begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1999,2000,2001 Jonathan Lemon<jlemon@FreeBSD.org>  * Copyright 2004 John-Mark Gurney<jmg@FreeBSD.org>  * Copyright (c) 2009 Apple, Inc.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"opt_ktrace.h"
end_include

begin_include
include|#
directive|include
file|"opt_kqueue.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/capsicum.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/rwlock.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/unistd.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/filedesc.h>
end_include

begin_include
include|#
directive|include
file|<sys/filio.h>
end_include

begin_include
include|#
directive|include
file|<sys/fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/kthread.h>
end_include

begin_include
include|#
directive|include
file|<sys/selinfo.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/event.h>
end_include

begin_include
include|#
directive|include
file|<sys/eventvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/poll.h>
end_include

begin_include
include|#
directive|include
file|<sys/protosw.h>
end_include

begin_include
include|#
directive|include
file|<sys/resourcevar.h>
end_include

begin_include
include|#
directive|include
file|<sys/sigio.h>
end_include

begin_include
include|#
directive|include
file|<sys/signalvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/socketvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysproto.h>
end_include

begin_include
include|#
directive|include
file|<sys/syscallsubr.h>
end_include

begin_include
include|#
directive|include
file|<sys/taskqueue.h>
end_include

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_include
include|#
directive|include
file|<sys/user.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|KTRACE
end_ifdef

begin_include
include|#
directive|include
file|<sys/ktrace.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<machine/atomic.h>
end_include

begin_include
include|#
directive|include
file|<vm/uma.h>
end_include

begin_expr_stmt
specifier|static
name|MALLOC_DEFINE
argument_list|(
name|M_KQUEUE
argument_list|,
literal|"kqueue"
argument_list|,
literal|"memory for kqueue system"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * This lock is used if multiple kq locks are required.  This possibly  * should be made into a per proc lock.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|mtx
name|kq_global
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|MTX_SYSINIT
argument_list|(
name|kq_global
argument_list|,
operator|&
name|kq_global
argument_list|,
literal|"kqueue order"
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|KQ_GLOBAL_LOCK
parameter_list|(
name|lck
parameter_list|,
name|haslck
parameter_list|)
value|do {	\ 	if (!haslck)				\ 		mtx_lock(lck);			\ 	haslck = 1;				\ } while (0)
end_define

begin_define
define|#
directive|define
name|KQ_GLOBAL_UNLOCK
parameter_list|(
name|lck
parameter_list|,
name|haslck
parameter_list|)
value|do {	\ 	if (haslck)				\ 		mtx_unlock(lck);			\ 	haslck = 0;				\ } while (0)
end_define

begin_expr_stmt
name|TASKQUEUE_DEFINE_THREAD
argument_list|(
name|kqueue_ctx
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function_decl
specifier|static
name|int
name|kevent_copyout
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|struct
name|kevent
modifier|*
name|kevp
parameter_list|,
name|int
name|count
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|kevent_copyin
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|struct
name|kevent
modifier|*
name|kevp
parameter_list|,
name|int
name|count
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|kqueue_register
parameter_list|(
name|struct
name|kqueue
modifier|*
name|kq
parameter_list|,
name|struct
name|kevent
modifier|*
name|kev
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|int
name|waitok
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|kqueue_acquire
parameter_list|(
name|struct
name|file
modifier|*
name|fp
parameter_list|,
name|struct
name|kqueue
modifier|*
modifier|*
name|kqp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|kqueue_release
parameter_list|(
name|struct
name|kqueue
modifier|*
name|kq
parameter_list|,
name|int
name|locked
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|kqueue_destroy
parameter_list|(
name|struct
name|kqueue
modifier|*
name|kq
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|kqueue_drain
parameter_list|(
name|struct
name|kqueue
modifier|*
name|kq
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|kqueue_expand
parameter_list|(
name|struct
name|kqueue
modifier|*
name|kq
parameter_list|,
name|struct
name|filterops
modifier|*
name|fops
parameter_list|,
name|uintptr_t
name|ident
parameter_list|,
name|int
name|waitok
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|kqueue_task
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|pending
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|kqueue_scan
parameter_list|(
name|struct
name|kqueue
modifier|*
name|kq
parameter_list|,
name|int
name|maxevents
parameter_list|,
name|struct
name|kevent_copyops
modifier|*
name|k_ops
parameter_list|,
specifier|const
name|struct
name|timespec
modifier|*
name|timeout
parameter_list|,
name|struct
name|kevent
modifier|*
name|keva
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|kqueue_wakeup
parameter_list|(
name|struct
name|kqueue
modifier|*
name|kq
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|filterops
modifier|*
name|kqueue_fo_find
parameter_list|(
name|int
name|filt
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|kqueue_fo_release
parameter_list|(
name|int
name|filt
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|fo_ioctl_t
name|kqueue_ioctl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|fo_poll_t
name|kqueue_poll
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|fo_kqfilter_t
name|kqueue_kqfilter
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|fo_stat_t
name|kqueue_stat
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|fo_close_t
name|kqueue_close
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|fo_fill_kinfo_t
name|kqueue_fill_kinfo
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|fileops
name|kqueueops
init|=
block|{
operator|.
name|fo_read
operator|=
name|invfo_rdwr
block|,
operator|.
name|fo_write
operator|=
name|invfo_rdwr
block|,
operator|.
name|fo_truncate
operator|=
name|invfo_truncate
block|,
operator|.
name|fo_ioctl
operator|=
name|kqueue_ioctl
block|,
operator|.
name|fo_poll
operator|=
name|kqueue_poll
block|,
operator|.
name|fo_kqfilter
operator|=
name|kqueue_kqfilter
block|,
operator|.
name|fo_stat
operator|=
name|kqueue_stat
block|,
operator|.
name|fo_close
operator|=
name|kqueue_close
block|,
operator|.
name|fo_chmod
operator|=
name|invfo_chmod
block|,
operator|.
name|fo_chown
operator|=
name|invfo_chown
block|,
operator|.
name|fo_sendfile
operator|=
name|invfo_sendfile
block|,
operator|.
name|fo_fill_kinfo
operator|=
name|kqueue_fill_kinfo
block|, }
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|knote_attach
parameter_list|(
name|struct
name|knote
modifier|*
name|kn
parameter_list|,
name|struct
name|kqueue
modifier|*
name|kq
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|knote_drop
parameter_list|(
name|struct
name|knote
modifier|*
name|kn
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|knote_enqueue
parameter_list|(
name|struct
name|knote
modifier|*
name|kn
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|knote_dequeue
parameter_list|(
name|struct
name|knote
modifier|*
name|kn
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|knote_init
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|knote
modifier|*
name|knote_alloc
parameter_list|(
name|int
name|waitok
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|knote_free
parameter_list|(
name|struct
name|knote
modifier|*
name|kn
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|filt_kqdetach
parameter_list|(
name|struct
name|knote
modifier|*
name|kn
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|filt_kqueue
parameter_list|(
name|struct
name|knote
modifier|*
name|kn
parameter_list|,
name|long
name|hint
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|filt_procattach
parameter_list|(
name|struct
name|knote
modifier|*
name|kn
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|filt_procdetach
parameter_list|(
name|struct
name|knote
modifier|*
name|kn
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|filt_proc
parameter_list|(
name|struct
name|knote
modifier|*
name|kn
parameter_list|,
name|long
name|hint
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|filt_fileattach
parameter_list|(
name|struct
name|knote
modifier|*
name|kn
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|filt_timerexpire
parameter_list|(
name|void
modifier|*
name|knx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|filt_timerattach
parameter_list|(
name|struct
name|knote
modifier|*
name|kn
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|filt_timerdetach
parameter_list|(
name|struct
name|knote
modifier|*
name|kn
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|filt_timer
parameter_list|(
name|struct
name|knote
modifier|*
name|kn
parameter_list|,
name|long
name|hint
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|filt_userattach
parameter_list|(
name|struct
name|knote
modifier|*
name|kn
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|filt_userdetach
parameter_list|(
name|struct
name|knote
modifier|*
name|kn
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|filt_user
parameter_list|(
name|struct
name|knote
modifier|*
name|kn
parameter_list|,
name|long
name|hint
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|filt_usertouch
parameter_list|(
name|struct
name|knote
modifier|*
name|kn
parameter_list|,
name|struct
name|kevent
modifier|*
name|kev
parameter_list|,
name|u_long
name|type
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|struct
name|filterops
name|file_filtops
init|=
block|{
operator|.
name|f_isfd
operator|=
literal|1
block|,
operator|.
name|f_attach
operator|=
name|filt_fileattach
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|filterops
name|kqread_filtops
init|=
block|{
operator|.
name|f_isfd
operator|=
literal|1
block|,
operator|.
name|f_detach
operator|=
name|filt_kqdetach
block|,
operator|.
name|f_event
operator|=
name|filt_kqueue
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* XXX - move to kern_proc.c?  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|filterops
name|proc_filtops
init|=
block|{
operator|.
name|f_isfd
operator|=
literal|0
block|,
operator|.
name|f_attach
operator|=
name|filt_procattach
block|,
operator|.
name|f_detach
operator|=
name|filt_procdetach
block|,
operator|.
name|f_event
operator|=
name|filt_proc
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|filterops
name|timer_filtops
init|=
block|{
operator|.
name|f_isfd
operator|=
literal|0
block|,
operator|.
name|f_attach
operator|=
name|filt_timerattach
block|,
operator|.
name|f_detach
operator|=
name|filt_timerdetach
block|,
operator|.
name|f_event
operator|=
name|filt_timer
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|filterops
name|user_filtops
init|=
block|{
operator|.
name|f_attach
operator|=
name|filt_userattach
block|,
operator|.
name|f_detach
operator|=
name|filt_userdetach
block|,
operator|.
name|f_event
operator|=
name|filt_user
block|,
operator|.
name|f_touch
operator|=
name|filt_usertouch
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|uma_zone_t
name|knote_zone
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|kq_ncallouts
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|kq_calloutmax
init|=
literal|4
operator|*
literal|1024
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_kern
argument_list|,
name|OID_AUTO
argument_list|,
name|kq_calloutmax
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|kq_calloutmax
argument_list|,
literal|0
argument_list|,
literal|"Maximum number of callouts allocated for kqueue"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* XXX - ensure not KN_INFLUX?? */
end_comment

begin_define
define|#
directive|define
name|KNOTE_ACTIVATE
parameter_list|(
name|kn
parameter_list|,
name|islock
parameter_list|)
value|do { 				\ 	if ((islock))							\ 		mtx_assert(&(kn)->kn_kq->kq_lock, MA_OWNED);		\ 	else								\ 		KQ_LOCK((kn)->kn_kq);					\ 	(kn)->kn_status |= KN_ACTIVE;					\ 	if (((kn)->kn_status& (KN_QUEUED | KN_DISABLED)) == 0)		\ 		knote_enqueue((kn));					\ 	if (!(islock))							\ 		KQ_UNLOCK((kn)->kn_kq);					\ } while(0)
end_define

begin_define
define|#
directive|define
name|KQ_LOCK
parameter_list|(
name|kq
parameter_list|)
value|do {						\ 	mtx_lock(&(kq)->kq_lock);					\ } while (0)
end_define

begin_define
define|#
directive|define
name|KQ_FLUX_WAKEUP
parameter_list|(
name|kq
parameter_list|)
value|do {						\ 	if (((kq)->kq_state& KQ_FLUXWAIT) == KQ_FLUXWAIT) {		\ 		(kq)->kq_state&= ~KQ_FLUXWAIT;				\ 		wakeup((kq));						\ 	}								\ } while (0)
end_define

begin_define
define|#
directive|define
name|KQ_UNLOCK_FLUX
parameter_list|(
name|kq
parameter_list|)
value|do {						\ 	KQ_FLUX_WAKEUP(kq);						\ 	mtx_unlock(&(kq)->kq_lock);					\ } while (0)
end_define

begin_define
define|#
directive|define
name|KQ_UNLOCK
parameter_list|(
name|kq
parameter_list|)
value|do {						\ 	mtx_unlock(&(kq)->kq_lock);					\ } while (0)
end_define

begin_define
define|#
directive|define
name|KQ_OWNED
parameter_list|(
name|kq
parameter_list|)
value|do {						\ 	mtx_assert(&(kq)->kq_lock, MA_OWNED);				\ } while (0)
end_define

begin_define
define|#
directive|define
name|KQ_NOTOWNED
parameter_list|(
name|kq
parameter_list|)
value|do {						\ 	mtx_assert(&(kq)->kq_lock, MA_NOTOWNED);			\ } while (0)
end_define

begin_function
specifier|static
name|struct
name|knlist
modifier|*
name|kn_list_lock
parameter_list|(
name|struct
name|knote
modifier|*
name|kn
parameter_list|)
block|{
name|struct
name|knlist
modifier|*
name|knl
decl_stmt|;
name|knl
operator|=
name|kn
operator|->
name|kn_knlist
expr_stmt|;
if|if
condition|(
name|knl
operator|!=
name|NULL
condition|)
name|knl
operator|->
name|kl_lock
argument_list|(
name|knl
operator|->
name|kl_lockarg
argument_list|)
expr_stmt|;
return|return
operator|(
name|knl
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|kn_list_unlock
parameter_list|(
name|struct
name|knlist
modifier|*
name|knl
parameter_list|)
block|{
name|bool
name|do_free
decl_stmt|;
if|if
condition|(
name|knl
operator|==
name|NULL
condition|)
return|return;
name|do_free
operator|=
name|knl
operator|->
name|kl_autodestroy
operator|&&
name|knlist_empty
argument_list|(
name|knl
argument_list|)
expr_stmt|;
name|knl
operator|->
name|kl_unlock
argument_list|(
name|knl
operator|->
name|kl_lockarg
argument_list|)
expr_stmt|;
if|if
condition|(
name|do_free
condition|)
block|{
name|knlist_destroy
argument_list|(
name|knl
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|knl
argument_list|,
name|M_KQUEUE
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_define
define|#
directive|define
name|KNL_ASSERT_LOCK
parameter_list|(
name|knl
parameter_list|,
name|islocked
parameter_list|)
value|do {				\ 	if (islocked)							\ 		KNL_ASSERT_LOCKED(knl);				\ 	else								\ 		KNL_ASSERT_UNLOCKED(knl);				\ } while (0)
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|INVARIANTS
end_ifdef

begin_define
define|#
directive|define
name|KNL_ASSERT_LOCKED
parameter_list|(
name|knl
parameter_list|)
value|do {					\ 	knl->kl_assert_locked((knl)->kl_lockarg);			\ } while (0)
end_define

begin_define
define|#
directive|define
name|KNL_ASSERT_UNLOCKED
parameter_list|(
name|knl
parameter_list|)
value|do {					\ 	knl->kl_assert_unlocked((knl)->kl_lockarg);			\ } while (0)
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* !INVARIANTS */
end_comment

begin_define
define|#
directive|define
name|KNL_ASSERT_LOCKED
parameter_list|(
name|knl
parameter_list|)
value|do {} while(0)
end_define

begin_define
define|#
directive|define
name|KNL_ASSERT_UNLOCKED
parameter_list|(
name|knl
parameter_list|)
value|do {} while (0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* INVARIANTS */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|KN_HASHSIZE
end_ifndef

begin_define
define|#
directive|define
name|KN_HASHSIZE
value|64
end_define

begin_comment
comment|/* XXX should be tunable */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|KN_HASH
parameter_list|(
name|val
parameter_list|,
name|mask
parameter_list|)
value|(((val) ^ (val>> 8))& (mask))
end_define

begin_function
specifier|static
name|int
name|filt_nullattach
parameter_list|(
name|struct
name|knote
modifier|*
name|kn
parameter_list|)
block|{
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
end_function

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_decl_stmt
name|struct
name|filterops
name|null_filtops
init|=
block|{
operator|.
name|f_isfd
operator|=
literal|0
block|,
operator|.
name|f_attach
operator|=
name|filt_nullattach
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* XXX - make SYSINIT to add these, and move into respective modules. */
end_comment

begin_decl_stmt
specifier|extern
name|struct
name|filterops
name|sig_filtops
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|filterops
name|fs_filtops
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Table for for all system-defined filters.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|mtx
name|filterops_lock
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|MTX_SYSINIT
argument_list|(
name|kqueue_filterops
argument_list|,
operator|&
name|filterops_lock
argument_list|,
literal|"protect sysfilt_ops"
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
end_expr_stmt

begin_struct
specifier|static
struct|struct
block|{
name|struct
name|filterops
modifier|*
name|for_fop
decl_stmt|;
name|int
name|for_nolock
decl_stmt|;
name|int
name|for_refcnt
decl_stmt|;
block|}
name|sysfilt_ops
index|[
name|EVFILT_SYSCOUNT
index|]
init|=
block|{
block|{
operator|&
name|file_filtops
block|,
literal|1
block|}
block|,
comment|/* EVFILT_READ */
block|{
operator|&
name|file_filtops
block|,
literal|1
block|}
block|,
comment|/* EVFILT_WRITE */
block|{
operator|&
name|null_filtops
block|}
block|,
comment|/* EVFILT_AIO */
block|{
operator|&
name|file_filtops
block|,
literal|1
block|}
block|,
comment|/* EVFILT_VNODE */
block|{
operator|&
name|proc_filtops
block|,
literal|1
block|}
block|,
comment|/* EVFILT_PROC */
block|{
operator|&
name|sig_filtops
block|,
literal|1
block|}
block|,
comment|/* EVFILT_SIGNAL */
block|{
operator|&
name|timer_filtops
block|,
literal|1
block|}
block|,
comment|/* EVFILT_TIMER */
block|{
operator|&
name|file_filtops
block|,
literal|1
block|}
block|,
comment|/* EVFILT_PROCDESC */
block|{
operator|&
name|fs_filtops
block|,
literal|1
block|}
block|,
comment|/* EVFILT_FS */
block|{
operator|&
name|null_filtops
block|}
block|,
comment|/* EVFILT_LIO */
block|{
operator|&
name|user_filtops
block|,
literal|1
block|}
block|,
comment|/* EVFILT_USER */
block|{
operator|&
name|null_filtops
block|}
block|,
comment|/* EVFILT_SENDFILE */
block|}
struct|;
end_struct

begin_comment
comment|/*  * Simple redirection for all cdevsw style objects to call their fo_kqfilter  * method.  */
end_comment

begin_function
specifier|static
name|int
name|filt_fileattach
parameter_list|(
name|struct
name|knote
modifier|*
name|kn
parameter_list|)
block|{
return|return
operator|(
name|fo_kqfilter
argument_list|(
name|kn
operator|->
name|kn_fp
argument_list|,
name|kn
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|int
name|kqueue_kqfilter
parameter_list|(
name|struct
name|file
modifier|*
name|fp
parameter_list|,
name|struct
name|knote
modifier|*
name|kn
parameter_list|)
block|{
name|struct
name|kqueue
modifier|*
name|kq
init|=
name|kn
operator|->
name|kn_fp
operator|->
name|f_data
decl_stmt|;
if|if
condition|(
name|kn
operator|->
name|kn_filter
operator|!=
name|EVFILT_READ
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|kn
operator|->
name|kn_status
operator||=
name|KN_KQUEUE
expr_stmt|;
name|kn
operator|->
name|kn_fop
operator|=
operator|&
name|kqread_filtops
expr_stmt|;
name|knlist_add
argument_list|(
operator|&
name|kq
operator|->
name|kq_sel
operator|.
name|si_note
argument_list|,
name|kn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|filt_kqdetach
parameter_list|(
name|struct
name|knote
modifier|*
name|kn
parameter_list|)
block|{
name|struct
name|kqueue
modifier|*
name|kq
init|=
name|kn
operator|->
name|kn_fp
operator|->
name|f_data
decl_stmt|;
name|knlist_remove
argument_list|(
operator|&
name|kq
operator|->
name|kq_sel
operator|.
name|si_note
argument_list|,
name|kn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|int
name|filt_kqueue
parameter_list|(
name|struct
name|knote
modifier|*
name|kn
parameter_list|,
name|long
name|hint
parameter_list|)
block|{
name|struct
name|kqueue
modifier|*
name|kq
init|=
name|kn
operator|->
name|kn_fp
operator|->
name|f_data
decl_stmt|;
name|kn
operator|->
name|kn_data
operator|=
name|kq
operator|->
name|kq_count
expr_stmt|;
return|return
operator|(
name|kn
operator|->
name|kn_data
operator|>
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* XXX - move to kern_proc.c?  */
end_comment

begin_function
specifier|static
name|int
name|filt_procattach
parameter_list|(
name|struct
name|knote
modifier|*
name|kn
parameter_list|)
block|{
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|int
name|error
decl_stmt|;
name|bool
name|exiting
decl_stmt|,
name|immediate
decl_stmt|;
name|exiting
operator|=
name|immediate
operator|=
name|false
expr_stmt|;
name|p
operator|=
name|pfind
argument_list|(
name|kn
operator|->
name|kn_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
operator|&&
operator|(
name|kn
operator|->
name|kn_sfflags
operator|&
name|NOTE_EXIT
operator|)
condition|)
block|{
name|p
operator|=
name|zpfind
argument_list|(
name|kn
operator|->
name|kn_id
argument_list|)
expr_stmt|;
name|exiting
operator|=
name|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p
operator|!=
name|NULL
operator|&&
operator|(
name|p
operator|->
name|p_flag
operator|&
name|P_WEXIT
operator|)
condition|)
block|{
name|exiting
operator|=
name|true
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
return|return
operator|(
name|ESRCH
operator|)
return|;
if|if
condition|(
operator|(
name|error
operator|=
name|p_cansee
argument_list|(
name|curthread
argument_list|,
name|p
argument_list|)
operator|)
condition|)
block|{
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|kn
operator|->
name|kn_ptr
operator|.
name|p_proc
operator|=
name|p
expr_stmt|;
name|kn
operator|->
name|kn_flags
operator||=
name|EV_CLEAR
expr_stmt|;
comment|/* automatically set */
comment|/* 	 * Internal flag indicating registration done by kernel for the 	 * purposes of getting a NOTE_CHILD notification. 	 */
if|if
condition|(
name|kn
operator|->
name|kn_flags
operator|&
name|EV_FLAG2
condition|)
block|{
name|kn
operator|->
name|kn_flags
operator|&=
operator|~
name|EV_FLAG2
expr_stmt|;
name|kn
operator|->
name|kn_data
operator|=
name|kn
operator|->
name|kn_sdata
expr_stmt|;
comment|/* ppid */
name|kn
operator|->
name|kn_fflags
operator|=
name|NOTE_CHILD
expr_stmt|;
name|kn
operator|->
name|kn_sfflags
operator|&=
operator|~
operator|(
name|NOTE_EXIT
operator||
name|NOTE_EXEC
operator||
name|NOTE_FORK
operator|)
expr_stmt|;
name|immediate
operator|=
name|true
expr_stmt|;
comment|/* Force immediate activation of child note. */
block|}
comment|/* 	 * Internal flag indicating registration done by kernel (for other than 	 * NOTE_CHILD). 	 */
if|if
condition|(
name|kn
operator|->
name|kn_flags
operator|&
name|EV_FLAG1
condition|)
block|{
name|kn
operator|->
name|kn_flags
operator|&=
operator|~
name|EV_FLAG1
expr_stmt|;
block|}
name|knlist_add
argument_list|(
name|p
operator|->
name|p_klist
argument_list|,
name|kn
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* 	 * Immediately activate any child notes or, in the case of a zombie 	 * target process, exit notes.  The latter is necessary to handle the 	 * case where the target process, e.g. a child, dies before the kevent 	 * is registered. 	 */
if|if
condition|(
name|immediate
operator|||
operator|(
name|exiting
operator|&&
name|filt_proc
argument_list|(
name|kn
argument_list|,
name|NOTE_EXIT
argument_list|)
operator|)
condition|)
name|KNOTE_ACTIVATE
argument_list|(
name|kn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * The knote may be attached to a different process, which may exit,  * leaving nothing for the knote to be attached to.  So when the process  * exits, the knote is marked as DETACHED and also flagged as ONESHOT so  * it will be deleted when read out.  However, as part of the knote deletion,  * this routine is called, so a check is needed to avoid actually performing  * a detach, because the original process does not exist any more.  */
end_comment

begin_comment
comment|/* XXX - move to kern_proc.c?  */
end_comment

begin_function
specifier|static
name|void
name|filt_procdetach
parameter_list|(
name|struct
name|knote
modifier|*
name|kn
parameter_list|)
block|{
name|knlist_remove
argument_list|(
name|kn
operator|->
name|kn_knlist
argument_list|,
name|kn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|kn
operator|->
name|kn_ptr
operator|.
name|p_proc
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* XXX - move to kern_proc.c?  */
end_comment

begin_function
specifier|static
name|int
name|filt_proc
parameter_list|(
name|struct
name|knote
modifier|*
name|kn
parameter_list|,
name|long
name|hint
parameter_list|)
block|{
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|u_int
name|event
decl_stmt|;
name|p
operator|=
name|kn
operator|->
name|kn_ptr
operator|.
name|p_proc
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
comment|/* already activated, from attach filter */
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Mask off extra data. */
name|event
operator|=
operator|(
name|u_int
operator|)
name|hint
operator|&
name|NOTE_PCTRLMASK
expr_stmt|;
comment|/* If the user is interested in this event, record it. */
if|if
condition|(
name|kn
operator|->
name|kn_sfflags
operator|&
name|event
condition|)
name|kn
operator|->
name|kn_fflags
operator||=
name|event
expr_stmt|;
comment|/* Process is gone, so flag the event as finished. */
if|if
condition|(
name|event
operator|==
name|NOTE_EXIT
condition|)
block|{
name|kn
operator|->
name|kn_flags
operator||=
name|EV_EOF
operator||
name|EV_ONESHOT
expr_stmt|;
name|kn
operator|->
name|kn_ptr
operator|.
name|p_proc
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|kn
operator|->
name|kn_fflags
operator|&
name|NOTE_EXIT
condition|)
name|kn
operator|->
name|kn_data
operator|=
name|KW_EXITCODE
argument_list|(
name|p
operator|->
name|p_xexit
argument_list|,
name|p
operator|->
name|p_xsig
argument_list|)
expr_stmt|;
if|if
condition|(
name|kn
operator|->
name|kn_fflags
operator|==
literal|0
condition|)
name|kn
operator|->
name|kn_flags
operator||=
name|EV_DROP
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
name|kn
operator|->
name|kn_fflags
operator|!=
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Called when the process forked. It mostly does the same as the  * knote(), activating all knotes registered to be activated when the  * process forked. Additionally, for each knote attached to the  * parent, check whether user wants to track the new process. If so  * attach a new knote to it, and immediately report an event with the  * child's pid.  */
end_comment

begin_function
name|void
name|knote_fork
parameter_list|(
name|struct
name|knlist
modifier|*
name|list
parameter_list|,
name|int
name|pid
parameter_list|)
block|{
name|struct
name|kqueue
modifier|*
name|kq
decl_stmt|;
name|struct
name|knote
modifier|*
name|kn
decl_stmt|;
name|struct
name|kevent
name|kev
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|list
operator|==
name|NULL
condition|)
return|return;
name|list
operator|->
name|kl_lock
argument_list|(
name|list
operator|->
name|kl_lockarg
argument_list|)
expr_stmt|;
name|SLIST_FOREACH
argument_list|(
argument|kn
argument_list|,
argument|&list->kl_list
argument_list|,
argument|kn_selnext
argument_list|)
block|{
name|kq
operator|=
name|kn
operator|->
name|kn_kq
expr_stmt|;
name|KQ_LOCK
argument_list|(
name|kq
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|kn
operator|->
name|kn_status
operator|&
operator|(
name|KN_INFLUX
operator||
name|KN_SCAN
operator|)
operator|)
operator|==
name|KN_INFLUX
condition|)
block|{
name|KQ_UNLOCK
argument_list|(
name|kq
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * The same as knote(), activate the event. 		 */
if|if
condition|(
operator|(
name|kn
operator|->
name|kn_sfflags
operator|&
name|NOTE_TRACK
operator|)
operator|==
literal|0
condition|)
block|{
name|kn
operator|->
name|kn_status
operator||=
name|KN_HASKQLOCK
expr_stmt|;
if|if
condition|(
name|kn
operator|->
name|kn_fop
operator|->
name|f_event
argument_list|(
name|kn
argument_list|,
name|NOTE_FORK
argument_list|)
condition|)
name|KNOTE_ACTIVATE
argument_list|(
name|kn
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|kn
operator|->
name|kn_status
operator|&=
operator|~
name|KN_HASKQLOCK
expr_stmt|;
name|KQ_UNLOCK
argument_list|(
name|kq
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * The NOTE_TRACK case. In addition to the activation 		 * of the event, we need to register new events to 		 * track the child. Drop the locks in preparation for 		 * the call to kqueue_register(). 		 */
name|kn
operator|->
name|kn_status
operator||=
name|KN_INFLUX
expr_stmt|;
name|KQ_UNLOCK
argument_list|(
name|kq
argument_list|)
expr_stmt|;
name|list
operator|->
name|kl_unlock
argument_list|(
name|list
operator|->
name|kl_lockarg
argument_list|)
expr_stmt|;
comment|/* 		 * Activate existing knote and register tracking knotes with 		 * new process. 		 * 		 * First register a knote to get just the child notice. This 		 * must be a separate note from a potential NOTE_EXIT 		 * notification since both NOTE_CHILD and NOTE_EXIT are defined 		 * to use the data field (in conflicting ways). 		 */
name|kev
operator|.
name|ident
operator|=
name|pid
expr_stmt|;
name|kev
operator|.
name|filter
operator|=
name|kn
operator|->
name|kn_filter
expr_stmt|;
name|kev
operator|.
name|flags
operator|=
name|kn
operator|->
name|kn_flags
operator||
name|EV_ADD
operator||
name|EV_ENABLE
operator||
name|EV_ONESHOT
operator||
name|EV_FLAG2
expr_stmt|;
name|kev
operator|.
name|fflags
operator|=
name|kn
operator|->
name|kn_sfflags
expr_stmt|;
name|kev
operator|.
name|data
operator|=
name|kn
operator|->
name|kn_id
expr_stmt|;
comment|/* parent */
name|kev
operator|.
name|udata
operator|=
name|kn
operator|->
name|kn_kevent
operator|.
name|udata
expr_stmt|;
comment|/* preserve udata */
name|error
operator|=
name|kqueue_register
argument_list|(
name|kq
argument_list|,
operator|&
name|kev
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|kn
operator|->
name|kn_fflags
operator||=
name|NOTE_TRACKERR
expr_stmt|;
comment|/* 		 * Then register another knote to track other potential events 		 * from the new process. 		 */
name|kev
operator|.
name|ident
operator|=
name|pid
expr_stmt|;
name|kev
operator|.
name|filter
operator|=
name|kn
operator|->
name|kn_filter
expr_stmt|;
name|kev
operator|.
name|flags
operator|=
name|kn
operator|->
name|kn_flags
operator||
name|EV_ADD
operator||
name|EV_ENABLE
operator||
name|EV_FLAG1
expr_stmt|;
name|kev
operator|.
name|fflags
operator|=
name|kn
operator|->
name|kn_sfflags
expr_stmt|;
name|kev
operator|.
name|data
operator|=
name|kn
operator|->
name|kn_id
expr_stmt|;
comment|/* parent */
name|kev
operator|.
name|udata
operator|=
name|kn
operator|->
name|kn_kevent
operator|.
name|udata
expr_stmt|;
comment|/* preserve udata */
name|error
operator|=
name|kqueue_register
argument_list|(
name|kq
argument_list|,
operator|&
name|kev
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|kn
operator|->
name|kn_fflags
operator||=
name|NOTE_TRACKERR
expr_stmt|;
if|if
condition|(
name|kn
operator|->
name|kn_fop
operator|->
name|f_event
argument_list|(
name|kn
argument_list|,
name|NOTE_FORK
argument_list|)
condition|)
name|KNOTE_ACTIVATE
argument_list|(
name|kn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|KQ_LOCK
argument_list|(
name|kq
argument_list|)
expr_stmt|;
name|kn
operator|->
name|kn_status
operator|&=
operator|~
name|KN_INFLUX
expr_stmt|;
name|KQ_UNLOCK_FLUX
argument_list|(
name|kq
argument_list|)
expr_stmt|;
name|list
operator|->
name|kl_lock
argument_list|(
name|list
operator|->
name|kl_lockarg
argument_list|)
expr_stmt|;
block|}
name|list
operator|->
name|kl_unlock
argument_list|(
name|list
operator|->
name|kl_lockarg
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * XXX: EVFILT_TIMER should perhaps live in kern_time.c beside the  * interval timer support code.  */
end_comment

begin_define
define|#
directive|define
name|NOTE_TIMER_PRECMASK
value|(NOTE_SECONDS|NOTE_MSECONDS|NOTE_USECONDS| \ 				NOTE_NSECONDS)
end_define

begin_function
specifier|static
name|sbintime_t
name|timer2sbintime
parameter_list|(
name|intptr_t
name|data
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
comment|/*          * Macros for converting to the fractional second portion of an          * sbintime_t using 64bit multiplication to improve precision.          */
define|#
directive|define
name|NS_TO_SBT
parameter_list|(
name|ns
parameter_list|)
value|(((ns) * (((uint64_t)1<< 63) / 500000000))>> 32)
define|#
directive|define
name|US_TO_SBT
parameter_list|(
name|us
parameter_list|)
value|(((us) * (((uint64_t)1<< 63) / 500000))>> 32)
define|#
directive|define
name|MS_TO_SBT
parameter_list|(
name|ms
parameter_list|)
value|(((ms) * (((uint64_t)1<< 63) / 500))>> 32)
switch|switch
condition|(
name|flags
operator|&
name|NOTE_TIMER_PRECMASK
condition|)
block|{
case|case
name|NOTE_SECONDS
case|:
ifdef|#
directive|ifdef
name|__LP64__
if|if
condition|(
name|data
operator|>
operator|(
name|SBT_MAX
operator|/
name|SBT_1S
operator|)
condition|)
return|return
name|SBT_MAX
return|;
endif|#
directive|endif
return|return
operator|(
operator|(
name|sbintime_t
operator|)
name|data
operator|<<
literal|32
operator|)
return|;
case|case
name|NOTE_MSECONDS
case|:
comment|/* FALLTHROUGH */
case|case
literal|0
case|:
if|if
condition|(
name|data
operator|>=
literal|1000
condition|)
block|{
name|int64_t
name|secs
init|=
name|data
operator|/
literal|1000
decl_stmt|;
ifdef|#
directive|ifdef
name|__LP64__
if|if
condition|(
name|secs
operator|>
operator|(
name|SBT_MAX
operator|/
name|SBT_1S
operator|)
condition|)
return|return
name|SBT_MAX
return|;
endif|#
directive|endif
return|return
operator|(
name|secs
operator|<<
literal|32
operator||
name|MS_TO_SBT
argument_list|(
name|data
operator|%
literal|1000
argument_list|)
operator|)
return|;
block|}
return|return
name|MS_TO_SBT
argument_list|(
name|data
argument_list|)
return|;
case|case
name|NOTE_USECONDS
case|:
if|if
condition|(
name|data
operator|>=
literal|1000000
condition|)
block|{
name|int64_t
name|secs
init|=
name|data
operator|/
literal|1000000
decl_stmt|;
ifdef|#
directive|ifdef
name|__LP64__
if|if
condition|(
name|secs
operator|>
operator|(
name|SBT_MAX
operator|/
name|SBT_1S
operator|)
condition|)
return|return
name|SBT_MAX
return|;
endif|#
directive|endif
return|return
operator|(
name|secs
operator|<<
literal|32
operator||
name|US_TO_SBT
argument_list|(
name|data
operator|%
literal|1000000
argument_list|)
operator|)
return|;
block|}
return|return
name|US_TO_SBT
argument_list|(
name|data
argument_list|)
return|;
case|case
name|NOTE_NSECONDS
case|:
if|if
condition|(
name|data
operator|>=
literal|1000000000
condition|)
block|{
name|int64_t
name|secs
init|=
name|data
operator|/
literal|1000000000
decl_stmt|;
ifdef|#
directive|ifdef
name|__LP64__
if|if
condition|(
name|secs
operator|>
operator|(
name|SBT_MAX
operator|/
name|SBT_1S
operator|)
condition|)
return|return
name|SBT_MAX
return|;
endif|#
directive|endif
return|return
operator|(
name|secs
operator|<<
literal|32
operator||
name|US_TO_SBT
argument_list|(
name|data
operator|%
literal|1000000000
argument_list|)
operator|)
return|;
block|}
return|return
name|NS_TO_SBT
argument_list|(
name|data
argument_list|)
return|;
default|default:
break|break;
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|filt_timerexpire
parameter_list|(
name|void
modifier|*
name|knx
parameter_list|)
block|{
name|struct
name|callout
modifier|*
name|calloutp
decl_stmt|;
name|struct
name|knote
modifier|*
name|kn
decl_stmt|;
name|kn
operator|=
name|knx
expr_stmt|;
name|kn
operator|->
name|kn_data
operator|++
expr_stmt|;
name|KNOTE_ACTIVATE
argument_list|(
name|kn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* XXX - handle locking */
if|if
condition|(
operator|(
name|kn
operator|->
name|kn_flags
operator|&
name|EV_ONESHOT
operator|)
operator|!=
name|EV_ONESHOT
condition|)
block|{
name|calloutp
operator|=
operator|(
expr|struct
name|callout
operator|*
operator|)
name|kn
operator|->
name|kn_hook
expr_stmt|;
operator|*
name|kn
operator|->
name|kn_ptr
operator|.
name|p_nexttime
operator|+=
name|timer2sbintime
argument_list|(
name|kn
operator|->
name|kn_sdata
argument_list|,
name|kn
operator|->
name|kn_sfflags
argument_list|)
expr_stmt|;
name|callout_reset_sbt_on
argument_list|(
name|calloutp
argument_list|,
operator|*
name|kn
operator|->
name|kn_ptr
operator|.
name|p_nexttime
argument_list|,
literal|0
argument_list|,
name|filt_timerexpire
argument_list|,
name|kn
argument_list|,
name|PCPU_GET
argument_list|(
name|cpuid
argument_list|)
argument_list|,
name|C_ABSOLUTE
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * data contains amount of time to sleep  */
end_comment

begin_function
specifier|static
name|int
name|filt_timerattach
parameter_list|(
name|struct
name|knote
modifier|*
name|kn
parameter_list|)
block|{
name|struct
name|callout
modifier|*
name|calloutp
decl_stmt|;
name|sbintime_t
name|to
decl_stmt|;
name|unsigned
name|int
name|ncallouts
decl_stmt|;
if|if
condition|(
operator|(
name|intptr_t
operator|)
name|kn
operator|->
name|kn_sdata
operator|<
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
operator|(
name|intptr_t
operator|)
name|kn
operator|->
name|kn_sdata
operator|==
literal|0
operator|&&
operator|(
name|kn
operator|->
name|kn_flags
operator|&
name|EV_ONESHOT
operator|)
operator|==
literal|0
condition|)
name|kn
operator|->
name|kn_sdata
operator|=
literal|1
expr_stmt|;
comment|/* Only precision unit are supported in flags so far */
if|if
condition|(
name|kn
operator|->
name|kn_sfflags
operator|&
operator|~
name|NOTE_TIMER_PRECMASK
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|to
operator|=
name|timer2sbintime
argument_list|(
name|kn
operator|->
name|kn_sdata
argument_list|,
name|kn
operator|->
name|kn_sfflags
argument_list|)
expr_stmt|;
if|if
condition|(
name|to
operator|<
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
do|do
block|{
name|ncallouts
operator|=
name|kq_ncallouts
expr_stmt|;
if|if
condition|(
name|ncallouts
operator|>=
name|kq_calloutmax
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
do|while
condition|(
operator|!
name|atomic_cmpset_int
argument_list|(
operator|&
name|kq_ncallouts
argument_list|,
name|ncallouts
argument_list|,
name|ncallouts
operator|+
literal|1
argument_list|)
condition|)
do|;
name|kn
operator|->
name|kn_flags
operator||=
name|EV_CLEAR
expr_stmt|;
comment|/* automatically set */
name|kn
operator|->
name|kn_status
operator|&=
operator|~
name|KN_DETACHED
expr_stmt|;
comment|/* knlist_add clears it */
name|kn
operator|->
name|kn_ptr
operator|.
name|p_nexttime
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|sbintime_t
argument_list|)
argument_list|,
name|M_KQUEUE
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|calloutp
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|calloutp
argument_list|)
argument_list|,
name|M_KQUEUE
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|callout_init
argument_list|(
name|calloutp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|kn
operator|->
name|kn_hook
operator|=
name|calloutp
expr_stmt|;
operator|*
name|kn
operator|->
name|kn_ptr
operator|.
name|p_nexttime
operator|=
name|to
operator|+
name|sbinuptime
argument_list|()
expr_stmt|;
name|callout_reset_sbt_on
argument_list|(
name|calloutp
argument_list|,
operator|*
name|kn
operator|->
name|kn_ptr
operator|.
name|p_nexttime
argument_list|,
literal|0
argument_list|,
name|filt_timerexpire
argument_list|,
name|kn
argument_list|,
name|PCPU_GET
argument_list|(
name|cpuid
argument_list|)
argument_list|,
name|C_ABSOLUTE
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|filt_timerdetach
parameter_list|(
name|struct
name|knote
modifier|*
name|kn
parameter_list|)
block|{
name|struct
name|callout
modifier|*
name|calloutp
decl_stmt|;
name|unsigned
name|int
name|old
decl_stmt|;
name|calloutp
operator|=
operator|(
expr|struct
name|callout
operator|*
operator|)
name|kn
operator|->
name|kn_hook
expr_stmt|;
name|callout_drain
argument_list|(
name|calloutp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|calloutp
argument_list|,
name|M_KQUEUE
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|kn
operator|->
name|kn_ptr
operator|.
name|p_nexttime
argument_list|,
name|M_KQUEUE
argument_list|)
expr_stmt|;
name|old
operator|=
name|atomic_fetchadd_int
argument_list|(
operator|&
name|kq_ncallouts
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|old
operator|>
literal|0
argument_list|,
operator|(
literal|"Number of callouts cannot become negative"
operator|)
argument_list|)
expr_stmt|;
name|kn
operator|->
name|kn_status
operator||=
name|KN_DETACHED
expr_stmt|;
comment|/* knlist_remove sets it */
block|}
end_function

begin_function
specifier|static
name|int
name|filt_timer
parameter_list|(
name|struct
name|knote
modifier|*
name|kn
parameter_list|,
name|long
name|hint
parameter_list|)
block|{
return|return
operator|(
name|kn
operator|->
name|kn_data
operator|!=
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|filt_userattach
parameter_list|(
name|struct
name|knote
modifier|*
name|kn
parameter_list|)
block|{
comment|/*  	 * EVFILT_USER knotes are not attached to anything in the kernel. 	 */
name|kn
operator|->
name|kn_hook
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|kn
operator|->
name|kn_fflags
operator|&
name|NOTE_TRIGGER
condition|)
name|kn
operator|->
name|kn_hookid
operator|=
literal|1
expr_stmt|;
else|else
name|kn
operator|->
name|kn_hookid
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|filt_userdetach
parameter_list|(
name|__unused
name|struct
name|knote
modifier|*
name|kn
parameter_list|)
block|{
comment|/* 	 * EVFILT_USER knotes are not attached to anything in the kernel. 	 */
block|}
end_function

begin_function
specifier|static
name|int
name|filt_user
parameter_list|(
name|struct
name|knote
modifier|*
name|kn
parameter_list|,
name|__unused
name|long
name|hint
parameter_list|)
block|{
return|return
operator|(
name|kn
operator|->
name|kn_hookid
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|filt_usertouch
parameter_list|(
name|struct
name|knote
modifier|*
name|kn
parameter_list|,
name|struct
name|kevent
modifier|*
name|kev
parameter_list|,
name|u_long
name|type
parameter_list|)
block|{
name|u_int
name|ffctrl
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|EVENT_REGISTER
case|:
if|if
condition|(
name|kev
operator|->
name|fflags
operator|&
name|NOTE_TRIGGER
condition|)
name|kn
operator|->
name|kn_hookid
operator|=
literal|1
expr_stmt|;
name|ffctrl
operator|=
name|kev
operator|->
name|fflags
operator|&
name|NOTE_FFCTRLMASK
expr_stmt|;
name|kev
operator|->
name|fflags
operator|&=
name|NOTE_FFLAGSMASK
expr_stmt|;
switch|switch
condition|(
name|ffctrl
condition|)
block|{
case|case
name|NOTE_FFNOP
case|:
break|break;
case|case
name|NOTE_FFAND
case|:
name|kn
operator|->
name|kn_sfflags
operator|&=
name|kev
operator|->
name|fflags
expr_stmt|;
break|break;
case|case
name|NOTE_FFOR
case|:
name|kn
operator|->
name|kn_sfflags
operator||=
name|kev
operator|->
name|fflags
expr_stmt|;
break|break;
case|case
name|NOTE_FFCOPY
case|:
name|kn
operator|->
name|kn_sfflags
operator|=
name|kev
operator|->
name|fflags
expr_stmt|;
break|break;
default|default:
comment|/* XXX Return error? */
break|break;
block|}
name|kn
operator|->
name|kn_sdata
operator|=
name|kev
operator|->
name|data
expr_stmt|;
if|if
condition|(
name|kev
operator|->
name|flags
operator|&
name|EV_CLEAR
condition|)
block|{
name|kn
operator|->
name|kn_hookid
operator|=
literal|0
expr_stmt|;
name|kn
operator|->
name|kn_data
operator|=
literal|0
expr_stmt|;
name|kn
operator|->
name|kn_fflags
operator|=
literal|0
expr_stmt|;
block|}
break|break;
case|case
name|EVENT_PROCESS
case|:
operator|*
name|kev
operator|=
name|kn
operator|->
name|kn_kevent
expr_stmt|;
name|kev
operator|->
name|fflags
operator|=
name|kn
operator|->
name|kn_sfflags
expr_stmt|;
name|kev
operator|->
name|data
operator|=
name|kn
operator|->
name|kn_sdata
expr_stmt|;
if|if
condition|(
name|kn
operator|->
name|kn_flags
operator|&
name|EV_CLEAR
condition|)
block|{
name|kn
operator|->
name|kn_hookid
operator|=
literal|0
expr_stmt|;
name|kn
operator|->
name|kn_data
operator|=
literal|0
expr_stmt|;
name|kn
operator|->
name|kn_fflags
operator|=
literal|0
expr_stmt|;
block|}
break|break;
default|default:
name|panic
argument_list|(
literal|"filt_usertouch() - invalid type (%ld)"
argument_list|,
name|type
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
name|int
name|sys_kqueue
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|kqueue_args
modifier|*
name|uap
parameter_list|)
block|{
return|return
operator|(
name|kern_kqueue
argument_list|(
name|td
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|kqueue_init
parameter_list|(
name|struct
name|kqueue
modifier|*
name|kq
parameter_list|)
block|{
name|mtx_init
argument_list|(
operator|&
name|kq
operator|->
name|kq_lock
argument_list|,
literal|"kqueue"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
operator||
name|MTX_DUPOK
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|kq
operator|->
name|kq_head
argument_list|)
expr_stmt|;
name|knlist_init_mtx
argument_list|(
operator|&
name|kq
operator|->
name|kq_sel
operator|.
name|si_note
argument_list|,
operator|&
name|kq
operator|->
name|kq_lock
argument_list|)
expr_stmt|;
name|TASK_INIT
argument_list|(
operator|&
name|kq
operator|->
name|kq_task
argument_list|,
literal|0
argument_list|,
name|kqueue_task
argument_list|,
name|kq
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|kern_kqueue
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|int
name|flags
parameter_list|,
name|struct
name|filecaps
modifier|*
name|fcaps
parameter_list|)
block|{
name|struct
name|filedesc
modifier|*
name|fdp
decl_stmt|;
name|struct
name|kqueue
modifier|*
name|kq
decl_stmt|;
name|struct
name|file
modifier|*
name|fp
decl_stmt|;
name|struct
name|ucred
modifier|*
name|cred
decl_stmt|;
name|int
name|fd
decl_stmt|,
name|error
decl_stmt|;
name|fdp
operator|=
name|td
operator|->
name|td_proc
operator|->
name|p_fd
expr_stmt|;
name|cred
operator|=
name|td
operator|->
name|td_ucred
expr_stmt|;
if|if
condition|(
operator|!
name|chgkqcnt
argument_list|(
name|cred
operator|->
name|cr_ruidinfo
argument_list|,
literal|1
argument_list|,
name|lim_cur
argument_list|(
name|td
argument_list|,
name|RLIMIT_KQUEUES
argument_list|)
argument_list|)
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|error
operator|=
name|falloc_caps
argument_list|(
name|td
argument_list|,
operator|&
name|fp
argument_list|,
operator|&
name|fd
argument_list|,
name|flags
argument_list|,
name|fcaps
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|chgkqcnt
argument_list|(
name|cred
operator|->
name|cr_ruidinfo
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* An extra reference on `fp' has been held for us by falloc(). */
name|kq
operator|=
name|malloc
argument_list|(
sizeof|sizeof
expr|*
name|kq
argument_list|,
name|M_KQUEUE
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|kqueue_init
argument_list|(
name|kq
argument_list|)
expr_stmt|;
name|kq
operator|->
name|kq_fdp
operator|=
name|fdp
expr_stmt|;
name|kq
operator|->
name|kq_cred
operator|=
name|crhold
argument_list|(
name|cred
argument_list|)
expr_stmt|;
name|FILEDESC_XLOCK
argument_list|(
name|fdp
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|fdp
operator|->
name|fd_kqlist
argument_list|,
name|kq
argument_list|,
name|kq_list
argument_list|)
expr_stmt|;
name|FILEDESC_XUNLOCK
argument_list|(
name|fdp
argument_list|)
expr_stmt|;
name|finit
argument_list|(
name|fp
argument_list|,
name|FREAD
operator||
name|FWRITE
argument_list|,
name|DTYPE_KQUEUE
argument_list|,
name|kq
argument_list|,
operator|&
name|kqueueops
argument_list|)
expr_stmt|;
name|fdrop
argument_list|(
name|fp
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|=
name|fd
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|_SYS_SYSPROTO_H_
end_ifndef

begin_struct
struct|struct
name|kevent_args
block|{
name|int
name|fd
decl_stmt|;
specifier|const
name|struct
name|kevent
modifier|*
name|changelist
decl_stmt|;
name|int
name|nchanges
decl_stmt|;
name|struct
name|kevent
modifier|*
name|eventlist
decl_stmt|;
name|int
name|nevents
decl_stmt|;
specifier|const
name|struct
name|timespec
modifier|*
name|timeout
decl_stmt|;
block|}
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|sys_kevent
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|kevent_args
modifier|*
name|uap
parameter_list|)
block|{
name|struct
name|timespec
name|ts
decl_stmt|,
modifier|*
name|tsp
decl_stmt|;
name|struct
name|kevent_copyops
name|k_ops
init|=
block|{
name|uap
block|,
name|kevent_copyout
block|,
name|kevent_copyin
block|}
decl_stmt|;
name|int
name|error
decl_stmt|;
ifdef|#
directive|ifdef
name|KTRACE
name|struct
name|uio
name|ktruio
decl_stmt|;
name|struct
name|iovec
name|ktriov
decl_stmt|;
name|struct
name|uio
modifier|*
name|ktruioin
init|=
name|NULL
decl_stmt|;
name|struct
name|uio
modifier|*
name|ktruioout
init|=
name|NULL
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|uap
operator|->
name|timeout
operator|!=
name|NULL
condition|)
block|{
name|error
operator|=
name|copyin
argument_list|(
name|uap
operator|->
name|timeout
argument_list|,
operator|&
name|ts
argument_list|,
sizeof|sizeof
argument_list|(
name|ts
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|tsp
operator|=
operator|&
name|ts
expr_stmt|;
block|}
else|else
name|tsp
operator|=
name|NULL
expr_stmt|;
ifdef|#
directive|ifdef
name|KTRACE
if|if
condition|(
name|KTRPOINT
argument_list|(
name|td
argument_list|,
name|KTR_GENIO
argument_list|)
condition|)
block|{
name|ktriov
operator|.
name|iov_base
operator|=
name|uap
operator|->
name|changelist
expr_stmt|;
name|ktriov
operator|.
name|iov_len
operator|=
name|uap
operator|->
name|nchanges
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|kevent
argument_list|)
expr_stmt|;
name|ktruio
operator|=
operator|(
expr|struct
name|uio
operator|)
block|{
operator|.
name|uio_iov
operator|=
operator|&
name|ktriov
block|,
operator|.
name|uio_iovcnt
operator|=
literal|1
block|,
operator|.
name|uio_segflg
operator|=
name|UIO_USERSPACE
block|,
operator|.
name|uio_rw
operator|=
name|UIO_READ
block|,
operator|.
name|uio_td
operator|=
name|td
block|}
expr_stmt|;
name|ktruioin
operator|=
name|cloneuio
argument_list|(
operator|&
name|ktruio
argument_list|)
expr_stmt|;
name|ktriov
operator|.
name|iov_base
operator|=
name|uap
operator|->
name|eventlist
expr_stmt|;
name|ktriov
operator|.
name|iov_len
operator|=
name|uap
operator|->
name|nevents
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|kevent
argument_list|)
expr_stmt|;
name|ktruioout
operator|=
name|cloneuio
argument_list|(
operator|&
name|ktruio
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|error
operator|=
name|kern_kevent
argument_list|(
name|td
argument_list|,
name|uap
operator|->
name|fd
argument_list|,
name|uap
operator|->
name|nchanges
argument_list|,
name|uap
operator|->
name|nevents
argument_list|,
operator|&
name|k_ops
argument_list|,
name|tsp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|KTRACE
if|if
condition|(
name|ktruioin
operator|!=
name|NULL
condition|)
block|{
name|ktruioin
operator|->
name|uio_resid
operator|=
name|uap
operator|->
name|nchanges
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|kevent
argument_list|)
expr_stmt|;
name|ktrgenio
argument_list|(
name|uap
operator|->
name|fd
argument_list|,
name|UIO_WRITE
argument_list|,
name|ktruioin
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ktruioout
operator|->
name|uio_resid
operator|=
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|kevent
argument_list|)
expr_stmt|;
name|ktrgenio
argument_list|(
name|uap
operator|->
name|fd
argument_list|,
name|UIO_READ
argument_list|,
name|ktruioout
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Copy 'count' items into the destination list pointed to by uap->eventlist.  */
end_comment

begin_function
specifier|static
name|int
name|kevent_copyout
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|struct
name|kevent
modifier|*
name|kevp
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|struct
name|kevent_args
modifier|*
name|uap
decl_stmt|;
name|int
name|error
decl_stmt|;
name|KASSERT
argument_list|(
name|count
operator|<=
name|KQ_NEVENTS
argument_list|,
operator|(
literal|"count (%d)> KQ_NEVENTS"
operator|,
name|count
operator|)
argument_list|)
expr_stmt|;
name|uap
operator|=
operator|(
expr|struct
name|kevent_args
operator|*
operator|)
name|arg
expr_stmt|;
name|error
operator|=
name|copyout
argument_list|(
name|kevp
argument_list|,
name|uap
operator|->
name|eventlist
argument_list|,
name|count
operator|*
sizeof|sizeof
expr|*
name|kevp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|uap
operator|->
name|eventlist
operator|+=
name|count
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Copy 'count' items from the list pointed to by uap->changelist.  */
end_comment

begin_function
specifier|static
name|int
name|kevent_copyin
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|struct
name|kevent
modifier|*
name|kevp
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|struct
name|kevent_args
modifier|*
name|uap
decl_stmt|;
name|int
name|error
decl_stmt|;
name|KASSERT
argument_list|(
name|count
operator|<=
name|KQ_NEVENTS
argument_list|,
operator|(
literal|"count (%d)> KQ_NEVENTS"
operator|,
name|count
operator|)
argument_list|)
expr_stmt|;
name|uap
operator|=
operator|(
expr|struct
name|kevent_args
operator|*
operator|)
name|arg
expr_stmt|;
name|error
operator|=
name|copyin
argument_list|(
name|uap
operator|->
name|changelist
argument_list|,
name|kevp
argument_list|,
name|count
operator|*
sizeof|sizeof
expr|*
name|kevp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|uap
operator|->
name|changelist
operator|+=
name|count
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|kern_kevent
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|int
name|fd
parameter_list|,
name|int
name|nchanges
parameter_list|,
name|int
name|nevents
parameter_list|,
name|struct
name|kevent_copyops
modifier|*
name|k_ops
parameter_list|,
specifier|const
name|struct
name|timespec
modifier|*
name|timeout
parameter_list|)
block|{
name|cap_rights_t
name|rights
decl_stmt|;
name|struct
name|file
modifier|*
name|fp
decl_stmt|;
name|int
name|error
decl_stmt|;
name|cap_rights_init
argument_list|(
operator|&
name|rights
argument_list|)
expr_stmt|;
if|if
condition|(
name|nchanges
operator|>
literal|0
condition|)
name|cap_rights_set
argument_list|(
operator|&
name|rights
argument_list|,
name|CAP_KQUEUE_CHANGE
argument_list|)
expr_stmt|;
if|if
condition|(
name|nevents
operator|>
literal|0
condition|)
name|cap_rights_set
argument_list|(
operator|&
name|rights
argument_list|,
name|CAP_KQUEUE_EVENT
argument_list|)
expr_stmt|;
name|error
operator|=
name|fget
argument_list|(
name|td
argument_list|,
name|fd
argument_list|,
operator|&
name|rights
argument_list|,
operator|&
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|error
operator|=
name|kern_kevent_fp
argument_list|(
name|td
argument_list|,
name|fp
argument_list|,
name|nchanges
argument_list|,
name|nevents
argument_list|,
name|k_ops
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
name|fdrop
argument_list|(
name|fp
argument_list|,
name|td
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|kqueue_kevent
parameter_list|(
name|struct
name|kqueue
modifier|*
name|kq
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|int
name|nchanges
parameter_list|,
name|int
name|nevents
parameter_list|,
name|struct
name|kevent_copyops
modifier|*
name|k_ops
parameter_list|,
specifier|const
name|struct
name|timespec
modifier|*
name|timeout
parameter_list|)
block|{
name|struct
name|kevent
name|keva
index|[
name|KQ_NEVENTS
index|]
decl_stmt|;
name|struct
name|kevent
modifier|*
name|kevp
decl_stmt|,
modifier|*
name|changes
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n
decl_stmt|,
name|nerrors
decl_stmt|,
name|error
decl_stmt|;
name|nerrors
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|nchanges
operator|>
literal|0
condition|)
block|{
name|n
operator|=
name|nchanges
operator|>
name|KQ_NEVENTS
condition|?
name|KQ_NEVENTS
else|:
name|nchanges
expr_stmt|;
name|error
operator|=
name|k_ops
operator|->
name|k_copyin
argument_list|(
name|k_ops
operator|->
name|arg
argument_list|,
name|keva
argument_list|,
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|changes
operator|=
name|keva
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
name|kevp
operator|=
operator|&
name|changes
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|kevp
operator|->
name|filter
condition|)
continue|continue;
name|kevp
operator|->
name|flags
operator|&=
operator|~
name|EV_SYSFLAGS
expr_stmt|;
name|error
operator|=
name|kqueue_register
argument_list|(
name|kq
argument_list|,
name|kevp
argument_list|,
name|td
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
operator|(
name|kevp
operator|->
name|flags
operator|&
name|EV_RECEIPT
operator|)
condition|)
block|{
if|if
condition|(
name|nevents
operator|==
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|kevp
operator|->
name|flags
operator|=
name|EV_ERROR
expr_stmt|;
name|kevp
operator|->
name|data
operator|=
name|error
expr_stmt|;
operator|(
name|void
operator|)
name|k_ops
operator|->
name|k_copyout
argument_list|(
name|k_ops
operator|->
name|arg
argument_list|,
name|kevp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|nevents
operator|--
expr_stmt|;
name|nerrors
operator|++
expr_stmt|;
block|}
block|}
name|nchanges
operator|-=
name|n
expr_stmt|;
block|}
if|if
condition|(
name|nerrors
condition|)
block|{
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|=
name|nerrors
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
name|kqueue_scan
argument_list|(
name|kq
argument_list|,
name|nevents
argument_list|,
name|k_ops
argument_list|,
name|timeout
argument_list|,
name|keva
argument_list|,
name|td
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|kern_kevent_fp
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|file
modifier|*
name|fp
parameter_list|,
name|int
name|nchanges
parameter_list|,
name|int
name|nevents
parameter_list|,
name|struct
name|kevent_copyops
modifier|*
name|k_ops
parameter_list|,
specifier|const
name|struct
name|timespec
modifier|*
name|timeout
parameter_list|)
block|{
name|struct
name|kqueue
modifier|*
name|kq
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
name|kqueue_acquire
argument_list|(
name|fp
argument_list|,
operator|&
name|kq
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|error
operator|=
name|kqueue_kevent
argument_list|(
name|kq
argument_list|,
name|td
argument_list|,
name|nchanges
argument_list|,
name|nevents
argument_list|,
name|k_ops
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
name|kqueue_release
argument_list|(
name|kq
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Performs a kevent() call on a temporarily created kqueue. This can be  * used to perform one-shot polling, similar to poll() and select().  */
end_comment

begin_function
name|int
name|kern_kevent_anonymous
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|int
name|nevents
parameter_list|,
name|struct
name|kevent_copyops
modifier|*
name|k_ops
parameter_list|)
block|{
name|struct
name|kqueue
name|kq
init|=
block|{}
decl_stmt|;
name|int
name|error
decl_stmt|;
name|kqueue_init
argument_list|(
operator|&
name|kq
argument_list|)
expr_stmt|;
name|kq
operator|.
name|kq_refcnt
operator|=
literal|1
expr_stmt|;
name|error
operator|=
name|kqueue_kevent
argument_list|(
operator|&
name|kq
argument_list|,
name|td
argument_list|,
name|nevents
argument_list|,
name|nevents
argument_list|,
name|k_ops
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|kqueue_drain
argument_list|(
operator|&
name|kq
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|kqueue_destroy
argument_list|(
operator|&
name|kq
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|kqueue_add_filteropts
parameter_list|(
name|int
name|filt
parameter_list|,
name|struct
name|filterops
modifier|*
name|filtops
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|filt
operator|>
literal|0
operator|||
name|filt
operator|+
name|EVFILT_SYSCOUNT
operator|<
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"trying to add a filterop that is out of range: %d is beyond %d\n"
argument_list|,
operator|~
name|filt
argument_list|,
name|EVFILT_SYSCOUNT
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
name|mtx_lock
argument_list|(
operator|&
name|filterops_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|sysfilt_ops
index|[
operator|~
name|filt
index|]
operator|.
name|for_fop
operator|!=
operator|&
name|null_filtops
operator|&&
name|sysfilt_ops
index|[
operator|~
name|filt
index|]
operator|.
name|for_fop
operator|!=
name|NULL
condition|)
name|error
operator|=
name|EEXIST
expr_stmt|;
else|else
block|{
name|sysfilt_ops
index|[
operator|~
name|filt
index|]
operator|.
name|for_fop
operator|=
name|filtops
expr_stmt|;
name|sysfilt_ops
index|[
operator|~
name|filt
index|]
operator|.
name|for_refcnt
operator|=
literal|0
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|filterops_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|kqueue_del_filteropts
parameter_list|(
name|int
name|filt
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|filt
operator|>
literal|0
operator|||
name|filt
operator|+
name|EVFILT_SYSCOUNT
operator|<
literal|0
condition|)
return|return
name|EINVAL
return|;
name|mtx_lock
argument_list|(
operator|&
name|filterops_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|sysfilt_ops
index|[
operator|~
name|filt
index|]
operator|.
name|for_fop
operator|==
operator|&
name|null_filtops
operator|||
name|sysfilt_ops
index|[
operator|~
name|filt
index|]
operator|.
name|for_fop
operator|==
name|NULL
condition|)
name|error
operator|=
name|EINVAL
expr_stmt|;
elseif|else
if|if
condition|(
name|sysfilt_ops
index|[
operator|~
name|filt
index|]
operator|.
name|for_refcnt
operator|!=
literal|0
condition|)
name|error
operator|=
name|EBUSY
expr_stmt|;
else|else
block|{
name|sysfilt_ops
index|[
operator|~
name|filt
index|]
operator|.
name|for_fop
operator|=
operator|&
name|null_filtops
expr_stmt|;
name|sysfilt_ops
index|[
operator|~
name|filt
index|]
operator|.
name|for_refcnt
operator|=
literal|0
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|filterops_lock
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|filterops
modifier|*
name|kqueue_fo_find
parameter_list|(
name|int
name|filt
parameter_list|)
block|{
if|if
condition|(
name|filt
operator|>
literal|0
operator|||
name|filt
operator|+
name|EVFILT_SYSCOUNT
operator|<
literal|0
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|sysfilt_ops
index|[
operator|~
name|filt
index|]
operator|.
name|for_nolock
condition|)
return|return
name|sysfilt_ops
index|[
operator|~
name|filt
index|]
operator|.
name|for_fop
return|;
name|mtx_lock
argument_list|(
operator|&
name|filterops_lock
argument_list|)
expr_stmt|;
name|sysfilt_ops
index|[
operator|~
name|filt
index|]
operator|.
name|for_refcnt
operator|++
expr_stmt|;
if|if
condition|(
name|sysfilt_ops
index|[
operator|~
name|filt
index|]
operator|.
name|for_fop
operator|==
name|NULL
condition|)
name|sysfilt_ops
index|[
operator|~
name|filt
index|]
operator|.
name|for_fop
operator|=
operator|&
name|null_filtops
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|filterops_lock
argument_list|)
expr_stmt|;
return|return
name|sysfilt_ops
index|[
operator|~
name|filt
index|]
operator|.
name|for_fop
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|kqueue_fo_release
parameter_list|(
name|int
name|filt
parameter_list|)
block|{
if|if
condition|(
name|filt
operator|>
literal|0
operator|||
name|filt
operator|+
name|EVFILT_SYSCOUNT
operator|<
literal|0
condition|)
return|return;
if|if
condition|(
name|sysfilt_ops
index|[
operator|~
name|filt
index|]
operator|.
name|for_nolock
condition|)
return|return;
name|mtx_lock
argument_list|(
operator|&
name|filterops_lock
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|sysfilt_ops
index|[
operator|~
name|filt
index|]
operator|.
name|for_refcnt
operator|>
literal|0
argument_list|,
operator|(
literal|"filter object refcount not valid on release"
operator|)
argument_list|)
expr_stmt|;
name|sysfilt_ops
index|[
operator|~
name|filt
index|]
operator|.
name|for_refcnt
operator|--
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|filterops_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * A ref to kq (obtained via kqueue_acquire) must be held.  waitok will  * influence if memory allocation should wait.  Make sure it is 0 if you  * hold any mutexes.  */
end_comment

begin_function
specifier|static
name|int
name|kqueue_register
parameter_list|(
name|struct
name|kqueue
modifier|*
name|kq
parameter_list|,
name|struct
name|kevent
modifier|*
name|kev
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|int
name|waitok
parameter_list|)
block|{
name|struct
name|filterops
modifier|*
name|fops
decl_stmt|;
name|struct
name|file
modifier|*
name|fp
decl_stmt|;
name|struct
name|knote
modifier|*
name|kn
decl_stmt|,
modifier|*
name|tkn
decl_stmt|;
name|struct
name|knlist
modifier|*
name|knl
decl_stmt|;
name|cap_rights_t
name|rights
decl_stmt|;
name|int
name|error
decl_stmt|,
name|filt
decl_stmt|,
name|event
decl_stmt|;
name|int
name|haskqglobal
decl_stmt|,
name|filedesc_unlock
decl_stmt|;
if|if
condition|(
operator|(
name|kev
operator|->
name|flags
operator|&
operator|(
name|EV_ENABLE
operator||
name|EV_DISABLE
operator|)
operator|)
operator|==
operator|(
name|EV_ENABLE
operator||
name|EV_DISABLE
operator|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|fp
operator|=
name|NULL
expr_stmt|;
name|kn
operator|=
name|NULL
expr_stmt|;
name|knl
operator|=
name|NULL
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|haskqglobal
operator|=
literal|0
expr_stmt|;
name|filedesc_unlock
operator|=
literal|0
expr_stmt|;
name|filt
operator|=
name|kev
operator|->
name|filter
expr_stmt|;
name|fops
operator|=
name|kqueue_fo_find
argument_list|(
name|filt
argument_list|)
expr_stmt|;
if|if
condition|(
name|fops
operator|==
name|NULL
condition|)
return|return
name|EINVAL
return|;
if|if
condition|(
name|kev
operator|->
name|flags
operator|&
name|EV_ADD
condition|)
block|{
comment|/* 		 * Prevent waiting with locks.  Non-sleepable 		 * allocation failures are handled in the loop, only 		 * if the spare knote appears to be actually required. 		 */
name|tkn
operator|=
name|knote_alloc
argument_list|(
name|waitok
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tkn
operator|=
name|NULL
expr_stmt|;
block|}
name|findkn
label|:
if|if
condition|(
name|fops
operator|->
name|f_isfd
condition|)
block|{
name|KASSERT
argument_list|(
name|td
operator|!=
name|NULL
argument_list|,
operator|(
literal|"td is NULL"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|kev
operator|->
name|ident
operator|>
name|INT_MAX
condition|)
name|error
operator|=
name|EBADF
expr_stmt|;
else|else
name|error
operator|=
name|fget
argument_list|(
name|td
argument_list|,
name|kev
operator|->
name|ident
argument_list|,
name|cap_rights_init
argument_list|(
operator|&
name|rights
argument_list|,
name|CAP_EVENT
argument_list|)
argument_list|,
operator|&
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|done
goto|;
if|if
condition|(
operator|(
name|kev
operator|->
name|flags
operator|&
name|EV_ADD
operator|)
operator|==
name|EV_ADD
operator|&&
name|kqueue_expand
argument_list|(
name|kq
argument_list|,
name|fops
argument_list|,
name|kev
operator|->
name|ident
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* try again */
name|fdrop
argument_list|(
name|fp
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|fp
operator|=
name|NULL
expr_stmt|;
name|error
operator|=
name|kqueue_expand
argument_list|(
name|kq
argument_list|,
name|fops
argument_list|,
name|kev
operator|->
name|ident
argument_list|,
name|waitok
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|done
goto|;
goto|goto
name|findkn
goto|;
block|}
if|if
condition|(
name|fp
operator|->
name|f_type
operator|==
name|DTYPE_KQUEUE
condition|)
block|{
comment|/* 			 * If we add some intelligence about what we are doing, 			 * we should be able to support events on ourselves. 			 * We need to know when we are doing this to prevent 			 * getting both the knlist lock and the kq lock since 			 * they are the same thing. 			 */
if|if
condition|(
name|fp
operator|->
name|f_data
operator|==
name|kq
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* 			 * Pre-lock the filedesc before the global 			 * lock mutex, see the comment in 			 * kqueue_close(). 			 */
name|FILEDESC_XLOCK
argument_list|(
name|td
operator|->
name|td_proc
operator|->
name|p_fd
argument_list|)
expr_stmt|;
name|filedesc_unlock
operator|=
literal|1
expr_stmt|;
name|KQ_GLOBAL_LOCK
argument_list|(
operator|&
name|kq_global
argument_list|,
name|haskqglobal
argument_list|)
expr_stmt|;
block|}
name|KQ_LOCK
argument_list|(
name|kq
argument_list|)
expr_stmt|;
if|if
condition|(
name|kev
operator|->
name|ident
operator|<
name|kq
operator|->
name|kq_knlistsize
condition|)
block|{
name|SLIST_FOREACH
argument_list|(
argument|kn
argument_list|,
argument|&kq->kq_knlist[kev->ident]
argument_list|,
argument|kn_link
argument_list|)
if|if
condition|(
name|kev
operator|->
name|filter
operator|==
name|kn
operator|->
name|kn_filter
condition|)
break|break;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|(
name|kev
operator|->
name|flags
operator|&
name|EV_ADD
operator|)
operator|==
name|EV_ADD
condition|)
name|kqueue_expand
argument_list|(
name|kq
argument_list|,
name|fops
argument_list|,
name|kev
operator|->
name|ident
argument_list|,
name|waitok
argument_list|)
expr_stmt|;
name|KQ_LOCK
argument_list|(
name|kq
argument_list|)
expr_stmt|;
comment|/* 		 * If possible, find an existing knote to use for this kevent. 		 */
if|if
condition|(
name|kev
operator|->
name|filter
operator|==
name|EVFILT_PROC
operator|&&
operator|(
name|kev
operator|->
name|flags
operator|&
operator|(
name|EV_FLAG1
operator||
name|EV_FLAG2
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* This is an internal creation of a process tracking 			 * note. Don't attempt to coalesce this with an 			 * existing note. 			 */
empty_stmt|;
block|}
elseif|else
if|if
condition|(
name|kq
operator|->
name|kq_knhashmask
operator|!=
literal|0
condition|)
block|{
name|struct
name|klist
modifier|*
name|list
decl_stmt|;
name|list
operator|=
operator|&
name|kq
operator|->
name|kq_knhash
index|[
name|KN_HASH
argument_list|(
operator|(
name|u_long
operator|)
name|kev
operator|->
name|ident
argument_list|,
name|kq
operator|->
name|kq_knhashmask
argument_list|)
index|]
expr_stmt|;
name|SLIST_FOREACH
argument_list|(
argument|kn
argument_list|,
argument|list
argument_list|,
argument|kn_link
argument_list|)
if|if
condition|(
name|kev
operator|->
name|ident
operator|==
name|kn
operator|->
name|kn_id
operator|&&
name|kev
operator|->
name|filter
operator|==
name|kn
operator|->
name|kn_filter
condition|)
break|break;
block|}
block|}
comment|/* knote is in the process of changing, wait for it to stabilize. */
if|if
condition|(
name|kn
operator|!=
name|NULL
operator|&&
operator|(
name|kn
operator|->
name|kn_status
operator|&
name|KN_INFLUX
operator|)
operator|==
name|KN_INFLUX
condition|)
block|{
name|KQ_GLOBAL_UNLOCK
argument_list|(
operator|&
name|kq_global
argument_list|,
name|haskqglobal
argument_list|)
expr_stmt|;
if|if
condition|(
name|filedesc_unlock
condition|)
block|{
name|FILEDESC_XUNLOCK
argument_list|(
name|td
operator|->
name|td_proc
operator|->
name|p_fd
argument_list|)
expr_stmt|;
name|filedesc_unlock
operator|=
literal|0
expr_stmt|;
block|}
name|kq
operator|->
name|kq_state
operator||=
name|KQ_FLUXWAIT
expr_stmt|;
name|msleep
argument_list|(
name|kq
argument_list|,
operator|&
name|kq
operator|->
name|kq_lock
argument_list|,
name|PSOCK
operator||
name|PDROP
argument_list|,
literal|"kqflxwt"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|!=
name|NULL
condition|)
block|{
name|fdrop
argument_list|(
name|fp
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|fp
operator|=
name|NULL
expr_stmt|;
block|}
goto|goto
name|findkn
goto|;
block|}
comment|/* 	 * kn now contains the matching knote, or NULL if no match 	 */
if|if
condition|(
name|kn
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|kev
operator|->
name|flags
operator|&
name|EV_ADD
condition|)
block|{
name|kn
operator|=
name|tkn
expr_stmt|;
name|tkn
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|kn
operator|==
name|NULL
condition|)
block|{
name|KQ_UNLOCK
argument_list|(
name|kq
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|kn
operator|->
name|kn_fp
operator|=
name|fp
expr_stmt|;
name|kn
operator|->
name|kn_kq
operator|=
name|kq
expr_stmt|;
name|kn
operator|->
name|kn_fop
operator|=
name|fops
expr_stmt|;
comment|/* 			 * apply reference counts to knote structure, and 			 * do not release it at the end of this routine. 			 */
name|fops
operator|=
name|NULL
expr_stmt|;
name|fp
operator|=
name|NULL
expr_stmt|;
name|kn
operator|->
name|kn_sfflags
operator|=
name|kev
operator|->
name|fflags
expr_stmt|;
name|kn
operator|->
name|kn_sdata
operator|=
name|kev
operator|->
name|data
expr_stmt|;
name|kev
operator|->
name|fflags
operator|=
literal|0
expr_stmt|;
name|kev
operator|->
name|data
operator|=
literal|0
expr_stmt|;
name|kn
operator|->
name|kn_kevent
operator|=
operator|*
name|kev
expr_stmt|;
name|kn
operator|->
name|kn_kevent
operator|.
name|flags
operator|&=
operator|~
operator|(
name|EV_ADD
operator||
name|EV_DELETE
operator||
name|EV_ENABLE
operator||
name|EV_DISABLE
operator||
name|EV_FORCEONESHOT
operator|)
expr_stmt|;
name|kn
operator|->
name|kn_status
operator|=
name|KN_INFLUX
operator||
name|KN_DETACHED
expr_stmt|;
name|error
operator|=
name|knote_attach
argument_list|(
name|kn
argument_list|,
name|kq
argument_list|)
expr_stmt|;
name|KQ_UNLOCK
argument_list|(
name|kq
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|tkn
operator|=
name|kn
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
operator|(
name|error
operator|=
name|kn
operator|->
name|kn_fop
operator|->
name|f_attach
argument_list|(
name|kn
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|knote_drop
argument_list|(
name|kn
argument_list|,
name|td
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|knl
operator|=
name|kn_list_lock
argument_list|(
name|kn
argument_list|)
expr_stmt|;
goto|goto
name|done_ev_add
goto|;
block|}
else|else
block|{
comment|/* No matching knote and the EV_ADD flag is not set. */
name|KQ_UNLOCK
argument_list|(
name|kq
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOENT
expr_stmt|;
goto|goto
name|done
goto|;
block|}
block|}
if|if
condition|(
name|kev
operator|->
name|flags
operator|&
name|EV_DELETE
condition|)
block|{
name|kn
operator|->
name|kn_status
operator||=
name|KN_INFLUX
expr_stmt|;
name|KQ_UNLOCK
argument_list|(
name|kq
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|kn
operator|->
name|kn_status
operator|&
name|KN_DETACHED
operator|)
condition|)
name|kn
operator|->
name|kn_fop
operator|->
name|f_detach
argument_list|(
name|kn
argument_list|)
expr_stmt|;
name|knote_drop
argument_list|(
name|kn
argument_list|,
name|td
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|kev
operator|->
name|flags
operator|&
name|EV_FORCEONESHOT
condition|)
block|{
name|kn
operator|->
name|kn_flags
operator||=
name|EV_ONESHOT
expr_stmt|;
name|KNOTE_ACTIVATE
argument_list|(
name|kn
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * The user may change some filter values after the initial EV_ADD, 	 * but doing so will not reset any filter which has already been 	 * triggered. 	 */
name|kn
operator|->
name|kn_status
operator||=
name|KN_INFLUX
operator||
name|KN_SCAN
expr_stmt|;
name|KQ_UNLOCK
argument_list|(
name|kq
argument_list|)
expr_stmt|;
name|knl
operator|=
name|kn_list_lock
argument_list|(
name|kn
argument_list|)
expr_stmt|;
name|kn
operator|->
name|kn_kevent
operator|.
name|udata
operator|=
name|kev
operator|->
name|udata
expr_stmt|;
if|if
condition|(
operator|!
name|fops
operator|->
name|f_isfd
operator|&&
name|fops
operator|->
name|f_touch
operator|!=
name|NULL
condition|)
block|{
name|fops
operator|->
name|f_touch
argument_list|(
name|kn
argument_list|,
name|kev
argument_list|,
name|EVENT_REGISTER
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|kn
operator|->
name|kn_sfflags
operator|=
name|kev
operator|->
name|fflags
expr_stmt|;
name|kn
operator|->
name|kn_sdata
operator|=
name|kev
operator|->
name|data
expr_stmt|;
block|}
comment|/* 	 * We can get here with kn->kn_knlist == NULL.  This can happen when 	 * the initial attach event decides that the event is "completed"  	 * already.  i.e. filt_procattach is called on a zombie process.  It 	 * will call filt_proc which will remove it from the list, and NULL 	 * kn_knlist. 	 */
name|done_ev_add
label|:
if|if
condition|(
operator|(
name|kev
operator|->
name|flags
operator|&
name|EV_ENABLE
operator|)
operator|!=
literal|0
condition|)
name|kn
operator|->
name|kn_status
operator|&=
operator|~
name|KN_DISABLED
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|kev
operator|->
name|flags
operator|&
name|EV_DISABLE
operator|)
operator|!=
literal|0
condition|)
name|kn
operator|->
name|kn_status
operator||=
name|KN_DISABLED
expr_stmt|;
if|if
condition|(
operator|(
name|kn
operator|->
name|kn_status
operator|&
name|KN_DISABLED
operator|)
operator|==
literal|0
condition|)
name|event
operator|=
name|kn
operator|->
name|kn_fop
operator|->
name|f_event
argument_list|(
name|kn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|event
operator|=
literal|0
expr_stmt|;
name|KQ_LOCK
argument_list|(
name|kq
argument_list|)
expr_stmt|;
if|if
condition|(
name|event
condition|)
name|kn
operator|->
name|kn_status
operator||=
name|KN_ACTIVE
expr_stmt|;
if|if
condition|(
operator|(
name|kn
operator|->
name|kn_status
operator|&
operator|(
name|KN_ACTIVE
operator||
name|KN_DISABLED
operator||
name|KN_QUEUED
operator|)
operator|)
operator|==
name|KN_ACTIVE
condition|)
name|knote_enqueue
argument_list|(
name|kn
argument_list|)
expr_stmt|;
name|kn
operator|->
name|kn_status
operator|&=
operator|~
operator|(
name|KN_INFLUX
operator||
name|KN_SCAN
operator|)
expr_stmt|;
name|kn_list_unlock
argument_list|(
name|knl
argument_list|)
expr_stmt|;
name|KQ_UNLOCK_FLUX
argument_list|(
name|kq
argument_list|)
expr_stmt|;
name|done
label|:
name|KQ_GLOBAL_UNLOCK
argument_list|(
operator|&
name|kq_global
argument_list|,
name|haskqglobal
argument_list|)
expr_stmt|;
if|if
condition|(
name|filedesc_unlock
condition|)
name|FILEDESC_XUNLOCK
argument_list|(
name|td
operator|->
name|td_proc
operator|->
name|p_fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|!=
name|NULL
condition|)
name|fdrop
argument_list|(
name|fp
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|knote_free
argument_list|(
name|tkn
argument_list|)
expr_stmt|;
if|if
condition|(
name|fops
operator|!=
name|NULL
condition|)
name|kqueue_fo_release
argument_list|(
name|filt
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|kqueue_acquire
parameter_list|(
name|struct
name|file
modifier|*
name|fp
parameter_list|,
name|struct
name|kqueue
modifier|*
modifier|*
name|kqp
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|struct
name|kqueue
modifier|*
name|kq
decl_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|kq
operator|=
name|fp
operator|->
name|f_data
expr_stmt|;
if|if
condition|(
name|fp
operator|->
name|f_type
operator|!=
name|DTYPE_KQUEUE
operator|||
name|kq
operator|==
name|NULL
condition|)
return|return
operator|(
name|EBADF
operator|)
return|;
operator|*
name|kqp
operator|=
name|kq
expr_stmt|;
name|KQ_LOCK
argument_list|(
name|kq
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|kq
operator|->
name|kq_state
operator|&
name|KQ_CLOSING
operator|)
operator|==
name|KQ_CLOSING
condition|)
block|{
name|KQ_UNLOCK
argument_list|(
name|kq
argument_list|)
expr_stmt|;
return|return
operator|(
name|EBADF
operator|)
return|;
block|}
name|kq
operator|->
name|kq_refcnt
operator|++
expr_stmt|;
name|KQ_UNLOCK
argument_list|(
name|kq
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|kqueue_release
parameter_list|(
name|struct
name|kqueue
modifier|*
name|kq
parameter_list|,
name|int
name|locked
parameter_list|)
block|{
if|if
condition|(
name|locked
condition|)
name|KQ_OWNED
argument_list|(
name|kq
argument_list|)
expr_stmt|;
else|else
name|KQ_LOCK
argument_list|(
name|kq
argument_list|)
expr_stmt|;
name|kq
operator|->
name|kq_refcnt
operator|--
expr_stmt|;
if|if
condition|(
name|kq
operator|->
name|kq_refcnt
operator|==
literal|1
condition|)
name|wakeup
argument_list|(
operator|&
name|kq
operator|->
name|kq_refcnt
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|locked
condition|)
name|KQ_UNLOCK
argument_list|(
name|kq
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|kqueue_schedtask
parameter_list|(
name|struct
name|kqueue
modifier|*
name|kq
parameter_list|)
block|{
name|KQ_OWNED
argument_list|(
name|kq
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
operator|(
name|kq
operator|->
name|kq_state
operator|&
name|KQ_TASKDRAIN
operator|)
operator|!=
name|KQ_TASKDRAIN
operator|)
argument_list|,
operator|(
literal|"scheduling kqueue task while draining"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|kq
operator|->
name|kq_state
operator|&
name|KQ_TASKSCHED
operator|)
operator|!=
name|KQ_TASKSCHED
condition|)
block|{
name|taskqueue_enqueue
argument_list|(
name|taskqueue_kqueue_ctx
argument_list|,
operator|&
name|kq
operator|->
name|kq_task
argument_list|)
expr_stmt|;
name|kq
operator|->
name|kq_state
operator||=
name|KQ_TASKSCHED
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Expand the kq to make sure we have storage for fops/ident pair.  *  * Return 0 on success (or no work necessary), return errno on failure.  *  * Not calling hashinit w/ waitok (proper malloc flag) should be safe.  * If kqueue_register is called from a non-fd context, there usually/should  * be no locks held.  */
end_comment

begin_function
specifier|static
name|int
name|kqueue_expand
parameter_list|(
name|struct
name|kqueue
modifier|*
name|kq
parameter_list|,
name|struct
name|filterops
modifier|*
name|fops
parameter_list|,
name|uintptr_t
name|ident
parameter_list|,
name|int
name|waitok
parameter_list|)
block|{
name|struct
name|klist
modifier|*
name|list
decl_stmt|,
modifier|*
name|tmp_knhash
decl_stmt|,
modifier|*
name|to_free
decl_stmt|;
name|u_long
name|tmp_knhashmask
decl_stmt|;
name|int
name|size
decl_stmt|;
name|int
name|fd
decl_stmt|;
name|int
name|mflag
init|=
name|waitok
condition|?
name|M_WAITOK
else|:
name|M_NOWAIT
decl_stmt|;
name|KQ_NOTOWNED
argument_list|(
name|kq
argument_list|)
expr_stmt|;
name|to_free
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|fops
operator|->
name|f_isfd
condition|)
block|{
name|fd
operator|=
name|ident
expr_stmt|;
if|if
condition|(
name|kq
operator|->
name|kq_knlistsize
operator|<=
name|fd
condition|)
block|{
name|size
operator|=
name|kq
operator|->
name|kq_knlistsize
expr_stmt|;
while|while
condition|(
name|size
operator|<=
name|fd
condition|)
name|size
operator|+=
name|KQEXTENT
expr_stmt|;
name|list
operator|=
name|malloc
argument_list|(
name|size
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|list
argument_list|)
argument_list|,
name|M_KQUEUE
argument_list|,
name|mflag
argument_list|)
expr_stmt|;
if|if
condition|(
name|list
operator|==
name|NULL
condition|)
return|return
name|ENOMEM
return|;
name|KQ_LOCK
argument_list|(
name|kq
argument_list|)
expr_stmt|;
if|if
condition|(
name|kq
operator|->
name|kq_knlistsize
operator|>
name|fd
condition|)
block|{
name|to_free
operator|=
name|list
expr_stmt|;
name|list
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|kq
operator|->
name|kq_knlist
operator|!=
name|NULL
condition|)
block|{
name|bcopy
argument_list|(
name|kq
operator|->
name|kq_knlist
argument_list|,
name|list
argument_list|,
name|kq
operator|->
name|kq_knlistsize
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|list
argument_list|)
argument_list|)
expr_stmt|;
name|to_free
operator|=
name|kq
operator|->
name|kq_knlist
expr_stmt|;
name|kq
operator|->
name|kq_knlist
operator|=
name|NULL
expr_stmt|;
block|}
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
name|list
operator|+
name|kq
operator|->
name|kq_knlistsize
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|list
argument_list|)
argument_list|,
operator|(
name|size
operator|-
name|kq
operator|->
name|kq_knlistsize
operator|)
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|list
argument_list|)
argument_list|)
expr_stmt|;
name|kq
operator|->
name|kq_knlistsize
operator|=
name|size
expr_stmt|;
name|kq
operator|->
name|kq_knlist
operator|=
name|list
expr_stmt|;
block|}
name|KQ_UNLOCK
argument_list|(
name|kq
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|kq
operator|->
name|kq_knhashmask
operator|==
literal|0
condition|)
block|{
name|tmp_knhash
operator|=
name|hashinit
argument_list|(
name|KN_HASHSIZE
argument_list|,
name|M_KQUEUE
argument_list|,
operator|&
name|tmp_knhashmask
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp_knhash
operator|==
name|NULL
condition|)
return|return
name|ENOMEM
return|;
name|KQ_LOCK
argument_list|(
name|kq
argument_list|)
expr_stmt|;
if|if
condition|(
name|kq
operator|->
name|kq_knhashmask
operator|==
literal|0
condition|)
block|{
name|kq
operator|->
name|kq_knhash
operator|=
name|tmp_knhash
expr_stmt|;
name|kq
operator|->
name|kq_knhashmask
operator|=
name|tmp_knhashmask
expr_stmt|;
block|}
else|else
block|{
name|to_free
operator|=
name|tmp_knhash
expr_stmt|;
block|}
name|KQ_UNLOCK
argument_list|(
name|kq
argument_list|)
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|to_free
argument_list|,
name|M_KQUEUE
argument_list|)
expr_stmt|;
name|KQ_NOTOWNED
argument_list|(
name|kq
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|kqueue_task
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|pending
parameter_list|)
block|{
name|struct
name|kqueue
modifier|*
name|kq
decl_stmt|;
name|int
name|haskqglobal
decl_stmt|;
name|haskqglobal
operator|=
literal|0
expr_stmt|;
name|kq
operator|=
name|arg
expr_stmt|;
name|KQ_GLOBAL_LOCK
argument_list|(
operator|&
name|kq_global
argument_list|,
name|haskqglobal
argument_list|)
expr_stmt|;
name|KQ_LOCK
argument_list|(
name|kq
argument_list|)
expr_stmt|;
name|KNOTE_LOCKED
argument_list|(
operator|&
name|kq
operator|->
name|kq_sel
operator|.
name|si_note
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|kq
operator|->
name|kq_state
operator|&=
operator|~
name|KQ_TASKSCHED
expr_stmt|;
if|if
condition|(
operator|(
name|kq
operator|->
name|kq_state
operator|&
name|KQ_TASKDRAIN
operator|)
operator|==
name|KQ_TASKDRAIN
condition|)
block|{
name|wakeup
argument_list|(
operator|&
name|kq
operator|->
name|kq_state
argument_list|)
expr_stmt|;
block|}
name|KQ_UNLOCK
argument_list|(
name|kq
argument_list|)
expr_stmt|;
name|KQ_GLOBAL_UNLOCK
argument_list|(
operator|&
name|kq_global
argument_list|,
name|haskqglobal
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Scan, update kn_data (if not ONESHOT), and copyout triggered events.  * We treat KN_MARKER knotes as if they are INFLUX.  */
end_comment

begin_function
specifier|static
name|int
name|kqueue_scan
parameter_list|(
name|struct
name|kqueue
modifier|*
name|kq
parameter_list|,
name|int
name|maxevents
parameter_list|,
name|struct
name|kevent_copyops
modifier|*
name|k_ops
parameter_list|,
specifier|const
name|struct
name|timespec
modifier|*
name|tsp
parameter_list|,
name|struct
name|kevent
modifier|*
name|keva
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|kevent
modifier|*
name|kevp
decl_stmt|;
name|struct
name|knote
modifier|*
name|kn
decl_stmt|,
modifier|*
name|marker
decl_stmt|;
name|struct
name|knlist
modifier|*
name|knl
decl_stmt|;
name|sbintime_t
name|asbt
decl_stmt|,
name|rsbt
decl_stmt|;
name|int
name|count
decl_stmt|,
name|error
decl_stmt|,
name|haskqglobal
decl_stmt|,
name|influx
decl_stmt|,
name|nkev
decl_stmt|,
name|touch
decl_stmt|;
name|count
operator|=
name|maxevents
expr_stmt|;
name|nkev
operator|=
literal|0
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|haskqglobal
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|maxevents
operator|==
literal|0
condition|)
goto|goto
name|done_nl
goto|;
name|rsbt
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|tsp
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|tsp
operator|->
name|tv_sec
operator|<
literal|0
operator|||
name|tsp
operator|->
name|tv_nsec
operator|<
literal|0
operator|||
name|tsp
operator|->
name|tv_nsec
operator|>=
literal|1000000000
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|done_nl
goto|;
block|}
if|if
condition|(
name|timespecisset
argument_list|(
name|tsp
argument_list|)
condition|)
block|{
if|if
condition|(
name|tsp
operator|->
name|tv_sec
operator|<=
name|INT32_MAX
condition|)
block|{
name|rsbt
operator|=
name|tstosbt
argument_list|(
operator|*
name|tsp
argument_list|)
expr_stmt|;
if|if
condition|(
name|TIMESEL
argument_list|(
operator|&
name|asbt
argument_list|,
name|rsbt
argument_list|)
condition|)
name|asbt
operator|+=
name|tc_tick_sbt
expr_stmt|;
if|if
condition|(
name|asbt
operator|<=
name|SBT_MAX
operator|-
name|rsbt
condition|)
name|asbt
operator|+=
name|rsbt
expr_stmt|;
else|else
name|asbt
operator|=
literal|0
expr_stmt|;
name|rsbt
operator|>>=
name|tc_precexp
expr_stmt|;
block|}
else|else
name|asbt
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|asbt
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
name|asbt
operator|=
literal|0
expr_stmt|;
name|marker
operator|=
name|knote_alloc
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|marker
operator|->
name|kn_status
operator|=
name|KN_MARKER
expr_stmt|;
name|KQ_LOCK
argument_list|(
name|kq
argument_list|)
expr_stmt|;
name|retry
label|:
name|kevp
operator|=
name|keva
expr_stmt|;
if|if
condition|(
name|kq
operator|->
name|kq_count
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|asbt
operator|==
operator|-
literal|1
condition|)
block|{
name|error
operator|=
name|EWOULDBLOCK
expr_stmt|;
block|}
else|else
block|{
name|kq
operator|->
name|kq_state
operator||=
name|KQ_SLEEP
expr_stmt|;
name|error
operator|=
name|msleep_sbt
argument_list|(
name|kq
argument_list|,
operator|&
name|kq
operator|->
name|kq_lock
argument_list|,
name|PSOCK
operator||
name|PCATCH
argument_list|,
literal|"kqread"
argument_list|,
name|asbt
argument_list|,
name|rsbt
argument_list|,
name|C_ABSOLUTE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|==
literal|0
condition|)
goto|goto
name|retry
goto|;
comment|/* don't restart after signals... */
if|if
condition|(
name|error
operator|==
name|ERESTART
condition|)
name|error
operator|=
name|EINTR
expr_stmt|;
elseif|else
if|if
condition|(
name|error
operator|==
name|EWOULDBLOCK
condition|)
name|error
operator|=
literal|0
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|kq
operator|->
name|kq_head
argument_list|,
name|marker
argument_list|,
name|kn_tqe
argument_list|)
expr_stmt|;
name|influx
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|count
condition|)
block|{
name|KQ_OWNED
argument_list|(
name|kq
argument_list|)
expr_stmt|;
name|kn
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|kq
operator|->
name|kq_head
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|kn
operator|->
name|kn_status
operator|==
name|KN_MARKER
operator|&&
name|kn
operator|!=
name|marker
operator|)
operator|||
operator|(
name|kn
operator|->
name|kn_status
operator|&
name|KN_INFLUX
operator|)
operator|==
name|KN_INFLUX
condition|)
block|{
if|if
condition|(
name|influx
condition|)
block|{
name|influx
operator|=
literal|0
expr_stmt|;
name|KQ_FLUX_WAKEUP
argument_list|(
name|kq
argument_list|)
expr_stmt|;
block|}
name|kq
operator|->
name|kq_state
operator||=
name|KQ_FLUXWAIT
expr_stmt|;
name|error
operator|=
name|msleep
argument_list|(
name|kq
argument_list|,
operator|&
name|kq
operator|->
name|kq_lock
argument_list|,
name|PSOCK
argument_list|,
literal|"kqflxwt"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|TAILQ_REMOVE
argument_list|(
operator|&
name|kq
operator|->
name|kq_head
argument_list|,
name|kn
argument_list|,
name|kn_tqe
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|kn
operator|->
name|kn_status
operator|&
name|KN_DISABLED
operator|)
operator|==
name|KN_DISABLED
condition|)
block|{
name|kn
operator|->
name|kn_status
operator|&=
operator|~
name|KN_QUEUED
expr_stmt|;
name|kq
operator|->
name|kq_count
operator|--
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|kn
operator|==
name|marker
condition|)
block|{
name|KQ_FLUX_WAKEUP
argument_list|(
name|kq
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|==
name|maxevents
condition|)
goto|goto
name|retry
goto|;
goto|goto
name|done
goto|;
block|}
name|KASSERT
argument_list|(
operator|(
name|kn
operator|->
name|kn_status
operator|&
name|KN_INFLUX
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"KN_INFLUX set when not suppose to be"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|kn
operator|->
name|kn_flags
operator|&
name|EV_DROP
operator|)
operator|==
name|EV_DROP
condition|)
block|{
name|kn
operator|->
name|kn_status
operator|&=
operator|~
name|KN_QUEUED
expr_stmt|;
name|kn
operator|->
name|kn_status
operator||=
name|KN_INFLUX
expr_stmt|;
name|kq
operator|->
name|kq_count
operator|--
expr_stmt|;
name|KQ_UNLOCK
argument_list|(
name|kq
argument_list|)
expr_stmt|;
comment|/* 			 * We don't need to lock the list since we've marked 			 * it _INFLUX. 			 */
if|if
condition|(
operator|!
operator|(
name|kn
operator|->
name|kn_status
operator|&
name|KN_DETACHED
operator|)
condition|)
name|kn
operator|->
name|kn_fop
operator|->
name|f_detach
argument_list|(
name|kn
argument_list|)
expr_stmt|;
name|knote_drop
argument_list|(
name|kn
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|KQ_LOCK
argument_list|(
name|kq
argument_list|)
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
operator|(
name|kn
operator|->
name|kn_flags
operator|&
name|EV_ONESHOT
operator|)
operator|==
name|EV_ONESHOT
condition|)
block|{
name|kn
operator|->
name|kn_status
operator|&=
operator|~
name|KN_QUEUED
expr_stmt|;
name|kn
operator|->
name|kn_status
operator||=
name|KN_INFLUX
expr_stmt|;
name|kq
operator|->
name|kq_count
operator|--
expr_stmt|;
name|KQ_UNLOCK
argument_list|(
name|kq
argument_list|)
expr_stmt|;
comment|/* 			 * We don't need to lock the list since we've marked 			 * it _INFLUX. 			 */
operator|*
name|kevp
operator|=
name|kn
operator|->
name|kn_kevent
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|kn
operator|->
name|kn_status
operator|&
name|KN_DETACHED
operator|)
condition|)
name|kn
operator|->
name|kn_fop
operator|->
name|f_detach
argument_list|(
name|kn
argument_list|)
expr_stmt|;
name|knote_drop
argument_list|(
name|kn
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|KQ_LOCK
argument_list|(
name|kq
argument_list|)
expr_stmt|;
name|kn
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|kn
operator|->
name|kn_status
operator||=
name|KN_INFLUX
operator||
name|KN_SCAN
expr_stmt|;
name|KQ_UNLOCK
argument_list|(
name|kq
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|kn
operator|->
name|kn_status
operator|&
name|KN_KQUEUE
operator|)
operator|==
name|KN_KQUEUE
condition|)
name|KQ_GLOBAL_LOCK
argument_list|(
operator|&
name|kq_global
argument_list|,
name|haskqglobal
argument_list|)
expr_stmt|;
name|knl
operator|=
name|kn_list_lock
argument_list|(
name|kn
argument_list|)
expr_stmt|;
if|if
condition|(
name|kn
operator|->
name|kn_fop
operator|->
name|f_event
argument_list|(
name|kn
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
block|{
name|KQ_LOCK
argument_list|(
name|kq
argument_list|)
expr_stmt|;
name|KQ_GLOBAL_UNLOCK
argument_list|(
operator|&
name|kq_global
argument_list|,
name|haskqglobal
argument_list|)
expr_stmt|;
name|kn
operator|->
name|kn_status
operator|&=
operator|~
operator|(
name|KN_QUEUED
operator||
name|KN_ACTIVE
operator||
name|KN_INFLUX
operator||
name|KN_SCAN
operator|)
expr_stmt|;
name|kq
operator|->
name|kq_count
operator|--
expr_stmt|;
name|kn_list_unlock
argument_list|(
name|knl
argument_list|)
expr_stmt|;
name|influx
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
name|touch
operator|=
operator|(
operator|!
name|kn
operator|->
name|kn_fop
operator|->
name|f_isfd
operator|&&
name|kn
operator|->
name|kn_fop
operator|->
name|f_touch
operator|!=
name|NULL
operator|)
expr_stmt|;
if|if
condition|(
name|touch
condition|)
name|kn
operator|->
name|kn_fop
operator|->
name|f_touch
argument_list|(
name|kn
argument_list|,
name|kevp
argument_list|,
name|EVENT_PROCESS
argument_list|)
expr_stmt|;
else|else
operator|*
name|kevp
operator|=
name|kn
operator|->
name|kn_kevent
expr_stmt|;
name|KQ_LOCK
argument_list|(
name|kq
argument_list|)
expr_stmt|;
name|KQ_GLOBAL_UNLOCK
argument_list|(
operator|&
name|kq_global
argument_list|,
name|haskqglobal
argument_list|)
expr_stmt|;
if|if
condition|(
name|kn
operator|->
name|kn_flags
operator|&
operator|(
name|EV_CLEAR
operator||
name|EV_DISPATCH
operator|)
condition|)
block|{
comment|/*  				 * Manually clear knotes who weren't  				 * 'touch'ed. 				 */
if|if
condition|(
name|touch
operator|==
literal|0
operator|&&
name|kn
operator|->
name|kn_flags
operator|&
name|EV_CLEAR
condition|)
block|{
name|kn
operator|->
name|kn_data
operator|=
literal|0
expr_stmt|;
name|kn
operator|->
name|kn_fflags
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|kn
operator|->
name|kn_flags
operator|&
name|EV_DISPATCH
condition|)
name|kn
operator|->
name|kn_status
operator||=
name|KN_DISABLED
expr_stmt|;
name|kn
operator|->
name|kn_status
operator|&=
operator|~
operator|(
name|KN_QUEUED
operator||
name|KN_ACTIVE
operator|)
expr_stmt|;
name|kq
operator|->
name|kq_count
operator|--
expr_stmt|;
block|}
else|else
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|kq
operator|->
name|kq_head
argument_list|,
name|kn
argument_list|,
name|kn_tqe
argument_list|)
expr_stmt|;
name|kn
operator|->
name|kn_status
operator|&=
operator|~
operator|(
name|KN_INFLUX
operator||
name|KN_SCAN
operator|)
expr_stmt|;
name|kn_list_unlock
argument_list|(
name|knl
argument_list|)
expr_stmt|;
name|influx
operator|=
literal|1
expr_stmt|;
block|}
comment|/* we are returning a copy to the user */
name|kevp
operator|++
expr_stmt|;
name|nkev
operator|++
expr_stmt|;
name|count
operator|--
expr_stmt|;
if|if
condition|(
name|nkev
operator|==
name|KQ_NEVENTS
condition|)
block|{
name|influx
operator|=
literal|0
expr_stmt|;
name|KQ_UNLOCK_FLUX
argument_list|(
name|kq
argument_list|)
expr_stmt|;
name|error
operator|=
name|k_ops
operator|->
name|k_copyout
argument_list|(
name|k_ops
operator|->
name|arg
argument_list|,
name|keva
argument_list|,
name|nkev
argument_list|)
expr_stmt|;
name|nkev
operator|=
literal|0
expr_stmt|;
name|kevp
operator|=
name|keva
expr_stmt|;
name|KQ_LOCK
argument_list|(
name|kq
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
block|}
block|}
name|TAILQ_REMOVE
argument_list|(
operator|&
name|kq
operator|->
name|kq_head
argument_list|,
name|marker
argument_list|,
name|kn_tqe
argument_list|)
expr_stmt|;
name|done
label|:
name|KQ_OWNED
argument_list|(
name|kq
argument_list|)
expr_stmt|;
name|KQ_UNLOCK_FLUX
argument_list|(
name|kq
argument_list|)
expr_stmt|;
name|knote_free
argument_list|(
name|marker
argument_list|)
expr_stmt|;
name|done_nl
label|:
name|KQ_NOTOWNED
argument_list|(
name|kq
argument_list|)
expr_stmt|;
if|if
condition|(
name|nkev
operator|!=
literal|0
condition|)
name|error
operator|=
name|k_ops
operator|->
name|k_copyout
argument_list|(
name|k_ops
operator|->
name|arg
argument_list|,
name|keva
argument_list|,
name|nkev
argument_list|)
expr_stmt|;
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|=
name|maxevents
operator|-
name|count
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|int
name|kqueue_ioctl
parameter_list|(
name|struct
name|file
modifier|*
name|fp
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|struct
name|ucred
modifier|*
name|active_cred
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
comment|/* 	 * Enabling sigio causes two major problems: 	 * 1) infinite recursion: 	 * Synopsys: kevent is being used to track signals and have FIOASYNC 	 * set.  On receipt of a signal this will cause a kqueue to recurse 	 * into itself over and over.  Sending the sigio causes the kqueue 	 * to become ready, which in turn posts sigio again, forever. 	 * Solution: this can be solved by setting a flag in the kqueue that 	 * we have a SIGIO in progress. 	 * 2) locking problems: 	 * Synopsys: Kqueue is a leaf subsystem, but adding signalling puts 	 * us above the proc and pgrp locks. 	 * Solution: Post a signal using an async mechanism, being sure to 	 * record a generation count in the delivery so that we do not deliver 	 * a signal to the wrong process. 	 * 	 * Note, these two mechanisms are somewhat mutually exclusive! 	 */
if|#
directive|if
literal|0
block|struct kqueue *kq;  	kq = fp->f_data; 	switch (cmd) { 	case FIOASYNC: 		if (*(int *)data) { 			kq->kq_state |= KQ_ASYNC; 		} else { 			kq->kq_state&= ~KQ_ASYNC; 		} 		return (0);  	case FIOSETOWN: 		return (fsetown(*(int *)data,&kq->kq_sigio));  	case FIOGETOWN: 		*(int *)data = fgetown(&kq->kq_sigio); 		return (0); 	}
endif|#
directive|endif
return|return
operator|(
name|ENOTTY
operator|)
return|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|int
name|kqueue_poll
parameter_list|(
name|struct
name|file
modifier|*
name|fp
parameter_list|,
name|int
name|events
parameter_list|,
name|struct
name|ucred
modifier|*
name|active_cred
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|kqueue
modifier|*
name|kq
decl_stmt|;
name|int
name|revents
init|=
literal|0
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|kqueue_acquire
argument_list|(
name|fp
argument_list|,
operator|&
name|kq
argument_list|)
operator|)
condition|)
return|return
name|POLLERR
return|;
name|KQ_LOCK
argument_list|(
name|kq
argument_list|)
expr_stmt|;
if|if
condition|(
name|events
operator|&
operator|(
name|POLLIN
operator||
name|POLLRDNORM
operator|)
condition|)
block|{
if|if
condition|(
name|kq
operator|->
name|kq_count
condition|)
block|{
name|revents
operator||=
name|events
operator|&
operator|(
name|POLLIN
operator||
name|POLLRDNORM
operator|)
expr_stmt|;
block|}
else|else
block|{
name|selrecord
argument_list|(
name|td
argument_list|,
operator|&
name|kq
operator|->
name|kq_sel
argument_list|)
expr_stmt|;
if|if
condition|(
name|SEL_WAITING
argument_list|(
operator|&
name|kq
operator|->
name|kq_sel
argument_list|)
condition|)
name|kq
operator|->
name|kq_state
operator||=
name|KQ_SEL
expr_stmt|;
block|}
block|}
name|kqueue_release
argument_list|(
name|kq
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|KQ_UNLOCK
argument_list|(
name|kq
argument_list|)
expr_stmt|;
return|return
operator|(
name|revents
operator|)
return|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|int
name|kqueue_stat
parameter_list|(
name|struct
name|file
modifier|*
name|fp
parameter_list|,
name|struct
name|stat
modifier|*
name|st
parameter_list|,
name|struct
name|ucred
modifier|*
name|active_cred
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|bzero
argument_list|(
operator|(
name|void
operator|*
operator|)
name|st
argument_list|,
sizeof|sizeof
expr|*
name|st
argument_list|)
expr_stmt|;
comment|/* 	 * We no longer return kq_count because the unlocked value is useless. 	 * If you spent all this time getting the count, why not spend your 	 * syscall better by calling kevent? 	 * 	 * XXX - This is needed for libc_r. 	 */
name|st
operator|->
name|st_mode
operator|=
name|S_IFIFO
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|kqueue_drain
parameter_list|(
name|struct
name|kqueue
modifier|*
name|kq
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|knote
modifier|*
name|kn
decl_stmt|;
name|int
name|i
decl_stmt|;
name|KQ_LOCK
argument_list|(
name|kq
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|kq
operator|->
name|kq_state
operator|&
name|KQ_CLOSING
operator|)
operator|!=
name|KQ_CLOSING
argument_list|,
operator|(
literal|"kqueue already closing"
operator|)
argument_list|)
expr_stmt|;
name|kq
operator|->
name|kq_state
operator||=
name|KQ_CLOSING
expr_stmt|;
if|if
condition|(
name|kq
operator|->
name|kq_refcnt
operator|>
literal|1
condition|)
name|msleep
argument_list|(
operator|&
name|kq
operator|->
name|kq_refcnt
argument_list|,
operator|&
name|kq
operator|->
name|kq_lock
argument_list|,
name|PSOCK
argument_list|,
literal|"kqclose"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|kq
operator|->
name|kq_refcnt
operator|==
literal|1
argument_list|,
operator|(
literal|"other refs are out there!"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|knlist_empty
argument_list|(
operator|&
name|kq
operator|->
name|kq_sel
operator|.
name|si_note
argument_list|)
argument_list|,
operator|(
literal|"kqueue's knlist not empty"
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|kq
operator|->
name|kq_knlistsize
condition|;
name|i
operator|++
control|)
block|{
while|while
condition|(
operator|(
name|kn
operator|=
name|SLIST_FIRST
argument_list|(
operator|&
name|kq
operator|->
name|kq_knlist
index|[
name|i
index|]
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|kn
operator|->
name|kn_status
operator|&
name|KN_INFLUX
operator|)
operator|==
name|KN_INFLUX
condition|)
block|{
name|kq
operator|->
name|kq_state
operator||=
name|KQ_FLUXWAIT
expr_stmt|;
name|msleep
argument_list|(
name|kq
argument_list|,
operator|&
name|kq
operator|->
name|kq_lock
argument_list|,
name|PSOCK
argument_list|,
literal|"kqclo1"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|kn
operator|->
name|kn_status
operator||=
name|KN_INFLUX
expr_stmt|;
name|KQ_UNLOCK
argument_list|(
name|kq
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|kn
operator|->
name|kn_status
operator|&
name|KN_DETACHED
operator|)
condition|)
name|kn
operator|->
name|kn_fop
operator|->
name|f_detach
argument_list|(
name|kn
argument_list|)
expr_stmt|;
name|knote_drop
argument_list|(
name|kn
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|KQ_LOCK
argument_list|(
name|kq
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|kq
operator|->
name|kq_knhashmask
operator|!=
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|kq
operator|->
name|kq_knhashmask
condition|;
name|i
operator|++
control|)
block|{
while|while
condition|(
operator|(
name|kn
operator|=
name|SLIST_FIRST
argument_list|(
operator|&
name|kq
operator|->
name|kq_knhash
index|[
name|i
index|]
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|kn
operator|->
name|kn_status
operator|&
name|KN_INFLUX
operator|)
operator|==
name|KN_INFLUX
condition|)
block|{
name|kq
operator|->
name|kq_state
operator||=
name|KQ_FLUXWAIT
expr_stmt|;
name|msleep
argument_list|(
name|kq
argument_list|,
operator|&
name|kq
operator|->
name|kq_lock
argument_list|,
name|PSOCK
argument_list|,
literal|"kqclo2"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|kn
operator|->
name|kn_status
operator||=
name|KN_INFLUX
expr_stmt|;
name|KQ_UNLOCK
argument_list|(
name|kq
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|kn
operator|->
name|kn_status
operator|&
name|KN_DETACHED
operator|)
condition|)
name|kn
operator|->
name|kn_fop
operator|->
name|f_detach
argument_list|(
name|kn
argument_list|)
expr_stmt|;
name|knote_drop
argument_list|(
name|kn
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|KQ_LOCK
argument_list|(
name|kq
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|(
name|kq
operator|->
name|kq_state
operator|&
name|KQ_TASKSCHED
operator|)
operator|==
name|KQ_TASKSCHED
condition|)
block|{
name|kq
operator|->
name|kq_state
operator||=
name|KQ_TASKDRAIN
expr_stmt|;
name|msleep
argument_list|(
operator|&
name|kq
operator|->
name|kq_state
argument_list|,
operator|&
name|kq
operator|->
name|kq_lock
argument_list|,
name|PSOCK
argument_list|,
literal|"kqtqdr"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|kq
operator|->
name|kq_state
operator|&
name|KQ_SEL
operator|)
operator|==
name|KQ_SEL
condition|)
block|{
name|selwakeuppri
argument_list|(
operator|&
name|kq
operator|->
name|kq_sel
argument_list|,
name|PSOCK
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|SEL_WAITING
argument_list|(
operator|&
name|kq
operator|->
name|kq_sel
argument_list|)
condition|)
name|kq
operator|->
name|kq_state
operator|&=
operator|~
name|KQ_SEL
expr_stmt|;
block|}
name|KQ_UNLOCK
argument_list|(
name|kq
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|kqueue_destroy
parameter_list|(
name|struct
name|kqueue
modifier|*
name|kq
parameter_list|)
block|{
name|KASSERT
argument_list|(
name|kq
operator|->
name|kq_fdp
operator|==
name|NULL
argument_list|,
operator|(
literal|"kqueue still attached to a file descriptor"
operator|)
argument_list|)
expr_stmt|;
name|seldrain
argument_list|(
operator|&
name|kq
operator|->
name|kq_sel
argument_list|)
expr_stmt|;
name|knlist_destroy
argument_list|(
operator|&
name|kq
operator|->
name|kq_sel
operator|.
name|si_note
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|kq
operator|->
name|kq_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|kq
operator|->
name|kq_knhash
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|kq
operator|->
name|kq_knhash
argument_list|,
name|M_KQUEUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|kq
operator|->
name|kq_knlist
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|kq
operator|->
name|kq_knlist
argument_list|,
name|M_KQUEUE
argument_list|)
expr_stmt|;
name|funsetown
argument_list|(
operator|&
name|kq
operator|->
name|kq_sigio
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|int
name|kqueue_close
parameter_list|(
name|struct
name|file
modifier|*
name|fp
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|kqueue
modifier|*
name|kq
init|=
name|fp
operator|->
name|f_data
decl_stmt|;
name|struct
name|filedesc
modifier|*
name|fdp
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|filedesc_unlock
decl_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|kqueue_acquire
argument_list|(
name|fp
argument_list|,
operator|&
name|kq
argument_list|)
operator|)
condition|)
return|return
name|error
return|;
name|kqueue_drain
argument_list|(
name|kq
argument_list|,
name|td
argument_list|)
expr_stmt|;
comment|/* 	 * We could be called due to the knote_drop() doing fdrop(), 	 * called from kqueue_register().  In this case the global 	 * lock is owned, and filedesc sx is locked before, to not 	 * take the sleepable lock after non-sleepable. 	 */
name|fdp
operator|=
name|kq
operator|->
name|kq_fdp
expr_stmt|;
name|kq
operator|->
name|kq_fdp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|sx_xlocked
argument_list|(
name|FILEDESC_LOCK
argument_list|(
name|fdp
argument_list|)
argument_list|)
condition|)
block|{
name|FILEDESC_XLOCK
argument_list|(
name|fdp
argument_list|)
expr_stmt|;
name|filedesc_unlock
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|filedesc_unlock
operator|=
literal|0
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|fdp
operator|->
name|fd_kqlist
argument_list|,
name|kq
argument_list|,
name|kq_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|filedesc_unlock
condition|)
name|FILEDESC_XUNLOCK
argument_list|(
name|fdp
argument_list|)
expr_stmt|;
name|kqueue_destroy
argument_list|(
name|kq
argument_list|)
expr_stmt|;
name|chgkqcnt
argument_list|(
name|kq
operator|->
name|kq_cred
operator|->
name|cr_ruidinfo
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|crfree
argument_list|(
name|kq
operator|->
name|kq_cred
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|kq
argument_list|,
name|M_KQUEUE
argument_list|)
expr_stmt|;
name|fp
operator|->
name|f_data
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|kqueue_fill_kinfo
parameter_list|(
name|struct
name|file
modifier|*
name|fp
parameter_list|,
name|struct
name|kinfo_file
modifier|*
name|kif
parameter_list|,
name|struct
name|filedesc
modifier|*
name|fdp
parameter_list|)
block|{
name|kif
operator|->
name|kf_type
operator|=
name|KF_TYPE_KQUEUE
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|kqueue_wakeup
parameter_list|(
name|struct
name|kqueue
modifier|*
name|kq
parameter_list|)
block|{
name|KQ_OWNED
argument_list|(
name|kq
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|kq
operator|->
name|kq_state
operator|&
name|KQ_SLEEP
operator|)
operator|==
name|KQ_SLEEP
condition|)
block|{
name|kq
operator|->
name|kq_state
operator|&=
operator|~
name|KQ_SLEEP
expr_stmt|;
name|wakeup
argument_list|(
name|kq
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|kq
operator|->
name|kq_state
operator|&
name|KQ_SEL
operator|)
operator|==
name|KQ_SEL
condition|)
block|{
name|selwakeuppri
argument_list|(
operator|&
name|kq
operator|->
name|kq_sel
argument_list|,
name|PSOCK
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|SEL_WAITING
argument_list|(
operator|&
name|kq
operator|->
name|kq_sel
argument_list|)
condition|)
name|kq
operator|->
name|kq_state
operator|&=
operator|~
name|KQ_SEL
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|knlist_empty
argument_list|(
operator|&
name|kq
operator|->
name|kq_sel
operator|.
name|si_note
argument_list|)
condition|)
name|kqueue_schedtask
argument_list|(
name|kq
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|kq
operator|->
name|kq_state
operator|&
name|KQ_ASYNC
operator|)
operator|==
name|KQ_ASYNC
condition|)
block|{
name|pgsigio
argument_list|(
operator|&
name|kq
operator|->
name|kq_sigio
argument_list|,
name|SIGIO
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Walk down a list of knotes, activating them if their event has triggered.  *  * There is a possibility to optimize in the case of one kq watching another.  * Instead of scheduling a task to wake it up, you could pass enough state  * down the chain to make up the parent kqueue.  Make this code functional  * first.  */
end_comment

begin_function
name|void
name|knote
parameter_list|(
name|struct
name|knlist
modifier|*
name|list
parameter_list|,
name|long
name|hint
parameter_list|,
name|int
name|lockflags
parameter_list|)
block|{
name|struct
name|kqueue
modifier|*
name|kq
decl_stmt|;
name|struct
name|knote
modifier|*
name|kn
decl_stmt|,
modifier|*
name|tkn
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|list
operator|==
name|NULL
condition|)
return|return;
name|KNL_ASSERT_LOCK
argument_list|(
name|list
argument_list|,
name|lockflags
operator|&
name|KNF_LISTLOCKED
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|lockflags
operator|&
name|KNF_LISTLOCKED
operator|)
operator|==
literal|0
condition|)
name|list
operator|->
name|kl_lock
argument_list|(
name|list
operator|->
name|kl_lockarg
argument_list|)
expr_stmt|;
comment|/* 	 * If we unlock the list lock (and set KN_INFLUX), we can 	 * eliminate the kqueue scheduling, but this will introduce 	 * four lock/unlock's for each knote to test.  Also, marker 	 * would be needed to keep iteration position, since filters 	 * or other threads could remove events. 	 */
name|SLIST_FOREACH_SAFE
argument_list|(
argument|kn
argument_list|,
argument|&list->kl_list
argument_list|,
argument|kn_selnext
argument_list|,
argument|tkn
argument_list|)
block|{
name|kq
operator|=
name|kn
operator|->
name|kn_kq
expr_stmt|;
name|KQ_LOCK
argument_list|(
name|kq
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|kn
operator|->
name|kn_status
operator|&
operator|(
name|KN_INFLUX
operator||
name|KN_SCAN
operator|)
operator|)
operator|==
name|KN_INFLUX
condition|)
block|{
comment|/* 			 * Do not process the influx notes, except for 			 * the influx coming from the kq unlock in the 			 * kqueue_scan().  In the later case, we do 			 * not interfere with the scan, since the code 			 * fragment in kqueue_scan() locks the knlist, 			 * and cannot proceed until we finished. 			 */
name|KQ_UNLOCK
argument_list|(
name|kq
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|lockflags
operator|&
name|KNF_NOKQLOCK
operator|)
operator|!=
literal|0
condition|)
block|{
name|kn
operator|->
name|kn_status
operator||=
name|KN_INFLUX
expr_stmt|;
name|KQ_UNLOCK
argument_list|(
name|kq
argument_list|)
expr_stmt|;
name|error
operator|=
name|kn
operator|->
name|kn_fop
operator|->
name|f_event
argument_list|(
name|kn
argument_list|,
name|hint
argument_list|)
expr_stmt|;
name|KQ_LOCK
argument_list|(
name|kq
argument_list|)
expr_stmt|;
name|kn
operator|->
name|kn_status
operator|&=
operator|~
name|KN_INFLUX
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|KNOTE_ACTIVATE
argument_list|(
name|kn
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|KQ_UNLOCK_FLUX
argument_list|(
name|kq
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|kn
operator|->
name|kn_status
operator||=
name|KN_HASKQLOCK
expr_stmt|;
if|if
condition|(
name|kn
operator|->
name|kn_fop
operator|->
name|f_event
argument_list|(
name|kn
argument_list|,
name|hint
argument_list|)
condition|)
name|KNOTE_ACTIVATE
argument_list|(
name|kn
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|kn
operator|->
name|kn_status
operator|&=
operator|~
name|KN_HASKQLOCK
expr_stmt|;
name|KQ_UNLOCK
argument_list|(
name|kq
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|lockflags
operator|&
name|KNF_LISTLOCKED
operator|)
operator|==
literal|0
condition|)
name|list
operator|->
name|kl_unlock
argument_list|(
name|list
operator|->
name|kl_lockarg
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * add a knote to a knlist  */
end_comment

begin_function
name|void
name|knlist_add
parameter_list|(
name|struct
name|knlist
modifier|*
name|knl
parameter_list|,
name|struct
name|knote
modifier|*
name|kn
parameter_list|,
name|int
name|islocked
parameter_list|)
block|{
name|KNL_ASSERT_LOCK
argument_list|(
name|knl
argument_list|,
name|islocked
argument_list|)
expr_stmt|;
name|KQ_NOTOWNED
argument_list|(
name|kn
operator|->
name|kn_kq
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|kn
operator|->
name|kn_status
operator|&
operator|(
name|KN_INFLUX
operator||
name|KN_DETACHED
operator|)
operator|)
operator|==
operator|(
name|KN_INFLUX
operator||
name|KN_DETACHED
operator|)
argument_list|,
operator|(
literal|"knote not KN_INFLUX and KN_DETACHED"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|islocked
condition|)
name|knl
operator|->
name|kl_lock
argument_list|(
name|knl
operator|->
name|kl_lockarg
argument_list|)
expr_stmt|;
name|SLIST_INSERT_HEAD
argument_list|(
operator|&
name|knl
operator|->
name|kl_list
argument_list|,
name|kn
argument_list|,
name|kn_selnext
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|islocked
condition|)
name|knl
operator|->
name|kl_unlock
argument_list|(
name|knl
operator|->
name|kl_lockarg
argument_list|)
expr_stmt|;
name|KQ_LOCK
argument_list|(
name|kn
operator|->
name|kn_kq
argument_list|)
expr_stmt|;
name|kn
operator|->
name|kn_knlist
operator|=
name|knl
expr_stmt|;
name|kn
operator|->
name|kn_status
operator|&=
operator|~
name|KN_DETACHED
expr_stmt|;
name|KQ_UNLOCK
argument_list|(
name|kn
operator|->
name|kn_kq
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|knlist_remove_kq
parameter_list|(
name|struct
name|knlist
modifier|*
name|knl
parameter_list|,
name|struct
name|knote
modifier|*
name|kn
parameter_list|,
name|int
name|knlislocked
parameter_list|,
name|int
name|kqislocked
parameter_list|)
block|{
name|KASSERT
argument_list|(
operator|!
operator|(
operator|!
operator|!
name|kqislocked
operator|&&
operator|!
name|knlislocked
operator|)
argument_list|,
operator|(
literal|"kq locked w/o knl locked"
operator|)
argument_list|)
expr_stmt|;
name|KNL_ASSERT_LOCK
argument_list|(
name|knl
argument_list|,
name|knlislocked
argument_list|)
expr_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|kn
operator|->
name|kn_kq
operator|->
name|kq_lock
argument_list|,
name|kqislocked
condition|?
name|MA_OWNED
else|:
name|MA_NOTOWNED
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|kqislocked
condition|)
name|KASSERT
argument_list|(
operator|(
name|kn
operator|->
name|kn_status
operator|&
operator|(
name|KN_INFLUX
operator||
name|KN_DETACHED
operator|)
operator|)
operator|==
name|KN_INFLUX
argument_list|,
operator|(
literal|"knlist_remove called w/o knote being KN_INFLUX or already removed"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|knlislocked
condition|)
name|knl
operator|->
name|kl_lock
argument_list|(
name|knl
operator|->
name|kl_lockarg
argument_list|)
expr_stmt|;
name|SLIST_REMOVE
argument_list|(
operator|&
name|knl
operator|->
name|kl_list
argument_list|,
name|kn
argument_list|,
name|knote
argument_list|,
name|kn_selnext
argument_list|)
expr_stmt|;
name|kn
operator|->
name|kn_knlist
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|knlislocked
condition|)
name|kn_list_unlock
argument_list|(
name|knl
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|kqislocked
condition|)
name|KQ_LOCK
argument_list|(
name|kn
operator|->
name|kn_kq
argument_list|)
expr_stmt|;
name|kn
operator|->
name|kn_status
operator||=
name|KN_DETACHED
expr_stmt|;
if|if
condition|(
operator|!
name|kqislocked
condition|)
name|KQ_UNLOCK
argument_list|(
name|kn
operator|->
name|kn_kq
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * remove knote from the specified knlist  */
end_comment

begin_function
name|void
name|knlist_remove
parameter_list|(
name|struct
name|knlist
modifier|*
name|knl
parameter_list|,
name|struct
name|knote
modifier|*
name|kn
parameter_list|,
name|int
name|islocked
parameter_list|)
block|{
name|knlist_remove_kq
argument_list|(
name|knl
argument_list|,
name|kn
argument_list|,
name|islocked
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|knlist_empty
parameter_list|(
name|struct
name|knlist
modifier|*
name|knl
parameter_list|)
block|{
name|KNL_ASSERT_LOCKED
argument_list|(
name|knl
argument_list|)
expr_stmt|;
return|return
name|SLIST_EMPTY
argument_list|(
operator|&
name|knl
operator|->
name|kl_list
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|mtx
name|knlist_lock
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|MTX_SYSINIT
argument_list|(
name|knlist_lock
argument_list|,
operator|&
name|knlist_lock
argument_list|,
literal|"knlist lock for lockless objects"
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function_decl
specifier|static
name|void
name|knlist_mtx_lock
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|knlist_mtx_unlock
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|void
name|knlist_mtx_lock
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|mtx_lock
argument_list|(
operator|(
expr|struct
name|mtx
operator|*
operator|)
name|arg
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|knlist_mtx_unlock
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|mtx_unlock
argument_list|(
operator|(
expr|struct
name|mtx
operator|*
operator|)
name|arg
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|knlist_mtx_assert_locked
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|mtx_assert
argument_list|(
operator|(
expr|struct
name|mtx
operator|*
operator|)
name|arg
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|knlist_mtx_assert_unlocked
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|mtx_assert
argument_list|(
operator|(
expr|struct
name|mtx
operator|*
operator|)
name|arg
argument_list|,
name|MA_NOTOWNED
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|knlist_rw_rlock
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|rw_rlock
argument_list|(
operator|(
expr|struct
name|rwlock
operator|*
operator|)
name|arg
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|knlist_rw_runlock
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|rw_runlock
argument_list|(
operator|(
expr|struct
name|rwlock
operator|*
operator|)
name|arg
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|knlist_rw_assert_locked
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|rw_assert
argument_list|(
operator|(
expr|struct
name|rwlock
operator|*
operator|)
name|arg
argument_list|,
name|RA_LOCKED
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|knlist_rw_assert_unlocked
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|rw_assert
argument_list|(
operator|(
expr|struct
name|rwlock
operator|*
operator|)
name|arg
argument_list|,
name|RA_UNLOCKED
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|knlist_init
parameter_list|(
name|struct
name|knlist
modifier|*
name|knl
parameter_list|,
name|void
modifier|*
name|lock
parameter_list|,
name|void
function_decl|(
modifier|*
name|kl_lock
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
function_decl|(
modifier|*
name|kl_unlock
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
function_decl|(
modifier|*
name|kl_assert_locked
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
function_decl|(
modifier|*
name|kl_assert_unlocked
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|)
parameter_list|)
block|{
if|if
condition|(
name|lock
operator|==
name|NULL
condition|)
name|knl
operator|->
name|kl_lockarg
operator|=
operator|&
name|knlist_lock
expr_stmt|;
else|else
name|knl
operator|->
name|kl_lockarg
operator|=
name|lock
expr_stmt|;
if|if
condition|(
name|kl_lock
operator|==
name|NULL
condition|)
name|knl
operator|->
name|kl_lock
operator|=
name|knlist_mtx_lock
expr_stmt|;
else|else
name|knl
operator|->
name|kl_lock
operator|=
name|kl_lock
expr_stmt|;
if|if
condition|(
name|kl_unlock
operator|==
name|NULL
condition|)
name|knl
operator|->
name|kl_unlock
operator|=
name|knlist_mtx_unlock
expr_stmt|;
else|else
name|knl
operator|->
name|kl_unlock
operator|=
name|kl_unlock
expr_stmt|;
if|if
condition|(
name|kl_assert_locked
operator|==
name|NULL
condition|)
name|knl
operator|->
name|kl_assert_locked
operator|=
name|knlist_mtx_assert_locked
expr_stmt|;
else|else
name|knl
operator|->
name|kl_assert_locked
operator|=
name|kl_assert_locked
expr_stmt|;
if|if
condition|(
name|kl_assert_unlocked
operator|==
name|NULL
condition|)
name|knl
operator|->
name|kl_assert_unlocked
operator|=
name|knlist_mtx_assert_unlocked
expr_stmt|;
else|else
name|knl
operator|->
name|kl_assert_unlocked
operator|=
name|kl_assert_unlocked
expr_stmt|;
name|knl
operator|->
name|kl_autodestroy
operator|=
literal|0
expr_stmt|;
name|SLIST_INIT
argument_list|(
operator|&
name|knl
operator|->
name|kl_list
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|knlist_init_mtx
parameter_list|(
name|struct
name|knlist
modifier|*
name|knl
parameter_list|,
name|struct
name|mtx
modifier|*
name|lock
parameter_list|)
block|{
name|knlist_init
argument_list|(
name|knl
argument_list|,
name|lock
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|struct
name|knlist
modifier|*
name|knlist_alloc
parameter_list|(
name|struct
name|mtx
modifier|*
name|lock
parameter_list|)
block|{
name|struct
name|knlist
modifier|*
name|knl
decl_stmt|;
name|knl
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|knlist
argument_list|)
argument_list|,
name|M_KQUEUE
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|knlist_init_mtx
argument_list|(
name|knl
argument_list|,
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|knl
operator|)
return|;
block|}
end_function

begin_function
name|void
name|knlist_init_rw_reader
parameter_list|(
name|struct
name|knlist
modifier|*
name|knl
parameter_list|,
name|struct
name|rwlock
modifier|*
name|lock
parameter_list|)
block|{
name|knlist_init
argument_list|(
name|knl
argument_list|,
name|lock
argument_list|,
name|knlist_rw_rlock
argument_list|,
name|knlist_rw_runlock
argument_list|,
name|knlist_rw_assert_locked
argument_list|,
name|knlist_rw_assert_unlocked
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|knlist_destroy
parameter_list|(
name|struct
name|knlist
modifier|*
name|knl
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|INVARIANTS
comment|/* 	 * if we run across this error, we need to find the offending 	 * driver and have it call knlist_clear or knlist_delete. 	 */
if|if
condition|(
operator|!
name|SLIST_EMPTY
argument_list|(
operator|&
name|knl
operator|->
name|kl_list
argument_list|)
condition|)
name|printf
argument_list|(
literal|"WARNING: destroying knlist w/ knotes on it!\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|knl
operator|->
name|kl_lockarg
operator|=
name|knl
operator|->
name|kl_lock
operator|=
name|knl
operator|->
name|kl_unlock
operator|=
name|NULL
expr_stmt|;
name|SLIST_INIT
argument_list|(
operator|&
name|knl
operator|->
name|kl_list
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|knlist_detach
parameter_list|(
name|struct
name|knlist
modifier|*
name|knl
parameter_list|)
block|{
name|KNL_ASSERT_LOCKED
argument_list|(
name|knl
argument_list|)
expr_stmt|;
name|knl
operator|->
name|kl_autodestroy
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|knlist_empty
argument_list|(
name|knl
argument_list|)
condition|)
block|{
name|knlist_destroy
argument_list|(
name|knl
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|knl
argument_list|,
name|M_KQUEUE
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Even if we are locked, we may need to drop the lock to allow any influx  * knotes time to "settle".  */
end_comment

begin_function
name|void
name|knlist_cleardel
parameter_list|(
name|struct
name|knlist
modifier|*
name|knl
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|int
name|islocked
parameter_list|,
name|int
name|killkn
parameter_list|)
block|{
name|struct
name|knote
modifier|*
name|kn
decl_stmt|,
modifier|*
name|kn2
decl_stmt|;
name|struct
name|kqueue
modifier|*
name|kq
decl_stmt|;
name|KASSERT
argument_list|(
operator|!
name|knl
operator|->
name|kl_autodestroy
argument_list|,
operator|(
literal|"cleardel for autodestroy %p"
operator|,
name|knl
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|islocked
condition|)
name|KNL_ASSERT_LOCKED
argument_list|(
name|knl
argument_list|)
expr_stmt|;
else|else
block|{
name|KNL_ASSERT_UNLOCKED
argument_list|(
name|knl
argument_list|)
expr_stmt|;
name|again
label|:
comment|/* need to reacquire lock since we have dropped it */
name|knl
operator|->
name|kl_lock
argument_list|(
name|knl
operator|->
name|kl_lockarg
argument_list|)
expr_stmt|;
block|}
name|SLIST_FOREACH_SAFE
argument_list|(
argument|kn
argument_list|,
argument|&knl->kl_list
argument_list|,
argument|kn_selnext
argument_list|,
argument|kn2
argument_list|)
block|{
name|kq
operator|=
name|kn
operator|->
name|kn_kq
expr_stmt|;
name|KQ_LOCK
argument_list|(
name|kq
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|kn
operator|->
name|kn_status
operator|&
name|KN_INFLUX
operator|)
condition|)
block|{
name|KQ_UNLOCK
argument_list|(
name|kq
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|knlist_remove_kq
argument_list|(
name|knl
argument_list|,
name|kn
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|killkn
condition|)
block|{
name|kn
operator|->
name|kn_status
operator||=
name|KN_INFLUX
operator||
name|KN_DETACHED
expr_stmt|;
name|KQ_UNLOCK
argument_list|(
name|kq
argument_list|)
expr_stmt|;
name|knote_drop
argument_list|(
name|kn
argument_list|,
name|td
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Make sure cleared knotes disappear soon */
name|kn
operator|->
name|kn_flags
operator||=
operator|(
name|EV_EOF
operator||
name|EV_ONESHOT
operator|)
expr_stmt|;
name|KQ_UNLOCK
argument_list|(
name|kq
argument_list|)
expr_stmt|;
block|}
name|kq
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|SLIST_EMPTY
argument_list|(
operator|&
name|knl
operator|->
name|kl_list
argument_list|)
condition|)
block|{
comment|/* there are still KN_INFLUX remaining */
name|kn
operator|=
name|SLIST_FIRST
argument_list|(
operator|&
name|knl
operator|->
name|kl_list
argument_list|)
expr_stmt|;
name|kq
operator|=
name|kn
operator|->
name|kn_kq
expr_stmt|;
name|KQ_LOCK
argument_list|(
name|kq
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|kn
operator|->
name|kn_status
operator|&
name|KN_INFLUX
argument_list|,
operator|(
literal|"knote removed w/o list lock"
operator|)
argument_list|)
expr_stmt|;
name|knl
operator|->
name|kl_unlock
argument_list|(
name|knl
operator|->
name|kl_lockarg
argument_list|)
expr_stmt|;
name|kq
operator|->
name|kq_state
operator||=
name|KQ_FLUXWAIT
expr_stmt|;
name|msleep
argument_list|(
name|kq
argument_list|,
operator|&
name|kq
operator|->
name|kq_lock
argument_list|,
name|PSOCK
operator||
name|PDROP
argument_list|,
literal|"kqkclr"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|kq
operator|=
name|NULL
expr_stmt|;
goto|goto
name|again
goto|;
block|}
if|if
condition|(
name|islocked
condition|)
name|KNL_ASSERT_LOCKED
argument_list|(
name|knl
argument_list|)
expr_stmt|;
else|else
block|{
name|knl
operator|->
name|kl_unlock
argument_list|(
name|knl
operator|->
name|kl_lockarg
argument_list|)
expr_stmt|;
name|KNL_ASSERT_UNLOCKED
argument_list|(
name|knl
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Remove all knotes referencing a specified fd must be called with FILEDESC  * lock.  This prevents a race where a new fd comes along and occupies the  * entry and we attach a knote to the fd.  */
end_comment

begin_function
name|void
name|knote_fdclose
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|int
name|fd
parameter_list|)
block|{
name|struct
name|filedesc
modifier|*
name|fdp
init|=
name|td
operator|->
name|td_proc
operator|->
name|p_fd
decl_stmt|;
name|struct
name|kqueue
modifier|*
name|kq
decl_stmt|;
name|struct
name|knote
modifier|*
name|kn
decl_stmt|;
name|int
name|influx
decl_stmt|;
name|FILEDESC_XLOCK_ASSERT
argument_list|(
name|fdp
argument_list|)
expr_stmt|;
comment|/* 	 * We shouldn't have to worry about new kevents appearing on fd 	 * since filedesc is locked. 	 */
name|TAILQ_FOREACH
argument_list|(
argument|kq
argument_list|,
argument|&fdp->fd_kqlist
argument_list|,
argument|kq_list
argument_list|)
block|{
name|KQ_LOCK
argument_list|(
name|kq
argument_list|)
expr_stmt|;
name|again
label|:
name|influx
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|kq
operator|->
name|kq_knlistsize
operator|>
name|fd
operator|&&
operator|(
name|kn
operator|=
name|SLIST_FIRST
argument_list|(
operator|&
name|kq
operator|->
name|kq_knlist
index|[
name|fd
index|]
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|kn
operator|->
name|kn_status
operator|&
name|KN_INFLUX
condition|)
block|{
comment|/* someone else might be waiting on our knote */
if|if
condition|(
name|influx
condition|)
name|wakeup
argument_list|(
name|kq
argument_list|)
expr_stmt|;
name|kq
operator|->
name|kq_state
operator||=
name|KQ_FLUXWAIT
expr_stmt|;
name|msleep
argument_list|(
name|kq
argument_list|,
operator|&
name|kq
operator|->
name|kq_lock
argument_list|,
name|PSOCK
argument_list|,
literal|"kqflxwt"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|again
goto|;
block|}
name|kn
operator|->
name|kn_status
operator||=
name|KN_INFLUX
expr_stmt|;
name|KQ_UNLOCK
argument_list|(
name|kq
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|kn
operator|->
name|kn_status
operator|&
name|KN_DETACHED
operator|)
condition|)
name|kn
operator|->
name|kn_fop
operator|->
name|f_detach
argument_list|(
name|kn
argument_list|)
expr_stmt|;
name|knote_drop
argument_list|(
name|kn
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|influx
operator|=
literal|1
expr_stmt|;
name|KQ_LOCK
argument_list|(
name|kq
argument_list|)
expr_stmt|;
block|}
name|KQ_UNLOCK_FLUX
argument_list|(
name|kq
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|knote_attach
parameter_list|(
name|struct
name|knote
modifier|*
name|kn
parameter_list|,
name|struct
name|kqueue
modifier|*
name|kq
parameter_list|)
block|{
name|struct
name|klist
modifier|*
name|list
decl_stmt|;
name|KASSERT
argument_list|(
name|kn
operator|->
name|kn_status
operator|&
name|KN_INFLUX
argument_list|,
operator|(
literal|"knote not marked INFLUX"
operator|)
argument_list|)
expr_stmt|;
name|KQ_OWNED
argument_list|(
name|kq
argument_list|)
expr_stmt|;
if|if
condition|(
name|kn
operator|->
name|kn_fop
operator|->
name|f_isfd
condition|)
block|{
if|if
condition|(
name|kn
operator|->
name|kn_id
operator|>=
name|kq
operator|->
name|kq_knlistsize
condition|)
return|return
name|ENOMEM
return|;
name|list
operator|=
operator|&
name|kq
operator|->
name|kq_knlist
index|[
name|kn
operator|->
name|kn_id
index|]
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|kq
operator|->
name|kq_knhash
operator|==
name|NULL
condition|)
return|return
name|ENOMEM
return|;
name|list
operator|=
operator|&
name|kq
operator|->
name|kq_knhash
index|[
name|KN_HASH
argument_list|(
name|kn
operator|->
name|kn_id
argument_list|,
name|kq
operator|->
name|kq_knhashmask
argument_list|)
index|]
expr_stmt|;
block|}
name|SLIST_INSERT_HEAD
argument_list|(
name|list
argument_list|,
name|kn
argument_list|,
name|kn_link
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * knote must already have been detached using the f_detach method.  * no lock need to be held, it is assumed that the KN_INFLUX flag is set  * to prevent other removal.  */
end_comment

begin_function
specifier|static
name|void
name|knote_drop
parameter_list|(
name|struct
name|knote
modifier|*
name|kn
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|kqueue
modifier|*
name|kq
decl_stmt|;
name|struct
name|klist
modifier|*
name|list
decl_stmt|;
name|kq
operator|=
name|kn
operator|->
name|kn_kq
expr_stmt|;
name|KQ_NOTOWNED
argument_list|(
name|kq
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|kn
operator|->
name|kn_status
operator|&
name|KN_INFLUX
operator|)
operator|==
name|KN_INFLUX
argument_list|,
operator|(
literal|"knote_drop called without KN_INFLUX set in kn_status"
operator|)
argument_list|)
expr_stmt|;
name|KQ_LOCK
argument_list|(
name|kq
argument_list|)
expr_stmt|;
if|if
condition|(
name|kn
operator|->
name|kn_fop
operator|->
name|f_isfd
condition|)
name|list
operator|=
operator|&
name|kq
operator|->
name|kq_knlist
index|[
name|kn
operator|->
name|kn_id
index|]
expr_stmt|;
else|else
name|list
operator|=
operator|&
name|kq
operator|->
name|kq_knhash
index|[
name|KN_HASH
argument_list|(
name|kn
operator|->
name|kn_id
argument_list|,
name|kq
operator|->
name|kq_knhashmask
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|SLIST_EMPTY
argument_list|(
name|list
argument_list|)
condition|)
name|SLIST_REMOVE
argument_list|(
name|list
argument_list|,
name|kn
argument_list|,
name|knote
argument_list|,
name|kn_link
argument_list|)
expr_stmt|;
if|if
condition|(
name|kn
operator|->
name|kn_status
operator|&
name|KN_QUEUED
condition|)
name|knote_dequeue
argument_list|(
name|kn
argument_list|)
expr_stmt|;
name|KQ_UNLOCK_FLUX
argument_list|(
name|kq
argument_list|)
expr_stmt|;
if|if
condition|(
name|kn
operator|->
name|kn_fop
operator|->
name|f_isfd
condition|)
block|{
name|fdrop
argument_list|(
name|kn
operator|->
name|kn_fp
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|kn
operator|->
name|kn_fp
operator|=
name|NULL
expr_stmt|;
block|}
name|kqueue_fo_release
argument_list|(
name|kn
operator|->
name|kn_kevent
operator|.
name|filter
argument_list|)
expr_stmt|;
name|kn
operator|->
name|kn_fop
operator|=
name|NULL
expr_stmt|;
name|knote_free
argument_list|(
name|kn
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|knote_enqueue
parameter_list|(
name|struct
name|knote
modifier|*
name|kn
parameter_list|)
block|{
name|struct
name|kqueue
modifier|*
name|kq
init|=
name|kn
operator|->
name|kn_kq
decl_stmt|;
name|KQ_OWNED
argument_list|(
name|kn
operator|->
name|kn_kq
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|kn
operator|->
name|kn_status
operator|&
name|KN_QUEUED
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"knote already queued"
operator|)
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|kq
operator|->
name|kq_head
argument_list|,
name|kn
argument_list|,
name|kn_tqe
argument_list|)
expr_stmt|;
name|kn
operator|->
name|kn_status
operator||=
name|KN_QUEUED
expr_stmt|;
name|kq
operator|->
name|kq_count
operator|++
expr_stmt|;
name|kqueue_wakeup
argument_list|(
name|kq
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|knote_dequeue
parameter_list|(
name|struct
name|knote
modifier|*
name|kn
parameter_list|)
block|{
name|struct
name|kqueue
modifier|*
name|kq
init|=
name|kn
operator|->
name|kn_kq
decl_stmt|;
name|KQ_OWNED
argument_list|(
name|kn
operator|->
name|kn_kq
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|kn
operator|->
name|kn_status
operator|&
name|KN_QUEUED
argument_list|,
operator|(
literal|"knote not queued"
operator|)
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|kq
operator|->
name|kq_head
argument_list|,
name|kn
argument_list|,
name|kn_tqe
argument_list|)
expr_stmt|;
name|kn
operator|->
name|kn_status
operator|&=
operator|~
name|KN_QUEUED
expr_stmt|;
name|kq
operator|->
name|kq_count
operator|--
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|knote_init
parameter_list|(
name|void
parameter_list|)
block|{
name|knote_zone
operator|=
name|uma_zcreate
argument_list|(
literal|"KNOTE"
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|knote
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|UMA_ALIGN_PTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|SYSINIT
argument_list|(
name|knote
argument_list|,
name|SI_SUB_PSEUDO
argument_list|,
name|SI_ORDER_ANY
argument_list|,
name|knote_init
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|struct
name|knote
modifier|*
name|knote_alloc
parameter_list|(
name|int
name|waitok
parameter_list|)
block|{
return|return
operator|(
name|uma_zalloc
argument_list|(
name|knote_zone
argument_list|,
operator|(
name|waitok
condition|?
name|M_WAITOK
else|:
name|M_NOWAIT
operator|)
operator||
name|M_ZERO
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|knote_free
parameter_list|(
name|struct
name|knote
modifier|*
name|kn
parameter_list|)
block|{
name|uma_zfree
argument_list|(
name|knote_zone
argument_list|,
name|kn
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Register the kev w/ the kq specified by fd.  */
end_comment

begin_function
name|int
name|kqfd_register
parameter_list|(
name|int
name|fd
parameter_list|,
name|struct
name|kevent
modifier|*
name|kev
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|int
name|waitok
parameter_list|)
block|{
name|struct
name|kqueue
modifier|*
name|kq
decl_stmt|;
name|struct
name|file
modifier|*
name|fp
decl_stmt|;
name|cap_rights_t
name|rights
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
name|fget
argument_list|(
name|td
argument_list|,
name|fd
argument_list|,
name|cap_rights_init
argument_list|(
operator|&
name|rights
argument_list|,
name|CAP_KQUEUE_CHANGE
argument_list|)
argument_list|,
operator|&
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
operator|(
name|error
operator|=
name|kqueue_acquire
argument_list|(
name|fp
argument_list|,
operator|&
name|kq
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|noacquire
goto|;
name|error
operator|=
name|kqueue_register
argument_list|(
name|kq
argument_list|,
name|kev
argument_list|,
name|td
argument_list|,
name|waitok
argument_list|)
expr_stmt|;
name|kqueue_release
argument_list|(
name|kq
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|noacquire
label|:
name|fdrop
argument_list|(
name|fp
argument_list|,
name|td
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

end_unit

