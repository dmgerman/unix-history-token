begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2012 EMC Corp.  * All rights reserved.  *  * Copyright (c) 1997, 1998 Justin T. Gibbs.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"opt_bus.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/bio.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/callout.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/memdesc.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_page.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_map.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_ccb.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_comment
comment|/*  * Load up data starting at offset within a region specified by a  * list of virtual address ranges until either length or the region  * are exhausted.  */
end_comment

begin_function
specifier|static
name|int
name|_bus_dmamap_load_vlist
parameter_list|(
name|bus_dma_tag_t
name|dmat
parameter_list|,
name|bus_dmamap_t
name|map
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|list
parameter_list|,
name|int
name|sglist_cnt
parameter_list|,
name|struct
name|pmap
modifier|*
name|pmap
parameter_list|,
name|int
modifier|*
name|nsegs
parameter_list|,
name|int
name|flags
parameter_list|,
name|size_t
name|offset
parameter_list|,
name|size_t
name|length
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
name|sglist_cnt
operator|>
literal|0
operator|&&
name|length
operator|!=
literal|0
condition|;
name|sglist_cnt
operator|--
operator|,
name|list
operator|++
control|)
block|{
name|char
modifier|*
name|addr
decl_stmt|;
name|size_t
name|ds_len
decl_stmt|;
name|KASSERT
argument_list|(
operator|(
name|offset
operator|<
name|list
operator|->
name|ds_len
operator|)
argument_list|,
operator|(
literal|"Invalid mid-segment offset"
operator|)
argument_list|)
expr_stmt|;
name|addr
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|list
operator|->
name|ds_addr
operator|+
name|offset
expr_stmt|;
name|ds_len
operator|=
name|list
operator|->
name|ds_len
operator|-
name|offset
expr_stmt|;
name|offset
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ds_len
operator|>
name|length
condition|)
name|ds_len
operator|=
name|length
expr_stmt|;
name|length
operator|-=
name|ds_len
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|ds_len
operator|!=
literal|0
operator|)
argument_list|,
operator|(
literal|"Segment length is zero"
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|_bus_dmamap_load_buffer
argument_list|(
name|dmat
argument_list|,
name|map
argument_list|,
name|addr
argument_list|,
name|ds_len
argument_list|,
name|pmap
argument_list|,
name|flags
argument_list|,
name|NULL
argument_list|,
name|nsegs
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Load a list of physical addresses.  */
end_comment

begin_function
specifier|static
name|int
name|_bus_dmamap_load_plist
parameter_list|(
name|bus_dma_tag_t
name|dmat
parameter_list|,
name|bus_dmamap_t
name|map
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|list
parameter_list|,
name|int
name|sglist_cnt
parameter_list|,
name|int
modifier|*
name|nsegs
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
name|sglist_cnt
operator|>
literal|0
condition|;
name|sglist_cnt
operator|--
operator|,
name|list
operator|++
control|)
block|{
name|error
operator|=
name|_bus_dmamap_load_phys
argument_list|(
name|dmat
argument_list|,
name|map
argument_list|,
operator|(
name|vm_paddr_t
operator|)
name|list
operator|->
name|ds_addr
argument_list|,
name|list
operator|->
name|ds_len
argument_list|,
name|flags
argument_list|,
name|NULL
argument_list|,
name|nsegs
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Load an mbuf chain.  */
end_comment

begin_function
specifier|static
name|int
name|_bus_dmamap_load_mbuf_sg
parameter_list|(
name|bus_dma_tag_t
name|dmat
parameter_list|,
name|bus_dmamap_t
name|map
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m0
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
modifier|*
name|nsegs
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|m
operator|=
name|m0
init|;
name|m
operator|!=
name|NULL
operator|&&
name|error
operator|==
literal|0
condition|;
name|m
operator|=
name|m
operator|->
name|m_next
control|)
block|{
if|if
condition|(
name|m
operator|->
name|m_len
operator|>
literal|0
condition|)
block|{
name|error
operator|=
name|_bus_dmamap_load_buffer
argument_list|(
name|dmat
argument_list|,
name|map
argument_list|,
name|m
operator|->
name|m_data
argument_list|,
name|m
operator|->
name|m_len
argument_list|,
name|kernel_pmap
argument_list|,
name|flags
operator||
name|BUS_DMA_LOAD_MBUF
argument_list|,
name|segs
argument_list|,
name|nsegs
argument_list|)
expr_stmt|;
block|}
block|}
name|CTR5
argument_list|(
name|KTR_BUSDMA
argument_list|,
literal|"%s: tag %p tag flags 0x%x error %d nsegs %d"
argument_list|,
name|__func__
argument_list|,
name|dmat
argument_list|,
name|flags
argument_list|,
name|error
argument_list|,
operator|*
name|nsegs
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Load tlen data starting at offset within a region specified by a list of  * physical pages.  */
end_comment

begin_function
specifier|static
name|int
name|_bus_dmamap_load_pages
parameter_list|(
name|bus_dma_tag_t
name|dmat
parameter_list|,
name|bus_dmamap_t
name|map
parameter_list|,
name|vm_page_t
modifier|*
name|pages
parameter_list|,
name|bus_size_t
name|tlen
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
modifier|*
name|nsegs
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|vm_paddr_t
name|paddr
decl_stmt|;
name|bus_size_t
name|len
decl_stmt|;
name|int
name|error
decl_stmt|,
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|error
operator|=
literal|0
init|;
name|error
operator|==
literal|0
operator|&&
name|tlen
operator|>
literal|0
condition|;
name|i
operator|++
operator|,
name|tlen
operator|-=
name|len
control|)
block|{
name|len
operator|=
name|min
argument_list|(
name|PAGE_SIZE
operator|-
name|offset
argument_list|,
name|tlen
argument_list|)
expr_stmt|;
name|paddr
operator|=
name|VM_PAGE_TO_PHYS
argument_list|(
name|pages
index|[
name|i
index|]
argument_list|)
operator|+
name|offset
expr_stmt|;
name|error
operator|=
name|_bus_dmamap_load_phys
argument_list|(
name|dmat
argument_list|,
name|map
argument_list|,
name|paddr
argument_list|,
name|len
argument_list|,
name|flags
argument_list|,
name|NULL
argument_list|,
name|nsegs
argument_list|)
expr_stmt|;
name|offset
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Load from block io.  */
end_comment

begin_function
specifier|static
name|int
name|_bus_dmamap_load_bio
parameter_list|(
name|bus_dma_tag_t
name|dmat
parameter_list|,
name|bus_dmamap_t
name|map
parameter_list|,
name|struct
name|bio
modifier|*
name|bio
parameter_list|,
name|int
modifier|*
name|nsegs
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
if|if
condition|(
operator|(
name|bio
operator|->
name|bio_flags
operator|&
name|BIO_VLIST
operator|)
operator|!=
literal|0
condition|)
block|{
name|bus_dma_segment_t
modifier|*
name|segs
init|=
operator|(
name|bus_dma_segment_t
operator|*
operator|)
name|bio
operator|->
name|bio_data
decl_stmt|;
return|return
operator|(
name|_bus_dmamap_load_vlist
argument_list|(
name|dmat
argument_list|,
name|map
argument_list|,
name|segs
argument_list|,
name|bio
operator|->
name|bio_ma_n
argument_list|,
name|kernel_pmap
argument_list|,
name|nsegs
argument_list|,
name|flags
argument_list|,
name|bio
operator|->
name|bio_ma_offset
argument_list|,
name|bio
operator|->
name|bio_bcount
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|bio
operator|->
name|bio_flags
operator|&
name|BIO_UNMAPPED
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|_bus_dmamap_load_pages
argument_list|(
name|dmat
argument_list|,
name|map
argument_list|,
name|bio
operator|->
name|bio_ma
argument_list|,
name|bio
operator|->
name|bio_bcount
argument_list|,
name|bio
operator|->
name|bio_ma_offset
argument_list|,
name|nsegs
argument_list|,
name|flags
argument_list|)
operator|)
return|;
return|return
operator|(
name|_bus_dmamap_load_buffer
argument_list|(
name|dmat
argument_list|,
name|map
argument_list|,
name|bio
operator|->
name|bio_data
argument_list|,
name|bio
operator|->
name|bio_bcount
argument_list|,
name|kernel_pmap
argument_list|,
name|flags
argument_list|,
name|NULL
argument_list|,
name|nsegs
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|bus_dmamap_load_ma_triv
parameter_list|(
name|bus_dma_tag_t
name|dmat
parameter_list|,
name|bus_dmamap_t
name|map
parameter_list|,
name|struct
name|vm_page
modifier|*
modifier|*
name|ma
parameter_list|,
name|bus_size_t
name|tlen
parameter_list|,
name|int
name|ma_offs
parameter_list|,
name|int
name|flags
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
modifier|*
name|segp
parameter_list|)
block|{
name|vm_paddr_t
name|paddr
decl_stmt|;
name|bus_size_t
name|len
decl_stmt|;
name|int
name|error
decl_stmt|,
name|i
decl_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|tlen
operator|>
literal|0
condition|;
name|i
operator|++
operator|,
name|tlen
operator|-=
name|len
control|)
block|{
name|len
operator|=
name|min
argument_list|(
name|PAGE_SIZE
operator|-
name|ma_offs
argument_list|,
name|tlen
argument_list|)
expr_stmt|;
name|paddr
operator|=
name|VM_PAGE_TO_PHYS
argument_list|(
name|ma
index|[
name|i
index|]
argument_list|)
operator|+
name|ma_offs
expr_stmt|;
name|error
operator|=
name|_bus_dmamap_load_phys
argument_list|(
name|dmat
argument_list|,
name|map
argument_list|,
name|paddr
argument_list|,
name|len
argument_list|,
name|flags
argument_list|,
name|segs
argument_list|,
name|segp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
break|break;
name|ma_offs
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Load a cam control block.  */
end_comment

begin_function
specifier|static
name|int
name|_bus_dmamap_load_ccb
parameter_list|(
name|bus_dma_tag_t
name|dmat
parameter_list|,
name|bus_dmamap_t
name|map
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|,
name|int
modifier|*
name|nsegs
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|ccb_hdr
modifier|*
name|ccb_h
decl_stmt|;
name|void
modifier|*
name|data_ptr
decl_stmt|;
name|int
name|error
decl_stmt|;
name|uint32_t
name|dxfer_len
decl_stmt|;
name|uint16_t
name|sglist_cnt
decl_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|ccb_h
operator|=
operator|&
name|ccb
operator|->
name|ccb_h
expr_stmt|;
switch|switch
condition|(
name|ccb_h
operator|->
name|func_code
condition|)
block|{
case|case
name|XPT_SCSI_IO
case|:
block|{
name|struct
name|ccb_scsiio
modifier|*
name|csio
decl_stmt|;
name|csio
operator|=
operator|&
name|ccb
operator|->
name|csio
expr_stmt|;
name|data_ptr
operator|=
name|csio
operator|->
name|data_ptr
expr_stmt|;
name|dxfer_len
operator|=
name|csio
operator|->
name|dxfer_len
expr_stmt|;
name|sglist_cnt
operator|=
name|csio
operator|->
name|sglist_cnt
expr_stmt|;
break|break;
block|}
case|case
name|XPT_CONT_TARGET_IO
case|:
block|{
name|struct
name|ccb_scsiio
modifier|*
name|ctio
decl_stmt|;
name|ctio
operator|=
operator|&
name|ccb
operator|->
name|ctio
expr_stmt|;
name|data_ptr
operator|=
name|ctio
operator|->
name|data_ptr
expr_stmt|;
name|dxfer_len
operator|=
name|ctio
operator|->
name|dxfer_len
expr_stmt|;
name|sglist_cnt
operator|=
name|ctio
operator|->
name|sglist_cnt
expr_stmt|;
break|break;
block|}
case|case
name|XPT_ATA_IO
case|:
block|{
name|struct
name|ccb_ataio
modifier|*
name|ataio
decl_stmt|;
name|ataio
operator|=
operator|&
name|ccb
operator|->
name|ataio
expr_stmt|;
name|data_ptr
operator|=
name|ataio
operator|->
name|data_ptr
expr_stmt|;
name|dxfer_len
operator|=
name|ataio
operator|->
name|dxfer_len
expr_stmt|;
name|sglist_cnt
operator|=
literal|0
expr_stmt|;
break|break;
block|}
default|default:
name|panic
argument_list|(
literal|"_bus_dmamap_load_ccb: Unsupported func code %d"
argument_list|,
name|ccb_h
operator|->
name|func_code
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
operator|(
name|ccb_h
operator|->
name|flags
operator|&
name|CAM_DATA_MASK
operator|)
condition|)
block|{
case|case
name|CAM_DATA_VADDR
case|:
name|error
operator|=
name|_bus_dmamap_load_buffer
argument_list|(
name|dmat
argument_list|,
name|map
argument_list|,
name|data_ptr
argument_list|,
name|dxfer_len
argument_list|,
name|kernel_pmap
argument_list|,
name|flags
argument_list|,
name|NULL
argument_list|,
name|nsegs
argument_list|)
expr_stmt|;
break|break;
case|case
name|CAM_DATA_PADDR
case|:
name|error
operator|=
name|_bus_dmamap_load_phys
argument_list|(
name|dmat
argument_list|,
name|map
argument_list|,
operator|(
name|vm_paddr_t
operator|)
operator|(
name|uintptr_t
operator|)
name|data_ptr
argument_list|,
name|dxfer_len
argument_list|,
name|flags
argument_list|,
name|NULL
argument_list|,
name|nsegs
argument_list|)
expr_stmt|;
break|break;
case|case
name|CAM_DATA_SG
case|:
name|error
operator|=
name|_bus_dmamap_load_vlist
argument_list|(
name|dmat
argument_list|,
name|map
argument_list|,
operator|(
name|bus_dma_segment_t
operator|*
operator|)
name|data_ptr
argument_list|,
name|sglist_cnt
argument_list|,
name|kernel_pmap
argument_list|,
name|nsegs
argument_list|,
name|flags
argument_list|,
literal|0
argument_list|,
name|dxfer_len
argument_list|)
expr_stmt|;
break|break;
case|case
name|CAM_DATA_SG_PADDR
case|:
name|error
operator|=
name|_bus_dmamap_load_plist
argument_list|(
name|dmat
argument_list|,
name|map
argument_list|,
operator|(
name|bus_dma_segment_t
operator|*
operator|)
name|data_ptr
argument_list|,
name|sglist_cnt
argument_list|,
name|nsegs
argument_list|,
name|flags
argument_list|)
expr_stmt|;
break|break;
case|case
name|CAM_DATA_BIO
case|:
name|error
operator|=
name|_bus_dmamap_load_bio
argument_list|(
name|dmat
argument_list|,
name|map
argument_list|,
operator|(
expr|struct
name|bio
operator|*
operator|)
name|data_ptr
argument_list|,
name|nsegs
argument_list|,
name|flags
argument_list|)
expr_stmt|;
break|break;
default|default:
name|panic
argument_list|(
literal|"_bus_dmamap_load_ccb: flags 0x%X unimplemented"
argument_list|,
name|ccb_h
operator|->
name|flags
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Load a uio.  */
end_comment

begin_function
specifier|static
name|int
name|_bus_dmamap_load_uio
parameter_list|(
name|bus_dma_tag_t
name|dmat
parameter_list|,
name|bus_dmamap_t
name|map
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|,
name|int
modifier|*
name|nsegs
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|bus_size_t
name|resid
decl_stmt|;
name|bus_size_t
name|minlen
decl_stmt|;
name|struct
name|iovec
modifier|*
name|iov
decl_stmt|;
name|pmap_t
name|pmap
decl_stmt|;
name|caddr_t
name|addr
decl_stmt|;
name|int
name|error
decl_stmt|,
name|i
decl_stmt|;
if|if
condition|(
name|uio
operator|->
name|uio_segflg
operator|==
name|UIO_USERSPACE
condition|)
block|{
name|KASSERT
argument_list|(
name|uio
operator|->
name|uio_td
operator|!=
name|NULL
argument_list|,
operator|(
literal|"bus_dmamap_load_uio: USERSPACE but no proc"
operator|)
argument_list|)
expr_stmt|;
name|pmap
operator|=
name|vmspace_pmap
argument_list|(
name|uio
operator|->
name|uio_td
operator|->
name|td_proc
operator|->
name|p_vmspace
argument_list|)
expr_stmt|;
block|}
else|else
name|pmap
operator|=
name|kernel_pmap
expr_stmt|;
name|resid
operator|=
name|uio
operator|->
name|uio_resid
expr_stmt|;
name|iov
operator|=
name|uio
operator|->
name|uio_iov
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|uio
operator|->
name|uio_iovcnt
operator|&&
name|resid
operator|!=
literal|0
operator|&&
operator|!
name|error
condition|;
name|i
operator|++
control|)
block|{
comment|/* 		 * Now at the first iovec to load.  Load each iovec 		 * until we have exhausted the residual count. 		 */
name|addr
operator|=
operator|(
name|caddr_t
operator|)
name|iov
index|[
name|i
index|]
operator|.
name|iov_base
expr_stmt|;
name|minlen
operator|=
name|resid
operator|<
name|iov
index|[
name|i
index|]
operator|.
name|iov_len
condition|?
name|resid
else|:
name|iov
index|[
name|i
index|]
operator|.
name|iov_len
expr_stmt|;
if|if
condition|(
name|minlen
operator|>
literal|0
condition|)
block|{
name|error
operator|=
name|_bus_dmamap_load_buffer
argument_list|(
name|dmat
argument_list|,
name|map
argument_list|,
name|addr
argument_list|,
name|minlen
argument_list|,
name|pmap
argument_list|,
name|flags
argument_list|,
name|NULL
argument_list|,
name|nsegs
argument_list|)
expr_stmt|;
name|resid
operator|-=
name|minlen
expr_stmt|;
block|}
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Map the buffer buf into bus space using the dmamap map.  */
end_comment

begin_function
name|int
name|bus_dmamap_load
parameter_list|(
name|bus_dma_tag_t
name|dmat
parameter_list|,
name|bus_dmamap_t
name|map
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|,
name|bus_size_t
name|buflen
parameter_list|,
name|bus_dmamap_callback_t
modifier|*
name|callback
parameter_list|,
name|void
modifier|*
name|callback_arg
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|bus_dma_segment_t
modifier|*
name|segs
decl_stmt|;
name|struct
name|memdesc
name|mem
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|nsegs
decl_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|BUS_DMA_NOWAIT
operator|)
operator|==
literal|0
condition|)
block|{
name|mem
operator|=
name|memdesc_vaddr
argument_list|(
name|buf
argument_list|,
name|buflen
argument_list|)
expr_stmt|;
name|_bus_dmamap_waitok
argument_list|(
name|dmat
argument_list|,
name|map
argument_list|,
operator|&
name|mem
argument_list|,
name|callback
argument_list|,
name|callback_arg
argument_list|)
expr_stmt|;
block|}
name|nsegs
operator|=
operator|-
literal|1
expr_stmt|;
name|error
operator|=
name|_bus_dmamap_load_buffer
argument_list|(
name|dmat
argument_list|,
name|map
argument_list|,
name|buf
argument_list|,
name|buflen
argument_list|,
name|kernel_pmap
argument_list|,
name|flags
argument_list|,
name|NULL
argument_list|,
operator|&
name|nsegs
argument_list|)
expr_stmt|;
name|nsegs
operator|++
expr_stmt|;
name|CTR5
argument_list|(
name|KTR_BUSDMA
argument_list|,
literal|"%s: tag %p tag flags 0x%x error %d nsegs %d"
argument_list|,
name|__func__
argument_list|,
name|dmat
argument_list|,
name|flags
argument_list|,
name|error
argument_list|,
name|nsegs
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|EINPROGRESS
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|segs
operator|=
name|_bus_dmamap_complete
argument_list|(
name|dmat
argument_list|,
name|map
argument_list|,
name|NULL
argument_list|,
name|nsegs
argument_list|,
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
call|(
modifier|*
name|callback
call|)
argument_list|(
name|callback_arg
argument_list|,
name|segs
argument_list|,
literal|0
argument_list|,
name|error
argument_list|)
expr_stmt|;
else|else
call|(
modifier|*
name|callback
call|)
argument_list|(
name|callback_arg
argument_list|,
name|segs
argument_list|,
name|nsegs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Return ENOMEM to the caller so that it can pass it up the stack. 	 * This error only happens when NOWAIT is set, so deferral is disabled. 	 */
if|if
condition|(
name|error
operator|==
name|ENOMEM
condition|)
return|return
operator|(
name|error
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|bus_dmamap_load_mbuf
parameter_list|(
name|bus_dma_tag_t
name|dmat
parameter_list|,
name|bus_dmamap_t
name|map
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m0
parameter_list|,
name|bus_dmamap_callback2_t
modifier|*
name|callback
parameter_list|,
name|void
modifier|*
name|callback_arg
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|bus_dma_segment_t
modifier|*
name|segs
decl_stmt|;
name|int
name|nsegs
decl_stmt|,
name|error
decl_stmt|;
name|M_ASSERTPKTHDR
argument_list|(
name|m0
argument_list|)
expr_stmt|;
name|flags
operator||=
name|BUS_DMA_NOWAIT
expr_stmt|;
name|nsegs
operator|=
operator|-
literal|1
expr_stmt|;
name|error
operator|=
name|_bus_dmamap_load_mbuf_sg
argument_list|(
name|dmat
argument_list|,
name|map
argument_list|,
name|m0
argument_list|,
name|NULL
argument_list|,
operator|&
name|nsegs
argument_list|,
name|flags
argument_list|)
expr_stmt|;
operator|++
name|nsegs
expr_stmt|;
name|segs
operator|=
name|_bus_dmamap_complete
argument_list|(
name|dmat
argument_list|,
name|map
argument_list|,
name|NULL
argument_list|,
name|nsegs
argument_list|,
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
call|(
modifier|*
name|callback
call|)
argument_list|(
name|callback_arg
argument_list|,
name|segs
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|error
argument_list|)
expr_stmt|;
else|else
call|(
modifier|*
name|callback
call|)
argument_list|(
name|callback_arg
argument_list|,
name|segs
argument_list|,
name|nsegs
argument_list|,
name|m0
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|CTR5
argument_list|(
name|KTR_BUSDMA
argument_list|,
literal|"%s: tag %p tag flags 0x%x error %d nsegs %d"
argument_list|,
name|__func__
argument_list|,
name|dmat
argument_list|,
name|flags
argument_list|,
name|error
argument_list|,
name|nsegs
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|bus_dmamap_load_mbuf_sg
parameter_list|(
name|bus_dma_tag_t
name|dmat
parameter_list|,
name|bus_dmamap_t
name|map
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m0
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
modifier|*
name|nsegs
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|flags
operator||=
name|BUS_DMA_NOWAIT
expr_stmt|;
operator|*
name|nsegs
operator|=
operator|-
literal|1
expr_stmt|;
name|error
operator|=
name|_bus_dmamap_load_mbuf_sg
argument_list|(
name|dmat
argument_list|,
name|map
argument_list|,
name|m0
argument_list|,
name|segs
argument_list|,
name|nsegs
argument_list|,
name|flags
argument_list|)
expr_stmt|;
operator|++
operator|*
name|nsegs
expr_stmt|;
name|_bus_dmamap_complete
argument_list|(
name|dmat
argument_list|,
name|map
argument_list|,
name|segs
argument_list|,
operator|*
name|nsegs
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|bus_dmamap_load_uio
parameter_list|(
name|bus_dma_tag_t
name|dmat
parameter_list|,
name|bus_dmamap_t
name|map
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|,
name|bus_dmamap_callback2_t
modifier|*
name|callback
parameter_list|,
name|void
modifier|*
name|callback_arg
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|bus_dma_segment_t
modifier|*
name|segs
decl_stmt|;
name|int
name|nsegs
decl_stmt|,
name|error
decl_stmt|;
name|flags
operator||=
name|BUS_DMA_NOWAIT
expr_stmt|;
name|nsegs
operator|=
operator|-
literal|1
expr_stmt|;
name|error
operator|=
name|_bus_dmamap_load_uio
argument_list|(
name|dmat
argument_list|,
name|map
argument_list|,
name|uio
argument_list|,
operator|&
name|nsegs
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|nsegs
operator|++
expr_stmt|;
name|segs
operator|=
name|_bus_dmamap_complete
argument_list|(
name|dmat
argument_list|,
name|map
argument_list|,
name|NULL
argument_list|,
name|nsegs
argument_list|,
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
call|(
modifier|*
name|callback
call|)
argument_list|(
name|callback_arg
argument_list|,
name|segs
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|error
argument_list|)
expr_stmt|;
else|else
call|(
modifier|*
name|callback
call|)
argument_list|(
name|callback_arg
argument_list|,
name|segs
argument_list|,
name|nsegs
argument_list|,
name|uio
operator|->
name|uio_resid
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|CTR5
argument_list|(
name|KTR_BUSDMA
argument_list|,
literal|"%s: tag %p tag flags 0x%x error %d nsegs %d"
argument_list|,
name|__func__
argument_list|,
name|dmat
argument_list|,
name|flags
argument_list|,
name|error
argument_list|,
name|nsegs
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|bus_dmamap_load_ccb
parameter_list|(
name|bus_dma_tag_t
name|dmat
parameter_list|,
name|bus_dmamap_t
name|map
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|,
name|bus_dmamap_callback_t
modifier|*
name|callback
parameter_list|,
name|void
modifier|*
name|callback_arg
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|bus_dma_segment_t
modifier|*
name|segs
decl_stmt|;
name|struct
name|ccb_hdr
modifier|*
name|ccb_h
decl_stmt|;
name|struct
name|memdesc
name|mem
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|nsegs
decl_stmt|;
name|ccb_h
operator|=
operator|&
name|ccb
operator|->
name|ccb_h
expr_stmt|;
if|if
condition|(
operator|(
name|ccb_h
operator|->
name|flags
operator|&
name|CAM_DIR_MASK
operator|)
operator|==
name|CAM_DIR_NONE
condition|)
block|{
name|callback
argument_list|(
name|callback_arg
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|flags
operator|&
name|BUS_DMA_NOWAIT
operator|)
operator|==
literal|0
condition|)
block|{
name|mem
operator|=
name|memdesc_ccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
name|_bus_dmamap_waitok
argument_list|(
name|dmat
argument_list|,
name|map
argument_list|,
operator|&
name|mem
argument_list|,
name|callback
argument_list|,
name|callback_arg
argument_list|)
expr_stmt|;
block|}
name|nsegs
operator|=
operator|-
literal|1
expr_stmt|;
name|error
operator|=
name|_bus_dmamap_load_ccb
argument_list|(
name|dmat
argument_list|,
name|map
argument_list|,
name|ccb
argument_list|,
operator|&
name|nsegs
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|nsegs
operator|++
expr_stmt|;
name|CTR5
argument_list|(
name|KTR_BUSDMA
argument_list|,
literal|"%s: tag %p tag flags 0x%x error %d nsegs %d"
argument_list|,
name|__func__
argument_list|,
name|dmat
argument_list|,
name|flags
argument_list|,
name|error
argument_list|,
name|nsegs
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|EINPROGRESS
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|segs
operator|=
name|_bus_dmamap_complete
argument_list|(
name|dmat
argument_list|,
name|map
argument_list|,
name|NULL
argument_list|,
name|nsegs
argument_list|,
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
call|(
modifier|*
name|callback
call|)
argument_list|(
name|callback_arg
argument_list|,
name|segs
argument_list|,
literal|0
argument_list|,
name|error
argument_list|)
expr_stmt|;
else|else
call|(
modifier|*
name|callback
call|)
argument_list|(
name|callback_arg
argument_list|,
name|segs
argument_list|,
name|nsegs
argument_list|,
name|error
argument_list|)
expr_stmt|;
comment|/* 	 * Return ENOMEM to the caller so that it can pass it up the stack. 	 * This error only happens when NOWAIT is set, so deferral is disabled. 	 */
if|if
condition|(
name|error
operator|==
name|ENOMEM
condition|)
return|return
operator|(
name|error
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|bus_dmamap_load_bio
parameter_list|(
name|bus_dma_tag_t
name|dmat
parameter_list|,
name|bus_dmamap_t
name|map
parameter_list|,
name|struct
name|bio
modifier|*
name|bio
parameter_list|,
name|bus_dmamap_callback_t
modifier|*
name|callback
parameter_list|,
name|void
modifier|*
name|callback_arg
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|bus_dma_segment_t
modifier|*
name|segs
decl_stmt|;
name|struct
name|memdesc
name|mem
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|nsegs
decl_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|BUS_DMA_NOWAIT
operator|)
operator|==
literal|0
condition|)
block|{
name|mem
operator|=
name|memdesc_bio
argument_list|(
name|bio
argument_list|)
expr_stmt|;
name|_bus_dmamap_waitok
argument_list|(
name|dmat
argument_list|,
name|map
argument_list|,
operator|&
name|mem
argument_list|,
name|callback
argument_list|,
name|callback_arg
argument_list|)
expr_stmt|;
block|}
name|nsegs
operator|=
operator|-
literal|1
expr_stmt|;
name|error
operator|=
name|_bus_dmamap_load_bio
argument_list|(
name|dmat
argument_list|,
name|map
argument_list|,
name|bio
argument_list|,
operator|&
name|nsegs
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|nsegs
operator|++
expr_stmt|;
name|CTR5
argument_list|(
name|KTR_BUSDMA
argument_list|,
literal|"%s: tag %p tag flags 0x%x error %d nsegs %d"
argument_list|,
name|__func__
argument_list|,
name|dmat
argument_list|,
name|flags
argument_list|,
name|error
argument_list|,
name|nsegs
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|EINPROGRESS
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|segs
operator|=
name|_bus_dmamap_complete
argument_list|(
name|dmat
argument_list|,
name|map
argument_list|,
name|NULL
argument_list|,
name|nsegs
argument_list|,
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
call|(
modifier|*
name|callback
call|)
argument_list|(
name|callback_arg
argument_list|,
name|segs
argument_list|,
literal|0
argument_list|,
name|error
argument_list|)
expr_stmt|;
else|else
call|(
modifier|*
name|callback
call|)
argument_list|(
name|callback_arg
argument_list|,
name|segs
argument_list|,
name|nsegs
argument_list|,
name|error
argument_list|)
expr_stmt|;
comment|/* 	 * Return ENOMEM to the caller so that it can pass it up the stack. 	 * This error only happens when NOWAIT is set, so deferral is disabled. 	 */
if|if
condition|(
name|error
operator|==
name|ENOMEM
condition|)
return|return
operator|(
name|error
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|bus_dmamap_load_mem
parameter_list|(
name|bus_dma_tag_t
name|dmat
parameter_list|,
name|bus_dmamap_t
name|map
parameter_list|,
name|struct
name|memdesc
modifier|*
name|mem
parameter_list|,
name|bus_dmamap_callback_t
modifier|*
name|callback
parameter_list|,
name|void
modifier|*
name|callback_arg
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|bus_dma_segment_t
modifier|*
name|segs
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|nsegs
decl_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|BUS_DMA_NOWAIT
operator|)
operator|==
literal|0
condition|)
name|_bus_dmamap_waitok
argument_list|(
name|dmat
argument_list|,
name|map
argument_list|,
name|mem
argument_list|,
name|callback
argument_list|,
name|callback_arg
argument_list|)
expr_stmt|;
name|nsegs
operator|=
operator|-
literal|1
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|mem
operator|->
name|md_type
condition|)
block|{
case|case
name|MEMDESC_VADDR
case|:
name|error
operator|=
name|_bus_dmamap_load_buffer
argument_list|(
name|dmat
argument_list|,
name|map
argument_list|,
name|mem
operator|->
name|u
operator|.
name|md_vaddr
argument_list|,
name|mem
operator|->
name|md_opaque
argument_list|,
name|kernel_pmap
argument_list|,
name|flags
argument_list|,
name|NULL
argument_list|,
operator|&
name|nsegs
argument_list|)
expr_stmt|;
break|break;
case|case
name|MEMDESC_PADDR
case|:
name|error
operator|=
name|_bus_dmamap_load_phys
argument_list|(
name|dmat
argument_list|,
name|map
argument_list|,
name|mem
operator|->
name|u
operator|.
name|md_paddr
argument_list|,
name|mem
operator|->
name|md_opaque
argument_list|,
name|flags
argument_list|,
name|NULL
argument_list|,
operator|&
name|nsegs
argument_list|)
expr_stmt|;
break|break;
case|case
name|MEMDESC_VLIST
case|:
name|error
operator|=
name|_bus_dmamap_load_vlist
argument_list|(
name|dmat
argument_list|,
name|map
argument_list|,
name|mem
operator|->
name|u
operator|.
name|md_list
argument_list|,
name|mem
operator|->
name|md_opaque
argument_list|,
name|kernel_pmap
argument_list|,
operator|&
name|nsegs
argument_list|,
name|flags
argument_list|,
literal|0
argument_list|,
name|SIZE_T_MAX
argument_list|)
expr_stmt|;
break|break;
case|case
name|MEMDESC_PLIST
case|:
name|error
operator|=
name|_bus_dmamap_load_plist
argument_list|(
name|dmat
argument_list|,
name|map
argument_list|,
name|mem
operator|->
name|u
operator|.
name|md_list
argument_list|,
name|mem
operator|->
name|md_opaque
argument_list|,
operator|&
name|nsegs
argument_list|,
name|flags
argument_list|)
expr_stmt|;
break|break;
case|case
name|MEMDESC_BIO
case|:
name|error
operator|=
name|_bus_dmamap_load_bio
argument_list|(
name|dmat
argument_list|,
name|map
argument_list|,
name|mem
operator|->
name|u
operator|.
name|md_bio
argument_list|,
operator|&
name|nsegs
argument_list|,
name|flags
argument_list|)
expr_stmt|;
break|break;
case|case
name|MEMDESC_UIO
case|:
name|error
operator|=
name|_bus_dmamap_load_uio
argument_list|(
name|dmat
argument_list|,
name|map
argument_list|,
name|mem
operator|->
name|u
operator|.
name|md_uio
argument_list|,
operator|&
name|nsegs
argument_list|,
name|flags
argument_list|)
expr_stmt|;
break|break;
case|case
name|MEMDESC_MBUF
case|:
name|error
operator|=
name|_bus_dmamap_load_mbuf_sg
argument_list|(
name|dmat
argument_list|,
name|map
argument_list|,
name|mem
operator|->
name|u
operator|.
name|md_mbuf
argument_list|,
name|NULL
argument_list|,
operator|&
name|nsegs
argument_list|,
name|flags
argument_list|)
expr_stmt|;
break|break;
case|case
name|MEMDESC_CCB
case|:
name|error
operator|=
name|_bus_dmamap_load_ccb
argument_list|(
name|dmat
argument_list|,
name|map
argument_list|,
name|mem
operator|->
name|u
operator|.
name|md_ccb
argument_list|,
operator|&
name|nsegs
argument_list|,
name|flags
argument_list|)
expr_stmt|;
break|break;
block|}
name|nsegs
operator|++
expr_stmt|;
name|CTR5
argument_list|(
name|KTR_BUSDMA
argument_list|,
literal|"%s: tag %p tag flags 0x%x error %d nsegs %d"
argument_list|,
name|__func__
argument_list|,
name|dmat
argument_list|,
name|flags
argument_list|,
name|error
argument_list|,
name|nsegs
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|EINPROGRESS
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|segs
operator|=
name|_bus_dmamap_complete
argument_list|(
name|dmat
argument_list|,
name|map
argument_list|,
name|NULL
argument_list|,
name|nsegs
argument_list|,
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
call|(
modifier|*
name|callback
call|)
argument_list|(
name|callback_arg
argument_list|,
name|segs
argument_list|,
literal|0
argument_list|,
name|error
argument_list|)
expr_stmt|;
else|else
call|(
modifier|*
name|callback
call|)
argument_list|(
name|callback_arg
argument_list|,
name|segs
argument_list|,
name|nsegs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Return ENOMEM to the caller so that it can pass it up the stack. 	 * This error only happens when NOWAIT is set, so deferral is disabled. 	 */
if|if
condition|(
name|error
operator|==
name|ENOMEM
condition|)
return|return
operator|(
name|error
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

end_unit

