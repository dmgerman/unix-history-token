begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2008 Ed Schouten<ed@FreeBSD.org>  * All rights reserved.  *  * Portions of this software were developed under sponsorship from Snow  * B.V., the Netherlands.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/filio.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/signal.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/tty.h>
end_include

begin_include
include|#
directive|include
file|<sys/ttycom.h>
end_include

begin_include
include|#
directive|include
file|<sys/ttydefaults.h>
end_include

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_include
include|#
directive|include
file|<sys/vnode.h>
end_include

begin_comment
comment|/*  * Standard TTYDISC `termios' line discipline.  */
end_comment

begin_comment
comment|/* Statistics. */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|long
name|tty_nin
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_ULONG
argument_list|(
name|_kern
argument_list|,
name|OID_AUTO
argument_list|,
name|tty_nin
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|tty_nin
argument_list|,
literal|0
argument_list|,
literal|"Total amount of bytes received"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|long
name|tty_nout
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_ULONG
argument_list|(
name|_kern
argument_list|,
name|OID_AUTO
argument_list|,
name|tty_nout
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|tty_nout
argument_list|,
literal|0
argument_list|,
literal|"Total amount of bytes transmitted"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* termios comparison macro's. */
end_comment

begin_define
define|#
directive|define
name|CMP_CC
parameter_list|(
name|v
parameter_list|,
name|c
parameter_list|)
value|(tp->t_termios.c_cc[v] != _POSIX_VDISABLE&& \ 			tp->t_termios.c_cc[v] == (c))
end_define

begin_define
define|#
directive|define
name|CMP_FLAG
parameter_list|(
name|field
parameter_list|,
name|opt
parameter_list|)
value|(tp->t_termios.c_ ## field ## flag& (opt))
end_define

begin_comment
comment|/* Characters that cannot be modified through c_cc. */
end_comment

begin_define
define|#
directive|define
name|CTAB
value|'\t'
end_define

begin_define
define|#
directive|define
name|CNL
value|'\n'
end_define

begin_define
define|#
directive|define
name|CCR
value|'\r'
end_define

begin_comment
comment|/* Character is a control character. */
end_comment

begin_define
define|#
directive|define
name|CTL_VALID
parameter_list|(
name|c
parameter_list|)
value|((c) == 0x7f || (unsigned char)(c)< 0x20)
end_define

begin_comment
comment|/* Control character should be processed on echo. */
end_comment

begin_define
define|#
directive|define
name|CTL_ECHO
parameter_list|(
name|c
parameter_list|,
name|q
parameter_list|)
value|(!(q)&& ((c) == CERASE2 || (c) == CTAB || \     (c) == CNL || (c) == CCR))
end_define

begin_comment
comment|/* Control character should be printed using ^X notation. */
end_comment

begin_define
define|#
directive|define
name|CTL_PRINT
parameter_list|(
name|c
parameter_list|,
name|q
parameter_list|)
value|((c) == 0x7f || ((unsigned char)(c)< 0x20&& \     ((q) || ((c) != CTAB&& (c) != CNL))))
end_define

begin_comment
comment|/* Character is whitespace. */
end_comment

begin_define
define|#
directive|define
name|CTL_WHITE
parameter_list|(
name|c
parameter_list|)
value|((c) == ' ' || (c) == CTAB)
end_define

begin_comment
comment|/* Character is alphanumeric. */
end_comment

begin_define
define|#
directive|define
name|CTL_ALNUM
parameter_list|(
name|c
parameter_list|)
value|(((c)>= '0'&& (c)<= '9') || \     ((c)>= 'a'&& (c)<= 'z') || ((c)>= 'A'&& (c)<= 'Z'))
end_define

begin_define
define|#
directive|define
name|TTY_STACKBUF
value|256
end_define

begin_function
name|void
name|ttydisc_open
parameter_list|(
name|struct
name|tty
modifier|*
name|tp
parameter_list|)
block|{
name|ttydisc_optimize
argument_list|(
name|tp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ttydisc_close
parameter_list|(
name|struct
name|tty
modifier|*
name|tp
parameter_list|)
block|{
comment|/* Clean up our flags when leaving the discipline. */
name|tp
operator|->
name|t_flags
operator|&=
operator|~
operator|(
name|TF_STOPPED
operator||
name|TF_HIWAT
operator||
name|TF_ZOMBIE
operator|)
expr_stmt|;
comment|/* POSIX states we should flush when close() is called. */
name|ttyinq_flush
argument_list|(
operator|&
name|tp
operator|->
name|t_inq
argument_list|)
expr_stmt|;
name|ttyoutq_flush
argument_list|(
operator|&
name|tp
operator|->
name|t_outq
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tty_gone
argument_list|(
name|tp
argument_list|)
condition|)
block|{
name|ttydevsw_inwakeup
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|ttydevsw_outwakeup
argument_list|(
name|tp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ttyhook_hashook
argument_list|(
name|tp
argument_list|,
name|close
argument_list|)
condition|)
name|ttyhook_close
argument_list|(
name|tp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|ttydisc_read_canonical
parameter_list|(
name|struct
name|tty
modifier|*
name|tp
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|,
name|int
name|ioflag
parameter_list|)
block|{
name|char
name|breakc
index|[
literal|4
index|]
init|=
block|{
name|CNL
block|}
decl_stmt|;
comment|/* enough to hold \n, VEOF and VEOL. */
name|int
name|error
decl_stmt|;
name|size_t
name|clen
decl_stmt|,
name|flen
init|=
literal|0
decl_stmt|,
name|n
init|=
literal|1
decl_stmt|;
name|unsigned
name|char
name|lastc
init|=
name|_POSIX_VDISABLE
decl_stmt|;
define|#
directive|define
name|BREAK_ADD
parameter_list|(
name|c
parameter_list|)
value|do { \ 	if (tp->t_termios.c_cc[c] != _POSIX_VDISABLE)	\ 		breakc[n++] = tp->t_termios.c_cc[c];	\ } while (0)
comment|/* Determine which characters we should trigger on. */
name|BREAK_ADD
argument_list|(
name|VEOF
argument_list|)
expr_stmt|;
name|BREAK_ADD
argument_list|(
name|VEOL
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|BREAK_ADD
name|breakc
index|[
name|n
index|]
operator|=
literal|'\0'
expr_stmt|;
do|do
block|{
comment|/* 		 * Quite a tricky case: unlike the old TTY 		 * implementation, this implementation copies data back 		 * to userspace in large chunks. Unfortunately, we can't 		 * calculate the line length on beforehand if it crosses 		 * ttyinq_block boundaries, because multiple reads could 		 * then make this code read beyond the newline. 		 * 		 * This is why we limit the read to: 		 * - The size the user has requested 		 * - The blocksize (done in tty_inq.c) 		 * - The amount of bytes until the newline 		 * 		 * This causes the line length to be recalculated after 		 * each block has been copied to userspace. This will 		 * cause the TTY layer to return data in chunks using 		 * the blocksize (except the first and last blocks). 		 */
name|clen
operator|=
name|ttyinq_findchar
argument_list|(
operator|&
name|tp
operator|->
name|t_inq
argument_list|,
name|breakc
argument_list|,
name|uio
operator|->
name|uio_resid
argument_list|,
operator|&
name|lastc
argument_list|)
expr_stmt|;
comment|/* No more data. */
if|if
condition|(
name|clen
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|ioflag
operator|&
name|IO_NDELAY
condition|)
return|return
operator|(
name|EWOULDBLOCK
operator|)
return|;
elseif|else
if|if
condition|(
name|tp
operator|->
name|t_flags
operator|&
name|TF_ZOMBIE
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|error
operator|=
name|tty_wait
argument_list|(
name|tp
argument_list|,
operator|&
name|tp
operator|->
name|t_inwait
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
continue|continue;
block|}
comment|/* Don't send the EOF char back to userspace. */
if|if
condition|(
name|CMP_CC
argument_list|(
name|VEOF
argument_list|,
name|lastc
argument_list|)
condition|)
name|flen
operator|=
literal|1
expr_stmt|;
name|MPASS
argument_list|(
name|flen
operator|<=
name|clen
argument_list|)
expr_stmt|;
comment|/* Read and throw away the EOF character. */
name|error
operator|=
name|ttyinq_read_uio
argument_list|(
operator|&
name|tp
operator|->
name|t_inq
argument_list|,
name|tp
argument_list|,
name|uio
argument_list|,
name|clen
argument_list|,
name|flen
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
do|while
condition|(
name|uio
operator|->
name|uio_resid
operator|>
literal|0
operator|&&
name|lastc
operator|==
name|_POSIX_VDISABLE
condition|)
do|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ttydisc_read_raw_no_timer
parameter_list|(
name|struct
name|tty
modifier|*
name|tp
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|,
name|int
name|ioflag
parameter_list|)
block|{
name|size_t
name|vmin
init|=
name|tp
operator|->
name|t_termios
operator|.
name|c_cc
index|[
name|VMIN
index|]
decl_stmt|;
name|int
name|oresid
init|=
name|uio
operator|->
name|uio_resid
decl_stmt|;
name|int
name|error
decl_stmt|;
name|MPASS
argument_list|(
name|tp
operator|->
name|t_termios
operator|.
name|c_cc
index|[
name|VTIME
index|]
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * This routine implements the easy cases of read()s while in 	 * non-canonical mode, namely case B and D, where we don't have 	 * any timers at all. 	 */
for|for
control|(
init|;
condition|;
control|)
block|{
name|error
operator|=
name|ttyinq_read_uio
argument_list|(
operator|&
name|tp
operator|->
name|t_inq
argument_list|,
name|tp
argument_list|,
name|uio
argument_list|,
name|uio
operator|->
name|uio_resid
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|uio
operator|->
name|uio_resid
operator|==
literal|0
operator|||
operator|(
name|oresid
operator|-
name|uio
operator|->
name|uio_resid
operator|)
operator|>=
name|vmin
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* We have to wait for more. */
if|if
condition|(
name|ioflag
operator|&
name|IO_NDELAY
condition|)
return|return
operator|(
name|EWOULDBLOCK
operator|)
return|;
elseif|else
if|if
condition|(
name|tp
operator|->
name|t_flags
operator|&
name|TF_ZOMBIE
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|error
operator|=
name|tty_wait
argument_list|(
name|tp
argument_list|,
operator|&
name|tp
operator|->
name|t_inwait
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|ttydisc_read_raw_read_timer
parameter_list|(
name|struct
name|tty
modifier|*
name|tp
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|,
name|int
name|ioflag
parameter_list|,
name|int
name|oresid
parameter_list|)
block|{
name|size_t
name|vmin
init|=
name|MAX
argument_list|(
name|tp
operator|->
name|t_termios
operator|.
name|c_cc
index|[
name|VMIN
index|]
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|vtime
init|=
name|tp
operator|->
name|t_termios
operator|.
name|c_cc
index|[
name|VTIME
index|]
decl_stmt|;
name|struct
name|timeval
name|end
decl_stmt|,
name|now
decl_stmt|,
name|left
decl_stmt|;
name|int
name|error
decl_stmt|,
name|hz
decl_stmt|;
name|MPASS
argument_list|(
name|tp
operator|->
name|t_termios
operator|.
name|c_cc
index|[
name|VTIME
index|]
operator|!=
literal|0
argument_list|)
expr_stmt|;
comment|/* Determine when the read should be expired. */
name|end
operator|.
name|tv_sec
operator|=
name|vtime
operator|/
literal|10
expr_stmt|;
name|end
operator|.
name|tv_usec
operator|=
operator|(
name|vtime
operator|%
literal|10
operator|)
operator|*
literal|100000
expr_stmt|;
name|getmicrotime
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
name|timevaladd
argument_list|(
operator|&
name|end
argument_list|,
operator|&
name|now
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|error
operator|=
name|ttyinq_read_uio
argument_list|(
operator|&
name|tp
operator|->
name|t_inq
argument_list|,
name|tp
argument_list|,
name|uio
argument_list|,
name|uio
operator|->
name|uio_resid
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|uio
operator|->
name|uio_resid
operator|==
literal|0
operator|||
operator|(
name|oresid
operator|-
name|uio
operator|->
name|uio_resid
operator|)
operator|>=
name|vmin
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Calculate how long we should wait. */
name|getmicrotime
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
if|if
condition|(
name|timevalcmp
argument_list|(
operator|&
name|now
argument_list|,
operator|&
name|end
argument_list|,
operator|>
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|left
operator|=
name|end
expr_stmt|;
name|timevalsub
argument_list|(
operator|&
name|left
argument_list|,
operator|&
name|now
argument_list|)
expr_stmt|;
name|hz
operator|=
name|tvtohz
argument_list|(
operator|&
name|left
argument_list|)
expr_stmt|;
comment|/* 		 * We have to wait for more. If the timer expires, we 		 * should return a 0-byte read. 		 */
if|if
condition|(
name|ioflag
operator|&
name|IO_NDELAY
condition|)
return|return
operator|(
name|EWOULDBLOCK
operator|)
return|;
elseif|else
if|if
condition|(
name|tp
operator|->
name|t_flags
operator|&
name|TF_ZOMBIE
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|error
operator|=
name|tty_timedwait
argument_list|(
name|tp
argument_list|,
operator|&
name|tp
operator|->
name|t_inwait
argument_list|,
name|hz
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|==
name|EWOULDBLOCK
condition|?
literal|0
else|:
name|error
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ttydisc_read_raw_interbyte_timer
parameter_list|(
name|struct
name|tty
modifier|*
name|tp
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|,
name|int
name|ioflag
parameter_list|)
block|{
name|size_t
name|vmin
init|=
name|tp
operator|->
name|t_termios
operator|.
name|c_cc
index|[
name|VMIN
index|]
decl_stmt|;
name|int
name|oresid
init|=
name|uio
operator|->
name|uio_resid
decl_stmt|;
name|int
name|error
decl_stmt|;
name|MPASS
argument_list|(
name|tp
operator|->
name|t_termios
operator|.
name|c_cc
index|[
name|VMIN
index|]
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|tp
operator|->
name|t_termios
operator|.
name|c_cc
index|[
name|VTIME
index|]
operator|!=
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * When using the interbyte timer, the timer should be started 	 * after the first byte has been received. We just call into the 	 * generic read timer code after we've received the first byte. 	 */
for|for
control|(
init|;
condition|;
control|)
block|{
name|error
operator|=
name|ttyinq_read_uio
argument_list|(
operator|&
name|tp
operator|->
name|t_inq
argument_list|,
name|tp
argument_list|,
name|uio
argument_list|,
name|uio
operator|->
name|uio_resid
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|uio
operator|->
name|uio_resid
operator|==
literal|0
operator|||
operator|(
name|oresid
operator|-
name|uio
operator|->
name|uio_resid
operator|)
operator|>=
name|vmin
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 		 * Not enough data, but we did receive some, which means 		 * we'll now start using the interbyte timer. 		 */
if|if
condition|(
name|oresid
operator|!=
name|uio
operator|->
name|uio_resid
condition|)
break|break;
comment|/* We have to wait for more. */
if|if
condition|(
name|ioflag
operator|&
name|IO_NDELAY
condition|)
return|return
operator|(
name|EWOULDBLOCK
operator|)
return|;
elseif|else
if|if
condition|(
name|tp
operator|->
name|t_flags
operator|&
name|TF_ZOMBIE
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|error
operator|=
name|tty_wait
argument_list|(
name|tp
argument_list|,
operator|&
name|tp
operator|->
name|t_inwait
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
return|return
name|ttydisc_read_raw_read_timer
argument_list|(
name|tp
argument_list|,
name|uio
argument_list|,
name|ioflag
argument_list|,
name|oresid
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|ttydisc_read
parameter_list|(
name|struct
name|tty
modifier|*
name|tp
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|,
name|int
name|ioflag
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|tty_lock_assert
argument_list|(
name|tp
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
if|if
condition|(
name|uio
operator|->
name|uio_resid
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|CMP_FLAG
argument_list|(
name|l
argument_list|,
name|ICANON
argument_list|)
condition|)
name|error
operator|=
name|ttydisc_read_canonical
argument_list|(
name|tp
argument_list|,
name|uio
argument_list|,
name|ioflag
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|tp
operator|->
name|t_termios
operator|.
name|c_cc
index|[
name|VTIME
index|]
operator|==
literal|0
condition|)
name|error
operator|=
name|ttydisc_read_raw_no_timer
argument_list|(
name|tp
argument_list|,
name|uio
argument_list|,
name|ioflag
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|tp
operator|->
name|t_termios
operator|.
name|c_cc
index|[
name|VMIN
index|]
operator|==
literal|0
condition|)
name|error
operator|=
name|ttydisc_read_raw_read_timer
argument_list|(
name|tp
argument_list|,
name|uio
argument_list|,
name|ioflag
argument_list|,
name|uio
operator|->
name|uio_resid
argument_list|)
expr_stmt|;
else|else
name|error
operator|=
name|ttydisc_read_raw_interbyte_timer
argument_list|(
name|tp
argument_list|,
name|uio
argument_list|,
name|ioflag
argument_list|)
expr_stmt|;
if|if
condition|(
name|ttyinq_bytesleft
argument_list|(
operator|&
name|tp
operator|->
name|t_inq
argument_list|)
operator|>=
name|tp
operator|->
name|t_inlow
operator|||
name|ttyinq_bytescanonicalized
argument_list|(
operator|&
name|tp
operator|->
name|t_inq
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Unset the input watermark when we've got enough space. */
name|tty_hiwat_in_unblock
argument_list|(
name|tp
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|unsigned
name|int
name|ttydisc_findchar
parameter_list|(
specifier|const
name|char
modifier|*
name|obstart
parameter_list|,
name|unsigned
name|int
name|oblen
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|c
init|=
name|obstart
decl_stmt|;
while|while
condition|(
name|oblen
operator|--
condition|)
block|{
if|if
condition|(
name|CTL_VALID
argument_list|(
operator|*
name|c
argument_list|)
condition|)
break|break;
name|c
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|c
operator|-
name|obstart
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ttydisc_write_oproc
parameter_list|(
name|struct
name|tty
modifier|*
name|tp
parameter_list|,
name|char
name|c
parameter_list|)
block|{
name|unsigned
name|int
name|scnt
decl_stmt|,
name|error
decl_stmt|;
name|MPASS
argument_list|(
name|CMP_FLAG
argument_list|(
name|o
argument_list|,
name|OPOST
argument_list|)
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|CTL_VALID
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
define|#
directive|define
name|PRINT_NORMAL
parameter_list|()
value|ttyoutq_write_nofrag(&tp->t_outq,&c, 1)
switch|switch
condition|(
name|c
condition|)
block|{
case|case
name|CEOF
case|:
comment|/* End-of-text dropping. */
if|if
condition|(
name|CMP_FLAG
argument_list|(
name|o
argument_list|,
name|ONOEOT
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
name|PRINT_NORMAL
argument_list|()
return|;
case|case
name|CERASE2
case|:
comment|/* Handle backspace to fix tab expansion. */
if|if
condition|(
name|PRINT_NORMAL
argument_list|()
operator|!=
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|tp
operator|->
name|t_column
operator|>
literal|0
condition|)
name|tp
operator|->
name|t_column
operator|--
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|CTAB
case|:
comment|/* Tab expansion. */
name|scnt
operator|=
literal|8
operator|-
operator|(
name|tp
operator|->
name|t_column
operator|&
literal|7
operator|)
expr_stmt|;
if|if
condition|(
name|CMP_FLAG
argument_list|(
name|o
argument_list|,
name|TAB3
argument_list|)
condition|)
block|{
name|error
operator|=
name|ttyoutq_write_nofrag
argument_list|(
operator|&
name|tp
operator|->
name|t_outq
argument_list|,
literal|"        "
argument_list|,
name|scnt
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|PRINT_NORMAL
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|error
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|tp
operator|->
name|t_column
operator|+=
name|scnt
expr_stmt|;
name|MPASS
argument_list|(
operator|(
name|tp
operator|->
name|t_column
operator|%
literal|8
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|CNL
case|:
comment|/* Newline conversion. */
if|if
condition|(
name|CMP_FLAG
argument_list|(
name|o
argument_list|,
name|ONLCR
argument_list|)
condition|)
block|{
comment|/* Convert \n to \r\n. */
name|error
operator|=
name|ttyoutq_write_nofrag
argument_list|(
operator|&
name|tp
operator|->
name|t_outq
argument_list|,
literal|"\r\n"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|PRINT_NORMAL
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|error
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|CMP_FLAG
argument_list|(
name|o
argument_list|,
name|ONLCR
operator||
name|ONLRET
argument_list|)
condition|)
block|{
name|tp
operator|->
name|t_column
operator|=
name|tp
operator|->
name|t_writepos
operator|=
literal|0
expr_stmt|;
name|ttyinq_reprintpos_set
argument_list|(
operator|&
name|tp
operator|->
name|t_inq
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|CCR
case|:
comment|/* Carriage return to newline conversion. */
if|if
condition|(
name|CMP_FLAG
argument_list|(
name|o
argument_list|,
name|OCRNL
argument_list|)
condition|)
name|c
operator|=
name|CNL
expr_stmt|;
comment|/* Omit carriage returns on column 0. */
if|if
condition|(
name|CMP_FLAG
argument_list|(
name|o
argument_list|,
name|ONOCR
argument_list|)
operator|&&
name|tp
operator|->
name|t_column
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|PRINT_NORMAL
argument_list|()
operator|!=
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|tp
operator|->
name|t_column
operator|=
name|tp
operator|->
name|t_writepos
operator|=
literal|0
expr_stmt|;
name|ttyinq_reprintpos_set
argument_list|(
operator|&
name|tp
operator|->
name|t_inq
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * Invisible control character. Print it, but don't 	 * increase the column count. 	 */
return|return
name|PRINT_NORMAL
argument_list|()
return|;
undef|#
directive|undef
name|PRINT_NORMAL
block|}
end_function

begin_comment
comment|/*  * Just like the old TTY implementation, we need to copy data in chunks  * into a temporary buffer. One of the reasons why we need to do this,  * is because output processing (only TAB3 though) may allow the buffer  * to grow eight times.  */
end_comment

begin_function
name|int
name|ttydisc_write
parameter_list|(
name|struct
name|tty
modifier|*
name|tp
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|,
name|int
name|ioflag
parameter_list|)
block|{
name|char
name|ob
index|[
name|TTY_STACKBUF
index|]
decl_stmt|;
name|char
modifier|*
name|obstart
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|oblen
init|=
literal|0
decl_stmt|;
name|tty_lock_assert
argument_list|(
name|tp
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_flags
operator|&
name|TF_ZOMBIE
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
comment|/* 	 * We don't need to check whether the process is the foreground 	 * process group or if we have a carrier. This is already done 	 * in ttydev_write(). 	 */
while|while
condition|(
name|uio
operator|->
name|uio_resid
operator|>
literal|0
condition|)
block|{
name|unsigned
name|int
name|nlen
decl_stmt|;
name|MPASS
argument_list|(
name|oblen
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* Step 1: read data. */
name|obstart
operator|=
name|ob
expr_stmt|;
name|nlen
operator|=
name|MIN
argument_list|(
name|uio
operator|->
name|uio_resid
argument_list|,
sizeof|sizeof
name|ob
argument_list|)
expr_stmt|;
name|tty_unlock
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|error
operator|=
name|uiomove
argument_list|(
name|ob
argument_list|,
name|nlen
argument_list|,
name|uio
argument_list|)
expr_stmt|;
name|tty_lock
argument_list|(
name|tp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
break|break;
name|oblen
operator|=
name|nlen
expr_stmt|;
if|if
condition|(
name|tty_gone
argument_list|(
name|tp
argument_list|)
condition|)
block|{
name|error
operator|=
name|ENXIO
expr_stmt|;
break|break;
block|}
name|MPASS
argument_list|(
name|oblen
operator|>
literal|0
argument_list|)
expr_stmt|;
comment|/* Step 2: process data. */
do|do
block|{
name|unsigned
name|int
name|plen
decl_stmt|,
name|wlen
decl_stmt|;
comment|/* Search for special characters for post processing. */
if|if
condition|(
name|CMP_FLAG
argument_list|(
name|o
argument_list|,
name|OPOST
argument_list|)
condition|)
block|{
name|plen
operator|=
name|ttydisc_findchar
argument_list|(
name|obstart
argument_list|,
name|oblen
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|plen
operator|=
name|oblen
expr_stmt|;
block|}
if|if
condition|(
name|plen
operator|==
literal|0
condition|)
block|{
comment|/* 				 * We're going to process a character 				 * that needs processing 				 */
if|if
condition|(
name|ttydisc_write_oproc
argument_list|(
name|tp
argument_list|,
operator|*
name|obstart
argument_list|)
operator|==
literal|0
condition|)
block|{
name|obstart
operator|++
expr_stmt|;
name|oblen
operator|--
expr_stmt|;
name|tp
operator|->
name|t_writepos
operator|=
name|tp
operator|->
name|t_column
expr_stmt|;
name|ttyinq_reprintpos_set
argument_list|(
operator|&
name|tp
operator|->
name|t_inq
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
else|else
block|{
comment|/* We're going to write regular data. */
name|wlen
operator|=
name|ttyoutq_write
argument_list|(
operator|&
name|tp
operator|->
name|t_outq
argument_list|,
name|obstart
argument_list|,
name|plen
argument_list|)
expr_stmt|;
name|obstart
operator|+=
name|wlen
expr_stmt|;
name|oblen
operator|-=
name|wlen
expr_stmt|;
name|tp
operator|->
name|t_column
operator|+=
name|wlen
expr_stmt|;
name|tp
operator|->
name|t_writepos
operator|=
name|tp
operator|->
name|t_column
expr_stmt|;
name|ttyinq_reprintpos_set
argument_list|(
operator|&
name|tp
operator|->
name|t_inq
argument_list|)
expr_stmt|;
if|if
condition|(
name|wlen
operator|==
name|plen
condition|)
continue|continue;
block|}
comment|/* Watermark reached. Try to sleep. */
name|tp
operator|->
name|t_flags
operator||=
name|TF_HIWAT_OUT
expr_stmt|;
if|if
condition|(
name|ioflag
operator|&
name|IO_NDELAY
condition|)
block|{
name|error
operator|=
name|EWOULDBLOCK
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* 			 * The driver may write back the data 			 * synchronously. Be sure to check the high 			 * water mark before going to sleep. 			 */
name|ttydevsw_outwakeup
argument_list|(
name|tp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tp
operator|->
name|t_flags
operator|&
name|TF_HIWAT_OUT
operator|)
operator|==
literal|0
condition|)
continue|continue;
name|error
operator|=
name|tty_wait
argument_list|(
name|tp
argument_list|,
operator|&
name|tp
operator|->
name|t_outwait
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|done
goto|;
if|if
condition|(
name|tp
operator|->
name|t_flags
operator|&
name|TF_ZOMBIE
condition|)
block|{
name|error
operator|=
name|EIO
expr_stmt|;
goto|goto
name|done
goto|;
block|}
block|}
do|while
condition|(
name|oblen
operator|>
literal|0
condition|)
do|;
block|}
name|done
label|:
if|if
condition|(
operator|!
name|tty_gone
argument_list|(
name|tp
argument_list|)
condition|)
name|ttydevsw_outwakeup
argument_list|(
name|tp
argument_list|)
expr_stmt|;
comment|/* 	 * Add the amount of bytes that we didn't process back to the 	 * uio counters. We need to do this to make sure write() doesn't 	 * count the bytes we didn't store in the queue. 	 */
name|uio
operator|->
name|uio_resid
operator|+=
name|oblen
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|void
name|ttydisc_optimize
parameter_list|(
name|struct
name|tty
modifier|*
name|tp
parameter_list|)
block|{
name|tty_lock_assert
argument_list|(
name|tp
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
if|if
condition|(
name|ttyhook_hashook
argument_list|(
name|tp
argument_list|,
name|rint_bypass
argument_list|)
condition|)
block|{
name|tp
operator|->
name|t_flags
operator||=
name|TF_BYPASS
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ttyhook_hashook
argument_list|(
name|tp
argument_list|,
name|rint
argument_list|)
condition|)
block|{
name|tp
operator|->
name|t_flags
operator|&=
operator|~
name|TF_BYPASS
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|CMP_FLAG
argument_list|(
name|i
argument_list|,
name|ICRNL
operator||
name|IGNCR
operator||
name|IMAXBEL
operator||
name|INLCR
operator||
name|ISTRIP
operator||
name|IXON
argument_list|)
operator|&&
operator|(
operator|!
name|CMP_FLAG
argument_list|(
name|i
argument_list|,
name|BRKINT
argument_list|)
operator|||
name|CMP_FLAG
argument_list|(
name|i
argument_list|,
name|IGNBRK
argument_list|)
operator|)
operator|&&
operator|(
operator|!
name|CMP_FLAG
argument_list|(
name|i
argument_list|,
name|PARMRK
argument_list|)
operator|||
name|CMP_FLAG
argument_list|(
name|i
argument_list|,
name|IGNPAR
operator||
name|IGNBRK
argument_list|)
operator|==
operator|(
name|IGNPAR
operator||
name|IGNBRK
operator|)
operator|)
operator|&&
operator|!
name|CMP_FLAG
argument_list|(
name|l
argument_list|,
name|ECHO
operator||
name|ICANON
operator||
name|IEXTEN
operator||
name|ISIG
operator||
name|PENDIN
argument_list|)
condition|)
block|{
name|tp
operator|->
name|t_flags
operator||=
name|TF_BYPASS
expr_stmt|;
block|}
else|else
block|{
name|tp
operator|->
name|t_flags
operator|&=
operator|~
name|TF_BYPASS
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|ttydisc_modem
parameter_list|(
name|struct
name|tty
modifier|*
name|tp
parameter_list|,
name|int
name|open
parameter_list|)
block|{
name|tty_lock_assert
argument_list|(
name|tp
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
if|if
condition|(
name|open
condition|)
name|cv_broadcast
argument_list|(
operator|&
name|tp
operator|->
name|t_dcdwait
argument_list|)
expr_stmt|;
comment|/* 	 * Ignore modem status lines when CLOCAL is turned on, but don't 	 * enter the zombie state when the TTY isn't opened, because 	 * that would cause the TTY to be in zombie state after being 	 * opened. 	 */
if|if
condition|(
operator|!
name|tty_opened
argument_list|(
name|tp
argument_list|)
operator|||
name|CMP_FLAG
argument_list|(
name|c
argument_list|,
name|CLOCAL
argument_list|)
condition|)
return|return;
if|if
condition|(
name|open
operator|==
literal|0
condition|)
block|{
comment|/* 		 * Lost carrier. 		 */
name|tp
operator|->
name|t_flags
operator||=
name|TF_ZOMBIE
expr_stmt|;
name|tty_signal_sessleader
argument_list|(
name|tp
argument_list|,
name|SIGHUP
argument_list|)
expr_stmt|;
name|tty_flush
argument_list|(
name|tp
argument_list|,
name|FREAD
operator||
name|FWRITE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Carrier is back again. 		 */
comment|/* XXX: what should we do here? */
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|ttydisc_echo_force
parameter_list|(
name|struct
name|tty
modifier|*
name|tp
parameter_list|,
name|char
name|c
parameter_list|,
name|int
name|quote
parameter_list|)
block|{
if|if
condition|(
name|CMP_FLAG
argument_list|(
name|o
argument_list|,
name|OPOST
argument_list|)
operator|&&
name|CTL_ECHO
argument_list|(
name|c
argument_list|,
name|quote
argument_list|)
condition|)
block|{
comment|/* 		 * Only perform postprocessing when OPOST is turned on 		 * and the character is an unquoted BS/TB/NL/CR. 		 */
return|return
name|ttydisc_write_oproc
argument_list|(
name|tp
argument_list|,
name|c
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|CMP_FLAG
argument_list|(
name|l
argument_list|,
name|ECHOCTL
argument_list|)
operator|&&
name|CTL_PRINT
argument_list|(
name|c
argument_list|,
name|quote
argument_list|)
condition|)
block|{
comment|/* 		 * Only use ^X notation when ECHOCTL is turned on and 		 * we've got an quoted control character. 		 * 		 * Print backspaces when echoing an end-of-file. 		 */
name|char
name|ob
index|[
literal|4
index|]
init|=
literal|"^?\b\b"
decl_stmt|;
comment|/* Print ^X notation. */
if|if
condition|(
name|c
operator|!=
literal|0x7f
condition|)
name|ob
index|[
literal|1
index|]
operator|=
name|c
operator|+
literal|'A'
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|quote
operator|&&
name|CMP_CC
argument_list|(
name|VEOF
argument_list|,
name|c
argument_list|)
condition|)
block|{
return|return
name|ttyoutq_write_nofrag
argument_list|(
operator|&
name|tp
operator|->
name|t_outq
argument_list|,
name|ob
argument_list|,
literal|4
argument_list|)
return|;
block|}
else|else
block|{
name|tp
operator|->
name|t_column
operator|+=
literal|2
expr_stmt|;
return|return
name|ttyoutq_write_nofrag
argument_list|(
operator|&
name|tp
operator|->
name|t_outq
argument_list|,
name|ob
argument_list|,
literal|2
argument_list|)
return|;
block|}
block|}
else|else
block|{
comment|/* Can just be printed. */
name|tp
operator|->
name|t_column
operator|++
expr_stmt|;
return|return
name|ttyoutq_write_nofrag
argument_list|(
operator|&
name|tp
operator|->
name|t_outq
argument_list|,
operator|&
name|c
argument_list|,
literal|1
argument_list|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|ttydisc_echo
parameter_list|(
name|struct
name|tty
modifier|*
name|tp
parameter_list|,
name|char
name|c
parameter_list|,
name|int
name|quote
parameter_list|)
block|{
comment|/* 	 * Only echo characters when ECHO is turned on, or ECHONL when 	 * the character is an unquoted newline. 	 */
if|if
condition|(
operator|!
name|CMP_FLAG
argument_list|(
name|l
argument_list|,
name|ECHO
argument_list|)
operator|&&
operator|(
operator|!
name|CMP_FLAG
argument_list|(
name|l
argument_list|,
name|ECHONL
argument_list|)
operator|||
name|c
operator|!=
name|CNL
operator|||
name|quote
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
name|ttydisc_echo_force
argument_list|(
name|tp
argument_list|,
name|c
argument_list|,
name|quote
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ttydisc_reprint_char
parameter_list|(
name|void
modifier|*
name|d
parameter_list|,
name|char
name|c
parameter_list|,
name|int
name|quote
parameter_list|)
block|{
name|struct
name|tty
modifier|*
name|tp
init|=
name|d
decl_stmt|;
name|ttydisc_echo
argument_list|(
name|tp
argument_list|,
name|c
argument_list|,
name|quote
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ttydisc_reprint
parameter_list|(
name|struct
name|tty
modifier|*
name|tp
parameter_list|)
block|{
name|cc_t
name|c
decl_stmt|;
comment|/* Print  ^R\n, followed by the line. */
name|c
operator|=
name|tp
operator|->
name|t_termios
operator|.
name|c_cc
index|[
name|VREPRINT
index|]
expr_stmt|;
if|if
condition|(
name|c
operator|!=
name|_POSIX_VDISABLE
condition|)
name|ttydisc_echo
argument_list|(
name|tp
argument_list|,
name|c
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ttydisc_echo
argument_list|(
name|tp
argument_list|,
name|CNL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ttyinq_reprintpos_reset
argument_list|(
operator|&
name|tp
operator|->
name|t_inq
argument_list|)
expr_stmt|;
name|ttyinq_line_iterate_from_linestart
argument_list|(
operator|&
name|tp
operator|->
name|t_inq
argument_list|,
name|ttydisc_reprint_char
argument_list|,
name|tp
argument_list|)
expr_stmt|;
block|}
end_function

begin_struct
struct|struct
name|ttydisc_recalc_length
block|{
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
name|unsigned
name|int
name|curlen
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|void
name|ttydisc_recalc_charlength
parameter_list|(
name|void
modifier|*
name|d
parameter_list|,
name|char
name|c
parameter_list|,
name|int
name|quote
parameter_list|)
block|{
name|struct
name|ttydisc_recalc_length
modifier|*
name|data
init|=
name|d
decl_stmt|;
name|struct
name|tty
modifier|*
name|tp
init|=
name|data
operator|->
name|tp
decl_stmt|;
if|if
condition|(
name|CTL_PRINT
argument_list|(
name|c
argument_list|,
name|quote
argument_list|)
condition|)
block|{
if|if
condition|(
name|CMP_FLAG
argument_list|(
name|l
argument_list|,
name|ECHOCTL
argument_list|)
condition|)
name|data
operator|->
name|curlen
operator|+=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
name|CTAB
condition|)
block|{
name|data
operator|->
name|curlen
operator|+=
literal|8
operator|-
operator|(
name|data
operator|->
name|curlen
operator|&
literal|7
operator|)
expr_stmt|;
block|}
else|else
block|{
name|data
operator|->
name|curlen
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|unsigned
name|int
name|ttydisc_recalc_linelength
parameter_list|(
name|struct
name|tty
modifier|*
name|tp
parameter_list|)
block|{
name|struct
name|ttydisc_recalc_length
name|data
init|=
block|{
name|tp
block|,
name|tp
operator|->
name|t_writepos
block|}
decl_stmt|;
name|ttyinq_line_iterate_from_reprintpos
argument_list|(
operator|&
name|tp
operator|->
name|t_inq
argument_list|,
name|ttydisc_recalc_charlength
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
return|return
operator|(
name|data
operator|.
name|curlen
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ttydisc_rubchar
parameter_list|(
name|struct
name|tty
modifier|*
name|tp
parameter_list|)
block|{
name|char
name|c
decl_stmt|;
name|int
name|quote
decl_stmt|;
name|unsigned
name|int
name|prevpos
decl_stmt|,
name|tablen
decl_stmt|;
if|if
condition|(
name|ttyinq_peekchar
argument_list|(
operator|&
name|tp
operator|->
name|t_inq
argument_list|,
operator|&
name|c
argument_list|,
operator|&
name|quote
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|ttyinq_unputchar
argument_list|(
operator|&
name|tp
operator|->
name|t_inq
argument_list|)
expr_stmt|;
if|if
condition|(
name|CMP_FLAG
argument_list|(
name|l
argument_list|,
name|ECHO
argument_list|)
condition|)
block|{
comment|/* 		 * Remove the character from the screen. This is even 		 * safe for characters that span multiple characters 		 * (tabs, quoted, etc). 		 */
if|if
condition|(
name|tp
operator|->
name|t_writepos
operator|>=
name|tp
operator|->
name|t_column
condition|)
block|{
comment|/* Retype the sentence. */
name|ttydisc_reprint
argument_list|(
name|tp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|CMP_FLAG
argument_list|(
name|l
argument_list|,
name|ECHOE
argument_list|)
condition|)
block|{
if|if
condition|(
name|CTL_PRINT
argument_list|(
name|c
argument_list|,
name|quote
argument_list|)
condition|)
block|{
comment|/* Remove ^X formatted chars. */
if|if
condition|(
name|CMP_FLAG
argument_list|(
name|l
argument_list|,
name|ECHOCTL
argument_list|)
condition|)
block|{
name|tp
operator|->
name|t_column
operator|-=
literal|2
expr_stmt|;
name|ttyoutq_write_nofrag
argument_list|(
operator|&
name|tp
operator|->
name|t_outq
argument_list|,
literal|"\b\b  \b\b"
argument_list|,
literal|6
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|' '
condition|)
block|{
comment|/* Space character needs no rubbing. */
name|tp
operator|->
name|t_column
operator|-=
literal|1
expr_stmt|;
name|ttyoutq_write_nofrag
argument_list|(
operator|&
name|tp
operator|->
name|t_outq
argument_list|,
literal|"\b"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
name|CTAB
condition|)
block|{
comment|/* 				 * Making backspace work with tabs is 				 * quite hard. Recalculate the length of 				 * this character and remove it. 				 * 				 * Because terminal settings could be 				 * changed while the line is being 				 * inserted, the calculations don't have 				 * to be correct. Make sure we keep the 				 * tab length within proper bounds. 				 */
name|prevpos
operator|=
name|ttydisc_recalc_linelength
argument_list|(
name|tp
argument_list|)
expr_stmt|;
if|if
condition|(
name|prevpos
operator|>=
name|tp
operator|->
name|t_column
condition|)
name|tablen
operator|=
literal|1
expr_stmt|;
else|else
name|tablen
operator|=
name|tp
operator|->
name|t_column
operator|-
name|prevpos
expr_stmt|;
if|if
condition|(
name|tablen
operator|>
literal|8
condition|)
name|tablen
operator|=
literal|8
expr_stmt|;
name|tp
operator|->
name|t_column
operator|=
name|prevpos
expr_stmt|;
name|ttyoutq_write_nofrag
argument_list|(
operator|&
name|tp
operator|->
name|t_outq
argument_list|,
literal|"\b\b\b\b\b\b\b\b"
argument_list|,
name|tablen
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
block|{
comment|/* 				 * Remove a regular character by 				 * punching a space over it. 				 */
name|tp
operator|->
name|t_column
operator|-=
literal|1
expr_stmt|;
name|ttyoutq_write_nofrag
argument_list|(
operator|&
name|tp
operator|->
name|t_outq
argument_list|,
literal|"\b \b"
argument_list|,
literal|3
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Don't print spaces. */
name|ttydisc_echo
argument_list|(
name|tp
argument_list|,
name|tp
operator|->
name|t_termios
operator|.
name|c_cc
index|[
name|VERASE
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ttydisc_rubword
parameter_list|(
name|struct
name|tty
modifier|*
name|tp
parameter_list|)
block|{
name|char
name|c
decl_stmt|;
name|int
name|quote
decl_stmt|,
name|alnum
decl_stmt|;
comment|/* Strip whitespace first. */
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|ttyinq_peekchar
argument_list|(
operator|&
name|tp
operator|->
name|t_inq
argument_list|,
operator|&
name|c
argument_list|,
operator|&
name|quote
argument_list|)
operator|!=
literal|0
condition|)
return|return;
if|if
condition|(
operator|!
name|CTL_WHITE
argument_list|(
name|c
argument_list|)
condition|)
break|break;
name|ttydisc_rubchar
argument_list|(
name|tp
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Record whether the last character from the previous iteration 	 * was alphanumeric or not. We need this to implement ALTWERASE. 	 */
name|alnum
operator|=
name|CTL_ALNUM
argument_list|(
name|c
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|ttydisc_rubchar
argument_list|(
name|tp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ttyinq_peekchar
argument_list|(
operator|&
name|tp
operator|->
name|t_inq
argument_list|,
operator|&
name|c
argument_list|,
operator|&
name|quote
argument_list|)
operator|!=
literal|0
condition|)
return|return;
if|if
condition|(
name|CTL_WHITE
argument_list|(
name|c
argument_list|)
condition|)
return|return;
if|if
condition|(
name|CMP_FLAG
argument_list|(
name|l
argument_list|,
name|ALTWERASE
argument_list|)
operator|&&
name|CTL_ALNUM
argument_list|(
name|c
argument_list|)
operator|!=
name|alnum
condition|)
return|return;
block|}
block|}
end_function

begin_function
name|int
name|ttydisc_rint
parameter_list|(
name|struct
name|tty
modifier|*
name|tp
parameter_list|,
name|char
name|c
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|int
name|signal
decl_stmt|,
name|quote
init|=
literal|0
decl_stmt|;
name|char
name|ob
index|[
literal|3
index|]
init|=
block|{
literal|0xff
block|,
literal|0x00
block|}
decl_stmt|;
name|size_t
name|ol
decl_stmt|;
name|tty_lock_assert
argument_list|(
name|tp
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|atomic_add_long
argument_list|(
operator|&
name|tty_nin
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ttyhook_hashook
argument_list|(
name|tp
argument_list|,
name|rint
argument_list|)
condition|)
return|return
name|ttyhook_rint
argument_list|(
name|tp
argument_list|,
name|c
argument_list|,
name|flags
argument_list|)
return|;
if|if
condition|(
name|tp
operator|->
name|t_flags
operator|&
name|TF_BYPASS
condition|)
goto|goto
name|processed
goto|;
if|if
condition|(
name|flags
condition|)
block|{
if|if
condition|(
name|flags
operator|&
name|TRE_BREAK
condition|)
block|{
if|if
condition|(
name|CMP_FLAG
argument_list|(
name|i
argument_list|,
name|IGNBRK
argument_list|)
condition|)
block|{
comment|/* Ignore break characters. */
return|return
operator|(
literal|0
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|CMP_FLAG
argument_list|(
name|i
argument_list|,
name|BRKINT
argument_list|)
condition|)
block|{
comment|/* Generate SIGINT on break. */
name|tty_flush
argument_list|(
name|tp
argument_list|,
name|FREAD
operator||
name|FWRITE
argument_list|)
expr_stmt|;
name|tty_signal_pgrp
argument_list|(
name|tp
argument_list|,
name|SIGINT
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
block|{
comment|/* Just print it. */
goto|goto
name|parmrk
goto|;
block|}
block|}
elseif|else
if|if
condition|(
name|flags
operator|&
name|TRE_FRAMING
operator|||
operator|(
name|flags
operator|&
name|TRE_PARITY
operator|&&
name|CMP_FLAG
argument_list|(
name|i
argument_list|,
name|INPCK
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|CMP_FLAG
argument_list|(
name|i
argument_list|,
name|IGNPAR
argument_list|)
condition|)
block|{
comment|/* Ignore bad characters. */
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
block|{
comment|/* Just print it. */
goto|goto
name|parmrk
goto|;
block|}
block|}
block|}
comment|/* Allow any character to perform a wakeup. */
if|if
condition|(
name|CMP_FLAG
argument_list|(
name|i
argument_list|,
name|IXANY
argument_list|)
condition|)
name|tp
operator|->
name|t_flags
operator|&=
operator|~
name|TF_STOPPED
expr_stmt|;
comment|/* Remove the top bit. */
if|if
condition|(
name|CMP_FLAG
argument_list|(
name|i
argument_list|,
name|ISTRIP
argument_list|)
condition|)
name|c
operator|&=
operator|~
literal|0x80
expr_stmt|;
comment|/* Skip input processing when we want to print it literally. */
if|if
condition|(
name|tp
operator|->
name|t_flags
operator|&
name|TF_LITERAL
condition|)
block|{
name|tp
operator|->
name|t_flags
operator|&=
operator|~
name|TF_LITERAL
expr_stmt|;
name|quote
operator|=
literal|1
expr_stmt|;
goto|goto
name|processed
goto|;
block|}
comment|/* Special control characters that are implementation dependent. */
if|if
condition|(
name|CMP_FLAG
argument_list|(
name|l
argument_list|,
name|IEXTEN
argument_list|)
condition|)
block|{
comment|/* Accept the next character as literal. */
if|if
condition|(
name|CMP_CC
argument_list|(
name|VLNEXT
argument_list|,
name|c
argument_list|)
condition|)
block|{
if|if
condition|(
name|CMP_FLAG
argument_list|(
name|l
argument_list|,
name|ECHO
argument_list|)
condition|)
block|{
if|if
condition|(
name|CMP_FLAG
argument_list|(
name|l
argument_list|,
name|ECHOE
argument_list|)
condition|)
name|ttyoutq_write_nofrag
argument_list|(
operator|&
name|tp
operator|->
name|t_outq
argument_list|,
literal|"^\b"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
else|else
name|ttydisc_echo
argument_list|(
name|tp
argument_list|,
name|c
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|tp
operator|->
name|t_flags
operator||=
name|TF_LITERAL
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
comment|/* 	 * Handle signal processing. 	 */
if|if
condition|(
name|CMP_FLAG
argument_list|(
name|l
argument_list|,
name|ISIG
argument_list|)
condition|)
block|{
if|if
condition|(
name|CMP_FLAG
argument_list|(
name|l
argument_list|,
name|ICANON
operator||
name|IEXTEN
argument_list|)
operator|==
operator|(
name|ICANON
operator||
name|IEXTEN
operator|)
condition|)
block|{
if|if
condition|(
name|CMP_CC
argument_list|(
name|VSTATUS
argument_list|,
name|c
argument_list|)
condition|)
block|{
name|tty_signal_pgrp
argument_list|(
name|tp
argument_list|,
name|SIGINFO
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
comment|/* 		 * When compared to the old implementation, this 		 * implementation also flushes the output queue. POSIX 		 * is really brief about this, but does makes us assume 		 * we have to do so. 		 */
name|signal
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|CMP_CC
argument_list|(
name|VINTR
argument_list|,
name|c
argument_list|)
condition|)
block|{
name|signal
operator|=
name|SIGINT
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|CMP_CC
argument_list|(
name|VQUIT
argument_list|,
name|c
argument_list|)
condition|)
block|{
name|signal
operator|=
name|SIGQUIT
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|CMP_CC
argument_list|(
name|VSUSP
argument_list|,
name|c
argument_list|)
condition|)
block|{
name|signal
operator|=
name|SIGTSTP
expr_stmt|;
block|}
if|if
condition|(
name|signal
operator|!=
literal|0
condition|)
block|{
comment|/* 			 * Echo the character before signalling the 			 * processes. 			 */
if|if
condition|(
operator|!
name|CMP_FLAG
argument_list|(
name|l
argument_list|,
name|NOFLSH
argument_list|)
condition|)
name|tty_flush
argument_list|(
name|tp
argument_list|,
name|FREAD
operator||
name|FWRITE
argument_list|)
expr_stmt|;
name|ttydisc_echo
argument_list|(
name|tp
argument_list|,
name|c
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tty_signal_pgrp
argument_list|(
name|tp
argument_list|,
name|signal
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
comment|/* 	 * Handle start/stop characters. 	 */
if|if
condition|(
name|CMP_FLAG
argument_list|(
name|i
argument_list|,
name|IXON
argument_list|)
condition|)
block|{
if|if
condition|(
name|CMP_CC
argument_list|(
name|VSTOP
argument_list|,
name|c
argument_list|)
condition|)
block|{
comment|/* Stop it if we aren't stopped yet. */
if|if
condition|(
operator|(
name|tp
operator|->
name|t_flags
operator|&
name|TF_STOPPED
operator|)
operator|==
literal|0
condition|)
block|{
name|tp
operator|->
name|t_flags
operator||=
name|TF_STOPPED
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 			 * Fallthrough: 			 * When VSTART == VSTOP, we should make this key 			 * toggle it. 			 */
if|if
condition|(
operator|!
name|CMP_CC
argument_list|(
name|VSTART
argument_list|,
name|c
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|CMP_CC
argument_list|(
name|VSTART
argument_list|,
name|c
argument_list|)
condition|)
block|{
name|tp
operator|->
name|t_flags
operator|&=
operator|~
name|TF_STOPPED
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
comment|/* Conversion of CR and NL. */
switch|switch
condition|(
name|c
condition|)
block|{
case|case
name|CCR
case|:
if|if
condition|(
name|CMP_FLAG
argument_list|(
name|i
argument_list|,
name|IGNCR
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|CMP_FLAG
argument_list|(
name|i
argument_list|,
name|ICRNL
argument_list|)
condition|)
name|c
operator|=
name|CNL
expr_stmt|;
break|break;
case|case
name|CNL
case|:
if|if
condition|(
name|CMP_FLAG
argument_list|(
name|i
argument_list|,
name|INLCR
argument_list|)
condition|)
name|c
operator|=
name|CCR
expr_stmt|;
break|break;
block|}
comment|/* Canonical line editing. */
if|if
condition|(
name|CMP_FLAG
argument_list|(
name|l
argument_list|,
name|ICANON
argument_list|)
condition|)
block|{
if|if
condition|(
name|CMP_CC
argument_list|(
name|VERASE
argument_list|,
name|c
argument_list|)
operator|||
name|CMP_CC
argument_list|(
name|VERASE2
argument_list|,
name|c
argument_list|)
condition|)
block|{
name|ttydisc_rubchar
argument_list|(
name|tp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|CMP_CC
argument_list|(
name|VKILL
argument_list|,
name|c
argument_list|)
condition|)
block|{
while|while
condition|(
name|ttydisc_rubchar
argument_list|(
name|tp
argument_list|)
operator|==
literal|0
condition|)
empty_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|CMP_FLAG
argument_list|(
name|l
argument_list|,
name|IEXTEN
argument_list|)
condition|)
block|{
if|if
condition|(
name|CMP_CC
argument_list|(
name|VWERASE
argument_list|,
name|c
argument_list|)
condition|)
block|{
name|ttydisc_rubword
argument_list|(
name|tp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|CMP_CC
argument_list|(
name|VREPRINT
argument_list|,
name|c
argument_list|)
condition|)
block|{
name|ttydisc_reprint
argument_list|(
name|tp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
block|}
name|processed
label|:
if|if
condition|(
name|CMP_FLAG
argument_list|(
name|i
argument_list|,
name|PARMRK
argument_list|)
operator|&&
operator|(
name|unsigned
name|char
operator|)
name|c
operator|==
literal|0xff
condition|)
block|{
comment|/* Print 0xff 0xff. */
name|ob
index|[
literal|1
index|]
operator|=
literal|0xff
expr_stmt|;
name|ol
operator|=
literal|2
expr_stmt|;
name|quote
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|ob
index|[
literal|0
index|]
operator|=
name|c
expr_stmt|;
name|ol
operator|=
literal|1
expr_stmt|;
block|}
goto|goto
name|print
goto|;
name|parmrk
label|:
if|if
condition|(
name|CMP_FLAG
argument_list|(
name|i
argument_list|,
name|PARMRK
argument_list|)
condition|)
block|{
comment|/* Prepend 0xff 0x00 0x.. */
name|ob
index|[
literal|2
index|]
operator|=
name|c
expr_stmt|;
name|ol
operator|=
literal|3
expr_stmt|;
name|quote
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|ob
index|[
literal|0
index|]
operator|=
name|c
expr_stmt|;
name|ol
operator|=
literal|1
expr_stmt|;
block|}
name|print
label|:
comment|/* See if we can store this on the input queue. */
if|if
condition|(
name|ttyinq_write_nofrag
argument_list|(
operator|&
name|tp
operator|->
name|t_inq
argument_list|,
name|ob
argument_list|,
name|ol
argument_list|,
name|quote
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|CMP_FLAG
argument_list|(
name|i
argument_list|,
name|IMAXBEL
argument_list|)
condition|)
name|ttyoutq_write_nofrag
argument_list|(
operator|&
name|tp
operator|->
name|t_outq
argument_list|,
literal|"\a"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* 		 * Prevent a deadlock here. It may be possible that a 		 * user has entered so much data, there is no data 		 * available to read(), but the buffers are full anyway. 		 * 		 * Only enter the high watermark if the device driver 		 * can actually transmit something. 		 */
if|if
condition|(
name|ttyinq_bytescanonicalized
argument_list|(
operator|&
name|tp
operator|->
name|t_inq
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|tty_hiwat_in_block
argument_list|(
name|tp
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* 	 * In raw mode, we canonicalize after receiving a single 	 * character. Otherwise, we canonicalize when we receive a 	 * newline, VEOL or VEOF, but only when it isn't quoted. 	 */
if|if
condition|(
operator|!
name|CMP_FLAG
argument_list|(
name|l
argument_list|,
name|ICANON
argument_list|)
operator|||
operator|(
operator|!
name|quote
operator|&&
operator|(
name|c
operator|==
name|CNL
operator|||
name|CMP_CC
argument_list|(
name|VEOL
argument_list|,
name|c
argument_list|)
operator|||
name|CMP_CC
argument_list|(
name|VEOF
argument_list|,
name|c
argument_list|)
operator|)
operator|)
condition|)
block|{
name|ttyinq_canonicalize
argument_list|(
operator|&
name|tp
operator|->
name|t_inq
argument_list|)
expr_stmt|;
block|}
name|ttydisc_echo
argument_list|(
name|tp
argument_list|,
name|c
argument_list|,
name|quote
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|size_t
name|ttydisc_rint_simple
parameter_list|(
name|struct
name|tty
modifier|*
name|tp
parameter_list|,
specifier|const
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|cbuf
decl_stmt|;
if|if
condition|(
name|ttydisc_can_bypass
argument_list|(
name|tp
argument_list|)
condition|)
return|return
operator|(
name|ttydisc_rint_bypass
argument_list|(
name|tp
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
operator|)
return|;
for|for
control|(
name|cbuf
operator|=
name|buf
init|;
name|len
operator|--
operator|>
literal|0
condition|;
name|cbuf
operator|++
control|)
block|{
if|if
condition|(
name|ttydisc_rint
argument_list|(
name|tp
argument_list|,
operator|*
name|cbuf
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
break|break;
block|}
return|return
operator|(
name|cbuf
operator|-
operator|(
specifier|const
name|char
operator|*
operator|)
name|buf
operator|)
return|;
block|}
end_function

begin_function
name|size_t
name|ttydisc_rint_bypass
parameter_list|(
name|struct
name|tty
modifier|*
name|tp
parameter_list|,
specifier|const
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|size_t
name|ret
decl_stmt|;
name|tty_lock_assert
argument_list|(
name|tp
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|tp
operator|->
name|t_flags
operator|&
name|TF_BYPASS
argument_list|)
expr_stmt|;
name|atomic_add_long
argument_list|(
operator|&
name|tty_nin
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|ttyhook_hashook
argument_list|(
name|tp
argument_list|,
name|rint_bypass
argument_list|)
condition|)
return|return
name|ttyhook_rint_bypass
argument_list|(
name|tp
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
return|;
name|ret
operator|=
name|ttyinq_write
argument_list|(
operator|&
name|tp
operator|->
name|t_inq
argument_list|,
name|buf
argument_list|,
name|len
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ttyinq_canonicalize
argument_list|(
operator|&
name|tp
operator|->
name|t_inq
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<
name|len
condition|)
name|tty_hiwat_in_block
argument_list|(
name|tp
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
name|void
name|ttydisc_rint_done
parameter_list|(
name|struct
name|tty
modifier|*
name|tp
parameter_list|)
block|{
name|tty_lock_assert
argument_list|(
name|tp
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
if|if
condition|(
name|ttyhook_hashook
argument_list|(
name|tp
argument_list|,
name|rint_done
argument_list|)
condition|)
name|ttyhook_rint_done
argument_list|(
name|tp
argument_list|)
expr_stmt|;
comment|/* Wake up readers. */
name|tty_wakeup
argument_list|(
name|tp
argument_list|,
name|FREAD
argument_list|)
expr_stmt|;
comment|/* Wake up driver for echo. */
name|ttydevsw_outwakeup
argument_list|(
name|tp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|size_t
name|ttydisc_rint_poll
parameter_list|(
name|struct
name|tty
modifier|*
name|tp
parameter_list|)
block|{
name|size_t
name|l
decl_stmt|;
name|tty_lock_assert
argument_list|(
name|tp
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
if|if
condition|(
name|ttyhook_hashook
argument_list|(
name|tp
argument_list|,
name|rint_poll
argument_list|)
condition|)
return|return
name|ttyhook_rint_poll
argument_list|(
name|tp
argument_list|)
return|;
comment|/* 	 * XXX: Still allow character input when there's no space in the 	 * buffers, but we haven't entered the high watermark. This is 	 * to allow backspace characters to be inserted when in 	 * canonical mode. 	 */
name|l
operator|=
name|ttyinq_bytesleft
argument_list|(
operator|&
name|tp
operator|->
name|t_inq
argument_list|)
expr_stmt|;
if|if
condition|(
name|l
operator|==
literal|0
operator|&&
operator|(
name|tp
operator|->
name|t_flags
operator|&
name|TF_HIWAT_IN
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
name|l
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ttydisc_wakeup_watermark
parameter_list|(
name|struct
name|tty
modifier|*
name|tp
parameter_list|)
block|{
name|size_t
name|c
decl_stmt|;
name|c
operator|=
name|ttyoutq_bytesleft
argument_list|(
operator|&
name|tp
operator|->
name|t_outq
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_flags
operator|&
name|TF_HIWAT_OUT
condition|)
block|{
comment|/* Only allow us to run when we're below the watermark. */
if|if
condition|(
name|c
operator|<
name|tp
operator|->
name|t_outlow
condition|)
return|return;
comment|/* Reset the watermark. */
name|tp
operator|->
name|t_flags
operator|&=
operator|~
name|TF_HIWAT_OUT
expr_stmt|;
block|}
else|else
block|{
comment|/* Only run when we have data at all. */
if|if
condition|(
name|c
operator|==
literal|0
condition|)
return|return;
block|}
name|tty_wakeup
argument_list|(
name|tp
argument_list|,
name|FWRITE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|size_t
name|ttydisc_getc
parameter_list|(
name|struct
name|tty
modifier|*
name|tp
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|tty_lock_assert
argument_list|(
name|tp
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_flags
operator|&
name|TF_STOPPED
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|ttyhook_hashook
argument_list|(
name|tp
argument_list|,
name|getc_inject
argument_list|)
condition|)
return|return
name|ttyhook_getc_inject
argument_list|(
name|tp
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
return|;
name|len
operator|=
name|ttyoutq_read
argument_list|(
operator|&
name|tp
operator|->
name|t_outq
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|ttyhook_hashook
argument_list|(
name|tp
argument_list|,
name|getc_capture
argument_list|)
condition|)
name|ttyhook_getc_capture
argument_list|(
name|tp
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|ttydisc_wakeup_watermark
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|atomic_add_long
argument_list|(
operator|&
name|tty_nout
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
operator|(
name|len
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ttydisc_getc_uio
parameter_list|(
name|struct
name|tty
modifier|*
name|tp
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|)
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
name|int
name|obytes
init|=
name|uio
operator|->
name|uio_resid
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|char
name|buf
index|[
name|TTY_STACKBUF
index|]
decl_stmt|;
name|tty_lock_assert
argument_list|(
name|tp
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_flags
operator|&
name|TF_STOPPED
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * When a TTY hook is attached, we cannot perform unbuffered 	 * copying to userspace. Just call ttydisc_getc() and 	 * temporarily store data in a shadow buffer. 	 */
if|if
condition|(
name|ttyhook_hashook
argument_list|(
name|tp
argument_list|,
name|getc_capture
argument_list|)
operator|||
name|ttyhook_hashook
argument_list|(
name|tp
argument_list|,
name|getc_inject
argument_list|)
condition|)
block|{
while|while
condition|(
name|uio
operator|->
name|uio_resid
operator|>
literal|0
condition|)
block|{
comment|/* Read to shadow buffer. */
name|len
operator|=
name|ttydisc_getc
argument_list|(
name|tp
argument_list|,
name|buf
argument_list|,
name|MIN
argument_list|(
name|uio
operator|->
name|uio_resid
argument_list|,
sizeof|sizeof
name|buf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
break|break;
comment|/* Copy to userspace. */
name|tty_unlock
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|error
operator|=
name|uiomove
argument_list|(
name|buf
argument_list|,
name|len
argument_list|,
name|uio
argument_list|)
expr_stmt|;
name|tty_lock
argument_list|(
name|tp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
break|break;
block|}
block|}
else|else
block|{
name|error
operator|=
name|ttyoutq_read_uio
argument_list|(
operator|&
name|tp
operator|->
name|t_outq
argument_list|,
name|tp
argument_list|,
name|uio
argument_list|)
expr_stmt|;
name|ttydisc_wakeup_watermark
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|atomic_add_long
argument_list|(
operator|&
name|tty_nout
argument_list|,
name|obytes
operator|-
name|uio
operator|->
name|uio_resid
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|size_t
name|ttydisc_getc_poll
parameter_list|(
name|struct
name|tty
modifier|*
name|tp
parameter_list|)
block|{
name|tty_lock_assert
argument_list|(
name|tp
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_flags
operator|&
name|TF_STOPPED
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|ttyhook_hashook
argument_list|(
name|tp
argument_list|,
name|getc_poll
argument_list|)
condition|)
return|return
name|ttyhook_getc_poll
argument_list|(
name|tp
argument_list|)
return|;
return|return
name|ttyoutq_bytesused
argument_list|(
operator|&
name|tp
operator|->
name|t_outq
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * XXX: not really related to the TTYDISC, but we'd better put  * tty_putchar() here, because we need to perform proper output  * processing.  */
end_comment

begin_function
name|int
name|tty_putchar
parameter_list|(
name|struct
name|tty
modifier|*
name|tp
parameter_list|,
name|char
name|c
parameter_list|)
block|{
name|tty_lock_assert
argument_list|(
name|tp
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
if|if
condition|(
name|tty_gone
argument_list|(
name|tp
argument_list|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|ttydisc_echo_force
argument_list|(
name|tp
argument_list|,
name|c
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tp
operator|->
name|t_writepos
operator|=
name|tp
operator|->
name|t_column
expr_stmt|;
name|ttyinq_reprintpos_set
argument_list|(
operator|&
name|tp
operator|->
name|t_inq
argument_list|)
expr_stmt|;
name|ttydevsw_outwakeup
argument_list|(
name|tp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

end_unit

