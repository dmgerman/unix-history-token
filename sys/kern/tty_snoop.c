begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1995 Ugen J.S.Antsilevich  *  * Redistribution and use in source forms, with and without modification,  * are permitted provided that this entire comment appears intact.  *  * Redistribution in binary form may occur without any restrictions.  * Obviously, it would be nice if you gave credit where credit is due  * but requiring it would be too onerous.  *  * This software is provided ``AS IS'' without any warranties of any kind.  *  * Snoop stuff.  */
end_comment

begin_include
include|#
directive|include
file|"snp.h"
end_include

begin_if
if|#
directive|if
name|NSNP
operator|>
literal|0
end_if

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/filio.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl_compat.h>
end_include

begin_comment
comment|/* Oooh..We need O/NTTYDISC	 */
end_comment

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/tty.h>
end_include

begin_include
include|#
directive|include
file|<sys/fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/poll.h>
end_include

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|DEVFS
end_ifdef

begin_include
include|#
directive|include
file|<sys/devfsext.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*DEVFS*/
end_comment

begin_include
include|#
directive|include
file|<sys/snoop.h>
end_include

begin_decl_stmt
specifier|static
name|d_open_t
name|snpopen
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_close_t
name|snpclose
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_read_t
name|snpread
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_write_t
name|snpwrite
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_ioctl_t
name|snpioctl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_poll_t
name|snppoll
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|CDEV_MAJOR
value|53
end_define

begin_decl_stmt
specifier|static
name|struct
name|cdevsw
name|snp_cdevsw
init|=
block|{
name|snpopen
block|,
name|snpclose
block|,
name|snpread
block|,
name|snpwrite
block|,
comment|/*53*/
name|snpioctl
block|,
name|nostop
block|,
name|nullreset
block|,
name|nodevtotty
block|,
comment|/* snoop */
name|snppoll
block|,
name|nommap
block|,
name|NULL
block|,
literal|"snp"
block|,
name|NULL
block|,
operator|-
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|MIN
end_ifndef

begin_define
define|#
directive|define
name|MIN
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|(((a)<(b))?(a):(b))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|struct
name|snoop
name|snoopsw
index|[
name|NSNP
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|tty
modifier|*
name|snpdevtotty
name|__P
argument_list|(
operator|(
name|dev_t
name|dev
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|snp_detach
name|__P
argument_list|(
operator|(
expr|struct
name|snoop
operator|*
name|snp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|struct
name|tty
modifier|*
name|snpdevtotty
parameter_list|(
name|dev
parameter_list|)
name|dev_t
name|dev
decl_stmt|;
block|{
name|struct
name|cdevsw
modifier|*
name|cdp
decl_stmt|;
name|int
name|maj
decl_stmt|;
name|maj
operator|=
name|major
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|u_int
operator|)
name|maj
operator|>=
name|nchrdev
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|cdp
operator|=
name|cdevsw
index|[
name|maj
index|]
expr_stmt|;
if|if
condition|(
name|cdp
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
return|return
operator|(
call|(
modifier|*
name|cdp
operator|->
name|d_devtotty
call|)
argument_list|(
name|dev
argument_list|)
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|SNP_INPUT_BUF
value|5
end_define

begin_comment
comment|/* This is even too  much,the maximal 				 * interactive mode write is 3 bytes 				 * length for function keys... 				 */
end_comment

begin_function
specifier|static
name|int
name|snpwrite
parameter_list|(
name|dev
parameter_list|,
name|uio
parameter_list|,
name|flag
parameter_list|)
name|dev_t
name|dev
decl_stmt|;
name|struct
name|uio
modifier|*
name|uio
decl_stmt|;
name|int
name|flag
decl_stmt|;
block|{
name|int
name|unit
init|=
name|minor
argument_list|(
name|dev
argument_list|)
decl_stmt|,
name|len
decl_stmt|,
name|i
decl_stmt|,
name|error
decl_stmt|;
name|struct
name|snoop
modifier|*
name|snp
init|=
operator|&
name|snoopsw
index|[
name|unit
index|]
decl_stmt|;
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
name|char
name|c
index|[
name|SNP_INPUT_BUF
index|]
decl_stmt|;
if|if
condition|(
name|snp
operator|->
name|snp_tty
operator|==
name|NULL
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
name|tp
operator|=
name|snp
operator|->
name|snp_tty
expr_stmt|;
if|if
condition|(
operator|(
name|tp
operator|->
name|t_sc
operator|==
name|snp
operator|)
operator|&&
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_SNOOP
operator|)
operator|&&
operator|(
name|tp
operator|->
name|t_line
operator|==
name|OTTYDISC
operator|||
name|tp
operator|->
name|t_line
operator|==
name|NTTYDISC
operator|)
condition|)
goto|goto
name|tty_input
goto|;
name|printf
argument_list|(
literal|"Snoop: attempt to write to bad tty.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
name|tty_input
label|:
if|if
condition|(
operator|!
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_ISOPEN
operator|)
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
while|while
condition|(
name|uio
operator|->
name|uio_resid
operator|>
literal|0
condition|)
block|{
name|len
operator|=
name|MIN
argument_list|(
name|uio
operator|->
name|uio_resid
argument_list|,
name|SNP_INPUT_BUF
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|uiomove
argument_list|(
name|c
argument_list|,
name|len
argument_list|,
name|uio
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ttyinput
argument_list|(
name|c
index|[
name|i
index|]
argument_list|,
name|tp
argument_list|)
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|snpread
parameter_list|(
name|dev
parameter_list|,
name|uio
parameter_list|,
name|flag
parameter_list|)
name|dev_t
name|dev
decl_stmt|;
name|struct
name|uio
modifier|*
name|uio
decl_stmt|;
name|int
name|flag
decl_stmt|;
block|{
name|int
name|unit
init|=
name|minor
argument_list|(
name|dev
argument_list|)
decl_stmt|,
name|s
decl_stmt|;
name|struct
name|snoop
modifier|*
name|snp
init|=
operator|&
name|snoopsw
index|[
name|unit
index|]
decl_stmt|;
name|int
name|len
decl_stmt|,
name|n
decl_stmt|,
name|nblen
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
name|caddr_t
name|from
decl_stmt|;
name|char
modifier|*
name|nbuf
decl_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
operator|(
name|snp
operator|->
name|snp_len
operator|+
name|snp
operator|->
name|snp_base
operator|)
operator|>
name|snp
operator|->
name|snp_blen
condition|)
name|panic
argument_list|(
literal|"snoop buffer error"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|snp
operator|->
name|snp_tty
operator|==
name|NULL
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
name|snp
operator|->
name|snp_flags
operator|&=
operator|~
name|SNOOP_RWAIT
expr_stmt|;
do|do
block|{
if|if
condition|(
name|snp
operator|->
name|snp_len
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|snp
operator|->
name|snp_flags
operator|&
name|SNOOP_NBIO
condition|)
block|{
return|return
name|EWOULDBLOCK
return|;
block|}
name|snp
operator|->
name|snp_flags
operator||=
name|SNOOP_RWAIT
expr_stmt|;
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
name|snp
argument_list|,
operator|(
name|PZERO
operator|+
literal|1
operator|)
operator||
name|PCATCH
argument_list|,
literal|"snoopread"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
do|while
condition|(
name|snp
operator|->
name|snp_len
operator|==
literal|0
condition|)
do|;
name|n
operator|=
name|snp
operator|->
name|snp_len
expr_stmt|;
while|while
condition|(
name|snp
operator|->
name|snp_len
operator|>
literal|0
operator|&&
name|uio
operator|->
name|uio_resid
operator|>
literal|0
operator|&&
name|error
operator|==
literal|0
condition|)
block|{
name|len
operator|=
name|MIN
argument_list|(
name|uio
operator|->
name|uio_resid
argument_list|,
name|snp
operator|->
name|snp_len
argument_list|)
expr_stmt|;
name|from
operator|=
call|(
name|caddr_t
call|)
argument_list|(
name|snp
operator|->
name|snp_buf
operator|+
name|snp
operator|->
name|snp_base
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
break|break;
name|error
operator|=
name|uiomove
argument_list|(
name|from
argument_list|,
name|len
argument_list|,
name|uio
argument_list|)
expr_stmt|;
name|snp
operator|->
name|snp_base
operator|+=
name|len
expr_stmt|;
name|snp
operator|->
name|snp_len
operator|-=
name|len
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|snp
operator|->
name|snp_flags
operator|&
name|SNOOP_OFLOW
operator|)
operator|&&
operator|(
name|n
operator|<
name|snp
operator|->
name|snp_len
operator|)
condition|)
block|{
name|snp
operator|->
name|snp_flags
operator|&=
operator|~
name|SNOOP_OFLOW
expr_stmt|;
block|}
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
name|nblen
operator|=
name|snp
operator|->
name|snp_blen
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|nblen
operator|/
literal|2
operator|)
operator|>=
name|SNOOP_MINLEN
operator|)
operator|&&
operator|(
name|nblen
operator|/
literal|2
operator|)
operator|>=
name|snp
operator|->
name|snp_len
condition|)
block|{
while|while
condition|(
operator|(
operator|(
name|nblen
operator|/
literal|2
operator|)
operator|>=
name|snp
operator|->
name|snp_len
operator|)
operator|&&
operator|(
operator|(
name|nblen
operator|/
literal|2
operator|)
operator|>=
name|SNOOP_MINLEN
operator|)
condition|)
name|nblen
operator|=
name|nblen
operator|/
literal|2
expr_stmt|;
if|if
condition|(
name|nbuf
operator|=
name|malloc
argument_list|(
name|nblen
argument_list|,
name|M_TTYS
argument_list|,
name|M_NOWAIT
argument_list|)
condition|)
block|{
name|bcopy
argument_list|(
name|snp
operator|->
name|snp_buf
operator|+
name|snp
operator|->
name|snp_base
argument_list|,
name|nbuf
argument_list|,
name|snp
operator|->
name|snp_len
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|snp
operator|->
name|snp_buf
argument_list|,
name|M_TTYS
argument_list|)
expr_stmt|;
name|snp
operator|->
name|snp_buf
operator|=
name|nbuf
expr_stmt|;
name|snp
operator|->
name|snp_blen
operator|=
name|nblen
expr_stmt|;
name|snp
operator|->
name|snp_base
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_function
name|int
name|snpinc
parameter_list|(
name|snp
parameter_list|,
name|c
parameter_list|)
name|struct
name|snoop
modifier|*
name|snp
decl_stmt|;
name|char
name|c
decl_stmt|;
block|{
name|char
name|buf
index|[
literal|1
index|]
decl_stmt|;
name|buf
index|[
literal|0
index|]
operator|=
name|c
expr_stmt|;
return|return
operator|(
name|snpin
argument_list|(
name|snp
argument_list|,
name|buf
argument_list|,
literal|1
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|snpin
parameter_list|(
name|snp
parameter_list|,
name|buf
parameter_list|,
name|n
parameter_list|)
name|struct
name|snoop
modifier|*
name|snp
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|int
name|n
decl_stmt|;
block|{
name|int
name|s_free
decl_stmt|,
name|s_tail
decl_stmt|;
name|int
name|s
decl_stmt|,
name|len
decl_stmt|,
name|nblen
decl_stmt|;
name|caddr_t
name|from
decl_stmt|,
name|to
decl_stmt|;
name|char
modifier|*
name|nbuf
decl_stmt|;
if|if
condition|(
name|n
operator|==
literal|0
condition|)
return|return
literal|0
return|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
name|n
operator|<
literal|0
condition|)
name|panic
argument_list|(
literal|"bad snoop char count"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|snp
operator|->
name|snp_flags
operator|&
name|SNOOP_OPEN
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"Snoop: data coming to closed device.\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
endif|#
directive|endif
if|if
condition|(
name|snp
operator|->
name|snp_flags
operator|&
name|SNOOP_DOWN
condition|)
block|{
name|printf
argument_list|(
literal|"Snoop: more data to down interface.\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|snp
operator|->
name|snp_flags
operator|&
name|SNOOP_OFLOW
condition|)
block|{
name|printf
argument_list|(
literal|"Snoop: buffer overflow.\n"
argument_list|)
expr_stmt|;
comment|/* 		 * On overflow we just repeat the standart close 		 * procedure...yes , this is waste of space but.. Then next 		 * read from device will fail if one would recall he is 		 * snooping and retry... 		 */
return|return
operator|(
name|snpdown
argument_list|(
name|snp
argument_list|)
operator|)
return|;
block|}
name|s_tail
operator|=
name|snp
operator|->
name|snp_blen
operator|-
operator|(
name|snp
operator|->
name|snp_len
operator|+
name|snp
operator|->
name|snp_base
operator|)
expr_stmt|;
name|s_free
operator|=
name|snp
operator|->
name|snp_blen
operator|-
name|snp
operator|->
name|snp_len
expr_stmt|;
if|if
condition|(
name|n
operator|>
name|s_free
condition|)
block|{
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
name|nblen
operator|=
name|snp
operator|->
name|snp_blen
expr_stmt|;
while|while
condition|(
operator|(
name|n
operator|>
name|s_free
operator|)
operator|&&
operator|(
operator|(
name|nblen
operator|*
literal|2
operator|)
operator|<=
name|SNOOP_MAXLEN
operator|)
condition|)
block|{
name|nblen
operator|=
name|snp
operator|->
name|snp_blen
operator|*
literal|2
expr_stmt|;
name|s_free
operator|=
name|nblen
operator|-
operator|(
name|snp
operator|->
name|snp_len
operator|+
name|snp
operator|->
name|snp_base
operator|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|n
operator|<=
name|s_free
operator|)
operator|&&
operator|(
name|nbuf
operator|=
name|malloc
argument_list|(
name|nblen
argument_list|,
name|M_TTYS
argument_list|,
name|M_NOWAIT
argument_list|)
operator|)
condition|)
block|{
name|bcopy
argument_list|(
name|snp
operator|->
name|snp_buf
operator|+
name|snp
operator|->
name|snp_base
argument_list|,
name|nbuf
argument_list|,
name|snp
operator|->
name|snp_len
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|snp
operator|->
name|snp_buf
argument_list|,
name|M_TTYS
argument_list|)
expr_stmt|;
name|snp
operator|->
name|snp_buf
operator|=
name|nbuf
expr_stmt|;
name|snp
operator|->
name|snp_blen
operator|=
name|nblen
expr_stmt|;
name|snp
operator|->
name|snp_base
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|snp
operator|->
name|snp_flags
operator||=
name|SNOOP_OFLOW
expr_stmt|;
if|if
condition|(
name|snp
operator|->
name|snp_flags
operator|&
name|SNOOP_RWAIT
condition|)
block|{
name|snp
operator|->
name|snp_flags
operator|&=
operator|~
name|SNOOP_RWAIT
expr_stmt|;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
name|snp
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|n
operator|>
name|s_tail
condition|)
block|{
name|from
operator|=
call|(
name|caddr_t
call|)
argument_list|(
name|snp
operator|->
name|snp_buf
operator|+
name|snp
operator|->
name|snp_base
argument_list|)
expr_stmt|;
name|to
operator|=
call|(
name|caddr_t
call|)
argument_list|(
name|snp
operator|->
name|snp_buf
argument_list|)
expr_stmt|;
name|len
operator|=
name|snp
operator|->
name|snp_len
expr_stmt|;
name|bcopy
argument_list|(
name|from
argument_list|,
name|to
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|snp
operator|->
name|snp_base
operator|=
literal|0
expr_stmt|;
block|}
name|to
operator|=
call|(
name|caddr_t
call|)
argument_list|(
name|snp
operator|->
name|snp_buf
operator|+
name|snp
operator|->
name|snp_base
operator|+
name|snp
operator|->
name|snp_len
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|buf
argument_list|,
name|to
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|snp
operator|->
name|snp_len
operator|+=
name|n
expr_stmt|;
if|if
condition|(
name|snp
operator|->
name|snp_flags
operator|&
name|SNOOP_RWAIT
condition|)
block|{
name|snp
operator|->
name|snp_flags
operator|&=
operator|~
name|SNOOP_RWAIT
expr_stmt|;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
name|snp
argument_list|)
expr_stmt|;
block|}
name|selwakeup
argument_list|(
operator|&
name|snp
operator|->
name|snp_sel
argument_list|)
expr_stmt|;
name|snp
operator|->
name|snp_sel
operator|.
name|si_pid
operator|=
literal|0
expr_stmt|;
return|return
name|n
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|snpopen
parameter_list|(
name|dev
parameter_list|,
name|flag
parameter_list|,
name|mode
parameter_list|,
name|p
parameter_list|)
name|dev_t
name|dev
decl_stmt|;
name|int
name|flag
decl_stmt|,
name|mode
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
block|{
name|struct
name|snoop
modifier|*
name|snp
decl_stmt|;
specifier|register
name|int
name|unit
decl_stmt|,
name|error
decl_stmt|;
if|if
condition|(
name|error
operator|=
name|suser
argument_list|(
name|p
operator|->
name|p_ucred
argument_list|,
operator|&
name|p
operator|->
name|p_acflag
argument_list|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
operator|(
name|unit
operator|=
name|minor
argument_list|(
name|dev
argument_list|)
operator|)
operator|>=
name|NSNP
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|snp
operator|=
operator|&
name|snoopsw
index|[
name|unit
index|]
expr_stmt|;
if|if
condition|(
name|snp
operator|->
name|snp_flags
operator|&
name|SNOOP_OPEN
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
comment|/* 	 * We intentionally do not OR flags with SNOOP_OPEN,but set them so 	 * all previous settings (especially SNOOP_OFLOW) will be cleared. 	 */
name|snp
operator|->
name|snp_flags
operator|=
name|SNOOP_OPEN
expr_stmt|;
name|snp
operator|->
name|snp_buf
operator|=
name|malloc
argument_list|(
name|SNOOP_MINLEN
argument_list|,
name|M_TTYS
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|snp
operator|->
name|snp_blen
operator|=
name|SNOOP_MINLEN
expr_stmt|;
name|snp
operator|->
name|snp_base
operator|=
literal|0
expr_stmt|;
name|snp
operator|->
name|snp_len
operator|=
literal|0
expr_stmt|;
comment|/* 	 * snp_tty == NULL  is for inactive snoop devices. 	 */
name|snp
operator|->
name|snp_tty
operator|=
name|NULL
expr_stmt|;
name|snp
operator|->
name|snp_target
operator|=
operator|-
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|snp_detach
parameter_list|(
name|snp
parameter_list|)
name|struct
name|snoop
modifier|*
name|snp
decl_stmt|;
block|{
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
name|snp
operator|->
name|snp_base
operator|=
literal|0
expr_stmt|;
name|snp
operator|->
name|snp_len
operator|=
literal|0
expr_stmt|;
comment|/* 	 * If line disc. changed we do not touch this pointer,SLIP/PPP will 	 * change it anyway. 	 */
if|if
condition|(
name|snp
operator|->
name|snp_tty
operator|==
name|NULL
condition|)
goto|goto
name|detach_notty
goto|;
name|tp
operator|=
name|snp
operator|->
name|snp_tty
expr_stmt|;
if|if
condition|(
name|tp
operator|&&
operator|(
name|tp
operator|->
name|t_sc
operator|==
name|snp
operator|)
operator|&&
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_SNOOP
operator|)
operator|&&
operator|(
name|tp
operator|->
name|t_line
operator|==
name|OTTYDISC
operator|||
name|tp
operator|->
name|t_line
operator|==
name|NTTYDISC
operator|)
condition|)
block|{
name|tp
operator|->
name|t_sc
operator|=
name|NULL
expr_stmt|;
name|tp
operator|->
name|t_state
operator|&=
operator|~
name|TS_SNOOP
expr_stmt|;
block|}
else|else
name|printf
argument_list|(
literal|"Snoop: bad attached tty data.\n"
argument_list|)
expr_stmt|;
name|snp
operator|->
name|snp_tty
operator|=
name|NULL
expr_stmt|;
name|snp
operator|->
name|snp_target
operator|=
operator|-
literal|1
expr_stmt|;
name|detach_notty
label|:
name|selwakeup
argument_list|(
operator|&
name|snp
operator|->
name|snp_sel
argument_list|)
expr_stmt|;
name|snp
operator|->
name|snp_sel
operator|.
name|si_pid
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|snpclose
parameter_list|(
name|dev
parameter_list|,
name|flags
parameter_list|,
name|fmt
parameter_list|,
name|p
parameter_list|)
name|dev_t
name|dev
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|int
name|fmt
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
block|{
specifier|register
name|int
name|unit
init|=
name|minor
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|snoop
modifier|*
name|snp
init|=
operator|&
name|snoopsw
index|[
name|unit
index|]
decl_stmt|;
name|snp
operator|->
name|snp_blen
operator|=
literal|0
expr_stmt|;
name|free
argument_list|(
name|snp
operator|->
name|snp_buf
argument_list|,
name|M_TTYS
argument_list|)
expr_stmt|;
name|snp
operator|->
name|snp_flags
operator|&=
operator|~
name|SNOOP_OPEN
expr_stmt|;
return|return
operator|(
name|snp_detach
argument_list|(
name|snp
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|snpdown
parameter_list|(
name|snp
parameter_list|)
name|struct
name|snoop
modifier|*
name|snp
decl_stmt|;
block|{
name|snp
operator|->
name|snp_blen
operator|=
name|SNOOP_MINLEN
expr_stmt|;
name|free
argument_list|(
name|snp
operator|->
name|snp_buf
argument_list|,
name|M_TTYS
argument_list|)
expr_stmt|;
name|snp
operator|->
name|snp_buf
operator|=
name|malloc
argument_list|(
name|SNOOP_MINLEN
argument_list|,
name|M_TTYS
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|snp
operator|->
name|snp_flags
operator||=
name|SNOOP_DOWN
expr_stmt|;
return|return
operator|(
name|snp_detach
argument_list|(
name|snp
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|snpioctl
parameter_list|(
name|dev
parameter_list|,
name|cmd
parameter_list|,
name|data
parameter_list|,
name|flags
parameter_list|,
name|p
parameter_list|)
name|dev_t
name|dev
decl_stmt|;
name|int
name|cmd
decl_stmt|;
name|caddr_t
name|data
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
block|{
name|int
name|unit
init|=
name|minor
argument_list|(
name|dev
argument_list|)
decl_stmt|,
name|s
decl_stmt|;
name|dev_t
name|tdev
decl_stmt|;
name|struct
name|snoop
modifier|*
name|snp
init|=
operator|&
name|snoopsw
index|[
name|unit
index|]
decl_stmt|;
name|struct
name|tty
modifier|*
name|tp
decl_stmt|,
modifier|*
name|tpo
decl_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|SNPSTTY
case|:
name|tdev
operator|=
operator|*
operator|(
operator|(
name|dev_t
operator|*
operator|)
name|data
operator|)
expr_stmt|;
if|if
condition|(
name|tdev
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
name|snpdown
argument_list|(
name|snp
argument_list|)
operator|)
return|;
name|tp
operator|=
name|snpdevtotty
argument_list|(
name|tdev
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tp
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
operator|(
name|tp
operator|->
name|t_sc
operator|!=
operator|(
name|caddr_t
operator|)
name|snp
operator|)
operator|&&
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_SNOOP
operator|)
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
if|if
condition|(
operator|(
name|tp
operator|->
name|t_line
operator|!=
name|OTTYDISC
operator|)
operator|&&
operator|(
name|tp
operator|->
name|t_line
operator|!=
name|NTTYDISC
operator|)
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
if|if
condition|(
name|snp
operator|->
name|snp_target
operator|==
operator|-
literal|1
condition|)
block|{
name|tpo
operator|=
name|snp
operator|->
name|snp_tty
expr_stmt|;
if|if
condition|(
name|tpo
condition|)
name|tpo
operator|->
name|t_state
operator|&=
operator|~
name|TS_SNOOP
expr_stmt|;
block|}
name|tp
operator|->
name|t_sc
operator|=
operator|(
name|caddr_t
operator|)
name|snp
expr_stmt|;
name|tp
operator|->
name|t_state
operator||=
name|TS_SNOOP
expr_stmt|;
name|snp
operator|->
name|snp_tty
operator|=
name|tp
expr_stmt|;
name|snp
operator|->
name|snp_target
operator|=
name|tdev
expr_stmt|;
comment|/* 		 * Clean overflow and down flags - 		 * we'll have a chance to get them in the future :))) 		 */
name|snp
operator|->
name|snp_flags
operator|&=
operator|~
name|SNOOP_OFLOW
expr_stmt|;
name|snp
operator|->
name|snp_flags
operator|&=
operator|~
name|SNOOP_DOWN
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
break|break;
case|case
name|SNPGTTY
case|:
comment|/* 		 * We keep snp_target field specially to make 		 * SNPGTTY happy,else we can't know what is device 		 * major/minor for tty. 		 */
operator|*
operator|(
operator|(
name|dev_t
operator|*
operator|)
name|data
operator|)
operator|=
name|snp
operator|->
name|snp_target
expr_stmt|;
break|break;
case|case
name|FIONBIO
case|:
if|if
condition|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
condition|)
name|snp
operator|->
name|snp_flags
operator||=
name|SNOOP_NBIO
expr_stmt|;
else|else
name|snp
operator|->
name|snp_flags
operator|&=
operator|~
name|SNOOP_NBIO
expr_stmt|;
break|break;
case|case
name|FIOASYNC
case|:
if|if
condition|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
condition|)
name|snp
operator|->
name|snp_flags
operator||=
name|SNOOP_ASYNC
expr_stmt|;
else|else
name|snp
operator|->
name|snp_flags
operator|&=
operator|~
name|SNOOP_ASYNC
expr_stmt|;
break|break;
case|case
name|FIONREAD
case|:
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
if|if
condition|(
name|snp
operator|->
name|snp_tty
operator|!=
name|NULL
condition|)
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|snp
operator|->
name|snp_len
expr_stmt|;
elseif|else
if|if
condition|(
name|snp
operator|->
name|snp_flags
operator|&
name|SNOOP_DOWN
condition|)
block|{
if|if
condition|(
name|snp
operator|->
name|snp_flags
operator|&
name|SNOOP_OFLOW
condition|)
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|SNP_OFLOW
expr_stmt|;
else|else
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|SNP_TTYCLOSE
expr_stmt|;
block|}
else|else
block|{
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|SNP_DETACH
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|ENOTTY
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|snppoll
parameter_list|(
name|dev
parameter_list|,
name|events
parameter_list|,
name|p
parameter_list|)
name|dev_t
name|dev
decl_stmt|;
name|int
name|events
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
block|{
name|int
name|unit
init|=
name|minor
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|snoop
modifier|*
name|snp
init|=
operator|&
name|snoopsw
index|[
name|unit
index|]
decl_stmt|;
name|int
name|revents
init|=
literal|0
decl_stmt|;
comment|/* 	 * If snoop is down,we don't want to poll() forever so we return 1. 	 * Caller should see if we down via FIONREAD ioctl().The last should 	 * return -1 to indicate down state. 	 */
if|if
condition|(
name|events
operator|&
operator|(
name|POLLIN
operator||
name|POLLRDNORM
operator|)
condition|)
if|if
condition|(
name|snp
operator|->
name|snp_flags
operator|&
name|SNOOP_DOWN
operator|||
name|snp
operator|->
name|snp_len
operator|>
literal|0
condition|)
name|revents
operator||=
name|events
operator|&
operator|(
name|POLLIN
operator||
name|POLLRDNORM
operator|)
expr_stmt|;
else|else
name|selrecord
argument_list|(
name|p
argument_list|,
operator|&
name|snp
operator|->
name|snp_sel
argument_list|)
expr_stmt|;
return|return
operator|(
name|revents
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|DEVFS
end_ifdef

begin_decl_stmt
specifier|static
name|void
modifier|*
name|snp_devfs_token
index|[
name|NSNP
index|]
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_expr_stmt
specifier|static
name|snp_devsw_installed
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|void
name|snp_drvinit
name|__P
argument_list|(
operator|(
name|void
operator|*
name|unused
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|snp_drvinit
parameter_list|(
name|unused
parameter_list|)
name|void
modifier|*
name|unused
decl_stmt|;
block|{
name|dev_t
name|dev
decl_stmt|;
ifdef|#
directive|ifdef
name|DEVFS
name|int
name|i
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|snp_devsw_installed
condition|)
block|{
name|dev
operator|=
name|makedev
argument_list|(
name|CDEV_MAJOR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cdevsw_add
argument_list|(
operator|&
name|dev
argument_list|,
operator|&
name|snp_cdevsw
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|snp_devsw_installed
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|DEVFS
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NSNP
condition|;
name|i
operator|++
control|)
block|{
name|snp_devfs_token
index|[
name|i
index|]
operator|=
name|devfs_add_devswf
argument_list|(
operator|&
name|snp_cdevsw
argument_list|,
name|i
argument_list|,
name|DV_CHR
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0600
argument_list|,
literal|"snp%d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
block|}
end_function

begin_macro
name|SYSINIT
argument_list|(
argument|snpdev
argument_list|,
argument|SI_SUB_DRIVERS
argument_list|,
argument|SI_ORDER_MIDDLE+CDEV_MAJOR
argument_list|,
argument|snp_drvinit
argument_list|,
argument|NULL
argument_list|)
end_macro

begin_endif
endif|#
directive|endif
end_endif

end_unit

