begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2008 Yahoo!, Inc.  * All rights reserved.  * Written by: John Baldwin<jhb@FreeBSD.org>  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. Neither the name of the author nor the names of any co-contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/bio.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/sglist.h>
end_include

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_page.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_map.h>
end_include

begin_include
include|#
directive|include
file|<sys/ktr.h>
end_include

begin_expr_stmt
specifier|static
name|MALLOC_DEFINE
argument_list|(
name|M_SGLIST
argument_list|,
literal|"sglist"
argument_list|,
literal|"scatter/gather lists"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Convenience macros to save the state of an sglist so it can be restored  * if an append attempt fails.  Since sglist's only grow we only need to  * save the current count of segments and the length of the ending segment.  * Earlier segments will not be changed by an append, and the only change  * that can occur to the ending segment is that it can be extended.  */
end_comment

begin_struct
struct|struct
name|sgsave
block|{
name|u_short
name|sg_nseg
decl_stmt|;
name|size_t
name|ss_len
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|SGLIST_SAVE
parameter_list|(
name|sg
parameter_list|,
name|sgsave
parameter_list|)
value|do {					\ 	(sgsave).sg_nseg = (sg)->sg_nseg;				\ 	if ((sgsave).sg_nseg> 0)					\ 		(sgsave).ss_len = (sg)->sg_segs[(sgsave).sg_nseg - 1].ss_len; \ 	else								\ 		(sgsave).ss_len = 0;					\ } while (0)
end_define

begin_define
define|#
directive|define
name|SGLIST_RESTORE
parameter_list|(
name|sg
parameter_list|,
name|sgsave
parameter_list|)
value|do {					\ 	(sg)->sg_nseg = (sgsave).sg_nseg;				\ 	if ((sgsave).sg_nseg> 0)					\ 		(sg)->sg_segs[(sgsave).sg_nseg - 1].ss_len = (sgsave).ss_len; \ } while (0)
end_define

begin_comment
comment|/*  * Append a single (paddr, len) to a sglist.  sg is the list and ss is  * the current segment in the list.  If we run out of segments then  * EFBIG will be returned.  */
end_comment

begin_function
specifier|static
name|__inline
name|int
name|_sglist_append_range
parameter_list|(
name|struct
name|sglist
modifier|*
name|sg
parameter_list|,
name|struct
name|sglist_seg
modifier|*
modifier|*
name|ssp
parameter_list|,
name|vm_paddr_t
name|paddr
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|struct
name|sglist_seg
modifier|*
name|ss
decl_stmt|;
name|ss
operator|=
operator|*
name|ssp
expr_stmt|;
if|if
condition|(
name|ss
operator|->
name|ss_paddr
operator|+
name|ss
operator|->
name|ss_len
operator|==
name|paddr
condition|)
name|ss
operator|->
name|ss_len
operator|+=
name|len
expr_stmt|;
else|else
block|{
if|if
condition|(
name|sg
operator|->
name|sg_nseg
operator|==
name|sg
operator|->
name|sg_maxseg
condition|)
return|return
operator|(
name|EFBIG
operator|)
return|;
name|ss
operator|++
expr_stmt|;
name|ss
operator|->
name|ss_paddr
operator|=
name|paddr
expr_stmt|;
name|ss
operator|->
name|ss_len
operator|=
name|len
expr_stmt|;
name|sg
operator|->
name|sg_nseg
operator|++
expr_stmt|;
operator|*
name|ssp
operator|=
name|ss
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Worker routine to append a virtual address range (either kernel or  * user) to a scatter/gather list.  */
end_comment

begin_function
specifier|static
name|__inline
name|int
name|_sglist_append_buf
parameter_list|(
name|struct
name|sglist
modifier|*
name|sg
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|,
name|pmap_t
name|pmap
parameter_list|,
name|size_t
modifier|*
name|donep
parameter_list|)
block|{
name|struct
name|sglist_seg
modifier|*
name|ss
decl_stmt|;
name|vm_offset_t
name|vaddr
decl_stmt|,
name|offset
decl_stmt|;
name|vm_paddr_t
name|paddr
decl_stmt|;
name|size_t
name|seglen
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|donep
condition|)
operator|*
name|donep
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Do the first page.  It may have an offset. */
name|vaddr
operator|=
operator|(
name|vm_offset_t
operator|)
name|buf
expr_stmt|;
name|offset
operator|=
name|vaddr
operator|&
name|PAGE_MASK
expr_stmt|;
if|if
condition|(
name|pmap
operator|!=
name|NULL
condition|)
name|paddr
operator|=
name|pmap_extract
argument_list|(
name|pmap
argument_list|,
name|vaddr
argument_list|)
expr_stmt|;
else|else
name|paddr
operator|=
name|pmap_kextract
argument_list|(
name|vaddr
argument_list|)
expr_stmt|;
name|seglen
operator|=
name|MIN
argument_list|(
name|len
argument_list|,
name|PAGE_SIZE
operator|-
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|sg
operator|->
name|sg_nseg
operator|==
literal|0
condition|)
block|{
name|ss
operator|=
name|sg
operator|->
name|sg_segs
expr_stmt|;
name|ss
operator|->
name|ss_paddr
operator|=
name|paddr
expr_stmt|;
name|ss
operator|->
name|ss_len
operator|=
name|seglen
expr_stmt|;
name|sg
operator|->
name|sg_nseg
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|ss
operator|=
operator|&
name|sg
operator|->
name|sg_segs
index|[
name|sg
operator|->
name|sg_nseg
operator|-
literal|1
index|]
expr_stmt|;
name|error
operator|=
name|_sglist_append_range
argument_list|(
name|sg
argument_list|,
operator|&
name|ss
argument_list|,
name|paddr
argument_list|,
name|seglen
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
name|vaddr
operator|+=
name|seglen
expr_stmt|;
name|len
operator|-=
name|seglen
expr_stmt|;
if|if
condition|(
name|donep
condition|)
operator|*
name|donep
operator|+=
name|seglen
expr_stmt|;
while|while
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|seglen
operator|=
name|MIN
argument_list|(
name|len
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|pmap
operator|!=
name|NULL
condition|)
name|paddr
operator|=
name|pmap_extract
argument_list|(
name|pmap
argument_list|,
name|vaddr
argument_list|)
expr_stmt|;
else|else
name|paddr
operator|=
name|pmap_kextract
argument_list|(
name|vaddr
argument_list|)
expr_stmt|;
name|error
operator|=
name|_sglist_append_range
argument_list|(
name|sg
argument_list|,
operator|&
name|ss
argument_list|,
name|paddr
argument_list|,
name|seglen
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|vaddr
operator|+=
name|seglen
expr_stmt|;
name|len
operator|-=
name|seglen
expr_stmt|;
if|if
condition|(
name|donep
condition|)
operator|*
name|donep
operator|+=
name|seglen
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Determine the number of scatter/gather list elements needed to  * describe a kernel virtual address range.  */
end_comment

begin_function
name|int
name|sglist_count
parameter_list|(
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|vm_offset_t
name|vaddr
decl_stmt|,
name|vendaddr
decl_stmt|;
name|vm_paddr_t
name|lastaddr
decl_stmt|,
name|paddr
decl_stmt|;
name|int
name|nsegs
decl_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|vaddr
operator|=
name|trunc_page
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|buf
argument_list|)
expr_stmt|;
name|vendaddr
operator|=
operator|(
name|vm_offset_t
operator|)
name|buf
operator|+
name|len
expr_stmt|;
name|nsegs
operator|=
literal|1
expr_stmt|;
name|lastaddr
operator|=
name|pmap_kextract
argument_list|(
name|vaddr
argument_list|)
expr_stmt|;
name|vaddr
operator|+=
name|PAGE_SIZE
expr_stmt|;
while|while
condition|(
name|vaddr
operator|<
name|vendaddr
condition|)
block|{
name|paddr
operator|=
name|pmap_kextract
argument_list|(
name|vaddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|lastaddr
operator|+
name|PAGE_SIZE
operator|!=
name|paddr
condition|)
name|nsegs
operator|++
expr_stmt|;
name|lastaddr
operator|=
name|paddr
expr_stmt|;
name|vaddr
operator|+=
name|PAGE_SIZE
expr_stmt|;
block|}
return|return
operator|(
name|nsegs
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Determine the number of scatter/gather list elements needed to  * describe a buffer backed by an array of VM pages.  */
end_comment

begin_function
name|int
name|sglist_count_vmpages
parameter_list|(
name|vm_page_t
modifier|*
name|m
parameter_list|,
name|size_t
name|pgoff
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|vm_paddr_t
name|lastaddr
decl_stmt|,
name|paddr
decl_stmt|;
name|int
name|i
decl_stmt|,
name|nsegs
decl_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|len
operator|+=
name|pgoff
expr_stmt|;
name|nsegs
operator|=
literal|1
expr_stmt|;
name|lastaddr
operator|=
name|VM_PAGE_TO_PHYS
argument_list|(
name|m
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|len
operator|>
name|PAGE_SIZE
condition|;
name|len
operator|-=
name|PAGE_SIZE
operator|,
name|i
operator|++
control|)
block|{
name|paddr
operator|=
name|VM_PAGE_TO_PHYS
argument_list|(
name|m
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|lastaddr
operator|+
name|PAGE_SIZE
operator|!=
name|paddr
condition|)
name|nsegs
operator|++
expr_stmt|;
name|lastaddr
operator|=
name|paddr
expr_stmt|;
block|}
return|return
operator|(
name|nsegs
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Allocate a scatter/gather list along with 'nsegs' segments.  The  * 'mflags' parameters are the same as passed to malloc(9).  The caller  * should use sglist_free() to free this list.  */
end_comment

begin_function
name|struct
name|sglist
modifier|*
name|sglist_alloc
parameter_list|(
name|int
name|nsegs
parameter_list|,
name|int
name|mflags
parameter_list|)
block|{
name|struct
name|sglist
modifier|*
name|sg
decl_stmt|;
name|sg
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sglist
argument_list|)
operator|+
name|nsegs
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|sglist_seg
argument_list|)
argument_list|,
name|M_SGLIST
argument_list|,
name|mflags
argument_list|)
expr_stmt|;
if|if
condition|(
name|sg
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|sglist_init
argument_list|(
name|sg
argument_list|,
name|nsegs
argument_list|,
operator|(
expr|struct
name|sglist_seg
operator|*
operator|)
operator|(
name|sg
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|sg
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Free a scatter/gather list allocated via sglist_allc().  */
end_comment

begin_function
name|void
name|sglist_free
parameter_list|(
name|struct
name|sglist
modifier|*
name|sg
parameter_list|)
block|{
if|if
condition|(
name|sg
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|refcount_release
argument_list|(
operator|&
name|sg
operator|->
name|sg_refs
argument_list|)
condition|)
name|free
argument_list|(
name|sg
argument_list|,
name|M_SGLIST
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Append the segments to describe a single kernel virtual address  * range to a scatter/gather list.  If there are insufficient  * segments, then this fails with EFBIG.  */
end_comment

begin_function
name|int
name|sglist_append
parameter_list|(
name|struct
name|sglist
modifier|*
name|sg
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|struct
name|sgsave
name|save
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|sg
operator|->
name|sg_maxseg
operator|==
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|SGLIST_SAVE
argument_list|(
name|sg
argument_list|,
name|save
argument_list|)
expr_stmt|;
name|error
operator|=
name|_sglist_append_buf
argument_list|(
name|sg
argument_list|,
name|buf
argument_list|,
name|len
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|SGLIST_RESTORE
argument_list|(
name|sg
argument_list|,
name|save
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Append the segments to describe a bio's data to a scatter/gather list.  * If there are insufficient segments, then this fails with EFBIG.  *  * NOTE: This function expects bio_bcount to be initialized.  */
end_comment

begin_function
name|int
name|sglist_append_bio
parameter_list|(
name|struct
name|sglist
modifier|*
name|sg
parameter_list|,
name|struct
name|bio
modifier|*
name|bp
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
if|if
condition|(
operator|(
name|bp
operator|->
name|bio_flags
operator|&
name|BIO_UNMAPPED
operator|)
operator|==
literal|0
condition|)
name|error
operator|=
name|sglist_append
argument_list|(
name|sg
argument_list|,
name|bp
operator|->
name|bio_data
argument_list|,
name|bp
operator|->
name|bio_bcount
argument_list|)
expr_stmt|;
else|else
name|error
operator|=
name|sglist_append_vmpages
argument_list|(
name|sg
argument_list|,
name|bp
operator|->
name|bio_ma
argument_list|,
name|bp
operator|->
name|bio_ma_offset
argument_list|,
name|bp
operator|->
name|bio_bcount
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Append a single physical address range to a scatter/gather list.  * If there are insufficient segments, then this fails with EFBIG.  */
end_comment

begin_function
name|int
name|sglist_append_phys
parameter_list|(
name|struct
name|sglist
modifier|*
name|sg
parameter_list|,
name|vm_paddr_t
name|paddr
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|struct
name|sglist_seg
modifier|*
name|ss
decl_stmt|;
name|struct
name|sgsave
name|save
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|sg
operator|->
name|sg_maxseg
operator|==
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|sg
operator|->
name|sg_nseg
operator|==
literal|0
condition|)
block|{
name|sg
operator|->
name|sg_segs
index|[
literal|0
index|]
operator|.
name|ss_paddr
operator|=
name|paddr
expr_stmt|;
name|sg
operator|->
name|sg_segs
index|[
literal|0
index|]
operator|.
name|ss_len
operator|=
name|len
expr_stmt|;
name|sg
operator|->
name|sg_nseg
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|ss
operator|=
operator|&
name|sg
operator|->
name|sg_segs
index|[
name|sg
operator|->
name|sg_nseg
operator|-
literal|1
index|]
expr_stmt|;
name|SGLIST_SAVE
argument_list|(
name|sg
argument_list|,
name|save
argument_list|)
expr_stmt|;
name|error
operator|=
name|_sglist_append_range
argument_list|(
name|sg
argument_list|,
operator|&
name|ss
argument_list|,
name|paddr
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|SGLIST_RESTORE
argument_list|(
name|sg
argument_list|,
name|save
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Append the segments that describe a single mbuf chain to a  * scatter/gather list.  If there are insufficient segments, then this  * fails with EFBIG.  */
end_comment

begin_function
name|int
name|sglist_append_mbuf
parameter_list|(
name|struct
name|sglist
modifier|*
name|sg
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m0
parameter_list|)
block|{
name|struct
name|sgsave
name|save
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|sg
operator|->
name|sg_maxseg
operator|==
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|error
operator|=
literal|0
expr_stmt|;
name|SGLIST_SAVE
argument_list|(
name|sg
argument_list|,
name|save
argument_list|)
expr_stmt|;
for|for
control|(
name|m
operator|=
name|m0
init|;
name|m
operator|!=
name|NULL
condition|;
name|m
operator|=
name|m
operator|->
name|m_next
control|)
block|{
if|if
condition|(
name|m
operator|->
name|m_len
operator|>
literal|0
condition|)
block|{
name|error
operator|=
name|sglist_append
argument_list|(
name|sg
argument_list|,
name|m
operator|->
name|m_data
argument_list|,
name|m
operator|->
name|m_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|SGLIST_RESTORE
argument_list|(
name|sg
argument_list|,
name|save
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Append the segments that describe a buffer spanning an array of VM  * pages.  The buffer begins at an offset of 'pgoff' in the first  * page.  */
end_comment

begin_function
name|int
name|sglist_append_vmpages
parameter_list|(
name|struct
name|sglist
modifier|*
name|sg
parameter_list|,
name|vm_page_t
modifier|*
name|m
parameter_list|,
name|size_t
name|pgoff
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|struct
name|sgsave
name|save
decl_stmt|;
name|struct
name|sglist_seg
modifier|*
name|ss
decl_stmt|;
name|vm_paddr_t
name|paddr
decl_stmt|;
name|size_t
name|seglen
decl_stmt|;
name|int
name|error
decl_stmt|,
name|i
decl_stmt|;
if|if
condition|(
name|sg
operator|->
name|sg_maxseg
operator|==
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|SGLIST_SAVE
argument_list|(
name|sg
argument_list|,
name|save
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sg
operator|->
name|sg_nseg
operator|==
literal|0
condition|)
block|{
name|seglen
operator|=
name|min
argument_list|(
name|PAGE_SIZE
operator|-
name|pgoff
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|sg
operator|->
name|sg_segs
index|[
literal|0
index|]
operator|.
name|ss_paddr
operator|=
name|VM_PAGE_TO_PHYS
argument_list|(
name|m
index|[
literal|0
index|]
argument_list|)
operator|+
name|pgoff
expr_stmt|;
name|sg
operator|->
name|sg_segs
index|[
literal|0
index|]
operator|.
name|ss_len
operator|=
name|seglen
expr_stmt|;
name|sg
operator|->
name|sg_nseg
operator|=
literal|1
expr_stmt|;
name|pgoff
operator|=
literal|0
expr_stmt|;
name|len
operator|-=
name|seglen
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
name|ss
operator|=
operator|&
name|sg
operator|->
name|sg_segs
index|[
name|sg
operator|->
name|sg_nseg
operator|-
literal|1
index|]
expr_stmt|;
for|for
control|(
init|;
name|len
operator|>
literal|0
condition|;
name|i
operator|++
operator|,
name|len
operator|-=
name|seglen
control|)
block|{
name|seglen
operator|=
name|min
argument_list|(
name|PAGE_SIZE
operator|-
name|pgoff
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|paddr
operator|=
name|VM_PAGE_TO_PHYS
argument_list|(
name|m
index|[
name|i
index|]
argument_list|)
operator|+
name|pgoff
expr_stmt|;
name|error
operator|=
name|_sglist_append_range
argument_list|(
name|sg
argument_list|,
operator|&
name|ss
argument_list|,
name|paddr
argument_list|,
name|seglen
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|SGLIST_RESTORE
argument_list|(
name|sg
argument_list|,
name|save
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|pgoff
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Append the segments that describe a single user address range to a  * scatter/gather list.  If there are insufficient segments, then this  * fails with EFBIG.  */
end_comment

begin_function
name|int
name|sglist_append_user
parameter_list|(
name|struct
name|sglist
modifier|*
name|sg
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|sgsave
name|save
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|sg
operator|->
name|sg_maxseg
operator|==
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|SGLIST_SAVE
argument_list|(
name|sg
argument_list|,
name|save
argument_list|)
expr_stmt|;
name|error
operator|=
name|_sglist_append_buf
argument_list|(
name|sg
argument_list|,
name|buf
argument_list|,
name|len
argument_list|,
name|vmspace_pmap
argument_list|(
name|td
operator|->
name|td_proc
operator|->
name|p_vmspace
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|SGLIST_RESTORE
argument_list|(
name|sg
argument_list|,
name|save
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Append a subset of an existing scatter/gather list 'source' to a  * the scatter/gather list 'sg'.  If there are insufficient segments,  * then this fails with EFBIG.  */
end_comment

begin_function
name|int
name|sglist_append_sglist
parameter_list|(
name|struct
name|sglist
modifier|*
name|sg
parameter_list|,
name|struct
name|sglist
modifier|*
name|source
parameter_list|,
name|size_t
name|offset
parameter_list|,
name|size_t
name|length
parameter_list|)
block|{
name|struct
name|sgsave
name|save
decl_stmt|;
name|struct
name|sglist_seg
modifier|*
name|ss
decl_stmt|;
name|size_t
name|seglen
decl_stmt|;
name|int
name|error
decl_stmt|,
name|i
decl_stmt|;
if|if
condition|(
name|sg
operator|->
name|sg_maxseg
operator|==
literal|0
operator|||
name|length
operator|==
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|SGLIST_SAVE
argument_list|(
name|sg
argument_list|,
name|save
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
name|ss
operator|=
operator|&
name|sg
operator|->
name|sg_segs
index|[
name|sg
operator|->
name|sg_nseg
operator|-
literal|1
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|source
operator|->
name|sg_nseg
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|offset
operator|>=
name|source
operator|->
name|sg_segs
index|[
name|i
index|]
operator|.
name|ss_len
condition|)
block|{
name|offset
operator|-=
name|source
operator|->
name|sg_segs
index|[
name|i
index|]
operator|.
name|ss_len
expr_stmt|;
continue|continue;
block|}
name|seglen
operator|=
name|source
operator|->
name|sg_segs
index|[
name|i
index|]
operator|.
name|ss_len
operator|-
name|offset
expr_stmt|;
if|if
condition|(
name|seglen
operator|>
name|length
condition|)
name|seglen
operator|=
name|length
expr_stmt|;
name|error
operator|=
name|_sglist_append_range
argument_list|(
name|sg
argument_list|,
operator|&
name|ss
argument_list|,
name|source
operator|->
name|sg_segs
index|[
name|i
index|]
operator|.
name|ss_paddr
operator|+
name|offset
argument_list|,
name|seglen
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
name|offset
operator|=
literal|0
expr_stmt|;
name|length
operator|-=
name|seglen
expr_stmt|;
if|if
condition|(
name|length
operator|==
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|length
operator|!=
literal|0
condition|)
name|error
operator|=
name|EINVAL
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|SGLIST_RESTORE
argument_list|(
name|sg
argument_list|,
name|save
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Append the segments that describe a single uio to a scatter/gather  * list.  If there are insufficient segments, then this fails with  * EFBIG.  */
end_comment

begin_function
name|int
name|sglist_append_uio
parameter_list|(
name|struct
name|sglist
modifier|*
name|sg
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|)
block|{
name|struct
name|iovec
modifier|*
name|iov
decl_stmt|;
name|struct
name|sgsave
name|save
decl_stmt|;
name|size_t
name|resid
decl_stmt|,
name|minlen
decl_stmt|;
name|pmap_t
name|pmap
decl_stmt|;
name|int
name|error
decl_stmt|,
name|i
decl_stmt|;
if|if
condition|(
name|sg
operator|->
name|sg_maxseg
operator|==
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|resid
operator|=
name|uio
operator|->
name|uio_resid
expr_stmt|;
name|iov
operator|=
name|uio
operator|->
name|uio_iov
expr_stmt|;
if|if
condition|(
name|uio
operator|->
name|uio_segflg
operator|==
name|UIO_USERSPACE
condition|)
block|{
name|KASSERT
argument_list|(
name|uio
operator|->
name|uio_td
operator|!=
name|NULL
argument_list|,
operator|(
literal|"sglist_append_uio: USERSPACE but no thread"
operator|)
argument_list|)
expr_stmt|;
name|pmap
operator|=
name|vmspace_pmap
argument_list|(
name|uio
operator|->
name|uio_td
operator|->
name|td_proc
operator|->
name|p_vmspace
argument_list|)
expr_stmt|;
block|}
else|else
name|pmap
operator|=
name|NULL
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|SGLIST_SAVE
argument_list|(
name|sg
argument_list|,
name|save
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|uio
operator|->
name|uio_iovcnt
operator|&&
name|resid
operator|!=
literal|0
condition|;
name|i
operator|++
control|)
block|{
comment|/* 		 * Now at the first iovec to load.  Load each iovec 		 * until we have exhausted the residual count. 		 */
name|minlen
operator|=
name|MIN
argument_list|(
name|resid
argument_list|,
name|iov
index|[
name|i
index|]
operator|.
name|iov_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|minlen
operator|>
literal|0
condition|)
block|{
name|error
operator|=
name|_sglist_append_buf
argument_list|(
name|sg
argument_list|,
name|iov
index|[
name|i
index|]
operator|.
name|iov_base
argument_list|,
name|minlen
argument_list|,
name|pmap
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|SGLIST_RESTORE
argument_list|(
name|sg
argument_list|,
name|save
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|resid
operator|-=
name|minlen
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Append the segments that describe at most 'resid' bytes from a  * single uio to a scatter/gather list.  If there are insufficient  * segments, then only the amount that fits is appended.  */
end_comment

begin_function
name|int
name|sglist_consume_uio
parameter_list|(
name|struct
name|sglist
modifier|*
name|sg
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|,
name|size_t
name|resid
parameter_list|)
block|{
name|struct
name|iovec
modifier|*
name|iov
decl_stmt|;
name|size_t
name|done
decl_stmt|;
name|pmap_t
name|pmap
decl_stmt|;
name|int
name|error
decl_stmt|,
name|len
decl_stmt|;
if|if
condition|(
name|sg
operator|->
name|sg_maxseg
operator|==
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|uio
operator|->
name|uio_segflg
operator|==
name|UIO_USERSPACE
condition|)
block|{
name|KASSERT
argument_list|(
name|uio
operator|->
name|uio_td
operator|!=
name|NULL
argument_list|,
operator|(
literal|"sglist_consume_uio: USERSPACE but no thread"
operator|)
argument_list|)
expr_stmt|;
name|pmap
operator|=
name|vmspace_pmap
argument_list|(
name|uio
operator|->
name|uio_td
operator|->
name|td_proc
operator|->
name|p_vmspace
argument_list|)
expr_stmt|;
block|}
else|else
name|pmap
operator|=
name|NULL
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|resid
operator|>
literal|0
operator|&&
name|uio
operator|->
name|uio_resid
condition|)
block|{
name|iov
operator|=
name|uio
operator|->
name|uio_iov
expr_stmt|;
name|len
operator|=
name|iov
operator|->
name|iov_len
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
block|{
name|uio
operator|->
name|uio_iov
operator|++
expr_stmt|;
name|uio
operator|->
name|uio_iovcnt
operator|--
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|len
operator|>
name|resid
condition|)
name|len
operator|=
name|resid
expr_stmt|;
comment|/* 		 * Try to append this iovec.  If we run out of room, 		 * then break out of the loop. 		 */
name|error
operator|=
name|_sglist_append_buf
argument_list|(
name|sg
argument_list|,
name|iov
operator|->
name|iov_base
argument_list|,
name|len
argument_list|,
name|pmap
argument_list|,
operator|&
name|done
argument_list|)
expr_stmt|;
name|iov
operator|->
name|iov_base
operator|=
operator|(
name|char
operator|*
operator|)
name|iov
operator|->
name|iov_base
operator|+
name|done
expr_stmt|;
name|iov
operator|->
name|iov_len
operator|-=
name|done
expr_stmt|;
name|uio
operator|->
name|uio_resid
operator|-=
name|done
expr_stmt|;
name|uio
operator|->
name|uio_offset
operator|+=
name|done
expr_stmt|;
name|resid
operator|-=
name|done
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Allocate and populate a scatter/gather list to describe a single  * kernel virtual address range.  */
end_comment

begin_function
name|struct
name|sglist
modifier|*
name|sglist_build
parameter_list|(
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|,
name|int
name|mflags
parameter_list|)
block|{
name|struct
name|sglist
modifier|*
name|sg
decl_stmt|;
name|int
name|nsegs
decl_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|nsegs
operator|=
name|sglist_count
argument_list|(
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|sg
operator|=
name|sglist_alloc
argument_list|(
name|nsegs
argument_list|,
name|mflags
argument_list|)
expr_stmt|;
if|if
condition|(
name|sg
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
name|sglist_append
argument_list|(
name|sg
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|sglist_free
argument_list|(
name|sg
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
return|return
operator|(
name|sg
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Clone a new copy of a scatter/gather list.  */
end_comment

begin_function
name|struct
name|sglist
modifier|*
name|sglist_clone
parameter_list|(
name|struct
name|sglist
modifier|*
name|sg
parameter_list|,
name|int
name|mflags
parameter_list|)
block|{
name|struct
name|sglist
modifier|*
name|new
decl_stmt|;
if|if
condition|(
name|sg
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|new
operator|=
name|sglist_alloc
argument_list|(
name|sg
operator|->
name|sg_maxseg
argument_list|,
name|mflags
argument_list|)
expr_stmt|;
if|if
condition|(
name|new
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|new
operator|->
name|sg_nseg
operator|=
name|sg
operator|->
name|sg_nseg
expr_stmt|;
name|bcopy
argument_list|(
name|sg
operator|->
name|sg_segs
argument_list|,
name|new
operator|->
name|sg_segs
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sglist_seg
argument_list|)
operator|*
name|sg
operator|->
name|sg_nseg
argument_list|)
expr_stmt|;
return|return
operator|(
name|new
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Calculate the total length of the segments described in a  * scatter/gather list.  */
end_comment

begin_function
name|size_t
name|sglist_length
parameter_list|(
name|struct
name|sglist
modifier|*
name|sg
parameter_list|)
block|{
name|size_t
name|space
decl_stmt|;
name|int
name|i
decl_stmt|;
name|space
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sg
operator|->
name|sg_nseg
condition|;
name|i
operator|++
control|)
name|space
operator|+=
name|sg
operator|->
name|sg_segs
index|[
name|i
index|]
operator|.
name|ss_len
expr_stmt|;
return|return
operator|(
name|space
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Split a scatter/gather list into two lists.  The scatter/gather  * entries for the first 'length' bytes of the 'original' list are  * stored in the '*head' list and are removed from 'original'.  *  * If '*head' is NULL, then a new list will be allocated using  * 'mflags'.  If M_NOWAIT is specified and the allocation fails,  * ENOMEM will be returned.  *  * If '*head' is not NULL, it should point to an empty sglist.  If it  * does not have enough room for the remaining space, then EFBIG will  * be returned.  If '*head' is not empty, then EINVAL will be  * returned.  *  * If 'original' is shared (refcount> 1), then EDOOFUS will be  * returned.  */
end_comment

begin_function
name|int
name|sglist_split
parameter_list|(
name|struct
name|sglist
modifier|*
name|original
parameter_list|,
name|struct
name|sglist
modifier|*
modifier|*
name|head
parameter_list|,
name|size_t
name|length
parameter_list|,
name|int
name|mflags
parameter_list|)
block|{
name|struct
name|sglist
modifier|*
name|sg
decl_stmt|;
name|size_t
name|space
decl_stmt|,
name|split
decl_stmt|;
name|int
name|count
decl_stmt|,
name|i
decl_stmt|;
if|if
condition|(
name|original
operator|->
name|sg_refs
operator|>
literal|1
condition|)
return|return
operator|(
name|EDOOFUS
operator|)
return|;
comment|/* Figure out how big of a sglist '*head' has to hold. */
name|count
operator|=
literal|0
expr_stmt|;
name|space
operator|=
literal|0
expr_stmt|;
name|split
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|original
operator|->
name|sg_nseg
condition|;
name|i
operator|++
control|)
block|{
name|space
operator|+=
name|original
operator|->
name|sg_segs
index|[
name|i
index|]
operator|.
name|ss_len
expr_stmt|;
name|count
operator|++
expr_stmt|;
if|if
condition|(
name|space
operator|>=
name|length
condition|)
block|{
comment|/* 			 * If 'length' falls in the middle of a 			 * scatter/gather list entry, then 'split' 			 * holds how much of that entry will remain in 			 * 'original'. 			 */
name|split
operator|=
name|space
operator|-
name|length
expr_stmt|;
break|break;
block|}
block|}
comment|/* Nothing to do, so leave head empty. */
if|if
condition|(
name|count
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|*
name|head
operator|==
name|NULL
condition|)
block|{
name|sg
operator|=
name|sglist_alloc
argument_list|(
name|count
argument_list|,
name|mflags
argument_list|)
expr_stmt|;
if|if
condition|(
name|sg
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
operator|*
name|head
operator|=
name|sg
expr_stmt|;
block|}
else|else
block|{
name|sg
operator|=
operator|*
name|head
expr_stmt|;
if|if
condition|(
name|sg
operator|->
name|sg_maxseg
operator|<
name|count
condition|)
return|return
operator|(
name|EFBIG
operator|)
return|;
if|if
condition|(
name|sg
operator|->
name|sg_nseg
operator|!=
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* Copy 'count' entries to 'sg' from 'original'. */
name|bcopy
argument_list|(
name|original
operator|->
name|sg_segs
argument_list|,
name|sg
operator|->
name|sg_segs
argument_list|,
name|count
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|sglist_seg
argument_list|)
argument_list|)
expr_stmt|;
name|sg
operator|->
name|sg_nseg
operator|=
name|count
expr_stmt|;
comment|/* 	 * If we had to split a list entry, fixup the last entry in 	 * 'sg' and the new first entry in 'original'.  We also 	 * decrement 'count' by 1 since we will only be removing 	 * 'count - 1' segments from 'original' now. 	 */
if|if
condition|(
name|split
operator|!=
literal|0
condition|)
block|{
name|count
operator|--
expr_stmt|;
name|sg
operator|->
name|sg_segs
index|[
name|count
index|]
operator|.
name|ss_len
operator|-=
name|split
expr_stmt|;
name|original
operator|->
name|sg_segs
index|[
name|count
index|]
operator|.
name|ss_paddr
operator|=
name|sg
operator|->
name|sg_segs
index|[
name|count
index|]
operator|.
name|ss_paddr
operator|+
name|split
expr_stmt|;
name|original
operator|->
name|sg_segs
index|[
name|count
index|]
operator|.
name|ss_len
operator|=
name|split
expr_stmt|;
block|}
comment|/* Trim 'count' entries from the front of 'original'. */
name|original
operator|->
name|sg_nseg
operator|-=
name|count
expr_stmt|;
name|bcopy
argument_list|(
name|original
operator|->
name|sg_segs
operator|+
name|count
argument_list|,
name|original
operator|->
name|sg_segs
argument_list|,
name|count
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|sglist_seg
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Append the scatter/gather list elements in 'second' to the  * scatter/gather list 'first'.  If there is not enough space in  * 'first', EFBIG is returned.  */
end_comment

begin_function
name|int
name|sglist_join
parameter_list|(
name|struct
name|sglist
modifier|*
name|first
parameter_list|,
name|struct
name|sglist
modifier|*
name|second
parameter_list|)
block|{
name|struct
name|sglist_seg
modifier|*
name|flast
decl_stmt|,
modifier|*
name|sfirst
decl_stmt|;
name|int
name|append
decl_stmt|;
comment|/* If 'second' is empty, there is nothing to do. */
if|if
condition|(
name|second
operator|->
name|sg_nseg
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * If the first entry in 'second' can be appended to the last entry 	 * in 'first' then set append to '1'. 	 */
name|append
operator|=
literal|0
expr_stmt|;
name|flast
operator|=
operator|&
name|first
operator|->
name|sg_segs
index|[
name|first
operator|->
name|sg_nseg
operator|-
literal|1
index|]
expr_stmt|;
name|sfirst
operator|=
operator|&
name|second
operator|->
name|sg_segs
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|first
operator|->
name|sg_nseg
operator|!=
literal|0
operator|&&
name|flast
operator|->
name|ss_paddr
operator|+
name|flast
operator|->
name|ss_len
operator|==
name|sfirst
operator|->
name|ss_paddr
condition|)
name|append
operator|=
literal|1
expr_stmt|;
comment|/* Make sure 'first' has enough room. */
if|if
condition|(
name|first
operator|->
name|sg_nseg
operator|+
name|second
operator|->
name|sg_nseg
operator|-
name|append
operator|>
name|first
operator|->
name|sg_maxseg
condition|)
return|return
operator|(
name|EFBIG
operator|)
return|;
comment|/* Merge last in 'first' and first in 'second' if needed. */
if|if
condition|(
name|append
condition|)
name|flast
operator|->
name|ss_len
operator|+=
name|sfirst
operator|->
name|ss_len
expr_stmt|;
comment|/* Append new segments from 'second' to 'first'. */
name|bcopy
argument_list|(
name|first
operator|->
name|sg_segs
operator|+
name|first
operator|->
name|sg_nseg
argument_list|,
name|second
operator|->
name|sg_segs
operator|+
name|append
argument_list|,
operator|(
name|second
operator|->
name|sg_nseg
operator|-
name|append
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|sglist_seg
argument_list|)
argument_list|)
expr_stmt|;
name|first
operator|->
name|sg_nseg
operator|+=
name|second
operator|->
name|sg_nseg
operator|-
name|append
expr_stmt|;
name|sglist_reset
argument_list|(
name|second
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Generate a new scatter/gather list from a range of an existing  * scatter/gather list.  The 'offset' and 'length' parameters specify  * the logical range of the 'original' list to extract.  If that range  * is not a subset of the length of 'original', then EINVAL is  * returned.  The new scatter/gather list is stored in '*slice'.  *  * If '*slice' is NULL, then a new list will be allocated using  * 'mflags'.  If M_NOWAIT is specified and the allocation fails,  * ENOMEM will be returned.  *  * If '*slice' is not NULL, it should point to an empty sglist.  If it  * does not have enough room for the remaining space, then EFBIG will  * be returned.  If '*slice' is not empty, then EINVAL will be  * returned.  */
end_comment

begin_function
name|int
name|sglist_slice
parameter_list|(
name|struct
name|sglist
modifier|*
name|original
parameter_list|,
name|struct
name|sglist
modifier|*
modifier|*
name|slice
parameter_list|,
name|size_t
name|offset
parameter_list|,
name|size_t
name|length
parameter_list|,
name|int
name|mflags
parameter_list|)
block|{
name|struct
name|sglist
modifier|*
name|sg
decl_stmt|;
name|size_t
name|space
decl_stmt|,
name|end
decl_stmt|,
name|foffs
decl_stmt|,
name|loffs
decl_stmt|;
name|int
name|count
decl_stmt|,
name|i
decl_stmt|,
name|fseg
decl_stmt|;
comment|/* Nothing to do. */
if|if
condition|(
name|length
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Figure out how many segments '*slice' needs to have. */
name|end
operator|=
name|offset
operator|+
name|length
expr_stmt|;
name|space
operator|=
literal|0
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
name|fseg
operator|=
literal|0
expr_stmt|;
name|foffs
operator|=
name|loffs
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|original
operator|->
name|sg_nseg
condition|;
name|i
operator|++
control|)
block|{
name|space
operator|+=
name|original
operator|->
name|sg_segs
index|[
name|i
index|]
operator|.
name|ss_len
expr_stmt|;
if|if
condition|(
name|space
operator|>
name|offset
condition|)
block|{
comment|/* 			 * When we hit the first segment, store its index 			 * in 'fseg' and the offset into the first segment 			 * of 'offset' in 'foffs'. 			 */
if|if
condition|(
name|count
operator|==
literal|0
condition|)
block|{
name|fseg
operator|=
name|i
expr_stmt|;
name|foffs
operator|=
name|offset
operator|-
operator|(
name|space
operator|-
name|original
operator|->
name|sg_segs
index|[
name|i
index|]
operator|.
name|ss_len
operator|)
expr_stmt|;
name|CTR1
argument_list|(
name|KTR_DEV
argument_list|,
literal|"sglist_slice: foffs = %08lx"
argument_list|,
name|foffs
argument_list|)
expr_stmt|;
block|}
name|count
operator|++
expr_stmt|;
comment|/* 			 * When we hit the last segment, break out of 			 * the loop.  Store the amount of extra space 			 * at the end of this segment in 'loffs'. 			 */
if|if
condition|(
name|space
operator|>=
name|end
condition|)
block|{
name|loffs
operator|=
name|space
operator|-
name|end
expr_stmt|;
name|CTR1
argument_list|(
name|KTR_DEV
argument_list|,
literal|"sglist_slice: loffs = %08lx"
argument_list|,
name|loffs
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
comment|/* If we never hit 'end', then 'length' ran off the end, so fail. */
if|if
condition|(
name|space
operator|<
name|end
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
operator|*
name|slice
operator|==
name|NULL
condition|)
block|{
name|sg
operator|=
name|sglist_alloc
argument_list|(
name|count
argument_list|,
name|mflags
argument_list|)
expr_stmt|;
if|if
condition|(
name|sg
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
operator|*
name|slice
operator|=
name|sg
expr_stmt|;
block|}
else|else
block|{
name|sg
operator|=
operator|*
name|slice
expr_stmt|;
if|if
condition|(
name|sg
operator|->
name|sg_maxseg
operator|<
name|count
condition|)
return|return
operator|(
name|EFBIG
operator|)
return|;
if|if
condition|(
name|sg
operator|->
name|sg_nseg
operator|!=
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* 	 * Copy over 'count' segments from 'original' starting at 	 * 'fseg' to 'sg'. 	 */
name|bcopy
argument_list|(
name|original
operator|->
name|sg_segs
operator|+
name|fseg
argument_list|,
name|sg
operator|->
name|sg_segs
argument_list|,
name|count
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|sglist_seg
argument_list|)
argument_list|)
expr_stmt|;
name|sg
operator|->
name|sg_nseg
operator|=
name|count
expr_stmt|;
comment|/* Fixup first and last segments if needed. */
if|if
condition|(
name|foffs
operator|!=
literal|0
condition|)
block|{
name|sg
operator|->
name|sg_segs
index|[
literal|0
index|]
operator|.
name|ss_paddr
operator|+=
name|foffs
expr_stmt|;
name|sg
operator|->
name|sg_segs
index|[
literal|0
index|]
operator|.
name|ss_len
operator|-=
name|foffs
expr_stmt|;
name|CTR2
argument_list|(
name|KTR_DEV
argument_list|,
literal|"sglist_slice seg[0]: %08lx:%08lx"
argument_list|,
operator|(
name|long
operator|)
name|sg
operator|->
name|sg_segs
index|[
literal|0
index|]
operator|.
name|ss_paddr
argument_list|,
name|sg
operator|->
name|sg_segs
index|[
literal|0
index|]
operator|.
name|ss_len
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|loffs
operator|!=
literal|0
condition|)
block|{
name|sg
operator|->
name|sg_segs
index|[
name|count
operator|-
literal|1
index|]
operator|.
name|ss_len
operator|-=
name|loffs
expr_stmt|;
name|CTR2
argument_list|(
name|KTR_DEV
argument_list|,
literal|"sglist_slice seg[%d]: len %08x"
argument_list|,
name|count
operator|-
literal|1
argument_list|,
name|sg
operator|->
name|sg_segs
index|[
name|count
operator|-
literal|1
index|]
operator|.
name|ss_len
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

end_unit

