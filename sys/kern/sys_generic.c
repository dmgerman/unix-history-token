begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1982, 1986, 1989, 1993  *	The Regents of the University of California.  All rights reserved.  * (c) UNIX System Laboratories, Inc.  * All or some portions of this file are derived from material licensed  * to the University of California by American Telephone and Telegraph  * Co. or Unix System Laboratories, Inc. and are reproduced herein with  * the permission of UNIX System Laboratories, Inc.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *	@(#)sys_generic.c	8.5 (Berkeley) 1/21/94  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"opt_compat.h"
end_include

begin_include
include|#
directive|include
file|"opt_ktrace.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysproto.h>
end_include

begin_include
include|#
directive|include
file|<sys/filedesc.h>
end_include

begin_include
include|#
directive|include
file|<sys/filio.h>
end_include

begin_include
include|#
directive|include
file|<sys/fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/signalvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/socketvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/ktr.h>
end_include

begin_include
include|#
directive|include
file|<sys/limits.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/poll.h>
end_include

begin_include
include|#
directive|include
file|<sys/resourcevar.h>
end_include

begin_include
include|#
directive|include
file|<sys/selinfo.h>
end_include

begin_include
include|#
directive|include
file|<sys/sleepqueue.h>
end_include

begin_include
include|#
directive|include
file|<sys/syscallsubr.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysent.h>
end_include

begin_include
include|#
directive|include
file|<sys/vnode.h>
end_include

begin_include
include|#
directive|include
file|<sys/bio.h>
end_include

begin_include
include|#
directive|include
file|<sys/buf.h>
end_include

begin_include
include|#
directive|include
file|<sys/condvar.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|KTRACE
end_ifdef

begin_include
include|#
directive|include
file|<sys/ktrace.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<security/audit/audit.h>
end_include

begin_expr_stmt
specifier|static
name|MALLOC_DEFINE
argument_list|(
name|M_IOCTLOPS
argument_list|,
literal|"ioctlops"
argument_list|,
literal|"ioctl data buffer"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|MALLOC_DEFINE
argument_list|(
name|M_SELECT
argument_list|,
literal|"select"
argument_list|,
literal|"select() buffer"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_IOV
argument_list|,
literal|"iov"
argument_list|,
literal|"large iov's"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function_decl
specifier|static
name|int
name|pollout
parameter_list|(
name|struct
name|pollfd
modifier|*
parameter_list|,
name|struct
name|pollfd
modifier|*
parameter_list|,
name|u_int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pollscan
parameter_list|(
name|struct
name|thread
modifier|*
parameter_list|,
name|struct
name|pollfd
modifier|*
parameter_list|,
name|u_int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pollrescan
parameter_list|(
name|struct
name|thread
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|selscan
parameter_list|(
name|struct
name|thread
modifier|*
parameter_list|,
name|fd_mask
modifier|*
modifier|*
parameter_list|,
name|fd_mask
modifier|*
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|selrescan
parameter_list|(
name|struct
name|thread
modifier|*
parameter_list|,
name|fd_mask
modifier|*
modifier|*
parameter_list|,
name|fd_mask
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|selfdalloc
parameter_list|(
name|struct
name|thread
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|selfdfree
parameter_list|(
name|struct
name|seltd
modifier|*
parameter_list|,
name|struct
name|selfd
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|dofileread
parameter_list|(
name|struct
name|thread
modifier|*
parameter_list|,
name|int
parameter_list|,
name|struct
name|file
modifier|*
parameter_list|,
name|struct
name|uio
modifier|*
parameter_list|,
name|off_t
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|dofilewrite
parameter_list|(
name|struct
name|thread
modifier|*
parameter_list|,
name|int
parameter_list|,
name|struct
name|file
modifier|*
parameter_list|,
name|struct
name|uio
modifier|*
parameter_list|,
name|off_t
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|doselwakeup
parameter_list|(
name|struct
name|selinfo
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|seltdinit
parameter_list|(
name|struct
name|thread
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|seltdwait
parameter_list|(
name|struct
name|thread
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|seltdclear
parameter_list|(
name|struct
name|thread
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * One seltd per-thread allocated on demand as needed.  *  *	t - protected by st_mtx  * 	k - Only accessed by curthread or read-only  */
end_comment

begin_struct
struct|struct
name|seltd
block|{
name|STAILQ_HEAD
argument_list|(
argument_list|,
argument|selfd
argument_list|)
name|st_selq
expr_stmt|;
comment|/* (k) List of selfds. */
name|struct
name|selfd
modifier|*
name|st_free1
decl_stmt|;
comment|/* (k) free fd for read set. */
name|struct
name|selfd
modifier|*
name|st_free2
decl_stmt|;
comment|/* (k) free fd for write set. */
name|struct
name|mtx
name|st_mtx
decl_stmt|;
comment|/* Protects struct seltd */
name|struct
name|cv
name|st_wait
decl_stmt|;
comment|/* (t) Wait channel. */
name|int
name|st_flags
decl_stmt|;
comment|/* (t) SELTD_ flags. */
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|SELTD_PENDING
value|0x0001
end_define

begin_comment
comment|/* We have pending events. */
end_comment

begin_define
define|#
directive|define
name|SELTD_RESCAN
value|0x0002
end_define

begin_comment
comment|/* Doing a rescan. */
end_comment

begin_comment
comment|/*  * One selfd allocated per-thread per-file-descriptor.  *	f - protected by sf_mtx  */
end_comment

begin_struct
struct|struct
name|selfd
block|{
name|STAILQ_ENTRY
argument_list|(
argument|selfd
argument_list|)
name|sf_link
expr_stmt|;
comment|/* (k) fds owned by this td. */
name|TAILQ_ENTRY
argument_list|(
argument|selfd
argument_list|)
name|sf_threads
expr_stmt|;
comment|/* (f) fds on this selinfo. */
name|struct
name|selinfo
modifier|*
name|sf_si
decl_stmt|;
comment|/* (f) selinfo when linked. */
name|struct
name|mtx
modifier|*
name|sf_mtx
decl_stmt|;
comment|/* Pointer to selinfo mtx. */
name|struct
name|seltd
modifier|*
name|sf_td
decl_stmt|;
comment|/* (k) owning seltd. */
name|void
modifier|*
name|sf_cookie
decl_stmt|;
comment|/* (k) fd or pollfd. */
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|uma_zone_t
name|selfd_zone
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|_SYS_SYSPROTO_H_
end_ifndef

begin_struct
struct|struct
name|read_args
block|{
name|int
name|fd
decl_stmt|;
name|void
modifier|*
name|buf
decl_stmt|;
name|size_t
name|nbyte
decl_stmt|;
block|}
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|read
parameter_list|(
name|td
parameter_list|,
name|uap
parameter_list|)
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|read_args
modifier|*
name|uap
decl_stmt|;
block|{
name|struct
name|uio
name|auio
decl_stmt|;
name|struct
name|iovec
name|aiov
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|uap
operator|->
name|nbyte
operator|>
name|INT_MAX
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|aiov
operator|.
name|iov_base
operator|=
name|uap
operator|->
name|buf
expr_stmt|;
name|aiov
operator|.
name|iov_len
operator|=
name|uap
operator|->
name|nbyte
expr_stmt|;
name|auio
operator|.
name|uio_iov
operator|=
operator|&
name|aiov
expr_stmt|;
name|auio
operator|.
name|uio_iovcnt
operator|=
literal|1
expr_stmt|;
name|auio
operator|.
name|uio_resid
operator|=
name|uap
operator|->
name|nbyte
expr_stmt|;
name|auio
operator|.
name|uio_segflg
operator|=
name|UIO_USERSPACE
expr_stmt|;
name|error
operator|=
name|kern_readv
argument_list|(
name|td
argument_list|,
name|uap
operator|->
name|fd
argument_list|,
operator|&
name|auio
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Positioned read system call  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|_SYS_SYSPROTO_H_
end_ifndef

begin_struct
struct|struct
name|pread_args
block|{
name|int
name|fd
decl_stmt|;
name|void
modifier|*
name|buf
decl_stmt|;
name|size_t
name|nbyte
decl_stmt|;
name|int
name|pad
decl_stmt|;
name|off_t
name|offset
decl_stmt|;
block|}
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|pread
parameter_list|(
name|td
parameter_list|,
name|uap
parameter_list|)
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|pread_args
modifier|*
name|uap
decl_stmt|;
block|{
name|struct
name|uio
name|auio
decl_stmt|;
name|struct
name|iovec
name|aiov
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|uap
operator|->
name|nbyte
operator|>
name|INT_MAX
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|aiov
operator|.
name|iov_base
operator|=
name|uap
operator|->
name|buf
expr_stmt|;
name|aiov
operator|.
name|iov_len
operator|=
name|uap
operator|->
name|nbyte
expr_stmt|;
name|auio
operator|.
name|uio_iov
operator|=
operator|&
name|aiov
expr_stmt|;
name|auio
operator|.
name|uio_iovcnt
operator|=
literal|1
expr_stmt|;
name|auio
operator|.
name|uio_resid
operator|=
name|uap
operator|->
name|nbyte
expr_stmt|;
name|auio
operator|.
name|uio_segflg
operator|=
name|UIO_USERSPACE
expr_stmt|;
name|error
operator|=
name|kern_preadv
argument_list|(
name|td
argument_list|,
name|uap
operator|->
name|fd
argument_list|,
operator|&
name|auio
argument_list|,
name|uap
operator|->
name|offset
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|freebsd6_pread
parameter_list|(
name|td
parameter_list|,
name|uap
parameter_list|)
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|freebsd6_pread_args
modifier|*
name|uap
decl_stmt|;
block|{
name|struct
name|pread_args
name|oargs
decl_stmt|;
name|oargs
operator|.
name|fd
operator|=
name|uap
operator|->
name|fd
expr_stmt|;
name|oargs
operator|.
name|buf
operator|=
name|uap
operator|->
name|buf
expr_stmt|;
name|oargs
operator|.
name|nbyte
operator|=
name|uap
operator|->
name|nbyte
expr_stmt|;
name|oargs
operator|.
name|offset
operator|=
name|uap
operator|->
name|offset
expr_stmt|;
return|return
operator|(
name|pread
argument_list|(
name|td
argument_list|,
operator|&
name|oargs
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Scatter read system call.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|_SYS_SYSPROTO_H_
end_ifndef

begin_struct
struct|struct
name|readv_args
block|{
name|int
name|fd
decl_stmt|;
name|struct
name|iovec
modifier|*
name|iovp
decl_stmt|;
name|u_int
name|iovcnt
decl_stmt|;
block|}
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|readv
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|readv_args
modifier|*
name|uap
parameter_list|)
block|{
name|struct
name|uio
modifier|*
name|auio
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
name|copyinuio
argument_list|(
name|uap
operator|->
name|iovp
argument_list|,
name|uap
operator|->
name|iovcnt
argument_list|,
operator|&
name|auio
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|error
operator|=
name|kern_readv
argument_list|(
name|td
argument_list|,
name|uap
operator|->
name|fd
argument_list|,
name|auio
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|auio
argument_list|,
name|M_IOV
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|kern_readv
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|int
name|fd
parameter_list|,
name|struct
name|uio
modifier|*
name|auio
parameter_list|)
block|{
name|struct
name|file
modifier|*
name|fp
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
name|fget_read
argument_list|(
name|td
argument_list|,
name|fd
argument_list|,
operator|&
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|error
operator|=
name|dofileread
argument_list|(
name|td
argument_list|,
name|fd
argument_list|,
name|fp
argument_list|,
name|auio
argument_list|,
operator|(
name|off_t
operator|)
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fdrop
argument_list|(
name|fp
argument_list|,
name|td
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Scatter positioned read system call.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|_SYS_SYSPROTO_H_
end_ifndef

begin_struct
struct|struct
name|preadv_args
block|{
name|int
name|fd
decl_stmt|;
name|struct
name|iovec
modifier|*
name|iovp
decl_stmt|;
name|u_int
name|iovcnt
decl_stmt|;
name|off_t
name|offset
decl_stmt|;
block|}
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|preadv
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|preadv_args
modifier|*
name|uap
parameter_list|)
block|{
name|struct
name|uio
modifier|*
name|auio
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
name|copyinuio
argument_list|(
name|uap
operator|->
name|iovp
argument_list|,
name|uap
operator|->
name|iovcnt
argument_list|,
operator|&
name|auio
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|error
operator|=
name|kern_preadv
argument_list|(
name|td
argument_list|,
name|uap
operator|->
name|fd
argument_list|,
name|auio
argument_list|,
name|uap
operator|->
name|offset
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|auio
argument_list|,
name|M_IOV
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|kern_preadv
parameter_list|(
name|td
parameter_list|,
name|fd
parameter_list|,
name|auio
parameter_list|,
name|offset
parameter_list|)
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|int
name|fd
decl_stmt|;
name|struct
name|uio
modifier|*
name|auio
decl_stmt|;
name|off_t
name|offset
decl_stmt|;
block|{
name|struct
name|file
modifier|*
name|fp
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
name|fget_read
argument_list|(
name|td
argument_list|,
name|fd
argument_list|,
operator|&
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
operator|!
operator|(
name|fp
operator|->
name|f_ops
operator|->
name|fo_flags
operator|&
name|DFLAG_SEEKABLE
operator|)
condition|)
name|error
operator|=
name|ESPIPE
expr_stmt|;
elseif|else
if|if
condition|(
name|offset
operator|<
literal|0
operator|&&
name|fp
operator|->
name|f_vnode
operator|->
name|v_type
operator|!=
name|VCHR
condition|)
name|error
operator|=
name|EINVAL
expr_stmt|;
else|else
name|error
operator|=
name|dofileread
argument_list|(
name|td
argument_list|,
name|fd
argument_list|,
name|fp
argument_list|,
name|auio
argument_list|,
name|offset
argument_list|,
name|FOF_OFFSET
argument_list|)
expr_stmt|;
name|fdrop
argument_list|(
name|fp
argument_list|,
name|td
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Common code for readv and preadv that reads data in  * from a file using the passed in uio, offset, and flags.  */
end_comment

begin_function
specifier|static
name|int
name|dofileread
parameter_list|(
name|td
parameter_list|,
name|fd
parameter_list|,
name|fp
parameter_list|,
name|auio
parameter_list|,
name|offset
parameter_list|,
name|flags
parameter_list|)
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|int
name|fd
decl_stmt|;
name|struct
name|file
modifier|*
name|fp
decl_stmt|;
name|struct
name|uio
modifier|*
name|auio
decl_stmt|;
name|off_t
name|offset
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|{
name|ssize_t
name|cnt
decl_stmt|;
name|int
name|error
decl_stmt|;
ifdef|#
directive|ifdef
name|KTRACE
name|struct
name|uio
modifier|*
name|ktruio
init|=
name|NULL
decl_stmt|;
endif|#
directive|endif
comment|/* Finish zero length reads right here */
if|if
condition|(
name|auio
operator|->
name|uio_resid
operator|==
literal|0
condition|)
block|{
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|auio
operator|->
name|uio_rw
operator|=
name|UIO_READ
expr_stmt|;
name|auio
operator|->
name|uio_offset
operator|=
name|offset
expr_stmt|;
name|auio
operator|->
name|uio_td
operator|=
name|td
expr_stmt|;
ifdef|#
directive|ifdef
name|KTRACE
if|if
condition|(
name|KTRPOINT
argument_list|(
name|td
argument_list|,
name|KTR_GENIO
argument_list|)
condition|)
name|ktruio
operator|=
name|cloneuio
argument_list|(
name|auio
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|cnt
operator|=
name|auio
operator|->
name|uio_resid
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|fo_read
argument_list|(
name|fp
argument_list|,
name|auio
argument_list|,
name|td
operator|->
name|td_ucred
argument_list|,
name|flags
argument_list|,
name|td
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|auio
operator|->
name|uio_resid
operator|!=
name|cnt
operator|&&
operator|(
name|error
operator|==
name|ERESTART
operator|||
name|error
operator|==
name|EINTR
operator|||
name|error
operator|==
name|EWOULDBLOCK
operator|)
condition|)
name|error
operator|=
literal|0
expr_stmt|;
block|}
name|cnt
operator|-=
name|auio
operator|->
name|uio_resid
expr_stmt|;
ifdef|#
directive|ifdef
name|KTRACE
if|if
condition|(
name|ktruio
operator|!=
name|NULL
condition|)
block|{
name|ktruio
operator|->
name|uio_resid
operator|=
name|cnt
expr_stmt|;
name|ktrgenio
argument_list|(
name|fd
argument_list|,
name|UIO_READ
argument_list|,
name|ktruio
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|=
name|cnt
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|_SYS_SYSPROTO_H_
end_ifndef

begin_struct
struct|struct
name|write_args
block|{
name|int
name|fd
decl_stmt|;
specifier|const
name|void
modifier|*
name|buf
decl_stmt|;
name|size_t
name|nbyte
decl_stmt|;
block|}
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|write
parameter_list|(
name|td
parameter_list|,
name|uap
parameter_list|)
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|write_args
modifier|*
name|uap
decl_stmt|;
block|{
name|struct
name|uio
name|auio
decl_stmt|;
name|struct
name|iovec
name|aiov
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|uap
operator|->
name|nbyte
operator|>
name|INT_MAX
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|aiov
operator|.
name|iov_base
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|uap
operator|->
name|buf
expr_stmt|;
name|aiov
operator|.
name|iov_len
operator|=
name|uap
operator|->
name|nbyte
expr_stmt|;
name|auio
operator|.
name|uio_iov
operator|=
operator|&
name|aiov
expr_stmt|;
name|auio
operator|.
name|uio_iovcnt
operator|=
literal|1
expr_stmt|;
name|auio
operator|.
name|uio_resid
operator|=
name|uap
operator|->
name|nbyte
expr_stmt|;
name|auio
operator|.
name|uio_segflg
operator|=
name|UIO_USERSPACE
expr_stmt|;
name|error
operator|=
name|kern_writev
argument_list|(
name|td
argument_list|,
name|uap
operator|->
name|fd
argument_list|,
operator|&
name|auio
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Positioned write system call.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|_SYS_SYSPROTO_H_
end_ifndef

begin_struct
struct|struct
name|pwrite_args
block|{
name|int
name|fd
decl_stmt|;
specifier|const
name|void
modifier|*
name|buf
decl_stmt|;
name|size_t
name|nbyte
decl_stmt|;
name|int
name|pad
decl_stmt|;
name|off_t
name|offset
decl_stmt|;
block|}
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|pwrite
parameter_list|(
name|td
parameter_list|,
name|uap
parameter_list|)
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|pwrite_args
modifier|*
name|uap
decl_stmt|;
block|{
name|struct
name|uio
name|auio
decl_stmt|;
name|struct
name|iovec
name|aiov
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|uap
operator|->
name|nbyte
operator|>
name|INT_MAX
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|aiov
operator|.
name|iov_base
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|uap
operator|->
name|buf
expr_stmt|;
name|aiov
operator|.
name|iov_len
operator|=
name|uap
operator|->
name|nbyte
expr_stmt|;
name|auio
operator|.
name|uio_iov
operator|=
operator|&
name|aiov
expr_stmt|;
name|auio
operator|.
name|uio_iovcnt
operator|=
literal|1
expr_stmt|;
name|auio
operator|.
name|uio_resid
operator|=
name|uap
operator|->
name|nbyte
expr_stmt|;
name|auio
operator|.
name|uio_segflg
operator|=
name|UIO_USERSPACE
expr_stmt|;
name|error
operator|=
name|kern_pwritev
argument_list|(
name|td
argument_list|,
name|uap
operator|->
name|fd
argument_list|,
operator|&
name|auio
argument_list|,
name|uap
operator|->
name|offset
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|freebsd6_pwrite
parameter_list|(
name|td
parameter_list|,
name|uap
parameter_list|)
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|freebsd6_pwrite_args
modifier|*
name|uap
decl_stmt|;
block|{
name|struct
name|pwrite_args
name|oargs
decl_stmt|;
name|oargs
operator|.
name|fd
operator|=
name|uap
operator|->
name|fd
expr_stmt|;
name|oargs
operator|.
name|buf
operator|=
name|uap
operator|->
name|buf
expr_stmt|;
name|oargs
operator|.
name|nbyte
operator|=
name|uap
operator|->
name|nbyte
expr_stmt|;
name|oargs
operator|.
name|offset
operator|=
name|uap
operator|->
name|offset
expr_stmt|;
return|return
operator|(
name|pwrite
argument_list|(
name|td
argument_list|,
operator|&
name|oargs
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Gather write system call.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|_SYS_SYSPROTO_H_
end_ifndef

begin_struct
struct|struct
name|writev_args
block|{
name|int
name|fd
decl_stmt|;
name|struct
name|iovec
modifier|*
name|iovp
decl_stmt|;
name|u_int
name|iovcnt
decl_stmt|;
block|}
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|writev
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|writev_args
modifier|*
name|uap
parameter_list|)
block|{
name|struct
name|uio
modifier|*
name|auio
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
name|copyinuio
argument_list|(
name|uap
operator|->
name|iovp
argument_list|,
name|uap
operator|->
name|iovcnt
argument_list|,
operator|&
name|auio
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|error
operator|=
name|kern_writev
argument_list|(
name|td
argument_list|,
name|uap
operator|->
name|fd
argument_list|,
name|auio
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|auio
argument_list|,
name|M_IOV
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|kern_writev
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|int
name|fd
parameter_list|,
name|struct
name|uio
modifier|*
name|auio
parameter_list|)
block|{
name|struct
name|file
modifier|*
name|fp
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
name|fget_write
argument_list|(
name|td
argument_list|,
name|fd
argument_list|,
operator|&
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|error
operator|=
name|dofilewrite
argument_list|(
name|td
argument_list|,
name|fd
argument_list|,
name|fp
argument_list|,
name|auio
argument_list|,
operator|(
name|off_t
operator|)
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fdrop
argument_list|(
name|fp
argument_list|,
name|td
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Gather positioned write system call.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|_SYS_SYSPROTO_H_
end_ifndef

begin_struct
struct|struct
name|pwritev_args
block|{
name|int
name|fd
decl_stmt|;
name|struct
name|iovec
modifier|*
name|iovp
decl_stmt|;
name|u_int
name|iovcnt
decl_stmt|;
name|off_t
name|offset
decl_stmt|;
block|}
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|pwritev
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|pwritev_args
modifier|*
name|uap
parameter_list|)
block|{
name|struct
name|uio
modifier|*
name|auio
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
name|copyinuio
argument_list|(
name|uap
operator|->
name|iovp
argument_list|,
name|uap
operator|->
name|iovcnt
argument_list|,
operator|&
name|auio
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|error
operator|=
name|kern_pwritev
argument_list|(
name|td
argument_list|,
name|uap
operator|->
name|fd
argument_list|,
name|auio
argument_list|,
name|uap
operator|->
name|offset
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|auio
argument_list|,
name|M_IOV
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|kern_pwritev
parameter_list|(
name|td
parameter_list|,
name|fd
parameter_list|,
name|auio
parameter_list|,
name|offset
parameter_list|)
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|uio
modifier|*
name|auio
decl_stmt|;
name|int
name|fd
decl_stmt|;
name|off_t
name|offset
decl_stmt|;
block|{
name|struct
name|file
modifier|*
name|fp
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
name|fget_write
argument_list|(
name|td
argument_list|,
name|fd
argument_list|,
operator|&
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
operator|!
operator|(
name|fp
operator|->
name|f_ops
operator|->
name|fo_flags
operator|&
name|DFLAG_SEEKABLE
operator|)
condition|)
name|error
operator|=
name|ESPIPE
expr_stmt|;
elseif|else
if|if
condition|(
name|offset
operator|<
literal|0
operator|&&
name|fp
operator|->
name|f_vnode
operator|->
name|v_type
operator|!=
name|VCHR
condition|)
name|error
operator|=
name|EINVAL
expr_stmt|;
else|else
name|error
operator|=
name|dofilewrite
argument_list|(
name|td
argument_list|,
name|fd
argument_list|,
name|fp
argument_list|,
name|auio
argument_list|,
name|offset
argument_list|,
name|FOF_OFFSET
argument_list|)
expr_stmt|;
name|fdrop
argument_list|(
name|fp
argument_list|,
name|td
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Common code for writev and pwritev that writes data to  * a file using the passed in uio, offset, and flags.  */
end_comment

begin_function
specifier|static
name|int
name|dofilewrite
parameter_list|(
name|td
parameter_list|,
name|fd
parameter_list|,
name|fp
parameter_list|,
name|auio
parameter_list|,
name|offset
parameter_list|,
name|flags
parameter_list|)
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|int
name|fd
decl_stmt|;
name|struct
name|file
modifier|*
name|fp
decl_stmt|;
name|struct
name|uio
modifier|*
name|auio
decl_stmt|;
name|off_t
name|offset
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|{
name|ssize_t
name|cnt
decl_stmt|;
name|int
name|error
decl_stmt|;
ifdef|#
directive|ifdef
name|KTRACE
name|struct
name|uio
modifier|*
name|ktruio
init|=
name|NULL
decl_stmt|;
endif|#
directive|endif
name|auio
operator|->
name|uio_rw
operator|=
name|UIO_WRITE
expr_stmt|;
name|auio
operator|->
name|uio_td
operator|=
name|td
expr_stmt|;
name|auio
operator|->
name|uio_offset
operator|=
name|offset
expr_stmt|;
ifdef|#
directive|ifdef
name|KTRACE
if|if
condition|(
name|KTRPOINT
argument_list|(
name|td
argument_list|,
name|KTR_GENIO
argument_list|)
condition|)
name|ktruio
operator|=
name|cloneuio
argument_list|(
name|auio
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|cnt
operator|=
name|auio
operator|->
name|uio_resid
expr_stmt|;
if|if
condition|(
name|fp
operator|->
name|f_type
operator|==
name|DTYPE_VNODE
condition|)
name|bwillwrite
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|fo_write
argument_list|(
name|fp
argument_list|,
name|auio
argument_list|,
name|td
operator|->
name|td_ucred
argument_list|,
name|flags
argument_list|,
name|td
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|auio
operator|->
name|uio_resid
operator|!=
name|cnt
operator|&&
operator|(
name|error
operator|==
name|ERESTART
operator|||
name|error
operator|==
name|EINTR
operator|||
name|error
operator|==
name|EWOULDBLOCK
operator|)
condition|)
name|error
operator|=
literal|0
expr_stmt|;
comment|/* Socket layer is responsible for issuing SIGPIPE. */
if|if
condition|(
name|fp
operator|->
name|f_type
operator|!=
name|DTYPE_SOCKET
operator|&&
name|error
operator|==
name|EPIPE
condition|)
block|{
name|PROC_LOCK
argument_list|(
name|td
operator|->
name|td_proc
argument_list|)
expr_stmt|;
name|psignal
argument_list|(
name|td
operator|->
name|td_proc
argument_list|,
name|SIGPIPE
argument_list|)
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|td
operator|->
name|td_proc
argument_list|)
expr_stmt|;
block|}
block|}
name|cnt
operator|-=
name|auio
operator|->
name|uio_resid
expr_stmt|;
ifdef|#
directive|ifdef
name|KTRACE
if|if
condition|(
name|ktruio
operator|!=
name|NULL
condition|)
block|{
name|ktruio
operator|->
name|uio_resid
operator|=
name|cnt
expr_stmt|;
name|ktrgenio
argument_list|(
name|fd
argument_list|,
name|UIO_WRITE
argument_list|,
name|ktruio
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|=
name|cnt
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Truncate a file given a file descriptor.  *  * Can't use fget_write() here, since must return EINVAL and not EBADF if the  * descriptor isn't writable.  */
end_comment

begin_function
name|int
name|kern_ftruncate
parameter_list|(
name|td
parameter_list|,
name|fd
parameter_list|,
name|length
parameter_list|)
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|int
name|fd
decl_stmt|;
name|off_t
name|length
decl_stmt|;
block|{
name|struct
name|file
modifier|*
name|fp
decl_stmt|;
name|int
name|error
decl_stmt|;
name|AUDIT_ARG_FD
argument_list|(
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|length
operator|<
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|error
operator|=
name|fget
argument_list|(
name|td
argument_list|,
name|fd
argument_list|,
operator|&
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|AUDIT_ARG_FILE
argument_list|(
name|td
operator|->
name|td_proc
argument_list|,
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|fp
operator|->
name|f_flag
operator|&
name|FWRITE
operator|)
condition|)
block|{
name|fdrop
argument_list|(
name|fp
argument_list|,
name|td
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|error
operator|=
name|fo_truncate
argument_list|(
name|fp
argument_list|,
name|length
argument_list|,
name|td
operator|->
name|td_ucred
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|fdrop
argument_list|(
name|fp
argument_list|,
name|td
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|_SYS_SYSPROTO_H_
end_ifndef

begin_struct
struct|struct
name|ftruncate_args
block|{
name|int
name|fd
decl_stmt|;
name|int
name|pad
decl_stmt|;
name|off_t
name|length
decl_stmt|;
block|}
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|ftruncate
parameter_list|(
name|td
parameter_list|,
name|uap
parameter_list|)
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|ftruncate_args
modifier|*
name|uap
decl_stmt|;
block|{
return|return
operator|(
name|kern_ftruncate
argument_list|(
name|td
argument_list|,
name|uap
operator|->
name|fd
argument_list|,
name|uap
operator|->
name|length
argument_list|)
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|COMPAT_43
argument_list|)
end_if

begin_ifndef
ifndef|#
directive|ifndef
name|_SYS_SYSPROTO_H_
end_ifndef

begin_struct
struct|struct
name|oftruncate_args
block|{
name|int
name|fd
decl_stmt|;
name|long
name|length
decl_stmt|;
block|}
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|oftruncate
parameter_list|(
name|td
parameter_list|,
name|uap
parameter_list|)
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|oftruncate_args
modifier|*
name|uap
decl_stmt|;
block|{
return|return
operator|(
name|kern_ftruncate
argument_list|(
name|td
argument_list|,
name|uap
operator|->
name|fd
argument_list|,
name|uap
operator|->
name|length
argument_list|)
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* COMPAT_43 */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|_SYS_SYSPROTO_H_
end_ifndef

begin_struct
struct|struct
name|ioctl_args
block|{
name|int
name|fd
decl_stmt|;
name|u_long
name|com
decl_stmt|;
name|caddr_t
name|data
decl_stmt|;
block|}
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|ioctl
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|ioctl_args
modifier|*
name|uap
parameter_list|)
block|{
name|u_long
name|com
decl_stmt|;
name|int
name|arg
decl_stmt|,
name|error
decl_stmt|;
name|u_int
name|size
decl_stmt|;
name|caddr_t
name|data
decl_stmt|;
if|if
condition|(
name|uap
operator|->
name|com
operator|>
literal|0xffffffff
condition|)
block|{
name|printf
argument_list|(
literal|"WARNING pid %d (%s): ioctl sign-extension ioctl %lx\n"
argument_list|,
name|td
operator|->
name|td_proc
operator|->
name|p_pid
argument_list|,
name|td
operator|->
name|td_name
argument_list|,
name|uap
operator|->
name|com
argument_list|)
expr_stmt|;
name|uap
operator|->
name|com
operator|&=
literal|0xffffffff
expr_stmt|;
block|}
name|com
operator|=
name|uap
operator|->
name|com
expr_stmt|;
comment|/* 	 * Interpret high order word to find amount of data to be 	 * copied to/from the user's address space. 	 */
name|size
operator|=
name|IOCPARM_LEN
argument_list|(
name|com
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|size
operator|>
name|IOCPARM_MAX
operator|)
operator|||
operator|(
operator|(
name|com
operator|&
operator|(
name|IOC_VOID
operator||
name|IOC_IN
operator||
name|IOC_OUT
operator|)
operator|)
operator|==
literal|0
operator|)
operator|||
if|#
directive|if
name|defined
argument_list|(
name|COMPAT_FREEBSD5
argument_list|)
operator|||
name|defined
argument_list|(
name|COMPAT_FREEBSD4
argument_list|)
operator|||
name|defined
argument_list|(
name|COMPAT_43
argument_list|)
operator|(
operator|(
name|com
operator|&
name|IOC_OUT
operator|)
operator|&&
name|size
operator|==
literal|0
operator|)
operator|||
else|#
directive|else
operator|(
operator|(
name|com
operator|&
operator|(
name|IOC_IN
operator||
name|IOC_OUT
operator|)
operator|)
operator|&&
name|size
operator|==
literal|0
operator|)
operator|||
endif|#
directive|endif
operator|(
operator|(
name|com
operator|&
name|IOC_VOID
operator|)
operator|&&
name|size
operator|>
literal|0
operator|&&
name|size
operator|!=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|)
condition|)
return|return
operator|(
name|ENOTTY
operator|)
return|;
if|if
condition|(
name|size
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|com
operator|&
name|IOC_VOID
condition|)
block|{
comment|/* Integer argument. */
name|arg
operator|=
operator|(
name|intptr_t
operator|)
name|uap
operator|->
name|data
expr_stmt|;
name|data
operator|=
operator|(
name|void
operator|*
operator|)
operator|&
name|arg
expr_stmt|;
name|size
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|data
operator|=
name|malloc
argument_list|(
operator|(
name|u_long
operator|)
name|size
argument_list|,
name|M_IOCTLOPS
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
block|}
else|else
name|data
operator|=
operator|(
name|void
operator|*
operator|)
operator|&
name|uap
operator|->
name|data
expr_stmt|;
if|if
condition|(
name|com
operator|&
name|IOC_IN
condition|)
block|{
name|error
operator|=
name|copyin
argument_list|(
name|uap
operator|->
name|data
argument_list|,
name|data
argument_list|,
operator|(
name|u_int
operator|)
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
if|if
condition|(
name|size
operator|>
literal|0
condition|)
name|free
argument_list|(
name|data
argument_list|,
name|M_IOCTLOPS
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|com
operator|&
name|IOC_OUT
condition|)
block|{
comment|/* 		 * Zero the buffer so the user always 		 * gets back something deterministic. 		 */
name|bzero
argument_list|(
name|data
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
name|kern_ioctl
argument_list|(
name|td
argument_list|,
name|uap
operator|->
name|fd
argument_list|,
name|com
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
operator|&&
operator|(
name|com
operator|&
name|IOC_OUT
operator|)
condition|)
name|error
operator|=
name|copyout
argument_list|(
name|data
argument_list|,
name|uap
operator|->
name|data
argument_list|,
operator|(
name|u_int
operator|)
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|>
literal|0
condition|)
name|free
argument_list|(
name|data
argument_list|,
name|M_IOCTLOPS
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|kern_ioctl
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|int
name|fd
parameter_list|,
name|u_long
name|com
parameter_list|,
name|caddr_t
name|data
parameter_list|)
block|{
name|struct
name|file
modifier|*
name|fp
decl_stmt|;
name|struct
name|filedesc
modifier|*
name|fdp
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|tmp
decl_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|fget
argument_list|(
name|td
argument_list|,
name|fd
argument_list|,
operator|&
name|fp
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
operator|(
name|fp
operator|->
name|f_flag
operator|&
operator|(
name|FREAD
operator||
name|FWRITE
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
name|fdrop
argument_list|(
name|fp
argument_list|,
name|td
argument_list|)
expr_stmt|;
return|return
operator|(
name|EBADF
operator|)
return|;
block|}
name|fdp
operator|=
name|td
operator|->
name|td_proc
operator|->
name|p_fd
expr_stmt|;
switch|switch
condition|(
name|com
condition|)
block|{
case|case
name|FIONCLEX
case|:
name|FILEDESC_XLOCK
argument_list|(
name|fdp
argument_list|)
expr_stmt|;
name|fdp
operator|->
name|fd_ofileflags
index|[
name|fd
index|]
operator|&=
operator|~
name|UF_EXCLOSE
expr_stmt|;
name|FILEDESC_XUNLOCK
argument_list|(
name|fdp
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
case|case
name|FIOCLEX
case|:
name|FILEDESC_XLOCK
argument_list|(
name|fdp
argument_list|)
expr_stmt|;
name|fdp
operator|->
name|fd_ofileflags
index|[
name|fd
index|]
operator||=
name|UF_EXCLOSE
expr_stmt|;
name|FILEDESC_XUNLOCK
argument_list|(
name|fdp
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
case|case
name|FIONBIO
case|:
if|if
condition|(
operator|(
name|tmp
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|)
condition|)
name|atomic_set_int
argument_list|(
operator|&
name|fp
operator|->
name|f_flag
argument_list|,
name|FNONBLOCK
argument_list|)
expr_stmt|;
else|else
name|atomic_clear_int
argument_list|(
operator|&
name|fp
operator|->
name|f_flag
argument_list|,
name|FNONBLOCK
argument_list|)
expr_stmt|;
name|data
operator|=
operator|(
name|void
operator|*
operator|)
operator|&
name|tmp
expr_stmt|;
break|break;
case|case
name|FIOASYNC
case|:
if|if
condition|(
operator|(
name|tmp
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|)
condition|)
name|atomic_set_int
argument_list|(
operator|&
name|fp
operator|->
name|f_flag
argument_list|,
name|FASYNC
argument_list|)
expr_stmt|;
else|else
name|atomic_clear_int
argument_list|(
operator|&
name|fp
operator|->
name|f_flag
argument_list|,
name|FASYNC
argument_list|)
expr_stmt|;
name|data
operator|=
operator|(
name|void
operator|*
operator|)
operator|&
name|tmp
expr_stmt|;
break|break;
block|}
name|error
operator|=
name|fo_ioctl
argument_list|(
name|fp
argument_list|,
name|com
argument_list|,
name|data
argument_list|,
name|td
operator|->
name|td_ucred
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|out
label|:
name|fdrop
argument_list|(
name|fp
argument_list|,
name|td
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|poll_no_poll
parameter_list|(
name|int
name|events
parameter_list|)
block|{
comment|/* 	 * Return true for read/write.  If the user asked for something 	 * special, return POLLNVAL, so that clients have a way of 	 * determining reliably whether or not the extended 	 * functionality is present without hard-coding knowledge 	 * of specific filesystem implementations. 	 */
if|if
condition|(
name|events
operator|&
operator|~
name|POLLSTANDARD
condition|)
return|return
operator|(
name|POLLNVAL
operator|)
return|;
return|return
operator|(
name|events
operator|&
operator|(
name|POLLIN
operator||
name|POLLOUT
operator||
name|POLLRDNORM
operator||
name|POLLWRNORM
operator|)
operator|)
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|_SYS_SYSPROTO_H_
end_ifndef

begin_struct
struct|struct
name|select_args
block|{
name|int
name|nd
decl_stmt|;
name|fd_set
modifier|*
name|in
decl_stmt|,
modifier|*
name|ou
decl_stmt|,
modifier|*
name|ex
decl_stmt|;
name|struct
name|timeval
modifier|*
name|tv
decl_stmt|;
block|}
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|select
parameter_list|(
name|td
parameter_list|,
name|uap
parameter_list|)
specifier|register
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
specifier|register
name|struct
name|select_args
modifier|*
name|uap
decl_stmt|;
block|{
name|struct
name|timeval
name|tv
decl_stmt|,
modifier|*
name|tvp
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|uap
operator|->
name|tv
operator|!=
name|NULL
condition|)
block|{
name|error
operator|=
name|copyin
argument_list|(
name|uap
operator|->
name|tv
argument_list|,
operator|&
name|tv
argument_list|,
sizeof|sizeof
argument_list|(
name|tv
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|tvp
operator|=
operator|&
name|tv
expr_stmt|;
block|}
else|else
name|tvp
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|kern_select
argument_list|(
name|td
argument_list|,
name|uap
operator|->
name|nd
argument_list|,
name|uap
operator|->
name|in
argument_list|,
name|uap
operator|->
name|ou
argument_list|,
name|uap
operator|->
name|ex
argument_list|,
name|tvp
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|kern_select
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|int
name|nd
parameter_list|,
name|fd_set
modifier|*
name|fd_in
parameter_list|,
name|fd_set
modifier|*
name|fd_ou
parameter_list|,
name|fd_set
modifier|*
name|fd_ex
parameter_list|,
name|struct
name|timeval
modifier|*
name|tvp
parameter_list|)
block|{
name|struct
name|filedesc
modifier|*
name|fdp
decl_stmt|;
comment|/* 	 * The magic 2048 here is chosen to be just enough for FD_SETSIZE 	 * infds with the new FD_SETSIZE of 1024, and more than enough for 	 * FD_SETSIZE infds, outfds and exceptfds with the old FD_SETSIZE 	 * of 256. 	 */
name|fd_mask
name|s_selbits
index|[
name|howmany
argument_list|(
literal|2048
argument_list|,
name|NFDBITS
argument_list|)
index|]
decl_stmt|;
name|fd_mask
modifier|*
name|ibits
index|[
literal|3
index|]
decl_stmt|,
modifier|*
name|obits
index|[
literal|3
index|]
decl_stmt|,
modifier|*
name|selbits
decl_stmt|,
modifier|*
name|sbp
decl_stmt|;
name|struct
name|timeval
name|atv
decl_stmt|,
name|rtv
decl_stmt|,
name|ttv
decl_stmt|;
name|int
name|error
decl_stmt|,
name|timo
decl_stmt|;
name|u_int
name|nbufbytes
decl_stmt|,
name|ncpbytes
decl_stmt|,
name|nfdbits
decl_stmt|;
if|if
condition|(
name|nd
operator|<
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|fdp
operator|=
name|td
operator|->
name|td_proc
operator|->
name|p_fd
expr_stmt|;
name|FILEDESC_SLOCK
argument_list|(
name|fdp
argument_list|)
expr_stmt|;
if|if
condition|(
name|nd
operator|>
name|td
operator|->
name|td_proc
operator|->
name|p_fd
operator|->
name|fd_nfiles
condition|)
name|nd
operator|=
name|td
operator|->
name|td_proc
operator|->
name|p_fd
operator|->
name|fd_nfiles
expr_stmt|;
comment|/* forgiving; slightly wrong */
name|FILEDESC_SUNLOCK
argument_list|(
name|fdp
argument_list|)
expr_stmt|;
comment|/* 	 * Allocate just enough bits for the non-null fd_sets.  Use the 	 * preallocated auto buffer if possible. 	 */
name|nfdbits
operator|=
name|roundup
argument_list|(
name|nd
argument_list|,
name|NFDBITS
argument_list|)
expr_stmt|;
name|ncpbytes
operator|=
name|nfdbits
operator|/
name|NBBY
expr_stmt|;
name|nbufbytes
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|fd_in
operator|!=
name|NULL
condition|)
name|nbufbytes
operator|+=
literal|2
operator|*
name|ncpbytes
expr_stmt|;
if|if
condition|(
name|fd_ou
operator|!=
name|NULL
condition|)
name|nbufbytes
operator|+=
literal|2
operator|*
name|ncpbytes
expr_stmt|;
if|if
condition|(
name|fd_ex
operator|!=
name|NULL
condition|)
name|nbufbytes
operator|+=
literal|2
operator|*
name|ncpbytes
expr_stmt|;
if|if
condition|(
name|nbufbytes
operator|<=
sizeof|sizeof
name|s_selbits
condition|)
name|selbits
operator|=
operator|&
name|s_selbits
index|[
literal|0
index|]
expr_stmt|;
else|else
name|selbits
operator|=
name|malloc
argument_list|(
name|nbufbytes
argument_list|,
name|M_SELECT
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
comment|/* 	 * Assign pointers into the bit buffers and fetch the input bits. 	 * Put the output buffers together so that they can be bzeroed 	 * together. 	 */
name|sbp
operator|=
name|selbits
expr_stmt|;
define|#
directive|define
name|getbits
parameter_list|(
name|name
parameter_list|,
name|x
parameter_list|)
define|\
value|do {								\ 		if (name == NULL)					\ 			ibits[x] = NULL;				\ 		else {							\ 			ibits[x] = sbp + nbufbytes / 2 / sizeof *sbp;	\ 			obits[x] = sbp;					\ 			sbp += ncpbytes / sizeof *sbp;			\ 			error = copyin(name, ibits[x], ncpbytes);	\ 			if (error != 0)					\ 				goto done;				\ 		}							\ 	} while (0)
name|getbits
argument_list|(
name|fd_in
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|getbits
argument_list|(
name|fd_ou
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|getbits
argument_list|(
name|fd_ex
argument_list|,
literal|2
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|getbits
if|if
condition|(
name|nbufbytes
operator|!=
literal|0
condition|)
name|bzero
argument_list|(
name|selbits
argument_list|,
name|nbufbytes
operator|/
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|tvp
operator|!=
name|NULL
condition|)
block|{
name|atv
operator|=
operator|*
name|tvp
expr_stmt|;
if|if
condition|(
name|itimerfix
argument_list|(
operator|&
name|atv
argument_list|)
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|getmicrouptime
argument_list|(
operator|&
name|rtv
argument_list|)
expr_stmt|;
name|timevaladd
argument_list|(
operator|&
name|atv
argument_list|,
operator|&
name|rtv
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|atv
operator|.
name|tv_sec
operator|=
literal|0
expr_stmt|;
name|atv
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
block|}
name|timo
operator|=
literal|0
expr_stmt|;
name|seltdinit
argument_list|(
name|td
argument_list|)
expr_stmt|;
comment|/* Iterate until the timeout expires or descriptors become ready. */
for|for
control|(
init|;
condition|;
control|)
block|{
name|error
operator|=
name|selscan
argument_list|(
name|td
argument_list|,
name|ibits
argument_list|,
name|obits
argument_list|,
name|nd
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|!=
literal|0
condition|)
break|break;
if|if
condition|(
name|atv
operator|.
name|tv_sec
operator|||
name|atv
operator|.
name|tv_usec
condition|)
block|{
name|getmicrouptime
argument_list|(
operator|&
name|rtv
argument_list|)
expr_stmt|;
if|if
condition|(
name|timevalcmp
argument_list|(
operator|&
name|rtv
argument_list|,
operator|&
name|atv
argument_list|,
operator|>=
argument_list|)
condition|)
break|break;
name|ttv
operator|=
name|atv
expr_stmt|;
name|timevalsub
argument_list|(
operator|&
name|ttv
argument_list|,
operator|&
name|rtv
argument_list|)
expr_stmt|;
name|timo
operator|=
name|ttv
operator|.
name|tv_sec
operator|>
literal|24
operator|*
literal|60
operator|*
literal|60
condition|?
literal|24
operator|*
literal|60
operator|*
literal|60
operator|*
name|hz
else|:
name|tvtohz
argument_list|(
operator|&
name|ttv
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
name|seltdwait
argument_list|(
name|td
argument_list|,
name|timo
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
name|error
operator|=
name|selrescan
argument_list|(
name|td
argument_list|,
name|ibits
argument_list|,
name|obits
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|!=
literal|0
condition|)
break|break;
block|}
name|seltdclear
argument_list|(
name|td
argument_list|)
expr_stmt|;
name|done
label|:
comment|/* select is not restarted after signals... */
if|if
condition|(
name|error
operator|==
name|ERESTART
condition|)
name|error
operator|=
name|EINTR
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|EWOULDBLOCK
condition|)
name|error
operator|=
literal|0
expr_stmt|;
define|#
directive|define
name|putbits
parameter_list|(
name|name
parameter_list|,
name|x
parameter_list|)
define|\
value|if (name&& (error2 = copyout(obits[x], name, ncpbytes))) \ 		error = error2;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|int
name|error2
decl_stmt|;
name|putbits
argument_list|(
name|fd_in
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|putbits
argument_list|(
name|fd_ou
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|putbits
argument_list|(
name|fd_ex
argument_list|,
literal|2
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|putbits
block|}
if|if
condition|(
name|selbits
operator|!=
operator|&
name|s_selbits
index|[
literal|0
index|]
condition|)
name|free
argument_list|(
name|selbits
argument_list|,
name|M_SELECT
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*   * Convert a select bit set to poll flags.  *  * The backend always returns POLLHUP/POLLERR if appropriate and we  * return this as a set bit in any set.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|select_flags
index|[
literal|3
index|]
init|=
block|{
name|POLLRDNORM
operator||
name|POLLHUP
operator||
name|POLLERR
block|,
name|POLLWRNORM
operator||
name|POLLHUP
operator||
name|POLLERR
block|,
name|POLLRDBAND
operator||
name|POLLHUP
operator||
name|POLLERR
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Compute the fo_poll flags required for a fd given by the index and  * bit position in the fd_mask array.  */
end_comment

begin_function
specifier|static
name|__inline
name|int
name|selflags
parameter_list|(
name|fd_mask
modifier|*
modifier|*
name|ibits
parameter_list|,
name|int
name|idx
parameter_list|,
name|fd_mask
name|bit
parameter_list|)
block|{
name|int
name|flags
decl_stmt|;
name|int
name|msk
decl_stmt|;
name|flags
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|msk
operator|=
literal|0
init|;
name|msk
operator|<
literal|3
condition|;
name|msk
operator|++
control|)
block|{
if|if
condition|(
name|ibits
index|[
name|msk
index|]
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
operator|(
name|ibits
index|[
name|msk
index|]
index|[
name|idx
index|]
operator|&
name|bit
operator|)
operator|==
literal|0
condition|)
continue|continue;
name|flags
operator||=
name|select_flags
index|[
name|msk
index|]
expr_stmt|;
block|}
return|return
operator|(
name|flags
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Set the appropriate output bits given a mask of fired events and the  * input bits originally requested.  */
end_comment

begin_function
specifier|static
name|__inline
name|int
name|selsetbits
parameter_list|(
name|fd_mask
modifier|*
modifier|*
name|ibits
parameter_list|,
name|fd_mask
modifier|*
modifier|*
name|obits
parameter_list|,
name|int
name|idx
parameter_list|,
name|fd_mask
name|bit
parameter_list|,
name|int
name|events
parameter_list|)
block|{
name|int
name|msk
decl_stmt|;
name|int
name|n
decl_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|msk
operator|=
literal|0
init|;
name|msk
operator|<
literal|3
condition|;
name|msk
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|events
operator|&
name|select_flags
index|[
name|msk
index|]
operator|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|ibits
index|[
name|msk
index|]
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
operator|(
name|ibits
index|[
name|msk
index|]
index|[
name|idx
index|]
operator|&
name|bit
operator|)
operator|==
literal|0
condition|)
continue|continue;
comment|/* 		 * XXX Check for a duplicate set.  This can occur because a 		 * socket calls selrecord() twice for each poll() call 		 * resulting in two selfds per real fd.  selrescan() will 		 * call selsetbits twice as a result. 		 */
if|if
condition|(
operator|(
name|obits
index|[
name|msk
index|]
index|[
name|idx
index|]
operator|&
name|bit
operator|)
operator|!=
literal|0
condition|)
continue|continue;
name|obits
index|[
name|msk
index|]
index|[
name|idx
index|]
operator||=
name|bit
expr_stmt|;
name|n
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|n
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Traverse the list of fds attached to this thread's seltd and check for  * completion.  */
end_comment

begin_function
specifier|static
name|int
name|selrescan
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|fd_mask
modifier|*
modifier|*
name|ibits
parameter_list|,
name|fd_mask
modifier|*
modifier|*
name|obits
parameter_list|)
block|{
name|struct
name|filedesc
modifier|*
name|fdp
decl_stmt|;
name|struct
name|selinfo
modifier|*
name|si
decl_stmt|;
name|struct
name|seltd
modifier|*
name|stp
decl_stmt|;
name|struct
name|selfd
modifier|*
name|sfp
decl_stmt|;
name|struct
name|selfd
modifier|*
name|sfn
decl_stmt|;
name|struct
name|file
modifier|*
name|fp
decl_stmt|;
name|fd_mask
name|bit
decl_stmt|;
name|int
name|fd
decl_stmt|,
name|ev
decl_stmt|,
name|n
decl_stmt|,
name|idx
decl_stmt|;
name|fdp
operator|=
name|td
operator|->
name|td_proc
operator|->
name|p_fd
expr_stmt|;
name|stp
operator|=
name|td
operator|->
name|td_sel
expr_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
name|STAILQ_FOREACH_SAFE
argument_list|(
argument|sfp
argument_list|,
argument|&stp->st_selq
argument_list|,
argument|sf_link
argument_list|,
argument|sfn
argument_list|)
block|{
name|fd
operator|=
operator|(
name|int
operator|)
operator|(
name|uintptr_t
operator|)
name|sfp
operator|->
name|sf_cookie
expr_stmt|;
name|si
operator|=
name|sfp
operator|->
name|sf_si
expr_stmt|;
name|selfdfree
argument_list|(
name|stp
argument_list|,
name|sfp
argument_list|)
expr_stmt|;
comment|/* If the selinfo wasn't cleared the event didn't fire. */
if|if
condition|(
name|si
operator|!=
name|NULL
condition|)
continue|continue;
if|if
condition|(
operator|(
name|fp
operator|=
name|fget_unlocked
argument_list|(
name|fdp
argument_list|,
name|fd
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|EBADF
operator|)
return|;
name|idx
operator|=
name|fd
operator|/
name|NFDBITS
expr_stmt|;
name|bit
operator|=
operator|(
name|fd_mask
operator|)
literal|1
operator|<<
operator|(
name|fd
operator|%
name|NFDBITS
operator|)
expr_stmt|;
name|ev
operator|=
name|fo_poll
argument_list|(
name|fp
argument_list|,
name|selflags
argument_list|(
name|ibits
argument_list|,
name|idx
argument_list|,
name|bit
argument_list|)
argument_list|,
name|td
operator|->
name|td_ucred
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|fdrop
argument_list|(
name|fp
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|ev
operator|!=
literal|0
condition|)
name|n
operator|+=
name|selsetbits
argument_list|(
name|ibits
argument_list|,
name|obits
argument_list|,
name|idx
argument_list|,
name|bit
argument_list|,
name|ev
argument_list|)
expr_stmt|;
block|}
name|stp
operator|->
name|st_flags
operator|=
literal|0
expr_stmt|;
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|=
name|n
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Perform the initial filedescriptor scan and register ourselves with  * each selinfo.  */
end_comment

begin_function
specifier|static
name|int
name|selscan
parameter_list|(
name|td
parameter_list|,
name|ibits
parameter_list|,
name|obits
parameter_list|,
name|nfd
parameter_list|)
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|fd_mask
modifier|*
modifier|*
name|ibits
decl_stmt|,
decl|*
modifier|*
name|obits
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|nfd
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|filedesc
modifier|*
name|fdp
decl_stmt|;
name|struct
name|file
modifier|*
name|fp
decl_stmt|;
name|fd_mask
name|bit
decl_stmt|;
name|int
name|ev
decl_stmt|,
name|flags
decl_stmt|,
name|end
decl_stmt|,
name|fd
decl_stmt|;
name|int
name|n
decl_stmt|,
name|idx
decl_stmt|;
name|fdp
operator|=
name|td
operator|->
name|td_proc
operator|->
name|p_fd
expr_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|idx
operator|=
literal|0
operator|,
name|fd
operator|=
literal|0
init|;
name|fd
operator|<
name|nfd
condition|;
name|idx
operator|++
control|)
block|{
name|end
operator|=
name|imin
argument_list|(
name|fd
operator|+
name|NFDBITS
argument_list|,
name|nfd
argument_list|)
expr_stmt|;
for|for
control|(
name|bit
operator|=
literal|1
init|;
name|fd
operator|<
name|end
condition|;
name|bit
operator|<<=
literal|1
operator|,
name|fd
operator|++
control|)
block|{
comment|/* Compute the list of events we're interested in. */
name|flags
operator|=
name|selflags
argument_list|(
name|ibits
argument_list|,
name|idx
argument_list|,
name|bit
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
operator|(
name|fp
operator|=
name|fget_unlocked
argument_list|(
name|fdp
argument_list|,
name|fd
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|EBADF
operator|)
return|;
name|selfdalloc
argument_list|(
name|td
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|fd
argument_list|)
expr_stmt|;
name|ev
operator|=
name|fo_poll
argument_list|(
name|fp
argument_list|,
name|flags
argument_list|,
name|td
operator|->
name|td_ucred
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|fdrop
argument_list|(
name|fp
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|ev
operator|!=
literal|0
condition|)
name|n
operator|+=
name|selsetbits
argument_list|(
name|ibits
argument_list|,
name|obits
argument_list|,
name|idx
argument_list|,
name|bit
argument_list|,
name|ev
argument_list|)
expr_stmt|;
block|}
block|}
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|=
name|n
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_ifndef
ifndef|#
directive|ifndef
name|_SYS_SYSPROTO_H_
end_ifndef

begin_struct
struct|struct
name|poll_args
block|{
name|struct
name|pollfd
modifier|*
name|fds
decl_stmt|;
name|u_int
name|nfds
decl_stmt|;
name|int
name|timeout
decl_stmt|;
block|}
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|poll
parameter_list|(
name|td
parameter_list|,
name|uap
parameter_list|)
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|poll_args
modifier|*
name|uap
decl_stmt|;
block|{
name|struct
name|pollfd
modifier|*
name|bits
decl_stmt|;
name|struct
name|pollfd
name|smallbits
index|[
literal|32
index|]
decl_stmt|;
name|struct
name|timeval
name|atv
decl_stmt|,
name|rtv
decl_stmt|,
name|ttv
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|,
name|timo
decl_stmt|;
name|u_int
name|nfds
decl_stmt|;
name|size_t
name|ni
decl_stmt|;
name|nfds
operator|=
name|uap
operator|->
name|nfds
expr_stmt|;
if|if
condition|(
name|nfds
operator|>
name|maxfilesperproc
operator|&&
name|nfds
operator|>
name|FD_SETSIZE
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|ni
operator|=
name|nfds
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|pollfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|ni
operator|>
sizeof|sizeof
argument_list|(
name|smallbits
argument_list|)
condition|)
name|bits
operator|=
name|malloc
argument_list|(
name|ni
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
else|else
name|bits
operator|=
name|smallbits
expr_stmt|;
name|error
operator|=
name|copyin
argument_list|(
name|uap
operator|->
name|fds
argument_list|,
name|bits
argument_list|,
name|ni
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|done
goto|;
if|if
condition|(
name|uap
operator|->
name|timeout
operator|!=
name|INFTIM
condition|)
block|{
name|atv
operator|.
name|tv_sec
operator|=
name|uap
operator|->
name|timeout
operator|/
literal|1000
expr_stmt|;
name|atv
operator|.
name|tv_usec
operator|=
operator|(
name|uap
operator|->
name|timeout
operator|%
literal|1000
operator|)
operator|*
literal|1000
expr_stmt|;
if|if
condition|(
name|itimerfix
argument_list|(
operator|&
name|atv
argument_list|)
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|getmicrouptime
argument_list|(
operator|&
name|rtv
argument_list|)
expr_stmt|;
name|timevaladd
argument_list|(
operator|&
name|atv
argument_list|,
operator|&
name|rtv
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|atv
operator|.
name|tv_sec
operator|=
literal|0
expr_stmt|;
name|atv
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
block|}
name|timo
operator|=
literal|0
expr_stmt|;
name|seltdinit
argument_list|(
name|td
argument_list|)
expr_stmt|;
comment|/* Iterate until the timeout expires or descriptors become ready. */
for|for
control|(
init|;
condition|;
control|)
block|{
name|error
operator|=
name|pollscan
argument_list|(
name|td
argument_list|,
name|bits
argument_list|,
name|nfds
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|!=
literal|0
condition|)
break|break;
if|if
condition|(
name|atv
operator|.
name|tv_sec
operator|||
name|atv
operator|.
name|tv_usec
condition|)
block|{
name|getmicrouptime
argument_list|(
operator|&
name|rtv
argument_list|)
expr_stmt|;
if|if
condition|(
name|timevalcmp
argument_list|(
operator|&
name|rtv
argument_list|,
operator|&
name|atv
argument_list|,
operator|>=
argument_list|)
condition|)
break|break;
name|ttv
operator|=
name|atv
expr_stmt|;
name|timevalsub
argument_list|(
operator|&
name|ttv
argument_list|,
operator|&
name|rtv
argument_list|)
expr_stmt|;
name|timo
operator|=
name|ttv
operator|.
name|tv_sec
operator|>
literal|24
operator|*
literal|60
operator|*
literal|60
condition|?
literal|24
operator|*
literal|60
operator|*
literal|60
operator|*
name|hz
else|:
name|tvtohz
argument_list|(
operator|&
name|ttv
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
name|seltdwait
argument_list|(
name|td
argument_list|,
name|timo
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
name|error
operator|=
name|pollrescan
argument_list|(
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|!=
literal|0
condition|)
break|break;
block|}
name|seltdclear
argument_list|(
name|td
argument_list|)
expr_stmt|;
name|done
label|:
comment|/* poll is not restarted after signals... */
if|if
condition|(
name|error
operator|==
name|ERESTART
condition|)
name|error
operator|=
name|EINTR
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|EWOULDBLOCK
condition|)
name|error
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|pollout
argument_list|(
name|bits
argument_list|,
name|uap
operator|->
name|fds
argument_list|,
name|nfds
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
block|}
name|out
label|:
if|if
condition|(
name|ni
operator|>
sizeof|sizeof
argument_list|(
name|smallbits
argument_list|)
condition|)
name|free
argument_list|(
name|bits
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pollrescan
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|seltd
modifier|*
name|stp
decl_stmt|;
name|struct
name|selfd
modifier|*
name|sfp
decl_stmt|;
name|struct
name|selfd
modifier|*
name|sfn
decl_stmt|;
name|struct
name|selinfo
modifier|*
name|si
decl_stmt|;
name|struct
name|filedesc
modifier|*
name|fdp
decl_stmt|;
name|struct
name|file
modifier|*
name|fp
decl_stmt|;
name|struct
name|pollfd
modifier|*
name|fd
decl_stmt|;
name|int
name|n
decl_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
name|fdp
operator|=
name|td
operator|->
name|td_proc
operator|->
name|p_fd
expr_stmt|;
name|stp
operator|=
name|td
operator|->
name|td_sel
expr_stmt|;
name|FILEDESC_SLOCK
argument_list|(
name|fdp
argument_list|)
expr_stmt|;
name|STAILQ_FOREACH_SAFE
argument_list|(
argument|sfp
argument_list|,
argument|&stp->st_selq
argument_list|,
argument|sf_link
argument_list|,
argument|sfn
argument_list|)
block|{
name|fd
operator|=
operator|(
expr|struct
name|pollfd
operator|*
operator|)
name|sfp
operator|->
name|sf_cookie
expr_stmt|;
name|si
operator|=
name|sfp
operator|->
name|sf_si
expr_stmt|;
name|selfdfree
argument_list|(
name|stp
argument_list|,
name|sfp
argument_list|)
expr_stmt|;
comment|/* If the selinfo wasn't cleared the event didn't fire. */
if|if
condition|(
name|si
operator|!=
name|NULL
condition|)
continue|continue;
name|fp
operator|=
name|fdp
operator|->
name|fd_ofiles
index|[
name|fd
operator|->
name|fd
index|]
expr_stmt|;
if|if
condition|(
name|fp
operator|==
name|NULL
condition|)
block|{
name|fd
operator|->
name|revents
operator|=
name|POLLNVAL
expr_stmt|;
name|n
operator|++
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * Note: backend also returns POLLHUP and 		 * POLLERR if appropriate. 		 */
name|fd
operator|->
name|revents
operator|=
name|fo_poll
argument_list|(
name|fp
argument_list|,
name|fd
operator|->
name|events
argument_list|,
name|td
operator|->
name|td_ucred
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|->
name|revents
operator|!=
literal|0
condition|)
name|n
operator|++
expr_stmt|;
block|}
name|FILEDESC_SUNLOCK
argument_list|(
name|fdp
argument_list|)
expr_stmt|;
name|stp
operator|->
name|st_flags
operator|=
literal|0
expr_stmt|;
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|=
name|n
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pollout
parameter_list|(
name|fds
parameter_list|,
name|ufds
parameter_list|,
name|nfd
parameter_list|)
name|struct
name|pollfd
modifier|*
name|fds
decl_stmt|;
name|struct
name|pollfd
modifier|*
name|ufds
decl_stmt|;
name|u_int
name|nfd
decl_stmt|;
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
name|u_int
name|i
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nfd
condition|;
name|i
operator|++
control|)
block|{
name|error
operator|=
name|copyout
argument_list|(
operator|&
name|fds
operator|->
name|revents
argument_list|,
operator|&
name|ufds
operator|->
name|revents
argument_list|,
sizeof|sizeof
argument_list|(
name|ufds
operator|->
name|revents
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|fds
operator|++
expr_stmt|;
name|ufds
operator|++
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pollscan
parameter_list|(
name|td
parameter_list|,
name|fds
parameter_list|,
name|nfd
parameter_list|)
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|pollfd
modifier|*
name|fds
decl_stmt|;
name|u_int
name|nfd
decl_stmt|;
block|{
name|struct
name|filedesc
modifier|*
name|fdp
init|=
name|td
operator|->
name|td_proc
operator|->
name|p_fd
decl_stmt|;
name|int
name|i
decl_stmt|;
name|struct
name|file
modifier|*
name|fp
decl_stmt|;
name|int
name|n
init|=
literal|0
decl_stmt|;
name|FILEDESC_SLOCK
argument_list|(
name|fdp
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nfd
condition|;
name|i
operator|++
operator|,
name|fds
operator|++
control|)
block|{
if|if
condition|(
name|fds
operator|->
name|fd
operator|>=
name|fdp
operator|->
name|fd_nfiles
condition|)
block|{
name|fds
operator|->
name|revents
operator|=
name|POLLNVAL
expr_stmt|;
name|n
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fds
operator|->
name|fd
operator|<
literal|0
condition|)
block|{
name|fds
operator|->
name|revents
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|fp
operator|=
name|fdp
operator|->
name|fd_ofiles
index|[
name|fds
operator|->
name|fd
index|]
expr_stmt|;
if|if
condition|(
name|fp
operator|==
name|NULL
condition|)
block|{
name|fds
operator|->
name|revents
operator|=
name|POLLNVAL
expr_stmt|;
name|n
operator|++
expr_stmt|;
block|}
else|else
block|{
comment|/* 				 * Note: backend also returns POLLHUP and 				 * POLLERR if appropriate. 				 */
name|selfdalloc
argument_list|(
name|td
argument_list|,
name|fds
argument_list|)
expr_stmt|;
name|fds
operator|->
name|revents
operator|=
name|fo_poll
argument_list|(
name|fp
argument_list|,
name|fds
operator|->
name|events
argument_list|,
name|td
operator|->
name|td_ucred
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|fds
operator|->
name|revents
operator|!=
literal|0
condition|)
name|n
operator|++
expr_stmt|;
block|}
block|}
block|}
name|FILEDESC_SUNLOCK
argument_list|(
name|fdp
argument_list|)
expr_stmt|;
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|=
name|n
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * OpenBSD poll system call.  *  * XXX this isn't quite a true representation..  OpenBSD uses select ops.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|_SYS_SYSPROTO_H_
end_ifndef

begin_struct
struct|struct
name|openbsd_poll_args
block|{
name|struct
name|pollfd
modifier|*
name|fds
decl_stmt|;
name|u_int
name|nfds
decl_stmt|;
name|int
name|timeout
decl_stmt|;
block|}
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|openbsd_poll
parameter_list|(
name|td
parameter_list|,
name|uap
parameter_list|)
specifier|register
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
specifier|register
name|struct
name|openbsd_poll_args
modifier|*
name|uap
decl_stmt|;
block|{
return|return
operator|(
name|poll
argument_list|(
name|td
argument_list|,
operator|(
expr|struct
name|poll_args
operator|*
operator|)
name|uap
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * XXX This was created specifically to support netncp and netsmb.  This  * allows the caller to specify a socket to wait for events on.  It returns  * 0 if any events matched and an error otherwise.  There is no way to  * determine which events fired.  */
end_comment

begin_function
name|int
name|selsocket
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|int
name|events
parameter_list|,
name|struct
name|timeval
modifier|*
name|tvp
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|timeval
name|atv
decl_stmt|,
name|rtv
decl_stmt|,
name|ttv
decl_stmt|;
name|int
name|error
decl_stmt|,
name|timo
decl_stmt|;
if|if
condition|(
name|tvp
operator|!=
name|NULL
condition|)
block|{
name|atv
operator|=
operator|*
name|tvp
expr_stmt|;
if|if
condition|(
name|itimerfix
argument_list|(
operator|&
name|atv
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|getmicrouptime
argument_list|(
operator|&
name|rtv
argument_list|)
expr_stmt|;
name|timevaladd
argument_list|(
operator|&
name|atv
argument_list|,
operator|&
name|rtv
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|atv
operator|.
name|tv_sec
operator|=
literal|0
expr_stmt|;
name|atv
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
block|}
name|timo
operator|=
literal|0
expr_stmt|;
name|seltdinit
argument_list|(
name|td
argument_list|)
expr_stmt|;
comment|/* 	 * Iterate until the timeout expires or the socket becomes ready. 	 */
for|for
control|(
init|;
condition|;
control|)
block|{
name|selfdalloc
argument_list|(
name|td
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|error
operator|=
name|sopoll
argument_list|(
name|so
argument_list|,
name|events
argument_list|,
name|NULL
argument_list|,
name|td
argument_list|)
expr_stmt|;
comment|/* error here is actually the ready events. */
if|if
condition|(
name|error
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|atv
operator|.
name|tv_sec
operator|||
name|atv
operator|.
name|tv_usec
condition|)
block|{
name|getmicrouptime
argument_list|(
operator|&
name|rtv
argument_list|)
expr_stmt|;
if|if
condition|(
name|timevalcmp
argument_list|(
operator|&
name|rtv
argument_list|,
operator|&
name|atv
argument_list|,
operator|>=
argument_list|)
condition|)
block|{
name|seltdclear
argument_list|(
name|td
argument_list|)
expr_stmt|;
return|return
operator|(
name|EWOULDBLOCK
operator|)
return|;
block|}
name|ttv
operator|=
name|atv
expr_stmt|;
name|timevalsub
argument_list|(
operator|&
name|ttv
argument_list|,
operator|&
name|rtv
argument_list|)
expr_stmt|;
name|timo
operator|=
name|ttv
operator|.
name|tv_sec
operator|>
literal|24
operator|*
literal|60
operator|*
literal|60
condition|?
literal|24
operator|*
literal|60
operator|*
literal|60
operator|*
name|hz
else|:
name|tvtohz
argument_list|(
operator|&
name|ttv
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
name|seltdwait
argument_list|(
name|td
argument_list|,
name|timo
argument_list|)
expr_stmt|;
name|seltdclear
argument_list|(
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
block|}
comment|/* XXX Duplicates ncp/smb behavior. */
if|if
condition|(
name|error
operator|==
name|ERESTART
condition|)
name|error
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Preallocate two selfds associated with 'cookie'.  Some fo_poll routines  * have two select sets, one for read and another for write.  */
end_comment

begin_function
specifier|static
name|void
name|selfdalloc
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|void
modifier|*
name|cookie
parameter_list|)
block|{
name|struct
name|seltd
modifier|*
name|stp
decl_stmt|;
name|stp
operator|=
name|td
operator|->
name|td_sel
expr_stmt|;
if|if
condition|(
name|stp
operator|->
name|st_free1
operator|==
name|NULL
condition|)
name|stp
operator|->
name|st_free1
operator|=
name|uma_zalloc
argument_list|(
name|selfd_zone
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|stp
operator|->
name|st_free1
operator|->
name|sf_td
operator|=
name|stp
expr_stmt|;
name|stp
operator|->
name|st_free1
operator|->
name|sf_cookie
operator|=
name|cookie
expr_stmt|;
if|if
condition|(
name|stp
operator|->
name|st_free2
operator|==
name|NULL
condition|)
name|stp
operator|->
name|st_free2
operator|=
name|uma_zalloc
argument_list|(
name|selfd_zone
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|stp
operator|->
name|st_free2
operator|->
name|sf_td
operator|=
name|stp
expr_stmt|;
name|stp
operator|->
name|st_free2
operator|->
name|sf_cookie
operator|=
name|cookie
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|selfdfree
parameter_list|(
name|struct
name|seltd
modifier|*
name|stp
parameter_list|,
name|struct
name|selfd
modifier|*
name|sfp
parameter_list|)
block|{
name|STAILQ_REMOVE
argument_list|(
operator|&
name|stp
operator|->
name|st_selq
argument_list|,
name|sfp
argument_list|,
name|selfd
argument_list|,
name|sf_link
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
name|sfp
operator|->
name|sf_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|sfp
operator|->
name|sf_si
condition|)
name|TAILQ_REMOVE
argument_list|(
operator|&
name|sfp
operator|->
name|sf_si
operator|->
name|si_tdlist
argument_list|,
name|sfp
argument_list|,
name|sf_threads
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
name|sfp
operator|->
name|sf_mtx
argument_list|)
expr_stmt|;
name|uma_zfree
argument_list|(
name|selfd_zone
argument_list|,
name|sfp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Record a select request.  */
end_comment

begin_function
name|void
name|selrecord
parameter_list|(
name|selector
parameter_list|,
name|sip
parameter_list|)
name|struct
name|thread
modifier|*
name|selector
decl_stmt|;
name|struct
name|selinfo
modifier|*
name|sip
decl_stmt|;
block|{
name|struct
name|selfd
modifier|*
name|sfp
decl_stmt|;
name|struct
name|seltd
modifier|*
name|stp
decl_stmt|;
name|struct
name|mtx
modifier|*
name|mtxp
decl_stmt|;
name|stp
operator|=
name|selector
operator|->
name|td_sel
expr_stmt|;
comment|/* 	 * Don't record when doing a rescan. 	 */
if|if
condition|(
name|stp
operator|->
name|st_flags
operator|&
name|SELTD_RESCAN
condition|)
return|return;
comment|/* 	 * Grab one of the preallocated descriptors. 	 */
name|sfp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|sfp
operator|=
name|stp
operator|->
name|st_free1
operator|)
operator|!=
name|NULL
condition|)
name|stp
operator|->
name|st_free1
operator|=
name|NULL
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|sfp
operator|=
name|stp
operator|->
name|st_free2
operator|)
operator|!=
name|NULL
condition|)
name|stp
operator|->
name|st_free2
operator|=
name|NULL
expr_stmt|;
else|else
name|panic
argument_list|(
literal|"selrecord: No free selfd on selq"
argument_list|)
expr_stmt|;
name|mtxp
operator|=
name|mtx_pool_find
argument_list|(
name|mtxpool_sleep
argument_list|,
name|sip
argument_list|)
expr_stmt|;
comment|/* 	 * Initialize the sfp and queue it in the thread. 	 */
name|sfp
operator|->
name|sf_si
operator|=
name|sip
expr_stmt|;
name|sfp
operator|->
name|sf_mtx
operator|=
name|mtxp
expr_stmt|;
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|stp
operator|->
name|st_selq
argument_list|,
name|sfp
argument_list|,
name|sf_link
argument_list|)
expr_stmt|;
comment|/* 	 * Now that we've locked the sip, check for initialization. 	 */
name|mtx_lock
argument_list|(
name|mtxp
argument_list|)
expr_stmt|;
if|if
condition|(
name|sip
operator|->
name|si_mtx
operator|==
name|NULL
condition|)
block|{
name|sip
operator|->
name|si_mtx
operator|=
name|mtxp
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|sip
operator|->
name|si_tdlist
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Add this thread to the list of selfds listening on this selinfo. 	 */
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|sip
operator|->
name|si_tdlist
argument_list|,
name|sfp
argument_list|,
name|sf_threads
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
name|sip
operator|->
name|si_mtx
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Wake up a selecting thread. */
end_comment

begin_function
name|void
name|selwakeup
parameter_list|(
name|sip
parameter_list|)
name|struct
name|selinfo
modifier|*
name|sip
decl_stmt|;
block|{
name|doselwakeup
argument_list|(
name|sip
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Wake up a selecting thread, and set its priority. */
end_comment

begin_function
name|void
name|selwakeuppri
parameter_list|(
name|sip
parameter_list|,
name|pri
parameter_list|)
name|struct
name|selinfo
modifier|*
name|sip
decl_stmt|;
name|int
name|pri
decl_stmt|;
block|{
name|doselwakeup
argument_list|(
name|sip
argument_list|,
name|pri
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Do a wakeup when a selectable event occurs.  */
end_comment

begin_function
specifier|static
name|void
name|doselwakeup
parameter_list|(
name|sip
parameter_list|,
name|pri
parameter_list|)
name|struct
name|selinfo
modifier|*
name|sip
decl_stmt|;
name|int
name|pri
decl_stmt|;
block|{
name|struct
name|selfd
modifier|*
name|sfp
decl_stmt|;
name|struct
name|selfd
modifier|*
name|sfn
decl_stmt|;
name|struct
name|seltd
modifier|*
name|stp
decl_stmt|;
comment|/* If it's not initialized there can't be any waiters. */
if|if
condition|(
name|sip
operator|->
name|si_mtx
operator|==
name|NULL
condition|)
return|return;
comment|/* 	 * Locking the selinfo locks all selfds associated with it. 	 */
name|mtx_lock
argument_list|(
name|sip
operator|->
name|si_mtx
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|sfp
argument_list|,
argument|&sip->si_tdlist
argument_list|,
argument|sf_threads
argument_list|,
argument|sfn
argument_list|)
block|{
comment|/* 		 * Once we remove this sfp from the list and clear the 		 * sf_si seltdclear will know to ignore this si. 		 */
name|TAILQ_REMOVE
argument_list|(
operator|&
name|sip
operator|->
name|si_tdlist
argument_list|,
name|sfp
argument_list|,
name|sf_threads
argument_list|)
expr_stmt|;
name|sfp
operator|->
name|sf_si
operator|=
name|NULL
expr_stmt|;
name|stp
operator|=
name|sfp
operator|->
name|sf_td
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|stp
operator|->
name|st_mtx
argument_list|)
expr_stmt|;
name|stp
operator|->
name|st_flags
operator||=
name|SELTD_PENDING
expr_stmt|;
name|cv_broadcastpri
argument_list|(
operator|&
name|stp
operator|->
name|st_wait
argument_list|,
name|pri
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|stp
operator|->
name|st_mtx
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
name|sip
operator|->
name|si_mtx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|seltdinit
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|seltd
modifier|*
name|stp
decl_stmt|;
if|if
condition|(
operator|(
name|stp
operator|=
name|td
operator|->
name|td_sel
operator|)
operator|!=
name|NULL
condition|)
goto|goto
name|out
goto|;
name|td
operator|->
name|td_sel
operator|=
name|stp
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|stp
argument_list|)
argument_list|,
name|M_SELECT
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|stp
operator|->
name|st_mtx
argument_list|,
literal|"sellck"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|cv_init
argument_list|(
operator|&
name|stp
operator|->
name|st_wait
argument_list|,
literal|"select"
argument_list|)
expr_stmt|;
name|out
label|:
name|stp
operator|->
name|st_flags
operator|=
literal|0
expr_stmt|;
name|STAILQ_INIT
argument_list|(
operator|&
name|stp
operator|->
name|st_selq
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|seltdwait
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|int
name|timo
parameter_list|)
block|{
name|struct
name|seltd
modifier|*
name|stp
decl_stmt|;
name|int
name|error
decl_stmt|;
name|stp
operator|=
name|td
operator|->
name|td_sel
expr_stmt|;
comment|/* 	 * An event of interest may occur while we do not hold the seltd 	 * locked so check the pending flag before we sleep. 	 */
name|mtx_lock
argument_list|(
operator|&
name|stp
operator|->
name|st_mtx
argument_list|)
expr_stmt|;
comment|/* 	 * Any further calls to selrecord will be a rescan. 	 */
name|stp
operator|->
name|st_flags
operator||=
name|SELTD_RESCAN
expr_stmt|;
if|if
condition|(
name|stp
operator|->
name|st_flags
operator|&
name|SELTD_PENDING
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|stp
operator|->
name|st_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|timo
operator|>
literal|0
condition|)
name|error
operator|=
name|cv_timedwait_sig
argument_list|(
operator|&
name|stp
operator|->
name|st_wait
argument_list|,
operator|&
name|stp
operator|->
name|st_mtx
argument_list|,
name|timo
argument_list|)
expr_stmt|;
else|else
name|error
operator|=
name|cv_wait_sig
argument_list|(
operator|&
name|stp
operator|->
name|st_wait
argument_list|,
operator|&
name|stp
operator|->
name|st_mtx
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|stp
operator|->
name|st_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|void
name|seltdfini
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|seltd
modifier|*
name|stp
decl_stmt|;
name|stp
operator|=
name|td
operator|->
name|td_sel
expr_stmt|;
if|if
condition|(
name|stp
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|stp
operator|->
name|st_free1
condition|)
name|uma_zfree
argument_list|(
name|selfd_zone
argument_list|,
name|stp
operator|->
name|st_free1
argument_list|)
expr_stmt|;
if|if
condition|(
name|stp
operator|->
name|st_free2
condition|)
name|uma_zfree
argument_list|(
name|selfd_zone
argument_list|,
name|stp
operator|->
name|st_free2
argument_list|)
expr_stmt|;
name|td
operator|->
name|td_sel
operator|=
name|NULL
expr_stmt|;
name|free
argument_list|(
name|stp
argument_list|,
name|M_SELECT
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Remove the references to the thread from all of the objects we were  * polling.  */
end_comment

begin_function
specifier|static
name|void
name|seltdclear
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|seltd
modifier|*
name|stp
decl_stmt|;
name|struct
name|selfd
modifier|*
name|sfp
decl_stmt|;
name|struct
name|selfd
modifier|*
name|sfn
decl_stmt|;
name|stp
operator|=
name|td
operator|->
name|td_sel
expr_stmt|;
name|STAILQ_FOREACH_SAFE
argument_list|(
argument|sfp
argument_list|,
argument|&stp->st_selq
argument_list|,
argument|sf_link
argument_list|,
argument|sfn
argument_list|)
name|selfdfree
argument_list|(
name|stp
argument_list|,
name|sfp
argument_list|)
expr_stmt|;
name|stp
operator|->
name|st_flags
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function_decl
specifier|static
name|void
name|selectinit
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_expr_stmt
name|SYSINIT
argument_list|(
name|select
argument_list|,
name|SI_SUB_SYSCALLS
argument_list|,
name|SI_ORDER_ANY
argument_list|,
name|selectinit
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|void
name|selectinit
parameter_list|(
name|void
modifier|*
name|dummy
name|__unused
parameter_list|)
block|{
name|selfd_zone
operator|=
name|uma_zcreate
argument_list|(
literal|"selfd"
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|selfd
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|UMA_ALIGN_PTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

