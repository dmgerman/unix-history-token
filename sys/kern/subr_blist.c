begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * BLIST.C -	Bitmap allocator/deallocator, using a radix tree with hinting  *  *	(c)Copyright 1998, Matthew Dillon.  Terms for use and redistribution  *	are covered by the BSD Copyright as found in /usr/src/COPYRIGHT.  *  *	This module implements a general bitmap allocator/deallocator.  The  *	allocator eats around 2 bits per 'block'.  The module does not   *	try to interpret the meaning of a 'block' other then to return   *	SWAPBLK_NONE on an allocation failure.  *  *	A radix tree is used to maintain the bitmap.  Two radix constants are  *	involved:  One for the bitmaps contained in the leaf nodes (typically  *	32), and one for the meta nodes (typically 16).  Both meta and leaf  *	nodes have a hint field.  This field gives us a hint as to the largest  *	free contiguous range of blocks under the node.  It may contain a  *	value that is too high, but will never contain a value that is too   *	low.  When the radix tree is searched, allocation failures in subtrees  *	update the hint.   *  *	The radix tree also implements two collapsed states for meta nodes:  *	the ALL-ALLOCATED state and the ALL-FREE state.  If a meta node is  *	in either of these two states, all information contained underneath  *	the node is considered stale.  These states are used to optimize  *	allocation and freeing operations.  *  * 	The hinting greatly increases code efficiency for allocations while  *	the general radix structure optimizes both allocations and frees.  The  *	radix tree should be able to operate well no matter how much   *	fragmentation there is and no matter how large a bitmap is used.  *  *	Unlike the rlist code, the blist code wires all necessary memory at  *	creation time.  Neither allocations nor frees require interaction with  *	the memory subsystem.  In contrast, the rlist code may allocate memory   *	on an rlist_free() call.  The non-blocking features of the blist code  *	are used to great advantage in the swap code (vm/nswap_pager.c).  The  *	rlist code uses a little less overall memory then the blist code (but  *	due to swap interleaving not all that much less), but the blist code   *	scales much, much better.  *  *	LAYOUT: The radix tree is layed out recursively using a  *	linear array.  Each meta node is immediately followed (layed out  *	sequentially in memory) by BLIST_META_RADIX lower level nodes.  This  *	is a recursive structure but one that can be easily scanned through  *	a very simple 'skip' calculation.  In order to support large radixes,   *	portions of the tree may reside outside our memory allocation.  We   *	handle this with an early-termination optimization (when bighint is   *	set to -1) on the scan.  The memory allocation is only large enough   *	to cover the number of blocks requested at creation time even if it  *	must be encompassed in larger root-node radix.  *  *	NOTE: the allocator cannot currently allocate more then   *	BLIST_BMAP_RADIX blocks per call.  It will panic with 'allocation too   *	large' if you try.  This is an area that could use improvement.  The   *	radix is large enough that this restriction does not effect the swap   *	system, though.  Currently only the allocation code is effected by  *	this algorithmic unfeature.  The freeing code can handle arbitrary  *	ranges.  *  *	This code can be compiled stand-alone for debugging.  *  *	$Id$  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|KERNEL
end_ifdef

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/blist.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_prot.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_object.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_kern.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_extern.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_page.h>
end_include

begin_else
else|#
directive|else
end_else

begin_ifndef
ifndef|#
directive|ifndef
name|BLIST_NO_DEBUG
end_ifndef

begin_define
define|#
directive|define
name|BLIST_DEBUG
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|SWAPBLK_NONE
value|((daddr_t)-1)
end_define

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_define
define|#
directive|define
name|malloc
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|)
value|malloc(a)
end_define

begin_define
define|#
directive|define
name|free
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|free(a)
end_define

begin_typedef
typedef|typedef
name|unsigned
name|int
name|u_daddr_t
typedef|;
end_typedef

begin_include
include|#
directive|include
file|<sys/blist.h>
end_include

begin_function_decl
name|void
name|panic
parameter_list|(
specifier|const
name|char
modifier|*
name|ctl
parameter_list|,
modifier|...
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * static support functions  */
end_comment

begin_function_decl
specifier|static
name|daddr_t
name|blst_leaf_alloc
parameter_list|(
name|blmeta_t
modifier|*
name|scan
parameter_list|,
name|daddr_t
name|blk
parameter_list|,
name|int
name|count
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|daddr_t
name|blst_meta_alloc
parameter_list|(
name|blmeta_t
modifier|*
name|scan
parameter_list|,
name|daddr_t
name|blk
parameter_list|,
name|daddr_t
name|count
parameter_list|,
name|daddr_t
name|radix
parameter_list|,
name|int
name|skip
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|blst_leaf_free
parameter_list|(
name|blmeta_t
modifier|*
name|scan
parameter_list|,
name|daddr_t
name|relblk
parameter_list|,
name|int
name|count
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|blst_meta_free
parameter_list|(
name|blmeta_t
modifier|*
name|scan
parameter_list|,
name|daddr_t
name|freeBlk
parameter_list|,
name|daddr_t
name|count
parameter_list|,
name|daddr_t
name|radix
parameter_list|,
name|int
name|skip
parameter_list|,
name|daddr_t
name|blk
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|blst_copy
parameter_list|(
name|blmeta_t
modifier|*
name|scan
parameter_list|,
name|daddr_t
name|blk
parameter_list|,
name|daddr_t
name|radix
parameter_list|,
name|daddr_t
name|skip
parameter_list|,
name|blist_t
name|dest
parameter_list|,
name|daddr_t
name|count
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|daddr_t
name|blst_radix_init
parameter_list|(
name|blmeta_t
modifier|*
name|scan
parameter_list|,
name|daddr_t
name|radix
parameter_list|,
name|int
name|skip
parameter_list|,
name|daddr_t
name|count
parameter_list|)
function_decl|;
end_function_decl

begin_ifndef
ifndef|#
directive|ifndef
name|KERNEL
end_ifndef

begin_function_decl
specifier|static
name|void
name|blst_radix_print
parameter_list|(
name|blmeta_t
modifier|*
name|scan
parameter_list|,
name|daddr_t
name|blk
parameter_list|,
name|daddr_t
name|radix
parameter_list|,
name|int
name|skip
parameter_list|,
name|int
name|tab
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|KERNEL
end_ifdef

begin_expr_stmt
specifier|static
name|MALLOC_DEFINE
argument_list|(
name|M_SWAP
argument_list|,
literal|"SWAP"
argument_list|,
literal|"Swap space"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * blist_create() - create a blist capable of handling up to the specified  *		    number of blocks  *  *	blocks must be greater then 0  *  *	The smallest blist consists of a single leaf node capable of   *	managing BLIST_BMAP_RADIX blocks.  */
end_comment

begin_function
name|blist_t
name|blist_create
parameter_list|(
name|daddr_t
name|blocks
parameter_list|)
block|{
name|blist_t
name|bl
decl_stmt|;
name|int
name|radix
decl_stmt|;
name|int
name|skip
init|=
literal|0
decl_stmt|;
comment|/* 	 * Calculate radix and skip field used for scanning. 	 */
name|radix
operator|=
name|BLIST_BMAP_RADIX
expr_stmt|;
while|while
condition|(
name|radix
operator|<
name|blocks
condition|)
block|{
name|radix
operator|<<=
name|BLIST_META_RADIX_SHIFT
expr_stmt|;
name|skip
operator|=
operator|(
name|skip
operator|+
literal|1
operator|)
operator|<<
name|BLIST_META_RADIX_SHIFT
expr_stmt|;
block|}
name|bl
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|blist
argument_list|)
argument_list|,
name|M_SWAP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|bl
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|bl
argument_list|)
argument_list|)
expr_stmt|;
name|bl
operator|->
name|bl_blocks
operator|=
name|blocks
expr_stmt|;
name|bl
operator|->
name|bl_radix
operator|=
name|radix
expr_stmt|;
name|bl
operator|->
name|bl_skip
operator|=
name|skip
expr_stmt|;
name|bl
operator|->
name|bl_rootblks
operator|=
literal|1
operator|+
name|blst_radix_init
argument_list|(
name|NULL
argument_list|,
name|bl
operator|->
name|bl_radix
argument_list|,
name|bl
operator|->
name|bl_skip
argument_list|,
name|blocks
argument_list|)
expr_stmt|;
name|bl
operator|->
name|bl_root
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|blmeta_t
argument_list|)
operator|*
name|bl
operator|->
name|bl_rootblks
argument_list|,
name|M_SWAP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|BLIST_DEBUG
argument_list|)
name|printf
argument_list|(
literal|"BLIST representing %d blocks (%d MB of swap)"
literal|", requiring %dK of ram\n"
argument_list|,
name|bl
operator|->
name|bl_blocks
argument_list|,
name|bl
operator|->
name|bl_blocks
operator|*
literal|4
operator|/
literal|1024
argument_list|,
operator|(
name|bl
operator|->
name|bl_rootblks
operator|*
sizeof|sizeof
argument_list|(
name|blmeta_t
argument_list|)
operator|+
literal|1023
operator|)
operator|/
literal|1024
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"BLIST raw radix tree contains %d records\n"
argument_list|,
name|bl
operator|->
name|bl_rootblks
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|blst_radix_init
argument_list|(
name|bl
operator|->
name|bl_root
argument_list|,
name|bl
operator|->
name|bl_radix
argument_list|,
name|bl
operator|->
name|bl_skip
argument_list|,
name|blocks
argument_list|)
expr_stmt|;
return|return
operator|(
name|bl
operator|)
return|;
block|}
end_function

begin_function
name|void
name|blist_destroy
parameter_list|(
name|blist_t
name|bl
parameter_list|)
block|{
name|free
argument_list|(
name|bl
operator|->
name|bl_root
argument_list|,
name|M_SWAP
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|bl
argument_list|,
name|M_SWAP
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * blist_alloc() - reserve space in the block bitmap.  Return the base  *		     of a contiguous region or SWAPBLK_NONE if space could  *		     not be allocated.  */
end_comment

begin_function
name|daddr_t
name|blist_alloc
parameter_list|(
name|blist_t
name|bl
parameter_list|,
name|daddr_t
name|count
parameter_list|)
block|{
name|daddr_t
name|blk
init|=
name|SWAPBLK_NONE
decl_stmt|;
if|if
condition|(
name|bl
condition|)
block|{
if|if
condition|(
name|bl
operator|->
name|bl_radix
operator|==
name|BLIST_BMAP_RADIX
condition|)
name|blk
operator|=
name|blst_leaf_alloc
argument_list|(
name|bl
operator|->
name|bl_root
argument_list|,
literal|0
argument_list|,
name|count
argument_list|)
expr_stmt|;
else|else
name|blk
operator|=
name|blst_meta_alloc
argument_list|(
name|bl
operator|->
name|bl_root
argument_list|,
literal|0
argument_list|,
name|count
argument_list|,
name|bl
operator|->
name|bl_radix
argument_list|,
name|bl
operator|->
name|bl_skip
argument_list|)
expr_stmt|;
if|if
condition|(
name|blk
operator|!=
name|SWAPBLK_NONE
condition|)
name|bl
operator|->
name|bl_free
operator|-=
name|count
expr_stmt|;
block|}
return|return
operator|(
name|blk
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * blist_free() -	free up space in the block bitmap.  Return the base  *		     	of a contiguous region.  Panic if an inconsistancy is  *			found.  */
end_comment

begin_function
name|void
name|blist_free
parameter_list|(
name|blist_t
name|bl
parameter_list|,
name|daddr_t
name|blkno
parameter_list|,
name|daddr_t
name|count
parameter_list|)
block|{
if|if
condition|(
name|bl
condition|)
block|{
if|if
condition|(
name|bl
operator|->
name|bl_radix
operator|==
name|BLIST_BMAP_RADIX
condition|)
name|blst_leaf_free
argument_list|(
name|bl
operator|->
name|bl_root
argument_list|,
name|blkno
argument_list|,
name|count
argument_list|)
expr_stmt|;
else|else
name|blst_meta_free
argument_list|(
name|bl
operator|->
name|bl_root
argument_list|,
name|blkno
argument_list|,
name|count
argument_list|,
name|bl
operator|->
name|bl_radix
argument_list|,
name|bl
operator|->
name|bl_skip
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bl
operator|->
name|bl_free
operator|+=
name|count
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * blist_resize() -	resize an existing radix tree to handle the  *			specified number of blocks.  This will reallocate  *			the tree and transfer the previous bitmap to the new  *			one.  When extending the tree you can specify whether  *			the new blocks are to left allocated or freed.  */
end_comment

begin_function
name|void
name|blist_resize
parameter_list|(
name|blist_t
modifier|*
name|pbl
parameter_list|,
name|daddr_t
name|count
parameter_list|,
name|int
name|freenew
parameter_list|)
block|{
name|blist_t
name|newbl
init|=
name|blist_create
argument_list|(
name|count
argument_list|)
decl_stmt|;
name|blist_t
name|save
init|=
operator|*
name|pbl
decl_stmt|;
operator|*
name|pbl
operator|=
name|newbl
expr_stmt|;
if|if
condition|(
name|count
operator|>
name|save
operator|->
name|bl_blocks
condition|)
name|count
operator|=
name|save
operator|->
name|bl_blocks
expr_stmt|;
name|blst_copy
argument_list|(
name|save
operator|->
name|bl_root
argument_list|,
literal|0
argument_list|,
name|save
operator|->
name|bl_radix
argument_list|,
name|save
operator|->
name|bl_skip
argument_list|,
name|newbl
argument_list|,
name|count
argument_list|)
expr_stmt|;
comment|/*      * If resizing upwards, should we free the new space or not?      */
if|if
condition|(
name|freenew
operator|&&
name|count
operator|<
name|newbl
operator|->
name|bl_blocks
condition|)
block|{
name|blist_free
argument_list|(
name|newbl
argument_list|,
name|count
argument_list|,
name|newbl
operator|->
name|bl_blocks
operator|-
name|count
argument_list|)
expr_stmt|;
block|}
name|blist_destroy
argument_list|(
name|save
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|BLIST_DEBUG
end_ifdef

begin_comment
comment|/*  * blist_print()    - dump radix tree  */
end_comment

begin_function
name|void
name|blist_print
parameter_list|(
name|blist_t
name|bl
parameter_list|)
block|{
name|printf
argument_list|(
literal|"BLIST {\n"
argument_list|)
expr_stmt|;
name|blst_radix_print
argument_list|(
name|bl
operator|->
name|bl_root
argument_list|,
literal|0
argument_list|,
name|bl
operator|->
name|bl_radix
argument_list|,
name|bl
operator|->
name|bl_skip
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"}\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/************************************************************************  *			  ALLOCATION SUPPORT FUNCTIONS			*  ************************************************************************  *  *	These support functions do all the actual work.  They may seem   *	rather longish, but that's because I've commented them up.  The  *	actual code is straight forward.  *  */
end_comment

begin_comment
comment|/*  * blist_leaf_alloc() -	allocate at a leaf in the radix tree (a bitmap).  *  *	This is the core of the allocator and is optimized for the 1 block  *	and the BLIST_BMAP_RADIX block allocation cases.  Other cases are  *	somewhat slower.  The 1 block allocation case is log2 and extremely  *	quick.  */
end_comment

begin_function
specifier|static
name|daddr_t
name|blst_leaf_alloc
parameter_list|(
name|blmeta_t
modifier|*
name|scan
parameter_list|,
name|daddr_t
name|blk
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|u_daddr_t
name|orig
init|=
name|scan
operator|->
name|u
operator|.
name|bmu_bitmap
decl_stmt|;
if|if
condition|(
name|orig
operator|==
literal|0
condition|)
block|{
comment|/* 		 * Optimize bitmap all-allocated case.  Also, count = 1 		 * case assumes at least 1 bit is free in the bitmap, so 		 * we have to take care of this case here. 		 */
name|scan
operator|->
name|bm_bighint
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|SWAPBLK_NONE
operator|)
return|;
block|}
if|if
condition|(
name|count
operator|==
literal|1
condition|)
block|{
comment|/* 		 * Optimized code to allocate one bit out of the bitmap 		 */
name|u_daddr_t
name|mask
decl_stmt|;
name|int
name|j
init|=
name|BLIST_BMAP_RADIX
operator|/
literal|2
decl_stmt|;
name|int
name|r
init|=
literal|0
decl_stmt|;
name|mask
operator|=
operator|(
name|u_daddr_t
operator|)
operator|-
literal|1
operator|>>
operator|(
name|BLIST_BMAP_RADIX
operator|/
literal|2
operator|)
expr_stmt|;
while|while
condition|(
name|j
condition|)
block|{
if|if
condition|(
operator|(
name|orig
operator|&
name|mask
operator|)
operator|==
literal|0
condition|)
block|{
name|r
operator|+=
name|j
expr_stmt|;
name|orig
operator|>>=
name|j
expr_stmt|;
block|}
name|j
operator|>>=
literal|1
expr_stmt|;
name|mask
operator|>>=
name|j
expr_stmt|;
block|}
name|scan
operator|->
name|u
operator|.
name|bmu_bitmap
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|r
operator|)
expr_stmt|;
return|return
operator|(
name|blk
operator|+
name|r
operator|)
return|;
block|}
if|if
condition|(
name|count
operator|<=
name|BLIST_BMAP_RADIX
condition|)
block|{
comment|/* 		 * non-optimized code to allocate N bits out of the bitmap. 		 * The more bits, the faster the code runs.  It will run 		 * the slowest allocating 2 bits, but since there aren't any 		 * memory ops in the core loop (or shouldn't be, anyway), 		 * you probably won't notice the difference. 		 */
name|int
name|j
decl_stmt|;
name|int
name|n
init|=
name|BLIST_BMAP_RADIX
operator|-
name|count
decl_stmt|;
name|u_daddr_t
name|mask
decl_stmt|;
name|mask
operator|=
operator|(
name|u_daddr_t
operator|)
operator|-
literal|1
operator|>>
name|n
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<=
name|n
condition|;
operator|++
name|j
control|)
block|{
if|if
condition|(
operator|(
name|orig
operator|&
name|mask
operator|)
operator|==
name|mask
condition|)
block|{
name|scan
operator|->
name|u
operator|.
name|bmu_bitmap
operator|&=
operator|~
name|mask
expr_stmt|;
return|return
operator|(
name|blk
operator|+
name|j
operator|)
return|;
block|}
name|mask
operator|=
operator|(
name|mask
operator|<<
literal|1
operator|)
expr_stmt|;
block|}
block|}
comment|/* 	 * We couldn't allocate count in this subtree, update bighint. 	 */
name|scan
operator|->
name|bm_bighint
operator|=
name|count
operator|-
literal|1
expr_stmt|;
return|return
operator|(
name|SWAPBLK_NONE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * blist_meta_alloc() -	allocate at a meta in the radix tree.  *  *	Attempt to allocate at a meta node.  If we can't, we update  *	bighint and return a failure.  Updating bighint optimize future  *	calls that hit this node.  We have to check for our collapse cases  *	and we have a few optimizations strewn in as well.  */
end_comment

begin_function
specifier|static
name|daddr_t
name|blst_meta_alloc
parameter_list|(
name|blmeta_t
modifier|*
name|scan
parameter_list|,
name|daddr_t
name|blk
parameter_list|,
name|daddr_t
name|count
parameter_list|,
name|daddr_t
name|radix
parameter_list|,
name|int
name|skip
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|next_skip
init|=
operator|(
name|skip
operator|>>
name|BLIST_META_RADIX_SHIFT
operator|)
decl_stmt|;
if|if
condition|(
name|scan
operator|->
name|u
operator|.
name|bmu_avail
operator|==
literal|0
condition|)
block|{
comment|/* 		 * ALL-ALLOCATED special case 		 */
name|scan
operator|->
name|bm_bighint
operator|=
name|count
expr_stmt|;
return|return
operator|(
name|SWAPBLK_NONE
operator|)
return|;
block|}
if|if
condition|(
name|scan
operator|->
name|u
operator|.
name|bmu_avail
operator|==
name|radix
condition|)
block|{
name|radix
operator|>>=
name|BLIST_META_RADIX_SHIFT
expr_stmt|;
comment|/* 		 * ALL-FREE special case, initialize uninitialize 		 * sublevel. 		 */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|skip
condition|;
name|i
operator|+=
name|next_skip
control|)
block|{
if|if
condition|(
name|scan
index|[
name|i
index|]
operator|.
name|bm_bighint
operator|==
operator|(
name|daddr_t
operator|)
operator|-
literal|1
condition|)
break|break;
if|if
condition|(
name|next_skip
operator|==
literal|1
condition|)
block|{
name|scan
index|[
name|i
index|]
operator|.
name|u
operator|.
name|bmu_bitmap
operator|=
operator|(
name|u_daddr_t
operator|)
operator|-
literal|1
expr_stmt|;
name|scan
index|[
name|i
index|]
operator|.
name|bm_bighint
operator|=
name|BLIST_BMAP_RADIX
expr_stmt|;
block|}
else|else
block|{
name|scan
index|[
name|i
index|]
operator|.
name|bm_bighint
operator|=
name|radix
expr_stmt|;
name|scan
index|[
name|i
index|]
operator|.
name|u
operator|.
name|bmu_avail
operator|=
name|radix
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|radix
operator|>>=
name|BLIST_META_RADIX_SHIFT
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|skip
condition|;
name|i
operator|+=
name|next_skip
control|)
block|{
if|if
condition|(
name|count
operator|<=
name|scan
index|[
name|i
index|]
operator|.
name|bm_bighint
condition|)
block|{
comment|/* 			 * count fits in object 			 */
name|daddr_t
name|r
decl_stmt|;
if|if
condition|(
name|next_skip
operator|==
literal|1
condition|)
block|{
name|r
operator|=
name|blst_leaf_alloc
argument_list|(
operator|&
name|scan
index|[
name|i
index|]
argument_list|,
name|blk
argument_list|,
name|count
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|r
operator|=
name|blst_meta_alloc
argument_list|(
operator|&
name|scan
index|[
name|i
index|]
argument_list|,
name|blk
argument_list|,
name|count
argument_list|,
name|radix
argument_list|,
name|next_skip
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|r
operator|!=
name|SWAPBLK_NONE
condition|)
block|{
name|scan
operator|->
name|u
operator|.
name|bmu_avail
operator|-=
name|count
expr_stmt|;
if|if
condition|(
name|scan
operator|->
name|bm_bighint
operator|>
name|scan
operator|->
name|u
operator|.
name|bmu_avail
condition|)
name|scan
operator|->
name|bm_bighint
operator|=
name|scan
operator|->
name|u
operator|.
name|bmu_avail
expr_stmt|;
return|return
operator|(
name|r
operator|)
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|scan
index|[
name|i
index|]
operator|.
name|bm_bighint
operator|==
operator|(
name|daddr_t
operator|)
operator|-
literal|1
condition|)
block|{
comment|/* 			 * Terminator 			 */
break|break;
block|}
elseif|else
if|if
condition|(
name|count
operator|>
name|radix
condition|)
block|{
comment|/* 			 * count does not fit in object even if it were 			 * complete free. 			 */
name|panic
argument_list|(
literal|"blist_meta_alloc: allocation too large"
argument_list|)
expr_stmt|;
block|}
name|blk
operator|+=
name|radix
expr_stmt|;
block|}
comment|/* 	 * We couldn't allocate count in this subtree, update bighint. 	 */
if|if
condition|(
name|scan
operator|->
name|bm_bighint
operator|>=
name|count
condition|)
name|scan
operator|->
name|bm_bighint
operator|=
name|count
operator|-
literal|1
expr_stmt|;
return|return
operator|(
name|SWAPBLK_NONE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * BLST_LEAF_FREE() -	free allocated block from leaf bitmap  *  */
end_comment

begin_function
specifier|static
name|void
name|blst_leaf_free
parameter_list|(
name|blmeta_t
modifier|*
name|scan
parameter_list|,
name|daddr_t
name|blk
parameter_list|,
name|int
name|count
parameter_list|)
block|{
comment|/* 	 * free some data in this bitmap 	 * 	 * e.g. 	 *	0000111111111110000 	 *          \_________/\__/ 	 *		v        n 	 */
name|int
name|n
init|=
name|blk
operator|&
operator|(
name|BLIST_BMAP_RADIX
operator|-
literal|1
operator|)
decl_stmt|;
name|u_daddr_t
name|mask
decl_stmt|;
name|mask
operator|=
operator|(
operator|(
name|u_daddr_t
operator|)
operator|-
literal|1
operator|<<
name|n
operator|)
operator|&
operator|(
operator|(
name|u_daddr_t
operator|)
operator|-
literal|1
operator|>>
operator|(
name|BLIST_BMAP_RADIX
operator|-
name|count
operator|-
name|n
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|scan
operator|->
name|u
operator|.
name|bmu_bitmap
operator|&
name|mask
condition|)
name|panic
argument_list|(
literal|"blst_radix_free: freeing free block"
argument_list|)
expr_stmt|;
name|scan
operator|->
name|u
operator|.
name|bmu_bitmap
operator||=
name|mask
expr_stmt|;
comment|/* 	 * We could probably do a better job here.  We are required to make 	 * bighint at least as large as the biggest contiguous block of  	 * data.  If we just shoehorn it, a little extra overhead will 	 * be incured on the next allocation (but only that one typically). 	 */
name|scan
operator|->
name|bm_bighint
operator|=
name|BLIST_BMAP_RADIX
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * BLST_META_FREE() - free allocated blocks from radix tree meta info  *  *	This support routine frees a range of blocks from the bitmap.  *	The range must be entirely enclosed by this radix node.  If a  *	meta node, we break the range down recursively to free blocks  *	in subnodes (which means that this code can free an arbitrary  *	range whereas the allocation code cannot allocate an arbitrary  *	range).  */
end_comment

begin_function
specifier|static
name|void
name|blst_meta_free
parameter_list|(
name|blmeta_t
modifier|*
name|scan
parameter_list|,
name|daddr_t
name|freeBlk
parameter_list|,
name|daddr_t
name|count
parameter_list|,
name|daddr_t
name|radix
parameter_list|,
name|int
name|skip
parameter_list|,
name|daddr_t
name|blk
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|next_skip
init|=
operator|(
name|skip
operator|>>
name|BLIST_META_RADIX_SHIFT
operator|)
decl_stmt|;
if|#
directive|if
literal|0
block|printf("FREE (%x,%d) FROM (%x,%d)\n", 	    freeBlk, count, 	    blk, radix 	);
endif|#
directive|endif
if|if
condition|(
name|scan
operator|->
name|u
operator|.
name|bmu_avail
operator|==
literal|0
condition|)
block|{
comment|/* 		 * ALL-ALLOCATED special case, with possible 		 * shortcut to ALL-FREE special case. 		 */
name|scan
operator|->
name|u
operator|.
name|bmu_avail
operator|=
name|count
expr_stmt|;
name|scan
operator|->
name|bm_bighint
operator|=
name|count
expr_stmt|;
if|if
condition|(
name|count
operator|!=
name|radix
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|skip
condition|;
name|i
operator|+=
name|next_skip
control|)
block|{
if|if
condition|(
name|scan
index|[
name|i
index|]
operator|.
name|bm_bighint
operator|==
operator|(
name|daddr_t
operator|)
operator|-
literal|1
condition|)
break|break;
name|scan
index|[
name|i
index|]
operator|.
name|bm_bighint
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|next_skip
operator|==
literal|1
condition|)
block|{
name|scan
index|[
name|i
index|]
operator|.
name|u
operator|.
name|bmu_bitmap
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|scan
index|[
name|i
index|]
operator|.
name|u
operator|.
name|bmu_avail
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* fall through */
block|}
block|}
else|else
block|{
name|scan
operator|->
name|u
operator|.
name|bmu_avail
operator|+=
name|count
expr_stmt|;
comment|/* scan->bm_bighint = radix; */
block|}
comment|/* 	 * ALL-FREE special case. 	 */
if|if
condition|(
name|scan
operator|->
name|u
operator|.
name|bmu_avail
operator|==
name|radix
condition|)
return|return;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|MAX_PERF
argument_list|)
if|if
condition|(
name|scan
operator|->
name|u
operator|.
name|bmu_avail
operator|>
name|radix
condition|)
name|panic
argument_list|(
literal|"blst_meta_free: freeing already free blocks (%d) %d/%d"
argument_list|,
name|count
argument_list|,
name|scan
operator|->
name|u
operator|.
name|bmu_avail
argument_list|,
name|radix
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Break the free down into its components 	 */
name|radix
operator|>>=
name|BLIST_META_RADIX_SHIFT
expr_stmt|;
name|i
operator|=
operator|(
name|freeBlk
operator|-
name|blk
operator|)
operator|/
name|radix
expr_stmt|;
name|blk
operator|+=
name|i
operator|*
name|radix
expr_stmt|;
name|i
operator|=
name|i
operator|*
name|next_skip
operator|+
literal|1
expr_stmt|;
while|while
condition|(
name|i
operator|<=
name|skip
operator|&&
name|blk
operator|<
name|freeBlk
operator|+
name|count
condition|)
block|{
name|daddr_t
name|v
decl_stmt|;
name|v
operator|=
name|blk
operator|+
name|radix
operator|-
name|freeBlk
expr_stmt|;
if|if
condition|(
name|v
operator|>
name|count
condition|)
name|v
operator|=
name|count
expr_stmt|;
if|if
condition|(
name|scan
operator|->
name|bm_bighint
operator|==
operator|(
name|daddr_t
operator|)
operator|-
literal|1
condition|)
name|panic
argument_list|(
literal|"blst_meta_free: freeing unexpected range"
argument_list|)
expr_stmt|;
if|if
condition|(
name|next_skip
operator|==
literal|1
condition|)
block|{
name|blst_leaf_free
argument_list|(
operator|&
name|scan
index|[
name|i
index|]
argument_list|,
name|freeBlk
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|blst_meta_free
argument_list|(
operator|&
name|scan
index|[
name|i
index|]
argument_list|,
name|freeBlk
argument_list|,
name|v
argument_list|,
name|radix
argument_list|,
name|next_skip
operator|-
literal|1
argument_list|,
name|blk
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|scan
operator|->
name|bm_bighint
operator|<
name|scan
index|[
name|i
index|]
operator|.
name|bm_bighint
condition|)
name|scan
operator|->
name|bm_bighint
operator|=
name|scan
index|[
name|i
index|]
operator|.
name|bm_bighint
expr_stmt|;
name|count
operator|-=
name|v
expr_stmt|;
name|freeBlk
operator|+=
name|v
expr_stmt|;
name|blk
operator|+=
name|radix
expr_stmt|;
name|i
operator|+=
name|next_skip
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * BLIST_RADIX_COPY() - copy one radix tree to another  *  *	Locates free space in the source tree and frees it in the destination  *	tree.  The space may not already be free in the destination.  */
end_comment

begin_function
specifier|static
name|void
name|blst_copy
parameter_list|(
name|blmeta_t
modifier|*
name|scan
parameter_list|,
name|daddr_t
name|blk
parameter_list|,
name|daddr_t
name|radix
parameter_list|,
name|daddr_t
name|skip
parameter_list|,
name|blist_t
name|dest
parameter_list|,
name|daddr_t
name|count
parameter_list|)
block|{
name|int
name|next_skip
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* 	 * Leaf node 	 */
if|if
condition|(
name|radix
operator|==
name|BLIST_BMAP_RADIX
condition|)
block|{
name|u_daddr_t
name|v
init|=
name|scan
operator|->
name|u
operator|.
name|bmu_bitmap
decl_stmt|;
if|if
condition|(
name|v
operator|==
operator|(
name|u_daddr_t
operator|)
operator|-
literal|1
condition|)
block|{
name|blist_free
argument_list|(
name|dest
argument_list|,
name|blk
argument_list|,
name|count
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|v
operator|!=
literal|0
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|BLIST_BMAP_RADIX
operator|&&
name|i
operator|<
name|count
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|v
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
condition|)
name|blist_free
argument_list|(
name|dest
argument_list|,
name|blk
operator|+
name|i
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
return|return;
block|}
comment|/* 	 * Meta node 	 */
if|if
condition|(
name|scan
operator|->
name|u
operator|.
name|bmu_avail
operator|==
literal|0
condition|)
block|{
comment|/* 		 * Source all allocated, leave dest allocated 		 */
return|return;
block|}
if|if
condition|(
name|scan
operator|->
name|u
operator|.
name|bmu_avail
operator|==
name|radix
condition|)
block|{
comment|/* 		 * Source all free, free entire dest 		 */
if|if
condition|(
name|count
operator|<
name|radix
condition|)
name|blist_free
argument_list|(
name|dest
argument_list|,
name|blk
argument_list|,
name|count
argument_list|)
expr_stmt|;
else|else
name|blist_free
argument_list|(
name|dest
argument_list|,
name|blk
argument_list|,
name|radix
argument_list|)
expr_stmt|;
return|return;
block|}
name|radix
operator|>>=
name|BLIST_META_RADIX_SHIFT
expr_stmt|;
name|next_skip
operator|=
operator|(
name|skip
operator|>>
name|BLIST_META_RADIX_SHIFT
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|count
operator|&&
name|i
operator|<=
name|skip
condition|;
name|i
operator|+=
name|next_skip
control|)
block|{
if|if
condition|(
name|scan
index|[
name|i
index|]
operator|.
name|bm_bighint
operator|==
operator|(
name|daddr_t
operator|)
operator|-
literal|1
condition|)
break|break;
if|if
condition|(
name|count
operator|>=
name|radix
condition|)
block|{
name|blst_copy
argument_list|(
operator|&
name|scan
index|[
name|i
index|]
argument_list|,
name|blk
argument_list|,
name|radix
argument_list|,
name|next_skip
operator|-
literal|1
argument_list|,
name|dest
argument_list|,
name|radix
argument_list|)
expr_stmt|;
name|count
operator|-=
name|radix
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|count
condition|)
block|{
name|blst_copy
argument_list|(
operator|&
name|scan
index|[
name|i
index|]
argument_list|,
name|blk
argument_list|,
name|radix
argument_list|,
name|next_skip
operator|-
literal|1
argument_list|,
name|dest
argument_list|,
name|count
argument_list|)
expr_stmt|;
block|}
name|count
operator|=
literal|0
expr_stmt|;
block|}
name|blk
operator|+=
name|radix
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * BLST_RADIX_INIT() - initialize radix tree  *  *	Initialize our meta structures and bitmaps and calculate the exact  *	amount of space required to manage 'count' blocks - this space may  *	be considerably less then the calculated radix due to the large  *	RADIX values we use.  */
end_comment

begin_function
specifier|static
name|daddr_t
name|blst_radix_init
parameter_list|(
name|blmeta_t
modifier|*
name|scan
parameter_list|,
name|daddr_t
name|radix
parameter_list|,
name|int
name|skip
parameter_list|,
name|daddr_t
name|count
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|next_skip
decl_stmt|;
name|daddr_t
name|memindex
init|=
literal|0
decl_stmt|;
comment|/* 	 * Leaf node 	 */
if|if
condition|(
name|radix
operator|==
name|BLIST_BMAP_RADIX
condition|)
block|{
if|if
condition|(
name|scan
condition|)
block|{
name|scan
operator|->
name|bm_bighint
operator|=
literal|0
expr_stmt|;
name|scan
operator|->
name|u
operator|.
name|bmu_bitmap
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
name|memindex
operator|)
return|;
block|}
comment|/* 	 * Meta node.  If allocating the entire object we can special 	 * case it.  However, we need to figure out how much memory 	 * is required to manage 'count' blocks, so we continue on anyway. 	 */
if|if
condition|(
name|scan
condition|)
block|{
name|scan
operator|->
name|bm_bighint
operator|=
literal|0
expr_stmt|;
name|scan
operator|->
name|u
operator|.
name|bmu_avail
operator|=
literal|0
expr_stmt|;
block|}
name|radix
operator|>>=
name|BLIST_META_RADIX_SHIFT
expr_stmt|;
name|next_skip
operator|=
operator|(
name|skip
operator|>>
name|BLIST_META_RADIX_SHIFT
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|skip
condition|;
name|i
operator|+=
name|next_skip
control|)
block|{
if|if
condition|(
name|count
operator|>=
name|radix
condition|)
block|{
comment|/* 			 * Allocate the entire object 			 */
name|memindex
operator|=
name|i
operator|+
name|blst_radix_init
argument_list|(
operator|(
operator|(
name|scan
operator|)
condition|?
operator|&
name|scan
index|[
name|i
index|]
else|:
name|NULL
operator|)
argument_list|,
name|radix
argument_list|,
name|next_skip
operator|-
literal|1
argument_list|,
name|radix
argument_list|)
expr_stmt|;
name|count
operator|-=
name|radix
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|count
operator|>
literal|0
condition|)
block|{
comment|/* 			 * Allocate a partial object 			 */
name|memindex
operator|=
name|i
operator|+
name|blst_radix_init
argument_list|(
operator|(
operator|(
name|scan
operator|)
condition|?
operator|&
name|scan
index|[
name|i
index|]
else|:
name|NULL
operator|)
argument_list|,
name|radix
argument_list|,
name|next_skip
operator|-
literal|1
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * Add terminator and break out 			 */
if|if
condition|(
name|scan
condition|)
name|scan
index|[
name|i
index|]
operator|.
name|bm_bighint
operator|=
operator|(
name|daddr_t
operator|)
operator|-
literal|1
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|memindex
operator|<
name|i
condition|)
name|memindex
operator|=
name|i
expr_stmt|;
return|return
operator|(
name|memindex
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|BLIST_DEBUG
end_ifdef

begin_function
specifier|static
name|void
name|blst_radix_print
parameter_list|(
name|blmeta_t
modifier|*
name|scan
parameter_list|,
name|daddr_t
name|blk
parameter_list|,
name|daddr_t
name|radix
parameter_list|,
name|int
name|skip
parameter_list|,
name|int
name|tab
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|next_skip
decl_stmt|;
name|int
name|lastState
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|radix
operator|==
name|BLIST_BMAP_RADIX
condition|)
block|{
name|printf
argument_list|(
literal|"%*.*s(%04x,%d): bitmap %08x big=%d\n"
argument_list|,
name|tab
argument_list|,
name|tab
argument_list|,
literal|""
argument_list|,
name|blk
argument_list|,
name|radix
argument_list|,
name|scan
operator|->
name|u
operator|.
name|bmu_bitmap
argument_list|,
name|scan
operator|->
name|bm_bighint
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|scan
operator|->
name|u
operator|.
name|bmu_avail
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%*.*s(%04x,%d) ALL ALLOCATED\n"
argument_list|,
name|tab
argument_list|,
name|tab
argument_list|,
literal|""
argument_list|,
name|blk
argument_list|,
name|radix
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|scan
operator|->
name|u
operator|.
name|bmu_avail
operator|==
name|radix
condition|)
block|{
name|printf
argument_list|(
literal|"%*.*s(%04x,%d) ALL FREE\n"
argument_list|,
name|tab
argument_list|,
name|tab
argument_list|,
literal|""
argument_list|,
name|blk
argument_list|,
name|radix
argument_list|)
expr_stmt|;
return|return;
block|}
name|printf
argument_list|(
literal|"%*.*s(%04x,%d): subtree (%d/%d) big=%d {\n"
argument_list|,
name|tab
argument_list|,
name|tab
argument_list|,
literal|""
argument_list|,
name|blk
argument_list|,
name|radix
argument_list|,
name|scan
operator|->
name|u
operator|.
name|bmu_avail
argument_list|,
name|radix
argument_list|,
name|scan
operator|->
name|bm_bighint
argument_list|)
expr_stmt|;
name|radix
operator|>>=
name|BLIST_META_RADIX_SHIFT
expr_stmt|;
name|next_skip
operator|=
operator|(
name|skip
operator|>>
name|BLIST_META_RADIX_SHIFT
operator|)
expr_stmt|;
name|tab
operator|+=
literal|4
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|skip
condition|;
name|i
operator|+=
name|next_skip
control|)
block|{
if|if
condition|(
name|scan
index|[
name|i
index|]
operator|.
name|bm_bighint
operator|==
operator|(
name|daddr_t
operator|)
operator|-
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"%*.*s(%04x,%d): Terminator\n"
argument_list|,
name|tab
argument_list|,
name|tab
argument_list|,
literal|""
argument_list|,
name|blk
argument_list|,
name|radix
argument_list|)
expr_stmt|;
name|lastState
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|blst_radix_print
argument_list|(
operator|&
name|scan
index|[
name|i
index|]
argument_list|,
name|blk
argument_list|,
name|radix
argument_list|,
name|next_skip
operator|-
literal|1
argument_list|,
name|tab
argument_list|)
expr_stmt|;
name|blk
operator|+=
name|radix
expr_stmt|;
block|}
name|tab
operator|-=
literal|4
expr_stmt|;
name|printf
argument_list|(
literal|"%*.*s}\n"
argument_list|,
name|tab
argument_list|,
name|tab
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|BLIST_DEBUG
end_ifdef

begin_function
name|int
name|main
parameter_list|(
name|int
name|ac
parameter_list|,
name|char
modifier|*
modifier|*
name|av
parameter_list|)
block|{
name|int
name|size
init|=
literal|1024
decl_stmt|;
name|int
name|i
decl_stmt|;
name|blist_t
name|bl
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|ac
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|char
modifier|*
name|ptr
init|=
name|av
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
operator|*
name|ptr
operator|!=
literal|'-'
condition|)
block|{
name|size
operator|=
name|strtol
argument_list|(
name|ptr
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|ptr
operator|+=
literal|2
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Bad option: %s\n"
argument_list|,
name|ptr
operator|-
literal|2
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|bl
operator|=
name|blist_create
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|blist_free
argument_list|(
name|bl
argument_list|,
literal|0
argument_list|,
name|size
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|char
name|buf
index|[
literal|1024
index|]
decl_stmt|;
name|daddr_t
name|da
init|=
literal|0
decl_stmt|;
name|daddr_t
name|count
init|=
literal|0
decl_stmt|;
name|printf
argument_list|(
literal|"%d/%d/%d> "
argument_list|,
name|bl
operator|->
name|bl_free
argument_list|,
name|size
argument_list|,
name|bl
operator|->
name|bl_radix
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|fgets
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|stdin
argument_list|)
operator|==
name|NULL
condition|)
break|break;
switch|switch
condition|(
name|buf
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|'r'
case|:
if|if
condition|(
name|sscanf
argument_list|(
name|buf
operator|+
literal|1
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|count
argument_list|)
operator|==
literal|1
condition|)
block|{
name|blist_resize
argument_list|(
operator|&
name|bl
argument_list|,
name|count
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"?\n"
argument_list|)
expr_stmt|;
block|}
case|case
literal|'p'
case|:
name|blist_print
argument_list|(
name|bl
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'a'
case|:
if|if
condition|(
name|sscanf
argument_list|(
name|buf
operator|+
literal|1
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|count
argument_list|)
operator|==
literal|1
condition|)
block|{
name|daddr_t
name|blk
init|=
name|blist_alloc
argument_list|(
name|bl
argument_list|,
name|count
argument_list|)
decl_stmt|;
name|printf
argument_list|(
literal|"    R=%04x\n"
argument_list|,
name|blk
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"?\n"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'f'
case|:
if|if
condition|(
name|sscanf
argument_list|(
name|buf
operator|+
literal|1
argument_list|,
literal|"%x %d"
argument_list|,
operator|&
name|da
argument_list|,
operator|&
name|count
argument_list|)
operator|==
literal|2
condition|)
block|{
name|blist_free
argument_list|(
name|bl
argument_list|,
name|da
argument_list|,
name|count
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"?\n"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'?'
case|:
case|case
literal|'h'
case|:
name|puts
argument_list|(
literal|"p          -print\n"
literal|"a %d       -allocate\n"
literal|"f %x %d    -free\n"
literal|"r %d       -resize\n"
literal|"h/?        -help"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"?\n"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|panic
parameter_list|(
specifier|const
name|char
modifier|*
name|ctl
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|va
decl_stmt|;
name|va_start
argument_list|(
name|va
argument_list|,
name|ctl
argument_list|)
expr_stmt|;
name|vfprintf
argument_list|(
name|stderr
argument_list|,
name|ctl
argument_list|,
name|va
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|va
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

