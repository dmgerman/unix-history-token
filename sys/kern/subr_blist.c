begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1998 Matthew Dillon.  All Rights Reserved.  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS  * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE  * GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,  * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * BLIST.C -	Bitmap allocator/deallocator, using a radix tree with hinting  *  *	This module implements a general bitmap allocator/deallocator.  The  *	allocator eats around 2 bits per 'block'.  The module does not  *	try to interpret the meaning of a 'block' other than to return  *	SWAPBLK_NONE on an allocation failure.  *  *	A radix tree controls access to pieces of the bitmap, and includes  *	auxiliary information at each interior node about the availabilty of  *	contiguous free blocks in the subtree rooted at that node.  Two radix  *	constants are involved: one for the size of the bitmaps contained in the  *	leaf nodes (BLIST_BMAP_RADIX), and one for the number of descendents of  *	each of the meta (interior) nodes (BLIST_META_RADIX).  Each subtree is  *	associated with a range of blocks.  The root of any subtree stores a  *	hint field that defines an upper bound on the size of the largest  *	allocation that can begin in the associated block range.  A hint is an  *	upper bound on a potential allocation, but not necessarily a tight upper  *	bound.  *  *	The radix tree also implements two collapsed states for meta nodes:  *	the ALL-ALLOCATED state and the ALL-FREE state.  If a meta node is  *	in either of these two states, all information contained underneath  *	the node is considered stale.  These states are used to optimize  *	allocation and freeing operations.  *  * 	The hinting greatly increases code efficiency for allocations while  *	the general radix structure optimizes both allocations and frees.  The  *	radix tree should be able to operate well no matter how much  *	fragmentation there is and no matter how large a bitmap is used.  *  *	The blist code wires all necessary memory at creation time.  Neither  *	allocations nor frees require interaction with the memory subsystem.  *	The non-blocking features of the blist code are used in the swap code  *	(vm/swap_pager.c).  *  *	LAYOUT: The radix tree is laid out recursively using a  *	linear array.  Each meta node is immediately followed (laid out  *	sequentially in memory) by BLIST_META_RADIX lower level nodes.  This  *	is a recursive structure but one that can be easily scanned through  *	a very simple 'skip' calculation.  In order to support large radixes,  *	portions of the tree may reside outside our memory allocation.  We  *	handle this with an early-termination optimization (when bighint is  *	set to -1) on the scan.  The memory allocation is only large enough  *	to cover the number of blocks requested at creation time even if it  *	must be encompassed in larger root-node radix.  *  *	NOTE: the allocator cannot currently allocate more than  *	BLIST_BMAP_RADIX blocks per call.  It will panic with 'allocation too  *	large' if you try.  This is an area that could use improvement.  The  *	radix is large enough that this restriction does not effect the swap  *	system, though.  Currently only the allocation code is affected by  *	this algorithmic unfeature.  The freeing code can handle arbitrary  *	ranges.  *  *	This code can be compiled stand-alone for debugging.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|_KERNEL
end_ifdef

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/blist.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/sbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_else
else|#
directive|else
end_else

begin_ifndef
ifndef|#
directive|ifndef
name|BLIST_NO_DEBUG
end_ifndef

begin_define
define|#
directive|define
name|BLIST_DEBUG
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/sbuf.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<stddef.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_include
include|#
directive|include
file|<stdbool.h>
end_include

begin_define
define|#
directive|define
name|bitcount64
parameter_list|(
name|x
parameter_list|)
value|__bitcount64((uint64_t)(x))
end_define

begin_define
define|#
directive|define
name|malloc
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|)
value|calloc(a, 1)
end_define

begin_define
define|#
directive|define
name|free
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|free(a)
end_define

begin_function
specifier|static
name|__inline
name|int
name|imax
parameter_list|(
name|int
name|a
parameter_list|,
name|int
name|b
parameter_list|)
block|{
return|return
operator|(
name|a
operator|>
name|b
condition|?
name|a
else|:
name|b
operator|)
return|;
block|}
end_function

begin_include
include|#
directive|include
file|<sys/blist.h>
end_include

begin_function_decl
name|void
name|panic
parameter_list|(
specifier|const
name|char
modifier|*
name|ctl
parameter_list|,
modifier|...
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * static support functions  */
end_comment

begin_function_decl
specifier|static
name|daddr_t
name|blst_leaf_alloc
parameter_list|(
name|blmeta_t
modifier|*
name|scan
parameter_list|,
name|daddr_t
name|blk
parameter_list|,
name|int
name|count
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|daddr_t
name|blst_meta_alloc
parameter_list|(
name|blmeta_t
modifier|*
name|scan
parameter_list|,
name|daddr_t
name|cursor
parameter_list|,
name|daddr_t
name|count
parameter_list|,
name|u_daddr_t
name|radix
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|blst_leaf_free
parameter_list|(
name|blmeta_t
modifier|*
name|scan
parameter_list|,
name|daddr_t
name|relblk
parameter_list|,
name|int
name|count
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|blst_meta_free
parameter_list|(
name|blmeta_t
modifier|*
name|scan
parameter_list|,
name|daddr_t
name|freeBlk
parameter_list|,
name|daddr_t
name|count
parameter_list|,
name|u_daddr_t
name|radix
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|blst_copy
parameter_list|(
name|blmeta_t
modifier|*
name|scan
parameter_list|,
name|daddr_t
name|blk
parameter_list|,
name|daddr_t
name|radix
parameter_list|,
name|blist_t
name|dest
parameter_list|,
name|daddr_t
name|count
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|daddr_t
name|blst_leaf_fill
parameter_list|(
name|blmeta_t
modifier|*
name|scan
parameter_list|,
name|daddr_t
name|blk
parameter_list|,
name|int
name|count
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|daddr_t
name|blst_meta_fill
parameter_list|(
name|blmeta_t
modifier|*
name|scan
parameter_list|,
name|daddr_t
name|allocBlk
parameter_list|,
name|daddr_t
name|count
parameter_list|,
name|u_daddr_t
name|radix
parameter_list|)
function_decl|;
end_function_decl

begin_ifndef
ifndef|#
directive|ifndef
name|_KERNEL
end_ifndef

begin_function_decl
specifier|static
name|void
name|blst_radix_print
parameter_list|(
name|blmeta_t
modifier|*
name|scan
parameter_list|,
name|daddr_t
name|blk
parameter_list|,
name|daddr_t
name|radix
parameter_list|,
name|int
name|tab
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|_KERNEL
end_ifdef

begin_expr_stmt
specifier|static
name|MALLOC_DEFINE
argument_list|(
name|M_SWAP
argument_list|,
literal|"SWAP"
argument_list|,
literal|"Swap space"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_assert
assert|_Static_assert
argument_list|(
name|BLIST_BMAP_RADIX
operator|%
name|BLIST_META_RADIX
operator|==
literal|0
argument_list|,
literal|"radix divisibility error"
argument_list|)
assert|;
end_assert

begin_define
define|#
directive|define
name|BLIST_BMAP_MASK
value|(BLIST_BMAP_RADIX - 1)
end_define

begin_define
define|#
directive|define
name|BLIST_META_MASK
value|(BLIST_META_RADIX - 1)
end_define

begin_comment
comment|/*  * For a subtree that can represent the state of up to 'radix' blocks, the  * number of leaf nodes of the subtree is L=radix/BLIST_BMAP_RADIX.  If 'm'  * is short for BLIST_META_RADIX, then for a tree of height h with L=m**h  * leaf nodes, the total number of tree nodes is 1 + m + m**2 + ... + m**h,  * or, equivalently, (m**(h+1)-1)/(m-1).  This quantity is called 'skip'  * in the 'meta' functions that process subtrees.  Since integer division  * discards remainders, we can express this computation as  * skip = (m * m**h) / (m - 1)  * skip = (m * (radix / BLIST_BMAP_RADIX)) / (m - 1)  * and since m divides BLIST_BMAP_RADIX, we can simplify further to  * skip = (radix / (BLIST_BMAP_RADIX / m)) / (m - 1)  * skip = radix / ((BLIST_BMAP_RADIX / m) * (m - 1))  * so that simple integer division by a constant can safely be used for the  * calculation.  */
end_comment

begin_function
specifier|static
specifier|inline
name|daddr_t
name|radix_to_skip
parameter_list|(
name|daddr_t
name|radix
parameter_list|)
block|{
return|return
operator|(
name|radix
operator|/
operator|(
operator|(
name|BLIST_BMAP_RADIX
operator|/
name|BLIST_META_RADIX
operator|)
operator|*
name|BLIST_META_MASK
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Use binary search, or a faster method, to find the 1 bit in a u_daddr_t.  * Assumes that the argument has only one bit set.  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|bitpos
parameter_list|(
name|u_daddr_t
name|mask
parameter_list|)
block|{
name|int
name|hi
decl_stmt|,
name|lo
decl_stmt|,
name|mid
decl_stmt|;
switch|switch
condition|(
sizeof|sizeof
argument_list|(
name|mask
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|HAVE_INLINE_FFSLL
case|case
expr|sizeof
operator|(
name|long
name|long
operator|)
case|:
return|return
operator|(
name|ffsll
argument_list|(
name|mask
argument_list|)
operator|-
literal|1
operator|)
return|;
endif|#
directive|endif
default|default:
name|lo
operator|=
literal|0
expr_stmt|;
name|hi
operator|=
name|BLIST_BMAP_RADIX
expr_stmt|;
while|while
condition|(
name|lo
operator|+
literal|1
operator|<
name|hi
condition|)
block|{
name|mid
operator|=
operator|(
name|lo
operator|+
name|hi
operator|)
operator|>>
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|mask
operator|>>
name|mid
operator|)
operator|!=
literal|0
condition|)
name|lo
operator|=
name|mid
expr_stmt|;
else|else
name|hi
operator|=
name|mid
expr_stmt|;
block|}
return|return
operator|(
name|lo
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * blist_create() - create a blist capable of handling up to the specified  *		    number of blocks  *  *	blocks - must be greater than 0  * 	flags  - malloc flags  *  *	The smallest blist consists of a single leaf node capable of  *	managing BLIST_BMAP_RADIX blocks.  */
end_comment

begin_function
name|blist_t
name|blist_create
parameter_list|(
name|daddr_t
name|blocks
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|blist_t
name|bl
decl_stmt|;
name|daddr_t
name|i
decl_stmt|,
name|last_block
decl_stmt|;
name|u_daddr_t
name|nodes
decl_stmt|,
name|radix
decl_stmt|,
name|skip
decl_stmt|;
name|int
name|digit
decl_stmt|;
comment|/* 	 * Calculate the radix and node count used for scanning.  Find the last 	 * block that is followed by a terminator. 	 */
name|last_block
operator|=
name|blocks
operator|-
literal|1
expr_stmt|;
name|radix
operator|=
name|BLIST_BMAP_RADIX
expr_stmt|;
while|while
condition|(
name|radix
operator|<
name|blocks
condition|)
block|{
if|if
condition|(
operator|(
operator|(
name|last_block
operator|/
name|radix
operator|+
literal|1
operator|)
operator|&
name|BLIST_META_MASK
operator|)
operator|!=
literal|0
condition|)
comment|/* 			 * A terminator will be added.  Update last_block to the 			 * position just before that terminator. 			 */
name|last_block
operator||=
name|radix
operator|-
literal|1
expr_stmt|;
name|radix
operator|*=
name|BLIST_META_RADIX
expr_stmt|;
block|}
comment|/* 	 * Count the meta-nodes in the expanded tree, including the final 	 * terminator, from the bottom level up to the root. 	 */
name|nodes
operator|=
operator|(
name|last_block
operator|>=
name|blocks
operator|)
condition|?
literal|2
else|:
literal|1
expr_stmt|;
name|last_block
operator|/=
name|BLIST_BMAP_RADIX
expr_stmt|;
while|while
condition|(
name|last_block
operator|>
literal|0
condition|)
block|{
name|nodes
operator|+=
name|last_block
operator|+
literal|1
expr_stmt|;
name|last_block
operator|/=
name|BLIST_META_RADIX
expr_stmt|;
block|}
name|bl
operator|=
name|malloc
argument_list|(
name|offsetof
argument_list|(
expr|struct
name|blist
argument_list|,
name|bl_root
index|[
name|nodes
index|]
argument_list|)
argument_list|,
name|M_SWAP
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|bl
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|bl
operator|->
name|bl_blocks
operator|=
name|blocks
expr_stmt|;
name|bl
operator|->
name|bl_radix
operator|=
name|radix
expr_stmt|;
name|bl
operator|->
name|bl_cursor
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Initialize the empty tree by filling in root values, then initialize 	 * just the terminators in the rest of the tree. 	 */
name|bl
operator|->
name|bl_root
index|[
literal|0
index|]
operator|.
name|bm_bighint
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|radix
operator|==
name|BLIST_BMAP_RADIX
condition|)
name|bl
operator|->
name|bl_root
index|[
literal|0
index|]
operator|.
name|u
operator|.
name|bmu_bitmap
operator|=
literal|0
expr_stmt|;
else|else
name|bl
operator|->
name|bl_root
index|[
literal|0
index|]
operator|.
name|u
operator|.
name|bmu_avail
operator|=
literal|0
expr_stmt|;
name|last_block
operator|=
name|blocks
operator|-
literal|1
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|radix
operator|>
name|BLIST_BMAP_RADIX
condition|)
block|{
name|radix
operator|/=
name|BLIST_META_RADIX
expr_stmt|;
name|skip
operator|=
name|radix_to_skip
argument_list|(
name|radix
argument_list|)
expr_stmt|;
name|digit
operator|=
name|last_block
operator|/
name|radix
expr_stmt|;
name|i
operator|+=
literal|1
operator|+
name|digit
operator|*
name|skip
expr_stmt|;
if|if
condition|(
name|digit
operator|!=
name|BLIST_META_MASK
condition|)
block|{
comment|/* 			 * Add a terminator. 			 */
name|bl
operator|->
name|bl_root
index|[
name|i
operator|+
name|skip
index|]
operator|.
name|bm_bighint
operator|=
operator|(
name|daddr_t
operator|)
operator|-
literal|1
expr_stmt|;
name|bl
operator|->
name|bl_root
index|[
name|i
operator|+
name|skip
index|]
operator|.
name|u
operator|.
name|bmu_bitmap
operator|=
literal|0
expr_stmt|;
block|}
name|last_block
operator|%=
name|radix
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|BLIST_DEBUG
argument_list|)
name|printf
argument_list|(
literal|"BLIST representing %lld blocks (%lld MB of swap)"
literal|", requiring %lldK of ram\n"
argument_list|,
operator|(
name|long
name|long
operator|)
name|bl
operator|->
name|bl_blocks
argument_list|,
operator|(
name|long
name|long
operator|)
name|bl
operator|->
name|bl_blocks
operator|*
literal|4
operator|/
literal|1024
argument_list|,
call|(
name|long
name|long
call|)
argument_list|(
name|nodes
operator|*
sizeof|sizeof
argument_list|(
name|blmeta_t
argument_list|)
operator|+
literal|1023
argument_list|)
operator|/
literal|1024
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"BLIST raw radix tree contains %lld records\n"
argument_list|,
operator|(
name|long
name|long
operator|)
name|nodes
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|bl
operator|)
return|;
block|}
end_function

begin_function
name|void
name|blist_destroy
parameter_list|(
name|blist_t
name|bl
parameter_list|)
block|{
name|free
argument_list|(
name|bl
argument_list|,
name|M_SWAP
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * blist_alloc() -   reserve space in the block bitmap.  Return the base  *		     of a contiguous region or SWAPBLK_NONE if space could  *		     not be allocated.  */
end_comment

begin_function
name|daddr_t
name|blist_alloc
parameter_list|(
name|blist_t
name|bl
parameter_list|,
name|daddr_t
name|count
parameter_list|)
block|{
name|daddr_t
name|blk
decl_stmt|;
comment|/* 	 * This loop iterates at most twice.  An allocation failure in the 	 * first iteration leads to a second iteration only if the cursor was 	 * non-zero.  When the cursor is zero, an allocation failure will 	 * reduce the hint, stopping further iterations. 	 */
while|while
condition|(
name|count
operator|<=
name|bl
operator|->
name|bl_root
operator|->
name|bm_bighint
condition|)
block|{
name|blk
operator|=
name|blst_meta_alloc
argument_list|(
name|bl
operator|->
name|bl_root
argument_list|,
name|bl
operator|->
name|bl_cursor
argument_list|,
name|count
argument_list|,
name|bl
operator|->
name|bl_radix
argument_list|)
expr_stmt|;
if|if
condition|(
name|blk
operator|!=
name|SWAPBLK_NONE
condition|)
block|{
name|bl
operator|->
name|bl_cursor
operator|=
name|blk
operator|+
name|count
expr_stmt|;
if|if
condition|(
name|bl
operator|->
name|bl_cursor
operator|==
name|bl
operator|->
name|bl_blocks
condition|)
name|bl
operator|->
name|bl_cursor
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|blk
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|bl
operator|->
name|bl_cursor
operator|!=
literal|0
condition|)
name|bl
operator|->
name|bl_cursor
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
name|SWAPBLK_NONE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * blist_avail() -	return the number of free blocks.  */
end_comment

begin_function
name|daddr_t
name|blist_avail
parameter_list|(
name|blist_t
name|bl
parameter_list|)
block|{
if|if
condition|(
name|bl
operator|->
name|bl_radix
operator|==
name|BLIST_BMAP_RADIX
condition|)
return|return
operator|(
name|bitcount64
argument_list|(
name|bl
operator|->
name|bl_root
operator|->
name|u
operator|.
name|bmu_bitmap
argument_list|)
operator|)
return|;
else|else
return|return
operator|(
name|bl
operator|->
name|bl_root
operator|->
name|u
operator|.
name|bmu_avail
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * blist_free() -	free up space in the block bitmap.  Return the base  *		     	of a contiguous region.  Panic if an inconsistancy is  *			found.  */
end_comment

begin_function
name|void
name|blist_free
parameter_list|(
name|blist_t
name|bl
parameter_list|,
name|daddr_t
name|blkno
parameter_list|,
name|daddr_t
name|count
parameter_list|)
block|{
name|blst_meta_free
argument_list|(
name|bl
operator|->
name|bl_root
argument_list|,
name|blkno
argument_list|,
name|count
argument_list|,
name|bl
operator|->
name|bl_radix
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * blist_fill() -	mark a region in the block bitmap as off-limits  *			to the allocator (i.e. allocate it), ignoring any  *			existing allocations.  Return the number of blocks  *			actually filled that were free before the call.  */
end_comment

begin_function
name|daddr_t
name|blist_fill
parameter_list|(
name|blist_t
name|bl
parameter_list|,
name|daddr_t
name|blkno
parameter_list|,
name|daddr_t
name|count
parameter_list|)
block|{
return|return
operator|(
name|blst_meta_fill
argument_list|(
name|bl
operator|->
name|bl_root
argument_list|,
name|blkno
argument_list|,
name|count
argument_list|,
name|bl
operator|->
name|bl_radix
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * blist_resize() -	resize an existing radix tree to handle the  *			specified number of blocks.  This will reallocate  *			the tree and transfer the previous bitmap to the new  *			one.  When extending the tree you can specify whether  *			the new blocks are to left allocated or freed.  */
end_comment

begin_function
name|void
name|blist_resize
parameter_list|(
name|blist_t
modifier|*
name|pbl
parameter_list|,
name|daddr_t
name|count
parameter_list|,
name|int
name|freenew
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|blist_t
name|newbl
init|=
name|blist_create
argument_list|(
name|count
argument_list|,
name|flags
argument_list|)
decl_stmt|;
name|blist_t
name|save
init|=
operator|*
name|pbl
decl_stmt|;
operator|*
name|pbl
operator|=
name|newbl
expr_stmt|;
if|if
condition|(
name|count
operator|>
name|save
operator|->
name|bl_blocks
condition|)
name|count
operator|=
name|save
operator|->
name|bl_blocks
expr_stmt|;
name|blst_copy
argument_list|(
name|save
operator|->
name|bl_root
argument_list|,
literal|0
argument_list|,
name|save
operator|->
name|bl_radix
argument_list|,
name|newbl
argument_list|,
name|count
argument_list|)
expr_stmt|;
comment|/*      * If resizing upwards, should we free the new space or not?      */
if|if
condition|(
name|freenew
operator|&&
name|count
operator|<
name|newbl
operator|->
name|bl_blocks
condition|)
block|{
name|blist_free
argument_list|(
name|newbl
argument_list|,
name|count
argument_list|,
name|newbl
operator|->
name|bl_blocks
operator|-
name|count
argument_list|)
expr_stmt|;
block|}
name|blist_destroy
argument_list|(
name|save
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|BLIST_DEBUG
end_ifdef

begin_comment
comment|/*  * blist_print()    - dump radix tree  */
end_comment

begin_function
name|void
name|blist_print
parameter_list|(
name|blist_t
name|bl
parameter_list|)
block|{
name|printf
argument_list|(
literal|"BLIST cursor = %08jx {\n"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|bl
operator|->
name|bl_cursor
argument_list|)
expr_stmt|;
name|blst_radix_print
argument_list|(
name|bl
operator|->
name|bl_root
argument_list|,
literal|0
argument_list|,
name|bl
operator|->
name|bl_radix
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"}\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
specifier|const
name|u_daddr_t
name|fib
index|[]
init|=
block|{
literal|1
block|,
literal|2
block|,
literal|3
block|,
literal|5
block|,
literal|8
block|,
literal|13
block|,
literal|21
block|,
literal|34
block|,
literal|55
block|,
literal|89
block|,
literal|144
block|,
literal|233
block|,
literal|377
block|,
literal|610
block|,
literal|987
block|,
literal|1597
block|,
literal|2584
block|,
literal|4181
block|,
literal|6765
block|,
literal|10946
block|,
literal|17711
block|,
literal|28657
block|,
literal|46368
block|,
literal|75025
block|,
literal|121393
block|,
literal|196418
block|,
literal|317811
block|,
literal|514229
block|,
literal|832040
block|,
literal|1346269
block|,
literal|2178309
block|,
literal|3524578
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Use 'gap' to describe a maximal range of unallocated blocks/bits.  */
end_comment

begin_struct
struct|struct
name|gap_stats
block|{
name|daddr_t
name|start
decl_stmt|;
comment|/* current gap start, or SWAPBLK_NONE */
name|daddr_t
name|num
decl_stmt|;
comment|/* number of gaps observed */
name|daddr_t
name|max
decl_stmt|;
comment|/* largest gap size */
name|daddr_t
name|avg
decl_stmt|;
comment|/* average gap size */
name|daddr_t
name|err
decl_stmt|;
comment|/* sum - num * avg */
name|daddr_t
name|histo
index|[
name|nitems
argument_list|(
name|fib
argument_list|)
index|]
decl_stmt|;
comment|/* # gaps in each size range */
name|int
name|max_bucket
decl_stmt|;
comment|/* last histo elt with nonzero val */
block|}
struct|;
end_struct

begin_comment
comment|/*  * gap_stats_counting()    - is the state 'counting 1 bits'?  *                           or 'skipping 0 bits'?  */
end_comment

begin_function
specifier|static
specifier|inline
name|bool
name|gap_stats_counting
parameter_list|(
specifier|const
name|struct
name|gap_stats
modifier|*
name|stats
parameter_list|)
block|{
return|return
operator|(
name|stats
operator|->
name|start
operator|!=
name|SWAPBLK_NONE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * init_gap_stats()    - initialize stats on gap sizes  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|init_gap_stats
parameter_list|(
name|struct
name|gap_stats
modifier|*
name|stats
parameter_list|)
block|{
name|bzero
argument_list|(
name|stats
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|stats
argument_list|)
argument_list|)
expr_stmt|;
name|stats
operator|->
name|start
operator|=
name|SWAPBLK_NONE
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * update_gap_stats()    - update stats on gap sizes  */
end_comment

begin_function
specifier|static
name|void
name|update_gap_stats
parameter_list|(
name|struct
name|gap_stats
modifier|*
name|stats
parameter_list|,
name|daddr_t
name|posn
parameter_list|)
block|{
name|daddr_t
name|size
decl_stmt|;
name|int
name|hi
decl_stmt|,
name|lo
decl_stmt|,
name|mid
decl_stmt|;
if|if
condition|(
operator|!
name|gap_stats_counting
argument_list|(
name|stats
argument_list|)
condition|)
block|{
name|stats
operator|->
name|start
operator|=
name|posn
expr_stmt|;
return|return;
block|}
name|size
operator|=
name|posn
operator|-
name|stats
operator|->
name|start
expr_stmt|;
name|stats
operator|->
name|start
operator|=
name|SWAPBLK_NONE
expr_stmt|;
if|if
condition|(
name|size
operator|>
name|stats
operator|->
name|max
condition|)
name|stats
operator|->
name|max
operator|=
name|size
expr_stmt|;
comment|/* 	 * Find the fibonacci range that contains size, 	 * expecting to find it in an early range. 	 */
name|lo
operator|=
literal|0
expr_stmt|;
name|hi
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|hi
operator|<
name|nitems
argument_list|(
name|fib
argument_list|)
operator|&&
name|fib
index|[
name|hi
index|]
operator|<=
name|size
condition|)
block|{
name|lo
operator|=
name|hi
expr_stmt|;
name|hi
operator|*=
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|hi
operator|>=
name|nitems
argument_list|(
name|fib
argument_list|)
condition|)
name|hi
operator|=
name|nitems
argument_list|(
name|fib
argument_list|)
expr_stmt|;
while|while
condition|(
name|lo
operator|+
literal|1
operator|!=
name|hi
condition|)
block|{
name|mid
operator|=
operator|(
name|lo
operator|+
name|hi
operator|)
operator|>>
literal|1
expr_stmt|;
if|if
condition|(
name|fib
index|[
name|mid
index|]
operator|<=
name|size
condition|)
name|lo
operator|=
name|mid
expr_stmt|;
else|else
name|hi
operator|=
name|mid
expr_stmt|;
block|}
name|stats
operator|->
name|histo
index|[
name|lo
index|]
operator|++
expr_stmt|;
if|if
condition|(
name|lo
operator|>
name|stats
operator|->
name|max_bucket
condition|)
name|stats
operator|->
name|max_bucket
operator|=
name|lo
expr_stmt|;
name|stats
operator|->
name|err
operator|+=
name|size
operator|-
name|stats
operator|->
name|avg
expr_stmt|;
name|stats
operator|->
name|num
operator|++
expr_stmt|;
name|stats
operator|->
name|avg
operator|+=
name|stats
operator|->
name|err
operator|/
name|stats
operator|->
name|num
expr_stmt|;
name|stats
operator|->
name|err
operator|%=
name|stats
operator|->
name|num
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * dump_gap_stats()    - print stats on gap sizes  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|dump_gap_stats
parameter_list|(
specifier|const
name|struct
name|gap_stats
modifier|*
name|stats
parameter_list|,
name|struct
name|sbuf
modifier|*
name|s
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|sbuf_printf
argument_list|(
name|s
argument_list|,
literal|"number of maximal free ranges: %jd\n"
argument_list|,
operator|(
name|intmax_t
operator|)
name|stats
operator|->
name|num
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|s
argument_list|,
literal|"largest free range: %jd\n"
argument_list|,
operator|(
name|intmax_t
operator|)
name|stats
operator|->
name|max
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|s
argument_list|,
literal|"average maximal free range size: %jd\n"
argument_list|,
operator|(
name|intmax_t
operator|)
name|stats
operator|->
name|avg
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|s
argument_list|,
literal|"number of maximal free ranges of different sizes:\n"
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|s
argument_list|,
literal|"               count  |  size range\n"
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|s
argument_list|,
literal|"               -----  |  ----------\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|stats
operator|->
name|max_bucket
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|stats
operator|->
name|histo
index|[
name|i
index|]
operator|!=
literal|0
condition|)
block|{
name|sbuf_printf
argument_list|(
name|s
argument_list|,
literal|"%20jd  |  "
argument_list|,
operator|(
name|intmax_t
operator|)
name|stats
operator|->
name|histo
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|fib
index|[
name|i
index|]
operator|!=
name|fib
index|[
name|i
operator|+
literal|1
index|]
operator|-
literal|1
condition|)
name|sbuf_printf
argument_list|(
name|s
argument_list|,
literal|"%jd to %jd\n"
argument_list|,
operator|(
name|intmax_t
operator|)
name|fib
index|[
name|i
index|]
argument_list|,
operator|(
name|intmax_t
operator|)
name|fib
index|[
name|i
operator|+
literal|1
index|]
operator|-
literal|1
argument_list|)
expr_stmt|;
else|else
name|sbuf_printf
argument_list|(
name|s
argument_list|,
literal|"%jd\n"
argument_list|,
operator|(
name|intmax_t
operator|)
name|fib
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
name|sbuf_printf
argument_list|(
name|s
argument_list|,
literal|"%20jd  |  "
argument_list|,
operator|(
name|intmax_t
operator|)
name|stats
operator|->
name|histo
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|stats
operator|->
name|histo
index|[
name|i
index|]
operator|>
literal|1
condition|)
name|sbuf_printf
argument_list|(
name|s
argument_list|,
literal|"%jd to %jd\n"
argument_list|,
operator|(
name|intmax_t
operator|)
name|fib
index|[
name|i
index|]
argument_list|,
operator|(
name|intmax_t
operator|)
name|stats
operator|->
name|max
argument_list|)
expr_stmt|;
else|else
name|sbuf_printf
argument_list|(
name|s
argument_list|,
literal|"%jd\n"
argument_list|,
operator|(
name|intmax_t
operator|)
name|stats
operator|->
name|max
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * blist_stats()    - dump radix tree stats  */
end_comment

begin_function
name|void
name|blist_stats
parameter_list|(
name|blist_t
name|bl
parameter_list|,
name|struct
name|sbuf
modifier|*
name|s
parameter_list|)
block|{
name|struct
name|gap_stats
name|gstats
decl_stmt|;
name|struct
name|gap_stats
modifier|*
name|stats
init|=
operator|&
name|gstats
decl_stmt|;
name|daddr_t
name|i
decl_stmt|,
name|nodes
decl_stmt|,
name|radix
decl_stmt|;
name|u_daddr_t
name|bit
decl_stmt|,
name|diff
decl_stmt|,
name|mask
decl_stmt|;
name|init_gap_stats
argument_list|(
name|stats
argument_list|)
expr_stmt|;
name|nodes
operator|=
literal|0
expr_stmt|;
name|i
operator|=
name|bl
operator|->
name|bl_radix
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|bl
operator|->
name|bl_radix
operator|+
name|bl
operator|->
name|bl_blocks
condition|)
block|{
comment|/* 		 * Find max size subtree starting at i. 		 */
name|radix
operator|=
name|BLIST_BMAP_RADIX
expr_stmt|;
while|while
condition|(
operator|(
operator|(
name|i
operator|/
name|radix
operator|)
operator|&
name|BLIST_META_MASK
operator|)
operator|==
literal|0
condition|)
name|radix
operator|*=
name|BLIST_META_RADIX
expr_stmt|;
comment|/* 		 * Check for skippable subtrees starting at i. 		 */
while|while
condition|(
name|radix
operator|>
name|BLIST_BMAP_RADIX
condition|)
block|{
if|if
condition|(
name|bl
operator|->
name|bl_root
index|[
name|nodes
index|]
operator|.
name|u
operator|.
name|bmu_avail
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|gap_stats_counting
argument_list|(
name|stats
argument_list|)
condition|)
name|update_gap_stats
argument_list|(
name|stats
argument_list|,
name|i
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|bl
operator|->
name|bl_root
index|[
name|nodes
index|]
operator|.
name|u
operator|.
name|bmu_avail
operator|==
name|radix
condition|)
block|{
if|if
condition|(
operator|!
name|gap_stats_counting
argument_list|(
name|stats
argument_list|)
condition|)
name|update_gap_stats
argument_list|(
name|stats
argument_list|,
name|i
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* 			 * Skip subtree root. 			 */
name|nodes
operator|++
expr_stmt|;
name|radix
operator|/=
name|BLIST_META_RADIX
expr_stmt|;
block|}
if|if
condition|(
name|radix
operator|==
name|BLIST_BMAP_RADIX
condition|)
block|{
comment|/* 			 * Scan leaf. 			 */
name|mask
operator|=
name|bl
operator|->
name|bl_root
index|[
name|nodes
index|]
operator|.
name|u
operator|.
name|bmu_bitmap
expr_stmt|;
name|diff
operator|=
name|mask
operator|^
operator|(
name|mask
operator|<<
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|gap_stats_counting
argument_list|(
name|stats
argument_list|)
condition|)
name|diff
operator|^=
literal|1
expr_stmt|;
while|while
condition|(
name|diff
operator|!=
literal|0
condition|)
block|{
name|bit
operator|=
name|diff
operator|&
operator|-
name|diff
expr_stmt|;
name|update_gap_stats
argument_list|(
name|stats
argument_list|,
name|i
operator|+
name|bitpos
argument_list|(
name|bit
argument_list|)
argument_list|)
expr_stmt|;
name|diff
operator|^=
name|bit
expr_stmt|;
block|}
block|}
name|nodes
operator|+=
name|radix_to_skip
argument_list|(
name|radix
argument_list|)
expr_stmt|;
name|i
operator|+=
name|radix
expr_stmt|;
block|}
name|update_gap_stats
argument_list|(
name|stats
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|dump_gap_stats
argument_list|(
name|stats
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/************************************************************************  *			  ALLOCATION SUPPORT FUNCTIONS			*  ************************************************************************  *  *	These support functions do all the actual work.  They may seem  *	rather longish, but that's because I've commented them up.  The  *	actual code is straight forward.  *  */
end_comment

begin_comment
comment|/*  * blist_leaf_alloc() -	allocate at a leaf in the radix tree (a bitmap).  *  *	This is the core of the allocator and is optimized for the  *	BLIST_BMAP_RADIX block allocation case.  Otherwise, execution  *	time is proportional to log2(count) + bitpos time.  */
end_comment

begin_function
specifier|static
name|daddr_t
name|blst_leaf_alloc
parameter_list|(
name|blmeta_t
modifier|*
name|scan
parameter_list|,
name|daddr_t
name|blk
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|u_daddr_t
name|mask
decl_stmt|;
name|int
name|count1
decl_stmt|,
name|hi
decl_stmt|,
name|lo
decl_stmt|,
name|num_shifts
decl_stmt|,
name|range1
decl_stmt|,
name|range_ext
decl_stmt|;
name|range1
operator|=
literal|0
expr_stmt|;
name|count1
operator|=
name|count
operator|-
literal|1
expr_stmt|;
name|num_shifts
operator|=
name|fls
argument_list|(
name|count1
argument_list|)
expr_stmt|;
name|mask
operator|=
name|scan
operator|->
name|u
operator|.
name|bmu_bitmap
expr_stmt|;
while|while
condition|(
operator|(
operator|-
name|mask
operator|&
operator|~
name|mask
operator|)
operator|!=
literal|0
operator|&&
name|num_shifts
operator|>
literal|0
condition|)
block|{
comment|/* 		 * If bit i is set in mask, then bits in [i, i+range1] are set 		 * in scan->u.bmu_bitmap.  The value of range1 is equal to 		 * count1>> num_shifts.  Grow range and reduce num_shifts to 0, 		 * while preserving these invariants.  The updates to mask leave 		 * fewer bits set, but each bit that remains set represents a 		 * longer string of consecutive bits set in scan->u.bmu_bitmap. 		 * If more updates to mask cannot clear more bits, because mask 		 * is partitioned with all 0 bits preceding all 1 bits, the loop 		 * terminates immediately. 		 */
name|num_shifts
operator|--
expr_stmt|;
name|range_ext
operator|=
name|range1
operator|+
operator|(
operator|(
name|count1
operator|>>
name|num_shifts
operator|)
operator|&
literal|1
operator|)
expr_stmt|;
comment|/* 		 * mask is a signed quantity for the shift because when it is 		 * shifted right, the sign bit should copied; when the last 		 * block of the leaf is free, pretend, for a while, that all the 		 * blocks that follow it are also free. 		 */
name|mask
operator|&=
operator|(
name|daddr_t
operator|)
name|mask
operator|>>
name|range_ext
expr_stmt|;
name|range1
operator|+=
name|range_ext
expr_stmt|;
block|}
if|if
condition|(
name|mask
operator|==
literal|0
condition|)
block|{
comment|/* 		 * Update bighint.  There is no allocation bigger than range1 		 * starting in this leaf. 		 */
name|scan
operator|->
name|bm_bighint
operator|=
name|range1
expr_stmt|;
return|return
operator|(
name|SWAPBLK_NONE
operator|)
return|;
block|}
comment|/* Discard any candidates that appear before blk. */
name|mask
operator|&=
operator|(
name|u_daddr_t
operator|)
operator|-
literal|1
operator|<<
operator|(
name|blk
operator|&
name|BLIST_BMAP_MASK
operator|)
expr_stmt|;
if|if
condition|(
name|mask
operator|==
literal|0
condition|)
return|return
operator|(
name|SWAPBLK_NONE
operator|)
return|;
comment|/* 	 * The least significant set bit in mask marks the start of the first 	 * available range of sufficient size.  Clear all the bits but that one, 	 * and then find its position. 	 */
name|mask
operator|&=
operator|-
name|mask
expr_stmt|;
name|lo
operator|=
name|bitpos
argument_list|(
name|mask
argument_list|)
expr_stmt|;
name|hi
operator|=
name|lo
operator|+
name|count
expr_stmt|;
if|if
condition|(
name|hi
operator|>
name|BLIST_BMAP_RADIX
condition|)
block|{
comment|/* 		 * An allocation within this leaf is impossible, so a successful 		 * allocation depends on the next leaf providing some of the blocks. 		 */
if|if
condition|(
operator|(
operator|(
name|blk
operator|/
name|BLIST_BMAP_RADIX
operator|+
literal|1
operator|)
operator|&
name|BLIST_META_MASK
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 			 * The next leaf has a different meta-node parent, so it 			 * is not necessarily initialized.  Update bighint, 			 * comparing the range found at the end of mask to the 			 * largest earlier range that could have been made to 			 * vanish in the initial processing of mask. 			 */
name|scan
operator|->
name|bm_bighint
operator|=
name|imax
argument_list|(
name|BLIST_BMAP_RADIX
operator|-
name|lo
argument_list|,
name|range1
argument_list|)
expr_stmt|;
return|return
operator|(
name|SWAPBLK_NONE
operator|)
return|;
block|}
name|hi
operator|-=
name|BLIST_BMAP_RADIX
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|scan
index|[
literal|1
index|]
operator|.
name|u
operator|.
name|bmu_bitmap
operator|+
literal|1
operator|)
operator|&
operator|~
operator|(
operator|(
name|u_daddr_t
operator|)
operator|-
literal|1
operator|<<
name|hi
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* 			 * The next leaf doesn't have enough free blocks at the 			 * beginning to complete the spanning allocation.  The 			 * hint cannot be updated, because the same allocation 			 * request could be satisfied later, by this leaf, if 			 * the state of the next leaf changes, and without any 			 * changes to this leaf. 			 */
return|return
operator|(
name|SWAPBLK_NONE
operator|)
return|;
block|}
comment|/* Clear the first 'hi' bits in the next leaf, allocating them. */
name|scan
index|[
literal|1
index|]
operator|.
name|u
operator|.
name|bmu_bitmap
operator|&=
operator|(
name|u_daddr_t
operator|)
operator|-
literal|1
operator|<<
name|hi
expr_stmt|;
name|hi
operator|=
name|BLIST_BMAP_RADIX
expr_stmt|;
block|}
comment|/* Set the bits of mask at position 'lo' and higher. */
name|mask
operator|=
operator|-
name|mask
expr_stmt|;
if|if
condition|(
name|hi
operator|==
name|BLIST_BMAP_RADIX
condition|)
block|{
comment|/* 		 * Update bighint.  There is no allocation bigger than range1 		 * available in this leaf after this allocation completes. 		 */
name|scan
operator|->
name|bm_bighint
operator|=
name|range1
expr_stmt|;
block|}
else|else
block|{
comment|/* Clear the bits of mask at position 'hi' and higher. */
name|mask
operator|&=
operator|(
name|u_daddr_t
operator|)
operator|-
literal|1
operator|>>
operator|(
name|BLIST_BMAP_RADIX
operator|-
name|hi
operator|)
expr_stmt|;
comment|/* If this allocation uses all the bits, clear the hint. */
if|if
condition|(
name|mask
operator|==
name|scan
operator|->
name|u
operator|.
name|bmu_bitmap
condition|)
name|scan
operator|->
name|bm_bighint
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Clear the allocated bits from this leaf. */
name|scan
operator|->
name|u
operator|.
name|bmu_bitmap
operator|&=
operator|~
name|mask
expr_stmt|;
return|return
operator|(
operator|(
name|blk
operator|&
operator|~
name|BLIST_BMAP_MASK
operator|)
operator|+
name|lo
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * blist_meta_alloc() -	allocate at a meta in the radix tree.  *  *	Attempt to allocate at a meta node.  If we can't, we update  *	bighint and return a failure.  Updating bighint optimize future  *	calls that hit this node.  We have to check for our collapse cases  *	and we have a few optimizations strewn in as well.  */
end_comment

begin_function
specifier|static
name|daddr_t
name|blst_meta_alloc
parameter_list|(
name|blmeta_t
modifier|*
name|scan
parameter_list|,
name|daddr_t
name|cursor
parameter_list|,
name|daddr_t
name|count
parameter_list|,
name|u_daddr_t
name|radix
parameter_list|)
block|{
name|daddr_t
name|blk
decl_stmt|,
name|i
decl_stmt|,
name|next_skip
decl_stmt|,
name|r
decl_stmt|,
name|skip
decl_stmt|;
name|int
name|child
decl_stmt|;
name|bool
name|scan_from_start
decl_stmt|;
if|if
condition|(
name|radix
operator|==
name|BLIST_BMAP_RADIX
condition|)
return|return
operator|(
name|blst_leaf_alloc
argument_list|(
name|scan
argument_list|,
name|cursor
argument_list|,
name|count
argument_list|)
operator|)
return|;
if|if
condition|(
name|scan
operator|->
name|u
operator|.
name|bmu_avail
operator|<
name|count
condition|)
block|{
comment|/* 		 * The meta node's hint must be too large if the allocation 		 * exceeds the number of free blocks.  Reduce the hint, and 		 * return failure. 		 */
name|scan
operator|->
name|bm_bighint
operator|=
name|scan
operator|->
name|u
operator|.
name|bmu_avail
expr_stmt|;
return|return
operator|(
name|SWAPBLK_NONE
operator|)
return|;
block|}
name|blk
operator|=
name|cursor
operator|&
operator|-
name|radix
expr_stmt|;
name|skip
operator|=
name|radix_to_skip
argument_list|(
name|radix
argument_list|)
expr_stmt|;
name|next_skip
operator|=
name|skip
operator|/
name|BLIST_META_RADIX
expr_stmt|;
comment|/* 	 * An ALL-FREE meta node requires special handling before allocating 	 * any of its blocks. 	 */
if|if
condition|(
name|scan
operator|->
name|u
operator|.
name|bmu_avail
operator|==
name|radix
condition|)
block|{
name|radix
operator|/=
name|BLIST_META_RADIX
expr_stmt|;
comment|/* 		 * Reinitialize each of the meta node's children.  An ALL-FREE 		 * meta node cannot have a terminator in any subtree. 		 */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|skip
condition|;
name|i
operator|+=
name|next_skip
control|)
block|{
if|if
condition|(
name|next_skip
operator|==
literal|1
condition|)
name|scan
index|[
name|i
index|]
operator|.
name|u
operator|.
name|bmu_bitmap
operator|=
operator|(
name|u_daddr_t
operator|)
operator|-
literal|1
expr_stmt|;
else|else
name|scan
index|[
name|i
index|]
operator|.
name|u
operator|.
name|bmu_avail
operator|=
name|radix
expr_stmt|;
name|scan
index|[
name|i
index|]
operator|.
name|bm_bighint
operator|=
name|radix
expr_stmt|;
block|}
block|}
else|else
block|{
name|radix
operator|/=
name|BLIST_META_RADIX
expr_stmt|;
block|}
if|if
condition|(
name|count
operator|>
name|radix
condition|)
block|{
comment|/* 		 * The allocation exceeds the number of blocks that are 		 * managed by a subtree of this meta node. 		 */
name|panic
argument_list|(
literal|"allocation too large"
argument_list|)
expr_stmt|;
block|}
name|scan_from_start
operator|=
name|cursor
operator|==
name|blk
expr_stmt|;
name|child
operator|=
operator|(
name|cursor
operator|-
name|blk
operator|)
operator|/
name|radix
expr_stmt|;
name|blk
operator|+=
name|child
operator|*
name|radix
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
operator|+
name|child
operator|*
name|next_skip
init|;
name|i
operator|<
name|skip
condition|;
name|i
operator|+=
name|next_skip
control|)
block|{
if|if
condition|(
name|count
operator|<=
name|scan
index|[
name|i
index|]
operator|.
name|bm_bighint
condition|)
block|{
comment|/* 			 * The allocation might fit beginning in the i'th subtree. 			 */
name|r
operator|=
name|blst_meta_alloc
argument_list|(
operator|&
name|scan
index|[
name|i
index|]
argument_list|,
name|cursor
operator|>
name|blk
condition|?
name|cursor
else|:
name|blk
argument_list|,
name|count
argument_list|,
name|radix
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|SWAPBLK_NONE
condition|)
block|{
name|scan
operator|->
name|u
operator|.
name|bmu_avail
operator|-=
name|count
expr_stmt|;
return|return
operator|(
name|r
operator|)
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|scan
index|[
name|i
index|]
operator|.
name|bm_bighint
operator|==
operator|(
name|daddr_t
operator|)
operator|-
literal|1
condition|)
block|{
comment|/* 			 * Terminator 			 */
break|break;
block|}
name|blk
operator|+=
name|radix
expr_stmt|;
block|}
comment|/* 	 * We couldn't allocate count in this subtree, update bighint. 	 */
if|if
condition|(
name|scan_from_start
operator|&&
name|scan
operator|->
name|bm_bighint
operator|>=
name|count
condition|)
name|scan
operator|->
name|bm_bighint
operator|=
name|count
operator|-
literal|1
expr_stmt|;
return|return
operator|(
name|SWAPBLK_NONE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * BLST_LEAF_FREE() -	free allocated block from leaf bitmap  *  */
end_comment

begin_function
specifier|static
name|void
name|blst_leaf_free
parameter_list|(
name|blmeta_t
modifier|*
name|scan
parameter_list|,
name|daddr_t
name|blk
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|u_daddr_t
name|mask
decl_stmt|;
name|int
name|n
decl_stmt|;
comment|/* 	 * free some data in this bitmap 	 * mask=0000111111111110000 	 *          \_________/\__/ 	 *		count   n 	 */
name|n
operator|=
name|blk
operator|&
name|BLIST_BMAP_MASK
expr_stmt|;
name|mask
operator|=
operator|(
operator|(
name|u_daddr_t
operator|)
operator|-
literal|1
operator|<<
name|n
operator|)
operator|&
operator|(
operator|(
name|u_daddr_t
operator|)
operator|-
literal|1
operator|>>
operator|(
name|BLIST_BMAP_RADIX
operator|-
name|count
operator|-
name|n
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|scan
operator|->
name|u
operator|.
name|bmu_bitmap
operator|&
name|mask
condition|)
name|panic
argument_list|(
literal|"freeing free block"
argument_list|)
expr_stmt|;
name|scan
operator|->
name|u
operator|.
name|bmu_bitmap
operator||=
name|mask
expr_stmt|;
comment|/* 	 * We could probably do a better job here.  We are required to make 	 * bighint at least as large as the biggest contiguous block of 	 * data.  If we just shoehorn it, a little extra overhead will 	 * be incured on the next allocation (but only that one typically). 	 */
name|scan
operator|->
name|bm_bighint
operator|=
name|BLIST_BMAP_RADIX
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * BLST_META_FREE() - free allocated blocks from radix tree meta info  *  *	This support routine frees a range of blocks from the bitmap.  *	The range must be entirely enclosed by this radix node.  If a  *	meta node, we break the range down recursively to free blocks  *	in subnodes (which means that this code can free an arbitrary  *	range whereas the allocation code cannot allocate an arbitrary  *	range).  */
end_comment

begin_function
specifier|static
name|void
name|blst_meta_free
parameter_list|(
name|blmeta_t
modifier|*
name|scan
parameter_list|,
name|daddr_t
name|freeBlk
parameter_list|,
name|daddr_t
name|count
parameter_list|,
name|u_daddr_t
name|radix
parameter_list|)
block|{
name|daddr_t
name|blk
decl_stmt|,
name|i
decl_stmt|,
name|next_skip
decl_stmt|,
name|skip
decl_stmt|,
name|v
decl_stmt|;
name|int
name|child
decl_stmt|;
if|if
condition|(
name|scan
operator|->
name|bm_bighint
operator|==
operator|(
name|daddr_t
operator|)
operator|-
literal|1
condition|)
name|panic
argument_list|(
literal|"freeing invalid range"
argument_list|)
expr_stmt|;
if|if
condition|(
name|radix
operator|==
name|BLIST_BMAP_RADIX
condition|)
return|return
operator|(
name|blst_leaf_free
argument_list|(
name|scan
argument_list|,
name|freeBlk
argument_list|,
name|count
argument_list|)
operator|)
return|;
name|skip
operator|=
name|radix_to_skip
argument_list|(
name|radix
argument_list|)
expr_stmt|;
name|next_skip
operator|=
name|skip
operator|/
name|BLIST_META_RADIX
expr_stmt|;
if|if
condition|(
name|scan
operator|->
name|u
operator|.
name|bmu_avail
operator|==
literal|0
condition|)
block|{
comment|/* 		 * ALL-ALLOCATED special case, with possible 		 * shortcut to ALL-FREE special case. 		 */
name|scan
operator|->
name|u
operator|.
name|bmu_avail
operator|=
name|count
expr_stmt|;
name|scan
operator|->
name|bm_bighint
operator|=
name|count
expr_stmt|;
if|if
condition|(
name|count
operator|!=
name|radix
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|skip
condition|;
name|i
operator|+=
name|next_skip
control|)
block|{
if|if
condition|(
name|scan
index|[
name|i
index|]
operator|.
name|bm_bighint
operator|==
operator|(
name|daddr_t
operator|)
operator|-
literal|1
condition|)
break|break;
name|scan
index|[
name|i
index|]
operator|.
name|bm_bighint
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|next_skip
operator|==
literal|1
condition|)
block|{
name|scan
index|[
name|i
index|]
operator|.
name|u
operator|.
name|bmu_bitmap
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|scan
index|[
name|i
index|]
operator|.
name|u
operator|.
name|bmu_avail
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* fall through */
block|}
block|}
else|else
block|{
name|scan
operator|->
name|u
operator|.
name|bmu_avail
operator|+=
name|count
expr_stmt|;
comment|/* scan->bm_bighint = radix; */
block|}
comment|/* 	 * ALL-FREE special case. 	 */
if|if
condition|(
name|scan
operator|->
name|u
operator|.
name|bmu_avail
operator|==
name|radix
condition|)
return|return;
if|if
condition|(
name|scan
operator|->
name|u
operator|.
name|bmu_avail
operator|>
name|radix
condition|)
name|panic
argument_list|(
literal|"blst_meta_free: freeing already free blocks (%lld) %lld/%lld"
argument_list|,
operator|(
name|long
name|long
operator|)
name|count
argument_list|,
operator|(
name|long
name|long
operator|)
name|scan
operator|->
name|u
operator|.
name|bmu_avail
argument_list|,
operator|(
name|long
name|long
operator|)
name|radix
argument_list|)
expr_stmt|;
comment|/* 	 * Break the free down into its components 	 */
name|blk
operator|=
name|freeBlk
operator|&
operator|-
name|radix
expr_stmt|;
name|radix
operator|/=
name|BLIST_META_RADIX
expr_stmt|;
name|child
operator|=
operator|(
name|freeBlk
operator|-
name|blk
operator|)
operator|/
name|radix
expr_stmt|;
name|blk
operator|+=
name|child
operator|*
name|radix
expr_stmt|;
name|i
operator|=
literal|1
operator|+
name|child
operator|*
name|next_skip
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|skip
operator|&&
name|blk
operator|<
name|freeBlk
operator|+
name|count
condition|)
block|{
name|v
operator|=
name|blk
operator|+
name|radix
operator|-
name|freeBlk
expr_stmt|;
if|if
condition|(
name|v
operator|>
name|count
condition|)
name|v
operator|=
name|count
expr_stmt|;
name|blst_meta_free
argument_list|(
operator|&
name|scan
index|[
name|i
index|]
argument_list|,
name|freeBlk
argument_list|,
name|v
argument_list|,
name|radix
argument_list|)
expr_stmt|;
if|if
condition|(
name|scan
operator|->
name|bm_bighint
operator|<
name|scan
index|[
name|i
index|]
operator|.
name|bm_bighint
condition|)
name|scan
operator|->
name|bm_bighint
operator|=
name|scan
index|[
name|i
index|]
operator|.
name|bm_bighint
expr_stmt|;
name|count
operator|-=
name|v
expr_stmt|;
name|freeBlk
operator|+=
name|v
expr_stmt|;
name|blk
operator|+=
name|radix
expr_stmt|;
name|i
operator|+=
name|next_skip
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * BLIST_RADIX_COPY() - copy one radix tree to another  *  *	Locates free space in the source tree and frees it in the destination  *	tree.  The space may not already be free in the destination.  */
end_comment

begin_function
specifier|static
name|void
name|blst_copy
parameter_list|(
name|blmeta_t
modifier|*
name|scan
parameter_list|,
name|daddr_t
name|blk
parameter_list|,
name|daddr_t
name|radix
parameter_list|,
name|blist_t
name|dest
parameter_list|,
name|daddr_t
name|count
parameter_list|)
block|{
name|daddr_t
name|i
decl_stmt|,
name|next_skip
decl_stmt|,
name|skip
decl_stmt|;
comment|/* 	 * Leaf node 	 */
if|if
condition|(
name|radix
operator|==
name|BLIST_BMAP_RADIX
condition|)
block|{
name|u_daddr_t
name|v
init|=
name|scan
operator|->
name|u
operator|.
name|bmu_bitmap
decl_stmt|;
if|if
condition|(
name|v
operator|==
operator|(
name|u_daddr_t
operator|)
operator|-
literal|1
condition|)
block|{
name|blist_free
argument_list|(
name|dest
argument_list|,
name|blk
argument_list|,
name|count
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|v
operator|!=
literal|0
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|BLIST_BMAP_RADIX
operator|&&
name|i
operator|<
name|count
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|v
operator|&
operator|(
operator|(
name|u_daddr_t
operator|)
literal|1
operator|<<
name|i
operator|)
condition|)
name|blist_free
argument_list|(
name|dest
argument_list|,
name|blk
operator|+
name|i
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
return|return;
block|}
comment|/* 	 * Meta node 	 */
if|if
condition|(
name|scan
operator|->
name|u
operator|.
name|bmu_avail
operator|==
literal|0
condition|)
block|{
comment|/* 		 * Source all allocated, leave dest allocated 		 */
return|return;
block|}
if|if
condition|(
name|scan
operator|->
name|u
operator|.
name|bmu_avail
operator|==
name|radix
condition|)
block|{
comment|/* 		 * Source all free, free entire dest 		 */
if|if
condition|(
name|count
operator|<
name|radix
condition|)
name|blist_free
argument_list|(
name|dest
argument_list|,
name|blk
argument_list|,
name|count
argument_list|)
expr_stmt|;
else|else
name|blist_free
argument_list|(
name|dest
argument_list|,
name|blk
argument_list|,
name|radix
argument_list|)
expr_stmt|;
return|return;
block|}
name|skip
operator|=
name|radix_to_skip
argument_list|(
name|radix
argument_list|)
expr_stmt|;
name|next_skip
operator|=
name|skip
operator|/
name|BLIST_META_RADIX
expr_stmt|;
name|radix
operator|/=
name|BLIST_META_RADIX
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|count
operator|&&
name|i
operator|<
name|skip
condition|;
name|i
operator|+=
name|next_skip
control|)
block|{
if|if
condition|(
name|scan
index|[
name|i
index|]
operator|.
name|bm_bighint
operator|==
operator|(
name|daddr_t
operator|)
operator|-
literal|1
condition|)
break|break;
if|if
condition|(
name|count
operator|>=
name|radix
condition|)
block|{
name|blst_copy
argument_list|(
operator|&
name|scan
index|[
name|i
index|]
argument_list|,
name|blk
argument_list|,
name|radix
argument_list|,
name|dest
argument_list|,
name|radix
argument_list|)
expr_stmt|;
name|count
operator|-=
name|radix
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|count
condition|)
block|{
name|blst_copy
argument_list|(
operator|&
name|scan
index|[
name|i
index|]
argument_list|,
name|blk
argument_list|,
name|radix
argument_list|,
name|dest
argument_list|,
name|count
argument_list|)
expr_stmt|;
block|}
name|count
operator|=
literal|0
expr_stmt|;
block|}
name|blk
operator|+=
name|radix
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * BLST_LEAF_FILL() -	allocate specific blocks in leaf bitmap  *  *	This routine allocates all blocks in the specified range  *	regardless of any existing allocations in that range.  Returns  *	the number of blocks allocated by the call.  */
end_comment

begin_function
specifier|static
name|daddr_t
name|blst_leaf_fill
parameter_list|(
name|blmeta_t
modifier|*
name|scan
parameter_list|,
name|daddr_t
name|blk
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|daddr_t
name|nblks
decl_stmt|;
name|u_daddr_t
name|mask
decl_stmt|;
name|int
name|n
decl_stmt|;
name|n
operator|=
name|blk
operator|&
name|BLIST_BMAP_MASK
expr_stmt|;
name|mask
operator|=
operator|(
operator|(
name|u_daddr_t
operator|)
operator|-
literal|1
operator|<<
name|n
operator|)
operator|&
operator|(
operator|(
name|u_daddr_t
operator|)
operator|-
literal|1
operator|>>
operator|(
name|BLIST_BMAP_RADIX
operator|-
name|count
operator|-
name|n
operator|)
operator|)
expr_stmt|;
comment|/* Count the number of blocks that we are allocating. */
name|nblks
operator|=
name|bitcount64
argument_list|(
name|scan
operator|->
name|u
operator|.
name|bmu_bitmap
operator|&
name|mask
argument_list|)
expr_stmt|;
name|scan
operator|->
name|u
operator|.
name|bmu_bitmap
operator|&=
operator|~
name|mask
expr_stmt|;
return|return
operator|(
name|nblks
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * BLIST_META_FILL() -	allocate specific blocks at a meta node  *  *	This routine allocates the specified range of blocks,  *	regardless of any existing allocations in the range.  The  *	range must be within the extent of this node.  Returns the  *	number of blocks allocated by the call.  */
end_comment

begin_function
specifier|static
name|daddr_t
name|blst_meta_fill
parameter_list|(
name|blmeta_t
modifier|*
name|scan
parameter_list|,
name|daddr_t
name|allocBlk
parameter_list|,
name|daddr_t
name|count
parameter_list|,
name|u_daddr_t
name|radix
parameter_list|)
block|{
name|daddr_t
name|blk
decl_stmt|,
name|i
decl_stmt|,
name|nblks
decl_stmt|,
name|next_skip
decl_stmt|,
name|skip
decl_stmt|,
name|v
decl_stmt|;
name|int
name|child
decl_stmt|;
if|if
condition|(
name|scan
operator|->
name|bm_bighint
operator|==
operator|(
name|daddr_t
operator|)
operator|-
literal|1
condition|)
name|panic
argument_list|(
literal|"filling invalid range"
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|>
name|radix
condition|)
block|{
comment|/* 		 * The allocation exceeds the number of blocks that are 		 * managed by this node. 		 */
name|panic
argument_list|(
literal|"fill too large"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|radix
operator|==
name|BLIST_BMAP_RADIX
condition|)
return|return
operator|(
name|blst_leaf_fill
argument_list|(
name|scan
argument_list|,
name|allocBlk
argument_list|,
name|count
argument_list|)
operator|)
return|;
if|if
condition|(
name|count
operator|==
name|radix
operator|||
name|scan
operator|->
name|u
operator|.
name|bmu_avail
operator|==
literal|0
condition|)
block|{
comment|/* 		 * ALL-ALLOCATED special case 		 */
name|nblks
operator|=
name|scan
operator|->
name|u
operator|.
name|bmu_avail
expr_stmt|;
name|scan
operator|->
name|u
operator|.
name|bmu_avail
operator|=
literal|0
expr_stmt|;
name|scan
operator|->
name|bm_bighint
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|nblks
operator|)
return|;
block|}
name|skip
operator|=
name|radix_to_skip
argument_list|(
name|radix
argument_list|)
expr_stmt|;
name|next_skip
operator|=
name|skip
operator|/
name|BLIST_META_RADIX
expr_stmt|;
name|blk
operator|=
name|allocBlk
operator|&
operator|-
name|radix
expr_stmt|;
comment|/* 	 * An ALL-FREE meta node requires special handling before allocating 	 * any of its blocks. 	 */
if|if
condition|(
name|scan
operator|->
name|u
operator|.
name|bmu_avail
operator|==
name|radix
condition|)
block|{
name|radix
operator|/=
name|BLIST_META_RADIX
expr_stmt|;
comment|/* 		 * Reinitialize each of the meta node's children.  An ALL-FREE 		 * meta node cannot have a terminator in any subtree. 		 */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|skip
condition|;
name|i
operator|+=
name|next_skip
control|)
block|{
if|if
condition|(
name|next_skip
operator|==
literal|1
condition|)
name|scan
index|[
name|i
index|]
operator|.
name|u
operator|.
name|bmu_bitmap
operator|=
operator|(
name|u_daddr_t
operator|)
operator|-
literal|1
expr_stmt|;
else|else
name|scan
index|[
name|i
index|]
operator|.
name|u
operator|.
name|bmu_avail
operator|=
name|radix
expr_stmt|;
name|scan
index|[
name|i
index|]
operator|.
name|bm_bighint
operator|=
name|radix
expr_stmt|;
block|}
block|}
else|else
block|{
name|radix
operator|/=
name|BLIST_META_RADIX
expr_stmt|;
block|}
name|nblks
operator|=
literal|0
expr_stmt|;
name|child
operator|=
operator|(
name|allocBlk
operator|-
name|blk
operator|)
operator|/
name|radix
expr_stmt|;
name|blk
operator|+=
name|child
operator|*
name|radix
expr_stmt|;
name|i
operator|=
literal|1
operator|+
name|child
operator|*
name|next_skip
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|skip
operator|&&
name|blk
operator|<
name|allocBlk
operator|+
name|count
condition|)
block|{
name|v
operator|=
name|blk
operator|+
name|radix
operator|-
name|allocBlk
expr_stmt|;
if|if
condition|(
name|v
operator|>
name|count
condition|)
name|v
operator|=
name|count
expr_stmt|;
name|nblks
operator|+=
name|blst_meta_fill
argument_list|(
operator|&
name|scan
index|[
name|i
index|]
argument_list|,
name|allocBlk
argument_list|,
name|v
argument_list|,
name|radix
argument_list|)
expr_stmt|;
name|count
operator|-=
name|v
expr_stmt|;
name|allocBlk
operator|+=
name|v
expr_stmt|;
name|blk
operator|+=
name|radix
expr_stmt|;
name|i
operator|+=
name|next_skip
expr_stmt|;
block|}
name|scan
operator|->
name|u
operator|.
name|bmu_avail
operator|-=
name|nblks
expr_stmt|;
return|return
operator|(
name|nblks
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|BLIST_DEBUG
end_ifdef

begin_function
specifier|static
name|void
name|blst_radix_print
parameter_list|(
name|blmeta_t
modifier|*
name|scan
parameter_list|,
name|daddr_t
name|blk
parameter_list|,
name|daddr_t
name|radix
parameter_list|,
name|int
name|tab
parameter_list|)
block|{
name|daddr_t
name|i
decl_stmt|,
name|next_skip
decl_stmt|,
name|skip
decl_stmt|;
if|if
condition|(
name|radix
operator|==
name|BLIST_BMAP_RADIX
condition|)
block|{
name|printf
argument_list|(
literal|"%*.*s(%08llx,%lld): bitmap %016llx big=%lld\n"
argument_list|,
name|tab
argument_list|,
name|tab
argument_list|,
literal|""
argument_list|,
operator|(
name|long
name|long
operator|)
name|blk
argument_list|,
operator|(
name|long
name|long
operator|)
name|radix
argument_list|,
operator|(
name|long
name|long
operator|)
name|scan
operator|->
name|u
operator|.
name|bmu_bitmap
argument_list|,
operator|(
name|long
name|long
operator|)
name|scan
operator|->
name|bm_bighint
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|scan
operator|->
name|u
operator|.
name|bmu_avail
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%*.*s(%08llx,%lld) ALL ALLOCATED\n"
argument_list|,
name|tab
argument_list|,
name|tab
argument_list|,
literal|""
argument_list|,
operator|(
name|long
name|long
operator|)
name|blk
argument_list|,
operator|(
name|long
name|long
operator|)
name|radix
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|scan
operator|->
name|u
operator|.
name|bmu_avail
operator|==
name|radix
condition|)
block|{
name|printf
argument_list|(
literal|"%*.*s(%08llx,%lld) ALL FREE\n"
argument_list|,
name|tab
argument_list|,
name|tab
argument_list|,
literal|""
argument_list|,
operator|(
name|long
name|long
operator|)
name|blk
argument_list|,
operator|(
name|long
name|long
operator|)
name|radix
argument_list|)
expr_stmt|;
return|return;
block|}
name|printf
argument_list|(
literal|"%*.*s(%08llx,%lld): subtree (%lld/%lld) big=%lld {\n"
argument_list|,
name|tab
argument_list|,
name|tab
argument_list|,
literal|""
argument_list|,
operator|(
name|long
name|long
operator|)
name|blk
argument_list|,
operator|(
name|long
name|long
operator|)
name|radix
argument_list|,
operator|(
name|long
name|long
operator|)
name|scan
operator|->
name|u
operator|.
name|bmu_avail
argument_list|,
operator|(
name|long
name|long
operator|)
name|radix
argument_list|,
operator|(
name|long
name|long
operator|)
name|scan
operator|->
name|bm_bighint
argument_list|)
expr_stmt|;
name|skip
operator|=
name|radix_to_skip
argument_list|(
name|radix
argument_list|)
expr_stmt|;
name|next_skip
operator|=
name|skip
operator|/
name|BLIST_META_RADIX
expr_stmt|;
name|radix
operator|/=
name|BLIST_META_RADIX
expr_stmt|;
name|tab
operator|+=
literal|4
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|skip
condition|;
name|i
operator|+=
name|next_skip
control|)
block|{
if|if
condition|(
name|scan
index|[
name|i
index|]
operator|.
name|bm_bighint
operator|==
operator|(
name|daddr_t
operator|)
operator|-
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"%*.*s(%08llx,%lld): Terminator\n"
argument_list|,
name|tab
argument_list|,
name|tab
argument_list|,
literal|""
argument_list|,
operator|(
name|long
name|long
operator|)
name|blk
argument_list|,
operator|(
name|long
name|long
operator|)
name|radix
argument_list|)
expr_stmt|;
break|break;
block|}
name|blst_radix_print
argument_list|(
operator|&
name|scan
index|[
name|i
index|]
argument_list|,
name|blk
argument_list|,
name|radix
argument_list|,
name|tab
argument_list|)
expr_stmt|;
name|blk
operator|+=
name|radix
expr_stmt|;
block|}
name|tab
operator|-=
literal|4
expr_stmt|;
name|printf
argument_list|(
literal|"%*.*s}\n"
argument_list|,
name|tab
argument_list|,
name|tab
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|BLIST_DEBUG
end_ifdef

begin_function
name|int
name|main
parameter_list|(
name|int
name|ac
parameter_list|,
name|char
modifier|*
modifier|*
name|av
parameter_list|)
block|{
name|int
name|size
init|=
literal|1024
decl_stmt|;
name|int
name|i
decl_stmt|;
name|blist_t
name|bl
decl_stmt|;
name|struct
name|sbuf
modifier|*
name|s
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|ac
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|char
modifier|*
name|ptr
init|=
name|av
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
operator|*
name|ptr
operator|!=
literal|'-'
condition|)
block|{
name|size
operator|=
name|strtol
argument_list|(
name|ptr
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|ptr
operator|+=
literal|2
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Bad option: %s\n"
argument_list|,
name|ptr
operator|-
literal|2
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|bl
operator|=
name|blist_create
argument_list|(
name|size
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|blist_free
argument_list|(
name|bl
argument_list|,
literal|0
argument_list|,
name|size
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|char
name|buf
index|[
literal|1024
index|]
decl_stmt|;
name|long
name|long
name|da
init|=
literal|0
decl_stmt|;
name|long
name|long
name|count
init|=
literal|0
decl_stmt|;
name|printf
argument_list|(
literal|"%lld/%lld/%lld> "
argument_list|,
operator|(
name|long
name|long
operator|)
name|blist_avail
argument_list|(
name|bl
argument_list|)
argument_list|,
operator|(
name|long
name|long
operator|)
name|size
argument_list|,
operator|(
name|long
name|long
operator|)
name|bl
operator|->
name|bl_radix
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|fgets
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|stdin
argument_list|)
operator|==
name|NULL
condition|)
break|break;
switch|switch
condition|(
name|buf
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|'r'
case|:
if|if
condition|(
name|sscanf
argument_list|(
name|buf
operator|+
literal|1
argument_list|,
literal|"%lld"
argument_list|,
operator|&
name|count
argument_list|)
operator|==
literal|1
condition|)
block|{
name|blist_resize
argument_list|(
operator|&
name|bl
argument_list|,
name|count
argument_list|,
literal|1
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"?\n"
argument_list|)
expr_stmt|;
block|}
case|case
literal|'p'
case|:
name|blist_print
argument_list|(
name|bl
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|s
operator|=
name|sbuf_new_auto
argument_list|()
expr_stmt|;
name|blist_stats
argument_list|(
name|bl
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|sbuf_finish
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|sbuf_data
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
name|sbuf_delete
argument_list|(
name|s
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'a'
case|:
if|if
condition|(
name|sscanf
argument_list|(
name|buf
operator|+
literal|1
argument_list|,
literal|"%lld"
argument_list|,
operator|&
name|count
argument_list|)
operator|==
literal|1
condition|)
block|{
name|daddr_t
name|blk
init|=
name|blist_alloc
argument_list|(
name|bl
argument_list|,
name|count
argument_list|)
decl_stmt|;
name|printf
argument_list|(
literal|"    R=%08llx\n"
argument_list|,
operator|(
name|long
name|long
operator|)
name|blk
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"?\n"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'f'
case|:
if|if
condition|(
name|sscanf
argument_list|(
name|buf
operator|+
literal|1
argument_list|,
literal|"%llx %lld"
argument_list|,
operator|&
name|da
argument_list|,
operator|&
name|count
argument_list|)
operator|==
literal|2
condition|)
block|{
name|blist_free
argument_list|(
name|bl
argument_list|,
name|da
argument_list|,
name|count
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"?\n"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'l'
case|:
if|if
condition|(
name|sscanf
argument_list|(
name|buf
operator|+
literal|1
argument_list|,
literal|"%llx %lld"
argument_list|,
operator|&
name|da
argument_list|,
operator|&
name|count
argument_list|)
operator|==
literal|2
condition|)
block|{
name|printf
argument_list|(
literal|"    n=%jd\n"
argument_list|,
operator|(
name|intmax_t
operator|)
name|blist_fill
argument_list|(
name|bl
argument_list|,
name|da
argument_list|,
name|count
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"?\n"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'?'
case|:
case|case
literal|'h'
case|:
name|puts
argument_list|(
literal|"p          -print\n"
literal|"s          -stats\n"
literal|"a %d       -allocate\n"
literal|"f %x %d    -free\n"
literal|"l %x %d    -fill\n"
literal|"r %d       -resize\n"
literal|"h/?        -help"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"?\n"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|panic
parameter_list|(
specifier|const
name|char
modifier|*
name|ctl
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|va
decl_stmt|;
name|va_start
argument_list|(
name|va
argument_list|,
name|ctl
argument_list|)
expr_stmt|;
name|vfprintf
argument_list|(
name|stderr
argument_list|,
name|ctl
argument_list|,
name|va
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|va
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

