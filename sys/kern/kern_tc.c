begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * ----------------------------------------------------------------------------  * "THE BEER-WARE LICENSE" (Revision 42):  *<phk@FreeBSD.ORG> wrote this file.  As long as you retain this notice you  * can do whatever you want with this stuff. If we meet some day, and you think  * this stuff is worth it, you can buy me a beer in return.   Poul-Henning Kamp  * ----------------------------------------------------------------------------  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|"opt_ntp.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/timetc.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/timex.h>
end_include

begin_include
include|#
directive|include
file|<sys/timepps.h>
end_include

begin_comment
comment|/*  * Implement a dummy timecounter which we can use until we get a real one  * in the air.  This allows the console and other early stuff to use  * timeservices.  */
end_comment

begin_function
specifier|static
name|unsigned
name|dummy_get_timecount
parameter_list|(
name|struct
name|timecounter
modifier|*
name|tc
parameter_list|)
block|{
specifier|static
name|unsigned
name|now
decl_stmt|;
return|return
operator|(
operator|++
name|now
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|timecounter
name|dummy_timecounter
init|=
block|{
name|dummy_get_timecount
block|,
literal|0
block|,
operator|~
literal|0u
block|,
literal|1000000
block|,
literal|"dummy"
block|}
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|timehands
block|{
comment|/* These fields must be initialized by the driver. */
name|struct
name|timecounter
modifier|*
name|tc_counter
decl_stmt|;
name|int64_t
name|tc_adjustment
decl_stmt|;
name|u_int64_t
name|tc_scale
decl_stmt|;
name|unsigned
name|tc_offset_count
decl_stmt|;
name|struct
name|bintime
name|tc_offset
decl_stmt|;
name|struct
name|timeval
name|tc_microtime
decl_stmt|;
name|struct
name|timespec
name|tc_nanotime
decl_stmt|;
comment|/* Fields not to be copied in tc_windup start with tc_generation */
specifier|volatile
name|unsigned
name|tc_generation
decl_stmt|;
name|struct
name|timehands
modifier|*
name|tc_next
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|extern
name|struct
name|timehands
name|th0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|timehands
name|th9
init|=
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
literal|1
block|,
operator|&
name|th0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|timehands
name|th8
init|=
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
literal|1
block|,
operator|&
name|th9
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|timehands
name|th7
init|=
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
literal|1
block|,
operator|&
name|th8
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|timehands
name|th6
init|=
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
literal|1
block|,
operator|&
name|th7
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|timehands
name|th5
init|=
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
literal|1
block|,
operator|&
name|th6
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|timehands
name|th4
init|=
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
literal|1
block|,
operator|&
name|th5
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|timehands
name|th3
init|=
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
literal|1
block|,
operator|&
name|th4
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|timehands
name|th2
init|=
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
literal|1
block|,
operator|&
name|th3
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|timehands
name|th1
init|=
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
literal|1
block|,
operator|&
name|th2
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|timehands
name|th0
init|=
block|{
operator|&
name|dummy_timecounter
block|,
literal|0
block|,
literal|18446744073709ULL
block|,
comment|/* 2^64/1000000 */
literal|0
block|,
block|{
literal|769769981
block|,
literal|0
block|}
block|,
comment|/* Tue May 24 08:59:41 GMT 1994 */
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
literal|1
block|,
operator|&
name|th1
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|timehands
modifier|*
specifier|volatile
name|timehands
init|=
operator|&
name|th0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|timecounter
modifier|*
name|timecounter
init|=
operator|&
name|dummy_timecounter
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|timecounter
modifier|*
name|timecounters
init|=
operator|&
name|dummy_timecounter
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|time_t
name|time_second
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|bintime
name|boottimebin
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|timeval
name|boottime
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_STRUCT
argument_list|(
name|_kern
argument_list|,
name|KERN_BOOTTIME
argument_list|,
name|boottime
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|boottime
argument_list|,
name|timeval
argument_list|,
literal|"System boottime"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_kern
argument_list|,
name|OID_AUTO
argument_list|,
name|timecounter
argument_list|,
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|TC_STATS
parameter_list|(
name|foo
parameter_list|)
define|\
value|static unsigned foo; \ 	SYSCTL_INT(_kern_timecounter, OID_AUTO, foo, CTLFLAG_RD,& foo, 0, "")
end_define

begin_expr_stmt
name|TC_STATS
argument_list|(
name|nbinuptime
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|TC_STATS
argument_list|(
name|nnanouptime
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|TC_STATS
argument_list|(
name|nmicrouptime
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|TC_STATS
argument_list|(
name|nbintime
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|TC_STATS
argument_list|(
name|nnanotime
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|TC_STATS
argument_list|(
name|nmicrotime
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|TC_STATS
argument_list|(
name|ngetbinuptime
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|TC_STATS
argument_list|(
name|ngetnanouptime
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|TC_STATS
argument_list|(
name|ngetmicrouptime
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|TC_STATS
argument_list|(
name|ngetbintime
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|TC_STATS
argument_list|(
name|ngetnanotime
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|TC_STATS
argument_list|(
name|ngetmicrotime
argument_list|)
expr_stmt|;
end_expr_stmt

begin_undef
undef|#
directive|undef
name|TC_STATS
end_undef

begin_function_decl
specifier|static
name|void
name|tc_windup
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|__inline
name|unsigned
name|tc_delta
parameter_list|(
name|struct
name|timehands
modifier|*
name|tc
parameter_list|)
block|{
return|return
operator|(
operator|(
name|tc
operator|->
name|tc_counter
operator|->
name|tc_get_timecount
argument_list|(
name|tc
operator|->
name|tc_counter
argument_list|)
operator|-
name|tc
operator|->
name|tc_offset_count
operator|)
operator|&
name|tc
operator|->
name|tc_counter
operator|->
name|tc_counter_mask
operator|)
return|;
block|}
end_function

begin_function
name|void
name|binuptime
parameter_list|(
name|struct
name|bintime
modifier|*
name|bt
parameter_list|)
block|{
name|struct
name|timehands
modifier|*
name|tc
decl_stmt|;
name|unsigned
name|gen
decl_stmt|;
name|nbinuptime
operator|++
expr_stmt|;
do|do
block|{
name|tc
operator|=
name|timehands
expr_stmt|;
name|gen
operator|=
name|tc
operator|->
name|tc_generation
expr_stmt|;
operator|*
name|bt
operator|=
name|tc
operator|->
name|tc_offset
expr_stmt|;
name|bintime_addx
argument_list|(
name|bt
argument_list|,
name|tc
operator|->
name|tc_scale
operator|*
name|tc_delta
argument_list|(
name|tc
argument_list|)
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|gen
operator|==
literal|0
operator|||
name|gen
operator|!=
name|tc
operator|->
name|tc_generation
condition|)
do|;
block|}
end_function

begin_function
name|void
name|nanouptime
parameter_list|(
name|struct
name|timespec
modifier|*
name|ts
parameter_list|)
block|{
name|struct
name|bintime
name|bt
decl_stmt|;
name|nnanouptime
operator|++
expr_stmt|;
name|binuptime
argument_list|(
operator|&
name|bt
argument_list|)
expr_stmt|;
name|bintime2timespec
argument_list|(
operator|&
name|bt
argument_list|,
name|ts
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|microuptime
parameter_list|(
name|struct
name|timeval
modifier|*
name|tv
parameter_list|)
block|{
name|struct
name|bintime
name|bt
decl_stmt|;
name|nmicrouptime
operator|++
expr_stmt|;
name|binuptime
argument_list|(
operator|&
name|bt
argument_list|)
expr_stmt|;
name|bintime2timeval
argument_list|(
operator|&
name|bt
argument_list|,
name|tv
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|bintime
parameter_list|(
name|struct
name|bintime
modifier|*
name|bt
parameter_list|)
block|{
name|nbintime
operator|++
expr_stmt|;
name|binuptime
argument_list|(
name|bt
argument_list|)
expr_stmt|;
name|bintime_add
argument_list|(
name|bt
argument_list|,
operator|&
name|boottimebin
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|nanotime
parameter_list|(
name|struct
name|timespec
modifier|*
name|ts
parameter_list|)
block|{
name|struct
name|bintime
name|bt
decl_stmt|;
name|nnanotime
operator|++
expr_stmt|;
name|bintime
argument_list|(
operator|&
name|bt
argument_list|)
expr_stmt|;
name|bintime2timespec
argument_list|(
operator|&
name|bt
argument_list|,
name|ts
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|microtime
parameter_list|(
name|struct
name|timeval
modifier|*
name|tv
parameter_list|)
block|{
name|struct
name|bintime
name|bt
decl_stmt|;
name|nmicrotime
operator|++
expr_stmt|;
name|bintime
argument_list|(
operator|&
name|bt
argument_list|)
expr_stmt|;
name|bintime2timeval
argument_list|(
operator|&
name|bt
argument_list|,
name|tv
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|getbinuptime
parameter_list|(
name|struct
name|bintime
modifier|*
name|bt
parameter_list|)
block|{
name|struct
name|timehands
modifier|*
name|tc
decl_stmt|;
name|unsigned
name|gen
decl_stmt|;
name|ngetbinuptime
operator|++
expr_stmt|;
do|do
block|{
name|tc
operator|=
name|timehands
expr_stmt|;
name|gen
operator|=
name|tc
operator|->
name|tc_generation
expr_stmt|;
operator|*
name|bt
operator|=
name|tc
operator|->
name|tc_offset
expr_stmt|;
block|}
do|while
condition|(
name|gen
operator|==
literal|0
operator|||
name|gen
operator|!=
name|tc
operator|->
name|tc_generation
condition|)
do|;
block|}
end_function

begin_function
name|void
name|getnanouptime
parameter_list|(
name|struct
name|timespec
modifier|*
name|tsp
parameter_list|)
block|{
name|struct
name|timehands
modifier|*
name|tc
decl_stmt|;
name|unsigned
name|gen
decl_stmt|;
name|ngetnanouptime
operator|++
expr_stmt|;
do|do
block|{
name|tc
operator|=
name|timehands
expr_stmt|;
name|gen
operator|=
name|tc
operator|->
name|tc_generation
expr_stmt|;
name|bintime2timespec
argument_list|(
operator|&
name|tc
operator|->
name|tc_offset
argument_list|,
name|tsp
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|gen
operator|==
literal|0
operator|||
name|gen
operator|!=
name|tc
operator|->
name|tc_generation
condition|)
do|;
block|}
end_function

begin_function
name|void
name|getmicrouptime
parameter_list|(
name|struct
name|timeval
modifier|*
name|tvp
parameter_list|)
block|{
name|struct
name|timehands
modifier|*
name|tc
decl_stmt|;
name|unsigned
name|gen
decl_stmt|;
name|ngetmicrouptime
operator|++
expr_stmt|;
do|do
block|{
name|tc
operator|=
name|timehands
expr_stmt|;
name|gen
operator|=
name|tc
operator|->
name|tc_generation
expr_stmt|;
name|bintime2timeval
argument_list|(
operator|&
name|tc
operator|->
name|tc_offset
argument_list|,
name|tvp
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|gen
operator|==
literal|0
operator|||
name|gen
operator|!=
name|tc
operator|->
name|tc_generation
condition|)
do|;
block|}
end_function

begin_function
name|void
name|getbintime
parameter_list|(
name|struct
name|bintime
modifier|*
name|bt
parameter_list|)
block|{
name|struct
name|timehands
modifier|*
name|tc
decl_stmt|;
name|unsigned
name|gen
decl_stmt|;
name|ngetbintime
operator|++
expr_stmt|;
do|do
block|{
name|tc
operator|=
name|timehands
expr_stmt|;
name|gen
operator|=
name|tc
operator|->
name|tc_generation
expr_stmt|;
operator|*
name|bt
operator|=
name|tc
operator|->
name|tc_offset
expr_stmt|;
block|}
do|while
condition|(
name|gen
operator|==
literal|0
operator|||
name|gen
operator|!=
name|tc
operator|->
name|tc_generation
condition|)
do|;
name|bintime_add
argument_list|(
name|bt
argument_list|,
operator|&
name|boottimebin
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|getnanotime
parameter_list|(
name|struct
name|timespec
modifier|*
name|tsp
parameter_list|)
block|{
name|struct
name|timehands
modifier|*
name|tc
decl_stmt|;
name|unsigned
name|gen
decl_stmt|;
name|ngetnanotime
operator|++
expr_stmt|;
do|do
block|{
name|tc
operator|=
name|timehands
expr_stmt|;
name|gen
operator|=
name|tc
operator|->
name|tc_generation
expr_stmt|;
operator|*
name|tsp
operator|=
name|tc
operator|->
name|tc_nanotime
expr_stmt|;
block|}
do|while
condition|(
name|gen
operator|==
literal|0
operator|||
name|gen
operator|!=
name|tc
operator|->
name|tc_generation
condition|)
do|;
block|}
end_function

begin_function
name|void
name|getmicrotime
parameter_list|(
name|struct
name|timeval
modifier|*
name|tvp
parameter_list|)
block|{
name|struct
name|timehands
modifier|*
name|tc
decl_stmt|;
name|unsigned
name|gen
decl_stmt|;
name|ngetmicrotime
operator|++
expr_stmt|;
do|do
block|{
name|tc
operator|=
name|timehands
expr_stmt|;
name|gen
operator|=
name|tc
operator|->
name|tc_generation
expr_stmt|;
operator|*
name|tvp
operator|=
name|tc
operator|->
name|tc_microtime
expr_stmt|;
block|}
do|while
condition|(
name|gen
operator|==
literal|0
operator|||
name|gen
operator|!=
name|tc
operator|->
name|tc_generation
condition|)
do|;
block|}
end_function

begin_function
specifier|static
name|void
name|tc_setscales
parameter_list|(
name|struct
name|timehands
modifier|*
name|tc
parameter_list|)
block|{
name|u_int64_t
name|scale
decl_stmt|;
comment|/* Sacrifice the lower bit to the deity for code clarity */
name|scale
operator|=
literal|1ULL
operator|<<
literal|63
expr_stmt|;
comment|/*  	 * We get nanoseconds with 32 bit binary fraction and want 	 * 64 bit binary fraction: x = a * 2^32 / 10^9 = a * 4.294967296 	 * The range is +/- 5000PPM so we can only multiply by about 850 	 * without overflowing.  The best suitable fraction is 2199/512. 	 * Divide by 2 times 512 to match the temporary lower precision. 	 */
name|scale
operator|+=
operator|(
name|tc
operator|->
name|tc_adjustment
operator|/
literal|1024
operator|)
operator|*
literal|2199
expr_stmt|;
name|scale
operator|/=
name|tc
operator|->
name|tc_counter
operator|->
name|tc_frequency
expr_stmt|;
name|tc
operator|->
name|tc_scale
operator|=
name|scale
operator|*
literal|2
expr_stmt|;
block|}
end_function

begin_function
name|void
name|tc_init
parameter_list|(
name|struct
name|timecounter
modifier|*
name|tc
parameter_list|)
block|{
name|tc
operator|->
name|tc_next
operator|=
name|timecounters
expr_stmt|;
name|timecounters
operator|=
name|tc
expr_stmt|;
name|printf
argument_list|(
literal|"Timecounter \"%s\"  frequency %lu Hz\n"
argument_list|,
name|tc
operator|->
name|tc_name
argument_list|,
operator|(
name|u_long
operator|)
name|tc
operator|->
name|tc_frequency
argument_list|)
expr_stmt|;
name|timecounter
operator|=
name|tc
expr_stmt|;
block|}
end_function

begin_function
name|u_int32_t
name|tc_getfrequency
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
name|timehands
operator|->
name|tc_counter
operator|->
name|tc_frequency
operator|)
return|;
block|}
end_function

begin_function
name|void
name|tc_setclock
parameter_list|(
name|struct
name|timespec
modifier|*
name|ts
parameter_list|)
block|{
name|struct
name|timespec
name|ts2
decl_stmt|;
name|nanouptime
argument_list|(
operator|&
name|ts2
argument_list|)
expr_stmt|;
name|boottime
operator|.
name|tv_sec
operator|=
name|ts
operator|->
name|tv_sec
operator|-
name|ts2
operator|.
name|tv_sec
expr_stmt|;
name|boottime
operator|.
name|tv_usec
operator|=
operator|(
name|ts
operator|->
name|tv_nsec
operator|-
name|ts2
operator|.
name|tv_nsec
operator|)
operator|/
literal|1000
expr_stmt|;
if|if
condition|(
name|boottime
operator|.
name|tv_usec
operator|<
literal|0
condition|)
block|{
name|boottime
operator|.
name|tv_usec
operator|+=
literal|1000000
expr_stmt|;
name|boottime
operator|.
name|tv_sec
operator|--
expr_stmt|;
block|}
name|timeval2bintime
argument_list|(
operator|&
name|boottime
argument_list|,
operator|&
name|boottimebin
argument_list|)
expr_stmt|;
comment|/* fiddle all the little crinkly bits around the fiords... */
name|tc_windup
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|tc_windup
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|timehands
modifier|*
name|tc
decl_stmt|,
modifier|*
name|tco
decl_stmt|;
name|struct
name|bintime
name|bt
decl_stmt|;
name|unsigned
name|ogen
decl_stmt|,
name|delta
decl_stmt|,
name|ncount
decl_stmt|;
name|int
name|i
decl_stmt|;
name|ncount
operator|=
literal|0
expr_stmt|;
comment|/* GCC is lame */
name|tco
operator|=
name|timehands
expr_stmt|;
name|tc
operator|=
name|tco
operator|->
name|tc_next
expr_stmt|;
name|ogen
operator|=
name|tc
operator|->
name|tc_generation
expr_stmt|;
name|tc
operator|->
name|tc_generation
operator|=
literal|0
expr_stmt|;
name|bcopy
argument_list|(
name|tco
argument_list|,
name|tc
argument_list|,
name|__offsetof
argument_list|(
expr|struct
name|timehands
argument_list|,
name|tc_generation
argument_list|)
argument_list|)
expr_stmt|;
name|delta
operator|=
name|tc_delta
argument_list|(
name|tc
argument_list|)
expr_stmt|;
if|if
condition|(
name|tc
operator|->
name|tc_counter
operator|!=
name|timecounter
condition|)
name|ncount
operator|=
name|timecounter
operator|->
name|tc_get_timecount
argument_list|(
name|timecounter
argument_list|)
expr_stmt|;
name|tc
operator|->
name|tc_offset_count
operator|+=
name|delta
expr_stmt|;
name|tc
operator|->
name|tc_offset_count
operator|&=
name|tc
operator|->
name|tc_counter
operator|->
name|tc_counter_mask
expr_stmt|;
name|bintime_addx
argument_list|(
operator|&
name|tc
operator|->
name|tc_offset
argument_list|,
name|tc
operator|->
name|tc_scale
operator|*
name|delta
argument_list|)
expr_stmt|;
comment|/* 	 * We may be inducing a tiny error here, the tc_poll_pps() may 	 * process a latched count which happens after the tc_delta() 	 * in sync_other_counter(), which would extend the previous 	 * counters parameters into the domain of this new one. 	 * Since the timewindow is very small for this, the error is 	 * going to be only a few weenieseconds (as Dave Mills would 	 * say), so lets just not talk more about it, OK ? 	 */
if|if
condition|(
name|tco
operator|->
name|tc_counter
operator|->
name|tc_poll_pps
condition|)
name|tco
operator|->
name|tc_counter
operator|->
name|tc_poll_pps
argument_list|(
name|tco
operator|->
name|tc_counter
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|tc
operator|->
name|tc_offset
operator|.
name|sec
operator|-
name|tco
operator|->
name|tc_offset
operator|.
name|sec
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
name|ntp_update_second
argument_list|(
operator|&
name|tc
operator|->
name|tc_adjustment
argument_list|,
operator|&
name|tc
operator|->
name|tc_offset
operator|.
name|sec
argument_list|)
expr_stmt|;
if|if
condition|(
name|tc
operator|->
name|tc_counter
operator|!=
name|timecounter
condition|)
block|{
name|tc
operator|->
name|tc_counter
operator|=
name|timecounter
expr_stmt|;
name|tc
operator|->
name|tc_offset_count
operator|=
name|ncount
expr_stmt|;
block|}
name|tc_setscales
argument_list|(
name|tc
argument_list|)
expr_stmt|;
name|bt
operator|=
name|tc
operator|->
name|tc_offset
expr_stmt|;
name|bintime_add
argument_list|(
operator|&
name|bt
argument_list|,
operator|&
name|boottimebin
argument_list|)
expr_stmt|;
name|bintime2timeval
argument_list|(
operator|&
name|bt
argument_list|,
operator|&
name|tc
operator|->
name|tc_microtime
argument_list|)
expr_stmt|;
name|bintime2timespec
argument_list|(
operator|&
name|bt
argument_list|,
operator|&
name|tc
operator|->
name|tc_nanotime
argument_list|)
expr_stmt|;
name|ogen
operator|++
expr_stmt|;
if|if
condition|(
name|ogen
operator|==
literal|0
condition|)
name|ogen
operator|++
expr_stmt|;
name|tc
operator|->
name|tc_generation
operator|=
name|ogen
expr_stmt|;
name|time_second
operator|=
name|tc
operator|->
name|tc_microtime
operator|.
name|tv_sec
expr_stmt|;
name|timehands
operator|=
name|tc
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|sysctl_kern_timecounter_hardware
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|char
name|newname
index|[
literal|32
index|]
decl_stmt|;
name|struct
name|timecounter
modifier|*
name|newtc
decl_stmt|,
modifier|*
name|tc
decl_stmt|;
name|int
name|error
decl_stmt|;
name|tc
operator|=
name|timecounter
expr_stmt|;
name|strncpy
argument_list|(
name|newname
argument_list|,
name|tc
operator|->
name|tc_name
argument_list|,
sizeof|sizeof
argument_list|(
name|newname
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|sysctl_handle_string
argument_list|(
name|oidp
argument_list|,
operator|&
name|newname
index|[
literal|0
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|newname
argument_list|)
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
operator|&&
name|req
operator|->
name|newptr
operator|==
name|NULL
operator|&&
operator|!
name|strcmp
argument_list|(
name|newname
argument_list|,
name|tc
operator|->
name|tc_name
argument_list|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
for|for
control|(
name|newtc
operator|=
name|timecounters
init|;
name|newtc
operator|!=
name|NULL
condition|;
name|newtc
operator|=
name|newtc
operator|->
name|tc_next
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|newname
argument_list|,
name|newtc
operator|->
name|tc_name
argument_list|)
condition|)
continue|continue;
comment|/* Warm up new timecounter. */
operator|(
name|void
operator|)
name|newtc
operator|->
name|tc_get_timecount
argument_list|(
name|newtc
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|newtc
operator|->
name|tc_get_timecount
argument_list|(
name|newtc
argument_list|)
expr_stmt|;
name|timecounter
operator|=
name|newtc
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|SYSCTL_PROC
argument_list|(
name|_kern_timecounter
argument_list|,
name|OID_AUTO
argument_list|,
name|hardware
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|sysctl_kern_timecounter_hardware
argument_list|,
literal|"A"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
name|int
name|pps_ioctl
parameter_list|(
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|data
parameter_list|,
name|struct
name|pps_state
modifier|*
name|pps
parameter_list|)
block|{
name|pps_params_t
modifier|*
name|app
decl_stmt|;
name|struct
name|pps_fetch_args
modifier|*
name|fapi
decl_stmt|;
ifdef|#
directive|ifdef
name|PPS_SYNC
name|struct
name|pps_kcbind_args
modifier|*
name|kapi
decl_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|PPS_IOC_CREATE
case|:
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|PPS_IOC_DESTROY
case|:
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|PPS_IOC_SETPARAMS
case|:
name|app
operator|=
operator|(
name|pps_params_t
operator|*
operator|)
name|data
expr_stmt|;
if|if
condition|(
name|app
operator|->
name|mode
operator|&
operator|~
name|pps
operator|->
name|ppscap
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|pps
operator|->
name|ppsparam
operator|=
operator|*
name|app
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|PPS_IOC_GETPARAMS
case|:
name|app
operator|=
operator|(
name|pps_params_t
operator|*
operator|)
name|data
expr_stmt|;
operator|*
name|app
operator|=
name|pps
operator|->
name|ppsparam
expr_stmt|;
name|app
operator|->
name|api_version
operator|=
name|PPS_API_VERS_1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|PPS_IOC_GETCAP
case|:
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|pps
operator|->
name|ppscap
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|PPS_IOC_FETCH
case|:
name|fapi
operator|=
operator|(
expr|struct
name|pps_fetch_args
operator|*
operator|)
name|data
expr_stmt|;
if|if
condition|(
name|fapi
operator|->
name|tsformat
operator|&&
name|fapi
operator|->
name|tsformat
operator|!=
name|PPS_TSFMT_TSPEC
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|fapi
operator|->
name|timeout
operator|.
name|tv_sec
operator|||
name|fapi
operator|->
name|timeout
operator|.
name|tv_nsec
condition|)
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
name|pps
operator|->
name|ppsinfo
operator|.
name|current_mode
operator|=
name|pps
operator|->
name|ppsparam
operator|.
name|mode
expr_stmt|;
name|fapi
operator|->
name|pps_info_buf
operator|=
name|pps
operator|->
name|ppsinfo
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|PPS_IOC_KCBIND
case|:
ifdef|#
directive|ifdef
name|PPS_SYNC
name|kapi
operator|=
operator|(
expr|struct
name|pps_kcbind_args
operator|*
operator|)
name|data
expr_stmt|;
comment|/* XXX Only root should be able to do this */
if|if
condition|(
name|kapi
operator|->
name|tsformat
operator|&&
name|kapi
operator|->
name|tsformat
operator|!=
name|PPS_TSFMT_TSPEC
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|kapi
operator|->
name|kernel_consumer
operator|!=
name|PPS_KC_HARDPPS
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|kapi
operator|->
name|edge
operator|&
operator|~
name|pps
operator|->
name|ppscap
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|pps
operator|->
name|kcmode
operator|=
name|kapi
operator|->
name|edge
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
else|#
directive|else
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
endif|#
directive|endif
default|default:
return|return
operator|(
name|ENOTTY
operator|)
return|;
block|}
block|}
end_function

begin_function
name|void
name|pps_init
parameter_list|(
name|struct
name|pps_state
modifier|*
name|pps
parameter_list|)
block|{
name|pps
operator|->
name|ppscap
operator||=
name|PPS_TSFMT_TSPEC
expr_stmt|;
if|if
condition|(
name|pps
operator|->
name|ppscap
operator|&
name|PPS_CAPTUREASSERT
condition|)
name|pps
operator|->
name|ppscap
operator||=
name|PPS_OFFSETASSERT
expr_stmt|;
if|if
condition|(
name|pps
operator|->
name|ppscap
operator|&
name|PPS_CAPTURECLEAR
condition|)
name|pps
operator|->
name|ppscap
operator||=
name|PPS_OFFSETCLEAR
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pps_capture
parameter_list|(
name|struct
name|pps_state
modifier|*
name|pps
parameter_list|)
block|{
name|struct
name|timehands
modifier|*
name|tc
decl_stmt|;
name|tc
operator|=
name|timehands
expr_stmt|;
name|pps
operator|->
name|captc
operator|=
name|tc
expr_stmt|;
name|pps
operator|->
name|capgen
operator|=
name|tc
operator|->
name|tc_generation
expr_stmt|;
name|pps
operator|->
name|capcount
operator|=
name|tc
operator|->
name|tc_counter
operator|->
name|tc_get_timecount
argument_list|(
name|tc
operator|->
name|tc_counter
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pps_event
parameter_list|(
name|struct
name|pps_state
modifier|*
name|pps
parameter_list|,
name|int
name|event
parameter_list|)
block|{
name|struct
name|timespec
name|ts
decl_stmt|,
modifier|*
name|tsp
decl_stmt|,
modifier|*
name|osp
decl_stmt|;
name|unsigned
name|tcount
decl_stmt|,
modifier|*
name|pcount
decl_stmt|;
name|struct
name|bintime
name|bt
decl_stmt|;
name|int
name|foff
decl_stmt|,
name|fhard
decl_stmt|;
name|pps_seq_t
modifier|*
name|pseq
decl_stmt|;
comment|/* If the timecounter were wound up, bail. */
if|if
condition|(
name|pps
operator|->
name|capgen
operator|!=
name|pps
operator|->
name|capgen
condition|)
return|return;
comment|/* Things would be easier with arrays... */
if|if
condition|(
name|event
operator|==
name|PPS_CAPTUREASSERT
condition|)
block|{
name|tsp
operator|=
operator|&
name|pps
operator|->
name|ppsinfo
operator|.
name|assert_timestamp
expr_stmt|;
name|osp
operator|=
operator|&
name|pps
operator|->
name|ppsparam
operator|.
name|assert_offset
expr_stmt|;
name|foff
operator|=
name|pps
operator|->
name|ppsparam
operator|.
name|mode
operator|&
name|PPS_OFFSETASSERT
expr_stmt|;
name|fhard
operator|=
name|pps
operator|->
name|kcmode
operator|&
name|PPS_CAPTUREASSERT
expr_stmt|;
name|pcount
operator|=
operator|&
name|pps
operator|->
name|ppscount
index|[
literal|0
index|]
expr_stmt|;
name|pseq
operator|=
operator|&
name|pps
operator|->
name|ppsinfo
operator|.
name|assert_sequence
expr_stmt|;
block|}
else|else
block|{
name|tsp
operator|=
operator|&
name|pps
operator|->
name|ppsinfo
operator|.
name|clear_timestamp
expr_stmt|;
name|osp
operator|=
operator|&
name|pps
operator|->
name|ppsparam
operator|.
name|clear_offset
expr_stmt|;
name|foff
operator|=
name|pps
operator|->
name|ppsparam
operator|.
name|mode
operator|&
name|PPS_OFFSETCLEAR
expr_stmt|;
name|fhard
operator|=
name|pps
operator|->
name|kcmode
operator|&
name|PPS_CAPTURECLEAR
expr_stmt|;
name|pcount
operator|=
operator|&
name|pps
operator|->
name|ppscount
index|[
literal|1
index|]
expr_stmt|;
name|pseq
operator|=
operator|&
name|pps
operator|->
name|ppsinfo
operator|.
name|clear_sequence
expr_stmt|;
block|}
comment|/* The timecounter changed: bail */
if|if
condition|(
operator|!
name|pps
operator|->
name|ppstc
operator|||
name|pps
operator|->
name|ppstc
operator|!=
name|pps
operator|->
name|captc
operator|->
name|tc_counter
operator|||
name|pps
operator|->
name|captc
operator|->
name|tc_counter
operator|!=
name|timehands
operator|->
name|tc_counter
condition|)
block|{
name|pps
operator|->
name|ppstc
operator|=
name|pps
operator|->
name|captc
operator|->
name|tc_counter
expr_stmt|;
operator|*
name|pcount
operator|=
name|pps
operator|->
name|capcount
expr_stmt|;
ifdef|#
directive|ifdef
name|PPS_SYNC
name|pps
operator|->
name|ppscount
index|[
literal|2
index|]
operator|=
name|pps
operator|->
name|capcount
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
comment|/* Nothing really happened */
if|if
condition|(
operator|*
name|pcount
operator|==
name|pps
operator|->
name|capcount
condition|)
return|return;
comment|/* Convert the count to timespec */
name|tcount
operator|=
name|pps
operator|->
name|capcount
operator|-
name|pps
operator|->
name|captc
operator|->
name|tc_offset_count
expr_stmt|;
name|tcount
operator|&=
name|pps
operator|->
name|captc
operator|->
name|tc_counter
operator|->
name|tc_counter_mask
expr_stmt|;
name|bt
operator|=
name|pps
operator|->
name|captc
operator|->
name|tc_offset
expr_stmt|;
name|bintime_addx
argument_list|(
operator|&
name|bt
argument_list|,
name|pps
operator|->
name|captc
operator|->
name|tc_scale
operator|*
name|tcount
argument_list|)
expr_stmt|;
name|bintime2timespec
argument_list|(
operator|&
name|bt
argument_list|,
operator|&
name|ts
argument_list|)
expr_stmt|;
comment|/* If the timecounter were wound up, bail. */
if|if
condition|(
name|pps
operator|->
name|capgen
operator|!=
name|pps
operator|->
name|capgen
condition|)
return|return;
operator|*
name|pcount
operator|=
name|pps
operator|->
name|capcount
expr_stmt|;
operator|(
operator|*
name|pseq
operator|)
operator|++
expr_stmt|;
operator|*
name|tsp
operator|=
name|ts
expr_stmt|;
if|if
condition|(
name|foff
condition|)
block|{
name|timespecadd
argument_list|(
name|tsp
argument_list|,
name|osp
argument_list|)
expr_stmt|;
if|if
condition|(
name|tsp
operator|->
name|tv_nsec
operator|<
literal|0
condition|)
block|{
name|tsp
operator|->
name|tv_nsec
operator|+=
literal|1000000000
expr_stmt|;
name|tsp
operator|->
name|tv_sec
operator|-=
literal|1
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|PPS_SYNC
if|if
condition|(
name|fhard
condition|)
block|{
comment|/* magic, at its best... */
name|tcount
operator|=
name|pps
operator|->
name|capcount
operator|-
name|pps
operator|->
name|ppscount
index|[
literal|2
index|]
expr_stmt|;
name|pps
operator|->
name|ppscount
index|[
literal|2
index|]
operator|=
name|pps
operator|->
name|capcount
expr_stmt|;
name|tcount
operator|&=
name|pps
operator|->
name|captc
operator|->
name|tc_counter
operator|->
name|tc_counter_mask
expr_stmt|;
name|bt
operator|.
name|sec
operator|=
literal|0
expr_stmt|;
name|bt
operator|.
name|frac
operator|=
literal|0
expr_stmt|;
name|bintime_addx
argument_list|(
operator|&
name|bt
argument_list|,
name|pps
operator|->
name|captc
operator|->
name|tc_scale
operator|*
name|tcount
argument_list|)
expr_stmt|;
name|bintime2timespec
argument_list|(
operator|&
name|bt
argument_list|,
operator|&
name|ts
argument_list|)
expr_stmt|;
name|hardpps
argument_list|(
name|tsp
argument_list|,
name|ts
operator|.
name|tv_nsec
operator|+
literal|1000000000
operator|*
name|ts
operator|.
name|tv_sec
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*-  * Timecounters need to be updated every so often to prevent the hardware  * counter from overflowing.  Updating also recalculates the cached values  * used by the get*() family of functions, so their precision depends on  * the update frequency.  * Don't update faster than approx once per millisecond, if people want  * better timestamps they should use the non-"get" functions.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|tc_tick
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_kern_timecounter
argument_list|,
name|OID_AUTO
argument_list|,
name|tick
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|tick
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|void
name|tc_ticktock
parameter_list|(
name|void
modifier|*
name|dummy
parameter_list|)
block|{
name|tc_windup
argument_list|()
expr_stmt|;
name|timeout
argument_list|(
name|tc_ticktock
argument_list|,
name|NULL
argument_list|,
name|tc_tick
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|inittimecounter
parameter_list|(
name|void
modifier|*
name|dummy
parameter_list|)
block|{
name|u_int
name|p
decl_stmt|;
if|if
condition|(
name|hz
operator|>
literal|1000
condition|)
name|tc_tick
operator|=
operator|(
name|hz
operator|+
literal|500
operator|)
operator|/
literal|1000
expr_stmt|;
else|else
name|tc_tick
operator|=
literal|1
expr_stmt|;
name|p
operator|=
operator|(
name|tc_tick
operator|*
literal|1000000
operator|)
operator|/
name|hz
expr_stmt|;
name|printf
argument_list|(
literal|"Timecounters tick every %d.%03u msec\n"
argument_list|,
name|p
operator|/
literal|1000
argument_list|,
name|p
operator|%
literal|1000
argument_list|)
expr_stmt|;
name|tc_ticktock
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_macro
name|SYSINIT
argument_list|(
argument|timecounter
argument_list|,
argument|SI_SUB_CLOCKS
argument_list|,
argument|SI_ORDER_FIRST
argument_list|,
argument|inittimecounter
argument_list|,
argument|NULL
argument_list|)
end_macro

end_unit

