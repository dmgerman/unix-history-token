begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * ----------------------------------------------------------------------------  * "THE BEER-WARE LICENSE" (Revision 42):  *<phk@FreeBSD.ORG> wrote this file.  As long as you retain this notice you  * can do whatever you want with this stuff. If we meet some day, and you think  * this stuff is worth it, you can buy me a beer in return.   Poul-Henning Kamp  * ----------------------------------------------------------------------------  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|"opt_ntp.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/timepps.h>
end_include

begin_include
include|#
directive|include
file|<sys/timetc.h>
end_include

begin_include
include|#
directive|include
file|<sys/timex.h>
end_include

begin_comment
comment|/*  * Implement a dummy timecounter which we can use until we get a real one  * in the air.  This allows the console and other early stuff to use  * time services.  */
end_comment

begin_function
specifier|static
name|u_int
name|dummy_get_timecount
parameter_list|(
name|struct
name|timecounter
modifier|*
name|tc
parameter_list|)
block|{
specifier|static
name|u_int
name|now
decl_stmt|;
return|return
operator|(
operator|++
name|now
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|timecounter
name|dummy_timecounter
init|=
block|{
name|dummy_get_timecount
block|,
literal|0
block|,
operator|~
literal|0u
block|,
literal|1000000
block|,
literal|"dummy"
block|, }
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|timehands
block|{
comment|/* These fields must be initialized by the driver. */
name|struct
name|timecounter
modifier|*
name|th_counter
decl_stmt|;
name|int64_t
name|th_adjustment
decl_stmt|;
name|u_int64_t
name|th_scale
decl_stmt|;
name|u_int
name|th_offset_count
decl_stmt|;
name|struct
name|bintime
name|th_offset
decl_stmt|;
name|struct
name|timeval
name|th_microtime
decl_stmt|;
name|struct
name|timespec
name|th_nanotime
decl_stmt|;
comment|/* Fields not to be copied in tc_windup start with th_generation. */
specifier|volatile
name|u_int
name|th_generation
decl_stmt|;
name|struct
name|timehands
modifier|*
name|th_next
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|extern
name|struct
name|timehands
name|th0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|timehands
name|th9
init|=
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
literal|0
block|,
operator|&
name|th0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|timehands
name|th8
init|=
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
literal|0
block|,
operator|&
name|th9
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|timehands
name|th7
init|=
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
literal|0
block|,
operator|&
name|th8
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|timehands
name|th6
init|=
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
literal|0
block|,
operator|&
name|th7
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|timehands
name|th5
init|=
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
literal|0
block|,
operator|&
name|th6
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|timehands
name|th4
init|=
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
literal|0
block|,
operator|&
name|th5
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|timehands
name|th3
init|=
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
literal|0
block|,
operator|&
name|th4
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|timehands
name|th2
init|=
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
literal|0
block|,
operator|&
name|th3
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|timehands
name|th1
init|=
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
literal|0
block|,
operator|&
name|th2
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|timehands
name|th0
init|=
block|{
operator|&
name|dummy_timecounter
block|,
literal|0
block|,
operator|(
name|uint64_t
operator|)
operator|-
literal|1
operator|/
literal|1000000
block|,
literal|0
block|,
block|{
literal|1
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
literal|1
block|,
operator|&
name|th1
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|timehands
modifier|*
specifier|volatile
name|timehands
init|=
operator|&
name|th0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|timecounter
modifier|*
name|timecounter
init|=
operator|&
name|dummy_timecounter
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|timecounter
modifier|*
name|timecounters
init|=
operator|&
name|dummy_timecounter
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|time_t
name|time_second
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|bintime
name|boottimebin
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|timeval
name|boottime
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_STRUCT
argument_list|(
name|_kern
argument_list|,
name|KERN_BOOTTIME
argument_list|,
name|boottime
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|boottime
argument_list|,
name|timeval
argument_list|,
literal|"System boottime"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_kern
argument_list|,
name|OID_AUTO
argument_list|,
name|timecounter
argument_list|,
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|TC_STATS
parameter_list|(
name|foo
parameter_list|)
define|\
value|static u_int foo; \ 	SYSCTL_UINT(_kern_timecounter, OID_AUTO, foo, CTLFLAG_RD,&foo, 0, "");\ 	struct __hack
end_define

begin_expr_stmt
name|TC_STATS
argument_list|(
name|nbinuptime
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|TC_STATS
argument_list|(
name|nnanouptime
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|TC_STATS
argument_list|(
name|nmicrouptime
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|TC_STATS
argument_list|(
name|nbintime
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|TC_STATS
argument_list|(
name|nnanotime
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|TC_STATS
argument_list|(
name|nmicrotime
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|TC_STATS
argument_list|(
name|ngetbinuptime
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|TC_STATS
argument_list|(
name|ngetnanouptime
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|TC_STATS
argument_list|(
name|ngetmicrouptime
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|TC_STATS
argument_list|(
name|ngetbintime
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|TC_STATS
argument_list|(
name|ngetnanotime
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|TC_STATS
argument_list|(
name|ngetmicrotime
argument_list|)
expr_stmt|;
end_expr_stmt

begin_undef
undef|#
directive|undef
name|TC_STATS
end_undef

begin_function_decl
specifier|static
name|void
name|tc_windup
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Return the difference between the timehands' counter value now and what  * was when we copied it to the timehands' offset_count.  */
end_comment

begin_function
specifier|static
name|__inline
name|u_int
name|tc_delta
parameter_list|(
name|struct
name|timehands
modifier|*
name|th
parameter_list|)
block|{
name|struct
name|timecounter
modifier|*
name|tc
decl_stmt|;
name|tc
operator|=
name|th
operator|->
name|th_counter
expr_stmt|;
return|return
operator|(
operator|(
name|tc
operator|->
name|tc_get_timecount
argument_list|(
name|tc
argument_list|)
operator|-
name|th
operator|->
name|th_offset_count
operator|)
operator|&
name|tc
operator|->
name|tc_counter_mask
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Functions for reading the time.  We have to loop until we are sure that  * the timehands that we operated on was not updated under our feet.  See  * the comment in<sys/time.h> for a description of these 12 functions.  */
end_comment

begin_function
name|void
name|binuptime
parameter_list|(
name|struct
name|bintime
modifier|*
name|bt
parameter_list|)
block|{
name|struct
name|timehands
modifier|*
name|th
decl_stmt|;
name|u_int
name|gen
decl_stmt|;
name|nbinuptime
operator|++
expr_stmt|;
do|do
block|{
name|th
operator|=
name|timehands
expr_stmt|;
name|gen
operator|=
name|th
operator|->
name|th_generation
expr_stmt|;
operator|*
name|bt
operator|=
name|th
operator|->
name|th_offset
expr_stmt|;
name|bintime_addx
argument_list|(
name|bt
argument_list|,
name|th
operator|->
name|th_scale
operator|*
name|tc_delta
argument_list|(
name|th
argument_list|)
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|gen
operator|==
literal|0
operator|||
name|gen
operator|!=
name|th
operator|->
name|th_generation
condition|)
do|;
block|}
end_function

begin_function
name|void
name|nanouptime
parameter_list|(
name|struct
name|timespec
modifier|*
name|tsp
parameter_list|)
block|{
name|struct
name|bintime
name|bt
decl_stmt|;
name|nnanouptime
operator|++
expr_stmt|;
name|binuptime
argument_list|(
operator|&
name|bt
argument_list|)
expr_stmt|;
name|bintime2timespec
argument_list|(
operator|&
name|bt
argument_list|,
name|tsp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|microuptime
parameter_list|(
name|struct
name|timeval
modifier|*
name|tvp
parameter_list|)
block|{
name|struct
name|bintime
name|bt
decl_stmt|;
name|nmicrouptime
operator|++
expr_stmt|;
name|binuptime
argument_list|(
operator|&
name|bt
argument_list|)
expr_stmt|;
name|bintime2timeval
argument_list|(
operator|&
name|bt
argument_list|,
name|tvp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|bintime
parameter_list|(
name|struct
name|bintime
modifier|*
name|bt
parameter_list|)
block|{
name|nbintime
operator|++
expr_stmt|;
name|binuptime
argument_list|(
name|bt
argument_list|)
expr_stmt|;
name|bintime_add
argument_list|(
name|bt
argument_list|,
operator|&
name|boottimebin
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|nanotime
parameter_list|(
name|struct
name|timespec
modifier|*
name|tsp
parameter_list|)
block|{
name|struct
name|bintime
name|bt
decl_stmt|;
name|nnanotime
operator|++
expr_stmt|;
name|bintime
argument_list|(
operator|&
name|bt
argument_list|)
expr_stmt|;
name|bintime2timespec
argument_list|(
operator|&
name|bt
argument_list|,
name|tsp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|microtime
parameter_list|(
name|struct
name|timeval
modifier|*
name|tvp
parameter_list|)
block|{
name|struct
name|bintime
name|bt
decl_stmt|;
name|nmicrotime
operator|++
expr_stmt|;
name|bintime
argument_list|(
operator|&
name|bt
argument_list|)
expr_stmt|;
name|bintime2timeval
argument_list|(
operator|&
name|bt
argument_list|,
name|tvp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|getbinuptime
parameter_list|(
name|struct
name|bintime
modifier|*
name|bt
parameter_list|)
block|{
name|struct
name|timehands
modifier|*
name|th
decl_stmt|;
name|u_int
name|gen
decl_stmt|;
name|ngetbinuptime
operator|++
expr_stmt|;
do|do
block|{
name|th
operator|=
name|timehands
expr_stmt|;
name|gen
operator|=
name|th
operator|->
name|th_generation
expr_stmt|;
operator|*
name|bt
operator|=
name|th
operator|->
name|th_offset
expr_stmt|;
block|}
do|while
condition|(
name|gen
operator|==
literal|0
operator|||
name|gen
operator|!=
name|th
operator|->
name|th_generation
condition|)
do|;
block|}
end_function

begin_function
name|void
name|getnanouptime
parameter_list|(
name|struct
name|timespec
modifier|*
name|tsp
parameter_list|)
block|{
name|struct
name|timehands
modifier|*
name|th
decl_stmt|;
name|u_int
name|gen
decl_stmt|;
name|ngetnanouptime
operator|++
expr_stmt|;
do|do
block|{
name|th
operator|=
name|timehands
expr_stmt|;
name|gen
operator|=
name|th
operator|->
name|th_generation
expr_stmt|;
name|bintime2timespec
argument_list|(
operator|&
name|th
operator|->
name|th_offset
argument_list|,
name|tsp
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|gen
operator|==
literal|0
operator|||
name|gen
operator|!=
name|th
operator|->
name|th_generation
condition|)
do|;
block|}
end_function

begin_function
name|void
name|getmicrouptime
parameter_list|(
name|struct
name|timeval
modifier|*
name|tvp
parameter_list|)
block|{
name|struct
name|timehands
modifier|*
name|th
decl_stmt|;
name|u_int
name|gen
decl_stmt|;
name|ngetmicrouptime
operator|++
expr_stmt|;
do|do
block|{
name|th
operator|=
name|timehands
expr_stmt|;
name|gen
operator|=
name|th
operator|->
name|th_generation
expr_stmt|;
name|bintime2timeval
argument_list|(
operator|&
name|th
operator|->
name|th_offset
argument_list|,
name|tvp
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|gen
operator|==
literal|0
operator|||
name|gen
operator|!=
name|th
operator|->
name|th_generation
condition|)
do|;
block|}
end_function

begin_function
name|void
name|getbintime
parameter_list|(
name|struct
name|bintime
modifier|*
name|bt
parameter_list|)
block|{
name|struct
name|timehands
modifier|*
name|th
decl_stmt|;
name|u_int
name|gen
decl_stmt|;
name|ngetbintime
operator|++
expr_stmt|;
do|do
block|{
name|th
operator|=
name|timehands
expr_stmt|;
name|gen
operator|=
name|th
operator|->
name|th_generation
expr_stmt|;
operator|*
name|bt
operator|=
name|th
operator|->
name|th_offset
expr_stmt|;
block|}
do|while
condition|(
name|gen
operator|==
literal|0
operator|||
name|gen
operator|!=
name|th
operator|->
name|th_generation
condition|)
do|;
name|bintime_add
argument_list|(
name|bt
argument_list|,
operator|&
name|boottimebin
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|getnanotime
parameter_list|(
name|struct
name|timespec
modifier|*
name|tsp
parameter_list|)
block|{
name|struct
name|timehands
modifier|*
name|th
decl_stmt|;
name|u_int
name|gen
decl_stmt|;
name|ngetnanotime
operator|++
expr_stmt|;
do|do
block|{
name|th
operator|=
name|timehands
expr_stmt|;
name|gen
operator|=
name|th
operator|->
name|th_generation
expr_stmt|;
operator|*
name|tsp
operator|=
name|th
operator|->
name|th_nanotime
expr_stmt|;
block|}
do|while
condition|(
name|gen
operator|==
literal|0
operator|||
name|gen
operator|!=
name|th
operator|->
name|th_generation
condition|)
do|;
block|}
end_function

begin_function
name|void
name|getmicrotime
parameter_list|(
name|struct
name|timeval
modifier|*
name|tvp
parameter_list|)
block|{
name|struct
name|timehands
modifier|*
name|th
decl_stmt|;
name|u_int
name|gen
decl_stmt|;
name|ngetmicrotime
operator|++
expr_stmt|;
do|do
block|{
name|th
operator|=
name|timehands
expr_stmt|;
name|gen
operator|=
name|th
operator|->
name|th_generation
expr_stmt|;
operator|*
name|tvp
operator|=
name|th
operator|->
name|th_microtime
expr_stmt|;
block|}
do|while
condition|(
name|gen
operator|==
literal|0
operator|||
name|gen
operator|!=
name|th
operator|->
name|th_generation
condition|)
do|;
block|}
end_function

begin_comment
comment|/*  * Initialize a new timecounter.  * We should really try to rank the timecounters and intelligently determine  * if the new timecounter is better than the current one.  This is subject  * to further study.  For now always use the new timecounter.  */
end_comment

begin_function
name|void
name|tc_init
parameter_list|(
name|struct
name|timecounter
modifier|*
name|tc
parameter_list|)
block|{
name|tc
operator|->
name|tc_next
operator|=
name|timecounters
expr_stmt|;
name|timecounters
operator|=
name|tc
expr_stmt|;
name|printf
argument_list|(
literal|"Timecounter \"%s\"  frequency %lu Hz\n"
argument_list|,
name|tc
operator|->
name|tc_name
argument_list|,
operator|(
name|u_long
operator|)
name|tc
operator|->
name|tc_frequency
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|tc
operator|->
name|tc_get_timecount
argument_list|(
name|tc
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|tc
operator|->
name|tc_get_timecount
argument_list|(
name|tc
argument_list|)
expr_stmt|;
name|timecounter
operator|=
name|tc
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Report the frequency of the current timecounter. */
end_comment

begin_function
name|u_int32_t
name|tc_getfrequency
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
name|timehands
operator|->
name|th_counter
operator|->
name|tc_frequency
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Step our concept of GMT.  This is done by modifying our estimate of  * when we booted.  XXX: needs futher work.  */
end_comment

begin_function
name|void
name|tc_setclock
parameter_list|(
name|struct
name|timespec
modifier|*
name|ts
parameter_list|)
block|{
name|struct
name|timespec
name|ts2
decl_stmt|;
name|nanouptime
argument_list|(
operator|&
name|ts2
argument_list|)
expr_stmt|;
name|boottime
operator|.
name|tv_sec
operator|=
name|ts
operator|->
name|tv_sec
operator|-
name|ts2
operator|.
name|tv_sec
expr_stmt|;
comment|/* XXX boottime should probably be a timespec. */
name|boottime
operator|.
name|tv_usec
operator|=
operator|(
name|ts
operator|->
name|tv_nsec
operator|-
name|ts2
operator|.
name|tv_nsec
operator|)
operator|/
literal|1000
expr_stmt|;
if|if
condition|(
name|boottime
operator|.
name|tv_usec
operator|<
literal|0
condition|)
block|{
name|boottime
operator|.
name|tv_usec
operator|+=
literal|1000000
expr_stmt|;
name|boottime
operator|.
name|tv_sec
operator|--
expr_stmt|;
block|}
name|timeval2bintime
argument_list|(
operator|&
name|boottime
argument_list|,
operator|&
name|boottimebin
argument_list|)
expr_stmt|;
comment|/* XXX fiddle all the little crinkly bits around the fiords... */
name|tc_windup
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Initialize the next struct timehands in the ring and make  * it the active timehands.  Along the way we might switch to a different  * timecounter and/or do seconds processing in NTP.  Slightly magic.  */
end_comment

begin_function
specifier|static
name|void
name|tc_windup
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|bintime
name|bt
decl_stmt|;
name|struct
name|timehands
modifier|*
name|th
decl_stmt|,
modifier|*
name|tho
decl_stmt|;
name|u_int64_t
name|scale
decl_stmt|;
name|u_int
name|delta
decl_stmt|,
name|ncount
decl_stmt|,
name|ogen
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* 	 * Make the next timehands a copy of the current one, but do not 	 * overwrite the generation or next pointer.  While we update 	 * the contents, the generation must be zero. 	 */
name|tho
operator|=
name|timehands
expr_stmt|;
name|th
operator|=
name|tho
operator|->
name|th_next
expr_stmt|;
name|ogen
operator|=
name|th
operator|->
name|th_generation
expr_stmt|;
name|th
operator|->
name|th_generation
operator|=
literal|0
expr_stmt|;
name|bcopy
argument_list|(
name|tho
argument_list|,
name|th
argument_list|,
name|offsetof
argument_list|(
expr|struct
name|timehands
argument_list|,
name|th_generation
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Capture a timecounter delta on the current timecounter and if 	 * changing timecounters, a counter value from the new timecounter. 	 * Update the offset fields accordingly. 	 */
name|delta
operator|=
name|tc_delta
argument_list|(
name|th
argument_list|)
expr_stmt|;
if|if
condition|(
name|th
operator|->
name|th_counter
operator|!=
name|timecounter
condition|)
name|ncount
operator|=
name|timecounter
operator|->
name|tc_get_timecount
argument_list|(
name|timecounter
argument_list|)
expr_stmt|;
else|else
name|ncount
operator|=
literal|0
expr_stmt|;
name|th
operator|->
name|th_offset_count
operator|+=
name|delta
expr_stmt|;
name|th
operator|->
name|th_offset_count
operator|&=
name|th
operator|->
name|th_counter
operator|->
name|tc_counter_mask
expr_stmt|;
name|bintime_addx
argument_list|(
operator|&
name|th
operator|->
name|th_offset
argument_list|,
name|th
operator|->
name|th_scale
operator|*
name|delta
argument_list|)
expr_stmt|;
comment|/* 	 * Hardware latching timecounters may not generate interrupts on 	 * PPS events, so instead we poll them.  There is a finite risk that 	 * the hardware might capture a count which is later than the one we 	 * got above, and therefore possibly in the next NTP second which might 	 * have a different rate than the current NTP second.  It doesn't 	 * matter in practice. 	 */
if|if
condition|(
name|tho
operator|->
name|th_counter
operator|->
name|tc_poll_pps
condition|)
name|tho
operator|->
name|th_counter
operator|->
name|tc_poll_pps
argument_list|(
name|tho
operator|->
name|th_counter
argument_list|)
expr_stmt|;
comment|/* 	 * Deal with NTP second processing.  The for loop normally only 	 * iterates once, but in extreme situations it might keep NTP sane 	 * if timeouts are not run for several seconds. 	 */
for|for
control|(
name|i
operator|=
name|th
operator|->
name|th_offset
operator|.
name|sec
operator|-
name|tho
operator|->
name|th_offset
operator|.
name|sec
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
name|ntp_update_second
argument_list|(
operator|&
name|th
operator|->
name|th_adjustment
argument_list|,
operator|&
name|th
operator|->
name|th_offset
operator|.
name|sec
argument_list|)
expr_stmt|;
comment|/* Now is a good time to change timecounters. */
if|if
condition|(
name|th
operator|->
name|th_counter
operator|!=
name|timecounter
condition|)
block|{
name|th
operator|->
name|th_counter
operator|=
name|timecounter
expr_stmt|;
name|th
operator|->
name|th_offset_count
operator|=
name|ncount
expr_stmt|;
block|}
comment|/*- 	 * Recalculate the scaling factor.  We want the number of 1/2^64 	 * fractions of a second per period of the hardware counter, taking 	 * into account the th_adjustment factor which the NTP PLL/adjtime(2) 	 * processing provides us with. 	 * 	 * The th_adjustment is nanoseconds per second with 32 bit binary 	 * fraction and want 64 bit binary fraction of second: 	 * 	 *	 x = a * 2^32 / 10^9 = a * 4.294967296 	 * 	 * The range of th_adjustment is +/- 5000PPM so inside a 64bit int 	 * we can only multiply by about 850 without overflowing, but that 	 * leaves suitably precise fractions for multiply before divide. 	 * 	 * Divide before multiply with a fraction of 2199/512 results in a 	 * systematic undercompensation of 10PPM of th_adjustment.  On a 	 * 5000PPM adjustment this is a 0.05PPM error.  This is acceptable.  	 * 	 * We happily sacrifice the lowest of the 64 bits of our result 	 * to the goddess of code clarity. 	 * 	 */
name|scale
operator|=
operator|(
name|u_int64_t
operator|)
literal|1
operator|<<
literal|63
expr_stmt|;
name|scale
operator|+=
operator|(
name|th
operator|->
name|th_adjustment
operator|/
literal|1024
operator|)
operator|*
literal|2199
expr_stmt|;
name|scale
operator|/=
name|th
operator|->
name|th_counter
operator|->
name|tc_frequency
expr_stmt|;
name|th
operator|->
name|th_scale
operator|=
name|scale
operator|*
literal|2
expr_stmt|;
comment|/* Update the GMT timestamps used for the get*() functions. */
name|bt
operator|=
name|th
operator|->
name|th_offset
expr_stmt|;
name|bintime_add
argument_list|(
operator|&
name|bt
argument_list|,
operator|&
name|boottimebin
argument_list|)
expr_stmt|;
name|bintime2timeval
argument_list|(
operator|&
name|bt
argument_list|,
operator|&
name|th
operator|->
name|th_microtime
argument_list|)
expr_stmt|;
name|bintime2timespec
argument_list|(
operator|&
name|bt
argument_list|,
operator|&
name|th
operator|->
name|th_nanotime
argument_list|)
expr_stmt|;
comment|/* 	 * Now that the struct timehands is again consistent, set the new 	 * generation number, making sure to not make it zero. 	 */
if|if
condition|(
operator|++
name|ogen
operator|==
literal|0
condition|)
name|ogen
operator|=
literal|1
expr_stmt|;
name|th
operator|->
name|th_generation
operator|=
name|ogen
expr_stmt|;
comment|/* Go live with the new struct timehands. */
name|time_second
operator|=
name|th
operator|->
name|th_microtime
operator|.
name|tv_sec
expr_stmt|;
name|timehands
operator|=
name|th
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Report or change the active timecounter hardware. */
end_comment

begin_function
specifier|static
name|int
name|sysctl_kern_timecounter_hardware
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|char
name|newname
index|[
literal|32
index|]
decl_stmt|;
name|struct
name|timecounter
modifier|*
name|newtc
decl_stmt|,
modifier|*
name|tc
decl_stmt|;
name|int
name|error
decl_stmt|;
name|tc
operator|=
name|timecounter
expr_stmt|;
name|strncpy
argument_list|(
name|newname
argument_list|,
name|tc
operator|->
name|tc_name
argument_list|,
sizeof|sizeof
argument_list|(
name|newname
argument_list|)
argument_list|)
expr_stmt|;
name|newname
index|[
sizeof|sizeof
argument_list|(
name|newname
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|error
operator|=
name|sysctl_handle_string
argument_list|(
name|oidp
argument_list|,
operator|&
name|newname
index|[
literal|0
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|newname
argument_list|)
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
operator|||
name|req
operator|->
name|newptr
operator|==
name|NULL
operator|||
name|strcmp
argument_list|(
name|newname
argument_list|,
name|tc
operator|->
name|tc_name
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
for|for
control|(
name|newtc
operator|=
name|timecounters
init|;
name|newtc
operator|!=
name|NULL
condition|;
name|newtc
operator|=
name|newtc
operator|->
name|tc_next
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|newname
argument_list|,
name|newtc
operator|->
name|tc_name
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
comment|/* Warm up new timecounter. */
operator|(
name|void
operator|)
name|newtc
operator|->
name|tc_get_timecount
argument_list|(
name|newtc
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|newtc
operator|->
name|tc_get_timecount
argument_list|(
name|newtc
argument_list|)
expr_stmt|;
name|timecounter
operator|=
name|newtc
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|SYSCTL_PROC
argument_list|(
name|_kern_timecounter
argument_list|,
name|OID_AUTO
argument_list|,
name|hardware
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|sysctl_kern_timecounter_hardware
argument_list|,
literal|"A"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * RFC 2783 PPS-API implementation.  */
end_comment

begin_function
name|int
name|pps_ioctl
parameter_list|(
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|data
parameter_list|,
name|struct
name|pps_state
modifier|*
name|pps
parameter_list|)
block|{
name|pps_params_t
modifier|*
name|app
decl_stmt|;
name|struct
name|pps_fetch_args
modifier|*
name|fapi
decl_stmt|;
ifdef|#
directive|ifdef
name|PPS_SYNC
name|struct
name|pps_kcbind_args
modifier|*
name|kapi
decl_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|PPS_IOC_CREATE
case|:
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|PPS_IOC_DESTROY
case|:
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|PPS_IOC_SETPARAMS
case|:
name|app
operator|=
operator|(
name|pps_params_t
operator|*
operator|)
name|data
expr_stmt|;
if|if
condition|(
name|app
operator|->
name|mode
operator|&
operator|~
name|pps
operator|->
name|ppscap
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|pps
operator|->
name|ppsparam
operator|=
operator|*
name|app
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|PPS_IOC_GETPARAMS
case|:
name|app
operator|=
operator|(
name|pps_params_t
operator|*
operator|)
name|data
expr_stmt|;
operator|*
name|app
operator|=
name|pps
operator|->
name|ppsparam
expr_stmt|;
name|app
operator|->
name|api_version
operator|=
name|PPS_API_VERS_1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|PPS_IOC_GETCAP
case|:
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|pps
operator|->
name|ppscap
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|PPS_IOC_FETCH
case|:
name|fapi
operator|=
operator|(
expr|struct
name|pps_fetch_args
operator|*
operator|)
name|data
expr_stmt|;
if|if
condition|(
name|fapi
operator|->
name|tsformat
operator|&&
name|fapi
operator|->
name|tsformat
operator|!=
name|PPS_TSFMT_TSPEC
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|fapi
operator|->
name|timeout
operator|.
name|tv_sec
operator|||
name|fapi
operator|->
name|timeout
operator|.
name|tv_nsec
condition|)
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
name|pps
operator|->
name|ppsinfo
operator|.
name|current_mode
operator|=
name|pps
operator|->
name|ppsparam
operator|.
name|mode
expr_stmt|;
name|fapi
operator|->
name|pps_info_buf
operator|=
name|pps
operator|->
name|ppsinfo
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|PPS_IOC_KCBIND
case|:
ifdef|#
directive|ifdef
name|PPS_SYNC
name|kapi
operator|=
operator|(
expr|struct
name|pps_kcbind_args
operator|*
operator|)
name|data
expr_stmt|;
comment|/* XXX Only root should be able to do this */
if|if
condition|(
name|kapi
operator|->
name|tsformat
operator|&&
name|kapi
operator|->
name|tsformat
operator|!=
name|PPS_TSFMT_TSPEC
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|kapi
operator|->
name|kernel_consumer
operator|!=
name|PPS_KC_HARDPPS
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|kapi
operator|->
name|edge
operator|&
operator|~
name|pps
operator|->
name|ppscap
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|pps
operator|->
name|kcmode
operator|=
name|kapi
operator|->
name|edge
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
else|#
directive|else
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
endif|#
directive|endif
default|default:
return|return
operator|(
name|ENOTTY
operator|)
return|;
block|}
block|}
end_function

begin_function
name|void
name|pps_init
parameter_list|(
name|struct
name|pps_state
modifier|*
name|pps
parameter_list|)
block|{
name|pps
operator|->
name|ppscap
operator||=
name|PPS_TSFMT_TSPEC
expr_stmt|;
if|if
condition|(
name|pps
operator|->
name|ppscap
operator|&
name|PPS_CAPTUREASSERT
condition|)
name|pps
operator|->
name|ppscap
operator||=
name|PPS_OFFSETASSERT
expr_stmt|;
if|if
condition|(
name|pps
operator|->
name|ppscap
operator|&
name|PPS_CAPTURECLEAR
condition|)
name|pps
operator|->
name|ppscap
operator||=
name|PPS_OFFSETCLEAR
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pps_capture
parameter_list|(
name|struct
name|pps_state
modifier|*
name|pps
parameter_list|)
block|{
name|struct
name|timehands
modifier|*
name|th
decl_stmt|;
name|th
operator|=
name|timehands
expr_stmt|;
name|pps
operator|->
name|capgen
operator|=
name|th
operator|->
name|th_generation
expr_stmt|;
name|pps
operator|->
name|capth
operator|=
name|th
expr_stmt|;
name|pps
operator|->
name|capcount
operator|=
name|th
operator|->
name|th_counter
operator|->
name|tc_get_timecount
argument_list|(
name|th
operator|->
name|th_counter
argument_list|)
expr_stmt|;
if|if
condition|(
name|pps
operator|->
name|capgen
operator|!=
name|th
operator|->
name|th_generation
condition|)
name|pps
operator|->
name|capgen
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pps_event
parameter_list|(
name|struct
name|pps_state
modifier|*
name|pps
parameter_list|,
name|int
name|event
parameter_list|)
block|{
name|struct
name|bintime
name|bt
decl_stmt|;
name|struct
name|timespec
name|ts
decl_stmt|,
modifier|*
name|tsp
decl_stmt|,
modifier|*
name|osp
decl_stmt|;
name|u_int
name|tcount
decl_stmt|,
modifier|*
name|pcount
decl_stmt|;
name|int
name|foff
decl_stmt|,
name|fhard
decl_stmt|;
name|pps_seq_t
modifier|*
name|pseq
decl_stmt|;
comment|/* If the timecounter was wound up underneath us, bail out. */
if|if
condition|(
name|pps
operator|->
name|capgen
operator|==
literal|0
operator|||
name|pps
operator|->
name|capgen
operator|!=
name|pps
operator|->
name|capth
operator|->
name|th_generation
condition|)
return|return;
comment|/* Things would be easier with arrays. */
if|if
condition|(
name|event
operator|==
name|PPS_CAPTUREASSERT
condition|)
block|{
name|tsp
operator|=
operator|&
name|pps
operator|->
name|ppsinfo
operator|.
name|assert_timestamp
expr_stmt|;
name|osp
operator|=
operator|&
name|pps
operator|->
name|ppsparam
operator|.
name|assert_offset
expr_stmt|;
name|foff
operator|=
name|pps
operator|->
name|ppsparam
operator|.
name|mode
operator|&
name|PPS_OFFSETASSERT
expr_stmt|;
name|fhard
operator|=
name|pps
operator|->
name|kcmode
operator|&
name|PPS_CAPTUREASSERT
expr_stmt|;
name|pcount
operator|=
operator|&
name|pps
operator|->
name|ppscount
index|[
literal|0
index|]
expr_stmt|;
name|pseq
operator|=
operator|&
name|pps
operator|->
name|ppsinfo
operator|.
name|assert_sequence
expr_stmt|;
block|}
else|else
block|{
name|tsp
operator|=
operator|&
name|pps
operator|->
name|ppsinfo
operator|.
name|clear_timestamp
expr_stmt|;
name|osp
operator|=
operator|&
name|pps
operator|->
name|ppsparam
operator|.
name|clear_offset
expr_stmt|;
name|foff
operator|=
name|pps
operator|->
name|ppsparam
operator|.
name|mode
operator|&
name|PPS_OFFSETCLEAR
expr_stmt|;
name|fhard
operator|=
name|pps
operator|->
name|kcmode
operator|&
name|PPS_CAPTURECLEAR
expr_stmt|;
name|pcount
operator|=
operator|&
name|pps
operator|->
name|ppscount
index|[
literal|1
index|]
expr_stmt|;
name|pseq
operator|=
operator|&
name|pps
operator|->
name|ppsinfo
operator|.
name|clear_sequence
expr_stmt|;
block|}
comment|/* 	 * If the timecounter changed, we cannot compare the count values, so 	 * we have to drop the rest of the PPS-stuff until the next event. 	 */
if|if
condition|(
name|pps
operator|->
name|ppstc
operator|!=
name|pps
operator|->
name|capth
operator|->
name|th_counter
condition|)
block|{
name|pps
operator|->
name|ppstc
operator|=
name|pps
operator|->
name|capth
operator|->
name|th_counter
expr_stmt|;
operator|*
name|pcount
operator|=
name|pps
operator|->
name|capcount
expr_stmt|;
name|pps
operator|->
name|ppscount
index|[
literal|2
index|]
operator|=
name|pps
operator|->
name|capcount
expr_stmt|;
return|return;
block|}
comment|/* Return if nothing really happened. */
if|if
condition|(
operator|*
name|pcount
operator|==
name|pps
operator|->
name|capcount
condition|)
return|return;
comment|/* Convert the count to a timespec. */
name|tcount
operator|=
name|pps
operator|->
name|capcount
operator|-
name|pps
operator|->
name|capth
operator|->
name|th_offset_count
expr_stmt|;
name|tcount
operator|&=
name|pps
operator|->
name|capth
operator|->
name|th_counter
operator|->
name|tc_counter_mask
expr_stmt|;
name|bt
operator|=
name|pps
operator|->
name|capth
operator|->
name|th_offset
expr_stmt|;
name|bintime_addx
argument_list|(
operator|&
name|bt
argument_list|,
name|pps
operator|->
name|capth
operator|->
name|th_scale
operator|*
name|tcount
argument_list|)
expr_stmt|;
name|bintime_add
argument_list|(
operator|&
name|bt
argument_list|,
operator|&
name|boottimebin
argument_list|)
expr_stmt|;
name|bintime2timespec
argument_list|(
operator|&
name|bt
argument_list|,
operator|&
name|ts
argument_list|)
expr_stmt|;
comment|/* If the timecounter was wound up underneath us, bail out. */
if|if
condition|(
name|pps
operator|->
name|capgen
operator|!=
name|pps
operator|->
name|capth
operator|->
name|th_generation
condition|)
return|return;
operator|*
name|pcount
operator|=
name|pps
operator|->
name|capcount
expr_stmt|;
operator|(
operator|*
name|pseq
operator|)
operator|++
expr_stmt|;
operator|*
name|tsp
operator|=
name|ts
expr_stmt|;
if|if
condition|(
name|foff
condition|)
block|{
name|timespecadd
argument_list|(
name|tsp
argument_list|,
name|osp
argument_list|)
expr_stmt|;
if|if
condition|(
name|tsp
operator|->
name|tv_nsec
operator|<
literal|0
condition|)
block|{
name|tsp
operator|->
name|tv_nsec
operator|+=
literal|1000000000
expr_stmt|;
name|tsp
operator|->
name|tv_sec
operator|-=
literal|1
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|PPS_SYNC
if|if
condition|(
name|fhard
condition|)
block|{
comment|/* 		 * Feed the NTP PLL/FLL. 		 * The FLL wants to know how many nanoseconds elapsed since 		 * the previous event. 		 * I have never been able to convince myself that this code 		 * is actually correct:  Using th_scale is bound to contain 		 * a phase correction component from userland, when running 		 * as FLL, so the number hardpps() gets is not meaningful IMO. 		 */
name|tcount
operator|=
name|pps
operator|->
name|capcount
operator|-
name|pps
operator|->
name|ppscount
index|[
literal|2
index|]
expr_stmt|;
name|pps
operator|->
name|ppscount
index|[
literal|2
index|]
operator|=
name|pps
operator|->
name|capcount
expr_stmt|;
name|tcount
operator|&=
name|pps
operator|->
name|capth
operator|->
name|th_counter
operator|->
name|tc_counter_mask
expr_stmt|;
name|bt
operator|.
name|sec
operator|=
literal|0
expr_stmt|;
name|bt
operator|.
name|frac
operator|=
literal|0
expr_stmt|;
name|bintime_addx
argument_list|(
operator|&
name|bt
argument_list|,
name|pps
operator|->
name|capth
operator|->
name|th_scale
operator|*
name|tcount
argument_list|)
expr_stmt|;
name|bintime2timespec
argument_list|(
operator|&
name|bt
argument_list|,
operator|&
name|ts
argument_list|)
expr_stmt|;
name|hardpps
argument_list|(
name|tsp
argument_list|,
name|ts
operator|.
name|tv_nsec
operator|+
literal|1000000000
operator|*
name|ts
operator|.
name|tv_sec
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * Timecounters need to be updated every so often to prevent the hardware  * counter from overflowing.  Updating also recalculates the cached values  * used by the get*() family of functions, so their precision depends on  * the update frequency.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|tc_tick
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_kern_timecounter
argument_list|,
name|OID_AUTO
argument_list|,
name|tick
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|tick
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
name|void
name|tc_ticktock
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
name|int
name|count
decl_stmt|;
if|if
condition|(
operator|++
name|count
operator|<
name|tc_tick
condition|)
return|return;
name|count
operator|=
literal|0
expr_stmt|;
name|tc_windup
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|inittimecounter
parameter_list|(
name|void
modifier|*
name|dummy
parameter_list|)
block|{
name|u_int
name|p
decl_stmt|;
comment|/* 	 * Set the initial timeout to 	 * max(1,<approx. number of hardclock ticks in a millisecond>). 	 * People should probably not use the sysctl to set the timeout 	 * to smaller than its inital value, since that value is the 	 * smallest reasonable one.  If they want better timestamps they 	 * should use the non-"get"* functions. 	 */
if|if
condition|(
name|hz
operator|>
literal|1000
condition|)
name|tc_tick
operator|=
operator|(
name|hz
operator|+
literal|500
operator|)
operator|/
literal|1000
expr_stmt|;
else|else
name|tc_tick
operator|=
literal|1
expr_stmt|;
name|p
operator|=
operator|(
name|tc_tick
operator|*
literal|1000000
operator|)
operator|/
name|hz
expr_stmt|;
name|printf
argument_list|(
literal|"Timecounters tick every %d.%03u msec\n"
argument_list|,
name|p
operator|/
literal|1000
argument_list|,
name|p
operator|%
literal|1000
argument_list|)
expr_stmt|;
comment|/* warm up new timecounter (again) and get rolling. */
operator|(
name|void
operator|)
name|timecounter
operator|->
name|tc_get_timecount
argument_list|(
name|timecounter
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|timecounter
operator|->
name|tc_get_timecount
argument_list|(
name|timecounter
argument_list|)
expr_stmt|;
block|}
end_function

begin_macro
name|SYSINIT
argument_list|(
argument|timecounter
argument_list|,
argument|SI_SUB_CLOCKS
argument_list|,
argument|SI_ORDER_FIRST
argument_list|,
argument|inittimecounter
argument_list|,
argument|NULL
argument_list|)
end_macro

end_unit

