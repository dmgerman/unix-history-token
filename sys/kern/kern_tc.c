begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * ----------------------------------------------------------------------------  * "THE BEER-WARE LICENSE" (Revision 42):  *<phk@FreeBSD.ORG> wrote this file.  As long as you retain this notice you  * can do whatever you want with this stuff. If we meet some day, and you think  * this stuff is worth it, you can buy me a beer in return.   Poul-Henning Kamp  * ----------------------------------------------------------------------------  *  * Copyright (c) 2011 The FreeBSD Foundation  * All rights reserved.  *  * Portions of this software were developed by Julien Ridoux at the University  * of Melbourne under sponsorship from the FreeBSD Foundation.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"opt_compat.h"
end_include

begin_include
include|#
directive|include
file|"opt_ntp.h"
end_include

begin_include
include|#
directive|include
file|"opt_ffclock.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/limits.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|FFCLOCK
end_ifdef

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/syslog.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/timeffc.h>
end_include

begin_include
include|#
directive|include
file|<sys/timepps.h>
end_include

begin_include
include|#
directive|include
file|<sys/timetc.h>
end_include

begin_include
include|#
directive|include
file|<sys/timex.h>
end_include

begin_include
include|#
directive|include
file|<sys/vdso.h>
end_include

begin_comment
comment|/*  * A large step happens on boot.  This constant detects such steps.  * It is relatively small so that ntp_update_second gets called enough  * in the typical 'missed a couple of seconds' case, but doesn't loop  * forever when the time step is large.  */
end_comment

begin_define
define|#
directive|define
name|LARGE_STEP
value|200
end_define

begin_comment
comment|/*  * Implement a dummy timecounter which we can use until we get a real one  * in the air.  This allows the console and other early stuff to use  * time services.  */
end_comment

begin_function
specifier|static
name|u_int
name|dummy_get_timecount
parameter_list|(
name|struct
name|timecounter
modifier|*
name|tc
parameter_list|)
block|{
specifier|static
name|u_int
name|now
decl_stmt|;
return|return
operator|(
operator|++
name|now
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|timecounter
name|dummy_timecounter
init|=
block|{
name|dummy_get_timecount
block|,
literal|0
block|,
operator|~
literal|0u
block|,
literal|1000000
block|,
literal|"dummy"
block|,
operator|-
literal|1000000
block|}
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|timehands
block|{
comment|/* These fields must be initialized by the driver. */
name|struct
name|timecounter
modifier|*
name|th_counter
decl_stmt|;
name|int64_t
name|th_adjustment
decl_stmt|;
name|uint64_t
name|th_scale
decl_stmt|;
name|u_int
name|th_offset_count
decl_stmt|;
name|struct
name|bintime
name|th_offset
decl_stmt|;
name|struct
name|timeval
name|th_microtime
decl_stmt|;
name|struct
name|timespec
name|th_nanotime
decl_stmt|;
comment|/* Fields not to be copied in tc_windup start with th_generation. */
specifier|volatile
name|u_int
name|th_generation
decl_stmt|;
name|struct
name|timehands
modifier|*
name|th_next
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|timehands
name|th0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|timehands
name|th9
init|=
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
literal|0
block|,
operator|&
name|th0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|timehands
name|th8
init|=
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
literal|0
block|,
operator|&
name|th9
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|timehands
name|th7
init|=
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
literal|0
block|,
operator|&
name|th8
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|timehands
name|th6
init|=
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
literal|0
block|,
operator|&
name|th7
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|timehands
name|th5
init|=
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
literal|0
block|,
operator|&
name|th6
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|timehands
name|th4
init|=
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
literal|0
block|,
operator|&
name|th5
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|timehands
name|th3
init|=
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
literal|0
block|,
operator|&
name|th4
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|timehands
name|th2
init|=
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
literal|0
block|,
operator|&
name|th3
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|timehands
name|th1
init|=
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
literal|0
block|,
operator|&
name|th2
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|timehands
name|th0
init|=
block|{
operator|&
name|dummy_timecounter
block|,
literal|0
block|,
operator|(
name|uint64_t
operator|)
operator|-
literal|1
operator|/
literal|1000000
block|,
literal|0
block|,
block|{
literal|1
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
literal|1
block|,
operator|&
name|th1
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|timehands
modifier|*
specifier|volatile
name|timehands
init|=
operator|&
name|th0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|timecounter
modifier|*
name|timecounter
init|=
operator|&
name|dummy_timecounter
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|timecounter
modifier|*
name|timecounters
init|=
operator|&
name|dummy_timecounter
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|tc_min_ticktock_freq
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|volatile
name|time_t
name|time_second
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|volatile
name|time_t
name|time_uptime
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|bintime
name|boottimebin
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|timeval
name|boottime
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|sysctl_kern_boottime
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_expr_stmt
name|SYSCTL_PROC
argument_list|(
name|_kern
argument_list|,
name|KERN_BOOTTIME
argument_list|,
name|boottime
argument_list|,
name|CTLTYPE_STRUCT
operator||
name|CTLFLAG_RD
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|sysctl_kern_boottime
argument_list|,
literal|"S,timeval"
argument_list|,
literal|"System boottime"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_kern
argument_list|,
name|OID_AUTO
argument_list|,
name|timecounter
argument_list|,
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|SYSCTL_NODE
argument_list|(
name|_kern_timecounter
argument_list|,
name|OID_AUTO
argument_list|,
name|tc
argument_list|,
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|timestepwarnings
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_kern_timecounter
argument_list|,
name|OID_AUTO
argument_list|,
name|stepwarnings
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|timestepwarnings
argument_list|,
literal|0
argument_list|,
literal|"Log time steps"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|struct
name|bintime
name|bt_timethreshold
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|bintime
name|bt_tickthreshold
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|sbintime_t
name|sbt_timethreshold
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|sbintime_t
name|sbt_tickthreshold
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|bintime
name|tc_tick_bt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|sbintime_t
name|tc_tick_sbt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|tc_precexp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|tc_timepercentage
init|=
name|TC_DEFAULTPERC
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|sysctl_kern_timecounter_adjprecision
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_expr_stmt
name|SYSCTL_PROC
argument_list|(
name|_kern_timecounter
argument_list|,
name|OID_AUTO
argument_list|,
name|alloweddeviation
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RWTUN
operator||
name|CTLFLAG_MPSAFE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|sysctl_kern_timecounter_adjprecision
argument_list|,
literal|"I"
argument_list|,
literal|"Allowed time interval deviation in percents"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function_decl
specifier|static
name|void
name|tc_windup
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cpu_tick_calibrate
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|dtrace_getnanotime
parameter_list|(
name|struct
name|timespec
modifier|*
name|tsp
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|int
name|sysctl_kern_boottime
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|__mips__
ifdef|#
directive|ifdef
name|SCTL_MASK32
name|int
name|tv
index|[
literal|2
index|]
decl_stmt|;
if|if
condition|(
name|req
operator|->
name|flags
operator|&
name|SCTL_MASK32
condition|)
block|{
name|tv
index|[
literal|0
index|]
operator|=
name|boottime
operator|.
name|tv_sec
expr_stmt|;
name|tv
index|[
literal|1
index|]
operator|=
name|boottime
operator|.
name|tv_usec
expr_stmt|;
return|return
name|SYSCTL_OUT
argument_list|(
name|req
argument_list|,
name|tv
argument_list|,
sizeof|sizeof
argument_list|(
name|tv
argument_list|)
argument_list|)
return|;
block|}
else|else
endif|#
directive|endif
endif|#
directive|endif
return|return
name|SYSCTL_OUT
argument_list|(
name|req
argument_list|,
operator|&
name|boottime
argument_list|,
sizeof|sizeof
argument_list|(
name|boottime
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sysctl_kern_timecounter_get
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|u_int
name|ncount
decl_stmt|;
name|struct
name|timecounter
modifier|*
name|tc
init|=
name|arg1
decl_stmt|;
name|ncount
operator|=
name|tc
operator|->
name|tc_get_timecount
argument_list|(
name|tc
argument_list|)
expr_stmt|;
return|return
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|ncount
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sysctl_kern_timecounter_freq
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|uint64_t
name|freq
decl_stmt|;
name|struct
name|timecounter
modifier|*
name|tc
init|=
name|arg1
decl_stmt|;
name|freq
operator|=
name|tc
operator|->
name|tc_frequency
expr_stmt|;
return|return
name|sysctl_handle_64
argument_list|(
name|oidp
argument_list|,
operator|&
name|freq
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return the difference between the timehands' counter value now and what  * was when we copied it to the timehands' offset_count.  */
end_comment

begin_function
specifier|static
name|__inline
name|u_int
name|tc_delta
parameter_list|(
name|struct
name|timehands
modifier|*
name|th
parameter_list|)
block|{
name|struct
name|timecounter
modifier|*
name|tc
decl_stmt|;
name|tc
operator|=
name|th
operator|->
name|th_counter
expr_stmt|;
return|return
operator|(
operator|(
name|tc
operator|->
name|tc_get_timecount
argument_list|(
name|tc
argument_list|)
operator|-
name|th
operator|->
name|th_offset_count
operator|)
operator|&
name|tc
operator|->
name|tc_counter_mask
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Functions for reading the time.  We have to loop until we are sure that  * the timehands that we operated on was not updated under our feet.  See  * the comment in<sys/time.h> for a description of these 12 functions.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|FFCLOCK
end_ifdef

begin_function
name|void
name|fbclock_binuptime
parameter_list|(
name|struct
name|bintime
modifier|*
name|bt
parameter_list|)
block|{
name|struct
name|timehands
modifier|*
name|th
decl_stmt|;
name|unsigned
name|int
name|gen
decl_stmt|;
do|do
block|{
name|th
operator|=
name|timehands
expr_stmt|;
name|gen
operator|=
name|th
operator|->
name|th_generation
expr_stmt|;
operator|*
name|bt
operator|=
name|th
operator|->
name|th_offset
expr_stmt|;
name|bintime_addx
argument_list|(
name|bt
argument_list|,
name|th
operator|->
name|th_scale
operator|*
name|tc_delta
argument_list|(
name|th
argument_list|)
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|gen
operator|==
literal|0
operator|||
name|gen
operator|!=
name|th
operator|->
name|th_generation
condition|)
do|;
block|}
end_function

begin_function
name|void
name|fbclock_nanouptime
parameter_list|(
name|struct
name|timespec
modifier|*
name|tsp
parameter_list|)
block|{
name|struct
name|bintime
name|bt
decl_stmt|;
name|fbclock_binuptime
argument_list|(
operator|&
name|bt
argument_list|)
expr_stmt|;
name|bintime2timespec
argument_list|(
operator|&
name|bt
argument_list|,
name|tsp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|fbclock_microuptime
parameter_list|(
name|struct
name|timeval
modifier|*
name|tvp
parameter_list|)
block|{
name|struct
name|bintime
name|bt
decl_stmt|;
name|fbclock_binuptime
argument_list|(
operator|&
name|bt
argument_list|)
expr_stmt|;
name|bintime2timeval
argument_list|(
operator|&
name|bt
argument_list|,
name|tvp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|fbclock_bintime
parameter_list|(
name|struct
name|bintime
modifier|*
name|bt
parameter_list|)
block|{
name|fbclock_binuptime
argument_list|(
name|bt
argument_list|)
expr_stmt|;
name|bintime_add
argument_list|(
name|bt
argument_list|,
operator|&
name|boottimebin
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|fbclock_nanotime
parameter_list|(
name|struct
name|timespec
modifier|*
name|tsp
parameter_list|)
block|{
name|struct
name|bintime
name|bt
decl_stmt|;
name|fbclock_bintime
argument_list|(
operator|&
name|bt
argument_list|)
expr_stmt|;
name|bintime2timespec
argument_list|(
operator|&
name|bt
argument_list|,
name|tsp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|fbclock_microtime
parameter_list|(
name|struct
name|timeval
modifier|*
name|tvp
parameter_list|)
block|{
name|struct
name|bintime
name|bt
decl_stmt|;
name|fbclock_bintime
argument_list|(
operator|&
name|bt
argument_list|)
expr_stmt|;
name|bintime2timeval
argument_list|(
operator|&
name|bt
argument_list|,
name|tvp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|fbclock_getbinuptime
parameter_list|(
name|struct
name|bintime
modifier|*
name|bt
parameter_list|)
block|{
name|struct
name|timehands
modifier|*
name|th
decl_stmt|;
name|unsigned
name|int
name|gen
decl_stmt|;
do|do
block|{
name|th
operator|=
name|timehands
expr_stmt|;
name|gen
operator|=
name|th
operator|->
name|th_generation
expr_stmt|;
operator|*
name|bt
operator|=
name|th
operator|->
name|th_offset
expr_stmt|;
block|}
do|while
condition|(
name|gen
operator|==
literal|0
operator|||
name|gen
operator|!=
name|th
operator|->
name|th_generation
condition|)
do|;
block|}
end_function

begin_function
name|void
name|fbclock_getnanouptime
parameter_list|(
name|struct
name|timespec
modifier|*
name|tsp
parameter_list|)
block|{
name|struct
name|timehands
modifier|*
name|th
decl_stmt|;
name|unsigned
name|int
name|gen
decl_stmt|;
do|do
block|{
name|th
operator|=
name|timehands
expr_stmt|;
name|gen
operator|=
name|th
operator|->
name|th_generation
expr_stmt|;
name|bintime2timespec
argument_list|(
operator|&
name|th
operator|->
name|th_offset
argument_list|,
name|tsp
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|gen
operator|==
literal|0
operator|||
name|gen
operator|!=
name|th
operator|->
name|th_generation
condition|)
do|;
block|}
end_function

begin_function
name|void
name|fbclock_getmicrouptime
parameter_list|(
name|struct
name|timeval
modifier|*
name|tvp
parameter_list|)
block|{
name|struct
name|timehands
modifier|*
name|th
decl_stmt|;
name|unsigned
name|int
name|gen
decl_stmt|;
do|do
block|{
name|th
operator|=
name|timehands
expr_stmt|;
name|gen
operator|=
name|th
operator|->
name|th_generation
expr_stmt|;
name|bintime2timeval
argument_list|(
operator|&
name|th
operator|->
name|th_offset
argument_list|,
name|tvp
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|gen
operator|==
literal|0
operator|||
name|gen
operator|!=
name|th
operator|->
name|th_generation
condition|)
do|;
block|}
end_function

begin_function
name|void
name|fbclock_getbintime
parameter_list|(
name|struct
name|bintime
modifier|*
name|bt
parameter_list|)
block|{
name|struct
name|timehands
modifier|*
name|th
decl_stmt|;
name|unsigned
name|int
name|gen
decl_stmt|;
do|do
block|{
name|th
operator|=
name|timehands
expr_stmt|;
name|gen
operator|=
name|th
operator|->
name|th_generation
expr_stmt|;
operator|*
name|bt
operator|=
name|th
operator|->
name|th_offset
expr_stmt|;
block|}
do|while
condition|(
name|gen
operator|==
literal|0
operator|||
name|gen
operator|!=
name|th
operator|->
name|th_generation
condition|)
do|;
name|bintime_add
argument_list|(
name|bt
argument_list|,
operator|&
name|boottimebin
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|fbclock_getnanotime
parameter_list|(
name|struct
name|timespec
modifier|*
name|tsp
parameter_list|)
block|{
name|struct
name|timehands
modifier|*
name|th
decl_stmt|;
name|unsigned
name|int
name|gen
decl_stmt|;
do|do
block|{
name|th
operator|=
name|timehands
expr_stmt|;
name|gen
operator|=
name|th
operator|->
name|th_generation
expr_stmt|;
operator|*
name|tsp
operator|=
name|th
operator|->
name|th_nanotime
expr_stmt|;
block|}
do|while
condition|(
name|gen
operator|==
literal|0
operator|||
name|gen
operator|!=
name|th
operator|->
name|th_generation
condition|)
do|;
block|}
end_function

begin_function
name|void
name|fbclock_getmicrotime
parameter_list|(
name|struct
name|timeval
modifier|*
name|tvp
parameter_list|)
block|{
name|struct
name|timehands
modifier|*
name|th
decl_stmt|;
name|unsigned
name|int
name|gen
decl_stmt|;
do|do
block|{
name|th
operator|=
name|timehands
expr_stmt|;
name|gen
operator|=
name|th
operator|->
name|th_generation
expr_stmt|;
operator|*
name|tvp
operator|=
name|th
operator|->
name|th_microtime
expr_stmt|;
block|}
do|while
condition|(
name|gen
operator|==
literal|0
operator|||
name|gen
operator|!=
name|th
operator|->
name|th_generation
condition|)
do|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* !FFCLOCK */
end_comment

begin_function
name|void
name|binuptime
parameter_list|(
name|struct
name|bintime
modifier|*
name|bt
parameter_list|)
block|{
name|struct
name|timehands
modifier|*
name|th
decl_stmt|;
name|u_int
name|gen
decl_stmt|;
do|do
block|{
name|th
operator|=
name|timehands
expr_stmt|;
name|gen
operator|=
name|th
operator|->
name|th_generation
expr_stmt|;
operator|*
name|bt
operator|=
name|th
operator|->
name|th_offset
expr_stmt|;
name|bintime_addx
argument_list|(
name|bt
argument_list|,
name|th
operator|->
name|th_scale
operator|*
name|tc_delta
argument_list|(
name|th
argument_list|)
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|gen
operator|==
literal|0
operator|||
name|gen
operator|!=
name|th
operator|->
name|th_generation
condition|)
do|;
block|}
end_function

begin_function
name|void
name|nanouptime
parameter_list|(
name|struct
name|timespec
modifier|*
name|tsp
parameter_list|)
block|{
name|struct
name|bintime
name|bt
decl_stmt|;
name|binuptime
argument_list|(
operator|&
name|bt
argument_list|)
expr_stmt|;
name|bintime2timespec
argument_list|(
operator|&
name|bt
argument_list|,
name|tsp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|microuptime
parameter_list|(
name|struct
name|timeval
modifier|*
name|tvp
parameter_list|)
block|{
name|struct
name|bintime
name|bt
decl_stmt|;
name|binuptime
argument_list|(
operator|&
name|bt
argument_list|)
expr_stmt|;
name|bintime2timeval
argument_list|(
operator|&
name|bt
argument_list|,
name|tvp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|bintime
parameter_list|(
name|struct
name|bintime
modifier|*
name|bt
parameter_list|)
block|{
name|binuptime
argument_list|(
name|bt
argument_list|)
expr_stmt|;
name|bintime_add
argument_list|(
name|bt
argument_list|,
operator|&
name|boottimebin
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|nanotime
parameter_list|(
name|struct
name|timespec
modifier|*
name|tsp
parameter_list|)
block|{
name|struct
name|bintime
name|bt
decl_stmt|;
name|bintime
argument_list|(
operator|&
name|bt
argument_list|)
expr_stmt|;
name|bintime2timespec
argument_list|(
operator|&
name|bt
argument_list|,
name|tsp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|microtime
parameter_list|(
name|struct
name|timeval
modifier|*
name|tvp
parameter_list|)
block|{
name|struct
name|bintime
name|bt
decl_stmt|;
name|bintime
argument_list|(
operator|&
name|bt
argument_list|)
expr_stmt|;
name|bintime2timeval
argument_list|(
operator|&
name|bt
argument_list|,
name|tvp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|getbinuptime
parameter_list|(
name|struct
name|bintime
modifier|*
name|bt
parameter_list|)
block|{
name|struct
name|timehands
modifier|*
name|th
decl_stmt|;
name|u_int
name|gen
decl_stmt|;
do|do
block|{
name|th
operator|=
name|timehands
expr_stmt|;
name|gen
operator|=
name|th
operator|->
name|th_generation
expr_stmt|;
operator|*
name|bt
operator|=
name|th
operator|->
name|th_offset
expr_stmt|;
block|}
do|while
condition|(
name|gen
operator|==
literal|0
operator|||
name|gen
operator|!=
name|th
operator|->
name|th_generation
condition|)
do|;
block|}
end_function

begin_function
name|void
name|getnanouptime
parameter_list|(
name|struct
name|timespec
modifier|*
name|tsp
parameter_list|)
block|{
name|struct
name|timehands
modifier|*
name|th
decl_stmt|;
name|u_int
name|gen
decl_stmt|;
do|do
block|{
name|th
operator|=
name|timehands
expr_stmt|;
name|gen
operator|=
name|th
operator|->
name|th_generation
expr_stmt|;
name|bintime2timespec
argument_list|(
operator|&
name|th
operator|->
name|th_offset
argument_list|,
name|tsp
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|gen
operator|==
literal|0
operator|||
name|gen
operator|!=
name|th
operator|->
name|th_generation
condition|)
do|;
block|}
end_function

begin_function
name|void
name|getmicrouptime
parameter_list|(
name|struct
name|timeval
modifier|*
name|tvp
parameter_list|)
block|{
name|struct
name|timehands
modifier|*
name|th
decl_stmt|;
name|u_int
name|gen
decl_stmt|;
do|do
block|{
name|th
operator|=
name|timehands
expr_stmt|;
name|gen
operator|=
name|th
operator|->
name|th_generation
expr_stmt|;
name|bintime2timeval
argument_list|(
operator|&
name|th
operator|->
name|th_offset
argument_list|,
name|tvp
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|gen
operator|==
literal|0
operator|||
name|gen
operator|!=
name|th
operator|->
name|th_generation
condition|)
do|;
block|}
end_function

begin_function
name|void
name|getbintime
parameter_list|(
name|struct
name|bintime
modifier|*
name|bt
parameter_list|)
block|{
name|struct
name|timehands
modifier|*
name|th
decl_stmt|;
name|u_int
name|gen
decl_stmt|;
do|do
block|{
name|th
operator|=
name|timehands
expr_stmt|;
name|gen
operator|=
name|th
operator|->
name|th_generation
expr_stmt|;
operator|*
name|bt
operator|=
name|th
operator|->
name|th_offset
expr_stmt|;
block|}
do|while
condition|(
name|gen
operator|==
literal|0
operator|||
name|gen
operator|!=
name|th
operator|->
name|th_generation
condition|)
do|;
name|bintime_add
argument_list|(
name|bt
argument_list|,
operator|&
name|boottimebin
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|getnanotime
parameter_list|(
name|struct
name|timespec
modifier|*
name|tsp
parameter_list|)
block|{
name|struct
name|timehands
modifier|*
name|th
decl_stmt|;
name|u_int
name|gen
decl_stmt|;
do|do
block|{
name|th
operator|=
name|timehands
expr_stmt|;
name|gen
operator|=
name|th
operator|->
name|th_generation
expr_stmt|;
operator|*
name|tsp
operator|=
name|th
operator|->
name|th_nanotime
expr_stmt|;
block|}
do|while
condition|(
name|gen
operator|==
literal|0
operator|||
name|gen
operator|!=
name|th
operator|->
name|th_generation
condition|)
do|;
block|}
end_function

begin_function
name|void
name|getmicrotime
parameter_list|(
name|struct
name|timeval
modifier|*
name|tvp
parameter_list|)
block|{
name|struct
name|timehands
modifier|*
name|th
decl_stmt|;
name|u_int
name|gen
decl_stmt|;
do|do
block|{
name|th
operator|=
name|timehands
expr_stmt|;
name|gen
operator|=
name|th
operator|->
name|th_generation
expr_stmt|;
operator|*
name|tvp
operator|=
name|th
operator|->
name|th_microtime
expr_stmt|;
block|}
do|while
condition|(
name|gen
operator|==
literal|0
operator|||
name|gen
operator|!=
name|th
operator|->
name|th_generation
condition|)
do|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* FFCLOCK */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|FFCLOCK
end_ifdef

begin_comment
comment|/*  * Support for feed-forward synchronization algorithms. This is heavily inspired  * by the timehands mechanism but kept independent from it. *_windup() functions  * have some connection to avoid accessing the timecounter hardware more than  * necessary.  */
end_comment

begin_comment
comment|/* Feed-forward clock estimates kept updated by the synchronization daemon. */
end_comment

begin_decl_stmt
name|struct
name|ffclock_estimate
name|ffclock_estimate
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|bintime
name|ffclock_boottime
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Feed-forward boot time estimate. */
end_comment

begin_decl_stmt
name|uint32_t
name|ffclock_status
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Feed-forward clock status. */
end_comment

begin_decl_stmt
name|int8_t
name|ffclock_updated
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* New estimates are available. */
end_comment

begin_decl_stmt
name|struct
name|mtx
name|ffclock_mtx
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Mutex on ffclock_estimate. */
end_comment

begin_struct
struct|struct
name|fftimehands
block|{
name|struct
name|ffclock_estimate
name|cest
decl_stmt|;
name|struct
name|bintime
name|tick_time
decl_stmt|;
name|struct
name|bintime
name|tick_time_lerp
decl_stmt|;
name|ffcounter
name|tick_ffcount
decl_stmt|;
name|uint64_t
name|period_lerp
decl_stmt|;
specifier|volatile
name|uint8_t
name|gen
decl_stmt|;
name|struct
name|fftimehands
modifier|*
name|next
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|NUM_ELEMENTS
parameter_list|(
name|x
parameter_list|)
value|(sizeof(x) / sizeof(*x))
end_define

begin_decl_stmt
specifier|static
name|struct
name|fftimehands
name|ffth
index|[
literal|10
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|fftimehands
modifier|*
specifier|volatile
name|fftimehands
init|=
name|ffth
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|ffclock_init
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|fftimehands
modifier|*
name|cur
decl_stmt|;
name|struct
name|fftimehands
modifier|*
name|last
decl_stmt|;
name|memset
argument_list|(
name|ffth
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ffth
argument_list|)
argument_list|)
expr_stmt|;
name|last
operator|=
name|ffth
operator|+
name|NUM_ELEMENTS
argument_list|(
name|ffth
argument_list|)
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|cur
operator|=
name|ffth
init|;
name|cur
operator|<
name|last
condition|;
name|cur
operator|++
control|)
name|cur
operator|->
name|next
operator|=
name|cur
operator|+
literal|1
expr_stmt|;
name|last
operator|->
name|next
operator|=
name|ffth
expr_stmt|;
name|ffclock_updated
operator|=
literal|0
expr_stmt|;
name|ffclock_status
operator|=
name|FFCLOCK_STA_UNSYNC
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|ffclock_mtx
argument_list|,
literal|"ffclock lock"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Reset the feed-forward clock estimates. Called from inittodr() to get things  * kick started and uses the timecounter nominal frequency as a first period  * estimate. Note: this function may be called several time just after boot.  * Note: this is the only function that sets the value of boot time for the  * monotonic (i.e. uptime) version of the feed-forward clock.  */
end_comment

begin_function
name|void
name|ffclock_reset_clock
parameter_list|(
name|struct
name|timespec
modifier|*
name|ts
parameter_list|)
block|{
name|struct
name|timecounter
modifier|*
name|tc
decl_stmt|;
name|struct
name|ffclock_estimate
name|cest
decl_stmt|;
name|tc
operator|=
name|timehands
operator|->
name|th_counter
expr_stmt|;
name|memset
argument_list|(
operator|&
name|cest
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ffclock_estimate
argument_list|)
argument_list|)
expr_stmt|;
name|timespec2bintime
argument_list|(
name|ts
argument_list|,
operator|&
name|ffclock_boottime
argument_list|)
expr_stmt|;
name|timespec2bintime
argument_list|(
name|ts
argument_list|,
operator|&
operator|(
name|cest
operator|.
name|update_time
operator|)
argument_list|)
expr_stmt|;
name|ffclock_read_counter
argument_list|(
operator|&
name|cest
operator|.
name|update_ffcount
argument_list|)
expr_stmt|;
name|cest
operator|.
name|leapsec_next
operator|=
literal|0
expr_stmt|;
name|cest
operator|.
name|period
operator|=
operator|(
operator|(
literal|1ULL
operator|<<
literal|63
operator|)
operator|/
name|tc
operator|->
name|tc_frequency
operator|)
operator|<<
literal|1
expr_stmt|;
name|cest
operator|.
name|errb_abs
operator|=
literal|0
expr_stmt|;
name|cest
operator|.
name|errb_rate
operator|=
literal|0
expr_stmt|;
name|cest
operator|.
name|status
operator|=
name|FFCLOCK_STA_UNSYNC
expr_stmt|;
name|cest
operator|.
name|leapsec_total
operator|=
literal|0
expr_stmt|;
name|cest
operator|.
name|leapsec
operator|=
literal|0
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|ffclock_mtx
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|cest
argument_list|,
operator|&
name|ffclock_estimate
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ffclock_estimate
argument_list|)
argument_list|)
expr_stmt|;
name|ffclock_updated
operator|=
name|INT8_MAX
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|ffclock_mtx
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"ffclock reset: %s (%llu Hz), time = %ld.%09lu\n"
argument_list|,
name|tc
operator|->
name|tc_name
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|tc
operator|->
name|tc_frequency
argument_list|,
operator|(
name|long
operator|)
name|ts
operator|->
name|tv_sec
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|ts
operator|->
name|tv_nsec
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Sub-routine to convert a time interval measured in RAW counter units to time  * in seconds stored in bintime format.  * NOTE: bintime_mul requires u_int, but the value of the ffcounter may be  * larger than the max value of u_int (on 32 bit architecture). Loop to consume  * extra cycles.  */
end_comment

begin_function
specifier|static
name|void
name|ffclock_convert_delta
parameter_list|(
name|ffcounter
name|ffdelta
parameter_list|,
name|uint64_t
name|period
parameter_list|,
name|struct
name|bintime
modifier|*
name|bt
parameter_list|)
block|{
name|struct
name|bintime
name|bt2
decl_stmt|;
name|ffcounter
name|delta
decl_stmt|,
name|delta_max
decl_stmt|;
name|delta_max
operator|=
operator|(
literal|1ULL
operator|<<
operator|(
literal|8
operator|*
expr|sizeof
operator|(
name|unsigned
name|int
operator|)
operator|)
operator|)
operator|-
literal|1
expr_stmt|;
name|bintime_clear
argument_list|(
name|bt
argument_list|)
expr_stmt|;
do|do
block|{
if|if
condition|(
name|ffdelta
operator|>
name|delta_max
condition|)
name|delta
operator|=
name|delta_max
expr_stmt|;
else|else
name|delta
operator|=
name|ffdelta
expr_stmt|;
name|bt2
operator|.
name|sec
operator|=
literal|0
expr_stmt|;
name|bt2
operator|.
name|frac
operator|=
name|period
expr_stmt|;
name|bintime_mul
argument_list|(
operator|&
name|bt2
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|delta
argument_list|)
expr_stmt|;
name|bintime_add
argument_list|(
name|bt
argument_list|,
operator|&
name|bt2
argument_list|)
expr_stmt|;
name|ffdelta
operator|-=
name|delta
expr_stmt|;
block|}
do|while
condition|(
name|ffdelta
operator|>
literal|0
condition|)
do|;
block|}
end_function

begin_comment
comment|/*  * Update the fftimehands.  * Push the tick ffcount and time(s) forward based on current clock estimate.  * The conversion from ffcounter to bintime relies on the difference clock  * principle, whose accuracy relies on computing small time intervals. If a new  * clock estimate has been passed by the synchronisation daemon, make it  * current, and compute the linear interpolation for monotonic time if needed.  */
end_comment

begin_function
specifier|static
name|void
name|ffclock_windup
parameter_list|(
name|unsigned
name|int
name|delta
parameter_list|)
block|{
name|struct
name|ffclock_estimate
modifier|*
name|cest
decl_stmt|;
name|struct
name|fftimehands
modifier|*
name|ffth
decl_stmt|;
name|struct
name|bintime
name|bt
decl_stmt|,
name|gap_lerp
decl_stmt|;
name|ffcounter
name|ffdelta
decl_stmt|;
name|uint64_t
name|frac
decl_stmt|;
name|unsigned
name|int
name|polling
decl_stmt|;
name|uint8_t
name|forward_jump
decl_stmt|,
name|ogen
decl_stmt|;
comment|/* 	 * Pick the next timehand, copy current ffclock estimates and move tick 	 * times and counter forward. 	 */
name|forward_jump
operator|=
literal|0
expr_stmt|;
name|ffth
operator|=
name|fftimehands
operator|->
name|next
expr_stmt|;
name|ogen
operator|=
name|ffth
operator|->
name|gen
expr_stmt|;
name|ffth
operator|->
name|gen
operator|=
literal|0
expr_stmt|;
name|cest
operator|=
operator|&
name|ffth
operator|->
name|cest
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|fftimehands
operator|->
name|cest
argument_list|,
name|cest
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ffclock_estimate
argument_list|)
argument_list|)
expr_stmt|;
name|ffdelta
operator|=
operator|(
name|ffcounter
operator|)
name|delta
expr_stmt|;
name|ffth
operator|->
name|period_lerp
operator|=
name|fftimehands
operator|->
name|period_lerp
expr_stmt|;
name|ffth
operator|->
name|tick_time
operator|=
name|fftimehands
operator|->
name|tick_time
expr_stmt|;
name|ffclock_convert_delta
argument_list|(
name|ffdelta
argument_list|,
name|cest
operator|->
name|period
argument_list|,
operator|&
name|bt
argument_list|)
expr_stmt|;
name|bintime_add
argument_list|(
operator|&
name|ffth
operator|->
name|tick_time
argument_list|,
operator|&
name|bt
argument_list|)
expr_stmt|;
name|ffth
operator|->
name|tick_time_lerp
operator|=
name|fftimehands
operator|->
name|tick_time_lerp
expr_stmt|;
name|ffclock_convert_delta
argument_list|(
name|ffdelta
argument_list|,
name|ffth
operator|->
name|period_lerp
argument_list|,
operator|&
name|bt
argument_list|)
expr_stmt|;
name|bintime_add
argument_list|(
operator|&
name|ffth
operator|->
name|tick_time_lerp
argument_list|,
operator|&
name|bt
argument_list|)
expr_stmt|;
name|ffth
operator|->
name|tick_ffcount
operator|=
name|fftimehands
operator|->
name|tick_ffcount
operator|+
name|ffdelta
expr_stmt|;
comment|/* 	 * Assess the status of the clock, if the last update is too old, it is 	 * likely the synchronisation daemon is dead and the clock is free 	 * running. 	 */
if|if
condition|(
name|ffclock_updated
operator|==
literal|0
condition|)
block|{
name|ffdelta
operator|=
name|ffth
operator|->
name|tick_ffcount
operator|-
name|cest
operator|->
name|update_ffcount
expr_stmt|;
name|ffclock_convert_delta
argument_list|(
name|ffdelta
argument_list|,
name|cest
operator|->
name|period
argument_list|,
operator|&
name|bt
argument_list|)
expr_stmt|;
if|if
condition|(
name|bt
operator|.
name|sec
operator|>
literal|2
operator|*
name|FFCLOCK_SKM_SCALE
condition|)
name|ffclock_status
operator||=
name|FFCLOCK_STA_UNSYNC
expr_stmt|;
block|}
comment|/* 	 * If available, grab updated clock estimates and make them current. 	 * Recompute time at this tick using the updated estimates. The clock 	 * estimates passed the feed-forward synchronisation daemon may result 	 * in time conversion that is not monotonically increasing (just after 	 * the update). time_lerp is a particular linear interpolation over the 	 * synchronisation algo polling period that ensures monotonicity for the 	 * clock ids requesting it. 	 */
if|if
condition|(
name|ffclock_updated
operator|>
literal|0
condition|)
block|{
name|bcopy
argument_list|(
operator|&
name|ffclock_estimate
argument_list|,
name|cest
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ffclock_estimate
argument_list|)
argument_list|)
expr_stmt|;
name|ffdelta
operator|=
name|ffth
operator|->
name|tick_ffcount
operator|-
name|cest
operator|->
name|update_ffcount
expr_stmt|;
name|ffth
operator|->
name|tick_time
operator|=
name|cest
operator|->
name|update_time
expr_stmt|;
name|ffclock_convert_delta
argument_list|(
name|ffdelta
argument_list|,
name|cest
operator|->
name|period
argument_list|,
operator|&
name|bt
argument_list|)
expr_stmt|;
name|bintime_add
argument_list|(
operator|&
name|ffth
operator|->
name|tick_time
argument_list|,
operator|&
name|bt
argument_list|)
expr_stmt|;
comment|/* ffclock_reset sets ffclock_updated to INT8_MAX */
if|if
condition|(
name|ffclock_updated
operator|==
name|INT8_MAX
condition|)
name|ffth
operator|->
name|tick_time_lerp
operator|=
name|ffth
operator|->
name|tick_time
expr_stmt|;
if|if
condition|(
name|bintime_cmp
argument_list|(
operator|&
name|ffth
operator|->
name|tick_time
argument_list|,
operator|&
name|ffth
operator|->
name|tick_time_lerp
argument_list|,
operator|>
argument_list|)
condition|)
name|forward_jump
operator|=
literal|1
expr_stmt|;
else|else
name|forward_jump
operator|=
literal|0
expr_stmt|;
name|bintime_clear
argument_list|(
operator|&
name|gap_lerp
argument_list|)
expr_stmt|;
if|if
condition|(
name|forward_jump
condition|)
block|{
name|gap_lerp
operator|=
name|ffth
operator|->
name|tick_time
expr_stmt|;
name|bintime_sub
argument_list|(
operator|&
name|gap_lerp
argument_list|,
operator|&
name|ffth
operator|->
name|tick_time_lerp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|gap_lerp
operator|=
name|ffth
operator|->
name|tick_time_lerp
expr_stmt|;
name|bintime_sub
argument_list|(
operator|&
name|gap_lerp
argument_list|,
operator|&
name|ffth
operator|->
name|tick_time
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * The reset from the RTC clock may be far from accurate, and 		 * reducing the gap between real time and interpolated time 		 * could take a very long time if the interpolated clock insists 		 * on strict monotonicity. The clock is reset under very strict 		 * conditions (kernel time is known to be wrong and 		 * synchronization daemon has been restarted recently. 		 * ffclock_boottime absorbs the jump to ensure boot time is 		 * correct and uptime functions stay consistent. 		 */
if|if
condition|(
operator|(
operator|(
name|ffclock_status
operator|&
name|FFCLOCK_STA_UNSYNC
operator|)
operator|==
name|FFCLOCK_STA_UNSYNC
operator|)
operator|&&
operator|(
operator|(
name|cest
operator|->
name|status
operator|&
name|FFCLOCK_STA_UNSYNC
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|(
name|cest
operator|->
name|status
operator|&
name|FFCLOCK_STA_WARMUP
operator|)
operator|==
name|FFCLOCK_STA_WARMUP
operator|)
condition|)
block|{
if|if
condition|(
name|forward_jump
condition|)
name|bintime_add
argument_list|(
operator|&
name|ffclock_boottime
argument_list|,
operator|&
name|gap_lerp
argument_list|)
expr_stmt|;
else|else
name|bintime_sub
argument_list|(
operator|&
name|ffclock_boottime
argument_list|,
operator|&
name|gap_lerp
argument_list|)
expr_stmt|;
name|ffth
operator|->
name|tick_time_lerp
operator|=
name|ffth
operator|->
name|tick_time
expr_stmt|;
name|bintime_clear
argument_list|(
operator|&
name|gap_lerp
argument_list|)
expr_stmt|;
block|}
name|ffclock_status
operator|=
name|cest
operator|->
name|status
expr_stmt|;
name|ffth
operator|->
name|period_lerp
operator|=
name|cest
operator|->
name|period
expr_stmt|;
comment|/* 		 * Compute corrected period used for the linear interpolation of 		 * time. The rate of linear interpolation is capped to 5000PPM 		 * (5ms/s). 		 */
if|if
condition|(
name|bintime_isset
argument_list|(
operator|&
name|gap_lerp
argument_list|)
condition|)
block|{
name|ffdelta
operator|=
name|cest
operator|->
name|update_ffcount
expr_stmt|;
name|ffdelta
operator|-=
name|fftimehands
operator|->
name|cest
operator|.
name|update_ffcount
expr_stmt|;
name|ffclock_convert_delta
argument_list|(
name|ffdelta
argument_list|,
name|cest
operator|->
name|period
argument_list|,
operator|&
name|bt
argument_list|)
expr_stmt|;
name|polling
operator|=
name|bt
operator|.
name|sec
expr_stmt|;
name|bt
operator|.
name|sec
operator|=
literal|0
expr_stmt|;
name|bt
operator|.
name|frac
operator|=
literal|5000000
operator|*
operator|(
name|uint64_t
operator|)
literal|18446744073LL
expr_stmt|;
name|bintime_mul
argument_list|(
operator|&
name|bt
argument_list|,
name|polling
argument_list|)
expr_stmt|;
if|if
condition|(
name|bintime_cmp
argument_list|(
operator|&
name|gap_lerp
argument_list|,
operator|&
name|bt
argument_list|,
operator|>
argument_list|)
condition|)
name|gap_lerp
operator|=
name|bt
expr_stmt|;
comment|/* Approximate 1 sec by 1-(1/2^64) to ease arithmetic */
name|frac
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|gap_lerp
operator|.
name|sec
operator|>
literal|0
condition|)
block|{
name|frac
operator|-=
literal|1
expr_stmt|;
name|frac
operator|/=
name|ffdelta
operator|/
name|gap_lerp
operator|.
name|sec
expr_stmt|;
block|}
name|frac
operator|+=
name|gap_lerp
operator|.
name|frac
operator|/
name|ffdelta
expr_stmt|;
if|if
condition|(
name|forward_jump
condition|)
name|ffth
operator|->
name|period_lerp
operator|+=
name|frac
expr_stmt|;
else|else
name|ffth
operator|->
name|period_lerp
operator|-=
name|frac
expr_stmt|;
block|}
name|ffclock_updated
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|++
name|ogen
operator|==
literal|0
condition|)
name|ogen
operator|=
literal|1
expr_stmt|;
name|ffth
operator|->
name|gen
operator|=
name|ogen
expr_stmt|;
name|fftimehands
operator|=
name|ffth
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Adjust the fftimehands when the timecounter is changed. Stating the obvious,  * the old and new hardware counter cannot be read simultaneously. tc_windup()  * does read the two counters 'back to back', but a few cycles are effectively  * lost, and not accumulated in tick_ffcount. This is a fairly radical  * operation for a feed-forward synchronization daemon, and it is its job to not  * pushing irrelevant data to the kernel. Because there is no locking here,  * simply force to ignore pending or next update to give daemon a chance to  * realize the counter has changed.  */
end_comment

begin_function
specifier|static
name|void
name|ffclock_change_tc
parameter_list|(
name|struct
name|timehands
modifier|*
name|th
parameter_list|)
block|{
name|struct
name|fftimehands
modifier|*
name|ffth
decl_stmt|;
name|struct
name|ffclock_estimate
modifier|*
name|cest
decl_stmt|;
name|struct
name|timecounter
modifier|*
name|tc
decl_stmt|;
name|uint8_t
name|ogen
decl_stmt|;
name|tc
operator|=
name|th
operator|->
name|th_counter
expr_stmt|;
name|ffth
operator|=
name|fftimehands
operator|->
name|next
expr_stmt|;
name|ogen
operator|=
name|ffth
operator|->
name|gen
expr_stmt|;
name|ffth
operator|->
name|gen
operator|=
literal|0
expr_stmt|;
name|cest
operator|=
operator|&
name|ffth
operator|->
name|cest
expr_stmt|;
name|bcopy
argument_list|(
operator|&
operator|(
name|fftimehands
operator|->
name|cest
operator|)
argument_list|,
name|cest
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ffclock_estimate
argument_list|)
argument_list|)
expr_stmt|;
name|cest
operator|->
name|period
operator|=
operator|(
operator|(
literal|1ULL
operator|<<
literal|63
operator|)
operator|/
name|tc
operator|->
name|tc_frequency
operator|)
operator|<<
literal|1
expr_stmt|;
name|cest
operator|->
name|errb_abs
operator|=
literal|0
expr_stmt|;
name|cest
operator|->
name|errb_rate
operator|=
literal|0
expr_stmt|;
name|cest
operator|->
name|status
operator||=
name|FFCLOCK_STA_UNSYNC
expr_stmt|;
name|ffth
operator|->
name|tick_ffcount
operator|=
name|fftimehands
operator|->
name|tick_ffcount
expr_stmt|;
name|ffth
operator|->
name|tick_time_lerp
operator|=
name|fftimehands
operator|->
name|tick_time_lerp
expr_stmt|;
name|ffth
operator|->
name|tick_time
operator|=
name|fftimehands
operator|->
name|tick_time
expr_stmt|;
name|ffth
operator|->
name|period_lerp
operator|=
name|cest
operator|->
name|period
expr_stmt|;
comment|/* Do not lock but ignore next update from synchronization daemon. */
name|ffclock_updated
operator|--
expr_stmt|;
if|if
condition|(
operator|++
name|ogen
operator|==
literal|0
condition|)
name|ogen
operator|=
literal|1
expr_stmt|;
name|ffth
operator|->
name|gen
operator|=
name|ogen
expr_stmt|;
name|fftimehands
operator|=
name|ffth
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Retrieve feed-forward counter and time of last kernel tick.  */
end_comment

begin_function
name|void
name|ffclock_last_tick
parameter_list|(
name|ffcounter
modifier|*
name|ffcount
parameter_list|,
name|struct
name|bintime
modifier|*
name|bt
parameter_list|,
name|uint32_t
name|flags
parameter_list|)
block|{
name|struct
name|fftimehands
modifier|*
name|ffth
decl_stmt|;
name|uint8_t
name|gen
decl_stmt|;
comment|/* 	 * No locking but check generation has not changed. Also need to make 	 * sure ffdelta is positive, i.e. ffcount> tick_ffcount. 	 */
do|do
block|{
name|ffth
operator|=
name|fftimehands
expr_stmt|;
name|gen
operator|=
name|ffth
operator|->
name|gen
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|FFCLOCK_LERP
operator|)
operator|==
name|FFCLOCK_LERP
condition|)
operator|*
name|bt
operator|=
name|ffth
operator|->
name|tick_time_lerp
expr_stmt|;
else|else
operator|*
name|bt
operator|=
name|ffth
operator|->
name|tick_time
expr_stmt|;
operator|*
name|ffcount
operator|=
name|ffth
operator|->
name|tick_ffcount
expr_stmt|;
block|}
do|while
condition|(
name|gen
operator|==
literal|0
operator|||
name|gen
operator|!=
name|ffth
operator|->
name|gen
condition|)
do|;
block|}
end_function

begin_comment
comment|/*  * Absolute clock conversion. Low level function to convert ffcounter to  * bintime. The ffcounter is converted using the current ffclock period estimate  * or the "interpolated period" to ensure monotonicity.  * NOTE: this conversion may have been deferred, and the clock updated since the  * hardware counter has been read.  */
end_comment

begin_function
name|void
name|ffclock_convert_abs
parameter_list|(
name|ffcounter
name|ffcount
parameter_list|,
name|struct
name|bintime
modifier|*
name|bt
parameter_list|,
name|uint32_t
name|flags
parameter_list|)
block|{
name|struct
name|fftimehands
modifier|*
name|ffth
decl_stmt|;
name|struct
name|bintime
name|bt2
decl_stmt|;
name|ffcounter
name|ffdelta
decl_stmt|;
name|uint8_t
name|gen
decl_stmt|;
comment|/* 	 * No locking but check generation has not changed. Also need to make 	 * sure ffdelta is positive, i.e. ffcount> tick_ffcount. 	 */
do|do
block|{
name|ffth
operator|=
name|fftimehands
expr_stmt|;
name|gen
operator|=
name|ffth
operator|->
name|gen
expr_stmt|;
if|if
condition|(
name|ffcount
operator|>
name|ffth
operator|->
name|tick_ffcount
condition|)
name|ffdelta
operator|=
name|ffcount
operator|-
name|ffth
operator|->
name|tick_ffcount
expr_stmt|;
else|else
name|ffdelta
operator|=
name|ffth
operator|->
name|tick_ffcount
operator|-
name|ffcount
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|FFCLOCK_LERP
operator|)
operator|==
name|FFCLOCK_LERP
condition|)
block|{
operator|*
name|bt
operator|=
name|ffth
operator|->
name|tick_time_lerp
expr_stmt|;
name|ffclock_convert_delta
argument_list|(
name|ffdelta
argument_list|,
name|ffth
operator|->
name|period_lerp
argument_list|,
operator|&
name|bt2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|bt
operator|=
name|ffth
operator|->
name|tick_time
expr_stmt|;
name|ffclock_convert_delta
argument_list|(
name|ffdelta
argument_list|,
name|ffth
operator|->
name|cest
operator|.
name|period
argument_list|,
operator|&
name|bt2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ffcount
operator|>
name|ffth
operator|->
name|tick_ffcount
condition|)
name|bintime_add
argument_list|(
name|bt
argument_list|,
operator|&
name|bt2
argument_list|)
expr_stmt|;
else|else
name|bintime_sub
argument_list|(
name|bt
argument_list|,
operator|&
name|bt2
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|gen
operator|==
literal|0
operator|||
name|gen
operator|!=
name|ffth
operator|->
name|gen
condition|)
do|;
block|}
end_function

begin_comment
comment|/*  * Difference clock conversion.  * Low level function to Convert a time interval measured in RAW counter units  * into bintime. The difference clock allows measuring small intervals much more  * reliably than the absolute clock.  */
end_comment

begin_function
name|void
name|ffclock_convert_diff
parameter_list|(
name|ffcounter
name|ffdelta
parameter_list|,
name|struct
name|bintime
modifier|*
name|bt
parameter_list|)
block|{
name|struct
name|fftimehands
modifier|*
name|ffth
decl_stmt|;
name|uint8_t
name|gen
decl_stmt|;
comment|/* No locking but check generation has not changed. */
do|do
block|{
name|ffth
operator|=
name|fftimehands
expr_stmt|;
name|gen
operator|=
name|ffth
operator|->
name|gen
expr_stmt|;
name|ffclock_convert_delta
argument_list|(
name|ffdelta
argument_list|,
name|ffth
operator|->
name|cest
operator|.
name|period
argument_list|,
name|bt
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|gen
operator|==
literal|0
operator|||
name|gen
operator|!=
name|ffth
operator|->
name|gen
condition|)
do|;
block|}
end_function

begin_comment
comment|/*  * Access to current ffcounter value.  */
end_comment

begin_function
name|void
name|ffclock_read_counter
parameter_list|(
name|ffcounter
modifier|*
name|ffcount
parameter_list|)
block|{
name|struct
name|timehands
modifier|*
name|th
decl_stmt|;
name|struct
name|fftimehands
modifier|*
name|ffth
decl_stmt|;
name|unsigned
name|int
name|gen
decl_stmt|,
name|delta
decl_stmt|;
comment|/* 	 * ffclock_windup() called from tc_windup(), safe to rely on 	 * th->th_generation only, for correct delta and ffcounter. 	 */
do|do
block|{
name|th
operator|=
name|timehands
expr_stmt|;
name|gen
operator|=
name|th
operator|->
name|th_generation
expr_stmt|;
name|ffth
operator|=
name|fftimehands
expr_stmt|;
name|delta
operator|=
name|tc_delta
argument_list|(
name|th
argument_list|)
expr_stmt|;
operator|*
name|ffcount
operator|=
name|ffth
operator|->
name|tick_ffcount
expr_stmt|;
block|}
do|while
condition|(
name|gen
operator|==
literal|0
operator|||
name|gen
operator|!=
name|th
operator|->
name|th_generation
condition|)
do|;
operator|*
name|ffcount
operator|+=
name|delta
expr_stmt|;
block|}
end_function

begin_function
name|void
name|binuptime
parameter_list|(
name|struct
name|bintime
modifier|*
name|bt
parameter_list|)
block|{
name|binuptime_fromclock
argument_list|(
name|bt
argument_list|,
name|sysclock_active
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|nanouptime
parameter_list|(
name|struct
name|timespec
modifier|*
name|tsp
parameter_list|)
block|{
name|nanouptime_fromclock
argument_list|(
name|tsp
argument_list|,
name|sysclock_active
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|microuptime
parameter_list|(
name|struct
name|timeval
modifier|*
name|tvp
parameter_list|)
block|{
name|microuptime_fromclock
argument_list|(
name|tvp
argument_list|,
name|sysclock_active
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|bintime
parameter_list|(
name|struct
name|bintime
modifier|*
name|bt
parameter_list|)
block|{
name|bintime_fromclock
argument_list|(
name|bt
argument_list|,
name|sysclock_active
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|nanotime
parameter_list|(
name|struct
name|timespec
modifier|*
name|tsp
parameter_list|)
block|{
name|nanotime_fromclock
argument_list|(
name|tsp
argument_list|,
name|sysclock_active
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|microtime
parameter_list|(
name|struct
name|timeval
modifier|*
name|tvp
parameter_list|)
block|{
name|microtime_fromclock
argument_list|(
name|tvp
argument_list|,
name|sysclock_active
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|getbinuptime
parameter_list|(
name|struct
name|bintime
modifier|*
name|bt
parameter_list|)
block|{
name|getbinuptime_fromclock
argument_list|(
name|bt
argument_list|,
name|sysclock_active
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|getnanouptime
parameter_list|(
name|struct
name|timespec
modifier|*
name|tsp
parameter_list|)
block|{
name|getnanouptime_fromclock
argument_list|(
name|tsp
argument_list|,
name|sysclock_active
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|getmicrouptime
parameter_list|(
name|struct
name|timeval
modifier|*
name|tvp
parameter_list|)
block|{
name|getmicrouptime_fromclock
argument_list|(
name|tvp
argument_list|,
name|sysclock_active
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|getbintime
parameter_list|(
name|struct
name|bintime
modifier|*
name|bt
parameter_list|)
block|{
name|getbintime_fromclock
argument_list|(
name|bt
argument_list|,
name|sysclock_active
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|getnanotime
parameter_list|(
name|struct
name|timespec
modifier|*
name|tsp
parameter_list|)
block|{
name|getnanotime_fromclock
argument_list|(
name|tsp
argument_list|,
name|sysclock_active
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|getmicrotime
parameter_list|(
name|struct
name|timeval
modifier|*
name|tvp
parameter_list|)
block|{
name|getmicrouptime_fromclock
argument_list|(
name|tvp
argument_list|,
name|sysclock_active
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* FFCLOCK */
end_comment

begin_comment
comment|/*  * This is a clone of getnanotime and used for walltimestamps.  * The dtrace_ prefix prevents fbt from creating probes for  * it so walltimestamp can be safely used in all fbt probes.  */
end_comment

begin_function
name|void
name|dtrace_getnanotime
parameter_list|(
name|struct
name|timespec
modifier|*
name|tsp
parameter_list|)
block|{
name|struct
name|timehands
modifier|*
name|th
decl_stmt|;
name|u_int
name|gen
decl_stmt|;
do|do
block|{
name|th
operator|=
name|timehands
expr_stmt|;
name|gen
operator|=
name|th
operator|->
name|th_generation
expr_stmt|;
operator|*
name|tsp
operator|=
name|th
operator|->
name|th_nanotime
expr_stmt|;
block|}
do|while
condition|(
name|gen
operator|==
literal|0
operator|||
name|gen
operator|!=
name|th
operator|->
name|th_generation
condition|)
do|;
block|}
end_function

begin_comment
comment|/*  * System clock currently providing time to the system. Modifiable via sysctl  * when the FFCLOCK option is defined.  */
end_comment

begin_decl_stmt
name|int
name|sysclock_active
init|=
name|SYSCLOCK_FBCK
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Internal NTP status and error estimates. */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|time_status
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|long
name|time_esterror
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Take a snapshot of sysclock data which can be used to compare system clocks  * and generate timestamps after the fact.  */
end_comment

begin_function
name|void
name|sysclock_getsnapshot
parameter_list|(
name|struct
name|sysclock_snap
modifier|*
name|clock_snap
parameter_list|,
name|int
name|fast
parameter_list|)
block|{
name|struct
name|fbclock_info
modifier|*
name|fbi
decl_stmt|;
name|struct
name|timehands
modifier|*
name|th
decl_stmt|;
name|struct
name|bintime
name|bt
decl_stmt|;
name|unsigned
name|int
name|delta
decl_stmt|,
name|gen
decl_stmt|;
ifdef|#
directive|ifdef
name|FFCLOCK
name|ffcounter
name|ffcount
decl_stmt|;
name|struct
name|fftimehands
modifier|*
name|ffth
decl_stmt|;
name|struct
name|ffclock_info
modifier|*
name|ffi
decl_stmt|;
name|struct
name|ffclock_estimate
name|cest
decl_stmt|;
name|ffi
operator|=
operator|&
name|clock_snap
operator|->
name|ff_info
expr_stmt|;
endif|#
directive|endif
name|fbi
operator|=
operator|&
name|clock_snap
operator|->
name|fb_info
expr_stmt|;
name|delta
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|th
operator|=
name|timehands
expr_stmt|;
name|gen
operator|=
name|th
operator|->
name|th_generation
expr_stmt|;
name|fbi
operator|->
name|th_scale
operator|=
name|th
operator|->
name|th_scale
expr_stmt|;
name|fbi
operator|->
name|tick_time
operator|=
name|th
operator|->
name|th_offset
expr_stmt|;
ifdef|#
directive|ifdef
name|FFCLOCK
name|ffth
operator|=
name|fftimehands
expr_stmt|;
name|ffi
operator|->
name|tick_time
operator|=
name|ffth
operator|->
name|tick_time_lerp
expr_stmt|;
name|ffi
operator|->
name|tick_time_lerp
operator|=
name|ffth
operator|->
name|tick_time_lerp
expr_stmt|;
name|ffi
operator|->
name|period
operator|=
name|ffth
operator|->
name|cest
operator|.
name|period
expr_stmt|;
name|ffi
operator|->
name|period_lerp
operator|=
name|ffth
operator|->
name|period_lerp
expr_stmt|;
name|clock_snap
operator|->
name|ffcount
operator|=
name|ffth
operator|->
name|tick_ffcount
expr_stmt|;
name|cest
operator|=
name|ffth
operator|->
name|cest
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|fast
condition|)
name|delta
operator|=
name|tc_delta
argument_list|(
name|th
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|gen
operator|==
literal|0
operator|||
name|gen
operator|!=
name|th
operator|->
name|th_generation
condition|)
do|;
name|clock_snap
operator|->
name|delta
operator|=
name|delta
expr_stmt|;
name|clock_snap
operator|->
name|sysclock_active
operator|=
name|sysclock_active
expr_stmt|;
comment|/* Record feedback clock status and error. */
name|clock_snap
operator|->
name|fb_info
operator|.
name|status
operator|=
name|time_status
expr_stmt|;
comment|/* XXX: Very crude estimate of feedback clock error. */
name|bt
operator|.
name|sec
operator|=
name|time_esterror
operator|/
literal|1000000
expr_stmt|;
name|bt
operator|.
name|frac
operator|=
operator|(
operator|(
name|time_esterror
operator|-
name|bt
operator|.
name|sec
operator|)
operator|*
literal|1000000
operator|)
operator|*
operator|(
name|uint64_t
operator|)
literal|18446744073709ULL
expr_stmt|;
name|clock_snap
operator|->
name|fb_info
operator|.
name|error
operator|=
name|bt
expr_stmt|;
ifdef|#
directive|ifdef
name|FFCLOCK
if|if
condition|(
operator|!
name|fast
condition|)
name|clock_snap
operator|->
name|ffcount
operator|+=
name|delta
expr_stmt|;
comment|/* Record feed-forward clock leap second adjustment. */
name|ffi
operator|->
name|leapsec_adjustment
operator|=
name|cest
operator|.
name|leapsec_total
expr_stmt|;
if|if
condition|(
name|clock_snap
operator|->
name|ffcount
operator|>
name|cest
operator|.
name|leapsec_next
condition|)
name|ffi
operator|->
name|leapsec_adjustment
operator|-=
name|cest
operator|.
name|leapsec
expr_stmt|;
comment|/* Record feed-forward clock status and error. */
name|clock_snap
operator|->
name|ff_info
operator|.
name|status
operator|=
name|cest
operator|.
name|status
expr_stmt|;
name|ffcount
operator|=
name|clock_snap
operator|->
name|ffcount
operator|-
name|cest
operator|.
name|update_ffcount
expr_stmt|;
name|ffclock_convert_delta
argument_list|(
name|ffcount
argument_list|,
name|cest
operator|.
name|period
argument_list|,
operator|&
name|bt
argument_list|)
expr_stmt|;
comment|/* 18446744073709 = int(2^64/1e12), err_bound_rate in [ps/s]. */
name|bintime_mul
argument_list|(
operator|&
name|bt
argument_list|,
name|cest
operator|.
name|errb_rate
operator|*
operator|(
name|uint64_t
operator|)
literal|18446744073709ULL
argument_list|)
expr_stmt|;
comment|/* 18446744073 = int(2^64 / 1e9), since err_abs in [ns]. */
name|bintime_addx
argument_list|(
operator|&
name|bt
argument_list|,
name|cest
operator|.
name|errb_abs
operator|*
operator|(
name|uint64_t
operator|)
literal|18446744073ULL
argument_list|)
expr_stmt|;
name|clock_snap
operator|->
name|ff_info
operator|.
name|error
operator|=
name|bt
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * Convert a sysclock snapshot into a struct bintime based on the specified  * clock source and flags.  */
end_comment

begin_function
name|int
name|sysclock_snap2bintime
parameter_list|(
name|struct
name|sysclock_snap
modifier|*
name|cs
parameter_list|,
name|struct
name|bintime
modifier|*
name|bt
parameter_list|,
name|int
name|whichclock
parameter_list|,
name|uint32_t
name|flags
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|FFCLOCK
name|struct
name|bintime
name|bt2
decl_stmt|;
name|uint64_t
name|period
decl_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|whichclock
condition|)
block|{
case|case
name|SYSCLOCK_FBCK
case|:
operator|*
name|bt
operator|=
name|cs
operator|->
name|fb_info
operator|.
name|tick_time
expr_stmt|;
comment|/* If snapshot was created with !fast, delta will be>0. */
if|if
condition|(
name|cs
operator|->
name|delta
operator|>
literal|0
condition|)
name|bintime_addx
argument_list|(
name|bt
argument_list|,
name|cs
operator|->
name|fb_info
operator|.
name|th_scale
operator|*
name|cs
operator|->
name|delta
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|FBCLOCK_UPTIME
operator|)
operator|==
literal|0
condition|)
name|bintime_add
argument_list|(
name|bt
argument_list|,
operator|&
name|boottimebin
argument_list|)
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|FFCLOCK
case|case
name|SYSCLOCK_FFWD
case|:
if|if
condition|(
name|flags
operator|&
name|FFCLOCK_LERP
condition|)
block|{
operator|*
name|bt
operator|=
name|cs
operator|->
name|ff_info
operator|.
name|tick_time_lerp
expr_stmt|;
name|period
operator|=
name|cs
operator|->
name|ff_info
operator|.
name|period_lerp
expr_stmt|;
block|}
else|else
block|{
operator|*
name|bt
operator|=
name|cs
operator|->
name|ff_info
operator|.
name|tick_time
expr_stmt|;
name|period
operator|=
name|cs
operator|->
name|ff_info
operator|.
name|period
expr_stmt|;
block|}
comment|/* If snapshot was created with !fast, delta will be>0. */
if|if
condition|(
name|cs
operator|->
name|delta
operator|>
literal|0
condition|)
block|{
name|ffclock_convert_delta
argument_list|(
name|cs
operator|->
name|delta
argument_list|,
name|period
argument_list|,
operator|&
name|bt2
argument_list|)
expr_stmt|;
name|bintime_add
argument_list|(
name|bt
argument_list|,
operator|&
name|bt2
argument_list|)
expr_stmt|;
block|}
comment|/* Leap second adjustment. */
if|if
condition|(
name|flags
operator|&
name|FFCLOCK_LEAPSEC
condition|)
name|bt
operator|->
name|sec
operator|-=
name|cs
operator|->
name|ff_info
operator|.
name|leapsec_adjustment
expr_stmt|;
comment|/* Boot time adjustment, for uptime/monotonic clocks. */
if|if
condition|(
name|flags
operator|&
name|FFCLOCK_UPTIME
condition|)
name|bintime_sub
argument_list|(
name|bt
argument_list|,
operator|&
name|ffclock_boottime
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
return|return
operator|(
name|EINVAL
operator|)
return|;
break|break;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Initialize a new timecounter and possibly use it.  */
end_comment

begin_function
name|void
name|tc_init
parameter_list|(
name|struct
name|timecounter
modifier|*
name|tc
parameter_list|)
block|{
name|u_int
name|u
decl_stmt|;
name|struct
name|sysctl_oid
modifier|*
name|tc_root
decl_stmt|;
name|u
operator|=
name|tc
operator|->
name|tc_frequency
operator|/
name|tc
operator|->
name|tc_counter_mask
expr_stmt|;
comment|/* XXX: We need some margin here, 10% is a guess */
name|u
operator|*=
literal|11
expr_stmt|;
name|u
operator|/=
literal|10
expr_stmt|;
if|if
condition|(
name|u
operator|>
name|hz
operator|&&
name|tc
operator|->
name|tc_quality
operator|>=
literal|0
condition|)
block|{
name|tc
operator|->
name|tc_quality
operator|=
operator|-
literal|2000
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
block|{
name|printf
argument_list|(
literal|"Timecounter \"%s\" frequency %ju Hz"
argument_list|,
name|tc
operator|->
name|tc_name
argument_list|,
operator|(
name|uintmax_t
operator|)
name|tc
operator|->
name|tc_frequency
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" -- Insufficient hz, needs at least %u\n"
argument_list|,
name|u
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|tc
operator|->
name|tc_quality
operator|>=
literal|0
operator|||
name|bootverbose
condition|)
block|{
name|printf
argument_list|(
literal|"Timecounter \"%s\" frequency %ju Hz quality %d\n"
argument_list|,
name|tc
operator|->
name|tc_name
argument_list|,
operator|(
name|uintmax_t
operator|)
name|tc
operator|->
name|tc_frequency
argument_list|,
name|tc
operator|->
name|tc_quality
argument_list|)
expr_stmt|;
block|}
name|tc
operator|->
name|tc_next
operator|=
name|timecounters
expr_stmt|;
name|timecounters
operator|=
name|tc
expr_stmt|;
comment|/* 	 * Set up sysctl tree for this counter. 	 */
name|tc_root
operator|=
name|SYSCTL_ADD_NODE
argument_list|(
name|NULL
argument_list|,
name|SYSCTL_STATIC_CHILDREN
argument_list|(
name|_kern_timecounter_tc
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
name|tc
operator|->
name|tc_name
argument_list|,
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
literal|"timecounter description"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UINT
argument_list|(
name|NULL
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|tc_root
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"mask"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
operator|(
name|tc
operator|->
name|tc_counter_mask
operator|)
argument_list|,
literal|0
argument_list|,
literal|"mask for implemented bits"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|NULL
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|tc_root
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"counter"
argument_list|,
name|CTLTYPE_UINT
operator||
name|CTLFLAG_RD
argument_list|,
name|tc
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|tc
argument_list|)
argument_list|,
name|sysctl_kern_timecounter_get
argument_list|,
literal|"IU"
argument_list|,
literal|"current timecounter value"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|NULL
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|tc_root
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"frequency"
argument_list|,
name|CTLTYPE_U64
operator||
name|CTLFLAG_RD
argument_list|,
name|tc
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|tc
argument_list|)
argument_list|,
name|sysctl_kern_timecounter_freq
argument_list|,
literal|"QU"
argument_list|,
literal|"timecounter frequency"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|NULL
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|tc_root
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"quality"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
operator|(
name|tc
operator|->
name|tc_quality
operator|)
argument_list|,
literal|0
argument_list|,
literal|"goodness of time counter"
argument_list|)
expr_stmt|;
comment|/* 	 * Never automatically use a timecounter with negative quality. 	 * Even though we run on the dummy counter, switching here may be 	 * worse since this timecounter may not be monotonous. 	 */
if|if
condition|(
name|tc
operator|->
name|tc_quality
operator|<
literal|0
condition|)
return|return;
if|if
condition|(
name|tc
operator|->
name|tc_quality
operator|<
name|timecounter
operator|->
name|tc_quality
condition|)
return|return;
if|if
condition|(
name|tc
operator|->
name|tc_quality
operator|==
name|timecounter
operator|->
name|tc_quality
operator|&&
name|tc
operator|->
name|tc_frequency
operator|<
name|timecounter
operator|->
name|tc_frequency
condition|)
return|return;
operator|(
name|void
operator|)
name|tc
operator|->
name|tc_get_timecount
argument_list|(
name|tc
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|tc
operator|->
name|tc_get_timecount
argument_list|(
name|tc
argument_list|)
expr_stmt|;
name|timecounter
operator|=
name|tc
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Report the frequency of the current timecounter. */
end_comment

begin_function
name|uint64_t
name|tc_getfrequency
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
name|timehands
operator|->
name|th_counter
operator|->
name|tc_frequency
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Step our concept of UTC.  This is done by modifying our estimate of  * when we booted.  * XXX: not locked.  */
end_comment

begin_function
name|void
name|tc_setclock
parameter_list|(
name|struct
name|timespec
modifier|*
name|ts
parameter_list|)
block|{
name|struct
name|timespec
name|tbef
decl_stmt|,
name|taft
decl_stmt|;
name|struct
name|bintime
name|bt
decl_stmt|,
name|bt2
decl_stmt|;
name|cpu_tick_calibrate
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|nanotime
argument_list|(
operator|&
name|tbef
argument_list|)
expr_stmt|;
name|timespec2bintime
argument_list|(
name|ts
argument_list|,
operator|&
name|bt
argument_list|)
expr_stmt|;
name|binuptime
argument_list|(
operator|&
name|bt2
argument_list|)
expr_stmt|;
name|bintime_sub
argument_list|(
operator|&
name|bt
argument_list|,
operator|&
name|bt2
argument_list|)
expr_stmt|;
name|bintime_add
argument_list|(
operator|&
name|bt2
argument_list|,
operator|&
name|boottimebin
argument_list|)
expr_stmt|;
name|boottimebin
operator|=
name|bt
expr_stmt|;
name|bintime2timeval
argument_list|(
operator|&
name|bt
argument_list|,
operator|&
name|boottime
argument_list|)
expr_stmt|;
comment|/* XXX fiddle all the little crinkly bits around the fiords... */
name|tc_windup
argument_list|()
expr_stmt|;
name|nanotime
argument_list|(
operator|&
name|taft
argument_list|)
expr_stmt|;
if|if
condition|(
name|timestepwarnings
condition|)
block|{
name|log
argument_list|(
name|LOG_INFO
argument_list|,
literal|"Time stepped from %jd.%09ld to %jd.%09ld (%jd.%09ld)\n"
argument_list|,
operator|(
name|intmax_t
operator|)
name|tbef
operator|.
name|tv_sec
argument_list|,
name|tbef
operator|.
name|tv_nsec
argument_list|,
operator|(
name|intmax_t
operator|)
name|taft
operator|.
name|tv_sec
argument_list|,
name|taft
operator|.
name|tv_nsec
argument_list|,
operator|(
name|intmax_t
operator|)
name|ts
operator|->
name|tv_sec
argument_list|,
name|ts
operator|->
name|tv_nsec
argument_list|)
expr_stmt|;
block|}
name|cpu_tick_calibrate
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Initialize the next struct timehands in the ring and make  * it the active timehands.  Along the way we might switch to a different  * timecounter and/or do seconds processing in NTP.  Slightly magic.  */
end_comment

begin_function
specifier|static
name|void
name|tc_windup
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|bintime
name|bt
decl_stmt|;
name|struct
name|timehands
modifier|*
name|th
decl_stmt|,
modifier|*
name|tho
decl_stmt|;
name|uint64_t
name|scale
decl_stmt|;
name|u_int
name|delta
decl_stmt|,
name|ncount
decl_stmt|,
name|ogen
decl_stmt|;
name|int
name|i
decl_stmt|;
name|time_t
name|t
decl_stmt|;
comment|/* 	 * Make the next timehands a copy of the current one, but do not 	 * overwrite the generation or next pointer.  While we update 	 * the contents, the generation must be zero. 	 */
name|tho
operator|=
name|timehands
expr_stmt|;
name|th
operator|=
name|tho
operator|->
name|th_next
expr_stmt|;
name|ogen
operator|=
name|th
operator|->
name|th_generation
expr_stmt|;
name|th
operator|->
name|th_generation
operator|=
literal|0
expr_stmt|;
name|bcopy
argument_list|(
name|tho
argument_list|,
name|th
argument_list|,
name|offsetof
argument_list|(
expr|struct
name|timehands
argument_list|,
name|th_generation
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Capture a timecounter delta on the current timecounter and if 	 * changing timecounters, a counter value from the new timecounter. 	 * Update the offset fields accordingly. 	 */
name|delta
operator|=
name|tc_delta
argument_list|(
name|th
argument_list|)
expr_stmt|;
if|if
condition|(
name|th
operator|->
name|th_counter
operator|!=
name|timecounter
condition|)
name|ncount
operator|=
name|timecounter
operator|->
name|tc_get_timecount
argument_list|(
name|timecounter
argument_list|)
expr_stmt|;
else|else
name|ncount
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|FFCLOCK
name|ffclock_windup
argument_list|(
name|delta
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|th
operator|->
name|th_offset_count
operator|+=
name|delta
expr_stmt|;
name|th
operator|->
name|th_offset_count
operator|&=
name|th
operator|->
name|th_counter
operator|->
name|tc_counter_mask
expr_stmt|;
while|while
condition|(
name|delta
operator|>
name|th
operator|->
name|th_counter
operator|->
name|tc_frequency
condition|)
block|{
comment|/* Eat complete unadjusted seconds. */
name|delta
operator|-=
name|th
operator|->
name|th_counter
operator|->
name|tc_frequency
expr_stmt|;
name|th
operator|->
name|th_offset
operator|.
name|sec
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|delta
operator|>
name|th
operator|->
name|th_counter
operator|->
name|tc_frequency
operator|/
literal|2
operator|)
operator|&&
operator|(
name|th
operator|->
name|th_scale
operator|*
name|delta
operator|<
operator|(
operator|(
name|uint64_t
operator|)
literal|1
operator|<<
literal|63
operator|)
operator|)
condition|)
block|{
comment|/* The product th_scale * delta just barely overflows. */
name|th
operator|->
name|th_offset
operator|.
name|sec
operator|++
expr_stmt|;
block|}
name|bintime_addx
argument_list|(
operator|&
name|th
operator|->
name|th_offset
argument_list|,
name|th
operator|->
name|th_scale
operator|*
name|delta
argument_list|)
expr_stmt|;
comment|/* 	 * Hardware latching timecounters may not generate interrupts on 	 * PPS events, so instead we poll them.  There is a finite risk that 	 * the hardware might capture a count which is later than the one we 	 * got above, and therefore possibly in the next NTP second which might 	 * have a different rate than the current NTP second.  It doesn't 	 * matter in practice. 	 */
if|if
condition|(
name|tho
operator|->
name|th_counter
operator|->
name|tc_poll_pps
condition|)
name|tho
operator|->
name|th_counter
operator|->
name|tc_poll_pps
argument_list|(
name|tho
operator|->
name|th_counter
argument_list|)
expr_stmt|;
comment|/* 	 * Deal with NTP second processing.  The for loop normally 	 * iterates at most once, but in extreme situations it might 	 * keep NTP sane if timeouts are not run for several seconds. 	 * At boot, the time step can be large when the TOD hardware 	 * has been read, so on really large steps, we call 	 * ntp_update_second only twice.  We need to call it twice in 	 * case we missed a leap second. 	 */
name|bt
operator|=
name|th
operator|->
name|th_offset
expr_stmt|;
name|bintime_add
argument_list|(
operator|&
name|bt
argument_list|,
operator|&
name|boottimebin
argument_list|)
expr_stmt|;
name|i
operator|=
name|bt
operator|.
name|sec
operator|-
name|tho
operator|->
name|th_microtime
operator|.
name|tv_sec
expr_stmt|;
if|if
condition|(
name|i
operator|>
name|LARGE_STEP
condition|)
name|i
operator|=
literal|2
expr_stmt|;
for|for
control|(
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|t
operator|=
name|bt
operator|.
name|sec
expr_stmt|;
name|ntp_update_second
argument_list|(
operator|&
name|th
operator|->
name|th_adjustment
argument_list|,
operator|&
name|bt
operator|.
name|sec
argument_list|)
expr_stmt|;
if|if
condition|(
name|bt
operator|.
name|sec
operator|!=
name|t
condition|)
name|boottimebin
operator|.
name|sec
operator|+=
name|bt
operator|.
name|sec
operator|-
name|t
expr_stmt|;
block|}
comment|/* Update the UTC timestamps used by the get*() functions. */
comment|/* XXX shouldn't do this here.  Should force non-`get' versions. */
name|bintime2timeval
argument_list|(
operator|&
name|bt
argument_list|,
operator|&
name|th
operator|->
name|th_microtime
argument_list|)
expr_stmt|;
name|bintime2timespec
argument_list|(
operator|&
name|bt
argument_list|,
operator|&
name|th
operator|->
name|th_nanotime
argument_list|)
expr_stmt|;
comment|/* Now is a good time to change timecounters. */
if|if
condition|(
name|th
operator|->
name|th_counter
operator|!=
name|timecounter
condition|)
block|{
ifndef|#
directive|ifndef
name|__arm__
if|if
condition|(
operator|(
name|timecounter
operator|->
name|tc_flags
operator|&
name|TC_FLAGS_C3STOP
operator|)
operator|!=
literal|0
condition|)
name|cpu_disable_deep_sleep
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|th
operator|->
name|th_counter
operator|->
name|tc_flags
operator|&
name|TC_FLAGS_C3STOP
operator|)
operator|!=
literal|0
condition|)
name|cpu_disable_deep_sleep
operator|--
expr_stmt|;
endif|#
directive|endif
name|th
operator|->
name|th_counter
operator|=
name|timecounter
expr_stmt|;
name|th
operator|->
name|th_offset_count
operator|=
name|ncount
expr_stmt|;
name|tc_min_ticktock_freq
operator|=
name|max
argument_list|(
literal|1
argument_list|,
name|timecounter
operator|->
name|tc_frequency
operator|/
operator|(
operator|(
operator|(
name|uint64_t
operator|)
name|timecounter
operator|->
name|tc_counter_mask
operator|+
literal|1
operator|)
operator|/
literal|3
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|FFCLOCK
name|ffclock_change_tc
argument_list|(
name|th
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/*- 	 * Recalculate the scaling factor.  We want the number of 1/2^64 	 * fractions of a second per period of the hardware counter, taking 	 * into account the th_adjustment factor which the NTP PLL/adjtime(2) 	 * processing provides us with. 	 * 	 * The th_adjustment is nanoseconds per second with 32 bit binary 	 * fraction and we want 64 bit binary fraction of second: 	 * 	 *	 x = a * 2^32 / 10^9 = a * 4.294967296 	 * 	 * The range of th_adjustment is +/- 5000PPM so inside a 64bit int 	 * we can only multiply by about 850 without overflowing, that 	 * leaves no suitably precise fractions for multiply before divide. 	 * 	 * Divide before multiply with a fraction of 2199/512 results in a 	 * systematic undercompensation of 10PPM of th_adjustment.  On a 	 * 5000PPM adjustment this is a 0.05PPM error.  This is acceptable.  	 * 	 * We happily sacrifice the lowest of the 64 bits of our result 	 * to the goddess of code clarity. 	 * 	 */
name|scale
operator|=
operator|(
name|uint64_t
operator|)
literal|1
operator|<<
literal|63
expr_stmt|;
name|scale
operator|+=
operator|(
name|th
operator|->
name|th_adjustment
operator|/
literal|1024
operator|)
operator|*
literal|2199
expr_stmt|;
name|scale
operator|/=
name|th
operator|->
name|th_counter
operator|->
name|tc_frequency
expr_stmt|;
name|th
operator|->
name|th_scale
operator|=
name|scale
operator|*
literal|2
expr_stmt|;
comment|/* 	 * Now that the struct timehands is again consistent, set the new 	 * generation number, making sure to not make it zero. 	 */
if|if
condition|(
operator|++
name|ogen
operator|==
literal|0
condition|)
name|ogen
operator|=
literal|1
expr_stmt|;
name|th
operator|->
name|th_generation
operator|=
name|ogen
expr_stmt|;
comment|/* Go live with the new struct timehands. */
ifdef|#
directive|ifdef
name|FFCLOCK
switch|switch
condition|(
name|sysclock_active
condition|)
block|{
case|case
name|SYSCLOCK_FBCK
case|:
endif|#
directive|endif
name|time_second
operator|=
name|th
operator|->
name|th_microtime
operator|.
name|tv_sec
expr_stmt|;
name|time_uptime
operator|=
name|th
operator|->
name|th_offset
operator|.
name|sec
expr_stmt|;
ifdef|#
directive|ifdef
name|FFCLOCK
break|break;
case|case
name|SYSCLOCK_FFWD
case|:
name|time_second
operator|=
name|fftimehands
operator|->
name|tick_time_lerp
operator|.
name|sec
expr_stmt|;
name|time_uptime
operator|=
name|fftimehands
operator|->
name|tick_time_lerp
operator|.
name|sec
operator|-
name|ffclock_boottime
operator|.
name|sec
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
name|timehands
operator|=
name|th
expr_stmt|;
name|timekeep_push_vdso
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Report or change the active timecounter hardware. */
end_comment

begin_function
specifier|static
name|int
name|sysctl_kern_timecounter_hardware
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|char
name|newname
index|[
literal|32
index|]
decl_stmt|;
name|struct
name|timecounter
modifier|*
name|newtc
decl_stmt|,
modifier|*
name|tc
decl_stmt|;
name|int
name|error
decl_stmt|;
name|tc
operator|=
name|timecounter
expr_stmt|;
name|strlcpy
argument_list|(
name|newname
argument_list|,
name|tc
operator|->
name|tc_name
argument_list|,
sizeof|sizeof
argument_list|(
name|newname
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|sysctl_handle_string
argument_list|(
name|oidp
argument_list|,
operator|&
name|newname
index|[
literal|0
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|newname
argument_list|)
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
operator|||
name|req
operator|->
name|newptr
operator|==
name|NULL
operator|||
name|strcmp
argument_list|(
name|newname
argument_list|,
name|tc
operator|->
name|tc_name
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
for|for
control|(
name|newtc
operator|=
name|timecounters
init|;
name|newtc
operator|!=
name|NULL
condition|;
name|newtc
operator|=
name|newtc
operator|->
name|tc_next
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|newname
argument_list|,
name|newtc
operator|->
name|tc_name
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
comment|/* Warm up new timecounter. */
operator|(
name|void
operator|)
name|newtc
operator|->
name|tc_get_timecount
argument_list|(
name|newtc
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|newtc
operator|->
name|tc_get_timecount
argument_list|(
name|newtc
argument_list|)
expr_stmt|;
name|timecounter
operator|=
name|newtc
expr_stmt|;
name|timekeep_push_vdso
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|SYSCTL_PROC
argument_list|(
name|_kern_timecounter
argument_list|,
name|OID_AUTO
argument_list|,
name|hardware
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|sysctl_kern_timecounter_hardware
argument_list|,
literal|"A"
argument_list|,
literal|"Timecounter hardware selected"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Report or change the active timecounter hardware. */
end_comment

begin_function
specifier|static
name|int
name|sysctl_kern_timecounter_choice
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|char
name|buf
index|[
literal|32
index|]
decl_stmt|,
modifier|*
name|spc
decl_stmt|;
name|struct
name|timecounter
modifier|*
name|tc
decl_stmt|;
name|int
name|error
decl_stmt|;
name|spc
operator|=
literal|""
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|tc
operator|=
name|timecounters
init|;
name|error
operator|==
literal|0
operator|&&
name|tc
operator|!=
name|NULL
condition|;
name|tc
operator|=
name|tc
operator|->
name|tc_next
control|)
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s%s(%d)"
argument_list|,
name|spc
argument_list|,
name|tc
operator|->
name|tc_name
argument_list|,
name|tc
operator|->
name|tc_quality
argument_list|)
expr_stmt|;
name|error
operator|=
name|SYSCTL_OUT
argument_list|(
name|req
argument_list|,
name|buf
argument_list|,
name|strlen
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|spc
operator|=
literal|" "
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|SYSCTL_PROC
argument_list|(
name|_kern_timecounter
argument_list|,
name|OID_AUTO
argument_list|,
name|choice
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RD
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|sysctl_kern_timecounter_choice
argument_list|,
literal|"A"
argument_list|,
literal|"Timecounter hardware detected"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * RFC 2783 PPS-API implementation.  */
end_comment

begin_function
specifier|static
name|int
name|pps_fetch
parameter_list|(
name|struct
name|pps_fetch_args
modifier|*
name|fapi
parameter_list|,
name|struct
name|pps_state
modifier|*
name|pps
parameter_list|)
block|{
name|int
name|err
decl_stmt|,
name|timo
decl_stmt|;
name|pps_seq_t
name|aseq
decl_stmt|,
name|cseq
decl_stmt|;
name|struct
name|timeval
name|tv
decl_stmt|;
if|if
condition|(
name|fapi
operator|->
name|tsformat
operator|&&
name|fapi
operator|->
name|tsformat
operator|!=
name|PPS_TSFMT_TSPEC
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* 	 * If no timeout is requested, immediately return whatever values were 	 * most recently captured.  If timeout seconds is -1, that's a request 	 * to block without a timeout.  WITNESS won't let us sleep forever 	 * without a lock (we really don't need a lock), so just repeatedly 	 * sleep a long time. 	 */
if|if
condition|(
name|fapi
operator|->
name|timeout
operator|.
name|tv_sec
operator|||
name|fapi
operator|->
name|timeout
operator|.
name|tv_nsec
condition|)
block|{
if|if
condition|(
name|fapi
operator|->
name|timeout
operator|.
name|tv_sec
operator|==
operator|-
literal|1
condition|)
name|timo
operator|=
literal|0x7fffffff
expr_stmt|;
else|else
block|{
name|tv
operator|.
name|tv_sec
operator|=
name|fapi
operator|->
name|timeout
operator|.
name|tv_sec
expr_stmt|;
name|tv
operator|.
name|tv_usec
operator|=
name|fapi
operator|->
name|timeout
operator|.
name|tv_nsec
operator|/
literal|1000
expr_stmt|;
name|timo
operator|=
name|tvtohz
argument_list|(
operator|&
name|tv
argument_list|)
expr_stmt|;
block|}
name|aseq
operator|=
name|pps
operator|->
name|ppsinfo
operator|.
name|assert_sequence
expr_stmt|;
name|cseq
operator|=
name|pps
operator|->
name|ppsinfo
operator|.
name|clear_sequence
expr_stmt|;
while|while
condition|(
name|aseq
operator|==
name|pps
operator|->
name|ppsinfo
operator|.
name|assert_sequence
operator|&&
name|cseq
operator|==
name|pps
operator|->
name|ppsinfo
operator|.
name|clear_sequence
condition|)
block|{
name|err
operator|=
name|tsleep
argument_list|(
name|pps
argument_list|,
name|PCATCH
argument_list|,
literal|"ppsfch"
argument_list|,
name|timo
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
name|EWOULDBLOCK
operator|&&
name|fapi
operator|->
name|timeout
operator|.
name|tv_sec
operator|==
operator|-
literal|1
condition|)
block|{
continue|continue;
block|}
elseif|else
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
return|return
operator|(
name|err
operator|)
return|;
block|}
block|}
block|}
name|pps
operator|->
name|ppsinfo
operator|.
name|current_mode
operator|=
name|pps
operator|->
name|ppsparam
operator|.
name|mode
expr_stmt|;
name|fapi
operator|->
name|pps_info_buf
operator|=
name|pps
operator|->
name|ppsinfo
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pps_ioctl
parameter_list|(
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|data
parameter_list|,
name|struct
name|pps_state
modifier|*
name|pps
parameter_list|)
block|{
name|pps_params_t
modifier|*
name|app
decl_stmt|;
name|struct
name|pps_fetch_args
modifier|*
name|fapi
decl_stmt|;
ifdef|#
directive|ifdef
name|FFCLOCK
name|struct
name|pps_fetch_ffc_args
modifier|*
name|fapi_ffc
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PPS_SYNC
name|struct
name|pps_kcbind_args
modifier|*
name|kapi
decl_stmt|;
endif|#
directive|endif
name|KASSERT
argument_list|(
name|pps
operator|!=
name|NULL
argument_list|,
operator|(
literal|"NULL pps pointer in pps_ioctl"
operator|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|PPS_IOC_CREATE
case|:
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|PPS_IOC_DESTROY
case|:
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|PPS_IOC_SETPARAMS
case|:
name|app
operator|=
operator|(
name|pps_params_t
operator|*
operator|)
name|data
expr_stmt|;
if|if
condition|(
name|app
operator|->
name|mode
operator|&
operator|~
name|pps
operator|->
name|ppscap
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
ifdef|#
directive|ifdef
name|FFCLOCK
comment|/* Ensure only a single clock is selected for ffc timestamp. */
if|if
condition|(
operator|(
name|app
operator|->
name|mode
operator|&
name|PPS_TSCLK_MASK
operator|)
operator|==
name|PPS_TSCLK_MASK
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
endif|#
directive|endif
name|pps
operator|->
name|ppsparam
operator|=
operator|*
name|app
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|PPS_IOC_GETPARAMS
case|:
name|app
operator|=
operator|(
name|pps_params_t
operator|*
operator|)
name|data
expr_stmt|;
operator|*
name|app
operator|=
name|pps
operator|->
name|ppsparam
expr_stmt|;
name|app
operator|->
name|api_version
operator|=
name|PPS_API_VERS_1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|PPS_IOC_GETCAP
case|:
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|pps
operator|->
name|ppscap
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|PPS_IOC_FETCH
case|:
name|fapi
operator|=
operator|(
expr|struct
name|pps_fetch_args
operator|*
operator|)
name|data
expr_stmt|;
return|return
operator|(
name|pps_fetch
argument_list|(
name|fapi
argument_list|,
name|pps
argument_list|)
operator|)
return|;
ifdef|#
directive|ifdef
name|FFCLOCK
case|case
name|PPS_IOC_FETCH_FFCOUNTER
case|:
name|fapi_ffc
operator|=
operator|(
expr|struct
name|pps_fetch_ffc_args
operator|*
operator|)
name|data
expr_stmt|;
if|if
condition|(
name|fapi_ffc
operator|->
name|tsformat
operator|&&
name|fapi_ffc
operator|->
name|tsformat
operator|!=
name|PPS_TSFMT_TSPEC
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|fapi_ffc
operator|->
name|timeout
operator|.
name|tv_sec
operator|||
name|fapi_ffc
operator|->
name|timeout
operator|.
name|tv_nsec
condition|)
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
name|pps
operator|->
name|ppsinfo_ffc
operator|.
name|current_mode
operator|=
name|pps
operator|->
name|ppsparam
operator|.
name|mode
expr_stmt|;
name|fapi_ffc
operator|->
name|pps_info_buf_ffc
operator|=
name|pps
operator|->
name|ppsinfo_ffc
expr_stmt|;
comment|/* Overwrite timestamps if feedback clock selected. */
switch|switch
condition|(
name|pps
operator|->
name|ppsparam
operator|.
name|mode
operator|&
name|PPS_TSCLK_MASK
condition|)
block|{
case|case
name|PPS_TSCLK_FBCK
case|:
name|fapi_ffc
operator|->
name|pps_info_buf_ffc
operator|.
name|assert_timestamp
operator|=
name|pps
operator|->
name|ppsinfo
operator|.
name|assert_timestamp
expr_stmt|;
name|fapi_ffc
operator|->
name|pps_info_buf_ffc
operator|.
name|clear_timestamp
operator|=
name|pps
operator|->
name|ppsinfo
operator|.
name|clear_timestamp
expr_stmt|;
break|break;
case|case
name|PPS_TSCLK_FFWD
case|:
break|break;
default|default:
break|break;
block|}
return|return
operator|(
literal|0
operator|)
return|;
endif|#
directive|endif
comment|/* FFCLOCK */
case|case
name|PPS_IOC_KCBIND
case|:
ifdef|#
directive|ifdef
name|PPS_SYNC
name|kapi
operator|=
operator|(
expr|struct
name|pps_kcbind_args
operator|*
operator|)
name|data
expr_stmt|;
comment|/* XXX Only root should be able to do this */
if|if
condition|(
name|kapi
operator|->
name|tsformat
operator|&&
name|kapi
operator|->
name|tsformat
operator|!=
name|PPS_TSFMT_TSPEC
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|kapi
operator|->
name|kernel_consumer
operator|!=
name|PPS_KC_HARDPPS
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|kapi
operator|->
name|edge
operator|&
operator|~
name|pps
operator|->
name|ppscap
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|pps
operator|->
name|kcmode
operator|=
name|kapi
operator|->
name|edge
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
else|#
directive|else
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
endif|#
directive|endif
default|default:
return|return
operator|(
name|ENOIOCTL
operator|)
return|;
block|}
block|}
end_function

begin_function
name|void
name|pps_init
parameter_list|(
name|struct
name|pps_state
modifier|*
name|pps
parameter_list|)
block|{
name|pps
operator|->
name|ppscap
operator||=
name|PPS_TSFMT_TSPEC
operator||
name|PPS_CANWAIT
expr_stmt|;
if|if
condition|(
name|pps
operator|->
name|ppscap
operator|&
name|PPS_CAPTUREASSERT
condition|)
name|pps
operator|->
name|ppscap
operator||=
name|PPS_OFFSETASSERT
expr_stmt|;
if|if
condition|(
name|pps
operator|->
name|ppscap
operator|&
name|PPS_CAPTURECLEAR
condition|)
name|pps
operator|->
name|ppscap
operator||=
name|PPS_OFFSETCLEAR
expr_stmt|;
ifdef|#
directive|ifdef
name|FFCLOCK
name|pps
operator|->
name|ppscap
operator||=
name|PPS_TSCLK_MASK
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|pps_capture
parameter_list|(
name|struct
name|pps_state
modifier|*
name|pps
parameter_list|)
block|{
name|struct
name|timehands
modifier|*
name|th
decl_stmt|;
name|KASSERT
argument_list|(
name|pps
operator|!=
name|NULL
argument_list|,
operator|(
literal|"NULL pps pointer in pps_capture"
operator|)
argument_list|)
expr_stmt|;
name|th
operator|=
name|timehands
expr_stmt|;
name|pps
operator|->
name|capgen
operator|=
name|th
operator|->
name|th_generation
expr_stmt|;
name|pps
operator|->
name|capth
operator|=
name|th
expr_stmt|;
ifdef|#
directive|ifdef
name|FFCLOCK
name|pps
operator|->
name|capffth
operator|=
name|fftimehands
expr_stmt|;
endif|#
directive|endif
name|pps
operator|->
name|capcount
operator|=
name|th
operator|->
name|th_counter
operator|->
name|tc_get_timecount
argument_list|(
name|th
operator|->
name|th_counter
argument_list|)
expr_stmt|;
if|if
condition|(
name|pps
operator|->
name|capgen
operator|!=
name|th
operator|->
name|th_generation
condition|)
name|pps
operator|->
name|capgen
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pps_event
parameter_list|(
name|struct
name|pps_state
modifier|*
name|pps
parameter_list|,
name|int
name|event
parameter_list|)
block|{
name|struct
name|bintime
name|bt
decl_stmt|;
name|struct
name|timespec
name|ts
decl_stmt|,
modifier|*
name|tsp
decl_stmt|,
modifier|*
name|osp
decl_stmt|;
name|u_int
name|tcount
decl_stmt|,
modifier|*
name|pcount
decl_stmt|;
name|int
name|foff
decl_stmt|,
name|fhard
decl_stmt|;
name|pps_seq_t
modifier|*
name|pseq
decl_stmt|;
ifdef|#
directive|ifdef
name|FFCLOCK
name|struct
name|timespec
modifier|*
name|tsp_ffc
decl_stmt|;
name|pps_seq_t
modifier|*
name|pseq_ffc
decl_stmt|;
name|ffcounter
modifier|*
name|ffcount
decl_stmt|;
endif|#
directive|endif
name|KASSERT
argument_list|(
name|pps
operator|!=
name|NULL
argument_list|,
operator|(
literal|"NULL pps pointer in pps_event"
operator|)
argument_list|)
expr_stmt|;
comment|/* If the timecounter was wound up underneath us, bail out. */
if|if
condition|(
name|pps
operator|->
name|capgen
operator|==
literal|0
operator|||
name|pps
operator|->
name|capgen
operator|!=
name|pps
operator|->
name|capth
operator|->
name|th_generation
condition|)
return|return;
comment|/* Things would be easier with arrays. */
if|if
condition|(
name|event
operator|==
name|PPS_CAPTUREASSERT
condition|)
block|{
name|tsp
operator|=
operator|&
name|pps
operator|->
name|ppsinfo
operator|.
name|assert_timestamp
expr_stmt|;
name|osp
operator|=
operator|&
name|pps
operator|->
name|ppsparam
operator|.
name|assert_offset
expr_stmt|;
name|foff
operator|=
name|pps
operator|->
name|ppsparam
operator|.
name|mode
operator|&
name|PPS_OFFSETASSERT
expr_stmt|;
name|fhard
operator|=
name|pps
operator|->
name|kcmode
operator|&
name|PPS_CAPTUREASSERT
expr_stmt|;
name|pcount
operator|=
operator|&
name|pps
operator|->
name|ppscount
index|[
literal|0
index|]
expr_stmt|;
name|pseq
operator|=
operator|&
name|pps
operator|->
name|ppsinfo
operator|.
name|assert_sequence
expr_stmt|;
ifdef|#
directive|ifdef
name|FFCLOCK
name|ffcount
operator|=
operator|&
name|pps
operator|->
name|ppsinfo_ffc
operator|.
name|assert_ffcount
expr_stmt|;
name|tsp_ffc
operator|=
operator|&
name|pps
operator|->
name|ppsinfo_ffc
operator|.
name|assert_timestamp
expr_stmt|;
name|pseq_ffc
operator|=
operator|&
name|pps
operator|->
name|ppsinfo_ffc
operator|.
name|assert_sequence
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
name|tsp
operator|=
operator|&
name|pps
operator|->
name|ppsinfo
operator|.
name|clear_timestamp
expr_stmt|;
name|osp
operator|=
operator|&
name|pps
operator|->
name|ppsparam
operator|.
name|clear_offset
expr_stmt|;
name|foff
operator|=
name|pps
operator|->
name|ppsparam
operator|.
name|mode
operator|&
name|PPS_OFFSETCLEAR
expr_stmt|;
name|fhard
operator|=
name|pps
operator|->
name|kcmode
operator|&
name|PPS_CAPTURECLEAR
expr_stmt|;
name|pcount
operator|=
operator|&
name|pps
operator|->
name|ppscount
index|[
literal|1
index|]
expr_stmt|;
name|pseq
operator|=
operator|&
name|pps
operator|->
name|ppsinfo
operator|.
name|clear_sequence
expr_stmt|;
ifdef|#
directive|ifdef
name|FFCLOCK
name|ffcount
operator|=
operator|&
name|pps
operator|->
name|ppsinfo_ffc
operator|.
name|clear_ffcount
expr_stmt|;
name|tsp_ffc
operator|=
operator|&
name|pps
operator|->
name|ppsinfo_ffc
operator|.
name|clear_timestamp
expr_stmt|;
name|pseq_ffc
operator|=
operator|&
name|pps
operator|->
name|ppsinfo_ffc
operator|.
name|clear_sequence
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* 	 * If the timecounter changed, we cannot compare the count values, so 	 * we have to drop the rest of the PPS-stuff until the next event. 	 */
if|if
condition|(
name|pps
operator|->
name|ppstc
operator|!=
name|pps
operator|->
name|capth
operator|->
name|th_counter
condition|)
block|{
name|pps
operator|->
name|ppstc
operator|=
name|pps
operator|->
name|capth
operator|->
name|th_counter
expr_stmt|;
operator|*
name|pcount
operator|=
name|pps
operator|->
name|capcount
expr_stmt|;
name|pps
operator|->
name|ppscount
index|[
literal|2
index|]
operator|=
name|pps
operator|->
name|capcount
expr_stmt|;
return|return;
block|}
comment|/* Convert the count to a timespec. */
name|tcount
operator|=
name|pps
operator|->
name|capcount
operator|-
name|pps
operator|->
name|capth
operator|->
name|th_offset_count
expr_stmt|;
name|tcount
operator|&=
name|pps
operator|->
name|capth
operator|->
name|th_counter
operator|->
name|tc_counter_mask
expr_stmt|;
name|bt
operator|=
name|pps
operator|->
name|capth
operator|->
name|th_offset
expr_stmt|;
name|bintime_addx
argument_list|(
operator|&
name|bt
argument_list|,
name|pps
operator|->
name|capth
operator|->
name|th_scale
operator|*
name|tcount
argument_list|)
expr_stmt|;
name|bintime_add
argument_list|(
operator|&
name|bt
argument_list|,
operator|&
name|boottimebin
argument_list|)
expr_stmt|;
name|bintime2timespec
argument_list|(
operator|&
name|bt
argument_list|,
operator|&
name|ts
argument_list|)
expr_stmt|;
comment|/* If the timecounter was wound up underneath us, bail out. */
if|if
condition|(
name|pps
operator|->
name|capgen
operator|!=
name|pps
operator|->
name|capth
operator|->
name|th_generation
condition|)
return|return;
operator|*
name|pcount
operator|=
name|pps
operator|->
name|capcount
expr_stmt|;
operator|(
operator|*
name|pseq
operator|)
operator|++
expr_stmt|;
operator|*
name|tsp
operator|=
name|ts
expr_stmt|;
if|if
condition|(
name|foff
condition|)
block|{
name|timespecadd
argument_list|(
name|tsp
argument_list|,
name|osp
argument_list|)
expr_stmt|;
if|if
condition|(
name|tsp
operator|->
name|tv_nsec
operator|<
literal|0
condition|)
block|{
name|tsp
operator|->
name|tv_nsec
operator|+=
literal|1000000000
expr_stmt|;
name|tsp
operator|->
name|tv_sec
operator|-=
literal|1
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|FFCLOCK
operator|*
name|ffcount
operator|=
name|pps
operator|->
name|capffth
operator|->
name|tick_ffcount
operator|+
name|tcount
expr_stmt|;
name|bt
operator|=
name|pps
operator|->
name|capffth
operator|->
name|tick_time
expr_stmt|;
name|ffclock_convert_delta
argument_list|(
name|tcount
argument_list|,
name|pps
operator|->
name|capffth
operator|->
name|cest
operator|.
name|period
argument_list|,
operator|&
name|bt
argument_list|)
expr_stmt|;
name|bintime_add
argument_list|(
operator|&
name|bt
argument_list|,
operator|&
name|pps
operator|->
name|capffth
operator|->
name|tick_time
argument_list|)
expr_stmt|;
name|bintime2timespec
argument_list|(
operator|&
name|bt
argument_list|,
operator|&
name|ts
argument_list|)
expr_stmt|;
operator|(
operator|*
name|pseq_ffc
operator|)
operator|++
expr_stmt|;
operator|*
name|tsp_ffc
operator|=
name|ts
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PPS_SYNC
if|if
condition|(
name|fhard
condition|)
block|{
name|uint64_t
name|scale
decl_stmt|;
comment|/* 		 * Feed the NTP PLL/FLL. 		 * The FLL wants to know how many (hardware) nanoseconds 		 * elapsed since the previous event. 		 */
name|tcount
operator|=
name|pps
operator|->
name|capcount
operator|-
name|pps
operator|->
name|ppscount
index|[
literal|2
index|]
expr_stmt|;
name|pps
operator|->
name|ppscount
index|[
literal|2
index|]
operator|=
name|pps
operator|->
name|capcount
expr_stmt|;
name|tcount
operator|&=
name|pps
operator|->
name|capth
operator|->
name|th_counter
operator|->
name|tc_counter_mask
expr_stmt|;
name|scale
operator|=
operator|(
name|uint64_t
operator|)
literal|1
operator|<<
literal|63
expr_stmt|;
name|scale
operator|/=
name|pps
operator|->
name|capth
operator|->
name|th_counter
operator|->
name|tc_frequency
expr_stmt|;
name|scale
operator|*=
literal|2
expr_stmt|;
name|bt
operator|.
name|sec
operator|=
literal|0
expr_stmt|;
name|bt
operator|.
name|frac
operator|=
literal|0
expr_stmt|;
name|bintime_addx
argument_list|(
operator|&
name|bt
argument_list|,
name|scale
operator|*
name|tcount
argument_list|)
expr_stmt|;
name|bintime2timespec
argument_list|(
operator|&
name|bt
argument_list|,
operator|&
name|ts
argument_list|)
expr_stmt|;
name|hardpps
argument_list|(
name|tsp
argument_list|,
name|ts
operator|.
name|tv_nsec
operator|+
literal|1000000000
operator|*
name|ts
operator|.
name|tv_sec
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Wakeup anyone sleeping in pps_fetch().  */
name|wakeup
argument_list|(
name|pps
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Timecounters need to be updated every so often to prevent the hardware  * counter from overflowing.  Updating also recalculates the cached values  * used by the get*() family of functions, so their precision depends on  * the update frequency.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|tc_tick
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_kern_timecounter
argument_list|,
name|OID_AUTO
argument_list|,
name|tick
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|tc_tick
argument_list|,
literal|0
argument_list|,
literal|"Approximate number of hardclock ticks in a millisecond"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
name|void
name|tc_ticktock
parameter_list|(
name|int
name|cnt
parameter_list|)
block|{
specifier|static
name|int
name|count
decl_stmt|;
name|count
operator|+=
name|cnt
expr_stmt|;
if|if
condition|(
name|count
operator|<
name|tc_tick
condition|)
return|return;
name|count
operator|=
literal|0
expr_stmt|;
name|tc_windup
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|__inline
name|tc_adjprecision
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|t
decl_stmt|;
if|if
condition|(
name|tc_timepercentage
operator|>
literal|0
condition|)
block|{
name|t
operator|=
operator|(
literal|99
operator|+
name|tc_timepercentage
operator|)
operator|/
name|tc_timepercentage
expr_stmt|;
name|tc_precexp
operator|=
name|fls
argument_list|(
name|t
operator|+
operator|(
name|t
operator|>>
literal|1
operator|)
argument_list|)
operator|-
literal|1
expr_stmt|;
name|FREQ2BT
argument_list|(
name|hz
operator|/
name|tc_tick
argument_list|,
operator|&
name|bt_timethreshold
argument_list|)
expr_stmt|;
name|FREQ2BT
argument_list|(
name|hz
argument_list|,
operator|&
name|bt_tickthreshold
argument_list|)
expr_stmt|;
name|bintime_shift
argument_list|(
operator|&
name|bt_timethreshold
argument_list|,
name|tc_precexp
argument_list|)
expr_stmt|;
name|bintime_shift
argument_list|(
operator|&
name|bt_tickthreshold
argument_list|,
name|tc_precexp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tc_precexp
operator|=
literal|31
expr_stmt|;
name|bt_timethreshold
operator|.
name|sec
operator|=
name|INT_MAX
expr_stmt|;
name|bt_timethreshold
operator|.
name|frac
operator|=
operator|~
operator|(
name|uint64_t
operator|)
literal|0
expr_stmt|;
name|bt_tickthreshold
operator|=
name|bt_timethreshold
expr_stmt|;
block|}
name|sbt_timethreshold
operator|=
name|bttosbt
argument_list|(
name|bt_timethreshold
argument_list|)
expr_stmt|;
name|sbt_tickthreshold
operator|=
name|bttosbt
argument_list|(
name|bt_tickthreshold
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|sysctl_kern_timecounter_adjprecision
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|int
name|error
decl_stmt|,
name|val
decl_stmt|;
name|val
operator|=
name|tc_timepercentage
expr_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|val
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
operator|||
name|req
operator|->
name|newptr
operator|==
name|NULL
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|tc_timepercentage
operator|=
name|val
expr_stmt|;
if|if
condition|(
name|cold
condition|)
goto|goto
name|done
goto|;
name|tc_adjprecision
argument_list|()
expr_stmt|;
name|done
label|:
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|inittimecounter
parameter_list|(
name|void
modifier|*
name|dummy
parameter_list|)
block|{
name|u_int
name|p
decl_stmt|;
name|int
name|tick_rate
decl_stmt|;
comment|/* 	 * Set the initial timeout to 	 * max(1,<approx. number of hardclock ticks in a millisecond>). 	 * People should probably not use the sysctl to set the timeout 	 * to smaller than its inital value, since that value is the 	 * smallest reasonable one.  If they want better timestamps they 	 * should use the non-"get"* functions. 	 */
if|if
condition|(
name|hz
operator|>
literal|1000
condition|)
name|tc_tick
operator|=
operator|(
name|hz
operator|+
literal|500
operator|)
operator|/
literal|1000
expr_stmt|;
else|else
name|tc_tick
operator|=
literal|1
expr_stmt|;
name|tc_adjprecision
argument_list|()
expr_stmt|;
name|FREQ2BT
argument_list|(
name|hz
argument_list|,
operator|&
name|tick_bt
argument_list|)
expr_stmt|;
name|tick_sbt
operator|=
name|bttosbt
argument_list|(
name|tick_bt
argument_list|)
expr_stmt|;
name|tick_rate
operator|=
name|hz
operator|/
name|tc_tick
expr_stmt|;
name|FREQ2BT
argument_list|(
name|tick_rate
argument_list|,
operator|&
name|tc_tick_bt
argument_list|)
expr_stmt|;
name|tc_tick_sbt
operator|=
name|bttosbt
argument_list|(
name|tc_tick_bt
argument_list|)
expr_stmt|;
name|p
operator|=
operator|(
name|tc_tick
operator|*
literal|1000000
operator|)
operator|/
name|hz
expr_stmt|;
name|printf
argument_list|(
literal|"Timecounters tick every %d.%03u msec\n"
argument_list|,
name|p
operator|/
literal|1000
argument_list|,
name|p
operator|%
literal|1000
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|FFCLOCK
name|ffclock_init
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* warm up new timecounter (again) and get rolling. */
operator|(
name|void
operator|)
name|timecounter
operator|->
name|tc_get_timecount
argument_list|(
name|timecounter
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|timecounter
operator|->
name|tc_get_timecount
argument_list|(
name|timecounter
argument_list|)
expr_stmt|;
name|tc_windup
argument_list|()
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|SYSINIT
argument_list|(
name|timecounter
argument_list|,
name|SI_SUB_CLOCKS
argument_list|,
name|SI_ORDER_SECOND
argument_list|,
name|inittimecounter
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Cpu tick handling -------------------------------------------------*/
end_comment

begin_decl_stmt
specifier|static
name|int
name|cpu_tick_variable
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|uint64_t
name|cpu_tick_frequency
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|uint64_t
name|tc_cpu_ticks
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
name|uint64_t
name|base
decl_stmt|;
specifier|static
name|unsigned
name|last
decl_stmt|;
name|unsigned
name|u
decl_stmt|;
name|struct
name|timecounter
modifier|*
name|tc
decl_stmt|;
name|tc
operator|=
name|timehands
operator|->
name|th_counter
expr_stmt|;
name|u
operator|=
name|tc
operator|->
name|tc_get_timecount
argument_list|(
name|tc
argument_list|)
operator|&
name|tc
operator|->
name|tc_counter_mask
expr_stmt|;
if|if
condition|(
name|u
operator|<
name|last
condition|)
name|base
operator|+=
operator|(
name|uint64_t
operator|)
name|tc
operator|->
name|tc_counter_mask
operator|+
literal|1
expr_stmt|;
name|last
operator|=
name|u
expr_stmt|;
return|return
operator|(
name|u
operator|+
name|base
operator|)
return|;
block|}
end_function

begin_function
name|void
name|cpu_tick_calibration
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
name|time_t
name|last_calib
decl_stmt|;
if|if
condition|(
name|time_uptime
operator|!=
name|last_calib
operator|&&
operator|!
operator|(
name|time_uptime
operator|&
literal|0xf
operator|)
condition|)
block|{
name|cpu_tick_calibrate
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|last_calib
operator|=
name|time_uptime
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * This function gets called every 16 seconds on only one designated  * CPU in the system from hardclock() via cpu_tick_calibration()().  *  * Whenever the real time clock is stepped we get called with reset=1  * to make sure we handle suspend/resume and similar events correctly.  */
end_comment

begin_function
specifier|static
name|void
name|cpu_tick_calibrate
parameter_list|(
name|int
name|reset
parameter_list|)
block|{
specifier|static
name|uint64_t
name|c_last
decl_stmt|;
name|uint64_t
name|c_this
decl_stmt|,
name|c_delta
decl_stmt|;
specifier|static
name|struct
name|bintime
name|t_last
decl_stmt|;
name|struct
name|bintime
name|t_this
decl_stmt|,
name|t_delta
decl_stmt|;
name|uint32_t
name|divi
decl_stmt|;
if|if
condition|(
name|reset
condition|)
block|{
comment|/* The clock was stepped, abort& reset */
name|t_last
operator|.
name|sec
operator|=
literal|0
expr_stmt|;
return|return;
block|}
comment|/* we don't calibrate fixed rate cputicks */
if|if
condition|(
operator|!
name|cpu_tick_variable
condition|)
return|return;
name|getbinuptime
argument_list|(
operator|&
name|t_this
argument_list|)
expr_stmt|;
name|c_this
operator|=
name|cpu_ticks
argument_list|()
expr_stmt|;
if|if
condition|(
name|t_last
operator|.
name|sec
operator|!=
literal|0
condition|)
block|{
name|c_delta
operator|=
name|c_this
operator|-
name|c_last
expr_stmt|;
name|t_delta
operator|=
name|t_this
expr_stmt|;
name|bintime_sub
argument_list|(
operator|&
name|t_delta
argument_list|,
operator|&
name|t_last
argument_list|)
expr_stmt|;
comment|/* 		 * Headroom: 		 * 	2^(64-20) / 16[s] = 		 * 	2^(44) / 16[s] = 		 * 	17.592.186.044.416 / 16 = 		 * 	1.099.511.627.776 [Hz] 		 */
name|divi
operator|=
name|t_delta
operator|.
name|sec
operator|<<
literal|20
expr_stmt|;
name|divi
operator||=
name|t_delta
operator|.
name|frac
operator|>>
operator|(
literal|64
operator|-
literal|20
operator|)
expr_stmt|;
name|c_delta
operator|<<=
literal|20
expr_stmt|;
name|c_delta
operator|/=
name|divi
expr_stmt|;
if|if
condition|(
name|c_delta
operator|>
name|cpu_tick_frequency
condition|)
block|{
if|if
condition|(
literal|0
operator|&&
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"cpu_tick increased to %ju Hz\n"
argument_list|,
name|c_delta
argument_list|)
expr_stmt|;
name|cpu_tick_frequency
operator|=
name|c_delta
expr_stmt|;
block|}
block|}
name|c_last
operator|=
name|c_this
expr_stmt|;
name|t_last
operator|=
name|t_this
expr_stmt|;
block|}
end_function

begin_function
name|void
name|set_cputicker
parameter_list|(
name|cpu_tick_f
modifier|*
name|func
parameter_list|,
name|uint64_t
name|freq
parameter_list|,
name|unsigned
name|var
parameter_list|)
block|{
if|if
condition|(
name|func
operator|==
name|NULL
condition|)
block|{
name|cpu_ticks
operator|=
name|tc_cpu_ticks
expr_stmt|;
block|}
else|else
block|{
name|cpu_tick_frequency
operator|=
name|freq
expr_stmt|;
name|cpu_tick_variable
operator|=
name|var
expr_stmt|;
name|cpu_ticks
operator|=
name|func
expr_stmt|;
block|}
block|}
end_function

begin_function
name|uint64_t
name|cpu_tickrate
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|cpu_ticks
operator|==
name|tc_cpu_ticks
condition|)
return|return
operator|(
name|tc_getfrequency
argument_list|()
operator|)
return|;
return|return
operator|(
name|cpu_tick_frequency
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * We need to be slightly careful converting cputicks to microseconds.  * There is plenty of margin in 64 bits of microseconds (half a million  * years) and in 64 bits at 4 GHz (146 years), but if we do a multiply  * before divide conversion (to retain precision) we find that the  * margin shrinks to 1.5 hours (one millionth of 146y).  * With a three prong approach we never lose significant bits, no  * matter what the cputick rate and length of timeinterval is.  */
end_comment

begin_function
name|uint64_t
name|cputick2usec
parameter_list|(
name|uint64_t
name|tick
parameter_list|)
block|{
if|if
condition|(
name|tick
operator|>
literal|18446744073709551LL
condition|)
comment|/* floor(2^64 / 1000) */
return|return
operator|(
name|tick
operator|/
operator|(
name|cpu_tickrate
argument_list|()
operator|/
literal|1000000LL
operator|)
operator|)
return|;
elseif|else
if|if
condition|(
name|tick
operator|>
literal|18446744073709LL
condition|)
comment|/* floor(2^64 / 1000000) */
return|return
operator|(
operator|(
name|tick
operator|*
literal|1000LL
operator|)
operator|/
operator|(
name|cpu_tickrate
argument_list|()
operator|/
literal|1000LL
operator|)
operator|)
return|;
else|else
return|return
operator|(
operator|(
name|tick
operator|*
literal|1000000LL
operator|)
operator|/
name|cpu_tickrate
argument_list|()
operator|)
return|;
block|}
end_function

begin_decl_stmt
name|cpu_tick_f
modifier|*
name|cpu_ticks
init|=
name|tc_cpu_ticks
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|vdso_th_enable
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|sysctl_fast_gettime
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|int
name|old_vdso_th_enable
decl_stmt|,
name|error
decl_stmt|;
name|old_vdso_th_enable
operator|=
name|vdso_th_enable
expr_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|old_vdso_th_enable
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|vdso_th_enable
operator|=
name|old_vdso_th_enable
expr_stmt|;
name|timekeep_push_vdso
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|SYSCTL_PROC
argument_list|(
name|_kern_timecounter
argument_list|,
name|OID_AUTO
argument_list|,
name|fast_gettime
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
operator||
name|CTLFLAG_MPSAFE
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|sysctl_fast_gettime
argument_list|,
literal|"I"
argument_list|,
literal|"Enable fast time of day"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
name|uint32_t
name|tc_fill_vdso_timehands
parameter_list|(
name|struct
name|vdso_timehands
modifier|*
name|vdso_th
parameter_list|)
block|{
name|struct
name|timehands
modifier|*
name|th
decl_stmt|;
name|uint32_t
name|enabled
decl_stmt|;
name|th
operator|=
name|timehands
expr_stmt|;
name|vdso_th
operator|->
name|th_algo
operator|=
name|VDSO_TH_ALGO_1
expr_stmt|;
name|vdso_th
operator|->
name|th_scale
operator|=
name|th
operator|->
name|th_scale
expr_stmt|;
name|vdso_th
operator|->
name|th_offset_count
operator|=
name|th
operator|->
name|th_offset_count
expr_stmt|;
name|vdso_th
operator|->
name|th_counter_mask
operator|=
name|th
operator|->
name|th_counter
operator|->
name|tc_counter_mask
expr_stmt|;
name|vdso_th
operator|->
name|th_offset
operator|=
name|th
operator|->
name|th_offset
expr_stmt|;
name|vdso_th
operator|->
name|th_boottime
operator|=
name|boottimebin
expr_stmt|;
name|enabled
operator|=
name|cpu_fill_vdso_timehands
argument_list|(
name|vdso_th
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|vdso_th_enable
condition|)
name|enabled
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|enabled
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|COMPAT_FREEBSD32
end_ifdef

begin_function
name|uint32_t
name|tc_fill_vdso_timehands32
parameter_list|(
name|struct
name|vdso_timehands32
modifier|*
name|vdso_th32
parameter_list|)
block|{
name|struct
name|timehands
modifier|*
name|th
decl_stmt|;
name|uint32_t
name|enabled
decl_stmt|;
name|th
operator|=
name|timehands
expr_stmt|;
name|vdso_th32
operator|->
name|th_algo
operator|=
name|VDSO_TH_ALGO_1
expr_stmt|;
operator|*
operator|(
name|uint64_t
operator|*
operator|)
operator|&
name|vdso_th32
operator|->
name|th_scale
index|[
literal|0
index|]
operator|=
name|th
operator|->
name|th_scale
expr_stmt|;
name|vdso_th32
operator|->
name|th_offset_count
operator|=
name|th
operator|->
name|th_offset_count
expr_stmt|;
name|vdso_th32
operator|->
name|th_counter_mask
operator|=
name|th
operator|->
name|th_counter
operator|->
name|tc_counter_mask
expr_stmt|;
name|vdso_th32
operator|->
name|th_offset
operator|.
name|sec
operator|=
name|th
operator|->
name|th_offset
operator|.
name|sec
expr_stmt|;
operator|*
operator|(
name|uint64_t
operator|*
operator|)
operator|&
name|vdso_th32
operator|->
name|th_offset
operator|.
name|frac
index|[
literal|0
index|]
operator|=
name|th
operator|->
name|th_offset
operator|.
name|frac
expr_stmt|;
name|vdso_th32
operator|->
name|th_boottime
operator|.
name|sec
operator|=
name|boottimebin
operator|.
name|sec
expr_stmt|;
operator|*
operator|(
name|uint64_t
operator|*
operator|)
operator|&
name|vdso_th32
operator|->
name|th_boottime
operator|.
name|frac
index|[
literal|0
index|]
operator|=
name|boottimebin
operator|.
name|frac
expr_stmt|;
name|enabled
operator|=
name|cpu_fill_vdso_timehands32
argument_list|(
name|vdso_th32
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|vdso_th_enable
condition|)
name|enabled
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|enabled
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

