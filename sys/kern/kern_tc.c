begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * ----------------------------------------------------------------------------  * "THE BEER-WARE LICENSE" (Revision 42):  *<phk@FreeBSD.ORG> wrote this file.  As long as you retain this notice you  * can do whatever you want with this stuff. If we meet some day, and you think  * this stuff is worth it, you can buy me a beer in return.   Poul-Henning Kamp  * ----------------------------------------------------------------------------  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|"opt_ntp.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/timetc.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/timex.h>
end_include

begin_include
include|#
directive|include
file|<sys/timepps.h>
end_include

begin_comment
comment|/*  * Number of timecounters used to implement stable storage  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|NTIMECOUNTER
end_ifndef

begin_define
define|#
directive|define
name|NTIMECOUNTER
value|hz
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_expr_stmt
specifier|static
name|MALLOC_DEFINE
argument_list|(
name|M_TIMECOUNTER
argument_list|,
literal|"timecounter"
argument_list|,
literal|"Timecounter stable storage"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|time_t
name|time_second
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|bintime
name|boottimebin
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|timeval
name|boottime
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_STRUCT
argument_list|(
name|_kern
argument_list|,
name|KERN_BOOTTIME
argument_list|,
name|boottime
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|boottime
argument_list|,
name|timeval
argument_list|,
literal|"System boottime"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_kern
argument_list|,
name|OID_AUTO
argument_list|,
name|timecounter
argument_list|,
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|TC_STATS
parameter_list|(
name|foo
parameter_list|)
define|\
value|static unsigned foo; \ 	SYSCTL_INT(_kern_timecounter, OID_AUTO, foo, CTLFLAG_RD,& foo, 0, "")
end_define

begin_expr_stmt
name|TC_STATS
argument_list|(
name|nbinuptime
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|TC_STATS
argument_list|(
name|nnanouptime
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|TC_STATS
argument_list|(
name|nmicrouptime
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|TC_STATS
argument_list|(
name|nbintime
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|TC_STATS
argument_list|(
name|nnanotime
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|TC_STATS
argument_list|(
name|nmicrotime
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|TC_STATS
argument_list|(
name|ngetbinuptime
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|TC_STATS
argument_list|(
name|ngetnanouptime
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|TC_STATS
argument_list|(
name|ngetmicrouptime
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|TC_STATS
argument_list|(
name|ngetbintime
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|TC_STATS
argument_list|(
name|ngetnanotime
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|TC_STATS
argument_list|(
name|ngetmicrotime
argument_list|)
expr_stmt|;
end_expr_stmt

begin_undef
undef|#
directive|undef
name|TC_STATS
end_undef

begin_comment
comment|/*  * Implement a dummy timecounter which we can use until we get a real one  * in the air.  This allows the console and other early stuff to use  * timeservices.  */
end_comment

begin_function
specifier|static
name|unsigned
name|dummy_get_timecount
parameter_list|(
name|struct
name|timecounter
modifier|*
name|tc
parameter_list|)
block|{
specifier|static
name|unsigned
name|now
decl_stmt|;
if|if
condition|(
name|tc
operator|->
name|tc_generation
operator|==
literal|0
condition|)
name|tc
operator|->
name|tc_generation
operator|=
literal|1
expr_stmt|;
return|return
operator|(
operator|++
name|now
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|timecounter
name|dummy_timecounter
init|=
block|{
name|dummy_get_timecount
block|,
literal|0
block|,
operator|~
literal|0u
block|,
literal|1000000
block|,
literal|"dummy"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|timecounter
modifier|*
specifier|volatile
name|timecounter
init|=
operator|&
name|dummy_timecounter
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|__inline
name|unsigned
name|tc_delta
parameter_list|(
name|struct
name|timecounter
modifier|*
name|tc
parameter_list|)
block|{
return|return
operator|(
operator|(
name|tc
operator|->
name|tc_get_timecount
argument_list|(
name|tc
argument_list|)
operator|-
name|tc
operator|->
name|tc_offset_count
operator|)
operator|&
name|tc
operator|->
name|tc_counter_mask
operator|)
return|;
block|}
end_function

begin_function
name|void
name|binuptime
parameter_list|(
name|struct
name|bintime
modifier|*
name|bt
parameter_list|)
block|{
name|struct
name|timecounter
modifier|*
name|tc
decl_stmt|;
name|unsigned
name|gen
decl_stmt|;
name|nbinuptime
operator|++
expr_stmt|;
do|do
block|{
name|tc
operator|=
name|timecounter
expr_stmt|;
name|gen
operator|=
name|tc
operator|->
name|tc_generation
expr_stmt|;
operator|*
name|bt
operator|=
name|tc
operator|->
name|tc_offset
expr_stmt|;
name|bintime_addx
argument_list|(
name|bt
argument_list|,
name|tc
operator|->
name|tc_scale
operator|*
name|tc_delta
argument_list|(
name|tc
argument_list|)
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|gen
operator|==
literal|0
operator|||
name|gen
operator|!=
name|tc
operator|->
name|tc_generation
condition|)
do|;
block|}
end_function

begin_function
name|void
name|nanouptime
parameter_list|(
name|struct
name|timespec
modifier|*
name|ts
parameter_list|)
block|{
name|struct
name|bintime
name|bt
decl_stmt|;
name|nnanouptime
operator|++
expr_stmt|;
name|binuptime
argument_list|(
operator|&
name|bt
argument_list|)
expr_stmt|;
name|bintime2timespec
argument_list|(
operator|&
name|bt
argument_list|,
name|ts
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|microuptime
parameter_list|(
name|struct
name|timeval
modifier|*
name|tv
parameter_list|)
block|{
name|struct
name|bintime
name|bt
decl_stmt|;
name|nmicrouptime
operator|++
expr_stmt|;
name|binuptime
argument_list|(
operator|&
name|bt
argument_list|)
expr_stmt|;
name|bintime2timeval
argument_list|(
operator|&
name|bt
argument_list|,
name|tv
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|bintime
parameter_list|(
name|struct
name|bintime
modifier|*
name|bt
parameter_list|)
block|{
name|nbintime
operator|++
expr_stmt|;
name|binuptime
argument_list|(
name|bt
argument_list|)
expr_stmt|;
name|bintime_add
argument_list|(
name|bt
argument_list|,
operator|&
name|boottimebin
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|nanotime
parameter_list|(
name|struct
name|timespec
modifier|*
name|ts
parameter_list|)
block|{
name|struct
name|bintime
name|bt
decl_stmt|;
name|nnanotime
operator|++
expr_stmt|;
name|bintime
argument_list|(
operator|&
name|bt
argument_list|)
expr_stmt|;
name|bintime2timespec
argument_list|(
operator|&
name|bt
argument_list|,
name|ts
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|microtime
parameter_list|(
name|struct
name|timeval
modifier|*
name|tv
parameter_list|)
block|{
name|struct
name|bintime
name|bt
decl_stmt|;
name|nmicrotime
operator|++
expr_stmt|;
name|bintime
argument_list|(
operator|&
name|bt
argument_list|)
expr_stmt|;
name|bintime2timeval
argument_list|(
operator|&
name|bt
argument_list|,
name|tv
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|getbinuptime
parameter_list|(
name|struct
name|bintime
modifier|*
name|bt
parameter_list|)
block|{
name|struct
name|timecounter
modifier|*
name|tc
decl_stmt|;
name|unsigned
name|gen
decl_stmt|;
name|ngetbinuptime
operator|++
expr_stmt|;
do|do
block|{
name|tc
operator|=
name|timecounter
expr_stmt|;
name|gen
operator|=
name|tc
operator|->
name|tc_generation
expr_stmt|;
operator|*
name|bt
operator|=
name|tc
operator|->
name|tc_offset
expr_stmt|;
block|}
do|while
condition|(
name|gen
operator|==
literal|0
operator|||
name|gen
operator|!=
name|tc
operator|->
name|tc_generation
condition|)
do|;
block|}
end_function

begin_function
name|void
name|getnanouptime
parameter_list|(
name|struct
name|timespec
modifier|*
name|tsp
parameter_list|)
block|{
name|struct
name|timecounter
modifier|*
name|tc
decl_stmt|;
name|unsigned
name|gen
decl_stmt|;
name|ngetnanouptime
operator|++
expr_stmt|;
do|do
block|{
name|tc
operator|=
name|timecounter
expr_stmt|;
name|gen
operator|=
name|tc
operator|->
name|tc_generation
expr_stmt|;
name|bintime2timespec
argument_list|(
operator|&
name|tc
operator|->
name|tc_offset
argument_list|,
name|tsp
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|gen
operator|==
literal|0
operator|||
name|gen
operator|!=
name|tc
operator|->
name|tc_generation
condition|)
do|;
block|}
end_function

begin_function
name|void
name|getmicrouptime
parameter_list|(
name|struct
name|timeval
modifier|*
name|tvp
parameter_list|)
block|{
name|struct
name|timecounter
modifier|*
name|tc
decl_stmt|;
name|unsigned
name|gen
decl_stmt|;
name|ngetmicrouptime
operator|++
expr_stmt|;
do|do
block|{
name|tc
operator|=
name|timecounter
expr_stmt|;
name|gen
operator|=
name|tc
operator|->
name|tc_generation
expr_stmt|;
name|bintime2timeval
argument_list|(
operator|&
name|tc
operator|->
name|tc_offset
argument_list|,
name|tvp
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|gen
operator|==
literal|0
operator|||
name|gen
operator|!=
name|tc
operator|->
name|tc_generation
condition|)
do|;
block|}
end_function

begin_function
name|void
name|getbintime
parameter_list|(
name|struct
name|bintime
modifier|*
name|bt
parameter_list|)
block|{
name|struct
name|timecounter
modifier|*
name|tc
decl_stmt|;
name|unsigned
name|gen
decl_stmt|;
name|ngetbintime
operator|++
expr_stmt|;
do|do
block|{
name|tc
operator|=
name|timecounter
expr_stmt|;
name|gen
operator|=
name|tc
operator|->
name|tc_generation
expr_stmt|;
operator|*
name|bt
operator|=
name|tc
operator|->
name|tc_offset
expr_stmt|;
block|}
do|while
condition|(
name|gen
operator|==
literal|0
operator|||
name|gen
operator|!=
name|tc
operator|->
name|tc_generation
condition|)
do|;
name|bintime_add
argument_list|(
name|bt
argument_list|,
operator|&
name|boottimebin
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|getnanotime
parameter_list|(
name|struct
name|timespec
modifier|*
name|tsp
parameter_list|)
block|{
name|struct
name|timecounter
modifier|*
name|tc
decl_stmt|;
name|unsigned
name|gen
decl_stmt|;
name|ngetnanotime
operator|++
expr_stmt|;
do|do
block|{
name|tc
operator|=
name|timecounter
expr_stmt|;
name|gen
operator|=
name|tc
operator|->
name|tc_generation
expr_stmt|;
operator|*
name|tsp
operator|=
name|tc
operator|->
name|tc_nanotime
expr_stmt|;
block|}
do|while
condition|(
name|gen
operator|==
literal|0
operator|||
name|gen
operator|!=
name|tc
operator|->
name|tc_generation
condition|)
do|;
block|}
end_function

begin_function
name|void
name|getmicrotime
parameter_list|(
name|struct
name|timeval
modifier|*
name|tvp
parameter_list|)
block|{
name|struct
name|timecounter
modifier|*
name|tc
decl_stmt|;
name|unsigned
name|gen
decl_stmt|;
name|ngetmicrotime
operator|++
expr_stmt|;
do|do
block|{
name|tc
operator|=
name|timecounter
expr_stmt|;
name|gen
operator|=
name|tc
operator|->
name|tc_generation
expr_stmt|;
operator|*
name|tvp
operator|=
name|tc
operator|->
name|tc_microtime
expr_stmt|;
block|}
do|while
condition|(
name|gen
operator|==
literal|0
operator|||
name|gen
operator|!=
name|tc
operator|->
name|tc_generation
condition|)
do|;
block|}
end_function

begin_function
specifier|static
name|void
name|tc_setscales
parameter_list|(
name|struct
name|timecounter
modifier|*
name|tc
parameter_list|)
block|{
name|u_int64_t
name|scale
decl_stmt|;
comment|/* Sacrifice the lower bit to the deity for code clarity */
name|scale
operator|=
literal|1ULL
operator|<<
literal|63
expr_stmt|;
comment|/*  	 * We get nanoseconds with 32 bit binary fraction and want 	 * 64 bit binary fraction: x = a * 2^32 / 10^9 = a * 4.294967296 	 * The range is +/- 5000PPM so we can only multiply by about 850 	 * without overflowing.  The best suitable fraction is 2199/512. 	 * Divide by 2 times 512 to match the temporary lower precision. 	 */
name|scale
operator|+=
operator|(
name|tc
operator|->
name|tc_adjustment
operator|/
literal|1024
operator|)
operator|*
literal|2199
expr_stmt|;
name|scale
operator|/=
name|tc
operator|->
name|tc_tweak
operator|->
name|tc_frequency
expr_stmt|;
name|tc
operator|->
name|tc_scale
operator|=
name|scale
operator|*
literal|2
expr_stmt|;
block|}
end_function

begin_function
name|void
name|tc_init
parameter_list|(
name|struct
name|timecounter
modifier|*
name|tc
parameter_list|)
block|{
name|struct
name|timecounter
modifier|*
name|t1
decl_stmt|,
modifier|*
name|t2
decl_stmt|,
modifier|*
name|t3
decl_stmt|;
name|int
name|i
decl_stmt|;
name|tc
operator|->
name|tc_adjustment
operator|=
literal|0
expr_stmt|;
name|tc
operator|->
name|tc_tweak
operator|=
name|tc
expr_stmt|;
name|tc_setscales
argument_list|(
name|tc
argument_list|)
expr_stmt|;
name|tc
operator|->
name|tc_offset_count
operator|=
name|tc
operator|->
name|tc_get_timecount
argument_list|(
name|tc
argument_list|)
expr_stmt|;
if|if
condition|(
name|timecounter
operator|==
operator|&
name|dummy_timecounter
condition|)
name|tc
operator|->
name|tc_avail
operator|=
name|tc
expr_stmt|;
else|else
block|{
name|tc
operator|->
name|tc_avail
operator|=
name|timecounter
operator|->
name|tc_tweak
operator|->
name|tc_avail
expr_stmt|;
name|timecounter
operator|->
name|tc_tweak
operator|->
name|tc_avail
operator|=
name|tc
expr_stmt|;
block|}
name|MALLOC
argument_list|(
name|t1
argument_list|,
expr|struct
name|timecounter
operator|*
argument_list|,
sizeof|sizeof
expr|*
name|t1
argument_list|,
name|M_TIMECOUNTER
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|tc
operator|->
name|tc_next
operator|=
name|t1
expr_stmt|;
operator|*
name|t1
operator|=
operator|*
name|tc
expr_stmt|;
name|t2
operator|=
name|t1
expr_stmt|;
name|t3
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|NTIMECOUNTER
condition|;
name|i
operator|++
control|)
block|{
name|MALLOC
argument_list|(
name|t3
argument_list|,
expr|struct
name|timecounter
operator|*
argument_list|,
sizeof|sizeof
expr|*
name|t3
argument_list|,
name|M_TIMECOUNTER
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
operator|*
name|t3
operator|=
operator|*
name|tc
expr_stmt|;
name|t3
operator|->
name|tc_next
operator|=
name|t2
expr_stmt|;
name|t2
operator|=
name|t3
expr_stmt|;
block|}
name|t1
operator|->
name|tc_next
operator|=
name|t3
expr_stmt|;
name|tc
operator|=
name|t1
expr_stmt|;
name|printf
argument_list|(
literal|"Timecounter \"%s\"  frequency %lu Hz\n"
argument_list|,
name|tc
operator|->
name|tc_name
argument_list|,
operator|(
name|u_long
operator|)
name|tc
operator|->
name|tc_frequency
argument_list|)
expr_stmt|;
comment|/* XXX: For now always start using the counter. */
name|tc
operator|->
name|tc_offset_count
operator|=
name|tc
operator|->
name|tc_get_timecount
argument_list|(
name|tc
argument_list|)
expr_stmt|;
name|binuptime
argument_list|(
operator|&
name|tc
operator|->
name|tc_offset
argument_list|)
expr_stmt|;
name|timecounter
operator|=
name|tc
expr_stmt|;
name|tc_windup
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|tc_setclock
parameter_list|(
name|struct
name|timespec
modifier|*
name|ts
parameter_list|)
block|{
name|struct
name|timespec
name|ts2
decl_stmt|;
name|nanouptime
argument_list|(
operator|&
name|ts2
argument_list|)
expr_stmt|;
name|boottime
operator|.
name|tv_sec
operator|=
name|ts
operator|->
name|tv_sec
operator|-
name|ts2
operator|.
name|tv_sec
expr_stmt|;
name|boottime
operator|.
name|tv_usec
operator|=
operator|(
name|ts
operator|->
name|tv_nsec
operator|-
name|ts2
operator|.
name|tv_nsec
operator|)
operator|/
literal|1000
expr_stmt|;
if|if
condition|(
name|boottime
operator|.
name|tv_usec
operator|<
literal|0
condition|)
block|{
name|boottime
operator|.
name|tv_usec
operator|+=
literal|1000000
expr_stmt|;
name|boottime
operator|.
name|tv_sec
operator|--
expr_stmt|;
block|}
name|timeval2bintime
argument_list|(
operator|&
name|boottime
argument_list|,
operator|&
name|boottimebin
argument_list|)
expr_stmt|;
comment|/* fiddle all the little crinkly bits around the fiords... */
name|tc_windup
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|switch_timecounter
parameter_list|(
name|struct
name|timecounter
modifier|*
name|newtc
parameter_list|)
block|{
name|int
name|s
decl_stmt|;
name|struct
name|timecounter
modifier|*
name|tc
decl_stmt|;
name|s
operator|=
name|splclock
argument_list|()
expr_stmt|;
name|tc
operator|=
name|timecounter
expr_stmt|;
if|if
condition|(
name|newtc
operator|->
name|tc_tweak
operator|==
name|tc
operator|->
name|tc_tweak
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
name|newtc
operator|=
name|newtc
operator|->
name|tc_tweak
operator|->
name|tc_next
expr_stmt|;
name|binuptime
argument_list|(
operator|&
name|newtc
operator|->
name|tc_offset
argument_list|)
expr_stmt|;
name|newtc
operator|->
name|tc_offset_count
operator|=
name|newtc
operator|->
name|tc_get_timecount
argument_list|(
name|newtc
argument_list|)
expr_stmt|;
name|tc_setscales
argument_list|(
name|newtc
argument_list|)
expr_stmt|;
name|newtc
operator|->
name|tc_generation
operator|=
literal|0
expr_stmt|;
name|timecounter
operator|=
name|newtc
expr_stmt|;
name|tc_windup
argument_list|()
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|tc_windup
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|timecounter
modifier|*
name|tc
decl_stmt|,
modifier|*
name|tco
decl_stmt|;
name|struct
name|bintime
name|bt
decl_stmt|;
name|unsigned
name|ogen
decl_stmt|,
name|delta
decl_stmt|;
name|int
name|i
decl_stmt|;
name|tco
operator|=
name|timecounter
expr_stmt|;
name|tc
operator|=
name|tco
operator|->
name|tc_next
expr_stmt|;
name|ogen
operator|=
name|tc
operator|->
name|tc_generation
expr_stmt|;
name|tc
operator|->
name|tc_generation
operator|=
literal|0
expr_stmt|;
name|bcopy
argument_list|(
name|tco
argument_list|,
name|tc
argument_list|,
name|__offsetof
argument_list|(
expr|struct
name|timecounter
argument_list|,
name|tc_generation
argument_list|)
argument_list|)
expr_stmt|;
name|delta
operator|=
name|tc_delta
argument_list|(
name|tc
argument_list|)
expr_stmt|;
name|tc
operator|->
name|tc_offset_count
operator|+=
name|delta
expr_stmt|;
name|tc
operator|->
name|tc_offset_count
operator|&=
name|tc
operator|->
name|tc_counter_mask
expr_stmt|;
name|bintime_addx
argument_list|(
operator|&
name|tc
operator|->
name|tc_offset
argument_list|,
name|tc
operator|->
name|tc_scale
operator|*
name|delta
argument_list|)
expr_stmt|;
comment|/* 	 * We may be inducing a tiny error here, the tc_poll_pps() may 	 * process a latched count which happens after the tc_delta() 	 * in sync_other_counter(), which would extend the previous 	 * counters parameters into the domain of this new one. 	 * Since the timewindow is very small for this, the error is 	 * going to be only a few weenieseconds (as Dave Mills would 	 * say), so lets just not talk more about it, OK ? 	 */
if|if
condition|(
name|tco
operator|->
name|tc_poll_pps
condition|)
name|tco
operator|->
name|tc_poll_pps
argument_list|(
name|tco
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|tc
operator|->
name|tc_offset
operator|.
name|sec
operator|-
name|tco
operator|->
name|tc_offset
operator|.
name|sec
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|ntp_update_second
argument_list|(
name|tc
argument_list|)
expr_stmt|;
comment|/* XXX only needed if xntpd runs */
name|tc_setscales
argument_list|(
name|tc
argument_list|)
expr_stmt|;
block|}
name|bt
operator|=
name|tc
operator|->
name|tc_offset
expr_stmt|;
name|bintime_add
argument_list|(
operator|&
name|bt
argument_list|,
operator|&
name|boottimebin
argument_list|)
expr_stmt|;
name|bintime2timeval
argument_list|(
operator|&
name|bt
argument_list|,
operator|&
name|tc
operator|->
name|tc_microtime
argument_list|)
expr_stmt|;
name|bintime2timespec
argument_list|(
operator|&
name|bt
argument_list|,
operator|&
name|tc
operator|->
name|tc_nanotime
argument_list|)
expr_stmt|;
name|ogen
operator|++
expr_stmt|;
if|if
condition|(
name|ogen
operator|==
literal|0
condition|)
name|ogen
operator|++
expr_stmt|;
name|tc
operator|->
name|tc_generation
operator|=
name|ogen
expr_stmt|;
name|time_second
operator|=
name|tc
operator|->
name|tc_microtime
operator|.
name|tv_sec
expr_stmt|;
name|timecounter
operator|=
name|tc
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|sysctl_kern_timecounter_hardware
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|char
name|newname
index|[
literal|32
index|]
decl_stmt|;
name|struct
name|timecounter
modifier|*
name|newtc
decl_stmt|,
modifier|*
name|tc
decl_stmt|;
name|int
name|error
decl_stmt|;
name|tc
operator|=
name|timecounter
operator|->
name|tc_tweak
expr_stmt|;
name|strncpy
argument_list|(
name|newname
argument_list|,
name|tc
operator|->
name|tc_name
argument_list|,
sizeof|sizeof
argument_list|(
name|newname
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|sysctl_handle_string
argument_list|(
name|oidp
argument_list|,
operator|&
name|newname
index|[
literal|0
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|newname
argument_list|)
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
operator|&&
name|req
operator|->
name|newptr
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|newname
argument_list|,
name|tc
operator|->
name|tc_name
argument_list|)
operator|!=
literal|0
condition|)
block|{
for|for
control|(
name|newtc
operator|=
name|tc
operator|->
name|tc_avail
init|;
name|newtc
operator|!=
name|tc
condition|;
name|newtc
operator|=
name|newtc
operator|->
name|tc_avail
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|newname
argument_list|,
name|newtc
operator|->
name|tc_name
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Warm up new timecounter. */
operator|(
name|void
operator|)
name|newtc
operator|->
name|tc_get_timecount
argument_list|(
name|newtc
argument_list|)
expr_stmt|;
name|switch_timecounter
argument_list|(
name|newtc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|SYSCTL_PROC
argument_list|(
name|_kern_timecounter
argument_list|,
name|OID_AUTO
argument_list|,
name|hardware
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|sysctl_kern_timecounter_hardware
argument_list|,
literal|"A"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
name|int
name|pps_ioctl
parameter_list|(
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|data
parameter_list|,
name|struct
name|pps_state
modifier|*
name|pps
parameter_list|)
block|{
name|pps_params_t
modifier|*
name|app
decl_stmt|;
name|struct
name|pps_fetch_args
modifier|*
name|fapi
decl_stmt|;
ifdef|#
directive|ifdef
name|PPS_SYNC
name|struct
name|pps_kcbind_args
modifier|*
name|kapi
decl_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|PPS_IOC_CREATE
case|:
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|PPS_IOC_DESTROY
case|:
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|PPS_IOC_SETPARAMS
case|:
name|app
operator|=
operator|(
name|pps_params_t
operator|*
operator|)
name|data
expr_stmt|;
if|if
condition|(
name|app
operator|->
name|mode
operator|&
operator|~
name|pps
operator|->
name|ppscap
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|pps
operator|->
name|ppsparam
operator|=
operator|*
name|app
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|PPS_IOC_GETPARAMS
case|:
name|app
operator|=
operator|(
name|pps_params_t
operator|*
operator|)
name|data
expr_stmt|;
operator|*
name|app
operator|=
name|pps
operator|->
name|ppsparam
expr_stmt|;
name|app
operator|->
name|api_version
operator|=
name|PPS_API_VERS_1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|PPS_IOC_GETCAP
case|:
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|pps
operator|->
name|ppscap
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|PPS_IOC_FETCH
case|:
name|fapi
operator|=
operator|(
expr|struct
name|pps_fetch_args
operator|*
operator|)
name|data
expr_stmt|;
if|if
condition|(
name|fapi
operator|->
name|tsformat
operator|&&
name|fapi
operator|->
name|tsformat
operator|!=
name|PPS_TSFMT_TSPEC
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|fapi
operator|->
name|timeout
operator|.
name|tv_sec
operator|||
name|fapi
operator|->
name|timeout
operator|.
name|tv_nsec
condition|)
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
name|pps
operator|->
name|ppsinfo
operator|.
name|current_mode
operator|=
name|pps
operator|->
name|ppsparam
operator|.
name|mode
expr_stmt|;
name|fapi
operator|->
name|pps_info_buf
operator|=
name|pps
operator|->
name|ppsinfo
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|PPS_IOC_KCBIND
case|:
ifdef|#
directive|ifdef
name|PPS_SYNC
name|kapi
operator|=
operator|(
expr|struct
name|pps_kcbind_args
operator|*
operator|)
name|data
expr_stmt|;
comment|/* XXX Only root should be able to do this */
if|if
condition|(
name|kapi
operator|->
name|tsformat
operator|&&
name|kapi
operator|->
name|tsformat
operator|!=
name|PPS_TSFMT_TSPEC
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|kapi
operator|->
name|kernel_consumer
operator|!=
name|PPS_KC_HARDPPS
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|kapi
operator|->
name|edge
operator|&
operator|~
name|pps
operator|->
name|ppscap
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|pps
operator|->
name|kcmode
operator|=
name|kapi
operator|->
name|edge
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
else|#
directive|else
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
endif|#
directive|endif
default|default:
return|return
operator|(
name|ENOTTY
operator|)
return|;
block|}
block|}
end_function

begin_function
name|void
name|pps_init
parameter_list|(
name|struct
name|pps_state
modifier|*
name|pps
parameter_list|)
block|{
name|pps
operator|->
name|ppscap
operator||=
name|PPS_TSFMT_TSPEC
expr_stmt|;
if|if
condition|(
name|pps
operator|->
name|ppscap
operator|&
name|PPS_CAPTUREASSERT
condition|)
name|pps
operator|->
name|ppscap
operator||=
name|PPS_OFFSETASSERT
expr_stmt|;
if|if
condition|(
name|pps
operator|->
name|ppscap
operator|&
name|PPS_CAPTURECLEAR
condition|)
name|pps
operator|->
name|ppscap
operator||=
name|PPS_OFFSETCLEAR
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pps_event
parameter_list|(
name|struct
name|pps_state
modifier|*
name|pps
parameter_list|,
name|struct
name|timecounter
modifier|*
name|tc
parameter_list|,
name|unsigned
name|count
parameter_list|,
name|int
name|event
parameter_list|)
block|{
name|struct
name|timespec
name|ts
decl_stmt|,
modifier|*
name|tsp
decl_stmt|,
modifier|*
name|osp
decl_stmt|;
name|unsigned
name|tcount
decl_stmt|,
modifier|*
name|pcount
decl_stmt|;
name|struct
name|bintime
name|bt
decl_stmt|;
name|int
name|foff
decl_stmt|,
name|fhard
decl_stmt|;
name|pps_seq_t
modifier|*
name|pseq
decl_stmt|;
comment|/* Things would be easier with arrays... */
if|if
condition|(
name|event
operator|==
name|PPS_CAPTUREASSERT
condition|)
block|{
name|tsp
operator|=
operator|&
name|pps
operator|->
name|ppsinfo
operator|.
name|assert_timestamp
expr_stmt|;
name|osp
operator|=
operator|&
name|pps
operator|->
name|ppsparam
operator|.
name|assert_offset
expr_stmt|;
name|foff
operator|=
name|pps
operator|->
name|ppsparam
operator|.
name|mode
operator|&
name|PPS_OFFSETASSERT
expr_stmt|;
name|fhard
operator|=
name|pps
operator|->
name|kcmode
operator|&
name|PPS_CAPTUREASSERT
expr_stmt|;
name|pcount
operator|=
operator|&
name|pps
operator|->
name|ppscount
index|[
literal|0
index|]
expr_stmt|;
name|pseq
operator|=
operator|&
name|pps
operator|->
name|ppsinfo
operator|.
name|assert_sequence
expr_stmt|;
block|}
else|else
block|{
name|tsp
operator|=
operator|&
name|pps
operator|->
name|ppsinfo
operator|.
name|clear_timestamp
expr_stmt|;
name|osp
operator|=
operator|&
name|pps
operator|->
name|ppsparam
operator|.
name|clear_offset
expr_stmt|;
name|foff
operator|=
name|pps
operator|->
name|ppsparam
operator|.
name|mode
operator|&
name|PPS_OFFSETCLEAR
expr_stmt|;
name|fhard
operator|=
name|pps
operator|->
name|kcmode
operator|&
name|PPS_CAPTURECLEAR
expr_stmt|;
name|pcount
operator|=
operator|&
name|pps
operator|->
name|ppscount
index|[
literal|1
index|]
expr_stmt|;
name|pseq
operator|=
operator|&
name|pps
operator|->
name|ppsinfo
operator|.
name|clear_sequence
expr_stmt|;
block|}
comment|/* The timecounter changed: bail */
if|if
condition|(
operator|!
name|pps
operator|->
name|ppstc
operator|||
name|pps
operator|->
name|ppstc
operator|->
name|tc_name
operator|!=
name|tc
operator|->
name|tc_name
operator|||
name|tc
operator|->
name|tc_name
operator|!=
name|timecounter
operator|->
name|tc_name
condition|)
block|{
name|pps
operator|->
name|ppstc
operator|=
name|tc
expr_stmt|;
operator|*
name|pcount
operator|=
name|count
expr_stmt|;
return|return;
block|}
comment|/* Nothing really happened */
if|if
condition|(
operator|*
name|pcount
operator|==
name|count
condition|)
return|return;
operator|*
name|pcount
operator|=
name|count
expr_stmt|;
comment|/* Convert the count to timespec */
name|tcount
operator|=
name|count
operator|-
name|tc
operator|->
name|tc_offset_count
expr_stmt|;
name|tcount
operator|&=
name|tc
operator|->
name|tc_counter_mask
expr_stmt|;
name|bt
operator|=
name|tc
operator|->
name|tc_offset
expr_stmt|;
name|bintime_addx
argument_list|(
operator|&
name|bt
argument_list|,
name|tc
operator|->
name|tc_scale
operator|*
name|tcount
argument_list|)
expr_stmt|;
name|bintime2timespec
argument_list|(
operator|&
name|bt
argument_list|,
operator|&
name|ts
argument_list|)
expr_stmt|;
operator|(
operator|*
name|pseq
operator|)
operator|++
expr_stmt|;
operator|*
name|tsp
operator|=
name|ts
expr_stmt|;
if|if
condition|(
name|foff
condition|)
block|{
name|timespecadd
argument_list|(
name|tsp
argument_list|,
name|osp
argument_list|)
expr_stmt|;
if|if
condition|(
name|tsp
operator|->
name|tv_nsec
operator|<
literal|0
condition|)
block|{
name|tsp
operator|->
name|tv_nsec
operator|+=
literal|1000000000
expr_stmt|;
name|tsp
operator|->
name|tv_sec
operator|-=
literal|1
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|PPS_SYNC
if|if
condition|(
name|fhard
condition|)
block|{
comment|/* magic, at its best... */
name|tcount
operator|=
name|count
operator|-
name|pps
operator|->
name|ppscount
index|[
literal|2
index|]
expr_stmt|;
name|pps
operator|->
name|ppscount
index|[
literal|2
index|]
operator|=
name|count
expr_stmt|;
name|tcount
operator|&=
name|tc
operator|->
name|tc_counter_mask
expr_stmt|;
name|bt
operator|.
name|sec
operator|=
literal|0
expr_stmt|;
name|bt
operator|.
name|frac
operator|=
literal|0
expr_stmt|;
name|bintime_addx
argument_list|(
operator|&
name|bt
argument_list|,
name|tc
operator|->
name|tc_scale
operator|*
name|tcount
argument_list|)
expr_stmt|;
name|bintime2timespec
argument_list|(
operator|&
name|bt
argument_list|,
operator|&
name|ts
argument_list|)
expr_stmt|;
name|hardpps
argument_list|(
name|tsp
argument_list|,
name|ts
operator|.
name|tv_nsec
operator|+
literal|1000000000
operator|*
name|ts
operator|.
name|tv_sec
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

end_unit

