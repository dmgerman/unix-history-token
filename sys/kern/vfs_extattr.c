begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1999-2001 Robert N. M. Watson  * All rights reserved.  *  * This software was developed by Robert Watson for the TrustedBSD Project.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"opt_mac.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mount.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysproto.h>
end_include

begin_include
include|#
directive|include
file|<sys/namei.h>
end_include

begin_include
include|#
directive|include
file|<sys/filedesc.h>
end_include

begin_include
include|#
directive|include
file|<sys/limits.h>
end_include

begin_include
include|#
directive|include
file|<sys/vnode.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/extattr.h>
end_include

begin_include
include|#
directive|include
file|<security/audit/audit.h>
end_include

begin_include
include|#
directive|include
file|<security/mac/mac_framework.h>
end_include

begin_comment
comment|/*  * Syscall to push extended attribute configuration information into the VFS.  * Accepts a path, which it converts to a mountpoint, as well as a command  * (int cmd), and attribute name and misc data.  *  * Currently this is used only by UFS1 extended attributes.  */
end_comment

begin_function
name|int
name|extattrctl
parameter_list|(
name|td
parameter_list|,
name|uap
parameter_list|)
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|extattrctl_args
comment|/* { 		const char *path; 		int cmd; 		const char *filename; 		int attrnamespace; 		const char *attrname; 	} */
modifier|*
name|uap
decl_stmt|;
block|{
name|struct
name|vnode
modifier|*
name|filename_vp
decl_stmt|;
name|struct
name|nameidata
name|nd
decl_stmt|;
name|struct
name|mount
modifier|*
name|mp
decl_stmt|,
modifier|*
name|mp_writable
decl_stmt|;
name|char
name|attrname
index|[
name|EXTATTR_MAXNAMELEN
index|]
decl_stmt|;
name|int
name|vfslocked
decl_stmt|,
name|fnvfslocked
decl_stmt|,
name|error
decl_stmt|;
name|AUDIT_ARG
argument_list|(
name|cmd
argument_list|,
name|uap
operator|->
name|cmd
argument_list|)
expr_stmt|;
name|AUDIT_ARG
argument_list|(
name|value
argument_list|,
name|uap
operator|->
name|attrnamespace
argument_list|)
expr_stmt|;
comment|/* 	 * uap->attrname is not always defined.  We check again later when we 	 * invoke the VFS call so as to pass in NULL there if needed. 	 */
if|if
condition|(
name|uap
operator|->
name|attrname
operator|!=
name|NULL
condition|)
block|{
name|error
operator|=
name|copyinstr
argument_list|(
name|uap
operator|->
name|attrname
argument_list|,
name|attrname
argument_list|,
name|EXTATTR_MAXNAMELEN
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
name|AUDIT_ARG
argument_list|(
name|text
argument_list|,
name|attrname
argument_list|)
expr_stmt|;
name|vfslocked
operator|=
name|fnvfslocked
operator|=
literal|0
expr_stmt|;
name|mp
operator|=
name|NULL
expr_stmt|;
name|filename_vp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|uap
operator|->
name|filename
operator|!=
name|NULL
condition|)
block|{
name|NDINIT
argument_list|(
operator|&
name|nd
argument_list|,
name|LOOKUP
argument_list|,
name|MPSAFE
operator||
name|FOLLOW
operator||
name|AUDITVNODE2
argument_list|,
name|UIO_USERSPACE
argument_list|,
name|uap
operator|->
name|filename
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|error
operator|=
name|namei
argument_list|(
operator|&
name|nd
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|fnvfslocked
operator|=
name|NDHASGIANT
argument_list|(
operator|&
name|nd
argument_list|)
expr_stmt|;
name|filename_vp
operator|=
name|nd
operator|.
name|ni_vp
expr_stmt|;
name|NDFREE
argument_list|(
operator|&
name|nd
argument_list|,
name|NDF_NO_VP_RELE
argument_list|)
expr_stmt|;
block|}
comment|/* uap->path is always defined. */
name|NDINIT
argument_list|(
operator|&
name|nd
argument_list|,
name|LOOKUP
argument_list|,
name|MPSAFE
operator||
name|FOLLOW
operator||
name|LOCKLEAF
operator||
name|AUDITVNODE1
argument_list|,
name|UIO_USERSPACE
argument_list|,
name|uap
operator|->
name|path
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|error
operator|=
name|namei
argument_list|(
operator|&
name|nd
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
name|vfslocked
operator|=
name|NDHASGIANT
argument_list|(
operator|&
name|nd
argument_list|)
expr_stmt|;
name|mp
operator|=
name|nd
operator|.
name|ni_vp
operator|->
name|v_mount
expr_stmt|;
name|error
operator|=
name|vfs_busy
argument_list|(
name|mp
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|NDFREE
argument_list|(
operator|&
name|nd
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mp
operator|=
name|NULL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|VOP_UNLOCK
argument_list|(
name|nd
operator|.
name|ni_vp
argument_list|,
literal|0
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|error
operator|=
name|vn_start_write
argument_list|(
name|nd
operator|.
name|ni_vp
argument_list|,
operator|&
name|mp_writable
argument_list|,
name|V_WAIT
operator||
name|PCATCH
argument_list|)
expr_stmt|;
name|NDFREE
argument_list|(
operator|&
name|nd
argument_list|,
name|NDF_NO_VP_UNLOCK
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|filename_vp
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * uap->filename is not always defined.  If it is, 		 * grab a vnode lock, which VFS_EXTATTRCTL() will 		 * later release. 		 */
name|error
operator|=
name|vn_lock
argument_list|(
name|filename_vp
argument_list|,
name|LK_EXCLUSIVE
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|vn_finished_write
argument_list|(
name|mp_writable
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
name|error
operator|=
name|VFS_EXTATTRCTL
argument_list|(
name|mp
argument_list|,
name|uap
operator|->
name|cmd
argument_list|,
name|filename_vp
argument_list|,
name|uap
operator|->
name|attrnamespace
argument_list|,
name|uap
operator|->
name|attrname
operator|!=
name|NULL
condition|?
name|attrname
else|:
name|NULL
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|vn_finished_write
argument_list|(
name|mp_writable
argument_list|)
expr_stmt|;
name|out
label|:
if|if
condition|(
name|mp
operator|!=
name|NULL
condition|)
name|vfs_unbusy
argument_list|(
name|mp
argument_list|,
name|td
argument_list|)
expr_stmt|;
comment|/* 	 * VFS_EXTATTRCTL will have unlocked, but not de-ref'd, filename_vp, 	 * so vrele it if it is defined. 	 */
if|if
condition|(
name|filename_vp
operator|!=
name|NULL
condition|)
name|vrele
argument_list|(
name|filename_vp
argument_list|)
expr_stmt|;
name|VFS_UNLOCK_GIANT
argument_list|(
name|fnvfslocked
argument_list|)
expr_stmt|;
name|VFS_UNLOCK_GIANT
argument_list|(
name|vfslocked
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*-  * Set a named extended attribute on a file or directory  *  * Arguments: unlocked vnode "vp", attribute namespace "attrnamespace",  *            kernelspace string pointer "attrname", userspace buffer  *            pointer "data", buffer length "nbytes", thread "td".  * Returns: 0 on success, an error number otherwise  * Locks: none  * References: vp must be a valid reference for the duration of the call  */
end_comment

begin_function
specifier|static
name|int
name|extattr_set_vp
parameter_list|(
name|struct
name|vnode
modifier|*
name|vp
parameter_list|,
name|int
name|attrnamespace
parameter_list|,
specifier|const
name|char
modifier|*
name|attrname
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|size_t
name|nbytes
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|mount
modifier|*
name|mp
decl_stmt|;
name|struct
name|uio
name|auio
decl_stmt|;
name|struct
name|iovec
name|aiov
decl_stmt|;
name|ssize_t
name|cnt
decl_stmt|;
name|int
name|error
decl_stmt|;
name|VFS_ASSERT_GIANT
argument_list|(
name|vp
operator|->
name|v_mount
argument_list|)
expr_stmt|;
name|error
operator|=
name|vn_start_write
argument_list|(
name|vp
argument_list|,
operator|&
name|mp
argument_list|,
name|V_WAIT
operator||
name|PCATCH
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|VOP_LEASE
argument_list|(
name|vp
argument_list|,
name|td
argument_list|,
name|td
operator|->
name|td_ucred
argument_list|,
name|LEASE_WRITE
argument_list|)
expr_stmt|;
name|vn_lock
argument_list|(
name|vp
argument_list|,
name|LK_EXCLUSIVE
operator||
name|LK_RETRY
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|aiov
operator|.
name|iov_base
operator|=
name|data
expr_stmt|;
name|aiov
operator|.
name|iov_len
operator|=
name|nbytes
expr_stmt|;
name|auio
operator|.
name|uio_iov
operator|=
operator|&
name|aiov
expr_stmt|;
name|auio
operator|.
name|uio_iovcnt
operator|=
literal|1
expr_stmt|;
name|auio
operator|.
name|uio_offset
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|nbytes
operator|>
name|INT_MAX
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|auio
operator|.
name|uio_resid
operator|=
name|nbytes
expr_stmt|;
name|auio
operator|.
name|uio_rw
operator|=
name|UIO_WRITE
expr_stmt|;
name|auio
operator|.
name|uio_segflg
operator|=
name|UIO_USERSPACE
expr_stmt|;
name|auio
operator|.
name|uio_td
operator|=
name|td
expr_stmt|;
name|cnt
operator|=
name|nbytes
expr_stmt|;
ifdef|#
directive|ifdef
name|MAC
name|error
operator|=
name|mac_check_vnode_setextattr
argument_list|(
name|td
operator|->
name|td_ucred
argument_list|,
name|vp
argument_list|,
name|attrnamespace
argument_list|,
name|attrname
argument_list|,
operator|&
name|auio
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|done
goto|;
endif|#
directive|endif
name|error
operator|=
name|VOP_SETEXTATTR
argument_list|(
name|vp
argument_list|,
name|attrnamespace
argument_list|,
name|attrname
argument_list|,
operator|&
name|auio
argument_list|,
name|td
operator|->
name|td_ucred
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|cnt
operator|-=
name|auio
operator|.
name|uio_resid
expr_stmt|;
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|=
name|cnt
expr_stmt|;
name|done
label|:
name|VOP_UNLOCK
argument_list|(
name|vp
argument_list|,
literal|0
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|vn_finished_write
argument_list|(
name|mp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|extattr_set_fd
parameter_list|(
name|td
parameter_list|,
name|uap
parameter_list|)
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|extattr_set_fd_args
comment|/* { 		int fd; 		int attrnamespace; 		const char *attrname; 		void *data; 		size_t nbytes; 	} */
modifier|*
name|uap
decl_stmt|;
block|{
name|struct
name|file
modifier|*
name|fp
decl_stmt|;
name|char
name|attrname
index|[
name|EXTATTR_MAXNAMELEN
index|]
decl_stmt|;
name|int
name|vfslocked
decl_stmt|,
name|error
decl_stmt|;
name|AUDIT_ARG
argument_list|(
name|fd
argument_list|,
name|uap
operator|->
name|fd
argument_list|)
expr_stmt|;
name|AUDIT_ARG
argument_list|(
name|value
argument_list|,
name|uap
operator|->
name|attrnamespace
argument_list|)
expr_stmt|;
name|error
operator|=
name|copyinstr
argument_list|(
name|uap
operator|->
name|attrname
argument_list|,
name|attrname
argument_list|,
name|EXTATTR_MAXNAMELEN
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|AUDIT_ARG
argument_list|(
name|text
argument_list|,
name|attrname
argument_list|)
expr_stmt|;
name|error
operator|=
name|getvnode
argument_list|(
name|td
operator|->
name|td_proc
operator|->
name|p_fd
argument_list|,
name|uap
operator|->
name|fd
argument_list|,
operator|&
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|vfslocked
operator|=
name|VFS_LOCK_GIANT
argument_list|(
name|fp
operator|->
name|f_vnode
operator|->
name|v_mount
argument_list|)
expr_stmt|;
name|error
operator|=
name|extattr_set_vp
argument_list|(
name|fp
operator|->
name|f_vnode
argument_list|,
name|uap
operator|->
name|attrnamespace
argument_list|,
name|attrname
argument_list|,
name|uap
operator|->
name|data
argument_list|,
name|uap
operator|->
name|nbytes
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|fdrop
argument_list|(
name|fp
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|VFS_UNLOCK_GIANT
argument_list|(
name|vfslocked
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|extattr_set_file
parameter_list|(
name|td
parameter_list|,
name|uap
parameter_list|)
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|extattr_set_file_args
comment|/* { 		const char *path; 		int attrnamespace; 		const char *attrname; 		void *data; 		size_t nbytes; 	} */
modifier|*
name|uap
decl_stmt|;
block|{
name|struct
name|nameidata
name|nd
decl_stmt|;
name|char
name|attrname
index|[
name|EXTATTR_MAXNAMELEN
index|]
decl_stmt|;
name|int
name|vfslocked
decl_stmt|,
name|error
decl_stmt|;
name|AUDIT_ARG
argument_list|(
name|value
argument_list|,
name|uap
operator|->
name|attrnamespace
argument_list|)
expr_stmt|;
name|error
operator|=
name|copyinstr
argument_list|(
name|uap
operator|->
name|attrname
argument_list|,
name|attrname
argument_list|,
name|EXTATTR_MAXNAMELEN
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|AUDIT_ARG
argument_list|(
name|text
argument_list|,
name|attrname
argument_list|)
expr_stmt|;
name|NDINIT
argument_list|(
operator|&
name|nd
argument_list|,
name|LOOKUP
argument_list|,
name|MPSAFE
operator||
name|FOLLOW
operator||
name|AUDITVNODE1
argument_list|,
name|UIO_USERSPACE
argument_list|,
name|uap
operator|->
name|path
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|error
operator|=
name|namei
argument_list|(
operator|&
name|nd
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|NDFREE
argument_list|(
operator|&
name|nd
argument_list|,
name|NDF_ONLY_PNBUF
argument_list|)
expr_stmt|;
name|vfslocked
operator|=
name|NDHASGIANT
argument_list|(
operator|&
name|nd
argument_list|)
expr_stmt|;
name|error
operator|=
name|extattr_set_vp
argument_list|(
name|nd
operator|.
name|ni_vp
argument_list|,
name|uap
operator|->
name|attrnamespace
argument_list|,
name|attrname
argument_list|,
name|uap
operator|->
name|data
argument_list|,
name|uap
operator|->
name|nbytes
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|vrele
argument_list|(
name|nd
operator|.
name|ni_vp
argument_list|)
expr_stmt|;
name|VFS_UNLOCK_GIANT
argument_list|(
name|vfslocked
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|extattr_set_link
parameter_list|(
name|td
parameter_list|,
name|uap
parameter_list|)
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|extattr_set_link_args
comment|/* { 		const char *path; 		int attrnamespace; 		const char *attrname; 		void *data; 		size_t nbytes; 	} */
modifier|*
name|uap
decl_stmt|;
block|{
name|struct
name|nameidata
name|nd
decl_stmt|;
name|char
name|attrname
index|[
name|EXTATTR_MAXNAMELEN
index|]
decl_stmt|;
name|int
name|vfslocked
decl_stmt|,
name|error
decl_stmt|;
name|AUDIT_ARG
argument_list|(
name|value
argument_list|,
name|uap
operator|->
name|attrnamespace
argument_list|)
expr_stmt|;
name|error
operator|=
name|copyinstr
argument_list|(
name|uap
operator|->
name|attrname
argument_list|,
name|attrname
argument_list|,
name|EXTATTR_MAXNAMELEN
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|AUDIT_ARG
argument_list|(
name|text
argument_list|,
name|attrname
argument_list|)
expr_stmt|;
name|NDINIT
argument_list|(
operator|&
name|nd
argument_list|,
name|LOOKUP
argument_list|,
name|MPSAFE
operator||
name|NOFOLLOW
operator||
name|AUDITVNODE1
argument_list|,
name|UIO_USERSPACE
argument_list|,
name|uap
operator|->
name|path
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|error
operator|=
name|namei
argument_list|(
operator|&
name|nd
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|NDFREE
argument_list|(
operator|&
name|nd
argument_list|,
name|NDF_ONLY_PNBUF
argument_list|)
expr_stmt|;
name|vfslocked
operator|=
name|NDHASGIANT
argument_list|(
operator|&
name|nd
argument_list|)
expr_stmt|;
name|error
operator|=
name|extattr_set_vp
argument_list|(
name|nd
operator|.
name|ni_vp
argument_list|,
name|uap
operator|->
name|attrnamespace
argument_list|,
name|attrname
argument_list|,
name|uap
operator|->
name|data
argument_list|,
name|uap
operator|->
name|nbytes
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|vrele
argument_list|(
name|nd
operator|.
name|ni_vp
argument_list|)
expr_stmt|;
name|VFS_UNLOCK_GIANT
argument_list|(
name|vfslocked
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*-  * Get a named extended attribute on a file or directory  *  * Arguments: unlocked vnode "vp", attribute namespace "attrnamespace",  *            kernelspace string pointer "attrname", userspace buffer  *            pointer "data", buffer length "nbytes", thread "td".  * Returns: 0 on success, an error number otherwise  * Locks: none  * References: vp must be a valid reference for the duration of the call  */
end_comment

begin_function
specifier|static
name|int
name|extattr_get_vp
parameter_list|(
name|struct
name|vnode
modifier|*
name|vp
parameter_list|,
name|int
name|attrnamespace
parameter_list|,
specifier|const
name|char
modifier|*
name|attrname
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|size_t
name|nbytes
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|uio
name|auio
decl_stmt|,
modifier|*
name|auiop
decl_stmt|;
name|struct
name|iovec
name|aiov
decl_stmt|;
name|ssize_t
name|cnt
decl_stmt|;
name|size_t
name|size
decl_stmt|,
modifier|*
name|sizep
decl_stmt|;
name|int
name|error
decl_stmt|;
name|VFS_ASSERT_GIANT
argument_list|(
name|vp
operator|->
name|v_mount
argument_list|)
expr_stmt|;
name|VOP_LEASE
argument_list|(
name|vp
argument_list|,
name|td
argument_list|,
name|td
operator|->
name|td_ucred
argument_list|,
name|LEASE_READ
argument_list|)
expr_stmt|;
name|vn_lock
argument_list|(
name|vp
argument_list|,
name|LK_EXCLUSIVE
operator||
name|LK_RETRY
argument_list|,
name|td
argument_list|)
expr_stmt|;
comment|/* 	 * Slightly unusual semantics: if the user provides a NULL data 	 * pointer, they don't want to receive the data, just the maximum 	 * read length. 	 */
name|auiop
operator|=
name|NULL
expr_stmt|;
name|sizep
operator|=
name|NULL
expr_stmt|;
name|cnt
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|data
operator|!=
name|NULL
condition|)
block|{
name|aiov
operator|.
name|iov_base
operator|=
name|data
expr_stmt|;
name|aiov
operator|.
name|iov_len
operator|=
name|nbytes
expr_stmt|;
name|auio
operator|.
name|uio_iov
operator|=
operator|&
name|aiov
expr_stmt|;
name|auio
operator|.
name|uio_iovcnt
operator|=
literal|1
expr_stmt|;
name|auio
operator|.
name|uio_offset
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|nbytes
operator|>
name|INT_MAX
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|auio
operator|.
name|uio_resid
operator|=
name|nbytes
expr_stmt|;
name|auio
operator|.
name|uio_rw
operator|=
name|UIO_READ
expr_stmt|;
name|auio
operator|.
name|uio_segflg
operator|=
name|UIO_USERSPACE
expr_stmt|;
name|auio
operator|.
name|uio_td
operator|=
name|td
expr_stmt|;
name|auiop
operator|=
operator|&
name|auio
expr_stmt|;
name|cnt
operator|=
name|nbytes
expr_stmt|;
block|}
else|else
name|sizep
operator|=
operator|&
name|size
expr_stmt|;
ifdef|#
directive|ifdef
name|MAC
name|error
operator|=
name|mac_check_vnode_getextattr
argument_list|(
name|td
operator|->
name|td_ucred
argument_list|,
name|vp
argument_list|,
name|attrnamespace
argument_list|,
name|attrname
argument_list|,
operator|&
name|auio
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|done
goto|;
endif|#
directive|endif
name|error
operator|=
name|VOP_GETEXTATTR
argument_list|(
name|vp
argument_list|,
name|attrnamespace
argument_list|,
name|attrname
argument_list|,
name|auiop
argument_list|,
name|sizep
argument_list|,
name|td
operator|->
name|td_ucred
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|auiop
operator|!=
name|NULL
condition|)
block|{
name|cnt
operator|-=
name|auio
operator|.
name|uio_resid
expr_stmt|;
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|=
name|cnt
expr_stmt|;
block|}
else|else
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|=
name|size
expr_stmt|;
name|done
label|:
name|VOP_UNLOCK
argument_list|(
name|vp
argument_list|,
literal|0
argument_list|,
name|td
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|extattr_get_fd
parameter_list|(
name|td
parameter_list|,
name|uap
parameter_list|)
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|extattr_get_fd_args
comment|/* { 		int fd; 		int attrnamespace; 		const char *attrname; 		void *data; 		size_t nbytes; 	} */
modifier|*
name|uap
decl_stmt|;
block|{
name|struct
name|file
modifier|*
name|fp
decl_stmt|;
name|char
name|attrname
index|[
name|EXTATTR_MAXNAMELEN
index|]
decl_stmt|;
name|int
name|vfslocked
decl_stmt|,
name|error
decl_stmt|;
name|AUDIT_ARG
argument_list|(
name|fd
argument_list|,
name|uap
operator|->
name|fd
argument_list|)
expr_stmt|;
name|AUDIT_ARG
argument_list|(
name|value
argument_list|,
name|uap
operator|->
name|attrnamespace
argument_list|)
expr_stmt|;
name|error
operator|=
name|copyinstr
argument_list|(
name|uap
operator|->
name|attrname
argument_list|,
name|attrname
argument_list|,
name|EXTATTR_MAXNAMELEN
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|AUDIT_ARG
argument_list|(
name|text
argument_list|,
name|attrname
argument_list|)
expr_stmt|;
name|error
operator|=
name|getvnode
argument_list|(
name|td
operator|->
name|td_proc
operator|->
name|p_fd
argument_list|,
name|uap
operator|->
name|fd
argument_list|,
operator|&
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|vfslocked
operator|=
name|VFS_LOCK_GIANT
argument_list|(
name|fp
operator|->
name|f_vnode
operator|->
name|v_mount
argument_list|)
expr_stmt|;
name|error
operator|=
name|extattr_get_vp
argument_list|(
name|fp
operator|->
name|f_vnode
argument_list|,
name|uap
operator|->
name|attrnamespace
argument_list|,
name|attrname
argument_list|,
name|uap
operator|->
name|data
argument_list|,
name|uap
operator|->
name|nbytes
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|fdrop
argument_list|(
name|fp
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|VFS_UNLOCK_GIANT
argument_list|(
name|vfslocked
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|extattr_get_file
parameter_list|(
name|td
parameter_list|,
name|uap
parameter_list|)
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|extattr_get_file_args
comment|/* { 		const char *path; 		int attrnamespace; 		const char *attrname; 		void *data; 		size_t nbytes; 	} */
modifier|*
name|uap
decl_stmt|;
block|{
name|struct
name|nameidata
name|nd
decl_stmt|;
name|char
name|attrname
index|[
name|EXTATTR_MAXNAMELEN
index|]
decl_stmt|;
name|int
name|vfslocked
decl_stmt|,
name|error
decl_stmt|;
name|AUDIT_ARG
argument_list|(
name|value
argument_list|,
name|uap
operator|->
name|attrnamespace
argument_list|)
expr_stmt|;
name|error
operator|=
name|copyinstr
argument_list|(
name|uap
operator|->
name|attrname
argument_list|,
name|attrname
argument_list|,
name|EXTATTR_MAXNAMELEN
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|AUDIT_ARG
argument_list|(
name|text
argument_list|,
name|attrname
argument_list|)
expr_stmt|;
name|NDINIT
argument_list|(
operator|&
name|nd
argument_list|,
name|LOOKUP
argument_list|,
name|MPSAFE
operator||
name|FOLLOW
operator||
name|AUDITVNODE1
argument_list|,
name|UIO_USERSPACE
argument_list|,
name|uap
operator|->
name|path
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|error
operator|=
name|namei
argument_list|(
operator|&
name|nd
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|NDFREE
argument_list|(
operator|&
name|nd
argument_list|,
name|NDF_ONLY_PNBUF
argument_list|)
expr_stmt|;
name|vfslocked
operator|=
name|NDHASGIANT
argument_list|(
operator|&
name|nd
argument_list|)
expr_stmt|;
name|error
operator|=
name|extattr_get_vp
argument_list|(
name|nd
operator|.
name|ni_vp
argument_list|,
name|uap
operator|->
name|attrnamespace
argument_list|,
name|attrname
argument_list|,
name|uap
operator|->
name|data
argument_list|,
name|uap
operator|->
name|nbytes
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|vrele
argument_list|(
name|nd
operator|.
name|ni_vp
argument_list|)
expr_stmt|;
name|VFS_UNLOCK_GIANT
argument_list|(
name|vfslocked
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|extattr_get_link
parameter_list|(
name|td
parameter_list|,
name|uap
parameter_list|)
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|extattr_get_link_args
comment|/* { 		const char *path; 		int attrnamespace; 		const char *attrname; 		void *data; 		size_t nbytes; 	} */
modifier|*
name|uap
decl_stmt|;
block|{
name|struct
name|nameidata
name|nd
decl_stmt|;
name|char
name|attrname
index|[
name|EXTATTR_MAXNAMELEN
index|]
decl_stmt|;
name|int
name|vfslocked
decl_stmt|,
name|error
decl_stmt|;
name|AUDIT_ARG
argument_list|(
name|value
argument_list|,
name|uap
operator|->
name|attrnamespace
argument_list|)
expr_stmt|;
name|error
operator|=
name|copyinstr
argument_list|(
name|uap
operator|->
name|attrname
argument_list|,
name|attrname
argument_list|,
name|EXTATTR_MAXNAMELEN
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|AUDIT_ARG
argument_list|(
name|text
argument_list|,
name|attrname
argument_list|)
expr_stmt|;
name|NDINIT
argument_list|(
operator|&
name|nd
argument_list|,
name|LOOKUP
argument_list|,
name|MPSAFE
operator||
name|NOFOLLOW
operator||
name|AUDITVNODE1
argument_list|,
name|UIO_USERSPACE
argument_list|,
name|uap
operator|->
name|path
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|error
operator|=
name|namei
argument_list|(
operator|&
name|nd
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|NDFREE
argument_list|(
operator|&
name|nd
argument_list|,
name|NDF_ONLY_PNBUF
argument_list|)
expr_stmt|;
name|vfslocked
operator|=
name|NDHASGIANT
argument_list|(
operator|&
name|nd
argument_list|)
expr_stmt|;
name|error
operator|=
name|extattr_get_vp
argument_list|(
name|nd
operator|.
name|ni_vp
argument_list|,
name|uap
operator|->
name|attrnamespace
argument_list|,
name|attrname
argument_list|,
name|uap
operator|->
name|data
argument_list|,
name|uap
operator|->
name|nbytes
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|vrele
argument_list|(
name|nd
operator|.
name|ni_vp
argument_list|)
expr_stmt|;
name|VFS_UNLOCK_GIANT
argument_list|(
name|vfslocked
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * extattr_delete_vp(): Delete a named extended attribute on a file or  *                      directory  *  * Arguments: unlocked vnode "vp", attribute namespace "attrnamespace",  *            kernelspace string pointer "attrname", proc "p"  * Returns: 0 on success, an error number otherwise  * Locks: none  * References: vp must be a valid reference for the duration of the call  */
end_comment

begin_function
specifier|static
name|int
name|extattr_delete_vp
parameter_list|(
name|struct
name|vnode
modifier|*
name|vp
parameter_list|,
name|int
name|attrnamespace
parameter_list|,
specifier|const
name|char
modifier|*
name|attrname
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|mount
modifier|*
name|mp
decl_stmt|;
name|int
name|error
decl_stmt|;
name|VFS_ASSERT_GIANT
argument_list|(
name|vp
operator|->
name|v_mount
argument_list|)
expr_stmt|;
name|error
operator|=
name|vn_start_write
argument_list|(
name|vp
argument_list|,
operator|&
name|mp
argument_list|,
name|V_WAIT
operator||
name|PCATCH
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|VOP_LEASE
argument_list|(
name|vp
argument_list|,
name|td
argument_list|,
name|td
operator|->
name|td_ucred
argument_list|,
name|LEASE_WRITE
argument_list|)
expr_stmt|;
name|vn_lock
argument_list|(
name|vp
argument_list|,
name|LK_EXCLUSIVE
operator||
name|LK_RETRY
argument_list|,
name|td
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MAC
name|error
operator|=
name|mac_check_vnode_deleteextattr
argument_list|(
name|td
operator|->
name|td_ucred
argument_list|,
name|vp
argument_list|,
name|attrnamespace
argument_list|,
name|attrname
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|done
goto|;
endif|#
directive|endif
name|error
operator|=
name|VOP_DELETEEXTATTR
argument_list|(
name|vp
argument_list|,
name|attrnamespace
argument_list|,
name|attrname
argument_list|,
name|td
operator|->
name|td_ucred
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|EOPNOTSUPP
condition|)
name|error
operator|=
name|VOP_SETEXTATTR
argument_list|(
name|vp
argument_list|,
name|attrnamespace
argument_list|,
name|attrname
argument_list|,
name|NULL
argument_list|,
name|td
operator|->
name|td_ucred
argument_list|,
name|td
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MAC
name|done
label|:
endif|#
directive|endif
name|VOP_UNLOCK
argument_list|(
name|vp
argument_list|,
literal|0
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|vn_finished_write
argument_list|(
name|mp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|extattr_delete_fd
parameter_list|(
name|td
parameter_list|,
name|uap
parameter_list|)
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|extattr_delete_fd_args
comment|/* { 		int fd; 		int attrnamespace; 		const char *attrname; 	} */
modifier|*
name|uap
decl_stmt|;
block|{
name|struct
name|file
modifier|*
name|fp
decl_stmt|;
name|char
name|attrname
index|[
name|EXTATTR_MAXNAMELEN
index|]
decl_stmt|;
name|int
name|vfslocked
decl_stmt|,
name|error
decl_stmt|;
name|AUDIT_ARG
argument_list|(
name|fd
argument_list|,
name|uap
operator|->
name|fd
argument_list|)
expr_stmt|;
name|AUDIT_ARG
argument_list|(
name|value
argument_list|,
name|uap
operator|->
name|attrnamespace
argument_list|)
expr_stmt|;
name|error
operator|=
name|copyinstr
argument_list|(
name|uap
operator|->
name|attrname
argument_list|,
name|attrname
argument_list|,
name|EXTATTR_MAXNAMELEN
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|AUDIT_ARG
argument_list|(
name|text
argument_list|,
name|attrname
argument_list|)
expr_stmt|;
name|error
operator|=
name|getvnode
argument_list|(
name|td
operator|->
name|td_proc
operator|->
name|p_fd
argument_list|,
name|uap
operator|->
name|fd
argument_list|,
operator|&
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|vfslocked
operator|=
name|VFS_LOCK_GIANT
argument_list|(
name|fp
operator|->
name|f_vnode
operator|->
name|v_mount
argument_list|)
expr_stmt|;
name|error
operator|=
name|extattr_delete_vp
argument_list|(
name|fp
operator|->
name|f_vnode
argument_list|,
name|uap
operator|->
name|attrnamespace
argument_list|,
name|attrname
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|fdrop
argument_list|(
name|fp
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|VFS_UNLOCK_GIANT
argument_list|(
name|vfslocked
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|extattr_delete_file
parameter_list|(
name|td
parameter_list|,
name|uap
parameter_list|)
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|extattr_delete_file_args
comment|/* { 		const char *path; 		int attrnamespace; 		const char *attrname; 	} */
modifier|*
name|uap
decl_stmt|;
block|{
name|struct
name|nameidata
name|nd
decl_stmt|;
name|char
name|attrname
index|[
name|EXTATTR_MAXNAMELEN
index|]
decl_stmt|;
name|int
name|vfslocked
decl_stmt|,
name|error
decl_stmt|;
name|AUDIT_ARG
argument_list|(
name|value
argument_list|,
name|uap
operator|->
name|attrnamespace
argument_list|)
expr_stmt|;
name|error
operator|=
name|copyinstr
argument_list|(
name|uap
operator|->
name|attrname
argument_list|,
name|attrname
argument_list|,
name|EXTATTR_MAXNAMELEN
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|AUDIT_ARG
argument_list|(
name|text
argument_list|,
name|attrname
argument_list|)
expr_stmt|;
name|NDINIT
argument_list|(
operator|&
name|nd
argument_list|,
name|LOOKUP
argument_list|,
name|MPSAFE
operator||
name|FOLLOW
operator||
name|AUDITVNODE1
argument_list|,
name|UIO_USERSPACE
argument_list|,
name|uap
operator|->
name|path
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|error
operator|=
name|namei
argument_list|(
operator|&
name|nd
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|NDFREE
argument_list|(
operator|&
name|nd
argument_list|,
name|NDF_ONLY_PNBUF
argument_list|)
expr_stmt|;
name|vfslocked
operator|=
name|NDHASGIANT
argument_list|(
operator|&
name|nd
argument_list|)
expr_stmt|;
name|error
operator|=
name|extattr_delete_vp
argument_list|(
name|nd
operator|.
name|ni_vp
argument_list|,
name|uap
operator|->
name|attrnamespace
argument_list|,
name|attrname
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|vrele
argument_list|(
name|nd
operator|.
name|ni_vp
argument_list|)
expr_stmt|;
name|VFS_UNLOCK_GIANT
argument_list|(
name|vfslocked
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|extattr_delete_link
parameter_list|(
name|td
parameter_list|,
name|uap
parameter_list|)
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|extattr_delete_link_args
comment|/* { 		const char *path; 		int attrnamespace; 		const char *attrname; 	} */
modifier|*
name|uap
decl_stmt|;
block|{
name|struct
name|nameidata
name|nd
decl_stmt|;
name|char
name|attrname
index|[
name|EXTATTR_MAXNAMELEN
index|]
decl_stmt|;
name|int
name|vfslocked
decl_stmt|,
name|error
decl_stmt|;
name|AUDIT_ARG
argument_list|(
name|value
argument_list|,
name|uap
operator|->
name|attrnamespace
argument_list|)
expr_stmt|;
name|error
operator|=
name|copyinstr
argument_list|(
name|uap
operator|->
name|attrname
argument_list|,
name|attrname
argument_list|,
name|EXTATTR_MAXNAMELEN
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|AUDIT_ARG
argument_list|(
name|text
argument_list|,
name|attrname
argument_list|)
expr_stmt|;
name|NDINIT
argument_list|(
operator|&
name|nd
argument_list|,
name|LOOKUP
argument_list|,
name|MPSAFE
operator||
name|NOFOLLOW
operator||
name|AUDITVNODE1
argument_list|,
name|UIO_USERSPACE
argument_list|,
name|uap
operator|->
name|path
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|error
operator|=
name|namei
argument_list|(
operator|&
name|nd
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|NDFREE
argument_list|(
operator|&
name|nd
argument_list|,
name|NDF_ONLY_PNBUF
argument_list|)
expr_stmt|;
name|vfslocked
operator|=
name|NDHASGIANT
argument_list|(
operator|&
name|nd
argument_list|)
expr_stmt|;
name|error
operator|=
name|extattr_delete_vp
argument_list|(
name|nd
operator|.
name|ni_vp
argument_list|,
name|uap
operator|->
name|attrnamespace
argument_list|,
name|attrname
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|vrele
argument_list|(
name|nd
operator|.
name|ni_vp
argument_list|)
expr_stmt|;
name|VFS_UNLOCK_GIANT
argument_list|(
name|vfslocked
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*-  * Retrieve a list of extended attributes on a file or directory.  *  * Arguments: unlocked vnode "vp", attribute namespace 'attrnamespace",  *            userspace buffer pointer "data", buffer length "nbytes",  *            thread "td".  * Returns: 0 on success, an error number otherwise  * Locks: none  * References: vp must be a valid reference for the duration of the call  */
end_comment

begin_function
specifier|static
name|int
name|extattr_list_vp
parameter_list|(
name|struct
name|vnode
modifier|*
name|vp
parameter_list|,
name|int
name|attrnamespace
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|size_t
name|nbytes
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|uio
name|auio
decl_stmt|,
modifier|*
name|auiop
decl_stmt|;
name|size_t
name|size
decl_stmt|,
modifier|*
name|sizep
decl_stmt|;
name|struct
name|iovec
name|aiov
decl_stmt|;
name|ssize_t
name|cnt
decl_stmt|;
name|int
name|error
decl_stmt|;
name|VFS_ASSERT_GIANT
argument_list|(
name|vp
operator|->
name|v_mount
argument_list|)
expr_stmt|;
name|VOP_LEASE
argument_list|(
name|vp
argument_list|,
name|td
argument_list|,
name|td
operator|->
name|td_ucred
argument_list|,
name|LEASE_READ
argument_list|)
expr_stmt|;
name|vn_lock
argument_list|(
name|vp
argument_list|,
name|LK_EXCLUSIVE
operator||
name|LK_RETRY
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|auiop
operator|=
name|NULL
expr_stmt|;
name|sizep
operator|=
name|NULL
expr_stmt|;
name|cnt
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|data
operator|!=
name|NULL
condition|)
block|{
name|aiov
operator|.
name|iov_base
operator|=
name|data
expr_stmt|;
name|aiov
operator|.
name|iov_len
operator|=
name|nbytes
expr_stmt|;
name|auio
operator|.
name|uio_iov
operator|=
operator|&
name|aiov
expr_stmt|;
name|auio
operator|.
name|uio_iovcnt
operator|=
literal|1
expr_stmt|;
name|auio
operator|.
name|uio_offset
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|nbytes
operator|>
name|INT_MAX
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|auio
operator|.
name|uio_resid
operator|=
name|nbytes
expr_stmt|;
name|auio
operator|.
name|uio_rw
operator|=
name|UIO_READ
expr_stmt|;
name|auio
operator|.
name|uio_segflg
operator|=
name|UIO_USERSPACE
expr_stmt|;
name|auio
operator|.
name|uio_td
operator|=
name|td
expr_stmt|;
name|auiop
operator|=
operator|&
name|auio
expr_stmt|;
name|cnt
operator|=
name|nbytes
expr_stmt|;
block|}
else|else
name|sizep
operator|=
operator|&
name|size
expr_stmt|;
ifdef|#
directive|ifdef
name|MAC
name|error
operator|=
name|mac_check_vnode_listextattr
argument_list|(
name|td
operator|->
name|td_ucred
argument_list|,
name|vp
argument_list|,
name|attrnamespace
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|done
goto|;
endif|#
directive|endif
name|error
operator|=
name|VOP_LISTEXTATTR
argument_list|(
name|vp
argument_list|,
name|attrnamespace
argument_list|,
name|auiop
argument_list|,
name|sizep
argument_list|,
name|td
operator|->
name|td_ucred
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|auiop
operator|!=
name|NULL
condition|)
block|{
name|cnt
operator|-=
name|auio
operator|.
name|uio_resid
expr_stmt|;
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|=
name|cnt
expr_stmt|;
block|}
else|else
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|=
name|size
expr_stmt|;
name|done
label|:
name|VOP_UNLOCK
argument_list|(
name|vp
argument_list|,
literal|0
argument_list|,
name|td
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|extattr_list_fd
parameter_list|(
name|td
parameter_list|,
name|uap
parameter_list|)
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|extattr_list_fd_args
comment|/* { 		int fd; 		int attrnamespace; 		void *data; 		size_t nbytes; 	} */
modifier|*
name|uap
decl_stmt|;
block|{
name|struct
name|file
modifier|*
name|fp
decl_stmt|;
name|int
name|vfslocked
decl_stmt|,
name|error
decl_stmt|;
name|AUDIT_ARG
argument_list|(
name|fd
argument_list|,
name|uap
operator|->
name|fd
argument_list|)
expr_stmt|;
name|AUDIT_ARG
argument_list|(
name|value
argument_list|,
name|uap
operator|->
name|attrnamespace
argument_list|)
expr_stmt|;
name|error
operator|=
name|getvnode
argument_list|(
name|td
operator|->
name|td_proc
operator|->
name|p_fd
argument_list|,
name|uap
operator|->
name|fd
argument_list|,
operator|&
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|vfslocked
operator|=
name|VFS_LOCK_GIANT
argument_list|(
name|fp
operator|->
name|f_vnode
operator|->
name|v_mount
argument_list|)
expr_stmt|;
name|error
operator|=
name|extattr_list_vp
argument_list|(
name|fp
operator|->
name|f_vnode
argument_list|,
name|uap
operator|->
name|attrnamespace
argument_list|,
name|uap
operator|->
name|data
argument_list|,
name|uap
operator|->
name|nbytes
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|fdrop
argument_list|(
name|fp
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|VFS_UNLOCK_GIANT
argument_list|(
name|vfslocked
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|extattr_list_file
parameter_list|(
name|td
parameter_list|,
name|uap
parameter_list|)
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|extattr_list_file_args
comment|/* { 		const char *path; 		int attrnamespace; 		void *data; 		size_t nbytes; 	} */
modifier|*
name|uap
decl_stmt|;
block|{
name|struct
name|nameidata
name|nd
decl_stmt|;
name|int
name|vfslocked
decl_stmt|,
name|error
decl_stmt|;
name|AUDIT_ARG
argument_list|(
name|value
argument_list|,
name|uap
operator|->
name|attrnamespace
argument_list|)
expr_stmt|;
name|NDINIT
argument_list|(
operator|&
name|nd
argument_list|,
name|LOOKUP
argument_list|,
name|MPSAFE
operator||
name|FOLLOW
operator||
name|AUDITVNODE1
argument_list|,
name|UIO_USERSPACE
argument_list|,
name|uap
operator|->
name|path
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|error
operator|=
name|namei
argument_list|(
operator|&
name|nd
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|NDFREE
argument_list|(
operator|&
name|nd
argument_list|,
name|NDF_ONLY_PNBUF
argument_list|)
expr_stmt|;
name|vfslocked
operator|=
name|NDHASGIANT
argument_list|(
operator|&
name|nd
argument_list|)
expr_stmt|;
name|error
operator|=
name|extattr_list_vp
argument_list|(
name|nd
operator|.
name|ni_vp
argument_list|,
name|uap
operator|->
name|attrnamespace
argument_list|,
name|uap
operator|->
name|data
argument_list|,
name|uap
operator|->
name|nbytes
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|vrele
argument_list|(
name|nd
operator|.
name|ni_vp
argument_list|)
expr_stmt|;
name|VFS_UNLOCK_GIANT
argument_list|(
name|vfslocked
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|extattr_list_link
parameter_list|(
name|td
parameter_list|,
name|uap
parameter_list|)
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|extattr_list_link_args
comment|/* { 		const char *path; 		int attrnamespace; 		void *data; 		size_t nbytes; 	} */
modifier|*
name|uap
decl_stmt|;
block|{
name|struct
name|nameidata
name|nd
decl_stmt|;
name|int
name|vfslocked
decl_stmt|,
name|error
decl_stmt|;
name|AUDIT_ARG
argument_list|(
name|value
argument_list|,
name|uap
operator|->
name|attrnamespace
argument_list|)
expr_stmt|;
name|NDINIT
argument_list|(
operator|&
name|nd
argument_list|,
name|LOOKUP
argument_list|,
name|MPSAFE
operator||
name|NOFOLLOW
operator||
name|AUDITVNODE1
argument_list|,
name|UIO_USERSPACE
argument_list|,
name|uap
operator|->
name|path
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|error
operator|=
name|namei
argument_list|(
operator|&
name|nd
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|NDFREE
argument_list|(
operator|&
name|nd
argument_list|,
name|NDF_ONLY_PNBUF
argument_list|)
expr_stmt|;
name|vfslocked
operator|=
name|NDHASGIANT
argument_list|(
operator|&
name|nd
argument_list|)
expr_stmt|;
name|error
operator|=
name|extattr_list_vp
argument_list|(
name|nd
operator|.
name|ni_vp
argument_list|,
name|uap
operator|->
name|attrnamespace
argument_list|,
name|uap
operator|->
name|data
argument_list|,
name|uap
operator|->
name|nbytes
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|vrele
argument_list|(
name|nd
operator|.
name|ni_vp
argument_list|)
expr_stmt|;
name|VFS_UNLOCK_GIANT
argument_list|(
name|vfslocked
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

end_unit

