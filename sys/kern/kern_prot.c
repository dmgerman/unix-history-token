begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1982, 1986, 1989, 1990, 1991, 1993  *	The Regents of the University of California.  All rights reserved.  * (c) UNIX System Laboratories, Inc.  * All or some portions of this file are derived from material licensed  * to the University of California by American Telephone and Telegraph  * Co. or Unix System Laboratories, Inc. and are reproduced herein with  * the permission of UNIX System Laboratories, Inc.  * Copyright (c) 2000-2001 Robert N. M. Watson.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *	@(#)kern_prot.c	8.6 (Berkeley) 1/21/94  */
end_comment

begin_comment
comment|/*  * System calls related to processes and protection  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"opt_compat.h"
end_include

begin_include
include|#
directive|include
file|"opt_mac.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/acct.h>
end_include

begin_include
include|#
directive|include
file|<sys/kdb.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mac.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/refcount.h>
end_include

begin_include
include|#
directive|include
file|<sys/sx.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysproto.h>
end_include

begin_include
include|#
directive|include
file|<sys/jail.h>
end_include

begin_include
include|#
directive|include
file|<sys/pioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/resourcevar.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/socketvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<security/audit/audit.h>
end_include

begin_expr_stmt
specifier|static
name|MALLOC_DEFINE
argument_list|(
name|M_CRED
argument_list|,
literal|"cred"
argument_list|,
literal|"credentials"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_DECL
argument_list|(
name|_security
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_security
argument_list|,
name|OID_AUTO
argument_list|,
name|bsd
argument_list|,
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
literal|"BSD security policy"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|_SYS_SYSPROTO_H_
end_ifndef

begin_struct
struct|struct
name|getpid_args
block|{
name|int
name|dummy
decl_stmt|;
block|}
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * MPSAFE  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|getpid
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|getpid_args
modifier|*
name|uap
parameter_list|)
block|{
name|struct
name|proc
modifier|*
name|p
init|=
name|td
operator|->
name|td_proc
decl_stmt|;
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|=
name|p
operator|->
name|p_pid
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|COMPAT_43
argument_list|)
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|td
operator|->
name|td_retval
index|[
literal|1
index|]
operator|=
name|p
operator|->
name|p_pptr
operator|->
name|p_pid
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|_SYS_SYSPROTO_H_
end_ifndef

begin_struct
struct|struct
name|getppid_args
block|{
name|int
name|dummy
decl_stmt|;
block|}
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * MPSAFE  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|getppid
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|getppid_args
modifier|*
name|uap
parameter_list|)
block|{
name|struct
name|proc
modifier|*
name|p
init|=
name|td
operator|->
name|td_proc
decl_stmt|;
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|=
name|p
operator|->
name|p_pptr
operator|->
name|p_pid
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Get process group ID; note that POSIX getpgrp takes no parameter.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|_SYS_SYSPROTO_H_
end_ifndef

begin_struct
struct|struct
name|getpgrp_args
block|{
name|int
name|dummy
decl_stmt|;
block|}
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * MPSAFE  */
end_comment

begin_function
name|int
name|getpgrp
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|getpgrp_args
modifier|*
name|uap
parameter_list|)
block|{
name|struct
name|proc
modifier|*
name|p
init|=
name|td
operator|->
name|td_proc
decl_stmt|;
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|=
name|p
operator|->
name|p_pgrp
operator|->
name|pg_id
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Get an arbitary pid's process group id */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|_SYS_SYSPROTO_H_
end_ifndef

begin_struct
struct|struct
name|getpgid_args
block|{
name|pid_t
name|pid
decl_stmt|;
block|}
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * MPSAFE  */
end_comment

begin_function
name|int
name|getpgid
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|getpgid_args
modifier|*
name|uap
parameter_list|)
block|{
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|uap
operator|->
name|pid
operator|==
literal|0
condition|)
block|{
name|p
operator|=
name|td
operator|->
name|td_proc
expr_stmt|;
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|p
operator|=
name|pfind
argument_list|(
name|uap
operator|->
name|pid
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
return|return
operator|(
name|ESRCH
operator|)
return|;
name|error
operator|=
name|p_cansee
argument_list|(
name|td
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|=
name|p
operator|->
name|p_pgrp
operator|->
name|pg_id
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Get an arbitary pid's session id.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|_SYS_SYSPROTO_H_
end_ifndef

begin_struct
struct|struct
name|getsid_args
block|{
name|pid_t
name|pid
decl_stmt|;
block|}
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * MPSAFE  */
end_comment

begin_function
name|int
name|getsid
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|getsid_args
modifier|*
name|uap
parameter_list|)
block|{
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|uap
operator|->
name|pid
operator|==
literal|0
condition|)
block|{
name|p
operator|=
name|td
operator|->
name|td_proc
expr_stmt|;
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|p
operator|=
name|pfind
argument_list|(
name|uap
operator|->
name|pid
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
return|return
operator|(
name|ESRCH
operator|)
return|;
name|error
operator|=
name|p_cansee
argument_list|(
name|td
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|=
name|p
operator|->
name|p_session
operator|->
name|s_sid
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|_SYS_SYSPROTO_H_
end_ifndef

begin_struct
struct|struct
name|getuid_args
block|{
name|int
name|dummy
decl_stmt|;
block|}
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * MPSAFE  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|getuid
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|getuid_args
modifier|*
name|uap
parameter_list|)
block|{
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|=
name|td
operator|->
name|td_ucred
operator|->
name|cr_ruid
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|COMPAT_43
argument_list|)
name|td
operator|->
name|td_retval
index|[
literal|1
index|]
operator|=
name|td
operator|->
name|td_ucred
operator|->
name|cr_uid
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|_SYS_SYSPROTO_H_
end_ifndef

begin_struct
struct|struct
name|geteuid_args
block|{
name|int
name|dummy
decl_stmt|;
block|}
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * MPSAFE  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|geteuid
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|geteuid_args
modifier|*
name|uap
parameter_list|)
block|{
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|=
name|td
operator|->
name|td_ucred
operator|->
name|cr_uid
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|_SYS_SYSPROTO_H_
end_ifndef

begin_struct
struct|struct
name|getgid_args
block|{
name|int
name|dummy
decl_stmt|;
block|}
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * MPSAFE  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|getgid
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|getgid_args
modifier|*
name|uap
parameter_list|)
block|{
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|=
name|td
operator|->
name|td_ucred
operator|->
name|cr_rgid
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|COMPAT_43
argument_list|)
name|td
operator|->
name|td_retval
index|[
literal|1
index|]
operator|=
name|td
operator|->
name|td_ucred
operator|->
name|cr_groups
index|[
literal|0
index|]
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Get effective group ID.  The "egid" is groups[0], and could be obtained  * via getgroups.  This syscall exists because it is somewhat painful to do  * correctly in a library function.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|_SYS_SYSPROTO_H_
end_ifndef

begin_struct
struct|struct
name|getegid_args
block|{
name|int
name|dummy
decl_stmt|;
block|}
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * MPSAFE  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|getegid
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|getegid_args
modifier|*
name|uap
parameter_list|)
block|{
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|=
name|td
operator|->
name|td_ucred
operator|->
name|cr_groups
index|[
literal|0
index|]
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|_SYS_SYSPROTO_H_
end_ifndef

begin_struct
struct|struct
name|getgroups_args
block|{
name|u_int
name|gidsetsize
decl_stmt|;
name|gid_t
modifier|*
name|gidset
decl_stmt|;
block|}
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * MPSAFE  */
end_comment

begin_function
name|int
name|getgroups
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
specifier|register
name|struct
name|getgroups_args
modifier|*
name|uap
parameter_list|)
block|{
name|struct
name|ucred
modifier|*
name|cred
decl_stmt|;
name|u_int
name|ngrp
decl_stmt|;
name|int
name|error
decl_stmt|;
name|cred
operator|=
name|td
operator|->
name|td_ucred
expr_stmt|;
if|if
condition|(
operator|(
name|ngrp
operator|=
name|uap
operator|->
name|gidsetsize
operator|)
operator|==
literal|0
condition|)
block|{
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|=
name|cred
operator|->
name|cr_ngroups
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|ngrp
operator|<
name|cred
operator|->
name|cr_ngroups
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|ngrp
operator|=
name|cred
operator|->
name|cr_ngroups
expr_stmt|;
name|error
operator|=
name|copyout
argument_list|(
name|cred
operator|->
name|cr_groups
argument_list|,
name|uap
operator|->
name|gidset
argument_list|,
name|ngrp
operator|*
sizeof|sizeof
argument_list|(
name|gid_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|=
name|ngrp
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|_SYS_SYSPROTO_H_
end_ifndef

begin_struct
struct|struct
name|setsid_args
block|{
name|int
name|dummy
decl_stmt|;
block|}
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * MPSAFE  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|setsid
parameter_list|(
specifier|register
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|setsid_args
modifier|*
name|uap
parameter_list|)
block|{
name|struct
name|pgrp
modifier|*
name|pgrp
decl_stmt|;
name|int
name|error
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
init|=
name|td
operator|->
name|td_proc
decl_stmt|;
name|struct
name|pgrp
modifier|*
name|newpgrp
decl_stmt|;
name|struct
name|session
modifier|*
name|newsess
decl_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|pgrp
operator|=
name|NULL
expr_stmt|;
name|MALLOC
argument_list|(
name|newpgrp
argument_list|,
expr|struct
name|pgrp
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|pgrp
argument_list|)
argument_list|,
name|M_PGRP
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|MALLOC
argument_list|(
name|newsess
argument_list|,
expr|struct
name|session
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|session
argument_list|)
argument_list|,
name|M_SESSION
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|sx_xlock
argument_list|(
operator|&
name|proctree_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|p_pgid
operator|==
name|p
operator|->
name|p_pid
operator|||
operator|(
name|pgrp
operator|=
name|pgfind
argument_list|(
name|p
operator|->
name|p_pid
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|pgrp
operator|!=
name|NULL
condition|)
name|PGRP_UNLOCK
argument_list|(
name|pgrp
argument_list|)
expr_stmt|;
name|error
operator|=
name|EPERM
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|enterpgrp
argument_list|(
name|p
argument_list|,
name|p
operator|->
name|p_pid
argument_list|,
name|newpgrp
argument_list|,
name|newsess
argument_list|)
expr_stmt|;
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|=
name|p
operator|->
name|p_pid
expr_stmt|;
name|newpgrp
operator|=
name|NULL
expr_stmt|;
name|newsess
operator|=
name|NULL
expr_stmt|;
block|}
name|sx_xunlock
argument_list|(
operator|&
name|proctree_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|newpgrp
operator|!=
name|NULL
condition|)
name|FREE
argument_list|(
name|newpgrp
argument_list|,
name|M_PGRP
argument_list|)
expr_stmt|;
if|if
condition|(
name|newsess
operator|!=
name|NULL
condition|)
name|FREE
argument_list|(
name|newsess
argument_list|,
name|M_SESSION
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * set process group (setpgid/old setpgrp)  *  * caller does setpgid(targpid, targpgid)  *  * pid must be caller or child of caller (ESRCH)  * if a child  *	pid must be in same session (EPERM)  *	pid can't have done an exec (EACCES)  * if pgid != pid  * 	there must exist some pid in same session having pgid (EPERM)  * pid must not be session leader (EPERM)  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|_SYS_SYSPROTO_H_
end_ifndef

begin_struct
struct|struct
name|setpgid_args
block|{
name|int
name|pid
decl_stmt|;
comment|/* target process id */
name|int
name|pgid
decl_stmt|;
comment|/* target pgrp id */
block|}
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * MPSAFE  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|setpgid
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
specifier|register
name|struct
name|setpgid_args
modifier|*
name|uap
parameter_list|)
block|{
name|struct
name|proc
modifier|*
name|curp
init|=
name|td
operator|->
name|td_proc
decl_stmt|;
specifier|register
name|struct
name|proc
modifier|*
name|targp
decl_stmt|;
comment|/* target process */
specifier|register
name|struct
name|pgrp
modifier|*
name|pgrp
decl_stmt|;
comment|/* target pgrp */
name|int
name|error
decl_stmt|;
name|struct
name|pgrp
modifier|*
name|newpgrp
decl_stmt|;
if|if
condition|(
name|uap
operator|->
name|pgid
operator|<
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|error
operator|=
literal|0
expr_stmt|;
name|MALLOC
argument_list|(
name|newpgrp
argument_list|,
expr|struct
name|pgrp
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|pgrp
argument_list|)
argument_list|,
name|M_PGRP
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|sx_xlock
argument_list|(
operator|&
name|proctree_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|uap
operator|->
name|pid
operator|!=
literal|0
operator|&&
name|uap
operator|->
name|pid
operator|!=
name|curp
operator|->
name|p_pid
condition|)
block|{
if|if
condition|(
operator|(
name|targp
operator|=
name|pfind
argument_list|(
name|uap
operator|->
name|pid
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ESRCH
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
operator|!
name|inferior
argument_list|(
name|targp
argument_list|)
condition|)
block|{
name|PROC_UNLOCK
argument_list|(
name|targp
argument_list|)
expr_stmt|;
name|error
operator|=
name|ESRCH
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
operator|(
name|error
operator|=
name|p_cansee
argument_list|(
name|td
argument_list|,
name|targp
argument_list|)
operator|)
condition|)
block|{
name|PROC_UNLOCK
argument_list|(
name|targp
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|targp
operator|->
name|p_pgrp
operator|==
name|NULL
operator|||
name|targp
operator|->
name|p_session
operator|!=
name|curp
operator|->
name|p_session
condition|)
block|{
name|PROC_UNLOCK
argument_list|(
name|targp
argument_list|)
expr_stmt|;
name|error
operator|=
name|EPERM
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|targp
operator|->
name|p_flag
operator|&
name|P_EXEC
condition|)
block|{
name|PROC_UNLOCK
argument_list|(
name|targp
argument_list|)
expr_stmt|;
name|error
operator|=
name|EACCES
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|PROC_UNLOCK
argument_list|(
name|targp
argument_list|)
expr_stmt|;
block|}
else|else
name|targp
operator|=
name|curp
expr_stmt|;
if|if
condition|(
name|SESS_LEADER
argument_list|(
name|targp
argument_list|)
condition|)
block|{
name|error
operator|=
name|EPERM
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|uap
operator|->
name|pgid
operator|==
literal|0
condition|)
name|uap
operator|->
name|pgid
operator|=
name|targp
operator|->
name|p_pid
expr_stmt|;
if|if
condition|(
operator|(
name|pgrp
operator|=
name|pgfind
argument_list|(
name|uap
operator|->
name|pgid
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|uap
operator|->
name|pgid
operator|==
name|targp
operator|->
name|p_pid
condition|)
block|{
name|error
operator|=
name|enterpgrp
argument_list|(
name|targp
argument_list|,
name|uap
operator|->
name|pgid
argument_list|,
name|newpgrp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|newpgrp
operator|=
name|NULL
expr_stmt|;
block|}
else|else
name|error
operator|=
name|EPERM
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|pgrp
operator|==
name|targp
operator|->
name|p_pgrp
condition|)
block|{
name|PGRP_UNLOCK
argument_list|(
name|pgrp
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|pgrp
operator|->
name|pg_id
operator|!=
name|targp
operator|->
name|p_pid
operator|&&
name|pgrp
operator|->
name|pg_session
operator|!=
name|curp
operator|->
name|p_session
condition|)
block|{
name|PGRP_UNLOCK
argument_list|(
name|pgrp
argument_list|)
expr_stmt|;
name|error
operator|=
name|EPERM
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|PGRP_UNLOCK
argument_list|(
name|pgrp
argument_list|)
expr_stmt|;
name|error
operator|=
name|enterthispgrp
argument_list|(
name|targp
argument_list|,
name|pgrp
argument_list|)
expr_stmt|;
block|}
name|done
label|:
name|sx_xunlock
argument_list|(
operator|&
name|proctree_lock
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|error
operator|==
literal|0
operator|)
operator|||
operator|(
name|newpgrp
operator|!=
name|NULL
operator|)
argument_list|,
operator|(
literal|"setpgid failed and newpgrp is NULL"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|newpgrp
operator|!=
name|NULL
condition|)
name|FREE
argument_list|(
name|newpgrp
argument_list|,
name|M_PGRP
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Use the clause in B.4.2.2 that allows setuid/setgid to be 4.2/4.3BSD  * compatible.  It says that setting the uid/gid to euid/egid is a special  * case of "appropriate privilege".  Once the rules are expanded out, this  * basically means that setuid(nnn) sets all three id's, in all permitted  * cases unless _POSIX_SAVED_IDS is enabled.  In that case, setuid(getuid())  * does not set the saved id - this is dangerous for traditional BSD  * programs.  For this reason, we *really* do not want to set  * _POSIX_SAVED_IDS and do not want to clear POSIX_APPENDIX_B_4_2_2.  */
end_comment

begin_define
define|#
directive|define
name|POSIX_APPENDIX_B_4_2_2
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|_SYS_SYSPROTO_H_
end_ifndef

begin_struct
struct|struct
name|setuid_args
block|{
name|uid_t
name|uid
decl_stmt|;
block|}
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * MPSAFE  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|setuid
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|setuid_args
modifier|*
name|uap
parameter_list|)
block|{
name|struct
name|proc
modifier|*
name|p
init|=
name|td
operator|->
name|td_proc
decl_stmt|;
name|struct
name|ucred
modifier|*
name|newcred
decl_stmt|,
modifier|*
name|oldcred
decl_stmt|;
name|uid_t
name|uid
decl_stmt|;
name|struct
name|uidinfo
modifier|*
name|uip
decl_stmt|;
name|int
name|error
decl_stmt|;
name|uid
operator|=
name|uap
operator|->
name|uid
expr_stmt|;
name|AUDIT_ARG
argument_list|(
name|uid
argument_list|,
name|uid
argument_list|)
expr_stmt|;
name|newcred
operator|=
name|crget
argument_list|()
expr_stmt|;
name|uip
operator|=
name|uifind
argument_list|(
name|uid
argument_list|)
expr_stmt|;
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|oldcred
operator|=
name|p
operator|->
name|p_ucred
expr_stmt|;
ifdef|#
directive|ifdef
name|MAC
name|error
operator|=
name|mac_check_proc_setuid
argument_list|(
name|p
argument_list|,
name|oldcred
argument_list|,
name|uid
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|fail
goto|;
endif|#
directive|endif
comment|/* 	 * See if we have "permission" by POSIX 1003.1 rules. 	 * 	 * Note that setuid(geteuid()) is a special case of 	 * "appropriate privileges" in appendix B.4.2.2.  We need 	 * to use this clause to be compatible with traditional BSD 	 * semantics.  Basically, it means that "setuid(xx)" sets all 	 * three id's (assuming you have privs). 	 * 	 * Notes on the logic.  We do things in three steps. 	 * 1: We determine if the euid is going to change, and do EPERM 	 *    right away.  We unconditionally change the euid later if this 	 *    test is satisfied, simplifying that part of the logic. 	 * 2: We determine if the real and/or saved uids are going to 	 *    change.  Determined by compile options. 	 * 3: Change euid last. (after tests in #2 for "appropriate privs") 	 */
if|if
condition|(
name|uid
operator|!=
name|oldcred
operator|->
name|cr_ruid
operator|&&
comment|/* allow setuid(getuid()) */
ifdef|#
directive|ifdef
name|_POSIX_SAVED_IDS
name|uid
operator|!=
name|oldcred
operator|->
name|cr_svuid
operator|&&
comment|/* allow setuid(saved gid) */
endif|#
directive|endif
ifdef|#
directive|ifdef
name|POSIX_APPENDIX_B_4_2_2
comment|/* Use BSD-compat clause from B.4.2.2 */
name|uid
operator|!=
name|oldcred
operator|->
name|cr_uid
operator|&&
comment|/* allow setuid(geteuid()) */
endif|#
directive|endif
operator|(
name|error
operator|=
name|suser_cred
argument_list|(
name|oldcred
argument_list|,
name|SUSER_ALLOWJAIL
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|fail
goto|;
comment|/* 	 * Copy credentials so other references do not see our changes. 	 */
name|crcopy
argument_list|(
name|newcred
argument_list|,
name|oldcred
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|_POSIX_SAVED_IDS
comment|/* 	 * Do we have "appropriate privileges" (are we root or uid == euid) 	 * If so, we are changing the real uid and/or saved uid. 	 */
if|if
condition|(
ifdef|#
directive|ifdef
name|POSIX_APPENDIX_B_4_2_2
comment|/* Use the clause from B.4.2.2 */
name|uid
operator|==
name|oldcred
operator|->
name|cr_uid
operator|||
endif|#
directive|endif
name|suser_cred
argument_list|(
name|oldcred
argument_list|,
name|SUSER_ALLOWJAIL
argument_list|)
operator|==
literal|0
condition|)
comment|/* we are using privs */
endif|#
directive|endif
block|{
comment|/* 		 * Set the real uid and transfer proc count to new user. 		 */
if|if
condition|(
name|uid
operator|!=
name|oldcred
operator|->
name|cr_ruid
condition|)
block|{
name|change_ruid
argument_list|(
name|newcred
argument_list|,
name|uip
argument_list|)
expr_stmt|;
name|setsugid
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Set saved uid 		 * 		 * XXX always set saved uid even if not _POSIX_SAVED_IDS, as 		 * the security of seteuid() depends on it.  B.4.2.2 says it 		 * is important that we should do this. 		 */
if|if
condition|(
name|uid
operator|!=
name|oldcred
operator|->
name|cr_svuid
condition|)
block|{
name|change_svuid
argument_list|(
name|newcred
argument_list|,
name|uid
argument_list|)
expr_stmt|;
name|setsugid
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * In all permitted cases, we are changing the euid. 	 */
if|if
condition|(
name|uid
operator|!=
name|oldcred
operator|->
name|cr_uid
condition|)
block|{
name|change_euid
argument_list|(
name|newcred
argument_list|,
name|uip
argument_list|)
expr_stmt|;
name|setsugid
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
name|p
operator|->
name|p_ucred
operator|=
name|newcred
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|uifree
argument_list|(
name|uip
argument_list|)
expr_stmt|;
name|crfree
argument_list|(
name|oldcred
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|fail
label|:
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|uifree
argument_list|(
name|uip
argument_list|)
expr_stmt|;
name|crfree
argument_list|(
name|newcred
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|_SYS_SYSPROTO_H_
end_ifndef

begin_struct
struct|struct
name|seteuid_args
block|{
name|uid_t
name|euid
decl_stmt|;
block|}
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * MPSAFE  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|seteuid
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|seteuid_args
modifier|*
name|uap
parameter_list|)
block|{
name|struct
name|proc
modifier|*
name|p
init|=
name|td
operator|->
name|td_proc
decl_stmt|;
name|struct
name|ucred
modifier|*
name|newcred
decl_stmt|,
modifier|*
name|oldcred
decl_stmt|;
name|uid_t
name|euid
decl_stmt|;
name|struct
name|uidinfo
modifier|*
name|euip
decl_stmt|;
name|int
name|error
decl_stmt|;
name|euid
operator|=
name|uap
operator|->
name|euid
expr_stmt|;
name|AUDIT_ARG
argument_list|(
name|euid
argument_list|,
name|euid
argument_list|)
expr_stmt|;
name|newcred
operator|=
name|crget
argument_list|()
expr_stmt|;
name|euip
operator|=
name|uifind
argument_list|(
name|euid
argument_list|)
expr_stmt|;
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|oldcred
operator|=
name|p
operator|->
name|p_ucred
expr_stmt|;
ifdef|#
directive|ifdef
name|MAC
name|error
operator|=
name|mac_check_proc_seteuid
argument_list|(
name|p
argument_list|,
name|oldcred
argument_list|,
name|euid
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|fail
goto|;
endif|#
directive|endif
if|if
condition|(
name|euid
operator|!=
name|oldcred
operator|->
name|cr_ruid
operator|&&
comment|/* allow seteuid(getuid()) */
name|euid
operator|!=
name|oldcred
operator|->
name|cr_svuid
operator|&&
comment|/* allow seteuid(saved uid) */
operator|(
name|error
operator|=
name|suser_cred
argument_list|(
name|oldcred
argument_list|,
name|SUSER_ALLOWJAIL
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|fail
goto|;
comment|/* 	 * Everything's okay, do it.  Copy credentials so other references do 	 * not see our changes. 	 */
name|crcopy
argument_list|(
name|newcred
argument_list|,
name|oldcred
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldcred
operator|->
name|cr_uid
operator|!=
name|euid
condition|)
block|{
name|change_euid
argument_list|(
name|newcred
argument_list|,
name|euip
argument_list|)
expr_stmt|;
name|setsugid
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
name|p
operator|->
name|p_ucred
operator|=
name|newcred
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|uifree
argument_list|(
name|euip
argument_list|)
expr_stmt|;
name|crfree
argument_list|(
name|oldcred
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|fail
label|:
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|uifree
argument_list|(
name|euip
argument_list|)
expr_stmt|;
name|crfree
argument_list|(
name|newcred
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|_SYS_SYSPROTO_H_
end_ifndef

begin_struct
struct|struct
name|setgid_args
block|{
name|gid_t
name|gid
decl_stmt|;
block|}
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * MPSAFE  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|setgid
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|setgid_args
modifier|*
name|uap
parameter_list|)
block|{
name|struct
name|proc
modifier|*
name|p
init|=
name|td
operator|->
name|td_proc
decl_stmt|;
name|struct
name|ucred
modifier|*
name|newcred
decl_stmt|,
modifier|*
name|oldcred
decl_stmt|;
name|gid_t
name|gid
decl_stmt|;
name|int
name|error
decl_stmt|;
name|gid
operator|=
name|uap
operator|->
name|gid
expr_stmt|;
name|AUDIT_ARG
argument_list|(
name|gid
argument_list|,
name|gid
argument_list|)
expr_stmt|;
name|newcred
operator|=
name|crget
argument_list|()
expr_stmt|;
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|oldcred
operator|=
name|p
operator|->
name|p_ucred
expr_stmt|;
ifdef|#
directive|ifdef
name|MAC
name|error
operator|=
name|mac_check_proc_setgid
argument_list|(
name|p
argument_list|,
name|oldcred
argument_list|,
name|gid
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|fail
goto|;
endif|#
directive|endif
comment|/* 	 * See if we have "permission" by POSIX 1003.1 rules. 	 * 	 * Note that setgid(getegid()) is a special case of 	 * "appropriate privileges" in appendix B.4.2.2.  We need 	 * to use this clause to be compatible with traditional BSD 	 * semantics.  Basically, it means that "setgid(xx)" sets all 	 * three id's (assuming you have privs). 	 * 	 * For notes on the logic here, see setuid() above. 	 */
if|if
condition|(
name|gid
operator|!=
name|oldcred
operator|->
name|cr_rgid
operator|&&
comment|/* allow setgid(getgid()) */
ifdef|#
directive|ifdef
name|_POSIX_SAVED_IDS
name|gid
operator|!=
name|oldcred
operator|->
name|cr_svgid
operator|&&
comment|/* allow setgid(saved gid) */
endif|#
directive|endif
ifdef|#
directive|ifdef
name|POSIX_APPENDIX_B_4_2_2
comment|/* Use BSD-compat clause from B.4.2.2 */
name|gid
operator|!=
name|oldcred
operator|->
name|cr_groups
index|[
literal|0
index|]
operator|&&
comment|/* allow setgid(getegid()) */
endif|#
directive|endif
operator|(
name|error
operator|=
name|suser_cred
argument_list|(
name|oldcred
argument_list|,
name|SUSER_ALLOWJAIL
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|fail
goto|;
name|crcopy
argument_list|(
name|newcred
argument_list|,
name|oldcred
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|_POSIX_SAVED_IDS
comment|/* 	 * Do we have "appropriate privileges" (are we root or gid == egid) 	 * If so, we are changing the real uid and saved gid. 	 */
if|if
condition|(
ifdef|#
directive|ifdef
name|POSIX_APPENDIX_B_4_2_2
comment|/* use the clause from B.4.2.2 */
name|gid
operator|==
name|oldcred
operator|->
name|cr_groups
index|[
literal|0
index|]
operator|||
endif|#
directive|endif
name|suser_cred
argument_list|(
name|oldcred
argument_list|,
name|SUSER_ALLOWJAIL
argument_list|)
operator|==
literal|0
condition|)
comment|/* we are using privs */
endif|#
directive|endif
block|{
comment|/* 		 * Set real gid 		 */
if|if
condition|(
name|oldcred
operator|->
name|cr_rgid
operator|!=
name|gid
condition|)
block|{
name|change_rgid
argument_list|(
name|newcred
argument_list|,
name|gid
argument_list|)
expr_stmt|;
name|setsugid
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Set saved gid 		 * 		 * XXX always set saved gid even if not _POSIX_SAVED_IDS, as 		 * the security of setegid() depends on it.  B.4.2.2 says it 		 * is important that we should do this. 		 */
if|if
condition|(
name|oldcred
operator|->
name|cr_svgid
operator|!=
name|gid
condition|)
block|{
name|change_svgid
argument_list|(
name|newcred
argument_list|,
name|gid
argument_list|)
expr_stmt|;
name|setsugid
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * In all cases permitted cases, we are changing the egid. 	 * Copy credentials so other references do not see our changes. 	 */
if|if
condition|(
name|oldcred
operator|->
name|cr_groups
index|[
literal|0
index|]
operator|!=
name|gid
condition|)
block|{
name|change_egid
argument_list|(
name|newcred
argument_list|,
name|gid
argument_list|)
expr_stmt|;
name|setsugid
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
name|p
operator|->
name|p_ucred
operator|=
name|newcred
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|crfree
argument_list|(
name|oldcred
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|fail
label|:
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|crfree
argument_list|(
name|newcred
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|_SYS_SYSPROTO_H_
end_ifndef

begin_struct
struct|struct
name|setegid_args
block|{
name|gid_t
name|egid
decl_stmt|;
block|}
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * MPSAFE  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|setegid
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|setegid_args
modifier|*
name|uap
parameter_list|)
block|{
name|struct
name|proc
modifier|*
name|p
init|=
name|td
operator|->
name|td_proc
decl_stmt|;
name|struct
name|ucred
modifier|*
name|newcred
decl_stmt|,
modifier|*
name|oldcred
decl_stmt|;
name|gid_t
name|egid
decl_stmt|;
name|int
name|error
decl_stmt|;
name|egid
operator|=
name|uap
operator|->
name|egid
expr_stmt|;
name|AUDIT_ARG
argument_list|(
name|egid
argument_list|,
name|egid
argument_list|)
expr_stmt|;
name|newcred
operator|=
name|crget
argument_list|()
expr_stmt|;
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|oldcred
operator|=
name|p
operator|->
name|p_ucred
expr_stmt|;
ifdef|#
directive|ifdef
name|MAC
name|error
operator|=
name|mac_check_proc_setegid
argument_list|(
name|p
argument_list|,
name|oldcred
argument_list|,
name|egid
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|fail
goto|;
endif|#
directive|endif
if|if
condition|(
name|egid
operator|!=
name|oldcred
operator|->
name|cr_rgid
operator|&&
comment|/* allow setegid(getgid()) */
name|egid
operator|!=
name|oldcred
operator|->
name|cr_svgid
operator|&&
comment|/* allow setegid(saved gid) */
operator|(
name|error
operator|=
name|suser_cred
argument_list|(
name|oldcred
argument_list|,
name|SUSER_ALLOWJAIL
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|fail
goto|;
name|crcopy
argument_list|(
name|newcred
argument_list|,
name|oldcred
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldcred
operator|->
name|cr_groups
index|[
literal|0
index|]
operator|!=
name|egid
condition|)
block|{
name|change_egid
argument_list|(
name|newcred
argument_list|,
name|egid
argument_list|)
expr_stmt|;
name|setsugid
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
name|p
operator|->
name|p_ucred
operator|=
name|newcred
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|crfree
argument_list|(
name|oldcred
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|fail
label|:
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|crfree
argument_list|(
name|newcred
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|_SYS_SYSPROTO_H_
end_ifndef

begin_struct
struct|struct
name|setgroups_args
block|{
name|u_int
name|gidsetsize
decl_stmt|;
name|gid_t
modifier|*
name|gidset
decl_stmt|;
block|}
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * MPSAFE  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|setgroups
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|setgroups_args
modifier|*
name|uap
parameter_list|)
block|{
name|struct
name|proc
modifier|*
name|p
init|=
name|td
operator|->
name|td_proc
decl_stmt|;
name|struct
name|ucred
modifier|*
name|newcred
decl_stmt|,
modifier|*
name|tempcred
decl_stmt|,
modifier|*
name|oldcred
decl_stmt|;
name|u_int
name|ngrp
decl_stmt|;
name|int
name|error
decl_stmt|;
name|ngrp
operator|=
name|uap
operator|->
name|gidsetsize
expr_stmt|;
if|if
condition|(
name|ngrp
operator|>
name|NGROUPS
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|tempcred
operator|=
name|crget
argument_list|()
expr_stmt|;
name|error
operator|=
name|copyin
argument_list|(
name|uap
operator|->
name|gidset
argument_list|,
name|tempcred
operator|->
name|cr_groups
argument_list|,
name|ngrp
operator|*
sizeof|sizeof
argument_list|(
name|gid_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|crfree
argument_list|(
name|tempcred
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|AUDIT_ARG
argument_list|(
name|groupset
argument_list|,
name|tempcred
operator|->
name|cr_groups
argument_list|,
name|ngrp
argument_list|)
expr_stmt|;
name|newcred
operator|=
name|crget
argument_list|()
expr_stmt|;
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|oldcred
operator|=
name|p
operator|->
name|p_ucred
expr_stmt|;
ifdef|#
directive|ifdef
name|MAC
name|error
operator|=
name|mac_check_proc_setgroups
argument_list|(
name|p
argument_list|,
name|oldcred
argument_list|,
name|ngrp
argument_list|,
name|tempcred
operator|->
name|cr_groups
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|fail
goto|;
endif|#
directive|endif
name|error
operator|=
name|suser_cred
argument_list|(
name|oldcred
argument_list|,
name|SUSER_ALLOWJAIL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|fail
goto|;
comment|/* 	 * XXX A little bit lazy here.  We could test if anything has 	 * changed before crcopy() and setting P_SUGID. 	 */
name|crcopy
argument_list|(
name|newcred
argument_list|,
name|oldcred
argument_list|)
expr_stmt|;
if|if
condition|(
name|ngrp
operator|<
literal|1
condition|)
block|{
comment|/* 		 * setgroups(0, NULL) is a legitimate way of clearing the 		 * groups vector on non-BSD systems (which generally do not 		 * have the egid in the groups[0]).  We risk security holes 		 * when running non-BSD software if we do not do the same. 		 */
name|newcred
operator|->
name|cr_ngroups
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|bcopy
argument_list|(
name|tempcred
operator|->
name|cr_groups
argument_list|,
name|newcred
operator|->
name|cr_groups
argument_list|,
name|ngrp
operator|*
sizeof|sizeof
argument_list|(
name|gid_t
argument_list|)
argument_list|)
expr_stmt|;
name|newcred
operator|->
name|cr_ngroups
operator|=
name|ngrp
expr_stmt|;
block|}
name|setsugid
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|->
name|p_ucred
operator|=
name|newcred
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|crfree
argument_list|(
name|tempcred
argument_list|)
expr_stmt|;
name|crfree
argument_list|(
name|oldcred
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|fail
label|:
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|crfree
argument_list|(
name|newcred
argument_list|)
expr_stmt|;
name|crfree
argument_list|(
name|tempcred
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|_SYS_SYSPROTO_H_
end_ifndef

begin_struct
struct|struct
name|setreuid_args
block|{
name|uid_t
name|ruid
decl_stmt|;
name|uid_t
name|euid
decl_stmt|;
block|}
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * MPSAFE  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|setreuid
parameter_list|(
specifier|register
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|setreuid_args
modifier|*
name|uap
parameter_list|)
block|{
name|struct
name|proc
modifier|*
name|p
init|=
name|td
operator|->
name|td_proc
decl_stmt|;
name|struct
name|ucred
modifier|*
name|newcred
decl_stmt|,
modifier|*
name|oldcred
decl_stmt|;
name|uid_t
name|euid
decl_stmt|,
name|ruid
decl_stmt|;
name|struct
name|uidinfo
modifier|*
name|euip
decl_stmt|,
modifier|*
name|ruip
decl_stmt|;
name|int
name|error
decl_stmt|;
name|euid
operator|=
name|uap
operator|->
name|euid
expr_stmt|;
name|ruid
operator|=
name|uap
operator|->
name|ruid
expr_stmt|;
name|AUDIT_ARG
argument_list|(
name|euid
argument_list|,
name|euid
argument_list|)
expr_stmt|;
name|AUDIT_ARG
argument_list|(
name|ruid
argument_list|,
name|ruid
argument_list|)
expr_stmt|;
name|newcred
operator|=
name|crget
argument_list|()
expr_stmt|;
name|euip
operator|=
name|uifind
argument_list|(
name|euid
argument_list|)
expr_stmt|;
name|ruip
operator|=
name|uifind
argument_list|(
name|ruid
argument_list|)
expr_stmt|;
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|oldcred
operator|=
name|p
operator|->
name|p_ucred
expr_stmt|;
ifdef|#
directive|ifdef
name|MAC
name|error
operator|=
name|mac_check_proc_setreuid
argument_list|(
name|p
argument_list|,
name|oldcred
argument_list|,
name|ruid
argument_list|,
name|euid
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|fail
goto|;
endif|#
directive|endif
if|if
condition|(
operator|(
operator|(
name|ruid
operator|!=
operator|(
name|uid_t
operator|)
operator|-
literal|1
operator|&&
name|ruid
operator|!=
name|oldcred
operator|->
name|cr_ruid
operator|&&
name|ruid
operator|!=
name|oldcred
operator|->
name|cr_svuid
operator|)
operator|||
operator|(
name|euid
operator|!=
operator|(
name|uid_t
operator|)
operator|-
literal|1
operator|&&
name|euid
operator|!=
name|oldcred
operator|->
name|cr_uid
operator|&&
name|euid
operator|!=
name|oldcred
operator|->
name|cr_ruid
operator|&&
name|euid
operator|!=
name|oldcred
operator|->
name|cr_svuid
operator|)
operator|)
operator|&&
operator|(
name|error
operator|=
name|suser_cred
argument_list|(
name|oldcred
argument_list|,
name|SUSER_ALLOWJAIL
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|fail
goto|;
name|crcopy
argument_list|(
name|newcred
argument_list|,
name|oldcred
argument_list|)
expr_stmt|;
if|if
condition|(
name|euid
operator|!=
operator|(
name|uid_t
operator|)
operator|-
literal|1
operator|&&
name|oldcred
operator|->
name|cr_uid
operator|!=
name|euid
condition|)
block|{
name|change_euid
argument_list|(
name|newcred
argument_list|,
name|euip
argument_list|)
expr_stmt|;
name|setsugid
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ruid
operator|!=
operator|(
name|uid_t
operator|)
operator|-
literal|1
operator|&&
name|oldcred
operator|->
name|cr_ruid
operator|!=
name|ruid
condition|)
block|{
name|change_ruid
argument_list|(
name|newcred
argument_list|,
name|ruip
argument_list|)
expr_stmt|;
name|setsugid
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|ruid
operator|!=
operator|(
name|uid_t
operator|)
operator|-
literal|1
operator|||
name|newcred
operator|->
name|cr_uid
operator|!=
name|newcred
operator|->
name|cr_ruid
operator|)
operator|&&
name|newcred
operator|->
name|cr_svuid
operator|!=
name|newcred
operator|->
name|cr_uid
condition|)
block|{
name|change_svuid
argument_list|(
name|newcred
argument_list|,
name|newcred
operator|->
name|cr_uid
argument_list|)
expr_stmt|;
name|setsugid
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
name|p
operator|->
name|p_ucred
operator|=
name|newcred
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|uifree
argument_list|(
name|ruip
argument_list|)
expr_stmt|;
name|uifree
argument_list|(
name|euip
argument_list|)
expr_stmt|;
name|crfree
argument_list|(
name|oldcred
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|fail
label|:
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|uifree
argument_list|(
name|ruip
argument_list|)
expr_stmt|;
name|uifree
argument_list|(
name|euip
argument_list|)
expr_stmt|;
name|crfree
argument_list|(
name|newcred
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|_SYS_SYSPROTO_H_
end_ifndef

begin_struct
struct|struct
name|setregid_args
block|{
name|gid_t
name|rgid
decl_stmt|;
name|gid_t
name|egid
decl_stmt|;
block|}
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * MPSAFE  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|setregid
parameter_list|(
specifier|register
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|setregid_args
modifier|*
name|uap
parameter_list|)
block|{
name|struct
name|proc
modifier|*
name|p
init|=
name|td
operator|->
name|td_proc
decl_stmt|;
name|struct
name|ucred
modifier|*
name|newcred
decl_stmt|,
modifier|*
name|oldcred
decl_stmt|;
name|gid_t
name|egid
decl_stmt|,
name|rgid
decl_stmt|;
name|int
name|error
decl_stmt|;
name|egid
operator|=
name|uap
operator|->
name|egid
expr_stmt|;
name|rgid
operator|=
name|uap
operator|->
name|rgid
expr_stmt|;
name|AUDIT_ARG
argument_list|(
name|egid
argument_list|,
name|egid
argument_list|)
expr_stmt|;
name|AUDIT_ARG
argument_list|(
name|rgid
argument_list|,
name|rgid
argument_list|)
expr_stmt|;
name|newcred
operator|=
name|crget
argument_list|()
expr_stmt|;
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|oldcred
operator|=
name|p
operator|->
name|p_ucred
expr_stmt|;
ifdef|#
directive|ifdef
name|MAC
name|error
operator|=
name|mac_check_proc_setregid
argument_list|(
name|p
argument_list|,
name|oldcred
argument_list|,
name|rgid
argument_list|,
name|egid
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|fail
goto|;
endif|#
directive|endif
if|if
condition|(
operator|(
operator|(
name|rgid
operator|!=
operator|(
name|gid_t
operator|)
operator|-
literal|1
operator|&&
name|rgid
operator|!=
name|oldcred
operator|->
name|cr_rgid
operator|&&
name|rgid
operator|!=
name|oldcred
operator|->
name|cr_svgid
operator|)
operator|||
operator|(
name|egid
operator|!=
operator|(
name|gid_t
operator|)
operator|-
literal|1
operator|&&
name|egid
operator|!=
name|oldcred
operator|->
name|cr_groups
index|[
literal|0
index|]
operator|&&
name|egid
operator|!=
name|oldcred
operator|->
name|cr_rgid
operator|&&
name|egid
operator|!=
name|oldcred
operator|->
name|cr_svgid
operator|)
operator|)
operator|&&
operator|(
name|error
operator|=
name|suser_cred
argument_list|(
name|oldcred
argument_list|,
name|SUSER_ALLOWJAIL
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|fail
goto|;
name|crcopy
argument_list|(
name|newcred
argument_list|,
name|oldcred
argument_list|)
expr_stmt|;
if|if
condition|(
name|egid
operator|!=
operator|(
name|gid_t
operator|)
operator|-
literal|1
operator|&&
name|oldcred
operator|->
name|cr_groups
index|[
literal|0
index|]
operator|!=
name|egid
condition|)
block|{
name|change_egid
argument_list|(
name|newcred
argument_list|,
name|egid
argument_list|)
expr_stmt|;
name|setsugid
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rgid
operator|!=
operator|(
name|gid_t
operator|)
operator|-
literal|1
operator|&&
name|oldcred
operator|->
name|cr_rgid
operator|!=
name|rgid
condition|)
block|{
name|change_rgid
argument_list|(
name|newcred
argument_list|,
name|rgid
argument_list|)
expr_stmt|;
name|setsugid
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|rgid
operator|!=
operator|(
name|gid_t
operator|)
operator|-
literal|1
operator|||
name|newcred
operator|->
name|cr_groups
index|[
literal|0
index|]
operator|!=
name|newcred
operator|->
name|cr_rgid
operator|)
operator|&&
name|newcred
operator|->
name|cr_svgid
operator|!=
name|newcred
operator|->
name|cr_groups
index|[
literal|0
index|]
condition|)
block|{
name|change_svgid
argument_list|(
name|newcred
argument_list|,
name|newcred
operator|->
name|cr_groups
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|setsugid
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
name|p
operator|->
name|p_ucred
operator|=
name|newcred
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|crfree
argument_list|(
name|oldcred
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|fail
label|:
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|crfree
argument_list|(
name|newcred
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * setresuid(ruid, euid, suid) is like setreuid except control over the  * saved uid is explicit.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|_SYS_SYSPROTO_H_
end_ifndef

begin_struct
struct|struct
name|setresuid_args
block|{
name|uid_t
name|ruid
decl_stmt|;
name|uid_t
name|euid
decl_stmt|;
name|uid_t
name|suid
decl_stmt|;
block|}
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * MPSAFE  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|setresuid
parameter_list|(
specifier|register
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|setresuid_args
modifier|*
name|uap
parameter_list|)
block|{
name|struct
name|proc
modifier|*
name|p
init|=
name|td
operator|->
name|td_proc
decl_stmt|;
name|struct
name|ucred
modifier|*
name|newcred
decl_stmt|,
modifier|*
name|oldcred
decl_stmt|;
name|uid_t
name|euid
decl_stmt|,
name|ruid
decl_stmt|,
name|suid
decl_stmt|;
name|struct
name|uidinfo
modifier|*
name|euip
decl_stmt|,
modifier|*
name|ruip
decl_stmt|;
name|int
name|error
decl_stmt|;
name|euid
operator|=
name|uap
operator|->
name|euid
expr_stmt|;
name|ruid
operator|=
name|uap
operator|->
name|ruid
expr_stmt|;
name|suid
operator|=
name|uap
operator|->
name|suid
expr_stmt|;
name|AUDIT_ARG
argument_list|(
name|euid
argument_list|,
name|euid
argument_list|)
expr_stmt|;
name|AUDIT_ARG
argument_list|(
name|ruid
argument_list|,
name|ruid
argument_list|)
expr_stmt|;
name|AUDIT_ARG
argument_list|(
name|suid
argument_list|,
name|suid
argument_list|)
expr_stmt|;
name|newcred
operator|=
name|crget
argument_list|()
expr_stmt|;
name|euip
operator|=
name|uifind
argument_list|(
name|euid
argument_list|)
expr_stmt|;
name|ruip
operator|=
name|uifind
argument_list|(
name|ruid
argument_list|)
expr_stmt|;
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|oldcred
operator|=
name|p
operator|->
name|p_ucred
expr_stmt|;
ifdef|#
directive|ifdef
name|MAC
name|error
operator|=
name|mac_check_proc_setresuid
argument_list|(
name|p
argument_list|,
name|oldcred
argument_list|,
name|ruid
argument_list|,
name|euid
argument_list|,
name|suid
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|fail
goto|;
endif|#
directive|endif
if|if
condition|(
operator|(
operator|(
name|ruid
operator|!=
operator|(
name|uid_t
operator|)
operator|-
literal|1
operator|&&
name|ruid
operator|!=
name|oldcred
operator|->
name|cr_ruid
operator|&&
name|ruid
operator|!=
name|oldcred
operator|->
name|cr_svuid
operator|&&
name|ruid
operator|!=
name|oldcred
operator|->
name|cr_uid
operator|)
operator|||
operator|(
name|euid
operator|!=
operator|(
name|uid_t
operator|)
operator|-
literal|1
operator|&&
name|euid
operator|!=
name|oldcred
operator|->
name|cr_ruid
operator|&&
name|euid
operator|!=
name|oldcred
operator|->
name|cr_svuid
operator|&&
name|euid
operator|!=
name|oldcred
operator|->
name|cr_uid
operator|)
operator|||
operator|(
name|suid
operator|!=
operator|(
name|uid_t
operator|)
operator|-
literal|1
operator|&&
name|suid
operator|!=
name|oldcred
operator|->
name|cr_ruid
operator|&&
name|suid
operator|!=
name|oldcred
operator|->
name|cr_svuid
operator|&&
name|suid
operator|!=
name|oldcred
operator|->
name|cr_uid
operator|)
operator|)
operator|&&
operator|(
name|error
operator|=
name|suser_cred
argument_list|(
name|oldcred
argument_list|,
name|SUSER_ALLOWJAIL
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|fail
goto|;
name|crcopy
argument_list|(
name|newcred
argument_list|,
name|oldcred
argument_list|)
expr_stmt|;
if|if
condition|(
name|euid
operator|!=
operator|(
name|uid_t
operator|)
operator|-
literal|1
operator|&&
name|oldcred
operator|->
name|cr_uid
operator|!=
name|euid
condition|)
block|{
name|change_euid
argument_list|(
name|newcred
argument_list|,
name|euip
argument_list|)
expr_stmt|;
name|setsugid
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ruid
operator|!=
operator|(
name|uid_t
operator|)
operator|-
literal|1
operator|&&
name|oldcred
operator|->
name|cr_ruid
operator|!=
name|ruid
condition|)
block|{
name|change_ruid
argument_list|(
name|newcred
argument_list|,
name|ruip
argument_list|)
expr_stmt|;
name|setsugid
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|suid
operator|!=
operator|(
name|uid_t
operator|)
operator|-
literal|1
operator|&&
name|oldcred
operator|->
name|cr_svuid
operator|!=
name|suid
condition|)
block|{
name|change_svuid
argument_list|(
name|newcred
argument_list|,
name|suid
argument_list|)
expr_stmt|;
name|setsugid
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
name|p
operator|->
name|p_ucred
operator|=
name|newcred
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|uifree
argument_list|(
name|ruip
argument_list|)
expr_stmt|;
name|uifree
argument_list|(
name|euip
argument_list|)
expr_stmt|;
name|crfree
argument_list|(
name|oldcred
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|fail
label|:
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|uifree
argument_list|(
name|ruip
argument_list|)
expr_stmt|;
name|uifree
argument_list|(
name|euip
argument_list|)
expr_stmt|;
name|crfree
argument_list|(
name|newcred
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * setresgid(rgid, egid, sgid) is like setregid except control over the  * saved gid is explicit.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|_SYS_SYSPROTO_H_
end_ifndef

begin_struct
struct|struct
name|setresgid_args
block|{
name|gid_t
name|rgid
decl_stmt|;
name|gid_t
name|egid
decl_stmt|;
name|gid_t
name|sgid
decl_stmt|;
block|}
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * MPSAFE  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|setresgid
parameter_list|(
specifier|register
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|setresgid_args
modifier|*
name|uap
parameter_list|)
block|{
name|struct
name|proc
modifier|*
name|p
init|=
name|td
operator|->
name|td_proc
decl_stmt|;
name|struct
name|ucred
modifier|*
name|newcred
decl_stmt|,
modifier|*
name|oldcred
decl_stmt|;
name|gid_t
name|egid
decl_stmt|,
name|rgid
decl_stmt|,
name|sgid
decl_stmt|;
name|int
name|error
decl_stmt|;
name|egid
operator|=
name|uap
operator|->
name|egid
expr_stmt|;
name|rgid
operator|=
name|uap
operator|->
name|rgid
expr_stmt|;
name|sgid
operator|=
name|uap
operator|->
name|sgid
expr_stmt|;
name|AUDIT_ARG
argument_list|(
name|egid
argument_list|,
name|egid
argument_list|)
expr_stmt|;
name|AUDIT_ARG
argument_list|(
name|rgid
argument_list|,
name|rgid
argument_list|)
expr_stmt|;
name|AUDIT_ARG
argument_list|(
name|sgid
argument_list|,
name|sgid
argument_list|)
expr_stmt|;
name|newcred
operator|=
name|crget
argument_list|()
expr_stmt|;
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|oldcred
operator|=
name|p
operator|->
name|p_ucred
expr_stmt|;
ifdef|#
directive|ifdef
name|MAC
name|error
operator|=
name|mac_check_proc_setresgid
argument_list|(
name|p
argument_list|,
name|oldcred
argument_list|,
name|rgid
argument_list|,
name|egid
argument_list|,
name|sgid
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|fail
goto|;
endif|#
directive|endif
if|if
condition|(
operator|(
operator|(
name|rgid
operator|!=
operator|(
name|gid_t
operator|)
operator|-
literal|1
operator|&&
name|rgid
operator|!=
name|oldcred
operator|->
name|cr_rgid
operator|&&
name|rgid
operator|!=
name|oldcred
operator|->
name|cr_svgid
operator|&&
name|rgid
operator|!=
name|oldcred
operator|->
name|cr_groups
index|[
literal|0
index|]
operator|)
operator|||
operator|(
name|egid
operator|!=
operator|(
name|gid_t
operator|)
operator|-
literal|1
operator|&&
name|egid
operator|!=
name|oldcred
operator|->
name|cr_rgid
operator|&&
name|egid
operator|!=
name|oldcred
operator|->
name|cr_svgid
operator|&&
name|egid
operator|!=
name|oldcred
operator|->
name|cr_groups
index|[
literal|0
index|]
operator|)
operator|||
operator|(
name|sgid
operator|!=
operator|(
name|gid_t
operator|)
operator|-
literal|1
operator|&&
name|sgid
operator|!=
name|oldcred
operator|->
name|cr_rgid
operator|&&
name|sgid
operator|!=
name|oldcred
operator|->
name|cr_svgid
operator|&&
name|sgid
operator|!=
name|oldcred
operator|->
name|cr_groups
index|[
literal|0
index|]
operator|)
operator|)
operator|&&
operator|(
name|error
operator|=
name|suser_cred
argument_list|(
name|oldcred
argument_list|,
name|SUSER_ALLOWJAIL
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|fail
goto|;
name|crcopy
argument_list|(
name|newcred
argument_list|,
name|oldcred
argument_list|)
expr_stmt|;
if|if
condition|(
name|egid
operator|!=
operator|(
name|gid_t
operator|)
operator|-
literal|1
operator|&&
name|oldcred
operator|->
name|cr_groups
index|[
literal|0
index|]
operator|!=
name|egid
condition|)
block|{
name|change_egid
argument_list|(
name|newcred
argument_list|,
name|egid
argument_list|)
expr_stmt|;
name|setsugid
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rgid
operator|!=
operator|(
name|gid_t
operator|)
operator|-
literal|1
operator|&&
name|oldcred
operator|->
name|cr_rgid
operator|!=
name|rgid
condition|)
block|{
name|change_rgid
argument_list|(
name|newcred
argument_list|,
name|rgid
argument_list|)
expr_stmt|;
name|setsugid
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sgid
operator|!=
operator|(
name|gid_t
operator|)
operator|-
literal|1
operator|&&
name|oldcred
operator|->
name|cr_svgid
operator|!=
name|sgid
condition|)
block|{
name|change_svgid
argument_list|(
name|newcred
argument_list|,
name|sgid
argument_list|)
expr_stmt|;
name|setsugid
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
name|p
operator|->
name|p_ucred
operator|=
name|newcred
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|crfree
argument_list|(
name|oldcred
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|fail
label|:
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|crfree
argument_list|(
name|newcred
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|_SYS_SYSPROTO_H_
end_ifndef

begin_struct
struct|struct
name|getresuid_args
block|{
name|uid_t
modifier|*
name|ruid
decl_stmt|;
name|uid_t
modifier|*
name|euid
decl_stmt|;
name|uid_t
modifier|*
name|suid
decl_stmt|;
block|}
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * MPSAFE  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|getresuid
parameter_list|(
specifier|register
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|getresuid_args
modifier|*
name|uap
parameter_list|)
block|{
name|struct
name|ucred
modifier|*
name|cred
decl_stmt|;
name|int
name|error1
init|=
literal|0
decl_stmt|,
name|error2
init|=
literal|0
decl_stmt|,
name|error3
init|=
literal|0
decl_stmt|;
name|cred
operator|=
name|td
operator|->
name|td_ucred
expr_stmt|;
if|if
condition|(
name|uap
operator|->
name|ruid
condition|)
name|error1
operator|=
name|copyout
argument_list|(
operator|&
name|cred
operator|->
name|cr_ruid
argument_list|,
name|uap
operator|->
name|ruid
argument_list|,
sizeof|sizeof
argument_list|(
name|cred
operator|->
name|cr_ruid
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|uap
operator|->
name|euid
condition|)
name|error2
operator|=
name|copyout
argument_list|(
operator|&
name|cred
operator|->
name|cr_uid
argument_list|,
name|uap
operator|->
name|euid
argument_list|,
sizeof|sizeof
argument_list|(
name|cred
operator|->
name|cr_uid
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|uap
operator|->
name|suid
condition|)
name|error3
operator|=
name|copyout
argument_list|(
operator|&
name|cred
operator|->
name|cr_svuid
argument_list|,
name|uap
operator|->
name|suid
argument_list|,
sizeof|sizeof
argument_list|(
name|cred
operator|->
name|cr_svuid
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|error1
condition|?
name|error1
else|:
name|error2
condition|?
name|error2
else|:
name|error3
operator|)
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|_SYS_SYSPROTO_H_
end_ifndef

begin_struct
struct|struct
name|getresgid_args
block|{
name|gid_t
modifier|*
name|rgid
decl_stmt|;
name|gid_t
modifier|*
name|egid
decl_stmt|;
name|gid_t
modifier|*
name|sgid
decl_stmt|;
block|}
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * MPSAFE  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|getresgid
parameter_list|(
specifier|register
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|getresgid_args
modifier|*
name|uap
parameter_list|)
block|{
name|struct
name|ucred
modifier|*
name|cred
decl_stmt|;
name|int
name|error1
init|=
literal|0
decl_stmt|,
name|error2
init|=
literal|0
decl_stmt|,
name|error3
init|=
literal|0
decl_stmt|;
name|cred
operator|=
name|td
operator|->
name|td_ucred
expr_stmt|;
if|if
condition|(
name|uap
operator|->
name|rgid
condition|)
name|error1
operator|=
name|copyout
argument_list|(
operator|&
name|cred
operator|->
name|cr_rgid
argument_list|,
name|uap
operator|->
name|rgid
argument_list|,
sizeof|sizeof
argument_list|(
name|cred
operator|->
name|cr_rgid
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|uap
operator|->
name|egid
condition|)
name|error2
operator|=
name|copyout
argument_list|(
operator|&
name|cred
operator|->
name|cr_groups
index|[
literal|0
index|]
argument_list|,
name|uap
operator|->
name|egid
argument_list|,
sizeof|sizeof
argument_list|(
name|cred
operator|->
name|cr_groups
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|uap
operator|->
name|sgid
condition|)
name|error3
operator|=
name|copyout
argument_list|(
operator|&
name|cred
operator|->
name|cr_svgid
argument_list|,
name|uap
operator|->
name|sgid
argument_list|,
sizeof|sizeof
argument_list|(
name|cred
operator|->
name|cr_svgid
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|error1
condition|?
name|error1
else|:
name|error2
condition|?
name|error2
else|:
name|error3
operator|)
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|_SYS_SYSPROTO_H_
end_ifndef

begin_struct
struct|struct
name|issetugid_args
block|{
name|int
name|dummy
decl_stmt|;
block|}
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * MPSAFE  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|issetugid
parameter_list|(
specifier|register
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|issetugid_args
modifier|*
name|uap
parameter_list|)
block|{
name|struct
name|proc
modifier|*
name|p
init|=
name|td
operator|->
name|td_proc
decl_stmt|;
comment|/* 	 * Note: OpenBSD sets a P_SUGIDEXEC flag set at execve() time, 	 * we use P_SUGID because we consider changing the owners as 	 * "tainting" as well. 	 * This is significant for procs that start as root and "become" 	 * a user without an exec - programs cannot know *everything* 	 * that libc *might* have put in their data segment. 	 */
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|=
operator|(
name|p
operator|->
name|p_flag
operator|&
name|P_SUGID
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * MPSAFE  */
end_comment

begin_function
name|int
name|__setugid
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|__setugid_args
modifier|*
name|uap
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|REGRESSION
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|td
operator|->
name|td_proc
expr_stmt|;
switch|switch
condition|(
name|uap
operator|->
name|flag
condition|)
block|{
case|case
literal|0
case|:
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|->
name|p_flag
operator|&=
operator|~
name|P_SUGID
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
literal|1
case|:
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|->
name|p_flag
operator||=
name|P_SUGID
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
default|default:
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
else|#
directive|else
comment|/* !REGRESSION */
return|return
operator|(
name|ENOSYS
operator|)
return|;
endif|#
directive|endif
comment|/* REGRESSION */
block|}
end_function

begin_comment
comment|/*  * Check if gid is a member of the group set.  *  * MPSAFE (cred must be held)  */
end_comment

begin_function
name|int
name|groupmember
parameter_list|(
name|gid_t
name|gid
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|)
block|{
specifier|register
name|gid_t
modifier|*
name|gp
decl_stmt|;
name|gid_t
modifier|*
name|egp
decl_stmt|;
name|egp
operator|=
operator|&
operator|(
name|cred
operator|->
name|cr_groups
index|[
name|cred
operator|->
name|cr_ngroups
index|]
operator|)
expr_stmt|;
for|for
control|(
name|gp
operator|=
name|cred
operator|->
name|cr_groups
init|;
name|gp
operator|<
name|egp
condition|;
name|gp
operator|++
control|)
if|if
condition|(
operator|*
name|gp
operator|==
name|gid
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * `suser_enabled' (which can be set by the security.suser_enabled  * sysctl) determines whether the system 'super-user' policy is in effect.  * If it is nonzero, an effective uid of 0 connotes special privilege,  * overriding many mandatory and discretionary protections.  If it is zero,  * uid 0 is offered no special privilege in the kernel security policy.  * Setting it to zero may seriously impact the functionality of many  * existing userland programs, and should not be done without careful  * consideration of the consequences.  */
end_comment

begin_decl_stmt
name|int
name|suser_enabled
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_security_bsd
argument_list|,
name|OID_AUTO
argument_list|,
name|suser_enabled
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|suser_enabled
argument_list|,
literal|0
argument_list|,
literal|"processes with uid 0 have privilege"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"security.bsd.suser_enabled"
argument_list|,
operator|&
name|suser_enabled
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Test whether the specified credentials imply "super-user" privilege.  * Return 0 or EPERM.  */
end_comment

begin_function
name|int
name|suser_cred
parameter_list|(
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|int
name|flag
parameter_list|)
block|{
if|if
condition|(
operator|!
name|suser_enabled
condition|)
return|return
operator|(
name|EPERM
operator|)
return|;
if|if
condition|(
operator|(
operator|(
name|flag
operator|&
name|SUSER_RUID
operator|)
condition|?
name|cred
operator|->
name|cr_ruid
else|:
name|cred
operator|->
name|cr_uid
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|EPERM
operator|)
return|;
if|if
condition|(
name|jailed
argument_list|(
name|cred
argument_list|)
operator|&&
operator|!
operator|(
name|flag
operator|&
name|SUSER_ALLOWJAIL
operator|)
condition|)
return|return
operator|(
name|EPERM
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Shortcut to hide contents of struct td and struct proc from the  * caller, promoting binary compatibility.  */
end_comment

begin_function
name|int
name|suser
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|INVARIANTS
if|if
condition|(
name|td
operator|!=
name|curthread
condition|)
block|{
name|printf
argument_list|(
literal|"suser: thread %p (%d %s) != curthread %p (%d %s)\n"
argument_list|,
name|td
argument_list|,
name|td
operator|->
name|td_proc
operator|->
name|p_pid
argument_list|,
name|td
operator|->
name|td_proc
operator|->
name|p_comm
argument_list|,
name|curthread
argument_list|,
name|curthread
operator|->
name|td_proc
operator|->
name|p_pid
argument_list|,
name|curthread
operator|->
name|td_proc
operator|->
name|p_comm
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|KDB
name|kdb_backtrace
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
endif|#
directive|endif
return|return
operator|(
name|suser_cred
argument_list|(
name|td
operator|->
name|td_ucred
argument_list|,
literal|0
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Test the active securelevel against a given level.  securelevel_gt()  * implements (securelevel> level).  securelevel_ge() implements  * (securelevel>= level).  Note that the logic is inverted -- these  * functions return EPERM on "success" and 0 on "failure".  *  * MPSAFE  */
end_comment

begin_function
name|int
name|securelevel_gt
parameter_list|(
name|struct
name|ucred
modifier|*
name|cr
parameter_list|,
name|int
name|level
parameter_list|)
block|{
name|int
name|active_securelevel
decl_stmt|;
name|active_securelevel
operator|=
name|securelevel
expr_stmt|;
name|KASSERT
argument_list|(
name|cr
operator|!=
name|NULL
argument_list|,
operator|(
literal|"securelevel_gt: null cr"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cr
operator|->
name|cr_prison
operator|!=
name|NULL
condition|)
name|active_securelevel
operator|=
name|imax
argument_list|(
name|cr
operator|->
name|cr_prison
operator|->
name|pr_securelevel
argument_list|,
name|active_securelevel
argument_list|)
expr_stmt|;
return|return
operator|(
name|active_securelevel
operator|>
name|level
condition|?
name|EPERM
else|:
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|securelevel_ge
parameter_list|(
name|struct
name|ucred
modifier|*
name|cr
parameter_list|,
name|int
name|level
parameter_list|)
block|{
name|int
name|active_securelevel
decl_stmt|;
name|active_securelevel
operator|=
name|securelevel
expr_stmt|;
name|KASSERT
argument_list|(
name|cr
operator|!=
name|NULL
argument_list|,
operator|(
literal|"securelevel_ge: null cr"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cr
operator|->
name|cr_prison
operator|!=
name|NULL
condition|)
name|active_securelevel
operator|=
name|imax
argument_list|(
name|cr
operator|->
name|cr_prison
operator|->
name|pr_securelevel
argument_list|,
name|active_securelevel
argument_list|)
expr_stmt|;
return|return
operator|(
name|active_securelevel
operator|>=
name|level
condition|?
name|EPERM
else|:
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * 'see_other_uids' determines whether or not visibility of processes  * and sockets with credentials holding different real uids is possible  * using a variety of system MIBs.  * XXX: data declarations should be together near the beginning of the file.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|see_other_uids
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_security_bsd
argument_list|,
name|OID_AUTO
argument_list|,
name|see_other_uids
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|see_other_uids
argument_list|,
literal|0
argument_list|,
literal|"Unprivileged processes may see subjects/objects with different real uid"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*-  * Determine if u1 "can see" the subject specified by u2, according to the  * 'see_other_uids' policy.  * Returns: 0 for permitted, ESRCH otherwise  * Locks: none  * References: *u1 and *u2 must not change during the call  *             u1 may equal u2, in which case only one reference is required  */
end_comment

begin_function
specifier|static
name|int
name|cr_seeotheruids
parameter_list|(
name|struct
name|ucred
modifier|*
name|u1
parameter_list|,
name|struct
name|ucred
modifier|*
name|u2
parameter_list|)
block|{
if|if
condition|(
operator|!
name|see_other_uids
operator|&&
name|u1
operator|->
name|cr_ruid
operator|!=
name|u2
operator|->
name|cr_ruid
condition|)
block|{
if|if
condition|(
name|suser_cred
argument_list|(
name|u1
argument_list|,
name|SUSER_ALLOWJAIL
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|ESRCH
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * 'see_other_gids' determines whether or not visibility of processes  * and sockets with credentials holding different real gids is possible  * using a variety of system MIBs.  * XXX: data declarations should be together near the beginning of the file.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|see_other_gids
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_security_bsd
argument_list|,
name|OID_AUTO
argument_list|,
name|see_other_gids
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|see_other_gids
argument_list|,
literal|0
argument_list|,
literal|"Unprivileged processes may see subjects/objects with different real gid"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Determine if u1 can "see" the subject specified by u2, according to the  * 'see_other_gids' policy.  * Returns: 0 for permitted, ESRCH otherwise  * Locks: none  * References: *u1 and *u2 must not change during the call  *             u1 may equal u2, in which case only one reference is required  */
end_comment

begin_function
specifier|static
name|int
name|cr_seeothergids
parameter_list|(
name|struct
name|ucred
modifier|*
name|u1
parameter_list|,
name|struct
name|ucred
modifier|*
name|u2
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|match
decl_stmt|;
if|if
condition|(
operator|!
name|see_other_gids
condition|)
block|{
name|match
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|u1
operator|->
name|cr_ngroups
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|groupmember
argument_list|(
name|u1
operator|->
name|cr_groups
index|[
name|i
index|]
argument_list|,
name|u2
argument_list|)
condition|)
name|match
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|match
condition|)
break|break;
block|}
if|if
condition|(
operator|!
name|match
condition|)
block|{
if|if
condition|(
name|suser_cred
argument_list|(
name|u1
argument_list|,
name|SUSER_ALLOWJAIL
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|ESRCH
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*-  * Determine if u1 "can see" the subject specified by u2.  * Returns: 0 for permitted, an errno value otherwise  * Locks: none  * References: *u1 and *u2 must not change during the call  *             u1 may equal u2, in which case only one reference is required  */
end_comment

begin_function
name|int
name|cr_cansee
parameter_list|(
name|struct
name|ucred
modifier|*
name|u1
parameter_list|,
name|struct
name|ucred
modifier|*
name|u2
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|prison_check
argument_list|(
name|u1
argument_list|,
name|u2
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
ifdef|#
directive|ifdef
name|MAC
if|if
condition|(
operator|(
name|error
operator|=
name|mac_check_cred_visible
argument_list|(
name|u1
argument_list|,
name|u2
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|error
operator|=
name|cr_seeotheruids
argument_list|(
name|u1
argument_list|,
name|u2
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
operator|(
name|error
operator|=
name|cr_seeothergids
argument_list|(
name|u1
argument_list|,
name|u2
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*-  * Determine if td "can see" the subject specified by p.  * Returns: 0 for permitted, an errno value otherwise  * Locks: Sufficient locks to protect p->p_ucred must be held.  td really  *        should be curthread.  * References: td and p must be valid for the lifetime of the call  */
end_comment

begin_function
name|int
name|p_cansee
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
comment|/* Wrap cr_cansee() for all functionality. */
name|KASSERT
argument_list|(
name|td
operator|==
name|curthread
argument_list|,
operator|(
literal|"%s: td not curthread"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|PROC_LOCK_ASSERT
argument_list|(
name|p
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
return|return
operator|(
name|cr_cansee
argument_list|(
name|td
operator|->
name|td_ucred
argument_list|,
name|p
operator|->
name|p_ucred
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * 'conservative_signals' prevents the delivery of a broad class of  * signals by unprivileged processes to processes that have changed their  * credentials since the last invocation of execve().  This can prevent  * the leakage of cached information or retained privileges as a result  * of a common class of signal-related vulnerabilities.  However, this  * may interfere with some applications that expect to be able to  * deliver these signals to peer processes after having given up  * privilege.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|conservative_signals
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_security_bsd
argument_list|,
name|OID_AUTO
argument_list|,
name|conservative_signals
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|conservative_signals
argument_list|,
literal|0
argument_list|,
literal|"Unprivileged processes prevented from "
literal|"sending certain signals to processes whose credentials have changed"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*-  * Determine whether cred may deliver the specified signal to proc.  * Returns: 0 for permitted, an errno value otherwise.  * Locks: A lock must be held for proc.  * References: cred and proc must be valid for the lifetime of the call.  */
end_comment

begin_function
name|int
name|cr_cansignal
parameter_list|(
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|struct
name|proc
modifier|*
name|proc
parameter_list|,
name|int
name|signum
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|PROC_LOCK_ASSERT
argument_list|(
name|proc
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
comment|/* 	 * Jail semantics limit the scope of signalling to proc in the 	 * same jail as cred, if cred is in jail. 	 */
name|error
operator|=
name|prison_check
argument_list|(
name|cred
argument_list|,
name|proc
operator|->
name|p_ucred
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
ifdef|#
directive|ifdef
name|MAC
if|if
condition|(
operator|(
name|error
operator|=
name|mac_check_proc_signal
argument_list|(
name|cred
argument_list|,
name|proc
argument_list|,
name|signum
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|error
operator|=
name|cr_seeotheruids
argument_list|(
name|cred
argument_list|,
name|proc
operator|->
name|p_ucred
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
operator|(
name|error
operator|=
name|cr_seeothergids
argument_list|(
name|cred
argument_list|,
name|proc
operator|->
name|p_ucred
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* 	 * UNIX signal semantics depend on the status of the P_SUGID 	 * bit on the target process.  If the bit is set, then additional 	 * restrictions are placed on the set of available signals. 	 */
if|if
condition|(
name|conservative_signals
operator|&&
operator|(
name|proc
operator|->
name|p_flag
operator|&
name|P_SUGID
operator|)
condition|)
block|{
switch|switch
condition|(
name|signum
condition|)
block|{
case|case
literal|0
case|:
case|case
name|SIGKILL
case|:
case|case
name|SIGINT
case|:
case|case
name|SIGTERM
case|:
case|case
name|SIGALRM
case|:
case|case
name|SIGSTOP
case|:
case|case
name|SIGTTIN
case|:
case|case
name|SIGTTOU
case|:
case|case
name|SIGTSTP
case|:
case|case
name|SIGHUP
case|:
case|case
name|SIGUSR1
case|:
case|case
name|SIGUSR2
case|:
comment|/* 			 * Generally, permit job and terminal control 			 * signals. 			 */
break|break;
default|default:
comment|/* Not permitted without privilege. */
name|error
operator|=
name|suser_cred
argument_list|(
name|cred
argument_list|,
name|SUSER_ALLOWJAIL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
comment|/* 	 * Generally, the target credential's ruid or svuid must match the 	 * subject credential's ruid or euid. 	 */
if|if
condition|(
name|cred
operator|->
name|cr_ruid
operator|!=
name|proc
operator|->
name|p_ucred
operator|->
name|cr_ruid
operator|&&
name|cred
operator|->
name|cr_ruid
operator|!=
name|proc
operator|->
name|p_ucred
operator|->
name|cr_svuid
operator|&&
name|cred
operator|->
name|cr_uid
operator|!=
name|proc
operator|->
name|p_ucred
operator|->
name|cr_ruid
operator|&&
name|cred
operator|->
name|cr_uid
operator|!=
name|proc
operator|->
name|p_ucred
operator|->
name|cr_svuid
condition|)
block|{
comment|/* Not permitted without privilege. */
name|error
operator|=
name|suser_cred
argument_list|(
name|cred
argument_list|,
name|SUSER_ALLOWJAIL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*-  * Determine whether td may deliver the specified signal to p.  * Returns: 0 for permitted, an errno value otherwise  * Locks: Sufficient locks to protect various components of td and p  *        must be held.  td must be curthread, and a lock must be  *        held for p.  * References: td and p must be valid for the lifetime of the call  */
end_comment

begin_function
name|int
name|p_cansignal
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|,
name|int
name|signum
parameter_list|)
block|{
name|KASSERT
argument_list|(
name|td
operator|==
name|curthread
argument_list|,
operator|(
literal|"%s: td not curthread"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|PROC_LOCK_ASSERT
argument_list|(
name|p
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
if|if
condition|(
name|td
operator|->
name|td_proc
operator|==
name|p
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * UNIX signalling semantics require that processes in the same 	 * session always be able to deliver SIGCONT to one another, 	 * overriding the remaining protections. 	 */
comment|/* XXX: This will require an additional lock of some sort. */
if|if
condition|(
name|signum
operator|==
name|SIGCONT
operator|&&
name|td
operator|->
name|td_proc
operator|->
name|p_session
operator|==
name|p
operator|->
name|p_session
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * Some compat layers use SIGTHR and higher signals for 	 * communication between different kernel threads of the same 	 * process, so that they expect that it's always possible to 	 * deliver them, even for suid applications where cr_cansignal() can 	 * deny such ability for security consideration.  It should be 	 * pretty safe to do since the only way to create two processes 	 * with the same p_leader is via rfork(2). 	 */
if|if
condition|(
name|td
operator|->
name|td_proc
operator|->
name|p_leader
operator|!=
name|NULL
operator|&&
name|signum
operator|>=
name|SIGTHR
operator|&&
name|signum
operator|<
name|SIGTHR
operator|+
literal|4
operator|&&
name|td
operator|->
name|td_proc
operator|->
name|p_leader
operator|==
name|p
operator|->
name|p_leader
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
name|cr_cansignal
argument_list|(
name|td
operator|->
name|td_ucred
argument_list|,
name|p
argument_list|,
name|signum
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*-  * Determine whether td may reschedule p.  * Returns: 0 for permitted, an errno value otherwise  * Locks: Sufficient locks to protect various components of td and p  *        must be held.  td must be curthread, and a lock must  *        be held for p.  * References: td and p must be valid for the lifetime of the call  */
end_comment

begin_function
name|int
name|p_cansched
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|KASSERT
argument_list|(
name|td
operator|==
name|curthread
argument_list|,
operator|(
literal|"%s: td not curthread"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|PROC_LOCK_ASSERT
argument_list|(
name|p
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
if|if
condition|(
name|td
operator|->
name|td_proc
operator|==
name|p
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|(
name|error
operator|=
name|prison_check
argument_list|(
name|td
operator|->
name|td_ucred
argument_list|,
name|p
operator|->
name|p_ucred
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
ifdef|#
directive|ifdef
name|MAC
if|if
condition|(
operator|(
name|error
operator|=
name|mac_check_proc_sched
argument_list|(
name|td
operator|->
name|td_ucred
argument_list|,
name|p
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|error
operator|=
name|cr_seeotheruids
argument_list|(
name|td
operator|->
name|td_ucred
argument_list|,
name|p
operator|->
name|p_ucred
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
operator|(
name|error
operator|=
name|cr_seeothergids
argument_list|(
name|td
operator|->
name|td_ucred
argument_list|,
name|p
operator|->
name|p_ucred
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|td
operator|->
name|td_ucred
operator|->
name|cr_ruid
operator|==
name|p
operator|->
name|p_ucred
operator|->
name|cr_ruid
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|td
operator|->
name|td_ucred
operator|->
name|cr_uid
operator|==
name|p
operator|->
name|p_ucred
operator|->
name|cr_ruid
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|suser_cred
argument_list|(
name|td
operator|->
name|td_ucred
argument_list|,
name|SUSER_ALLOWJAIL
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
ifdef|#
directive|ifdef
name|CAPABILITIES
if|if
condition|(
operator|!
name|cap_check
argument_list|(
name|NULL
argument_list|,
name|td
argument_list|,
name|CAP_SYS_NICE
argument_list|,
name|SUSER_ALLOWJAIL
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
endif|#
directive|endif
return|return
operator|(
name|EPERM
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * The 'unprivileged_proc_debug' flag may be used to disable a variety of  * unprivileged inter-process debugging services, including some procfs  * functionality, ptrace(), and ktrace().  In the past, inter-process  * debugging has been involved in a variety of security problems, and sites  * not requiring the service might choose to disable it when hardening  * systems.  *  * XXX: Should modifying and reading this variable require locking?  * XXX: data declarations should be together near the beginning of the file.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|unprivileged_proc_debug
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_security_bsd
argument_list|,
name|OID_AUTO
argument_list|,
name|unprivileged_proc_debug
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|unprivileged_proc_debug
argument_list|,
literal|0
argument_list|,
literal|"Unprivileged processes may use process debugging facilities"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*-  * Determine whether td may debug p.  * Returns: 0 for permitted, an errno value otherwise  * Locks: Sufficient locks to protect various components of td and p  *        must be held.  td must be curthread, and a lock must  *        be held for p.  * References: td and p must be valid for the lifetime of the call  */
end_comment

begin_function
name|int
name|p_candebug
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|int
name|credentialchanged
decl_stmt|,
name|error
decl_stmt|,
name|grpsubset
decl_stmt|,
name|i
decl_stmt|,
name|uidsubset
decl_stmt|;
name|KASSERT
argument_list|(
name|td
operator|==
name|curthread
argument_list|,
operator|(
literal|"%s: td not curthread"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|PROC_LOCK_ASSERT
argument_list|(
name|p
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|unprivileged_proc_debug
condition|)
block|{
name|error
operator|=
name|suser_cred
argument_list|(
name|td
operator|->
name|td_ucred
argument_list|,
name|SUSER_ALLOWJAIL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
name|td
operator|->
name|td_proc
operator|==
name|p
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|(
name|error
operator|=
name|prison_check
argument_list|(
name|td
operator|->
name|td_ucred
argument_list|,
name|p
operator|->
name|p_ucred
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
ifdef|#
directive|ifdef
name|MAC
if|if
condition|(
operator|(
name|error
operator|=
name|mac_check_proc_debug
argument_list|(
name|td
operator|->
name|td_ucred
argument_list|,
name|p
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|error
operator|=
name|cr_seeotheruids
argument_list|(
name|td
operator|->
name|td_ucred
argument_list|,
name|p
operator|->
name|p_ucred
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
operator|(
name|error
operator|=
name|cr_seeothergids
argument_list|(
name|td
operator|->
name|td_ucred
argument_list|,
name|p
operator|->
name|p_ucred
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* 	 * Is p's group set a subset of td's effective group set?  This 	 * includes p's egid, group access list, rgid, and svgid. 	 */
name|grpsubset
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|p
operator|->
name|p_ucred
operator|->
name|cr_ngroups
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|groupmember
argument_list|(
name|p
operator|->
name|p_ucred
operator|->
name|cr_groups
index|[
name|i
index|]
argument_list|,
name|td
operator|->
name|td_ucred
argument_list|)
condition|)
block|{
name|grpsubset
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
name|grpsubset
operator|=
name|grpsubset
operator|&&
name|groupmember
argument_list|(
name|p
operator|->
name|p_ucred
operator|->
name|cr_rgid
argument_list|,
name|td
operator|->
name|td_ucred
argument_list|)
operator|&&
name|groupmember
argument_list|(
name|p
operator|->
name|p_ucred
operator|->
name|cr_svgid
argument_list|,
name|td
operator|->
name|td_ucred
argument_list|)
expr_stmt|;
comment|/* 	 * Are the uids present in p's credential equal to td's 	 * effective uid?  This includes p's euid, svuid, and ruid. 	 */
name|uidsubset
operator|=
operator|(
name|td
operator|->
name|td_ucred
operator|->
name|cr_uid
operator|==
name|p
operator|->
name|p_ucred
operator|->
name|cr_uid
operator|&&
name|td
operator|->
name|td_ucred
operator|->
name|cr_uid
operator|==
name|p
operator|->
name|p_ucred
operator|->
name|cr_svuid
operator|&&
name|td
operator|->
name|td_ucred
operator|->
name|cr_uid
operator|==
name|p
operator|->
name|p_ucred
operator|->
name|cr_ruid
operator|)
expr_stmt|;
comment|/* 	 * Has the credential of the process changed since the last exec()? 	 */
name|credentialchanged
operator|=
operator|(
name|p
operator|->
name|p_flag
operator|&
name|P_SUGID
operator|)
expr_stmt|;
comment|/* 	 * If p's gids aren't a subset, or the uids aren't a subset, 	 * or the credential has changed, require appropriate privilege 	 * for td to debug p.  For POSIX.1e capabilities, this will 	 * require CAP_SYS_PTRACE. 	 */
if|if
condition|(
operator|!
name|grpsubset
operator|||
operator|!
name|uidsubset
operator|||
name|credentialchanged
condition|)
block|{
name|error
operator|=
name|suser_cred
argument_list|(
name|td
operator|->
name|td_ucred
argument_list|,
name|SUSER_ALLOWJAIL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* Can't trace init when securelevel> 0. */
if|if
condition|(
name|p
operator|==
name|initproc
condition|)
block|{
name|error
operator|=
name|securelevel_gt
argument_list|(
name|td
operator|->
name|td_ucred
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* 	 * Can't trace a process that's currently exec'ing. 	 * XXX: Note, this is not a security policy decision, it's a 	 * basic correctness/functionality decision.  Therefore, this check 	 * should be moved to the caller's of p_candebug(). 	 */
if|if
condition|(
operator|(
name|p
operator|->
name|p_flag
operator|&
name|P_INEXEC
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|EAGAIN
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*-  * Determine whether the subject represented by cred can "see" a socket.  * Returns: 0 for permitted, ENOENT otherwise.  */
end_comment

begin_function
name|int
name|cr_canseesocket
parameter_list|(
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|struct
name|socket
modifier|*
name|so
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|error
operator|=
name|prison_check
argument_list|(
name|cred
argument_list|,
name|so
operator|->
name|so_cred
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|ENOENT
operator|)
return|;
ifdef|#
directive|ifdef
name|MAC
name|SOCK_LOCK
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|error
operator|=
name|mac_check_socket_visible
argument_list|(
name|cred
argument_list|,
name|so
argument_list|)
expr_stmt|;
name|SOCK_UNLOCK
argument_list|(
name|so
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
endif|#
directive|endif
if|if
condition|(
name|cr_seeotheruids
argument_list|(
name|cred
argument_list|,
name|so
operator|->
name|so_cred
argument_list|)
condition|)
return|return
operator|(
name|ENOENT
operator|)
return|;
if|if
condition|(
name|cr_seeothergids
argument_list|(
name|cred
argument_list|,
name|so
operator|->
name|so_cred
argument_list|)
condition|)
return|return
operator|(
name|ENOENT
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*-  * Determine whether td can wait for the exit of p.  * Returns: 0 for permitted, an errno value otherwise  * Locks: Sufficient locks to protect various components of td and p  *        must be held.  td must be curthread, and a lock must  *        be held for p.  * References: td and p must be valid for the lifetime of the call   */
end_comment

begin_function
name|int
name|p_canwait
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|KASSERT
argument_list|(
name|td
operator|==
name|curthread
argument_list|,
operator|(
literal|"%s: td not curthread"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|PROC_LOCK_ASSERT
argument_list|(
name|p
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|prison_check
argument_list|(
name|td
operator|->
name|td_ucred
argument_list|,
name|p
operator|->
name|p_ucred
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
ifdef|#
directive|ifdef
name|MAC
if|if
condition|(
operator|(
name|error
operator|=
name|mac_check_proc_wait
argument_list|(
name|td
operator|->
name|td_ucred
argument_list|,
name|p
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
endif|#
directive|endif
if|#
directive|if
literal|0
comment|/* XXXMAC: This could have odd effects on some shells. */
block|if ((error = cr_seeotheruids(td->td_ucred, p->p_ucred))) 		return (error);
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Allocate a zeroed cred structure.  * MPSAFE  */
end_comment

begin_function
name|struct
name|ucred
modifier|*
name|crget
parameter_list|(
name|void
parameter_list|)
block|{
specifier|register
name|struct
name|ucred
modifier|*
name|cr
decl_stmt|;
name|MALLOC
argument_list|(
name|cr
argument_list|,
expr|struct
name|ucred
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|cr
argument_list|)
argument_list|,
name|M_CRED
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|refcount_init
argument_list|(
operator|&
name|cr
operator|->
name|cr_ref
argument_list|,
literal|1
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MAC
name|mac_init_cred
argument_list|(
name|cr
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|cr
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Claim another reference to a ucred structure.  * MPSAFE  */
end_comment

begin_function
name|struct
name|ucred
modifier|*
name|crhold
parameter_list|(
name|struct
name|ucred
modifier|*
name|cr
parameter_list|)
block|{
name|refcount_acquire
argument_list|(
operator|&
name|cr
operator|->
name|cr_ref
argument_list|)
expr_stmt|;
return|return
operator|(
name|cr
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Free a cred structure.  * Throws away space when ref count gets to 0.  * MPSAFE  */
end_comment

begin_function
name|void
name|crfree
parameter_list|(
name|struct
name|ucred
modifier|*
name|cr
parameter_list|)
block|{
name|KASSERT
argument_list|(
name|cr
operator|->
name|cr_ref
operator|>
literal|0
argument_list|,
operator|(
literal|"bad ucred refcount: %d"
operator|,
name|cr
operator|->
name|cr_ref
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|cr
operator|->
name|cr_ref
operator|!=
literal|0xdeadc0de
argument_list|,
operator|(
literal|"dangling reference to ucred"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|refcount_release
argument_list|(
operator|&
name|cr
operator|->
name|cr_ref
argument_list|)
condition|)
block|{
comment|/* 		 * Some callers of crget(), such as nfs_statfs(), 		 * allocate a temporary credential, but don't 		 * allocate a uidinfo structure. 		 */
if|if
condition|(
name|cr
operator|->
name|cr_uidinfo
operator|!=
name|NULL
condition|)
name|uifree
argument_list|(
name|cr
operator|->
name|cr_uidinfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|cr
operator|->
name|cr_ruidinfo
operator|!=
name|NULL
condition|)
name|uifree
argument_list|(
name|cr
operator|->
name|cr_ruidinfo
argument_list|)
expr_stmt|;
comment|/* 		 * Free a prison, if any. 		 */
if|if
condition|(
name|jailed
argument_list|(
name|cr
argument_list|)
condition|)
name|prison_free
argument_list|(
name|cr
operator|->
name|cr_prison
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MAC
name|mac_destroy_cred
argument_list|(
name|cr
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|FREE
argument_list|(
name|cr
argument_list|,
name|M_CRED
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Check to see if this ucred is shared.  * MPSAFE  */
end_comment

begin_function
name|int
name|crshared
parameter_list|(
name|struct
name|ucred
modifier|*
name|cr
parameter_list|)
block|{
return|return
operator|(
name|cr
operator|->
name|cr_ref
operator|>
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Copy a ucred's contents from a template.  Does not block.  * MPSAFE  */
end_comment

begin_function
name|void
name|crcopy
parameter_list|(
name|struct
name|ucred
modifier|*
name|dest
parameter_list|,
name|struct
name|ucred
modifier|*
name|src
parameter_list|)
block|{
name|KASSERT
argument_list|(
name|crshared
argument_list|(
name|dest
argument_list|)
operator|==
literal|0
argument_list|,
operator|(
literal|"crcopy of shared ucred"
operator|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|src
operator|->
name|cr_startcopy
argument_list|,
operator|&
name|dest
operator|->
name|cr_startcopy
argument_list|,
call|(
name|unsigned
call|)
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|src
operator|->
name|cr_endcopy
operator|-
operator|(
name|caddr_t
operator|)
operator|&
name|src
operator|->
name|cr_startcopy
argument_list|)
argument_list|)
expr_stmt|;
name|uihold
argument_list|(
name|dest
operator|->
name|cr_uidinfo
argument_list|)
expr_stmt|;
name|uihold
argument_list|(
name|dest
operator|->
name|cr_ruidinfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|jailed
argument_list|(
name|dest
argument_list|)
condition|)
name|prison_hold
argument_list|(
name|dest
operator|->
name|cr_prison
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MAC
name|mac_copy_cred
argument_list|(
name|src
argument_list|,
name|dest
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * Dup cred struct to a new held one.  * MPSAFE  */
end_comment

begin_function
name|struct
name|ucred
modifier|*
name|crdup
parameter_list|(
name|struct
name|ucred
modifier|*
name|cr
parameter_list|)
block|{
name|struct
name|ucred
modifier|*
name|newcr
decl_stmt|;
name|newcr
operator|=
name|crget
argument_list|()
expr_stmt|;
name|crcopy
argument_list|(
name|newcr
argument_list|,
name|cr
argument_list|)
expr_stmt|;
return|return
operator|(
name|newcr
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Fill in a struct xucred based on a struct ucred.  * MPSAFE  */
end_comment

begin_function
name|void
name|cru2x
parameter_list|(
name|struct
name|ucred
modifier|*
name|cr
parameter_list|,
name|struct
name|xucred
modifier|*
name|xcr
parameter_list|)
block|{
name|bzero
argument_list|(
name|xcr
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|xcr
argument_list|)
argument_list|)
expr_stmt|;
name|xcr
operator|->
name|cr_version
operator|=
name|XUCRED_VERSION
expr_stmt|;
name|xcr
operator|->
name|cr_uid
operator|=
name|cr
operator|->
name|cr_uid
expr_stmt|;
name|xcr
operator|->
name|cr_ngroups
operator|=
name|cr
operator|->
name|cr_ngroups
expr_stmt|;
name|bcopy
argument_list|(
name|cr
operator|->
name|cr_groups
argument_list|,
name|xcr
operator|->
name|cr_groups
argument_list|,
sizeof|sizeof
argument_list|(
name|cr
operator|->
name|cr_groups
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * small routine to swap a thread's current ucred for the correct one  * taken from the process.  * MPSAFE  */
end_comment

begin_function
name|void
name|cred_update_thread
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|struct
name|ucred
modifier|*
name|cred
decl_stmt|;
name|p
operator|=
name|td
operator|->
name|td_proc
expr_stmt|;
name|cred
operator|=
name|td
operator|->
name|td_ucred
expr_stmt|;
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|td
operator|->
name|td_ucred
operator|=
name|crhold
argument_list|(
name|p
operator|->
name|p_ucred
argument_list|)
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|cred
operator|!=
name|NULL
condition|)
name|crfree
argument_list|(
name|cred
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Get login name, if available.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|_SYS_SYSPROTO_H_
end_ifndef

begin_struct
struct|struct
name|getlogin_args
block|{
name|char
modifier|*
name|namebuf
decl_stmt|;
name|u_int
name|namelen
decl_stmt|;
block|}
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * MPSAFE  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|getlogin
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|getlogin_args
modifier|*
name|uap
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|char
name|login
index|[
name|MAXLOGNAME
index|]
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
init|=
name|td
operator|->
name|td_proc
decl_stmt|;
if|if
condition|(
name|uap
operator|->
name|namelen
operator|>
name|MAXLOGNAME
condition|)
name|uap
operator|->
name|namelen
operator|=
name|MAXLOGNAME
expr_stmt|;
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|SESS_LOCK
argument_list|(
name|p
operator|->
name|p_session
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|p
operator|->
name|p_session
operator|->
name|s_login
argument_list|,
name|login
argument_list|,
name|uap
operator|->
name|namelen
argument_list|)
expr_stmt|;
name|SESS_UNLOCK
argument_list|(
name|p
operator|->
name|p_session
argument_list|)
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|error
operator|=
name|copyout
argument_list|(
name|login
argument_list|,
name|uap
operator|->
name|namebuf
argument_list|,
name|uap
operator|->
name|namelen
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Set login name.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|_SYS_SYSPROTO_H_
end_ifndef

begin_struct
struct|struct
name|setlogin_args
block|{
name|char
modifier|*
name|namebuf
decl_stmt|;
block|}
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * MPSAFE  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|setlogin
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|setlogin_args
modifier|*
name|uap
parameter_list|)
block|{
name|struct
name|proc
modifier|*
name|p
init|=
name|td
operator|->
name|td_proc
decl_stmt|;
name|int
name|error
decl_stmt|;
name|char
name|logintmp
index|[
name|MAXLOGNAME
index|]
decl_stmt|;
name|error
operator|=
name|suser_cred
argument_list|(
name|td
operator|->
name|td_ucred
argument_list|,
name|SUSER_ALLOWJAIL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|error
operator|=
name|copyinstr
argument_list|(
name|uap
operator|->
name|namebuf
argument_list|,
name|logintmp
argument_list|,
sizeof|sizeof
argument_list|(
name|logintmp
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|ENAMETOOLONG
condition|)
name|error
operator|=
name|EINVAL
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|error
condition|)
block|{
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|SESS_LOCK
argument_list|(
name|p
operator|->
name|p_session
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|memcpy
argument_list|(
name|p
operator|->
name|p_session
operator|->
name|s_login
argument_list|,
name|logintmp
argument_list|,
sizeof|sizeof
argument_list|(
name|logintmp
argument_list|)
argument_list|)
expr_stmt|;
name|SESS_UNLOCK
argument_list|(
name|p
operator|->
name|p_session
argument_list|)
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|void
name|setsugid
parameter_list|(
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|PROC_LOCK_ASSERT
argument_list|(
name|p
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|p
operator|->
name|p_flag
operator||=
name|P_SUGID
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|p
operator|->
name|p_pfsflags
operator|&
name|PF_ISUGID
operator|)
condition|)
name|p
operator|->
name|p_stops
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*-  * Change a process's effective uid.  * Side effects: newcred->cr_uid and newcred->cr_uidinfo will be modified.  * References: newcred must be an exclusive credential reference for the  *             duration of the call.  */
end_comment

begin_function
name|void
name|change_euid
parameter_list|(
name|struct
name|ucred
modifier|*
name|newcred
parameter_list|,
name|struct
name|uidinfo
modifier|*
name|euip
parameter_list|)
block|{
name|newcred
operator|->
name|cr_uid
operator|=
name|euip
operator|->
name|ui_uid
expr_stmt|;
name|uihold
argument_list|(
name|euip
argument_list|)
expr_stmt|;
name|uifree
argument_list|(
name|newcred
operator|->
name|cr_uidinfo
argument_list|)
expr_stmt|;
name|newcred
operator|->
name|cr_uidinfo
operator|=
name|euip
expr_stmt|;
block|}
end_function

begin_comment
comment|/*-  * Change a process's effective gid.  * Side effects: newcred->cr_gid will be modified.  * References: newcred must be an exclusive credential reference for the  *             duration of the call.  */
end_comment

begin_function
name|void
name|change_egid
parameter_list|(
name|struct
name|ucred
modifier|*
name|newcred
parameter_list|,
name|gid_t
name|egid
parameter_list|)
block|{
name|newcred
operator|->
name|cr_groups
index|[
literal|0
index|]
operator|=
name|egid
expr_stmt|;
block|}
end_function

begin_comment
comment|/*-  * Change a process's real uid.  * Side effects: newcred->cr_ruid will be updated, newcred->cr_ruidinfo  *               will be updated, and the old and new cr_ruidinfo proc  *               counts will be updated.  * References: newcred must be an exclusive credential reference for the  *             duration of the call.  */
end_comment

begin_function
name|void
name|change_ruid
parameter_list|(
name|struct
name|ucred
modifier|*
name|newcred
parameter_list|,
name|struct
name|uidinfo
modifier|*
name|ruip
parameter_list|)
block|{
operator|(
name|void
operator|)
name|chgproccnt
argument_list|(
name|newcred
operator|->
name|cr_ruidinfo
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|newcred
operator|->
name|cr_ruid
operator|=
name|ruip
operator|->
name|ui_uid
expr_stmt|;
name|uihold
argument_list|(
name|ruip
argument_list|)
expr_stmt|;
name|uifree
argument_list|(
name|newcred
operator|->
name|cr_ruidinfo
argument_list|)
expr_stmt|;
name|newcred
operator|->
name|cr_ruidinfo
operator|=
name|ruip
expr_stmt|;
operator|(
name|void
operator|)
name|chgproccnt
argument_list|(
name|newcred
operator|->
name|cr_ruidinfo
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*-  * Change a process's real gid.  * Side effects: newcred->cr_rgid will be updated.  * References: newcred must be an exclusive credential reference for the  *             duration of the call.  */
end_comment

begin_function
name|void
name|change_rgid
parameter_list|(
name|struct
name|ucred
modifier|*
name|newcred
parameter_list|,
name|gid_t
name|rgid
parameter_list|)
block|{
name|newcred
operator|->
name|cr_rgid
operator|=
name|rgid
expr_stmt|;
block|}
end_function

begin_comment
comment|/*-  * Change a process's saved uid.  * Side effects: newcred->cr_svuid will be updated.  * References: newcred must be an exclusive credential reference for the  *             duration of the call.  */
end_comment

begin_function
name|void
name|change_svuid
parameter_list|(
name|struct
name|ucred
modifier|*
name|newcred
parameter_list|,
name|uid_t
name|svuid
parameter_list|)
block|{
name|newcred
operator|->
name|cr_svuid
operator|=
name|svuid
expr_stmt|;
block|}
end_function

begin_comment
comment|/*-  * Change a process's saved gid.  * Side effects: newcred->cr_svgid will be updated.  * References: newcred must be an exclusive credential reference for the  *             duration of the call.  */
end_comment

begin_function
name|void
name|change_svgid
parameter_list|(
name|struct
name|ucred
modifier|*
name|newcred
parameter_list|,
name|gid_t
name|svgid
parameter_list|)
block|{
name|newcred
operator|->
name|cr_svgid
operator|=
name|svgid
expr_stmt|;
block|}
end_function

end_unit

