begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1982, 1986, 1989, 1990, 1991, 1993  *	The Regents of the University of California.  All rights reserved.  * (c) UNIX System Laboratories, Inc.  * All or some portions of this file are derived from material licensed  * to the University of California by American Telephone and Telegraph  * Co. or Unix System Laboratories, Inc. and are reproduced herein with  * the permission of UNIX System Laboratories, Inc.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *	@(#)kern_prot.c	8.6 (Berkeley) 1/21/94  * $FreeBSD$  */
end_comment

begin_comment
comment|/*  * System calls related to processes and protection  */
end_comment

begin_include
include|#
directive|include
file|"opt_compat.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/acct.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysproto.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/pioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/resourcevar.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_expr_stmt
specifier|static
name|MALLOC_DEFINE
argument_list|(
name|M_CRED
argument_list|,
literal|"cred"
argument_list|,
literal|"credentials"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|_SYS_SYSPROTO_H_
end_ifndef

begin_struct
struct|struct
name|getpid_args
block|{
name|int
name|dummy
decl_stmt|;
block|}
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * NOT MP SAFE due to p_pptr access  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|getpid
parameter_list|(
name|p
parameter_list|,
name|uap
parameter_list|)
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|struct
name|getpid_args
modifier|*
name|uap
decl_stmt|;
block|{
name|p
operator|->
name|p_retval
index|[
literal|0
index|]
operator|=
name|p
operator|->
name|p_pid
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|COMPAT_43
argument_list|)
operator|||
name|defined
argument_list|(
name|COMPAT_SUNOS
argument_list|)
name|p
operator|->
name|p_retval
index|[
literal|1
index|]
operator|=
name|p
operator|->
name|p_pptr
operator|->
name|p_pid
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|_SYS_SYSPROTO_H_
end_ifndef

begin_struct
struct|struct
name|getppid_args
block|{
name|int
name|dummy
decl_stmt|;
block|}
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|getppid
parameter_list|(
name|p
parameter_list|,
name|uap
parameter_list|)
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|struct
name|getppid_args
modifier|*
name|uap
decl_stmt|;
block|{
name|p
operator|->
name|p_retval
index|[
literal|0
index|]
operator|=
name|p
operator|->
name|p_pptr
operator|->
name|p_pid
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*   * Get process group ID; note that POSIX getpgrp takes no parameter   *  * MP SAFE  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|_SYS_SYSPROTO_H_
end_ifndef

begin_struct
struct|struct
name|getpgrp_args
block|{
name|int
name|dummy
decl_stmt|;
block|}
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|getpgrp
parameter_list|(
name|p
parameter_list|,
name|uap
parameter_list|)
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|struct
name|getpgrp_args
modifier|*
name|uap
decl_stmt|;
block|{
name|p
operator|->
name|p_retval
index|[
literal|0
index|]
operator|=
name|p
operator|->
name|p_pgrp
operator|->
name|pg_id
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Get an arbitary pid's process group id */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|_SYS_SYSPROTO_H_
end_ifndef

begin_struct
struct|struct
name|getpgid_args
block|{
name|pid_t
name|pid
decl_stmt|;
block|}
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|getpgid
parameter_list|(
name|p
parameter_list|,
name|uap
parameter_list|)
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|struct
name|getpgid_args
modifier|*
name|uap
decl_stmt|;
block|{
name|struct
name|proc
modifier|*
name|pt
decl_stmt|;
name|pt
operator|=
name|p
expr_stmt|;
if|if
condition|(
name|uap
operator|->
name|pid
operator|==
literal|0
condition|)
goto|goto
name|found
goto|;
if|if
condition|(
operator|(
name|pt
operator|=
name|pfind
argument_list|(
name|uap
operator|->
name|pid
argument_list|)
operator|)
operator|==
literal|0
condition|)
return|return
name|ESRCH
return|;
name|found
label|:
name|p
operator|->
name|p_retval
index|[
literal|0
index|]
operator|=
name|pt
operator|->
name|p_pgrp
operator|->
name|pg_id
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Get an arbitary pid's session id.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|_SYS_SYSPROTO_H_
end_ifndef

begin_struct
struct|struct
name|getsid_args
block|{
name|pid_t
name|pid
decl_stmt|;
block|}
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|getsid
parameter_list|(
name|p
parameter_list|,
name|uap
parameter_list|)
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|struct
name|getsid_args
modifier|*
name|uap
decl_stmt|;
block|{
name|struct
name|proc
modifier|*
name|pt
decl_stmt|;
name|pt
operator|=
name|p
expr_stmt|;
if|if
condition|(
name|uap
operator|->
name|pid
operator|==
literal|0
condition|)
goto|goto
name|found
goto|;
if|if
condition|(
operator|(
name|pt
operator|==
name|pfind
argument_list|(
name|uap
operator|->
name|pid
argument_list|)
operator|)
operator|==
literal|0
condition|)
return|return
name|ESRCH
return|;
name|found
label|:
name|p
operator|->
name|p_retval
index|[
literal|0
index|]
operator|=
name|pt
operator|->
name|p_session
operator|->
name|s_sid
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * getuid() - MP SAFE  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|_SYS_SYSPROTO_H_
end_ifndef

begin_struct
struct|struct
name|getuid_args
block|{
name|int
name|dummy
decl_stmt|;
block|}
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|getuid
parameter_list|(
name|p
parameter_list|,
name|uap
parameter_list|)
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|struct
name|getuid_args
modifier|*
name|uap
decl_stmt|;
block|{
name|p
operator|->
name|p_retval
index|[
literal|0
index|]
operator|=
name|p
operator|->
name|p_cred
operator|->
name|p_ruid
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|COMPAT_43
argument_list|)
operator|||
name|defined
argument_list|(
name|COMPAT_SUNOS
argument_list|)
name|p
operator|->
name|p_retval
index|[
literal|1
index|]
operator|=
name|p
operator|->
name|p_ucred
operator|->
name|cr_uid
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * geteuid() - MP SAFE  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|_SYS_SYSPROTO_H_
end_ifndef

begin_struct
struct|struct
name|geteuid_args
block|{
name|int
name|dummy
decl_stmt|;
block|}
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|geteuid
parameter_list|(
name|p
parameter_list|,
name|uap
parameter_list|)
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|struct
name|geteuid_args
modifier|*
name|uap
decl_stmt|;
block|{
name|p
operator|->
name|p_retval
index|[
literal|0
index|]
operator|=
name|p
operator|->
name|p_ucred
operator|->
name|cr_uid
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * getgid() - MP SAFE  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|_SYS_SYSPROTO_H_
end_ifndef

begin_struct
struct|struct
name|getgid_args
block|{
name|int
name|dummy
decl_stmt|;
block|}
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|getgid
parameter_list|(
name|p
parameter_list|,
name|uap
parameter_list|)
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|struct
name|getgid_args
modifier|*
name|uap
decl_stmt|;
block|{
name|p
operator|->
name|p_retval
index|[
literal|0
index|]
operator|=
name|p
operator|->
name|p_cred
operator|->
name|p_rgid
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|COMPAT_43
argument_list|)
operator|||
name|defined
argument_list|(
name|COMPAT_SUNOS
argument_list|)
name|p
operator|->
name|p_retval
index|[
literal|1
index|]
operator|=
name|p
operator|->
name|p_ucred
operator|->
name|cr_groups
index|[
literal|0
index|]
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Get effective group ID.  The "egid" is groups[0], and could be obtained  * via getgroups.  This syscall exists because it is somewhat painful to do  * correctly in a library function.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|_SYS_SYSPROTO_H_
end_ifndef

begin_struct
struct|struct
name|getegid_args
block|{
name|int
name|dummy
decl_stmt|;
block|}
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|getegid
parameter_list|(
name|p
parameter_list|,
name|uap
parameter_list|)
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|struct
name|getegid_args
modifier|*
name|uap
decl_stmt|;
block|{
name|p
operator|->
name|p_retval
index|[
literal|0
index|]
operator|=
name|p
operator|->
name|p_ucred
operator|->
name|cr_groups
index|[
literal|0
index|]
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|_SYS_SYSPROTO_H_
end_ifndef

begin_struct
struct|struct
name|getgroups_args
block|{
name|u_int
name|gidsetsize
decl_stmt|;
name|gid_t
modifier|*
name|gidset
decl_stmt|;
block|}
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|getgroups
parameter_list|(
name|p
parameter_list|,
name|uap
parameter_list|)
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
specifier|register
name|struct
name|getgroups_args
modifier|*
name|uap
decl_stmt|;
block|{
specifier|register
name|struct
name|pcred
modifier|*
name|pc
init|=
name|p
operator|->
name|p_cred
decl_stmt|;
specifier|register
name|u_int
name|ngrp
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
operator|(
name|ngrp
operator|=
name|uap
operator|->
name|gidsetsize
operator|)
operator|==
literal|0
condition|)
block|{
name|p
operator|->
name|p_retval
index|[
literal|0
index|]
operator|=
name|pc
operator|->
name|pc_ucred
operator|->
name|cr_ngroups
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|ngrp
operator|<
name|pc
operator|->
name|pc_ucred
operator|->
name|cr_ngroups
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|ngrp
operator|=
name|pc
operator|->
name|pc_ucred
operator|->
name|cr_ngroups
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|copyout
argument_list|(
operator|(
name|caddr_t
operator|)
name|pc
operator|->
name|pc_ucred
operator|->
name|cr_groups
argument_list|,
operator|(
name|caddr_t
operator|)
name|uap
operator|->
name|gidset
argument_list|,
name|ngrp
operator|*
sizeof|sizeof
argument_list|(
name|gid_t
argument_list|)
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|p
operator|->
name|p_retval
index|[
literal|0
index|]
operator|=
name|ngrp
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|_SYS_SYSPROTO_H_
end_ifndef

begin_struct
struct|struct
name|setsid_args
block|{
name|int
name|dummy
decl_stmt|;
block|}
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|setsid
parameter_list|(
name|p
parameter_list|,
name|uap
parameter_list|)
specifier|register
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|struct
name|setsid_args
modifier|*
name|uap
decl_stmt|;
block|{
if|if
condition|(
name|p
operator|->
name|p_pgid
operator|==
name|p
operator|->
name|p_pid
operator|||
name|pgfind
argument_list|(
name|p
operator|->
name|p_pid
argument_list|)
condition|)
block|{
return|return
operator|(
name|EPERM
operator|)
return|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|enterpgrp
argument_list|(
name|p
argument_list|,
name|p
operator|->
name|p_pid
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|p
operator|->
name|p_retval
index|[
literal|0
index|]
operator|=
name|p
operator|->
name|p_pid
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * set process group (setpgid/old setpgrp)  *  * caller does setpgid(targpid, targpgid)  *  * pid must be caller or child of caller (ESRCH)  * if a child  *	pid must be in same session (EPERM)  *	pid can't have done an exec (EACCES)  * if pgid != pid  * 	there must exist some pid in same session having pgid (EPERM)  * pid must not be session leader (EPERM)  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|_SYS_SYSPROTO_H_
end_ifndef

begin_struct
struct|struct
name|setpgid_args
block|{
name|int
name|pid
decl_stmt|;
comment|/* target process id */
name|int
name|pgid
decl_stmt|;
comment|/* target pgrp id */
block|}
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|setpgid
parameter_list|(
name|curp
parameter_list|,
name|uap
parameter_list|)
name|struct
name|proc
modifier|*
name|curp
decl_stmt|;
specifier|register
name|struct
name|setpgid_args
modifier|*
name|uap
decl_stmt|;
block|{
specifier|register
name|struct
name|proc
modifier|*
name|targp
decl_stmt|;
comment|/* target process */
specifier|register
name|struct
name|pgrp
modifier|*
name|pgrp
decl_stmt|;
comment|/* target pgrp */
if|if
condition|(
name|uap
operator|->
name|pgid
operator|<
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|uap
operator|->
name|pid
operator|!=
literal|0
operator|&&
name|uap
operator|->
name|pid
operator|!=
name|curp
operator|->
name|p_pid
condition|)
block|{
if|if
condition|(
operator|(
name|targp
operator|=
name|pfind
argument_list|(
name|uap
operator|->
name|pid
argument_list|)
operator|)
operator|==
literal|0
operator|||
operator|!
name|inferior
argument_list|(
name|targp
argument_list|)
condition|)
return|return
operator|(
name|ESRCH
operator|)
return|;
if|if
condition|(
name|targp
operator|->
name|p_pgrp
operator|==
name|NULL
operator|||
name|targp
operator|->
name|p_session
operator|!=
name|curp
operator|->
name|p_session
condition|)
return|return
operator|(
name|EPERM
operator|)
return|;
if|if
condition|(
name|targp
operator|->
name|p_flag
operator|&
name|P_EXEC
condition|)
return|return
operator|(
name|EACCES
operator|)
return|;
block|}
else|else
name|targp
operator|=
name|curp
expr_stmt|;
if|if
condition|(
name|SESS_LEADER
argument_list|(
name|targp
argument_list|)
condition|)
return|return
operator|(
name|EPERM
operator|)
return|;
if|if
condition|(
name|uap
operator|->
name|pgid
operator|==
literal|0
condition|)
name|uap
operator|->
name|pgid
operator|=
name|targp
operator|->
name|p_pid
expr_stmt|;
elseif|else
if|if
condition|(
name|uap
operator|->
name|pgid
operator|!=
name|targp
operator|->
name|p_pid
condition|)
if|if
condition|(
operator|(
name|pgrp
operator|=
name|pgfind
argument_list|(
name|uap
operator|->
name|pgid
argument_list|)
operator|)
operator|==
literal|0
operator|||
name|pgrp
operator|->
name|pg_session
operator|!=
name|curp
operator|->
name|p_session
condition|)
return|return
operator|(
name|EPERM
operator|)
return|;
return|return
operator|(
name|enterpgrp
argument_list|(
name|targp
argument_list|,
name|uap
operator|->
name|pgid
argument_list|,
literal|0
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Use the clause in B.4.2.2 that allows setuid/setgid to be 4.2/4.3BSD  * compatable.  It says that setting the uid/gid to euid/egid is a special  * case of "appropriate privilege".  Once the rules are expanded out, this  * basically means that setuid(nnn) sets all three id's, in all permitted  * cases unless _POSIX_SAVED_IDS is enabled.  In that case, setuid(getuid())  * does not set the saved id - this is dangerous for traditional BSD  * programs.  For this reason, we *really* do not want to set  * _POSIX_SAVED_IDS and do not want to clear POSIX_APPENDIX_B_4_2_2.  */
end_comment

begin_define
define|#
directive|define
name|POSIX_APPENDIX_B_4_2_2
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|_SYS_SYSPROTO_H_
end_ifndef

begin_struct
struct|struct
name|setuid_args
block|{
name|uid_t
name|uid
decl_stmt|;
block|}
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|setuid
parameter_list|(
name|p
parameter_list|,
name|uap
parameter_list|)
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|struct
name|setuid_args
modifier|*
name|uap
decl_stmt|;
block|{
specifier|register
name|struct
name|pcred
modifier|*
name|pc
init|=
name|p
operator|->
name|p_cred
decl_stmt|;
specifier|register
name|uid_t
name|uid
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* 	 * See if we have "permission" by POSIX 1003.1 rules. 	 * 	 * Note that setuid(geteuid()) is a special case of  	 * "appropriate privileges" in appendix B.4.2.2.  We need 	 * to use this clause to be compatable with traditional BSD 	 * semantics.  Basically, it means that "setuid(xx)" sets all 	 * three id's (assuming you have privs). 	 * 	 * Notes on the logic.  We do things in three steps. 	 * 1: We determine if the euid is going to change, and do EPERM 	 *    right away.  We unconditionally change the euid later if this 	 *    test is satisfied, simplifying that part of the logic. 	 * 2: We determine if the real and/or saved uid's are going to 	 *    change.  Determined by compile options. 	 * 3: Change euid last. (after tests in #2 for "appropriate privs") 	 */
name|uid
operator|=
name|uap
operator|->
name|uid
expr_stmt|;
if|if
condition|(
name|uid
operator|!=
name|pc
operator|->
name|p_ruid
operator|&&
comment|/* allow setuid(getuid()) */
ifdef|#
directive|ifdef
name|_POSIX_SAVED_IDS
name|uid
operator|!=
name|pc
operator|->
name|p_svuid
operator|&&
comment|/* allow setuid(saved gid) */
endif|#
directive|endif
ifdef|#
directive|ifdef
name|POSIX_APPENDIX_B_4_2_2
comment|/* Use BSD-compat clause from B.4.2.2 */
name|uid
operator|!=
name|pc
operator|->
name|pc_ucred
operator|->
name|cr_uid
operator|&&
comment|/* allow setuid(geteuid()) */
endif|#
directive|endif
operator|(
name|error
operator|=
name|suser_xxx
argument_list|(
literal|0
argument_list|,
name|p
argument_list|,
name|PRISON_ROOT
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
ifdef|#
directive|ifdef
name|_POSIX_SAVED_IDS
comment|/* 	 * Do we have "appropriate privileges" (are we root or uid == euid) 	 * If so, we are changing the real uid and/or saved uid. 	 */
if|if
condition|(
ifdef|#
directive|ifdef
name|POSIX_APPENDIX_B_4_2_2
comment|/* Use the clause from B.4.2.2 */
name|uid
operator|==
name|pc
operator|->
name|pc_ucred
operator|->
name|cr_uid
operator|||
endif|#
directive|endif
name|suser_xxx
argument_list|(
literal|0
argument_list|,
name|p
argument_list|,
name|PRISON_ROOT
argument_list|)
operator|==
literal|0
condition|)
comment|/* we are using privs */
endif|#
directive|endif
block|{
comment|/* 		 * Set the real uid and transfer proc count to new user. 		 */
if|if
condition|(
name|uid
operator|!=
name|pc
operator|->
name|p_ruid
condition|)
block|{
name|change_ruid
argument_list|(
name|p
argument_list|,
name|uid
argument_list|)
expr_stmt|;
name|setsugid
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Set saved uid 		 * 		 * XXX always set saved uid even if not _POSIX_SAVED_IDS, as 		 * the security of seteuid() depends on it.  B.4.2.2 says it 		 * is important that we should do this. 		 */
if|if
condition|(
name|pc
operator|->
name|p_svuid
operator|!=
name|uid
condition|)
block|{
name|pc
operator|->
name|p_svuid
operator|=
name|uid
expr_stmt|;
name|setsugid
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * In all permitted cases, we are changing the euid. 	 * Copy credentials so other references do not see our changes. 	 */
if|if
condition|(
name|pc
operator|->
name|pc_ucred
operator|->
name|cr_uid
operator|!=
name|uid
condition|)
block|{
name|change_euid
argument_list|(
name|p
argument_list|,
name|uid
argument_list|)
expr_stmt|;
name|setsugid
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|_SYS_SYSPROTO_H_
end_ifndef

begin_struct
struct|struct
name|seteuid_args
block|{
name|uid_t
name|euid
decl_stmt|;
block|}
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|seteuid
parameter_list|(
name|p
parameter_list|,
name|uap
parameter_list|)
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|struct
name|seteuid_args
modifier|*
name|uap
decl_stmt|;
block|{
specifier|register
name|struct
name|pcred
modifier|*
name|pc
init|=
name|p
operator|->
name|p_cred
decl_stmt|;
specifier|register
name|uid_t
name|euid
decl_stmt|;
name|int
name|error
decl_stmt|;
name|euid
operator|=
name|uap
operator|->
name|euid
expr_stmt|;
if|if
condition|(
name|euid
operator|!=
name|pc
operator|->
name|p_ruid
operator|&&
comment|/* allow seteuid(getuid()) */
name|euid
operator|!=
name|pc
operator|->
name|p_svuid
operator|&&
comment|/* allow seteuid(saved uid) */
operator|(
name|error
operator|=
name|suser_xxx
argument_list|(
literal|0
argument_list|,
name|p
argument_list|,
name|PRISON_ROOT
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* 	 * Everything's okay, do it.  Copy credentials so other references do 	 * not see our changes. 	 */
if|if
condition|(
name|pc
operator|->
name|pc_ucred
operator|->
name|cr_uid
operator|!=
name|euid
condition|)
block|{
name|change_euid
argument_list|(
name|p
argument_list|,
name|euid
argument_list|)
expr_stmt|;
name|setsugid
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|_SYS_SYSPROTO_H_
end_ifndef

begin_struct
struct|struct
name|setgid_args
block|{
name|gid_t
name|gid
decl_stmt|;
block|}
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|setgid
parameter_list|(
name|p
parameter_list|,
name|uap
parameter_list|)
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|struct
name|setgid_args
modifier|*
name|uap
decl_stmt|;
block|{
specifier|register
name|struct
name|pcred
modifier|*
name|pc
init|=
name|p
operator|->
name|p_cred
decl_stmt|;
specifier|register
name|gid_t
name|gid
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* 	 * See if we have "permission" by POSIX 1003.1 rules. 	 * 	 * Note that setgid(getegid()) is a special case of 	 * "appropriate privileges" in appendix B.4.2.2.  We need 	 * to use this clause to be compatable with traditional BSD 	 * semantics.  Basically, it means that "setgid(xx)" sets all 	 * three id's (assuming you have privs). 	 * 	 * For notes on the logic here, see setuid() above. 	 */
name|gid
operator|=
name|uap
operator|->
name|gid
expr_stmt|;
if|if
condition|(
name|gid
operator|!=
name|pc
operator|->
name|p_rgid
operator|&&
comment|/* allow setgid(getgid()) */
ifdef|#
directive|ifdef
name|_POSIX_SAVED_IDS
name|gid
operator|!=
name|pc
operator|->
name|p_svgid
operator|&&
comment|/* allow setgid(saved gid) */
endif|#
directive|endif
ifdef|#
directive|ifdef
name|POSIX_APPENDIX_B_4_2_2
comment|/* Use BSD-compat clause from B.4.2.2 */
name|gid
operator|!=
name|pc
operator|->
name|pc_ucred
operator|->
name|cr_groups
index|[
literal|0
index|]
operator|&&
comment|/* allow setgid(getegid()) */
endif|#
directive|endif
operator|(
name|error
operator|=
name|suser_xxx
argument_list|(
literal|0
argument_list|,
name|p
argument_list|,
name|PRISON_ROOT
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
ifdef|#
directive|ifdef
name|_POSIX_SAVED_IDS
comment|/* 	 * Do we have "appropriate privileges" (are we root or gid == egid) 	 * If so, we are changing the real uid and saved gid. 	 */
if|if
condition|(
ifdef|#
directive|ifdef
name|POSIX_APPENDIX_B_4_2_2
comment|/* use the clause from B.4.2.2 */
name|gid
operator|==
name|pc
operator|->
name|pc_ucred
operator|->
name|cr_groups
index|[
literal|0
index|]
operator|||
endif|#
directive|endif
name|suser_xxx
argument_list|(
literal|0
argument_list|,
name|p
argument_list|,
name|PRISON_ROOT
argument_list|)
operator|==
literal|0
condition|)
comment|/* we are using privs */
endif|#
directive|endif
block|{
comment|/* 		 * Set real gid 		 */
if|if
condition|(
name|pc
operator|->
name|p_rgid
operator|!=
name|gid
condition|)
block|{
name|pc
operator|->
name|p_rgid
operator|=
name|gid
expr_stmt|;
name|setsugid
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Set saved gid 		 * 		 * XXX always set saved gid even if not _POSIX_SAVED_IDS, as 		 * the security of setegid() depends on it.  B.4.2.2 says it 		 * is important that we should do this. 		 */
if|if
condition|(
name|pc
operator|->
name|p_svgid
operator|!=
name|gid
condition|)
block|{
name|pc
operator|->
name|p_svgid
operator|=
name|gid
expr_stmt|;
name|setsugid
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * In all cases permitted cases, we are changing the egid. 	 * Copy credentials so other references do not see our changes. 	 */
if|if
condition|(
name|pc
operator|->
name|pc_ucred
operator|->
name|cr_groups
index|[
literal|0
index|]
operator|!=
name|gid
condition|)
block|{
name|pc
operator|->
name|pc_ucred
operator|=
name|crcopy
argument_list|(
name|pc
operator|->
name|pc_ucred
argument_list|)
expr_stmt|;
name|pc
operator|->
name|pc_ucred
operator|->
name|cr_groups
index|[
literal|0
index|]
operator|=
name|gid
expr_stmt|;
name|setsugid
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|_SYS_SYSPROTO_H_
end_ifndef

begin_struct
struct|struct
name|setegid_args
block|{
name|gid_t
name|egid
decl_stmt|;
block|}
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|setegid
parameter_list|(
name|p
parameter_list|,
name|uap
parameter_list|)
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|struct
name|setegid_args
modifier|*
name|uap
decl_stmt|;
block|{
specifier|register
name|struct
name|pcred
modifier|*
name|pc
init|=
name|p
operator|->
name|p_cred
decl_stmt|;
specifier|register
name|gid_t
name|egid
decl_stmt|;
name|int
name|error
decl_stmt|;
name|egid
operator|=
name|uap
operator|->
name|egid
expr_stmt|;
if|if
condition|(
name|egid
operator|!=
name|pc
operator|->
name|p_rgid
operator|&&
comment|/* allow setegid(getgid()) */
name|egid
operator|!=
name|pc
operator|->
name|p_svgid
operator|&&
comment|/* allow setegid(saved gid) */
operator|(
name|error
operator|=
name|suser_xxx
argument_list|(
literal|0
argument_list|,
name|p
argument_list|,
name|PRISON_ROOT
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|pc
operator|->
name|pc_ucred
operator|->
name|cr_groups
index|[
literal|0
index|]
operator|!=
name|egid
condition|)
block|{
name|pc
operator|->
name|pc_ucred
operator|=
name|crcopy
argument_list|(
name|pc
operator|->
name|pc_ucred
argument_list|)
expr_stmt|;
name|pc
operator|->
name|pc_ucred
operator|->
name|cr_groups
index|[
literal|0
index|]
operator|=
name|egid
expr_stmt|;
name|setsugid
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|_SYS_SYSPROTO_H_
end_ifndef

begin_struct
struct|struct
name|setgroups_args
block|{
name|u_int
name|gidsetsize
decl_stmt|;
name|gid_t
modifier|*
name|gidset
decl_stmt|;
block|}
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|setgroups
parameter_list|(
name|p
parameter_list|,
name|uap
parameter_list|)
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|struct
name|setgroups_args
modifier|*
name|uap
decl_stmt|;
block|{
specifier|register
name|struct
name|pcred
modifier|*
name|pc
init|=
name|p
operator|->
name|p_cred
decl_stmt|;
specifier|register
name|u_int
name|ngrp
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|suser_xxx
argument_list|(
literal|0
argument_list|,
name|p
argument_list|,
name|PRISON_ROOT
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|ngrp
operator|=
name|uap
operator|->
name|gidsetsize
expr_stmt|;
if|if
condition|(
name|ngrp
operator|>
name|NGROUPS
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* 	 * XXX A little bit lazy here.  We could test if anything has 	 * changed before crcopy() and setting P_SUGID. 	 */
name|pc
operator|->
name|pc_ucred
operator|=
name|crcopy
argument_list|(
name|pc
operator|->
name|pc_ucred
argument_list|)
expr_stmt|;
if|if
condition|(
name|ngrp
operator|<
literal|1
condition|)
block|{
comment|/* 		 * setgroups(0, NULL) is a legitimate way of clearing the 		 * groups vector on non-BSD systems (which generally do not 		 * have the egid in the groups[0]).  We risk security holes 		 * when running non-BSD software if we do not do the same. 		 */
name|pc
operator|->
name|pc_ucred
operator|->
name|cr_ngroups
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|copyin
argument_list|(
operator|(
name|caddr_t
operator|)
name|uap
operator|->
name|gidset
argument_list|,
operator|(
name|caddr_t
operator|)
name|pc
operator|->
name|pc_ucred
operator|->
name|cr_groups
argument_list|,
name|ngrp
operator|*
sizeof|sizeof
argument_list|(
name|gid_t
argument_list|)
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|pc
operator|->
name|pc_ucred
operator|->
name|cr_ngroups
operator|=
name|ngrp
expr_stmt|;
block|}
name|setsugid
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|_SYS_SYSPROTO_H_
end_ifndef

begin_struct
struct|struct
name|setreuid_args
block|{
name|uid_t
name|ruid
decl_stmt|;
name|uid_t
name|euid
decl_stmt|;
block|}
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|setreuid
parameter_list|(
name|p
parameter_list|,
name|uap
parameter_list|)
specifier|register
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|struct
name|setreuid_args
modifier|*
name|uap
decl_stmt|;
block|{
specifier|register
name|struct
name|pcred
modifier|*
name|pc
init|=
name|p
operator|->
name|p_cred
decl_stmt|;
specifier|register
name|uid_t
name|ruid
decl_stmt|,
name|euid
decl_stmt|;
name|int
name|error
decl_stmt|;
name|ruid
operator|=
name|uap
operator|->
name|ruid
expr_stmt|;
name|euid
operator|=
name|uap
operator|->
name|euid
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|ruid
operator|!=
operator|(
name|uid_t
operator|)
operator|-
literal|1
operator|&&
name|ruid
operator|!=
name|pc
operator|->
name|p_ruid
operator|&&
name|ruid
operator|!=
name|pc
operator|->
name|p_svuid
operator|)
operator|||
operator|(
name|euid
operator|!=
operator|(
name|uid_t
operator|)
operator|-
literal|1
operator|&&
name|euid
operator|!=
name|pc
operator|->
name|pc_ucred
operator|->
name|cr_uid
operator|&&
name|euid
operator|!=
name|pc
operator|->
name|p_ruid
operator|&&
name|euid
operator|!=
name|pc
operator|->
name|p_svuid
operator|)
operator|)
operator|&&
operator|(
name|error
operator|=
name|suser_xxx
argument_list|(
literal|0
argument_list|,
name|p
argument_list|,
name|PRISON_ROOT
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|euid
operator|!=
operator|(
name|uid_t
operator|)
operator|-
literal|1
operator|&&
name|pc
operator|->
name|pc_ucred
operator|->
name|cr_uid
operator|!=
name|euid
condition|)
block|{
name|change_euid
argument_list|(
name|p
argument_list|,
name|euid
argument_list|)
expr_stmt|;
name|setsugid
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ruid
operator|!=
operator|(
name|uid_t
operator|)
operator|-
literal|1
operator|&&
name|pc
operator|->
name|p_ruid
operator|!=
name|ruid
condition|)
block|{
name|change_ruid
argument_list|(
name|p
argument_list|,
name|ruid
argument_list|)
expr_stmt|;
name|setsugid
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|ruid
operator|!=
operator|(
name|uid_t
operator|)
operator|-
literal|1
operator|||
name|pc
operator|->
name|pc_ucred
operator|->
name|cr_uid
operator|!=
name|pc
operator|->
name|p_ruid
operator|)
operator|&&
name|pc
operator|->
name|p_svuid
operator|!=
name|pc
operator|->
name|pc_ucred
operator|->
name|cr_uid
condition|)
block|{
name|pc
operator|->
name|p_svuid
operator|=
name|pc
operator|->
name|pc_ucred
operator|->
name|cr_uid
expr_stmt|;
name|setsugid
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|_SYS_SYSPROTO_H_
end_ifndef

begin_struct
struct|struct
name|setregid_args
block|{
name|gid_t
name|rgid
decl_stmt|;
name|gid_t
name|egid
decl_stmt|;
block|}
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|setregid
parameter_list|(
name|p
parameter_list|,
name|uap
parameter_list|)
specifier|register
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|struct
name|setregid_args
modifier|*
name|uap
decl_stmt|;
block|{
specifier|register
name|struct
name|pcred
modifier|*
name|pc
init|=
name|p
operator|->
name|p_cred
decl_stmt|;
specifier|register
name|gid_t
name|rgid
decl_stmt|,
name|egid
decl_stmt|;
name|int
name|error
decl_stmt|;
name|rgid
operator|=
name|uap
operator|->
name|rgid
expr_stmt|;
name|egid
operator|=
name|uap
operator|->
name|egid
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|rgid
operator|!=
operator|(
name|gid_t
operator|)
operator|-
literal|1
operator|&&
name|rgid
operator|!=
name|pc
operator|->
name|p_rgid
operator|&&
name|rgid
operator|!=
name|pc
operator|->
name|p_svgid
operator|)
operator|||
operator|(
name|egid
operator|!=
operator|(
name|gid_t
operator|)
operator|-
literal|1
operator|&&
name|egid
operator|!=
name|pc
operator|->
name|pc_ucred
operator|->
name|cr_groups
index|[
literal|0
index|]
operator|&&
name|egid
operator|!=
name|pc
operator|->
name|p_rgid
operator|&&
name|egid
operator|!=
name|pc
operator|->
name|p_svgid
operator|)
operator|)
operator|&&
operator|(
name|error
operator|=
name|suser_xxx
argument_list|(
literal|0
argument_list|,
name|p
argument_list|,
name|PRISON_ROOT
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|egid
operator|!=
operator|(
name|gid_t
operator|)
operator|-
literal|1
operator|&&
name|pc
operator|->
name|pc_ucred
operator|->
name|cr_groups
index|[
literal|0
index|]
operator|!=
name|egid
condition|)
block|{
name|pc
operator|->
name|pc_ucred
operator|=
name|crcopy
argument_list|(
name|pc
operator|->
name|pc_ucred
argument_list|)
expr_stmt|;
name|pc
operator|->
name|pc_ucred
operator|->
name|cr_groups
index|[
literal|0
index|]
operator|=
name|egid
expr_stmt|;
name|setsugid
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rgid
operator|!=
operator|(
name|gid_t
operator|)
operator|-
literal|1
operator|&&
name|pc
operator|->
name|p_rgid
operator|!=
name|rgid
condition|)
block|{
name|pc
operator|->
name|p_rgid
operator|=
name|rgid
expr_stmt|;
name|setsugid
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|rgid
operator|!=
operator|(
name|gid_t
operator|)
operator|-
literal|1
operator|||
name|pc
operator|->
name|pc_ucred
operator|->
name|cr_groups
index|[
literal|0
index|]
operator|!=
name|pc
operator|->
name|p_rgid
operator|)
operator|&&
name|pc
operator|->
name|p_svgid
operator|!=
name|pc
operator|->
name|pc_ucred
operator|->
name|cr_groups
index|[
literal|0
index|]
condition|)
block|{
name|pc
operator|->
name|p_svgid
operator|=
name|pc
operator|->
name|pc_ucred
operator|->
name|cr_groups
index|[
literal|0
index|]
expr_stmt|;
name|setsugid
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * setresuid(ruid, euid, suid) is like setreuid except control over the  * saved uid is explicit.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|_SYS_SYSPROTO_H_
end_ifndef

begin_struct
struct|struct
name|setresuid_args
block|{
name|uid_t
name|ruid
decl_stmt|;
name|uid_t
name|euid
decl_stmt|;
name|uid_t
name|suid
decl_stmt|;
block|}
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|setresuid
parameter_list|(
name|p
parameter_list|,
name|uap
parameter_list|)
specifier|register
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|struct
name|setresuid_args
modifier|*
name|uap
decl_stmt|;
block|{
specifier|register
name|struct
name|pcred
modifier|*
name|pc
init|=
name|p
operator|->
name|p_cred
decl_stmt|;
specifier|register
name|uid_t
name|ruid
decl_stmt|,
name|euid
decl_stmt|,
name|suid
decl_stmt|;
name|int
name|error
decl_stmt|;
name|ruid
operator|=
name|uap
operator|->
name|ruid
expr_stmt|;
name|euid
operator|=
name|uap
operator|->
name|euid
expr_stmt|;
name|suid
operator|=
name|uap
operator|->
name|suid
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|ruid
operator|!=
operator|(
name|uid_t
operator|)
operator|-
literal|1
operator|&&
name|ruid
operator|!=
name|pc
operator|->
name|p_ruid
operator|&&
name|ruid
operator|!=
name|pc
operator|->
name|p_svuid
operator|&&
name|ruid
operator|!=
name|pc
operator|->
name|pc_ucred
operator|->
name|cr_uid
operator|)
operator|||
operator|(
name|euid
operator|!=
operator|(
name|uid_t
operator|)
operator|-
literal|1
operator|&&
name|euid
operator|!=
name|pc
operator|->
name|p_ruid
operator|&&
name|euid
operator|!=
name|pc
operator|->
name|p_svuid
operator|&&
name|euid
operator|!=
name|pc
operator|->
name|pc_ucred
operator|->
name|cr_uid
operator|)
operator|||
operator|(
name|suid
operator|!=
operator|(
name|uid_t
operator|)
operator|-
literal|1
operator|&&
name|suid
operator|!=
name|pc
operator|->
name|p_ruid
operator|&&
name|suid
operator|!=
name|pc
operator|->
name|p_svuid
operator|&&
name|suid
operator|!=
name|pc
operator|->
name|pc_ucred
operator|->
name|cr_uid
operator|)
operator|)
operator|&&
operator|(
name|error
operator|=
name|suser_xxx
argument_list|(
literal|0
argument_list|,
name|p
argument_list|,
name|PRISON_ROOT
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|euid
operator|!=
operator|(
name|uid_t
operator|)
operator|-
literal|1
operator|&&
name|pc
operator|->
name|pc_ucred
operator|->
name|cr_uid
operator|!=
name|euid
condition|)
block|{
name|change_euid
argument_list|(
name|p
argument_list|,
name|euid
argument_list|)
expr_stmt|;
name|setsugid
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ruid
operator|!=
operator|(
name|uid_t
operator|)
operator|-
literal|1
operator|&&
name|pc
operator|->
name|p_ruid
operator|!=
name|ruid
condition|)
block|{
name|change_ruid
argument_list|(
name|p
argument_list|,
name|ruid
argument_list|)
expr_stmt|;
name|setsugid
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|suid
operator|!=
operator|(
name|uid_t
operator|)
operator|-
literal|1
operator|&&
name|pc
operator|->
name|p_svuid
operator|!=
name|suid
condition|)
block|{
name|pc
operator|->
name|p_svuid
operator|=
name|suid
expr_stmt|;
name|setsugid
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * setresgid(rgid, egid, sgid) is like setregid except control over the  * saved gid is explicit.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|_SYS_SYSPROTO_H_
end_ifndef

begin_struct
struct|struct
name|setresgid_args
block|{
name|gid_t
name|rgid
decl_stmt|;
name|gid_t
name|egid
decl_stmt|;
name|gid_t
name|sgid
decl_stmt|;
block|}
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|setresgid
parameter_list|(
name|p
parameter_list|,
name|uap
parameter_list|)
specifier|register
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|struct
name|setresgid_args
modifier|*
name|uap
decl_stmt|;
block|{
specifier|register
name|struct
name|pcred
modifier|*
name|pc
init|=
name|p
operator|->
name|p_cred
decl_stmt|;
specifier|register
name|gid_t
name|rgid
decl_stmt|,
name|egid
decl_stmt|,
name|sgid
decl_stmt|;
name|int
name|error
decl_stmt|;
name|rgid
operator|=
name|uap
operator|->
name|rgid
expr_stmt|;
name|egid
operator|=
name|uap
operator|->
name|egid
expr_stmt|;
name|sgid
operator|=
name|uap
operator|->
name|sgid
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|rgid
operator|!=
operator|(
name|gid_t
operator|)
operator|-
literal|1
operator|&&
name|rgid
operator|!=
name|pc
operator|->
name|p_rgid
operator|&&
name|rgid
operator|!=
name|pc
operator|->
name|p_svgid
operator|&&
name|rgid
operator|!=
name|pc
operator|->
name|pc_ucred
operator|->
name|cr_groups
index|[
literal|0
index|]
operator|)
operator|||
operator|(
name|egid
operator|!=
operator|(
name|gid_t
operator|)
operator|-
literal|1
operator|&&
name|egid
operator|!=
name|pc
operator|->
name|p_rgid
operator|&&
name|egid
operator|!=
name|pc
operator|->
name|p_svgid
operator|&&
name|egid
operator|!=
name|pc
operator|->
name|pc_ucred
operator|->
name|cr_groups
index|[
literal|0
index|]
operator|)
operator|||
operator|(
name|sgid
operator|!=
operator|(
name|gid_t
operator|)
operator|-
literal|1
operator|&&
name|sgid
operator|!=
name|pc
operator|->
name|p_rgid
operator|&&
name|sgid
operator|!=
name|pc
operator|->
name|p_svgid
operator|&&
name|sgid
operator|!=
name|pc
operator|->
name|pc_ucred
operator|->
name|cr_groups
index|[
literal|0
index|]
operator|)
operator|)
operator|&&
operator|(
name|error
operator|=
name|suser_xxx
argument_list|(
literal|0
argument_list|,
name|p
argument_list|,
name|PRISON_ROOT
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|egid
operator|!=
operator|(
name|gid_t
operator|)
operator|-
literal|1
operator|&&
name|pc
operator|->
name|pc_ucred
operator|->
name|cr_groups
index|[
literal|0
index|]
operator|!=
name|egid
condition|)
block|{
name|pc
operator|->
name|pc_ucred
operator|=
name|crcopy
argument_list|(
name|pc
operator|->
name|pc_ucred
argument_list|)
expr_stmt|;
name|pc
operator|->
name|pc_ucred
operator|->
name|cr_groups
index|[
literal|0
index|]
operator|=
name|egid
expr_stmt|;
name|setsugid
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rgid
operator|!=
operator|(
name|gid_t
operator|)
operator|-
literal|1
operator|&&
name|pc
operator|->
name|p_rgid
operator|!=
name|rgid
condition|)
block|{
name|pc
operator|->
name|p_rgid
operator|=
name|rgid
expr_stmt|;
name|setsugid
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sgid
operator|!=
operator|(
name|gid_t
operator|)
operator|-
literal|1
operator|&&
name|pc
operator|->
name|p_svgid
operator|!=
name|sgid
condition|)
block|{
name|pc
operator|->
name|p_svgid
operator|=
name|sgid
expr_stmt|;
name|setsugid
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|_SYS_SYSPROTO_H_
end_ifndef

begin_struct
struct|struct
name|getresuid_args
block|{
name|uid_t
modifier|*
name|ruid
decl_stmt|;
name|uid_t
modifier|*
name|euid
decl_stmt|;
name|uid_t
modifier|*
name|suid
decl_stmt|;
block|}
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|getresuid
parameter_list|(
name|p
parameter_list|,
name|uap
parameter_list|)
specifier|register
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|struct
name|getresuid_args
modifier|*
name|uap
decl_stmt|;
block|{
name|struct
name|pcred
modifier|*
name|pc
init|=
name|p
operator|->
name|p_cred
decl_stmt|;
name|int
name|error1
init|=
literal|0
decl_stmt|,
name|error2
init|=
literal|0
decl_stmt|,
name|error3
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|uap
operator|->
name|ruid
condition|)
name|error1
operator|=
name|copyout
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|pc
operator|->
name|p_ruid
argument_list|,
operator|(
name|caddr_t
operator|)
name|uap
operator|->
name|ruid
argument_list|,
sizeof|sizeof
argument_list|(
name|pc
operator|->
name|p_ruid
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|uap
operator|->
name|euid
condition|)
name|error2
operator|=
name|copyout
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|pc
operator|->
name|pc_ucred
operator|->
name|cr_uid
argument_list|,
operator|(
name|caddr_t
operator|)
name|uap
operator|->
name|euid
argument_list|,
sizeof|sizeof
argument_list|(
name|pc
operator|->
name|pc_ucred
operator|->
name|cr_uid
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|uap
operator|->
name|suid
condition|)
name|error3
operator|=
name|copyout
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|pc
operator|->
name|p_svuid
argument_list|,
operator|(
name|caddr_t
operator|)
name|uap
operator|->
name|suid
argument_list|,
sizeof|sizeof
argument_list|(
name|pc
operator|->
name|p_svuid
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|error1
condition|?
name|error1
else|:
operator|(
name|error2
condition|?
name|error2
else|:
name|error3
operator|)
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|_SYS_SYSPROTO_H_
end_ifndef

begin_struct
struct|struct
name|getresgid_args
block|{
name|gid_t
modifier|*
name|rgid
decl_stmt|;
name|gid_t
modifier|*
name|egid
decl_stmt|;
name|gid_t
modifier|*
name|sgid
decl_stmt|;
block|}
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|getresgid
parameter_list|(
name|p
parameter_list|,
name|uap
parameter_list|)
specifier|register
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|struct
name|getresgid_args
modifier|*
name|uap
decl_stmt|;
block|{
name|struct
name|pcred
modifier|*
name|pc
init|=
name|p
operator|->
name|p_cred
decl_stmt|;
name|int
name|error1
init|=
literal|0
decl_stmt|,
name|error2
init|=
literal|0
decl_stmt|,
name|error3
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|uap
operator|->
name|rgid
condition|)
name|error1
operator|=
name|copyout
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|pc
operator|->
name|p_rgid
argument_list|,
operator|(
name|caddr_t
operator|)
name|uap
operator|->
name|rgid
argument_list|,
sizeof|sizeof
argument_list|(
name|pc
operator|->
name|p_rgid
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|uap
operator|->
name|egid
condition|)
name|error2
operator|=
name|copyout
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|pc
operator|->
name|pc_ucred
operator|->
name|cr_groups
index|[
literal|0
index|]
argument_list|,
operator|(
name|caddr_t
operator|)
name|uap
operator|->
name|egid
argument_list|,
sizeof|sizeof
argument_list|(
name|pc
operator|->
name|pc_ucred
operator|->
name|cr_groups
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|uap
operator|->
name|sgid
condition|)
name|error3
operator|=
name|copyout
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|pc
operator|->
name|p_svgid
argument_list|,
operator|(
name|caddr_t
operator|)
name|uap
operator|->
name|sgid
argument_list|,
sizeof|sizeof
argument_list|(
name|pc
operator|->
name|p_svgid
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|error1
condition|?
name|error1
else|:
operator|(
name|error2
condition|?
name|error2
else|:
name|error3
operator|)
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|_SYS_SYSPROTO_H_
end_ifndef

begin_struct
struct|struct
name|issetugid_args
block|{
name|int
name|dummy
decl_stmt|;
block|}
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|issetugid
parameter_list|(
name|p
parameter_list|,
name|uap
parameter_list|)
specifier|register
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|struct
name|issetugid_args
modifier|*
name|uap
decl_stmt|;
block|{
comment|/* 	 * Note: OpenBSD sets a P_SUGIDEXEC flag set at execve() time, 	 * we use P_SUGID because we consider changing the owners as 	 * "tainting" as well. 	 * This is significant for procs that start as root and "become" 	 * a user without an exec - programs cannot know *everything* 	 * that libc *might* have put in their data segment. 	 */
name|p
operator|->
name|p_retval
index|[
literal|0
index|]
operator|=
operator|(
name|p
operator|->
name|p_flag
operator|&
name|P_SUGID
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Check if gid is a member of the group set.  */
end_comment

begin_function
name|int
name|groupmember
parameter_list|(
name|gid
parameter_list|,
name|cred
parameter_list|)
name|gid_t
name|gid
decl_stmt|;
specifier|register
name|struct
name|ucred
modifier|*
name|cred
decl_stmt|;
block|{
specifier|register
name|gid_t
modifier|*
name|gp
decl_stmt|;
name|gid_t
modifier|*
name|egp
decl_stmt|;
name|egp
operator|=
operator|&
operator|(
name|cred
operator|->
name|cr_groups
index|[
name|cred
operator|->
name|cr_ngroups
index|]
operator|)
expr_stmt|;
for|for
control|(
name|gp
operator|=
name|cred
operator|->
name|cr_groups
init|;
name|gp
operator|<
name|egp
condition|;
name|gp
operator|++
control|)
if|if
condition|(
operator|*
name|gp
operator|==
name|gid
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|int
name|suser_permitted
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_kern
argument_list|,
name|OID_AUTO
argument_list|,
name|suser_permitted
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|suser_permitted
argument_list|,
literal|0
argument_list|,
literal|"processes with uid 0 have privilege"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Test whether the specified credentials imply "super-user"  * privilege; if so, and we have accounting info, set the flag  * indicating use of super-powers.  * Returns 0 or error.  */
end_comment

begin_function
name|int
name|suser
parameter_list|(
name|p
parameter_list|)
specifier|const
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
block|{
return|return
name|suser_xxx
argument_list|(
literal|0
argument_list|,
name|p
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|suser_xxx
parameter_list|(
name|cred
parameter_list|,
name|proc
parameter_list|,
name|flag
parameter_list|)
specifier|const
name|struct
name|ucred
modifier|*
name|cred
decl_stmt|;
specifier|const
name|struct
name|proc
modifier|*
name|proc
decl_stmt|;
name|int
name|flag
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|suser_permitted
condition|)
return|return
operator|(
name|EPERM
operator|)
return|;
if|if
condition|(
operator|!
name|cred
operator|&&
operator|!
name|proc
condition|)
block|{
name|printf
argument_list|(
literal|"suser_xxx(): THINK!\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EPERM
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|cred
condition|)
name|cred
operator|=
name|proc
operator|->
name|p_ucred
expr_stmt|;
if|if
condition|(
name|cred
operator|->
name|cr_uid
operator|!=
literal|0
condition|)
return|return
operator|(
name|EPERM
operator|)
return|;
if|if
condition|(
name|proc
operator|&&
name|proc
operator|->
name|p_prison
operator|&&
operator|!
operator|(
name|flag
operator|&
name|PRISON_ROOT
operator|)
condition|)
return|return
operator|(
name|EPERM
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|p_cansee
parameter_list|(
specifier|const
name|struct
name|proc
modifier|*
name|p1
parameter_list|,
specifier|const
name|struct
name|proc
modifier|*
name|p2
parameter_list|,
name|int
modifier|*
name|privused
parameter_list|)
block|{
if|if
condition|(
name|privused
operator|!=
name|NULL
condition|)
operator|*
name|privused
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|PRISON_CHECK
argument_list|(
name|p1
argument_list|,
name|p2
argument_list|)
condition|)
return|return
operator|(
name|ESRCH
operator|)
return|;
if|if
condition|(
operator|!
name|ps_showallprocs
operator|&&
name|p1
operator|->
name|p_ucred
operator|->
name|cr_uid
operator|!=
name|p2
operator|->
name|p_ucred
operator|->
name|cr_uid
condition|)
block|{
if|if
condition|(
name|suser_xxx
argument_list|(
name|NULL
argument_list|,
name|p1
argument_list|,
name|PRISON_ROOT
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|privused
operator|!=
name|NULL
condition|)
operator|*
name|privused
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
name|ESRCH
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|p_cankill
parameter_list|(
specifier|const
name|struct
name|proc
modifier|*
name|p1
parameter_list|,
specifier|const
name|struct
name|proc
modifier|*
name|p2
parameter_list|,
name|int
modifier|*
name|privused
parameter_list|)
block|{
if|if
condition|(
name|privused
operator|!=
name|NULL
condition|)
operator|*
name|privused
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|p1
operator|==
name|p2
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|!
name|PRISON_CHECK
argument_list|(
name|p1
argument_list|,
name|p2
argument_list|)
condition|)
return|return
operator|(
name|ESRCH
operator|)
return|;
if|if
condition|(
name|p1
operator|->
name|p_cred
operator|->
name|p_ruid
operator|==
name|p2
operator|->
name|p_cred
operator|->
name|p_ruid
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|p1
operator|->
name|p_ucred
operator|->
name|cr_uid
operator|==
name|p2
operator|->
name|p_cred
operator|->
name|p_ruid
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * XXX should a process be able to affect another process 	 * acting as the same uid (i.e., a userland nfsd or the like?) 	 */
if|if
condition|(
name|p1
operator|->
name|p_cred
operator|->
name|p_ruid
operator|==
name|p2
operator|->
name|p_ucred
operator|->
name|cr_uid
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|p1
operator|->
name|p_ucred
operator|->
name|cr_uid
operator|==
name|p2
operator|->
name|p_ucred
operator|->
name|cr_uid
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|!
name|suser_xxx
argument_list|(
literal|0
argument_list|,
name|p1
argument_list|,
name|PRISON_ROOT
argument_list|)
condition|)
block|{
if|if
condition|(
name|privused
operator|!=
name|NULL
condition|)
operator|*
name|privused
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|CAPABILITIES
if|if
condition|(
operator|!
name|cap_check_xxx
argument_list|(
literal|0
argument_list|,
name|p1
argument_list|,
name|CAP_KILL
argument_list|,
name|PRISON_ROOT
argument_list|)
condition|)
block|{
if|if
condition|(
name|privused
operator|!=
name|NULL
condition|)
operator|*
name|privused
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
endif|#
directive|endif
return|return
operator|(
name|EPERM
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|p_cansched
parameter_list|(
specifier|const
name|struct
name|proc
modifier|*
name|p1
parameter_list|,
specifier|const
name|struct
name|proc
modifier|*
name|p2
parameter_list|,
name|int
modifier|*
name|privused
parameter_list|)
block|{
if|if
condition|(
name|privused
operator|!=
name|NULL
condition|)
operator|*
name|privused
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|p1
operator|==
name|p2
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|!
name|PRISON_CHECK
argument_list|(
name|p1
argument_list|,
name|p2
argument_list|)
condition|)
return|return
operator|(
name|ESRCH
operator|)
return|;
if|if
condition|(
name|p1
operator|->
name|p_cred
operator|->
name|p_ruid
operator|==
name|p2
operator|->
name|p_cred
operator|->
name|p_ruid
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|p1
operator|->
name|p_ucred
operator|->
name|cr_uid
operator|==
name|p2
operator|->
name|p_cred
operator|->
name|p_ruid
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * XXX should a process be able to affect another process 	 * acting as the same uid (i.e., a userland nfsd or the like?) 	 */
if|if
condition|(
name|p1
operator|->
name|p_cred
operator|->
name|p_ruid
operator|==
name|p2
operator|->
name|p_ucred
operator|->
name|cr_uid
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|p1
operator|->
name|p_ucred
operator|->
name|cr_uid
operator|==
name|p2
operator|->
name|p_ucred
operator|->
name|cr_uid
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|!
name|suser_xxx
argument_list|(
literal|0
argument_list|,
name|p1
argument_list|,
name|PRISON_ROOT
argument_list|)
condition|)
block|{
if|if
condition|(
name|privused
operator|!=
name|NULL
condition|)
operator|*
name|privused
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|CAPABILITIES
if|if
condition|(
operator|!
name|cap_check_xxx
argument_list|(
literal|0
argument_list|,
name|p1
argument_list|,
name|CAP_SYS_NICE
argument_list|,
name|PRISON_ROOT
argument_list|)
condition|)
block|{
if|if
condition|(
name|privused
operator|!=
name|NULL
condition|)
operator|*
name|privused
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
endif|#
directive|endif
return|return
operator|(
name|EPERM
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|p_candebug
parameter_list|(
specifier|const
name|struct
name|proc
modifier|*
name|p1
parameter_list|,
specifier|const
name|struct
name|proc
modifier|*
name|p2
parameter_list|,
name|int
modifier|*
name|privused
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
if|if
condition|(
name|privused
operator|!=
name|NULL
condition|)
operator|*
name|privused
operator|=
literal|0
expr_stmt|;
comment|/* XXX it is authorized, but semantics don't permit it */
if|if
condition|(
name|p1
operator|==
name|p2
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|!
name|PRISON_CHECK
argument_list|(
name|p1
argument_list|,
name|p2
argument_list|)
condition|)
return|return
operator|(
name|ESRCH
operator|)
return|;
comment|/* not owned by you, has done setuid (unless you're root) */
comment|/* add a CAP_SYS_PTRACE here? */
if|if
condition|(
name|p1
operator|->
name|p_cred
operator|->
name|pc_ucred
operator|->
name|cr_uid
operator|!=
name|p2
operator|->
name|p_cred
operator|->
name|p_ruid
operator|||
name|p1
operator|->
name|p_cred
operator|->
name|p_ruid
operator|!=
name|p2
operator|->
name|p_cred
operator|->
name|p_ruid
operator|||
name|p1
operator|->
name|p_cred
operator|->
name|p_svuid
operator|!=
name|p2
operator|->
name|p_cred
operator|->
name|p_ruid
operator|||
name|p2
operator|->
name|p_flag
operator|&
name|P_SUGID
condition|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|suser_xxx
argument_list|(
literal|0
argument_list|,
name|p1
argument_list|,
name|PRISON_ROOT
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|privused
operator|!=
name|NULL
condition|)
operator|*
name|privused
operator|=
literal|1
expr_stmt|;
block|}
comment|/* can't trace init when securelevel> 0 */
if|if
condition|(
name|securelevel
operator|>
literal|0
operator|&&
name|p2
operator|->
name|p_pid
operator|==
literal|1
condition|)
return|return
operator|(
name|EPERM
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|p_can
parameter_list|(
specifier|const
name|struct
name|proc
modifier|*
name|p1
parameter_list|,
specifier|const
name|struct
name|proc
modifier|*
name|p2
parameter_list|,
name|int
name|operation
parameter_list|,
name|int
modifier|*
name|privused
parameter_list|)
block|{
switch|switch
condition|(
name|operation
condition|)
block|{
case|case
name|P_CAN_SEE
case|:
return|return
operator|(
name|p_cansee
argument_list|(
name|p1
argument_list|,
name|p2
argument_list|,
name|privused
argument_list|)
operator|)
return|;
case|case
name|P_CAN_KILL
case|:
return|return
operator|(
name|p_cankill
argument_list|(
name|p1
argument_list|,
name|p2
argument_list|,
name|privused
argument_list|)
operator|)
return|;
case|case
name|P_CAN_SCHED
case|:
return|return
operator|(
name|p_cansched
argument_list|(
name|p1
argument_list|,
name|p2
argument_list|,
name|privused
argument_list|)
operator|)
return|;
case|case
name|P_CAN_DEBUG
case|:
return|return
operator|(
name|p_candebug
argument_list|(
name|p1
argument_list|,
name|p2
argument_list|,
name|privused
argument_list|)
operator|)
return|;
default|default:
name|panic
argument_list|(
literal|"p_can: invalid operation"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Allocate a zeroed cred structure.  */
end_comment

begin_function
name|struct
name|ucred
modifier|*
name|crget
parameter_list|()
block|{
specifier|register
name|struct
name|ucred
modifier|*
name|cr
decl_stmt|;
name|MALLOC
argument_list|(
name|cr
argument_list|,
expr|struct
name|ucred
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|cr
argument_list|)
argument_list|,
name|M_CRED
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|cr
operator|->
name|cr_ref
operator|=
literal|1
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|cr
operator|->
name|cr_mtx
argument_list|,
literal|"ucred"
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
return|return
operator|(
name|cr
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Free a cred structure.  * Throws away space when ref count gets to 0.  */
end_comment

begin_function
name|void
name|crfree
parameter_list|(
name|cr
parameter_list|)
name|struct
name|ucred
modifier|*
name|cr
decl_stmt|;
block|{
name|mtx_enter
argument_list|(
operator|&
name|cr
operator|->
name|cr_mtx
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
if|if
condition|(
operator|--
name|cr
operator|->
name|cr_ref
operator|==
literal|0
condition|)
block|{
name|mtx_destroy
argument_list|(
operator|&
name|cr
operator|->
name|cr_mtx
argument_list|)
expr_stmt|;
comment|/* 		 * Some callers of crget(), such as nfs_statfs(), 		 * allocate a temporary credential, but don't 		 * allocate a uidinfo structure. 		 */
if|if
condition|(
name|cr
operator|->
name|cr_uidinfo
operator|!=
name|NULL
condition|)
name|uifree
argument_list|(
name|cr
operator|->
name|cr_uidinfo
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
operator|(
name|caddr_t
operator|)
name|cr
argument_list|,
name|M_CRED
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mtx_exit
argument_list|(
operator|&
name|cr
operator|->
name|cr_mtx
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Copy cred structure to a new one and free the old one.  */
end_comment

begin_function
name|struct
name|ucred
modifier|*
name|crcopy
parameter_list|(
name|cr
parameter_list|)
name|struct
name|ucred
modifier|*
name|cr
decl_stmt|;
block|{
name|struct
name|ucred
modifier|*
name|newcr
decl_stmt|;
name|mtx_enter
argument_list|(
operator|&
name|cr
operator|->
name|cr_mtx
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
if|if
condition|(
name|cr
operator|->
name|cr_ref
operator|==
literal|1
condition|)
block|{
name|mtx_exit
argument_list|(
operator|&
name|cr
operator|->
name|cr_mtx
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
return|return
operator|(
name|cr
operator|)
return|;
block|}
name|mtx_exit
argument_list|(
operator|&
name|cr
operator|->
name|cr_mtx
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|newcr
operator|=
name|crdup
argument_list|(
name|cr
argument_list|)
expr_stmt|;
name|crfree
argument_list|(
name|cr
argument_list|)
expr_stmt|;
return|return
operator|(
name|newcr
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Dup cred struct to a new held one.  */
end_comment

begin_function
name|struct
name|ucred
modifier|*
name|crdup
parameter_list|(
name|cr
parameter_list|)
name|struct
name|ucred
modifier|*
name|cr
decl_stmt|;
block|{
name|struct
name|ucred
modifier|*
name|newcr
decl_stmt|;
name|MALLOC
argument_list|(
name|newcr
argument_list|,
expr|struct
name|ucred
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|cr
argument_list|)
argument_list|,
name|M_CRED
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
operator|*
name|newcr
operator|=
operator|*
name|cr
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|newcr
operator|->
name|cr_mtx
argument_list|,
literal|"ucred"
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|uihold
argument_list|(
name|newcr
operator|->
name|cr_uidinfo
argument_list|)
expr_stmt|;
name|newcr
operator|->
name|cr_ref
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|newcr
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Get login name, if available.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|_SYS_SYSPROTO_H_
end_ifndef

begin_struct
struct|struct
name|getlogin_args
block|{
name|char
modifier|*
name|namebuf
decl_stmt|;
name|u_int
name|namelen
decl_stmt|;
block|}
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|getlogin
parameter_list|(
name|p
parameter_list|,
name|uap
parameter_list|)
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|struct
name|getlogin_args
modifier|*
name|uap
decl_stmt|;
block|{
if|if
condition|(
name|uap
operator|->
name|namelen
operator|>
name|MAXLOGNAME
condition|)
name|uap
operator|->
name|namelen
operator|=
name|MAXLOGNAME
expr_stmt|;
return|return
operator|(
name|copyout
argument_list|(
operator|(
name|caddr_t
operator|)
name|p
operator|->
name|p_pgrp
operator|->
name|pg_session
operator|->
name|s_login
argument_list|,
operator|(
name|caddr_t
operator|)
name|uap
operator|->
name|namebuf
argument_list|,
name|uap
operator|->
name|namelen
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Set login name.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|_SYS_SYSPROTO_H_
end_ifndef

begin_struct
struct|struct
name|setlogin_args
block|{
name|char
modifier|*
name|namebuf
decl_stmt|;
block|}
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|setlogin
parameter_list|(
name|p
parameter_list|,
name|uap
parameter_list|)
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|struct
name|setlogin_args
modifier|*
name|uap
decl_stmt|;
block|{
name|int
name|error
decl_stmt|;
name|char
name|logintmp
index|[
name|MAXLOGNAME
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|suser_xxx
argument_list|(
literal|0
argument_list|,
name|p
argument_list|,
name|PRISON_ROOT
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|error
operator|=
name|copyinstr
argument_list|(
operator|(
name|caddr_t
operator|)
name|uap
operator|->
name|namebuf
argument_list|,
operator|(
name|caddr_t
operator|)
name|logintmp
argument_list|,
sizeof|sizeof
argument_list|(
name|logintmp
argument_list|)
argument_list|,
operator|(
name|size_t
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|ENAMETOOLONG
condition|)
name|error
operator|=
name|EINVAL
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|error
condition|)
operator|(
name|void
operator|)
name|memcpy
argument_list|(
name|p
operator|->
name|p_pgrp
operator|->
name|pg_session
operator|->
name|s_login
argument_list|,
name|logintmp
argument_list|,
sizeof|sizeof
argument_list|(
name|logintmp
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|void
name|setsugid
parameter_list|(
name|p
parameter_list|)
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
block|{
name|p
operator|->
name|p_flag
operator||=
name|P_SUGID
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|p
operator|->
name|p_pfsflags
operator|&
name|PF_ISUGID
operator|)
condition|)
name|p
operator|->
name|p_stops
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Helper function to change the effective uid of a process  */
end_comment

begin_function
name|void
name|change_euid
parameter_list|(
name|p
parameter_list|,
name|euid
parameter_list|)
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|uid_t
name|euid
decl_stmt|;
block|{
name|struct
name|pcred
modifier|*
name|pc
decl_stmt|;
name|struct
name|uidinfo
modifier|*
name|uip
decl_stmt|;
name|pc
operator|=
name|p
operator|->
name|p_cred
expr_stmt|;
comment|/* 	 * crcopy is essentially a NOP if ucred has a reference count 	 * of 1, which is true if it has already been copied. 	 */
name|pc
operator|->
name|pc_ucred
operator|=
name|crcopy
argument_list|(
name|pc
operator|->
name|pc_ucred
argument_list|)
expr_stmt|;
name|uip
operator|=
name|pc
operator|->
name|pc_ucred
operator|->
name|cr_uidinfo
expr_stmt|;
name|pc
operator|->
name|pc_ucred
operator|->
name|cr_uid
operator|=
name|euid
expr_stmt|;
name|pc
operator|->
name|pc_ucred
operator|->
name|cr_uidinfo
operator|=
name|uifind
argument_list|(
name|euid
argument_list|)
expr_stmt|;
name|uifree
argument_list|(
name|uip
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Helper function to change the real uid of a process  *  * The per-uid process count for this process is transfered from  * the old uid to the new uid.  */
end_comment

begin_function
name|void
name|change_ruid
parameter_list|(
name|p
parameter_list|,
name|ruid
parameter_list|)
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|uid_t
name|ruid
decl_stmt|;
block|{
name|struct
name|pcred
modifier|*
name|pc
decl_stmt|;
name|struct
name|uidinfo
modifier|*
name|uip
decl_stmt|;
name|pc
operator|=
name|p
operator|->
name|p_cred
expr_stmt|;
operator|(
name|void
operator|)
name|chgproccnt
argument_list|(
name|pc
operator|->
name|p_uidinfo
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|uip
operator|=
name|pc
operator|->
name|p_uidinfo
expr_stmt|;
comment|/* It is assumed that pcred is not shared between processes */
name|pc
operator|->
name|p_ruid
operator|=
name|ruid
expr_stmt|;
name|pc
operator|->
name|p_uidinfo
operator|=
name|uifind
argument_list|(
name|ruid
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|chgproccnt
argument_list|(
name|pc
operator|->
name|p_uidinfo
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|uifree
argument_list|(
name|uip
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

