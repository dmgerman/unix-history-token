begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1982, 1986, 1989, 1990, 1991, 1993  *	The Regents of the University of California.  All rights reserved.  * Copyright (c) 2000-2001 Robert N. M. Watson.  All rights reserved.  * (c) UNIX System Laboratories, Inc.  *  * All or some portions of this file are derived from material licensed  * to the University of California by American Telephone and Telegraph  * Co. or Unix System Laboratories, Inc. and are reproduced herein with  * the permission of UNIX System Laboratories, Inc.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *	@(#)kern_prot.c	8.6 (Berkeley) 1/21/94  * $FreeBSD$  */
end_comment

begin_comment
comment|/*  * System calls related to processes and protection  */
end_comment

begin_include
include|#
directive|include
file|"opt_compat.h"
end_include

begin_include
include|#
directive|include
file|"opt_global.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/acct.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/sx.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysproto.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/pioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/resourcevar.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/jail.h>
end_include

begin_expr_stmt
specifier|static
name|MALLOC_DEFINE
argument_list|(
name|M_CRED
argument_list|,
literal|"cred"
argument_list|,
literal|"credentials"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_kern
argument_list|,
name|OID_AUTO
argument_list|,
name|security
argument_list|,
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
literal|"Kernel security policy"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_kern_security
argument_list|,
name|OID_AUTO
argument_list|,
name|bsd
argument_list|,
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
literal|"BSD security policy"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|_SYS_SYSPROTO_H_
end_ifndef

begin_struct
struct|struct
name|getpid_args
block|{
name|int
name|dummy
decl_stmt|;
block|}
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * getpid  */
end_comment

begin_comment
comment|/*  * MPSAFE  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|getpid
parameter_list|(
name|td
parameter_list|,
name|uap
parameter_list|)
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|getpid_args
modifier|*
name|uap
decl_stmt|;
block|{
name|struct
name|proc
modifier|*
name|p
init|=
name|td
operator|->
name|td_proc
decl_stmt|;
name|int
name|s
decl_stmt|;
name|s
operator|=
name|mtx_lock_giant
argument_list|(
name|kern_giant_proc
argument_list|)
expr_stmt|;
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|=
name|p
operator|->
name|p_pid
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|COMPAT_43
argument_list|)
operator|||
name|defined
argument_list|(
name|COMPAT_SUNOS
argument_list|)
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|td
operator|->
name|td_retval
index|[
literal|1
index|]
operator|=
name|p
operator|->
name|p_pptr
operator|->
name|p_pid
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|mtx_unlock_giant
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * getppid  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|_SYS_SYSPROTO_H_
end_ifndef

begin_struct
struct|struct
name|getppid_args
block|{
name|int
name|dummy
decl_stmt|;
block|}
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * MPSAFE  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|getppid
parameter_list|(
name|td
parameter_list|,
name|uap
parameter_list|)
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|getppid_args
modifier|*
name|uap
decl_stmt|;
block|{
name|struct
name|proc
modifier|*
name|p
init|=
name|td
operator|->
name|td_proc
decl_stmt|;
name|int
name|s
decl_stmt|;
name|s
operator|=
name|mtx_lock_giant
argument_list|(
name|kern_giant_proc
argument_list|)
expr_stmt|;
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|=
name|p
operator|->
name|p_pptr
operator|->
name|p_pid
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|mtx_unlock_giant
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*   * Get process group ID; note that POSIX getpgrp takes no parameter   *  * MP SAFE  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|_SYS_SYSPROTO_H_
end_ifndef

begin_struct
struct|struct
name|getpgrp_args
block|{
name|int
name|dummy
decl_stmt|;
block|}
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * MPSAFE  */
end_comment

begin_function
name|int
name|getpgrp
parameter_list|(
name|td
parameter_list|,
name|uap
parameter_list|)
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|getpgrp_args
modifier|*
name|uap
decl_stmt|;
block|{
name|struct
name|proc
modifier|*
name|p
init|=
name|td
operator|->
name|td_proc
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|=
name|p
operator|->
name|p_pgrp
operator|->
name|pg_id
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Get an arbitary pid's process group id */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|_SYS_SYSPROTO_H_
end_ifndef

begin_struct
struct|struct
name|getpgid_args
block|{
name|pid_t
name|pid
decl_stmt|;
block|}
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * MPSAFE  */
end_comment

begin_function
name|int
name|getpgid
parameter_list|(
name|td
parameter_list|,
name|uap
parameter_list|)
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|getpgid_args
modifier|*
name|uap
decl_stmt|;
block|{
name|struct
name|proc
modifier|*
name|p
init|=
name|td
operator|->
name|td_proc
decl_stmt|;
name|struct
name|proc
modifier|*
name|pt
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|int
name|s
decl_stmt|;
name|s
operator|=
name|mtx_lock_giant
argument_list|(
name|kern_giant_proc
argument_list|)
expr_stmt|;
if|if
condition|(
name|uap
operator|->
name|pid
operator|==
literal|0
condition|)
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|=
name|p
operator|->
name|p_pgrp
operator|->
name|pg_id
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|pt
operator|=
name|pfind
argument_list|(
name|uap
operator|->
name|pid
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|error
operator|=
name|ESRCH
expr_stmt|;
else|else
block|{
name|error
operator|=
name|p_cansee
argument_list|(
name|p
argument_list|,
name|pt
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|=
name|pt
operator|->
name|p_pgrp
operator|->
name|pg_id
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|pt
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock_giant
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Get an arbitary pid's session id.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|_SYS_SYSPROTO_H_
end_ifndef

begin_struct
struct|struct
name|getsid_args
block|{
name|pid_t
name|pid
decl_stmt|;
block|}
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * MPSAFE  */
end_comment

begin_function
name|int
name|getsid
parameter_list|(
name|td
parameter_list|,
name|uap
parameter_list|)
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|getsid_args
modifier|*
name|uap
decl_stmt|;
block|{
name|struct
name|proc
modifier|*
name|p
init|=
name|td
operator|->
name|td_proc
decl_stmt|;
name|struct
name|proc
modifier|*
name|pt
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
if|if
condition|(
name|uap
operator|->
name|pid
operator|==
literal|0
condition|)
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|=
name|p
operator|->
name|p_session
operator|->
name|s_sid
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|pt
operator|=
name|pfind
argument_list|(
name|uap
operator|->
name|pid
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|error
operator|=
name|ESRCH
expr_stmt|;
else|else
block|{
name|error
operator|=
name|p_cansee
argument_list|(
name|p
argument_list|,
name|pt
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|=
name|pt
operator|->
name|p_session
operator|->
name|s_sid
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|pt
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * getuid() - MP SAFE  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|_SYS_SYSPROTO_H_
end_ifndef

begin_struct
struct|struct
name|getuid_args
block|{
name|int
name|dummy
decl_stmt|;
block|}
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * MPSAFE  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|getuid
parameter_list|(
name|td
parameter_list|,
name|uap
parameter_list|)
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|getuid_args
modifier|*
name|uap
decl_stmt|;
block|{
name|struct
name|proc
modifier|*
name|p
init|=
name|td
operator|->
name|td_proc
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|=
name|p
operator|->
name|p_ucred
operator|->
name|cr_ruid
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|COMPAT_43
argument_list|)
operator|||
name|defined
argument_list|(
name|COMPAT_SUNOS
argument_list|)
name|td
operator|->
name|td_retval
index|[
literal|1
index|]
operator|=
name|p
operator|->
name|p_ucred
operator|->
name|cr_uid
expr_stmt|;
endif|#
directive|endif
name|mtx_unlock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * geteuid() - MP SAFE  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|_SYS_SYSPROTO_H_
end_ifndef

begin_struct
struct|struct
name|geteuid_args
block|{
name|int
name|dummy
decl_stmt|;
block|}
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|geteuid
parameter_list|(
name|td
parameter_list|,
name|uap
parameter_list|)
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|geteuid_args
modifier|*
name|uap
decl_stmt|;
block|{
name|mtx_lock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|=
name|td
operator|->
name|td_proc
operator|->
name|p_ucred
operator|->
name|cr_uid
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * getgid() - MP SAFE  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|_SYS_SYSPROTO_H_
end_ifndef

begin_struct
struct|struct
name|getgid_args
block|{
name|int
name|dummy
decl_stmt|;
block|}
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * MPSAFE  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|getgid
parameter_list|(
name|td
parameter_list|,
name|uap
parameter_list|)
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|getgid_args
modifier|*
name|uap
decl_stmt|;
block|{
name|struct
name|proc
modifier|*
name|p
init|=
name|td
operator|->
name|td_proc
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|=
name|p
operator|->
name|p_ucred
operator|->
name|cr_rgid
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|COMPAT_43
argument_list|)
operator|||
name|defined
argument_list|(
name|COMPAT_SUNOS
argument_list|)
name|td
operator|->
name|td_retval
index|[
literal|1
index|]
operator|=
name|p
operator|->
name|p_ucred
operator|->
name|cr_groups
index|[
literal|0
index|]
expr_stmt|;
endif|#
directive|endif
name|mtx_unlock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Get effective group ID.  The "egid" is groups[0], and could be obtained  * via getgroups.  This syscall exists because it is somewhat painful to do  * correctly in a library function.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|_SYS_SYSPROTO_H_
end_ifndef

begin_struct
struct|struct
name|getegid_args
block|{
name|int
name|dummy
decl_stmt|;
block|}
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * MPSAFE  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|getegid
parameter_list|(
name|td
parameter_list|,
name|uap
parameter_list|)
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|getegid_args
modifier|*
name|uap
decl_stmt|;
block|{
name|struct
name|proc
modifier|*
name|p
init|=
name|td
operator|->
name|td_proc
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|=
name|p
operator|->
name|p_ucred
operator|->
name|cr_groups
index|[
literal|0
index|]
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|_SYS_SYSPROTO_H_
end_ifndef

begin_struct
struct|struct
name|getgroups_args
block|{
name|u_int
name|gidsetsize
decl_stmt|;
name|gid_t
modifier|*
name|gidset
decl_stmt|;
block|}
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * MPSAFE  */
end_comment

begin_function
name|int
name|getgroups
parameter_list|(
name|td
parameter_list|,
name|uap
parameter_list|)
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
specifier|register
name|struct
name|getgroups_args
modifier|*
name|uap
decl_stmt|;
block|{
name|struct
name|ucred
modifier|*
name|cred
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
init|=
name|td
operator|->
name|td_proc
decl_stmt|;
name|u_int
name|ngrp
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
name|cred
operator|=
name|p
operator|->
name|p_ucred
expr_stmt|;
if|if
condition|(
operator|(
name|ngrp
operator|=
name|uap
operator|->
name|gidsetsize
operator|)
operator|==
literal|0
condition|)
block|{
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|=
name|cred
operator|->
name|cr_ngroups
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
goto|goto
name|done2
goto|;
block|}
if|if
condition|(
name|ngrp
operator|<
name|cred
operator|->
name|cr_ngroups
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|done2
goto|;
block|}
name|ngrp
operator|=
name|cred
operator|->
name|cr_ngroups
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|copyout
argument_list|(
operator|(
name|caddr_t
operator|)
name|cred
operator|->
name|cr_groups
argument_list|,
operator|(
name|caddr_t
operator|)
name|uap
operator|->
name|gidset
argument_list|,
name|ngrp
operator|*
sizeof|sizeof
argument_list|(
name|gid_t
argument_list|)
argument_list|)
operator|)
condition|)
block|{
goto|goto
name|done2
goto|;
block|}
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|=
name|ngrp
expr_stmt|;
name|done2
label|:
name|mtx_unlock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|_SYS_SYSPROTO_H_
end_ifndef

begin_struct
struct|struct
name|setsid_args
block|{
name|int
name|dummy
decl_stmt|;
block|}
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * MPSAFE  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|setsid
parameter_list|(
name|td
parameter_list|,
name|uap
parameter_list|)
specifier|register
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|setsid_args
modifier|*
name|uap
decl_stmt|;
block|{
name|int
name|error
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
init|=
name|td
operator|->
name|td_proc
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|p_pgid
operator|==
name|p
operator|->
name|p_pid
operator|||
name|pgfind
argument_list|(
name|p
operator|->
name|p_pid
argument_list|)
condition|)
block|{
name|error
operator|=
name|EPERM
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|enterpgrp
argument_list|(
name|p
argument_list|,
name|p
operator|->
name|p_pid
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|=
name|p
operator|->
name|p_pid
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * set process group (setpgid/old setpgrp)  *  * caller does setpgid(targpid, targpgid)  *  * pid must be caller or child of caller (ESRCH)  * if a child  *	pid must be in same session (EPERM)  *	pid can't have done an exec (EACCES)  * if pgid != pid  * 	there must exist some pid in same session having pgid (EPERM)  * pid must not be session leader (EPERM)  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|_SYS_SYSPROTO_H_
end_ifndef

begin_struct
struct|struct
name|setpgid_args
block|{
name|int
name|pid
decl_stmt|;
comment|/* target process id */
name|int
name|pgid
decl_stmt|;
comment|/* target pgrp id */
block|}
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * MPSAFE  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|setpgid
parameter_list|(
name|td
parameter_list|,
name|uap
parameter_list|)
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
specifier|register
name|struct
name|setpgid_args
modifier|*
name|uap
decl_stmt|;
block|{
name|struct
name|proc
modifier|*
name|curp
init|=
name|td
operator|->
name|td_proc
decl_stmt|;
specifier|register
name|struct
name|proc
modifier|*
name|targp
decl_stmt|;
comment|/* target process */
specifier|register
name|struct
name|pgrp
modifier|*
name|pgrp
decl_stmt|;
comment|/* target pgrp */
name|int
name|error
decl_stmt|;
if|if
condition|(
name|uap
operator|->
name|pgid
operator|<
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|mtx_lock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
name|sx_slock
argument_list|(
operator|&
name|proctree_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|uap
operator|->
name|pid
operator|!=
literal|0
operator|&&
name|uap
operator|->
name|pid
operator|!=
name|curp
operator|->
name|p_pid
condition|)
block|{
if|if
condition|(
operator|(
name|targp
operator|=
name|pfind
argument_list|(
name|uap
operator|->
name|pid
argument_list|)
operator|)
operator|==
name|NULL
operator|||
operator|!
name|inferior
argument_list|(
name|targp
argument_list|)
condition|)
block|{
if|if
condition|(
name|targp
condition|)
name|PROC_UNLOCK
argument_list|(
name|targp
argument_list|)
expr_stmt|;
name|error
operator|=
name|ESRCH
expr_stmt|;
goto|goto
name|done2
goto|;
block|}
if|if
condition|(
operator|(
name|error
operator|=
name|p_cansee
argument_list|(
name|curproc
argument_list|,
name|targp
argument_list|)
operator|)
condition|)
block|{
name|PROC_UNLOCK
argument_list|(
name|targp
argument_list|)
expr_stmt|;
goto|goto
name|done2
goto|;
block|}
if|if
condition|(
name|targp
operator|->
name|p_pgrp
operator|==
name|NULL
operator|||
name|targp
operator|->
name|p_session
operator|!=
name|curp
operator|->
name|p_session
condition|)
block|{
name|PROC_UNLOCK
argument_list|(
name|targp
argument_list|)
expr_stmt|;
name|error
operator|=
name|EPERM
expr_stmt|;
goto|goto
name|done2
goto|;
block|}
if|if
condition|(
name|targp
operator|->
name|p_flag
operator|&
name|P_EXEC
condition|)
block|{
name|PROC_UNLOCK
argument_list|(
name|targp
argument_list|)
expr_stmt|;
name|error
operator|=
name|EACCES
expr_stmt|;
goto|goto
name|done2
goto|;
block|}
block|}
else|else
block|{
name|targp
operator|=
name|curp
expr_stmt|;
name|PROC_LOCK
argument_list|(
name|curp
argument_list|)
expr_stmt|;
comment|/* XXX: not needed */
block|}
if|if
condition|(
name|SESS_LEADER
argument_list|(
name|targp
argument_list|)
condition|)
block|{
name|PROC_UNLOCK
argument_list|(
name|targp
argument_list|)
expr_stmt|;
name|error
operator|=
name|EPERM
expr_stmt|;
goto|goto
name|done2
goto|;
block|}
if|if
condition|(
name|uap
operator|->
name|pgid
operator|==
literal|0
condition|)
block|{
name|uap
operator|->
name|pgid
operator|=
name|targp
operator|->
name|p_pid
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|uap
operator|->
name|pgid
operator|!=
name|targp
operator|->
name|p_pid
condition|)
block|{
if|if
condition|(
operator|(
name|pgrp
operator|=
name|pgfind
argument_list|(
name|uap
operator|->
name|pgid
argument_list|)
operator|)
operator|==
literal|0
operator|||
name|pgrp
operator|->
name|pg_session
operator|!=
name|curp
operator|->
name|p_session
condition|)
block|{
name|PROC_UNLOCK
argument_list|(
name|targp
argument_list|)
expr_stmt|;
name|error
operator|=
name|EPERM
expr_stmt|;
goto|goto
name|done2
goto|;
block|}
block|}
comment|/* XXX: We should probably hold the lock across enterpgrp. */
name|PROC_UNLOCK
argument_list|(
name|targp
argument_list|)
expr_stmt|;
name|error
operator|=
name|enterpgrp
argument_list|(
name|targp
argument_list|,
name|uap
operator|->
name|pgid
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|done2
label|:
name|sx_sunlock
argument_list|(
operator|&
name|proctree_lock
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Use the clause in B.4.2.2 that allows setuid/setgid to be 4.2/4.3BSD  * compatible.  It says that setting the uid/gid to euid/egid is a special  * case of "appropriate privilege".  Once the rules are expanded out, this  * basically means that setuid(nnn) sets all three id's, in all permitted  * cases unless _POSIX_SAVED_IDS is enabled.  In that case, setuid(getuid())  * does not set the saved id - this is dangerous for traditional BSD  * programs.  For this reason, we *really* do not want to set  * _POSIX_SAVED_IDS and do not want to clear POSIX_APPENDIX_B_4_2_2.  */
end_comment

begin_define
define|#
directive|define
name|POSIX_APPENDIX_B_4_2_2
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|_SYS_SYSPROTO_H_
end_ifndef

begin_struct
struct|struct
name|setuid_args
block|{
name|uid_t
name|uid
decl_stmt|;
block|}
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * MPSAFE  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|setuid
parameter_list|(
name|td
parameter_list|,
name|uap
parameter_list|)
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|setuid_args
modifier|*
name|uap
decl_stmt|;
block|{
name|struct
name|proc
modifier|*
name|p
init|=
name|td
operator|->
name|td_proc
decl_stmt|;
name|struct
name|ucred
modifier|*
name|newcred
decl_stmt|,
modifier|*
name|oldcred
decl_stmt|;
name|uid_t
name|uid
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|uid
operator|=
name|uap
operator|->
name|uid
expr_stmt|;
name|oldcred
operator|=
name|p
operator|->
name|p_ucred
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
comment|/* 	 * See if we have "permission" by POSIX 1003.1 rules. 	 * 	 * Note that setuid(geteuid()) is a special case of  	 * "appropriate privileges" in appendix B.4.2.2.  We need 	 * to use this clause to be compatible with traditional BSD 	 * semantics.  Basically, it means that "setuid(xx)" sets all 	 * three id's (assuming you have privs). 	 * 	 * Notes on the logic.  We do things in three steps. 	 * 1: We determine if the euid is going to change, and do EPERM 	 *    right away.  We unconditionally change the euid later if this 	 *    test is satisfied, simplifying that part of the logic. 	 * 2: We determine if the real and/or saved uid's are going to 	 *    change.  Determined by compile options. 	 * 3: Change euid last. (after tests in #2 for "appropriate privs") 	 */
if|if
condition|(
name|uid
operator|!=
name|oldcred
operator|->
name|cr_ruid
operator|&&
comment|/* allow setuid(getuid()) */
ifdef|#
directive|ifdef
name|_POSIX_SAVED_IDS
name|uid
operator|!=
name|oldcred
operator|->
name|cr_svuid
operator|&&
comment|/* allow setuid(saved gid) */
endif|#
directive|endif
ifdef|#
directive|ifdef
name|POSIX_APPENDIX_B_4_2_2
comment|/* Use BSD-compat clause from B.4.2.2 */
name|uid
operator|!=
name|oldcred
operator|->
name|cr_uid
operator|&&
comment|/* allow setuid(geteuid()) */
endif|#
directive|endif
operator|(
name|error
operator|=
name|suser_xxx
argument_list|(
name|oldcred
argument_list|,
name|NULL
argument_list|,
name|PRISON_ROOT
argument_list|)
operator|)
condition|)
goto|goto
name|done2
goto|;
name|newcred
operator|=
name|crdup
argument_list|(
name|oldcred
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|_POSIX_SAVED_IDS
comment|/* 	 * Do we have "appropriate privileges" (are we root or uid == euid) 	 * If so, we are changing the real uid and/or saved uid. 	 */
if|if
condition|(
ifdef|#
directive|ifdef
name|POSIX_APPENDIX_B_4_2_2
comment|/* Use the clause from B.4.2.2 */
name|uid
operator|==
name|oldcred
operator|->
name|cr_uid
operator|||
endif|#
directive|endif
name|suser_xxx
argument_list|(
name|oldcred
argument_list|,
name|NULL
argument_list|,
name|PRISON_ROOT
argument_list|)
operator|==
literal|0
condition|)
comment|/* we are using privs */
endif|#
directive|endif
block|{
comment|/* 		 * Set the real uid and transfer proc count to new user. 		 */
if|if
condition|(
name|uid
operator|!=
name|oldcred
operator|->
name|cr_ruid
condition|)
block|{
name|change_ruid
argument_list|(
name|newcred
argument_list|,
name|uid
argument_list|)
expr_stmt|;
name|setsugid
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Set saved uid 		 * 		 * XXX always set saved uid even if not _POSIX_SAVED_IDS, as 		 * the security of seteuid() depends on it.  B.4.2.2 says it 		 * is important that we should do this. 		 */
if|if
condition|(
name|uid
operator|!=
name|oldcred
operator|->
name|cr_svuid
condition|)
block|{
name|change_svuid
argument_list|(
name|newcred
argument_list|,
name|uid
argument_list|)
expr_stmt|;
name|setsugid
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * In all permitted cases, we are changing the euid. 	 * Copy credentials so other references do not see our changes. 	 */
if|if
condition|(
name|uid
operator|!=
name|oldcred
operator|->
name|cr_uid
condition|)
block|{
name|change_euid
argument_list|(
name|newcred
argument_list|,
name|uid
argument_list|)
expr_stmt|;
name|setsugid
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
name|p
operator|->
name|p_ucred
operator|=
name|newcred
expr_stmt|;
name|crfree
argument_list|(
name|oldcred
argument_list|)
expr_stmt|;
name|done2
label|:
name|mtx_unlock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|_SYS_SYSPROTO_H_
end_ifndef

begin_struct
struct|struct
name|seteuid_args
block|{
name|uid_t
name|euid
decl_stmt|;
block|}
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * MPSAFE  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|seteuid
parameter_list|(
name|td
parameter_list|,
name|uap
parameter_list|)
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|seteuid_args
modifier|*
name|uap
decl_stmt|;
block|{
name|struct
name|proc
modifier|*
name|p
init|=
name|td
operator|->
name|td_proc
decl_stmt|;
name|struct
name|ucred
modifier|*
name|newcred
decl_stmt|,
modifier|*
name|oldcred
decl_stmt|;
name|uid_t
name|euid
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|euid
operator|=
name|uap
operator|->
name|euid
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
name|oldcred
operator|=
name|p
operator|->
name|p_ucred
expr_stmt|;
if|if
condition|(
name|euid
operator|!=
name|oldcred
operator|->
name|cr_ruid
operator|&&
comment|/* allow seteuid(getuid()) */
name|euid
operator|!=
name|oldcred
operator|->
name|cr_svuid
operator|&&
comment|/* allow seteuid(saved uid) */
operator|(
name|error
operator|=
name|suser_xxx
argument_list|(
name|oldcred
argument_list|,
name|NULL
argument_list|,
name|PRISON_ROOT
argument_list|)
operator|)
condition|)
block|{
goto|goto
name|done2
goto|;
block|}
comment|/* 	 * Everything's okay, do it.  Copy credentials so other references do 	 * not see our changes. 	 */
name|newcred
operator|=
name|crdup
argument_list|(
name|oldcred
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldcred
operator|->
name|cr_uid
operator|!=
name|euid
condition|)
block|{
name|change_euid
argument_list|(
name|newcred
argument_list|,
name|euid
argument_list|)
expr_stmt|;
name|setsugid
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
name|p
operator|->
name|p_ucred
operator|=
name|newcred
expr_stmt|;
name|crfree
argument_list|(
name|oldcred
argument_list|)
expr_stmt|;
name|done2
label|:
name|mtx_unlock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|_SYS_SYSPROTO_H_
end_ifndef

begin_struct
struct|struct
name|setgid_args
block|{
name|gid_t
name|gid
decl_stmt|;
block|}
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * MPSAFE  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|setgid
parameter_list|(
name|td
parameter_list|,
name|uap
parameter_list|)
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|setgid_args
modifier|*
name|uap
decl_stmt|;
block|{
name|struct
name|proc
modifier|*
name|p
init|=
name|td
operator|->
name|td_proc
decl_stmt|;
name|struct
name|ucred
modifier|*
name|newcred
decl_stmt|,
modifier|*
name|oldcred
decl_stmt|;
name|gid_t
name|gid
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|gid
operator|=
name|uap
operator|->
name|gid
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
name|oldcred
operator|=
name|p
operator|->
name|p_ucred
expr_stmt|;
comment|/* 	 * See if we have "permission" by POSIX 1003.1 rules. 	 * 	 * Note that setgid(getegid()) is a special case of 	 * "appropriate privileges" in appendix B.4.2.2.  We need 	 * to use this clause to be compatible with traditional BSD 	 * semantics.  Basically, it means that "setgid(xx)" sets all 	 * three id's (assuming you have privs). 	 * 	 * For notes on the logic here, see setuid() above. 	 */
if|if
condition|(
name|gid
operator|!=
name|oldcred
operator|->
name|cr_rgid
operator|&&
comment|/* allow setgid(getgid()) */
ifdef|#
directive|ifdef
name|_POSIX_SAVED_IDS
name|gid
operator|!=
name|oldcred
operator|->
name|cr_svgid
operator|&&
comment|/* allow setgid(saved gid) */
endif|#
directive|endif
ifdef|#
directive|ifdef
name|POSIX_APPENDIX_B_4_2_2
comment|/* Use BSD-compat clause from B.4.2.2 */
name|gid
operator|!=
name|oldcred
operator|->
name|cr_groups
index|[
literal|0
index|]
operator|&&
comment|/* allow setgid(getegid()) */
endif|#
directive|endif
operator|(
name|error
operator|=
name|suser_xxx
argument_list|(
name|oldcred
argument_list|,
name|NULL
argument_list|,
name|PRISON_ROOT
argument_list|)
operator|)
condition|)
block|{
goto|goto
name|done2
goto|;
block|}
name|newcred
operator|=
name|crdup
argument_list|(
name|oldcred
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|_POSIX_SAVED_IDS
comment|/* 	 * Do we have "appropriate privileges" (are we root or gid == egid) 	 * If so, we are changing the real uid and saved gid. 	 */
if|if
condition|(
ifdef|#
directive|ifdef
name|POSIX_APPENDIX_B_4_2_2
comment|/* use the clause from B.4.2.2 */
name|gid
operator|==
name|oldcred
operator|->
name|cr_groups
index|[
literal|0
index|]
operator|||
endif|#
directive|endif
name|suser_xxx
argument_list|(
name|oldcred
argument_list|,
name|NULL
argument_list|,
name|PRISON_ROOT
argument_list|)
operator|==
literal|0
condition|)
comment|/* we are using privs */
endif|#
directive|endif
block|{
comment|/* 		 * Set real gid 		 */
if|if
condition|(
name|oldcred
operator|->
name|cr_rgid
operator|!=
name|gid
condition|)
block|{
name|change_rgid
argument_list|(
name|newcred
argument_list|,
name|gid
argument_list|)
expr_stmt|;
name|setsugid
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Set saved gid 		 * 		 * XXX always set saved gid even if not _POSIX_SAVED_IDS, as 		 * the security of setegid() depends on it.  B.4.2.2 says it 		 * is important that we should do this. 		 */
if|if
condition|(
name|oldcred
operator|->
name|cr_svgid
operator|!=
name|gid
condition|)
block|{
name|change_svgid
argument_list|(
name|newcred
argument_list|,
name|gid
argument_list|)
expr_stmt|;
name|setsugid
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * In all cases permitted cases, we are changing the egid. 	 * Copy credentials so other references do not see our changes. 	 */
if|if
condition|(
name|oldcred
operator|->
name|cr_groups
index|[
literal|0
index|]
operator|!=
name|gid
condition|)
block|{
name|change_egid
argument_list|(
name|newcred
argument_list|,
name|gid
argument_list|)
expr_stmt|;
name|setsugid
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
name|p
operator|->
name|p_ucred
operator|=
name|newcred
expr_stmt|;
name|crfree
argument_list|(
name|oldcred
argument_list|)
expr_stmt|;
name|done2
label|:
name|mtx_unlock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|_SYS_SYSPROTO_H_
end_ifndef

begin_struct
struct|struct
name|setegid_args
block|{
name|gid_t
name|egid
decl_stmt|;
block|}
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * MPSAFE  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|setegid
parameter_list|(
name|td
parameter_list|,
name|uap
parameter_list|)
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|setegid_args
modifier|*
name|uap
decl_stmt|;
block|{
name|struct
name|proc
modifier|*
name|p
init|=
name|td
operator|->
name|td_proc
decl_stmt|;
name|struct
name|ucred
modifier|*
name|newcred
decl_stmt|,
modifier|*
name|oldcred
decl_stmt|;
name|gid_t
name|egid
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|egid
operator|=
name|uap
operator|->
name|egid
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
name|oldcred
operator|=
name|p
operator|->
name|p_ucred
expr_stmt|;
if|if
condition|(
name|egid
operator|!=
name|oldcred
operator|->
name|cr_rgid
operator|&&
comment|/* allow setegid(getgid()) */
name|egid
operator|!=
name|oldcred
operator|->
name|cr_svgid
operator|&&
comment|/* allow setegid(saved gid) */
operator|(
name|error
operator|=
name|suser_xxx
argument_list|(
name|oldcred
argument_list|,
name|NULL
argument_list|,
name|PRISON_ROOT
argument_list|)
operator|)
condition|)
block|{
goto|goto
name|done2
goto|;
block|}
name|newcred
operator|=
name|crdup
argument_list|(
name|oldcred
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldcred
operator|->
name|cr_groups
index|[
literal|0
index|]
operator|!=
name|egid
condition|)
block|{
name|change_egid
argument_list|(
name|newcred
argument_list|,
name|egid
argument_list|)
expr_stmt|;
name|setsugid
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
name|p
operator|->
name|p_ucred
operator|=
name|newcred
expr_stmt|;
name|crfree
argument_list|(
name|oldcred
argument_list|)
expr_stmt|;
name|done2
label|:
name|mtx_unlock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|_SYS_SYSPROTO_H_
end_ifndef

begin_struct
struct|struct
name|setgroups_args
block|{
name|u_int
name|gidsetsize
decl_stmt|;
name|gid_t
modifier|*
name|gidset
decl_stmt|;
block|}
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * MPSAFE  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|setgroups
parameter_list|(
name|td
parameter_list|,
name|uap
parameter_list|)
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|setgroups_args
modifier|*
name|uap
decl_stmt|;
block|{
name|struct
name|proc
modifier|*
name|p
init|=
name|td
operator|->
name|td_proc
decl_stmt|;
name|struct
name|ucred
modifier|*
name|newcred
decl_stmt|,
modifier|*
name|oldcred
decl_stmt|;
name|u_int
name|ngrp
decl_stmt|;
name|int
name|error
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
name|ngrp
operator|=
name|uap
operator|->
name|gidsetsize
expr_stmt|;
name|oldcred
operator|=
name|p
operator|->
name|p_ucred
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|suser_xxx
argument_list|(
name|oldcred
argument_list|,
name|NULL
argument_list|,
name|PRISON_ROOT
argument_list|)
operator|)
condition|)
goto|goto
name|done2
goto|;
if|if
condition|(
name|ngrp
operator|>
name|NGROUPS
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|done2
goto|;
block|}
comment|/* 	 * XXX A little bit lazy here.  We could test if anything has 	 * changed before crcopy() and setting P_SUGID. 	 */
name|newcred
operator|=
name|crdup
argument_list|(
name|oldcred
argument_list|)
expr_stmt|;
if|if
condition|(
name|ngrp
operator|<
literal|1
condition|)
block|{
comment|/* 		 * setgroups(0, NULL) is a legitimate way of clearing the 		 * groups vector on non-BSD systems (which generally do not 		 * have the egid in the groups[0]).  We risk security holes 		 * when running non-BSD software if we do not do the same. 		 */
name|newcred
operator|->
name|cr_ngroups
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|copyin
argument_list|(
operator|(
name|caddr_t
operator|)
name|uap
operator|->
name|gidset
argument_list|,
operator|(
name|caddr_t
operator|)
name|newcred
operator|->
name|cr_groups
argument_list|,
name|ngrp
operator|*
sizeof|sizeof
argument_list|(
name|gid_t
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|crfree
argument_list|(
name|newcred
argument_list|)
expr_stmt|;
goto|goto
name|done2
goto|;
block|}
name|newcred
operator|->
name|cr_ngroups
operator|=
name|ngrp
expr_stmt|;
block|}
name|setsugid
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|->
name|p_ucred
operator|=
name|newcred
expr_stmt|;
name|crfree
argument_list|(
name|oldcred
argument_list|)
expr_stmt|;
name|done2
label|:
name|mtx_unlock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|_SYS_SYSPROTO_H_
end_ifndef

begin_struct
struct|struct
name|setreuid_args
block|{
name|uid_t
name|ruid
decl_stmt|;
name|uid_t
name|euid
decl_stmt|;
block|}
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * MPSAFE  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|setreuid
parameter_list|(
name|td
parameter_list|,
name|uap
parameter_list|)
specifier|register
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|setreuid_args
modifier|*
name|uap
decl_stmt|;
block|{
name|struct
name|proc
modifier|*
name|p
init|=
name|td
operator|->
name|td_proc
decl_stmt|;
name|struct
name|ucred
modifier|*
name|newcred
decl_stmt|,
modifier|*
name|oldcred
decl_stmt|;
name|uid_t
name|ruid
decl_stmt|,
name|euid
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|ruid
operator|=
name|uap
operator|->
name|ruid
expr_stmt|;
name|euid
operator|=
name|uap
operator|->
name|euid
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
name|oldcred
operator|=
name|p
operator|->
name|p_ucred
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|ruid
operator|!=
operator|(
name|uid_t
operator|)
operator|-
literal|1
operator|&&
name|ruid
operator|!=
name|oldcred
operator|->
name|cr_ruid
operator|&&
name|ruid
operator|!=
name|oldcred
operator|->
name|cr_svuid
operator|)
operator|||
operator|(
name|euid
operator|!=
operator|(
name|uid_t
operator|)
operator|-
literal|1
operator|&&
name|euid
operator|!=
name|oldcred
operator|->
name|cr_uid
operator|&&
name|euid
operator|!=
name|oldcred
operator|->
name|cr_ruid
operator|&&
name|euid
operator|!=
name|oldcred
operator|->
name|cr_svuid
operator|)
operator|)
operator|&&
operator|(
name|error
operator|=
name|suser_xxx
argument_list|(
name|oldcred
argument_list|,
name|NULL
argument_list|,
name|PRISON_ROOT
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
goto|goto
name|done2
goto|;
block|}
name|newcred
operator|=
name|crdup
argument_list|(
name|oldcred
argument_list|)
expr_stmt|;
if|if
condition|(
name|euid
operator|!=
operator|(
name|uid_t
operator|)
operator|-
literal|1
operator|&&
name|oldcred
operator|->
name|cr_uid
operator|!=
name|euid
condition|)
block|{
name|change_euid
argument_list|(
name|newcred
argument_list|,
name|euid
argument_list|)
expr_stmt|;
name|setsugid
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ruid
operator|!=
operator|(
name|uid_t
operator|)
operator|-
literal|1
operator|&&
name|oldcred
operator|->
name|cr_ruid
operator|!=
name|ruid
condition|)
block|{
name|change_ruid
argument_list|(
name|newcred
argument_list|,
name|ruid
argument_list|)
expr_stmt|;
name|setsugid
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|ruid
operator|!=
operator|(
name|uid_t
operator|)
operator|-
literal|1
operator|||
name|newcred
operator|->
name|cr_uid
operator|!=
name|newcred
operator|->
name|cr_ruid
operator|)
operator|&&
name|newcred
operator|->
name|cr_svuid
operator|!=
name|newcred
operator|->
name|cr_uid
condition|)
block|{
name|change_svuid
argument_list|(
name|newcred
argument_list|,
name|newcred
operator|->
name|cr_uid
argument_list|)
expr_stmt|;
name|setsugid
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
name|p
operator|->
name|p_ucred
operator|=
name|newcred
expr_stmt|;
name|crfree
argument_list|(
name|oldcred
argument_list|)
expr_stmt|;
name|done2
label|:
name|mtx_unlock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|_SYS_SYSPROTO_H_
end_ifndef

begin_struct
struct|struct
name|setregid_args
block|{
name|gid_t
name|rgid
decl_stmt|;
name|gid_t
name|egid
decl_stmt|;
block|}
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * MPSAFE  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|setregid
parameter_list|(
name|td
parameter_list|,
name|uap
parameter_list|)
specifier|register
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|setregid_args
modifier|*
name|uap
decl_stmt|;
block|{
name|struct
name|proc
modifier|*
name|p
init|=
name|td
operator|->
name|td_proc
decl_stmt|;
name|struct
name|ucred
modifier|*
name|newcred
decl_stmt|,
modifier|*
name|oldcred
decl_stmt|;
name|gid_t
name|rgid
decl_stmt|,
name|egid
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|rgid
operator|=
name|uap
operator|->
name|rgid
expr_stmt|;
name|egid
operator|=
name|uap
operator|->
name|egid
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
name|oldcred
operator|=
name|p
operator|->
name|p_ucred
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|rgid
operator|!=
operator|(
name|gid_t
operator|)
operator|-
literal|1
operator|&&
name|rgid
operator|!=
name|oldcred
operator|->
name|cr_rgid
operator|&&
name|rgid
operator|!=
name|oldcred
operator|->
name|cr_svgid
operator|)
operator|||
operator|(
name|egid
operator|!=
operator|(
name|gid_t
operator|)
operator|-
literal|1
operator|&&
name|egid
operator|!=
name|oldcred
operator|->
name|cr_groups
index|[
literal|0
index|]
operator|&&
name|egid
operator|!=
name|oldcred
operator|->
name|cr_rgid
operator|&&
name|egid
operator|!=
name|oldcred
operator|->
name|cr_svgid
operator|)
operator|)
operator|&&
operator|(
name|error
operator|=
name|suser_xxx
argument_list|(
name|oldcred
argument_list|,
name|NULL
argument_list|,
name|PRISON_ROOT
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
goto|goto
name|done2
goto|;
block|}
name|newcred
operator|=
name|crdup
argument_list|(
name|oldcred
argument_list|)
expr_stmt|;
if|if
condition|(
name|egid
operator|!=
operator|(
name|gid_t
operator|)
operator|-
literal|1
operator|&&
name|oldcred
operator|->
name|cr_groups
index|[
literal|0
index|]
operator|!=
name|egid
condition|)
block|{
name|change_egid
argument_list|(
name|newcred
argument_list|,
name|egid
argument_list|)
expr_stmt|;
name|setsugid
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rgid
operator|!=
operator|(
name|gid_t
operator|)
operator|-
literal|1
operator|&&
name|oldcred
operator|->
name|cr_rgid
operator|!=
name|rgid
condition|)
block|{
name|change_rgid
argument_list|(
name|newcred
argument_list|,
name|rgid
argument_list|)
expr_stmt|;
name|setsugid
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|rgid
operator|!=
operator|(
name|gid_t
operator|)
operator|-
literal|1
operator|||
name|newcred
operator|->
name|cr_groups
index|[
literal|0
index|]
operator|!=
name|newcred
operator|->
name|cr_rgid
operator|)
operator|&&
name|newcred
operator|->
name|cr_svgid
operator|!=
name|newcred
operator|->
name|cr_groups
index|[
literal|0
index|]
condition|)
block|{
name|change_svgid
argument_list|(
name|newcred
argument_list|,
name|newcred
operator|->
name|cr_groups
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|setsugid
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
name|p
operator|->
name|p_ucred
operator|=
name|newcred
expr_stmt|;
name|crfree
argument_list|(
name|oldcred
argument_list|)
expr_stmt|;
name|done2
label|:
name|mtx_unlock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * setresuid(ruid, euid, suid) is like setreuid except control over the  * saved uid is explicit.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|_SYS_SYSPROTO_H_
end_ifndef

begin_struct
struct|struct
name|setresuid_args
block|{
name|uid_t
name|ruid
decl_stmt|;
name|uid_t
name|euid
decl_stmt|;
name|uid_t
name|suid
decl_stmt|;
block|}
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * MPSAFE  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|setresuid
parameter_list|(
name|td
parameter_list|,
name|uap
parameter_list|)
specifier|register
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|setresuid_args
modifier|*
name|uap
decl_stmt|;
block|{
name|struct
name|proc
modifier|*
name|p
init|=
name|td
operator|->
name|td_proc
decl_stmt|;
name|struct
name|ucred
modifier|*
name|newcred
decl_stmt|,
modifier|*
name|oldcred
decl_stmt|;
name|uid_t
name|ruid
decl_stmt|,
name|euid
decl_stmt|,
name|suid
decl_stmt|;
name|int
name|error
decl_stmt|;
name|ruid
operator|=
name|uap
operator|->
name|ruid
expr_stmt|;
name|euid
operator|=
name|uap
operator|->
name|euid
expr_stmt|;
name|suid
operator|=
name|uap
operator|->
name|suid
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
name|oldcred
operator|=
name|p
operator|->
name|p_ucred
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|ruid
operator|!=
operator|(
name|uid_t
operator|)
operator|-
literal|1
operator|&&
name|ruid
operator|!=
name|oldcred
operator|->
name|cr_ruid
operator|&&
name|ruid
operator|!=
name|oldcred
operator|->
name|cr_svuid
operator|&&
name|ruid
operator|!=
name|oldcred
operator|->
name|cr_uid
operator|)
operator|||
operator|(
name|euid
operator|!=
operator|(
name|uid_t
operator|)
operator|-
literal|1
operator|&&
name|euid
operator|!=
name|oldcred
operator|->
name|cr_ruid
operator|&&
name|euid
operator|!=
name|oldcred
operator|->
name|cr_svuid
operator|&&
name|euid
operator|!=
name|oldcred
operator|->
name|cr_uid
operator|)
operator|||
operator|(
name|suid
operator|!=
operator|(
name|uid_t
operator|)
operator|-
literal|1
operator|&&
name|suid
operator|!=
name|oldcred
operator|->
name|cr_ruid
operator|&&
name|suid
operator|!=
name|oldcred
operator|->
name|cr_svuid
operator|&&
name|suid
operator|!=
name|oldcred
operator|->
name|cr_uid
operator|)
operator|)
operator|&&
operator|(
name|error
operator|=
name|suser_xxx
argument_list|(
name|oldcred
argument_list|,
name|NULL
argument_list|,
name|PRISON_ROOT
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
goto|goto
name|done2
goto|;
block|}
name|newcred
operator|=
name|crdup
argument_list|(
name|oldcred
argument_list|)
expr_stmt|;
if|if
condition|(
name|euid
operator|!=
operator|(
name|uid_t
operator|)
operator|-
literal|1
operator|&&
name|oldcred
operator|->
name|cr_uid
operator|!=
name|euid
condition|)
block|{
name|change_euid
argument_list|(
name|newcred
argument_list|,
name|euid
argument_list|)
expr_stmt|;
name|setsugid
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ruid
operator|!=
operator|(
name|uid_t
operator|)
operator|-
literal|1
operator|&&
name|oldcred
operator|->
name|cr_ruid
operator|!=
name|ruid
condition|)
block|{
name|change_ruid
argument_list|(
name|newcred
argument_list|,
name|ruid
argument_list|)
expr_stmt|;
name|setsugid
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|suid
operator|!=
operator|(
name|uid_t
operator|)
operator|-
literal|1
operator|&&
name|oldcred
operator|->
name|cr_svuid
operator|!=
name|suid
condition|)
block|{
name|change_svuid
argument_list|(
name|newcred
argument_list|,
name|suid
argument_list|)
expr_stmt|;
name|setsugid
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
name|p
operator|->
name|p_ucred
operator|=
name|newcred
expr_stmt|;
name|crfree
argument_list|(
name|oldcred
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|done2
label|:
name|mtx_unlock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * setresgid(rgid, egid, sgid) is like setregid except control over the  * saved gid is explicit.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|_SYS_SYSPROTO_H_
end_ifndef

begin_struct
struct|struct
name|setresgid_args
block|{
name|gid_t
name|rgid
decl_stmt|;
name|gid_t
name|egid
decl_stmt|;
name|gid_t
name|sgid
decl_stmt|;
block|}
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*   * MPSAFE  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|setresgid
parameter_list|(
name|td
parameter_list|,
name|uap
parameter_list|)
specifier|register
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|setresgid_args
modifier|*
name|uap
decl_stmt|;
block|{
name|struct
name|proc
modifier|*
name|p
init|=
name|td
operator|->
name|td_proc
decl_stmt|;
name|struct
name|ucred
modifier|*
name|newcred
decl_stmt|,
modifier|*
name|oldcred
decl_stmt|;
name|gid_t
name|rgid
decl_stmt|,
name|egid
decl_stmt|,
name|sgid
decl_stmt|;
name|int
name|error
decl_stmt|;
name|rgid
operator|=
name|uap
operator|->
name|rgid
expr_stmt|;
name|egid
operator|=
name|uap
operator|->
name|egid
expr_stmt|;
name|sgid
operator|=
name|uap
operator|->
name|sgid
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
name|oldcred
operator|=
name|p
operator|->
name|p_ucred
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|rgid
operator|!=
operator|(
name|gid_t
operator|)
operator|-
literal|1
operator|&&
name|rgid
operator|!=
name|oldcred
operator|->
name|cr_rgid
operator|&&
name|rgid
operator|!=
name|oldcred
operator|->
name|cr_svgid
operator|&&
name|rgid
operator|!=
name|oldcred
operator|->
name|cr_groups
index|[
literal|0
index|]
operator|)
operator|||
operator|(
name|egid
operator|!=
operator|(
name|gid_t
operator|)
operator|-
literal|1
operator|&&
name|egid
operator|!=
name|oldcred
operator|->
name|cr_rgid
operator|&&
name|egid
operator|!=
name|oldcred
operator|->
name|cr_svgid
operator|&&
name|egid
operator|!=
name|oldcred
operator|->
name|cr_groups
index|[
literal|0
index|]
operator|)
operator|||
operator|(
name|sgid
operator|!=
operator|(
name|gid_t
operator|)
operator|-
literal|1
operator|&&
name|sgid
operator|!=
name|oldcred
operator|->
name|cr_rgid
operator|&&
name|sgid
operator|!=
name|oldcred
operator|->
name|cr_svgid
operator|&&
name|sgid
operator|!=
name|oldcred
operator|->
name|cr_groups
index|[
literal|0
index|]
operator|)
operator|)
operator|&&
operator|(
name|error
operator|=
name|suser_xxx
argument_list|(
name|oldcred
argument_list|,
name|NULL
argument_list|,
name|PRISON_ROOT
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
goto|goto
name|done2
goto|;
block|}
name|newcred
operator|=
name|crdup
argument_list|(
name|oldcred
argument_list|)
expr_stmt|;
if|if
condition|(
name|egid
operator|!=
operator|(
name|gid_t
operator|)
operator|-
literal|1
operator|&&
name|oldcred
operator|->
name|cr_groups
index|[
literal|0
index|]
operator|!=
name|egid
condition|)
block|{
name|change_egid
argument_list|(
name|newcred
argument_list|,
name|egid
argument_list|)
expr_stmt|;
name|setsugid
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rgid
operator|!=
operator|(
name|gid_t
operator|)
operator|-
literal|1
operator|&&
name|oldcred
operator|->
name|cr_rgid
operator|!=
name|rgid
condition|)
block|{
name|change_rgid
argument_list|(
name|newcred
argument_list|,
name|rgid
argument_list|)
expr_stmt|;
name|setsugid
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sgid
operator|!=
operator|(
name|gid_t
operator|)
operator|-
literal|1
operator|&&
name|oldcred
operator|->
name|cr_svgid
operator|!=
name|sgid
condition|)
block|{
name|change_svgid
argument_list|(
name|newcred
argument_list|,
name|sgid
argument_list|)
expr_stmt|;
name|setsugid
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
name|p
operator|->
name|p_ucred
operator|=
name|newcred
expr_stmt|;
name|crfree
argument_list|(
name|oldcred
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|done2
label|:
name|mtx_unlock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|_SYS_SYSPROTO_H_
end_ifndef

begin_struct
struct|struct
name|getresuid_args
block|{
name|uid_t
modifier|*
name|ruid
decl_stmt|;
name|uid_t
modifier|*
name|euid
decl_stmt|;
name|uid_t
modifier|*
name|suid
decl_stmt|;
block|}
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * MPSAFE  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|getresuid
parameter_list|(
name|td
parameter_list|,
name|uap
parameter_list|)
specifier|register
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|getresuid_args
modifier|*
name|uap
decl_stmt|;
block|{
name|struct
name|ucred
modifier|*
name|cred
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
init|=
name|td
operator|->
name|td_proc
decl_stmt|;
name|int
name|error1
init|=
literal|0
decl_stmt|,
name|error2
init|=
literal|0
decl_stmt|,
name|error3
init|=
literal|0
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
name|cred
operator|=
name|p
operator|->
name|p_ucred
expr_stmt|;
if|if
condition|(
name|uap
operator|->
name|ruid
condition|)
name|error1
operator|=
name|copyout
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|cred
operator|->
name|cr_ruid
argument_list|,
operator|(
name|caddr_t
operator|)
name|uap
operator|->
name|ruid
argument_list|,
sizeof|sizeof
argument_list|(
name|cred
operator|->
name|cr_ruid
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|uap
operator|->
name|euid
condition|)
name|error2
operator|=
name|copyout
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|cred
operator|->
name|cr_uid
argument_list|,
operator|(
name|caddr_t
operator|)
name|uap
operator|->
name|euid
argument_list|,
sizeof|sizeof
argument_list|(
name|cred
operator|->
name|cr_uid
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|uap
operator|->
name|suid
condition|)
name|error3
operator|=
name|copyout
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|cred
operator|->
name|cr_svuid
argument_list|,
operator|(
name|caddr_t
operator|)
name|uap
operator|->
name|suid
argument_list|,
sizeof|sizeof
argument_list|(
name|cred
operator|->
name|cr_svuid
argument_list|)
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
return|return
name|error1
condition|?
name|error1
else|:
operator|(
name|error2
condition|?
name|error2
else|:
name|error3
operator|)
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|_SYS_SYSPROTO_H_
end_ifndef

begin_struct
struct|struct
name|getresgid_args
block|{
name|gid_t
modifier|*
name|rgid
decl_stmt|;
name|gid_t
modifier|*
name|egid
decl_stmt|;
name|gid_t
modifier|*
name|sgid
decl_stmt|;
block|}
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * MPSAFE  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|getresgid
parameter_list|(
name|td
parameter_list|,
name|uap
parameter_list|)
specifier|register
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|getresgid_args
modifier|*
name|uap
decl_stmt|;
block|{
name|struct
name|ucred
modifier|*
name|cred
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
init|=
name|td
operator|->
name|td_proc
decl_stmt|;
name|int
name|error1
init|=
literal|0
decl_stmt|,
name|error2
init|=
literal|0
decl_stmt|,
name|error3
init|=
literal|0
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
name|cred
operator|=
name|p
operator|->
name|p_ucred
expr_stmt|;
if|if
condition|(
name|uap
operator|->
name|rgid
condition|)
name|error1
operator|=
name|copyout
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|cred
operator|->
name|cr_rgid
argument_list|,
operator|(
name|caddr_t
operator|)
name|uap
operator|->
name|rgid
argument_list|,
sizeof|sizeof
argument_list|(
name|cred
operator|->
name|cr_rgid
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|uap
operator|->
name|egid
condition|)
name|error2
operator|=
name|copyout
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|cred
operator|->
name|cr_groups
index|[
literal|0
index|]
argument_list|,
operator|(
name|caddr_t
operator|)
name|uap
operator|->
name|egid
argument_list|,
sizeof|sizeof
argument_list|(
name|cred
operator|->
name|cr_groups
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|uap
operator|->
name|sgid
condition|)
name|error3
operator|=
name|copyout
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|cred
operator|->
name|cr_svgid
argument_list|,
operator|(
name|caddr_t
operator|)
name|uap
operator|->
name|sgid
argument_list|,
sizeof|sizeof
argument_list|(
name|cred
operator|->
name|cr_svgid
argument_list|)
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
return|return
name|error1
condition|?
name|error1
else|:
operator|(
name|error2
condition|?
name|error2
else|:
name|error3
operator|)
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|_SYS_SYSPROTO_H_
end_ifndef

begin_struct
struct|struct
name|issetugid_args
block|{
name|int
name|dummy
decl_stmt|;
block|}
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|issetugid
parameter_list|(
name|td
parameter_list|,
name|uap
parameter_list|)
specifier|register
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|issetugid_args
modifier|*
name|uap
decl_stmt|;
block|{
name|struct
name|proc
modifier|*
name|p
init|=
name|td
operator|->
name|td_proc
decl_stmt|;
comment|/* 	 * Note: OpenBSD sets a P_SUGIDEXEC flag set at execve() time, 	 * we use P_SUGID because we consider changing the owners as 	 * "tainting" as well. 	 * This is significant for procs that start as root and "become" 	 * a user without an exec - programs cannot know *everything* 	 * that libc *might* have put in their data segment. 	 */
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|=
operator|(
name|p
operator|->
name|p_flag
operator|&
name|P_SUGID
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * MPSAFE  */
end_comment

begin_function
name|int
name|__setugid
parameter_list|(
name|td
parameter_list|,
name|uap
parameter_list|)
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|__setugid_args
modifier|*
name|uap
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|REGRESSION
name|int
name|error
init|=
literal|0
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|uap
operator|->
name|flag
condition|)
block|{
case|case
literal|0
case|:
name|td
operator|->
name|td_proc
operator|->
name|p_flag
operator|&=
operator|~
name|P_SUGID
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|td
operator|->
name|td_proc
operator|->
name|p_flag
operator||=
name|P_SUGID
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
else|#
directive|else
comment|/* !REGRESSION */
return|return
operator|(
name|ENOSYS
operator|)
return|;
endif|#
directive|endif
comment|/* !REGRESSION */
block|}
end_function

begin_comment
comment|/*  * Check if gid is a member of the group set.  */
end_comment

begin_function
name|int
name|groupmember
parameter_list|(
name|gid
parameter_list|,
name|cred
parameter_list|)
name|gid_t
name|gid
decl_stmt|;
name|struct
name|ucred
modifier|*
name|cred
decl_stmt|;
block|{
specifier|register
name|gid_t
modifier|*
name|gp
decl_stmt|;
name|gid_t
modifier|*
name|egp
decl_stmt|;
name|egp
operator|=
operator|&
operator|(
name|cred
operator|->
name|cr_groups
index|[
name|cred
operator|->
name|cr_ngroups
index|]
operator|)
expr_stmt|;
for|for
control|(
name|gp
operator|=
name|cred
operator|->
name|cr_groups
init|;
name|gp
operator|<
name|egp
condition|;
name|gp
operator|++
control|)
if|if
condition|(
operator|*
name|gp
operator|==
name|gid
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * `suser_enabled' (which can be set by the kern.security.suser_enabled  * sysctl) determines whether the system 'super-user' policy is in effect.  * If it is nonzero, an effective uid of 0 connotes special privilege,  * overriding many mandatory and discretionary protections.  If it is zero,  * uid 0 is offered no special privilege in the kernel security policy.  * Setting it to zero may seriously impact the functionality of many  * existing userland programs, and should not be done without careful  * consideration of the consequences.  */
end_comment

begin_decl_stmt
name|int
name|suser_enabled
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_kern_security_bsd
argument_list|,
name|OID_AUTO
argument_list|,
name|suser_enabled
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|suser_enabled
argument_list|,
literal|0
argument_list|,
literal|"processes with uid 0 have privilege"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Test whether the specified credentials imply "super-user" privilege.  * Return 0 or EPERM.  */
end_comment

begin_function
name|int
name|suser
parameter_list|(
name|p
parameter_list|)
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
block|{
return|return
name|suser_xxx
argument_list|(
literal|0
argument_list|,
name|p
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * version for when the thread pointer is available and not the proc.  * (saves having to include proc.h into every file that needs to do the change.)  */
end_comment

begin_function
name|int
name|suser_td
parameter_list|(
name|td
parameter_list|)
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
block|{
return|return
name|suser_xxx
argument_list|(
literal|0
argument_list|,
name|td
operator|->
name|td_proc
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * wrapper to use if you have the thread on hand but not the proc.  */
end_comment

begin_function
name|int
name|suser_xxx_td
parameter_list|(
name|cred
parameter_list|,
name|td
parameter_list|,
name|flag
parameter_list|)
name|struct
name|ucred
modifier|*
name|cred
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|int
name|flag
decl_stmt|;
block|{
return|return
operator|(
name|suser_xxx
argument_list|(
name|cred
argument_list|,
name|td
operator|->
name|td_proc
argument_list|,
name|flag
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|suser_xxx
parameter_list|(
name|cred
parameter_list|,
name|proc
parameter_list|,
name|flag
parameter_list|)
name|struct
name|ucred
modifier|*
name|cred
decl_stmt|;
name|struct
name|proc
modifier|*
name|proc
decl_stmt|;
name|int
name|flag
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|suser_enabled
condition|)
return|return
operator|(
name|EPERM
operator|)
return|;
if|if
condition|(
operator|!
name|cred
operator|&&
operator|!
name|proc
condition|)
block|{
name|printf
argument_list|(
literal|"suser_xxx(): THINK!\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EPERM
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|cred
condition|)
name|cred
operator|=
name|proc
operator|->
name|p_ucred
expr_stmt|;
if|if
condition|(
name|cred
operator|->
name|cr_uid
operator|!=
literal|0
condition|)
return|return
operator|(
name|EPERM
operator|)
return|;
if|if
condition|(
name|jailed
argument_list|(
name|cred
argument_list|)
operator|&&
operator|!
operator|(
name|flag
operator|&
name|PRISON_ROOT
operator|)
condition|)
return|return
operator|(
name|EPERM
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Test (local, globale) securelevel values against passed required  * securelevel.  _gt implements (level> securelevel), and _ge implements  * (level>= securelevel).  Returns 0 oer EPERM.  *  * cr is permitted to be NULL for the time being, as there were some  * existing securelevel checks that occurred without a process/credential  * context.  In the future this will be disallowed, so a kernel  * message is displayed.  */
end_comment

begin_function
name|int
name|securelevel_gt
parameter_list|(
name|struct
name|ucred
modifier|*
name|cr
parameter_list|,
name|int
name|level
parameter_list|)
block|{
if|if
condition|(
name|cr
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"securelevel_gt: cr is NULL\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|level
operator|>
name|securelevel
condition|)
return|return
operator|(
literal|0
operator|)
return|;
else|else
return|return
operator|(
name|EPERM
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|cr
operator|->
name|cr_prison
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|level
operator|>
name|securelevel
condition|)
return|return
operator|(
literal|0
operator|)
return|;
else|else
return|return
operator|(
name|EPERM
operator|)
return|;
block|}
else|else
block|{
if|if
condition|(
name|level
operator|>
name|imax
argument_list|(
name|cr
operator|->
name|cr_prison
operator|->
name|pr_securelevel
argument_list|,
name|securelevel
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
else|else
return|return
operator|(
name|EPERM
operator|)
return|;
block|}
block|}
end_function

begin_function
name|int
name|securelevel_ge
parameter_list|(
name|struct
name|ucred
modifier|*
name|cr
parameter_list|,
name|int
name|level
parameter_list|)
block|{
if|if
condition|(
name|cr
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"securelevel_ge: cr is NULL\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|level
operator|>=
name|securelevel
condition|)
return|return
operator|(
literal|0
operator|)
return|;
else|else
return|return
operator|(
name|EPERM
operator|)
return|;
block|}
if|if
condition|(
name|cr
operator|->
name|cr_prison
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|level
operator|>=
name|securelevel
condition|)
return|return
operator|(
literal|0
operator|)
return|;
else|else
return|return
operator|(
name|EPERM
operator|)
return|;
block|}
else|else
block|{
if|if
condition|(
name|level
operator|>=
name|imax
argument_list|(
name|cr
operator|->
name|cr_prison
operator|->
name|pr_securelevel
argument_list|,
name|securelevel
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
else|else
return|return
operator|(
name|EPERM
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * 'seeotheruids_permitted' determines whether or not visibility of processes  * and sockets with credentials holding different real uid's is possible  * using a variety of system MIBs.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|seeotheruids_permitted
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_kern_security_bsd
argument_list|,
name|OID_AUTO
argument_list|,
name|seeotheruids_permitted
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|seeotheruids_permitted
argument_list|,
literal|0
argument_list|,
literal|"Unprivileged processes may see subjects/objects with different real uid"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*-  * Determine if u1 "can see" the subject specified by u2.  * Returns: 0 for permitted, an errno value otherwise  * Locks: none  * References: u1 and u2 must be immutable credentials  *             u1 and u2 must be valid for the lifetime of the call  *             u1 may equal u2, in which case only one reference is required  */
end_comment

begin_function
name|int
name|cr_cansee
parameter_list|(
name|struct
name|ucred
modifier|*
name|u1
parameter_list|,
name|struct
name|ucred
modifier|*
name|u2
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|prison_check
argument_list|(
name|u1
argument_list|,
name|u2
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
operator|!
name|seeotheruids_permitted
operator|&&
name|u1
operator|->
name|cr_ruid
operator|!=
name|u2
operator|->
name|cr_ruid
condition|)
block|{
if|if
condition|(
name|suser_xxx
argument_list|(
name|u1
argument_list|,
name|NULL
argument_list|,
name|PRISON_ROOT
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|ESRCH
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*-  * Determine if p1 "can see" the subject specified by p2.  * Returns: 0 for permitted, an errno value otherwise  * Locks: Sufficient locks to protect p1->p_ucred and p2->p_ucred must  *        be held.  Normally, p1 will be curproc, and a lock must be held  *        for p2.  * References: p1 and p2 must be valid for the lifetime of the call  */
end_comment

begin_function
name|int
name|p_cansee
parameter_list|(
name|struct
name|proc
modifier|*
name|p1
parameter_list|,
name|struct
name|proc
modifier|*
name|p2
parameter_list|)
block|{
comment|/* Wrap cr_cansee() for all functionality. */
return|return
operator|(
name|cr_cansee
argument_list|(
name|p1
operator|->
name|p_ucred
argument_list|,
name|p2
operator|->
name|p_ucred
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*-  * Determine whether p1 may deliver the specified signal to p2.  * Returns: 0 for permitted, an errno value otherwise  * Locks: Sufficient locks to protect various components of p1 and p2  *        must be held.  Normally, p1 will be curproc, and a lock must  *        be held for p2.  * References: p1 and p2 must be valid for the lifetime of the call  */
end_comment

begin_function
name|int
name|p_cansignal
parameter_list|(
name|struct
name|proc
modifier|*
name|p1
parameter_list|,
name|struct
name|proc
modifier|*
name|p2
parameter_list|,
name|int
name|signum
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
if|if
condition|(
name|p1
operator|==
name|p2
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * Jail semantics limit the scope of signalling to p2 in the same 	 * jail as p1, if p1 is in jail. 	 */
if|if
condition|(
operator|(
name|error
operator|=
name|prison_check
argument_list|(
name|p1
operator|->
name|p_ucred
argument_list|,
name|p2
operator|->
name|p_ucred
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* 	 * UNIX signalling semantics require that processes in the same 	 * session always be able to deliver SIGCONT to one another, 	 * overriding the remaining protections. 	 */
if|if
condition|(
name|signum
operator|==
name|SIGCONT
operator|&&
name|p1
operator|->
name|p_session
operator|==
name|p2
operator|->
name|p_session
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * UNIX signal semantics depend on the status of the P_SUGID 	 * bit on the target process.  If the bit is set, then additional 	 * restrictions are placed on the set of available signals. 	 */
if|if
condition|(
name|p2
operator|->
name|p_flag
operator|&
name|P_SUGID
condition|)
block|{
switch|switch
condition|(
name|signum
condition|)
block|{
case|case
literal|0
case|:
case|case
name|SIGKILL
case|:
case|case
name|SIGINT
case|:
case|case
name|SIGTERM
case|:
case|case
name|SIGSTOP
case|:
case|case
name|SIGTTIN
case|:
case|case
name|SIGTTOU
case|:
case|case
name|SIGTSTP
case|:
case|case
name|SIGHUP
case|:
case|case
name|SIGUSR1
case|:
case|case
name|SIGUSR2
case|:
comment|/* 			 * Generally, permit job and terminal control 			 * signals. 			 */
break|break;
default|default:
comment|/* Not permitted, privilege is required. */
name|error
operator|=
name|suser_xxx
argument_list|(
name|NULL
argument_list|,
name|p1
argument_list|,
name|PRISON_ROOT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
comment|/* 	 * Generally, the target credential's ruid or svuid must match the 	 * subject credential's ruid or euid. 	 */
if|if
condition|(
name|p1
operator|->
name|p_ucred
operator|->
name|cr_ruid
operator|!=
name|p2
operator|->
name|p_ucred
operator|->
name|cr_ruid
operator|&&
name|p1
operator|->
name|p_ucred
operator|->
name|cr_ruid
operator|!=
name|p2
operator|->
name|p_ucred
operator|->
name|cr_svuid
operator|&&
name|p1
operator|->
name|p_ucred
operator|->
name|cr_uid
operator|!=
name|p2
operator|->
name|p_ucred
operator|->
name|cr_ruid
operator|&&
name|p1
operator|->
name|p_ucred
operator|->
name|cr_uid
operator|!=
name|p2
operator|->
name|p_ucred
operator|->
name|cr_svuid
condition|)
block|{
comment|/* Not permitted, try privilege. */
name|error
operator|=
name|suser_xxx
argument_list|(
name|NULL
argument_list|,
name|p1
argument_list|,
name|PRISON_ROOT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*-  * Determine whether p1 may reschedule p2  * Returns: 0 for permitted, an errno value otherwise  * Locks: Sufficient locks to protect various components of p1 and p2  *        must be held.  Normally, p1 will be curproc, and a lock must  *        be held for p2.  * References: p1 and p2 must be valid for the lifetime of the call  */
end_comment

begin_function
name|int
name|p_cansched
parameter_list|(
name|struct
name|proc
modifier|*
name|p1
parameter_list|,
name|struct
name|proc
modifier|*
name|p2
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
if|if
condition|(
name|p1
operator|==
name|p2
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|(
name|error
operator|=
name|prison_check
argument_list|(
name|p1
operator|->
name|p_ucred
argument_list|,
name|p2
operator|->
name|p_ucred
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|p1
operator|->
name|p_ucred
operator|->
name|cr_ruid
operator|==
name|p2
operator|->
name|p_ucred
operator|->
name|cr_ruid
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|p1
operator|->
name|p_ucred
operator|->
name|cr_uid
operator|==
name|p2
operator|->
name|p_ucred
operator|->
name|cr_ruid
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|suser_xxx
argument_list|(
literal|0
argument_list|,
name|p1
argument_list|,
name|PRISON_ROOT
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
ifdef|#
directive|ifdef
name|CAPABILITIES
if|if
condition|(
operator|!
name|cap_check
argument_list|(
name|NULL
argument_list|,
name|p1
argument_list|,
name|CAP_SYS_NICE
argument_list|,
name|PRISON_ROOT
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
endif|#
directive|endif
return|return
operator|(
name|EPERM
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * The 'unprivileged_procdebug_permitted' flag may be used to disable  * a variety of unprivileged inter-process debugging services, including  * some procfs functionality, ptrace(), and ktrace().  In the past,  * inter-process debugging has been involved in a variety of security  * problems, and sites not requiring the service might choose to disable it  * when hardening systems.  *  * XXX: Should modifying and reading this variable require locking?  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|unprivileged_procdebug_permitted
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_kern_security_bsd
argument_list|,
name|OID_AUTO
argument_list|,
name|unprivileged_procdebug_permitted
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|unprivileged_procdebug_permitted
argument_list|,
literal|0
argument_list|,
literal|"Unprivileged processes may use process debugging facilities"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*-  * Determine whether p1 may debug p2.  * Returns: 0 for permitted, an errno value otherwise  * Locks: Sufficient locks to protect various components of p1 and p2  *        must be held.  Normally, p1 will be curproc, and a lock must  *        be held for p2.  * References: p1 and p2 must be valid for the lifetime of the call  */
end_comment

begin_function
name|int
name|p_candebug
parameter_list|(
name|struct
name|proc
modifier|*
name|p1
parameter_list|,
name|struct
name|proc
modifier|*
name|p2
parameter_list|)
block|{
name|int
name|error
decl_stmt|,
name|i
decl_stmt|,
name|grpsubset
decl_stmt|,
name|uidsubset
decl_stmt|,
name|credentialchanged
decl_stmt|;
if|if
condition|(
operator|!
name|unprivileged_procdebug_permitted
condition|)
block|{
name|error
operator|=
name|suser_xxx
argument_list|(
name|NULL
argument_list|,
name|p1
argument_list|,
name|PRISON_ROOT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
name|p1
operator|==
name|p2
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|(
name|error
operator|=
name|prison_check
argument_list|(
name|p1
operator|->
name|p_ucred
argument_list|,
name|p2
operator|->
name|p_ucred
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* 	 * Is p2's group set a subset of p1's effective group set?  This 	 * includes p2's egid, group access list, rgid, and svgid. 	 */
name|grpsubset
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|p2
operator|->
name|p_ucred
operator|->
name|cr_ngroups
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|groupmember
argument_list|(
name|p2
operator|->
name|p_ucred
operator|->
name|cr_groups
index|[
name|i
index|]
argument_list|,
name|p1
operator|->
name|p_ucred
argument_list|)
condition|)
block|{
name|grpsubset
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
name|grpsubset
operator|=
name|grpsubset
operator|&&
name|groupmember
argument_list|(
name|p2
operator|->
name|p_ucred
operator|->
name|cr_rgid
argument_list|,
name|p1
operator|->
name|p_ucred
argument_list|)
operator|&&
name|groupmember
argument_list|(
name|p2
operator|->
name|p_ucred
operator|->
name|cr_svgid
argument_list|,
name|p1
operator|->
name|p_ucred
argument_list|)
expr_stmt|;
comment|/* 	 * Are the uids present in p2's credential equal to p1's 	 * effective uid?  This includes p2's euid, svuid, and ruid. 	 */
name|uidsubset
operator|=
operator|(
name|p1
operator|->
name|p_ucred
operator|->
name|cr_uid
operator|==
name|p2
operator|->
name|p_ucred
operator|->
name|cr_uid
operator|&&
name|p1
operator|->
name|p_ucred
operator|->
name|cr_uid
operator|==
name|p2
operator|->
name|p_ucred
operator|->
name|cr_svuid
operator|&&
name|p1
operator|->
name|p_ucred
operator|->
name|cr_uid
operator|==
name|p2
operator|->
name|p_ucred
operator|->
name|cr_ruid
operator|)
expr_stmt|;
comment|/* 	 * Has the credential of the process changed since the last exec()? 	 */
name|credentialchanged
operator|=
operator|(
name|p2
operator|->
name|p_flag
operator|&
name|P_SUGID
operator|)
expr_stmt|;
comment|/* 	 * If p2's gids aren't a subset, or the uids aren't a subset, 	 * or the credential has changed, require appropriate privilege 	 * for p1 to debug p2.  For POSIX.1e capabilities, this will 	 * require CAP_SYS_PTRACE. 	 */
if|if
condition|(
operator|!
name|grpsubset
operator|||
operator|!
name|uidsubset
operator|||
name|credentialchanged
condition|)
block|{
name|error
operator|=
name|suser_xxx
argument_list|(
name|NULL
argument_list|,
name|p1
argument_list|,
name|PRISON_ROOT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* can't trace init when securelevel> 0 */
if|if
condition|(
name|p2
operator|->
name|p_pid
operator|==
literal|1
condition|)
block|{
name|error
operator|=
name|securelevel_gt
argument_list|(
name|p1
operator|->
name|p_ucred
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* 	 * Can't trace a process that's currently exec'ing. 	 * XXX: Note, this is not a security policy decision, it's a 	 * basic correctness/functionality decision.  Therefore, this check 	 * should be moved to the caller's of p_candebug(). 	 */
if|if
condition|(
operator|(
name|p2
operator|->
name|p_flag
operator|&
name|P_INEXEC
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|EAGAIN
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Allocate a zeroed cred structure.  */
end_comment

begin_function
name|struct
name|ucred
modifier|*
name|crget
parameter_list|()
block|{
specifier|register
name|struct
name|ucred
modifier|*
name|cr
decl_stmt|;
name|MALLOC
argument_list|(
name|cr
argument_list|,
expr|struct
name|ucred
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|cr
argument_list|)
argument_list|,
name|M_CRED
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|cr
operator|->
name|cr_ref
operator|=
literal|1
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|cr
operator|->
name|cr_mtx
argument_list|,
literal|"ucred"
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
return|return
operator|(
name|cr
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Claim another reference to a ucred structure.  */
end_comment

begin_function
name|struct
name|ucred
modifier|*
name|crhold
parameter_list|(
name|cr
parameter_list|)
name|struct
name|ucred
modifier|*
name|cr
decl_stmt|;
block|{
name|mtx_lock
argument_list|(
operator|&
name|cr
operator|->
name|cr_mtx
argument_list|)
expr_stmt|;
name|cr
operator|->
name|cr_ref
operator|++
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|cr
operator|->
name|cr_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
name|cr
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Free a cred structure.  * Throws away space when ref count gets to 0.  */
end_comment

begin_function
name|void
name|crfree
parameter_list|(
name|cr
parameter_list|)
name|struct
name|ucred
modifier|*
name|cr
decl_stmt|;
block|{
name|mtx_lock
argument_list|(
operator|&
name|cr
operator|->
name|cr_mtx
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|cr
operator|->
name|cr_ref
operator|>
literal|0
argument_list|,
operator|(
literal|"bad ucred refcount: %d"
operator|,
name|cr
operator|->
name|cr_ref
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|--
name|cr
operator|->
name|cr_ref
operator|==
literal|0
condition|)
block|{
name|mtx_destroy
argument_list|(
operator|&
name|cr
operator|->
name|cr_mtx
argument_list|)
expr_stmt|;
comment|/* 		 * Some callers of crget(), such as nfs_statfs(), 		 * allocate a temporary credential, but don't 		 * allocate a uidinfo structure. 		 */
if|if
condition|(
name|cr
operator|->
name|cr_uidinfo
operator|!=
name|NULL
condition|)
name|uifree
argument_list|(
name|cr
operator|->
name|cr_uidinfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|cr
operator|->
name|cr_ruidinfo
operator|!=
name|NULL
condition|)
name|uifree
argument_list|(
name|cr
operator|->
name|cr_ruidinfo
argument_list|)
expr_stmt|;
comment|/* 		 * Free a prison, if any. 		 */
if|if
condition|(
name|jailed
argument_list|(
name|cr
argument_list|)
condition|)
name|prison_free
argument_list|(
name|cr
operator|->
name|cr_prison
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
operator|(
name|caddr_t
operator|)
name|cr
argument_list|,
name|M_CRED
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mtx_unlock
argument_list|(
operator|&
name|cr
operator|->
name|cr_mtx
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Check to see if this ucred is shared.  */
end_comment

begin_function
name|int
name|crshared
parameter_list|(
name|cr
parameter_list|)
name|struct
name|ucred
modifier|*
name|cr
decl_stmt|;
block|{
name|int
name|shared
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|cr
operator|->
name|cr_mtx
argument_list|)
expr_stmt|;
name|shared
operator|=
operator|(
name|cr
operator|->
name|cr_ref
operator|>
literal|1
operator|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|cr
operator|->
name|cr_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
name|shared
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Copy a ucred's contents from a template.  Does not block.  */
end_comment

begin_function
name|void
name|crcopy
parameter_list|(
name|dest
parameter_list|,
name|src
parameter_list|)
name|struct
name|ucred
modifier|*
name|dest
decl_stmt|,
decl|*
name|src
decl_stmt|;
end_function

begin_block
block|{
name|KASSERT
argument_list|(
name|crshared
argument_list|(
name|dest
argument_list|)
operator|==
literal|0
argument_list|,
operator|(
literal|"crcopy of shared ucred"
operator|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|src
operator|->
name|cr_startcopy
argument_list|,
operator|&
name|dest
operator|->
name|cr_startcopy
argument_list|,
call|(
name|unsigned
call|)
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|src
operator|->
name|cr_endcopy
operator|-
operator|(
name|caddr_t
operator|)
operator|&
name|src
operator|->
name|cr_startcopy
argument_list|)
argument_list|)
expr_stmt|;
name|uihold
argument_list|(
name|dest
operator|->
name|cr_uidinfo
argument_list|)
expr_stmt|;
name|uihold
argument_list|(
name|dest
operator|->
name|cr_ruidinfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|jailed
argument_list|(
name|dest
argument_list|)
condition|)
name|prison_hold
argument_list|(
name|dest
operator|->
name|cr_prison
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Dup cred struct to a new held one.  */
end_comment

begin_function
name|struct
name|ucred
modifier|*
name|crdup
parameter_list|(
name|cr
parameter_list|)
name|struct
name|ucred
modifier|*
name|cr
decl_stmt|;
block|{
name|struct
name|ucred
modifier|*
name|newcr
decl_stmt|;
name|newcr
operator|=
name|crget
argument_list|()
expr_stmt|;
name|crcopy
argument_list|(
name|newcr
argument_list|,
name|cr
argument_list|)
expr_stmt|;
return|return
operator|(
name|newcr
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Get login name, if available.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|_SYS_SYSPROTO_H_
end_ifndef

begin_struct
struct|struct
name|getlogin_args
block|{
name|char
modifier|*
name|namebuf
decl_stmt|;
name|u_int
name|namelen
decl_stmt|;
block|}
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * MPSAFE  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|getlogin
parameter_list|(
name|td
parameter_list|,
name|uap
parameter_list|)
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|getlogin_args
modifier|*
name|uap
decl_stmt|;
block|{
name|int
name|error
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
init|=
name|td
operator|->
name|td_proc
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
if|if
condition|(
name|uap
operator|->
name|namelen
operator|>
name|MAXLOGNAME
condition|)
name|uap
operator|->
name|namelen
operator|=
name|MAXLOGNAME
expr_stmt|;
name|error
operator|=
name|copyout
argument_list|(
operator|(
name|caddr_t
operator|)
name|p
operator|->
name|p_pgrp
operator|->
name|pg_session
operator|->
name|s_login
argument_list|,
operator|(
name|caddr_t
operator|)
name|uap
operator|->
name|namebuf
argument_list|,
name|uap
operator|->
name|namelen
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Set login name.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|_SYS_SYSPROTO_H_
end_ifndef

begin_struct
struct|struct
name|setlogin_args
block|{
name|char
modifier|*
name|namebuf
decl_stmt|;
block|}
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * MPSAFE  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|setlogin
parameter_list|(
name|td
parameter_list|,
name|uap
parameter_list|)
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|setlogin_args
modifier|*
name|uap
decl_stmt|;
block|{
name|struct
name|proc
modifier|*
name|p
init|=
name|td
operator|->
name|td_proc
decl_stmt|;
name|int
name|error
decl_stmt|;
name|char
name|logintmp
index|[
name|MAXLOGNAME
index|]
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|suser_xxx
argument_list|(
literal|0
argument_list|,
name|p
argument_list|,
name|PRISON_ROOT
argument_list|)
operator|)
condition|)
goto|goto
name|done2
goto|;
name|error
operator|=
name|copyinstr
argument_list|(
operator|(
name|caddr_t
operator|)
name|uap
operator|->
name|namebuf
argument_list|,
operator|(
name|caddr_t
operator|)
name|logintmp
argument_list|,
sizeof|sizeof
argument_list|(
name|logintmp
argument_list|)
argument_list|,
operator|(
name|size_t
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|ENAMETOOLONG
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|error
condition|)
block|{
operator|(
name|void
operator|)
name|memcpy
argument_list|(
name|p
operator|->
name|p_pgrp
operator|->
name|pg_session
operator|->
name|s_login
argument_list|,
name|logintmp
argument_list|,
sizeof|sizeof
argument_list|(
name|logintmp
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|done2
label|:
name|mtx_unlock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|void
name|setsugid
parameter_list|(
name|p
parameter_list|)
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
block|{
name|p
operator|->
name|p_flag
operator||=
name|P_SUGID
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|p
operator|->
name|p_pfsflags
operator|&
name|PF_ISUGID
operator|)
condition|)
name|p
operator|->
name|p_stops
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*-  * Change a process's effective uid.  * Side effects: newcred->cr_uid and newcred->cr_uidinfo will be modified.  * References: newcred must be an exclusive credential reference for the  *             duration of the call.  */
end_comment

begin_function
name|void
name|change_euid
parameter_list|(
name|newcred
parameter_list|,
name|euid
parameter_list|)
name|struct
name|ucred
modifier|*
name|newcred
decl_stmt|;
name|uid_t
name|euid
decl_stmt|;
block|{
name|newcred
operator|->
name|cr_uid
operator|=
name|euid
expr_stmt|;
name|uifree
argument_list|(
name|newcred
operator|->
name|cr_uidinfo
argument_list|)
expr_stmt|;
name|newcred
operator|->
name|cr_uidinfo
operator|=
name|uifind
argument_list|(
name|euid
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*-  * Change a process's effective gid.  * Side effects: newcred->cr_gid will be modified.  * References: newcred must be an exclusive credential reference for the  *             duration of the call.  */
end_comment

begin_function
name|void
name|change_egid
parameter_list|(
name|newcred
parameter_list|,
name|egid
parameter_list|)
name|struct
name|ucred
modifier|*
name|newcred
decl_stmt|;
name|gid_t
name|egid
decl_stmt|;
block|{
name|newcred
operator|->
name|cr_groups
index|[
literal|0
index|]
operator|=
name|egid
expr_stmt|;
block|}
end_function

begin_comment
comment|/*-  * Change a process's real uid.  * Side effects: newcred->cr_ruid will be updated, newcred->cr_ruidinfo  *               will be updated, and the old and new cr_ruidinfo proc  *               counts will be updated.  * References: newcred must be an exclusive credential reference for the  *             duration of the call.  */
end_comment

begin_function
name|void
name|change_ruid
parameter_list|(
name|newcred
parameter_list|,
name|ruid
parameter_list|)
name|struct
name|ucred
modifier|*
name|newcred
decl_stmt|;
name|uid_t
name|ruid
decl_stmt|;
block|{
operator|(
name|void
operator|)
name|chgproccnt
argument_list|(
name|newcred
operator|->
name|cr_ruidinfo
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|newcred
operator|->
name|cr_ruid
operator|=
name|ruid
expr_stmt|;
name|uifree
argument_list|(
name|newcred
operator|->
name|cr_ruidinfo
argument_list|)
expr_stmt|;
name|newcred
operator|->
name|cr_ruidinfo
operator|=
name|uifind
argument_list|(
name|ruid
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|chgproccnt
argument_list|(
name|newcred
operator|->
name|cr_ruidinfo
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*-  * Change a process's real gid.  * Side effects: newcred->cr_rgid will be updated.  * References: newcred must be an exclusive credential reference for the  *             duration of the call.  */
end_comment

begin_function
name|void
name|change_rgid
parameter_list|(
name|newcred
parameter_list|,
name|rgid
parameter_list|)
name|struct
name|ucred
modifier|*
name|newcred
decl_stmt|;
name|gid_t
name|rgid
decl_stmt|;
block|{
name|newcred
operator|->
name|cr_rgid
operator|=
name|rgid
expr_stmt|;
block|}
end_function

begin_comment
comment|/*-  * Change a process's saved uid.  * Side effects: newcred->cr_svuid will be updated.  * References: newcred must be an exclusive credential reference for the  *             duration of the call.  */
end_comment

begin_function
name|void
name|change_svuid
parameter_list|(
name|newcred
parameter_list|,
name|svuid
parameter_list|)
name|struct
name|ucred
modifier|*
name|newcred
decl_stmt|;
name|uid_t
name|svuid
decl_stmt|;
block|{
name|newcred
operator|->
name|cr_svuid
operator|=
name|svuid
expr_stmt|;
block|}
end_function

begin_comment
comment|/*-  * Change a process's saved gid.  * Side effects: newcred->cr_svgid will be updated.  * References: newcred must be an exclusive credential reference for the  *             duration of the call.  */
end_comment

begin_function
name|void
name|change_svgid
parameter_list|(
name|newcred
parameter_list|,
name|svgid
parameter_list|)
name|struct
name|ucred
modifier|*
name|newcred
decl_stmt|;
name|gid_t
name|svgid
decl_stmt|;
block|{
name|newcred
operator|->
name|cr_svgid
operator|=
name|svgid
expr_stmt|;
block|}
end_function

end_unit

