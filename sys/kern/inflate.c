begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Most parts of this file are not covered by:  * ----------------------------------------------------------------------------  * "THE BEER-WARE LICENSE" (Revision 42):  *<phk@login.dknet.dk> wrote this file.  As long as you retain this notice you  * can do whatever you want with this stuff. If we meet some day, and you think  * this stuff is worth it, you can buy me a beer in return.   Poul-Henning Kamp  * ----------------------------------------------------------------------------  *  * $FreeBSD$  *  *  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/inflate.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|KERNEL
end_ifdef

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/mman.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|KERNEL
end_ifdef

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_kern.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* needed to make inflate() work */
end_comment

begin_define
define|#
directive|define
name|uch
value|u_char
end_define

begin_define
define|#
directive|define
name|ush
value|u_short
end_define

begin_define
define|#
directive|define
name|ulg
value|u_long
end_define

begin_comment
comment|/* Stuff to make inflate() work */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|KERNEL
end_ifdef

begin_define
define|#
directive|define
name|memzero
parameter_list|(
name|dest
parameter_list|,
name|len
parameter_list|)
value|bzero(dest,len)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|NOMEMCPY
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|KERNEL
end_ifdef

begin_define
define|#
directive|define
name|FPRINTF
value|printf
end_define

begin_else
else|#
directive|else
end_else

begin_function_decl
specifier|extern
name|void
name|putstr
parameter_list|(
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|FPRINTF
value|putstr
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|FLUSH
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|{						\ 	int foo = (*x->gz_output)(x->gz_private,x->gz_slide,y);	\ 	if (foo) 						\ 		return foo;					\ 	}
end_define

begin_decl_stmt
specifier|static
specifier|const
name|int
name|qflag
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|KERNEL
end_ifndef

begin_comment
comment|/* want to use this file in kzip also */
end_comment

begin_function_decl
specifier|extern
name|unsigned
name|char
modifier|*
name|malloc
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|free
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * This came from unzip-5.12.  I have changed it the flow to pass  * a structure pointer around, thus hopefully making it re-entrant.  * Poul-Henning  */
end_comment

begin_comment
comment|/* inflate.c -- put in the public domain by Mark Adler    version c14o, 23 August 1994 */
end_comment

begin_comment
comment|/* You can do whatever you like with this source file, though I would    prefer that if you modify it and redistribute it that you include    comments to that effect with your name and the date.  Thank you.     History:    vers    date          who           what    ----  ---------  --------------  ------------------------------------     a    ~~ Feb 92  M. Adler        used full (large, one-step) lookup table     b1   21 Mar 92  M. Adler        first version with partial lookup tables     b2   21 Mar 92  M. Adler        fixed bug in fixed-code blocks     b3   22 Mar 92  M. Adler        sped up match copies, cleaned up some     b4   25 Mar 92  M. Adler        added prototypes; removed window[] (now                                     is the responsibility of unzip.h--also                                     changed name to slide[]), so needs diffs                                     for unzip.c and unzip.h (this allows                                     compiling in the small model on MSDOS);                                     fixed cast of q in huft_build();     b5   26 Mar 92  M. Adler        got rid of unintended macro recursion.     b6   27 Mar 92  M. Adler        got rid of nextbyte() routine.  fixed                                     bug in inflate_fixed().     c1   30 Mar 92  M. Adler        removed lbits, dbits environment variables.                                     changed BMAX to 16 for explode.  Removed                                     OUTB usage, and replaced it with flush()--                                     this was a 20% speed improvement!  Added                                     an explode.c (to replace unimplod.c) that                                     uses the huft routines here.  Removed                                     register union.     c2    4 Apr 92  M. Adler        fixed bug for file sizes a multiple of 32k.     c3   10 Apr 92  M. Adler        reduced memory of code tables made by                                     huft_build significantly (factor of two to                                     three).     c4   15 Apr 92  M. Adler        added NOMEMCPY do kill use of memcpy().                                     worked around a Turbo C optimization bug.     c5   21 Apr 92  M. Adler        added the GZ_WSIZE #define to allow reducing                                     the 32K window size for specialized                                     applications.     c6   31 May 92  M. Adler        added some typecasts to eliminate warnings     c7   27 Jun 92  G. Roelofs      added some more typecasts (444:  MSC bug).     c8    5 Oct 92  J-l. Gailly     added ifdef'd code to deal with PKZIP bug.     c9    9 Oct 92  M. Adler        removed a memory error message (~line 416).     c10  17 Oct 92  G. Roelofs      changed ULONG/UWORD/byte to ulg/ush/uch,                                     removed old inflate, renamed inflate_entry                                     to inflate, added Mark's fix to a comment.    c10.5 14 Dec 92  M. Adler        fix up error messages for incomplete trees.     c11   2 Jan 93  M. Adler        fixed bug in detection of incomplete                                     tables, and removed assumption that EOB is                                     the longest code (bad assumption).     c12   3 Jan 93  M. Adler        make tables for fixed blocks only once.     c13   5 Jan 93  M. Adler        allow all zero length codes (pkzip 2.04c                                     outputs one zero length code for an empty                                     distance tree).     c14  12 Mar 93  M. Adler        made inflate.c standalone with the                                     introduction of inflate.h.    c14b  16 Jul 93  G. Roelofs      added (unsigned) typecast to w at 470.    c14c  19 Jul 93  J. Bush         changed v[N_MAX], l[288], ll[28x+3x] arrays                                     to static for Amiga.    c14d  13 Aug 93  J-l. Gailly     de-complicatified Mark's c[*p++]++ thing.    c14e   8 Oct 93  G. Roelofs      changed memset() to memzero().    c14f  22 Oct 93  G. Roelofs      renamed quietflg to qflag; made Trace()                                     conditional; added inflate_free().    c14g  28 Oct 93  G. Roelofs      changed l/(lx+1) macro to pointer (Cray bug)    c14h   7 Dec 93  C. Ghisler      huft_build() optimizations.    c14i   9 Jan 94  A. Verheijen    set fixed_t{d,l} to NULL after freeing;                     G. Roelofs      check NEXTBYTE macro for GZ_EOF.    c14j  23 Jan 94  G. Roelofs      removed Ghisler "optimizations"; ifdef'd                                     GZ_EOF check.    c14k  27 Feb 94  G. Roelofs      added some typecasts to avoid warnings.    c14l   9 Apr 94  G. Roelofs      fixed split comments on preprocessor lines                                     to avoid bug in Encore compiler.    c14m   7 Jul 94  P. Kienitz      modified to allow assembler version of                                     inflate_codes() (define ASM_INFLATECODES)    c14n  22 Jul 94  G. Roelofs      changed fprintf to FPRINTF for DLL versions    c14o  23 Aug 94  C. Spieler      added a newline to a debug statement;                     G. Roelofs      added another typecast to avoid MSC warning  */
end_comment

begin_comment
comment|/*    Inflate deflated (PKZIP's method 8 compressed) data.  The compression    method searches for as much of the current string of bytes (up to a    length of 258) in the previous 32K bytes.  If it doesn't find any    matches (of at least length 3), it codes the next byte.  Otherwise, it    codes the length of the matched string and its distance backwards from    the current position.  There is a single Huffman code that codes both    single bytes (called "literals") and match lengths.  A second Huffman    code codes the distance information, which follows a length code.  Each    length or distance code actually represents a base value and a number    of "extra" (sometimes zero) bits to get to add to the base value.  At    the end of each deflated block is a special end-of-block (EOB) literal/    length code.  The decoding process is basically: get a literal/length    code; if EOB then done; if a literal, emit the decoded byte; if a    length then get the distance and emit the referred-to bytes from the    sliding window of previously emitted data.     There are (currently) three kinds of inflate blocks: stored, fixed, and    dynamic.  The compressor outputs a chunk of data at a time and decides    which method to use on a chunk-by-chunk basis.  A chunk might typically    be 32K to 64K, uncompressed.  If the chunk is uncompressible, then the    "stored" method is used.  In this case, the bytes are simply stored as    is, eight bits per byte, with none of the above coding.  The bytes are    preceded by a count, since there is no longer an EOB code.     If the data is compressible, then either the fixed or dynamic methods    are used.  In the dynamic method, the compressed data is preceded by    an encoding of the literal/length and distance Huffman codes that are    to be used to decode this block.  The representation is itself Huffman    coded, and so is preceded by a description of that code.  These code    descriptions take up a little space, and so for small blocks, there is    a predefined set of codes, called the fixed codes.  The fixed method is    used if the block ends up smaller that way (usually for quite small    chunks); otherwise the dynamic method is used.  In the latter case, the    codes are customized to the probabilities in the current block and so    can code it much better than the pre-determined fixed codes can.     The Huffman codes themselves are decoded using a mutli-level table    lookup, in order to maximize the speed of decoding plus the speed of    building the decoding tables.  See the comments below that precede the    lbits and dbits tuning parameters.  */
end_comment

begin_comment
comment|/*    Notes beyond the 1.93a appnote.txt:     1. Distance pointers never point before the beginning of the output       stream.    2. Distance pointers can point back across blocks, up to 32k away.    3. There is an implied maximum of 7 bits for the bit length table and       15 bits for the actual data.    4. If only one code exists, then it is encoded using one bit.  (Zero       would be more efficient, but perhaps a little confusing.)  If two       codes exist, they are coded using one bit each (0 and 1).    5. There is no way of sending zero distance codes--a dummy must be       sent if there are none.  (History: a pre 2.0 version of PKZIP would       store blocks with no distance codes, but this was discovered to be       too harsh a criterion.)  Valid only for 1.93a.  2.04c does allow       zero distance codes, which is sent as one code of zero bits in       length.    6. There are up to 286 literal/length codes.  Code 256 represents the       end-of-block.  Note however that the static length tree defines       288 codes just to fill out the Huffman codes.  Codes 286 and 287       cannot be used though, since there is no length base or extra bits       defined for them.  Similarily, there are up to 30 distance codes.       However, static trees define 32 codes (all 5 bits) to fill out the       Huffman codes, but the last two had better not show up in the data.    7. Unzip can check dynamic Huffman blocks for complete code sets.       The exception is that a single code would not be complete (see #4).    8. The five bits following the block type is really the number of       literal codes sent minus 257.    9. Length codes 8,16,16 are interpreted as 13 length codes of 8 bits       (1+6+6).  Therefore, to output three times the length, you output       three codes (1+1+1), whereas to output four times the same length,       you only need two codes (1+3).  Hmm.   10. In the tree reconstruction algorithm, Code = Code + Increment       only if BitLength(i) is not zero.  (Pretty obvious.)   11. Correction: 4 Bits: # of Bit Length codes - 4     (4 - 19)   12. Note: length code 284 can represent 227-258, but length code 285       really is 258.  The last length deserves its own, short code       since it gets used a lot in very redundant files.  The length       258 is special since 258 - 3 (the min match length) is 255.   13. The literal/length and distance code bit lengths are read as a       single stream of lengths.  It is possible (and advantageous) for       a repeat code (16, 17, or 18) to go across the boundary between       the two sets of lengths.  */
end_comment

begin_define
define|#
directive|define
name|PKZIP_BUG_WORKAROUND
end_define

begin_comment
comment|/* PKZIP 1.93a problem--live with it */
end_comment

begin_comment
comment|/*     inflate.h must supply the uch slide[GZ_WSIZE] array and the NEXTBYTE,     FLUSH() and memzero macros.  If the window size is not 32K, it     should also define GZ_WSIZE.  If INFMOD is defined, it can include     compiled functions to support the NEXTBYTE and/or FLUSH() macros.     There are defaults for NEXTBYTE and FLUSH() below for use as     examples of what those functions need to do.  Normally, you would     also want FLUSH() to compute a crc on the data.  inflate.h also     needs to provide these typedefs:          typedef unsigned char uch;         typedef unsigned short ush;         typedef unsigned long ulg;      This module uses the external functions malloc() and free() (and     probably memset() or bzero() in the memzero() macro).  Their     prototypes are normally found in<string.h> and<stdlib.h>.  */
end_comment

begin_define
define|#
directive|define
name|INFMOD
end_define

begin_comment
comment|/* tell inflate.h to include code to be 				 * compiled */
end_comment

begin_comment
comment|/* Huffman code lookup table entry--this entry is four bytes for machines    that have 16-bit pointers (e.g. PC's in the small or medium model).    Valid extra bits are 0..13.  e == 15 is EOB (end of block), e == 16    means that v is a literal, 16< e< 32 means that v is a pointer to    the next table, which codes e - 16 bits, and lastly e == 99 indicates    an unused code.  If a code with e == 99 is looked up, this implies an    error in the data. */
end_comment

begin_struct
struct|struct
name|huft
block|{
name|uch
name|e
decl_stmt|;
comment|/* number of extra bits or operation */
name|uch
name|b
decl_stmt|;
comment|/* number of bits in this code or subcode */
union|union
block|{
name|ush
name|n
decl_stmt|;
comment|/* literal, length base, or distance 					 * base */
name|struct
name|huft
modifier|*
name|t
decl_stmt|;
comment|/* pointer to next level of table */
block|}
name|v
union|;
block|}
struct|;
end_struct

begin_comment
comment|/* Function prototypes */
end_comment

begin_decl_stmt
specifier|static
name|int
name|huft_build
name|__P
argument_list|(
operator|(
expr|struct
name|inflate
operator|*
operator|,
name|unsigned
operator|*
operator|,
name|unsigned
operator|,
name|unsigned
operator|,
specifier|const
name|ush
operator|*
operator|,
specifier|const
name|ush
operator|*
operator|,
expr|struct
name|huft
operator|*
operator|*
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|huft_free
name|__P
argument_list|(
operator|(
expr|struct
name|inflate
operator|*
operator|,
expr|struct
name|huft
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|inflate_codes
name|__P
argument_list|(
operator|(
expr|struct
name|inflate
operator|*
operator|,
expr|struct
name|huft
operator|*
operator|,
expr|struct
name|huft
operator|*
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|inflate_stored
name|__P
argument_list|(
operator|(
expr|struct
name|inflate
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|xinflate
name|__P
argument_list|(
operator|(
expr|struct
name|inflate
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|inflate_fixed
name|__P
argument_list|(
operator|(
expr|struct
name|inflate
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|inflate_dynamic
name|__P
argument_list|(
operator|(
expr|struct
name|inflate
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|inflate_block
name|__P
argument_list|(
operator|(
expr|struct
name|inflate
operator|*
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The inflate algorithm uses a sliding 32K byte window on the uncompressed    stream to find repeated byte strings.  This is implemented here as a    circular buffer.  The index is updated simply by incrementing and then    and'ing with 0x7fff (32K-1). */
end_comment

begin_comment
comment|/* It is left to other modules to supply the 32K area.  It is assumed    to be usable as if it were declared "uch slide[32768];" or as just    "uch *slide;" and then malloc'ed in the latter case.  The definition    must be in unzip.h, included above. */
end_comment

begin_comment
comment|/* Tables for deflate from PKZIP's appnote.txt. */
end_comment

begin_comment
comment|/* Order of the bit length code lengths */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|unsigned
name|border
index|[]
init|=
block|{
literal|16
block|,
literal|17
block|,
literal|18
block|,
literal|0
block|,
literal|8
block|,
literal|7
block|,
literal|9
block|,
literal|6
block|,
literal|10
block|,
literal|5
block|,
literal|11
block|,
literal|4
block|,
literal|12
block|,
literal|3
block|,
literal|13
block|,
literal|2
block|,
literal|14
block|,
literal|1
block|,
literal|15
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|ush
name|cplens
index|[]
init|=
block|{
comment|/* Copy lengths for literal codes 257..285 */
literal|3
block|,
literal|4
block|,
literal|5
block|,
literal|6
block|,
literal|7
block|,
literal|8
block|,
literal|9
block|,
literal|10
block|,
literal|11
block|,
literal|13
block|,
literal|15
block|,
literal|17
block|,
literal|19
block|,
literal|23
block|,
literal|27
block|,
literal|31
block|,
literal|35
block|,
literal|43
block|,
literal|51
block|,
literal|59
block|,
literal|67
block|,
literal|83
block|,
literal|99
block|,
literal|115
block|,
literal|131
block|,
literal|163
block|,
literal|195
block|,
literal|227
block|,
literal|258
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* note: see note #13 above about the 258 in this list. */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|ush
name|cplext
index|[]
init|=
block|{
comment|/* Extra bits for literal codes 257..285 */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|0
block|,
literal|99
block|,
literal|99
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 99==invalid */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|ush
name|cpdist
index|[]
init|=
block|{
comment|/* Copy offsets for distance codes 0..29 */
literal|1
block|,
literal|2
block|,
literal|3
block|,
literal|4
block|,
literal|5
block|,
literal|7
block|,
literal|9
block|,
literal|13
block|,
literal|17
block|,
literal|25
block|,
literal|33
block|,
literal|49
block|,
literal|65
block|,
literal|97
block|,
literal|129
block|,
literal|193
block|,
literal|257
block|,
literal|385
block|,
literal|513
block|,
literal|769
block|,
literal|1025
block|,
literal|1537
block|,
literal|2049
block|,
literal|3073
block|,
literal|4097
block|,
literal|6145
block|,
literal|8193
block|,
literal|12289
block|,
literal|16385
block|,
literal|24577
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|ush
name|cpdext
index|[]
init|=
block|{
comment|/* Extra bits for distance codes */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|2
block|,
literal|2
block|,
literal|3
block|,
literal|3
block|,
literal|4
block|,
literal|4
block|,
literal|5
block|,
literal|5
block|,
literal|6
block|,
literal|6
block|,
literal|7
block|,
literal|7
block|,
literal|8
block|,
literal|8
block|,
literal|9
block|,
literal|9
block|,
literal|10
block|,
literal|10
block|,
literal|11
block|,
literal|11
block|,
literal|12
block|,
literal|12
block|,
literal|13
block|,
literal|13
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* And'ing with mask[n] masks the lower n bits */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|ush
name|mask
index|[]
init|=
block|{
literal|0x0000
block|,
literal|0x0001
block|,
literal|0x0003
block|,
literal|0x0007
block|,
literal|0x000f
block|,
literal|0x001f
block|,
literal|0x003f
block|,
literal|0x007f
block|,
literal|0x00ff
block|,
literal|0x01ff
block|,
literal|0x03ff
block|,
literal|0x07ff
block|,
literal|0x0fff
block|,
literal|0x1fff
block|,
literal|0x3fff
block|,
literal|0x7fff
block|,
literal|0xffff
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Macros for inflate() bit peeking and grabbing.    The usage is:          NEEDBITS(glbl,j)         x = b& mask[j];         DUMPBITS(j)     where NEEDBITS makes sure that b has at least j bits in it, and    DUMPBITS removes the bits from b.  The macros use the variable k    for the number of bits in b.  Normally, b and k are register    variables for speed, and are initialized at the begining of a    routine that uses these macros from a global bit buffer and count.     In order to not ask for more bits than there are in the compressed    stream, the Huffman tables are constructed to only ask for just    enough bits to make up the end-of-block code (value 256).  Then no    bytes need to be "returned" to the buffer at the end of the last    block.  See the huft_build() routine.  */
end_comment

begin_comment
comment|/*  * The following 2 were global variables.  * They are now fields of the inflate structure.  */
end_comment

begin_define
define|#
directive|define
name|NEEDBITS
parameter_list|(
name|glbl
parameter_list|,
name|n
parameter_list|)
value|{						\ 		while(k<(n)) {						\ 			int c=(*glbl->gz_input)(glbl->gz_private);	\ 			if(c==GZ_EOF)					\ 				return 1; 				\ 			b|=((ulg)c)<<k;					\ 			k+=8;						\ 		}							\ 	}
end_define

begin_define
define|#
directive|define
name|DUMPBITS
parameter_list|(
name|n
parameter_list|)
value|{b>>=(n);k-=(n);}
end_define

begin_comment
comment|/*    Huffman code decoding is performed using a multi-level table lookup.    The fastest way to decode is to simply build a lookup table whose    size is determined by the longest code.  However, the time it takes    to build this table can also be a factor if the data being decoded    is not very long.  The most common codes are necessarily the    shortest codes, so those codes dominate the decoding time, and hence    the speed.  The idea is you can have a shorter table that decodes the    shorter, more probable codes, and then point to subsidiary tables for    the longer codes.  The time it costs to decode the longer codes is    then traded against the time it takes to make longer tables.     This results of this trade are in the variables lbits and dbits    below.  lbits is the number of bits the first level table for literal/    length codes can decode in one step, and dbits is the same thing for    the distance codes.  Subsequent tables are also less than or equal to    those sizes.  These values may be adjusted either when all of the    codes are shorter than that, in which case the longest code length in    bits is used, or when the shortest code is *longer* than the requested    table size, in which case the length of the shortest code in bits is    used.     There are two different values for the two tables, since they code a    different number of possibilities each.  The literal/length table    codes 286 possible values, or in a flat code, a little over eight    bits.  The distance table codes 30 possible values, or a little less    than five bits, flat.  The optimum values for speed end up being    about one bit more than those, so lbits is 8+1 and dbits is 5+1.    The optimum values may differ though from machine to machine, and    possibly even between compilers.  Your mileage may vary.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|int
name|lbits
init|=
literal|9
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* bits in base literal/length lookup table */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|int
name|dbits
init|=
literal|6
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* bits in base distance lookup table */
end_comment

begin_comment
comment|/* If BMAX needs to be larger than 16, then h and x[] should be ulg. */
end_comment

begin_define
define|#
directive|define
name|BMAX
value|16
end_define

begin_comment
comment|/* maximum bit length of any code (16 for 				 * explode) */
end_comment

begin_define
define|#
directive|define
name|N_MAX
value|288
end_define

begin_comment
comment|/* maximum number of codes in any set */
end_comment

begin_comment
comment|/* Given a list of code lengths and a maximum table size, make a set of    tables to decode that set of codes.  Return zero on success, one if    the given code set is incomplete (the tables are still built in this    case), two if the input is invalid (all zero length codes or an    oversubscribed set of lengths), and three if not enough memory.    The code with value 256 is special, and the tables are constructed    so that no bits beyond that code are fetched when that code is    decoded. */
end_comment

begin_function
specifier|static
name|int
name|huft_build
parameter_list|(
name|glbl
parameter_list|,
name|b
parameter_list|,
name|n
parameter_list|,
name|s
parameter_list|,
name|d
parameter_list|,
name|e
parameter_list|,
name|t
parameter_list|,
name|m
parameter_list|)
name|struct
name|inflate
modifier|*
name|glbl
decl_stmt|;
name|unsigned
modifier|*
name|b
decl_stmt|;
comment|/* code lengths in bits (all assumed<= BMAX) */
name|unsigned
name|n
decl_stmt|;
comment|/* number of codes (assumed<= N_MAX) */
name|unsigned
name|s
decl_stmt|;
comment|/* number of simple-valued codes (0..s-1) */
specifier|const
name|ush
modifier|*
name|d
decl_stmt|;
comment|/* list of base values for non-simple codes */
specifier|const
name|ush
modifier|*
name|e
decl_stmt|;
comment|/* list of extra bits for non-simple codes */
name|struct
name|huft
modifier|*
modifier|*
name|t
decl_stmt|;
comment|/* result: starting table */
name|int
modifier|*
name|m
decl_stmt|;
comment|/* maximum lookup bits, returns actual */
block|{
name|unsigned
name|a
decl_stmt|;
comment|/* counter for codes of length k */
name|unsigned
name|c
index|[
name|BMAX
operator|+
literal|1
index|]
decl_stmt|;
comment|/* bit length count table */
name|unsigned
name|el
decl_stmt|;
comment|/* length of EOB code (value 256) */
name|unsigned
name|f
decl_stmt|;
comment|/* i repeats in table every f entries */
name|int
name|g
decl_stmt|;
comment|/* maximum code length */
name|int
name|h
decl_stmt|;
comment|/* table level */
specifier|register
name|unsigned
name|i
decl_stmt|;
comment|/* counter, current code */
specifier|register
name|unsigned
name|j
decl_stmt|;
comment|/* counter */
specifier|register
name|int
name|k
decl_stmt|;
comment|/* number of bits in current code */
name|int
name|lx
index|[
name|BMAX
operator|+
literal|1
index|]
decl_stmt|;
comment|/* memory for l[-1..BMAX-1] */
name|int
modifier|*
name|l
init|=
name|lx
operator|+
literal|1
decl_stmt|;
comment|/* stack of bits per table */
specifier|register
name|unsigned
modifier|*
name|p
decl_stmt|;
comment|/* pointer into c[], b[], or v[] */
specifier|register
name|struct
name|huft
modifier|*
name|q
decl_stmt|;
comment|/* points to current table */
name|struct
name|huft
name|r
decl_stmt|;
comment|/* table entry for structure assignment */
name|struct
name|huft
modifier|*
name|u
index|[
name|BMAX
index|]
decl_stmt|;
comment|/* table stack */
name|unsigned
name|v
index|[
name|N_MAX
index|]
decl_stmt|;
comment|/* values in order of bit length */
specifier|register
name|int
name|w
decl_stmt|;
comment|/* bits before this table == (l * h) */
name|unsigned
name|x
index|[
name|BMAX
operator|+
literal|1
index|]
decl_stmt|;
comment|/* bit offsets, then code stack */
name|unsigned
modifier|*
name|xp
decl_stmt|;
comment|/* pointer into x */
name|int
name|y
decl_stmt|;
comment|/* number of dummy codes added */
name|unsigned
name|z
decl_stmt|;
comment|/* number of entries in current table */
comment|/* Generate counts for each bit length */
name|el
operator|=
name|n
operator|>
literal|256
condition|?
name|b
index|[
literal|256
index|]
else|:
name|BMAX
expr_stmt|;
comment|/* set length of EOB code, if any */
ifdef|#
directive|ifdef
name|KERNEL
name|memzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|c
argument_list|,
sizeof|sizeof
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|BMAX
operator|+
literal|1
condition|;
name|i
operator|++
control|)
name|c
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|p
operator|=
name|b
expr_stmt|;
name|i
operator|=
name|n
expr_stmt|;
do|do
block|{
name|c
index|[
operator|*
name|p
index|]
operator|++
expr_stmt|;
name|p
operator|++
expr_stmt|;
comment|/* assume all entries<= BMAX */
block|}
do|while
condition|(
operator|--
name|i
condition|)
do|;
if|if
condition|(
name|c
index|[
literal|0
index|]
operator|==
name|n
condition|)
block|{
comment|/* null input--all zero length codes */
operator|*
name|t
operator|=
operator|(
expr|struct
name|huft
operator|*
operator|)
name|NULL
expr_stmt|;
operator|*
name|m
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Find minimum and maximum length, bound *m by those */
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<=
name|BMAX
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|c
index|[
name|j
index|]
condition|)
break|break;
name|k
operator|=
name|j
expr_stmt|;
comment|/* minimum code length */
if|if
condition|(
operator|(
name|unsigned
operator|)
operator|*
name|m
operator|<
name|j
condition|)
operator|*
name|m
operator|=
name|j
expr_stmt|;
for|for
control|(
name|i
operator|=
name|BMAX
init|;
name|i
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|c
index|[
name|i
index|]
condition|)
break|break;
name|g
operator|=
name|i
expr_stmt|;
comment|/* maximum code length */
if|if
condition|(
operator|(
name|unsigned
operator|)
operator|*
name|m
operator|>
name|i
condition|)
operator|*
name|m
operator|=
name|i
expr_stmt|;
comment|/* Adjust last length count to fill out codes, if needed */
for|for
control|(
name|y
operator|=
literal|1
operator|<<
name|j
init|;
name|j
operator|<
name|i
condition|;
name|j
operator|++
operator|,
name|y
operator|<<=
literal|1
control|)
if|if
condition|(
operator|(
name|y
operator|-=
name|c
index|[
name|j
index|]
operator|)
operator|<
literal|0
condition|)
return|return
literal|2
return|;
comment|/* bad input: more codes than bits */
if|if
condition|(
operator|(
name|y
operator|-=
name|c
index|[
name|i
index|]
operator|)
operator|<
literal|0
condition|)
return|return
literal|2
return|;
name|c
index|[
name|i
index|]
operator|+=
name|y
expr_stmt|;
comment|/* Generate starting offsets into the value table for each length */
name|x
index|[
literal|1
index|]
operator|=
name|j
operator|=
literal|0
expr_stmt|;
name|p
operator|=
name|c
operator|+
literal|1
expr_stmt|;
name|xp
operator|=
name|x
operator|+
literal|2
expr_stmt|;
while|while
condition|(
operator|--
name|i
condition|)
block|{
comment|/* note that i == g from above */
operator|*
name|xp
operator|++
operator|=
operator|(
name|j
operator|+=
operator|*
name|p
operator|++
operator|)
expr_stmt|;
block|}
comment|/* Make a table of values in order of bit lengths */
name|p
operator|=
name|b
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
do|do
block|{
if|if
condition|(
operator|(
name|j
operator|=
operator|*
name|p
operator|++
operator|)
operator|!=
literal|0
condition|)
name|v
index|[
name|x
index|[
name|j
index|]
operator|++
index|]
operator|=
name|i
expr_stmt|;
block|}
do|while
condition|(
operator|++
name|i
operator|<
name|n
condition|)
do|;
comment|/* Generate the Huffman codes and for each, make the table entries */
name|x
index|[
literal|0
index|]
operator|=
name|i
operator|=
literal|0
expr_stmt|;
comment|/* first Huffman code is zero */
name|p
operator|=
name|v
expr_stmt|;
comment|/* grab values in bit order */
name|h
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* no tables yet--level -1 */
name|w
operator|=
name|l
index|[
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
comment|/* no bits decoded yet */
name|u
index|[
literal|0
index|]
operator|=
operator|(
expr|struct
name|huft
operator|*
operator|)
name|NULL
expr_stmt|;
comment|/* just to keep compilers happy */
name|q
operator|=
operator|(
expr|struct
name|huft
operator|*
operator|)
name|NULL
expr_stmt|;
comment|/* ditto */
name|z
operator|=
literal|0
expr_stmt|;
comment|/* ditto */
comment|/* go through the bit lengths (k already is bits in shortest code) */
for|for
control|(
init|;
name|k
operator|<=
name|g
condition|;
name|k
operator|++
control|)
block|{
name|a
operator|=
name|c
index|[
name|k
index|]
expr_stmt|;
while|while
condition|(
name|a
operator|--
condition|)
block|{
comment|/* 			 * here i is the Huffman code of length k bits for 			 * value *p 			 */
comment|/* make tables up to required level */
while|while
condition|(
name|k
operator|>
name|w
operator|+
name|l
index|[
name|h
index|]
condition|)
block|{
name|w
operator|+=
name|l
index|[
name|h
operator|++
index|]
expr_stmt|;
comment|/* add bits already decoded */
comment|/* 				 * compute minimum size table less than or 				 * equal to *m bits 				 */
name|z
operator|=
operator|(
name|z
operator|=
name|g
operator|-
name|w
operator|)
operator|>
operator|(
name|unsigned
operator|)
operator|*
name|m
condition|?
operator|*
name|m
else|:
name|z
expr_stmt|;
comment|/* upper limit */
if|if
condition|(
operator|(
name|f
operator|=
literal|1
operator|<<
operator|(
name|j
operator|=
name|k
operator|-
name|w
operator|)
operator|)
operator|>
name|a
operator|+
literal|1
condition|)
block|{
comment|/* try a k-w bit table */
comment|/* t 									 * oo few codes for k-w 									 * bit table */
name|f
operator|-=
name|a
operator|+
literal|1
expr_stmt|;
comment|/* deduct codes from 							 * patterns left */
name|xp
operator|=
name|c
operator|+
name|k
expr_stmt|;
while|while
condition|(
operator|++
name|j
operator|<
name|z
condition|)
block|{
comment|/* try smaller tables up 								 * to z bits */
if|if
condition|(
operator|(
name|f
operator|<<=
literal|1
operator|)
operator|<=
operator|*
operator|++
name|xp
condition|)
break|break;
comment|/* enough codes to use 								 * up j bits */
name|f
operator|-=
operator|*
name|xp
expr_stmt|;
comment|/* else deduct codes 								 * from patterns */
block|}
block|}
if|if
condition|(
operator|(
name|unsigned
operator|)
name|w
operator|+
name|j
operator|>
name|el
operator|&&
operator|(
name|unsigned
operator|)
name|w
operator|<
name|el
condition|)
name|j
operator|=
name|el
operator|-
name|w
expr_stmt|;
comment|/* make EOB code end at 							 * table */
name|z
operator|=
literal|1
operator|<<
name|j
expr_stmt|;
comment|/* table entries for j-bit 						 * table */
name|l
index|[
name|h
index|]
operator|=
name|j
expr_stmt|;
comment|/* set table size in stack */
comment|/* allocate and link in new table */
if|if
condition|(
operator|(
name|q
operator|=
operator|(
expr|struct
name|huft
operator|*
operator|)
name|malloc
argument_list|(
operator|(
name|z
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|huft
argument_list|)
argument_list|,
name|M_GZIP
argument_list|,
name|M_WAITOK
argument_list|)
operator|)
operator|==
operator|(
expr|struct
name|huft
operator|*
operator|)
name|NULL
condition|)
block|{
if|if
condition|(
name|h
condition|)
name|huft_free
argument_list|(
name|glbl
argument_list|,
name|u
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return
literal|3
return|;
comment|/* not enough memory */
block|}
name|glbl
operator|->
name|gz_hufts
operator|+=
name|z
operator|+
literal|1
expr_stmt|;
comment|/* track memory usage */
operator|*
name|t
operator|=
name|q
operator|+
literal|1
expr_stmt|;
comment|/* link to list for 						 * huft_free() */
operator|*
operator|(
name|t
operator|=
operator|&
operator|(
name|q
operator|->
name|v
operator|.
name|t
operator|)
operator|)
operator|=
operator|(
expr|struct
name|huft
operator|*
operator|)
name|NULL
expr_stmt|;
name|u
index|[
name|h
index|]
operator|=
operator|++
name|q
expr_stmt|;
comment|/* table starts after link */
comment|/* connect to last table, if there is one */
if|if
condition|(
name|h
condition|)
block|{
name|x
index|[
name|h
index|]
operator|=
name|i
expr_stmt|;
comment|/* save pattern for 							 * backing up */
name|r
operator|.
name|b
operator|=
operator|(
name|uch
operator|)
name|l
index|[
name|h
operator|-
literal|1
index|]
expr_stmt|;
comment|/* bits to dump before 								 * this table */
name|r
operator|.
name|e
operator|=
call|(
name|uch
call|)
argument_list|(
literal|16
operator|+
name|j
argument_list|)
expr_stmt|;
comment|/* bits in this table */
name|r
operator|.
name|v
operator|.
name|t
operator|=
name|q
expr_stmt|;
comment|/* pointer to this table */
name|j
operator|=
operator|(
name|i
operator|&
operator|(
operator|(
literal|1
operator|<<
name|w
operator|)
operator|-
literal|1
operator|)
operator|)
operator|>>
operator|(
name|w
operator|-
name|l
index|[
name|h
operator|-
literal|1
index|]
operator|)
expr_stmt|;
name|u
index|[
name|h
operator|-
literal|1
index|]
index|[
name|j
index|]
operator|=
name|r
expr_stmt|;
comment|/* connect to last table */
block|}
block|}
comment|/* set up table entry in r */
name|r
operator|.
name|b
operator|=
call|(
name|uch
call|)
argument_list|(
name|k
operator|-
name|w
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|>=
name|v
operator|+
name|n
condition|)
name|r
operator|.
name|e
operator|=
literal|99
expr_stmt|;
comment|/* out of values--invalid 						 * code */
elseif|else
if|if
condition|(
operator|*
name|p
operator|<
name|s
condition|)
block|{
name|r
operator|.
name|e
operator|=
call|(
name|uch
call|)
argument_list|(
operator|*
name|p
operator|<
literal|256
condition|?
literal|16
else|:
literal|15
argument_list|)
expr_stmt|;
comment|/* 256 is end-of-block 									 * code */
name|r
operator|.
name|v
operator|.
name|n
operator|=
operator|*
name|p
operator|++
expr_stmt|;
comment|/* simple code is just the 						 * value */
block|}
else|else
block|{
name|r
operator|.
name|e
operator|=
operator|(
name|uch
operator|)
name|e
index|[
operator|*
name|p
operator|-
name|s
index|]
expr_stmt|;
comment|/* non-simple--look up 							 * in lists */
name|r
operator|.
name|v
operator|.
name|n
operator|=
name|d
index|[
operator|*
name|p
operator|++
operator|-
name|s
index|]
expr_stmt|;
block|}
comment|/* fill code-like entries with r */
name|f
operator|=
literal|1
operator|<<
operator|(
name|k
operator|-
name|w
operator|)
expr_stmt|;
for|for
control|(
name|j
operator|=
name|i
operator|>>
name|w
init|;
name|j
operator|<
name|z
condition|;
name|j
operator|+=
name|f
control|)
name|q
index|[
name|j
index|]
operator|=
name|r
expr_stmt|;
comment|/* backwards increment the k-bit code i */
for|for
control|(
name|j
operator|=
literal|1
operator|<<
operator|(
name|k
operator|-
literal|1
operator|)
init|;
name|i
operator|&
name|j
condition|;
name|j
operator|>>=
literal|1
control|)
name|i
operator|^=
name|j
expr_stmt|;
name|i
operator|^=
name|j
expr_stmt|;
comment|/* backup over finished tables */
while|while
condition|(
operator|(
name|i
operator|&
operator|(
operator|(
literal|1
operator|<<
name|w
operator|)
operator|-
literal|1
operator|)
operator|)
operator|!=
name|x
index|[
name|h
index|]
condition|)
name|w
operator|-=
name|l
index|[
operator|--
name|h
index|]
expr_stmt|;
comment|/* don't need to update q */
block|}
block|}
comment|/* return actual size of base table */
operator|*
name|m
operator|=
name|l
index|[
literal|0
index|]
expr_stmt|;
comment|/* Return true (1) if we were given an incomplete table */
return|return
name|y
operator|!=
literal|0
operator|&&
name|g
operator|!=
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|huft_free
parameter_list|(
name|glbl
parameter_list|,
name|t
parameter_list|)
name|struct
name|inflate
modifier|*
name|glbl
decl_stmt|;
name|struct
name|huft
modifier|*
name|t
decl_stmt|;
comment|/* table to free */
comment|/* Free the malloc'ed tables built by huft_build(), which makes a linked    list of the tables it made, with the links in a dummy first entry of    each table. */
block|{
specifier|register
name|struct
name|huft
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
comment|/* Go through linked list, freeing from the malloced (t[-1]) address. */
name|p
operator|=
name|t
expr_stmt|;
while|while
condition|(
name|p
operator|!=
operator|(
expr|struct
name|huft
operator|*
operator|)
name|NULL
condition|)
block|{
name|q
operator|=
operator|(
operator|--
name|p
operator|)
operator|->
name|v
operator|.
name|t
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|,
name|M_GZIP
argument_list|)
expr_stmt|;
name|p
operator|=
name|q
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* inflate (decompress) the codes in a deflated (compressed) block.    Return an error code or zero if it all goes ok. */
end_comment

begin_function
specifier|static
name|int
name|inflate_codes
parameter_list|(
name|glbl
parameter_list|,
name|tl
parameter_list|,
name|td
parameter_list|,
name|bl
parameter_list|,
name|bd
parameter_list|)
name|struct
name|inflate
modifier|*
name|glbl
decl_stmt|;
name|struct
name|huft
modifier|*
name|tl
decl_stmt|,
decl|*
name|td
decl_stmt|;
end_function

begin_comment
comment|/* literal/length and distance decoder tables */
end_comment

begin_decl_stmt
name|int
name|bl
decl_stmt|,
name|bd
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of bits decoded by tl[] and td[] */
end_comment

begin_block
block|{
specifier|register
name|unsigned
name|e
decl_stmt|;
comment|/* table entry flag/number of extra bits */
name|unsigned
name|n
decl_stmt|,
name|d
decl_stmt|;
comment|/* length and index for copy */
name|unsigned
name|w
decl_stmt|;
comment|/* current window position */
name|struct
name|huft
modifier|*
name|t
decl_stmt|;
comment|/* pointer to table entry */
name|unsigned
name|ml
decl_stmt|,
name|md
decl_stmt|;
comment|/* masks for bl and bd bits */
specifier|register
name|ulg
name|b
decl_stmt|;
comment|/* bit buffer */
specifier|register
name|unsigned
name|k
decl_stmt|;
comment|/* number of bits in bit buffer */
comment|/* make local copies of globals */
name|b
operator|=
name|glbl
operator|->
name|gz_bb
expr_stmt|;
comment|/* initialize bit buffer */
name|k
operator|=
name|glbl
operator|->
name|gz_bk
expr_stmt|;
name|w
operator|=
name|glbl
operator|->
name|gz_wp
expr_stmt|;
comment|/* initialize window position */
comment|/* inflate the coded data */
name|ml
operator|=
name|mask
index|[
name|bl
index|]
expr_stmt|;
comment|/* precompute masks for speed */
name|md
operator|=
name|mask
index|[
name|bd
index|]
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
comment|/* do until end of block */
name|NEEDBITS
argument_list|(
argument|glbl
argument_list|,
argument|(unsigned) bl
argument_list|)
if|if
condition|(
operator|(
name|e
operator|=
operator|(
name|t
operator|=
name|tl
operator|+
operator|(
operator|(
name|unsigned
operator|)
name|b
operator|&
name|ml
operator|)
operator|)
operator|->
name|e
operator|)
operator|>
literal|16
condition|)
do|do
block|{
if|if
condition|(
name|e
operator|==
literal|99
condition|)
return|return
literal|1
return|;
name|DUMPBITS
argument_list|(
argument|t->b
argument_list|)
name|e
operator|-=
literal|16
expr_stmt|;
name|NEEDBITS
argument_list|(
argument|glbl
argument_list|,
argument|e
argument_list|)
block|}
do|while
condition|(
operator|(
name|e
operator|=
operator|(
name|t
operator|=
name|t
operator|->
name|v
operator|.
name|t
operator|+
operator|(
operator|(
name|unsigned
operator|)
name|b
operator|&
name|mask
index|[
name|e
index|]
operator|)
operator|)
operator|->
name|e
operator|)
operator|>
literal|16
condition|)
do|;
name|DUMPBITS
argument_list|(
argument|t->b
argument_list|)
if|if
condition|(
name|e
operator|==
literal|16
condition|)
block|{
comment|/* then it's a literal */
name|glbl
operator|->
name|gz_slide
index|[
name|w
operator|++
index|]
operator|=
operator|(
name|uch
operator|)
name|t
operator|->
name|v
operator|.
name|n
expr_stmt|;
if|if
condition|(
name|w
operator|==
name|GZ_WSIZE
condition|)
block|{
name|FLUSH
argument_list|(
name|glbl
argument_list|,
name|w
argument_list|)
expr_stmt|;
name|w
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* it's an EOB or a length */
comment|/* exit if end of block */
if|if
condition|(
name|e
operator|==
literal|15
condition|)
break|break;
comment|/* get length of block to copy */
name|NEEDBITS
argument_list|(
argument|glbl
argument_list|,
argument|e
argument_list|)
name|n
operator|=
name|t
operator|->
name|v
operator|.
name|n
operator|+
operator|(
operator|(
name|unsigned
operator|)
name|b
operator|&
name|mask
index|[
name|e
index|]
operator|)
expr_stmt|;
name|DUMPBITS
argument_list|(
name|e
argument_list|)
expr_stmt|;
comment|/* decode distance of block to copy */
name|NEEDBITS
argument_list|(
argument|glbl
argument_list|,
argument|(unsigned) bd
argument_list|)
if|if
condition|(
operator|(
name|e
operator|=
operator|(
name|t
operator|=
name|td
operator|+
operator|(
operator|(
name|unsigned
operator|)
name|b
operator|&
name|md
operator|)
operator|)
operator|->
name|e
operator|)
operator|>
literal|16
condition|)
do|do
block|{
if|if
condition|(
name|e
operator|==
literal|99
condition|)
return|return
literal|1
return|;
name|DUMPBITS
argument_list|(
argument|t->b
argument_list|)
name|e
operator|-=
literal|16
expr_stmt|;
name|NEEDBITS
argument_list|(
argument|glbl
argument_list|,
argument|e
argument_list|)
block|}
do|while
condition|(
operator|(
name|e
operator|=
operator|(
name|t
operator|=
name|t
operator|->
name|v
operator|.
name|t
operator|+
operator|(
operator|(
name|unsigned
operator|)
name|b
operator|&
name|mask
index|[
name|e
index|]
operator|)
operator|)
operator|->
name|e
operator|)
operator|>
literal|16
condition|)
do|;
name|DUMPBITS
argument_list|(
argument|t->b
argument_list|)
name|NEEDBITS
argument_list|(
argument|glbl
argument_list|,
argument|e
argument_list|)
name|d
operator|=
name|w
operator|-
name|t
operator|->
name|v
operator|.
name|n
operator|-
operator|(
operator|(
name|unsigned
operator|)
name|b
operator|&
name|mask
index|[
name|e
index|]
operator|)
expr_stmt|;
name|DUMPBITS
argument_list|(
argument|e
argument_list|)
comment|/* do the copy */
do|do
block|{
name|n
operator|-=
operator|(
name|e
operator|=
operator|(
name|e
operator|=
name|GZ_WSIZE
operator|-
operator|(
operator|(
name|d
operator|&=
name|GZ_WSIZE
operator|-
literal|1
operator|)
operator|>
name|w
condition|?
name|d
else|:
name|w
operator|)
operator|)
operator|>
name|n
condition|?
name|n
else|:
name|e
operator|)
expr_stmt|;
ifndef|#
directive|ifndef
name|NOMEMCPY
if|if
condition|(
name|w
operator|-
name|d
operator|>=
name|e
condition|)
block|{
comment|/* (this test assumes 							 * unsigned comparison) */
name|memcpy
argument_list|(
name|glbl
operator|->
name|gz_slide
operator|+
name|w
argument_list|,
name|glbl
operator|->
name|gz_slide
operator|+
name|d
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|w
operator|+=
name|e
expr_stmt|;
name|d
operator|+=
name|e
expr_stmt|;
block|}
else|else
comment|/* do it slow to avoid memcpy() 					 * overlap */
endif|#
directive|endif
comment|/* !NOMEMCPY */
do|do
block|{
name|glbl
operator|->
name|gz_slide
index|[
name|w
operator|++
index|]
operator|=
name|glbl
operator|->
name|gz_slide
index|[
name|d
operator|++
index|]
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|e
condition|)
do|;
if|if
condition|(
name|w
operator|==
name|GZ_WSIZE
condition|)
block|{
name|FLUSH
argument_list|(
name|glbl
argument_list|,
name|w
argument_list|)
expr_stmt|;
name|w
operator|=
literal|0
expr_stmt|;
block|}
block|}
do|while
condition|(
name|n
condition|)
do|;
block|}
block|}
comment|/* restore the globals from the locals */
name|glbl
operator|->
name|gz_wp
operator|=
name|w
expr_stmt|;
comment|/* restore global window pointer */
name|glbl
operator|->
name|gz_bb
operator|=
name|b
expr_stmt|;
comment|/* restore global bit buffer */
name|glbl
operator|->
name|gz_bk
operator|=
name|k
expr_stmt|;
comment|/* done */
return|return
literal|0
return|;
block|}
end_block

begin_comment
comment|/* "decompress" an inflated type 0 (stored) block. */
end_comment

begin_function
specifier|static
name|int
name|inflate_stored
parameter_list|(
name|glbl
parameter_list|)
name|struct
name|inflate
modifier|*
name|glbl
decl_stmt|;
block|{
name|unsigned
name|n
decl_stmt|;
comment|/* number of bytes in block */
name|unsigned
name|w
decl_stmt|;
comment|/* current window position */
specifier|register
name|ulg
name|b
decl_stmt|;
comment|/* bit buffer */
specifier|register
name|unsigned
name|k
decl_stmt|;
comment|/* number of bits in bit buffer */
comment|/* make local copies of globals */
name|b
operator|=
name|glbl
operator|->
name|gz_bb
expr_stmt|;
comment|/* initialize bit buffer */
name|k
operator|=
name|glbl
operator|->
name|gz_bk
expr_stmt|;
name|w
operator|=
name|glbl
operator|->
name|gz_wp
expr_stmt|;
comment|/* initialize window position */
comment|/* go to byte boundary */
name|n
operator|=
name|k
operator|&
literal|7
expr_stmt|;
name|DUMPBITS
argument_list|(
name|n
argument_list|)
expr_stmt|;
comment|/* get the length and its complement */
name|NEEDBITS
argument_list|(
argument|glbl
argument_list|,
literal|16
argument_list|)
name|n
operator|=
operator|(
operator|(
name|unsigned
operator|)
name|b
operator|&
literal|0xffff
operator|)
expr_stmt|;
name|DUMPBITS
argument_list|(
literal|16
argument_list|)
name|NEEDBITS
argument_list|(
argument|glbl
argument_list|,
literal|16
argument_list|)
if|if
condition|(
name|n
operator|!=
call|(
name|unsigned
call|)
argument_list|(
operator|(
operator|~
name|b
operator|)
operator|&
literal|0xffff
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* error in compressed data */
name|DUMPBITS
argument_list|(
literal|16
argument_list|)
comment|/* read and output the compressed data */
while|while
condition|(
name|n
operator|--
condition|)
block|{
name|NEEDBITS
argument_list|(
argument|glbl
argument_list|,
literal|8
argument_list|)
name|glbl
operator|->
name|gz_slide
index|[
name|w
operator|++
index|]
operator|=
operator|(
name|uch
operator|)
name|b
expr_stmt|;
if|if
condition|(
name|w
operator|==
name|GZ_WSIZE
condition|)
block|{
name|FLUSH
argument_list|(
name|glbl
argument_list|,
name|w
argument_list|)
expr_stmt|;
name|w
operator|=
literal|0
expr_stmt|;
block|}
name|DUMPBITS
argument_list|(
literal|8
argument_list|)
block|}
comment|/* restore the globals from the locals */
name|glbl
operator|->
name|gz_wp
operator|=
name|w
expr_stmt|;
comment|/* restore global window pointer */
name|glbl
operator|->
name|gz_bb
operator|=
name|b
expr_stmt|;
comment|/* restore global bit buffer */
name|glbl
operator|->
name|gz_bk
operator|=
name|k
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* decompress an inflated type 1 (fixed Huffman codes) block.  We should    either replace this with a custom decoder, or at least precompute the    Huffman tables. */
end_comment

begin_function
specifier|static
name|int
name|inflate_fixed
parameter_list|(
name|glbl
parameter_list|)
name|struct
name|inflate
modifier|*
name|glbl
decl_stmt|;
block|{
comment|/* if first time, set up tables for fixed blocks */
if|if
condition|(
name|glbl
operator|->
name|gz_fixed_tl
operator|==
operator|(
expr|struct
name|huft
operator|*
operator|)
name|NULL
condition|)
block|{
name|int
name|i
decl_stmt|;
comment|/* temporary variable */
specifier|static
name|unsigned
name|l
index|[
literal|288
index|]
decl_stmt|;
comment|/* length list for huft_build */
comment|/* literal table */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|144
condition|;
name|i
operator|++
control|)
name|l
index|[
name|i
index|]
operator|=
literal|8
expr_stmt|;
for|for
control|(
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
control|)
name|l
index|[
name|i
index|]
operator|=
literal|9
expr_stmt|;
for|for
control|(
init|;
name|i
operator|<
literal|280
condition|;
name|i
operator|++
control|)
name|l
index|[
name|i
index|]
operator|=
literal|7
expr_stmt|;
for|for
control|(
init|;
name|i
operator|<
literal|288
condition|;
name|i
operator|++
control|)
comment|/* make a complete, but wrong code 					 * set */
name|l
index|[
name|i
index|]
operator|=
literal|8
expr_stmt|;
name|glbl
operator|->
name|gz_fixed_bl
operator|=
literal|7
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|=
name|huft_build
argument_list|(
name|glbl
argument_list|,
name|l
argument_list|,
literal|288
argument_list|,
literal|257
argument_list|,
name|cplens
argument_list|,
name|cplext
argument_list|,
operator|&
name|glbl
operator|->
name|gz_fixed_tl
argument_list|,
operator|&
name|glbl
operator|->
name|gz_fixed_bl
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|glbl
operator|->
name|gz_fixed_tl
operator|=
operator|(
expr|struct
name|huft
operator|*
operator|)
name|NULL
expr_stmt|;
return|return
name|i
return|;
block|}
comment|/* distance table */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|30
condition|;
name|i
operator|++
control|)
comment|/* make an incomplete code 						 * set */
name|l
index|[
name|i
index|]
operator|=
literal|5
expr_stmt|;
name|glbl
operator|->
name|gz_fixed_bd
operator|=
literal|5
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|=
name|huft_build
argument_list|(
name|glbl
argument_list|,
name|l
argument_list|,
literal|30
argument_list|,
literal|0
argument_list|,
name|cpdist
argument_list|,
name|cpdext
argument_list|,
operator|&
name|glbl
operator|->
name|gz_fixed_td
argument_list|,
operator|&
name|glbl
operator|->
name|gz_fixed_bd
argument_list|)
operator|)
operator|>
literal|1
condition|)
block|{
name|huft_free
argument_list|(
name|glbl
argument_list|,
name|glbl
operator|->
name|gz_fixed_tl
argument_list|)
expr_stmt|;
name|glbl
operator|->
name|gz_fixed_tl
operator|=
operator|(
expr|struct
name|huft
operator|*
operator|)
name|NULL
expr_stmt|;
return|return
name|i
return|;
block|}
block|}
comment|/* decompress until an end-of-block code */
return|return
name|inflate_codes
argument_list|(
name|glbl
argument_list|,
name|glbl
operator|->
name|gz_fixed_tl
argument_list|,
name|glbl
operator|->
name|gz_fixed_td
argument_list|,
name|glbl
operator|->
name|gz_fixed_bl
argument_list|,
name|glbl
operator|->
name|gz_fixed_bd
argument_list|)
operator|!=
literal|0
return|;
block|}
end_function

begin_comment
comment|/* decompress an inflated type 2 (dynamic Huffman codes) block. */
end_comment

begin_function
specifier|static
name|int
name|inflate_dynamic
parameter_list|(
name|glbl
parameter_list|)
name|struct
name|inflate
modifier|*
name|glbl
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
comment|/* temporary variables */
name|unsigned
name|j
decl_stmt|;
name|unsigned
name|l
decl_stmt|;
comment|/* last length */
name|unsigned
name|m
decl_stmt|;
comment|/* mask for bit lengths table */
name|unsigned
name|n
decl_stmt|;
comment|/* number of lengths to get */
name|struct
name|huft
modifier|*
name|tl
decl_stmt|;
comment|/* literal/length code table */
name|struct
name|huft
modifier|*
name|td
decl_stmt|;
comment|/* distance code table */
name|int
name|bl
decl_stmt|;
comment|/* lookup bits for tl */
name|int
name|bd
decl_stmt|;
comment|/* lookup bits for td */
name|unsigned
name|nb
decl_stmt|;
comment|/* number of bit length codes */
name|unsigned
name|nl
decl_stmt|;
comment|/* number of literal/length codes */
name|unsigned
name|nd
decl_stmt|;
comment|/* number of distance codes */
ifdef|#
directive|ifdef
name|PKZIP_BUG_WORKAROUND
name|unsigned
name|ll
index|[
literal|288
operator|+
literal|32
index|]
decl_stmt|;
comment|/* literal/length and distance code 					 * lengths */
else|#
directive|else
name|unsigned
name|ll
index|[
literal|286
operator|+
literal|30
index|]
decl_stmt|;
comment|/* literal/length and distance code 					 * lengths */
endif|#
directive|endif
specifier|register
name|ulg
name|b
decl_stmt|;
comment|/* bit buffer */
specifier|register
name|unsigned
name|k
decl_stmt|;
comment|/* number of bits in bit buffer */
comment|/* make local bit buffer */
name|b
operator|=
name|glbl
operator|->
name|gz_bb
expr_stmt|;
name|k
operator|=
name|glbl
operator|->
name|gz_bk
expr_stmt|;
comment|/* read in table lengths */
name|NEEDBITS
argument_list|(
argument|glbl
argument_list|,
literal|5
argument_list|)
name|nl
operator|=
literal|257
operator|+
operator|(
operator|(
name|unsigned
operator|)
name|b
operator|&
literal|0x1f
operator|)
expr_stmt|;
comment|/* number of 							 * literal/length codes */
name|DUMPBITS
argument_list|(
literal|5
argument_list|)
name|NEEDBITS
argument_list|(
argument|glbl
argument_list|,
literal|5
argument_list|)
name|nd
operator|=
literal|1
operator|+
operator|(
operator|(
name|unsigned
operator|)
name|b
operator|&
literal|0x1f
operator|)
expr_stmt|;
comment|/* number of distance codes */
name|DUMPBITS
argument_list|(
literal|5
argument_list|)
name|NEEDBITS
argument_list|(
argument|glbl
argument_list|,
literal|4
argument_list|)
name|nb
operator|=
literal|4
operator|+
operator|(
operator|(
name|unsigned
operator|)
name|b
operator|&
literal|0xf
operator|)
expr_stmt|;
comment|/* number of bit length codes */
name|DUMPBITS
argument_list|(
literal|4
argument_list|)
ifdef|#
directive|ifdef
name|PKZIP_BUG_WORKAROUND
if|if
condition|(
name|nl
operator|>
literal|288
operator|||
name|nd
operator|>
literal|32
condition|)
else|#
directive|else
if|if
condition|(
name|nl
operator|>
literal|286
operator|||
name|nd
operator|>
literal|30
condition|)
endif|#
directive|endif
return|return
literal|1
return|;
comment|/* bad lengths */
comment|/* read in bit-length-code lengths */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|nb
condition|;
name|j
operator|++
control|)
block|{
name|NEEDBITS
argument_list|(
argument|glbl
argument_list|,
literal|3
argument_list|)
name|ll
index|[
name|border
index|[
name|j
index|]
index|]
operator|=
operator|(
name|unsigned
operator|)
name|b
operator|&
literal|7
expr_stmt|;
name|DUMPBITS
argument_list|(
literal|3
argument_list|)
block|}
for|for
control|(
init|;
name|j
operator|<
literal|19
condition|;
name|j
operator|++
control|)
name|ll
index|[
name|border
index|[
name|j
index|]
index|]
operator|=
literal|0
expr_stmt|;
comment|/* build decoding table for trees--single level, 7 bit lookup */
name|bl
operator|=
literal|7
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|=
name|huft_build
argument_list|(
name|glbl
argument_list|,
name|ll
argument_list|,
literal|19
argument_list|,
literal|19
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|tl
argument_list|,
operator|&
name|bl
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|i
operator|==
literal|1
condition|)
name|huft_free
argument_list|(
name|glbl
argument_list|,
name|tl
argument_list|)
expr_stmt|;
return|return
name|i
return|;
comment|/* incomplete code set */
block|}
comment|/* read in literal and distance code lengths */
name|n
operator|=
name|nl
operator|+
name|nd
expr_stmt|;
name|m
operator|=
name|mask
index|[
name|bl
index|]
expr_stmt|;
name|i
operator|=
name|l
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|unsigned
operator|)
name|i
operator|<
name|n
condition|)
block|{
name|NEEDBITS
argument_list|(
argument|glbl
argument_list|,
argument|(unsigned) bl
argument_list|)
name|j
operator|=
operator|(
name|td
operator|=
name|tl
operator|+
operator|(
operator|(
name|unsigned
operator|)
name|b
operator|&
name|m
operator|)
operator|)
operator|->
name|b
expr_stmt|;
name|DUMPBITS
argument_list|(
argument|j
argument_list|)
name|j
operator|=
name|td
operator|->
name|v
operator|.
name|n
expr_stmt|;
if|if
condition|(
name|j
operator|<
literal|16
condition|)
comment|/* length of code in bits (0..15) */
name|ll
index|[
name|i
operator|++
index|]
operator|=
name|l
operator|=
name|j
expr_stmt|;
comment|/* save last length in l */
elseif|else
if|if
condition|(
name|j
operator|==
literal|16
condition|)
block|{
comment|/* repeat last length 3 to 6 times */
name|NEEDBITS
argument_list|(
argument|glbl
argument_list|,
literal|2
argument_list|)
name|j
operator|=
literal|3
operator|+
operator|(
operator|(
name|unsigned
operator|)
name|b
operator|&
literal|3
operator|)
expr_stmt|;
name|DUMPBITS
argument_list|(
literal|2
argument_list|)
if|if
condition|(
operator|(
name|unsigned
operator|)
name|i
operator|+
name|j
operator|>
name|n
condition|)
return|return
literal|1
return|;
while|while
condition|(
name|j
operator|--
condition|)
name|ll
index|[
name|i
operator|++
index|]
operator|=
name|l
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|j
operator|==
literal|17
condition|)
block|{
comment|/* 3 to 10 zero length codes */
name|NEEDBITS
argument_list|(
argument|glbl
argument_list|,
literal|3
argument_list|)
name|j
operator|=
literal|3
operator|+
operator|(
operator|(
name|unsigned
operator|)
name|b
operator|&
literal|7
operator|)
expr_stmt|;
name|DUMPBITS
argument_list|(
literal|3
argument_list|)
if|if
condition|(
operator|(
name|unsigned
operator|)
name|i
operator|+
name|j
operator|>
name|n
condition|)
return|return
literal|1
return|;
while|while
condition|(
name|j
operator|--
condition|)
name|ll
index|[
name|i
operator|++
index|]
operator|=
literal|0
expr_stmt|;
name|l
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* j == 18: 11 to 138 zero length codes */
name|NEEDBITS
argument_list|(
argument|glbl
argument_list|,
literal|7
argument_list|)
name|j
operator|=
literal|11
operator|+
operator|(
operator|(
name|unsigned
operator|)
name|b
operator|&
literal|0x7f
operator|)
expr_stmt|;
name|DUMPBITS
argument_list|(
literal|7
argument_list|)
if|if
condition|(
operator|(
name|unsigned
operator|)
name|i
operator|+
name|j
operator|>
name|n
condition|)
return|return
literal|1
return|;
while|while
condition|(
name|j
operator|--
condition|)
name|ll
index|[
name|i
operator|++
index|]
operator|=
literal|0
expr_stmt|;
name|l
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* free decoding table for trees */
name|huft_free
argument_list|(
name|glbl
argument_list|,
name|tl
argument_list|)
expr_stmt|;
comment|/* restore the global bit buffer */
name|glbl
operator|->
name|gz_bb
operator|=
name|b
expr_stmt|;
name|glbl
operator|->
name|gz_bk
operator|=
name|k
expr_stmt|;
comment|/* build the decoding tables for literal/length and distance codes */
name|bl
operator|=
name|lbits
expr_stmt|;
name|i
operator|=
name|huft_build
argument_list|(
name|glbl
argument_list|,
name|ll
argument_list|,
name|nl
argument_list|,
literal|257
argument_list|,
name|cplens
argument_list|,
name|cplext
argument_list|,
operator|&
name|tl
argument_list|,
operator|&
name|bl
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|i
operator|==
literal|1
operator|&&
operator|!
name|qflag
condition|)
block|{
name|FPRINTF
argument_list|(
literal|"(incomplete l-tree)  "
argument_list|)
expr_stmt|;
name|huft_free
argument_list|(
name|glbl
argument_list|,
name|tl
argument_list|)
expr_stmt|;
block|}
return|return
name|i
return|;
comment|/* incomplete code set */
block|}
name|bd
operator|=
name|dbits
expr_stmt|;
name|i
operator|=
name|huft_build
argument_list|(
name|glbl
argument_list|,
name|ll
operator|+
name|nl
argument_list|,
name|nd
argument_list|,
literal|0
argument_list|,
name|cpdist
argument_list|,
name|cpdext
argument_list|,
operator|&
name|td
argument_list|,
operator|&
name|bd
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|i
operator|==
literal|1
operator|&&
operator|!
name|qflag
condition|)
block|{
name|FPRINTF
argument_list|(
literal|"(incomplete d-tree)  "
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PKZIP_BUG_WORKAROUND
name|i
operator|=
literal|0
expr_stmt|;
block|}
else|#
directive|else
name|huft_free
argument_list|(
name|glbl
argument_list|,
name|td
argument_list|)
expr_stmt|;
block|}
name|huft_free
argument_list|(
name|glbl
argument_list|,
name|tl
argument_list|)
expr_stmt|;
return|return
name|i
return|;
comment|/* incomplete code set */
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* decompress until an end-of-block code */
end_comment

begin_if
if|if
condition|(
name|inflate_codes
argument_list|(
name|glbl
argument_list|,
name|tl
argument_list|,
name|td
argument_list|,
name|bl
argument_list|,
name|bd
argument_list|)
condition|)
return|return
literal|1
return|;
end_if

begin_comment
comment|/* free the decoding tables, return */
end_comment

begin_expr_stmt
name|huft_free
argument_list|(
name|glbl
argument_list|,
name|tl
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|huft_free
argument_list|(
name|glbl
argument_list|,
name|td
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
literal|0
return|;
end_return

begin_comment
unit|}
comment|/* decompress an inflated block */
end_comment

begin_function
unit|static
name|int
name|inflate_block
parameter_list|(
name|glbl
parameter_list|,
name|e
parameter_list|)
name|struct
name|inflate
modifier|*
name|glbl
decl_stmt|;
name|int
modifier|*
name|e
decl_stmt|;
comment|/* last block flag */
block|{
name|unsigned
name|t
decl_stmt|;
comment|/* block type */
specifier|register
name|ulg
name|b
decl_stmt|;
comment|/* bit buffer */
specifier|register
name|unsigned
name|k
decl_stmt|;
comment|/* number of bits in bit buffer */
comment|/* make local bit buffer */
name|b
operator|=
name|glbl
operator|->
name|gz_bb
expr_stmt|;
name|k
operator|=
name|glbl
operator|->
name|gz_bk
expr_stmt|;
comment|/* read in last block bit */
name|NEEDBITS
argument_list|(
name|glbl
argument_list|,
literal|1
argument_list|)
operator|*
name|e
operator|=
operator|(
name|int
operator|)
name|b
operator|&
literal|1
expr_stmt|;
name|DUMPBITS
argument_list|(
literal|1
argument_list|)
comment|/* read in block type */
name|NEEDBITS
argument_list|(
argument|glbl
argument_list|,
literal|2
argument_list|)
name|t
operator|=
operator|(
name|unsigned
operator|)
name|b
operator|&
literal|3
expr_stmt|;
name|DUMPBITS
argument_list|(
literal|2
argument_list|)
comment|/* restore the global bit buffer */
name|glbl
operator|->
name|gz_bb
operator|=
name|b
expr_stmt|;
name|glbl
operator|->
name|gz_bk
operator|=
name|k
expr_stmt|;
comment|/* inflate that block type */
if|if
condition|(
name|t
operator|==
literal|2
condition|)
return|return
name|inflate_dynamic
argument_list|(
name|glbl
argument_list|)
return|;
if|if
condition|(
name|t
operator|==
literal|0
condition|)
return|return
name|inflate_stored
argument_list|(
name|glbl
argument_list|)
return|;
if|if
condition|(
name|t
operator|==
literal|1
condition|)
return|return
name|inflate_fixed
argument_list|(
name|glbl
argument_list|)
return|;
comment|/* bad block type */
return|return
literal|2
return|;
block|}
end_function

begin_comment
comment|/* decompress an inflated entry */
end_comment

begin_function
specifier|static
name|int
name|xinflate
parameter_list|(
name|glbl
parameter_list|)
name|struct
name|inflate
modifier|*
name|glbl
decl_stmt|;
block|{
name|int
name|e
decl_stmt|;
comment|/* last block flag */
name|int
name|r
decl_stmt|;
comment|/* result code */
name|unsigned
name|h
decl_stmt|;
comment|/* maximum struct huft's malloc'ed */
name|glbl
operator|->
name|gz_fixed_tl
operator|=
operator|(
expr|struct
name|huft
operator|*
operator|)
name|NULL
expr_stmt|;
comment|/* initialize window, bit buffer */
name|glbl
operator|->
name|gz_wp
operator|=
literal|0
expr_stmt|;
name|glbl
operator|->
name|gz_bk
operator|=
literal|0
expr_stmt|;
name|glbl
operator|->
name|gz_bb
operator|=
literal|0
expr_stmt|;
comment|/* decompress until the last block */
name|h
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|glbl
operator|->
name|gz_hufts
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|r
operator|=
name|inflate_block
argument_list|(
name|glbl
argument_list|,
operator|&
name|e
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|r
return|;
if|if
condition|(
name|glbl
operator|->
name|gz_hufts
operator|>
name|h
condition|)
name|h
operator|=
name|glbl
operator|->
name|gz_hufts
expr_stmt|;
block|}
do|while
condition|(
operator|!
name|e
condition|)
do|;
comment|/* flush out slide */
name|FLUSH
argument_list|(
name|glbl
argument_list|,
name|glbl
operator|->
name|gz_wp
argument_list|)
expr_stmt|;
comment|/* return success */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Nobody uses this - why not? */
end_comment

begin_function
name|int
name|inflate
parameter_list|(
name|glbl
parameter_list|)
name|struct
name|inflate
modifier|*
name|glbl
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
ifdef|#
directive|ifdef
name|KERNEL
name|u_char
modifier|*
name|p
init|=
name|NULL
decl_stmt|;
if|if
condition|(
operator|!
name|glbl
operator|->
name|gz_slide
condition|)
name|p
operator|=
name|glbl
operator|->
name|gz_slide
operator|=
name|malloc
argument_list|(
name|GZ_WSIZE
argument_list|,
name|M_GZIP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|glbl
operator|->
name|gz_slide
condition|)
ifdef|#
directive|ifdef
name|KERNEL
return|return
operator|(
name|ENOMEM
operator|)
return|;
else|#
directive|else
return|return
literal|3
return|;
comment|/* kzip expects 3 */
endif|#
directive|endif
name|i
operator|=
name|xinflate
argument_list|(
name|glbl
argument_list|)
expr_stmt|;
if|if
condition|(
name|glbl
operator|->
name|gz_fixed_td
operator|!=
operator|(
expr|struct
name|huft
operator|*
operator|)
name|NULL
condition|)
block|{
name|huft_free
argument_list|(
name|glbl
argument_list|,
name|glbl
operator|->
name|gz_fixed_td
argument_list|)
expr_stmt|;
name|glbl
operator|->
name|gz_fixed_td
operator|=
operator|(
expr|struct
name|huft
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|glbl
operator|->
name|gz_fixed_tl
operator|!=
operator|(
expr|struct
name|huft
operator|*
operator|)
name|NULL
condition|)
block|{
name|huft_free
argument_list|(
name|glbl
argument_list|,
name|glbl
operator|->
name|gz_fixed_tl
argument_list|)
expr_stmt|;
name|glbl
operator|->
name|gz_fixed_tl
operator|=
operator|(
expr|struct
name|huft
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|KERNEL
if|if
condition|(
name|p
operator|==
name|glbl
operator|->
name|gz_slide
condition|)
block|{
name|free
argument_list|(
name|glbl
operator|->
name|gz_slide
argument_list|,
name|M_GZIP
argument_list|)
expr_stmt|;
name|glbl
operator|->
name|gz_slide
operator|=
name|NULL
expr_stmt|;
block|}
endif|#
directive|endif
return|return
name|i
return|;
block|}
end_function

begin_comment
comment|/* ----------------------- END INFLATE.C */
end_comment

end_unit

