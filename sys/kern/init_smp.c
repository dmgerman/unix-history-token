begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1996, Peter Wemm<peter@freebsd.org>  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHORS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $Id: init_smp.c,v 1.12 1997/07/21 17:03:22 fsmp Exp $  */
end_comment

begin_include
include|#
directive|include
file|"opt_smp.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/filedesc.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/resourcevar.h>
end_include

begin_include
include|#
directive|include
file|<sys/signalvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/vnode.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysent.h>
end_include

begin_include
include|#
directive|include
file|<sys/reboot.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysproto.h>
end_include

begin_include
include|#
directive|include
file|<sys/vmmeter.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<machine/cpu.h>
end_include

begin_include
include|#
directive|include
file|<machine/smp.h>
end_include

begin_include
include|#
directive|include
file|<machine/smptests.h>
end_include

begin_comment
comment|/** IGNORE_IDLEPROCS, TEST_TEST1 */
end_comment

begin_include
include|#
directive|include
file|<machine/specialreg.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_param.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_prot.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_map.h>
end_include

begin_include
include|#
directive|include
file|<sys/user.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|TEST_TEST1
argument_list|)
end_if

begin_function_decl
name|void
name|ipi_test1
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/** TEST_TEST1 */
end_comment

begin_decl_stmt
name|int
name|smp_active
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* are the APs allowed to run? */
end_comment

begin_decl_stmt
specifier|static
name|int
name|sysctl_smp_active
name|SYSCTL_HANDLER_ARGS
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
name|int
name|new_val
decl_stmt|;
name|error
operator|=
name|SYSCTL_OUT
argument_list|(
name|req
argument_list|,
operator|&
name|smp_active
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
operator|!
name|req
operator|->
name|newptr
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|error
operator|=
name|SYSCTL_IN
argument_list|(
name|req
argument_list|,
operator|&
name|new_val
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|new_val
operator|<
literal|1
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
if|if
condition|(
name|new_val
operator|>
name|mp_ncpus
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|smp_active
operator|=
name|new_val
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_decl_stmt

begin_expr_stmt
name|SYSCTL_PROC
argument_list|(
name|_kern
argument_list|,
name|OID_AUTO
argument_list|,
name|smp_active
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|&
name|sysctl_smp_active
argument_list|,
literal|"I"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|smp_cpus
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* how many cpu's running */
end_comment

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_kern
argument_list|,
name|OID_AUTO
argument_list|,
name|smp_cpus
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|smp_cpus
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|idle_debug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_kern
argument_list|,
name|OID_AUTO
argument_list|,
name|idle_debug
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|idle_debug
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|invltlb_ok
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* throttle smp_invltlb() till safe */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|IGNORE_IDLEPROCS
argument_list|)
end_if

begin_decl_stmt
name|int
name|ignore_idleprocs
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
name|int
name|ignore_idleprocs
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_kern
argument_list|,
name|OID_AUTO
argument_list|,
name|ignore_idleprocs
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|ignore_idleprocs
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|void
name|smp_kickoff
name|__P
argument_list|(
operator|(
name|void
operator|*
name|dummy
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_macro
name|SYSINIT
argument_list|(
argument|smpkick
argument_list|,
argument|SI_SUB_SMP
argument_list|,
argument|SI_ORDER_FIRST
argument_list|,
argument|smp_kickoff
argument_list|,
argument|NULL
argument_list|)
end_macro

begin_decl_stmt
specifier|static
name|void
name|smp_idleloop
name|__P
argument_list|(
operator|(
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|secondary_main
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|idle_loops
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|boot_unlock
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|proc
modifier|*
name|SMPidleproc
index|[
name|NCPU
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|cpu_starting
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|smp_kickoff
parameter_list|(
name|dummy
parameter_list|)
name|void
modifier|*
name|dummy
decl_stmt|;
block|{
name|int
name|rval
index|[
literal|2
index|]
decl_stmt|;
comment|/* return from fork */
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* 	 * Create the appropriate number of cpu-idle-eaters 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|mp_ncpus
condition|;
name|i
operator|++
control|)
block|{
comment|/* kernel thread*/
if|if
condition|(
name|fork
argument_list|(
operator|&
name|proc0
argument_list|,
name|NULL
argument_list|,
name|rval
argument_list|)
condition|)
name|panic
argument_list|(
literal|"cannot fork idle process"
argument_list|)
expr_stmt|;
name|p
operator|=
name|pfind
argument_list|(
name|rval
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|cpu_set_fork_handler
argument_list|(
name|p
argument_list|,
name|smp_idleloop
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|SMPidleproc
index|[
name|i
index|]
operator|=
name|p
expr_stmt|;
name|p
operator|->
name|p_flag
operator||=
name|P_INMEM
operator||
name|P_SYSTEM
operator||
name|P_IDLEPROC
expr_stmt|;
name|sprintf
argument_list|(
name|p
operator|->
name|p_comm
argument_list|,
literal|"cpuidle%d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* 		 * PRIO_IDLE is the last scheduled of the three 		 * classes and we choose the lowest priority possible 		 * for there. 		 */
name|p
operator|->
name|p_rtprio
operator|.
name|type
operator|=
name|RTP_PRIO_IDLE
expr_stmt|;
name|p
operator|->
name|p_rtprio
operator|.
name|prio
operator|=
name|RTP_PRIO_MAX
expr_stmt|;
block|}
block|}
end_function

begin_define
define|#
directive|define
name|MSG_CPU_MADEIT
define|\
value|printf("SMP: TADA! CPU #%d made it into the scheduler!.\n", \ 	       cpuid)
end_define

begin_define
define|#
directive|define
name|MSG_NEXT_CPU
define|\
value|printf("SMP: %d of %d CPU's online. Unlocking next CPU..\n", \ 	       smp_cpus, mp_ncpus)
end_define

begin_define
define|#
directive|define
name|MSG_FINAL_CPU
define|\
value|printf("SMP: All %d CPU's are online!\n", \ 	       smp_cpus)
end_define

begin_define
define|#
directive|define
name|MSG_TOOMANY_CPU
define|\
value|printf("SMP: Hey! Too many cpu's started, %d of %d running!\n", \ 	       smp_cpus, mp_ncpus)
end_define

begin_comment
comment|/*  * This is run by the secondary processor to kick things off.  * It basically drops into the switch routine to pick the first  * available process to run, which is probably an idle process.  */
end_comment

begin_function
name|void
name|secondary_main
parameter_list|()
block|{
name|u_int
name|temp
decl_stmt|;
name|get_mplock
argument_list|()
expr_stmt|;
comment|/* 	 * Record our ID so we know when we've released the mp_stk. 	 * We must remain single threaded through this. 	 */
name|cpu_starting
operator|=
name|cpuid
expr_stmt|;
name|smp_cpus
operator|++
expr_stmt|;
comment|/* Build our map of 'other' CPUs. */
name|other_cpus
operator|=
name|all_cpus
operator|&
operator|~
operator|(
literal|1
operator|<<
name|cpuid
operator|)
expr_stmt|;
name|printf
argument_list|(
literal|"SMP: AP CPU #%d LAUNCHED!!  Starting Scheduling...\n"
argument_list|,
name|cpuid
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|TEST_TEST1
argument_list|)
comment|/* XXX this would be dangerous for> 2 CPUs! */
if|if
condition|(
name|cpuid
operator|==
name|IPI_TARGET_TEST1
condition|)
block|{
name|lapic
operator|.
name|tpr
operator|=
literal|0xff
expr_stmt|;
name|ipi_test1
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
comment|/** TEST_TEST1 */
comment|/* Setup the FPU. */
name|load_cr0
argument_list|(
operator|(
name|rcr0
argument_list|()
operator|&
operator|~
name|CR0_EM
operator|)
operator||
name|CR0_MP
operator||
name|CR0_NE
operator||
name|CR0_TS
argument_list|)
expr_stmt|;
name|curproc
operator|=
name|NULL
expr_stmt|;
comment|/* ensure no context to save */
name|cpu_switch
argument_list|(
name|curproc
argument_list|)
expr_stmt|;
comment|/* start first process */
name|panic
argument_list|(
literal|"switch returned!"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * The main program loop for the idle process  */
end_comment

begin_function
specifier|static
name|void
name|smp_idleloop
parameter_list|(
name|dummy
parameter_list|)
name|void
modifier|*
name|dummy
decl_stmt|;
block|{
name|int
name|dcnt
init|=
literal|0
decl_stmt|;
name|int
name|apic_id
decl_stmt|;
comment|/* 	 * This code is executed only on startup of the idleprocs 	 * The fact that this is executed is an indication that the 	 * idle procs are online and it's safe to kick off the first 	 * AP cpu. 	 */
if|if
condition|(
operator|++
name|idle_loops
operator|==
name|mp_ncpus
condition|)
block|{
name|printf
argument_list|(
literal|"SMP: All idle procs online.\n"
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|NO_AUTOSTART
name|printf
argument_list|(
literal|"SMP: *** AUTO *** starting 1st AP!\n"
argument_list|)
expr_stmt|;
name|smp_cpus
operator|=
literal|1
expr_stmt|;
name|smp_active
operator|=
name|mp_ncpus
expr_stmt|;
comment|/* XXX */
name|boot_unlock
argument_list|()
expr_stmt|;
else|#
directive|else
name|printf
argument_list|(
literal|"You can now activate SMP processing, use: sysctl -w kern.smp_active=%d\n"
argument_list|,
name|mp_ncpus
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|spl0
argument_list|()
expr_stmt|;
name|rel_mplock
argument_list|()
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
comment|/* 		 * make the optimiser assume nothing about the 		 * which*qs variables 		 */
asm|__asm __volatile("" : : : "memory");
ifdef|#
directive|ifdef
name|NO_AUTOSTART
if|if
condition|(
name|smp_cpus
operator|==
literal|0
operator|&&
name|smp_active
operator|!=
literal|0
condition|)
block|{
name|get_mplock
argument_list|()
expr_stmt|;
name|printf
argument_list|(
literal|"SMP: Starting 1st AP!\n"
argument_list|)
expr_stmt|;
name|smp_cpus
operator|=
literal|1
expr_stmt|;
name|smp_active
operator|=
name|mp_ncpus
expr_stmt|;
comment|/* XXX */
name|boot_unlock
argument_list|()
expr_stmt|;
name|rel_mplock
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* 		 * If smp_active is set to (say) 1, we want cpu id's 		 * 1,2,etc to freeze here. 		 */
if|if
condition|(
name|smp_active
operator|&&
name|smp_active
operator|<=
name|cpuid
condition|)
block|{
name|get_mplock
argument_list|()
expr_stmt|;
name|printf
argument_list|(
literal|"SMP: cpu#%d freezing\n"
argument_list|,
name|cpuid
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|smp_active
argument_list|)
expr_stmt|;
name|rel_mplock
argument_list|()
expr_stmt|;
while|while
condition|(
name|smp_active
operator|<=
name|cpuid
condition|)
block|{
asm|__asm __volatile("" : : : "memory");
block|}
name|get_mplock
argument_list|()
expr_stmt|;
name|printf
argument_list|(
literal|"SMP: cpu#%d waking up!\n"
argument_list|,
name|cpuid
argument_list|)
expr_stmt|;
name|rel_mplock
argument_list|()
expr_stmt|;
block|}
comment|/* XXX DEBUG */
name|apic_id
operator|=
operator|(
name|apic_id_to_logical
index|[
operator|(
name|lapic
operator|.
name|id
operator|&
literal|0x0f000000
operator|)
operator|>>
literal|24
index|]
operator|)
expr_stmt|;
if|if
condition|(
name|cpuid
operator|!=
name|apic_id
condition|)
block|{
name|printf
argument_list|(
literal|"SMP: cpuid = %d\n"
argument_list|,
name|cpuid
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"SMP: apic_id = %d\n"
argument_list|,
name|apic_id
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"PTD[MPPTDI] = %08x\n"
argument_list|,
name|PTD
index|[
name|MPPTDI
index|]
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"cpuid mismatch! boom!!"
argument_list|)
expr_stmt|;
block|}
comment|/* XXX END DEBUG */
if|if
condition|(
name|whichqs
operator|||
name|whichrtqs
operator|||
operator|(
operator|!
name|ignore_idleprocs
operator|&&
name|whichidqs
operator|)
condition|)
block|{
comment|/* grab lock for kernel "entry" */
name|get_mplock
argument_list|()
expr_stmt|;
comment|/* We need to retest due to the spin lock */
asm|__asm __volatile("" : : : "memory");
if|if
condition|(
name|whichqs
operator|||
name|whichrtqs
operator|||
operator|(
operator|!
name|ignore_idleprocs
operator|&&
name|whichidqs
operator|)
condition|)
block|{
name|splhigh
argument_list|()
expr_stmt|;
if|if
condition|(
name|curproc
condition|)
name|setrunqueue
argument_list|(
name|curproc
argument_list|)
expr_stmt|;
name|cnt
operator|.
name|v_swtch
operator|++
expr_stmt|;
name|cpu_switch
argument_list|(
name|curproc
argument_list|)
expr_stmt|;
name|microtime
argument_list|(
operator|&
name|runtime
argument_list|)
expr_stmt|;
if|if
condition|(
name|cpu_starting
operator|!=
operator|-
literal|1
operator|&&
name|cpu_starting
operator|==
name|cpuid
condition|)
block|{
comment|/* 					 * TADA! we have arrived! unlock the 					 * next cpu now that we have released 					 * the single mp_stk. 					 */
name|MSG_CPU_MADEIT
expr_stmt|;
name|cpu_starting
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* Init local apic for irq's */
name|apic_initialize
argument_list|()
expr_stmt|;
if|if
condition|(
name|smp_cpus
operator|<
name|mp_ncpus
condition|)
block|{
name|MSG_NEXT_CPU
expr_stmt|;
name|boot_unlock
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|smp_cpus
operator|>
name|mp_ncpus
condition|)
block|{
name|MSG_TOOMANY_CPU
expr_stmt|;
name|panic
argument_list|(
literal|"too many cpus"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|MSG_FINAL_CPU
expr_stmt|;
comment|/* 						 * It's safe to send IPI's now 						 * that all CPUs are online. 						 */
name|invltlb_ok
operator|=
literal|1
expr_stmt|;
block|}
block|}
operator|(
name|void
operator|)
name|spl0
argument_list|()
expr_stmt|;
block|}
name|rel_mplock
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|dcnt
operator|++
expr_stmt|;
if|if
condition|(
name|idle_debug
operator|&&
operator|(
name|dcnt
operator|%
name|idle_debug
operator|)
operator|==
literal|0
condition|)
block|{
name|get_mplock
argument_list|()
expr_stmt|;
name|printf
argument_list|(
literal|"idleproc pid#%d on cpu#%d, lock %08x\n"
argument_list|,
name|curproc
operator|->
name|p_pid
argument_list|,
name|cpuid
argument_list|,
name|mp_lock
argument_list|)
expr_stmt|;
name|rel_mplock
argument_list|()
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

end_unit

