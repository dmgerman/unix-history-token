begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2004 The FreeBSD Project  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"opt_kdb.h"
end_include

begin_include
include|#
directive|include
file|"opt_stack.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kdb.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/pcpu.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/sbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/smp.h>
end_include

begin_include
include|#
directive|include
file|<sys/stack.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<machine/kdb.h>
end_include

begin_include
include|#
directive|include
file|<machine/pcb.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|SMP
end_ifdef

begin_include
include|#
directive|include
file|<machine/smp.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|int
name|kdb_active
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
modifier|*
name|kdb_jmpbufp
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|kdb_dbbe
modifier|*
name|kdb_dbbe
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|pcb
name|kdb_pcb
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|pcb
modifier|*
name|kdb_thrctx
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|thread
modifier|*
name|kdb_thread
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|trapframe
modifier|*
name|kdb_frame
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|BREAK_TO_DEBUGGER
end_ifdef

begin_define
define|#
directive|define
name|KDB_BREAK_TO_DEBUGGER
value|1
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|KDB_BREAK_TO_DEBUGGER
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|ALT_BREAK_TO_DEBUGGER
end_ifdef

begin_define
define|#
directive|define
name|KDB_ALT_BREAK_TO_DEBUGGER
value|1
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|KDB_ALT_BREAK_TO_DEBUGGER
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|int
name|kdb_break_to_debugger
init|=
name|KDB_BREAK_TO_DEBUGGER
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|kdb_alt_break_to_debugger
init|=
name|KDB_ALT_BREAK_TO_DEBUGGER
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|KDB_BACKEND
argument_list|(
name|null
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SET_DECLARE
argument_list|(
name|kdb_dbbe_set
argument_list|,
expr|struct
name|kdb_dbbe
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function_decl
specifier|static
name|int
name|kdb_sysctl_available
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|kdb_sysctl_current
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|kdb_sysctl_enter
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|kdb_sysctl_panic
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|kdb_sysctl_trap
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|kdb_sysctl_trap_code
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_expr_stmt
specifier|static
name|SYSCTL_NODE
argument_list|(
name|_debug
argument_list|,
name|OID_AUTO
argument_list|,
name|kdb
argument_list|,
name|CTLFLAG_RW
argument_list|,
name|NULL
argument_list|,
literal|"KDB nodes"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_PROC
argument_list|(
name|_debug_kdb
argument_list|,
name|OID_AUTO
argument_list|,
name|available
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RD
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|kdb_sysctl_available
argument_list|,
literal|"A"
argument_list|,
literal|"list of available KDB backends"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_PROC
argument_list|(
name|_debug_kdb
argument_list|,
name|OID_AUTO
argument_list|,
name|current
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RW
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|kdb_sysctl_current
argument_list|,
literal|"A"
argument_list|,
literal|"currently selected KDB backend"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_PROC
argument_list|(
name|_debug_kdb
argument_list|,
name|OID_AUTO
argument_list|,
name|enter
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
operator||
name|CTLFLAG_SECURE
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|kdb_sysctl_enter
argument_list|,
literal|"I"
argument_list|,
literal|"set to enter the debugger"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_PROC
argument_list|(
name|_debug_kdb
argument_list|,
name|OID_AUTO
argument_list|,
name|panic
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
operator||
name|CTLFLAG_SECURE
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|kdb_sysctl_panic
argument_list|,
literal|"I"
argument_list|,
literal|"set to panic the kernel"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_PROC
argument_list|(
name|_debug_kdb
argument_list|,
name|OID_AUTO
argument_list|,
name|trap
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
operator||
name|CTLFLAG_SECURE
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|kdb_sysctl_trap
argument_list|,
literal|"I"
argument_list|,
literal|"set to cause a page fault via data access"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_PROC
argument_list|(
name|_debug_kdb
argument_list|,
name|OID_AUTO
argument_list|,
name|trap_code
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
operator||
name|CTLFLAG_SECURE
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|kdb_sysctl_trap_code
argument_list|,
literal|"I"
argument_list|,
literal|"set to cause a page fault via code access"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_debug_kdb
argument_list|,
name|OID_AUTO
argument_list|,
name|break_to_debugger
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
operator||
name|CTLFLAG_TUN
operator||
name|CTLFLAG_SECURE
argument_list|,
operator|&
name|kdb_break_to_debugger
argument_list|,
literal|0
argument_list|,
literal|"Enable break to debugger"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"debug.kdb.break_to_debugger"
argument_list|,
operator|&
name|kdb_break_to_debugger
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_debug_kdb
argument_list|,
name|OID_AUTO
argument_list|,
name|alt_break_to_debugger
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
operator||
name|CTLFLAG_TUN
operator||
name|CTLFLAG_SECURE
argument_list|,
operator|&
name|kdb_alt_break_to_debugger
argument_list|,
literal|0
argument_list|,
literal|"Enable alternative break to debugger"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"debug.kdb.alt_break_to_debugger"
argument_list|,
operator|&
name|kdb_alt_break_to_debugger
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Flag to indicate to debuggers why the debugger was entered.  */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
specifier|volatile
name|kdb_why
init|=
name|KDB_WHY_UNSET
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|kdb_sysctl_available
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|kdb_dbbe
modifier|*
modifier|*
name|iter
decl_stmt|;
name|struct
name|sbuf
name|sbuf
decl_stmt|;
name|int
name|error
decl_stmt|;
name|sbuf_new_for_sysctl
argument_list|(
operator|&
name|sbuf
argument_list|,
name|NULL
argument_list|,
literal|64
argument_list|,
name|req
argument_list|)
expr_stmt|;
name|SET_FOREACH
argument_list|(
argument|iter
argument_list|,
argument|kdb_dbbe_set
argument_list|)
block|{
if|if
condition|(
operator|(
operator|*
name|iter
operator|)
operator|->
name|dbbe_active
operator|==
literal|0
condition|)
name|sbuf_printf
argument_list|(
operator|&
name|sbuf
argument_list|,
literal|"%s "
argument_list|,
operator|(
operator|*
name|iter
operator|)
operator|->
name|dbbe_name
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
name|sbuf_finish
argument_list|(
operator|&
name|sbuf
argument_list|)
expr_stmt|;
name|sbuf_delete
argument_list|(
operator|&
name|sbuf
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|kdb_sysctl_current
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|char
name|buf
index|[
literal|16
index|]
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|kdb_dbbe
operator|!=
name|NULL
condition|)
name|strlcpy
argument_list|(
name|buf
argument_list|,
name|kdb_dbbe
operator|->
name|dbbe_name
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
else|else
operator|*
name|buf
operator|=
literal|'\0'
expr_stmt|;
name|error
operator|=
name|sysctl_handle_string
argument_list|(
name|oidp
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
operator|||
name|req
operator|->
name|newptr
operator|==
name|NULL
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|kdb_active
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
return|return
operator|(
name|kdb_dbbe_select
argument_list|(
name|buf
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|kdb_sysctl_enter
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|int
name|error
decl_stmt|,
name|i
decl_stmt|;
name|error
operator|=
name|sysctl_wire_old_buffer
argument_list|(
name|req
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|i
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|i
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|!=
literal|0
operator|||
name|req
operator|->
name|newptr
operator|==
name|NULL
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|kdb_active
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
name|kdb_enter
argument_list|(
name|KDB_WHY_SYSCTL
argument_list|,
literal|"sysctl debug.kdb.enter"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|kdb_sysctl_panic
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|int
name|error
decl_stmt|,
name|i
decl_stmt|;
name|error
operator|=
name|sysctl_wire_old_buffer
argument_list|(
name|req
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|i
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|i
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|!=
literal|0
operator|||
name|req
operator|->
name|newptr
operator|==
name|NULL
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|panic
argument_list|(
literal|"kdb_sysctl_panic"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|kdb_sysctl_trap
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|int
name|error
decl_stmt|,
name|i
decl_stmt|;
name|int
modifier|*
name|addr
init|=
operator|(
name|int
operator|*
operator|)
literal|0x10
decl_stmt|;
name|error
operator|=
name|sysctl_wire_old_buffer
argument_list|(
name|req
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|i
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|i
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|!=
literal|0
operator|||
name|req
operator|->
name|newptr
operator|==
name|NULL
condition|)
return|return
operator|(
name|error
operator|)
return|;
return|return
operator|(
operator|*
name|addr
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|kdb_sysctl_trap_code
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|int
name|error
decl_stmt|,
name|i
decl_stmt|;
name|void
function_decl|(
modifier|*
name|fp
function_decl|)
parameter_list|(
name|u_int
parameter_list|,
name|u_int
parameter_list|,
name|u_int
parameter_list|)
init|=
operator|(
name|void
operator|*
operator|)
literal|0xdeadc0de
function_decl|;
name|error
operator|=
name|sysctl_wire_old_buffer
argument_list|(
name|req
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|i
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|i
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|!=
literal|0
operator|||
name|req
operator|->
name|newptr
operator|==
name|NULL
condition|)
return|return
operator|(
name|error
operator|)
return|;
call|(
modifier|*
name|fp
call|)
argument_list|(
literal|0x11111111
argument_list|,
literal|0x22222222
argument_list|,
literal|0x33333333
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|kdb_panic
parameter_list|(
specifier|const
name|char
modifier|*
name|msg
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|SMP
name|cpuset_t
name|other_cpus
decl_stmt|;
name|other_cpus
operator|=
name|all_cpus
expr_stmt|;
name|CPU_CLR
argument_list|(
name|PCPU_GET
argument_list|(
name|cpuid
argument_list|)
argument_list|,
operator|&
name|other_cpus
argument_list|)
expr_stmt|;
name|stop_cpus_hard
argument_list|(
name|other_cpus
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|printf
argument_list|(
literal|"KDB: panic\n"
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"%s"
argument_list|,
name|msg
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|kdb_reboot
parameter_list|(
name|void
parameter_list|)
block|{
name|printf
argument_list|(
literal|"KDB: reboot requested\n"
argument_list|)
expr_stmt|;
name|shutdown_nice
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Solaris implements a new BREAK which is initiated by a character sequence  * CR ~ ^b which is similar to a familiar pattern used on Sun servers by the  * Remote Console.  *  * Note that this function may be called from almost anywhere, with interrupts  * disabled and with unknown locks held, so it must not access data other than  * its arguments.  Its up to the caller to ensure that the state variable is  * consistent.  */
end_comment

begin_define
define|#
directive|define
name|KEY_CR
value|13
end_define

begin_comment
comment|/* CR '\r' */
end_comment

begin_define
define|#
directive|define
name|KEY_TILDE
value|126
end_define

begin_comment
comment|/* ~ */
end_comment

begin_define
define|#
directive|define
name|KEY_CRTLB
value|2
end_define

begin_comment
comment|/* ^B */
end_comment

begin_define
define|#
directive|define
name|KEY_CRTLP
value|16
end_define

begin_comment
comment|/* ^P */
end_comment

begin_define
define|#
directive|define
name|KEY_CRTLR
value|18
end_define

begin_comment
comment|/* ^R */
end_comment

begin_comment
comment|/* States of th KDB "alternate break sequence" detecting state machine. */
end_comment

begin_enum
enum|enum
block|{
name|KDB_ALT_BREAK_SEEN_NONE
block|,
name|KDB_ALT_BREAK_SEEN_CR
block|,
name|KDB_ALT_BREAK_SEEN_CR_TILDE
block|, }
enum|;
end_enum

begin_function
name|int
name|kdb_break
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
name|kdb_break_to_debugger
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|kdb_enter
argument_list|(
name|KDB_WHY_BREAK
argument_list|,
literal|"Break to debugger"
argument_list|)
expr_stmt|;
return|return
operator|(
name|KDB_REQ_DEBUGGER
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|kdb_alt_break_state
parameter_list|(
name|int
name|key
parameter_list|,
name|int
modifier|*
name|state
parameter_list|)
block|{
name|int
name|brk
decl_stmt|;
comment|/* All states transition to KDB_ALT_BREAK_SEEN_CR on a CR. */
if|if
condition|(
name|key
operator|==
name|KEY_CR
condition|)
block|{
operator|*
name|state
operator|=
name|KDB_ALT_BREAK_SEEN_CR
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|brk
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
operator|*
name|state
condition|)
block|{
case|case
name|KDB_ALT_BREAK_SEEN_CR
case|:
operator|*
name|state
operator|=
name|KDB_ALT_BREAK_SEEN_NONE
expr_stmt|;
if|if
condition|(
name|key
operator|==
name|KEY_TILDE
condition|)
operator|*
name|state
operator|=
name|KDB_ALT_BREAK_SEEN_CR_TILDE
expr_stmt|;
break|break;
case|case
name|KDB_ALT_BREAK_SEEN_CR_TILDE
case|:
operator|*
name|state
operator|=
name|KDB_ALT_BREAK_SEEN_NONE
expr_stmt|;
if|if
condition|(
name|key
operator|==
name|KEY_CRTLB
condition|)
name|brk
operator|=
name|KDB_REQ_DEBUGGER
expr_stmt|;
elseif|else
if|if
condition|(
name|key
operator|==
name|KEY_CRTLP
condition|)
name|brk
operator|=
name|KDB_REQ_PANIC
expr_stmt|;
elseif|else
if|if
condition|(
name|key
operator|==
name|KEY_CRTLR
condition|)
name|brk
operator|=
name|KDB_REQ_REBOOT
expr_stmt|;
break|break;
case|case
name|KDB_ALT_BREAK_SEEN_NONE
case|:
default|default:
operator|*
name|state
operator|=
name|KDB_ALT_BREAK_SEEN_NONE
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|brk
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|kdb_alt_break_internal
parameter_list|(
name|int
name|key
parameter_list|,
name|int
modifier|*
name|state
parameter_list|,
name|int
name|force_gdb
parameter_list|)
block|{
name|int
name|brk
decl_stmt|;
if|if
condition|(
operator|!
name|kdb_alt_break_to_debugger
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|brk
operator|=
name|kdb_alt_break_state
argument_list|(
name|key
argument_list|,
name|state
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|brk
condition|)
block|{
case|case
name|KDB_REQ_DEBUGGER
case|:
if|if
condition|(
name|force_gdb
condition|)
name|kdb_dbbe_select
argument_list|(
literal|"gdb"
argument_list|)
expr_stmt|;
name|kdb_enter
argument_list|(
name|KDB_WHY_BREAK
argument_list|,
literal|"Break to debugger"
argument_list|)
expr_stmt|;
break|break;
case|case
name|KDB_REQ_PANIC
case|:
if|if
condition|(
name|force_gdb
condition|)
name|kdb_dbbe_select
argument_list|(
literal|"gdb"
argument_list|)
expr_stmt|;
name|kdb_panic
argument_list|(
literal|"Panic sequence on console"
argument_list|)
expr_stmt|;
break|break;
case|case
name|KDB_REQ_REBOOT
case|:
name|kdb_reboot
argument_list|()
expr_stmt|;
break|break;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|kdb_alt_break
parameter_list|(
name|int
name|key
parameter_list|,
name|int
modifier|*
name|state
parameter_list|)
block|{
return|return
operator|(
name|kdb_alt_break_internal
argument_list|(
name|key
argument_list|,
name|state
argument_list|,
literal|0
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * This variation on kdb_alt_break() is used only by dcons, which has its own  * configuration flag to force GDB use regardless of the global KDB  * configuration.  */
end_comment

begin_function
name|int
name|kdb_alt_break_gdb
parameter_list|(
name|int
name|key
parameter_list|,
name|int
modifier|*
name|state
parameter_list|)
block|{
return|return
operator|(
name|kdb_alt_break_internal
argument_list|(
name|key
argument_list|,
name|state
argument_list|,
literal|1
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Print a backtrace of the calling thread. The backtrace is generated by  * the selected debugger, provided it supports backtraces. If no debugger  * is selected or the current debugger does not support backtraces, this  * function silently returns.  */
end_comment

begin_function
name|void
name|kdb_backtrace
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|kdb_dbbe
operator|!=
name|NULL
operator|&&
name|kdb_dbbe
operator|->
name|dbbe_trace
operator|!=
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"KDB: stack backtrace:\n"
argument_list|)
expr_stmt|;
name|kdb_dbbe
operator|->
name|dbbe_trace
argument_list|()
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|STACK
else|else
block|{
name|struct
name|stack
name|st
decl_stmt|;
name|printf
argument_list|(
literal|"KDB: stack backtrace:\n"
argument_list|)
expr_stmt|;
name|stack_save
argument_list|(
operator|&
name|st
argument_list|)
expr_stmt|;
name|stack_print_ddb
argument_list|(
operator|&
name|st
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * Set/change the current backend.  */
end_comment

begin_function
name|int
name|kdb_dbbe_select
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|kdb_dbbe
modifier|*
name|be
decl_stmt|,
modifier|*
modifier|*
name|iter
decl_stmt|;
name|SET_FOREACH
argument_list|(
argument|iter
argument_list|,
argument|kdb_dbbe_set
argument_list|)
block|{
name|be
operator|=
operator|*
name|iter
expr_stmt|;
if|if
condition|(
name|be
operator|->
name|dbbe_active
operator|==
literal|0
operator|&&
name|strcmp
argument_list|(
name|be
operator|->
name|dbbe_name
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
name|kdb_dbbe
operator|=
name|be
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Enter the currently selected debugger. If a message has been provided,  * it is printed first. If the debugger does not support the enter method,  * it is entered by using breakpoint(), which enters the debugger through  * kdb_trap().  The 'why' argument will contain a more mechanically usable  * string than 'msg', and is relied upon by DDB scripting to identify the  * reason for entering the debugger so that the right script can be run.  */
end_comment

begin_function
name|void
name|kdb_enter
parameter_list|(
specifier|const
name|char
modifier|*
name|why
parameter_list|,
specifier|const
name|char
modifier|*
name|msg
parameter_list|)
block|{
if|if
condition|(
name|kdb_dbbe
operator|!=
name|NULL
operator|&&
name|kdb_active
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|msg
operator|!=
name|NULL
condition|)
name|printf
argument_list|(
literal|"KDB: enter: %s\n"
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|kdb_why
operator|=
name|why
expr_stmt|;
name|breakpoint
argument_list|()
expr_stmt|;
name|kdb_why
operator|=
name|KDB_WHY_UNSET
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Initialize the kernel debugger interface.  */
end_comment

begin_function
name|void
name|kdb_init
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|kdb_dbbe
modifier|*
name|be
decl_stmt|,
modifier|*
modifier|*
name|iter
decl_stmt|;
name|int
name|cur_pri
decl_stmt|,
name|pri
decl_stmt|;
name|kdb_active
operator|=
literal|0
expr_stmt|;
name|kdb_dbbe
operator|=
name|NULL
expr_stmt|;
name|cur_pri
operator|=
operator|-
literal|1
expr_stmt|;
name|SET_FOREACH
argument_list|(
argument|iter
argument_list|,
argument|kdb_dbbe_set
argument_list|)
block|{
name|be
operator|=
operator|*
name|iter
expr_stmt|;
name|pri
operator|=
operator|(
name|be
operator|->
name|dbbe_init
operator|!=
name|NULL
operator|)
condition|?
name|be
operator|->
name|dbbe_init
argument_list|()
else|:
operator|-
literal|1
expr_stmt|;
name|be
operator|->
name|dbbe_active
operator|=
operator|(
name|pri
operator|>=
literal|0
operator|)
condition|?
literal|0
else|:
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|pri
operator|>
name|cur_pri
condition|)
block|{
name|cur_pri
operator|=
name|pri
expr_stmt|;
name|kdb_dbbe
operator|=
name|be
expr_stmt|;
block|}
block|}
if|if
condition|(
name|kdb_dbbe
operator|!=
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"KDB: debugger backends:"
argument_list|)
expr_stmt|;
name|SET_FOREACH
argument_list|(
argument|iter
argument_list|,
argument|kdb_dbbe_set
argument_list|)
block|{
name|be
operator|=
operator|*
name|iter
expr_stmt|;
if|if
condition|(
name|be
operator|->
name|dbbe_active
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|" %s"
argument_list|,
name|be
operator|->
name|dbbe_name
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"KDB: current backend: %s\n"
argument_list|,
name|kdb_dbbe
operator|->
name|dbbe_name
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Handle contexts.  */
end_comment

begin_function
name|void
modifier|*
name|kdb_jmpbuf
parameter_list|(
name|jmp_buf
name|new
parameter_list|)
block|{
name|void
modifier|*
name|old
decl_stmt|;
name|old
operator|=
name|kdb_jmpbufp
expr_stmt|;
name|kdb_jmpbufp
operator|=
name|new
expr_stmt|;
return|return
operator|(
name|old
operator|)
return|;
block|}
end_function

begin_function
name|void
name|kdb_reenter
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
name|kdb_active
operator|||
name|kdb_jmpbufp
operator|==
name|NULL
condition|)
return|return;
name|longjmp
argument_list|(
name|kdb_jmpbufp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
end_function

begin_comment
comment|/*  * Thread related support functions.  */
end_comment

begin_function
name|struct
name|pcb
modifier|*
name|kdb_thr_ctx
parameter_list|(
name|struct
name|thread
modifier|*
name|thr
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|SMP
argument_list|)
operator|&&
name|defined
argument_list|(
name|KDB_STOPPEDPCB
argument_list|)
name|struct
name|pcpu
modifier|*
name|pc
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|thr
operator|==
name|curthread
condition|)
return|return
operator|(
operator|&
name|kdb_pcb
operator|)
return|;
if|#
directive|if
name|defined
argument_list|(
name|SMP
argument_list|)
operator|&&
name|defined
argument_list|(
name|KDB_STOPPEDPCB
argument_list|)
name|STAILQ_FOREACH
argument_list|(
argument|pc
argument_list|,
argument|&cpuhead
argument_list|,
argument|pc_allcpu
argument_list|)
block|{
if|if
condition|(
name|pc
operator|->
name|pc_curthread
operator|==
name|thr
operator|&&
name|CPU_ISSET
argument_list|(
name|pc
operator|->
name|pc_cpuid
argument_list|,
operator|&
name|stopped_cpus
argument_list|)
condition|)
return|return
operator|(
name|KDB_STOPPEDPCB
argument_list|(
name|pc
argument_list|)
operator|)
return|;
block|}
endif|#
directive|endif
return|return
operator|(
name|thr
operator|->
name|td_pcb
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|thread
modifier|*
name|kdb_thr_first
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|struct
name|thread
modifier|*
name|thr
decl_stmt|;
name|p
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|allproc
argument_list|)
expr_stmt|;
while|while
condition|(
name|p
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|p_flag
operator|&
name|P_INMEM
condition|)
block|{
name|thr
operator|=
name|FIRST_THREAD_IN_PROC
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|thr
operator|!=
name|NULL
condition|)
return|return
operator|(
name|thr
operator|)
return|;
block|}
name|p
operator|=
name|LIST_NEXT
argument_list|(
name|p
argument_list|,
name|p_list
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|thread
modifier|*
name|kdb_thr_from_pid
parameter_list|(
name|pid_t
name|pid
parameter_list|)
block|{
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|allproc
argument_list|)
expr_stmt|;
while|while
condition|(
name|p
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|p_flag
operator|&
name|P_INMEM
operator|&&
name|p
operator|->
name|p_pid
operator|==
name|pid
condition|)
return|return
operator|(
name|FIRST_THREAD_IN_PROC
argument_list|(
name|p
argument_list|)
operator|)
return|;
name|p
operator|=
name|LIST_NEXT
argument_list|(
name|p
argument_list|,
name|p_list
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|thread
modifier|*
name|kdb_thr_lookup
parameter_list|(
name|lwpid_t
name|tid
parameter_list|)
block|{
name|struct
name|thread
modifier|*
name|thr
decl_stmt|;
name|thr
operator|=
name|kdb_thr_first
argument_list|()
expr_stmt|;
while|while
condition|(
name|thr
operator|!=
name|NULL
operator|&&
name|thr
operator|->
name|td_tid
operator|!=
name|tid
condition|)
name|thr
operator|=
name|kdb_thr_next
argument_list|(
name|thr
argument_list|)
expr_stmt|;
return|return
operator|(
name|thr
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|thread
modifier|*
name|kdb_thr_next
parameter_list|(
name|struct
name|thread
modifier|*
name|thr
parameter_list|)
block|{
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|thr
operator|->
name|td_proc
expr_stmt|;
name|thr
operator|=
name|TAILQ_NEXT
argument_list|(
name|thr
argument_list|,
name|td_plist
argument_list|)
expr_stmt|;
do|do
block|{
if|if
condition|(
name|thr
operator|!=
name|NULL
condition|)
return|return
operator|(
name|thr
operator|)
return|;
name|p
operator|=
name|LIST_NEXT
argument_list|(
name|p
argument_list|,
name|p_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
operator|&&
operator|(
name|p
operator|->
name|p_flag
operator|&
name|P_INMEM
operator|)
condition|)
name|thr
operator|=
name|FIRST_THREAD_IN_PROC
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|p
operator|!=
name|NULL
condition|)
do|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
name|int
name|kdb_thr_select
parameter_list|(
name|struct
name|thread
modifier|*
name|thr
parameter_list|)
block|{
if|if
condition|(
name|thr
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|kdb_thread
operator|=
name|thr
expr_stmt|;
name|kdb_thrctx
operator|=
name|kdb_thr_ctx
argument_list|(
name|thr
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Enter the debugger due to a trap.  */
end_comment

begin_function
name|int
name|kdb_trap
parameter_list|(
name|int
name|type
parameter_list|,
name|int
name|code
parameter_list|,
name|struct
name|trapframe
modifier|*
name|tf
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|SMP
name|cpuset_t
name|other_cpus
decl_stmt|;
endif|#
directive|endif
name|struct
name|kdb_dbbe
modifier|*
name|be
decl_stmt|;
name|register_t
name|intr
decl_stmt|;
name|int
name|handled
decl_stmt|;
name|be
operator|=
name|kdb_dbbe
expr_stmt|;
if|if
condition|(
name|be
operator|==
name|NULL
operator|||
name|be
operator|->
name|dbbe_trap
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* We reenter the debugger through kdb_reenter(). */
if|if
condition|(
name|kdb_active
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|intr
operator|=
name|intr_disable
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|SMP
name|other_cpus
operator|=
name|all_cpus
expr_stmt|;
name|CPU_CLR
argument_list|(
name|PCPU_GET
argument_list|(
name|cpuid
argument_list|)
argument_list|,
operator|&
name|other_cpus
argument_list|)
expr_stmt|;
name|stop_cpus_hard
argument_list|(
name|other_cpus
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|kdb_active
operator|++
expr_stmt|;
name|kdb_frame
operator|=
name|tf
expr_stmt|;
comment|/* Let MD code do its thing first... */
name|kdb_cpu_trap
argument_list|(
name|type
argument_list|,
name|code
argument_list|)
expr_stmt|;
name|makectx
argument_list|(
name|tf
argument_list|,
operator|&
name|kdb_pcb
argument_list|)
expr_stmt|;
name|kdb_thr_select
argument_list|(
name|curthread
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|handled
operator|=
name|be
operator|->
name|dbbe_trap
argument_list|(
name|type
argument_list|,
name|code
argument_list|)
expr_stmt|;
if|if
condition|(
name|be
operator|==
name|kdb_dbbe
condition|)
break|break;
name|be
operator|=
name|kdb_dbbe
expr_stmt|;
if|if
condition|(
name|be
operator|==
name|NULL
operator|||
name|be
operator|->
name|dbbe_trap
operator|==
name|NULL
condition|)
break|break;
name|printf
argument_list|(
literal|"Switching to %s back-end\n"
argument_list|,
name|be
operator|->
name|dbbe_name
argument_list|)
expr_stmt|;
block|}
name|kdb_active
operator|--
expr_stmt|;
ifdef|#
directive|ifdef
name|SMP
name|restart_cpus
argument_list|(
name|stopped_cpus
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|intr_restore
argument_list|(
name|intr
argument_list|)
expr_stmt|;
return|return
operator|(
name|handled
operator|)
return|;
block|}
end_function

end_unit

