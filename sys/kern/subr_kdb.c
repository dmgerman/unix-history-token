begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2004 The FreeBSD Project  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"opt_kdb.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kdb.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/pcpu.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/smp.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<machine/kdb.h>
end_include

begin_include
include|#
directive|include
file|<machine/pcb.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|KDB_STOP_NMI
end_ifdef

begin_include
include|#
directive|include
file|<machine/smp.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*   * KDB_STOP_NMI requires SMP to pick up the right dependencies  * (And isn't useful on UP anyway)   */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|KDB_STOP_NMI
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|SMP
argument_list|)
end_if

begin_error
error|#
directive|error
literal|"options KDB_STOP_NMI"
error|requires "options SMP"
end_error

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|int
name|kdb_active
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
modifier|*
name|kdb_jmpbufp
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|kdb_dbbe
modifier|*
name|kdb_dbbe
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|pcb
name|kdb_pcb
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|pcb
modifier|*
name|kdb_thrctx
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|thread
modifier|*
name|kdb_thread
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|trapframe
modifier|*
name|kdb_frame
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|KDB_BACKEND
argument_list|(
name|null
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SET_DECLARE
argument_list|(
name|kdb_dbbe_set
argument_list|,
expr|struct
name|kdb_dbbe
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function_decl
specifier|static
name|int
name|kdb_sysctl_available
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|kdb_sysctl_current
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|kdb_sysctl_enter
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_debug
argument_list|,
name|OID_AUTO
argument_list|,
name|kdb
argument_list|,
name|CTLFLAG_RW
argument_list|,
name|NULL
argument_list|,
literal|"KDB nodes"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_PROC
argument_list|(
name|_debug_kdb
argument_list|,
name|OID_AUTO
argument_list|,
name|available
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RD
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|kdb_sysctl_available
argument_list|,
literal|"A"
argument_list|,
literal|"list of available KDB backends"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_PROC
argument_list|(
name|_debug_kdb
argument_list|,
name|OID_AUTO
argument_list|,
name|current
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|kdb_sysctl_current
argument_list|,
literal|"A"
argument_list|,
literal|"currently selected KDB backend"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_PROC
argument_list|(
name|_debug_kdb
argument_list|,
name|OID_AUTO
argument_list|,
name|enter
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|kdb_sysctl_enter
argument_list|,
literal|"I"
argument_list|,
literal|"set to enter the debugger"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Flag indicating whether or not to IPI the other CPUs to stop them on  * entering the debugger.  Sometimes, this will result in a deadlock as  * stop_cpus() waits for the other cpus to stop, so we allow it to be  * disabled.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|SMP
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|kdb_stop_cpus
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_debug_kdb
argument_list|,
name|OID_AUTO
argument_list|,
name|stop_cpus
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
operator|&
name|kdb_stop_cpus
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"debug.kdb.stop_cpus"
argument_list|,
operator|&
name|kdb_stop_cpus
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|KDB_STOP_NMI
end_ifdef

begin_comment
comment|/*   * Provide an alternate method of stopping other CPUs. If another CPU has  * disabled interrupts the conventional STOP IPI will be blocked. This   * NMI-based stop should get through in that case.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|kdb_stop_cpus_with_nmi
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_debug_kdb
argument_list|,
name|OID_AUTO
argument_list|,
name|stop_cpus_with_nmi
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
operator|&
name|kdb_stop_cpus_with_nmi
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"debug.kdb.stop_cpus_with_nmi"
argument_list|,
operator|&
name|kdb_stop_cpus_with_nmi
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* KDB_STOP_NMI */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|int
name|kdb_sysctl_available
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|kdb_dbbe
modifier|*
name|be
decl_stmt|,
modifier|*
modifier|*
name|iter
decl_stmt|;
name|char
modifier|*
name|avail
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|ssize_t
name|len
decl_stmt|,
name|sz
decl_stmt|;
name|int
name|error
decl_stmt|;
name|sz
operator|=
literal|0
expr_stmt|;
name|SET_FOREACH
argument_list|(
argument|iter
argument_list|,
argument|kdb_dbbe_set
argument_list|)
block|{
name|be
operator|=
operator|*
name|iter
expr_stmt|;
if|if
condition|(
name|be
operator|->
name|dbbe_active
operator|==
literal|0
condition|)
name|sz
operator|+=
name|strlen
argument_list|(
name|be
operator|->
name|dbbe_name
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
name|sz
operator|++
expr_stmt|;
name|avail
operator|=
name|malloc
argument_list|(
name|sz
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|p
operator|=
name|avail
expr_stmt|;
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
name|SET_FOREACH
argument_list|(
argument|iter
argument_list|,
argument|kdb_dbbe_set
argument_list|)
block|{
name|be
operator|=
operator|*
name|iter
expr_stmt|;
if|if
condition|(
name|be
operator|->
name|dbbe_active
operator|==
literal|0
condition|)
block|{
name|len
operator|=
name|snprintf
argument_list|(
name|p
argument_list|,
name|sz
argument_list|,
literal|"%s "
argument_list|,
name|be
operator|->
name|dbbe_name
argument_list|)
expr_stmt|;
name|p
operator|+=
name|len
expr_stmt|;
name|sz
operator|-=
name|len
expr_stmt|;
block|}
block|}
name|KASSERT
argument_list|(
name|sz
operator|>=
literal|0
argument_list|,
operator|(
literal|"%s"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|sysctl_handle_string
argument_list|(
name|oidp
argument_list|,
name|avail
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|avail
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|kdb_sysctl_current
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|char
name|buf
index|[
literal|16
index|]
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|kdb_dbbe
operator|!=
name|NULL
condition|)
block|{
name|strncpy
argument_list|(
name|buf
argument_list|,
name|kdb_dbbe
operator|->
name|dbbe_name
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|buf
index|[
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
operator|*
name|buf
operator|=
literal|'\0'
expr_stmt|;
name|error
operator|=
name|sysctl_handle_string
argument_list|(
name|oidp
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
operator|||
name|req
operator|->
name|newptr
operator|==
name|NULL
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|kdb_active
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
return|return
operator|(
name|kdb_dbbe_select
argument_list|(
name|buf
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|kdb_sysctl_enter
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|int
name|error
decl_stmt|,
name|i
decl_stmt|;
name|error
operator|=
name|sysctl_wire_old_buffer
argument_list|(
name|req
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|i
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|i
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|!=
literal|0
operator|||
name|req
operator|->
name|newptr
operator|==
name|NULL
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|kdb_active
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
name|kdb_enter
argument_list|(
literal|"sysctl debug.kdb.enter"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Solaris implements a new BREAK which is initiated by a character sequence  * CR ~ ^b which is similar to a familiar pattern used on Sun servers by the  * Remote Console.  *  * Note that this function may be called from almost anywhere, with interrupts  * disabled and with unknown locks held, so it must not access data other than  * its arguments.  Its up to the caller to ensure that the state variable is  * consistent.  */
end_comment

begin_define
define|#
directive|define
name|KEY_CR
value|13
end_define

begin_comment
comment|/* CR '\r' */
end_comment

begin_define
define|#
directive|define
name|KEY_TILDE
value|126
end_define

begin_comment
comment|/* ~ */
end_comment

begin_define
define|#
directive|define
name|KEY_CRTLB
value|2
end_define

begin_comment
comment|/* ^B */
end_comment

begin_function
name|int
name|kdb_alt_break
parameter_list|(
name|int
name|key
parameter_list|,
name|int
modifier|*
name|state
parameter_list|)
block|{
name|int
name|brk
decl_stmt|;
name|brk
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|key
condition|)
block|{
case|case
name|KEY_CR
case|:
operator|*
name|state
operator|=
name|KEY_TILDE
expr_stmt|;
break|break;
case|case
name|KEY_TILDE
case|:
operator|*
name|state
operator|=
operator|(
operator|*
name|state
operator|==
name|KEY_TILDE
operator|)
condition|?
name|KEY_CRTLB
else|:
literal|0
expr_stmt|;
break|break;
case|case
name|KEY_CRTLB
case|:
if|if
condition|(
operator|*
name|state
operator|==
name|KEY_CRTLB
condition|)
name|brk
operator|=
literal|1
expr_stmt|;
comment|/* FALLTHROUGH */
default|default:
operator|*
name|state
operator|=
literal|0
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|brk
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Print a backtrace of the calling thread. The backtrace is generated by  * the selected debugger, provided it supports backtraces. If no debugger  * is selected or the current debugger does not support backtraces, this  * function silently returns.  */
end_comment

begin_function
name|void
name|kdb_backtrace
parameter_list|()
block|{
if|if
condition|(
name|kdb_dbbe
operator|!=
name|NULL
operator|&&
name|kdb_dbbe
operator|->
name|dbbe_trace
operator|!=
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"KDB: stack backtrace:\n"
argument_list|)
expr_stmt|;
name|kdb_dbbe
operator|->
name|dbbe_trace
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Set/change the current backend.  */
end_comment

begin_function
name|int
name|kdb_dbbe_select
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|kdb_dbbe
modifier|*
name|be
decl_stmt|,
modifier|*
modifier|*
name|iter
decl_stmt|;
name|SET_FOREACH
argument_list|(
argument|iter
argument_list|,
argument|kdb_dbbe_set
argument_list|)
block|{
name|be
operator|=
operator|*
name|iter
expr_stmt|;
if|if
condition|(
name|be
operator|->
name|dbbe_active
operator|==
literal|0
operator|&&
name|strcmp
argument_list|(
name|be
operator|->
name|dbbe_name
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
name|kdb_dbbe
operator|=
name|be
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Enter the currently selected debugger. If a message has been provided,  * it is printed first. If the debugger does not support the enter method,  * it is entered by using breakpoint(), which enters the debugger through  * kdb_trap().  */
end_comment

begin_function
name|void
name|kdb_enter
parameter_list|(
specifier|const
name|char
modifier|*
name|msg
parameter_list|)
block|{
if|if
condition|(
name|kdb_dbbe
operator|!=
name|NULL
operator|&&
name|kdb_active
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|msg
operator|!=
name|NULL
condition|)
name|printf
argument_list|(
literal|"KDB: enter: %s\n"
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|breakpoint
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Initialize the kernel debugger interface.  */
end_comment

begin_function
name|void
name|kdb_init
parameter_list|()
block|{
name|struct
name|kdb_dbbe
modifier|*
name|be
decl_stmt|,
modifier|*
modifier|*
name|iter
decl_stmt|;
name|int
name|cur_pri
decl_stmt|,
name|pri
decl_stmt|;
name|kdb_active
operator|=
literal|0
expr_stmt|;
name|kdb_dbbe
operator|=
name|NULL
expr_stmt|;
name|cur_pri
operator|=
operator|-
literal|1
expr_stmt|;
name|SET_FOREACH
argument_list|(
argument|iter
argument_list|,
argument|kdb_dbbe_set
argument_list|)
block|{
name|be
operator|=
operator|*
name|iter
expr_stmt|;
name|pri
operator|=
operator|(
name|be
operator|->
name|dbbe_init
operator|!=
name|NULL
operator|)
condition|?
name|be
operator|->
name|dbbe_init
argument_list|()
else|:
operator|-
literal|1
expr_stmt|;
name|be
operator|->
name|dbbe_active
operator|=
operator|(
name|pri
operator|>=
literal|0
operator|)
condition|?
literal|0
else|:
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|pri
operator|>
name|cur_pri
condition|)
block|{
name|cur_pri
operator|=
name|pri
expr_stmt|;
name|kdb_dbbe
operator|=
name|be
expr_stmt|;
block|}
block|}
if|if
condition|(
name|kdb_dbbe
operator|!=
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"KDB: debugger backends:"
argument_list|)
expr_stmt|;
name|SET_FOREACH
argument_list|(
argument|iter
argument_list|,
argument|kdb_dbbe_set
argument_list|)
block|{
name|be
operator|=
operator|*
name|iter
expr_stmt|;
if|if
condition|(
name|be
operator|->
name|dbbe_active
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|" %s"
argument_list|,
name|be
operator|->
name|dbbe_name
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"KDB: current backend: %s\n"
argument_list|,
name|kdb_dbbe
operator|->
name|dbbe_name
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Handle contexts.  */
end_comment

begin_function
name|void
modifier|*
name|kdb_jmpbuf
parameter_list|(
name|jmp_buf
name|new
parameter_list|)
block|{
name|void
modifier|*
name|old
decl_stmt|;
name|old
operator|=
name|kdb_jmpbufp
expr_stmt|;
name|kdb_jmpbufp
operator|=
name|new
expr_stmt|;
return|return
operator|(
name|old
operator|)
return|;
block|}
end_function

begin_function
name|void
name|kdb_reenter
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
name|kdb_active
operator|||
name|kdb_jmpbufp
operator|==
name|NULL
condition|)
return|return;
name|longjmp
argument_list|(
name|kdb_jmpbufp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
end_function

begin_comment
comment|/*  * Thread related support functions.  */
end_comment

begin_function
name|struct
name|pcb
modifier|*
name|kdb_thr_ctx
parameter_list|(
name|struct
name|thread
modifier|*
name|thr
parameter_list|)
ifdef|#
directive|ifdef
name|KDB_STOP_NMI
block|{
name|u_int
name|cpuid
decl_stmt|;
name|struct
name|pcpu
modifier|*
name|pc
decl_stmt|;
if|if
condition|(
name|thr
operator|==
name|curthread
condition|)
return|return
operator|&
name|kdb_pcb
return|;
name|SLIST_FOREACH
argument_list|(
argument|pc
argument_list|,
argument|&cpuhead
argument_list|,
argument|pc_allcpu
argument_list|)
block|{
name|cpuid
operator|=
name|pc
operator|->
name|pc_cpuid
expr_stmt|;
if|if
condition|(
name|pc
operator|->
name|pc_curthread
operator|==
name|thr
operator|&&
operator|(
name|atomic_load_acq_int
argument_list|(
operator|&
name|stopped_cpus
argument_list|)
operator|&
operator|(
literal|1
operator|<<
name|cpuid
operator|)
operator|)
condition|)
return|return
operator|&
name|stoppcbs
index|[
name|cpuid
index|]
return|;
block|}
return|return
name|thr
operator|->
name|td_pcb
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_block
block|{
return|return
operator|(
operator|(
name|thr
operator|==
name|curthread
operator|)
condition|?
operator|&
name|kdb_pcb
else|:
name|thr
operator|->
name|td_pcb
operator|)
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* KDB_STOP_NMI */
end_comment

begin_function
name|struct
name|thread
modifier|*
name|kdb_thr_first
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|struct
name|thread
modifier|*
name|thr
decl_stmt|;
name|p
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|allproc
argument_list|)
expr_stmt|;
while|while
condition|(
name|p
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|p_sflag
operator|&
name|PS_INMEM
condition|)
block|{
name|thr
operator|=
name|FIRST_THREAD_IN_PROC
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|thr
operator|!=
name|NULL
condition|)
return|return
operator|(
name|thr
operator|)
return|;
block|}
name|p
operator|=
name|LIST_NEXT
argument_list|(
name|p
argument_list|,
name|p_list
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|thread
modifier|*
name|kdb_thr_from_pid
parameter_list|(
name|pid_t
name|pid
parameter_list|)
block|{
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|allproc
argument_list|)
expr_stmt|;
while|while
condition|(
name|p
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|p_sflag
operator|&
name|PS_INMEM
operator|&&
name|p
operator|->
name|p_pid
operator|==
name|pid
condition|)
return|return
operator|(
name|FIRST_THREAD_IN_PROC
argument_list|(
name|p
argument_list|)
operator|)
return|;
name|p
operator|=
name|LIST_NEXT
argument_list|(
name|p
argument_list|,
name|p_list
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|thread
modifier|*
name|kdb_thr_lookup
parameter_list|(
name|lwpid_t
name|tid
parameter_list|)
block|{
name|struct
name|thread
modifier|*
name|thr
decl_stmt|;
name|thr
operator|=
name|kdb_thr_first
argument_list|()
expr_stmt|;
while|while
condition|(
name|thr
operator|!=
name|NULL
operator|&&
name|thr
operator|->
name|td_tid
operator|!=
name|tid
condition|)
name|thr
operator|=
name|kdb_thr_next
argument_list|(
name|thr
argument_list|)
expr_stmt|;
return|return
operator|(
name|thr
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|thread
modifier|*
name|kdb_thr_next
parameter_list|(
name|struct
name|thread
modifier|*
name|thr
parameter_list|)
block|{
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|thr
operator|->
name|td_proc
expr_stmt|;
name|thr
operator|=
name|TAILQ_NEXT
argument_list|(
name|thr
argument_list|,
name|td_plist
argument_list|)
expr_stmt|;
do|do
block|{
if|if
condition|(
name|thr
operator|!=
name|NULL
condition|)
return|return
operator|(
name|thr
operator|)
return|;
name|p
operator|=
name|LIST_NEXT
argument_list|(
name|p
argument_list|,
name|p_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
operator|&&
operator|(
name|p
operator|->
name|p_sflag
operator|&
name|PS_INMEM
operator|)
condition|)
name|thr
operator|=
name|FIRST_THREAD_IN_PROC
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|p
operator|!=
name|NULL
condition|)
do|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
name|int
name|kdb_thr_select
parameter_list|(
name|struct
name|thread
modifier|*
name|thr
parameter_list|)
block|{
if|if
condition|(
name|thr
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|kdb_thread
operator|=
name|thr
expr_stmt|;
name|kdb_thrctx
operator|=
name|kdb_thr_ctx
argument_list|(
name|thr
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Enter the debugger due to a trap.  */
end_comment

begin_function
name|int
name|kdb_trap
parameter_list|(
name|int
name|type
parameter_list|,
name|int
name|code
parameter_list|,
name|struct
name|trapframe
modifier|*
name|tf
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|SMP
name|int
name|did_stop_cpus
decl_stmt|;
endif|#
directive|endif
name|int
name|handled
decl_stmt|;
if|if
condition|(
name|kdb_dbbe
operator|==
name|NULL
operator|||
name|kdb_dbbe
operator|->
name|dbbe_trap
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* We reenter the debugger through kdb_reenter(). */
if|if
condition|(
name|kdb_active
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|critical_enter
argument_list|()
expr_stmt|;
name|kdb_active
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|SMP
if|if
condition|(
operator|(
name|did_stop_cpus
operator|=
name|kdb_stop_cpus
operator|)
operator|!=
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|KDB_STOP_NMI
if|if
condition|(
name|kdb_stop_cpus_with_nmi
condition|)
name|stop_cpus_nmi
argument_list|(
name|PCPU_GET
argument_list|(
name|other_cpus
argument_list|)
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
comment|/* KDB_STOP_NMI */
name|stop_cpus
argument_list|(
name|PCPU_GET
argument_list|(
name|other_cpus
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|kdb_frame
operator|=
name|tf
expr_stmt|;
comment|/* Let MD code do its thing first... */
name|kdb_cpu_trap
argument_list|(
name|type
argument_list|,
name|code
argument_list|)
expr_stmt|;
name|makectx
argument_list|(
name|tf
argument_list|,
operator|&
name|kdb_pcb
argument_list|)
expr_stmt|;
name|kdb_thr_select
argument_list|(
name|curthread
argument_list|)
expr_stmt|;
name|handled
operator|=
name|kdb_dbbe
operator|->
name|dbbe_trap
argument_list|(
name|type
argument_list|,
name|code
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SMP
if|if
condition|(
name|did_stop_cpus
condition|)
name|restart_cpus
argument_list|(
name|stopped_cpus
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|kdb_active
operator|--
expr_stmt|;
name|critical_exit
argument_list|()
expr_stmt|;
return|return
operator|(
name|handled
operator|)
return|;
block|}
end_function

end_unit

