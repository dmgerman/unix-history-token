begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2013-16, Stacey D. Son  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/ctype.h>
end_include

begin_include
include|#
directive|include
file|<sys/sbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysproto.h>
end_include

begin_include
include|#
directive|include
file|<sys/exec.h>
end_include

begin_include
include|#
directive|include
file|<sys/imgact.h>
end_include

begin_include
include|#
directive|include
file|<sys/imgact_binmisc.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/libkern.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/sx.h>
end_include

begin_include
include|#
directive|include
file|<machine/atomic.h>
end_include

begin_comment
comment|/**  * Miscellaneous binary interpreter image activator.  *  * If the given target executable's header matches 'xbe_magic' field in the  * 'interpreter_list' then it will use the user-level interpreter specified in  * the 'xbe_interpreter' field to execute the binary. The 'xbe_magic' field may  * be adjusted to a given offset using the value in the 'xbe_moffset' field  * and bits of the header may be masked using the 'xbe_mask' field.  The  * 'interpreter_list' entries are managed using sysctl(3) as described in the  *<sys/imgact_binmisc.h> file.  */
end_comment

begin_comment
comment|/*  * Node of the interpreter list.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|imgact_binmisc_entry
block|{
name|char
modifier|*
name|ibe_name
decl_stmt|;
name|uint8_t
modifier|*
name|ibe_magic
decl_stmt|;
name|uint32_t
name|ibe_moffset
decl_stmt|;
name|uint32_t
name|ibe_msize
decl_stmt|;
name|uint8_t
modifier|*
name|ibe_mask
decl_stmt|;
name|uint8_t
modifier|*
name|ibe_interpreter
decl_stmt|;
name|uint32_t
name|ibe_interp_argcnt
decl_stmt|;
name|uint32_t
name|ibe_interp_length
decl_stmt|;
name|uint32_t
name|ibe_flags
decl_stmt|;
name|SLIST_ENTRY
argument_list|(
argument|imgact_binmisc_entry
argument_list|)
name|link
expr_stmt|;
block|}
name|imgact_binmisc_entry_t
typedef|;
end_typedef

begin_comment
comment|/*  * sysctl() commands.  */
end_comment

begin_define
define|#
directive|define
name|IBC_ADD
value|1
end_define

begin_comment
comment|/* Add given entry. */
end_comment

begin_define
define|#
directive|define
name|IBC_REMOVE
value|2
end_define

begin_comment
comment|/* Remove entry for a given name. */
end_comment

begin_define
define|#
directive|define
name|IBC_DISABLE
value|3
end_define

begin_comment
comment|/* Disable entry for a given name. */
end_comment

begin_define
define|#
directive|define
name|IBC_ENABLE
value|4
end_define

begin_comment
comment|/* Enable entry for a given name. */
end_comment

begin_define
define|#
directive|define
name|IBC_LOOKUP
value|5
end_define

begin_comment
comment|/* Lookup and return entry for given name. */
end_comment

begin_define
define|#
directive|define
name|IBC_LIST
value|6
end_define

begin_comment
comment|/* Get a snapshot of the interpretor list. */
end_comment

begin_comment
comment|/*  * Interpreter string macros.  *  * They all start with '#' followed by a single letter:  */
end_comment

begin_define
define|#
directive|define
name|ISM_POUND
value|'#'
end_define

begin_comment
comment|/* "##" is the escape sequence for single #. */
end_comment

begin_define
define|#
directive|define
name|ISM_OLD_ARGV0
value|'a'
end_define

begin_comment
comment|/* "#a" is replaced with the old argv0. */
end_comment

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_BINMISC
argument_list|,
name|KMOD_NAME
argument_list|,
literal|"misc binary image activator"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* The interpreter list. */
end_comment

begin_expr_stmt
specifier|static
name|SLIST_HEAD
argument_list|(
argument_list|,
argument|imgact_binmisc_entry
argument_list|)
name|interpreter_list
operator|=
name|SLIST_HEAD_INITIALIZER
argument_list|(
name|interpreter_list
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|interp_list_entry_count
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|sx
name|interp_list_sx
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Populate the entry with the information about the interpreter.  */
end_comment

begin_function
specifier|static
name|void
name|imgact_binmisc_populate_interp
parameter_list|(
name|char
modifier|*
name|str
parameter_list|,
name|imgact_binmisc_entry_t
modifier|*
name|ibe
parameter_list|)
block|{
name|uint32_t
name|len
init|=
literal|0
decl_stmt|,
name|argc
init|=
literal|1
decl_stmt|;
name|char
name|t
index|[
name|IBE_INTERP_LEN_MAX
index|]
decl_stmt|;
name|char
modifier|*
name|sp
decl_stmt|,
modifier|*
name|tp
decl_stmt|;
name|memset
argument_list|(
name|t
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Normalize interpreter string. Replace white space between args with 	 * single space. 	 */
name|sp
operator|=
name|str
expr_stmt|;
name|tp
operator|=
name|t
expr_stmt|;
while|while
condition|(
operator|*
name|sp
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
operator|*
name|sp
operator|==
literal|' '
operator|||
operator|*
name|sp
operator|==
literal|'\t'
condition|)
block|{
if|if
condition|(
operator|++
name|len
operator|>=
name|IBE_INTERP_LEN_MAX
condition|)
break|break;
operator|*
name|tp
operator|++
operator|=
literal|' '
expr_stmt|;
name|argc
operator|++
expr_stmt|;
while|while
condition|(
operator|*
name|sp
operator|==
literal|' '
operator|||
operator|*
name|sp
operator|==
literal|'\t'
condition|)
name|sp
operator|++
expr_stmt|;
continue|continue;
block|}
else|else
block|{
operator|*
name|tp
operator|++
operator|=
operator|*
name|sp
operator|++
expr_stmt|;
name|len
operator|++
expr_stmt|;
block|}
block|}
operator|*
name|tp
operator|=
literal|'\0'
expr_stmt|;
name|len
operator|++
expr_stmt|;
name|ibe
operator|->
name|ibe_interpreter
operator|=
name|malloc
argument_list|(
name|len
argument_list|,
name|M_BINMISC
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
comment|/* Populate all the ibe fields for the interpreter. */
name|memcpy
argument_list|(
name|ibe
operator|->
name|ibe_interpreter
argument_list|,
name|t
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|ibe
operator|->
name|ibe_interp_argcnt
operator|=
name|argc
expr_stmt|;
name|ibe
operator|->
name|ibe_interp_length
operator|=
name|len
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Allocate memory and populate a new entry for the interpreter table.  */
end_comment

begin_function
specifier|static
name|imgact_binmisc_entry_t
modifier|*
name|imgact_binmisc_new_entry
parameter_list|(
name|ximgact_binmisc_entry_t
modifier|*
name|xbe
parameter_list|)
block|{
name|imgact_binmisc_entry_t
modifier|*
name|ibe
init|=
name|NULL
decl_stmt|;
name|size_t
name|namesz
init|=
name|min
argument_list|(
name|strlen
argument_list|(
name|xbe
operator|->
name|xbe_name
argument_list|)
operator|+
literal|1
argument_list|,
name|IBE_NAME_MAX
argument_list|)
decl_stmt|;
name|ibe
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|ibe
argument_list|)
argument_list|,
name|M_BINMISC
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|ibe
operator|->
name|ibe_name
operator|=
name|malloc
argument_list|(
name|namesz
argument_list|,
name|M_BINMISC
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|strlcpy
argument_list|(
name|ibe
operator|->
name|ibe_name
argument_list|,
name|xbe
operator|->
name|xbe_name
argument_list|,
name|namesz
argument_list|)
expr_stmt|;
name|imgact_binmisc_populate_interp
argument_list|(
name|xbe
operator|->
name|xbe_interpreter
argument_list|,
name|ibe
argument_list|)
expr_stmt|;
name|ibe
operator|->
name|ibe_magic
operator|=
name|malloc
argument_list|(
name|xbe
operator|->
name|xbe_msize
argument_list|,
name|M_BINMISC
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|ibe
operator|->
name|ibe_magic
argument_list|,
name|xbe
operator|->
name|xbe_magic
argument_list|,
name|xbe
operator|->
name|xbe_msize
argument_list|)
expr_stmt|;
name|ibe
operator|->
name|ibe_mask
operator|=
name|malloc
argument_list|(
name|xbe
operator|->
name|xbe_msize
argument_list|,
name|M_BINMISC
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|ibe
operator|->
name|ibe_mask
argument_list|,
name|xbe
operator|->
name|xbe_mask
argument_list|,
name|xbe
operator|->
name|xbe_msize
argument_list|)
expr_stmt|;
name|ibe
operator|->
name|ibe_moffset
operator|=
name|xbe
operator|->
name|xbe_moffset
expr_stmt|;
name|ibe
operator|->
name|ibe_msize
operator|=
name|xbe
operator|->
name|xbe_msize
expr_stmt|;
name|ibe
operator|->
name|ibe_flags
operator|=
name|xbe
operator|->
name|xbe_flags
expr_stmt|;
return|return
operator|(
name|ibe
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Free the allocated memory for a given list item.  */
end_comment

begin_function
specifier|static
name|void
name|imgact_binmisc_destroy_entry
parameter_list|(
name|imgact_binmisc_entry_t
modifier|*
name|ibe
parameter_list|)
block|{
if|if
condition|(
operator|!
name|ibe
condition|)
return|return;
if|if
condition|(
name|ibe
operator|->
name|ibe_magic
condition|)
name|free
argument_list|(
name|ibe
operator|->
name|ibe_magic
argument_list|,
name|M_BINMISC
argument_list|)
expr_stmt|;
if|if
condition|(
name|ibe
operator|->
name|ibe_mask
condition|)
name|free
argument_list|(
name|ibe
operator|->
name|ibe_mask
argument_list|,
name|M_BINMISC
argument_list|)
expr_stmt|;
if|if
condition|(
name|ibe
operator|->
name|ibe_interpreter
condition|)
name|free
argument_list|(
name|ibe
operator|->
name|ibe_interpreter
argument_list|,
name|M_BINMISC
argument_list|)
expr_stmt|;
if|if
condition|(
name|ibe
operator|->
name|ibe_name
condition|)
name|free
argument_list|(
name|ibe
operator|->
name|ibe_name
argument_list|,
name|M_BINMISC
argument_list|)
expr_stmt|;
if|if
condition|(
name|ibe
condition|)
name|free
argument_list|(
name|ibe
argument_list|,
name|M_BINMISC
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Find the interpreter in the list by the given name.  Return NULL if not  * found.  */
end_comment

begin_function
specifier|static
name|imgact_binmisc_entry_t
modifier|*
name|imgact_binmisc_find_entry
parameter_list|(
name|char
modifier|*
name|name
parameter_list|)
block|{
name|imgact_binmisc_entry_t
modifier|*
name|ibe
decl_stmt|;
name|sx_assert
argument_list|(
operator|&
name|interp_list_sx
argument_list|,
name|SA_LOCKED
argument_list|)
expr_stmt|;
name|SLIST_FOREACH
argument_list|(
argument|ibe
argument_list|,
argument|&interpreter_list
argument_list|,
argument|link
argument_list|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|name
argument_list|,
name|ibe
operator|->
name|ibe_name
argument_list|,
name|IBE_NAME_MAX
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|ibe
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Add the given interpreter if it doesn't already exist.  Return EEXIST  * if the name already exist in the interpreter list.  */
end_comment

begin_function
specifier|static
name|int
name|imgact_binmisc_add_entry
parameter_list|(
name|ximgact_binmisc_entry_t
modifier|*
name|xbe
parameter_list|)
block|{
name|imgact_binmisc_entry_t
modifier|*
name|ibe
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|cnt
decl_stmt|;
if|if
condition|(
name|xbe
operator|->
name|xbe_msize
operator|>
name|IBE_MAGIC_MAX
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
for|for
control|(
name|cnt
operator|=
literal|0
operator|,
name|p
operator|=
name|xbe
operator|->
name|xbe_name
init|;
operator|*
name|p
operator|!=
literal|0
condition|;
name|cnt
operator|++
operator|,
name|p
operator|++
control|)
if|if
condition|(
name|cnt
operator|>=
name|IBE_NAME_MAX
operator|||
operator|!
name|isascii
argument_list|(
operator|(
name|int
operator|)
operator|*
name|p
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
for|for
control|(
name|cnt
operator|=
literal|0
operator|,
name|p
operator|=
name|xbe
operator|->
name|xbe_interpreter
init|;
operator|*
name|p
operator|!=
literal|0
condition|;
name|cnt
operator|++
operator|,
name|p
operator|++
control|)
if|if
condition|(
name|cnt
operator|>=
name|IBE_INTERP_LEN_MAX
operator|||
operator|!
name|isascii
argument_list|(
operator|(
name|int
operator|)
operator|*
name|p
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* Make sure we don't have any invalid #'s. */
name|p
operator|=
name|xbe
operator|->
name|xbe_interpreter
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|p
operator|=
name|strchr
argument_list|(
name|p
argument_list|,
literal|'#'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p
condition|)
break|break;
name|p
operator|++
expr_stmt|;
switch|switch
condition|(
operator|*
name|p
condition|)
block|{
case|case
name|ISM_POUND
case|:
comment|/* "##" */
name|p
operator|++
expr_stmt|;
break|break;
case|case
name|ISM_OLD_ARGV0
case|:
comment|/* "#a" */
name|p
operator|++
expr_stmt|;
break|break;
case|case
literal|0
case|:
default|default:
comment|/* Anything besides the above is invalid. */
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
block|}
name|sx_xlock
argument_list|(
operator|&
name|interp_list_sx
argument_list|)
expr_stmt|;
if|if
condition|(
name|imgact_binmisc_find_entry
argument_list|(
name|xbe
operator|->
name|xbe_name
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|sx_xunlock
argument_list|(
operator|&
name|interp_list_sx
argument_list|)
expr_stmt|;
return|return
operator|(
name|EEXIST
operator|)
return|;
block|}
comment|/* Preallocate a new entry. */
name|ibe
operator|=
name|imgact_binmisc_new_entry
argument_list|(
name|xbe
argument_list|)
expr_stmt|;
name|SLIST_INSERT_HEAD
argument_list|(
operator|&
name|interpreter_list
argument_list|,
name|ibe
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|interp_list_entry_count
operator|++
expr_stmt|;
name|sx_xunlock
argument_list|(
operator|&
name|interp_list_sx
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Remove the interpreter in the list with the given name. Return ENOENT  * if not found.  */
end_comment

begin_function
specifier|static
name|int
name|imgact_binmisc_remove_entry
parameter_list|(
name|char
modifier|*
name|name
parameter_list|)
block|{
name|imgact_binmisc_entry_t
modifier|*
name|ibe
decl_stmt|;
name|sx_xlock
argument_list|(
operator|&
name|interp_list_sx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ibe
operator|=
name|imgact_binmisc_find_entry
argument_list|(
name|name
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|sx_xunlock
argument_list|(
operator|&
name|interp_list_sx
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
name|SLIST_REMOVE
argument_list|(
operator|&
name|interpreter_list
argument_list|,
name|ibe
argument_list|,
name|imgact_binmisc_entry
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|interp_list_entry_count
operator|--
expr_stmt|;
name|sx_xunlock
argument_list|(
operator|&
name|interp_list_sx
argument_list|)
expr_stmt|;
name|imgact_binmisc_destroy_entry
argument_list|(
name|ibe
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Disable the interpreter in the list with the given name. Return ENOENT  * if not found.  */
end_comment

begin_function
specifier|static
name|int
name|imgact_binmisc_disable_entry
parameter_list|(
name|char
modifier|*
name|name
parameter_list|)
block|{
name|imgact_binmisc_entry_t
modifier|*
name|ibe
decl_stmt|;
name|sx_xlock
argument_list|(
operator|&
name|interp_list_sx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ibe
operator|=
name|imgact_binmisc_find_entry
argument_list|(
name|name
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|sx_xunlock
argument_list|(
operator|&
name|interp_list_sx
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
name|ibe
operator|->
name|ibe_flags
operator|&=
operator|~
name|IBF_ENABLED
expr_stmt|;
name|sx_xunlock
argument_list|(
operator|&
name|interp_list_sx
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Enable the interpreter in the list with the given name. Return ENOENT  * if not found.  */
end_comment

begin_function
specifier|static
name|int
name|imgact_binmisc_enable_entry
parameter_list|(
name|char
modifier|*
name|name
parameter_list|)
block|{
name|imgact_binmisc_entry_t
modifier|*
name|ibe
decl_stmt|;
name|sx_xlock
argument_list|(
operator|&
name|interp_list_sx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ibe
operator|=
name|imgact_binmisc_find_entry
argument_list|(
name|name
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|sx_xunlock
argument_list|(
operator|&
name|interp_list_sx
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
name|ibe
operator|->
name|ibe_flags
operator||=
name|IBF_ENABLED
expr_stmt|;
name|sx_xunlock
argument_list|(
operator|&
name|interp_list_sx
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|imgact_binmisc_populate_xbe
parameter_list|(
name|ximgact_binmisc_entry_t
modifier|*
name|xbe
parameter_list|,
name|imgact_binmisc_entry_t
modifier|*
name|ibe
parameter_list|)
block|{
name|uint32_t
name|i
decl_stmt|;
name|sx_assert
argument_list|(
operator|&
name|interp_list_sx
argument_list|,
name|SA_LOCKED
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|xbe
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|xbe
argument_list|)
argument_list|)
expr_stmt|;
name|strlcpy
argument_list|(
name|xbe
operator|->
name|xbe_name
argument_list|,
name|ibe
operator|->
name|ibe_name
argument_list|,
name|IBE_NAME_MAX
argument_list|)
expr_stmt|;
comment|/* Copy interpreter string.  Replace NULL breaks with space. */
name|memcpy
argument_list|(
name|xbe
operator|->
name|xbe_interpreter
argument_list|,
name|ibe
operator|->
name|ibe_interpreter
argument_list|,
name|ibe
operator|->
name|ibe_interp_length
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|ibe
operator|->
name|ibe_interp_length
operator|-
literal|1
operator|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|xbe
operator|->
name|xbe_interpreter
index|[
name|i
index|]
operator|==
literal|'\0'
condition|)
name|xbe
operator|->
name|xbe_interpreter
index|[
name|i
index|]
operator|=
literal|' '
expr_stmt|;
name|memcpy
argument_list|(
name|xbe
operator|->
name|xbe_magic
argument_list|,
name|ibe
operator|->
name|ibe_magic
argument_list|,
name|ibe
operator|->
name|ibe_msize
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|xbe
operator|->
name|xbe_mask
argument_list|,
name|ibe
operator|->
name|ibe_mask
argument_list|,
name|ibe
operator|->
name|ibe_msize
argument_list|)
expr_stmt|;
name|xbe
operator|->
name|xbe_version
operator|=
name|IBE_VERSION
expr_stmt|;
name|xbe
operator|->
name|xbe_flags
operator|=
name|ibe
operator|->
name|ibe_flags
expr_stmt|;
name|xbe
operator|->
name|xbe_moffset
operator|=
name|ibe
operator|->
name|ibe_moffset
expr_stmt|;
name|xbe
operator|->
name|xbe_msize
operator|=
name|ibe
operator|->
name|ibe_msize
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Retrieve the interpreter with the give name and populate the  * ximgact_binmisc_entry structure.  Return ENOENT if not found.  */
end_comment

begin_function
specifier|static
name|int
name|imgact_binmisc_lookup_entry
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|ximgact_binmisc_entry_t
modifier|*
name|xbe
parameter_list|)
block|{
name|imgact_binmisc_entry_t
modifier|*
name|ibe
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|sx_slock
argument_list|(
operator|&
name|interp_list_sx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ibe
operator|=
name|imgact_binmisc_find_entry
argument_list|(
name|name
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|sx_sunlock
argument_list|(
operator|&
name|interp_list_sx
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
name|error
operator|=
name|imgact_binmisc_populate_xbe
argument_list|(
name|xbe
argument_list|,
name|ibe
argument_list|)
expr_stmt|;
name|sx_sunlock
argument_list|(
operator|&
name|interp_list_sx
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Get a snapshot of all the interpreter entries in the list.  */
end_comment

begin_function
specifier|static
name|int
name|imgact_binmisc_get_all_entries
parameter_list|(
name|struct
name|sysctl_req
modifier|*
name|req
parameter_list|)
block|{
name|ximgact_binmisc_entry_t
modifier|*
name|xbe
decl_stmt|,
modifier|*
name|xbep
decl_stmt|;
name|imgact_binmisc_entry_t
modifier|*
name|ibe
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|,
name|count
decl_stmt|;
name|sx_slock
argument_list|(
operator|&
name|interp_list_sx
argument_list|)
expr_stmt|;
name|count
operator|=
name|interp_list_entry_count
expr_stmt|;
name|xbe
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|xbe
argument_list|)
operator|*
name|count
argument_list|,
name|M_BINMISC
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|xbep
operator|=
name|xbe
expr_stmt|;
name|SLIST_FOREACH
argument_list|(
argument|ibe
argument_list|,
argument|&interpreter_list
argument_list|,
argument|link
argument_list|)
block|{
name|error
operator|=
name|imgact_binmisc_populate_xbe
argument_list|(
name|xbep
operator|++
argument_list|,
name|ibe
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
block|}
name|sx_sunlock
argument_list|(
operator|&
name|interp_list_sx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
name|error
operator|=
name|SYSCTL_OUT
argument_list|(
name|req
argument_list|,
name|xbe
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|xbe
argument_list|)
operator|*
name|count
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|xbe
argument_list|,
name|M_BINMISC
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * sysctl() handler for munipulating interpretor table.  * Not MP safe (locked by sysctl).  */
end_comment

begin_function
specifier|static
name|int
name|sysctl_kern_binmisc
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|ximgact_binmisc_entry_t
name|xbe
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|arg2
condition|)
block|{
case|case
name|IBC_ADD
case|:
comment|/* Add an entry. Limited to IBE_MAX_ENTRIES. */
name|error
operator|=
name|SYSCTL_IN
argument_list|(
name|req
argument_list|,
operator|&
name|xbe
argument_list|,
sizeof|sizeof
argument_list|(
name|xbe
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|IBE_VERSION
operator|!=
name|xbe
operator|.
name|xbe_version
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|interp_list_entry_count
operator|==
name|IBE_MAX_ENTRIES
condition|)
return|return
operator|(
name|ENOSPC
operator|)
return|;
name|error
operator|=
name|imgact_binmisc_add_entry
argument_list|(
operator|&
name|xbe
argument_list|)
expr_stmt|;
break|break;
case|case
name|IBC_REMOVE
case|:
comment|/* Remove an entry. */
name|error
operator|=
name|SYSCTL_IN
argument_list|(
name|req
argument_list|,
operator|&
name|xbe
argument_list|,
sizeof|sizeof
argument_list|(
name|xbe
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|IBE_VERSION
operator|!=
name|xbe
operator|.
name|xbe_version
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|error
operator|=
name|imgact_binmisc_remove_entry
argument_list|(
name|xbe
operator|.
name|xbe_name
argument_list|)
expr_stmt|;
break|break;
case|case
name|IBC_DISABLE
case|:
comment|/* Disable an entry. */
name|error
operator|=
name|SYSCTL_IN
argument_list|(
name|req
argument_list|,
operator|&
name|xbe
argument_list|,
sizeof|sizeof
argument_list|(
name|xbe
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|IBE_VERSION
operator|!=
name|xbe
operator|.
name|xbe_version
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|error
operator|=
name|imgact_binmisc_disable_entry
argument_list|(
name|xbe
operator|.
name|xbe_name
argument_list|)
expr_stmt|;
break|break;
case|case
name|IBC_ENABLE
case|:
comment|/* Enable an entry. */
name|error
operator|=
name|SYSCTL_IN
argument_list|(
name|req
argument_list|,
operator|&
name|xbe
argument_list|,
sizeof|sizeof
argument_list|(
name|xbe
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|IBE_VERSION
operator|!=
name|xbe
operator|.
name|xbe_version
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|error
operator|=
name|imgact_binmisc_enable_entry
argument_list|(
name|xbe
operator|.
name|xbe_name
argument_list|)
expr_stmt|;
break|break;
case|case
name|IBC_LOOKUP
case|:
comment|/* Lookup an entry. */
name|error
operator|=
name|SYSCTL_IN
argument_list|(
name|req
argument_list|,
operator|&
name|xbe
argument_list|,
sizeof|sizeof
argument_list|(
name|xbe
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|IBE_VERSION
operator|!=
name|xbe
operator|.
name|xbe_version
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|error
operator|=
name|imgact_binmisc_lookup_entry
argument_list|(
name|xbe
operator|.
name|xbe_name
argument_list|,
operator|&
name|xbe
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
name|error
operator|=
name|SYSCTL_OUT
argument_list|(
name|req
argument_list|,
operator|&
name|xbe
argument_list|,
sizeof|sizeof
argument_list|(
name|xbe
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|IBC_LIST
case|:
comment|/* Return a snapshot of the interpretor list. */
if|if
condition|(
operator|!
name|req
operator|->
name|oldptr
condition|)
block|{
comment|/* No pointer then just return the list size. */
name|error
operator|=
name|SYSCTL_OUT
argument_list|(
name|req
argument_list|,
literal|0
argument_list|,
name|interp_list_entry_count
operator|*
sizeof|sizeof
argument_list|(
name|ximgact_binmisc_entry_t
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|req
operator|->
name|oldlen
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|error
operator|=
name|imgact_binmisc_get_all_entries
argument_list|(
name|req
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_kern
argument_list|,
name|OID_AUTO
argument_list|,
name|binmisc
argument_list|,
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
literal|"Image activator for miscellaneous binaries"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_PROC
argument_list|(
name|_kern_binmisc
argument_list|,
name|OID_AUTO
argument_list|,
name|add
argument_list|,
name|CTLFLAG_MPSAFE
operator||
name|CTLTYPE_STRUCT
operator||
name|CTLFLAG_WR
argument_list|,
name|NULL
argument_list|,
name|IBC_ADD
argument_list|,
name|sysctl_kern_binmisc
argument_list|,
literal|"S,ximgact_binmisc_entry"
argument_list|,
literal|"Add an activator entry"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_PROC
argument_list|(
name|_kern_binmisc
argument_list|,
name|OID_AUTO
argument_list|,
name|remove
argument_list|,
name|CTLFLAG_MPSAFE
operator||
name|CTLTYPE_STRUCT
operator||
name|CTLFLAG_WR
argument_list|,
name|NULL
argument_list|,
name|IBC_REMOVE
argument_list|,
name|sysctl_kern_binmisc
argument_list|,
literal|"S,ximgact_binmisc_entry"
argument_list|,
literal|"Remove an activator entry"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_PROC
argument_list|(
name|_kern_binmisc
argument_list|,
name|OID_AUTO
argument_list|,
name|disable
argument_list|,
name|CTLFLAG_MPSAFE
operator||
name|CTLTYPE_STRUCT
operator||
name|CTLFLAG_WR
argument_list|,
name|NULL
argument_list|,
name|IBC_DISABLE
argument_list|,
name|sysctl_kern_binmisc
argument_list|,
literal|"S,ximgact_binmisc_entry"
argument_list|,
literal|"Disable an activator entry"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_PROC
argument_list|(
name|_kern_binmisc
argument_list|,
name|OID_AUTO
argument_list|,
name|enable
argument_list|,
name|CTLFLAG_MPSAFE
operator||
name|CTLTYPE_STRUCT
operator||
name|CTLFLAG_WR
argument_list|,
name|NULL
argument_list|,
name|IBC_ENABLE
argument_list|,
name|sysctl_kern_binmisc
argument_list|,
literal|"S,ximgact_binmisc_entry"
argument_list|,
literal|"Enable an activator entry"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_PROC
argument_list|(
name|_kern_binmisc
argument_list|,
name|OID_AUTO
argument_list|,
name|lookup
argument_list|,
name|CTLFLAG_MPSAFE
operator||
name|CTLTYPE_STRUCT
operator||
name|CTLFLAG_RW
operator||
name|CTLFLAG_ANYBODY
argument_list|,
name|NULL
argument_list|,
name|IBC_LOOKUP
argument_list|,
name|sysctl_kern_binmisc
argument_list|,
literal|"S,ximgact_binmisc_entry"
argument_list|,
literal|"Lookup an activator entry"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_PROC
argument_list|(
name|_kern_binmisc
argument_list|,
name|OID_AUTO
argument_list|,
name|list
argument_list|,
name|CTLFLAG_MPSAFE
operator||
name|CTLTYPE_STRUCT
operator||
name|CTLFLAG_RD
operator||
name|CTLFLAG_ANYBODY
argument_list|,
name|NULL
argument_list|,
name|IBC_LIST
argument_list|,
name|sysctl_kern_binmisc
argument_list|,
literal|"S,ximgact_binmisc_entry"
argument_list|,
literal|"Get snapshot of all the activator entries"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|imgact_binmisc_entry_t
modifier|*
name|imgact_binmisc_find_interpreter
parameter_list|(
specifier|const
name|char
modifier|*
name|image_header
parameter_list|)
block|{
name|imgact_binmisc_entry_t
modifier|*
name|ibe
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|i
decl_stmt|;
name|size_t
name|sz
decl_stmt|;
name|sx_assert
argument_list|(
operator|&
name|interp_list_sx
argument_list|,
name|SA_LOCKED
argument_list|)
expr_stmt|;
name|SLIST_FOREACH
argument_list|(
argument|ibe
argument_list|,
argument|&interpreter_list
argument_list|,
argument|link
argument_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|IBF_ENABLED
operator|&
name|ibe
operator|->
name|ibe_flags
operator|)
condition|)
continue|continue;
name|p
operator|=
name|image_header
operator|+
name|ibe
operator|->
name|ibe_moffset
expr_stmt|;
name|sz
operator|=
name|ibe
operator|->
name|ibe_msize
expr_stmt|;
if|if
condition|(
name|IBF_USE_MASK
operator|&
name|ibe
operator|->
name|ibe_flags
condition|)
block|{
comment|/* Compare using mask. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sz
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
operator|*
name|p
operator|++
operator|^
name|ibe
operator|->
name|ibe_magic
index|[
name|i
index|]
operator|)
operator|&
name|ibe
operator|->
name|ibe_mask
index|[
name|i
index|]
condition|)
break|break;
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sz
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|*
name|p
operator|++
operator|^
name|ibe
operator|->
name|ibe_magic
index|[
name|i
index|]
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|==
name|ibe
operator|->
name|ibe_msize
condition|)
return|return
operator|(
name|ibe
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|imgact_binmisc_exec
parameter_list|(
name|struct
name|image_params
modifier|*
name|imgp
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|image_header
init|=
name|imgp
operator|->
name|image_header
decl_stmt|;
specifier|const
name|char
modifier|*
name|fname
init|=
name|NULL
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|size_t
name|offset
decl_stmt|,
name|l
decl_stmt|;
name|imgact_binmisc_entry_t
modifier|*
name|ibe
decl_stmt|;
name|struct
name|sbuf
modifier|*
name|sname
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|d
decl_stmt|;
comment|/* Do we have an interpreter for the given image header? */
name|sx_slock
argument_list|(
operator|&
name|interp_list_sx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ibe
operator|=
name|imgact_binmisc_find_interpreter
argument_list|(
name|image_header
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|sx_sunlock
argument_list|(
operator|&
name|interp_list_sx
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* No interpreter nesting allowed. */
if|if
condition|(
name|imgp
operator|->
name|interpreted
operator|&
name|IMGACT_BINMISC
condition|)
block|{
name|sx_sunlock
argument_list|(
operator|&
name|interp_list_sx
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOEXEC
operator|)
return|;
block|}
name|imgp
operator|->
name|interpreted
operator||=
name|IMGACT_BINMISC
expr_stmt|;
if|if
condition|(
name|imgp
operator|->
name|args
operator|->
name|fname
operator|!=
name|NULL
condition|)
block|{
name|fname
operator|=
name|imgp
operator|->
name|args
operator|->
name|fname
expr_stmt|;
name|sname
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
comment|/* Use the fdescfs(5) path for fexecve(2). */
name|sname
operator|=
name|sbuf_new_auto
argument_list|()
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sname
argument_list|,
literal|"/dev/fd/%d"
argument_list|,
name|imgp
operator|->
name|args
operator|->
name|fd
argument_list|)
expr_stmt|;
name|sbuf_finish
argument_list|(
name|sname
argument_list|)
expr_stmt|;
name|fname
operator|=
name|sbuf_data
argument_list|(
name|sname
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * We need to "push" the interpreter in the arg[] list.  To do this, 	 * we first shift all the other values in the `begin_argv' area to 	 * provide the exact amount of room for the values added.  Set up 	 * `offset' as the number of bytes to be added to the `begin_argv' 	 * area. 	 */
name|offset
operator|=
name|ibe
operator|->
name|ibe_interp_length
expr_stmt|;
comment|/* Adjust the offset for #'s. */
name|s
operator|=
name|ibe
operator|->
name|ibe_interpreter
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|s
operator|=
name|strchr
argument_list|(
name|s
argument_list|,
literal|'#'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|s
condition|)
break|break;
name|s
operator|++
expr_stmt|;
switch|switch
condition|(
operator|*
name|s
condition|)
block|{
case|case
name|ISM_POUND
case|:
comment|/* "##" -> "#": reduce offset by one. */
name|offset
operator|--
expr_stmt|;
break|break;
case|case
name|ISM_OLD_ARGV0
case|:
comment|/* "#a" -> (old argv0): increase offset to fit fname */
name|offset
operator|+=
name|strlen
argument_list|(
name|fname
argument_list|)
operator|-
literal|2
expr_stmt|;
break|break;
default|default:
comment|/* Hmm... This shouldn't happen. */
name|sx_sunlock
argument_list|(
operator|&
name|interp_list_sx
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s: Unknown macro #%c sequence in "
literal|"interpreter string\n"
argument_list|,
name|KMOD_NAME
argument_list|,
operator|*
operator|(
name|s
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|s
operator|++
expr_stmt|;
block|}
comment|/* Check to make sure we won't overrun the stringspace. */
if|if
condition|(
name|offset
operator|>
name|imgp
operator|->
name|args
operator|->
name|stringspace
condition|)
block|{
name|sx_sunlock
argument_list|(
operator|&
name|interp_list_sx
argument_list|)
expr_stmt|;
name|error
operator|=
name|E2BIG
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* Make room for the interpreter */
name|bcopy
argument_list|(
name|imgp
operator|->
name|args
operator|->
name|begin_argv
argument_list|,
name|imgp
operator|->
name|args
operator|->
name|begin_argv
operator|+
name|offset
argument_list|,
name|imgp
operator|->
name|args
operator|->
name|endp
operator|-
name|imgp
operator|->
name|args
operator|->
name|begin_argv
argument_list|)
expr_stmt|;
comment|/* Adjust everything by the offset. */
name|imgp
operator|->
name|args
operator|->
name|begin_envv
operator|+=
name|offset
expr_stmt|;
name|imgp
operator|->
name|args
operator|->
name|endp
operator|+=
name|offset
expr_stmt|;
name|imgp
operator|->
name|args
operator|->
name|stringspace
operator|-=
name|offset
expr_stmt|;
comment|/* Add the new argument(s) in the count. */
name|imgp
operator|->
name|args
operator|->
name|argc
operator|+=
name|ibe
operator|->
name|ibe_interp_argcnt
expr_stmt|;
comment|/* 	 * The original arg[] list has been shifted appropriately.  Copy in 	 * the interpreter path. 	 */
name|s
operator|=
name|ibe
operator|->
name|ibe_interpreter
expr_stmt|;
name|d
operator|=
name|imgp
operator|->
name|args
operator|->
name|begin_argv
expr_stmt|;
while|while
condition|(
operator|*
name|s
operator|!=
literal|'\0'
condition|)
block|{
switch|switch
condition|(
operator|*
name|s
condition|)
block|{
case|case
literal|'#'
case|:
comment|/* Handle "#" in interpreter string. */
name|s
operator|++
expr_stmt|;
switch|switch
condition|(
operator|*
name|s
condition|)
block|{
case|case
name|ISM_POUND
case|:
comment|/* "##": Replace with a single '#' */
operator|*
name|d
operator|++
operator|=
literal|'#'
expr_stmt|;
break|break;
case|case
name|ISM_OLD_ARGV0
case|:
comment|/* "#a": Replace with old arg0 (fname). */
if|if
condition|(
operator|(
name|l
operator|=
name|strlen
argument_list|(
name|fname
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|memcpy
argument_list|(
name|d
argument_list|,
name|fname
argument_list|,
name|l
argument_list|)
expr_stmt|;
name|d
operator|+=
name|l
expr_stmt|;
block|}
break|break;
default|default:
comment|/* Shouldn't happen but skip it if it does. */
break|break;
block|}
break|break;
case|case
literal|' '
case|:
comment|/* Replace space with NUL to separate arguments. */
operator|*
name|d
operator|++
operator|=
literal|'\0'
expr_stmt|;
break|break;
default|default:
operator|*
name|d
operator|++
operator|=
operator|*
name|s
expr_stmt|;
break|break;
block|}
name|s
operator|++
expr_stmt|;
block|}
operator|*
name|d
operator|=
literal|'\0'
expr_stmt|;
name|sx_sunlock
argument_list|(
operator|&
name|interp_list_sx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
name|imgp
operator|->
name|interpreter_name
operator|=
name|imgp
operator|->
name|args
operator|->
name|begin_argv
expr_stmt|;
name|done
label|:
if|if
condition|(
name|sname
condition|)
name|sbuf_delete
argument_list|(
name|sname
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|imgact_binmisc_init
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|sx_init
argument_list|(
operator|&
name|interp_list_sx
argument_list|,
name|KMOD_NAME
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|imgact_binmisc_fini
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|imgact_binmisc_entry_t
modifier|*
name|ibe
decl_stmt|,
modifier|*
name|ibe_tmp
decl_stmt|;
comment|/* Free all the interpreters. */
name|sx_xlock
argument_list|(
operator|&
name|interp_list_sx
argument_list|)
expr_stmt|;
name|SLIST_FOREACH_SAFE
argument_list|(
argument|ibe
argument_list|,
argument|&interpreter_list
argument_list|,
argument|link
argument_list|,
argument|ibe_tmp
argument_list|)
block|{
name|SLIST_REMOVE
argument_list|(
operator|&
name|interpreter_list
argument_list|,
name|ibe
argument_list|,
name|imgact_binmisc_entry
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|imgact_binmisc_destroy_entry
argument_list|(
name|ibe
argument_list|)
expr_stmt|;
block|}
name|sx_xunlock
argument_list|(
operator|&
name|interp_list_sx
argument_list|)
expr_stmt|;
name|sx_destroy
argument_list|(
operator|&
name|interp_list_sx
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|SYSINIT
argument_list|(
name|imgact_binmisc
argument_list|,
name|SI_SUB_EXEC
argument_list|,
name|SI_ORDER_MIDDLE
argument_list|,
name|imgact_binmisc_init
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSUNINIT
argument_list|(
name|imgact_binmisc
argument_list|,
name|SI_SUB_EXEC
argument_list|,
name|SI_ORDER_MIDDLE
argument_list|,
name|imgact_binmisc_fini
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Tell kern_execve.c about it, with a little help from the linker.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|execsw
name|imgact_binmisc_execsw
init|=
block|{
name|imgact_binmisc_exec
block|,
name|KMOD_NAME
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|EXEC_SET
argument_list|(
name|imgact_binmisc
argument_list|,
name|imgact_binmisc_execsw
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

