begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1986, 1988, 1991, 1993  *	The Regents of the University of California.  All rights reserved.  * (c) UNIX System Laboratories, Inc.  * All or some portions of this file are derived from material licensed  * to the University of California by American Telephone and Telegraph  * Co. or Unix System Laboratories, Inc. and are reproduced herein with  * the permission of UNIX System Laboratories, Inc.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *	@(#)kern_shutdown.c	8.3 (Berkeley) 1/21/94  * $Id: kern_shutdown.c,v 1.1 1996/08/19 02:19:21 julian Exp $  */
end_comment

begin_include
include|#
directive|include
file|"opt_ddb.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/reboot.h>
end_include

begin_include
include|#
directive|include
file|<sys/msgbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/vnode.h>
end_include

begin_include
include|#
directive|include
file|<sys/tty.h>
end_include

begin_include
include|#
directive|include
file|<sys/tprintf.h>
end_include

begin_include
include|#
directive|include
file|<sys/syslog.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/devconf.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysproto.h>
end_include

begin_include
include|#
directive|include
file|<machine/pcb.h>
end_include

begin_include
include|#
directive|include
file|<machine/clock.h>
end_include

begin_include
include|#
directive|include
file|<machine/cons.h>
end_include

begin_include
include|#
directive|include
file|<machine/md_var.h>
end_include

begin_include
include|#
directive|include
file|<sys/utsname.h>
end_include

begin_include
include|#
directive|include
file|<sys/signalvar.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|PANIC_REBOOT_WAIT_TIME
end_ifndef

begin_define
define|#
directive|define
name|PANIC_REBOOT_WAIT_TIME
value|15
end_define

begin_comment
comment|/* default to 15 seconds */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Note that stdarg.h and the ANSI style va_start macro is used for both  * ANSI and traditional C compilers.  */
end_comment

begin_include
include|#
directive|include
file|<machine/stdarg.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|DDB
argument_list|)
end_if

begin_ifdef
ifdef|#
directive|ifdef
name|DDB_UNATTENDED
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|debugger_on_panic
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|static
name|int
name|debugger_on_panic
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_debug
argument_list|,
name|OID_AUTO
argument_list|,
name|debugger_on_panic
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|debugger_on_panic
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Variable panicstr contains argument to first call to panic; used as flag  * to indicate that the kernel has already called panic.  */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|panicstr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * callout list for things to do a shutdown  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|shutdown_list_element
block|{
name|struct
name|shutdown_list_element
modifier|*
name|next
decl_stmt|;
name|bootlist_fn
name|function
decl_stmt|;
name|void
modifier|*
name|arg
decl_stmt|;
block|}
typedef|*
name|sle_p
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|sle_p
name|shutdown_list
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This implements a "TEXT_SET" for cleanup functions */
end_comment

begin_decl_stmt
specifier|static
name|void
name|dummy_cleanup
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|dummy_cleanup
parameter_list|()
block|{}
end_function

begin_expr_stmt
name|TEXT_SET
argument_list|(
name|cleanup_set
argument_list|,
name|dummy_cleanup
argument_list|)
expr_stmt|;
end_expr_stmt

begin_typedef
typedef|typedef
name|void
function_decl|(
modifier|*
name|cleanup_func_t
function_decl|)
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_typedef

begin_decl_stmt
specifier|extern
specifier|const
name|struct
name|linker_set
name|cleanup_set
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|cleanup_func_t
modifier|*
name|cleanups
init|=
operator|(
specifier|const
name|cleanup_func_t
operator|*
operator|)
operator|&
name|cleanup_set
operator|.
name|ls_items
index|[
literal|0
index|]
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|dumpsys
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_ifndef
ifndef|#
directive|ifndef
name|_SYS_SYSPROTO_H_
end_ifndef

begin_struct
struct|struct
name|reboot_args
block|{
name|int
name|opt
decl_stmt|;
block|}
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ARGSUSED */
end_comment

begin_comment
comment|/*  * The system call that results in a reboot  */
end_comment

begin_function
name|int
name|reboot
parameter_list|(
name|p
parameter_list|,
name|uap
parameter_list|,
name|retval
parameter_list|)
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|struct
name|reboot_args
modifier|*
name|uap
decl_stmt|;
name|int
modifier|*
name|retval
decl_stmt|;
block|{
name|int
name|error
decl_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|suser
argument_list|(
name|p
operator|->
name|p_ucred
argument_list|,
operator|&
name|p
operator|->
name|p_acflag
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|boot
argument_list|(
name|uap
operator|->
name|opt
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Called by events that want to shut down.. e.g<CTL><ALT><DEL> on a PC  */
end_comment

begin_function
name|void
name|shutdown_nice
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* Send a signal to init(8) and have it shutdown the world */
if|if
condition|(
name|initproc
operator|!=
name|NULL
condition|)
block|{
name|psignal
argument_list|(
name|initproc
argument_list|,
name|SIGINT
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* No init(8) running, so simply reboot */
name|boot
argument_list|(
name|RB_NOSYNC
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_decl_stmt
specifier|static
name|int
name|waittime
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|pcb
name|dumppcb
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  *  Go through the rigmarole of shutting down..  * this used to be in machdep.c but I'll be dammned if I could see  * anything machine dependant in it.  */
end_comment

begin_function
name|__dead
name|void
name|boot
parameter_list|(
name|howto
parameter_list|)
name|int
name|howto
decl_stmt|;
block|{
name|sle_p
name|ep
init|=
name|shutdown_list
decl_stmt|;
comment|/* 	 * eventually the at_shutdown() method will totally replace the 	 * linker set but for now leave them both (so 3rd partys 	 * modules that might use it can not break). 	 * The linker set is no good for LKMs etc. 	 */
if|if
condition|(
operator|(
name|howto
operator|&
name|RB_NOSYNC
operator|)
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"\ncleaning up... "
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|cleanups
condition|)
block|{
name|printf
argument_list|(
literal|"Using obsolete shutdown callout..\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"update code to use at_shutdown()\n"
argument_list|)
expr_stmt|;
operator|(
operator|*
operator|*
name|cleanups
operator|++
operator|)
operator|(
operator|)
expr_stmt|;
block|}
block|}
while|while
condition|(
name|ep
condition|)
block|{
name|shutdown_list
operator|=
name|ep
operator|->
name|next
expr_stmt|;
call|(
modifier|*
name|ep
operator|->
name|function
call|)
argument_list|(
name|howto
argument_list|,
name|ep
operator|->
name|arg
argument_list|)
expr_stmt|;
name|ep
operator|=
name|ep
operator|->
name|next
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|cold
operator|&&
operator|(
name|howto
operator|&
name|RB_NOSYNC
operator|)
operator|==
literal|0
operator|&&
name|waittime
operator|<
literal|0
condition|)
block|{
specifier|register
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|int
name|iter
decl_stmt|,
name|nbusy
decl_stmt|;
name|waittime
operator|=
literal|0
expr_stmt|;
name|printf
argument_list|(
literal|"\nsyncing disks... "
argument_list|)
expr_stmt|;
name|sync
argument_list|(
operator|&
name|proc0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
for|for
control|(
name|iter
operator|=
literal|0
init|;
name|iter
operator|<
literal|20
condition|;
name|iter
operator|++
control|)
block|{
name|nbusy
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|bp
operator|=
operator|&
name|buf
index|[
name|nbuf
index|]
init|;
operator|--
name|bp
operator|>=
name|buf
condition|;
control|)
block|{
if|if
condition|(
operator|(
name|bp
operator|->
name|b_flags
operator|&
operator|(
name|B_BUSY
operator||
name|B_INVAL
operator|)
operator|)
operator|==
name|B_BUSY
condition|)
block|{
name|nbusy
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|nbusy
operator|==
literal|0
condition|)
break|break;
name|printf
argument_list|(
literal|"%d "
argument_list|,
name|nbusy
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|40000
operator|*
name|iter
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nbusy
condition|)
block|{
comment|/* 			 * Failed to sync all blocks. Indicate this and don't 			 * unmount filesystems (thus forcing an fsck on reboot). 			 */
name|printf
argument_list|(
literal|"giving up\n"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SHOW_BUSYBUFS
name|nbusy
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|bp
operator|=
operator|&
name|buf
index|[
name|nbuf
index|]
init|;
operator|--
name|bp
operator|>=
name|buf
condition|;
control|)
block|{
if|if
condition|(
operator|(
name|bp
operator|->
name|b_flags
operator|&
operator|(
name|B_BUSY
operator||
name|B_INVAL
operator|)
operator|)
operator|==
name|B_BUSY
condition|)
block|{
name|nbusy
operator|++
expr_stmt|;
name|printf
argument_list|(
literal|"%d: dev:%08x, flags:%08x, blkno:%d, lblkno:%d\n"
argument_list|,
name|nbusy
argument_list|,
name|bp
operator|->
name|b_dev
argument_list|,
name|bp
operator|->
name|b_flags
argument_list|,
name|bp
operator|->
name|b_blkno
argument_list|,
name|bp
operator|->
name|b_lblkno
argument_list|)
expr_stmt|;
block|}
block|}
name|DELAY
argument_list|(
literal|5000000
argument_list|)
expr_stmt|;
comment|/* 5 seconds */
endif|#
directive|endif
block|}
else|else
block|{
name|printf
argument_list|(
literal|"done\n"
argument_list|)
expr_stmt|;
comment|/* 			 * Unmount filesystems 			 */
if|if
condition|(
name|panicstr
operator|==
literal|0
condition|)
name|vfs_unmountall
argument_list|()
expr_stmt|;
block|}
name|DELAY
argument_list|(
literal|100000
argument_list|)
expr_stmt|;
comment|/* wait for console output to finish */
name|dev_shutdownall
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
block|}
name|splhigh
argument_list|()
expr_stmt|;
if|if
condition|(
name|howto
operator|&
name|RB_HALT
condition|)
block|{
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"The operating system has halted.\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Please press any key to reboot.\n\n"
argument_list|)
expr_stmt|;
name|cngetc
argument_list|()
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|howto
operator|&
name|RB_DUMP
condition|)
block|{
if|if
condition|(
operator|!
name|cold
condition|)
block|{
name|savectx
argument_list|(
operator|&
name|dumppcb
argument_list|)
expr_stmt|;
name|dumppcb
operator|.
name|pcb_cr3
operator|=
name|rcr3
argument_list|()
expr_stmt|;
name|dumpsys
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|PANIC_REBOOT_WAIT_TIME
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|PANIC_REBOOT_WAIT_TIME
operator|!=
operator|-
literal|1
condition|)
block|{
name|int
name|loop
decl_stmt|;
name|printf
argument_list|(
literal|"Automatic reboot in %d seconds - press a key on the console to abort\n"
argument_list|,
name|PANIC_REBOOT_WAIT_TIME
argument_list|)
expr_stmt|;
for|for
control|(
name|loop
operator|=
name|PANIC_REBOOT_WAIT_TIME
operator|*
literal|10
init|;
name|loop
operator|>
literal|0
condition|;
operator|--
name|loop
control|)
block|{
name|DELAY
argument_list|(
literal|1000
operator|*
literal|100
argument_list|)
expr_stmt|;
comment|/* 1/10th second */
if|if
condition|(
name|cncheckc
argument_list|()
condition|)
comment|/* Did user type a key? */
break|break;
block|}
if|if
condition|(
operator|!
name|loop
condition|)
goto|goto
name|die
goto|;
block|}
block|}
else|else
block|{
comment|/* zero time specified - reboot NOW */
goto|goto
name|die
goto|;
block|}
name|printf
argument_list|(
literal|"--> Press a key on the console to reboot<--\n"
argument_list|)
expr_stmt|;
name|cngetc
argument_list|()
expr_stmt|;
block|}
block|}
name|die
label|:
name|printf
argument_list|(
literal|"Rebooting...\n"
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1000000
argument_list|)
expr_stmt|;
comment|/* wait 1 sec for printf's to complete and be read */
comment|/* cpu_boot(howto); */
comment|/* doesn't do anything at the moment */
name|cpu_reset
argument_list|()
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
empty_stmt|;
comment|/* NOTREACHED */
block|}
end_function

begin_comment
comment|/*  * Magic number for savecore  *  * exported (symorder) and used at least by savecore(8)  *  */
end_comment

begin_decl_stmt
specifier|static
name|u_long
specifier|const
name|dumpmag
init|=
literal|0x8fca0101UL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|dumpsize
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* also for savecore */
end_comment

begin_decl_stmt
specifier|static
name|int
name|dodump
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_machdep
argument_list|,
name|OID_AUTO
argument_list|,
name|do_dump
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|dodump
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Doadump comes here after turning off memory management and  * getting on the dump stack, either when called above, or by  * the auto-restart code.  */
end_comment

begin_function
specifier|static
name|void
name|dumpsys
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
name|dodump
condition|)
return|return;
if|if
condition|(
name|dumpdev
operator|==
name|NODEV
condition|)
return|return;
if|if
condition|(
operator|(
name|minor
argument_list|(
name|dumpdev
argument_list|)
operator|&
literal|07
operator|)
operator|!=
literal|1
condition|)
return|return;
if|if
condition|(
operator|!
operator|(
name|bdevsw
index|[
name|major
argument_list|(
name|dumpdev
argument_list|)
index|]
operator|)
condition|)
return|return;
if|if
condition|(
operator|!
operator|(
name|bdevsw
index|[
name|major
argument_list|(
name|dumpdev
argument_list|)
index|]
operator|->
name|d_dump
operator|)
condition|)
return|return;
name|dumpsize
operator|=
name|Maxmem
expr_stmt|;
name|printf
argument_list|(
literal|"\ndumping to dev %lx, offset %ld\n"
argument_list|,
name|dumpdev
argument_list|,
name|dumplo
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"dump "
argument_list|)
expr_stmt|;
switch|switch
condition|(
operator|(
operator|*
name|bdevsw
index|[
name|major
argument_list|(
name|dumpdev
argument_list|)
index|]
operator|->
name|d_dump
operator|)
operator|(
name|dumpdev
operator|)
condition|)
block|{
case|case
name|ENXIO
case|:
name|printf
argument_list|(
literal|"device bad\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EFAULT
case|:
name|printf
argument_list|(
literal|"device not ready\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EINVAL
case|:
name|printf
argument_list|(
literal|"area improper\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EIO
case|:
name|printf
argument_list|(
literal|"i/o error\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EINTR
case|:
name|printf
argument_list|(
literal|"aborted from console\n"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"succeeded\n"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/*  * Panic is called on unresolvable fatal errors.  It prints "panic: mesg",  * and then reboots.  If we are called twice, then we avoid trying to sync  * the disks as this often leads to recursive panics.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__GNUC__
end_ifdef

begin_function
name|__dead
comment|/* panic() does not return */
endif|#
directive|endif
name|void
name|panic
parameter_list|(
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|int
name|bootopt
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
name|bootopt
operator|=
name|RB_AUTOBOOT
operator||
name|RB_DUMP
expr_stmt|;
if|if
condition|(
name|panicstr
condition|)
name|bootopt
operator||=
name|RB_NOSYNC
expr_stmt|;
else|else
name|panicstr
operator|=
name|fmt
expr_stmt|;
name|printf
argument_list|(
literal|"panic: "
argument_list|)
expr_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|vprintf
argument_list|(
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|DDB
argument_list|)
if|if
condition|(
name|debugger_on_panic
condition|)
name|Debugger
argument_list|(
literal|"panic"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|boot
argument_list|(
name|bootopt
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*********************************************************  * general routines to handle adding/deleting items on the  * shutdown callout list  *****  * Take the arguments given and put them onto the shutdown callout list.  * However first make sure that it's not already there.  * returns 0 on success.  */
end_comment

begin_function
name|int
name|at_shutdown
parameter_list|(
name|bootlist_fn
name|function
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|sle_p
name|ep
decl_stmt|;
if|if
condition|(
name|rm_at_shutdown
argument_list|(
name|function
argument_list|,
name|arg
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"exit callout entry already present\n"
argument_list|)
expr_stmt|;
block|}
name|ep
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|ep
argument_list|)
argument_list|,
name|M_TEMP
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ep
condition|)
return|return
name|ENOMEM
return|;
name|ep
operator|->
name|next
operator|=
name|shutdown_list
expr_stmt|;
name|ep
operator|->
name|function
operator|=
name|function
expr_stmt|;
name|ep
operator|->
name|arg
operator|=
name|arg
expr_stmt|;
name|shutdown_list
operator|=
name|ep
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Scan the exit callout list for the given items and remove them.  * Returns the number of items removed.  */
end_comment

begin_function
name|int
name|rm_at_shutdown
parameter_list|(
name|bootlist_fn
name|function
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|sle_p
modifier|*
name|epp
decl_stmt|,
name|ep
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|;
name|epp
operator|=
operator|&
name|shutdown_list
expr_stmt|;
name|ep
operator|=
operator|*
name|epp
expr_stmt|;
while|while
condition|(
name|ep
condition|)
block|{
if|if
condition|(
operator|(
name|ep
operator|->
name|function
operator|==
name|function
operator|)
operator|&&
operator|(
name|ep
operator|->
name|arg
operator|=
name|arg
operator|)
condition|)
block|{
operator|*
name|epp
operator|=
name|ep
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|ep
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
else|else
block|{
name|epp
operator|=
operator|&
name|ep
operator|->
name|next
expr_stmt|;
block|}
name|ep
operator|=
operator|*
name|epp
expr_stmt|;
block|}
return|return
name|count
return|;
block|}
end_function

end_unit

