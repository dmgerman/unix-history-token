begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1986, 1988, 1991, 1993  *	The Regents of the University of California.  All rights reserved.  * (c) UNIX System Laboratories, Inc.  * All or some portions of this file are derived from material licensed  * to the University of California by American Telephone and Telegraph  * Co. or Unix System Laboratories, Inc. and are reproduced herein with  * the permission of UNIX System Laboratories, Inc.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *	@(#)kern_shutdown.c	8.3 (Berkeley) 1/21/94  * $Id: kern_shutdown.c,v 1.25 1997/11/06 19:29:13 phk Exp $  */
end_comment

begin_include
include|#
directive|include
file|"opt_ddb.h"
end_include

begin_include
include|#
directive|include
file|"opt_panic.h"
end_include

begin_include
include|#
directive|include
file|"opt_show_busybufs.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/buf.h>
end_include

begin_include
include|#
directive|include
file|<sys/reboot.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/mount.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysproto.h>
end_include

begin_include
include|#
directive|include
file|<machine/pcb.h>
end_include

begin_include
include|#
directive|include
file|<machine/clock.h>
end_include

begin_include
include|#
directive|include
file|<machine/cons.h>
end_include

begin_include
include|#
directive|include
file|<machine/md_var.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|SMP
end_ifdef

begin_include
include|#
directive|include
file|<machine/smp.h>
end_include

begin_comment
comment|/* smp_active, cpuid */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/signalvar.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|PANIC_REBOOT_WAIT_TIME
end_ifndef

begin_define
define|#
directive|define
name|PANIC_REBOOT_WAIT_TIME
value|15
end_define

begin_comment
comment|/* default to 15 seconds */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Note that stdarg.h and the ANSI style va_start macro is used for both  * ANSI and traditional C compilers.  */
end_comment

begin_include
include|#
directive|include
file|<machine/stdarg.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|DDB
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|DDB_UNATTENDED
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|debugger_on_panic
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|static
name|int
name|debugger_on_panic
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_debug
argument_list|,
name|OID_AUTO
argument_list|,
name|debugger_on_panic
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|debugger_on_panic
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HW_WDOG
end_ifdef

begin_comment
comment|/*  * If there is a hardware watchdog, point this at the function needed to  * hold it off.  * It's needed when the kernel needs to do some lengthy operations.  * e.g. in wd.c when dumping core.. It's most annoying to have  * your precious core-dump only half written because the wdog kicked in.  */
end_comment

begin_decl_stmt
name|watchdog_tickle_fn
name|wdog_tickler
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HW_WDOG */
end_comment

begin_comment
comment|/*  * Variable panicstr contains argument to first call to panic; used as flag  * to indicate that the kernel has already called panic.  */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|panicstr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * callout list for things to do a shutdown  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|shutdown_list_element
block|{
name|struct
name|shutdown_list_element
modifier|*
name|next
decl_stmt|;
name|bootlist_fn
name|function
decl_stmt|;
name|void
modifier|*
name|arg
decl_stmt|;
block|}
typedef|*
name|sle_p
typedef|;
end_typedef

begin_comment
comment|/*  * there are two shutdown lists. Some things need to be shut down  * Earlier than others.  */
end_comment

begin_decl_stmt
specifier|static
name|sle_p
name|shutdown_list1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|sle_p
name|shutdown_list2
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|boot
name|__P
argument_list|(
operator|(
name|int
operator|)
argument_list|)
name|__dead2
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dumpsys
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|_SYS_SYSPROTO_H_
end_ifndef

begin_struct
struct|struct
name|reboot_args
block|{
name|int
name|opt
decl_stmt|;
block|}
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ARGSUSED */
end_comment

begin_comment
comment|/*  * The system call that results in a reboot  */
end_comment

begin_function
name|int
name|reboot
parameter_list|(
name|p
parameter_list|,
name|uap
parameter_list|)
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|struct
name|reboot_args
modifier|*
name|uap
decl_stmt|;
block|{
name|int
name|error
decl_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|suser
argument_list|(
name|p
operator|->
name|p_ucred
argument_list|,
operator|&
name|p
operator|->
name|p_acflag
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|boot
argument_list|(
name|uap
operator|->
name|opt
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Called by events that want to shut down.. e.g<CTL><ALT><DEL> on a PC  */
end_comment

begin_function
name|void
name|shutdown_nice
parameter_list|()
block|{
comment|/* Send a signal to init(8) and have it shutdown the world */
if|if
condition|(
name|initproc
operator|!=
name|NULL
condition|)
block|{
name|psignal
argument_list|(
name|initproc
argument_list|,
name|SIGINT
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* No init(8) running, so simply reboot */
name|boot
argument_list|(
name|RB_NOSYNC
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_decl_stmt
specifier|static
name|int
name|waittime
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|pcb
name|dumppcb
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  *  Go through the rigmarole of shutting down..  * this used to be in machdep.c but I'll be dammned if I could see  * anything machine dependant in it.  */
end_comment

begin_function
specifier|static
name|void
name|boot
parameter_list|(
name|howto
parameter_list|)
name|int
name|howto
decl_stmt|;
block|{
name|sle_p
name|ep
decl_stmt|;
ifdef|#
directive|ifdef
name|SMP
name|int
name|c
decl_stmt|,
name|spins
decl_stmt|;
comment|/* The MPSPEC says that the BSP must do the shutdown */
if|if
condition|(
name|smp_active
condition|)
block|{
name|smp_active
operator|=
literal|0
expr_stmt|;
name|spins
operator|=
literal|100
expr_stmt|;
name|printf
argument_list|(
literal|"boot() called on cpu#%d\n"
argument_list|,
name|cpuid
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|cpuid
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|spins
operator|--
operator|<
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"timeout waiting for cpu #0!\n"
argument_list|)
expr_stmt|;
break|break;
block|}
name|printf
argument_list|(
literal|"I'm on cpu#%d, I need to be on cpu#0, sleeping..\n"
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|smp_active
argument_list|,
name|PZERO
argument_list|,
literal|"cpu0wt"
argument_list|,
literal|10
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* 	 * Do any callouts that should be done BEFORE syncing the filesystems. 	 */
name|ep
operator|=
name|shutdown_list1
expr_stmt|;
while|while
condition|(
name|ep
condition|)
block|{
name|shutdown_list1
operator|=
name|ep
operator|->
name|next
expr_stmt|;
call|(
modifier|*
name|ep
operator|->
name|function
call|)
argument_list|(
name|howto
argument_list|,
name|ep
operator|->
name|arg
argument_list|)
expr_stmt|;
name|ep
operator|=
name|ep
operator|->
name|next
expr_stmt|;
block|}
comment|/*  	 * Now sync filesystems 	 */
if|if
condition|(
operator|!
name|cold
operator|&&
operator|(
name|howto
operator|&
name|RB_NOSYNC
operator|)
operator|==
literal|0
operator|&&
name|waittime
operator|<
literal|0
condition|)
block|{
specifier|register
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|int
name|iter
decl_stmt|,
name|nbusy
decl_stmt|;
name|waittime
operator|=
literal|0
expr_stmt|;
name|printf
argument_list|(
literal|"\nsyncing disks... "
argument_list|)
expr_stmt|;
name|sync
argument_list|(
operator|&
name|proc0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
for|for
control|(
name|iter
operator|=
literal|0
init|;
name|iter
operator|<
literal|20
condition|;
name|iter
operator|++
control|)
block|{
name|nbusy
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|bp
operator|=
operator|&
name|buf
index|[
name|nbuf
index|]
init|;
operator|--
name|bp
operator|>=
name|buf
condition|;
control|)
block|{
if|if
condition|(
operator|(
name|bp
operator|->
name|b_flags
operator|&
operator|(
name|B_BUSY
operator||
name|B_INVAL
operator|)
operator|)
operator|==
name|B_BUSY
condition|)
block|{
name|nbusy
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|nbusy
operator|==
literal|0
condition|)
break|break;
name|printf
argument_list|(
literal|"%d "
argument_list|,
name|nbusy
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|40000
operator|*
name|iter
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nbusy
condition|)
block|{
comment|/* 			 * Failed to sync all blocks. Indicate this and don't 			 * unmount filesystems (thus forcing an fsck on reboot). 			 */
name|printf
argument_list|(
literal|"giving up\n"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SHOW_BUSYBUFS
name|nbusy
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|bp
operator|=
operator|&
name|buf
index|[
name|nbuf
index|]
init|;
operator|--
name|bp
operator|>=
name|buf
condition|;
control|)
block|{
if|if
condition|(
operator|(
name|bp
operator|->
name|b_flags
operator|&
operator|(
name|B_BUSY
operator||
name|B_INVAL
operator|)
operator|)
operator|==
name|B_BUSY
condition|)
block|{
name|nbusy
operator|++
expr_stmt|;
name|printf
argument_list|(
literal|"%d: dev:%08x, flags:%08x, blkno:%d, lblkno:%d\n"
argument_list|,
name|nbusy
argument_list|,
name|bp
operator|->
name|b_dev
argument_list|,
name|bp
operator|->
name|b_flags
argument_list|,
name|bp
operator|->
name|b_blkno
argument_list|,
name|bp
operator|->
name|b_lblkno
argument_list|)
expr_stmt|;
block|}
block|}
name|DELAY
argument_list|(
literal|5000000
argument_list|)
expr_stmt|;
comment|/* 5 seconds */
endif|#
directive|endif
block|}
else|else
block|{
name|printf
argument_list|(
literal|"done\n"
argument_list|)
expr_stmt|;
comment|/* 			 * Unmount filesystems 			 */
if|if
condition|(
name|panicstr
operator|==
literal|0
condition|)
name|vfs_unmountall
argument_list|()
expr_stmt|;
block|}
name|DELAY
argument_list|(
literal|100000
argument_list|)
expr_stmt|;
comment|/* wait for console output to finish */
block|}
comment|/* 	 * Ok, now do things that assume all filesystem activity has 	 * been completed. 	 */
name|ep
operator|=
name|shutdown_list2
expr_stmt|;
while|while
condition|(
name|ep
condition|)
block|{
name|shutdown_list2
operator|=
name|ep
operator|->
name|next
expr_stmt|;
call|(
modifier|*
name|ep
operator|->
name|function
call|)
argument_list|(
name|howto
argument_list|,
name|ep
operator|->
name|arg
argument_list|)
expr_stmt|;
name|ep
operator|=
name|ep
operator|->
name|next
expr_stmt|;
block|}
name|splhigh
argument_list|()
expr_stmt|;
if|if
condition|(
name|howto
operator|&
name|RB_HALT
condition|)
block|{
name|cpu_power_down
argument_list|()
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"The operating system has halted.\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Please press any key to reboot.\n\n"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|cngetc
argument_list|()
condition|)
block|{
case|case
operator|-
literal|1
case|:
comment|/* No console, just die */
name|cpu_halt
argument_list|()
expr_stmt|;
comment|/* NOTREACHED */
default|default:
break|break;
block|}
block|}
else|else
block|{
if|if
condition|(
name|howto
operator|&
name|RB_DUMP
condition|)
block|{
if|if
condition|(
operator|!
name|cold
condition|)
block|{
name|savectx
argument_list|(
operator|&
name|dumppcb
argument_list|)
expr_stmt|;
name|dumppcb
operator|.
name|pcb_cr3
operator|=
name|rcr3
argument_list|()
expr_stmt|;
name|dumpsys
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|PANIC_REBOOT_WAIT_TIME
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|PANIC_REBOOT_WAIT_TIME
operator|!=
operator|-
literal|1
condition|)
block|{
name|int
name|loop
decl_stmt|;
name|printf
argument_list|(
literal|"Automatic reboot in %d seconds - press a key on the console to abort\n"
argument_list|,
name|PANIC_REBOOT_WAIT_TIME
argument_list|)
expr_stmt|;
for|for
control|(
name|loop
operator|=
name|PANIC_REBOOT_WAIT_TIME
operator|*
literal|10
init|;
name|loop
operator|>
literal|0
condition|;
operator|--
name|loop
control|)
block|{
name|DELAY
argument_list|(
literal|1000
operator|*
literal|100
argument_list|)
expr_stmt|;
comment|/* 1/10th second */
comment|/* Did user type a key? */
if|if
condition|(
name|cncheckc
argument_list|()
operator|!=
operator|-
literal|1
condition|)
break|break;
block|}
if|if
condition|(
operator|!
name|loop
condition|)
goto|goto
name|die
goto|;
block|}
block|}
else|else
block|{
comment|/* zero time specified - reboot NOW */
goto|goto
name|die
goto|;
block|}
name|printf
argument_list|(
literal|"--> Press a key on the console to reboot<--\n"
argument_list|)
expr_stmt|;
name|cngetc
argument_list|()
expr_stmt|;
block|}
block|}
name|die
label|:
name|printf
argument_list|(
literal|"Rebooting...\n"
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1000000
argument_list|)
expr_stmt|;
comment|/* wait 1 sec for printf's to complete and be read */
comment|/* cpu_boot(howto); */
comment|/* doesn't do anything at the moment */
name|cpu_reset
argument_list|()
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
empty_stmt|;
comment|/* NOTREACHED */
block|}
end_function

begin_comment
comment|/*  * Magic number for savecore  *  * exported (symorder) and used at least by savecore(8)  *  */
end_comment

begin_decl_stmt
specifier|static
name|u_long
specifier|const
name|dumpmag
init|=
literal|0x8fca0101UL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|dumpsize
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* also for savecore */
end_comment

begin_decl_stmt
specifier|static
name|int
name|dodump
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_machdep
argument_list|,
name|OID_AUTO
argument_list|,
name|do_dump
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|dodump
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Doadump comes here after turning off memory management and  * getting on the dump stack, either when called above, or by  * the auto-restart code.  */
end_comment

begin_function
specifier|static
name|void
name|dumpsys
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
name|dodump
condition|)
return|return;
if|if
condition|(
name|dumpdev
operator|==
name|NODEV
condition|)
return|return;
if|if
condition|(
operator|(
name|minor
argument_list|(
name|dumpdev
argument_list|)
operator|&
literal|07
operator|)
operator|!=
literal|1
condition|)
return|return;
if|if
condition|(
operator|!
operator|(
name|bdevsw
index|[
name|major
argument_list|(
name|dumpdev
argument_list|)
index|]
operator|)
condition|)
return|return;
if|if
condition|(
operator|!
operator|(
name|bdevsw
index|[
name|major
argument_list|(
name|dumpdev
argument_list|)
index|]
operator|->
name|d_dump
operator|)
condition|)
return|return;
name|dumpsize
operator|=
name|Maxmem
expr_stmt|;
name|printf
argument_list|(
literal|"\ndumping to dev %lx, offset %ld\n"
argument_list|,
name|dumpdev
argument_list|,
name|dumplo
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"dump "
argument_list|)
expr_stmt|;
switch|switch
condition|(
operator|(
operator|*
name|bdevsw
index|[
name|major
argument_list|(
name|dumpdev
argument_list|)
index|]
operator|->
name|d_dump
operator|)
operator|(
name|dumpdev
operator|)
condition|)
block|{
case|case
name|ENXIO
case|:
name|printf
argument_list|(
literal|"device bad\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EFAULT
case|:
name|printf
argument_list|(
literal|"device not ready\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EINVAL
case|:
name|printf
argument_list|(
literal|"area improper\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EIO
case|:
name|printf
argument_list|(
literal|"i/o error\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EINTR
case|:
name|printf
argument_list|(
literal|"aborted from console\n"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"succeeded\n"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/*  * Panic is called on unresolvable fatal errors.  It prints "panic: mesg",  * and then reboots.  If we are called twice, then we avoid trying to sync  * the disks as this often leads to recursive panics.  */
end_comment

begin_function
name|void
name|panic
parameter_list|(
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|int
name|bootopt
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
name|bootopt
operator|=
name|RB_AUTOBOOT
operator||
name|RB_DUMP
expr_stmt|;
if|if
condition|(
name|panicstr
condition|)
name|bootopt
operator||=
name|RB_NOSYNC
expr_stmt|;
else|else
name|panicstr
operator|=
name|fmt
expr_stmt|;
name|printf
argument_list|(
literal|"panic: "
argument_list|)
expr_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|vprintf
argument_list|(
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SMP
comment|/* three seperate prints in case of an unmapped page and trap */
name|printf
argument_list|(
literal|"mp_lock = %08x; "
argument_list|,
name|mp_lock
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"cpuid = %d; "
argument_list|,
name|cpuid
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"lapic.id = %08x\n"
argument_list|,
name|lapic
operator|.
name|id
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|DDB
argument_list|)
if|if
condition|(
name|debugger_on_panic
condition|)
name|Debugger
argument_list|(
literal|"panic"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|boot
argument_list|(
name|bootopt
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Two routines to handle adding/deleting items on the  * shutdown callout lists  *  * at_shutdown():  * Take the arguments given and put them onto the shutdown callout list.  * However first make sure that it's not already there.  * returns 0 on success.  */
end_comment

begin_function
name|int
name|at_shutdown
parameter_list|(
name|bootlist_fn
name|function
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|position
parameter_list|)
block|{
name|sle_p
name|ep
decl_stmt|,
modifier|*
name|epp
decl_stmt|;
switch|switch
condition|(
name|position
condition|)
block|{
case|case
name|SHUTDOWN_PRE_SYNC
case|:
name|epp
operator|=
operator|&
name|shutdown_list1
expr_stmt|;
break|break;
case|case
name|SHUTDOWN_POST_SYNC
case|:
name|epp
operator|=
operator|&
name|shutdown_list2
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"bad exit callout list specified\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
name|rm_at_shutdown
argument_list|(
name|function
argument_list|,
name|arg
argument_list|)
condition|)
name|printf
argument_list|(
literal|"exit callout entry already present\n"
argument_list|)
expr_stmt|;
name|ep
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|ep
argument_list|)
argument_list|,
name|M_TEMP
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|ep
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|ep
operator|->
name|next
operator|=
operator|*
name|epp
expr_stmt|;
name|ep
operator|->
name|function
operator|=
name|function
expr_stmt|;
name|ep
operator|->
name|arg
operator|=
name|arg
expr_stmt|;
operator|*
name|epp
operator|=
name|ep
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Scan the exit callout lists for the given items and remove them.  * Returns the number of items removed.  */
end_comment

begin_function
name|int
name|rm_at_shutdown
parameter_list|(
name|bootlist_fn
name|function
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|sle_p
modifier|*
name|epp
decl_stmt|,
name|ep
decl_stmt|;
name|int
name|count
decl_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
name|epp
operator|=
operator|&
name|shutdown_list1
expr_stmt|;
name|ep
operator|=
operator|*
name|epp
expr_stmt|;
while|while
condition|(
name|ep
condition|)
block|{
if|if
condition|(
operator|(
name|ep
operator|->
name|function
operator|==
name|function
operator|)
operator|&&
operator|(
name|ep
operator|->
name|arg
operator|==
name|arg
operator|)
condition|)
block|{
operator|*
name|epp
operator|=
name|ep
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|ep
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
else|else
block|{
name|epp
operator|=
operator|&
name|ep
operator|->
name|next
expr_stmt|;
block|}
name|ep
operator|=
operator|*
name|epp
expr_stmt|;
block|}
name|epp
operator|=
operator|&
name|shutdown_list2
expr_stmt|;
name|ep
operator|=
operator|*
name|epp
expr_stmt|;
while|while
condition|(
name|ep
condition|)
block|{
if|if
condition|(
operator|(
name|ep
operator|->
name|function
operator|==
name|function
operator|)
operator|&&
operator|(
name|ep
operator|->
name|arg
operator|==
name|arg
operator|)
condition|)
block|{
operator|*
name|epp
operator|=
name|ep
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|ep
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
else|else
block|{
name|epp
operator|=
operator|&
name|ep
operator|->
name|next
expr_stmt|;
block|}
name|ep
operator|=
operator|*
name|epp
expr_stmt|;
block|}
return|return
operator|(
name|count
operator|)
return|;
block|}
end_function

end_unit

