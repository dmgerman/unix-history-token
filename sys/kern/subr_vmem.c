begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c)2006,2007,2008,2009 YAMAMOTO Takashi,  * Copyright (c) 2013 EMC Corp.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * From:  *	$NetBSD: vmem_impl.h,v 1.2 2013/01/29 21:26:24 para Exp $  *	$NetBSD: subr_vmem.c,v 1.83 2013/03/06 11:20:10 yamt Exp $  */
end_comment

begin_comment
comment|/*  * reference:  * -	Magazines and Vmem: Extending the Slab Allocator  *	to Many CPUs and Arbitrary Resources  *	http://www.usenix.org/event/usenix01/bonwick.html  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"opt_ddb.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/callout.h>
end_include

begin_include
include|#
directive|include
file|<sys/hash.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/smp.h>
end_include

begin_include
include|#
directive|include
file|<sys/condvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/taskqueue.h>
end_include

begin_include
include|#
directive|include
file|<sys/vmem.h>
end_include

begin_include
include|#
directive|include
file|"opt_vm.h"
end_include

begin_include
include|#
directive|include
file|<vm/uma.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_map.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_object.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_kern.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_extern.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_param.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_pageout.h>
end_include

begin_define
define|#
directive|define
name|VMEM_OPTORDER
value|5
end_define

begin_define
define|#
directive|define
name|VMEM_OPTVALUE
value|(1<< VMEM_OPTORDER)
end_define

begin_define
define|#
directive|define
name|VMEM_MAXORDER
define|\
value|(VMEM_OPTVALUE - 1 + sizeof(vmem_size_t) * NBBY - VMEM_OPTORDER)
end_define

begin_define
define|#
directive|define
name|VMEM_HASHSIZE_MIN
value|16
end_define

begin_define
define|#
directive|define
name|VMEM_HASHSIZE_MAX
value|131072
end_define

begin_define
define|#
directive|define
name|VMEM_QCACHE_IDX_MAX
value|16
end_define

begin_define
define|#
directive|define
name|VMEM_FITMASK
value|(M_BESTFIT | M_FIRSTFIT)
end_define

begin_define
define|#
directive|define
name|VMEM_FLAGS
define|\
value|(M_NOWAIT | M_WAITOK | M_USE_RESERVE | M_NOVM | M_BESTFIT | M_FIRSTFIT)
end_define

begin_define
define|#
directive|define
name|BT_FLAGS
value|(M_NOWAIT | M_WAITOK | M_USE_RESERVE | M_NOVM)
end_define

begin_define
define|#
directive|define
name|QC_NAME_MAX
value|16
end_define

begin_comment
comment|/*  * Data structures private to vmem.  */
end_comment

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_VMEM
argument_list|,
literal|"vmem"
argument_list|,
literal|"vmem internal structures"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_typedef
typedef|typedef
name|struct
name|vmem_btag
name|bt_t
typedef|;
end_typedef

begin_expr_stmt
name|TAILQ_HEAD
argument_list|(
name|vmem_seglist
argument_list|,
name|vmem_btag
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|LIST_HEAD
argument_list|(
name|vmem_freelist
argument_list|,
name|vmem_btag
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|LIST_HEAD
argument_list|(
name|vmem_hashlist
argument_list|,
name|vmem_btag
argument_list|)
expr_stmt|;
end_expr_stmt

begin_struct
struct|struct
name|qcache
block|{
name|uma_zone_t
name|qc_cache
decl_stmt|;
name|vmem_t
modifier|*
name|qc_vmem
decl_stmt|;
name|vmem_size_t
name|qc_size
decl_stmt|;
name|char
name|qc_name
index|[
name|QC_NAME_MAX
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
name|struct
name|qcache
name|qcache_t
typedef|;
end_typedef

begin_define
define|#
directive|define
name|QC_POOL_TO_QCACHE
parameter_list|(
name|pool
parameter_list|)
value|((qcache_t *)(pool->pr_qcache))
end_define

begin_define
define|#
directive|define
name|VMEM_NAME_MAX
value|16
end_define

begin_comment
comment|/* vmem arena */
end_comment

begin_struct
struct|struct
name|vmem
block|{
name|struct
name|mtx_padalign
name|vm_lock
decl_stmt|;
name|struct
name|cv
name|vm_cv
decl_stmt|;
name|char
name|vm_name
index|[
name|VMEM_NAME_MAX
operator|+
literal|1
index|]
decl_stmt|;
name|LIST_ENTRY
argument_list|(
argument|vmem
argument_list|)
name|vm_alllist
expr_stmt|;
name|struct
name|vmem_hashlist
name|vm_hash0
index|[
name|VMEM_HASHSIZE_MIN
index|]
decl_stmt|;
name|struct
name|vmem_freelist
name|vm_freelist
index|[
name|VMEM_MAXORDER
index|]
decl_stmt|;
name|struct
name|vmem_seglist
name|vm_seglist
decl_stmt|;
name|struct
name|vmem_hashlist
modifier|*
name|vm_hashlist
decl_stmt|;
name|vmem_size_t
name|vm_hashsize
decl_stmt|;
comment|/* Constant after init */
name|vmem_size_t
name|vm_qcache_max
decl_stmt|;
name|vmem_size_t
name|vm_quantum_mask
decl_stmt|;
name|vmem_size_t
name|vm_import_quantum
decl_stmt|;
name|int
name|vm_quantum_shift
decl_stmt|;
comment|/* Written on alloc/free */
name|LIST_HEAD
argument_list|(
argument_list|,
argument|vmem_btag
argument_list|)
name|vm_freetags
expr_stmt|;
name|int
name|vm_nfreetags
decl_stmt|;
name|int
name|vm_nbusytag
decl_stmt|;
name|vmem_size_t
name|vm_inuse
decl_stmt|;
name|vmem_size_t
name|vm_size
decl_stmt|;
comment|/* Used on import. */
name|vmem_import_t
modifier|*
name|vm_importfn
decl_stmt|;
name|vmem_release_t
modifier|*
name|vm_releasefn
decl_stmt|;
name|void
modifier|*
name|vm_arg
decl_stmt|;
comment|/* Space exhaustion callback. */
name|vmem_reclaim_t
modifier|*
name|vm_reclaimfn
decl_stmt|;
comment|/* quantum cache */
name|qcache_t
name|vm_qcache
index|[
name|VMEM_QCACHE_IDX_MAX
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* boundary tag */
end_comment

begin_struct
struct|struct
name|vmem_btag
block|{
name|TAILQ_ENTRY
argument_list|(
argument|vmem_btag
argument_list|)
name|bt_seglist
expr_stmt|;
union|union
block|{
name|LIST_ENTRY
argument_list|(
argument|vmem_btag
argument_list|)
name|u_freelist
expr_stmt|;
comment|/* BT_TYPE_FREE */
name|LIST_ENTRY
argument_list|(
argument|vmem_btag
argument_list|)
name|u_hashlist
expr_stmt|;
comment|/* BT_TYPE_BUSY */
block|}
name|bt_u
union|;
define|#
directive|define
name|bt_hashlist
value|bt_u.u_hashlist
define|#
directive|define
name|bt_freelist
value|bt_u.u_freelist
name|vmem_addr_t
name|bt_start
decl_stmt|;
name|vmem_size_t
name|bt_size
decl_stmt|;
name|int
name|bt_type
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|BT_TYPE_SPAN
value|1
end_define

begin_comment
comment|/* Allocated from importfn */
end_comment

begin_define
define|#
directive|define
name|BT_TYPE_SPAN_STATIC
value|2
end_define

begin_comment
comment|/* vmem_add() or create. */
end_comment

begin_define
define|#
directive|define
name|BT_TYPE_FREE
value|3
end_define

begin_comment
comment|/* Available space. */
end_comment

begin_define
define|#
directive|define
name|BT_TYPE_BUSY
value|4
end_define

begin_comment
comment|/* Used space. */
end_comment

begin_define
define|#
directive|define
name|BT_ISSPAN_P
parameter_list|(
name|bt
parameter_list|)
value|((bt)->bt_type<= BT_TYPE_SPAN_STATIC)
end_define

begin_define
define|#
directive|define
name|BT_END
parameter_list|(
name|bt
parameter_list|)
value|((bt)->bt_start + (bt)->bt_size - 1)
end_define

begin_if
if|#
directive|if
name|defined
argument_list|(
name|DIAGNOSTIC
argument_list|)
end_if

begin_decl_stmt
specifier|static
name|int
name|enable_vmem_check
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_debug
argument_list|,
name|OID_AUTO
argument_list|,
name|vmem_check
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|enable_vmem_check
argument_list|,
literal|0
argument_list|,
literal|"Enable vmem check"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function_decl
specifier|static
name|void
name|vmem_check
parameter_list|(
name|vmem_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|struct
name|callout
name|vmem_periodic_ch
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|vmem_periodic_interval
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|task
name|vmem_periodic_wk
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|mtx_padalign
name|vmem_list_lock
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|static
name|LIST_HEAD
argument_list|(
argument_list|,
argument|vmem
argument_list|)
name|vmem_list
operator|=
name|LIST_HEAD_INITIALIZER
argument_list|(
name|vmem_list
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* ---- misc */
end_comment

begin_define
define|#
directive|define
name|VMEM_CONDVAR_INIT
parameter_list|(
name|vm
parameter_list|,
name|wchan
parameter_list|)
value|cv_init(&vm->vm_cv, wchan)
end_define

begin_define
define|#
directive|define
name|VMEM_CONDVAR_DESTROY
parameter_list|(
name|vm
parameter_list|)
value|cv_destroy(&vm->vm_cv)
end_define

begin_define
define|#
directive|define
name|VMEM_CONDVAR_WAIT
parameter_list|(
name|vm
parameter_list|)
value|cv_wait(&vm->vm_cv,&vm->vm_lock)
end_define

begin_define
define|#
directive|define
name|VMEM_CONDVAR_BROADCAST
parameter_list|(
name|vm
parameter_list|)
value|cv_broadcast(&vm->vm_cv)
end_define

begin_define
define|#
directive|define
name|VMEM_LOCK
parameter_list|(
name|vm
parameter_list|)
value|mtx_lock(&vm->vm_lock)
end_define

begin_define
define|#
directive|define
name|VMEM_TRYLOCK
parameter_list|(
name|vm
parameter_list|)
value|mtx_trylock(&vm->vm_lock)
end_define

begin_define
define|#
directive|define
name|VMEM_UNLOCK
parameter_list|(
name|vm
parameter_list|)
value|mtx_unlock(&vm->vm_lock)
end_define

begin_define
define|#
directive|define
name|VMEM_LOCK_INIT
parameter_list|(
name|vm
parameter_list|,
name|name
parameter_list|)
value|mtx_init(&vm->vm_lock, (name), NULL, MTX_DEF)
end_define

begin_define
define|#
directive|define
name|VMEM_LOCK_DESTROY
parameter_list|(
name|vm
parameter_list|)
value|mtx_destroy(&vm->vm_lock)
end_define

begin_define
define|#
directive|define
name|VMEM_ASSERT_LOCKED
parameter_list|(
name|vm
parameter_list|)
value|mtx_assert(&vm->vm_lock, MA_OWNED);
end_define

begin_define
define|#
directive|define
name|VMEM_ALIGNUP
parameter_list|(
name|addr
parameter_list|,
name|align
parameter_list|)
value|(-(-(addr)& -(align)))
end_define

begin_define
define|#
directive|define
name|VMEM_CROSS_P
parameter_list|(
name|addr1
parameter_list|,
name|addr2
parameter_list|,
name|boundary
parameter_list|)
define|\
value|((((addr1) ^ (addr2))& -(boundary)) != 0)
end_define

begin_define
define|#
directive|define
name|ORDER2SIZE
parameter_list|(
name|order
parameter_list|)
value|((order)< VMEM_OPTVALUE ? ((order) + 1) : \     (vmem_size_t)1<< ((order) - (VMEM_OPTVALUE - VMEM_OPTORDER - 1)))
end_define

begin_define
define|#
directive|define
name|SIZE2ORDER
parameter_list|(
name|size
parameter_list|)
value|((size)<= VMEM_OPTVALUE ? ((size) - 1) : \     (flsl(size) + (VMEM_OPTVALUE - VMEM_OPTORDER - 2)))
end_define

begin_comment
comment|/*  * Maximum number of boundary tags that may be required to satisfy an  * allocation.  Two may be required to import.  Another two may be  * required to clip edges.  */
end_comment

begin_define
define|#
directive|define
name|BT_MAXALLOC
value|4
end_define

begin_comment
comment|/*  * Max free limits the number of locally cached boundary tags.  We  * just want to avoid hitting the zone allocator for every call.  */
end_comment

begin_define
define|#
directive|define
name|BT_MAXFREE
value|(BT_MAXALLOC * 8)
end_define

begin_comment
comment|/* Allocator for boundary tags. */
end_comment

begin_decl_stmt
specifier|static
name|uma_zone_t
name|vmem_bt_zone
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* boot time arena storage. */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|vmem
name|kernel_arena_storage
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|vmem
name|kmem_arena_storage
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|vmem
name|buffer_arena_storage
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|vmem
name|transient_arena_storage
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|vmem_t
modifier|*
name|kernel_arena
init|=
operator|&
name|kernel_arena_storage
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|vmem_t
modifier|*
name|kmem_arena
init|=
operator|&
name|kmem_arena_storage
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|vmem_t
modifier|*
name|buffer_arena
init|=
operator|&
name|buffer_arena_storage
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|vmem_t
modifier|*
name|transient_arena
init|=
operator|&
name|transient_arena_storage
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG_MEMGUARD
end_ifdef

begin_decl_stmt
specifier|static
name|struct
name|vmem
name|memguard_arena_storage
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|vmem_t
modifier|*
name|memguard_arena
init|=
operator|&
name|memguard_arena_storage
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Fill the vmem's boundary tag cache.  We guarantee that boundary tag  * allocation will not fail once bt_fill() passes.  To do so we cache  * at least the maximum possible tag allocations in the arena.  */
end_comment

begin_function
specifier|static
name|int
name|bt_fill
parameter_list|(
name|vmem_t
modifier|*
name|vm
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|bt_t
modifier|*
name|bt
decl_stmt|;
name|VMEM_ASSERT_LOCKED
argument_list|(
name|vm
argument_list|)
expr_stmt|;
comment|/* 	 * Only allow the kmem arena to dip into reserve tags.  It is the 	 * vmem where new tags come from. 	 */
name|flags
operator|&=
name|BT_FLAGS
expr_stmt|;
if|if
condition|(
name|vm
operator|!=
name|kmem_arena
condition|)
name|flags
operator|&=
operator|~
name|M_USE_RESERVE
expr_stmt|;
comment|/* 	 * Loop until we meet the reserve.  To minimize the lock shuffle 	 * and prevent simultaneous fills we first try a NOWAIT regardless 	 * of the caller's flags.  Specify M_NOVM so we don't recurse while 	 * holding a vmem lock. 	 */
while|while
condition|(
name|vm
operator|->
name|vm_nfreetags
operator|<
name|BT_MAXALLOC
condition|)
block|{
name|bt
operator|=
name|uma_zalloc
argument_list|(
name|vmem_bt_zone
argument_list|,
operator|(
name|flags
operator|&
name|M_USE_RESERVE
operator|)
operator||
name|M_NOWAIT
operator||
name|M_NOVM
argument_list|)
expr_stmt|;
if|if
condition|(
name|bt
operator|==
name|NULL
condition|)
block|{
name|VMEM_UNLOCK
argument_list|(
name|vm
argument_list|)
expr_stmt|;
name|bt
operator|=
name|uma_zalloc
argument_list|(
name|vmem_bt_zone
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|VMEM_LOCK
argument_list|(
name|vm
argument_list|)
expr_stmt|;
if|if
condition|(
name|bt
operator|==
name|NULL
operator|&&
operator|(
name|flags
operator|&
name|M_NOWAIT
operator|)
operator|!=
literal|0
condition|)
break|break;
block|}
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|vm
operator|->
name|vm_freetags
argument_list|,
name|bt
argument_list|,
name|bt_freelist
argument_list|)
expr_stmt|;
name|vm
operator|->
name|vm_nfreetags
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|vm
operator|->
name|vm_nfreetags
operator|<
name|BT_MAXALLOC
condition|)
return|return
name|ENOMEM
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Pop a tag off of the freetag stack.  */
end_comment

begin_function
specifier|static
name|bt_t
modifier|*
name|bt_alloc
parameter_list|(
name|vmem_t
modifier|*
name|vm
parameter_list|)
block|{
name|bt_t
modifier|*
name|bt
decl_stmt|;
name|VMEM_ASSERT_LOCKED
argument_list|(
name|vm
argument_list|)
expr_stmt|;
name|bt
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|vm
operator|->
name|vm_freetags
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|bt
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|bt
argument_list|,
name|bt_freelist
argument_list|)
expr_stmt|;
name|vm
operator|->
name|vm_nfreetags
operator|--
expr_stmt|;
return|return
name|bt
return|;
block|}
end_function

begin_comment
comment|/*  * Trim the per-vmem free list.  Returns with the lock released to  * avoid allocator recursions.  */
end_comment

begin_function
specifier|static
name|void
name|bt_freetrim
parameter_list|(
name|vmem_t
modifier|*
name|vm
parameter_list|,
name|int
name|freelimit
parameter_list|)
block|{
name|LIST_HEAD
argument_list|(
argument_list|,
argument|vmem_btag
argument_list|)
name|freetags
expr_stmt|;
name|bt_t
modifier|*
name|bt
decl_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|freetags
argument_list|)
expr_stmt|;
name|VMEM_ASSERT_LOCKED
argument_list|(
name|vm
argument_list|)
expr_stmt|;
while|while
condition|(
name|vm
operator|->
name|vm_nfreetags
operator|>
name|freelimit
condition|)
block|{
name|bt
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|vm
operator|->
name|vm_freetags
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|bt
argument_list|,
name|bt_freelist
argument_list|)
expr_stmt|;
name|vm
operator|->
name|vm_nfreetags
operator|--
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|freetags
argument_list|,
name|bt
argument_list|,
name|bt_freelist
argument_list|)
expr_stmt|;
block|}
name|VMEM_UNLOCK
argument_list|(
name|vm
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|bt
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|freetags
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|LIST_REMOVE
argument_list|(
name|bt
argument_list|,
name|bt_freelist
argument_list|)
expr_stmt|;
name|uma_zfree
argument_list|(
name|vmem_bt_zone
argument_list|,
name|bt
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|bt_free
parameter_list|(
name|vmem_t
modifier|*
name|vm
parameter_list|,
name|bt_t
modifier|*
name|bt
parameter_list|)
block|{
name|VMEM_ASSERT_LOCKED
argument_list|(
name|vm
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|LIST_FIRST
argument_list|(
operator|&
name|vm
operator|->
name|vm_freetags
argument_list|)
operator|!=
name|bt
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|vm
operator|->
name|vm_freetags
argument_list|,
name|bt
argument_list|,
name|bt_freelist
argument_list|)
expr_stmt|;
name|vm
operator|->
name|vm_nfreetags
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * freelist[0] ... [1, 1]  * freelist[1] ... [2, 2]  *  :  * freelist[29] ... [30, 30]  * freelist[30] ... [31, 31]  * freelist[31] ... [32, 63]  * freelist[33] ... [64, 127]  *  :  * freelist[n] ... [(1<< (n - 26)), (1<< (n - 25)) - 1]  *  :  */
end_comment

begin_function
specifier|static
name|struct
name|vmem_freelist
modifier|*
name|bt_freehead_tofree
parameter_list|(
name|vmem_t
modifier|*
name|vm
parameter_list|,
name|vmem_size_t
name|size
parameter_list|)
block|{
specifier|const
name|vmem_size_t
name|qsize
init|=
name|size
operator|>>
name|vm
operator|->
name|vm_quantum_shift
decl_stmt|;
specifier|const
name|int
name|idx
init|=
name|SIZE2ORDER
argument_list|(
name|qsize
argument_list|)
decl_stmt|;
name|MPASS
argument_list|(
name|size
operator|!=
literal|0
operator|&&
name|qsize
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
operator|(
name|size
operator|&
name|vm
operator|->
name|vm_quantum_mask
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|idx
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|idx
operator|<
name|VMEM_MAXORDER
argument_list|)
expr_stmt|;
return|return
operator|&
name|vm
operator|->
name|vm_freelist
index|[
name|idx
index|]
return|;
block|}
end_function

begin_comment
comment|/*  * bt_freehead_toalloc: return the freelist for the given size and allocation  * strategy.  *  * For M_FIRSTFIT, return the list in which any blocks are large enough  * for the requested size.  otherwise, return the list which can have blocks  * large enough for the requested size.  */
end_comment

begin_function
specifier|static
name|struct
name|vmem_freelist
modifier|*
name|bt_freehead_toalloc
parameter_list|(
name|vmem_t
modifier|*
name|vm
parameter_list|,
name|vmem_size_t
name|size
parameter_list|,
name|int
name|strat
parameter_list|)
block|{
specifier|const
name|vmem_size_t
name|qsize
init|=
name|size
operator|>>
name|vm
operator|->
name|vm_quantum_shift
decl_stmt|;
name|int
name|idx
init|=
name|SIZE2ORDER
argument_list|(
name|qsize
argument_list|)
decl_stmt|;
name|MPASS
argument_list|(
name|size
operator|!=
literal|0
operator|&&
name|qsize
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
operator|(
name|size
operator|&
name|vm
operator|->
name|vm_quantum_mask
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|strat
operator|==
name|M_FIRSTFIT
operator|&&
name|ORDER2SIZE
argument_list|(
name|idx
argument_list|)
operator|!=
name|qsize
condition|)
block|{
name|idx
operator|++
expr_stmt|;
comment|/* check too large request? */
block|}
name|MPASS
argument_list|(
name|idx
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|idx
operator|<
name|VMEM_MAXORDER
argument_list|)
expr_stmt|;
return|return
operator|&
name|vm
operator|->
name|vm_freelist
index|[
name|idx
index|]
return|;
block|}
end_function

begin_comment
comment|/* ---- boundary tag hash */
end_comment

begin_function
specifier|static
name|struct
name|vmem_hashlist
modifier|*
name|bt_hashhead
parameter_list|(
name|vmem_t
modifier|*
name|vm
parameter_list|,
name|vmem_addr_t
name|addr
parameter_list|)
block|{
name|struct
name|vmem_hashlist
modifier|*
name|list
decl_stmt|;
name|unsigned
name|int
name|hash
decl_stmt|;
name|hash
operator|=
name|hash32_buf
argument_list|(
operator|&
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
name|addr
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|list
operator|=
operator|&
name|vm
operator|->
name|vm_hashlist
index|[
name|hash
operator|%
name|vm
operator|->
name|vm_hashsize
index|]
expr_stmt|;
return|return
name|list
return|;
block|}
end_function

begin_function
specifier|static
name|bt_t
modifier|*
name|bt_lookupbusy
parameter_list|(
name|vmem_t
modifier|*
name|vm
parameter_list|,
name|vmem_addr_t
name|addr
parameter_list|)
block|{
name|struct
name|vmem_hashlist
modifier|*
name|list
decl_stmt|;
name|bt_t
modifier|*
name|bt
decl_stmt|;
name|VMEM_ASSERT_LOCKED
argument_list|(
name|vm
argument_list|)
expr_stmt|;
name|list
operator|=
name|bt_hashhead
argument_list|(
name|vm
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|bt
argument_list|,
argument|list
argument_list|,
argument|bt_hashlist
argument_list|)
block|{
if|if
condition|(
name|bt
operator|->
name|bt_start
operator|==
name|addr
condition|)
block|{
break|break;
block|}
block|}
return|return
name|bt
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|bt_rembusy
parameter_list|(
name|vmem_t
modifier|*
name|vm
parameter_list|,
name|bt_t
modifier|*
name|bt
parameter_list|)
block|{
name|VMEM_ASSERT_LOCKED
argument_list|(
name|vm
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|vm
operator|->
name|vm_nbusytag
operator|>
literal|0
argument_list|)
expr_stmt|;
name|vm
operator|->
name|vm_inuse
operator|-=
name|bt
operator|->
name|bt_size
expr_stmt|;
name|vm
operator|->
name|vm_nbusytag
operator|--
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|bt
argument_list|,
name|bt_hashlist
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|bt_insbusy
parameter_list|(
name|vmem_t
modifier|*
name|vm
parameter_list|,
name|bt_t
modifier|*
name|bt
parameter_list|)
block|{
name|struct
name|vmem_hashlist
modifier|*
name|list
decl_stmt|;
name|VMEM_ASSERT_LOCKED
argument_list|(
name|vm
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|bt
operator|->
name|bt_type
operator|==
name|BT_TYPE_BUSY
argument_list|)
expr_stmt|;
name|list
operator|=
name|bt_hashhead
argument_list|(
name|vm
argument_list|,
name|bt
operator|->
name|bt_start
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
name|list
argument_list|,
name|bt
argument_list|,
name|bt_hashlist
argument_list|)
expr_stmt|;
name|vm
operator|->
name|vm_nbusytag
operator|++
expr_stmt|;
name|vm
operator|->
name|vm_inuse
operator|+=
name|bt
operator|->
name|bt_size
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ---- boundary tag list */
end_comment

begin_function
specifier|static
name|void
name|bt_remseg
parameter_list|(
name|vmem_t
modifier|*
name|vm
parameter_list|,
name|bt_t
modifier|*
name|bt
parameter_list|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|vm
operator|->
name|vm_seglist
argument_list|,
name|bt
argument_list|,
name|bt_seglist
argument_list|)
expr_stmt|;
name|bt_free
argument_list|(
name|vm
argument_list|,
name|bt
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|bt_insseg
parameter_list|(
name|vmem_t
modifier|*
name|vm
parameter_list|,
name|bt_t
modifier|*
name|bt
parameter_list|,
name|bt_t
modifier|*
name|prev
parameter_list|)
block|{
name|TAILQ_INSERT_AFTER
argument_list|(
operator|&
name|vm
operator|->
name|vm_seglist
argument_list|,
name|prev
argument_list|,
name|bt
argument_list|,
name|bt_seglist
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|bt_insseg_tail
parameter_list|(
name|vmem_t
modifier|*
name|vm
parameter_list|,
name|bt_t
modifier|*
name|bt
parameter_list|)
block|{
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|vm
operator|->
name|vm_seglist
argument_list|,
name|bt
argument_list|,
name|bt_seglist
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|bt_remfree
parameter_list|(
name|vmem_t
modifier|*
name|vm
parameter_list|,
name|bt_t
modifier|*
name|bt
parameter_list|)
block|{
name|MPASS
argument_list|(
name|bt
operator|->
name|bt_type
operator|==
name|BT_TYPE_FREE
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|bt
argument_list|,
name|bt_freelist
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|bt_insfree
parameter_list|(
name|vmem_t
modifier|*
name|vm
parameter_list|,
name|bt_t
modifier|*
name|bt
parameter_list|)
block|{
name|struct
name|vmem_freelist
modifier|*
name|list
decl_stmt|;
name|list
operator|=
name|bt_freehead_tofree
argument_list|(
name|vm
argument_list|,
name|bt
operator|->
name|bt_size
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
name|list
argument_list|,
name|bt
argument_list|,
name|bt_freelist
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ---- vmem internal functions */
end_comment

begin_comment
comment|/*  * Import from the arena into the quantum cache in UMA.  */
end_comment

begin_function
specifier|static
name|int
name|qc_import
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|void
modifier|*
modifier|*
name|store
parameter_list|,
name|int
name|cnt
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|qcache_t
modifier|*
name|qc
decl_stmt|;
name|vmem_addr_t
name|addr
decl_stmt|;
name|int
name|i
decl_stmt|;
name|qc
operator|=
name|arg
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|VMEM_FITMASK
operator|)
operator|==
literal|0
condition|)
name|flags
operator||=
name|M_BESTFIT
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cnt
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|vmem_xalloc
argument_list|(
name|qc
operator|->
name|qc_vmem
argument_list|,
name|qc
operator|->
name|qc_size
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|VMEM_ADDR_MIN
argument_list|,
name|VMEM_ADDR_MAX
argument_list|,
name|flags
argument_list|,
operator|&
name|addr
argument_list|)
operator|!=
literal|0
condition|)
break|break;
name|store
index|[
name|i
index|]
operator|=
operator|(
name|void
operator|*
operator|)
name|addr
expr_stmt|;
comment|/* Only guarantee one allocation. */
name|flags
operator|&=
operator|~
name|M_WAITOK
expr_stmt|;
name|flags
operator||=
name|M_NOWAIT
expr_stmt|;
block|}
return|return
name|i
return|;
block|}
end_function

begin_comment
comment|/*  * Release memory from the UMA cache to the arena.  */
end_comment

begin_function
specifier|static
name|void
name|qc_release
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|void
modifier|*
modifier|*
name|store
parameter_list|,
name|int
name|cnt
parameter_list|)
block|{
name|qcache_t
modifier|*
name|qc
decl_stmt|;
name|int
name|i
decl_stmt|;
name|qc
operator|=
name|arg
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cnt
condition|;
name|i
operator|++
control|)
name|vmem_xfree
argument_list|(
name|qc
operator|->
name|qc_vmem
argument_list|,
operator|(
name|vmem_addr_t
operator|)
name|store
index|[
name|i
index|]
argument_list|,
name|qc
operator|->
name|qc_size
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|qc_init
parameter_list|(
name|vmem_t
modifier|*
name|vm
parameter_list|,
name|vmem_size_t
name|qcache_max
parameter_list|)
block|{
name|qcache_t
modifier|*
name|qc
decl_stmt|;
name|vmem_size_t
name|size
decl_stmt|;
name|int
name|qcache_idx_max
decl_stmt|;
name|int
name|i
decl_stmt|;
name|MPASS
argument_list|(
operator|(
name|qcache_max
operator|&
name|vm
operator|->
name|vm_quantum_mask
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|qcache_idx_max
operator|=
name|MIN
argument_list|(
name|qcache_max
operator|>>
name|vm
operator|->
name|vm_quantum_shift
argument_list|,
name|VMEM_QCACHE_IDX_MAX
argument_list|)
expr_stmt|;
name|vm
operator|->
name|vm_qcache_max
operator|=
name|qcache_idx_max
operator|<<
name|vm
operator|->
name|vm_quantum_shift
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|qcache_idx_max
condition|;
name|i
operator|++
control|)
block|{
name|qc
operator|=
operator|&
name|vm
operator|->
name|vm_qcache
index|[
name|i
index|]
expr_stmt|;
name|size
operator|=
operator|(
name|i
operator|+
literal|1
operator|)
operator|<<
name|vm
operator|->
name|vm_quantum_shift
expr_stmt|;
name|snprintf
argument_list|(
name|qc
operator|->
name|qc_name
argument_list|,
sizeof|sizeof
argument_list|(
name|qc
operator|->
name|qc_name
argument_list|)
argument_list|,
literal|"%s-%zu"
argument_list|,
name|vm
operator|->
name|vm_name
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|qc
operator|->
name|qc_vmem
operator|=
name|vm
expr_stmt|;
name|qc
operator|->
name|qc_size
operator|=
name|size
expr_stmt|;
name|qc
operator|->
name|qc_cache
operator|=
name|uma_zcache_create
argument_list|(
name|qc
operator|->
name|qc_name
argument_list|,
name|size
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|qc_import
argument_list|,
name|qc_release
argument_list|,
name|qc
argument_list|,
name|UMA_ZONE_VM
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|qc
operator|->
name|qc_cache
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|qc_destroy
parameter_list|(
name|vmem_t
modifier|*
name|vm
parameter_list|)
block|{
name|int
name|qcache_idx_max
decl_stmt|;
name|int
name|i
decl_stmt|;
name|qcache_idx_max
operator|=
name|vm
operator|->
name|vm_qcache_max
operator|>>
name|vm
operator|->
name|vm_quantum_shift
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|qcache_idx_max
condition|;
name|i
operator|++
control|)
name|uma_zdestroy
argument_list|(
name|vm
operator|->
name|vm_qcache
index|[
name|i
index|]
operator|.
name|qc_cache
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|qc_drain
parameter_list|(
name|vmem_t
modifier|*
name|vm
parameter_list|)
block|{
name|int
name|qcache_idx_max
decl_stmt|;
name|int
name|i
decl_stmt|;
name|qcache_idx_max
operator|=
name|vm
operator|->
name|vm_qcache_max
operator|>>
name|vm
operator|->
name|vm_quantum_shift
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|qcache_idx_max
condition|;
name|i
operator|++
control|)
name|zone_drain
argument_list|(
name|vm
operator|->
name|vm_qcache
index|[
name|i
index|]
operator|.
name|qc_cache
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|UMA_MD_SMALL_ALLOC
end_ifndef

begin_decl_stmt
specifier|static
name|struct
name|mtx_padalign
name|vmem_bt_lock
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * vmem_bt_alloc:  Allocate a new page of boundary tags.  *  * On architectures with uma_small_alloc there is no recursion; no address  * space need be allocated to allocate boundary tags.  For the others, we  * must handle recursion.  Boundary tags are necessary to allocate new  * boundary tags.  *  * UMA guarantees that enough tags are held in reserve to allocate a new  * page of kva.  We dip into this reserve by specifying M_USE_RESERVE only  * when allocating the page to hold new boundary tags.  In this way the  * reserve is automatically filled by the allocation that uses the reserve.  *   * We still have to guarantee that the new tags are allocated atomically since  * many threads may try concurrently.  The bt_lock provides this guarantee.  * We convert WAITOK allocations to NOWAIT and then handle the blocking here  * on failure.  It's ok to return NULL for a WAITOK allocation as UMA will  * loop again after checking to see if we lost the race to allocate.  *  * There is a small race between vmem_bt_alloc() returning the page and the  * zone lock being acquired to add the page to the zone.  For WAITOK  * allocations we just pause briefly.  NOWAIT may experience a transient  * failure.  To alleviate this we permit a small number of simultaneous  * fills to proceed concurrently so NOWAIT is less likely to fail unless  * we are really out of KVA.  */
end_comment

begin_function
specifier|static
name|void
modifier|*
name|vmem_bt_alloc
parameter_list|(
name|uma_zone_t
name|zone
parameter_list|,
name|int
name|bytes
parameter_list|,
name|uint8_t
modifier|*
name|pflag
parameter_list|,
name|int
name|wait
parameter_list|)
block|{
name|vmem_addr_t
name|addr
decl_stmt|;
operator|*
name|pflag
operator|=
name|UMA_SLAB_KMEM
expr_stmt|;
comment|/* 	 * Single thread boundary tag allocation so that the address space 	 * and memory are added in one atomic operation. 	 */
name|mtx_lock
argument_list|(
operator|&
name|vmem_bt_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|vmem_xalloc
argument_list|(
name|kmem_arena
argument_list|,
name|bytes
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|VMEM_ADDR_MIN
argument_list|,
name|VMEM_ADDR_MAX
argument_list|,
name|M_NOWAIT
operator||
name|M_NOVM
operator||
name|M_USE_RESERVE
operator||
name|M_BESTFIT
argument_list|,
operator|&
name|addr
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|kmem_back
argument_list|(
name|kmem_object
argument_list|,
name|addr
argument_list|,
name|bytes
argument_list|,
name|M_NOWAIT
operator||
name|M_USE_RESERVE
argument_list|)
operator|==
literal|0
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|vmem_bt_lock
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|void
operator|*
operator|)
name|addr
operator|)
return|;
block|}
name|vmem_xfree
argument_list|(
name|kmem_arena
argument_list|,
name|addr
argument_list|,
name|bytes
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|vmem_bt_lock
argument_list|)
expr_stmt|;
comment|/* 		 * Out of memory, not address space.  This may not even be 		 * possible due to M_USE_RESERVE page allocation. 		 */
if|if
condition|(
name|wait
operator|&
name|M_WAITOK
condition|)
name|VM_WAIT
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|vmem_bt_lock
argument_list|)
expr_stmt|;
comment|/* 	 * We're either out of address space or lost a fill race. 	 */
if|if
condition|(
name|wait
operator|&
name|M_WAITOK
condition|)
name|pause
argument_list|(
literal|"btalloc"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|vmem_startup
parameter_list|(
name|void
parameter_list|)
block|{
name|mtx_init
argument_list|(
operator|&
name|vmem_list_lock
argument_list|,
literal|"vmem list lock"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|vmem_bt_zone
operator|=
name|uma_zcreate
argument_list|(
literal|"vmem btag"
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|vmem_btag
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|UMA_ALIGN_PTR
argument_list|,
name|UMA_ZONE_VM
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|UMA_MD_SMALL_ALLOC
name|mtx_init
argument_list|(
operator|&
name|vmem_bt_lock
argument_list|,
literal|"btag lock"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|uma_prealloc
argument_list|(
name|vmem_bt_zone
argument_list|,
name|BT_MAXALLOC
argument_list|)
expr_stmt|;
comment|/* 	 * Reserve enough tags to allocate new tags.  We allow multiple 	 * CPUs to attempt to allocate new tags concurrently to limit 	 * false restarts in UMA. 	 */
name|uma_zone_reserve
argument_list|(
name|vmem_bt_zone
argument_list|,
name|BT_MAXALLOC
operator|*
operator|(
name|mp_ncpus
operator|+
literal|1
operator|)
operator|/
literal|2
argument_list|)
expr_stmt|;
name|uma_zone_set_allocf
argument_list|(
name|vmem_bt_zone
argument_list|,
name|vmem_bt_alloc
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* ---- rehash */
end_comment

begin_function
specifier|static
name|int
name|vmem_rehash
parameter_list|(
name|vmem_t
modifier|*
name|vm
parameter_list|,
name|vmem_size_t
name|newhashsize
parameter_list|)
block|{
name|bt_t
modifier|*
name|bt
decl_stmt|;
name|int
name|i
decl_stmt|;
name|struct
name|vmem_hashlist
modifier|*
name|newhashlist
decl_stmt|;
name|struct
name|vmem_hashlist
modifier|*
name|oldhashlist
decl_stmt|;
name|vmem_size_t
name|oldhashsize
decl_stmt|;
name|MPASS
argument_list|(
name|newhashsize
operator|>
literal|0
argument_list|)
expr_stmt|;
name|newhashlist
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|vmem_hashlist
argument_list|)
operator|*
name|newhashsize
argument_list|,
name|M_VMEM
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|newhashlist
operator|==
name|NULL
condition|)
return|return
name|ENOMEM
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|newhashsize
condition|;
name|i
operator|++
control|)
block|{
name|LIST_INIT
argument_list|(
operator|&
name|newhashlist
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|VMEM_LOCK
argument_list|(
name|vm
argument_list|)
expr_stmt|;
name|oldhashlist
operator|=
name|vm
operator|->
name|vm_hashlist
expr_stmt|;
name|oldhashsize
operator|=
name|vm
operator|->
name|vm_hashsize
expr_stmt|;
name|vm
operator|->
name|vm_hashlist
operator|=
name|newhashlist
expr_stmt|;
name|vm
operator|->
name|vm_hashsize
operator|=
name|newhashsize
expr_stmt|;
if|if
condition|(
name|oldhashlist
operator|==
name|NULL
condition|)
block|{
name|VMEM_UNLOCK
argument_list|(
name|vm
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|oldhashsize
condition|;
name|i
operator|++
control|)
block|{
while|while
condition|(
operator|(
name|bt
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|oldhashlist
index|[
name|i
index|]
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|bt_rembusy
argument_list|(
name|vm
argument_list|,
name|bt
argument_list|)
expr_stmt|;
name|bt_insbusy
argument_list|(
name|vm
argument_list|,
name|bt
argument_list|)
expr_stmt|;
block|}
block|}
name|VMEM_UNLOCK
argument_list|(
name|vm
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldhashlist
operator|!=
name|vm
operator|->
name|vm_hash0
condition|)
block|{
name|free
argument_list|(
name|oldhashlist
argument_list|,
name|M_VMEM
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|vmem_periodic_kick
parameter_list|(
name|void
modifier|*
name|dummy
parameter_list|)
block|{
name|taskqueue_enqueue
argument_list|(
name|taskqueue_thread
argument_list|,
operator|&
name|vmem_periodic_wk
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|vmem_periodic
parameter_list|(
name|void
modifier|*
name|unused
parameter_list|,
name|int
name|pending
parameter_list|)
block|{
name|vmem_t
modifier|*
name|vm
decl_stmt|;
name|vmem_size_t
name|desired
decl_stmt|;
name|vmem_size_t
name|current
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|vmem_list_lock
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|vm
argument_list|,
argument|&vmem_list
argument_list|,
argument|vm_alllist
argument_list|)
block|{
ifdef|#
directive|ifdef
name|DIAGNOSTIC
comment|/* Convenient time to verify vmem state. */
if|if
condition|(
name|enable_vmem_check
operator|==
literal|1
condition|)
block|{
name|VMEM_LOCK
argument_list|(
name|vm
argument_list|)
expr_stmt|;
name|vmem_check
argument_list|(
name|vm
argument_list|)
expr_stmt|;
name|VMEM_UNLOCK
argument_list|(
name|vm
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|desired
operator|=
literal|1
operator|<<
name|flsl
argument_list|(
name|vm
operator|->
name|vm_nbusytag
argument_list|)
expr_stmt|;
name|desired
operator|=
name|MIN
argument_list|(
name|MAX
argument_list|(
name|desired
argument_list|,
name|VMEM_HASHSIZE_MIN
argument_list|)
argument_list|,
name|VMEM_HASHSIZE_MAX
argument_list|)
expr_stmt|;
name|current
operator|=
name|vm
operator|->
name|vm_hashsize
expr_stmt|;
comment|/* Grow in powers of two.  Shrink less aggressively. */
if|if
condition|(
name|desired
operator|>=
name|current
operator|*
literal|2
operator|||
name|desired
operator|*
literal|4
operator|<=
name|current
condition|)
name|vmem_rehash
argument_list|(
name|vm
argument_list|,
name|desired
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|vmem_list_lock
argument_list|)
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|vmem_periodic_ch
argument_list|,
name|vmem_periodic_interval
argument_list|,
name|vmem_periodic_kick
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|vmem_start_callout
parameter_list|(
name|void
modifier|*
name|unused
parameter_list|)
block|{
name|TASK_INIT
argument_list|(
operator|&
name|vmem_periodic_wk
argument_list|,
literal|0
argument_list|,
name|vmem_periodic
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|vmem_periodic_interval
operator|=
name|hz
operator|*
literal|10
expr_stmt|;
name|callout_init
argument_list|(
operator|&
name|vmem_periodic_ch
argument_list|,
name|CALLOUT_MPSAFE
argument_list|)
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|vmem_periodic_ch
argument_list|,
name|vmem_periodic_interval
argument_list|,
name|vmem_periodic_kick
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|SYSINIT
argument_list|(
name|vfs
argument_list|,
name|SI_SUB_CONFIGURE
argument_list|,
name|SI_ORDER_ANY
argument_list|,
name|vmem_start_callout
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|void
name|vmem_add1
parameter_list|(
name|vmem_t
modifier|*
name|vm
parameter_list|,
name|vmem_addr_t
name|addr
parameter_list|,
name|vmem_size_t
name|size
parameter_list|,
name|int
name|type
parameter_list|)
block|{
name|bt_t
modifier|*
name|btspan
decl_stmt|;
name|bt_t
modifier|*
name|btfree
decl_stmt|;
name|MPASS
argument_list|(
name|type
operator|==
name|BT_TYPE_SPAN
operator|||
name|type
operator|==
name|BT_TYPE_SPAN_STATIC
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
operator|(
name|size
operator|&
name|vm
operator|->
name|vm_quantum_mask
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|btspan
operator|=
name|bt_alloc
argument_list|(
name|vm
argument_list|)
expr_stmt|;
name|btspan
operator|->
name|bt_type
operator|=
name|type
expr_stmt|;
name|btspan
operator|->
name|bt_start
operator|=
name|addr
expr_stmt|;
name|btspan
operator|->
name|bt_size
operator|=
name|size
expr_stmt|;
name|bt_insseg_tail
argument_list|(
name|vm
argument_list|,
name|btspan
argument_list|)
expr_stmt|;
name|btfree
operator|=
name|bt_alloc
argument_list|(
name|vm
argument_list|)
expr_stmt|;
name|btfree
operator|->
name|bt_type
operator|=
name|BT_TYPE_FREE
expr_stmt|;
name|btfree
operator|->
name|bt_start
operator|=
name|addr
expr_stmt|;
name|btfree
operator|->
name|bt_size
operator|=
name|size
expr_stmt|;
name|bt_insseg
argument_list|(
name|vm
argument_list|,
name|btfree
argument_list|,
name|btspan
argument_list|)
expr_stmt|;
name|bt_insfree
argument_list|(
name|vm
argument_list|,
name|btfree
argument_list|)
expr_stmt|;
name|vm
operator|->
name|vm_size
operator|+=
name|size
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|vmem_destroy1
parameter_list|(
name|vmem_t
modifier|*
name|vm
parameter_list|)
block|{
name|bt_t
modifier|*
name|bt
decl_stmt|;
comment|/* 	 * Drain per-cpu quantum caches. 	 */
name|qc_destroy
argument_list|(
name|vm
argument_list|)
expr_stmt|;
comment|/* 	 * The vmem should now only contain empty segments. 	 */
name|VMEM_LOCK
argument_list|(
name|vm
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|vm
operator|->
name|vm_nbusytag
operator|==
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|bt
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|vm
operator|->
name|vm_seglist
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|bt_remseg
argument_list|(
name|vm
argument_list|,
name|bt
argument_list|)
expr_stmt|;
if|if
condition|(
name|vm
operator|->
name|vm_hashlist
operator|!=
name|NULL
operator|&&
name|vm
operator|->
name|vm_hashlist
operator|!=
name|vm
operator|->
name|vm_hash0
condition|)
name|free
argument_list|(
name|vm
operator|->
name|vm_hashlist
argument_list|,
name|M_VMEM
argument_list|)
expr_stmt|;
name|bt_freetrim
argument_list|(
name|vm
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|VMEM_CONDVAR_DESTROY
argument_list|(
name|vm
argument_list|)
expr_stmt|;
name|VMEM_LOCK_DESTROY
argument_list|(
name|vm
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|vm
argument_list|,
name|M_VMEM
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|vmem_import
parameter_list|(
name|vmem_t
modifier|*
name|vm
parameter_list|,
name|vmem_size_t
name|size
parameter_list|,
name|vmem_size_t
name|align
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|vmem_addr_t
name|addr
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|vm
operator|->
name|vm_importfn
operator|==
name|NULL
condition|)
return|return
name|EINVAL
return|;
comment|/* 	 * To make sure we get a span that meets the alignment we double it 	 * and add the size to the tail.  This slightly overestimates. 	 */
if|if
condition|(
name|align
operator|!=
name|vm
operator|->
name|vm_quantum_mask
operator|+
literal|1
condition|)
name|size
operator|=
operator|(
name|align
operator|*
literal|2
operator|)
operator|+
name|size
expr_stmt|;
name|size
operator|=
name|roundup
argument_list|(
name|size
argument_list|,
name|vm
operator|->
name|vm_import_quantum
argument_list|)
expr_stmt|;
comment|/* 	 * Hide MAXALLOC tags so we're guaranteed to be able to add this 	 * span and the tag we want to allocate from it. 	 */
name|MPASS
argument_list|(
name|vm
operator|->
name|vm_nfreetags
operator|>=
name|BT_MAXALLOC
argument_list|)
expr_stmt|;
name|vm
operator|->
name|vm_nfreetags
operator|-=
name|BT_MAXALLOC
expr_stmt|;
name|VMEM_UNLOCK
argument_list|(
name|vm
argument_list|)
expr_stmt|;
name|error
operator|=
call|(
name|vm
operator|->
name|vm_importfn
call|)
argument_list|(
name|vm
operator|->
name|vm_arg
argument_list|,
name|size
argument_list|,
name|flags
argument_list|,
operator|&
name|addr
argument_list|)
expr_stmt|;
name|VMEM_LOCK
argument_list|(
name|vm
argument_list|)
expr_stmt|;
name|vm
operator|->
name|vm_nfreetags
operator|+=
name|BT_MAXALLOC
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|ENOMEM
return|;
name|vmem_add1
argument_list|(
name|vm
argument_list|,
name|addr
argument_list|,
name|size
argument_list|,
name|BT_TYPE_SPAN
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * vmem_fit: check if a bt can satisfy the given restrictions.  *  * it's a caller's responsibility to ensure the region is big enough  * before calling us.  */
end_comment

begin_function
specifier|static
name|int
name|vmem_fit
parameter_list|(
specifier|const
name|bt_t
modifier|*
name|bt
parameter_list|,
name|vmem_size_t
name|size
parameter_list|,
name|vmem_size_t
name|align
parameter_list|,
name|vmem_size_t
name|phase
parameter_list|,
name|vmem_size_t
name|nocross
parameter_list|,
name|vmem_addr_t
name|minaddr
parameter_list|,
name|vmem_addr_t
name|maxaddr
parameter_list|,
name|vmem_addr_t
modifier|*
name|addrp
parameter_list|)
block|{
name|vmem_addr_t
name|start
decl_stmt|;
name|vmem_addr_t
name|end
decl_stmt|;
name|MPASS
argument_list|(
name|size
operator|>
literal|0
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|bt
operator|->
name|bt_size
operator|>=
name|size
argument_list|)
expr_stmt|;
comment|/* caller's responsibility */
comment|/* 	 * XXX assumption: vmem_addr_t and vmem_size_t are 	 * unsigned integer of the same size. 	 */
name|start
operator|=
name|bt
operator|->
name|bt_start
expr_stmt|;
if|if
condition|(
name|start
operator|<
name|minaddr
condition|)
block|{
name|start
operator|=
name|minaddr
expr_stmt|;
block|}
name|end
operator|=
name|BT_END
argument_list|(
name|bt
argument_list|)
expr_stmt|;
if|if
condition|(
name|end
operator|>
name|maxaddr
condition|)
name|end
operator|=
name|maxaddr
expr_stmt|;
if|if
condition|(
name|start
operator|>
name|end
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|start
operator|=
name|VMEM_ALIGNUP
argument_list|(
name|start
operator|-
name|phase
argument_list|,
name|align
argument_list|)
operator|+
name|phase
expr_stmt|;
if|if
condition|(
name|start
operator|<
name|bt
operator|->
name|bt_start
condition|)
name|start
operator|+=
name|align
expr_stmt|;
if|if
condition|(
name|VMEM_CROSS_P
argument_list|(
name|start
argument_list|,
name|start
operator|+
name|size
operator|-
literal|1
argument_list|,
name|nocross
argument_list|)
condition|)
block|{
name|MPASS
argument_list|(
name|align
operator|<
name|nocross
argument_list|)
expr_stmt|;
name|start
operator|=
name|VMEM_ALIGNUP
argument_list|(
name|start
operator|-
name|phase
argument_list|,
name|nocross
argument_list|)
operator|+
name|phase
expr_stmt|;
block|}
if|if
condition|(
name|start
operator|<=
name|end
operator|&&
name|end
operator|-
name|start
operator|>=
name|size
operator|-
literal|1
condition|)
block|{
name|MPASS
argument_list|(
operator|(
name|start
operator|&
operator|(
name|align
operator|-
literal|1
operator|)
operator|)
operator|==
name|phase
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
operator|!
name|VMEM_CROSS_P
argument_list|(
name|start
argument_list|,
name|start
operator|+
name|size
operator|-
literal|1
argument_list|,
name|nocross
argument_list|)
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|minaddr
operator|<=
name|start
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|maxaddr
operator|==
literal|0
operator|||
name|start
operator|+
name|size
operator|-
literal|1
operator|<=
name|maxaddr
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|bt
operator|->
name|bt_start
operator|<=
name|start
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|BT_END
argument_list|(
name|bt
argument_list|)
operator|-
name|start
operator|>=
name|size
operator|-
literal|1
argument_list|)
expr_stmt|;
operator|*
name|addrp
operator|=
name|start
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * vmem_clip:  Trim the boundary tag edges to the requested start and size.  */
end_comment

begin_function
specifier|static
name|void
name|vmem_clip
parameter_list|(
name|vmem_t
modifier|*
name|vm
parameter_list|,
name|bt_t
modifier|*
name|bt
parameter_list|,
name|vmem_addr_t
name|start
parameter_list|,
name|vmem_size_t
name|size
parameter_list|)
block|{
name|bt_t
modifier|*
name|btnew
decl_stmt|;
name|bt_t
modifier|*
name|btprev
decl_stmt|;
name|VMEM_ASSERT_LOCKED
argument_list|(
name|vm
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|bt
operator|->
name|bt_type
operator|==
name|BT_TYPE_FREE
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|bt
operator|->
name|bt_size
operator|>=
name|size
argument_list|)
expr_stmt|;
name|bt_remfree
argument_list|(
name|vm
argument_list|,
name|bt
argument_list|)
expr_stmt|;
if|if
condition|(
name|bt
operator|->
name|bt_start
operator|!=
name|start
condition|)
block|{
name|btprev
operator|=
name|bt_alloc
argument_list|(
name|vm
argument_list|)
expr_stmt|;
name|btprev
operator|->
name|bt_type
operator|=
name|BT_TYPE_FREE
expr_stmt|;
name|btprev
operator|->
name|bt_start
operator|=
name|bt
operator|->
name|bt_start
expr_stmt|;
name|btprev
operator|->
name|bt_size
operator|=
name|start
operator|-
name|bt
operator|->
name|bt_start
expr_stmt|;
name|bt
operator|->
name|bt_start
operator|=
name|start
expr_stmt|;
name|bt
operator|->
name|bt_size
operator|-=
name|btprev
operator|->
name|bt_size
expr_stmt|;
name|bt_insfree
argument_list|(
name|vm
argument_list|,
name|btprev
argument_list|)
expr_stmt|;
name|bt_insseg
argument_list|(
name|vm
argument_list|,
name|btprev
argument_list|,
name|TAILQ_PREV
argument_list|(
name|bt
argument_list|,
name|vmem_seglist
argument_list|,
name|bt_seglist
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|MPASS
argument_list|(
name|bt
operator|->
name|bt_start
operator|==
name|start
argument_list|)
expr_stmt|;
if|if
condition|(
name|bt
operator|->
name|bt_size
operator|!=
name|size
operator|&&
name|bt
operator|->
name|bt_size
operator|-
name|size
operator|>
name|vm
operator|->
name|vm_quantum_mask
condition|)
block|{
comment|/* split */
name|btnew
operator|=
name|bt_alloc
argument_list|(
name|vm
argument_list|)
expr_stmt|;
name|btnew
operator|->
name|bt_type
operator|=
name|BT_TYPE_BUSY
expr_stmt|;
name|btnew
operator|->
name|bt_start
operator|=
name|bt
operator|->
name|bt_start
expr_stmt|;
name|btnew
operator|->
name|bt_size
operator|=
name|size
expr_stmt|;
name|bt
operator|->
name|bt_start
operator|=
name|bt
operator|->
name|bt_start
operator|+
name|size
expr_stmt|;
name|bt
operator|->
name|bt_size
operator|-=
name|size
expr_stmt|;
name|bt_insfree
argument_list|(
name|vm
argument_list|,
name|bt
argument_list|)
expr_stmt|;
name|bt_insseg
argument_list|(
name|vm
argument_list|,
name|btnew
argument_list|,
name|TAILQ_PREV
argument_list|(
name|bt
argument_list|,
name|vmem_seglist
argument_list|,
name|bt_seglist
argument_list|)
argument_list|)
expr_stmt|;
name|bt_insbusy
argument_list|(
name|vm
argument_list|,
name|btnew
argument_list|)
expr_stmt|;
name|bt
operator|=
name|btnew
expr_stmt|;
block|}
else|else
block|{
name|bt
operator|->
name|bt_type
operator|=
name|BT_TYPE_BUSY
expr_stmt|;
name|bt_insbusy
argument_list|(
name|vm
argument_list|,
name|bt
argument_list|)
expr_stmt|;
block|}
name|MPASS
argument_list|(
name|bt
operator|->
name|bt_size
operator|>=
name|size
argument_list|)
expr_stmt|;
name|bt
operator|->
name|bt_type
operator|=
name|BT_TYPE_BUSY
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ---- vmem API */
end_comment

begin_function
name|void
name|vmem_set_import
parameter_list|(
name|vmem_t
modifier|*
name|vm
parameter_list|,
name|vmem_import_t
modifier|*
name|importfn
parameter_list|,
name|vmem_release_t
modifier|*
name|releasefn
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|vmem_size_t
name|import_quantum
parameter_list|)
block|{
name|VMEM_LOCK
argument_list|(
name|vm
argument_list|)
expr_stmt|;
name|vm
operator|->
name|vm_importfn
operator|=
name|importfn
expr_stmt|;
name|vm
operator|->
name|vm_releasefn
operator|=
name|releasefn
expr_stmt|;
name|vm
operator|->
name|vm_arg
operator|=
name|arg
expr_stmt|;
name|vm
operator|->
name|vm_import_quantum
operator|=
name|import_quantum
expr_stmt|;
name|VMEM_UNLOCK
argument_list|(
name|vm
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|vmem_set_reclaim
parameter_list|(
name|vmem_t
modifier|*
name|vm
parameter_list|,
name|vmem_reclaim_t
modifier|*
name|reclaimfn
parameter_list|)
block|{
name|VMEM_LOCK
argument_list|(
name|vm
argument_list|)
expr_stmt|;
name|vm
operator|->
name|vm_reclaimfn
operator|=
name|reclaimfn
expr_stmt|;
name|VMEM_UNLOCK
argument_list|(
name|vm
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * vmem_init: Initializes vmem arena.  */
end_comment

begin_function
name|vmem_t
modifier|*
name|vmem_init
parameter_list|(
name|vmem_t
modifier|*
name|vm
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|vmem_addr_t
name|base
parameter_list|,
name|vmem_size_t
name|size
parameter_list|,
name|vmem_size_t
name|quantum
parameter_list|,
name|vmem_size_t
name|qcache_max
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|MPASS
argument_list|(
name|quantum
operator|>
literal|0
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
operator|(
name|quantum
operator|&
operator|(
name|quantum
operator|-
literal|1
operator|)
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|vm
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|vm
argument_list|)
argument_list|)
expr_stmt|;
name|VMEM_CONDVAR_INIT
argument_list|(
name|vm
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|VMEM_LOCK_INIT
argument_list|(
name|vm
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|vm
operator|->
name|vm_nfreetags
operator|=
literal|0
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|vm
operator|->
name|vm_freetags
argument_list|)
expr_stmt|;
name|strlcpy
argument_list|(
name|vm
operator|->
name|vm_name
argument_list|,
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|vm
operator|->
name|vm_name
argument_list|)
argument_list|)
expr_stmt|;
name|vm
operator|->
name|vm_quantum_mask
operator|=
name|quantum
operator|-
literal|1
expr_stmt|;
name|vm
operator|->
name|vm_quantum_shift
operator|=
name|flsl
argument_list|(
name|quantum
argument_list|)
operator|-
literal|1
expr_stmt|;
name|vm
operator|->
name|vm_nbusytag
operator|=
literal|0
expr_stmt|;
name|vm
operator|->
name|vm_size
operator|=
literal|0
expr_stmt|;
name|vm
operator|->
name|vm_inuse
operator|=
literal|0
expr_stmt|;
name|qc_init
argument_list|(
name|vm
argument_list|,
name|qcache_max
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|vm
operator|->
name|vm_seglist
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|VMEM_MAXORDER
condition|;
name|i
operator|++
control|)
block|{
name|LIST_INIT
argument_list|(
operator|&
name|vm
operator|->
name|vm_freelist
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|memset
argument_list|(
operator|&
name|vm
operator|->
name|vm_hash0
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|vm
operator|->
name|vm_hash0
argument_list|)
argument_list|)
expr_stmt|;
name|vm
operator|->
name|vm_hashsize
operator|=
name|VMEM_HASHSIZE_MIN
expr_stmt|;
name|vm
operator|->
name|vm_hashlist
operator|=
name|vm
operator|->
name|vm_hash0
expr_stmt|;
if|if
condition|(
name|size
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|vmem_add
argument_list|(
name|vm
argument_list|,
name|base
argument_list|,
name|size
argument_list|,
name|flags
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|vmem_destroy1
argument_list|(
name|vm
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
name|mtx_lock
argument_list|(
operator|&
name|vmem_list_lock
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|vmem_list
argument_list|,
name|vm
argument_list|,
name|vm_alllist
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|vmem_list_lock
argument_list|)
expr_stmt|;
return|return
name|vm
return|;
block|}
end_function

begin_comment
comment|/*  * vmem_create: create an arena.  */
end_comment

begin_function
name|vmem_t
modifier|*
name|vmem_create
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|vmem_addr_t
name|base
parameter_list|,
name|vmem_size_t
name|size
parameter_list|,
name|vmem_size_t
name|quantum
parameter_list|,
name|vmem_size_t
name|qcache_max
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|vmem_t
modifier|*
name|vm
decl_stmt|;
name|vm
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|vm
argument_list|)
argument_list|,
name|M_VMEM
argument_list|,
name|flags
operator|&
operator|(
name|M_WAITOK
operator||
name|M_NOWAIT
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|vm
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
name|vmem_init
argument_list|(
name|vm
argument_list|,
name|name
argument_list|,
name|base
argument_list|,
name|size
argument_list|,
name|quantum
argument_list|,
name|qcache_max
argument_list|,
name|flags
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|vm
argument_list|,
name|M_VMEM
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
return|return
operator|(
name|vm
operator|)
return|;
block|}
end_function

begin_function
name|void
name|vmem_destroy
parameter_list|(
name|vmem_t
modifier|*
name|vm
parameter_list|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|vmem_list_lock
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|vm
argument_list|,
name|vm_alllist
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|vmem_list_lock
argument_list|)
expr_stmt|;
name|vmem_destroy1
argument_list|(
name|vm
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|vmem_size_t
name|vmem_roundup_size
parameter_list|(
name|vmem_t
modifier|*
name|vm
parameter_list|,
name|vmem_size_t
name|size
parameter_list|)
block|{
return|return
operator|(
name|size
operator|+
name|vm
operator|->
name|vm_quantum_mask
operator|)
operator|&
operator|~
name|vm
operator|->
name|vm_quantum_mask
return|;
block|}
end_function

begin_comment
comment|/*  * vmem_alloc: allocate resource from the arena.  */
end_comment

begin_function
name|int
name|vmem_alloc
parameter_list|(
name|vmem_t
modifier|*
name|vm
parameter_list|,
name|vmem_size_t
name|size
parameter_list|,
name|int
name|flags
parameter_list|,
name|vmem_addr_t
modifier|*
name|addrp
parameter_list|)
block|{
specifier|const
name|int
name|strat
name|__unused
init|=
name|flags
operator|&
name|VMEM_FITMASK
decl_stmt|;
name|qcache_t
modifier|*
name|qc
decl_stmt|;
name|flags
operator|&=
name|VMEM_FLAGS
expr_stmt|;
name|MPASS
argument_list|(
name|size
operator|>
literal|0
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|strat
operator|==
name|M_BESTFIT
operator|||
name|strat
operator|==
name|M_FIRSTFIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|M_NOWAIT
operator|)
operator|==
literal|0
condition|)
name|WITNESS_WARN
argument_list|(
name|WARN_GIANTOK
operator||
name|WARN_SLEEPOK
argument_list|,
name|NULL
argument_list|,
literal|"vmem_alloc"
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|<=
name|vm
operator|->
name|vm_qcache_max
condition|)
block|{
name|qc
operator|=
operator|&
name|vm
operator|->
name|vm_qcache
index|[
operator|(
name|size
operator|-
literal|1
operator|)
operator|>>
name|vm
operator|->
name|vm_quantum_shift
index|]
expr_stmt|;
operator|*
name|addrp
operator|=
operator|(
name|vmem_addr_t
operator|)
name|uma_zalloc
argument_list|(
name|qc
operator|->
name|qc_cache
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|addrp
operator|==
literal|0
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
name|vmem_xalloc
argument_list|(
name|vm
argument_list|,
name|size
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|VMEM_ADDR_MIN
argument_list|,
name|VMEM_ADDR_MAX
argument_list|,
name|flags
argument_list|,
name|addrp
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|vmem_xalloc
parameter_list|(
name|vmem_t
modifier|*
name|vm
parameter_list|,
specifier|const
name|vmem_size_t
name|size0
parameter_list|,
name|vmem_size_t
name|align
parameter_list|,
specifier|const
name|vmem_size_t
name|phase
parameter_list|,
specifier|const
name|vmem_size_t
name|nocross
parameter_list|,
specifier|const
name|vmem_addr_t
name|minaddr
parameter_list|,
specifier|const
name|vmem_addr_t
name|maxaddr
parameter_list|,
name|int
name|flags
parameter_list|,
name|vmem_addr_t
modifier|*
name|addrp
parameter_list|)
block|{
specifier|const
name|vmem_size_t
name|size
init|=
name|vmem_roundup_size
argument_list|(
name|vm
argument_list|,
name|size0
argument_list|)
decl_stmt|;
name|struct
name|vmem_freelist
modifier|*
name|list
decl_stmt|;
name|struct
name|vmem_freelist
modifier|*
name|first
decl_stmt|;
name|struct
name|vmem_freelist
modifier|*
name|end
decl_stmt|;
name|vmem_size_t
name|avail
decl_stmt|;
name|bt_t
modifier|*
name|bt
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|strat
decl_stmt|;
name|flags
operator|&=
name|VMEM_FLAGS
expr_stmt|;
name|strat
operator|=
name|flags
operator|&
name|VMEM_FITMASK
expr_stmt|;
name|MPASS
argument_list|(
name|size0
operator|>
literal|0
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|size
operator|>
literal|0
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|strat
operator|==
name|M_BESTFIT
operator|||
name|strat
operator|==
name|M_FIRSTFIT
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
operator|(
name|flags
operator|&
operator|(
name|M_NOWAIT
operator||
name|M_WAITOK
operator|)
operator|)
operator|!=
operator|(
name|M_NOWAIT
operator||
name|M_WAITOK
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|M_NOWAIT
operator|)
operator|==
literal|0
condition|)
name|WITNESS_WARN
argument_list|(
name|WARN_GIANTOK
operator||
name|WARN_SLEEPOK
argument_list|,
name|NULL
argument_list|,
literal|"vmem_xalloc"
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
operator|(
name|align
operator|&
name|vm
operator|->
name|vm_quantum_mask
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
operator|(
name|align
operator|&
operator|(
name|align
operator|-
literal|1
operator|)
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
operator|(
name|phase
operator|&
name|vm
operator|->
name|vm_quantum_mask
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
operator|(
name|nocross
operator|&
name|vm
operator|->
name|vm_quantum_mask
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
operator|(
name|nocross
operator|&
operator|(
name|nocross
operator|-
literal|1
operator|)
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
operator|(
name|align
operator|==
literal|0
operator|&&
name|phase
operator|==
literal|0
operator|)
operator|||
name|phase
operator|<
name|align
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|nocross
operator|==
literal|0
operator|||
name|nocross
operator|>=
name|size
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|minaddr
operator|<=
name|maxaddr
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
operator|!
name|VMEM_CROSS_P
argument_list|(
name|phase
argument_list|,
name|phase
operator|+
name|size
operator|-
literal|1
argument_list|,
name|nocross
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|align
operator|==
literal|0
condition|)
name|align
operator|=
name|vm
operator|->
name|vm_quantum_mask
operator|+
literal|1
expr_stmt|;
operator|*
name|addrp
operator|=
literal|0
expr_stmt|;
name|end
operator|=
operator|&
name|vm
operator|->
name|vm_freelist
index|[
name|VMEM_MAXORDER
index|]
expr_stmt|;
comment|/* 	 * choose a free block from which we allocate. 	 */
name|first
operator|=
name|bt_freehead_toalloc
argument_list|(
name|vm
argument_list|,
name|size
argument_list|,
name|strat
argument_list|)
expr_stmt|;
name|VMEM_LOCK
argument_list|(
name|vm
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* 		 * Make sure we have enough tags to complete the 		 * operation. 		 */
if|if
condition|(
name|vm
operator|->
name|vm_nfreetags
operator|<
name|BT_MAXALLOC
operator|&&
name|bt_fill
argument_list|(
name|vm
argument_list|,
name|flags
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|error
operator|=
name|ENOMEM
expr_stmt|;
break|break;
block|}
comment|/* 	 	 * Scan freelists looking for a tag that satisfies the 		 * allocation.  If we're doing BESTFIT we may encounter 		 * sizes below the request.  If we're doing FIRSTFIT we 		 * inspect only the first element from each list. 		 */
for|for
control|(
name|list
operator|=
name|first
init|;
name|list
operator|<
name|end
condition|;
name|list
operator|++
control|)
block|{
name|LIST_FOREACH
argument_list|(
argument|bt
argument_list|,
argument|list
argument_list|,
argument|bt_freelist
argument_list|)
block|{
if|if
condition|(
name|bt
operator|->
name|bt_size
operator|>=
name|size
condition|)
block|{
name|error
operator|=
name|vmem_fit
argument_list|(
name|bt
argument_list|,
name|size
argument_list|,
name|align
argument_list|,
name|phase
argument_list|,
name|nocross
argument_list|,
name|minaddr
argument_list|,
name|maxaddr
argument_list|,
name|addrp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|vmem_clip
argument_list|(
name|vm
argument_list|,
name|bt
argument_list|,
operator|*
name|addrp
argument_list|,
name|size
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
comment|/* FIRST skips to the next list. */
if|if
condition|(
name|strat
operator|==
name|M_FIRSTFIT
condition|)
break|break;
block|}
block|}
comment|/* 		 * Retry if the fast algorithm failed. 		 */
if|if
condition|(
name|strat
operator|==
name|M_FIRSTFIT
condition|)
block|{
name|strat
operator|=
name|M_BESTFIT
expr_stmt|;
name|first
operator|=
name|bt_freehead_toalloc
argument_list|(
name|vm
argument_list|,
name|size
argument_list|,
name|strat
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * XXX it is possible to fail to meet restrictions with the 		 * imported region.  It is up to the user to specify the 		 * import quantum such that it can satisfy any allocation. 		 */
if|if
condition|(
name|vmem_import
argument_list|(
name|vm
argument_list|,
name|size
argument_list|,
name|align
argument_list|,
name|flags
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
comment|/* 		 * Try to free some space from the quantum cache or reclaim 		 * functions if available. 		 */
if|if
condition|(
name|vm
operator|->
name|vm_qcache_max
operator|!=
literal|0
operator|||
name|vm
operator|->
name|vm_reclaimfn
operator|!=
name|NULL
condition|)
block|{
name|avail
operator|=
name|vm
operator|->
name|vm_size
operator|-
name|vm
operator|->
name|vm_inuse
expr_stmt|;
name|VMEM_UNLOCK
argument_list|(
name|vm
argument_list|)
expr_stmt|;
if|if
condition|(
name|vm
operator|->
name|vm_qcache_max
operator|!=
literal|0
condition|)
name|qc_drain
argument_list|(
name|vm
argument_list|)
expr_stmt|;
if|if
condition|(
name|vm
operator|->
name|vm_reclaimfn
operator|!=
name|NULL
condition|)
name|vm
operator|->
name|vm_reclaimfn
argument_list|(
name|vm
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|VMEM_LOCK
argument_list|(
name|vm
argument_list|)
expr_stmt|;
comment|/* If we were successful retry even NOWAIT. */
if|if
condition|(
name|vm
operator|->
name|vm_size
operator|-
name|vm
operator|->
name|vm_inuse
operator|>
name|avail
condition|)
continue|continue;
block|}
if|if
condition|(
operator|(
name|flags
operator|&
name|M_NOWAIT
operator|)
operator|!=
literal|0
condition|)
block|{
name|error
operator|=
name|ENOMEM
expr_stmt|;
break|break;
block|}
name|VMEM_CONDVAR_WAIT
argument_list|(
name|vm
argument_list|)
expr_stmt|;
block|}
name|out
label|:
name|VMEM_UNLOCK
argument_list|(
name|vm
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
operator|&&
operator|(
name|flags
operator|&
name|M_NOWAIT
operator|)
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"failed to allocate waiting allocation\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * vmem_free: free the resource to the arena.  */
end_comment

begin_function
name|void
name|vmem_free
parameter_list|(
name|vmem_t
modifier|*
name|vm
parameter_list|,
name|vmem_addr_t
name|addr
parameter_list|,
name|vmem_size_t
name|size
parameter_list|)
block|{
name|qcache_t
modifier|*
name|qc
decl_stmt|;
name|MPASS
argument_list|(
name|size
operator|>
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|<=
name|vm
operator|->
name|vm_qcache_max
condition|)
block|{
name|qc
operator|=
operator|&
name|vm
operator|->
name|vm_qcache
index|[
operator|(
name|size
operator|-
literal|1
operator|)
operator|>>
name|vm
operator|->
name|vm_quantum_shift
index|]
expr_stmt|;
name|uma_zfree
argument_list|(
name|qc
operator|->
name|qc_cache
argument_list|,
operator|(
name|void
operator|*
operator|)
name|addr
argument_list|)
expr_stmt|;
block|}
else|else
name|vmem_xfree
argument_list|(
name|vm
argument_list|,
name|addr
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|vmem_xfree
parameter_list|(
name|vmem_t
modifier|*
name|vm
parameter_list|,
name|vmem_addr_t
name|addr
parameter_list|,
name|vmem_size_t
name|size
parameter_list|)
block|{
name|bt_t
modifier|*
name|bt
decl_stmt|;
name|bt_t
modifier|*
name|t
decl_stmt|;
name|MPASS
argument_list|(
name|size
operator|>
literal|0
argument_list|)
expr_stmt|;
name|VMEM_LOCK
argument_list|(
name|vm
argument_list|)
expr_stmt|;
name|bt
operator|=
name|bt_lookupbusy
argument_list|(
name|vm
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|bt
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|bt
operator|->
name|bt_start
operator|==
name|addr
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|bt
operator|->
name|bt_size
operator|==
name|vmem_roundup_size
argument_list|(
name|vm
argument_list|,
name|size
argument_list|)
operator|||
name|bt
operator|->
name|bt_size
operator|-
name|vmem_roundup_size
argument_list|(
name|vm
argument_list|,
name|size
argument_list|)
operator|<=
name|vm
operator|->
name|vm_quantum_mask
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|bt
operator|->
name|bt_type
operator|==
name|BT_TYPE_BUSY
argument_list|)
expr_stmt|;
name|bt_rembusy
argument_list|(
name|vm
argument_list|,
name|bt
argument_list|)
expr_stmt|;
name|bt
operator|->
name|bt_type
operator|=
name|BT_TYPE_FREE
expr_stmt|;
comment|/* coalesce */
name|t
operator|=
name|TAILQ_NEXT
argument_list|(
name|bt
argument_list|,
name|bt_seglist
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|!=
name|NULL
operator|&&
name|t
operator|->
name|bt_type
operator|==
name|BT_TYPE_FREE
condition|)
block|{
name|MPASS
argument_list|(
name|BT_END
argument_list|(
name|bt
argument_list|)
operator|<
name|t
operator|->
name|bt_start
argument_list|)
expr_stmt|;
comment|/* YYY */
name|bt
operator|->
name|bt_size
operator|+=
name|t
operator|->
name|bt_size
expr_stmt|;
name|bt_remfree
argument_list|(
name|vm
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|bt_remseg
argument_list|(
name|vm
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
name|t
operator|=
name|TAILQ_PREV
argument_list|(
name|bt
argument_list|,
name|vmem_seglist
argument_list|,
name|bt_seglist
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|!=
name|NULL
operator|&&
name|t
operator|->
name|bt_type
operator|==
name|BT_TYPE_FREE
condition|)
block|{
name|MPASS
argument_list|(
name|BT_END
argument_list|(
name|t
argument_list|)
operator|<
name|bt
operator|->
name|bt_start
argument_list|)
expr_stmt|;
comment|/* YYY */
name|bt
operator|->
name|bt_size
operator|+=
name|t
operator|->
name|bt_size
expr_stmt|;
name|bt
operator|->
name|bt_start
operator|=
name|t
operator|->
name|bt_start
expr_stmt|;
name|bt_remfree
argument_list|(
name|vm
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|bt_remseg
argument_list|(
name|vm
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
name|t
operator|=
name|TAILQ_PREV
argument_list|(
name|bt
argument_list|,
name|vmem_seglist
argument_list|,
name|bt_seglist
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|t
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|BT_ISSPAN_P
argument_list|(
name|t
argument_list|)
operator|||
name|t
operator|->
name|bt_type
operator|==
name|BT_TYPE_BUSY
argument_list|)
expr_stmt|;
if|if
condition|(
name|vm
operator|->
name|vm_releasefn
operator|!=
name|NULL
operator|&&
name|t
operator|->
name|bt_type
operator|==
name|BT_TYPE_SPAN
operator|&&
name|t
operator|->
name|bt_size
operator|==
name|bt
operator|->
name|bt_size
condition|)
block|{
name|vmem_addr_t
name|spanaddr
decl_stmt|;
name|vmem_size_t
name|spansize
decl_stmt|;
name|MPASS
argument_list|(
name|t
operator|->
name|bt_start
operator|==
name|bt
operator|->
name|bt_start
argument_list|)
expr_stmt|;
name|spanaddr
operator|=
name|bt
operator|->
name|bt_start
expr_stmt|;
name|spansize
operator|=
name|bt
operator|->
name|bt_size
expr_stmt|;
name|bt_remseg
argument_list|(
name|vm
argument_list|,
name|bt
argument_list|)
expr_stmt|;
name|bt_remseg
argument_list|(
name|vm
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|vm
operator|->
name|vm_size
operator|-=
name|spansize
expr_stmt|;
name|VMEM_CONDVAR_BROADCAST
argument_list|(
name|vm
argument_list|)
expr_stmt|;
name|bt_freetrim
argument_list|(
name|vm
argument_list|,
name|BT_MAXFREE
argument_list|)
expr_stmt|;
call|(
modifier|*
name|vm
operator|->
name|vm_releasefn
call|)
argument_list|(
name|vm
operator|->
name|vm_arg
argument_list|,
name|spanaddr
argument_list|,
name|spansize
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bt_insfree
argument_list|(
name|vm
argument_list|,
name|bt
argument_list|)
expr_stmt|;
name|VMEM_CONDVAR_BROADCAST
argument_list|(
name|vm
argument_list|)
expr_stmt|;
name|bt_freetrim
argument_list|(
name|vm
argument_list|,
name|BT_MAXFREE
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * vmem_add:  *  */
end_comment

begin_function
name|int
name|vmem_add
parameter_list|(
name|vmem_t
modifier|*
name|vm
parameter_list|,
name|vmem_addr_t
name|addr
parameter_list|,
name|vmem_size_t
name|size
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|flags
operator|&=
name|VMEM_FLAGS
expr_stmt|;
name|VMEM_LOCK
argument_list|(
name|vm
argument_list|)
expr_stmt|;
if|if
condition|(
name|vm
operator|->
name|vm_nfreetags
operator|>=
name|BT_MAXALLOC
operator|||
name|bt_fill
argument_list|(
name|vm
argument_list|,
name|flags
argument_list|)
operator|==
literal|0
condition|)
name|vmem_add1
argument_list|(
name|vm
argument_list|,
name|addr
argument_list|,
name|size
argument_list|,
name|BT_TYPE_SPAN_STATIC
argument_list|)
expr_stmt|;
else|else
name|error
operator|=
name|ENOMEM
expr_stmt|;
name|VMEM_UNLOCK
argument_list|(
name|vm
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * vmem_size: information about arenas size  */
end_comment

begin_function
name|vmem_size_t
name|vmem_size
parameter_list|(
name|vmem_t
modifier|*
name|vm
parameter_list|,
name|int
name|typemask
parameter_list|)
block|{
switch|switch
condition|(
name|typemask
condition|)
block|{
case|case
name|VMEM_ALLOC
case|:
return|return
name|vm
operator|->
name|vm_inuse
return|;
case|case
name|VMEM_FREE
case|:
return|return
name|vm
operator|->
name|vm_size
operator|-
name|vm
operator|->
name|vm_inuse
return|;
case|case
name|VMEM_FREE
operator||
name|VMEM_ALLOC
case|:
return|return
name|vm
operator|->
name|vm_size
return|;
default|default:
name|panic
argument_list|(
literal|"vmem_size"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* ---- debug */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|DDB
argument_list|)
operator|||
name|defined
argument_list|(
name|DIAGNOSTIC
argument_list|)
end_if

begin_decl_stmt
specifier|static
name|void
name|bt_dump
argument_list|(
specifier|const
name|bt_t
operator|*
argument_list|,
name|int
argument_list|(
argument|*
argument_list|)
operator|(
specifier|const
name|char
operator|*
operator|,
operator|...
operator|)
name|__printflike
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|bt_type_string
parameter_list|(
name|int
name|type
parameter_list|)
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|BT_TYPE_BUSY
case|:
return|return
literal|"busy"
return|;
case|case
name|BT_TYPE_FREE
case|:
return|return
literal|"free"
return|;
case|case
name|BT_TYPE_SPAN
case|:
return|return
literal|"span"
return|;
case|case
name|BT_TYPE_SPAN_STATIC
case|:
return|return
literal|"static span"
return|;
default|default:
break|break;
block|}
return|return
literal|"BOGUS"
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|bt_dump
parameter_list|(
specifier|const
name|bt_t
modifier|*
name|bt
parameter_list|,
name|int
function_decl|(
modifier|*
name|pr
function_decl|)
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
modifier|...
parameter_list|)
parameter_list|)
block|{
call|(
modifier|*
name|pr
call|)
argument_list|(
literal|"\t%p: %jx %jx, %d(%s)\n"
argument_list|,
name|bt
argument_list|,
operator|(
name|intmax_t
operator|)
name|bt
operator|->
name|bt_start
argument_list|,
operator|(
name|intmax_t
operator|)
name|bt
operator|->
name|bt_size
argument_list|,
name|bt
operator|->
name|bt_type
argument_list|,
name|bt_type_string
argument_list|(
name|bt
operator|->
name|bt_type
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|void
name|vmem_dump
argument_list|(
specifier|const
name|vmem_t
operator|*
name|vm
argument_list|,
name|int
argument_list|(
argument|*pr
argument_list|)
operator|(
specifier|const
name|char
operator|*
operator|,
operator|...
operator|)
name|__printflike
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|)
argument_list|)
block|{
specifier|const
name|bt_t
modifier|*
name|bt
decl_stmt|;
name|int
name|i
decl_stmt|;
call|(
modifier|*
name|pr
call|)
argument_list|(
literal|"vmem %p '%s'\n"
argument_list|,
name|vm
argument_list|,
name|vm
operator|->
name|vm_name
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|bt
argument_list|,
argument|&vm->vm_seglist
argument_list|,
argument|bt_seglist
argument_list|)
block|{
name|bt_dump
argument_list|(
name|bt
argument_list|,
name|pr
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|VMEM_MAXORDER
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|struct
name|vmem_freelist
modifier|*
name|fl
init|=
operator|&
name|vm
operator|->
name|vm_freelist
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|LIST_EMPTY
argument_list|(
name|fl
argument_list|)
condition|)
block|{
continue|continue;
block|}
call|(
modifier|*
name|pr
call|)
argument_list|(
literal|"freelist[%d]\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|bt
argument_list|,
argument|fl
argument_list|,
argument|bt_freelist
argument_list|)
block|{
name|bt_dump
argument_list|(
name|bt
argument_list|,
name|pr
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* defined(DDB) || defined(DIAGNOSTIC) */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|DDB
argument_list|)
end_if

begin_function
specifier|static
name|bt_t
modifier|*
name|vmem_whatis_lookup
parameter_list|(
name|vmem_t
modifier|*
name|vm
parameter_list|,
name|vmem_addr_t
name|addr
parameter_list|)
block|{
name|bt_t
modifier|*
name|bt
decl_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|bt
argument_list|,
argument|&vm->vm_seglist
argument_list|,
argument|bt_seglist
argument_list|)
block|{
if|if
condition|(
name|BT_ISSPAN_P
argument_list|(
name|bt
argument_list|)
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|bt
operator|->
name|bt_start
operator|<=
name|addr
operator|&&
name|addr
operator|<=
name|BT_END
argument_list|(
name|bt
argument_list|)
condition|)
block|{
return|return
name|bt
return|;
block|}
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
name|void
name|vmem_whatis
parameter_list|(
name|vmem_addr_t
name|addr
parameter_list|,
name|int
function_decl|(
modifier|*
name|pr
function_decl|)
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
modifier|...
parameter_list|)
parameter_list|)
block|{
name|vmem_t
modifier|*
name|vm
decl_stmt|;
name|LIST_FOREACH
argument_list|(
argument|vm
argument_list|,
argument|&vmem_list
argument_list|,
argument|vm_alllist
argument_list|)
block|{
name|bt_t
modifier|*
name|bt
decl_stmt|;
name|bt
operator|=
name|vmem_whatis_lookup
argument_list|(
name|vm
argument_list|,
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|bt
operator|==
name|NULL
condition|)
block|{
continue|continue;
block|}
call|(
modifier|*
name|pr
call|)
argument_list|(
literal|"%p is %p+%zu in VMEM '%s' (%s)\n"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|addr
argument_list|,
operator|(
name|void
operator|*
operator|)
name|bt
operator|->
name|bt_start
argument_list|,
call|(
name|vmem_size_t
call|)
argument_list|(
name|addr
operator|-
name|bt
operator|->
name|bt_start
argument_list|)
argument_list|,
name|vm
operator|->
name|vm_name
argument_list|,
operator|(
name|bt
operator|->
name|bt_type
operator|==
name|BT_TYPE_BUSY
operator|)
condition|?
literal|"allocated"
else|:
literal|"free"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|vmem_printall
parameter_list|(
specifier|const
name|char
modifier|*
name|modif
parameter_list|,
name|int
function_decl|(
modifier|*
name|pr
function_decl|)
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
modifier|...
parameter_list|)
parameter_list|)
block|{
specifier|const
name|vmem_t
modifier|*
name|vm
decl_stmt|;
name|LIST_FOREACH
argument_list|(
argument|vm
argument_list|,
argument|&vmem_list
argument_list|,
argument|vm_alllist
argument_list|)
block|{
name|vmem_dump
argument_list|(
name|vm
argument_list|,
name|pr
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|vmem_print
parameter_list|(
name|vmem_addr_t
name|addr
parameter_list|,
specifier|const
name|char
modifier|*
name|modif
parameter_list|,
name|int
function_decl|(
modifier|*
name|pr
function_decl|)
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
modifier|...
parameter_list|)
parameter_list|)
block|{
specifier|const
name|vmem_t
modifier|*
name|vm
init|=
operator|(
specifier|const
name|void
operator|*
operator|)
name|addr
decl_stmt|;
name|vmem_dump
argument_list|(
name|vm
argument_list|,
name|pr
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* defined(DDB) */
end_comment

begin_define
define|#
directive|define
name|vmem_printf
value|printf
end_define

begin_if
if|#
directive|if
name|defined
argument_list|(
name|DIAGNOSTIC
argument_list|)
end_if

begin_function
specifier|static
name|bool
name|vmem_check_sanity
parameter_list|(
name|vmem_t
modifier|*
name|vm
parameter_list|)
block|{
specifier|const
name|bt_t
modifier|*
name|bt
decl_stmt|,
modifier|*
name|bt2
decl_stmt|;
name|MPASS
argument_list|(
name|vm
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|bt
argument_list|,
argument|&vm->vm_seglist
argument_list|,
argument|bt_seglist
argument_list|)
block|{
if|if
condition|(
name|bt
operator|->
name|bt_start
operator|>
name|BT_END
argument_list|(
name|bt
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"corrupted tag\n"
argument_list|)
expr_stmt|;
name|bt_dump
argument_list|(
name|bt
argument_list|,
name|vmem_printf
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
block|}
name|TAILQ_FOREACH
argument_list|(
argument|bt
argument_list|,
argument|&vm->vm_seglist
argument_list|,
argument|bt_seglist
argument_list|)
block|{
name|TAILQ_FOREACH
argument_list|(
argument|bt2
argument_list|,
argument|&vm->vm_seglist
argument_list|,
argument|bt_seglist
argument_list|)
block|{
if|if
condition|(
name|bt
operator|==
name|bt2
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|BT_ISSPAN_P
argument_list|(
name|bt
argument_list|)
operator|!=
name|BT_ISSPAN_P
argument_list|(
name|bt2
argument_list|)
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|bt
operator|->
name|bt_start
operator|<=
name|BT_END
argument_list|(
name|bt2
argument_list|)
operator|&&
name|bt2
operator|->
name|bt_start
operator|<=
name|BT_END
argument_list|(
name|bt
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"overwrapped tags\n"
argument_list|)
expr_stmt|;
name|bt_dump
argument_list|(
name|bt
argument_list|,
name|vmem_printf
argument_list|)
expr_stmt|;
name|bt_dump
argument_list|(
name|bt2
argument_list|,
name|vmem_printf
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
block|}
block|}
return|return
name|true
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|vmem_check
parameter_list|(
name|vmem_t
modifier|*
name|vm
parameter_list|)
block|{
if|if
condition|(
operator|!
name|vmem_check_sanity
argument_list|(
name|vm
argument_list|)
condition|)
block|{
name|panic
argument_list|(
literal|"insanity vmem %p"
argument_list|,
name|vm
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* defined(DIAGNOSTIC) */
end_comment

end_unit

