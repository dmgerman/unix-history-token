begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2007 Attilio Rao<attilio@freebsd.org>  * Copyright (c) 2001 Jason Evans<jasone@freebsd.org>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice(s), this list of conditions and the following disclaimer as  *    the first lines of this file unmodified other than the possible  *    addition of one or more copyright notices.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice(s), this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER(S) ``AS IS'' AND ANY  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE  * DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT HOLDER(S) BE LIABLE FOR ANY  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER  * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH  * DAMAGE.  */
end_comment

begin_comment
comment|/*  * Shared/exclusive locks.  This implementation attempts to ensure  * deterministic lock granting behavior, so that slocks and xlocks are  * interleaved.  *  * Priority propagation will not generally raise the priority of lock holders,  * so should not be relied upon in combination with sx locks.  */
end_comment

begin_include
include|#
directive|include
file|"opt_adaptive_sx.h"
end_include

begin_include
include|#
directive|include
file|"opt_ddb.h"
end_include

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/ktr.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock_profile.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/sleepqueue.h>
end_include

begin_include
include|#
directive|include
file|<sys/sx.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|ADAPTIVE_SX
end_ifdef

begin_include
include|#
directive|include
file|<machine/cpu.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|DDB
end_ifdef

begin_include
include|#
directive|include
file|<ddb/ddb.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|SMP
argument_list|)
operator|&&
name|defined
argument_list|(
name|ADAPTIVE_SX
argument_list|)
end_if

begin_error
error|#
directive|error
literal|"You must have SMP to enable the ADAPTIVE_SX option"
end_error

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Handy macros for sleep queues. */
end_comment

begin_define
define|#
directive|define
name|SQ_EXCLUSIVE_QUEUE
value|0
end_define

begin_define
define|#
directive|define
name|SQ_SHARED_QUEUE
value|1
end_define

begin_comment
comment|/*  * Variations on DROP_GIANT()/PICKUP_GIANT() for use in this file.  We  * drop Giant anytime we have to sleep or if we adaptively spin.  */
end_comment

begin_define
define|#
directive|define
name|GIANT_DECLARE
define|\
value|int _giantcnt = 0;						\ 	WITNESS_SAVE_DECL(Giant)					\  #define	GIANT_SAVE() do {						\ 	if (mtx_owned(&Giant)) {					\ 		WITNESS_SAVE(&Giant.lock_object, Giant);		\ 		while (mtx_owned(&Giant)) {				\ 			_giantcnt++;					\ 			mtx_unlock(&Giant);				\ 		}							\ 	}								\ } while (0)
end_define

begin_define
define|#
directive|define
name|GIANT_RESTORE
parameter_list|()
value|do {						\ 	if (_giantcnt> 0) {						\ 		mtx_assert(&Giant, MA_NOTOWNED);			\ 		while (_giantcnt--)					\ 			mtx_lock(&Giant);				\ 		WITNESS_RESTORE(&Giant.lock_object, Giant);		\ 	}								\ } while (0)
end_define

begin_comment
comment|/*  * Returns true if an exclusive lock is recursed.  It curthread  * currently has an exclusive lock.  */
end_comment

begin_define
define|#
directive|define
name|sx_recursed
parameter_list|(
name|sx
parameter_list|)
value|((sx)->sx_recurse != 0)
end_define

begin_comment
comment|/*  * Return a pointer to the owning thread if the lock is exclusively  * locked.  */
end_comment

begin_define
define|#
directive|define
name|sx_xholder
parameter_list|(
name|sx
parameter_list|)
define|\
value|((sx)->sx_lock& SX_LOCK_SHARED ? NULL :			\ 	(struct thread *)SX_OWNER((sx)->sx_lock))
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|DDB
end_ifdef

begin_function_decl
specifier|static
name|void
name|db_show_sx
parameter_list|(
name|struct
name|lock_object
modifier|*
name|lock
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|lock_sx
parameter_list|(
name|struct
name|lock_object
modifier|*
name|lock
parameter_list|,
name|int
name|how
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|unlock_sx
parameter_list|(
name|struct
name|lock_object
modifier|*
name|lock
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|struct
name|lock_class
name|lock_class_sx
init|=
block|{
operator|.
name|lc_name
operator|=
literal|"sx"
block|,
operator|.
name|lc_flags
operator|=
name|LC_SLEEPLOCK
operator||
name|LC_SLEEPABLE
operator||
name|LC_RECURSABLE
operator||
name|LC_UPGRADABLE
block|,
ifdef|#
directive|ifdef
name|DDB
operator|.
name|lc_ddb_show
operator|=
name|db_show_sx
block|,
endif|#
directive|endif
operator|.
name|lc_lock
operator|=
name|lock_sx
block|,
operator|.
name|lc_unlock
operator|=
name|unlock_sx
block|, }
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|INVARIANTS
end_ifndef

begin_define
define|#
directive|define
name|_sx_assert
parameter_list|(
name|sx
parameter_list|,
name|what
parameter_list|,
name|file
parameter_list|,
name|line
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|lock_sx
parameter_list|(
name|struct
name|lock_object
modifier|*
name|lock
parameter_list|,
name|int
name|how
parameter_list|)
block|{
name|struct
name|sx
modifier|*
name|sx
decl_stmt|;
name|sx
operator|=
operator|(
expr|struct
name|sx
operator|*
operator|)
name|lock
expr_stmt|;
if|if
condition|(
name|how
condition|)
name|sx_xlock
argument_list|(
name|sx
argument_list|)
expr_stmt|;
else|else
name|sx_slock
argument_list|(
name|sx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|unlock_sx
parameter_list|(
name|struct
name|lock_object
modifier|*
name|lock
parameter_list|)
block|{
name|struct
name|sx
modifier|*
name|sx
decl_stmt|;
name|sx
operator|=
operator|(
expr|struct
name|sx
operator|*
operator|)
name|lock
expr_stmt|;
name|sx_assert
argument_list|(
name|sx
argument_list|,
name|SX_LOCKED
operator||
name|SX_NOTRECURSED
argument_list|)
expr_stmt|;
if|if
condition|(
name|sx_xlocked
argument_list|(
name|sx
argument_list|)
condition|)
block|{
name|sx_xunlock
argument_list|(
name|sx
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
else|else
block|{
name|sx_sunlock
argument_list|(
name|sx
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
end_function

begin_function
name|void
name|sx_sysinit
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|sx_args
modifier|*
name|sargs
init|=
name|arg
decl_stmt|;
name|sx_init
argument_list|(
name|sargs
operator|->
name|sa_sx
argument_list|,
name|sargs
operator|->
name|sa_desc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|sx_init_flags
parameter_list|(
name|struct
name|sx
modifier|*
name|sx
parameter_list|,
specifier|const
name|char
modifier|*
name|description
parameter_list|,
name|int
name|opts
parameter_list|)
block|{
name|int
name|flags
decl_stmt|;
name|flags
operator|=
name|LO_RECURSABLE
operator||
name|LO_SLEEPABLE
operator||
name|LO_UPGRADABLE
expr_stmt|;
if|if
condition|(
name|opts
operator|&
name|SX_DUPOK
condition|)
name|flags
operator||=
name|LO_DUPOK
expr_stmt|;
if|if
condition|(
name|opts
operator|&
name|SX_NOPROFILE
condition|)
name|flags
operator||=
name|LO_NOPROFILE
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|opts
operator|&
name|SX_NOWITNESS
operator|)
condition|)
name|flags
operator||=
name|LO_WITNESS
expr_stmt|;
if|if
condition|(
name|opts
operator|&
name|SX_QUIET
condition|)
name|flags
operator||=
name|LO_QUIET
expr_stmt|;
name|flags
operator||=
name|opts
operator|&
name|SX_ADAPTIVESPIN
expr_stmt|;
name|sx
operator|->
name|sx_lock
operator|=
name|SX_LOCK_UNLOCKED
expr_stmt|;
name|sx
operator|->
name|sx_recurse
operator|=
literal|0
expr_stmt|;
name|lock_profile_object_init
argument_list|(
operator|&
name|sx
operator|->
name|lock_object
argument_list|,
operator|&
name|lock_class_sx
argument_list|,
name|description
argument_list|)
expr_stmt|;
name|lock_init
argument_list|(
operator|&
name|sx
operator|->
name|lock_object
argument_list|,
operator|&
name|lock_class_sx
argument_list|,
name|description
argument_list|,
name|NULL
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|sx_destroy
parameter_list|(
name|struct
name|sx
modifier|*
name|sx
parameter_list|)
block|{
name|KASSERT
argument_list|(
name|sx
operator|->
name|sx_lock
operator|==
name|SX_LOCK_UNLOCKED
argument_list|,
operator|(
literal|"sx lock still held"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|sx
operator|->
name|sx_recurse
operator|==
literal|0
argument_list|,
operator|(
literal|"sx lock still recursed"
operator|)
argument_list|)
expr_stmt|;
name|lock_profile_object_destroy
argument_list|(
operator|&
name|sx
operator|->
name|lock_object
argument_list|)
expr_stmt|;
name|lock_destroy
argument_list|(
operator|&
name|sx
operator|->
name|lock_object
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|_sx_slock
parameter_list|(
name|struct
name|sx
modifier|*
name|sx
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|)
block|{
name|MPASS
argument_list|(
name|curthread
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|WITNESS_CHECKORDER
argument_list|(
operator|&
name|sx
operator|->
name|lock_object
argument_list|,
name|LOP_NEWORDER
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|__sx_slock
argument_list|(
name|sx
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|LOCK_LOG_LOCK
argument_list|(
literal|"SLOCK"
argument_list|,
operator|&
name|sx
operator|->
name|lock_object
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|WITNESS_LOCK
argument_list|(
operator|&
name|sx
operator|->
name|lock_object
argument_list|,
literal|0
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|curthread
operator|->
name|td_locks
operator|++
expr_stmt|;
block|}
end_function

begin_function
name|int
name|_sx_try_slock
parameter_list|(
name|struct
name|sx
modifier|*
name|sx
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|)
block|{
name|uintptr_t
name|x
decl_stmt|;
name|x
operator|=
name|sx
operator|->
name|sx_lock
expr_stmt|;
if|if
condition|(
operator|(
name|x
operator|&
name|SX_LOCK_SHARED
operator|)
operator|&&
name|atomic_cmpset_acq_ptr
argument_list|(
operator|&
name|sx
operator|->
name|sx_lock
argument_list|,
name|x
argument_list|,
name|x
operator|+
name|SX_ONE_SHARER
argument_list|)
condition|)
block|{
name|LOCK_LOG_TRY
argument_list|(
literal|"SLOCK"
argument_list|,
operator|&
name|sx
operator|->
name|lock_object
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|WITNESS_LOCK
argument_list|(
operator|&
name|sx
operator|->
name|lock_object
argument_list|,
name|LOP_TRYLOCK
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|curthread
operator|->
name|td_locks
operator|++
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|LOCK_LOG_TRY
argument_list|(
literal|"SLOCK"
argument_list|,
operator|&
name|sx
operator|->
name|lock_object
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|_sx_xlock
parameter_list|(
name|struct
name|sx
modifier|*
name|sx
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|)
block|{
name|MPASS
argument_list|(
name|curthread
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|WITNESS_CHECKORDER
argument_list|(
operator|&
name|sx
operator|->
name|lock_object
argument_list|,
name|LOP_NEWORDER
operator||
name|LOP_EXCLUSIVE
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|__sx_xlock
argument_list|(
name|sx
argument_list|,
name|curthread
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|LOCK_LOG_LOCK
argument_list|(
literal|"XLOCK"
argument_list|,
operator|&
name|sx
operator|->
name|lock_object
argument_list|,
literal|0
argument_list|,
name|sx
operator|->
name|sx_recurse
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|WITNESS_LOCK
argument_list|(
operator|&
name|sx
operator|->
name|lock_object
argument_list|,
name|LOP_EXCLUSIVE
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|curthread
operator|->
name|td_locks
operator|++
expr_stmt|;
block|}
end_function

begin_function
name|int
name|_sx_try_xlock
parameter_list|(
name|struct
name|sx
modifier|*
name|sx
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|)
block|{
name|int
name|rval
decl_stmt|;
name|MPASS
argument_list|(
name|curthread
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|sx_xlocked
argument_list|(
name|sx
argument_list|)
condition|)
block|{
name|sx
operator|->
name|sx_recurse
operator|++
expr_stmt|;
name|atomic_set_ptr
argument_list|(
operator|&
name|sx
operator|->
name|sx_lock
argument_list|,
name|SX_LOCK_RECURSED
argument_list|)
expr_stmt|;
name|rval
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|rval
operator|=
name|atomic_cmpset_acq_ptr
argument_list|(
operator|&
name|sx
operator|->
name|sx_lock
argument_list|,
name|SX_LOCK_UNLOCKED
argument_list|,
operator|(
name|uintptr_t
operator|)
name|curthread
argument_list|)
expr_stmt|;
name|LOCK_LOG_TRY
argument_list|(
literal|"XLOCK"
argument_list|,
operator|&
name|sx
operator|->
name|lock_object
argument_list|,
literal|0
argument_list|,
name|rval
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|rval
condition|)
block|{
name|WITNESS_LOCK
argument_list|(
operator|&
name|sx
operator|->
name|lock_object
argument_list|,
name|LOP_EXCLUSIVE
operator||
name|LOP_TRYLOCK
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|curthread
operator|->
name|td_locks
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|rval
operator|)
return|;
block|}
end_function

begin_function
name|void
name|_sx_sunlock
parameter_list|(
name|struct
name|sx
modifier|*
name|sx
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|)
block|{
name|MPASS
argument_list|(
name|curthread
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|_sx_assert
argument_list|(
name|sx
argument_list|,
name|SX_SLOCKED
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|curthread
operator|->
name|td_locks
operator|--
expr_stmt|;
name|WITNESS_UNLOCK
argument_list|(
operator|&
name|sx
operator|->
name|lock_object
argument_list|,
literal|0
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|LOCK_LOG_LOCK
argument_list|(
literal|"SUNLOCK"
argument_list|,
operator|&
name|sx
operator|->
name|lock_object
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|lock_profile_release_lock
argument_list|(
operator|&
name|sx
operator|->
name|lock_object
argument_list|)
expr_stmt|;
name|__sx_sunlock
argument_list|(
name|sx
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|_sx_xunlock
parameter_list|(
name|struct
name|sx
modifier|*
name|sx
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|)
block|{
name|MPASS
argument_list|(
name|curthread
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|_sx_assert
argument_list|(
name|sx
argument_list|,
name|SX_XLOCKED
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|curthread
operator|->
name|td_locks
operator|--
expr_stmt|;
name|WITNESS_UNLOCK
argument_list|(
operator|&
name|sx
operator|->
name|lock_object
argument_list|,
name|LOP_EXCLUSIVE
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|LOCK_LOG_LOCK
argument_list|(
literal|"XUNLOCK"
argument_list|,
operator|&
name|sx
operator|->
name|lock_object
argument_list|,
literal|0
argument_list|,
name|sx
operator|->
name|sx_recurse
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|lock_profile_release_lock
argument_list|(
operator|&
name|sx
operator|->
name|lock_object
argument_list|)
expr_stmt|;
name|__sx_xunlock
argument_list|(
name|sx
argument_list|,
name|curthread
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Try to do a non-blocking upgrade from a shared lock to an exclusive lock.  * This will only succeed if this thread holds a single shared lock.  * Return 1 if if the upgrade succeed, 0 otherwise.  */
end_comment

begin_function
name|int
name|_sx_try_upgrade
parameter_list|(
name|struct
name|sx
modifier|*
name|sx
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|)
block|{
name|uintptr_t
name|x
decl_stmt|;
name|int
name|success
decl_stmt|;
name|_sx_assert
argument_list|(
name|sx
argument_list|,
name|SX_SLOCKED
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
comment|/* 	 * Try to switch from one shared lock to an exclusive lock.  We need 	 * to maintain the SX_LOCK_EXCLUSIVE_WAITERS flag if set so that 	 * we will wake up the exclusive waiters when we drop the lock. 	 */
name|x
operator|=
name|sx
operator|->
name|sx_lock
operator|&
name|SX_LOCK_EXCLUSIVE_WAITERS
expr_stmt|;
name|success
operator|=
name|atomic_cmpset_ptr
argument_list|(
operator|&
name|sx
operator|->
name|sx_lock
argument_list|,
name|SX_SHARERS_LOCK
argument_list|(
literal|1
argument_list|)
operator||
name|x
argument_list|,
operator|(
name|uintptr_t
operator|)
name|curthread
operator||
name|x
argument_list|)
expr_stmt|;
name|LOCK_LOG_TRY
argument_list|(
literal|"XUPGRADE"
argument_list|,
operator|&
name|sx
operator|->
name|lock_object
argument_list|,
literal|0
argument_list|,
name|success
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
name|WITNESS_UPGRADE
argument_list|(
operator|&
name|sx
operator|->
name|lock_object
argument_list|,
name|LOP_EXCLUSIVE
operator||
name|LOP_TRYLOCK
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
return|return
operator|(
name|success
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Downgrade an unrecursed exclusive lock into a single shared lock.  */
end_comment

begin_function
name|void
name|_sx_downgrade
parameter_list|(
name|struct
name|sx
modifier|*
name|sx
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|)
block|{
name|uintptr_t
name|x
decl_stmt|;
name|_sx_assert
argument_list|(
name|sx
argument_list|,
name|SX_XLOCKED
operator||
name|SX_NOTRECURSED
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|INVARIANTS
if|if
condition|(
name|sx_recursed
argument_list|(
name|sx
argument_list|)
condition|)
name|panic
argument_list|(
literal|"downgrade of a recursed lock"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|WITNESS_DOWNGRADE
argument_list|(
operator|&
name|sx
operator|->
name|lock_object
argument_list|,
literal|0
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
comment|/* 	 * Try to switch from an exclusive lock with no shared waiters 	 * to one sharer with no shared waiters.  If there are 	 * exclusive waiters, we don't need to lock the sleep queue so 	 * long as we preserve the flag.  We do one quick try and if 	 * that fails we grab the sleepq lock to keep the flags from 	 * changing and do it the slow way. 	 * 	 * We have to lock the sleep queue if there are shared waiters 	 * so we can wake them up. 	 */
name|x
operator|=
name|sx
operator|->
name|sx_lock
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|x
operator|&
name|SX_LOCK_SHARED_WAITERS
operator|)
operator|&&
name|atomic_cmpset_rel_ptr
argument_list|(
operator|&
name|sx
operator|->
name|sx_lock
argument_list|,
name|x
argument_list|,
name|SX_SHARERS_LOCK
argument_list|(
literal|1
argument_list|)
operator||
operator|(
name|x
operator|&
name|SX_LOCK_EXCLUSIVE_WAITERS
operator|)
argument_list|)
condition|)
block|{
name|LOCK_LOG_LOCK
argument_list|(
literal|"XDOWNGRADE"
argument_list|,
operator|&
name|sx
operator|->
name|lock_object
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Lock the sleep queue so we can read the waiters bits 	 * without any races and wakeup any shared waiters. 	 */
name|sleepq_lock
argument_list|(
operator|&
name|sx
operator|->
name|lock_object
argument_list|)
expr_stmt|;
comment|/* 	 * Preserve SX_LOCK_EXCLUSIVE_WAITERS while downgraded to a single 	 * shared lock.  If there are any shared waiters, wake them up. 	 */
name|x
operator|=
name|sx
operator|->
name|sx_lock
expr_stmt|;
name|atomic_store_rel_ptr
argument_list|(
operator|&
name|sx
operator|->
name|sx_lock
argument_list|,
name|SX_SHARERS_LOCK
argument_list|(
literal|1
argument_list|)
operator||
operator|(
name|x
operator|&
name|SX_LOCK_EXCLUSIVE_WAITERS
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|&
name|SX_LOCK_SHARED_WAITERS
condition|)
name|sleepq_broadcast
argument_list|(
operator|&
name|sx
operator|->
name|lock_object
argument_list|,
name|SLEEPQ_SX
argument_list|,
operator|-
literal|1
argument_list|,
name|SQ_SHARED_QUEUE
argument_list|)
expr_stmt|;
else|else
name|sleepq_release
argument_list|(
operator|&
name|sx
operator|->
name|lock_object
argument_list|)
expr_stmt|;
name|LOCK_LOG_LOCK
argument_list|(
literal|"XDOWNGRADE"
argument_list|,
operator|&
name|sx
operator|->
name|lock_object
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This function represents the so-called 'hard case' for sx_xlock  * operation.  All 'easy case' failures are redirected to this.  Note  * that ideally this would be a static function, but it needs to be  * accessible from at least sx.h.  */
end_comment

begin_function
name|void
name|_sx_xlock_hard
parameter_list|(
name|struct
name|sx
modifier|*
name|sx
parameter_list|,
name|uintptr_t
name|tid
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|)
block|{
name|GIANT_DECLARE
expr_stmt|;
ifdef|#
directive|ifdef
name|ADAPTIVE_SX
specifier|volatile
name|struct
name|thread
modifier|*
name|owner
decl_stmt|;
endif|#
directive|endif
name|uintptr_t
name|x
decl_stmt|;
comment|/* If we already hold an exclusive lock, then recurse. */
if|if
condition|(
name|sx_xlocked
argument_list|(
name|sx
argument_list|)
condition|)
block|{
name|sx
operator|->
name|sx_recurse
operator|++
expr_stmt|;
name|atomic_set_ptr
argument_list|(
operator|&
name|sx
operator|->
name|sx_lock
argument_list|,
name|SX_LOCK_RECURSED
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOCK_LOG_TEST
argument_list|(
operator|&
name|sx
operator|->
name|lock_object
argument_list|,
literal|0
argument_list|)
condition|)
name|CTR2
argument_list|(
name|KTR_LOCK
argument_list|,
literal|"%s: %p recursing"
argument_list|,
name|__func__
argument_list|,
name|sx
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|LOCK_LOG_TEST
argument_list|(
operator|&
name|sx
operator|->
name|lock_object
argument_list|,
literal|0
argument_list|)
condition|)
name|CTR5
argument_list|(
name|KTR_LOCK
argument_list|,
literal|"%s: %s contested (lock=%p) at %s:%d"
argument_list|,
name|__func__
argument_list|,
name|sx
operator|->
name|lock_object
operator|.
name|lo_name
argument_list|,
operator|(
name|void
operator|*
operator|)
name|sx
operator|->
name|sx_lock
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|atomic_cmpset_acq_ptr
argument_list|(
operator|&
name|sx
operator|->
name|sx_lock
argument_list|,
name|SX_LOCK_UNLOCKED
argument_list|,
name|tid
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|ADAPTIVE_SX
comment|/* 		 * If the lock is write locked and the owner is 		 * running on another CPU, spin until the owner stops 		 * running or the state of the lock changes. 		 */
name|x
operator|=
name|sx
operator|->
name|sx_lock
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|x
operator|&
name|SX_LOCK_SHARED
operator|)
operator|&&
operator|(
name|sx
operator|->
name|lock_object
operator|.
name|lo_flags
operator|&
name|SX_ADAPTIVESPIN
operator|)
condition|)
block|{
name|x
operator|=
name|SX_OWNER
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|owner
operator|=
operator|(
expr|struct
name|thread
operator|*
operator|)
name|x
expr_stmt|;
if|if
condition|(
name|TD_IS_RUNNING
argument_list|(
name|owner
argument_list|)
condition|)
block|{
if|if
condition|(
name|LOCK_LOG_TEST
argument_list|(
operator|&
name|sx
operator|->
name|lock_object
argument_list|,
literal|0
argument_list|)
condition|)
name|CTR3
argument_list|(
name|KTR_LOCK
argument_list|,
literal|"%s: spinning on %p held by %p"
argument_list|,
name|__func__
argument_list|,
name|sx
argument_list|,
name|owner
argument_list|)
expr_stmt|;
name|GIANT_SAVE
argument_list|()
expr_stmt|;
while|while
condition|(
name|SX_OWNER
argument_list|(
name|sx
operator|->
name|sx_lock
argument_list|)
operator|==
name|x
operator|&&
name|TD_IS_RUNNING
argument_list|(
name|owner
argument_list|)
condition|)
name|cpu_spinwait
argument_list|()
expr_stmt|;
continue|continue;
block|}
block|}
endif|#
directive|endif
name|sleepq_lock
argument_list|(
operator|&
name|sx
operator|->
name|lock_object
argument_list|)
expr_stmt|;
name|x
operator|=
name|sx
operator|->
name|sx_lock
expr_stmt|;
comment|/* 		 * If the lock was released while spinning on the 		 * sleep queue chain lock, try again. 		 */
if|if
condition|(
name|x
operator|==
name|SX_LOCK_UNLOCKED
condition|)
block|{
name|sleepq_release
argument_list|(
operator|&
name|sx
operator|->
name|lock_object
argument_list|)
expr_stmt|;
continue|continue;
block|}
ifdef|#
directive|ifdef
name|ADAPTIVE_SX
comment|/* 		 * The current lock owner might have started executing 		 * on another CPU (or the lock could have changed 		 * owners) while we were waiting on the sleep queue 		 * chain lock.  If so, drop the sleep queue lock and try 		 * again. 		 */
if|if
condition|(
operator|!
operator|(
name|x
operator|&
name|SX_LOCK_SHARED
operator|)
operator|&&
operator|(
name|sx
operator|->
name|lock_object
operator|.
name|lo_flags
operator|&
name|SX_ADAPTIVESPIN
operator|)
condition|)
block|{
name|owner
operator|=
operator|(
expr|struct
name|thread
operator|*
operator|)
name|SX_OWNER
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|TD_IS_RUNNING
argument_list|(
name|owner
argument_list|)
condition|)
block|{
name|sleepq_release
argument_list|(
operator|&
name|sx
operator|->
name|lock_object
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
endif|#
directive|endif
comment|/* 		 * If an exclusive lock was released with both shared 		 * and exclusive waiters and a shared waiter hasn't 		 * woken up and acquired the lock yet, sx_lock will be 		 * set to SX_LOCK_UNLOCKED | SX_LOCK_EXCLUSIVE_WAITERS. 		 * If we see that value, try to acquire it once.  Note 		 * that we have to preserve SX_LOCK_EXCLUSIVE_WAITERS 		 * as there are other exclusive waiters still.  If we 		 * fail, restart the loop. 		 */
if|if
condition|(
name|x
operator|==
operator|(
name|SX_LOCK_UNLOCKED
operator||
name|SX_LOCK_EXCLUSIVE_WAITERS
operator|)
condition|)
block|{
if|if
condition|(
name|atomic_cmpset_acq_ptr
argument_list|(
operator|&
name|sx
operator|->
name|sx_lock
argument_list|,
name|SX_LOCK_UNLOCKED
operator||
name|SX_LOCK_EXCLUSIVE_WAITERS
argument_list|,
name|tid
operator||
name|SX_LOCK_EXCLUSIVE_WAITERS
argument_list|)
condition|)
block|{
name|sleepq_release
argument_list|(
operator|&
name|sx
operator|->
name|lock_object
argument_list|)
expr_stmt|;
name|CTR2
argument_list|(
name|KTR_LOCK
argument_list|,
literal|"%s: %p claimed by new writer"
argument_list|,
name|__func__
argument_list|,
name|sx
argument_list|)
expr_stmt|;
break|break;
block|}
name|sleepq_release
argument_list|(
operator|&
name|sx
operator|->
name|lock_object
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * Try to set the SX_LOCK_EXCLUSIVE_WAITERS.  If we fail, 		 * than loop back and retry. 		 */
if|if
condition|(
operator|!
operator|(
name|x
operator|&
name|SX_LOCK_EXCLUSIVE_WAITERS
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|atomic_cmpset_ptr
argument_list|(
operator|&
name|sx
operator|->
name|sx_lock
argument_list|,
name|x
argument_list|,
name|x
operator||
name|SX_LOCK_EXCLUSIVE_WAITERS
argument_list|)
condition|)
block|{
name|sleepq_release
argument_list|(
operator|&
name|sx
operator|->
name|lock_object
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|LOCK_LOG_TEST
argument_list|(
operator|&
name|sx
operator|->
name|lock_object
argument_list|,
literal|0
argument_list|)
condition|)
name|CTR2
argument_list|(
name|KTR_LOCK
argument_list|,
literal|"%s: %p set excl waiters flag"
argument_list|,
name|__func__
argument_list|,
name|sx
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Since we have been unable to acquire the exclusive 		 * lock and the exclusive waiters flag is set, we have 		 * to sleep. 		 */
if|if
condition|(
name|LOCK_LOG_TEST
argument_list|(
operator|&
name|sx
operator|->
name|lock_object
argument_list|,
literal|0
argument_list|)
condition|)
name|CTR2
argument_list|(
name|KTR_LOCK
argument_list|,
literal|"%s: %p blocking on sleep queue"
argument_list|,
name|__func__
argument_list|,
name|sx
argument_list|)
expr_stmt|;
name|GIANT_SAVE
argument_list|()
expr_stmt|;
name|sleepq_add
argument_list|(
operator|&
name|sx
operator|->
name|lock_object
argument_list|,
name|NULL
argument_list|,
name|sx
operator|->
name|lock_object
operator|.
name|lo_name
argument_list|,
name|SLEEPQ_SX
argument_list|,
name|SQ_EXCLUSIVE_QUEUE
argument_list|)
expr_stmt|;
name|sleepq_wait
argument_list|(
operator|&
name|sx
operator|->
name|lock_object
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOCK_LOG_TEST
argument_list|(
operator|&
name|sx
operator|->
name|lock_object
argument_list|,
literal|0
argument_list|)
condition|)
name|CTR2
argument_list|(
name|KTR_LOCK
argument_list|,
literal|"%s: %p resuming from sleep queue"
argument_list|,
name|__func__
argument_list|,
name|sx
argument_list|)
expr_stmt|;
block|}
name|GIANT_RESTORE
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This function represents the so-called 'hard case' for sx_xunlock  * operation.  All 'easy case' failures are redirected to this.  Note  * that ideally this would be a static function, but it needs to be  * accessible from at least sx.h.  */
end_comment

begin_function
name|void
name|_sx_xunlock_hard
parameter_list|(
name|struct
name|sx
modifier|*
name|sx
parameter_list|,
name|uintptr_t
name|tid
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|)
block|{
name|uintptr_t
name|x
decl_stmt|;
name|int
name|queue
decl_stmt|;
name|MPASS
argument_list|(
operator|!
operator|(
name|sx
operator|->
name|sx_lock
operator|&
name|SX_LOCK_SHARED
operator|)
argument_list|)
expr_stmt|;
comment|/* If the lock is recursed, then unrecurse one level. */
if|if
condition|(
name|sx_xlocked
argument_list|(
name|sx
argument_list|)
operator|&&
name|sx_recursed
argument_list|(
name|sx
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
operator|--
name|sx
operator|->
name|sx_recurse
operator|)
operator|==
literal|0
condition|)
name|atomic_clear_ptr
argument_list|(
operator|&
name|sx
operator|->
name|sx_lock
argument_list|,
name|SX_LOCK_RECURSED
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOCK_LOG_TEST
argument_list|(
operator|&
name|sx
operator|->
name|lock_object
argument_list|,
literal|0
argument_list|)
condition|)
name|CTR2
argument_list|(
name|KTR_LOCK
argument_list|,
literal|"%s: %p unrecursing"
argument_list|,
name|__func__
argument_list|,
name|sx
argument_list|)
expr_stmt|;
return|return;
block|}
name|MPASS
argument_list|(
name|sx
operator|->
name|sx_lock
operator|&
operator|(
name|SX_LOCK_SHARED_WAITERS
operator||
name|SX_LOCK_EXCLUSIVE_WAITERS
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOCK_LOG_TEST
argument_list|(
operator|&
name|sx
operator|->
name|lock_object
argument_list|,
literal|0
argument_list|)
condition|)
name|CTR2
argument_list|(
name|KTR_LOCK
argument_list|,
literal|"%s: %p contested"
argument_list|,
name|__func__
argument_list|,
name|sx
argument_list|)
expr_stmt|;
name|sleepq_lock
argument_list|(
operator|&
name|sx
operator|->
name|lock_object
argument_list|)
expr_stmt|;
name|x
operator|=
name|SX_LOCK_UNLOCKED
expr_stmt|;
comment|/* 	 * The wake up algorithm here is quite simple and probably not 	 * ideal.  It gives precedence to shared waiters if they are 	 * present.  For this condition, we have to preserve the 	 * state of the exclusive waiters flag. 	 */
if|if
condition|(
name|sx
operator|->
name|sx_lock
operator|&
name|SX_LOCK_SHARED_WAITERS
condition|)
block|{
name|queue
operator|=
name|SQ_SHARED_QUEUE
expr_stmt|;
name|x
operator||=
operator|(
name|sx
operator|->
name|sx_lock
operator|&
name|SX_LOCK_EXCLUSIVE_WAITERS
operator|)
expr_stmt|;
block|}
else|else
name|queue
operator|=
name|SQ_EXCLUSIVE_QUEUE
expr_stmt|;
comment|/* Wake up all the waiters for the specific queue. */
if|if
condition|(
name|LOCK_LOG_TEST
argument_list|(
operator|&
name|sx
operator|->
name|lock_object
argument_list|,
literal|0
argument_list|)
condition|)
name|CTR3
argument_list|(
name|KTR_LOCK
argument_list|,
literal|"%s: %p waking up all threads on %s queue"
argument_list|,
name|__func__
argument_list|,
name|sx
argument_list|,
name|queue
operator|==
name|SQ_SHARED_QUEUE
condition|?
literal|"shared"
else|:
literal|"exclusive"
argument_list|)
expr_stmt|;
name|atomic_store_rel_ptr
argument_list|(
operator|&
name|sx
operator|->
name|sx_lock
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|sleepq_broadcast
argument_list|(
operator|&
name|sx
operator|->
name|lock_object
argument_list|,
name|SLEEPQ_SX
argument_list|,
operator|-
literal|1
argument_list|,
name|queue
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This function represents the so-called 'hard case' for sx_slock  * operation.  All 'easy case' failures are redirected to this.  Note  * that ideally this would be a static function, but it needs to be  * accessible from at least sx.h.  */
end_comment

begin_function
name|void
name|_sx_slock_hard
parameter_list|(
name|struct
name|sx
modifier|*
name|sx
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|)
block|{
name|GIANT_DECLARE
expr_stmt|;
ifdef|#
directive|ifdef
name|ADAPTIVE_SX
specifier|volatile
name|struct
name|thread
modifier|*
name|owner
decl_stmt|;
endif|#
directive|endif
name|uintptr_t
name|x
decl_stmt|;
comment|/* 	 * As with rwlocks, we don't make any attempt to try to block 	 * shared locks once there is an exclusive waiter. 	 */
for|for
control|(
init|;
condition|;
control|)
block|{
name|x
operator|=
name|sx
operator|->
name|sx_lock
expr_stmt|;
comment|/* 		 * If no other thread has an exclusive lock then try to bump up 		 * the count of sharers.  Since we have to preserve the state 		 * of SX_LOCK_EXCLUSIVE_WAITERS, if we fail to acquire the 		 * shared lock loop back and retry. 		 */
if|if
condition|(
name|x
operator|&
name|SX_LOCK_SHARED
condition|)
block|{
name|MPASS
argument_list|(
operator|!
operator|(
name|x
operator|&
name|SX_LOCK_SHARED_WAITERS
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|atomic_cmpset_acq_ptr
argument_list|(
operator|&
name|sx
operator|->
name|sx_lock
argument_list|,
name|x
argument_list|,
name|x
operator|+
name|SX_ONE_SHARER
argument_list|)
condition|)
block|{
if|if
condition|(
name|LOCK_LOG_TEST
argument_list|(
operator|&
name|sx
operator|->
name|lock_object
argument_list|,
literal|0
argument_list|)
condition|)
name|CTR4
argument_list|(
name|KTR_LOCK
argument_list|,
literal|"%s: %p succeed %p -> %p"
argument_list|,
name|__func__
argument_list|,
name|sx
argument_list|,
operator|(
name|void
operator|*
operator|)
name|x
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|x
operator|+
name|SX_ONE_SHARER
operator|)
argument_list|)
expr_stmt|;
break|break;
block|}
continue|continue;
block|}
ifdef|#
directive|ifdef
name|ADAPTIVE_SX
comment|/* 		 * If the owner is running on another CPU, spin until 		 * the owner stops running or the state of the lock 		 * changes. 		 */
elseif|else
if|if
condition|(
name|sx
operator|->
name|lock_object
operator|.
name|lo_flags
operator|&
name|SX_ADAPTIVESPIN
condition|)
block|{
name|x
operator|=
name|SX_OWNER
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|owner
operator|=
operator|(
expr|struct
name|thread
operator|*
operator|)
name|x
expr_stmt|;
if|if
condition|(
name|TD_IS_RUNNING
argument_list|(
name|owner
argument_list|)
condition|)
block|{
if|if
condition|(
name|LOCK_LOG_TEST
argument_list|(
operator|&
name|sx
operator|->
name|lock_object
argument_list|,
literal|0
argument_list|)
condition|)
name|CTR3
argument_list|(
name|KTR_LOCK
argument_list|,
literal|"%s: spinning on %p held by %p"
argument_list|,
name|__func__
argument_list|,
name|sx
argument_list|,
name|owner
argument_list|)
expr_stmt|;
name|GIANT_SAVE
argument_list|()
expr_stmt|;
while|while
condition|(
name|SX_OWNER
argument_list|(
name|sx
operator|->
name|sx_lock
argument_list|)
operator|==
name|x
operator|&&
name|TD_IS_RUNNING
argument_list|(
name|owner
argument_list|)
condition|)
name|cpu_spinwait
argument_list|()
expr_stmt|;
continue|continue;
block|}
block|}
endif|#
directive|endif
comment|/* 		 * Some other thread already has an exclusive lock, so 		 * start the process of blocking. 		 */
name|sleepq_lock
argument_list|(
operator|&
name|sx
operator|->
name|lock_object
argument_list|)
expr_stmt|;
name|x
operator|=
name|sx
operator|->
name|sx_lock
expr_stmt|;
comment|/* 		 * The lock could have been released while we spun. 		 * In this case loop back and retry. 		 */
if|if
condition|(
name|x
operator|&
name|SX_LOCK_SHARED
condition|)
block|{
name|sleepq_release
argument_list|(
operator|&
name|sx
operator|->
name|lock_object
argument_list|)
expr_stmt|;
continue|continue;
block|}
ifdef|#
directive|ifdef
name|ADAPTIVE_SX
comment|/* 		 * If the owner is running on another CPU, spin until 		 * the owner stops running or the state of the lock 		 * changes. 		 */
if|if
condition|(
operator|!
operator|(
name|x
operator|&
name|SX_LOCK_SHARED
operator|)
operator|&&
operator|(
name|sx
operator|->
name|lock_object
operator|.
name|lo_flags
operator|&
name|SX_ADAPTIVESPIN
operator|)
condition|)
block|{
name|owner
operator|=
operator|(
expr|struct
name|thread
operator|*
operator|)
name|SX_OWNER
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|TD_IS_RUNNING
argument_list|(
name|owner
argument_list|)
condition|)
block|{
name|sleepq_release
argument_list|(
operator|&
name|sx
operator|->
name|lock_object
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
endif|#
directive|endif
comment|/* 		 * Try to set the SX_LOCK_SHARED_WAITERS flag.  If we 		 * fail to set it drop the sleep queue lock and loop 		 * back. 		 */
if|if
condition|(
operator|!
operator|(
name|x
operator|&
name|SX_LOCK_SHARED_WAITERS
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|atomic_cmpset_ptr
argument_list|(
operator|&
name|sx
operator|->
name|sx_lock
argument_list|,
name|x
argument_list|,
name|x
operator||
name|SX_LOCK_SHARED_WAITERS
argument_list|)
condition|)
block|{
name|sleepq_release
argument_list|(
operator|&
name|sx
operator|->
name|lock_object
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|LOCK_LOG_TEST
argument_list|(
operator|&
name|sx
operator|->
name|lock_object
argument_list|,
literal|0
argument_list|)
condition|)
name|CTR2
argument_list|(
name|KTR_LOCK
argument_list|,
literal|"%s: %p set shared waiters flag"
argument_list|,
name|__func__
argument_list|,
name|sx
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Since we have been unable to acquire the shared lock, 		 * we have to sleep. 		 */
if|if
condition|(
name|LOCK_LOG_TEST
argument_list|(
operator|&
name|sx
operator|->
name|lock_object
argument_list|,
literal|0
argument_list|)
condition|)
name|CTR2
argument_list|(
name|KTR_LOCK
argument_list|,
literal|"%s: %p blocking on sleep queue"
argument_list|,
name|__func__
argument_list|,
name|sx
argument_list|)
expr_stmt|;
name|GIANT_SAVE
argument_list|()
expr_stmt|;
name|sleepq_add
argument_list|(
operator|&
name|sx
operator|->
name|lock_object
argument_list|,
name|NULL
argument_list|,
name|sx
operator|->
name|lock_object
operator|.
name|lo_name
argument_list|,
name|SLEEPQ_SX
argument_list|,
name|SQ_SHARED_QUEUE
argument_list|)
expr_stmt|;
name|sleepq_wait
argument_list|(
operator|&
name|sx
operator|->
name|lock_object
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOCK_LOG_TEST
argument_list|(
operator|&
name|sx
operator|->
name|lock_object
argument_list|,
literal|0
argument_list|)
condition|)
name|CTR2
argument_list|(
name|KTR_LOCK
argument_list|,
literal|"%s: %p resuming from sleep queue"
argument_list|,
name|__func__
argument_list|,
name|sx
argument_list|)
expr_stmt|;
block|}
name|GIANT_RESTORE
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This function represents the so-called 'hard case' for sx_sunlock  * operation.  All 'easy case' failures are redirected to this.  Note  * that ideally this would be a static function, but it needs to be  * accessible from at least sx.h.  */
end_comment

begin_function
name|void
name|_sx_sunlock_hard
parameter_list|(
name|struct
name|sx
modifier|*
name|sx
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|)
block|{
name|uintptr_t
name|x
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|x
operator|=
name|sx
operator|->
name|sx_lock
expr_stmt|;
comment|/* 		 * We should never have sharers while at least one thread 		 * holds a shared lock. 		 */
name|KASSERT
argument_list|(
operator|!
operator|(
name|x
operator|&
name|SX_LOCK_SHARED_WAITERS
operator|)
argument_list|,
operator|(
literal|"%s: waiting sharers"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
comment|/* 		 * See if there is more than one shared lock held.  If 		 * so, just drop one and return. 		 */
if|if
condition|(
name|SX_SHARERS
argument_list|(
name|x
argument_list|)
operator|>
literal|1
condition|)
block|{
if|if
condition|(
name|atomic_cmpset_ptr
argument_list|(
operator|&
name|sx
operator|->
name|sx_lock
argument_list|,
name|x
argument_list|,
name|x
operator|-
name|SX_ONE_SHARER
argument_list|)
condition|)
block|{
if|if
condition|(
name|LOCK_LOG_TEST
argument_list|(
operator|&
name|sx
operator|->
name|lock_object
argument_list|,
literal|0
argument_list|)
condition|)
name|CTR4
argument_list|(
name|KTR_LOCK
argument_list|,
literal|"%s: %p succeeded %p -> %p"
argument_list|,
name|__func__
argument_list|,
name|sx
argument_list|,
operator|(
name|void
operator|*
operator|)
name|x
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|x
operator|-
name|SX_ONE_SHARER
operator|)
argument_list|)
expr_stmt|;
break|break;
block|}
continue|continue;
block|}
comment|/* 		 * If there aren't any waiters for an exclusive lock, 		 * then try to drop it quickly. 		 */
if|if
condition|(
operator|!
operator|(
name|x
operator|&
name|SX_LOCK_EXCLUSIVE_WAITERS
operator|)
condition|)
block|{
name|MPASS
argument_list|(
name|x
operator|==
name|SX_SHARERS_LOCK
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|atomic_cmpset_ptr
argument_list|(
operator|&
name|sx
operator|->
name|sx_lock
argument_list|,
name|SX_SHARERS_LOCK
argument_list|(
literal|1
argument_list|)
argument_list|,
name|SX_LOCK_UNLOCKED
argument_list|)
condition|)
block|{
if|if
condition|(
name|LOCK_LOG_TEST
argument_list|(
operator|&
name|sx
operator|->
name|lock_object
argument_list|,
literal|0
argument_list|)
condition|)
name|CTR2
argument_list|(
name|KTR_LOCK
argument_list|,
literal|"%s: %p last succeeded"
argument_list|,
name|__func__
argument_list|,
name|sx
argument_list|)
expr_stmt|;
break|break;
block|}
continue|continue;
block|}
comment|/* 		 * At this point, there should just be one sharer with 		 * exclusive waiters. 		 */
name|MPASS
argument_list|(
name|x
operator|==
operator|(
name|SX_SHARERS_LOCK
argument_list|(
literal|1
argument_list|)
operator||
name|SX_LOCK_EXCLUSIVE_WAITERS
operator|)
argument_list|)
expr_stmt|;
name|sleepq_lock
argument_list|(
operator|&
name|sx
operator|->
name|lock_object
argument_list|)
expr_stmt|;
comment|/* 		 * Wake up semantic here is quite simple: 		 * Just wake up all the exclusive waiters. 		 * Note that the state of the lock could have changed, 		 * so if it fails loop back and retry. 		 */
if|if
condition|(
operator|!
name|atomic_cmpset_ptr
argument_list|(
operator|&
name|sx
operator|->
name|sx_lock
argument_list|,
name|SX_SHARERS_LOCK
argument_list|(
literal|1
argument_list|)
operator||
name|SX_LOCK_EXCLUSIVE_WAITERS
argument_list|,
name|SX_LOCK_UNLOCKED
argument_list|)
condition|)
block|{
name|sleepq_release
argument_list|(
operator|&
name|sx
operator|->
name|lock_object
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|LOCK_LOG_TEST
argument_list|(
operator|&
name|sx
operator|->
name|lock_object
argument_list|,
literal|0
argument_list|)
condition|)
name|CTR2
argument_list|(
name|KTR_LOCK
argument_list|,
literal|"%s: %p waking up all thread on"
literal|"exclusive queue"
argument_list|,
name|__func__
argument_list|,
name|sx
argument_list|)
expr_stmt|;
name|sleepq_broadcast
argument_list|(
operator|&
name|sx
operator|->
name|lock_object
argument_list|,
name|SLEEPQ_SX
argument_list|,
operator|-
literal|1
argument_list|,
name|SQ_EXCLUSIVE_QUEUE
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|INVARIANT_SUPPORT
end_ifdef

begin_ifndef
ifndef|#
directive|ifndef
name|INVARIANTS
end_ifndef

begin_undef
undef|#
directive|undef
name|_sx_assert
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * In the non-WITNESS case, sx_assert() can only detect that at least  * *some* thread owns an slock, but it cannot guarantee that *this*  * thread owns an slock.  */
end_comment

begin_function
name|void
name|_sx_assert
parameter_list|(
name|struct
name|sx
modifier|*
name|sx
parameter_list|,
name|int
name|what
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|WITNESS
name|int
name|slocked
init|=
literal|0
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|panicstr
operator|!=
name|NULL
condition|)
return|return;
switch|switch
condition|(
name|what
condition|)
block|{
case|case
name|SX_SLOCKED
case|:
case|case
name|SX_SLOCKED
operator||
name|SX_NOTRECURSED
case|:
case|case
name|SX_SLOCKED
operator||
name|SX_RECURSED
case|:
ifndef|#
directive|ifndef
name|WITNESS
name|slocked
operator|=
literal|1
expr_stmt|;
comment|/* FALLTHROUGH */
endif|#
directive|endif
case|case
name|SX_LOCKED
case|:
case|case
name|SX_LOCKED
operator||
name|SX_NOTRECURSED
case|:
case|case
name|SX_LOCKED
operator||
name|SX_RECURSED
case|:
ifdef|#
directive|ifdef
name|WITNESS
name|witness_assert
argument_list|(
operator|&
name|sx
operator|->
name|lock_object
argument_list|,
name|what
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* 		 * If some other thread has an exclusive lock or we 		 * have one and are asserting a shared lock, fail. 		 * Also, if no one has a lock at all, fail. 		 */
if|if
condition|(
name|sx
operator|->
name|sx_lock
operator|==
name|SX_LOCK_UNLOCKED
operator|||
operator|(
operator|!
operator|(
name|sx
operator|->
name|sx_lock
operator|&
name|SX_LOCK_SHARED
operator|)
operator|&&
operator|(
name|slocked
operator|||
name|sx_xholder
argument_list|(
name|sx
argument_list|)
operator|!=
name|curthread
operator|)
operator|)
condition|)
name|panic
argument_list|(
literal|"Lock %s not %slocked @ %s:%d\n"
argument_list|,
name|sx
operator|->
name|lock_object
operator|.
name|lo_name
argument_list|,
name|slocked
condition|?
literal|"share "
else|:
literal|""
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|sx
operator|->
name|sx_lock
operator|&
name|SX_LOCK_SHARED
operator|)
condition|)
block|{
if|if
condition|(
name|sx_recursed
argument_list|(
name|sx
argument_list|)
condition|)
block|{
if|if
condition|(
name|what
operator|&
name|SX_NOTRECURSED
condition|)
name|panic
argument_list|(
literal|"Lock %s recursed @ %s:%d\n"
argument_list|,
name|sx
operator|->
name|lock_object
operator|.
name|lo_name
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|what
operator|&
name|SX_RECURSED
condition|)
name|panic
argument_list|(
literal|"Lock %s not recursed @ %s:%d\n"
argument_list|,
name|sx
operator|->
name|lock_object
operator|.
name|lo_name
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
break|break;
case|case
name|SX_XLOCKED
case|:
case|case
name|SX_XLOCKED
operator||
name|SX_NOTRECURSED
case|:
case|case
name|SX_XLOCKED
operator||
name|SX_RECURSED
case|:
if|if
condition|(
name|sx_xholder
argument_list|(
name|sx
argument_list|)
operator|!=
name|curthread
condition|)
name|panic
argument_list|(
literal|"Lock %s not exclusively locked @ %s:%d\n"
argument_list|,
name|sx
operator|->
name|lock_object
operator|.
name|lo_name
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|sx_recursed
argument_list|(
name|sx
argument_list|)
condition|)
block|{
if|if
condition|(
name|what
operator|&
name|SX_NOTRECURSED
condition|)
name|panic
argument_list|(
literal|"Lock %s recursed @ %s:%d\n"
argument_list|,
name|sx
operator|->
name|lock_object
operator|.
name|lo_name
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|what
operator|&
name|SX_RECURSED
condition|)
name|panic
argument_list|(
literal|"Lock %s not recursed @ %s:%d\n"
argument_list|,
name|sx
operator|->
name|lock_object
operator|.
name|lo_name
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
break|break;
case|case
name|SX_UNLOCKED
case|:
ifdef|#
directive|ifdef
name|WITNESS
name|witness_assert
argument_list|(
operator|&
name|sx
operator|->
name|lock_object
argument_list|,
name|what
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* 		 * If we hold an exclusve lock fail.  We can't 		 * reliably check to see if we hold a shared lock or 		 * not. 		 */
if|if
condition|(
name|sx_xholder
argument_list|(
name|sx
argument_list|)
operator|==
name|curthread
condition|)
name|panic
argument_list|(
literal|"Lock %s exclusively locked @ %s:%d\n"
argument_list|,
name|sx
operator|->
name|lock_object
operator|.
name|lo_name
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
default|default:
name|panic
argument_list|(
literal|"Unknown sx lock assertion: %d @ %s:%d"
argument_list|,
name|what
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* INVARIANT_SUPPORT */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|DDB
end_ifdef

begin_function
specifier|static
name|void
name|db_show_sx
parameter_list|(
name|struct
name|lock_object
modifier|*
name|lock
parameter_list|)
block|{
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|sx
modifier|*
name|sx
decl_stmt|;
name|sx
operator|=
operator|(
expr|struct
name|sx
operator|*
operator|)
name|lock
expr_stmt|;
name|db_printf
argument_list|(
literal|" state: "
argument_list|)
expr_stmt|;
if|if
condition|(
name|sx
operator|->
name|sx_lock
operator|==
name|SX_LOCK_UNLOCKED
condition|)
name|db_printf
argument_list|(
literal|"UNLOCKED\n"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|sx
operator|->
name|sx_lock
operator|&
name|SX_LOCK_SHARED
condition|)
name|db_printf
argument_list|(
literal|"SLOCK: %ju\n"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|SX_SHARERS
argument_list|(
name|sx
operator|->
name|sx_lock
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|td
operator|=
name|sx_xholder
argument_list|(
name|sx
argument_list|)
expr_stmt|;
name|db_printf
argument_list|(
literal|"XLOCK: %p (tid %d, pid %d, \"%s\")\n"
argument_list|,
name|td
argument_list|,
name|td
operator|->
name|td_tid
argument_list|,
name|td
operator|->
name|td_proc
operator|->
name|p_pid
argument_list|,
name|td
operator|->
name|td_proc
operator|->
name|p_comm
argument_list|)
expr_stmt|;
if|if
condition|(
name|sx_recursed
argument_list|(
name|sx
argument_list|)
condition|)
name|db_printf
argument_list|(
literal|" recursed: %d\n"
argument_list|,
name|sx
operator|->
name|sx_recurse
argument_list|)
expr_stmt|;
block|}
name|db_printf
argument_list|(
literal|" waiters: "
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|sx
operator|->
name|sx_lock
operator|&
operator|(
name|SX_LOCK_SHARED_WAITERS
operator||
name|SX_LOCK_EXCLUSIVE_WAITERS
operator|)
condition|)
block|{
case|case
name|SX_LOCK_SHARED_WAITERS
case|:
name|db_printf
argument_list|(
literal|"shared\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|SX_LOCK_EXCLUSIVE_WAITERS
case|:
name|db_printf
argument_list|(
literal|"exclusive\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|SX_LOCK_SHARED_WAITERS
operator||
name|SX_LOCK_EXCLUSIVE_WAITERS
case|:
name|db_printf
argument_list|(
literal|"exclusive and shared\n"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|db_printf
argument_list|(
literal|"none\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Check to see if a thread that is blocked on a sleep queue is actually  * blocked on an sx lock.  If so, output some details and return true.  * If the lock has an exclusive owner, return that in *ownerp.  */
end_comment

begin_function
name|int
name|sx_chain
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|thread
modifier|*
modifier|*
name|ownerp
parameter_list|)
block|{
name|struct
name|sx
modifier|*
name|sx
decl_stmt|;
comment|/* 	 * Check to see if this thread is blocked on an sx lock. 	 * First, we check the lock class.  If that is ok, then we 	 * compare the lock name against the wait message. 	 */
name|sx
operator|=
name|td
operator|->
name|td_wchan
expr_stmt|;
if|if
condition|(
name|LOCK_CLASS
argument_list|(
operator|&
name|sx
operator|->
name|lock_object
argument_list|)
operator|!=
operator|&
name|lock_class_sx
operator|||
name|sx
operator|->
name|lock_object
operator|.
name|lo_name
operator|!=
name|td
operator|->
name|td_wmesg
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* We think we have an sx lock, so output some details. */
name|db_printf
argument_list|(
literal|"blocked on sx \"%s\" "
argument_list|,
name|td
operator|->
name|td_wmesg
argument_list|)
expr_stmt|;
operator|*
name|ownerp
operator|=
name|sx_xholder
argument_list|(
name|sx
argument_list|)
expr_stmt|;
if|if
condition|(
name|sx
operator|->
name|sx_lock
operator|&
name|SX_LOCK_SHARED
condition|)
name|db_printf
argument_list|(
literal|"SLOCK (count %ju)\n"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|SX_SHARERS
argument_list|(
name|sx
operator|->
name|sx_lock
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|db_printf
argument_list|(
literal|"XLOCK\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

