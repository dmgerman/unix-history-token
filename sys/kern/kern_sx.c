begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2007 Attilio Rao<attilio@freebsd.org>  * Copyright (c) 2001 Jason Evans<jasone@freebsd.org>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice(s), this list of conditions and the following disclaimer as  *    the first lines of this file unmodified other than the possible  *    addition of one or more copyright notices.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice(s), this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER(S) ``AS IS'' AND ANY  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE  * DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT HOLDER(S) BE LIABLE FOR ANY  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER  * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH  * DAMAGE.  */
end_comment

begin_comment
comment|/*  * Shared/exclusive locks.  This implementation attempts to ensure  * deterministic lock granting behavior, so that slocks and xlocks are  * interleaved.  *  * Priority propagation will not generally raise the priority of lock holders,  * so should not be relied upon in combination with sx locks.  */
end_comment

begin_include
include|#
directive|include
file|"opt_ddb.h"
end_include

begin_include
include|#
directive|include
file|"opt_hwpmc_hooks.h"
end_include

begin_include
include|#
directive|include
file|"opt_no_adaptive_sx.h"
end_include

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kdb.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/ktr.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/sched.h>
end_include

begin_include
include|#
directive|include
file|<sys/sleepqueue.h>
end_include

begin_include
include|#
directive|include
file|<sys/sx.h>
end_include

begin_include
include|#
directive|include
file|<sys/smp.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|SMP
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|NO_ADAPTIVE_SX
argument_list|)
end_if

begin_include
include|#
directive|include
file|<machine/cpu.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|DDB
end_ifdef

begin_include
include|#
directive|include
file|<ddb/ddb.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|SMP
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|NO_ADAPTIVE_SX
argument_list|)
end_if

begin_define
define|#
directive|define
name|ADAPTIVE_SX
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_expr_stmt
name|CTASSERT
argument_list|(
operator|(
name|SX_NOADAPTIVE
operator|&
name|LO_CLASSFLAGS
operator|)
operator|==
name|SX_NOADAPTIVE
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|HWPMC_HOOKS
end_ifdef

begin_include
include|#
directive|include
file|<sys/pmckern.h>
end_include

begin_expr_stmt
name|PMC_SOFT_DECLARE
argument_list|( , ,
name|lock
argument_list|,
name|failed
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Handy macros for sleep queues. */
end_comment

begin_define
define|#
directive|define
name|SQ_EXCLUSIVE_QUEUE
value|0
end_define

begin_define
define|#
directive|define
name|SQ_SHARED_QUEUE
value|1
end_define

begin_comment
comment|/*  * Variations on DROP_GIANT()/PICKUP_GIANT() for use in this file.  We  * drop Giant anytime we have to sleep or if we adaptively spin.  */
end_comment

begin_define
define|#
directive|define
name|GIANT_DECLARE
define|\
value|int _giantcnt = 0;						\ 	WITNESS_SAVE_DECL(Giant)					\  #define	GIANT_SAVE(work) do {						\ 	if (mtx_owned(&Giant)) {					\ 		work++;							\ 		WITNESS_SAVE(&Giant.lock_object, Giant);		\ 		while (mtx_owned(&Giant)) {				\ 			_giantcnt++;					\ 			mtx_unlock(&Giant);				\ 		}							\ 	}								\ } while (0)
end_define

begin_define
define|#
directive|define
name|GIANT_RESTORE
parameter_list|()
value|do {						\ 	if (_giantcnt> 0) {						\ 		mtx_assert(&Giant, MA_NOTOWNED);			\ 		while (_giantcnt--)					\ 			mtx_lock(&Giant);				\ 		WITNESS_RESTORE(&Giant.lock_object, Giant);		\ 	}								\ } while (0)
end_define

begin_comment
comment|/*  * Returns true if an exclusive lock is recursed.  It assumes  * curthread currently has an exclusive lock.  */
end_comment

begin_define
define|#
directive|define
name|sx_recursed
parameter_list|(
name|sx
parameter_list|)
value|((sx)->sx_recurse != 0)
end_define

begin_function_decl
specifier|static
name|void
name|assert_sx
parameter_list|(
specifier|const
name|struct
name|lock_object
modifier|*
name|lock
parameter_list|,
name|int
name|what
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|DDB
end_ifdef

begin_function_decl
specifier|static
name|void
name|db_show_sx
parameter_list|(
specifier|const
name|struct
name|lock_object
modifier|*
name|lock
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|lock_sx
parameter_list|(
name|struct
name|lock_object
modifier|*
name|lock
parameter_list|,
name|uintptr_t
name|how
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|KDTRACE_HOOKS
end_ifdef

begin_function_decl
specifier|static
name|int
name|owner_sx
parameter_list|(
specifier|const
name|struct
name|lock_object
modifier|*
name|lock
parameter_list|,
name|struct
name|thread
modifier|*
modifier|*
name|owner
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|uintptr_t
name|unlock_sx
parameter_list|(
name|struct
name|lock_object
modifier|*
name|lock
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|struct
name|lock_class
name|lock_class_sx
init|=
block|{
operator|.
name|lc_name
operator|=
literal|"sx"
block|,
operator|.
name|lc_flags
operator|=
name|LC_SLEEPLOCK
operator||
name|LC_SLEEPABLE
operator||
name|LC_RECURSABLE
operator||
name|LC_UPGRADABLE
block|,
operator|.
name|lc_assert
operator|=
name|assert_sx
block|,
ifdef|#
directive|ifdef
name|DDB
operator|.
name|lc_ddb_show
operator|=
name|db_show_sx
block|,
endif|#
directive|endif
operator|.
name|lc_lock
operator|=
name|lock_sx
block|,
operator|.
name|lc_unlock
operator|=
name|unlock_sx
block|,
ifdef|#
directive|ifdef
name|KDTRACE_HOOKS
operator|.
name|lc_owner
operator|=
name|owner_sx
block|,
endif|#
directive|endif
block|}
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|INVARIANTS
end_ifndef

begin_define
define|#
directive|define
name|_sx_assert
parameter_list|(
name|sx
parameter_list|,
name|what
parameter_list|,
name|file
parameter_list|,
name|line
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|ADAPTIVE_SX
end_ifdef

begin_decl_stmt
specifier|static
name|__read_frequently
name|u_int
name|asx_retries
init|=
literal|10
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|__read_frequently
name|u_int
name|asx_loops
init|=
literal|10000
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|static
name|SYSCTL_NODE
argument_list|(
name|_debug
argument_list|,
name|OID_AUTO
argument_list|,
name|sx
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|NULL
argument_list|,
literal|"sxlock debugging"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_debug_sx
argument_list|,
name|OID_AUTO
argument_list|,
name|retries
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|asx_retries
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_debug_sx
argument_list|,
name|OID_AUTO
argument_list|,
name|loops
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|asx_loops
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|struct
name|lock_delay_config
name|__read_frequently
name|sx_delay
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_debug_sx
argument_list|,
name|OID_AUTO
argument_list|,
name|delay_base
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|sx_delay
operator|.
name|base
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_debug_sx
argument_list|,
name|OID_AUTO
argument_list|,
name|delay_max
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|sx_delay
operator|.
name|max
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|LOCK_DELAY_SYSINIT_DEFAULT
argument_list|(
name|sx_delay
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|assert_sx
parameter_list|(
specifier|const
name|struct
name|lock_object
modifier|*
name|lock
parameter_list|,
name|int
name|what
parameter_list|)
block|{
name|sx_assert
argument_list|(
operator|(
specifier|const
expr|struct
name|sx
operator|*
operator|)
name|lock
argument_list|,
name|what
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|lock_sx
parameter_list|(
name|struct
name|lock_object
modifier|*
name|lock
parameter_list|,
name|uintptr_t
name|how
parameter_list|)
block|{
name|struct
name|sx
modifier|*
name|sx
decl_stmt|;
name|sx
operator|=
operator|(
expr|struct
name|sx
operator|*
operator|)
name|lock
expr_stmt|;
if|if
condition|(
name|how
condition|)
name|sx_slock
argument_list|(
name|sx
argument_list|)
expr_stmt|;
else|else
name|sx_xlock
argument_list|(
name|sx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|uintptr_t
name|unlock_sx
parameter_list|(
name|struct
name|lock_object
modifier|*
name|lock
parameter_list|)
block|{
name|struct
name|sx
modifier|*
name|sx
decl_stmt|;
name|sx
operator|=
operator|(
expr|struct
name|sx
operator|*
operator|)
name|lock
expr_stmt|;
name|sx_assert
argument_list|(
name|sx
argument_list|,
name|SA_LOCKED
operator||
name|SA_NOTRECURSED
argument_list|)
expr_stmt|;
if|if
condition|(
name|sx_xlocked
argument_list|(
name|sx
argument_list|)
condition|)
block|{
name|sx_xunlock
argument_list|(
name|sx
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
block|{
name|sx_sunlock
argument_list|(
name|sx
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|KDTRACE_HOOKS
end_ifdef

begin_function
name|int
name|owner_sx
parameter_list|(
specifier|const
name|struct
name|lock_object
modifier|*
name|lock
parameter_list|,
name|struct
name|thread
modifier|*
modifier|*
name|owner
parameter_list|)
block|{
specifier|const
name|struct
name|sx
modifier|*
name|sx
decl_stmt|;
name|uintptr_t
name|x
decl_stmt|;
name|sx
operator|=
operator|(
specifier|const
expr|struct
name|sx
operator|*
operator|)
name|lock
expr_stmt|;
name|x
operator|=
name|sx
operator|->
name|sx_lock
expr_stmt|;
operator|*
name|owner
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
operator|(
name|x
operator|&
name|SX_LOCK_SHARED
operator|)
operator|!=
literal|0
condition|?
operator|(
name|SX_SHARERS
argument_list|(
name|x
argument_list|)
operator|!=
literal|0
operator|)
else|:
operator|(
operator|(
operator|*
name|owner
operator|=
operator|(
expr|struct
name|thread
operator|*
operator|)
name|SX_OWNER
argument_list|(
name|x
argument_list|)
operator|)
operator|!=
name|NULL
operator|)
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|sx_sysinit
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|sx_args
modifier|*
name|sargs
init|=
name|arg
decl_stmt|;
name|sx_init_flags
argument_list|(
name|sargs
operator|->
name|sa_sx
argument_list|,
name|sargs
operator|->
name|sa_desc
argument_list|,
name|sargs
operator|->
name|sa_flags
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|sx_init_flags
parameter_list|(
name|struct
name|sx
modifier|*
name|sx
parameter_list|,
specifier|const
name|char
modifier|*
name|description
parameter_list|,
name|int
name|opts
parameter_list|)
block|{
name|int
name|flags
decl_stmt|;
name|MPASS
argument_list|(
operator|(
name|opts
operator|&
operator|~
operator|(
name|SX_QUIET
operator||
name|SX_RECURSE
operator||
name|SX_NOWITNESS
operator||
name|SX_DUPOK
operator||
name|SX_NOPROFILE
operator||
name|SX_NOADAPTIVE
operator||
name|SX_NEW
operator|)
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ASSERT_ATOMIC_LOAD_PTR
argument_list|(
name|sx
operator|->
name|sx_lock
argument_list|,
operator|(
literal|"%s: sx_lock not aligned for %s: %p"
operator|,
name|__func__
operator|,
name|description
operator|,
operator|&
name|sx
operator|->
name|sx_lock
operator|)
argument_list|)
expr_stmt|;
name|flags
operator|=
name|LO_SLEEPABLE
operator||
name|LO_UPGRADABLE
expr_stmt|;
if|if
condition|(
name|opts
operator|&
name|SX_DUPOK
condition|)
name|flags
operator||=
name|LO_DUPOK
expr_stmt|;
if|if
condition|(
name|opts
operator|&
name|SX_NOPROFILE
condition|)
name|flags
operator||=
name|LO_NOPROFILE
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|opts
operator|&
name|SX_NOWITNESS
operator|)
condition|)
name|flags
operator||=
name|LO_WITNESS
expr_stmt|;
if|if
condition|(
name|opts
operator|&
name|SX_RECURSE
condition|)
name|flags
operator||=
name|LO_RECURSABLE
expr_stmt|;
if|if
condition|(
name|opts
operator|&
name|SX_QUIET
condition|)
name|flags
operator||=
name|LO_QUIET
expr_stmt|;
if|if
condition|(
name|opts
operator|&
name|SX_NEW
condition|)
name|flags
operator||=
name|LO_NEW
expr_stmt|;
name|flags
operator||=
name|opts
operator|&
name|SX_NOADAPTIVE
expr_stmt|;
name|lock_init
argument_list|(
operator|&
name|sx
operator|->
name|lock_object
argument_list|,
operator|&
name|lock_class_sx
argument_list|,
name|description
argument_list|,
name|NULL
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|sx
operator|->
name|sx_lock
operator|=
name|SX_LOCK_UNLOCKED
expr_stmt|;
name|sx
operator|->
name|sx_recurse
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|void
name|sx_destroy
parameter_list|(
name|struct
name|sx
modifier|*
name|sx
parameter_list|)
block|{
name|KASSERT
argument_list|(
name|sx
operator|->
name|sx_lock
operator|==
name|SX_LOCK_UNLOCKED
argument_list|,
operator|(
literal|"sx lock still held"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|sx
operator|->
name|sx_recurse
operator|==
literal|0
argument_list|,
operator|(
literal|"sx lock still recursed"
operator|)
argument_list|)
expr_stmt|;
name|sx
operator|->
name|sx_lock
operator|=
name|SX_LOCK_DESTROYED
expr_stmt|;
name|lock_destroy
argument_list|(
operator|&
name|sx
operator|->
name|lock_object
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|sx_try_slock_int
parameter_list|(
name|struct
name|sx
modifier|*
name|sx
name|LOCK_FILE_LINE_ARG_DEF
parameter_list|)
block|{
name|uintptr_t
name|x
decl_stmt|;
if|if
condition|(
name|SCHEDULER_STOPPED
argument_list|()
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|KASSERT
argument_list|(
name|kdb_active
operator|!=
literal|0
operator|||
operator|!
name|TD_IS_IDLETHREAD
argument_list|(
name|curthread
argument_list|)
argument_list|,
operator|(
literal|"sx_try_slock() by idle thread %p on sx %s @ %s:%d"
operator|,
name|curthread
operator|,
name|sx
operator|->
name|lock_object
operator|.
name|lo_name
operator|,
name|file
operator|,
name|line
operator|)
argument_list|)
expr_stmt|;
name|x
operator|=
name|sx
operator|->
name|sx_lock
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|KASSERT
argument_list|(
name|x
operator|!=
name|SX_LOCK_DESTROYED
argument_list|,
operator|(
literal|"sx_try_slock() of destroyed sx @ %s:%d"
operator|,
name|file
operator|,
name|line
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|x
operator|&
name|SX_LOCK_SHARED
operator|)
condition|)
break|break;
if|if
condition|(
name|atomic_fcmpset_acq_ptr
argument_list|(
operator|&
name|sx
operator|->
name|sx_lock
argument_list|,
operator|&
name|x
argument_list|,
name|x
operator|+
name|SX_ONE_SHARER
argument_list|)
condition|)
block|{
name|LOCK_LOG_TRY
argument_list|(
literal|"SLOCK"
argument_list|,
operator|&
name|sx
operator|->
name|lock_object
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|WITNESS_LOCK
argument_list|(
operator|&
name|sx
operator|->
name|lock_object
argument_list|,
name|LOP_TRYLOCK
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|LOCKSTAT_PROFILE_OBTAIN_RWLOCK_SUCCESS
argument_list|(
name|sx__acquire
argument_list|,
name|sx
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|file
argument_list|,
name|line
argument_list|,
name|LOCKSTAT_READER
argument_list|)
expr_stmt|;
name|TD_LOCKS_INC
argument_list|(
name|curthread
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
name|LOCK_LOG_TRY
argument_list|(
literal|"SLOCK"
argument_list|,
operator|&
name|sx
operator|->
name|lock_object
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|sx_try_slock_
parameter_list|(
name|struct
name|sx
modifier|*
name|sx
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|)
block|{
return|return
operator|(
name|sx_try_slock_int
argument_list|(
argument|sx LOCK_FILE_LINE_ARG
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|_sx_xlock
parameter_list|(
name|struct
name|sx
modifier|*
name|sx
parameter_list|,
name|int
name|opts
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|)
block|{
name|uintptr_t
name|tid
decl_stmt|,
name|x
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|KASSERT
argument_list|(
name|kdb_active
operator|!=
literal|0
operator|||
name|SCHEDULER_STOPPED
argument_list|()
operator|||
operator|!
name|TD_IS_IDLETHREAD
argument_list|(
name|curthread
argument_list|)
argument_list|,
operator|(
literal|"sx_xlock() by idle thread %p on sx %s @ %s:%d"
operator|,
name|curthread
operator|,
name|sx
operator|->
name|lock_object
operator|.
name|lo_name
operator|,
name|file
operator|,
name|line
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|sx
operator|->
name|sx_lock
operator|!=
name|SX_LOCK_DESTROYED
argument_list|,
operator|(
literal|"sx_xlock() of destroyed sx @ %s:%d"
operator|,
name|file
operator|,
name|line
operator|)
argument_list|)
expr_stmt|;
name|WITNESS_CHECKORDER
argument_list|(
operator|&
name|sx
operator|->
name|lock_object
argument_list|,
name|LOP_NEWORDER
operator||
name|LOP_EXCLUSIVE
argument_list|,
name|file
argument_list|,
name|line
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|tid
operator|=
operator|(
name|uintptr_t
operator|)
name|curthread
expr_stmt|;
name|x
operator|=
name|SX_LOCK_UNLOCKED
expr_stmt|;
if|if
condition|(
operator|!
name|atomic_fcmpset_acq_ptr
argument_list|(
operator|&
name|sx
operator|->
name|sx_lock
argument_list|,
operator|&
name|x
argument_list|,
name|tid
argument_list|)
condition|)
name|error
operator|=
name|_sx_xlock_hard
argument_list|(
argument|sx
argument_list|,
argument|x
argument_list|,
argument|opts LOCK_FILE_LINE_ARG
argument_list|)
expr_stmt|;
else|else
name|LOCKSTAT_PROFILE_OBTAIN_RWLOCK_SUCCESS
argument_list|(
name|sx__acquire
argument_list|,
name|sx
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|file
argument_list|,
name|line
argument_list|,
name|LOCKSTAT_WRITER
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
block|{
name|LOCK_LOG_LOCK
argument_list|(
literal|"XLOCK"
argument_list|,
operator|&
name|sx
operator|->
name|lock_object
argument_list|,
literal|0
argument_list|,
name|sx
operator|->
name|sx_recurse
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|WITNESS_LOCK
argument_list|(
operator|&
name|sx
operator|->
name|lock_object
argument_list|,
name|LOP_EXCLUSIVE
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|TD_LOCKS_INC
argument_list|(
name|curthread
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|sx_try_xlock_int
parameter_list|(
name|struct
name|sx
modifier|*
name|sx
name|LOCK_FILE_LINE_ARG_DEF
parameter_list|)
block|{
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|uintptr_t
name|tid
decl_stmt|,
name|x
decl_stmt|;
name|int
name|rval
decl_stmt|;
name|bool
name|recursed
decl_stmt|;
name|td
operator|=
name|curthread
expr_stmt|;
name|tid
operator|=
operator|(
name|uintptr_t
operator|)
name|td
expr_stmt|;
if|if
condition|(
name|SCHEDULER_STOPPED_TD
argument_list|(
name|td
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|KASSERT
argument_list|(
name|kdb_active
operator|!=
literal|0
operator|||
operator|!
name|TD_IS_IDLETHREAD
argument_list|(
name|td
argument_list|)
argument_list|,
operator|(
literal|"sx_try_xlock() by idle thread %p on sx %s @ %s:%d"
operator|,
name|curthread
operator|,
name|sx
operator|->
name|lock_object
operator|.
name|lo_name
operator|,
name|file
operator|,
name|line
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|sx
operator|->
name|sx_lock
operator|!=
name|SX_LOCK_DESTROYED
argument_list|,
operator|(
literal|"sx_try_xlock() of destroyed sx @ %s:%d"
operator|,
name|file
operator|,
name|line
operator|)
argument_list|)
expr_stmt|;
name|rval
operator|=
literal|1
expr_stmt|;
name|recursed
operator|=
name|false
expr_stmt|;
name|x
operator|=
name|SX_LOCK_UNLOCKED
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|atomic_fcmpset_acq_ptr
argument_list|(
operator|&
name|sx
operator|->
name|sx_lock
argument_list|,
operator|&
name|x
argument_list|,
name|tid
argument_list|)
condition|)
break|break;
if|if
condition|(
name|x
operator|==
name|SX_LOCK_UNLOCKED
condition|)
continue|continue;
if|if
condition|(
name|x
operator|==
name|tid
operator|&&
operator|(
name|sx
operator|->
name|lock_object
operator|.
name|lo_flags
operator|&
name|LO_RECURSABLE
operator|)
condition|)
block|{
name|sx
operator|->
name|sx_recurse
operator|++
expr_stmt|;
name|atomic_set_ptr
argument_list|(
operator|&
name|sx
operator|->
name|sx_lock
argument_list|,
name|SX_LOCK_RECURSED
argument_list|)
expr_stmt|;
break|break;
block|}
name|rval
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|LOCK_LOG_TRY
argument_list|(
literal|"XLOCK"
argument_list|,
operator|&
name|sx
operator|->
name|lock_object
argument_list|,
literal|0
argument_list|,
name|rval
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|rval
condition|)
block|{
name|WITNESS_LOCK
argument_list|(
operator|&
name|sx
operator|->
name|lock_object
argument_list|,
name|LOP_EXCLUSIVE
operator||
name|LOP_TRYLOCK
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|recursed
condition|)
name|LOCKSTAT_PROFILE_OBTAIN_RWLOCK_SUCCESS
argument_list|(
name|sx__acquire
argument_list|,
name|sx
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|file
argument_list|,
name|line
argument_list|,
name|LOCKSTAT_WRITER
argument_list|)
expr_stmt|;
name|TD_LOCKS_INC
argument_list|(
name|curthread
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|rval
operator|)
return|;
block|}
end_function

begin_function
name|int
name|sx_try_xlock_
parameter_list|(
name|struct
name|sx
modifier|*
name|sx
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|)
block|{
return|return
operator|(
name|sx_try_xlock_int
argument_list|(
argument|sx LOCK_FILE_LINE_ARG
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|void
name|_sx_xunlock
parameter_list|(
name|struct
name|sx
modifier|*
name|sx
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|)
block|{
name|KASSERT
argument_list|(
name|sx
operator|->
name|sx_lock
operator|!=
name|SX_LOCK_DESTROYED
argument_list|,
operator|(
literal|"sx_xunlock() of destroyed sx @ %s:%d"
operator|,
name|file
operator|,
name|line
operator|)
argument_list|)
expr_stmt|;
name|_sx_assert
argument_list|(
name|sx
argument_list|,
name|SA_XLOCKED
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|WITNESS_UNLOCK
argument_list|(
operator|&
name|sx
operator|->
name|lock_object
argument_list|,
name|LOP_EXCLUSIVE
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|LOCK_LOG_LOCK
argument_list|(
literal|"XUNLOCK"
argument_list|,
operator|&
name|sx
operator|->
name|lock_object
argument_list|,
literal|0
argument_list|,
name|sx
operator|->
name|sx_recurse
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
if|#
directive|if
name|LOCK_DEBUG
operator|>
literal|0
name|_sx_xunlock_hard
argument_list|(
name|sx
argument_list|,
operator|(
name|uintptr_t
operator|)
name|curthread
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
else|#
directive|else
name|__sx_xunlock
argument_list|(
name|sx
argument_list|,
name|curthread
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|TD_LOCKS_DEC
argument_list|(
name|curthread
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Try to do a non-blocking upgrade from a shared lock to an exclusive lock.  * This will only succeed if this thread holds a single shared lock.  * Return 1 if if the upgrade succeed, 0 otherwise.  */
end_comment

begin_function
name|int
name|sx_try_upgrade_int
parameter_list|(
name|struct
name|sx
modifier|*
name|sx
name|LOCK_FILE_LINE_ARG_DEF
parameter_list|)
block|{
name|uintptr_t
name|x
decl_stmt|;
name|int
name|success
decl_stmt|;
if|if
condition|(
name|SCHEDULER_STOPPED
argument_list|()
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|KASSERT
argument_list|(
name|sx
operator|->
name|sx_lock
operator|!=
name|SX_LOCK_DESTROYED
argument_list|,
operator|(
literal|"sx_try_upgrade() of destroyed sx @ %s:%d"
operator|,
name|file
operator|,
name|line
operator|)
argument_list|)
expr_stmt|;
name|_sx_assert
argument_list|(
name|sx
argument_list|,
name|SA_SLOCKED
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
comment|/* 	 * Try to switch from one shared lock to an exclusive lock.  We need 	 * to maintain the SX_LOCK_EXCLUSIVE_WAITERS flag if set so that 	 * we will wake up the exclusive waiters when we drop the lock. 	 */
name|x
operator|=
name|sx
operator|->
name|sx_lock
operator|&
name|SX_LOCK_EXCLUSIVE_WAITERS
expr_stmt|;
name|success
operator|=
name|atomic_cmpset_acq_ptr
argument_list|(
operator|&
name|sx
operator|->
name|sx_lock
argument_list|,
name|SX_SHARERS_LOCK
argument_list|(
literal|1
argument_list|)
operator||
name|x
argument_list|,
operator|(
name|uintptr_t
operator|)
name|curthread
operator||
name|x
argument_list|)
expr_stmt|;
name|LOCK_LOG_TRY
argument_list|(
literal|"XUPGRADE"
argument_list|,
operator|&
name|sx
operator|->
name|lock_object
argument_list|,
literal|0
argument_list|,
name|success
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
name|WITNESS_UPGRADE
argument_list|(
operator|&
name|sx
operator|->
name|lock_object
argument_list|,
name|LOP_EXCLUSIVE
operator||
name|LOP_TRYLOCK
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|LOCKSTAT_RECORD0
argument_list|(
name|sx__upgrade
argument_list|,
name|sx
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|success
operator|)
return|;
block|}
end_function

begin_function
name|int
name|sx_try_upgrade_
parameter_list|(
name|struct
name|sx
modifier|*
name|sx
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|)
block|{
return|return
operator|(
name|sx_try_upgrade_int
argument_list|(
argument|sx LOCK_FILE_LINE_ARG
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Downgrade an unrecursed exclusive lock into a single shared lock.  */
end_comment

begin_function
name|void
name|sx_downgrade_int
parameter_list|(
name|struct
name|sx
modifier|*
name|sx
name|LOCK_FILE_LINE_ARG_DEF
parameter_list|)
block|{
name|uintptr_t
name|x
decl_stmt|;
name|int
name|wakeup_swapper
decl_stmt|;
if|if
condition|(
name|SCHEDULER_STOPPED
argument_list|()
condition|)
return|return;
name|KASSERT
argument_list|(
name|sx
operator|->
name|sx_lock
operator|!=
name|SX_LOCK_DESTROYED
argument_list|,
operator|(
literal|"sx_downgrade() of destroyed sx @ %s:%d"
operator|,
name|file
operator|,
name|line
operator|)
argument_list|)
expr_stmt|;
name|_sx_assert
argument_list|(
name|sx
argument_list|,
name|SA_XLOCKED
operator||
name|SA_NOTRECURSED
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|INVARIANTS
if|if
condition|(
name|sx_recursed
argument_list|(
name|sx
argument_list|)
condition|)
name|panic
argument_list|(
literal|"downgrade of a recursed lock"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|WITNESS_DOWNGRADE
argument_list|(
operator|&
name|sx
operator|->
name|lock_object
argument_list|,
literal|0
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
comment|/* 	 * Try to switch from an exclusive lock with no shared waiters 	 * to one sharer with no shared waiters.  If there are 	 * exclusive waiters, we don't need to lock the sleep queue so 	 * long as we preserve the flag.  We do one quick try and if 	 * that fails we grab the sleepq lock to keep the flags from 	 * changing and do it the slow way. 	 * 	 * We have to lock the sleep queue if there are shared waiters 	 * so we can wake them up. 	 */
name|x
operator|=
name|sx
operator|->
name|sx_lock
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|x
operator|&
name|SX_LOCK_SHARED_WAITERS
operator|)
operator|&&
name|atomic_cmpset_rel_ptr
argument_list|(
operator|&
name|sx
operator|->
name|sx_lock
argument_list|,
name|x
argument_list|,
name|SX_SHARERS_LOCK
argument_list|(
literal|1
argument_list|)
operator||
operator|(
name|x
operator|&
name|SX_LOCK_EXCLUSIVE_WAITERS
operator|)
argument_list|)
condition|)
goto|goto
name|out
goto|;
comment|/* 	 * Lock the sleep queue so we can read the waiters bits 	 * without any races and wakeup any shared waiters. 	 */
name|sleepq_lock
argument_list|(
operator|&
name|sx
operator|->
name|lock_object
argument_list|)
expr_stmt|;
comment|/* 	 * Preserve SX_LOCK_EXCLUSIVE_WAITERS while downgraded to a single 	 * shared lock.  If there are any shared waiters, wake them up. 	 */
name|wakeup_swapper
operator|=
literal|0
expr_stmt|;
name|x
operator|=
name|sx
operator|->
name|sx_lock
expr_stmt|;
name|atomic_store_rel_ptr
argument_list|(
operator|&
name|sx
operator|->
name|sx_lock
argument_list|,
name|SX_SHARERS_LOCK
argument_list|(
literal|1
argument_list|)
operator||
operator|(
name|x
operator|&
name|SX_LOCK_EXCLUSIVE_WAITERS
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|&
name|SX_LOCK_SHARED_WAITERS
condition|)
name|wakeup_swapper
operator|=
name|sleepq_broadcast
argument_list|(
operator|&
name|sx
operator|->
name|lock_object
argument_list|,
name|SLEEPQ_SX
argument_list|,
literal|0
argument_list|,
name|SQ_SHARED_QUEUE
argument_list|)
expr_stmt|;
name|sleepq_release
argument_list|(
operator|&
name|sx
operator|->
name|lock_object
argument_list|)
expr_stmt|;
if|if
condition|(
name|wakeup_swapper
condition|)
name|kick_proc0
argument_list|()
expr_stmt|;
name|out
label|:
name|LOCK_LOG_LOCK
argument_list|(
literal|"XDOWNGRADE"
argument_list|,
operator|&
name|sx
operator|->
name|lock_object
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|LOCKSTAT_RECORD0
argument_list|(
name|sx__downgrade
argument_list|,
name|sx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|sx_downgrade_
parameter_list|(
name|struct
name|sx
modifier|*
name|sx
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|)
block|{
name|sx_downgrade_int
argument_list|(
argument|sx LOCK_FILE_LINE_ARG
argument_list|)
empty_stmt|;
block|}
end_function

begin_comment
comment|/*  * This function represents the so-called 'hard case' for sx_xlock  * operation.  All 'easy case' failures are redirected to this.  Note  * that ideally this would be a static function, but it needs to be  * accessible from at least sx.h.  */
end_comment

begin_function
name|int
name|_sx_xlock_hard
parameter_list|(
name|struct
name|sx
modifier|*
name|sx
parameter_list|,
name|uintptr_t
name|x
parameter_list|,
name|int
name|opts
name|LOCK_FILE_LINE_ARG_DEF
parameter_list|)
block|{
name|GIANT_DECLARE
expr_stmt|;
name|uintptr_t
name|tid
decl_stmt|;
ifdef|#
directive|ifdef
name|ADAPTIVE_SX
specifier|volatile
name|struct
name|thread
modifier|*
name|owner
decl_stmt|;
name|u_int
name|i
decl_stmt|,
name|n
decl_stmt|,
name|spintries
init|=
literal|0
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|LOCK_PROFILING
name|uint64_t
name|waittime
init|=
literal|0
decl_stmt|;
name|int
name|contested
init|=
literal|0
decl_stmt|;
endif|#
directive|endif
name|int
name|error
init|=
literal|0
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|ADAPTIVE_SX
argument_list|)
operator|||
name|defined
argument_list|(
name|KDTRACE_HOOKS
argument_list|)
name|struct
name|lock_delay_arg
name|lda
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|KDTRACE_HOOKS
name|u_int
name|sleep_cnt
init|=
literal|0
decl_stmt|;
name|int64_t
name|sleep_time
init|=
literal|0
decl_stmt|;
name|int64_t
name|all_time
init|=
literal|0
decl_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|KDTRACE_HOOKS
argument_list|)
operator|||
name|defined
argument_list|(
name|LOCK_PROFILING
argument_list|)
name|uintptr_t
name|state
decl_stmt|;
endif|#
directive|endif
name|int
name|extra_work
init|=
literal|0
decl_stmt|;
name|tid
operator|=
operator|(
name|uintptr_t
operator|)
name|curthread
expr_stmt|;
if|if
condition|(
name|SCHEDULER_STOPPED
argument_list|()
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|#
directive|if
name|defined
argument_list|(
name|ADAPTIVE_SX
argument_list|)
name|lock_delay_arg_init
argument_list|(
operator|&
name|lda
argument_list|,
operator|&
name|sx_delay
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|KDTRACE_HOOKS
argument_list|)
name|lock_delay_arg_init
argument_list|(
operator|&
name|lda
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|__predict_false
argument_list|(
name|x
operator|==
name|SX_LOCK_UNLOCKED
argument_list|)
condition|)
name|x
operator|=
name|SX_READ_VALUE
argument_list|(
name|sx
argument_list|)
expr_stmt|;
comment|/* If we already hold an exclusive lock, then recurse. */
if|if
condition|(
name|__predict_false
argument_list|(
name|lv_sx_owner
argument_list|(
name|x
argument_list|)
operator|==
operator|(
expr|struct
name|thread
operator|*
operator|)
name|tid
argument_list|)
condition|)
block|{
name|KASSERT
argument_list|(
operator|(
name|sx
operator|->
name|lock_object
operator|.
name|lo_flags
operator|&
name|LO_RECURSABLE
operator|)
operator|!=
literal|0
argument_list|,
operator|(
literal|"_sx_xlock_hard: recursed on non-recursive sx %s @ %s:%d\n"
operator|,
name|sx
operator|->
name|lock_object
operator|.
name|lo_name
operator|,
name|file
operator|,
name|line
operator|)
argument_list|)
expr_stmt|;
name|sx
operator|->
name|sx_recurse
operator|++
expr_stmt|;
name|atomic_set_ptr
argument_list|(
operator|&
name|sx
operator|->
name|sx_lock
argument_list|,
name|SX_LOCK_RECURSED
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOCK_LOG_TEST
argument_list|(
operator|&
name|sx
operator|->
name|lock_object
argument_list|,
literal|0
argument_list|)
condition|)
name|CTR2
argument_list|(
name|KTR_LOCK
argument_list|,
literal|"%s: %p recursing"
argument_list|,
name|__func__
argument_list|,
name|sx
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|LOCK_LOG_TEST
argument_list|(
operator|&
name|sx
operator|->
name|lock_object
argument_list|,
literal|0
argument_list|)
condition|)
name|CTR5
argument_list|(
name|KTR_LOCK
argument_list|,
literal|"%s: %s contested (lock=%p) at %s:%d"
argument_list|,
name|__func__
argument_list|,
name|sx
operator|->
name|lock_object
operator|.
name|lo_name
argument_list|,
operator|(
name|void
operator|*
operator|)
name|sx
operator|->
name|sx_lock
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HWPMC_HOOKS
name|PMC_SOFT_CALL
argument_list|( , ,
name|lock
argument_list|,
name|failed
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|lock_profile_obtain_lock_failed
argument_list|(
operator|&
name|sx
operator|->
name|lock_object
argument_list|,
operator|&
name|contested
argument_list|,
operator|&
name|waittime
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|LOCK_PROFILING
name|extra_work
operator|=
literal|1
expr_stmt|;
name|state
operator|=
name|x
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|KDTRACE_HOOKS
argument_list|)
name|extra_work
operator|=
name|lockstat_enabled
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|extra_work
argument_list|)
condition|)
block|{
name|all_time
operator|-=
name|lockstat_nsecs
argument_list|(
operator|&
name|sx
operator|->
name|lock_object
argument_list|)
expr_stmt|;
name|state
operator|=
name|x
expr_stmt|;
block|}
endif|#
directive|endif
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|x
operator|==
name|SX_LOCK_UNLOCKED
condition|)
block|{
if|if
condition|(
name|atomic_fcmpset_acq_ptr
argument_list|(
operator|&
name|sx
operator|->
name|sx_lock
argument_list|,
operator|&
name|x
argument_list|,
name|tid
argument_list|)
condition|)
break|break;
continue|continue;
block|}
ifdef|#
directive|ifdef
name|KDTRACE_HOOKS
name|lda
operator|.
name|spin_cnt
operator|++
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ADAPTIVE_SX
comment|/* 		 * If the lock is write locked and the owner is 		 * running on another CPU, spin until the owner stops 		 * running or the state of the lock changes. 		 */
if|if
condition|(
operator|(
name|sx
operator|->
name|lock_object
operator|.
name|lo_flags
operator|&
name|SX_NOADAPTIVE
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|x
operator|&
name|SX_LOCK_SHARED
operator|)
operator|==
literal|0
condition|)
block|{
name|owner
operator|=
name|lv_sx_owner
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|TD_IS_RUNNING
argument_list|(
name|owner
argument_list|)
condition|)
block|{
if|if
condition|(
name|LOCK_LOG_TEST
argument_list|(
operator|&
name|sx
operator|->
name|lock_object
argument_list|,
literal|0
argument_list|)
condition|)
name|CTR3
argument_list|(
name|KTR_LOCK
argument_list|,
literal|"%s: spinning on %p held by %p"
argument_list|,
name|__func__
argument_list|,
name|sx
argument_list|,
name|owner
argument_list|)
expr_stmt|;
name|KTR_STATE1
argument_list|(
name|KTR_SCHED
argument_list|,
literal|"thread"
argument_list|,
name|sched_tdname
argument_list|(
name|curthread
argument_list|)
argument_list|,
literal|"spinning"
argument_list|,
literal|"lockname:\"%s\""
argument_list|,
name|sx
operator|->
name|lock_object
operator|.
name|lo_name
argument_list|)
expr_stmt|;
name|GIANT_SAVE
argument_list|(
name|extra_work
argument_list|)
expr_stmt|;
do|do
block|{
name|lock_delay
argument_list|(
operator|&
name|lda
argument_list|)
expr_stmt|;
name|x
operator|=
name|SX_READ_VALUE
argument_list|(
name|sx
argument_list|)
expr_stmt|;
name|owner
operator|=
name|lv_sx_owner
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|owner
operator|!=
name|NULL
operator|&&
name|TD_IS_RUNNING
argument_list|(
name|owner
argument_list|)
condition|)
do|;
name|KTR_STATE0
argument_list|(
name|KTR_SCHED
argument_list|,
literal|"thread"
argument_list|,
name|sched_tdname
argument_list|(
name|curthread
argument_list|)
argument_list|,
literal|"running"
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
elseif|else
if|if
condition|(
name|SX_SHARERS
argument_list|(
name|x
argument_list|)
operator|&&
name|spintries
operator|<
name|asx_retries
condition|)
block|{
name|KTR_STATE1
argument_list|(
name|KTR_SCHED
argument_list|,
literal|"thread"
argument_list|,
name|sched_tdname
argument_list|(
name|curthread
argument_list|)
argument_list|,
literal|"spinning"
argument_list|,
literal|"lockname:\"%s\""
argument_list|,
name|sx
operator|->
name|lock_object
operator|.
name|lo_name
argument_list|)
expr_stmt|;
name|GIANT_SAVE
argument_list|(
name|extra_work
argument_list|)
expr_stmt|;
name|spintries
operator|++
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|asx_loops
condition|;
name|i
operator|+=
name|n
control|)
block|{
if|if
condition|(
name|LOCK_LOG_TEST
argument_list|(
operator|&
name|sx
operator|->
name|lock_object
argument_list|,
literal|0
argument_list|)
condition|)
name|CTR4
argument_list|(
name|KTR_LOCK
argument_list|,
literal|"%s: shared spinning on %p with %u and %u"
argument_list|,
name|__func__
argument_list|,
name|sx
argument_list|,
name|spintries
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|n
operator|=
name|SX_SHARERS
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|lock_delay_spin
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|x
operator|=
name|SX_READ_VALUE
argument_list|(
name|sx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|x
operator|&
name|SX_LOCK_SHARED
operator|)
operator|==
literal|0
operator|||
name|SX_SHARERS
argument_list|(
name|x
argument_list|)
operator|==
literal|0
condition|)
break|break;
block|}
ifdef|#
directive|ifdef
name|KDTRACE_HOOKS
name|lda
operator|.
name|spin_cnt
operator|+=
name|i
expr_stmt|;
endif|#
directive|endif
name|KTR_STATE0
argument_list|(
name|KTR_SCHED
argument_list|,
literal|"thread"
argument_list|,
name|sched_tdname
argument_list|(
name|curthread
argument_list|)
argument_list|,
literal|"running"
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
name|asx_loops
condition|)
continue|continue;
block|}
block|}
endif|#
directive|endif
name|sleepq_lock
argument_list|(
operator|&
name|sx
operator|->
name|lock_object
argument_list|)
expr_stmt|;
name|x
operator|=
name|SX_READ_VALUE
argument_list|(
name|sx
argument_list|)
expr_stmt|;
comment|/* 		 * If the lock was released while spinning on the 		 * sleep queue chain lock, try again. 		 */
if|if
condition|(
name|x
operator|==
name|SX_LOCK_UNLOCKED
condition|)
block|{
name|sleepq_release
argument_list|(
operator|&
name|sx
operator|->
name|lock_object
argument_list|)
expr_stmt|;
continue|continue;
block|}
ifdef|#
directive|ifdef
name|ADAPTIVE_SX
comment|/* 		 * The current lock owner might have started executing 		 * on another CPU (or the lock could have changed 		 * owners) while we were waiting on the sleep queue 		 * chain lock.  If so, drop the sleep queue lock and try 		 * again. 		 */
if|if
condition|(
operator|!
operator|(
name|x
operator|&
name|SX_LOCK_SHARED
operator|)
operator|&&
operator|(
name|sx
operator|->
name|lock_object
operator|.
name|lo_flags
operator|&
name|SX_NOADAPTIVE
operator|)
operator|==
literal|0
condition|)
block|{
name|owner
operator|=
operator|(
expr|struct
name|thread
operator|*
operator|)
name|SX_OWNER
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|TD_IS_RUNNING
argument_list|(
name|owner
argument_list|)
condition|)
block|{
name|sleepq_release
argument_list|(
operator|&
name|sx
operator|->
name|lock_object
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
endif|#
directive|endif
comment|/* 		 * If an exclusive lock was released with both shared 		 * and exclusive waiters and a shared waiter hasn't 		 * woken up and acquired the lock yet, sx_lock will be 		 * set to SX_LOCK_UNLOCKED | SX_LOCK_EXCLUSIVE_WAITERS. 		 * If we see that value, try to acquire it once.  Note 		 * that we have to preserve SX_LOCK_EXCLUSIVE_WAITERS 		 * as there are other exclusive waiters still.  If we 		 * fail, restart the loop. 		 */
if|if
condition|(
name|x
operator|==
operator|(
name|SX_LOCK_UNLOCKED
operator||
name|SX_LOCK_EXCLUSIVE_WAITERS
operator|)
condition|)
block|{
if|if
condition|(
name|atomic_cmpset_acq_ptr
argument_list|(
operator|&
name|sx
operator|->
name|sx_lock
argument_list|,
name|SX_LOCK_UNLOCKED
operator||
name|SX_LOCK_EXCLUSIVE_WAITERS
argument_list|,
name|tid
operator||
name|SX_LOCK_EXCLUSIVE_WAITERS
argument_list|)
condition|)
block|{
name|sleepq_release
argument_list|(
operator|&
name|sx
operator|->
name|lock_object
argument_list|)
expr_stmt|;
name|CTR2
argument_list|(
name|KTR_LOCK
argument_list|,
literal|"%s: %p claimed by new writer"
argument_list|,
name|__func__
argument_list|,
name|sx
argument_list|)
expr_stmt|;
break|break;
block|}
name|sleepq_release
argument_list|(
operator|&
name|sx
operator|->
name|lock_object
argument_list|)
expr_stmt|;
name|x
operator|=
name|SX_READ_VALUE
argument_list|(
name|sx
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * Try to set the SX_LOCK_EXCLUSIVE_WAITERS.  If we fail, 		 * than loop back and retry. 		 */
if|if
condition|(
operator|!
operator|(
name|x
operator|&
name|SX_LOCK_EXCLUSIVE_WAITERS
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|atomic_cmpset_ptr
argument_list|(
operator|&
name|sx
operator|->
name|sx_lock
argument_list|,
name|x
argument_list|,
name|x
operator||
name|SX_LOCK_EXCLUSIVE_WAITERS
argument_list|)
condition|)
block|{
name|sleepq_release
argument_list|(
operator|&
name|sx
operator|->
name|lock_object
argument_list|)
expr_stmt|;
name|x
operator|=
name|SX_READ_VALUE
argument_list|(
name|sx
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|LOCK_LOG_TEST
argument_list|(
operator|&
name|sx
operator|->
name|lock_object
argument_list|,
literal|0
argument_list|)
condition|)
name|CTR2
argument_list|(
name|KTR_LOCK
argument_list|,
literal|"%s: %p set excl waiters flag"
argument_list|,
name|__func__
argument_list|,
name|sx
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Since we have been unable to acquire the exclusive 		 * lock and the exclusive waiters flag is set, we have 		 * to sleep. 		 */
if|if
condition|(
name|LOCK_LOG_TEST
argument_list|(
operator|&
name|sx
operator|->
name|lock_object
argument_list|,
literal|0
argument_list|)
condition|)
name|CTR2
argument_list|(
name|KTR_LOCK
argument_list|,
literal|"%s: %p blocking on sleep queue"
argument_list|,
name|__func__
argument_list|,
name|sx
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|KDTRACE_HOOKS
name|sleep_time
operator|-=
name|lockstat_nsecs
argument_list|(
operator|&
name|sx
operator|->
name|lock_object
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|GIANT_SAVE
argument_list|(
name|extra_work
argument_list|)
expr_stmt|;
name|sleepq_add
argument_list|(
operator|&
name|sx
operator|->
name|lock_object
argument_list|,
name|NULL
argument_list|,
name|sx
operator|->
name|lock_object
operator|.
name|lo_name
argument_list|,
name|SLEEPQ_SX
operator||
operator|(
operator|(
name|opts
operator|&
name|SX_INTERRUPTIBLE
operator|)
condition|?
name|SLEEPQ_INTERRUPTIBLE
else|:
literal|0
operator|)
argument_list|,
name|SQ_EXCLUSIVE_QUEUE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|opts
operator|&
name|SX_INTERRUPTIBLE
operator|)
condition|)
name|sleepq_wait
argument_list|(
operator|&
name|sx
operator|->
name|lock_object
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|error
operator|=
name|sleepq_wait_sig
argument_list|(
operator|&
name|sx
operator|->
name|lock_object
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|KDTRACE_HOOKS
name|sleep_time
operator|+=
name|lockstat_nsecs
argument_list|(
operator|&
name|sx
operator|->
name|lock_object
argument_list|)
expr_stmt|;
name|sleep_cnt
operator|++
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|error
condition|)
block|{
if|if
condition|(
name|LOCK_LOG_TEST
argument_list|(
operator|&
name|sx
operator|->
name|lock_object
argument_list|,
literal|0
argument_list|)
condition|)
name|CTR2
argument_list|(
name|KTR_LOCK
argument_list|,
literal|"%s: interruptible sleep by %p suspended by signal"
argument_list|,
name|__func__
argument_list|,
name|sx
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|LOCK_LOG_TEST
argument_list|(
operator|&
name|sx
operator|->
name|lock_object
argument_list|,
literal|0
argument_list|)
condition|)
name|CTR2
argument_list|(
name|KTR_LOCK
argument_list|,
literal|"%s: %p resuming from sleep queue"
argument_list|,
name|__func__
argument_list|,
name|sx
argument_list|)
expr_stmt|;
name|x
operator|=
name|SX_READ_VALUE
argument_list|(
name|sx
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|KDTRACE_HOOKS
argument_list|)
operator|||
name|defined
argument_list|(
name|LOCK_PROFILING
argument_list|)
if|if
condition|(
name|__predict_true
argument_list|(
operator|!
name|extra_work
argument_list|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|KDTRACE_HOOKS
name|all_time
operator|+=
name|lockstat_nsecs
argument_list|(
operator|&
name|sx
operator|->
name|lock_object
argument_list|)
expr_stmt|;
if|if
condition|(
name|sleep_time
condition|)
name|LOCKSTAT_RECORD4
argument_list|(
name|sx__block
argument_list|,
name|sx
argument_list|,
name|sleep_time
argument_list|,
name|LOCKSTAT_WRITER
argument_list|,
operator|(
name|state
operator|&
name|SX_LOCK_SHARED
operator|)
operator|==
literal|0
argument_list|,
operator|(
name|state
operator|&
name|SX_LOCK_SHARED
operator|)
operator|==
literal|0
condition|?
literal|0
else|:
name|SX_SHARERS
argument_list|(
name|state
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|lda
operator|.
name|spin_cnt
operator|>
name|sleep_cnt
condition|)
name|LOCKSTAT_RECORD4
argument_list|(
name|sx__spin
argument_list|,
name|sx
argument_list|,
name|all_time
operator|-
name|sleep_time
argument_list|,
name|LOCKSTAT_WRITER
argument_list|,
operator|(
name|state
operator|&
name|SX_LOCK_SHARED
operator|)
operator|==
literal|0
argument_list|,
operator|(
name|state
operator|&
name|SX_LOCK_SHARED
operator|)
operator|==
literal|0
condition|?
literal|0
else|:
name|SX_SHARERS
argument_list|(
name|state
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|error
condition|)
name|LOCKSTAT_PROFILE_OBTAIN_RWLOCK_SUCCESS
argument_list|(
name|sx__acquire
argument_list|,
name|sx
argument_list|,
name|contested
argument_list|,
name|waittime
argument_list|,
name|file
argument_list|,
name|line
argument_list|,
name|LOCKSTAT_WRITER
argument_list|)
expr_stmt|;
name|GIANT_RESTORE
argument_list|()
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * This function represents the so-called 'hard case' for sx_xunlock  * operation.  All 'easy case' failures are redirected to this.  Note  * that ideally this would be a static function, but it needs to be  * accessible from at least sx.h.  */
end_comment

begin_function
name|void
name|_sx_xunlock_hard
parameter_list|(
name|struct
name|sx
modifier|*
name|sx
parameter_list|,
name|uintptr_t
name|x
name|LOCK_FILE_LINE_ARG_DEF
parameter_list|)
block|{
name|uintptr_t
name|tid
decl_stmt|,
name|setx
decl_stmt|;
name|int
name|queue
decl_stmt|,
name|wakeup_swapper
decl_stmt|;
if|if
condition|(
name|SCHEDULER_STOPPED
argument_list|()
condition|)
return|return;
name|tid
operator|=
operator|(
name|uintptr_t
operator|)
name|curthread
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|x
operator|==
name|tid
argument_list|)
condition|)
name|x
operator|=
name|SX_READ_VALUE
argument_list|(
name|sx
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
operator|!
operator|(
name|x
operator|&
name|SX_LOCK_SHARED
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|x
operator|&
name|SX_LOCK_RECURSED
argument_list|)
condition|)
block|{
comment|/* The lock is recursed, unrecurse one level. */
if|if
condition|(
operator|(
operator|--
name|sx
operator|->
name|sx_recurse
operator|)
operator|==
literal|0
condition|)
name|atomic_clear_ptr
argument_list|(
operator|&
name|sx
operator|->
name|sx_lock
argument_list|,
name|SX_LOCK_RECURSED
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOCK_LOG_TEST
argument_list|(
operator|&
name|sx
operator|->
name|lock_object
argument_list|,
literal|0
argument_list|)
condition|)
name|CTR2
argument_list|(
name|KTR_LOCK
argument_list|,
literal|"%s: %p unrecursing"
argument_list|,
name|__func__
argument_list|,
name|sx
argument_list|)
expr_stmt|;
return|return;
block|}
name|LOCKSTAT_PROFILE_RELEASE_RWLOCK
argument_list|(
name|sx__release
argument_list|,
name|sx
argument_list|,
name|LOCKSTAT_WRITER
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|==
name|tid
operator|&&
name|atomic_cmpset_rel_ptr
argument_list|(
operator|&
name|sx
operator|->
name|sx_lock
argument_list|,
name|tid
argument_list|,
name|SX_LOCK_UNLOCKED
argument_list|)
condition|)
return|return;
if|if
condition|(
name|LOCK_LOG_TEST
argument_list|(
operator|&
name|sx
operator|->
name|lock_object
argument_list|,
literal|0
argument_list|)
condition|)
name|CTR2
argument_list|(
name|KTR_LOCK
argument_list|,
literal|"%s: %p contested"
argument_list|,
name|__func__
argument_list|,
name|sx
argument_list|)
expr_stmt|;
name|sleepq_lock
argument_list|(
operator|&
name|sx
operator|->
name|lock_object
argument_list|)
expr_stmt|;
name|x
operator|=
name|SX_READ_VALUE
argument_list|(
name|sx
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|x
operator|&
operator|(
name|SX_LOCK_SHARED_WAITERS
operator||
name|SX_LOCK_EXCLUSIVE_WAITERS
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * The wake up algorithm here is quite simple and probably not 	 * ideal.  It gives precedence to shared waiters if they are 	 * present.  For this condition, we have to preserve the 	 * state of the exclusive waiters flag. 	 * If interruptible sleeps left the shared queue empty avoid a 	 * starvation for the threads sleeping on the exclusive queue by giving 	 * them precedence and cleaning up the shared waiters bit anyway. 	 */
name|setx
operator|=
name|SX_LOCK_UNLOCKED
expr_stmt|;
name|queue
operator|=
name|SQ_EXCLUSIVE_QUEUE
expr_stmt|;
if|if
condition|(
operator|(
name|x
operator|&
name|SX_LOCK_SHARED_WAITERS
operator|)
operator|!=
literal|0
operator|&&
name|sleepq_sleepcnt
argument_list|(
operator|&
name|sx
operator|->
name|lock_object
argument_list|,
name|SQ_SHARED_QUEUE
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|queue
operator|=
name|SQ_SHARED_QUEUE
expr_stmt|;
name|setx
operator||=
operator|(
name|x
operator|&
name|SX_LOCK_EXCLUSIVE_WAITERS
operator|)
expr_stmt|;
block|}
name|atomic_store_rel_ptr
argument_list|(
operator|&
name|sx
operator|->
name|sx_lock
argument_list|,
name|setx
argument_list|)
expr_stmt|;
comment|/* Wake up all the waiters for the specific queue. */
if|if
condition|(
name|LOCK_LOG_TEST
argument_list|(
operator|&
name|sx
operator|->
name|lock_object
argument_list|,
literal|0
argument_list|)
condition|)
name|CTR3
argument_list|(
name|KTR_LOCK
argument_list|,
literal|"%s: %p waking up all threads on %s queue"
argument_list|,
name|__func__
argument_list|,
name|sx
argument_list|,
name|queue
operator|==
name|SQ_SHARED_QUEUE
condition|?
literal|"shared"
else|:
literal|"exclusive"
argument_list|)
expr_stmt|;
name|wakeup_swapper
operator|=
name|sleepq_broadcast
argument_list|(
operator|&
name|sx
operator|->
name|lock_object
argument_list|,
name|SLEEPQ_SX
argument_list|,
literal|0
argument_list|,
name|queue
argument_list|)
expr_stmt|;
name|sleepq_release
argument_list|(
operator|&
name|sx
operator|->
name|lock_object
argument_list|)
expr_stmt|;
if|if
condition|(
name|wakeup_swapper
condition|)
name|kick_proc0
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|bool
name|__always_inline
name|__sx_slock_try
parameter_list|(
name|struct
name|sx
modifier|*
name|sx
parameter_list|,
name|uintptr_t
modifier|*
name|xp
name|LOCK_FILE_LINE_ARG_DEF
parameter_list|)
block|{
comment|/* 	 * If no other thread has an exclusive lock then try to bump up 	 * the count of sharers.  Since we have to preserve the state 	 * of SX_LOCK_EXCLUSIVE_WAITERS, if we fail to acquire the 	 * shared lock loop back and retry. 	 */
while|while
condition|(
operator|*
name|xp
operator|&
name|SX_LOCK_SHARED
condition|)
block|{
name|MPASS
argument_list|(
operator|!
operator|(
operator|*
name|xp
operator|&
name|SX_LOCK_SHARED_WAITERS
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|atomic_fcmpset_acq_ptr
argument_list|(
operator|&
name|sx
operator|->
name|sx_lock
argument_list|,
name|xp
argument_list|,
operator|*
name|xp
operator|+
name|SX_ONE_SHARER
argument_list|)
condition|)
block|{
if|if
condition|(
name|LOCK_LOG_TEST
argument_list|(
operator|&
name|sx
operator|->
name|lock_object
argument_list|,
literal|0
argument_list|)
condition|)
name|CTR4
argument_list|(
name|KTR_LOCK
argument_list|,
literal|"%s: %p succeed %p -> %p"
argument_list|,
name|__func__
argument_list|,
name|sx
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|*
name|xp
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
operator|*
name|xp
operator|+
name|SX_ONE_SHARER
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|true
operator|)
return|;
block|}
block|}
return|return
operator|(
name|false
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|__noinline
name|_sx_slock_hard
parameter_list|(
name|struct
name|sx
modifier|*
name|sx
parameter_list|,
name|int
name|opts
parameter_list|,
name|uintptr_t
name|x
name|LOCK_FILE_LINE_ARG_DEF
parameter_list|)
block|{
name|GIANT_DECLARE
expr_stmt|;
ifdef|#
directive|ifdef
name|ADAPTIVE_SX
specifier|volatile
name|struct
name|thread
modifier|*
name|owner
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|LOCK_PROFILING
name|uint64_t
name|waittime
init|=
literal|0
decl_stmt|;
name|int
name|contested
init|=
literal|0
decl_stmt|;
endif|#
directive|endif
name|int
name|error
init|=
literal|0
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|ADAPTIVE_SX
argument_list|)
operator|||
name|defined
argument_list|(
name|KDTRACE_HOOKS
argument_list|)
name|struct
name|lock_delay_arg
name|lda
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|KDTRACE_HOOKS
name|u_int
name|sleep_cnt
init|=
literal|0
decl_stmt|;
name|int64_t
name|sleep_time
init|=
literal|0
decl_stmt|;
name|int64_t
name|all_time
init|=
literal|0
decl_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|KDTRACE_HOOKS
argument_list|)
operator|||
name|defined
argument_list|(
name|LOCK_PROFILING
argument_list|)
name|uintptr_t
name|state
decl_stmt|;
endif|#
directive|endif
name|int
name|extra_work
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|SCHEDULER_STOPPED
argument_list|()
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|#
directive|if
name|defined
argument_list|(
name|ADAPTIVE_SX
argument_list|)
name|lock_delay_arg_init
argument_list|(
operator|&
name|lda
argument_list|,
operator|&
name|sx_delay
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|KDTRACE_HOOKS
argument_list|)
name|lock_delay_arg_init
argument_list|(
operator|&
name|lda
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HWPMC_HOOKS
name|PMC_SOFT_CALL
argument_list|( , ,
name|lock
argument_list|,
name|failed
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|lock_profile_obtain_lock_failed
argument_list|(
operator|&
name|sx
operator|->
name|lock_object
argument_list|,
operator|&
name|contested
argument_list|,
operator|&
name|waittime
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|LOCK_PROFILING
name|extra_work
operator|=
literal|1
expr_stmt|;
name|state
operator|=
name|x
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|KDTRACE_HOOKS
argument_list|)
name|extra_work
operator|=
name|lockstat_enabled
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|extra_work
argument_list|)
condition|)
block|{
name|all_time
operator|-=
name|lockstat_nsecs
argument_list|(
operator|&
name|sx
operator|->
name|lock_object
argument_list|)
expr_stmt|;
name|state
operator|=
name|x
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* 	 * As with rwlocks, we don't make any attempt to try to block 	 * shared locks once there is an exclusive waiter. 	 */
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|__sx_slock_try
argument_list|(
argument|sx
argument_list|,
argument|&x LOCK_FILE_LINE_ARG
argument_list|)
condition|)
break|break;
ifdef|#
directive|ifdef
name|KDTRACE_HOOKS
name|lda
operator|.
name|spin_cnt
operator|++
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ADAPTIVE_SX
comment|/* 		 * If the owner is running on another CPU, spin until 		 * the owner stops running or the state of the lock 		 * changes. 		 */
if|if
condition|(
operator|(
name|sx
operator|->
name|lock_object
operator|.
name|lo_flags
operator|&
name|SX_NOADAPTIVE
operator|)
operator|==
literal|0
condition|)
block|{
name|owner
operator|=
name|lv_sx_owner
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|TD_IS_RUNNING
argument_list|(
name|owner
argument_list|)
condition|)
block|{
if|if
condition|(
name|LOCK_LOG_TEST
argument_list|(
operator|&
name|sx
operator|->
name|lock_object
argument_list|,
literal|0
argument_list|)
condition|)
name|CTR3
argument_list|(
name|KTR_LOCK
argument_list|,
literal|"%s: spinning on %p held by %p"
argument_list|,
name|__func__
argument_list|,
name|sx
argument_list|,
name|owner
argument_list|)
expr_stmt|;
name|KTR_STATE1
argument_list|(
name|KTR_SCHED
argument_list|,
literal|"thread"
argument_list|,
name|sched_tdname
argument_list|(
name|curthread
argument_list|)
argument_list|,
literal|"spinning"
argument_list|,
literal|"lockname:\"%s\""
argument_list|,
name|sx
operator|->
name|lock_object
operator|.
name|lo_name
argument_list|)
expr_stmt|;
name|GIANT_SAVE
argument_list|(
name|extra_work
argument_list|)
expr_stmt|;
do|do
block|{
name|lock_delay
argument_list|(
operator|&
name|lda
argument_list|)
expr_stmt|;
name|x
operator|=
name|SX_READ_VALUE
argument_list|(
name|sx
argument_list|)
expr_stmt|;
name|owner
operator|=
name|lv_sx_owner
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|owner
operator|!=
name|NULL
operator|&&
name|TD_IS_RUNNING
argument_list|(
name|owner
argument_list|)
condition|)
do|;
name|KTR_STATE0
argument_list|(
name|KTR_SCHED
argument_list|,
literal|"thread"
argument_list|,
name|sched_tdname
argument_list|(
name|curthread
argument_list|)
argument_list|,
literal|"running"
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
endif|#
directive|endif
comment|/* 		 * Some other thread already has an exclusive lock, so 		 * start the process of blocking. 		 */
name|sleepq_lock
argument_list|(
operator|&
name|sx
operator|->
name|lock_object
argument_list|)
expr_stmt|;
name|x
operator|=
name|SX_READ_VALUE
argument_list|(
name|sx
argument_list|)
expr_stmt|;
comment|/* 		 * The lock could have been released while we spun. 		 * In this case loop back and retry. 		 */
if|if
condition|(
name|x
operator|&
name|SX_LOCK_SHARED
condition|)
block|{
name|sleepq_release
argument_list|(
operator|&
name|sx
operator|->
name|lock_object
argument_list|)
expr_stmt|;
continue|continue;
block|}
ifdef|#
directive|ifdef
name|ADAPTIVE_SX
comment|/* 		 * If the owner is running on another CPU, spin until 		 * the owner stops running or the state of the lock 		 * changes. 		 */
if|if
condition|(
operator|!
operator|(
name|x
operator|&
name|SX_LOCK_SHARED
operator|)
operator|&&
operator|(
name|sx
operator|->
name|lock_object
operator|.
name|lo_flags
operator|&
name|SX_NOADAPTIVE
operator|)
operator|==
literal|0
condition|)
block|{
name|owner
operator|=
operator|(
expr|struct
name|thread
operator|*
operator|)
name|SX_OWNER
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|TD_IS_RUNNING
argument_list|(
name|owner
argument_list|)
condition|)
block|{
name|sleepq_release
argument_list|(
operator|&
name|sx
operator|->
name|lock_object
argument_list|)
expr_stmt|;
name|x
operator|=
name|SX_READ_VALUE
argument_list|(
name|sx
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
endif|#
directive|endif
comment|/* 		 * Try to set the SX_LOCK_SHARED_WAITERS flag.  If we 		 * fail to set it drop the sleep queue lock and loop 		 * back. 		 */
if|if
condition|(
operator|!
operator|(
name|x
operator|&
name|SX_LOCK_SHARED_WAITERS
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|atomic_cmpset_ptr
argument_list|(
operator|&
name|sx
operator|->
name|sx_lock
argument_list|,
name|x
argument_list|,
name|x
operator||
name|SX_LOCK_SHARED_WAITERS
argument_list|)
condition|)
block|{
name|sleepq_release
argument_list|(
operator|&
name|sx
operator|->
name|lock_object
argument_list|)
expr_stmt|;
name|x
operator|=
name|SX_READ_VALUE
argument_list|(
name|sx
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|LOCK_LOG_TEST
argument_list|(
operator|&
name|sx
operator|->
name|lock_object
argument_list|,
literal|0
argument_list|)
condition|)
name|CTR2
argument_list|(
name|KTR_LOCK
argument_list|,
literal|"%s: %p set shared waiters flag"
argument_list|,
name|__func__
argument_list|,
name|sx
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Since we have been unable to acquire the shared lock, 		 * we have to sleep. 		 */
if|if
condition|(
name|LOCK_LOG_TEST
argument_list|(
operator|&
name|sx
operator|->
name|lock_object
argument_list|,
literal|0
argument_list|)
condition|)
name|CTR2
argument_list|(
name|KTR_LOCK
argument_list|,
literal|"%s: %p blocking on sleep queue"
argument_list|,
name|__func__
argument_list|,
name|sx
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|KDTRACE_HOOKS
name|sleep_time
operator|-=
name|lockstat_nsecs
argument_list|(
operator|&
name|sx
operator|->
name|lock_object
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|GIANT_SAVE
argument_list|(
name|extra_work
argument_list|)
expr_stmt|;
name|sleepq_add
argument_list|(
operator|&
name|sx
operator|->
name|lock_object
argument_list|,
name|NULL
argument_list|,
name|sx
operator|->
name|lock_object
operator|.
name|lo_name
argument_list|,
name|SLEEPQ_SX
operator||
operator|(
operator|(
name|opts
operator|&
name|SX_INTERRUPTIBLE
operator|)
condition|?
name|SLEEPQ_INTERRUPTIBLE
else|:
literal|0
operator|)
argument_list|,
name|SQ_SHARED_QUEUE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|opts
operator|&
name|SX_INTERRUPTIBLE
operator|)
condition|)
name|sleepq_wait
argument_list|(
operator|&
name|sx
operator|->
name|lock_object
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|error
operator|=
name|sleepq_wait_sig
argument_list|(
operator|&
name|sx
operator|->
name|lock_object
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|KDTRACE_HOOKS
name|sleep_time
operator|+=
name|lockstat_nsecs
argument_list|(
operator|&
name|sx
operator|->
name|lock_object
argument_list|)
expr_stmt|;
name|sleep_cnt
operator|++
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|error
condition|)
block|{
if|if
condition|(
name|LOCK_LOG_TEST
argument_list|(
operator|&
name|sx
operator|->
name|lock_object
argument_list|,
literal|0
argument_list|)
condition|)
name|CTR2
argument_list|(
name|KTR_LOCK
argument_list|,
literal|"%s: interruptible sleep by %p suspended by signal"
argument_list|,
name|__func__
argument_list|,
name|sx
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|LOCK_LOG_TEST
argument_list|(
operator|&
name|sx
operator|->
name|lock_object
argument_list|,
literal|0
argument_list|)
condition|)
name|CTR2
argument_list|(
name|KTR_LOCK
argument_list|,
literal|"%s: %p resuming from sleep queue"
argument_list|,
name|__func__
argument_list|,
name|sx
argument_list|)
expr_stmt|;
name|x
operator|=
name|SX_READ_VALUE
argument_list|(
name|sx
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|KDTRACE_HOOKS
argument_list|)
operator|||
name|defined
argument_list|(
name|LOCK_PROFILING
argument_list|)
if|if
condition|(
name|__predict_true
argument_list|(
operator|!
name|extra_work
argument_list|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|KDTRACE_HOOKS
name|all_time
operator|+=
name|lockstat_nsecs
argument_list|(
operator|&
name|sx
operator|->
name|lock_object
argument_list|)
expr_stmt|;
if|if
condition|(
name|sleep_time
condition|)
name|LOCKSTAT_RECORD4
argument_list|(
name|sx__block
argument_list|,
name|sx
argument_list|,
name|sleep_time
argument_list|,
name|LOCKSTAT_READER
argument_list|,
operator|(
name|state
operator|&
name|SX_LOCK_SHARED
operator|)
operator|==
literal|0
argument_list|,
operator|(
name|state
operator|&
name|SX_LOCK_SHARED
operator|)
operator|==
literal|0
condition|?
literal|0
else|:
name|SX_SHARERS
argument_list|(
name|state
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|lda
operator|.
name|spin_cnt
operator|>
name|sleep_cnt
condition|)
name|LOCKSTAT_RECORD4
argument_list|(
name|sx__spin
argument_list|,
name|sx
argument_list|,
name|all_time
operator|-
name|sleep_time
argument_list|,
name|LOCKSTAT_READER
argument_list|,
operator|(
name|state
operator|&
name|SX_LOCK_SHARED
operator|)
operator|==
literal|0
argument_list|,
operator|(
name|state
operator|&
name|SX_LOCK_SHARED
operator|)
operator|==
literal|0
condition|?
literal|0
else|:
name|SX_SHARERS
argument_list|(
name|state
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|LOCKSTAT_PROFILE_OBTAIN_RWLOCK_SUCCESS
argument_list|(
name|sx__acquire
argument_list|,
name|sx
argument_list|,
name|contested
argument_list|,
name|waittime
argument_list|,
name|file
argument_list|,
name|line
argument_list|,
name|LOCKSTAT_READER
argument_list|)
expr_stmt|;
block|}
name|GIANT_RESTORE
argument_list|()
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|_sx_slock_int
parameter_list|(
name|struct
name|sx
modifier|*
name|sx
parameter_list|,
name|int
name|opts
name|LOCK_FILE_LINE_ARG_DEF
parameter_list|)
block|{
name|uintptr_t
name|x
decl_stmt|;
name|int
name|error
decl_stmt|;
name|KASSERT
argument_list|(
name|kdb_active
operator|!=
literal|0
operator|||
name|SCHEDULER_STOPPED
argument_list|()
operator|||
operator|!
name|TD_IS_IDLETHREAD
argument_list|(
name|curthread
argument_list|)
argument_list|,
operator|(
literal|"sx_slock() by idle thread %p on sx %s @ %s:%d"
operator|,
name|curthread
operator|,
name|sx
operator|->
name|lock_object
operator|.
name|lo_name
operator|,
name|file
operator|,
name|line
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|sx
operator|->
name|sx_lock
operator|!=
name|SX_LOCK_DESTROYED
argument_list|,
operator|(
literal|"sx_slock() of destroyed sx @ %s:%d"
operator|,
name|file
operator|,
name|line
operator|)
argument_list|)
expr_stmt|;
name|WITNESS_CHECKORDER
argument_list|(
operator|&
name|sx
operator|->
name|lock_object
argument_list|,
name|LOP_NEWORDER
argument_list|,
name|file
argument_list|,
name|line
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|x
operator|=
name|SX_READ_VALUE
argument_list|(
name|sx
argument_list|)
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|LOCKSTAT_OOL_PROFILE_ENABLED
argument_list|(
name|sx__acquire
argument_list|)
operator|||
operator|!
name|__sx_slock_try
argument_list|(
argument|sx
argument_list|,
argument|&x LOCK_FILE_LINE_ARG
argument_list|)
argument_list|)
condition|)
name|error
operator|=
name|_sx_slock_hard
argument_list|(
argument|sx
argument_list|,
argument|opts
argument_list|,
argument|x LOCK_FILE_LINE_ARG
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|LOCK_LOG_LOCK
argument_list|(
literal|"SLOCK"
argument_list|,
operator|&
name|sx
operator|->
name|lock_object
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|WITNESS_LOCK
argument_list|(
operator|&
name|sx
operator|->
name|lock_object
argument_list|,
literal|0
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|TD_LOCKS_INC
argument_list|(
name|curthread
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|_sx_slock
parameter_list|(
name|struct
name|sx
modifier|*
name|sx
parameter_list|,
name|int
name|opts
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|)
block|{
return|return
operator|(
name|_sx_slock_int
argument_list|(
argument|sx
argument_list|,
argument|opts LOCK_FILE_LINE_ARG
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|__always_inline
name|_sx_sunlock_try
parameter_list|(
name|struct
name|sx
modifier|*
name|sx
parameter_list|,
name|uintptr_t
modifier|*
name|xp
parameter_list|)
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* 		 * We should never have sharers while at least one thread 		 * holds a shared lock. 		 */
name|KASSERT
argument_list|(
operator|!
operator|(
operator|*
name|xp
operator|&
name|SX_LOCK_SHARED_WAITERS
operator|)
argument_list|,
operator|(
literal|"%s: waiting sharers"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
comment|/* 		 * See if there is more than one shared lock held.  If 		 * so, just drop one and return. 		 */
if|if
condition|(
name|SX_SHARERS
argument_list|(
operator|*
name|xp
argument_list|)
operator|>
literal|1
condition|)
block|{
if|if
condition|(
name|atomic_fcmpset_rel_ptr
argument_list|(
operator|&
name|sx
operator|->
name|sx_lock
argument_list|,
name|xp
argument_list|,
operator|*
name|xp
operator|-
name|SX_ONE_SHARER
argument_list|)
condition|)
block|{
if|if
condition|(
name|LOCK_LOG_TEST
argument_list|(
operator|&
name|sx
operator|->
name|lock_object
argument_list|,
literal|0
argument_list|)
condition|)
name|CTR4
argument_list|(
name|KTR_LOCK
argument_list|,
literal|"%s: %p succeeded %p -> %p"
argument_list|,
name|__func__
argument_list|,
name|sx
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|*
name|xp
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
operator|*
name|xp
operator|-
name|SX_ONE_SHARER
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|true
operator|)
return|;
block|}
continue|continue;
block|}
comment|/* 		 * If there aren't any waiters for an exclusive lock, 		 * then try to drop it quickly. 		 */
if|if
condition|(
operator|!
operator|(
operator|*
name|xp
operator|&
name|SX_LOCK_EXCLUSIVE_WAITERS
operator|)
condition|)
block|{
name|MPASS
argument_list|(
operator|*
name|xp
operator|==
name|SX_SHARERS_LOCK
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|xp
operator|=
name|SX_SHARERS_LOCK
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|atomic_fcmpset_rel_ptr
argument_list|(
operator|&
name|sx
operator|->
name|sx_lock
argument_list|,
name|xp
argument_list|,
name|SX_LOCK_UNLOCKED
argument_list|)
condition|)
block|{
if|if
condition|(
name|LOCK_LOG_TEST
argument_list|(
operator|&
name|sx
operator|->
name|lock_object
argument_list|,
literal|0
argument_list|)
condition|)
name|CTR2
argument_list|(
name|KTR_LOCK
argument_list|,
literal|"%s: %p last succeeded"
argument_list|,
name|__func__
argument_list|,
name|sx
argument_list|)
expr_stmt|;
return|return
operator|(
name|true
operator|)
return|;
block|}
continue|continue;
block|}
break|break;
block|}
return|return
operator|(
name|false
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|__noinline
name|_sx_sunlock_hard
parameter_list|(
name|struct
name|sx
modifier|*
name|sx
parameter_list|,
name|uintptr_t
name|x
name|LOCK_FILE_LINE_ARG_DEF
parameter_list|)
block|{
name|int
name|wakeup_swapper
decl_stmt|;
if|if
condition|(
name|SCHEDULER_STOPPED
argument_list|()
condition|)
return|return;
name|LOCKSTAT_PROFILE_RELEASE_RWLOCK
argument_list|(
name|sx__release
argument_list|,
name|sx
argument_list|,
name|LOCKSTAT_READER
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|_sx_sunlock_try
argument_list|(
name|sx
argument_list|,
operator|&
name|x
argument_list|)
condition|)
break|break;
comment|/* 		 * At this point, there should just be one sharer with 		 * exclusive waiters. 		 */
name|MPASS
argument_list|(
name|x
operator|==
operator|(
name|SX_SHARERS_LOCK
argument_list|(
literal|1
argument_list|)
operator||
name|SX_LOCK_EXCLUSIVE_WAITERS
operator|)
argument_list|)
expr_stmt|;
name|sleepq_lock
argument_list|(
operator|&
name|sx
operator|->
name|lock_object
argument_list|)
expr_stmt|;
comment|/* 		 * Wake up semantic here is quite simple: 		 * Just wake up all the exclusive waiters. 		 * Note that the state of the lock could have changed, 		 * so if it fails loop back and retry. 		 */
if|if
condition|(
operator|!
name|atomic_cmpset_rel_ptr
argument_list|(
operator|&
name|sx
operator|->
name|sx_lock
argument_list|,
name|SX_SHARERS_LOCK
argument_list|(
literal|1
argument_list|)
operator||
name|SX_LOCK_EXCLUSIVE_WAITERS
argument_list|,
name|SX_LOCK_UNLOCKED
argument_list|)
condition|)
block|{
name|sleepq_release
argument_list|(
operator|&
name|sx
operator|->
name|lock_object
argument_list|)
expr_stmt|;
name|x
operator|=
name|SX_READ_VALUE
argument_list|(
name|sx
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|LOCK_LOG_TEST
argument_list|(
operator|&
name|sx
operator|->
name|lock_object
argument_list|,
literal|0
argument_list|)
condition|)
name|CTR2
argument_list|(
name|KTR_LOCK
argument_list|,
literal|"%s: %p waking up all thread on"
literal|"exclusive queue"
argument_list|,
name|__func__
argument_list|,
name|sx
argument_list|)
expr_stmt|;
name|wakeup_swapper
operator|=
name|sleepq_broadcast
argument_list|(
operator|&
name|sx
operator|->
name|lock_object
argument_list|,
name|SLEEPQ_SX
argument_list|,
literal|0
argument_list|,
name|SQ_EXCLUSIVE_QUEUE
argument_list|)
expr_stmt|;
name|sleepq_release
argument_list|(
operator|&
name|sx
operator|->
name|lock_object
argument_list|)
expr_stmt|;
if|if
condition|(
name|wakeup_swapper
condition|)
name|kick_proc0
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
name|void
name|_sx_sunlock_int
parameter_list|(
name|struct
name|sx
modifier|*
name|sx
name|LOCK_FILE_LINE_ARG_DEF
parameter_list|)
block|{
name|uintptr_t
name|x
decl_stmt|;
name|KASSERT
argument_list|(
name|sx
operator|->
name|sx_lock
operator|!=
name|SX_LOCK_DESTROYED
argument_list|,
operator|(
literal|"sx_sunlock() of destroyed sx @ %s:%d"
operator|,
name|file
operator|,
name|line
operator|)
argument_list|)
expr_stmt|;
name|_sx_assert
argument_list|(
name|sx
argument_list|,
name|SA_SLOCKED
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|WITNESS_UNLOCK
argument_list|(
operator|&
name|sx
operator|->
name|lock_object
argument_list|,
literal|0
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|LOCK_LOG_LOCK
argument_list|(
literal|"SUNLOCK"
argument_list|,
operator|&
name|sx
operator|->
name|lock_object
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|x
operator|=
name|SX_READ_VALUE
argument_list|(
name|sx
argument_list|)
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|LOCKSTAT_OOL_PROFILE_ENABLED
argument_list|(
name|sx__release
argument_list|)
operator|||
operator|!
name|_sx_sunlock_try
argument_list|(
name|sx
argument_list|,
operator|&
name|x
argument_list|)
argument_list|)
condition|)
name|_sx_sunlock_hard
argument_list|(
argument|sx
argument_list|,
argument|x LOCK_FILE_LINE_ARG
argument_list|)
empty_stmt|;
name|TD_LOCKS_DEC
argument_list|(
name|curthread
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|_sx_sunlock
parameter_list|(
name|struct
name|sx
modifier|*
name|sx
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|)
block|{
name|_sx_sunlock_int
argument_list|(
argument|sx LOCK_FILE_LINE_ARG
argument_list|)
empty_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|INVARIANT_SUPPORT
end_ifdef

begin_ifndef
ifndef|#
directive|ifndef
name|INVARIANTS
end_ifndef

begin_undef
undef|#
directive|undef
name|_sx_assert
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * In the non-WITNESS case, sx_assert() can only detect that at least  * *some* thread owns an slock, but it cannot guarantee that *this*  * thread owns an slock.  */
end_comment

begin_function
name|void
name|_sx_assert
parameter_list|(
specifier|const
name|struct
name|sx
modifier|*
name|sx
parameter_list|,
name|int
name|what
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|WITNESS
name|int
name|slocked
init|=
literal|0
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|panicstr
operator|!=
name|NULL
condition|)
return|return;
switch|switch
condition|(
name|what
condition|)
block|{
case|case
name|SA_SLOCKED
case|:
case|case
name|SA_SLOCKED
operator||
name|SA_NOTRECURSED
case|:
case|case
name|SA_SLOCKED
operator||
name|SA_RECURSED
case|:
ifndef|#
directive|ifndef
name|WITNESS
name|slocked
operator|=
literal|1
expr_stmt|;
comment|/* FALLTHROUGH */
endif|#
directive|endif
case|case
name|SA_LOCKED
case|:
case|case
name|SA_LOCKED
operator||
name|SA_NOTRECURSED
case|:
case|case
name|SA_LOCKED
operator||
name|SA_RECURSED
case|:
ifdef|#
directive|ifdef
name|WITNESS
name|witness_assert
argument_list|(
operator|&
name|sx
operator|->
name|lock_object
argument_list|,
name|what
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* 		 * If some other thread has an exclusive lock or we 		 * have one and are asserting a shared lock, fail. 		 * Also, if no one has a lock at all, fail. 		 */
if|if
condition|(
name|sx
operator|->
name|sx_lock
operator|==
name|SX_LOCK_UNLOCKED
operator|||
operator|(
operator|!
operator|(
name|sx
operator|->
name|sx_lock
operator|&
name|SX_LOCK_SHARED
operator|)
operator|&&
operator|(
name|slocked
operator|||
name|sx_xholder
argument_list|(
name|sx
argument_list|)
operator|!=
name|curthread
operator|)
operator|)
condition|)
name|panic
argument_list|(
literal|"Lock %s not %slocked @ %s:%d\n"
argument_list|,
name|sx
operator|->
name|lock_object
operator|.
name|lo_name
argument_list|,
name|slocked
condition|?
literal|"share "
else|:
literal|""
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|sx
operator|->
name|sx_lock
operator|&
name|SX_LOCK_SHARED
operator|)
condition|)
block|{
if|if
condition|(
name|sx_recursed
argument_list|(
name|sx
argument_list|)
condition|)
block|{
if|if
condition|(
name|what
operator|&
name|SA_NOTRECURSED
condition|)
name|panic
argument_list|(
literal|"Lock %s recursed @ %s:%d\n"
argument_list|,
name|sx
operator|->
name|lock_object
operator|.
name|lo_name
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|what
operator|&
name|SA_RECURSED
condition|)
name|panic
argument_list|(
literal|"Lock %s not recursed @ %s:%d\n"
argument_list|,
name|sx
operator|->
name|lock_object
operator|.
name|lo_name
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
break|break;
case|case
name|SA_XLOCKED
case|:
case|case
name|SA_XLOCKED
operator||
name|SA_NOTRECURSED
case|:
case|case
name|SA_XLOCKED
operator||
name|SA_RECURSED
case|:
if|if
condition|(
name|sx_xholder
argument_list|(
name|sx
argument_list|)
operator|!=
name|curthread
condition|)
name|panic
argument_list|(
literal|"Lock %s not exclusively locked @ %s:%d\n"
argument_list|,
name|sx
operator|->
name|lock_object
operator|.
name|lo_name
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|sx_recursed
argument_list|(
name|sx
argument_list|)
condition|)
block|{
if|if
condition|(
name|what
operator|&
name|SA_NOTRECURSED
condition|)
name|panic
argument_list|(
literal|"Lock %s recursed @ %s:%d\n"
argument_list|,
name|sx
operator|->
name|lock_object
operator|.
name|lo_name
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|what
operator|&
name|SA_RECURSED
condition|)
name|panic
argument_list|(
literal|"Lock %s not recursed @ %s:%d\n"
argument_list|,
name|sx
operator|->
name|lock_object
operator|.
name|lo_name
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
break|break;
case|case
name|SA_UNLOCKED
case|:
ifdef|#
directive|ifdef
name|WITNESS
name|witness_assert
argument_list|(
operator|&
name|sx
operator|->
name|lock_object
argument_list|,
name|what
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* 		 * If we hold an exclusve lock fail.  We can't 		 * reliably check to see if we hold a shared lock or 		 * not. 		 */
if|if
condition|(
name|sx_xholder
argument_list|(
name|sx
argument_list|)
operator|==
name|curthread
condition|)
name|panic
argument_list|(
literal|"Lock %s exclusively locked @ %s:%d\n"
argument_list|,
name|sx
operator|->
name|lock_object
operator|.
name|lo_name
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
default|default:
name|panic
argument_list|(
literal|"Unknown sx lock assertion: %d @ %s:%d"
argument_list|,
name|what
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* INVARIANT_SUPPORT */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|DDB
end_ifdef

begin_function
specifier|static
name|void
name|db_show_sx
parameter_list|(
specifier|const
name|struct
name|lock_object
modifier|*
name|lock
parameter_list|)
block|{
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
specifier|const
name|struct
name|sx
modifier|*
name|sx
decl_stmt|;
name|sx
operator|=
operator|(
specifier|const
expr|struct
name|sx
operator|*
operator|)
name|lock
expr_stmt|;
name|db_printf
argument_list|(
literal|" state: "
argument_list|)
expr_stmt|;
if|if
condition|(
name|sx
operator|->
name|sx_lock
operator|==
name|SX_LOCK_UNLOCKED
condition|)
name|db_printf
argument_list|(
literal|"UNLOCKED\n"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|sx
operator|->
name|sx_lock
operator|==
name|SX_LOCK_DESTROYED
condition|)
block|{
name|db_printf
argument_list|(
literal|"DESTROYED\n"
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|sx
operator|->
name|sx_lock
operator|&
name|SX_LOCK_SHARED
condition|)
name|db_printf
argument_list|(
literal|"SLOCK: %ju\n"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|SX_SHARERS
argument_list|(
name|sx
operator|->
name|sx_lock
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|td
operator|=
name|sx_xholder
argument_list|(
name|sx
argument_list|)
expr_stmt|;
name|db_printf
argument_list|(
literal|"XLOCK: %p (tid %d, pid %d, \"%s\")\n"
argument_list|,
name|td
argument_list|,
name|td
operator|->
name|td_tid
argument_list|,
name|td
operator|->
name|td_proc
operator|->
name|p_pid
argument_list|,
name|td
operator|->
name|td_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|sx_recursed
argument_list|(
name|sx
argument_list|)
condition|)
name|db_printf
argument_list|(
literal|" recursed: %d\n"
argument_list|,
name|sx
operator|->
name|sx_recurse
argument_list|)
expr_stmt|;
block|}
name|db_printf
argument_list|(
literal|" waiters: "
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|sx
operator|->
name|sx_lock
operator|&
operator|(
name|SX_LOCK_SHARED_WAITERS
operator||
name|SX_LOCK_EXCLUSIVE_WAITERS
operator|)
condition|)
block|{
case|case
name|SX_LOCK_SHARED_WAITERS
case|:
name|db_printf
argument_list|(
literal|"shared\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|SX_LOCK_EXCLUSIVE_WAITERS
case|:
name|db_printf
argument_list|(
literal|"exclusive\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|SX_LOCK_SHARED_WAITERS
operator||
name|SX_LOCK_EXCLUSIVE_WAITERS
case|:
name|db_printf
argument_list|(
literal|"exclusive and shared\n"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|db_printf
argument_list|(
literal|"none\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Check to see if a thread that is blocked on a sleep queue is actually  * blocked on an sx lock.  If so, output some details and return true.  * If the lock has an exclusive owner, return that in *ownerp.  */
end_comment

begin_function
name|int
name|sx_chain
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|thread
modifier|*
modifier|*
name|ownerp
parameter_list|)
block|{
name|struct
name|sx
modifier|*
name|sx
decl_stmt|;
comment|/* 	 * Check to see if this thread is blocked on an sx lock. 	 * First, we check the lock class.  If that is ok, then we 	 * compare the lock name against the wait message. 	 */
name|sx
operator|=
name|td
operator|->
name|td_wchan
expr_stmt|;
if|if
condition|(
name|LOCK_CLASS
argument_list|(
operator|&
name|sx
operator|->
name|lock_object
argument_list|)
operator|!=
operator|&
name|lock_class_sx
operator|||
name|sx
operator|->
name|lock_object
operator|.
name|lo_name
operator|!=
name|td
operator|->
name|td_wmesg
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* We think we have an sx lock, so output some details. */
name|db_printf
argument_list|(
literal|"blocked on sx \"%s\" "
argument_list|,
name|td
operator|->
name|td_wmesg
argument_list|)
expr_stmt|;
operator|*
name|ownerp
operator|=
name|sx_xholder
argument_list|(
name|sx
argument_list|)
expr_stmt|;
if|if
condition|(
name|sx
operator|->
name|sx_lock
operator|&
name|SX_LOCK_SHARED
condition|)
name|db_printf
argument_list|(
literal|"SLOCK (count %ju)\n"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|SX_SHARERS
argument_list|(
name|sx
operator|->
name|sx_lock
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|db_printf
argument_list|(
literal|"XLOCK\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

