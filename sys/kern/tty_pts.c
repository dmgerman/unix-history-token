begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2008 Ed Schouten<ed@FreeBSD.org>  * All rights reserved.  *  * Portions of this software were developed under sponsorship from Snow  * B.V., the Netherlands.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Add compatibility bits for FreeBSD. */
end_comment

begin_define
define|#
directive|define
name|PTS_COMPAT
end_define

begin_comment
comment|/* Add pty(4) compat bits. */
end_comment

begin_define
define|#
directive|define
name|PTS_EXTERNAL
end_define

begin_comment
comment|/* Add bits to make Linux binaries work. */
end_comment

begin_define
define|#
directive|define
name|PTS_LINUX
end_define

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/condvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/filedesc.h>
end_include

begin_include
include|#
directive|include
file|<sys/filio.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/limits.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/poll.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/racct.h>
end_include

begin_include
include|#
directive|include
file|<sys/resourcevar.h>
end_include

begin_include
include|#
directive|include
file|<sys/serial.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/syscall.h>
end_include

begin_include
include|#
directive|include
file|<sys/syscallsubr.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysent.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysproto.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/tty.h>
end_include

begin_include
include|#
directive|include
file|<sys/ttycom.h>
end_include

begin_include
include|#
directive|include
file|<sys/user.h>
end_include

begin_include
include|#
directive|include
file|<machine/stdarg.h>
end_include

begin_comment
comment|/*  * Our utmp(5) format is limited to 8-byte TTY line names.  This means  * we can at most allocate 1000 pseudo-terminals ("pts/999").  Allow  * users to increase this number, assuming they have manually increased  * UT_LINESIZE.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|unrhdr
modifier|*
name|pts_pool
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|static
name|MALLOC_DEFINE
argument_list|(
name|M_PTS
argument_list|,
literal|"pts"
argument_list|,
literal|"pseudo tty device"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Per-PTS structure.  *  * List of locks  * (t)	locked by tty_lock()  * (c)	const until freeing  */
end_comment

begin_struct
struct|struct
name|pts_softc
block|{
name|int
name|pts_unit
decl_stmt|;
comment|/* (c) Device unit number. */
name|unsigned
name|int
name|pts_flags
decl_stmt|;
comment|/* (t) Device flags. */
define|#
directive|define
name|PTS_PKT
value|0x1
comment|/* Packet mode. */
define|#
directive|define
name|PTS_FINISHED
value|0x2
comment|/* Return errors on read()/write(). */
name|char
name|pts_pkt
decl_stmt|;
comment|/* (t) Unread packet mode data. */
name|struct
name|cv
name|pts_inwait
decl_stmt|;
comment|/* (t) Blocking write() on master. */
name|struct
name|selinfo
name|pts_inpoll
decl_stmt|;
comment|/* (t) Select queue for write(). */
name|struct
name|cv
name|pts_outwait
decl_stmt|;
comment|/* (t) Blocking read() on master. */
name|struct
name|selinfo
name|pts_outpoll
decl_stmt|;
comment|/* (t) Select queue for read(). */
ifdef|#
directive|ifdef
name|PTS_EXTERNAL
name|struct
name|cdev
modifier|*
name|pts_cdev
decl_stmt|;
comment|/* (c) Master device node. */
endif|#
directive|endif
comment|/* PTS_EXTERNAL */
name|struct
name|ucred
modifier|*
name|pts_cred
decl_stmt|;
comment|/* (c) Resource limit. */
block|}
struct|;
end_struct

begin_comment
comment|/*  * Controller-side file operations.  */
end_comment

begin_function
specifier|static
name|int
name|ptsdev_read
parameter_list|(
name|struct
name|file
modifier|*
name|fp
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|,
name|struct
name|ucred
modifier|*
name|active_cred
parameter_list|,
name|int
name|flags
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|tty
modifier|*
name|tp
init|=
name|fp
operator|->
name|f_data
decl_stmt|;
name|struct
name|pts_softc
modifier|*
name|psc
init|=
name|tty_softc
argument_list|(
name|tp
argument_list|)
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|char
name|pkt
decl_stmt|;
if|if
condition|(
name|uio
operator|->
name|uio_resid
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|tty_lock
argument_list|(
name|tp
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* 		 * Implement packet mode. When packet mode is turned on, 		 * the first byte contains a bitmask of events that 		 * occurred (start, stop, flush, window size, etc). 		 */
if|if
condition|(
name|psc
operator|->
name|pts_flags
operator|&
name|PTS_PKT
operator|&&
name|psc
operator|->
name|pts_pkt
condition|)
block|{
name|pkt
operator|=
name|psc
operator|->
name|pts_pkt
expr_stmt|;
name|psc
operator|->
name|pts_pkt
operator|=
literal|0
expr_stmt|;
name|tty_unlock
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|error
operator|=
name|ureadc
argument_list|(
name|pkt
argument_list|,
name|uio
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* 		 * Transmit regular data. 		 * 		 * XXX: We shouldn't use ttydisc_getc_poll()! Even 		 * though in this implementation, there is likely going 		 * to be data, we should just call ttydisc_getc_uio() 		 * and use its return value to sleep. 		 */
if|if
condition|(
name|ttydisc_getc_poll
argument_list|(
name|tp
argument_list|)
condition|)
block|{
if|if
condition|(
name|psc
operator|->
name|pts_flags
operator|&
name|PTS_PKT
condition|)
block|{
comment|/* 				 * XXX: Small race. Fortunately PTY 				 * consumers aren't multithreaded. 				 */
name|tty_unlock
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|error
operator|=
name|ureadc
argument_list|(
name|TIOCPKT_DATA
argument_list|,
name|uio
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|tty_lock
argument_list|(
name|tp
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
name|ttydisc_getc_uio
argument_list|(
name|tp
argument_list|,
name|uio
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Maybe the device isn't used anyway. */
if|if
condition|(
name|psc
operator|->
name|pts_flags
operator|&
name|PTS_FINISHED
condition|)
break|break;
comment|/* Wait for more data. */
if|if
condition|(
name|fp
operator|->
name|f_flag
operator|&
name|O_NONBLOCK
condition|)
block|{
name|error
operator|=
name|EWOULDBLOCK
expr_stmt|;
break|break;
block|}
name|error
operator|=
name|cv_wait_sig
argument_list|(
operator|&
name|psc
operator|->
name|pts_outwait
argument_list|,
name|tp
operator|->
name|t_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
break|break;
block|}
name|tty_unlock
argument_list|(
name|tp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ptsdev_write
parameter_list|(
name|struct
name|file
modifier|*
name|fp
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|,
name|struct
name|ucred
modifier|*
name|active_cred
parameter_list|,
name|int
name|flags
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|tty
modifier|*
name|tp
init|=
name|fp
operator|->
name|f_data
decl_stmt|;
name|struct
name|pts_softc
modifier|*
name|psc
init|=
name|tty_softc
argument_list|(
name|tp
argument_list|)
decl_stmt|;
name|char
name|ib
index|[
literal|256
index|]
decl_stmt|,
modifier|*
name|ibstart
decl_stmt|;
name|size_t
name|iblen
decl_stmt|,
name|rintlen
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|uio
operator|->
name|uio_resid
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|ibstart
operator|=
name|ib
expr_stmt|;
name|iblen
operator|=
name|MIN
argument_list|(
name|uio
operator|->
name|uio_resid
argument_list|,
sizeof|sizeof
name|ib
argument_list|)
expr_stmt|;
name|error
operator|=
name|uiomove
argument_list|(
name|ib
argument_list|,
name|iblen
argument_list|,
name|uio
argument_list|)
expr_stmt|;
name|tty_lock
argument_list|(
name|tp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|iblen
operator|=
literal|0
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* 		 * When possible, avoid the slow path. rint_bypass() 		 * copies all input to the input queue at once. 		 */
name|MPASS
argument_list|(
name|iblen
operator|>
literal|0
argument_list|)
expr_stmt|;
do|do
block|{
name|rintlen
operator|=
name|ttydisc_rint_simple
argument_list|(
name|tp
argument_list|,
name|ibstart
argument_list|,
name|iblen
argument_list|)
expr_stmt|;
name|ibstart
operator|+=
name|rintlen
expr_stmt|;
name|iblen
operator|-=
name|rintlen
expr_stmt|;
if|if
condition|(
name|iblen
operator|==
literal|0
condition|)
block|{
comment|/* All data written. */
break|break;
block|}
comment|/* Maybe the device isn't used anyway. */
if|if
condition|(
name|psc
operator|->
name|pts_flags
operator|&
name|PTS_FINISHED
condition|)
block|{
name|error
operator|=
name|EIO
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* Wait for more data. */
if|if
condition|(
name|fp
operator|->
name|f_flag
operator|&
name|O_NONBLOCK
condition|)
block|{
name|error
operator|=
name|EWOULDBLOCK
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* Wake up users on the slave side. */
name|ttydisc_rint_done
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|error
operator|=
name|cv_wait_sig
argument_list|(
operator|&
name|psc
operator|->
name|pts_inwait
argument_list|,
name|tp
operator|->
name|t_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|done
goto|;
block|}
do|while
condition|(
name|iblen
operator|>
literal|0
condition|)
do|;
if|if
condition|(
name|uio
operator|->
name|uio_resid
operator|==
literal|0
condition|)
break|break;
name|tty_unlock
argument_list|(
name|tp
argument_list|)
expr_stmt|;
block|}
name|done
label|:
name|ttydisc_rint_done
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|tty_unlock
argument_list|(
name|tp
argument_list|)
expr_stmt|;
comment|/* 	 * Don't account for the part of the buffer that we couldn't 	 * pass to the TTY. 	 */
name|uio
operator|->
name|uio_resid
operator|+=
name|iblen
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ptsdev_ioctl
parameter_list|(
name|struct
name|file
modifier|*
name|fp
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|struct
name|ucred
modifier|*
name|active_cred
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|tty
modifier|*
name|tp
init|=
name|fp
operator|->
name|f_data
decl_stmt|;
name|struct
name|pts_softc
modifier|*
name|psc
init|=
name|tty_softc
argument_list|(
name|tp
argument_list|)
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|,
name|sig
decl_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|FIODTYPE
case|:
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|D_TTY
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|FIONBIO
case|:
comment|/* This device supports non-blocking operation. */
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|FIONREAD
case|:
name|tty_lock
argument_list|(
name|tp
argument_list|)
expr_stmt|;
if|if
condition|(
name|psc
operator|->
name|pts_flags
operator|&
name|PTS_FINISHED
condition|)
block|{
comment|/* Force read() to be called. */
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|ttydisc_getc_poll
argument_list|(
name|tp
argument_list|)
expr_stmt|;
block|}
name|tty_unlock
argument_list|(
name|tp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|FIODGNAME
case|:
block|{
name|struct
name|fiodgname_arg
modifier|*
name|fgn
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Reverse device name lookups, for ptsname() and ttyname(). */
name|fgn
operator|=
name|data
expr_stmt|;
name|p
operator|=
name|tty_devname
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|i
operator|=
name|strlen
argument_list|(
name|p
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|i
operator|>
name|fgn
operator|->
name|len
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
return|return
name|copyout
argument_list|(
name|p
argument_list|,
name|fgn
operator|->
name|buf
argument_list|,
name|i
argument_list|)
return|;
block|}
comment|/* 	 * We need to implement TIOCGPGRP and TIOCGSID here again. When 	 * called on the pseudo-terminal master, it should not check if 	 * the terminal is the foreground terminal of the calling 	 * process. 	 * 	 * TIOCGETA is also implemented here. Various Linux PTY routines 	 * often call isatty(), which is implemented by tcgetattr(). 	 */
ifdef|#
directive|ifdef
name|PTS_LINUX
case|case
name|TIOCGETA
case|:
comment|/* Obtain terminal flags through tcgetattr(). */
name|tty_lock
argument_list|(
name|tp
argument_list|)
expr_stmt|;
operator|*
operator|(
expr|struct
name|termios
operator|*
operator|)
name|data
operator|=
name|tp
operator|->
name|t_termios
expr_stmt|;
name|tty_unlock
argument_list|(
name|tp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
endif|#
directive|endif
comment|/* PTS_LINUX */
case|case
name|TIOCSETAF
case|:
case|case
name|TIOCSETAW
case|:
comment|/* 		 * We must make sure we turn tcsetattr() calls of TCSAFLUSH and 		 * TCSADRAIN into something different. If an application would 		 * call TCSAFLUSH or TCSADRAIN on the master descriptor, it may 		 * deadlock waiting for all data to be read. 		 */
name|cmd
operator|=
name|TIOCSETA
expr_stmt|;
break|break;
if|#
directive|if
name|defined
argument_list|(
name|PTS_COMPAT
argument_list|)
operator|||
name|defined
argument_list|(
name|PTS_LINUX
argument_list|)
case|case
name|TIOCGPTN
case|:
comment|/* 		 * Get the device unit number. 		 */
if|if
condition|(
name|psc
operator|->
name|pts_unit
operator|<
literal|0
condition|)
return|return
operator|(
name|ENOTTY
operator|)
return|;
operator|*
operator|(
name|unsigned
name|int
operator|*
operator|)
name|data
operator|=
name|psc
operator|->
name|pts_unit
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
endif|#
directive|endif
comment|/* PTS_COMPAT || PTS_LINUX */
case|case
name|TIOCGPGRP
case|:
comment|/* Get the foreground process group ID. */
name|tty_lock
argument_list|(
name|tp
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_pgrp
operator|!=
name|NULL
condition|)
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|tp
operator|->
name|t_pgrp
operator|->
name|pg_id
expr_stmt|;
else|else
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|NO_PID
expr_stmt|;
name|tty_unlock
argument_list|(
name|tp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|TIOCGSID
case|:
comment|/* Get the session leader process ID. */
name|tty_lock
argument_list|(
name|tp
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_session
operator|==
name|NULL
condition|)
name|error
operator|=
name|ENOTTY
expr_stmt|;
else|else
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|tp
operator|->
name|t_session
operator|->
name|s_sid
expr_stmt|;
name|tty_unlock
argument_list|(
name|tp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
case|case
name|TIOCPTMASTER
case|:
comment|/* Yes, we are a pseudo-terminal master. */
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|TIOCSIG
case|:
comment|/* Signal the foreground process group. */
name|sig
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
name|data
expr_stmt|;
if|if
condition|(
name|sig
operator|<
literal|1
operator|||
name|sig
operator|>=
name|NSIG
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|tty_lock
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|tty_signal_pgrp
argument_list|(
name|tp
argument_list|,
name|sig
argument_list|)
expr_stmt|;
name|tty_unlock
argument_list|(
name|tp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|TIOCPKT
case|:
comment|/* Enable/disable packet mode. */
name|tty_lock
argument_list|(
name|tp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
condition|)
name|psc
operator|->
name|pts_flags
operator||=
name|PTS_PKT
expr_stmt|;
else|else
name|psc
operator|->
name|pts_flags
operator|&=
operator|~
name|PTS_PKT
expr_stmt|;
name|tty_unlock
argument_list|(
name|tp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* Just redirect this ioctl to the slave device. */
name|tty_lock
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|error
operator|=
name|tty_ioctl
argument_list|(
name|tp
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|,
name|fp
operator|->
name|f_flag
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|tty_unlock
argument_list|(
name|tp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|ENOIOCTL
condition|)
name|error
operator|=
name|ENOTTY
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ptsdev_poll
parameter_list|(
name|struct
name|file
modifier|*
name|fp
parameter_list|,
name|int
name|events
parameter_list|,
name|struct
name|ucred
modifier|*
name|active_cred
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|tty
modifier|*
name|tp
init|=
name|fp
operator|->
name|f_data
decl_stmt|;
name|struct
name|pts_softc
modifier|*
name|psc
init|=
name|tty_softc
argument_list|(
name|tp
argument_list|)
decl_stmt|;
name|int
name|revents
init|=
literal|0
decl_stmt|;
name|tty_lock
argument_list|(
name|tp
argument_list|)
expr_stmt|;
if|if
condition|(
name|psc
operator|->
name|pts_flags
operator|&
name|PTS_FINISHED
condition|)
block|{
comment|/* Slave device is not opened. */
name|tty_unlock
argument_list|(
name|tp
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|events
operator|&
operator|(
name|POLLIN
operator||
name|POLLRDNORM
operator|)
operator|)
operator||
name|POLLHUP
operator|)
return|;
block|}
if|if
condition|(
name|events
operator|&
operator|(
name|POLLIN
operator||
name|POLLRDNORM
operator|)
condition|)
block|{
comment|/* See if we can getc something. */
if|if
condition|(
name|ttydisc_getc_poll
argument_list|(
name|tp
argument_list|)
operator|||
operator|(
name|psc
operator|->
name|pts_flags
operator|&
name|PTS_PKT
operator|&&
name|psc
operator|->
name|pts_pkt
operator|)
condition|)
name|revents
operator||=
name|events
operator|&
operator|(
name|POLLIN
operator||
name|POLLRDNORM
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|events
operator|&
operator|(
name|POLLOUT
operator||
name|POLLWRNORM
operator|)
condition|)
block|{
comment|/* See if we can rint something. */
if|if
condition|(
name|ttydisc_rint_poll
argument_list|(
name|tp
argument_list|)
condition|)
name|revents
operator||=
name|events
operator|&
operator|(
name|POLLOUT
operator||
name|POLLWRNORM
operator|)
expr_stmt|;
block|}
comment|/* 	 * No need to check for POLLHUP here. This device cannot be used 	 * as a callout device, which means we always have a carrier, 	 * because the master is. 	 */
if|if
condition|(
name|revents
operator|==
literal|0
condition|)
block|{
comment|/* 		 * This code might look misleading, but the naming of 		 * poll events on this side is the opposite of the slave 		 * device. 		 */
if|if
condition|(
name|events
operator|&
operator|(
name|POLLIN
operator||
name|POLLRDNORM
operator|)
condition|)
name|selrecord
argument_list|(
name|td
argument_list|,
operator|&
name|psc
operator|->
name|pts_outpoll
argument_list|)
expr_stmt|;
if|if
condition|(
name|events
operator|&
operator|(
name|POLLOUT
operator||
name|POLLWRNORM
operator|)
condition|)
name|selrecord
argument_list|(
name|td
argument_list|,
operator|&
name|psc
operator|->
name|pts_inpoll
argument_list|)
expr_stmt|;
block|}
name|tty_unlock
argument_list|(
name|tp
argument_list|)
expr_stmt|;
return|return
operator|(
name|revents
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * kqueue support.  */
end_comment

begin_function
specifier|static
name|void
name|pts_kqops_read_detach
parameter_list|(
name|struct
name|knote
modifier|*
name|kn
parameter_list|)
block|{
name|struct
name|file
modifier|*
name|fp
init|=
name|kn
operator|->
name|kn_fp
decl_stmt|;
name|struct
name|tty
modifier|*
name|tp
init|=
name|fp
operator|->
name|f_data
decl_stmt|;
name|struct
name|pts_softc
modifier|*
name|psc
init|=
name|tty_softc
argument_list|(
name|tp
argument_list|)
decl_stmt|;
name|knlist_remove
argument_list|(
operator|&
name|psc
operator|->
name|pts_outpoll
operator|.
name|si_note
argument_list|,
name|kn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|pts_kqops_read_event
parameter_list|(
name|struct
name|knote
modifier|*
name|kn
parameter_list|,
name|long
name|hint
parameter_list|)
block|{
name|struct
name|file
modifier|*
name|fp
init|=
name|kn
operator|->
name|kn_fp
decl_stmt|;
name|struct
name|tty
modifier|*
name|tp
init|=
name|fp
operator|->
name|f_data
decl_stmt|;
name|struct
name|pts_softc
modifier|*
name|psc
init|=
name|tty_softc
argument_list|(
name|tp
argument_list|)
decl_stmt|;
if|if
condition|(
name|psc
operator|->
name|pts_flags
operator|&
name|PTS_FINISHED
condition|)
block|{
name|kn
operator|->
name|kn_flags
operator||=
name|EV_EOF
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
else|else
block|{
name|kn
operator|->
name|kn_data
operator|=
name|ttydisc_getc_poll
argument_list|(
name|tp
argument_list|)
expr_stmt|;
return|return
operator|(
name|kn
operator|->
name|kn_data
operator|>
literal|0
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|pts_kqops_write_detach
parameter_list|(
name|struct
name|knote
modifier|*
name|kn
parameter_list|)
block|{
name|struct
name|file
modifier|*
name|fp
init|=
name|kn
operator|->
name|kn_fp
decl_stmt|;
name|struct
name|tty
modifier|*
name|tp
init|=
name|fp
operator|->
name|f_data
decl_stmt|;
name|struct
name|pts_softc
modifier|*
name|psc
init|=
name|tty_softc
argument_list|(
name|tp
argument_list|)
decl_stmt|;
name|knlist_remove
argument_list|(
operator|&
name|psc
operator|->
name|pts_inpoll
operator|.
name|si_note
argument_list|,
name|kn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|pts_kqops_write_event
parameter_list|(
name|struct
name|knote
modifier|*
name|kn
parameter_list|,
name|long
name|hint
parameter_list|)
block|{
name|struct
name|file
modifier|*
name|fp
init|=
name|kn
operator|->
name|kn_fp
decl_stmt|;
name|struct
name|tty
modifier|*
name|tp
init|=
name|fp
operator|->
name|f_data
decl_stmt|;
name|struct
name|pts_softc
modifier|*
name|psc
init|=
name|tty_softc
argument_list|(
name|tp
argument_list|)
decl_stmt|;
if|if
condition|(
name|psc
operator|->
name|pts_flags
operator|&
name|PTS_FINISHED
condition|)
block|{
name|kn
operator|->
name|kn_flags
operator||=
name|EV_EOF
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
else|else
block|{
name|kn
operator|->
name|kn_data
operator|=
name|ttydisc_rint_poll
argument_list|(
name|tp
argument_list|)
expr_stmt|;
return|return
operator|(
name|kn
operator|->
name|kn_data
operator|>
literal|0
operator|)
return|;
block|}
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|filterops
name|pts_kqops_read
init|=
block|{
operator|.
name|f_isfd
operator|=
literal|1
block|,
operator|.
name|f_detach
operator|=
name|pts_kqops_read_detach
block|,
operator|.
name|f_event
operator|=
name|pts_kqops_read_event
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|filterops
name|pts_kqops_write
init|=
block|{
operator|.
name|f_isfd
operator|=
literal|1
block|,
operator|.
name|f_detach
operator|=
name|pts_kqops_write_detach
block|,
operator|.
name|f_event
operator|=
name|pts_kqops_write_event
block|, }
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|ptsdev_kqfilter
parameter_list|(
name|struct
name|file
modifier|*
name|fp
parameter_list|,
name|struct
name|knote
modifier|*
name|kn
parameter_list|)
block|{
name|struct
name|tty
modifier|*
name|tp
init|=
name|fp
operator|->
name|f_data
decl_stmt|;
name|struct
name|pts_softc
modifier|*
name|psc
init|=
name|tty_softc
argument_list|(
name|tp
argument_list|)
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|tty_lock
argument_list|(
name|tp
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|kn
operator|->
name|kn_filter
condition|)
block|{
case|case
name|EVFILT_READ
case|:
name|kn
operator|->
name|kn_fop
operator|=
operator|&
name|pts_kqops_read
expr_stmt|;
name|knlist_add
argument_list|(
operator|&
name|psc
operator|->
name|pts_outpoll
operator|.
name|si_note
argument_list|,
name|kn
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|EVFILT_WRITE
case|:
name|kn
operator|->
name|kn_fop
operator|=
operator|&
name|pts_kqops_write
expr_stmt|;
name|knlist_add
argument_list|(
operator|&
name|psc
operator|->
name|pts_inpoll
operator|.
name|si_note
argument_list|,
name|kn
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|tty_unlock
argument_list|(
name|tp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ptsdev_stat
parameter_list|(
name|struct
name|file
modifier|*
name|fp
parameter_list|,
name|struct
name|stat
modifier|*
name|sb
parameter_list|,
name|struct
name|ucred
modifier|*
name|active_cred
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|tty
modifier|*
name|tp
init|=
name|fp
operator|->
name|f_data
decl_stmt|;
ifdef|#
directive|ifdef
name|PTS_EXTERNAL
name|struct
name|pts_softc
modifier|*
name|psc
init|=
name|tty_softc
argument_list|(
name|tp
argument_list|)
decl_stmt|;
endif|#
directive|endif
comment|/* PTS_EXTERNAL */
name|struct
name|cdev
modifier|*
name|dev
init|=
name|tp
operator|->
name|t_dev
decl_stmt|;
comment|/* 	 * According to POSIX, we must implement an fstat(). This also 	 * makes this implementation compatible with Linux binaries, 	 * because Linux calls fstat() on the pseudo-terminal master to 	 * obtain st_rdev. 	 * 	 * XXX: POSIX also mentions we must fill in st_dev, but how? 	 */
name|bzero
argument_list|(
name|sb
argument_list|,
sizeof|sizeof
expr|*
name|sb
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PTS_EXTERNAL
if|if
condition|(
name|psc
operator|->
name|pts_cdev
operator|!=
name|NULL
condition|)
name|sb
operator|->
name|st_ino
operator|=
name|sb
operator|->
name|st_rdev
operator|=
name|dev2udev
argument_list|(
name|psc
operator|->
name|pts_cdev
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
comment|/* PTS_EXTERNAL */
name|sb
operator|->
name|st_ino
operator|=
name|sb
operator|->
name|st_rdev
operator|=
name|tty_udev
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|sb
operator|->
name|st_atim
operator|=
name|dev
operator|->
name|si_atime
expr_stmt|;
name|sb
operator|->
name|st_ctim
operator|=
name|dev
operator|->
name|si_ctime
expr_stmt|;
name|sb
operator|->
name|st_mtim
operator|=
name|dev
operator|->
name|si_mtime
expr_stmt|;
name|sb
operator|->
name|st_uid
operator|=
name|dev
operator|->
name|si_uid
expr_stmt|;
name|sb
operator|->
name|st_gid
operator|=
name|dev
operator|->
name|si_gid
expr_stmt|;
name|sb
operator|->
name|st_mode
operator|=
name|dev
operator|->
name|si_mode
operator||
name|S_IFCHR
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ptsdev_close
parameter_list|(
name|struct
name|file
modifier|*
name|fp
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|tty
modifier|*
name|tp
init|=
name|fp
operator|->
name|f_data
decl_stmt|;
comment|/* Deallocate TTY device. */
name|tty_lock
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|tty_rel_gone
argument_list|(
name|tp
argument_list|)
expr_stmt|;
comment|/* 	 * Open of /dev/ptmx or /dev/ptyXX changes the type of file 	 * from DTYPE_VNODE to DTYPE_PTS. vn_open() increases vnode 	 * use count, we need to decrement it, and possibly do other 	 * required cleanup. 	 */
if|if
condition|(
name|fp
operator|->
name|f_vnode
operator|!=
name|NULL
condition|)
return|return
operator|(
name|vnops
operator|.
name|fo_close
argument_list|(
name|fp
argument_list|,
name|td
argument_list|)
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ptsdev_fill_kinfo
parameter_list|(
name|struct
name|file
modifier|*
name|fp
parameter_list|,
name|struct
name|kinfo_file
modifier|*
name|kif
parameter_list|,
name|struct
name|filedesc
modifier|*
name|fdp
parameter_list|)
block|{
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
name|kif
operator|->
name|kf_type
operator|=
name|KF_TYPE_PTS
expr_stmt|;
name|tp
operator|=
name|fp
operator|->
name|f_data
expr_stmt|;
name|kif
operator|->
name|kf_un
operator|.
name|kf_pts
operator|.
name|kf_pts_dev
operator|=
name|tty_udev
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|kif
operator|->
name|kf_un
operator|.
name|kf_pts
operator|.
name|kf_pts_dev_freebsd11
operator|=
name|kif
operator|->
name|kf_un
operator|.
name|kf_pts
operator|.
name|kf_pts_dev
expr_stmt|;
comment|/* truncate */
name|strlcpy
argument_list|(
name|kif
operator|->
name|kf_path
argument_list|,
name|tty_devname
argument_list|(
name|tp
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|kif
operator|->
name|kf_path
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|fileops
name|ptsdev_ops
init|=
block|{
operator|.
name|fo_read
operator|=
name|ptsdev_read
block|,
operator|.
name|fo_write
operator|=
name|ptsdev_write
block|,
operator|.
name|fo_truncate
operator|=
name|invfo_truncate
block|,
operator|.
name|fo_ioctl
operator|=
name|ptsdev_ioctl
block|,
operator|.
name|fo_poll
operator|=
name|ptsdev_poll
block|,
operator|.
name|fo_kqfilter
operator|=
name|ptsdev_kqfilter
block|,
operator|.
name|fo_stat
operator|=
name|ptsdev_stat
block|,
operator|.
name|fo_close
operator|=
name|ptsdev_close
block|,
operator|.
name|fo_chmod
operator|=
name|invfo_chmod
block|,
operator|.
name|fo_chown
operator|=
name|invfo_chown
block|,
operator|.
name|fo_sendfile
operator|=
name|invfo_sendfile
block|,
operator|.
name|fo_fill_kinfo
operator|=
name|ptsdev_fill_kinfo
block|,
operator|.
name|fo_flags
operator|=
name|DFLAG_PASSABLE
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Driver-side hooks.  */
end_comment

begin_function
specifier|static
name|void
name|ptsdrv_outwakeup
parameter_list|(
name|struct
name|tty
modifier|*
name|tp
parameter_list|)
block|{
name|struct
name|pts_softc
modifier|*
name|psc
init|=
name|tty_softc
argument_list|(
name|tp
argument_list|)
decl_stmt|;
name|cv_broadcast
argument_list|(
operator|&
name|psc
operator|->
name|pts_outwait
argument_list|)
expr_stmt|;
name|selwakeup
argument_list|(
operator|&
name|psc
operator|->
name|pts_outpoll
argument_list|)
expr_stmt|;
name|KNOTE_LOCKED
argument_list|(
operator|&
name|psc
operator|->
name|pts_outpoll
operator|.
name|si_note
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ptsdrv_inwakeup
parameter_list|(
name|struct
name|tty
modifier|*
name|tp
parameter_list|)
block|{
name|struct
name|pts_softc
modifier|*
name|psc
init|=
name|tty_softc
argument_list|(
name|tp
argument_list|)
decl_stmt|;
name|cv_broadcast
argument_list|(
operator|&
name|psc
operator|->
name|pts_inwait
argument_list|)
expr_stmt|;
name|selwakeup
argument_list|(
operator|&
name|psc
operator|->
name|pts_inpoll
argument_list|)
expr_stmt|;
name|KNOTE_LOCKED
argument_list|(
operator|&
name|psc
operator|->
name|pts_inpoll
operator|.
name|si_note
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|ptsdrv_open
parameter_list|(
name|struct
name|tty
modifier|*
name|tp
parameter_list|)
block|{
name|struct
name|pts_softc
modifier|*
name|psc
init|=
name|tty_softc
argument_list|(
name|tp
argument_list|)
decl_stmt|;
name|psc
operator|->
name|pts_flags
operator|&=
operator|~
name|PTS_FINISHED
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ptsdrv_close
parameter_list|(
name|struct
name|tty
modifier|*
name|tp
parameter_list|)
block|{
name|struct
name|pts_softc
modifier|*
name|psc
init|=
name|tty_softc
argument_list|(
name|tp
argument_list|)
decl_stmt|;
comment|/* Wake up any blocked readers/writers. */
name|psc
operator|->
name|pts_flags
operator||=
name|PTS_FINISHED
expr_stmt|;
name|ptsdrv_outwakeup
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|ptsdrv_inwakeup
argument_list|(
name|tp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ptsdrv_pktnotify
parameter_list|(
name|struct
name|tty
modifier|*
name|tp
parameter_list|,
name|char
name|event
parameter_list|)
block|{
name|struct
name|pts_softc
modifier|*
name|psc
init|=
name|tty_softc
argument_list|(
name|tp
argument_list|)
decl_stmt|;
comment|/* 	 * Clear conflicting flags. 	 */
switch|switch
condition|(
name|event
condition|)
block|{
case|case
name|TIOCPKT_STOP
case|:
name|psc
operator|->
name|pts_pkt
operator|&=
operator|~
name|TIOCPKT_START
expr_stmt|;
break|break;
case|case
name|TIOCPKT_START
case|:
name|psc
operator|->
name|pts_pkt
operator|&=
operator|~
name|TIOCPKT_STOP
expr_stmt|;
break|break;
case|case
name|TIOCPKT_NOSTOP
case|:
name|psc
operator|->
name|pts_pkt
operator|&=
operator|~
name|TIOCPKT_DOSTOP
expr_stmt|;
break|break;
case|case
name|TIOCPKT_DOSTOP
case|:
name|psc
operator|->
name|pts_pkt
operator|&=
operator|~
name|TIOCPKT_NOSTOP
expr_stmt|;
break|break;
block|}
name|psc
operator|->
name|pts_pkt
operator||=
name|event
expr_stmt|;
name|ptsdrv_outwakeup
argument_list|(
name|tp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ptsdrv_free
parameter_list|(
name|void
modifier|*
name|softc
parameter_list|)
block|{
name|struct
name|pts_softc
modifier|*
name|psc
init|=
name|softc
decl_stmt|;
comment|/* Make device number available again. */
if|if
condition|(
name|psc
operator|->
name|pts_unit
operator|>=
literal|0
condition|)
name|free_unr
argument_list|(
name|pts_pool
argument_list|,
name|psc
operator|->
name|pts_unit
argument_list|)
expr_stmt|;
name|chgptscnt
argument_list|(
name|psc
operator|->
name|pts_cred
operator|->
name|cr_ruidinfo
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|racct_sub_cred
argument_list|(
name|psc
operator|->
name|pts_cred
argument_list|,
name|RACCT_NPTS
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|crfree
argument_list|(
name|psc
operator|->
name|pts_cred
argument_list|)
expr_stmt|;
name|seldrain
argument_list|(
operator|&
name|psc
operator|->
name|pts_inpoll
argument_list|)
expr_stmt|;
name|seldrain
argument_list|(
operator|&
name|psc
operator|->
name|pts_outpoll
argument_list|)
expr_stmt|;
name|knlist_destroy
argument_list|(
operator|&
name|psc
operator|->
name|pts_inpoll
operator|.
name|si_note
argument_list|)
expr_stmt|;
name|knlist_destroy
argument_list|(
operator|&
name|psc
operator|->
name|pts_outpoll
operator|.
name|si_note
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PTS_EXTERNAL
comment|/* Destroy master device as well. */
if|if
condition|(
name|psc
operator|->
name|pts_cdev
operator|!=
name|NULL
condition|)
name|destroy_dev_sched
argument_list|(
name|psc
operator|->
name|pts_cdev
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* PTS_EXTERNAL */
name|free
argument_list|(
name|psc
argument_list|,
name|M_PTS
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|ttydevsw
name|pts_class
init|=
block|{
operator|.
name|tsw_flags
operator|=
name|TF_NOPREFIX
block|,
operator|.
name|tsw_outwakeup
operator|=
name|ptsdrv_outwakeup
block|,
operator|.
name|tsw_inwakeup
operator|=
name|ptsdrv_inwakeup
block|,
operator|.
name|tsw_open
operator|=
name|ptsdrv_open
block|,
operator|.
name|tsw_close
operator|=
name|ptsdrv_close
block|,
operator|.
name|tsw_pktnotify
operator|=
name|ptsdrv_pktnotify
block|,
operator|.
name|tsw_free
operator|=
name|ptsdrv_free
block|, }
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|PTS_EXTERNAL
end_ifndef

begin_function
specifier|static
endif|#
directive|endif
comment|/* !PTS_EXTERNAL */
name|int
name|pts_alloc
parameter_list|(
name|int
name|fflags
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|file
modifier|*
name|fp
parameter_list|)
block|{
name|int
name|unit
decl_stmt|,
name|ok
decl_stmt|,
name|error
decl_stmt|;
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
name|struct
name|pts_softc
modifier|*
name|psc
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
init|=
name|td
operator|->
name|td_proc
decl_stmt|;
name|struct
name|ucred
modifier|*
name|cred
init|=
name|td
operator|->
name|td_ucred
decl_stmt|;
comment|/* Resource limiting. */
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|error
operator|=
name|racct_add
argument_list|(
name|p
argument_list|,
name|RACCT_NPTS
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
name|EAGAIN
operator|)
return|;
block|}
name|ok
operator|=
name|chgptscnt
argument_list|(
name|cred
operator|->
name|cr_ruidinfo
argument_list|,
literal|1
argument_list|,
name|lim_cur
argument_list|(
name|td
argument_list|,
name|RLIMIT_NPTS
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ok
condition|)
block|{
name|racct_sub
argument_list|(
name|p
argument_list|,
name|RACCT_NPTS
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
name|EAGAIN
operator|)
return|;
block|}
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* Try to allocate a new pts unit number. */
name|unit
operator|=
name|alloc_unr
argument_list|(
name|pts_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|unit
operator|<
literal|0
condition|)
block|{
name|racct_sub
argument_list|(
name|p
argument_list|,
name|RACCT_NPTS
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|chgptscnt
argument_list|(
name|cred
operator|->
name|cr_ruidinfo
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|EAGAIN
operator|)
return|;
block|}
comment|/* Allocate TTY and softc. */
name|psc
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|pts_softc
argument_list|)
argument_list|,
name|M_PTS
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|cv_init
argument_list|(
operator|&
name|psc
operator|->
name|pts_inwait
argument_list|,
literal|"ptsin"
argument_list|)
expr_stmt|;
name|cv_init
argument_list|(
operator|&
name|psc
operator|->
name|pts_outwait
argument_list|,
literal|"ptsout"
argument_list|)
expr_stmt|;
name|psc
operator|->
name|pts_unit
operator|=
name|unit
expr_stmt|;
name|psc
operator|->
name|pts_cred
operator|=
name|crhold
argument_list|(
name|cred
argument_list|)
expr_stmt|;
name|tp
operator|=
name|tty_alloc
argument_list|(
operator|&
name|pts_class
argument_list|,
name|psc
argument_list|)
expr_stmt|;
name|knlist_init_mtx
argument_list|(
operator|&
name|psc
operator|->
name|pts_inpoll
operator|.
name|si_note
argument_list|,
name|tp
operator|->
name|t_mtx
argument_list|)
expr_stmt|;
name|knlist_init_mtx
argument_list|(
operator|&
name|psc
operator|->
name|pts_outpoll
operator|.
name|si_note
argument_list|,
name|tp
operator|->
name|t_mtx
argument_list|)
expr_stmt|;
comment|/* Expose the slave device as well. */
name|tty_makedev
argument_list|(
name|tp
argument_list|,
name|td
operator|->
name|td_ucred
argument_list|,
literal|"pts/%u"
argument_list|,
name|psc
operator|->
name|pts_unit
argument_list|)
expr_stmt|;
name|finit
argument_list|(
name|fp
argument_list|,
name|fflags
argument_list|,
name|DTYPE_PTS
argument_list|,
name|tp
argument_list|,
operator|&
name|ptsdev_ops
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|PTS_EXTERNAL
end_ifdef

begin_function
name|int
name|pts_alloc_external
parameter_list|(
name|int
name|fflags
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|file
modifier|*
name|fp
parameter_list|,
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|int
name|ok
decl_stmt|,
name|error
decl_stmt|;
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
name|struct
name|pts_softc
modifier|*
name|psc
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
init|=
name|td
operator|->
name|td_proc
decl_stmt|;
name|struct
name|ucred
modifier|*
name|cred
init|=
name|td
operator|->
name|td_ucred
decl_stmt|;
comment|/* Resource limiting. */
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|error
operator|=
name|racct_add
argument_list|(
name|p
argument_list|,
name|RACCT_NPTS
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
name|EAGAIN
operator|)
return|;
block|}
name|ok
operator|=
name|chgptscnt
argument_list|(
name|cred
operator|->
name|cr_ruidinfo
argument_list|,
literal|1
argument_list|,
name|lim_cur
argument_list|(
name|td
argument_list|,
name|RLIMIT_NPTS
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ok
condition|)
block|{
name|racct_sub
argument_list|(
name|p
argument_list|,
name|RACCT_NPTS
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
name|EAGAIN
operator|)
return|;
block|}
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* Allocate TTY and softc. */
name|psc
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|pts_softc
argument_list|)
argument_list|,
name|M_PTS
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|cv_init
argument_list|(
operator|&
name|psc
operator|->
name|pts_inwait
argument_list|,
literal|"ptsin"
argument_list|)
expr_stmt|;
name|cv_init
argument_list|(
operator|&
name|psc
operator|->
name|pts_outwait
argument_list|,
literal|"ptsout"
argument_list|)
expr_stmt|;
name|psc
operator|->
name|pts_unit
operator|=
operator|-
literal|1
expr_stmt|;
name|psc
operator|->
name|pts_cdev
operator|=
name|dev
expr_stmt|;
name|psc
operator|->
name|pts_cred
operator|=
name|crhold
argument_list|(
name|cred
argument_list|)
expr_stmt|;
name|tp
operator|=
name|tty_alloc
argument_list|(
operator|&
name|pts_class
argument_list|,
name|psc
argument_list|)
expr_stmt|;
name|knlist_init_mtx
argument_list|(
operator|&
name|psc
operator|->
name|pts_inpoll
operator|.
name|si_note
argument_list|,
name|tp
operator|->
name|t_mtx
argument_list|)
expr_stmt|;
name|knlist_init_mtx
argument_list|(
operator|&
name|psc
operator|->
name|pts_outpoll
operator|.
name|si_note
argument_list|,
name|tp
operator|->
name|t_mtx
argument_list|)
expr_stmt|;
comment|/* Expose the slave device as well. */
name|tty_makedev
argument_list|(
name|tp
argument_list|,
name|td
operator|->
name|td_ucred
argument_list|,
literal|"%s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|finit
argument_list|(
name|fp
argument_list|,
name|fflags
argument_list|,
name|DTYPE_PTS
argument_list|,
name|tp
argument_list|,
operator|&
name|ptsdev_ops
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* PTS_EXTERNAL */
end_comment

begin_function
name|int
name|sys_posix_openpt
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|posix_openpt_args
modifier|*
name|uap
parameter_list|)
block|{
name|int
name|error
decl_stmt|,
name|fd
decl_stmt|;
name|struct
name|file
modifier|*
name|fp
decl_stmt|;
comment|/* 	 * POSIX states it's unspecified when other flags are passed. We 	 * don't allow this. 	 */
if|if
condition|(
name|uap
operator|->
name|flags
operator|&
operator|~
operator|(
name|O_RDWR
operator||
name|O_NOCTTY
operator||
name|O_CLOEXEC
operator|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|error
operator|=
name|falloc
argument_list|(
name|td
argument_list|,
operator|&
name|fp
argument_list|,
operator|&
name|fd
argument_list|,
name|uap
operator|->
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* Allocate the actual pseudo-TTY. */
name|error
operator|=
name|pts_alloc
argument_list|(
name|FFLAGS
argument_list|(
name|uap
operator|->
name|flags
operator|&
name|O_ACCMODE
argument_list|)
argument_list|,
name|td
argument_list|,
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|fdclose
argument_list|(
name|td
argument_list|,
name|fp
argument_list|,
name|fd
argument_list|)
expr_stmt|;
name|fdrop
argument_list|(
name|fp
argument_list|,
name|td
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* Pass it back to userspace. */
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|=
name|fd
expr_stmt|;
name|fdrop
argument_list|(
name|fp
argument_list|,
name|td
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|pts_init
parameter_list|(
name|void
modifier|*
name|unused
parameter_list|)
block|{
name|pts_pool
operator|=
name|new_unrhdr
argument_list|(
literal|0
argument_list|,
name|INT_MAX
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|SYSINIT
argument_list|(
name|pts
argument_list|,
name|SI_SUB_DRIVERS
argument_list|,
name|SI_ORDER_MIDDLE
argument_list|,
name|pts_init
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

