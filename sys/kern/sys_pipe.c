begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1996 John S. Dyson  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice immediately at the beginning of the file, without modification,  *    this list of conditions, and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. Absolutely no warranty of function or purpose is made by the author  *    John S. Dyson.  * 4. This work was done expressly for inclusion into FreeBSD.  Other use  *    is allowed if this notation is included.  * 5. Modifications may be freely made to this file if the above conditions  *    are met.  *  * $Id$  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|OLD_PIPE
end_ifndef

begin_comment
comment|/*  * This file contains a high-performance replacement for the socket-based  * pipes scheme originally used in FreeBSD/4.4Lite.  It does not support  * all features of sockets, but does do everything that pipes normally  * do.  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/protosw.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/filedesc.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/select.h>
end_include

begin_include
include|#
directive|include
file|<sys/signalvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/vmmeter.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysproto.h>
end_include

begin_include
include|#
directive|include
file|<sys/pipe.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_prot.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_param.h>
end_include

begin_include
include|#
directive|include
file|<vm/lock.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_object.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_kern.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_extern.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_map.h>
end_include

begin_decl_stmt
specifier|static
name|int
name|pipe_read
name|__P
argument_list|(
operator|(
expr|struct
name|file
operator|*
name|fp
operator|,
expr|struct
name|uio
operator|*
name|uio
operator|,
expr|struct
name|ucred
operator|*
name|cred
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|pipe_write
name|__P
argument_list|(
operator|(
expr|struct
name|file
operator|*
name|fp
operator|,
expr|struct
name|uio
operator|*
name|uio
operator|,
expr|struct
name|ucred
operator|*
name|cred
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|pipe_close
name|__P
argument_list|(
operator|(
expr|struct
name|file
operator|*
name|fp
operator|,
expr|struct
name|proc
operator|*
name|p
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|pipe_select
name|__P
argument_list|(
operator|(
expr|struct
name|file
operator|*
name|fp
operator|,
name|int
name|which
operator|,
expr|struct
name|proc
operator|*
name|p
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|pipe_ioctl
name|__P
argument_list|(
operator|(
expr|struct
name|file
operator|*
name|fp
operator|,
name|int
name|cmd
operator|,
name|caddr_t
name|data
operator|,
expr|struct
name|proc
operator|*
name|p
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|fileops
name|pipeops
init|=
block|{
name|pipe_read
block|,
name|pipe_write
block|,
name|pipe_ioctl
block|,
name|pipe_select
block|,
name|pipe_close
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Default pipe buffer size(s), this can be kind-of large now because pipe  * space is pageable.  The pipe code will try to maintain locality of  * reference for performance reasons, so small amounts of outstanding I/O  * will not wipe the cache.  */
end_comment

begin_define
define|#
directive|define
name|PIPESIZE
value|(16384)
end_define

begin_define
define|#
directive|define
name|MINPIPESIZE
value|(PIPESIZE/3)
end_define

begin_define
define|#
directive|define
name|MAXPIPESIZE
value|(2*PIPESIZE/3)
end_define

begin_decl_stmt
specifier|static
name|void
name|pipeclose
name|__P
argument_list|(
operator|(
expr|struct
name|pipe
operator|*
name|cpipe
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|pipebufferinit
name|__P
argument_list|(
operator|(
expr|struct
name|pipe
operator|*
name|cpipe
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|pipeinit
name|__P
argument_list|(
operator|(
expr|struct
name|pipe
operator|*
name|cpipe
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|__inline
name|int
name|pipelock
name|__P
argument_list|(
operator|(
expr|struct
name|pipe
operator|*
name|cpipe
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|__inline
name|void
name|pipeunlock
name|__P
argument_list|(
operator|(
expr|struct
name|pipe
operator|*
name|cpipe
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * The pipe system call for the DTYPE_PIPE type of pipes  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|pipe
parameter_list|(
name|p
parameter_list|,
name|uap
parameter_list|,
name|retval
parameter_list|)
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|struct
name|pipe_args
comment|/* { 		int	dummy; 	} */
modifier|*
name|uap
decl_stmt|;
name|int
name|retval
index|[]
decl_stmt|;
block|{
specifier|register
name|struct
name|filedesc
modifier|*
name|fdp
init|=
name|p
operator|->
name|p_fd
decl_stmt|;
name|struct
name|file
modifier|*
name|rf
decl_stmt|,
modifier|*
name|wf
decl_stmt|;
name|struct
name|pipe
modifier|*
name|rpipe
decl_stmt|,
modifier|*
name|wpipe
decl_stmt|;
name|int
name|fd
decl_stmt|,
name|error
decl_stmt|;
name|rpipe
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|rpipe
argument_list|)
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|pipeinit
argument_list|(
name|rpipe
argument_list|)
expr_stmt|;
name|wpipe
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|wpipe
argument_list|)
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|pipeinit
argument_list|(
name|wpipe
argument_list|)
expr_stmt|;
name|error
operator|=
name|falloc
argument_list|(
name|p
argument_list|,
operator|&
name|rf
argument_list|,
operator|&
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|free2
goto|;
name|retval
index|[
literal|0
index|]
operator|=
name|fd
expr_stmt|;
name|rf
operator|->
name|f_flag
operator|=
name|FREAD
operator||
name|FWRITE
expr_stmt|;
name|rf
operator|->
name|f_type
operator|=
name|DTYPE_PIPE
expr_stmt|;
name|rf
operator|->
name|f_ops
operator|=
operator|&
name|pipeops
expr_stmt|;
name|rf
operator|->
name|f_data
operator|=
operator|(
name|caddr_t
operator|)
name|rpipe
expr_stmt|;
name|error
operator|=
name|falloc
argument_list|(
name|p
argument_list|,
operator|&
name|wf
argument_list|,
operator|&
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|free3
goto|;
name|wf
operator|->
name|f_flag
operator|=
name|FREAD
operator||
name|FWRITE
expr_stmt|;
name|wf
operator|->
name|f_type
operator|=
name|DTYPE_PIPE
expr_stmt|;
name|wf
operator|->
name|f_ops
operator|=
operator|&
name|pipeops
expr_stmt|;
name|wf
operator|->
name|f_data
operator|=
operator|(
name|caddr_t
operator|)
name|wpipe
expr_stmt|;
name|retval
index|[
literal|1
index|]
operator|=
name|fd
expr_stmt|;
name|rpipe
operator|->
name|pipe_peer
operator|=
name|wpipe
expr_stmt|;
name|wpipe
operator|->
name|pipe_peer
operator|=
name|rpipe
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|free3
label|:
name|ffree
argument_list|(
name|rf
argument_list|)
expr_stmt|;
name|fdp
operator|->
name|fd_ofiles
index|[
name|retval
index|[
literal|0
index|]
index|]
operator|=
literal|0
expr_stmt|;
name|free2
label|:
operator|(
name|void
operator|)
name|pipeclose
argument_list|(
name|wpipe
argument_list|)
expr_stmt|;
name|free1
label|:
operator|(
name|void
operator|)
name|pipeclose
argument_list|(
name|rpipe
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * initialize and allocate VM and memory for pipe  */
end_comment

begin_function
specifier|static
name|void
name|pipeinit
parameter_list|(
name|cpipe
parameter_list|)
name|struct
name|pipe
modifier|*
name|cpipe
decl_stmt|;
block|{
name|int
name|npages
decl_stmt|;
name|npages
operator|=
name|round_page
argument_list|(
name|PIPESIZE
argument_list|)
operator|/
name|PAGE_SIZE
expr_stmt|;
comment|/* 	 * Create an object, I don't like the idea of paging to/from 	 * kernel_object. 	 */
name|cpipe
operator|->
name|pipe_buffer
operator|.
name|object
operator|=
name|vm_object_allocate
argument_list|(
name|OBJT_DEFAULT
argument_list|,
name|npages
argument_list|)
expr_stmt|;
comment|/* 	 * Insert the object into the kernel map, and allocate kva for it. 	 * The map entry is, by default, pageable. 	 */
if|if
condition|(
name|vm_map_find
argument_list|(
name|kernel_map
argument_list|,
name|cpipe
operator|->
name|pipe_buffer
operator|.
name|object
argument_list|,
literal|0
argument_list|,
operator|(
name|vm_offset_t
operator|*
operator|)
operator|&
name|cpipe
operator|->
name|pipe_buffer
operator|.
name|buffer
argument_list|,
name|PIPESIZE
argument_list|,
literal|1
argument_list|,
name|VM_PROT_ALL
argument_list|,
name|VM_PROT_ALL
argument_list|,
literal|0
argument_list|)
operator|!=
name|KERN_SUCCESS
condition|)
name|panic
argument_list|(
literal|"pipeinit: cannot allocate pipe -- out of kvm"
argument_list|)
expr_stmt|;
name|cpipe
operator|->
name|pipe_buffer
operator|.
name|in
operator|=
literal|0
expr_stmt|;
name|cpipe
operator|->
name|pipe_buffer
operator|.
name|out
operator|=
literal|0
expr_stmt|;
name|cpipe
operator|->
name|pipe_buffer
operator|.
name|cnt
operator|=
literal|0
expr_stmt|;
name|cpipe
operator|->
name|pipe_buffer
operator|.
name|size
operator|=
name|PIPESIZE
expr_stmt|;
name|cpipe
operator|->
name|pipe_state
operator|=
literal|0
expr_stmt|;
name|cpipe
operator|->
name|pipe_peer
operator|=
name|NULL
expr_stmt|;
name|cpipe
operator|->
name|pipe_busy
operator|=
literal|0
expr_stmt|;
name|cpipe
operator|->
name|pipe_ctime
operator|=
name|time
expr_stmt|;
name|cpipe
operator|->
name|pipe_atime
operator|=
name|time
expr_stmt|;
name|cpipe
operator|->
name|pipe_mtime
operator|=
name|time
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|cpipe
operator|->
name|pipe_sel
argument_list|,
sizeof|sizeof
name|cpipe
operator|->
name|pipe_sel
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * lock a pipe for I/O, blocking other access  */
end_comment

begin_function
specifier|static
name|__inline
name|int
name|pipelock
parameter_list|(
name|cpipe
parameter_list|)
name|struct
name|pipe
modifier|*
name|cpipe
decl_stmt|;
block|{
while|while
condition|(
name|cpipe
operator|->
name|pipe_state
operator|&
name|PIPE_LOCK
condition|)
block|{
name|cpipe
operator|->
name|pipe_state
operator||=
name|PIPE_LWANT
expr_stmt|;
if|if
condition|(
name|tsleep
argument_list|(
operator|&
name|cpipe
operator|->
name|pipe_state
argument_list|,
name|PRIBIO
operator||
name|PCATCH
argument_list|,
literal|"pipelk"
argument_list|,
literal|0
argument_list|)
condition|)
block|{
return|return
name|ERESTART
return|;
block|}
block|}
name|cpipe
operator|->
name|pipe_state
operator||=
name|PIPE_LOCK
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * unlock a pipe I/O lock  */
end_comment

begin_function
specifier|static
name|__inline
name|void
name|pipeunlock
parameter_list|(
name|cpipe
parameter_list|)
name|struct
name|pipe
modifier|*
name|cpipe
decl_stmt|;
block|{
name|cpipe
operator|->
name|pipe_state
operator|&=
operator|~
name|PIPE_LOCK
expr_stmt|;
if|if
condition|(
name|cpipe
operator|->
name|pipe_state
operator|&
name|PIPE_LWANT
condition|)
block|{
name|cpipe
operator|->
name|pipe_state
operator|&=
operator|~
name|PIPE_LWANT
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|cpipe
operator|->
name|pipe_state
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|pipe_read
parameter_list|(
name|fp
parameter_list|,
name|uio
parameter_list|,
name|cred
parameter_list|)
name|struct
name|file
modifier|*
name|fp
decl_stmt|;
name|struct
name|uio
modifier|*
name|uio
decl_stmt|;
name|struct
name|ucred
modifier|*
name|cred
decl_stmt|;
block|{
name|struct
name|pipe
modifier|*
name|rpipe
init|=
operator|(
expr|struct
name|pipe
operator|*
operator|)
name|fp
operator|->
name|f_data
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|int
name|nread
init|=
literal|0
decl_stmt|;
operator|++
name|rpipe
operator|->
name|pipe_busy
expr_stmt|;
while|while
condition|(
name|uio
operator|->
name|uio_resid
condition|)
block|{
if|if
condition|(
name|rpipe
operator|->
name|pipe_buffer
operator|.
name|cnt
operator|>
literal|0
condition|)
block|{
name|int
name|size
init|=
name|rpipe
operator|->
name|pipe_buffer
operator|.
name|size
operator|-
name|rpipe
operator|->
name|pipe_buffer
operator|.
name|out
decl_stmt|;
if|if
condition|(
name|size
operator|>
name|rpipe
operator|->
name|pipe_buffer
operator|.
name|cnt
condition|)
name|size
operator|=
name|rpipe
operator|->
name|pipe_buffer
operator|.
name|cnt
expr_stmt|;
if|if
condition|(
name|size
operator|>
name|uio
operator|->
name|uio_resid
condition|)
name|size
operator|=
name|uio
operator|->
name|uio_resid
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|pipelock
argument_list|(
name|rpipe
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|uiomove
argument_list|(
operator|&
name|rpipe
operator|->
name|pipe_buffer
operator|.
name|buffer
index|[
name|rpipe
operator|->
name|pipe_buffer
operator|.
name|out
index|]
argument_list|,
name|size
argument_list|,
name|uio
argument_list|)
expr_stmt|;
name|pipeunlock
argument_list|(
name|rpipe
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
condition|)
block|{
break|break;
block|}
name|rpipe
operator|->
name|pipe_buffer
operator|.
name|out
operator|+=
name|size
expr_stmt|;
if|if
condition|(
name|rpipe
operator|->
name|pipe_buffer
operator|.
name|out
operator|>=
name|rpipe
operator|->
name|pipe_buffer
operator|.
name|size
condition|)
name|rpipe
operator|->
name|pipe_buffer
operator|.
name|out
operator|=
literal|0
expr_stmt|;
name|rpipe
operator|->
name|pipe_buffer
operator|.
name|cnt
operator|-=
name|size
expr_stmt|;
name|nread
operator|+=
name|size
expr_stmt|;
name|rpipe
operator|->
name|pipe_atime
operator|=
name|time
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * detect EOF condition 			 */
if|if
condition|(
name|rpipe
operator|->
name|pipe_state
operator|&
name|PIPE_EOF
condition|)
block|{
break|break;
block|}
comment|/* 			 * If the "write-side" has been blocked, wake it up now. 			 */
if|if
condition|(
name|rpipe
operator|->
name|pipe_state
operator|&
name|PIPE_WANTW
condition|)
block|{
name|rpipe
operator|->
name|pipe_state
operator|&=
operator|~
name|PIPE_WANTW
expr_stmt|;
name|wakeup
argument_list|(
name|rpipe
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|nread
operator|>
literal|0
operator|)
operator|||
operator|(
name|rpipe
operator|->
name|pipe_state
operator|&
name|PIPE_NBIO
operator|)
condition|)
break|break;
if|if
condition|(
name|rpipe
operator|->
name|pipe_peer
operator|==
name|NULL
condition|)
break|break;
comment|/* 			 * If there is no more to read in the pipe, reset 			 * it's pointers to the beginning.  This improves 			 * cache hit stats. 			 */
if|if
condition|(
operator|(
name|error
operator|=
name|pipelock
argument_list|(
name|rpipe
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|rpipe
operator|->
name|pipe_buffer
operator|.
name|cnt
operator|==
literal|0
condition|)
block|{
name|rpipe
operator|->
name|pipe_buffer
operator|.
name|in
operator|=
literal|0
expr_stmt|;
name|rpipe
operator|->
name|pipe_buffer
operator|.
name|out
operator|=
literal|0
expr_stmt|;
block|}
name|pipeunlock
argument_list|(
name|rpipe
argument_list|)
expr_stmt|;
block|}
else|else
block|{
break|break;
block|}
name|rpipe
operator|->
name|pipe_state
operator||=
name|PIPE_WANTR
expr_stmt|;
if|if
condition|(
name|tsleep
argument_list|(
name|rpipe
argument_list|,
name|PRIBIO
operator||
name|PCATCH
argument_list|,
literal|"piperd"
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|error
operator|=
name|ERESTART
expr_stmt|;
break|break;
block|}
block|}
block|}
operator|--
name|rpipe
operator|->
name|pipe_busy
expr_stmt|;
if|if
condition|(
operator|(
name|rpipe
operator|->
name|pipe_busy
operator|==
literal|0
operator|)
operator|&&
operator|(
name|rpipe
operator|->
name|pipe_state
operator|&
name|PIPE_WANT
operator|)
condition|)
block|{
name|rpipe
operator|->
name|pipe_state
operator|&=
operator|~
operator|(
name|PIPE_WANT
operator||
name|PIPE_WANTW
operator|)
expr_stmt|;
name|wakeup
argument_list|(
name|rpipe
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rpipe
operator|->
name|pipe_buffer
operator|.
name|cnt
operator|<
name|MINPIPESIZE
condition|)
block|{
comment|/* 		 * If there is no more to read in the pipe, reset 		 * it's pointers to the beginning.  This improves 		 * cache hit stats. 		 */
if|if
condition|(
operator|(
name|error
operator|==
literal|0
operator|)
operator|&&
operator|(
name|error
operator|=
name|pipelock
argument_list|(
name|rpipe
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|rpipe
operator|->
name|pipe_buffer
operator|.
name|cnt
operator|==
literal|0
condition|)
block|{
name|rpipe
operator|->
name|pipe_buffer
operator|.
name|in
operator|=
literal|0
expr_stmt|;
name|rpipe
operator|->
name|pipe_buffer
operator|.
name|out
operator|=
literal|0
expr_stmt|;
block|}
name|pipeunlock
argument_list|(
name|rpipe
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * If the "write-side" has been blocked, wake it up now. 		 */
if|if
condition|(
name|rpipe
operator|->
name|pipe_state
operator|&
name|PIPE_WANTW
condition|)
block|{
name|rpipe
operator|->
name|pipe_state
operator|&=
operator|~
name|PIPE_WANTW
expr_stmt|;
name|wakeup
argument_list|(
name|rpipe
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|rpipe
operator|->
name|pipe_state
operator|&
name|PIPE_SEL
condition|)
block|{
name|rpipe
operator|->
name|pipe_state
operator|&=
operator|~
name|PIPE_SEL
expr_stmt|;
name|selwakeup
argument_list|(
operator|&
name|rpipe
operator|->
name|pipe_sel
argument_list|)
expr_stmt|;
block|}
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|pipe_write
parameter_list|(
name|fp
parameter_list|,
name|uio
parameter_list|,
name|cred
parameter_list|)
name|struct
name|file
modifier|*
name|fp
decl_stmt|;
name|struct
name|uio
modifier|*
name|uio
decl_stmt|;
name|struct
name|ucred
modifier|*
name|cred
decl_stmt|;
block|{
name|struct
name|pipe
modifier|*
name|rpipe
init|=
operator|(
expr|struct
name|pipe
operator|*
operator|)
name|fp
operator|->
name|f_data
decl_stmt|;
name|struct
name|pipe
modifier|*
name|wpipe
init|=
name|rpipe
operator|->
name|pipe_peer
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
comment|/* 	 * detect loss of pipe read side, issue SIGPIPE if lost. 	 */
if|if
condition|(
name|wpipe
operator|==
name|NULL
operator|||
operator|(
name|wpipe
operator|->
name|pipe_state
operator|&
name|PIPE_EOF
operator|)
condition|)
block|{
name|psignal
argument_list|(
name|curproc
argument_list|,
name|SIGPIPE
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
operator|++
name|wpipe
operator|->
name|pipe_busy
expr_stmt|;
while|while
condition|(
name|uio
operator|->
name|uio_resid
condition|)
block|{
name|int
name|space
init|=
name|wpipe
operator|->
name|pipe_buffer
operator|.
name|size
operator|-
name|wpipe
operator|->
name|pipe_buffer
operator|.
name|cnt
decl_stmt|;
if|if
condition|(
name|space
operator|>
literal|0
condition|)
block|{
name|int
name|size
init|=
name|wpipe
operator|->
name|pipe_buffer
operator|.
name|size
operator|-
name|wpipe
operator|->
name|pipe_buffer
operator|.
name|in
decl_stmt|;
if|if
condition|(
name|size
operator|>
name|space
condition|)
name|size
operator|=
name|space
expr_stmt|;
if|if
condition|(
name|size
operator|>
name|uio
operator|->
name|uio_resid
condition|)
name|size
operator|=
name|uio
operator|->
name|uio_resid
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|pipelock
argument_list|(
name|wpipe
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|uiomove
argument_list|(
operator|&
name|wpipe
operator|->
name|pipe_buffer
operator|.
name|buffer
index|[
name|wpipe
operator|->
name|pipe_buffer
operator|.
name|in
index|]
argument_list|,
name|size
argument_list|,
name|uio
argument_list|)
expr_stmt|;
name|pipeunlock
argument_list|(
name|wpipe
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
condition|)
break|break;
name|wpipe
operator|->
name|pipe_buffer
operator|.
name|in
operator|+=
name|size
expr_stmt|;
if|if
condition|(
name|wpipe
operator|->
name|pipe_buffer
operator|.
name|in
operator|>=
name|wpipe
operator|->
name|pipe_buffer
operator|.
name|size
condition|)
name|wpipe
operator|->
name|pipe_buffer
operator|.
name|in
operator|=
literal|0
expr_stmt|;
name|wpipe
operator|->
name|pipe_buffer
operator|.
name|cnt
operator|+=
name|size
expr_stmt|;
name|wpipe
operator|->
name|pipe_mtime
operator|=
name|time
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * If the "read-side" has been blocked, wake it up now. 			 */
if|if
condition|(
name|wpipe
operator|->
name|pipe_state
operator|&
name|PIPE_WANTR
condition|)
block|{
name|wpipe
operator|->
name|pipe_state
operator|&=
operator|~
name|PIPE_WANTR
expr_stmt|;
name|wakeup
argument_list|(
name|wpipe
argument_list|)
expr_stmt|;
block|}
comment|/* 			 * don't block on non-blocking I/O 			 */
if|if
condition|(
name|wpipe
operator|->
name|pipe_state
operator|&
name|PIPE_NBIO
condition|)
block|{
break|break;
block|}
name|wpipe
operator|->
name|pipe_state
operator||=
name|PIPE_WANTW
expr_stmt|;
if|if
condition|(
name|tsleep
argument_list|(
name|wpipe
argument_list|,
operator|(
name|PRIBIO
operator|+
literal|1
operator|)
operator||
name|PCATCH
argument_list|,
literal|"pipewr"
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|error
operator|=
name|ERESTART
expr_stmt|;
break|break;
block|}
comment|/* 			 * If read side wants to go away, we just issue a signal 			 * to ourselves. 			 */
if|if
condition|(
name|wpipe
operator|->
name|pipe_state
operator|&
name|PIPE_EOF
condition|)
block|{
name|psignal
argument_list|(
name|curproc
argument_list|,
name|SIGPIPE
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
operator|--
name|wpipe
operator|->
name|pipe_busy
expr_stmt|;
if|if
condition|(
operator|(
name|wpipe
operator|->
name|pipe_busy
operator|==
literal|0
operator|)
operator|&&
operator|(
name|wpipe
operator|->
name|pipe_state
operator|&
name|PIPE_WANT
operator|)
condition|)
block|{
name|wpipe
operator|->
name|pipe_state
operator|&=
operator|~
operator|(
name|PIPE_WANT
operator||
name|PIPE_WANTR
operator|)
expr_stmt|;
name|wakeup
argument_list|(
name|wpipe
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|wpipe
operator|->
name|pipe_buffer
operator|.
name|cnt
operator|>
literal|0
condition|)
block|{
comment|/* 		 * If we have put any characters in the buffer, we wake up 		 * the reader. 		 */
if|if
condition|(
name|wpipe
operator|->
name|pipe_state
operator|&
name|PIPE_WANTR
condition|)
block|{
name|wpipe
operator|->
name|pipe_state
operator|&=
operator|~
name|PIPE_WANTR
expr_stmt|;
name|wakeup
argument_list|(
name|wpipe
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|wpipe
operator|->
name|pipe_state
operator|&
name|PIPE_SEL
condition|)
block|{
name|wpipe
operator|->
name|pipe_state
operator|&=
operator|~
name|PIPE_SEL
expr_stmt|;
name|selwakeup
argument_list|(
operator|&
name|wpipe
operator|->
name|pipe_sel
argument_list|)
expr_stmt|;
block|}
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  * we implement a very minimal set of ioctls for compatibility with sockets.  */
end_comment

begin_function
name|int
name|pipe_ioctl
parameter_list|(
name|fp
parameter_list|,
name|cmd
parameter_list|,
name|data
parameter_list|,
name|p
parameter_list|)
name|struct
name|file
modifier|*
name|fp
decl_stmt|;
name|int
name|cmd
decl_stmt|;
specifier|register
name|caddr_t
name|data
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
block|{
specifier|register
name|struct
name|pipe
modifier|*
name|mpipe
init|=
operator|(
expr|struct
name|pipe
operator|*
operator|)
name|fp
operator|->
name|f_data
decl_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|FIONBIO
case|:
if|if
condition|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
condition|)
name|mpipe
operator|->
name|pipe_state
operator||=
name|PIPE_NBIO
expr_stmt|;
else|else
name|mpipe
operator|->
name|pipe_state
operator|&=
operator|~
name|PIPE_NBIO
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|FIOASYNC
case|:
if|if
condition|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
condition|)
block|{
name|mpipe
operator|->
name|pipe_state
operator||=
name|PIPE_ASYNC
expr_stmt|;
block|}
else|else
block|{
name|mpipe
operator|->
name|pipe_state
operator|&=
operator|~
name|PIPE_ASYNC
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|FIONREAD
case|:
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|mpipe
operator|->
name|pipe_buffer
operator|.
name|cnt
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|SIOCSPGRP
case|:
name|mpipe
operator|->
name|pipe_pgid
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
name|data
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|SIOCGPGRP
case|:
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|mpipe
operator|->
name|pipe_pgid
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
name|ENOSYS
return|;
block|}
end_function

begin_function
name|int
name|pipe_select
parameter_list|(
name|fp
parameter_list|,
name|which
parameter_list|,
name|p
parameter_list|)
name|struct
name|file
modifier|*
name|fp
decl_stmt|;
name|int
name|which
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
block|{
specifier|register
name|struct
name|pipe
modifier|*
name|rpipe
init|=
operator|(
expr|struct
name|pipe
operator|*
operator|)
name|fp
operator|->
name|f_data
decl_stmt|;
name|struct
name|pipe
modifier|*
name|wpipe
decl_stmt|;
specifier|register
name|int
name|s
init|=
name|splnet
argument_list|()
decl_stmt|;
name|wpipe
operator|=
name|rpipe
operator|->
name|pipe_peer
expr_stmt|;
switch|switch
condition|(
name|which
condition|)
block|{
case|case
name|FREAD
case|:
if|if
condition|(
name|rpipe
operator|->
name|pipe_buffer
operator|.
name|cnt
operator|>
literal|0
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|selrecord
argument_list|(
name|p
argument_list|,
operator|&
name|rpipe
operator|->
name|pipe_sel
argument_list|)
expr_stmt|;
name|rpipe
operator|->
name|pipe_state
operator||=
name|PIPE_SEL
expr_stmt|;
break|break;
case|case
name|FWRITE
case|:
if|if
condition|(
name|wpipe
operator|==
literal|0
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|wpipe
operator|->
name|pipe_buffer
operator|.
name|cnt
operator|<
name|wpipe
operator|->
name|pipe_buffer
operator|.
name|size
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|selrecord
argument_list|(
name|p
argument_list|,
operator|&
name|wpipe
operator|->
name|pipe_sel
argument_list|)
expr_stmt|;
name|wpipe
operator|->
name|pipe_state
operator||=
name|PIPE_SEL
expr_stmt|;
break|break;
case|case
literal|0
case|:
name|selrecord
argument_list|(
name|p
argument_list|,
operator|&
name|rpipe
operator|->
name|pipe_sel
argument_list|)
expr_stmt|;
name|rpipe
operator|->
name|pipe_state
operator||=
name|PIPE_SEL
expr_stmt|;
break|break;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pipe_stat
parameter_list|(
name|pipe
parameter_list|,
name|ub
parameter_list|)
specifier|register
name|struct
name|pipe
modifier|*
name|pipe
decl_stmt|;
specifier|register
name|struct
name|stat
modifier|*
name|ub
decl_stmt|;
block|{
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
name|ub
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ub
argument_list|)
argument_list|)
expr_stmt|;
name|ub
operator|->
name|st_mode
operator|=
name|S_IFSOCK
expr_stmt|;
name|ub
operator|->
name|st_blksize
operator|=
name|pipe
operator|->
name|pipe_buffer
operator|.
name|size
operator|/
literal|2
expr_stmt|;
name|ub
operator|->
name|st_size
operator|=
name|pipe
operator|->
name|pipe_buffer
operator|.
name|cnt
expr_stmt|;
name|ub
operator|->
name|st_blocks
operator|=
operator|(
name|ub
operator|->
name|st_size
operator|+
name|ub
operator|->
name|st_blksize
operator|-
literal|1
operator|)
operator|/
name|ub
operator|->
name|st_blksize
expr_stmt|;
name|TIMEVAL_TO_TIMESPEC
argument_list|(
operator|&
name|pipe
operator|->
name|pipe_atime
argument_list|,
operator|&
name|ub
operator|->
name|st_atimespec
argument_list|)
expr_stmt|;
name|TIMEVAL_TO_TIMESPEC
argument_list|(
operator|&
name|pipe
operator|->
name|pipe_mtime
argument_list|,
operator|&
name|ub
operator|->
name|st_mtimespec
argument_list|)
expr_stmt|;
name|TIMEVAL_TO_TIMESPEC
argument_list|(
operator|&
name|pipe
operator|->
name|pipe_ctime
argument_list|,
operator|&
name|ub
operator|->
name|st_ctimespec
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|pipe_close
parameter_list|(
name|fp
parameter_list|,
name|p
parameter_list|)
name|struct
name|file
modifier|*
name|fp
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
name|struct
name|pipe
modifier|*
name|cpipe
init|=
operator|(
expr|struct
name|pipe
operator|*
operator|)
name|fp
operator|->
name|f_data
decl_stmt|;
name|pipeclose
argument_list|(
name|cpipe
argument_list|)
expr_stmt|;
name|fp
operator|->
name|f_data
operator|=
name|NULL
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * shutdown the pipe  */
end_comment

begin_function
specifier|static
name|void
name|pipeclose
parameter_list|(
name|cpipe
parameter_list|)
name|struct
name|pipe
modifier|*
name|cpipe
decl_stmt|;
block|{
if|if
condition|(
name|cpipe
condition|)
block|{
comment|/* 		 * If the other side is blocked, wake it up saying that 		 * we want to close it down. 		 */
while|while
condition|(
name|cpipe
operator|->
name|pipe_busy
condition|)
block|{
name|wakeup
argument_list|(
name|cpipe
argument_list|)
expr_stmt|;
name|cpipe
operator|->
name|pipe_state
operator||=
name|PIPE_WANT
operator||
name|PIPE_EOF
expr_stmt|;
name|tsleep
argument_list|(
name|cpipe
argument_list|,
name|PRIBIO
argument_list|,
literal|"pipecl"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Disconnect from peer 		 */
if|if
condition|(
name|cpipe
operator|->
name|pipe_peer
condition|)
block|{
name|cpipe
operator|->
name|pipe_peer
operator|->
name|pipe_state
operator||=
name|PIPE_EOF
expr_stmt|;
name|wakeup
argument_list|(
name|cpipe
operator|->
name|pipe_peer
argument_list|)
expr_stmt|;
name|cpipe
operator|->
name|pipe_peer
operator|->
name|pipe_peer
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* 		 * free resources 		 */
name|kmem_free
argument_list|(
name|kernel_map
argument_list|,
operator|(
name|vm_offset_t
operator|)
name|cpipe
operator|->
name|pipe_buffer
operator|.
name|buffer
argument_list|,
name|cpipe
operator|->
name|pipe_buffer
operator|.
name|size
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cpipe
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

