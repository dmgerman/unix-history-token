begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1996 John S. Dyson  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice immediately at the beginning of the file, without modification,  *    this list of conditions, and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. Absolutely no warranty of function or purpose is made by the author  *    John S. Dyson.  * 4. Modifications may be freely made to this file if the above conditions  *    are met.  */
end_comment

begin_comment
comment|/*  * This file contains a high-performance replacement for the socket-based  * pipes scheme originally used in FreeBSD/4.4Lite.  It does not support  * all features of sockets, but does do everything that pipes normally  * do.  */
end_comment

begin_comment
comment|/*  * This code has two modes of operation, a small write mode and a large  * write mode.  The small write mode acts like conventional pipes with  * a kernel buffer.  If the buffer is less than PIPE_MINDIRECT, then the  * "normal" pipe buffering is done.  If the buffer is between PIPE_MINDIRECT  * and PIPE_SIZE in size, it is fully mapped and wired into the kernel, and  * the receiving process can copy it directly from the pages in the sending  * process.  *  * If the sending process receives a signal, it is possible that it will  * go away, and certainly its address space can change, because control  * is returned back to the user-mode side.  In that case, the pipe code  * arranges to copy the buffer supplied by the user process, to a pageable  * kernel buffer, and the receiving process will grab the data from the  * pageable kernel buffer.  Since signals don't happen all that often,  * the copy operation is normally eliminated.  *  * The constant PIPE_MINDIRECT is chosen to make sure that buffering will  * happen for small transfers so that the system will not spend all of  * its time context switching.  *  * In order to limit the resource use of pipes, two sysctls exist:  *  * kern.ipc.maxpipekva - This is a hard limit on the amount of pageable  * address space available to us in pipe_map. This value is normally  * autotuned, but may also be loader tuned.  *  * kern.ipc.pipekva - This read-only sysctl tracks the current amount of  * memory in use by pipes.  *  * Based on how large pipekva is relative to maxpipekva, the following  * will happen:  *  * 0% - 50%:  *     New pipes are given 16K of memory backing, pipes may dynamically  *     grow to as large as 64K where needed.  * 50% - 75%:  *     New pipes are given 4K (or PAGE_SIZE) of memory backing,  *     existing pipes may NOT grow.  * 75% - 100%:  *     New pipes are given 4K (or PAGE_SIZE) of memory backing,  *     existing pipes will be shrunk down to 4K whenever possible.  *  * Resizing may be disabled by setting kern.ipc.piperesizeallowed=0.  If  * that is set,  the only resize that will occur is the 0 -> SMALL_PIPE_SIZE  * resize which MUST occur for reverse-direction pipes when they are  * first used.  *  * Additional information about the current state of pipes may be obtained  * from kern.ipc.pipes, kern.ipc.pipefragretry, kern.ipc.pipeallocfail,  * and kern.ipc.piperesizefail.  *  * Locking rules:  There are two locks present here:  A mutex, used via  * PIPE_LOCK, and a flag, used via pipelock().  All locking is done via  * the flag, as mutexes can not persist over uiomove.  The mutex  * exists only to guard access to the flag, and is not in itself a  * locking mechanism.  Also note that there is only a single mutex for  * both directions of a pipe.  *  * As pipelock() may have to sleep before it can acquire the flag, it  * is important to reread all data after a call to pipelock(); everything  * in the structure may have changed.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"opt_mac.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/filedesc.h>
end_include

begin_include
include|#
directive|include
file|<sys/filio.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/ttycom.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/poll.h>
end_include

begin_include
include|#
directive|include
file|<sys/selinfo.h>
end_include

begin_include
include|#
directive|include
file|<sys/signalvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysproto.h>
end_include

begin_include
include|#
directive|include
file|<sys/pipe.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/vnode.h>
end_include

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_include
include|#
directive|include
file|<sys/event.h>
end_include

begin_include
include|#
directive|include
file|<security/mac/mac_framework.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_param.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_object.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_kern.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_extern.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_map.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_page.h>
end_include

begin_include
include|#
directive|include
file|<vm/uma.h>
end_include

begin_comment
comment|/*  * Use this define if you want to disable *fancy* VM things.  Expect an  * approx 30% decrease in transfer rate.  This could be useful for  * NetBSD or OpenBSD.  */
end_comment

begin_comment
comment|/* #define PIPE_NODIRECT */
end_comment

begin_comment
comment|/*  * interfaces to the outside world  */
end_comment

begin_decl_stmt
specifier|static
name|fo_rdwr_t
name|pipe_read
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|fo_rdwr_t
name|pipe_write
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|fo_ioctl_t
name|pipe_ioctl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|fo_poll_t
name|pipe_poll
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|fo_kqfilter_t
name|pipe_kqfilter
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|fo_stat_t
name|pipe_stat
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|fo_close_t
name|pipe_close
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|fileops
name|pipeops
init|=
block|{
operator|.
name|fo_read
operator|=
name|pipe_read
block|,
operator|.
name|fo_write
operator|=
name|pipe_write
block|,
operator|.
name|fo_ioctl
operator|=
name|pipe_ioctl
block|,
operator|.
name|fo_poll
operator|=
name|pipe_poll
block|,
operator|.
name|fo_kqfilter
operator|=
name|pipe_kqfilter
block|,
operator|.
name|fo_stat
operator|=
name|pipe_stat
block|,
operator|.
name|fo_close
operator|=
name|pipe_close
block|,
operator|.
name|fo_flags
operator|=
name|DFLAG_PASSABLE
block|}
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|filt_pipedetach
parameter_list|(
name|struct
name|knote
modifier|*
name|kn
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|filt_piperead
parameter_list|(
name|struct
name|knote
modifier|*
name|kn
parameter_list|,
name|long
name|hint
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|filt_pipewrite
parameter_list|(
name|struct
name|knote
modifier|*
name|kn
parameter_list|,
name|long
name|hint
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|struct
name|filterops
name|pipe_rfiltops
init|=
block|{
literal|1
block|,
name|NULL
block|,
name|filt_pipedetach
block|,
name|filt_piperead
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|filterops
name|pipe_wfiltops
init|=
block|{
literal|1
block|,
name|NULL
block|,
name|filt_pipedetach
block|,
name|filt_pipewrite
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Default pipe buffer size(s), this can be kind-of large now because pipe  * space is pageable.  The pipe code will try to maintain locality of  * reference for performance reasons, so small amounts of outstanding I/O  * will not wipe the cache.  */
end_comment

begin_define
define|#
directive|define
name|MINPIPESIZE
value|(PIPE_SIZE/3)
end_define

begin_define
define|#
directive|define
name|MAXPIPESIZE
value|(2*PIPE_SIZE/3)
end_define

begin_decl_stmt
specifier|static
name|int
name|amountpipes
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|amountpipekva
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|pipefragretry
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|pipeallocfail
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|piperesizefail
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|piperesizeallowed
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_kern_ipc
argument_list|,
name|OID_AUTO
argument_list|,
name|maxpipekva
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|maxpipekva
argument_list|,
literal|0
argument_list|,
literal|"Pipe KVA limit"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_kern_ipc
argument_list|,
name|OID_AUTO
argument_list|,
name|pipes
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|amountpipes
argument_list|,
literal|0
argument_list|,
literal|"Current # of pipes"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_kern_ipc
argument_list|,
name|OID_AUTO
argument_list|,
name|pipekva
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|amountpipekva
argument_list|,
literal|0
argument_list|,
literal|"Pipe KVA usage"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_kern_ipc
argument_list|,
name|OID_AUTO
argument_list|,
name|pipefragretry
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|pipefragretry
argument_list|,
literal|0
argument_list|,
literal|"Pipe allocation retries due to fragmentation"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_kern_ipc
argument_list|,
name|OID_AUTO
argument_list|,
name|pipeallocfail
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|pipeallocfail
argument_list|,
literal|0
argument_list|,
literal|"Pipe allocation failures"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_kern_ipc
argument_list|,
name|OID_AUTO
argument_list|,
name|piperesizefail
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|piperesizefail
argument_list|,
literal|0
argument_list|,
literal|"Pipe resize failures"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_kern_ipc
argument_list|,
name|OID_AUTO
argument_list|,
name|piperesizeallowed
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|piperesizeallowed
argument_list|,
literal|0
argument_list|,
literal|"Pipe resizing allowed"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function_decl
specifier|static
name|void
name|pipeinit
parameter_list|(
name|void
modifier|*
name|dummy
name|__unused
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pipeclose
parameter_list|(
name|struct
name|pipe
modifier|*
name|cpipe
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pipe_free_kmem
parameter_list|(
name|struct
name|pipe
modifier|*
name|cpipe
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pipe_create
parameter_list|(
name|struct
name|pipe
modifier|*
name|pipe
parameter_list|,
name|int
name|backing
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__inline
name|int
name|pipelock
parameter_list|(
name|struct
name|pipe
modifier|*
name|cpipe
parameter_list|,
name|int
name|catch
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__inline
name|void
name|pipeunlock
parameter_list|(
name|struct
name|pipe
modifier|*
name|cpipe
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__inline
name|void
name|pipeselwakeup
parameter_list|(
name|struct
name|pipe
modifier|*
name|cpipe
parameter_list|)
function_decl|;
end_function_decl

begin_ifndef
ifndef|#
directive|ifndef
name|PIPE_NODIRECT
end_ifndef

begin_function_decl
specifier|static
name|int
name|pipe_build_write_buffer
parameter_list|(
name|struct
name|pipe
modifier|*
name|wpipe
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pipe_destroy_write_buffer
parameter_list|(
name|struct
name|pipe
modifier|*
name|wpipe
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pipe_direct_write
parameter_list|(
name|struct
name|pipe
modifier|*
name|wpipe
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pipe_clone_write_buffer
parameter_list|(
name|struct
name|pipe
modifier|*
name|wpipe
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|int
name|pipespace
parameter_list|(
name|struct
name|pipe
modifier|*
name|cpipe
parameter_list|,
name|int
name|size
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pipespace_new
parameter_list|(
name|struct
name|pipe
modifier|*
name|cpipe
parameter_list|,
name|int
name|size
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pipe_zone_ctor
parameter_list|(
name|void
modifier|*
name|mem
parameter_list|,
name|int
name|size
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|flags
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pipe_zone_dtor
parameter_list|(
name|void
modifier|*
name|mem
parameter_list|,
name|int
name|size
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pipe_zone_init
parameter_list|(
name|void
modifier|*
name|mem
parameter_list|,
name|int
name|size
parameter_list|,
name|int
name|flags
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pipe_zone_fini
parameter_list|(
name|void
modifier|*
name|mem
parameter_list|,
name|int
name|size
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|uma_zone_t
name|pipe_zone
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSINIT
argument_list|(
name|vfs
argument_list|,
name|SI_SUB_VFS
argument_list|,
name|SI_ORDER_ANY
argument_list|,
name|pipeinit
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|void
name|pipeinit
parameter_list|(
name|void
modifier|*
name|dummy
name|__unused
parameter_list|)
block|{
name|pipe_zone
operator|=
name|uma_zcreate
argument_list|(
literal|"PIPE"
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|pipepair
argument_list|)
argument_list|,
name|pipe_zone_ctor
argument_list|,
name|pipe_zone_dtor
argument_list|,
name|pipe_zone_init
argument_list|,
name|pipe_zone_fini
argument_list|,
name|UMA_ALIGN_PTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|pipe_zone
operator|!=
name|NULL
argument_list|,
operator|(
literal|"pipe_zone not initialized"
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|pipe_zone_ctor
parameter_list|(
name|void
modifier|*
name|mem
parameter_list|,
name|int
name|size
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|pipepair
modifier|*
name|pp
decl_stmt|;
name|struct
name|pipe
modifier|*
name|rpipe
decl_stmt|,
modifier|*
name|wpipe
decl_stmt|;
name|KASSERT
argument_list|(
name|size
operator|==
sizeof|sizeof
argument_list|(
operator|*
name|pp
argument_list|)
argument_list|,
operator|(
literal|"pipe_zone_ctor: wrong size"
operator|)
argument_list|)
expr_stmt|;
name|pp
operator|=
operator|(
expr|struct
name|pipepair
operator|*
operator|)
name|mem
expr_stmt|;
comment|/* 	 * We zero both pipe endpoints to make sure all the kmem pointers 	 * are NULL, flag fields are zero'd, etc.  We timestamp both 	 * endpoints with the same time. 	 */
name|rpipe
operator|=
operator|&
name|pp
operator|->
name|pp_rpipe
expr_stmt|;
name|bzero
argument_list|(
name|rpipe
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|rpipe
argument_list|)
argument_list|)
expr_stmt|;
name|vfs_timestamp
argument_list|(
operator|&
name|rpipe
operator|->
name|pipe_ctime
argument_list|)
expr_stmt|;
name|rpipe
operator|->
name|pipe_atime
operator|=
name|rpipe
operator|->
name|pipe_mtime
operator|=
name|rpipe
operator|->
name|pipe_ctime
expr_stmt|;
name|wpipe
operator|=
operator|&
name|pp
operator|->
name|pp_wpipe
expr_stmt|;
name|bzero
argument_list|(
name|wpipe
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|wpipe
argument_list|)
argument_list|)
expr_stmt|;
name|wpipe
operator|->
name|pipe_ctime
operator|=
name|rpipe
operator|->
name|pipe_ctime
expr_stmt|;
name|wpipe
operator|->
name|pipe_atime
operator|=
name|wpipe
operator|->
name|pipe_mtime
operator|=
name|rpipe
operator|->
name|pipe_ctime
expr_stmt|;
name|rpipe
operator|->
name|pipe_peer
operator|=
name|wpipe
expr_stmt|;
name|rpipe
operator|->
name|pipe_pair
operator|=
name|pp
expr_stmt|;
name|wpipe
operator|->
name|pipe_peer
operator|=
name|rpipe
expr_stmt|;
name|wpipe
operator|->
name|pipe_pair
operator|=
name|pp
expr_stmt|;
comment|/* 	 * Mark both endpoints as present; they will later get free'd 	 * one at a time.  When both are free'd, then the whole pair 	 * is released. 	 */
name|rpipe
operator|->
name|pipe_present
operator|=
literal|1
expr_stmt|;
name|wpipe
operator|->
name|pipe_present
operator|=
literal|1
expr_stmt|;
comment|/* 	 * Eventually, the MAC Framework may initialize the label 	 * in ctor or init, but for now we do it elswhere to avoid 	 * blocking in ctor or init. 	 */
name|pp
operator|->
name|pp_label
operator|=
name|NULL
expr_stmt|;
name|atomic_add_int
argument_list|(
operator|&
name|amountpipes
argument_list|,
literal|2
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|pipe_zone_dtor
parameter_list|(
name|void
modifier|*
name|mem
parameter_list|,
name|int
name|size
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|pipepair
modifier|*
name|pp
decl_stmt|;
name|KASSERT
argument_list|(
name|size
operator|==
sizeof|sizeof
argument_list|(
operator|*
name|pp
argument_list|)
argument_list|,
operator|(
literal|"pipe_zone_dtor: wrong size"
operator|)
argument_list|)
expr_stmt|;
name|pp
operator|=
operator|(
expr|struct
name|pipepair
operator|*
operator|)
name|mem
expr_stmt|;
name|atomic_subtract_int
argument_list|(
operator|&
name|amountpipes
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|pipe_zone_init
parameter_list|(
name|void
modifier|*
name|mem
parameter_list|,
name|int
name|size
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|pipepair
modifier|*
name|pp
decl_stmt|;
name|KASSERT
argument_list|(
name|size
operator|==
sizeof|sizeof
argument_list|(
operator|*
name|pp
argument_list|)
argument_list|,
operator|(
literal|"pipe_zone_init: wrong size"
operator|)
argument_list|)
expr_stmt|;
name|pp
operator|=
operator|(
expr|struct
name|pipepair
operator|*
operator|)
name|mem
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|pp
operator|->
name|pp_mtx
argument_list|,
literal|"pipe mutex"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
operator||
name|MTX_RECURSE
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|pipe_zone_fini
parameter_list|(
name|void
modifier|*
name|mem
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|struct
name|pipepair
modifier|*
name|pp
decl_stmt|;
name|KASSERT
argument_list|(
name|size
operator|==
sizeof|sizeof
argument_list|(
operator|*
name|pp
argument_list|)
argument_list|,
operator|(
literal|"pipe_zone_fini: wrong size"
operator|)
argument_list|)
expr_stmt|;
name|pp
operator|=
operator|(
expr|struct
name|pipepair
operator|*
operator|)
name|mem
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|pp
operator|->
name|pp_mtx
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * The pipe system call for the DTYPE_PIPE type of pipes.  If we fail, let  * the zone pick up the pieces via pipeclose().  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|pipe
parameter_list|(
name|td
parameter_list|,
name|uap
parameter_list|)
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|pipe_args
comment|/* { 		int	dummy; 	} */
modifier|*
name|uap
decl_stmt|;
block|{
name|struct
name|filedesc
modifier|*
name|fdp
init|=
name|td
operator|->
name|td_proc
operator|->
name|p_fd
decl_stmt|;
name|struct
name|file
modifier|*
name|rf
decl_stmt|,
modifier|*
name|wf
decl_stmt|;
name|struct
name|pipepair
modifier|*
name|pp
decl_stmt|;
name|struct
name|pipe
modifier|*
name|rpipe
decl_stmt|,
modifier|*
name|wpipe
decl_stmt|;
name|int
name|fd
decl_stmt|,
name|error
decl_stmt|;
name|pp
operator|=
name|uma_zalloc
argument_list|(
name|pipe_zone
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MAC
comment|/* 	 * The MAC label is shared between the connected endpoints.  As a 	 * result mac_init_pipe() and mac_create_pipe() are called once 	 * for the pair, and not on the endpoints. 	 */
name|mac_init_pipe
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|mac_create_pipe
argument_list|(
name|td
operator|->
name|td_ucred
argument_list|,
name|pp
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|rpipe
operator|=
operator|&
name|pp
operator|->
name|pp_rpipe
expr_stmt|;
name|wpipe
operator|=
operator|&
name|pp
operator|->
name|pp_wpipe
expr_stmt|;
name|knlist_init
argument_list|(
operator|&
name|rpipe
operator|->
name|pipe_sel
operator|.
name|si_note
argument_list|,
name|PIPE_MTX
argument_list|(
name|rpipe
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|knlist_init
argument_list|(
operator|&
name|wpipe
operator|->
name|pipe_sel
operator|.
name|si_note
argument_list|,
name|PIPE_MTX
argument_list|(
name|wpipe
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Only the forward direction pipe is backed by default */
if|if
condition|(
operator|(
name|error
operator|=
name|pipe_create
argument_list|(
name|rpipe
argument_list|,
literal|1
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|error
operator|=
name|pipe_create
argument_list|(
name|wpipe
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|pipeclose
argument_list|(
name|rpipe
argument_list|)
expr_stmt|;
name|pipeclose
argument_list|(
name|wpipe
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|rpipe
operator|->
name|pipe_state
operator||=
name|PIPE_DIRECTOK
expr_stmt|;
name|wpipe
operator|->
name|pipe_state
operator||=
name|PIPE_DIRECTOK
expr_stmt|;
name|error
operator|=
name|falloc
argument_list|(
name|td
argument_list|,
operator|&
name|rf
argument_list|,
operator|&
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|pipeclose
argument_list|(
name|rpipe
argument_list|)
expr_stmt|;
name|pipeclose
argument_list|(
name|wpipe
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* An extra reference on `rf' has been held for us by falloc(). */
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|=
name|fd
expr_stmt|;
comment|/* 	 * Warning: once we've gotten past allocation of the fd for the 	 * read-side, we can only drop the read side via fdrop() in order 	 * to avoid races against processes which manage to dup() the read 	 * side while we are blocked trying to allocate the write side. 	 */
name|FILE_LOCK
argument_list|(
name|rf
argument_list|)
expr_stmt|;
name|rf
operator|->
name|f_flag
operator|=
name|FREAD
operator||
name|FWRITE
expr_stmt|;
name|rf
operator|->
name|f_type
operator|=
name|DTYPE_PIPE
expr_stmt|;
name|rf
operator|->
name|f_data
operator|=
name|rpipe
expr_stmt|;
name|rf
operator|->
name|f_ops
operator|=
operator|&
name|pipeops
expr_stmt|;
name|FILE_UNLOCK
argument_list|(
name|rf
argument_list|)
expr_stmt|;
name|error
operator|=
name|falloc
argument_list|(
name|td
argument_list|,
operator|&
name|wf
argument_list|,
operator|&
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|fdclose
argument_list|(
name|fdp
argument_list|,
name|rf
argument_list|,
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|fdrop
argument_list|(
name|rf
argument_list|,
name|td
argument_list|)
expr_stmt|;
comment|/* rpipe has been closed by fdrop(). */
name|pipeclose
argument_list|(
name|wpipe
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* An extra reference on `wf' has been held for us by falloc(). */
name|FILE_LOCK
argument_list|(
name|wf
argument_list|)
expr_stmt|;
name|wf
operator|->
name|f_flag
operator|=
name|FREAD
operator||
name|FWRITE
expr_stmt|;
name|wf
operator|->
name|f_type
operator|=
name|DTYPE_PIPE
expr_stmt|;
name|wf
operator|->
name|f_data
operator|=
name|wpipe
expr_stmt|;
name|wf
operator|->
name|f_ops
operator|=
operator|&
name|pipeops
expr_stmt|;
name|FILE_UNLOCK
argument_list|(
name|wf
argument_list|)
expr_stmt|;
name|fdrop
argument_list|(
name|wf
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|td
operator|->
name|td_retval
index|[
literal|1
index|]
operator|=
name|fd
expr_stmt|;
name|fdrop
argument_list|(
name|rf
argument_list|,
name|td
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Allocate kva for pipe circular buffer, the space is pageable  * This routine will 'realloc' the size of a pipe safely, if it fails  * it will retain the old buffer.  * If it fails it will return ENOMEM.  */
end_comment

begin_function
specifier|static
name|int
name|pipespace_new
parameter_list|(
name|cpipe
parameter_list|,
name|size
parameter_list|)
name|struct
name|pipe
modifier|*
name|cpipe
decl_stmt|;
name|int
name|size
decl_stmt|;
block|{
name|caddr_t
name|buffer
decl_stmt|;
name|int
name|error
decl_stmt|,
name|cnt
decl_stmt|,
name|firstseg
decl_stmt|;
specifier|static
name|int
name|curfail
init|=
literal|0
decl_stmt|;
specifier|static
name|struct
name|timeval
name|lastfail
decl_stmt|;
name|KASSERT
argument_list|(
operator|!
name|mtx_owned
argument_list|(
name|PIPE_MTX
argument_list|(
name|cpipe
argument_list|)
argument_list|)
argument_list|,
operator|(
literal|"pipespace: pipe mutex locked"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|!
operator|(
name|cpipe
operator|->
name|pipe_state
operator|&
name|PIPE_DIRECTW
operator|)
argument_list|,
operator|(
literal|"pipespace: resize of direct writes not allowed"
operator|)
argument_list|)
expr_stmt|;
name|retry
label|:
name|cnt
operator|=
name|cpipe
operator|->
name|pipe_buffer
operator|.
name|cnt
expr_stmt|;
if|if
condition|(
name|cnt
operator|>
name|size
condition|)
name|size
operator|=
name|cnt
expr_stmt|;
name|size
operator|=
name|round_page
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|buffer
operator|=
operator|(
name|caddr_t
operator|)
name|vm_map_min
argument_list|(
name|pipe_map
argument_list|)
expr_stmt|;
name|error
operator|=
name|vm_map_find
argument_list|(
name|pipe_map
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
operator|(
name|vm_offset_t
operator|*
operator|)
operator|&
name|buffer
argument_list|,
name|size
argument_list|,
literal|1
argument_list|,
name|VM_PROT_ALL
argument_list|,
name|VM_PROT_ALL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
name|KERN_SUCCESS
condition|)
block|{
if|if
condition|(
operator|(
name|cpipe
operator|->
name|pipe_buffer
operator|.
name|buffer
operator|==
name|NULL
operator|)
operator|&&
operator|(
name|size
operator|>
name|SMALL_PIPE_SIZE
operator|)
condition|)
block|{
name|size
operator|=
name|SMALL_PIPE_SIZE
expr_stmt|;
name|pipefragretry
operator|++
expr_stmt|;
goto|goto
name|retry
goto|;
block|}
if|if
condition|(
name|cpipe
operator|->
name|pipe_buffer
operator|.
name|buffer
operator|==
name|NULL
condition|)
block|{
name|pipeallocfail
operator|++
expr_stmt|;
if|if
condition|(
name|ppsratecheck
argument_list|(
operator|&
name|lastfail
argument_list|,
operator|&
name|curfail
argument_list|,
literal|1
argument_list|)
condition|)
name|printf
argument_list|(
literal|"kern.ipc.maxpipekva exceeded; see tuning(7)\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|piperesizefail
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
comment|/* copy data, then free old resources if we're resizing */
if|if
condition|(
name|cnt
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|cpipe
operator|->
name|pipe_buffer
operator|.
name|in
operator|<=
name|cpipe
operator|->
name|pipe_buffer
operator|.
name|out
condition|)
block|{
name|firstseg
operator|=
name|cpipe
operator|->
name|pipe_buffer
operator|.
name|size
operator|-
name|cpipe
operator|->
name|pipe_buffer
operator|.
name|out
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|cpipe
operator|->
name|pipe_buffer
operator|.
name|buffer
index|[
name|cpipe
operator|->
name|pipe_buffer
operator|.
name|out
index|]
argument_list|,
name|buffer
argument_list|,
name|firstseg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cnt
operator|-
name|firstseg
operator|)
operator|>
literal|0
condition|)
name|bcopy
argument_list|(
name|cpipe
operator|->
name|pipe_buffer
operator|.
name|buffer
argument_list|,
operator|&
name|buffer
index|[
name|firstseg
index|]
argument_list|,
name|cpipe
operator|->
name|pipe_buffer
operator|.
name|in
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bcopy
argument_list|(
operator|&
name|cpipe
operator|->
name|pipe_buffer
operator|.
name|buffer
index|[
name|cpipe
operator|->
name|pipe_buffer
operator|.
name|out
index|]
argument_list|,
name|buffer
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
block|}
block|}
name|pipe_free_kmem
argument_list|(
name|cpipe
argument_list|)
expr_stmt|;
name|cpipe
operator|->
name|pipe_buffer
operator|.
name|buffer
operator|=
name|buffer
expr_stmt|;
name|cpipe
operator|->
name|pipe_buffer
operator|.
name|size
operator|=
name|size
expr_stmt|;
name|cpipe
operator|->
name|pipe_buffer
operator|.
name|in
operator|=
name|cnt
expr_stmt|;
name|cpipe
operator|->
name|pipe_buffer
operator|.
name|out
operator|=
literal|0
expr_stmt|;
name|cpipe
operator|->
name|pipe_buffer
operator|.
name|cnt
operator|=
name|cnt
expr_stmt|;
name|atomic_add_int
argument_list|(
operator|&
name|amountpipekva
argument_list|,
name|cpipe
operator|->
name|pipe_buffer
operator|.
name|size
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Wrapper for pipespace_new() that performs locking assertions.  */
end_comment

begin_function
specifier|static
name|int
name|pipespace
parameter_list|(
name|cpipe
parameter_list|,
name|size
parameter_list|)
name|struct
name|pipe
modifier|*
name|cpipe
decl_stmt|;
name|int
name|size
decl_stmt|;
block|{
name|KASSERT
argument_list|(
name|cpipe
operator|->
name|pipe_state
operator|&
name|PIPE_LOCKFL
argument_list|,
operator|(
literal|"Unlocked pipe passed to pipespace"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|pipespace_new
argument_list|(
name|cpipe
argument_list|,
name|size
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * lock a pipe for I/O, blocking other access  */
end_comment

begin_function
specifier|static
name|__inline
name|int
name|pipelock
parameter_list|(
name|cpipe
parameter_list|,
name|catch
parameter_list|)
name|struct
name|pipe
modifier|*
name|cpipe
decl_stmt|;
name|int
name|catch
decl_stmt|;
block|{
name|int
name|error
decl_stmt|;
name|PIPE_LOCK_ASSERT
argument_list|(
name|cpipe
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
while|while
condition|(
name|cpipe
operator|->
name|pipe_state
operator|&
name|PIPE_LOCKFL
condition|)
block|{
name|cpipe
operator|->
name|pipe_state
operator||=
name|PIPE_LWANT
expr_stmt|;
name|error
operator|=
name|msleep
argument_list|(
name|cpipe
argument_list|,
name|PIPE_MTX
argument_list|(
name|cpipe
argument_list|)
argument_list|,
name|catch
condition|?
operator|(
name|PRIBIO
operator||
name|PCATCH
operator|)
else|:
name|PRIBIO
argument_list|,
literal|"pipelk"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
name|cpipe
operator|->
name|pipe_state
operator||=
name|PIPE_LOCKFL
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * unlock a pipe I/O lock  */
end_comment

begin_function
specifier|static
name|__inline
name|void
name|pipeunlock
parameter_list|(
name|cpipe
parameter_list|)
name|struct
name|pipe
modifier|*
name|cpipe
decl_stmt|;
block|{
name|PIPE_LOCK_ASSERT
argument_list|(
name|cpipe
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|cpipe
operator|->
name|pipe_state
operator|&
name|PIPE_LOCKFL
argument_list|,
operator|(
literal|"Unlocked pipe passed to pipeunlock"
operator|)
argument_list|)
expr_stmt|;
name|cpipe
operator|->
name|pipe_state
operator|&=
operator|~
name|PIPE_LOCKFL
expr_stmt|;
if|if
condition|(
name|cpipe
operator|->
name|pipe_state
operator|&
name|PIPE_LWANT
condition|)
block|{
name|cpipe
operator|->
name|pipe_state
operator|&=
operator|~
name|PIPE_LWANT
expr_stmt|;
name|wakeup
argument_list|(
name|cpipe
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|pipeselwakeup
parameter_list|(
name|cpipe
parameter_list|)
name|struct
name|pipe
modifier|*
name|cpipe
decl_stmt|;
block|{
name|PIPE_LOCK_ASSERT
argument_list|(
name|cpipe
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
if|if
condition|(
name|cpipe
operator|->
name|pipe_state
operator|&
name|PIPE_SEL
condition|)
block|{
name|cpipe
operator|->
name|pipe_state
operator|&=
operator|~
name|PIPE_SEL
expr_stmt|;
name|selwakeuppri
argument_list|(
operator|&
name|cpipe
operator|->
name|pipe_sel
argument_list|,
name|PSOCK
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|cpipe
operator|->
name|pipe_state
operator|&
name|PIPE_ASYNC
operator|)
operator|&&
name|cpipe
operator|->
name|pipe_sigio
condition|)
name|pgsigio
argument_list|(
operator|&
name|cpipe
operator|->
name|pipe_sigio
argument_list|,
name|SIGIO
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|KNOTE_LOCKED
argument_list|(
operator|&
name|cpipe
operator|->
name|pipe_sel
operator|.
name|si_note
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Initialize and allocate VM and memory for pipe.  The structure  * will start out zero'd from the ctor, so we just manage the kmem.  */
end_comment

begin_function
specifier|static
name|int
name|pipe_create
parameter_list|(
name|pipe
parameter_list|,
name|backing
parameter_list|)
name|struct
name|pipe
modifier|*
name|pipe
decl_stmt|;
name|int
name|backing
decl_stmt|;
block|{
name|int
name|error
decl_stmt|;
if|if
condition|(
name|backing
condition|)
block|{
if|if
condition|(
name|amountpipekva
operator|>
name|maxpipekva
operator|/
literal|2
condition|)
name|error
operator|=
name|pipespace_new
argument_list|(
name|pipe
argument_list|,
name|SMALL_PIPE_SIZE
argument_list|)
expr_stmt|;
else|else
name|error
operator|=
name|pipespace_new
argument_list|(
name|pipe
argument_list|,
name|PIPE_SIZE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* If we're not backing this pipe, no need to do anything. */
name|error
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|pipe_read
parameter_list|(
name|fp
parameter_list|,
name|uio
parameter_list|,
name|active_cred
parameter_list|,
name|flags
parameter_list|,
name|td
parameter_list|)
name|struct
name|file
modifier|*
name|fp
decl_stmt|;
name|struct
name|uio
modifier|*
name|uio
decl_stmt|;
name|struct
name|ucred
modifier|*
name|active_cred
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|{
name|struct
name|pipe
modifier|*
name|rpipe
init|=
name|fp
operator|->
name|f_data
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|nread
init|=
literal|0
decl_stmt|;
name|u_int
name|size
decl_stmt|;
name|PIPE_LOCK
argument_list|(
name|rpipe
argument_list|)
expr_stmt|;
operator|++
name|rpipe
operator|->
name|pipe_busy
expr_stmt|;
name|error
operator|=
name|pipelock
argument_list|(
name|rpipe
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|unlocked_error
goto|;
ifdef|#
directive|ifdef
name|MAC
name|error
operator|=
name|mac_check_pipe_read
argument_list|(
name|active_cred
argument_list|,
name|rpipe
operator|->
name|pipe_pair
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|locked_error
goto|;
endif|#
directive|endif
if|if
condition|(
name|amountpipekva
operator|>
operator|(
literal|3
operator|*
name|maxpipekva
operator|)
operator|/
literal|4
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|rpipe
operator|->
name|pipe_state
operator|&
name|PIPE_DIRECTW
operator|)
operator|&&
operator|(
name|rpipe
operator|->
name|pipe_buffer
operator|.
name|size
operator|>
name|SMALL_PIPE_SIZE
operator|)
operator|&&
operator|(
name|rpipe
operator|->
name|pipe_buffer
operator|.
name|cnt
operator|<=
name|SMALL_PIPE_SIZE
operator|)
operator|&&
operator|(
name|piperesizeallowed
operator|==
literal|1
operator|)
condition|)
block|{
name|PIPE_UNLOCK
argument_list|(
name|rpipe
argument_list|)
expr_stmt|;
name|pipespace
argument_list|(
name|rpipe
argument_list|,
name|SMALL_PIPE_SIZE
argument_list|)
expr_stmt|;
name|PIPE_LOCK
argument_list|(
name|rpipe
argument_list|)
expr_stmt|;
block|}
block|}
while|while
condition|(
name|uio
operator|->
name|uio_resid
condition|)
block|{
comment|/* 		 * normal pipe buffer receive 		 */
if|if
condition|(
name|rpipe
operator|->
name|pipe_buffer
operator|.
name|cnt
operator|>
literal|0
condition|)
block|{
name|size
operator|=
name|rpipe
operator|->
name|pipe_buffer
operator|.
name|size
operator|-
name|rpipe
operator|->
name|pipe_buffer
operator|.
name|out
expr_stmt|;
if|if
condition|(
name|size
operator|>
name|rpipe
operator|->
name|pipe_buffer
operator|.
name|cnt
condition|)
name|size
operator|=
name|rpipe
operator|->
name|pipe_buffer
operator|.
name|cnt
expr_stmt|;
if|if
condition|(
name|size
operator|>
operator|(
name|u_int
operator|)
name|uio
operator|->
name|uio_resid
condition|)
name|size
operator|=
operator|(
name|u_int
operator|)
name|uio
operator|->
name|uio_resid
expr_stmt|;
name|PIPE_UNLOCK
argument_list|(
name|rpipe
argument_list|)
expr_stmt|;
name|error
operator|=
name|uiomove
argument_list|(
operator|&
name|rpipe
operator|->
name|pipe_buffer
operator|.
name|buffer
index|[
name|rpipe
operator|->
name|pipe_buffer
operator|.
name|out
index|]
argument_list|,
name|size
argument_list|,
name|uio
argument_list|)
expr_stmt|;
name|PIPE_LOCK
argument_list|(
name|rpipe
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
name|rpipe
operator|->
name|pipe_buffer
operator|.
name|out
operator|+=
name|size
expr_stmt|;
if|if
condition|(
name|rpipe
operator|->
name|pipe_buffer
operator|.
name|out
operator|>=
name|rpipe
operator|->
name|pipe_buffer
operator|.
name|size
condition|)
name|rpipe
operator|->
name|pipe_buffer
operator|.
name|out
operator|=
literal|0
expr_stmt|;
name|rpipe
operator|->
name|pipe_buffer
operator|.
name|cnt
operator|-=
name|size
expr_stmt|;
comment|/* 			 * If there is no more to read in the pipe, reset 			 * its pointers to the beginning.  This improves 			 * cache hit stats. 			 */
if|if
condition|(
name|rpipe
operator|->
name|pipe_buffer
operator|.
name|cnt
operator|==
literal|0
condition|)
block|{
name|rpipe
operator|->
name|pipe_buffer
operator|.
name|in
operator|=
literal|0
expr_stmt|;
name|rpipe
operator|->
name|pipe_buffer
operator|.
name|out
operator|=
literal|0
expr_stmt|;
block|}
name|nread
operator|+=
name|size
expr_stmt|;
ifndef|#
directive|ifndef
name|PIPE_NODIRECT
comment|/* 		 * Direct copy, bypassing a kernel buffer. 		 */
block|}
elseif|else
if|if
condition|(
operator|(
name|size
operator|=
name|rpipe
operator|->
name|pipe_map
operator|.
name|cnt
operator|)
operator|&&
operator|(
name|rpipe
operator|->
name|pipe_state
operator|&
name|PIPE_DIRECTW
operator|)
condition|)
block|{
if|if
condition|(
name|size
operator|>
operator|(
name|u_int
operator|)
name|uio
operator|->
name|uio_resid
condition|)
name|size
operator|=
operator|(
name|u_int
operator|)
name|uio
operator|->
name|uio_resid
expr_stmt|;
name|PIPE_UNLOCK
argument_list|(
name|rpipe
argument_list|)
expr_stmt|;
name|error
operator|=
name|uiomove_fromphys
argument_list|(
name|rpipe
operator|->
name|pipe_map
operator|.
name|ms
argument_list|,
name|rpipe
operator|->
name|pipe_map
operator|.
name|pos
argument_list|,
name|size
argument_list|,
name|uio
argument_list|)
expr_stmt|;
name|PIPE_LOCK
argument_list|(
name|rpipe
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
name|nread
operator|+=
name|size
expr_stmt|;
name|rpipe
operator|->
name|pipe_map
operator|.
name|pos
operator|+=
name|size
expr_stmt|;
name|rpipe
operator|->
name|pipe_map
operator|.
name|cnt
operator|-=
name|size
expr_stmt|;
if|if
condition|(
name|rpipe
operator|->
name|pipe_map
operator|.
name|cnt
operator|==
literal|0
condition|)
block|{
name|rpipe
operator|->
name|pipe_state
operator|&=
operator|~
name|PIPE_DIRECTW
expr_stmt|;
name|wakeup
argument_list|(
name|rpipe
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
else|else
block|{
comment|/* 			 * detect EOF condition 			 * read returns 0 on EOF, no need to set error 			 */
if|if
condition|(
name|rpipe
operator|->
name|pipe_state
operator|&
name|PIPE_EOF
condition|)
break|break;
comment|/* 			 * If the "write-side" has been blocked, wake it up now. 			 */
if|if
condition|(
name|rpipe
operator|->
name|pipe_state
operator|&
name|PIPE_WANTW
condition|)
block|{
name|rpipe
operator|->
name|pipe_state
operator|&=
operator|~
name|PIPE_WANTW
expr_stmt|;
name|wakeup
argument_list|(
name|rpipe
argument_list|)
expr_stmt|;
block|}
comment|/* 			 * Break if some data was read. 			 */
if|if
condition|(
name|nread
operator|>
literal|0
condition|)
break|break;
comment|/* 			 * Unlock the pipe buffer for our remaining processing. 			 * We will either break out with an error or we will 			 * sleep and relock to loop. 			 */
name|pipeunlock
argument_list|(
name|rpipe
argument_list|)
expr_stmt|;
comment|/* 			 * Handle non-blocking mode operation or 			 * wait for more data. 			 */
if|if
condition|(
name|fp
operator|->
name|f_flag
operator|&
name|FNONBLOCK
condition|)
block|{
name|error
operator|=
name|EAGAIN
expr_stmt|;
block|}
else|else
block|{
name|rpipe
operator|->
name|pipe_state
operator||=
name|PIPE_WANTR
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|msleep
argument_list|(
name|rpipe
argument_list|,
name|PIPE_MTX
argument_list|(
name|rpipe
argument_list|)
argument_list|,
name|PRIBIO
operator||
name|PCATCH
argument_list|,
literal|"piperd"
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
literal|0
condition|)
name|error
operator|=
name|pipelock
argument_list|(
name|rpipe
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
condition|)
goto|goto
name|unlocked_error
goto|;
block|}
block|}
ifdef|#
directive|ifdef
name|MAC
name|locked_error
label|:
endif|#
directive|endif
name|pipeunlock
argument_list|(
name|rpipe
argument_list|)
expr_stmt|;
comment|/* XXX: should probably do this before getting any locks. */
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|vfs_timestamp
argument_list|(
operator|&
name|rpipe
operator|->
name|pipe_atime
argument_list|)
expr_stmt|;
name|unlocked_error
label|:
operator|--
name|rpipe
operator|->
name|pipe_busy
expr_stmt|;
comment|/* 	 * PIPE_WANT processing only makes sense if pipe_busy is 0. 	 */
if|if
condition|(
operator|(
name|rpipe
operator|->
name|pipe_busy
operator|==
literal|0
operator|)
operator|&&
operator|(
name|rpipe
operator|->
name|pipe_state
operator|&
name|PIPE_WANT
operator|)
condition|)
block|{
name|rpipe
operator|->
name|pipe_state
operator|&=
operator|~
operator|(
name|PIPE_WANT
operator||
name|PIPE_WANTW
operator|)
expr_stmt|;
name|wakeup
argument_list|(
name|rpipe
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rpipe
operator|->
name|pipe_buffer
operator|.
name|cnt
operator|<
name|MINPIPESIZE
condition|)
block|{
comment|/* 		 * Handle write blocking hysteresis. 		 */
if|if
condition|(
name|rpipe
operator|->
name|pipe_state
operator|&
name|PIPE_WANTW
condition|)
block|{
name|rpipe
operator|->
name|pipe_state
operator|&=
operator|~
name|PIPE_WANTW
expr_stmt|;
name|wakeup
argument_list|(
name|rpipe
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|rpipe
operator|->
name|pipe_buffer
operator|.
name|size
operator|-
name|rpipe
operator|->
name|pipe_buffer
operator|.
name|cnt
operator|)
operator|>=
name|PIPE_BUF
condition|)
name|pipeselwakeup
argument_list|(
name|rpipe
argument_list|)
expr_stmt|;
name|PIPE_UNLOCK
argument_list|(
name|rpipe
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|PIPE_NODIRECT
end_ifndef

begin_comment
comment|/*  * Map the sending processes' buffer into kernel space and wire it.  * This is similar to a physical write operation.  */
end_comment

begin_function
specifier|static
name|int
name|pipe_build_write_buffer
parameter_list|(
name|wpipe
parameter_list|,
name|uio
parameter_list|)
name|struct
name|pipe
modifier|*
name|wpipe
decl_stmt|;
name|struct
name|uio
modifier|*
name|uio
decl_stmt|;
block|{
name|pmap_t
name|pmap
decl_stmt|;
name|u_int
name|size
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|vm_offset_t
name|addr
decl_stmt|,
name|endaddr
decl_stmt|;
name|PIPE_LOCK_ASSERT
argument_list|(
name|wpipe
argument_list|,
name|MA_NOTOWNED
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|wpipe
operator|->
name|pipe_state
operator|&
name|PIPE_DIRECTW
argument_list|,
operator|(
literal|"Clone attempt on non-direct write pipe!"
operator|)
argument_list|)
expr_stmt|;
name|size
operator|=
operator|(
name|u_int
operator|)
name|uio
operator|->
name|uio_iov
operator|->
name|iov_len
expr_stmt|;
if|if
condition|(
name|size
operator|>
name|wpipe
operator|->
name|pipe_buffer
operator|.
name|size
condition|)
name|size
operator|=
name|wpipe
operator|->
name|pipe_buffer
operator|.
name|size
expr_stmt|;
name|pmap
operator|=
name|vmspace_pmap
argument_list|(
name|curproc
operator|->
name|p_vmspace
argument_list|)
expr_stmt|;
name|endaddr
operator|=
name|round_page
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|uio
operator|->
name|uio_iov
operator|->
name|iov_base
operator|+
name|size
argument_list|)
expr_stmt|;
name|addr
operator|=
name|trunc_page
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|uio
operator|->
name|uio_iov
operator|->
name|iov_base
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|addr
operator|<
name|endaddr
condition|;
name|addr
operator|+=
name|PAGE_SIZE
operator|,
name|i
operator|++
control|)
block|{
comment|/* 		 * vm_fault_quick() can sleep.  Consequently, 		 * vm_page_lock_queue() and vm_page_unlock_queue() 		 * should not be performed outside of this loop. 		 */
name|race
label|:
if|if
condition|(
name|vm_fault_quick
argument_list|(
operator|(
name|caddr_t
operator|)
name|addr
argument_list|,
name|VM_PROT_READ
argument_list|)
operator|<
literal|0
condition|)
block|{
name|vm_page_lock_queues
argument_list|()
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|i
condition|;
name|j
operator|++
control|)
name|vm_page_unhold
argument_list|(
name|wpipe
operator|->
name|pipe_map
operator|.
name|ms
index|[
name|j
index|]
argument_list|)
expr_stmt|;
name|vm_page_unlock_queues
argument_list|()
expr_stmt|;
return|return
operator|(
name|EFAULT
operator|)
return|;
block|}
name|wpipe
operator|->
name|pipe_map
operator|.
name|ms
index|[
name|i
index|]
operator|=
name|pmap_extract_and_hold
argument_list|(
name|pmap
argument_list|,
name|addr
argument_list|,
name|VM_PROT_READ
argument_list|)
expr_stmt|;
if|if
condition|(
name|wpipe
operator|->
name|pipe_map
operator|.
name|ms
index|[
name|i
index|]
operator|==
name|NULL
condition|)
goto|goto
name|race
goto|;
block|}
comment|/*  * set up the control block  */
name|wpipe
operator|->
name|pipe_map
operator|.
name|npages
operator|=
name|i
expr_stmt|;
name|wpipe
operator|->
name|pipe_map
operator|.
name|pos
operator|=
operator|(
operator|(
name|vm_offset_t
operator|)
name|uio
operator|->
name|uio_iov
operator|->
name|iov_base
operator|)
operator|&
name|PAGE_MASK
expr_stmt|;
name|wpipe
operator|->
name|pipe_map
operator|.
name|cnt
operator|=
name|size
expr_stmt|;
comment|/*  * and update the uio data  */
name|uio
operator|->
name|uio_iov
operator|->
name|iov_len
operator|-=
name|size
expr_stmt|;
name|uio
operator|->
name|uio_iov
operator|->
name|iov_base
operator|=
operator|(
name|char
operator|*
operator|)
name|uio
operator|->
name|uio_iov
operator|->
name|iov_base
operator|+
name|size
expr_stmt|;
if|if
condition|(
name|uio
operator|->
name|uio_iov
operator|->
name|iov_len
operator|==
literal|0
condition|)
name|uio
operator|->
name|uio_iov
operator|++
expr_stmt|;
name|uio
operator|->
name|uio_resid
operator|-=
name|size
expr_stmt|;
name|uio
operator|->
name|uio_offset
operator|+=
name|size
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * unmap and unwire the process buffer  */
end_comment

begin_function
specifier|static
name|void
name|pipe_destroy_write_buffer
parameter_list|(
name|wpipe
parameter_list|)
name|struct
name|pipe
modifier|*
name|wpipe
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|PIPE_LOCK_ASSERT
argument_list|(
name|wpipe
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|vm_page_lock_queues
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|wpipe
operator|->
name|pipe_map
operator|.
name|npages
condition|;
name|i
operator|++
control|)
block|{
name|vm_page_unhold
argument_list|(
name|wpipe
operator|->
name|pipe_map
operator|.
name|ms
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|vm_page_unlock_queues
argument_list|()
expr_stmt|;
name|wpipe
operator|->
name|pipe_map
operator|.
name|npages
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * In the case of a signal, the writing process might go away.  This  * code copies the data into the circular buffer so that the source  * pages can be freed without loss of data.  */
end_comment

begin_function
specifier|static
name|void
name|pipe_clone_write_buffer
parameter_list|(
name|wpipe
parameter_list|)
name|struct
name|pipe
modifier|*
name|wpipe
decl_stmt|;
block|{
name|struct
name|uio
name|uio
decl_stmt|;
name|struct
name|iovec
name|iov
decl_stmt|;
name|int
name|size
decl_stmt|;
name|int
name|pos
decl_stmt|;
name|PIPE_LOCK_ASSERT
argument_list|(
name|wpipe
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|size
operator|=
name|wpipe
operator|->
name|pipe_map
operator|.
name|cnt
expr_stmt|;
name|pos
operator|=
name|wpipe
operator|->
name|pipe_map
operator|.
name|pos
expr_stmt|;
name|wpipe
operator|->
name|pipe_buffer
operator|.
name|in
operator|=
name|size
expr_stmt|;
name|wpipe
operator|->
name|pipe_buffer
operator|.
name|out
operator|=
literal|0
expr_stmt|;
name|wpipe
operator|->
name|pipe_buffer
operator|.
name|cnt
operator|=
name|size
expr_stmt|;
name|wpipe
operator|->
name|pipe_state
operator|&=
operator|~
name|PIPE_DIRECTW
expr_stmt|;
name|PIPE_UNLOCK
argument_list|(
name|wpipe
argument_list|)
expr_stmt|;
name|iov
operator|.
name|iov_base
operator|=
name|wpipe
operator|->
name|pipe_buffer
operator|.
name|buffer
expr_stmt|;
name|iov
operator|.
name|iov_len
operator|=
name|size
expr_stmt|;
name|uio
operator|.
name|uio_iov
operator|=
operator|&
name|iov
expr_stmt|;
name|uio
operator|.
name|uio_iovcnt
operator|=
literal|1
expr_stmt|;
name|uio
operator|.
name|uio_offset
operator|=
literal|0
expr_stmt|;
name|uio
operator|.
name|uio_resid
operator|=
name|size
expr_stmt|;
name|uio
operator|.
name|uio_segflg
operator|=
name|UIO_SYSSPACE
expr_stmt|;
name|uio
operator|.
name|uio_rw
operator|=
name|UIO_READ
expr_stmt|;
name|uio
operator|.
name|uio_td
operator|=
name|curthread
expr_stmt|;
name|uiomove_fromphys
argument_list|(
name|wpipe
operator|->
name|pipe_map
operator|.
name|ms
argument_list|,
name|pos
argument_list|,
name|size
argument_list|,
operator|&
name|uio
argument_list|)
expr_stmt|;
name|PIPE_LOCK
argument_list|(
name|wpipe
argument_list|)
expr_stmt|;
name|pipe_destroy_write_buffer
argument_list|(
name|wpipe
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This implements the pipe buffer write mechanism.  Note that only  * a direct write OR a normal pipe write can be pending at any given time.  * If there are any characters in the pipe buffer, the direct write will  * be deferred until the receiving process grabs all of the bytes from  * the pipe buffer.  Then the direct mapping write is set-up.  */
end_comment

begin_function
specifier|static
name|int
name|pipe_direct_write
parameter_list|(
name|wpipe
parameter_list|,
name|uio
parameter_list|)
name|struct
name|pipe
modifier|*
name|wpipe
decl_stmt|;
name|struct
name|uio
modifier|*
name|uio
decl_stmt|;
block|{
name|int
name|error
decl_stmt|;
name|retry
label|:
name|PIPE_LOCK_ASSERT
argument_list|(
name|wpipe
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|error
operator|=
name|pipelock
argument_list|(
name|wpipe
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|wpipe
operator|->
name|pipe_state
operator|&
name|PIPE_EOF
condition|)
name|error
operator|=
name|EPIPE
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|pipeunlock
argument_list|(
name|wpipe
argument_list|)
expr_stmt|;
goto|goto
name|error1
goto|;
block|}
while|while
condition|(
name|wpipe
operator|->
name|pipe_state
operator|&
name|PIPE_DIRECTW
condition|)
block|{
if|if
condition|(
name|wpipe
operator|->
name|pipe_state
operator|&
name|PIPE_WANTR
condition|)
block|{
name|wpipe
operator|->
name|pipe_state
operator|&=
operator|~
name|PIPE_WANTR
expr_stmt|;
name|wakeup
argument_list|(
name|wpipe
argument_list|)
expr_stmt|;
block|}
name|wpipe
operator|->
name|pipe_state
operator||=
name|PIPE_WANTW
expr_stmt|;
name|pipeunlock
argument_list|(
name|wpipe
argument_list|)
expr_stmt|;
name|error
operator|=
name|msleep
argument_list|(
name|wpipe
argument_list|,
name|PIPE_MTX
argument_list|(
name|wpipe
argument_list|)
argument_list|,
name|PRIBIO
operator||
name|PCATCH
argument_list|,
literal|"pipdww"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|error1
goto|;
else|else
goto|goto
name|retry
goto|;
block|}
name|wpipe
operator|->
name|pipe_map
operator|.
name|cnt
operator|=
literal|0
expr_stmt|;
comment|/* transfer not ready yet */
if|if
condition|(
name|wpipe
operator|->
name|pipe_buffer
operator|.
name|cnt
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|wpipe
operator|->
name|pipe_state
operator|&
name|PIPE_WANTR
condition|)
block|{
name|wpipe
operator|->
name|pipe_state
operator|&=
operator|~
name|PIPE_WANTR
expr_stmt|;
name|wakeup
argument_list|(
name|wpipe
argument_list|)
expr_stmt|;
block|}
name|wpipe
operator|->
name|pipe_state
operator||=
name|PIPE_WANTW
expr_stmt|;
name|pipeunlock
argument_list|(
name|wpipe
argument_list|)
expr_stmt|;
name|error
operator|=
name|msleep
argument_list|(
name|wpipe
argument_list|,
name|PIPE_MTX
argument_list|(
name|wpipe
argument_list|)
argument_list|,
name|PRIBIO
operator||
name|PCATCH
argument_list|,
literal|"pipdwc"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|error1
goto|;
else|else
goto|goto
name|retry
goto|;
block|}
name|wpipe
operator|->
name|pipe_state
operator||=
name|PIPE_DIRECTW
expr_stmt|;
name|PIPE_UNLOCK
argument_list|(
name|wpipe
argument_list|)
expr_stmt|;
name|error
operator|=
name|pipe_build_write_buffer
argument_list|(
name|wpipe
argument_list|,
name|uio
argument_list|)
expr_stmt|;
name|PIPE_LOCK
argument_list|(
name|wpipe
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|wpipe
operator|->
name|pipe_state
operator|&=
operator|~
name|PIPE_DIRECTW
expr_stmt|;
name|pipeunlock
argument_list|(
name|wpipe
argument_list|)
expr_stmt|;
goto|goto
name|error1
goto|;
block|}
name|error
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|!
name|error
operator|&&
operator|(
name|wpipe
operator|->
name|pipe_state
operator|&
name|PIPE_DIRECTW
operator|)
condition|)
block|{
if|if
condition|(
name|wpipe
operator|->
name|pipe_state
operator|&
name|PIPE_EOF
condition|)
block|{
name|pipe_destroy_write_buffer
argument_list|(
name|wpipe
argument_list|)
expr_stmt|;
name|pipeselwakeup
argument_list|(
name|wpipe
argument_list|)
expr_stmt|;
name|pipeunlock
argument_list|(
name|wpipe
argument_list|)
expr_stmt|;
name|error
operator|=
name|EPIPE
expr_stmt|;
goto|goto
name|error1
goto|;
block|}
if|if
condition|(
name|wpipe
operator|->
name|pipe_state
operator|&
name|PIPE_WANTR
condition|)
block|{
name|wpipe
operator|->
name|pipe_state
operator|&=
operator|~
name|PIPE_WANTR
expr_stmt|;
name|wakeup
argument_list|(
name|wpipe
argument_list|)
expr_stmt|;
block|}
name|pipeselwakeup
argument_list|(
name|wpipe
argument_list|)
expr_stmt|;
name|pipeunlock
argument_list|(
name|wpipe
argument_list|)
expr_stmt|;
name|error
operator|=
name|msleep
argument_list|(
name|wpipe
argument_list|,
name|PIPE_MTX
argument_list|(
name|wpipe
argument_list|)
argument_list|,
name|PRIBIO
operator||
name|PCATCH
argument_list|,
literal|"pipdwt"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pipelock
argument_list|(
name|wpipe
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|wpipe
operator|->
name|pipe_state
operator|&
name|PIPE_EOF
condition|)
name|error
operator|=
name|EPIPE
expr_stmt|;
if|if
condition|(
name|wpipe
operator|->
name|pipe_state
operator|&
name|PIPE_DIRECTW
condition|)
block|{
comment|/* 		 * this bit of trickery substitutes a kernel buffer for 		 * the process that might be going away. 		 */
name|pipe_clone_write_buffer
argument_list|(
name|wpipe
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pipe_destroy_write_buffer
argument_list|(
name|wpipe
argument_list|)
expr_stmt|;
block|}
name|pipeunlock
argument_list|(
name|wpipe
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
name|error1
label|:
name|wakeup
argument_list|(
name|wpipe
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|int
name|pipe_write
parameter_list|(
name|fp
parameter_list|,
name|uio
parameter_list|,
name|active_cred
parameter_list|,
name|flags
parameter_list|,
name|td
parameter_list|)
name|struct
name|file
modifier|*
name|fp
decl_stmt|;
name|struct
name|uio
modifier|*
name|uio
decl_stmt|;
name|struct
name|ucred
modifier|*
name|active_cred
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
name|int
name|desiredsize
decl_stmt|,
name|orig_resid
decl_stmt|;
name|struct
name|pipe
modifier|*
name|wpipe
decl_stmt|,
modifier|*
name|rpipe
decl_stmt|;
name|rpipe
operator|=
name|fp
operator|->
name|f_data
expr_stmt|;
name|wpipe
operator|=
name|rpipe
operator|->
name|pipe_peer
expr_stmt|;
name|PIPE_LOCK
argument_list|(
name|rpipe
argument_list|)
expr_stmt|;
name|error
operator|=
name|pipelock
argument_list|(
name|wpipe
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|PIPE_UNLOCK
argument_list|(
name|rpipe
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* 	 * detect loss of pipe read side, issue SIGPIPE if lost. 	 */
if|if
condition|(
operator|(
operator|!
name|wpipe
operator|->
name|pipe_present
operator|)
operator|||
operator|(
name|wpipe
operator|->
name|pipe_state
operator|&
name|PIPE_EOF
operator|)
condition|)
block|{
name|pipeunlock
argument_list|(
name|wpipe
argument_list|)
expr_stmt|;
name|PIPE_UNLOCK
argument_list|(
name|rpipe
argument_list|)
expr_stmt|;
return|return
operator|(
name|EPIPE
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|MAC
name|error
operator|=
name|mac_check_pipe_write
argument_list|(
name|active_cred
argument_list|,
name|wpipe
operator|->
name|pipe_pair
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|pipeunlock
argument_list|(
name|wpipe
argument_list|)
expr_stmt|;
name|PIPE_UNLOCK
argument_list|(
name|rpipe
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
endif|#
directive|endif
operator|++
name|wpipe
operator|->
name|pipe_busy
expr_stmt|;
comment|/* Choose a larger size if it's advantageous */
name|desiredsize
operator|=
name|max
argument_list|(
name|SMALL_PIPE_SIZE
argument_list|,
name|wpipe
operator|->
name|pipe_buffer
operator|.
name|size
argument_list|)
expr_stmt|;
while|while
condition|(
name|desiredsize
operator|<
name|wpipe
operator|->
name|pipe_buffer
operator|.
name|cnt
operator|+
name|uio
operator|->
name|uio_resid
condition|)
block|{
if|if
condition|(
name|piperesizeallowed
operator|!=
literal|1
condition|)
break|break;
if|if
condition|(
name|amountpipekva
operator|>
name|maxpipekva
operator|/
literal|2
condition|)
break|break;
if|if
condition|(
name|desiredsize
operator|==
name|BIG_PIPE_SIZE
condition|)
break|break;
name|desiredsize
operator|=
name|desiredsize
operator|*
literal|2
expr_stmt|;
block|}
comment|/* Choose a smaller size if we're in a OOM situation */
if|if
condition|(
operator|(
name|amountpipekva
operator|>
operator|(
literal|3
operator|*
name|maxpipekva
operator|)
operator|/
literal|4
operator|)
operator|&&
operator|(
name|wpipe
operator|->
name|pipe_buffer
operator|.
name|size
operator|>
name|SMALL_PIPE_SIZE
operator|)
operator|&&
operator|(
name|wpipe
operator|->
name|pipe_buffer
operator|.
name|cnt
operator|<=
name|SMALL_PIPE_SIZE
operator|)
operator|&&
operator|(
name|piperesizeallowed
operator|==
literal|1
operator|)
condition|)
name|desiredsize
operator|=
name|SMALL_PIPE_SIZE
expr_stmt|;
comment|/* Resize if the above determined that a new size was necessary */
if|if
condition|(
operator|(
name|desiredsize
operator|!=
name|wpipe
operator|->
name|pipe_buffer
operator|.
name|size
operator|)
operator|&&
operator|(
operator|(
name|wpipe
operator|->
name|pipe_state
operator|&
name|PIPE_DIRECTW
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
name|PIPE_UNLOCK
argument_list|(
name|wpipe
argument_list|)
expr_stmt|;
name|pipespace
argument_list|(
name|wpipe
argument_list|,
name|desiredsize
argument_list|)
expr_stmt|;
name|PIPE_LOCK
argument_list|(
name|wpipe
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|wpipe
operator|->
name|pipe_buffer
operator|.
name|size
operator|==
literal|0
condition|)
block|{
comment|/* 		 * This can only happen for reverse direction use of pipes 		 * in a complete OOM situation. 		 */
name|error
operator|=
name|ENOMEM
expr_stmt|;
operator|--
name|wpipe
operator|->
name|pipe_busy
expr_stmt|;
name|pipeunlock
argument_list|(
name|wpipe
argument_list|)
expr_stmt|;
name|PIPE_UNLOCK
argument_list|(
name|wpipe
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|pipeunlock
argument_list|(
name|wpipe
argument_list|)
expr_stmt|;
name|orig_resid
operator|=
name|uio
operator|->
name|uio_resid
expr_stmt|;
while|while
condition|(
name|uio
operator|->
name|uio_resid
condition|)
block|{
name|int
name|space
decl_stmt|;
name|pipelock
argument_list|(
name|wpipe
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|wpipe
operator|->
name|pipe_state
operator|&
name|PIPE_EOF
condition|)
block|{
name|pipeunlock
argument_list|(
name|wpipe
argument_list|)
expr_stmt|;
name|error
operator|=
name|EPIPE
expr_stmt|;
break|break;
block|}
ifndef|#
directive|ifndef
name|PIPE_NODIRECT
comment|/* 		 * If the transfer is large, we can gain performance if 		 * we do process-to-process copies directly. 		 * If the write is non-blocking, we don't use the 		 * direct write mechanism. 		 * 		 * The direct write mechanism will detect the reader going 		 * away on us. 		 */
if|if
condition|(
name|uio
operator|->
name|uio_segflg
operator|==
name|UIO_USERSPACE
operator|&&
name|uio
operator|->
name|uio_iov
operator|->
name|iov_len
operator|>=
name|PIPE_MINDIRECT
operator|&&
name|wpipe
operator|->
name|pipe_buffer
operator|.
name|size
operator|>=
name|PIPE_MINDIRECT
operator|&&
operator|(
name|fp
operator|->
name|f_flag
operator|&
name|FNONBLOCK
operator|)
operator|==
literal|0
condition|)
block|{
name|pipeunlock
argument_list|(
name|wpipe
argument_list|)
expr_stmt|;
name|error
operator|=
name|pipe_direct_write
argument_list|(
name|wpipe
argument_list|,
name|uio
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
continue|continue;
block|}
endif|#
directive|endif
comment|/* 		 * Pipe buffered writes cannot be coincidental with 		 * direct writes.  We wait until the currently executing 		 * direct write is completed before we start filling the 		 * pipe buffer.  We break out if a signal occurs or the 		 * reader goes away. 		 */
if|if
condition|(
name|wpipe
operator|->
name|pipe_state
operator|&
name|PIPE_DIRECTW
condition|)
block|{
if|if
condition|(
name|wpipe
operator|->
name|pipe_state
operator|&
name|PIPE_WANTR
condition|)
block|{
name|wpipe
operator|->
name|pipe_state
operator|&=
operator|~
name|PIPE_WANTR
expr_stmt|;
name|wakeup
argument_list|(
name|wpipe
argument_list|)
expr_stmt|;
block|}
name|pipeunlock
argument_list|(
name|wpipe
argument_list|)
expr_stmt|;
name|error
operator|=
name|msleep
argument_list|(
name|wpipe
argument_list|,
name|PIPE_MTX
argument_list|(
name|rpipe
argument_list|)
argument_list|,
name|PRIBIO
operator||
name|PCATCH
argument_list|,
literal|"pipbww"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
else|else
continue|continue;
block|}
name|space
operator|=
name|wpipe
operator|->
name|pipe_buffer
operator|.
name|size
operator|-
name|wpipe
operator|->
name|pipe_buffer
operator|.
name|cnt
expr_stmt|;
comment|/* Writes of size<= PIPE_BUF must be atomic. */
if|if
condition|(
operator|(
name|space
operator|<
name|uio
operator|->
name|uio_resid
operator|)
operator|&&
operator|(
name|orig_resid
operator|<=
name|PIPE_BUF
operator|)
condition|)
name|space
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|space
operator|>
literal|0
condition|)
block|{
name|int
name|size
decl_stmt|;
comment|/* Transfer size */
name|int
name|segsize
decl_stmt|;
comment|/* first segment to transfer */
comment|/* 			 * Transfer size is minimum of uio transfer 			 * and free space in pipe buffer. 			 */
if|if
condition|(
name|space
operator|>
name|uio
operator|->
name|uio_resid
condition|)
name|size
operator|=
name|uio
operator|->
name|uio_resid
expr_stmt|;
else|else
name|size
operator|=
name|space
expr_stmt|;
comment|/* 			 * First segment to transfer is minimum of 			 * transfer size and contiguous space in 			 * pipe buffer.  If first segment to transfer 			 * is less than the transfer size, we've got 			 * a wraparound in the buffer. 			 */
name|segsize
operator|=
name|wpipe
operator|->
name|pipe_buffer
operator|.
name|size
operator|-
name|wpipe
operator|->
name|pipe_buffer
operator|.
name|in
expr_stmt|;
if|if
condition|(
name|segsize
operator|>
name|size
condition|)
name|segsize
operator|=
name|size
expr_stmt|;
comment|/* Transfer first segment */
name|PIPE_UNLOCK
argument_list|(
name|rpipe
argument_list|)
expr_stmt|;
name|error
operator|=
name|uiomove
argument_list|(
operator|&
name|wpipe
operator|->
name|pipe_buffer
operator|.
name|buffer
index|[
name|wpipe
operator|->
name|pipe_buffer
operator|.
name|in
index|]
argument_list|,
name|segsize
argument_list|,
name|uio
argument_list|)
expr_stmt|;
name|PIPE_LOCK
argument_list|(
name|rpipe
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
operator|&&
name|segsize
operator|<
name|size
condition|)
block|{
name|KASSERT
argument_list|(
name|wpipe
operator|->
name|pipe_buffer
operator|.
name|in
operator|+
name|segsize
operator|==
name|wpipe
operator|->
name|pipe_buffer
operator|.
name|size
argument_list|,
operator|(
literal|"Pipe buffer wraparound disappeared"
operator|)
argument_list|)
expr_stmt|;
comment|/* 				 * Transfer remaining part now, to 				 * support atomic writes.  Wraparound 				 * happened. 				 */
name|PIPE_UNLOCK
argument_list|(
name|rpipe
argument_list|)
expr_stmt|;
name|error
operator|=
name|uiomove
argument_list|(
operator|&
name|wpipe
operator|->
name|pipe_buffer
operator|.
name|buffer
index|[
literal|0
index|]
argument_list|,
name|size
operator|-
name|segsize
argument_list|,
name|uio
argument_list|)
expr_stmt|;
name|PIPE_LOCK
argument_list|(
name|rpipe
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|wpipe
operator|->
name|pipe_buffer
operator|.
name|in
operator|+=
name|size
expr_stmt|;
if|if
condition|(
name|wpipe
operator|->
name|pipe_buffer
operator|.
name|in
operator|>=
name|wpipe
operator|->
name|pipe_buffer
operator|.
name|size
condition|)
block|{
name|KASSERT
argument_list|(
name|wpipe
operator|->
name|pipe_buffer
operator|.
name|in
operator|==
name|size
operator|-
name|segsize
operator|+
name|wpipe
operator|->
name|pipe_buffer
operator|.
name|size
argument_list|,
operator|(
literal|"Expected wraparound bad"
operator|)
argument_list|)
expr_stmt|;
name|wpipe
operator|->
name|pipe_buffer
operator|.
name|in
operator|=
name|size
operator|-
name|segsize
expr_stmt|;
block|}
name|wpipe
operator|->
name|pipe_buffer
operator|.
name|cnt
operator|+=
name|size
expr_stmt|;
name|KASSERT
argument_list|(
name|wpipe
operator|->
name|pipe_buffer
operator|.
name|cnt
operator|<=
name|wpipe
operator|->
name|pipe_buffer
operator|.
name|size
argument_list|,
operator|(
literal|"Pipe buffer overflow"
operator|)
argument_list|)
expr_stmt|;
block|}
name|pipeunlock
argument_list|(
name|wpipe
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
break|break;
block|}
else|else
block|{
comment|/* 			 * If the "read-side" has been blocked, wake it up now. 			 */
if|if
condition|(
name|wpipe
operator|->
name|pipe_state
operator|&
name|PIPE_WANTR
condition|)
block|{
name|wpipe
operator|->
name|pipe_state
operator|&=
operator|~
name|PIPE_WANTR
expr_stmt|;
name|wakeup
argument_list|(
name|wpipe
argument_list|)
expr_stmt|;
block|}
comment|/* 			 * don't block on non-blocking I/O 			 */
if|if
condition|(
name|fp
operator|->
name|f_flag
operator|&
name|FNONBLOCK
condition|)
block|{
name|error
operator|=
name|EAGAIN
expr_stmt|;
name|pipeunlock
argument_list|(
name|wpipe
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* 			 * We have no more space and have something to offer, 			 * wake up select/poll. 			 */
name|pipeselwakeup
argument_list|(
name|wpipe
argument_list|)
expr_stmt|;
name|wpipe
operator|->
name|pipe_state
operator||=
name|PIPE_WANTW
expr_stmt|;
name|pipeunlock
argument_list|(
name|wpipe
argument_list|)
expr_stmt|;
name|error
operator|=
name|msleep
argument_list|(
name|wpipe
argument_list|,
name|PIPE_MTX
argument_list|(
name|rpipe
argument_list|)
argument_list|,
name|PRIBIO
operator||
name|PCATCH
argument_list|,
literal|"pipewr"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
break|break;
block|}
block|}
name|pipelock
argument_list|(
name|wpipe
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|--
name|wpipe
operator|->
name|pipe_busy
expr_stmt|;
if|if
condition|(
operator|(
name|wpipe
operator|->
name|pipe_busy
operator|==
literal|0
operator|)
operator|&&
operator|(
name|wpipe
operator|->
name|pipe_state
operator|&
name|PIPE_WANT
operator|)
condition|)
block|{
name|wpipe
operator|->
name|pipe_state
operator|&=
operator|~
operator|(
name|PIPE_WANT
operator||
name|PIPE_WANTR
operator|)
expr_stmt|;
name|wakeup
argument_list|(
name|wpipe
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|wpipe
operator|->
name|pipe_buffer
operator|.
name|cnt
operator|>
literal|0
condition|)
block|{
comment|/* 		 * If we have put any characters in the buffer, we wake up 		 * the reader. 		 */
if|if
condition|(
name|wpipe
operator|->
name|pipe_state
operator|&
name|PIPE_WANTR
condition|)
block|{
name|wpipe
operator|->
name|pipe_state
operator|&=
operator|~
name|PIPE_WANTR
expr_stmt|;
name|wakeup
argument_list|(
name|wpipe
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * Don't return EPIPE if I/O was successful 	 */
if|if
condition|(
operator|(
name|wpipe
operator|->
name|pipe_buffer
operator|.
name|cnt
operator|==
literal|0
operator|)
operator|&&
operator|(
name|uio
operator|->
name|uio_resid
operator|==
literal|0
operator|)
operator|&&
operator|(
name|error
operator|==
name|EPIPE
operator|)
condition|)
block|{
name|error
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|vfs_timestamp
argument_list|(
operator|&
name|wpipe
operator|->
name|pipe_mtime
argument_list|)
expr_stmt|;
comment|/* 	 * We have something to offer, 	 * wake up select/poll. 	 */
if|if
condition|(
name|wpipe
operator|->
name|pipe_buffer
operator|.
name|cnt
condition|)
name|pipeselwakeup
argument_list|(
name|wpipe
argument_list|)
expr_stmt|;
name|pipeunlock
argument_list|(
name|wpipe
argument_list|)
expr_stmt|;
name|PIPE_UNLOCK
argument_list|(
name|rpipe
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * we implement a very minimal set of ioctls for compatibility with sockets.  */
end_comment

begin_function
specifier|static
name|int
name|pipe_ioctl
parameter_list|(
name|fp
parameter_list|,
name|cmd
parameter_list|,
name|data
parameter_list|,
name|active_cred
parameter_list|,
name|td
parameter_list|)
name|struct
name|file
modifier|*
name|fp
decl_stmt|;
name|u_long
name|cmd
decl_stmt|;
name|void
modifier|*
name|data
decl_stmt|;
name|struct
name|ucred
modifier|*
name|active_cred
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
block|{
name|struct
name|pipe
modifier|*
name|mpipe
init|=
name|fp
operator|->
name|f_data
decl_stmt|;
name|int
name|error
decl_stmt|;
name|PIPE_LOCK
argument_list|(
name|mpipe
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MAC
name|error
operator|=
name|mac_check_pipe_ioctl
argument_list|(
name|active_cred
argument_list|,
name|mpipe
operator|->
name|pipe_pair
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|PIPE_UNLOCK
argument_list|(
name|mpipe
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
endif|#
directive|endif
name|error
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|FIONBIO
case|:
break|break;
case|case
name|FIOASYNC
case|:
if|if
condition|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
condition|)
block|{
name|mpipe
operator|->
name|pipe_state
operator||=
name|PIPE_ASYNC
expr_stmt|;
block|}
else|else
block|{
name|mpipe
operator|->
name|pipe_state
operator|&=
operator|~
name|PIPE_ASYNC
expr_stmt|;
block|}
break|break;
case|case
name|FIONREAD
case|:
if|if
condition|(
name|mpipe
operator|->
name|pipe_state
operator|&
name|PIPE_DIRECTW
condition|)
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|mpipe
operator|->
name|pipe_map
operator|.
name|cnt
expr_stmt|;
else|else
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|mpipe
operator|->
name|pipe_buffer
operator|.
name|cnt
expr_stmt|;
break|break;
case|case
name|FIOSETOWN
case|:
name|PIPE_UNLOCK
argument_list|(
name|mpipe
argument_list|)
expr_stmt|;
name|error
operator|=
name|fsetown
argument_list|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
argument_list|,
operator|&
name|mpipe
operator|->
name|pipe_sigio
argument_list|)
expr_stmt|;
goto|goto
name|out_unlocked
goto|;
case|case
name|FIOGETOWN
case|:
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|fgetown
argument_list|(
operator|&
name|mpipe
operator|->
name|pipe_sigio
argument_list|)
expr_stmt|;
break|break;
comment|/* This is deprecated, FIOSETOWN should be used instead. */
case|case
name|TIOCSPGRP
case|:
name|PIPE_UNLOCK
argument_list|(
name|mpipe
argument_list|)
expr_stmt|;
name|error
operator|=
name|fsetown
argument_list|(
operator|-
operator|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|)
argument_list|,
operator|&
name|mpipe
operator|->
name|pipe_sigio
argument_list|)
expr_stmt|;
goto|goto
name|out_unlocked
goto|;
comment|/* This is deprecated, FIOGETOWN should be used instead. */
case|case
name|TIOCGPGRP
case|:
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
operator|-
name|fgetown
argument_list|(
operator|&
name|mpipe
operator|->
name|pipe_sigio
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|ENOTTY
expr_stmt|;
break|break;
block|}
name|PIPE_UNLOCK
argument_list|(
name|mpipe
argument_list|)
expr_stmt|;
name|out_unlocked
label|:
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pipe_poll
parameter_list|(
name|fp
parameter_list|,
name|events
parameter_list|,
name|active_cred
parameter_list|,
name|td
parameter_list|)
name|struct
name|file
modifier|*
name|fp
decl_stmt|;
name|int
name|events
decl_stmt|;
name|struct
name|ucred
modifier|*
name|active_cred
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
block|{
name|struct
name|pipe
modifier|*
name|rpipe
init|=
name|fp
operator|->
name|f_data
decl_stmt|;
name|struct
name|pipe
modifier|*
name|wpipe
decl_stmt|;
name|int
name|revents
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|MAC
name|int
name|error
decl_stmt|;
endif|#
directive|endif
name|wpipe
operator|=
name|rpipe
operator|->
name|pipe_peer
expr_stmt|;
name|PIPE_LOCK
argument_list|(
name|rpipe
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MAC
name|error
operator|=
name|mac_check_pipe_poll
argument_list|(
name|active_cred
argument_list|,
name|rpipe
operator|->
name|pipe_pair
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|locked_error
goto|;
endif|#
directive|endif
if|if
condition|(
name|events
operator|&
operator|(
name|POLLIN
operator||
name|POLLRDNORM
operator|)
condition|)
if|if
condition|(
operator|(
name|rpipe
operator|->
name|pipe_state
operator|&
name|PIPE_DIRECTW
operator|)
operator|||
operator|(
name|rpipe
operator|->
name|pipe_buffer
operator|.
name|cnt
operator|>
literal|0
operator|)
operator|||
operator|(
name|rpipe
operator|->
name|pipe_state
operator|&
name|PIPE_EOF
operator|)
condition|)
name|revents
operator||=
name|events
operator|&
operator|(
name|POLLIN
operator||
name|POLLRDNORM
operator|)
expr_stmt|;
if|if
condition|(
name|events
operator|&
operator|(
name|POLLOUT
operator||
name|POLLWRNORM
operator|)
condition|)
if|if
condition|(
operator|!
name|wpipe
operator|->
name|pipe_present
operator|||
operator|(
name|wpipe
operator|->
name|pipe_state
operator|&
name|PIPE_EOF
operator|)
operator|||
operator|(
operator|(
operator|(
name|wpipe
operator|->
name|pipe_state
operator|&
name|PIPE_DIRECTW
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|wpipe
operator|->
name|pipe_buffer
operator|.
name|size
operator|-
name|wpipe
operator|->
name|pipe_buffer
operator|.
name|cnt
operator|)
operator|>=
name|PIPE_BUF
operator|)
condition|)
name|revents
operator||=
name|events
operator|&
operator|(
name|POLLOUT
operator||
name|POLLWRNORM
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|rpipe
operator|->
name|pipe_state
operator|&
name|PIPE_EOF
operator|)
operator|||
operator|(
operator|!
name|wpipe
operator|->
name|pipe_present
operator|)
operator|||
operator|(
name|wpipe
operator|->
name|pipe_state
operator|&
name|PIPE_EOF
operator|)
condition|)
name|revents
operator||=
name|POLLHUP
expr_stmt|;
if|if
condition|(
name|revents
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|events
operator|&
operator|(
name|POLLIN
operator||
name|POLLRDNORM
operator|)
condition|)
block|{
name|selrecord
argument_list|(
name|td
argument_list|,
operator|&
name|rpipe
operator|->
name|pipe_sel
argument_list|)
expr_stmt|;
name|rpipe
operator|->
name|pipe_state
operator||=
name|PIPE_SEL
expr_stmt|;
block|}
if|if
condition|(
name|events
operator|&
operator|(
name|POLLOUT
operator||
name|POLLWRNORM
operator|)
condition|)
block|{
name|selrecord
argument_list|(
name|td
argument_list|,
operator|&
name|wpipe
operator|->
name|pipe_sel
argument_list|)
expr_stmt|;
name|wpipe
operator|->
name|pipe_state
operator||=
name|PIPE_SEL
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|MAC
name|locked_error
label|:
endif|#
directive|endif
name|PIPE_UNLOCK
argument_list|(
name|rpipe
argument_list|)
expr_stmt|;
return|return
operator|(
name|revents
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * We shouldn't need locks here as we're doing a read and this should  * be a natural race.  */
end_comment

begin_function
specifier|static
name|int
name|pipe_stat
parameter_list|(
name|fp
parameter_list|,
name|ub
parameter_list|,
name|active_cred
parameter_list|,
name|td
parameter_list|)
name|struct
name|file
modifier|*
name|fp
decl_stmt|;
name|struct
name|stat
modifier|*
name|ub
decl_stmt|;
name|struct
name|ucred
modifier|*
name|active_cred
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
block|{
name|struct
name|pipe
modifier|*
name|pipe
init|=
name|fp
operator|->
name|f_data
decl_stmt|;
ifdef|#
directive|ifdef
name|MAC
name|int
name|error
decl_stmt|;
name|PIPE_LOCK
argument_list|(
name|pipe
argument_list|)
expr_stmt|;
name|error
operator|=
name|mac_check_pipe_stat
argument_list|(
name|active_cred
argument_list|,
name|pipe
operator|->
name|pipe_pair
argument_list|)
expr_stmt|;
name|PIPE_UNLOCK
argument_list|(
name|pipe
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
endif|#
directive|endif
name|bzero
argument_list|(
name|ub
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ub
argument_list|)
argument_list|)
expr_stmt|;
name|ub
operator|->
name|st_mode
operator|=
name|S_IFIFO
expr_stmt|;
name|ub
operator|->
name|st_blksize
operator|=
name|PAGE_SIZE
expr_stmt|;
if|if
condition|(
name|pipe
operator|->
name|pipe_state
operator|&
name|PIPE_DIRECTW
condition|)
name|ub
operator|->
name|st_size
operator|=
name|pipe
operator|->
name|pipe_map
operator|.
name|cnt
expr_stmt|;
else|else
name|ub
operator|->
name|st_size
operator|=
name|pipe
operator|->
name|pipe_buffer
operator|.
name|cnt
expr_stmt|;
name|ub
operator|->
name|st_blocks
operator|=
operator|(
name|ub
operator|->
name|st_size
operator|+
name|ub
operator|->
name|st_blksize
operator|-
literal|1
operator|)
operator|/
name|ub
operator|->
name|st_blksize
expr_stmt|;
name|ub
operator|->
name|st_atimespec
operator|=
name|pipe
operator|->
name|pipe_atime
expr_stmt|;
name|ub
operator|->
name|st_mtimespec
operator|=
name|pipe
operator|->
name|pipe_mtime
expr_stmt|;
name|ub
operator|->
name|st_ctimespec
operator|=
name|pipe
operator|->
name|pipe_ctime
expr_stmt|;
name|ub
operator|->
name|st_uid
operator|=
name|fp
operator|->
name|f_cred
operator|->
name|cr_uid
expr_stmt|;
name|ub
operator|->
name|st_gid
operator|=
name|fp
operator|->
name|f_cred
operator|->
name|cr_gid
expr_stmt|;
comment|/* 	 * Left as 0: st_dev, st_ino, st_nlink, st_rdev, st_flags, st_gen. 	 * XXX (st_dev, st_ino) should be unique. 	 */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|pipe_close
parameter_list|(
name|fp
parameter_list|,
name|td
parameter_list|)
name|struct
name|file
modifier|*
name|fp
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
block|{
name|struct
name|pipe
modifier|*
name|cpipe
init|=
name|fp
operator|->
name|f_data
decl_stmt|;
name|fp
operator|->
name|f_ops
operator|=
operator|&
name|badfileops
expr_stmt|;
name|fp
operator|->
name|f_data
operator|=
name|NULL
expr_stmt|;
name|funsetown
argument_list|(
operator|&
name|cpipe
operator|->
name|pipe_sigio
argument_list|)
expr_stmt|;
name|pipeclose
argument_list|(
name|cpipe
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|pipe_free_kmem
parameter_list|(
name|cpipe
parameter_list|)
name|struct
name|pipe
modifier|*
name|cpipe
decl_stmt|;
block|{
name|KASSERT
argument_list|(
operator|!
name|mtx_owned
argument_list|(
name|PIPE_MTX
argument_list|(
name|cpipe
argument_list|)
argument_list|)
argument_list|,
operator|(
literal|"pipe_free_kmem: pipe mutex locked"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cpipe
operator|->
name|pipe_buffer
operator|.
name|buffer
operator|!=
name|NULL
condition|)
block|{
name|atomic_subtract_int
argument_list|(
operator|&
name|amountpipekva
argument_list|,
name|cpipe
operator|->
name|pipe_buffer
operator|.
name|size
argument_list|)
expr_stmt|;
name|vm_map_remove
argument_list|(
name|pipe_map
argument_list|,
operator|(
name|vm_offset_t
operator|)
name|cpipe
operator|->
name|pipe_buffer
operator|.
name|buffer
argument_list|,
operator|(
name|vm_offset_t
operator|)
name|cpipe
operator|->
name|pipe_buffer
operator|.
name|buffer
operator|+
name|cpipe
operator|->
name|pipe_buffer
operator|.
name|size
argument_list|)
expr_stmt|;
name|cpipe
operator|->
name|pipe_buffer
operator|.
name|buffer
operator|=
name|NULL
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|PIPE_NODIRECT
block|{
name|cpipe
operator|->
name|pipe_map
operator|.
name|cnt
operator|=
literal|0
expr_stmt|;
name|cpipe
operator|->
name|pipe_map
operator|.
name|pos
operator|=
literal|0
expr_stmt|;
name|cpipe
operator|->
name|pipe_map
operator|.
name|npages
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * shutdown the pipe  */
end_comment

begin_function
specifier|static
name|void
name|pipeclose
parameter_list|(
name|cpipe
parameter_list|)
name|struct
name|pipe
modifier|*
name|cpipe
decl_stmt|;
block|{
name|struct
name|pipepair
modifier|*
name|pp
decl_stmt|;
name|struct
name|pipe
modifier|*
name|ppipe
decl_stmt|;
name|KASSERT
argument_list|(
name|cpipe
operator|!=
name|NULL
argument_list|,
operator|(
literal|"pipeclose: cpipe == NULL"
operator|)
argument_list|)
expr_stmt|;
name|PIPE_LOCK
argument_list|(
name|cpipe
argument_list|)
expr_stmt|;
name|pipelock
argument_list|(
name|cpipe
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pp
operator|=
name|cpipe
operator|->
name|pipe_pair
expr_stmt|;
name|pipeselwakeup
argument_list|(
name|cpipe
argument_list|)
expr_stmt|;
comment|/* 	 * If the other side is blocked, wake it up saying that 	 * we want to close it down. 	 */
name|cpipe
operator|->
name|pipe_state
operator||=
name|PIPE_EOF
expr_stmt|;
while|while
condition|(
name|cpipe
operator|->
name|pipe_busy
condition|)
block|{
name|wakeup
argument_list|(
name|cpipe
argument_list|)
expr_stmt|;
name|cpipe
operator|->
name|pipe_state
operator||=
name|PIPE_WANT
expr_stmt|;
name|pipeunlock
argument_list|(
name|cpipe
argument_list|)
expr_stmt|;
name|msleep
argument_list|(
name|cpipe
argument_list|,
name|PIPE_MTX
argument_list|(
name|cpipe
argument_list|)
argument_list|,
name|PRIBIO
argument_list|,
literal|"pipecl"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pipelock
argument_list|(
name|cpipe
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Disconnect from peer, if any. 	 */
name|ppipe
operator|=
name|cpipe
operator|->
name|pipe_peer
expr_stmt|;
if|if
condition|(
name|ppipe
operator|->
name|pipe_present
operator|!=
literal|0
condition|)
block|{
name|pipeselwakeup
argument_list|(
name|ppipe
argument_list|)
expr_stmt|;
name|ppipe
operator|->
name|pipe_state
operator||=
name|PIPE_EOF
expr_stmt|;
name|wakeup
argument_list|(
name|ppipe
argument_list|)
expr_stmt|;
name|KNOTE_LOCKED
argument_list|(
operator|&
name|ppipe
operator|->
name|pipe_sel
operator|.
name|si_note
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Mark this endpoint as free.  Release kmem resources.  We 	 * don't mark this endpoint as unused until we've finished 	 * doing that, or the pipe might disappear out from under 	 * us. 	 */
name|PIPE_UNLOCK
argument_list|(
name|cpipe
argument_list|)
expr_stmt|;
name|pipe_free_kmem
argument_list|(
name|cpipe
argument_list|)
expr_stmt|;
name|PIPE_LOCK
argument_list|(
name|cpipe
argument_list|)
expr_stmt|;
name|cpipe
operator|->
name|pipe_present
operator|=
literal|0
expr_stmt|;
name|pipeunlock
argument_list|(
name|cpipe
argument_list|)
expr_stmt|;
name|knlist_clear
argument_list|(
operator|&
name|cpipe
operator|->
name|pipe_sel
operator|.
name|si_note
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|knlist_destroy
argument_list|(
operator|&
name|cpipe
operator|->
name|pipe_sel
operator|.
name|si_note
argument_list|)
expr_stmt|;
comment|/* 	 * If both endpoints are now closed, release the memory for the 	 * pipe pair.  If not, unlock. 	 */
if|if
condition|(
name|ppipe
operator|->
name|pipe_present
operator|==
literal|0
condition|)
block|{
name|PIPE_UNLOCK
argument_list|(
name|cpipe
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MAC
name|mac_destroy_pipe
argument_list|(
name|pp
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|uma_zfree
argument_list|(
name|pipe_zone
argument_list|,
name|cpipe
operator|->
name|pipe_pair
argument_list|)
expr_stmt|;
block|}
else|else
name|PIPE_UNLOCK
argument_list|(
name|cpipe
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|int
name|pipe_kqfilter
parameter_list|(
name|struct
name|file
modifier|*
name|fp
parameter_list|,
name|struct
name|knote
modifier|*
name|kn
parameter_list|)
block|{
name|struct
name|pipe
modifier|*
name|cpipe
decl_stmt|;
name|cpipe
operator|=
name|kn
operator|->
name|kn_fp
operator|->
name|f_data
expr_stmt|;
name|PIPE_LOCK
argument_list|(
name|cpipe
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|kn
operator|->
name|kn_filter
condition|)
block|{
case|case
name|EVFILT_READ
case|:
name|kn
operator|->
name|kn_fop
operator|=
operator|&
name|pipe_rfiltops
expr_stmt|;
break|break;
case|case
name|EVFILT_WRITE
case|:
name|kn
operator|->
name|kn_fop
operator|=
operator|&
name|pipe_wfiltops
expr_stmt|;
if|if
condition|(
operator|!
name|cpipe
operator|->
name|pipe_peer
operator|->
name|pipe_present
condition|)
block|{
comment|/* other end of pipe has been closed */
name|PIPE_UNLOCK
argument_list|(
name|cpipe
argument_list|)
expr_stmt|;
return|return
operator|(
name|EPIPE
operator|)
return|;
block|}
name|cpipe
operator|=
name|cpipe
operator|->
name|pipe_peer
expr_stmt|;
break|break;
default|default:
name|PIPE_UNLOCK
argument_list|(
name|cpipe
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|knlist_add
argument_list|(
operator|&
name|cpipe
operator|->
name|pipe_sel
operator|.
name|si_note
argument_list|,
name|kn
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|PIPE_UNLOCK
argument_list|(
name|cpipe
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|filt_pipedetach
parameter_list|(
name|struct
name|knote
modifier|*
name|kn
parameter_list|)
block|{
name|struct
name|pipe
modifier|*
name|cpipe
init|=
operator|(
expr|struct
name|pipe
operator|*
operator|)
name|kn
operator|->
name|kn_fp
operator|->
name|f_data
decl_stmt|;
name|PIPE_LOCK
argument_list|(
name|cpipe
argument_list|)
expr_stmt|;
if|if
condition|(
name|kn
operator|->
name|kn_filter
operator|==
name|EVFILT_WRITE
condition|)
block|{
if|if
condition|(
operator|!
name|cpipe
operator|->
name|pipe_peer
operator|->
name|pipe_present
condition|)
block|{
name|PIPE_UNLOCK
argument_list|(
name|cpipe
argument_list|)
expr_stmt|;
return|return;
block|}
name|cpipe
operator|=
name|cpipe
operator|->
name|pipe_peer
expr_stmt|;
block|}
name|knlist_remove
argument_list|(
operator|&
name|cpipe
operator|->
name|pipe_sel
operator|.
name|si_note
argument_list|,
name|kn
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|PIPE_UNLOCK
argument_list|(
name|cpipe
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|int
name|filt_piperead
parameter_list|(
name|struct
name|knote
modifier|*
name|kn
parameter_list|,
name|long
name|hint
parameter_list|)
block|{
name|struct
name|pipe
modifier|*
name|rpipe
init|=
name|kn
operator|->
name|kn_fp
operator|->
name|f_data
decl_stmt|;
name|struct
name|pipe
modifier|*
name|wpipe
init|=
name|rpipe
operator|->
name|pipe_peer
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|PIPE_LOCK
argument_list|(
name|rpipe
argument_list|)
expr_stmt|;
name|kn
operator|->
name|kn_data
operator|=
name|rpipe
operator|->
name|pipe_buffer
operator|.
name|cnt
expr_stmt|;
if|if
condition|(
operator|(
name|kn
operator|->
name|kn_data
operator|==
literal|0
operator|)
operator|&&
operator|(
name|rpipe
operator|->
name|pipe_state
operator|&
name|PIPE_DIRECTW
operator|)
condition|)
name|kn
operator|->
name|kn_data
operator|=
name|rpipe
operator|->
name|pipe_map
operator|.
name|cnt
expr_stmt|;
if|if
condition|(
operator|(
name|rpipe
operator|->
name|pipe_state
operator|&
name|PIPE_EOF
operator|)
operator|||
operator|(
operator|!
name|wpipe
operator|->
name|pipe_present
operator|)
operator|||
operator|(
name|wpipe
operator|->
name|pipe_state
operator|&
name|PIPE_EOF
operator|)
condition|)
block|{
name|kn
operator|->
name|kn_flags
operator||=
name|EV_EOF
expr_stmt|;
name|PIPE_UNLOCK
argument_list|(
name|rpipe
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|ret
operator|=
name|kn
operator|->
name|kn_data
operator|>
literal|0
expr_stmt|;
name|PIPE_UNLOCK
argument_list|(
name|rpipe
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|int
name|filt_pipewrite
parameter_list|(
name|struct
name|knote
modifier|*
name|kn
parameter_list|,
name|long
name|hint
parameter_list|)
block|{
name|struct
name|pipe
modifier|*
name|rpipe
init|=
name|kn
operator|->
name|kn_fp
operator|->
name|f_data
decl_stmt|;
name|struct
name|pipe
modifier|*
name|wpipe
init|=
name|rpipe
operator|->
name|pipe_peer
decl_stmt|;
name|PIPE_LOCK
argument_list|(
name|rpipe
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|!
name|wpipe
operator|->
name|pipe_present
operator|)
operator|||
operator|(
name|wpipe
operator|->
name|pipe_state
operator|&
name|PIPE_EOF
operator|)
condition|)
block|{
name|kn
operator|->
name|kn_data
operator|=
literal|0
expr_stmt|;
name|kn
operator|->
name|kn_flags
operator||=
name|EV_EOF
expr_stmt|;
name|PIPE_UNLOCK
argument_list|(
name|rpipe
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|kn
operator|->
name|kn_data
operator|=
name|wpipe
operator|->
name|pipe_buffer
operator|.
name|size
operator|-
name|wpipe
operator|->
name|pipe_buffer
operator|.
name|cnt
expr_stmt|;
if|if
condition|(
name|wpipe
operator|->
name|pipe_state
operator|&
name|PIPE_DIRECTW
condition|)
name|kn
operator|->
name|kn_data
operator|=
literal|0
expr_stmt|;
name|PIPE_UNLOCK
argument_list|(
name|rpipe
argument_list|)
expr_stmt|;
return|return
operator|(
name|kn
operator|->
name|kn_data
operator|>=
name|PIPE_BUF
operator|)
return|;
block|}
end_function

end_unit

