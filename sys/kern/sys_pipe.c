begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1996 John S. Dyson  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice immediately at the beginning of the file, without modification,  *    this list of conditions, and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. Absolutely no warranty of function or purpose is made by the author  *    John S. Dyson.  * 4. Modifications may be freely made to this file if the above conditions  *    are met.  *  * $Id: sys_pipe.c,v 1.10 1996/02/09 04:36:36 dyson Exp $  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|OLD_PIPE
end_ifndef

begin_comment
comment|/*  * This file contains a high-performance replacement for the socket-based  * pipes scheme originally used in FreeBSD/4.4Lite.  It does not support  * all features of sockets, but does do everything that pipes normally  * do.  */
end_comment

begin_comment
comment|/*  * This code has two modes of operation, a small write mode and a large  * write mode.  The small write mode acts like conventional pipes with  * a kernel buffer.  If the buffer is less than PIPE_MINDIRECT, then the  * "normal" pipe buffering is done.  If the buffer is between PIPE_MINDIRECT  * and PIPE_SIZE in size, it is fully mapped and wired into the kernel, and  * the receiving process can copy it directly from the pages in the sending  * process.  *  * If the sending process receives a signal, it is possible that it will  * go away, and certainly its address space can change, because control  * is returned back to the user-mode side.  In that case, the pipe code  * arranges to copy the buffer supplied by the user process, to a pageable  * kernel buffer, and the receiving process will grab the data from the  * pageable kernel buffer.  Since signals don't happen all that often,  * the copy operation is normally eliminated.  *  * The constant PIPE_MINDIRECT is chosen to make sure that buffering will  * happen for small transfers so that the system will not spend all of  * its time context switching.  PIPE_SIZE is constrained by the  * amount of kernel virtual memory.  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/protosw.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/filedesc.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/select.h>
end_include

begin_include
include|#
directive|include
file|<sys/signalvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/vmmeter.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysproto.h>
end_include

begin_include
include|#
directive|include
file|<sys/pipe.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_prot.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_param.h>
end_include

begin_include
include|#
directive|include
file|<vm/lock.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_object.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_kern.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_extern.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_map.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_page.h>
end_include

begin_comment
comment|/*  * Use this define if you want to disable *fancy* VM things.  Expect an  * approx 30% decrease in transfer rate.  This could be useful for  * NetBSD or OpenBSD.  */
end_comment

begin_comment
comment|/* #define PIPE_NODIRECT */
end_comment

begin_comment
comment|/*  * interfaces to the outside world  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|pipe_read
name|__P
argument_list|(
operator|(
expr|struct
name|file
operator|*
name|fp
operator|,
expr|struct
name|uio
operator|*
name|uio
operator|,
expr|struct
name|ucred
operator|*
name|cred
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|pipe_write
name|__P
argument_list|(
operator|(
expr|struct
name|file
operator|*
name|fp
operator|,
expr|struct
name|uio
operator|*
name|uio
operator|,
expr|struct
name|ucred
operator|*
name|cred
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|pipe_close
name|__P
argument_list|(
operator|(
expr|struct
name|file
operator|*
name|fp
operator|,
expr|struct
name|proc
operator|*
name|p
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|pipe_select
name|__P
argument_list|(
operator|(
expr|struct
name|file
operator|*
name|fp
operator|,
name|int
name|which
operator|,
expr|struct
name|proc
operator|*
name|p
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|pipe_ioctl
name|__P
argument_list|(
operator|(
expr|struct
name|file
operator|*
name|fp
operator|,
name|int
name|cmd
operator|,
name|caddr_t
name|data
operator|,
expr|struct
name|proc
operator|*
name|p
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|fileops
name|pipeops
init|=
block|{
name|pipe_read
block|,
name|pipe_write
block|,
name|pipe_ioctl
block|,
name|pipe_select
block|,
name|pipe_close
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Default pipe buffer size(s), this can be kind-of large now because pipe  * space is pageable.  The pipe code will try to maintain locality of  * reference for performance reasons, so small amounts of outstanding I/O  * will not wipe the cache.  */
end_comment

begin_define
define|#
directive|define
name|MINPIPESIZE
value|(PIPE_SIZE/3)
end_define

begin_define
define|#
directive|define
name|MAXPIPESIZE
value|(2*PIPE_SIZE/3)
end_define

begin_comment
comment|/*  * Maximum amount of kva for pipes -- this is kind-of a soft limit, but  * is there so that on large systems, we don't exhaust it.  */
end_comment

begin_define
define|#
directive|define
name|MAXPIPEKVA
value|(8*1024*1024)
end_define

begin_comment
comment|/*  * Limit for direct transfers, we cannot, of course limit  * the amount of kva for pipes in general though.  */
end_comment

begin_define
define|#
directive|define
name|LIMITPIPEKVA
value|(16*1024*1024)
end_define

begin_decl_stmt
name|int
name|amountpipekva
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|pipeclose
name|__P
argument_list|(
operator|(
expr|struct
name|pipe
operator|*
name|cpipe
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|pipebufferinit
name|__P
argument_list|(
operator|(
expr|struct
name|pipe
operator|*
name|cpipe
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|pipeinit
name|__P
argument_list|(
operator|(
expr|struct
name|pipe
operator|*
name|cpipe
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|__inline
name|int
name|pipelock
name|__P
argument_list|(
operator|(
expr|struct
name|pipe
operator|*
name|cpipe
operator|,
name|int
name|catch
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|__inline
name|void
name|pipeunlock
name|__P
argument_list|(
operator|(
expr|struct
name|pipe
operator|*
name|cpipe
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|PIPE_NODIRECT
end_ifndef

begin_decl_stmt
specifier|static
name|int
name|pipe_build_write_buffer
name|__P
argument_list|(
operator|(
expr|struct
name|pipe
operator|*
name|wpipe
operator|,
expr|struct
name|uio
operator|*
name|uio
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|pipe_destroy_write_buffer
name|__P
argument_list|(
operator|(
expr|struct
name|pipe
operator|*
name|wpipe
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|pipe_direct_write
name|__P
argument_list|(
operator|(
expr|struct
name|pipe
operator|*
name|wpipe
operator|,
expr|struct
name|uio
operator|*
name|uio
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|pipe_clone_write_buffer
name|__P
argument_list|(
operator|(
expr|struct
name|pipe
operator|*
name|wpipe
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|pipe_mark_pages_clean
name|__P
argument_list|(
operator|(
expr|struct
name|pipe
operator|*
name|cpipe
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|int
name|pipewrite
name|__P
argument_list|(
operator|(
expr|struct
name|pipe
operator|*
name|wpipe
operator|,
expr|struct
name|uio
operator|*
name|uio
operator|,
name|int
name|nbio
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|pipespace
name|__P
argument_list|(
operator|(
expr|struct
name|pipe
operator|*
name|cpipe
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * The pipe system call for the DTYPE_PIPE type of pipes  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|pipe
parameter_list|(
name|p
parameter_list|,
name|uap
parameter_list|,
name|retval
parameter_list|)
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|struct
name|pipe_args
comment|/* { 		int	dummy; 	} */
modifier|*
name|uap
decl_stmt|;
name|int
name|retval
index|[]
decl_stmt|;
block|{
specifier|register
name|struct
name|filedesc
modifier|*
name|fdp
init|=
name|p
operator|->
name|p_fd
decl_stmt|;
name|struct
name|file
modifier|*
name|rf
decl_stmt|,
modifier|*
name|wf
decl_stmt|;
name|struct
name|pipe
modifier|*
name|rpipe
decl_stmt|,
modifier|*
name|wpipe
decl_stmt|;
name|int
name|fd
decl_stmt|,
name|error
decl_stmt|;
name|rpipe
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|rpipe
argument_list|)
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|pipeinit
argument_list|(
name|rpipe
argument_list|)
expr_stmt|;
name|rpipe
operator|->
name|pipe_state
operator||=
name|PIPE_DIRECTOK
expr_stmt|;
name|wpipe
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|wpipe
argument_list|)
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|pipeinit
argument_list|(
name|wpipe
argument_list|)
expr_stmt|;
name|wpipe
operator|->
name|pipe_state
operator||=
name|PIPE_DIRECTOK
expr_stmt|;
name|error
operator|=
name|falloc
argument_list|(
name|p
argument_list|,
operator|&
name|rf
argument_list|,
operator|&
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|free2
goto|;
name|retval
index|[
literal|0
index|]
operator|=
name|fd
expr_stmt|;
name|rf
operator|->
name|f_flag
operator|=
name|FREAD
operator||
name|FWRITE
expr_stmt|;
name|rf
operator|->
name|f_type
operator|=
name|DTYPE_PIPE
expr_stmt|;
name|rf
operator|->
name|f_ops
operator|=
operator|&
name|pipeops
expr_stmt|;
name|rf
operator|->
name|f_data
operator|=
operator|(
name|caddr_t
operator|)
name|rpipe
expr_stmt|;
name|error
operator|=
name|falloc
argument_list|(
name|p
argument_list|,
operator|&
name|wf
argument_list|,
operator|&
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|free3
goto|;
name|wf
operator|->
name|f_flag
operator|=
name|FREAD
operator||
name|FWRITE
expr_stmt|;
name|wf
operator|->
name|f_type
operator|=
name|DTYPE_PIPE
expr_stmt|;
name|wf
operator|->
name|f_ops
operator|=
operator|&
name|pipeops
expr_stmt|;
name|wf
operator|->
name|f_data
operator|=
operator|(
name|caddr_t
operator|)
name|wpipe
expr_stmt|;
name|retval
index|[
literal|1
index|]
operator|=
name|fd
expr_stmt|;
name|rpipe
operator|->
name|pipe_peer
operator|=
name|wpipe
expr_stmt|;
name|wpipe
operator|->
name|pipe_peer
operator|=
name|rpipe
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|free3
label|:
name|ffree
argument_list|(
name|rf
argument_list|)
expr_stmt|;
name|fdp
operator|->
name|fd_ofiles
index|[
name|retval
index|[
literal|0
index|]
index|]
operator|=
literal|0
expr_stmt|;
name|free2
label|:
operator|(
name|void
operator|)
name|pipeclose
argument_list|(
name|wpipe
argument_list|)
expr_stmt|;
name|free1
label|:
operator|(
name|void
operator|)
name|pipeclose
argument_list|(
name|rpipe
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Allocate kva for pipe circular buffer, the space is pageable  */
end_comment

begin_function
specifier|static
name|void
name|pipespace
parameter_list|(
name|cpipe
parameter_list|)
name|struct
name|pipe
modifier|*
name|cpipe
decl_stmt|;
block|{
name|int
name|npages
decl_stmt|,
name|error
decl_stmt|;
name|npages
operator|=
name|round_page
argument_list|(
name|cpipe
operator|->
name|pipe_buffer
operator|.
name|size
argument_list|)
operator|/
name|PAGE_SIZE
expr_stmt|;
comment|/* 	 * Create an object, I don't like the idea of paging to/from 	 * kernel_object. 	 * XXX -- minor change needed here for NetBSD/OpenBSD VM systems. 	 */
name|cpipe
operator|->
name|pipe_buffer
operator|.
name|object
operator|=
name|vm_object_allocate
argument_list|(
name|OBJT_DEFAULT
argument_list|,
name|npages
argument_list|)
expr_stmt|;
name|cpipe
operator|->
name|pipe_buffer
operator|.
name|buffer
operator|=
operator|(
name|caddr_t
operator|)
name|vm_map_min
argument_list|(
name|kernel_map
argument_list|)
expr_stmt|;
comment|/* 	 * Insert the object into the kernel map, and allocate kva for it. 	 * The map entry is, by default, pageable. 	 * XXX -- minor change needed here for NetBSD/OpenBSD VM systems. 	 */
name|error
operator|=
name|vm_map_find
argument_list|(
name|kernel_map
argument_list|,
name|cpipe
operator|->
name|pipe_buffer
operator|.
name|object
argument_list|,
literal|0
argument_list|,
operator|(
name|vm_offset_t
operator|*
operator|)
operator|&
name|cpipe
operator|->
name|pipe_buffer
operator|.
name|buffer
argument_list|,
name|cpipe
operator|->
name|pipe_buffer
operator|.
name|size
argument_list|,
literal|1
argument_list|,
name|VM_PROT_ALL
argument_list|,
name|VM_PROT_ALL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
name|KERN_SUCCESS
condition|)
name|panic
argument_list|(
literal|"pipeinit: cannot allocate pipe -- out of kvm -- code = %d"
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|amountpipekva
operator|+=
name|cpipe
operator|->
name|pipe_buffer
operator|.
name|size
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * initialize and allocate VM and memory for pipe  */
end_comment

begin_function
specifier|static
name|void
name|pipeinit
parameter_list|(
name|cpipe
parameter_list|)
name|struct
name|pipe
modifier|*
name|cpipe
decl_stmt|;
block|{
name|int
name|s
decl_stmt|;
name|cpipe
operator|->
name|pipe_buffer
operator|.
name|in
operator|=
literal|0
expr_stmt|;
name|cpipe
operator|->
name|pipe_buffer
operator|.
name|out
operator|=
literal|0
expr_stmt|;
name|cpipe
operator|->
name|pipe_buffer
operator|.
name|cnt
operator|=
literal|0
expr_stmt|;
name|cpipe
operator|->
name|pipe_buffer
operator|.
name|size
operator|=
name|PIPE_SIZE
expr_stmt|;
comment|/* Buffer kva gets dynamically allocated */
name|cpipe
operator|->
name|pipe_buffer
operator|.
name|buffer
operator|=
name|NULL
expr_stmt|;
name|cpipe
operator|->
name|pipe_state
operator|=
literal|0
expr_stmt|;
name|cpipe
operator|->
name|pipe_peer
operator|=
name|NULL
expr_stmt|;
name|cpipe
operator|->
name|pipe_busy
operator|=
literal|0
expr_stmt|;
name|s
operator|=
name|splhigh
argument_list|()
expr_stmt|;
name|cpipe
operator|->
name|pipe_ctime
operator|=
name|time
expr_stmt|;
name|cpipe
operator|->
name|pipe_atime
operator|=
name|time
expr_stmt|;
name|cpipe
operator|->
name|pipe_mtime
operator|=
name|time
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|cpipe
operator|->
name|pipe_sel
argument_list|,
sizeof|sizeof
name|cpipe
operator|->
name|pipe_sel
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|PIPE_NODIRECT
comment|/* 	 * pipe data structure initializations to support direct pipe I/O 	 */
name|cpipe
operator|->
name|pipe_map
operator|.
name|cnt
operator|=
literal|0
expr_stmt|;
name|cpipe
operator|->
name|pipe_map
operator|.
name|kva
operator|=
literal|0
expr_stmt|;
name|cpipe
operator|->
name|pipe_map
operator|.
name|pos
operator|=
literal|0
expr_stmt|;
name|cpipe
operator|->
name|pipe_map
operator|.
name|npages
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * lock a pipe for I/O, blocking other access  */
end_comment

begin_function
specifier|static
name|__inline
name|int
name|pipelock
parameter_list|(
name|cpipe
parameter_list|,
name|catch
parameter_list|)
name|struct
name|pipe
modifier|*
name|cpipe
decl_stmt|;
name|int
name|catch
decl_stmt|;
block|{
name|int
name|error
decl_stmt|;
while|while
condition|(
name|cpipe
operator|->
name|pipe_state
operator|&
name|PIPE_LOCK
condition|)
block|{
name|cpipe
operator|->
name|pipe_state
operator||=
name|PIPE_LWANT
expr_stmt|;
if|if
condition|(
name|error
operator|=
name|tsleep
argument_list|(
operator|&
name|cpipe
operator|->
name|pipe_state
argument_list|,
name|catch
condition|?
operator|(
name|PRIBIO
operator||
name|PCATCH
operator|)
else|:
name|PRIBIO
argument_list|,
literal|"pipelk"
argument_list|,
literal|0
argument_list|)
condition|)
block|{
return|return
name|error
return|;
block|}
block|}
name|cpipe
operator|->
name|pipe_state
operator||=
name|PIPE_LOCK
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * unlock a pipe I/O lock  */
end_comment

begin_function
specifier|static
name|__inline
name|void
name|pipeunlock
parameter_list|(
name|cpipe
parameter_list|)
name|struct
name|pipe
modifier|*
name|cpipe
decl_stmt|;
block|{
name|cpipe
operator|->
name|pipe_state
operator|&=
operator|~
name|PIPE_LOCK
expr_stmt|;
if|if
condition|(
name|cpipe
operator|->
name|pipe_state
operator|&
name|PIPE_LWANT
condition|)
block|{
name|cpipe
operator|->
name|pipe_state
operator|&=
operator|~
name|PIPE_LWANT
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|cpipe
operator|->
name|pipe_state
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|pipeselwakeup
parameter_list|(
name|cpipe
parameter_list|)
name|struct
name|pipe
modifier|*
name|cpipe
decl_stmt|;
block|{
if|if
condition|(
name|cpipe
operator|->
name|pipe_state
operator|&
name|PIPE_SEL
condition|)
block|{
name|cpipe
operator|->
name|pipe_state
operator|&=
operator|~
name|PIPE_SEL
expr_stmt|;
name|selwakeup
argument_list|(
operator|&
name|cpipe
operator|->
name|pipe_sel
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|PIPE_NODIRECT
end_ifndef

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static void pipe_mark_pages_clean(cpipe) 	struct pipe *cpipe; { 	vm_size_t off; 	vm_page_t m;  	for(off = 0; off< cpipe->pipe_buffer.object->size; off += 1) { 		m = vm_page_lookup(cpipe->pipe_buffer.object, off); 		if ((m != NULL)&& (m->busy == 0)&& (m->flags& PG_BUSY) == 0) { 			m->dirty = 0; 			pmap_clear_modify(VM_PAGE_TO_PHYS(m)); 		} 	} }
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|pipe_read
parameter_list|(
name|fp
parameter_list|,
name|uio
parameter_list|,
name|cred
parameter_list|)
name|struct
name|file
modifier|*
name|fp
decl_stmt|;
name|struct
name|uio
modifier|*
name|uio
decl_stmt|;
name|struct
name|ucred
modifier|*
name|cred
decl_stmt|;
block|{
name|struct
name|pipe
modifier|*
name|rpipe
init|=
operator|(
expr|struct
name|pipe
operator|*
operator|)
name|fp
operator|->
name|f_data
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|int
name|nread
init|=
literal|0
decl_stmt|;
name|int
name|size
decl_stmt|;
operator|++
name|rpipe
operator|->
name|pipe_busy
expr_stmt|;
while|while
condition|(
name|uio
operator|->
name|uio_resid
condition|)
block|{
comment|/* 		 * normal pipe buffer receive 		 */
if|if
condition|(
name|rpipe
operator|->
name|pipe_buffer
operator|.
name|cnt
operator|>
literal|0
condition|)
block|{
name|int
name|size
init|=
name|rpipe
operator|->
name|pipe_buffer
operator|.
name|size
operator|-
name|rpipe
operator|->
name|pipe_buffer
operator|.
name|out
decl_stmt|;
if|if
condition|(
name|size
operator|>
name|rpipe
operator|->
name|pipe_buffer
operator|.
name|cnt
condition|)
name|size
operator|=
name|rpipe
operator|->
name|pipe_buffer
operator|.
name|cnt
expr_stmt|;
if|if
condition|(
name|size
operator|>
name|uio
operator|->
name|uio_resid
condition|)
name|size
operator|=
name|uio
operator|->
name|uio_resid
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|pipelock
argument_list|(
name|rpipe
argument_list|,
literal|1
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|uiomove
argument_list|(
operator|&
name|rpipe
operator|->
name|pipe_buffer
operator|.
name|buffer
index|[
name|rpipe
operator|->
name|pipe_buffer
operator|.
name|out
index|]
argument_list|,
name|size
argument_list|,
name|uio
argument_list|)
expr_stmt|;
name|pipeunlock
argument_list|(
name|rpipe
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
condition|)
block|{
break|break;
block|}
name|rpipe
operator|->
name|pipe_buffer
operator|.
name|out
operator|+=
name|size
expr_stmt|;
if|if
condition|(
name|rpipe
operator|->
name|pipe_buffer
operator|.
name|out
operator|>=
name|rpipe
operator|->
name|pipe_buffer
operator|.
name|size
condition|)
name|rpipe
operator|->
name|pipe_buffer
operator|.
name|out
operator|=
literal|0
expr_stmt|;
name|rpipe
operator|->
name|pipe_buffer
operator|.
name|cnt
operator|-=
name|size
expr_stmt|;
name|nread
operator|+=
name|size
expr_stmt|;
ifndef|#
directive|ifndef
name|PIPE_NODIRECT
comment|/* 		 * Direct copy, bypassing a kernel buffer. 		 */
block|}
elseif|else
if|if
condition|(
operator|(
name|size
operator|=
name|rpipe
operator|->
name|pipe_map
operator|.
name|cnt
operator|)
operator|&&
operator|(
name|rpipe
operator|->
name|pipe_state
operator|&
name|PIPE_DIRECTW
operator|)
condition|)
block|{
name|caddr_t
name|va
decl_stmt|;
if|if
condition|(
name|size
operator|>
name|uio
operator|->
name|uio_resid
condition|)
name|size
operator|=
name|uio
operator|->
name|uio_resid
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|pipelock
argument_list|(
name|rpipe
argument_list|,
literal|1
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|va
operator|=
operator|(
name|caddr_t
operator|)
name|rpipe
operator|->
name|pipe_map
operator|.
name|kva
operator|+
name|rpipe
operator|->
name|pipe_map
operator|.
name|pos
expr_stmt|;
name|error
operator|=
name|uiomove
argument_list|(
name|va
argument_list|,
name|size
argument_list|,
name|uio
argument_list|)
expr_stmt|;
name|pipeunlock
argument_list|(
name|rpipe
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
condition|)
break|break;
name|nread
operator|+=
name|size
expr_stmt|;
name|rpipe
operator|->
name|pipe_map
operator|.
name|pos
operator|+=
name|size
expr_stmt|;
name|rpipe
operator|->
name|pipe_map
operator|.
name|cnt
operator|-=
name|size
expr_stmt|;
if|if
condition|(
name|rpipe
operator|->
name|pipe_map
operator|.
name|cnt
operator|==
literal|0
condition|)
block|{
name|rpipe
operator|->
name|pipe_state
operator|&=
operator|~
name|PIPE_DIRECTW
expr_stmt|;
name|wakeup
argument_list|(
name|rpipe
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
else|else
block|{
comment|/* 			 * detect EOF condition 			 */
if|if
condition|(
name|rpipe
operator|->
name|pipe_state
operator|&
name|PIPE_EOF
condition|)
block|{
break|break;
block|}
comment|/* 			 * If the "write-side" has been blocked, wake it up now. 			 */
if|if
condition|(
name|rpipe
operator|->
name|pipe_state
operator|&
name|PIPE_WANTW
condition|)
block|{
name|rpipe
operator|->
name|pipe_state
operator|&=
operator|~
name|PIPE_WANTW
expr_stmt|;
name|wakeup
argument_list|(
name|rpipe
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nread
operator|>
literal|0
condition|)
break|break;
if|if
condition|(
name|rpipe
operator|->
name|pipe_state
operator|&
name|PIPE_NBIO
condition|)
block|{
name|error
operator|=
name|EAGAIN
expr_stmt|;
break|break;
block|}
comment|/* 			 * If there is no more to read in the pipe, reset 			 * its pointers to the beginning.  This improves 			 * cache hit stats. 			 */
if|if
condition|(
operator|(
name|error
operator|=
name|pipelock
argument_list|(
name|rpipe
argument_list|,
literal|1
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|rpipe
operator|->
name|pipe_buffer
operator|.
name|cnt
operator|==
literal|0
condition|)
block|{
name|rpipe
operator|->
name|pipe_buffer
operator|.
name|in
operator|=
literal|0
expr_stmt|;
name|rpipe
operator|->
name|pipe_buffer
operator|.
name|out
operator|=
literal|0
expr_stmt|;
block|}
name|pipeunlock
argument_list|(
name|rpipe
argument_list|)
expr_stmt|;
block|}
else|else
block|{
break|break;
block|}
name|rpipe
operator|->
name|pipe_state
operator||=
name|PIPE_WANTR
expr_stmt|;
if|if
condition|(
name|error
operator|=
name|tsleep
argument_list|(
name|rpipe
argument_list|,
name|PRIBIO
operator||
name|PCATCH
argument_list|,
literal|"piperd"
argument_list|,
literal|0
argument_list|)
condition|)
block|{
break|break;
block|}
block|}
block|}
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|int
name|s
init|=
name|splhigh
argument_list|()
decl_stmt|;
name|rpipe
operator|->
name|pipe_atime
operator|=
name|time
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
operator|--
name|rpipe
operator|->
name|pipe_busy
expr_stmt|;
if|if
condition|(
operator|(
name|rpipe
operator|->
name|pipe_busy
operator|==
literal|0
operator|)
operator|&&
operator|(
name|rpipe
operator|->
name|pipe_state
operator|&
name|PIPE_WANT
operator|)
condition|)
block|{
name|rpipe
operator|->
name|pipe_state
operator|&=
operator|~
operator|(
name|PIPE_WANT
operator||
name|PIPE_WANTW
operator|)
expr_stmt|;
name|wakeup
argument_list|(
name|rpipe
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rpipe
operator|->
name|pipe_buffer
operator|.
name|cnt
operator|<
name|MINPIPESIZE
condition|)
block|{
comment|/* 		 * If there is no more to read in the pipe, reset 		 * its pointers to the beginning.  This improves 		 * cache hit stats. 		 */
if|if
condition|(
operator|(
name|error
operator|==
literal|0
operator|)
operator|&&
operator|(
name|error
operator|=
name|pipelock
argument_list|(
name|rpipe
argument_list|,
literal|1
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|rpipe
operator|->
name|pipe_buffer
operator|.
name|cnt
operator|==
literal|0
condition|)
block|{
if|#
directive|if
literal|0
block|pipe_mark_pages_clean(rpipe);
endif|#
directive|endif
name|rpipe
operator|->
name|pipe_buffer
operator|.
name|in
operator|=
literal|0
expr_stmt|;
name|rpipe
operator|->
name|pipe_buffer
operator|.
name|out
operator|=
literal|0
expr_stmt|;
block|}
name|pipeunlock
argument_list|(
name|rpipe
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * If the "write-side" has been blocked, wake it up now. 		 */
if|if
condition|(
name|rpipe
operator|->
name|pipe_state
operator|&
name|PIPE_WANTW
condition|)
block|{
name|rpipe
operator|->
name|pipe_state
operator|&=
operator|~
name|PIPE_WANTW
expr_stmt|;
name|wakeup
argument_list|(
name|rpipe
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|rpipe
operator|->
name|pipe_buffer
operator|.
name|size
operator|-
name|rpipe
operator|->
name|pipe_buffer
operator|.
name|cnt
operator|)
operator|>
literal|0
condition|)
name|pipeselwakeup
argument_list|(
name|rpipe
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|PIPE_NODIRECT
end_ifndef

begin_comment
comment|/*  * Map the sending processes' buffer into kernel space and wire it.  * This is similar to a physical write operation.  */
end_comment

begin_function
specifier|static
name|int
name|pipe_build_write_buffer
parameter_list|(
name|wpipe
parameter_list|,
name|uio
parameter_list|)
name|struct
name|pipe
modifier|*
name|wpipe
decl_stmt|;
name|struct
name|uio
modifier|*
name|uio
decl_stmt|;
block|{
name|int
name|size
decl_stmt|;
name|int
name|i
decl_stmt|;
name|vm_offset_t
name|addr
decl_stmt|,
name|endaddr
decl_stmt|,
name|paddr
decl_stmt|;
name|size
operator|=
name|uio
operator|->
name|uio_iov
operator|->
name|iov_len
expr_stmt|;
if|if
condition|(
name|size
operator|>
name|wpipe
operator|->
name|pipe_buffer
operator|.
name|size
condition|)
name|size
operator|=
name|wpipe
operator|->
name|pipe_buffer
operator|.
name|size
expr_stmt|;
name|endaddr
operator|=
name|round_page
argument_list|(
name|uio
operator|->
name|uio_iov
operator|->
name|iov_base
operator|+
name|size
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|addr
operator|=
name|trunc_page
argument_list|(
name|uio
operator|->
name|uio_iov
operator|->
name|iov_base
argument_list|)
init|;
name|addr
operator|<
name|endaddr
condition|;
name|addr
operator|+=
name|PAGE_SIZE
operator|,
name|i
operator|+=
literal|1
control|)
block|{
name|vm_page_t
name|m
decl_stmt|;
name|vm_fault_quick
argument_list|(
operator|(
name|caddr_t
operator|)
name|addr
argument_list|,
name|VM_PROT_READ
argument_list|)
expr_stmt|;
name|paddr
operator|=
name|pmap_kextract
argument_list|(
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|paddr
condition|)
block|{
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|i
condition|;
name|j
operator|++
control|)
name|vm_page_unwire
argument_list|(
name|wpipe
operator|->
name|pipe_map
operator|.
name|ms
index|[
name|j
index|]
argument_list|)
expr_stmt|;
return|return
name|EFAULT
return|;
block|}
name|m
operator|=
name|PHYS_TO_VM_PAGE
argument_list|(
name|paddr
argument_list|)
expr_stmt|;
name|vm_page_wire
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|wpipe
operator|->
name|pipe_map
operator|.
name|ms
index|[
name|i
index|]
operator|=
name|m
expr_stmt|;
block|}
comment|/*  * set up the control block  */
name|wpipe
operator|->
name|pipe_map
operator|.
name|npages
operator|=
name|i
expr_stmt|;
name|wpipe
operator|->
name|pipe_map
operator|.
name|pos
operator|=
operator|(
operator|(
name|vm_offset_t
operator|)
name|uio
operator|->
name|uio_iov
operator|->
name|iov_base
operator|)
operator|&
name|PAGE_MASK
expr_stmt|;
name|wpipe
operator|->
name|pipe_map
operator|.
name|cnt
operator|=
name|size
expr_stmt|;
comment|/*  * and map the buffer  */
if|if
condition|(
name|wpipe
operator|->
name|pipe_map
operator|.
name|kva
operator|==
literal|0
condition|)
block|{
comment|/* 		 * We need to allocate space for an extra page because the 		 * address range might (will) span pages at times. 		 */
name|wpipe
operator|->
name|pipe_map
operator|.
name|kva
operator|=
name|kmem_alloc_pageable
argument_list|(
name|kernel_map
argument_list|,
name|wpipe
operator|->
name|pipe_buffer
operator|.
name|size
operator|+
name|PAGE_SIZE
argument_list|)
expr_stmt|;
name|amountpipekva
operator|+=
name|wpipe
operator|->
name|pipe_buffer
operator|.
name|size
operator|+
name|PAGE_SIZE
expr_stmt|;
block|}
name|pmap_qenter
argument_list|(
name|wpipe
operator|->
name|pipe_map
operator|.
name|kva
argument_list|,
name|wpipe
operator|->
name|pipe_map
operator|.
name|ms
argument_list|,
name|wpipe
operator|->
name|pipe_map
operator|.
name|npages
argument_list|)
expr_stmt|;
comment|/*  * and update the uio data  */
name|uio
operator|->
name|uio_iov
operator|->
name|iov_len
operator|-=
name|size
expr_stmt|;
name|uio
operator|->
name|uio_iov
operator|->
name|iov_base
operator|+=
name|size
expr_stmt|;
if|if
condition|(
name|uio
operator|->
name|uio_iov
operator|->
name|iov_len
operator|==
literal|0
condition|)
name|uio
operator|->
name|uio_iov
operator|++
expr_stmt|;
name|uio
operator|->
name|uio_resid
operator|-=
name|size
expr_stmt|;
name|uio
operator|->
name|uio_offset
operator|+=
name|size
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * unmap and unwire the process buffer  */
end_comment

begin_function
specifier|static
name|void
name|pipe_destroy_write_buffer
parameter_list|(
name|wpipe
parameter_list|)
name|struct
name|pipe
modifier|*
name|wpipe
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|pmap_qremove
argument_list|(
name|wpipe
operator|->
name|pipe_map
operator|.
name|kva
argument_list|,
name|wpipe
operator|->
name|pipe_map
operator|.
name|npages
argument_list|)
expr_stmt|;
if|if
condition|(
name|wpipe
operator|->
name|pipe_map
operator|.
name|kva
condition|)
block|{
if|if
condition|(
name|amountpipekva
operator|>
name|MAXPIPEKVA
condition|)
block|{
name|vm_offset_t
name|kva
init|=
name|wpipe
operator|->
name|pipe_map
operator|.
name|kva
decl_stmt|;
name|wpipe
operator|->
name|pipe_map
operator|.
name|kva
operator|=
literal|0
expr_stmt|;
name|kmem_free
argument_list|(
name|kernel_map
argument_list|,
name|kva
argument_list|,
name|wpipe
operator|->
name|pipe_buffer
operator|.
name|size
operator|+
name|PAGE_SIZE
argument_list|)
expr_stmt|;
name|amountpipekva
operator|-=
name|wpipe
operator|->
name|pipe_buffer
operator|.
name|size
operator|+
name|PAGE_SIZE
expr_stmt|;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|wpipe
operator|->
name|pipe_map
operator|.
name|npages
condition|;
name|i
operator|++
control|)
name|vm_page_unwire
argument_list|(
name|wpipe
operator|->
name|pipe_map
operator|.
name|ms
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * In the case of a signal, the writing process might go away.  This  * code copies the data into the circular buffer so that the source  * pages can be freed without loss of data.  */
end_comment

begin_function
specifier|static
name|void
name|pipe_clone_write_buffer
parameter_list|(
name|wpipe
parameter_list|)
name|struct
name|pipe
modifier|*
name|wpipe
decl_stmt|;
block|{
name|int
name|size
decl_stmt|;
name|int
name|pos
decl_stmt|;
name|size
operator|=
name|wpipe
operator|->
name|pipe_map
operator|.
name|cnt
expr_stmt|;
name|pos
operator|=
name|wpipe
operator|->
name|pipe_map
operator|.
name|pos
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|wpipe
operator|->
name|pipe_map
operator|.
name|kva
operator|+
name|pos
argument_list|,
operator|(
name|caddr_t
operator|)
name|wpipe
operator|->
name|pipe_buffer
operator|.
name|buffer
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|wpipe
operator|->
name|pipe_buffer
operator|.
name|in
operator|=
name|size
expr_stmt|;
name|wpipe
operator|->
name|pipe_buffer
operator|.
name|out
operator|=
literal|0
expr_stmt|;
name|wpipe
operator|->
name|pipe_buffer
operator|.
name|cnt
operator|=
name|size
expr_stmt|;
name|wpipe
operator|->
name|pipe_state
operator|&=
operator|~
name|PIPE_DIRECTW
expr_stmt|;
name|pipe_destroy_write_buffer
argument_list|(
name|wpipe
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This implements the pipe buffer write mechanism.  Note that only  * a direct write OR a normal pipe write can be pending at any given time.  * If there are any characters in the pipe buffer, the direct write will  * be deferred until the receiving process grabs all of the bytes from  * the pipe buffer.  Then the direct mapping write is set-up.  */
end_comment

begin_function
specifier|static
name|int
name|pipe_direct_write
parameter_list|(
name|wpipe
parameter_list|,
name|uio
parameter_list|)
name|struct
name|pipe
modifier|*
name|wpipe
decl_stmt|;
name|struct
name|uio
modifier|*
name|uio
decl_stmt|;
block|{
name|int
name|error
decl_stmt|;
name|retry
label|:
while|while
condition|(
name|wpipe
operator|->
name|pipe_state
operator|&
name|PIPE_DIRECTW
condition|)
block|{
if|if
condition|(
name|wpipe
operator|->
name|pipe_state
operator|&
name|PIPE_WANTR
condition|)
block|{
name|wpipe
operator|->
name|pipe_state
operator|&=
operator|~
name|PIPE_WANTR
expr_stmt|;
name|wakeup
argument_list|(
name|wpipe
argument_list|)
expr_stmt|;
block|}
name|wpipe
operator|->
name|pipe_state
operator||=
name|PIPE_WANTW
expr_stmt|;
name|error
operator|=
name|tsleep
argument_list|(
name|wpipe
argument_list|,
name|PRIBIO
operator||
name|PCATCH
argument_list|,
literal|"pipdww"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
operator|(
name|wpipe
operator|->
name|pipe_state
operator|&
name|PIPE_EOF
operator|)
condition|)
goto|goto
name|error1
goto|;
block|}
name|wpipe
operator|->
name|pipe_map
operator|.
name|cnt
operator|=
literal|0
expr_stmt|;
comment|/* transfer not ready yet */
if|if
condition|(
name|wpipe
operator|->
name|pipe_buffer
operator|.
name|cnt
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|wpipe
operator|->
name|pipe_state
operator|&
name|PIPE_WANTR
condition|)
block|{
name|wpipe
operator|->
name|pipe_state
operator|&=
operator|~
name|PIPE_WANTR
expr_stmt|;
name|wakeup
argument_list|(
name|wpipe
argument_list|)
expr_stmt|;
block|}
name|wpipe
operator|->
name|pipe_state
operator||=
name|PIPE_WANTW
expr_stmt|;
name|error
operator|=
name|tsleep
argument_list|(
name|wpipe
argument_list|,
name|PRIBIO
operator||
name|PCATCH
argument_list|,
literal|"pipdwc"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
operator|(
name|wpipe
operator|->
name|pipe_state
operator|&
name|PIPE_EOF
operator|)
condition|)
block|{
name|wpipe
operator|->
name|pipe_state
operator|&=
operator|~
name|PIPE_DIRECTW
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|error
operator|=
name|EPIPE
expr_stmt|;
goto|goto
name|error1
goto|;
block|}
goto|goto
name|retry
goto|;
block|}
name|wpipe
operator|->
name|pipe_state
operator||=
name|PIPE_DIRECTW
expr_stmt|;
name|error
operator|=
name|pipe_build_write_buffer
argument_list|(
name|wpipe
argument_list|,
name|uio
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|wpipe
operator|->
name|pipe_state
operator|&=
operator|~
name|PIPE_DIRECTW
expr_stmt|;
goto|goto
name|error1
goto|;
block|}
name|error
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|!
name|error
operator|&&
operator|(
name|wpipe
operator|->
name|pipe_state
operator|&
name|PIPE_DIRECTW
operator|)
condition|)
block|{
if|if
condition|(
name|wpipe
operator|->
name|pipe_state
operator|&
name|PIPE_EOF
condition|)
block|{
name|pipelock
argument_list|(
name|wpipe
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pipe_destroy_write_buffer
argument_list|(
name|wpipe
argument_list|)
expr_stmt|;
name|pipeunlock
argument_list|(
name|wpipe
argument_list|)
expr_stmt|;
name|pipeselwakeup
argument_list|(
name|wpipe
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
name|wpipe
argument_list|)
expr_stmt|;
return|return
name|EPIPE
return|;
block|}
if|if
condition|(
name|wpipe
operator|->
name|pipe_state
operator|&
name|PIPE_WANTR
condition|)
block|{
name|wpipe
operator|->
name|pipe_state
operator|&=
operator|~
name|PIPE_WANTR
expr_stmt|;
name|wakeup
argument_list|(
name|wpipe
argument_list|)
expr_stmt|;
block|}
name|pipeselwakeup
argument_list|(
name|wpipe
argument_list|)
expr_stmt|;
name|error
operator|=
name|tsleep
argument_list|(
name|wpipe
argument_list|,
name|PRIBIO
operator||
name|PCATCH
argument_list|,
literal|"pipdwt"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|pipelock
argument_list|(
name|wpipe
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|wpipe
operator|->
name|pipe_state
operator|&
name|PIPE_DIRECTW
condition|)
block|{
comment|/* 		 * this bit of trickery substitutes a kernel buffer for 		 * the process that might be going away. 		 */
name|pipe_clone_write_buffer
argument_list|(
name|wpipe
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pipe_destroy_write_buffer
argument_list|(
name|wpipe
argument_list|)
expr_stmt|;
block|}
name|pipeunlock
argument_list|(
name|wpipe
argument_list|)
expr_stmt|;
return|return
name|error
return|;
name|error1
label|:
name|wakeup
argument_list|(
name|wpipe
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|__inline
name|int
name|pipewrite
parameter_list|(
name|wpipe
parameter_list|,
name|uio
parameter_list|,
name|nbio
parameter_list|)
name|struct
name|pipe
modifier|*
name|wpipe
decl_stmt|;
name|struct
name|uio
modifier|*
name|uio
decl_stmt|;
name|int
name|nbio
decl_stmt|;
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
name|int
name|orig_resid
decl_stmt|;
comment|/* 	 * detect loss of pipe read side, issue SIGPIPE if lost. 	 */
if|if
condition|(
name|wpipe
operator|==
name|NULL
operator|||
operator|(
name|wpipe
operator|->
name|pipe_state
operator|&
name|PIPE_EOF
operator|)
condition|)
block|{
return|return
name|EPIPE
return|;
block|}
if|if
condition|(
name|wpipe
operator|->
name|pipe_buffer
operator|.
name|buffer
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|pipelock
argument_list|(
name|wpipe
argument_list|,
literal|1
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|pipespace
argument_list|(
name|wpipe
argument_list|)
expr_stmt|;
name|pipeunlock
argument_list|(
name|wpipe
argument_list|)
expr_stmt|;
block|}
else|else
block|{
return|return
name|error
return|;
block|}
block|}
operator|++
name|wpipe
operator|->
name|pipe_busy
expr_stmt|;
name|orig_resid
operator|=
name|uio
operator|->
name|uio_resid
expr_stmt|;
while|while
condition|(
name|uio
operator|->
name|uio_resid
condition|)
block|{
name|int
name|space
decl_stmt|;
ifndef|#
directive|ifndef
name|PIPE_NODIRECT
comment|/* 		 * If the transfer is large, we can gain performance if 		 * we do process-to-process copies directly. 		 */
if|if
condition|(
operator|(
name|amountpipekva
operator|<
name|LIMITPIPEKVA
operator|)
operator|&&
operator|(
name|uio
operator|->
name|uio_iov
operator|->
name|iov_len
operator|>=
name|PIPE_MINDIRECT
operator|)
condition|)
block|{
name|error
operator|=
name|pipe_direct_write
argument_list|(
name|wpipe
argument_list|,
name|uio
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
break|break;
block|}
continue|continue;
block|}
endif|#
directive|endif
comment|/* 		 * Pipe buffered writes cannot be coincidental with 		 * direct writes.  We wait until the currently executing 		 * direct write is completed before we start filling the 		 * pipe buffer. 		 */
name|retrywrite
label|:
while|while
condition|(
name|wpipe
operator|->
name|pipe_state
operator|&
name|PIPE_DIRECTW
condition|)
block|{
if|if
condition|(
name|wpipe
operator|->
name|pipe_state
operator|&
name|PIPE_WANTR
condition|)
block|{
name|wpipe
operator|->
name|pipe_state
operator|&=
operator|~
name|PIPE_WANTR
expr_stmt|;
name|wakeup
argument_list|(
name|wpipe
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
name|tsleep
argument_list|(
name|wpipe
argument_list|,
name|PRIBIO
operator||
name|PCATCH
argument_list|,
literal|"pipbww"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
block|}
name|space
operator|=
name|wpipe
operator|->
name|pipe_buffer
operator|.
name|size
operator|-
name|wpipe
operator|->
name|pipe_buffer
operator|.
name|cnt
expr_stmt|;
if|if
condition|(
operator|(
name|space
operator|<
name|uio
operator|->
name|uio_resid
operator|)
operator|&&
operator|(
name|orig_resid
operator|<=
name|PIPE_BUF
operator|)
condition|)
name|space
operator|=
literal|0
expr_stmt|;
comment|/* 		 * We must afford contiguous writes on buffers of size 		 * PIPE_BUF or less. 		 */
if|if
condition|(
name|space
operator|>
literal|0
condition|)
block|{
name|int
name|size
init|=
name|wpipe
operator|->
name|pipe_buffer
operator|.
name|size
operator|-
name|wpipe
operator|->
name|pipe_buffer
operator|.
name|in
decl_stmt|;
if|if
condition|(
name|size
operator|>
name|space
condition|)
name|size
operator|=
name|space
expr_stmt|;
if|if
condition|(
name|size
operator|>
name|uio
operator|->
name|uio_resid
condition|)
name|size
operator|=
name|uio
operator|->
name|uio_resid
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|pipelock
argument_list|(
name|wpipe
argument_list|,
literal|1
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 				 * It is possible for a direct write to 				 * slip in on us... handle it here... 				 */
if|if
condition|(
name|wpipe
operator|->
name|pipe_state
operator|&
name|PIPE_DIRECTW
condition|)
block|{
name|pipeunlock
argument_list|(
name|wpipe
argument_list|)
expr_stmt|;
goto|goto
name|retrywrite
goto|;
block|}
name|error
operator|=
name|uiomove
argument_list|(
operator|&
name|wpipe
operator|->
name|pipe_buffer
operator|.
name|buffer
index|[
name|wpipe
operator|->
name|pipe_buffer
operator|.
name|in
index|]
argument_list|,
name|size
argument_list|,
name|uio
argument_list|)
expr_stmt|;
name|pipeunlock
argument_list|(
name|wpipe
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
condition|)
break|break;
name|wpipe
operator|->
name|pipe_buffer
operator|.
name|in
operator|+=
name|size
expr_stmt|;
if|if
condition|(
name|wpipe
operator|->
name|pipe_buffer
operator|.
name|in
operator|>=
name|wpipe
operator|->
name|pipe_buffer
operator|.
name|size
condition|)
name|wpipe
operator|->
name|pipe_buffer
operator|.
name|in
operator|=
literal|0
expr_stmt|;
name|wpipe
operator|->
name|pipe_buffer
operator|.
name|cnt
operator|+=
name|size
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * If the "read-side" has been blocked, wake it up now. 			 */
if|if
condition|(
name|wpipe
operator|->
name|pipe_state
operator|&
name|PIPE_WANTR
condition|)
block|{
name|wpipe
operator|->
name|pipe_state
operator|&=
operator|~
name|PIPE_WANTR
expr_stmt|;
name|wakeup
argument_list|(
name|wpipe
argument_list|)
expr_stmt|;
block|}
comment|/* 			 * don't block on non-blocking I/O 			 */
if|if
condition|(
name|nbio
condition|)
block|{
name|error
operator|=
name|EAGAIN
expr_stmt|;
break|break;
block|}
comment|/* 			 * We have no more space and have something to offer, 			 * wake up selects. 			 */
name|pipeselwakeup
argument_list|(
name|wpipe
argument_list|)
expr_stmt|;
name|wpipe
operator|->
name|pipe_state
operator||=
name|PIPE_WANTW
expr_stmt|;
if|if
condition|(
name|error
operator|=
name|tsleep
argument_list|(
name|wpipe
argument_list|,
operator|(
name|PRIBIO
operator|+
literal|1
operator|)
operator||
name|PCATCH
argument_list|,
literal|"pipewr"
argument_list|,
literal|0
argument_list|)
condition|)
block|{
break|break;
block|}
comment|/* 			 * If read side wants to go away, we just issue a signal 			 * to ourselves. 			 */
if|if
condition|(
name|wpipe
operator|->
name|pipe_state
operator|&
name|PIPE_EOF
condition|)
block|{
name|error
operator|=
name|EPIPE
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
operator|(
name|wpipe
operator|->
name|pipe_busy
operator|==
literal|0
operator|)
operator|&&
operator|(
name|wpipe
operator|->
name|pipe_state
operator|&
name|PIPE_WANT
operator|)
condition|)
block|{
name|wpipe
operator|->
name|pipe_state
operator|&=
operator|~
operator|(
name|PIPE_WANT
operator||
name|PIPE_WANTR
operator|)
expr_stmt|;
name|wakeup
argument_list|(
name|wpipe
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|wpipe
operator|->
name|pipe_buffer
operator|.
name|cnt
operator|>
literal|0
condition|)
block|{
comment|/* 		 * If we have put any characters in the buffer, we wake up 		 * the reader. 		 */
if|if
condition|(
name|wpipe
operator|->
name|pipe_state
operator|&
name|PIPE_WANTR
condition|)
block|{
name|wpipe
operator|->
name|pipe_state
operator|&=
operator|~
name|PIPE_WANTR
expr_stmt|;
name|wakeup
argument_list|(
name|wpipe
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * Don't return EPIPE if I/O was successful 	 */
if|if
condition|(
operator|(
name|wpipe
operator|->
name|pipe_buffer
operator|.
name|cnt
operator|==
literal|0
operator|)
operator|&&
operator|(
name|uio
operator|->
name|uio_resid
operator|==
literal|0
operator|)
operator|&&
operator|(
name|error
operator|==
name|EPIPE
operator|)
condition|)
name|error
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|error
operator|=
literal|0
condition|)
block|{
name|int
name|s
init|=
name|splhigh
argument_list|()
decl_stmt|;
name|wpipe
operator|->
name|pipe_mtime
operator|=
name|time
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * We have something to offer, 	 * wake up select. 	 */
if|if
condition|(
name|wpipe
operator|->
name|pipe_buffer
operator|.
name|cnt
operator|>
literal|0
condition|)
name|pipeselwakeup
argument_list|(
name|wpipe
argument_list|)
expr_stmt|;
operator|--
name|wpipe
operator|->
name|pipe_busy
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|pipe_write
parameter_list|(
name|fp
parameter_list|,
name|uio
parameter_list|,
name|cred
parameter_list|)
name|struct
name|file
modifier|*
name|fp
decl_stmt|;
name|struct
name|uio
modifier|*
name|uio
decl_stmt|;
name|struct
name|ucred
modifier|*
name|cred
decl_stmt|;
block|{
name|struct
name|pipe
modifier|*
name|rpipe
init|=
operator|(
expr|struct
name|pipe
operator|*
operator|)
name|fp
operator|->
name|f_data
decl_stmt|;
name|struct
name|pipe
modifier|*
name|wpipe
init|=
name|rpipe
operator|->
name|pipe_peer
decl_stmt|;
return|return
name|pipewrite
argument_list|(
name|wpipe
argument_list|,
name|uio
argument_list|,
operator|(
name|rpipe
operator|->
name|pipe_state
operator|&
name|PIPE_NBIO
operator|)
condition|?
literal|1
else|:
literal|0
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * we implement a very minimal set of ioctls for compatibility with sockets.  */
end_comment

begin_function
name|int
name|pipe_ioctl
parameter_list|(
name|fp
parameter_list|,
name|cmd
parameter_list|,
name|data
parameter_list|,
name|p
parameter_list|)
name|struct
name|file
modifier|*
name|fp
decl_stmt|;
name|int
name|cmd
decl_stmt|;
specifier|register
name|caddr_t
name|data
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
block|{
specifier|register
name|struct
name|pipe
modifier|*
name|mpipe
init|=
operator|(
expr|struct
name|pipe
operator|*
operator|)
name|fp
operator|->
name|f_data
decl_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|FIONBIO
case|:
if|if
condition|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
condition|)
name|mpipe
operator|->
name|pipe_state
operator||=
name|PIPE_NBIO
expr_stmt|;
else|else
name|mpipe
operator|->
name|pipe_state
operator|&=
operator|~
name|PIPE_NBIO
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|FIOASYNC
case|:
if|if
condition|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
condition|)
block|{
name|mpipe
operator|->
name|pipe_state
operator||=
name|PIPE_ASYNC
expr_stmt|;
block|}
else|else
block|{
name|mpipe
operator|->
name|pipe_state
operator|&=
operator|~
name|PIPE_ASYNC
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|FIONREAD
case|:
if|if
condition|(
name|mpipe
operator|->
name|pipe_state
operator|&
name|PIPE_DIRECTW
condition|)
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|mpipe
operator|->
name|pipe_map
operator|.
name|cnt
expr_stmt|;
else|else
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|mpipe
operator|->
name|pipe_buffer
operator|.
name|cnt
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|SIOCSPGRP
case|:
name|mpipe
operator|->
name|pipe_pgid
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
name|data
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|SIOCGPGRP
case|:
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|mpipe
operator|->
name|pipe_pgid
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
name|ENOSYS
return|;
block|}
end_function

begin_function
name|int
name|pipe_select
parameter_list|(
name|fp
parameter_list|,
name|which
parameter_list|,
name|p
parameter_list|)
name|struct
name|file
modifier|*
name|fp
decl_stmt|;
name|int
name|which
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
block|{
specifier|register
name|struct
name|pipe
modifier|*
name|rpipe
init|=
operator|(
expr|struct
name|pipe
operator|*
operator|)
name|fp
operator|->
name|f_data
decl_stmt|;
name|struct
name|pipe
modifier|*
name|wpipe
decl_stmt|;
name|wpipe
operator|=
name|rpipe
operator|->
name|pipe_peer
expr_stmt|;
switch|switch
condition|(
name|which
condition|)
block|{
case|case
name|FREAD
case|:
if|if
condition|(
name|rpipe
operator|->
name|pipe_buffer
operator|.
name|cnt
operator|>
literal|0
operator|||
operator|(
name|rpipe
operator|->
name|pipe_state
operator|&
name|PIPE_EOF
operator|)
condition|)
block|{
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|selrecord
argument_list|(
name|p
argument_list|,
operator|&
name|rpipe
operator|->
name|pipe_sel
argument_list|)
expr_stmt|;
name|rpipe
operator|->
name|pipe_state
operator||=
name|PIPE_SEL
expr_stmt|;
break|break;
case|case
name|FWRITE
case|:
if|if
condition|(
operator|(
name|wpipe
operator|==
name|NULL
operator|)
operator|||
operator|(
name|wpipe
operator|->
name|pipe_state
operator|&
name|PIPE_EOF
operator|)
operator|||
operator|(
operator|(
name|wpipe
operator|->
name|pipe_buffer
operator|.
name|size
operator|-
name|wpipe
operator|->
name|pipe_buffer
operator|.
name|cnt
operator|)
operator|>=
name|PIPE_BUF
operator|)
condition|)
block|{
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|selrecord
argument_list|(
name|p
argument_list|,
operator|&
name|wpipe
operator|->
name|pipe_sel
argument_list|)
expr_stmt|;
name|wpipe
operator|->
name|pipe_state
operator||=
name|PIPE_SEL
expr_stmt|;
break|break;
case|case
literal|0
case|:
if|if
condition|(
operator|(
name|rpipe
operator|->
name|pipe_state
operator|&
name|PIPE_EOF
operator|)
operator|||
operator|(
name|wpipe
operator|==
name|NULL
operator|)
operator|||
operator|(
name|wpipe
operator|->
name|pipe_state
operator|&
name|PIPE_EOF
operator|)
condition|)
block|{
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|selrecord
argument_list|(
name|p
argument_list|,
operator|&
name|rpipe
operator|->
name|pipe_sel
argument_list|)
expr_stmt|;
name|rpipe
operator|->
name|pipe_state
operator||=
name|PIPE_SEL
expr_stmt|;
break|break;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pipe_stat
parameter_list|(
name|pipe
parameter_list|,
name|ub
parameter_list|)
specifier|register
name|struct
name|pipe
modifier|*
name|pipe
decl_stmt|;
specifier|register
name|struct
name|stat
modifier|*
name|ub
decl_stmt|;
block|{
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
name|ub
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ub
argument_list|)
argument_list|)
expr_stmt|;
name|ub
operator|->
name|st_mode
operator|=
name|S_IFSOCK
expr_stmt|;
name|ub
operator|->
name|st_blksize
operator|=
name|pipe
operator|->
name|pipe_buffer
operator|.
name|size
expr_stmt|;
name|ub
operator|->
name|st_size
operator|=
name|pipe
operator|->
name|pipe_buffer
operator|.
name|cnt
expr_stmt|;
name|ub
operator|->
name|st_blocks
operator|=
operator|(
name|ub
operator|->
name|st_size
operator|+
name|ub
operator|->
name|st_blksize
operator|-
literal|1
operator|)
operator|/
name|ub
operator|->
name|st_blksize
expr_stmt|;
name|TIMEVAL_TO_TIMESPEC
argument_list|(
operator|&
name|pipe
operator|->
name|pipe_atime
argument_list|,
operator|&
name|ub
operator|->
name|st_atimespec
argument_list|)
expr_stmt|;
name|TIMEVAL_TO_TIMESPEC
argument_list|(
operator|&
name|pipe
operator|->
name|pipe_mtime
argument_list|,
operator|&
name|ub
operator|->
name|st_mtimespec
argument_list|)
expr_stmt|;
name|TIMEVAL_TO_TIMESPEC
argument_list|(
operator|&
name|pipe
operator|->
name|pipe_ctime
argument_list|,
operator|&
name|ub
operator|->
name|st_ctimespec
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|pipe_close
parameter_list|(
name|fp
parameter_list|,
name|p
parameter_list|)
name|struct
name|file
modifier|*
name|fp
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
name|struct
name|pipe
modifier|*
name|cpipe
init|=
operator|(
expr|struct
name|pipe
operator|*
operator|)
name|fp
operator|->
name|f_data
decl_stmt|;
name|pipeclose
argument_list|(
name|cpipe
argument_list|)
expr_stmt|;
name|fp
operator|->
name|f_data
operator|=
name|NULL
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * shutdown the pipe  */
end_comment

begin_function
specifier|static
name|void
name|pipeclose
parameter_list|(
name|cpipe
parameter_list|)
name|struct
name|pipe
modifier|*
name|cpipe
decl_stmt|;
block|{
name|struct
name|pipe
modifier|*
name|ppipe
decl_stmt|;
if|if
condition|(
name|cpipe
condition|)
block|{
name|pipeselwakeup
argument_list|(
name|cpipe
argument_list|)
expr_stmt|;
comment|/* 		 * If the other side is blocked, wake it up saying that 		 * we want to close it down. 		 */
while|while
condition|(
name|cpipe
operator|->
name|pipe_busy
condition|)
block|{
name|wakeup
argument_list|(
name|cpipe
argument_list|)
expr_stmt|;
name|cpipe
operator|->
name|pipe_state
operator||=
name|PIPE_WANT
operator||
name|PIPE_EOF
expr_stmt|;
name|tsleep
argument_list|(
name|cpipe
argument_list|,
name|PRIBIO
argument_list|,
literal|"pipecl"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Disconnect from peer 		 */
if|if
condition|(
name|ppipe
operator|=
name|cpipe
operator|->
name|pipe_peer
condition|)
block|{
name|pipeselwakeup
argument_list|(
name|ppipe
argument_list|)
expr_stmt|;
name|ppipe
operator|->
name|pipe_state
operator||=
name|PIPE_EOF
expr_stmt|;
name|wakeup
argument_list|(
name|ppipe
argument_list|)
expr_stmt|;
name|ppipe
operator|->
name|pipe_peer
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* 		 * free resources 		 */
if|if
condition|(
name|cpipe
operator|->
name|pipe_buffer
operator|.
name|buffer
condition|)
block|{
name|amountpipekva
operator|-=
name|cpipe
operator|->
name|pipe_buffer
operator|.
name|size
expr_stmt|;
name|kmem_free
argument_list|(
name|kernel_map
argument_list|,
operator|(
name|vm_offset_t
operator|)
name|cpipe
operator|->
name|pipe_buffer
operator|.
name|buffer
argument_list|,
name|cpipe
operator|->
name|pipe_buffer
operator|.
name|size
argument_list|)
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|PIPE_NODIRECT
if|if
condition|(
name|cpipe
operator|->
name|pipe_map
operator|.
name|kva
condition|)
block|{
name|amountpipekva
operator|-=
name|cpipe
operator|->
name|pipe_buffer
operator|.
name|size
operator|+
name|PAGE_SIZE
expr_stmt|;
name|kmem_free
argument_list|(
name|kernel_map
argument_list|,
name|cpipe
operator|->
name|pipe_map
operator|.
name|kva
argument_list|,
name|cpipe
operator|->
name|pipe_buffer
operator|.
name|size
operator|+
name|PAGE_SIZE
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|free
argument_list|(
name|cpipe
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

