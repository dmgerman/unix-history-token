begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2008 Attilio Rao<attilio@FreeBSD.org>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice(s), this list of conditions and the following disclaimer as  *    the first lines of this file unmodified other than the possible  *    addition of one or more copyright notices.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice(s), this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER(S) ``AS IS'' AND ANY  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE  * DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT HOLDER(S) BE LIABLE FOR ANY  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER  * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH  * DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|"opt_adaptive_lockmgrs.h"
end_include

begin_include
include|#
directive|include
file|"opt_ddb.h"
end_include

begin_include
include|#
directive|include
file|"opt_hwpmc_hooks.h"
end_include

begin_include
include|#
directive|include
file|"opt_kdtrace.h"
end_include

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/ktr.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock_profile.h>
end_include

begin_include
include|#
directive|include
file|<sys/lockmgr.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/sleepqueue.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG_LOCKS
end_ifdef

begin_include
include|#
directive|include
file|<sys/stack.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<machine/cpu.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|DDB
end_ifdef

begin_include
include|#
directive|include
file|<ddb/ddb.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HWPMC_HOOKS
end_ifdef

begin_include
include|#
directive|include
file|<sys/pmckern.h>
end_include

begin_expr_stmt
name|PMC_SOFT_DECLARE
argument_list|( , ,
name|lock
argument_list|,
name|failed
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_expr_stmt
name|CTASSERT
argument_list|(
operator|(
operator|(
name|LK_ADAPTIVE
operator||
name|LK_NOSHARE
operator|)
operator|&
name|LO_CLASSFLAGS
operator|)
operator|==
operator|(
name|LK_ADAPTIVE
operator||
name|LK_NOSHARE
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|CTASSERT
argument_list|(
name|LK_UNLOCKED
operator|==
operator|(
name|LK_UNLOCKED
operator|&
operator|~
operator|(
name|LK_ALL_WAITERS
operator||
name|LK_EXCLUSIVE_SPINNERS
operator|)
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|SQ_EXCLUSIVE_QUEUE
value|0
end_define

begin_define
define|#
directive|define
name|SQ_SHARED_QUEUE
value|1
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|INVARIANTS
end_ifndef

begin_define
define|#
directive|define
name|_lockmgr_assert
parameter_list|(
name|lk
parameter_list|,
name|what
parameter_list|,
name|file
parameter_list|,
name|line
parameter_list|)
end_define

begin_define
define|#
directive|define
name|TD_LOCKS_INC
parameter_list|(
name|td
parameter_list|)
end_define

begin_define
define|#
directive|define
name|TD_LOCKS_DEC
parameter_list|(
name|td
parameter_list|)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|TD_LOCKS_INC
parameter_list|(
name|td
parameter_list|)
value|((td)->td_locks++)
end_define

begin_define
define|#
directive|define
name|TD_LOCKS_DEC
parameter_list|(
name|td
parameter_list|)
value|((td)->td_locks--)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|TD_SLOCKS_INC
parameter_list|(
name|td
parameter_list|)
value|((td)->td_lk_slocks++)
end_define

begin_define
define|#
directive|define
name|TD_SLOCKS_DEC
parameter_list|(
name|td
parameter_list|)
value|((td)->td_lk_slocks--)
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|DEBUG_LOCKS
end_ifndef

begin_define
define|#
directive|define
name|STACK_PRINT
parameter_list|(
name|lk
parameter_list|)
end_define

begin_define
define|#
directive|define
name|STACK_SAVE
parameter_list|(
name|lk
parameter_list|)
end_define

begin_define
define|#
directive|define
name|STACK_ZERO
parameter_list|(
name|lk
parameter_list|)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|STACK_PRINT
parameter_list|(
name|lk
parameter_list|)
value|stack_print_ddb(&(lk)->lk_stack)
end_define

begin_define
define|#
directive|define
name|STACK_SAVE
parameter_list|(
name|lk
parameter_list|)
value|stack_save(&(lk)->lk_stack)
end_define

begin_define
define|#
directive|define
name|STACK_ZERO
parameter_list|(
name|lk
parameter_list|)
value|stack_zero(&(lk)->lk_stack)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|LOCK_LOG2
parameter_list|(
name|lk
parameter_list|,
name|string
parameter_list|,
name|arg1
parameter_list|,
name|arg2
parameter_list|)
define|\
value|if (LOCK_LOG_TEST(&(lk)->lock_object, 0))			\ 		CTR2(KTR_LOCK, (string), (arg1), (arg2))
end_define

begin_define
define|#
directive|define
name|LOCK_LOG3
parameter_list|(
name|lk
parameter_list|,
name|string
parameter_list|,
name|arg1
parameter_list|,
name|arg2
parameter_list|,
name|arg3
parameter_list|)
define|\
value|if (LOCK_LOG_TEST(&(lk)->lock_object, 0))			\ 		CTR3(KTR_LOCK, (string), (arg1), (arg2), (arg3))
end_define

begin_define
define|#
directive|define
name|GIANT_DECLARE
define|\
value|int _i = 0;							\ 	WITNESS_SAVE_DECL(Giant)
end_define

begin_define
define|#
directive|define
name|GIANT_RESTORE
parameter_list|()
value|do {						\ 	if (_i> 0) {							\ 		while (_i--)						\ 			mtx_lock(&Giant);				\ 		WITNESS_RESTORE(&Giant.lock_object, Giant);		\ 	}								\ } while (0)
end_define

begin_define
define|#
directive|define
name|GIANT_SAVE
parameter_list|()
value|do {						\ 	if (mtx_owned(&Giant)) {					\ 		WITNESS_SAVE(&Giant.lock_object, Giant);		\ 		while (mtx_owned(&Giant)) {				\ 			_i++;						\ 			mtx_unlock(&Giant);				\ 		}							\ 	}								\ } while (0)
end_define

begin_define
define|#
directive|define
name|LK_CAN_SHARE
parameter_list|(
name|x
parameter_list|)
define|\
value|(((x)& LK_SHARE)&& (((x)& LK_EXCLUSIVE_WAITERS) == 0 ||	\ 	((x)& LK_EXCLUSIVE_SPINNERS) == 0 ||				\ 	curthread->td_lk_slocks || (curthread->td_pflags& TDP_DEADLKTREAT)))
end_define

begin_define
define|#
directive|define
name|LK_TRYOP
parameter_list|(
name|x
parameter_list|)
define|\
value|((x)& LK_NOWAIT)
end_define

begin_define
define|#
directive|define
name|LK_CAN_WITNESS
parameter_list|(
name|x
parameter_list|)
define|\
value|(((x)& LK_NOWITNESS) == 0&& !LK_TRYOP(x))
end_define

begin_define
define|#
directive|define
name|LK_TRYWIT
parameter_list|(
name|x
parameter_list|)
define|\
value|(LK_TRYOP(x) ? LOP_TRYLOCK : 0)
end_define

begin_define
define|#
directive|define
name|LK_CAN_ADAPT
parameter_list|(
name|lk
parameter_list|,
name|f
parameter_list|)
define|\
value|(((lk)->lock_object.lo_flags& LK_ADAPTIVE) != 0&&		\ 	((f)& LK_SLEEPFAIL) == 0)
end_define

begin_define
define|#
directive|define
name|lockmgr_disowned
parameter_list|(
name|lk
parameter_list|)
define|\
value|(((lk)->lk_lock& ~(LK_FLAGMASK& ~LK_SHARE)) == LK_KERNPROC)
end_define

begin_define
define|#
directive|define
name|lockmgr_xlocked
parameter_list|(
name|lk
parameter_list|)
define|\
value|(((lk)->lk_lock& ~(LK_FLAGMASK& ~LK_SHARE)) == (uintptr_t)curthread)
end_define

begin_function_decl
specifier|static
name|void
name|assert_lockmgr
parameter_list|(
specifier|const
name|struct
name|lock_object
modifier|*
name|lock
parameter_list|,
name|int
name|how
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|DDB
end_ifdef

begin_function_decl
specifier|static
name|void
name|db_show_lockmgr
parameter_list|(
specifier|const
name|struct
name|lock_object
modifier|*
name|lock
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|lock_lockmgr
parameter_list|(
name|struct
name|lock_object
modifier|*
name|lock
parameter_list|,
name|int
name|how
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|KDTRACE_HOOKS
end_ifdef

begin_function_decl
specifier|static
name|int
name|owner_lockmgr
parameter_list|(
specifier|const
name|struct
name|lock_object
modifier|*
name|lock
parameter_list|,
name|struct
name|thread
modifier|*
modifier|*
name|owner
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|int
name|unlock_lockmgr
parameter_list|(
name|struct
name|lock_object
modifier|*
name|lock
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|struct
name|lock_class
name|lock_class_lockmgr
init|=
block|{
operator|.
name|lc_name
operator|=
literal|"lockmgr"
block|,
operator|.
name|lc_flags
operator|=
name|LC_RECURSABLE
operator||
name|LC_SLEEPABLE
operator||
name|LC_SLEEPLOCK
operator||
name|LC_UPGRADABLE
block|,
operator|.
name|lc_assert
operator|=
name|assert_lockmgr
block|,
ifdef|#
directive|ifdef
name|DDB
operator|.
name|lc_ddb_show
operator|=
name|db_show_lockmgr
block|,
endif|#
directive|endif
operator|.
name|lc_lock
operator|=
name|lock_lockmgr
block|,
operator|.
name|lc_unlock
operator|=
name|unlock_lockmgr
block|,
ifdef|#
directive|ifdef
name|KDTRACE_HOOKS
operator|.
name|lc_owner
operator|=
name|owner_lockmgr
block|,
endif|#
directive|endif
block|}
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|ADAPTIVE_LOCKMGRS
end_ifdef

begin_decl_stmt
specifier|static
name|u_int
name|alk_retries
init|=
literal|10
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_int
name|alk_loops
init|=
literal|10000
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|static
name|SYSCTL_NODE
argument_list|(
name|_debug
argument_list|,
name|OID_AUTO
argument_list|,
name|lockmgr
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|NULL
argument_list|,
literal|"lockmgr debugging"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_debug_lockmgr
argument_list|,
name|OID_AUTO
argument_list|,
name|retries
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|alk_retries
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_debug_lockmgr
argument_list|,
name|OID_AUTO
argument_list|,
name|loops
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|alk_loops
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_expr_stmt
specifier|static
name|__inline
expr|struct
name|thread
operator|*
name|lockmgr_xholder
argument_list|(
argument|const struct lock *lk
argument_list|)
block|{
name|uintptr_t
name|x
block|;
name|x
operator|=
name|lk
operator|->
name|lk_lock
block|;
return|return
operator|(
operator|(
name|x
operator|&
name|LK_SHARE
operator|)
condition|?
name|NULL
else|:
operator|(
expr|struct
name|thread
operator|*
operator|)
name|LK_HOLDER
argument_list|(
name|x
argument_list|)
operator|)
return|;
block|}
end_expr_stmt

begin_comment
comment|/*  * It assumes sleepq_lock held and returns with this one unheld.  * It also assumes the generic interlock is sane and previously checked.  * If LK_INTERLOCK is specified the interlock is not reacquired after the  * sleep.  */
end_comment

begin_function
specifier|static
name|__inline
name|int
name|sleeplk
parameter_list|(
name|struct
name|lock
modifier|*
name|lk
parameter_list|,
name|u_int
name|flags
parameter_list|,
name|struct
name|lock_object
modifier|*
name|ilk
parameter_list|,
specifier|const
name|char
modifier|*
name|wmesg
parameter_list|,
name|int
name|pri
parameter_list|,
name|int
name|timo
parameter_list|,
name|int
name|queue
parameter_list|)
block|{
name|GIANT_DECLARE
expr_stmt|;
name|struct
name|lock_class
modifier|*
name|class
decl_stmt|;
name|int
name|catch
decl_stmt|,
name|error
decl_stmt|;
name|class
operator|=
operator|(
name|flags
operator|&
name|LK_INTERLOCK
operator|)
condition|?
name|LOCK_CLASS
argument_list|(
name|ilk
argument_list|)
else|:
name|NULL
expr_stmt|;
name|catch
operator|=
name|pri
operator|&
name|PCATCH
expr_stmt|;
name|pri
operator|&=
name|PRIMASK
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|LOCK_LOG3
argument_list|(
name|lk
argument_list|,
literal|"%s: %p blocking on the %s sleepqueue"
argument_list|,
name|__func__
argument_list|,
name|lk
argument_list|,
operator|(
name|queue
operator|==
name|SQ_EXCLUSIVE_QUEUE
operator|)
condition|?
literal|"exclusive"
else|:
literal|"shared"
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|LK_INTERLOCK
condition|)
name|class
operator|->
name|lc_unlock
argument_list|(
name|ilk
argument_list|)
expr_stmt|;
if|if
condition|(
name|queue
operator|==
name|SQ_EXCLUSIVE_QUEUE
operator|&&
operator|(
name|flags
operator|&
name|LK_SLEEPFAIL
operator|)
operator|!=
literal|0
condition|)
name|lk
operator|->
name|lk_exslpfail
operator|++
expr_stmt|;
name|GIANT_SAVE
argument_list|()
expr_stmt|;
name|sleepq_add
argument_list|(
operator|&
name|lk
operator|->
name|lock_object
argument_list|,
name|NULL
argument_list|,
name|wmesg
argument_list|,
name|SLEEPQ_LK
operator||
operator|(
name|catch
condition|?
name|SLEEPQ_INTERRUPTIBLE
else|:
literal|0
operator|)
argument_list|,
name|queue
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|LK_TIMELOCK
operator|)
operator|&&
name|timo
condition|)
name|sleepq_set_timeout
argument_list|(
operator|&
name|lk
operator|->
name|lock_object
argument_list|,
name|timo
argument_list|)
expr_stmt|;
comment|/* 	 * Decisional switch for real sleeping. 	 */
if|if
condition|(
operator|(
name|flags
operator|&
name|LK_TIMELOCK
operator|)
operator|&&
name|timo
operator|&&
name|catch
condition|)
name|error
operator|=
name|sleepq_timedwait_sig
argument_list|(
operator|&
name|lk
operator|->
name|lock_object
argument_list|,
name|pri
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|flags
operator|&
name|LK_TIMELOCK
operator|)
operator|&&
name|timo
condition|)
name|error
operator|=
name|sleepq_timedwait
argument_list|(
operator|&
name|lk
operator|->
name|lock_object
argument_list|,
name|pri
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|catch
condition|)
name|error
operator|=
name|sleepq_wait_sig
argument_list|(
operator|&
name|lk
operator|->
name|lock_object
argument_list|,
name|pri
argument_list|)
expr_stmt|;
else|else
name|sleepq_wait
argument_list|(
operator|&
name|lk
operator|->
name|lock_object
argument_list|,
name|pri
argument_list|)
expr_stmt|;
name|GIANT_RESTORE
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|LK_SLEEPFAIL
operator|)
operator|&&
name|error
operator|==
literal|0
condition|)
name|error
operator|=
name|ENOLCK
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|int
name|wakeupshlk
parameter_list|(
name|struct
name|lock
modifier|*
name|lk
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|)
block|{
name|uintptr_t
name|v
decl_stmt|,
name|x
decl_stmt|;
name|u_int
name|realexslp
decl_stmt|;
name|int
name|queue
decl_stmt|,
name|wakeup_swapper
decl_stmt|;
name|TD_LOCKS_DEC
argument_list|(
name|curthread
argument_list|)
expr_stmt|;
name|TD_SLOCKS_DEC
argument_list|(
name|curthread
argument_list|)
expr_stmt|;
name|WITNESS_UNLOCK
argument_list|(
operator|&
name|lk
operator|->
name|lock_object
argument_list|,
literal|0
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|LOCK_LOG_LOCK
argument_list|(
literal|"SUNLOCK"
argument_list|,
operator|&
name|lk
operator|->
name|lock_object
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|wakeup_swapper
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|x
operator|=
name|lk
operator|->
name|lk_lock
expr_stmt|;
comment|/* 		 * If there is more than one shared lock held, just drop one 		 * and return. 		 */
if|if
condition|(
name|LK_SHARERS
argument_list|(
name|x
argument_list|)
operator|>
literal|1
condition|)
block|{
if|if
condition|(
name|atomic_cmpset_rel_ptr
argument_list|(
operator|&
name|lk
operator|->
name|lk_lock
argument_list|,
name|x
argument_list|,
name|x
operator|-
name|LK_ONE_SHARER
argument_list|)
condition|)
break|break;
continue|continue;
block|}
comment|/* 		 * If there are not waiters on the exclusive queue, drop the 		 * lock quickly. 		 */
if|if
condition|(
operator|(
name|x
operator|&
name|LK_ALL_WAITERS
operator|)
operator|==
literal|0
condition|)
block|{
name|MPASS
argument_list|(
operator|(
name|x
operator|&
operator|~
name|LK_EXCLUSIVE_SPINNERS
operator|)
operator|==
name|LK_SHARERS_LOCK
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|atomic_cmpset_rel_ptr
argument_list|(
operator|&
name|lk
operator|->
name|lk_lock
argument_list|,
name|x
argument_list|,
name|LK_UNLOCKED
argument_list|)
condition|)
break|break;
continue|continue;
block|}
comment|/* 		 * We should have a sharer with waiters, so enter the hard 		 * path in order to handle wakeups correctly. 		 */
name|sleepq_lock
argument_list|(
operator|&
name|lk
operator|->
name|lock_object
argument_list|)
expr_stmt|;
name|x
operator|=
name|lk
operator|->
name|lk_lock
operator|&
operator|(
name|LK_ALL_WAITERS
operator||
name|LK_EXCLUSIVE_SPINNERS
operator|)
expr_stmt|;
name|v
operator|=
name|LK_UNLOCKED
expr_stmt|;
comment|/* 		 * If the lock has exclusive waiters, give them preference in 		 * order to avoid deadlock with shared runners up. 		 * If interruptible sleeps left the exclusive queue empty 		 * avoid a starvation for the threads sleeping on the shared 		 * queue by giving them precedence and cleaning up the 		 * exclusive waiters bit anyway. 		 * Please note that lk_exslpfail count may be lying about 		 * the real number of waiters with the LK_SLEEPFAIL flag on 		 * because they may be used in conjuction with interruptible 		 * sleeps so lk_exslpfail might be considered an 'upper limit' 		 * bound, including the edge cases. 		 */
name|realexslp
operator|=
name|sleepq_sleepcnt
argument_list|(
operator|&
name|lk
operator|->
name|lock_object
argument_list|,
name|SQ_EXCLUSIVE_QUEUE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|x
operator|&
name|LK_EXCLUSIVE_WAITERS
operator|)
operator|!=
literal|0
operator|&&
name|realexslp
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|lk
operator|->
name|lk_exslpfail
operator|<
name|realexslp
condition|)
block|{
name|lk
operator|->
name|lk_exslpfail
operator|=
literal|0
expr_stmt|;
name|queue
operator|=
name|SQ_EXCLUSIVE_QUEUE
expr_stmt|;
name|v
operator||=
operator|(
name|x
operator|&
name|LK_SHARED_WAITERS
operator|)
expr_stmt|;
block|}
else|else
block|{
name|lk
operator|->
name|lk_exslpfail
operator|=
literal|0
expr_stmt|;
name|LOCK_LOG2
argument_list|(
name|lk
argument_list|,
literal|"%s: %p has only LK_SLEEPFAIL sleepers"
argument_list|,
name|__func__
argument_list|,
name|lk
argument_list|)
expr_stmt|;
name|LOCK_LOG2
argument_list|(
name|lk
argument_list|,
literal|"%s: %p waking up threads on the exclusive queue"
argument_list|,
name|__func__
argument_list|,
name|lk
argument_list|)
expr_stmt|;
name|wakeup_swapper
operator|=
name|sleepq_broadcast
argument_list|(
operator|&
name|lk
operator|->
name|lock_object
argument_list|,
name|SLEEPQ_LK
argument_list|,
literal|0
argument_list|,
name|SQ_EXCLUSIVE_QUEUE
argument_list|)
expr_stmt|;
name|queue
operator|=
name|SQ_SHARED_QUEUE
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 			 * Exclusive waiters sleeping with LK_SLEEPFAIL on 			 * and using interruptible sleeps/timeout may have 			 * left spourious lk_exslpfail counts on, so clean 			 * it up anyway. 			 */
name|lk
operator|->
name|lk_exslpfail
operator|=
literal|0
expr_stmt|;
name|queue
operator|=
name|SQ_SHARED_QUEUE
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|atomic_cmpset_rel_ptr
argument_list|(
operator|&
name|lk
operator|->
name|lk_lock
argument_list|,
name|LK_SHARERS_LOCK
argument_list|(
literal|1
argument_list|)
operator||
name|x
argument_list|,
name|v
argument_list|)
condition|)
block|{
name|sleepq_release
argument_list|(
operator|&
name|lk
operator|->
name|lock_object
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|LOCK_LOG3
argument_list|(
name|lk
argument_list|,
literal|"%s: %p waking up threads on the %s queue"
argument_list|,
name|__func__
argument_list|,
name|lk
argument_list|,
name|queue
operator|==
name|SQ_SHARED_QUEUE
condition|?
literal|"shared"
else|:
literal|"exclusive"
argument_list|)
expr_stmt|;
name|wakeup_swapper
operator||=
name|sleepq_broadcast
argument_list|(
operator|&
name|lk
operator|->
name|lock_object
argument_list|,
name|SLEEPQ_LK
argument_list|,
literal|0
argument_list|,
name|queue
argument_list|)
expr_stmt|;
name|sleepq_release
argument_list|(
operator|&
name|lk
operator|->
name|lock_object
argument_list|)
expr_stmt|;
break|break;
block|}
name|lock_profile_release_lock
argument_list|(
operator|&
name|lk
operator|->
name|lock_object
argument_list|)
expr_stmt|;
return|return
operator|(
name|wakeup_swapper
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|assert_lockmgr
parameter_list|(
specifier|const
name|struct
name|lock_object
modifier|*
name|lock
parameter_list|,
name|int
name|what
parameter_list|)
block|{
name|panic
argument_list|(
literal|"lockmgr locks do not support assertions"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|lock_lockmgr
parameter_list|(
name|struct
name|lock_object
modifier|*
name|lock
parameter_list|,
name|int
name|how
parameter_list|)
block|{
name|panic
argument_list|(
literal|"lockmgr locks do not support sleep interlocking"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|unlock_lockmgr
parameter_list|(
name|struct
name|lock_object
modifier|*
name|lock
parameter_list|)
block|{
name|panic
argument_list|(
literal|"lockmgr locks do not support sleep interlocking"
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|KDTRACE_HOOKS
end_ifdef

begin_function
specifier|static
name|int
name|owner_lockmgr
parameter_list|(
specifier|const
name|struct
name|lock_object
modifier|*
name|lock
parameter_list|,
name|struct
name|thread
modifier|*
modifier|*
name|owner
parameter_list|)
block|{
name|panic
argument_list|(
literal|"lockmgr locks do not support owner inquiring"
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|lockinit
parameter_list|(
name|struct
name|lock
modifier|*
name|lk
parameter_list|,
name|int
name|pri
parameter_list|,
specifier|const
name|char
modifier|*
name|wmesg
parameter_list|,
name|int
name|timo
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|int
name|iflags
decl_stmt|;
name|MPASS
argument_list|(
operator|(
name|flags
operator|&
operator|~
name|LK_INIT_MASK
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ASSERT_ATOMIC_LOAD_PTR
argument_list|(
name|lk
operator|->
name|lk_lock
argument_list|,
operator|(
literal|"%s: lockmgr not aligned for %s: %p"
operator|,
name|__func__
operator|,
name|wmesg
operator|,
operator|&
name|lk
operator|->
name|lk_lock
operator|)
argument_list|)
expr_stmt|;
name|iflags
operator|=
name|LO_SLEEPABLE
operator||
name|LO_UPGRADABLE
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|LK_CANRECURSE
condition|)
name|iflags
operator||=
name|LO_RECURSABLE
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|LK_NODUP
operator|)
operator|==
literal|0
condition|)
name|iflags
operator||=
name|LO_DUPOK
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|LK_NOPROFILE
condition|)
name|iflags
operator||=
name|LO_NOPROFILE
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|LK_NOWITNESS
operator|)
operator|==
literal|0
condition|)
name|iflags
operator||=
name|LO_WITNESS
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|LK_QUIET
condition|)
name|iflags
operator||=
name|LO_QUIET
expr_stmt|;
name|iflags
operator||=
name|flags
operator|&
operator|(
name|LK_ADAPTIVE
operator||
name|LK_NOSHARE
operator|)
expr_stmt|;
name|lk
operator|->
name|lk_lock
operator|=
name|LK_UNLOCKED
expr_stmt|;
name|lk
operator|->
name|lk_recurse
operator|=
literal|0
expr_stmt|;
name|lk
operator|->
name|lk_exslpfail
operator|=
literal|0
expr_stmt|;
name|lk
operator|->
name|lk_timo
operator|=
name|timo
expr_stmt|;
name|lk
operator|->
name|lk_pri
operator|=
name|pri
expr_stmt|;
name|lock_init
argument_list|(
operator|&
name|lk
operator|->
name|lock_object
argument_list|,
operator|&
name|lock_class_lockmgr
argument_list|,
name|wmesg
argument_list|,
name|NULL
argument_list|,
name|iflags
argument_list|)
expr_stmt|;
name|STACK_ZERO
argument_list|(
name|lk
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * XXX: Gross hacks to manipulate external lock flags after  * initialization.  Used for certain vnode and buf locks.  */
end_comment

begin_function
name|void
name|lockallowshare
parameter_list|(
name|struct
name|lock
modifier|*
name|lk
parameter_list|)
block|{
name|lockmgr_assert
argument_list|(
name|lk
argument_list|,
name|KA_XLOCKED
argument_list|)
expr_stmt|;
name|lk
operator|->
name|lock_object
operator|.
name|lo_flags
operator|&=
operator|~
name|LK_NOSHARE
expr_stmt|;
block|}
end_function

begin_function
name|void
name|lockallowrecurse
parameter_list|(
name|struct
name|lock
modifier|*
name|lk
parameter_list|)
block|{
name|lockmgr_assert
argument_list|(
name|lk
argument_list|,
name|KA_XLOCKED
argument_list|)
expr_stmt|;
name|lk
operator|->
name|lock_object
operator|.
name|lo_flags
operator||=
name|LO_RECURSABLE
expr_stmt|;
block|}
end_function

begin_function
name|void
name|lockdisablerecurse
parameter_list|(
name|struct
name|lock
modifier|*
name|lk
parameter_list|)
block|{
name|lockmgr_assert
argument_list|(
name|lk
argument_list|,
name|KA_XLOCKED
argument_list|)
expr_stmt|;
name|lk
operator|->
name|lock_object
operator|.
name|lo_flags
operator|&=
operator|~
name|LO_RECURSABLE
expr_stmt|;
block|}
end_function

begin_function
name|void
name|lockdestroy
parameter_list|(
name|struct
name|lock
modifier|*
name|lk
parameter_list|)
block|{
name|KASSERT
argument_list|(
name|lk
operator|->
name|lk_lock
operator|==
name|LK_UNLOCKED
argument_list|,
operator|(
literal|"lockmgr still held"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|lk
operator|->
name|lk_recurse
operator|==
literal|0
argument_list|,
operator|(
literal|"lockmgr still recursed"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|lk
operator|->
name|lk_exslpfail
operator|==
literal|0
argument_list|,
operator|(
literal|"lockmgr still exclusive waiters"
operator|)
argument_list|)
expr_stmt|;
name|lock_destroy
argument_list|(
operator|&
name|lk
operator|->
name|lock_object
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|__lockmgr_args
parameter_list|(
name|struct
name|lock
modifier|*
name|lk
parameter_list|,
name|u_int
name|flags
parameter_list|,
name|struct
name|lock_object
modifier|*
name|ilk
parameter_list|,
specifier|const
name|char
modifier|*
name|wmesg
parameter_list|,
name|int
name|pri
parameter_list|,
name|int
name|timo
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|)
block|{
name|GIANT_DECLARE
expr_stmt|;
name|struct
name|lock_class
modifier|*
name|class
decl_stmt|;
specifier|const
name|char
modifier|*
name|iwmesg
decl_stmt|;
name|uintptr_t
name|tid
decl_stmt|,
name|v
decl_stmt|,
name|x
decl_stmt|;
name|u_int
name|op
decl_stmt|,
name|realexslp
decl_stmt|;
name|int
name|error
decl_stmt|,
name|ipri
decl_stmt|,
name|itimo
decl_stmt|,
name|queue
decl_stmt|,
name|wakeup_swapper
decl_stmt|;
ifdef|#
directive|ifdef
name|LOCK_PROFILING
name|uint64_t
name|waittime
init|=
literal|0
decl_stmt|;
name|int
name|contested
init|=
literal|0
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ADAPTIVE_LOCKMGRS
specifier|volatile
name|struct
name|thread
modifier|*
name|owner
decl_stmt|;
name|u_int
name|i
decl_stmt|,
name|spintries
init|=
literal|0
decl_stmt|;
endif|#
directive|endif
name|error
operator|=
literal|0
expr_stmt|;
name|tid
operator|=
operator|(
name|uintptr_t
operator|)
name|curthread
expr_stmt|;
name|op
operator|=
operator|(
name|flags
operator|&
name|LK_TYPE_MASK
operator|)
expr_stmt|;
name|iwmesg
operator|=
operator|(
name|wmesg
operator|==
name|LK_WMESG_DEFAULT
operator|)
condition|?
name|lk
operator|->
name|lock_object
operator|.
name|lo_name
else|:
name|wmesg
expr_stmt|;
name|ipri
operator|=
operator|(
name|pri
operator|==
name|LK_PRIO_DEFAULT
operator|)
condition|?
name|lk
operator|->
name|lk_pri
else|:
name|pri
expr_stmt|;
name|itimo
operator|=
operator|(
name|timo
operator|==
name|LK_TIMO_DEFAULT
operator|)
condition|?
name|lk
operator|->
name|lk_timo
else|:
name|timo
expr_stmt|;
name|MPASS
argument_list|(
operator|(
name|flags
operator|&
operator|~
name|LK_TOTAL_MASK
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|op
operator|&
operator|(
name|op
operator|-
literal|1
operator|)
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"%s: Invalid requested operation @ %s:%d"
operator|,
name|__func__
operator|,
name|file
operator|,
name|line
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|flags
operator|&
operator|(
name|LK_NOWAIT
operator||
name|LK_SLEEPFAIL
operator|)
operator|)
operator|==
literal|0
operator|||
operator|(
name|op
operator|!=
name|LK_DOWNGRADE
operator|&&
name|op
operator|!=
name|LK_RELEASE
operator|)
argument_list|,
operator|(
literal|"%s: Invalid flags in regard of the operation desired @ %s:%d"
operator|,
name|__func__
operator|,
name|file
operator|,
name|line
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|flags
operator|&
name|LK_INTERLOCK
operator|)
operator|==
literal|0
operator|||
name|ilk
operator|!=
name|NULL
argument_list|,
operator|(
literal|"%s: LK_INTERLOCK passed without valid interlock @ %s:%d"
operator|,
name|__func__
operator|,
name|file
operator|,
name|line
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|!
name|TD_IS_IDLETHREAD
argument_list|(
name|curthread
argument_list|)
argument_list|,
operator|(
literal|"%s: idle thread %p on lockmgr %s @ %s:%d"
operator|,
name|__func__
operator|,
name|curthread
operator|,
name|lk
operator|->
name|lock_object
operator|.
name|lo_name
operator|,
name|file
operator|,
name|line
operator|)
argument_list|)
expr_stmt|;
name|class
operator|=
operator|(
name|flags
operator|&
name|LK_INTERLOCK
operator|)
condition|?
name|LOCK_CLASS
argument_list|(
name|ilk
argument_list|)
else|:
name|NULL
expr_stmt|;
if|if
condition|(
name|panicstr
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|flags
operator|&
name|LK_INTERLOCK
condition|)
name|class
operator|->
name|lc_unlock
argument_list|(
name|ilk
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|lk
operator|->
name|lock_object
operator|.
name|lo_flags
operator|&
name|LK_NOSHARE
condition|)
block|{
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|LK_SHARED
case|:
name|op
operator|=
name|LK_EXCLUSIVE
expr_stmt|;
break|break;
case|case
name|LK_UPGRADE
case|:
case|case
name|LK_DOWNGRADE
case|:
name|_lockmgr_assert
argument_list|(
name|lk
argument_list|,
name|KA_XLOCKED
operator||
name|KA_NOTRECURSED
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
name|wakeup_swapper
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|LK_SHARED
case|:
if|if
condition|(
name|LK_CAN_WITNESS
argument_list|(
name|flags
argument_list|)
condition|)
name|WITNESS_CHECKORDER
argument_list|(
operator|&
name|lk
operator|->
name|lock_object
argument_list|,
name|LOP_NEWORDER
argument_list|,
name|file
argument_list|,
name|line
argument_list|,
name|ilk
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|x
operator|=
name|lk
operator|->
name|lk_lock
expr_stmt|;
comment|/* 			 * If no other thread has an exclusive lock, or 			 * no exclusive waiter is present, bump the count of 			 * sharers.  Since we have to preserve the state of 			 * waiters, if we fail to acquire the shared lock 			 * loop back and retry. 			 */
if|if
condition|(
name|LK_CAN_SHARE
argument_list|(
name|x
argument_list|)
condition|)
block|{
if|if
condition|(
name|atomic_cmpset_acq_ptr
argument_list|(
operator|&
name|lk
operator|->
name|lk_lock
argument_list|,
name|x
argument_list|,
name|x
operator|+
name|LK_ONE_SHARER
argument_list|)
condition|)
break|break;
continue|continue;
block|}
ifdef|#
directive|ifdef
name|HWPMC_HOOKS
name|PMC_SOFT_CALL
argument_list|( , ,
name|lock
argument_list|,
name|failed
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|lock_profile_obtain_lock_failed
argument_list|(
operator|&
name|lk
operator|->
name|lock_object
argument_list|,
operator|&
name|contested
argument_list|,
operator|&
name|waittime
argument_list|)
expr_stmt|;
comment|/* 			 * If the lock is already held by curthread in 			 * exclusive way avoid a deadlock. 			 */
if|if
condition|(
name|LK_HOLDER
argument_list|(
name|x
argument_list|)
operator|==
name|tid
condition|)
block|{
name|LOCK_LOG2
argument_list|(
name|lk
argument_list|,
literal|"%s: %p already held in exclusive mode"
argument_list|,
name|__func__
argument_list|,
name|lk
argument_list|)
expr_stmt|;
name|error
operator|=
name|EDEADLK
expr_stmt|;
break|break;
block|}
comment|/* 			 * If the lock is expected to not sleep just give up 			 * and return. 			 */
if|if
condition|(
name|LK_TRYOP
argument_list|(
name|flags
argument_list|)
condition|)
block|{
name|LOCK_LOG2
argument_list|(
name|lk
argument_list|,
literal|"%s: %p fails the try operation"
argument_list|,
name|__func__
argument_list|,
name|lk
argument_list|)
expr_stmt|;
name|error
operator|=
name|EBUSY
expr_stmt|;
break|break;
block|}
ifdef|#
directive|ifdef
name|ADAPTIVE_LOCKMGRS
comment|/* 			 * If the owner is running on another CPU, spin until 			 * the owner stops running or the state of the lock 			 * changes.  We need a double-state handle here 			 * because for a failed acquisition the lock can be 			 * either held in exclusive mode or shared mode 			 * (for the writer starvation avoidance technique). 			 */
if|if
condition|(
name|LK_CAN_ADAPT
argument_list|(
name|lk
argument_list|,
name|flags
argument_list|)
operator|&&
operator|(
name|x
operator|&
name|LK_SHARE
operator|)
operator|==
literal|0
operator|&&
name|LK_HOLDER
argument_list|(
name|x
argument_list|)
operator|!=
name|LK_KERNPROC
condition|)
block|{
name|owner
operator|=
operator|(
expr|struct
name|thread
operator|*
operator|)
name|LK_HOLDER
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOCK_LOG_TEST
argument_list|(
operator|&
name|lk
operator|->
name|lock_object
argument_list|,
literal|0
argument_list|)
condition|)
name|CTR3
argument_list|(
name|KTR_LOCK
argument_list|,
literal|"%s: spinning on %p held by %p"
argument_list|,
name|__func__
argument_list|,
name|lk
argument_list|,
name|owner
argument_list|)
expr_stmt|;
comment|/* 				 * If we are holding also an interlock drop it 				 * in order to avoid a deadlock if the lockmgr 				 * owner is adaptively spinning on the 				 * interlock itself. 				 */
if|if
condition|(
name|flags
operator|&
name|LK_INTERLOCK
condition|)
block|{
name|class
operator|->
name|lc_unlock
argument_list|(
name|ilk
argument_list|)
expr_stmt|;
name|flags
operator|&=
operator|~
name|LK_INTERLOCK
expr_stmt|;
block|}
name|GIANT_SAVE
argument_list|()
expr_stmt|;
while|while
condition|(
name|LK_HOLDER
argument_list|(
name|lk
operator|->
name|lk_lock
argument_list|)
operator|==
operator|(
name|uintptr_t
operator|)
name|owner
operator|&&
name|TD_IS_RUNNING
argument_list|(
name|owner
argument_list|)
condition|)
name|cpu_spinwait
argument_list|()
expr_stmt|;
name|GIANT_RESTORE
argument_list|()
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|LK_CAN_ADAPT
argument_list|(
name|lk
argument_list|,
name|flags
argument_list|)
operator|&&
operator|(
name|x
operator|&
name|LK_SHARE
operator|)
operator|!=
literal|0
operator|&&
name|LK_SHARERS
argument_list|(
name|x
argument_list|)
operator|&&
name|spintries
operator|<
name|alk_retries
condition|)
block|{
if|if
condition|(
name|flags
operator|&
name|LK_INTERLOCK
condition|)
block|{
name|class
operator|->
name|lc_unlock
argument_list|(
name|ilk
argument_list|)
expr_stmt|;
name|flags
operator|&=
operator|~
name|LK_INTERLOCK
expr_stmt|;
block|}
name|GIANT_SAVE
argument_list|()
expr_stmt|;
name|spintries
operator|++
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|alk_loops
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|LOCK_LOG_TEST
argument_list|(
operator|&
name|lk
operator|->
name|lock_object
argument_list|,
literal|0
argument_list|)
condition|)
name|CTR4
argument_list|(
name|KTR_LOCK
argument_list|,
literal|"%s: shared spinning on %p with %u and %u"
argument_list|,
name|__func__
argument_list|,
name|lk
argument_list|,
name|spintries
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|x
operator|=
name|lk
operator|->
name|lk_lock
expr_stmt|;
if|if
condition|(
operator|(
name|x
operator|&
name|LK_SHARE
operator|)
operator|==
literal|0
operator|||
name|LK_CAN_SHARE
argument_list|(
name|x
argument_list|)
operator|!=
literal|0
condition|)
break|break;
name|cpu_spinwait
argument_list|()
expr_stmt|;
block|}
name|GIANT_RESTORE
argument_list|()
expr_stmt|;
if|if
condition|(
name|i
operator|!=
name|alk_loops
condition|)
continue|continue;
block|}
endif|#
directive|endif
comment|/* 			 * Acquire the sleepqueue chain lock because we 			 * probabilly will need to manipulate waiters flags. 			 */
name|sleepq_lock
argument_list|(
operator|&
name|lk
operator|->
name|lock_object
argument_list|)
expr_stmt|;
name|x
operator|=
name|lk
operator|->
name|lk_lock
expr_stmt|;
comment|/* 			 * if the lock can be acquired in shared mode, try 			 * again. 			 */
if|if
condition|(
name|LK_CAN_SHARE
argument_list|(
name|x
argument_list|)
condition|)
block|{
name|sleepq_release
argument_list|(
operator|&
name|lk
operator|->
name|lock_object
argument_list|)
expr_stmt|;
continue|continue;
block|}
ifdef|#
directive|ifdef
name|ADAPTIVE_LOCKMGRS
comment|/* 			 * The current lock owner might have started executing 			 * on another CPU (or the lock could have changed 			 * owner) while we were waiting on the turnstile 			 * chain lock.  If so, drop the turnstile lock and try 			 * again. 			 */
if|if
condition|(
name|LK_CAN_ADAPT
argument_list|(
name|lk
argument_list|,
name|flags
argument_list|)
operator|&&
operator|(
name|x
operator|&
name|LK_SHARE
operator|)
operator|==
literal|0
operator|&&
name|LK_HOLDER
argument_list|(
name|x
argument_list|)
operator|!=
name|LK_KERNPROC
condition|)
block|{
name|owner
operator|=
operator|(
expr|struct
name|thread
operator|*
operator|)
name|LK_HOLDER
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|TD_IS_RUNNING
argument_list|(
name|owner
argument_list|)
condition|)
block|{
name|sleepq_release
argument_list|(
operator|&
name|lk
operator|->
name|lock_object
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
endif|#
directive|endif
comment|/* 			 * Try to set the LK_SHARED_WAITERS flag.  If we fail, 			 * loop back and retry. 			 */
if|if
condition|(
operator|(
name|x
operator|&
name|LK_SHARED_WAITERS
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|atomic_cmpset_acq_ptr
argument_list|(
operator|&
name|lk
operator|->
name|lk_lock
argument_list|,
name|x
argument_list|,
name|x
operator||
name|LK_SHARED_WAITERS
argument_list|)
condition|)
block|{
name|sleepq_release
argument_list|(
operator|&
name|lk
operator|->
name|lock_object
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|LOCK_LOG2
argument_list|(
name|lk
argument_list|,
literal|"%s: %p set shared waiters flag"
argument_list|,
name|__func__
argument_list|,
name|lk
argument_list|)
expr_stmt|;
block|}
comment|/* 			 * As far as we have been unable to acquire the 			 * shared lock and the shared waiters flag is set, 			 * we will sleep. 			 */
name|error
operator|=
name|sleeplk
argument_list|(
name|lk
argument_list|,
name|flags
argument_list|,
name|ilk
argument_list|,
name|iwmesg
argument_list|,
name|ipri
argument_list|,
name|itimo
argument_list|,
name|SQ_SHARED_QUEUE
argument_list|)
expr_stmt|;
name|flags
operator|&=
operator|~
name|LK_INTERLOCK
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|LOCK_LOG3
argument_list|(
name|lk
argument_list|,
literal|"%s: interrupted sleep for %p with %d"
argument_list|,
name|__func__
argument_list|,
name|lk
argument_list|,
name|error
argument_list|)
expr_stmt|;
break|break;
block|}
name|LOCK_LOG2
argument_list|(
name|lk
argument_list|,
literal|"%s: %p resuming from the sleep queue"
argument_list|,
name|__func__
argument_list|,
name|lk
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|lock_profile_obtain_lock_success
argument_list|(
operator|&
name|lk
operator|->
name|lock_object
argument_list|,
name|contested
argument_list|,
name|waittime
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|LOCK_LOG_LOCK
argument_list|(
literal|"SLOCK"
argument_list|,
operator|&
name|lk
operator|->
name|lock_object
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|WITNESS_LOCK
argument_list|(
operator|&
name|lk
operator|->
name|lock_object
argument_list|,
name|LK_TRYWIT
argument_list|(
name|flags
argument_list|)
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|TD_LOCKS_INC
argument_list|(
name|curthread
argument_list|)
expr_stmt|;
name|TD_SLOCKS_INC
argument_list|(
name|curthread
argument_list|)
expr_stmt|;
name|STACK_SAVE
argument_list|(
name|lk
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|LK_UPGRADE
case|:
name|_lockmgr_assert
argument_list|(
name|lk
argument_list|,
name|KA_SLOCKED
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|v
operator|=
name|lk
operator|->
name|lk_lock
expr_stmt|;
name|x
operator|=
name|v
operator|&
name|LK_ALL_WAITERS
expr_stmt|;
name|v
operator|&=
name|LK_EXCLUSIVE_SPINNERS
expr_stmt|;
comment|/* 		 * Try to switch from one shared lock to an exclusive one. 		 * We need to preserve waiters flags during the operation. 		 */
if|if
condition|(
name|atomic_cmpset_ptr
argument_list|(
operator|&
name|lk
operator|->
name|lk_lock
argument_list|,
name|LK_SHARERS_LOCK
argument_list|(
literal|1
argument_list|)
operator||
name|x
operator||
name|v
argument_list|,
name|tid
operator||
name|x
argument_list|)
condition|)
block|{
name|LOCK_LOG_LOCK
argument_list|(
literal|"XUPGRADE"
argument_list|,
operator|&
name|lk
operator|->
name|lock_object
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|WITNESS_UPGRADE
argument_list|(
operator|&
name|lk
operator|->
name|lock_object
argument_list|,
name|LOP_EXCLUSIVE
operator||
name|LK_TRYWIT
argument_list|(
name|flags
argument_list|)
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|TD_SLOCKS_DEC
argument_list|(
name|curthread
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* 		 * We have been unable to succeed in upgrading, so just 		 * give up the shared lock. 		 */
name|wakeup_swapper
operator||=
name|wakeupshlk
argument_list|(
name|lk
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
name|LK_EXCLUSIVE
case|:
if|if
condition|(
name|LK_CAN_WITNESS
argument_list|(
name|flags
argument_list|)
condition|)
name|WITNESS_CHECKORDER
argument_list|(
operator|&
name|lk
operator|->
name|lock_object
argument_list|,
name|LOP_NEWORDER
operator||
name|LOP_EXCLUSIVE
argument_list|,
name|file
argument_list|,
name|line
argument_list|,
name|ilk
argument_list|)
expr_stmt|;
comment|/* 		 * If curthread already holds the lock and this one is 		 * allowed to recurse, simply recurse on it. 		 */
if|if
condition|(
name|lockmgr_xlocked
argument_list|(
name|lk
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|flags
operator|&
name|LK_CANRECURSE
operator|)
operator|==
literal|0
operator|&&
operator|(
name|lk
operator|->
name|lock_object
operator|.
name|lo_flags
operator|&
name|LO_RECURSABLE
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 				 * If the lock is expected to not panic just 				 * give up and return. 				 */
if|if
condition|(
name|LK_TRYOP
argument_list|(
name|flags
argument_list|)
condition|)
block|{
name|LOCK_LOG2
argument_list|(
name|lk
argument_list|,
literal|"%s: %p fails the try operation"
argument_list|,
name|__func__
argument_list|,
name|lk
argument_list|)
expr_stmt|;
name|error
operator|=
name|EBUSY
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|flags
operator|&
name|LK_INTERLOCK
condition|)
name|class
operator|->
name|lc_unlock
argument_list|(
name|ilk
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"%s: recursing on non recursive lockmgr %s @ %s:%d\n"
argument_list|,
name|__func__
argument_list|,
name|iwmesg
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
block|}
name|lk
operator|->
name|lk_recurse
operator|++
expr_stmt|;
name|LOCK_LOG2
argument_list|(
name|lk
argument_list|,
literal|"%s: %p recursing"
argument_list|,
name|__func__
argument_list|,
name|lk
argument_list|)
expr_stmt|;
name|LOCK_LOG_LOCK
argument_list|(
literal|"XLOCK"
argument_list|,
operator|&
name|lk
operator|->
name|lock_object
argument_list|,
literal|0
argument_list|,
name|lk
operator|->
name|lk_recurse
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|WITNESS_LOCK
argument_list|(
operator|&
name|lk
operator|->
name|lock_object
argument_list|,
name|LOP_EXCLUSIVE
operator||
name|LK_TRYWIT
argument_list|(
name|flags
argument_list|)
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|TD_LOCKS_INC
argument_list|(
name|curthread
argument_list|)
expr_stmt|;
break|break;
block|}
while|while
condition|(
operator|!
name|atomic_cmpset_acq_ptr
argument_list|(
operator|&
name|lk
operator|->
name|lk_lock
argument_list|,
name|LK_UNLOCKED
argument_list|,
name|tid
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|HWPMC_HOOKS
name|PMC_SOFT_CALL
argument_list|( , ,
name|lock
argument_list|,
name|failed
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|lock_profile_obtain_lock_failed
argument_list|(
operator|&
name|lk
operator|->
name|lock_object
argument_list|,
operator|&
name|contested
argument_list|,
operator|&
name|waittime
argument_list|)
expr_stmt|;
comment|/* 			 * If the lock is expected to not sleep just give up 			 * and return. 			 */
if|if
condition|(
name|LK_TRYOP
argument_list|(
name|flags
argument_list|)
condition|)
block|{
name|LOCK_LOG2
argument_list|(
name|lk
argument_list|,
literal|"%s: %p fails the try operation"
argument_list|,
name|__func__
argument_list|,
name|lk
argument_list|)
expr_stmt|;
name|error
operator|=
name|EBUSY
expr_stmt|;
break|break;
block|}
ifdef|#
directive|ifdef
name|ADAPTIVE_LOCKMGRS
comment|/* 			 * If the owner is running on another CPU, spin until 			 * the owner stops running or the state of the lock 			 * changes. 			 */
name|x
operator|=
name|lk
operator|->
name|lk_lock
expr_stmt|;
if|if
condition|(
name|LK_CAN_ADAPT
argument_list|(
name|lk
argument_list|,
name|flags
argument_list|)
operator|&&
operator|(
name|x
operator|&
name|LK_SHARE
operator|)
operator|==
literal|0
operator|&&
name|LK_HOLDER
argument_list|(
name|x
argument_list|)
operator|!=
name|LK_KERNPROC
condition|)
block|{
name|owner
operator|=
operator|(
expr|struct
name|thread
operator|*
operator|)
name|LK_HOLDER
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOCK_LOG_TEST
argument_list|(
operator|&
name|lk
operator|->
name|lock_object
argument_list|,
literal|0
argument_list|)
condition|)
name|CTR3
argument_list|(
name|KTR_LOCK
argument_list|,
literal|"%s: spinning on %p held by %p"
argument_list|,
name|__func__
argument_list|,
name|lk
argument_list|,
name|owner
argument_list|)
expr_stmt|;
comment|/* 				 * If we are holding also an interlock drop it 				 * in order to avoid a deadlock if the lockmgr 				 * owner is adaptively spinning on the 				 * interlock itself. 				 */
if|if
condition|(
name|flags
operator|&
name|LK_INTERLOCK
condition|)
block|{
name|class
operator|->
name|lc_unlock
argument_list|(
name|ilk
argument_list|)
expr_stmt|;
name|flags
operator|&=
operator|~
name|LK_INTERLOCK
expr_stmt|;
block|}
name|GIANT_SAVE
argument_list|()
expr_stmt|;
while|while
condition|(
name|LK_HOLDER
argument_list|(
name|lk
operator|->
name|lk_lock
argument_list|)
operator|==
operator|(
name|uintptr_t
operator|)
name|owner
operator|&&
name|TD_IS_RUNNING
argument_list|(
name|owner
argument_list|)
condition|)
name|cpu_spinwait
argument_list|()
expr_stmt|;
name|GIANT_RESTORE
argument_list|()
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|LK_CAN_ADAPT
argument_list|(
name|lk
argument_list|,
name|flags
argument_list|)
operator|&&
operator|(
name|x
operator|&
name|LK_SHARE
operator|)
operator|!=
literal|0
operator|&&
name|LK_SHARERS
argument_list|(
name|x
argument_list|)
operator|&&
name|spintries
operator|<
name|alk_retries
condition|)
block|{
if|if
condition|(
operator|(
name|x
operator|&
name|LK_EXCLUSIVE_SPINNERS
operator|)
operator|==
literal|0
operator|&&
operator|!
name|atomic_cmpset_ptr
argument_list|(
operator|&
name|lk
operator|->
name|lk_lock
argument_list|,
name|x
argument_list|,
name|x
operator||
name|LK_EXCLUSIVE_SPINNERS
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|flags
operator|&
name|LK_INTERLOCK
condition|)
block|{
name|class
operator|->
name|lc_unlock
argument_list|(
name|ilk
argument_list|)
expr_stmt|;
name|flags
operator|&=
operator|~
name|LK_INTERLOCK
expr_stmt|;
block|}
name|GIANT_SAVE
argument_list|()
expr_stmt|;
name|spintries
operator|++
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|alk_loops
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|LOCK_LOG_TEST
argument_list|(
operator|&
name|lk
operator|->
name|lock_object
argument_list|,
literal|0
argument_list|)
condition|)
name|CTR4
argument_list|(
name|KTR_LOCK
argument_list|,
literal|"%s: shared spinning on %p with %u and %u"
argument_list|,
name|__func__
argument_list|,
name|lk
argument_list|,
name|spintries
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|lk
operator|->
name|lk_lock
operator|&
name|LK_EXCLUSIVE_SPINNERS
operator|)
operator|==
literal|0
condition|)
break|break;
name|cpu_spinwait
argument_list|()
expr_stmt|;
block|}
name|GIANT_RESTORE
argument_list|()
expr_stmt|;
if|if
condition|(
name|i
operator|!=
name|alk_loops
condition|)
continue|continue;
block|}
endif|#
directive|endif
comment|/* 			 * Acquire the sleepqueue chain lock because we 			 * probabilly will need to manipulate waiters flags. 			 */
name|sleepq_lock
argument_list|(
operator|&
name|lk
operator|->
name|lock_object
argument_list|)
expr_stmt|;
name|x
operator|=
name|lk
operator|->
name|lk_lock
expr_stmt|;
comment|/* 			 * if the lock has been released while we spun on 			 * the sleepqueue chain lock just try again. 			 */
if|if
condition|(
name|x
operator|==
name|LK_UNLOCKED
condition|)
block|{
name|sleepq_release
argument_list|(
operator|&
name|lk
operator|->
name|lock_object
argument_list|)
expr_stmt|;
continue|continue;
block|}
ifdef|#
directive|ifdef
name|ADAPTIVE_LOCKMGRS
comment|/* 			 * The current lock owner might have started executing 			 * on another CPU (or the lock could have changed 			 * owner) while we were waiting on the turnstile 			 * chain lock.  If so, drop the turnstile lock and try 			 * again. 			 */
if|if
condition|(
name|LK_CAN_ADAPT
argument_list|(
name|lk
argument_list|,
name|flags
argument_list|)
operator|&&
operator|(
name|x
operator|&
name|LK_SHARE
operator|)
operator|==
literal|0
operator|&&
name|LK_HOLDER
argument_list|(
name|x
argument_list|)
operator|!=
name|LK_KERNPROC
condition|)
block|{
name|owner
operator|=
operator|(
expr|struct
name|thread
operator|*
operator|)
name|LK_HOLDER
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|TD_IS_RUNNING
argument_list|(
name|owner
argument_list|)
condition|)
block|{
name|sleepq_release
argument_list|(
operator|&
name|lk
operator|->
name|lock_object
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
endif|#
directive|endif
comment|/* 			 * The lock can be in the state where there is a 			 * pending queue of waiters, but still no owner. 			 * This happens when the lock is contested and an 			 * owner is going to claim the lock. 			 * If curthread is the one successfully acquiring it 			 * claim lock ownership and return, preserving waiters 			 * flags. 			 */
name|v
operator|=
name|x
operator|&
operator|(
name|LK_ALL_WAITERS
operator||
name|LK_EXCLUSIVE_SPINNERS
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|x
operator|&
operator|~
name|v
operator|)
operator|==
name|LK_UNLOCKED
condition|)
block|{
name|v
operator|&=
operator|~
name|LK_EXCLUSIVE_SPINNERS
expr_stmt|;
if|if
condition|(
name|atomic_cmpset_acq_ptr
argument_list|(
operator|&
name|lk
operator|->
name|lk_lock
argument_list|,
name|x
argument_list|,
name|tid
operator||
name|v
argument_list|)
condition|)
block|{
name|sleepq_release
argument_list|(
operator|&
name|lk
operator|->
name|lock_object
argument_list|)
expr_stmt|;
name|LOCK_LOG2
argument_list|(
name|lk
argument_list|,
literal|"%s: %p claimed by a new writer"
argument_list|,
name|__func__
argument_list|,
name|lk
argument_list|)
expr_stmt|;
break|break;
block|}
name|sleepq_release
argument_list|(
operator|&
name|lk
operator|->
name|lock_object
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* 			 * Try to set the LK_EXCLUSIVE_WAITERS flag.  If we 			 * fail, loop back and retry. 			 */
if|if
condition|(
operator|(
name|x
operator|&
name|LK_EXCLUSIVE_WAITERS
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|atomic_cmpset_ptr
argument_list|(
operator|&
name|lk
operator|->
name|lk_lock
argument_list|,
name|x
argument_list|,
name|x
operator||
name|LK_EXCLUSIVE_WAITERS
argument_list|)
condition|)
block|{
name|sleepq_release
argument_list|(
operator|&
name|lk
operator|->
name|lock_object
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|LOCK_LOG2
argument_list|(
name|lk
argument_list|,
literal|"%s: %p set excl waiters flag"
argument_list|,
name|__func__
argument_list|,
name|lk
argument_list|)
expr_stmt|;
block|}
comment|/* 			 * As far as we have been unable to acquire the 			 * exclusive lock and the exclusive waiters flag 			 * is set, we will sleep. 			 */
name|error
operator|=
name|sleeplk
argument_list|(
name|lk
argument_list|,
name|flags
argument_list|,
name|ilk
argument_list|,
name|iwmesg
argument_list|,
name|ipri
argument_list|,
name|itimo
argument_list|,
name|SQ_EXCLUSIVE_QUEUE
argument_list|)
expr_stmt|;
name|flags
operator|&=
operator|~
name|LK_INTERLOCK
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|LOCK_LOG3
argument_list|(
name|lk
argument_list|,
literal|"%s: interrupted sleep for %p with %d"
argument_list|,
name|__func__
argument_list|,
name|lk
argument_list|,
name|error
argument_list|)
expr_stmt|;
break|break;
block|}
name|LOCK_LOG2
argument_list|(
name|lk
argument_list|,
literal|"%s: %p resuming from the sleep queue"
argument_list|,
name|__func__
argument_list|,
name|lk
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|lock_profile_obtain_lock_success
argument_list|(
operator|&
name|lk
operator|->
name|lock_object
argument_list|,
name|contested
argument_list|,
name|waittime
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|LOCK_LOG_LOCK
argument_list|(
literal|"XLOCK"
argument_list|,
operator|&
name|lk
operator|->
name|lock_object
argument_list|,
literal|0
argument_list|,
name|lk
operator|->
name|lk_recurse
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|WITNESS_LOCK
argument_list|(
operator|&
name|lk
operator|->
name|lock_object
argument_list|,
name|LOP_EXCLUSIVE
operator||
name|LK_TRYWIT
argument_list|(
name|flags
argument_list|)
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|TD_LOCKS_INC
argument_list|(
name|curthread
argument_list|)
expr_stmt|;
name|STACK_SAVE
argument_list|(
name|lk
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|LK_DOWNGRADE
case|:
name|_lockmgr_assert
argument_list|(
name|lk
argument_list|,
name|KA_XLOCKED
operator||
name|KA_NOTRECURSED
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|LOCK_LOG_LOCK
argument_list|(
literal|"XDOWNGRADE"
argument_list|,
operator|&
name|lk
operator|->
name|lock_object
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|WITNESS_DOWNGRADE
argument_list|(
operator|&
name|lk
operator|->
name|lock_object
argument_list|,
literal|0
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|TD_SLOCKS_INC
argument_list|(
name|curthread
argument_list|)
expr_stmt|;
comment|/* 		 * In order to preserve waiters flags, just spin. 		 */
for|for
control|(
init|;
condition|;
control|)
block|{
name|x
operator|=
name|lk
operator|->
name|lk_lock
expr_stmt|;
name|MPASS
argument_list|(
operator|(
name|x
operator|&
name|LK_EXCLUSIVE_SPINNERS
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|x
operator|&=
name|LK_ALL_WAITERS
expr_stmt|;
if|if
condition|(
name|atomic_cmpset_rel_ptr
argument_list|(
operator|&
name|lk
operator|->
name|lk_lock
argument_list|,
name|tid
operator||
name|x
argument_list|,
name|LK_SHARERS_LOCK
argument_list|(
literal|1
argument_list|)
operator||
name|x
argument_list|)
condition|)
break|break;
name|cpu_spinwait
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|LK_RELEASE
case|:
name|_lockmgr_assert
argument_list|(
name|lk
argument_list|,
name|KA_LOCKED
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|x
operator|=
name|lk
operator|->
name|lk_lock
expr_stmt|;
if|if
condition|(
operator|(
name|x
operator|&
name|LK_SHARE
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 			 * As first option, treact the lock as if it has not 			 * any waiter. 			 * Fix-up the tid var if the lock has been disowned. 			 */
if|if
condition|(
name|LK_HOLDER
argument_list|(
name|x
argument_list|)
operator|==
name|LK_KERNPROC
condition|)
name|tid
operator|=
name|LK_KERNPROC
expr_stmt|;
else|else
block|{
name|WITNESS_UNLOCK
argument_list|(
operator|&
name|lk
operator|->
name|lock_object
argument_list|,
name|LOP_EXCLUSIVE
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|TD_LOCKS_DEC
argument_list|(
name|curthread
argument_list|)
expr_stmt|;
block|}
name|LOCK_LOG_LOCK
argument_list|(
literal|"XUNLOCK"
argument_list|,
operator|&
name|lk
operator|->
name|lock_object
argument_list|,
literal|0
argument_list|,
name|lk
operator|->
name|lk_recurse
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
comment|/* 			 * The lock is held in exclusive mode. 			 * If the lock is recursed also, then unrecurse it. 			 */
if|if
condition|(
name|lockmgr_xlocked
argument_list|(
name|lk
argument_list|)
operator|&&
name|lockmgr_recursed
argument_list|(
name|lk
argument_list|)
condition|)
block|{
name|LOCK_LOG2
argument_list|(
name|lk
argument_list|,
literal|"%s: %p unrecursing"
argument_list|,
name|__func__
argument_list|,
name|lk
argument_list|)
expr_stmt|;
name|lk
operator|->
name|lk_recurse
operator|--
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|tid
operator|!=
name|LK_KERNPROC
condition|)
name|lock_profile_release_lock
argument_list|(
operator|&
name|lk
operator|->
name|lock_object
argument_list|)
expr_stmt|;
if|if
condition|(
name|atomic_cmpset_rel_ptr
argument_list|(
operator|&
name|lk
operator|->
name|lk_lock
argument_list|,
name|tid
argument_list|,
name|LK_UNLOCKED
argument_list|)
condition|)
break|break;
name|sleepq_lock
argument_list|(
operator|&
name|lk
operator|->
name|lock_object
argument_list|)
expr_stmt|;
name|x
operator|=
name|lk
operator|->
name|lk_lock
expr_stmt|;
name|v
operator|=
name|LK_UNLOCKED
expr_stmt|;
comment|/* 		 	 * If the lock has exclusive waiters, give them 			 * preference in order to avoid deadlock with 			 * shared runners up. 			 * If interruptible sleeps left the exclusive queue 			 * empty avoid a starvation for the threads sleeping 			 * on the shared queue by giving them precedence 			 * and cleaning up the exclusive waiters bit anyway. 			 * Please note that lk_exslpfail count may be lying 			 * about the real number of waiters with the 			 * LK_SLEEPFAIL flag on because they may be used in 			 * conjuction with interruptible sleeps so 			 * lk_exslpfail might be considered an 'upper limit' 			 * bound, including the edge cases. 			 */
name|MPASS
argument_list|(
operator|(
name|x
operator|&
name|LK_EXCLUSIVE_SPINNERS
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|realexslp
operator|=
name|sleepq_sleepcnt
argument_list|(
operator|&
name|lk
operator|->
name|lock_object
argument_list|,
name|SQ_EXCLUSIVE_QUEUE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|x
operator|&
name|LK_EXCLUSIVE_WAITERS
operator|)
operator|!=
literal|0
operator|&&
name|realexslp
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|lk
operator|->
name|lk_exslpfail
operator|<
name|realexslp
condition|)
block|{
name|lk
operator|->
name|lk_exslpfail
operator|=
literal|0
expr_stmt|;
name|queue
operator|=
name|SQ_EXCLUSIVE_QUEUE
expr_stmt|;
name|v
operator||=
operator|(
name|x
operator|&
name|LK_SHARED_WAITERS
operator|)
expr_stmt|;
block|}
else|else
block|{
name|lk
operator|->
name|lk_exslpfail
operator|=
literal|0
expr_stmt|;
name|LOCK_LOG2
argument_list|(
name|lk
argument_list|,
literal|"%s: %p has only LK_SLEEPFAIL sleepers"
argument_list|,
name|__func__
argument_list|,
name|lk
argument_list|)
expr_stmt|;
name|LOCK_LOG2
argument_list|(
name|lk
argument_list|,
literal|"%s: %p waking up threads on the exclusive queue"
argument_list|,
name|__func__
argument_list|,
name|lk
argument_list|)
expr_stmt|;
name|wakeup_swapper
operator|=
name|sleepq_broadcast
argument_list|(
operator|&
name|lk
operator|->
name|lock_object
argument_list|,
name|SLEEPQ_LK
argument_list|,
literal|0
argument_list|,
name|SQ_EXCLUSIVE_QUEUE
argument_list|)
expr_stmt|;
name|queue
operator|=
name|SQ_SHARED_QUEUE
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 				 * Exclusive waiters sleeping with LK_SLEEPFAIL 				 * on and using interruptible sleeps/timeout 				 * may have left spourious lk_exslpfail counts 				 * on, so clean it up anyway.  				 */
name|lk
operator|->
name|lk_exslpfail
operator|=
literal|0
expr_stmt|;
name|queue
operator|=
name|SQ_SHARED_QUEUE
expr_stmt|;
block|}
name|LOCK_LOG3
argument_list|(
name|lk
argument_list|,
literal|"%s: %p waking up threads on the %s queue"
argument_list|,
name|__func__
argument_list|,
name|lk
argument_list|,
name|queue
operator|==
name|SQ_SHARED_QUEUE
condition|?
literal|"shared"
else|:
literal|"exclusive"
argument_list|)
expr_stmt|;
name|atomic_store_rel_ptr
argument_list|(
operator|&
name|lk
operator|->
name|lk_lock
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|wakeup_swapper
operator||=
name|sleepq_broadcast
argument_list|(
operator|&
name|lk
operator|->
name|lock_object
argument_list|,
name|SLEEPQ_LK
argument_list|,
literal|0
argument_list|,
name|queue
argument_list|)
expr_stmt|;
name|sleepq_release
argument_list|(
operator|&
name|lk
operator|->
name|lock_object
argument_list|)
expr_stmt|;
break|break;
block|}
else|else
name|wakeup_swapper
operator|=
name|wakeupshlk
argument_list|(
name|lk
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
break|break;
case|case
name|LK_DRAIN
case|:
if|if
condition|(
name|LK_CAN_WITNESS
argument_list|(
name|flags
argument_list|)
condition|)
name|WITNESS_CHECKORDER
argument_list|(
operator|&
name|lk
operator|->
name|lock_object
argument_list|,
name|LOP_NEWORDER
operator||
name|LOP_EXCLUSIVE
argument_list|,
name|file
argument_list|,
name|line
argument_list|,
name|ilk
argument_list|)
expr_stmt|;
comment|/* 		 * Trying to drain a lock we already own will result in a 		 * deadlock. 		 */
if|if
condition|(
name|lockmgr_xlocked
argument_list|(
name|lk
argument_list|)
condition|)
block|{
if|if
condition|(
name|flags
operator|&
name|LK_INTERLOCK
condition|)
name|class
operator|->
name|lc_unlock
argument_list|(
name|ilk
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"%s: draining %s with the lock held @ %s:%d\n"
argument_list|,
name|__func__
argument_list|,
name|iwmesg
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|!
name|atomic_cmpset_acq_ptr
argument_list|(
operator|&
name|lk
operator|->
name|lk_lock
argument_list|,
name|LK_UNLOCKED
argument_list|,
name|tid
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|HWPMC_HOOKS
name|PMC_SOFT_CALL
argument_list|( , ,
name|lock
argument_list|,
name|failed
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|lock_profile_obtain_lock_failed
argument_list|(
operator|&
name|lk
operator|->
name|lock_object
argument_list|,
operator|&
name|contested
argument_list|,
operator|&
name|waittime
argument_list|)
expr_stmt|;
comment|/* 			 * If the lock is expected to not sleep just give up 			 * and return. 			 */
if|if
condition|(
name|LK_TRYOP
argument_list|(
name|flags
argument_list|)
condition|)
block|{
name|LOCK_LOG2
argument_list|(
name|lk
argument_list|,
literal|"%s: %p fails the try operation"
argument_list|,
name|__func__
argument_list|,
name|lk
argument_list|)
expr_stmt|;
name|error
operator|=
name|EBUSY
expr_stmt|;
break|break;
block|}
comment|/* 			 * Acquire the sleepqueue chain lock because we 			 * probabilly will need to manipulate waiters flags. 			 */
name|sleepq_lock
argument_list|(
operator|&
name|lk
operator|->
name|lock_object
argument_list|)
expr_stmt|;
name|x
operator|=
name|lk
operator|->
name|lk_lock
expr_stmt|;
comment|/* 			 * if the lock has been released while we spun on 			 * the sleepqueue chain lock just try again. 			 */
if|if
condition|(
name|x
operator|==
name|LK_UNLOCKED
condition|)
block|{
name|sleepq_release
argument_list|(
operator|&
name|lk
operator|->
name|lock_object
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|v
operator|=
name|x
operator|&
operator|(
name|LK_ALL_WAITERS
operator||
name|LK_EXCLUSIVE_SPINNERS
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|x
operator|&
operator|~
name|v
operator|)
operator|==
name|LK_UNLOCKED
condition|)
block|{
name|v
operator|=
operator|(
name|x
operator|&
operator|~
name|LK_EXCLUSIVE_SPINNERS
operator|)
expr_stmt|;
comment|/* 				 * If interruptible sleeps left the exclusive 				 * queue empty avoid a starvation for the 				 * threads sleeping on the shared queue by 				 * giving them precedence and cleaning up the 				 * exclusive waiters bit anyway. 				 * Please note that lk_exslpfail count may be 				 * lying about the real number of waiters with 				 * the LK_SLEEPFAIL flag on because they may 				 * be used in conjuction with interruptible 				 * sleeps so lk_exslpfail might be considered 				 * an 'upper limit' bound, including the edge 				 * cases. 				 */
if|if
condition|(
name|v
operator|&
name|LK_EXCLUSIVE_WAITERS
condition|)
block|{
name|queue
operator|=
name|SQ_EXCLUSIVE_QUEUE
expr_stmt|;
name|v
operator|&=
operator|~
name|LK_EXCLUSIVE_WAITERS
expr_stmt|;
block|}
else|else
block|{
comment|/* 					 * Exclusive waiters sleeping with 					 * LK_SLEEPFAIL on and using 					 * interruptible sleeps/timeout may 					 * have left spourious lk_exslpfail 					 * counts on, so clean it up anyway. 					 */
name|MPASS
argument_list|(
name|v
operator|&
name|LK_SHARED_WAITERS
argument_list|)
expr_stmt|;
name|lk
operator|->
name|lk_exslpfail
operator|=
literal|0
expr_stmt|;
name|queue
operator|=
name|SQ_SHARED_QUEUE
expr_stmt|;
name|v
operator|&=
operator|~
name|LK_SHARED_WAITERS
expr_stmt|;
block|}
if|if
condition|(
name|queue
operator|==
name|SQ_EXCLUSIVE_QUEUE
condition|)
block|{
name|realexslp
operator|=
name|sleepq_sleepcnt
argument_list|(
operator|&
name|lk
operator|->
name|lock_object
argument_list|,
name|SQ_EXCLUSIVE_QUEUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|lk
operator|->
name|lk_exslpfail
operator|>=
name|realexslp
condition|)
block|{
name|lk
operator|->
name|lk_exslpfail
operator|=
literal|0
expr_stmt|;
name|queue
operator|=
name|SQ_SHARED_QUEUE
expr_stmt|;
name|v
operator|&=
operator|~
name|LK_SHARED_WAITERS
expr_stmt|;
if|if
condition|(
name|realexslp
operator|!=
literal|0
condition|)
block|{
name|LOCK_LOG2
argument_list|(
name|lk
argument_list|,
literal|"%s: %p has only LK_SLEEPFAIL sleepers"
argument_list|,
name|__func__
argument_list|,
name|lk
argument_list|)
expr_stmt|;
name|LOCK_LOG2
argument_list|(
name|lk
argument_list|,
literal|"%s: %p waking up threads on the exclusive queue"
argument_list|,
name|__func__
argument_list|,
name|lk
argument_list|)
expr_stmt|;
name|wakeup_swapper
operator|=
name|sleepq_broadcast
argument_list|(
operator|&
name|lk
operator|->
name|lock_object
argument_list|,
name|SLEEPQ_LK
argument_list|,
literal|0
argument_list|,
name|SQ_EXCLUSIVE_QUEUE
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|lk
operator|->
name|lk_exslpfail
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|atomic_cmpset_ptr
argument_list|(
operator|&
name|lk
operator|->
name|lk_lock
argument_list|,
name|x
argument_list|,
name|v
argument_list|)
condition|)
block|{
name|sleepq_release
argument_list|(
operator|&
name|lk
operator|->
name|lock_object
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|LOCK_LOG3
argument_list|(
name|lk
argument_list|,
literal|"%s: %p waking up all threads on the %s queue"
argument_list|,
name|__func__
argument_list|,
name|lk
argument_list|,
name|queue
operator|==
name|SQ_SHARED_QUEUE
condition|?
literal|"shared"
else|:
literal|"exclusive"
argument_list|)
expr_stmt|;
name|wakeup_swapper
operator||=
name|sleepq_broadcast
argument_list|(
operator|&
name|lk
operator|->
name|lock_object
argument_list|,
name|SLEEPQ_LK
argument_list|,
literal|0
argument_list|,
name|queue
argument_list|)
expr_stmt|;
comment|/* 				 * If shared waiters have been woken up we need 				 * to wait for one of them to acquire the lock 				 * before to set the exclusive waiters in 				 * order to avoid a deadlock. 				 */
if|if
condition|(
name|queue
operator|==
name|SQ_SHARED_QUEUE
condition|)
block|{
for|for
control|(
name|v
operator|=
name|lk
operator|->
name|lk_lock
init|;
operator|(
name|v
operator|&
name|LK_SHARE
operator|)
operator|&&
operator|!
name|LK_SHARERS
argument_list|(
name|v
argument_list|)
condition|;
name|v
operator|=
name|lk
operator|->
name|lk_lock
control|)
name|cpu_spinwait
argument_list|()
expr_stmt|;
block|}
block|}
comment|/* 			 * Try to set the LK_EXCLUSIVE_WAITERS flag.  If we 			 * fail, loop back and retry. 			 */
if|if
condition|(
operator|(
name|x
operator|&
name|LK_EXCLUSIVE_WAITERS
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|atomic_cmpset_ptr
argument_list|(
operator|&
name|lk
operator|->
name|lk_lock
argument_list|,
name|x
argument_list|,
name|x
operator||
name|LK_EXCLUSIVE_WAITERS
argument_list|)
condition|)
block|{
name|sleepq_release
argument_list|(
operator|&
name|lk
operator|->
name|lock_object
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|LOCK_LOG2
argument_list|(
name|lk
argument_list|,
literal|"%s: %p set drain waiters flag"
argument_list|,
name|__func__
argument_list|,
name|lk
argument_list|)
expr_stmt|;
block|}
comment|/* 			 * As far as we have been unable to acquire the 			 * exclusive lock and the exclusive waiters flag 			 * is set, we will sleep. 			 */
if|if
condition|(
name|flags
operator|&
name|LK_INTERLOCK
condition|)
block|{
name|class
operator|->
name|lc_unlock
argument_list|(
name|ilk
argument_list|)
expr_stmt|;
name|flags
operator|&=
operator|~
name|LK_INTERLOCK
expr_stmt|;
block|}
name|GIANT_SAVE
argument_list|()
expr_stmt|;
name|sleepq_add
argument_list|(
operator|&
name|lk
operator|->
name|lock_object
argument_list|,
name|NULL
argument_list|,
name|iwmesg
argument_list|,
name|SLEEPQ_LK
argument_list|,
name|SQ_EXCLUSIVE_QUEUE
argument_list|)
expr_stmt|;
name|sleepq_wait
argument_list|(
operator|&
name|lk
operator|->
name|lock_object
argument_list|,
name|ipri
operator|&
name|PRIMASK
argument_list|)
expr_stmt|;
name|GIANT_RESTORE
argument_list|()
expr_stmt|;
name|LOCK_LOG2
argument_list|(
name|lk
argument_list|,
literal|"%s: %p resuming from the sleep queue"
argument_list|,
name|__func__
argument_list|,
name|lk
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|lock_profile_obtain_lock_success
argument_list|(
operator|&
name|lk
operator|->
name|lock_object
argument_list|,
name|contested
argument_list|,
name|waittime
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|LOCK_LOG_LOCK
argument_list|(
literal|"DRAIN"
argument_list|,
operator|&
name|lk
operator|->
name|lock_object
argument_list|,
literal|0
argument_list|,
name|lk
operator|->
name|lk_recurse
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|WITNESS_LOCK
argument_list|(
operator|&
name|lk
operator|->
name|lock_object
argument_list|,
name|LOP_EXCLUSIVE
operator||
name|LK_TRYWIT
argument_list|(
name|flags
argument_list|)
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|TD_LOCKS_INC
argument_list|(
name|curthread
argument_list|)
expr_stmt|;
name|STACK_SAVE
argument_list|(
name|lk
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
if|if
condition|(
name|flags
operator|&
name|LK_INTERLOCK
condition|)
name|class
operator|->
name|lc_unlock
argument_list|(
name|ilk
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"%s: unknown lockmgr request 0x%x\n"
argument_list|,
name|__func__
argument_list|,
name|op
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flags
operator|&
name|LK_INTERLOCK
condition|)
name|class
operator|->
name|lc_unlock
argument_list|(
name|ilk
argument_list|)
expr_stmt|;
if|if
condition|(
name|wakeup_swapper
condition|)
name|kick_proc0
argument_list|()
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|void
name|_lockmgr_disown
parameter_list|(
name|struct
name|lock
modifier|*
name|lk
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|)
block|{
name|uintptr_t
name|tid
decl_stmt|,
name|x
decl_stmt|;
if|if
condition|(
name|SCHEDULER_STOPPED
argument_list|()
condition|)
return|return;
name|tid
operator|=
operator|(
name|uintptr_t
operator|)
name|curthread
expr_stmt|;
name|_lockmgr_assert
argument_list|(
name|lk
argument_list|,
name|KA_XLOCKED
operator||
name|KA_NOTRECURSED
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
comment|/* 	 * If the owner is already LK_KERNPROC just skip the whole operation. 	 */
if|if
condition|(
name|LK_HOLDER
argument_list|(
name|lk
operator|->
name|lk_lock
argument_list|)
operator|!=
name|tid
condition|)
return|return;
name|lock_profile_release_lock
argument_list|(
operator|&
name|lk
operator|->
name|lock_object
argument_list|)
expr_stmt|;
name|LOCK_LOG_LOCK
argument_list|(
literal|"XDISOWN"
argument_list|,
operator|&
name|lk
operator|->
name|lock_object
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|WITNESS_UNLOCK
argument_list|(
operator|&
name|lk
operator|->
name|lock_object
argument_list|,
name|LOP_EXCLUSIVE
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|TD_LOCKS_DEC
argument_list|(
name|curthread
argument_list|)
expr_stmt|;
name|STACK_SAVE
argument_list|(
name|lk
argument_list|)
expr_stmt|;
comment|/* 	 * In order to preserve waiters flags, just spin. 	 */
for|for
control|(
init|;
condition|;
control|)
block|{
name|x
operator|=
name|lk
operator|->
name|lk_lock
expr_stmt|;
name|MPASS
argument_list|(
operator|(
name|x
operator|&
name|LK_EXCLUSIVE_SPINNERS
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|x
operator|&=
name|LK_ALL_WAITERS
expr_stmt|;
if|if
condition|(
name|atomic_cmpset_rel_ptr
argument_list|(
operator|&
name|lk
operator|->
name|lk_lock
argument_list|,
name|tid
operator||
name|x
argument_list|,
name|LK_KERNPROC
operator||
name|x
argument_list|)
condition|)
return|return;
name|cpu_spinwait
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|lockmgr_printinfo
parameter_list|(
specifier|const
name|struct
name|lock
modifier|*
name|lk
parameter_list|)
block|{
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|uintptr_t
name|x
decl_stmt|;
if|if
condition|(
name|lk
operator|->
name|lk_lock
operator|==
name|LK_UNLOCKED
condition|)
name|printf
argument_list|(
literal|"lock type %s: UNLOCKED\n"
argument_list|,
name|lk
operator|->
name|lock_object
operator|.
name|lo_name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|lk
operator|->
name|lk_lock
operator|&
name|LK_SHARE
condition|)
name|printf
argument_list|(
literal|"lock type %s: SHARED (count %ju)\n"
argument_list|,
name|lk
operator|->
name|lock_object
operator|.
name|lo_name
argument_list|,
operator|(
name|uintmax_t
operator|)
name|LK_SHARERS
argument_list|(
name|lk
operator|->
name|lk_lock
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|td
operator|=
name|lockmgr_xholder
argument_list|(
name|lk
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"lock type %s: EXCL by thread %p "
literal|"(pid %d, %s, tid %d)\n"
argument_list|,
name|lk
operator|->
name|lock_object
operator|.
name|lo_name
argument_list|,
name|td
argument_list|,
name|td
operator|->
name|td_proc
operator|->
name|p_pid
argument_list|,
name|td
operator|->
name|td_proc
operator|->
name|p_comm
argument_list|,
name|td
operator|->
name|td_tid
argument_list|)
expr_stmt|;
block|}
name|x
operator|=
name|lk
operator|->
name|lk_lock
expr_stmt|;
if|if
condition|(
name|x
operator|&
name|LK_EXCLUSIVE_WAITERS
condition|)
name|printf
argument_list|(
literal|" with exclusive waiters pending\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|&
name|LK_SHARED_WAITERS
condition|)
name|printf
argument_list|(
literal|" with shared waiters pending\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|&
name|LK_EXCLUSIVE_SPINNERS
condition|)
name|printf
argument_list|(
literal|" with exclusive spinners pending\n"
argument_list|)
expr_stmt|;
name|STACK_PRINT
argument_list|(
name|lk
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|lockstatus
parameter_list|(
specifier|const
name|struct
name|lock
modifier|*
name|lk
parameter_list|)
block|{
name|uintptr_t
name|v
decl_stmt|,
name|x
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|ret
operator|=
name|LK_SHARED
expr_stmt|;
name|x
operator|=
name|lk
operator|->
name|lk_lock
expr_stmt|;
name|v
operator|=
name|LK_HOLDER
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|x
operator|&
name|LK_SHARE
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|v
operator|==
operator|(
name|uintptr_t
operator|)
name|curthread
operator|||
name|v
operator|==
name|LK_KERNPROC
condition|)
name|ret
operator|=
name|LK_EXCLUSIVE
expr_stmt|;
else|else
name|ret
operator|=
name|LK_EXCLOTHER
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|x
operator|==
name|LK_UNLOCKED
condition|)
name|ret
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|INVARIANT_SUPPORT
end_ifdef

begin_expr_stmt
name|FEATURE
argument_list|(
name|invariant_support
argument_list|,
literal|"Support for modules compiled with INVARIANTS option"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|INVARIANTS
end_ifndef

begin_undef
undef|#
directive|undef
name|_lockmgr_assert
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|_lockmgr_assert
parameter_list|(
specifier|const
name|struct
name|lock
modifier|*
name|lk
parameter_list|,
name|int
name|what
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|)
block|{
name|int
name|slocked
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|panicstr
operator|!=
name|NULL
condition|)
return|return;
switch|switch
condition|(
name|what
condition|)
block|{
case|case
name|KA_SLOCKED
case|:
case|case
name|KA_SLOCKED
operator||
name|KA_NOTRECURSED
case|:
case|case
name|KA_SLOCKED
operator||
name|KA_RECURSED
case|:
name|slocked
operator|=
literal|1
expr_stmt|;
case|case
name|KA_LOCKED
case|:
case|case
name|KA_LOCKED
operator||
name|KA_NOTRECURSED
case|:
case|case
name|KA_LOCKED
operator||
name|KA_RECURSED
case|:
ifdef|#
directive|ifdef
name|WITNESS
comment|/* 		 * We cannot trust WITNESS if the lock is held in exclusive 		 * mode and a call to lockmgr_disown() happened. 		 * Workaround this skipping the check if the lock is held in 		 * exclusive mode even for the KA_LOCKED case. 		 */
if|if
condition|(
name|slocked
operator|||
operator|(
name|lk
operator|->
name|lk_lock
operator|&
name|LK_SHARE
operator|)
condition|)
block|{
name|witness_assert
argument_list|(
operator|&
name|lk
operator|->
name|lock_object
argument_list|,
name|what
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
if|if
condition|(
name|lk
operator|->
name|lk_lock
operator|==
name|LK_UNLOCKED
operator|||
operator|(
operator|(
name|lk
operator|->
name|lk_lock
operator|&
name|LK_SHARE
operator|)
operator|==
literal|0
operator|&&
operator|(
name|slocked
operator|||
operator|(
operator|!
name|lockmgr_xlocked
argument_list|(
name|lk
argument_list|)
operator|&&
operator|!
name|lockmgr_disowned
argument_list|(
name|lk
argument_list|)
operator|)
operator|)
operator|)
condition|)
name|panic
argument_list|(
literal|"Lock %s not %slocked @ %s:%d\n"
argument_list|,
name|lk
operator|->
name|lock_object
operator|.
name|lo_name
argument_list|,
name|slocked
condition|?
literal|"share"
else|:
literal|""
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|lk
operator|->
name|lk_lock
operator|&
name|LK_SHARE
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|lockmgr_recursed
argument_list|(
name|lk
argument_list|)
condition|)
block|{
if|if
condition|(
name|what
operator|&
name|KA_NOTRECURSED
condition|)
name|panic
argument_list|(
literal|"Lock %s recursed @ %s:%d\n"
argument_list|,
name|lk
operator|->
name|lock_object
operator|.
name|lo_name
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|what
operator|&
name|KA_RECURSED
condition|)
name|panic
argument_list|(
literal|"Lock %s not recursed @ %s:%d\n"
argument_list|,
name|lk
operator|->
name|lock_object
operator|.
name|lo_name
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|KA_XLOCKED
case|:
case|case
name|KA_XLOCKED
operator||
name|KA_NOTRECURSED
case|:
case|case
name|KA_XLOCKED
operator||
name|KA_RECURSED
case|:
if|if
condition|(
operator|!
name|lockmgr_xlocked
argument_list|(
name|lk
argument_list|)
operator|&&
operator|!
name|lockmgr_disowned
argument_list|(
name|lk
argument_list|)
condition|)
name|panic
argument_list|(
literal|"Lock %s not exclusively locked @ %s:%d\n"
argument_list|,
name|lk
operator|->
name|lock_object
operator|.
name|lo_name
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|lockmgr_recursed
argument_list|(
name|lk
argument_list|)
condition|)
block|{
if|if
condition|(
name|what
operator|&
name|KA_NOTRECURSED
condition|)
name|panic
argument_list|(
literal|"Lock %s recursed @ %s:%d\n"
argument_list|,
name|lk
operator|->
name|lock_object
operator|.
name|lo_name
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|what
operator|&
name|KA_RECURSED
condition|)
name|panic
argument_list|(
literal|"Lock %s not recursed @ %s:%d\n"
argument_list|,
name|lk
operator|->
name|lock_object
operator|.
name|lo_name
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
break|break;
case|case
name|KA_UNLOCKED
case|:
if|if
condition|(
name|lockmgr_xlocked
argument_list|(
name|lk
argument_list|)
operator|||
name|lockmgr_disowned
argument_list|(
name|lk
argument_list|)
condition|)
name|panic
argument_list|(
literal|"Lock %s exclusively locked @ %s:%d\n"
argument_list|,
name|lk
operator|->
name|lock_object
operator|.
name|lo_name
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
break|break;
default|default:
name|panic
argument_list|(
literal|"Unknown lockmgr assertion: %d @ %s:%d\n"
argument_list|,
name|what
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|DDB
end_ifdef

begin_function
name|int
name|lockmgr_chain
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|thread
modifier|*
modifier|*
name|ownerp
parameter_list|)
block|{
name|struct
name|lock
modifier|*
name|lk
decl_stmt|;
name|lk
operator|=
name|td
operator|->
name|td_wchan
expr_stmt|;
if|if
condition|(
name|LOCK_CLASS
argument_list|(
operator|&
name|lk
operator|->
name|lock_object
argument_list|)
operator|!=
operator|&
name|lock_class_lockmgr
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|db_printf
argument_list|(
literal|"blocked on lockmgr %s"
argument_list|,
name|lk
operator|->
name|lock_object
operator|.
name|lo_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|lk
operator|->
name|lk_lock
operator|&
name|LK_SHARE
condition|)
name|db_printf
argument_list|(
literal|"SHARED (count %ju)\n"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|LK_SHARERS
argument_list|(
name|lk
operator|->
name|lk_lock
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|db_printf
argument_list|(
literal|"EXCL\n"
argument_list|)
expr_stmt|;
operator|*
name|ownerp
operator|=
name|lockmgr_xholder
argument_list|(
name|lk
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|db_show_lockmgr
parameter_list|(
specifier|const
name|struct
name|lock_object
modifier|*
name|lock
parameter_list|)
block|{
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
specifier|const
name|struct
name|lock
modifier|*
name|lk
decl_stmt|;
name|lk
operator|=
operator|(
specifier|const
expr|struct
name|lock
operator|*
operator|)
name|lock
expr_stmt|;
name|db_printf
argument_list|(
literal|" state: "
argument_list|)
expr_stmt|;
if|if
condition|(
name|lk
operator|->
name|lk_lock
operator|==
name|LK_UNLOCKED
condition|)
name|db_printf
argument_list|(
literal|"UNLOCKED\n"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|lk
operator|->
name|lk_lock
operator|&
name|LK_SHARE
condition|)
name|db_printf
argument_list|(
literal|"SLOCK: %ju\n"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|LK_SHARERS
argument_list|(
name|lk
operator|->
name|lk_lock
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|td
operator|=
name|lockmgr_xholder
argument_list|(
name|lk
argument_list|)
expr_stmt|;
if|if
condition|(
name|td
operator|==
operator|(
expr|struct
name|thread
operator|*
operator|)
name|LK_KERNPROC
condition|)
name|db_printf
argument_list|(
literal|"XLOCK: LK_KERNPROC\n"
argument_list|)
expr_stmt|;
else|else
name|db_printf
argument_list|(
literal|"XLOCK: %p (tid %d, pid %d, \"%s\")\n"
argument_list|,
name|td
argument_list|,
name|td
operator|->
name|td_tid
argument_list|,
name|td
operator|->
name|td_proc
operator|->
name|p_pid
argument_list|,
name|td
operator|->
name|td_proc
operator|->
name|p_comm
argument_list|)
expr_stmt|;
if|if
condition|(
name|lockmgr_recursed
argument_list|(
name|lk
argument_list|)
condition|)
name|db_printf
argument_list|(
literal|" recursed: %d\n"
argument_list|,
name|lk
operator|->
name|lk_recurse
argument_list|)
expr_stmt|;
block|}
name|db_printf
argument_list|(
literal|" waiters: "
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|lk
operator|->
name|lk_lock
operator|&
name|LK_ALL_WAITERS
condition|)
block|{
case|case
name|LK_SHARED_WAITERS
case|:
name|db_printf
argument_list|(
literal|"shared\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|LK_EXCLUSIVE_WAITERS
case|:
name|db_printf
argument_list|(
literal|"exclusive\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|LK_ALL_WAITERS
case|:
name|db_printf
argument_list|(
literal|"shared and exclusive\n"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|db_printf
argument_list|(
literal|"none\n"
argument_list|)
expr_stmt|;
block|}
name|db_printf
argument_list|(
literal|" spinners: "
argument_list|)
expr_stmt|;
if|if
condition|(
name|lk
operator|->
name|lk_lock
operator|&
name|LK_EXCLUSIVE_SPINNERS
condition|)
name|db_printf
argument_list|(
literal|"exclusive\n"
argument_list|)
expr_stmt|;
else|else
name|db_printf
argument_list|(
literal|"none\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

