begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1997 John S. Dyson.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. John S. Dyson's name may not be used to endorse or promote products  *    derived from this software without specific prior written permission.  *  * DISCLAIMER:  This code isn't warranted to do anything useful.  Anything  * bad that happens because of using this software isn't the responsibility  * of the author.  This software is distributed AS-IS.  *  * $Id: vfs_aio.c,v 1.9 1997/11/06 19:29:27 phk Exp $  */
end_comment

begin_comment
comment|/*  * This file contains support for the POSIX.4 AIO facility.  *  * The initial version provides only the (bogus) synchronous semantics  * but will support async in the future.  Note that a bit  * in a private field allows the user mode subroutine to adapt  * the kernel operations to true POSIX.4 for future compatibility.  *  * This code is used to support true POSIX.4 AIO/LIO with the help  * of a user mode subroutine package.  Note that eventually more support  * will be pushed into the kernel.  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysproto.h>
end_include

begin_include
include|#
directive|include
file|<sys/filedesc.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/unistd.h>
end_include

begin_include
include|#
directive|include
file|<sys/vnode.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/signalvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_param.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_extern.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_map.h>
end_include

begin_include
include|#
directive|include
file|<sys/aio.h>
end_include

begin_include
include|#
directive|include
file|<sys/shm.h>
end_include

begin_include
include|#
directive|include
file|<machine/cpu.h>
end_include

begin_expr_stmt
specifier|static
name|MALLOC_DEFINE
argument_list|(
name|M_AIO
argument_list|,
literal|"AIO"
argument_list|,
literal|"AIO structure(s)"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|AIOCBLIST_CANCELLED
value|0x1
end_define

begin_define
define|#
directive|define
name|AIOCBLIST_RUNDOWN
value|0x4
end_define

begin_define
define|#
directive|define
name|AIOCBLIST_ASYNCFREE
value|0x8
end_define

begin_define
define|#
directive|define
name|AIOCBLIST_SUSPEND
value|0x10
end_define

begin_if
if|#
directive|if
literal|0
end_if

begin_define
define|#
directive|define
name|DEBUGAIO
end_define

begin_define
define|#
directive|define
name|DIAGNOSTIC
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|DEBUGAIO
value|1
end_define

begin_decl_stmt
specifier|static
name|int
name|jobrefid
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|JOBST_NULL
value|0x0
end_define

begin_define
define|#
directive|define
name|JOBST_JOBQPROC
value|0x1
end_define

begin_define
define|#
directive|define
name|JOBST_JOBQGLOBAL
value|0x2
end_define

begin_define
define|#
directive|define
name|JOBST_JOBRUNNING
value|0x3
end_define

begin_define
define|#
directive|define
name|JOBST_JOBFINISHED
value|0x4
end_define

begin_define
define|#
directive|define
name|MAX_AIO_PER_PROC
value|32
end_define

begin_define
define|#
directive|define
name|MAX_AIO_QUEUE_PER_PROC
value|256
end_define

begin_comment
comment|/* Bigger than AIO_LISTIO_MAX */
end_comment

begin_define
define|#
directive|define
name|MAX_AIO_PROCS
value|128
end_define

begin_define
define|#
directive|define
name|MAX_AIO_QUEUE
value|1024
end_define

begin_comment
comment|/* Bigger than AIO_LISTIO_MAX */
end_comment

begin_define
define|#
directive|define
name|TARGET_AIO_PROCS
value|64
end_define

begin_decl_stmt
name|int
name|max_aio_procs
init|=
name|MAX_AIO_PROCS
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|num_aio_procs
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|target_aio_procs
init|=
name|TARGET_AIO_PROCS
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|max_queue_count
init|=
name|MAX_AIO_QUEUE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|num_queue_count
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|max_aio_per_proc
init|=
name|MAX_AIO_PER_PROC
decl_stmt|,
name|max_aio_queue_per_proc
init|=
name|MAX_AIO_QUEUE_PER_PROC
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_vfs
argument_list|,
name|OID_AUTO
argument_list|,
name|aio
argument_list|,
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
literal|"AIO mgmt"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vfs_aio
argument_list|,
name|OID_AUTO
argument_list|,
name|max_aio_per_proc
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|max_aio_per_proc
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vfs_aio
argument_list|,
name|OID_AUTO
argument_list|,
name|max_aio_queue_per_proc
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|max_aio_queue_per_proc
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vfs_aio
argument_list|,
name|OID_AUTO
argument_list|,
name|max_aio_procs
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|max_aio_procs
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vfs_aio
argument_list|,
name|OID_AUTO
argument_list|,
name|num_aio_procs
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|num_aio_procs
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vfs_aio
argument_list|,
name|OID_AUTO
argument_list|,
name|num_queue_count
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|num_queue_count
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vfs_aio
argument_list|,
name|OID_AUTO
argument_list|,
name|max_aio_queue
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|max_queue_count
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vfs_aio
argument_list|,
name|OID_AUTO
argument_list|,
name|target_aio_procs
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|target_aio_procs
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|#
directive|if
name|DEBUGAIO
operator|>
literal|0
end_if

begin_decl_stmt
specifier|static
name|int
name|debugaio
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vfs_aio
argument_list|,
name|OID_AUTO
argument_list|,
name|debugaio
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|debugaio
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Job queue item  */
end_comment

begin_struct
struct|struct
name|aiocblist
block|{
name|TAILQ_ENTRY
argument_list|(
argument|aiocblist
argument_list|)
name|list
expr_stmt|;
comment|/* List of jobs */
name|TAILQ_ENTRY
argument_list|(
argument|aiocblist
argument_list|)
name|plist
expr_stmt|;
comment|/* List of jobs for proc */
name|int
name|jobflags
decl_stmt|;
name|int
name|jobstate
decl_stmt|;
name|struct
name|proc
modifier|*
name|userproc
decl_stmt|;
comment|/* User process */
name|struct
name|aioproclist
modifier|*
name|jobaioproc
decl_stmt|;
comment|/* AIO process descriptor */
name|struct
name|aiocb
name|uaiocb
decl_stmt|;
comment|/* Kernel I/O control block */
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|AIOP_FREE
value|0x1
end_define

begin_comment
comment|/* proc on free queue */
end_comment

begin_comment
comment|/*  * AIO process info  */
end_comment

begin_struct
struct|struct
name|aioproclist
block|{
name|int
name|aioprocflags
decl_stmt|;
comment|/* AIO proc flags */
name|TAILQ_ENTRY
argument_list|(
argument|aioproclist
argument_list|)
name|list
expr_stmt|;
comment|/* List of processes */
name|struct
name|proc
modifier|*
name|aioproc
decl_stmt|;
comment|/* The AIO thread */
name|TAILQ_HEAD
argument_list|(
argument_list|,
argument|aiocblist
argument_list|)
name|jobtorun
expr_stmt|;
comment|/* suggested job to run */
block|}
struct|;
end_struct

begin_struct
struct|struct
name|kaioinfo
block|{
name|int
name|kaio_maxactive_count
decl_stmt|;
comment|/* maximum number of AIOs */
name|int
name|kaio_active_count
decl_stmt|;
comment|/* number of currently used AIOs */
name|int
name|kaio_qallowed_count
decl_stmt|;
comment|/* maxiumu size of AIO queue */
name|int
name|kaio_queue_count
decl_stmt|;
comment|/* size of AIO queue */
name|TAILQ_HEAD
argument_list|(
argument_list|,
argument|aiocblist
argument_list|)
name|kaio_jobqueue
expr_stmt|;
comment|/* job queue for process */
name|TAILQ_HEAD
argument_list|(
argument_list|,
argument|aiocblist
argument_list|)
name|kaio_jobdone
expr_stmt|;
comment|/* done queue for process */
block|}
struct|;
end_struct

begin_macro
name|TAILQ_HEAD
argument_list|(
argument_list|,
argument|aioproclist
argument_list|)
end_macro

begin_expr_stmt
name|aio_freeproc
operator|,
name|aio_activeproc
expr_stmt|;
end_expr_stmt

begin_macro
name|TAILQ_HEAD
argument_list|(
argument_list|,
argument|aiocblist
argument_list|)
end_macro

begin_expr_stmt
name|aio_jobs
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Async job list */
end_comment

begin_macro
name|TAILQ_HEAD
argument_list|(
argument_list|,
argument|aiocblist
argument_list|)
end_macro

begin_expr_stmt
name|aio_freejobs
expr_stmt|;
end_expr_stmt

begin_function_decl
name|void
name|aio_init_aioinfo
parameter_list|(
name|struct
name|proc
modifier|*
name|p
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|aio_onceonly
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|aio_free_entry
parameter_list|(
name|struct
name|aiocblist
modifier|*
name|aiocbe
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|aio_cancel_internal
parameter_list|(
name|struct
name|aiocblist
modifier|*
name|aiocbe
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|aio_process
parameter_list|(
name|struct
name|aiocblist
modifier|*
name|aiocbe
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|pmap_newvmspace
parameter_list|(
name|struct
name|vmspace
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|aio_newproc
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|aio_aqueue
parameter_list|(
name|struct
name|proc
modifier|*
name|p
parameter_list|,
name|struct
name|aiocb
modifier|*
name|job
parameter_list|,
name|int
name|type
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|aio_marksuspend
parameter_list|(
name|struct
name|proc
modifier|*
name|p
parameter_list|,
name|int
name|njobs
parameter_list|,
name|int
modifier|*
name|joblist
parameter_list|,
name|int
name|set
parameter_list|)
function_decl|;
end_function_decl

begin_expr_stmt
name|SYSINIT
argument_list|(
name|aio
argument_list|,
name|SI_SUB_VFS
argument_list|,
name|SI_ORDER_ANY
argument_list|,
name|aio_onceonly
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Startup initialization  */
end_comment

begin_function
name|void
name|aio_onceonly
parameter_list|(
name|void
modifier|*
name|na
parameter_list|)
block|{
name|TAILQ_INIT
argument_list|(
operator|&
name|aio_freeproc
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|aio_activeproc
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|aio_jobs
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|aio_freejobs
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Init the per-process aioinfo structure.  */
end_comment

begin_function
name|void
name|aio_init_aioinfo
parameter_list|(
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|kaioinfo
modifier|*
name|ki
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|p_aioinfo
operator|==
name|NULL
condition|)
block|{
name|ki
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|kaioinfo
argument_list|)
argument_list|,
name|M_AIO
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|p
operator|->
name|p_aioinfo
operator|=
name|ki
expr_stmt|;
name|ki
operator|->
name|kaio_maxactive_count
operator|=
name|max_aio_per_proc
expr_stmt|;
name|ki
operator|->
name|kaio_active_count
operator|=
literal|0
expr_stmt|;
name|ki
operator|->
name|kaio_qallowed_count
operator|=
name|max_aio_queue_per_proc
expr_stmt|;
name|ki
operator|->
name|kaio_queue_count
operator|=
literal|0
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|ki
operator|->
name|kaio_jobdone
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|ki
operator|->
name|kaio_jobqueue
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Free a job entry.  Wait for completion if it is currently  * active, but don't delay forever.  If we delay, we return  * a flag that says that we have to restart the queue scan.  */
end_comment

begin_function
name|int
name|aio_free_entry
parameter_list|(
name|struct
name|aiocblist
modifier|*
name|aiocbe
parameter_list|)
block|{
name|struct
name|kaioinfo
modifier|*
name|ki
decl_stmt|;
name|struct
name|aioproclist
modifier|*
name|aiop
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|aiocbe
operator|->
name|jobstate
operator|==
name|JOBST_NULL
condition|)
name|panic
argument_list|(
literal|"aio_free_entry: freeing already free job"
argument_list|)
expr_stmt|;
name|p
operator|=
name|aiocbe
operator|->
name|userproc
expr_stmt|;
name|ki
operator|=
name|p
operator|->
name|p_aioinfo
expr_stmt|;
if|if
condition|(
name|ki
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"aio_free_entry: missing p->p_aioinfo"
argument_list|)
expr_stmt|;
if|if
condition|(
name|aiocbe
operator|->
name|jobstate
operator|==
name|JOBST_JOBRUNNING
condition|)
block|{
if|if
condition|(
name|aiocbe
operator|->
name|jobflags
operator|&
name|AIOCBLIST_ASYNCFREE
condition|)
return|return
literal|0
return|;
name|aiocbe
operator|->
name|jobflags
operator||=
name|AIOCBLIST_RUNDOWN
expr_stmt|;
name|tsleep
argument_list|(
name|aiocbe
argument_list|,
name|PRIBIO
operator||
name|PCATCH
argument_list|,
literal|"jobwai"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 		if (tsleep(aiocbe, PRIBIO|PCATCH, "jobwai", hz*5)) { 			aiocbe->jobflags |= AIOCBLIST_ASYNCFREE; 			aiocbe->jobflags&= ~AIOCBLIST_RUNDOWN; 			return 1; 		} 		aiocbe->jobflags&= ~AIOCBLIST_RUNDOWN; */
block|}
name|aiocbe
operator|->
name|jobflags
operator|&=
operator|~
name|AIOCBLIST_ASYNCFREE
expr_stmt|;
if|if
condition|(
name|ki
operator|->
name|kaio_queue_count
operator|<=
literal|0
condition|)
name|panic
argument_list|(
literal|"aio_free_entry: process queue size<= 0"
argument_list|)
expr_stmt|;
if|if
condition|(
name|num_queue_count
operator|<=
literal|0
condition|)
name|panic
argument_list|(
literal|"aio_free_entry: system wide queue size<= 0"
argument_list|)
expr_stmt|;
operator|--
name|ki
operator|->
name|kaio_queue_count
expr_stmt|;
operator|--
name|num_queue_count
expr_stmt|;
if|#
directive|if
name|DEBUGAIO
operator|>
literal|0
if|if
condition|(
name|debugaio
operator|>
literal|0
condition|)
name|printf
argument_list|(
literal|"freeing entry: %d, %d\n"
argument_list|,
name|ki
operator|->
name|kaio_queue_count
argument_list|,
name|num_queue_count
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|aiocbe
operator|->
name|jobstate
operator|==
name|JOBST_JOBQPROC
condition|)
block|{
name|aiop
operator|=
name|aiocbe
operator|->
name|jobaioproc
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|aiop
operator|->
name|jobtorun
argument_list|,
name|aiocbe
argument_list|,
name|list
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|aiocbe
operator|->
name|jobstate
operator|==
name|JOBST_JOBQGLOBAL
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|aio_jobs
argument_list|,
name|aiocbe
argument_list|,
name|list
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|aiocbe
operator|->
name|jobstate
operator|==
name|JOBST_JOBFINISHED
condition|)
block|{
name|ki
operator|=
name|p
operator|->
name|p_aioinfo
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|ki
operator|->
name|kaio_jobdone
argument_list|,
name|aiocbe
argument_list|,
name|plist
argument_list|)
expr_stmt|;
block|}
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|aio_freejobs
argument_list|,
name|aiocbe
argument_list|,
name|list
argument_list|)
expr_stmt|;
name|aiocbe
operator|->
name|jobstate
operator|=
name|JOBST_NULL
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Rundown the jobs for a given process.    */
end_comment

begin_function
name|void
name|aio_proc_rundown
parameter_list|(
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|kaioinfo
modifier|*
name|ki
decl_stmt|;
name|struct
name|aiocblist
modifier|*
name|aiocbe
decl_stmt|,
modifier|*
name|aiocbn
decl_stmt|;
name|ki
operator|=
name|p
operator|->
name|p_aioinfo
expr_stmt|;
if|if
condition|(
name|ki
operator|==
name|NULL
condition|)
return|return;
while|while
condition|(
name|ki
operator|->
name|kaio_active_count
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|tsleep
argument_list|(
name|ki
argument_list|,
name|PRIBIO
argument_list|,
literal|"kaiowt"
argument_list|,
literal|60
operator|*
name|hz
argument_list|)
condition|)
break|break;
block|}
if|#
directive|if
name|DEBUGAIO
operator|>
literal|0
if|if
condition|(
name|debugaio
operator|>
literal|0
condition|)
name|printf
argument_list|(
literal|"Proc rundown: %d %d\n"
argument_list|,
name|num_queue_count
argument_list|,
name|ki
operator|->
name|kaio_queue_count
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|restart1
label|:
for|for
control|(
name|aiocbe
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|ki
operator|->
name|kaio_jobdone
argument_list|)
init|;
name|aiocbe
condition|;
name|aiocbe
operator|=
name|aiocbn
control|)
block|{
name|aiocbn
operator|=
name|TAILQ_NEXT
argument_list|(
name|aiocbe
argument_list|,
name|plist
argument_list|)
expr_stmt|;
if|if
condition|(
name|aio_free_entry
argument_list|(
name|aiocbe
argument_list|)
condition|)
goto|goto
name|restart1
goto|;
block|}
name|restart2
label|:
for|for
control|(
name|aiocbe
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|ki
operator|->
name|kaio_jobqueue
argument_list|)
init|;
name|aiocbe
condition|;
name|aiocbe
operator|=
name|aiocbn
control|)
block|{
name|aiocbn
operator|=
name|TAILQ_NEXT
argument_list|(
name|aiocbe
argument_list|,
name|plist
argument_list|)
expr_stmt|;
if|if
condition|(
name|aio_free_entry
argument_list|(
name|aiocbe
argument_list|)
condition|)
goto|goto
name|restart2
goto|;
block|}
name|free
argument_list|(
name|ki
argument_list|,
name|M_AIO
argument_list|)
expr_stmt|;
name|p
operator|->
name|p_aioinfo
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Select a job to run (called by an AIO daemon)  */
end_comment

begin_function
specifier|static
name|struct
name|aiocblist
modifier|*
name|aio_selectjob
parameter_list|(
name|struct
name|aioproclist
modifier|*
name|aiop
parameter_list|)
block|{
name|struct
name|aiocblist
modifier|*
name|aiocbe
decl_stmt|;
name|aiocbe
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|aiop
operator|->
name|jobtorun
argument_list|)
expr_stmt|;
if|if
condition|(
name|aiocbe
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|aiop
operator|->
name|jobtorun
argument_list|,
name|aiocbe
argument_list|,
name|list
argument_list|)
expr_stmt|;
return|return
name|aiocbe
return|;
block|}
for|for
control|(
name|aiocbe
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|aio_jobs
argument_list|)
init|;
name|aiocbe
condition|;
name|aiocbe
operator|=
name|TAILQ_NEXT
argument_list|(
name|aiocbe
argument_list|,
name|list
argument_list|)
control|)
block|{
name|struct
name|kaioinfo
modifier|*
name|ki
decl_stmt|;
name|struct
name|proc
modifier|*
name|userp
decl_stmt|;
name|userp
operator|=
name|aiocbe
operator|->
name|userproc
expr_stmt|;
name|ki
operator|=
name|userp
operator|->
name|p_aioinfo
expr_stmt|;
if|if
condition|(
name|ki
operator|->
name|kaio_active_count
operator|<
name|ki
operator|->
name|kaio_maxactive_count
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|aio_jobs
argument_list|,
name|aiocbe
argument_list|,
name|list
argument_list|)
expr_stmt|;
return|return
name|aiocbe
return|;
block|}
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/*  * The AIO activity proper.  */
end_comment

begin_function
name|void
name|aio_process
parameter_list|(
name|struct
name|aiocblist
modifier|*
name|aiocbe
parameter_list|)
block|{
name|struct
name|filedesc
modifier|*
name|fdp
decl_stmt|;
name|struct
name|proc
modifier|*
name|userp
decl_stmt|;
name|struct
name|aiocb
modifier|*
name|cb
decl_stmt|;
name|struct
name|file
modifier|*
name|fp
decl_stmt|;
name|struct
name|uio
name|auio
decl_stmt|;
name|struct
name|iovec
name|aiov
decl_stmt|;
name|unsigned
name|int
name|fd
decl_stmt|;
name|int
name|cnt
decl_stmt|;
name|int
name|error
decl_stmt|;
name|off_t
name|offset
decl_stmt|;
name|userp
operator|=
name|aiocbe
operator|->
name|userproc
expr_stmt|;
name|cb
operator|=
operator|&
name|aiocbe
operator|->
name|uaiocb
expr_stmt|;
if|#
directive|if
name|DEBUGAIO
operator|>
literal|0
if|if
condition|(
name|debugaio
operator|>
literal|1
condition|)
name|printf
argument_list|(
literal|"AIO %s, fd: %d, offset: 0x%x, address: 0x%x, size: %d\n"
argument_list|,
name|cb
operator|->
name|aio_lio_opcode
operator|==
name|LIO_READ
condition|?
literal|"Read"
else|:
literal|"Write"
argument_list|,
name|cb
operator|->
name|aio_fildes
argument_list|,
operator|(
name|int
operator|)
name|cb
operator|->
name|aio_offset
argument_list|,
name|cb
operator|->
name|aio_buf
argument_list|,
name|cb
operator|->
name|aio_nbytes
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|SLOW
name|tsleep
argument_list|(
name|curproc
argument_list|,
name|PVM
argument_list|,
literal|"aioprc"
argument_list|,
name|hz
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|fdp
operator|=
name|curproc
operator|->
name|p_fd
expr_stmt|;
comment|/* 	 * Range check file descriptor 	 */
name|fd
operator|=
name|cb
operator|->
name|aio_fildes
expr_stmt|;
name|fp
operator|=
name|fdp
operator|->
name|fd_ofiles
index|[
name|fd
index|]
expr_stmt|;
name|aiov
operator|.
name|iov_base
operator|=
name|cb
operator|->
name|aio_buf
expr_stmt|;
name|aiov
operator|.
name|iov_len
operator|=
name|cb
operator|->
name|aio_nbytes
expr_stmt|;
name|auio
operator|.
name|uio_iov
operator|=
operator|&
name|aiov
expr_stmt|;
name|auio
operator|.
name|uio_iovcnt
operator|=
literal|1
expr_stmt|;
name|auio
operator|.
name|uio_offset
operator|=
name|offset
operator|=
name|cb
operator|->
name|aio_offset
expr_stmt|;
name|auio
operator|.
name|uio_resid
operator|=
name|cb
operator|->
name|aio_nbytes
expr_stmt|;
name|cnt
operator|=
name|cb
operator|->
name|aio_nbytes
expr_stmt|;
name|auio
operator|.
name|uio_segflg
operator|=
name|UIO_USERSPACE
expr_stmt|;
name|auio
operator|.
name|uio_procp
operator|=
name|curproc
expr_stmt|;
if|if
condition|(
name|cb
operator|->
name|aio_lio_opcode
operator|==
name|LIO_READ
condition|)
block|{
name|auio
operator|.
name|uio_rw
operator|=
name|UIO_READ
expr_stmt|;
name|error
operator|=
call|(
modifier|*
name|fp
operator|->
name|f_ops
operator|->
name|fo_read
call|)
argument_list|(
name|fp
argument_list|,
operator|&
name|auio
argument_list|,
name|fp
operator|->
name|f_cred
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|auio
operator|.
name|uio_rw
operator|=
name|UIO_WRITE
expr_stmt|;
name|error
operator|=
call|(
modifier|*
name|fp
operator|->
name|f_ops
operator|->
name|fo_write
call|)
argument_list|(
name|fp
argument_list|,
operator|&
name|auio
argument_list|,
name|fp
operator|->
name|f_cred
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
condition|)
block|{
if|if
condition|(
name|auio
operator|.
name|uio_resid
operator|!=
name|cnt
condition|)
block|{
if|if
condition|(
name|error
operator|==
name|ERESTART
operator|||
name|error
operator|==
name|EINTR
operator|||
name|error
operator|==
name|EWOULDBLOCK
condition|)
name|error
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|==
name|EPIPE
operator|)
operator|&&
operator|(
name|cb
operator|->
name|aio_lio_opcode
operator|==
name|LIO_WRITE
operator|)
condition|)
name|psignal
argument_list|(
name|userp
argument_list|,
name|SIGPIPE
argument_list|)
expr_stmt|;
block|}
block|}
if|#
directive|if
name|DEBUGAIO
operator|>
literal|0
if|if
condition|(
name|debugaio
operator|>
literal|1
condition|)
name|printf
argument_list|(
literal|"%s complete: error: %d, status: %d, nio: %d, resid: %d, offset: %d\n"
argument_list|,
name|cb
operator|->
name|aio_lio_opcode
operator|==
name|LIO_READ
condition|?
literal|"Read"
else|:
literal|"Write"
argument_list|,
name|error
argument_list|,
name|cnt
argument_list|,
name|cnt
operator|-
name|auio
operator|.
name|uio_resid
argument_list|,
name|auio
operator|.
name|uio_resid
argument_list|,
operator|(
name|int
operator|)
name|offset
operator|&
literal|0xffffffff
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|cnt
operator|-=
name|auio
operator|.
name|uio_resid
expr_stmt|;
name|cb
operator|->
name|_aiocb_private
operator|.
name|error
operator|=
name|error
expr_stmt|;
name|cb
operator|->
name|_aiocb_private
operator|.
name|status
operator|=
name|cnt
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * The AIO daemon.  */
end_comment

begin_function
specifier|static
name|void
name|aio_startproc
parameter_list|(
name|void
modifier|*
name|uproc
parameter_list|)
block|{
name|struct
name|aioproclist
modifier|*
name|aiop
decl_stmt|;
comment|/* 	 * Allocate and ready the aio control info 	 */
name|aiop
operator|=
name|malloc
argument_list|(
sizeof|sizeof
expr|*
name|aiop
argument_list|,
name|M_AIO
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|aiop
operator|->
name|aioproc
operator|=
name|curproc
expr_stmt|;
name|aiop
operator|->
name|aioprocflags
operator||=
name|AIOP_FREE
expr_stmt|;
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|aio_freeproc
argument_list|,
name|aiop
argument_list|,
name|list
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|aiop
operator|->
name|jobtorun
argument_list|)
expr_stmt|;
comment|/* 	 * Get rid of current address space 	 */
if|if
condition|(
name|curproc
operator|->
name|p_vmspace
operator|->
name|vm_refcnt
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|curproc
operator|->
name|p_vmspace
operator|->
name|vm_shm
condition|)
name|shmexit
argument_list|(
name|curproc
argument_list|)
expr_stmt|;
name|pmap_remove_pages
argument_list|(
operator|&
name|curproc
operator|->
name|p_vmspace
operator|->
name|vm_pmap
argument_list|,
literal|0
argument_list|,
name|USRSTACK
argument_list|)
expr_stmt|;
name|vm_map_remove
argument_list|(
operator|&
name|curproc
operator|->
name|p_vmspace
operator|->
name|vm_map
argument_list|,
literal|0
argument_list|,
name|USRSTACK
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|vmspace_exec
argument_list|(
name|curproc
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Make up a name for the daemon 	 */
name|strcpy
argument_list|(
name|curproc
operator|->
name|p_comm
argument_list|,
literal|"aiodaemon"
argument_list|)
expr_stmt|;
comment|/* 	 * Get rid of our current filedescriptors 	 */
name|fdfree
argument_list|(
name|curproc
argument_list|)
expr_stmt|;
name|curproc
operator|->
name|p_fd
operator|=
name|NULL
expr_stmt|;
name|curproc
operator|->
name|p_ucred
operator|=
name|crcopy
argument_list|(
name|curproc
operator|->
name|p_ucred
argument_list|)
expr_stmt|;
name|curproc
operator|->
name|p_ucred
operator|->
name|cr_uid
operator|=
literal|0
expr_stmt|;
name|curproc
operator|->
name|p_ucred
operator|->
name|cr_groups
index|[
literal|0
index|]
operator|=
literal|1
expr_stmt|;
name|curproc
operator|->
name|p_flag
operator||=
name|P_SYSTEM
expr_stmt|;
if|#
directive|if
name|DEBUGAIO
operator|>
literal|0
if|if
condition|(
name|debugaio
operator|>
literal|2
condition|)
name|printf
argument_list|(
literal|"Started new process: %d\n"
argument_list|,
name|curproc
operator|->
name|p_pid
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|wakeup
argument_list|(
operator|&
name|aio_freeproc
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|struct
name|vmspace
modifier|*
name|myvm
decl_stmt|,
modifier|*
name|tmpvm
decl_stmt|;
name|struct
name|proc
modifier|*
name|cp
init|=
name|curproc
decl_stmt|;
name|struct
name|aiocblist
modifier|*
name|aiocbe
decl_stmt|;
if|if
condition|(
operator|(
name|aiop
operator|->
name|aioprocflags
operator|&
name|AIOP_FREE
operator|)
operator|==
literal|0
condition|)
block|{
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|aio_freeproc
argument_list|,
name|aiop
argument_list|,
name|list
argument_list|)
expr_stmt|;
name|aiop
operator|->
name|aioprocflags
operator||=
name|AIOP_FREE
expr_stmt|;
block|}
if|if
condition|(
name|tsleep
argument_list|(
name|cp
argument_list|,
name|PRIBIO
argument_list|,
literal|"aiordy"
argument_list|,
name|hz
operator|*
literal|30
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|num_aio_procs
operator|>
name|target_aio_procs
operator|)
operator|&&
operator|(
name|TAILQ_FIRST
argument_list|(
operator|&
name|aiop
operator|->
name|jobtorun
argument_list|)
operator|==
name|NULL
operator|)
condition|)
name|exit1
argument_list|(
name|curproc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|aiop
operator|->
name|aioprocflags
operator|&
name|AIOP_FREE
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|aio_freeproc
argument_list|,
name|aiop
argument_list|,
name|list
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|aio_activeproc
argument_list|,
name|aiop
argument_list|,
name|list
argument_list|)
expr_stmt|;
name|aiop
operator|->
name|aioprocflags
operator|&=
operator|~
name|AIOP_FREE
expr_stmt|;
block|}
name|myvm
operator|=
name|curproc
operator|->
name|p_vmspace
expr_stmt|;
while|while
condition|(
name|aiocbe
operator|=
name|aio_selectjob
argument_list|(
name|aiop
argument_list|)
condition|)
block|{
name|struct
name|aiocb
modifier|*
name|cb
decl_stmt|;
name|struct
name|kaioinfo
modifier|*
name|ki
decl_stmt|;
name|struct
name|proc
modifier|*
name|userp
decl_stmt|;
name|cb
operator|=
operator|&
name|aiocbe
operator|->
name|uaiocb
expr_stmt|;
name|userp
operator|=
name|aiocbe
operator|->
name|userproc
expr_stmt|;
name|ki
operator|=
name|userp
operator|->
name|p_aioinfo
expr_stmt|;
name|aiocbe
operator|->
name|jobstate
operator|=
name|JOBST_JOBRUNNING
expr_stmt|;
if|if
condition|(
name|userp
operator|!=
name|cp
condition|)
block|{
name|tmpvm
operator|=
name|curproc
operator|->
name|p_vmspace
expr_stmt|;
name|curproc
operator|->
name|p_vmspace
operator|=
name|userp
operator|->
name|p_vmspace
expr_stmt|;
operator|++
name|curproc
operator|->
name|p_vmspace
operator|->
name|vm_refcnt
expr_stmt|;
name|pmap_activate
argument_list|(
name|curproc
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmpvm
operator|!=
name|myvm
condition|)
block|{
name|vmspace_free
argument_list|(
name|tmpvm
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|curproc
operator|->
name|p_fd
condition|)
name|fdfree
argument_list|(
name|curproc
argument_list|)
expr_stmt|;
name|curproc
operator|->
name|p_fd
operator|=
name|fdshare
argument_list|(
name|userp
argument_list|)
expr_stmt|;
name|cp
operator|=
name|userp
expr_stmt|;
block|}
name|ki
operator|->
name|kaio_active_count
operator|++
expr_stmt|;
if|#
directive|if
name|DEBUGAIO
operator|>
literal|0
if|if
condition|(
name|debugaio
operator|>
literal|0
condition|)
name|printf
argument_list|(
literal|"process: pid: %d(%d), active: %d, queue: %d\n"
argument_list|,
name|cb
operator|->
name|_aiocb_private
operator|.
name|kernelinfo
argument_list|,
name|userp
operator|->
name|p_pid
argument_list|,
name|ki
operator|->
name|kaio_active_count
argument_list|,
name|ki
operator|->
name|kaio_queue_count
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|aiocbe
operator|->
name|jobaioproc
operator|=
name|aiop
expr_stmt|;
name|aio_process
argument_list|(
name|aiocbe
argument_list|)
expr_stmt|;
operator|--
name|ki
operator|->
name|kaio_active_count
expr_stmt|;
if|if
condition|(
name|ki
operator|->
name|kaio_active_count
operator|==
literal|0
condition|)
name|wakeup
argument_list|(
name|ki
argument_list|)
expr_stmt|;
if|#
directive|if
name|DEBUGAIO
operator|>
literal|0
if|if
condition|(
name|debugaio
operator|>
literal|0
condition|)
name|printf
argument_list|(
literal|"DONE process: pid: %d(%d), active: %d, queue: %d\n"
argument_list|,
name|cb
operator|->
name|_aiocb_private
operator|.
name|kernelinfo
argument_list|,
name|userp
operator|->
name|p_pid
argument_list|,
name|ki
operator|->
name|kaio_active_count
argument_list|,
name|ki
operator|->
name|kaio_queue_count
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|aiocbe
operator|->
name|jobstate
operator|=
name|JOBST_JOBFINISHED
expr_stmt|;
if|if
condition|(
name|aiocbe
operator|->
name|jobflags
operator|&
name|AIOCBLIST_ASYNCFREE
condition|)
block|{
name|aiocbe
operator|->
name|jobflags
operator|&=
operator|~
name|AIOCBLIST_ASYNCFREE
expr_stmt|;
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|aio_freejobs
argument_list|,
name|aiocbe
argument_list|,
name|list
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|ki
operator|->
name|kaio_jobqueue
argument_list|,
name|aiocbe
argument_list|,
name|plist
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|ki
operator|->
name|kaio_jobdone
argument_list|,
name|aiocbe
argument_list|,
name|plist
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|aiocbe
operator|->
name|jobflags
operator|&
name|AIOCBLIST_RUNDOWN
condition|)
block|{
name|wakeup
argument_list|(
name|aiocbe
argument_list|)
expr_stmt|;
name|aiocbe
operator|->
name|jobflags
operator|&=
operator|~
name|AIOCBLIST_RUNDOWN
expr_stmt|;
block|}
if|if
condition|(
name|aiocbe
operator|->
name|jobflags
operator|&
name|AIOCBLIST_SUSPEND
condition|)
block|{
name|wakeup
argument_list|(
name|userp
argument_list|)
expr_stmt|;
name|aiocbe
operator|->
name|jobflags
operator|&=
operator|~
name|AIOCBLIST_SUSPEND
expr_stmt|;
block|}
if|if
condition|(
name|cb
operator|->
name|aio_sigevent
operator|.
name|sigev_notify
operator|==
name|SIGEV_SIGNAL
condition|)
block|{
name|psignal
argument_list|(
name|userp
argument_list|,
name|cb
operator|->
name|aio_sigevent
operator|.
name|sigev_signo
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|cp
operator|!=
name|curproc
condition|)
block|{
name|tmpvm
operator|=
name|curproc
operator|->
name|p_vmspace
expr_stmt|;
name|curproc
operator|->
name|p_vmspace
operator|=
name|myvm
expr_stmt|;
name|pmap_activate
argument_list|(
name|curproc
argument_list|)
expr_stmt|;
name|vmspace_free
argument_list|(
name|tmpvm
argument_list|)
expr_stmt|;
if|if
condition|(
name|curproc
operator|->
name|p_fd
condition|)
name|fdfree
argument_list|(
name|curproc
argument_list|)
expr_stmt|;
name|curproc
operator|->
name|p_fd
operator|=
name|NULL
expr_stmt|;
name|cp
operator|=
name|curproc
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Create a new AIO daemon.  */
end_comment

begin_function
specifier|static
name|int
name|aio_newproc
parameter_list|()
block|{
name|int
name|error
decl_stmt|;
name|struct
name|rfork_args
name|rfa
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|rfa
operator|.
name|flags
operator|=
name|RFMEM
operator||
name|RFPROC
operator||
name|RFCFDG
expr_stmt|;
name|p
operator|=
name|curproc
expr_stmt|;
if|if
condition|(
name|error
operator|=
name|rfork
argument_list|(
name|p
argument_list|,
operator|&
name|rfa
argument_list|)
condition|)
return|return
name|error
return|;
name|cpu_set_fork_handler
argument_list|(
name|p
operator|=
name|pfind
argument_list|(
name|p
operator|->
name|p_retval
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|aio_startproc
argument_list|,
name|curproc
argument_list|)
expr_stmt|;
if|#
directive|if
name|DEBUGAIO
operator|>
literal|0
if|if
condition|(
name|debugaio
operator|>
literal|2
condition|)
name|printf
argument_list|(
literal|"Waiting for new process: %d, count: %d\n"
argument_list|,
name|curproc
operator|->
name|p_pid
argument_list|,
name|num_aio_procs
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|error
operator|=
name|tsleep
argument_list|(
operator|&
name|aio_freeproc
argument_list|,
name|PZERO
argument_list|,
literal|"aiosta"
argument_list|,
literal|5
operator|*
name|hz
argument_list|)
expr_stmt|;
operator|++
name|num_aio_procs
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  * Queue a new AIO request.  */
end_comment

begin_function
specifier|static
name|int
name|_aio_aqueue
parameter_list|(
name|struct
name|proc
modifier|*
name|p
parameter_list|,
name|struct
name|aiocb
modifier|*
name|job
parameter_list|,
name|int
name|type
parameter_list|)
block|{
name|struct
name|filedesc
modifier|*
name|fdp
decl_stmt|;
name|struct
name|file
modifier|*
name|fp
decl_stmt|;
name|unsigned
name|int
name|fd
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|opcode
decl_stmt|;
name|struct
name|aiocblist
modifier|*
name|aiocbe
decl_stmt|;
name|struct
name|aioproclist
modifier|*
name|aiop
decl_stmt|;
name|struct
name|kaioinfo
modifier|*
name|ki
decl_stmt|;
if|if
condition|(
name|aiocbe
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|aio_freejobs
argument_list|)
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|aio_freejobs
argument_list|,
name|aiocbe
argument_list|,
name|list
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|aiocbe
operator|=
name|malloc
argument_list|(
sizeof|sizeof
expr|*
name|aiocbe
argument_list|,
name|M_AIO
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
name|copyin
argument_list|(
operator|(
name|caddr_t
operator|)
name|job
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|aiocbe
operator|->
name|uaiocb
argument_list|,
sizeof|sizeof
name|aiocbe
operator|->
name|uaiocb
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
if|#
directive|if
name|DEBUGAIO
operator|>
literal|0
if|if
condition|(
name|debugaio
operator|>
literal|0
condition|)
name|printf
argument_list|(
literal|"aio_aqueue: Copyin error: %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|aio_freejobs
argument_list|,
name|aiocbe
argument_list|,
name|list
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
comment|/* 	 * Get the opcode 	 */
if|if
condition|(
name|type
operator|!=
name|LIO_NOP
condition|)
block|{
name|aiocbe
operator|->
name|uaiocb
operator|.
name|aio_lio_opcode
operator|=
name|type
expr_stmt|;
block|}
name|opcode
operator|=
name|aiocbe
operator|->
name|uaiocb
operator|.
name|aio_lio_opcode
expr_stmt|;
comment|/* 	 * Get the fd info for process 	 */
name|fdp
operator|=
name|p
operator|->
name|p_fd
expr_stmt|;
comment|/* 	 * Range check file descriptor 	 */
name|fd
operator|=
name|aiocbe
operator|->
name|uaiocb
operator|.
name|aio_fildes
expr_stmt|;
if|if
condition|(
name|fd
operator|>=
name|fdp
operator|->
name|fd_nfiles
condition|)
block|{
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|aio_freejobs
argument_list|,
name|aiocbe
argument_list|,
name|list
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
literal|0
condition|)
block|{
if|#
directive|if
name|DEBUGAIO
operator|>
literal|0
if|if
condition|(
name|debugaio
operator|>
literal|0
condition|)
name|printf
argument_list|(
literal|"aio_aqueue: Null type\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|suword
argument_list|(
operator|&
name|job
operator|->
name|_aiocb_private
operator|.
name|status
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|suword
argument_list|(
operator|&
name|job
operator|->
name|_aiocb_private
operator|.
name|error
argument_list|,
name|EBADF
argument_list|)
expr_stmt|;
block|}
return|return
name|EBADF
return|;
block|}
if|#
directive|if
name|DEBUGAIO
operator|>
literal|0
if|if
condition|(
name|debugaio
operator|>
literal|3
condition|)
name|printf
argument_list|(
literal|"aio_aqueue: fd: %d, cmd: %d, buf: %d, cnt: %d, fileoffset: %d\n"
argument_list|,
name|aiocbe
operator|->
name|uaiocb
operator|.
name|aio_fildes
argument_list|,
name|aiocbe
operator|->
name|uaiocb
operator|.
name|aio_lio_opcode
argument_list|,
operator|(
name|int
operator|)
name|aiocbe
operator|->
name|uaiocb
operator|.
name|aio_buf
operator|&
literal|0xffffffff
argument_list|,
name|aiocbe
operator|->
name|uaiocb
operator|.
name|aio_nbytes
argument_list|,
operator|(
name|int
operator|)
name|aiocbe
operator|->
name|uaiocb
operator|.
name|aio_offset
operator|&
literal|0xffffffff
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|fp
operator|=
name|fdp
operator|->
name|fd_ofiles
index|[
name|fd
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|fp
operator|==
name|NULL
operator|)
operator|||
operator|(
operator|(
name|opcode
operator|==
name|LIO_WRITE
operator|)
operator|&&
operator|(
operator|(
name|fp
operator|->
name|f_flag
operator|&
name|FWRITE
operator|)
operator|==
literal|0
operator|)
operator|)
condition|)
block|{
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|aio_freejobs
argument_list|,
name|aiocbe
argument_list|,
name|list
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
literal|0
condition|)
block|{
name|suword
argument_list|(
operator|&
name|job
operator|->
name|_aiocb_private
operator|.
name|status
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|suword
argument_list|(
operator|&
name|job
operator|->
name|_aiocb_private
operator|.
name|error
argument_list|,
name|EBADF
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|DEBUGAIO
operator|>
literal|0
if|if
condition|(
name|debugaio
operator|>
literal|0
condition|)
name|printf
argument_list|(
literal|"aio_aqueue: Bad file descriptor\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|EBADF
return|;
block|}
if|if
condition|(
name|aiocbe
operator|->
name|uaiocb
operator|.
name|aio_offset
operator|==
operator|-
literal|1LL
condition|)
block|{
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|aio_freejobs
argument_list|,
name|aiocbe
argument_list|,
name|list
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
literal|0
condition|)
block|{
name|suword
argument_list|(
operator|&
name|job
operator|->
name|_aiocb_private
operator|.
name|status
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|suword
argument_list|(
operator|&
name|job
operator|->
name|_aiocb_private
operator|.
name|error
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|DEBUGAIO
operator|>
literal|0
if|if
condition|(
name|debugaio
operator|>
literal|0
condition|)
name|printf
argument_list|(
literal|"aio_aqueue: bad offset\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|EINVAL
return|;
block|}
if|#
directive|if
name|DEBUGAIO
operator|>
literal|0
if|if
condition|(
name|debugaio
operator|>
literal|2
condition|)
name|printf
argument_list|(
literal|"job addr: 0x%x, 0x%x, %d\n"
argument_list|,
name|job
argument_list|,
operator|&
name|job
operator|->
name|_aiocb_private
operator|.
name|kernelinfo
argument_list|,
name|jobrefid
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|error
operator|=
name|suword
argument_list|(
operator|&
name|job
operator|->
name|_aiocb_private
operator|.
name|kernelinfo
argument_list|,
name|jobrefid
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|aio_freejobs
argument_list|,
name|aiocbe
argument_list|,
name|list
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
literal|0
condition|)
block|{
name|suword
argument_list|(
operator|&
name|job
operator|->
name|_aiocb_private
operator|.
name|status
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|suword
argument_list|(
operator|&
name|job
operator|->
name|_aiocb_private
operator|.
name|error
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|DEBUGAIO
operator|>
literal|0
if|if
condition|(
name|debugaio
operator|>
literal|0
condition|)
name|printf
argument_list|(
literal|"aio_aqueue: fetch of kernelinfo from user space\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|error
return|;
block|}
name|aiocbe
operator|->
name|uaiocb
operator|.
name|_aiocb_private
operator|.
name|kernelinfo
operator|=
operator|(
name|void
operator|*
operator|)
name|jobrefid
expr_stmt|;
if|#
directive|if
name|DEBUGAIO
operator|>
literal|0
if|if
condition|(
name|debugaio
operator|>
literal|2
condition|)
name|printf
argument_list|(
literal|"aio_aqueue: New job: %d...  "
argument_list|,
name|jobrefid
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|++
name|jobrefid
expr_stmt|;
if|if
condition|(
name|opcode
operator|==
name|LIO_NOP
condition|)
block|{
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|aio_freejobs
argument_list|,
name|aiocbe
argument_list|,
name|list
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
literal|0
condition|)
block|{
name|suword
argument_list|(
operator|&
name|job
operator|->
name|_aiocb_private
operator|.
name|status
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|suword
argument_list|(
operator|&
name|job
operator|->
name|_aiocb_private
operator|.
name|error
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|(
name|opcode
operator|!=
name|LIO_NOP
operator|)
operator|&&
operator|(
name|opcode
operator|!=
name|LIO_READ
operator|)
operator|&&
operator|(
name|opcode
operator|!=
name|LIO_WRITE
operator|)
condition|)
block|{
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|aio_freejobs
argument_list|,
name|aiocbe
argument_list|,
name|list
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
literal|0
condition|)
block|{
name|suword
argument_list|(
operator|&
name|job
operator|->
name|_aiocb_private
operator|.
name|status
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|suword
argument_list|(
operator|&
name|job
operator|->
name|_aiocb_private
operator|.
name|error
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|DEBUGAIO
operator|>
literal|0
if|if
condition|(
name|debugaio
operator|>
literal|0
condition|)
name|printf
argument_list|(
literal|"aio_aqueue: invalid LIO op: %d\n"
argument_list|,
name|opcode
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|EINVAL
return|;
block|}
name|suword
argument_list|(
operator|&
name|job
operator|->
name|_aiocb_private
operator|.
name|error
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|suword
argument_list|(
operator|&
name|job
operator|->
name|_aiocb_private
operator|.
name|status
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|aiocbe
operator|->
name|userproc
operator|=
name|p
expr_stmt|;
name|aiocbe
operator|->
name|jobflags
operator|=
literal|0
expr_stmt|;
name|ki
operator|=
name|p
operator|->
name|p_aioinfo
expr_stmt|;
operator|++
name|num_queue_count
expr_stmt|;
operator|++
name|ki
operator|->
name|kaio_queue_count
expr_stmt|;
name|retryproc
label|:
if|if
condition|(
name|aiop
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|aio_freeproc
argument_list|)
condition|)
block|{
if|#
directive|if
name|DEBUGAIO
operator|>
literal|0
if|if
condition|(
name|debugaio
operator|>
literal|0
condition|)
name|printf
argument_list|(
literal|"found a free AIO process\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|TAILQ_REMOVE
argument_list|(
operator|&
name|aio_freeproc
argument_list|,
name|aiop
argument_list|,
name|list
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|aio_activeproc
argument_list|,
name|aiop
argument_list|,
name|list
argument_list|)
expr_stmt|;
name|aiop
operator|->
name|aioprocflags
operator|&=
operator|~
name|AIOP_FREE
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|aiop
operator|->
name|jobtorun
argument_list|,
name|aiocbe
argument_list|,
name|list
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|ki
operator|->
name|kaio_jobqueue
argument_list|,
name|aiocbe
argument_list|,
name|plist
argument_list|)
expr_stmt|;
name|aiocbe
operator|->
name|jobstate
operator|=
name|JOBST_JOBQPROC
expr_stmt|;
name|aiocbe
operator|->
name|jobaioproc
operator|=
name|aiop
expr_stmt|;
name|wakeup
argument_list|(
name|aiop
operator|->
name|aioproc
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|num_aio_procs
operator|<
name|max_aio_procs
operator|)
operator|&&
operator|(
name|ki
operator|->
name|kaio_active_count
operator|<
name|ki
operator|->
name|kaio_maxactive_count
operator|)
condition|)
block|{
if|#
directive|if
name|DEBUGAIO
operator|>
literal|0
if|if
condition|(
name|debugaio
operator|>
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"aio_aqueue: starting new proc: num_aio_procs(%d), max_aio_procs(%d)\n"
argument_list|,
name|num_aio_procs
argument_list|,
name|max_aio_procs
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"            ki->kaio_active_count(%d), ki->kaio_maxactive_count(%d)\n"
argument_list|,
name|ki
operator|->
name|kaio_active_count
argument_list|,
name|ki
operator|->
name|kaio_maxactive_count
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|error
operator|=
name|aio_newproc
argument_list|()
condition|)
block|{
if|#
directive|if
name|DEBUGAIO
operator|>
literal|0
if|if
condition|(
name|debugaio
operator|>
literal|0
condition|)
name|printf
argument_list|(
literal|"aio_aqueue: problem sleeping for starting proc: %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
goto|goto
name|retryproc
goto|;
block|}
else|else
block|{
if|#
directive|if
name|DEBUGAIO
operator|>
literal|0
if|if
condition|(
name|debugaio
operator|>
literal|0
condition|)
name|printf
argument_list|(
literal|"queuing to global queue\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|aio_jobs
argument_list|,
name|aiocbe
argument_list|,
name|list
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|ki
operator|->
name|kaio_jobqueue
argument_list|,
name|aiocbe
argument_list|,
name|plist
argument_list|)
expr_stmt|;
name|aiocbe
operator|->
name|jobstate
operator|=
name|JOBST_JOBQGLOBAL
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|aio_aqueue
parameter_list|(
name|struct
name|proc
modifier|*
name|p
parameter_list|,
name|struct
name|aiocb
modifier|*
name|job
parameter_list|,
name|int
name|type
parameter_list|)
block|{
name|struct
name|kaioinfo
modifier|*
name|ki
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|p_aioinfo
operator|==
name|NULL
condition|)
block|{
name|aio_init_aioinfo
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|num_queue_count
operator|>=
name|max_queue_count
condition|)
return|return
name|EAGAIN
return|;
name|ki
operator|=
name|p
operator|->
name|p_aioinfo
expr_stmt|;
if|if
condition|(
name|ki
operator|->
name|kaio_queue_count
operator|>=
name|ki
operator|->
name|kaio_qallowed_count
condition|)
return|return
name|EAGAIN
return|;
return|return
name|_aio_aqueue
argument_list|(
name|p
argument_list|,
name|job
argument_list|,
name|type
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Support the aio_return system call  */
end_comment

begin_function
name|int
name|aio_return
parameter_list|(
name|struct
name|proc
modifier|*
name|p
parameter_list|,
name|struct
name|aio_return_args
modifier|*
name|uap
parameter_list|)
block|{
name|int
name|jobref
decl_stmt|,
name|status
decl_stmt|;
name|struct
name|aiocblist
modifier|*
name|cb
decl_stmt|;
name|struct
name|kaioinfo
modifier|*
name|ki
decl_stmt|;
name|ki
operator|=
name|p
operator|->
name|p_aioinfo
expr_stmt|;
if|if
condition|(
name|ki
operator|==
name|NULL
condition|)
block|{
return|return
name|EINVAL
return|;
block|}
name|jobref
operator|=
name|fuword
argument_list|(
operator|&
name|uap
operator|->
name|aiocbp
operator|->
name|_aiocb_private
operator|.
name|kernelinfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|jobref
operator|==
operator|-
literal|1
condition|)
return|return
name|EINVAL
return|;
if|#
directive|if
name|DEBUGAIO
operator|>
literal|0
if|if
condition|(
name|debugaio
operator|>
literal|0
condition|)
name|printf
argument_list|(
literal|"aio_return: jobref: %d\n"
argument_list|,
name|jobref
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|cb
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|ki
operator|->
name|kaio_jobdone
argument_list|)
init|;
name|cb
condition|;
name|cb
operator|=
name|TAILQ_NEXT
argument_list|(
name|cb
argument_list|,
name|plist
argument_list|)
control|)
block|{
if|if
condition|(
operator|(
operator|(
name|int
operator|)
name|cb
operator|->
name|uaiocb
operator|.
name|_aiocb_private
operator|.
name|kernelinfo
operator|)
operator|==
name|jobref
condition|)
block|{
name|p
operator|->
name|p_retval
index|[
literal|0
index|]
operator|=
name|cb
operator|->
name|uaiocb
operator|.
name|_aiocb_private
operator|.
name|status
expr_stmt|;
name|aio_free_entry
argument_list|(
name|cb
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
name|status
operator|=
name|fuword
argument_list|(
operator|&
name|uap
operator|->
name|aiocbp
operator|->
name|_aiocb_private
operator|.
name|status
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
operator|-
literal|1
condition|)
return|return
literal|0
return|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Rundown the jobs for a given process.    */
end_comment

begin_function
name|void
name|aio_marksuspend
parameter_list|(
name|struct
name|proc
modifier|*
name|p
parameter_list|,
name|int
name|njobs
parameter_list|,
name|int
modifier|*
name|joblist
parameter_list|,
name|int
name|set
parameter_list|)
block|{
name|struct
name|aiocblist
modifier|*
name|aiocbe
decl_stmt|;
name|struct
name|kaioinfo
modifier|*
name|ki
decl_stmt|;
name|ki
operator|=
name|p
operator|->
name|p_aioinfo
expr_stmt|;
if|if
condition|(
name|ki
operator|==
name|NULL
condition|)
return|return;
for|for
control|(
name|aiocbe
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|ki
operator|->
name|kaio_jobqueue
argument_list|)
init|;
name|aiocbe
condition|;
name|aiocbe
operator|=
name|TAILQ_NEXT
argument_list|(
name|aiocbe
argument_list|,
name|plist
argument_list|)
control|)
block|{
if|if
condition|(
name|njobs
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|njobs
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
operator|(
name|int
operator|)
name|aiocbe
operator|->
name|uaiocb
operator|.
name|_aiocb_private
operator|.
name|kernelinfo
operator|)
operator|==
name|joblist
index|[
name|i
index|]
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|==
name|njobs
condition|)
continue|continue;
block|}
if|if
condition|(
name|set
condition|)
name|aiocbe
operator|->
name|jobflags
operator||=
name|AIOCBLIST_SUSPEND
expr_stmt|;
else|else
name|aiocbe
operator|->
name|jobflags
operator|&=
operator|~
name|AIOCBLIST_SUSPEND
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Allow a process to wakeup when any of the I/O requests are  * completed.  */
end_comment

begin_function
name|int
name|aio_suspend
parameter_list|(
name|struct
name|proc
modifier|*
name|p
parameter_list|,
name|struct
name|aio_suspend_args
modifier|*
name|uap
parameter_list|)
block|{
name|struct
name|timeval
name|atv
decl_stmt|;
name|struct
name|timespec
name|ts
decl_stmt|;
name|struct
name|aiocb
modifier|*
specifier|const
modifier|*
name|cbptr
decl_stmt|,
modifier|*
name|cbp
decl_stmt|;
name|struct
name|kaioinfo
modifier|*
name|ki
decl_stmt|;
name|struct
name|aiocblist
modifier|*
name|cb
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|error
decl_stmt|,
name|s
decl_stmt|,
name|timo
decl_stmt|;
name|int
modifier|*
name|joblist
decl_stmt|;
name|timo
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|uap
operator|->
name|timeout
condition|)
block|{
comment|/* 		 * Get timespec struct 		 */
if|if
condition|(
name|error
operator|=
name|copyin
argument_list|(
operator|(
name|caddr_t
operator|)
name|uap
operator|->
name|timeout
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|ts
argument_list|,
sizeof|sizeof
name|ts
argument_list|)
condition|)
block|{
return|return
name|error
return|;
block|}
if|if
condition|(
name|ts
operator|.
name|tv_nsec
operator|<
literal|0
operator|||
name|ts
operator|.
name|tv_nsec
operator|>=
literal|1000000000
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|TIMESPEC_TO_TIMEVAL
argument_list|(
argument|&atv
argument_list|,
argument|&ts
argument_list|)
if|if
condition|(
name|itimerfix
argument_list|(
operator|&
name|atv
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* 		 * XXX this is not as careful as settimeofday() about minimising 		 * interrupt latency.  The hzto() interface is inconvenient as usual. 		 */
name|s
operator|=
name|splclock
argument_list|()
expr_stmt|;
name|timevaladd
argument_list|(
operator|&
name|atv
argument_list|,
operator|&
name|time
argument_list|)
expr_stmt|;
name|timo
operator|=
name|hzto
argument_list|(
operator|&
name|atv
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|timo
operator|==
literal|0
condition|)
name|timo
operator|=
literal|1
expr_stmt|;
block|}
name|ki
operator|=
name|p
operator|->
name|p_aioinfo
expr_stmt|;
if|if
condition|(
name|ki
operator|==
name|NULL
condition|)
return|return
name|EAGAIN
return|;
name|joblist
operator|=
name|malloc
argument_list|(
name|uap
operator|->
name|nent
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|cbptr
operator|=
name|uap
operator|->
name|aiocbp
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|uap
operator|->
name|nent
condition|;
name|i
operator|++
control|)
block|{
name|cbp
operator|=
operator|(
expr|struct
name|aiocb
operator|*
operator|)
name|fuword
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|cbptr
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|#
directive|if
name|DEBUGAIO
operator|>
literal|1
if|if
condition|(
name|debugaio
operator|>
literal|2
condition|)
name|printf
argument_list|(
literal|"cbp: %x\n"
argument_list|,
name|cbp
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|joblist
index|[
name|i
index|]
operator|=
name|fuword
argument_list|(
operator|&
name|cbp
operator|->
name|_aiocb_private
operator|.
name|kernelinfo
argument_list|)
expr_stmt|;
name|cbptr
operator|++
expr_stmt|;
block|}
while|while
condition|(
literal|1
condition|)
block|{
for|for
control|(
name|cb
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|ki
operator|->
name|kaio_jobdone
argument_list|)
init|;
name|cb
condition|;
name|cb
operator|=
name|TAILQ_NEXT
argument_list|(
name|cb
argument_list|,
name|plist
argument_list|)
control|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|uap
operator|->
name|nent
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
operator|(
name|int
operator|)
name|cb
operator|->
name|uaiocb
operator|.
name|_aiocb_private
operator|.
name|kernelinfo
operator|)
operator|==
name|joblist
index|[
name|i
index|]
condition|)
block|{
name|free
argument_list|(
name|joblist
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
block|}
if|#
directive|if
name|DEBUGAIO
operator|>
literal|0
if|if
condition|(
name|debugaio
operator|>
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"Suspend, timeout: %d clocks, jobs:"
argument_list|,
name|timo
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|uap
operator|->
name|nent
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|" %d"
argument_list|,
name|joblist
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|aio_marksuspend
argument_list|(
name|p
argument_list|,
name|uap
operator|->
name|nent
argument_list|,
name|joblist
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|#
directive|if
name|DEBUGAIO
operator|>
literal|0
if|if
condition|(
name|debugaio
operator|>
literal|2
condition|)
block|{
name|printf
argument_list|(
literal|"Suspending -- waiting for all I/O's to complete: "
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|uap
operator|->
name|nent
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|" %d"
argument_list|,
name|joblist
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|error
operator|=
name|tsleep
argument_list|(
name|p
argument_list|,
name|PRIBIO
operator||
name|PCATCH
argument_list|,
literal|"aiospn"
argument_list|,
name|timo
argument_list|)
expr_stmt|;
name|aio_marksuspend
argument_list|(
name|p
argument_list|,
name|uap
operator|->
name|nent
argument_list|,
name|joblist
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|EINTR
condition|)
block|{
if|#
directive|if
name|DEBUGAIO
operator|>
literal|0
if|if
condition|(
name|debugaio
operator|>
literal|2
condition|)
name|printf
argument_list|(
literal|" signal\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|free
argument_list|(
name|joblist
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
name|EINTR
return|;
block|}
elseif|else
if|if
condition|(
name|error
operator|==
name|EWOULDBLOCK
condition|)
block|{
if|#
directive|if
name|DEBUGAIO
operator|>
literal|0
if|if
condition|(
name|debugaio
operator|>
literal|2
condition|)
name|printf
argument_list|(
literal|" timeout\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|free
argument_list|(
name|joblist
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
name|EAGAIN
return|;
block|}
if|#
directive|if
name|DEBUGAIO
operator|>
literal|0
if|if
condition|(
name|debugaio
operator|>
literal|2
condition|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* NOTREACHED */
return|return
name|EINVAL
return|;
block|}
end_function

begin_comment
comment|/*  * aio_cancel at the kernel level is a NOOP right now.  It  * might be possible to support it partially in user mode, or  * in kernel mode later on.  */
end_comment

begin_function
name|int
name|aio_cancel
parameter_list|(
name|struct
name|proc
modifier|*
name|p
parameter_list|,
name|struct
name|aio_cancel_args
modifier|*
name|uap
parameter_list|)
block|{
return|return
name|AIO_NOTCANCELLED
return|;
block|}
end_function

begin_comment
comment|/*  * aio_error is implemented in the kernel level for compatibility  * purposes only.  For a user mode async implementation, it would be  * best to do it in a userland subroutine.  */
end_comment

begin_function
name|int
name|aio_error
parameter_list|(
name|struct
name|proc
modifier|*
name|p
parameter_list|,
name|struct
name|aio_error_args
modifier|*
name|uap
parameter_list|)
block|{
name|struct
name|aiocblist
modifier|*
name|cb
decl_stmt|;
name|struct
name|kaioinfo
modifier|*
name|ki
decl_stmt|;
name|int
name|jobref
decl_stmt|;
name|int
name|status
decl_stmt|;
name|ki
operator|=
name|p
operator|->
name|p_aioinfo
expr_stmt|;
if|if
condition|(
name|ki
operator|==
name|NULL
condition|)
return|return
name|EINVAL
return|;
name|jobref
operator|=
name|fuword
argument_list|(
operator|&
name|uap
operator|->
name|aiocbp
operator|->
name|_aiocb_private
operator|.
name|kernelinfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|jobref
operator|==
operator|-
literal|1
condition|)
return|return
name|EFAULT
return|;
for|for
control|(
name|cb
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|ki
operator|->
name|kaio_jobdone
argument_list|)
init|;
name|cb
condition|;
name|cb
operator|=
name|TAILQ_NEXT
argument_list|(
name|cb
argument_list|,
name|plist
argument_list|)
control|)
block|{
if|if
condition|(
operator|(
operator|(
name|int
operator|)
name|cb
operator|->
name|uaiocb
operator|.
name|_aiocb_private
operator|.
name|kernelinfo
operator|)
operator|==
name|jobref
condition|)
block|{
name|p
operator|->
name|p_retval
index|[
literal|0
index|]
operator|=
name|cb
operator|->
name|uaiocb
operator|.
name|_aiocb_private
operator|.
name|error
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
for|for
control|(
name|cb
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|ki
operator|->
name|kaio_jobqueue
argument_list|)
init|;
name|cb
condition|;
name|cb
operator|=
name|TAILQ_NEXT
argument_list|(
name|cb
argument_list|,
name|plist
argument_list|)
control|)
block|{
if|if
condition|(
operator|(
operator|(
name|int
operator|)
name|cb
operator|->
name|uaiocb
operator|.
name|_aiocb_private
operator|.
name|kernelinfo
operator|)
operator|==
name|jobref
condition|)
block|{
name|p
operator|->
name|p_retval
index|[
literal|0
index|]
operator|=
name|EINPROGRESS
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
comment|/* 	 * Hack for lio 	 */
name|status
operator|=
name|fuword
argument_list|(
operator|&
name|uap
operator|->
name|aiocbp
operator|->
name|_aiocb_private
operator|.
name|status
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
operator|-
literal|1
condition|)
block|{
return|return
name|fuword
argument_list|(
operator|&
name|uap
operator|->
name|aiocbp
operator|->
name|_aiocb_private
operator|.
name|error
argument_list|)
return|;
block|}
return|return
name|EINVAL
return|;
block|}
end_function

begin_function
name|int
name|aio_read
parameter_list|(
name|struct
name|proc
modifier|*
name|p
parameter_list|,
name|struct
name|aio_read_args
modifier|*
name|uap
parameter_list|)
block|{
name|struct
name|filedesc
modifier|*
name|fdp
decl_stmt|;
name|struct
name|file
modifier|*
name|fp
decl_stmt|;
name|struct
name|uio
name|auio
decl_stmt|;
name|struct
name|iovec
name|aiov
decl_stmt|;
name|unsigned
name|int
name|fd
decl_stmt|;
name|int
name|cnt
decl_stmt|;
name|struct
name|aiocb
name|iocb
decl_stmt|;
name|int
name|error
decl_stmt|,
name|pmodes
decl_stmt|;
name|pmodes
operator|=
name|fuword
argument_list|(
operator|&
name|uap
operator|->
name|aiocbp
operator|->
name|_aiocb_private
operator|.
name|privatemodes
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pmodes
operator|&
name|AIO_PMODE_SYNC
operator|)
operator|==
literal|0
condition|)
block|{
if|#
directive|if
name|DEBUGAIO
operator|>
literal|1
if|if
condition|(
name|debugaio
operator|>
literal|2
condition|)
name|printf
argument_list|(
literal|"queueing aio_read\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|aio_aqueue
argument_list|(
name|p
argument_list|,
operator|(
expr|struct
name|aiocb
operator|*
operator|)
name|uap
operator|->
name|aiocbp
argument_list|,
name|LIO_READ
argument_list|)
return|;
block|}
comment|/* 	 * Get control block 	 */
if|if
condition|(
name|error
operator|=
name|copyin
argument_list|(
operator|(
name|caddr_t
operator|)
name|uap
operator|->
name|aiocbp
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|iocb
argument_list|,
sizeof|sizeof
name|iocb
argument_list|)
condition|)
return|return
name|error
return|;
comment|/* 	 * Get the fd info for process 	 */
name|fdp
operator|=
name|p
operator|->
name|p_fd
expr_stmt|;
comment|/* 	 * Range check file descriptor 	 */
name|fd
operator|=
name|iocb
operator|.
name|aio_fildes
expr_stmt|;
if|if
condition|(
name|fd
operator|>=
name|fdp
operator|->
name|fd_nfiles
condition|)
return|return
name|EBADF
return|;
name|fp
operator|=
name|fdp
operator|->
name|fd_ofiles
index|[
name|fd
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|fp
operator|==
name|NULL
operator|)
operator|||
operator|(
operator|(
name|fp
operator|->
name|f_flag
operator|&
name|FREAD
operator|)
operator|==
literal|0
operator|)
condition|)
return|return
name|EBADF
return|;
if|if
condition|(
name|iocb
operator|.
name|aio_offset
operator|==
operator|-
literal|1LL
condition|)
return|return
name|EINVAL
return|;
name|auio
operator|.
name|uio_resid
operator|=
name|iocb
operator|.
name|aio_nbytes
expr_stmt|;
if|if
condition|(
name|auio
operator|.
name|uio_resid
operator|<
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* 	 * Process sync simply -- queue async request. 	 */
if|if
condition|(
operator|(
name|iocb
operator|.
name|_aiocb_private
operator|.
name|privatemodes
operator|&
name|AIO_PMODE_SYNC
operator|)
operator|==
literal|0
condition|)
block|{
return|return
name|aio_aqueue
argument_list|(
name|p
argument_list|,
operator|(
expr|struct
name|aiocb
operator|*
operator|)
name|uap
operator|->
name|aiocbp
argument_list|,
name|LIO_READ
argument_list|)
return|;
block|}
name|aiov
operator|.
name|iov_base
operator|=
name|iocb
operator|.
name|aio_buf
expr_stmt|;
name|aiov
operator|.
name|iov_len
operator|=
name|iocb
operator|.
name|aio_nbytes
expr_stmt|;
name|auio
operator|.
name|uio_iov
operator|=
operator|&
name|aiov
expr_stmt|;
name|auio
operator|.
name|uio_iovcnt
operator|=
literal|1
expr_stmt|;
name|auio
operator|.
name|uio_offset
operator|=
name|iocb
operator|.
name|aio_offset
expr_stmt|;
name|auio
operator|.
name|uio_rw
operator|=
name|UIO_READ
expr_stmt|;
name|auio
operator|.
name|uio_segflg
operator|=
name|UIO_USERSPACE
expr_stmt|;
name|auio
operator|.
name|uio_procp
operator|=
name|p
expr_stmt|;
name|cnt
operator|=
name|iocb
operator|.
name|aio_nbytes
expr_stmt|;
name|error
operator|=
call|(
modifier|*
name|fp
operator|->
name|f_ops
operator|->
name|fo_read
call|)
argument_list|(
name|fp
argument_list|,
operator|&
name|auio
argument_list|,
name|fp
operator|->
name|f_cred
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|&&
operator|(
name|auio
operator|.
name|uio_resid
operator|!=
name|cnt
operator|)
operator|&&
operator|(
name|error
operator|==
name|ERESTART
operator|||
name|error
operator|==
name|EINTR
operator|||
name|error
operator|==
name|EWOULDBLOCK
operator|)
condition|)
name|error
operator|=
literal|0
expr_stmt|;
name|cnt
operator|-=
name|auio
operator|.
name|uio_resid
expr_stmt|;
name|p
operator|->
name|p_retval
index|[
literal|0
index|]
operator|=
name|cnt
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_function
name|int
name|aio_write
parameter_list|(
name|struct
name|proc
modifier|*
name|p
parameter_list|,
name|struct
name|aio_write_args
modifier|*
name|uap
parameter_list|)
block|{
name|struct
name|filedesc
modifier|*
name|fdp
decl_stmt|;
name|struct
name|file
modifier|*
name|fp
decl_stmt|;
name|struct
name|uio
name|auio
decl_stmt|;
name|struct
name|iovec
name|aiov
decl_stmt|;
name|unsigned
name|int
name|fd
decl_stmt|;
name|int
name|cnt
decl_stmt|;
name|struct
name|aiocb
name|iocb
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|pmodes
decl_stmt|;
comment|/* 	 * Process sync simply -- queue async request. 	 */
name|pmodes
operator|=
name|fuword
argument_list|(
operator|&
name|uap
operator|->
name|aiocbp
operator|->
name|_aiocb_private
operator|.
name|privatemodes
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pmodes
operator|&
name|AIO_PMODE_SYNC
operator|)
operator|==
literal|0
condition|)
block|{
if|#
directive|if
name|DEBUGAIO
operator|>
literal|1
if|if
condition|(
name|debugaio
operator|>
literal|2
condition|)
name|printf
argument_list|(
literal|"queing aio_write\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|aio_aqueue
argument_list|(
name|p
argument_list|,
operator|(
expr|struct
name|aiocb
operator|*
operator|)
name|uap
operator|->
name|aiocbp
argument_list|,
name|LIO_WRITE
argument_list|)
return|;
block|}
if|if
condition|(
name|error
operator|=
name|copyin
argument_list|(
operator|(
name|caddr_t
operator|)
name|uap
operator|->
name|aiocbp
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|iocb
argument_list|,
sizeof|sizeof
name|iocb
argument_list|)
condition|)
return|return
name|error
return|;
comment|/* 	 * Get the fd info for process 	 */
name|fdp
operator|=
name|p
operator|->
name|p_fd
expr_stmt|;
comment|/* 	 * Range check file descriptor 	 */
name|fd
operator|=
name|iocb
operator|.
name|aio_fildes
expr_stmt|;
if|if
condition|(
name|fd
operator|>=
name|fdp
operator|->
name|fd_nfiles
condition|)
return|return
name|EBADF
return|;
name|fp
operator|=
name|fdp
operator|->
name|fd_ofiles
index|[
name|fd
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|fp
operator|==
name|NULL
operator|)
operator|||
operator|(
operator|(
name|fp
operator|->
name|f_flag
operator|&
name|FWRITE
operator|)
operator|==
literal|0
operator|)
condition|)
return|return
name|EBADF
return|;
if|if
condition|(
name|iocb
operator|.
name|aio_offset
operator|==
operator|-
literal|1LL
condition|)
return|return
name|EINVAL
return|;
name|aiov
operator|.
name|iov_base
operator|=
name|iocb
operator|.
name|aio_buf
expr_stmt|;
name|aiov
operator|.
name|iov_len
operator|=
name|iocb
operator|.
name|aio_nbytes
expr_stmt|;
name|auio
operator|.
name|uio_iov
operator|=
operator|&
name|aiov
expr_stmt|;
name|auio
operator|.
name|uio_iovcnt
operator|=
literal|1
expr_stmt|;
name|auio
operator|.
name|uio_offset
operator|=
name|iocb
operator|.
name|aio_offset
expr_stmt|;
name|auio
operator|.
name|uio_resid
operator|=
name|iocb
operator|.
name|aio_nbytes
expr_stmt|;
if|if
condition|(
name|auio
operator|.
name|uio_resid
operator|<
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|auio
operator|.
name|uio_rw
operator|=
name|UIO_WRITE
expr_stmt|;
name|auio
operator|.
name|uio_segflg
operator|=
name|UIO_USERSPACE
expr_stmt|;
name|auio
operator|.
name|uio_procp
operator|=
name|p
expr_stmt|;
name|cnt
operator|=
name|iocb
operator|.
name|aio_nbytes
expr_stmt|;
name|error
operator|=
call|(
modifier|*
name|fp
operator|->
name|f_ops
operator|->
name|fo_write
call|)
argument_list|(
name|fp
argument_list|,
operator|&
name|auio
argument_list|,
name|fp
operator|->
name|f_cred
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
if|if
condition|(
name|auio
operator|.
name|uio_resid
operator|!=
name|cnt
condition|)
block|{
if|if
condition|(
name|error
operator|==
name|ERESTART
operator|||
name|error
operator|==
name|EINTR
operator|||
name|error
operator|==
name|EWOULDBLOCK
condition|)
name|error
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|EPIPE
condition|)
name|psignal
argument_list|(
name|p
argument_list|,
name|SIGPIPE
argument_list|)
expr_stmt|;
block|}
block|}
name|cnt
operator|-=
name|auio
operator|.
name|uio_resid
expr_stmt|;
name|p
operator|->
name|p_retval
index|[
literal|0
index|]
operator|=
name|cnt
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_function
name|int
name|lio_listio
parameter_list|(
name|struct
name|proc
modifier|*
name|p
parameter_list|,
name|struct
name|lio_listio_args
modifier|*
name|uap
parameter_list|)
block|{
name|int
name|nent
decl_stmt|,
name|nentqueued
decl_stmt|;
name|struct
name|aiocb
modifier|*
name|iocb
decl_stmt|,
modifier|*
decl_stmt|const
modifier|*
name|cbptr
decl_stmt|;
name|struct
name|aiocblist
modifier|*
name|cb
decl_stmt|;
name|struct
name|kaioinfo
modifier|*
name|ki
decl_stmt|;
name|int
name|error
decl_stmt|,
name|runningcode
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|(
name|uap
operator|->
name|mode
operator|!=
name|LIO_NOWAIT
operator|)
operator|&&
operator|(
name|uap
operator|->
name|mode
operator|!=
name|LIO_WAIT
operator|)
condition|)
block|{
if|#
directive|if
name|DEBUGAIO
operator|>
literal|0
if|if
condition|(
name|debugaio
operator|>
literal|0
condition|)
name|printf
argument_list|(
literal|"lio_listio: bad mode: %d\n"
argument_list|,
name|uap
operator|->
name|mode
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|EINVAL
return|;
block|}
name|nent
operator|=
name|uap
operator|->
name|nent
expr_stmt|;
if|if
condition|(
name|nent
operator|>
name|AIO_LISTIO_MAX
condition|)
block|{
if|#
directive|if
name|DEBUGAIO
operator|>
literal|0
if|if
condition|(
name|debugaio
operator|>
literal|0
condition|)
name|printf
argument_list|(
literal|"lio_listio: nent> AIO_LISTIO_MAX: %d> %d\n"
argument_list|,
name|nent
argument_list|,
name|AIO_LISTIO_MAX
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|EINVAL
return|;
block|}
if|if
condition|(
name|p
operator|->
name|p_aioinfo
operator|==
name|NULL
condition|)
block|{
name|aio_init_aioinfo
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|nent
operator|+
name|num_queue_count
operator|)
operator|>
name|max_queue_count
condition|)
block|{
if|#
directive|if
name|DEBUGAIO
operator|>
literal|0
if|if
condition|(
name|debugaio
operator|>
literal|0
condition|)
name|printf
argument_list|(
literal|"lio_listio: (nent(%d) + num_queue_count(%d))> max_queue_count(%d)\n"
argument_list|,
name|nent
argument_list|,
name|num_queue_count
argument_list|,
name|max_queue_count
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|EAGAIN
return|;
block|}
name|ki
operator|=
name|p
operator|->
name|p_aioinfo
expr_stmt|;
if|if
condition|(
operator|(
name|nent
operator|+
name|ki
operator|->
name|kaio_queue_count
operator|)
operator|>
name|ki
operator|->
name|kaio_qallowed_count
condition|)
block|{
if|#
directive|if
name|DEBUGAIO
operator|>
literal|0
if|if
condition|(
name|debugaio
operator|>
literal|0
condition|)
name|printf
argument_list|(
literal|"lio_listio: (nent(%d) + ki->kaio_queue_count(%d))> ki->kaio_qallowed_count(%d)\n"
argument_list|,
name|nent
argument_list|,
name|ki
operator|->
name|kaio_queue_count
argument_list|,
name|ki
operator|->
name|kaio_qallowed_count
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|EAGAIN
return|;
block|}
comment|/* 	num_queue_count += nent; 	ki->kaio_queue_count += nent; */
name|nentqueued
operator|=
literal|0
expr_stmt|;
comment|/*  * get pointers to the list of I/O requests 	iocbvec = malloc(uap->nent * sizeof(struct aiocb *), M_TEMP, M_WAITOK);  */
name|cbptr
operator|=
name|uap
operator|->
name|acb_list
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|uap
operator|->
name|nent
condition|;
name|i
operator|++
control|)
block|{
name|iocb
operator|=
operator|(
expr|struct
name|aiocb
operator|*
operator|)
name|fuword
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|cbptr
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|error
operator|=
name|_aio_aqueue
argument_list|(
name|p
argument_list|,
name|iocb
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|nentqueued
operator|++
expr_stmt|;
block|}
comment|/* 	 * If we haven't queued any, then just return error 	 */
if|if
condition|(
name|nentqueued
operator|==
literal|0
condition|)
block|{
if|#
directive|if
name|DEBUGAIO
operator|>
literal|0
if|if
condition|(
name|debugaio
operator|>
literal|0
condition|)
name|printf
argument_list|(
literal|"lio_listio: none queued\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|EIO
return|;
block|}
if|#
directive|if
name|DEBUGAIO
operator|>
literal|0
if|if
condition|(
name|debugaio
operator|>
literal|0
condition|)
name|printf
argument_list|(
literal|"lio_listio: %d queued\n"
argument_list|,
name|nentqueued
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Calculate the appropriate error return 	 */
name|runningcode
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|nentqueued
operator|!=
name|nent
condition|)
name|runningcode
operator|=
name|EIO
expr_stmt|;
if|if
condition|(
name|uap
operator|->
name|mode
operator|==
name|LIO_WAIT
condition|)
block|{
while|while
condition|(
literal|1
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|uap
operator|->
name|nent
condition|;
name|i
operator|++
control|)
block|{
name|int
name|found
decl_stmt|;
name|int
name|jobref
decl_stmt|,
name|command
decl_stmt|,
name|status
decl_stmt|;
comment|/* 				 * Fetch address of the control buf pointer in user space 				 */
name|iocb
operator|=
operator|(
expr|struct
name|aiocb
operator|*
operator|)
name|fuword
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|cbptr
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|/* 				 * Fetch the associated command from user space 				 */
name|command
operator|=
name|fuword
argument_list|(
operator|&
name|iocb
operator|->
name|aio_lio_opcode
argument_list|)
expr_stmt|;
if|if
condition|(
name|command
operator|==
name|LIO_NOP
condition|)
continue|continue;
comment|/* 				 * If the status shows error or complete, then skip this entry. 				 */
name|status
operator|=
name|fuword
argument_list|(
operator|&
name|iocb
operator|->
name|_aiocb_private
operator|.
name|status
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
continue|continue;
name|jobref
operator|=
name|fuword
argument_list|(
operator|&
name|iocb
operator|->
name|_aiocb_private
operator|.
name|kernelinfo
argument_list|)
expr_stmt|;
name|found
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|cb
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|ki
operator|->
name|kaio_jobdone
argument_list|)
init|;
name|cb
condition|;
name|cb
operator|=
name|TAILQ_NEXT
argument_list|(
name|cb
argument_list|,
name|plist
argument_list|)
control|)
block|{
if|if
condition|(
operator|(
operator|(
name|int
operator|)
name|cb
operator|->
name|uaiocb
operator|.
name|_aiocb_private
operator|.
name|kernelinfo
operator|)
operator|==
name|jobref
condition|)
block|{
name|found
operator|++
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|found
operator|==
literal|0
condition|)
break|break;
block|}
comment|/* 			 * If all I/Os have been disposed of, then we can return 			 */
if|if
condition|(
name|i
operator|==
name|uap
operator|->
name|nent
condition|)
block|{
return|return
name|runningcode
return|;
block|}
name|aio_marksuspend
argument_list|(
name|p
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|error
operator|=
name|tsleep
argument_list|(
name|p
argument_list|,
name|PRIBIO
operator||
name|PCATCH
argument_list|,
literal|"aiospn"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|aio_marksuspend
argument_list|(
name|p
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|EINTR
condition|)
block|{
return|return
name|EINTR
return|;
block|}
elseif|else
if|if
condition|(
name|error
operator|==
name|EWOULDBLOCK
condition|)
block|{
return|return
name|EAGAIN
return|;
block|}
block|}
block|}
return|return
name|runningcode
return|;
block|}
end_function

end_unit

