begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1997 John S. Dyson.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. John S. Dyson's name may not be used to endorse or promote products  *    derived from this software without specific prior written permission.  *  * DISCLAIMER:  This code isn't warranted to do anything useful.  Anything  * bad that happens because of using this software isn't the responsibility  * of the author.  This software is distributed AS-IS.  *  * $FreeBSD$  */
end_comment

begin_comment
comment|/*  * This file contains support for the POSIX 1003.1B AIO/LIO facility.  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/bio.h>
end_include

begin_include
include|#
directive|include
file|<sys/buf.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysproto.h>
end_include

begin_include
include|#
directive|include
file|<sys/filedesc.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/unistd.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/resourcevar.h>
end_include

begin_include
include|#
directive|include
file|<sys/signalvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/protosw.h>
end_include

begin_include
include|#
directive|include
file|<sys/socketvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/vnode.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/event.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_extern.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_map.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_zone.h>
end_include

begin_include
include|#
directive|include
file|<sys/aio.h>
end_include

begin_include
include|#
directive|include
file|<machine/limits.h>
end_include

begin_include
include|#
directive|include
file|"opt_vfs_aio.h"
end_include

begin_decl_stmt
specifier|static
name|long
name|jobrefid
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|JOBST_NULL
value|0x0
end_define

begin_define
define|#
directive|define
name|JOBST_JOBQPROC
value|0x1
end_define

begin_define
define|#
directive|define
name|JOBST_JOBQGLOBAL
value|0x2
end_define

begin_define
define|#
directive|define
name|JOBST_JOBRUNNING
value|0x3
end_define

begin_define
define|#
directive|define
name|JOBST_JOBFINISHED
value|0x4
end_define

begin_define
define|#
directive|define
name|JOBST_JOBQBUF
value|0x5
end_define

begin_define
define|#
directive|define
name|JOBST_JOBBFINISHED
value|0x6
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|MAX_AIO_PER_PROC
end_ifndef

begin_define
define|#
directive|define
name|MAX_AIO_PER_PROC
value|32
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|MAX_AIO_QUEUE_PER_PROC
end_ifndef

begin_define
define|#
directive|define
name|MAX_AIO_QUEUE_PER_PROC
value|256
end_define

begin_comment
comment|/* Bigger than AIO_LISTIO_MAX */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|MAX_AIO_PROCS
end_ifndef

begin_define
define|#
directive|define
name|MAX_AIO_PROCS
value|32
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|MAX_AIO_QUEUE
end_ifndef

begin_define
define|#
directive|define
name|MAX_AIO_QUEUE
value|1024
end_define

begin_comment
comment|/* Bigger than AIO_LISTIO_MAX */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|TARGET_AIO_PROCS
end_ifndef

begin_define
define|#
directive|define
name|TARGET_AIO_PROCS
value|4
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|MAX_BUF_AIO
end_ifndef

begin_define
define|#
directive|define
name|MAX_BUF_AIO
value|16
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|AIOD_TIMEOUT_DEFAULT
end_ifndef

begin_define
define|#
directive|define
name|AIOD_TIMEOUT_DEFAULT
value|(10 * hz)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|AIOD_LIFETIME_DEFAULT
end_ifndef

begin_define
define|#
directive|define
name|AIOD_LIFETIME_DEFAULT
value|(30 * hz)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|int
name|max_aio_procs
init|=
name|MAX_AIO_PROCS
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|num_aio_procs
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|target_aio_procs
init|=
name|TARGET_AIO_PROCS
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|max_queue_count
init|=
name|MAX_AIO_QUEUE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|num_queue_count
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|num_buf_aio
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|num_aio_resv_start
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|aiod_timeout
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|aiod_lifetime
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|max_aio_per_proc
init|=
name|MAX_AIO_PER_PROC
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|max_aio_queue_per_proc
init|=
name|MAX_AIO_QUEUE_PER_PROC
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|max_buf_aio
init|=
name|MAX_BUF_AIO
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_vfs
argument_list|,
name|OID_AUTO
argument_list|,
name|aio
argument_list|,
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
literal|"AIO mgmt"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vfs_aio
argument_list|,
name|OID_AUTO
argument_list|,
name|max_aio_per_proc
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|max_aio_per_proc
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vfs_aio
argument_list|,
name|OID_AUTO
argument_list|,
name|max_aio_queue_per_proc
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|max_aio_queue_per_proc
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vfs_aio
argument_list|,
name|OID_AUTO
argument_list|,
name|max_aio_procs
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|max_aio_procs
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vfs_aio
argument_list|,
name|OID_AUTO
argument_list|,
name|num_aio_procs
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|num_aio_procs
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vfs_aio
argument_list|,
name|OID_AUTO
argument_list|,
name|num_queue_count
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|num_queue_count
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vfs_aio
argument_list|,
name|OID_AUTO
argument_list|,
name|max_aio_queue
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|max_queue_count
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vfs_aio
argument_list|,
name|OID_AUTO
argument_list|,
name|target_aio_procs
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|target_aio_procs
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vfs_aio
argument_list|,
name|OID_AUTO
argument_list|,
name|max_buf_aio
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|max_buf_aio
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vfs_aio
argument_list|,
name|OID_AUTO
argument_list|,
name|num_buf_aio
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|num_buf_aio
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vfs_aio
argument_list|,
name|OID_AUTO
argument_list|,
name|aiod_lifetime
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|aiod_lifetime
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vfs_aio
argument_list|,
name|OID_AUTO
argument_list|,
name|aiod_timeout
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|aiod_timeout
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * AIO process info  */
end_comment

begin_define
define|#
directive|define
name|AIOP_FREE
value|0x1
end_define

begin_comment
comment|/* proc on free queue */
end_comment

begin_define
define|#
directive|define
name|AIOP_SCHED
value|0x2
end_define

begin_comment
comment|/* proc explicitly scheduled */
end_comment

begin_struct
struct|struct
name|aioproclist
block|{
name|int
name|aioprocflags
decl_stmt|;
comment|/* AIO proc flags */
name|TAILQ_ENTRY
argument_list|(
argument|aioproclist
argument_list|)
name|list
expr_stmt|;
comment|/* List of processes */
name|struct
name|proc
modifier|*
name|aioproc
decl_stmt|;
comment|/* The AIO thread */
name|TAILQ_HEAD
argument_list|(
argument_list|,
argument|aiocblist
argument_list|)
name|jobtorun
expr_stmt|;
comment|/* suggested job to run */
block|}
struct|;
end_struct

begin_comment
comment|/*  * data-structure for lio signal management  */
end_comment

begin_struct
struct|struct
name|aio_liojob
block|{
name|int
name|lioj_flags
decl_stmt|;
name|int
name|lioj_buffer_count
decl_stmt|;
name|int
name|lioj_buffer_finished_count
decl_stmt|;
name|int
name|lioj_queue_count
decl_stmt|;
name|int
name|lioj_queue_finished_count
decl_stmt|;
name|struct
name|sigevent
name|lioj_signal
decl_stmt|;
comment|/* signal on all I/O done */
name|TAILQ_ENTRY
argument_list|(
argument|aio_liojob
argument_list|)
name|lioj_list
expr_stmt|;
name|struct
name|kaioinfo
modifier|*
name|lioj_ki
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|LIOJ_SIGNAL
value|0x1
end_define

begin_comment
comment|/* signal on all done (lio) */
end_comment

begin_define
define|#
directive|define
name|LIOJ_SIGNAL_POSTED
value|0x2
end_define

begin_comment
comment|/* signal has been posted */
end_comment

begin_comment
comment|/*  * per process aio data structure  */
end_comment

begin_struct
struct|struct
name|kaioinfo
block|{
name|int
name|kaio_flags
decl_stmt|;
comment|/* per process kaio flags */
name|int
name|kaio_maxactive_count
decl_stmt|;
comment|/* maximum number of AIOs */
name|int
name|kaio_active_count
decl_stmt|;
comment|/* number of currently used AIOs */
name|int
name|kaio_qallowed_count
decl_stmt|;
comment|/* maxiumu size of AIO queue */
name|int
name|kaio_queue_count
decl_stmt|;
comment|/* size of AIO queue */
name|int
name|kaio_ballowed_count
decl_stmt|;
comment|/* maximum number of buffers */
name|int
name|kaio_queue_finished_count
decl_stmt|;
comment|/* number of daemon jobs finished */
name|int
name|kaio_buffer_count
decl_stmt|;
comment|/* number of physio buffers */
name|int
name|kaio_buffer_finished_count
decl_stmt|;
comment|/* count of I/O done */
name|struct
name|proc
modifier|*
name|kaio_p
decl_stmt|;
comment|/* process that uses this kaio block */
name|TAILQ_HEAD
argument_list|(
argument_list|,
argument|aio_liojob
argument_list|)
name|kaio_liojoblist
expr_stmt|;
comment|/* list of lio jobs */
name|TAILQ_HEAD
argument_list|(
argument_list|,
argument|aiocblist
argument_list|)
name|kaio_jobqueue
expr_stmt|;
comment|/* job queue for process */
name|TAILQ_HEAD
argument_list|(
argument_list|,
argument|aiocblist
argument_list|)
name|kaio_jobdone
expr_stmt|;
comment|/* done queue for process */
name|TAILQ_HEAD
argument_list|(
argument_list|,
argument|aiocblist
argument_list|)
name|kaio_bufqueue
expr_stmt|;
comment|/* buffer job queue for process */
name|TAILQ_HEAD
argument_list|(
argument_list|,
argument|aiocblist
argument_list|)
name|kaio_bufdone
expr_stmt|;
comment|/* buffer done queue for process */
name|TAILQ_HEAD
argument_list|(
argument_list|,
argument|aiocblist
argument_list|)
name|kaio_sockqueue
expr_stmt|;
comment|/* queue for aios waiting on sockets */
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|KAIO_RUNDOWN
value|0x1
end_define

begin_comment
comment|/* process is being run down */
end_comment

begin_define
define|#
directive|define
name|KAIO_WAKEUP
value|0x2
end_define

begin_comment
comment|/* wakeup process when there is a significant event */
end_comment

begin_expr_stmt
specifier|static
name|TAILQ_HEAD
argument_list|(
argument_list|,
argument|aioproclist
argument_list|)
name|aio_freeproc
operator|,
name|aio_activeproc
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|TAILQ_HEAD
argument_list|(
argument_list|,
argument|aiocblist
argument_list|)
name|aio_jobs
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Async job list */
end_comment

begin_expr_stmt
specifier|static
name|TAILQ_HEAD
argument_list|(
argument_list|,
argument|aiocblist
argument_list|)
name|aio_bufjobs
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Phys I/O job list */
end_comment

begin_expr_stmt
specifier|static
name|TAILQ_HEAD
argument_list|(
argument_list|,
argument|aiocblist
argument_list|)
name|aio_freejobs
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Pool of free jobs */
end_comment

begin_function_decl
specifier|static
name|void
name|aio_init_aioinfo
parameter_list|(
name|struct
name|proc
modifier|*
name|p
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|aio_onceonly
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|aio_free_entry
parameter_list|(
name|struct
name|aiocblist
modifier|*
name|aiocbe
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|aio_process
parameter_list|(
name|struct
name|aiocblist
modifier|*
name|aiocbe
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|aio_newproc
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|aio_aqueue
parameter_list|(
name|struct
name|proc
modifier|*
name|p
parameter_list|,
name|struct
name|aiocb
modifier|*
name|job
parameter_list|,
name|int
name|type
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|aio_physwakeup
parameter_list|(
name|struct
name|buf
modifier|*
name|bp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|aio_fphysio
parameter_list|(
name|struct
name|proc
modifier|*
name|p
parameter_list|,
name|struct
name|aiocblist
modifier|*
name|aiocbe
parameter_list|,
name|int
name|type
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|aio_qphysio
parameter_list|(
name|struct
name|proc
modifier|*
name|p
parameter_list|,
name|struct
name|aiocblist
modifier|*
name|iocb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|aio_daemon
parameter_list|(
name|void
modifier|*
name|uproc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|filt_aioattach
parameter_list|(
name|struct
name|knote
modifier|*
name|kn
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|filt_aiodetach
parameter_list|(
name|struct
name|knote
modifier|*
name|kn
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|filt_aio
parameter_list|(
name|struct
name|knote
modifier|*
name|kn
parameter_list|,
name|long
name|hint
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|struct
name|filterops
name|aio_filtops
init|=
block|{
literal|0
block|,
name|filt_aioattach
block|,
name|filt_aiodetach
block|,
name|filt_aio
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSINIT
argument_list|(
name|aio
argument_list|,
name|SI_SUB_VFS
argument_list|,
name|SI_ORDER_ANY
argument_list|,
name|aio_onceonly
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|vm_zone_t
name|kaio_zone
init|=
literal|0
decl_stmt|,
name|aiop_zone
init|=
literal|0
decl_stmt|,
name|aiocb_zone
init|=
literal|0
decl_stmt|,
name|aiol_zone
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vm_zone_t
name|aiolio_zone
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Startup initialization  */
end_comment

begin_function
name|void
name|aio_onceonly
parameter_list|(
name|void
modifier|*
name|na
parameter_list|)
block|{
name|TAILQ_INIT
argument_list|(
operator|&
name|aio_freeproc
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|aio_activeproc
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|aio_jobs
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|aio_bufjobs
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|aio_freejobs
argument_list|)
expr_stmt|;
name|kaio_zone
operator|=
name|zinit
argument_list|(
literal|"AIO"
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|kaioinfo
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|aiop_zone
operator|=
name|zinit
argument_list|(
literal|"AIOP"
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|aioproclist
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|aiocb_zone
operator|=
name|zinit
argument_list|(
literal|"AIOCB"
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|aiocblist
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|aiol_zone
operator|=
name|zinit
argument_list|(
literal|"AIOL"
argument_list|,
name|AIO_LISTIO_MAX
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|aiolio_zone
operator|=
name|zinit
argument_list|(
literal|"AIOLIO"
argument_list|,
name|AIO_LISTIO_MAX
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|aio_liojob
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|aiod_timeout
operator|=
name|AIOD_TIMEOUT_DEFAULT
expr_stmt|;
name|aiod_lifetime
operator|=
name|AIOD_LIFETIME_DEFAULT
expr_stmt|;
name|jobrefid
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Init the per-process aioinfo structure.  The aioinfo limits are set  * per-process for user limit (resource) management.  */
end_comment

begin_function
name|void
name|aio_init_aioinfo
parameter_list|(
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|kaioinfo
modifier|*
name|ki
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|p_aioinfo
operator|==
name|NULL
condition|)
block|{
name|ki
operator|=
name|zalloc
argument_list|(
name|kaio_zone
argument_list|)
expr_stmt|;
name|p
operator|->
name|p_aioinfo
operator|=
name|ki
expr_stmt|;
name|ki
operator|->
name|kaio_flags
operator|=
literal|0
expr_stmt|;
name|ki
operator|->
name|kaio_maxactive_count
operator|=
name|max_aio_per_proc
expr_stmt|;
name|ki
operator|->
name|kaio_active_count
operator|=
literal|0
expr_stmt|;
name|ki
operator|->
name|kaio_qallowed_count
operator|=
name|max_aio_queue_per_proc
expr_stmt|;
name|ki
operator|->
name|kaio_queue_count
operator|=
literal|0
expr_stmt|;
name|ki
operator|->
name|kaio_ballowed_count
operator|=
name|max_buf_aio
expr_stmt|;
name|ki
operator|->
name|kaio_buffer_count
operator|=
literal|0
expr_stmt|;
name|ki
operator|->
name|kaio_buffer_finished_count
operator|=
literal|0
expr_stmt|;
name|ki
operator|->
name|kaio_p
operator|=
name|p
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|ki
operator|->
name|kaio_jobdone
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|ki
operator|->
name|kaio_jobqueue
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|ki
operator|->
name|kaio_bufdone
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|ki
operator|->
name|kaio_bufqueue
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|ki
operator|->
name|kaio_liojoblist
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|ki
operator|->
name|kaio_sockqueue
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|num_aio_procs
operator|<
name|target_aio_procs
condition|)
name|aio_newproc
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Free a job entry.  Wait for completion if it is currently active, but don't  * delay forever.  If we delay, we return a flag that says that we have to  * restart the queue scan.  */
end_comment

begin_function
name|int
name|aio_free_entry
parameter_list|(
name|struct
name|aiocblist
modifier|*
name|aiocbe
parameter_list|)
block|{
name|struct
name|kaioinfo
modifier|*
name|ki
decl_stmt|;
name|struct
name|aioproclist
modifier|*
name|aiop
decl_stmt|;
name|struct
name|aio_liojob
modifier|*
name|lj
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|s
decl_stmt|;
if|if
condition|(
name|aiocbe
operator|->
name|jobstate
operator|==
name|JOBST_NULL
condition|)
name|panic
argument_list|(
literal|"aio_free_entry: freeing already free job"
argument_list|)
expr_stmt|;
name|p
operator|=
name|aiocbe
operator|->
name|userproc
expr_stmt|;
name|ki
operator|=
name|p
operator|->
name|p_aioinfo
expr_stmt|;
name|lj
operator|=
name|aiocbe
operator|->
name|lio
expr_stmt|;
if|if
condition|(
name|ki
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"aio_free_entry: missing p->p_aioinfo"
argument_list|)
expr_stmt|;
if|if
condition|(
name|aiocbe
operator|->
name|jobstate
operator|==
name|JOBST_JOBRUNNING
condition|)
block|{
if|if
condition|(
name|aiocbe
operator|->
name|jobflags
operator|&
name|AIOCBLIST_ASYNCFREE
condition|)
return|return
literal|0
return|;
name|aiocbe
operator|->
name|jobflags
operator||=
name|AIOCBLIST_RUNDOWN
expr_stmt|;
name|tsleep
argument_list|(
name|aiocbe
argument_list|,
name|PRIBIO
operator||
name|PCATCH
argument_list|,
literal|"jobwai"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|aiocbe
operator|->
name|jobflags
operator|&=
operator|~
name|AIOCBLIST_ASYNCFREE
expr_stmt|;
if|if
condition|(
name|aiocbe
operator|->
name|bp
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|ki
operator|->
name|kaio_queue_count
operator|<=
literal|0
condition|)
name|panic
argument_list|(
literal|"aio_free_entry: process queue size<= 0"
argument_list|)
expr_stmt|;
if|if
condition|(
name|num_queue_count
operator|<=
literal|0
condition|)
name|panic
argument_list|(
literal|"aio_free_entry: system wide queue size<= 0"
argument_list|)
expr_stmt|;
if|if
condition|(
name|lj
condition|)
block|{
name|lj
operator|->
name|lioj_queue_count
operator|--
expr_stmt|;
if|if
condition|(
name|aiocbe
operator|->
name|jobflags
operator|&
name|AIOCBLIST_DONE
condition|)
name|lj
operator|->
name|lioj_queue_finished_count
operator|--
expr_stmt|;
block|}
name|ki
operator|->
name|kaio_queue_count
operator|--
expr_stmt|;
if|if
condition|(
name|aiocbe
operator|->
name|jobflags
operator|&
name|AIOCBLIST_DONE
condition|)
name|ki
operator|->
name|kaio_queue_finished_count
operator|--
expr_stmt|;
name|num_queue_count
operator|--
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|lj
condition|)
block|{
name|lj
operator|->
name|lioj_buffer_count
operator|--
expr_stmt|;
if|if
condition|(
name|aiocbe
operator|->
name|jobflags
operator|&
name|AIOCBLIST_DONE
condition|)
name|lj
operator|->
name|lioj_buffer_finished_count
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|aiocbe
operator|->
name|jobflags
operator|&
name|AIOCBLIST_DONE
condition|)
name|ki
operator|->
name|kaio_buffer_finished_count
operator|--
expr_stmt|;
name|ki
operator|->
name|kaio_buffer_count
operator|--
expr_stmt|;
name|num_buf_aio
operator|--
expr_stmt|;
block|}
comment|/* aiocbe is going away, we need to destroy any knotes */
name|knote_remove
argument_list|(
name|p
argument_list|,
operator|&
name|aiocbe
operator|->
name|klist
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ki
operator|->
name|kaio_flags
operator|&
name|KAIO_WAKEUP
operator|)
operator|||
operator|(
operator|(
name|ki
operator|->
name|kaio_flags
operator|&
name|KAIO_RUNDOWN
operator|)
operator|&&
operator|(
operator|(
name|ki
operator|->
name|kaio_buffer_count
operator|==
literal|0
operator|)
operator|&&
operator|(
name|ki
operator|->
name|kaio_queue_count
operator|==
literal|0
operator|)
operator|)
operator|)
condition|)
block|{
name|ki
operator|->
name|kaio_flags
operator|&=
operator|~
name|KAIO_WAKEUP
expr_stmt|;
name|wakeup
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|aiocbe
operator|->
name|jobstate
operator|==
name|JOBST_JOBQBUF
condition|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|aio_fphysio
argument_list|(
name|p
argument_list|,
name|aiocbe
argument_list|,
literal|1
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|error
return|;
if|if
condition|(
name|aiocbe
operator|->
name|jobstate
operator|!=
name|JOBST_JOBBFINISHED
condition|)
name|panic
argument_list|(
literal|"aio_free_entry: invalid physio finish-up state"
argument_list|)
expr_stmt|;
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|ki
operator|->
name|kaio_bufdone
argument_list|,
name|aiocbe
argument_list|,
name|plist
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|aiocbe
operator|->
name|jobstate
operator|==
name|JOBST_JOBQPROC
condition|)
block|{
name|aiop
operator|=
name|aiocbe
operator|->
name|jobaioproc
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|aiop
operator|->
name|jobtorun
argument_list|,
name|aiocbe
argument_list|,
name|list
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|aiocbe
operator|->
name|jobstate
operator|==
name|JOBST_JOBQGLOBAL
condition|)
name|TAILQ_REMOVE
argument_list|(
operator|&
name|aio_jobs
argument_list|,
name|aiocbe
argument_list|,
name|list
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|aiocbe
operator|->
name|jobstate
operator|==
name|JOBST_JOBFINISHED
condition|)
name|TAILQ_REMOVE
argument_list|(
operator|&
name|ki
operator|->
name|kaio_jobdone
argument_list|,
name|aiocbe
argument_list|,
name|plist
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|aiocbe
operator|->
name|jobstate
operator|==
name|JOBST_JOBBFINISHED
condition|)
block|{
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|ki
operator|->
name|kaio_bufdone
argument_list|,
name|aiocbe
argument_list|,
name|plist
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|aiocbe
operator|->
name|bp
condition|)
block|{
name|vunmapbuf
argument_list|(
name|aiocbe
operator|->
name|bp
argument_list|)
expr_stmt|;
name|relpbuf
argument_list|(
name|aiocbe
operator|->
name|bp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|aiocbe
operator|->
name|bp
operator|=
name|NULL
expr_stmt|;
block|}
block|}
if|if
condition|(
name|lj
operator|&&
operator|(
name|lj
operator|->
name|lioj_buffer_count
operator|==
literal|0
operator|)
operator|&&
operator|(
name|lj
operator|->
name|lioj_queue_count
operator|==
literal|0
operator|)
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|ki
operator|->
name|kaio_liojoblist
argument_list|,
name|lj
argument_list|,
name|lioj_list
argument_list|)
expr_stmt|;
name|zfree
argument_list|(
name|aiolio_zone
argument_list|,
name|lj
argument_list|)
expr_stmt|;
block|}
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|aio_freejobs
argument_list|,
name|aiocbe
argument_list|,
name|list
argument_list|)
expr_stmt|;
name|aiocbe
operator|->
name|jobstate
operator|=
name|JOBST_NULL
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Rundown the jobs for a given process.    */
end_comment

begin_function
name|void
name|aio_proc_rundown
parameter_list|(
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|int
name|s
decl_stmt|;
name|struct
name|kaioinfo
modifier|*
name|ki
decl_stmt|;
name|struct
name|aio_liojob
modifier|*
name|lj
decl_stmt|,
modifier|*
name|ljn
decl_stmt|;
name|struct
name|aiocblist
modifier|*
name|aiocbe
decl_stmt|,
modifier|*
name|aiocbn
decl_stmt|;
name|struct
name|file
modifier|*
name|fp
decl_stmt|;
name|struct
name|filedesc
modifier|*
name|fdp
decl_stmt|;
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|ki
operator|=
name|p
operator|->
name|p_aioinfo
expr_stmt|;
if|if
condition|(
name|ki
operator|==
name|NULL
condition|)
return|return;
name|ki
operator|->
name|kaio_flags
operator||=
name|LIOJ_SIGNAL_POSTED
expr_stmt|;
while|while
condition|(
operator|(
name|ki
operator|->
name|kaio_active_count
operator|>
literal|0
operator|)
operator|||
operator|(
name|ki
operator|->
name|kaio_buffer_count
operator|>
name|ki
operator|->
name|kaio_buffer_finished_count
operator|)
condition|)
block|{
name|ki
operator|->
name|kaio_flags
operator||=
name|KAIO_RUNDOWN
expr_stmt|;
if|if
condition|(
name|tsleep
argument_list|(
name|p
argument_list|,
name|PRIBIO
argument_list|,
literal|"kaiowt"
argument_list|,
name|aiod_timeout
argument_list|)
condition|)
break|break;
block|}
comment|/* 	 * Move any aio ops that are waiting on socket I/O to the normal job 	 * queues so they are cleaned up with any others. 	 */
name|fdp
operator|=
name|p
operator|->
name|p_fd
expr_stmt|;
name|s
operator|=
name|splnet
argument_list|()
expr_stmt|;
for|for
control|(
name|aiocbe
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|ki
operator|->
name|kaio_sockqueue
argument_list|)
init|;
name|aiocbe
condition|;
name|aiocbe
operator|=
name|aiocbn
control|)
block|{
name|aiocbn
operator|=
name|TAILQ_NEXT
argument_list|(
name|aiocbe
argument_list|,
name|plist
argument_list|)
expr_stmt|;
name|fp
operator|=
name|fdp
operator|->
name|fd_ofiles
index|[
name|aiocbe
operator|->
name|uaiocb
operator|.
name|aio_fildes
index|]
expr_stmt|;
comment|/* 		 * Under some circumstances, the aio_fildes and the file 		 * structure don't match.  This would leave aiocbe's in the 		 * TAILQ associated with the socket and cause a panic later. 		 *  		 * Detect and fix. 		 */
if|if
condition|(
operator|(
name|fp
operator|==
name|NULL
operator|)
operator|||
operator|(
name|fp
operator|!=
name|aiocbe
operator|->
name|fd_file
operator|)
condition|)
name|fp
operator|=
name|aiocbe
operator|->
name|fd_file
expr_stmt|;
if|if
condition|(
name|fp
condition|)
block|{
name|so
operator|=
operator|(
expr|struct
name|socket
operator|*
operator|)
name|fp
operator|->
name|f_data
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|so
operator|->
name|so_aiojobq
argument_list|,
name|aiocbe
argument_list|,
name|list
argument_list|)
expr_stmt|;
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|so
operator|->
name|so_aiojobq
argument_list|)
condition|)
block|{
name|so
operator|->
name|so_snd
operator|.
name|sb_flags
operator|&=
operator|~
name|SB_AIO
expr_stmt|;
name|so
operator|->
name|so_rcv
operator|.
name|sb_flags
operator|&=
operator|~
name|SB_AIO
expr_stmt|;
block|}
block|}
name|TAILQ_REMOVE
argument_list|(
operator|&
name|ki
operator|->
name|kaio_sockqueue
argument_list|,
name|aiocbe
argument_list|,
name|plist
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|aio_jobs
argument_list|,
name|aiocbe
argument_list|,
name|list
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|ki
operator|->
name|kaio_jobqueue
argument_list|,
name|aiocbe
argument_list|,
name|plist
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|restart1
label|:
for|for
control|(
name|aiocbe
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|ki
operator|->
name|kaio_jobdone
argument_list|)
init|;
name|aiocbe
condition|;
name|aiocbe
operator|=
name|aiocbn
control|)
block|{
name|aiocbn
operator|=
name|TAILQ_NEXT
argument_list|(
name|aiocbe
argument_list|,
name|plist
argument_list|)
expr_stmt|;
if|if
condition|(
name|aio_free_entry
argument_list|(
name|aiocbe
argument_list|)
condition|)
goto|goto
name|restart1
goto|;
block|}
name|restart2
label|:
for|for
control|(
name|aiocbe
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|ki
operator|->
name|kaio_jobqueue
argument_list|)
init|;
name|aiocbe
condition|;
name|aiocbe
operator|=
name|aiocbn
control|)
block|{
name|aiocbn
operator|=
name|TAILQ_NEXT
argument_list|(
name|aiocbe
argument_list|,
name|plist
argument_list|)
expr_stmt|;
if|if
condition|(
name|aio_free_entry
argument_list|(
name|aiocbe
argument_list|)
condition|)
goto|goto
name|restart2
goto|;
block|}
comment|/*  * Note the use of lots of splbio here, trying to avoid splbio for long chains  * of I/O.  Probably unnecessary.  */
name|restart3
label|:
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
while|while
condition|(
name|TAILQ_FIRST
argument_list|(
operator|&
name|ki
operator|->
name|kaio_bufqueue
argument_list|)
condition|)
block|{
name|ki
operator|->
name|kaio_flags
operator||=
name|KAIO_WAKEUP
expr_stmt|;
name|tsleep
argument_list|(
name|p
argument_list|,
name|PRIBIO
argument_list|,
literal|"aioprn"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
goto|goto
name|restart3
goto|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|restart4
label|:
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
for|for
control|(
name|aiocbe
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|ki
operator|->
name|kaio_bufdone
argument_list|)
init|;
name|aiocbe
condition|;
name|aiocbe
operator|=
name|aiocbn
control|)
block|{
name|aiocbn
operator|=
name|TAILQ_NEXT
argument_list|(
name|aiocbe
argument_list|,
name|plist
argument_list|)
expr_stmt|;
if|if
condition|(
name|aio_free_entry
argument_list|(
name|aiocbe
argument_list|)
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
goto|goto
name|restart4
goto|;
block|}
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
for|for
control|(
name|lj
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|ki
operator|->
name|kaio_liojoblist
argument_list|)
init|;
name|lj
condition|;
name|lj
operator|=
name|ljn
control|)
block|{
name|ljn
operator|=
name|TAILQ_NEXT
argument_list|(
name|lj
argument_list|,
name|lioj_list
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|lj
operator|->
name|lioj_buffer_count
operator|==
literal|0
operator|)
operator|&&
operator|(
name|lj
operator|->
name|lioj_queue_count
operator|==
literal|0
operator|)
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|ki
operator|->
name|kaio_liojoblist
argument_list|,
name|lj
argument_list|,
name|lioj_list
argument_list|)
expr_stmt|;
name|zfree
argument_list|(
name|aiolio_zone
argument_list|,
name|lj
argument_list|)
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|DIAGNOSTIC
name|printf
argument_list|(
literal|"LIO job not cleaned up: B:%d, BF:%d, Q:%d, "
literal|"QF:%d\n"
argument_list|,
name|lj
operator|->
name|lioj_buffer_count
argument_list|,
name|lj
operator|->
name|lioj_buffer_finished_count
argument_list|,
name|lj
operator|->
name|lioj_queue_count
argument_list|,
name|lj
operator|->
name|lioj_queue_finished_count
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
name|zfree
argument_list|(
name|kaio_zone
argument_list|,
name|ki
argument_list|)
expr_stmt|;
name|p
operator|->
name|p_aioinfo
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Select a job to run (called by an AIO daemon).  */
end_comment

begin_function
specifier|static
name|struct
name|aiocblist
modifier|*
name|aio_selectjob
parameter_list|(
name|struct
name|aioproclist
modifier|*
name|aiop
parameter_list|)
block|{
name|int
name|s
decl_stmt|;
name|struct
name|aiocblist
modifier|*
name|aiocbe
decl_stmt|;
name|struct
name|kaioinfo
modifier|*
name|ki
decl_stmt|;
name|struct
name|proc
modifier|*
name|userp
decl_stmt|;
name|aiocbe
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|aiop
operator|->
name|jobtorun
argument_list|)
expr_stmt|;
if|if
condition|(
name|aiocbe
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|aiop
operator|->
name|jobtorun
argument_list|,
name|aiocbe
argument_list|,
name|list
argument_list|)
expr_stmt|;
return|return
name|aiocbe
return|;
block|}
name|s
operator|=
name|splnet
argument_list|()
expr_stmt|;
for|for
control|(
name|aiocbe
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|aio_jobs
argument_list|)
init|;
name|aiocbe
condition|;
name|aiocbe
operator|=
name|TAILQ_NEXT
argument_list|(
name|aiocbe
argument_list|,
name|list
argument_list|)
control|)
block|{
name|userp
operator|=
name|aiocbe
operator|->
name|userproc
expr_stmt|;
name|ki
operator|=
name|userp
operator|->
name|p_aioinfo
expr_stmt|;
if|if
condition|(
name|ki
operator|->
name|kaio_active_count
operator|<
name|ki
operator|->
name|kaio_maxactive_count
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|aio_jobs
argument_list|,
name|aiocbe
argument_list|,
name|list
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|aiocbe
return|;
block|}
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/*  * The AIO processing activity.  This is the code that does the I/O request for  * the non-physio version of the operations.  The normal vn operations are used,  * and this code should work in all instances for every type of file, including  * pipes, sockets, fifos, and regular files.  */
end_comment

begin_function
name|void
name|aio_process
parameter_list|(
name|struct
name|aiocblist
modifier|*
name|aiocbe
parameter_list|)
block|{
name|struct
name|filedesc
modifier|*
name|fdp
decl_stmt|;
name|struct
name|proc
modifier|*
name|userp
decl_stmt|,
modifier|*
name|mycp
decl_stmt|;
name|struct
name|aiocb
modifier|*
name|cb
decl_stmt|;
name|struct
name|file
modifier|*
name|fp
decl_stmt|;
name|struct
name|uio
name|auio
decl_stmt|;
name|struct
name|iovec
name|aiov
decl_stmt|;
name|unsigned
name|int
name|fd
decl_stmt|;
name|int
name|cnt
decl_stmt|;
name|int
name|error
decl_stmt|;
name|off_t
name|offset
decl_stmt|;
name|int
name|oublock_st
decl_stmt|,
name|oublock_end
decl_stmt|;
name|int
name|inblock_st
decl_stmt|,
name|inblock_end
decl_stmt|;
name|userp
operator|=
name|aiocbe
operator|->
name|userproc
expr_stmt|;
name|cb
operator|=
operator|&
name|aiocbe
operator|->
name|uaiocb
expr_stmt|;
name|mycp
operator|=
name|curproc
expr_stmt|;
name|fdp
operator|=
name|mycp
operator|->
name|p_fd
expr_stmt|;
name|fd
operator|=
name|cb
operator|->
name|aio_fildes
expr_stmt|;
name|fp
operator|=
name|fdp
operator|->
name|fd_ofiles
index|[
name|fd
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|fp
operator|==
name|NULL
operator|)
operator|||
operator|(
name|fp
operator|!=
name|aiocbe
operator|->
name|fd_file
operator|)
condition|)
block|{
name|cb
operator|->
name|_aiocb_private
operator|.
name|error
operator|=
name|EBADF
expr_stmt|;
name|cb
operator|->
name|_aiocb_private
operator|.
name|status
operator|=
operator|-
literal|1
expr_stmt|;
return|return;
block|}
name|aiov
operator|.
name|iov_base
operator|=
operator|(
name|void
operator|*
operator|)
name|cb
operator|->
name|aio_buf
expr_stmt|;
name|aiov
operator|.
name|iov_len
operator|=
name|cb
operator|->
name|aio_nbytes
expr_stmt|;
name|auio
operator|.
name|uio_iov
operator|=
operator|&
name|aiov
expr_stmt|;
name|auio
operator|.
name|uio_iovcnt
operator|=
literal|1
expr_stmt|;
name|auio
operator|.
name|uio_offset
operator|=
name|offset
operator|=
name|cb
operator|->
name|aio_offset
expr_stmt|;
name|auio
operator|.
name|uio_resid
operator|=
name|cb
operator|->
name|aio_nbytes
expr_stmt|;
name|cnt
operator|=
name|cb
operator|->
name|aio_nbytes
expr_stmt|;
name|auio
operator|.
name|uio_segflg
operator|=
name|UIO_USERSPACE
expr_stmt|;
name|auio
operator|.
name|uio_procp
operator|=
name|mycp
expr_stmt|;
name|inblock_st
operator|=
name|mycp
operator|->
name|p_stats
operator|->
name|p_ru
operator|.
name|ru_inblock
expr_stmt|;
name|oublock_st
operator|=
name|mycp
operator|->
name|p_stats
operator|->
name|p_ru
operator|.
name|ru_oublock
expr_stmt|;
if|if
condition|(
name|cb
operator|->
name|aio_lio_opcode
operator|==
name|LIO_READ
condition|)
block|{
name|auio
operator|.
name|uio_rw
operator|=
name|UIO_READ
expr_stmt|;
name|error
operator|=
name|fo_read
argument_list|(
name|fp
argument_list|,
operator|&
name|auio
argument_list|,
name|fp
operator|->
name|f_cred
argument_list|,
name|FOF_OFFSET
argument_list|,
name|mycp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|auio
operator|.
name|uio_rw
operator|=
name|UIO_WRITE
expr_stmt|;
name|error
operator|=
name|fo_write
argument_list|(
name|fp
argument_list|,
operator|&
name|auio
argument_list|,
name|fp
operator|->
name|f_cred
argument_list|,
name|FOF_OFFSET
argument_list|,
name|mycp
argument_list|)
expr_stmt|;
block|}
name|inblock_end
operator|=
name|mycp
operator|->
name|p_stats
operator|->
name|p_ru
operator|.
name|ru_inblock
expr_stmt|;
name|oublock_end
operator|=
name|mycp
operator|->
name|p_stats
operator|->
name|p_ru
operator|.
name|ru_oublock
expr_stmt|;
name|aiocbe
operator|->
name|inputcharge
operator|=
name|inblock_end
operator|-
name|inblock_st
expr_stmt|;
name|aiocbe
operator|->
name|outputcharge
operator|=
name|oublock_end
operator|-
name|oublock_st
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|)
operator|&&
operator|(
name|auio
operator|.
name|uio_resid
operator|!=
name|cnt
operator|)
condition|)
block|{
if|if
condition|(
name|error
operator|==
name|ERESTART
operator|||
name|error
operator|==
name|EINTR
operator|||
name|error
operator|==
name|EWOULDBLOCK
condition|)
name|error
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|==
name|EPIPE
operator|)
operator|&&
operator|(
name|cb
operator|->
name|aio_lio_opcode
operator|==
name|LIO_WRITE
operator|)
condition|)
name|psignal
argument_list|(
name|userp
argument_list|,
name|SIGPIPE
argument_list|)
expr_stmt|;
block|}
name|cnt
operator|-=
name|auio
operator|.
name|uio_resid
expr_stmt|;
name|cb
operator|->
name|_aiocb_private
operator|.
name|error
operator|=
name|error
expr_stmt|;
name|cb
operator|->
name|_aiocb_private
operator|.
name|status
operator|=
name|cnt
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * The AIO daemon, most of the actual work is done in aio_process,  * but the setup (and address space mgmt) is done in this routine.  */
end_comment

begin_function
specifier|static
name|void
name|aio_daemon
parameter_list|(
name|void
modifier|*
name|uproc
parameter_list|)
block|{
name|int
name|s
decl_stmt|;
name|struct
name|aio_liojob
modifier|*
name|lj
decl_stmt|;
name|struct
name|aiocb
modifier|*
name|cb
decl_stmt|;
name|struct
name|aiocblist
modifier|*
name|aiocbe
decl_stmt|;
name|struct
name|aioproclist
modifier|*
name|aiop
decl_stmt|;
name|struct
name|kaioinfo
modifier|*
name|ki
decl_stmt|;
name|struct
name|proc
modifier|*
name|curcp
decl_stmt|,
modifier|*
name|mycp
decl_stmt|,
modifier|*
name|userp
decl_stmt|;
name|struct
name|vmspace
modifier|*
name|myvm
decl_stmt|,
modifier|*
name|tmpvm
decl_stmt|;
comment|/* 	 * Local copies of curproc (cp) and vmspace (myvm) 	 */
name|mycp
operator|=
name|curproc
expr_stmt|;
name|myvm
operator|=
name|mycp
operator|->
name|p_vmspace
expr_stmt|;
if|if
condition|(
name|mycp
operator|->
name|p_textvp
condition|)
block|{
name|vrele
argument_list|(
name|mycp
operator|->
name|p_textvp
argument_list|)
expr_stmt|;
name|mycp
operator|->
name|p_textvp
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* 	 * Allocate and ready the aio control info.  There is one aiop structure 	 * per daemon. 	 */
name|aiop
operator|=
name|zalloc
argument_list|(
name|aiop_zone
argument_list|)
expr_stmt|;
name|aiop
operator|->
name|aioproc
operator|=
name|mycp
expr_stmt|;
name|aiop
operator|->
name|aioprocflags
operator||=
name|AIOP_FREE
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|aiop
operator|->
name|jobtorun
argument_list|)
expr_stmt|;
name|s
operator|=
name|splnet
argument_list|()
expr_stmt|;
comment|/* 	 * Place thread (lightweight process) onto the AIO free thread list. 	 */
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|aio_freeproc
argument_list|)
condition|)
name|wakeup
argument_list|(
operator|&
name|aio_freeproc
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|aio_freeproc
argument_list|,
name|aiop
argument_list|,
name|list
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* Make up a name for the daemon. */
name|strcpy
argument_list|(
name|mycp
operator|->
name|p_comm
argument_list|,
literal|"aiod"
argument_list|)
expr_stmt|;
comment|/* 	 * Get rid of our current filedescriptors.  AIOD's don't need any 	 * filedescriptors, except as temporarily inherited from the client. 	 * Credentials are also cloned, and made equivalent to "root". 	 */
name|fdfree
argument_list|(
name|mycp
argument_list|)
expr_stmt|;
name|mycp
operator|->
name|p_fd
operator|=
name|NULL
expr_stmt|;
name|mycp
operator|->
name|p_ucred
operator|=
name|crcopy
argument_list|(
name|mycp
operator|->
name|p_ucred
argument_list|)
expr_stmt|;
name|mycp
operator|->
name|p_ucred
operator|->
name|cr_uid
operator|=
literal|0
expr_stmt|;
name|mycp
operator|->
name|p_ucred
operator|->
name|cr_ngroups
operator|=
literal|1
expr_stmt|;
name|mycp
operator|->
name|p_ucred
operator|->
name|cr_groups
index|[
literal|0
index|]
operator|=
literal|1
expr_stmt|;
comment|/* The daemon resides in its own pgrp. */
name|enterpgrp
argument_list|(
name|mycp
argument_list|,
name|mycp
operator|->
name|p_pid
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Mark special process type. */
name|mycp
operator|->
name|p_flag
operator||=
name|P_SYSTEM
operator||
name|P_KTHREADP
expr_stmt|;
comment|/* 	 * Wakeup parent process.  (Parent sleeps to keep from blasting away 	 * creating to many daemons.) 	 */
name|wakeup
argument_list|(
name|mycp
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* 		 * curcp is the current daemon process context. 		 * userp is the current user process context. 		 */
name|curcp
operator|=
name|mycp
expr_stmt|;
comment|/* 		 * Take daemon off of free queue 		 */
if|if
condition|(
name|aiop
operator|->
name|aioprocflags
operator|&
name|AIOP_FREE
condition|)
block|{
name|s
operator|=
name|splnet
argument_list|()
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|aio_freeproc
argument_list|,
name|aiop
argument_list|,
name|list
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|aio_activeproc
argument_list|,
name|aiop
argument_list|,
name|list
argument_list|)
expr_stmt|;
name|aiop
operator|->
name|aioprocflags
operator|&=
operator|~
name|AIOP_FREE
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
name|aiop
operator|->
name|aioprocflags
operator|&=
operator|~
name|AIOP_SCHED
expr_stmt|;
comment|/* 		 * Check for jobs. 		 */
while|while
condition|(
operator|(
name|aiocbe
operator|=
name|aio_selectjob
argument_list|(
name|aiop
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|cb
operator|=
operator|&
name|aiocbe
operator|->
name|uaiocb
expr_stmt|;
name|userp
operator|=
name|aiocbe
operator|->
name|userproc
expr_stmt|;
name|aiocbe
operator|->
name|jobstate
operator|=
name|JOBST_JOBRUNNING
expr_stmt|;
comment|/* 			 * Connect to process address space for user program. 			 */
if|if
condition|(
name|userp
operator|!=
name|curcp
condition|)
block|{
comment|/* 				 * Save the current address space that we are 				 * connected to. 				 */
name|tmpvm
operator|=
name|mycp
operator|->
name|p_vmspace
expr_stmt|;
comment|/* 				 * Point to the new user address space, and 				 * refer to it. 				 */
name|mycp
operator|->
name|p_vmspace
operator|=
name|userp
operator|->
name|p_vmspace
expr_stmt|;
name|mycp
operator|->
name|p_vmspace
operator|->
name|vm_refcnt
operator|++
expr_stmt|;
comment|/* Activate the new mapping. */
name|pmap_activate
argument_list|(
name|mycp
argument_list|)
expr_stmt|;
comment|/* 				 * If the old address space wasn't the daemons 				 * own address space, then we need to remove the 				 * daemon's reference from the other process 				 * that it was acting on behalf of. 				 */
if|if
condition|(
name|tmpvm
operator|!=
name|myvm
condition|)
block|{
name|vmspace_free
argument_list|(
name|tmpvm
argument_list|)
expr_stmt|;
block|}
comment|/* 				 * Disassociate from previous clients file 				 * descriptors, and associate to the new clients 				 * descriptors.  Note that the daemon doesn't 				 * need to worry about its orginal descriptors, 				 * because they were originally freed. 				 */
if|if
condition|(
name|mycp
operator|->
name|p_fd
condition|)
name|fdfree
argument_list|(
name|mycp
argument_list|)
expr_stmt|;
name|mycp
operator|->
name|p_fd
operator|=
name|fdshare
argument_list|(
name|userp
argument_list|)
expr_stmt|;
name|curcp
operator|=
name|userp
expr_stmt|;
block|}
name|ki
operator|=
name|userp
operator|->
name|p_aioinfo
expr_stmt|;
name|lj
operator|=
name|aiocbe
operator|->
name|lio
expr_stmt|;
comment|/* Account for currently active jobs. */
name|ki
operator|->
name|kaio_active_count
operator|++
expr_stmt|;
comment|/* Do the I/O function. */
name|aiocbe
operator|->
name|jobaioproc
operator|=
name|aiop
expr_stmt|;
name|aio_process
argument_list|(
name|aiocbe
argument_list|)
expr_stmt|;
comment|/* Decrement the active job count. */
name|ki
operator|->
name|kaio_active_count
operator|--
expr_stmt|;
comment|/* 			 * Increment the completion count for wakeup/signal 			 * comparisons. 			 */
name|aiocbe
operator|->
name|jobflags
operator||=
name|AIOCBLIST_DONE
expr_stmt|;
name|ki
operator|->
name|kaio_queue_finished_count
operator|++
expr_stmt|;
if|if
condition|(
name|lj
condition|)
name|lj
operator|->
name|lioj_queue_finished_count
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|ki
operator|->
name|kaio_flags
operator|&
name|KAIO_WAKEUP
operator|)
operator|||
operator|(
operator|(
name|ki
operator|->
name|kaio_flags
operator|&
name|KAIO_RUNDOWN
operator|)
operator|&&
operator|(
name|ki
operator|->
name|kaio_active_count
operator|==
literal|0
operator|)
operator|)
condition|)
block|{
name|ki
operator|->
name|kaio_flags
operator|&=
operator|~
name|KAIO_WAKEUP
expr_stmt|;
name|wakeup
argument_list|(
name|userp
argument_list|)
expr_stmt|;
block|}
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
if|if
condition|(
name|lj
operator|&&
operator|(
name|lj
operator|->
name|lioj_flags
operator|&
operator|(
name|LIOJ_SIGNAL
operator||
name|LIOJ_SIGNAL_POSTED
operator|)
operator|)
operator|==
name|LIOJ_SIGNAL
condition|)
block|{
if|if
condition|(
operator|(
name|lj
operator|->
name|lioj_queue_finished_count
operator|==
name|lj
operator|->
name|lioj_queue_count
operator|)
operator|&&
operator|(
name|lj
operator|->
name|lioj_buffer_finished_count
operator|==
name|lj
operator|->
name|lioj_buffer_count
operator|)
condition|)
block|{
name|psignal
argument_list|(
name|userp
argument_list|,
name|lj
operator|->
name|lioj_signal
operator|.
name|sigev_signo
argument_list|)
expr_stmt|;
name|lj
operator|->
name|lioj_flags
operator||=
name|LIOJ_SIGNAL_POSTED
expr_stmt|;
block|}
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|aiocbe
operator|->
name|jobstate
operator|=
name|JOBST_JOBFINISHED
expr_stmt|;
comment|/* 			 * If the I/O request should be automatically rundown, 			 * do the needed cleanup.  Otherwise, place the queue 			 * entry for the just finished I/O request into the done 			 * queue for the associated client. 			 */
name|s
operator|=
name|splnet
argument_list|()
expr_stmt|;
if|if
condition|(
name|aiocbe
operator|->
name|jobflags
operator|&
name|AIOCBLIST_ASYNCFREE
condition|)
block|{
name|aiocbe
operator|->
name|jobflags
operator|&=
operator|~
name|AIOCBLIST_ASYNCFREE
expr_stmt|;
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|aio_freejobs
argument_list|,
name|aiocbe
argument_list|,
name|list
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|ki
operator|->
name|kaio_jobqueue
argument_list|,
name|aiocbe
argument_list|,
name|plist
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|ki
operator|->
name|kaio_jobdone
argument_list|,
name|aiocbe
argument_list|,
name|plist
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|KNOTE
argument_list|(
operator|&
name|aiocbe
operator|->
name|klist
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|aiocbe
operator|->
name|jobflags
operator|&
name|AIOCBLIST_RUNDOWN
condition|)
block|{
name|wakeup
argument_list|(
name|aiocbe
argument_list|)
expr_stmt|;
name|aiocbe
operator|->
name|jobflags
operator|&=
operator|~
name|AIOCBLIST_RUNDOWN
expr_stmt|;
block|}
if|if
condition|(
name|cb
operator|->
name|aio_sigevent
operator|.
name|sigev_notify
operator|==
name|SIGEV_SIGNAL
condition|)
block|{
name|psignal
argument_list|(
name|userp
argument_list|,
name|cb
operator|->
name|aio_sigevent
operator|.
name|sigev_signo
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 		 * Disconnect from user address space. 		 */
if|if
condition|(
name|curcp
operator|!=
name|mycp
condition|)
block|{
comment|/* Get the user address space to disconnect from. */
name|tmpvm
operator|=
name|mycp
operator|->
name|p_vmspace
expr_stmt|;
comment|/* Get original address space for daemon. */
name|mycp
operator|->
name|p_vmspace
operator|=
name|myvm
expr_stmt|;
comment|/* Activate the daemon's address space. */
name|pmap_activate
argument_list|(
name|mycp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
name|tmpvm
operator|==
name|myvm
condition|)
block|{
name|printf
argument_list|(
literal|"AIOD: vmspace problem -- %d\n"
argument_list|,
name|mycp
operator|->
name|p_pid
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Remove our vmspace reference. */
name|vmspace_free
argument_list|(
name|tmpvm
argument_list|)
expr_stmt|;
comment|/* 			 * Disassociate from the user process's file 			 * descriptors. 			 */
if|if
condition|(
name|mycp
operator|->
name|p_fd
condition|)
name|fdfree
argument_list|(
name|mycp
argument_list|)
expr_stmt|;
name|mycp
operator|->
name|p_fd
operator|=
name|NULL
expr_stmt|;
name|curcp
operator|=
name|mycp
expr_stmt|;
block|}
comment|/* 		 * If we are the first to be put onto the free queue, wakeup 		 * anyone waiting for a daemon. 		 */
name|s
operator|=
name|splnet
argument_list|()
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|aio_activeproc
argument_list|,
name|aiop
argument_list|,
name|list
argument_list|)
expr_stmt|;
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|aio_freeproc
argument_list|)
condition|)
name|wakeup
argument_list|(
operator|&
name|aio_freeproc
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|aio_freeproc
argument_list|,
name|aiop
argument_list|,
name|list
argument_list|)
expr_stmt|;
name|aiop
operator|->
name|aioprocflags
operator||=
name|AIOP_FREE
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* 		 * If daemon is inactive for a long time, allow it to exit, 		 * thereby freeing resources. 		 */
if|if
condition|(
operator|(
operator|(
name|aiop
operator|->
name|aioprocflags
operator|&
name|AIOP_SCHED
operator|)
operator|==
literal|0
operator|)
operator|&&
name|tsleep
argument_list|(
name|mycp
argument_list|,
name|PRIBIO
argument_list|,
literal|"aiordy"
argument_list|,
name|aiod_lifetime
argument_list|)
condition|)
block|{
name|s
operator|=
name|splnet
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|TAILQ_FIRST
argument_list|(
operator|&
name|aio_jobs
argument_list|)
operator|==
name|NULL
operator|)
operator|&&
operator|(
name|TAILQ_FIRST
argument_list|(
operator|&
name|aiop
operator|->
name|jobtorun
argument_list|)
operator|==
name|NULL
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|aiop
operator|->
name|aioprocflags
operator|&
name|AIOP_FREE
operator|)
operator|&&
operator|(
name|num_aio_procs
operator|>
name|target_aio_procs
operator|)
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|aio_freeproc
argument_list|,
name|aiop
argument_list|,
name|list
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|zfree
argument_list|(
name|aiop_zone
argument_list|,
name|aiop
argument_list|)
expr_stmt|;
name|num_aio_procs
operator|--
expr_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
name|mycp
operator|->
name|p_vmspace
operator|->
name|vm_refcnt
operator|<=
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"AIOD: bad vm refcnt for"
literal|" exiting daemon: %d\n"
argument_list|,
name|mycp
operator|->
name|p_vmspace
operator|->
name|vm_refcnt
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|exit1
argument_list|(
name|mycp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Create a new AIO daemon.  This is mostly a kernel-thread fork routine.  The  * AIO daemon modifies its environment itself.  */
end_comment

begin_function
specifier|static
name|int
name|aio_newproc
parameter_list|()
block|{
name|int
name|error
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|,
modifier|*
name|np
decl_stmt|;
name|p
operator|=
operator|&
name|proc0
expr_stmt|;
name|error
operator|=
name|fork1
argument_list|(
name|p
argument_list|,
name|RFPROC
operator||
name|RFMEM
operator||
name|RFNOWAIT
argument_list|,
operator|&
name|np
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
name|cpu_set_fork_handler
argument_list|(
name|np
argument_list|,
name|aio_daemon
argument_list|,
name|curproc
argument_list|)
expr_stmt|;
comment|/* 	 * Wait until daemon is started, but continue on just in case to 	 * handle error conditions. 	 */
name|error
operator|=
name|tsleep
argument_list|(
name|np
argument_list|,
name|PZERO
argument_list|,
literal|"aiosta"
argument_list|,
name|aiod_timeout
argument_list|)
expr_stmt|;
name|num_aio_procs
operator|++
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  * Try the high-performance physio method for eligible VCHR devices.  This  * routine doesn't require the use of any additional threads, and have overhead.  */
end_comment

begin_function
name|int
name|aio_qphysio
parameter_list|(
name|struct
name|proc
modifier|*
name|p
parameter_list|,
name|struct
name|aiocblist
modifier|*
name|aiocbe
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|struct
name|aiocb
modifier|*
name|cb
decl_stmt|;
name|struct
name|file
modifier|*
name|fp
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|struct
name|kaioinfo
modifier|*
name|ki
decl_stmt|;
name|struct
name|filedesc
modifier|*
name|fdp
decl_stmt|;
name|struct
name|aio_liojob
modifier|*
name|lj
decl_stmt|;
name|int
name|fd
decl_stmt|;
name|int
name|s
decl_stmt|;
name|int
name|cnt
decl_stmt|,
name|notify
decl_stmt|;
name|cb
operator|=
operator|&
name|aiocbe
operator|->
name|uaiocb
expr_stmt|;
name|fdp
operator|=
name|p
operator|->
name|p_fd
expr_stmt|;
name|fd
operator|=
name|cb
operator|->
name|aio_fildes
expr_stmt|;
name|fp
operator|=
name|fdp
operator|->
name|fd_ofiles
index|[
name|fd
index|]
expr_stmt|;
if|if
condition|(
name|fp
operator|->
name|f_type
operator|!=
name|DTYPE_VNODE
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|vp
operator|=
operator|(
expr|struct
name|vnode
operator|*
operator|)
name|fp
operator|->
name|f_data
expr_stmt|;
comment|/* 	 * If its not a disk, we don't want to return a positive error. 	 * It causes the aio code to not fall through to try the thread 	 * way when you're talking to a regular file. 	 */
if|if
condition|(
operator|!
name|vn_isdisk
argument_list|(
name|vp
argument_list|,
operator|&
name|error
argument_list|)
condition|)
block|{
if|if
condition|(
name|error
operator|==
name|ENOTBLK
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
else|else
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
name|cb
operator|->
name|aio_nbytes
operator|%
name|vp
operator|->
name|v_rdev
operator|->
name|si_bsize_phys
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
operator|(
name|cb
operator|->
name|aio_nbytes
operator|>
name|MAXPHYS
operator|)
operator|&&
operator|(
name|num_buf_aio
operator|>=
name|max_buf_aio
operator|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|ki
operator|=
name|p
operator|->
name|p_aioinfo
expr_stmt|;
if|if
condition|(
name|ki
operator|->
name|kaio_buffer_count
operator|>=
name|ki
operator|->
name|kaio_ballowed_count
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|cnt
operator|=
name|cb
operator|->
name|aio_nbytes
expr_stmt|;
if|if
condition|(
name|cnt
operator|>
name|MAXPHYS
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* 	 * Physical I/O is charged directly to the process, so we don't have to 	 * fake it. 	 */
name|aiocbe
operator|->
name|inputcharge
operator|=
literal|0
expr_stmt|;
name|aiocbe
operator|->
name|outputcharge
operator|=
literal|0
expr_stmt|;
name|ki
operator|->
name|kaio_buffer_count
operator|++
expr_stmt|;
name|lj
operator|=
name|aiocbe
operator|->
name|lio
expr_stmt|;
if|if
condition|(
name|lj
condition|)
name|lj
operator|->
name|lioj_buffer_count
operator|++
expr_stmt|;
comment|/* Create and build a buffer header for a transfer. */
name|bp
operator|=
operator|(
expr|struct
name|buf
operator|*
operator|)
name|getpbuf
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
comment|/* 	 * Get a copy of the kva from the physical buffer. 	 */
name|bp
operator|->
name|b_caller1
operator|=
name|p
expr_stmt|;
name|bp
operator|->
name|b_dev
operator|=
name|vp
operator|->
name|v_rdev
expr_stmt|;
name|error
operator|=
name|bp
operator|->
name|b_error
operator|=
literal|0
expr_stmt|;
name|bp
operator|->
name|b_bcount
operator|=
name|cb
operator|->
name|aio_nbytes
expr_stmt|;
name|bp
operator|->
name|b_bufsize
operator|=
name|cb
operator|->
name|aio_nbytes
expr_stmt|;
name|bp
operator|->
name|b_flags
operator|=
name|B_PHYS
expr_stmt|;
name|bp
operator|->
name|b_iodone
operator|=
name|aio_physwakeup
expr_stmt|;
name|bp
operator|->
name|b_saveaddr
operator|=
name|bp
operator|->
name|b_data
expr_stmt|;
name|bp
operator|->
name|b_data
operator|=
operator|(
name|void
operator|*
operator|)
name|cb
operator|->
name|aio_buf
expr_stmt|;
name|bp
operator|->
name|b_blkno
operator|=
name|btodb
argument_list|(
name|cb
operator|->
name|aio_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|cb
operator|->
name|aio_lio_opcode
operator|==
name|LIO_WRITE
condition|)
block|{
name|bp
operator|->
name|b_iocmd
operator|=
name|BIO_WRITE
expr_stmt|;
if|if
condition|(
operator|!
name|useracc
argument_list|(
name|bp
operator|->
name|b_data
argument_list|,
name|bp
operator|->
name|b_bufsize
argument_list|,
name|VM_PROT_READ
argument_list|)
condition|)
block|{
name|error
operator|=
name|EFAULT
expr_stmt|;
goto|goto
name|doerror
goto|;
block|}
block|}
else|else
block|{
name|bp
operator|->
name|b_iocmd
operator|=
name|BIO_READ
expr_stmt|;
if|if
condition|(
operator|!
name|useracc
argument_list|(
name|bp
operator|->
name|b_data
argument_list|,
name|bp
operator|->
name|b_bufsize
argument_list|,
name|VM_PROT_WRITE
argument_list|)
condition|)
block|{
name|error
operator|=
name|EFAULT
expr_stmt|;
goto|goto
name|doerror
goto|;
block|}
block|}
comment|/* Bring buffer into kernel space. */
name|vmapbuf
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
name|aiocbe
operator|->
name|bp
operator|=
name|bp
expr_stmt|;
name|bp
operator|->
name|b_spc
operator|=
operator|(
name|void
operator|*
operator|)
name|aiocbe
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|aio_bufjobs
argument_list|,
name|aiocbe
argument_list|,
name|list
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|ki
operator|->
name|kaio_bufqueue
argument_list|,
name|aiocbe
argument_list|,
name|plist
argument_list|)
expr_stmt|;
name|aiocbe
operator|->
name|jobstate
operator|=
name|JOBST_JOBQBUF
expr_stmt|;
name|cb
operator|->
name|_aiocb_private
operator|.
name|status
operator|=
name|cb
operator|->
name|aio_nbytes
expr_stmt|;
name|num_buf_aio
operator|++
expr_stmt|;
name|bp
operator|->
name|b_error
operator|=
literal|0
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* Perform transfer. */
name|DEV_STRATEGY
argument_list|(
name|bp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|notify
operator|=
literal|0
expr_stmt|;
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
comment|/* 	 * If we had an error invoking the request, or an error in processing 	 * the request before we have returned, we process it as an error in 	 * transfer.  Note that such an I/O error is not indicated immediately, 	 * but is returned using the aio_error mechanism.  In this case, 	 * aio_suspend will return immediately. 	 */
if|if
condition|(
name|bp
operator|->
name|b_error
operator|||
operator|(
name|bp
operator|->
name|b_ioflags
operator|&
name|BIO_ERROR
operator|)
condition|)
block|{
name|struct
name|aiocb
modifier|*
name|job
init|=
name|aiocbe
operator|->
name|uuaiocb
decl_stmt|;
name|aiocbe
operator|->
name|uaiocb
operator|.
name|_aiocb_private
operator|.
name|status
operator|=
literal|0
expr_stmt|;
name|suword
argument_list|(
operator|&
name|job
operator|->
name|_aiocb_private
operator|.
name|status
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|aiocbe
operator|->
name|uaiocb
operator|.
name|_aiocb_private
operator|.
name|error
operator|=
name|bp
operator|->
name|b_error
expr_stmt|;
name|suword
argument_list|(
operator|&
name|job
operator|->
name|_aiocb_private
operator|.
name|error
argument_list|,
name|bp
operator|->
name|b_error
argument_list|)
expr_stmt|;
name|ki
operator|->
name|kaio_buffer_finished_count
operator|++
expr_stmt|;
if|if
condition|(
name|aiocbe
operator|->
name|jobstate
operator|!=
name|JOBST_JOBBFINISHED
condition|)
block|{
name|aiocbe
operator|->
name|jobstate
operator|=
name|JOBST_JOBBFINISHED
expr_stmt|;
name|aiocbe
operator|->
name|jobflags
operator||=
name|AIOCBLIST_DONE
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|aio_bufjobs
argument_list|,
name|aiocbe
argument_list|,
name|list
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|ki
operator|->
name|kaio_bufqueue
argument_list|,
name|aiocbe
argument_list|,
name|plist
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|ki
operator|->
name|kaio_bufdone
argument_list|,
name|aiocbe
argument_list|,
name|plist
argument_list|)
expr_stmt|;
name|notify
operator|=
literal|1
expr_stmt|;
block|}
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|notify
condition|)
name|KNOTE
argument_list|(
operator|&
name|aiocbe
operator|->
name|klist
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
name|doerror
label|:
name|ki
operator|->
name|kaio_buffer_count
operator|--
expr_stmt|;
if|if
condition|(
name|lj
condition|)
name|lj
operator|->
name|lioj_buffer_count
operator|--
expr_stmt|;
name|aiocbe
operator|->
name|bp
operator|=
name|NULL
expr_stmt|;
name|relpbuf
argument_list|(
name|bp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  * This waits/tests physio completion.  */
end_comment

begin_function
name|int
name|aio_fphysio
parameter_list|(
name|struct
name|proc
modifier|*
name|p
parameter_list|,
name|struct
name|aiocblist
modifier|*
name|iocb
parameter_list|,
name|int
name|flgwait
parameter_list|)
block|{
name|int
name|s
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|int
name|error
decl_stmt|;
name|bp
operator|=
name|iocb
operator|->
name|bp
expr_stmt|;
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
if|if
condition|(
name|flgwait
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_DONE
operator|)
operator|==
literal|0
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|EINPROGRESS
return|;
block|}
block|}
while|while
condition|(
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_DONE
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
name|bp
argument_list|,
name|PRIBIO
argument_list|,
literal|"physstr"
argument_list|,
name|aiod_timeout
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_DONE
operator|)
operator|==
literal|0
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|EINPROGRESS
return|;
block|}
else|else
break|break;
block|}
block|}
comment|/* Release mapping into kernel space. */
name|vunmapbuf
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|iocb
operator|->
name|bp
operator|=
literal|0
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
comment|/* Check for an error. */
if|if
condition|(
name|bp
operator|->
name|b_ioflags
operator|&
name|BIO_ERROR
condition|)
name|error
operator|=
name|bp
operator|->
name|b_error
expr_stmt|;
name|relpbuf
argument_list|(
name|bp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Wake up aio requests that may be serviceable now.  */
end_comment

begin_function
name|void
name|aio_swake
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|sockbuf
modifier|*
name|sb
parameter_list|)
block|{
name|struct
name|aiocblist
modifier|*
name|cb
decl_stmt|,
modifier|*
name|cbn
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|struct
name|kaioinfo
modifier|*
name|ki
init|=
name|NULL
decl_stmt|;
name|int
name|opcode
decl_stmt|,
name|wakecount
init|=
literal|0
decl_stmt|;
name|struct
name|aioproclist
modifier|*
name|aiop
decl_stmt|;
if|if
condition|(
name|sb
operator|==
operator|&
name|so
operator|->
name|so_snd
condition|)
block|{
name|opcode
operator|=
name|LIO_WRITE
expr_stmt|;
name|so
operator|->
name|so_snd
operator|.
name|sb_flags
operator|&=
operator|~
name|SB_AIO
expr_stmt|;
block|}
else|else
block|{
name|opcode
operator|=
name|LIO_READ
expr_stmt|;
name|so
operator|->
name|so_rcv
operator|.
name|sb_flags
operator|&=
operator|~
name|SB_AIO
expr_stmt|;
block|}
for|for
control|(
name|cb
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|so
operator|->
name|so_aiojobq
argument_list|)
init|;
name|cb
condition|;
name|cb
operator|=
name|cbn
control|)
block|{
name|cbn
operator|=
name|TAILQ_NEXT
argument_list|(
name|cb
argument_list|,
name|list
argument_list|)
expr_stmt|;
if|if
condition|(
name|opcode
operator|==
name|cb
operator|->
name|uaiocb
operator|.
name|aio_lio_opcode
condition|)
block|{
name|p
operator|=
name|cb
operator|->
name|userproc
expr_stmt|;
name|ki
operator|=
name|p
operator|->
name|p_aioinfo
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|so
operator|->
name|so_aiojobq
argument_list|,
name|cb
argument_list|,
name|list
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|ki
operator|->
name|kaio_sockqueue
argument_list|,
name|cb
argument_list|,
name|plist
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|aio_jobs
argument_list|,
name|cb
argument_list|,
name|list
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|ki
operator|->
name|kaio_jobqueue
argument_list|,
name|cb
argument_list|,
name|plist
argument_list|)
expr_stmt|;
name|wakecount
operator|++
expr_stmt|;
if|if
condition|(
name|cb
operator|->
name|jobstate
operator|!=
name|JOBST_JOBQGLOBAL
condition|)
name|panic
argument_list|(
literal|"invalid queue value"
argument_list|)
expr_stmt|;
block|}
block|}
while|while
condition|(
name|wakecount
operator|--
condition|)
block|{
if|if
condition|(
operator|(
name|aiop
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|aio_freeproc
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|aio_freeproc
argument_list|,
name|aiop
argument_list|,
name|list
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|aio_activeproc
argument_list|,
name|aiop
argument_list|,
name|list
argument_list|)
expr_stmt|;
name|aiop
operator|->
name|aioprocflags
operator|&=
operator|~
name|AIOP_FREE
expr_stmt|;
name|wakeup
argument_list|(
name|aiop
operator|->
name|aioproc
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Queue a new AIO request.  Choosing either the threaded or direct physio VCHR  * technique is done in this code.  */
end_comment

begin_function
specifier|static
name|int
name|_aio_aqueue
parameter_list|(
name|struct
name|proc
modifier|*
name|p
parameter_list|,
name|struct
name|aiocb
modifier|*
name|job
parameter_list|,
name|struct
name|aio_liojob
modifier|*
name|lj
parameter_list|,
name|int
name|type
parameter_list|)
block|{
name|struct
name|filedesc
modifier|*
name|fdp
decl_stmt|;
name|struct
name|file
modifier|*
name|fp
decl_stmt|;
name|unsigned
name|int
name|fd
decl_stmt|;
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|int
name|s
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|int
name|opcode
decl_stmt|;
name|struct
name|aiocblist
modifier|*
name|aiocbe
decl_stmt|;
name|struct
name|aioproclist
modifier|*
name|aiop
decl_stmt|;
name|struct
name|kaioinfo
modifier|*
name|ki
decl_stmt|;
if|if
condition|(
operator|(
name|aiocbe
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|aio_freejobs
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|TAILQ_REMOVE
argument_list|(
operator|&
name|aio_freejobs
argument_list|,
name|aiocbe
argument_list|,
name|list
argument_list|)
expr_stmt|;
else|else
name|aiocbe
operator|=
name|zalloc
argument_list|(
name|aiocb_zone
argument_list|)
expr_stmt|;
name|aiocbe
operator|->
name|inputcharge
operator|=
literal|0
expr_stmt|;
name|aiocbe
operator|->
name|outputcharge
operator|=
literal|0
expr_stmt|;
name|SLIST_INIT
argument_list|(
operator|&
name|aiocbe
operator|->
name|klist
argument_list|)
expr_stmt|;
name|suword
argument_list|(
operator|&
name|job
operator|->
name|_aiocb_private
operator|.
name|status
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|suword
argument_list|(
operator|&
name|job
operator|->
name|_aiocb_private
operator|.
name|error
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|suword
argument_list|(
operator|&
name|job
operator|->
name|_aiocb_private
operator|.
name|kernelinfo
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|error
operator|=
name|copyin
argument_list|(
operator|(
name|caddr_t
operator|)
name|job
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|aiocbe
operator|->
name|uaiocb
argument_list|,
sizeof|sizeof
name|aiocbe
operator|->
name|uaiocb
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|suword
argument_list|(
operator|&
name|job
operator|->
name|_aiocb_private
operator|.
name|error
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|aio_freejobs
argument_list|,
name|aiocbe
argument_list|,
name|list
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
comment|/* Save userspace address of the job info. */
name|aiocbe
operator|->
name|uuaiocb
operator|=
name|job
expr_stmt|;
comment|/* Get the opcode. */
if|if
condition|(
name|type
operator|!=
name|LIO_NOP
condition|)
name|aiocbe
operator|->
name|uaiocb
operator|.
name|aio_lio_opcode
operator|=
name|type
expr_stmt|;
name|opcode
operator|=
name|aiocbe
operator|->
name|uaiocb
operator|.
name|aio_lio_opcode
expr_stmt|;
comment|/* Get the fd info for process. */
name|fdp
operator|=
name|p
operator|->
name|p_fd
expr_stmt|;
comment|/* 	 * Range check file descriptor. 	 */
name|fd
operator|=
name|aiocbe
operator|->
name|uaiocb
operator|.
name|aio_fildes
expr_stmt|;
if|if
condition|(
name|fd
operator|>=
name|fdp
operator|->
name|fd_nfiles
condition|)
block|{
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|aio_freejobs
argument_list|,
name|aiocbe
argument_list|,
name|list
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
literal|0
condition|)
name|suword
argument_list|(
operator|&
name|job
operator|->
name|_aiocb_private
operator|.
name|error
argument_list|,
name|EBADF
argument_list|)
expr_stmt|;
return|return
name|EBADF
return|;
block|}
name|fp
operator|=
name|aiocbe
operator|->
name|fd_file
operator|=
name|fdp
operator|->
name|fd_ofiles
index|[
name|fd
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|fp
operator|==
name|NULL
operator|)
operator|||
operator|(
operator|(
name|opcode
operator|==
name|LIO_WRITE
operator|)
operator|&&
operator|(
operator|(
name|fp
operator|->
name|f_flag
operator|&
name|FWRITE
operator|)
operator|==
literal|0
operator|)
operator|)
condition|)
block|{
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|aio_freejobs
argument_list|,
name|aiocbe
argument_list|,
name|list
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
literal|0
condition|)
name|suword
argument_list|(
operator|&
name|job
operator|->
name|_aiocb_private
operator|.
name|error
argument_list|,
name|EBADF
argument_list|)
expr_stmt|;
return|return
name|EBADF
return|;
block|}
if|if
condition|(
name|aiocbe
operator|->
name|uaiocb
operator|.
name|aio_offset
operator|==
operator|-
literal|1LL
condition|)
block|{
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|aio_freejobs
argument_list|,
name|aiocbe
argument_list|,
name|list
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
literal|0
condition|)
name|suword
argument_list|(
operator|&
name|job
operator|->
name|_aiocb_private
operator|.
name|error
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
name|error
operator|=
name|suword
argument_list|(
operator|&
name|job
operator|->
name|_aiocb_private
operator|.
name|kernelinfo
argument_list|,
name|jobrefid
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|aio_freejobs
argument_list|,
name|aiocbe
argument_list|,
name|list
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
literal|0
condition|)
name|suword
argument_list|(
operator|&
name|job
operator|->
name|_aiocb_private
operator|.
name|error
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
name|aiocbe
operator|->
name|uaiocb
operator|.
name|_aiocb_private
operator|.
name|kernelinfo
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
name|intptr_t
operator|)
name|jobrefid
expr_stmt|;
if|if
condition|(
name|jobrefid
operator|==
name|LONG_MAX
condition|)
name|jobrefid
operator|=
literal|1
expr_stmt|;
else|else
name|jobrefid
operator|++
expr_stmt|;
if|if
condition|(
name|opcode
operator|==
name|LIO_NOP
condition|)
block|{
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|aio_freejobs
argument_list|,
name|aiocbe
argument_list|,
name|list
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
literal|0
condition|)
block|{
name|suword
argument_list|(
operator|&
name|job
operator|->
name|_aiocb_private
operator|.
name|error
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|suword
argument_list|(
operator|&
name|job
operator|->
name|_aiocb_private
operator|.
name|status
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|suword
argument_list|(
operator|&
name|job
operator|->
name|_aiocb_private
operator|.
name|kernelinfo
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|(
name|opcode
operator|!=
name|LIO_READ
operator|)
operator|&&
operator|(
name|opcode
operator|!=
name|LIO_WRITE
operator|)
condition|)
block|{
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|aio_freejobs
argument_list|,
name|aiocbe
argument_list|,
name|list
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
literal|0
condition|)
block|{
name|suword
argument_list|(
operator|&
name|job
operator|->
name|_aiocb_private
operator|.
name|status
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|suword
argument_list|(
operator|&
name|job
operator|->
name|_aiocb_private
operator|.
name|error
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
block|}
return|return
name|EINVAL
return|;
block|}
comment|/* 	 * XXX   	 * Figure out how to do this properly.  This currently won't 	 * work on the alpha, since we're passing in a pointer via 	 * aio_lio_opcode, which is an int. 	 */
block|{
name|struct
name|kevent
name|kev
decl_stmt|,
modifier|*
name|kevp
decl_stmt|;
name|struct
name|kqueue
modifier|*
name|kq
decl_stmt|;
name|kevp
operator|=
operator|(
expr|struct
name|kevent
operator|*
operator|)
name|job
operator|->
name|aio_lio_opcode
expr_stmt|;
if|if
condition|(
name|kevp
operator|==
name|NULL
condition|)
goto|goto
name|no_kqueue
goto|;
name|error
operator|=
name|copyin
argument_list|(
operator|(
name|caddr_t
operator|)
name|kevp
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|kev
argument_list|,
sizeof|sizeof
argument_list|(
name|kev
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|aqueue_fail
goto|;
if|if
condition|(
operator|(
name|u_int
operator|)
name|kev
operator|.
name|ident
operator|>=
name|fdp
operator|->
name|fd_nfiles
operator|||
operator|(
name|fp
operator|=
name|fdp
operator|->
name|fd_ofiles
index|[
name|kev
operator|.
name|ident
index|]
operator|)
operator|==
name|NULL
operator|||
operator|(
name|fp
operator|->
name|f_type
operator|!=
name|DTYPE_KQUEUE
operator|)
condition|)
block|{
name|error
operator|=
name|EBADF
expr_stmt|;
goto|goto
name|aqueue_fail
goto|;
block|}
name|kq
operator|=
operator|(
expr|struct
name|kqueue
operator|*
operator|)
name|fp
operator|->
name|f_data
expr_stmt|;
name|kev
operator|.
name|ident
operator|=
operator|(
name|u_long
operator|)
name|aiocbe
expr_stmt|;
name|kev
operator|.
name|filter
operator|=
name|EVFILT_AIO
expr_stmt|;
name|kev
operator|.
name|flags
operator|=
name|EV_ADD
operator||
name|EV_ENABLE
operator||
name|EV_FLAG1
expr_stmt|;
name|error
operator|=
name|kqueue_register
argument_list|(
name|kq
argument_list|,
operator|&
name|kev
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|aqueue_fail
label|:
if|if
condition|(
name|error
condition|)
block|{
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|aio_freejobs
argument_list|,
name|aiocbe
argument_list|,
name|list
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
literal|0
condition|)
name|suword
argument_list|(
operator|&
name|job
operator|->
name|_aiocb_private
operator|.
name|error
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|no_kqueue
label|:
block|}
name|suword
argument_list|(
operator|&
name|job
operator|->
name|_aiocb_private
operator|.
name|error
argument_list|,
name|EINPROGRESS
argument_list|)
expr_stmt|;
name|aiocbe
operator|->
name|uaiocb
operator|.
name|_aiocb_private
operator|.
name|error
operator|=
name|EINPROGRESS
expr_stmt|;
name|aiocbe
operator|->
name|userproc
operator|=
name|p
expr_stmt|;
name|aiocbe
operator|->
name|jobflags
operator|=
literal|0
expr_stmt|;
name|aiocbe
operator|->
name|lio
operator|=
name|lj
expr_stmt|;
name|ki
operator|=
name|p
operator|->
name|p_aioinfo
expr_stmt|;
if|if
condition|(
name|fp
operator|->
name|f_type
operator|==
name|DTYPE_SOCKET
condition|)
block|{
comment|/* 		 * Alternate queueing for socket ops: Reach down into the 		 * descriptor to get the socket data.  Then check to see if the 		 * socket is ready to be read or written (based on the requested 		 * operation). 		 * 		 * If it is not ready for io, then queue the aiocbe on the 		 * socket, and set the flags so we get a call when sbnotify() 		 * happens. 		 */
name|so
operator|=
operator|(
expr|struct
name|socket
operator|*
operator|)
name|fp
operator|->
name|f_data
expr_stmt|;
name|s
operator|=
name|splnet
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|opcode
operator|==
name|LIO_READ
operator|)
operator|&&
operator|(
operator|!
name|soreadable
argument_list|(
name|so
argument_list|)
operator|)
operator|)
operator|||
operator|(
operator|(
name|opcode
operator|==
name|LIO_WRITE
operator|)
operator|&&
operator|(
operator|!
name|sowriteable
argument_list|(
name|so
argument_list|)
operator|)
operator|)
condition|)
block|{
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|so
operator|->
name|so_aiojobq
argument_list|,
name|aiocbe
argument_list|,
name|list
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|ki
operator|->
name|kaio_sockqueue
argument_list|,
name|aiocbe
argument_list|,
name|plist
argument_list|)
expr_stmt|;
if|if
condition|(
name|opcode
operator|==
name|LIO_READ
condition|)
name|so
operator|->
name|so_rcv
operator|.
name|sb_flags
operator||=
name|SB_AIO
expr_stmt|;
else|else
name|so
operator|->
name|so_snd
operator|.
name|sb_flags
operator||=
name|SB_AIO
expr_stmt|;
name|aiocbe
operator|->
name|jobstate
operator|=
name|JOBST_JOBQGLOBAL
expr_stmt|;
comment|/* XXX */
name|ki
operator|->
name|kaio_queue_count
operator|++
expr_stmt|;
name|num_queue_count
operator|++
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|error
operator|=
name|aio_qphysio
argument_list|(
name|p
argument_list|,
name|aiocbe
argument_list|)
operator|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
elseif|else
if|if
condition|(
name|error
operator|>
literal|0
condition|)
block|{
name|suword
argument_list|(
operator|&
name|job
operator|->
name|_aiocb_private
operator|.
name|status
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|aiocbe
operator|->
name|uaiocb
operator|.
name|_aiocb_private
operator|.
name|error
operator|=
name|error
expr_stmt|;
name|suword
argument_list|(
operator|&
name|job
operator|->
name|_aiocb_private
operator|.
name|error
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
comment|/* No buffer for daemon I/O. */
name|aiocbe
operator|->
name|bp
operator|=
name|NULL
expr_stmt|;
name|ki
operator|->
name|kaio_queue_count
operator|++
expr_stmt|;
if|if
condition|(
name|lj
condition|)
name|lj
operator|->
name|lioj_queue_count
operator|++
expr_stmt|;
name|s
operator|=
name|splnet
argument_list|()
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|ki
operator|->
name|kaio_jobqueue
argument_list|,
name|aiocbe
argument_list|,
name|plist
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|aio_jobs
argument_list|,
name|aiocbe
argument_list|,
name|list
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|aiocbe
operator|->
name|jobstate
operator|=
name|JOBST_JOBQGLOBAL
expr_stmt|;
name|num_queue_count
operator|++
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
comment|/* 	 * If we don't have a free AIO process, and we are below our quota, then 	 * start one.  Otherwise, depend on the subsequent I/O completions to 	 * pick-up this job.  If we don't sucessfully create the new process 	 * (thread) due to resource issues, we return an error for now (EAGAIN), 	 * which is likely not the correct thing to do. 	 */
name|retryproc
label|:
name|s
operator|=
name|splnet
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|aiop
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|aio_freeproc
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|aio_freeproc
argument_list|,
name|aiop
argument_list|,
name|list
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|aio_activeproc
argument_list|,
name|aiop
argument_list|,
name|list
argument_list|)
expr_stmt|;
name|aiop
operator|->
name|aioprocflags
operator|&=
operator|~
name|AIOP_FREE
expr_stmt|;
name|wakeup
argument_list|(
name|aiop
operator|->
name|aioproc
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|(
name|num_aio_resv_start
operator|+
name|num_aio_procs
operator|)
operator|<
name|max_aio_procs
operator|)
operator|&&
operator|(
operator|(
name|ki
operator|->
name|kaio_active_count
operator|+
name|num_aio_resv_start
operator|)
operator|<
name|ki
operator|->
name|kaio_maxactive_count
operator|)
condition|)
block|{
name|num_aio_resv_start
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|aio_newproc
argument_list|()
operator|)
operator|==
literal|0
condition|)
block|{
name|num_aio_resv_start
operator|--
expr_stmt|;
name|p
operator|->
name|p_retval
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
goto|goto
name|retryproc
goto|;
block|}
name|num_aio_resv_start
operator|--
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  * This routine queues an AIO request, checking for quotas.  */
end_comment

begin_function
specifier|static
name|int
name|aio_aqueue
parameter_list|(
name|struct
name|proc
modifier|*
name|p
parameter_list|,
name|struct
name|aiocb
modifier|*
name|job
parameter_list|,
name|int
name|type
parameter_list|)
block|{
name|struct
name|kaioinfo
modifier|*
name|ki
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|p_aioinfo
operator|==
name|NULL
condition|)
name|aio_init_aioinfo
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|num_queue_count
operator|>=
name|max_queue_count
condition|)
return|return
name|EAGAIN
return|;
name|ki
operator|=
name|p
operator|->
name|p_aioinfo
expr_stmt|;
if|if
condition|(
name|ki
operator|->
name|kaio_queue_count
operator|>=
name|ki
operator|->
name|kaio_qallowed_count
condition|)
return|return
name|EAGAIN
return|;
return|return
name|_aio_aqueue
argument_list|(
name|p
argument_list|,
name|job
argument_list|,
name|NULL
argument_list|,
name|type
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Support the aio_return system call, as a side-effect, kernel resources are  * released.  */
end_comment

begin_function
name|int
name|aio_return
parameter_list|(
name|struct
name|proc
modifier|*
name|p
parameter_list|,
name|struct
name|aio_return_args
modifier|*
name|uap
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|VFS_AIO
return|return
name|ENOSYS
return|;
else|#
directive|else
name|int
name|s
decl_stmt|;
name|int
name|jobref
decl_stmt|;
name|struct
name|aiocblist
modifier|*
name|cb
decl_stmt|,
modifier|*
name|ncb
decl_stmt|;
name|struct
name|aiocb
modifier|*
name|ujob
decl_stmt|;
name|struct
name|kaioinfo
modifier|*
name|ki
decl_stmt|;
name|ki
operator|=
name|p
operator|->
name|p_aioinfo
expr_stmt|;
if|if
condition|(
name|ki
operator|==
name|NULL
condition|)
return|return
name|EINVAL
return|;
name|ujob
operator|=
name|uap
operator|->
name|aiocbp
expr_stmt|;
name|jobref
operator|=
name|fuword
argument_list|(
operator|&
name|ujob
operator|->
name|_aiocb_private
operator|.
name|kernelinfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|jobref
operator|==
operator|-
literal|1
operator|||
name|jobref
operator|==
literal|0
condition|)
return|return
name|EINVAL
return|;
name|s
operator|=
name|splnet
argument_list|()
expr_stmt|;
for|for
control|(
name|cb
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|ki
operator|->
name|kaio_jobdone
argument_list|)
init|;
name|cb
condition|;
name|cb
operator|=
name|TAILQ_NEXT
argument_list|(
name|cb
argument_list|,
name|plist
argument_list|)
control|)
block|{
if|if
condition|(
operator|(
operator|(
name|intptr_t
operator|)
name|cb
operator|->
name|uaiocb
operator|.
name|_aiocb_private
operator|.
name|kernelinfo
operator|)
operator|==
name|jobref
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|ujob
operator|==
name|cb
operator|->
name|uuaiocb
condition|)
block|{
name|p
operator|->
name|p_retval
index|[
literal|0
index|]
operator|=
name|cb
operator|->
name|uaiocb
operator|.
name|_aiocb_private
operator|.
name|status
expr_stmt|;
block|}
else|else
name|p
operator|->
name|p_retval
index|[
literal|0
index|]
operator|=
name|EFAULT
expr_stmt|;
if|if
condition|(
name|cb
operator|->
name|uaiocb
operator|.
name|aio_lio_opcode
operator|==
name|LIO_WRITE
condition|)
block|{
name|curproc
operator|->
name|p_stats
operator|->
name|p_ru
operator|.
name|ru_oublock
operator|+=
name|cb
operator|->
name|outputcharge
expr_stmt|;
name|cb
operator|->
name|outputcharge
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cb
operator|->
name|uaiocb
operator|.
name|aio_lio_opcode
operator|==
name|LIO_READ
condition|)
block|{
name|curproc
operator|->
name|p_stats
operator|->
name|p_ru
operator|.
name|ru_inblock
operator|+=
name|cb
operator|->
name|inputcharge
expr_stmt|;
name|cb
operator|->
name|inputcharge
operator|=
literal|0
expr_stmt|;
block|}
name|aio_free_entry
argument_list|(
name|cb
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
for|for
control|(
name|cb
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|ki
operator|->
name|kaio_bufdone
argument_list|)
init|;
name|cb
condition|;
name|cb
operator|=
name|ncb
control|)
block|{
name|ncb
operator|=
name|TAILQ_NEXT
argument_list|(
name|cb
argument_list|,
name|plist
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|intptr_t
operator|)
name|cb
operator|->
name|uaiocb
operator|.
name|_aiocb_private
operator|.
name|kernelinfo
operator|)
operator|==
name|jobref
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|ujob
operator|==
name|cb
operator|->
name|uuaiocb
condition|)
block|{
name|p
operator|->
name|p_retval
index|[
literal|0
index|]
operator|=
name|cb
operator|->
name|uaiocb
operator|.
name|_aiocb_private
operator|.
name|status
expr_stmt|;
block|}
else|else
name|p
operator|->
name|p_retval
index|[
literal|0
index|]
operator|=
name|EFAULT
expr_stmt|;
name|aio_free_entry
argument_list|(
name|cb
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
endif|#
directive|endif
comment|/* VFS_AIO */
block|}
end_function

begin_comment
comment|/*  * Allow a process to wakeup when any of the I/O requests are completed.  */
end_comment

begin_function
name|int
name|aio_suspend
parameter_list|(
name|struct
name|proc
modifier|*
name|p
parameter_list|,
name|struct
name|aio_suspend_args
modifier|*
name|uap
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|VFS_AIO
return|return
name|ENOSYS
return|;
else|#
directive|else
name|struct
name|timeval
name|atv
decl_stmt|;
name|struct
name|timespec
name|ts
decl_stmt|;
name|struct
name|aiocb
modifier|*
specifier|const
modifier|*
name|cbptr
decl_stmt|,
modifier|*
name|cbp
decl_stmt|;
name|struct
name|kaioinfo
modifier|*
name|ki
decl_stmt|;
name|struct
name|aiocblist
modifier|*
name|cb
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|njoblist
decl_stmt|;
name|int
name|error
decl_stmt|,
name|s
decl_stmt|,
name|timo
decl_stmt|;
name|int
modifier|*
name|ijoblist
decl_stmt|;
name|struct
name|aiocb
modifier|*
modifier|*
name|ujoblist
decl_stmt|;
if|if
condition|(
name|uap
operator|->
name|nent
operator|>=
name|AIO_LISTIO_MAX
condition|)
return|return
name|EINVAL
return|;
name|timo
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|uap
operator|->
name|timeout
condition|)
block|{
comment|/* Get timespec struct. */
if|if
condition|(
operator|(
name|error
operator|=
name|copyin
argument_list|(
name|uap
operator|->
name|timeout
argument_list|,
operator|&
name|ts
argument_list|,
sizeof|sizeof
argument_list|(
name|ts
argument_list|)
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|error
return|;
if|if
condition|(
name|ts
operator|.
name|tv_nsec
operator|<
literal|0
operator|||
name|ts
operator|.
name|tv_nsec
operator|>=
literal|1000000000
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|TIMESPEC_TO_TIMEVAL
argument_list|(
operator|&
name|atv
argument_list|,
operator|&
name|ts
argument_list|)
expr_stmt|;
if|if
condition|(
name|itimerfix
argument_list|(
operator|&
name|atv
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|timo
operator|=
name|tvtohz
argument_list|(
operator|&
name|atv
argument_list|)
expr_stmt|;
block|}
name|ki
operator|=
name|p
operator|->
name|p_aioinfo
expr_stmt|;
if|if
condition|(
name|ki
operator|==
name|NULL
condition|)
return|return
name|EAGAIN
return|;
name|njoblist
operator|=
literal|0
expr_stmt|;
name|ijoblist
operator|=
name|zalloc
argument_list|(
name|aiol_zone
argument_list|)
expr_stmt|;
name|ujoblist
operator|=
name|zalloc
argument_list|(
name|aiol_zone
argument_list|)
expr_stmt|;
name|cbptr
operator|=
name|uap
operator|->
name|aiocbp
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|uap
operator|->
name|nent
condition|;
name|i
operator|++
control|)
block|{
name|cbp
operator|=
operator|(
expr|struct
name|aiocb
operator|*
operator|)
operator|(
name|intptr_t
operator|)
name|fuword
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|cbptr
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|cbp
operator|==
literal|0
condition|)
continue|continue;
name|ujoblist
index|[
name|njoblist
index|]
operator|=
name|cbp
expr_stmt|;
name|ijoblist
index|[
name|njoblist
index|]
operator|=
name|fuword
argument_list|(
operator|&
name|cbp
operator|->
name|_aiocb_private
operator|.
name|kernelinfo
argument_list|)
expr_stmt|;
name|njoblist
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|njoblist
operator|==
literal|0
condition|)
block|{
name|zfree
argument_list|(
name|aiol_zone
argument_list|,
name|ijoblist
argument_list|)
expr_stmt|;
name|zfree
argument_list|(
name|aiol_zone
argument_list|,
name|ujoblist
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|error
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
for|for
control|(
name|cb
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|ki
operator|->
name|kaio_jobdone
argument_list|)
init|;
name|cb
condition|;
name|cb
operator|=
name|TAILQ_NEXT
argument_list|(
name|cb
argument_list|,
name|plist
argument_list|)
control|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|njoblist
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
operator|(
name|intptr_t
operator|)
name|cb
operator|->
name|uaiocb
operator|.
name|_aiocb_private
operator|.
name|kernelinfo
operator|)
operator|==
name|ijoblist
index|[
name|i
index|]
condition|)
block|{
if|if
condition|(
name|ujoblist
index|[
name|i
index|]
operator|!=
name|cb
operator|->
name|uuaiocb
condition|)
name|error
operator|=
name|EINVAL
expr_stmt|;
name|zfree
argument_list|(
name|aiol_zone
argument_list|,
name|ijoblist
argument_list|)
expr_stmt|;
name|zfree
argument_list|(
name|aiol_zone
argument_list|,
name|ujoblist
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
block|}
block|}
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
for|for
control|(
name|cb
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|ki
operator|->
name|kaio_bufdone
argument_list|)
init|;
name|cb
condition|;
name|cb
operator|=
name|TAILQ_NEXT
argument_list|(
name|cb
argument_list|,
name|plist
argument_list|)
control|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|njoblist
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
operator|(
name|intptr_t
operator|)
name|cb
operator|->
name|uaiocb
operator|.
name|_aiocb_private
operator|.
name|kernelinfo
operator|)
operator|==
name|ijoblist
index|[
name|i
index|]
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|ujoblist
index|[
name|i
index|]
operator|!=
name|cb
operator|->
name|uuaiocb
condition|)
name|error
operator|=
name|EINVAL
expr_stmt|;
name|zfree
argument_list|(
name|aiol_zone
argument_list|,
name|ijoblist
argument_list|)
expr_stmt|;
name|zfree
argument_list|(
name|aiol_zone
argument_list|,
name|ujoblist
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
block|}
block|}
name|ki
operator|->
name|kaio_flags
operator||=
name|KAIO_WAKEUP
expr_stmt|;
name|error
operator|=
name|tsleep
argument_list|(
name|p
argument_list|,
name|PRIBIO
operator||
name|PCATCH
argument_list|,
literal|"aiospn"
argument_list|,
name|timo
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|ERESTART
operator|||
name|error
operator|==
name|EINTR
condition|)
block|{
name|zfree
argument_list|(
name|aiol_zone
argument_list|,
name|ijoblist
argument_list|)
expr_stmt|;
name|zfree
argument_list|(
name|aiol_zone
argument_list|,
name|ujoblist
argument_list|)
expr_stmt|;
return|return
name|EINTR
return|;
block|}
elseif|else
if|if
condition|(
name|error
operator|==
name|EWOULDBLOCK
condition|)
block|{
name|zfree
argument_list|(
name|aiol_zone
argument_list|,
name|ijoblist
argument_list|)
expr_stmt|;
name|zfree
argument_list|(
name|aiol_zone
argument_list|,
name|ujoblist
argument_list|)
expr_stmt|;
return|return
name|EAGAIN
return|;
block|}
block|}
comment|/* NOTREACHED */
return|return
name|EINVAL
return|;
endif|#
directive|endif
comment|/* VFS_AIO */
block|}
end_function

begin_comment
comment|/*  * aio_cancel cancels any non-physio aio operations not currently in  * progress.  */
end_comment

begin_function
name|int
name|aio_cancel
parameter_list|(
name|struct
name|proc
modifier|*
name|p
parameter_list|,
name|struct
name|aio_cancel_args
modifier|*
name|uap
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|VFS_AIO
return|return
name|ENOSYS
return|;
else|#
directive|else
name|struct
name|kaioinfo
modifier|*
name|ki
decl_stmt|;
name|struct
name|aiocblist
modifier|*
name|cbe
decl_stmt|,
modifier|*
name|cbn
decl_stmt|;
name|struct
name|file
modifier|*
name|fp
decl_stmt|;
name|struct
name|filedesc
modifier|*
name|fdp
decl_stmt|;
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|struct
name|proc
modifier|*
name|po
decl_stmt|;
name|int
name|s
decl_stmt|,
name|error
decl_stmt|;
name|int
name|cancelled
init|=
literal|0
decl_stmt|;
name|int
name|notcancelled
init|=
literal|0
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|fdp
operator|=
name|p
operator|->
name|p_fd
expr_stmt|;
name|fp
operator|=
name|fdp
operator|->
name|fd_ofiles
index|[
name|uap
operator|->
name|fd
index|]
expr_stmt|;
if|if
condition|(
name|fp
operator|==
name|NULL
condition|)
block|{
return|return
name|EBADF
return|;
block|}
if|if
condition|(
name|fp
operator|->
name|f_type
operator|==
name|DTYPE_VNODE
condition|)
block|{
name|vp
operator|=
operator|(
expr|struct
name|vnode
operator|*
operator|)
name|fp
operator|->
name|f_data
expr_stmt|;
if|if
condition|(
name|vn_isdisk
argument_list|(
name|vp
argument_list|,
operator|&
name|error
argument_list|)
condition|)
block|{
name|p
operator|->
name|p_retval
index|[
literal|0
index|]
operator|=
name|AIO_NOTCANCELED
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|fp
operator|->
name|f_type
operator|==
name|DTYPE_SOCKET
condition|)
block|{
name|so
operator|=
operator|(
expr|struct
name|socket
operator|*
operator|)
name|fp
operator|->
name|f_data
expr_stmt|;
name|s
operator|=
name|splnet
argument_list|()
expr_stmt|;
for|for
control|(
name|cbe
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|so
operator|->
name|so_aiojobq
argument_list|)
init|;
name|cbe
condition|;
name|cbe
operator|=
name|cbn
control|)
block|{
name|cbn
operator|=
name|TAILQ_NEXT
argument_list|(
name|cbe
argument_list|,
name|list
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|uap
operator|->
name|aiocbp
operator|==
name|NULL
operator|)
operator|||
operator|(
name|uap
operator|->
name|aiocbp
operator|==
name|cbe
operator|->
name|uuaiocb
operator|)
condition|)
block|{
name|po
operator|=
name|cbe
operator|->
name|userproc
expr_stmt|;
name|ki
operator|=
name|po
operator|->
name|p_aioinfo
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|so
operator|->
name|so_aiojobq
argument_list|,
name|cbe
argument_list|,
name|list
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|ki
operator|->
name|kaio_sockqueue
argument_list|,
name|cbe
argument_list|,
name|plist
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|ki
operator|->
name|kaio_jobdone
argument_list|,
name|cbe
argument_list|,
name|plist
argument_list|)
expr_stmt|;
if|if
condition|(
name|ki
operator|->
name|kaio_flags
operator|&
name|KAIO_WAKEUP
condition|)
block|{
name|wakeup
argument_list|(
name|po
argument_list|)
expr_stmt|;
block|}
name|cbe
operator|->
name|jobstate
operator|=
name|JOBST_JOBFINISHED
expr_stmt|;
name|cbe
operator|->
name|uaiocb
operator|.
name|_aiocb_private
operator|.
name|status
operator|=
operator|-
literal|1
expr_stmt|;
name|cbe
operator|->
name|uaiocb
operator|.
name|_aiocb_private
operator|.
name|error
operator|=
name|ECANCELED
expr_stmt|;
name|cancelled
operator|++
expr_stmt|;
comment|/* XXX cancelled, knote? */
if|if
condition|(
name|cbe
operator|->
name|uaiocb
operator|.
name|aio_sigevent
operator|.
name|sigev_notify
operator|==
name|SIGEV_SIGNAL
condition|)
name|psignal
argument_list|(
name|cbe
operator|->
name|userproc
argument_list|,
name|cbe
operator|->
name|uaiocb
operator|.
name|aio_sigevent
operator|.
name|sigev_signo
argument_list|)
expr_stmt|;
if|if
condition|(
name|uap
operator|->
name|aiocbp
condition|)
break|break;
block|}
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cancelled
operator|)
operator|&&
operator|(
name|uap
operator|->
name|aiocbp
operator|)
condition|)
block|{
name|p
operator|->
name|p_retval
index|[
literal|0
index|]
operator|=
name|AIO_CANCELED
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
name|ki
operator|=
name|p
operator|->
name|p_aioinfo
expr_stmt|;
name|s
operator|=
name|splnet
argument_list|()
expr_stmt|;
for|for
control|(
name|cbe
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|ki
operator|->
name|kaio_jobqueue
argument_list|)
init|;
name|cbe
condition|;
name|cbe
operator|=
name|cbn
control|)
block|{
name|cbn
operator|=
name|TAILQ_NEXT
argument_list|(
name|cbe
argument_list|,
name|plist
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|uap
operator|->
name|fd
operator|==
name|cbe
operator|->
name|uaiocb
operator|.
name|aio_fildes
operator|)
operator|&&
operator|(
operator|(
name|uap
operator|->
name|aiocbp
operator|==
name|NULL
operator|)
operator|||
operator|(
name|uap
operator|->
name|aiocbp
operator|==
name|cbe
operator|->
name|uuaiocb
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|cbe
operator|->
name|jobstate
operator|==
name|JOBST_JOBQGLOBAL
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|aio_jobs
argument_list|,
name|cbe
argument_list|,
name|list
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|ki
operator|->
name|kaio_jobqueue
argument_list|,
name|cbe
argument_list|,
name|plist
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|ki
operator|->
name|kaio_jobdone
argument_list|,
name|cbe
argument_list|,
name|plist
argument_list|)
expr_stmt|;
name|cancelled
operator|++
expr_stmt|;
name|ki
operator|->
name|kaio_queue_finished_count
operator|++
expr_stmt|;
name|cbe
operator|->
name|jobstate
operator|=
name|JOBST_JOBFINISHED
expr_stmt|;
name|cbe
operator|->
name|uaiocb
operator|.
name|_aiocb_private
operator|.
name|status
operator|=
operator|-
literal|1
expr_stmt|;
name|cbe
operator|->
name|uaiocb
operator|.
name|_aiocb_private
operator|.
name|error
operator|=
name|ECANCELED
expr_stmt|;
comment|/* XXX cancelled, knote? */
if|if
condition|(
name|cbe
operator|->
name|uaiocb
operator|.
name|aio_sigevent
operator|.
name|sigev_notify
operator|==
name|SIGEV_SIGNAL
condition|)
name|psignal
argument_list|(
name|cbe
operator|->
name|userproc
argument_list|,
name|cbe
operator|->
name|uaiocb
operator|.
name|aio_sigevent
operator|.
name|sigev_signo
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|notcancelled
operator|++
expr_stmt|;
block|}
block|}
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|notcancelled
condition|)
block|{
name|p
operator|->
name|p_retval
index|[
literal|0
index|]
operator|=
name|AIO_NOTCANCELED
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|cancelled
condition|)
block|{
name|p
operator|->
name|p_retval
index|[
literal|0
index|]
operator|=
name|AIO_CANCELED
expr_stmt|;
return|return
literal|0
return|;
block|}
name|p
operator|->
name|p_retval
index|[
literal|0
index|]
operator|=
name|AIO_ALLDONE
expr_stmt|;
return|return
literal|0
return|;
endif|#
directive|endif
comment|/* VFS_AIO */
block|}
end_function

begin_comment
comment|/*  * aio_error is implemented in the kernel level for compatibility purposes only.  * For a user mode async implementation, it would be best to do it in a userland  * subroutine.  */
end_comment

begin_function
name|int
name|aio_error
parameter_list|(
name|struct
name|proc
modifier|*
name|p
parameter_list|,
name|struct
name|aio_error_args
modifier|*
name|uap
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|VFS_AIO
return|return
name|ENOSYS
return|;
else|#
directive|else
name|int
name|s
decl_stmt|;
name|struct
name|aiocblist
modifier|*
name|cb
decl_stmt|;
name|struct
name|kaioinfo
modifier|*
name|ki
decl_stmt|;
name|int
name|jobref
decl_stmt|;
name|ki
operator|=
name|p
operator|->
name|p_aioinfo
expr_stmt|;
if|if
condition|(
name|ki
operator|==
name|NULL
condition|)
return|return
name|EINVAL
return|;
name|jobref
operator|=
name|fuword
argument_list|(
operator|&
name|uap
operator|->
name|aiocbp
operator|->
name|_aiocb_private
operator|.
name|kernelinfo
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|jobref
operator|==
operator|-
literal|1
operator|)
operator|||
operator|(
name|jobref
operator|==
literal|0
operator|)
condition|)
return|return
name|EINVAL
return|;
for|for
control|(
name|cb
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|ki
operator|->
name|kaio_jobdone
argument_list|)
init|;
name|cb
condition|;
name|cb
operator|=
name|TAILQ_NEXT
argument_list|(
name|cb
argument_list|,
name|plist
argument_list|)
control|)
block|{
if|if
condition|(
operator|(
operator|(
name|intptr_t
operator|)
name|cb
operator|->
name|uaiocb
operator|.
name|_aiocb_private
operator|.
name|kernelinfo
operator|)
operator|==
name|jobref
condition|)
block|{
name|p
operator|->
name|p_retval
index|[
literal|0
index|]
operator|=
name|cb
operator|->
name|uaiocb
operator|.
name|_aiocb_private
operator|.
name|error
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
name|s
operator|=
name|splnet
argument_list|()
expr_stmt|;
for|for
control|(
name|cb
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|ki
operator|->
name|kaio_jobqueue
argument_list|)
init|;
name|cb
condition|;
name|cb
operator|=
name|TAILQ_NEXT
argument_list|(
name|cb
argument_list|,
name|plist
argument_list|)
control|)
block|{
if|if
condition|(
operator|(
operator|(
name|intptr_t
operator|)
name|cb
operator|->
name|uaiocb
operator|.
name|_aiocb_private
operator|.
name|kernelinfo
operator|)
operator|==
name|jobref
condition|)
block|{
name|p
operator|->
name|p_retval
index|[
literal|0
index|]
operator|=
name|EINPROGRESS
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
for|for
control|(
name|cb
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|ki
operator|->
name|kaio_sockqueue
argument_list|)
init|;
name|cb
condition|;
name|cb
operator|=
name|TAILQ_NEXT
argument_list|(
name|cb
argument_list|,
name|plist
argument_list|)
control|)
block|{
if|if
condition|(
operator|(
operator|(
name|intptr_t
operator|)
name|cb
operator|->
name|uaiocb
operator|.
name|_aiocb_private
operator|.
name|kernelinfo
operator|)
operator|==
name|jobref
condition|)
block|{
name|p
operator|->
name|p_retval
index|[
literal|0
index|]
operator|=
name|EINPROGRESS
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
for|for
control|(
name|cb
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|ki
operator|->
name|kaio_bufdone
argument_list|)
init|;
name|cb
condition|;
name|cb
operator|=
name|TAILQ_NEXT
argument_list|(
name|cb
argument_list|,
name|plist
argument_list|)
control|)
block|{
if|if
condition|(
operator|(
operator|(
name|intptr_t
operator|)
name|cb
operator|->
name|uaiocb
operator|.
name|_aiocb_private
operator|.
name|kernelinfo
operator|)
operator|==
name|jobref
condition|)
block|{
name|p
operator|->
name|p_retval
index|[
literal|0
index|]
operator|=
name|cb
operator|->
name|uaiocb
operator|.
name|_aiocb_private
operator|.
name|error
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
for|for
control|(
name|cb
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|ki
operator|->
name|kaio_bufqueue
argument_list|)
init|;
name|cb
condition|;
name|cb
operator|=
name|TAILQ_NEXT
argument_list|(
name|cb
argument_list|,
name|plist
argument_list|)
control|)
block|{
if|if
condition|(
operator|(
operator|(
name|intptr_t
operator|)
name|cb
operator|->
name|uaiocb
operator|.
name|_aiocb_private
operator|.
name|kernelinfo
operator|)
operator|==
name|jobref
condition|)
block|{
name|p
operator|->
name|p_retval
index|[
literal|0
index|]
operator|=
name|EINPROGRESS
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|#
directive|if
operator|(
literal|0
operator|)
comment|/* 	 * Hack for lio. 	 */
name|status
operator|=
name|fuword
argument_list|(
operator|&
name|uap
operator|->
name|aiocbp
operator|->
name|_aiocb_private
operator|.
name|status
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
operator|-
literal|1
condition|)
return|return
name|fuword
argument_list|(
operator|&
name|uap
operator|->
name|aiocbp
operator|->
name|_aiocb_private
operator|.
name|error
argument_list|)
return|;
endif|#
directive|endif
return|return
name|EINVAL
return|;
endif|#
directive|endif
comment|/* VFS_AIO */
block|}
end_function

begin_function
name|int
name|aio_read
parameter_list|(
name|struct
name|proc
modifier|*
name|p
parameter_list|,
name|struct
name|aio_read_args
modifier|*
name|uap
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|VFS_AIO
return|return
name|ENOSYS
return|;
else|#
directive|else
name|struct
name|filedesc
modifier|*
name|fdp
decl_stmt|;
name|struct
name|file
modifier|*
name|fp
decl_stmt|;
name|struct
name|uio
name|auio
decl_stmt|;
name|struct
name|iovec
name|aiov
decl_stmt|;
name|unsigned
name|int
name|fd
decl_stmt|;
name|int
name|cnt
decl_stmt|;
name|struct
name|aiocb
name|iocb
decl_stmt|;
name|int
name|error
decl_stmt|,
name|pmodes
decl_stmt|;
name|pmodes
operator|=
name|fuword
argument_list|(
operator|&
name|uap
operator|->
name|aiocbp
operator|->
name|_aiocb_private
operator|.
name|privatemodes
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pmodes
operator|&
name|AIO_PMODE_SYNC
operator|)
operator|==
literal|0
condition|)
return|return
name|aio_aqueue
argument_list|(
name|p
argument_list|,
operator|(
expr|struct
name|aiocb
operator|*
operator|)
name|uap
operator|->
name|aiocbp
argument_list|,
name|LIO_READ
argument_list|)
return|;
comment|/* Get control block. */
if|if
condition|(
operator|(
name|error
operator|=
name|copyin
argument_list|(
operator|(
name|caddr_t
operator|)
name|uap
operator|->
name|aiocbp
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|iocb
argument_list|,
sizeof|sizeof
name|iocb
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|error
return|;
comment|/* Get the fd info for process. */
name|fdp
operator|=
name|p
operator|->
name|p_fd
expr_stmt|;
comment|/* 	 * Range check file descriptor. 	 */
name|fd
operator|=
name|iocb
operator|.
name|aio_fildes
expr_stmt|;
if|if
condition|(
name|fd
operator|>=
name|fdp
operator|->
name|fd_nfiles
condition|)
return|return
name|EBADF
return|;
name|fp
operator|=
name|fdp
operator|->
name|fd_ofiles
index|[
name|fd
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|fp
operator|==
name|NULL
operator|)
operator|||
operator|(
operator|(
name|fp
operator|->
name|f_flag
operator|&
name|FREAD
operator|)
operator|==
literal|0
operator|)
condition|)
return|return
name|EBADF
return|;
if|if
condition|(
name|iocb
operator|.
name|aio_offset
operator|==
operator|-
literal|1LL
condition|)
return|return
name|EINVAL
return|;
name|auio
operator|.
name|uio_resid
operator|=
name|iocb
operator|.
name|aio_nbytes
expr_stmt|;
if|if
condition|(
name|auio
operator|.
name|uio_resid
operator|<
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* 	 * Process sync simply -- queue async request. 	 */
if|if
condition|(
operator|(
name|iocb
operator|.
name|_aiocb_private
operator|.
name|privatemodes
operator|&
name|AIO_PMODE_SYNC
operator|)
operator|==
literal|0
condition|)
return|return
name|aio_aqueue
argument_list|(
name|p
argument_list|,
operator|(
expr|struct
name|aiocb
operator|*
operator|)
name|uap
operator|->
name|aiocbp
argument_list|,
name|LIO_READ
argument_list|)
return|;
name|aiov
operator|.
name|iov_base
operator|=
operator|(
name|void
operator|*
operator|)
name|iocb
operator|.
name|aio_buf
expr_stmt|;
name|aiov
operator|.
name|iov_len
operator|=
name|iocb
operator|.
name|aio_nbytes
expr_stmt|;
name|auio
operator|.
name|uio_iov
operator|=
operator|&
name|aiov
expr_stmt|;
name|auio
operator|.
name|uio_iovcnt
operator|=
literal|1
expr_stmt|;
name|auio
operator|.
name|uio_offset
operator|=
name|iocb
operator|.
name|aio_offset
expr_stmt|;
name|auio
operator|.
name|uio_rw
operator|=
name|UIO_READ
expr_stmt|;
name|auio
operator|.
name|uio_segflg
operator|=
name|UIO_USERSPACE
expr_stmt|;
name|auio
operator|.
name|uio_procp
operator|=
name|p
expr_stmt|;
name|cnt
operator|=
name|iocb
operator|.
name|aio_nbytes
expr_stmt|;
name|error
operator|=
name|fo_read
argument_list|(
name|fp
argument_list|,
operator|&
name|auio
argument_list|,
name|fp
operator|->
name|f_cred
argument_list|,
name|FOF_OFFSET
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|&&
operator|(
name|auio
operator|.
name|uio_resid
operator|!=
name|cnt
operator|)
operator|&&
operator|(
name|error
operator|==
name|ERESTART
operator|||
name|error
operator|==
name|EINTR
operator|||
name|error
operator|==
name|EWOULDBLOCK
operator|)
condition|)
name|error
operator|=
literal|0
expr_stmt|;
name|cnt
operator|-=
name|auio
operator|.
name|uio_resid
expr_stmt|;
name|p
operator|->
name|p_retval
index|[
literal|0
index|]
operator|=
name|cnt
expr_stmt|;
return|return
name|error
return|;
endif|#
directive|endif
comment|/* VFS_AIO */
block|}
end_function

begin_function
name|int
name|aio_write
parameter_list|(
name|struct
name|proc
modifier|*
name|p
parameter_list|,
name|struct
name|aio_write_args
modifier|*
name|uap
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|VFS_AIO
return|return
name|ENOSYS
return|;
else|#
directive|else
name|struct
name|filedesc
modifier|*
name|fdp
decl_stmt|;
name|struct
name|file
modifier|*
name|fp
decl_stmt|;
name|struct
name|uio
name|auio
decl_stmt|;
name|struct
name|iovec
name|aiov
decl_stmt|;
name|unsigned
name|int
name|fd
decl_stmt|;
name|int
name|cnt
decl_stmt|;
name|struct
name|aiocb
name|iocb
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|pmodes
decl_stmt|;
comment|/* 	 * Process sync simply -- queue async request. 	 */
name|pmodes
operator|=
name|fuword
argument_list|(
operator|&
name|uap
operator|->
name|aiocbp
operator|->
name|_aiocb_private
operator|.
name|privatemodes
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pmodes
operator|&
name|AIO_PMODE_SYNC
operator|)
operator|==
literal|0
condition|)
return|return
name|aio_aqueue
argument_list|(
name|p
argument_list|,
operator|(
expr|struct
name|aiocb
operator|*
operator|)
name|uap
operator|->
name|aiocbp
argument_list|,
name|LIO_WRITE
argument_list|)
return|;
if|if
condition|(
operator|(
name|error
operator|=
name|copyin
argument_list|(
operator|(
name|caddr_t
operator|)
name|uap
operator|->
name|aiocbp
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|iocb
argument_list|,
sizeof|sizeof
name|iocb
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|error
return|;
comment|/* Get the fd info for process. */
name|fdp
operator|=
name|p
operator|->
name|p_fd
expr_stmt|;
comment|/* 	 * Range check file descriptor. 	 */
name|fd
operator|=
name|iocb
operator|.
name|aio_fildes
expr_stmt|;
if|if
condition|(
name|fd
operator|>=
name|fdp
operator|->
name|fd_nfiles
condition|)
return|return
name|EBADF
return|;
name|fp
operator|=
name|fdp
operator|->
name|fd_ofiles
index|[
name|fd
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|fp
operator|==
name|NULL
operator|)
operator|||
operator|(
operator|(
name|fp
operator|->
name|f_flag
operator|&
name|FWRITE
operator|)
operator|==
literal|0
operator|)
condition|)
return|return
name|EBADF
return|;
if|if
condition|(
name|iocb
operator|.
name|aio_offset
operator|==
operator|-
literal|1LL
condition|)
return|return
name|EINVAL
return|;
name|aiov
operator|.
name|iov_base
operator|=
operator|(
name|void
operator|*
operator|)
name|iocb
operator|.
name|aio_buf
expr_stmt|;
name|aiov
operator|.
name|iov_len
operator|=
name|iocb
operator|.
name|aio_nbytes
expr_stmt|;
name|auio
operator|.
name|uio_iov
operator|=
operator|&
name|aiov
expr_stmt|;
name|auio
operator|.
name|uio_iovcnt
operator|=
literal|1
expr_stmt|;
name|auio
operator|.
name|uio_offset
operator|=
name|iocb
operator|.
name|aio_offset
expr_stmt|;
name|auio
operator|.
name|uio_resid
operator|=
name|iocb
operator|.
name|aio_nbytes
expr_stmt|;
if|if
condition|(
name|auio
operator|.
name|uio_resid
operator|<
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|auio
operator|.
name|uio_rw
operator|=
name|UIO_WRITE
expr_stmt|;
name|auio
operator|.
name|uio_segflg
operator|=
name|UIO_USERSPACE
expr_stmt|;
name|auio
operator|.
name|uio_procp
operator|=
name|p
expr_stmt|;
name|cnt
operator|=
name|iocb
operator|.
name|aio_nbytes
expr_stmt|;
name|error
operator|=
name|fo_write
argument_list|(
name|fp
argument_list|,
operator|&
name|auio
argument_list|,
name|fp
operator|->
name|f_cred
argument_list|,
name|FOF_OFFSET
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
if|if
condition|(
name|auio
operator|.
name|uio_resid
operator|!=
name|cnt
condition|)
block|{
if|if
condition|(
name|error
operator|==
name|ERESTART
operator|||
name|error
operator|==
name|EINTR
operator|||
name|error
operator|==
name|EWOULDBLOCK
condition|)
name|error
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|EPIPE
condition|)
name|psignal
argument_list|(
name|p
argument_list|,
name|SIGPIPE
argument_list|)
expr_stmt|;
block|}
block|}
name|cnt
operator|-=
name|auio
operator|.
name|uio_resid
expr_stmt|;
name|p
operator|->
name|p_retval
index|[
literal|0
index|]
operator|=
name|cnt
expr_stmt|;
return|return
name|error
return|;
endif|#
directive|endif
comment|/* VFS_AIO */
block|}
end_function

begin_function
name|int
name|lio_listio
parameter_list|(
name|struct
name|proc
modifier|*
name|p
parameter_list|,
name|struct
name|lio_listio_args
modifier|*
name|uap
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|VFS_AIO
return|return
name|ENOSYS
return|;
else|#
directive|else
name|int
name|nent
decl_stmt|,
name|nentqueued
decl_stmt|;
name|struct
name|aiocb
modifier|*
name|iocb
decl_stmt|,
modifier|*
decl_stmt|const
modifier|*
name|cbptr
decl_stmt|;
name|struct
name|aiocblist
modifier|*
name|cb
decl_stmt|;
name|struct
name|kaioinfo
modifier|*
name|ki
decl_stmt|;
name|struct
name|aio_liojob
modifier|*
name|lj
decl_stmt|;
name|int
name|error
decl_stmt|,
name|runningcode
decl_stmt|;
name|int
name|nerror
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|s
decl_stmt|;
if|if
condition|(
operator|(
name|uap
operator|->
name|mode
operator|!=
name|LIO_NOWAIT
operator|)
operator|&&
operator|(
name|uap
operator|->
name|mode
operator|!=
name|LIO_WAIT
operator|)
condition|)
return|return
name|EINVAL
return|;
name|nent
operator|=
name|uap
operator|->
name|nent
expr_stmt|;
if|if
condition|(
name|nent
operator|>
name|AIO_LISTIO_MAX
condition|)
return|return
name|EINVAL
return|;
if|if
condition|(
name|p
operator|->
name|p_aioinfo
operator|==
name|NULL
condition|)
name|aio_init_aioinfo
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|nent
operator|+
name|num_queue_count
operator|)
operator|>
name|max_queue_count
condition|)
return|return
name|EAGAIN
return|;
name|ki
operator|=
name|p
operator|->
name|p_aioinfo
expr_stmt|;
if|if
condition|(
operator|(
name|nent
operator|+
name|ki
operator|->
name|kaio_queue_count
operator|)
operator|>
name|ki
operator|->
name|kaio_qallowed_count
condition|)
return|return
name|EAGAIN
return|;
name|lj
operator|=
name|zalloc
argument_list|(
name|aiolio_zone
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|lj
condition|)
return|return
name|EAGAIN
return|;
name|lj
operator|->
name|lioj_flags
operator|=
literal|0
expr_stmt|;
name|lj
operator|->
name|lioj_buffer_count
operator|=
literal|0
expr_stmt|;
name|lj
operator|->
name|lioj_buffer_finished_count
operator|=
literal|0
expr_stmt|;
name|lj
operator|->
name|lioj_queue_count
operator|=
literal|0
expr_stmt|;
name|lj
operator|->
name|lioj_queue_finished_count
operator|=
literal|0
expr_stmt|;
name|lj
operator|->
name|lioj_ki
operator|=
name|ki
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|ki
operator|->
name|kaio_liojoblist
argument_list|,
name|lj
argument_list|,
name|lioj_list
argument_list|)
expr_stmt|;
comment|/* 	 * Setup signal. 	 */
if|if
condition|(
name|uap
operator|->
name|sig
operator|&&
operator|(
name|uap
operator|->
name|mode
operator|==
name|LIO_NOWAIT
operator|)
condition|)
block|{
name|error
operator|=
name|copyin
argument_list|(
name|uap
operator|->
name|sig
argument_list|,
operator|&
name|lj
operator|->
name|lioj_signal
argument_list|,
sizeof|sizeof
argument_list|(
name|lj
operator|->
name|lioj_signal
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
name|lj
operator|->
name|lioj_flags
operator||=
name|LIOJ_SIGNAL
expr_stmt|;
name|lj
operator|->
name|lioj_flags
operator|&=
operator|~
name|LIOJ_SIGNAL_POSTED
expr_stmt|;
block|}
else|else
name|lj
operator|->
name|lioj_flags
operator|&=
operator|~
name|LIOJ_SIGNAL
expr_stmt|;
comment|/* 	 * Get pointers to the list of I/O requests. 	 */
name|nerror
operator|=
literal|0
expr_stmt|;
name|nentqueued
operator|=
literal|0
expr_stmt|;
name|cbptr
operator|=
name|uap
operator|->
name|acb_list
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|uap
operator|->
name|nent
condition|;
name|i
operator|++
control|)
block|{
name|iocb
operator|=
operator|(
expr|struct
name|aiocb
operator|*
operator|)
operator|(
name|intptr_t
operator|)
name|fuword
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|cbptr
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|intptr_t
operator|)
name|iocb
operator|!=
operator|-
literal|1
operator|)
operator|&&
operator|(
operator|(
name|intptr_t
operator|)
name|iocb
operator|!=
name|NULL
operator|)
condition|)
block|{
name|error
operator|=
name|_aio_aqueue
argument_list|(
name|p
argument_list|,
name|iocb
argument_list|,
name|lj
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|nentqueued
operator|++
expr_stmt|;
else|else
name|nerror
operator|++
expr_stmt|;
block|}
block|}
comment|/* 	 * If we haven't queued any, then just return error. 	 */
if|if
condition|(
name|nentqueued
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* 	 * Calculate the appropriate error return. 	 */
name|runningcode
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|nerror
condition|)
name|runningcode
operator|=
name|EIO
expr_stmt|;
if|if
condition|(
name|uap
operator|->
name|mode
operator|==
name|LIO_WAIT
condition|)
block|{
name|int
name|command
decl_stmt|,
name|found
decl_stmt|,
name|jobref
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|found
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|uap
operator|->
name|nent
condition|;
name|i
operator|++
control|)
block|{
comment|/* 				 * Fetch address of the control buf pointer in 				 * user space. 				 */
name|iocb
operator|=
operator|(
expr|struct
name|aiocb
operator|*
operator|)
operator|(
name|intptr_t
operator|)
name|fuword
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|cbptr
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|intptr_t
operator|)
name|iocb
operator|==
operator|-
literal|1
operator|)
operator|||
operator|(
operator|(
name|intptr_t
operator|)
name|iocb
operator|==
literal|0
operator|)
condition|)
continue|continue;
comment|/* 				 * Fetch the associated command from user space. 				 */
name|command
operator|=
name|fuword
argument_list|(
operator|&
name|iocb
operator|->
name|aio_lio_opcode
argument_list|)
expr_stmt|;
if|if
condition|(
name|command
operator|==
name|LIO_NOP
condition|)
block|{
name|found
operator|++
expr_stmt|;
continue|continue;
block|}
name|jobref
operator|=
name|fuword
argument_list|(
operator|&
name|iocb
operator|->
name|_aiocb_private
operator|.
name|kernelinfo
argument_list|)
expr_stmt|;
for|for
control|(
name|cb
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|ki
operator|->
name|kaio_jobdone
argument_list|)
init|;
name|cb
condition|;
name|cb
operator|=
name|TAILQ_NEXT
argument_list|(
name|cb
argument_list|,
name|plist
argument_list|)
control|)
block|{
if|if
condition|(
operator|(
operator|(
name|intptr_t
operator|)
name|cb
operator|->
name|uaiocb
operator|.
name|_aiocb_private
operator|.
name|kernelinfo
operator|)
operator|==
name|jobref
condition|)
block|{
if|if
condition|(
name|cb
operator|->
name|uaiocb
operator|.
name|aio_lio_opcode
operator|==
name|LIO_WRITE
condition|)
block|{
name|curproc
operator|->
name|p_stats
operator|->
name|p_ru
operator|.
name|ru_oublock
operator|+=
name|cb
operator|->
name|outputcharge
expr_stmt|;
name|cb
operator|->
name|outputcharge
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cb
operator|->
name|uaiocb
operator|.
name|aio_lio_opcode
operator|==
name|LIO_READ
condition|)
block|{
name|curproc
operator|->
name|p_stats
operator|->
name|p_ru
operator|.
name|ru_inblock
operator|+=
name|cb
operator|->
name|inputcharge
expr_stmt|;
name|cb
operator|->
name|inputcharge
operator|=
literal|0
expr_stmt|;
block|}
name|found
operator|++
expr_stmt|;
break|break;
block|}
block|}
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
for|for
control|(
name|cb
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|ki
operator|->
name|kaio_bufdone
argument_list|)
init|;
name|cb
condition|;
name|cb
operator|=
name|TAILQ_NEXT
argument_list|(
name|cb
argument_list|,
name|plist
argument_list|)
control|)
block|{
if|if
condition|(
operator|(
operator|(
name|intptr_t
operator|)
name|cb
operator|->
name|uaiocb
operator|.
name|_aiocb_private
operator|.
name|kernelinfo
operator|)
operator|==
name|jobref
condition|)
block|{
name|found
operator|++
expr_stmt|;
break|break;
block|}
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
comment|/* 			 * If all I/Os have been disposed of, then we can 			 * return. 			 */
if|if
condition|(
name|found
operator|==
name|nentqueued
condition|)
return|return
name|runningcode
return|;
name|ki
operator|->
name|kaio_flags
operator||=
name|KAIO_WAKEUP
expr_stmt|;
name|error
operator|=
name|tsleep
argument_list|(
name|p
argument_list|,
name|PRIBIO
operator||
name|PCATCH
argument_list|,
literal|"aiospn"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|EINTR
condition|)
return|return
name|EINTR
return|;
elseif|else
if|if
condition|(
name|error
operator|==
name|EWOULDBLOCK
condition|)
return|return
name|EAGAIN
return|;
block|}
block|}
return|return
name|runningcode
return|;
endif|#
directive|endif
comment|/* VFS_AIO */
block|}
end_function

begin_comment
comment|/*  * This is a wierd hack so that we can post a signal.  It is safe to do so from  * a timeout routine, but *not* from an interrupt routine.  */
end_comment

begin_function
specifier|static
name|void
name|process_signal
parameter_list|(
name|void
modifier|*
name|aioj
parameter_list|)
block|{
name|struct
name|aiocblist
modifier|*
name|aiocbe
init|=
name|aioj
decl_stmt|;
name|struct
name|aio_liojob
modifier|*
name|lj
init|=
name|aiocbe
operator|->
name|lio
decl_stmt|;
name|struct
name|aiocb
modifier|*
name|cb
init|=
operator|&
name|aiocbe
operator|->
name|uaiocb
decl_stmt|;
if|if
condition|(
operator|(
name|lj
operator|)
operator|&&
operator|(
name|lj
operator|->
name|lioj_signal
operator|.
name|sigev_notify
operator|==
name|SIGEV_SIGNAL
operator|)
operator|&&
operator|(
name|lj
operator|->
name|lioj_queue_count
operator|==
name|lj
operator|->
name|lioj_queue_finished_count
operator|)
condition|)
block|{
name|psignal
argument_list|(
name|lj
operator|->
name|lioj_ki
operator|->
name|kaio_p
argument_list|,
name|lj
operator|->
name|lioj_signal
operator|.
name|sigev_signo
argument_list|)
expr_stmt|;
name|lj
operator|->
name|lioj_flags
operator||=
name|LIOJ_SIGNAL_POSTED
expr_stmt|;
block|}
if|if
condition|(
name|cb
operator|->
name|aio_sigevent
operator|.
name|sigev_notify
operator|==
name|SIGEV_SIGNAL
condition|)
name|psignal
argument_list|(
name|aiocbe
operator|->
name|userproc
argument_list|,
name|cb
operator|->
name|aio_sigevent
operator|.
name|sigev_signo
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Interrupt handler for physio, performs the necessary process wakeups, and  * signals.  */
end_comment

begin_function
specifier|static
name|void
name|aio_physwakeup
parameter_list|(
name|struct
name|buf
modifier|*
name|bp
parameter_list|)
block|{
name|struct
name|aiocblist
modifier|*
name|aiocbe
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|struct
name|kaioinfo
modifier|*
name|ki
decl_stmt|;
name|struct
name|aio_liojob
modifier|*
name|lj
decl_stmt|;
name|int
name|s
decl_stmt|;
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
name|bp
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_flags
operator||=
name|B_DONE
expr_stmt|;
name|aiocbe
operator|=
operator|(
expr|struct
name|aiocblist
operator|*
operator|)
name|bp
operator|->
name|b_spc
expr_stmt|;
if|if
condition|(
name|aiocbe
condition|)
block|{
name|p
operator|=
name|bp
operator|->
name|b_caller1
expr_stmt|;
name|aiocbe
operator|->
name|jobstate
operator|=
name|JOBST_JOBBFINISHED
expr_stmt|;
name|aiocbe
operator|->
name|uaiocb
operator|.
name|_aiocb_private
operator|.
name|status
operator|-=
name|bp
operator|->
name|b_resid
expr_stmt|;
name|aiocbe
operator|->
name|uaiocb
operator|.
name|_aiocb_private
operator|.
name|error
operator|=
literal|0
expr_stmt|;
name|aiocbe
operator|->
name|jobflags
operator||=
name|AIOCBLIST_DONE
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_ioflags
operator|&
name|BIO_ERROR
condition|)
name|aiocbe
operator|->
name|uaiocb
operator|.
name|_aiocb_private
operator|.
name|error
operator|=
name|bp
operator|->
name|b_error
expr_stmt|;
name|lj
operator|=
name|aiocbe
operator|->
name|lio
expr_stmt|;
if|if
condition|(
name|lj
condition|)
block|{
name|lj
operator|->
name|lioj_buffer_finished_count
operator|++
expr_stmt|;
comment|/* 			 * wakeup/signal if all of the interrupt jobs are done. 			 */
if|if
condition|(
name|lj
operator|->
name|lioj_buffer_finished_count
operator|==
name|lj
operator|->
name|lioj_buffer_count
condition|)
block|{
comment|/* 				 * Post a signal if it is called for. 				 */
if|if
condition|(
operator|(
name|lj
operator|->
name|lioj_flags
operator|&
operator|(
name|LIOJ_SIGNAL
operator||
name|LIOJ_SIGNAL_POSTED
operator|)
operator|)
operator|==
name|LIOJ_SIGNAL
condition|)
block|{
name|lj
operator|->
name|lioj_flags
operator||=
name|LIOJ_SIGNAL_POSTED
expr_stmt|;
name|timeout
argument_list|(
name|process_signal
argument_list|,
name|aiocbe
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|ki
operator|=
name|p
operator|->
name|p_aioinfo
expr_stmt|;
if|if
condition|(
name|ki
condition|)
block|{
name|ki
operator|->
name|kaio_buffer_finished_count
operator|++
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|aio_bufjobs
argument_list|,
name|aiocbe
argument_list|,
name|list
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|ki
operator|->
name|kaio_bufqueue
argument_list|,
name|aiocbe
argument_list|,
name|plist
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|ki
operator|->
name|kaio_bufdone
argument_list|,
name|aiocbe
argument_list|,
name|plist
argument_list|)
expr_stmt|;
name|KNOTE
argument_list|(
operator|&
name|aiocbe
operator|->
name|klist
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Do the wakeup. */
if|if
condition|(
name|ki
operator|->
name|kaio_flags
operator|&
operator|(
name|KAIO_RUNDOWN
operator||
name|KAIO_WAKEUP
operator|)
condition|)
block|{
name|ki
operator|->
name|kaio_flags
operator|&=
operator|~
name|KAIO_WAKEUP
expr_stmt|;
name|wakeup
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|aiocbe
operator|->
name|uaiocb
operator|.
name|aio_sigevent
operator|.
name|sigev_notify
operator|==
name|SIGEV_SIGNAL
condition|)
name|timeout
argument_list|(
name|process_signal
argument_list|,
name|aiocbe
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|aio_waitcomplete
parameter_list|(
name|struct
name|proc
modifier|*
name|p
parameter_list|,
name|struct
name|aio_waitcomplete_args
modifier|*
name|uap
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|VFS_AIO
return|return
name|ENOSYS
return|;
else|#
directive|else
name|struct
name|timeval
name|atv
decl_stmt|;
name|struct
name|timespec
name|ts
decl_stmt|;
name|struct
name|aiocb
modifier|*
modifier|*
name|cbptr
decl_stmt|;
name|struct
name|kaioinfo
modifier|*
name|ki
decl_stmt|;
name|struct
name|aiocblist
modifier|*
name|cb
init|=
name|NULL
decl_stmt|;
name|int
name|error
decl_stmt|,
name|s
decl_stmt|,
name|timo
decl_stmt|;
name|suword
argument_list|(
name|uap
operator|->
name|aiocbp
argument_list|,
operator|(
name|int
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|timo
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|uap
operator|->
name|timeout
condition|)
block|{
comment|/* Get timespec struct. */
name|error
operator|=
name|copyin
argument_list|(
operator|(
name|caddr_t
operator|)
name|uap
operator|->
name|timeout
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|ts
argument_list|,
sizeof|sizeof
argument_list|(
name|ts
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
if|if
condition|(
operator|(
name|ts
operator|.
name|tv_nsec
operator|<
literal|0
operator|)
operator|||
operator|(
name|ts
operator|.
name|tv_nsec
operator|>=
literal|1000000000
operator|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|TIMESPEC_TO_TIMEVAL
argument_list|(
operator|&
name|atv
argument_list|,
operator|&
name|ts
argument_list|)
expr_stmt|;
if|if
condition|(
name|itimerfix
argument_list|(
operator|&
name|atv
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|timo
operator|=
name|tvtohz
argument_list|(
operator|&
name|atv
argument_list|)
expr_stmt|;
block|}
name|ki
operator|=
name|p
operator|->
name|p_aioinfo
expr_stmt|;
if|if
condition|(
name|ki
operator|==
name|NULL
condition|)
return|return
name|EAGAIN
return|;
name|cbptr
operator|=
name|uap
operator|->
name|aiocbp
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|(
name|cb
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|ki
operator|->
name|kaio_jobdone
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|suword
argument_list|(
name|uap
operator|->
name|aiocbp
argument_list|,
operator|(
name|int
operator|)
name|cb
operator|->
name|uuaiocb
argument_list|)
expr_stmt|;
name|p
operator|->
name|p_retval
index|[
literal|0
index|]
operator|=
name|cb
operator|->
name|uaiocb
operator|.
name|_aiocb_private
operator|.
name|status
expr_stmt|;
if|if
condition|(
name|cb
operator|->
name|uaiocb
operator|.
name|aio_lio_opcode
operator|==
name|LIO_WRITE
condition|)
block|{
name|curproc
operator|->
name|p_stats
operator|->
name|p_ru
operator|.
name|ru_oublock
operator|+=
name|cb
operator|->
name|outputcharge
expr_stmt|;
name|cb
operator|->
name|outputcharge
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cb
operator|->
name|uaiocb
operator|.
name|aio_lio_opcode
operator|==
name|LIO_READ
condition|)
block|{
name|curproc
operator|->
name|p_stats
operator|->
name|p_ru
operator|.
name|ru_inblock
operator|+=
name|cb
operator|->
name|inputcharge
expr_stmt|;
name|cb
operator|->
name|inputcharge
operator|=
literal|0
expr_stmt|;
block|}
name|aio_free_entry
argument_list|(
name|cb
argument_list|)
expr_stmt|;
return|return
name|cb
operator|->
name|uaiocb
operator|.
name|_aiocb_private
operator|.
name|error
return|;
block|}
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|cb
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|ki
operator|->
name|kaio_bufdone
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|suword
argument_list|(
name|uap
operator|->
name|aiocbp
argument_list|,
operator|(
name|int
operator|)
name|cb
operator|->
name|uuaiocb
argument_list|)
expr_stmt|;
name|p
operator|->
name|p_retval
index|[
literal|0
index|]
operator|=
name|cb
operator|->
name|uaiocb
operator|.
name|_aiocb_private
operator|.
name|status
expr_stmt|;
name|aio_free_entry
argument_list|(
name|cb
argument_list|)
expr_stmt|;
return|return
name|cb
operator|->
name|uaiocb
operator|.
name|_aiocb_private
operator|.
name|error
return|;
block|}
name|ki
operator|->
name|kaio_flags
operator||=
name|KAIO_WAKEUP
expr_stmt|;
name|error
operator|=
name|tsleep
argument_list|(
name|p
argument_list|,
name|PRIBIO
operator||
name|PCATCH
argument_list|,
literal|"aiowc"
argument_list|,
name|timo
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|ERESTART
condition|)
return|return
name|EINTR
return|;
elseif|else
if|if
condition|(
name|error
operator|<
literal|0
condition|)
return|return
name|error
return|;
elseif|else
if|if
condition|(
name|error
operator|==
name|EINTR
condition|)
return|return
name|EINTR
return|;
elseif|else
if|if
condition|(
name|error
operator|==
name|EWOULDBLOCK
condition|)
return|return
name|EAGAIN
return|;
block|}
endif|#
directive|endif
comment|/* VFS_AIO */
block|}
end_function

begin_function
specifier|static
name|int
name|filt_aioattach
parameter_list|(
name|struct
name|knote
modifier|*
name|kn
parameter_list|)
block|{
name|struct
name|aiocblist
modifier|*
name|aiocbe
init|=
operator|(
expr|struct
name|aiocblist
operator|*
operator|)
name|kn
operator|->
name|kn_id
decl_stmt|;
comment|/* 	 * The aiocbe pointer must be validated before using it, so 	 * registration is restricted to the kernel; the user cannot 	 * set EV_FLAG1. 	 */
if|if
condition|(
operator|(
name|kn
operator|->
name|kn_flags
operator|&
name|EV_FLAG1
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|EPERM
operator|)
return|;
name|kn
operator|->
name|kn_flags
operator|&=
operator|~
name|EV_FLAG1
expr_stmt|;
name|SLIST_INSERT_HEAD
argument_list|(
operator|&
name|aiocbe
operator|->
name|klist
argument_list|,
name|kn
argument_list|,
name|kn_selnext
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|filt_aiodetach
parameter_list|(
name|struct
name|knote
modifier|*
name|kn
parameter_list|)
block|{
name|struct
name|aiocblist
modifier|*
name|aiocbe
init|=
operator|(
expr|struct
name|aiocblist
operator|*
operator|)
name|kn
operator|->
name|kn_id
decl_stmt|;
name|int
name|s
init|=
name|splhigh
argument_list|()
decl_stmt|;
comment|/* XXX no clue, so overkill */
name|SLIST_REMOVE
argument_list|(
operator|&
name|aiocbe
operator|->
name|klist
argument_list|,
name|kn
argument_list|,
name|knote
argument_list|,
name|kn_selnext
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|int
name|filt_aio
parameter_list|(
name|struct
name|knote
modifier|*
name|kn
parameter_list|,
name|long
name|hint
parameter_list|)
block|{
name|struct
name|aiocblist
modifier|*
name|aiocbe
init|=
operator|(
expr|struct
name|aiocblist
operator|*
operator|)
name|kn
operator|->
name|kn_id
decl_stmt|;
name|kn
operator|->
name|kn_data
operator|=
literal|0
expr_stmt|;
comment|/* XXX data returned? */
if|if
condition|(
name|aiocbe
operator|->
name|jobstate
operator|!=
name|JOBST_JOBFINISHED
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|kn
operator|->
name|kn_flags
operator||=
name|EV_EOF
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

end_unit

