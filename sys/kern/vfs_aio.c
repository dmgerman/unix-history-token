begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1997 John S. Dyson.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. John S. Dyson's name may not be used to endorse or promote products  *    derived from this software without specific prior written permission.  *  * DISCLAIMER:  This code isn't warranted to do anything useful.  Anything  * bad that happens because of using this software isn't the responsibility  * of the author.  This software is distributed AS-IS.  *  * $Id$  */
end_comment

begin_comment
comment|/*  * This file contains support for the POSIX.4 AIO facility.  *  * The initial version provides only the (bogus) synchronous semantics  * but will support async in the future.  Note that a bit  * in a private field allows the user mode subroutine to adapt  * the kernel operations to true POSIX.4 for future compatibility.  *  * This code is used to support true POSIX.4 AIO/LIO with the help  * of a user mode subroutine package.  Note that eventually more support  * will be pushed into the kernel.  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysent.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysproto.h>
end_include

begin_include
include|#
directive|include
file|<sys/namei.h>
end_include

begin_include
include|#
directive|include
file|<sys/filedesc.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/unistd.h>
end_include

begin_include
include|#
directive|include
file|<sys/vnode.h>
end_include

begin_include
include|#
directive|include
file|<sys/mount.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/dirent.h>
end_include

begin_include
include|#
directive|include
file|<sys/signalvar.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_param.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_object.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_extern.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/aio.h>
end_include

begin_comment
comment|/*  * aio_cancel at the kernel level is a NOOP right now.  It  * might be possible to support it partially in user mode, or  * in kernel mode later on.  */
end_comment

begin_function
name|int
name|aio_cancel
parameter_list|(
name|struct
name|proc
modifier|*
name|p
parameter_list|,
name|struct
name|aio_cancel_args
modifier|*
name|uap
parameter_list|,
name|int
modifier|*
name|retval
parameter_list|)
block|{
return|return
name|AIO_NOTCANCELLED
return|;
block|}
end_function

begin_comment
comment|/*  * aio_error is implemented in the kernel level for compatibility  * purposes only.  For a user mode async implementation, it would be  * best to do it in a userland subroutine.  */
end_comment

begin_function
name|int
name|aio_error
parameter_list|(
name|struct
name|proc
modifier|*
name|p
parameter_list|,
name|struct
name|aio_error_args
modifier|*
name|uap
parameter_list|,
name|int
modifier|*
name|retval
parameter_list|)
block|{
name|int
name|activeflag
decl_stmt|,
name|errorcode
decl_stmt|;
name|struct
name|aiocb
name|iocb
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* 	 * Get control block 	 */
if|if
condition|(
name|error
operator|=
name|copyin
argument_list|(
operator|(
name|caddr_t
operator|)
name|uap
operator|->
name|aiocbp
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|iocb
argument_list|,
sizeof|sizeof
name|iocb
argument_list|)
condition|)
return|return
name|error
return|;
if|if
condition|(
name|iocb
operator|.
name|_aiocb_private
operator|.
name|active
operator|==
operator|-
literal|1
condition|)
return|return
name|EFAULT
return|;
if|if
condition|(
name|iocb
operator|.
name|_aiocb_private
operator|.
name|active
operator|!=
name|AIO_PMODE_ACTIVE
condition|)
block|{
name|retval
index|[
literal|0
index|]
operator|=
name|EINVAL
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|retval
index|[
literal|0
index|]
operator|=
name|iocb
operator|.
name|_aiocb_private
operator|.
name|error
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|aio_read
parameter_list|(
name|struct
name|proc
modifier|*
name|p
parameter_list|,
name|struct
name|aio_read_args
modifier|*
name|uap
parameter_list|,
name|int
modifier|*
name|retval
parameter_list|)
block|{
name|struct
name|filedesc
modifier|*
name|fdp
decl_stmt|;
name|struct
name|file
modifier|*
name|fp
decl_stmt|;
name|struct
name|uio
name|auio
decl_stmt|;
name|struct
name|iovec
name|aiov
decl_stmt|;
name|unsigned
name|int
name|fd
decl_stmt|;
name|int
name|cnt
decl_stmt|;
name|struct
name|aiocb
name|iocb
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* 	 * Get control block 	 */
if|if
condition|(
name|error
operator|=
name|copyin
argument_list|(
operator|(
name|caddr_t
operator|)
name|uap
operator|->
name|aiocbp
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|iocb
argument_list|,
sizeof|sizeof
name|iocb
argument_list|)
condition|)
return|return
name|error
return|;
comment|/* 	 * We support sync only for now. 	 */
if|if
condition|(
operator|(
name|iocb
operator|.
name|_aiocb_private
operator|.
name|privatemodes
operator|&
name|AIO_PMODE_SYNC
operator|)
operator|==
literal|0
condition|)
return|return
name|ENOSYS
return|;
comment|/* 	 * Get the fd info for process 	 */
name|fdp
operator|=
name|p
operator|->
name|p_fd
expr_stmt|;
comment|/* 	 * Range check file descriptor 	 */
name|fd
operator|=
name|iocb
operator|.
name|aio_fildes
expr_stmt|;
if|if
condition|(
name|fd
operator|>=
name|fdp
operator|->
name|fd_nfiles
condition|)
return|return
name|EBADF
return|;
name|fp
operator|=
name|fdp
operator|->
name|fd_ofiles
index|[
name|fd
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|fp
operator|==
name|NULL
operator|)
operator|||
operator|(
operator|(
name|fp
operator|->
name|f_flag
operator|&
name|FREAD
operator|)
operator|==
literal|0
operator|)
condition|)
return|return
name|EBADF
return|;
if|if
condition|(
operator|(
operator|(
name|int
operator|)
name|iocb
operator|.
name|aio_offset
operator|)
operator|==
operator|-
literal|1
condition|)
return|return
name|EINVAL
return|;
name|aiov
operator|.
name|iov_base
operator|=
name|iocb
operator|.
name|aio_buf
expr_stmt|;
name|aiov
operator|.
name|iov_len
operator|=
name|iocb
operator|.
name|aio_nbytes
expr_stmt|;
name|auio
operator|.
name|uio_iov
operator|=
operator|&
name|aiov
expr_stmt|;
name|auio
operator|.
name|uio_iovcnt
operator|=
literal|1
expr_stmt|;
name|auio
operator|.
name|uio_offset
operator|=
name|iocb
operator|.
name|aio_offset
expr_stmt|;
name|auio
operator|.
name|uio_resid
operator|=
name|iocb
operator|.
name|aio_nbytes
expr_stmt|;
if|if
condition|(
name|auio
operator|.
name|uio_resid
operator|<
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|auio
operator|.
name|uio_rw
operator|=
name|UIO_READ
expr_stmt|;
name|auio
operator|.
name|uio_segflg
operator|=
name|UIO_USERSPACE
expr_stmt|;
name|auio
operator|.
name|uio_procp
operator|=
name|p
expr_stmt|;
name|cnt
operator|=
name|iocb
operator|.
name|aio_nbytes
expr_stmt|;
name|error
operator|=
call|(
modifier|*
name|fp
operator|->
name|f_ops
operator|->
name|fo_read
call|)
argument_list|(
name|fp
argument_list|,
operator|&
name|auio
argument_list|,
name|fp
operator|->
name|f_cred
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|&&
operator|(
name|auio
operator|.
name|uio_resid
operator|!=
name|cnt
operator|)
operator|&&
operator|(
name|error
operator|==
name|ERESTART
operator|||
name|error
operator|==
name|EINTR
operator|||
name|error
operator|==
name|EWOULDBLOCK
operator|)
condition|)
name|error
operator|=
literal|0
expr_stmt|;
name|cnt
operator|-=
name|auio
operator|.
name|uio_resid
expr_stmt|;
operator|*
name|retval
operator|=
name|cnt
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  * Return and suspend aren't supported (yet).  */
end_comment

begin_function
name|int
name|aio_return
parameter_list|(
name|struct
name|proc
modifier|*
name|p
parameter_list|,
name|struct
name|aio_return_args
modifier|*
name|uap
parameter_list|,
name|int
modifier|*
name|retval
parameter_list|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|aio_suspend
parameter_list|(
name|struct
name|proc
modifier|*
name|p
parameter_list|,
name|struct
name|aio_suspend_args
modifier|*
name|uap
parameter_list|,
name|int
modifier|*
name|retval
parameter_list|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|aio_write
parameter_list|(
name|struct
name|proc
modifier|*
name|p
parameter_list|,
name|struct
name|aio_write_args
modifier|*
name|uap
parameter_list|,
name|int
modifier|*
name|retval
parameter_list|)
block|{
name|struct
name|filedesc
modifier|*
name|fdp
decl_stmt|;
name|struct
name|file
modifier|*
name|fp
decl_stmt|;
name|struct
name|uio
name|auio
decl_stmt|;
name|struct
name|iovec
name|aiov
decl_stmt|;
name|unsigned
name|int
name|fd
decl_stmt|;
name|int
name|cnt
decl_stmt|;
name|struct
name|aiocb
name|iocb
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|error
operator|=
name|copyin
argument_list|(
operator|(
name|caddr_t
operator|)
name|uap
operator|->
name|aiocbp
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|iocb
argument_list|,
sizeof|sizeof
name|iocb
argument_list|)
condition|)
return|return
name|error
return|;
comment|/* 	 * We support sync only for now. 	 */
if|if
condition|(
operator|(
name|iocb
operator|.
name|_aiocb_private
operator|.
name|privatemodes
operator|&
name|AIO_PMODE_SYNC
operator|)
operator|==
literal|0
condition|)
return|return
name|ENOSYS
return|;
comment|/* 	 * Get the fd info for process 	 */
name|fdp
operator|=
name|p
operator|->
name|p_fd
expr_stmt|;
comment|/* 	 * Range check file descriptor 	 */
name|fd
operator|=
name|iocb
operator|.
name|aio_fildes
expr_stmt|;
if|if
condition|(
name|fd
operator|>=
name|fdp
operator|->
name|fd_nfiles
condition|)
return|return
name|EBADF
return|;
name|fp
operator|=
name|fdp
operator|->
name|fd_ofiles
index|[
name|fd
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|fp
operator|==
name|NULL
operator|)
operator|||
operator|(
operator|(
name|fp
operator|->
name|f_flag
operator|&
name|FWRITE
operator|)
operator|==
literal|0
operator|)
condition|)
return|return
name|EBADF
return|;
if|if
condition|(
operator|(
operator|(
name|int
operator|)
name|iocb
operator|.
name|aio_offset
operator|)
operator|==
operator|-
literal|1
condition|)
return|return
name|EINVAL
return|;
name|aiov
operator|.
name|iov_base
operator|=
name|iocb
operator|.
name|aio_buf
expr_stmt|;
name|aiov
operator|.
name|iov_len
operator|=
name|iocb
operator|.
name|aio_nbytes
expr_stmt|;
name|auio
operator|.
name|uio_iov
operator|=
operator|&
name|aiov
expr_stmt|;
name|auio
operator|.
name|uio_iovcnt
operator|=
literal|1
expr_stmt|;
name|auio
operator|.
name|uio_offset
operator|=
name|iocb
operator|.
name|aio_offset
expr_stmt|;
name|auio
operator|.
name|uio_resid
operator|=
name|iocb
operator|.
name|aio_nbytes
expr_stmt|;
if|if
condition|(
name|auio
operator|.
name|uio_resid
operator|<
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|auio
operator|.
name|uio_rw
operator|=
name|UIO_WRITE
expr_stmt|;
name|auio
operator|.
name|uio_segflg
operator|=
name|UIO_USERSPACE
expr_stmt|;
name|auio
operator|.
name|uio_procp
operator|=
name|p
expr_stmt|;
name|cnt
operator|=
name|iocb
operator|.
name|aio_nbytes
expr_stmt|;
name|error
operator|=
call|(
modifier|*
name|fp
operator|->
name|f_ops
operator|->
name|fo_write
call|)
argument_list|(
name|fp
argument_list|,
operator|&
name|auio
argument_list|,
name|fp
operator|->
name|f_cred
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
if|if
condition|(
name|auio
operator|.
name|uio_resid
operator|!=
name|cnt
condition|)
block|{
if|if
condition|(
name|error
operator|==
name|ERESTART
operator|||
name|error
operator|==
name|EINTR
operator|||
name|error
operator|==
name|EWOULDBLOCK
condition|)
name|error
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|EPIPE
condition|)
name|psignal
argument_list|(
name|p
argument_list|,
name|SIGPIPE
argument_list|)
expr_stmt|;
block|}
block|}
name|cnt
operator|-=
name|auio
operator|.
name|uio_resid
expr_stmt|;
operator|*
name|retval
operator|=
name|cnt
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_function
name|int
name|lio_listio
parameter_list|(
name|struct
name|proc
modifier|*
name|p
parameter_list|,
name|struct
name|lio_listio_args
modifier|*
name|uap
parameter_list|,
name|int
modifier|*
name|retval
parameter_list|)
block|{
name|struct
name|filedesc
modifier|*
name|fdp
decl_stmt|;
name|struct
name|file
modifier|*
name|fp
decl_stmt|;
name|struct
name|uio
name|auio
decl_stmt|;
name|struct
name|iovec
name|aiov
decl_stmt|;
name|unsigned
name|int
name|fd
decl_stmt|;
name|int
name|cnt
decl_stmt|;
name|unsigned
name|int
name|iocblen
decl_stmt|,
name|iocbcnt
decl_stmt|;
name|struct
name|aiocb
modifier|*
name|iocb
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|uap
operator|->
name|mode
operator|==
name|LIO_NOWAIT
condition|)
return|return
name|ENOSYS
return|;
name|iocbcnt
operator|=
name|uap
operator|->
name|nent
expr_stmt|;
if|if
condition|(
name|iocbcnt
operator|>
name|AIO_LISTIO_MAX
condition|)
return|return
name|EINVAL
return|;
return|return
name|ENOSYS
return|;
block|}
end_function

end_unit

