begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1997 John S. Dyson.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. John S. Dyson's name may not be used to endorse or promote products  *    derived from this software without specific prior written permission.  *  * DISCLAIMER:  This code isn't warranted to do anything useful.  Anything  * bad that happens because of using this software isn't the responsibility  * of the author.  This software is distributed AS-IS.  */
end_comment

begin_comment
comment|/*  * This file contains support for the POSIX 1003.1B AIO/LIO facility.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"opt_compat.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/bio.h>
end_include

begin_include
include|#
directive|include
file|<sys/buf.h>
end_include

begin_include
include|#
directive|include
file|<sys/capsicum.h>
end_include

begin_include
include|#
directive|include
file|<sys/eventhandler.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysproto.h>
end_include

begin_include
include|#
directive|include
file|<sys/filedesc.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/kthread.h>
end_include

begin_include
include|#
directive|include
file|<sys/fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/limits.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/unistd.h>
end_include

begin_include
include|#
directive|include
file|<sys/posix4.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/resourcevar.h>
end_include

begin_include
include|#
directive|include
file|<sys/signalvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/syscallsubr.h>
end_include

begin_include
include|#
directive|include
file|<sys/protosw.h>
end_include

begin_include
include|#
directive|include
file|<sys/rwlock.h>
end_include

begin_include
include|#
directive|include
file|<sys/sema.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/socketvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/syscall.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysent.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/syslog.h>
end_include

begin_include
include|#
directive|include
file|<sys/sx.h>
end_include

begin_include
include|#
directive|include
file|<sys/taskqueue.h>
end_include

begin_include
include|#
directive|include
file|<sys/vnode.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/event.h>
end_include

begin_include
include|#
directive|include
file|<sys/mount.h>
end_include

begin_include
include|#
directive|include
file|<geom/geom.h>
end_include

begin_include
include|#
directive|include
file|<machine/atomic.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_page.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_extern.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_map.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_object.h>
end_include

begin_include
include|#
directive|include
file|<vm/uma.h>
end_include

begin_include
include|#
directive|include
file|<sys/aio.h>
end_include

begin_comment
comment|/*  * Counter for allocating reference ids to new jobs.  Wrapped to 1 on  * overflow. (XXX will be removed soon.)  */
end_comment

begin_decl_stmt
specifier|static
name|u_long
name|jobrefid
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Counter for aio_fsync.  */
end_comment

begin_decl_stmt
specifier|static
name|uint64_t
name|jobseqno
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|MAX_AIO_PER_PROC
end_ifndef

begin_define
define|#
directive|define
name|MAX_AIO_PER_PROC
value|32
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|MAX_AIO_QUEUE_PER_PROC
end_ifndef

begin_define
define|#
directive|define
name|MAX_AIO_QUEUE_PER_PROC
value|256
end_define

begin_comment
comment|/* Bigger than AIO_LISTIO_MAX */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|MAX_AIO_QUEUE
end_ifndef

begin_define
define|#
directive|define
name|MAX_AIO_QUEUE
value|1024
end_define

begin_comment
comment|/* Bigger than AIO_LISTIO_MAX */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|MAX_BUF_AIO
end_ifndef

begin_define
define|#
directive|define
name|MAX_BUF_AIO
value|16
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_expr_stmt
name|FEATURE
argument_list|(
name|aio
argument_list|,
literal|"Asynchronous I/O"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|MALLOC_DEFINE
argument_list|(
name|M_LIO
argument_list|,
literal|"lio"
argument_list|,
literal|"listio aio control block list"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|SYSCTL_NODE
argument_list|(
name|_vfs
argument_list|,
name|OID_AUTO
argument_list|,
name|aio
argument_list|,
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
literal|"Async IO management"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|enable_aio_unsafe
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vfs_aio
argument_list|,
name|OID_AUTO
argument_list|,
name|enable_unsafe
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|enable_aio_unsafe
argument_list|,
literal|0
argument_list|,
literal|"Permit asynchronous IO on all file types, not just known-safe types"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|unsafe_warningcnt
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_vfs_aio
argument_list|,
name|OID_AUTO
argument_list|,
name|unsafe_warningcnt
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|unsafe_warningcnt
argument_list|,
literal|0
argument_list|,
literal|"Warnings that will be triggered upon failed IO requests on unsafe files"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|max_aio_procs
init|=
name|MAX_AIO_PROCS
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vfs_aio
argument_list|,
name|OID_AUTO
argument_list|,
name|max_aio_procs
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|max_aio_procs
argument_list|,
literal|0
argument_list|,
literal|"Maximum number of kernel processes to use for handling async IO "
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|num_aio_procs
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vfs_aio
argument_list|,
name|OID_AUTO
argument_list|,
name|num_aio_procs
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|num_aio_procs
argument_list|,
literal|0
argument_list|,
literal|"Number of presently active kernel processes for async IO"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * The code will adjust the actual number of AIO processes towards this  * number when it gets a chance.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|target_aio_procs
init|=
name|TARGET_AIO_PROCS
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vfs_aio
argument_list|,
name|OID_AUTO
argument_list|,
name|target_aio_procs
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|target_aio_procs
argument_list|,
literal|0
argument_list|,
literal|"Preferred number of ready kernel processes for async IO"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|max_queue_count
init|=
name|MAX_AIO_QUEUE
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vfs_aio
argument_list|,
name|OID_AUTO
argument_list|,
name|max_aio_queue
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|max_queue_count
argument_list|,
literal|0
argument_list|,
literal|"Maximum number of aio requests to queue, globally"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|num_queue_count
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vfs_aio
argument_list|,
name|OID_AUTO
argument_list|,
name|num_queue_count
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|num_queue_count
argument_list|,
literal|0
argument_list|,
literal|"Number of queued aio requests"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|num_buf_aio
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vfs_aio
argument_list|,
name|OID_AUTO
argument_list|,
name|num_buf_aio
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|num_buf_aio
argument_list|,
literal|0
argument_list|,
literal|"Number of aio requests presently handled by the buf subsystem"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Number of async I/O processes in the process of being started */
end_comment

begin_comment
comment|/* XXX This should be local to aio_aqueue() */
end_comment

begin_decl_stmt
specifier|static
name|int
name|num_aio_resv_start
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|aiod_lifetime
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vfs_aio
argument_list|,
name|OID_AUTO
argument_list|,
name|aiod_lifetime
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|aiod_lifetime
argument_list|,
literal|0
argument_list|,
literal|"Maximum lifetime for idle aiod"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|max_aio_per_proc
init|=
name|MAX_AIO_PER_PROC
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vfs_aio
argument_list|,
name|OID_AUTO
argument_list|,
name|max_aio_per_proc
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|max_aio_per_proc
argument_list|,
literal|0
argument_list|,
literal|"Maximum active aio requests per process (stored in the process)"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|max_aio_queue_per_proc
init|=
name|MAX_AIO_QUEUE_PER_PROC
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vfs_aio
argument_list|,
name|OID_AUTO
argument_list|,
name|max_aio_queue_per_proc
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|max_aio_queue_per_proc
argument_list|,
literal|0
argument_list|,
literal|"Maximum queued aio requests per process (stored in the process)"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|max_buf_aio
init|=
name|MAX_BUF_AIO
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vfs_aio
argument_list|,
name|OID_AUTO
argument_list|,
name|max_buf_aio
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|max_buf_aio
argument_list|,
literal|0
argument_list|,
literal|"Maximum buf aio requests per process (stored in the process)"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|COMPAT_FREEBSD6
end_ifdef

begin_typedef
typedef|typedef
struct|struct
name|oaiocb
block|{
name|int
name|aio_fildes
decl_stmt|;
comment|/* File descriptor */
name|off_t
name|aio_offset
decl_stmt|;
comment|/* File offset for I/O */
specifier|volatile
name|void
modifier|*
name|aio_buf
decl_stmt|;
comment|/* I/O buffer in process space */
name|size_t
name|aio_nbytes
decl_stmt|;
comment|/* Number of bytes for I/O */
name|struct
name|osigevent
name|aio_sigevent
decl_stmt|;
comment|/* Signal to deliver */
name|int
name|aio_lio_opcode
decl_stmt|;
comment|/* LIO opcode */
name|int
name|aio_reqprio
decl_stmt|;
comment|/* Request priority -- ignored */
name|struct
name|__aiocb_private
name|_aiocb_private
decl_stmt|;
block|}
name|oaiocb_t
typedef|;
end_typedef

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Below is a key of locks used to protect each member of struct kaiocb  * aioliojob and kaioinfo and any backends.  *  * * - need not protected  * a - locked by kaioinfo lock  * b - locked by backend lock, the backend lock can be null in some cases,  *     for example, BIO belongs to this type, in this case, proc lock is  *     reused.  * c - locked by aio_job_mtx, the lock for the generic file I/O backend.  */
end_comment

begin_comment
comment|/*  * If the routine that services an AIO request blocks while running in an  * AIO kernel process it can starve other I/O requests.  BIO requests  * queued via aio_qphysio() complete in GEOM and do not use AIO kernel  * processes at all.  Socket I/O requests use a separate pool of  * kprocs and also force non-blocking I/O.  Other file I/O requests  * use the generic fo_read/fo_write operations which can block.  The  * fsync and mlock operations can also block while executing.  Ideally  * none of these requests would block while executing.  *  * Note that the service routines cannot toggle O_NONBLOCK in the file  * structure directly while handling a request due to races with  * userland threads.  */
end_comment

begin_comment
comment|/* jobflags */
end_comment

begin_define
define|#
directive|define
name|KAIOCB_QUEUEING
value|0x01
end_define

begin_define
define|#
directive|define
name|KAIOCB_CANCELLED
value|0x02
end_define

begin_define
define|#
directive|define
name|KAIOCB_CANCELLING
value|0x04
end_define

begin_define
define|#
directive|define
name|KAIOCB_CHECKSYNC
value|0x08
end_define

begin_define
define|#
directive|define
name|KAIOCB_CLEARED
value|0x10
end_define

begin_define
define|#
directive|define
name|KAIOCB_FINISHED
value|0x20
end_define

begin_comment
comment|/*  * AIO process info  */
end_comment

begin_define
define|#
directive|define
name|AIOP_FREE
value|0x1
end_define

begin_comment
comment|/* proc on free queue */
end_comment

begin_struct
struct|struct
name|aioproc
block|{
name|int
name|aioprocflags
decl_stmt|;
comment|/* (c) AIO proc flags */
name|TAILQ_ENTRY
argument_list|(
argument|aioproc
argument_list|)
name|list
expr_stmt|;
comment|/* (c) list of processes */
name|struct
name|proc
modifier|*
name|aioproc
decl_stmt|;
comment|/* (*) the AIO proc */
block|}
struct|;
end_struct

begin_comment
comment|/*  * data-structure for lio signal management  */
end_comment

begin_struct
struct|struct
name|aioliojob
block|{
name|int
name|lioj_flags
decl_stmt|;
comment|/* (a) listio flags */
name|int
name|lioj_count
decl_stmt|;
comment|/* (a) listio flags */
name|int
name|lioj_finished_count
decl_stmt|;
comment|/* (a) listio flags */
name|struct
name|sigevent
name|lioj_signal
decl_stmt|;
comment|/* (a) signal on all I/O done */
name|TAILQ_ENTRY
argument_list|(
argument|aioliojob
argument_list|)
name|lioj_list
expr_stmt|;
comment|/* (a) lio list */
name|struct
name|knlist
name|klist
decl_stmt|;
comment|/* (a) list of knotes */
name|ksiginfo_t
name|lioj_ksi
decl_stmt|;
comment|/* (a) Realtime signal info */
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|LIOJ_SIGNAL
value|0x1
end_define

begin_comment
comment|/* signal on all done (lio) */
end_comment

begin_define
define|#
directive|define
name|LIOJ_SIGNAL_POSTED
value|0x2
end_define

begin_comment
comment|/* signal has been posted */
end_comment

begin_define
define|#
directive|define
name|LIOJ_KEVENT_POSTED
value|0x4
end_define

begin_comment
comment|/* kevent triggered */
end_comment

begin_comment
comment|/*  * per process aio data structure  */
end_comment

begin_struct
struct|struct
name|kaioinfo
block|{
name|struct
name|mtx
name|kaio_mtx
decl_stmt|;
comment|/* the lock to protect this struct */
name|int
name|kaio_flags
decl_stmt|;
comment|/* (a) per process kaio flags */
name|int
name|kaio_maxactive_count
decl_stmt|;
comment|/* (*) maximum number of AIOs */
name|int
name|kaio_active_count
decl_stmt|;
comment|/* (c) number of currently used AIOs */
name|int
name|kaio_qallowed_count
decl_stmt|;
comment|/* (*) maxiumu size of AIO queue */
name|int
name|kaio_count
decl_stmt|;
comment|/* (a) size of AIO queue */
name|int
name|kaio_ballowed_count
decl_stmt|;
comment|/* (*) maximum number of buffers */
name|int
name|kaio_buffer_count
decl_stmt|;
comment|/* (a) number of physio buffers */
name|TAILQ_HEAD
argument_list|(
argument_list|,
argument|kaiocb
argument_list|)
name|kaio_all
expr_stmt|;
comment|/* (a) all AIOs in a process */
name|TAILQ_HEAD
argument_list|(
argument_list|,
argument|kaiocb
argument_list|)
name|kaio_done
expr_stmt|;
comment|/* (a) done queue for process */
name|TAILQ_HEAD
argument_list|(
argument_list|,
argument|aioliojob
argument_list|)
name|kaio_liojoblist
expr_stmt|;
comment|/* (a) list of lio jobs */
name|TAILQ_HEAD
argument_list|(
argument_list|,
argument|kaiocb
argument_list|)
name|kaio_jobqueue
expr_stmt|;
comment|/* (a) job queue for process */
name|TAILQ_HEAD
argument_list|(
argument_list|,
argument|kaiocb
argument_list|)
name|kaio_syncqueue
expr_stmt|;
comment|/* (a) queue for aio_fsync */
name|TAILQ_HEAD
argument_list|(
argument_list|,
argument|kaiocb
argument_list|)
name|kaio_syncready
expr_stmt|;
comment|/* (a) second q for aio_fsync */
name|struct
name|task
name|kaio_task
decl_stmt|;
comment|/* (*) task to kick aio processes */
name|struct
name|task
name|kaio_sync_task
decl_stmt|;
comment|/* (*) task to schedule fsync jobs */
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|AIO_LOCK
parameter_list|(
name|ki
parameter_list|)
value|mtx_lock(&(ki)->kaio_mtx)
end_define

begin_define
define|#
directive|define
name|AIO_UNLOCK
parameter_list|(
name|ki
parameter_list|)
value|mtx_unlock(&(ki)->kaio_mtx)
end_define

begin_define
define|#
directive|define
name|AIO_LOCK_ASSERT
parameter_list|(
name|ki
parameter_list|,
name|f
parameter_list|)
value|mtx_assert(&(ki)->kaio_mtx, (f))
end_define

begin_define
define|#
directive|define
name|AIO_MTX
parameter_list|(
name|ki
parameter_list|)
value|(&(ki)->kaio_mtx)
end_define

begin_define
define|#
directive|define
name|KAIO_RUNDOWN
value|0x1
end_define

begin_comment
comment|/* process is being run down */
end_comment

begin_define
define|#
directive|define
name|KAIO_WAKEUP
value|0x2
end_define

begin_comment
comment|/* wakeup process when AIO completes */
end_comment

begin_comment
comment|/*  * Operations used to interact with userland aio control blocks.  * Different ABIs provide their own operations.  */
end_comment

begin_struct
struct|struct
name|aiocb_ops
block|{
name|int
function_decl|(
modifier|*
name|copyin
function_decl|)
parameter_list|(
name|struct
name|aiocb
modifier|*
name|ujob
parameter_list|,
name|struct
name|aiocb
modifier|*
name|kjob
parameter_list|)
function_decl|;
name|long
function_decl|(
modifier|*
name|fetch_status
function_decl|)
parameter_list|(
name|struct
name|aiocb
modifier|*
name|ujob
parameter_list|)
function_decl|;
name|long
function_decl|(
modifier|*
name|fetch_error
function_decl|)
parameter_list|(
name|struct
name|aiocb
modifier|*
name|ujob
parameter_list|)
function_decl|;
name|int
function_decl|(
modifier|*
name|store_status
function_decl|)
parameter_list|(
name|struct
name|aiocb
modifier|*
name|ujob
parameter_list|,
name|long
name|status
parameter_list|)
function_decl|;
name|int
function_decl|(
modifier|*
name|store_error
function_decl|)
parameter_list|(
name|struct
name|aiocb
modifier|*
name|ujob
parameter_list|,
name|long
name|error
parameter_list|)
function_decl|;
name|int
function_decl|(
modifier|*
name|store_kernelinfo
function_decl|)
parameter_list|(
name|struct
name|aiocb
modifier|*
name|ujob
parameter_list|,
name|long
name|jobref
parameter_list|)
function_decl|;
name|int
function_decl|(
modifier|*
name|store_aiocb
function_decl|)
parameter_list|(
name|struct
name|aiocb
modifier|*
modifier|*
name|ujobp
parameter_list|,
name|struct
name|aiocb
modifier|*
name|ujob
parameter_list|)
function_decl|;
block|}
struct|;
end_struct

begin_expr_stmt
specifier|static
name|TAILQ_HEAD
argument_list|(
argument_list|,
argument|aioproc
argument_list|)
name|aio_freeproc
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* (c) Idle daemons */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|sema
name|aio_newproc_sem
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|mtx
name|aio_job_mtx
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|static
name|TAILQ_HEAD
argument_list|(
argument_list|,
argument|kaiocb
argument_list|)
name|aio_jobs
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* (c) Async job list */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|unrhdr
modifier|*
name|aiod_unr
decl_stmt|;
end_decl_stmt

begin_function_decl
name|void
name|aio_init_aioinfo
parameter_list|(
name|struct
name|proc
modifier|*
name|p
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|aio_onceonly
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|aio_free_entry
parameter_list|(
name|struct
name|kaiocb
modifier|*
name|job
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|aio_process_rw
parameter_list|(
name|struct
name|kaiocb
modifier|*
name|job
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|aio_process_sync
parameter_list|(
name|struct
name|kaiocb
modifier|*
name|job
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|aio_process_mlock
parameter_list|(
name|struct
name|kaiocb
modifier|*
name|job
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|aio_schedule_fsync
parameter_list|(
name|void
modifier|*
name|context
parameter_list|,
name|int
name|pending
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|aio_newproc
parameter_list|(
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|aio_aqueue
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|aiocb
modifier|*
name|ujob
parameter_list|,
name|struct
name|aioliojob
modifier|*
name|lio
parameter_list|,
name|int
name|type
parameter_list|,
name|struct
name|aiocb_ops
modifier|*
name|ops
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|aio_queue_file
parameter_list|(
name|struct
name|file
modifier|*
name|fp
parameter_list|,
name|struct
name|kaiocb
modifier|*
name|job
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|aio_physwakeup
parameter_list|(
name|struct
name|bio
modifier|*
name|bp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|aio_proc_rundown
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|aio_proc_rundown_exec
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|,
name|struct
name|image_params
modifier|*
name|imgp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|aio_qphysio
parameter_list|(
name|struct
name|proc
modifier|*
name|p
parameter_list|,
name|struct
name|kaiocb
modifier|*
name|job
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|aio_daemon
parameter_list|(
name|void
modifier|*
name|param
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|aio_bio_done_notify
parameter_list|(
name|struct
name|proc
modifier|*
name|userp
parameter_list|,
name|struct
name|kaiocb
modifier|*
name|job
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|aio_clear_cancel_function_locked
parameter_list|(
name|struct
name|kaiocb
modifier|*
name|job
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|aio_kick
parameter_list|(
name|struct
name|proc
modifier|*
name|userp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|aio_kick_nowait
parameter_list|(
name|struct
name|proc
modifier|*
name|userp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|aio_kick_helper
parameter_list|(
name|void
modifier|*
name|context
parameter_list|,
name|int
name|pending
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|filt_aioattach
parameter_list|(
name|struct
name|knote
modifier|*
name|kn
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|filt_aiodetach
parameter_list|(
name|struct
name|knote
modifier|*
name|kn
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|filt_aio
parameter_list|(
name|struct
name|knote
modifier|*
name|kn
parameter_list|,
name|long
name|hint
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|filt_lioattach
parameter_list|(
name|struct
name|knote
modifier|*
name|kn
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|filt_liodetach
parameter_list|(
name|struct
name|knote
modifier|*
name|kn
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|filt_lio
parameter_list|(
name|struct
name|knote
modifier|*
name|kn
parameter_list|,
name|long
name|hint
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Zones for:  * 	kaio	Per process async io info  *	aiop	async io process data  *	aiocb	async io jobs  *	aiol	list io job pointer - internal to aio_suspend XXX  *	aiolio	list io jobs  */
end_comment

begin_decl_stmt
specifier|static
name|uma_zone_t
name|kaio_zone
decl_stmt|,
name|aiop_zone
decl_stmt|,
name|aiocb_zone
decl_stmt|,
name|aiol_zone
decl_stmt|,
name|aiolio_zone
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* kqueue filters for aio */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|filterops
name|aio_filtops
init|=
block|{
operator|.
name|f_isfd
operator|=
literal|0
block|,
operator|.
name|f_attach
operator|=
name|filt_aioattach
block|,
operator|.
name|f_detach
operator|=
name|filt_aiodetach
block|,
operator|.
name|f_event
operator|=
name|filt_aio
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|filterops
name|lio_filtops
init|=
block|{
operator|.
name|f_isfd
operator|=
literal|0
block|,
operator|.
name|f_attach
operator|=
name|filt_lioattach
block|,
operator|.
name|f_detach
operator|=
name|filt_liodetach
block|,
operator|.
name|f_event
operator|=
name|filt_lio
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|eventhandler_tag
name|exit_tag
decl_stmt|,
name|exec_tag
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TASKQUEUE_DEFINE_THREAD
argument_list|(
name|aiod_kick
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Main operations function for use as a kernel module.  */
end_comment

begin_function
specifier|static
name|int
name|aio_modload
parameter_list|(
name|struct
name|module
modifier|*
name|module
parameter_list|,
name|int
name|cmd
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|MOD_LOAD
case|:
name|aio_onceonly
argument_list|()
expr_stmt|;
break|break;
case|case
name|MOD_SHUTDOWN
case|:
break|break;
default|default:
name|error
operator|=
name|EOPNOTSUPP
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|moduledata_t
name|aio_mod
init|=
block|{
literal|"aio"
block|,
operator|&
name|aio_modload
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DECLARE_MODULE
argument_list|(
name|aio
argument_list|,
name|aio_mod
argument_list|,
name|SI_SUB_VFS
argument_list|,
name|SI_ORDER_ANY
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_VERSION
argument_list|(
name|aio
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Startup initialization  */
end_comment

begin_function
specifier|static
name|int
name|aio_onceonly
parameter_list|(
name|void
parameter_list|)
block|{
name|exit_tag
operator|=
name|EVENTHANDLER_REGISTER
argument_list|(
name|process_exit
argument_list|,
name|aio_proc_rundown
argument_list|,
name|NULL
argument_list|,
name|EVENTHANDLER_PRI_ANY
argument_list|)
expr_stmt|;
name|exec_tag
operator|=
name|EVENTHANDLER_REGISTER
argument_list|(
name|process_exec
argument_list|,
name|aio_proc_rundown_exec
argument_list|,
name|NULL
argument_list|,
name|EVENTHANDLER_PRI_ANY
argument_list|)
expr_stmt|;
name|kqueue_add_filteropts
argument_list|(
name|EVFILT_AIO
argument_list|,
operator|&
name|aio_filtops
argument_list|)
expr_stmt|;
name|kqueue_add_filteropts
argument_list|(
name|EVFILT_LIO
argument_list|,
operator|&
name|lio_filtops
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|aio_freeproc
argument_list|)
expr_stmt|;
name|sema_init
argument_list|(
operator|&
name|aio_newproc_sem
argument_list|,
literal|0
argument_list|,
literal|"aio_new_proc"
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|aio_job_mtx
argument_list|,
literal|"aio_job"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|aio_jobs
argument_list|)
expr_stmt|;
name|aiod_unr
operator|=
name|new_unrhdr
argument_list|(
literal|1
argument_list|,
name|INT_MAX
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|kaio_zone
operator|=
name|uma_zcreate
argument_list|(
literal|"AIO"
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|kaioinfo
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|UMA_ALIGN_PTR
argument_list|,
name|UMA_ZONE_NOFREE
argument_list|)
expr_stmt|;
name|aiop_zone
operator|=
name|uma_zcreate
argument_list|(
literal|"AIOP"
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|aioproc
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|UMA_ALIGN_PTR
argument_list|,
name|UMA_ZONE_NOFREE
argument_list|)
expr_stmt|;
name|aiocb_zone
operator|=
name|uma_zcreate
argument_list|(
literal|"AIOCB"
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|kaiocb
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|UMA_ALIGN_PTR
argument_list|,
name|UMA_ZONE_NOFREE
argument_list|)
expr_stmt|;
name|aiol_zone
operator|=
name|uma_zcreate
argument_list|(
literal|"AIOL"
argument_list|,
name|AIO_LISTIO_MAX
operator|*
sizeof|sizeof
argument_list|(
name|intptr_t
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|UMA_ALIGN_PTR
argument_list|,
name|UMA_ZONE_NOFREE
argument_list|)
expr_stmt|;
name|aiolio_zone
operator|=
name|uma_zcreate
argument_list|(
literal|"AIOLIO"
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|aioliojob
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|UMA_ALIGN_PTR
argument_list|,
name|UMA_ZONE_NOFREE
argument_list|)
expr_stmt|;
name|aiod_lifetime
operator|=
name|AIOD_LIFETIME_DEFAULT
expr_stmt|;
name|jobrefid
operator|=
literal|1
expr_stmt|;
name|p31b_setcfg
argument_list|(
name|CTL_P1003_1B_ASYNCHRONOUS_IO
argument_list|,
name|_POSIX_ASYNCHRONOUS_IO
argument_list|)
expr_stmt|;
name|p31b_setcfg
argument_list|(
name|CTL_P1003_1B_AIO_LISTIO_MAX
argument_list|,
name|AIO_LISTIO_MAX
argument_list|)
expr_stmt|;
name|p31b_setcfg
argument_list|(
name|CTL_P1003_1B_AIO_MAX
argument_list|,
name|MAX_AIO_QUEUE
argument_list|)
expr_stmt|;
name|p31b_setcfg
argument_list|(
name|CTL_P1003_1B_AIO_PRIO_DELTA_MAX
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Init the per-process aioinfo structure.  The aioinfo limits are set  * per-process for user limit (resource) management.  */
end_comment

begin_function
name|void
name|aio_init_aioinfo
parameter_list|(
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|kaioinfo
modifier|*
name|ki
decl_stmt|;
name|ki
operator|=
name|uma_zalloc
argument_list|(
name|kaio_zone
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|ki
operator|->
name|kaio_mtx
argument_list|,
literal|"aiomtx"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
operator||
name|MTX_NEW
argument_list|)
expr_stmt|;
name|ki
operator|->
name|kaio_flags
operator|=
literal|0
expr_stmt|;
name|ki
operator|->
name|kaio_maxactive_count
operator|=
name|max_aio_per_proc
expr_stmt|;
name|ki
operator|->
name|kaio_active_count
operator|=
literal|0
expr_stmt|;
name|ki
operator|->
name|kaio_qallowed_count
operator|=
name|max_aio_queue_per_proc
expr_stmt|;
name|ki
operator|->
name|kaio_count
operator|=
literal|0
expr_stmt|;
name|ki
operator|->
name|kaio_ballowed_count
operator|=
name|max_buf_aio
expr_stmt|;
name|ki
operator|->
name|kaio_buffer_count
operator|=
literal|0
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|ki
operator|->
name|kaio_all
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|ki
operator|->
name|kaio_done
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|ki
operator|->
name|kaio_jobqueue
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|ki
operator|->
name|kaio_liojoblist
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|ki
operator|->
name|kaio_syncqueue
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|ki
operator|->
name|kaio_syncready
argument_list|)
expr_stmt|;
name|TASK_INIT
argument_list|(
operator|&
name|ki
operator|->
name|kaio_task
argument_list|,
literal|0
argument_list|,
name|aio_kick_helper
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|TASK_INIT
argument_list|(
operator|&
name|ki
operator|->
name|kaio_sync_task
argument_list|,
literal|0
argument_list|,
name|aio_schedule_fsync
argument_list|,
name|ki
argument_list|)
expr_stmt|;
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|p_aioinfo
operator|==
name|NULL
condition|)
block|{
name|p
operator|->
name|p_aioinfo
operator|=
name|ki
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|ki
operator|->
name|kaio_mtx
argument_list|)
expr_stmt|;
name|uma_zfree
argument_list|(
name|kaio_zone
argument_list|,
name|ki
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|num_aio_procs
operator|<
name|MIN
argument_list|(
name|target_aio_procs
argument_list|,
name|max_aio_procs
argument_list|)
condition|)
name|aio_newproc
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|aio_sendsig
parameter_list|(
name|struct
name|proc
modifier|*
name|p
parameter_list|,
name|struct
name|sigevent
modifier|*
name|sigev
parameter_list|,
name|ksiginfo_t
modifier|*
name|ksi
parameter_list|)
block|{
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
name|sigev_findtd
argument_list|(
name|p
argument_list|,
name|sigev
argument_list|,
operator|&
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
operator|!
name|KSI_ONQ
argument_list|(
name|ksi
argument_list|)
condition|)
block|{
name|ksiginfo_set_sigev
argument_list|(
name|ksi
argument_list|,
name|sigev
argument_list|)
expr_stmt|;
name|ksi
operator|->
name|ksi_code
operator|=
name|SI_ASYNCIO
expr_stmt|;
name|ksi
operator|->
name|ksi_flags
operator||=
name|KSI_EXT
operator||
name|KSI_INS
expr_stmt|;
name|tdsendsignal
argument_list|(
name|p
argument_list|,
name|td
argument_list|,
name|ksi
operator|->
name|ksi_signo
argument_list|,
name|ksi
argument_list|)
expr_stmt|;
block|}
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Free a job entry.  Wait for completion if it is currently active, but don't  * delay forever.  If we delay, we return a flag that says that we have to  * restart the queue scan.  */
end_comment

begin_function
specifier|static
name|int
name|aio_free_entry
parameter_list|(
name|struct
name|kaiocb
modifier|*
name|job
parameter_list|)
block|{
name|struct
name|kaioinfo
modifier|*
name|ki
decl_stmt|;
name|struct
name|aioliojob
modifier|*
name|lj
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|job
operator|->
name|userproc
expr_stmt|;
name|MPASS
argument_list|(
name|curproc
operator|==
name|p
argument_list|)
expr_stmt|;
name|ki
operator|=
name|p
operator|->
name|p_aioinfo
expr_stmt|;
name|MPASS
argument_list|(
name|ki
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|AIO_LOCK_ASSERT
argument_list|(
name|ki
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|job
operator|->
name|jobflags
operator|&
name|KAIOCB_FINISHED
argument_list|)
expr_stmt|;
name|atomic_subtract_int
argument_list|(
operator|&
name|num_queue_count
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ki
operator|->
name|kaio_count
operator|--
expr_stmt|;
name|MPASS
argument_list|(
name|ki
operator|->
name|kaio_count
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|ki
operator|->
name|kaio_done
argument_list|,
name|job
argument_list|,
name|plist
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|ki
operator|->
name|kaio_all
argument_list|,
name|job
argument_list|,
name|allist
argument_list|)
expr_stmt|;
name|lj
operator|=
name|job
operator|->
name|lio
expr_stmt|;
if|if
condition|(
name|lj
condition|)
block|{
name|lj
operator|->
name|lioj_count
operator|--
expr_stmt|;
name|lj
operator|->
name|lioj_finished_count
operator|--
expr_stmt|;
if|if
condition|(
name|lj
operator|->
name|lioj_count
operator|==
literal|0
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|ki
operator|->
name|kaio_liojoblist
argument_list|,
name|lj
argument_list|,
name|lioj_list
argument_list|)
expr_stmt|;
comment|/* lio is going away, we need to destroy any knotes */
name|knlist_delete
argument_list|(
operator|&
name|lj
operator|->
name|klist
argument_list|,
name|curthread
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|sigqueue_take
argument_list|(
operator|&
name|lj
operator|->
name|lioj_ksi
argument_list|)
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|uma_zfree
argument_list|(
name|aiolio_zone
argument_list|,
name|lj
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* job is going away, we need to destroy any knotes */
name|knlist_delete
argument_list|(
operator|&
name|job
operator|->
name|klist
argument_list|,
name|curthread
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|sigqueue_take
argument_list|(
operator|&
name|job
operator|->
name|ksi
argument_list|)
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|AIO_UNLOCK
argument_list|(
name|ki
argument_list|)
expr_stmt|;
comment|/* 	 * The thread argument here is used to find the owning process 	 * and is also passed to fo_close() which may pass it to various 	 * places such as devsw close() routines.  Because of that, we 	 * need a thread pointer from the process owning the job that is 	 * persistent and won't disappear out from under us or move to 	 * another process. 	 * 	 * Currently, all the callers of this function call it to remove 	 * a kaiocb from the current process' job list either via a 	 * syscall or due to the current process calling exit() or 	 * execve().  Thus, we know that p == curproc.  We also know that 	 * curthread can't exit since we are curthread. 	 * 	 * Therefore, we use curthread as the thread to pass to 	 * knlist_delete().  This does mean that it is possible for the 	 * thread pointer at close time to differ from the thread pointer 	 * at open time, but this is already true of file descriptors in 	 * a multithreaded process. 	 */
if|if
condition|(
name|job
operator|->
name|fd_file
condition|)
name|fdrop
argument_list|(
name|job
operator|->
name|fd_file
argument_list|,
name|curthread
argument_list|)
expr_stmt|;
name|crfree
argument_list|(
name|job
operator|->
name|cred
argument_list|)
expr_stmt|;
name|uma_zfree
argument_list|(
name|aiocb_zone
argument_list|,
name|job
argument_list|)
expr_stmt|;
name|AIO_LOCK
argument_list|(
name|ki
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|aio_proc_rundown_exec
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|,
name|struct
name|image_params
modifier|*
name|imgp
name|__unused
parameter_list|)
block|{
name|aio_proc_rundown
argument_list|(
name|arg
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|aio_cancel_job
parameter_list|(
name|struct
name|proc
modifier|*
name|p
parameter_list|,
name|struct
name|kaioinfo
modifier|*
name|ki
parameter_list|,
name|struct
name|kaiocb
modifier|*
name|job
parameter_list|)
block|{
name|aio_cancel_fn_t
modifier|*
name|func
decl_stmt|;
name|int
name|cancelled
decl_stmt|;
name|AIO_LOCK_ASSERT
argument_list|(
name|ki
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
if|if
condition|(
name|job
operator|->
name|jobflags
operator|&
operator|(
name|KAIOCB_CANCELLED
operator||
name|KAIOCB_FINISHED
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|MPASS
argument_list|(
operator|(
name|job
operator|->
name|jobflags
operator|&
name|KAIOCB_CANCELLING
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|job
operator|->
name|jobflags
operator||=
name|KAIOCB_CANCELLED
expr_stmt|;
name|func
operator|=
name|job
operator|->
name|cancel_fn
expr_stmt|;
comment|/* 	 * If there is no cancel routine, just leave the job marked as 	 * cancelled.  The job should be in active use by a caller who 	 * should complete it normally or when it fails to install a 	 * cancel routine. 	 */
if|if
condition|(
name|func
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * Set the CANCELLING flag so that aio_complete() will defer 	 * completions of this job.  This prevents the job from being 	 * freed out from under the cancel callback.  After the 	 * callback any deferred completion (whether from the callback 	 * or any other source) will be completed. 	 */
name|job
operator|->
name|jobflags
operator||=
name|KAIOCB_CANCELLING
expr_stmt|;
name|AIO_UNLOCK
argument_list|(
name|ki
argument_list|)
expr_stmt|;
name|func
argument_list|(
name|job
argument_list|)
expr_stmt|;
name|AIO_LOCK
argument_list|(
name|ki
argument_list|)
expr_stmt|;
name|job
operator|->
name|jobflags
operator|&=
operator|~
name|KAIOCB_CANCELLING
expr_stmt|;
if|if
condition|(
name|job
operator|->
name|jobflags
operator|&
name|KAIOCB_FINISHED
condition|)
block|{
name|cancelled
operator|=
name|job
operator|->
name|uaiocb
operator|.
name|_aiocb_private
operator|.
name|error
operator|==
name|ECANCELED
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|ki
operator|->
name|kaio_jobqueue
argument_list|,
name|job
argument_list|,
name|plist
argument_list|)
expr_stmt|;
name|aio_bio_done_notify
argument_list|(
name|p
argument_list|,
name|job
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * The cancel callback might have scheduled an 		 * operation to cancel this request, but it is 		 * only counted as cancelled if the request is 		 * cancelled when the callback returns. 		 */
name|cancelled
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
name|cancelled
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Rundown the jobs for a given process.  */
end_comment

begin_function
specifier|static
name|void
name|aio_proc_rundown
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|kaioinfo
modifier|*
name|ki
decl_stmt|;
name|struct
name|aioliojob
modifier|*
name|lj
decl_stmt|;
name|struct
name|kaiocb
modifier|*
name|job
decl_stmt|,
modifier|*
name|jobn
decl_stmt|;
name|KASSERT
argument_list|(
name|curthread
operator|->
name|td_proc
operator|==
name|p
argument_list|,
operator|(
literal|"%s: called on non-curproc"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|ki
operator|=
name|p
operator|->
name|p_aioinfo
expr_stmt|;
if|if
condition|(
name|ki
operator|==
name|NULL
condition|)
return|return;
name|AIO_LOCK
argument_list|(
name|ki
argument_list|)
expr_stmt|;
name|ki
operator|->
name|kaio_flags
operator||=
name|KAIO_RUNDOWN
expr_stmt|;
name|restart
label|:
comment|/* 	 * Try to cancel all pending requests. This code simulates 	 * aio_cancel on all pending I/O requests. 	 */
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|job
argument_list|,
argument|&ki->kaio_jobqueue
argument_list|,
argument|plist
argument_list|,
argument|jobn
argument_list|)
block|{
name|aio_cancel_job
argument_list|(
name|p
argument_list|,
name|ki
argument_list|,
name|job
argument_list|)
expr_stmt|;
block|}
comment|/* Wait for all running I/O to be finished */
if|if
condition|(
name|TAILQ_FIRST
argument_list|(
operator|&
name|ki
operator|->
name|kaio_jobqueue
argument_list|)
operator|||
name|ki
operator|->
name|kaio_active_count
operator|!=
literal|0
condition|)
block|{
name|ki
operator|->
name|kaio_flags
operator||=
name|KAIO_WAKEUP
expr_stmt|;
name|msleep
argument_list|(
operator|&
name|p
operator|->
name|p_aioinfo
argument_list|,
name|AIO_MTX
argument_list|(
name|ki
argument_list|)
argument_list|,
name|PRIBIO
argument_list|,
literal|"aioprn"
argument_list|,
name|hz
argument_list|)
expr_stmt|;
goto|goto
name|restart
goto|;
block|}
comment|/* Free all completed I/O requests. */
while|while
condition|(
operator|(
name|job
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|ki
operator|->
name|kaio_done
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|aio_free_entry
argument_list|(
name|job
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|lj
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|ki
operator|->
name|kaio_liojoblist
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|lj
operator|->
name|lioj_count
operator|==
literal|0
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|ki
operator|->
name|kaio_liojoblist
argument_list|,
name|lj
argument_list|,
name|lioj_list
argument_list|)
expr_stmt|;
name|knlist_delete
argument_list|(
operator|&
name|lj
operator|->
name|klist
argument_list|,
name|curthread
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|sigqueue_take
argument_list|(
operator|&
name|lj
operator|->
name|lioj_ksi
argument_list|)
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|uma_zfree
argument_list|(
name|aiolio_zone
argument_list|,
name|lj
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|panic
argument_list|(
literal|"LIO job not cleaned up: C:%d, FC:%d\n"
argument_list|,
name|lj
operator|->
name|lioj_count
argument_list|,
name|lj
operator|->
name|lioj_finished_count
argument_list|)
expr_stmt|;
block|}
block|}
name|AIO_UNLOCK
argument_list|(
name|ki
argument_list|)
expr_stmt|;
name|taskqueue_drain
argument_list|(
name|taskqueue_aiod_kick
argument_list|,
operator|&
name|ki
operator|->
name|kaio_task
argument_list|)
expr_stmt|;
name|taskqueue_drain
argument_list|(
name|taskqueue_aiod_kick
argument_list|,
operator|&
name|ki
operator|->
name|kaio_sync_task
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|ki
operator|->
name|kaio_mtx
argument_list|)
expr_stmt|;
name|uma_zfree
argument_list|(
name|kaio_zone
argument_list|,
name|ki
argument_list|)
expr_stmt|;
name|p
operator|->
name|p_aioinfo
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Select a job to run (called by an AIO daemon).  */
end_comment

begin_function
specifier|static
name|struct
name|kaiocb
modifier|*
name|aio_selectjob
parameter_list|(
name|struct
name|aioproc
modifier|*
name|aiop
parameter_list|)
block|{
name|struct
name|kaiocb
modifier|*
name|job
decl_stmt|;
name|struct
name|kaioinfo
modifier|*
name|ki
decl_stmt|;
name|struct
name|proc
modifier|*
name|userp
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|aio_job_mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|restart
label|:
name|TAILQ_FOREACH
argument_list|(
argument|job
argument_list|,
argument|&aio_jobs
argument_list|,
argument|list
argument_list|)
block|{
name|userp
operator|=
name|job
operator|->
name|userproc
expr_stmt|;
name|ki
operator|=
name|userp
operator|->
name|p_aioinfo
expr_stmt|;
if|if
condition|(
name|ki
operator|->
name|kaio_active_count
operator|<
name|ki
operator|->
name|kaio_maxactive_count
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|aio_jobs
argument_list|,
name|job
argument_list|,
name|list
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|aio_clear_cancel_function
argument_list|(
name|job
argument_list|)
condition|)
goto|goto
name|restart
goto|;
comment|/* Account for currently active jobs. */
name|ki
operator|->
name|kaio_active_count
operator|++
expr_stmt|;
break|break;
block|}
block|}
return|return
operator|(
name|job
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Move all data to a permanent storage device.  This code  * simulates the fsync syscall.  */
end_comment

begin_function
specifier|static
name|int
name|aio_fsync_vnode
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|vnode
modifier|*
name|vp
parameter_list|)
block|{
name|struct
name|mount
modifier|*
name|mp
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|vn_start_write
argument_list|(
name|vp
argument_list|,
operator|&
name|mp
argument_list|,
name|V_WAIT
operator||
name|PCATCH
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|drop
goto|;
name|vn_lock
argument_list|(
name|vp
argument_list|,
name|LK_EXCLUSIVE
operator||
name|LK_RETRY
argument_list|)
expr_stmt|;
if|if
condition|(
name|vp
operator|->
name|v_object
operator|!=
name|NULL
condition|)
block|{
name|VM_OBJECT_WLOCK
argument_list|(
name|vp
operator|->
name|v_object
argument_list|)
expr_stmt|;
name|vm_object_page_clean
argument_list|(
name|vp
operator|->
name|v_object
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|VM_OBJECT_WUNLOCK
argument_list|(
name|vp
operator|->
name|v_object
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
name|VOP_FSYNC
argument_list|(
name|vp
argument_list|,
name|MNT_WAIT
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|VOP_UNLOCK
argument_list|(
name|vp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|vn_finished_write
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|drop
label|:
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * The AIO processing activity for LIO_READ/LIO_WRITE.  This is the code that  * does the I/O request for the non-physio version of the operations.  The  * normal vn operations are used, and this code should work in all instances  * for every type of file, including pipes, sockets, fifos, and regular files.  *  * XXX I don't think it works well for socket, pipe, and fifo.  */
end_comment

begin_function
specifier|static
name|void
name|aio_process_rw
parameter_list|(
name|struct
name|kaiocb
modifier|*
name|job
parameter_list|)
block|{
name|struct
name|ucred
modifier|*
name|td_savedcred
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|aiocb
modifier|*
name|cb
decl_stmt|;
name|struct
name|file
modifier|*
name|fp
decl_stmt|;
name|struct
name|uio
name|auio
decl_stmt|;
name|struct
name|iovec
name|aiov
decl_stmt|;
name|ssize_t
name|cnt
decl_stmt|;
name|long
name|msgsnd_st
decl_stmt|,
name|msgsnd_end
decl_stmt|;
name|long
name|msgrcv_st
decl_stmt|,
name|msgrcv_end
decl_stmt|;
name|long
name|oublock_st
decl_stmt|,
name|oublock_end
decl_stmt|;
name|long
name|inblock_st
decl_stmt|,
name|inblock_end
decl_stmt|;
name|int
name|error
decl_stmt|;
name|KASSERT
argument_list|(
name|job
operator|->
name|uaiocb
operator|.
name|aio_lio_opcode
operator|==
name|LIO_READ
operator|||
name|job
operator|->
name|uaiocb
operator|.
name|aio_lio_opcode
operator|==
name|LIO_WRITE
argument_list|,
operator|(
literal|"%s: opcode %d"
operator|,
name|__func__
operator|,
name|job
operator|->
name|uaiocb
operator|.
name|aio_lio_opcode
operator|)
argument_list|)
expr_stmt|;
name|aio_switch_vmspace
argument_list|(
name|job
argument_list|)
expr_stmt|;
name|td
operator|=
name|curthread
expr_stmt|;
name|td_savedcred
operator|=
name|td
operator|->
name|td_ucred
expr_stmt|;
name|td
operator|->
name|td_ucred
operator|=
name|job
operator|->
name|cred
expr_stmt|;
name|cb
operator|=
operator|&
name|job
operator|->
name|uaiocb
expr_stmt|;
name|fp
operator|=
name|job
operator|->
name|fd_file
expr_stmt|;
name|aiov
operator|.
name|iov_base
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|cb
operator|->
name|aio_buf
expr_stmt|;
name|aiov
operator|.
name|iov_len
operator|=
name|cb
operator|->
name|aio_nbytes
expr_stmt|;
name|auio
operator|.
name|uio_iov
operator|=
operator|&
name|aiov
expr_stmt|;
name|auio
operator|.
name|uio_iovcnt
operator|=
literal|1
expr_stmt|;
name|auio
operator|.
name|uio_offset
operator|=
name|cb
operator|->
name|aio_offset
expr_stmt|;
name|auio
operator|.
name|uio_resid
operator|=
name|cb
operator|->
name|aio_nbytes
expr_stmt|;
name|cnt
operator|=
name|cb
operator|->
name|aio_nbytes
expr_stmt|;
name|auio
operator|.
name|uio_segflg
operator|=
name|UIO_USERSPACE
expr_stmt|;
name|auio
operator|.
name|uio_td
operator|=
name|td
expr_stmt|;
name|msgrcv_st
operator|=
name|td
operator|->
name|td_ru
operator|.
name|ru_msgrcv
expr_stmt|;
name|msgsnd_st
operator|=
name|td
operator|->
name|td_ru
operator|.
name|ru_msgsnd
expr_stmt|;
name|inblock_st
operator|=
name|td
operator|->
name|td_ru
operator|.
name|ru_inblock
expr_stmt|;
name|oublock_st
operator|=
name|td
operator|->
name|td_ru
operator|.
name|ru_oublock
expr_stmt|;
comment|/* 	 * aio_aqueue() acquires a reference to the file that is 	 * released in aio_free_entry(). 	 */
if|if
condition|(
name|cb
operator|->
name|aio_lio_opcode
operator|==
name|LIO_READ
condition|)
block|{
name|auio
operator|.
name|uio_rw
operator|=
name|UIO_READ
expr_stmt|;
if|if
condition|(
name|auio
operator|.
name|uio_resid
operator|==
literal|0
condition|)
name|error
operator|=
literal|0
expr_stmt|;
else|else
name|error
operator|=
name|fo_read
argument_list|(
name|fp
argument_list|,
operator|&
name|auio
argument_list|,
name|fp
operator|->
name|f_cred
argument_list|,
name|FOF_OFFSET
argument_list|,
name|td
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|fp
operator|->
name|f_type
operator|==
name|DTYPE_VNODE
condition|)
name|bwillwrite
argument_list|()
expr_stmt|;
name|auio
operator|.
name|uio_rw
operator|=
name|UIO_WRITE
expr_stmt|;
name|error
operator|=
name|fo_write
argument_list|(
name|fp
argument_list|,
operator|&
name|auio
argument_list|,
name|fp
operator|->
name|f_cred
argument_list|,
name|FOF_OFFSET
argument_list|,
name|td
argument_list|)
expr_stmt|;
block|}
name|msgrcv_end
operator|=
name|td
operator|->
name|td_ru
operator|.
name|ru_msgrcv
expr_stmt|;
name|msgsnd_end
operator|=
name|td
operator|->
name|td_ru
operator|.
name|ru_msgsnd
expr_stmt|;
name|inblock_end
operator|=
name|td
operator|->
name|td_ru
operator|.
name|ru_inblock
expr_stmt|;
name|oublock_end
operator|=
name|td
operator|->
name|td_ru
operator|.
name|ru_oublock
expr_stmt|;
name|job
operator|->
name|msgrcv
operator|=
name|msgrcv_end
operator|-
name|msgrcv_st
expr_stmt|;
name|job
operator|->
name|msgsnd
operator|=
name|msgsnd_end
operator|-
name|msgsnd_st
expr_stmt|;
name|job
operator|->
name|inblock
operator|=
name|inblock_end
operator|-
name|inblock_st
expr_stmt|;
name|job
operator|->
name|outblock
operator|=
name|oublock_end
operator|-
name|oublock_st
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|)
operator|&&
operator|(
name|auio
operator|.
name|uio_resid
operator|!=
name|cnt
operator|)
condition|)
block|{
if|if
condition|(
name|error
operator|==
name|ERESTART
operator|||
name|error
operator|==
name|EINTR
operator|||
name|error
operator|==
name|EWOULDBLOCK
condition|)
name|error
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|==
name|EPIPE
operator|)
operator|&&
operator|(
name|cb
operator|->
name|aio_lio_opcode
operator|==
name|LIO_WRITE
operator|)
condition|)
block|{
name|PROC_LOCK
argument_list|(
name|job
operator|->
name|userproc
argument_list|)
expr_stmt|;
name|kern_psignal
argument_list|(
name|job
operator|->
name|userproc
argument_list|,
name|SIGPIPE
argument_list|)
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|job
operator|->
name|userproc
argument_list|)
expr_stmt|;
block|}
block|}
name|cnt
operator|-=
name|auio
operator|.
name|uio_resid
expr_stmt|;
name|td
operator|->
name|td_ucred
operator|=
name|td_savedcred
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|aio_complete
argument_list|(
name|job
argument_list|,
operator|-
literal|1
argument_list|,
name|error
argument_list|)
expr_stmt|;
else|else
name|aio_complete
argument_list|(
name|job
argument_list|,
name|cnt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|aio_process_sync
parameter_list|(
name|struct
name|kaiocb
modifier|*
name|job
parameter_list|)
block|{
name|struct
name|thread
modifier|*
name|td
init|=
name|curthread
decl_stmt|;
name|struct
name|ucred
modifier|*
name|td_savedcred
init|=
name|td
operator|->
name|td_ucred
decl_stmt|;
name|struct
name|file
modifier|*
name|fp
init|=
name|job
operator|->
name|fd_file
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|KASSERT
argument_list|(
name|job
operator|->
name|uaiocb
operator|.
name|aio_lio_opcode
operator|==
name|LIO_SYNC
argument_list|,
operator|(
literal|"%s: opcode %d"
operator|,
name|__func__
operator|,
name|job
operator|->
name|uaiocb
operator|.
name|aio_lio_opcode
operator|)
argument_list|)
expr_stmt|;
name|td
operator|->
name|td_ucred
operator|=
name|job
operator|->
name|cred
expr_stmt|;
if|if
condition|(
name|fp
operator|->
name|f_vnode
operator|!=
name|NULL
condition|)
name|error
operator|=
name|aio_fsync_vnode
argument_list|(
name|td
argument_list|,
name|fp
operator|->
name|f_vnode
argument_list|)
expr_stmt|;
name|td
operator|->
name|td_ucred
operator|=
name|td_savedcred
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|aio_complete
argument_list|(
name|job
argument_list|,
operator|-
literal|1
argument_list|,
name|error
argument_list|)
expr_stmt|;
else|else
name|aio_complete
argument_list|(
name|job
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|aio_process_mlock
parameter_list|(
name|struct
name|kaiocb
modifier|*
name|job
parameter_list|)
block|{
name|struct
name|aiocb
modifier|*
name|cb
init|=
operator|&
name|job
operator|->
name|uaiocb
decl_stmt|;
name|int
name|error
decl_stmt|;
name|KASSERT
argument_list|(
name|job
operator|->
name|uaiocb
operator|.
name|aio_lio_opcode
operator|==
name|LIO_MLOCK
argument_list|,
operator|(
literal|"%s: opcode %d"
operator|,
name|__func__
operator|,
name|job
operator|->
name|uaiocb
operator|.
name|aio_lio_opcode
operator|)
argument_list|)
expr_stmt|;
name|aio_switch_vmspace
argument_list|(
name|job
argument_list|)
expr_stmt|;
name|error
operator|=
name|kern_mlock
argument_list|(
name|job
operator|->
name|userproc
argument_list|,
name|job
operator|->
name|cred
argument_list|,
name|__DEVOLATILE
argument_list|(
name|uintptr_t
argument_list|,
name|cb
operator|->
name|aio_buf
argument_list|)
argument_list|,
name|cb
operator|->
name|aio_nbytes
argument_list|)
expr_stmt|;
name|aio_complete
argument_list|(
name|job
argument_list|,
name|error
operator|!=
literal|0
condition|?
operator|-
literal|1
else|:
literal|0
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|aio_bio_done_notify
parameter_list|(
name|struct
name|proc
modifier|*
name|userp
parameter_list|,
name|struct
name|kaiocb
modifier|*
name|job
parameter_list|)
block|{
name|struct
name|aioliojob
modifier|*
name|lj
decl_stmt|;
name|struct
name|kaioinfo
modifier|*
name|ki
decl_stmt|;
name|struct
name|kaiocb
modifier|*
name|sjob
decl_stmt|,
modifier|*
name|sjobn
decl_stmt|;
name|int
name|lj_done
decl_stmt|;
name|bool
name|schedule_fsync
decl_stmt|;
name|ki
operator|=
name|userp
operator|->
name|p_aioinfo
expr_stmt|;
name|AIO_LOCK_ASSERT
argument_list|(
name|ki
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|lj
operator|=
name|job
operator|->
name|lio
expr_stmt|;
name|lj_done
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|lj
condition|)
block|{
name|lj
operator|->
name|lioj_finished_count
operator|++
expr_stmt|;
if|if
condition|(
name|lj
operator|->
name|lioj_count
operator|==
name|lj
operator|->
name|lioj_finished_count
condition|)
name|lj_done
operator|=
literal|1
expr_stmt|;
block|}
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|ki
operator|->
name|kaio_done
argument_list|,
name|job
argument_list|,
name|plist
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|job
operator|->
name|jobflags
operator|&
name|KAIOCB_FINISHED
argument_list|)
expr_stmt|;
if|if
condition|(
name|ki
operator|->
name|kaio_flags
operator|&
name|KAIO_RUNDOWN
condition|)
goto|goto
name|notification_done
goto|;
if|if
condition|(
name|job
operator|->
name|uaiocb
operator|.
name|aio_sigevent
operator|.
name|sigev_notify
operator|==
name|SIGEV_SIGNAL
operator|||
name|job
operator|->
name|uaiocb
operator|.
name|aio_sigevent
operator|.
name|sigev_notify
operator|==
name|SIGEV_THREAD_ID
condition|)
name|aio_sendsig
argument_list|(
name|userp
argument_list|,
operator|&
name|job
operator|->
name|uaiocb
operator|.
name|aio_sigevent
argument_list|,
operator|&
name|job
operator|->
name|ksi
argument_list|)
expr_stmt|;
name|KNOTE_LOCKED
argument_list|(
operator|&
name|job
operator|->
name|klist
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|lj_done
condition|)
block|{
if|if
condition|(
name|lj
operator|->
name|lioj_signal
operator|.
name|sigev_notify
operator|==
name|SIGEV_KEVENT
condition|)
block|{
name|lj
operator|->
name|lioj_flags
operator||=
name|LIOJ_KEVENT_POSTED
expr_stmt|;
name|KNOTE_LOCKED
argument_list|(
operator|&
name|lj
operator|->
name|klist
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|lj
operator|->
name|lioj_flags
operator|&
operator|(
name|LIOJ_SIGNAL
operator||
name|LIOJ_SIGNAL_POSTED
operator|)
operator|)
operator|==
name|LIOJ_SIGNAL
operator|&&
operator|(
name|lj
operator|->
name|lioj_signal
operator|.
name|sigev_notify
operator|==
name|SIGEV_SIGNAL
operator|||
name|lj
operator|->
name|lioj_signal
operator|.
name|sigev_notify
operator|==
name|SIGEV_THREAD_ID
operator|)
condition|)
block|{
name|aio_sendsig
argument_list|(
name|userp
argument_list|,
operator|&
name|lj
operator|->
name|lioj_signal
argument_list|,
operator|&
name|lj
operator|->
name|lioj_ksi
argument_list|)
expr_stmt|;
name|lj
operator|->
name|lioj_flags
operator||=
name|LIOJ_SIGNAL_POSTED
expr_stmt|;
block|}
block|}
name|notification_done
label|:
if|if
condition|(
name|job
operator|->
name|jobflags
operator|&
name|KAIOCB_CHECKSYNC
condition|)
block|{
name|schedule_fsync
operator|=
name|false
expr_stmt|;
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|sjob
argument_list|,
argument|&ki->kaio_syncqueue
argument_list|,
argument|list
argument_list|,
argument|sjobn
argument_list|)
block|{
if|if
condition|(
name|job
operator|->
name|fd_file
operator|!=
name|sjob
operator|->
name|fd_file
operator|||
name|job
operator|->
name|seqno
operator|>=
name|sjob
operator|->
name|seqno
condition|)
continue|continue;
if|if
condition|(
operator|--
name|sjob
operator|->
name|pending
operator|>
literal|0
condition|)
continue|continue;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|ki
operator|->
name|kaio_syncqueue
argument_list|,
name|sjob
argument_list|,
name|list
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|aio_clear_cancel_function_locked
argument_list|(
name|sjob
argument_list|)
condition|)
continue|continue;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|ki
operator|->
name|kaio_syncready
argument_list|,
name|sjob
argument_list|,
name|list
argument_list|)
expr_stmt|;
name|schedule_fsync
operator|=
name|true
expr_stmt|;
block|}
if|if
condition|(
name|schedule_fsync
condition|)
name|taskqueue_enqueue
argument_list|(
name|taskqueue_aiod_kick
argument_list|,
operator|&
name|ki
operator|->
name|kaio_sync_task
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ki
operator|->
name|kaio_flags
operator|&
name|KAIO_WAKEUP
condition|)
block|{
name|ki
operator|->
name|kaio_flags
operator|&=
operator|~
name|KAIO_WAKEUP
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|userp
operator|->
name|p_aioinfo
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|aio_schedule_fsync
parameter_list|(
name|void
modifier|*
name|context
parameter_list|,
name|int
name|pending
parameter_list|)
block|{
name|struct
name|kaioinfo
modifier|*
name|ki
decl_stmt|;
name|struct
name|kaiocb
modifier|*
name|job
decl_stmt|;
name|ki
operator|=
name|context
expr_stmt|;
name|AIO_LOCK
argument_list|(
name|ki
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|ki
operator|->
name|kaio_syncready
argument_list|)
condition|)
block|{
name|job
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|ki
operator|->
name|kaio_syncready
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|ki
operator|->
name|kaio_syncready
argument_list|,
name|job
argument_list|,
name|list
argument_list|)
expr_stmt|;
name|AIO_UNLOCK
argument_list|(
name|ki
argument_list|)
expr_stmt|;
name|aio_schedule
argument_list|(
name|job
argument_list|,
name|aio_process_sync
argument_list|)
expr_stmt|;
name|AIO_LOCK
argument_list|(
name|ki
argument_list|)
expr_stmt|;
block|}
name|AIO_UNLOCK
argument_list|(
name|ki
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|bool
name|aio_cancel_cleared
parameter_list|(
name|struct
name|kaiocb
modifier|*
name|job
parameter_list|)
block|{
name|struct
name|kaioinfo
modifier|*
name|ki
decl_stmt|;
comment|/* 	 * The caller should hold the same queue lock held when 	 * aio_clear_cancel_function() was called and set this flag 	 * ensuring this check sees an up-to-date value.  However, 	 * there is no way to assert that. 	 */
name|ki
operator|=
name|job
operator|->
name|userproc
operator|->
name|p_aioinfo
expr_stmt|;
return|return
operator|(
operator|(
name|job
operator|->
name|jobflags
operator|&
name|KAIOCB_CLEARED
operator|)
operator|!=
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|aio_clear_cancel_function_locked
parameter_list|(
name|struct
name|kaiocb
modifier|*
name|job
parameter_list|)
block|{
name|AIO_LOCK_ASSERT
argument_list|(
name|job
operator|->
name|userproc
operator|->
name|p_aioinfo
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|job
operator|->
name|cancel_fn
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|job
operator|->
name|jobflags
operator|&
name|KAIOCB_CANCELLING
condition|)
block|{
name|job
operator|->
name|jobflags
operator||=
name|KAIOCB_CLEARED
expr_stmt|;
return|return
operator|(
name|false
operator|)
return|;
block|}
name|job
operator|->
name|cancel_fn
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|true
operator|)
return|;
block|}
end_function

begin_function
name|bool
name|aio_clear_cancel_function
parameter_list|(
name|struct
name|kaiocb
modifier|*
name|job
parameter_list|)
block|{
name|struct
name|kaioinfo
modifier|*
name|ki
decl_stmt|;
name|bool
name|ret
decl_stmt|;
name|ki
operator|=
name|job
operator|->
name|userproc
operator|->
name|p_aioinfo
expr_stmt|;
name|AIO_LOCK
argument_list|(
name|ki
argument_list|)
expr_stmt|;
name|ret
operator|=
name|aio_clear_cancel_function_locked
argument_list|(
name|job
argument_list|)
expr_stmt|;
name|AIO_UNLOCK
argument_list|(
name|ki
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|aio_set_cancel_function_locked
parameter_list|(
name|struct
name|kaiocb
modifier|*
name|job
parameter_list|,
name|aio_cancel_fn_t
modifier|*
name|func
parameter_list|)
block|{
name|AIO_LOCK_ASSERT
argument_list|(
name|job
operator|->
name|userproc
operator|->
name|p_aioinfo
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
if|if
condition|(
name|job
operator|->
name|jobflags
operator|&
name|KAIOCB_CANCELLED
condition|)
return|return
operator|(
name|false
operator|)
return|;
name|job
operator|->
name|cancel_fn
operator|=
name|func
expr_stmt|;
return|return
operator|(
name|true
operator|)
return|;
block|}
end_function

begin_function
name|bool
name|aio_set_cancel_function
parameter_list|(
name|struct
name|kaiocb
modifier|*
name|job
parameter_list|,
name|aio_cancel_fn_t
modifier|*
name|func
parameter_list|)
block|{
name|struct
name|kaioinfo
modifier|*
name|ki
decl_stmt|;
name|bool
name|ret
decl_stmt|;
name|ki
operator|=
name|job
operator|->
name|userproc
operator|->
name|p_aioinfo
expr_stmt|;
name|AIO_LOCK
argument_list|(
name|ki
argument_list|)
expr_stmt|;
name|ret
operator|=
name|aio_set_cancel_function_locked
argument_list|(
name|job
argument_list|,
name|func
argument_list|)
expr_stmt|;
name|AIO_UNLOCK
argument_list|(
name|ki
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
name|void
name|aio_complete
parameter_list|(
name|struct
name|kaiocb
modifier|*
name|job
parameter_list|,
name|long
name|status
parameter_list|,
name|int
name|error
parameter_list|)
block|{
name|struct
name|kaioinfo
modifier|*
name|ki
decl_stmt|;
name|struct
name|proc
modifier|*
name|userp
decl_stmt|;
name|job
operator|->
name|uaiocb
operator|.
name|_aiocb_private
operator|.
name|error
operator|=
name|error
expr_stmt|;
name|job
operator|->
name|uaiocb
operator|.
name|_aiocb_private
operator|.
name|status
operator|=
name|status
expr_stmt|;
name|userp
operator|=
name|job
operator|->
name|userproc
expr_stmt|;
name|ki
operator|=
name|userp
operator|->
name|p_aioinfo
expr_stmt|;
name|AIO_LOCK
argument_list|(
name|ki
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|!
operator|(
name|job
operator|->
name|jobflags
operator|&
name|KAIOCB_FINISHED
operator|)
argument_list|,
operator|(
literal|"duplicate aio_complete"
operator|)
argument_list|)
expr_stmt|;
name|job
operator|->
name|jobflags
operator||=
name|KAIOCB_FINISHED
expr_stmt|;
if|if
condition|(
operator|(
name|job
operator|->
name|jobflags
operator|&
operator|(
name|KAIOCB_QUEUEING
operator||
name|KAIOCB_CANCELLING
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|ki
operator|->
name|kaio_jobqueue
argument_list|,
name|job
argument_list|,
name|plist
argument_list|)
expr_stmt|;
name|aio_bio_done_notify
argument_list|(
name|userp
argument_list|,
name|job
argument_list|)
expr_stmt|;
block|}
name|AIO_UNLOCK
argument_list|(
name|ki
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|aio_cancel
parameter_list|(
name|struct
name|kaiocb
modifier|*
name|job
parameter_list|)
block|{
name|aio_complete
argument_list|(
name|job
argument_list|,
operator|-
literal|1
argument_list|,
name|ECANCELED
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|aio_switch_vmspace
parameter_list|(
name|struct
name|kaiocb
modifier|*
name|job
parameter_list|)
block|{
name|vmspace_switch_aio
argument_list|(
name|job
operator|->
name|userproc
operator|->
name|p_vmspace
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * The AIO daemon, most of the actual work is done in aio_process_*,  * but the setup (and address space mgmt) is done in this routine.  */
end_comment

begin_function
specifier|static
name|void
name|aio_daemon
parameter_list|(
name|void
modifier|*
name|_id
parameter_list|)
block|{
name|struct
name|kaiocb
modifier|*
name|job
decl_stmt|;
name|struct
name|aioproc
modifier|*
name|aiop
decl_stmt|;
name|struct
name|kaioinfo
modifier|*
name|ki
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|struct
name|vmspace
modifier|*
name|myvm
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
init|=
name|curthread
decl_stmt|;
name|int
name|id
init|=
operator|(
name|intptr_t
operator|)
name|_id
decl_stmt|;
comment|/* 	 * Grab an extra reference on the daemon's vmspace so that it 	 * doesn't get freed by jobs that switch to a different 	 * vmspace. 	 */
name|p
operator|=
name|td
operator|->
name|td_proc
expr_stmt|;
name|myvm
operator|=
name|vmspace_acquire_ref
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|p
operator|->
name|p_textvp
operator|==
name|NULL
argument_list|,
operator|(
literal|"kthread has a textvp"
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Allocate and ready the aio control info.  There is one aiop structure 	 * per daemon. 	 */
name|aiop
operator|=
name|uma_zalloc
argument_list|(
name|aiop_zone
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|aiop
operator|->
name|aioproc
operator|=
name|p
expr_stmt|;
name|aiop
operator|->
name|aioprocflags
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Wakeup parent process.  (Parent sleeps to keep from blasting away 	 * and creating too many daemons.) 	 */
name|sema_post
argument_list|(
operator|&
name|aio_newproc_sem
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|aio_job_mtx
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* 		 * Take daemon off of free queue 		 */
if|if
condition|(
name|aiop
operator|->
name|aioprocflags
operator|&
name|AIOP_FREE
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|aio_freeproc
argument_list|,
name|aiop
argument_list|,
name|list
argument_list|)
expr_stmt|;
name|aiop
operator|->
name|aioprocflags
operator|&=
operator|~
name|AIOP_FREE
expr_stmt|;
block|}
comment|/* 		 * Check for jobs. 		 */
while|while
condition|(
operator|(
name|job
operator|=
name|aio_selectjob
argument_list|(
name|aiop
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|aio_job_mtx
argument_list|)
expr_stmt|;
name|ki
operator|=
name|job
operator|->
name|userproc
operator|->
name|p_aioinfo
expr_stmt|;
name|job
operator|->
name|handle_fn
argument_list|(
name|job
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|aio_job_mtx
argument_list|)
expr_stmt|;
comment|/* Decrement the active job count. */
name|ki
operator|->
name|kaio_active_count
operator|--
expr_stmt|;
block|}
comment|/* 		 * Disconnect from user address space. 		 */
if|if
condition|(
name|p
operator|->
name|p_vmspace
operator|!=
name|myvm
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|aio_job_mtx
argument_list|)
expr_stmt|;
name|vmspace_switch_aio
argument_list|(
name|myvm
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|aio_job_mtx
argument_list|)
expr_stmt|;
comment|/* 			 * We have to restart to avoid race, we only sleep if 			 * no job can be selected. 			 */
continue|continue;
block|}
name|mtx_assert
argument_list|(
operator|&
name|aio_job_mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|aio_freeproc
argument_list|,
name|aiop
argument_list|,
name|list
argument_list|)
expr_stmt|;
name|aiop
operator|->
name|aioprocflags
operator||=
name|AIOP_FREE
expr_stmt|;
comment|/* 		 * If daemon is inactive for a long time, allow it to exit, 		 * thereby freeing resources. 		 */
if|if
condition|(
name|msleep
argument_list|(
name|p
argument_list|,
operator|&
name|aio_job_mtx
argument_list|,
name|PRIBIO
argument_list|,
literal|"aiordy"
argument_list|,
name|aiod_lifetime
argument_list|)
operator|==
name|EWOULDBLOCK
operator|&&
name|TAILQ_EMPTY
argument_list|(
operator|&
name|aio_jobs
argument_list|)
operator|&&
operator|(
name|aiop
operator|->
name|aioprocflags
operator|&
name|AIOP_FREE
operator|)
operator|&&
name|num_aio_procs
operator|>
name|target_aio_procs
condition|)
break|break;
block|}
name|TAILQ_REMOVE
argument_list|(
operator|&
name|aio_freeproc
argument_list|,
name|aiop
argument_list|,
name|list
argument_list|)
expr_stmt|;
name|num_aio_procs
operator|--
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|aio_job_mtx
argument_list|)
expr_stmt|;
name|uma_zfree
argument_list|(
name|aiop_zone
argument_list|,
name|aiop
argument_list|)
expr_stmt|;
name|free_unr
argument_list|(
name|aiod_unr
argument_list|,
name|id
argument_list|)
expr_stmt|;
name|vmspace_free
argument_list|(
name|myvm
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|p
operator|->
name|p_vmspace
operator|==
name|myvm
argument_list|,
operator|(
literal|"AIOD: bad vmspace for exiting daemon"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|myvm
operator|->
name|vm_refcnt
operator|>
literal|1
argument_list|,
operator|(
literal|"AIOD: bad vm refcnt for exiting daemon: %d"
operator|,
name|myvm
operator|->
name|vm_refcnt
operator|)
argument_list|)
expr_stmt|;
name|kproc_exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Create a new AIO daemon. This is mostly a kernel-thread fork routine. The  * AIO daemon modifies its environment itself.  */
end_comment

begin_function
specifier|static
name|int
name|aio_newproc
parameter_list|(
name|int
modifier|*
name|start
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|int
name|id
decl_stmt|;
name|id
operator|=
name|alloc_unr
argument_list|(
name|aiod_unr
argument_list|)
expr_stmt|;
name|error
operator|=
name|kproc_create
argument_list|(
name|aio_daemon
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|intptr_t
operator|)
name|id
argument_list|,
operator|&
name|p
argument_list|,
name|RFNOWAIT
argument_list|,
literal|0
argument_list|,
literal|"aiod%d"
argument_list|,
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
comment|/* 		 * Wait until daemon is started. 		 */
name|sema_wait
argument_list|(
operator|&
name|aio_newproc_sem
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|aio_job_mtx
argument_list|)
expr_stmt|;
name|num_aio_procs
operator|++
expr_stmt|;
if|if
condition|(
name|start
operator|!=
name|NULL
condition|)
operator|(
operator|*
name|start
operator|)
operator|--
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|aio_job_mtx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|free_unr
argument_list|(
name|aiod_unr
argument_list|,
name|id
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Try the high-performance, low-overhead physio method for eligible  * VCHR devices.  This method doesn't use an aio helper thread, and  * thus has very low overhead.  *  * Assumes that the caller, aio_aqueue(), has incremented the file  * structure's reference count, preventing its deallocation for the  * duration of this call.  */
end_comment

begin_function
specifier|static
name|int
name|aio_qphysio
parameter_list|(
name|struct
name|proc
modifier|*
name|p
parameter_list|,
name|struct
name|kaiocb
modifier|*
name|job
parameter_list|)
block|{
name|struct
name|aiocb
modifier|*
name|cb
decl_stmt|;
name|struct
name|file
modifier|*
name|fp
decl_stmt|;
name|struct
name|bio
modifier|*
name|bp
decl_stmt|;
name|struct
name|buf
modifier|*
name|pbuf
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|struct
name|cdevsw
modifier|*
name|csw
decl_stmt|;
name|struct
name|cdev
modifier|*
name|dev
decl_stmt|;
name|struct
name|kaioinfo
modifier|*
name|ki
decl_stmt|;
name|int
name|error
decl_stmt|,
name|ref
decl_stmt|,
name|poff
decl_stmt|;
name|vm_prot_t
name|prot
decl_stmt|;
name|cb
operator|=
operator|&
name|job
operator|->
name|uaiocb
expr_stmt|;
name|fp
operator|=
name|job
operator|->
name|fd_file
expr_stmt|;
if|if
condition|(
name|fp
operator|==
name|NULL
operator|||
name|fp
operator|->
name|f_type
operator|!=
name|DTYPE_VNODE
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|vp
operator|=
name|fp
operator|->
name|f_vnode
expr_stmt|;
if|if
condition|(
name|vp
operator|->
name|v_type
operator|!=
name|VCHR
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|vp
operator|->
name|v_bufobj
operator|.
name|bo_bsize
operator|==
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|cb
operator|->
name|aio_nbytes
operator|%
name|vp
operator|->
name|v_bufobj
operator|.
name|bo_bsize
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|ref
operator|=
literal|0
expr_stmt|;
name|csw
operator|=
name|devvn_refthread
argument_list|(
name|vp
argument_list|,
operator|&
name|dev
argument_list|,
operator|&
name|ref
argument_list|)
expr_stmt|;
if|if
condition|(
name|csw
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
if|if
condition|(
operator|(
name|csw
operator|->
name|d_flags
operator|&
name|D_DISK
operator|)
operator|==
literal|0
condition|)
block|{
name|error
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|unref
goto|;
block|}
if|if
condition|(
name|cb
operator|->
name|aio_nbytes
operator|>
name|dev
operator|->
name|si_iosize_max
condition|)
block|{
name|error
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|unref
goto|;
block|}
name|ki
operator|=
name|p
operator|->
name|p_aioinfo
expr_stmt|;
name|poff
operator|=
operator|(
name|vm_offset_t
operator|)
name|cb
operator|->
name|aio_buf
operator|&
name|PAGE_MASK
expr_stmt|;
if|if
condition|(
operator|(
name|dev
operator|->
name|si_flags
operator|&
name|SI_UNMAPPED
operator|)
operator|&&
name|unmapped_buf_allowed
condition|)
block|{
if|if
condition|(
name|cb
operator|->
name|aio_nbytes
operator|>
name|MAXPHYS
condition|)
block|{
name|error
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|unref
goto|;
block|}
name|pbuf
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|cb
operator|->
name|aio_nbytes
operator|>
name|MAXPHYS
operator|-
name|poff
condition|)
block|{
name|error
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|unref
goto|;
block|}
if|if
condition|(
name|ki
operator|->
name|kaio_buffer_count
operator|>=
name|ki
operator|->
name|kaio_ballowed_count
condition|)
block|{
name|error
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|unref
goto|;
block|}
name|job
operator|->
name|pbuf
operator|=
name|pbuf
operator|=
operator|(
expr|struct
name|buf
operator|*
operator|)
name|getpbuf
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|BUF_KERNPROC
argument_list|(
name|pbuf
argument_list|)
expr_stmt|;
name|AIO_LOCK
argument_list|(
name|ki
argument_list|)
expr_stmt|;
name|ki
operator|->
name|kaio_buffer_count
operator|++
expr_stmt|;
name|AIO_UNLOCK
argument_list|(
name|ki
argument_list|)
expr_stmt|;
block|}
name|job
operator|->
name|bp
operator|=
name|bp
operator|=
name|g_alloc_bio
argument_list|()
expr_stmt|;
name|bp
operator|->
name|bio_length
operator|=
name|cb
operator|->
name|aio_nbytes
expr_stmt|;
name|bp
operator|->
name|bio_bcount
operator|=
name|cb
operator|->
name|aio_nbytes
expr_stmt|;
name|bp
operator|->
name|bio_done
operator|=
name|aio_physwakeup
expr_stmt|;
name|bp
operator|->
name|bio_data
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|cb
operator|->
name|aio_buf
expr_stmt|;
name|bp
operator|->
name|bio_offset
operator|=
name|cb
operator|->
name|aio_offset
expr_stmt|;
name|bp
operator|->
name|bio_cmd
operator|=
name|cb
operator|->
name|aio_lio_opcode
operator|==
name|LIO_WRITE
condition|?
name|BIO_WRITE
else|:
name|BIO_READ
expr_stmt|;
name|bp
operator|->
name|bio_dev
operator|=
name|dev
expr_stmt|;
name|bp
operator|->
name|bio_caller1
operator|=
operator|(
name|void
operator|*
operator|)
name|job
expr_stmt|;
name|prot
operator|=
name|VM_PROT_READ
expr_stmt|;
if|if
condition|(
name|cb
operator|->
name|aio_lio_opcode
operator|==
name|LIO_READ
condition|)
name|prot
operator||=
name|VM_PROT_WRITE
expr_stmt|;
comment|/* Less backwards than it looks */
name|job
operator|->
name|npages
operator|=
name|vm_fault_quick_hold_pages
argument_list|(
operator|&
name|curproc
operator|->
name|p_vmspace
operator|->
name|vm_map
argument_list|,
operator|(
name|vm_offset_t
operator|)
name|bp
operator|->
name|bio_data
argument_list|,
name|bp
operator|->
name|bio_length
argument_list|,
name|prot
argument_list|,
name|job
operator|->
name|pages
argument_list|,
name|nitems
argument_list|(
name|job
operator|->
name|pages
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|job
operator|->
name|npages
operator|<
literal|0
condition|)
block|{
name|error
operator|=
name|EFAULT
expr_stmt|;
goto|goto
name|doerror
goto|;
block|}
if|if
condition|(
name|pbuf
operator|!=
name|NULL
condition|)
block|{
name|pmap_qenter
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|pbuf
operator|->
name|b_data
argument_list|,
name|job
operator|->
name|pages
argument_list|,
name|job
operator|->
name|npages
argument_list|)
expr_stmt|;
name|bp
operator|->
name|bio_data
operator|=
name|pbuf
operator|->
name|b_data
operator|+
name|poff
expr_stmt|;
name|atomic_add_int
argument_list|(
operator|&
name|num_buf_aio
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bp
operator|->
name|bio_ma
operator|=
name|job
operator|->
name|pages
expr_stmt|;
name|bp
operator|->
name|bio_ma_n
operator|=
name|job
operator|->
name|npages
expr_stmt|;
name|bp
operator|->
name|bio_ma_offset
operator|=
name|poff
expr_stmt|;
name|bp
operator|->
name|bio_data
operator|=
name|unmapped_buf
expr_stmt|;
name|bp
operator|->
name|bio_flags
operator||=
name|BIO_UNMAPPED
expr_stmt|;
block|}
comment|/* Perform transfer. */
name|csw
operator|->
name|d_strategy
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|dev_relthread
argument_list|(
name|dev
argument_list|,
name|ref
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|doerror
label|:
if|if
condition|(
name|pbuf
operator|!=
name|NULL
condition|)
block|{
name|AIO_LOCK
argument_list|(
name|ki
argument_list|)
expr_stmt|;
name|ki
operator|->
name|kaio_buffer_count
operator|--
expr_stmt|;
name|AIO_UNLOCK
argument_list|(
name|ki
argument_list|)
expr_stmt|;
name|relpbuf
argument_list|(
name|pbuf
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|job
operator|->
name|pbuf
operator|=
name|NULL
expr_stmt|;
block|}
name|g_destroy_bio
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|job
operator|->
name|bp
operator|=
name|NULL
expr_stmt|;
name|unref
label|:
name|dev_relthread
argument_list|(
name|dev
argument_list|,
name|ref
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|COMPAT_FREEBSD6
end_ifdef

begin_function
specifier|static
name|int
name|convert_old_sigevent
parameter_list|(
name|struct
name|osigevent
modifier|*
name|osig
parameter_list|,
name|struct
name|sigevent
modifier|*
name|nsig
parameter_list|)
block|{
comment|/* 	 * Only SIGEV_NONE, SIGEV_SIGNAL, and SIGEV_KEVENT are 	 * supported by AIO with the old sigevent structure. 	 */
name|nsig
operator|->
name|sigev_notify
operator|=
name|osig
operator|->
name|sigev_notify
expr_stmt|;
switch|switch
condition|(
name|nsig
operator|->
name|sigev_notify
condition|)
block|{
case|case
name|SIGEV_NONE
case|:
break|break;
case|case
name|SIGEV_SIGNAL
case|:
name|nsig
operator|->
name|sigev_signo
operator|=
name|osig
operator|->
name|__sigev_u
operator|.
name|__sigev_signo
expr_stmt|;
break|break;
case|case
name|SIGEV_KEVENT
case|:
name|nsig
operator|->
name|sigev_notify_kqueue
operator|=
name|osig
operator|->
name|__sigev_u
operator|.
name|__sigev_notify_kqueue
expr_stmt|;
name|nsig
operator|->
name|sigev_value
operator|.
name|sival_ptr
operator|=
name|osig
operator|->
name|sigev_value
operator|.
name|sival_ptr
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|aiocb_copyin_old_sigevent
parameter_list|(
name|struct
name|aiocb
modifier|*
name|ujob
parameter_list|,
name|struct
name|aiocb
modifier|*
name|kjob
parameter_list|)
block|{
name|struct
name|oaiocb
modifier|*
name|ojob
decl_stmt|;
name|int
name|error
decl_stmt|;
name|bzero
argument_list|(
name|kjob
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|aiocb
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|copyin
argument_list|(
name|ujob
argument_list|,
name|kjob
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|oaiocb
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|ojob
operator|=
operator|(
expr|struct
name|oaiocb
operator|*
operator|)
name|kjob
expr_stmt|;
return|return
operator|(
name|convert_old_sigevent
argument_list|(
operator|&
name|ojob
operator|->
name|aio_sigevent
argument_list|,
operator|&
name|kjob
operator|->
name|aio_sigevent
argument_list|)
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|int
name|aiocb_copyin
parameter_list|(
name|struct
name|aiocb
modifier|*
name|ujob
parameter_list|,
name|struct
name|aiocb
modifier|*
name|kjob
parameter_list|)
block|{
return|return
operator|(
name|copyin
argument_list|(
name|ujob
argument_list|,
name|kjob
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|aiocb
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|long
name|aiocb_fetch_status
parameter_list|(
name|struct
name|aiocb
modifier|*
name|ujob
parameter_list|)
block|{
return|return
operator|(
name|fuword
argument_list|(
operator|&
name|ujob
operator|->
name|_aiocb_private
operator|.
name|status
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|long
name|aiocb_fetch_error
parameter_list|(
name|struct
name|aiocb
modifier|*
name|ujob
parameter_list|)
block|{
return|return
operator|(
name|fuword
argument_list|(
operator|&
name|ujob
operator|->
name|_aiocb_private
operator|.
name|error
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|aiocb_store_status
parameter_list|(
name|struct
name|aiocb
modifier|*
name|ujob
parameter_list|,
name|long
name|status
parameter_list|)
block|{
return|return
operator|(
name|suword
argument_list|(
operator|&
name|ujob
operator|->
name|_aiocb_private
operator|.
name|status
argument_list|,
name|status
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|aiocb_store_error
parameter_list|(
name|struct
name|aiocb
modifier|*
name|ujob
parameter_list|,
name|long
name|error
parameter_list|)
block|{
return|return
operator|(
name|suword
argument_list|(
operator|&
name|ujob
operator|->
name|_aiocb_private
operator|.
name|error
argument_list|,
name|error
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|aiocb_store_kernelinfo
parameter_list|(
name|struct
name|aiocb
modifier|*
name|ujob
parameter_list|,
name|long
name|jobref
parameter_list|)
block|{
return|return
operator|(
name|suword
argument_list|(
operator|&
name|ujob
operator|->
name|_aiocb_private
operator|.
name|kernelinfo
argument_list|,
name|jobref
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|aiocb_store_aiocb
parameter_list|(
name|struct
name|aiocb
modifier|*
modifier|*
name|ujobp
parameter_list|,
name|struct
name|aiocb
modifier|*
name|ujob
parameter_list|)
block|{
return|return
operator|(
name|suword
argument_list|(
name|ujobp
argument_list|,
operator|(
name|long
operator|)
name|ujob
argument_list|)
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|aiocb_ops
name|aiocb_ops
init|=
block|{
operator|.
name|copyin
operator|=
name|aiocb_copyin
block|,
operator|.
name|fetch_status
operator|=
name|aiocb_fetch_status
block|,
operator|.
name|fetch_error
operator|=
name|aiocb_fetch_error
block|,
operator|.
name|store_status
operator|=
name|aiocb_store_status
block|,
operator|.
name|store_error
operator|=
name|aiocb_store_error
block|,
operator|.
name|store_kernelinfo
operator|=
name|aiocb_store_kernelinfo
block|,
operator|.
name|store_aiocb
operator|=
name|aiocb_store_aiocb
block|, }
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|COMPAT_FREEBSD6
end_ifdef

begin_decl_stmt
specifier|static
name|struct
name|aiocb_ops
name|aiocb_ops_osigevent
init|=
block|{
operator|.
name|copyin
operator|=
name|aiocb_copyin_old_sigevent
block|,
operator|.
name|fetch_status
operator|=
name|aiocb_fetch_status
block|,
operator|.
name|fetch_error
operator|=
name|aiocb_fetch_error
block|,
operator|.
name|store_status
operator|=
name|aiocb_store_status
block|,
operator|.
name|store_error
operator|=
name|aiocb_store_error
block|,
operator|.
name|store_kernelinfo
operator|=
name|aiocb_store_kernelinfo
block|,
operator|.
name|store_aiocb
operator|=
name|aiocb_store_aiocb
block|, }
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Queue a new AIO request.  Choosing either the threaded or direct physio VCHR  * technique is done in this code.  */
end_comment

begin_function
name|int
name|aio_aqueue
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|aiocb
modifier|*
name|ujob
parameter_list|,
name|struct
name|aioliojob
modifier|*
name|lj
parameter_list|,
name|int
name|type
parameter_list|,
name|struct
name|aiocb_ops
modifier|*
name|ops
parameter_list|)
block|{
name|struct
name|proc
modifier|*
name|p
init|=
name|td
operator|->
name|td_proc
decl_stmt|;
name|cap_rights_t
name|rights
decl_stmt|;
name|struct
name|file
modifier|*
name|fp
decl_stmt|;
name|struct
name|kaiocb
modifier|*
name|job
decl_stmt|;
name|struct
name|kaioinfo
modifier|*
name|ki
decl_stmt|;
name|struct
name|kevent
name|kev
decl_stmt|;
name|int
name|opcode
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|fd
decl_stmt|,
name|kqfd
decl_stmt|;
name|int
name|jid
decl_stmt|;
name|u_short
name|evflags
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|p_aioinfo
operator|==
name|NULL
condition|)
name|aio_init_aioinfo
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|ki
operator|=
name|p
operator|->
name|p_aioinfo
expr_stmt|;
name|ops
operator|->
name|store_status
argument_list|(
name|ujob
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|ops
operator|->
name|store_error
argument_list|(
name|ujob
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ops
operator|->
name|store_kernelinfo
argument_list|(
name|ujob
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|num_queue_count
operator|>=
name|max_queue_count
operator|||
name|ki
operator|->
name|kaio_count
operator|>=
name|ki
operator|->
name|kaio_qallowed_count
condition|)
block|{
name|ops
operator|->
name|store_error
argument_list|(
name|ujob
argument_list|,
name|EAGAIN
argument_list|)
expr_stmt|;
return|return
operator|(
name|EAGAIN
operator|)
return|;
block|}
name|job
operator|=
name|uma_zalloc
argument_list|(
name|aiocb_zone
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|knlist_init_mtx
argument_list|(
operator|&
name|job
operator|->
name|klist
argument_list|,
name|AIO_MTX
argument_list|(
name|ki
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|ops
operator|->
name|copyin
argument_list|(
name|ujob
argument_list|,
operator|&
name|job
operator|->
name|uaiocb
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|ops
operator|->
name|store_error
argument_list|(
name|ujob
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|uma_zfree
argument_list|(
name|aiocb_zone
argument_list|,
name|job
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
name|job
operator|->
name|uaiocb
operator|.
name|aio_nbytes
operator|>
name|IOSIZE_MAX
condition|)
block|{
name|uma_zfree
argument_list|(
name|aiocb_zone
argument_list|,
name|job
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
name|job
operator|->
name|uaiocb
operator|.
name|aio_sigevent
operator|.
name|sigev_notify
operator|!=
name|SIGEV_KEVENT
operator|&&
name|job
operator|->
name|uaiocb
operator|.
name|aio_sigevent
operator|.
name|sigev_notify
operator|!=
name|SIGEV_SIGNAL
operator|&&
name|job
operator|->
name|uaiocb
operator|.
name|aio_sigevent
operator|.
name|sigev_notify
operator|!=
name|SIGEV_THREAD_ID
operator|&&
name|job
operator|->
name|uaiocb
operator|.
name|aio_sigevent
operator|.
name|sigev_notify
operator|!=
name|SIGEV_NONE
condition|)
block|{
name|ops
operator|->
name|store_error
argument_list|(
name|ujob
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
name|uma_zfree
argument_list|(
name|aiocb_zone
argument_list|,
name|job
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|job
operator|->
name|uaiocb
operator|.
name|aio_sigevent
operator|.
name|sigev_notify
operator|==
name|SIGEV_SIGNAL
operator|||
name|job
operator|->
name|uaiocb
operator|.
name|aio_sigevent
operator|.
name|sigev_notify
operator|==
name|SIGEV_THREAD_ID
operator|)
operator|&&
operator|!
name|_SIG_VALID
argument_list|(
name|job
operator|->
name|uaiocb
operator|.
name|aio_sigevent
operator|.
name|sigev_signo
argument_list|)
condition|)
block|{
name|uma_zfree
argument_list|(
name|aiocb_zone
argument_list|,
name|job
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|ksiginfo_init
argument_list|(
operator|&
name|job
operator|->
name|ksi
argument_list|)
expr_stmt|;
comment|/* Save userspace address of the job info. */
name|job
operator|->
name|ujob
operator|=
name|ujob
expr_stmt|;
comment|/* Get the opcode. */
if|if
condition|(
name|type
operator|!=
name|LIO_NOP
condition|)
name|job
operator|->
name|uaiocb
operator|.
name|aio_lio_opcode
operator|=
name|type
expr_stmt|;
name|opcode
operator|=
name|job
operator|->
name|uaiocb
operator|.
name|aio_lio_opcode
expr_stmt|;
comment|/* 	 * Validate the opcode and fetch the file object for the specified 	 * file descriptor. 	 * 	 * XXXRW: Moved the opcode validation up here so that we don't 	 * retrieve a file descriptor without knowing what the capabiltity 	 * should be. 	 */
name|fd
operator|=
name|job
operator|->
name|uaiocb
operator|.
name|aio_fildes
expr_stmt|;
switch|switch
condition|(
name|opcode
condition|)
block|{
case|case
name|LIO_WRITE
case|:
name|error
operator|=
name|fget_write
argument_list|(
name|td
argument_list|,
name|fd
argument_list|,
name|cap_rights_init
argument_list|(
operator|&
name|rights
argument_list|,
name|CAP_PWRITE
argument_list|)
argument_list|,
operator|&
name|fp
argument_list|)
expr_stmt|;
break|break;
case|case
name|LIO_READ
case|:
name|error
operator|=
name|fget_read
argument_list|(
name|td
argument_list|,
name|fd
argument_list|,
name|cap_rights_init
argument_list|(
operator|&
name|rights
argument_list|,
name|CAP_PREAD
argument_list|)
argument_list|,
operator|&
name|fp
argument_list|)
expr_stmt|;
break|break;
case|case
name|LIO_SYNC
case|:
name|error
operator|=
name|fget
argument_list|(
name|td
argument_list|,
name|fd
argument_list|,
name|cap_rights_init
argument_list|(
operator|&
name|rights
argument_list|,
name|CAP_FSYNC
argument_list|)
argument_list|,
operator|&
name|fp
argument_list|)
expr_stmt|;
break|break;
case|case
name|LIO_MLOCK
case|:
name|fp
operator|=
name|NULL
expr_stmt|;
break|break;
case|case
name|LIO_NOP
case|:
name|error
operator|=
name|fget
argument_list|(
name|td
argument_list|,
name|fd
argument_list|,
name|cap_rights_init
argument_list|(
operator|&
name|rights
argument_list|)
argument_list|,
operator|&
name|fp
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
if|if
condition|(
name|error
condition|)
block|{
name|uma_zfree
argument_list|(
name|aiocb_zone
argument_list|,
name|job
argument_list|)
expr_stmt|;
name|ops
operator|->
name|store_error
argument_list|(
name|ujob
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
name|opcode
operator|==
name|LIO_SYNC
operator|&&
name|fp
operator|->
name|f_vnode
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|aqueue_fail
goto|;
block|}
if|if
condition|(
operator|(
name|opcode
operator|==
name|LIO_READ
operator|||
name|opcode
operator|==
name|LIO_WRITE
operator|)
operator|&&
name|job
operator|->
name|uaiocb
operator|.
name|aio_offset
operator|<
literal|0
operator|&&
operator|(
name|fp
operator|->
name|f_vnode
operator|==
name|NULL
operator|||
name|fp
operator|->
name|f_vnode
operator|->
name|v_type
operator|!=
name|VCHR
operator|)
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|aqueue_fail
goto|;
block|}
name|job
operator|->
name|fd_file
operator|=
name|fp
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|aio_job_mtx
argument_list|)
expr_stmt|;
name|jid
operator|=
name|jobrefid
operator|++
expr_stmt|;
name|job
operator|->
name|seqno
operator|=
name|jobseqno
operator|++
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|aio_job_mtx
argument_list|)
expr_stmt|;
name|error
operator|=
name|ops
operator|->
name|store_kernelinfo
argument_list|(
name|ujob
argument_list|,
name|jid
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|aqueue_fail
goto|;
block|}
name|job
operator|->
name|uaiocb
operator|.
name|_aiocb_private
operator|.
name|kernelinfo
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
name|intptr_t
operator|)
name|jid
expr_stmt|;
if|if
condition|(
name|opcode
operator|==
name|LIO_NOP
condition|)
block|{
name|fdrop
argument_list|(
name|fp
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|uma_zfree
argument_list|(
name|aiocb_zone
argument_list|,
name|job
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|job
operator|->
name|uaiocb
operator|.
name|aio_sigevent
operator|.
name|sigev_notify
operator|!=
name|SIGEV_KEVENT
condition|)
goto|goto
name|no_kqueue
goto|;
name|evflags
operator|=
name|job
operator|->
name|uaiocb
operator|.
name|aio_sigevent
operator|.
name|sigev_notify_kevent_flags
expr_stmt|;
if|if
condition|(
operator|(
name|evflags
operator|&
operator|~
operator|(
name|EV_CLEAR
operator||
name|EV_DISPATCH
operator||
name|EV_ONESHOT
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|aqueue_fail
goto|;
block|}
name|kqfd
operator|=
name|job
operator|->
name|uaiocb
operator|.
name|aio_sigevent
operator|.
name|sigev_notify_kqueue
expr_stmt|;
name|kev
operator|.
name|ident
operator|=
operator|(
name|uintptr_t
operator|)
name|job
operator|->
name|ujob
expr_stmt|;
name|kev
operator|.
name|filter
operator|=
name|EVFILT_AIO
expr_stmt|;
name|kev
operator|.
name|flags
operator|=
name|EV_ADD
operator||
name|EV_ENABLE
operator||
name|EV_FLAG1
operator||
name|evflags
expr_stmt|;
name|kev
operator|.
name|data
operator|=
operator|(
name|intptr_t
operator|)
name|job
expr_stmt|;
name|kev
operator|.
name|udata
operator|=
name|job
operator|->
name|uaiocb
operator|.
name|aio_sigevent
operator|.
name|sigev_value
operator|.
name|sival_ptr
expr_stmt|;
name|error
operator|=
name|kqfd_register
argument_list|(
name|kqfd
argument_list|,
operator|&
name|kev
argument_list|,
name|td
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|aqueue_fail
goto|;
name|no_kqueue
label|:
name|ops
operator|->
name|store_error
argument_list|(
name|ujob
argument_list|,
name|EINPROGRESS
argument_list|)
expr_stmt|;
name|job
operator|->
name|uaiocb
operator|.
name|_aiocb_private
operator|.
name|error
operator|=
name|EINPROGRESS
expr_stmt|;
name|job
operator|->
name|userproc
operator|=
name|p
expr_stmt|;
name|job
operator|->
name|cred
operator|=
name|crhold
argument_list|(
name|td
operator|->
name|td_ucred
argument_list|)
expr_stmt|;
name|job
operator|->
name|jobflags
operator|=
name|KAIOCB_QUEUEING
expr_stmt|;
name|job
operator|->
name|lio
operator|=
name|lj
expr_stmt|;
if|if
condition|(
name|opcode
operator|==
name|LIO_MLOCK
condition|)
block|{
name|aio_schedule
argument_list|(
name|job
argument_list|,
name|aio_process_mlock
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fp
operator|->
name|f_ops
operator|->
name|fo_aio_queue
operator|==
name|NULL
condition|)
name|error
operator|=
name|aio_queue_file
argument_list|(
name|fp
argument_list|,
name|job
argument_list|)
expr_stmt|;
else|else
name|error
operator|=
name|fo_aio_queue
argument_list|(
name|fp
argument_list|,
name|job
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|aqueue_fail
goto|;
name|AIO_LOCK
argument_list|(
name|ki
argument_list|)
expr_stmt|;
name|job
operator|->
name|jobflags
operator|&=
operator|~
name|KAIOCB_QUEUEING
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|ki
operator|->
name|kaio_all
argument_list|,
name|job
argument_list|,
name|allist
argument_list|)
expr_stmt|;
name|ki
operator|->
name|kaio_count
operator|++
expr_stmt|;
if|if
condition|(
name|lj
condition|)
name|lj
operator|->
name|lioj_count
operator|++
expr_stmt|;
name|atomic_add_int
argument_list|(
operator|&
name|num_queue_count
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|job
operator|->
name|jobflags
operator|&
name|KAIOCB_FINISHED
condition|)
block|{
comment|/* 		 * The queue callback completed the request synchronously. 		 * The bulk of the completion is deferred in that case 		 * until this point. 		 */
name|aio_bio_done_notify
argument_list|(
name|p
argument_list|,
name|job
argument_list|)
expr_stmt|;
block|}
else|else
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|ki
operator|->
name|kaio_jobqueue
argument_list|,
name|job
argument_list|,
name|plist
argument_list|)
expr_stmt|;
name|AIO_UNLOCK
argument_list|(
name|ki
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|aqueue_fail
label|:
name|knlist_delete
argument_list|(
operator|&
name|job
operator|->
name|klist
argument_list|,
name|curthread
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
condition|)
name|fdrop
argument_list|(
name|fp
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|uma_zfree
argument_list|(
name|aiocb_zone
argument_list|,
name|job
argument_list|)
expr_stmt|;
name|ops
operator|->
name|store_error
argument_list|(
name|ujob
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|aio_cancel_daemon_job
parameter_list|(
name|struct
name|kaiocb
modifier|*
name|job
parameter_list|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|aio_job_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|aio_cancel_cleared
argument_list|(
name|job
argument_list|)
condition|)
name|TAILQ_REMOVE
argument_list|(
operator|&
name|aio_jobs
argument_list|,
name|job
argument_list|,
name|list
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|aio_job_mtx
argument_list|)
expr_stmt|;
name|aio_cancel
argument_list|(
name|job
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|aio_schedule
parameter_list|(
name|struct
name|kaiocb
modifier|*
name|job
parameter_list|,
name|aio_handle_fn_t
modifier|*
name|func
parameter_list|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|aio_job_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|aio_set_cancel_function
argument_list|(
name|job
argument_list|,
name|aio_cancel_daemon_job
argument_list|)
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|aio_job_mtx
argument_list|)
expr_stmt|;
name|aio_cancel
argument_list|(
name|job
argument_list|)
expr_stmt|;
return|return;
block|}
name|job
operator|->
name|handle_fn
operator|=
name|func
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|aio_jobs
argument_list|,
name|job
argument_list|,
name|list
argument_list|)
expr_stmt|;
name|aio_kick_nowait
argument_list|(
name|job
operator|->
name|userproc
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|aio_job_mtx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|aio_cancel_sync
parameter_list|(
name|struct
name|kaiocb
modifier|*
name|job
parameter_list|)
block|{
name|struct
name|kaioinfo
modifier|*
name|ki
decl_stmt|;
name|ki
operator|=
name|job
operator|->
name|userproc
operator|->
name|p_aioinfo
expr_stmt|;
name|AIO_LOCK
argument_list|(
name|ki
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|aio_cancel_cleared
argument_list|(
name|job
argument_list|)
condition|)
name|TAILQ_REMOVE
argument_list|(
operator|&
name|ki
operator|->
name|kaio_syncqueue
argument_list|,
name|job
argument_list|,
name|list
argument_list|)
expr_stmt|;
name|AIO_UNLOCK
argument_list|(
name|ki
argument_list|)
expr_stmt|;
name|aio_cancel
argument_list|(
name|job
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|aio_queue_file
parameter_list|(
name|struct
name|file
modifier|*
name|fp
parameter_list|,
name|struct
name|kaiocb
modifier|*
name|job
parameter_list|)
block|{
name|struct
name|aioliojob
modifier|*
name|lj
decl_stmt|;
name|struct
name|kaioinfo
modifier|*
name|ki
decl_stmt|;
name|struct
name|kaiocb
modifier|*
name|job2
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|struct
name|mount
modifier|*
name|mp
decl_stmt|;
name|int
name|error
decl_stmt|,
name|opcode
decl_stmt|;
name|bool
name|safe
decl_stmt|;
name|lj
operator|=
name|job
operator|->
name|lio
expr_stmt|;
name|ki
operator|=
name|job
operator|->
name|userproc
operator|->
name|p_aioinfo
expr_stmt|;
name|opcode
operator|=
name|job
operator|->
name|uaiocb
operator|.
name|aio_lio_opcode
expr_stmt|;
if|if
condition|(
name|opcode
operator|==
name|LIO_SYNC
condition|)
goto|goto
name|queueit
goto|;
if|if
condition|(
operator|(
name|error
operator|=
name|aio_qphysio
argument_list|(
name|job
operator|->
name|userproc
argument_list|,
name|job
argument_list|)
operator|)
operator|==
literal|0
condition|)
goto|goto
name|done
goto|;
if|#
directive|if
literal|0
comment|/* 	 * XXX: This means qphysio() failed with EFAULT.  The current 	 * behavior is to retry the operation via fo_read/fo_write. 	 * Wouldn't it be better to just complete the request with an 	 * error here? 	 */
block|if (error> 0) 		goto done;
endif|#
directive|endif
name|queueit
label|:
name|safe
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|fp
operator|->
name|f_type
operator|==
name|DTYPE_VNODE
condition|)
block|{
name|vp
operator|=
name|fp
operator|->
name|f_vnode
expr_stmt|;
if|if
condition|(
name|vp
operator|->
name|v_type
operator|==
name|VREG
operator|||
name|vp
operator|->
name|v_type
operator|==
name|VDIR
condition|)
block|{
name|mp
operator|=
name|fp
operator|->
name|f_vnode
operator|->
name|v_mount
expr_stmt|;
if|if
condition|(
name|mp
operator|==
name|NULL
operator|||
operator|(
name|mp
operator|->
name|mnt_flag
operator|&
name|MNT_LOCAL
operator|)
operator|!=
literal|0
condition|)
name|safe
operator|=
name|true
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
operator|(
name|safe
operator|||
name|enable_aio_unsafe
operator|)
condition|)
block|{
name|counted_warning
argument_list|(
operator|&
name|unsafe_warningcnt
argument_list|,
literal|"is attempting to use unsafe AIO requests"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
block|}
if|if
condition|(
name|opcode
operator|==
name|LIO_SYNC
condition|)
block|{
name|AIO_LOCK
argument_list|(
name|ki
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|job2
argument_list|,
argument|&ki->kaio_jobqueue
argument_list|,
argument|plist
argument_list|)
block|{
if|if
condition|(
name|job2
operator|->
name|fd_file
operator|==
name|job
operator|->
name|fd_file
operator|&&
name|job2
operator|->
name|uaiocb
operator|.
name|aio_lio_opcode
operator|!=
name|LIO_SYNC
operator|&&
name|job2
operator|->
name|seqno
operator|<
name|job
operator|->
name|seqno
condition|)
block|{
name|job2
operator|->
name|jobflags
operator||=
name|KAIOCB_CHECKSYNC
expr_stmt|;
name|job
operator|->
name|pending
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|job
operator|->
name|pending
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|aio_set_cancel_function_locked
argument_list|(
name|job
argument_list|,
name|aio_cancel_sync
argument_list|)
condition|)
block|{
name|AIO_UNLOCK
argument_list|(
name|ki
argument_list|)
expr_stmt|;
name|aio_cancel
argument_list|(
name|job
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|ki
operator|->
name|kaio_syncqueue
argument_list|,
name|job
argument_list|,
name|list
argument_list|)
expr_stmt|;
name|AIO_UNLOCK
argument_list|(
name|ki
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|AIO_UNLOCK
argument_list|(
name|ki
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|opcode
condition|)
block|{
case|case
name|LIO_READ
case|:
case|case
name|LIO_WRITE
case|:
name|aio_schedule
argument_list|(
name|job
argument_list|,
name|aio_process_rw
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|LIO_SYNC
case|:
name|aio_schedule
argument_list|(
name|job
argument_list|,
name|aio_process_sync
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
name|done
label|:
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|aio_kick_nowait
parameter_list|(
name|struct
name|proc
modifier|*
name|userp
parameter_list|)
block|{
name|struct
name|kaioinfo
modifier|*
name|ki
init|=
name|userp
operator|->
name|p_aioinfo
decl_stmt|;
name|struct
name|aioproc
modifier|*
name|aiop
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|aio_job_mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|aiop
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|aio_freeproc
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|aio_freeproc
argument_list|,
name|aiop
argument_list|,
name|list
argument_list|)
expr_stmt|;
name|aiop
operator|->
name|aioprocflags
operator|&=
operator|~
name|AIOP_FREE
expr_stmt|;
name|wakeup
argument_list|(
name|aiop
operator|->
name|aioproc
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|num_aio_resv_start
operator|+
name|num_aio_procs
operator|<
name|max_aio_procs
operator|&&
name|ki
operator|->
name|kaio_active_count
operator|+
name|num_aio_resv_start
operator|<
name|ki
operator|->
name|kaio_maxactive_count
condition|)
block|{
name|taskqueue_enqueue
argument_list|(
name|taskqueue_aiod_kick
argument_list|,
operator|&
name|ki
operator|->
name|kaio_task
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|aio_kick
parameter_list|(
name|struct
name|proc
modifier|*
name|userp
parameter_list|)
block|{
name|struct
name|kaioinfo
modifier|*
name|ki
init|=
name|userp
operator|->
name|p_aioinfo
decl_stmt|;
name|struct
name|aioproc
modifier|*
name|aiop
decl_stmt|;
name|int
name|error
decl_stmt|,
name|ret
init|=
literal|0
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|aio_job_mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|retryproc
label|:
if|if
condition|(
operator|(
name|aiop
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|aio_freeproc
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|aio_freeproc
argument_list|,
name|aiop
argument_list|,
name|list
argument_list|)
expr_stmt|;
name|aiop
operator|->
name|aioprocflags
operator|&=
operator|~
name|AIOP_FREE
expr_stmt|;
name|wakeup
argument_list|(
name|aiop
operator|->
name|aioproc
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|num_aio_resv_start
operator|+
name|num_aio_procs
operator|<
name|max_aio_procs
operator|&&
name|ki
operator|->
name|kaio_active_count
operator|+
name|num_aio_resv_start
operator|<
name|ki
operator|->
name|kaio_maxactive_count
condition|)
block|{
name|num_aio_resv_start
operator|++
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|aio_job_mtx
argument_list|)
expr_stmt|;
name|error
operator|=
name|aio_newproc
argument_list|(
operator|&
name|num_aio_resv_start
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|aio_job_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|num_aio_resv_start
operator|--
expr_stmt|;
goto|goto
name|retryproc
goto|;
block|}
block|}
else|else
block|{
name|ret
operator|=
operator|-
literal|1
expr_stmt|;
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|aio_kick_helper
parameter_list|(
name|void
modifier|*
name|context
parameter_list|,
name|int
name|pending
parameter_list|)
block|{
name|struct
name|proc
modifier|*
name|userp
init|=
name|context
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|aio_job_mtx
argument_list|)
expr_stmt|;
while|while
condition|(
operator|--
name|pending
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|aio_kick
argument_list|(
name|userp
argument_list|)
condition|)
break|break;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|aio_job_mtx
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Support the aio_return system call, as a side-effect, kernel resources are  * released.  */
end_comment

begin_function
specifier|static
name|int
name|kern_aio_return
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|aiocb
modifier|*
name|ujob
parameter_list|,
name|struct
name|aiocb_ops
modifier|*
name|ops
parameter_list|)
block|{
name|struct
name|proc
modifier|*
name|p
init|=
name|td
operator|->
name|td_proc
decl_stmt|;
name|struct
name|kaiocb
modifier|*
name|job
decl_stmt|;
name|struct
name|kaioinfo
modifier|*
name|ki
decl_stmt|;
name|long
name|status
decl_stmt|,
name|error
decl_stmt|;
name|ki
operator|=
name|p
operator|->
name|p_aioinfo
expr_stmt|;
if|if
condition|(
name|ki
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|AIO_LOCK
argument_list|(
name|ki
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|job
argument_list|,
argument|&ki->kaio_done
argument_list|,
argument|plist
argument_list|)
block|{
if|if
condition|(
name|job
operator|->
name|ujob
operator|==
name|ujob
condition|)
break|break;
block|}
if|if
condition|(
name|job
operator|!=
name|NULL
condition|)
block|{
name|MPASS
argument_list|(
name|job
operator|->
name|jobflags
operator|&
name|KAIOCB_FINISHED
argument_list|)
expr_stmt|;
name|status
operator|=
name|job
operator|->
name|uaiocb
operator|.
name|_aiocb_private
operator|.
name|status
expr_stmt|;
name|error
operator|=
name|job
operator|->
name|uaiocb
operator|.
name|_aiocb_private
operator|.
name|error
expr_stmt|;
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|=
name|status
expr_stmt|;
name|td
operator|->
name|td_ru
operator|.
name|ru_oublock
operator|+=
name|job
operator|->
name|outblock
expr_stmt|;
name|td
operator|->
name|td_ru
operator|.
name|ru_inblock
operator|+=
name|job
operator|->
name|inblock
expr_stmt|;
name|td
operator|->
name|td_ru
operator|.
name|ru_msgsnd
operator|+=
name|job
operator|->
name|msgsnd
expr_stmt|;
name|td
operator|->
name|td_ru
operator|.
name|ru_msgrcv
operator|+=
name|job
operator|->
name|msgrcv
expr_stmt|;
name|aio_free_entry
argument_list|(
name|job
argument_list|)
expr_stmt|;
name|AIO_UNLOCK
argument_list|(
name|ki
argument_list|)
expr_stmt|;
name|ops
operator|->
name|store_error
argument_list|(
name|ujob
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|ops
operator|->
name|store_status
argument_list|(
name|ujob
argument_list|,
name|status
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
name|AIO_UNLOCK
argument_list|(
name|ki
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|sys_aio_return
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|aio_return_args
modifier|*
name|uap
parameter_list|)
block|{
return|return
operator|(
name|kern_aio_return
argument_list|(
name|td
argument_list|,
name|uap
operator|->
name|aiocbp
argument_list|,
operator|&
name|aiocb_ops
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Allow a process to wakeup when any of the I/O requests are completed.  */
end_comment

begin_function
specifier|static
name|int
name|kern_aio_suspend
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|int
name|njoblist
parameter_list|,
name|struct
name|aiocb
modifier|*
modifier|*
name|ujoblist
parameter_list|,
name|struct
name|timespec
modifier|*
name|ts
parameter_list|)
block|{
name|struct
name|proc
modifier|*
name|p
init|=
name|td
operator|->
name|td_proc
decl_stmt|;
name|struct
name|timeval
name|atv
decl_stmt|;
name|struct
name|kaioinfo
modifier|*
name|ki
decl_stmt|;
name|struct
name|kaiocb
modifier|*
name|firstjob
decl_stmt|,
modifier|*
name|job
decl_stmt|;
name|int
name|error
decl_stmt|,
name|i
decl_stmt|,
name|timo
decl_stmt|;
name|timo
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ts
condition|)
block|{
if|if
condition|(
name|ts
operator|->
name|tv_nsec
operator|<
literal|0
operator|||
name|ts
operator|->
name|tv_nsec
operator|>=
literal|1000000000
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|TIMESPEC_TO_TIMEVAL
argument_list|(
operator|&
name|atv
argument_list|,
name|ts
argument_list|)
expr_stmt|;
if|if
condition|(
name|itimerfix
argument_list|(
operator|&
name|atv
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|timo
operator|=
name|tvtohz
argument_list|(
operator|&
name|atv
argument_list|)
expr_stmt|;
block|}
name|ki
operator|=
name|p
operator|->
name|p_aioinfo
expr_stmt|;
if|if
condition|(
name|ki
operator|==
name|NULL
condition|)
return|return
operator|(
name|EAGAIN
operator|)
return|;
if|if
condition|(
name|njoblist
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|AIO_LOCK
argument_list|(
name|ki
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|firstjob
operator|=
name|NULL
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|job
argument_list|,
argument|&ki->kaio_all
argument_list|,
argument|allist
argument_list|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|njoblist
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|job
operator|->
name|ujob
operator|==
name|ujoblist
index|[
name|i
index|]
condition|)
block|{
if|if
condition|(
name|firstjob
operator|==
name|NULL
condition|)
name|firstjob
operator|=
name|job
expr_stmt|;
if|if
condition|(
name|job
operator|->
name|jobflags
operator|&
name|KAIOCB_FINISHED
condition|)
goto|goto
name|RETURN
goto|;
block|}
block|}
block|}
comment|/* All tasks were finished. */
if|if
condition|(
name|firstjob
operator|==
name|NULL
condition|)
break|break;
name|ki
operator|->
name|kaio_flags
operator||=
name|KAIO_WAKEUP
expr_stmt|;
name|error
operator|=
name|msleep
argument_list|(
operator|&
name|p
operator|->
name|p_aioinfo
argument_list|,
name|AIO_MTX
argument_list|(
name|ki
argument_list|)
argument_list|,
name|PRIBIO
operator||
name|PCATCH
argument_list|,
literal|"aiospn"
argument_list|,
name|timo
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|ERESTART
condition|)
name|error
operator|=
name|EINTR
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
block|}
name|RETURN
label|:
name|AIO_UNLOCK
argument_list|(
name|ki
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|sys_aio_suspend
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|aio_suspend_args
modifier|*
name|uap
parameter_list|)
block|{
name|struct
name|timespec
name|ts
decl_stmt|,
modifier|*
name|tsp
decl_stmt|;
name|struct
name|aiocb
modifier|*
modifier|*
name|ujoblist
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|uap
operator|->
name|nent
operator|<
literal|0
operator|||
name|uap
operator|->
name|nent
operator|>
name|AIO_LISTIO_MAX
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|uap
operator|->
name|timeout
condition|)
block|{
comment|/* Get timespec struct. */
if|if
condition|(
operator|(
name|error
operator|=
name|copyin
argument_list|(
name|uap
operator|->
name|timeout
argument_list|,
operator|&
name|ts
argument_list|,
sizeof|sizeof
argument_list|(
name|ts
argument_list|)
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|tsp
operator|=
operator|&
name|ts
expr_stmt|;
block|}
else|else
name|tsp
operator|=
name|NULL
expr_stmt|;
name|ujoblist
operator|=
name|uma_zalloc
argument_list|(
name|aiol_zone
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|error
operator|=
name|copyin
argument_list|(
name|uap
operator|->
name|aiocbp
argument_list|,
name|ujoblist
argument_list|,
name|uap
operator|->
name|nent
operator|*
sizeof|sizeof
argument_list|(
name|ujoblist
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|error
operator|=
name|kern_aio_suspend
argument_list|(
name|td
argument_list|,
name|uap
operator|->
name|nent
argument_list|,
name|ujoblist
argument_list|,
name|tsp
argument_list|)
expr_stmt|;
name|uma_zfree
argument_list|(
name|aiol_zone
argument_list|,
name|ujoblist
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * aio_cancel cancels any non-physio aio operations not currently in  * progress.  */
end_comment

begin_function
name|int
name|sys_aio_cancel
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|aio_cancel_args
modifier|*
name|uap
parameter_list|)
block|{
name|struct
name|proc
modifier|*
name|p
init|=
name|td
operator|->
name|td_proc
decl_stmt|;
name|struct
name|kaioinfo
modifier|*
name|ki
decl_stmt|;
name|struct
name|kaiocb
modifier|*
name|job
decl_stmt|,
modifier|*
name|jobn
decl_stmt|;
name|struct
name|file
modifier|*
name|fp
decl_stmt|;
name|cap_rights_t
name|rights
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|cancelled
init|=
literal|0
decl_stmt|;
name|int
name|notcancelled
init|=
literal|0
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
comment|/* Lookup file object. */
name|error
operator|=
name|fget
argument_list|(
name|td
argument_list|,
name|uap
operator|->
name|fd
argument_list|,
name|cap_rights_init
argument_list|(
operator|&
name|rights
argument_list|)
argument_list|,
operator|&
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|ki
operator|=
name|p
operator|->
name|p_aioinfo
expr_stmt|;
if|if
condition|(
name|ki
operator|==
name|NULL
condition|)
goto|goto
name|done
goto|;
if|if
condition|(
name|fp
operator|->
name|f_type
operator|==
name|DTYPE_VNODE
condition|)
block|{
name|vp
operator|=
name|fp
operator|->
name|f_vnode
expr_stmt|;
if|if
condition|(
name|vn_isdisk
argument_list|(
name|vp
argument_list|,
operator|&
name|error
argument_list|)
condition|)
block|{
name|fdrop
argument_list|(
name|fp
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|=
name|AIO_NOTCANCELED
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
name|AIO_LOCK
argument_list|(
name|ki
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|job
argument_list|,
argument|&ki->kaio_jobqueue
argument_list|,
argument|plist
argument_list|,
argument|jobn
argument_list|)
block|{
if|if
condition|(
operator|(
name|uap
operator|->
name|fd
operator|==
name|job
operator|->
name|uaiocb
operator|.
name|aio_fildes
operator|)
operator|&&
operator|(
operator|(
name|uap
operator|->
name|aiocbp
operator|==
name|NULL
operator|)
operator|||
operator|(
name|uap
operator|->
name|aiocbp
operator|==
name|job
operator|->
name|ujob
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|aio_cancel_job
argument_list|(
name|p
argument_list|,
name|ki
argument_list|,
name|job
argument_list|)
condition|)
block|{
name|cancelled
operator|++
expr_stmt|;
block|}
else|else
block|{
name|notcancelled
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|uap
operator|->
name|aiocbp
operator|!=
name|NULL
condition|)
break|break;
block|}
block|}
name|AIO_UNLOCK
argument_list|(
name|ki
argument_list|)
expr_stmt|;
name|done
label|:
name|fdrop
argument_list|(
name|fp
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|uap
operator|->
name|aiocbp
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|cancelled
condition|)
block|{
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|=
name|AIO_CANCELED
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
if|if
condition|(
name|notcancelled
condition|)
block|{
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|=
name|AIO_NOTCANCELED
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|cancelled
condition|)
block|{
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|=
name|AIO_CANCELED
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|=
name|AIO_ALLDONE
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * aio_error is implemented in the kernel level for compatibility purposes  * only.  For a user mode async implementation, it would be best to do it in  * a userland subroutine.  */
end_comment

begin_function
specifier|static
name|int
name|kern_aio_error
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|aiocb
modifier|*
name|ujob
parameter_list|,
name|struct
name|aiocb_ops
modifier|*
name|ops
parameter_list|)
block|{
name|struct
name|proc
modifier|*
name|p
init|=
name|td
operator|->
name|td_proc
decl_stmt|;
name|struct
name|kaiocb
modifier|*
name|job
decl_stmt|;
name|struct
name|kaioinfo
modifier|*
name|ki
decl_stmt|;
name|int
name|status
decl_stmt|;
name|ki
operator|=
name|p
operator|->
name|p_aioinfo
expr_stmt|;
if|if
condition|(
name|ki
operator|==
name|NULL
condition|)
block|{
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|=
name|EINVAL
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|AIO_LOCK
argument_list|(
name|ki
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|job
argument_list|,
argument|&ki->kaio_all
argument_list|,
argument|allist
argument_list|)
block|{
if|if
condition|(
name|job
operator|->
name|ujob
operator|==
name|ujob
condition|)
block|{
if|if
condition|(
name|job
operator|->
name|jobflags
operator|&
name|KAIOCB_FINISHED
condition|)
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|=
name|job
operator|->
name|uaiocb
operator|.
name|_aiocb_private
operator|.
name|error
expr_stmt|;
else|else
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|=
name|EINPROGRESS
expr_stmt|;
name|AIO_UNLOCK
argument_list|(
name|ki
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
name|AIO_UNLOCK
argument_list|(
name|ki
argument_list|)
expr_stmt|;
comment|/* 	 * Hack for failure of aio_aqueue. 	 */
name|status
operator|=
name|ops
operator|->
name|fetch_status
argument_list|(
name|ujob
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
operator|-
literal|1
condition|)
block|{
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|=
name|ops
operator|->
name|fetch_error
argument_list|(
name|ujob
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|=
name|EINVAL
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|sys_aio_error
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|aio_error_args
modifier|*
name|uap
parameter_list|)
block|{
return|return
operator|(
name|kern_aio_error
argument_list|(
name|td
argument_list|,
name|uap
operator|->
name|aiocbp
argument_list|,
operator|&
name|aiocb_ops
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* syscall - asynchronous read from a file (REALTIME) */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|COMPAT_FREEBSD6
end_ifdef

begin_function
name|int
name|freebsd6_aio_read
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|freebsd6_aio_read_args
modifier|*
name|uap
parameter_list|)
block|{
return|return
operator|(
name|aio_aqueue
argument_list|(
name|td
argument_list|,
operator|(
expr|struct
name|aiocb
operator|*
operator|)
name|uap
operator|->
name|aiocbp
argument_list|,
name|NULL
argument_list|,
name|LIO_READ
argument_list|,
operator|&
name|aiocb_ops_osigevent
argument_list|)
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|sys_aio_read
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|aio_read_args
modifier|*
name|uap
parameter_list|)
block|{
return|return
operator|(
name|aio_aqueue
argument_list|(
name|td
argument_list|,
name|uap
operator|->
name|aiocbp
argument_list|,
name|NULL
argument_list|,
name|LIO_READ
argument_list|,
operator|&
name|aiocb_ops
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* syscall - asynchronous write to a file (REALTIME) */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|COMPAT_FREEBSD6
end_ifdef

begin_function
name|int
name|freebsd6_aio_write
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|freebsd6_aio_write_args
modifier|*
name|uap
parameter_list|)
block|{
return|return
operator|(
name|aio_aqueue
argument_list|(
name|td
argument_list|,
operator|(
expr|struct
name|aiocb
operator|*
operator|)
name|uap
operator|->
name|aiocbp
argument_list|,
name|NULL
argument_list|,
name|LIO_WRITE
argument_list|,
operator|&
name|aiocb_ops_osigevent
argument_list|)
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|sys_aio_write
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|aio_write_args
modifier|*
name|uap
parameter_list|)
block|{
return|return
operator|(
name|aio_aqueue
argument_list|(
name|td
argument_list|,
name|uap
operator|->
name|aiocbp
argument_list|,
name|NULL
argument_list|,
name|LIO_WRITE
argument_list|,
operator|&
name|aiocb_ops
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|sys_aio_mlock
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|aio_mlock_args
modifier|*
name|uap
parameter_list|)
block|{
return|return
operator|(
name|aio_aqueue
argument_list|(
name|td
argument_list|,
name|uap
operator|->
name|aiocbp
argument_list|,
name|NULL
argument_list|,
name|LIO_MLOCK
argument_list|,
operator|&
name|aiocb_ops
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|kern_lio_listio
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|int
name|mode
parameter_list|,
name|struct
name|aiocb
modifier|*
specifier|const
modifier|*
name|uacb_list
parameter_list|,
name|struct
name|aiocb
modifier|*
modifier|*
name|acb_list
parameter_list|,
name|int
name|nent
parameter_list|,
name|struct
name|sigevent
modifier|*
name|sig
parameter_list|,
name|struct
name|aiocb_ops
modifier|*
name|ops
parameter_list|)
block|{
name|struct
name|proc
modifier|*
name|p
init|=
name|td
operator|->
name|td_proc
decl_stmt|;
name|struct
name|aiocb
modifier|*
name|job
decl_stmt|;
name|struct
name|kaioinfo
modifier|*
name|ki
decl_stmt|;
name|struct
name|aioliojob
modifier|*
name|lj
decl_stmt|;
name|struct
name|kevent
name|kev
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|nerror
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|(
name|mode
operator|!=
name|LIO_NOWAIT
operator|)
operator|&&
operator|(
name|mode
operator|!=
name|LIO_WAIT
operator|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|nent
operator|<
literal|0
operator|||
name|nent
operator|>
name|AIO_LISTIO_MAX
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|p
operator|->
name|p_aioinfo
operator|==
name|NULL
condition|)
name|aio_init_aioinfo
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|ki
operator|=
name|p
operator|->
name|p_aioinfo
expr_stmt|;
name|lj
operator|=
name|uma_zalloc
argument_list|(
name|aiolio_zone
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|lj
operator|->
name|lioj_flags
operator|=
literal|0
expr_stmt|;
name|lj
operator|->
name|lioj_count
operator|=
literal|0
expr_stmt|;
name|lj
operator|->
name|lioj_finished_count
operator|=
literal|0
expr_stmt|;
name|knlist_init_mtx
argument_list|(
operator|&
name|lj
operator|->
name|klist
argument_list|,
name|AIO_MTX
argument_list|(
name|ki
argument_list|)
argument_list|)
expr_stmt|;
name|ksiginfo_init
argument_list|(
operator|&
name|lj
operator|->
name|lioj_ksi
argument_list|)
expr_stmt|;
comment|/* 	 * Setup signal. 	 */
if|if
condition|(
name|sig
operator|&&
operator|(
name|mode
operator|==
name|LIO_NOWAIT
operator|)
condition|)
block|{
name|bcopy
argument_list|(
name|sig
argument_list|,
operator|&
name|lj
operator|->
name|lioj_signal
argument_list|,
sizeof|sizeof
argument_list|(
name|lj
operator|->
name|lioj_signal
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|lj
operator|->
name|lioj_signal
operator|.
name|sigev_notify
operator|==
name|SIGEV_KEVENT
condition|)
block|{
comment|/* Assume only new style KEVENT */
name|kev
operator|.
name|filter
operator|=
name|EVFILT_LIO
expr_stmt|;
name|kev
operator|.
name|flags
operator|=
name|EV_ADD
operator||
name|EV_ENABLE
operator||
name|EV_FLAG1
expr_stmt|;
name|kev
operator|.
name|ident
operator|=
operator|(
name|uintptr_t
operator|)
name|uacb_list
expr_stmt|;
comment|/* something unique */
name|kev
operator|.
name|data
operator|=
operator|(
name|intptr_t
operator|)
name|lj
expr_stmt|;
comment|/* pass user defined sigval data */
name|kev
operator|.
name|udata
operator|=
name|lj
operator|->
name|lioj_signal
operator|.
name|sigev_value
operator|.
name|sival_ptr
expr_stmt|;
name|error
operator|=
name|kqfd_register
argument_list|(
name|lj
operator|->
name|lioj_signal
operator|.
name|sigev_notify_kqueue
argument_list|,
operator|&
name|kev
argument_list|,
name|td
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|uma_zfree
argument_list|(
name|aiolio_zone
argument_list|,
name|lj
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|lj
operator|->
name|lioj_signal
operator|.
name|sigev_notify
operator|==
name|SIGEV_NONE
condition|)
block|{
empty_stmt|;
block|}
elseif|else
if|if
condition|(
name|lj
operator|->
name|lioj_signal
operator|.
name|sigev_notify
operator|==
name|SIGEV_SIGNAL
operator|||
name|lj
operator|->
name|lioj_signal
operator|.
name|sigev_notify
operator|==
name|SIGEV_THREAD_ID
condition|)
block|{
if|if
condition|(
operator|!
name|_SIG_VALID
argument_list|(
name|lj
operator|->
name|lioj_signal
operator|.
name|sigev_signo
argument_list|)
condition|)
block|{
name|uma_zfree
argument_list|(
name|aiolio_zone
argument_list|,
name|lj
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
name|lj
operator|->
name|lioj_flags
operator||=
name|LIOJ_SIGNAL
expr_stmt|;
block|}
else|else
block|{
name|uma_zfree
argument_list|(
name|aiolio_zone
argument_list|,
name|lj
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
block|}
name|AIO_LOCK
argument_list|(
name|ki
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|ki
operator|->
name|kaio_liojoblist
argument_list|,
name|lj
argument_list|,
name|lioj_list
argument_list|)
expr_stmt|;
comment|/* 	 * Add extra aiocb count to avoid the lio to be freed 	 * by other threads doing aio_waitcomplete or aio_return, 	 * and prevent event from being sent until we have queued 	 * all tasks. 	 */
name|lj
operator|->
name|lioj_count
operator|=
literal|1
expr_stmt|;
name|AIO_UNLOCK
argument_list|(
name|ki
argument_list|)
expr_stmt|;
comment|/* 	 * Get pointers to the list of I/O requests. 	 */
name|nerror
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nent
condition|;
name|i
operator|++
control|)
block|{
name|job
operator|=
name|acb_list
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|job
operator|!=
name|NULL
condition|)
block|{
name|error
operator|=
name|aio_aqueue
argument_list|(
name|td
argument_list|,
name|job
argument_list|,
name|lj
argument_list|,
name|LIO_NOP
argument_list|,
name|ops
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
name|nerror
operator|++
expr_stmt|;
block|}
block|}
name|error
operator|=
literal|0
expr_stmt|;
name|AIO_LOCK
argument_list|(
name|ki
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|LIO_WAIT
condition|)
block|{
while|while
condition|(
name|lj
operator|->
name|lioj_count
operator|-
literal|1
operator|!=
name|lj
operator|->
name|lioj_finished_count
condition|)
block|{
name|ki
operator|->
name|kaio_flags
operator||=
name|KAIO_WAKEUP
expr_stmt|;
name|error
operator|=
name|msleep
argument_list|(
operator|&
name|p
operator|->
name|p_aioinfo
argument_list|,
name|AIO_MTX
argument_list|(
name|ki
argument_list|)
argument_list|,
name|PRIBIO
operator||
name|PCATCH
argument_list|,
literal|"aiospn"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|ERESTART
condition|)
name|error
operator|=
name|EINTR
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
block|}
block|}
else|else
block|{
if|if
condition|(
name|lj
operator|->
name|lioj_count
operator|-
literal|1
operator|==
name|lj
operator|->
name|lioj_finished_count
condition|)
block|{
if|if
condition|(
name|lj
operator|->
name|lioj_signal
operator|.
name|sigev_notify
operator|==
name|SIGEV_KEVENT
condition|)
block|{
name|lj
operator|->
name|lioj_flags
operator||=
name|LIOJ_KEVENT_POSTED
expr_stmt|;
name|KNOTE_LOCKED
argument_list|(
operator|&
name|lj
operator|->
name|klist
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|lj
operator|->
name|lioj_flags
operator|&
operator|(
name|LIOJ_SIGNAL
operator||
name|LIOJ_SIGNAL_POSTED
operator|)
operator|)
operator|==
name|LIOJ_SIGNAL
operator|&&
operator|(
name|lj
operator|->
name|lioj_signal
operator|.
name|sigev_notify
operator|==
name|SIGEV_SIGNAL
operator|||
name|lj
operator|->
name|lioj_signal
operator|.
name|sigev_notify
operator|==
name|SIGEV_THREAD_ID
operator|)
condition|)
block|{
name|aio_sendsig
argument_list|(
name|p
argument_list|,
operator|&
name|lj
operator|->
name|lioj_signal
argument_list|,
operator|&
name|lj
operator|->
name|lioj_ksi
argument_list|)
expr_stmt|;
name|lj
operator|->
name|lioj_flags
operator||=
name|LIOJ_SIGNAL_POSTED
expr_stmt|;
block|}
block|}
block|}
name|lj
operator|->
name|lioj_count
operator|--
expr_stmt|;
if|if
condition|(
name|lj
operator|->
name|lioj_count
operator|==
literal|0
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|ki
operator|->
name|kaio_liojoblist
argument_list|,
name|lj
argument_list|,
name|lioj_list
argument_list|)
expr_stmt|;
name|knlist_delete
argument_list|(
operator|&
name|lj
operator|->
name|klist
argument_list|,
name|curthread
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|sigqueue_take
argument_list|(
operator|&
name|lj
operator|->
name|lioj_ksi
argument_list|)
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|AIO_UNLOCK
argument_list|(
name|ki
argument_list|)
expr_stmt|;
name|uma_zfree
argument_list|(
name|aiolio_zone
argument_list|,
name|lj
argument_list|)
expr_stmt|;
block|}
else|else
name|AIO_UNLOCK
argument_list|(
name|ki
argument_list|)
expr_stmt|;
if|if
condition|(
name|nerror
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/* syscall - list directed I/O (REALTIME) */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|COMPAT_FREEBSD6
end_ifdef

begin_function
name|int
name|freebsd6_lio_listio
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|freebsd6_lio_listio_args
modifier|*
name|uap
parameter_list|)
block|{
name|struct
name|aiocb
modifier|*
modifier|*
name|acb_list
decl_stmt|;
name|struct
name|sigevent
modifier|*
name|sigp
decl_stmt|,
name|sig
decl_stmt|;
name|struct
name|osigevent
name|osig
decl_stmt|;
name|int
name|error
decl_stmt|,
name|nent
decl_stmt|;
if|if
condition|(
operator|(
name|uap
operator|->
name|mode
operator|!=
name|LIO_NOWAIT
operator|)
operator|&&
operator|(
name|uap
operator|->
name|mode
operator|!=
name|LIO_WAIT
operator|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|nent
operator|=
name|uap
operator|->
name|nent
expr_stmt|;
if|if
condition|(
name|nent
operator|<
literal|0
operator|||
name|nent
operator|>
name|AIO_LISTIO_MAX
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|uap
operator|->
name|sig
operator|&&
operator|(
name|uap
operator|->
name|mode
operator|==
name|LIO_NOWAIT
operator|)
condition|)
block|{
name|error
operator|=
name|copyin
argument_list|(
name|uap
operator|->
name|sig
argument_list|,
operator|&
name|osig
argument_list|,
sizeof|sizeof
argument_list|(
name|osig
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|error
operator|=
name|convert_old_sigevent
argument_list|(
operator|&
name|osig
argument_list|,
operator|&
name|sig
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|sigp
operator|=
operator|&
name|sig
expr_stmt|;
block|}
else|else
name|sigp
operator|=
name|NULL
expr_stmt|;
name|acb_list
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|aiocb
operator|*
argument_list|)
operator|*
name|nent
argument_list|,
name|M_LIO
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|error
operator|=
name|copyin
argument_list|(
name|uap
operator|->
name|acb_list
argument_list|,
name|acb_list
argument_list|,
name|nent
operator|*
sizeof|sizeof
argument_list|(
name|acb_list
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|error
operator|=
name|kern_lio_listio
argument_list|(
name|td
argument_list|,
name|uap
operator|->
name|mode
argument_list|,
operator|(
expr|struct
name|aiocb
operator|*
specifier|const
operator|*
operator|)
name|uap
operator|->
name|acb_list
argument_list|,
name|acb_list
argument_list|,
name|nent
argument_list|,
name|sigp
argument_list|,
operator|&
name|aiocb_ops_osigevent
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|acb_list
argument_list|,
name|M_LIO
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* syscall - list directed I/O (REALTIME) */
end_comment

begin_function
name|int
name|sys_lio_listio
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|lio_listio_args
modifier|*
name|uap
parameter_list|)
block|{
name|struct
name|aiocb
modifier|*
modifier|*
name|acb_list
decl_stmt|;
name|struct
name|sigevent
modifier|*
name|sigp
decl_stmt|,
name|sig
decl_stmt|;
name|int
name|error
decl_stmt|,
name|nent
decl_stmt|;
if|if
condition|(
operator|(
name|uap
operator|->
name|mode
operator|!=
name|LIO_NOWAIT
operator|)
operator|&&
operator|(
name|uap
operator|->
name|mode
operator|!=
name|LIO_WAIT
operator|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|nent
operator|=
name|uap
operator|->
name|nent
expr_stmt|;
if|if
condition|(
name|nent
operator|<
literal|0
operator|||
name|nent
operator|>
name|AIO_LISTIO_MAX
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|uap
operator|->
name|sig
operator|&&
operator|(
name|uap
operator|->
name|mode
operator|==
name|LIO_NOWAIT
operator|)
condition|)
block|{
name|error
operator|=
name|copyin
argument_list|(
name|uap
operator|->
name|sig
argument_list|,
operator|&
name|sig
argument_list|,
sizeof|sizeof
argument_list|(
name|sig
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|sigp
operator|=
operator|&
name|sig
expr_stmt|;
block|}
else|else
name|sigp
operator|=
name|NULL
expr_stmt|;
name|acb_list
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|aiocb
operator|*
argument_list|)
operator|*
name|nent
argument_list|,
name|M_LIO
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|error
operator|=
name|copyin
argument_list|(
name|uap
operator|->
name|acb_list
argument_list|,
name|acb_list
argument_list|,
name|nent
operator|*
sizeof|sizeof
argument_list|(
name|acb_list
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|error
operator|=
name|kern_lio_listio
argument_list|(
name|td
argument_list|,
name|uap
operator|->
name|mode
argument_list|,
name|uap
operator|->
name|acb_list
argument_list|,
name|acb_list
argument_list|,
name|nent
argument_list|,
name|sigp
argument_list|,
operator|&
name|aiocb_ops
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|acb_list
argument_list|,
name|M_LIO
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|aio_physwakeup
parameter_list|(
name|struct
name|bio
modifier|*
name|bp
parameter_list|)
block|{
name|struct
name|kaiocb
modifier|*
name|job
init|=
operator|(
expr|struct
name|kaiocb
operator|*
operator|)
name|bp
operator|->
name|bio_caller1
decl_stmt|;
name|struct
name|proc
modifier|*
name|userp
decl_stmt|;
name|struct
name|kaioinfo
modifier|*
name|ki
decl_stmt|;
name|size_t
name|nbytes
decl_stmt|;
name|int
name|error
decl_stmt|,
name|nblks
decl_stmt|;
comment|/* Release mapping into kernel space. */
name|userp
operator|=
name|job
operator|->
name|userproc
expr_stmt|;
name|ki
operator|=
name|userp
operator|->
name|p_aioinfo
expr_stmt|;
if|if
condition|(
name|job
operator|->
name|pbuf
condition|)
block|{
name|pmap_qremove
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|job
operator|->
name|pbuf
operator|->
name|b_data
argument_list|,
name|job
operator|->
name|npages
argument_list|)
expr_stmt|;
name|relpbuf
argument_list|(
name|job
operator|->
name|pbuf
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|job
operator|->
name|pbuf
operator|=
name|NULL
expr_stmt|;
name|atomic_subtract_int
argument_list|(
operator|&
name|num_buf_aio
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|AIO_LOCK
argument_list|(
name|ki
argument_list|)
expr_stmt|;
name|ki
operator|->
name|kaio_buffer_count
operator|--
expr_stmt|;
name|AIO_UNLOCK
argument_list|(
name|ki
argument_list|)
expr_stmt|;
block|}
name|vm_page_unhold_pages
argument_list|(
name|job
operator|->
name|pages
argument_list|,
name|job
operator|->
name|npages
argument_list|)
expr_stmt|;
name|bp
operator|=
name|job
operator|->
name|bp
expr_stmt|;
name|job
operator|->
name|bp
operator|=
name|NULL
expr_stmt|;
name|nbytes
operator|=
name|job
operator|->
name|uaiocb
operator|.
name|aio_nbytes
operator|-
name|bp
operator|->
name|bio_resid
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|bio_flags
operator|&
name|BIO_ERROR
condition|)
name|error
operator|=
name|bp
operator|->
name|bio_error
expr_stmt|;
name|nblks
operator|=
name|btodb
argument_list|(
name|nbytes
argument_list|)
expr_stmt|;
if|if
condition|(
name|job
operator|->
name|uaiocb
operator|.
name|aio_lio_opcode
operator|==
name|LIO_WRITE
condition|)
name|job
operator|->
name|outblock
operator|+=
name|nblks
expr_stmt|;
else|else
name|job
operator|->
name|inblock
operator|+=
name|nblks
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|aio_complete
argument_list|(
name|job
argument_list|,
operator|-
literal|1
argument_list|,
name|error
argument_list|)
expr_stmt|;
else|else
name|aio_complete
argument_list|(
name|job
argument_list|,
name|nbytes
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|g_destroy_bio
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* syscall - wait for the next completion of an aio request */
end_comment

begin_function
specifier|static
name|int
name|kern_aio_waitcomplete
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|aiocb
modifier|*
modifier|*
name|ujobp
parameter_list|,
name|struct
name|timespec
modifier|*
name|ts
parameter_list|,
name|struct
name|aiocb_ops
modifier|*
name|ops
parameter_list|)
block|{
name|struct
name|proc
modifier|*
name|p
init|=
name|td
operator|->
name|td_proc
decl_stmt|;
name|struct
name|timeval
name|atv
decl_stmt|;
name|struct
name|kaioinfo
modifier|*
name|ki
decl_stmt|;
name|struct
name|kaiocb
modifier|*
name|job
decl_stmt|;
name|struct
name|aiocb
modifier|*
name|ujob
decl_stmt|;
name|long
name|error
decl_stmt|,
name|status
decl_stmt|;
name|int
name|timo
decl_stmt|;
name|ops
operator|->
name|store_aiocb
argument_list|(
name|ujobp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|ts
operator|==
name|NULL
condition|)
block|{
name|timo
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ts
operator|->
name|tv_sec
operator|==
literal|0
operator|&&
name|ts
operator|->
name|tv_nsec
operator|==
literal|0
condition|)
block|{
name|timo
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|ts
operator|->
name|tv_nsec
operator|<
literal|0
operator|)
operator|||
operator|(
name|ts
operator|->
name|tv_nsec
operator|>=
literal|1000000000
operator|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|TIMESPEC_TO_TIMEVAL
argument_list|(
operator|&
name|atv
argument_list|,
name|ts
argument_list|)
expr_stmt|;
if|if
condition|(
name|itimerfix
argument_list|(
operator|&
name|atv
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|timo
operator|=
name|tvtohz
argument_list|(
operator|&
name|atv
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|->
name|p_aioinfo
operator|==
name|NULL
condition|)
name|aio_init_aioinfo
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|ki
operator|=
name|p
operator|->
name|p_aioinfo
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|job
operator|=
name|NULL
expr_stmt|;
name|AIO_LOCK
argument_list|(
name|ki
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|job
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|ki
operator|->
name|kaio_done
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|timo
operator|==
operator|-
literal|1
condition|)
block|{
name|error
operator|=
name|EWOULDBLOCK
expr_stmt|;
break|break;
block|}
name|ki
operator|->
name|kaio_flags
operator||=
name|KAIO_WAKEUP
expr_stmt|;
name|error
operator|=
name|msleep
argument_list|(
operator|&
name|p
operator|->
name|p_aioinfo
argument_list|,
name|AIO_MTX
argument_list|(
name|ki
argument_list|)
argument_list|,
name|PRIBIO
operator||
name|PCATCH
argument_list|,
literal|"aiowc"
argument_list|,
name|timo
argument_list|)
expr_stmt|;
if|if
condition|(
name|timo
operator|&&
name|error
operator|==
name|ERESTART
condition|)
name|error
operator|=
name|EINTR
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
block|}
if|if
condition|(
name|job
operator|!=
name|NULL
condition|)
block|{
name|MPASS
argument_list|(
name|job
operator|->
name|jobflags
operator|&
name|KAIOCB_FINISHED
argument_list|)
expr_stmt|;
name|ujob
operator|=
name|job
operator|->
name|ujob
expr_stmt|;
name|status
operator|=
name|job
operator|->
name|uaiocb
operator|.
name|_aiocb_private
operator|.
name|status
expr_stmt|;
name|error
operator|=
name|job
operator|->
name|uaiocb
operator|.
name|_aiocb_private
operator|.
name|error
expr_stmt|;
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|=
name|status
expr_stmt|;
name|td
operator|->
name|td_ru
operator|.
name|ru_oublock
operator|+=
name|job
operator|->
name|outblock
expr_stmt|;
name|td
operator|->
name|td_ru
operator|.
name|ru_inblock
operator|+=
name|job
operator|->
name|inblock
expr_stmt|;
name|td
operator|->
name|td_ru
operator|.
name|ru_msgsnd
operator|+=
name|job
operator|->
name|msgsnd
expr_stmt|;
name|td
operator|->
name|td_ru
operator|.
name|ru_msgrcv
operator|+=
name|job
operator|->
name|msgrcv
expr_stmt|;
name|aio_free_entry
argument_list|(
name|job
argument_list|)
expr_stmt|;
name|AIO_UNLOCK
argument_list|(
name|ki
argument_list|)
expr_stmt|;
name|ops
operator|->
name|store_aiocb
argument_list|(
name|ujobp
argument_list|,
name|ujob
argument_list|)
expr_stmt|;
name|ops
operator|->
name|store_error
argument_list|(
name|ujob
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|ops
operator|->
name|store_status
argument_list|(
name|ujob
argument_list|,
name|status
argument_list|)
expr_stmt|;
block|}
else|else
name|AIO_UNLOCK
argument_list|(
name|ki
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|sys_aio_waitcomplete
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|aio_waitcomplete_args
modifier|*
name|uap
parameter_list|)
block|{
name|struct
name|timespec
name|ts
decl_stmt|,
modifier|*
name|tsp
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|uap
operator|->
name|timeout
condition|)
block|{
comment|/* Get timespec struct. */
name|error
operator|=
name|copyin
argument_list|(
name|uap
operator|->
name|timeout
argument_list|,
operator|&
name|ts
argument_list|,
sizeof|sizeof
argument_list|(
name|ts
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|tsp
operator|=
operator|&
name|ts
expr_stmt|;
block|}
else|else
name|tsp
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|kern_aio_waitcomplete
argument_list|(
name|td
argument_list|,
name|uap
operator|->
name|aiocbp
argument_list|,
name|tsp
argument_list|,
operator|&
name|aiocb_ops
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|kern_aio_fsync
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|int
name|op
parameter_list|,
name|struct
name|aiocb
modifier|*
name|ujob
parameter_list|,
name|struct
name|aiocb_ops
modifier|*
name|ops
parameter_list|)
block|{
if|if
condition|(
name|op
operator|!=
name|O_SYNC
condition|)
comment|/* XXX lack of O_DSYNC */
return|return
operator|(
name|EINVAL
operator|)
return|;
return|return
operator|(
name|aio_aqueue
argument_list|(
name|td
argument_list|,
name|ujob
argument_list|,
name|NULL
argument_list|,
name|LIO_SYNC
argument_list|,
name|ops
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|sys_aio_fsync
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|aio_fsync_args
modifier|*
name|uap
parameter_list|)
block|{
return|return
operator|(
name|kern_aio_fsync
argument_list|(
name|td
argument_list|,
name|uap
operator|->
name|op
argument_list|,
name|uap
operator|->
name|aiocbp
argument_list|,
operator|&
name|aiocb_ops
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* kqueue attach function */
end_comment

begin_function
specifier|static
name|int
name|filt_aioattach
parameter_list|(
name|struct
name|knote
modifier|*
name|kn
parameter_list|)
block|{
name|struct
name|kaiocb
modifier|*
name|job
init|=
operator|(
expr|struct
name|kaiocb
operator|*
operator|)
name|kn
operator|->
name|kn_sdata
decl_stmt|;
comment|/* 	 * The job pointer must be validated before using it, so 	 * registration is restricted to the kernel; the user cannot 	 * set EV_FLAG1. 	 */
if|if
condition|(
operator|(
name|kn
operator|->
name|kn_flags
operator|&
name|EV_FLAG1
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|EPERM
operator|)
return|;
name|kn
operator|->
name|kn_ptr
operator|.
name|p_aio
operator|=
name|job
expr_stmt|;
name|kn
operator|->
name|kn_flags
operator|&=
operator|~
name|EV_FLAG1
expr_stmt|;
name|knlist_add
argument_list|(
operator|&
name|job
operator|->
name|klist
argument_list|,
name|kn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* kqueue detach function */
end_comment

begin_function
specifier|static
name|void
name|filt_aiodetach
parameter_list|(
name|struct
name|knote
modifier|*
name|kn
parameter_list|)
block|{
name|struct
name|knlist
modifier|*
name|knl
decl_stmt|;
name|knl
operator|=
operator|&
name|kn
operator|->
name|kn_ptr
operator|.
name|p_aio
operator|->
name|klist
expr_stmt|;
name|knl
operator|->
name|kl_lock
argument_list|(
name|knl
operator|->
name|kl_lockarg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|knlist_empty
argument_list|(
name|knl
argument_list|)
condition|)
name|knlist_remove
argument_list|(
name|knl
argument_list|,
name|kn
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|knl
operator|->
name|kl_unlock
argument_list|(
name|knl
operator|->
name|kl_lockarg
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* kqueue filter function */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|int
name|filt_aio
parameter_list|(
name|struct
name|knote
modifier|*
name|kn
parameter_list|,
name|long
name|hint
parameter_list|)
block|{
name|struct
name|kaiocb
modifier|*
name|job
init|=
name|kn
operator|->
name|kn_ptr
operator|.
name|p_aio
decl_stmt|;
name|kn
operator|->
name|kn_data
operator|=
name|job
operator|->
name|uaiocb
operator|.
name|_aiocb_private
operator|.
name|error
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|job
operator|->
name|jobflags
operator|&
name|KAIOCB_FINISHED
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|kn
operator|->
name|kn_flags
operator||=
name|EV_EOF
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* kqueue attach function */
end_comment

begin_function
specifier|static
name|int
name|filt_lioattach
parameter_list|(
name|struct
name|knote
modifier|*
name|kn
parameter_list|)
block|{
name|struct
name|aioliojob
modifier|*
name|lj
init|=
operator|(
expr|struct
name|aioliojob
operator|*
operator|)
name|kn
operator|->
name|kn_sdata
decl_stmt|;
comment|/* 	 * The aioliojob pointer must be validated before using it, so 	 * registration is restricted to the kernel; the user cannot 	 * set EV_FLAG1. 	 */
if|if
condition|(
operator|(
name|kn
operator|->
name|kn_flags
operator|&
name|EV_FLAG1
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|EPERM
operator|)
return|;
name|kn
operator|->
name|kn_ptr
operator|.
name|p_lio
operator|=
name|lj
expr_stmt|;
name|kn
operator|->
name|kn_flags
operator|&=
operator|~
name|EV_FLAG1
expr_stmt|;
name|knlist_add
argument_list|(
operator|&
name|lj
operator|->
name|klist
argument_list|,
name|kn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* kqueue detach function */
end_comment

begin_function
specifier|static
name|void
name|filt_liodetach
parameter_list|(
name|struct
name|knote
modifier|*
name|kn
parameter_list|)
block|{
name|struct
name|knlist
modifier|*
name|knl
decl_stmt|;
name|knl
operator|=
operator|&
name|kn
operator|->
name|kn_ptr
operator|.
name|p_lio
operator|->
name|klist
expr_stmt|;
name|knl
operator|->
name|kl_lock
argument_list|(
name|knl
operator|->
name|kl_lockarg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|knlist_empty
argument_list|(
name|knl
argument_list|)
condition|)
name|knlist_remove
argument_list|(
name|knl
argument_list|,
name|kn
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|knl
operator|->
name|kl_unlock
argument_list|(
name|knl
operator|->
name|kl_lockarg
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* kqueue filter function */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|int
name|filt_lio
parameter_list|(
name|struct
name|knote
modifier|*
name|kn
parameter_list|,
name|long
name|hint
parameter_list|)
block|{
name|struct
name|aioliojob
modifier|*
name|lj
init|=
name|kn
operator|->
name|kn_ptr
operator|.
name|p_lio
decl_stmt|;
return|return
operator|(
name|lj
operator|->
name|lioj_flags
operator|&
name|LIOJ_KEVENT_POSTED
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|COMPAT_FREEBSD32
end_ifdef

begin_include
include|#
directive|include
file|<sys/mount.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<compat/freebsd32/freebsd32.h>
end_include

begin_include
include|#
directive|include
file|<compat/freebsd32/freebsd32_proto.h>
end_include

begin_include
include|#
directive|include
file|<compat/freebsd32/freebsd32_signal.h>
end_include

begin_include
include|#
directive|include
file|<compat/freebsd32/freebsd32_syscall.h>
end_include

begin_include
include|#
directive|include
file|<compat/freebsd32/freebsd32_util.h>
end_include

begin_struct
struct|struct
name|__aiocb_private32
block|{
name|int32_t
name|status
decl_stmt|;
name|int32_t
name|error
decl_stmt|;
name|uint32_t
name|kernelinfo
decl_stmt|;
block|}
struct|;
end_struct

begin_ifdef
ifdef|#
directive|ifdef
name|COMPAT_FREEBSD6
end_ifdef

begin_typedef
typedef|typedef
struct|struct
name|oaiocb32
block|{
name|int
name|aio_fildes
decl_stmt|;
comment|/* File descriptor */
name|uint64_t
name|aio_offset
name|__packed
decl_stmt|;
comment|/* File offset for I/O */
name|uint32_t
name|aio_buf
decl_stmt|;
comment|/* I/O buffer in process space */
name|uint32_t
name|aio_nbytes
decl_stmt|;
comment|/* Number of bytes for I/O */
name|struct
name|osigevent32
name|aio_sigevent
decl_stmt|;
comment|/* Signal to deliver */
name|int
name|aio_lio_opcode
decl_stmt|;
comment|/* LIO opcode */
name|int
name|aio_reqprio
decl_stmt|;
comment|/* Request priority -- ignored */
name|struct
name|__aiocb_private32
name|_aiocb_private
decl_stmt|;
block|}
name|oaiocb32_t
typedef|;
end_typedef

begin_endif
endif|#
directive|endif
end_endif

begin_typedef
typedef|typedef
struct|struct
name|aiocb32
block|{
name|int32_t
name|aio_fildes
decl_stmt|;
comment|/* File descriptor */
name|uint64_t
name|aio_offset
name|__packed
decl_stmt|;
comment|/* File offset for I/O */
name|uint32_t
name|aio_buf
decl_stmt|;
comment|/* I/O buffer in process space */
name|uint32_t
name|aio_nbytes
decl_stmt|;
comment|/* Number of bytes for I/O */
name|int
name|__spare__
index|[
literal|2
index|]
decl_stmt|;
name|uint32_t
name|__spare2__
decl_stmt|;
name|int
name|aio_lio_opcode
decl_stmt|;
comment|/* LIO opcode */
name|int
name|aio_reqprio
decl_stmt|;
comment|/* Request priority -- ignored */
name|struct
name|__aiocb_private32
name|_aiocb_private
decl_stmt|;
name|struct
name|sigevent32
name|aio_sigevent
decl_stmt|;
comment|/* Signal to deliver */
block|}
name|aiocb32_t
typedef|;
end_typedef

begin_ifdef
ifdef|#
directive|ifdef
name|COMPAT_FREEBSD6
end_ifdef

begin_function
specifier|static
name|int
name|convert_old_sigevent32
parameter_list|(
name|struct
name|osigevent32
modifier|*
name|osig
parameter_list|,
name|struct
name|sigevent
modifier|*
name|nsig
parameter_list|)
block|{
comment|/* 	 * Only SIGEV_NONE, SIGEV_SIGNAL, and SIGEV_KEVENT are 	 * supported by AIO with the old sigevent structure. 	 */
name|CP
argument_list|(
operator|*
name|osig
argument_list|,
operator|*
name|nsig
argument_list|,
name|sigev_notify
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|nsig
operator|->
name|sigev_notify
condition|)
block|{
case|case
name|SIGEV_NONE
case|:
break|break;
case|case
name|SIGEV_SIGNAL
case|:
name|nsig
operator|->
name|sigev_signo
operator|=
name|osig
operator|->
name|__sigev_u
operator|.
name|__sigev_signo
expr_stmt|;
break|break;
case|case
name|SIGEV_KEVENT
case|:
name|nsig
operator|->
name|sigev_notify_kqueue
operator|=
name|osig
operator|->
name|__sigev_u
operator|.
name|__sigev_notify_kqueue
expr_stmt|;
name|PTRIN_CP
argument_list|(
operator|*
name|osig
argument_list|,
operator|*
name|nsig
argument_list|,
name|sigev_value
operator|.
name|sival_ptr
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|aiocb32_copyin_old_sigevent
parameter_list|(
name|struct
name|aiocb
modifier|*
name|ujob
parameter_list|,
name|struct
name|aiocb
modifier|*
name|kjob
parameter_list|)
block|{
name|struct
name|oaiocb32
name|job32
decl_stmt|;
name|int
name|error
decl_stmt|;
name|bzero
argument_list|(
name|kjob
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|aiocb
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|copyin
argument_list|(
name|ujob
argument_list|,
operator|&
name|job32
argument_list|,
sizeof|sizeof
argument_list|(
name|job32
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|CP
argument_list|(
name|job32
argument_list|,
operator|*
name|kjob
argument_list|,
name|aio_fildes
argument_list|)
expr_stmt|;
name|CP
argument_list|(
name|job32
argument_list|,
operator|*
name|kjob
argument_list|,
name|aio_offset
argument_list|)
expr_stmt|;
name|PTRIN_CP
argument_list|(
name|job32
argument_list|,
operator|*
name|kjob
argument_list|,
name|aio_buf
argument_list|)
expr_stmt|;
name|CP
argument_list|(
name|job32
argument_list|,
operator|*
name|kjob
argument_list|,
name|aio_nbytes
argument_list|)
expr_stmt|;
name|CP
argument_list|(
name|job32
argument_list|,
operator|*
name|kjob
argument_list|,
name|aio_lio_opcode
argument_list|)
expr_stmt|;
name|CP
argument_list|(
name|job32
argument_list|,
operator|*
name|kjob
argument_list|,
name|aio_reqprio
argument_list|)
expr_stmt|;
name|CP
argument_list|(
name|job32
argument_list|,
operator|*
name|kjob
argument_list|,
name|_aiocb_private
operator|.
name|status
argument_list|)
expr_stmt|;
name|CP
argument_list|(
name|job32
argument_list|,
operator|*
name|kjob
argument_list|,
name|_aiocb_private
operator|.
name|error
argument_list|)
expr_stmt|;
name|PTRIN_CP
argument_list|(
name|job32
argument_list|,
operator|*
name|kjob
argument_list|,
name|_aiocb_private
operator|.
name|kernelinfo
argument_list|)
expr_stmt|;
return|return
operator|(
name|convert_old_sigevent32
argument_list|(
operator|&
name|job32
operator|.
name|aio_sigevent
argument_list|,
operator|&
name|kjob
operator|->
name|aio_sigevent
argument_list|)
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|int
name|aiocb32_copyin
parameter_list|(
name|struct
name|aiocb
modifier|*
name|ujob
parameter_list|,
name|struct
name|aiocb
modifier|*
name|kjob
parameter_list|)
block|{
name|struct
name|aiocb32
name|job32
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
name|copyin
argument_list|(
name|ujob
argument_list|,
operator|&
name|job32
argument_list|,
sizeof|sizeof
argument_list|(
name|job32
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|CP
argument_list|(
name|job32
argument_list|,
operator|*
name|kjob
argument_list|,
name|aio_fildes
argument_list|)
expr_stmt|;
name|CP
argument_list|(
name|job32
argument_list|,
operator|*
name|kjob
argument_list|,
name|aio_offset
argument_list|)
expr_stmt|;
name|PTRIN_CP
argument_list|(
name|job32
argument_list|,
operator|*
name|kjob
argument_list|,
name|aio_buf
argument_list|)
expr_stmt|;
name|CP
argument_list|(
name|job32
argument_list|,
operator|*
name|kjob
argument_list|,
name|aio_nbytes
argument_list|)
expr_stmt|;
name|CP
argument_list|(
name|job32
argument_list|,
operator|*
name|kjob
argument_list|,
name|aio_lio_opcode
argument_list|)
expr_stmt|;
name|CP
argument_list|(
name|job32
argument_list|,
operator|*
name|kjob
argument_list|,
name|aio_reqprio
argument_list|)
expr_stmt|;
name|CP
argument_list|(
name|job32
argument_list|,
operator|*
name|kjob
argument_list|,
name|_aiocb_private
operator|.
name|status
argument_list|)
expr_stmt|;
name|CP
argument_list|(
name|job32
argument_list|,
operator|*
name|kjob
argument_list|,
name|_aiocb_private
operator|.
name|error
argument_list|)
expr_stmt|;
name|PTRIN_CP
argument_list|(
name|job32
argument_list|,
operator|*
name|kjob
argument_list|,
name|_aiocb_private
operator|.
name|kernelinfo
argument_list|)
expr_stmt|;
return|return
operator|(
name|convert_sigevent32
argument_list|(
operator|&
name|job32
operator|.
name|aio_sigevent
argument_list|,
operator|&
name|kjob
operator|->
name|aio_sigevent
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|long
name|aiocb32_fetch_status
parameter_list|(
name|struct
name|aiocb
modifier|*
name|ujob
parameter_list|)
block|{
name|struct
name|aiocb32
modifier|*
name|ujob32
decl_stmt|;
name|ujob32
operator|=
operator|(
expr|struct
name|aiocb32
operator|*
operator|)
name|ujob
expr_stmt|;
return|return
operator|(
name|fuword32
argument_list|(
operator|&
name|ujob32
operator|->
name|_aiocb_private
operator|.
name|status
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|long
name|aiocb32_fetch_error
parameter_list|(
name|struct
name|aiocb
modifier|*
name|ujob
parameter_list|)
block|{
name|struct
name|aiocb32
modifier|*
name|ujob32
decl_stmt|;
name|ujob32
operator|=
operator|(
expr|struct
name|aiocb32
operator|*
operator|)
name|ujob
expr_stmt|;
return|return
operator|(
name|fuword32
argument_list|(
operator|&
name|ujob32
operator|->
name|_aiocb_private
operator|.
name|error
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|aiocb32_store_status
parameter_list|(
name|struct
name|aiocb
modifier|*
name|ujob
parameter_list|,
name|long
name|status
parameter_list|)
block|{
name|struct
name|aiocb32
modifier|*
name|ujob32
decl_stmt|;
name|ujob32
operator|=
operator|(
expr|struct
name|aiocb32
operator|*
operator|)
name|ujob
expr_stmt|;
return|return
operator|(
name|suword32
argument_list|(
operator|&
name|ujob32
operator|->
name|_aiocb_private
operator|.
name|status
argument_list|,
name|status
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|aiocb32_store_error
parameter_list|(
name|struct
name|aiocb
modifier|*
name|ujob
parameter_list|,
name|long
name|error
parameter_list|)
block|{
name|struct
name|aiocb32
modifier|*
name|ujob32
decl_stmt|;
name|ujob32
operator|=
operator|(
expr|struct
name|aiocb32
operator|*
operator|)
name|ujob
expr_stmt|;
return|return
operator|(
name|suword32
argument_list|(
operator|&
name|ujob32
operator|->
name|_aiocb_private
operator|.
name|error
argument_list|,
name|error
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|aiocb32_store_kernelinfo
parameter_list|(
name|struct
name|aiocb
modifier|*
name|ujob
parameter_list|,
name|long
name|jobref
parameter_list|)
block|{
name|struct
name|aiocb32
modifier|*
name|ujob32
decl_stmt|;
name|ujob32
operator|=
operator|(
expr|struct
name|aiocb32
operator|*
operator|)
name|ujob
expr_stmt|;
return|return
operator|(
name|suword32
argument_list|(
operator|&
name|ujob32
operator|->
name|_aiocb_private
operator|.
name|kernelinfo
argument_list|,
name|jobref
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|aiocb32_store_aiocb
parameter_list|(
name|struct
name|aiocb
modifier|*
modifier|*
name|ujobp
parameter_list|,
name|struct
name|aiocb
modifier|*
name|ujob
parameter_list|)
block|{
return|return
operator|(
name|suword32
argument_list|(
name|ujobp
argument_list|,
operator|(
name|long
operator|)
name|ujob
argument_list|)
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|aiocb_ops
name|aiocb32_ops
init|=
block|{
operator|.
name|copyin
operator|=
name|aiocb32_copyin
block|,
operator|.
name|fetch_status
operator|=
name|aiocb32_fetch_status
block|,
operator|.
name|fetch_error
operator|=
name|aiocb32_fetch_error
block|,
operator|.
name|store_status
operator|=
name|aiocb32_store_status
block|,
operator|.
name|store_error
operator|=
name|aiocb32_store_error
block|,
operator|.
name|store_kernelinfo
operator|=
name|aiocb32_store_kernelinfo
block|,
operator|.
name|store_aiocb
operator|=
name|aiocb32_store_aiocb
block|, }
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|COMPAT_FREEBSD6
end_ifdef

begin_decl_stmt
specifier|static
name|struct
name|aiocb_ops
name|aiocb32_ops_osigevent
init|=
block|{
operator|.
name|copyin
operator|=
name|aiocb32_copyin_old_sigevent
block|,
operator|.
name|fetch_status
operator|=
name|aiocb32_fetch_status
block|,
operator|.
name|fetch_error
operator|=
name|aiocb32_fetch_error
block|,
operator|.
name|store_status
operator|=
name|aiocb32_store_status
block|,
operator|.
name|store_error
operator|=
name|aiocb32_store_error
block|,
operator|.
name|store_kernelinfo
operator|=
name|aiocb32_store_kernelinfo
block|,
operator|.
name|store_aiocb
operator|=
name|aiocb32_store_aiocb
block|, }
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|freebsd32_aio_return
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|freebsd32_aio_return_args
modifier|*
name|uap
parameter_list|)
block|{
return|return
operator|(
name|kern_aio_return
argument_list|(
name|td
argument_list|,
operator|(
expr|struct
name|aiocb
operator|*
operator|)
name|uap
operator|->
name|aiocbp
argument_list|,
operator|&
name|aiocb32_ops
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|freebsd32_aio_suspend
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|freebsd32_aio_suspend_args
modifier|*
name|uap
parameter_list|)
block|{
name|struct
name|timespec32
name|ts32
decl_stmt|;
name|struct
name|timespec
name|ts
decl_stmt|,
modifier|*
name|tsp
decl_stmt|;
name|struct
name|aiocb
modifier|*
modifier|*
name|ujoblist
decl_stmt|;
name|uint32_t
modifier|*
name|ujoblist32
decl_stmt|;
name|int
name|error
decl_stmt|,
name|i
decl_stmt|;
if|if
condition|(
name|uap
operator|->
name|nent
operator|<
literal|0
operator|||
name|uap
operator|->
name|nent
operator|>
name|AIO_LISTIO_MAX
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|uap
operator|->
name|timeout
condition|)
block|{
comment|/* Get timespec struct. */
if|if
condition|(
operator|(
name|error
operator|=
name|copyin
argument_list|(
name|uap
operator|->
name|timeout
argument_list|,
operator|&
name|ts32
argument_list|,
sizeof|sizeof
argument_list|(
name|ts32
argument_list|)
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|CP
argument_list|(
name|ts32
argument_list|,
name|ts
argument_list|,
name|tv_sec
argument_list|)
expr_stmt|;
name|CP
argument_list|(
name|ts32
argument_list|,
name|ts
argument_list|,
name|tv_nsec
argument_list|)
expr_stmt|;
name|tsp
operator|=
operator|&
name|ts
expr_stmt|;
block|}
else|else
name|tsp
operator|=
name|NULL
expr_stmt|;
name|ujoblist
operator|=
name|uma_zalloc
argument_list|(
name|aiol_zone
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|ujoblist32
operator|=
operator|(
name|uint32_t
operator|*
operator|)
name|ujoblist
expr_stmt|;
name|error
operator|=
name|copyin
argument_list|(
name|uap
operator|->
name|aiocbp
argument_list|,
name|ujoblist32
argument_list|,
name|uap
operator|->
name|nent
operator|*
sizeof|sizeof
argument_list|(
name|ujoblist32
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
name|uap
operator|->
name|nent
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
name|ujoblist
index|[
name|i
index|]
operator|=
name|PTRIN
argument_list|(
name|ujoblist32
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|error
operator|=
name|kern_aio_suspend
argument_list|(
name|td
argument_list|,
name|uap
operator|->
name|nent
argument_list|,
name|ujoblist
argument_list|,
name|tsp
argument_list|)
expr_stmt|;
block|}
name|uma_zfree
argument_list|(
name|aiol_zone
argument_list|,
name|ujoblist
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|freebsd32_aio_error
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|freebsd32_aio_error_args
modifier|*
name|uap
parameter_list|)
block|{
return|return
operator|(
name|kern_aio_error
argument_list|(
name|td
argument_list|,
operator|(
expr|struct
name|aiocb
operator|*
operator|)
name|uap
operator|->
name|aiocbp
argument_list|,
operator|&
name|aiocb32_ops
argument_list|)
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|COMPAT_FREEBSD6
end_ifdef

begin_function
name|int
name|freebsd6_freebsd32_aio_read
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|freebsd6_freebsd32_aio_read_args
modifier|*
name|uap
parameter_list|)
block|{
return|return
operator|(
name|aio_aqueue
argument_list|(
name|td
argument_list|,
operator|(
expr|struct
name|aiocb
operator|*
operator|)
name|uap
operator|->
name|aiocbp
argument_list|,
name|NULL
argument_list|,
name|LIO_READ
argument_list|,
operator|&
name|aiocb32_ops_osigevent
argument_list|)
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|freebsd32_aio_read
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|freebsd32_aio_read_args
modifier|*
name|uap
parameter_list|)
block|{
return|return
operator|(
name|aio_aqueue
argument_list|(
name|td
argument_list|,
operator|(
expr|struct
name|aiocb
operator|*
operator|)
name|uap
operator|->
name|aiocbp
argument_list|,
name|NULL
argument_list|,
name|LIO_READ
argument_list|,
operator|&
name|aiocb32_ops
argument_list|)
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|COMPAT_FREEBSD6
end_ifdef

begin_function
name|int
name|freebsd6_freebsd32_aio_write
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|freebsd6_freebsd32_aio_write_args
modifier|*
name|uap
parameter_list|)
block|{
return|return
operator|(
name|aio_aqueue
argument_list|(
name|td
argument_list|,
operator|(
expr|struct
name|aiocb
operator|*
operator|)
name|uap
operator|->
name|aiocbp
argument_list|,
name|NULL
argument_list|,
name|LIO_WRITE
argument_list|,
operator|&
name|aiocb32_ops_osigevent
argument_list|)
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|freebsd32_aio_write
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|freebsd32_aio_write_args
modifier|*
name|uap
parameter_list|)
block|{
return|return
operator|(
name|aio_aqueue
argument_list|(
name|td
argument_list|,
operator|(
expr|struct
name|aiocb
operator|*
operator|)
name|uap
operator|->
name|aiocbp
argument_list|,
name|NULL
argument_list|,
name|LIO_WRITE
argument_list|,
operator|&
name|aiocb32_ops
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|freebsd32_aio_mlock
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|freebsd32_aio_mlock_args
modifier|*
name|uap
parameter_list|)
block|{
return|return
operator|(
name|aio_aqueue
argument_list|(
name|td
argument_list|,
operator|(
expr|struct
name|aiocb
operator|*
operator|)
name|uap
operator|->
name|aiocbp
argument_list|,
name|NULL
argument_list|,
name|LIO_MLOCK
argument_list|,
operator|&
name|aiocb32_ops
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|freebsd32_aio_waitcomplete
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|freebsd32_aio_waitcomplete_args
modifier|*
name|uap
parameter_list|)
block|{
name|struct
name|timespec32
name|ts32
decl_stmt|;
name|struct
name|timespec
name|ts
decl_stmt|,
modifier|*
name|tsp
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|uap
operator|->
name|timeout
condition|)
block|{
comment|/* Get timespec struct. */
name|error
operator|=
name|copyin
argument_list|(
name|uap
operator|->
name|timeout
argument_list|,
operator|&
name|ts32
argument_list|,
sizeof|sizeof
argument_list|(
name|ts32
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|CP
argument_list|(
name|ts32
argument_list|,
name|ts
argument_list|,
name|tv_sec
argument_list|)
expr_stmt|;
name|CP
argument_list|(
name|ts32
argument_list|,
name|ts
argument_list|,
name|tv_nsec
argument_list|)
expr_stmt|;
name|tsp
operator|=
operator|&
name|ts
expr_stmt|;
block|}
else|else
name|tsp
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|kern_aio_waitcomplete
argument_list|(
name|td
argument_list|,
operator|(
expr|struct
name|aiocb
operator|*
operator|*
operator|)
name|uap
operator|->
name|aiocbp
argument_list|,
name|tsp
argument_list|,
operator|&
name|aiocb32_ops
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|freebsd32_aio_fsync
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|freebsd32_aio_fsync_args
modifier|*
name|uap
parameter_list|)
block|{
return|return
operator|(
name|kern_aio_fsync
argument_list|(
name|td
argument_list|,
name|uap
operator|->
name|op
argument_list|,
operator|(
expr|struct
name|aiocb
operator|*
operator|)
name|uap
operator|->
name|aiocbp
argument_list|,
operator|&
name|aiocb32_ops
argument_list|)
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|COMPAT_FREEBSD6
end_ifdef

begin_function
name|int
name|freebsd6_freebsd32_lio_listio
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|freebsd6_freebsd32_lio_listio_args
modifier|*
name|uap
parameter_list|)
block|{
name|struct
name|aiocb
modifier|*
modifier|*
name|acb_list
decl_stmt|;
name|struct
name|sigevent
modifier|*
name|sigp
decl_stmt|,
name|sig
decl_stmt|;
name|struct
name|osigevent32
name|osig
decl_stmt|;
name|uint32_t
modifier|*
name|acb_list32
decl_stmt|;
name|int
name|error
decl_stmt|,
name|i
decl_stmt|,
name|nent
decl_stmt|;
if|if
condition|(
operator|(
name|uap
operator|->
name|mode
operator|!=
name|LIO_NOWAIT
operator|)
operator|&&
operator|(
name|uap
operator|->
name|mode
operator|!=
name|LIO_WAIT
operator|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|nent
operator|=
name|uap
operator|->
name|nent
expr_stmt|;
if|if
condition|(
name|nent
operator|<
literal|0
operator|||
name|nent
operator|>
name|AIO_LISTIO_MAX
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|uap
operator|->
name|sig
operator|&&
operator|(
name|uap
operator|->
name|mode
operator|==
name|LIO_NOWAIT
operator|)
condition|)
block|{
name|error
operator|=
name|copyin
argument_list|(
name|uap
operator|->
name|sig
argument_list|,
operator|&
name|osig
argument_list|,
sizeof|sizeof
argument_list|(
name|osig
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|error
operator|=
name|convert_old_sigevent32
argument_list|(
operator|&
name|osig
argument_list|,
operator|&
name|sig
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|sigp
operator|=
operator|&
name|sig
expr_stmt|;
block|}
else|else
name|sigp
operator|=
name|NULL
expr_stmt|;
name|acb_list32
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|*
name|nent
argument_list|,
name|M_LIO
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|error
operator|=
name|copyin
argument_list|(
name|uap
operator|->
name|acb_list
argument_list|,
name|acb_list32
argument_list|,
name|nent
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|free
argument_list|(
name|acb_list32
argument_list|,
name|M_LIO
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|acb_list
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|aiocb
operator|*
argument_list|)
operator|*
name|nent
argument_list|,
name|M_LIO
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nent
condition|;
name|i
operator|++
control|)
name|acb_list
index|[
name|i
index|]
operator|=
name|PTRIN
argument_list|(
name|acb_list32
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|acb_list32
argument_list|,
name|M_LIO
argument_list|)
expr_stmt|;
name|error
operator|=
name|kern_lio_listio
argument_list|(
name|td
argument_list|,
name|uap
operator|->
name|mode
argument_list|,
operator|(
expr|struct
name|aiocb
operator|*
specifier|const
operator|*
operator|)
name|uap
operator|->
name|acb_list
argument_list|,
name|acb_list
argument_list|,
name|nent
argument_list|,
name|sigp
argument_list|,
operator|&
name|aiocb32_ops_osigevent
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|acb_list
argument_list|,
name|M_LIO
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|freebsd32_lio_listio
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|freebsd32_lio_listio_args
modifier|*
name|uap
parameter_list|)
block|{
name|struct
name|aiocb
modifier|*
modifier|*
name|acb_list
decl_stmt|;
name|struct
name|sigevent
modifier|*
name|sigp
decl_stmt|,
name|sig
decl_stmt|;
name|struct
name|sigevent32
name|sig32
decl_stmt|;
name|uint32_t
modifier|*
name|acb_list32
decl_stmt|;
name|int
name|error
decl_stmt|,
name|i
decl_stmt|,
name|nent
decl_stmt|;
if|if
condition|(
operator|(
name|uap
operator|->
name|mode
operator|!=
name|LIO_NOWAIT
operator|)
operator|&&
operator|(
name|uap
operator|->
name|mode
operator|!=
name|LIO_WAIT
operator|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|nent
operator|=
name|uap
operator|->
name|nent
expr_stmt|;
if|if
condition|(
name|nent
operator|<
literal|0
operator|||
name|nent
operator|>
name|AIO_LISTIO_MAX
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|uap
operator|->
name|sig
operator|&&
operator|(
name|uap
operator|->
name|mode
operator|==
name|LIO_NOWAIT
operator|)
condition|)
block|{
name|error
operator|=
name|copyin
argument_list|(
name|uap
operator|->
name|sig
argument_list|,
operator|&
name|sig32
argument_list|,
sizeof|sizeof
argument_list|(
name|sig32
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|error
operator|=
name|convert_sigevent32
argument_list|(
operator|&
name|sig32
argument_list|,
operator|&
name|sig
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|sigp
operator|=
operator|&
name|sig
expr_stmt|;
block|}
else|else
name|sigp
operator|=
name|NULL
expr_stmt|;
name|acb_list32
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|*
name|nent
argument_list|,
name|M_LIO
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|error
operator|=
name|copyin
argument_list|(
name|uap
operator|->
name|acb_list
argument_list|,
name|acb_list32
argument_list|,
name|nent
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|free
argument_list|(
name|acb_list32
argument_list|,
name|M_LIO
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|acb_list
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|aiocb
operator|*
argument_list|)
operator|*
name|nent
argument_list|,
name|M_LIO
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nent
condition|;
name|i
operator|++
control|)
name|acb_list
index|[
name|i
index|]
operator|=
name|PTRIN
argument_list|(
name|acb_list32
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|acb_list32
argument_list|,
name|M_LIO
argument_list|)
expr_stmt|;
name|error
operator|=
name|kern_lio_listio
argument_list|(
name|td
argument_list|,
name|uap
operator|->
name|mode
argument_list|,
operator|(
expr|struct
name|aiocb
operator|*
specifier|const
operator|*
operator|)
name|uap
operator|->
name|acb_list
argument_list|,
name|acb_list
argument_list|,
name|nent
argument_list|,
name|sigp
argument_list|,
operator|&
name|aiocb32_ops
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|acb_list
argument_list|,
name|M_LIO
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

