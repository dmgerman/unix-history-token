begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *  * Portions of this code was derived from the file kern_fork.c and as such  * is subject to the copyrights below.  *  * Copyright (c) 1982, 1986, 1989, 1991, 1993  *	The Regents of the University of California.  All rights reserved.  * (c) UNIX System Laboratories, Inc.  * All or some portions of this file are derived from material licensed  * to the University of California by American Telephone and Telegraph  * Co. or Unix System Laboratories, Inc. and are reproduced herein with  * the permission of UNIX System Laboratories, Inc.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * Copyright (c) 1996 Douglas Santry  *  * This code is subject to the beer copyright.  If I chance to meet you in a  * bar and this code helped you in some way, you owe me a beer.  Only  * in Germany will I accept domestic beer.  This code may or may not work  * and I certainly make no claims as to its fitness for *any* purpose.  *   * $Id: kern_threads.c,v 1.1 1997/06/16 00:27:26 dyson Exp $  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/filedesc.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/resourcevar.h>
end_include

begin_include
include|#
directive|include
file|<sys/vnode.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/acct.h>
end_include

begin_include
include|#
directive|include
file|<sys/ktrace.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysproto.h>
end_include

begin_include
include|#
directive|include
file|<sys/unistd.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<machine/cpu.h>
end_include

begin_comment
comment|/*  * Low level support for sleep/wakeup paradigm  * If a timeout is specified:  *	returns 0 if wakeup  *	returns EAGAIN if timed out  *	returns EINVAL if error  *  * If a timeout is not specified:  *  *	returns time waiting in ticks.  */
end_comment

begin_function
name|int
name|thr_sleep
parameter_list|(
name|struct
name|proc
modifier|*
name|p
parameter_list|,
name|struct
name|thr_sleep_args
modifier|*
name|uap
parameter_list|,
name|int
modifier|*
name|retval
parameter_list|)
block|{
name|int
name|sleepstart
decl_stmt|;
name|struct
name|timespec
name|ts
decl_stmt|;
name|struct
name|timeval
name|atv
decl_stmt|,
name|utv
decl_stmt|;
name|int
name|error
decl_stmt|,
name|s
decl_stmt|,
name|timo
decl_stmt|;
name|timo
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|uap
operator|->
name|timeout
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * Get timespec struct 		 */
if|if
condition|(
name|error
operator|=
name|copyin
argument_list|(
operator|(
name|caddr_t
operator|)
name|uap
operator|->
name|timeout
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|ts
argument_list|,
sizeof|sizeof
name|ts
argument_list|)
condition|)
block|{
name|p
operator|->
name|p_wakeup
operator|=
literal|0
expr_stmt|;
return|return
name|error
return|;
block|}
if|if
condition|(
name|ts
operator|.
name|tv_nsec
operator|<
literal|0
operator|||
name|ts
operator|.
name|tv_nsec
operator|>=
literal|1000000000
condition|)
block|{
name|p
operator|->
name|p_wakeup
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|TIMESPEC_TO_TIMEVAL
argument_list|(
argument|&atv
argument_list|,
argument|&ts
argument_list|)
if|if
condition|(
name|itimerfix
argument_list|(
operator|&
name|atv
argument_list|)
condition|)
block|{
name|p
operator|->
name|p_wakeup
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* 		 * XXX this is not as careful as settimeofday() about minimising 		 * interrupt latency.  The hzto() interface is inconvenient as usual. 		 */
name|s
operator|=
name|splclock
argument_list|()
expr_stmt|;
name|timevaladd
argument_list|(
operator|&
name|atv
argument_list|,
operator|&
name|time
argument_list|)
expr_stmt|;
name|timo
operator|=
name|hzto
argument_list|(
operator|&
name|atv
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|timo
operator|==
literal|0
condition|)
name|timo
operator|=
literal|1
expr_stmt|;
block|}
name|retval
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|p_wakeup
operator|==
literal|0
condition|)
block|{
name|sleepstart
operator|=
name|ticks
expr_stmt|;
name|p
operator|->
name|p_flag
operator||=
name|P_SINTR
expr_stmt|;
name|error
operator|=
name|tsleep
argument_list|(
name|p
argument_list|,
name|PUSER
argument_list|,
literal|"thrslp"
argument_list|,
name|timo
argument_list|)
expr_stmt|;
name|p
operator|->
name|p_flag
operator|&=
operator|~
name|P_SINTR
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|EWOULDBLOCK
condition|)
block|{
name|p
operator|->
name|p_wakeup
operator|=
literal|0
expr_stmt|;
name|retval
index|[
literal|0
index|]
operator|=
name|EAGAIN
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|uap
operator|->
name|timeout
operator|==
literal|0
condition|)
name|retval
index|[
literal|0
index|]
operator|=
name|ticks
operator|-
name|sleepstart
expr_stmt|;
block|}
name|p
operator|->
name|p_wakeup
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|thr_wakeup
parameter_list|(
name|struct
name|proc
modifier|*
name|p
parameter_list|,
name|struct
name|thr_wakeup_args
modifier|*
name|uap
parameter_list|,
name|int
modifier|*
name|retval
parameter_list|)
block|{
name|struct
name|proc
modifier|*
name|pSlave
init|=
name|p
operator|->
name|p_leader
decl_stmt|;
while|while
condition|(
name|pSlave
operator|&&
operator|(
name|pSlave
operator|->
name|p_pid
operator|!=
name|uap
operator|->
name|pid
operator|)
condition|)
name|pSlave
operator|=
name|pSlave
operator|->
name|p_peers
expr_stmt|;
if|if
condition|(
name|pSlave
operator|==
literal|0
condition|)
block|{
name|retval
index|[
literal|0
index|]
operator|=
name|ESRCH
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|pSlave
operator|->
name|p_wakeup
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|pSlave
operator|->
name|p_stat
operator|==
name|SSLEEP
operator|)
operator|&&
operator|(
name|pSlave
operator|->
name|p_wchan
operator|==
name|pSlave
operator|)
condition|)
block|{
name|wakeup
argument_list|(
name|pSlave
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|retval
index|[
literal|0
index|]
operator|=
name|EAGAIN
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * General purpose yield system call  */
end_comment

begin_function
name|int
name|yield
parameter_list|(
name|struct
name|proc
modifier|*
name|p
parameter_list|,
name|struct
name|yield_args
modifier|*
name|uap
parameter_list|,
name|int
modifier|*
name|retval
parameter_list|)
block|{
name|int
name|s
decl_stmt|;
name|retval
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|s
operator|=
name|splhigh
argument_list|()
expr_stmt|;
name|p
operator|->
name|p_priority
operator|=
name|MAXPRI
expr_stmt|;
name|setrunqueue
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|mi_switch
argument_list|()
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

end_unit

