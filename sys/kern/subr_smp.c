begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2001, John Baldwin<jhb@FreeBSD.org>.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. Neither the name of the author nor the names of any co-contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * This module holds the global variables and machine independent functions  * used for the kernel SMP support.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/ktr.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/pcpu.h>
end_include

begin_include
include|#
directive|include
file|<sys/smp.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<machine/cpu.h>
end_include

begin_include
include|#
directive|include
file|<machine/smp.h>
end_include

begin_include
include|#
directive|include
file|"opt_sched.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|SMP
end_ifdef

begin_decl_stmt
specifier|volatile
name|cpumask_t
name|stopped_cpus
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|volatile
name|cpumask_t
name|started_cpus
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|cpumask_t
name|idle_cpus_mask
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|cpumask_t
name|hlt_cpus_mask
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|cpumask_t
name|logical_cpus_mask
decl_stmt|;
end_decl_stmt

begin_function_decl
name|void
function_decl|(
modifier|*
name|cpustop_restartfunc
function_decl|)
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* This is used in modules that need to work in both SMP and UP. */
end_comment

begin_decl_stmt
name|cpumask_t
name|all_cpus
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|mp_ncpus
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* export this for libkvm consumers. */
end_comment

begin_decl_stmt
name|int
name|mp_maxcpus
init|=
name|MAXCPU
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|volatile
name|int
name|smp_started
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_int
name|mp_maxid
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_kern
argument_list|,
name|OID_AUTO
argument_list|,
name|smp
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|NULL
argument_list|,
literal|"Kernel SMP"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_kern_smp
argument_list|,
name|OID_AUTO
argument_list|,
name|maxid
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|mp_maxid
argument_list|,
literal|0
argument_list|,
literal|"Max CPU ID."
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_kern_smp
argument_list|,
name|OID_AUTO
argument_list|,
name|maxcpus
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|mp_maxcpus
argument_list|,
literal|0
argument_list|,
literal|"Max number of CPUs that the system was compiled for."
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|smp_active
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* are the APs allowed to run? */
end_comment

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_kern_smp
argument_list|,
name|OID_AUTO
argument_list|,
name|active
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|smp_active
argument_list|,
literal|0
argument_list|,
literal|"Number of Auxillary Processors (APs) that were successfully started"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|smp_disabled
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* has smp been disabled? */
end_comment

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_kern_smp
argument_list|,
name|OID_AUTO
argument_list|,
name|disabled
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|smp_disabled
argument_list|,
literal|0
argument_list|,
literal|"SMP has been disabled from the loader"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"kern.smp.disabled"
argument_list|,
operator|&
name|smp_disabled
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|smp_cpus
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* how many cpu's running */
end_comment

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_kern_smp
argument_list|,
name|OID_AUTO
argument_list|,
name|cpus
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|smp_cpus
argument_list|,
literal|0
argument_list|,
literal|"Number of CPUs online"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|smp_topology
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Which topology we're using. */
end_comment

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_kern_smp
argument_list|,
name|OID_AUTO
argument_list|,
name|topology
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|smp_topology
argument_list|,
literal|0
argument_list|,
literal|"Topology override setting; 0 is default provided by hardware."
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"kern.smp.topology"
argument_list|,
operator|&
name|smp_topology
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|SMP
end_ifdef

begin_comment
comment|/* Enable forwarding of a signal to a process running on a different CPU */
end_comment

begin_decl_stmt
specifier|static
name|int
name|forward_signal_enabled
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_kern_smp
argument_list|,
name|OID_AUTO
argument_list|,
name|forward_signal_enabled
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|forward_signal_enabled
argument_list|,
literal|0
argument_list|,
literal|"Forwarding of a signal to a process on a different CPU"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Variables needed for SMP rendezvous. */
end_comment

begin_decl_stmt
specifier|static
specifier|volatile
name|int
name|smp_rv_ncpus
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|static
name|void
argument_list|(
operator|*
specifier|volatile
name|smp_rv_setup_func
argument_list|)
argument_list|(
name|void
operator|*
name|arg
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|void
argument_list|(
operator|*
specifier|volatile
name|smp_rv_action_func
argument_list|)
argument_list|(
name|void
operator|*
name|arg
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|void
argument_list|(
operator|*
specifier|volatile
name|smp_rv_teardown_func
argument_list|)
argument_list|(
name|void
operator|*
name|arg
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|void
modifier|*
specifier|volatile
name|smp_rv_func_arg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|volatile
name|int
name|smp_rv_waiters
index|[
literal|3
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*   * Shared mutex to restrict busywaits between smp_rendezvous() and  * smp(_targeted)_tlb_shootdown().  A deadlock occurs if both of these  * functions trigger at once and cause multiple CPUs to busywait with  * interrupts disabled.   */
end_comment

begin_decl_stmt
name|struct
name|mtx
name|smp_ipi_mtx
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Let the MD SMP code initialize mp_maxid very early if it can.  */
end_comment

begin_function
specifier|static
name|void
name|mp_setmaxid
parameter_list|(
name|void
modifier|*
name|dummy
parameter_list|)
block|{
name|cpu_mp_setmaxid
argument_list|()
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|SYSINIT
argument_list|(
name|cpu_mp_setmaxid
argument_list|,
name|SI_SUB_TUNABLES
argument_list|,
name|SI_ORDER_FIRST
argument_list|,
name|mp_setmaxid
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Call the MD SMP initialization code.  */
end_comment

begin_function
specifier|static
name|void
name|mp_start
parameter_list|(
name|void
modifier|*
name|dummy
parameter_list|)
block|{
comment|/* Probe for MP hardware. */
if|if
condition|(
name|smp_disabled
operator|!=
literal|0
operator|||
name|cpu_mp_probe
argument_list|()
operator|==
literal|0
condition|)
block|{
name|mp_ncpus
operator|=
literal|1
expr_stmt|;
name|all_cpus
operator|=
name|PCPU_GET
argument_list|(
name|cpumask
argument_list|)
expr_stmt|;
return|return;
block|}
name|mtx_init
argument_list|(
operator|&
name|smp_ipi_mtx
argument_list|,
literal|"smp rendezvous"
argument_list|,
name|NULL
argument_list|,
name|MTX_SPIN
argument_list|)
expr_stmt|;
name|cpu_mp_start
argument_list|()
expr_stmt|;
name|printf
argument_list|(
literal|"FreeBSD/SMP: Multiprocessor System Detected: %d CPUs\n"
argument_list|,
name|mp_ncpus
argument_list|)
expr_stmt|;
name|cpu_mp_announce
argument_list|()
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|SYSINIT
argument_list|(
name|cpu_mp
argument_list|,
name|SI_SUB_CPU
argument_list|,
name|SI_ORDER_THIRD
argument_list|,
name|mp_start
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
name|void
name|forward_signal
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|int
name|id
decl_stmt|;
comment|/* 	 * signotify() has already set TDF_ASTPENDING and TDF_NEEDSIGCHECK on 	 * this thread, so all we need to do is poke it if it is currently 	 * executing so that it executes ast(). 	 */
name|THREAD_LOCK_ASSERT
argument_list|(
name|td
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|TD_IS_RUNNING
argument_list|(
name|td
argument_list|)
argument_list|,
operator|(
literal|"forward_signal: thread is not TDS_RUNNING"
operator|)
argument_list|)
expr_stmt|;
name|CTR1
argument_list|(
name|KTR_SMP
argument_list|,
literal|"forward_signal(%p)"
argument_list|,
name|td
operator|->
name|td_proc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|smp_started
operator|||
name|cold
operator|||
name|panicstr
condition|)
return|return;
if|if
condition|(
operator|!
name|forward_signal_enabled
condition|)
return|return;
comment|/* No need to IPI ourself. */
if|if
condition|(
name|td
operator|==
name|curthread
condition|)
return|return;
name|id
operator|=
name|td
operator|->
name|td_oncpu
expr_stmt|;
if|if
condition|(
name|id
operator|==
name|NOCPU
condition|)
return|return;
name|ipi_selected
argument_list|(
literal|1
operator|<<
name|id
argument_list|,
name|IPI_AST
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * When called the executing CPU will send an IPI to all other CPUs  *  requesting that they halt execution.  *  * Usually (but not necessarily) called with 'other_cpus' as its arg.  *  *  - Signals all CPUs in map to stop.  *  - Waits for each to stop.  *  * Returns:  *  -1: error  *   0: NA  *   1: ok  *  * XXX FIXME: this is not MP-safe, needs a lock to prevent multiple CPUs  *            from executing at same time.  */
end_comment

begin_function
specifier|static
name|int
name|generic_stop_cpus
parameter_list|(
name|cpumask_t
name|map
parameter_list|,
name|u_int
name|type
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|KASSERT
argument_list|(
name|type
operator|==
name|IPI_STOP
operator|||
name|type
operator|==
name|IPI_STOP_HARD
argument_list|,
operator|(
literal|"%s: invalid stop type"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|smp_started
condition|)
return|return
literal|0
return|;
name|CTR2
argument_list|(
name|KTR_SMP
argument_list|,
literal|"stop_cpus(%x) with %u type"
argument_list|,
name|map
argument_list|,
name|type
argument_list|)
expr_stmt|;
comment|/* send the stop IPI to all CPUs in map */
name|ipi_selected
argument_list|(
name|map
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|stopped_cpus
operator|&
name|map
operator|)
operator|!=
name|map
condition|)
block|{
comment|/* spin */
name|cpu_spinwait
argument_list|()
expr_stmt|;
name|i
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
name|i
operator|==
literal|100000
condition|)
block|{
name|printf
argument_list|(
literal|"timeout stopping cpus\n"
argument_list|)
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
name|int
name|stop_cpus
parameter_list|(
name|cpumask_t
name|map
parameter_list|)
block|{
return|return
operator|(
name|generic_stop_cpus
argument_list|(
name|map
argument_list|,
name|IPI_STOP
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|stop_cpus_hard
parameter_list|(
name|cpumask_t
name|map
parameter_list|)
block|{
return|return
operator|(
name|generic_stop_cpus
argument_list|(
name|map
argument_list|,
name|IPI_STOP_HARD
argument_list|)
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__amd64__
argument_list|)
end_if

begin_comment
comment|/*  * When called the executing CPU will send an IPI to all other CPUs  *  requesting that they halt execution.  *  * Usually (but not necessarily) called with 'other_cpus' as its arg.  *  *  - Signals all CPUs in map to suspend.  *  - Waits for each to suspend.  *  * Returns:  *  -1: error  *   0: NA  *   1: ok  *  * XXX FIXME: this is not MP-safe, needs a lock to prevent multiple CPUs  *            from executing at same time.  */
end_comment

begin_function
name|int
name|suspend_cpus
parameter_list|(
name|cpumask_t
name|map
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|smp_started
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|CTR1
argument_list|(
name|KTR_SMP
argument_list|,
literal|"suspend_cpus(%x)"
argument_list|,
name|map
argument_list|)
expr_stmt|;
comment|/* send the suspend IPI to all CPUs in map */
name|ipi_selected
argument_list|(
name|map
argument_list|,
name|IPI_SUSPEND
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|stopped_cpus
operator|&
name|map
operator|)
operator|!=
name|map
condition|)
block|{
comment|/* spin */
name|cpu_spinwait
argument_list|()
expr_stmt|;
name|i
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
name|i
operator|==
literal|100000
condition|)
block|{
name|printf
argument_list|(
literal|"timeout suspending cpus\n"
argument_list|)
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Called by a CPU to restart stopped CPUs.   *  * Usually (but not necessarily) called with 'stopped_cpus' as its arg.  *  *  - Signals all CPUs in map to restart.  *  - Waits for each to restart.  *  * Returns:  *  -1: error  *   0: NA  *   1: ok  */
end_comment

begin_function
name|int
name|restart_cpus
parameter_list|(
name|cpumask_t
name|map
parameter_list|)
block|{
if|if
condition|(
operator|!
name|smp_started
condition|)
return|return
literal|0
return|;
name|CTR1
argument_list|(
name|KTR_SMP
argument_list|,
literal|"restart_cpus(%x)"
argument_list|,
name|map
argument_list|)
expr_stmt|;
comment|/* signal other cpus to restart */
name|atomic_store_rel_int
argument_list|(
operator|&
name|started_cpus
argument_list|,
name|map
argument_list|)
expr_stmt|;
comment|/* wait for each to clear its bit */
while|while
condition|(
operator|(
name|stopped_cpus
operator|&
name|map
operator|)
operator|!=
literal|0
condition|)
name|cpu_spinwait
argument_list|()
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * All-CPU rendezvous.  CPUs are signalled, all execute the setup function   * (if specified), rendezvous, execute the action function (if specified),  * rendezvous again, execute the teardown function (if specified), and then  * resume.  *  * Note that the supplied external functions _must_ be reentrant and aware  * that they are running in parallel and in an unknown lock context.  */
end_comment

begin_function
name|void
name|smp_rendezvous_action
parameter_list|(
name|void
parameter_list|)
block|{
name|void
modifier|*
name|local_func_arg
init|=
name|smp_rv_func_arg
decl_stmt|;
name|void
function_decl|(
modifier|*
name|local_setup_func
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|)
init|=
name|smp_rv_setup_func
function_decl|;
name|void
function_decl|(
modifier|*
name|local_action_func
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|)
init|=
name|smp_rv_action_func
function_decl|;
name|void
function_decl|(
modifier|*
name|local_teardown_func
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|)
init|=
name|smp_rv_teardown_func
function_decl|;
comment|/* Ensure we have up-to-date values. */
name|atomic_add_acq_int
argument_list|(
operator|&
name|smp_rv_waiters
index|[
literal|0
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
while|while
condition|(
name|smp_rv_waiters
index|[
literal|0
index|]
operator|<
name|smp_rv_ncpus
condition|)
name|cpu_spinwait
argument_list|()
expr_stmt|;
comment|/* setup function */
if|if
condition|(
name|local_setup_func
operator|!=
name|smp_no_rendevous_barrier
condition|)
block|{
if|if
condition|(
name|smp_rv_setup_func
operator|!=
name|NULL
condition|)
name|smp_rv_setup_func
argument_list|(
name|smp_rv_func_arg
argument_list|)
expr_stmt|;
comment|/* spin on entry rendezvous */
name|atomic_add_int
argument_list|(
operator|&
name|smp_rv_waiters
index|[
literal|1
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
while|while
condition|(
name|smp_rv_waiters
index|[
literal|1
index|]
operator|<
name|smp_rv_ncpus
condition|)
name|cpu_spinwait
argument_list|()
expr_stmt|;
block|}
comment|/* action function */
if|if
condition|(
name|local_action_func
operator|!=
name|NULL
condition|)
name|local_action_func
argument_list|(
name|local_func_arg
argument_list|)
expr_stmt|;
comment|/* spin on exit rendezvous */
name|atomic_add_int
argument_list|(
operator|&
name|smp_rv_waiters
index|[
literal|2
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|local_teardown_func
operator|==
name|smp_no_rendevous_barrier
condition|)
return|return;
while|while
condition|(
name|smp_rv_waiters
index|[
literal|2
index|]
operator|<
name|smp_rv_ncpus
condition|)
name|cpu_spinwait
argument_list|()
expr_stmt|;
comment|/* teardown function */
if|if
condition|(
name|local_teardown_func
operator|!=
name|NULL
condition|)
name|local_teardown_func
argument_list|(
name|local_func_arg
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|smp_rendezvous_cpus
parameter_list|(
name|cpumask_t
name|map
parameter_list|,
name|void
function_decl|(
modifier|*
name|setup_func
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
function_decl|(
modifier|*
name|action_func
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
function_decl|(
modifier|*
name|teardown_func
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|ncpus
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|smp_started
condition|)
block|{
if|if
condition|(
name|setup_func
operator|!=
name|NULL
condition|)
name|setup_func
argument_list|(
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|action_func
operator|!=
name|NULL
condition|)
name|action_func
argument_list|(
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|teardown_func
operator|!=
name|NULL
condition|)
name|teardown_func
argument_list|(
name|arg
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|mp_maxid
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
operator|(
literal|1
operator|<<
name|i
operator|)
operator|&
name|map
operator|)
operator|!=
literal|0
operator|&&
operator|!
name|CPU_ABSENT
argument_list|(
name|i
argument_list|)
condition|)
name|ncpus
operator|++
expr_stmt|;
if|if
condition|(
name|ncpus
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"ncpus is 0 with map=0x%x"
argument_list|,
name|map
argument_list|)
expr_stmt|;
comment|/* obtain rendezvous lock */
name|mtx_lock_spin
argument_list|(
operator|&
name|smp_ipi_mtx
argument_list|)
expr_stmt|;
comment|/* set static function pointers */
name|smp_rv_ncpus
operator|=
name|ncpus
expr_stmt|;
name|smp_rv_setup_func
operator|=
name|setup_func
expr_stmt|;
name|smp_rv_action_func
operator|=
name|action_func
expr_stmt|;
name|smp_rv_teardown_func
operator|=
name|teardown_func
expr_stmt|;
name|smp_rv_func_arg
operator|=
name|arg
expr_stmt|;
name|smp_rv_waiters
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|smp_rv_waiters
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|atomic_store_rel_int
argument_list|(
operator|&
name|smp_rv_waiters
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* signal other processors, which will enter the IPI with interrupts off */
name|ipi_selected
argument_list|(
name|map
operator|&
operator|~
operator|(
literal|1
operator|<<
name|curcpu
operator|)
argument_list|,
name|IPI_RENDEZVOUS
argument_list|)
expr_stmt|;
comment|/* Check if the current CPU is in the map */
if|if
condition|(
operator|(
name|map
operator|&
operator|(
literal|1
operator|<<
name|curcpu
operator|)
operator|)
operator|!=
literal|0
condition|)
name|smp_rendezvous_action
argument_list|()
expr_stmt|;
if|if
condition|(
name|teardown_func
operator|==
name|smp_no_rendevous_barrier
condition|)
while|while
condition|(
name|atomic_load_acq_int
argument_list|(
operator|&
name|smp_rv_waiters
index|[
literal|2
index|]
argument_list|)
operator|<
name|ncpus
condition|)
name|cpu_spinwait
argument_list|()
expr_stmt|;
comment|/* release lock */
name|mtx_unlock_spin
argument_list|(
operator|&
name|smp_ipi_mtx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|smp_rendezvous
parameter_list|(
name|void
function_decl|(
modifier|*
name|setup_func
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
function_decl|(
modifier|*
name|action_func
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
function_decl|(
modifier|*
name|teardown_func
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|smp_rendezvous_cpus
argument_list|(
name|all_cpus
argument_list|,
name|setup_func
argument_list|,
name|action_func
argument_list|,
name|teardown_func
argument_list|,
name|arg
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|cpu_group
name|group
index|[
name|MAXCPU
index|]
decl_stmt|;
end_decl_stmt

begin_function
name|struct
name|cpu_group
modifier|*
name|smp_topo
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|cpu_group
modifier|*
name|top
decl_stmt|;
comment|/* 	 * Check for a fake topology request for debugging purposes. 	 */
switch|switch
condition|(
name|smp_topology
condition|)
block|{
case|case
literal|1
case|:
comment|/* Dual core with no sharing.  */
name|top
operator|=
name|smp_topo_1level
argument_list|(
name|CG_SHARE_NONE
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
comment|/* No topology, all cpus are equal. */
name|top
operator|=
name|smp_topo_none
argument_list|()
expr_stmt|;
break|break;
case|case
literal|3
case|:
comment|/* Dual core with shared L2.  */
name|top
operator|=
name|smp_topo_1level
argument_list|(
name|CG_SHARE_L2
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|4
case|:
comment|/* quad core, shared l3 among each package, private l2.  */
name|top
operator|=
name|smp_topo_1level
argument_list|(
name|CG_SHARE_L3
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|5
case|:
comment|/* quad core,  2 dualcore parts on each package share l2.  */
name|top
operator|=
name|smp_topo_2level
argument_list|(
name|CG_SHARE_NONE
argument_list|,
literal|2
argument_list|,
name|CG_SHARE_L2
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|6
case|:
comment|/* Single-core 2xHTT */
name|top
operator|=
name|smp_topo_1level
argument_list|(
name|CG_SHARE_L1
argument_list|,
literal|2
argument_list|,
name|CG_FLAG_HTT
argument_list|)
expr_stmt|;
break|break;
case|case
literal|7
case|:
comment|/* quad core with a shared l3, 8 threads sharing L2.  */
name|top
operator|=
name|smp_topo_2level
argument_list|(
name|CG_SHARE_L3
argument_list|,
literal|4
argument_list|,
name|CG_SHARE_L2
argument_list|,
literal|8
argument_list|,
name|CG_FLAG_SMT
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* Default, ask the system what it wants. */
name|top
operator|=
name|cpu_topo
argument_list|()
expr_stmt|;
break|break;
block|}
comment|/* 	 * Verify the returned topology. 	 */
if|if
condition|(
name|top
operator|->
name|cg_count
operator|!=
name|mp_ncpus
condition|)
name|panic
argument_list|(
literal|"Built bad topology at %p.  CPU count %d != %d"
argument_list|,
name|top
argument_list|,
name|top
operator|->
name|cg_count
argument_list|,
name|mp_ncpus
argument_list|)
expr_stmt|;
if|if
condition|(
name|top
operator|->
name|cg_mask
operator|!=
name|all_cpus
condition|)
name|panic
argument_list|(
literal|"Built bad topology at %p.  CPU mask 0x%X != 0x%X"
argument_list|,
name|top
argument_list|,
name|top
operator|->
name|cg_mask
argument_list|,
name|all_cpus
argument_list|)
expr_stmt|;
return|return
operator|(
name|top
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|cpu_group
modifier|*
name|smp_topo_none
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|cpu_group
modifier|*
name|top
decl_stmt|;
name|top
operator|=
operator|&
name|group
index|[
literal|0
index|]
expr_stmt|;
name|top
operator|->
name|cg_parent
operator|=
name|NULL
expr_stmt|;
name|top
operator|->
name|cg_child
operator|=
name|NULL
expr_stmt|;
name|top
operator|->
name|cg_mask
operator|=
operator|(
literal|1
operator|<<
name|mp_ncpus
operator|)
operator|-
literal|1
expr_stmt|;
name|top
operator|->
name|cg_count
operator|=
name|mp_ncpus
expr_stmt|;
name|top
operator|->
name|cg_children
operator|=
literal|0
expr_stmt|;
name|top
operator|->
name|cg_level
operator|=
name|CG_SHARE_NONE
expr_stmt|;
name|top
operator|->
name|cg_flags
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|top
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|smp_topo_addleaf
parameter_list|(
name|struct
name|cpu_group
modifier|*
name|parent
parameter_list|,
name|struct
name|cpu_group
modifier|*
name|child
parameter_list|,
name|int
name|share
parameter_list|,
name|int
name|count
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|start
parameter_list|)
block|{
name|cpumask_t
name|mask
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|mask
operator|=
literal|0
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
operator|,
name|start
operator|++
control|)
name|mask
operator||=
operator|(
literal|1
operator|<<
name|start
operator|)
expr_stmt|;
name|child
operator|->
name|cg_parent
operator|=
name|parent
expr_stmt|;
name|child
operator|->
name|cg_child
operator|=
name|NULL
expr_stmt|;
name|child
operator|->
name|cg_children
operator|=
literal|0
expr_stmt|;
name|child
operator|->
name|cg_level
operator|=
name|share
expr_stmt|;
name|child
operator|->
name|cg_count
operator|=
name|count
expr_stmt|;
name|child
operator|->
name|cg_flags
operator|=
name|flags
expr_stmt|;
name|child
operator|->
name|cg_mask
operator|=
name|mask
expr_stmt|;
name|parent
operator|->
name|cg_children
operator|++
expr_stmt|;
for|for
control|(
init|;
name|parent
operator|!=
name|NULL
condition|;
name|parent
operator|=
name|parent
operator|->
name|cg_parent
control|)
block|{
if|if
condition|(
operator|(
name|parent
operator|->
name|cg_mask
operator|&
name|child
operator|->
name|cg_mask
operator|)
operator|!=
literal|0
condition|)
name|panic
argument_list|(
literal|"Duplicate children in %p.  mask 0x%X child 0x%X"
argument_list|,
name|parent
argument_list|,
name|parent
operator|->
name|cg_mask
argument_list|,
name|child
operator|->
name|cg_mask
argument_list|)
expr_stmt|;
name|parent
operator|->
name|cg_mask
operator||=
name|child
operator|->
name|cg_mask
expr_stmt|;
name|parent
operator|->
name|cg_count
operator|+=
name|child
operator|->
name|cg_count
expr_stmt|;
block|}
return|return
operator|(
name|start
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|cpu_group
modifier|*
name|smp_topo_1level
parameter_list|(
name|int
name|share
parameter_list|,
name|int
name|count
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|cpu_group
modifier|*
name|child
decl_stmt|;
name|struct
name|cpu_group
modifier|*
name|top
decl_stmt|;
name|int
name|packages
decl_stmt|;
name|int
name|cpu
decl_stmt|;
name|int
name|i
decl_stmt|;
name|cpu
operator|=
literal|0
expr_stmt|;
name|top
operator|=
operator|&
name|group
index|[
literal|0
index|]
expr_stmt|;
name|packages
operator|=
name|mp_ncpus
operator|/
name|count
expr_stmt|;
name|top
operator|->
name|cg_child
operator|=
name|child
operator|=
operator|&
name|group
index|[
literal|1
index|]
expr_stmt|;
name|top
operator|->
name|cg_level
operator|=
name|CG_SHARE_NONE
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|packages
condition|;
name|i
operator|++
operator|,
name|child
operator|++
control|)
name|cpu
operator|=
name|smp_topo_addleaf
argument_list|(
name|top
argument_list|,
name|child
argument_list|,
name|share
argument_list|,
name|count
argument_list|,
name|flags
argument_list|,
name|cpu
argument_list|)
expr_stmt|;
return|return
operator|(
name|top
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|cpu_group
modifier|*
name|smp_topo_2level
parameter_list|(
name|int
name|l2share
parameter_list|,
name|int
name|l2count
parameter_list|,
name|int
name|l1share
parameter_list|,
name|int
name|l1count
parameter_list|,
name|int
name|l1flags
parameter_list|)
block|{
name|struct
name|cpu_group
modifier|*
name|top
decl_stmt|;
name|struct
name|cpu_group
modifier|*
name|l1g
decl_stmt|;
name|struct
name|cpu_group
modifier|*
name|l2g
decl_stmt|;
name|int
name|cpu
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|j
decl_stmt|;
name|cpu
operator|=
literal|0
expr_stmt|;
name|top
operator|=
operator|&
name|group
index|[
literal|0
index|]
expr_stmt|;
name|l2g
operator|=
operator|&
name|group
index|[
literal|1
index|]
expr_stmt|;
name|top
operator|->
name|cg_child
operator|=
name|l2g
expr_stmt|;
name|top
operator|->
name|cg_level
operator|=
name|CG_SHARE_NONE
expr_stmt|;
name|top
operator|->
name|cg_children
operator|=
name|mp_ncpus
operator|/
operator|(
name|l2count
operator|*
name|l1count
operator|)
expr_stmt|;
name|l1g
operator|=
name|l2g
operator|+
name|top
operator|->
name|cg_children
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|top
operator|->
name|cg_children
condition|;
name|i
operator|++
operator|,
name|l2g
operator|++
control|)
block|{
name|l2g
operator|->
name|cg_parent
operator|=
name|top
expr_stmt|;
name|l2g
operator|->
name|cg_child
operator|=
name|l1g
expr_stmt|;
name|l2g
operator|->
name|cg_level
operator|=
name|l2share
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|l2count
condition|;
name|j
operator|++
operator|,
name|l1g
operator|++
control|)
name|cpu
operator|=
name|smp_topo_addleaf
argument_list|(
name|l2g
argument_list|,
name|l1g
argument_list|,
name|l1share
argument_list|,
name|l1count
argument_list|,
name|l1flags
argument_list|,
name|cpu
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|top
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|cpu_group
modifier|*
name|smp_topo_find
parameter_list|(
name|struct
name|cpu_group
modifier|*
name|top
parameter_list|,
name|int
name|cpu
parameter_list|)
block|{
name|struct
name|cpu_group
modifier|*
name|cg
decl_stmt|;
name|cpumask_t
name|mask
decl_stmt|;
name|int
name|children
decl_stmt|;
name|int
name|i
decl_stmt|;
name|mask
operator|=
operator|(
literal|1
operator|<<
name|cpu
operator|)
expr_stmt|;
name|cg
operator|=
name|top
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|(
name|cg
operator|->
name|cg_mask
operator|&
name|mask
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
name|cg
operator|->
name|cg_children
operator|==
literal|0
condition|)
return|return
operator|(
name|cg
operator|)
return|;
name|children
operator|=
name|cg
operator|->
name|cg_children
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|cg
operator|=
name|cg
operator|->
name|cg_child
init|;
name|i
operator|<
name|children
condition|;
name|cg
operator|++
operator|,
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|cg
operator|->
name|cg_mask
operator|&
name|mask
operator|)
operator|!=
literal|0
condition|)
break|break;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* !SMP */
end_comment

begin_function
name|void
name|smp_rendezvous_cpus
parameter_list|(
name|cpumask_t
name|map
parameter_list|,
name|void
function_decl|(
modifier|*
name|setup_func
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
function_decl|(
modifier|*
name|action_func
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
function_decl|(
modifier|*
name|teardown_func
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
if|if
condition|(
name|setup_func
operator|!=
name|NULL
condition|)
name|setup_func
argument_list|(
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|action_func
operator|!=
name|NULL
condition|)
name|action_func
argument_list|(
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|teardown_func
operator|!=
name|NULL
condition|)
name|teardown_func
argument_list|(
name|arg
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|smp_rendezvous
parameter_list|(
name|void
function_decl|(
modifier|*
name|setup_func
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
function_decl|(
modifier|*
name|action_func
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
function_decl|(
modifier|*
name|teardown_func
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
if|if
condition|(
name|setup_func
operator|!=
name|NULL
condition|)
name|setup_func
argument_list|(
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|action_func
operator|!=
name|NULL
condition|)
name|action_func
argument_list|(
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|teardown_func
operator|!=
name|NULL
condition|)
name|teardown_func
argument_list|(
name|arg
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Provide dummy SMP support for UP kernels.  Modules that need to use SMP  * APIs will still work using this dummy support.  */
end_comment

begin_function
specifier|static
name|void
name|mp_setvariables_for_up
parameter_list|(
name|void
modifier|*
name|dummy
parameter_list|)
block|{
name|mp_ncpus
operator|=
literal|1
expr_stmt|;
name|mp_maxid
operator|=
name|PCPU_GET
argument_list|(
name|cpuid
argument_list|)
expr_stmt|;
name|all_cpus
operator|=
name|PCPU_GET
argument_list|(
name|cpumask
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|PCPU_GET
argument_list|(
name|cpuid
argument_list|)
operator|==
literal|0
argument_list|,
operator|(
literal|"UP must have a CPU ID of zero"
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|SYSINIT
argument_list|(
name|cpu_mp_setvariables
argument_list|,
name|SI_SUB_TUNABLES
argument_list|,
name|SI_ORDER_FIRST
argument_list|,
name|mp_setvariables_for_up
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SMP */
end_comment

begin_function
name|void
name|smp_no_rendevous_barrier
parameter_list|(
name|void
modifier|*
name|dummy
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|SMP
name|KASSERT
argument_list|(
operator|(
operator|!
name|smp_started
operator|)
argument_list|,
operator|(
literal|"smp_no_rendevous called and smp is started"
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

end_unit

