begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2001, John Baldwin<jhb@FreeBSD.org>.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * This module holds the global variables and machine independent functions  * used for the kernel SMP support.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/ktr.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/pcpu.h>
end_include

begin_include
include|#
directive|include
file|<sys/sched.h>
end_include

begin_include
include|#
directive|include
file|<sys/smp.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<machine/cpu.h>
end_include

begin_include
include|#
directive|include
file|<machine/smp.h>
end_include

begin_include
include|#
directive|include
file|"opt_sched.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|SMP
end_ifdef

begin_decl_stmt
specifier|volatile
name|cpuset_t
name|stopped_cpus
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|volatile
name|cpuset_t
name|started_cpus
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|volatile
name|cpuset_t
name|suspended_cpus
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|cpuset_t
name|hlt_cpus_mask
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|cpuset_t
name|logical_cpus_mask
decl_stmt|;
end_decl_stmt

begin_function_decl
name|void
function_decl|(
modifier|*
name|cpustop_restartfunc
function_decl|)
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|int
name|sysctl_kern_smp_active
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* This is used in modules that need to work in both SMP and UP. */
end_comment

begin_decl_stmt
name|cpuset_t
name|all_cpus
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|mp_ncpus
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* export this for libkvm consumers. */
end_comment

begin_decl_stmt
name|int
name|mp_maxcpus
init|=
name|MAXCPU
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|volatile
name|int
name|smp_started
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_int
name|mp_maxid
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|static
name|SYSCTL_NODE
argument_list|(
name|_kern
argument_list|,
name|OID_AUTO
argument_list|,
name|smp
argument_list|,
name|CTLFLAG_RD
operator||
name|CTLFLAG_CAPRD
argument_list|,
name|NULL
argument_list|,
literal|"Kernel SMP"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_kern_smp
argument_list|,
name|OID_AUTO
argument_list|,
name|maxid
argument_list|,
name|CTLFLAG_RD
operator||
name|CTLFLAG_CAPRD
argument_list|,
operator|&
name|mp_maxid
argument_list|,
literal|0
argument_list|,
literal|"Max CPU ID."
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_kern_smp
argument_list|,
name|OID_AUTO
argument_list|,
name|maxcpus
argument_list|,
name|CTLFLAG_RD
operator||
name|CTLFLAG_CAPRD
argument_list|,
operator|&
name|mp_maxcpus
argument_list|,
literal|0
argument_list|,
literal|"Max number of CPUs that the system was compiled for."
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_PROC
argument_list|(
name|_kern_smp
argument_list|,
name|OID_AUTO
argument_list|,
name|active
argument_list|,
name|CTLFLAG_RD
operator||
name|CTLTYPE_INT
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|sysctl_kern_smp_active
argument_list|,
literal|"I"
argument_list|,
literal|"Indicates system is running in SMP mode"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|smp_disabled
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* has smp been disabled? */
end_comment

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_kern_smp
argument_list|,
name|OID_AUTO
argument_list|,
name|disabled
argument_list|,
name|CTLFLAG_RDTUN
operator||
name|CTLFLAG_CAPRD
argument_list|,
operator|&
name|smp_disabled
argument_list|,
literal|0
argument_list|,
literal|"SMP has been disabled from the loader"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|smp_cpus
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* how many cpu's running */
end_comment

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_kern_smp
argument_list|,
name|OID_AUTO
argument_list|,
name|cpus
argument_list|,
name|CTLFLAG_RD
operator||
name|CTLFLAG_CAPRD
argument_list|,
operator|&
name|smp_cpus
argument_list|,
literal|0
argument_list|,
literal|"Number of CPUs online"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|smp_topology
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Which topology we're using. */
end_comment

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_kern_smp
argument_list|,
name|OID_AUTO
argument_list|,
name|topology
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|smp_topology
argument_list|,
literal|0
argument_list|,
literal|"Topology override setting; 0 is default provided by hardware."
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|SMP
end_ifdef

begin_comment
comment|/* Enable forwarding of a signal to a process running on a different CPU */
end_comment

begin_decl_stmt
specifier|static
name|int
name|forward_signal_enabled
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_kern_smp
argument_list|,
name|OID_AUTO
argument_list|,
name|forward_signal_enabled
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|forward_signal_enabled
argument_list|,
literal|0
argument_list|,
literal|"Forwarding of a signal to a process on a different CPU"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Variables needed for SMP rendezvous. */
end_comment

begin_decl_stmt
specifier|static
specifier|volatile
name|int
name|smp_rv_ncpus
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|static
name|void
argument_list|(
operator|*
specifier|volatile
name|smp_rv_setup_func
argument_list|)
argument_list|(
name|void
operator|*
name|arg
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|void
argument_list|(
operator|*
specifier|volatile
name|smp_rv_action_func
argument_list|)
argument_list|(
name|void
operator|*
name|arg
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|void
argument_list|(
operator|*
specifier|volatile
name|smp_rv_teardown_func
argument_list|)
argument_list|(
name|void
operator|*
name|arg
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|void
modifier|*
specifier|volatile
name|smp_rv_func_arg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|volatile
name|int
name|smp_rv_waiters
index|[
literal|4
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*   * Shared mutex to restrict busywaits between smp_rendezvous() and  * smp(_targeted)_tlb_shootdown().  A deadlock occurs if both of these  * functions trigger at once and cause multiple CPUs to busywait with  * interrupts disabled.   */
end_comment

begin_decl_stmt
name|struct
name|mtx
name|smp_ipi_mtx
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Let the MD SMP code initialize mp_maxid very early if it can.  */
end_comment

begin_function
specifier|static
name|void
name|mp_setmaxid
parameter_list|(
name|void
modifier|*
name|dummy
parameter_list|)
block|{
name|cpu_mp_setmaxid
argument_list|()
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|SYSINIT
argument_list|(
name|cpu_mp_setmaxid
argument_list|,
name|SI_SUB_TUNABLES
argument_list|,
name|SI_ORDER_FIRST
argument_list|,
name|mp_setmaxid
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Call the MD SMP initialization code.  */
end_comment

begin_function
specifier|static
name|void
name|mp_start
parameter_list|(
name|void
modifier|*
name|dummy
parameter_list|)
block|{
name|mtx_init
argument_list|(
operator|&
name|smp_ipi_mtx
argument_list|,
literal|"smp rendezvous"
argument_list|,
name|NULL
argument_list|,
name|MTX_SPIN
argument_list|)
expr_stmt|;
comment|/* Probe for MP hardware. */
if|if
condition|(
name|smp_disabled
operator|!=
literal|0
operator|||
name|cpu_mp_probe
argument_list|()
operator|==
literal|0
condition|)
block|{
name|mp_ncpus
operator|=
literal|1
expr_stmt|;
name|CPU_SETOF
argument_list|(
name|PCPU_GET
argument_list|(
name|cpuid
argument_list|)
argument_list|,
operator|&
name|all_cpus
argument_list|)
expr_stmt|;
return|return;
block|}
name|cpu_mp_start
argument_list|()
expr_stmt|;
name|printf
argument_list|(
literal|"FreeBSD/SMP: Multiprocessor System Detected: %d CPUs\n"
argument_list|,
name|mp_ncpus
argument_list|)
expr_stmt|;
name|cpu_mp_announce
argument_list|()
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|SYSINIT
argument_list|(
name|cpu_mp
argument_list|,
name|SI_SUB_CPU
argument_list|,
name|SI_ORDER_THIRD
argument_list|,
name|mp_start
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
name|void
name|forward_signal
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|int
name|id
decl_stmt|;
comment|/* 	 * signotify() has already set TDF_ASTPENDING and TDF_NEEDSIGCHECK on 	 * this thread, so all we need to do is poke it if it is currently 	 * executing so that it executes ast(). 	 */
name|THREAD_LOCK_ASSERT
argument_list|(
name|td
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|TD_IS_RUNNING
argument_list|(
name|td
argument_list|)
argument_list|,
operator|(
literal|"forward_signal: thread is not TDS_RUNNING"
operator|)
argument_list|)
expr_stmt|;
name|CTR1
argument_list|(
name|KTR_SMP
argument_list|,
literal|"forward_signal(%p)"
argument_list|,
name|td
operator|->
name|td_proc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|smp_started
operator|||
name|cold
operator|||
name|panicstr
condition|)
return|return;
if|if
condition|(
operator|!
name|forward_signal_enabled
condition|)
return|return;
comment|/* No need to IPI ourself. */
if|if
condition|(
name|td
operator|==
name|curthread
condition|)
return|return;
name|id
operator|=
name|td
operator|->
name|td_oncpu
expr_stmt|;
if|if
condition|(
name|id
operator|==
name|NOCPU
condition|)
return|return;
name|ipi_cpu
argument_list|(
name|id
argument_list|,
name|IPI_AST
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * When called the executing CPU will send an IPI to all other CPUs  *  requesting that they halt execution.  *  * Usually (but not necessarily) called with 'other_cpus' as its arg.  *  *  - Signals all CPUs in map to stop.  *  - Waits for each to stop.  *  * Returns:  *  -1: error  *   0: NA  *   1: ok  *  */
end_comment

begin_function
specifier|static
name|int
name|generic_stop_cpus
parameter_list|(
name|cpuset_t
name|map
parameter_list|,
name|u_int
name|type
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|KTR
name|char
name|cpusetbuf
index|[
name|CPUSETBUFSIZ
index|]
decl_stmt|;
endif|#
directive|endif
specifier|static
specifier|volatile
name|u_int
name|stopping_cpu
init|=
name|NOCPU
decl_stmt|;
name|int
name|i
decl_stmt|;
specifier|volatile
name|cpuset_t
modifier|*
name|cpus
decl_stmt|;
name|KASSERT
argument_list|(
if|#
directive|if
name|defined
argument_list|(
name|__amd64__
argument_list|)
operator|||
name|defined
argument_list|(
name|__i386__
argument_list|)
name|type
operator|==
name|IPI_STOP
operator|||
name|type
operator|==
name|IPI_STOP_HARD
operator|||
name|type
operator|==
name|IPI_SUSPEND
argument_list|,
else|#
directive|else
name|type
operator|==
name|IPI_STOP
operator|||
name|type
operator|==
name|IPI_STOP_HARD
argument_list|,
endif|#
directive|endif
operator|(
literal|"%s: invalid stop type"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|smp_started
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|CTR2
argument_list|(
name|KTR_SMP
argument_list|,
literal|"stop_cpus(%s) with %u type"
argument_list|,
name|cpusetobj_strprint
argument_list|(
name|cpusetbuf
argument_list|,
operator|&
name|map
argument_list|)
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__amd64__
argument_list|)
operator|||
name|defined
argument_list|(
name|__i386__
argument_list|)
comment|/* 	 * When suspending, ensure there are are no IPIs in progress. 	 * IPIs that have been issued, but not yet delivered (e.g. 	 * not pending on a vCPU when running under virtualization) 	 * will be lost, violating FreeBSD's assumption of reliable 	 * IPI delivery. 	 */
if|if
condition|(
name|type
operator|==
name|IPI_SUSPEND
condition|)
name|mtx_lock_spin
argument_list|(
operator|&
name|smp_ipi_mtx
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|stopping_cpu
operator|!=
name|PCPU_GET
argument_list|(
name|cpuid
argument_list|)
condition|)
while|while
condition|(
name|atomic_cmpset_int
argument_list|(
operator|&
name|stopping_cpu
argument_list|,
name|NOCPU
argument_list|,
name|PCPU_GET
argument_list|(
name|cpuid
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
while|while
condition|(
name|stopping_cpu
operator|!=
name|NOCPU
condition|)
name|cpu_spinwait
argument_list|()
expr_stmt|;
comment|/* spin */
comment|/* send the stop IPI to all CPUs in map */
name|ipi_selected
argument_list|(
name|map
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__amd64__
argument_list|)
operator|||
name|defined
argument_list|(
name|__i386__
argument_list|)
if|if
condition|(
name|type
operator|==
name|IPI_SUSPEND
condition|)
name|cpus
operator|=
operator|&
name|suspended_cpus
expr_stmt|;
else|else
endif|#
directive|endif
name|cpus
operator|=
operator|&
name|stopped_cpus
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|!
name|CPU_SUBSET
argument_list|(
name|cpus
argument_list|,
operator|&
name|map
argument_list|)
condition|)
block|{
comment|/* spin */
name|cpu_spinwait
argument_list|()
expr_stmt|;
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|100000000
condition|)
block|{
name|printf
argument_list|(
literal|"timeout stopping cpus\n"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|#
directive|if
name|defined
argument_list|(
name|__amd64__
argument_list|)
operator|||
name|defined
argument_list|(
name|__i386__
argument_list|)
if|if
condition|(
name|type
operator|==
name|IPI_SUSPEND
condition|)
name|mtx_unlock_spin
argument_list|(
operator|&
name|smp_ipi_mtx
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|stopping_cpu
operator|=
name|NOCPU
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|int
name|stop_cpus
parameter_list|(
name|cpuset_t
name|map
parameter_list|)
block|{
return|return
operator|(
name|generic_stop_cpus
argument_list|(
name|map
argument_list|,
name|IPI_STOP
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|stop_cpus_hard
parameter_list|(
name|cpuset_t
name|map
parameter_list|)
block|{
return|return
operator|(
name|generic_stop_cpus
argument_list|(
name|map
argument_list|,
name|IPI_STOP_HARD
argument_list|)
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__amd64__
argument_list|)
operator|||
name|defined
argument_list|(
name|__i386__
argument_list|)
end_if

begin_function
name|int
name|suspend_cpus
parameter_list|(
name|cpuset_t
name|map
parameter_list|)
block|{
return|return
operator|(
name|generic_stop_cpus
argument_list|(
name|map
argument_list|,
name|IPI_SUSPEND
argument_list|)
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Called by a CPU to restart stopped CPUs.   *  * Usually (but not necessarily) called with 'stopped_cpus' as its arg.  *  *  - Signals all CPUs in map to restart.  *  - Waits for each to restart.  *  * Returns:  *  -1: error  *   0: NA  *   1: ok  */
end_comment

begin_function
specifier|static
name|int
name|generic_restart_cpus
parameter_list|(
name|cpuset_t
name|map
parameter_list|,
name|u_int
name|type
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|KTR
name|char
name|cpusetbuf
index|[
name|CPUSETBUFSIZ
index|]
decl_stmt|;
endif|#
directive|endif
specifier|volatile
name|cpuset_t
modifier|*
name|cpus
decl_stmt|;
name|KASSERT
argument_list|(
if|#
directive|if
name|defined
argument_list|(
name|__amd64__
argument_list|)
operator|||
name|defined
argument_list|(
name|__i386__
argument_list|)
name|type
operator|==
name|IPI_STOP
operator|||
name|type
operator|==
name|IPI_STOP_HARD
operator|||
name|type
operator|==
name|IPI_SUSPEND
argument_list|,
else|#
directive|else
name|type
operator|==
name|IPI_STOP
operator|||
name|type
operator|==
name|IPI_STOP_HARD
argument_list|,
endif|#
directive|endif
operator|(
literal|"%s: invalid stop type"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|smp_started
condition|)
return|return
literal|0
return|;
name|CTR1
argument_list|(
name|KTR_SMP
argument_list|,
literal|"restart_cpus(%s)"
argument_list|,
name|cpusetobj_strprint
argument_list|(
name|cpusetbuf
argument_list|,
operator|&
name|map
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__amd64__
argument_list|)
operator|||
name|defined
argument_list|(
name|__i386__
argument_list|)
if|if
condition|(
name|type
operator|==
name|IPI_SUSPEND
condition|)
name|cpus
operator|=
operator|&
name|suspended_cpus
expr_stmt|;
else|else
endif|#
directive|endif
name|cpus
operator|=
operator|&
name|stopped_cpus
expr_stmt|;
comment|/* signal other cpus to restart */
name|CPU_COPY_STORE_REL
argument_list|(
operator|&
name|map
argument_list|,
operator|&
name|started_cpus
argument_list|)
expr_stmt|;
comment|/* wait for each to clear its bit */
while|while
condition|(
name|CPU_OVERLAP
argument_list|(
name|cpus
argument_list|,
operator|&
name|map
argument_list|)
condition|)
name|cpu_spinwait
argument_list|()
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
name|int
name|restart_cpus
parameter_list|(
name|cpuset_t
name|map
parameter_list|)
block|{
return|return
operator|(
name|generic_restart_cpus
argument_list|(
name|map
argument_list|,
name|IPI_STOP
argument_list|)
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__amd64__
argument_list|)
operator|||
name|defined
argument_list|(
name|__i386__
argument_list|)
end_if

begin_function
name|int
name|resume_cpus
parameter_list|(
name|cpuset_t
name|map
parameter_list|)
block|{
return|return
operator|(
name|generic_restart_cpus
argument_list|(
name|map
argument_list|,
name|IPI_SUSPEND
argument_list|)
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * All-CPU rendezvous.  CPUs are signalled, all execute the setup function   * (if specified), rendezvous, execute the action function (if specified),  * rendezvous again, execute the teardown function (if specified), and then  * resume.  *  * Note that the supplied external functions _must_ be reentrant and aware  * that they are running in parallel and in an unknown lock context.  */
end_comment

begin_function
name|void
name|smp_rendezvous_action
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|void
modifier|*
name|local_func_arg
decl_stmt|;
name|void
function_decl|(
modifier|*
name|local_setup_func
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
name|void
function_decl|(
modifier|*
name|local_action_func
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
name|void
function_decl|(
modifier|*
name|local_teardown_func
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
ifdef|#
directive|ifdef
name|INVARIANTS
name|int
name|owepreempt
decl_stmt|;
endif|#
directive|endif
comment|/* Ensure we have up-to-date values. */
name|atomic_add_acq_int
argument_list|(
operator|&
name|smp_rv_waiters
index|[
literal|0
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
while|while
condition|(
name|smp_rv_waiters
index|[
literal|0
index|]
operator|<
name|smp_rv_ncpus
condition|)
name|cpu_spinwait
argument_list|()
expr_stmt|;
comment|/* Fetch rendezvous parameters after acquire barrier. */
name|local_func_arg
operator|=
name|smp_rv_func_arg
expr_stmt|;
name|local_setup_func
operator|=
name|smp_rv_setup_func
expr_stmt|;
name|local_action_func
operator|=
name|smp_rv_action_func
expr_stmt|;
name|local_teardown_func
operator|=
name|smp_rv_teardown_func
expr_stmt|;
comment|/* 	 * Use a nested critical section to prevent any preemptions 	 * from occurring during a rendezvous action routine. 	 * Specifically, if a rendezvous handler is invoked via an IPI 	 * and the interrupted thread was in the critical_exit() 	 * function after setting td_critnest to 0 but before 	 * performing a deferred preemption, this routine can be 	 * invoked with td_critnest set to 0 and td_owepreempt true. 	 * In that case, a critical_exit() during the rendezvous 	 * action would trigger a preemption which is not permitted in 	 * a rendezvous action.  To fix this, wrap all of the 	 * rendezvous action handlers in a critical section.  We 	 * cannot use a regular critical section however as having 	 * critical_exit() preempt from this routine would also be 	 * problematic (the preemption must not occur before the IPI 	 * has been acknowledged via an EOI).  Instead, we 	 * intentionally ignore td_owepreempt when leaving the 	 * critical section.  This should be harmless because we do 	 * not permit rendezvous action routines to schedule threads, 	 * and thus td_owepreempt should never transition from 0 to 1 	 * during this routine. 	 */
name|td
operator|=
name|curthread
expr_stmt|;
name|td
operator|->
name|td_critnest
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|INVARIANTS
name|owepreempt
operator|=
name|td
operator|->
name|td_owepreempt
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * If requested, run a setup function before the main action 	 * function.  Ensure all CPUs have completed the setup 	 * function before moving on to the action function. 	 */
if|if
condition|(
name|local_setup_func
operator|!=
name|smp_no_rendevous_barrier
condition|)
block|{
if|if
condition|(
name|smp_rv_setup_func
operator|!=
name|NULL
condition|)
name|smp_rv_setup_func
argument_list|(
name|smp_rv_func_arg
argument_list|)
expr_stmt|;
name|atomic_add_int
argument_list|(
operator|&
name|smp_rv_waiters
index|[
literal|1
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
while|while
condition|(
name|smp_rv_waiters
index|[
literal|1
index|]
operator|<
name|smp_rv_ncpus
condition|)
name|cpu_spinwait
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|local_action_func
operator|!=
name|NULL
condition|)
name|local_action_func
argument_list|(
name|local_func_arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|local_teardown_func
operator|!=
name|smp_no_rendevous_barrier
condition|)
block|{
comment|/* 		 * Signal that the main action has been completed.  If a 		 * full exit rendezvous is requested, then all CPUs will 		 * wait here until all CPUs have finished the main action. 		 */
name|atomic_add_int
argument_list|(
operator|&
name|smp_rv_waiters
index|[
literal|2
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
while|while
condition|(
name|smp_rv_waiters
index|[
literal|2
index|]
operator|<
name|smp_rv_ncpus
condition|)
name|cpu_spinwait
argument_list|()
expr_stmt|;
if|if
condition|(
name|local_teardown_func
operator|!=
name|NULL
condition|)
name|local_teardown_func
argument_list|(
name|local_func_arg
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Signal that the rendezvous is fully completed by this CPU. 	 * This means that no member of smp_rv_* pseudo-structure will be 	 * accessed by this target CPU after this point; in particular, 	 * memory pointed by smp_rv_func_arg. 	 */
name|atomic_add_int
argument_list|(
operator|&
name|smp_rv_waiters
index|[
literal|3
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|td
operator|->
name|td_critnest
operator|--
expr_stmt|;
name|KASSERT
argument_list|(
name|owepreempt
operator|==
name|td
operator|->
name|td_owepreempt
argument_list|,
operator|(
literal|"rendezvous action changed td_owepreempt"
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|smp_rendezvous_cpus
parameter_list|(
name|cpuset_t
name|map
parameter_list|,
name|void
function_decl|(
modifier|*
name|setup_func
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
function_decl|(
modifier|*
name|action_func
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
function_decl|(
modifier|*
name|teardown_func
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|int
name|curcpumap
decl_stmt|,
name|i
decl_stmt|,
name|ncpus
init|=
literal|0
decl_stmt|;
comment|/* Look comments in the !SMP case. */
if|if
condition|(
operator|!
name|smp_started
condition|)
block|{
name|spinlock_enter
argument_list|()
expr_stmt|;
if|if
condition|(
name|setup_func
operator|!=
name|NULL
condition|)
name|setup_func
argument_list|(
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|action_func
operator|!=
name|NULL
condition|)
name|action_func
argument_list|(
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|teardown_func
operator|!=
name|NULL
condition|)
name|teardown_func
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|spinlock_exit
argument_list|()
expr_stmt|;
return|return;
block|}
name|CPU_FOREACH
argument_list|(
argument|i
argument_list|)
block|{
if|if
condition|(
name|CPU_ISSET
argument_list|(
name|i
argument_list|,
operator|&
name|map
argument_list|)
condition|)
name|ncpus
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|ncpus
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"ncpus is 0 with non-zero map"
argument_list|)
expr_stmt|;
name|mtx_lock_spin
argument_list|(
operator|&
name|smp_ipi_mtx
argument_list|)
expr_stmt|;
comment|/* Pass rendezvous parameters via global variables. */
name|smp_rv_ncpus
operator|=
name|ncpus
expr_stmt|;
name|smp_rv_setup_func
operator|=
name|setup_func
expr_stmt|;
name|smp_rv_action_func
operator|=
name|action_func
expr_stmt|;
name|smp_rv_teardown_func
operator|=
name|teardown_func
expr_stmt|;
name|smp_rv_func_arg
operator|=
name|arg
expr_stmt|;
name|smp_rv_waiters
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|smp_rv_waiters
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|smp_rv_waiters
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
name|atomic_store_rel_int
argument_list|(
operator|&
name|smp_rv_waiters
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Signal other processors, which will enter the IPI with 	 * interrupts off. 	 */
name|curcpumap
operator|=
name|CPU_ISSET
argument_list|(
name|curcpu
argument_list|,
operator|&
name|map
argument_list|)
expr_stmt|;
name|CPU_CLR
argument_list|(
name|curcpu
argument_list|,
operator|&
name|map
argument_list|)
expr_stmt|;
name|ipi_selected
argument_list|(
name|map
argument_list|,
name|IPI_RENDEZVOUS
argument_list|)
expr_stmt|;
comment|/* Check if the current CPU is in the map */
if|if
condition|(
name|curcpumap
operator|!=
literal|0
condition|)
name|smp_rendezvous_action
argument_list|()
expr_stmt|;
comment|/* 	 * Ensure that the master CPU waits for all the other 	 * CPUs to finish the rendezvous, so that smp_rv_* 	 * pseudo-structure and the arg are guaranteed to not 	 * be in use. 	 */
while|while
condition|(
name|atomic_load_acq_int
argument_list|(
operator|&
name|smp_rv_waiters
index|[
literal|3
index|]
argument_list|)
operator|<
name|ncpus
condition|)
name|cpu_spinwait
argument_list|()
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|smp_ipi_mtx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|smp_rendezvous
parameter_list|(
name|void
function_decl|(
modifier|*
name|setup_func
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
function_decl|(
modifier|*
name|action_func
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
function_decl|(
modifier|*
name|teardown_func
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|smp_rendezvous_cpus
argument_list|(
name|all_cpus
argument_list|,
name|setup_func
argument_list|,
name|action_func
argument_list|,
name|teardown_func
argument_list|,
name|arg
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|cpu_group
name|group
index|[
name|MAXCPU
index|]
decl_stmt|;
end_decl_stmt

begin_function
name|struct
name|cpu_group
modifier|*
name|smp_topo
parameter_list|(
name|void
parameter_list|)
block|{
name|char
name|cpusetbuf
index|[
name|CPUSETBUFSIZ
index|]
decl_stmt|,
name|cpusetbuf2
index|[
name|CPUSETBUFSIZ
index|]
decl_stmt|;
name|struct
name|cpu_group
modifier|*
name|top
decl_stmt|;
comment|/* 	 * Check for a fake topology request for debugging purposes. 	 */
switch|switch
condition|(
name|smp_topology
condition|)
block|{
case|case
literal|1
case|:
comment|/* Dual core with no sharing.  */
name|top
operator|=
name|smp_topo_1level
argument_list|(
name|CG_SHARE_NONE
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
comment|/* No topology, all cpus are equal. */
name|top
operator|=
name|smp_topo_none
argument_list|()
expr_stmt|;
break|break;
case|case
literal|3
case|:
comment|/* Dual core with shared L2.  */
name|top
operator|=
name|smp_topo_1level
argument_list|(
name|CG_SHARE_L2
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|4
case|:
comment|/* quad core, shared l3 among each package, private l2.  */
name|top
operator|=
name|smp_topo_1level
argument_list|(
name|CG_SHARE_L3
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|5
case|:
comment|/* quad core,  2 dualcore parts on each package share l2.  */
name|top
operator|=
name|smp_topo_2level
argument_list|(
name|CG_SHARE_NONE
argument_list|,
literal|2
argument_list|,
name|CG_SHARE_L2
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|6
case|:
comment|/* Single-core 2xHTT */
name|top
operator|=
name|smp_topo_1level
argument_list|(
name|CG_SHARE_L1
argument_list|,
literal|2
argument_list|,
name|CG_FLAG_HTT
argument_list|)
expr_stmt|;
break|break;
case|case
literal|7
case|:
comment|/* quad core with a shared l3, 8 threads sharing L2.  */
name|top
operator|=
name|smp_topo_2level
argument_list|(
name|CG_SHARE_L3
argument_list|,
literal|4
argument_list|,
name|CG_SHARE_L2
argument_list|,
literal|8
argument_list|,
name|CG_FLAG_SMT
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* Default, ask the system what it wants. */
name|top
operator|=
name|cpu_topo
argument_list|()
expr_stmt|;
break|break;
block|}
comment|/* 	 * Verify the returned topology. 	 */
if|if
condition|(
name|top
operator|->
name|cg_count
operator|!=
name|mp_ncpus
condition|)
name|panic
argument_list|(
literal|"Built bad topology at %p.  CPU count %d != %d"
argument_list|,
name|top
argument_list|,
name|top
operator|->
name|cg_count
argument_list|,
name|mp_ncpus
argument_list|)
expr_stmt|;
if|if
condition|(
name|CPU_CMP
argument_list|(
operator|&
name|top
operator|->
name|cg_mask
argument_list|,
operator|&
name|all_cpus
argument_list|)
condition|)
name|panic
argument_list|(
literal|"Built bad topology at %p.  CPU mask (%s) != (%s)"
argument_list|,
name|top
argument_list|,
name|cpusetobj_strprint
argument_list|(
name|cpusetbuf
argument_list|,
operator|&
name|top
operator|->
name|cg_mask
argument_list|)
argument_list|,
name|cpusetobj_strprint
argument_list|(
name|cpusetbuf2
argument_list|,
operator|&
name|all_cpus
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|top
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|cpu_group
modifier|*
name|smp_topo_none
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|cpu_group
modifier|*
name|top
decl_stmt|;
name|top
operator|=
operator|&
name|group
index|[
literal|0
index|]
expr_stmt|;
name|top
operator|->
name|cg_parent
operator|=
name|NULL
expr_stmt|;
name|top
operator|->
name|cg_child
operator|=
name|NULL
expr_stmt|;
name|top
operator|->
name|cg_mask
operator|=
name|all_cpus
expr_stmt|;
name|top
operator|->
name|cg_count
operator|=
name|mp_ncpus
expr_stmt|;
name|top
operator|->
name|cg_children
operator|=
literal|0
expr_stmt|;
name|top
operator|->
name|cg_level
operator|=
name|CG_SHARE_NONE
expr_stmt|;
name|top
operator|->
name|cg_flags
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|top
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|smp_topo_addleaf
parameter_list|(
name|struct
name|cpu_group
modifier|*
name|parent
parameter_list|,
name|struct
name|cpu_group
modifier|*
name|child
parameter_list|,
name|int
name|share
parameter_list|,
name|int
name|count
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|start
parameter_list|)
block|{
name|char
name|cpusetbuf
index|[
name|CPUSETBUFSIZ
index|]
decl_stmt|,
name|cpusetbuf2
index|[
name|CPUSETBUFSIZ
index|]
decl_stmt|;
name|cpuset_t
name|mask
decl_stmt|;
name|int
name|i
decl_stmt|;
name|CPU_ZERO
argument_list|(
operator|&
name|mask
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
operator|,
name|start
operator|++
control|)
name|CPU_SET
argument_list|(
name|start
argument_list|,
operator|&
name|mask
argument_list|)
expr_stmt|;
name|child
operator|->
name|cg_parent
operator|=
name|parent
expr_stmt|;
name|child
operator|->
name|cg_child
operator|=
name|NULL
expr_stmt|;
name|child
operator|->
name|cg_children
operator|=
literal|0
expr_stmt|;
name|child
operator|->
name|cg_level
operator|=
name|share
expr_stmt|;
name|child
operator|->
name|cg_count
operator|=
name|count
expr_stmt|;
name|child
operator|->
name|cg_flags
operator|=
name|flags
expr_stmt|;
name|child
operator|->
name|cg_mask
operator|=
name|mask
expr_stmt|;
name|parent
operator|->
name|cg_children
operator|++
expr_stmt|;
for|for
control|(
init|;
name|parent
operator|!=
name|NULL
condition|;
name|parent
operator|=
name|parent
operator|->
name|cg_parent
control|)
block|{
if|if
condition|(
name|CPU_OVERLAP
argument_list|(
operator|&
name|parent
operator|->
name|cg_mask
argument_list|,
operator|&
name|child
operator|->
name|cg_mask
argument_list|)
condition|)
name|panic
argument_list|(
literal|"Duplicate children in %p.  mask (%s) child (%s)"
argument_list|,
name|parent
argument_list|,
name|cpusetobj_strprint
argument_list|(
name|cpusetbuf
argument_list|,
operator|&
name|parent
operator|->
name|cg_mask
argument_list|)
argument_list|,
name|cpusetobj_strprint
argument_list|(
name|cpusetbuf2
argument_list|,
operator|&
name|child
operator|->
name|cg_mask
argument_list|)
argument_list|)
expr_stmt|;
name|CPU_OR
argument_list|(
operator|&
name|parent
operator|->
name|cg_mask
argument_list|,
operator|&
name|child
operator|->
name|cg_mask
argument_list|)
expr_stmt|;
name|parent
operator|->
name|cg_count
operator|+=
name|child
operator|->
name|cg_count
expr_stmt|;
block|}
return|return
operator|(
name|start
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|cpu_group
modifier|*
name|smp_topo_1level
parameter_list|(
name|int
name|share
parameter_list|,
name|int
name|count
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|cpu_group
modifier|*
name|child
decl_stmt|;
name|struct
name|cpu_group
modifier|*
name|top
decl_stmt|;
name|int
name|packages
decl_stmt|;
name|int
name|cpu
decl_stmt|;
name|int
name|i
decl_stmt|;
name|cpu
operator|=
literal|0
expr_stmt|;
name|top
operator|=
operator|&
name|group
index|[
literal|0
index|]
expr_stmt|;
name|packages
operator|=
name|mp_ncpus
operator|/
name|count
expr_stmt|;
name|top
operator|->
name|cg_child
operator|=
name|child
operator|=
operator|&
name|group
index|[
literal|1
index|]
expr_stmt|;
name|top
operator|->
name|cg_level
operator|=
name|CG_SHARE_NONE
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|packages
condition|;
name|i
operator|++
operator|,
name|child
operator|++
control|)
name|cpu
operator|=
name|smp_topo_addleaf
argument_list|(
name|top
argument_list|,
name|child
argument_list|,
name|share
argument_list|,
name|count
argument_list|,
name|flags
argument_list|,
name|cpu
argument_list|)
expr_stmt|;
return|return
operator|(
name|top
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|cpu_group
modifier|*
name|smp_topo_2level
parameter_list|(
name|int
name|l2share
parameter_list|,
name|int
name|l2count
parameter_list|,
name|int
name|l1share
parameter_list|,
name|int
name|l1count
parameter_list|,
name|int
name|l1flags
parameter_list|)
block|{
name|struct
name|cpu_group
modifier|*
name|top
decl_stmt|;
name|struct
name|cpu_group
modifier|*
name|l1g
decl_stmt|;
name|struct
name|cpu_group
modifier|*
name|l2g
decl_stmt|;
name|int
name|cpu
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|j
decl_stmt|;
name|cpu
operator|=
literal|0
expr_stmt|;
name|top
operator|=
operator|&
name|group
index|[
literal|0
index|]
expr_stmt|;
name|l2g
operator|=
operator|&
name|group
index|[
literal|1
index|]
expr_stmt|;
name|top
operator|->
name|cg_child
operator|=
name|l2g
expr_stmt|;
name|top
operator|->
name|cg_level
operator|=
name|CG_SHARE_NONE
expr_stmt|;
name|top
operator|->
name|cg_children
operator|=
name|mp_ncpus
operator|/
operator|(
name|l2count
operator|*
name|l1count
operator|)
expr_stmt|;
name|l1g
operator|=
name|l2g
operator|+
name|top
operator|->
name|cg_children
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|top
operator|->
name|cg_children
condition|;
name|i
operator|++
operator|,
name|l2g
operator|++
control|)
block|{
name|l2g
operator|->
name|cg_parent
operator|=
name|top
expr_stmt|;
name|l2g
operator|->
name|cg_child
operator|=
name|l1g
expr_stmt|;
name|l2g
operator|->
name|cg_level
operator|=
name|l2share
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|l2count
condition|;
name|j
operator|++
operator|,
name|l1g
operator|++
control|)
name|cpu
operator|=
name|smp_topo_addleaf
argument_list|(
name|l2g
argument_list|,
name|l1g
argument_list|,
name|l1share
argument_list|,
name|l1count
argument_list|,
name|l1flags
argument_list|,
name|cpu
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|top
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|cpu_group
modifier|*
name|smp_topo_find
parameter_list|(
name|struct
name|cpu_group
modifier|*
name|top
parameter_list|,
name|int
name|cpu
parameter_list|)
block|{
name|struct
name|cpu_group
modifier|*
name|cg
decl_stmt|;
name|cpuset_t
name|mask
decl_stmt|;
name|int
name|children
decl_stmt|;
name|int
name|i
decl_stmt|;
name|CPU_SETOF
argument_list|(
name|cpu
argument_list|,
operator|&
name|mask
argument_list|)
expr_stmt|;
name|cg
operator|=
name|top
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|!
name|CPU_OVERLAP
argument_list|(
operator|&
name|cg
operator|->
name|cg_mask
argument_list|,
operator|&
name|mask
argument_list|)
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
name|cg
operator|->
name|cg_children
operator|==
literal|0
condition|)
return|return
operator|(
name|cg
operator|)
return|;
name|children
operator|=
name|cg
operator|->
name|cg_children
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|cg
operator|=
name|cg
operator|->
name|cg_child
init|;
name|i
operator|<
name|children
condition|;
name|cg
operator|++
operator|,
name|i
operator|++
control|)
if|if
condition|(
name|CPU_OVERLAP
argument_list|(
operator|&
name|cg
operator|->
name|cg_mask
argument_list|,
operator|&
name|mask
argument_list|)
condition|)
break|break;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* !SMP */
end_comment

begin_function
name|void
name|smp_rendezvous_cpus
parameter_list|(
name|cpuset_t
name|map
parameter_list|,
name|void
function_decl|(
modifier|*
name|setup_func
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
function_decl|(
modifier|*
name|action_func
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
function_decl|(
modifier|*
name|teardown_func
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
comment|/* 	 * In the !SMP case we just need to ensure the same initial conditions 	 * as the SMP case. 	 */
name|spinlock_enter
argument_list|()
expr_stmt|;
if|if
condition|(
name|setup_func
operator|!=
name|NULL
condition|)
name|setup_func
argument_list|(
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|action_func
operator|!=
name|NULL
condition|)
name|action_func
argument_list|(
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|teardown_func
operator|!=
name|NULL
condition|)
name|teardown_func
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|spinlock_exit
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|smp_rendezvous
parameter_list|(
name|void
function_decl|(
modifier|*
name|setup_func
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
function_decl|(
modifier|*
name|action_func
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
function_decl|(
modifier|*
name|teardown_func
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
comment|/* Look comments in the smp_rendezvous_cpus() case. */
name|spinlock_enter
argument_list|()
expr_stmt|;
if|if
condition|(
name|setup_func
operator|!=
name|NULL
condition|)
name|setup_func
argument_list|(
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|action_func
operator|!=
name|NULL
condition|)
name|action_func
argument_list|(
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|teardown_func
operator|!=
name|NULL
condition|)
name|teardown_func
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|spinlock_exit
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Provide dummy SMP support for UP kernels.  Modules that need to use SMP  * APIs will still work using this dummy support.  */
end_comment

begin_function
specifier|static
name|void
name|mp_setvariables_for_up
parameter_list|(
name|void
modifier|*
name|dummy
parameter_list|)
block|{
name|mp_ncpus
operator|=
literal|1
expr_stmt|;
name|mp_maxid
operator|=
name|PCPU_GET
argument_list|(
name|cpuid
argument_list|)
expr_stmt|;
name|CPU_SETOF
argument_list|(
name|mp_maxid
argument_list|,
operator|&
name|all_cpus
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|PCPU_GET
argument_list|(
name|cpuid
argument_list|)
operator|==
literal|0
argument_list|,
operator|(
literal|"UP must have a CPU ID of zero"
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|SYSINIT
argument_list|(
name|cpu_mp_setvariables
argument_list|,
name|SI_SUB_TUNABLES
argument_list|,
name|SI_ORDER_FIRST
argument_list|,
name|mp_setvariables_for_up
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SMP */
end_comment

begin_function
name|void
name|smp_no_rendevous_barrier
parameter_list|(
name|void
modifier|*
name|dummy
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|SMP
name|KASSERT
argument_list|(
operator|(
operator|!
name|smp_started
operator|)
argument_list|,
operator|(
literal|"smp_no_rendevous called and smp is started"
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * Wait specified idle threads to switch once.  This ensures that even  * preempted threads have cycled through the switch function once,  * exiting their codepaths.  This allows us to change global pointers  * with no other synchronization.  */
end_comment

begin_function
name|int
name|quiesce_cpus
parameter_list|(
name|cpuset_t
name|map
parameter_list|,
specifier|const
name|char
modifier|*
name|wmesg
parameter_list|,
name|int
name|prio
parameter_list|)
block|{
name|struct
name|pcpu
modifier|*
name|pcpu
decl_stmt|;
name|u_int
name|gen
index|[
name|MAXCPU
index|]
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|cpu
decl_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|cpu
operator|=
literal|0
init|;
name|cpu
operator|<=
name|mp_maxid
condition|;
name|cpu
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|CPU_ISSET
argument_list|(
name|cpu
argument_list|,
operator|&
name|map
argument_list|)
operator|||
name|CPU_ABSENT
argument_list|(
name|cpu
argument_list|)
condition|)
continue|continue;
name|pcpu
operator|=
name|pcpu_find
argument_list|(
name|cpu
argument_list|)
expr_stmt|;
name|gen
index|[
name|cpu
index|]
operator|=
name|pcpu
operator|->
name|pc_idlethread
operator|->
name|td_generation
expr_stmt|;
block|}
for|for
control|(
name|cpu
operator|=
literal|0
init|;
name|cpu
operator|<=
name|mp_maxid
condition|;
name|cpu
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|CPU_ISSET
argument_list|(
name|cpu
argument_list|,
operator|&
name|map
argument_list|)
operator|||
name|CPU_ABSENT
argument_list|(
name|cpu
argument_list|)
condition|)
continue|continue;
name|pcpu
operator|=
name|pcpu_find
argument_list|(
name|cpu
argument_list|)
expr_stmt|;
name|thread_lock
argument_list|(
name|curthread
argument_list|)
expr_stmt|;
name|sched_bind
argument_list|(
name|curthread
argument_list|,
name|cpu
argument_list|)
expr_stmt|;
name|thread_unlock
argument_list|(
name|curthread
argument_list|)
expr_stmt|;
while|while
condition|(
name|gen
index|[
name|cpu
index|]
operator|==
name|pcpu
operator|->
name|pc_idlethread
operator|->
name|td_generation
condition|)
block|{
name|error
operator|=
name|tsleep
argument_list|(
name|quiesce_cpus
argument_list|,
name|prio
argument_list|,
name|wmesg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
name|EWOULDBLOCK
condition|)
goto|goto
name|out
goto|;
name|error
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|out
label|:
name|thread_lock
argument_list|(
name|curthread
argument_list|)
expr_stmt|;
name|sched_unbind
argument_list|(
name|curthread
argument_list|)
expr_stmt|;
name|thread_unlock
argument_list|(
name|curthread
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|quiesce_all_cpus
parameter_list|(
specifier|const
name|char
modifier|*
name|wmesg
parameter_list|,
name|int
name|prio
parameter_list|)
block|{
return|return
name|quiesce_cpus
argument_list|(
name|all_cpus
argument_list|,
name|wmesg
argument_list|,
name|prio
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Extra care is taken with this sysctl because the data type is volatile */
end_comment

begin_function
specifier|static
name|int
name|sysctl_kern_smp_active
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|int
name|error
decl_stmt|,
name|active
decl_stmt|;
name|active
operator|=
name|smp_started
expr_stmt|;
name|error
operator|=
name|SYSCTL_OUT
argument_list|(
name|req
argument_list|,
operator|&
name|active
argument_list|,
sizeof|sizeof
argument_list|(
name|active
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

end_unit

