begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2001-2002 Luigi Rizzo  *  * Supported by: the Xorp Project (www.xorp.org)  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHORS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"opt_device_polling.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_comment
comment|/* needed by net/if.h		*/
end_comment

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/syslog.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_comment
comment|/* for IFF_* flags		*/
end_comment

begin_include
include|#
directive|include
file|<net/netisr.h>
end_include

begin_comment
comment|/* for NETISR_POLL		*/
end_comment

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/resourcevar.h>
end_include

begin_include
include|#
directive|include
file|<sys/kthread.h>
end_include

begin_function_decl
specifier|static
name|void
name|netisr_poll
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* the two netisr handlers      */
end_comment

begin_function_decl
specifier|static
name|void
name|netisr_pollmore
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|poll_switch
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|hardclock_device_poll
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* hook from hardclock		*/
end_comment

begin_function_decl
name|void
name|ether_poll
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* polling in idle loop		*/
end_comment

begin_decl_stmt
specifier|static
name|struct
name|mtx
name|poll_mtx
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Polling support for [network] device drivers.  *  * Drivers which support this feature can register with the  * polling code.  *  * If registration is successful, the driver must disable interrupts,  * and further I/O is performed through the handler, which is invoked  * (at least once per clock tick) with 3 arguments: the "arg" passed at  * register time (a struct ifnet pointer), a command, and a "count" limit.  *  * The command can be one of the following:  *  POLL_ONLY: quick move of "count" packets from input/output queues.  *  POLL_AND_CHECK_STATUS: as above, plus check status registers or do  *	other more expensive operations. This command is issued periodically  *	but less frequently than POLL_ONLY.  *  * The count limit specifies how much work the handler can do during the  * call -- typically this is the number of packets to be received, or  * transmitted, etc. (drivers are free to interpret this number, as long  * as the max time spent in the function grows roughly linearly with the  * count).  *  * Polling is enabled and disabled via setting IFCAP_POLLING flag on  * the interface. The driver ioctl handler should register interface  * with polling and disable interrupts, if registration was successful.  *  * A second variable controls the sharing of CPU between polling/kernel  * network processing, and other activities (typically userlevel tasks):  * kern.polling.user_frac (between 0 and 100, default 50) sets the share  * of CPU allocated to user tasks. CPU is allocated proportionally to the  * shares, by dynamically adjusting the "count" (poll_burst).  *  * Other parameters can should be left to their default values.  * The following constraints hold  *  *	1<= poll_each_burst<= poll_burst<= poll_burst_max  *	0<= poll_each_burst  *	MIN_POLL_BURST_MAX<= poll_burst_max<= MAX_POLL_BURST_MAX  */
end_comment

begin_define
define|#
directive|define
name|MIN_POLL_BURST_MAX
value|10
end_define

begin_define
define|#
directive|define
name|MAX_POLL_BURST_MAX
value|1000
end_define

begin_decl_stmt
specifier|static
name|uint32_t
name|poll_burst
init|=
literal|5
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|uint32_t
name|poll_burst_max
init|=
literal|150
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* good for 100Mbit net and HZ=1000 */
end_comment

begin_decl_stmt
specifier|static
name|uint32_t
name|poll_each_burst
init|=
literal|5
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_kern
argument_list|,
name|OID_AUTO
argument_list|,
name|polling
argument_list|,
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
literal|"Device polling parameters"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_kern_polling
argument_list|,
name|OID_AUTO
argument_list|,
name|burst
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|poll_burst
argument_list|,
literal|0
argument_list|,
literal|"Current polling burst size"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|int
name|poll_burst_max_sysctl
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|uint32_t
name|val
init|=
name|poll_burst_max
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|val
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
operator|!
name|req
operator|->
name|newptr
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|val
operator|<
name|MIN_POLL_BURST_MAX
operator|||
name|val
operator|>
name|MAX_POLL_BURST_MAX
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|mtx_lock
argument_list|(
operator|&
name|poll_mtx
argument_list|)
expr_stmt|;
name|poll_burst_max
operator|=
name|val
expr_stmt|;
if|if
condition|(
name|poll_burst
operator|>
name|poll_burst_max
condition|)
name|poll_burst
operator|=
name|poll_burst_max
expr_stmt|;
if|if
condition|(
name|poll_each_burst
operator|>
name|poll_burst_max
condition|)
name|poll_each_burst
operator|=
name|MIN_POLL_BURST_MAX
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|poll_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|SYSCTL_PROC
argument_list|(
name|_kern_polling
argument_list|,
name|OID_AUTO
argument_list|,
name|burst_max
argument_list|,
name|CTLTYPE_UINT
operator||
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|,
name|poll_burst_max_sysctl
argument_list|,
literal|"I"
argument_list|,
literal|"Max Polling burst size"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|int
name|poll_each_burst_sysctl
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|uint32_t
name|val
init|=
name|poll_each_burst
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|val
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
operator|!
name|req
operator|->
name|newptr
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|val
operator|<
literal|1
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|mtx_lock
argument_list|(
operator|&
name|poll_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|>
name|poll_burst_max
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|poll_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|poll_each_burst
operator|=
name|val
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|poll_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|SYSCTL_PROC
argument_list|(
name|_kern_polling
argument_list|,
name|OID_AUTO
argument_list|,
name|each_burst
argument_list|,
name|CTLTYPE_UINT
operator||
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|,
name|poll_each_burst_sysctl
argument_list|,
literal|"I"
argument_list|,
literal|"Max size of each burst"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|uint32_t
name|poll_in_idle_loop
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* do we poll in idle loop ? */
end_comment

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_kern_polling
argument_list|,
name|OID_AUTO
argument_list|,
name|idle_poll
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|poll_in_idle_loop
argument_list|,
literal|0
argument_list|,
literal|"Enable device polling in idle loop"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|uint32_t
name|user_frac
init|=
literal|50
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|user_frac_sysctl
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|uint32_t
name|val
init|=
name|user_frac
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|val
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
operator|!
name|req
operator|->
name|newptr
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|val
operator|<
literal|0
operator|||
name|val
operator|>
literal|99
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|mtx_lock
argument_list|(
operator|&
name|poll_mtx
argument_list|)
expr_stmt|;
name|user_frac
operator|=
name|val
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|poll_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|SYSCTL_PROC
argument_list|(
name|_kern_polling
argument_list|,
name|OID_AUTO
argument_list|,
name|user_frac
argument_list|,
name|CTLTYPE_UINT
operator||
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|,
name|user_frac_sysctl
argument_list|,
literal|"I"
argument_list|,
literal|"Desired user fraction of cpu time"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|uint32_t
name|reg_frac_count
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|uint32_t
name|reg_frac
init|=
literal|20
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|reg_frac_sysctl
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|uint32_t
name|val
init|=
name|reg_frac
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|val
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
operator|!
name|req
operator|->
name|newptr
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|val
operator|<
literal|1
operator|||
name|val
operator|>
name|hz
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|mtx_lock
argument_list|(
operator|&
name|poll_mtx
argument_list|)
expr_stmt|;
name|reg_frac
operator|=
name|val
expr_stmt|;
if|if
condition|(
name|reg_frac_count
operator|>=
name|reg_frac
condition|)
name|reg_frac_count
operator|=
literal|0
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|poll_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|SYSCTL_PROC
argument_list|(
name|_kern_polling
argument_list|,
name|OID_AUTO
argument_list|,
name|reg_frac
argument_list|,
name|CTLTYPE_UINT
operator||
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|,
name|reg_frac_sysctl
argument_list|,
literal|"I"
argument_list|,
literal|"Every this many cycles check registers"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|uint32_t
name|short_ticks
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_kern_polling
argument_list|,
name|OID_AUTO
argument_list|,
name|short_ticks
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|short_ticks
argument_list|,
literal|0
argument_list|,
literal|"Hardclock ticks shorter than they should be"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|uint32_t
name|lost_polls
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_kern_polling
argument_list|,
name|OID_AUTO
argument_list|,
name|lost_polls
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|lost_polls
argument_list|,
literal|0
argument_list|,
literal|"How many times we would have lost a poll tick"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|uint32_t
name|pending_polls
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_kern_polling
argument_list|,
name|OID_AUTO
argument_list|,
name|pending_polls
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|pending_polls
argument_list|,
literal|0
argument_list|,
literal|"Do we need to poll again"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|residual_burst
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_kern_polling
argument_list|,
name|OID_AUTO
argument_list|,
name|residual_burst
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|residual_burst
argument_list|,
literal|0
argument_list|,
literal|"# of residual cycles in burst"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|uint32_t
name|poll_handlers
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* next free entry in pr[]. */
end_comment

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_kern_polling
argument_list|,
name|OID_AUTO
argument_list|,
name|handlers
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|poll_handlers
argument_list|,
literal|0
argument_list|,
literal|"Number of registered poll handlers"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|polling
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_PROC
argument_list|(
name|_kern_polling
argument_list|,
name|OID_AUTO
argument_list|,
name|enable
argument_list|,
name|CTLTYPE_UINT
operator||
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|,
name|poll_switch
argument_list|,
literal|"I"
argument_list|,
literal|"Switch polling for all interfaces"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|uint32_t
name|phase
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_kern_polling
argument_list|,
name|OID_AUTO
argument_list|,
name|phase
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|phase
argument_list|,
literal|0
argument_list|,
literal|"Polling phase"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|uint32_t
name|suspect
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_kern_polling
argument_list|,
name|OID_AUTO
argument_list|,
name|suspect
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|suspect
argument_list|,
literal|0
argument_list|,
literal|"suspect event"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|uint32_t
name|stalled
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_kern_polling
argument_list|,
name|OID_AUTO
argument_list|,
name|stalled
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|stalled
argument_list|,
literal|0
argument_list|,
literal|"potential stalls"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|uint32_t
name|idlepoll_sleeping
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* idlepoll is sleeping */
end_comment

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_kern_polling
argument_list|,
name|OID_AUTO
argument_list|,
name|idlepoll_sleeping
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|idlepoll_sleeping
argument_list|,
literal|0
argument_list|,
literal|"idlepoll is sleeping"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|POLL_LIST_LEN
value|128
end_define

begin_struct
struct|struct
name|pollrec
block|{
name|poll_handler_t
modifier|*
name|handler
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|pollrec
name|pr
index|[
name|POLL_LIST_LEN
index|]
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|init_device_poll
parameter_list|(
name|void
parameter_list|)
block|{
name|mtx_init
argument_list|(
operator|&
name|poll_mtx
argument_list|,
literal|"polling"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|netisr_register
argument_list|(
name|NETISR_POLL
argument_list|,
operator|(
name|netisr_t
operator|*
operator|)
name|netisr_poll
argument_list|,
name|NULL
argument_list|,
name|NETISR_MPSAFE
argument_list|)
expr_stmt|;
name|netisr_register
argument_list|(
name|NETISR_POLLMORE
argument_list|,
operator|(
name|netisr_t
operator|*
operator|)
name|netisr_pollmore
argument_list|,
name|NULL
argument_list|,
name|NETISR_MPSAFE
argument_list|)
expr_stmt|;
block|}
end_function

begin_macro
name|SYSINIT
argument_list|(
argument|device_poll
argument_list|,
argument|SI_SUB_CLOCKS
argument_list|,
argument|SI_ORDER_MIDDLE
argument_list|,
argument|init_device_poll
argument_list|,
argument|NULL
argument_list|)
end_macro

begin_comment
comment|/*  * Hook from hardclock. Tries to schedule a netisr, but keeps track  * of lost ticks due to the previous handler taking too long.  * Normally, this should not happen, because polling handler should  * run for a short time. However, in some cases (e.g. when there are  * changes in link status etc.) the drivers take a very long time  * (even in the order of milliseconds) to reset and reconfigure the  * device, causing apparent lost polls.  *  * The first part of the code is just for debugging purposes, and tries  * to count how often hardclock ticks are shorter than they should,  * meaning either stray interrupts or delayed events.  */
end_comment

begin_function
name|void
name|hardclock_device_poll
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
name|struct
name|timeval
name|prev_t
decl_stmt|,
name|t
decl_stmt|;
name|int
name|delta
decl_stmt|;
if|if
condition|(
name|poll_handlers
operator|==
literal|0
condition|)
return|return;
name|microuptime
argument_list|(
operator|&
name|t
argument_list|)
expr_stmt|;
name|delta
operator|=
operator|(
name|t
operator|.
name|tv_usec
operator|-
name|prev_t
operator|.
name|tv_usec
operator|)
operator|+
operator|(
name|t
operator|.
name|tv_sec
operator|-
name|prev_t
operator|.
name|tv_sec
operator|)
operator|*
literal|1000000
expr_stmt|;
if|if
condition|(
name|delta
operator|*
name|hz
operator|<
literal|500000
condition|)
name|short_ticks
operator|++
expr_stmt|;
else|else
name|prev_t
operator|=
name|t
expr_stmt|;
if|if
condition|(
name|pending_polls
operator|>
literal|100
condition|)
block|{
comment|/* 		 * Too much, assume it has stalled (not always true 		 * see comment above). 		 */
name|stalled
operator|++
expr_stmt|;
name|pending_polls
operator|=
literal|0
expr_stmt|;
name|phase
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|phase
operator|<=
literal|2
condition|)
block|{
if|if
condition|(
name|phase
operator|!=
literal|0
condition|)
name|suspect
operator|++
expr_stmt|;
name|phase
operator|=
literal|1
expr_stmt|;
name|schednetisrbits
argument_list|(
literal|1
operator|<<
name|NETISR_POLL
operator||
literal|1
operator|<<
name|NETISR_POLLMORE
argument_list|)
expr_stmt|;
name|phase
operator|=
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|pending_polls
operator|++
operator|>
literal|0
condition|)
name|lost_polls
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * ether_poll is called from the idle loop.  */
end_comment

begin_function
name|void
name|ether_poll
parameter_list|(
name|int
name|count
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|NET_LOCK_GIANT
argument_list|()
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|poll_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|>
name|poll_each_burst
condition|)
name|count
operator|=
name|poll_each_burst
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|poll_handlers
condition|;
name|i
operator|++
control|)
name|pr
index|[
name|i
index|]
operator|.
name|handler
argument_list|(
name|pr
index|[
name|i
index|]
operator|.
name|ifp
argument_list|,
name|POLL_ONLY
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|poll_mtx
argument_list|)
expr_stmt|;
name|NET_UNLOCK_GIANT
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * netisr_pollmore is called after other netisr's, possibly scheduling  * another NETISR_POLL call, or adapting the burst size for the next cycle.  *  * It is very bad to fetch large bursts of packets from a single card at once,  * because the burst could take a long time to be completely processed, or  * could saturate the intermediate queue (ipintrq or similar) leading to  * losses or unfairness. To reduce the problem, and also to account better for  * time spent in network-related processing, we split the burst in smaller  * chunks of fixed size, giving control to the other netisr's between chunks.  * This helps in improving the fairness, reducing livelock (because we  * emulate more closely the "process to completion" that we have with  * fastforwarding) and accounting for the work performed in low level  * handling and forwarding.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|timeval
name|poll_start_t
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|netisr_pollmore
parameter_list|()
block|{
name|struct
name|timeval
name|t
decl_stmt|;
name|int
name|kern_load
decl_stmt|;
name|NET_ASSERT_GIANT
argument_list|()
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|poll_mtx
argument_list|)
expr_stmt|;
name|phase
operator|=
literal|5
expr_stmt|;
if|if
condition|(
name|residual_burst
operator|>
literal|0
condition|)
block|{
name|schednetisrbits
argument_list|(
literal|1
operator|<<
name|NETISR_POLL
operator||
literal|1
operator|<<
name|NETISR_POLLMORE
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|poll_mtx
argument_list|)
expr_stmt|;
comment|/* will run immediately on return, followed by netisrs */
return|return;
block|}
comment|/* here we can account time spent in netisr's in this tick */
name|microuptime
argument_list|(
operator|&
name|t
argument_list|)
expr_stmt|;
name|kern_load
operator|=
operator|(
name|t
operator|.
name|tv_usec
operator|-
name|poll_start_t
operator|.
name|tv_usec
operator|)
operator|+
operator|(
name|t
operator|.
name|tv_sec
operator|-
name|poll_start_t
operator|.
name|tv_sec
operator|)
operator|*
literal|1000000
expr_stmt|;
comment|/* us */
name|kern_load
operator|=
operator|(
name|kern_load
operator|*
name|hz
operator|)
operator|/
literal|10000
expr_stmt|;
comment|/* 0..100 */
if|if
condition|(
name|kern_load
operator|>
operator|(
literal|100
operator|-
name|user_frac
operator|)
condition|)
block|{
comment|/* try decrease ticks */
if|if
condition|(
name|poll_burst
operator|>
literal|1
condition|)
name|poll_burst
operator|--
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|poll_burst
operator|<
name|poll_burst_max
condition|)
name|poll_burst
operator|++
expr_stmt|;
block|}
name|pending_polls
operator|--
expr_stmt|;
if|if
condition|(
name|pending_polls
operator|==
literal|0
condition|)
comment|/* we are done */
name|phase
operator|=
literal|0
expr_stmt|;
else|else
block|{
comment|/* 		 * Last cycle was long and caused us to miss one or more 		 * hardclock ticks. Restart processing again, but slightly 		 * reduce the burst size to prevent that this happens again. 		 */
name|poll_burst
operator|-=
operator|(
name|poll_burst
operator|/
literal|8
operator|)
expr_stmt|;
if|if
condition|(
name|poll_burst
operator|<
literal|1
condition|)
name|poll_burst
operator|=
literal|1
expr_stmt|;
name|schednetisrbits
argument_list|(
literal|1
operator|<<
name|NETISR_POLL
operator||
literal|1
operator|<<
name|NETISR_POLLMORE
argument_list|)
expr_stmt|;
name|phase
operator|=
literal|6
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|poll_mtx
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * netisr_poll is scheduled by schednetisr when appropriate, typically once  * per tick.  */
end_comment

begin_function
specifier|static
name|void
name|netisr_poll
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|cycles
decl_stmt|;
name|enum
name|poll_cmd
name|arg
init|=
name|POLL_ONLY
decl_stmt|;
name|NET_ASSERT_GIANT
argument_list|()
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|poll_mtx
argument_list|)
expr_stmt|;
name|phase
operator|=
literal|3
expr_stmt|;
if|if
condition|(
name|residual_burst
operator|==
literal|0
condition|)
block|{
comment|/* first call in this tick */
name|microuptime
argument_list|(
operator|&
name|poll_start_t
argument_list|)
expr_stmt|;
if|if
condition|(
operator|++
name|reg_frac_count
operator|==
name|reg_frac
condition|)
block|{
name|arg
operator|=
name|POLL_AND_CHECK_STATUS
expr_stmt|;
name|reg_frac_count
operator|=
literal|0
expr_stmt|;
block|}
name|residual_burst
operator|=
name|poll_burst
expr_stmt|;
block|}
name|cycles
operator|=
operator|(
name|residual_burst
operator|<
name|poll_each_burst
operator|)
condition|?
name|residual_burst
else|:
name|poll_each_burst
expr_stmt|;
name|residual_burst
operator|-=
name|cycles
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|poll_handlers
condition|;
name|i
operator|++
control|)
name|pr
index|[
name|i
index|]
operator|.
name|handler
argument_list|(
name|pr
index|[
name|i
index|]
operator|.
name|ifp
argument_list|,
name|arg
argument_list|,
name|cycles
argument_list|)
expr_stmt|;
name|phase
operator|=
literal|4
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|poll_mtx
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Try to register routine for polling. Returns 0 if successful  * (and polling should be enabled), error code otherwise.  * A device is not supposed to register itself multiple times.  *  * This is called from within the *_ioctl() functions.  */
end_comment

begin_function
name|int
name|ether_poll_register
parameter_list|(
name|poll_handler_t
modifier|*
name|h
parameter_list|,
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|KASSERT
argument_list|(
name|h
operator|!=
name|NULL
argument_list|,
operator|(
literal|"%s: handler is NULL"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|ifp
operator|!=
name|NULL
argument_list|,
operator|(
literal|"%s: ifp is NULL"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|NET_ASSERT_GIANT
argument_list|()
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|poll_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|poll_handlers
operator|>=
name|POLL_LIST_LEN
condition|)
block|{
comment|/* 		 * List full, cannot register more entries. 		 * This should never happen; if it does, it is probably a 		 * broken driver trying to register multiple times. Checking 		 * this at runtime is expensive, and won't solve the problem 		 * anyways, so just report a few times and then give up. 		 */
specifier|static
name|int
name|verbose
init|=
literal|10
decl_stmt|;
if|if
condition|(
name|verbose
operator|>
literal|0
condition|)
block|{
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"poll handlers list full, "
literal|"maybe a broken driver ?\n"
argument_list|)
expr_stmt|;
name|verbose
operator|--
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|poll_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
comment|/* no polling for you */
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|poll_handlers
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|pr
index|[
name|i
index|]
operator|.
name|ifp
operator|==
name|ifp
operator|&&
name|pr
index|[
name|i
index|]
operator|.
name|handler
operator|!=
name|NULL
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|poll_mtx
argument_list|)
expr_stmt|;
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"ether_poll_register: %s: handler"
literal|" already registered\n"
argument_list|,
name|ifp
operator|->
name|if_xname
argument_list|)
expr_stmt|;
return|return
operator|(
name|EEXIST
operator|)
return|;
block|}
name|pr
index|[
name|poll_handlers
index|]
operator|.
name|handler
operator|=
name|h
expr_stmt|;
name|pr
index|[
name|poll_handlers
index|]
operator|.
name|ifp
operator|=
name|ifp
expr_stmt|;
name|poll_handlers
operator|++
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|poll_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|idlepoll_sleeping
condition|)
name|wakeup
argument_list|(
operator|&
name|idlepoll_sleeping
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Remove interface from the polling list. Called from *_ioctl(), too.  */
end_comment

begin_function
name|int
name|ether_poll_deregister
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|KASSERT
argument_list|(
name|ifp
operator|!=
name|NULL
argument_list|,
operator|(
literal|"%s: ifp is NULL"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|NET_ASSERT_GIANT
argument_list|()
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|poll_mtx
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|poll_handlers
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|pr
index|[
name|i
index|]
operator|.
name|ifp
operator|==
name|ifp
condition|)
comment|/* found it */
break|break;
if|if
condition|(
name|i
operator|==
name|poll_handlers
condition|)
block|{
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"ether_poll_deregister: %s: not found!\n"
argument_list|,
name|ifp
operator|->
name|if_xname
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|poll_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
name|poll_handlers
operator|--
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|poll_handlers
condition|)
block|{
comment|/* Last entry replaces this one. */
name|pr
index|[
name|i
index|]
operator|.
name|handler
operator|=
name|pr
index|[
name|poll_handlers
index|]
operator|.
name|handler
expr_stmt|;
name|pr
index|[
name|i
index|]
operator|.
name|ifp
operator|=
name|pr
index|[
name|poll_handlers
index|]
operator|.
name|ifp
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|poll_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Legacy interface for turning polling on all interfaces at one time.  */
end_comment

begin_function
specifier|static
name|int
name|poll_switch
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|val
init|=
name|polling
decl_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|val
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
operator|!
name|req
operator|->
name|newptr
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|val
operator|==
name|polling
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|val
operator|<
literal|0
operator|||
name|val
operator|>
literal|1
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|polling
operator|=
name|val
expr_stmt|;
name|NET_LOCK_GIANT
argument_list|()
expr_stmt|;
name|IFNET_RLOCK
argument_list|()
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|ifp
argument_list|,
argument|&ifnet
argument_list|,
argument|if_link
argument_list|)
block|{
if|if
condition|(
name|ifp
operator|->
name|if_capabilities
operator|&
name|IFCAP_POLLING
condition|)
block|{
name|struct
name|ifreq
name|ifr
decl_stmt|;
if|if
condition|(
name|val
operator|==
literal|1
condition|)
name|ifr
operator|.
name|ifr_reqcap
operator|=
name|ifp
operator|->
name|if_capenable
operator||
name|IFCAP_POLLING
expr_stmt|;
else|else
name|ifr
operator|.
name|ifr_reqcap
operator|=
name|ifp
operator|->
name|if_capenable
operator|&
operator|~
name|IFCAP_POLLING
expr_stmt|;
name|IFF_LOCKGIANT
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
comment|/* LOR here */
call|(
name|void
call|)
argument_list|(
operator|*
name|ifp
operator|->
name|if_ioctl
argument_list|)
argument_list|(
name|ifp
argument_list|,
name|SIOCSIFCAP
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|ifr
argument_list|)
expr_stmt|;
name|IFF_UNLOCKGIANT
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
block|}
block|}
name|IFNET_RUNLOCK
argument_list|()
expr_stmt|;
name|NET_UNLOCK_GIANT
argument_list|()
expr_stmt|;
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"kern.polling.enable is deprecated. Use ifconfig(8)"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|poll_idle
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|thread
modifier|*
name|td
init|=
name|curthread
decl_stmt|;
name|struct
name|rtprio
name|rtp
decl_stmt|;
name|rtp
operator|.
name|prio
operator|=
name|RTP_PRIO_MAX
expr_stmt|;
comment|/* lowest priority */
name|rtp
operator|.
name|type
operator|=
name|RTP_PRIO_IDLE
expr_stmt|;
name|mtx_lock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
name|rtp_to_pri
argument_list|(
operator|&
name|rtp
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|poll_in_idle_loop
operator|&&
name|poll_handlers
operator|>
literal|0
condition|)
block|{
name|idlepoll_sleeping
operator|=
literal|0
expr_stmt|;
name|ether_poll
argument_list|(
name|poll_each_burst
argument_list|)
expr_stmt|;
name|mtx_lock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
name|mi_switch
argument_list|(
name|SW_VOL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|idlepoll_sleeping
operator|=
literal|1
expr_stmt|;
name|tsleep
argument_list|(
operator|&
name|idlepoll_sleeping
argument_list|,
literal|0
argument_list|,
literal|"pollid"
argument_list|,
name|hz
operator|*
literal|3
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|proc
modifier|*
name|idlepoll
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|kproc_desc
name|idlepoll_kp
init|=
block|{
literal|"idlepoll"
block|,
name|poll_idle
block|,
operator|&
name|idlepoll
block|}
decl_stmt|;
end_decl_stmt

begin_macro
name|SYSINIT
argument_list|(
argument|idlepoll
argument_list|,
argument|SI_SUB_KTHREAD_VM
argument_list|,
argument|SI_ORDER_ANY
argument_list|,
argument|kproc_start
argument_list|,
argument|&idlepoll_kp
argument_list|)
end_macro

end_unit

