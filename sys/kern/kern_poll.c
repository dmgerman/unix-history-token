begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2001-2002 Luigi Rizzo  *  * Supported by: the Xorp Project (www.xorp.org)  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHORS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_comment
comment|/* needed by net/if.h		*/
end_comment

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_comment
comment|/* for IFF_* flags		*/
end_comment

begin_include
include|#
directive|include
file|<net/netisr.h>
end_include

begin_comment
comment|/* for NETISR_POLL		*/
end_comment

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/resourcevar.h>
end_include

begin_include
include|#
directive|include
file|<sys/kthread.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|SMP
end_ifdef

begin_error
error|#
directive|error
error|DEVICE_POLLING is not compatible with SMP
end_error

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|netisr_poll
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* the two netisr handlers      */
end_comment

begin_function_decl
name|void
name|netisr_pollmore
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|init_device_poll
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* init routine			*/
end_comment

begin_function_decl
name|void
name|hardclock_device_poll
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* hook from hardclock		*/
end_comment

begin_function_decl
name|void
name|ether_poll
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* polling while in trap	*/
end_comment

begin_comment
comment|/*  * Polling support for [network] device drivers.  *  * Drivers which support this feature try to register with the  * polling code.  *  * If registration is successful, the driver must disable interrupts,  * and further I/O is performed through the handler, which is invoked  * (at least once per clock tick) with 3 arguments: the "arg" passed at  * register time (a struct ifnet pointer), a command, and a "count" limit.  *  * The command can be one of the following:  *  POLL_ONLY: quick move of "count" packets from input/output queues.  *  POLL_AND_CHECK_STATUS: as above, plus check status registers or do  *	other more expensive operations. This command is issued periodically  *	but less frequently than POLL_ONLY.  *  POLL_DEREGISTER: deregister and return to interrupt mode.  *  * The first two commands are only issued if the interface is marked as  * 'IFF_UP and IFF_RUNNING', the last one only if IFF_RUNNING is set.  *  * The count limit specifies how much work the handler can do during the  * call -- typically this is the number of packets to be received, or  * transmitted, etc. (drivers are free to interpret this number, as long  * as the max time spent in the function grows roughly linearly with the  * count).  *  * Deregistration can be requested by the driver itself (typically in the  * *_stop() routine), or by the polling code, by invoking the handler.  *  * Polling can be globally enabled or disabled with the sysctl variable  * kern.polling.enable (default is 0, disabled)  *  * A second variable controls the sharing of CPU between polling/kernel  * network processing, and other activities (typically userlevel tasks):  * kern.polling.user_frac (between 0 and 100, default 50) sets the share  * of CPU allocated to user tasks. CPU is allocated proportionally to the  * shares, by dynamically adjusting the "count" (poll_burst).  *  * Other parameters can should be left to their default values.  * The following constraints hold  *  *	1<= poll_each_burst<= poll_burst<= poll_burst_max  *	0<= poll_in_trap<= poll_each_burst  *	MIN_POLL_BURST_MAX<= poll_burst_max<= MAX_POLL_BURST_MAX  */
end_comment

begin_define
define|#
directive|define
name|MIN_POLL_BURST_MAX
value|10
end_define

begin_define
define|#
directive|define
name|MAX_POLL_BURST_MAX
value|1000
end_define

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_kern
argument_list|,
name|OID_AUTO
argument_list|,
name|polling
argument_list|,
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
literal|"Device polling parameters"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|u_int32_t
name|poll_burst
init|=
literal|5
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_kern_polling
argument_list|,
name|OID_AUTO
argument_list|,
name|burst
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|poll_burst
argument_list|,
literal|0
argument_list|,
literal|"Current polling burst size"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|u_int32_t
name|poll_each_burst
init|=
literal|5
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_kern_polling
argument_list|,
name|OID_AUTO
argument_list|,
name|each_burst
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|poll_each_burst
argument_list|,
literal|0
argument_list|,
literal|"Max size of each burst"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|u_int32_t
name|poll_burst_max
init|=
literal|150
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* good for 100Mbit net and HZ=1000 */
end_comment

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_kern_polling
argument_list|,
name|OID_AUTO
argument_list|,
name|burst_max
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|poll_burst_max
argument_list|,
literal|0
argument_list|,
literal|"Max Polling burst size"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|u_int32_t
name|poll_in_idle_loop
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* do we poll in idle loop ? */
end_comment

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_kern_polling
argument_list|,
name|OID_AUTO
argument_list|,
name|idle_poll
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|poll_in_idle_loop
argument_list|,
literal|0
argument_list|,
literal|"Enable device polling in idle loop"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|u_int32_t
name|poll_in_trap
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* used in trap.c */
end_comment

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_kern_polling
argument_list|,
name|OID_AUTO
argument_list|,
name|poll_in_trap
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|poll_in_trap
argument_list|,
literal|0
argument_list|,
literal|"Poll burst size during a trap"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|u_int32_t
name|user_frac
init|=
literal|50
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_kern_polling
argument_list|,
name|OID_AUTO
argument_list|,
name|user_frac
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|user_frac
argument_list|,
literal|0
argument_list|,
literal|"Desired user fraction of cpu time"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|u_int32_t
name|reg_frac
init|=
literal|20
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_kern_polling
argument_list|,
name|OID_AUTO
argument_list|,
name|reg_frac
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|reg_frac
argument_list|,
literal|0
argument_list|,
literal|"Every this many cycles poll register"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|u_int32_t
name|short_ticks
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_kern_polling
argument_list|,
name|OID_AUTO
argument_list|,
name|short_ticks
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|short_ticks
argument_list|,
literal|0
argument_list|,
literal|"Hardclock ticks shorter than they should be"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|u_int32_t
name|lost_polls
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_kern_polling
argument_list|,
name|OID_AUTO
argument_list|,
name|lost_polls
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|lost_polls
argument_list|,
literal|0
argument_list|,
literal|"How many times we would have lost a poll tick"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|u_int32_t
name|pending_polls
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_kern_polling
argument_list|,
name|OID_AUTO
argument_list|,
name|pending_polls
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|pending_polls
argument_list|,
literal|0
argument_list|,
literal|"Do we need to poll again"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|residual_burst
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_kern_polling
argument_list|,
name|OID_AUTO
argument_list|,
name|residual_burst
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|residual_burst
argument_list|,
literal|0
argument_list|,
literal|"# of residual cycles in burst"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|u_int32_t
name|poll_handlers
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* next free entry in pr[]. */
end_comment

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_kern_polling
argument_list|,
name|OID_AUTO
argument_list|,
name|handlers
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|poll_handlers
argument_list|,
literal|0
argument_list|,
literal|"Number of registered poll handlers"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|polling
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* global polling enable */
end_comment

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_kern_polling
argument_list|,
name|OID_AUTO
argument_list|,
name|enable
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|polling
argument_list|,
literal|0
argument_list|,
literal|"Polling enabled"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
specifier|volatile
name|u_int32_t
name|phase
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_kern_polling
argument_list|,
name|OID_AUTO
argument_list|,
name|phase
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|phase
argument_list|,
literal|0
argument_list|,
literal|"Polling phase"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|u_int32_t
name|suspect
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_kern_polling
argument_list|,
name|OID_AUTO
argument_list|,
name|suspect
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|suspect
argument_list|,
literal|0
argument_list|,
literal|"suspect event"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
specifier|volatile
name|u_int32_t
name|stalled
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_kern_polling
argument_list|,
name|OID_AUTO
argument_list|,
name|stalled
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|stalled
argument_list|,
literal|0
argument_list|,
literal|"potential stalls"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|u_int32_t
name|idlepoll_sleeping
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* idlepoll is sleeping */
end_comment

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_kern_polling
argument_list|,
name|OID_AUTO
argument_list|,
name|idlepoll_sleeping
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|idlepoll_sleeping
argument_list|,
literal|0
argument_list|,
literal|"idlepoll is sleeping"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|POLL_LIST_LEN
value|128
end_define

begin_struct
struct|struct
name|pollrec
block|{
name|poll_handler_t
modifier|*
name|handler
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|pollrec
name|pr
index|[
name|POLL_LIST_LEN
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * register relevant netisr. Called from kern_clock.c:  */
end_comment

begin_function
name|void
name|init_device_poll
parameter_list|(
name|void
parameter_list|)
block|{
name|register_netisr
argument_list|(
name|NETISR_POLL
argument_list|,
name|netisr_poll
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Hook from hardclock. Tries to schedule a netisr, but keeps track  * of lost ticks due to the previous handler taking too long.  * The first part of the code is just for debugging purposes, and tries  * to count how often hardclock ticks are shorter than they should,  * meaning either stray interrupts or delayed events.  */
end_comment

begin_function
name|void
name|hardclock_device_poll
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
name|struct
name|timeval
name|prev_t
decl_stmt|,
name|t
decl_stmt|;
name|int
name|delta
decl_stmt|;
if|if
condition|(
name|poll_handlers
operator|==
literal|0
condition|)
return|return;
name|microuptime
argument_list|(
operator|&
name|t
argument_list|)
expr_stmt|;
name|delta
operator|=
operator|(
name|t
operator|.
name|tv_usec
operator|-
name|prev_t
operator|.
name|tv_usec
operator|)
operator|+
operator|(
name|t
operator|.
name|tv_sec
operator|-
name|prev_t
operator|.
name|tv_sec
operator|)
operator|*
literal|1000000
expr_stmt|;
if|if
condition|(
name|delta
operator|*
name|hz
operator|<
literal|500000
condition|)
name|short_ticks
operator|++
expr_stmt|;
else|else
name|prev_t
operator|=
name|t
expr_stmt|;
if|if
condition|(
name|pending_polls
operator|>
literal|100
condition|)
block|{
comment|/* too much, assume it has stalled */
name|stalled
operator|++
expr_stmt|;
name|printf
argument_list|(
literal|"poll stalled [%d] in phase %d\n"
argument_list|,
name|stalled
argument_list|,
name|phase
argument_list|)
expr_stmt|;
name|pending_polls
operator|=
literal|0
expr_stmt|;
name|phase
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|phase
operator|<=
literal|2
condition|)
block|{
if|if
condition|(
name|phase
operator|!=
literal|0
condition|)
name|suspect
operator|++
expr_stmt|;
name|phase
operator|=
literal|1
expr_stmt|;
name|schednetisr
argument_list|(
name|NETISR_POLL
argument_list|)
expr_stmt|;
name|phase
operator|=
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|pending_polls
operator|++
operator|>
literal|0
condition|)
name|lost_polls
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * ether_poll is called from the idle loop or from the trap handler.  */
end_comment

begin_function
name|void
name|ether_poll
parameter_list|(
name|int
name|count
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|>
name|poll_each_burst
condition|)
name|count
operator|=
name|poll_each_burst
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|poll_handlers
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|pr
index|[
name|i
index|]
operator|.
name|handler
operator|&&
operator|(
name|IFF_UP
operator||
name|IFF_RUNNING
operator|)
operator|==
operator|(
name|pr
index|[
name|i
index|]
operator|.
name|ifp
operator|->
name|if_flags
operator|&
operator|(
name|IFF_UP
operator||
name|IFF_RUNNING
operator|)
operator|)
condition|)
name|pr
index|[
name|i
index|]
operator|.
name|handler
argument_list|(
name|pr
index|[
name|i
index|]
operator|.
name|ifp
argument_list|,
literal|0
argument_list|,
name|count
argument_list|)
expr_stmt|;
comment|/* quick check */
name|mtx_unlock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * netisr_pollmore is called after other netisr's, possibly scheduling  * another NETISR_POLL call, or adapting the burst size for the next cycle.  *  * It is very bad to fetch large bursts of packets from a single card at once,  * because the burst could take a long time to be completely processed, or  * could saturate the intermediate queue (ipintrq or similar) leading to  * losses or unfairness. To reduce the problem, and also to account better for  * time spent in network-related processing, we split the burst in smaller  * chunks of fixed size, giving control to the other netisr's between chunks.  * This helps in improving the fairness, reducing livelock (because we  * emulate more closely the "process to completion" that we have with  * fastforwarding) and accounting for the work performed in low level  * handling and forwarding.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|timeval
name|poll_start_t
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|netisr_pollmore
parameter_list|()
block|{
name|struct
name|timeval
name|t
decl_stmt|;
name|int
name|kern_load
decl_stmt|;
comment|/* XXX run at splhigh() or equivalent */
name|phase
operator|=
literal|5
expr_stmt|;
if|if
condition|(
name|residual_burst
operator|>
literal|0
condition|)
block|{
name|schednetisr
argument_list|(
name|NETISR_POLL
argument_list|)
expr_stmt|;
comment|/* will run immediately on return, followed by netisrs */
return|return ;
block|}
comment|/* here we can account time spent in netisr's in this tick */
name|microuptime
argument_list|(
operator|&
name|t
argument_list|)
expr_stmt|;
name|kern_load
operator|=
operator|(
name|t
operator|.
name|tv_usec
operator|-
name|poll_start_t
operator|.
name|tv_usec
operator|)
operator|+
operator|(
name|t
operator|.
name|tv_sec
operator|-
name|poll_start_t
operator|.
name|tv_sec
operator|)
operator|*
literal|1000000
expr_stmt|;
comment|/* us */
name|kern_load
operator|=
operator|(
name|kern_load
operator|*
name|hz
operator|)
operator|/
literal|10000
expr_stmt|;
comment|/* 0..100 */
if|if
condition|(
name|kern_load
operator|>
operator|(
literal|100
operator|-
name|user_frac
operator|)
condition|)
block|{
comment|/* try decrease ticks */
if|if
condition|(
name|poll_burst
operator|>
literal|1
condition|)
name|poll_burst
operator|--
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|poll_burst
operator|<
name|poll_burst_max
condition|)
name|poll_burst
operator|++
expr_stmt|;
block|}
name|pending_polls
operator|--
expr_stmt|;
if|if
condition|(
name|pending_polls
operator|==
literal|0
condition|)
comment|/* we are done */
name|phase
operator|=
literal|0
expr_stmt|;
else|else
block|{
comment|/* 		 * Last cycle was long and caused us to miss one or more 		 * hardclock ticks. Restart processing again, but slightly 		 * reduce the burst size to prevent that this happens again. 		 */
name|poll_burst
operator|-=
operator|(
name|poll_burst
operator|/
literal|8
operator|)
expr_stmt|;
if|if
condition|(
name|poll_burst
operator|<
literal|1
condition|)
name|poll_burst
operator|=
literal|1
expr_stmt|;
name|schednetisr
argument_list|(
name|NETISR_POLL
argument_list|)
expr_stmt|;
name|phase
operator|=
literal|6
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * netisr_poll is scheduled by schednetisr when appropriate, typically once  * per tick. It is called at splnet() so first thing to do is to upgrade to  * splimp(), and call all registered handlers.  */
end_comment

begin_function
specifier|static
name|void
name|netisr_poll
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
name|int
name|reg_frac_count
decl_stmt|;
name|int
name|i
decl_stmt|,
name|cycles
decl_stmt|;
name|enum
name|poll_cmd
name|arg
init|=
name|POLL_ONLY
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
name|phase
operator|=
literal|3
expr_stmt|;
if|if
condition|(
name|residual_burst
operator|==
literal|0
condition|)
block|{
comment|/* first call in this tick */
name|microuptime
argument_list|(
operator|&
name|poll_start_t
argument_list|)
expr_stmt|;
comment|/* 		 * Check that paremeters are consistent with runtime 		 * variables. Some of these tests could be done at sysctl 		 * time, but the savings would be very limited because we 		 * still have to check against reg_frac_count and 		 * poll_each_burst. So, instead of writing separate sysctl 		 * handlers, we do all here. 		 */
if|if
condition|(
name|reg_frac
operator|>
name|hz
condition|)
name|reg_frac
operator|=
name|hz
expr_stmt|;
elseif|else
if|if
condition|(
name|reg_frac
operator|<
literal|1
condition|)
name|reg_frac
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|reg_frac_count
operator|>
name|reg_frac
condition|)
name|reg_frac_count
operator|=
name|reg_frac
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|reg_frac_count
operator|--
operator|==
literal|0
condition|)
block|{
name|arg
operator|=
name|POLL_AND_CHECK_STATUS
expr_stmt|;
name|reg_frac_count
operator|=
name|reg_frac
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|poll_burst_max
operator|<
name|MIN_POLL_BURST_MAX
condition|)
name|poll_burst_max
operator|=
name|MIN_POLL_BURST_MAX
expr_stmt|;
elseif|else
if|if
condition|(
name|poll_burst_max
operator|>
name|MAX_POLL_BURST_MAX
condition|)
name|poll_burst_max
operator|=
name|MAX_POLL_BURST_MAX
expr_stmt|;
if|if
condition|(
name|poll_each_burst
operator|<
literal|1
condition|)
name|poll_each_burst
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|poll_each_burst
operator|>
name|poll_burst_max
condition|)
name|poll_each_burst
operator|=
name|poll_burst_max
expr_stmt|;
name|residual_burst
operator|=
name|poll_burst
expr_stmt|;
block|}
name|cycles
operator|=
operator|(
name|residual_burst
operator|<
name|poll_each_burst
operator|)
condition|?
name|residual_burst
else|:
name|poll_each_burst
expr_stmt|;
name|residual_burst
operator|-=
name|cycles
expr_stmt|;
if|if
condition|(
name|polling
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|poll_handlers
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|pr
index|[
name|i
index|]
operator|.
name|handler
operator|&&
operator|(
name|IFF_UP
operator||
name|IFF_RUNNING
operator|)
operator|==
operator|(
name|pr
index|[
name|i
index|]
operator|.
name|ifp
operator|->
name|if_flags
operator|&
operator|(
name|IFF_UP
operator||
name|IFF_RUNNING
operator|)
operator|)
condition|)
name|pr
index|[
name|i
index|]
operator|.
name|handler
argument_list|(
name|pr
index|[
name|i
index|]
operator|.
name|ifp
argument_list|,
name|arg
argument_list|,
name|cycles
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* unregister */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|poll_handlers
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|pr
index|[
name|i
index|]
operator|.
name|handler
operator|&&
name|pr
index|[
name|i
index|]
operator|.
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
condition|)
block|{
name|pr
index|[
name|i
index|]
operator|.
name|ifp
operator|->
name|if_ipending
operator|&=
operator|~
name|IFF_POLLING
expr_stmt|;
name|pr
index|[
name|i
index|]
operator|.
name|handler
argument_list|(
name|pr
index|[
name|i
index|]
operator|.
name|ifp
argument_list|,
name|POLL_DEREGISTER
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|pr
index|[
name|i
index|]
operator|.
name|handler
operator|=
name|NULL
expr_stmt|;
block|}
name|residual_burst
operator|=
literal|0
expr_stmt|;
name|poll_handlers
operator|=
literal|0
expr_stmt|;
block|}
comment|/* on -stable, schednetisr(NETISR_POLLMORE); */
name|phase
operator|=
literal|4
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Try to register routine for polling. Returns 1 if successful  * (and polling should be enabled), 0 otherwise.  * A device is not supposed to register itself multiple times.  *  * This is called from within the *_intr() functions, so we do not need  * further locking.  */
end_comment

begin_function
name|int
name|ether_poll_register
parameter_list|(
name|poll_handler_t
modifier|*
name|h
parameter_list|,
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|int
name|s
decl_stmt|;
if|if
condition|(
name|polling
operator|==
literal|0
condition|)
comment|/* polling disabled, cannot register */
return|return
literal|0
return|;
if|if
condition|(
name|h
operator|==
name|NULL
operator|||
name|ifp
operator|==
name|NULL
condition|)
comment|/* bad arguments	*/
return|return
literal|0
return|;
if|if
condition|(
operator|!
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
operator|)
condition|)
comment|/* must be up		*/
return|return
literal|0
return|;
if|if
condition|(
name|ifp
operator|->
name|if_ipending
operator|&
name|IFF_POLLING
condition|)
comment|/* already polling	*/
return|return
literal|0
return|;
name|s
operator|=
name|splhigh
argument_list|()
expr_stmt|;
if|if
condition|(
name|poll_handlers
operator|>=
name|POLL_LIST_LEN
condition|)
block|{
comment|/* 		 * List full, cannot register more entries. 		 * This should never happen; if it does, it is probably a 		 * broken driver trying to register multiple times. Checking 		 * this at runtime is expensive, and won't solve the problem 		 * anyways, so just report a few times and then give up. 		 */
specifier|static
name|int
name|verbose
init|=
literal|10
decl_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
operator|>
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"poll handlers list full, "
literal|"maybe a broken driver ?\n"
argument_list|)
expr_stmt|;
name|verbose
operator|--
expr_stmt|;
block|}
return|return
literal|0
return|;
comment|/* no polling for you */
block|}
name|pr
index|[
name|poll_handlers
index|]
operator|.
name|handler
operator|=
name|h
expr_stmt|;
name|pr
index|[
name|poll_handlers
index|]
operator|.
name|ifp
operator|=
name|ifp
expr_stmt|;
name|poll_handlers
operator|++
expr_stmt|;
name|ifp
operator|->
name|if_ipending
operator||=
name|IFF_POLLING
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|idlepoll_sleeping
condition|)
name|wakeup
argument_list|(
operator|&
name|idlepoll_sleeping
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
comment|/* polling enabled in next call */
block|}
end_function

begin_comment
comment|/*  * Remove interface from the polling list. Normally called by *_stop().  * It is not an error to call it with IFF_POLLING clear, the call is  * sufficiently rare to be preferable to save the space for the extra  * test in each driver in exchange of one additional function call.  */
end_comment

begin_function
name|int
name|ether_poll_deregister
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ifp
operator|||
operator|!
operator|(
name|ifp
operator|->
name|if_ipending
operator|&
name|IFF_POLLING
operator|)
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|poll_handlers
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|pr
index|[
name|i
index|]
operator|.
name|ifp
operator|==
name|ifp
condition|)
comment|/* found it */
break|break;
name|ifp
operator|->
name|if_ipending
operator|&=
operator|~
name|IFF_POLLING
expr_stmt|;
comment|/* found or not... */
if|if
condition|(
name|i
operator|==
name|poll_handlers
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"ether_poll_deregister: ifp not found!!!\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|poll_handlers
operator|--
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|poll_handlers
condition|)
block|{
comment|/* Last entry replaces this one. */
name|pr
index|[
name|i
index|]
operator|.
name|handler
operator|=
name|pr
index|[
name|poll_handlers
index|]
operator|.
name|handler
expr_stmt|;
name|pr
index|[
name|i
index|]
operator|.
name|ifp
operator|=
name|pr
index|[
name|poll_handlers
index|]
operator|.
name|ifp
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|poll_idle
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|thread
modifier|*
name|td
init|=
name|curthread
decl_stmt|;
name|struct
name|rtprio
name|rtp
decl_stmt|;
name|int
name|pri
decl_stmt|;
name|rtp
operator|.
name|prio
operator|=
name|RTP_PRIO_MAX
expr_stmt|;
comment|/* lowest priority */
name|rtp
operator|.
name|type
operator|=
name|RTP_PRIO_IDLE
expr_stmt|;
name|mtx_lock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
name|rtp_to_pri
argument_list|(
operator|&
name|rtp
argument_list|,
name|td
operator|->
name|td_ksegrp
argument_list|)
expr_stmt|;
name|pri
operator|=
name|td
operator|->
name|td_priority
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|poll_in_idle_loop
operator|&&
name|poll_handlers
operator|>
literal|0
condition|)
block|{
name|idlepoll_sleeping
operator|=
literal|0
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
name|ether_poll
argument_list|(
name|poll_each_burst
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|Giant
argument_list|,
name|MA_NOTOWNED
argument_list|)
expr_stmt|;
name|mtx_lock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
name|setrunqueue
argument_list|(
name|td
argument_list|)
expr_stmt|;
name|td
operator|->
name|td_proc
operator|->
name|p_stats
operator|->
name|p_ru
operator|.
name|ru_nvcsw
operator|++
expr_stmt|;
name|mi_switch
argument_list|()
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|idlepoll_sleeping
operator|=
literal|1
expr_stmt|;
name|tsleep
argument_list|(
operator|&
name|idlepoll_sleeping
argument_list|,
name|pri
argument_list|,
literal|"pollid"
argument_list|,
name|hz
operator|*
literal|3
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|proc
modifier|*
name|idlepoll
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|kproc_desc
name|idlepoll_kp
init|=
block|{
literal|"idlepoll"
block|,
name|poll_idle
block|,
operator|&
name|idlepoll
block|}
decl_stmt|;
end_decl_stmt

begin_macro
name|SYSINIT
argument_list|(
argument|idlepoll
argument_list|,
argument|SI_SUB_KTHREAD_VM
argument_list|,
argument|SI_ORDER_ANY
argument_list|,
argument|kproc_start
argument_list|,
argument|&idlepoll_kp
argument_list|)
end_macro

end_unit

