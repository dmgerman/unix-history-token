begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1998-2000 Doug Rabson  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"opt_gdb.h"
end_include

begin_include
include|#
directive|include
file|"opt_mac.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|GPROF
end_ifdef

begin_include
include|#
directive|include
file|<sys/gmon.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/mount.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/namei.h>
end_include

begin_include
include|#
directive|include
file|<sys/fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/vnode.h>
end_include

begin_include
include|#
directive|include
file|<sys/linker.h>
end_include

begin_include
include|#
directive|include
file|<machine/elf.h>
end_include

begin_include
include|#
directive|include
file|<security/mac/mac_framework.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_param.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|SPARSE_MAPPING
end_ifdef

begin_include
include|#
directive|include
file|<vm/vm_object.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_kern.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_extern.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_map.h>
end_include

begin_include
include|#
directive|include
file|<sys/link_elf.h>
end_include

begin_include
include|#
directive|include
file|"linker_if.h"
end_include

begin_define
define|#
directive|define
name|MAXSEGS
value|4
end_define

begin_typedef
typedef|typedef
struct|struct
name|elf_file
block|{
name|struct
name|linker_file
name|lf
decl_stmt|;
comment|/* Common fields */
name|int
name|preloaded
decl_stmt|;
comment|/* Was file pre-loaded */
name|caddr_t
name|address
decl_stmt|;
comment|/* Relocation address */
ifdef|#
directive|ifdef
name|SPARSE_MAPPING
name|vm_object_t
name|object
decl_stmt|;
comment|/* VM object to hold file pages */
endif|#
directive|endif
name|Elf_Dyn
modifier|*
name|dynamic
decl_stmt|;
comment|/* Symbol table etc. */
name|Elf_Hashelt
name|nbuckets
decl_stmt|;
comment|/* DT_HASH info */
name|Elf_Hashelt
name|nchains
decl_stmt|;
specifier|const
name|Elf_Hashelt
modifier|*
name|buckets
decl_stmt|;
specifier|const
name|Elf_Hashelt
modifier|*
name|chains
decl_stmt|;
name|caddr_t
name|hash
decl_stmt|;
name|caddr_t
name|strtab
decl_stmt|;
comment|/* DT_STRTAB */
name|int
name|strsz
decl_stmt|;
comment|/* DT_STRSZ */
specifier|const
name|Elf_Sym
modifier|*
name|symtab
decl_stmt|;
comment|/* DT_SYMTAB */
name|Elf_Addr
modifier|*
name|got
decl_stmt|;
comment|/* DT_PLTGOT */
specifier|const
name|Elf_Rel
modifier|*
name|pltrel
decl_stmt|;
comment|/* DT_JMPREL */
name|int
name|pltrelsize
decl_stmt|;
comment|/* DT_PLTRELSZ */
specifier|const
name|Elf_Rela
modifier|*
name|pltrela
decl_stmt|;
comment|/* DT_JMPREL */
name|int
name|pltrelasize
decl_stmt|;
comment|/* DT_PLTRELSZ */
specifier|const
name|Elf_Rel
modifier|*
name|rel
decl_stmt|;
comment|/* DT_REL */
name|int
name|relsize
decl_stmt|;
comment|/* DT_RELSZ */
specifier|const
name|Elf_Rela
modifier|*
name|rela
decl_stmt|;
comment|/* DT_RELA */
name|int
name|relasize
decl_stmt|;
comment|/* DT_RELASZ */
name|caddr_t
name|modptr
decl_stmt|;
specifier|const
name|Elf_Sym
modifier|*
name|ddbsymtab
decl_stmt|;
comment|/* The symbol table we are using */
name|long
name|ddbsymcnt
decl_stmt|;
comment|/* Number of symbols */
name|caddr_t
name|ddbstrtab
decl_stmt|;
comment|/* String table */
name|long
name|ddbstrcnt
decl_stmt|;
comment|/* number of bytes in string table */
name|caddr_t
name|symbase
decl_stmt|;
comment|/* malloc'ed symbold base */
name|caddr_t
name|strbase
decl_stmt|;
comment|/* malloc'ed string base */
ifdef|#
directive|ifdef
name|GDB
name|struct
name|link_map
name|gdb
decl_stmt|;
comment|/* hooks for gdb */
endif|#
directive|endif
block|}
typedef|*
name|elf_file_t
typedef|;
end_typedef

begin_function_decl
specifier|static
name|int
name|link_elf_link_common_finish
parameter_list|(
name|linker_file_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|link_elf_link_preload
parameter_list|(
name|linker_class_t
name|cls
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|linker_file_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|link_elf_link_preload_finish
parameter_list|(
name|linker_file_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|link_elf_load_file
parameter_list|(
name|linker_class_t
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|linker_file_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|link_elf_lookup_symbol
parameter_list|(
name|linker_file_t
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|c_linker_sym_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|link_elf_symbol_values
parameter_list|(
name|linker_file_t
parameter_list|,
name|c_linker_sym_t
parameter_list|,
name|linker_symval_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|link_elf_search_symbol
parameter_list|(
name|linker_file_t
parameter_list|,
name|caddr_t
name|value
parameter_list|,
name|c_linker_sym_t
modifier|*
name|sym
parameter_list|,
name|long
modifier|*
name|diffp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|link_elf_unload_file
parameter_list|(
name|linker_file_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|link_elf_unload_preload
parameter_list|(
name|linker_file_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|link_elf_lookup_set
parameter_list|(
name|linker_file_t
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|void
modifier|*
modifier|*
modifier|*
parameter_list|,
name|void
modifier|*
modifier|*
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|link_elf_each_function_name
parameter_list|(
name|linker_file_t
parameter_list|,
name|int
function_decl|(
modifier|*
function_decl|)
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|link_elf_reloc_local
parameter_list|(
name|linker_file_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|Elf_Addr
name|elf_lookup
parameter_list|(
name|linker_file_t
name|lf
parameter_list|,
name|Elf_Size
name|symidx
parameter_list|,
name|int
name|deps
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|kobj_method_t
name|link_elf_methods
index|[]
init|=
block|{
name|KOBJMETHOD
argument_list|(
name|linker_lookup_symbol
argument_list|,
name|link_elf_lookup_symbol
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|linker_symbol_values
argument_list|,
name|link_elf_symbol_values
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|linker_search_symbol
argument_list|,
name|link_elf_search_symbol
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|linker_unload
argument_list|,
name|link_elf_unload_file
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|linker_load_file
argument_list|,
name|link_elf_load_file
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|linker_link_preload
argument_list|,
name|link_elf_link_preload
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|linker_link_preload_finish
argument_list|,
name|link_elf_link_preload_finish
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|linker_lookup_set
argument_list|,
name|link_elf_lookup_set
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|linker_each_function_name
argument_list|,
name|link_elf_each_function_name
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|linker_class
name|link_elf_class
init|=
block|{
if|#
directive|if
name|ELF_TARG_CLASS
operator|==
name|ELFCLASS32
literal|"elf32"
block|,
else|#
directive|else
literal|"elf64"
block|,
endif|#
directive|endif
name|link_elf_methods
block|,
expr|sizeof
operator|(
expr|struct
name|elf_file
operator|)
block|}
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|parse_dynamic
parameter_list|(
name|elf_file_t
name|ef
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|relocate_file
parameter_list|(
name|elf_file_t
name|ef
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|link_elf_preload_parse_symbols
parameter_list|(
name|elf_file_t
name|ef
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|GDB
end_ifdef

begin_function_decl
specifier|static
name|void
name|r_debug_state
parameter_list|(
name|struct
name|r_debug
modifier|*
name|dummy_one
parameter_list|,
name|struct
name|link_map
modifier|*
name|dummy_two
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * A list of loaded modules for GDB to use for loading symbols.  */
end_comment

begin_decl_stmt
name|struct
name|r_debug
name|r_debug
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|GDB_STATE
parameter_list|(
name|s
parameter_list|)
value|r_debug.r_state = s; r_debug_state(NULL, NULL);
end_define

begin_comment
comment|/*  * Function for the debugger to set a breakpoint on to gain control.  */
end_comment

begin_function
specifier|static
name|void
name|r_debug_state
parameter_list|(
name|struct
name|r_debug
modifier|*
name|dummy_one
name|__unused
parameter_list|,
name|struct
name|link_map
modifier|*
name|dummy_two
name|__unused
parameter_list|)
block|{ }
end_function

begin_function
specifier|static
name|void
name|link_elf_add_gdb
parameter_list|(
name|struct
name|link_map
modifier|*
name|l
parameter_list|)
block|{
name|struct
name|link_map
modifier|*
name|prev
decl_stmt|;
name|l
operator|->
name|l_next
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|r_debug
operator|.
name|r_map
operator|==
name|NULL
condition|)
block|{
comment|/* Add first. */
name|l
operator|->
name|l_prev
operator|=
name|NULL
expr_stmt|;
name|r_debug
operator|.
name|r_map
operator|=
name|l
expr_stmt|;
block|}
else|else
block|{
comment|/* Append to list. */
for|for
control|(
name|prev
operator|=
name|r_debug
operator|.
name|r_map
init|;
name|prev
operator|->
name|l_next
operator|!=
name|NULL
condition|;
name|prev
operator|=
name|prev
operator|->
name|l_next
control|)
empty_stmt|;
name|l
operator|->
name|l_prev
operator|=
name|prev
expr_stmt|;
name|prev
operator|->
name|l_next
operator|=
name|l
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|link_elf_delete_gdb
parameter_list|(
name|struct
name|link_map
modifier|*
name|l
parameter_list|)
block|{
if|if
condition|(
name|l
operator|->
name|l_prev
operator|==
name|NULL
condition|)
block|{
comment|/* Remove first. */
if|if
condition|(
operator|(
name|r_debug
operator|.
name|r_map
operator|=
name|l
operator|->
name|l_next
operator|)
operator|!=
name|NULL
condition|)
name|l
operator|->
name|l_next
operator|->
name|l_prev
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
comment|/* Remove any but first. */
if|if
condition|(
operator|(
name|l
operator|->
name|l_prev
operator|->
name|l_next
operator|=
name|l
operator|->
name|l_next
operator|)
operator|!=
name|NULL
condition|)
name|l
operator|->
name|l_next
operator|->
name|l_prev
operator|=
name|l
operator|->
name|l_prev
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* GDB */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__ia64__
end_ifdef

begin_function_decl
name|Elf_Addr
name|link_elf_get_gp
parameter_list|(
name|linker_file_t
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * The kernel symbol table starts here.  */
end_comment

begin_decl_stmt
specifier|extern
name|struct
name|_dynamic
name|_DYNAMIC
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|link_elf_error
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|)
block|{
name|printf
argument_list|(
literal|"kldload: %s\n"
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Actions performed after linking/loading both the preloaded kernel and any  * modules; whether preloaded or dynamicly loaded.  */
end_comment

begin_function
specifier|static
name|int
name|link_elf_link_common_finish
parameter_list|(
name|linker_file_t
name|lf
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|GDB
name|elf_file_t
name|ef
init|=
operator|(
name|elf_file_t
operator|)
name|lf
decl_stmt|;
name|char
modifier|*
name|newfilename
decl_stmt|;
endif|#
directive|endif
name|int
name|error
decl_stmt|;
comment|/* Notify MD code that a module is being loaded. */
name|error
operator|=
name|elf_cpu_load_file
argument_list|(
name|lf
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
ifdef|#
directive|ifdef
name|GDB
name|GDB_STATE
argument_list|(
name|RT_ADD
argument_list|)
expr_stmt|;
name|ef
operator|->
name|gdb
operator|.
name|l_addr
operator|=
name|lf
operator|->
name|address
expr_stmt|;
name|newfilename
operator|=
name|malloc
argument_list|(
name|strlen
argument_list|(
name|lf
operator|->
name|filename
argument_list|)
operator|+
literal|1
argument_list|,
name|M_LINKER
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|newfilename
argument_list|,
name|lf
operator|->
name|filename
argument_list|)
expr_stmt|;
name|ef
operator|->
name|gdb
operator|.
name|l_name
operator|=
name|newfilename
expr_stmt|;
name|ef
operator|->
name|gdb
operator|.
name|l_ld
operator|=
name|ef
operator|->
name|dynamic
expr_stmt|;
name|link_elf_add_gdb
argument_list|(
operator|&
name|ef
operator|->
name|gdb
argument_list|)
expr_stmt|;
name|GDB_STATE
argument_list|(
name|RT_CONSISTENT
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|link_elf_init
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|Elf_Dyn
modifier|*
name|dp
decl_stmt|;
name|caddr_t
name|modptr
decl_stmt|,
name|baseptr
decl_stmt|,
name|sizeptr
decl_stmt|;
name|elf_file_t
name|ef
decl_stmt|;
name|char
modifier|*
name|modname
decl_stmt|;
name|linker_add_class
argument_list|(
operator|&
name|link_elf_class
argument_list|)
expr_stmt|;
name|dp
operator|=
operator|(
name|Elf_Dyn
operator|*
operator|)
operator|&
name|_DYNAMIC
expr_stmt|;
name|modname
operator|=
name|NULL
expr_stmt|;
name|modptr
operator|=
name|preload_search_by_type
argument_list|(
literal|"elf"
name|__XSTRING
argument_list|(
name|__ELF_WORD_SIZE
argument_list|)
literal|" kernel"
argument_list|)
expr_stmt|;
if|if
condition|(
name|modptr
operator|==
name|NULL
condition|)
name|modptr
operator|=
name|preload_search_by_type
argument_list|(
literal|"elf kernel"
argument_list|)
expr_stmt|;
if|if
condition|(
name|modptr
condition|)
name|modname
operator|=
operator|(
name|char
operator|*
operator|)
name|preload_search_info
argument_list|(
name|modptr
argument_list|,
name|MODINFO_NAME
argument_list|)
expr_stmt|;
if|if
condition|(
name|modname
operator|==
name|NULL
condition|)
name|modname
operator|=
literal|"kernel"
expr_stmt|;
name|linker_kernel_file
operator|=
name|linker_make_file
argument_list|(
name|modname
argument_list|,
operator|&
name|link_elf_class
argument_list|)
expr_stmt|;
if|if
condition|(
name|linker_kernel_file
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"link_elf_init: Can't create linker structures for kernel"
argument_list|)
expr_stmt|;
name|ef
operator|=
operator|(
name|elf_file_t
operator|)
name|linker_kernel_file
expr_stmt|;
name|ef
operator|->
name|preloaded
operator|=
literal|1
expr_stmt|;
name|ef
operator|->
name|address
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|SPARSE_MAPPING
name|ef
operator|->
name|object
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|ef
operator|->
name|dynamic
operator|=
name|dp
expr_stmt|;
if|if
condition|(
name|dp
condition|)
name|parse_dynamic
argument_list|(
name|ef
argument_list|)
expr_stmt|;
name|linker_kernel_file
operator|->
name|address
operator|=
operator|(
name|caddr_t
operator|)
name|KERNBASE
expr_stmt|;
name|linker_kernel_file
operator|->
name|size
operator|=
operator|-
operator|(
name|intptr_t
operator|)
name|linker_kernel_file
operator|->
name|address
expr_stmt|;
if|if
condition|(
name|modptr
condition|)
block|{
name|ef
operator|->
name|modptr
operator|=
name|modptr
expr_stmt|;
name|baseptr
operator|=
name|preload_search_info
argument_list|(
name|modptr
argument_list|,
name|MODINFO_ADDR
argument_list|)
expr_stmt|;
if|if
condition|(
name|baseptr
condition|)
name|linker_kernel_file
operator|->
name|address
operator|=
operator|*
operator|(
name|caddr_t
operator|*
operator|)
name|baseptr
expr_stmt|;
name|sizeptr
operator|=
name|preload_search_info
argument_list|(
name|modptr
argument_list|,
name|MODINFO_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sizeptr
condition|)
name|linker_kernel_file
operator|->
name|size
operator|=
operator|*
operator|(
name|size_t
operator|*
operator|)
name|sizeptr
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|link_elf_preload_parse_symbols
argument_list|(
name|ef
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|GDB
name|r_debug
operator|.
name|r_map
operator|=
name|NULL
expr_stmt|;
name|r_debug
operator|.
name|r_brk
operator|=
name|r_debug_state
expr_stmt|;
name|r_debug
operator|.
name|r_state
operator|=
name|RT_CONSISTENT
expr_stmt|;
endif|#
directive|endif
operator|(
name|void
operator|)
name|link_elf_link_common_finish
argument_list|(
name|linker_kernel_file
argument_list|)
expr_stmt|;
name|linker_kernel_file
operator|->
name|flags
operator||=
name|LINKER_FILE_LINKED
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|SYSINIT
argument_list|(
name|link_elf
argument_list|,
name|SI_SUB_KLD
argument_list|,
name|SI_ORDER_THIRD
argument_list|,
name|link_elf_init
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|int
name|link_elf_preload_parse_symbols
parameter_list|(
name|elf_file_t
name|ef
parameter_list|)
block|{
name|caddr_t
name|pointer
decl_stmt|;
name|caddr_t
name|ssym
decl_stmt|,
name|esym
decl_stmt|,
name|base
decl_stmt|;
name|caddr_t
name|strtab
decl_stmt|;
name|int
name|strcnt
decl_stmt|;
name|Elf_Sym
modifier|*
name|symtab
decl_stmt|;
name|int
name|symcnt
decl_stmt|;
if|if
condition|(
name|ef
operator|->
name|modptr
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|pointer
operator|=
name|preload_search_info
argument_list|(
name|ef
operator|->
name|modptr
argument_list|,
name|MODINFO_METADATA
operator||
name|MODINFOMD_SSYM
argument_list|)
expr_stmt|;
if|if
condition|(
name|pointer
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|ssym
operator|=
operator|*
operator|(
name|caddr_t
operator|*
operator|)
name|pointer
expr_stmt|;
name|pointer
operator|=
name|preload_search_info
argument_list|(
name|ef
operator|->
name|modptr
argument_list|,
name|MODINFO_METADATA
operator||
name|MODINFOMD_ESYM
argument_list|)
expr_stmt|;
if|if
condition|(
name|pointer
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|esym
operator|=
operator|*
operator|(
name|caddr_t
operator|*
operator|)
name|pointer
expr_stmt|;
name|base
operator|=
name|ssym
expr_stmt|;
name|symcnt
operator|=
operator|*
operator|(
name|long
operator|*
operator|)
name|base
expr_stmt|;
name|base
operator|+=
sizeof|sizeof
argument_list|(
name|long
argument_list|)
expr_stmt|;
name|symtab
operator|=
operator|(
name|Elf_Sym
operator|*
operator|)
name|base
expr_stmt|;
name|base
operator|+=
name|roundup
argument_list|(
name|symcnt
argument_list|,
sizeof|sizeof
argument_list|(
name|long
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|base
operator|>
name|esym
operator|||
name|base
operator|<
name|ssym
condition|)
block|{
name|printf
argument_list|(
literal|"Symbols are corrupt!\n"
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
name|strcnt
operator|=
operator|*
operator|(
name|long
operator|*
operator|)
name|base
expr_stmt|;
name|base
operator|+=
sizeof|sizeof
argument_list|(
name|long
argument_list|)
expr_stmt|;
name|strtab
operator|=
name|base
expr_stmt|;
name|base
operator|+=
name|roundup
argument_list|(
name|strcnt
argument_list|,
sizeof|sizeof
argument_list|(
name|long
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|base
operator|>
name|esym
operator|||
name|base
operator|<
name|ssym
condition|)
block|{
name|printf
argument_list|(
literal|"Symbols are corrupt!\n"
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
name|ef
operator|->
name|ddbsymtab
operator|=
name|symtab
expr_stmt|;
name|ef
operator|->
name|ddbsymcnt
operator|=
name|symcnt
operator|/
sizeof|sizeof
argument_list|(
name|Elf_Sym
argument_list|)
expr_stmt|;
name|ef
operator|->
name|ddbstrtab
operator|=
name|strtab
expr_stmt|;
name|ef
operator|->
name|ddbstrcnt
operator|=
name|strcnt
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|parse_dynamic
parameter_list|(
name|elf_file_t
name|ef
parameter_list|)
block|{
name|Elf_Dyn
modifier|*
name|dp
decl_stmt|;
name|int
name|plttype
init|=
name|DT_REL
decl_stmt|;
for|for
control|(
name|dp
operator|=
name|ef
operator|->
name|dynamic
init|;
name|dp
operator|->
name|d_tag
operator|!=
name|DT_NULL
condition|;
name|dp
operator|++
control|)
block|{
switch|switch
condition|(
name|dp
operator|->
name|d_tag
condition|)
block|{
case|case
name|DT_HASH
case|:
block|{
comment|/* From src/libexec/rtld-elf/rtld.c */
specifier|const
name|Elf_Hashelt
modifier|*
name|hashtab
init|=
operator|(
specifier|const
name|Elf_Hashelt
operator|*
operator|)
operator|(
name|ef
operator|->
name|address
operator|+
name|dp
operator|->
name|d_un
operator|.
name|d_ptr
operator|)
decl_stmt|;
name|ef
operator|->
name|nbuckets
operator|=
name|hashtab
index|[
literal|0
index|]
expr_stmt|;
name|ef
operator|->
name|nchains
operator|=
name|hashtab
index|[
literal|1
index|]
expr_stmt|;
name|ef
operator|->
name|buckets
operator|=
name|hashtab
operator|+
literal|2
expr_stmt|;
name|ef
operator|->
name|chains
operator|=
name|ef
operator|->
name|buckets
operator|+
name|ef
operator|->
name|nbuckets
expr_stmt|;
break|break;
block|}
case|case
name|DT_STRTAB
case|:
name|ef
operator|->
name|strtab
operator|=
call|(
name|caddr_t
call|)
argument_list|(
name|ef
operator|->
name|address
operator|+
name|dp
operator|->
name|d_un
operator|.
name|d_ptr
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_STRSZ
case|:
name|ef
operator|->
name|strsz
operator|=
name|dp
operator|->
name|d_un
operator|.
name|d_val
expr_stmt|;
break|break;
case|case
name|DT_SYMTAB
case|:
name|ef
operator|->
name|symtab
operator|=
operator|(
name|Elf_Sym
operator|*
operator|)
operator|(
name|ef
operator|->
name|address
operator|+
name|dp
operator|->
name|d_un
operator|.
name|d_ptr
operator|)
expr_stmt|;
break|break;
case|case
name|DT_SYMENT
case|:
if|if
condition|(
name|dp
operator|->
name|d_un
operator|.
name|d_val
operator|!=
sizeof|sizeof
argument_list|(
name|Elf_Sym
argument_list|)
condition|)
return|return
name|ENOEXEC
return|;
break|break;
case|case
name|DT_PLTGOT
case|:
name|ef
operator|->
name|got
operator|=
operator|(
name|Elf_Addr
operator|*
operator|)
operator|(
name|ef
operator|->
name|address
operator|+
name|dp
operator|->
name|d_un
operator|.
name|d_ptr
operator|)
expr_stmt|;
break|break;
case|case
name|DT_REL
case|:
name|ef
operator|->
name|rel
operator|=
operator|(
specifier|const
name|Elf_Rel
operator|*
operator|)
operator|(
name|ef
operator|->
name|address
operator|+
name|dp
operator|->
name|d_un
operator|.
name|d_ptr
operator|)
expr_stmt|;
break|break;
case|case
name|DT_RELSZ
case|:
name|ef
operator|->
name|relsize
operator|=
name|dp
operator|->
name|d_un
operator|.
name|d_val
expr_stmt|;
break|break;
case|case
name|DT_RELENT
case|:
if|if
condition|(
name|dp
operator|->
name|d_un
operator|.
name|d_val
operator|!=
sizeof|sizeof
argument_list|(
name|Elf_Rel
argument_list|)
condition|)
return|return
name|ENOEXEC
return|;
break|break;
case|case
name|DT_JMPREL
case|:
name|ef
operator|->
name|pltrel
operator|=
operator|(
specifier|const
name|Elf_Rel
operator|*
operator|)
operator|(
name|ef
operator|->
name|address
operator|+
name|dp
operator|->
name|d_un
operator|.
name|d_ptr
operator|)
expr_stmt|;
break|break;
case|case
name|DT_PLTRELSZ
case|:
name|ef
operator|->
name|pltrelsize
operator|=
name|dp
operator|->
name|d_un
operator|.
name|d_val
expr_stmt|;
break|break;
case|case
name|DT_RELA
case|:
name|ef
operator|->
name|rela
operator|=
operator|(
specifier|const
name|Elf_Rela
operator|*
operator|)
operator|(
name|ef
operator|->
name|address
operator|+
name|dp
operator|->
name|d_un
operator|.
name|d_ptr
operator|)
expr_stmt|;
break|break;
case|case
name|DT_RELASZ
case|:
name|ef
operator|->
name|relasize
operator|=
name|dp
operator|->
name|d_un
operator|.
name|d_val
expr_stmt|;
break|break;
case|case
name|DT_RELAENT
case|:
if|if
condition|(
name|dp
operator|->
name|d_un
operator|.
name|d_val
operator|!=
sizeof|sizeof
argument_list|(
name|Elf_Rela
argument_list|)
condition|)
return|return
name|ENOEXEC
return|;
break|break;
case|case
name|DT_PLTREL
case|:
name|plttype
operator|=
name|dp
operator|->
name|d_un
operator|.
name|d_val
expr_stmt|;
if|if
condition|(
name|plttype
operator|!=
name|DT_REL
operator|&&
name|plttype
operator|!=
name|DT_RELA
condition|)
return|return
name|ENOEXEC
return|;
break|break;
ifdef|#
directive|ifdef
name|GDB
case|case
name|DT_DEBUG
case|:
name|dp
operator|->
name|d_un
operator|.
name|d_ptr
operator|=
operator|(
name|Elf_Addr
operator|)
operator|&
name|r_debug
expr_stmt|;
break|break;
endif|#
directive|endif
block|}
block|}
if|if
condition|(
name|plttype
operator|==
name|DT_RELA
condition|)
block|{
name|ef
operator|->
name|pltrela
operator|=
operator|(
specifier|const
name|Elf_Rela
operator|*
operator|)
name|ef
operator|->
name|pltrel
expr_stmt|;
name|ef
operator|->
name|pltrel
operator|=
name|NULL
expr_stmt|;
name|ef
operator|->
name|pltrelasize
operator|=
name|ef
operator|->
name|pltrelsize
expr_stmt|;
name|ef
operator|->
name|pltrelsize
operator|=
literal|0
expr_stmt|;
block|}
name|ef
operator|->
name|ddbsymtab
operator|=
name|ef
operator|->
name|symtab
expr_stmt|;
name|ef
operator|->
name|ddbsymcnt
operator|=
name|ef
operator|->
name|nchains
expr_stmt|;
name|ef
operator|->
name|ddbstrtab
operator|=
name|ef
operator|->
name|strtab
expr_stmt|;
name|ef
operator|->
name|ddbstrcnt
operator|=
name|ef
operator|->
name|strsz
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|link_elf_link_preload
parameter_list|(
name|linker_class_t
name|cls
parameter_list|,
specifier|const
name|char
modifier|*
name|filename
parameter_list|,
name|linker_file_t
modifier|*
name|result
parameter_list|)
block|{
name|caddr_t
name|modptr
decl_stmt|,
name|baseptr
decl_stmt|,
name|sizeptr
decl_stmt|,
name|dynptr
decl_stmt|;
name|char
modifier|*
name|type
decl_stmt|;
name|elf_file_t
name|ef
decl_stmt|;
name|linker_file_t
name|lf
decl_stmt|;
name|int
name|error
decl_stmt|;
name|vm_offset_t
name|dp
decl_stmt|;
comment|/* Look to see if we have the file preloaded */
name|modptr
operator|=
name|preload_search_by_name
argument_list|(
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|modptr
operator|==
name|NULL
condition|)
return|return
name|ENOENT
return|;
name|type
operator|=
operator|(
name|char
operator|*
operator|)
name|preload_search_info
argument_list|(
name|modptr
argument_list|,
name|MODINFO_TYPE
argument_list|)
expr_stmt|;
name|baseptr
operator|=
name|preload_search_info
argument_list|(
name|modptr
argument_list|,
name|MODINFO_ADDR
argument_list|)
expr_stmt|;
name|sizeptr
operator|=
name|preload_search_info
argument_list|(
name|modptr
argument_list|,
name|MODINFO_SIZE
argument_list|)
expr_stmt|;
name|dynptr
operator|=
name|preload_search_info
argument_list|(
name|modptr
argument_list|,
name|MODINFO_METADATA
operator||
name|MODINFOMD_DYNAMIC
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|NULL
operator|||
operator|(
name|strcmp
argument_list|(
name|type
argument_list|,
literal|"elf"
name|__XSTRING
argument_list|(
name|__ELF_WORD_SIZE
argument_list|)
literal|" module"
argument_list|)
operator|!=
literal|0
operator|&&
name|strcmp
argument_list|(
name|type
argument_list|,
literal|"elf module"
argument_list|)
operator|!=
literal|0
operator|)
condition|)
return|return
operator|(
name|EFTYPE
operator|)
return|;
if|if
condition|(
name|baseptr
operator|==
name|NULL
operator|||
name|sizeptr
operator|==
name|NULL
operator|||
name|dynptr
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|lf
operator|=
name|linker_make_file
argument_list|(
name|filename
argument_list|,
operator|&
name|link_elf_class
argument_list|)
expr_stmt|;
if|if
condition|(
name|lf
operator|==
name|NULL
condition|)
block|{
return|return
name|ENOMEM
return|;
block|}
name|ef
operator|=
operator|(
name|elf_file_t
operator|)
name|lf
expr_stmt|;
name|ef
operator|->
name|preloaded
operator|=
literal|1
expr_stmt|;
name|ef
operator|->
name|modptr
operator|=
name|modptr
expr_stmt|;
name|ef
operator|->
name|address
operator|=
operator|*
operator|(
name|caddr_t
operator|*
operator|)
name|baseptr
expr_stmt|;
ifdef|#
directive|ifdef
name|SPARSE_MAPPING
name|ef
operator|->
name|object
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|dp
operator|=
operator|(
name|vm_offset_t
operator|)
name|ef
operator|->
name|address
operator|+
operator|*
operator|(
name|vm_offset_t
operator|*
operator|)
name|dynptr
expr_stmt|;
name|ef
operator|->
name|dynamic
operator|=
operator|(
name|Elf_Dyn
operator|*
operator|)
name|dp
expr_stmt|;
name|lf
operator|->
name|address
operator|=
name|ef
operator|->
name|address
expr_stmt|;
name|lf
operator|->
name|size
operator|=
operator|*
operator|(
name|size_t
operator|*
operator|)
name|sizeptr
expr_stmt|;
name|error
operator|=
name|parse_dynamic
argument_list|(
name|ef
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|linker_file_unload
argument_list|(
name|lf
argument_list|,
name|LINKER_UNLOAD_FORCE
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
name|link_elf_reloc_local
argument_list|(
name|lf
argument_list|)
expr_stmt|;
operator|*
name|result
operator|=
name|lf
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|link_elf_link_preload_finish
parameter_list|(
name|linker_file_t
name|lf
parameter_list|)
block|{
name|elf_file_t
name|ef
decl_stmt|;
name|int
name|error
decl_stmt|;
name|ef
operator|=
operator|(
name|elf_file_t
operator|)
name|lf
expr_stmt|;
if|#
directive|if
literal|0
comment|/* this will be more trouble than it's worth for now */
block|for (dp = ef->dynamic; dp->d_tag != DT_NULL; dp++) { 	if (dp->d_tag != DT_NEEDED) 	    continue; 	modname = ef->strtab + dp->d_un.d_val; 	error = linker_load_module(modname, lf); 	if (error) 	    goto out;     }
endif|#
directive|endif
name|error
operator|=
name|relocate_file
argument_list|(
name|ef
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
operator|(
name|void
operator|)
name|link_elf_preload_parse_symbols
argument_list|(
name|ef
argument_list|)
expr_stmt|;
return|return
operator|(
name|link_elf_link_common_finish
argument_list|(
name|lf
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|link_elf_load_file
parameter_list|(
name|linker_class_t
name|cls
parameter_list|,
specifier|const
name|char
modifier|*
name|filename
parameter_list|,
name|linker_file_t
modifier|*
name|result
parameter_list|)
block|{
name|struct
name|nameidata
name|nd
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
init|=
name|curthread
decl_stmt|;
comment|/* XXX */
name|Elf_Ehdr
modifier|*
name|hdr
decl_stmt|;
name|caddr_t
name|firstpage
decl_stmt|;
name|int
name|nbytes
decl_stmt|,
name|i
decl_stmt|;
name|Elf_Phdr
modifier|*
name|phdr
decl_stmt|;
name|Elf_Phdr
modifier|*
name|phlimit
decl_stmt|;
name|Elf_Phdr
modifier|*
name|segs
index|[
name|MAXSEGS
index|]
decl_stmt|;
name|int
name|nsegs
decl_stmt|;
name|Elf_Phdr
modifier|*
name|phdyn
decl_stmt|;
name|Elf_Phdr
modifier|*
name|phphdr
decl_stmt|;
name|caddr_t
name|mapbase
decl_stmt|;
name|size_t
name|mapsize
decl_stmt|;
name|Elf_Off
name|base_offset
decl_stmt|;
name|Elf_Addr
name|base_vaddr
decl_stmt|;
name|Elf_Addr
name|base_vlimit
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|int
name|resid
decl_stmt|,
name|flags
decl_stmt|;
name|elf_file_t
name|ef
decl_stmt|;
name|linker_file_t
name|lf
decl_stmt|;
name|Elf_Shdr
modifier|*
name|shdr
decl_stmt|;
name|int
name|symtabindex
decl_stmt|;
name|int
name|symstrindex
decl_stmt|;
name|int
name|symcnt
decl_stmt|;
name|int
name|strcnt
decl_stmt|;
name|int
name|vfslocked
decl_stmt|;
name|shdr
operator|=
name|NULL
expr_stmt|;
name|lf
operator|=
name|NULL
expr_stmt|;
name|NDINIT
argument_list|(
operator|&
name|nd
argument_list|,
name|LOOKUP
argument_list|,
name|FOLLOW
operator||
name|MPSAFE
argument_list|,
name|UIO_SYSSPACE
argument_list|,
name|filename
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|flags
operator|=
name|FREAD
expr_stmt|;
name|error
operator|=
name|vn_open
argument_list|(
operator|&
name|nd
argument_list|,
operator|&
name|flags
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
name|vfslocked
operator|=
name|NDHASGIANT
argument_list|(
operator|&
name|nd
argument_list|)
expr_stmt|;
name|NDFREE
argument_list|(
operator|&
name|nd
argument_list|,
name|NDF_ONLY_PNBUF
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MAC
name|error
operator|=
name|mac_check_kld_load
argument_list|(
name|curthread
operator|->
name|td_ucred
argument_list|,
name|nd
operator|.
name|ni_vp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|firstpage
operator|=
name|NULL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
endif|#
directive|endif
comment|/*      * Read the elf header from the file.      */
name|firstpage
operator|=
name|malloc
argument_list|(
name|PAGE_SIZE
argument_list|,
name|M_LINKER
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
name|firstpage
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|hdr
operator|=
operator|(
name|Elf_Ehdr
operator|*
operator|)
name|firstpage
expr_stmt|;
name|error
operator|=
name|vn_rdwr
argument_list|(
name|UIO_READ
argument_list|,
name|nd
operator|.
name|ni_vp
argument_list|,
name|firstpage
argument_list|,
name|PAGE_SIZE
argument_list|,
literal|0
argument_list|,
name|UIO_SYSSPACE
argument_list|,
name|IO_NODELOCKED
argument_list|,
name|td
operator|->
name|td_ucred
argument_list|,
name|NOCRED
argument_list|,
operator|&
name|resid
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|nbytes
operator|=
name|PAGE_SIZE
operator|-
name|resid
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
operator|!
name|IS_ELF
argument_list|(
operator|*
name|hdr
argument_list|)
condition|)
block|{
name|error
operator|=
name|ENOEXEC
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|hdr
operator|->
name|e_ident
index|[
name|EI_CLASS
index|]
operator|!=
name|ELF_TARG_CLASS
operator|||
name|hdr
operator|->
name|e_ident
index|[
name|EI_DATA
index|]
operator|!=
name|ELF_TARG_DATA
condition|)
block|{
name|link_elf_error
argument_list|(
literal|"Unsupported file layout"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOEXEC
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|hdr
operator|->
name|e_ident
index|[
name|EI_VERSION
index|]
operator|!=
name|EV_CURRENT
operator|||
name|hdr
operator|->
name|e_version
operator|!=
name|EV_CURRENT
condition|)
block|{
name|link_elf_error
argument_list|(
literal|"Unsupported file version"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOEXEC
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|hdr
operator|->
name|e_type
operator|!=
name|ET_EXEC
operator|&&
name|hdr
operator|->
name|e_type
operator|!=
name|ET_DYN
condition|)
block|{
name|link_elf_error
argument_list|(
literal|"Unsupported file type"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOEXEC
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|hdr
operator|->
name|e_machine
operator|!=
name|ELF_TARG_MACH
condition|)
block|{
name|link_elf_error
argument_list|(
literal|"Unsupported machine"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOEXEC
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/*      * We rely on the program header being in the first page.  This is      * not strictly required by the ABI specification, but it seems to      * always true in practice.  And, it simplifies things considerably.      */
if|if
condition|(
operator|!
operator|(
operator|(
name|hdr
operator|->
name|e_phentsize
operator|==
sizeof|sizeof
argument_list|(
name|Elf_Phdr
argument_list|)
operator|)
operator|&&
operator|(
name|hdr
operator|->
name|e_phoff
operator|+
name|hdr
operator|->
name|e_phnum
operator|*
sizeof|sizeof
argument_list|(
name|Elf_Phdr
argument_list|)
operator|<=
name|PAGE_SIZE
operator|)
operator|&&
operator|(
name|hdr
operator|->
name|e_phoff
operator|+
name|hdr
operator|->
name|e_phnum
operator|*
sizeof|sizeof
argument_list|(
name|Elf_Phdr
argument_list|)
operator|<=
name|nbytes
operator|)
operator|)
condition|)
name|link_elf_error
argument_list|(
literal|"Unreadable program headers"
argument_list|)
expr_stmt|;
comment|/*      * Scan the program header entries, and save key information.      *      * We rely on there being exactly two load segments, text and data,      * in that order.      */
name|phdr
operator|=
operator|(
name|Elf_Phdr
operator|*
operator|)
operator|(
name|firstpage
operator|+
name|hdr
operator|->
name|e_phoff
operator|)
expr_stmt|;
name|phlimit
operator|=
name|phdr
operator|+
name|hdr
operator|->
name|e_phnum
expr_stmt|;
name|nsegs
operator|=
literal|0
expr_stmt|;
name|phdyn
operator|=
name|NULL
expr_stmt|;
name|phphdr
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
name|phdr
operator|<
name|phlimit
condition|)
block|{
switch|switch
condition|(
name|phdr
operator|->
name|p_type
condition|)
block|{
case|case
name|PT_LOAD
case|:
if|if
condition|(
name|nsegs
operator|==
name|MAXSEGS
condition|)
block|{
name|link_elf_error
argument_list|(
literal|"Too many sections"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOEXEC
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* 	     * XXX: We just trust they come in right order ?? 	     */
name|segs
index|[
name|nsegs
index|]
operator|=
name|phdr
expr_stmt|;
operator|++
name|nsegs
expr_stmt|;
break|break;
case|case
name|PT_PHDR
case|:
name|phphdr
operator|=
name|phdr
expr_stmt|;
break|break;
case|case
name|PT_DYNAMIC
case|:
name|phdyn
operator|=
name|phdr
expr_stmt|;
break|break;
case|case
name|PT_INTERP
case|:
name|link_elf_error
argument_list|(
literal|"Unsupported file type"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOEXEC
expr_stmt|;
goto|goto
name|out
goto|;
block|}
operator|++
name|phdr
expr_stmt|;
block|}
if|if
condition|(
name|phdyn
operator|==
name|NULL
condition|)
block|{
name|link_elf_error
argument_list|(
literal|"Object is not dynamically-linked"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOEXEC
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|nsegs
operator|==
literal|0
condition|)
block|{
name|link_elf_error
argument_list|(
literal|"No sections"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOEXEC
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/*      * Allocate the entire address space of the object, to stake out our      * contiguous region, and to establish the base address for relocation.      */
name|base_offset
operator|=
name|trunc_page
argument_list|(
name|segs
index|[
literal|0
index|]
operator|->
name|p_offset
argument_list|)
expr_stmt|;
name|base_vaddr
operator|=
name|trunc_page
argument_list|(
name|segs
index|[
literal|0
index|]
operator|->
name|p_vaddr
argument_list|)
expr_stmt|;
name|base_vlimit
operator|=
name|round_page
argument_list|(
name|segs
index|[
name|nsegs
operator|-
literal|1
index|]
operator|->
name|p_vaddr
operator|+
name|segs
index|[
name|nsegs
operator|-
literal|1
index|]
operator|->
name|p_memsz
argument_list|)
expr_stmt|;
name|mapsize
operator|=
name|base_vlimit
operator|-
name|base_vaddr
expr_stmt|;
name|lf
operator|=
name|linker_make_file
argument_list|(
name|filename
argument_list|,
operator|&
name|link_elf_class
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|lf
condition|)
block|{
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|ef
operator|=
operator|(
name|elf_file_t
operator|)
name|lf
expr_stmt|;
ifdef|#
directive|ifdef
name|SPARSE_MAPPING
name|ef
operator|->
name|object
operator|=
name|vm_object_allocate
argument_list|(
name|OBJT_DEFAULT
argument_list|,
name|mapsize
operator|>>
name|PAGE_SHIFT
argument_list|)
expr_stmt|;
if|if
condition|(
name|ef
operator|->
name|object
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|ef
operator|->
name|address
operator|=
operator|(
name|caddr_t
operator|)
name|vm_map_min
argument_list|(
name|kernel_map
argument_list|)
expr_stmt|;
name|error
operator|=
name|vm_map_find
argument_list|(
name|kernel_map
argument_list|,
name|ef
operator|->
name|object
argument_list|,
literal|0
argument_list|,
operator|(
name|vm_offset_t
operator|*
operator|)
operator|&
name|ef
operator|->
name|address
argument_list|,
name|mapsize
argument_list|,
literal|1
argument_list|,
name|VM_PROT_ALL
argument_list|,
name|VM_PROT_ALL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|vm_object_deallocate
argument_list|(
name|ef
operator|->
name|object
argument_list|)
expr_stmt|;
name|ef
operator|->
name|object
operator|=
literal|0
expr_stmt|;
goto|goto
name|out
goto|;
block|}
else|#
directive|else
name|ef
operator|->
name|address
operator|=
name|malloc
argument_list|(
name|mapsize
argument_list|,
name|M_LINKER
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ef
operator|->
name|address
condition|)
block|{
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|out
goto|;
block|}
endif|#
directive|endif
name|mapbase
operator|=
name|ef
operator|->
name|address
expr_stmt|;
comment|/*      * Read the text and data sections and zero the bss.      */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nsegs
condition|;
name|i
operator|++
control|)
block|{
name|caddr_t
name|segbase
init|=
name|mapbase
operator|+
name|segs
index|[
name|i
index|]
operator|->
name|p_vaddr
operator|-
name|base_vaddr
decl_stmt|;
name|error
operator|=
name|vn_rdwr
argument_list|(
name|UIO_READ
argument_list|,
name|nd
operator|.
name|ni_vp
argument_list|,
name|segbase
argument_list|,
name|segs
index|[
name|i
index|]
operator|->
name|p_filesz
argument_list|,
name|segs
index|[
name|i
index|]
operator|->
name|p_offset
argument_list|,
name|UIO_SYSSPACE
argument_list|,
name|IO_NODELOCKED
argument_list|,
name|td
operator|->
name|td_ucred
argument_list|,
name|NOCRED
argument_list|,
operator|&
name|resid
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
goto|goto
name|out
goto|;
block|}
name|bzero
argument_list|(
name|segbase
operator|+
name|segs
index|[
name|i
index|]
operator|->
name|p_filesz
argument_list|,
name|segs
index|[
name|i
index|]
operator|->
name|p_memsz
operator|-
name|segs
index|[
name|i
index|]
operator|->
name|p_filesz
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SPARSE_MAPPING
comment|/* 	 * Wire down the pages 	 */
name|error
operator|=
name|vm_map_wire
argument_list|(
name|kernel_map
argument_list|,
operator|(
name|vm_offset_t
operator|)
name|segbase
argument_list|,
operator|(
name|vm_offset_t
operator|)
name|segbase
operator|+
name|segs
index|[
name|i
index|]
operator|->
name|p_memsz
argument_list|,
name|VM_MAP_WIRE_SYSTEM
operator||
name|VM_MAP_WIRE_NOHOLES
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
name|KERN_SUCCESS
condition|)
block|{
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|out
goto|;
block|}
endif|#
directive|endif
block|}
ifdef|#
directive|ifdef
name|GPROF
comment|/* Update profiling information with the new text segment. */
name|mtx_lock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
name|kmupetext
argument_list|(
call|(
name|uintfptr_t
call|)
argument_list|(
name|mapbase
operator|+
name|segs
index|[
literal|0
index|]
operator|->
name|p_vaddr
operator|-
name|base_vaddr
operator|+
name|segs
index|[
literal|0
index|]
operator|->
name|p_memsz
argument_list|)
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ef
operator|->
name|dynamic
operator|=
operator|(
name|Elf_Dyn
operator|*
operator|)
operator|(
name|mapbase
operator|+
name|phdyn
operator|->
name|p_vaddr
operator|-
name|base_vaddr
operator|)
expr_stmt|;
name|lf
operator|->
name|address
operator|=
name|ef
operator|->
name|address
expr_stmt|;
name|lf
operator|->
name|size
operator|=
name|mapsize
expr_stmt|;
name|error
operator|=
name|parse_dynamic
argument_list|(
name|ef
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
name|link_elf_reloc_local
argument_list|(
name|lf
argument_list|)
expr_stmt|;
name|error
operator|=
name|linker_load_dependencies
argument_list|(
name|lf
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
if|#
directive|if
literal|0
comment|/* this will be more trouble than it's worth for now */
block|for (dp = ef->dynamic; dp->d_tag != DT_NULL; dp++) { 	if (dp->d_tag != DT_NEEDED) 	    continue; 	modname = ef->strtab + dp->d_un.d_val; 	error = linker_load_module(modname, lf); 	if (error) 	    goto out;     }
endif|#
directive|endif
name|error
operator|=
name|relocate_file
argument_list|(
name|ef
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
comment|/* Try and load the symbol table if it's present.  (you can strip it!) */
name|nbytes
operator|=
name|hdr
operator|->
name|e_shnum
operator|*
name|hdr
operator|->
name|e_shentsize
expr_stmt|;
if|if
condition|(
name|nbytes
operator|==
literal|0
operator|||
name|hdr
operator|->
name|e_shoff
operator|==
literal|0
condition|)
goto|goto
name|nosyms
goto|;
name|shdr
operator|=
name|malloc
argument_list|(
name|nbytes
argument_list|,
name|M_LINKER
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|shdr
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|error
operator|=
name|vn_rdwr
argument_list|(
name|UIO_READ
argument_list|,
name|nd
operator|.
name|ni_vp
argument_list|,
operator|(
name|caddr_t
operator|)
name|shdr
argument_list|,
name|nbytes
argument_list|,
name|hdr
operator|->
name|e_shoff
argument_list|,
name|UIO_SYSSPACE
argument_list|,
name|IO_NODELOCKED
argument_list|,
name|td
operator|->
name|td_ucred
argument_list|,
name|NOCRED
argument_list|,
operator|&
name|resid
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
name|symtabindex
operator|=
operator|-
literal|1
expr_stmt|;
name|symstrindex
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|hdr
operator|->
name|e_shnum
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|shdr
index|[
name|i
index|]
operator|.
name|sh_type
operator|==
name|SHT_SYMTAB
condition|)
block|{
name|symtabindex
operator|=
name|i
expr_stmt|;
name|symstrindex
operator|=
name|shdr
index|[
name|i
index|]
operator|.
name|sh_link
expr_stmt|;
block|}
block|}
if|if
condition|(
name|symtabindex
operator|<
literal|0
operator|||
name|symstrindex
operator|<
literal|0
condition|)
goto|goto
name|nosyms
goto|;
name|symcnt
operator|=
name|shdr
index|[
name|symtabindex
index|]
operator|.
name|sh_size
expr_stmt|;
name|ef
operator|->
name|symbase
operator|=
name|malloc
argument_list|(
name|symcnt
argument_list|,
name|M_LINKER
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|strcnt
operator|=
name|shdr
index|[
name|symstrindex
index|]
operator|.
name|sh_size
expr_stmt|;
name|ef
operator|->
name|strbase
operator|=
name|malloc
argument_list|(
name|strcnt
argument_list|,
name|M_LINKER
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
name|ef
operator|->
name|symbase
operator|==
name|NULL
operator|||
name|ef
operator|->
name|strbase
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|error
operator|=
name|vn_rdwr
argument_list|(
name|UIO_READ
argument_list|,
name|nd
operator|.
name|ni_vp
argument_list|,
name|ef
operator|->
name|symbase
argument_list|,
name|symcnt
argument_list|,
name|shdr
index|[
name|symtabindex
index|]
operator|.
name|sh_offset
argument_list|,
name|UIO_SYSSPACE
argument_list|,
name|IO_NODELOCKED
argument_list|,
name|td
operator|->
name|td_ucred
argument_list|,
name|NOCRED
argument_list|,
operator|&
name|resid
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
name|error
operator|=
name|vn_rdwr
argument_list|(
name|UIO_READ
argument_list|,
name|nd
operator|.
name|ni_vp
argument_list|,
name|ef
operator|->
name|strbase
argument_list|,
name|strcnt
argument_list|,
name|shdr
index|[
name|symstrindex
index|]
operator|.
name|sh_offset
argument_list|,
name|UIO_SYSSPACE
argument_list|,
name|IO_NODELOCKED
argument_list|,
name|td
operator|->
name|td_ucred
argument_list|,
name|NOCRED
argument_list|,
operator|&
name|resid
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
name|ef
operator|->
name|ddbsymcnt
operator|=
name|symcnt
operator|/
sizeof|sizeof
argument_list|(
name|Elf_Sym
argument_list|)
expr_stmt|;
name|ef
operator|->
name|ddbsymtab
operator|=
operator|(
specifier|const
name|Elf_Sym
operator|*
operator|)
name|ef
operator|->
name|symbase
expr_stmt|;
name|ef
operator|->
name|ddbstrcnt
operator|=
name|strcnt
expr_stmt|;
name|ef
operator|->
name|ddbstrtab
operator|=
name|ef
operator|->
name|strbase
expr_stmt|;
name|error
operator|=
name|link_elf_link_common_finish
argument_list|(
name|lf
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
name|nosyms
label|:
operator|*
name|result
operator|=
name|lf
expr_stmt|;
name|out
label|:
if|if
condition|(
name|error
operator|&&
name|lf
condition|)
name|linker_file_unload
argument_list|(
name|lf
argument_list|,
name|LINKER_UNLOAD_FORCE
argument_list|)
expr_stmt|;
if|if
condition|(
name|shdr
condition|)
name|free
argument_list|(
name|shdr
argument_list|,
name|M_LINKER
argument_list|)
expr_stmt|;
if|if
condition|(
name|firstpage
condition|)
name|free
argument_list|(
name|firstpage
argument_list|,
name|M_LINKER
argument_list|)
expr_stmt|;
name|VOP_UNLOCK
argument_list|(
name|nd
operator|.
name|ni_vp
argument_list|,
literal|0
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|vn_close
argument_list|(
name|nd
operator|.
name|ni_vp
argument_list|,
name|FREAD
argument_list|,
name|td
operator|->
name|td_ucred
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|VFS_UNLOCK_GIANT
argument_list|(
name|vfslocked
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|link_elf_unload_file
parameter_list|(
name|linker_file_t
name|file
parameter_list|)
block|{
name|elf_file_t
name|ef
init|=
operator|(
name|elf_file_t
operator|)
name|file
decl_stmt|;
ifdef|#
directive|ifdef
name|GDB
if|if
condition|(
name|ef
operator|->
name|gdb
operator|.
name|l_ld
condition|)
block|{
name|GDB_STATE
argument_list|(
name|RT_DELETE
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|ef
operator|->
name|gdb
operator|.
name|l_name
argument_list|,
name|M_LINKER
argument_list|)
expr_stmt|;
name|link_elf_delete_gdb
argument_list|(
operator|&
name|ef
operator|->
name|gdb
argument_list|)
expr_stmt|;
name|GDB_STATE
argument_list|(
name|RT_CONSISTENT
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Notify MD code that a module is being unloaded. */
name|elf_cpu_unload_file
argument_list|(
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|ef
operator|->
name|preloaded
condition|)
block|{
name|link_elf_unload_preload
argument_list|(
name|file
argument_list|)
expr_stmt|;
return|return;
block|}
ifdef|#
directive|ifdef
name|SPARSE_MAPPING
if|if
condition|(
name|ef
operator|->
name|object
condition|)
block|{
name|vm_map_remove
argument_list|(
name|kernel_map
argument_list|,
operator|(
name|vm_offset_t
operator|)
name|ef
operator|->
name|address
argument_list|,
operator|(
name|vm_offset_t
operator|)
name|ef
operator|->
name|address
operator|+
operator|(
name|ef
operator|->
name|object
operator|->
name|size
operator|<<
name|PAGE_SHIFT
operator|)
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
if|if
condition|(
name|ef
operator|->
name|address
condition|)
name|free
argument_list|(
name|ef
operator|->
name|address
argument_list|,
name|M_LINKER
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|ef
operator|->
name|symbase
condition|)
name|free
argument_list|(
name|ef
operator|->
name|symbase
argument_list|,
name|M_LINKER
argument_list|)
expr_stmt|;
if|if
condition|(
name|ef
operator|->
name|strbase
condition|)
name|free
argument_list|(
name|ef
operator|->
name|strbase
argument_list|,
name|M_LINKER
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|link_elf_unload_preload
parameter_list|(
name|linker_file_t
name|file
parameter_list|)
block|{
if|if
condition|(
name|file
operator|->
name|filename
condition|)
name|preload_delete_name
argument_list|(
name|file
operator|->
name|filename
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|symbol_name
parameter_list|(
name|elf_file_t
name|ef
parameter_list|,
name|Elf_Size
name|r_info
parameter_list|)
block|{
specifier|const
name|Elf_Sym
modifier|*
name|ref
decl_stmt|;
if|if
condition|(
name|ELF_R_SYM
argument_list|(
name|r_info
argument_list|)
condition|)
block|{
name|ref
operator|=
name|ef
operator|->
name|symtab
operator|+
name|ELF_R_SYM
argument_list|(
name|r_info
argument_list|)
expr_stmt|;
return|return
name|ef
operator|->
name|strtab
operator|+
name|ref
operator|->
name|st_name
return|;
block|}
else|else
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|relocate_file
parameter_list|(
name|elf_file_t
name|ef
parameter_list|)
block|{
specifier|const
name|Elf_Rel
modifier|*
name|rellim
decl_stmt|;
specifier|const
name|Elf_Rel
modifier|*
name|rel
decl_stmt|;
specifier|const
name|Elf_Rela
modifier|*
name|relalim
decl_stmt|;
specifier|const
name|Elf_Rela
modifier|*
name|rela
decl_stmt|;
specifier|const
name|char
modifier|*
name|symname
decl_stmt|;
comment|/* Perform relocations without addend if there are any: */
name|rel
operator|=
name|ef
operator|->
name|rel
expr_stmt|;
if|if
condition|(
name|rel
condition|)
block|{
name|rellim
operator|=
operator|(
specifier|const
name|Elf_Rel
operator|*
operator|)
operator|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|ef
operator|->
name|rel
operator|+
name|ef
operator|->
name|relsize
operator|)
expr_stmt|;
while|while
condition|(
name|rel
operator|<
name|rellim
condition|)
block|{
if|if
condition|(
name|elf_reloc
argument_list|(
operator|&
name|ef
operator|->
name|lf
argument_list|,
operator|(
name|Elf_Addr
operator|)
name|ef
operator|->
name|address
argument_list|,
name|rel
argument_list|,
name|ELF_RELOC_REL
argument_list|,
name|elf_lookup
argument_list|)
condition|)
block|{
name|symname
operator|=
name|symbol_name
argument_list|(
name|ef
argument_list|,
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"link_elf: symbol %s undefined\n"
argument_list|,
name|symname
argument_list|)
expr_stmt|;
return|return
name|ENOENT
return|;
block|}
name|rel
operator|++
expr_stmt|;
block|}
block|}
comment|/* Perform relocations with addend if there are any: */
name|rela
operator|=
name|ef
operator|->
name|rela
expr_stmt|;
if|if
condition|(
name|rela
condition|)
block|{
name|relalim
operator|=
operator|(
specifier|const
name|Elf_Rela
operator|*
operator|)
operator|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|ef
operator|->
name|rela
operator|+
name|ef
operator|->
name|relasize
operator|)
expr_stmt|;
while|while
condition|(
name|rela
operator|<
name|relalim
condition|)
block|{
if|if
condition|(
name|elf_reloc
argument_list|(
operator|&
name|ef
operator|->
name|lf
argument_list|,
operator|(
name|Elf_Addr
operator|)
name|ef
operator|->
name|address
argument_list|,
name|rela
argument_list|,
name|ELF_RELOC_RELA
argument_list|,
name|elf_lookup
argument_list|)
condition|)
block|{
name|symname
operator|=
name|symbol_name
argument_list|(
name|ef
argument_list|,
name|rela
operator|->
name|r_info
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"link_elf: symbol %s undefined\n"
argument_list|,
name|symname
argument_list|)
expr_stmt|;
return|return
name|ENOENT
return|;
block|}
name|rela
operator|++
expr_stmt|;
block|}
block|}
comment|/* Perform PLT relocations without addend if there are any: */
name|rel
operator|=
name|ef
operator|->
name|pltrel
expr_stmt|;
if|if
condition|(
name|rel
condition|)
block|{
name|rellim
operator|=
operator|(
specifier|const
name|Elf_Rel
operator|*
operator|)
operator|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|ef
operator|->
name|pltrel
operator|+
name|ef
operator|->
name|pltrelsize
operator|)
expr_stmt|;
while|while
condition|(
name|rel
operator|<
name|rellim
condition|)
block|{
if|if
condition|(
name|elf_reloc
argument_list|(
operator|&
name|ef
operator|->
name|lf
argument_list|,
operator|(
name|Elf_Addr
operator|)
name|ef
operator|->
name|address
argument_list|,
name|rel
argument_list|,
name|ELF_RELOC_REL
argument_list|,
name|elf_lookup
argument_list|)
condition|)
block|{
name|symname
operator|=
name|symbol_name
argument_list|(
name|ef
argument_list|,
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"link_elf: symbol %s undefined\n"
argument_list|,
name|symname
argument_list|)
expr_stmt|;
return|return
name|ENOENT
return|;
block|}
name|rel
operator|++
expr_stmt|;
block|}
block|}
comment|/* Perform relocations with addend if there are any: */
name|rela
operator|=
name|ef
operator|->
name|pltrela
expr_stmt|;
if|if
condition|(
name|rela
condition|)
block|{
name|relalim
operator|=
operator|(
specifier|const
name|Elf_Rela
operator|*
operator|)
operator|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|ef
operator|->
name|pltrela
operator|+
name|ef
operator|->
name|pltrelasize
operator|)
expr_stmt|;
while|while
condition|(
name|rela
operator|<
name|relalim
condition|)
block|{
if|if
condition|(
name|elf_reloc
argument_list|(
operator|&
name|ef
operator|->
name|lf
argument_list|,
operator|(
name|Elf_Addr
operator|)
name|ef
operator|->
name|address
argument_list|,
name|rela
argument_list|,
name|ELF_RELOC_RELA
argument_list|,
name|elf_lookup
argument_list|)
condition|)
block|{
name|symname
operator|=
name|symbol_name
argument_list|(
name|ef
argument_list|,
name|rela
operator|->
name|r_info
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"link_elf: symbol %s undefined\n"
argument_list|,
name|symname
argument_list|)
expr_stmt|;
return|return
name|ENOENT
return|;
block|}
name|rela
operator|++
expr_stmt|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Hash function for symbol table lookup.  Don't even think about changing  * this.  It is specified by the System V ABI.  */
end_comment

begin_function
specifier|static
name|unsigned
name|long
name|elf_hash
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
specifier|const
name|unsigned
name|char
modifier|*
name|p
init|=
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
name|name
decl_stmt|;
name|unsigned
name|long
name|h
init|=
literal|0
decl_stmt|;
name|unsigned
name|long
name|g
decl_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|'\0'
condition|)
block|{
name|h
operator|=
operator|(
name|h
operator|<<
literal|4
operator|)
operator|+
operator|*
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|g
operator|=
name|h
operator|&
literal|0xf0000000
operator|)
operator|!=
literal|0
condition|)
name|h
operator|^=
name|g
operator|>>
literal|24
expr_stmt|;
name|h
operator|&=
operator|~
name|g
expr_stmt|;
block|}
return|return
name|h
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|link_elf_lookup_symbol
parameter_list|(
name|linker_file_t
name|lf
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|c_linker_sym_t
modifier|*
name|sym
parameter_list|)
block|{
name|elf_file_t
name|ef
init|=
operator|(
name|elf_file_t
operator|)
name|lf
decl_stmt|;
name|unsigned
name|long
name|symnum
decl_stmt|;
specifier|const
name|Elf_Sym
modifier|*
name|symp
decl_stmt|;
specifier|const
name|char
modifier|*
name|strp
decl_stmt|;
name|unsigned
name|long
name|hash
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* If we don't have a hash, bail. */
if|if
condition|(
name|ef
operator|->
name|buckets
operator|==
name|NULL
operator|||
name|ef
operator|->
name|nbuckets
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"link_elf_lookup_symbol: missing symbol hash table\n"
argument_list|)
expr_stmt|;
return|return
name|ENOENT
return|;
block|}
comment|/* First, search hashed global symbols */
name|hash
operator|=
name|elf_hash
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|symnum
operator|=
name|ef
operator|->
name|buckets
index|[
name|hash
operator|%
name|ef
operator|->
name|nbuckets
index|]
expr_stmt|;
while|while
condition|(
name|symnum
operator|!=
name|STN_UNDEF
condition|)
block|{
if|if
condition|(
name|symnum
operator|>=
name|ef
operator|->
name|nchains
condition|)
block|{
name|printf
argument_list|(
literal|"link_elf_lookup_symbol: corrupt symbol table\n"
argument_list|)
expr_stmt|;
return|return
name|ENOENT
return|;
block|}
name|symp
operator|=
name|ef
operator|->
name|symtab
operator|+
name|symnum
expr_stmt|;
if|if
condition|(
name|symp
operator|->
name|st_name
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"link_elf_lookup_symbol: corrupt symbol table\n"
argument_list|)
expr_stmt|;
return|return
name|ENOENT
return|;
block|}
name|strp
operator|=
name|ef
operator|->
name|strtab
operator|+
name|symp
operator|->
name|st_name
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|strp
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|symp
operator|->
name|st_shndx
operator|!=
name|SHN_UNDEF
operator|||
operator|(
name|symp
operator|->
name|st_value
operator|!=
literal|0
operator|&&
name|ELF_ST_TYPE
argument_list|(
name|symp
operator|->
name|st_info
argument_list|)
operator|==
name|STT_FUNC
operator|)
condition|)
block|{
operator|*
name|sym
operator|=
operator|(
name|c_linker_sym_t
operator|)
name|symp
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
return|return
name|ENOENT
return|;
block|}
name|symnum
operator|=
name|ef
operator|->
name|chains
index|[
name|symnum
index|]
expr_stmt|;
block|}
comment|/* If we have not found it, look at the full table (if loaded) */
if|if
condition|(
name|ef
operator|->
name|symtab
operator|==
name|ef
operator|->
name|ddbsymtab
condition|)
return|return
name|ENOENT
return|;
comment|/* Exhaustive search */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|symp
operator|=
name|ef
operator|->
name|ddbsymtab
init|;
name|i
operator|<
name|ef
operator|->
name|ddbsymcnt
condition|;
name|i
operator|++
operator|,
name|symp
operator|++
control|)
block|{
name|strp
operator|=
name|ef
operator|->
name|ddbstrtab
operator|+
name|symp
operator|->
name|st_name
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|strp
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|symp
operator|->
name|st_shndx
operator|!=
name|SHN_UNDEF
operator|||
operator|(
name|symp
operator|->
name|st_value
operator|!=
literal|0
operator|&&
name|ELF_ST_TYPE
argument_list|(
name|symp
operator|->
name|st_info
argument_list|)
operator|==
name|STT_FUNC
operator|)
condition|)
block|{
operator|*
name|sym
operator|=
operator|(
name|c_linker_sym_t
operator|)
name|symp
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
return|return
name|ENOENT
return|;
block|}
block|}
return|return
name|ENOENT
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|link_elf_symbol_values
parameter_list|(
name|linker_file_t
name|lf
parameter_list|,
name|c_linker_sym_t
name|sym
parameter_list|,
name|linker_symval_t
modifier|*
name|symval
parameter_list|)
block|{
name|elf_file_t
name|ef
init|=
operator|(
name|elf_file_t
operator|)
name|lf
decl_stmt|;
specifier|const
name|Elf_Sym
modifier|*
name|es
init|=
operator|(
specifier|const
name|Elf_Sym
operator|*
operator|)
name|sym
decl_stmt|;
if|if
condition|(
name|es
operator|>=
name|ef
operator|->
name|symtab
operator|&&
name|es
operator|<
operator|(
name|ef
operator|->
name|symtab
operator|+
name|ef
operator|->
name|nchains
operator|)
condition|)
block|{
name|symval
operator|->
name|name
operator|=
name|ef
operator|->
name|strtab
operator|+
name|es
operator|->
name|st_name
expr_stmt|;
name|symval
operator|->
name|value
operator|=
operator|(
name|caddr_t
operator|)
name|ef
operator|->
name|address
operator|+
name|es
operator|->
name|st_value
expr_stmt|;
name|symval
operator|->
name|size
operator|=
name|es
operator|->
name|st_size
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|ef
operator|->
name|symtab
operator|==
name|ef
operator|->
name|ddbsymtab
condition|)
return|return
name|ENOENT
return|;
if|if
condition|(
name|es
operator|>=
name|ef
operator|->
name|ddbsymtab
operator|&&
name|es
operator|<
operator|(
name|ef
operator|->
name|ddbsymtab
operator|+
name|ef
operator|->
name|ddbsymcnt
operator|)
condition|)
block|{
name|symval
operator|->
name|name
operator|=
name|ef
operator|->
name|ddbstrtab
operator|+
name|es
operator|->
name|st_name
expr_stmt|;
name|symval
operator|->
name|value
operator|=
operator|(
name|caddr_t
operator|)
name|ef
operator|->
name|address
operator|+
name|es
operator|->
name|st_value
expr_stmt|;
name|symval
operator|->
name|size
operator|=
name|es
operator|->
name|st_size
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
name|ENOENT
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|link_elf_search_symbol
parameter_list|(
name|linker_file_t
name|lf
parameter_list|,
name|caddr_t
name|value
parameter_list|,
name|c_linker_sym_t
modifier|*
name|sym
parameter_list|,
name|long
modifier|*
name|diffp
parameter_list|)
block|{
name|elf_file_t
name|ef
init|=
operator|(
name|elf_file_t
operator|)
name|lf
decl_stmt|;
name|u_long
name|off
init|=
operator|(
name|uintptr_t
operator|)
operator|(
name|void
operator|*
operator|)
name|value
decl_stmt|;
name|u_long
name|diff
init|=
name|off
decl_stmt|;
name|u_long
name|st_value
decl_stmt|;
specifier|const
name|Elf_Sym
modifier|*
name|es
decl_stmt|;
specifier|const
name|Elf_Sym
modifier|*
name|best
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|es
operator|=
name|ef
operator|->
name|ddbsymtab
init|;
name|i
operator|<
name|ef
operator|->
name|ddbsymcnt
condition|;
name|i
operator|++
operator|,
name|es
operator|++
control|)
block|{
if|if
condition|(
name|es
operator|->
name|st_name
operator|==
literal|0
condition|)
continue|continue;
name|st_value
operator|=
name|es
operator|->
name|st_value
operator|+
operator|(
name|uintptr_t
operator|)
operator|(
name|void
operator|*
operator|)
name|ef
operator|->
name|address
expr_stmt|;
if|if
condition|(
name|off
operator|>=
name|st_value
condition|)
block|{
if|if
condition|(
name|off
operator|-
name|st_value
operator|<
name|diff
condition|)
block|{
name|diff
operator|=
name|off
operator|-
name|st_value
expr_stmt|;
name|best
operator|=
name|es
expr_stmt|;
if|if
condition|(
name|diff
operator|==
literal|0
condition|)
break|break;
block|}
elseif|else
if|if
condition|(
name|off
operator|-
name|st_value
operator|==
name|diff
condition|)
block|{
name|best
operator|=
name|es
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|best
operator|==
literal|0
condition|)
operator|*
name|diffp
operator|=
name|off
expr_stmt|;
else|else
operator|*
name|diffp
operator|=
name|diff
expr_stmt|;
operator|*
name|sym
operator|=
operator|(
name|c_linker_sym_t
operator|)
name|best
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Look up a linker set on an ELF system.  */
end_comment

begin_function
specifier|static
name|int
name|link_elf_lookup_set
parameter_list|(
name|linker_file_t
name|lf
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|void
modifier|*
modifier|*
modifier|*
name|startp
parameter_list|,
name|void
modifier|*
modifier|*
modifier|*
name|stopp
parameter_list|,
name|int
modifier|*
name|countp
parameter_list|)
block|{
name|c_linker_sym_t
name|sym
decl_stmt|;
name|linker_symval_t
name|symval
decl_stmt|;
name|char
modifier|*
name|setsym
decl_stmt|;
name|void
modifier|*
modifier|*
name|start
decl_stmt|,
modifier|*
modifier|*
name|stop
decl_stmt|;
name|int
name|len
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|,
name|count
decl_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
literal|"__start_set_"
argument_list|)
expr_stmt|;
comment|/* sizeof includes \0 */
name|setsym
operator|=
name|malloc
argument_list|(
name|len
argument_list|,
name|M_LINKER
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
name|setsym
operator|==
name|NULL
condition|)
return|return
name|ENOMEM
return|;
comment|/* get address of first entry */
name|snprintf
argument_list|(
name|setsym
argument_list|,
name|len
argument_list|,
literal|"%s%s"
argument_list|,
literal|"__start_set_"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|error
operator|=
name|link_elf_lookup_symbol
argument_list|(
name|lf
argument_list|,
name|setsym
argument_list|,
operator|&
name|sym
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
name|link_elf_symbol_values
argument_list|(
name|lf
argument_list|,
name|sym
argument_list|,
operator|&
name|symval
argument_list|)
expr_stmt|;
if|if
condition|(
name|symval
operator|.
name|value
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|ESRCH
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|start
operator|=
operator|(
name|void
operator|*
operator|*
operator|)
name|symval
operator|.
name|value
expr_stmt|;
comment|/* get address of last entry */
name|snprintf
argument_list|(
name|setsym
argument_list|,
name|len
argument_list|,
literal|"%s%s"
argument_list|,
literal|"__stop_set_"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|error
operator|=
name|link_elf_lookup_symbol
argument_list|(
name|lf
argument_list|,
name|setsym
argument_list|,
operator|&
name|sym
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
name|link_elf_symbol_values
argument_list|(
name|lf
argument_list|,
name|sym
argument_list|,
operator|&
name|symval
argument_list|)
expr_stmt|;
if|if
condition|(
name|symval
operator|.
name|value
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|ESRCH
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|stop
operator|=
operator|(
name|void
operator|*
operator|*
operator|)
name|symval
operator|.
name|value
expr_stmt|;
comment|/* and the number of entries */
name|count
operator|=
name|stop
operator|-
name|start
expr_stmt|;
comment|/* and copy out */
if|if
condition|(
name|startp
condition|)
operator|*
name|startp
operator|=
name|start
expr_stmt|;
if|if
condition|(
name|stopp
condition|)
operator|*
name|stopp
operator|=
name|stop
expr_stmt|;
if|if
condition|(
name|countp
condition|)
operator|*
name|countp
operator|=
name|count
expr_stmt|;
name|out
label|:
name|free
argument_list|(
name|setsym
argument_list|,
name|M_LINKER
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|link_elf_each_function_name
parameter_list|(
name|linker_file_t
name|file
parameter_list|,
name|int
function_decl|(
modifier|*
name|callback
function_decl|)
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
name|opaque
parameter_list|)
block|{
name|elf_file_t
name|ef
init|=
operator|(
name|elf_file_t
operator|)
name|file
decl_stmt|;
specifier|const
name|Elf_Sym
modifier|*
name|symp
decl_stmt|;
name|int
name|i
decl_stmt|,
name|error
decl_stmt|;
comment|/* Exhaustive search */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|symp
operator|=
name|ef
operator|->
name|ddbsymtab
init|;
name|i
operator|<
name|ef
operator|->
name|ddbsymcnt
condition|;
name|i
operator|++
operator|,
name|symp
operator|++
control|)
block|{
if|if
condition|(
name|symp
operator|->
name|st_value
operator|!=
literal|0
operator|&&
name|ELF_ST_TYPE
argument_list|(
name|symp
operator|->
name|st_info
argument_list|)
operator|==
name|STT_FUNC
condition|)
block|{
name|error
operator|=
name|callback
argument_list|(
name|ef
operator|->
name|ddbstrtab
operator|+
name|symp
operator|->
name|st_name
argument_list|,
name|opaque
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|__ia64__
end_ifdef

begin_comment
comment|/*  * Each KLD has its own GP. The GP value for each load module is given by  * DT_PLTGOT on ia64. We need GP to construct function descriptors, but  * don't have direct access to the ELF file structure. The link_elf_get_gp()  * function returns the GP given a pointer to a generic linker file struct.  */
end_comment

begin_function
name|Elf_Addr
name|link_elf_get_gp
parameter_list|(
name|linker_file_t
name|lf
parameter_list|)
block|{
name|elf_file_t
name|ef
init|=
operator|(
name|elf_file_t
operator|)
name|lf
decl_stmt|;
return|return
operator|(
name|Elf_Addr
operator|)
name|ef
operator|->
name|got
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|const
name|Elf_Sym
modifier|*
name|elf_get_sym
parameter_list|(
name|linker_file_t
name|lf
parameter_list|,
name|Elf_Size
name|symidx
parameter_list|)
block|{
name|elf_file_t
name|ef
init|=
operator|(
name|elf_file_t
operator|)
name|lf
decl_stmt|;
if|if
condition|(
name|symidx
operator|>=
name|ef
operator|->
name|nchains
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
return|return
operator|(
name|ef
operator|->
name|symtab
operator|+
name|symidx
operator|)
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|elf_get_symname
parameter_list|(
name|linker_file_t
name|lf
parameter_list|,
name|Elf_Size
name|symidx
parameter_list|)
block|{
name|elf_file_t
name|ef
init|=
operator|(
name|elf_file_t
operator|)
name|lf
decl_stmt|;
specifier|const
name|Elf_Sym
modifier|*
name|sym
decl_stmt|;
if|if
condition|(
name|symidx
operator|>=
name|ef
operator|->
name|nchains
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|sym
operator|=
name|ef
operator|->
name|symtab
operator|+
name|symidx
expr_stmt|;
return|return
operator|(
name|ef
operator|->
name|strtab
operator|+
name|sym
operator|->
name|st_name
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Symbol lookup function that can be used when the symbol index is known (ie  * in relocations). It uses the symbol index instead of doing a fully fledged  * hash table based lookup when such is valid. For example for local symbols.  * This is not only more efficient, it's also more correct. It's not always  * the case that the symbol can be found through the hash table.  */
end_comment

begin_function
specifier|static
name|Elf_Addr
name|elf_lookup
parameter_list|(
name|linker_file_t
name|lf
parameter_list|,
name|Elf_Size
name|symidx
parameter_list|,
name|int
name|deps
parameter_list|)
block|{
name|elf_file_t
name|ef
init|=
operator|(
name|elf_file_t
operator|)
name|lf
decl_stmt|;
specifier|const
name|Elf_Sym
modifier|*
name|sym
decl_stmt|;
specifier|const
name|char
modifier|*
name|symbol
decl_stmt|;
comment|/* Don't even try to lookup the symbol if the index is bogus. */
if|if
condition|(
name|symidx
operator|>=
name|ef
operator|->
name|nchains
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|sym
operator|=
name|ef
operator|->
name|symtab
operator|+
name|symidx
expr_stmt|;
comment|/* 	 * Don't do a full lookup when the symbol is local. It may even 	 * fail because it may not be found through the hash table. 	 */
if|if
condition|(
name|ELF_ST_BIND
argument_list|(
name|sym
operator|->
name|st_info
argument_list|)
operator|==
name|STB_LOCAL
condition|)
block|{
comment|/* Force lookup failure when we have an insanity. */
if|if
condition|(
name|sym
operator|->
name|st_shndx
operator|==
name|SHN_UNDEF
operator|||
name|sym
operator|->
name|st_value
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
operator|(
name|Elf_Addr
operator|)
name|ef
operator|->
name|address
operator|+
name|sym
operator|->
name|st_value
operator|)
return|;
block|}
comment|/* 	 * XXX we can avoid doing a hash table based lookup for global 	 * symbols as well. This however is not always valid, so we'll 	 * just do it the hard way for now. Performance tweaks can 	 * always be added. 	 */
name|symbol
operator|=
name|ef
operator|->
name|strtab
operator|+
name|sym
operator|->
name|st_name
expr_stmt|;
comment|/* Force a lookup failure if the symbol name is bogus. */
if|if
condition|(
operator|*
name|symbol
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
operator|(
name|Elf_Addr
operator|)
name|linker_file_lookup_symbol
argument_list|(
name|lf
argument_list|,
name|symbol
argument_list|,
name|deps
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|link_elf_reloc_local
parameter_list|(
name|linker_file_t
name|lf
parameter_list|)
block|{
specifier|const
name|Elf_Rel
modifier|*
name|rellim
decl_stmt|;
specifier|const
name|Elf_Rel
modifier|*
name|rel
decl_stmt|;
specifier|const
name|Elf_Rela
modifier|*
name|relalim
decl_stmt|;
specifier|const
name|Elf_Rela
modifier|*
name|rela
decl_stmt|;
name|elf_file_t
name|ef
init|=
operator|(
name|elf_file_t
operator|)
name|lf
decl_stmt|;
comment|/* Perform relocations without addend if there are any: */
if|if
condition|(
operator|(
name|rel
operator|=
name|ef
operator|->
name|rel
operator|)
operator|!=
name|NULL
condition|)
block|{
name|rellim
operator|=
operator|(
specifier|const
name|Elf_Rel
operator|*
operator|)
operator|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|ef
operator|->
name|rel
operator|+
name|ef
operator|->
name|relsize
operator|)
expr_stmt|;
while|while
condition|(
name|rel
operator|<
name|rellim
condition|)
block|{
name|elf_reloc_local
argument_list|(
name|lf
argument_list|,
operator|(
name|Elf_Addr
operator|)
name|ef
operator|->
name|address
argument_list|,
name|rel
argument_list|,
name|ELF_RELOC_REL
argument_list|,
name|elf_lookup
argument_list|)
expr_stmt|;
name|rel
operator|++
expr_stmt|;
block|}
block|}
comment|/* Perform relocations with addend if there are any: */
if|if
condition|(
operator|(
name|rela
operator|=
name|ef
operator|->
name|rela
operator|)
operator|!=
name|NULL
condition|)
block|{
name|relalim
operator|=
operator|(
specifier|const
name|Elf_Rela
operator|*
operator|)
operator|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|ef
operator|->
name|rela
operator|+
name|ef
operator|->
name|relasize
operator|)
expr_stmt|;
while|while
condition|(
name|rela
operator|<
name|relalim
condition|)
block|{
name|elf_reloc_local
argument_list|(
name|lf
argument_list|,
operator|(
name|Elf_Addr
operator|)
name|ef
operator|->
name|address
argument_list|,
name|rela
argument_list|,
name|ELF_RELOC_RELA
argument_list|,
name|elf_lookup
argument_list|)
expr_stmt|;
name|rela
operator|++
expr_stmt|;
block|}
block|}
block|}
end_function

end_unit

