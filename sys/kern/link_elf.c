begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1998 Doug Rabson  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/namei.h>
end_include

begin_include
include|#
directive|include
file|<sys/fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/vnode.h>
end_include

begin_include
include|#
directive|include
file|<sys/linker.h>
end_include

begin_include
include|#
directive|include
file|<machine/elf.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_param.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_zone.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|SPARSE_MAPPING
end_ifdef

begin_include
include|#
directive|include
file|<vm/vm_object.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_kern.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_extern.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_map.h>
end_include

begin_function_decl
specifier|static
name|int
name|link_elf_load_module
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|linker_file_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|link_elf_load_file
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|linker_file_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|link_elf_lookup_symbol
parameter_list|(
name|linker_file_t
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|c_linker_sym_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|link_elf_symbol_values
parameter_list|(
name|linker_file_t
parameter_list|,
name|c_linker_sym_t
parameter_list|,
name|linker_symval_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|link_elf_search_symbol
parameter_list|(
name|linker_file_t
parameter_list|,
name|caddr_t
name|value
parameter_list|,
name|c_linker_sym_t
modifier|*
name|sym
parameter_list|,
name|long
modifier|*
name|diffp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|link_elf_unload_file
parameter_list|(
name|linker_file_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|link_elf_unload_module
parameter_list|(
name|linker_file_t
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|struct
name|linker_class_ops
name|link_elf_class_ops
init|=
block|{
name|link_elf_load_module
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|linker_file_ops
name|link_elf_file_ops
init|=
block|{
name|link_elf_lookup_symbol
block|,
name|link_elf_symbol_values
block|,
name|link_elf_search_symbol
block|,
name|link_elf_unload_file
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|linker_file_ops
name|link_elf_module_ops
init|=
block|{
name|link_elf_lookup_symbol
block|,
name|link_elf_symbol_values
block|,
name|link_elf_search_symbol
block|,
name|link_elf_unload_module
block|, }
decl_stmt|;
end_decl_stmt

begin_typedef
typedef|typedef
struct|struct
name|elf_file
block|{
name|caddr_t
name|address
decl_stmt|;
comment|/* Relocation address */
ifdef|#
directive|ifdef
name|SPARSE_MAPPING
name|vm_object_t
name|object
decl_stmt|;
comment|/* VM object to hold file pages */
endif|#
directive|endif
specifier|const
name|Elf_Dyn
modifier|*
name|dynamic
decl_stmt|;
comment|/* Symbol table etc. */
name|Elf_Off
name|nbuckets
decl_stmt|;
comment|/* DT_HASH info */
name|Elf_Off
name|nchains
decl_stmt|;
specifier|const
name|Elf_Off
modifier|*
name|buckets
decl_stmt|;
specifier|const
name|Elf_Off
modifier|*
name|chains
decl_stmt|;
name|caddr_t
name|hash
decl_stmt|;
name|caddr_t
name|strtab
decl_stmt|;
comment|/* DT_STRTAB */
name|int
name|strsz
decl_stmt|;
comment|/* DT_STRSZ */
specifier|const
name|Elf_Sym
modifier|*
name|symtab
decl_stmt|;
comment|/* DT_SYMTAB */
name|Elf_Addr
modifier|*
name|got
decl_stmt|;
comment|/* DT_PLTGOT */
specifier|const
name|Elf_Rel
modifier|*
name|pltrel
decl_stmt|;
comment|/* DT_JMPREL */
name|int
name|pltrelsize
decl_stmt|;
comment|/* DT_PLTRELSZ */
specifier|const
name|Elf_Rela
modifier|*
name|pltrela
decl_stmt|;
comment|/* DT_JMPREL */
name|int
name|pltrelasize
decl_stmt|;
comment|/* DT_PLTRELSZ */
specifier|const
name|Elf_Rel
modifier|*
name|rel
decl_stmt|;
comment|/* DT_REL */
name|int
name|relsize
decl_stmt|;
comment|/* DT_RELSZ */
specifier|const
name|Elf_Rela
modifier|*
name|rela
decl_stmt|;
comment|/* DT_RELA */
name|int
name|relasize
decl_stmt|;
comment|/* DT_RELASZ */
name|caddr_t
name|modptr
decl_stmt|;
specifier|const
name|Elf_Sym
modifier|*
name|ddbsymtab
decl_stmt|;
comment|/* The symbol table we are using */
name|long
name|ddbsymcnt
decl_stmt|;
comment|/* Number of symbols */
name|caddr_t
name|ddbstrtab
decl_stmt|;
comment|/* String table */
name|long
name|ddbstrcnt
decl_stmt|;
comment|/* number of bytes in string table */
name|caddr_t
name|symbase
decl_stmt|;
comment|/* malloc'ed symbold base */
name|caddr_t
name|strbase
decl_stmt|;
comment|/* malloc'ed string base */
block|}
typedef|*
name|elf_file_t
typedef|;
end_typedef

begin_function_decl
specifier|static
name|int
name|parse_dynamic
parameter_list|(
name|linker_file_t
name|lf
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|load_dependancies
parameter_list|(
name|linker_file_t
name|lf
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|relocate_file
parameter_list|(
name|linker_file_t
name|lf
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|parse_module_symbols
parameter_list|(
name|linker_file_t
name|lf
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * The kernel symbol table starts here.  */
end_comment

begin_decl_stmt
specifier|extern
name|struct
name|_dynamic
name|_DYNAMIC
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|link_elf_init
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|__ELF__
name|Elf_Dyn
modifier|*
name|dp
decl_stmt|;
name|caddr_t
name|modptr
decl_stmt|,
name|baseptr
decl_stmt|,
name|sizeptr
decl_stmt|;
name|elf_file_t
name|ef
decl_stmt|;
name|char
modifier|*
name|modname
decl_stmt|;
endif|#
directive|endif
if|#
directive|if
name|ELF_TARG_CLASS
operator|==
name|ELFCLASS32
name|linker_add_class
argument_list|(
literal|"elf32"
argument_list|,
name|NULL
argument_list|,
operator|&
name|link_elf_class_ops
argument_list|)
expr_stmt|;
else|#
directive|else
name|linker_add_class
argument_list|(
literal|"elf64"
argument_list|,
name|NULL
argument_list|,
operator|&
name|link_elf_class_ops
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|__ELF__
name|dp
operator|=
operator|(
name|Elf_Dyn
operator|*
operator|)
operator|&
name|_DYNAMIC
expr_stmt|;
if|if
condition|(
name|dp
condition|)
block|{
name|ef
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|elf_file
argument_list|)
argument_list|,
name|M_LINKER
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|ef
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"link_elf_init: Can't create linker structures for kernel"
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|ef
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ef
argument_list|)
argument_list|)
expr_stmt|;
name|ef
operator|->
name|address
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|SPARSE_MAPPING
name|ef
operator|->
name|object
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|ef
operator|->
name|dynamic
operator|=
name|dp
expr_stmt|;
name|modname
operator|=
name|NULL
expr_stmt|;
name|modptr
operator|=
name|preload_search_by_type
argument_list|(
literal|"elf kernel"
argument_list|)
expr_stmt|;
if|if
condition|(
name|modptr
condition|)
name|modname
operator|=
operator|(
name|char
operator|*
operator|)
name|preload_search_info
argument_list|(
name|modptr
argument_list|,
name|MODINFO_NAME
argument_list|)
expr_stmt|;
if|if
condition|(
name|modname
operator|==
name|NULL
condition|)
name|modname
operator|=
literal|"kernel"
expr_stmt|;
name|linker_kernel_file
operator|=
name|linker_make_file
argument_list|(
name|modname
argument_list|,
name|ef
argument_list|,
operator|&
name|link_elf_file_ops
argument_list|)
expr_stmt|;
if|if
condition|(
name|linker_kernel_file
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"link_elf_init: Can't create linker structures for kernel"
argument_list|)
expr_stmt|;
name|parse_dynamic
argument_list|(
name|linker_kernel_file
argument_list|)
expr_stmt|;
name|linker_kernel_file
operator|->
name|address
operator|=
operator|(
name|caddr_t
operator|)
name|KERNBASE
expr_stmt|;
name|linker_kernel_file
operator|->
name|size
operator|=
operator|-
operator|(
name|intptr_t
operator|)
name|linker_kernel_file
operator|->
name|address
expr_stmt|;
if|if
condition|(
name|modptr
condition|)
block|{
name|ef
operator|->
name|modptr
operator|=
name|modptr
expr_stmt|;
name|baseptr
operator|=
name|preload_search_info
argument_list|(
name|modptr
argument_list|,
name|MODINFO_ADDR
argument_list|)
expr_stmt|;
if|if
condition|(
name|baseptr
condition|)
name|linker_kernel_file
operator|->
name|address
operator|=
operator|*
operator|(
name|caddr_t
operator|*
operator|)
name|baseptr
expr_stmt|;
name|sizeptr
operator|=
name|preload_search_info
argument_list|(
name|modptr
argument_list|,
name|MODINFO_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sizeptr
condition|)
name|linker_kernel_file
operator|->
name|size
operator|=
operator|*
operator|(
name|size_t
operator|*
operator|)
name|sizeptr
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|parse_module_symbols
argument_list|(
name|linker_kernel_file
argument_list|)
expr_stmt|;
name|linker_current_file
operator|=
name|linker_kernel_file
expr_stmt|;
name|linker_kernel_file
operator|->
name|flags
operator||=
name|LINKER_FILE_LINKED
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_expr_stmt
name|SYSINIT
argument_list|(
name|link_elf
argument_list|,
name|SI_SUB_KLD
argument_list|,
name|SI_ORDER_SECOND
argument_list|,
name|link_elf_init
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|int
name|parse_module_symbols
parameter_list|(
name|linker_file_t
name|lf
parameter_list|)
block|{
name|elf_file_t
name|ef
init|=
name|lf
operator|->
name|priv
decl_stmt|;
name|caddr_t
name|pointer
decl_stmt|;
name|caddr_t
name|ssym
decl_stmt|,
name|esym
decl_stmt|,
name|base
decl_stmt|;
name|caddr_t
name|strtab
decl_stmt|;
name|int
name|strcnt
decl_stmt|;
name|Elf_Sym
modifier|*
name|symtab
decl_stmt|;
name|int
name|symcnt
decl_stmt|;
if|if
condition|(
name|ef
operator|->
name|modptr
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|pointer
operator|=
name|preload_search_info
argument_list|(
name|ef
operator|->
name|modptr
argument_list|,
name|MODINFO_METADATA
operator||
name|MODINFOMD_SSYM
argument_list|)
expr_stmt|;
if|if
condition|(
name|pointer
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|ssym
operator|=
operator|*
operator|(
name|caddr_t
operator|*
operator|)
name|pointer
expr_stmt|;
name|pointer
operator|=
name|preload_search_info
argument_list|(
name|ef
operator|->
name|modptr
argument_list|,
name|MODINFO_METADATA
operator||
name|MODINFOMD_ESYM
argument_list|)
expr_stmt|;
if|if
condition|(
name|pointer
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|esym
operator|=
operator|*
operator|(
name|caddr_t
operator|*
operator|)
name|pointer
expr_stmt|;
name|base
operator|=
name|ssym
expr_stmt|;
name|symcnt
operator|=
operator|*
operator|(
name|long
operator|*
operator|)
name|base
expr_stmt|;
name|base
operator|+=
sizeof|sizeof
argument_list|(
name|long
argument_list|)
expr_stmt|;
name|symtab
operator|=
operator|(
name|Elf_Sym
operator|*
operator|)
name|base
expr_stmt|;
name|base
operator|+=
name|roundup
argument_list|(
name|symcnt
argument_list|,
sizeof|sizeof
argument_list|(
name|long
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|base
operator|>
name|esym
operator|||
name|base
operator|<
name|ssym
condition|)
block|{
name|printf
argument_list|(
literal|"Symbols are corrupt!\n"
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
name|strcnt
operator|=
operator|*
operator|(
name|long
operator|*
operator|)
name|base
expr_stmt|;
name|base
operator|+=
sizeof|sizeof
argument_list|(
name|long
argument_list|)
expr_stmt|;
name|strtab
operator|=
name|base
expr_stmt|;
name|base
operator|+=
name|roundup
argument_list|(
name|strcnt
argument_list|,
sizeof|sizeof
argument_list|(
name|long
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|base
operator|>
name|esym
operator|||
name|base
operator|<
name|ssym
condition|)
block|{
name|printf
argument_list|(
literal|"Symbols are corrupt!\n"
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
name|ef
operator|->
name|ddbsymtab
operator|=
name|symtab
expr_stmt|;
name|ef
operator|->
name|ddbsymcnt
operator|=
name|symcnt
operator|/
sizeof|sizeof
argument_list|(
name|Elf_Sym
argument_list|)
expr_stmt|;
name|ef
operator|->
name|ddbstrtab
operator|=
name|strtab
expr_stmt|;
name|ef
operator|->
name|ddbstrcnt
operator|=
name|strcnt
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|parse_dynamic
parameter_list|(
name|linker_file_t
name|lf
parameter_list|)
block|{
name|elf_file_t
name|ef
init|=
name|lf
operator|->
name|priv
decl_stmt|;
specifier|const
name|Elf_Dyn
modifier|*
name|dp
decl_stmt|;
name|int
name|plttype
init|=
name|DT_REL
decl_stmt|;
for|for
control|(
name|dp
operator|=
name|ef
operator|->
name|dynamic
init|;
name|dp
operator|->
name|d_tag
operator|!=
name|DT_NULL
condition|;
name|dp
operator|++
control|)
block|{
switch|switch
condition|(
name|dp
operator|->
name|d_tag
condition|)
block|{
case|case
name|DT_HASH
case|:
block|{
comment|/* From src/libexec/rtld-elf/rtld.c */
specifier|const
name|Elf_Off
modifier|*
name|hashtab
init|=
operator|(
specifier|const
name|Elf_Off
operator|*
operator|)
operator|(
name|ef
operator|->
name|address
operator|+
name|dp
operator|->
name|d_un
operator|.
name|d_ptr
operator|)
decl_stmt|;
name|ef
operator|->
name|nbuckets
operator|=
name|hashtab
index|[
literal|0
index|]
expr_stmt|;
name|ef
operator|->
name|nchains
operator|=
name|hashtab
index|[
literal|1
index|]
expr_stmt|;
name|ef
operator|->
name|buckets
operator|=
name|hashtab
operator|+
literal|2
expr_stmt|;
name|ef
operator|->
name|chains
operator|=
name|ef
operator|->
name|buckets
operator|+
name|ef
operator|->
name|nbuckets
expr_stmt|;
break|break;
block|}
case|case
name|DT_STRTAB
case|:
name|ef
operator|->
name|strtab
operator|=
call|(
name|caddr_t
call|)
argument_list|(
name|ef
operator|->
name|address
operator|+
name|dp
operator|->
name|d_un
operator|.
name|d_ptr
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_STRSZ
case|:
name|ef
operator|->
name|strsz
operator|=
name|dp
operator|->
name|d_un
operator|.
name|d_val
expr_stmt|;
break|break;
case|case
name|DT_SYMTAB
case|:
name|ef
operator|->
name|symtab
operator|=
operator|(
name|Elf_Sym
operator|*
operator|)
operator|(
name|ef
operator|->
name|address
operator|+
name|dp
operator|->
name|d_un
operator|.
name|d_ptr
operator|)
expr_stmt|;
break|break;
case|case
name|DT_SYMENT
case|:
if|if
condition|(
name|dp
operator|->
name|d_un
operator|.
name|d_val
operator|!=
sizeof|sizeof
argument_list|(
name|Elf_Sym
argument_list|)
condition|)
return|return
name|ENOEXEC
return|;
break|break;
case|case
name|DT_PLTGOT
case|:
name|ef
operator|->
name|got
operator|=
operator|(
name|Elf_Addr
operator|*
operator|)
operator|(
name|ef
operator|->
name|address
operator|+
name|dp
operator|->
name|d_un
operator|.
name|d_ptr
operator|)
expr_stmt|;
break|break;
case|case
name|DT_REL
case|:
name|ef
operator|->
name|rel
operator|=
operator|(
specifier|const
name|Elf_Rel
operator|*
operator|)
operator|(
name|ef
operator|->
name|address
operator|+
name|dp
operator|->
name|d_un
operator|.
name|d_ptr
operator|)
expr_stmt|;
break|break;
case|case
name|DT_RELSZ
case|:
name|ef
operator|->
name|relsize
operator|=
name|dp
operator|->
name|d_un
operator|.
name|d_val
expr_stmt|;
break|break;
case|case
name|DT_RELENT
case|:
if|if
condition|(
name|dp
operator|->
name|d_un
operator|.
name|d_val
operator|!=
sizeof|sizeof
argument_list|(
name|Elf_Rel
argument_list|)
condition|)
return|return
name|ENOEXEC
return|;
break|break;
case|case
name|DT_JMPREL
case|:
name|ef
operator|->
name|pltrel
operator|=
operator|(
specifier|const
name|Elf_Rel
operator|*
operator|)
operator|(
name|ef
operator|->
name|address
operator|+
name|dp
operator|->
name|d_un
operator|.
name|d_ptr
operator|)
expr_stmt|;
break|break;
case|case
name|DT_PLTRELSZ
case|:
name|ef
operator|->
name|pltrelsize
operator|=
name|dp
operator|->
name|d_un
operator|.
name|d_val
expr_stmt|;
break|break;
case|case
name|DT_RELA
case|:
name|ef
operator|->
name|rela
operator|=
operator|(
specifier|const
name|Elf_Rela
operator|*
operator|)
operator|(
name|ef
operator|->
name|address
operator|+
name|dp
operator|->
name|d_un
operator|.
name|d_ptr
operator|)
expr_stmt|;
break|break;
case|case
name|DT_RELASZ
case|:
name|ef
operator|->
name|relasize
operator|=
name|dp
operator|->
name|d_un
operator|.
name|d_val
expr_stmt|;
break|break;
case|case
name|DT_RELAENT
case|:
if|if
condition|(
name|dp
operator|->
name|d_un
operator|.
name|d_val
operator|!=
sizeof|sizeof
argument_list|(
name|Elf_Rela
argument_list|)
condition|)
return|return
name|ENOEXEC
return|;
break|break;
case|case
name|DT_PLTREL
case|:
name|plttype
operator|=
name|dp
operator|->
name|d_un
operator|.
name|d_val
expr_stmt|;
if|if
condition|(
name|plttype
operator|!=
name|DT_REL
operator|&&
name|plttype
operator|!=
name|DT_RELA
condition|)
return|return
name|ENOEXEC
return|;
break|break;
block|}
block|}
if|if
condition|(
name|plttype
operator|==
name|DT_RELA
condition|)
block|{
name|ef
operator|->
name|pltrela
operator|=
operator|(
specifier|const
name|Elf_Rela
operator|*
operator|)
name|ef
operator|->
name|pltrel
expr_stmt|;
name|ef
operator|->
name|pltrel
operator|=
name|NULL
expr_stmt|;
name|ef
operator|->
name|pltrelasize
operator|=
name|ef
operator|->
name|pltrelsize
expr_stmt|;
name|ef
operator|->
name|pltrelsize
operator|=
literal|0
expr_stmt|;
block|}
name|ef
operator|->
name|ddbsymtab
operator|=
name|ef
operator|->
name|symtab
expr_stmt|;
name|ef
operator|->
name|ddbsymcnt
operator|=
name|ef
operator|->
name|nchains
expr_stmt|;
name|ef
operator|->
name|ddbstrtab
operator|=
name|ef
operator|->
name|strtab
expr_stmt|;
name|ef
operator|->
name|ddbstrcnt
operator|=
name|ef
operator|->
name|strsz
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|link_elf_error
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|)
block|{
name|printf
argument_list|(
literal|"kldload: %s\n"
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|link_elf_load_module
parameter_list|(
specifier|const
name|char
modifier|*
name|filename
parameter_list|,
name|linker_file_t
modifier|*
name|result
parameter_list|)
block|{
name|caddr_t
name|modptr
decl_stmt|,
name|baseptr
decl_stmt|,
name|sizeptr
decl_stmt|,
name|dynptr
decl_stmt|;
name|char
modifier|*
name|type
decl_stmt|;
name|elf_file_t
name|ef
decl_stmt|;
name|linker_file_t
name|lf
decl_stmt|;
name|int
name|error
decl_stmt|;
name|vm_offset_t
name|dp
decl_stmt|;
comment|/* Look to see if we have the module preloaded */
name|modptr
operator|=
name|preload_search_by_name
argument_list|(
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|modptr
operator|==
name|NULL
condition|)
return|return
operator|(
name|link_elf_load_file
argument_list|(
name|filename
argument_list|,
name|result
argument_list|)
operator|)
return|;
comment|/* It's preloaded, check we can handle it and collect information */
name|type
operator|=
operator|(
name|char
operator|*
operator|)
name|preload_search_info
argument_list|(
name|modptr
argument_list|,
name|MODINFO_TYPE
argument_list|)
expr_stmt|;
name|baseptr
operator|=
name|preload_search_info
argument_list|(
name|modptr
argument_list|,
name|MODINFO_ADDR
argument_list|)
expr_stmt|;
name|sizeptr
operator|=
name|preload_search_info
argument_list|(
name|modptr
argument_list|,
name|MODINFO_SIZE
argument_list|)
expr_stmt|;
name|dynptr
operator|=
name|preload_search_info
argument_list|(
name|modptr
argument_list|,
name|MODINFO_METADATA
operator||
name|MODINFOMD_DYNAMIC
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|NULL
operator|||
name|strcmp
argument_list|(
name|type
argument_list|,
literal|"elf module"
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|EFTYPE
operator|)
return|;
if|if
condition|(
name|baseptr
operator|==
name|NULL
operator|||
name|sizeptr
operator|==
name|NULL
operator|||
name|dynptr
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|ef
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|elf_file
argument_list|)
argument_list|,
name|M_LINKER
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
name|ef
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|bzero
argument_list|(
name|ef
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ef
argument_list|)
argument_list|)
expr_stmt|;
name|ef
operator|->
name|modptr
operator|=
name|modptr
expr_stmt|;
name|ef
operator|->
name|address
operator|=
operator|*
operator|(
name|caddr_t
operator|*
operator|)
name|baseptr
expr_stmt|;
ifdef|#
directive|ifdef
name|SPARSE_MAPPING
name|ef
operator|->
name|object
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|dp
operator|=
operator|(
name|vm_offset_t
operator|)
name|ef
operator|->
name|address
operator|+
operator|*
operator|(
name|vm_offset_t
operator|*
operator|)
name|dynptr
expr_stmt|;
name|ef
operator|->
name|dynamic
operator|=
operator|(
name|Elf_Dyn
operator|*
operator|)
name|dp
expr_stmt|;
name|lf
operator|=
name|linker_make_file
argument_list|(
name|filename
argument_list|,
name|ef
argument_list|,
operator|&
name|link_elf_module_ops
argument_list|)
expr_stmt|;
if|if
condition|(
name|lf
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|ef
argument_list|,
name|M_LINKER
argument_list|)
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
name|lf
operator|->
name|address
operator|=
name|ef
operator|->
name|address
expr_stmt|;
name|lf
operator|->
name|size
operator|=
operator|*
operator|(
name|size_t
operator|*
operator|)
name|sizeptr
expr_stmt|;
name|error
operator|=
name|parse_dynamic
argument_list|(
name|lf
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|linker_file_unload
argument_list|(
name|lf
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
name|error
operator|=
name|load_dependancies
argument_list|(
name|lf
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|linker_file_unload
argument_list|(
name|lf
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
name|error
operator|=
name|relocate_file
argument_list|(
name|lf
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|linker_file_unload
argument_list|(
name|lf
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
operator|(
name|void
operator|)
name|parse_module_symbols
argument_list|(
name|lf
argument_list|)
expr_stmt|;
name|lf
operator|->
name|flags
operator||=
name|LINKER_FILE_LINKED
expr_stmt|;
operator|*
name|result
operator|=
name|lf
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|link_elf_load_file
parameter_list|(
specifier|const
name|char
modifier|*
name|filename
parameter_list|,
name|linker_file_t
modifier|*
name|result
parameter_list|)
block|{
name|struct
name|nameidata
name|nd
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
init|=
name|curproc
decl_stmt|;
comment|/* XXX */
name|Elf_Ehdr
modifier|*
name|hdr
decl_stmt|;
name|caddr_t
name|firstpage
decl_stmt|;
name|int
name|nbytes
decl_stmt|,
name|i
decl_stmt|;
name|Elf_Phdr
modifier|*
name|phdr
decl_stmt|;
name|Elf_Phdr
modifier|*
name|phlimit
decl_stmt|;
name|Elf_Phdr
modifier|*
name|segs
index|[
literal|2
index|]
decl_stmt|;
name|int
name|nsegs
decl_stmt|;
name|Elf_Phdr
modifier|*
name|phdyn
decl_stmt|;
name|Elf_Phdr
modifier|*
name|phphdr
decl_stmt|;
name|caddr_t
name|mapbase
decl_stmt|;
name|size_t
name|mapsize
decl_stmt|;
name|Elf_Off
name|base_offset
decl_stmt|;
name|Elf_Addr
name|base_vaddr
decl_stmt|;
name|Elf_Addr
name|base_vlimit
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|int
name|resid
decl_stmt|;
name|elf_file_t
name|ef
decl_stmt|;
name|linker_file_t
name|lf
decl_stmt|;
name|char
modifier|*
name|pathname
decl_stmt|;
name|Elf_Shdr
modifier|*
name|shdr
decl_stmt|;
name|int
name|symtabindex
decl_stmt|;
name|int
name|symstrindex
decl_stmt|;
name|int
name|symcnt
decl_stmt|;
name|int
name|strcnt
decl_stmt|;
name|shdr
operator|=
name|NULL
expr_stmt|;
name|lf
operator|=
name|NULL
expr_stmt|;
name|pathname
operator|=
name|linker_search_path
argument_list|(
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|pathname
operator|==
name|NULL
condition|)
return|return
name|ENOENT
return|;
name|NDINIT
argument_list|(
operator|&
name|nd
argument_list|,
name|LOOKUP
argument_list|,
name|FOLLOW
argument_list|,
name|UIO_SYSSPACE
argument_list|,
name|pathname
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|error
operator|=
name|vn_open
argument_list|(
operator|&
name|nd
argument_list|,
name|FREAD
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|pathname
argument_list|,
name|M_LINKER
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
name|NDFREE
argument_list|(
operator|&
name|nd
argument_list|,
name|NDF_ONLY_PNBUF
argument_list|)
expr_stmt|;
comment|/*      * Read the elf header from the file.      */
name|firstpage
operator|=
name|malloc
argument_list|(
name|PAGE_SIZE
argument_list|,
name|M_LINKER
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
name|firstpage
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|hdr
operator|=
operator|(
name|Elf_Ehdr
operator|*
operator|)
name|firstpage
expr_stmt|;
name|error
operator|=
name|vn_rdwr
argument_list|(
name|UIO_READ
argument_list|,
name|nd
operator|.
name|ni_vp
argument_list|,
name|firstpage
argument_list|,
name|PAGE_SIZE
argument_list|,
literal|0
argument_list|,
name|UIO_SYSSPACE
argument_list|,
name|IO_NODELOCKED
argument_list|,
name|p
operator|->
name|p_ucred
argument_list|,
operator|&
name|resid
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|nbytes
operator|=
name|PAGE_SIZE
operator|-
name|resid
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
operator|!
name|IS_ELF
argument_list|(
operator|*
name|hdr
argument_list|)
condition|)
block|{
name|error
operator|=
name|ENOEXEC
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|hdr
operator|->
name|e_ident
index|[
name|EI_CLASS
index|]
operator|!=
name|ELF_TARG_CLASS
operator|||
name|hdr
operator|->
name|e_ident
index|[
name|EI_DATA
index|]
operator|!=
name|ELF_TARG_DATA
condition|)
block|{
name|link_elf_error
argument_list|(
literal|"Unsupported file layout"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOEXEC
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|hdr
operator|->
name|e_ident
index|[
name|EI_VERSION
index|]
operator|!=
name|EV_CURRENT
operator|||
name|hdr
operator|->
name|e_version
operator|!=
name|EV_CURRENT
condition|)
block|{
name|link_elf_error
argument_list|(
literal|"Unsupported file version"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOEXEC
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|hdr
operator|->
name|e_type
operator|!=
name|ET_EXEC
operator|&&
name|hdr
operator|->
name|e_type
operator|!=
name|ET_DYN
condition|)
block|{
name|link_elf_error
argument_list|(
literal|"Unsupported file type"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOEXEC
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|hdr
operator|->
name|e_machine
operator|!=
name|ELF_TARG_MACH
condition|)
block|{
name|link_elf_error
argument_list|(
literal|"Unsupported machine"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOEXEC
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/*      * We rely on the program header being in the first page.  This is      * not strictly required by the ABI specification, but it seems to      * always true in practice.  And, it simplifies things considerably.      */
if|if
condition|(
operator|!
operator|(
operator|(
name|hdr
operator|->
name|e_phentsize
operator|==
sizeof|sizeof
argument_list|(
name|Elf_Phdr
argument_list|)
operator|)
operator|&&
operator|(
name|hdr
operator|->
name|e_phoff
operator|+
name|hdr
operator|->
name|e_phnum
operator|*
sizeof|sizeof
argument_list|(
name|Elf_Phdr
argument_list|)
operator|<=
name|PAGE_SIZE
operator|)
operator|&&
operator|(
name|hdr
operator|->
name|e_phoff
operator|+
name|hdr
operator|->
name|e_phnum
operator|*
sizeof|sizeof
argument_list|(
name|Elf_Phdr
argument_list|)
operator|<=
name|nbytes
operator|)
operator|)
condition|)
name|link_elf_error
argument_list|(
literal|"Unreadable program headers"
argument_list|)
expr_stmt|;
comment|/*      * Scan the program header entries, and save key information.      *      * We rely on there being exactly two load segments, text and data,      * in that order.      */
name|phdr
operator|=
operator|(
name|Elf_Phdr
operator|*
operator|)
operator|(
name|firstpage
operator|+
name|hdr
operator|->
name|e_phoff
operator|)
expr_stmt|;
name|phlimit
operator|=
name|phdr
operator|+
name|hdr
operator|->
name|e_phnum
expr_stmt|;
name|nsegs
operator|=
literal|0
expr_stmt|;
name|phdyn
operator|=
name|NULL
expr_stmt|;
name|phphdr
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
name|phdr
operator|<
name|phlimit
condition|)
block|{
switch|switch
condition|(
name|phdr
operator|->
name|p_type
condition|)
block|{
case|case
name|PT_LOAD
case|:
if|if
condition|(
name|nsegs
operator|==
literal|2
condition|)
block|{
name|link_elf_error
argument_list|(
literal|"Too many sections"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOEXEC
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|segs
index|[
name|nsegs
index|]
operator|=
name|phdr
expr_stmt|;
operator|++
name|nsegs
expr_stmt|;
break|break;
case|case
name|PT_PHDR
case|:
name|phphdr
operator|=
name|phdr
expr_stmt|;
break|break;
case|case
name|PT_DYNAMIC
case|:
name|phdyn
operator|=
name|phdr
expr_stmt|;
break|break;
block|}
operator|++
name|phdr
expr_stmt|;
block|}
if|if
condition|(
name|phdyn
operator|==
name|NULL
condition|)
block|{
name|link_elf_error
argument_list|(
literal|"Object is not dynamically-linked"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOEXEC
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/*      * Allocate the entire address space of the object, to stake out our      * contiguous region, and to establish the base address for relocation.      */
name|base_offset
operator|=
name|trunc_page
argument_list|(
name|segs
index|[
literal|0
index|]
operator|->
name|p_offset
argument_list|)
expr_stmt|;
name|base_vaddr
operator|=
name|trunc_page
argument_list|(
name|segs
index|[
literal|0
index|]
operator|->
name|p_vaddr
argument_list|)
expr_stmt|;
name|base_vlimit
operator|=
name|round_page
argument_list|(
name|segs
index|[
literal|1
index|]
operator|->
name|p_vaddr
operator|+
name|segs
index|[
literal|1
index|]
operator|->
name|p_memsz
argument_list|)
expr_stmt|;
name|mapsize
operator|=
name|base_vlimit
operator|-
name|base_vaddr
expr_stmt|;
name|ef
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|elf_file
argument_list|)
argument_list|,
name|M_LINKER
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|ef
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ef
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SPARSE_MAPPING
name|ef
operator|->
name|object
operator|=
name|vm_object_allocate
argument_list|(
name|OBJT_DEFAULT
argument_list|,
name|mapsize
operator|>>
name|PAGE_SHIFT
argument_list|)
expr_stmt|;
if|if
condition|(
name|ef
operator|->
name|object
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|ef
argument_list|,
name|M_LINKER
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|vm_object_reference
argument_list|(
name|ef
operator|->
name|object
argument_list|)
expr_stmt|;
name|ef
operator|->
name|address
operator|=
operator|(
name|caddr_t
operator|)
name|vm_map_min
argument_list|(
name|kernel_map
argument_list|)
expr_stmt|;
name|error
operator|=
name|vm_map_find
argument_list|(
name|kernel_map
argument_list|,
name|ef
operator|->
name|object
argument_list|,
literal|0
argument_list|,
operator|(
name|vm_offset_t
operator|*
operator|)
operator|&
name|ef
operator|->
name|address
argument_list|,
name|mapsize
argument_list|,
literal|1
argument_list|,
name|VM_PROT_ALL
argument_list|,
name|VM_PROT_ALL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|vm_object_deallocate
argument_list|(
name|ef
operator|->
name|object
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ef
argument_list|,
name|M_LINKER
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
else|#
directive|else
name|ef
operator|->
name|address
operator|=
name|malloc
argument_list|(
name|mapsize
argument_list|,
name|M_LINKER
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|mapbase
operator|=
name|ef
operator|->
name|address
expr_stmt|;
comment|/*      * Read the text and data sections and zero the bss.      */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
name|i
operator|++
control|)
block|{
name|caddr_t
name|segbase
init|=
name|mapbase
operator|+
name|segs
index|[
name|i
index|]
operator|->
name|p_vaddr
operator|-
name|base_vaddr
decl_stmt|;
name|error
operator|=
name|vn_rdwr
argument_list|(
name|UIO_READ
argument_list|,
name|nd
operator|.
name|ni_vp
argument_list|,
name|segbase
argument_list|,
name|segs
index|[
name|i
index|]
operator|->
name|p_filesz
argument_list|,
name|segs
index|[
name|i
index|]
operator|->
name|p_offset
argument_list|,
name|UIO_SYSSPACE
argument_list|,
name|IO_NODELOCKED
argument_list|,
name|p
operator|->
name|p_ucred
argument_list|,
operator|&
name|resid
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
ifdef|#
directive|ifdef
name|SPARSE_MAPPING
name|vm_map_remove
argument_list|(
name|kernel_map
argument_list|,
operator|(
name|vm_offset_t
operator|)
name|ef
operator|->
name|address
argument_list|,
operator|(
name|vm_offset_t
operator|)
name|ef
operator|->
name|address
operator|+
operator|(
name|ef
operator|->
name|object
operator|->
name|size
operator|<<
name|PAGE_SHIFT
operator|)
argument_list|)
expr_stmt|;
name|vm_object_deallocate
argument_list|(
name|ef
operator|->
name|object
argument_list|)
expr_stmt|;
else|#
directive|else
name|free
argument_list|(
name|ef
operator|->
name|address
argument_list|,
name|M_LINKER
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|free
argument_list|(
name|ef
argument_list|,
name|M_LINKER
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|bzero
argument_list|(
name|segbase
operator|+
name|segs
index|[
name|i
index|]
operator|->
name|p_filesz
argument_list|,
name|segs
index|[
name|i
index|]
operator|->
name|p_memsz
operator|-
name|segs
index|[
name|i
index|]
operator|->
name|p_filesz
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SPARSE_MAPPING
comment|/* 	 * Wire down the pages 	 */
name|vm_map_pageable
argument_list|(
name|kernel_map
argument_list|,
operator|(
name|vm_offset_t
operator|)
name|segbase
argument_list|,
operator|(
name|vm_offset_t
operator|)
name|segbase
operator|+
name|segs
index|[
name|i
index|]
operator|->
name|p_memsz
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|ef
operator|->
name|dynamic
operator|=
operator|(
specifier|const
name|Elf_Dyn
operator|*
operator|)
operator|(
name|mapbase
operator|+
name|phdyn
operator|->
name|p_vaddr
operator|-
name|base_vaddr
operator|)
expr_stmt|;
name|lf
operator|=
name|linker_make_file
argument_list|(
name|filename
argument_list|,
name|ef
argument_list|,
operator|&
name|link_elf_file_ops
argument_list|)
expr_stmt|;
if|if
condition|(
name|lf
operator|==
name|NULL
condition|)
block|{
ifdef|#
directive|ifdef
name|SPARSE_MAPPING
name|vm_map_remove
argument_list|(
name|kernel_map
argument_list|,
operator|(
name|vm_offset_t
operator|)
name|ef
operator|->
name|address
argument_list|,
operator|(
name|vm_offset_t
operator|)
name|ef
operator|->
name|address
operator|+
operator|(
name|ef
operator|->
name|object
operator|->
name|size
operator|<<
name|PAGE_SHIFT
operator|)
argument_list|)
expr_stmt|;
name|vm_object_deallocate
argument_list|(
name|ef
operator|->
name|object
argument_list|)
expr_stmt|;
else|#
directive|else
name|free
argument_list|(
name|ef
operator|->
name|address
argument_list|,
name|M_LINKER
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|free
argument_list|(
name|ef
argument_list|,
name|M_LINKER
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|lf
operator|->
name|address
operator|=
name|ef
operator|->
name|address
expr_stmt|;
name|lf
operator|->
name|size
operator|=
name|mapsize
expr_stmt|;
name|error
operator|=
name|parse_dynamic
argument_list|(
name|lf
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
name|error
operator|=
name|load_dependancies
argument_list|(
name|lf
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
name|error
operator|=
name|relocate_file
argument_list|(
name|lf
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
comment|/* Try and load the symbol table if it's present.  (you can strip it!) */
name|nbytes
operator|=
name|hdr
operator|->
name|e_shnum
operator|*
name|hdr
operator|->
name|e_shentsize
expr_stmt|;
if|if
condition|(
name|nbytes
operator|==
literal|0
operator|||
name|hdr
operator|->
name|e_shoff
operator|==
literal|0
condition|)
goto|goto
name|nosyms
goto|;
name|shdr
operator|=
name|malloc
argument_list|(
name|nbytes
argument_list|,
name|M_LINKER
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
name|shdr
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|bzero
argument_list|(
name|shdr
argument_list|,
name|nbytes
argument_list|)
expr_stmt|;
name|error
operator|=
name|vn_rdwr
argument_list|(
name|UIO_READ
argument_list|,
name|nd
operator|.
name|ni_vp
argument_list|,
operator|(
name|caddr_t
operator|)
name|shdr
argument_list|,
name|nbytes
argument_list|,
name|hdr
operator|->
name|e_shoff
argument_list|,
name|UIO_SYSSPACE
argument_list|,
name|IO_NODELOCKED
argument_list|,
name|p
operator|->
name|p_ucred
argument_list|,
operator|&
name|resid
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
name|symtabindex
operator|=
operator|-
literal|1
expr_stmt|;
name|symstrindex
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|hdr
operator|->
name|e_shnum
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|shdr
index|[
name|i
index|]
operator|.
name|sh_type
operator|==
name|SHT_SYMTAB
condition|)
block|{
name|symtabindex
operator|=
name|i
expr_stmt|;
name|symstrindex
operator|=
name|shdr
index|[
name|i
index|]
operator|.
name|sh_link
expr_stmt|;
block|}
block|}
if|if
condition|(
name|symtabindex
operator|<
literal|0
operator|||
name|symstrindex
operator|<
literal|0
condition|)
goto|goto
name|nosyms
goto|;
name|symcnt
operator|=
name|shdr
index|[
name|symtabindex
index|]
operator|.
name|sh_size
expr_stmt|;
name|ef
operator|->
name|symbase
operator|=
name|malloc
argument_list|(
name|symcnt
argument_list|,
name|M_LINKER
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|strcnt
operator|=
name|shdr
index|[
name|symstrindex
index|]
operator|.
name|sh_size
expr_stmt|;
name|ef
operator|->
name|strbase
operator|=
name|malloc
argument_list|(
name|strcnt
argument_list|,
name|M_LINKER
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
name|ef
operator|->
name|symbase
operator|==
name|NULL
operator|||
name|ef
operator|->
name|strbase
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|error
operator|=
name|vn_rdwr
argument_list|(
name|UIO_READ
argument_list|,
name|nd
operator|.
name|ni_vp
argument_list|,
name|ef
operator|->
name|symbase
argument_list|,
name|symcnt
argument_list|,
name|shdr
index|[
name|symtabindex
index|]
operator|.
name|sh_offset
argument_list|,
name|UIO_SYSSPACE
argument_list|,
name|IO_NODELOCKED
argument_list|,
name|p
operator|->
name|p_ucred
argument_list|,
operator|&
name|resid
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
name|error
operator|=
name|vn_rdwr
argument_list|(
name|UIO_READ
argument_list|,
name|nd
operator|.
name|ni_vp
argument_list|,
name|ef
operator|->
name|strbase
argument_list|,
name|strcnt
argument_list|,
name|shdr
index|[
name|symstrindex
index|]
operator|.
name|sh_offset
argument_list|,
name|UIO_SYSSPACE
argument_list|,
name|IO_NODELOCKED
argument_list|,
name|p
operator|->
name|p_ucred
argument_list|,
operator|&
name|resid
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
name|ef
operator|->
name|ddbsymcnt
operator|=
name|symcnt
operator|/
sizeof|sizeof
argument_list|(
name|Elf_Sym
argument_list|)
expr_stmt|;
name|ef
operator|->
name|ddbsymtab
operator|=
operator|(
specifier|const
name|Elf_Sym
operator|*
operator|)
name|ef
operator|->
name|symbase
expr_stmt|;
name|ef
operator|->
name|ddbstrcnt
operator|=
name|strcnt
expr_stmt|;
name|ef
operator|->
name|ddbstrtab
operator|=
name|ef
operator|->
name|strbase
expr_stmt|;
name|lf
operator|->
name|flags
operator||=
name|LINKER_FILE_LINKED
expr_stmt|;
name|nosyms
label|:
operator|*
name|result
operator|=
name|lf
expr_stmt|;
name|out
label|:
if|if
condition|(
name|error
operator|&&
name|lf
condition|)
name|linker_file_unload
argument_list|(
name|lf
argument_list|)
expr_stmt|;
if|if
condition|(
name|shdr
condition|)
name|free
argument_list|(
name|shdr
argument_list|,
name|M_LINKER
argument_list|)
expr_stmt|;
if|if
condition|(
name|firstpage
condition|)
name|free
argument_list|(
name|firstpage
argument_list|,
name|M_LINKER
argument_list|)
expr_stmt|;
name|VOP_UNLOCK
argument_list|(
name|nd
operator|.
name|ni_vp
argument_list|,
literal|0
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|vn_close
argument_list|(
name|nd
operator|.
name|ni_vp
argument_list|,
name|FREAD
argument_list|,
name|p
operator|->
name|p_ucred
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|link_elf_unload_file
parameter_list|(
name|linker_file_t
name|file
parameter_list|)
block|{
name|elf_file_t
name|ef
init|=
name|file
operator|->
name|priv
decl_stmt|;
if|if
condition|(
name|ef
condition|)
block|{
ifdef|#
directive|ifdef
name|SPARSE_MAPPING
if|if
condition|(
name|ef
operator|->
name|object
condition|)
block|{
name|vm_map_remove
argument_list|(
name|kernel_map
argument_list|,
operator|(
name|vm_offset_t
operator|)
name|ef
operator|->
name|address
argument_list|,
operator|(
name|vm_offset_t
operator|)
name|ef
operator|->
name|address
operator|+
operator|(
name|ef
operator|->
name|object
operator|->
name|size
operator|<<
name|PAGE_SHIFT
operator|)
argument_list|)
expr_stmt|;
name|vm_object_deallocate
argument_list|(
name|ef
operator|->
name|object
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
if|if
condition|(
name|ef
operator|->
name|address
condition|)
name|free
argument_list|(
name|ef
operator|->
name|address
argument_list|,
name|M_LINKER
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|ef
operator|->
name|symbase
condition|)
name|free
argument_list|(
name|ef
operator|->
name|symbase
argument_list|,
name|M_LINKER
argument_list|)
expr_stmt|;
if|if
condition|(
name|ef
operator|->
name|strbase
condition|)
name|free
argument_list|(
name|ef
operator|->
name|strbase
argument_list|,
name|M_LINKER
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ef
argument_list|,
name|M_LINKER
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|link_elf_unload_module
parameter_list|(
name|linker_file_t
name|file
parameter_list|)
block|{
name|elf_file_t
name|ef
init|=
name|file
operator|->
name|priv
decl_stmt|;
if|if
condition|(
name|ef
condition|)
name|free
argument_list|(
name|ef
argument_list|,
name|M_LINKER
argument_list|)
expr_stmt|;
if|if
condition|(
name|file
operator|->
name|filename
condition|)
name|preload_delete_name
argument_list|(
name|file
operator|->
name|filename
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|load_dependancies
parameter_list|(
name|linker_file_t
name|lf
parameter_list|)
block|{
name|elf_file_t
name|ef
init|=
name|lf
operator|->
name|priv
decl_stmt|;
name|linker_file_t
name|lfdep
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
specifier|const
name|Elf_Dyn
modifier|*
name|dp
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
comment|/*      * All files are dependant on /kernel.      */
if|if
condition|(
name|linker_kernel_file
condition|)
block|{
name|linker_kernel_file
operator|->
name|refs
operator|++
expr_stmt|;
name|linker_file_add_dependancy
argument_list|(
name|lf
argument_list|,
name|linker_kernel_file
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|dp
operator|=
name|ef
operator|->
name|dynamic
init|;
name|dp
operator|->
name|d_tag
operator|!=
name|DT_NULL
condition|;
name|dp
operator|++
control|)
block|{
if|if
condition|(
name|dp
operator|->
name|d_tag
operator|==
name|DT_NEEDED
condition|)
block|{
name|name
operator|=
name|ef
operator|->
name|strtab
operator|+
name|dp
operator|->
name|d_un
operator|.
name|d_val
expr_stmt|;
name|error
operator|=
name|linker_load_file
argument_list|(
name|name
argument_list|,
operator|&
name|lfdep
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
name|error
operator|=
name|linker_file_add_dependancy
argument_list|(
name|lf
argument_list|,
name|lfdep
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
block|}
block|}
name|out
label|:
return|return
name|error
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|symbol_name
parameter_list|(
name|elf_file_t
name|ef
parameter_list|,
name|Elf_Word
name|r_info
parameter_list|)
block|{
specifier|const
name|Elf_Sym
modifier|*
name|ref
decl_stmt|;
if|if
condition|(
name|ELF_R_SYM
argument_list|(
name|r_info
argument_list|)
condition|)
block|{
name|ref
operator|=
name|ef
operator|->
name|symtab
operator|+
name|ELF_R_SYM
argument_list|(
name|r_info
argument_list|)
expr_stmt|;
return|return
name|ef
operator|->
name|strtab
operator|+
name|ref
operator|->
name|st_name
return|;
block|}
else|else
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|relocate_file
parameter_list|(
name|linker_file_t
name|lf
parameter_list|)
block|{
name|elf_file_t
name|ef
init|=
name|lf
operator|->
name|priv
decl_stmt|;
specifier|const
name|Elf_Rel
modifier|*
name|rellim
decl_stmt|;
specifier|const
name|Elf_Rel
modifier|*
name|rel
decl_stmt|;
specifier|const
name|Elf_Rela
modifier|*
name|relalim
decl_stmt|;
specifier|const
name|Elf_Rela
modifier|*
name|rela
decl_stmt|;
specifier|const
name|char
modifier|*
name|symname
decl_stmt|;
comment|/* Perform relocations without addend if there are any: */
name|rel
operator|=
name|ef
operator|->
name|rel
expr_stmt|;
if|if
condition|(
name|rel
condition|)
block|{
name|rellim
operator|=
operator|(
specifier|const
name|Elf_Rel
operator|*
operator|)
operator|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|ef
operator|->
name|rel
operator|+
name|ef
operator|->
name|relsize
operator|)
expr_stmt|;
while|while
condition|(
name|rel
operator|<
name|rellim
condition|)
block|{
name|symname
operator|=
name|symbol_name
argument_list|(
name|ef
argument_list|,
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|elf_reloc
argument_list|(
name|lf
argument_list|,
name|rel
argument_list|,
name|ELF_RELOC_REL
argument_list|,
name|symname
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"link_elf: symbol %s undefined\n"
argument_list|,
name|symname
argument_list|)
expr_stmt|;
return|return
name|ENOENT
return|;
block|}
name|rel
operator|++
expr_stmt|;
block|}
block|}
comment|/* Perform relocations with addend if there are any: */
name|rela
operator|=
name|ef
operator|->
name|rela
expr_stmt|;
if|if
condition|(
name|rela
condition|)
block|{
name|relalim
operator|=
operator|(
specifier|const
name|Elf_Rela
operator|*
operator|)
operator|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|ef
operator|->
name|rela
operator|+
name|ef
operator|->
name|relasize
operator|)
expr_stmt|;
while|while
condition|(
name|rela
operator|<
name|relalim
condition|)
block|{
name|symname
operator|=
name|symbol_name
argument_list|(
name|ef
argument_list|,
name|rela
operator|->
name|r_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|elf_reloc
argument_list|(
name|lf
argument_list|,
name|rela
argument_list|,
name|ELF_RELOC_RELA
argument_list|,
name|symname
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"link_elf: symbol %s undefined\n"
argument_list|,
name|symname
argument_list|)
expr_stmt|;
return|return
name|ENOENT
return|;
block|}
name|rela
operator|++
expr_stmt|;
block|}
block|}
comment|/* Perform PLT relocations without addend if there are any: */
name|rel
operator|=
name|ef
operator|->
name|pltrel
expr_stmt|;
if|if
condition|(
name|rel
condition|)
block|{
name|rellim
operator|=
operator|(
specifier|const
name|Elf_Rel
operator|*
operator|)
operator|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|ef
operator|->
name|pltrel
operator|+
name|ef
operator|->
name|pltrelsize
operator|)
expr_stmt|;
while|while
condition|(
name|rel
operator|<
name|rellim
condition|)
block|{
name|symname
operator|=
name|symbol_name
argument_list|(
name|ef
argument_list|,
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|elf_reloc
argument_list|(
name|lf
argument_list|,
name|rel
argument_list|,
name|ELF_RELOC_REL
argument_list|,
name|symname
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"link_elf: symbol %s undefined\n"
argument_list|,
name|symname
argument_list|)
expr_stmt|;
return|return
name|ENOENT
return|;
block|}
name|rel
operator|++
expr_stmt|;
block|}
block|}
comment|/* Perform relocations with addend if there are any: */
name|rela
operator|=
name|ef
operator|->
name|pltrela
expr_stmt|;
if|if
condition|(
name|rela
condition|)
block|{
name|relalim
operator|=
operator|(
specifier|const
name|Elf_Rela
operator|*
operator|)
operator|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|ef
operator|->
name|pltrela
operator|+
name|ef
operator|->
name|pltrelasize
operator|)
expr_stmt|;
while|while
condition|(
name|rela
operator|<
name|relalim
condition|)
block|{
name|symname
operator|=
name|symbol_name
argument_list|(
name|ef
argument_list|,
name|rela
operator|->
name|r_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|elf_reloc
argument_list|(
name|lf
argument_list|,
name|rela
argument_list|,
name|ELF_RELOC_RELA
argument_list|,
name|symname
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"link_elf: symbol %s undefined\n"
argument_list|,
name|symname
argument_list|)
expr_stmt|;
return|return
name|ENOENT
return|;
block|}
name|rela
operator|++
expr_stmt|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Hash function for symbol table lookup.  Don't even think about changing  * this.  It is specified by the System V ABI.  */
end_comment

begin_function
specifier|static
name|unsigned
name|long
name|elf_hash
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
specifier|const
name|unsigned
name|char
modifier|*
name|p
init|=
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
name|name
decl_stmt|;
name|unsigned
name|long
name|h
init|=
literal|0
decl_stmt|;
name|unsigned
name|long
name|g
decl_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|'\0'
condition|)
block|{
name|h
operator|=
operator|(
name|h
operator|<<
literal|4
operator|)
operator|+
operator|*
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|g
operator|=
name|h
operator|&
literal|0xf0000000
operator|)
operator|!=
literal|0
condition|)
name|h
operator|^=
name|g
operator|>>
literal|24
expr_stmt|;
name|h
operator|&=
operator|~
name|g
expr_stmt|;
block|}
return|return
name|h
return|;
block|}
end_function

begin_function
name|int
name|link_elf_lookup_symbol
parameter_list|(
name|linker_file_t
name|lf
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|c_linker_sym_t
modifier|*
name|sym
parameter_list|)
block|{
name|elf_file_t
name|ef
init|=
name|lf
operator|->
name|priv
decl_stmt|;
name|unsigned
name|long
name|symnum
decl_stmt|;
specifier|const
name|Elf_Sym
modifier|*
name|symp
decl_stmt|;
specifier|const
name|char
modifier|*
name|strp
decl_stmt|;
name|unsigned
name|long
name|hash
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* First, search hashed global symbols */
name|hash
operator|=
name|elf_hash
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|symnum
operator|=
name|ef
operator|->
name|buckets
index|[
name|hash
operator|%
name|ef
operator|->
name|nbuckets
index|]
expr_stmt|;
while|while
condition|(
name|symnum
operator|!=
name|STN_UNDEF
condition|)
block|{
if|if
condition|(
name|symnum
operator|>=
name|ef
operator|->
name|nchains
condition|)
block|{
name|printf
argument_list|(
literal|"link_elf_lookup_symbol: corrupt symbol table\n"
argument_list|)
expr_stmt|;
return|return
name|ENOENT
return|;
block|}
name|symp
operator|=
name|ef
operator|->
name|symtab
operator|+
name|symnum
expr_stmt|;
if|if
condition|(
name|symp
operator|->
name|st_name
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"link_elf_lookup_symbol: corrupt symbol table\n"
argument_list|)
expr_stmt|;
return|return
name|ENOENT
return|;
block|}
name|strp
operator|=
name|ef
operator|->
name|strtab
operator|+
name|symp
operator|->
name|st_name
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|strp
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|symp
operator|->
name|st_shndx
operator|!=
name|SHN_UNDEF
operator|||
operator|(
name|symp
operator|->
name|st_value
operator|!=
literal|0
operator|&&
name|ELF_ST_TYPE
argument_list|(
name|symp
operator|->
name|st_info
argument_list|)
operator|==
name|STT_FUNC
operator|)
condition|)
block|{
operator|*
name|sym
operator|=
operator|(
name|c_linker_sym_t
operator|)
name|symp
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
return|return
name|ENOENT
return|;
block|}
name|symnum
operator|=
name|ef
operator|->
name|chains
index|[
name|symnum
index|]
expr_stmt|;
block|}
comment|/* If we have not found it, look at the full table (if loaded) */
if|if
condition|(
name|ef
operator|->
name|symtab
operator|==
name|ef
operator|->
name|ddbsymtab
condition|)
return|return
name|ENOENT
return|;
comment|/* Exhaustive search */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|symp
operator|=
name|ef
operator|->
name|ddbsymtab
init|;
name|i
operator|<
name|ef
operator|->
name|ddbsymcnt
condition|;
name|i
operator|++
operator|,
name|symp
operator|++
control|)
block|{
name|strp
operator|=
name|ef
operator|->
name|ddbstrtab
operator|+
name|symp
operator|->
name|st_name
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|strp
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|symp
operator|->
name|st_shndx
operator|!=
name|SHN_UNDEF
operator|||
operator|(
name|symp
operator|->
name|st_value
operator|!=
literal|0
operator|&&
name|ELF_ST_TYPE
argument_list|(
name|symp
operator|->
name|st_info
argument_list|)
operator|==
name|STT_FUNC
operator|)
condition|)
block|{
operator|*
name|sym
operator|=
operator|(
name|c_linker_sym_t
operator|)
name|symp
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
return|return
name|ENOENT
return|;
block|}
block|}
return|return
name|ENOENT
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|link_elf_symbol_values
parameter_list|(
name|linker_file_t
name|lf
parameter_list|,
name|c_linker_sym_t
name|sym
parameter_list|,
name|linker_symval_t
modifier|*
name|symval
parameter_list|)
block|{
name|elf_file_t
name|ef
init|=
name|lf
operator|->
name|priv
decl_stmt|;
specifier|const
name|Elf_Sym
modifier|*
name|es
init|=
operator|(
specifier|const
name|Elf_Sym
operator|*
operator|)
name|sym
decl_stmt|;
if|if
condition|(
name|es
operator|>=
name|ef
operator|->
name|symtab
operator|&&
operator|(
operator|(
name|es
operator|-
name|ef
operator|->
name|symtab
operator|)
operator|<
name|ef
operator|->
name|nchains
operator|)
condition|)
block|{
name|symval
operator|->
name|name
operator|=
name|ef
operator|->
name|strtab
operator|+
name|es
operator|->
name|st_name
expr_stmt|;
name|symval
operator|->
name|value
operator|=
operator|(
name|caddr_t
operator|)
name|ef
operator|->
name|address
operator|+
name|es
operator|->
name|st_value
expr_stmt|;
name|symval
operator|->
name|size
operator|=
name|es
operator|->
name|st_size
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|ef
operator|->
name|symtab
operator|==
name|ef
operator|->
name|ddbsymtab
condition|)
return|return
name|ENOENT
return|;
if|if
condition|(
name|es
operator|>=
name|ef
operator|->
name|ddbsymtab
operator|&&
operator|(
operator|(
name|es
operator|-
name|ef
operator|->
name|ddbsymtab
operator|)
operator|<
name|ef
operator|->
name|ddbsymcnt
operator|)
condition|)
block|{
name|symval
operator|->
name|name
operator|=
name|ef
operator|->
name|ddbstrtab
operator|+
name|es
operator|->
name|st_name
expr_stmt|;
name|symval
operator|->
name|value
operator|=
operator|(
name|caddr_t
operator|)
name|ef
operator|->
name|address
operator|+
name|es
operator|->
name|st_value
expr_stmt|;
name|symval
operator|->
name|size
operator|=
name|es
operator|->
name|st_size
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
name|ENOENT
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|link_elf_search_symbol
parameter_list|(
name|linker_file_t
name|lf
parameter_list|,
name|caddr_t
name|value
parameter_list|,
name|c_linker_sym_t
modifier|*
name|sym
parameter_list|,
name|long
modifier|*
name|diffp
parameter_list|)
block|{
name|elf_file_t
name|ef
init|=
name|lf
operator|->
name|priv
decl_stmt|;
name|u_long
name|off
init|=
operator|(
name|uintptr_t
operator|)
operator|(
name|void
operator|*
operator|)
name|value
decl_stmt|;
name|u_long
name|diff
init|=
name|off
decl_stmt|;
name|u_long
name|st_value
decl_stmt|;
specifier|const
name|Elf_Sym
modifier|*
name|es
decl_stmt|;
specifier|const
name|Elf_Sym
modifier|*
name|best
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|es
operator|=
name|ef
operator|->
name|ddbsymtab
init|;
name|i
operator|<
name|ef
operator|->
name|ddbsymcnt
condition|;
name|i
operator|++
operator|,
name|es
operator|++
control|)
block|{
if|if
condition|(
name|es
operator|->
name|st_name
operator|==
literal|0
condition|)
continue|continue;
name|st_value
operator|=
name|es
operator|->
name|st_value
operator|+
operator|(
name|uintptr_t
operator|)
operator|(
name|void
operator|*
operator|)
name|ef
operator|->
name|address
expr_stmt|;
if|if
condition|(
name|off
operator|>=
name|st_value
condition|)
block|{
if|if
condition|(
name|off
operator|-
name|st_value
operator|<
name|diff
condition|)
block|{
name|diff
operator|=
name|off
operator|-
name|st_value
expr_stmt|;
name|best
operator|=
name|es
expr_stmt|;
if|if
condition|(
name|diff
operator|==
literal|0
condition|)
break|break;
block|}
elseif|else
if|if
condition|(
name|off
operator|-
name|st_value
operator|==
name|diff
condition|)
block|{
name|best
operator|=
name|es
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|best
operator|==
literal|0
condition|)
operator|*
name|diffp
operator|=
name|off
expr_stmt|;
else|else
operator|*
name|diffp
operator|=
name|diff
expr_stmt|;
operator|*
name|sym
operator|=
operator|(
name|c_linker_sym_t
operator|)
name|best
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

end_unit

