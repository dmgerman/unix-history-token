begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1994 Christopher G. Demetriou  * Copyright (c) 1982, 1986, 1989, 1993  *	The Regents of the University of California.  All rights reserved.  * (c) UNIX System Laboratories, Inc.  * All or some portions of this file are derived from material licensed  * to the University of California by American Telephone and Telegraph  * Co. or Unix System Laboratories, Inc. and are reproduced herein with  * the permission of UNIX System Laboratories, Inc.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *	@(#)kern_acct.c	8.1 (Berkeley) 6/14/93  *	$Id: kern_acct.c,v 1.18 1997/11/06 19:29:07 phk Exp $  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysproto.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mount.h>
end_include

begin_include
include|#
directive|include
file|<sys/vnode.h>
end_include

begin_include
include|#
directive|include
file|<sys/fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/syslog.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysent.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/namei.h>
end_include

begin_include
include|#
directive|include
file|<sys/acct.h>
end_include

begin_include
include|#
directive|include
file|<sys/resourcevar.h>
end_include

begin_include
include|#
directive|include
file|<sys/tty.h>
end_include

begin_comment
comment|/*  * The routines implemented in this file are described in:  *      Leffler, et al.: The Design and Implementation of the 4.3BSD  *	    UNIX Operating System (Addison Welley, 1989)  * on pages 62-63.  *  * Arguably, to simplify accounting operations, this mechanism should  * be replaced by one in which an accounting log file (similar to /dev/klog)  * is read by a user process, etc.  However, that has its own problems.  */
end_comment

begin_comment
comment|/*  * Internal accounting functions.  * The former's operation is described in Leffler, et al., and the latter  * was provided by UCB with the 4.4BSD-Lite release  */
end_comment

begin_decl_stmt
specifier|static
name|comp_t
name|encode_comp_t
name|__P
argument_list|(
operator|(
name|u_long
operator|,
name|u_long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|acctwatch
name|__P
argument_list|(
operator|(
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Accounting callout handle used for periodic scheduling of  * acctwatch.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|callout_handle
name|acctwatch_handle
init|=
name|CALLOUT_HANDLE_INITIALIZER
argument_list|(
operator|&
name|acctwatch_handle
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Accounting vnode pointer, and saved vnode pointer.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|vnode
modifier|*
name|acctp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|vnode
modifier|*
name|savacctp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Values associated with enabling and disabling accounting  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|acctsuspend
init|=
literal|2
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* stop accounting when< 2% free space left */
end_comment

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_kern
argument_list|,
name|OID_AUTO
argument_list|,
name|acct_suspend
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|acctsuspend
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|acctresume
init|=
literal|4
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* resume when free space risen to> 4% */
end_comment

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_kern
argument_list|,
name|OID_AUTO
argument_list|,
name|acct_resume
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|acctresume
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|acctchkfreq
init|=
literal|15
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* frequency (in seconds) to check space */
end_comment

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_kern
argument_list|,
name|OID_AUTO
argument_list|,
name|acct_chkfreq
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|acctchkfreq
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Accounting system call.  Written based on the specification and  * previous implementation done by Mark Tinguely.  */
end_comment

begin_function
name|int
name|acct
parameter_list|(
name|a1
parameter_list|,
name|uap
parameter_list|)
name|struct
name|proc
modifier|*
name|a1
decl_stmt|;
name|struct
name|acct_args
comment|/* { 		syscallarg(char *) path; 	} */
modifier|*
name|uap
decl_stmt|;
block|{
name|struct
name|proc
modifier|*
name|p
init|=
name|curproc
decl_stmt|;
comment|/* XXX */
name|struct
name|nameidata
name|nd
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* Make sure that the caller is root. */
name|error
operator|=
name|suser
argument_list|(
name|p
operator|->
name|p_ucred
argument_list|,
operator|&
name|p
operator|->
name|p_acflag
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* 	 * If accounting is to be started to a file, open that file for 	 * writing and make sure it's a 'normal'. 	 */
if|if
condition|(
name|SCARG
argument_list|(
name|uap
argument_list|,
name|path
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|NDINIT
argument_list|(
operator|&
name|nd
argument_list|,
name|LOOKUP
argument_list|,
name|NOFOLLOW
argument_list|,
name|UIO_USERSPACE
argument_list|,
name|SCARG
argument_list|(
name|uap
argument_list|,
name|path
argument_list|)
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|error
operator|=
name|vn_open
argument_list|(
operator|&
name|nd
argument_list|,
name|FWRITE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|VOP_UNLOCK
argument_list|(
name|nd
operator|.
name|ni_vp
argument_list|,
literal|0
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|nd
operator|.
name|ni_vp
operator|->
name|v_type
operator|!=
name|VREG
condition|)
block|{
name|vn_close
argument_list|(
name|nd
operator|.
name|ni_vp
argument_list|,
name|FWRITE
argument_list|,
name|p
operator|->
name|p_ucred
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
name|EACCES
operator|)
return|;
block|}
block|}
comment|/* 	 * If accounting was previously enabled, kill the old space-watcher, 	 * close the file, and (if no new file was specified, leave). 	 */
if|if
condition|(
name|acctp
operator|!=
name|NULLVP
operator|||
name|savacctp
operator|!=
name|NULLVP
condition|)
block|{
name|untimeout
argument_list|(
name|acctwatch
argument_list|,
name|NULL
argument_list|,
name|acctwatch_handle
argument_list|)
expr_stmt|;
name|error
operator|=
name|vn_close
argument_list|(
operator|(
name|acctp
operator|!=
name|NULLVP
condition|?
name|acctp
else|:
name|savacctp
operator|)
argument_list|,
name|FWRITE
argument_list|,
name|p
operator|->
name|p_ucred
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|acctp
operator|=
name|savacctp
operator|=
name|NULLVP
expr_stmt|;
block|}
if|if
condition|(
name|SCARG
argument_list|(
name|uap
argument_list|,
name|path
argument_list|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* 	 * Save the new accounting file vnode, and schedule the new 	 * free space watcher. 	 */
name|acctp
operator|=
name|nd
operator|.
name|ni_vp
expr_stmt|;
name|acctwatch
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Write out process accounting information, on process exit.  * Data to be written out is specified in Leffler, et al.  * and are enumerated below.  (They're also noted in the system  * "acct.h" header file.)  */
end_comment

begin_function
name|int
name|acct_process
parameter_list|(
name|p
parameter_list|)
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
block|{
name|struct
name|acct
name|acct
decl_stmt|;
name|struct
name|rusage
modifier|*
name|r
decl_stmt|;
name|struct
name|timeval
name|ut
decl_stmt|,
name|st
decl_stmt|,
name|tmp
decl_stmt|;
name|int
name|t
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
comment|/* If accounting isn't enabled, don't bother */
name|vp
operator|=
name|acctp
expr_stmt|;
if|if
condition|(
name|vp
operator|==
name|NULLVP
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * Get process accounting information. 	 */
comment|/* (1) The name of the command that ran */
name|bcopy
argument_list|(
name|p
operator|->
name|p_comm
argument_list|,
name|acct
operator|.
name|ac_comm
argument_list|,
sizeof|sizeof
name|acct
operator|.
name|ac_comm
argument_list|)
expr_stmt|;
comment|/* (2) The amount of user and system time that was used */
name|calcru
argument_list|(
name|p
argument_list|,
operator|&
name|ut
argument_list|,
operator|&
name|st
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|acct
operator|.
name|ac_utime
operator|=
name|encode_comp_t
argument_list|(
name|ut
operator|.
name|tv_sec
argument_list|,
name|ut
operator|.
name|tv_usec
argument_list|)
expr_stmt|;
name|acct
operator|.
name|ac_stime
operator|=
name|encode_comp_t
argument_list|(
name|st
operator|.
name|tv_sec
argument_list|,
name|st
operator|.
name|tv_usec
argument_list|)
expr_stmt|;
comment|/* (3) The elapsed time the commmand ran (and its starting time) */
name|acct
operator|.
name|ac_btime
operator|=
name|p
operator|->
name|p_stats
operator|->
name|p_start
operator|.
name|tv_sec
expr_stmt|;
name|microtime
argument_list|(
operator|&
name|tmp
argument_list|)
expr_stmt|;
name|timevalsub
argument_list|(
operator|&
name|tmp
argument_list|,
operator|&
name|p
operator|->
name|p_stats
operator|->
name|p_start
argument_list|)
expr_stmt|;
name|acct
operator|.
name|ac_etime
operator|=
name|encode_comp_t
argument_list|(
name|tmp
operator|.
name|tv_sec
argument_list|,
name|tmp
operator|.
name|tv_usec
argument_list|)
expr_stmt|;
comment|/* (4) The average amount of memory used */
name|r
operator|=
operator|&
name|p
operator|->
name|p_stats
operator|->
name|p_ru
expr_stmt|;
name|tmp
operator|=
name|ut
expr_stmt|;
name|timevaladd
argument_list|(
operator|&
name|tmp
argument_list|,
operator|&
name|st
argument_list|)
expr_stmt|;
name|t
operator|=
name|tmp
operator|.
name|tv_sec
operator|*
name|hz
operator|+
name|tmp
operator|.
name|tv_usec
operator|/
name|tick
expr_stmt|;
if|if
condition|(
name|t
condition|)
name|acct
operator|.
name|ac_mem
operator|=
operator|(
name|r
operator|->
name|ru_ixrss
operator|+
name|r
operator|->
name|ru_idrss
operator|+
name|r
operator|->
name|ru_isrss
operator|)
operator|/
name|t
expr_stmt|;
else|else
name|acct
operator|.
name|ac_mem
operator|=
literal|0
expr_stmt|;
comment|/* (5) The number of disk I/O operations done */
name|acct
operator|.
name|ac_io
operator|=
name|encode_comp_t
argument_list|(
name|r
operator|->
name|ru_inblock
operator|+
name|r
operator|->
name|ru_oublock
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* (6) The UID and GID of the process */
name|acct
operator|.
name|ac_uid
operator|=
name|p
operator|->
name|p_cred
operator|->
name|p_ruid
expr_stmt|;
name|acct
operator|.
name|ac_gid
operator|=
name|p
operator|->
name|p_cred
operator|->
name|p_rgid
expr_stmt|;
comment|/* (7) The terminal from which the process was started */
if|if
condition|(
operator|(
name|p
operator|->
name|p_flag
operator|&
name|P_CONTROLT
operator|)
operator|&&
name|p
operator|->
name|p_pgrp
operator|->
name|pg_session
operator|->
name|s_ttyp
condition|)
name|acct
operator|.
name|ac_tty
operator|=
name|p
operator|->
name|p_pgrp
operator|->
name|pg_session
operator|->
name|s_ttyp
operator|->
name|t_dev
expr_stmt|;
else|else
name|acct
operator|.
name|ac_tty
operator|=
name|NODEV
expr_stmt|;
comment|/* (8) The boolean flags that tell how the process terminated, etc. */
name|acct
operator|.
name|ac_flag
operator|=
name|p
operator|->
name|p_acflag
expr_stmt|;
comment|/* 	 * Eliminate any file size rlimit. 	 */
if|if
condition|(
name|p
operator|->
name|p_limit
operator|->
name|p_refcnt
operator|>
literal|1
operator|&&
operator|(
name|p
operator|->
name|p_limit
operator|->
name|p_lflags
operator|&
name|PL_SHAREMOD
operator|)
operator|==
literal|0
condition|)
block|{
name|p
operator|->
name|p_limit
operator|->
name|p_refcnt
operator|--
expr_stmt|;
name|p
operator|->
name|p_limit
operator|=
name|limcopy
argument_list|(
name|p
operator|->
name|p_limit
argument_list|)
expr_stmt|;
block|}
name|p
operator|->
name|p_rlimit
index|[
name|RLIMIT_FSIZE
index|]
operator|.
name|rlim_cur
operator|=
name|RLIM_INFINITY
expr_stmt|;
comment|/* 	 * Write the accounting information to the file. 	 */
name|VOP_LEASE
argument_list|(
name|vp
argument_list|,
name|p
argument_list|,
name|p
operator|->
name|p_ucred
argument_list|,
name|LEASE_WRITE
argument_list|)
expr_stmt|;
return|return
operator|(
name|vn_rdwr
argument_list|(
name|UIO_WRITE
argument_list|,
name|vp
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|acct
argument_list|,
sizeof|sizeof
argument_list|(
name|acct
argument_list|)
argument_list|,
operator|(
name|off_t
operator|)
literal|0
argument_list|,
name|UIO_SYSSPACE
argument_list|,
name|IO_APPEND
operator||
name|IO_UNIT
argument_list|,
name|p
operator|->
name|p_ucred
argument_list|,
operator|(
name|int
operator|*
operator|)
literal|0
argument_list|,
name|p
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Encode_comp_t converts from ticks in seconds and microseconds  * to ticks in 1/AHZ seconds.  The encoding is described in  * Leffler, et al., on page 63.  */
end_comment

begin_define
define|#
directive|define
name|MANTSIZE
value|13
end_define

begin_comment
comment|/* 13 bit mantissa. */
end_comment

begin_define
define|#
directive|define
name|EXPSIZE
value|3
end_define

begin_comment
comment|/* Base 8 (3 bit) exponent. */
end_comment

begin_define
define|#
directive|define
name|MAXFRACT
value|((1<< MANTSIZE) - 1)
end_define

begin_comment
comment|/* Maximum fractional value. */
end_comment

begin_function
specifier|static
name|comp_t
name|encode_comp_t
parameter_list|(
name|s
parameter_list|,
name|us
parameter_list|)
name|u_long
name|s
decl_stmt|,
name|us
decl_stmt|;
block|{
name|int
name|exp
decl_stmt|,
name|rnd
decl_stmt|;
name|exp
operator|=
literal|0
expr_stmt|;
name|rnd
operator|=
literal|0
expr_stmt|;
name|s
operator|*=
name|AHZ
expr_stmt|;
name|s
operator|+=
name|us
operator|/
operator|(
literal|1000000
operator|/
name|AHZ
operator|)
expr_stmt|;
comment|/* Maximize precision. */
while|while
condition|(
name|s
operator|>
name|MAXFRACT
condition|)
block|{
name|rnd
operator|=
name|s
operator|&
operator|(
literal|1
operator|<<
operator|(
name|EXPSIZE
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
comment|/* Round up? */
name|s
operator|>>=
name|EXPSIZE
expr_stmt|;
comment|/* Base 8 exponent == 3 bit shift. */
name|exp
operator|++
expr_stmt|;
block|}
comment|/* If we need to round up, do it (and handle overflow correctly). */
if|if
condition|(
name|rnd
operator|&&
operator|(
operator|++
name|s
operator|>
name|MAXFRACT
operator|)
condition|)
block|{
name|s
operator|>>=
name|EXPSIZE
expr_stmt|;
name|exp
operator|++
expr_stmt|;
block|}
comment|/* Clean it up and polish it off. */
name|exp
operator|<<=
name|MANTSIZE
expr_stmt|;
comment|/* Shift the exponent into place */
name|exp
operator|+=
name|s
expr_stmt|;
comment|/* and add on the mantissa. */
return|return
operator|(
name|exp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Periodically check the file system to see if accounting  * should be turned on or off.  Beware the case where the vnode  * has been vgone()'d out from underneath us, e.g. when the file  * system containing the accounting file has been forcibly unmounted.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|acctwatch
parameter_list|(
name|a
parameter_list|)
name|void
modifier|*
name|a
decl_stmt|;
block|{
name|struct
name|statfs
name|sb
decl_stmt|;
if|if
condition|(
name|savacctp
operator|!=
name|NULLVP
condition|)
block|{
if|if
condition|(
name|savacctp
operator|->
name|v_type
operator|==
name|VBAD
condition|)
block|{
operator|(
name|void
operator|)
name|vn_close
argument_list|(
name|savacctp
argument_list|,
name|FWRITE
argument_list|,
name|NOCRED
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|savacctp
operator|=
name|NULLVP
expr_stmt|;
return|return;
block|}
operator|(
name|void
operator|)
name|VFS_STATFS
argument_list|(
name|savacctp
operator|->
name|v_mount
argument_list|,
operator|&
name|sb
argument_list|,
operator|(
expr|struct
name|proc
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sb
operator|.
name|f_bavail
operator|>
name|acctresume
operator|*
name|sb
operator|.
name|f_blocks
operator|/
literal|100
condition|)
block|{
name|acctp
operator|=
name|savacctp
expr_stmt|;
name|savacctp
operator|=
name|NULLVP
expr_stmt|;
name|log
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"Accounting resumed\n"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|acctp
operator|==
name|NULLVP
condition|)
return|return;
if|if
condition|(
name|acctp
operator|->
name|v_type
operator|==
name|VBAD
condition|)
block|{
operator|(
name|void
operator|)
name|vn_close
argument_list|(
name|acctp
argument_list|,
name|FWRITE
argument_list|,
name|NOCRED
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|acctp
operator|=
name|NULLVP
expr_stmt|;
return|return;
block|}
operator|(
name|void
operator|)
name|VFS_STATFS
argument_list|(
name|acctp
operator|->
name|v_mount
argument_list|,
operator|&
name|sb
argument_list|,
operator|(
expr|struct
name|proc
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sb
operator|.
name|f_bavail
operator|<=
name|acctsuspend
operator|*
name|sb
operator|.
name|f_blocks
operator|/
literal|100
condition|)
block|{
name|savacctp
operator|=
name|acctp
expr_stmt|;
name|acctp
operator|=
name|NULLVP
expr_stmt|;
name|log
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"Accounting suspended\n"
argument_list|)
expr_stmt|;
block|}
block|}
name|acctwatch_handle
operator|=
name|timeout
argument_list|(
name|acctwatch
argument_list|,
name|NULL
argument_list|,
name|acctchkfreq
operator|*
name|hz
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

