begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1982, 1986, 1989, 1993  *	The Regents of the University of California.  All rights reserved.  * (c) UNIX System Laboratories, Inc.  * Copyright (c) 2005 Robert N. M. Watson  * All rights reserved.  *  * All or some portions of this file are derived from material licensed  * to the University of California by American Telephone and Telegraph  * Co. or Unix System Laboratories, Inc. and are reproduced herein with  * the permission of UNIX System Laboratories, Inc.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * Copyright (c) 1994 Christopher G. Demetriou  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *	@(#)kern_acct.c	8.1 (Berkeley) 6/14/93  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"opt_mac.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/acct.h>
end_include

begin_include
include|#
directive|include
file|<sys/fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/kthread.h>
end_include

begin_include
include|#
directive|include
file|<sys/limits.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mount.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/namei.h>
end_include

begin_include
include|#
directive|include
file|<sys/priv.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/resourcevar.h>
end_include

begin_include
include|#
directive|include
file|<sys/sched.h>
end_include

begin_include
include|#
directive|include
file|<sys/sx.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysent.h>
end_include

begin_include
include|#
directive|include
file|<sys/syslog.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysproto.h>
end_include

begin_include
include|#
directive|include
file|<sys/tty.h>
end_include

begin_include
include|#
directive|include
file|<sys/vnode.h>
end_include

begin_include
include|#
directive|include
file|<security/mac/mac_framework.h>
end_include

begin_comment
comment|/*  * The routines implemented in this file are described in:  *      Leffler, et al.: The Design and Implementation of the 4.3BSD  *	    UNIX Operating System (Addison Welley, 1989)  * on pages 62-63.  * On May 2007 the historic 3 bits base 8 exponent, 13 bit fraction  * compt_t representation described in the above reference was replaced  * with that of IEEE-754 floats.  *  * Arguably, to simplify accounting operations, this mechanism should  * be replaced by one in which an accounting log file (similar to /dev/klog)  * is read by a user process, etc.  However, that has its own problems.  */
end_comment

begin_comment
comment|/* Floating point definitions from<float.h>. */
end_comment

begin_define
define|#
directive|define
name|FLT_MANT_DIG
value|24
end_define

begin_comment
comment|/* p */
end_comment

begin_define
define|#
directive|define
name|FLT_MAX_EXP
value|128
end_define

begin_comment
comment|/* emax */
end_comment

begin_comment
comment|/*  * Internal accounting functions.  * The former's operation is described in Leffler, et al., and the latter  * was provided by UCB with the 4.4BSD-Lite release  */
end_comment

begin_function_decl
specifier|static
name|uint32_t
name|encode_timeval
parameter_list|(
name|struct
name|timeval
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint32_t
name|encode_long
parameter_list|(
name|long
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|acctwatch
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|acct_thread
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|acct_disable
parameter_list|(
name|struct
name|thread
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Accounting vnode pointer, saved vnode pointer, and flags for each.  * acct_sx protects against changes to the active vnode and credentials  * while accounting records are being committed to disk.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|acct_configured
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|acct_suspended
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|vnode
modifier|*
name|acct_vp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|ucred
modifier|*
name|acct_cred
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|acct_flags
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|sx
name|acct_sx
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SX_SYSINIT
argument_list|(
name|acct
argument_list|,
operator|&
name|acct_sx
argument_list|,
literal|"acct_sx"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * State of the accounting kthread.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|acct_state
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|ACCT_RUNNING
value|1
end_define

begin_comment
comment|/* Accounting kthread is running. */
end_comment

begin_define
define|#
directive|define
name|ACCT_EXITREQ
value|2
end_define

begin_comment
comment|/* Accounting kthread should exit. */
end_comment

begin_comment
comment|/*  * Values associated with enabling and disabling accounting  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|acctsuspend
init|=
literal|2
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* stop accounting when< 2% free space left */
end_comment

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_kern
argument_list|,
name|OID_AUTO
argument_list|,
name|acct_suspend
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|acctsuspend
argument_list|,
literal|0
argument_list|,
literal|"percentage of free disk space below which accounting stops"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|acctresume
init|=
literal|4
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* resume when free space risen to> 4% */
end_comment

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_kern
argument_list|,
name|OID_AUTO
argument_list|,
name|acct_resume
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|acctresume
argument_list|,
literal|0
argument_list|,
literal|"percentage of free disk space above which accounting resumes"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|acctchkfreq
init|=
literal|15
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* frequency (in seconds) to check space */
end_comment

begin_function
specifier|static
name|int
name|sysctl_acct_chkfreq
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|int
name|error
decl_stmt|,
name|value
decl_stmt|;
comment|/* Write out the old value. */
name|error
operator|=
name|SYSCTL_OUT
argument_list|(
name|req
argument_list|,
operator|&
name|acctchkfreq
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
name|req
operator|->
name|newptr
operator|==
name|NULL
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* Read in and verify the new value. */
name|error
operator|=
name|SYSCTL_IN
argument_list|(
name|req
argument_list|,
operator|&
name|value
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|value
operator|<=
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|acctchkfreq
operator|=
name|value
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|SYSCTL_PROC
argument_list|(
name|_kern
argument_list|,
name|OID_AUTO
argument_list|,
name|acct_chkfreq
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
operator|&
name|acctchkfreq
argument_list|,
literal|0
argument_list|,
name|sysctl_acct_chkfreq
argument_list|,
literal|"I"
argument_list|,
literal|"frequency for checking the free space"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_kern
argument_list|,
name|OID_AUTO
argument_list|,
name|acct_configured
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|acct_configured
argument_list|,
literal|0
argument_list|,
literal|"Accounting configured or not"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_kern
argument_list|,
name|OID_AUTO
argument_list|,
name|acct_suspended
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|acct_suspended
argument_list|,
literal|0
argument_list|,
literal|"Accounting suspended or not"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Accounting system call.  Written based on the specification and previous  * implementation done by Mark Tinguely.  */
end_comment

begin_function
name|int
name|acct
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|acct_args
modifier|*
name|uap
parameter_list|)
block|{
name|struct
name|nameidata
name|nd
decl_stmt|;
name|int
name|error
decl_stmt|,
name|flags
decl_stmt|,
name|vfslocked
decl_stmt|;
name|error
operator|=
name|priv_check
argument_list|(
name|td
argument_list|,
name|PRIV_ACCT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* 	 * If accounting is to be started to a file, open that file for 	 * appending and make sure it's a 'normal'. 	 */
if|if
condition|(
name|uap
operator|->
name|path
operator|!=
name|NULL
condition|)
block|{
name|NDINIT
argument_list|(
operator|&
name|nd
argument_list|,
name|LOOKUP
argument_list|,
name|NOFOLLOW
operator||
name|MPSAFE
operator||
name|AUDITVNODE1
argument_list|,
name|UIO_USERSPACE
argument_list|,
name|uap
operator|->
name|path
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|flags
operator|=
name|FWRITE
operator||
name|O_APPEND
expr_stmt|;
name|error
operator|=
name|vn_open
argument_list|(
operator|&
name|nd
argument_list|,
operator|&
name|flags
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|vfslocked
operator|=
name|NDHASGIANT
argument_list|(
operator|&
name|nd
argument_list|)
expr_stmt|;
name|NDFREE
argument_list|(
operator|&
name|nd
argument_list|,
name|NDF_ONLY_PNBUF
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MAC
name|error
operator|=
name|mac_system_check_acct
argument_list|(
name|td
operator|->
name|td_ucred
argument_list|,
name|nd
operator|.
name|ni_vp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|VOP_UNLOCK
argument_list|(
name|nd
operator|.
name|ni_vp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|vn_close
argument_list|(
name|nd
operator|.
name|ni_vp
argument_list|,
name|flags
argument_list|,
name|td
operator|->
name|td_ucred
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|VFS_UNLOCK_GIANT
argument_list|(
name|vfslocked
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
endif|#
directive|endif
name|VOP_UNLOCK
argument_list|(
name|nd
operator|.
name|ni_vp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|nd
operator|.
name|ni_vp
operator|->
name|v_type
operator|!=
name|VREG
condition|)
block|{
name|vn_close
argument_list|(
name|nd
operator|.
name|ni_vp
argument_list|,
name|flags
argument_list|,
name|td
operator|->
name|td_ucred
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|VFS_UNLOCK_GIANT
argument_list|(
name|vfslocked
argument_list|)
expr_stmt|;
return|return
operator|(
name|EACCES
operator|)
return|;
block|}
name|VFS_UNLOCK_GIANT
argument_list|(
name|vfslocked
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MAC
block|}
else|else
block|{
name|error
operator|=
name|mac_system_check_acct
argument_list|(
name|td
operator|->
name|td_ucred
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
endif|#
directive|endif
block|}
comment|/* 	 * Disallow concurrent access to the accounting vnode while we swap 	 * it out, in order to prevent access after close. 	 */
name|sx_xlock
argument_list|(
operator|&
name|acct_sx
argument_list|)
expr_stmt|;
comment|/* 	 * If accounting was previously enabled, kill the old space-watcher, 	 * close the file, and (if no new file was specified, leave).  Reset 	 * the suspended state regardless of whether accounting remains 	 * enabled. 	 */
name|acct_suspended
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|acct_vp
operator|!=
name|NULL
condition|)
block|{
name|vfslocked
operator|=
name|VFS_LOCK_GIANT
argument_list|(
name|acct_vp
operator|->
name|v_mount
argument_list|)
expr_stmt|;
name|error
operator|=
name|acct_disable
argument_list|(
name|td
argument_list|)
expr_stmt|;
name|VFS_UNLOCK_GIANT
argument_list|(
name|vfslocked
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|uap
operator|->
name|path
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|acct_state
operator|&
name|ACCT_RUNNING
condition|)
block|{
name|acct_state
operator||=
name|ACCT_EXITREQ
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|acct_state
argument_list|)
expr_stmt|;
block|}
name|sx_xunlock
argument_list|(
operator|&
name|acct_sx
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* 	 * Save the new accounting file vnode, and schedule the new 	 * free space watcher. 	 */
name|acct_vp
operator|=
name|nd
operator|.
name|ni_vp
expr_stmt|;
name|acct_cred
operator|=
name|crhold
argument_list|(
name|td
operator|->
name|td_ucred
argument_list|)
expr_stmt|;
name|acct_flags
operator|=
name|flags
expr_stmt|;
if|if
condition|(
name|acct_state
operator|&
name|ACCT_RUNNING
condition|)
name|acct_state
operator|&=
operator|~
name|ACCT_EXITREQ
expr_stmt|;
else|else
block|{
comment|/* 		 * Try to start up an accounting kthread.  We may start more 		 * than one, but if so the extras will commit suicide as 		 * soon as they start up. 		 */
name|error
operator|=
name|kproc_create
argument_list|(
name|acct_thread
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|"accounting"
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|vfslocked
operator|=
name|VFS_LOCK_GIANT
argument_list|(
name|acct_vp
operator|->
name|v_mount
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|vn_close
argument_list|(
name|acct_vp
argument_list|,
name|acct_flags
argument_list|,
name|acct_cred
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|VFS_UNLOCK_GIANT
argument_list|(
name|vfslocked
argument_list|)
expr_stmt|;
name|crfree
argument_list|(
name|acct_cred
argument_list|)
expr_stmt|;
name|acct_configured
operator|=
literal|0
expr_stmt|;
name|acct_vp
operator|=
name|NULL
expr_stmt|;
name|acct_cred
operator|=
name|NULL
expr_stmt|;
name|acct_flags
operator|=
literal|0
expr_stmt|;
name|sx_xunlock
argument_list|(
operator|&
name|acct_sx
argument_list|)
expr_stmt|;
name|log
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"Unable to start accounting thread\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
name|acct_configured
operator|=
literal|1
expr_stmt|;
name|sx_xunlock
argument_list|(
operator|&
name|acct_sx
argument_list|)
expr_stmt|;
name|log
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"Accounting enabled\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Disable currently in-progress accounting by closing the vnode, dropping  * our reference to the credential, and clearing the vnode's flags.  */
end_comment

begin_function
specifier|static
name|int
name|acct_disable
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|sx_assert
argument_list|(
operator|&
name|acct_sx
argument_list|,
name|SX_XLOCKED
argument_list|)
expr_stmt|;
name|error
operator|=
name|vn_close
argument_list|(
name|acct_vp
argument_list|,
name|acct_flags
argument_list|,
name|acct_cred
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|crfree
argument_list|(
name|acct_cred
argument_list|)
expr_stmt|;
name|acct_configured
operator|=
literal|0
expr_stmt|;
name|acct_vp
operator|=
name|NULL
expr_stmt|;
name|acct_cred
operator|=
name|NULL
expr_stmt|;
name|acct_flags
operator|=
literal|0
expr_stmt|;
name|log
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"Accounting disabled\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Write out process accounting information, on process exit.  * Data to be written out is specified in Leffler, et al.  * and are enumerated below.  (They're also noted in the system  * "acct.h" header file.)  */
end_comment

begin_function
name|int
name|acct_process
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|acctv2
name|acct
decl_stmt|;
name|struct
name|timeval
name|ut
decl_stmt|,
name|st
decl_stmt|,
name|tmp
decl_stmt|;
name|struct
name|plimit
modifier|*
name|newlim
decl_stmt|,
modifier|*
name|oldlim
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|struct
name|rusage
name|ru
decl_stmt|;
name|int
name|t
decl_stmt|,
name|ret
decl_stmt|,
name|vfslocked
decl_stmt|;
comment|/* 	 * Lockless check of accounting condition before doing the hard 	 * work. 	 */
if|if
condition|(
name|acct_vp
operator|==
name|NULL
operator|||
name|acct_suspended
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|sx_slock
argument_list|(
operator|&
name|acct_sx
argument_list|)
expr_stmt|;
comment|/* 	 * If accounting isn't enabled, don't bother.  Have to check again 	 * once we own the lock in case we raced with disabling of accounting 	 * by another thread. 	 */
if|if
condition|(
name|acct_vp
operator|==
name|NULL
operator|||
name|acct_suspended
condition|)
block|{
name|sx_sunlock
argument_list|(
operator|&
name|acct_sx
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|p
operator|=
name|td
operator|->
name|td_proc
expr_stmt|;
comment|/* 	 * Get process accounting information. 	 */
name|sx_slock
argument_list|(
operator|&
name|proctree_lock
argument_list|)
expr_stmt|;
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* (1) The terminal from which the process was started */
if|if
condition|(
operator|(
name|p
operator|->
name|p_flag
operator|&
name|P_CONTROLT
operator|)
operator|&&
name|p
operator|->
name|p_pgrp
operator|->
name|pg_session
operator|->
name|s_ttyp
condition|)
name|acct
operator|.
name|ac_tty
operator|=
name|tty_udev
argument_list|(
name|p
operator|->
name|p_pgrp
operator|->
name|pg_session
operator|->
name|s_ttyp
argument_list|)
expr_stmt|;
else|else
name|acct
operator|.
name|ac_tty
operator|=
name|NODEV
expr_stmt|;
name|sx_sunlock
argument_list|(
operator|&
name|proctree_lock
argument_list|)
expr_stmt|;
comment|/* (2) The name of the command that ran */
name|bcopy
argument_list|(
name|p
operator|->
name|p_comm
argument_list|,
name|acct
operator|.
name|ac_comm
argument_list|,
sizeof|sizeof
name|acct
operator|.
name|ac_comm
argument_list|)
expr_stmt|;
comment|/* (3) The amount of user and system time that was used */
name|rufetchcalc
argument_list|(
name|p
argument_list|,
operator|&
name|ru
argument_list|,
operator|&
name|ut
argument_list|,
operator|&
name|st
argument_list|)
expr_stmt|;
name|acct
operator|.
name|ac_utime
operator|=
name|encode_timeval
argument_list|(
name|ut
argument_list|)
expr_stmt|;
name|acct
operator|.
name|ac_stime
operator|=
name|encode_timeval
argument_list|(
name|st
argument_list|)
expr_stmt|;
comment|/* (4) The elapsed time the command ran (and its starting time) */
name|tmp
operator|=
name|boottime
expr_stmt|;
name|timevaladd
argument_list|(
operator|&
name|tmp
argument_list|,
operator|&
name|p
operator|->
name|p_stats
operator|->
name|p_start
argument_list|)
expr_stmt|;
name|acct
operator|.
name|ac_btime
operator|=
name|tmp
operator|.
name|tv_sec
expr_stmt|;
name|microuptime
argument_list|(
operator|&
name|tmp
argument_list|)
expr_stmt|;
name|timevalsub
argument_list|(
operator|&
name|tmp
argument_list|,
operator|&
name|p
operator|->
name|p_stats
operator|->
name|p_start
argument_list|)
expr_stmt|;
name|acct
operator|.
name|ac_etime
operator|=
name|encode_timeval
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
comment|/* (5) The average amount of memory used */
name|tmp
operator|=
name|ut
expr_stmt|;
name|timevaladd
argument_list|(
operator|&
name|tmp
argument_list|,
operator|&
name|st
argument_list|)
expr_stmt|;
comment|/* Convert tmp (i.e. u + s) into hz units to match ru_i*. */
name|t
operator|=
name|tmp
operator|.
name|tv_sec
operator|*
name|hz
operator|+
name|tmp
operator|.
name|tv_usec
operator|/
name|tick
expr_stmt|;
if|if
condition|(
name|t
condition|)
name|acct
operator|.
name|ac_mem
operator|=
name|encode_long
argument_list|(
operator|(
name|ru
operator|.
name|ru_ixrss
operator|+
name|ru
operator|.
name|ru_idrss
operator|+
operator|+
name|ru
operator|.
name|ru_isrss
operator|)
operator|/
name|t
argument_list|)
expr_stmt|;
else|else
name|acct
operator|.
name|ac_mem
operator|=
literal|0
expr_stmt|;
comment|/* (6) The number of disk I/O operations done */
name|acct
operator|.
name|ac_io
operator|=
name|encode_long
argument_list|(
name|ru
operator|.
name|ru_inblock
operator|+
name|ru
operator|.
name|ru_oublock
argument_list|)
expr_stmt|;
comment|/* (7) The UID and GID of the process */
name|acct
operator|.
name|ac_uid
operator|=
name|p
operator|->
name|p_ucred
operator|->
name|cr_ruid
expr_stmt|;
name|acct
operator|.
name|ac_gid
operator|=
name|p
operator|->
name|p_ucred
operator|->
name|cr_rgid
expr_stmt|;
comment|/* (8) The boolean flags that tell how the process terminated, etc. */
name|acct
operator|.
name|ac_flagx
operator|=
name|p
operator|->
name|p_acflag
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* Setup ancillary structure fields. */
name|acct
operator|.
name|ac_flagx
operator||=
name|ANVER
expr_stmt|;
name|acct
operator|.
name|ac_zero
operator|=
literal|0
expr_stmt|;
name|acct
operator|.
name|ac_version
operator|=
literal|2
expr_stmt|;
name|acct
operator|.
name|ac_len
operator|=
name|acct
operator|.
name|ac_len2
operator|=
sizeof|sizeof
argument_list|(
name|acct
argument_list|)
expr_stmt|;
comment|/* 	 * Eliminate any file size rlimit. 	 */
name|newlim
operator|=
name|lim_alloc
argument_list|()
expr_stmt|;
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|oldlim
operator|=
name|p
operator|->
name|p_limit
expr_stmt|;
name|lim_copy
argument_list|(
name|newlim
argument_list|,
name|oldlim
argument_list|)
expr_stmt|;
name|newlim
operator|->
name|pl_rlimit
index|[
name|RLIMIT_FSIZE
index|]
operator|.
name|rlim_cur
operator|=
name|RLIM_INFINITY
expr_stmt|;
name|p
operator|->
name|p_limit
operator|=
name|newlim
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|lim_free
argument_list|(
name|oldlim
argument_list|)
expr_stmt|;
comment|/* 	 * Write the accounting information to the file. 	 */
name|vfslocked
operator|=
name|VFS_LOCK_GIANT
argument_list|(
name|acct_vp
operator|->
name|v_mount
argument_list|)
expr_stmt|;
name|VOP_LEASE
argument_list|(
name|acct_vp
argument_list|,
name|td
argument_list|,
name|acct_cred
argument_list|,
name|LEASE_WRITE
argument_list|)
expr_stmt|;
name|ret
operator|=
name|vn_rdwr
argument_list|(
name|UIO_WRITE
argument_list|,
name|acct_vp
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|acct
argument_list|,
sizeof|sizeof
argument_list|(
name|acct
argument_list|)
argument_list|,
operator|(
name|off_t
operator|)
literal|0
argument_list|,
name|UIO_SYSSPACE
argument_list|,
name|IO_APPEND
operator||
name|IO_UNIT
argument_list|,
name|acct_cred
argument_list|,
name|NOCRED
argument_list|,
operator|(
name|int
operator|*
operator|)
literal|0
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|VFS_UNLOCK_GIANT
argument_list|(
name|vfslocked
argument_list|)
expr_stmt|;
name|sx_sunlock
argument_list|(
operator|&
name|acct_sx
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/* FLOAT_CONVERSION_START (Regression testing; don't remove this line.) */
end_comment

begin_comment
comment|/* Convert timevals and longs into IEEE-754 bit patterns. */
end_comment

begin_comment
comment|/* Mantissa mask (MSB is implied, so subtract 1). */
end_comment

begin_define
define|#
directive|define
name|MANT_MASK
value|((1<< (FLT_MANT_DIG - 1)) - 1)
end_define

begin_comment
comment|/*  * We calculate integer values to a precision of approximately  * 28 bits.  * This is high-enough precision to fill the 24 float bits  * and low-enough to avoid overflowing the 32 int bits.  */
end_comment

begin_define
define|#
directive|define
name|CALC_BITS
value|28
end_define

begin_comment
comment|/* log_2(1000000). */
end_comment

begin_define
define|#
directive|define
name|LOG2_1M
value|20
end_define

begin_comment
comment|/*  * Convert the elements of a timeval into a 32-bit word holding  * the bits of a IEEE-754 float.  * The float value represents the timeval's value in microsecond units.  */
end_comment

begin_function
specifier|static
name|uint32_t
name|encode_timeval
parameter_list|(
name|struct
name|timeval
name|tv
parameter_list|)
block|{
name|int
name|log2_s
decl_stmt|;
name|int
name|val
decl_stmt|,
name|exp
decl_stmt|;
comment|/* Unnormalized value and exponent */
name|int
name|norm_exp
decl_stmt|;
comment|/* Normalized exponent */
name|int
name|shift
decl_stmt|;
comment|/* 	 * First calculate value and exponent to about CALC_BITS precision. 	 * Note that the following conditionals have been ordered so that 	 * the most common cases appear first. 	 */
if|if
condition|(
name|tv
operator|.
name|tv_sec
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|tv
operator|.
name|tv_usec
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|exp
operator|=
literal|0
expr_stmt|;
name|val
operator|=
name|tv
operator|.
name|tv_usec
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Calculate the value to a precision of approximately 		 * CALC_BITS. 		 */
name|log2_s
operator|=
name|fls
argument_list|(
name|tv
operator|.
name|tv_sec
argument_list|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|log2_s
operator|+
name|LOG2_1M
operator|<
name|CALC_BITS
condition|)
block|{
name|exp
operator|=
literal|0
expr_stmt|;
name|val
operator|=
literal|1000000
operator|*
name|tv
operator|.
name|tv_sec
operator|+
name|tv
operator|.
name|tv_usec
expr_stmt|;
block|}
else|else
block|{
name|exp
operator|=
name|log2_s
operator|+
name|LOG2_1M
operator|-
name|CALC_BITS
expr_stmt|;
name|val
operator|=
call|(
name|unsigned
name|int
call|)
argument_list|(
operator|(
operator|(
name|u_int64_t
operator|)
literal|1000000
operator|*
name|tv
operator|.
name|tv_sec
operator|+
name|tv
operator|.
name|tv_usec
operator|)
operator|>>
name|exp
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Now normalize and pack the value into an IEEE-754 float. */
name|norm_exp
operator|=
name|fls
argument_list|(
name|val
argument_list|)
operator|-
literal|1
expr_stmt|;
name|shift
operator|=
name|FLT_MANT_DIG
operator|-
name|norm_exp
operator|-
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|ACCT_DEBUG
name|printf
argument_list|(
literal|"val=%d exp=%d shift=%d log2(val)=%d\n"
argument_list|,
name|val
argument_list|,
name|exp
argument_list|,
name|shift
argument_list|,
name|norm_exp
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"exp=%x mant=%x\n"
argument_list|,
name|FLT_MAX_EXP
operator|-
literal|1
operator|+
name|exp
operator|+
name|norm_exp
argument_list|,
operator|(
operator|(
name|shift
operator|>
literal|0
condition|?
operator|(
name|val
operator|<<
name|shift
operator|)
else|:
operator|(
name|val
operator|>>
operator|-
name|shift
operator|)
operator|)
operator|&
name|MANT_MASK
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
operator|(
operator|(
name|FLT_MAX_EXP
operator|-
literal|1
operator|+
name|exp
operator|+
name|norm_exp
operator|)
operator|<<
operator|(
name|FLT_MANT_DIG
operator|-
literal|1
operator|)
operator|)
operator||
operator|(
operator|(
name|shift
operator|>
literal|0
condition|?
name|val
operator|<<
name|shift
else|:
name|val
operator|>>
operator|-
name|shift
operator|)
operator|&
name|MANT_MASK
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Convert a non-negative long value into the bit pattern of  * an IEEE-754 float value.  */
end_comment

begin_function
specifier|static
name|uint32_t
name|encode_long
parameter_list|(
name|long
name|val
parameter_list|)
block|{
name|int
name|norm_exp
decl_stmt|;
comment|/* Normalized exponent */
name|int
name|shift
decl_stmt|;
if|if
condition|(
name|val
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|val
operator|<
literal|0
condition|)
block|{
name|log
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"encode_long: negative value %ld in accounting record\n"
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|val
operator|=
name|LONG_MAX
expr_stmt|;
block|}
name|norm_exp
operator|=
name|fls
argument_list|(
name|val
argument_list|)
operator|-
literal|1
expr_stmt|;
name|shift
operator|=
name|FLT_MANT_DIG
operator|-
name|norm_exp
operator|-
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|ACCT_DEBUG
name|printf
argument_list|(
literal|"val=%d shift=%d log2(val)=%d\n"
argument_list|,
name|val
argument_list|,
name|shift
argument_list|,
name|norm_exp
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"exp=%x mant=%x\n"
argument_list|,
name|FLT_MAX_EXP
operator|-
literal|1
operator|+
name|exp
operator|+
name|norm_exp
argument_list|,
operator|(
operator|(
name|shift
operator|>
literal|0
condition|?
operator|(
name|val
operator|<<
name|shift
operator|)
else|:
operator|(
name|val
operator|>>
operator|-
name|shift
operator|)
operator|)
operator|&
name|MANT_MASK
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
operator|(
operator|(
name|FLT_MAX_EXP
operator|-
literal|1
operator|+
name|norm_exp
operator|)
operator|<<
operator|(
name|FLT_MANT_DIG
operator|-
literal|1
operator|)
operator|)
operator||
operator|(
operator|(
name|shift
operator|>
literal|0
condition|?
name|val
operator|<<
name|shift
else|:
name|val
operator|>>
operator|-
name|shift
operator|)
operator|&
name|MANT_MASK
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* FLOAT_CONVERSION_END (Regression testing; don't remove this line.) */
end_comment

begin_comment
comment|/*  * Periodically check the filesystem to see if accounting  * should be turned on or off.  Beware the case where the vnode  * has been vgone()'d out from underneath us, e.g. when the file  * system containing the accounting file has been forcibly unmounted.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|acctwatch
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|statfs
name|sb
decl_stmt|;
name|int
name|vfslocked
decl_stmt|;
name|sx_assert
argument_list|(
operator|&
name|acct_sx
argument_list|,
name|SX_XLOCKED
argument_list|)
expr_stmt|;
comment|/* 	 * If accounting was disabled before our kthread was scheduled, 	 * then acct_vp might be NULL.  If so, just ask our kthread to 	 * exit and return. 	 */
if|if
condition|(
name|acct_vp
operator|==
name|NULL
condition|)
block|{
name|acct_state
operator||=
name|ACCT_EXITREQ
expr_stmt|;
return|return;
block|}
comment|/* 	 * If our vnode is no longer valid, tear it down and signal the 	 * accounting thread to die. 	 */
name|vfslocked
operator|=
name|VFS_LOCK_GIANT
argument_list|(
name|acct_vp
operator|->
name|v_mount
argument_list|)
expr_stmt|;
if|if
condition|(
name|acct_vp
operator|->
name|v_type
operator|==
name|VBAD
condition|)
block|{
operator|(
name|void
operator|)
name|acct_disable
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|VFS_UNLOCK_GIANT
argument_list|(
name|vfslocked
argument_list|)
expr_stmt|;
name|acct_state
operator||=
name|ACCT_EXITREQ
expr_stmt|;
return|return;
block|}
comment|/* 	 * Stopping here is better than continuing, maybe it will be VBAD 	 * next time around. 	 */
if|if
condition|(
name|VFS_STATFS
argument_list|(
name|acct_vp
operator|->
name|v_mount
argument_list|,
operator|&
name|sb
argument_list|,
name|curthread
argument_list|)
operator|<
literal|0
condition|)
block|{
name|VFS_UNLOCK_GIANT
argument_list|(
name|vfslocked
argument_list|)
expr_stmt|;
return|return;
block|}
name|VFS_UNLOCK_GIANT
argument_list|(
name|vfslocked
argument_list|)
expr_stmt|;
if|if
condition|(
name|acct_suspended
condition|)
block|{
if|if
condition|(
name|sb
operator|.
name|f_bavail
operator|>
call|(
name|int64_t
call|)
argument_list|(
name|acctresume
operator|*
name|sb
operator|.
name|f_blocks
operator|/
literal|100
argument_list|)
condition|)
block|{
name|acct_suspended
operator|=
literal|0
expr_stmt|;
name|log
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"Accounting resumed\n"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|sb
operator|.
name|f_bavail
operator|<=
call|(
name|int64_t
call|)
argument_list|(
name|acctsuspend
operator|*
name|sb
operator|.
name|f_blocks
operator|/
literal|100
argument_list|)
condition|)
block|{
name|acct_suspended
operator|=
literal|1
expr_stmt|;
name|log
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"Accounting suspended\n"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * The main loop for the dedicated kernel thread that periodically calls  * acctwatch().  */
end_comment

begin_function
specifier|static
name|void
name|acct_thread
parameter_list|(
name|void
modifier|*
name|dummy
parameter_list|)
block|{
name|u_char
name|pri
decl_stmt|;
comment|/* This is a low-priority kernel thread. */
name|pri
operator|=
name|PRI_MAX_KERN
expr_stmt|;
name|thread_lock
argument_list|(
name|curthread
argument_list|)
expr_stmt|;
name|sched_prio
argument_list|(
name|curthread
argument_list|,
name|pri
argument_list|)
expr_stmt|;
name|thread_unlock
argument_list|(
name|curthread
argument_list|)
expr_stmt|;
comment|/* If another accounting kthread is already running, just die. */
name|sx_xlock
argument_list|(
operator|&
name|acct_sx
argument_list|)
expr_stmt|;
if|if
condition|(
name|acct_state
operator|&
name|ACCT_RUNNING
condition|)
block|{
name|sx_xunlock
argument_list|(
operator|&
name|acct_sx
argument_list|)
expr_stmt|;
name|kproc_exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|acct_state
operator||=
name|ACCT_RUNNING
expr_stmt|;
comment|/* Loop until we are asked to exit. */
while|while
condition|(
operator|!
operator|(
name|acct_state
operator|&
name|ACCT_EXITREQ
operator|)
condition|)
block|{
comment|/* Perform our periodic checks. */
name|acctwatch
argument_list|()
expr_stmt|;
comment|/* 		 * We check this flag again before sleeping since the 		 * acctwatch() might have shut down accounting and asked us 		 * to exit. 		 */
if|if
condition|(
operator|!
operator|(
name|acct_state
operator|&
name|ACCT_EXITREQ
operator|)
condition|)
block|{
name|sx_sleep
argument_list|(
operator|&
name|acct_state
argument_list|,
operator|&
name|acct_sx
argument_list|,
literal|0
argument_list|,
literal|"-"
argument_list|,
name|acctchkfreq
operator|*
name|hz
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * Acknowledge the exit request and shutdown.  We clear both the 	 * exit request and running flags. 	 */
name|acct_state
operator|=
literal|0
expr_stmt|;
name|sx_xunlock
argument_list|(
operator|&
name|acct_sx
argument_list|)
expr_stmt|;
name|kproc_exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

