begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) UNIX System Laboratories, Inc.  All or some portions  * of this file are derived from material licensed to the  * University of California by American Telephone and Telegraph Co.  * or UNIX System Laboratories, Inc. and are reproduced herein with  * the permission of UNIX System Laboratories, Inc.  */
end_comment

begin_comment
comment|/*  * Copyright (c) 1982, 1986, 1989 Regents of the University of California.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *	from: @(#)kern_acct.c	7.18 (Berkeley) 5/11/91  *	$Id: kern_acct.c,v 1.9 1993/11/25 01:32:48 wollman Exp $  */
end_comment

begin_include
include|#
directive|include
file|"param.h"
end_include

begin_include
include|#
directive|include
file|"systm.h"
end_include

begin_include
include|#
directive|include
file|"namei.h"
end_include

begin_include
include|#
directive|include
file|"resourcevar.h"
end_include

begin_include
include|#
directive|include
file|"proc.h"
end_include

begin_include
include|#
directive|include
file|"ioctl.h"
end_include

begin_include
include|#
directive|include
file|"termios.h"
end_include

begin_include
include|#
directive|include
file|"tty.h"
end_include

begin_include
include|#
directive|include
file|"vnode.h"
end_include

begin_include
include|#
directive|include
file|"mount.h"
end_include

begin_include
include|#
directive|include
file|"kernel.h"
end_include

begin_include
include|#
directive|include
file|"file.h"
end_include

begin_include
include|#
directive|include
file|"acct.h"
end_include

begin_include
include|#
directive|include
file|"syslog.h"
end_include

begin_include
include|#
directive|include
file|"vm/vm.h"
end_include

begin_include
include|#
directive|include
file|"vm/vm_param.h"
end_include

begin_comment
comment|/*  * Values associated with enabling and disabling accounting  */
end_comment

begin_decl_stmt
name|int
name|acctsuspend
init|=
literal|2
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* stop accounting when< 2% free space left */
end_comment

begin_decl_stmt
name|int
name|acctresume
init|=
literal|4
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* resume when free space risen to> 4% */
end_comment

begin_decl_stmt
name|struct
name|timeval
name|chk
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* frequency to check space for accounting */
end_comment

begin_decl_stmt
name|struct
name|vnode
modifier|*
name|acctp
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* file to which to do accounting */
end_comment

begin_decl_stmt
name|struct
name|vnode
modifier|*
name|savacctp
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* file to which to do accounting when space */
end_comment

begin_function_decl
specifier|static
name|void
name|acctwatch
parameter_list|(
name|caddr_t
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Enable or disable process accounting.  *  * If a non-null filename is given, that file is used to store accounting  * records on process exit. If a null filename is given process accounting  * is suspended. If accounting is enabled, the system checks the amount  * of freespace on the filesystem at timeval intervals. If the amount of  * freespace is below acctsuspend percent, accounting is suspended. If  * accounting has been suspended, and freespace rises above acctresume,  * accounting is resumed.  */
end_comment

begin_comment
comment|/* Mark Tinguely (tinguely@plains.NoDak.edu) 8/10/93 */
end_comment

begin_struct
struct|struct
name|sysacct_args
block|{
name|char
modifier|*
name|fname
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|sysacct
parameter_list|(
name|p
parameter_list|,
name|uap
parameter_list|,
name|retval
parameter_list|)
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|struct
name|sysacct_args
modifier|*
name|uap
decl_stmt|;
name|int
modifier|*
name|retval
decl_stmt|;
block|{
specifier|register
name|struct
name|nameidata
modifier|*
name|ndp
decl_stmt|;
name|struct
name|nameidata
name|nd
decl_stmt|;
name|struct
name|vattr
name|attr
decl_stmt|;
name|int
name|rv
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|p_ucred
operator|->
name|cr_uid
operator|!=
literal|0
condition|)
return|return
operator|(
name|EPERM
operator|)
return|;
comment|/* must be root */
comment|/* 	 * Step 1. turn off accounting (if on). exit if fname is nil 	 */
name|rv
operator|=
literal|0
expr_stmt|;
comment|/* just in case nothing is open */
if|if
condition|(
name|acctp
operator|!=
name|NULL
condition|)
block|{
name|rv
operator|=
name|vn_close
argument_list|(
name|acctp
argument_list|,
name|FWRITE
argument_list|,
name|p
operator|->
name|p_ucred
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|untimeout
argument_list|(
name|acctwatch
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|chk
argument_list|)
expr_stmt|;
comment|/* turn off disk check */
name|acctp
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|savacctp
operator|!=
name|NULL
condition|)
block|{
name|rv
operator|=
name|vn_close
argument_list|(
name|savacctp
argument_list|,
name|FWRITE
argument_list|,
name|p
operator|->
name|p_ucred
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|untimeout
argument_list|(
name|acctwatch
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|chk
argument_list|)
expr_stmt|;
comment|/* turn off disk check */
name|savacctp
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|uap
operator|->
name|fname
operator|==
name|NULL
condition|)
comment|/* accounting stopping complete */
return|return
operator|(
name|rv
operator|)
return|;
comment|/* 	 * Step 2. open accounting filename for writing. 	 */
name|nd
operator|.
name|ni_segflg
operator|=
name|UIO_USERSPACE
expr_stmt|;
name|nd
operator|.
name|ni_dirp
operator|=
name|uap
operator|->
name|fname
expr_stmt|;
comment|/* is it there? */
if|if
condition|(
name|rv
operator|=
name|vn_open
argument_list|(
operator|&
name|nd
argument_list|,
name|p
argument_list|,
name|FWRITE
argument_list|,
literal|0
argument_list|)
condition|)
return|return
operator|(
name|rv
operator|)
return|;
comment|/* Step 2. Check the attributes on accounting file */
name|rv
operator|=
name|VOP_GETATTR
argument_list|(
name|nd
operator|.
name|ni_vp
argument_list|,
operator|&
name|attr
argument_list|,
name|p
operator|->
name|p_ucred
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
condition|)
goto|goto
name|acct_fail
goto|;
comment|/* is filesystem writable, do I have permission to write and is 	 * a regular file? 	 */
if|if
condition|(
name|nd
operator|.
name|ni_vp
operator|->
name|v_mount
operator|->
name|mnt_flag
operator|&
name|MNT_RDONLY
condition|)
block|{
name|rv
operator|=
name|EROFS
expr_stmt|;
comment|/* to be consistant with man page */
goto|goto
name|acct_fail
goto|;
block|}
if|if
condition|(
operator|(
name|VOP_ACCESS
argument_list|(
name|nd
operator|.
name|ni_vp
argument_list|,
name|VWRITE
argument_list|,
name|p
operator|->
name|p_ucred
argument_list|,
name|p
argument_list|)
operator|)
operator|||
operator|(
name|attr
operator|.
name|va_type
operator|!=
name|VREG
operator|)
condition|)
block|{
name|rv
operator|=
name|EACCES
expr_stmt|;
comment|/* permission denied error */
goto|goto
name|acct_fail
goto|;
block|}
comment|/* Step 3. Save the accounting file vnode, schedule freespace watch. */
name|acctp
operator|=
name|nd
operator|.
name|ni_vp
expr_stmt|;
name|savacctp
operator|=
name|NULL
expr_stmt|;
name|VOP_UNLOCK
argument_list|(
name|acctp
argument_list|)
expr_stmt|;
name|acctwatch
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|chk
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* look for full system */
return|return
operator|(
literal|0
operator|)
return|;
comment|/* end successfully */
name|acct_fail
label|:
name|vn_close
argument_list|(
name|nd
operator|.
name|ni_vp
argument_list|,
name|FWRITE
argument_list|,
name|p
operator|->
name|p_ucred
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
name|rv
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Periodically check the file system to see if accounting  * should be turned on or off.  */
end_comment

begin_function
specifier|static
name|void
name|acctwatch
parameter_list|(
name|arg1
parameter_list|,
name|arg2
parameter_list|)
name|caddr_t
name|arg1
decl_stmt|;
name|int
name|arg2
decl_stmt|;
block|{
name|struct
name|timeval
modifier|*
name|resettime
init|=
operator|(
expr|struct
name|timeval
operator|*
operator|)
name|arg1
decl_stmt|;
name|struct
name|statfs
name|sb
decl_stmt|;
name|int
name|s
decl_stmt|;
if|if
condition|(
name|savacctp
condition|)
block|{
operator|(
name|void
operator|)
name|VFS_STATFS
argument_list|(
name|savacctp
operator|->
name|v_mount
argument_list|,
operator|&
name|sb
argument_list|,
operator|(
expr|struct
name|proc
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sb
operator|.
name|f_bavail
operator|>
name|acctresume
operator|*
name|sb
operator|.
name|f_blocks
operator|/
literal|100
condition|)
block|{
name|acctp
operator|=
name|savacctp
expr_stmt|;
name|savacctp
operator|=
name|NULL
expr_stmt|;
name|log
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"Accounting resumed\n"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
if|if
condition|(
name|acctp
operator|==
name|NULL
condition|)
return|return;
operator|(
name|void
operator|)
name|VFS_STATFS
argument_list|(
name|acctp
operator|->
name|v_mount
argument_list|,
operator|&
name|sb
argument_list|,
operator|(
expr|struct
name|proc
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sb
operator|.
name|f_bavail
operator|<=
name|acctsuspend
operator|*
name|sb
operator|.
name|f_blocks
operator|/
literal|100
condition|)
block|{
name|savacctp
operator|=
name|acctp
expr_stmt|;
name|acctp
operator|=
name|NULL
expr_stmt|;
name|log
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"Accounting suspended\n"
argument_list|)
expr_stmt|;
block|}
name|s
operator|=
name|splhigh
argument_list|()
expr_stmt|;
operator|*
name|resettime
operator|=
name|time
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|resettime
operator|->
name|tv_sec
operator|+=
literal|15
expr_stmt|;
name|timeout
argument_list|(
name|acctwatch
argument_list|,
operator|(
name|caddr_t
operator|)
name|resettime
argument_list|,
name|hzto
argument_list|(
name|resettime
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This routine calculates an accounting record for a process and,  * if accounting is enabled, writes it to the accounting file.  */
end_comment

begin_comment
comment|/* Mark Tinguely (tinguely@plains.NoDak.edu) 8/10/93 */
end_comment

begin_function
name|void
name|acct
parameter_list|(
name|p
parameter_list|)
specifier|register
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
block|{
name|struct
name|acct
name|acct
decl_stmt|;
name|struct
name|rusage
modifier|*
name|r
decl_stmt|;
name|int
name|rv
decl_stmt|;
name|long
name|i
decl_stmt|;
name|u_int
name|cnt
decl_stmt|;
name|char
modifier|*
name|c
decl_stmt|;
name|comp_t
name|int2comp
parameter_list|()
function_decl|;
if|if
condition|(
name|acctp
operator|==
name|NULL
condition|)
comment|/* accounting not turned on */
return|return;
comment|/* Step 1. Get command name (remove path if necessary) */
name|strncpy
argument_list|(
name|acct
operator|.
name|ac_comm
argument_list|,
name|p
operator|->
name|p_comm
argument_list|,
sizeof|sizeof
argument_list|(
name|acct
operator|.
name|ac_comm
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Step 2. Get rest of information */
name|acct
operator|.
name|ac_utime
operator|=
name|int2comp
argument_list|(
operator|(
name|unsigned
operator|)
name|p
operator|->
name|p_utime
operator|.
name|tv_sec
operator|*
literal|1000000
operator|+
name|p
operator|->
name|p_utime
operator|.
name|tv_usec
argument_list|)
expr_stmt|;
name|acct
operator|.
name|ac_stime
operator|=
name|int2comp
argument_list|(
operator|(
name|unsigned
operator|)
name|p
operator|->
name|p_stime
operator|.
name|tv_sec
operator|*
literal|1000000
operator|+
name|p
operator|->
name|p_stime
operator|.
name|tv_usec
argument_list|)
expr_stmt|;
name|acct
operator|.
name|ac_btime
operator|=
name|p
operator|->
name|p_stats
operator|->
name|p_start
operator|.
name|tv_sec
expr_stmt|;
comment|/* elapse time = current - start */
name|i
operator|=
operator|(
name|time
operator|.
name|tv_sec
operator|-
name|p
operator|->
name|p_stats
operator|->
name|p_start
operator|.
name|tv_sec
operator|)
operator|*
literal|1000000
operator|+
operator|(
name|time
operator|.
name|tv_usec
operator|-
name|p
operator|->
name|p_stats
operator|->
name|p_start
operator|.
name|tv_usec
operator|)
expr_stmt|;
name|acct
operator|.
name|ac_etime
operator|=
name|int2comp
argument_list|(
operator|(
name|unsigned
operator|)
name|i
argument_list|)
expr_stmt|;
name|acct
operator|.
name|ac_uid
operator|=
name|p
operator|->
name|p_cred
operator|->
name|p_ruid
expr_stmt|;
name|acct
operator|.
name|ac_gid
operator|=
name|p
operator|->
name|p_cred
operator|->
name|p_rgid
expr_stmt|;
name|r
operator|=
operator|&
name|p
operator|->
name|p_stats
operator|->
name|p_ru
expr_stmt|;
if|if
condition|(
name|i
operator|=
operator|(
name|p
operator|->
name|p_utime
operator|.
name|tv_sec
operator|+
name|p
operator|->
name|p_stime
operator|.
name|tv_sec
operator|)
operator|*
name|hz
operator|+
operator|(
name|p
operator|->
name|p_utime
operator|.
name|tv_usec
operator|+
name|p
operator|->
name|p_stime
operator|.
name|tv_usec
operator|)
operator|/
name|tick
condition|)
name|acct
operator|.
name|ac_mem
operator|=
operator|(
name|r
operator|->
name|ru_ixrss
operator|+
name|r
operator|->
name|ru_idrss
operator|+
name|r
operator|->
name|ru_isrss
operator|)
operator|/
name|i
expr_stmt|;
else|else
name|acct
operator|.
name|ac_mem
operator|=
literal|0
expr_stmt|;
name|acct
operator|.
name|ac_io
operator|=
name|int2comp
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
name|r
operator|->
name|ru_inblock
operator|+
name|r
operator|->
name|ru_oublock
argument_list|)
operator|*
literal|1000000
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|->
name|p_flag
operator|&
name|SCTTY
operator|)
operator|&&
name|p
operator|->
name|p_pgrp
operator|->
name|pg_session
operator|->
name|s_ttyp
condition|)
name|acct
operator|.
name|ac_tty
operator|=
name|p
operator|->
name|p_pgrp
operator|->
name|pg_session
operator|->
name|s_ttyp
operator|->
name|t_dev
expr_stmt|;
else|else
name|acct
operator|.
name|ac_tty
operator|=
name|NODEV
expr_stmt|;
name|acct
operator|.
name|ac_flag
operator|=
name|p
operator|->
name|p_acflag
expr_stmt|;
comment|/* Step 3. Write record to file */
name|rv
operator|=
name|vn_rdwr
argument_list|(
name|UIO_WRITE
argument_list|,
name|acctp
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|acct
argument_list|,
sizeof|sizeof
argument_list|(
name|acct
argument_list|)
argument_list|,
operator|(
name|off_t
operator|)
literal|0
argument_list|,
name|UIO_SYSSPACE
argument_list|,
name|IO_APPEND
operator||
name|IO_UNIT
argument_list|,
name|p
operator|->
name|p_ucred
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  int2comp converts from ticks in a microsecond to ticks in 1/AHZ second  *   * comp_t is a psuedo-floating point number with 13 bits of  * mantissa and 3 bits of base 8 exponent and has resolution  * of 1/AHZ seconds.  *  * notice I already converted the incoming values into microseconds  * I need to convert back into AHZ ticks.  */
end_comment

begin_comment
comment|/* Mark Tinguely (tinguely@plains.NoDak.edu) 8/10/93 */
end_comment

begin_define
define|#
directive|define
name|RES
value|13
end_define

begin_define
define|#
directive|define
name|EXP
value|3
end_define

begin_define
define|#
directive|define
name|MAXFRACT
value|1<<RES
end_define

begin_function
name|comp_t
name|int2comp
parameter_list|(
name|mantissa
parameter_list|)
name|unsigned
name|int
name|mantissa
decl_stmt|;
block|{
name|comp_t
name|exp
init|=
literal|0
decl_stmt|;
name|mantissa
operator|=
name|mantissa
operator|*
name|AHZ
operator|/
literal|1000000
expr_stmt|;
comment|/* convert back to AHZ ticks */
while|while
condition|(
name|mantissa
operator|>
name|MAXFRACT
condition|)
block|{
name|mantissa
operator|>>=
name|EXP
expr_stmt|;
comment|/* base 8 exponent */
name|exp
operator|++
expr_stmt|;
block|}
name|exp
operator|<<=
name|RES
expr_stmt|;
comment|/* move the exponent */
name|exp
operator|+=
name|mantissa
expr_stmt|;
comment|/* add on the manissa */
return|return
operator|(
name|exp
operator|)
return|;
block|}
end_function

end_unit

