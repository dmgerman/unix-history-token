begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1994 Christopher G. Demetriou  * Copyright (c) 1982, 1986, 1989, 1993  *	The Regents of the University of California.  All rights reserved.  * (c) UNIX System Laboratories, Inc.  * All or some portions of this file are derived from material licensed  * to the University of California by American Telephone and Telegraph  * Co. or Unix System Laboratories, Inc. and are reproduced herein with  * the permission of UNIX System Laboratories, Inc.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *	@(#)kern_acct.c	8.1 (Berkeley) 6/14/93  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"opt_mac.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysproto.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mac.h>
end_include

begin_include
include|#
directive|include
file|<sys/mount.h>
end_include

begin_include
include|#
directive|include
file|<sys/vnode.h>
end_include

begin_include
include|#
directive|include
file|<sys/fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/syslog.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysent.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/namei.h>
end_include

begin_include
include|#
directive|include
file|<sys/acct.h>
end_include

begin_include
include|#
directive|include
file|<sys/resourcevar.h>
end_include

begin_include
include|#
directive|include
file|<sys/tty.h>
end_include

begin_comment
comment|/*  * The routines implemented in this file are described in:  *      Leffler, et al.: The Design and Implementation of the 4.3BSD  *	    UNIX Operating System (Addison Welley, 1989)  * on pages 62-63.  *  * Arguably, to simplify accounting operations, this mechanism should  * be replaced by one in which an accounting log file (similar to /dev/klog)  * is read by a user process, etc.  However, that has its own problems.  */
end_comment

begin_comment
comment|/*  * Internal accounting functions.  * The former's operation is described in Leffler, et al., and the latter  * was provided by UCB with the 4.4BSD-Lite release  */
end_comment

begin_function_decl
specifier|static
name|comp_t
name|encode_comp_t
parameter_list|(
name|u_long
parameter_list|,
name|u_long
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|acctwatch
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Accounting callout used for periodic scheduling of acctwatch.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|callout
name|acctwatch_callout
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Accounting vnode pointer, saved vnode pointer, and flags for each.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|vnode
modifier|*
name|acctp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|ucred
modifier|*
name|acctcred
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|acctflags
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|vnode
modifier|*
name|savacctp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|ucred
modifier|*
name|savacctcred
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|savacctflags
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|mtx
name|acct_mtx
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|MTX_SYSINIT
argument_list|(
name|acct
argument_list|,
operator|&
name|acct_mtx
argument_list|,
literal|"accounting"
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Values associated with enabling and disabling accounting  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|acctsuspend
init|=
literal|2
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* stop accounting when< 2% free space left */
end_comment

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_kern
argument_list|,
name|OID_AUTO
argument_list|,
name|acct_suspend
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|acctsuspend
argument_list|,
literal|0
argument_list|,
literal|"percentage of free disk space below which accounting stops"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|acctresume
init|=
literal|4
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* resume when free space risen to> 4% */
end_comment

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_kern
argument_list|,
name|OID_AUTO
argument_list|,
name|acct_resume
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|acctresume
argument_list|,
literal|0
argument_list|,
literal|"percentage of free disk space above which accounting resumes"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|acctchkfreq
init|=
literal|15
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* frequency (in seconds) to check space */
end_comment

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_kern
argument_list|,
name|OID_AUTO
argument_list|,
name|acct_chkfreq
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|acctchkfreq
argument_list|,
literal|0
argument_list|,
literal|"frequency for checking the free space"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Accounting system call.  Written based on the specification and  * previous implementation done by Mark Tinguely.  *  * MPSAFE  */
end_comment

begin_function
name|int
name|acct
parameter_list|(
name|td
parameter_list|,
name|uap
parameter_list|)
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|acct_args
comment|/* { 		char *path; 	} */
modifier|*
name|uap
decl_stmt|;
block|{
name|struct
name|nameidata
name|nd
decl_stmt|;
name|int
name|error
decl_stmt|,
name|flags
decl_stmt|;
comment|/* Make sure that the caller is root. */
name|error
operator|=
name|suser
argument_list|(
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|mtx_lock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
comment|/* 	 * If accounting is to be started to a file, open that file for 	 * appending and make sure it's a 'normal'. 	 */
if|if
condition|(
name|uap
operator|->
name|path
operator|!=
name|NULL
condition|)
block|{
name|NDINIT
argument_list|(
operator|&
name|nd
argument_list|,
name|LOOKUP
argument_list|,
name|NOFOLLOW
argument_list|,
name|UIO_USERSPACE
argument_list|,
name|uap
operator|->
name|path
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|flags
operator|=
name|FWRITE
operator||
name|O_APPEND
expr_stmt|;
name|error
operator|=
name|vn_open
argument_list|(
operator|&
name|nd
argument_list|,
operator|&
name|flags
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|done2
goto|;
name|NDFREE
argument_list|(
operator|&
name|nd
argument_list|,
name|NDF_ONLY_PNBUF
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MAC
name|error
operator|=
name|mac_check_system_acct
argument_list|(
name|td
operator|->
name|td_ucred
argument_list|,
name|nd
operator|.
name|ni_vp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|vn_close
argument_list|(
name|nd
operator|.
name|ni_vp
argument_list|,
name|flags
argument_list|,
name|td
operator|->
name|td_ucred
argument_list|,
name|td
argument_list|)
expr_stmt|;
goto|goto
name|done2
goto|;
block|}
endif|#
directive|endif
name|VOP_UNLOCK
argument_list|(
name|nd
operator|.
name|ni_vp
argument_list|,
literal|0
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|nd
operator|.
name|ni_vp
operator|->
name|v_type
operator|!=
name|VREG
condition|)
block|{
name|vn_close
argument_list|(
name|nd
operator|.
name|ni_vp
argument_list|,
name|flags
argument_list|,
name|td
operator|->
name|td_ucred
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|error
operator|=
name|EACCES
expr_stmt|;
goto|goto
name|done2
goto|;
block|}
ifdef|#
directive|ifdef
name|MAC
block|}
else|else
block|{
name|error
operator|=
name|mac_check_system_acct
argument_list|(
name|td
operator|->
name|td_ucred
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|done2
goto|;
endif|#
directive|endif
block|}
name|mtx_lock
argument_list|(
operator|&
name|acct_mtx
argument_list|)
expr_stmt|;
comment|/* 	 * If accounting was previously enabled, kill the old space-watcher, 	 * close the file, and (if no new file was specified, leave). 	 * 	 * XXX arr: should not hold lock over vnode operation. 	 */
if|if
condition|(
name|acctp
operator|!=
name|NULLVP
operator|||
name|savacctp
operator|!=
name|NULLVP
condition|)
block|{
name|callout_stop
argument_list|(
operator|&
name|acctwatch_callout
argument_list|)
expr_stmt|;
name|error
operator|=
name|vn_close
argument_list|(
operator|(
name|acctp
operator|!=
name|NULLVP
condition|?
name|acctp
else|:
name|savacctp
operator|)
argument_list|,
operator|(
name|acctp
operator|!=
name|NULLVP
condition|?
name|acctflags
else|:
name|savacctflags
operator|)
argument_list|,
operator|(
name|acctcred
operator|!=
name|NOCRED
condition|?
name|acctcred
else|:
name|savacctcred
operator|)
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|acctp
operator|=
name|savacctp
operator|=
name|NULLVP
expr_stmt|;
name|crfree
argument_list|(
name|acctcred
operator|!=
name|NOCRED
condition|?
name|acctcred
else|:
name|savacctcred
argument_list|)
expr_stmt|;
name|acctcred
operator|=
name|savacctcred
operator|=
name|NOCRED
expr_stmt|;
name|log
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"Accounting disabled\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|uap
operator|->
name|path
operator|==
name|NULL
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|acct_mtx
argument_list|)
expr_stmt|;
goto|goto
name|done2
goto|;
block|}
comment|/* 	 * Save the new accounting file vnode, and schedule the new 	 * free space watcher. 	 */
name|acctp
operator|=
name|nd
operator|.
name|ni_vp
expr_stmt|;
name|acctcred
operator|=
name|crhold
argument_list|(
name|td
operator|->
name|td_ucred
argument_list|)
expr_stmt|;
name|acctflags
operator|=
name|flags
expr_stmt|;
name|callout_init
argument_list|(
operator|&
name|acctwatch_callout
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|acct_mtx
argument_list|)
expr_stmt|;
name|log
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"Accounting enabled\n"
argument_list|)
expr_stmt|;
name|acctwatch
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|done2
label|:
name|mtx_unlock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Write out process accounting information, on process exit.  * Data to be written out is specified in Leffler, et al.  * and are enumerated below.  (They're also noted in the system  * "acct.h" header file.)  */
end_comment

begin_function
name|int
name|acct_process
parameter_list|(
name|td
parameter_list|)
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
block|{
name|struct
name|acct
name|acct
decl_stmt|;
name|struct
name|timeval
name|ut
decl_stmt|,
name|st
decl_stmt|,
name|tmp
decl_stmt|;
name|struct
name|plimit
modifier|*
name|newlim
decl_stmt|,
modifier|*
name|oldlim
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|struct
name|rusage
modifier|*
name|r
decl_stmt|;
name|struct
name|ucred
modifier|*
name|uc
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|int
name|t
decl_stmt|,
name|ret
decl_stmt|;
comment|/* 	 * Lockless check of accounting condition before doing the hard 	 * work. 	 */
if|if
condition|(
name|acctp
operator|==
name|NULLVP
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|mtx_lock
argument_list|(
operator|&
name|acct_mtx
argument_list|)
expr_stmt|;
comment|/* 	 * If accounting isn't enabled, don't bother.  Have to check again 	 * once we own the lock in case we raced with disabling of accounting 	 * by another thread. 	 */
name|vp
operator|=
name|acctp
expr_stmt|;
if|if
condition|(
name|vp
operator|==
name|NULLVP
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|acct_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|p
operator|=
name|td
operator|->
name|td_proc
expr_stmt|;
comment|/* 	 * Get process accounting information. 	 */
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* (1) The name of the command that ran */
name|bcopy
argument_list|(
name|p
operator|->
name|p_comm
argument_list|,
name|acct
operator|.
name|ac_comm
argument_list|,
sizeof|sizeof
name|acct
operator|.
name|ac_comm
argument_list|)
expr_stmt|;
comment|/* (2) The amount of user and system time that was used */
name|calcru
argument_list|(
name|p
argument_list|,
operator|&
name|ut
argument_list|,
operator|&
name|st
argument_list|)
expr_stmt|;
name|acct
operator|.
name|ac_utime
operator|=
name|encode_comp_t
argument_list|(
name|ut
operator|.
name|tv_sec
argument_list|,
name|ut
operator|.
name|tv_usec
argument_list|)
expr_stmt|;
name|acct
operator|.
name|ac_stime
operator|=
name|encode_comp_t
argument_list|(
name|st
operator|.
name|tv_sec
argument_list|,
name|st
operator|.
name|tv_usec
argument_list|)
expr_stmt|;
comment|/* (3) The elapsed time the command ran (and its starting time) */
name|tmp
operator|=
name|boottime
expr_stmt|;
name|timevaladd
argument_list|(
operator|&
name|tmp
argument_list|,
operator|&
name|p
operator|->
name|p_stats
operator|->
name|p_start
argument_list|)
expr_stmt|;
name|acct
operator|.
name|ac_btime
operator|=
name|tmp
operator|.
name|tv_sec
expr_stmt|;
name|microuptime
argument_list|(
operator|&
name|tmp
argument_list|)
expr_stmt|;
name|timevalsub
argument_list|(
operator|&
name|tmp
argument_list|,
operator|&
name|p
operator|->
name|p_stats
operator|->
name|p_start
argument_list|)
expr_stmt|;
name|acct
operator|.
name|ac_etime
operator|=
name|encode_comp_t
argument_list|(
name|tmp
operator|.
name|tv_sec
argument_list|,
name|tmp
operator|.
name|tv_usec
argument_list|)
expr_stmt|;
comment|/* (4) The average amount of memory used */
name|r
operator|=
operator|&
name|p
operator|->
name|p_stats
operator|->
name|p_ru
expr_stmt|;
name|tmp
operator|=
name|ut
expr_stmt|;
name|timevaladd
argument_list|(
operator|&
name|tmp
argument_list|,
operator|&
name|st
argument_list|)
expr_stmt|;
name|t
operator|=
name|tmp
operator|.
name|tv_sec
operator|*
name|hz
operator|+
name|tmp
operator|.
name|tv_usec
operator|/
name|tick
expr_stmt|;
if|if
condition|(
name|t
condition|)
name|acct
operator|.
name|ac_mem
operator|=
operator|(
name|r
operator|->
name|ru_ixrss
operator|+
name|r
operator|->
name|ru_idrss
operator|+
name|r
operator|->
name|ru_isrss
operator|)
operator|/
name|t
expr_stmt|;
else|else
name|acct
operator|.
name|ac_mem
operator|=
literal|0
expr_stmt|;
comment|/* (5) The number of disk I/O operations done */
name|acct
operator|.
name|ac_io
operator|=
name|encode_comp_t
argument_list|(
name|r
operator|->
name|ru_inblock
operator|+
name|r
operator|->
name|ru_oublock
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* (6) The UID and GID of the process */
name|acct
operator|.
name|ac_uid
operator|=
name|p
operator|->
name|p_ucred
operator|->
name|cr_ruid
expr_stmt|;
name|acct
operator|.
name|ac_gid
operator|=
name|p
operator|->
name|p_ucred
operator|->
name|cr_rgid
expr_stmt|;
comment|/* (7) The terminal from which the process was started */
name|SESS_LOCK
argument_list|(
name|p
operator|->
name|p_session
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|->
name|p_flag
operator|&
name|P_CONTROLT
operator|)
operator|&&
name|p
operator|->
name|p_pgrp
operator|->
name|pg_session
operator|->
name|s_ttyp
condition|)
name|acct
operator|.
name|ac_tty
operator|=
name|dev2udev
argument_list|(
name|p
operator|->
name|p_pgrp
operator|->
name|pg_session
operator|->
name|s_ttyp
operator|->
name|t_dev
argument_list|)
expr_stmt|;
else|else
name|acct
operator|.
name|ac_tty
operator|=
name|NODEV
expr_stmt|;
name|SESS_UNLOCK
argument_list|(
name|p
operator|->
name|p_session
argument_list|)
expr_stmt|;
comment|/* (8) The boolean flags that tell how the process terminated, etc. */
name|acct
operator|.
name|ac_flag
operator|=
name|p
operator|->
name|p_acflag
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* 	 * Finish doing things that require acct_mtx, and release acct_mtx. 	 */
name|uc
operator|=
name|crhold
argument_list|(
name|acctcred
argument_list|)
expr_stmt|;
name|vref
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|acct_mtx
argument_list|)
expr_stmt|;
comment|/* 	 * Eliminate any file size rlimit. 	 */
name|newlim
operator|=
name|lim_alloc
argument_list|()
expr_stmt|;
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|oldlim
operator|=
name|p
operator|->
name|p_limit
expr_stmt|;
name|lim_copy
argument_list|(
name|newlim
argument_list|,
name|oldlim
argument_list|)
expr_stmt|;
name|newlim
operator|->
name|pl_rlimit
index|[
name|RLIMIT_FSIZE
index|]
operator|.
name|rlim_cur
operator|=
name|RLIM_INFINITY
expr_stmt|;
name|p
operator|->
name|p_limit
operator|=
name|newlim
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|lim_free
argument_list|(
name|oldlim
argument_list|)
expr_stmt|;
comment|/* 	 * Write the accounting information to the file. 	 */
name|VOP_LEASE
argument_list|(
name|vp
argument_list|,
name|td
argument_list|,
name|uc
argument_list|,
name|LEASE_WRITE
argument_list|)
expr_stmt|;
name|ret
operator|=
name|vn_rdwr
argument_list|(
name|UIO_WRITE
argument_list|,
name|vp
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|acct
argument_list|,
sizeof|sizeof
argument_list|(
name|acct
argument_list|)
argument_list|,
operator|(
name|off_t
operator|)
literal|0
argument_list|,
name|UIO_SYSSPACE
argument_list|,
name|IO_APPEND
operator||
name|IO_UNIT
argument_list|,
name|uc
argument_list|,
name|NOCRED
argument_list|,
operator|(
name|int
operator|*
operator|)
literal|0
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|vrele
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|crfree
argument_list|(
name|uc
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Encode_comp_t converts from ticks in seconds and microseconds  * to ticks in 1/AHZ seconds.  The encoding is described in  * Leffler, et al., on page 63.  */
end_comment

begin_define
define|#
directive|define
name|MANTSIZE
value|13
end_define

begin_comment
comment|/* 13 bit mantissa. */
end_comment

begin_define
define|#
directive|define
name|EXPSIZE
value|3
end_define

begin_comment
comment|/* Base 8 (3 bit) exponent. */
end_comment

begin_define
define|#
directive|define
name|MAXFRACT
value|((1<< MANTSIZE) - 1)
end_define

begin_comment
comment|/* Maximum fractional value. */
end_comment

begin_function
specifier|static
name|comp_t
name|encode_comp_t
parameter_list|(
name|s
parameter_list|,
name|us
parameter_list|)
name|u_long
name|s
decl_stmt|,
name|us
decl_stmt|;
block|{
name|int
name|exp
decl_stmt|,
name|rnd
decl_stmt|;
name|exp
operator|=
literal|0
expr_stmt|;
name|rnd
operator|=
literal|0
expr_stmt|;
name|s
operator|*=
name|AHZ
expr_stmt|;
name|s
operator|+=
name|us
operator|/
operator|(
literal|1000000
operator|/
name|AHZ
operator|)
expr_stmt|;
comment|/* Maximize precision. */
while|while
condition|(
name|s
operator|>
name|MAXFRACT
condition|)
block|{
name|rnd
operator|=
name|s
operator|&
operator|(
literal|1
operator|<<
operator|(
name|EXPSIZE
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
comment|/* Round up? */
name|s
operator|>>=
name|EXPSIZE
expr_stmt|;
comment|/* Base 8 exponent == 3 bit shift. */
name|exp
operator|++
expr_stmt|;
block|}
comment|/* If we need to round up, do it (and handle overflow correctly). */
if|if
condition|(
name|rnd
operator|&&
operator|(
operator|++
name|s
operator|>
name|MAXFRACT
operator|)
condition|)
block|{
name|s
operator|>>=
name|EXPSIZE
expr_stmt|;
name|exp
operator|++
expr_stmt|;
block|}
comment|/* Clean it up and polish it off. */
name|exp
operator|<<=
name|MANTSIZE
expr_stmt|;
comment|/* Shift the exponent into place */
name|exp
operator|+=
name|s
expr_stmt|;
comment|/* and add on the mantissa. */
return|return
operator|(
name|exp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Periodically check the filesystem to see if accounting  * should be turned on or off.  Beware the case where the vnode  * has been vgone()'d out from underneath us, e.g. when the file  * system containing the accounting file has been forcibly unmounted.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|acctwatch
parameter_list|(
name|a
parameter_list|)
name|void
modifier|*
name|a
decl_stmt|;
block|{
name|struct
name|statfs
name|sb
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|acct_mtx
argument_list|)
expr_stmt|;
comment|/* 	 * XXX arr: need to fix the issue of holding acct_mtx over 	 * the below vnode operations. 	 */
if|if
condition|(
name|savacctp
operator|!=
name|NULLVP
condition|)
block|{
if|if
condition|(
name|savacctp
operator|->
name|v_type
operator|==
name|VBAD
condition|)
block|{
operator|(
name|void
operator|)
name|vn_close
argument_list|(
name|savacctp
argument_list|,
name|savacctflags
argument_list|,
name|savacctcred
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|savacctp
operator|=
name|NULLVP
expr_stmt|;
name|savacctcred
operator|=
name|NOCRED
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|acct_mtx
argument_list|)
expr_stmt|;
return|return;
block|}
operator|(
name|void
operator|)
name|VFS_STATFS
argument_list|(
name|savacctp
operator|->
name|v_mount
argument_list|,
operator|&
name|sb
argument_list|,
operator|(
expr|struct
name|thread
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sb
operator|.
name|f_bavail
operator|>
name|acctresume
operator|*
name|sb
operator|.
name|f_blocks
operator|/
literal|100
condition|)
block|{
name|acctp
operator|=
name|savacctp
expr_stmt|;
name|acctcred
operator|=
name|savacctcred
expr_stmt|;
name|acctflags
operator|=
name|savacctflags
expr_stmt|;
name|savacctp
operator|=
name|NULLVP
expr_stmt|;
name|savacctcred
operator|=
name|NOCRED
expr_stmt|;
name|log
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"Accounting resumed\n"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|acctp
operator|==
name|NULLVP
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|acct_mtx
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|acctp
operator|->
name|v_type
operator|==
name|VBAD
condition|)
block|{
operator|(
name|void
operator|)
name|vn_close
argument_list|(
name|acctp
argument_list|,
name|acctflags
argument_list|,
name|acctcred
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|acctp
operator|=
name|NULLVP
expr_stmt|;
name|crfree
argument_list|(
name|acctcred
argument_list|)
expr_stmt|;
name|acctcred
operator|=
name|NOCRED
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|acct_mtx
argument_list|)
expr_stmt|;
return|return;
block|}
operator|(
name|void
operator|)
name|VFS_STATFS
argument_list|(
name|acctp
operator|->
name|v_mount
argument_list|,
operator|&
name|sb
argument_list|,
operator|(
expr|struct
name|thread
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sb
operator|.
name|f_bavail
operator|<=
name|acctsuspend
operator|*
name|sb
operator|.
name|f_blocks
operator|/
literal|100
condition|)
block|{
name|savacctp
operator|=
name|acctp
expr_stmt|;
name|savacctflags
operator|=
name|acctflags
expr_stmt|;
name|savacctcred
operator|=
name|acctcred
expr_stmt|;
name|acctp
operator|=
name|NULLVP
expr_stmt|;
name|acctcred
operator|=
name|NOCRED
expr_stmt|;
name|log
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"Accounting suspended\n"
argument_list|)
expr_stmt|;
block|}
block|}
name|callout_reset
argument_list|(
operator|&
name|acctwatch_callout
argument_list|,
name|acctchkfreq
operator|*
name|hz
argument_list|,
name|acctwatch
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|acct_mtx
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

