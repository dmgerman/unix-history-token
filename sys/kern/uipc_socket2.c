begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1982, 1986, 1988, 1990, 1993  *	The Regents of the University of California.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *	@(#)uipc_socket2.c	8.1 (Berkeley) 6/10/93  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"opt_param.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/domain.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/protosw.h>
end_include

begin_include
include|#
directive|include
file|<sys/resourcevar.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/socketvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_comment
comment|/*  * Primitive routines for operating on sockets.  */
end_comment

begin_comment
comment|/*  * Procedures to manipulate state flags of socket  * and do appropriate wakeups.  Normal sequence from the  * active (originating) side is that soisconnecting() is  * called during processing of connect() call,  * resulting in an eventual call to soisconnected() if/when the  * connection is established.  When the connection is torn down  * soisdisconnecting() is called during processing of disconnect() call,  * and soisdisconnected() is called when the connection to the peer  * is totally severed.  The semantics of these routines are such that  * connectionless protocols can call soisconnected() and soisdisconnected()  * only, bypassing the in-progress calls when setting up a ``connection''  * takes no time.  *  * From the passive side, a socket is created with  * two queues of sockets: so_incomp for connections in progress  * and so_comp for connections already made and awaiting user acceptance.  * As a protocol is preparing incoming connections, it creates a socket  * structure queued on so_incomp by calling sonewconn().  When the connection  * is established, soisconnected() is called, and transfers the  * socket structure to so_comp, making it available to accept().  *  * If a socket is closed with sockets on either  * so_incomp or so_comp, these sockets are dropped.  *  * If higher level protocols are implemented in  * the kernel, the wakeups done here will sometimes  * cause software-interrupt process scheduling.  */
end_comment

begin_function
name|void
name|soisconnecting
parameter_list|(
name|so
parameter_list|)
specifier|register
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
block|{
name|SOCK_LOCK
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|so
operator|->
name|so_state
operator|&=
operator|~
operator|(
name|SS_ISCONNECTED
operator||
name|SS_ISDISCONNECTING
operator|)
expr_stmt|;
name|so
operator|->
name|so_state
operator||=
name|SS_ISCONNECTING
expr_stmt|;
name|SOCK_UNLOCK
argument_list|(
name|so
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|soisconnected
parameter_list|(
name|so
parameter_list|)
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
block|{
name|struct
name|socket
modifier|*
name|head
decl_stmt|;
name|ACCEPT_LOCK
argument_list|()
expr_stmt|;
name|SOCK_LOCK
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|so
operator|->
name|so_state
operator|&=
operator|~
operator|(
name|SS_ISCONNECTING
operator||
name|SS_ISDISCONNECTING
operator||
name|SS_ISCONFIRMING
operator|)
expr_stmt|;
name|so
operator|->
name|so_state
operator||=
name|SS_ISCONNECTED
expr_stmt|;
name|head
operator|=
name|so
operator|->
name|so_head
expr_stmt|;
if|if
condition|(
name|head
operator|!=
name|NULL
operator|&&
operator|(
name|so
operator|->
name|so_qstate
operator|&
name|SQ_INCOMP
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|so
operator|->
name|so_options
operator|&
name|SO_ACCEPTFILTER
operator|)
operator|==
literal|0
condition|)
block|{
name|SOCK_UNLOCK
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|head
operator|->
name|so_incomp
argument_list|,
name|so
argument_list|,
name|so_list
argument_list|)
expr_stmt|;
name|head
operator|->
name|so_incqlen
operator|--
expr_stmt|;
name|so
operator|->
name|so_qstate
operator|&=
operator|~
name|SQ_INCOMP
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|head
operator|->
name|so_comp
argument_list|,
name|so
argument_list|,
name|so_list
argument_list|)
expr_stmt|;
name|head
operator|->
name|so_qlen
operator|++
expr_stmt|;
name|so
operator|->
name|so_qstate
operator||=
name|SQ_COMP
expr_stmt|;
name|ACCEPT_UNLOCK
argument_list|()
expr_stmt|;
name|sorwakeup
argument_list|(
name|head
argument_list|)
expr_stmt|;
name|wakeup_one
argument_list|(
operator|&
name|head
operator|->
name|so_timeo
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ACCEPT_UNLOCK
argument_list|()
expr_stmt|;
name|so
operator|->
name|so_upcall
operator|=
name|head
operator|->
name|so_accf
operator|->
name|so_accept_filter
operator|->
name|accf_callback
expr_stmt|;
name|so
operator|->
name|so_upcallarg
operator|=
name|head
operator|->
name|so_accf
operator|->
name|so_accept_filter_arg
expr_stmt|;
name|so
operator|->
name|so_rcv
operator|.
name|sb_flags
operator||=
name|SB_UPCALL
expr_stmt|;
name|so
operator|->
name|so_options
operator|&=
operator|~
name|SO_ACCEPTFILTER
expr_stmt|;
name|SOCK_UNLOCK
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|so
operator|->
name|so_upcall
argument_list|(
name|so
argument_list|,
name|so
operator|->
name|so_upcallarg
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
name|SOCK_UNLOCK
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|ACCEPT_UNLOCK
argument_list|()
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|so
operator|->
name|so_timeo
argument_list|)
expr_stmt|;
name|sorwakeup
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|sowwakeup
argument_list|(
name|so
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|soisdisconnecting
parameter_list|(
name|so
parameter_list|)
specifier|register
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
block|{
comment|/* 	 * XXXRW: This code assumes that SOCK_LOCK(so) and 	 * SOCKBUF_LOCK(&so->so_rcv) are the same. 	 */
name|SOCKBUF_LOCK
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
name|so
operator|->
name|so_state
operator|&=
operator|~
name|SS_ISCONNECTING
expr_stmt|;
name|so
operator|->
name|so_state
operator||=
name|SS_ISDISCONNECTING
expr_stmt|;
name|so
operator|->
name|so_rcv
operator|.
name|sb_state
operator||=
name|SBS_CANTRCVMORE
expr_stmt|;
name|sorwakeup_locked
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|SOCKBUF_LOCK
argument_list|(
operator|&
name|so
operator|->
name|so_snd
argument_list|)
expr_stmt|;
name|so
operator|->
name|so_snd
operator|.
name|sb_state
operator||=
name|SBS_CANTSENDMORE
expr_stmt|;
name|sowwakeup_locked
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|so
operator|->
name|so_timeo
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|soisdisconnected
parameter_list|(
name|so
parameter_list|)
specifier|register
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
block|{
comment|/* 	 * XXXRW: This code assumes that SOCK_LOCK(so) and 	 * SOCKBUF_LOCK(&so->so_rcv) are the same. 	 */
name|SOCKBUF_LOCK
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
name|so
operator|->
name|so_state
operator|&=
operator|~
operator|(
name|SS_ISCONNECTING
operator||
name|SS_ISCONNECTED
operator||
name|SS_ISDISCONNECTING
operator|)
expr_stmt|;
name|so
operator|->
name|so_state
operator||=
name|SS_ISDISCONNECTED
expr_stmt|;
name|so
operator|->
name|so_rcv
operator|.
name|sb_state
operator||=
name|SBS_CANTRCVMORE
expr_stmt|;
name|sorwakeup_locked
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|SOCKBUF_LOCK
argument_list|(
operator|&
name|so
operator|->
name|so_snd
argument_list|)
expr_stmt|;
name|so
operator|->
name|so_snd
operator|.
name|sb_state
operator||=
name|SBS_CANTSENDMORE
expr_stmt|;
name|sbdrop_locked
argument_list|(
operator|&
name|so
operator|->
name|so_snd
argument_list|,
name|so
operator|->
name|so_snd
operator|.
name|sb_cc
argument_list|)
expr_stmt|;
name|sowwakeup_locked
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|so
operator|->
name|so_timeo
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Create a "control" mbuf containing the specified data  * with the specified type for presentation on a socket buffer.  */
end_comment

begin_function
name|struct
name|mbuf
modifier|*
name|sbcreatecontrol
parameter_list|(
name|p
parameter_list|,
name|size
parameter_list|,
name|type
parameter_list|,
name|level
parameter_list|)
name|caddr_t
name|p
decl_stmt|;
specifier|register
name|int
name|size
decl_stmt|;
name|int
name|type
decl_stmt|,
name|level
decl_stmt|;
block|{
specifier|register
name|struct
name|cmsghdr
modifier|*
name|cp
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
if|if
condition|(
name|CMSG_SPACE
argument_list|(
operator|(
name|u_int
operator|)
name|size
argument_list|)
operator|>
name|MCLBYTES
condition|)
return|return
operator|(
operator|(
expr|struct
name|mbuf
operator|*
operator|)
name|NULL
operator|)
return|;
if|if
condition|(
name|CMSG_SPACE
argument_list|(
operator|(
name|u_int
operator|)
name|size
argument_list|)
operator|>
name|MLEN
condition|)
name|m
operator|=
name|m_getcl
argument_list|(
name|M_DONTWAIT
argument_list|,
name|MT_CONTROL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|m
operator|=
name|m_get
argument_list|(
name|M_DONTWAIT
argument_list|,
name|MT_CONTROL
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return
operator|(
operator|(
expr|struct
name|mbuf
operator|*
operator|)
name|NULL
operator|)
return|;
name|cp
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|cmsghdr
operator|*
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_len
operator|=
literal|0
expr_stmt|;
name|KASSERT
argument_list|(
name|CMSG_SPACE
argument_list|(
operator|(
name|u_int
operator|)
name|size
argument_list|)
operator|<=
name|M_TRAILINGSPACE
argument_list|(
name|m
argument_list|)
argument_list|,
operator|(
literal|"sbcreatecontrol: short mbuf"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|memcpy
argument_list|(
name|CMSG_DATA
argument_list|(
name|cp
argument_list|)
argument_list|,
name|p
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_len
operator|=
name|CMSG_SPACE
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|cp
operator|->
name|cmsg_len
operator|=
name|CMSG_LEN
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|cp
operator|->
name|cmsg_level
operator|=
name|level
expr_stmt|;
name|cp
operator|->
name|cmsg_type
operator|=
name|type
expr_stmt|;
return|return
operator|(
name|m
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Some routines that return EOPNOTSUPP for entry points that are not  * supported by a protocol.  Fill in as needed.  */
end_comment

begin_function
name|int
name|pru_accept_notsupp
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|sockaddr
modifier|*
modifier|*
name|nam
parameter_list|)
block|{
return|return
name|EOPNOTSUPP
return|;
block|}
end_function

begin_function
name|int
name|pru_attach_notsupp
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|int
name|proto
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
return|return
name|EOPNOTSUPP
return|;
block|}
end_function

begin_function
name|int
name|pru_bind_notsupp
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|nam
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
return|return
name|EOPNOTSUPP
return|;
block|}
end_function

begin_function
name|int
name|pru_connect_notsupp
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|nam
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
return|return
name|EOPNOTSUPP
return|;
block|}
end_function

begin_function
name|int
name|pru_connect2_notsupp
parameter_list|(
name|struct
name|socket
modifier|*
name|so1
parameter_list|,
name|struct
name|socket
modifier|*
name|so2
parameter_list|)
block|{
return|return
name|EOPNOTSUPP
return|;
block|}
end_function

begin_function
name|int
name|pru_control_notsupp
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|data
parameter_list|,
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
return|return
name|EOPNOTSUPP
return|;
block|}
end_function

begin_function
name|int
name|pru_disconnect_notsupp
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|)
block|{
return|return
name|EOPNOTSUPP
return|;
block|}
end_function

begin_function
name|int
name|pru_listen_notsupp
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|int
name|backlog
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
return|return
name|EOPNOTSUPP
return|;
block|}
end_function

begin_function
name|int
name|pru_peeraddr_notsupp
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|sockaddr
modifier|*
modifier|*
name|nam
parameter_list|)
block|{
return|return
name|EOPNOTSUPP
return|;
block|}
end_function

begin_function
name|int
name|pru_rcvd_notsupp
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
return|return
name|EOPNOTSUPP
return|;
block|}
end_function

begin_function
name|int
name|pru_rcvoob_notsupp
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
return|return
name|EOPNOTSUPP
return|;
block|}
end_function

begin_function
name|int
name|pru_send_notsupp
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|int
name|flags
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|addr
parameter_list|,
name|struct
name|mbuf
modifier|*
name|control
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
return|return
name|EOPNOTSUPP
return|;
block|}
end_function

begin_comment
comment|/*  * This isn't really a ``null'' operation, but it's the default one  * and doesn't do anything destructive.  */
end_comment

begin_function
name|int
name|pru_sense_null
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|stat
modifier|*
name|sb
parameter_list|)
block|{
name|sb
operator|->
name|st_blksize
operator|=
name|so
operator|->
name|so_snd
operator|.
name|sb_hiwat
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|pru_shutdown_notsupp
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|)
block|{
return|return
name|EOPNOTSUPP
return|;
block|}
end_function

begin_function
name|int
name|pru_sockaddr_notsupp
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|sockaddr
modifier|*
modifier|*
name|nam
parameter_list|)
block|{
return|return
name|EOPNOTSUPP
return|;
block|}
end_function

begin_function
name|int
name|pru_sosend_notsupp
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|addr
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|,
name|struct
name|mbuf
modifier|*
name|top
parameter_list|,
name|struct
name|mbuf
modifier|*
name|control
parameter_list|,
name|int
name|flags
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
return|return
name|EOPNOTSUPP
return|;
block|}
end_function

begin_function
name|int
name|pru_soreceive_notsupp
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|sockaddr
modifier|*
modifier|*
name|paddr
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
name|mp0
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
name|controlp
parameter_list|,
name|int
modifier|*
name|flagsp
parameter_list|)
block|{
return|return
name|EOPNOTSUPP
return|;
block|}
end_function

begin_function
name|int
name|pru_sopoll_notsupp
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|int
name|events
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
return|return
name|EOPNOTSUPP
return|;
block|}
end_function

begin_comment
comment|/*  * Make a copy of a sockaddr in a malloced buffer of type M_SONAME.  */
end_comment

begin_function
name|struct
name|sockaddr
modifier|*
name|sodupsockaddr
parameter_list|(
specifier|const
name|struct
name|sockaddr
modifier|*
name|sa
parameter_list|,
name|int
name|mflags
parameter_list|)
block|{
name|struct
name|sockaddr
modifier|*
name|sa2
decl_stmt|;
name|sa2
operator|=
name|malloc
argument_list|(
name|sa
operator|->
name|sa_len
argument_list|,
name|M_SONAME
argument_list|,
name|mflags
argument_list|)
expr_stmt|;
if|if
condition|(
name|sa2
condition|)
name|bcopy
argument_list|(
name|sa
argument_list|,
name|sa2
argument_list|,
name|sa
operator|->
name|sa_len
argument_list|)
expr_stmt|;
return|return
name|sa2
return|;
block|}
end_function

begin_comment
comment|/*  * Create an external-format (``xsocket'') structure using the information  * in the kernel-format socket structure pointed to by so.  This is done  * to reduce the spew of irrelevant information over this interface,  * to isolate user code from changes in the kernel structure, and  * potentially to provide information-hiding if we decide that  * some of this information should be hidden from users.  */
end_comment

begin_function
name|void
name|sotoxsocket
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|xsocket
modifier|*
name|xso
parameter_list|)
block|{
name|xso
operator|->
name|xso_len
operator|=
sizeof|sizeof
expr|*
name|xso
expr_stmt|;
name|xso
operator|->
name|xso_so
operator|=
name|so
expr_stmt|;
name|xso
operator|->
name|so_type
operator|=
name|so
operator|->
name|so_type
expr_stmt|;
name|xso
operator|->
name|so_options
operator|=
name|so
operator|->
name|so_options
expr_stmt|;
name|xso
operator|->
name|so_linger
operator|=
name|so
operator|->
name|so_linger
expr_stmt|;
name|xso
operator|->
name|so_state
operator|=
name|so
operator|->
name|so_state
expr_stmt|;
name|xso
operator|->
name|so_pcb
operator|=
name|so
operator|->
name|so_pcb
expr_stmt|;
name|xso
operator|->
name|xso_protocol
operator|=
name|so
operator|->
name|so_proto
operator|->
name|pr_protocol
expr_stmt|;
name|xso
operator|->
name|xso_family
operator|=
name|so
operator|->
name|so_proto
operator|->
name|pr_domain
operator|->
name|dom_family
expr_stmt|;
name|xso
operator|->
name|so_qlen
operator|=
name|so
operator|->
name|so_qlen
expr_stmt|;
name|xso
operator|->
name|so_incqlen
operator|=
name|so
operator|->
name|so_incqlen
expr_stmt|;
name|xso
operator|->
name|so_qlimit
operator|=
name|so
operator|->
name|so_qlimit
expr_stmt|;
name|xso
operator|->
name|so_timeo
operator|=
name|so
operator|->
name|so_timeo
expr_stmt|;
name|xso
operator|->
name|so_error
operator|=
name|so
operator|->
name|so_error
expr_stmt|;
name|xso
operator|->
name|so_pgid
operator|=
name|so
operator|->
name|so_sigio
condition|?
name|so
operator|->
name|so_sigio
operator|->
name|sio_pgid
else|:
literal|0
expr_stmt|;
name|xso
operator|->
name|so_oobmark
operator|=
name|so
operator|->
name|so_oobmark
expr_stmt|;
name|sbtoxsockbuf
argument_list|(
operator|&
name|so
operator|->
name|so_snd
argument_list|,
operator|&
name|xso
operator|->
name|so_snd
argument_list|)
expr_stmt|;
name|sbtoxsockbuf
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|,
operator|&
name|xso
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
name|xso
operator|->
name|so_uid
operator|=
name|so
operator|->
name|so_cred
operator|->
name|cr_uid
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This does the same for sockbufs.  Note that the xsockbuf structure,  * since it is always embedded in a socket, does not include a self  * pointer nor a length.  We make this entry point public in case  * some other mechanism needs it.  */
end_comment

begin_function
name|void
name|sbtoxsockbuf
parameter_list|(
name|struct
name|sockbuf
modifier|*
name|sb
parameter_list|,
name|struct
name|xsockbuf
modifier|*
name|xsb
parameter_list|)
block|{
name|xsb
operator|->
name|sb_cc
operator|=
name|sb
operator|->
name|sb_cc
expr_stmt|;
name|xsb
operator|->
name|sb_hiwat
operator|=
name|sb
operator|->
name|sb_hiwat
expr_stmt|;
name|xsb
operator|->
name|sb_mbcnt
operator|=
name|sb
operator|->
name|sb_mbcnt
expr_stmt|;
name|xsb
operator|->
name|sb_mbmax
operator|=
name|sb
operator|->
name|sb_mbmax
expr_stmt|;
name|xsb
operator|->
name|sb_lowat
operator|=
name|sb
operator|->
name|sb_lowat
expr_stmt|;
name|xsb
operator|->
name|sb_flags
operator|=
name|sb
operator|->
name|sb_flags
expr_stmt|;
name|xsb
operator|->
name|sb_timeo
operator|=
name|sb
operator|->
name|sb_timeo
expr_stmt|;
block|}
end_function

end_unit

