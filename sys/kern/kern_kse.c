begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (C) 2001 Julian Elischer<julian@freebsd.org>.  *  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice(s), this list of conditions and the following disclaimer as  *    the first lines of this file unmodified other than the possible  *    addition of one or more copyright notices.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice(s), this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER(S) ``AS IS'' AND ANY  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE  * DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT HOLDER(S) BE LIABLE FOR ANY  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER  * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH  * DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/imgact.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/ptrace.h>
end_include

begin_include
include|#
directive|include
file|<sys/smp.h>
end_include

begin_include
include|#
directive|include
file|<sys/syscallsubr.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysproto.h>
end_include

begin_include
include|#
directive|include
file|<sys/sched.h>
end_include

begin_include
include|#
directive|include
file|<sys/signalvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/sleepqueue.h>
end_include

begin_include
include|#
directive|include
file|<sys/kse.h>
end_include

begin_include
include|#
directive|include
file|<sys/ktr.h>
end_include

begin_include
include|#
directive|include
file|<vm/uma.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|KSE
end_ifdef

begin_decl_stmt
specifier|static
name|uma_zone_t
name|upcall_zone
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* DEBUG ONLY */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|virtual_cpu
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|thread_debug
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|max_threads_per_proc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|max_groups_per_proc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|max_threads_hits
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|mtx
name|kse_zombie_lock
decl_stmt|;
end_decl_stmt

begin_macro
name|TAILQ_HEAD
argument_list|(
argument_list|,
argument|kse_upcall
argument_list|)
end_macro

begin_expr_stmt
name|zombie_upcalls
operator|=
name|TAILQ_HEAD_INITIALIZER
argument_list|(
name|zombie_upcalls
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function_decl
specifier|static
name|int
name|thread_update_usr_ticks
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|thread_alloc_spare
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|struct
name|kse_upcall
modifier|*
name|upcall_alloc
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|kse_upcall
modifier|*
name|ku
decl_stmt|;
name|ku
operator|=
name|uma_zalloc
argument_list|(
name|upcall_zone
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
return|return
operator|(
name|ku
operator|)
return|;
block|}
end_function

begin_function
name|void
name|upcall_free
parameter_list|(
name|struct
name|kse_upcall
modifier|*
name|ku
parameter_list|)
block|{
name|uma_zfree
argument_list|(
name|upcall_zone
argument_list|,
name|ku
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|upcall_link
parameter_list|(
name|struct
name|kse_upcall
modifier|*
name|ku
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|mtx_assert
argument_list|(
operator|&
name|sched_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|p
operator|->
name|p_upcalls
argument_list|,
name|ku
argument_list|,
name|ku_link
argument_list|)
expr_stmt|;
name|ku
operator|->
name|ku_proc
operator|=
name|p
expr_stmt|;
name|p
operator|->
name|p_numupcalls
operator|++
expr_stmt|;
block|}
end_function

begin_function
name|void
name|upcall_unlink
parameter_list|(
name|struct
name|kse_upcall
modifier|*
name|ku
parameter_list|)
block|{
name|struct
name|proc
modifier|*
name|p
init|=
name|ku
operator|->
name|ku_proc
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|sched_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|ku
operator|->
name|ku_owner
operator|==
name|NULL
argument_list|,
operator|(
literal|"%s: have owner"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|p
operator|->
name|p_upcalls
argument_list|,
name|ku
argument_list|,
name|ku_link
argument_list|)
expr_stmt|;
name|p
operator|->
name|p_numupcalls
operator|--
expr_stmt|;
name|upcall_stash
argument_list|(
name|ku
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|upcall_remove
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|mtx_assert
argument_list|(
operator|&
name|sched_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
if|if
condition|(
name|td
operator|->
name|td_upcall
operator|!=
name|NULL
condition|)
block|{
name|td
operator|->
name|td_upcall
operator|->
name|ku_owner
operator|=
name|NULL
expr_stmt|;
name|upcall_unlink
argument_list|(
name|td
operator|->
name|td_upcall
argument_list|)
expr_stmt|;
name|td
operator|->
name|td_upcall
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|_SYS_SYSPROTO_H_
end_ifndef

begin_struct
struct|struct
name|kse_switchin_args
block|{
name|struct
name|kse_thr_mailbox
modifier|*
name|tmbx
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|}
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|kse_switchin
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|kse_switchin_args
modifier|*
name|uap
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|KSE
name|struct
name|kse_thr_mailbox
name|tmbx
decl_stmt|;
name|struct
name|kse_upcall
modifier|*
name|ku
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
operator|(
name|ku
operator|=
name|td
operator|->
name|td_upcall
operator|)
operator|==
name|NULL
operator|||
name|TD_CAN_UNBIND
argument_list|(
name|td
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|error
operator|=
operator|(
name|uap
operator|->
name|tmbx
operator|==
name|NULL
operator|)
condition|?
name|EINVAL
else|:
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
name|error
operator|=
name|copyin
argument_list|(
name|uap
operator|->
name|tmbx
argument_list|,
operator|&
name|tmbx
argument_list|,
sizeof|sizeof
argument_list|(
name|tmbx
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
operator|&&
operator|(
name|uap
operator|->
name|flags
operator|&
name|KSE_SWITCHIN_SETTMBX
operator|)
condition|)
name|error
operator|=
operator|(
name|suword
argument_list|(
operator|&
name|ku
operator|->
name|ku_mailbox
operator|->
name|km_curthread
argument_list|,
operator|(
name|long
operator|)
name|uap
operator|->
name|tmbx
argument_list|)
operator|!=
literal|0
condition|?
name|EINVAL
else|:
literal|0
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
name|error
operator|=
name|set_mcontext
argument_list|(
name|td
argument_list|,
operator|&
name|tmbx
operator|.
name|tm_context
operator|.
name|uc_mcontext
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
block|{
name|suword32
argument_list|(
operator|&
name|uap
operator|->
name|tmbx
operator|->
name|tm_lwp
argument_list|,
name|td
operator|->
name|td_tid
argument_list|)
expr_stmt|;
if|if
condition|(
name|uap
operator|->
name|flags
operator|&
name|KSE_SWITCHIN_SETTMBX
condition|)
block|{
name|td
operator|->
name|td_mailbox
operator|=
name|uap
operator|->
name|tmbx
expr_stmt|;
name|td
operator|->
name|td_pflags
operator||=
name|TDP_CAN_UNBIND
expr_stmt|;
block|}
name|PROC_LOCK
argument_list|(
name|td
operator|->
name|td_proc
argument_list|)
expr_stmt|;
if|if
condition|(
name|td
operator|->
name|td_proc
operator|->
name|p_flag
operator|&
name|P_TRACED
condition|)
block|{
name|_PHOLD
argument_list|(
name|td
operator|->
name|td_proc
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmbx
operator|.
name|tm_dflags
operator|&
name|TMDF_SSTEP
condition|)
name|ptrace_single_step
argument_list|(
name|td
argument_list|)
expr_stmt|;
else|else
name|ptrace_clear_single_step
argument_list|(
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmbx
operator|.
name|tm_dflags
operator|&
name|TMDF_SUSPEND
condition|)
block|{
name|mtx_lock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
comment|/* fuword can block, check again */
if|if
condition|(
name|td
operator|->
name|td_upcall
condition|)
name|ku
operator|->
name|ku_flags
operator||=
name|KUF_DOUPCALL
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
block|}
name|_PRELE
argument_list|(
name|td
operator|->
name|td_proc
argument_list|)
expr_stmt|;
block|}
name|PROC_UNLOCK
argument_list|(
name|td
operator|->
name|td_proc
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
operator|(
name|error
operator|==
literal|0
operator|)
condition|?
name|EJUSTRETURN
else|:
name|error
operator|)
return|;
else|#
directive|else
comment|/* !KSE */
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* struct kse_thr_interrupt_args { 	struct kse_thr_mailbox * tmbx; 	int cmd; 	long data; }; */
end_comment

begin_function
name|int
name|kse_thr_interrupt
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|kse_thr_interrupt_args
modifier|*
name|uap
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|KSE
name|struct
name|kse_execve_args
name|args
decl_stmt|;
name|struct
name|image_args
name|iargs
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|struct
name|thread
modifier|*
name|td2
decl_stmt|;
name|struct
name|kse_upcall
modifier|*
name|ku
decl_stmt|;
name|struct
name|kse_thr_mailbox
modifier|*
name|tmbx
decl_stmt|;
name|uint32_t
name|flags
decl_stmt|;
name|int
name|error
decl_stmt|;
name|p
operator|=
name|td
operator|->
name|td_proc
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|p
operator|->
name|p_flag
operator|&
name|P_SA
operator|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
switch|switch
condition|(
name|uap
operator|->
name|cmd
condition|)
block|{
case|case
name|KSE_INTR_SENDSIG
case|:
if|if
condition|(
name|uap
operator|->
name|data
operator|<
literal|0
operator|||
name|uap
operator|->
name|data
operator|>
name|_SIG_MAXSIG
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
case|case
name|KSE_INTR_INTERRUPT
case|:
case|case
name|KSE_INTR_RESTART
case|:
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|mtx_lock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
name|FOREACH_THREAD_IN_PROC
argument_list|(
argument|p
argument_list|,
argument|td2
argument_list|)
block|{
if|if
condition|(
name|td2
operator|->
name|td_mailbox
operator|==
name|uap
operator|->
name|tmbx
condition|)
break|break;
block|}
if|if
condition|(
name|td2
operator|==
name|NULL
condition|)
block|{
name|mtx_unlock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
name|ESRCH
operator|)
return|;
block|}
if|if
condition|(
name|uap
operator|->
name|cmd
operator|==
name|KSE_INTR_SENDSIG
condition|)
block|{
if|if
condition|(
name|uap
operator|->
name|data
operator|>
literal|0
condition|)
block|{
name|td2
operator|->
name|td_flags
operator|&=
operator|~
name|TDF_INTERRUPT
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
name|tdsignal
argument_list|(
name|p
argument_list|,
name|td2
argument_list|,
operator|(
name|int
operator|)
name|uap
operator|->
name|data
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mtx_unlock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|td2
operator|->
name|td_flags
operator||=
name|TDF_INTERRUPT
operator||
name|TDF_ASTPENDING
expr_stmt|;
if|if
condition|(
name|TD_CAN_UNBIND
argument_list|(
name|td2
argument_list|)
condition|)
name|td2
operator|->
name|td_upcall
operator|->
name|ku_flags
operator||=
name|KUF_DOUPCALL
expr_stmt|;
if|if
condition|(
name|uap
operator|->
name|cmd
operator|==
name|KSE_INTR_INTERRUPT
condition|)
name|td2
operator|->
name|td_intrval
operator|=
name|EINTR
expr_stmt|;
else|else
name|td2
operator|->
name|td_intrval
operator|=
name|ERESTART
expr_stmt|;
if|if
condition|(
name|TD_ON_SLEEPQ
argument_list|(
name|td2
argument_list|)
operator|&&
operator|(
name|td2
operator|->
name|td_flags
operator|&
name|TDF_SINTR
operator|)
condition|)
name|sleepq_abort
argument_list|(
name|td2
argument_list|,
name|td2
operator|->
name|td_intrval
argument_list|)
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
block|}
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
break|break;
case|case
name|KSE_INTR_SIGEXIT
case|:
if|if
condition|(
name|uap
operator|->
name|data
operator|<
literal|1
operator|||
name|uap
operator|->
name|data
operator|>
name|_SIG_MAXSIG
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|sigexit
argument_list|(
name|td
argument_list|,
operator|(
name|int
operator|)
name|uap
operator|->
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|KSE_INTR_DBSUSPEND
case|:
comment|/* this sub-function is only for bound thread */
if|if
condition|(
name|td
operator|->
name|td_pflags
operator|&
name|TDP_SA
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|ku
operator|=
name|td
operator|->
name|td_upcall
expr_stmt|;
name|tmbx
operator|=
operator|(
name|void
operator|*
operator|)
name|fuword
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|&
name|ku
operator|->
name|ku_mailbox
operator|->
name|km_curthread
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmbx
operator|==
name|NULL
operator|||
name|tmbx
operator|==
operator|(
name|void
operator|*
operator|)
operator|-
literal|1
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|flags
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|p
operator|->
name|p_flag
operator|&
name|P_TRACED
operator|)
operator|&&
operator|!
operator|(
name|p
operator|->
name|p_flag
operator|&
name|P_SINGLE_EXIT
operator|)
condition|)
block|{
name|flags
operator|=
name|fuword32
argument_list|(
operator|&
name|tmbx
operator|->
name|tm_dflags
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|TMDF_SUSPEND
operator|)
condition|)
break|break;
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|mtx_lock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
name|thread_stopped
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|thread_suspend_one
argument_list|(
name|td
argument_list|)
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|mi_switch
argument_list|(
name|SW_VOL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|KSE_INTR_EXECVE
case|:
name|error
operator|=
name|copyin
argument_list|(
operator|(
name|void
operator|*
operator|)
name|uap
operator|->
name|data
argument_list|,
operator|&
name|args
argument_list|,
sizeof|sizeof
argument_list|(
name|args
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|error
operator|=
name|exec_copyin_args
argument_list|(
operator|&
name|iargs
argument_list|,
name|args
operator|.
name|path
argument_list|,
name|UIO_USERSPACE
argument_list|,
name|args
operator|.
name|argv
argument_list|,
name|args
operator|.
name|envp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|error
operator|=
name|kern_execve
argument_list|(
name|td
argument_list|,
operator|&
name|iargs
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|SIGSETOR
argument_list|(
name|td
operator|->
name|td_siglist
argument_list|,
name|args
operator|.
name|sigpend
argument_list|)
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|kern_sigprocmask
argument_list|(
name|td
argument_list|,
name|SIG_SETMASK
argument_list|,
operator|&
name|args
operator|.
name|sigmask
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
default|default:
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
else|#
directive|else
comment|/* !KSE */
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* struct kse_exit_args { 	register_t dummy; }; */
end_comment

begin_function
name|int
name|kse_exit
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|kse_exit_args
modifier|*
name|uap
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|KSE
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|struct
name|kse_upcall
modifier|*
name|ku
decl_stmt|,
modifier|*
name|ku2
decl_stmt|;
name|int
name|error
decl_stmt|,
name|count
decl_stmt|;
name|p
operator|=
name|td
operator|->
name|td_proc
expr_stmt|;
comment|/*  	 * Ensure that this is only called from the UTS 	 */
if|if
condition|(
operator|(
name|ku
operator|=
name|td
operator|->
name|td_upcall
operator|)
operator|==
name|NULL
operator|||
name|TD_CAN_UNBIND
argument_list|(
name|td
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|count
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Calculate the existing non-exiting upcalls in this process. 	 * If we are the last upcall but there are still other threads, 	 * then do not exit. We need the other threads to be able to  	 * complete whatever they are doing. 	 * XXX This relies on the userland knowing what to do if we return. 	 * It may be a better choice to convert ourselves into a kse_release 	 * ( or similar) and wait in the kernel to be needed. 	 */
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|mtx_lock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
name|FOREACH_UPCALL_IN_PROC
argument_list|(
argument|p
argument_list|,
argument|ku2
argument_list|)
block|{
if|if
condition|(
name|ku2
operator|->
name|ku_flags
operator|&
name|KUF_EXITING
condition|)
name|count
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|p
operator|->
name|p_numupcalls
operator|-
name|count
operator|)
operator|==
literal|1
operator|&&
operator|(
name|p
operator|->
name|p_numthreads
operator|>
literal|1
operator|)
condition|)
block|{
name|mtx_unlock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
name|EDEADLK
operator|)
return|;
block|}
name|ku
operator|->
name|ku_flags
operator||=
name|KUF_EXITING
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/*  	 * Mark the UTS mailbox as having been finished with. 	 * If that fails then just go for a segfault. 	 * XXX need to check it that can be deliverred without a mailbox. 	 */
name|error
operator|=
name|suword32
argument_list|(
operator|&
name|ku
operator|->
name|ku_mailbox
operator|->
name|km_flags
argument_list|,
name|ku
operator|->
name|ku_mflags
operator||
name|KMF_DONE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|td
operator|->
name|td_pflags
operator|&
name|TDP_SA
operator|)
condition|)
if|if
condition|(
name|suword32
argument_list|(
operator|&
name|td
operator|->
name|td_mailbox
operator|->
name|tm_lwp
argument_list|,
literal|0
argument_list|)
condition|)
name|error
operator|=
name|EFAULT
expr_stmt|;
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|psignal
argument_list|(
name|p
argument_list|,
name|SIGSEGV
argument_list|)
expr_stmt|;
name|sigqueue_flush
argument_list|(
operator|&
name|td
operator|->
name|td_sigqueue
argument_list|)
expr_stmt|;
name|mtx_lock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
name|upcall_remove
argument_list|(
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|p_numthreads
operator|!=
literal|1
condition|)
block|{
name|thread_stopped
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|thread_exit
argument_list|()
expr_stmt|;
comment|/* NOTREACHED */
block|}
comment|/* 	 * This is the last thread. Just return to the user. 	 * Effectively we have left threading mode.. 	 * The only real thing left to do is ensure that the 	 * scheduler sets out concurrency back to 1 as that may be a 	 * resource leak otherwise. 	 * This is an A[PB]I issue.. what SHOULD we do? 	 * One possibility is to return to the user. It may not cope well. 	 * The other possibility would be to let the process exit. 	 */
name|thread_unthread
argument_list|(
name|td
argument_list|)
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|#
directive|if
literal|1
return|return
operator|(
literal|0
operator|)
return|;
else|#
directive|else
name|exit1
argument_list|(
name|td
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
else|#
directive|else
comment|/* !KSE */
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * Either becomes an upcall or waits for an awakening event and  * then becomes an upcall. Only error cases return.  */
end_comment

begin_comment
comment|/* struct kse_release_args { 	struct timespec *timeout; }; */
end_comment

begin_function
name|int
name|kse_release
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|kse_release_args
modifier|*
name|uap
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|KSE
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|struct
name|kse_upcall
modifier|*
name|ku
decl_stmt|;
name|struct
name|timespec
name|timeout
decl_stmt|;
name|struct
name|timeval
name|tv
decl_stmt|;
name|sigset_t
name|sigset
decl_stmt|;
name|int
name|error
decl_stmt|;
name|p
operator|=
name|td
operator|->
name|td_proc
expr_stmt|;
if|if
condition|(
operator|(
name|ku
operator|=
name|td
operator|->
name|td_upcall
operator|)
operator|==
name|NULL
operator|||
name|TD_CAN_UNBIND
argument_list|(
name|td
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|uap
operator|->
name|timeout
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|copyin
argument_list|(
name|uap
operator|->
name|timeout
argument_list|,
operator|&
name|timeout
argument_list|,
sizeof|sizeof
argument_list|(
name|timeout
argument_list|)
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|TIMESPEC_TO_TIMEVAL
argument_list|(
operator|&
name|tv
argument_list|,
operator|&
name|timeout
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|td
operator|->
name|td_pflags
operator|&
name|TDP_SA
condition|)
name|td
operator|->
name|td_pflags
operator||=
name|TDP_UPCALLING
expr_stmt|;
else|else
block|{
name|ku
operator|->
name|ku_mflags
operator|=
name|fuword32
argument_list|(
operator|&
name|ku
operator|->
name|ku_mailbox
operator|->
name|km_flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|ku
operator|->
name|ku_mflags
operator|==
operator|-
literal|1
condition|)
block|{
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|sigexit
argument_list|(
name|td
argument_list|,
name|SIGSEGV
argument_list|)
expr_stmt|;
block|}
block|}
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|ku
operator|->
name|ku_mflags
operator|&
name|KMF_WAITSIGEVENT
condition|)
block|{
comment|/* UTS wants to wait for signal event */
if|if
condition|(
operator|!
operator|(
name|p
operator|->
name|p_flag
operator|&
name|P_SIGEVENT
operator|)
operator|&&
operator|!
operator|(
name|ku
operator|->
name|ku_flags
operator|&
name|KUF_DOUPCALL
operator|)
condition|)
block|{
name|td
operator|->
name|td_kflags
operator||=
name|TDK_KSERELSIG
expr_stmt|;
name|error
operator|=
name|msleep
argument_list|(
operator|&
name|p
operator|->
name|p_siglist
argument_list|,
operator|&
name|p
operator|->
name|p_mtx
argument_list|,
name|PPAUSE
operator||
name|PCATCH
argument_list|,
literal|"ksesigwait"
argument_list|,
operator|(
name|uap
operator|->
name|timeout
condition|?
name|tvtohz
argument_list|(
operator|&
name|tv
argument_list|)
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
name|td
operator|->
name|td_kflags
operator|&=
operator|~
operator|(
name|TDK_KSERELSIG
operator||
name|TDK_WAKEUP
operator|)
expr_stmt|;
block|}
name|p
operator|->
name|p_flag
operator|&=
operator|~
name|P_SIGEVENT
expr_stmt|;
name|sigset
operator|=
name|p
operator|->
name|p_siglist
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|error
operator|=
name|copyout
argument_list|(
operator|&
name|sigset
argument_list|,
operator|&
name|ku
operator|->
name|ku_mailbox
operator|->
name|km_sigscaught
argument_list|,
sizeof|sizeof
argument_list|(
name|sigset
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|ku
operator|->
name|ku_flags
operator|&
name|KUF_DOUPCALL
operator|)
operator|==
literal|0
operator|&&
operator|(
operator|(
name|ku
operator|->
name|ku_mflags
operator|&
name|KMF_NOCOMPLETED
operator|)
operator|||
operator|(
name|p
operator|->
name|p_completed
operator|==
name|NULL
operator|)
operator|)
condition|)
block|{
name|p
operator|->
name|p_upsleeps
operator|++
expr_stmt|;
name|td
operator|->
name|td_kflags
operator||=
name|TDK_KSEREL
expr_stmt|;
name|error
operator|=
name|msleep
argument_list|(
operator|&
name|p
operator|->
name|p_completed
argument_list|,
operator|&
name|p
operator|->
name|p_mtx
argument_list|,
name|PPAUSE
operator||
name|PCATCH
argument_list|,
literal|"kserel"
argument_list|,
operator|(
name|uap
operator|->
name|timeout
condition|?
name|tvtohz
argument_list|(
operator|&
name|tv
argument_list|)
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
name|td
operator|->
name|td_kflags
operator|&=
operator|~
operator|(
name|TDK_KSEREL
operator||
name|TDK_WAKEUP
operator|)
expr_stmt|;
name|p
operator|->
name|p_upsleeps
operator|--
expr_stmt|;
block|}
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ku
operator|->
name|ku_flags
operator|&
name|KUF_DOUPCALL
condition|)
block|{
name|mtx_lock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
name|ku
operator|->
name|ku_flags
operator|&=
operator|~
name|KUF_DOUPCALL
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
else|#
directive|else
comment|/* !KSE */
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* struct kse_wakeup_args { 	struct kse_mailbox *mbx; }; */
end_comment

begin_function
name|int
name|kse_wakeup
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|kse_wakeup_args
modifier|*
name|uap
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|KSE
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|struct
name|kse_upcall
modifier|*
name|ku
decl_stmt|;
name|struct
name|thread
modifier|*
name|td2
decl_stmt|;
name|p
operator|=
name|td
operator|->
name|td_proc
expr_stmt|;
name|td2
operator|=
name|NULL
expr_stmt|;
name|ku
operator|=
name|NULL
expr_stmt|;
comment|/* KSE-enabled processes only, please. */
if|if
condition|(
operator|!
operator|(
name|p
operator|->
name|p_flag
operator|&
name|P_SA
operator|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|mtx_lock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|uap
operator|->
name|mbx
condition|)
block|{
name|FOREACH_UPCALL_IN_PROC
argument_list|(
argument|p
argument_list|,
argument|ku
argument_list|)
block|{
if|if
condition|(
name|ku
operator|->
name|ku_mailbox
operator|==
name|uap
operator|->
name|mbx
condition|)
break|break;
block|}
block|}
else|else
block|{
if|if
condition|(
name|p
operator|->
name|p_upsleeps
condition|)
block|{
name|mtx_unlock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|p
operator|->
name|p_completed
argument_list|)
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|ku
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|p
operator|->
name|p_upcalls
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ku
operator|==
name|NULL
condition|)
block|{
name|mtx_unlock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
name|ESRCH
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|td2
operator|=
name|ku
operator|->
name|ku_owner
operator|)
operator|==
name|NULL
condition|)
block|{
name|mtx_unlock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"%s: no owner"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|td2
operator|->
name|td_kflags
operator|&
operator|(
name|TDK_KSEREL
operator||
name|TDK_KSERELSIG
operator|)
condition|)
block|{
name|mtx_unlock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|td2
operator|->
name|td_kflags
operator|&
name|TDK_WAKEUP
operator|)
condition|)
block|{
name|td2
operator|->
name|td_kflags
operator||=
name|TDK_WAKEUP
expr_stmt|;
if|if
condition|(
name|td2
operator|->
name|td_kflags
operator|&
name|TDK_KSEREL
condition|)
name|sleepq_remove
argument_list|(
name|td2
argument_list|,
operator|&
name|p
operator|->
name|p_completed
argument_list|)
expr_stmt|;
else|else
name|sleepq_remove
argument_list|(
name|td2
argument_list|,
operator|&
name|p
operator|->
name|p_siglist
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|ku
operator|->
name|ku_flags
operator||=
name|KUF_DOUPCALL
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
block|}
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
else|#
directive|else
comment|/* !KSE */
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * newgroup == 0: first call: use current KSE, don't schedule an upcall  * All other situations, do allocate max new KSEs and schedule an upcall.  *  * XXX should be changed so that 'first' behaviour lasts for as long  * as you have not made a thread in this proc. i.e. as long as we do not have  * a mailbox..  */
end_comment

begin_comment
comment|/* struct kse_create_args { 	struct kse_mailbox *mbx; 	int newgroup; }; */
end_comment

begin_function
name|int
name|kse_create
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|kse_create_args
modifier|*
name|uap
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|KSE
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|struct
name|kse_mailbox
name|mbx
decl_stmt|;
name|struct
name|kse_upcall
modifier|*
name|newku
decl_stmt|;
name|int
name|err
decl_stmt|,
name|ncpus
decl_stmt|,
name|sa
init|=
literal|0
decl_stmt|,
name|first
init|=
literal|0
decl_stmt|;
name|struct
name|thread
modifier|*
name|newtd
decl_stmt|;
name|p
operator|=
name|td
operator|->
name|td_proc
expr_stmt|;
comment|/* 	 * Processes using the other threading model can't 	 * suddenly start calling this one 	 * XXX  maybe... 	 */
if|if
condition|(
operator|(
name|p
operator|->
name|p_flag
operator|&
operator|(
name|P_SA
operator||
name|P_HADTHREADS
operator|)
operator|)
operator|==
name|P_HADTHREADS
condition|)
block|{
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
operator|!
operator|(
name|p
operator|->
name|p_flag
operator|&
name|P_SA
operator|)
condition|)
block|{
name|first
operator|=
literal|1
expr_stmt|;
name|p
operator|->
name|p_flag
operator||=
name|P_SA
operator||
name|P_HADTHREADS
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|err
operator|=
name|copyin
argument_list|(
name|uap
operator|->
name|mbx
argument_list|,
operator|&
name|mbx
argument_list|,
sizeof|sizeof
argument_list|(
name|mbx
argument_list|)
argument_list|)
operator|)
condition|)
return|return
operator|(
name|err
operator|)
return|;
name|ncpus
operator|=
name|mp_ncpus
expr_stmt|;
if|if
condition|(
name|virtual_cpu
operator|!=
literal|0
condition|)
name|ncpus
operator|=
name|virtual_cpu
expr_stmt|;
comment|/* 	 * If the new UTS mailbox says that this 	 * will be a BOUND lwp, then it had better 	 * have its thread mailbox already there. 	 */
if|if
condition|(
operator|(
name|mbx
operator|.
name|km_flags
operator|&
name|KMF_BOUND
operator|)
operator|||
name|uap
operator|->
name|newgroup
condition|)
block|{
if|if
condition|(
name|mbx
operator|.
name|km_curthread
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|ncpus
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|uap
operator|->
name|newgroup
operator|||
name|first
operator|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
else|else
block|{
name|sa
operator|=
name|TDP_SA
expr_stmt|;
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* 		 * Limit it to NCPU upcall contexts per proc in any case. 		 */
if|if
condition|(
name|p
operator|->
name|p_numupcalls
operator|>=
name|ncpus
condition|)
block|{
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
name|EPROCLIM
operator|)
return|;
block|}
comment|/* 		 * We want to make a thread (bound or unbound). 		 * If we are just the first call, either kind 		 * is ok, but if not then either we must be  		 * already an upcallable thread to make another, 		 * or a bound thread to make one of those. 		 * Once again, not quite right but good enough for now.. XXXKSE 		 * XXX bogus 		 */
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|first
operator|&&
operator|(
operator|(
name|td
operator|->
name|td_pflags
operator|&
name|TDP_SA
operator|)
operator|!=
name|sa
operator|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|p
operator|->
name|p_numupcalls
operator|==
literal|0
condition|)
block|{
name|sched_set_concurrency
argument_list|(
name|p
argument_list|,
name|ncpus
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*  	 * Even bound LWPs get a mailbox and an upcall to hold it. 	 */
name|newku
operator|=
name|upcall_alloc
argument_list|()
expr_stmt|;
name|newku
operator|->
name|ku_mailbox
operator|=
name|uap
operator|->
name|mbx
expr_stmt|;
name|newku
operator|->
name|ku_func
operator|=
name|mbx
operator|.
name|km_func
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|mbx
operator|.
name|km_stack
argument_list|,
operator|&
name|newku
operator|->
name|ku_stack
argument_list|,
sizeof|sizeof
argument_list|(
name|stack_t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * For the first call this may not have been set. 	 * Of course nor may it actually be needed. 	 */
if|if
condition|(
name|td
operator|->
name|td_standin
operator|==
name|NULL
condition|)
name|thread_alloc_spare
argument_list|(
name|td
argument_list|)
expr_stmt|;
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|mtx_lock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|sa
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|p_numupcalls
operator|>=
name|ncpus
condition|)
block|{
name|mtx_unlock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|upcall_free
argument_list|(
name|newku
argument_list|)
expr_stmt|;
return|return
operator|(
name|EPROCLIM
operator|)
return|;
block|}
comment|/* 		 * If we are the first time, and a normal thread, 		 * then transfer all the signals back to the 'process'. 		 * SA threading will make a special thread to handle them. 		 */
if|if
condition|(
name|first
condition|)
block|{
name|sigqueue_move_set
argument_list|(
operator|&
name|td
operator|->
name|td_sigqueue
argument_list|,
operator|&
name|p
operator|->
name|p_sigqueue
argument_list|,
operator|&
name|td
operator|->
name|td_sigqueue
operator|.
name|sq_signals
argument_list|)
expr_stmt|;
name|SIGFILLSET
argument_list|(
name|td
operator|->
name|td_sigmask
argument_list|)
expr_stmt|;
name|SIG_CANTMASK
argument_list|(
name|td
operator|->
name|td_sigmask
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* should subtract from process count (later) */
block|}
comment|/* 	 * Make the new upcall available to the process. 	 * It may or may not use it, but it's available. 	 */
name|upcall_link
argument_list|(
name|newku
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|mbx
operator|.
name|km_quantum
condition|)
comment|/* XXX should this be in the thread? */
name|p
operator|->
name|p_upquantum
operator|=
name|max
argument_list|(
literal|1
argument_list|,
name|mbx
operator|.
name|km_quantum
operator|/
name|tick
argument_list|)
expr_stmt|;
comment|/* 	 * Each upcall structure has an owner thread, find which 	 * one owns it. 	 */
if|if
condition|(
name|uap
operator|->
name|newgroup
condition|)
block|{
comment|/* 		 * The newgroup parameter now means 		 * "bound, non SA, system scope" 		 * It is only used for the interrupt thread at the 		 * moment I think 		 * We'll rename it later. 		 */
name|newtd
operator|=
name|thread_schedule_upcall
argument_list|(
name|td
argument_list|,
name|newku
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * If the current thread hasn't an upcall structure, 		 * just assign the upcall to it. 		 * It'll just return. 		 */
if|if
condition|(
name|td
operator|->
name|td_upcall
operator|==
name|NULL
condition|)
block|{
name|newku
operator|->
name|ku_owner
operator|=
name|td
expr_stmt|;
name|td
operator|->
name|td_upcall
operator|=
name|newku
expr_stmt|;
name|newtd
operator|=
name|td
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * Create a new upcall thread to own it. 			 */
name|newtd
operator|=
name|thread_schedule_upcall
argument_list|(
name|td
argument_list|,
name|newku
argument_list|)
expr_stmt|;
block|}
block|}
name|mtx_unlock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
comment|/* 	 * Let the UTS instance know its LWPID. 	 * It doesn't really care. But the debugger will. 	 * XXX warning.. remember that this moves. 	 */
name|suword32
argument_list|(
operator|&
name|newku
operator|->
name|ku_mailbox
operator|->
name|km_lwp
argument_list|,
name|newtd
operator|->
name|td_tid
argument_list|)
expr_stmt|;
comment|/* 	 * In the same manner, if the UTS has a current user thread,  	 * then it is also running on this LWP so set it as well. 	 * The library could do that of course.. but why not.. 	 */
if|if
condition|(
name|mbx
operator|.
name|km_curthread
condition|)
name|suword32
argument_list|(
operator|&
name|mbx
operator|.
name|km_curthread
operator|->
name|tm_lwp
argument_list|,
name|newtd
operator|->
name|td_tid
argument_list|)
expr_stmt|;
if|if
condition|(
name|sa
condition|)
block|{
name|newtd
operator|->
name|td_pflags
operator||=
name|TDP_SA
expr_stmt|;
comment|/*  		 * If we are starting a new thread, kick it off. 		 */
if|if
condition|(
name|newtd
operator|!=
name|td
condition|)
block|{
name|mtx_lock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
name|setrunqueue
argument_list|(
name|newtd
argument_list|,
name|SRQ_BORING
argument_list|)
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|newtd
operator|->
name|td_pflags
operator|&=
operator|~
name|TDP_SA
expr_stmt|;
comment|/* 		 * Since a library will use the mailbox pointer to  		 * identify even a bound thread, and the mailbox pointer 		 * will never be allowed to change after this syscall 		 * for a bound thread, set it here so the library can 		 * find the thread after the syscall returns. 		 */
name|newtd
operator|->
name|td_mailbox
operator|=
name|mbx
operator|.
name|km_curthread
expr_stmt|;
if|if
condition|(
name|newtd
operator|!=
name|td
condition|)
block|{
comment|/* 			 * If we did create a new thread then 			 * make sure it goes to the right place 			 * when it starts up, and make sure that it runs  			 * at full speed when it gets there.  			 * thread_schedule_upcall() copies all cpu state 			 * to the new thread, so we should clear single step 			 * flag here. 			 */
name|cpu_set_upcall_kse
argument_list|(
name|newtd
argument_list|,
name|newku
operator|->
name|ku_func
argument_list|,
name|newku
operator|->
name|ku_mailbox
argument_list|,
operator|&
name|newku
operator|->
name|ku_stack
argument_list|)
expr_stmt|;
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|p_flag
operator|&
name|P_TRACED
condition|)
block|{
name|_PHOLD
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|ptrace_clear_single_step
argument_list|(
name|newtd
argument_list|)
expr_stmt|;
name|_PRELE
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|mtx_lock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
name|setrunqueue
argument_list|(
name|newtd
argument_list|,
name|SRQ_BORING
argument_list|)
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
else|#
directive|else
comment|/* !KSE */
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
endif|#
directive|endif
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|KSE
end_ifdef

begin_comment
comment|/*  * Initialize global thread allocation resources.  */
end_comment

begin_function
name|void
name|kseinit
parameter_list|(
name|void
parameter_list|)
block|{
name|upcall_zone
operator|=
name|uma_zcreate
argument_list|(
literal|"UPCALL"
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|kse_upcall
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|UMA_ALIGN_CACHE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Stash an embarasingly extra upcall into the zombie upcall queue.  */
end_comment

begin_function
name|void
name|upcall_stash
parameter_list|(
name|struct
name|kse_upcall
modifier|*
name|ku
parameter_list|)
block|{
name|mtx_lock_spin
argument_list|(
operator|&
name|kse_zombie_lock
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|zombie_upcalls
argument_list|,
name|ku
argument_list|,
name|ku_link
argument_list|)
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|kse_zombie_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Reap zombie kse resource.  */
end_comment

begin_function
name|void
name|kse_GC
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|kse_upcall
modifier|*
name|ku_first
decl_stmt|,
modifier|*
name|ku_next
decl_stmt|;
comment|/* 	 * Don't even bother to lock if none at this instant, 	 * we really don't care about the next instant.. 	 */
if|if
condition|(
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|zombie_upcalls
argument_list|)
condition|)
block|{
name|mtx_lock_spin
argument_list|(
operator|&
name|kse_zombie_lock
argument_list|)
expr_stmt|;
name|ku_first
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|zombie_upcalls
argument_list|)
expr_stmt|;
if|if
condition|(
name|ku_first
condition|)
name|TAILQ_INIT
argument_list|(
operator|&
name|zombie_upcalls
argument_list|)
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|kse_zombie_lock
argument_list|)
expr_stmt|;
while|while
condition|(
name|ku_first
condition|)
block|{
name|ku_next
operator|=
name|TAILQ_NEXT
argument_list|(
name|ku_first
argument_list|,
name|ku_link
argument_list|)
expr_stmt|;
name|upcall_free
argument_list|(
name|ku_first
argument_list|)
expr_stmt|;
name|ku_first
operator|=
name|ku_next
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Store the thread context in the UTS's mailbox.  * then add the mailbox at the head of a list we are building in user space.  * The list is anchored in the proc structure.  */
end_comment

begin_function
name|int
name|thread_export_context
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|int
name|willexit
parameter_list|)
block|{
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|uintptr_t
name|mbx
decl_stmt|;
name|void
modifier|*
name|addr
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|,
name|sig
decl_stmt|;
name|mcontext_t
name|mc
decl_stmt|;
name|p
operator|=
name|td
operator|->
name|td_proc
expr_stmt|;
comment|/* 	 * Post sync signal, or process SIGKILL and SIGSTOP. 	 * For sync signal, it is only possible when the signal is not 	 * caught by userland or process is being debugged. 	 */
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|td
operator|->
name|td_flags
operator|&
name|TDF_NEEDSIGCHK
condition|)
block|{
name|mtx_lock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
name|td
operator|->
name|td_flags
operator|&=
operator|~
name|TDF_NEEDSIGCHK
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|p
operator|->
name|p_sigacts
operator|->
name|ps_mtx
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|sig
operator|=
name|cursig
argument_list|(
name|td
argument_list|)
operator|)
operator|!=
literal|0
condition|)
name|postsig
argument_list|(
name|sig
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|p
operator|->
name|p_sigacts
operator|->
name|ps_mtx
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|willexit
condition|)
name|SIGFILLSET
argument_list|(
name|td
operator|->
name|td_sigmask
argument_list|)
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* Export the user/machine context. */
name|get_mcontext
argument_list|(
name|td
argument_list|,
operator|&
name|mc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|addr
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
operator|&
name|td
operator|->
name|td_mailbox
operator|->
name|tm_context
operator|.
name|uc_mcontext
operator|)
expr_stmt|;
name|error
operator|=
name|copyout
argument_list|(
operator|&
name|mc
argument_list|,
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
name|mcontext_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|bad
goto|;
name|addr
operator|=
call|(
name|caddr_t
call|)
argument_list|(
operator|&
name|td
operator|->
name|td_mailbox
operator|->
name|tm_lwp
argument_list|)
expr_stmt|;
if|if
condition|(
name|suword32
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|error
operator|=
name|EFAULT
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
comment|/* Get address in latest mbox of list pointer */
name|addr
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
operator|&
name|td
operator|->
name|td_mailbox
operator|->
name|tm_next
operator|)
expr_stmt|;
comment|/* 	 * Put the saved address of the previous first 	 * entry into this one 	 */
for|for
control|(
init|;
condition|;
control|)
block|{
name|mbx
operator|=
operator|(
name|uintptr_t
operator|)
name|p
operator|->
name|p_completed
expr_stmt|;
if|if
condition|(
name|suword
argument_list|(
name|addr
argument_list|,
name|mbx
argument_list|)
condition|)
block|{
name|error
operator|=
name|EFAULT
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|mbx
operator|==
operator|(
name|uintptr_t
operator|)
name|p
operator|->
name|p_completed
condition|)
block|{
name|p
operator|->
name|p_completed
operator|=
name|td
operator|->
name|td_mailbox
expr_stmt|;
comment|/* 			 * The thread context may be taken away by 			 * other upcall threads when we unlock 			 * process lock. it's no longer valid to 			 * use it again in any other places. 			 */
name|td
operator|->
name|td_mailbox
operator|=
name|NULL
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
break|break;
block|}
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
name|td
operator|->
name|td_usticks
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|bad
label|:
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|sigexit
argument_list|(
name|td
argument_list|,
name|SIGILL
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Take the list of completed mailboxes for this Process and put them on this  * upcall's mailbox as it's the next one going up.  */
end_comment

begin_function
specifier|static
name|int
name|thread_link_mboxes
parameter_list|(
name|struct
name|proc
modifier|*
name|p
parameter_list|,
name|struct
name|kse_upcall
modifier|*
name|ku
parameter_list|)
block|{
name|void
modifier|*
name|addr
decl_stmt|;
name|uintptr_t
name|mbx
decl_stmt|;
name|addr
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
operator|&
name|ku
operator|->
name|ku_mailbox
operator|->
name|km_completed
operator|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|mbx
operator|=
operator|(
name|uintptr_t
operator|)
name|p
operator|->
name|p_completed
expr_stmt|;
if|if
condition|(
name|suword
argument_list|(
name|addr
argument_list|,
name|mbx
argument_list|)
condition|)
block|{
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|psignal
argument_list|(
name|p
argument_list|,
name|SIGSEGV
argument_list|)
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
name|EFAULT
operator|)
return|;
block|}
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|mbx
operator|==
operator|(
name|uintptr_t
operator|)
name|p
operator|->
name|p_completed
condition|)
block|{
name|p
operator|->
name|p_completed
operator|=
name|NULL
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
break|break;
block|}
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * This function should be called at statclock interrupt time  */
end_comment

begin_function
name|int
name|thread_statclock
parameter_list|(
name|int
name|user
parameter_list|)
block|{
name|struct
name|thread
modifier|*
name|td
init|=
name|curthread
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|td
operator|->
name|td_pflags
operator|&
name|TDP_SA
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|user
condition|)
block|{
comment|/* Current always do via ast() */
name|mtx_lock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
name|td
operator|->
name|td_flags
operator||=
name|TDF_ASTPENDING
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
name|td
operator|->
name|td_uuticks
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|td
operator|->
name|td_mailbox
operator|!=
name|NULL
condition|)
name|td
operator|->
name|td_usticks
operator|++
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Export state clock ticks for userland  */
end_comment

begin_function
specifier|static
name|int
name|thread_update_usr_ticks
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|proc
modifier|*
name|p
init|=
name|td
operator|->
name|td_proc
decl_stmt|;
name|caddr_t
name|addr
decl_stmt|;
name|u_int
name|uticks
decl_stmt|;
if|if
condition|(
name|td
operator|->
name|td_mailbox
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
operator|(
name|uticks
operator|=
name|td
operator|->
name|td_uuticks
operator|)
operator|!=
literal|0
condition|)
block|{
name|td
operator|->
name|td_uuticks
operator|=
literal|0
expr_stmt|;
name|addr
operator|=
operator|(
name|caddr_t
operator|)
operator|&
name|td
operator|->
name|td_mailbox
operator|->
name|tm_uticks
expr_stmt|;
if|if
condition|(
name|suword32
argument_list|(
name|addr
argument_list|,
name|uticks
operator|+
name|fuword32
argument_list|(
name|addr
argument_list|)
argument_list|)
condition|)
goto|goto
name|error
goto|;
block|}
if|if
condition|(
operator|(
name|uticks
operator|=
name|td
operator|->
name|td_usticks
operator|)
operator|!=
literal|0
condition|)
block|{
name|td
operator|->
name|td_usticks
operator|=
literal|0
expr_stmt|;
name|addr
operator|=
operator|(
name|caddr_t
operator|)
operator|&
name|td
operator|->
name|td_mailbox
operator|->
name|tm_sticks
expr_stmt|;
if|if
condition|(
name|suword32
argument_list|(
name|addr
argument_list|,
name|uticks
operator|+
name|fuword32
argument_list|(
name|addr
argument_list|)
argument_list|)
condition|)
goto|goto
name|error
goto|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
name|error
label|:
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|psignal
argument_list|(
name|p
argument_list|,
name|SIGSEGV
argument_list|)
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|2
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * This function is intended to be used to initialize a spare thread  * for upcall. Initialize thread's large data area outside sched_lock  * for thread_schedule_upcall(). The crhold is also here to get it out  * from the schedlock as it has a mutex op itself.  * XXX BUG.. we need to get the cr ref after the thread has   * checked and chenged its own, not 6 months before...    */
end_comment

begin_function
name|void
name|thread_alloc_spare
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|thread
modifier|*
name|spare
decl_stmt|;
if|if
condition|(
name|td
operator|->
name|td_standin
condition|)
return|return;
name|spare
operator|=
name|thread_alloc
argument_list|()
expr_stmt|;
name|td
operator|->
name|td_standin
operator|=
name|spare
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|spare
operator|->
name|td_startzero
argument_list|,
name|__rangeof
argument_list|(
expr|struct
name|thread
argument_list|,
name|td_startzero
argument_list|,
name|td_endzero
argument_list|)
argument_list|)
expr_stmt|;
name|spare
operator|->
name|td_proc
operator|=
name|td
operator|->
name|td_proc
expr_stmt|;
name|spare
operator|->
name|td_ucred
operator|=
name|crhold
argument_list|(
name|td
operator|->
name|td_ucred
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Create a thread and schedule it for upcall on the KSE given.  * Use our thread's standin so that we don't have to allocate one.  */
end_comment

begin_function
name|struct
name|thread
modifier|*
name|thread_schedule_upcall
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|kse_upcall
modifier|*
name|ku
parameter_list|)
block|{
name|struct
name|thread
modifier|*
name|td2
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|sched_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
comment|/* 	 * Schedule an upcall thread on specified kse_upcall, 	 * the kse_upcall must be free. 	 * td must have a spare thread. 	 */
name|KASSERT
argument_list|(
name|ku
operator|->
name|ku_owner
operator|==
name|NULL
argument_list|,
operator|(
literal|"%s: upcall has owner"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|td2
operator|=
name|td
operator|->
name|td_standin
operator|)
operator|!=
name|NULL
condition|)
block|{
name|td
operator|->
name|td_standin
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|panic
argument_list|(
literal|"no reserve thread when scheduling an upcall"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|CTR3
argument_list|(
name|KTR_PROC
argument_list|,
literal|"thread_schedule_upcall: thread %p (pid %d, %s)"
argument_list|,
name|td2
argument_list|,
name|td
operator|->
name|td_proc
operator|->
name|p_pid
argument_list|,
name|td
operator|->
name|td_proc
operator|->
name|p_comm
argument_list|)
expr_stmt|;
comment|/* 	 * Bzero already done in thread_alloc_spare() because we can't 	 * do the crhold here because we are in schedlock already. 	 */
name|bcopy
argument_list|(
operator|&
name|td
operator|->
name|td_startcopy
argument_list|,
operator|&
name|td2
operator|->
name|td_startcopy
argument_list|,
name|__rangeof
argument_list|(
expr|struct
name|thread
argument_list|,
name|td_startcopy
argument_list|,
name|td_endcopy
argument_list|)
argument_list|)
expr_stmt|;
name|thread_link
argument_list|(
name|td2
argument_list|,
name|ku
operator|->
name|ku_proc
argument_list|)
expr_stmt|;
comment|/* inherit parts of blocked thread's context as a good template */
name|cpu_set_upcall
argument_list|(
name|td2
argument_list|,
name|td
argument_list|)
expr_stmt|;
comment|/* Let the new thread become owner of the upcall */
name|ku
operator|->
name|ku_owner
operator|=
name|td2
expr_stmt|;
name|td2
operator|->
name|td_upcall
operator|=
name|ku
expr_stmt|;
name|td2
operator|->
name|td_flags
operator|=
literal|0
expr_stmt|;
name|td2
operator|->
name|td_pflags
operator|=
name|TDP_SA
operator||
name|TDP_UPCALLING
expr_stmt|;
name|td2
operator|->
name|td_state
operator|=
name|TDS_CAN_RUN
expr_stmt|;
name|td2
operator|->
name|td_inhibitors
operator|=
literal|0
expr_stmt|;
name|SIGFILLSET
argument_list|(
name|td2
operator|->
name|td_sigmask
argument_list|)
expr_stmt|;
name|SIG_CANTMASK
argument_list|(
name|td2
operator|->
name|td_sigmask
argument_list|)
expr_stmt|;
name|sched_fork_thread
argument_list|(
name|td
argument_list|,
name|td2
argument_list|)
expr_stmt|;
return|return
operator|(
name|td2
operator|)
return|;
comment|/* bogus.. should be a void function */
block|}
end_function

begin_comment
comment|/*  * It is only used when thread generated a trap and process is being  * debugged.  */
end_comment

begin_function
name|void
name|thread_signal_add
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|ksiginfo_t
modifier|*
name|ksi
parameter_list|)
block|{
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|struct
name|sigacts
modifier|*
name|ps
decl_stmt|;
name|int
name|error
decl_stmt|;
name|p
operator|=
name|td
operator|->
name|td_proc
expr_stmt|;
name|PROC_LOCK_ASSERT
argument_list|(
name|p
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|ps
operator|=
name|p
operator|->
name|p_sigacts
expr_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|ps
operator|->
name|ps_mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|ps
operator|->
name|ps_mtx
argument_list|)
expr_stmt|;
name|SIGADDSET
argument_list|(
name|td
operator|->
name|td_sigmask
argument_list|,
name|ksi
operator|->
name|ksi_signo
argument_list|)
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|error
operator|=
name|copyout
argument_list|(
operator|&
name|ksi
operator|->
name|ksi_info
argument_list|,
operator|&
name|td
operator|->
name|td_mailbox
operator|->
name|tm_syncsig
argument_list|,
sizeof|sizeof
argument_list|(
name|siginfo_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|sigexit
argument_list|(
name|td
argument_list|,
name|SIGSEGV
argument_list|)
expr_stmt|;
block|}
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|ps
operator|->
name|ps_mtx
argument_list|)
expr_stmt|;
block|}
end_function

begin_include
include|#
directive|include
file|"opt_sched.h"
end_include

begin_function
name|struct
name|thread
modifier|*
name|thread_switchout
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|int
name|flags
parameter_list|,
name|struct
name|thread
modifier|*
name|nextthread
parameter_list|)
block|{
name|struct
name|kse_upcall
modifier|*
name|ku
decl_stmt|;
name|struct
name|thread
modifier|*
name|td2
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|sched_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
comment|/* 	 * If the outgoing thread is in threaded group and has never 	 * scheduled an upcall, decide whether this is a short 	 * or long term event and thus whether or not to schedule 	 * an upcall. 	 * If it is a short term event, just suspend it in 	 * a way that takes its KSE with it. 	 * Select the events for which we want to schedule upcalls. 	 * For now it's just sleep or if thread is suspended but 	 * process wide suspending flag is not set (debugger 	 * suspends thread). 	 * XXXKSE eventually almost any inhibition could do. 	 */
if|if
condition|(
name|TD_CAN_UNBIND
argument_list|(
name|td
argument_list|)
operator|&&
operator|(
name|td
operator|->
name|td_standin
operator|)
operator|&&
operator|(
name|TD_ON_SLEEPQ
argument_list|(
name|td
argument_list|)
operator|||
operator|(
name|TD_IS_SUSPENDED
argument_list|(
name|td
argument_list|)
operator|&&
operator|!
name|P_SHOULDSTOP
argument_list|(
name|td
operator|->
name|td_proc
argument_list|)
operator|)
operator|)
condition|)
block|{
comment|/* 		 * Release ownership of upcall, and schedule an upcall 		 * thread, this new upcall thread becomes the owner of 		 * the upcall structure. It will be ahead of us in the 		 * run queue, so as we are stopping, it should either 		 * start up immediatly, or at least before us if 		 * we release our slot. 		 */
name|ku
operator|=
name|td
operator|->
name|td_upcall
expr_stmt|;
name|ku
operator|->
name|ku_owner
operator|=
name|NULL
expr_stmt|;
name|td
operator|->
name|td_upcall
operator|=
name|NULL
expr_stmt|;
name|td
operator|->
name|td_pflags
operator|&=
operator|~
name|TDP_CAN_UNBIND
expr_stmt|;
name|td2
operator|=
name|thread_schedule_upcall
argument_list|(
name|td
argument_list|,
name|ku
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|SW_INVOL
operator|||
name|nextthread
condition|)
block|{
name|setrunqueue
argument_list|(
name|td2
argument_list|,
name|SRQ_YIELDING
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Keep up with reality.. we have one extra thread  			 * in the picture.. and it's 'running'. 			 */
return|return
name|td2
return|;
block|}
block|}
return|return
operator|(
name|nextthread
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Setup done on the thread when it enters the kernel.  */
end_comment

begin_function
name|void
name|thread_user_enter
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|proc
modifier|*
name|p
init|=
name|td
operator|->
name|td_proc
decl_stmt|;
name|struct
name|kse_upcall
modifier|*
name|ku
decl_stmt|;
name|struct
name|kse_thr_mailbox
modifier|*
name|tmbx
decl_stmt|;
name|uint32_t
name|flags
decl_stmt|;
comment|/* 	 * First check that we shouldn't just abort. we 	 * can suspend it here or just exit. 	 */
if|if
condition|(
name|__predict_false
argument_list|(
name|P_SHOULDSTOP
argument_list|(
name|p
argument_list|)
argument_list|)
condition|)
block|{
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|thread_suspend_check
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|td
operator|->
name|td_pflags
operator|&
name|TDP_SA
operator|)
condition|)
return|return;
comment|/* 	 * If we are doing a syscall in a KSE environment, 	 * note where our mailbox is. 	 */
name|ku
operator|=
name|td
operator|->
name|td_upcall
expr_stmt|;
name|KASSERT
argument_list|(
name|ku
operator|!=
name|NULL
argument_list|,
operator|(
literal|"no upcall owned"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|ku
operator|->
name|ku_owner
operator|==
name|td
argument_list|,
operator|(
literal|"wrong owner"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|!
name|TD_CAN_UNBIND
argument_list|(
name|td
argument_list|)
argument_list|,
operator|(
literal|"can unbind"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|td
operator|->
name|td_standin
operator|==
name|NULL
condition|)
name|thread_alloc_spare
argument_list|(
name|td
argument_list|)
expr_stmt|;
name|ku
operator|->
name|ku_mflags
operator|=
name|fuword32
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|&
name|ku
operator|->
name|ku_mailbox
operator|->
name|km_flags
argument_list|)
expr_stmt|;
name|tmbx
operator|=
operator|(
name|void
operator|*
operator|)
name|fuword
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|&
name|ku
operator|->
name|ku_mailbox
operator|->
name|km_curthread
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tmbx
operator|==
name|NULL
operator|)
operator|||
operator|(
name|tmbx
operator|==
operator|(
name|void
operator|*
operator|)
operator|-
literal|1L
operator|)
operator|||
operator|(
name|ku
operator|->
name|ku_mflags
operator|&
name|KMF_NOUPCALL
operator|)
condition|)
block|{
name|td
operator|->
name|td_mailbox
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|flags
operator|=
name|fuword32
argument_list|(
operator|&
name|tmbx
operator|->
name|tm_flags
argument_list|)
expr_stmt|;
comment|/* 		 * On some architectures, TP register points to thread 		 * mailbox but not points to kse mailbox, and userland 		 * can not atomically clear km_curthread, but can 		 * use TP register, and set TMF_NOUPCALL in thread 		 * flag	to indicate a critical region. 		 */
if|if
condition|(
name|flags
operator|&
name|TMF_NOUPCALL
condition|)
block|{
name|td
operator|->
name|td_mailbox
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|td
operator|->
name|td_mailbox
operator|=
name|tmbx
expr_stmt|;
name|td
operator|->
name|td_pflags
operator||=
name|TDP_CAN_UNBIND
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|p
operator|->
name|p_flag
operator|&
name|P_TRACED
argument_list|)
condition|)
block|{
name|flags
operator|=
name|fuword32
argument_list|(
operator|&
name|tmbx
operator|->
name|tm_dflags
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|TMDF_SUSPEND
condition|)
block|{
name|mtx_lock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
comment|/* fuword can block, check again */
if|if
condition|(
name|td
operator|->
name|td_upcall
condition|)
name|ku
operator|->
name|ku_flags
operator||=
name|KUF_DOUPCALL
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * The extra work we go through if we are a threaded process when we  * return to userland.  *  * If we are a KSE process and returning to user mode, check for  * extra work to do before we return (e.g. for more syscalls  * to complete first).  If we were in a critical section, we should  * just return to let it finish. Same if we were in the UTS (in  * which case the mailbox's context's busy indicator will be set).  * The only traps we suport will have set the mailbox.  * We will clear it here.  */
end_comment

begin_function
name|int
name|thread_userret
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|trapframe
modifier|*
name|frame
parameter_list|)
block|{
name|struct
name|kse_upcall
modifier|*
name|ku
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|struct
name|timespec
name|ts
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|,
name|uts_crit
decl_stmt|;
comment|/* Nothing to do with bound thread */
if|if
condition|(
operator|!
operator|(
name|td
operator|->
name|td_pflags
operator|&
name|TDP_SA
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * Update stat clock count for userland 	 */
if|if
condition|(
name|td
operator|->
name|td_mailbox
operator|!=
name|NULL
condition|)
block|{
name|thread_update_usr_ticks
argument_list|(
name|td
argument_list|)
expr_stmt|;
name|uts_crit
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|uts_crit
operator|=
literal|1
expr_stmt|;
block|}
name|p
operator|=
name|td
operator|->
name|td_proc
expr_stmt|;
name|ku
operator|=
name|td
operator|->
name|td_upcall
expr_stmt|;
comment|/* 	 * Optimisation: 	 * This thread has not started any upcall. 	 * If there is no work to report other than ourself, 	 * then it can return direct to userland. 	 */
if|if
condition|(
name|TD_CAN_UNBIND
argument_list|(
name|td
argument_list|)
condition|)
block|{
name|td
operator|->
name|td_pflags
operator|&=
operator|~
name|TDP_CAN_UNBIND
expr_stmt|;
if|if
condition|(
operator|(
name|td
operator|->
name|td_flags
operator|&
name|TDF_NEEDSIGCHK
operator|)
operator|==
literal|0
operator|&&
operator|(
name|p
operator|->
name|p_completed
operator|==
name|NULL
operator|)
operator|&&
operator|(
name|ku
operator|->
name|ku_flags
operator|&
name|KUF_DOUPCALL
operator|)
operator|==
literal|0
operator|&&
operator|(
name|p
operator|->
name|p_upquantum
operator|&&
name|ticks
operator|<
name|p
operator|->
name|p_nextupcall
operator|)
condition|)
block|{
name|nanotime
argument_list|(
operator|&
name|ts
argument_list|)
expr_stmt|;
name|error
operator|=
name|copyout
argument_list|(
operator|&
name|ts
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|ku
operator|->
name|ku_mailbox
operator|->
name|km_timeofday
argument_list|,
sizeof|sizeof
argument_list|(
name|ts
argument_list|)
argument_list|)
expr_stmt|;
name|td
operator|->
name|td_mailbox
operator|=
literal|0
expr_stmt|;
name|ku
operator|->
name|ku_mflags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|thread_export_context
argument_list|(
name|td
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 		 * There is something to report, and we own an upcall 		 * structure, we can go to userland. 		 * Turn ourself into an upcall thread. 		 */
name|td
operator|->
name|td_pflags
operator||=
name|TDP_UPCALLING
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|td
operator|->
name|td_mailbox
operator|&&
operator|(
name|ku
operator|==
name|NULL
operator|)
condition|)
block|{
name|thread_export_context
argument_list|(
name|td
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|p_upsleeps
condition|)
name|wakeup
argument_list|(
operator|&
name|p
operator|->
name|p_completed
argument_list|)
expr_stmt|;
name|WITNESS_WARN
argument_list|(
name|WARN_PANIC
argument_list|,
operator|&
name|p
operator|->
name|p_mtx
operator|.
name|mtx_object
argument_list|,
literal|"thread exiting in userret"
argument_list|)
expr_stmt|;
name|sigqueue_flush
argument_list|(
operator|&
name|td
operator|->
name|td_sigqueue
argument_list|)
expr_stmt|;
name|mtx_lock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
name|thread_stopped
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|thread_exit
argument_list|()
expr_stmt|;
comment|/* NOTREACHED */
block|}
name|KASSERT
argument_list|(
name|ku
operator|!=
name|NULL
argument_list|,
operator|(
literal|"upcall is NULL"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|TD_CAN_UNBIND
argument_list|(
name|td
argument_list|)
operator|==
literal|0
argument_list|,
operator|(
literal|"can unbind"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|p_numthreads
operator|>
name|max_threads_per_proc
condition|)
block|{
name|max_threads_hits
operator|++
expr_stmt|;
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|mtx_lock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
name|p
operator|->
name|p_maxthrwaits
operator|++
expr_stmt|;
while|while
condition|(
name|p
operator|->
name|p_numthreads
operator|>
name|max_threads_per_proc
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|p_numupcalls
operator|>=
name|max_threads_per_proc
condition|)
break|break;
name|mtx_unlock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|msleep
argument_list|(
operator|&
name|p
operator|->
name|p_numthreads
argument_list|,
operator|&
name|p
operator|->
name|p_mtx
argument_list|,
name|PPAUSE
operator||
name|PCATCH
argument_list|,
literal|"maxthreads"
argument_list|,
name|hz
operator|/
literal|10
argument_list|)
operator|!=
name|EWOULDBLOCK
condition|)
block|{
name|mtx_lock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
break|break;
block|}
else|else
block|{
name|mtx_lock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
block|}
block|}
name|p
operator|->
name|p_maxthrwaits
operator|--
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|td
operator|->
name|td_pflags
operator|&
name|TDP_UPCALLING
condition|)
block|{
name|uts_crit
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|p_nextupcall
operator|=
name|ticks
operator|+
name|p
operator|->
name|p_upquantum
expr_stmt|;
comment|/* 		 * There is no more work to do and we are going to ride 		 * this thread up to userland as an upcall. 		 * Do the last parts of the setup needed for the upcall. 		 */
name|CTR3
argument_list|(
name|KTR_PROC
argument_list|,
literal|"userret: upcall thread %p (pid %d, %s)"
argument_list|,
name|td
argument_list|,
name|td
operator|->
name|td_proc
operator|->
name|p_pid
argument_list|,
name|td
operator|->
name|td_proc
operator|->
name|p_comm
argument_list|)
expr_stmt|;
name|td
operator|->
name|td_pflags
operator|&=
operator|~
name|TDP_UPCALLING
expr_stmt|;
if|if
condition|(
name|ku
operator|->
name|ku_flags
operator|&
name|KUF_DOUPCALL
condition|)
block|{
name|mtx_lock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
name|ku
operator|->
name|ku_flags
operator|&=
operator|~
name|KUF_DOUPCALL
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Set user context to the UTS 		 */
if|if
condition|(
operator|!
operator|(
name|ku
operator|->
name|ku_mflags
operator|&
name|KMF_NOUPCALL
operator|)
condition|)
block|{
name|cpu_set_upcall_kse
argument_list|(
name|td
argument_list|,
name|ku
operator|->
name|ku_func
argument_list|,
name|ku
operator|->
name|ku_mailbox
argument_list|,
operator|&
name|ku
operator|->
name|ku_stack
argument_list|)
expr_stmt|;
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|p_flag
operator|&
name|P_TRACED
condition|)
block|{
name|_PHOLD
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|ptrace_clear_single_step
argument_list|(
name|td
argument_list|)
expr_stmt|;
name|_PRELE
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|error
operator|=
name|suword32
argument_list|(
operator|&
name|ku
operator|->
name|ku_mailbox
operator|->
name|km_lwp
argument_list|,
name|td
operator|->
name|td_tid
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
name|error
operator|=
name|suword
argument_list|(
operator|&
name|ku
operator|->
name|ku_mailbox
operator|->
name|km_curthread
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
block|}
comment|/* 		 * Unhook the list of completed threads. 		 * anything that completes after this gets to 		 * come in next time. 		 * Put the list of completed thread mailboxes on 		 * this KSE's mailbox. 		 */
if|if
condition|(
operator|!
operator|(
name|ku
operator|->
name|ku_mflags
operator|&
name|KMF_NOCOMPLETED
operator|)
operator|&&
operator|(
name|error
operator|=
name|thread_link_mboxes
argument_list|(
name|p
argument_list|,
name|ku
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
block|}
if|if
condition|(
operator|!
name|uts_crit
condition|)
block|{
name|nanotime
argument_list|(
operator|&
name|ts
argument_list|)
expr_stmt|;
name|error
operator|=
name|copyout
argument_list|(
operator|&
name|ts
argument_list|,
operator|&
name|ku
operator|->
name|ku_mailbox
operator|->
name|km_timeofday
argument_list|,
sizeof|sizeof
argument_list|(
name|ts
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|out
label|:
if|if
condition|(
name|error
condition|)
block|{
comment|/* 		 * Things are going to be so screwed we should just kill 		 * the process. 		 * how do we do that? 		 */
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|psignal
argument_list|(
name|p
argument_list|,
name|SIGSEGV
argument_list|)
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Optimisation: 		 * Ensure that we have a spare thread available, 		 * for when we re-enter the kernel. 		 */
if|if
condition|(
name|td
operator|->
name|td_standin
operator|==
name|NULL
condition|)
name|thread_alloc_spare
argument_list|(
name|td
argument_list|)
expr_stmt|;
block|}
name|ku
operator|->
name|ku_mflags
operator|=
literal|0
expr_stmt|;
name|td
operator|->
name|td_mailbox
operator|=
name|NULL
expr_stmt|;
name|td
operator|->
name|td_usticks
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
comment|/* go sync */
block|}
end_function

begin_comment
comment|/*  * called after ptrace resumed a process, force all  * virtual CPUs to schedule upcall for SA process,  * because debugger may have changed something in userland,  * we should notice UTS as soon as possible.  */
end_comment

begin_function
name|void
name|thread_continued
parameter_list|(
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|kse_upcall
modifier|*
name|ku
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|PROC_LOCK_ASSERT
argument_list|(
name|p
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|P_SHOULDSTOP
argument_list|(
name|p
argument_list|)
argument_list|,
operator|(
literal|"process not stopped"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|p
operator|->
name|p_flag
operator|&
name|P_SA
operator|)
condition|)
return|return;
if|if
condition|(
name|p
operator|->
name|p_flag
operator|&
name|P_TRACED
condition|)
block|{
name|td
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|p
operator|->
name|p_threads
argument_list|)
expr_stmt|;
if|if
condition|(
name|td
operator|&&
operator|(
name|td
operator|->
name|td_pflags
operator|&
name|TDP_SA
operator|)
condition|)
block|{
name|FOREACH_UPCALL_IN_PROC
argument_list|(
argument|p
argument_list|,
argument|ku
argument_list|)
block|{
name|mtx_lock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
name|ku
operator|->
name|ku_flags
operator||=
name|KUF_DOUPCALL
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|p
operator|->
name|p_completed
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

