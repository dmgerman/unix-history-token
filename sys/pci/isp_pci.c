begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* $FreeBSD$ */
end_comment

begin_comment
comment|/*  * PCI specific probe and attach routines for Qlogic ISP SCSI adapters.  * FreeBSD Version.  *  * Copyright (c) 1997, 1998, 1999, 2000 by Matthew Jacob  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice immediately at the beginning of the file, without modification,  *    this list of conditions, and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE FOR  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<pci/pcireg.h>
end_include

begin_include
include|#
directive|include
file|<pci/pcivar.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus_memio.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus_pio.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<machine/clock.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<dev/isp/isp_freebsd.h>
end_include

begin_decl_stmt
specifier|static
name|u_int16_t
name|isp_pci_rd_reg
name|__P
argument_list|(
operator|(
expr|struct
name|ispsoftc
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|isp_pci_wr_reg
name|__P
argument_list|(
operator|(
expr|struct
name|ispsoftc
operator|*
operator|,
name|int
operator|,
name|u_int16_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_int16_t
name|isp_pci_rd_reg_1080
name|__P
argument_list|(
operator|(
expr|struct
name|ispsoftc
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|isp_pci_wr_reg_1080
name|__P
argument_list|(
operator|(
expr|struct
name|ispsoftc
operator|*
operator|,
name|int
operator|,
name|u_int16_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|isp_pci_mbxdma
name|__P
argument_list|(
operator|(
expr|struct
name|ispsoftc
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|isp_pci_dmasetup
name|__P
argument_list|(
operator|(
expr|struct
name|ispsoftc
operator|*
operator|,
name|XS_T
operator|*
operator|,
name|ispreq_t
operator|*
operator|,
name|u_int16_t
operator|*
operator|,
name|u_int16_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|isp_pci_dmateardown
name|__P
argument_list|(
operator|(
expr|struct
name|ispsoftc
operator|*
operator|,
name|XS_T
operator|*
operator|,
name|u_int32_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|isp_pci_reset1
name|__P
argument_list|(
operator|(
expr|struct
name|ispsoftc
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|isp_pci_dumpregs
name|__P
argument_list|(
operator|(
expr|struct
name|ispsoftc
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|ISP_CODE_ORG
end_ifndef

begin_define
define|#
directive|define
name|ISP_CODE_ORG
value|0x1000
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|struct
name|ispmdvec
name|mdvec
init|=
block|{
name|isp_pci_rd_reg
block|,
name|isp_pci_wr_reg
block|,
name|isp_pci_mbxdma
block|,
name|isp_pci_dmasetup
block|,
name|isp_pci_dmateardown
block|,
name|NULL
block|,
name|isp_pci_reset1
block|,
name|isp_pci_dumpregs
block|,
name|NULL
block|,
name|BIU_BURST_ENABLE
operator||
name|BIU_PCI_CONF1_FIFO_64
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|ispmdvec
name|mdvec_1080
init|=
block|{
name|isp_pci_rd_reg_1080
block|,
name|isp_pci_wr_reg_1080
block|,
name|isp_pci_mbxdma
block|,
name|isp_pci_dmasetup
block|,
name|isp_pci_dmateardown
block|,
name|NULL
block|,
name|isp_pci_reset1
block|,
name|isp_pci_dumpregs
block|,
name|NULL
block|,
name|BIU_BURST_ENABLE
operator||
name|BIU_PCI_CONF1_FIFO_64
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|ispmdvec
name|mdvec_12160
init|=
block|{
name|isp_pci_rd_reg_1080
block|,
name|isp_pci_wr_reg_1080
block|,
name|isp_pci_mbxdma
block|,
name|isp_pci_dmasetup
block|,
name|isp_pci_dmateardown
block|,
name|NULL
block|,
name|isp_pci_reset1
block|,
name|isp_pci_dumpregs
block|,
name|NULL
block|,
name|BIU_BURST_ENABLE
operator||
name|BIU_PCI_CONF1_FIFO_64
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|ispmdvec
name|mdvec_2100
init|=
block|{
name|isp_pci_rd_reg
block|,
name|isp_pci_wr_reg
block|,
name|isp_pci_mbxdma
block|,
name|isp_pci_dmasetup
block|,
name|isp_pci_dmateardown
block|,
name|NULL
block|,
name|isp_pci_reset1
block|,
name|isp_pci_dumpregs
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|ispmdvec
name|mdvec_2200
init|=
block|{
name|isp_pci_rd_reg
block|,
name|isp_pci_wr_reg
block|,
name|isp_pci_mbxdma
block|,
name|isp_pci_dmasetup
block|,
name|isp_pci_dmateardown
block|,
name|NULL
block|,
name|isp_pci_reset1
block|,
name|isp_pci_dumpregs
block|}
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|PCIM_CMD_INVEN
end_ifndef

begin_define
define|#
directive|define
name|PCIM_CMD_INVEN
value|0x10
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|PCIM_CMD_BUSMASTEREN
end_ifndef

begin_define
define|#
directive|define
name|PCIM_CMD_BUSMASTEREN
value|0x0004
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|PCIM_CMD_PERRESPEN
end_ifndef

begin_define
define|#
directive|define
name|PCIM_CMD_PERRESPEN
value|0x0040
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|PCIM_CMD_SEREN
end_ifndef

begin_define
define|#
directive|define
name|PCIM_CMD_SEREN
value|0x0100
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|PCIR_COMMAND
end_ifndef

begin_define
define|#
directive|define
name|PCIR_COMMAND
value|0x04
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|PCIR_CACHELNSZ
end_ifndef

begin_define
define|#
directive|define
name|PCIR_CACHELNSZ
value|0x0c
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|PCIR_LATTIMER
end_ifndef

begin_define
define|#
directive|define
name|PCIR_LATTIMER
value|0x0d
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|PCIR_ROMADDR
end_ifndef

begin_define
define|#
directive|define
name|PCIR_ROMADDR
value|0x30
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|PCI_VENDOR_QLOGIC
end_ifndef

begin_define
define|#
directive|define
name|PCI_VENDOR_QLOGIC
value|0x1077
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|PCI_PRODUCT_QLOGIC_ISP1020
end_ifndef

begin_define
define|#
directive|define
name|PCI_PRODUCT_QLOGIC_ISP1020
value|0x1020
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|PCI_PRODUCT_QLOGIC_ISP1080
end_ifndef

begin_define
define|#
directive|define
name|PCI_PRODUCT_QLOGIC_ISP1080
value|0x1080
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|PCI_PRODUCT_QLOGIC_ISP12160
end_ifndef

begin_define
define|#
directive|define
name|PCI_PRODUCT_QLOGIC_ISP12160
value|0x1216
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|PCI_PRODUCT_QLOGIC_ISP1240
end_ifndef

begin_define
define|#
directive|define
name|PCI_PRODUCT_QLOGIC_ISP1240
value|0x1240
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|PCI_PRODUCT_QLOGIC_ISP1280
end_ifndef

begin_define
define|#
directive|define
name|PCI_PRODUCT_QLOGIC_ISP1280
value|0x1280
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|PCI_PRODUCT_QLOGIC_ISP2100
end_ifndef

begin_define
define|#
directive|define
name|PCI_PRODUCT_QLOGIC_ISP2100
value|0x2100
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|PCI_PRODUCT_QLOGIC_ISP2200
end_ifndef

begin_define
define|#
directive|define
name|PCI_PRODUCT_QLOGIC_ISP2200
value|0x2200
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|PCI_QLOGIC_ISP1020
define|\
value|((PCI_PRODUCT_QLOGIC_ISP1020<< 16) | PCI_VENDOR_QLOGIC)
end_define

begin_define
define|#
directive|define
name|PCI_QLOGIC_ISP1080
define|\
value|((PCI_PRODUCT_QLOGIC_ISP1080<< 16) | PCI_VENDOR_QLOGIC)
end_define

begin_define
define|#
directive|define
name|PCI_QLOGIC_ISP12160
define|\
value|((PCI_PRODUCT_QLOGIC_ISP12160<< 16) | PCI_VENDOR_QLOGIC)
end_define

begin_define
define|#
directive|define
name|PCI_QLOGIC_ISP1240
define|\
value|((PCI_PRODUCT_QLOGIC_ISP1240<< 16) | PCI_VENDOR_QLOGIC)
end_define

begin_define
define|#
directive|define
name|PCI_QLOGIC_ISP1280
define|\
value|((PCI_PRODUCT_QLOGIC_ISP1280<< 16) | PCI_VENDOR_QLOGIC)
end_define

begin_define
define|#
directive|define
name|PCI_QLOGIC_ISP2100
define|\
value|((PCI_PRODUCT_QLOGIC_ISP2100<< 16) | PCI_VENDOR_QLOGIC)
end_define

begin_define
define|#
directive|define
name|PCI_QLOGIC_ISP2200
define|\
value|((PCI_PRODUCT_QLOGIC_ISP2200<< 16) | PCI_VENDOR_QLOGIC)
end_define

begin_comment
comment|/*  * Odd case for some AMI raid cards... We need to *not* attach to this.  */
end_comment

begin_define
define|#
directive|define
name|AMI_RAID_SUBVENDOR_ID
value|0x101e
end_define

begin_define
define|#
directive|define
name|IO_MAP_REG
value|0x10
end_define

begin_define
define|#
directive|define
name|MEM_MAP_REG
value|0x14
end_define

begin_define
define|#
directive|define
name|PCI_DFLT_LTNCY
value|0x40
end_define

begin_define
define|#
directive|define
name|PCI_DFLT_LNSZ
value|0x10
end_define

begin_function_decl
specifier|static
name|int
name|isp_pci_probe
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|isp_pci_attach
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_struct
struct|struct
name|isp_pcisoftc
block|{
name|struct
name|ispsoftc
name|pci_isp
decl_stmt|;
name|device_t
name|pci_dev
decl_stmt|;
name|struct
name|resource
modifier|*
name|pci_reg
decl_stmt|;
name|bus_space_tag_t
name|pci_st
decl_stmt|;
name|bus_space_handle_t
name|pci_sh
decl_stmt|;
name|void
modifier|*
name|ih
decl_stmt|;
name|int16_t
name|pci_poff
index|[
name|_NREG_BLKS
index|]
decl_stmt|;
name|bus_dma_tag_t
name|parent_dmat
decl_stmt|;
name|bus_dma_tag_t
name|cntrol_dmat
decl_stmt|;
name|bus_dmamap_t
name|cntrol_dmap
decl_stmt|;
name|bus_dmamap_t
modifier|*
name|dmaps
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|ispfwfunc
modifier|*
name|isp_get_firmware_p
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|device_method_t
name|isp_pci_methods
index|[]
init|=
block|{
comment|/* Device interface */
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|isp_pci_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|isp_pci_attach
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|isp_pci_driver
init|=
block|{
literal|"isp"
block|,
name|isp_pci_methods
block|,
expr|sizeof
operator|(
expr|struct
name|isp_pcisoftc
operator|)
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|devclass_t
name|isp_devclass
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|isp
argument_list|,
name|pci
argument_list|,
name|isp_pci_driver
argument_list|,
name|isp_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_VERSION
argument_list|(
name|isp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|int
name|isp_pci_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
switch|switch
condition|(
operator|(
name|pci_get_device
argument_list|(
name|dev
argument_list|)
operator|<<
literal|16
operator|)
operator||
operator|(
name|pci_get_vendor
argument_list|(
name|dev
argument_list|)
operator|)
condition|)
block|{
case|case
name|PCI_QLOGIC_ISP1020
case|:
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"Qlogic ISP 1020/1040 PCI SCSI Adapter"
argument_list|)
expr_stmt|;
break|break;
case|case
name|PCI_QLOGIC_ISP1080
case|:
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"Qlogic ISP 1080 PCI SCSI Adapter"
argument_list|)
expr_stmt|;
break|break;
case|case
name|PCI_QLOGIC_ISP1240
case|:
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"Qlogic ISP 1240 PCI SCSI Adapter"
argument_list|)
expr_stmt|;
break|break;
case|case
name|PCI_QLOGIC_ISP1280
case|:
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"Qlogic ISP 1280 PCI SCSI Adapter"
argument_list|)
expr_stmt|;
break|break;
case|case
name|PCI_QLOGIC_ISP12160
case|:
if|if
condition|(
name|pci_get_subvendor
argument_list|(
name|dev
argument_list|)
operator|==
name|AMI_RAID_SUBVENDOR_ID
condition|)
block|{
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"Qlogic ISP 12160 PCI SCSI Adapter"
argument_list|)
expr_stmt|;
break|break;
case|case
name|PCI_QLOGIC_ISP2100
case|:
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"Qlogic ISP 2100 PCI FC-AL Adapter"
argument_list|)
expr_stmt|;
break|break;
case|case
name|PCI_QLOGIC_ISP2200
case|:
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"Qlogic ISP 2200 PCI FC-AL Adapter"
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
if|if
condition|(
name|device_get_unit
argument_list|(
name|dev
argument_list|)
operator|==
literal|0
operator|&&
name|bootverbose
condition|)
block|{
name|printf
argument_list|(
literal|"Qlogic ISP Driver, FreeBSD Version %d.%d, "
literal|"Core Version %d.%d\n"
argument_list|,
name|ISP_PLATFORM_VERSION_MAJOR
argument_list|,
name|ISP_PLATFORM_VERSION_MINOR
argument_list|,
name|ISP_CORE_VERSION_MAJOR
argument_list|,
name|ISP_CORE_VERSION_MINOR
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * XXXX: Here is where we might load the f/w module 	 * XXXX: (or increase a reference count to it). 	 */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|isp_pci_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|resource
modifier|*
name|regs
decl_stmt|,
modifier|*
name|irq
decl_stmt|;
name|int
name|unit
decl_stmt|,
name|bitmap
decl_stmt|,
name|rtp
decl_stmt|,
name|rgd
decl_stmt|,
name|iqd
decl_stmt|,
name|m1
decl_stmt|,
name|m2
decl_stmt|,
name|s
decl_stmt|,
name|isp_debug
decl_stmt|;
name|u_int32_t
name|data
decl_stmt|,
name|cmd
decl_stmt|,
name|linesz
decl_stmt|,
name|psize
decl_stmt|,
name|basetype
decl_stmt|;
name|struct
name|isp_pcisoftc
modifier|*
name|pcs
decl_stmt|;
name|struct
name|ispsoftc
modifier|*
name|isp
decl_stmt|;
name|struct
name|ispmdvec
modifier|*
name|mdvp
decl_stmt|;
name|bus_size_t
name|lim
decl_stmt|;
comment|/* 	 * Figure out if we're supposed to skip this one. 	 */
name|unit
operator|=
name|device_get_unit
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|getenv_int
argument_list|(
literal|"isp_disable"
argument_list|,
operator|&
name|bitmap
argument_list|)
condition|)
block|{
if|if
condition|(
name|bitmap
operator|&
operator|(
literal|1
operator|<<
name|unit
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"not configuring\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENODEV
operator|)
return|;
block|}
block|}
name|pcs
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|isp_pcisoftc
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcs
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"cannot allocate softc\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|bzero
argument_list|(
name|pcs
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|isp_pcisoftc
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Figure out which we should try first - memory mapping or i/o mapping? 	 */
ifdef|#
directive|ifdef
name|__alpha__
name|m1
operator|=
name|PCIM_CMD_MEMEN
expr_stmt|;
name|m2
operator|=
name|PCIM_CMD_PORTEN
expr_stmt|;
else|#
directive|else
name|m1
operator|=
name|PCIM_CMD_PORTEN
expr_stmt|;
name|m2
operator|=
name|PCIM_CMD_MEMEN
expr_stmt|;
endif|#
directive|endif
name|bitmap
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|getenv_int
argument_list|(
literal|"isp_mem_map"
argument_list|,
operator|&
name|bitmap
argument_list|)
condition|)
block|{
if|if
condition|(
name|bitmap
operator|&
operator|(
literal|1
operator|<<
name|unit
operator|)
condition|)
block|{
name|m1
operator|=
name|PCIM_CMD_MEMEN
expr_stmt|;
name|m2
operator|=
name|PCIM_CMD_PORTEN
expr_stmt|;
block|}
block|}
name|bitmap
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|getenv_int
argument_list|(
literal|"isp_io_map"
argument_list|,
operator|&
name|bitmap
argument_list|)
condition|)
block|{
if|if
condition|(
name|bitmap
operator|&
operator|(
literal|1
operator|<<
name|unit
operator|)
condition|)
block|{
name|m1
operator|=
name|PCIM_CMD_PORTEN
expr_stmt|;
name|m2
operator|=
name|PCIM_CMD_MEMEN
expr_stmt|;
block|}
block|}
name|linesz
operator|=
name|PCI_DFLT_LNSZ
expr_stmt|;
name|irq
operator|=
name|regs
operator|=
name|NULL
expr_stmt|;
name|rgd
operator|=
name|rtp
operator|=
name|iqd
operator|=
literal|0
expr_stmt|;
name|cmd
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_COMMAND
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmd
operator|&
name|m1
condition|)
block|{
name|rtp
operator|=
operator|(
name|m1
operator|==
name|PCIM_CMD_MEMEN
operator|)
condition|?
name|SYS_RES_MEMORY
else|:
name|SYS_RES_IOPORT
expr_stmt|;
name|rgd
operator|=
operator|(
name|m1
operator|==
name|PCIM_CMD_MEMEN
operator|)
condition|?
name|MEM_MAP_REG
else|:
name|IO_MAP_REG
expr_stmt|;
name|regs
operator|=
name|bus_alloc_resource
argument_list|(
name|dev
argument_list|,
name|rtp
argument_list|,
operator|&
name|rgd
argument_list|,
literal|0
argument_list|,
operator|~
literal|0
argument_list|,
literal|1
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|regs
operator|==
name|NULL
operator|&&
operator|(
name|cmd
operator|&
name|m2
operator|)
condition|)
block|{
name|rtp
operator|=
operator|(
name|m2
operator|==
name|PCIM_CMD_MEMEN
operator|)
condition|?
name|SYS_RES_MEMORY
else|:
name|SYS_RES_IOPORT
expr_stmt|;
name|rgd
operator|=
operator|(
name|m2
operator|==
name|PCIM_CMD_MEMEN
operator|)
condition|?
name|MEM_MAP_REG
else|:
name|IO_MAP_REG
expr_stmt|;
name|regs
operator|=
name|bus_alloc_resource
argument_list|(
name|dev
argument_list|,
name|rtp
argument_list|,
operator|&
name|rgd
argument_list|,
literal|0
argument_list|,
operator|~
literal|0
argument_list|,
literal|1
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|regs
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"unable to map any ports\n"
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"isp%d: using %s space register mapping\n"
argument_list|,
name|unit
argument_list|,
operator|(
name|rgd
operator|==
name|IO_MAP_REG
operator|)
condition|?
literal|"I/O"
else|:
literal|"Memory"
argument_list|)
expr_stmt|;
name|pcs
operator|->
name|pci_dev
operator|=
name|dev
expr_stmt|;
name|pcs
operator|->
name|pci_reg
operator|=
name|regs
expr_stmt|;
name|pcs
operator|->
name|pci_st
operator|=
name|rman_get_bustag
argument_list|(
name|regs
argument_list|)
expr_stmt|;
name|pcs
operator|->
name|pci_sh
operator|=
name|rman_get_bushandle
argument_list|(
name|regs
argument_list|)
expr_stmt|;
name|pcs
operator|->
name|pci_poff
index|[
name|BIU_BLOCK
operator|>>
name|_BLK_REG_SHFT
index|]
operator|=
name|BIU_REGS_OFF
expr_stmt|;
name|pcs
operator|->
name|pci_poff
index|[
name|MBOX_BLOCK
operator|>>
name|_BLK_REG_SHFT
index|]
operator|=
name|PCI_MBOX_REGS_OFF
expr_stmt|;
name|pcs
operator|->
name|pci_poff
index|[
name|SXP_BLOCK
operator|>>
name|_BLK_REG_SHFT
index|]
operator|=
name|PCI_SXP_REGS_OFF
expr_stmt|;
name|pcs
operator|->
name|pci_poff
index|[
name|RISC_BLOCK
operator|>>
name|_BLK_REG_SHFT
index|]
operator|=
name|PCI_RISC_REGS_OFF
expr_stmt|;
name|pcs
operator|->
name|pci_poff
index|[
name|DMA_BLOCK
operator|>>
name|_BLK_REG_SHFT
index|]
operator|=
name|DMA_REGS_OFF
expr_stmt|;
name|mdvp
operator|=
operator|&
name|mdvec
expr_stmt|;
name|basetype
operator|=
name|ISP_HA_SCSI_UNKNOWN
expr_stmt|;
name|psize
operator|=
sizeof|sizeof
argument_list|(
name|sdparam
argument_list|)
expr_stmt|;
name|lim
operator|=
name|BUS_SPACE_MAXSIZE_32BIT
expr_stmt|;
if|if
condition|(
name|pci_get_devid
argument_list|(
name|dev
argument_list|)
operator|==
name|PCI_QLOGIC_ISP1020
condition|)
block|{
name|mdvp
operator|=
operator|&
name|mdvec
expr_stmt|;
name|basetype
operator|=
name|ISP_HA_SCSI_UNKNOWN
expr_stmt|;
name|psize
operator|=
sizeof|sizeof
argument_list|(
name|sdparam
argument_list|)
expr_stmt|;
name|lim
operator|=
name|BUS_SPACE_MAXSIZE_24BIT
expr_stmt|;
block|}
if|if
condition|(
name|pci_get_devid
argument_list|(
name|dev
argument_list|)
operator|==
name|PCI_QLOGIC_ISP1080
condition|)
block|{
name|mdvp
operator|=
operator|&
name|mdvec_1080
expr_stmt|;
name|basetype
operator|=
name|ISP_HA_SCSI_1080
expr_stmt|;
name|psize
operator|=
sizeof|sizeof
argument_list|(
name|sdparam
argument_list|)
expr_stmt|;
name|pcs
operator|->
name|pci_poff
index|[
name|DMA_BLOCK
operator|>>
name|_BLK_REG_SHFT
index|]
operator|=
name|ISP1080_DMA_REGS_OFF
expr_stmt|;
block|}
if|if
condition|(
name|pci_get_devid
argument_list|(
name|dev
argument_list|)
operator|==
name|PCI_QLOGIC_ISP1240
condition|)
block|{
name|mdvp
operator|=
operator|&
name|mdvec_1080
expr_stmt|;
name|basetype
operator|=
name|ISP_HA_SCSI_1240
expr_stmt|;
name|psize
operator|=
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|sdparam
argument_list|)
expr_stmt|;
name|pcs
operator|->
name|pci_poff
index|[
name|DMA_BLOCK
operator|>>
name|_BLK_REG_SHFT
index|]
operator|=
name|ISP1080_DMA_REGS_OFF
expr_stmt|;
block|}
if|if
condition|(
name|pci_get_devid
argument_list|(
name|dev
argument_list|)
operator|==
name|PCI_QLOGIC_ISP1280
condition|)
block|{
name|mdvp
operator|=
operator|&
name|mdvec_1080
expr_stmt|;
name|basetype
operator|=
name|ISP_HA_SCSI_1280
expr_stmt|;
name|psize
operator|=
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|sdparam
argument_list|)
expr_stmt|;
name|pcs
operator|->
name|pci_poff
index|[
name|DMA_BLOCK
operator|>>
name|_BLK_REG_SHFT
index|]
operator|=
name|ISP1080_DMA_REGS_OFF
expr_stmt|;
block|}
if|if
condition|(
name|pci_get_devid
argument_list|(
name|dev
argument_list|)
operator|==
name|PCI_QLOGIC_ISP12160
condition|)
block|{
name|mdvp
operator|=
operator|&
name|mdvec_12160
expr_stmt|;
name|basetype
operator|=
name|ISP_HA_SCSI_12160
expr_stmt|;
name|psize
operator|=
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|sdparam
argument_list|)
expr_stmt|;
name|pcs
operator|->
name|pci_poff
index|[
name|DMA_BLOCK
operator|>>
name|_BLK_REG_SHFT
index|]
operator|=
name|ISP1080_DMA_REGS_OFF
expr_stmt|;
block|}
if|if
condition|(
name|pci_get_devid
argument_list|(
name|dev
argument_list|)
operator|==
name|PCI_QLOGIC_ISP2100
condition|)
block|{
name|mdvp
operator|=
operator|&
name|mdvec_2100
expr_stmt|;
name|basetype
operator|=
name|ISP_HA_FC_2100
expr_stmt|;
name|psize
operator|=
sizeof|sizeof
argument_list|(
name|fcparam
argument_list|)
expr_stmt|;
name|pcs
operator|->
name|pci_poff
index|[
name|MBOX_BLOCK
operator|>>
name|_BLK_REG_SHFT
index|]
operator|=
name|PCI_MBOX_REGS2100_OFF
expr_stmt|;
if|if
condition|(
name|pci_get_revid
argument_list|(
name|dev
argument_list|)
operator|<
literal|3
condition|)
block|{
comment|/* 			 * XXX: Need to get the actual revision 			 * XXX: number of the 2100 FB. At any rate, 			 * XXX: lower cache line size for early revision 			 * XXX; boards. 			 */
name|linesz
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|pci_get_devid
argument_list|(
name|dev
argument_list|)
operator|==
name|PCI_QLOGIC_ISP2200
condition|)
block|{
name|mdvp
operator|=
operator|&
name|mdvec_2200
expr_stmt|;
name|basetype
operator|=
name|ISP_HA_FC_2200
expr_stmt|;
name|psize
operator|=
sizeof|sizeof
argument_list|(
name|fcparam
argument_list|)
expr_stmt|;
name|pcs
operator|->
name|pci_poff
index|[
name|MBOX_BLOCK
operator|>>
name|_BLK_REG_SHFT
index|]
operator|=
name|PCI_MBOX_REGS2100_OFF
expr_stmt|;
block|}
name|isp
operator|=
operator|&
name|pcs
operator|->
name|pci_isp
expr_stmt|;
name|isp
operator|->
name|isp_param
operator|=
name|malloc
argument_list|(
name|psize
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|isp
operator|->
name|isp_param
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"cannot allocate parameter data\n"
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|bzero
argument_list|(
name|isp
operator|->
name|isp_param
argument_list|,
name|psize
argument_list|)
expr_stmt|;
name|isp
operator|->
name|isp_mdvec
operator|=
name|mdvp
expr_stmt|;
name|isp
operator|->
name|isp_type
operator|=
name|basetype
expr_stmt|;
name|isp
operator|->
name|isp_revision
operator|=
name|pci_get_revid
argument_list|(
name|dev
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|isp
operator|->
name|isp_name
argument_list|,
sizeof|sizeof
argument_list|(
name|isp
operator|->
name|isp_name
argument_list|)
argument_list|,
literal|"isp%d"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|isp
operator|->
name|isp_osinfo
operator|.
name|unit
operator|=
name|unit
expr_stmt|;
comment|/* 	 * Try and find firmware for this device. 	 */
if|if
condition|(
name|isp_get_firmware_p
condition|)
block|{
name|int
name|device
init|=
operator|(
name|int
operator|)
name|pci_get_device
argument_list|(
name|dev
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|ISP_TARGET_MODE
call|(
modifier|*
name|isp_get_firmware_p
call|)
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|,
name|device
argument_list|,
operator|&
name|mdvp
operator|->
name|dv_ispfw
argument_list|)
expr_stmt|;
else|#
directive|else
call|(
modifier|*
name|isp_get_firmware_p
call|)
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|device
argument_list|,
operator|&
name|mdvp
operator|->
name|dv_ispfw
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* 	 * 	 */
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
comment|/* 	 * Make sure that SERR, PERR, WRITE INVALIDATE and BUSMASTER 	 * are set. 	 */
name|cmd
operator||=
name|PCIM_CMD_SEREN
operator||
name|PCIM_CMD_PERRESPEN
operator||
name|PCIM_CMD_BUSMASTEREN
operator||
name|PCIM_CMD_INVEN
expr_stmt|;
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|PCIR_COMMAND
argument_list|,
name|cmd
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* 	 * Make sure the Cache Line Size register is set sensibly. 	 */
name|data
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_CACHELNSZ
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|!=
name|linesz
condition|)
block|{
name|data
operator|=
name|PCI_DFLT_LNSZ
expr_stmt|;
name|isp_prt
argument_list|(
name|isp
argument_list|,
name|ISP_LOGCONFIG
argument_list|,
literal|"set PCI line size to %d"
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|PCIR_CACHELNSZ
argument_list|,
name|data
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Make sure the Latency Timer is sane. 	 */
name|data
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_LATTIMER
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|<
name|PCI_DFLT_LTNCY
condition|)
block|{
name|data
operator|=
name|PCI_DFLT_LTNCY
expr_stmt|;
name|isp_prt
argument_list|(
name|isp
argument_list|,
name|ISP_LOGCONFIG
argument_list|,
literal|"set PCI latency to %d"
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|PCIR_LATTIMER
argument_list|,
name|data
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Make sure we've disabled the ROM. 	 */
name|data
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_ROMADDR
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|data
operator|&=
operator|~
literal|1
expr_stmt|;
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|PCIR_ROMADDR
argument_list|,
name|data
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|bus_dma_tag_create
argument_list|(
name|NULL
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|BUS_SPACE_MAXADDR_32BIT
argument_list|,
name|BUS_SPACE_MAXADDR
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|lim
operator|+
literal|1
argument_list|,
literal|255
argument_list|,
name|lim
argument_list|,
literal|0
argument_list|,
operator|&
name|pcs
operator|->
name|parent_dmat
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s: could not create master dma tag\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|isp
operator|->
name|isp_param
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|pcs
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|iqd
operator|=
literal|0
expr_stmt|;
name|irq
operator|=
name|bus_alloc_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|iqd
argument_list|,
literal|0
argument_list|,
operator|~
literal|0
argument_list|,
literal|1
argument_list|,
name|RF_ACTIVE
operator||
name|RF_SHAREABLE
argument_list|)
expr_stmt|;
if|if
condition|(
name|irq
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"could not allocate interrupt\n"
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
if|if
condition|(
name|getenv_int
argument_list|(
literal|"isp_no_fwload"
argument_list|,
operator|&
name|bitmap
argument_list|)
condition|)
block|{
if|if
condition|(
name|bitmap
operator|&
operator|(
literal|1
operator|<<
name|unit
operator|)
condition|)
name|isp
operator|->
name|isp_confopts
operator||=
name|ISP_CFG_NORELOAD
expr_stmt|;
block|}
if|if
condition|(
name|getenv_int
argument_list|(
literal|"isp_fwload"
argument_list|,
operator|&
name|bitmap
argument_list|)
condition|)
block|{
if|if
condition|(
name|bitmap
operator|&
operator|(
literal|1
operator|<<
name|unit
operator|)
condition|)
name|isp
operator|->
name|isp_confopts
operator|&=
operator|~
name|ISP_CFG_NORELOAD
expr_stmt|;
block|}
if|if
condition|(
name|getenv_int
argument_list|(
literal|"isp_no_nvram"
argument_list|,
operator|&
name|bitmap
argument_list|)
condition|)
block|{
if|if
condition|(
name|bitmap
operator|&
operator|(
literal|1
operator|<<
name|unit
operator|)
condition|)
name|isp
operator|->
name|isp_confopts
operator||=
name|ISP_CFG_NONVRAM
expr_stmt|;
block|}
if|if
condition|(
name|getenv_int
argument_list|(
literal|"isp_nvram"
argument_list|,
operator|&
name|bitmap
argument_list|)
condition|)
block|{
if|if
condition|(
name|bitmap
operator|&
operator|(
literal|1
operator|<<
name|unit
operator|)
condition|)
name|isp
operator|->
name|isp_confopts
operator|&=
operator|~
name|ISP_CFG_NONVRAM
expr_stmt|;
block|}
if|if
condition|(
name|getenv_int
argument_list|(
literal|"isp_fcduplex"
argument_list|,
operator|&
name|bitmap
argument_list|)
condition|)
block|{
if|if
condition|(
name|bitmap
operator|&
operator|(
literal|1
operator|<<
name|unit
operator|)
condition|)
name|isp
operator|->
name|isp_confopts
operator||=
name|ISP_CFG_FULL_DUPLEX
expr_stmt|;
block|}
if|if
condition|(
name|getenv_int
argument_list|(
literal|"isp_no_fcduplex"
argument_list|,
operator|&
name|bitmap
argument_list|)
condition|)
block|{
if|if
condition|(
name|bitmap
operator|&
operator|(
literal|1
operator|<<
name|unit
operator|)
condition|)
name|isp
operator|->
name|isp_confopts
operator|&=
operator|~
name|ISP_CFG_FULL_DUPLEX
expr_stmt|;
block|}
if|if
condition|(
name|getenv_int
argument_list|(
literal|"isp_nport"
argument_list|,
operator|&
name|bitmap
argument_list|)
condition|)
block|{
if|if
condition|(
name|bitmap
operator|&
operator|(
literal|1
operator|<<
name|unit
operator|)
condition|)
name|isp
operator|->
name|isp_confopts
operator||=
name|ISP_CFG_NPORT
expr_stmt|;
block|}
comment|/* 	 * Look for overriding WWN. This is a Node WWN so it binds to 	 * all FC instances. A Port WWN will be constructed from it 	 * as appropriate. 	 */
if|if
condition|(
operator|!
name|getenv_quad
argument_list|(
literal|"isp_wwn"
argument_list|,
operator|(
name|quad_t
operator|*
operator|)
operator|&
name|isp
operator|->
name|isp_osinfo
operator|.
name|default_wwn
argument_list|)
condition|)
block|{
name|int
name|i
decl_stmt|;
name|u_int64_t
name|seed
init|=
operator|(
name|u_int64_t
operator|)
operator|(
name|intptr_t
operator|)
name|isp
decl_stmt|;
name|seed
operator|<<=
literal|16
expr_stmt|;
name|seed
operator|&=
operator|(
operator|(
literal|1LL
operator|<<
literal|48
operator|)
operator|-
literal|1LL
operator|)
expr_stmt|;
comment|/* 		 * This isn't very random, but it's the best we can do for 		 * the real edge case of cards that don't have WWNs. If 		 * you recompile a new vers.c, you'll get a different WWN. 		 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|version
index|[
name|i
index|]
operator|!=
literal|0
condition|;
name|i
operator|++
control|)
block|{
name|seed
operator|+=
name|version
index|[
name|i
index|]
expr_stmt|;
block|}
comment|/* 		 * Make sure the top nibble has something vaguely sensible 		 * (NAA == Locally Administered) 		 */
name|isp
operator|->
name|isp_osinfo
operator|.
name|default_wwn
operator||=
operator|(
literal|3LL
operator|<<
literal|60
operator|)
operator||
name|seed
expr_stmt|;
block|}
else|else
block|{
name|isp
operator|->
name|isp_confopts
operator||=
name|ISP_CFG_OWNWWN
expr_stmt|;
block|}
name|isp_debug
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|getenv_int
argument_list|(
literal|"isp_debug"
argument_list|,
operator|&
name|isp_debug
argument_list|)
expr_stmt|;
if|if
condition|(
name|bus_setup_intr
argument_list|(
name|dev
argument_list|,
name|irq
argument_list|,
name|INTR_TYPE_CAM
argument_list|,
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
name|void
operator|*
argument_list|)
operator|)
name|isp_intr
argument_list|,
name|isp
argument_list|,
operator|&
name|pcs
operator|->
name|ih
argument_list|)
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"could not setup interrupt\n"
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
comment|/* 	 * Set up logging levels. 	 */
if|if
condition|(
name|isp_debug
condition|)
block|{
name|isp
operator|->
name|isp_dblev
operator|=
name|isp_debug
expr_stmt|;
block|}
else|else
block|{
name|isp
operator|->
name|isp_dblev
operator|=
name|ISP_LOGWARN
operator||
name|ISP_LOGERR
expr_stmt|;
block|}
if|if
condition|(
name|bootverbose
condition|)
name|isp
operator|->
name|isp_dblev
operator||=
name|ISP_LOGCONFIG
expr_stmt|;
comment|/* 	 * Make sure we're in reset state. 	 */
name|isp_reset
argument_list|(
name|isp
argument_list|)
expr_stmt|;
if|if
condition|(
name|isp
operator|->
name|isp_state
operator|!=
name|ISP_RESETSTATE
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|isp_init
argument_list|(
name|isp
argument_list|)
expr_stmt|;
if|if
condition|(
name|isp
operator|->
name|isp_state
operator|!=
name|ISP_INITSTATE
condition|)
block|{
comment|/* If we're a Fibre Channel Card, we allow deferred attach */
if|if
condition|(
name|IS_SCSI
argument_list|(
name|isp
argument_list|)
condition|)
block|{
name|isp_uninit
argument_list|(
name|isp
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
block|}
name|isp_attach
argument_list|(
name|isp
argument_list|)
expr_stmt|;
if|if
condition|(
name|isp
operator|->
name|isp_state
operator|!=
name|ISP_RUNSTATE
condition|)
block|{
comment|/* If we're a Fibre Channel Card, we allow deferred attach */
if|if
condition|(
name|IS_SCSI
argument_list|(
name|isp
argument_list|)
condition|)
block|{
name|isp_uninit
argument_list|(
name|isp
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* 	 * XXXX: Here is where we might unload the f/w module 	 * XXXX: (or decrease the reference count to it). 	 */
return|return
operator|(
literal|0
operator|)
return|;
name|bad
label|:
if|if
condition|(
name|pcs
operator|&&
name|pcs
operator|->
name|ih
condition|)
block|{
operator|(
name|void
operator|)
name|bus_teardown_intr
argument_list|(
name|dev
argument_list|,
name|irq
argument_list|,
name|pcs
operator|->
name|ih
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|irq
condition|)
block|{
operator|(
name|void
operator|)
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|iqd
argument_list|,
name|irq
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|regs
condition|)
block|{
operator|(
name|void
operator|)
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|rtp
argument_list|,
name|rgd
argument_list|,
name|regs
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pcs
condition|)
block|{
if|if
condition|(
name|pcs
operator|->
name|pci_isp
operator|.
name|isp_param
condition|)
name|free
argument_list|(
name|pcs
operator|->
name|pci_isp
operator|.
name|isp_param
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|pcs
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * XXXX: Here is where we might unload the f/w module 	 * XXXX: (or decrease the reference count to it). 	 */
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|u_int16_t
name|isp_pci_rd_reg
parameter_list|(
name|isp
parameter_list|,
name|regoff
parameter_list|)
name|struct
name|ispsoftc
modifier|*
name|isp
decl_stmt|;
name|int
name|regoff
decl_stmt|;
block|{
name|u_int16_t
name|rv
decl_stmt|;
name|struct
name|isp_pcisoftc
modifier|*
name|pcs
init|=
operator|(
expr|struct
name|isp_pcisoftc
operator|*
operator|)
name|isp
decl_stmt|;
name|int
name|offset
decl_stmt|,
name|oldconf
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|(
name|regoff
operator|&
name|_BLK_REG_MASK
operator|)
operator|==
name|SXP_BLOCK
condition|)
block|{
comment|/* 		 * We will assume that someone has paused the RISC processor. 		 */
name|oldconf
operator|=
name|isp_pci_rd_reg
argument_list|(
name|isp
argument_list|,
name|BIU_CONF1
argument_list|)
expr_stmt|;
name|isp_pci_wr_reg
argument_list|(
name|isp
argument_list|,
name|BIU_CONF1
argument_list|,
name|oldconf
operator||
name|BIU_PCI_CONF1_SXP
argument_list|)
expr_stmt|;
block|}
name|offset
operator|=
name|pcs
operator|->
name|pci_poff
index|[
operator|(
name|regoff
operator|&
name|_BLK_REG_MASK
operator|)
operator|>>
name|_BLK_REG_SHFT
index|]
expr_stmt|;
name|offset
operator|+=
operator|(
name|regoff
operator|&
literal|0xff
operator|)
expr_stmt|;
name|rv
operator|=
name|bus_space_read_2
argument_list|(
name|pcs
operator|->
name|pci_st
argument_list|,
name|pcs
operator|->
name|pci_sh
argument_list|,
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|regoff
operator|&
name|_BLK_REG_MASK
operator|)
operator|==
name|SXP_BLOCK
condition|)
block|{
name|isp_pci_wr_reg
argument_list|(
name|isp
argument_list|,
name|BIU_CONF1
argument_list|,
name|oldconf
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|rv
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|isp_pci_wr_reg
parameter_list|(
name|isp
parameter_list|,
name|regoff
parameter_list|,
name|val
parameter_list|)
name|struct
name|ispsoftc
modifier|*
name|isp
decl_stmt|;
name|int
name|regoff
decl_stmt|;
name|u_int16_t
name|val
decl_stmt|;
block|{
name|struct
name|isp_pcisoftc
modifier|*
name|pcs
init|=
operator|(
expr|struct
name|isp_pcisoftc
operator|*
operator|)
name|isp
decl_stmt|;
name|int
name|offset
decl_stmt|,
name|oldconf
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|(
name|regoff
operator|&
name|_BLK_REG_MASK
operator|)
operator|==
name|SXP_BLOCK
condition|)
block|{
comment|/* 		 * We will assume that someone has paused the RISC processor. 		 */
name|oldconf
operator|=
name|isp_pci_rd_reg
argument_list|(
name|isp
argument_list|,
name|BIU_CONF1
argument_list|)
expr_stmt|;
name|isp_pci_wr_reg
argument_list|(
name|isp
argument_list|,
name|BIU_CONF1
argument_list|,
name|oldconf
operator||
name|BIU_PCI_CONF1_SXP
argument_list|)
expr_stmt|;
block|}
name|offset
operator|=
name|pcs
operator|->
name|pci_poff
index|[
operator|(
name|regoff
operator|&
name|_BLK_REG_MASK
operator|)
operator|>>
name|_BLK_REG_SHFT
index|]
expr_stmt|;
name|offset
operator|+=
operator|(
name|regoff
operator|&
literal|0xff
operator|)
expr_stmt|;
name|bus_space_write_2
argument_list|(
name|pcs
operator|->
name|pci_st
argument_list|,
name|pcs
operator|->
name|pci_sh
argument_list|,
name|offset
argument_list|,
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|regoff
operator|&
name|_BLK_REG_MASK
operator|)
operator|==
name|SXP_BLOCK
condition|)
block|{
name|isp_pci_wr_reg
argument_list|(
name|isp
argument_list|,
name|BIU_CONF1
argument_list|,
name|oldconf
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|u_int16_t
name|isp_pci_rd_reg_1080
parameter_list|(
name|isp
parameter_list|,
name|regoff
parameter_list|)
name|struct
name|ispsoftc
modifier|*
name|isp
decl_stmt|;
name|int
name|regoff
decl_stmt|;
block|{
name|u_int16_t
name|rv
decl_stmt|,
name|oc
init|=
literal|0
decl_stmt|;
name|struct
name|isp_pcisoftc
modifier|*
name|pcs
init|=
operator|(
expr|struct
name|isp_pcisoftc
operator|*
operator|)
name|isp
decl_stmt|;
name|int
name|offset
decl_stmt|;
if|if
condition|(
operator|(
name|regoff
operator|&
name|_BLK_REG_MASK
operator|)
operator|==
name|SXP_BLOCK
operator|||
operator|(
name|regoff
operator|&
name|_BLK_REG_MASK
operator|)
operator|==
operator|(
name|SXP_BLOCK
operator||
name|SXP_BANK1_SELECT
operator|)
condition|)
block|{
name|u_int16_t
name|tc
decl_stmt|;
comment|/* 		 * We will assume that someone has paused the RISC processor. 		 */
name|oc
operator|=
name|isp_pci_rd_reg
argument_list|(
name|isp
argument_list|,
name|BIU_CONF1
argument_list|)
expr_stmt|;
name|tc
operator|=
name|oc
operator|&
operator|~
name|BIU_PCI1080_CONF1_DMA
expr_stmt|;
if|if
condition|(
name|regoff
operator|&
name|SXP_BANK1_SELECT
condition|)
name|tc
operator||=
name|BIU_PCI1080_CONF1_SXP1
expr_stmt|;
else|else
name|tc
operator||=
name|BIU_PCI1080_CONF1_SXP0
expr_stmt|;
name|isp_pci_wr_reg
argument_list|(
name|isp
argument_list|,
name|BIU_CONF1
argument_list|,
name|tc
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|regoff
operator|&
name|_BLK_REG_MASK
operator|)
operator|==
name|DMA_BLOCK
condition|)
block|{
name|oc
operator|=
name|isp_pci_rd_reg
argument_list|(
name|isp
argument_list|,
name|BIU_CONF1
argument_list|)
expr_stmt|;
name|isp_pci_wr_reg
argument_list|(
name|isp
argument_list|,
name|BIU_CONF1
argument_list|,
name|oc
operator||
name|BIU_PCI1080_CONF1_DMA
argument_list|)
expr_stmt|;
block|}
name|offset
operator|=
name|pcs
operator|->
name|pci_poff
index|[
operator|(
name|regoff
operator|&
name|_BLK_REG_MASK
operator|)
operator|>>
name|_BLK_REG_SHFT
index|]
expr_stmt|;
name|offset
operator|+=
operator|(
name|regoff
operator|&
literal|0xff
operator|)
expr_stmt|;
name|rv
operator|=
name|bus_space_read_2
argument_list|(
name|pcs
operator|->
name|pci_st
argument_list|,
name|pcs
operator|->
name|pci_sh
argument_list|,
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|oc
condition|)
block|{
name|isp_pci_wr_reg
argument_list|(
name|isp
argument_list|,
name|BIU_CONF1
argument_list|,
name|oc
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|rv
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|isp_pci_wr_reg_1080
parameter_list|(
name|isp
parameter_list|,
name|regoff
parameter_list|,
name|val
parameter_list|)
name|struct
name|ispsoftc
modifier|*
name|isp
decl_stmt|;
name|int
name|regoff
decl_stmt|;
name|u_int16_t
name|val
decl_stmt|;
block|{
name|struct
name|isp_pcisoftc
modifier|*
name|pcs
init|=
operator|(
expr|struct
name|isp_pcisoftc
operator|*
operator|)
name|isp
decl_stmt|;
name|int
name|offset
decl_stmt|,
name|oc
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|(
name|regoff
operator|&
name|_BLK_REG_MASK
operator|)
operator|==
name|SXP_BLOCK
operator|||
operator|(
name|regoff
operator|&
name|_BLK_REG_MASK
operator|)
operator|==
operator|(
name|SXP_BLOCK
operator||
name|SXP_BANK1_SELECT
operator|)
condition|)
block|{
name|u_int16_t
name|tc
decl_stmt|;
comment|/* 		 * We will assume that someone has paused the RISC processor. 		 */
name|oc
operator|=
name|isp_pci_rd_reg
argument_list|(
name|isp
argument_list|,
name|BIU_CONF1
argument_list|)
expr_stmt|;
name|tc
operator|=
name|oc
operator|&
operator|~
name|BIU_PCI1080_CONF1_DMA
expr_stmt|;
if|if
condition|(
name|regoff
operator|&
name|SXP_BANK1_SELECT
condition|)
name|tc
operator||=
name|BIU_PCI1080_CONF1_SXP1
expr_stmt|;
else|else
name|tc
operator||=
name|BIU_PCI1080_CONF1_SXP0
expr_stmt|;
name|isp_pci_wr_reg
argument_list|(
name|isp
argument_list|,
name|BIU_CONF1
argument_list|,
name|tc
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|regoff
operator|&
name|_BLK_REG_MASK
operator|)
operator|==
name|DMA_BLOCK
condition|)
block|{
name|oc
operator|=
name|isp_pci_rd_reg
argument_list|(
name|isp
argument_list|,
name|BIU_CONF1
argument_list|)
expr_stmt|;
name|isp_pci_wr_reg
argument_list|(
name|isp
argument_list|,
name|BIU_CONF1
argument_list|,
name|oc
operator||
name|BIU_PCI1080_CONF1_DMA
argument_list|)
expr_stmt|;
block|}
name|offset
operator|=
name|pcs
operator|->
name|pci_poff
index|[
operator|(
name|regoff
operator|&
name|_BLK_REG_MASK
operator|)
operator|>>
name|_BLK_REG_SHFT
index|]
expr_stmt|;
name|offset
operator|+=
operator|(
name|regoff
operator|&
literal|0xff
operator|)
expr_stmt|;
name|bus_space_write_2
argument_list|(
name|pcs
operator|->
name|pci_st
argument_list|,
name|pcs
operator|->
name|pci_sh
argument_list|,
name|offset
argument_list|,
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|oc
condition|)
block|{
name|isp_pci_wr_reg
argument_list|(
name|isp
argument_list|,
name|BIU_CONF1
argument_list|,
name|oc
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_decl_stmt
specifier|static
name|void
name|isp_map_rquest
name|__P
argument_list|(
operator|(
name|void
operator|*
operator|,
name|bus_dma_segment_t
operator|*
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|isp_map_result
name|__P
argument_list|(
operator|(
name|void
operator|*
operator|,
name|bus_dma_segment_t
operator|*
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|isp_map_fcscrt
name|__P
argument_list|(
operator|(
name|void
operator|*
operator|,
name|bus_dma_segment_t
operator|*
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|imush
block|{
name|struct
name|ispsoftc
modifier|*
name|isp
decl_stmt|;
name|int
name|error
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|void
name|isp_map_rquest
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
name|nseg
parameter_list|,
name|int
name|error
parameter_list|)
block|{
name|struct
name|imush
modifier|*
name|imushp
init|=
operator|(
expr|struct
name|imush
operator|*
operator|)
name|arg
decl_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|imushp
operator|->
name|error
operator|=
name|error
expr_stmt|;
block|}
else|else
block|{
name|imushp
operator|->
name|isp
operator|->
name|isp_rquest_dma
operator|=
name|segs
operator|->
name|ds_addr
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|isp_map_result
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
name|nseg
parameter_list|,
name|int
name|error
parameter_list|)
block|{
name|struct
name|imush
modifier|*
name|imushp
init|=
operator|(
expr|struct
name|imush
operator|*
operator|)
name|arg
decl_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|imushp
operator|->
name|error
operator|=
name|error
expr_stmt|;
block|}
else|else
block|{
name|imushp
operator|->
name|isp
operator|->
name|isp_result_dma
operator|=
name|segs
operator|->
name|ds_addr
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|isp_map_fcscrt
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
name|nseg
parameter_list|,
name|int
name|error
parameter_list|)
block|{
name|struct
name|imush
modifier|*
name|imushp
init|=
operator|(
expr|struct
name|imush
operator|*
operator|)
name|arg
decl_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|imushp
operator|->
name|error
operator|=
name|error
expr_stmt|;
block|}
else|else
block|{
name|fcparam
modifier|*
name|fcp
init|=
name|imushp
operator|->
name|isp
operator|->
name|isp_param
decl_stmt|;
name|fcp
operator|->
name|isp_scdma
operator|=
name|segs
operator|->
name|ds_addr
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|isp_pci_mbxdma
parameter_list|(
name|struct
name|ispsoftc
modifier|*
name|isp
parameter_list|)
block|{
name|struct
name|isp_pcisoftc
modifier|*
name|pci
init|=
operator|(
expr|struct
name|isp_pcisoftc
operator|*
operator|)
name|isp
decl_stmt|;
name|caddr_t
name|base
decl_stmt|;
name|u_int32_t
name|len
decl_stmt|;
name|int
name|i
decl_stmt|,
name|error
decl_stmt|;
name|bus_size_t
name|lim
decl_stmt|;
name|struct
name|imush
name|im
decl_stmt|;
comment|/* 	 * Already been here? If so, leave... 	 */
if|if
condition|(
name|isp
operator|->
name|isp_rquest
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|len
operator|=
sizeof|sizeof
argument_list|(
name|XS_T
operator|*
operator|*
argument_list|)
operator|*
name|isp
operator|->
name|isp_maxcmds
expr_stmt|;
name|isp
operator|->
name|isp_xflist
operator|=
operator|(
name|XS_T
operator|*
operator|*
operator|)
name|malloc
argument_list|(
name|len
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
name|isp
operator|->
name|isp_xflist
operator|==
name|NULL
condition|)
block|{
name|isp_prt
argument_list|(
name|isp
argument_list|,
name|ISP_LOGERR
argument_list|,
literal|"cannot alloc xflist array"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|bzero
argument_list|(
name|isp
operator|->
name|isp_xflist
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|len
operator|=
sizeof|sizeof
argument_list|(
name|bus_dmamap_t
argument_list|)
operator|*
name|isp
operator|->
name|isp_maxcmds
expr_stmt|;
name|pci
operator|->
name|dmaps
operator|=
operator|(
name|bus_dmamap_t
operator|*
operator|)
name|malloc
argument_list|(
name|len
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
name|pci
operator|->
name|dmaps
operator|==
name|NULL
condition|)
block|{
name|isp_prt
argument_list|(
name|isp
argument_list|,
name|ISP_LOGERR
argument_list|,
literal|"can't alloc dma maps"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|isp
operator|->
name|isp_xflist
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|IS_FC
argument_list|(
name|isp
argument_list|)
operator|||
name|IS_ULTRA2
argument_list|(
name|isp
argument_list|)
condition|)
name|lim
operator|=
name|BUS_SPACE_MAXADDR
operator|+
literal|1
expr_stmt|;
else|else
name|lim
operator|=
name|BUS_SPACE_MAXADDR_24BIT
operator|+
literal|1
expr_stmt|;
comment|/* 	 * Allocate and map the request, result queues, plus FC scratch area. 	 */
name|len
operator|=
name|ISP_QUEUE_SIZE
argument_list|(
name|RQUEST_QUEUE_LEN
argument_list|(
name|isp
argument_list|)
argument_list|)
expr_stmt|;
name|len
operator|+=
name|ISP_QUEUE_SIZE
argument_list|(
name|RESULT_QUEUE_LEN
argument_list|(
name|isp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_FC
argument_list|(
name|isp
argument_list|)
condition|)
block|{
name|len
operator|+=
name|ISP2100_SCRLEN
expr_stmt|;
block|}
if|if
condition|(
name|bus_dma_tag_create
argument_list|(
name|pci
operator|->
name|parent_dmat
argument_list|,
name|PAGE_SIZE
argument_list|,
name|lim
argument_list|,
name|BUS_SPACE_MAXADDR
argument_list|,
name|BUS_SPACE_MAXADDR
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|len
argument_list|,
literal|1
argument_list|,
name|BUS_SPACE_MAXSIZE_32BIT
argument_list|,
literal|0
argument_list|,
operator|&
name|pci
operator|->
name|cntrol_dmat
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%s: cannot create a dma tag for control spaces\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|isp
operator|->
name|isp_xflist
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|pci
operator|->
name|dmaps
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|bus_dmamem_alloc
argument_list|(
name|pci
operator|->
name|cntrol_dmat
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|base
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|,
operator|&
name|pci
operator|->
name|cntrol_dmap
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%s: cannot allocate %d bytes of CCB memory\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|isp
operator|->
name|isp_xflist
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|pci
operator|->
name|dmaps
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|isp
operator|->
name|isp_rquest
operator|=
name|base
expr_stmt|;
name|im
operator|.
name|isp
operator|=
name|isp
expr_stmt|;
name|im
operator|.
name|error
operator|=
literal|0
expr_stmt|;
name|bus_dmamap_load
argument_list|(
name|pci
operator|->
name|cntrol_dmat
argument_list|,
name|pci
operator|->
name|cntrol_dmap
argument_list|,
name|isp
operator|->
name|isp_rquest
argument_list|,
name|ISP_QUEUE_SIZE
argument_list|(
name|RQUEST_QUEUE_LEN
argument_list|(
name|isp
argument_list|)
argument_list|)
argument_list|,
name|isp_map_rquest
argument_list|,
operator|&
name|im
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|im
operator|.
name|error
condition|)
block|{
name|printf
argument_list|(
literal|"%s: error %d loading dma map for DMA request queue\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|im
operator|.
name|error
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|isp
operator|->
name|isp_xflist
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|pci
operator|->
name|dmaps
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|isp
operator|->
name|isp_rquest
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|isp
operator|->
name|isp_result
operator|=
name|base
operator|+
name|ISP_QUEUE_SIZE
argument_list|(
name|RQUEST_QUEUE_LEN
argument_list|(
name|isp
argument_list|)
argument_list|)
expr_stmt|;
name|im
operator|.
name|error
operator|=
literal|0
expr_stmt|;
name|bus_dmamap_load
argument_list|(
name|pci
operator|->
name|cntrol_dmat
argument_list|,
name|pci
operator|->
name|cntrol_dmap
argument_list|,
name|isp
operator|->
name|isp_result
argument_list|,
name|ISP_QUEUE_SIZE
argument_list|(
name|RESULT_QUEUE_LEN
argument_list|(
name|isp
argument_list|)
argument_list|)
argument_list|,
name|isp_map_result
argument_list|,
operator|&
name|im
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|im
operator|.
name|error
condition|)
block|{
name|printf
argument_list|(
literal|"%s: error %d loading dma map for DMA result queue\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|im
operator|.
name|error
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|isp
operator|->
name|isp_xflist
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|pci
operator|->
name|dmaps
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|isp
operator|->
name|isp_rquest
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|isp
operator|->
name|isp_maxcmds
condition|;
name|i
operator|++
control|)
block|{
name|error
operator|=
name|bus_dmamap_create
argument_list|(
name|pci
operator|->
name|parent_dmat
argument_list|,
literal|0
argument_list|,
operator|&
name|pci
operator|->
name|dmaps
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|printf
argument_list|(
literal|"%s: error %d creating per-cmd DMA maps\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|isp
operator|->
name|isp_xflist
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|pci
operator|->
name|dmaps
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|isp
operator|->
name|isp_rquest
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
if|if
condition|(
name|IS_FC
argument_list|(
name|isp
argument_list|)
condition|)
block|{
name|fcparam
modifier|*
name|fcp
init|=
operator|(
name|fcparam
operator|*
operator|)
name|isp
operator|->
name|isp_param
decl_stmt|;
name|fcp
operator|->
name|isp_scratch
operator|=
name|base
operator|+
name|ISP_QUEUE_SIZE
argument_list|(
name|RQUEST_QUEUE_LEN
argument_list|(
name|isp
argument_list|)
argument_list|)
operator|+
name|ISP_QUEUE_SIZE
argument_list|(
name|RESULT_QUEUE_LEN
argument_list|(
name|isp
argument_list|)
argument_list|)
expr_stmt|;
name|im
operator|.
name|error
operator|=
literal|0
expr_stmt|;
name|bus_dmamap_load
argument_list|(
name|pci
operator|->
name|cntrol_dmat
argument_list|,
name|pci
operator|->
name|cntrol_dmap
argument_list|,
name|fcp
operator|->
name|isp_scratch
argument_list|,
name|ISP2100_SCRLEN
argument_list|,
name|isp_map_fcscrt
argument_list|,
operator|&
name|im
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|im
operator|.
name|error
condition|)
block|{
name|printf
argument_list|(
literal|"%s: error %d loading FC scratch area\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|im
operator|.
name|error
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|isp
operator|->
name|isp_xflist
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|pci
operator|->
name|dmaps
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|isp
operator|->
name|isp_rquest
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_typedef
typedef|typedef
struct|struct
block|{
name|struct
name|ispsoftc
modifier|*
name|isp
decl_stmt|;
name|void
modifier|*
name|cmd_token
decl_stmt|;
name|void
modifier|*
name|rq
decl_stmt|;
name|u_int16_t
modifier|*
name|iptrp
decl_stmt|;
name|u_int16_t
name|optr
decl_stmt|;
name|u_int
name|error
decl_stmt|;
block|}
name|mush_t
typedef|;
end_typedef

begin_define
define|#
directive|define
name|MUSHERR_NOQENTRIES
value|-2
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|ISP_TARGET_MODE
end_ifdef

begin_comment
comment|/*  * We need to handle DMA for target mode differently from initiator mode.  *   * DMA mapping and construction and submission of CTIO Request Entries  * and rendevous for completion are very tightly coupled because we start  * out by knowing (per platform) how much data we have to move, but we  * don't know, up front, how many DMA mapping segments will have to be used  * cover that data, so we don't know how many CTIO Request Entries we  * will end up using. Further, for performance reasons we may want to  * (on the last CTIO for Fibre Channel), send status too (if all went well).  *  * The standard vector still goes through isp_pci_dmasetup, but the callback  * for the DMA mapping routines comes here instead with the whole transfer  * mapped and a pointer to a partially filled in already allocated request  * queue entry. We finish the job.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|tdma_mk
name|__P
argument_list|(
operator|(
name|void
operator|*
operator|,
name|bus_dma_segment_t
operator|*
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|tdma_mkfc
name|__P
argument_list|(
operator|(
name|void
operator|*
operator|,
name|bus_dma_segment_t
operator|*
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|tdma_mk
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|dm_segs
parameter_list|,
name|int
name|nseg
parameter_list|,
name|int
name|error
parameter_list|)
block|{
name|mush_t
modifier|*
name|mp
decl_stmt|;
name|struct
name|ccb_scsiio
modifier|*
name|csio
decl_stmt|;
name|struct
name|isp_pcisoftc
modifier|*
name|pci
decl_stmt|;
name|bus_dmamap_t
modifier|*
name|dp
decl_stmt|;
name|u_int8_t
name|scsi_status
decl_stmt|;
name|ct_entry_t
modifier|*
name|cto
decl_stmt|;
name|u_int32_t
name|handle
decl_stmt|,
name|totxfr
decl_stmt|,
name|sflags
decl_stmt|;
name|int
name|nctios
decl_stmt|,
name|send_status
decl_stmt|;
name|int32_t
name|resid
decl_stmt|;
name|mp
operator|=
operator|(
name|mush_t
operator|*
operator|)
name|arg
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|mp
operator|->
name|error
operator|=
name|error
expr_stmt|;
return|return;
block|}
name|csio
operator|=
name|mp
operator|->
name|cmd_token
expr_stmt|;
name|cto
operator|=
name|mp
operator|->
name|rq
expr_stmt|;
name|cto
operator|->
name|ct_xfrlen
operator|=
literal|0
expr_stmt|;
name|cto
operator|->
name|ct_seg_count
operator|=
literal|0
expr_stmt|;
name|cto
operator|->
name|ct_header
operator|.
name|rqs_entry_count
operator|=
literal|1
expr_stmt|;
name|MEMZERO
argument_list|(
name|cto
operator|->
name|ct_dataseg
argument_list|,
sizeof|sizeof
argument_list|(
name|cto
operator|->
name|ct_dataseg
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|nseg
operator|==
literal|0
condition|)
block|{
name|cto
operator|->
name|ct_header
operator|.
name|rqs_seqno
operator|=
literal|1
expr_stmt|;
name|ISP_TDQE
argument_list|(
name|mp
operator|->
name|isp
argument_list|,
literal|"tdma_mk[no data]"
argument_list|,
operator|*
name|mp
operator|->
name|iptrp
argument_list|,
name|cto
argument_list|)
expr_stmt|;
name|isp_prt
argument_list|(
name|mp
operator|->
name|isp
argument_list|,
name|ISP_LOGTDEBUG1
argument_list|,
literal|"CTIO lun %d->iid%d flgs 0x%x sts 0x%x ssts 0x%x res %d"
argument_list|,
name|csio
operator|->
name|ccb_h
operator|.
name|target_lun
argument_list|,
name|cto
operator|->
name|ct_iid
argument_list|,
name|cto
operator|->
name|ct_flags
argument_list|,
name|cto
operator|->
name|ct_status
argument_list|,
name|cto
operator|->
name|ct_scsi_status
argument_list|,
name|cto
operator|->
name|ct_resid
argument_list|)
expr_stmt|;
name|ISP_SWIZ_CTIO
argument_list|(
name|mp
operator|->
name|isp
argument_list|,
name|cto
argument_list|,
name|cto
argument_list|)
expr_stmt|;
return|return;
block|}
name|nctios
operator|=
name|nseg
operator|/
name|ISP_RQDSEG
expr_stmt|;
if|if
condition|(
name|nseg
operator|%
name|ISP_RQDSEG
condition|)
block|{
name|nctios
operator|++
expr_stmt|;
block|}
comment|/* 	 * Save handle, and potentially any SCSI status, which we'll reinsert 	 * on the last CTIO we're going to send. 	 */
name|handle
operator|=
name|cto
operator|->
name|ct_reserved
expr_stmt|;
name|cto
operator|->
name|ct_reserved
operator|=
literal|0
expr_stmt|;
name|cto
operator|->
name|ct_header
operator|.
name|rqs_seqno
operator|=
literal|0
expr_stmt|;
name|send_status
operator|=
operator|(
name|cto
operator|->
name|ct_flags
operator|&
name|CT_SENDSTATUS
operator|)
operator|!=
literal|0
expr_stmt|;
if|if
condition|(
name|send_status
condition|)
block|{
name|sflags
operator|=
name|cto
operator|->
name|ct_flags
operator|&
operator|(
name|CT_SENDSTATUS
operator||
name|CT_CCINCR
operator|)
expr_stmt|;
name|cto
operator|->
name|ct_flags
operator|&=
operator|~
operator|(
name|CT_SENDSTATUS
operator||
name|CT_CCINCR
operator|)
expr_stmt|;
comment|/* 		 * Preserve residual. 		 */
name|resid
operator|=
name|cto
operator|->
name|ct_resid
expr_stmt|;
comment|/* 		 * Save actual SCSI status. 		 */
name|scsi_status
operator|=
name|cto
operator|->
name|ct_scsi_status
expr_stmt|;
comment|/* 		 * We can't do a status at the same time as a data CTIO, so 		 * we need to synthesize an extra CTIO at this level. 		 */
name|nctios
operator|++
expr_stmt|;
block|}
else|else
block|{
name|sflags
operator|=
name|scsi_status
operator|=
name|resid
operator|=
literal|0
expr_stmt|;
block|}
name|totxfr
operator|=
name|cto
operator|->
name|ct_resid
operator|=
literal|0
expr_stmt|;
name|cto
operator|->
name|ct_scsi_status
operator|=
literal|0
expr_stmt|;
name|pci
operator|=
operator|(
expr|struct
name|isp_pcisoftc
operator|*
operator|)
name|mp
operator|->
name|isp
expr_stmt|;
name|dp
operator|=
operator|&
name|pci
operator|->
name|dmaps
index|[
name|isp_handle_index
argument_list|(
name|handle
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|csio
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DIR_MASK
operator|)
operator|==
name|CAM_DIR_IN
condition|)
block|{
name|bus_dmamap_sync
argument_list|(
name|pci
operator|->
name|parent_dmat
argument_list|,
operator|*
name|dp
argument_list|,
name|BUS_DMASYNC_PREREAD
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bus_dmamap_sync
argument_list|(
name|pci
operator|->
name|parent_dmat
argument_list|,
operator|*
name|dp
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|nctios
operator|--
condition|)
block|{
name|int
name|seglim
decl_stmt|;
name|seglim
operator|=
name|nseg
expr_stmt|;
if|if
condition|(
name|seglim
condition|)
block|{
name|int
name|seg
decl_stmt|;
if|if
condition|(
name|seglim
operator|>
name|ISP_RQDSEG
condition|)
name|seglim
operator|=
name|ISP_RQDSEG
expr_stmt|;
for|for
control|(
name|seg
operator|=
literal|0
init|;
name|seg
operator|<
name|seglim
condition|;
name|seg
operator|++
operator|,
name|nseg
operator|--
control|)
block|{
comment|/* 				 * Unlike normal initiator commands, we don't 				 * do any swizzling here. 				 */
name|cto
operator|->
name|ct_dataseg
index|[
name|seg
index|]
operator|.
name|ds_count
operator|=
name|dm_segs
operator|->
name|ds_len
expr_stmt|;
name|cto
operator|->
name|ct_dataseg
index|[
name|seg
index|]
operator|.
name|ds_base
operator|=
name|dm_segs
operator|->
name|ds_addr
expr_stmt|;
name|cto
operator|->
name|ct_xfrlen
operator|+=
name|dm_segs
operator|->
name|ds_len
expr_stmt|;
name|totxfr
operator|+=
name|dm_segs
operator|->
name|ds_len
expr_stmt|;
name|dm_segs
operator|++
expr_stmt|;
block|}
name|cto
operator|->
name|ct_seg_count
operator|=
name|seg
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * This case should only happen when we're sending an 			 * extra CTIO with final status. 			 */
if|if
condition|(
name|send_status
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%s: tdma_mk ran out of segments\n"
argument_list|,
name|mp
operator|->
name|isp
operator|->
name|isp_name
argument_list|)
expr_stmt|;
name|mp
operator|->
name|error
operator|=
name|EINVAL
expr_stmt|;
return|return;
block|}
block|}
comment|/* 		 * At this point, the fields ct_lun, ct_iid, ct_tagval, 		 * ct_tagtype, and ct_timeout have been carried over 		 * unchanged from what our caller had set. 		 *  		 * The dataseg fields and the seg_count fields we just got 		 * through setting. The data direction we've preserved all 		 * along and only clear it if we're now sending status. 		 */
if|if
condition|(
name|nctios
operator|==
literal|0
condition|)
block|{
comment|/* 			 * We're the last in a sequence of CTIOs, so mark 			 * this CTIO and save the handle to the CCB such that 			 * when this CTIO completes we can free dma resources 			 * and do whatever else we need to do to finish the 			 * rest of the command. 			 */
name|cto
operator|->
name|ct_reserved
operator|=
name|handle
expr_stmt|;
name|cto
operator|->
name|ct_header
operator|.
name|rqs_seqno
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|send_status
condition|)
block|{
name|cto
operator|->
name|ct_scsi_status
operator|=
name|scsi_status
expr_stmt|;
name|cto
operator|->
name|ct_flags
operator||=
name|sflags
operator||
name|CT_NO_DATA
expr_stmt|;
empty_stmt|;
name|cto
operator|->
name|ct_resid
operator|=
name|resid
expr_stmt|;
block|}
if|if
condition|(
name|send_status
condition|)
block|{
name|isp_prt
argument_list|(
name|mp
operator|->
name|isp
argument_list|,
name|ISP_LOGTDEBUG1
argument_list|,
literal|"CTIO lun%d for ID %d ct_flags 0x%x scsi "
literal|"status %x resid %d"
argument_list|,
name|csio
operator|->
name|ccb_h
operator|.
name|target_lun
argument_list|,
name|cto
operator|->
name|ct_iid
argument_list|,
name|cto
operator|->
name|ct_flags
argument_list|,
name|cto
operator|->
name|ct_scsi_status
argument_list|,
name|cto
operator|->
name|ct_resid
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|isp_prt
argument_list|(
name|mp
operator|->
name|isp
argument_list|,
name|ISP_LOGTDEBUG1
argument_list|,
literal|"CTIO lun%d for ID%d ct_flags 0x%x"
argument_list|,
name|csio
operator|->
name|ccb_h
operator|.
name|target_lun
argument_list|,
name|cto
operator|->
name|ct_iid
argument_list|,
name|cto
operator|->
name|ct_flags
argument_list|)
expr_stmt|;
block|}
name|ISP_TDQE
argument_list|(
name|mp
operator|->
name|isp
argument_list|,
literal|"last tdma_mk"
argument_list|,
operator|*
name|mp
operator|->
name|iptrp
argument_list|,
name|cto
argument_list|)
expr_stmt|;
name|ISP_SWIZ_CTIO
argument_list|(
name|mp
operator|->
name|isp
argument_list|,
name|cto
argument_list|,
name|cto
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ct_entry_t
modifier|*
name|octo
init|=
name|cto
decl_stmt|;
comment|/* 			 * Make sure handle fields are clean 			 */
name|cto
operator|->
name|ct_reserved
operator|=
literal|0
expr_stmt|;
name|cto
operator|->
name|ct_header
operator|.
name|rqs_seqno
operator|=
literal|0
expr_stmt|;
name|isp_prt
argument_list|(
name|mp
operator|->
name|isp
argument_list|,
name|ISP_LOGTDEBUG1
argument_list|,
literal|"CTIO lun%d for ID%d ct_flags 0x%x"
argument_list|,
name|csio
operator|->
name|ccb_h
operator|.
name|target_lun
argument_list|,
name|cto
operator|->
name|ct_iid
argument_list|,
name|cto
operator|->
name|ct_flags
argument_list|)
expr_stmt|;
name|ISP_TDQE
argument_list|(
name|mp
operator|->
name|isp
argument_list|,
literal|"tdma_mk"
argument_list|,
operator|*
name|mp
operator|->
name|iptrp
argument_list|,
name|cto
argument_list|)
expr_stmt|;
comment|/* 			 * Get a new CTIO 			 */
name|cto
operator|=
operator|(
name|ct_entry_t
operator|*
operator|)
name|ISP_QUEUE_ENTRY
argument_list|(
name|mp
operator|->
name|isp
operator|->
name|isp_rquest
argument_list|,
operator|*
name|mp
operator|->
name|iptrp
argument_list|)
expr_stmt|;
operator|*
name|mp
operator|->
name|iptrp
operator|=
name|ISP_NXT_QENTRY
argument_list|(
operator|*
name|mp
operator|->
name|iptrp
argument_list|,
name|RQUEST_QUEUE_LEN
argument_list|(
name|isp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|mp
operator|->
name|iptrp
operator|==
name|mp
operator|->
name|optr
condition|)
block|{
name|printf
argument_list|(
literal|"%s: Queue Overflow in tdma_mk\n"
argument_list|,
name|mp
operator|->
name|isp
operator|->
name|isp_name
argument_list|)
expr_stmt|;
name|mp
operator|->
name|error
operator|=
name|MUSHERR_NOQENTRIES
expr_stmt|;
return|return;
block|}
comment|/* 			 * Fill in the new CTIO with info from the old one. 			 */
name|cto
operator|->
name|ct_header
operator|.
name|rqs_entry_type
operator|=
name|RQSTYPE_CTIO
expr_stmt|;
name|cto
operator|->
name|ct_header
operator|.
name|rqs_entry_count
operator|=
literal|1
expr_stmt|;
name|cto
operator|->
name|ct_header
operator|.
name|rqs_flags
operator|=
literal|0
expr_stmt|;
name|cto
operator|->
name|ct_lun
operator|=
name|octo
operator|->
name|ct_lun
expr_stmt|;
name|cto
operator|->
name|ct_iid
operator|=
name|octo
operator|->
name|ct_iid
expr_stmt|;
name|cto
operator|->
name|ct_reserved2
operator|=
name|octo
operator|->
name|ct_reserved2
expr_stmt|;
name|cto
operator|->
name|ct_tgt
operator|=
name|octo
operator|->
name|ct_tgt
expr_stmt|;
name|cto
operator|->
name|ct_flags
operator|=
name|octo
operator|->
name|ct_flags
expr_stmt|;
name|cto
operator|->
name|ct_status
operator|=
literal|0
expr_stmt|;
name|cto
operator|->
name|ct_scsi_status
operator|=
literal|0
expr_stmt|;
name|cto
operator|->
name|ct_tag_val
operator|=
name|octo
operator|->
name|ct_tag_val
expr_stmt|;
name|cto
operator|->
name|ct_tag_type
operator|=
name|octo
operator|->
name|ct_tag_type
expr_stmt|;
name|cto
operator|->
name|ct_xfrlen
operator|=
literal|0
expr_stmt|;
name|cto
operator|->
name|ct_resid
operator|=
literal|0
expr_stmt|;
name|cto
operator|->
name|ct_timeout
operator|=
name|octo
operator|->
name|ct_timeout
expr_stmt|;
name|cto
operator|->
name|ct_seg_count
operator|=
literal|0
expr_stmt|;
name|MEMZERO
argument_list|(
name|cto
operator|->
name|ct_dataseg
argument_list|,
sizeof|sizeof
argument_list|(
name|cto
operator|->
name|ct_dataseg
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 			 * Now swizzle the old one for the consumption of the 			 * chip. 			 */
name|ISP_SWIZ_CTIO
argument_list|(
name|mp
operator|->
name|isp
argument_list|,
name|octo
argument_list|,
name|octo
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|tdma_mkfc
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|dm_segs
parameter_list|,
name|int
name|nseg
parameter_list|,
name|int
name|error
parameter_list|)
block|{
name|mush_t
modifier|*
name|mp
decl_stmt|;
name|struct
name|ccb_scsiio
modifier|*
name|csio
decl_stmt|;
name|struct
name|isp_pcisoftc
modifier|*
name|pci
decl_stmt|;
name|bus_dmamap_t
modifier|*
name|dp
decl_stmt|;
name|ct2_entry_t
modifier|*
name|cto
decl_stmt|;
name|u_int16_t
name|scsi_status
decl_stmt|,
name|send_status
decl_stmt|,
name|send_sense
decl_stmt|;
name|u_int32_t
name|handle
decl_stmt|,
name|totxfr
decl_stmt|,
name|datalen
decl_stmt|;
name|u_int8_t
name|sense
index|[
name|QLTM_SENSELEN
index|]
decl_stmt|;
name|int
name|nctios
decl_stmt|;
name|mp
operator|=
operator|(
name|mush_t
operator|*
operator|)
name|arg
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|mp
operator|->
name|error
operator|=
name|error
expr_stmt|;
return|return;
block|}
name|csio
operator|=
name|mp
operator|->
name|cmd_token
expr_stmt|;
name|cto
operator|=
name|mp
operator|->
name|rq
expr_stmt|;
if|if
condition|(
name|nseg
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|cto
operator|->
name|ct_flags
operator|&
name|CT2_FLAG_MMASK
operator|)
operator|!=
name|CT2_FLAG_MODE1
condition|)
block|{
name|printf
argument_list|(
literal|"%s: dma2_tgt_fc, a status CTIO2 without MODE1 "
literal|"set (0x%x)\n"
argument_list|,
name|mp
operator|->
name|isp
operator|->
name|isp_name
argument_list|,
name|cto
operator|->
name|ct_flags
argument_list|)
expr_stmt|;
name|mp
operator|->
name|error
operator|=
name|EINVAL
expr_stmt|;
return|return;
block|}
name|cto
operator|->
name|ct_header
operator|.
name|rqs_entry_count
operator|=
literal|1
expr_stmt|;
name|cto
operator|->
name|ct_header
operator|.
name|rqs_seqno
operator|=
literal|1
expr_stmt|;
comment|/* ct_reserved contains the handle set by caller */
comment|/* 		 * We preserve ct_lun, ct_iid, ct_rxid. We set the data 		 * flags to NO DATA and clear relative offset flags. 		 * We preserve the ct_resid and the response area. 		 */
name|cto
operator|->
name|ct_flags
operator||=
name|CT2_NO_DATA
expr_stmt|;
if|if
condition|(
name|cto
operator|->
name|ct_resid
operator|>
literal|0
condition|)
name|cto
operator|->
name|ct_flags
operator||=
name|CT2_DATA_UNDER
expr_stmt|;
elseif|else
if|if
condition|(
name|cto
operator|->
name|ct_resid
operator|<
literal|0
condition|)
name|cto
operator|->
name|ct_flags
operator||=
name|CT2_DATA_OVER
expr_stmt|;
name|cto
operator|->
name|ct_seg_count
operator|=
literal|0
expr_stmt|;
name|cto
operator|->
name|ct_reloff
operator|=
literal|0
expr_stmt|;
name|ISP_TDQE
argument_list|(
name|mp
operator|->
name|isp
argument_list|,
literal|"dma2_tgt_fc[no data]"
argument_list|,
operator|*
name|mp
operator|->
name|iptrp
argument_list|,
name|cto
argument_list|)
expr_stmt|;
name|isp_prt
argument_list|(
name|mp
operator|->
name|isp
argument_list|,
name|ISP_LOGTDEBUG1
argument_list|,
literal|"CTIO2 RX_ID 0x%x lun %d->iid%d flgs 0x%x sts 0x%x ssts "
literal|"0x%x res %d"
argument_list|,
name|cto
operator|->
name|ct_rxid
argument_list|,
name|csio
operator|->
name|ccb_h
operator|.
name|target_lun
argument_list|,
name|cto
operator|->
name|ct_iid
argument_list|,
name|cto
operator|->
name|ct_flags
argument_list|,
name|cto
operator|->
name|ct_status
argument_list|,
name|cto
operator|->
name|rsp
operator|.
name|m1
operator|.
name|ct_scsi_status
argument_list|,
name|cto
operator|->
name|ct_resid
argument_list|)
expr_stmt|;
name|ISP_SWIZ_CTIO2
argument_list|(
name|isp
argument_list|,
name|cto
argument_list|,
name|cto
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|cto
operator|->
name|ct_flags
operator|&
name|CT2_FLAG_MMASK
operator|)
operator|!=
name|CT2_FLAG_MODE0
condition|)
block|{
name|printf
argument_list|(
literal|"%s: dma2_tgt_fc, a data CTIO2 without MODE0 set "
literal|"(0x%x)\n\n"
argument_list|,
name|mp
operator|->
name|isp
operator|->
name|isp_name
argument_list|,
name|cto
operator|->
name|ct_flags
argument_list|)
expr_stmt|;
name|mp
operator|->
name|error
operator|=
name|EINVAL
expr_stmt|;
return|return;
block|}
name|nctios
operator|=
name|nseg
operator|/
name|ISP_RQDSEG_T2
expr_stmt|;
if|if
condition|(
name|nseg
operator|%
name|ISP_RQDSEG_T2
condition|)
block|{
name|nctios
operator|++
expr_stmt|;
block|}
comment|/* 	 * Save the handle, status, reloff, and residual. We'll reinsert the 	 * handle into the last CTIO2 we're going to send, and reinsert status 	 * and residual (and possibly sense data) if that's to be sent as well. 	 * 	 * We preserve ct_reloff and adjust it for each data CTIO2 we send past 	 * the first one. This is needed so that the FCP DATA IUs being sent 	 * out have the correct offset (they can arrive at the other end out 	 * of order). 	 */
name|handle
operator|=
name|cto
operator|->
name|ct_reserved
expr_stmt|;
name|cto
operator|->
name|ct_reserved
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|send_status
operator|=
operator|(
name|cto
operator|->
name|ct_flags
operator|&
name|CT2_SENDSTATUS
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|cto
operator|->
name|ct_flags
operator|&=
operator|~
name|CT2_SENDSTATUS
expr_stmt|;
comment|/* 		 * Preserve residual, which is actually the total count. 		 */
name|datalen
operator|=
name|cto
operator|->
name|ct_resid
expr_stmt|;
comment|/* 		 * Save actual SCSI status. We'll reinsert the 		 * CT2_SNSLEN_VALID later if appropriate. 		 */
name|scsi_status
operator|=
name|cto
operator|->
name|rsp
operator|.
name|m0
operator|.
name|ct_scsi_status
operator|&
literal|0xff
expr_stmt|;
name|send_sense
operator|=
name|cto
operator|->
name|rsp
operator|.
name|m0
operator|.
name|ct_scsi_status
operator|&
name|CT2_SNSLEN_VALID
expr_stmt|;
comment|/* 		 * If we're sending status and have a CHECK CONDTION and 		 * have sense data,  we send one more CTIO2 with just the 		 * status and sense data. The upper layers have stashed 		 * the sense data in the dataseg structure for us. 		 */
if|if
condition|(
operator|(
name|scsi_status
operator|&
literal|0xf
operator|)
operator|==
name|SCSI_STATUS_CHECK_COND
operator|&&
name|send_sense
condition|)
block|{
name|bcopy
argument_list|(
name|cto
operator|->
name|rsp
operator|.
name|m0
operator|.
name|ct_dataseg
argument_list|,
name|sense
argument_list|,
name|QLTM_SENSELEN
argument_list|)
expr_stmt|;
name|nctios
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
name|scsi_status
operator|=
name|send_sense
operator|=
name|datalen
operator|=
literal|0
expr_stmt|;
block|}
name|totxfr
operator|=
name|cto
operator|->
name|ct_resid
operator|=
literal|0
expr_stmt|;
name|cto
operator|->
name|rsp
operator|.
name|m0
operator|.
name|ct_scsi_status
operator|=
literal|0
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|cto
operator|->
name|rsp
argument_list|,
sizeof|sizeof
argument_list|(
name|cto
operator|->
name|rsp
argument_list|)
argument_list|)
expr_stmt|;
name|pci
operator|=
operator|(
expr|struct
name|isp_pcisoftc
operator|*
operator|)
name|mp
operator|->
name|isp
expr_stmt|;
name|dp
operator|=
operator|&
name|pci
operator|->
name|dmaps
index|[
name|isp_handle_index
argument_list|(
name|handle
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|csio
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DIR_MASK
operator|)
operator|==
name|CAM_DIR_IN
condition|)
block|{
name|bus_dmamap_sync
argument_list|(
name|pci
operator|->
name|parent_dmat
argument_list|,
operator|*
name|dp
argument_list|,
name|BUS_DMASYNC_PREREAD
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bus_dmamap_sync
argument_list|(
name|pci
operator|->
name|parent_dmat
argument_list|,
operator|*
name|dp
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|nctios
operator|--
condition|)
block|{
name|int
name|seg
decl_stmt|,
name|seglim
decl_stmt|;
name|seglim
operator|=
name|nseg
expr_stmt|;
if|if
condition|(
name|seglim
condition|)
block|{
if|if
condition|(
name|seglim
operator|>
name|ISP_RQDSEG_T2
condition|)
name|seglim
operator|=
name|ISP_RQDSEG_T2
expr_stmt|;
for|for
control|(
name|seg
operator|=
literal|0
init|;
name|seg
operator|<
name|seglim
condition|;
name|seg
operator|++
control|)
block|{
name|cto
operator|->
name|rsp
operator|.
name|m0
operator|.
name|ct_dataseg
index|[
name|seg
index|]
operator|.
name|ds_base
operator|=
name|dm_segs
operator|->
name|ds_addr
expr_stmt|;
name|cto
operator|->
name|rsp
operator|.
name|m0
operator|.
name|ct_dataseg
index|[
name|seg
index|]
operator|.
name|ds_count
operator|=
name|dm_segs
operator|->
name|ds_len
expr_stmt|;
name|cto
operator|->
name|rsp
operator|.
name|m0
operator|.
name|ct_xfrlen
operator|+=
name|dm_segs
operator|->
name|ds_len
expr_stmt|;
name|totxfr
operator|+=
name|dm_segs
operator|->
name|ds_len
expr_stmt|;
name|dm_segs
operator|++
expr_stmt|;
block|}
name|cto
operator|->
name|ct_seg_count
operator|=
name|seg
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * This case should only happen when we're sending a 			 * synthesized MODE1 final status with sense data. 			 */
if|if
condition|(
name|send_sense
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%s: dma2_tgt_fc ran out of segments, "
literal|"no SENSE DATA\n"
argument_list|,
name|mp
operator|->
name|isp
operator|->
name|isp_name
argument_list|)
expr_stmt|;
name|mp
operator|->
name|error
operator|=
name|EINVAL
expr_stmt|;
return|return;
block|}
block|}
comment|/* 		 * At this point, the fields ct_lun, ct_iid, ct_rxid, 		 * ct_timeout have been carried over unchanged from what 		 * our caller had set. 		 * 		 * The field ct_reloff is either what the caller set, or 		 * what we've added to below. 		 * 		 * The dataseg fields and the seg_count fields we just got 		 * through setting. The data direction we've preserved all 		 * along and only clear it if we're sending a MODE1 status 		 * as the last CTIO. 		 * 		 */
if|if
condition|(
name|nctios
operator|==
literal|0
condition|)
block|{
comment|/* 			 * We're the last in a sequence of CTIO2s, so mark this 			 * CTIO2 and save the handle to the CCB such that when 			 * this CTIO2 completes we can free dma resources and 			 * do whatever else we need to do to finish the rest 			 * of the command. 			 */
name|cto
operator|->
name|ct_reserved
operator|=
name|handle
expr_stmt|;
name|cto
operator|->
name|ct_header
operator|.
name|rqs_seqno
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|send_status
condition|)
block|{
if|if
condition|(
name|send_sense
condition|)
block|{
name|bcopy
argument_list|(
name|sense
argument_list|,
name|cto
operator|->
name|rsp
operator|.
name|m1
operator|.
name|ct_resp
argument_list|,
name|QLTM_SENSELEN
argument_list|)
expr_stmt|;
name|cto
operator|->
name|rsp
operator|.
name|m1
operator|.
name|ct_senselen
operator|=
name|QLTM_SENSELEN
expr_stmt|;
name|scsi_status
operator||=
name|CT2_SNSLEN_VALID
expr_stmt|;
name|cto
operator|->
name|rsp
operator|.
name|m1
operator|.
name|ct_scsi_status
operator|=
name|scsi_status
expr_stmt|;
name|cto
operator|->
name|ct_flags
operator|&=
name|CT2_FLAG_MMASK
expr_stmt|;
name|cto
operator|->
name|ct_flags
operator||=
name|CT2_FLAG_MODE1
operator||
name|CT2_NO_DATA
operator||
name|CT2_SENDSTATUS
expr_stmt|;
block|}
else|else
block|{
name|cto
operator|->
name|rsp
operator|.
name|m0
operator|.
name|ct_scsi_status
operator|=
name|scsi_status
expr_stmt|;
name|cto
operator|->
name|ct_flags
operator||=
name|CT2_SENDSTATUS
expr_stmt|;
block|}
comment|/* 				 * Get 'real' residual and set flags based 				 * on it. 				 */
name|cto
operator|->
name|ct_resid
operator|=
name|datalen
operator|-
name|totxfr
expr_stmt|;
if|if
condition|(
name|cto
operator|->
name|ct_resid
operator|>
literal|0
condition|)
name|cto
operator|->
name|ct_flags
operator||=
name|CT2_DATA_UNDER
expr_stmt|;
elseif|else
if|if
condition|(
name|cto
operator|->
name|ct_resid
operator|<
literal|0
condition|)
name|cto
operator|->
name|ct_flags
operator||=
name|CT2_DATA_OVER
expr_stmt|;
block|}
name|ISP_TDQE
argument_list|(
name|mp
operator|->
name|isp
argument_list|,
literal|"last dma2_tgt_fc"
argument_list|,
operator|*
name|mp
operator|->
name|iptrp
argument_list|,
name|cto
argument_list|)
expr_stmt|;
name|isp_prt
argument_list|(
name|mp
operator|->
name|isp
argument_list|,
name|ISP_LOGTDEBUG1
argument_list|,
literal|"CTIO2 RX_ID 0x%x lun %d->iid%d flgs 0x%x sts 0x%x"
literal|" ssts 0x%x res %d"
argument_list|,
name|cto
operator|->
name|ct_rxid
argument_list|,
name|csio
operator|->
name|ccb_h
operator|.
name|target_lun
argument_list|,
operator|(
name|int
operator|)
name|cto
operator|->
name|ct_iid
argument_list|,
name|cto
operator|->
name|ct_flags
argument_list|,
name|cto
operator|->
name|ct_status
argument_list|,
name|cto
operator|->
name|rsp
operator|.
name|m1
operator|.
name|ct_scsi_status
argument_list|,
name|cto
operator|->
name|ct_resid
argument_list|)
expr_stmt|;
name|ISP_SWIZ_CTIO2
argument_list|(
name|isp
argument_list|,
name|cto
argument_list|,
name|cto
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ct2_entry_t
modifier|*
name|octo
init|=
name|cto
decl_stmt|;
comment|/* 			 * Make sure handle fields are clean 			 */
name|cto
operator|->
name|ct_reserved
operator|=
literal|0
expr_stmt|;
name|cto
operator|->
name|ct_header
operator|.
name|rqs_seqno
operator|=
literal|0
expr_stmt|;
name|ISP_TDQE
argument_list|(
name|mp
operator|->
name|isp
argument_list|,
literal|"dma2_tgt_fc"
argument_list|,
operator|*
name|mp
operator|->
name|iptrp
argument_list|,
name|cto
argument_list|)
expr_stmt|;
name|isp_prt
argument_list|(
name|mp
operator|->
name|isp
argument_list|,
name|ISP_LOGTDEBUG1
argument_list|,
literal|"CTIO2 RX_ID 0x%x lun %d->iid%d flgs 0x%x"
argument_list|,
name|cto
operator|->
name|ct_rxid
argument_list|,
name|csio
operator|->
name|ccb_h
operator|.
name|target_lun
argument_list|,
operator|(
name|int
operator|)
name|cto
operator|->
name|ct_iid
argument_list|,
name|cto
operator|->
name|ct_flags
argument_list|)
expr_stmt|;
comment|/* 			 * Get a new CTIO2 			 */
name|cto
operator|=
operator|(
name|ct2_entry_t
operator|*
operator|)
name|ISP_QUEUE_ENTRY
argument_list|(
name|mp
operator|->
name|isp
operator|->
name|isp_rquest
argument_list|,
operator|*
name|mp
operator|->
name|iptrp
argument_list|)
expr_stmt|;
operator|*
name|mp
operator|->
name|iptrp
operator|=
name|ISP_NXT_QENTRY
argument_list|(
operator|*
name|mp
operator|->
name|iptrp
argument_list|,
name|RQUEST_QUEUE_LEN
argument_list|(
name|isp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|mp
operator|->
name|iptrp
operator|==
name|mp
operator|->
name|optr
condition|)
block|{
name|printf
argument_list|(
literal|"%s: Queue Overflow in dma2_tgt_fc\n"
argument_list|,
name|mp
operator|->
name|isp
operator|->
name|isp_name
argument_list|)
expr_stmt|;
name|mp
operator|->
name|error
operator|=
name|MUSHERR_NOQENTRIES
expr_stmt|;
return|return;
block|}
comment|/* 			 * Fill in the new CTIO2 with info from the old one. 			 */
name|cto
operator|->
name|ct_header
operator|.
name|rqs_entry_type
operator|=
name|RQSTYPE_CTIO2
expr_stmt|;
name|cto
operator|->
name|ct_header
operator|.
name|rqs_entry_count
operator|=
literal|1
expr_stmt|;
name|cto
operator|->
name|ct_header
operator|.
name|rqs_flags
operator|=
literal|0
expr_stmt|;
comment|/* ct_header.rqs_seqno&& ct_reserved done later */
name|cto
operator|->
name|ct_lun
operator|=
name|octo
operator|->
name|ct_lun
expr_stmt|;
name|cto
operator|->
name|ct_iid
operator|=
name|octo
operator|->
name|ct_iid
expr_stmt|;
name|cto
operator|->
name|ct_rxid
operator|=
name|octo
operator|->
name|ct_rxid
expr_stmt|;
name|cto
operator|->
name|ct_flags
operator|=
name|octo
operator|->
name|ct_flags
expr_stmt|;
name|cto
operator|->
name|ct_status
operator|=
literal|0
expr_stmt|;
name|cto
operator|->
name|ct_resid
operator|=
literal|0
expr_stmt|;
name|cto
operator|->
name|ct_timeout
operator|=
name|octo
operator|->
name|ct_timeout
expr_stmt|;
name|cto
operator|->
name|ct_seg_count
operator|=
literal|0
expr_stmt|;
comment|/* 			 * Adjust the new relative offset by the amount which 			 * is recorded in the data segment of the old CTIO2 we 			 * just finished filling out. 			 */
name|cto
operator|->
name|ct_reloff
operator|+=
name|octo
operator|->
name|rsp
operator|.
name|m0
operator|.
name|ct_xfrlen
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|cto
operator|->
name|rsp
argument_list|,
sizeof|sizeof
argument_list|(
name|cto
operator|->
name|rsp
argument_list|)
argument_list|)
expr_stmt|;
name|ISP_SWIZ_CTIO2
argument_list|(
name|isp
argument_list|,
name|cto
argument_list|,
name|cto
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|void
name|dma2
name|__P
argument_list|(
operator|(
name|void
operator|*
operator|,
name|bus_dma_segment_t
operator|*
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|dma2
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|dm_segs
parameter_list|,
name|int
name|nseg
parameter_list|,
name|int
name|error
parameter_list|)
block|{
name|mush_t
modifier|*
name|mp
decl_stmt|;
name|struct
name|ccb_scsiio
modifier|*
name|csio
decl_stmt|;
name|struct
name|isp_pcisoftc
modifier|*
name|pci
decl_stmt|;
name|bus_dmamap_t
modifier|*
name|dp
decl_stmt|;
name|bus_dma_segment_t
modifier|*
name|eseg
decl_stmt|;
name|ispreq_t
modifier|*
name|rq
decl_stmt|;
name|ispcontreq_t
modifier|*
name|crq
decl_stmt|;
name|int
name|seglim
decl_stmt|,
name|datalen
decl_stmt|;
name|mp
operator|=
operator|(
name|mush_t
operator|*
operator|)
name|arg
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|mp
operator|->
name|error
operator|=
name|error
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|nseg
operator|<
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"%s: bad segment count (%d)\n"
argument_list|,
name|mp
operator|->
name|isp
operator|->
name|isp_name
argument_list|,
name|nseg
argument_list|)
expr_stmt|;
name|mp
operator|->
name|error
operator|=
name|EFAULT
expr_stmt|;
return|return;
block|}
name|csio
operator|=
name|mp
operator|->
name|cmd_token
expr_stmt|;
name|rq
operator|=
name|mp
operator|->
name|rq
expr_stmt|;
name|pci
operator|=
operator|(
expr|struct
name|isp_pcisoftc
operator|*
operator|)
name|mp
operator|->
name|isp
expr_stmt|;
name|dp
operator|=
operator|&
name|pci
operator|->
name|dmaps
index|[
name|isp_handle_index
argument_list|(
name|rq
operator|->
name|req_handle
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|csio
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DIR_MASK
operator|)
operator|==
name|CAM_DIR_IN
condition|)
block|{
name|bus_dmamap_sync
argument_list|(
name|pci
operator|->
name|parent_dmat
argument_list|,
operator|*
name|dp
argument_list|,
name|BUS_DMASYNC_PREREAD
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bus_dmamap_sync
argument_list|(
name|pci
operator|->
name|parent_dmat
argument_list|,
operator|*
name|dp
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
block|}
name|datalen
operator|=
name|XS_XFRLEN
argument_list|(
name|csio
argument_list|)
expr_stmt|;
comment|/* 	 * We're passed an initial partially filled in entry that 	 * has most fields filled in except for data transfer 	 * related values. 	 * 	 * Our job is to fill in the initial request queue entry and 	 * then to start allocating and filling in continuation entries 	 * until we've covered the entire transfer. 	 */
if|if
condition|(
name|IS_FC
argument_list|(
name|mp
operator|->
name|isp
argument_list|)
condition|)
block|{
name|seglim
operator|=
name|ISP_RQDSEG_T2
expr_stmt|;
operator|(
operator|(
name|ispreqt2_t
operator|*
operator|)
name|rq
operator|)
operator|->
name|req_totalcnt
operator|=
name|datalen
expr_stmt|;
if|if
condition|(
operator|(
name|csio
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DIR_MASK
operator|)
operator|==
name|CAM_DIR_IN
condition|)
block|{
operator|(
operator|(
name|ispreqt2_t
operator|*
operator|)
name|rq
operator|)
operator|->
name|req_flags
operator||=
name|REQFLAG_DATA_IN
expr_stmt|;
block|}
else|else
block|{
operator|(
operator|(
name|ispreqt2_t
operator|*
operator|)
name|rq
operator|)
operator|->
name|req_flags
operator||=
name|REQFLAG_DATA_OUT
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|csio
operator|->
name|cdb_len
operator|>
literal|12
condition|)
block|{
name|seglim
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|seglim
operator|=
name|ISP_RQDSEG
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|csio
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DIR_MASK
operator|)
operator|==
name|CAM_DIR_IN
condition|)
block|{
name|rq
operator|->
name|req_flags
operator||=
name|REQFLAG_DATA_IN
expr_stmt|;
block|}
else|else
block|{
name|rq
operator|->
name|req_flags
operator||=
name|REQFLAG_DATA_OUT
expr_stmt|;
block|}
block|}
name|eseg
operator|=
name|dm_segs
operator|+
name|nseg
expr_stmt|;
while|while
condition|(
name|datalen
operator|!=
literal|0
operator|&&
name|rq
operator|->
name|req_seg_count
operator|<
name|seglim
operator|&&
name|dm_segs
operator|!=
name|eseg
condition|)
block|{
if|if
condition|(
name|IS_FC
argument_list|(
name|mp
operator|->
name|isp
argument_list|)
condition|)
block|{
name|ispreqt2_t
modifier|*
name|rq2
init|=
operator|(
name|ispreqt2_t
operator|*
operator|)
name|rq
decl_stmt|;
name|rq2
operator|->
name|req_dataseg
index|[
name|rq2
operator|->
name|req_seg_count
index|]
operator|.
name|ds_base
operator|=
name|dm_segs
operator|->
name|ds_addr
expr_stmt|;
name|rq2
operator|->
name|req_dataseg
index|[
name|rq2
operator|->
name|req_seg_count
index|]
operator|.
name|ds_count
operator|=
name|dm_segs
operator|->
name|ds_len
expr_stmt|;
block|}
else|else
block|{
name|rq
operator|->
name|req_dataseg
index|[
name|rq
operator|->
name|req_seg_count
index|]
operator|.
name|ds_base
operator|=
name|dm_segs
operator|->
name|ds_addr
expr_stmt|;
name|rq
operator|->
name|req_dataseg
index|[
name|rq
operator|->
name|req_seg_count
index|]
operator|.
name|ds_count
operator|=
name|dm_segs
operator|->
name|ds_len
expr_stmt|;
block|}
name|datalen
operator|-=
name|dm_segs
operator|->
name|ds_len
expr_stmt|;
if|#
directive|if
literal|0
block|if (IS_FC(mp->isp)) { 			ispreqt2_t *rq2 = (ispreqt2_t *)rq; 			printf("%s: seg0[%d] cnt 0x%x paddr 0x%08x\n", 			    mp->isp->isp_name, rq->req_seg_count, 			    rq2->req_dataseg[rq2->req_seg_count].ds_count, 			    rq2->req_dataseg[rq2->req_seg_count].ds_base); 		} else { 			printf("%s: seg0[%d] cnt 0x%x paddr 0x%08x\n", 			    mp->isp->isp_name, rq->req_seg_count, 			    rq->req_dataseg[rq->req_seg_count].ds_count, 			    rq->req_dataseg[rq->req_seg_count].ds_base); 		}
endif|#
directive|endif
name|rq
operator|->
name|req_seg_count
operator|++
expr_stmt|;
name|dm_segs
operator|++
expr_stmt|;
block|}
while|while
condition|(
name|datalen
operator|>
literal|0
operator|&&
name|dm_segs
operator|!=
name|eseg
condition|)
block|{
name|crq
operator|=
operator|(
name|ispcontreq_t
operator|*
operator|)
name|ISP_QUEUE_ENTRY
argument_list|(
name|mp
operator|->
name|isp
operator|->
name|isp_rquest
argument_list|,
operator|*
name|mp
operator|->
name|iptrp
argument_list|)
expr_stmt|;
operator|*
name|mp
operator|->
name|iptrp
operator|=
name|ISP_NXT_QENTRY
argument_list|(
operator|*
name|mp
operator|->
name|iptrp
argument_list|,
name|RQUEST_QUEUE_LEN
argument_list|(
name|isp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|mp
operator|->
name|iptrp
operator|==
name|mp
operator|->
name|optr
condition|)
block|{
if|#
directive|if
literal|0
block|printf("%s: Request Queue Overflow++\n", 			    mp->isp->isp_name);
endif|#
directive|endif
name|mp
operator|->
name|error
operator|=
name|MUSHERR_NOQENTRIES
expr_stmt|;
return|return;
block|}
name|rq
operator|->
name|req_header
operator|.
name|rqs_entry_count
operator|++
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|void
operator|*
operator|)
name|crq
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|crq
argument_list|)
argument_list|)
expr_stmt|;
name|crq
operator|->
name|req_header
operator|.
name|rqs_entry_count
operator|=
literal|1
expr_stmt|;
name|crq
operator|->
name|req_header
operator|.
name|rqs_entry_type
operator|=
name|RQSTYPE_DATASEG
expr_stmt|;
name|seglim
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|datalen
operator|>
literal|0
operator|&&
name|seglim
operator|<
name|ISP_CDSEG
operator|&&
name|dm_segs
operator|!=
name|eseg
condition|)
block|{
name|crq
operator|->
name|req_dataseg
index|[
name|seglim
index|]
operator|.
name|ds_base
operator|=
name|dm_segs
operator|->
name|ds_addr
expr_stmt|;
name|crq
operator|->
name|req_dataseg
index|[
name|seglim
index|]
operator|.
name|ds_count
operator|=
name|dm_segs
operator|->
name|ds_len
expr_stmt|;
if|#
directive|if
literal|0
block|printf("%s: seg%d[%d] cnt 0x%x paddr 0x%08x\n", 			    mp->isp->isp_name, rq->req_header.rqs_entry_count-1, 			    seglim, crq->req_dataseg[seglim].ds_count, 			    crq->req_dataseg[seglim].ds_base);
endif|#
directive|endif
name|rq
operator|->
name|req_seg_count
operator|++
expr_stmt|;
name|dm_segs
operator|++
expr_stmt|;
name|seglim
operator|++
expr_stmt|;
name|datalen
operator|-=
name|dm_segs
operator|->
name|ds_len
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|isp_pci_dmasetup
parameter_list|(
name|struct
name|ispsoftc
modifier|*
name|isp
parameter_list|,
name|struct
name|ccb_scsiio
modifier|*
name|csio
parameter_list|,
name|ispreq_t
modifier|*
name|rq
parameter_list|,
name|u_int16_t
modifier|*
name|iptrp
parameter_list|,
name|u_int16_t
name|optr
parameter_list|)
block|{
name|struct
name|isp_pcisoftc
modifier|*
name|pci
init|=
operator|(
expr|struct
name|isp_pcisoftc
operator|*
operator|)
name|isp
decl_stmt|;
name|bus_dmamap_t
modifier|*
name|dp
init|=
name|NULL
decl_stmt|;
name|mush_t
name|mush
decl_stmt|,
modifier|*
name|mp
decl_stmt|;
name|void
argument_list|(
argument|*eptr
argument_list|)
name|__P
argument_list|(
operator|(
name|void
operator|*
operator|,
name|bus_dma_segment_t
operator|*
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ISP_TARGET_MODE
if|if
condition|(
name|csio
operator|->
name|ccb_h
operator|.
name|func_code
operator|==
name|XPT_CONT_TARGET_IO
condition|)
block|{
if|if
condition|(
name|IS_FC
argument_list|(
name|isp
argument_list|)
condition|)
block|{
name|eptr
operator|=
name|tdma_mkfc
expr_stmt|;
block|}
else|else
block|{
name|eptr
operator|=
name|tdma_mk
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|csio
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DIR_MASK
operator|)
operator|==
name|CAM_DIR_NONE
operator|||
operator|(
name|csio
operator|->
name|dxfer_len
operator|==
literal|0
operator|)
condition|)
block|{
name|rq
operator|->
name|req_seg_count
operator|=
literal|1
expr_stmt|;
name|mp
operator|=
operator|&
name|mush
expr_stmt|;
name|mp
operator|->
name|isp
operator|=
name|isp
expr_stmt|;
name|mp
operator|->
name|cmd_token
operator|=
name|csio
expr_stmt|;
name|mp
operator|->
name|rq
operator|=
name|rq
expr_stmt|;
name|mp
operator|->
name|iptrp
operator|=
name|iptrp
expr_stmt|;
name|mp
operator|->
name|optr
operator|=
name|optr
expr_stmt|;
name|mp
operator|->
name|error
operator|=
literal|0
expr_stmt|;
call|(
modifier|*
name|eptr
call|)
argument_list|(
name|mp
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|exit
goto|;
block|}
block|}
else|else
endif|#
directive|endif
name|eptr
operator|=
name|dma2
expr_stmt|;
comment|/* 	 * NB: if we need to do request queue entry swizzling, 	 * NB: this is where it would need to be done for cmds 	 * NB: that move no data. For commands that move data, 	 * NB: swizzling would take place in those functions. 	 */
if|if
condition|(
operator|(
name|csio
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DIR_MASK
operator|)
operator|==
name|CAM_DIR_NONE
operator|||
operator|(
name|csio
operator|->
name|dxfer_len
operator|==
literal|0
operator|)
condition|)
block|{
name|rq
operator|->
name|req_seg_count
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|CMD_QUEUED
operator|)
return|;
block|}
comment|/* 	 * Do a virtual grapevine step to collect info for 	 * the callback dma allocation that we have to use... 	 */
name|mp
operator|=
operator|&
name|mush
expr_stmt|;
name|mp
operator|->
name|isp
operator|=
name|isp
expr_stmt|;
name|mp
operator|->
name|cmd_token
operator|=
name|csio
expr_stmt|;
name|mp
operator|->
name|rq
operator|=
name|rq
expr_stmt|;
name|mp
operator|->
name|iptrp
operator|=
name|iptrp
expr_stmt|;
name|mp
operator|->
name|optr
operator|=
name|optr
expr_stmt|;
name|mp
operator|->
name|error
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|csio
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_SCATTER_VALID
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|csio
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DATA_PHYS
operator|)
operator|==
literal|0
condition|)
block|{
name|int
name|error
decl_stmt|,
name|s
decl_stmt|;
name|dp
operator|=
operator|&
name|pci
operator|->
name|dmaps
index|[
name|isp_handle_index
argument_list|(
name|rq
operator|->
name|req_handle
argument_list|)
index|]
expr_stmt|;
name|s
operator|=
name|splsoftvm
argument_list|()
expr_stmt|;
name|error
operator|=
name|bus_dmamap_load
argument_list|(
name|pci
operator|->
name|parent_dmat
argument_list|,
operator|*
name|dp
argument_list|,
name|csio
operator|->
name|data_ptr
argument_list|,
name|csio
operator|->
name|dxfer_len
argument_list|,
name|eptr
argument_list|,
name|mp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|EINPROGRESS
condition|)
block|{
name|bus_dmamap_unload
argument_list|(
name|pci
operator|->
name|parent_dmat
argument_list|,
operator|*
name|dp
argument_list|)
expr_stmt|;
name|mp
operator|->
name|error
operator|=
name|EINVAL
expr_stmt|;
name|printf
argument_list|(
literal|"%s: deferred dma allocation not "
literal|"supported\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|error
operator|&&
name|mp
operator|->
name|error
operator|==
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|DIAGNOSTIC
name|printf
argument_list|(
literal|"%s: error %d in dma mapping code\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|error
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|mp
operator|->
name|error
operator|=
name|error
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Pointer to physical buffer */
name|struct
name|bus_dma_segment
name|seg
decl_stmt|;
name|seg
operator|.
name|ds_addr
operator|=
operator|(
name|bus_addr_t
operator|)
name|csio
operator|->
name|data_ptr
expr_stmt|;
name|seg
operator|.
name|ds_len
operator|=
name|csio
operator|->
name|dxfer_len
expr_stmt|;
call|(
modifier|*
name|eptr
call|)
argument_list|(
name|mp
argument_list|,
operator|&
name|seg
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|struct
name|bus_dma_segment
modifier|*
name|segs
decl_stmt|;
if|if
condition|(
operator|(
name|csio
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DATA_PHYS
operator|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%s: Physical segment pointers unsupported"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|)
expr_stmt|;
name|mp
operator|->
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|csio
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_SG_LIST_PHYS
operator|)
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%s: Virtual segment addresses unsupported"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|)
expr_stmt|;
name|mp
operator|->
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
else|else
block|{
comment|/* Just use the segments provided */
name|segs
operator|=
operator|(
expr|struct
name|bus_dma_segment
operator|*
operator|)
name|csio
operator|->
name|data_ptr
expr_stmt|;
call|(
modifier|*
name|eptr
call|)
argument_list|(
name|mp
argument_list|,
name|segs
argument_list|,
name|csio
operator|->
name|sglist_cnt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|ISP_TARGET_MODE
name|exit
label|:
endif|#
directive|endif
if|if
condition|(
name|mp
operator|->
name|error
condition|)
block|{
name|int
name|retval
init|=
name|CMD_COMPLETE
decl_stmt|;
if|if
condition|(
name|mp
operator|->
name|error
operator|==
name|MUSHERR_NOQENTRIES
condition|)
block|{
name|retval
operator|=
name|CMD_EAGAIN
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mp
operator|->
name|error
operator|==
name|EFBIG
condition|)
block|{
name|XS_SETERR
argument_list|(
name|csio
argument_list|,
name|CAM_REQ_TOO_BIG
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mp
operator|->
name|error
operator|==
name|EINVAL
condition|)
block|{
name|XS_SETERR
argument_list|(
name|csio
argument_list|,
name|CAM_REQ_INVALID
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|XS_SETERR
argument_list|(
name|csio
argument_list|,
name|CAM_UNREC_HBA_ERROR
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|retval
operator|)
return|;
block|}
else|else
block|{
comment|/* 		 * Check to see if we weren't cancelled while sleeping on 		 * getting DMA resources... 		 */
if|if
condition|(
operator|(
name|csio
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
operator|)
operator|!=
name|CAM_REQ_INPROG
condition|)
block|{
if|if
condition|(
name|dp
condition|)
block|{
name|bus_dmamap_unload
argument_list|(
name|pci
operator|->
name|parent_dmat
argument_list|,
operator|*
name|dp
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|CMD_COMPLETE
operator|)
return|;
block|}
return|return
operator|(
name|CMD_QUEUED
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|isp_pci_dmateardown
parameter_list|(
name|struct
name|ispsoftc
modifier|*
name|isp
parameter_list|,
name|XS_T
modifier|*
name|xs
parameter_list|,
name|u_int32_t
name|handle
parameter_list|)
block|{
name|struct
name|isp_pcisoftc
modifier|*
name|pci
init|=
operator|(
expr|struct
name|isp_pcisoftc
operator|*
operator|)
name|isp
decl_stmt|;
name|bus_dmamap_t
modifier|*
name|dp
init|=
operator|&
name|pci
operator|->
name|dmaps
index|[
name|isp_handle_index
argument_list|(
name|handle
argument_list|)
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|xs
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DIR_MASK
operator|)
operator|==
name|CAM_DIR_IN
condition|)
block|{
name|bus_dmamap_sync
argument_list|(
name|pci
operator|->
name|parent_dmat
argument_list|,
operator|*
name|dp
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bus_dmamap_sync
argument_list|(
name|pci
operator|->
name|parent_dmat
argument_list|,
operator|*
name|dp
argument_list|,
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
block|}
name|bus_dmamap_unload
argument_list|(
name|pci
operator|->
name|parent_dmat
argument_list|,
operator|*
name|dp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|isp_pci_reset1
parameter_list|(
name|struct
name|ispsoftc
modifier|*
name|isp
parameter_list|)
block|{
comment|/* Make sure the BIOS is disabled */
name|isp_pci_wr_reg
argument_list|(
name|isp
argument_list|,
name|HCCR
argument_list|,
name|PCI_HCCR_CMD_BIOS
argument_list|)
expr_stmt|;
comment|/* and enable interrupts */
name|ENABLE_INTS
argument_list|(
name|isp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|isp_pci_dumpregs
parameter_list|(
name|struct
name|ispsoftc
modifier|*
name|isp
parameter_list|,
specifier|const
name|char
modifier|*
name|msg
parameter_list|)
block|{
name|struct
name|isp_pcisoftc
modifier|*
name|pci
init|=
operator|(
expr|struct
name|isp_pcisoftc
operator|*
operator|)
name|isp
decl_stmt|;
if|if
condition|(
name|msg
condition|)
name|printf
argument_list|(
literal|"%s: %s\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|msg
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_SCSI
argument_list|(
name|isp
argument_list|)
condition|)
name|printf
argument_list|(
literal|"    biu_conf1=%x"
argument_list|,
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|BIU_CONF1
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"    biu_csr=%x"
argument_list|,
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|BIU2100_CSR
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" biu_icr=%x biu_isr=%x biu_sema=%x "
argument_list|,
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|BIU_ICR
argument_list|)
argument_list|,
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|BIU_ISR
argument_list|)
argument_list|,
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|BIU_SEMA
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"risc_hccr=%x\n"
argument_list|,
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|HCCR
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_SCSI
argument_list|(
name|isp
argument_list|)
condition|)
block|{
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|HCCR
argument_list|,
name|HCCR_CMD_PAUSE
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    cdma_conf=%x cdma_sts=%x cdma_fifostat=%x\n"
argument_list|,
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|CDMA_CONF
argument_list|)
argument_list|,
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|CDMA_STATUS
argument_list|)
argument_list|,
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|CDMA_FIFO_STS
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    ddma_conf=%x ddma_sts=%x ddma_fifostat=%x\n"
argument_list|,
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|DDMA_CONF
argument_list|)
argument_list|,
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|DDMA_STATUS
argument_list|)
argument_list|,
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|DDMA_FIFO_STS
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    sxp_int=%x sxp_gross=%x sxp(scsi_ctrl)=%x\n"
argument_list|,
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|SXP_INTERRUPT
argument_list|)
argument_list|,
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|SXP_GROSS_ERR
argument_list|)
argument_list|,
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|SXP_PINS_CTRL
argument_list|)
argument_list|)
expr_stmt|;
name|ISP_WRITE
argument_list|(
name|isp
argument_list|,
name|HCCR
argument_list|,
name|HCCR_CMD_RELEASE
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"    mbox regs: %x %x %x %x %x\n"
argument_list|,
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|OUTMAILBOX0
argument_list|)
argument_list|,
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|OUTMAILBOX1
argument_list|)
argument_list|,
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|OUTMAILBOX2
argument_list|)
argument_list|,
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|OUTMAILBOX3
argument_list|)
argument_list|,
name|ISP_READ
argument_list|(
name|isp
argument_list|,
name|OUTMAILBOX4
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    PCI Status Command/Status=%x\n"
argument_list|,
name|pci_read_config
argument_list|(
name|pci
operator|->
name|pci_dev
argument_list|,
name|PCIR_COMMAND
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

