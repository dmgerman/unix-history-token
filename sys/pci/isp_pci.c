begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* $FreeBSD$ */
end_comment

begin_comment
comment|/* $Id: isp_pci.c,v 1.13 1998/09/08 01:24:58 mjacob Exp $ */
end_comment

begin_comment
comment|/*  * PCI specific probe and attach routines for Qlogic ISP SCSI adapters.  * FreeBSD Version.  *  *---------------------------------------  * Copyright (c) 1997, 1998 by Matthew Jacob  * NASA/Ames Research Center  * All rights reserved.  *---------------------------------------  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice immediately at the beginning of the file, without modification,  *    this list of conditions, and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. The name of the author may not be used to endorse or promote products  *    derived from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE FOR  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<dev/isp/isp_freebsd.h>
end_include

begin_include
include|#
directive|include
file|<dev/isp/asm_pci.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_extern.h>
end_include

begin_include
include|#
directive|include
file|<pci/pcireg.h>
end_include

begin_include
include|#
directive|include
file|<pci/pcivar.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|SCSI_CAM
end_ifdef

begin_include
include|#
directive|include
file|<machine/bus_memio.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus_pio.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|u_int16_t
name|isp_pci_rd_reg
name|__P
argument_list|(
operator|(
expr|struct
name|ispsoftc
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|isp_pci_wr_reg
name|__P
argument_list|(
operator|(
expr|struct
name|ispsoftc
operator|*
operator|,
name|int
operator|,
name|u_int16_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|isp_pci_mbxdma
name|__P
argument_list|(
operator|(
expr|struct
name|ispsoftc
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|isp_pci_dmasetup
name|__P
argument_list|(
operator|(
expr|struct
name|ispsoftc
operator|*
operator|,
name|ISP_SCSI_XFER_T
operator|*
operator|,
name|ispreq_t
operator|*
operator|,
name|u_int8_t
operator|*
operator|,
name|u_int8_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|SCSI_CAM
end_ifdef

begin_decl_stmt
specifier|static
name|void
name|isp_pci_dmateardown
name|__P
argument_list|(
operator|(
expr|struct
name|ispsoftc
operator|*
operator|,
name|ISP_SCSI_XFER_T
operator|*
operator|,
name|u_int32_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|isp_pci_dmateardown
value|NULL
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|void
name|isp_pci_reset1
name|__P
argument_list|(
operator|(
expr|struct
name|ispsoftc
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|isp_pci_dumpregs
name|__P
argument_list|(
operator|(
expr|struct
name|ispsoftc
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|ispmdvec
name|mdvec
init|=
block|{
name|isp_pci_rd_reg
block|,
name|isp_pci_wr_reg
block|,
name|isp_pci_mbxdma
block|,
name|isp_pci_dmasetup
block|,
name|isp_pci_dmateardown
block|,
name|NULL
block|,
name|isp_pci_reset1
block|,
name|isp_pci_dumpregs
block|,
name|ISP_RISC_CODE
block|,
name|ISP_CODE_LENGTH
block|,
name|ISP_CODE_ORG
block|,
name|ISP_CODE_VERSION
block|,
name|BIU_BURST_ENABLE
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|ispmdvec
name|mdvec_2100
init|=
block|{
name|isp_pci_rd_reg
block|,
name|isp_pci_wr_reg
block|,
name|isp_pci_mbxdma
block|,
name|isp_pci_dmasetup
block|,
name|isp_pci_dmateardown
block|,
name|NULL
block|,
name|isp_pci_reset1
block|,
name|isp_pci_dumpregs
block|,
name|ISP2100_RISC_CODE
block|,
name|ISP2100_CODE_LENGTH
block|,
name|ISP2100_CODE_ORG
block|,
name|ISP2100_CODE_VERSION
block|,
name|BIU_BURST_ENABLE
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|PCIM_CMD_INVEN
end_ifndef

begin_define
define|#
directive|define
name|PCIM_CMD_INVEN
value|0x10
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|PCIM_CMD_BUSMASTEREN
end_ifndef

begin_define
define|#
directive|define
name|PCIM_CMD_BUSMASTEREN
value|0x0004
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|PCI_VENDOR_QLOGIC
end_ifndef

begin_define
define|#
directive|define
name|PCI_VENDOR_QLOGIC
value|0x1077
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|PCI_PRODUCT_QLOGIC_ISP1020
end_ifndef

begin_define
define|#
directive|define
name|PCI_PRODUCT_QLOGIC_ISP1020
value|0x1020
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|PCI_QLOGIC_ISP
define|\
value|((PCI_PRODUCT_QLOGIC_ISP1020<< 16) | PCI_VENDOR_QLOGIC)
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|PCI_PRODUCT_QLOGIC_ISP2100
end_ifndef

begin_define
define|#
directive|define
name|PCI_PRODUCT_QLOGIC_ISP2100
value|0x2100
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|PCI_QLOGIC_ISP2100
define|\
value|((PCI_PRODUCT_QLOGIC_ISP2100<< 16) | PCI_VENDOR_QLOGIC)
end_define

begin_define
define|#
directive|define
name|IO_MAP_REG
value|0x10
end_define

begin_define
define|#
directive|define
name|MEM_MAP_REG
value|0x14
end_define

begin_decl_stmt
specifier|static
name|char
modifier|*
name|isp_pci_probe
name|__P
argument_list|(
operator|(
name|pcici_t
name|tag
operator|,
name|pcidi_t
name|type
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|isp_pci_attach
name|__P
argument_list|(
operator|(
name|pcici_t
name|config_d
operator|,
name|int
name|unit
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This distinguishing define is not right, but it does work */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|SCSI_CAM
end_ifndef

begin_define
define|#
directive|define
name|I386_BUS_SPACE_IO
value|0
end_define

begin_define
define|#
directive|define
name|I386_BUS_SPACE_MEM
value|1
end_define

begin_typedef
typedef|typedef
name|int
name|bus_space_tag_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|u_long
name|bus_space_handle_t
typedef|;
end_typedef

begin_define
define|#
directive|define
name|bus_space_read_2
parameter_list|(
name|st
parameter_list|,
name|sh
parameter_list|,
name|offset
parameter_list|)
define|\
value|(st == I386_BUS_SPACE_IO)? \ 		inw((u_int16_t)sh + offset) : *((u_int16_t *)(uintptr_t)sh)
end_define

begin_define
define|#
directive|define
name|bus_space_write_2
parameter_list|(
name|st
parameter_list|,
name|sh
parameter_list|,
name|offset
parameter_list|,
name|val
parameter_list|)
define|\
value|if (st == I386_BUS_SPACE_IO) outw((u_int16_t)sh + offset, val); else \ 		*((u_int16_t *)(uintptr_t)sh) = val
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_struct
struct|struct
name|isp_pcisoftc
block|{
name|struct
name|ispsoftc
name|pci_isp
decl_stmt|;
name|pcici_t
name|pci_id
decl_stmt|;
name|bus_space_tag_t
name|pci_st
decl_stmt|;
name|bus_space_handle_t
name|pci_sh
decl_stmt|;
ifdef|#
directive|ifdef
name|SCSI_CAM
name|bus_dma_tag_t
name|parent_dmat
decl_stmt|;
name|bus_dma_tag_t
name|cntrol_dmat
decl_stmt|;
name|bus_dmamap_t
name|cntrol_dmap
decl_stmt|;
name|bus_dmamap_t
name|dmaps
index|[
name|MAXISPREQUEST
index|]
decl_stmt|;
endif|#
directive|endif
union|union
block|{
name|sdparam
name|_x
decl_stmt|;
struct|struct
block|{
name|fcparam
name|_a
decl_stmt|;
name|char
name|_b
index|[
name|ISP2100_SCRLEN
index|]
decl_stmt|;
block|}
name|_y
struct|;
block|}
name|_z
union|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|u_long
name|ispunit
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|pci_device
name|isp_pci_driver
init|=
block|{
literal|"isp"
block|,
name|isp_pci_probe
block|,
name|isp_pci_attach
block|,
operator|&
name|ispunit
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DATA_SET
argument_list|(
name|pcidevice_set
argument_list|,
name|isp_pci_driver
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|char
modifier|*
name|isp_pci_probe
parameter_list|(
name|tag
parameter_list|,
name|type
parameter_list|)
name|pcici_t
name|tag
decl_stmt|;
name|pcidi_t
name|type
decl_stmt|;
block|{
specifier|static
name|int
name|oneshot
init|=
literal|1
decl_stmt|;
name|char
modifier|*
name|x
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|PCI_QLOGIC_ISP
case|:
name|x
operator|=
literal|"Qlogic ISP 10X0 PCI SCSI Adapter"
expr_stmt|;
break|break;
case|case
name|PCI_QLOGIC_ISP2100
case|:
name|x
operator|=
literal|"Qlogic ISP 2100 PCI FC-AL Adapter"
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|oneshot
condition|)
block|{
name|oneshot
operator|=
literal|0
expr_stmt|;
name|printf
argument_list|(
literal|"%s Version %d.%d, Core Version %d.%d\n"
argument_list|,
name|PVS
argument_list|,
name|ISP_PLATFORM_VERSION_MAJOR
argument_list|,
name|ISP_PLATFORM_VERSION_MINOR
argument_list|,
name|ISP_CORE_VERSION_MAJOR
argument_list|,
name|ISP_CORE_VERSION_MINOR
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|x
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|isp_pci_attach
parameter_list|(
name|config_id
parameter_list|,
name|unit
parameter_list|)
name|pcici_t
name|config_id
decl_stmt|;
name|int
name|unit
decl_stmt|;
block|{
name|int
name|mapped
decl_stmt|;
name|u_int16_t
name|io_port
decl_stmt|;
name|u_int32_t
name|data
decl_stmt|;
name|struct
name|isp_pcisoftc
modifier|*
name|pcs
decl_stmt|;
name|struct
name|ispsoftc
modifier|*
name|isp
decl_stmt|;
name|vm_offset_t
name|vaddr
decl_stmt|,
name|paddr
decl_stmt|;
name|ISP_LOCKVAL_DECL
expr_stmt|;
name|pcs
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|isp_pcisoftc
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcs
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"isp%d: cannot allocate softc\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return;
block|}
name|bzero
argument_list|(
name|pcs
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|isp_pcisoftc
argument_list|)
argument_list|)
expr_stmt|;
name|vaddr
operator|=
name|paddr
operator|=
name|NULL
expr_stmt|;
name|mapped
operator|=
literal|0
expr_stmt|;
name|data
operator|=
name|pci_conf_read
argument_list|(
name|config_id
argument_list|,
name|PCI_COMMAND_STATUS_REG
argument_list|)
expr_stmt|;
if|if
condition|(
name|mapped
operator|==
literal|0
operator|&&
operator|(
name|data
operator|&
name|PCI_COMMAND_IO_ENABLE
operator|)
condition|)
block|{
if|if
condition|(
name|pci_map_port
argument_list|(
name|config_id
argument_list|,
name|PCI_MAP_REG_START
argument_list|,
operator|&
name|io_port
argument_list|)
condition|)
block|{
name|pcs
operator|->
name|pci_st
operator|=
name|I386_BUS_SPACE_IO
expr_stmt|;
name|pcs
operator|->
name|pci_sh
operator|=
name|io_port
expr_stmt|;
name|mapped
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|mapped
operator|==
literal|0
operator|&&
operator|(
name|data
operator|&
name|PCI_COMMAND_MEM_ENABLE
operator|)
condition|)
block|{
if|if
condition|(
name|pci_map_mem
argument_list|(
name|config_id
argument_list|,
name|PCI_MAP_REG_START
argument_list|,
operator|&
name|vaddr
argument_list|,
operator|&
name|paddr
argument_list|)
condition|)
block|{
name|pcs
operator|->
name|pci_st
operator|=
name|I386_BUS_SPACE_MEM
expr_stmt|;
name|pcs
operator|->
name|pci_sh
operator|=
name|vaddr
expr_stmt|;
name|mapped
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|mapped
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"isp%d: unable to map any ports!\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|pcs
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return;
block|}
name|printf
argument_list|(
literal|"isp%d: using %s space register mapping\n"
argument_list|,
name|unit
argument_list|,
name|pcs
operator|->
name|pci_st
operator|==
name|I386_BUS_SPACE_IO
condition|?
literal|"I/O"
else|:
literal|"Memory"
argument_list|)
expr_stmt|;
name|isp
operator|=
operator|&
name|pcs
operator|->
name|pci_isp
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|isp
operator|->
name|isp_name
argument_list|,
literal|"isp%d"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|isp
operator|->
name|isp_osinfo
operator|.
name|unit
operator|=
name|unit
expr_stmt|;
name|data
operator|=
name|pci_conf_read
argument_list|(
name|config_id
argument_list|,
name|PCI_ID_REG
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|==
name|PCI_QLOGIC_ISP
condition|)
block|{
name|isp
operator|->
name|isp_mdvec
operator|=
operator|&
name|mdvec
expr_stmt|;
name|isp
operator|->
name|isp_type
operator|=
name|ISP_HA_SCSI_UNKNOWN
expr_stmt|;
name|isp
operator|->
name|isp_param
operator|=
operator|&
name|pcs
operator|->
name|_z
operator|.
name|_x
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|data
operator|==
name|PCI_QLOGIC_ISP2100
condition|)
block|{
name|isp
operator|->
name|isp_mdvec
operator|=
operator|&
name|mdvec_2100
expr_stmt|;
name|isp
operator|->
name|isp_type
operator|=
name|ISP_HA_FC_2100
expr_stmt|;
name|isp
operator|->
name|isp_param
operator|=
operator|&
name|pcs
operator|->
name|_z
operator|.
name|_y
operator|.
name|_a
expr_stmt|;
name|ISP_LOCK
argument_list|(
name|isp
argument_list|)
expr_stmt|;
name|data
operator|=
name|pci_conf_read
argument_list|(
name|config_id
argument_list|,
name|PCI_COMMAND_STATUS_REG
argument_list|)
expr_stmt|;
name|data
operator||=
name|PCIM_CMD_BUSMASTEREN
operator||
name|PCIM_CMD_INVEN
expr_stmt|;
name|pci_conf_write
argument_list|(
name|config_id
argument_list|,
name|PCI_COMMAND_STATUS_REG
argument_list|,
name|data
argument_list|)
expr_stmt|;
comment|/* 		 * Wierd- we need to clear the lsb in offset 0x30 to take the 		 * chip out of reset state. 		 */
name|data
operator|=
name|pci_conf_read
argument_list|(
name|config_id
argument_list|,
literal|0x30
argument_list|)
expr_stmt|;
name|data
operator|&=
operator|~
literal|1
expr_stmt|;
name|pci_conf_write
argument_list|(
name|config_id
argument_list|,
literal|0x30
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|ISP_UNLOCK
argument_list|(
name|isp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"%s: unknown dev (%x)- punting\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|pcs
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return;
block|}
ifdef|#
directive|ifdef
name|SCSI_CAM
if|if
condition|(
name|bus_dma_tag_create
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|BUS_SPACE_MAXADDR_32BIT
argument_list|,
name|BUS_SPACE_MAXADDR
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|1
operator|<<
literal|24
argument_list|,
literal|255
argument_list|,
literal|1
operator|<<
literal|24
argument_list|,
literal|0
argument_list|,
operator|&
name|pcs
operator|->
name|parent_dmat
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%s: could not create master dma tag\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|pcs
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
if|if
condition|(
name|pci_map_int
argument_list|(
name|config_id
argument_list|,
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
name|void
operator|*
argument_list|)
operator|)
name|isp_intr
argument_list|,
operator|(
name|void
operator|*
operator|)
name|isp
argument_list|,
operator|&
name|IMASK
argument_list|)
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%s: could not map interrupt\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|pcs
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return;
block|}
name|pcs
operator|->
name|pci_id
operator|=
name|config_id
expr_stmt|;
name|ISP_LOCK
argument_list|(
name|isp
argument_list|)
expr_stmt|;
name|isp_reset
argument_list|(
name|isp
argument_list|)
expr_stmt|;
if|if
condition|(
name|isp
operator|->
name|isp_state
operator|!=
name|ISP_RESETSTATE
condition|)
block|{
name|ISP_UNLOCK
argument_list|(
name|isp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|pcs
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return;
block|}
name|isp_init
argument_list|(
name|isp
argument_list|)
expr_stmt|;
if|if
condition|(
name|isp
operator|->
name|isp_state
operator|!=
name|ISP_INITSTATE
condition|)
block|{
name|isp_uninit
argument_list|(
name|isp
argument_list|)
expr_stmt|;
name|ISP_UNLOCK
argument_list|(
name|isp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|pcs
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return;
block|}
name|isp_attach
argument_list|(
name|isp
argument_list|)
expr_stmt|;
if|if
condition|(
name|isp
operator|->
name|isp_state
operator|!=
name|ISP_RUNSTATE
condition|)
block|{
name|isp_uninit
argument_list|(
name|isp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|pcs
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
name|ISP_UNLOCK
argument_list|(
name|isp
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|PCI_BIU_REGS_OFF
value|BIU_REGS_OFF
end_define

begin_function
specifier|static
name|u_int16_t
name|isp_pci_rd_reg
parameter_list|(
name|isp
parameter_list|,
name|regoff
parameter_list|)
name|struct
name|ispsoftc
modifier|*
name|isp
decl_stmt|;
name|int
name|regoff
decl_stmt|;
block|{
name|u_int16_t
name|rv
decl_stmt|;
name|struct
name|isp_pcisoftc
modifier|*
name|pcs
init|=
operator|(
expr|struct
name|isp_pcisoftc
operator|*
operator|)
name|isp
decl_stmt|;
name|int
name|offset
decl_stmt|,
name|oldsxp
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|(
name|regoff
operator|&
name|BIU_BLOCK
operator|)
operator|!=
literal|0
condition|)
block|{
name|offset
operator|=
name|PCI_BIU_REGS_OFF
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|regoff
operator|&
name|MBOX_BLOCK
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|isp
operator|->
name|isp_type
operator|&
name|ISP_HA_SCSI
condition|)
name|offset
operator|=
name|PCI_MBOX_REGS_OFF
expr_stmt|;
else|else
name|offset
operator|=
name|PCI_MBOX_REGS2100_OFF
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|regoff
operator|&
name|SXP_BLOCK
operator|)
operator|!=
literal|0
condition|)
block|{
name|offset
operator|=
name|PCI_SXP_REGS_OFF
expr_stmt|;
comment|/* 		 * We will assume that someone has paused the RISC processor. 		 */
name|oldsxp
operator|=
name|isp_pci_rd_reg
argument_list|(
name|isp
argument_list|,
name|BIU_CONF1
argument_list|)
expr_stmt|;
name|isp_pci_wr_reg
argument_list|(
name|isp
argument_list|,
name|BIU_CONF1
argument_list|,
name|oldsxp
operator|&
operator|~
name|BIU_PCI_CONF1_SXP
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|offset
operator|=
name|PCI_RISC_REGS_OFF
expr_stmt|;
block|}
name|regoff
operator|&=
literal|0xff
expr_stmt|;
name|offset
operator|+=
name|regoff
expr_stmt|;
name|rv
operator|=
name|bus_space_read_2
argument_list|(
name|pcs
operator|->
name|pci_st
argument_list|,
name|pcs
operator|->
name|pci_sh
argument_list|,
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|regoff
operator|&
name|SXP_BLOCK
operator|)
operator|!=
literal|0
condition|)
block|{
name|isp_pci_wr_reg
argument_list|(
name|isp
argument_list|,
name|BIU_CONF1
argument_list|,
name|oldsxp
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|rv
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|isp_pci_wr_reg
parameter_list|(
name|isp
parameter_list|,
name|regoff
parameter_list|,
name|val
parameter_list|)
name|struct
name|ispsoftc
modifier|*
name|isp
decl_stmt|;
name|int
name|regoff
decl_stmt|;
name|u_int16_t
name|val
decl_stmt|;
block|{
name|struct
name|isp_pcisoftc
modifier|*
name|pcs
init|=
operator|(
expr|struct
name|isp_pcisoftc
operator|*
operator|)
name|isp
decl_stmt|;
name|int
name|offset
decl_stmt|,
name|oldsxp
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|(
name|regoff
operator|&
name|BIU_BLOCK
operator|)
operator|!=
literal|0
condition|)
block|{
name|offset
operator|=
name|PCI_BIU_REGS_OFF
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|regoff
operator|&
name|MBOX_BLOCK
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|isp
operator|->
name|isp_type
operator|&
name|ISP_HA_SCSI
condition|)
name|offset
operator|=
name|PCI_MBOX_REGS_OFF
expr_stmt|;
else|else
name|offset
operator|=
name|PCI_MBOX_REGS2100_OFF
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|regoff
operator|&
name|SXP_BLOCK
operator|)
operator|!=
literal|0
condition|)
block|{
name|offset
operator|=
name|PCI_SXP_REGS_OFF
expr_stmt|;
comment|/* 		 * We will assume that someone has paused the RISC processor. 		 */
name|oldsxp
operator|=
name|isp_pci_rd_reg
argument_list|(
name|isp
argument_list|,
name|BIU_CONF1
argument_list|)
expr_stmt|;
name|isp_pci_wr_reg
argument_list|(
name|isp
argument_list|,
name|BIU_CONF1
argument_list|,
name|oldsxp
operator|&
operator|~
name|BIU_PCI_CONF1_SXP
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|offset
operator|=
name|PCI_RISC_REGS_OFF
expr_stmt|;
block|}
name|regoff
operator|&=
literal|0xff
expr_stmt|;
name|offset
operator|+=
name|regoff
expr_stmt|;
name|bus_space_write_2
argument_list|(
name|pcs
operator|->
name|pci_st
argument_list|,
name|pcs
operator|->
name|pci_sh
argument_list|,
name|offset
argument_list|,
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|regoff
operator|&
name|SXP_BLOCK
operator|)
operator|!=
literal|0
condition|)
block|{
name|isp_pci_wr_reg
argument_list|(
name|isp
argument_list|,
name|BIU_CONF1
argument_list|,
name|oldsxp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|SCSI_CAM
end_ifdef

begin_decl_stmt
specifier|static
name|void
name|isp_map_rquest
name|__P
argument_list|(
operator|(
name|void
operator|*
operator|,
name|bus_dma_segment_t
operator|*
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|isp_map_result
name|__P
argument_list|(
operator|(
name|void
operator|*
operator|,
name|bus_dma_segment_t
operator|*
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|isp_map_fcscrt
name|__P
argument_list|(
operator|(
name|void
operator|*
operator|,
name|bus_dma_segment_t
operator|*
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|isp_map_rquest
parameter_list|(
name|arg
parameter_list|,
name|segs
parameter_list|,
name|nseg
parameter_list|,
name|error
parameter_list|)
name|void
modifier|*
name|arg
decl_stmt|;
name|bus_dma_segment_t
modifier|*
name|segs
decl_stmt|;
name|int
name|nseg
decl_stmt|;
name|int
name|error
decl_stmt|;
block|{
name|struct
name|ispsoftc
modifier|*
name|isp
init|=
operator|(
expr|struct
name|ispsoftc
operator|*
operator|)
name|arg
decl_stmt|;
name|isp
operator|->
name|isp_rquest_dma
operator|=
name|segs
operator|->
name|ds_addr
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|isp_map_result
parameter_list|(
name|arg
parameter_list|,
name|segs
parameter_list|,
name|nseg
parameter_list|,
name|error
parameter_list|)
name|void
modifier|*
name|arg
decl_stmt|;
name|bus_dma_segment_t
modifier|*
name|segs
decl_stmt|;
name|int
name|nseg
decl_stmt|;
name|int
name|error
decl_stmt|;
block|{
name|struct
name|ispsoftc
modifier|*
name|isp
init|=
operator|(
expr|struct
name|ispsoftc
operator|*
operator|)
name|arg
decl_stmt|;
name|isp
operator|->
name|isp_result_dma
operator|=
name|segs
operator|->
name|ds_addr
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|isp_map_fcscrt
parameter_list|(
name|arg
parameter_list|,
name|segs
parameter_list|,
name|nseg
parameter_list|,
name|error
parameter_list|)
name|void
modifier|*
name|arg
decl_stmt|;
name|bus_dma_segment_t
modifier|*
name|segs
decl_stmt|;
name|int
name|nseg
decl_stmt|;
name|int
name|error
decl_stmt|;
block|{
name|struct
name|ispsoftc
modifier|*
name|isp
init|=
operator|(
expr|struct
name|ispsoftc
operator|*
operator|)
name|arg
decl_stmt|;
name|fcparam
modifier|*
name|fcp
init|=
name|isp
operator|->
name|isp_param
decl_stmt|;
name|fcp
operator|->
name|isp_scdma
operator|=
name|segs
operator|->
name|ds_addr
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|isp_pci_mbxdma
parameter_list|(
name|isp
parameter_list|)
name|struct
name|ispsoftc
modifier|*
name|isp
decl_stmt|;
block|{
name|struct
name|isp_pcisoftc
modifier|*
name|pci
init|=
operator|(
expr|struct
name|isp_pcisoftc
operator|*
operator|)
name|isp
decl_stmt|;
name|caddr_t
name|base
decl_stmt|;
name|u_int32_t
name|len
decl_stmt|;
name|int
name|i
decl_stmt|,
name|error
decl_stmt|;
comment|/* 	 * Allocate and map the request, result queues, plus FC scratch area. 	 */
name|len
operator|=
name|ISP_QUEUE_SIZE
argument_list|(
name|RQUEST_QUEUE_LEN
argument_list|)
expr_stmt|;
name|len
operator|+=
name|ISP_QUEUE_SIZE
argument_list|(
name|RESULT_QUEUE_LEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|isp
operator|->
name|isp_type
operator|&
name|ISP_HA_FC
condition|)
block|{
name|len
operator|+=
name|ISP2100_SCRLEN
expr_stmt|;
block|}
if|if
condition|(
name|bus_dma_tag_create
argument_list|(
name|pci
operator|->
name|parent_dmat
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|BUS_SPACE_MAXADDR
argument_list|,
name|BUS_SPACE_MAXADDR
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|len
argument_list|,
literal|1
argument_list|,
name|BUS_SPACE_MAXSIZE_32BIT
argument_list|,
literal|0
argument_list|,
operator|&
name|pci
operator|->
name|cntrol_dmat
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%s: cannot create a dma tag for control spaces\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|bus_dmamem_alloc
argument_list|(
name|pci
operator|->
name|cntrol_dmat
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|base
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|,
operator|&
name|pci
operator|->
name|cntrol_dmap
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%s: cannot allocate CCB memory\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|isp
operator|->
name|isp_rquest
operator|=
name|base
expr_stmt|;
name|bus_dmamap_load
argument_list|(
name|pci
operator|->
name|cntrol_dmat
argument_list|,
name|pci
operator|->
name|cntrol_dmap
argument_list|,
name|isp
operator|->
name|isp_rquest
argument_list|,
name|ISP_QUEUE_SIZE
argument_list|(
name|RQUEST_QUEUE_LEN
argument_list|)
argument_list|,
name|isp_map_rquest
argument_list|,
name|pci
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|isp
operator|->
name|isp_result
operator|=
name|base
operator|+
name|ISP_QUEUE_SIZE
argument_list|(
name|RQUEST_QUEUE_LEN
argument_list|)
expr_stmt|;
name|bus_dmamap_load
argument_list|(
name|pci
operator|->
name|cntrol_dmat
argument_list|,
name|pci
operator|->
name|cntrol_dmap
argument_list|,
name|isp
operator|->
name|isp_result
argument_list|,
name|ISP_QUEUE_SIZE
argument_list|(
name|RESULT_QUEUE_LEN
argument_list|)
argument_list|,
name|isp_map_result
argument_list|,
name|pci
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|isp
operator|->
name|isp_type
operator|&
name|ISP_HA_FC
condition|)
block|{
name|fcparam
modifier|*
name|fcp
init|=
operator|(
name|fcparam
operator|*
operator|)
name|isp
operator|->
name|isp_param
decl_stmt|;
name|fcp
operator|->
name|isp_scratch
operator|=
name|isp
operator|->
name|isp_result
operator|+
name|ISP_QUEUE_SIZE
argument_list|(
name|RESULT_QUEUE_LEN
argument_list|)
expr_stmt|;
name|bus_dmamap_load
argument_list|(
name|pci
operator|->
name|cntrol_dmat
argument_list|,
name|pci
operator|->
name|cntrol_dmap
argument_list|,
name|fcp
operator|->
name|isp_scratch
argument_list|,
name|ISP2100_SCRLEN
argument_list|,
name|isp_map_fcscrt
argument_list|,
name|pci
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Use this opportunity to initialize/create data DMA maps. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAXISPREQUEST
condition|;
name|i
operator|++
control|)
block|{
name|error
operator|=
name|bus_dmamap_create
argument_list|(
name|pci
operator|->
name|parent_dmat
argument_list|,
literal|0
argument_list|,
operator|&
name|pci
operator|->
name|dmaps
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|printf
argument_list|(
literal|"%s: error %d creating data DMA maps\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|void
name|dma2
name|__P
argument_list|(
operator|(
name|void
operator|*
operator|,
name|bus_dma_segment_t
operator|*
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_typedef
typedef|typedef
struct|struct
block|{
name|struct
name|ispsoftc
modifier|*
name|isp
decl_stmt|;
name|ISP_SCSI_XFER_T
modifier|*
name|ccb
decl_stmt|;
name|ispreq_t
modifier|*
name|rq
decl_stmt|;
name|u_int8_t
modifier|*
name|iptrp
decl_stmt|;
name|u_int8_t
name|optr
decl_stmt|;
name|u_int
name|error
decl_stmt|;
block|}
name|mush_t
typedef|;
end_typedef

begin_function
specifier|static
name|void
name|dma2
parameter_list|(
name|arg
parameter_list|,
name|dm_segs
parameter_list|,
name|nseg
parameter_list|,
name|error
parameter_list|)
name|void
modifier|*
name|arg
decl_stmt|;
name|bus_dma_segment_t
modifier|*
name|dm_segs
decl_stmt|;
name|int
name|nseg
decl_stmt|;
name|int
name|error
decl_stmt|;
block|{
name|mush_t
modifier|*
name|mp
decl_stmt|;
name|ISP_SCSI_XFER_T
modifier|*
name|ccb
decl_stmt|;
name|struct
name|ispsoftc
modifier|*
name|isp
decl_stmt|;
name|struct
name|isp_pcisoftc
modifier|*
name|pci
decl_stmt|;
name|bus_dmamap_t
modifier|*
name|dp
decl_stmt|;
name|bus_dma_segment_t
modifier|*
name|eseg
decl_stmt|;
name|ispreq_t
modifier|*
name|rq
decl_stmt|;
name|u_int8_t
modifier|*
name|iptrp
decl_stmt|;
name|u_int8_t
name|optr
decl_stmt|;
name|ispcontreq_t
modifier|*
name|crq
decl_stmt|;
name|int
name|drq
decl_stmt|,
name|seglim
decl_stmt|,
name|datalen
decl_stmt|;
name|mp
operator|=
operator|(
name|mush_t
operator|*
operator|)
name|arg
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|mp
operator|->
name|error
operator|=
name|error
expr_stmt|;
return|return;
block|}
name|isp
operator|=
name|mp
operator|->
name|isp
expr_stmt|;
if|if
condition|(
name|nseg
operator|<
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"%s: zero or negative segment count\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|)
expr_stmt|;
name|mp
operator|->
name|error
operator|=
name|EFAULT
expr_stmt|;
return|return;
block|}
name|ccb
operator|=
name|mp
operator|->
name|ccb
expr_stmt|;
name|rq
operator|=
name|mp
operator|->
name|rq
expr_stmt|;
name|iptrp
operator|=
name|mp
operator|->
name|iptrp
expr_stmt|;
name|optr
operator|=
name|mp
operator|->
name|optr
expr_stmt|;
name|pci
operator|=
operator|(
expr|struct
name|isp_pcisoftc
operator|*
operator|)
name|isp
expr_stmt|;
name|dp
operator|=
operator|&
name|pci
operator|->
name|dmaps
index|[
name|rq
operator|->
name|req_handle
operator|-
literal|1
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DIR_MASK
operator|)
operator|==
name|CAM_DIR_IN
condition|)
block|{
name|bus_dmamap_sync
argument_list|(
name|pci
operator|->
name|parent_dmat
argument_list|,
operator|*
name|dp
argument_list|,
name|BUS_DMASYNC_PREREAD
argument_list|)
expr_stmt|;
name|drq
operator|=
name|REQFLAG_DATA_IN
expr_stmt|;
block|}
else|else
block|{
name|bus_dmamap_sync
argument_list|(
name|pci
operator|->
name|parent_dmat
argument_list|,
operator|*
name|dp
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
name|drq
operator|=
name|REQFLAG_DATA_OUT
expr_stmt|;
block|}
name|datalen
operator|=
name|XS_XFRLEN
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
if|if
condition|(
name|isp
operator|->
name|isp_type
operator|&
name|ISP_HA_FC
condition|)
block|{
name|seglim
operator|=
name|ISP_RQDSEG_T2
expr_stmt|;
operator|(
operator|(
name|ispreqt2_t
operator|*
operator|)
name|rq
operator|)
operator|->
name|req_totalcnt
operator|=
name|datalen
expr_stmt|;
operator|(
operator|(
name|ispreqt2_t
operator|*
operator|)
name|rq
operator|)
operator|->
name|req_flags
operator||=
name|drq
expr_stmt|;
block|}
else|else
block|{
name|seglim
operator|=
name|ISP_RQDSEG
expr_stmt|;
name|rq
operator|->
name|req_flags
operator||=
name|drq
expr_stmt|;
block|}
name|eseg
operator|=
name|dm_segs
operator|+
name|nseg
expr_stmt|;
while|while
condition|(
name|datalen
operator|!=
literal|0
operator|&&
name|rq
operator|->
name|req_seg_count
operator|<
name|seglim
operator|&&
name|dm_segs
operator|!=
name|eseg
condition|)
block|{
if|if
condition|(
name|isp
operator|->
name|isp_type
operator|&
name|ISP_HA_FC
condition|)
block|{
name|ispreqt2_t
modifier|*
name|rq2
init|=
operator|(
name|ispreqt2_t
operator|*
operator|)
name|rq
decl_stmt|;
name|rq2
operator|->
name|req_dataseg
index|[
name|rq2
operator|->
name|req_seg_count
index|]
operator|.
name|ds_base
operator|=
name|dm_segs
operator|->
name|ds_addr
expr_stmt|;
name|rq2
operator|->
name|req_dataseg
index|[
name|rq2
operator|->
name|req_seg_count
index|]
operator|.
name|ds_count
operator|=
name|dm_segs
operator|->
name|ds_len
expr_stmt|;
block|}
else|else
block|{
name|rq
operator|->
name|req_dataseg
index|[
name|rq
operator|->
name|req_seg_count
index|]
operator|.
name|ds_base
operator|=
name|dm_segs
operator|->
name|ds_addr
expr_stmt|;
name|rq
operator|->
name|req_dataseg
index|[
name|rq
operator|->
name|req_seg_count
index|]
operator|.
name|ds_count
operator|=
name|dm_segs
operator|->
name|ds_len
expr_stmt|;
block|}
name|datalen
operator|-=
name|dm_segs
operator|->
name|ds_len
expr_stmt|;
if|#
directive|if
literal|0
block|if (isp->isp_type& ISP_HA_FC) { 			ispreqt2_t *rq2 = (ispreqt2_t *)rq; 			printf("%s: seg0[%d] cnt 0x%x paddr 0x%08x\n", 			    isp->isp_name, rq->req_seg_count, 			    rq2->req_dataseg[rq2->req_seg_count].ds_count, 			    rq2->req_dataseg[rq2->req_seg_count].ds_base); 		} else { 			printf("%s: seg0[%d] cnt 0x%x paddr 0x%08x\n", 			    isp->isp_name, rq->req_seg_count, 			    rq->req_dataseg[rq->req_seg_count].ds_count, 			    rq->req_dataseg[rq->req_seg_count].ds_base); 		}
endif|#
directive|endif
name|rq
operator|->
name|req_seg_count
operator|++
expr_stmt|;
name|dm_segs
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|datalen
operator|==
literal|0
condition|)
return|return;
while|while
condition|(
name|datalen
operator|>
literal|0
operator|&&
name|dm_segs
operator|!=
name|eseg
condition|)
block|{
name|crq
operator|=
operator|(
name|ispcontreq_t
operator|*
operator|)
name|ISP_QUEUE_ENTRY
argument_list|(
name|isp
operator|->
name|isp_rquest
argument_list|,
operator|*
name|iptrp
argument_list|)
expr_stmt|;
operator|*
name|iptrp
operator|=
operator|(
operator|*
name|iptrp
operator|+
literal|1
operator|)
operator|&
operator|(
name|RQUEST_QUEUE_LEN
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
operator|*
name|iptrp
operator|==
name|optr
condition|)
block|{
name|printf
argument_list|(
literal|"%s: Request Queue Overflow+\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|)
expr_stmt|;
name|mp
operator|->
name|error
operator|=
name|EFBIG
expr_stmt|;
return|return;
block|}
name|rq
operator|->
name|req_header
operator|.
name|rqs_entry_count
operator|++
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|void
operator|*
operator|)
name|crq
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|crq
argument_list|)
argument_list|)
expr_stmt|;
name|crq
operator|->
name|req_header
operator|.
name|rqs_entry_count
operator|=
literal|1
expr_stmt|;
name|crq
operator|->
name|req_header
operator|.
name|rqs_entry_type
operator|=
name|RQSTYPE_DATASEG
expr_stmt|;
name|seglim
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|datalen
operator|>
literal|0
operator|&&
name|seglim
operator|<
name|ISP_CDSEG
operator|&&
name|dm_segs
operator|!=
name|eseg
condition|)
block|{
name|crq
operator|->
name|req_dataseg
index|[
name|seglim
index|]
operator|.
name|ds_base
operator|=
name|dm_segs
operator|->
name|ds_addr
expr_stmt|;
name|crq
operator|->
name|req_dataseg
index|[
name|seglim
index|]
operator|.
name|ds_count
operator|=
name|dm_segs
operator|->
name|ds_len
expr_stmt|;
if|#
directive|if
literal|0
block|printf("%s: seg%d[%d] cnt 0x%x paddr 0x%08x\n", 			    isp->isp_name, rq->req_header.rqs_entry_count-1, 			    seglim, crq->req_dataseg[seglim].ds_count, 			    crq->req_dataseg[seglim].ds_base);
endif|#
directive|endif
name|rq
operator|->
name|req_seg_count
operator|++
expr_stmt|;
name|dm_segs
operator|++
expr_stmt|;
name|seglim
operator|++
expr_stmt|;
name|datalen
operator|-=
name|dm_segs
operator|->
name|ds_len
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|isp_pci_dmasetup
parameter_list|(
name|isp
parameter_list|,
name|ccb
parameter_list|,
name|rq
parameter_list|,
name|iptrp
parameter_list|,
name|optr
parameter_list|)
name|struct
name|ispsoftc
modifier|*
name|isp
decl_stmt|;
name|ISP_SCSI_XFER_T
modifier|*
name|ccb
decl_stmt|;
name|ispreq_t
modifier|*
name|rq
decl_stmt|;
name|u_int8_t
modifier|*
name|iptrp
decl_stmt|;
name|u_int8_t
name|optr
decl_stmt|;
block|{
name|struct
name|isp_pcisoftc
modifier|*
name|pci
init|=
operator|(
expr|struct
name|isp_pcisoftc
operator|*
operator|)
name|isp
decl_stmt|;
name|struct
name|ccb_hdr
modifier|*
name|ccb_h
decl_stmt|;
name|struct
name|ccb_scsiio
modifier|*
name|csio
decl_stmt|;
name|bus_dmamap_t
modifier|*
name|dp
decl_stmt|;
name|mush_t
name|mush
decl_stmt|,
modifier|*
name|mp
decl_stmt|;
name|csio
operator|=
operator|(
expr|struct
name|ccb_scsiio
operator|*
operator|)
name|ccb
expr_stmt|;
name|ccb_h
operator|=
operator|&
name|csio
operator|->
name|ccb_h
expr_stmt|;
if|if
condition|(
operator|(
name|ccb_h
operator|->
name|flags
operator|&
name|CAM_DIR_MASK
operator|)
operator|==
name|CAM_DIR_NONE
condition|)
block|{
name|rq
operator|->
name|req_seg_count
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|dp
operator|=
operator|&
name|pci
operator|->
name|dmaps
index|[
name|rq
operator|->
name|req_handle
operator|-
literal|1
index|]
expr_stmt|;
comment|/* 	 * Do a virtual grapevine step to collect info for 	 * a callback method we really didn't want. 	 */
name|mp
operator|=
operator|&
name|mush
expr_stmt|;
name|mp
operator|->
name|isp
operator|=
name|isp
expr_stmt|;
name|mp
operator|->
name|ccb
operator|=
name|ccb
expr_stmt|;
name|mp
operator|->
name|rq
operator|=
name|rq
expr_stmt|;
name|mp
operator|->
name|iptrp
operator|=
name|iptrp
expr_stmt|;
name|mp
operator|->
name|optr
operator|=
name|optr
expr_stmt|;
name|mp
operator|->
name|error
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|ccb_h
operator|->
name|flags
operator|&
name|CAM_SCATTER_VALID
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|ccb_h
operator|->
name|flags
operator|&
name|CAM_DATA_PHYS
operator|)
operator|==
literal|0
condition|)
block|{
name|int
name|error
decl_stmt|;
comment|/* 			 * spls are spls, locks are locks. 			 * it isn't clear whether splsoftvm, if s spl, 			 * is a RAISE over splcam, or not. 			 */
if|#
directive|if
literal|0
block|int s; 			s = splsoftvm();
endif|#
directive|endif
name|error
operator|=
name|bus_dmamap_load
argument_list|(
name|pci
operator|->
name|parent_dmat
argument_list|,
operator|*
name|dp
argument_list|,
name|csio
operator|->
name|data_ptr
argument_list|,
name|csio
operator|->
name|dxfer_len
argument_list|,
name|dma2
argument_list|,
name|mp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|splx(s);
endif|#
directive|endif
if|if
condition|(
name|error
operator|==
name|EINPROGRESS
condition|)
block|{
comment|/* 				 * We simply aren't going to support 				 * this at this time. This mechanism 				 * is too rigid for my taste. 				 */
name|printf
argument_list|(
literal|"%s: sorry, we're not doing bounceio\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|pci
operator|->
name|parent_dmat
argument_list|,
operator|*
name|dp
argument_list|)
expr_stmt|;
name|mp
operator|->
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|error
operator|&&
name|mp
operator|->
name|error
operator|==
literal|0
condition|)
block|{
name|mp
operator|->
name|error
operator|=
name|error
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Pointer to physical buffer */
name|struct
name|bus_dma_segment
name|seg
decl_stmt|;
name|seg
operator|.
name|ds_addr
operator|=
operator|(
name|bus_addr_t
operator|)
name|csio
operator|->
name|data_ptr
expr_stmt|;
name|seg
operator|.
name|ds_len
operator|=
name|csio
operator|->
name|dxfer_len
expr_stmt|;
name|dma2
argument_list|(
name|mp
argument_list|,
operator|&
name|seg
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|struct
name|bus_dma_segment
modifier|*
name|segs
decl_stmt|;
if|if
condition|(
operator|(
name|ccb_h
operator|->
name|flags
operator|&
name|CAM_DATA_PHYS
operator|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%s: Physical segment pointers unsupported"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|)
expr_stmt|;
name|mp
operator|->
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|ccb_h
operator|->
name|flags
operator|&
name|CAM_SG_LIST_PHYS
operator|)
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%s: Virtual segment addresses unsupported"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|)
expr_stmt|;
name|mp
operator|->
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
else|else
block|{
comment|/* Just use the segments provided */
name|segs
operator|=
operator|(
expr|struct
name|bus_dma_segment
operator|*
operator|)
name|csio
operator|->
name|data_ptr
expr_stmt|;
name|dma2
argument_list|(
name|mp
argument_list|,
name|segs
argument_list|,
name|csio
operator|->
name|sglist_cnt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|mp
operator|->
name|error
condition|)
block|{
if|if
condition|(
name|mp
operator|->
name|error
operator|!=
name|EFBIG
condition|)
block|{
name|printf
argument_list|(
literal|"%s: Unexepected error 0x%x returned from "
literal|"bus_dmamap_load\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|,
name|mp
operator|->
name|error
argument_list|)
expr_stmt|;
name|ccb_h
operator|->
name|status
operator|=
name|CAM_REQ_TOO_BIG
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mp
operator|->
name|error
operator|==
name|EINVAL
condition|)
block|{
name|ccb_h
operator|->
name|status
operator|=
name|CAM_REQ_INVALID
expr_stmt|;
block|}
else|else
block|{
name|ccb_h
operator|->
name|status
operator|=
name|CAM_UNREC_HBA_ERROR
expr_stmt|;
block|}
name|ccb_h
operator|->
name|status
operator||=
name|CAM_DEV_QFRZN
expr_stmt|;
name|printf
argument_list|(
literal|"%s:isp_pci_dmasetup->xpt_freeze_devq\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|)
expr_stmt|;
name|xpt_freeze_devq
argument_list|(
name|ccb_h
operator|->
name|path
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|mp
operator|->
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|isp_pci_dmateardown
parameter_list|(
name|isp
parameter_list|,
name|ccb
parameter_list|,
name|handle
parameter_list|)
name|struct
name|ispsoftc
modifier|*
name|isp
decl_stmt|;
name|ISP_SCSI_XFER_T
modifier|*
name|ccb
decl_stmt|;
name|u_int32_t
name|handle
decl_stmt|;
block|{
name|struct
name|isp_pcisoftc
modifier|*
name|pci
init|=
operator|(
expr|struct
name|isp_pcisoftc
operator|*
operator|)
name|isp
decl_stmt|;
name|bus_dmamap_t
modifier|*
name|dp
init|=
operator|&
name|pci
operator|->
name|dmaps
index|[
name|handle
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DIR_MASK
operator|)
operator|==
name|CAM_DIR_IN
condition|)
block|{
name|bus_dmamap_sync
argument_list|(
name|pci
operator|->
name|parent_dmat
argument_list|,
operator|*
name|dp
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bus_dmamap_sync
argument_list|(
name|pci
operator|->
name|parent_dmat
argument_list|,
operator|*
name|dp
argument_list|,
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
block|}
name|bus_dmamap_unload
argument_list|(
name|pci
operator|->
name|parent_dmat
argument_list|,
operator|*
name|dp
argument_list|)
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* SCSI_CAM */
end_comment

begin_function
specifier|static
name|int
name|isp_pci_mbxdma
parameter_list|(
name|isp
parameter_list|)
name|struct
name|ispsoftc
modifier|*
name|isp
decl_stmt|;
block|{
name|struct
name|isp_pcisoftc
modifier|*
name|pci
init|=
operator|(
expr|struct
name|isp_pcisoftc
operator|*
operator|)
name|isp
decl_stmt|;
name|u_int32_t
name|len
decl_stmt|;
name|int
name|rseg
decl_stmt|;
comment|/* XXXX CHECK FOR ALIGNMENT */
comment|/* 	 * Allocate and map the request queue. 	 */
name|len
operator|=
name|ISP_QUEUE_SIZE
argument_list|(
name|RQUEST_QUEUE_LEN
argument_list|)
expr_stmt|;
name|isp
operator|->
name|isp_rquest
operator|=
name|malloc
argument_list|(
name|len
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|isp
operator|->
name|isp_rquest
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"%s: cannot malloc request queue\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|isp
operator|->
name|isp_rquest_dma
operator|=
name|vtophys
argument_list|(
name|isp
operator|->
name|isp_rquest
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|printf("RQUEST=0x%x (0x%x)...", isp->isp_rquest, isp->isp_rquest_dma);
endif|#
directive|endif
comment|/* 	 * Allocate and map the result queue. 	 */
name|len
operator|=
name|ISP_QUEUE_SIZE
argument_list|(
name|RESULT_QUEUE_LEN
argument_list|)
expr_stmt|;
name|isp
operator|->
name|isp_result
operator|=
name|malloc
argument_list|(
name|len
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|isp
operator|->
name|isp_result
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|isp
operator|->
name|isp_rquest
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s: cannot malloc result queue\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|isp
operator|->
name|isp_result_dma
operator|=
name|vtophys
argument_list|(
name|isp
operator|->
name|isp_result
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|printf("RESULT=0x%x (0x%x)\n", isp->isp_result, isp->isp_result_dma);
endif|#
directive|endif
if|if
condition|(
name|isp
operator|->
name|isp_type
operator|&
name|ISP_HA_FC
condition|)
block|{
name|fcparam
modifier|*
name|fcp
init|=
name|isp
operator|->
name|isp_param
decl_stmt|;
name|len
operator|=
name|ISP2100_SCRLEN
expr_stmt|;
name|fcp
operator|->
name|isp_scratch
operator|=
operator|(
specifier|volatile
name|caddr_t
operator|)
operator|&
name|pci
operator|->
name|_z
operator|.
name|_y
operator|.
name|_b
expr_stmt|;
name|fcp
operator|->
name|isp_scdma
operator|=
name|vtophys
argument_list|(
name|fcp
operator|->
name|isp_scratch
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|isp_pci_dmasetup
parameter_list|(
name|isp
parameter_list|,
name|xs
parameter_list|,
name|rq
parameter_list|,
name|iptrp
parameter_list|,
name|optr
parameter_list|)
name|struct
name|ispsoftc
modifier|*
name|isp
decl_stmt|;
name|ISP_SCSI_XFER_T
modifier|*
name|xs
decl_stmt|;
name|ispreq_t
modifier|*
name|rq
decl_stmt|;
name|u_int8_t
modifier|*
name|iptrp
decl_stmt|;
name|u_int8_t
name|optr
decl_stmt|;
block|{
name|struct
name|isp_pcisoftc
modifier|*
name|pci
init|=
operator|(
expr|struct
name|isp_pcisoftc
operator|*
operator|)
name|isp
decl_stmt|;
name|ispcontreq_t
modifier|*
name|crq
decl_stmt|;
name|vm_offset_t
name|vaddr
decl_stmt|;
name|int
name|drq
decl_stmt|,
name|seglim
decl_stmt|;
name|u_int32_t
name|paddr
decl_stmt|,
name|nextpaddr
decl_stmt|,
name|datalen
decl_stmt|,
name|size
decl_stmt|,
modifier|*
name|ctrp
decl_stmt|;
if|if
condition|(
name|xs
operator|->
name|datalen
operator|==
literal|0
condition|)
block|{
name|rq
operator|->
name|req_seg_count
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|xs
operator|->
name|flags
operator|&
name|SCSI_DATA_IN
condition|)
block|{
name|drq
operator|=
name|REQFLAG_DATA_IN
expr_stmt|;
block|}
else|else
block|{
name|drq
operator|=
name|REQFLAG_DATA_OUT
expr_stmt|;
block|}
if|if
condition|(
name|isp
operator|->
name|isp_type
operator|&
name|ISP_HA_FC
condition|)
block|{
name|seglim
operator|=
name|ISP_RQDSEG_T2
expr_stmt|;
operator|(
operator|(
name|ispreqt2_t
operator|*
operator|)
name|rq
operator|)
operator|->
name|req_totalcnt
operator|=
name|XS_XFRLEN
argument_list|(
name|xs
argument_list|)
expr_stmt|;
operator|(
operator|(
name|ispreqt2_t
operator|*
operator|)
name|rq
operator|)
operator|->
name|req_flags
operator||=
name|drq
expr_stmt|;
block|}
else|else
block|{
name|seglim
operator|=
name|ISP_RQDSEG
expr_stmt|;
name|rq
operator|->
name|req_flags
operator||=
name|drq
expr_stmt|;
block|}
name|datalen
operator|=
name|XS_XFRLEN
argument_list|(
name|xs
argument_list|)
expr_stmt|;
name|vaddr
operator|=
operator|(
name|vm_offset_t
operator|)
name|xs
operator|->
name|data
expr_stmt|;
name|paddr
operator|=
name|vtophys
argument_list|(
name|vaddr
argument_list|)
expr_stmt|;
while|while
condition|(
name|datalen
operator|!=
literal|0
operator|&&
name|rq
operator|->
name|req_seg_count
operator|<
name|seglim
condition|)
block|{
if|if
condition|(
name|isp
operator|->
name|isp_type
operator|&
name|ISP_HA_FC
condition|)
block|{
name|ispreqt2_t
modifier|*
name|rq2
init|=
operator|(
name|ispreqt2_t
operator|*
operator|)
name|rq
decl_stmt|;
name|rq2
operator|->
name|req_dataseg
index|[
name|rq2
operator|->
name|req_seg_count
index|]
operator|.
name|ds_base
operator|=
name|paddr
expr_stmt|;
name|ctrp
operator|=
operator|&
name|rq2
operator|->
name|req_dataseg
index|[
name|rq2
operator|->
name|req_seg_count
index|]
operator|.
name|ds_count
expr_stmt|;
block|}
else|else
block|{
name|rq
operator|->
name|req_dataseg
index|[
name|rq
operator|->
name|req_seg_count
index|]
operator|.
name|ds_base
operator|=
name|paddr
expr_stmt|;
name|ctrp
operator|=
operator|&
name|rq
operator|->
name|req_dataseg
index|[
name|rq
operator|->
name|req_seg_count
index|]
operator|.
name|ds_count
expr_stmt|;
block|}
name|nextpaddr
operator|=
name|paddr
expr_stmt|;
operator|*
operator|(
name|ctrp
operator|)
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|datalen
operator|!=
literal|0
operator|&&
name|paddr
operator|==
name|nextpaddr
condition|)
block|{
name|nextpaddr
operator|=
operator|(
name|paddr
operator|&
operator|(
operator|~
name|PAGE_MASK
operator|)
operator|)
operator|+
name|PAGE_SIZE
expr_stmt|;
name|size
operator|=
name|nextpaddr
operator|-
name|paddr
expr_stmt|;
if|if
condition|(
name|size
operator|>
name|datalen
condition|)
name|size
operator|=
name|datalen
expr_stmt|;
operator|*
operator|(
name|ctrp
operator|)
operator|+=
name|size
expr_stmt|;
name|vaddr
operator|+=
name|size
expr_stmt|;
name|datalen
operator|-=
name|size
expr_stmt|;
if|if
condition|(
name|datalen
operator|!=
literal|0
condition|)
name|paddr
operator|=
name|vtophys
argument_list|(
name|vaddr
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
literal|0
block|if (isp->isp_type& ISP_HA_FC) { 			ispreqt2_t *rq2 = (ispreqt2_t *)rq; 			printf("%s: seg0[%d] cnt 0x%x paddr 0x%08x\n", 			    isp->isp_name, rq->req_seg_count, 			    rq2->req_dataseg[rq2->req_seg_count].ds_count, 			    rq2->req_dataseg[rq2->req_seg_count].ds_base); 		} else { 			printf("%s: seg0[%d] cnt 0x%x paddr 0x%08x\n", 			    isp->isp_name, rq->req_seg_count, 			    rq->req_dataseg[rq->req_seg_count].ds_count, 			    rq->req_dataseg[rq->req_seg_count].ds_base); 		}
endif|#
directive|endif
name|rq
operator|->
name|req_seg_count
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|datalen
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|paddr
operator|=
name|vtophys
argument_list|(
name|vaddr
argument_list|)
expr_stmt|;
while|while
condition|(
name|datalen
operator|>
literal|0
condition|)
block|{
name|crq
operator|=
operator|(
name|ispcontreq_t
operator|*
operator|)
name|ISP_QUEUE_ENTRY
argument_list|(
name|isp
operator|->
name|isp_rquest
argument_list|,
operator|*
name|iptrp
argument_list|)
expr_stmt|;
operator|*
name|iptrp
operator|=
operator|(
operator|*
name|iptrp
operator|+
literal|1
operator|)
operator|&
operator|(
name|RQUEST_QUEUE_LEN
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
operator|*
name|iptrp
operator|==
name|optr
condition|)
block|{
name|printf
argument_list|(
literal|"%s: Request Queue Overflow\n"
argument_list|,
name|isp
operator|->
name|isp_name
argument_list|)
expr_stmt|;
name|XS_SETERR
argument_list|(
name|xs
argument_list|,
name|HBA_BOTCH
argument_list|)
expr_stmt|;
return|return
operator|(
name|EFBIG
operator|)
return|;
block|}
name|rq
operator|->
name|req_header
operator|.
name|rqs_entry_count
operator|++
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|void
operator|*
operator|)
name|crq
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|crq
argument_list|)
argument_list|)
expr_stmt|;
name|crq
operator|->
name|req_header
operator|.
name|rqs_entry_count
operator|=
literal|1
expr_stmt|;
name|crq
operator|->
name|req_header
operator|.
name|rqs_entry_type
operator|=
name|RQSTYPE_DATASEG
expr_stmt|;
for|for
control|(
name|seglim
operator|=
literal|0
init|;
name|datalen
operator|!=
literal|0
operator|&&
name|seglim
operator|<
name|ISP_CDSEG
condition|;
name|seglim
operator|++
control|)
block|{
name|crq
operator|->
name|req_dataseg
index|[
name|seglim
index|]
operator|.
name|ds_base
operator|=
name|paddr
expr_stmt|;
name|ctrp
operator|=
operator|&
name|crq
operator|->
name|req_dataseg
index|[
name|seglim
index|]
operator|.
name|ds_count
expr_stmt|;
operator|*
operator|(
name|ctrp
operator|)
operator|=
literal|0
expr_stmt|;
name|nextpaddr
operator|=
name|paddr
expr_stmt|;
while|while
condition|(
name|datalen
operator|!=
literal|0
operator|&&
name|paddr
operator|==
name|nextpaddr
condition|)
block|{
name|nextpaddr
operator|=
operator|(
name|paddr
operator|&
operator|(
operator|~
name|PAGE_MASK
operator|)
operator|)
operator|+
name|PAGE_SIZE
expr_stmt|;
name|size
operator|=
name|nextpaddr
operator|-
name|paddr
expr_stmt|;
if|if
condition|(
name|size
operator|>
name|datalen
condition|)
name|size
operator|=
name|datalen
expr_stmt|;
operator|*
operator|(
name|ctrp
operator|)
operator|+=
name|size
expr_stmt|;
name|vaddr
operator|+=
name|size
expr_stmt|;
name|datalen
operator|-=
name|size
expr_stmt|;
if|if
condition|(
name|datalen
operator|!=
literal|0
condition|)
name|paddr
operator|=
name|vtophys
argument_list|(
name|vaddr
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
literal|0
block|printf("%s: seg%d[%d] cnt 0x%x paddr 0x%08x\n", 			    isp->isp_name, rq->req_header.rqs_entry_count-1, 			    seglim, crq->req_dataseg[seglim].ds_count, 			    crq->req_dataseg[seglim].ds_base);
endif|#
directive|endif
name|rq
operator|->
name|req_seg_count
operator|++
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|isp_pci_reset1
parameter_list|(
name|isp
parameter_list|)
name|struct
name|ispsoftc
modifier|*
name|isp
decl_stmt|;
block|{
comment|/* Make sure the BIOS is disabled */
name|isp_pci_wr_reg
argument_list|(
name|isp
argument_list|,
name|HCCR
argument_list|,
name|PCI_HCCR_CMD_BIOS
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|isp_pci_dumpregs
parameter_list|(
name|isp
parameter_list|)
name|struct
name|ispsoftc
modifier|*
name|isp
decl_stmt|;
block|{
name|struct
name|isp_pcisoftc
modifier|*
name|pci
init|=
operator|(
expr|struct
name|isp_pcisoftc
operator|*
operator|)
name|isp
decl_stmt|;
name|printf
argument_list|(
literal|"%s: PCI Status Command/Status=%lx\n"
argument_list|,
name|pci
operator|->
name|pci_isp
operator|.
name|isp_name
argument_list|,
name|pci_conf_read
argument_list|(
name|pci
operator|->
name|pci_id
argument_list|,
name|PCI_COMMAND_STATUS_REG
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

