begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1995, David Greenman  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice unmodified, this list of conditions, and the following  *    disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *	$Id: if_fxp.c,v 1.8.2.8 1996/09/20 11:06:43 davidg Exp $  */
end_comment

begin_comment
comment|/*  * Intel EtherExpress Pro/100B PCI Fast Ethernet driver  */
end_comment

begin_include
include|#
directive|include
file|"bpfilter.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/devconf.h>
end_include

begin_include
include|#
directive|include
file|<sys/syslog.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_dl.h>
end_include

begin_include
include|#
directive|include
file|<net/if_types.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|INET
end_ifdef

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_systm.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip.h>
end_include

begin_include
include|#
directive|include
file|<netinet/if_ether.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|IPX
end_ifdef

begin_include
include|#
directive|include
file|<netipx/ipx.h>
end_include

begin_include
include|#
directive|include
file|<netipx/ipx_if.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|NS
end_ifdef

begin_include
include|#
directive|include
file|<netns/ns.h>
end_include

begin_include
include|#
directive|include
file|<netns/ns_if.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|NBPFILTER
operator|>
literal|0
end_if

begin_include
include|#
directive|include
file|<net/bpf.h>
end_include

begin_include
include|#
directive|include
file|<net/bpfdesc.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_comment
comment|/* for vtophys */
end_comment

begin_include
include|#
directive|include
file|<vm/vm_param.h>
end_include

begin_comment
comment|/* for vtophys */
end_comment

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_comment
comment|/* for vtophys */
end_comment

begin_include
include|#
directive|include
file|<machine/clock.h>
end_include

begin_comment
comment|/* for DELAY */
end_comment

begin_include
include|#
directive|include
file|<pci/pcivar.h>
end_include

begin_include
include|#
directive|include
file|<pci/if_fxpreg.h>
end_include

begin_struct
struct|struct
name|fxp_softc
block|{
name|struct
name|arpcom
name|arpcom
decl_stmt|;
comment|/* per-interface network data */
name|caddr_t
name|bpf
decl_stmt|;
comment|/* BPF token */
name|struct
name|fxp_csr
modifier|*
name|csr
decl_stmt|;
comment|/* control/status registers */
name|struct
name|fxp_cb_tx
modifier|*
name|cbl_base
decl_stmt|;
comment|/* base of TxCB list */
name|struct
name|fxp_cb_tx
modifier|*
name|cbl_first
decl_stmt|;
comment|/* first active TxCB in list */
name|struct
name|fxp_cb_tx
modifier|*
name|cbl_last
decl_stmt|;
comment|/* last active TxCB in list */
name|struct
name|mbuf
modifier|*
name|rfa_headm
decl_stmt|;
comment|/* first mbuf in receive frame area */
name|struct
name|mbuf
modifier|*
name|rfa_tailm
decl_stmt|;
comment|/* last mbuf in receive frame area */
name|struct
name|fxp_stats
modifier|*
name|fxp_stats
decl_stmt|;
comment|/* Pointer to interface stats */
name|int
name|tx_queued
decl_stmt|;
comment|/* # of active TxCB's */
name|int
name|promisc_mode
decl_stmt|;
comment|/* promiscuous mode enabled */
block|}
struct|;
end_struct

begin_include
include|#
directive|include
file|"fxp.h"
end_include

begin_decl_stmt
specifier|static
name|struct
name|fxp_softc
modifier|*
name|fxp_sc
index|[
name|NFXP
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* XXX Yuck */
end_comment

begin_decl_stmt
specifier|static
name|u_long
name|fxp_count
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Template for default configuration parameters.  * See struct fxp_cb_config for the bit definitions.  */
end_comment

begin_decl_stmt
specifier|static
name|u_char
name|fxp_cb_config_template
index|[]
init|=
block|{
literal|0x0
block|,
literal|0x0
block|,
comment|/* cb_status */
literal|0x80
block|,
literal|0x2
block|,
comment|/* cb_command */
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
comment|/* link_addr */
literal|0x16
block|,
comment|/*  0 */
literal|0x8
block|,
comment|/*  1 */
literal|0x0
block|,
comment|/*  2 */
literal|0x0
block|,
comment|/*  3 */
literal|0x0
block|,
comment|/*  4 */
literal|0x80
block|,
comment|/*  5 */
literal|0xb2
block|,
comment|/*  6 */
literal|0x3
block|,
comment|/*  7 */
literal|0x1
block|,
comment|/*  8 */
literal|0x0
block|,
comment|/*  9 */
literal|0x26
block|,
comment|/* 10 */
literal|0x0
block|,
comment|/* 11 */
literal|0x60
block|,
comment|/* 12 */
literal|0x0
block|,
comment|/* 13 */
literal|0xf2
block|,
comment|/* 14 */
literal|0x48
block|,
comment|/* 15 */
literal|0x0
block|,
comment|/* 16 */
literal|0x40
block|,
comment|/* 17 */
literal|0xf3
block|,
comment|/* 18 */
literal|0x0
block|,
comment|/* 19 */
literal|0x3f
block|,
comment|/* 20 */
literal|0x5
block|,
comment|/* 21 */
literal|0x0
block|,
literal|0x0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|inline
name|void
name|fxp_scb_wait
name|__P
argument_list|(
operator|(
expr|struct
name|fxp_csr
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|fxp_probe
name|__P
argument_list|(
operator|(
name|pcici_t
operator|,
name|pcidi_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|fxp_attach
name|__P
argument_list|(
operator|(
name|pcici_t
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|fxp_shutdown
name|__P
argument_list|(
operator|(
expr|struct
name|kern_devconf
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|fxp_intr
name|__P
argument_list|(
operator|(
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|fxp_start
name|__P
argument_list|(
operator|(
expr|struct
name|ifnet
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|fxp_ioctl
name|__P
argument_list|(
operator|(
expr|struct
name|ifnet
operator|*
operator|,
name|int
operator|,
name|caddr_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|fxp_init
name|__P
argument_list|(
operator|(
expr|struct
name|ifnet
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|fxp_stop
name|__P
argument_list|(
operator|(
expr|struct
name|fxp_softc
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|fxp_watchdog
name|__P
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|fxp_get_macaddr
name|__P
argument_list|(
operator|(
expr|struct
name|fxp_softc
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|fxp_add_rfabuf
name|__P
argument_list|(
operator|(
expr|struct
name|fxp_softc
operator|*
operator|,
expr|struct
name|mbuf
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|timeout_t
name|fxp_stats_update
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|pci_device
name|fxp_device
init|=
block|{
literal|"fxp"
block|,
name|fxp_probe
block|,
name|fxp_attach
block|,
operator|&
name|fxp_count
block|,
name|fxp_shutdown
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DATA_SET
argument_list|(
name|pcidevice_set
argument_list|,
name|fxp_device
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Set initial transmit threshold at 64 (512 bytes). This is  * increased by 64 (512 bytes) at a time, to maximum of 192  * (1536 bytes), if an underrun occurs.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|tx_threshold
init|=
literal|64
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Number of transmit control blocks. This determines the number  * of transmit buffers that can be chained in the CB list.  * This must be a power of two.  */
end_comment

begin_define
define|#
directive|define
name|FXP_NTXCB
value|128
end_define

begin_comment
comment|/*  * TxCB list index mask. This is used to do list wrap-around.  */
end_comment

begin_define
define|#
directive|define
name|FXP_TXCB_MASK
value|(FXP_NTXCB - 1)
end_define

begin_comment
comment|/*  * Number of DMA segments in a TxCB. Note that this is carefully  * chosen to make the total struct size an even power of two. It's  * critical that no TxCB be split across a page boundry since  * no attempt is made to allocate physically contiguous memory.  *   * XXX - don't forget to change the hard-coded constant in the  * fxp_cb_tx struct (defined in if_fxpreg.h), too!  */
end_comment

begin_define
define|#
directive|define
name|FXP_NTXSEG
value|29
end_define

begin_comment
comment|/*  * Number of receive frame area buffers. These are large so chose  * wisely.  */
end_comment

begin_define
define|#
directive|define
name|FXP_NRFABUFS
value|32
end_define

begin_comment
comment|/*  * Wait for the previous command to be accepted (but not necessarily  * completed).  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|fxp_scb_wait
parameter_list|(
name|csr
parameter_list|)
name|struct
name|fxp_csr
modifier|*
name|csr
decl_stmt|;
block|{
name|int
name|i
init|=
literal|10000
decl_stmt|;
while|while
condition|(
operator|(
name|csr
operator|->
name|scb_command
operator|&
name|FXP_SCB_COMMAND_MASK
operator|)
operator|&&
operator|--
name|i
condition|)
empty_stmt|;
block|}
end_function

begin_comment
comment|/*  * Return identification string if this is device is ours.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|fxp_probe
parameter_list|(
name|config_id
parameter_list|,
name|device_id
parameter_list|)
name|pcici_t
name|config_id
decl_stmt|;
name|pcidi_t
name|device_id
decl_stmt|;
block|{
if|if
condition|(
operator|(
operator|(
name|device_id
operator|&
literal|0xffff
operator|)
operator|==
name|FXP_VENDORID_INTEL
operator|)
operator|&&
operator|(
operator|(
name|device_id
operator|>>
literal|16
operator|)
operator|&
literal|0xffff
operator|)
operator|==
name|FXP_DEVICEID_i82557
condition|)
return|return
operator|(
literal|"Intel EtherExpress Pro/100B Fast Ethernet"
operator|)
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/*  * Allocate data structures and attach the device.  */
end_comment

begin_function
specifier|static
name|void
name|fxp_attach
parameter_list|(
name|config_id
parameter_list|,
name|unit
parameter_list|)
name|pcici_t
name|config_id
decl_stmt|;
name|int
name|unit
decl_stmt|;
block|{
name|struct
name|fxp_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|vm_offset_t
name|pbase
decl_stmt|;
name|int
name|s
decl_stmt|,
name|i
decl_stmt|;
name|sc
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|fxp_softc
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
return|return;
name|bzero
argument_list|(
name|sc
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|fxp_softc
argument_list|)
argument_list|)
expr_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
comment|/* 	 * Map control/status registers. 	 */
if|if
condition|(
operator|!
name|pci_map_mem
argument_list|(
name|config_id
argument_list|,
name|FXP_PCI_MMBA
argument_list|,
operator|(
name|vm_offset_t
operator|*
operator|)
operator|&
name|sc
operator|->
name|csr
argument_list|,
operator|&
name|pbase
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"fxp%d: couldn't map memory\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* 	 * Issue a software reset. 	 */
name|sc
operator|->
name|csr
operator|->
name|port
operator|=
literal|0
expr_stmt|;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
comment|/* 	 * Allocate our interrupt. 	 */
if|if
condition|(
operator|!
name|pci_map_int
argument_list|(
name|config_id
argument_list|,
name|fxp_intr
argument_list|,
name|sc
argument_list|,
operator|&
name|net_imask
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"fxp%d: couldn't map interrupt\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|sc
operator|->
name|cbl_base
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|fxp_cb_tx
argument_list|)
operator|*
name|FXP_NTXCB
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|cbl_base
operator|==
name|NULL
condition|)
goto|goto
name|malloc_fail
goto|;
name|sc
operator|->
name|fxp_stats
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|fxp_stats
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|fxp_stats
operator|==
name|NULL
condition|)
goto|goto
name|malloc_fail
goto|;
name|bzero
argument_list|(
name|sc
operator|->
name|fxp_stats
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|fxp_stats
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Pre-allocate our receive buffers. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FXP_NRFABUFS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|fxp_add_rfabuf
argument_list|(
name|sc
argument_list|,
name|NULL
argument_list|)
operator|!=
literal|0
condition|)
block|{
goto|goto
name|malloc_fail
goto|;
block|}
block|}
name|fxp_sc
index|[
name|unit
index|]
operator|=
name|sc
expr_stmt|;
name|ifp
operator|=
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
expr_stmt|;
name|ifp
operator|->
name|if_unit
operator|=
name|unit
expr_stmt|;
name|ifp
operator|->
name|if_name
operator|=
literal|"fxp"
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|=
name|IFF_BROADCAST
operator||
name|IFF_SIMPLEX
operator||
name|IFF_MULTICAST
expr_stmt|;
name|ifp
operator|->
name|if_ioctl
operator|=
name|fxp_ioctl
expr_stmt|;
name|ifp
operator|->
name|if_output
operator|=
name|ether_output
expr_stmt|;
name|ifp
operator|->
name|if_start
operator|=
name|fxp_start
expr_stmt|;
name|ifp
operator|->
name|if_watchdog
operator|=
name|fxp_watchdog
expr_stmt|;
name|ifp
operator|->
name|if_baudrate
operator|=
literal|100000000
expr_stmt|;
name|fxp_get_macaddr
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"fxp%d: Ethernet address %s\n"
argument_list|,
name|unit
argument_list|,
name|ether_sprintf
argument_list|(
name|sc
operator|->
name|arpcom
operator|.
name|ac_enaddr
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Attach the interface. 	 */
name|if_attach
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
if|#
directive|if
name|NBPFILTER
operator|>
literal|0
name|bpfattach
argument_list|(
operator|&
name|sc
operator|->
name|bpf
argument_list|,
name|ifp
argument_list|,
name|DLT_EN10MB
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
name|malloc_fail
label|:
name|printf
argument_list|(
literal|"fxp%d: Failed to malloc memory\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|pci_unmap_int
argument_list|(
name|config_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|&&
name|sc
operator|->
name|cbl_base
condition|)
name|free
argument_list|(
name|sc
operator|->
name|cbl_base
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|&&
name|sc
operator|->
name|fxp_stats
condition|)
name|free
argument_list|(
name|sc
operator|->
name|fxp_stats
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
comment|/* frees entire chain */
if|if
condition|(
name|sc
operator|&&
name|sc
operator|->
name|rfa_headm
condition|)
name|m_freem
argument_list|(
name|sc
operator|->
name|rfa_headm
argument_list|)
expr_stmt|;
name|fail
label|:
if|if
condition|(
name|sc
condition|)
name|free
argument_list|(
name|sc
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Read station (MAC) address from serial EEPROM. Basically, you  * manually shift in the read opcode (one bit at a time) and then  * shift in the address, and then you shift out the data (all of  * this one bit at a time). The word size is 16 bits, so you have  * to provide the address for every 16 bits of data. The MAC address  * is in the first 3 words (6 bytes total).  */
end_comment

begin_function
specifier|static
name|void
name|fxp_get_macaddr
parameter_list|(
name|sc
parameter_list|)
name|struct
name|fxp_softc
modifier|*
name|sc
decl_stmt|;
block|{
name|struct
name|fxp_csr
modifier|*
name|csr
decl_stmt|;
name|u_short
name|reg
decl_stmt|,
modifier|*
name|data
decl_stmt|;
name|int
name|i
decl_stmt|,
name|x
decl_stmt|;
name|csr
operator|=
name|sc
operator|->
name|csr
expr_stmt|;
name|data
operator|=
operator|(
name|u_short
operator|*
operator|)
name|sc
operator|->
name|arpcom
operator|.
name|ac_enaddr
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
name|i
operator|++
control|)
block|{
name|csr
operator|->
name|eeprom_control
operator|=
name|FXP_EEPROM_EECS
expr_stmt|;
comment|/* 		 * Shift in read opcode. 		 */
for|for
control|(
name|x
operator|=
literal|3
init|;
name|x
operator|>
literal|0
condition|;
name|x
operator|--
control|)
block|{
if|if
condition|(
name|FXP_EEPROM_OPC_READ
operator|&
operator|(
literal|1
operator|<<
operator|(
name|x
operator|-
literal|1
operator|)
operator|)
condition|)
block|{
name|reg
operator|=
name|FXP_EEPROM_EECS
operator||
name|FXP_EEPROM_EEDI
expr_stmt|;
block|}
else|else
block|{
name|reg
operator|=
name|FXP_EEPROM_EECS
expr_stmt|;
block|}
name|csr
operator|->
name|eeprom_control
operator|=
name|reg
expr_stmt|;
name|csr
operator|->
name|eeprom_control
operator|=
name|reg
operator||
name|FXP_EEPROM_EESK
expr_stmt|;
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|csr
operator|->
name|eeprom_control
operator|=
name|reg
expr_stmt|;
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Shift in address. 		 */
for|for
control|(
name|x
operator|=
literal|6
init|;
name|x
operator|>
literal|0
condition|;
name|x
operator|--
control|)
block|{
if|if
condition|(
name|i
operator|&
operator|(
literal|1
operator|<<
operator|(
name|x
operator|-
literal|1
operator|)
operator|)
condition|)
block|{
name|reg
operator|=
name|FXP_EEPROM_EECS
operator||
name|FXP_EEPROM_EEDI
expr_stmt|;
block|}
else|else
block|{
name|reg
operator|=
name|FXP_EEPROM_EECS
expr_stmt|;
block|}
name|csr
operator|->
name|eeprom_control
operator|=
name|reg
expr_stmt|;
name|csr
operator|->
name|eeprom_control
operator|=
name|reg
operator||
name|FXP_EEPROM_EESK
expr_stmt|;
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|csr
operator|->
name|eeprom_control
operator|=
name|reg
expr_stmt|;
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|reg
operator|=
name|FXP_EEPROM_EECS
expr_stmt|;
name|data
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
comment|/* 		 * Shift out data. 		 */
for|for
control|(
name|x
operator|=
literal|16
init|;
name|x
operator|>
literal|0
condition|;
name|x
operator|--
control|)
block|{
name|csr
operator|->
name|eeprom_control
operator|=
name|reg
operator||
name|FXP_EEPROM_EESK
expr_stmt|;
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|csr
operator|->
name|eeprom_control
operator|&
name|FXP_EEPROM_EEDO
condition|)
name|data
index|[
name|i
index|]
operator||=
operator|(
literal|1
operator|<<
operator|(
name|x
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
name|csr
operator|->
name|eeprom_control
operator|=
name|reg
expr_stmt|;
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|csr
operator|->
name|eeprom_control
operator|=
literal|0
expr_stmt|;
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Device shutdown routine. Usually called at system shutdown. The  * main purpose of this routine is to shut off receiver DMA so that  * kernel memory doesn't get clobbered during warmboot.  */
end_comment

begin_function
specifier|static
name|int
name|fxp_shutdown
parameter_list|(
name|kdc
parameter_list|,
name|force
parameter_list|)
name|struct
name|kern_devconf
modifier|*
name|kdc
decl_stmt|;
name|int
name|force
decl_stmt|;
block|{
name|struct
name|fxp_softc
modifier|*
name|sc
init|=
name|fxp_sc
index|[
name|kdc
operator|->
name|kdc_unit
index|]
decl_stmt|;
name|fxp_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|dev_detach
argument_list|(
name|kdc
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Start packet transmission on the interface.  */
end_comment

begin_function
specifier|static
name|void
name|fxp_start
parameter_list|(
name|ifp
parameter_list|)
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
block|{
name|struct
name|fxp_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|fxp_softc
operator|*
operator|)
name|ifp
decl_stmt|;
name|struct
name|fxp_csr
modifier|*
name|csr
init|=
name|sc
operator|->
name|csr
decl_stmt|;
name|struct
name|fxp_cb_tx
modifier|*
name|txp
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|,
modifier|*
name|mb_head
decl_stmt|;
name|int
name|segment
decl_stmt|;
name|txloop
label|:
comment|/* 	 * See if we're all filled up with buffers to transmit. 	 */
if|if
condition|(
name|sc
operator|->
name|tx_queued
operator|>=
name|FXP_NTXCB
condition|)
return|return;
comment|/* 	 * Grab a packet to transmit. 	 */
name|IF_DEQUEUE
argument_list|(
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_snd
argument_list|,
name|mb_head
argument_list|)
expr_stmt|;
if|if
condition|(
name|mb_head
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * No more packets to send. 		 */
return|return;
block|}
comment|/* 	 * Get pointer to next available (unused) descriptor. 	 */
name|txp
operator|=
name|sc
operator|->
name|cbl_last
operator|->
name|next
expr_stmt|;
comment|/* 	 * Go through each of the mbufs in the chain and initialize 	 * the transmit buffers descriptors with the physical address 	 * and size of the mbuf. 	 */
name|tbdinit
label|:
for|for
control|(
name|m
operator|=
name|mb_head
operator|,
name|segment
operator|=
literal|0
init|;
name|m
operator|!=
name|NULL
condition|;
name|m
operator|=
name|m
operator|->
name|m_next
control|)
block|{
if|if
condition|(
name|m
operator|->
name|m_len
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|segment
operator|==
name|FXP_NTXSEG
condition|)
break|break;
name|txp
operator|->
name|tbd
index|[
name|segment
index|]
operator|.
name|tb_addr
operator|=
name|vtophys
argument_list|(
name|mtod
argument_list|(
name|m
argument_list|,
name|vm_offset_t
argument_list|)
argument_list|)
expr_stmt|;
name|txp
operator|->
name|tbd
index|[
name|segment
index|]
operator|.
name|tb_size
operator|=
name|m
operator|->
name|m_len
expr_stmt|;
name|segment
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|m
operator|!=
name|NULL
operator|&&
name|segment
operator|==
name|FXP_NTXSEG
condition|)
block|{
name|struct
name|mbuf
modifier|*
name|mn
decl_stmt|;
comment|/* 		 * We ran out of segments. We have to recopy this mbuf 		 * chain first. 		 */
name|MGETHDR
argument_list|(
name|mn
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|mn
operator|==
name|NULL
condition|)
block|{
name|m_freem
argument_list|(
name|mb_head
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|mb_head
operator|->
name|m_pkthdr
operator|.
name|len
operator|>
name|MHLEN
condition|)
block|{
name|MCLGET
argument_list|(
name|mn
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|mn
operator|->
name|m_flags
operator|&
name|M_EXT
operator|)
operator|==
literal|0
condition|)
block|{
name|m_freem
argument_list|(
name|mn
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|mb_head
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|m_copydata
argument_list|(
name|mb_head
argument_list|,
literal|0
argument_list|,
name|mb_head
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|,
name|mtod
argument_list|(
name|mn
argument_list|,
name|caddr_t
argument_list|)
argument_list|)
expr_stmt|;
name|mn
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|mn
operator|->
name|m_len
operator|=
name|mb_head
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
name|m_freem
argument_list|(
name|mb_head
argument_list|)
expr_stmt|;
name|mb_head
operator|=
name|mn
expr_stmt|;
goto|goto
name|tbdinit
goto|;
block|}
name|txp
operator|->
name|tbd_number
operator|=
name|segment
expr_stmt|;
name|txp
operator|->
name|mb_head
operator|=
name|mb_head
expr_stmt|;
comment|/* 	 * Finish the initialization of this TxCB. 	 */
name|txp
operator|->
name|cb_status
operator|=
literal|0
expr_stmt|;
name|txp
operator|->
name|cb_command
operator|=
name|FXP_CB_COMMAND_XMIT
operator||
name|FXP_CB_COMMAND_SF
operator||
name|FXP_CB_COMMAND_S
expr_stmt|;
name|txp
operator|->
name|tx_threshold
operator|=
name|tx_threshold
expr_stmt|;
comment|/* 	 * Advance the end-of-list forward. 	 */
name|sc
operator|->
name|cbl_last
operator|->
name|cb_command
operator|&=
operator|~
name|FXP_CB_COMMAND_S
expr_stmt|;
name|sc
operator|->
name|cbl_last
operator|=
name|txp
expr_stmt|;
comment|/* 	 * Advance the beginning of the list forward if there are 	 * no other packets queued (when nothing is queued, cbl_first 	 * sits on the last TxCB that was sent out).. 	 */
if|if
condition|(
name|sc
operator|->
name|tx_queued
operator|==
literal|0
condition|)
name|sc
operator|->
name|cbl_first
operator|=
name|txp
expr_stmt|;
name|sc
operator|->
name|tx_queued
operator|++
expr_stmt|;
if|if
condition|(
name|csr
operator|->
name|scb_cus
operator|==
name|FXP_SCB_CUS_SUSPENDED
condition|)
block|{
name|fxp_scb_wait
argument_list|(
name|csr
argument_list|)
expr_stmt|;
comment|/* 		 * Resume transmission. 		 */
name|csr
operator|->
name|scb_command
operator|=
name|FXP_SCB_COMMAND_CU_RESUME
expr_stmt|;
block|}
if|#
directive|if
name|NBPFILTER
operator|>
literal|0
comment|/* 	 * Pass packet to bpf if there is a listener. 	 */
if|if
condition|(
name|sc
operator|->
name|bpf
operator|!=
name|NULL
condition|)
name|bpf_mtap
argument_list|(
name|sc
operator|->
name|bpf
argument_list|,
name|mb_head
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Set a 5 second timer just in case we don't hear from the 	 * card again. 	 */
name|ifp
operator|->
name|if_timer
operator|=
literal|5
expr_stmt|;
goto|goto
name|txloop
goto|;
block|}
end_function

begin_comment
comment|/*  * Process interface interrupts. Returns 1 if the interrupt  * was handled, 0 if it wasn't.  */
end_comment

begin_function
specifier|static
name|int
name|fxp_intr
parameter_list|(
name|arg
parameter_list|)
name|void
modifier|*
name|arg
decl_stmt|;
block|{
name|struct
name|fxp_softc
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
name|struct
name|fxp_csr
modifier|*
name|csr
init|=
name|sc
operator|->
name|csr
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
decl_stmt|;
name|int
name|found
init|=
literal|0
decl_stmt|;
name|u_int8_t
name|statack
decl_stmt|;
while|while
condition|(
operator|(
name|statack
operator|=
name|csr
operator|->
name|scb_statack
operator|)
operator|!=
literal|0
condition|)
block|{
name|found
operator|=
literal|1
expr_stmt|;
comment|/* 		 * First ACK all the interrupts in this pass. 		 */
name|csr
operator|->
name|scb_statack
operator|=
name|statack
expr_stmt|;
comment|/* 		 * Free any finished transmit mbuf chains. 		 */
if|if
condition|(
name|statack
operator|&
name|FXP_SCB_STATACK_CNA
condition|)
block|{
name|struct
name|fxp_cb_tx
modifier|*
name|txp
decl_stmt|;
for|for
control|(
name|txp
operator|=
name|sc
operator|->
name|cbl_first
init|;
operator|(
name|txp
operator|->
name|cb_status
operator|&
name|FXP_CB_STATUS_C
operator|)
operator|!=
literal|0
condition|;
name|txp
operator|=
name|txp
operator|->
name|next
control|)
block|{
if|if
condition|(
name|txp
operator|->
name|mb_head
operator|!=
name|NULL
condition|)
block|{
name|m_freem
argument_list|(
name|txp
operator|->
name|mb_head
argument_list|)
expr_stmt|;
name|txp
operator|->
name|mb_head
operator|=
name|NULL
expr_stmt|;
name|sc
operator|->
name|tx_queued
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|txp
operator|->
name|cb_command
operator|&
name|FXP_CB_COMMAND_S
condition|)
break|break;
block|}
name|sc
operator|->
name|cbl_first
operator|=
name|txp
expr_stmt|;
comment|/* 			 * Clear watchdog timer. It may or may not be set 			 * again in fxp_start(). 			 */
name|ifp
operator|->
name|if_timer
operator|=
literal|0
expr_stmt|;
name|fxp_start
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Process receiver interrupts. If a no-resource (RNR) 		 * condition exists, get whatever packets we can and 		 * re-start the receiver. 		 */
if|if
condition|(
name|statack
operator|&
operator|(
name|FXP_SCB_STATACK_FR
operator||
name|FXP_SCB_STATACK_RNR
operator|)
condition|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|fxp_rfa
modifier|*
name|rfa
decl_stmt|;
name|rcvloop
label|:
name|m
operator|=
name|sc
operator|->
name|rfa_headm
expr_stmt|;
name|rfa
operator|=
operator|(
expr|struct
name|fxp_rfa
operator|*
operator|)
name|m
operator|->
name|m_ext
operator|.
name|ext_buf
expr_stmt|;
if|if
condition|(
name|rfa
operator|->
name|rfa_status
operator|&
name|FXP_RFA_STATUS_C
condition|)
block|{
comment|/* 				 * Remove first packet from the chain. 				 */
name|sc
operator|->
name|rfa_headm
operator|=
name|m
operator|->
name|m_next
expr_stmt|;
name|m
operator|->
name|m_next
operator|=
name|NULL
expr_stmt|;
comment|/* 				 * Add a new buffer to the receive chain. If this 				 * fails, the old buffer is recycled instead. 				 */
if|if
condition|(
name|fxp_add_rfabuf
argument_list|(
name|sc
argument_list|,
name|m
argument_list|)
operator|==
literal|0
condition|)
block|{
name|struct
name|ether_header
modifier|*
name|eh
decl_stmt|;
name|u_short
name|total_len
decl_stmt|;
name|total_len
operator|=
name|rfa
operator|->
name|actual_size
operator|&
operator|(
name|MCLBYTES
operator|-
literal|1
operator|)
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|ifp
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|m
operator|->
name|m_len
operator|=
name|total_len
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
expr_stmt|;
name|eh
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ether_header
operator|*
argument_list|)
expr_stmt|;
if|#
directive|if
name|NBPFILTER
operator|>
literal|0
if|if
condition|(
name|sc
operator|->
name|bpf
operator|!=
name|NULL
condition|)
block|{
name|bpf_tap
argument_list|(
name|sc
operator|->
name|bpf
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
name|total_len
argument_list|)
expr_stmt|;
comment|/* 						 * Only pass this packet up if it is for us. 						 */
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_PROMISC
operator|)
operator|&&
operator|(
name|rfa
operator|->
name|rfa_status
operator|&
name|FXP_RFA_STATUS_IAMATCH
operator|)
operator|&&
operator|(
name|eh
operator|->
name|ether_dhost
index|[
literal|0
index|]
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
goto|goto
name|rcvloop
goto|;
block|}
block|}
endif|#
directive|endif
name|m
operator|->
name|m_data
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
expr_stmt|;
name|ether_input
argument_list|(
name|ifp
argument_list|,
name|eh
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
goto|goto
name|rcvloop
goto|;
block|}
if|if
condition|(
name|statack
operator|&
name|FXP_SCB_STATACK_RNR
condition|)
block|{
name|struct
name|fxp_csr
modifier|*
name|csr
init|=
name|sc
operator|->
name|csr
decl_stmt|;
name|fxp_scb_wait
argument_list|(
name|csr
argument_list|)
expr_stmt|;
name|csr
operator|->
name|scb_general
operator|=
name|vtophys
argument_list|(
name|sc
operator|->
name|rfa_headm
operator|->
name|m_ext
operator|.
name|ext_buf
argument_list|)
expr_stmt|;
name|csr
operator|->
name|scb_command
operator|=
name|FXP_SCB_COMMAND_RU_START
expr_stmt|;
block|}
block|}
block|}
return|return
name|found
return|;
block|}
end_function

begin_comment
comment|/*  * Update packet in/out/collision statistics. The i82557 doesn't  * allow you to access these counters without doing a fairly  * expensive DMA to get _all_ of the statistics it maintains, so  * we do this operation here only once per second. The statistics  * counters in the kernel are updated from the previous dump-stats  * DMA and then a new dump-stats DMA is started. The on-chip  * counters are zeroed when the DMA completes. If we can't start  * the DMA immediately, we don't wait - we just prepare to read  * them again next time.  */
end_comment

begin_function
name|void
name|fxp_stats_update
parameter_list|(
name|arg
parameter_list|)
name|void
modifier|*
name|arg
decl_stmt|;
block|{
name|struct
name|fxp_softc
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
decl_stmt|;
name|struct
name|fxp_stats
modifier|*
name|sp
init|=
name|sc
operator|->
name|fxp_stats
decl_stmt|;
name|ifp
operator|->
name|if_opackets
operator|+=
name|sp
operator|->
name|tx_good
expr_stmt|;
name|ifp
operator|->
name|if_collisions
operator|+=
name|sp
operator|->
name|tx_total_collisions
expr_stmt|;
name|ifp
operator|->
name|if_ipackets
operator|+=
name|sp
operator|->
name|rx_good
expr_stmt|;
name|ifp
operator|->
name|if_ierrors
operator|+=
name|sp
operator|->
name|rx_crc_errors
operator|+
name|sp
operator|->
name|rx_alignment_errors
operator|+
name|sp
operator|->
name|rx_rnr_errors
operator|+
name|sp
operator|->
name|rx_overrun_errors
operator|+
name|sp
operator|->
name|rx_shortframes
expr_stmt|;
comment|/* 	 * If any transmit underruns occured, bump up the transmit 	 * threshold by another 512 bytes (64 * 8). 	 */
if|if
condition|(
name|sp
operator|->
name|tx_underruns
condition|)
block|{
name|ifp
operator|->
name|if_oerrors
operator|+=
name|sp
operator|->
name|tx_underruns
expr_stmt|;
if|if
condition|(
name|tx_threshold
operator|<
literal|192
condition|)
name|tx_threshold
operator|+=
literal|64
expr_stmt|;
block|}
comment|/* 	 * If there is no pending command, start another stats 	 * dump. Otherwise punt for now. 	 */
if|if
condition|(
operator|(
name|sc
operator|->
name|csr
operator|->
name|scb_command
operator|&
name|FXP_SCB_COMMAND_MASK
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 		 * Start another stats dump. By waiting for it to be 		 * accepted, we avoid having to do splhigh locking when 		 * writing scb_command in other parts of the driver. 		 */
name|sc
operator|->
name|csr
operator|->
name|scb_command
operator|=
name|FXP_SCB_COMMAND_CU_DUMPRESET
expr_stmt|;
name|fxp_scb_wait
argument_list|(
name|sc
operator|->
name|csr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * A previous command is still waiting to be accepted. 		 * Just zero our copy of the stats and wait for the 		 * next timer event to update them. 		 */
name|sp
operator|->
name|tx_good
operator|=
literal|0
expr_stmt|;
name|sp
operator|->
name|tx_underruns
operator|=
literal|0
expr_stmt|;
name|sp
operator|->
name|tx_total_collisions
operator|=
literal|0
expr_stmt|;
name|sp
operator|->
name|rx_good
operator|=
literal|0
expr_stmt|;
name|sp
operator|->
name|rx_crc_errors
operator|=
literal|0
expr_stmt|;
name|sp
operator|->
name|rx_alignment_errors
operator|=
literal|0
expr_stmt|;
name|sp
operator|->
name|rx_rnr_errors
operator|=
literal|0
expr_stmt|;
name|sp
operator|->
name|rx_overrun_errors
operator|=
literal|0
expr_stmt|;
name|sp
operator|->
name|rx_shortframes
operator|=
literal|0
expr_stmt|;
empty_stmt|;
block|}
comment|/* 	 * Schedule another timeout one second from now. 	 */
name|timeout
argument_list|(
name|fxp_stats_update
argument_list|,
name|sc
argument_list|,
name|hz
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Stop the interface. Cancels the statistics updater and resets  * the interface.  */
end_comment

begin_function
specifier|static
name|void
name|fxp_stop
parameter_list|(
name|sc
parameter_list|)
name|struct
name|fxp_softc
modifier|*
name|sc
decl_stmt|;
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
decl_stmt|;
name|struct
name|fxp_cb_tx
modifier|*
name|txp
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* 	 * Cancel stats updater. 	 */
name|untimeout
argument_list|(
name|fxp_stats_update
argument_list|,
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * Issue software reset 	 */
name|sc
operator|->
name|csr
operator|->
name|port
operator|=
literal|0
expr_stmt|;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
comment|/* 	 * Release any xmit buffers. 	 */
for|for
control|(
name|txp
operator|=
name|sc
operator|->
name|cbl_first
init|;
name|txp
operator|!=
name|NULL
operator|&&
name|txp
operator|->
name|mb_head
operator|!=
name|NULL
condition|;
name|txp
operator|=
name|txp
operator|->
name|next
control|)
block|{
name|m_freem
argument_list|(
name|txp
operator|->
name|mb_head
argument_list|)
expr_stmt|;
name|txp
operator|->
name|mb_head
operator|=
name|NULL
expr_stmt|;
block|}
name|sc
operator|->
name|tx_queued
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Free all the receive buffers then reallocate/reinitialize 	 */
if|if
condition|(
name|sc
operator|->
name|rfa_headm
operator|!=
name|NULL
condition|)
name|m_freem
argument_list|(
name|sc
operator|->
name|rfa_headm
argument_list|)
expr_stmt|;
name|sc
operator|->
name|rfa_headm
operator|=
name|NULL
expr_stmt|;
name|sc
operator|->
name|rfa_tailm
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FXP_NRFABUFS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|fxp_add_rfabuf
argument_list|(
name|sc
argument_list|,
name|NULL
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* 			 * This "can't happen" - we're at splimp() 			 * and we just freed all the buffers we need 			 * above. 			 */
name|panic
argument_list|(
literal|"fxp_stop: no buffers!"
argument_list|)
expr_stmt|;
block|}
block|}
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
operator|(
name|IFF_RUNNING
operator||
name|IFF_OACTIVE
operator|)
expr_stmt|;
name|ifp
operator|->
name|if_timer
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Watchdog/transmission transmit timeout handler. Called when a  * transmission is started on the interface, but no interrupt is  * received before the timeout. This usually indicates that the  * card has wedged for some reason.  */
end_comment

begin_function
specifier|static
name|void
name|fxp_watchdog
parameter_list|(
name|unit
parameter_list|)
name|int
name|unit
decl_stmt|;
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
operator|(
expr|struct
name|ifnet
operator|*
operator|)
name|fxp_sc
index|[
name|unit
index|]
decl_stmt|;
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"fxp%d: device timeout\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_oerrors
operator|++
expr_stmt|;
name|fxp_init
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|fxp_init
parameter_list|(
name|ifp
parameter_list|)
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
block|{
name|struct
name|fxp_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|fxp_softc
operator|*
operator|)
name|ifp
decl_stmt|;
name|struct
name|fxp_cb_config
modifier|*
name|cbp
decl_stmt|;
name|struct
name|fxp_cb_ias
modifier|*
name|cb_ias
decl_stmt|;
name|struct
name|fxp_cb_tx
modifier|*
name|txp
decl_stmt|;
name|struct
name|fxp_csr
modifier|*
name|csr
init|=
name|sc
operator|->
name|csr
decl_stmt|;
name|int
name|i
decl_stmt|,
name|s
decl_stmt|,
name|mcast
decl_stmt|,
name|prm
decl_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
comment|/* 	 * Cancel any pending I/O 	 */
name|fxp_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|prm
operator|=
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_PROMISC
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|sc
operator|->
name|promisc_mode
operator|=
name|prm
expr_stmt|;
comment|/* 	 * Sleeze out here and enable reception of all multicasts if 	 * multicasts are enabled. Ideally, we'd program the multicast 	 * address filter to only accept specific multicasts. 	 */
name|mcast
operator|=
operator|(
name|ifp
operator|->
name|if_flags
operator|&
operator|(
name|IFF_MULTICAST
operator||
name|IFF_ALLMULTI
operator|)
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
comment|/* 	 * Initialize base of CBL and RFA memory. Loading with zero 	 * sets it up for regular linear addressing. 	 */
name|csr
operator|->
name|scb_general
operator|=
literal|0
expr_stmt|;
name|csr
operator|->
name|scb_command
operator|=
name|FXP_SCB_COMMAND_CU_BASE
expr_stmt|;
name|fxp_scb_wait
argument_list|(
name|csr
argument_list|)
expr_stmt|;
name|csr
operator|->
name|scb_command
operator|=
name|FXP_SCB_COMMAND_RU_BASE
expr_stmt|;
comment|/* 	 * Initialize base of dump-stats buffer. 	 */
name|fxp_scb_wait
argument_list|(
name|csr
argument_list|)
expr_stmt|;
name|csr
operator|->
name|scb_general
operator|=
name|vtophys
argument_list|(
name|sc
operator|->
name|fxp_stats
argument_list|)
expr_stmt|;
name|csr
operator|->
name|scb_command
operator|=
name|FXP_SCB_COMMAND_CU_DUMP_ADR
expr_stmt|;
comment|/* 	 * We temporarily use memory that contains the TxCB list to 	 * construct the config CB. The TxCB list memory is rebuilt 	 * later. 	 */
name|cbp
operator|=
operator|(
expr|struct
name|fxp_cb_config
operator|*
operator|)
name|sc
operator|->
name|cbl_base
expr_stmt|;
comment|/* 	 * This bcopy is kind of disgusting, but there are a bunch of must be 	 * zero and must be one bits in this structure and this is the easiest 	 * way to initialize them all to proper values. 	 */
name|bcopy
argument_list|(
name|fxp_cb_config_template
argument_list|,
name|cbp
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|fxp_cb_config
argument_list|)
argument_list|)
expr_stmt|;
name|cbp
operator|->
name|cb_status
operator|=
literal|0
expr_stmt|;
name|cbp
operator|->
name|cb_command
operator|=
name|FXP_CB_COMMAND_CONFIG
operator||
name|FXP_CB_COMMAND_EL
expr_stmt|;
name|cbp
operator|->
name|link_addr
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* (no) next command */
name|cbp
operator|->
name|byte_count
operator|=
literal|22
expr_stmt|;
comment|/* (22) bytes to config */
name|cbp
operator|->
name|rx_fifo_limit
operator|=
literal|8
expr_stmt|;
comment|/* rx fifo threshold */
name|cbp
operator|->
name|tx_fifo_limit
operator|=
literal|0
expr_stmt|;
comment|/* tx fifo threshold */
name|cbp
operator|->
name|adaptive_ifs
operator|=
literal|0
expr_stmt|;
comment|/* (no) adaptive interframe spacing */
name|cbp
operator|->
name|rx_dma_bytecount
operator|=
literal|16
expr_stmt|;
comment|/* (no) rx DMA max */
name|cbp
operator|->
name|tx_dma_bytecount
operator|=
literal|16
expr_stmt|;
comment|/* (no) tx DMA max */
name|cbp
operator|->
name|dma_bce
operator|=
literal|1
expr_stmt|;
comment|/* (enable) dma max counters */
name|cbp
operator|->
name|late_scb
operator|=
literal|0
expr_stmt|;
comment|/* (don't) defer SCB update */
name|cbp
operator|->
name|tno_int
operator|=
literal|0
expr_stmt|;
comment|/* (disable) tx not okay interrupt */
name|cbp
operator|->
name|ci_int
operator|=
literal|0
expr_stmt|;
comment|/* (do) interrupt on CU not active */
name|cbp
operator|->
name|save_bf
operator|=
name|prm
expr_stmt|;
comment|/* save bad frames */
name|cbp
operator|->
name|disc_short_rx
operator|=
operator|!
name|prm
expr_stmt|;
comment|/* discard short packets */
name|cbp
operator|->
name|underrun_retry
operator|=
literal|1
expr_stmt|;
comment|/* retry mode (1) on DMA underrun */
name|cbp
operator|->
name|mediatype
operator|=
literal|1
expr_stmt|;
comment|/* (MII) interface mode */
name|cbp
operator|->
name|nsai
operator|=
literal|1
expr_stmt|;
comment|/* (don't) disable source addr insert */
name|cbp
operator|->
name|preamble_length
operator|=
literal|2
expr_stmt|;
comment|/* (7 byte) preamble */
name|cbp
operator|->
name|loopback
operator|=
literal|0
expr_stmt|;
comment|/* (don't) loopback */
name|cbp
operator|->
name|linear_priority
operator|=
literal|0
expr_stmt|;
comment|/* (normal CSMA/CD operation) */
name|cbp
operator|->
name|linear_pri_mode
operator|=
literal|0
expr_stmt|;
comment|/* (wait after xmit only) */
name|cbp
operator|->
name|interfrm_spacing
operator|=
literal|6
expr_stmt|;
comment|/* (96 bits of) interframe spacing */
name|cbp
operator|->
name|promiscuous
operator|=
name|prm
expr_stmt|;
comment|/* promiscuous mode */
name|cbp
operator|->
name|bcast_disable
operator|=
literal|0
expr_stmt|;
comment|/* (don't) disable broadcasts */
name|cbp
operator|->
name|crscdt
operator|=
literal|0
expr_stmt|;
comment|/* (CRS only) */
name|cbp
operator|->
name|stripping
operator|=
operator|!
name|prm
expr_stmt|;
comment|/* truncate rx packet to byte count */
name|cbp
operator|->
name|padding
operator|=
literal|1
expr_stmt|;
comment|/* (do) pad short tx packets */
name|cbp
operator|->
name|rcv_crc_xfer
operator|=
literal|0
expr_stmt|;
comment|/* (don't) xfer CRC to host */
name|cbp
operator|->
name|force_fdx
operator|=
literal|0
expr_stmt|;
comment|/* (don't) force full duplex */
name|cbp
operator|->
name|fdx_pin_en
operator|=
literal|1
expr_stmt|;
comment|/* (enable) FDX# pin */
name|cbp
operator|->
name|multi_ia
operator|=
literal|0
expr_stmt|;
comment|/* (don't) accept multiple IAs */
name|cbp
operator|->
name|mc_all
operator|=
name|mcast
expr_stmt|;
comment|/* accept all multicasts */
comment|/* 	 * Start the config command/DMA. 	 */
name|fxp_scb_wait
argument_list|(
name|csr
argument_list|)
expr_stmt|;
name|csr
operator|->
name|scb_general
operator|=
name|vtophys
argument_list|(
name|cbp
argument_list|)
expr_stmt|;
name|csr
operator|->
name|scb_command
operator|=
name|FXP_SCB_COMMAND_CU_START
expr_stmt|;
comment|/* ...and wait for it to complete. */
while|while
condition|(
operator|!
operator|(
name|cbp
operator|->
name|cb_status
operator|&
name|FXP_CB_STATUS_C
operator|)
condition|)
empty_stmt|;
comment|/* 	 * Now initialize the station address. Temporarily use the TxCB 	 * memory area like we did above for the config CB. 	 */
name|cb_ias
operator|=
operator|(
expr|struct
name|fxp_cb_ias
operator|*
operator|)
name|sc
operator|->
name|cbl_base
expr_stmt|;
name|cb_ias
operator|->
name|cb_status
operator|=
literal|0
expr_stmt|;
name|cb_ias
operator|->
name|cb_command
operator|=
name|FXP_CB_COMMAND_IAS
operator||
name|FXP_CB_COMMAND_EL
expr_stmt|;
name|cb_ias
operator|->
name|link_addr
operator|=
operator|-
literal|1
expr_stmt|;
name|bcopy
argument_list|(
name|sc
operator|->
name|arpcom
operator|.
name|ac_enaddr
argument_list|,
operator|(
name|void
operator|*
operator|)
name|cb_ias
operator|->
name|macaddr
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|arpcom
operator|.
name|ac_enaddr
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Start the IAS (Individual Address Setup) command/DMA. 	 */
name|fxp_scb_wait
argument_list|(
name|csr
argument_list|)
expr_stmt|;
name|csr
operator|->
name|scb_command
operator|=
name|FXP_SCB_COMMAND_CU_START
expr_stmt|;
comment|/* ...and wait for it to complete. */
while|while
condition|(
operator|!
operator|(
name|cb_ias
operator|->
name|cb_status
operator|&
name|FXP_CB_STATUS_C
operator|)
condition|)
empty_stmt|;
comment|/* 	 * Initialize transmit control block (TxCB) list. 	 */
name|txp
operator|=
name|sc
operator|->
name|cbl_base
expr_stmt|;
name|bzero
argument_list|(
name|txp
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|fxp_cb_tx
argument_list|)
operator|*
name|FXP_NTXCB
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FXP_NTXCB
condition|;
name|i
operator|++
control|)
block|{
name|txp
index|[
name|i
index|]
operator|.
name|cb_status
operator|=
name|FXP_CB_STATUS_C
operator||
name|FXP_CB_STATUS_OK
expr_stmt|;
name|txp
index|[
name|i
index|]
operator|.
name|cb_command
operator|=
name|FXP_CB_COMMAND_NOP
expr_stmt|;
name|txp
index|[
name|i
index|]
operator|.
name|link_addr
operator|=
name|vtophys
argument_list|(
operator|&
name|txp
index|[
operator|(
name|i
operator|+
literal|1
operator|)
operator|&
name|FXP_TXCB_MASK
index|]
argument_list|)
expr_stmt|;
name|txp
index|[
name|i
index|]
operator|.
name|tbd_array_addr
operator|=
name|vtophys
argument_list|(
operator|&
name|txp
index|[
name|i
index|]
operator|.
name|tbd
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|txp
index|[
name|i
index|]
operator|.
name|next
operator|=
operator|&
name|txp
index|[
operator|(
name|i
operator|+
literal|1
operator|)
operator|&
name|FXP_TXCB_MASK
index|]
expr_stmt|;
block|}
comment|/* 	 * Set the stop flag on the first TxCB and start the control 	 * unit. It will execute the NOP and then suspend. 	 */
name|txp
operator|->
name|cb_command
operator|=
name|FXP_CB_COMMAND_NOP
operator||
name|FXP_CB_COMMAND_S
expr_stmt|;
name|sc
operator|->
name|cbl_first
operator|=
name|sc
operator|->
name|cbl_last
operator|=
name|txp
expr_stmt|;
name|sc
operator|->
name|tx_queued
operator|=
literal|0
expr_stmt|;
name|fxp_scb_wait
argument_list|(
name|csr
argument_list|)
expr_stmt|;
name|csr
operator|->
name|scb_command
operator|=
name|FXP_SCB_COMMAND_CU_START
expr_stmt|;
comment|/* 	 * Initialize receiver buffer area - RFA. 	 */
name|fxp_scb_wait
argument_list|(
name|csr
argument_list|)
expr_stmt|;
name|csr
operator|->
name|scb_general
operator|=
name|vtophys
argument_list|(
name|sc
operator|->
name|rfa_headm
operator|->
name|m_ext
operator|.
name|ext_buf
argument_list|)
expr_stmt|;
name|csr
operator|->
name|scb_command
operator|=
name|FXP_SCB_COMMAND_RU_START
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_RUNNING
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
name|IFF_OACTIVE
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* 	 * Start stats updater. 	 */
name|timeout
argument_list|(
name|fxp_stats_update
argument_list|,
name|sc
argument_list|,
name|hz
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Add a buffer to the end of the RFA buffer list.  * Return 0 if successful, 1 for failure. A failure results in  * adding the 'oldm' (if non-NULL) on to the end of the list -  * tossing out it's old contents and recycling it.  * The RFA struct is stuck at the beginning of mbuf cluster and the  * data pointer is fixed up to point just past it.  */
end_comment

begin_function
specifier|static
name|int
name|fxp_add_rfabuf
parameter_list|(
name|sc
parameter_list|,
name|oldm
parameter_list|)
name|struct
name|fxp_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|oldm
decl_stmt|;
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|fxp_rfa
modifier|*
name|rfa
decl_stmt|,
modifier|*
name|p_rfa
decl_stmt|;
name|MGETHDR
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|!=
name|NULL
condition|)
block|{
name|MCLGET
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|m
operator|->
name|m_flags
operator|&
name|M_EXT
operator|)
operator|==
literal|0
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldm
operator|==
name|NULL
condition|)
return|return
literal|1
return|;
name|m
operator|=
name|oldm
expr_stmt|;
name|m
operator|->
name|m_data
operator|=
name|m
operator|->
name|m_ext
operator|.
name|ext_buf
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|oldm
operator|==
name|NULL
condition|)
return|return
literal|1
return|;
name|m
operator|=
name|oldm
expr_stmt|;
name|m
operator|->
name|m_data
operator|=
name|m
operator|->
name|m_ext
operator|.
name|ext_buf
expr_stmt|;
block|}
comment|/* 	 * Get a pointer to the base of the mbuf cluster and move 	 * data start past it. 	 */
name|rfa
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|fxp_rfa
operator|*
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_data
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|fxp_rfa
argument_list|)
expr_stmt|;
name|rfa
operator|->
name|size
operator|=
name|MCLBYTES
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|fxp_rfa
argument_list|)
expr_stmt|;
name|rfa
operator|->
name|rfa_status
operator|=
literal|0
expr_stmt|;
name|rfa
operator|->
name|rfa_control
operator|=
name|FXP_RFA_CONTROL_EL
expr_stmt|;
name|rfa
operator|->
name|link_addr
operator|=
operator|-
literal|1
expr_stmt|;
name|rfa
operator|->
name|rbd_addr
operator|=
operator|-
literal|1
expr_stmt|;
name|rfa
operator|->
name|actual_size
operator|=
literal|0
expr_stmt|;
comment|/* 	 * If there are other buffers already on the list, attach this 	 * one to the end by fixing up the tail to point to this one. 	 */
if|if
condition|(
name|sc
operator|->
name|rfa_headm
operator|!=
name|NULL
condition|)
block|{
name|p_rfa
operator|=
operator|(
expr|struct
name|fxp_rfa
operator|*
operator|)
name|sc
operator|->
name|rfa_tailm
operator|->
name|m_ext
operator|.
name|ext_buf
expr_stmt|;
name|sc
operator|->
name|rfa_tailm
operator|->
name|m_next
operator|=
name|m
expr_stmt|;
name|p_rfa
operator|->
name|link_addr
operator|=
name|vtophys
argument_list|(
name|rfa
argument_list|)
expr_stmt|;
name|p_rfa
operator|->
name|rfa_control
operator|&=
operator|~
name|FXP_RFA_CONTROL_EL
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|rfa_headm
operator|=
name|m
expr_stmt|;
block|}
name|sc
operator|->
name|rfa_tailm
operator|=
name|m
expr_stmt|;
return|return
operator|(
name|m
operator|==
name|oldm
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|fxp_ioctl
parameter_list|(
name|ifp
parameter_list|,
name|command
parameter_list|,
name|data
parameter_list|)
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|int
name|command
decl_stmt|;
name|caddr_t
name|data
decl_stmt|;
block|{
name|struct
name|ifaddr
modifier|*
name|ifa
init|=
operator|(
expr|struct
name|ifaddr
operator|*
operator|)
name|data
decl_stmt|;
name|struct
name|fxp_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|fxp_softc
operator|*
operator|)
name|ifp
decl_stmt|;
name|struct
name|ifreq
modifier|*
name|ifr
init|=
operator|(
expr|struct
name|ifreq
operator|*
operator|)
name|data
decl_stmt|;
name|int
name|s
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|command
condition|)
block|{
case|case
name|SIOCSIFADDR
case|:
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_UP
expr_stmt|;
switch|switch
condition|(
name|ifa
operator|->
name|ifa_addr
operator|->
name|sa_family
condition|)
block|{
ifdef|#
directive|ifdef
name|INET
case|case
name|AF_INET
case|:
name|fxp_init
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
comment|/* before arpwhohas */
name|arp_ifinit
argument_list|(
operator|(
expr|struct
name|arpcom
operator|*
operator|)
name|ifp
argument_list|,
name|ifa
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|IPX
comment|/* 		 * XXX - This code is probably wrong 		 */
case|case
name|AF_IPX
case|:
block|{
specifier|register
name|struct
name|ipx_addr
modifier|*
name|ina
init|=
operator|&
operator|(
name|IA_SIPX
argument_list|(
name|ifa
argument_list|)
operator|->
name|sipx_addr
operator|)
decl_stmt|;
if|if
condition|(
name|ipx_nullhost
argument_list|(
operator|*
name|ina
argument_list|)
condition|)
name|ina
operator|->
name|x_host
operator|=
operator|*
operator|(
expr|union
name|ipx_host
operator|*
operator|)
operator|(
name|sc
operator|->
name|arpcom
operator|.
name|ac_enaddr
operator|)
expr_stmt|;
else|else
block|{
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|ina
operator|->
name|x_host
operator|.
name|c_host
argument_list|,
operator|(
name|caddr_t
operator|)
name|sc
operator|->
name|arpcom
operator|.
name|ac_enaddr
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|arpcom
operator|.
name|ac_enaddr
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* 				 * Set new address 				 */
name|fxp_init
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|NS
comment|/* 		 * XXX - This code is probably wrong 		 */
case|case
name|AF_NS
case|:
block|{
specifier|register
name|struct
name|ns_addr
modifier|*
name|ina
init|=
operator|&
operator|(
name|IA_SNS
argument_list|(
name|ifa
argument_list|)
operator|->
name|sns_addr
operator|)
decl_stmt|;
if|if
condition|(
name|ns_nullhost
argument_list|(
operator|*
name|ina
argument_list|)
condition|)
name|ina
operator|->
name|x_host
operator|=
operator|*
operator|(
expr|union
name|ns_host
operator|*
operator|)
operator|(
name|sc
operator|->
name|arpcom
operator|.
name|ac_enaddr
operator|)
expr_stmt|;
else|else
block|{
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|ina
operator|->
name|x_host
operator|.
name|c_host
argument_list|,
operator|(
name|caddr_t
operator|)
name|sc
operator|->
name|arpcom
operator|.
name|ac_enaddr
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|arpcom
operator|.
name|ac_enaddr
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* 				 * Set new address 				 */
name|fxp_init
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
default|default:
name|fxp_init
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|SIOCGIFADDR
case|:
block|{
name|struct
name|sockaddr
modifier|*
name|sa
decl_stmt|;
name|sa
operator|=
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|ifr
operator|->
name|ifr_data
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|sc
operator|->
name|arpcom
operator|.
name|ac_enaddr
argument_list|,
operator|(
name|caddr_t
operator|)
name|sa
operator|->
name|sa_data
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|arpcom
operator|.
name|ac_enaddr
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SIOCSIFFLAGS
case|:
comment|/* 		 * If interface is marked up and not running, then start it. 		 * If it is marked down and running, stop it. 		 * XXX If it's up then re-initialize it. This is so flags 		 * such as IFF_PROMISC are handled. 		 */
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
condition|)
block|{
name|fxp_init
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
condition|)
name|fxp_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SIOCADDMULTI
case|:
case|case
name|SIOCDELMULTI
case|:
comment|/* 		 * Update out multicast list. 		 */
name|error
operator|=
operator|(
name|command
operator|==
name|SIOCADDMULTI
operator|)
condition|?
name|ether_addmulti
argument_list|(
name|ifr
argument_list|,
operator|&
name|sc
operator|->
name|arpcom
argument_list|)
else|:
name|ether_delmulti
argument_list|(
name|ifr
argument_list|,
operator|&
name|sc
operator|->
name|arpcom
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|ENETRESET
condition|)
block|{
comment|/* 			 * Multicast list has changed; set the hardware filter 			 * accordingly. 			 */
name|fxp_init
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
block|}
break|break;
case|case
name|SIOCSIFMTU
case|:
comment|/* 		 * Set the interface MTU. 		 */
if|if
condition|(
name|ifr
operator|->
name|ifr_mtu
operator|>
name|ETHERMTU
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
else|else
block|{
name|ifp
operator|->
name|if_mtu
operator|=
name|ifr
operator|->
name|ifr_mtu
expr_stmt|;
block|}
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

end_unit

