begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1994, 1995, 1996 Matt Thomas (matt@3am-software.com)  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. The name of the author may not be used to endorse or promote products  *    derived from this software withough specific prior written permission  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *  * $Id: if_de.c,v 1.54.2.3 1997/02/23 11:00:44 joerg Exp $  *  */
end_comment

begin_comment
comment|/*  * DEC 21040 PCI Ethernet Controller  *  * Written by Matt Thomas  * BPF support code stolen directly from if_ec.c  *  *   This driver supports the DEC DE435 or any other PCI  *   board which support 21040, 21041, or 21140 (mostly).  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/protosw.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_comment
comment|/* only for declaration of wakeup() used by vm.h */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
end_if

begin_include
include|#
directive|include
file|<machine/clock.h>
end_include

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|__bsdi__
argument_list|)
operator|||
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
end_elif

begin_include
include|#
directive|include
file|<sys/device.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_dl.h>
end_include

begin_include
include|#
directive|include
file|<net/if_mib.h>
end_include

begin_include
include|#
directive|include
file|<net/if_types.h>
end_include

begin_include
include|#
directive|include
file|<net/route.h>
end_include

begin_include
include|#
directive|include
file|<net/netisr.h>
end_include

begin_include
include|#
directive|include
file|"bpfilter.h"
end_include

begin_if
if|#
directive|if
name|NBPFILTER
operator|>
literal|0
end_if

begin_include
include|#
directive|include
file|<net/bpf.h>
end_include

begin_include
include|#
directive|include
file|<net/bpfdesc.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|INET
end_ifdef

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_systm.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip.h>
end_include

begin_include
include|#
directive|include
file|<netinet/if_ether.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|NS
end_ifdef

begin_include
include|#
directive|include
file|<netns/ns.h>
end_include

begin_include
include|#
directive|include
file|<netns/ns_if.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_param.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_kern.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
end_if

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|"pci.h"
end_include

begin_if
if|#
directive|if
name|NPCI
operator|>
literal|0
end_if

begin_include
include|#
directive|include
file|<pci/pcivar.h>
end_include

begin_include
include|#
directive|include
file|<pci/dc21040.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __FreeBSD__ */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__bsdi__
argument_list|)
end_if

begin_include
include|#
directive|include
file|<i386/pci/pci.h>
end_include

begin_include
include|#
directive|include
file|<i386/pci/ic/dc21040.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/isa.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/icu.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/dma.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/isavar.h>
end_include

begin_if
if|#
directive|if
name|_BSDI_VERSION
operator|<
literal|199510
end_if

begin_include
include|#
directive|include
file|<eisa.h>
end_include

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|NEISA
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|NEISA
operator|>
literal|0
operator|&&
name|_BSDI_VERSION
operator|>=
literal|199401
end_if

begin_include
include|#
directive|include
file|<i386/eisa/eisa.h>
end_include

begin_define
define|#
directive|define
name|TULIP_EISA
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __bsdi__ */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
end_if

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__alpha__
argument_list|)
end_if

begin_include
include|#
directive|include
file|<machine/intr.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<dev/pci/pcireg.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcivar.h>
end_include

begin_include
include|#
directive|include
file|<dev/ic/dc21040reg.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __NetBSD__ */
end_comment

begin_comment
comment|/*  * Intel CPUs should use I/O mapped access.  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__i386__
argument_list|)
operator|||
name|defined
argument_list|(
name|TULIP_EISA
argument_list|)
end_if

begin_define
define|#
directive|define
name|TULIP_IOMAPPED
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/*  * This turns on all sort of debugging stuff and make the  * driver much larger.  */
end_comment

begin_define
define|#
directive|define
name|TULIP_DEBUG
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
literal|0
end_if

begin_define
define|#
directive|define
name|TULIP_USE_SOFTINTR
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * This module supports  *	the DEC 21040 PCI Ethernet Controller.  *	the DEC 21041 PCI Ethernet Controller.  *	the DEC 21140 PCI Fast Ethernet Controller.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|TULIP_IOMAPPED
end_ifdef

begin_define
define|#
directive|define
name|TULIP_EISA_CSRSIZE
value|16
end_define

begin_define
define|#
directive|define
name|TULIP_EISA_CSROFFSET
value|0
end_define

begin_define
define|#
directive|define
name|TULIP_PCI_CSRSIZE
value|8
end_define

begin_define
define|#
directive|define
name|TULIP_PCI_CSROFFSET
value|0
end_define

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
end_if

begin_typedef
typedef|typedef
name|bus_io_size_t
name|tulip_csrptr_t
typedef|;
end_typedef

begin_define
define|#
directive|define
name|TULIP_CSR_READ
parameter_list|(
name|sc
parameter_list|,
name|csr
parameter_list|)
define|\
value|bus_io_read_4((sc)->tulip_bc, (sc)->tulip_ioh, (sc)->tulip_csrs.csr)
end_define

begin_define
define|#
directive|define
name|TULIP_CSR_WRITE
parameter_list|(
name|sc
parameter_list|,
name|csr
parameter_list|,
name|val
parameter_list|)
define|\
value|bus_io_write_4((sc)->tulip_bc, (sc)->tulip_ioh, (sc)->tulip_csrs.csr, (val))
end_define

begin_define
define|#
directive|define
name|TULIP_CSR_READBYTE
parameter_list|(
name|sc
parameter_list|,
name|csr
parameter_list|)
define|\
value|bus_io_read_1((sc)->tulip_bc, (sc)->tulip_ioh, (sc)->tulip_csrs.csr)
end_define

begin_define
define|#
directive|define
name|TULIP_CSR_WRITEBYTE
parameter_list|(
name|sc
parameter_list|,
name|csr
parameter_list|,
name|val
parameter_list|)
define|\
value|bus_io_write_1((sc)->tulip_bc, (sc)->tulip_ioh, (sc)->tulip_csrs.csr, (val))
end_define

begin_else
else|#
directive|else
end_else

begin_typedef
typedef|typedef
name|u_int16_t
name|tulip_csrptr_t
typedef|;
end_typedef

begin_define
define|#
directive|define
name|TULIP_CSR_READ
parameter_list|(
name|sc
parameter_list|,
name|csr
parameter_list|)
value|(inl((sc)->tulip_csrs.csr))
end_define

begin_define
define|#
directive|define
name|TULIP_CSR_WRITE
parameter_list|(
name|sc
parameter_list|,
name|csr
parameter_list|,
name|val
parameter_list|)
value|outl((sc)->tulip_csrs.csr, val)
end_define

begin_define
define|#
directive|define
name|TULIP_CSR_READBYTE
parameter_list|(
name|sc
parameter_list|,
name|csr
parameter_list|)
value|(inb((sc)->tulip_csrs.csr))
end_define

begin_define
define|#
directive|define
name|TULIP_CSR_WRITEBYTE
parameter_list|(
name|sc
parameter_list|,
name|csr
parameter_list|,
name|val
parameter_list|)
value|outb((sc)->tulip_csrs.csr, val)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __NetBSD__ */
end_comment

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* TULIP_IOMAPPED */
end_comment

begin_define
define|#
directive|define
name|TULIP_PCI_CSRSIZE
value|8
end_define

begin_define
define|#
directive|define
name|TULIP_PCI_CSROFFSET
value|0
end_define

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
end_if

begin_typedef
typedef|typedef
name|bus_mem_size_t
name|tulip_csrptr_t
typedef|;
end_typedef

begin_define
define|#
directive|define
name|TULIP_CSR_READ
parameter_list|(
name|sc
parameter_list|,
name|csr
parameter_list|)
define|\
value|bus_mem_read_4((sc)->tulip_bc, (sc)->tulip_memh, (sc)->tulip_csrs.csr)
end_define

begin_define
define|#
directive|define
name|TULIP_CSR_WRITE
parameter_list|(
name|sc
parameter_list|,
name|csr
parameter_list|,
name|val
parameter_list|)
define|\
value|bus_mem_write_4((sc)->tulip_bc, (sc)->tulip_memh, (sc)->tulip_csrs.csr, \       (val))
end_define

begin_else
else|#
directive|else
end_else

begin_typedef
typedef|typedef
specifier|volatile
name|u_int32_t
modifier|*
name|tulip_csrptr_t
typedef|;
end_typedef

begin_comment
comment|/*  * macros to read and write CSRs.  Note that the "0 +" in  * READ_CSR is to prevent the macro from being an lvalue  * and WRITE_CSR shouldn't be assigned from.  */
end_comment

begin_define
define|#
directive|define
name|TULIP_CSR_READ
parameter_list|(
name|sc
parameter_list|,
name|csr
parameter_list|)
value|(0 + *(sc)->tulip_csrs.csr)
end_define

begin_define
define|#
directive|define
name|TULIP_CSR_WRITE
parameter_list|(
name|sc
parameter_list|,
name|csr
parameter_list|,
name|val
parameter_list|)
value|((void)(*(sc)->tulip_csrs.csr = (val)))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __NetBSD__ */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* TULIP_IOMAPPED */
end_comment

begin_comment
comment|/*  * This structure contains "pointers" for the registers on  * the various 21x4x chips.  CSR0 through CSR8 are common  * to all chips.  After that, it gets messy...  */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|tulip_csrptr_t
name|csr_busmode
decl_stmt|;
comment|/* CSR0 */
name|tulip_csrptr_t
name|csr_txpoll
decl_stmt|;
comment|/* CSR1 */
name|tulip_csrptr_t
name|csr_rxpoll
decl_stmt|;
comment|/* CSR2 */
name|tulip_csrptr_t
name|csr_rxlist
decl_stmt|;
comment|/* CSR3 */
name|tulip_csrptr_t
name|csr_txlist
decl_stmt|;
comment|/* CSR4 */
name|tulip_csrptr_t
name|csr_status
decl_stmt|;
comment|/* CSR5 */
name|tulip_csrptr_t
name|csr_command
decl_stmt|;
comment|/* CSR6 */
name|tulip_csrptr_t
name|csr_intr
decl_stmt|;
comment|/* CSR7 */
name|tulip_csrptr_t
name|csr_missed_frames
decl_stmt|;
comment|/* CSR8 */
comment|/* 21040 specific registers */
name|tulip_csrptr_t
name|csr_enetrom
decl_stmt|;
comment|/* CSR9 */
name|tulip_csrptr_t
name|csr_reserved
decl_stmt|;
comment|/* CSR10 */
name|tulip_csrptr_t
name|csr_full_duplex
decl_stmt|;
comment|/* CSR11 */
comment|/* 21040/21041 common registers */
name|tulip_csrptr_t
name|csr_sia_status
decl_stmt|;
comment|/* CSR12 */
name|tulip_csrptr_t
name|csr_sia_connectivity
decl_stmt|;
comment|/* CSR13 */
name|tulip_csrptr_t
name|csr_sia_tx_rx
decl_stmt|;
comment|/* CSR14 */
name|tulip_csrptr_t
name|csr_sia_general
decl_stmt|;
comment|/* CSR15 */
comment|/* 21140/21041 common registers */
name|tulip_csrptr_t
name|csr_srom_mii
decl_stmt|;
comment|/* CSR9 */
name|tulip_csrptr_t
name|csr_gp_timer
decl_stmt|;
comment|/* CSR11 */
comment|/* 21140 specific registers */
name|tulip_csrptr_t
name|csr_gp
decl_stmt|;
comment|/* CSR12 */
name|tulip_csrptr_t
name|csr_watchdog
decl_stmt|;
comment|/* CSR15 */
comment|/* 21041 specific registers */
name|tulip_csrptr_t
name|csr_bootrom
decl_stmt|;
comment|/* CSR10 */
block|}
name|tulip_regfile_t
typedef|;
end_typedef

begin_comment
comment|/*  * While 21x4x allows chaining of its descriptors, this driver  * doesn't take advantage of it.  We keep the descriptors in a  * traditional FIFO ring.    */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|tulip_desc_t
modifier|*
name|ri_first
decl_stmt|;
comment|/* first entry in ring */
name|tulip_desc_t
modifier|*
name|ri_last
decl_stmt|;
comment|/* one after last entry */
name|tulip_desc_t
modifier|*
name|ri_nextin
decl_stmt|;
comment|/* next to processed by host */
name|tulip_desc_t
modifier|*
name|ri_nextout
decl_stmt|;
comment|/* next to processed by adapter */
name|int
name|ri_max
decl_stmt|;
name|int
name|ri_free
decl_stmt|;
block|}
name|tulip_ringinfo_t
typedef|;
end_typedef

begin_comment
comment|/*  * The 21040 has a stupid restriction in that the receive  * buffers must be longword aligned.  But since Ethernet  * headers are not a multiple of longwords in size this forces  * the data to non-longword aligned.  Since IP requires the  * data to be longword aligned, we need to copy it after it has  * been DMA'ed in our memory.  *  * Since we have to copy it anyways, we might as well as allocate  * dedicated receive space for the input.  This allows to use a  * small receive buffer size and more ring entries to be able to  * better keep with a flood of tiny Ethernet packets.  *  * The receive space MUST ALWAYS be a multiple of the page size.  * And the number of receive descriptors multiplied by the size  * of the receive buffers must equal the recevive space.  This  * is so that we can manipulate the page tables so that even if a  * packet wraps around the end of the receive space, we can   * treat it as virtually contiguous.  *  * The above used to be true (the stupid restriction is still true)  * but we gone to directly DMA'ing into MBUFs (unless it's on an   * architecture which can't handle unaligned accesses) because with  * 100Mb/s cards the copying is just too much of a hit.  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__alpha__
argument_list|)
end_if

begin_define
define|#
directive|define
name|TULIP_COPY_RXDATA
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|TULIP_TXTIMER
value|3
end_define

begin_define
define|#
directive|define
name|TULIP_RXDESCS
value|48
end_define

begin_define
define|#
directive|define
name|TULIP_TXDESCS
value|128
end_define

begin_define
define|#
directive|define
name|TULIP_RXQ_TARGET
value|32
end_define

begin_if
if|#
directive|if
name|TULIP_RXQ_TARGET
operator|>=
name|TULIP_RXDESCS
end_if

begin_error
error|#
directive|error
error|TULIP_RXQ_TARGET must be less than TULIP_RXDESCS
end_error

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|TULIP_RX_BUFLEN
value|((MCLBYTES< 2048 ? MCLBYTES : 2048) - 16)
end_define

begin_comment
comment|/*  * Forward reference to make C happy.  */
end_comment

begin_typedef
typedef|typedef
name|struct
name|_tulip_softc_t
name|tulip_softc_t
typedef|;
end_typedef

begin_comment
comment|/*  * The various controllers support.  Technically the DE425 is just  * a 21040 on EISA.  But since it remarkably difference from normal  * 21040s, we give it its own chip id.  */
end_comment

begin_typedef
typedef|typedef
enum|enum
block|{
name|TULIP_21040
block|,
name|TULIP_DE425
block|,
name|TULIP_21041
block|,
name|TULIP_21140
block|,
name|TULIP_21140A
block|,
name|TULIP_21142
block|,
name|TULIP_21143
block|,
name|TULIP_CHIPID_UNKNOWN
block|}
name|tulip_chipid_t
typedef|;
end_typedef

begin_comment
comment|/*  * Various physical media types supported.  * BNCAUI is BNC or AUI since on the 21040 you can't really tell  * which is in use.  */
end_comment

begin_typedef
typedef|typedef
enum|enum
block|{
name|TULIP_MEDIA_UNKNOWN
block|,
name|TULIP_MEDIA_10BASET
block|,
name|TULIP_MEDIA_BNC
block|,
name|TULIP_MEDIA_AUI
block|,
name|TULIP_MEDIA_BNCAUI
block|,
name|TULIP_MEDIA_10BASET_FD
block|,
name|TULIP_MEDIA_100BASETX
block|,
name|TULIP_MEDIA_100BASETX_FD
block|,
name|TULIP_MEDIA_100BASET4
block|,
name|TULIP_MEDIA_100BASEFX
block|,
name|TULIP_MEDIA_100BASEFX_FD
block|,
name|TULIP_MEDIA_MAX
block|}
name|tulip_media_t
typedef|;
end_typedef

begin_comment
comment|/*  * Some boards need to treated specially.  The following enumeration  * identifies the cards with quirks (or those we just want to single  * out for special merit or scorn).  */
end_comment

begin_typedef
typedef|typedef
enum|enum
block|{
name|TULIP_21040_GENERIC
block|,
comment|/* Generic 21040 (works with most any board) */
name|TULIP_21040_ZX314_MASTER
block|,
comment|/* ZNYX ZX314 Master 21040 (it has the interrupt line) */
name|TULIP_21040_ZX314_SLAVE
block|,
comment|/* ZNYX ZX314 Slave 21040 (its interrupt is tied to the master's */
name|TULIP_21140_DEC_EB
block|,
comment|/* Digital Semicondutor 21140 Evaluation Board */
name|TULIP_21140_DEC_DE500
block|,
comment|/* Digital DE500-?? 10/100 */
name|TULIP_21140_SMC_9332
block|,
comment|/* SMC 9332 */
name|TULIP_21140A_SMC_9332BDT
block|,
comment|/* SMC 9332BDT with 21140A */
name|TULIP_21140_COGENT_EM100
block|,
comment|/* Cogent EM100 100 only */
name|TULIP_21140_ZNYX_ZX34X
block|,
comment|/* ZNYX ZX342 10/100 */
name|TULIP_21041_GENERIC
block|,
comment|/* Generic 21041 card */
name|TULIP_21041_DEC_DE450
comment|/* Digital DE450 */
block|}
name|tulip_board_t
typedef|;
end_typedef

begin_comment
comment|/*  * This data structure is used to abstract out the quirks.  * media_probe  = tries to determine the media type.  * media_select = enables the current media (or autosenses)  * media_preset = 21140, etal requires bit to set before the  *		  the software reset; hence pre-set.  Should be  *		  pre-reset but that's ugly.  * mii_probe	= probe for PHY devices connected via the MII interface  *		  on 21140, etal.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|tulip_board_t
name|bd_type
decl_stmt|;
specifier|const
name|char
modifier|*
name|bd_description
decl_stmt|;
name|int
function_decl|(
modifier|*
name|bd_media_probe
function_decl|)
parameter_list|(
name|tulip_softc_t
modifier|*
name|sc
parameter_list|)
function_decl|;
name|void
function_decl|(
modifier|*
name|bd_media_select
function_decl|)
parameter_list|(
name|tulip_softc_t
modifier|*
name|sc
parameter_list|)
function_decl|;
name|void
function_decl|(
modifier|*
name|bd_media_preset
function_decl|)
parameter_list|(
name|tulip_softc_t
modifier|*
name|sc
parameter_list|)
function_decl|;
name|void
function_decl|(
modifier|*
name|bd_mii_probe
function_decl|)
parameter_list|(
name|tulip_softc_t
modifier|*
name|sc
parameter_list|)
function_decl|;
block|}
name|tulip_boardsw_t
typedef|;
end_typedef

begin_comment
comment|/*  * The next few declarations are for MII/PHY based board.  *  *    The first enumeration identifies a superset of various datums  * that can be obtained from various PHY chips.  Not all PHYs will  * support all datums.  *    The modedata structure indicates what register contains  * a datum, what mask is applied the register contents, and what the  * result should be.  *    The attr structure records information about a supported PHY.  *    The phy structure records information about a PHY instance.  */
end_comment

begin_typedef
typedef|typedef
enum|enum
block|{
name|PHY_MODE_10T
block|,
name|PHY_MODE_100TX
block|,
name|PHY_MODE_100T4
block|,
name|PHY_MODE_FULLDUPLEX
block|,
name|PHY_MODE_MAX
block|}
name|phy_mode_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
block|{
name|unsigned
name|short
name|pm_regno
decl_stmt|;
name|unsigned
name|short
name|pm_mask
decl_stmt|;
name|unsigned
name|short
name|pm_value
decl_stmt|;
block|}
name|phy_modedata_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
block|{
specifier|const
name|char
modifier|*
name|attr_name
decl_stmt|;
name|unsigned
name|attr_id
decl_stmt|;
name|unsigned
name|short
name|attr_flags
decl_stmt|;
define|#
directive|define
name|PHY_NEED_HARD_RESET
value|0x0001
define|#
directive|define
name|PHY_DUAL_CYCLE_TA
value|0x0002
name|phy_modedata_t
name|attr_modes
index|[
name|PHY_MODE_MAX
index|]
decl_stmt|;
block|}
name|phy_attr_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|_tulip_phy_t
block|{
specifier|const
name|struct
name|_tulip_phy_t
modifier|*
name|phy_next
decl_stmt|;
specifier|const
name|phy_attr_t
modifier|*
name|phy_attr
decl_stmt|;
name|unsigned
name|phy_devaddr
decl_stmt|;
name|unsigned
name|phy_status
decl_stmt|;
block|}
name|tulip_phy_t
typedef|;
end_typedef

begin_comment
comment|/*  * Various probe states used when trying to autosense the media.  * While we could try to autosense on the 21040, it a pain and so  * until someone complain we won't.  However, the 21041 and MII  * 2114x do support autosense.  */
end_comment

begin_typedef
typedef|typedef
enum|enum
block|{
name|TULIP_PROBE_INACTIVE
block|,
name|TULIP_PROBE_10BASET
block|,
name|TULIP_PROBE_AUI
block|,
name|TULIP_PROBE_BNC
block|,
name|TULIP_PROBE_PHYRESET
block|,
name|TULIP_PROBE_PHYAUTONEG
block|,
name|TULIP_PROBE_MEDIATEST
block|,
name|TULIP_PROBE_FAILED
block|}
name|tulip_probe_state_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
block|{
comment|/*      * Transmit Statistics      */
name|u_int32_t
name|dot3StatsSingleCollisionFrames
decl_stmt|;
name|u_int32_t
name|dot3StatsMultipleCollisionFrames
decl_stmt|;
name|u_int32_t
name|dot3StatsSQETestErrors
decl_stmt|;
name|u_int32_t
name|dot3StatsDeferredTransmissions
decl_stmt|;
name|u_int32_t
name|dot3StatsLateCollisions
decl_stmt|;
name|u_int32_t
name|dot3StatsExcessiveCollisions
decl_stmt|;
name|u_int32_t
name|dot3StatsInternalMacTransmitErrors
decl_stmt|;
name|u_int32_t
name|dot3StatsCarrierSenseErrors
decl_stmt|;
comment|/*      * Receive Statistics      */
name|u_int32_t
name|dot3StatsMissedFrames
decl_stmt|;
comment|/* not in rfc1650! */
name|u_int32_t
name|dot3StatsAlignmentErrors
decl_stmt|;
name|u_int32_t
name|dot3StatsFCSErrors
decl_stmt|;
name|u_int32_t
name|dot3StatsFrameTooLongs
decl_stmt|;
name|u_int32_t
name|dot3StatsInternalMacReceiveErrors
decl_stmt|;
block|}
name|tulip_dot3_stats_t
typedef|;
end_typedef

begin_comment
comment|/*  * Now to important stuff.  This is softc structure (where does softc  * come from??? No idea) for the tulip device.    *  */
end_comment

begin_struct
struct|struct
name|_tulip_softc_t
block|{
if|#
directive|if
name|defined
argument_list|(
name|__bsdi__
argument_list|)
name|struct
name|device
name|tulip_dev
decl_stmt|;
comment|/* base device */
name|struct
name|isadev
name|tulip_id
decl_stmt|;
comment|/* ISA device */
name|struct
name|intrhand
name|tulip_ih
decl_stmt|;
comment|/* intrrupt vectoring */
name|struct
name|atshutdown
name|tulip_ats
decl_stmt|;
comment|/* shutdown hook */
if|#
directive|if
name|_BSDI_VERSION
operator|<
literal|199401
name|caddr_t
name|tulip_bpf
decl_stmt|;
comment|/* for BPF */
else|#
directive|else
name|prf_t
name|tulip_pf
decl_stmt|;
comment|/* printf function */
endif|#
directive|endif
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
name|struct
name|device
name|tulip_dev
decl_stmt|;
comment|/* base device */
name|void
modifier|*
name|tulip_ih
decl_stmt|;
comment|/* intrrupt vectoring */
name|void
modifier|*
name|tulip_ats
decl_stmt|;
comment|/* shutdown hook */
name|bus_chipset_tag_t
name|tulip_bc
decl_stmt|;
name|pci_chipset_tag_t
name|tulip_pc
decl_stmt|;
ifdef|#
directive|ifdef
name|TULIP_IOMAPPED
name|bus_io_handle_t
name|tulip_ioh
decl_stmt|;
comment|/* I/O region handle */
else|#
directive|else
name|bus_io_handle_t
name|tulip_memh
decl_stmt|;
comment|/* memory region handle */
endif|#
directive|endif
endif|#
directive|endif
name|struct
name|arpcom
name|tulip_ac
decl_stmt|;
name|tulip_regfile_t
name|tulip_csrs
decl_stmt|;
name|unsigned
name|tulip_flags
decl_stmt|;
define|#
directive|define
name|TULIP_WANTSETUP
value|0x00000001
define|#
directive|define
name|TULIP_WANTHASH
value|0x00000002
define|#
directive|define
name|TULIP_DOINGSETUP
value|0x00000004
define|#
directive|define
name|TULIP_ALTPHYS
value|0x00000008
define|#
directive|define
name|TULIP_PRINTMEDIA
value|0x00000010
define|#
directive|define
name|TULIP_TXPROBE_ACTIVE
value|0x00000020
define|#
directive|define
name|TULIP_TXPROBE_OK
value|0x00000040
define|#
directive|define
name|TULIP_WANTRXACT
value|0x00000080
define|#
directive|define
name|TULIP_RXACT
value|0x00000100
define|#
directive|define
name|TULIP_INRESET
value|0x00000200
define|#
directive|define
name|TULIP_NEEDRESET
value|0x00000400
define|#
directive|define
name|TULIP_SQETEST
value|0x00000800
define|#
directive|define
name|TULIP_ROMOK
value|0x00001000
define|#
directive|define
name|TULIP_SLAVEDROM
value|0x00002000
define|#
directive|define
name|TULIP_SLAVEDINTR
value|0x00004000
define|#
directive|define
name|TULIP_SHAREDINTR
value|0x00008000
define|#
directive|define
name|TULIP_LINKSUSPECT
value|0x00010000
define|#
directive|define
name|TULIP_LINKUP
value|0x00020000
define|#
directive|define
name|TULIP_RXBUFSLOW
value|0x00040000
define|#
directive|define
name|TULIP_NOMESSAGES
value|0x00080000
define|#
directive|define
name|TULIP_SYSTEMERROR
value|0x00100000
define|#
directive|define
name|TULIP_DEVICEPROBE
value|0x00200000
define|#
directive|define
name|TULIP_FAKEGPTIMEOUT
value|0x00400000
comment|/* only 10 bits! */
name|unsigned
name|char
name|tulip_rombuf
index|[
literal|128
index|]
decl_stmt|;
name|u_int32_t
name|tulip_setupbuf
index|[
literal|192
operator|/
sizeof|sizeof
argument_list|(
name|u_int32_t
argument_list|)
index|]
decl_stmt|;
name|u_int32_t
name|tulip_setupdata
index|[
literal|192
operator|/
sizeof|sizeof
argument_list|(
name|u_int32_t
argument_list|)
index|]
decl_stmt|;
name|u_int32_t
name|tulip_intrmask
decl_stmt|;
comment|/* our copy of csr_intr */
name|u_int32_t
name|tulip_cmdmode
decl_stmt|;
comment|/* our copy of csr_cmdmode */
name|u_int32_t
name|tulip_revinfo
decl_stmt|;
comment|/* revision of chip */
name|u_int32_t
name|tulip_gpticks
decl_stmt|;
comment|/* number of gpticks unless timeout */
name|u_int32_t
name|tulip_last_system_error
range|:
literal|3
decl_stmt|;
comment|/* last system error (only value is TULIP_SYSTEMERROR is also set) */
name|u_int32_t
name|tulip_txtimer
range|:
literal|2
decl_stmt|;
comment|/* transmission timer */
name|u_int32_t
name|tulip_system_errors
decl_stmt|;
comment|/* number of system errors encountered */
name|u_int32_t
name|tulip_statusbits
decl_stmt|;
comment|/* status bits from CSR5 that may need to be printed */
name|u_int32_t
name|tulip_abilities
decl_stmt|;
comment|/* remote system's abiltities (as defined in IEEE 802.3u) */
comment|/* u_int32_t tulip_bus; XXX */
name|tulip_media_t
name|tulip_media
decl_stmt|;
comment|/* current media type */
name|tulip_probe_state_t
name|tulip_probe_state
decl_stmt|;
comment|/* current media probe state */
name|tulip_chipid_t
name|tulip_chipid
decl_stmt|;
comment|/* type of chip we are using */
specifier|const
name|char
modifier|*
name|tulip_boardid
decl_stmt|;
comment|/* string for board ID */
name|char
name|tulip_boardidbuf
index|[
literal|16
index|]
decl_stmt|;
comment|/* buffer for board ID */
specifier|const
name|tulip_boardsw_t
modifier|*
name|tulip_boardsw
decl_stmt|;
comment|/* board/chip characteristics */
name|tulip_softc_t
modifier|*
name|tulip_slaves
decl_stmt|;
comment|/* slaved devices (ZX3xx) */
name|tulip_phy_t
modifier|*
name|tulip_phys
decl_stmt|;
comment|/* 802.3 PHY devices */
if|#
directive|if
name|defined
argument_list|(
name|TULIP_DEBUG
argument_list|)
comment|/*      * Debugging/Statistical information      */
struct|struct
block|{
name|u_int32_t
name|dbg_intrs
decl_stmt|;
name|u_int32_t
name|dbg_msdelay
decl_stmt|;
name|u_int32_t
name|dbg_gpticks
decl_stmt|;
enum|enum
block|{
name|TULIP_GPTMR_10MB
block|,
name|TULIP_GPTMR_10MB_MII
block|,
name|TULIP_GPTMR_100MB_MII
block|}
name|dbg_gprate
enum|;
name|u_int32_t
name|dbg_gpintrs
decl_stmt|;
name|u_int32_t
name|dbg_gpintrs_hz
decl_stmt|;
name|u_int32_t
name|dbg_link_downed
decl_stmt|;
name|u_int32_t
name|dbg_link_suspected
decl_stmt|;
name|u_int16_t
name|dbg_phyregs
index|[
literal|32
index|]
index|[
literal|4
index|]
decl_stmt|;
name|u_int32_t
name|dbg_rxlowbufs
decl_stmt|;
name|u_int32_t
name|dbg_rxintrs
decl_stmt|;
name|u_int32_t
name|dbg_last_rxintrs
decl_stmt|;
name|u_int32_t
name|dbg_high_rxintrs_hz
decl_stmt|;
name|u_int32_t
name|dbg_rxpktsperintr
index|[
name|TULIP_RXDESCS
index|]
decl_stmt|;
block|}
name|tulip_dbg
struct|;
endif|#
directive|endif
name|struct
name|ifqueue
name|tulip_txq
decl_stmt|;
name|struct
name|ifqueue
name|tulip_rxq
decl_stmt|;
name|struct
name|ifmib_iso_8802_3
name|tulip_dot3stats
decl_stmt|;
name|tulip_ringinfo_t
name|tulip_rxinfo
decl_stmt|;
name|tulip_ringinfo_t
name|tulip_txinfo
decl_stmt|;
name|tulip_desc_t
name|tulip_rxdescs
index|[
name|TULIP_RXDESCS
index|]
decl_stmt|;
name|tulip_desc_t
name|tulip_txdescs
index|[
name|TULIP_TXDESCS
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|tulip_chipdescs
index|[]
init|=
block|{
literal|"21040 [10Mb/s]"
block|,
if|#
directive|if
name|defined
argument_list|(
name|TULIP_EISA
argument_list|)
literal|"DE425 [10Mb/s]"
block|,
else|#
directive|else
name|NULL
block|,
endif|#
directive|endif
literal|"21041 [10Mb/s]"
block|,
literal|"21140 [10-100Mb/s]"
block|,
literal|"21140A [10-100Mb/s]"
block|,
literal|"21142 [10-100Mb/s]"
block|, }
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|chip
parameter_list|(
name|x
parameter_list|)
value|DOT3CHIPSET(dot3VendorDigital, dot3ChipSetDigital##x)
end_define

begin_decl_stmt
specifier|static
name|u_int32_t
specifier|const
name|tulip_chip2mib
index|[]
init|=
block|{
name|chip
argument_list|(
name|DC21040
argument_list|)
block|,
name|chip
argument_list|(
name|DC21040
argument_list|)
block|,
name|chip
argument_list|(
name|DC21041
argument_list|)
block|,
name|chip
argument_list|(
name|DC21140
argument_list|)
block|,
name|chip
argument_list|(
name|DC21140A
argument_list|)
block|,
name|chip
argument_list|(
argument|DC21142
argument_list|)
block|}
decl_stmt|;
end_decl_stmt

begin_undef
undef|#
directive|undef
name|chip
end_undef

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|tulip_mediums
index|[]
init|=
block|{
literal|"unknown"
block|,
comment|/* TULIP_MEDIA_UNKNOWN */
literal|"10baseT"
block|,
comment|/* TULIP_MEDIA_10BASET */
literal|"BNC"
block|,
comment|/* TULIP_MEDIA_BNC */
literal|"AUI"
block|,
comment|/* TULIP_MEDIA_AUI */
literal|"BNC/AUI"
block|,
comment|/* TULIP_MEDIA_BNCAUI */
literal|"Full Duplex 10baseT"
block|,
comment|/* TULIP_MEDIA_10BASET_FD */
literal|"100baseTX"
block|,
comment|/* TULIP_MEDIA_100BASET */
literal|"Full Duplex 100baseTX"
block|,
comment|/* TULIP_MEDIA_100BASET_FD */
literal|"100baseT4"
block|,
comment|/* TULIP_MEDIA_100BASET4 */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|tulip_media_t
name|tulip_phy_statuses
index|[]
init|=
block|{
name|TULIP_MEDIA_10BASET
block|,
name|TULIP_MEDIA_10BASET_FD
block|,
name|TULIP_MEDIA_100BASETX
block|,
name|TULIP_MEDIA_100BASETX_FD
block|,
name|TULIP_MEDIA_100BASET4
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|tulip_system_errors
index|[]
init|=
block|{
literal|"parity error"
block|,
literal|"master abort"
block|,
literal|"target abort"
block|,
literal|"reserved #3"
block|,
literal|"reserved #4"
block|,
literal|"reserved #5"
block|,
literal|"reserved #6"
block|,
literal|"reserved #7"
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|tulip_status_bits
index|[]
init|=
block|{
name|NULL
block|,
literal|"transmit process stopped"
block|,
name|NULL
block|,
literal|"transmit jabber timeout"
block|,
name|NULL
block|,
literal|"transmit underflow"
block|,
name|NULL
block|,
literal|"receive underflow"
block|,
literal|"receive process stopped"
block|,
literal|"receive watchdog timeout"
block|,
name|NULL
block|,
name|NULL
block|,
literal|"link failure"
block|,
name|NULL
block|,
name|NULL
block|, }
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|IFF_ALTPHYS
end_ifndef

begin_define
define|#
directive|define
name|IFF_ALTPHYS
value|IFF_LINK2
end_define

begin_comment
comment|/* In case it isn't defined */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|IFF_FULLDUPLEX
end_ifndef

begin_define
define|#
directive|define
name|IFF_FULLDUPLEX
value|IFF_LINK1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|IFF_NOAUTONEG
end_ifndef

begin_if
if|#
directive|if
name|IFF_ALTPHYS
operator|==
name|IFF_LINK2
end_if

begin_define
define|#
directive|define
name|IFF_NOAUTONEG
value|IFF_LINK0
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|IFF_NOAUTONEG
value|IFF_LINK2
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|(
name|IFF_ALTPHYS
operator|&
name|IFF_FULLDUPLEX
operator|&
name|IFF_NOAUTONEG
operator|)
operator|!=
literal|0
end_if

begin_error
error|#
directive|error
error|IFF_ALTPHYS, IFF_FULLDUPLEX, IFF_NOAUTONEG overlap
end_error

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * This driver supports a maximum of 32 tulip boards.  * This should be enough for the forseeable future.  */
end_comment

begin_define
define|#
directive|define
name|TULIP_MAX_DEVICES
value|32
end_define

begin_if
if|#
directive|if
name|defined
argument_list|(
name|TULIP_USE_SOFTINTR
argument_list|)
end_if

begin_decl_stmt
specifier|static
name|u_int32_t
name|tulip_softintr_mask
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|tulip_softintr_last_unit
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|tulip_softintr_max_unit
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|tulip_softintr
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
end_if

begin_typedef
typedef|typedef
name|void
name|ifnet_ret_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|int
name|ioctl_cmd_t
typedef|;
end_typedef

begin_decl_stmt
name|tulip_softc_t
modifier|*
name|tulips
index|[
name|TULIP_MAX_DEVICES
index|]
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|BSD
operator|>=
literal|199506
end_if

begin_define
define|#
directive|define
name|TULIP_IFP_TO_SOFTC
parameter_list|(
name|ifp
parameter_list|)
value|((tulip_softc_t *)((ifp)->if_softc))
end_define

begin_if
if|#
directive|if
name|NBPFILTER
operator|>
literal|0
end_if

begin_define
define|#
directive|define
name|TULIP_BPF_MTAP
parameter_list|(
name|sc
parameter_list|,
name|m
parameter_list|)
value|bpf_mtap(&(sc)->tulip_if, m)
end_define

begin_define
define|#
directive|define
name|TULIP_BPF_TAP
parameter_list|(
name|sc
parameter_list|,
name|p
parameter_list|,
name|l
parameter_list|)
value|bpf_tap(&(sc)->tulip_if, p, l)
end_define

begin_define
define|#
directive|define
name|TULIP_BPF_ATTACH
parameter_list|(
name|sc
parameter_list|)
value|bpfattach(&(sc)->tulip_if, DLT_EN10MB, sizeof(struct ether_header))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|tulip_intrfunc_t
value|void
end_define

begin_define
define|#
directive|define
name|TULIP_VOID_INTRFUNC
end_define

begin_define
define|#
directive|define
name|IFF_NOTRAILERS
value|0
end_define

begin_define
define|#
directive|define
name|CLBYTES
value|PAGE_SIZE
end_define

begin_if
if|#
directive|if
literal|0
end_if

begin_define
define|#
directive|define
name|TULIP_KVATOPHYS
parameter_list|(
name|sc
parameter_list|,
name|va
parameter_list|)
value|kvtop(va)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|TULIP_EADDR_FMT
value|"%6D"
end_define

begin_define
define|#
directive|define
name|TULIP_EADDR_ARGS
parameter_list|(
name|addr
parameter_list|)
value|addr, ":"
end_define

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|extern
name|int
name|bootverbose
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|TULIP_IFP_TO_SOFTC
parameter_list|(
name|ifp
parameter_list|)
value|(TULIP_UNIT_TO_SOFTC((ifp)->if_unit))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|TULIP_USE_SOFTINTR
argument_list|)
end_if

begin_expr_stmt
name|NETISR_SET
argument_list|(
name|NETISR_DE
argument_list|,
name|tulip_softintr
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|TULIP_UNIT_TO_SOFTC
parameter_list|(
name|unit
parameter_list|)
value|(tulips[unit])
end_define

begin_define
define|#
directive|define
name|TULIP_BURSTSIZE
parameter_list|(
name|unit
parameter_list|)
value|pci_max_burst_len
end_define

begin_define
define|#
directive|define
name|loudprintf
value|if (bootverbose) printf
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__bsdi__
argument_list|)
end_if

begin_typedef
typedef|typedef
name|int
name|ifnet_ret_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|int
name|ioctl_cmd_t
typedef|;
end_typedef

begin_decl_stmt
specifier|extern
name|struct
name|cfdriver
name|decd
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|TULIP_UNIT_TO_SOFTC
parameter_list|(
name|unit
parameter_list|)
value|((tulip_softc_t *) decd.cd_devs[unit])
end_define

begin_define
define|#
directive|define
name|TULIP_IFP_TO_SOFTC
parameter_list|(
name|ifp
parameter_list|)
value|(TULIP_UNIT_TO_SOFTC((ifp)->if_unit))
end_define

begin_if
if|#
directive|if
name|_BSDI_VERSION
operator|>=
literal|199510
end_if

begin_if
if|#
directive|if
literal|0
end_if

begin_define
define|#
directive|define
name|TULIP_BURSTSIZE
parameter_list|(
name|unit
parameter_list|)
value|log2_burst_size
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|loudprintf
value|aprint_verbose
end_define

begin_define
define|#
directive|define
name|printf
value|(*sc->tulip_pf)
end_define

begin_elif
elif|#
directive|elif
name|_BSDI_VERSION
operator|<=
literal|199401
end_elif

begin_define
define|#
directive|define
name|DRQNONE
value|0
end_define

begin_define
define|#
directive|define
name|loudprintf
value|printf
end_define

begin_function
specifier|static
name|void
name|arp_ifinit
parameter_list|(
name|struct
name|arpcom
modifier|*
name|ac
parameter_list|,
name|struct
name|ifaddr
modifier|*
name|ifa
parameter_list|)
block|{
name|ac
operator|->
name|ac_ipaddr
operator|=
name|IA_SIN
argument_list|(
name|ifa
argument_list|)
operator|->
name|sin_addr
expr_stmt|;
name|arpwhohas
argument_list|(
name|ac
argument_list|,
operator|&
name|ac
operator|->
name|ac_ipaddr
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __bsdi__ */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
end_if

begin_typedef
typedef|typedef
name|void
name|ifnet_ret_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|u_long
name|ioctl_cmd_t
typedef|;
end_typedef

begin_decl_stmt
specifier|extern
name|struct
name|cfattach
name|de_ca
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|cfdriver
name|de_cd
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|TULIP_UNIT_TO_SOFTC
parameter_list|(
name|unit
parameter_list|)
value|((tulip_softc_t *) de_cd.cd_devs[unit])
end_define

begin_define
define|#
directive|define
name|TULIP_IFP_TO_SOFTC
parameter_list|(
name|ifp
parameter_list|)
value|((tulip_softc_t *)((ifp)->if_softc))
end_define

begin_define
define|#
directive|define
name|tulip_xname
value|tulip_ac.ac_if.if_xname
end_define

begin_define
define|#
directive|define
name|tulip_unit
value|tulip_dev.dv_unit
end_define

begin_define
define|#
directive|define
name|loudprintf
value|printf
end_define

begin_define
define|#
directive|define
name|TULIP_PRINTF_FMT
value|"%s"
end_define

begin_define
define|#
directive|define
name|TULIP_PRINTF_ARGS
value|sc->tulip_xname
end_define

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__alpha__
argument_list|)
end_if

begin_comment
comment|/* XXX XXX NEED REAL DMA MAPPING SUPPORT XXX XXX */
end_comment

begin_define
define|#
directive|define
name|TULIP_KVATOPHYS
parameter_list|(
name|va
parameter_list|)
value|(vtophys(va) | 0x40000000)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __NetBSD__ */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|TULIP_PRINTF_FMT
end_ifndef

begin_define
define|#
directive|define
name|TULIP_PRINTF_FMT
value|"%s%d"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|TULIP_PRINTF_ARGS
end_ifndef

begin_define
define|#
directive|define
name|TULIP_PRINTF_ARGS
value|sc->tulip_name, sc->tulip_unit
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|TULIP_BURSTSIZE
end_ifndef

begin_define
define|#
directive|define
name|TULIP_BURSTSIZE
parameter_list|(
name|unit
parameter_list|)
value|3
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|tulip_if
value|tulip_ac.ac_if
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|tulip_unit
end_ifndef

begin_define
define|#
directive|define
name|tulip_unit
value|tulip_ac.ac_if.if_unit
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|tulip_name
value|tulip_ac.ac_if.if_name
end_define

begin_define
define|#
directive|define
name|tulip_hwaddr
value|tulip_ac.ac_enaddr
end_define

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|tulip_bpf
argument_list|)
operator|&&
operator|(
operator|!
name|defined
argument_list|(
name|__bsdi__
argument_list|)
operator|||
name|_BSDI_VERSION
operator|>=
literal|199401
operator|)
end_if

begin_define
define|#
directive|define
name|tulip_bpf
value|tulip_ac.ac_if.if_bpf
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|tulip_intrfunc_t
argument_list|)
end_if

begin_define
define|#
directive|define
name|tulip_intrfunc_t
value|int
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|TULIP_KVATOPHYS
argument_list|)
end_if

begin_define
define|#
directive|define
name|TULIP_KVATOPHYS
parameter_list|(
name|sc
parameter_list|,
name|va
parameter_list|)
value|vtophys(va)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * While I think FreeBSD's 2.2 change to the bpf is a nice simplification,  * it does add yet more conditional code to this driver.  Sigh.  */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|TULIP_BPF_MTAP
argument_list|)
operator|&&
name|NBPFILTER
operator|>
literal|0
end_if

begin_define
define|#
directive|define
name|TULIP_BPF_MTAP
parameter_list|(
name|sc
parameter_list|,
name|m
parameter_list|)
value|bpf_mtap((sc)->tulip_bpf, m)
end_define

begin_define
define|#
directive|define
name|TULIP_BPF_TAP
parameter_list|(
name|sc
parameter_list|,
name|p
parameter_list|,
name|l
parameter_list|)
value|bpf_tap((sc)->tulip_bpf, p, l)
end_define

begin_define
define|#
directive|define
name|TULIP_BPF_ATTACH
parameter_list|(
name|sc
parameter_list|)
value|bpfattach(&(sc)->tulip_bpf,&(sc)->tulip_if, DLT_EN10MB, sizeof(struct ether_header))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * However, this change to FreeBSD I am much less enamored with.  */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|TULIP_EADDR_FMT
argument_list|)
end_if

begin_define
define|#
directive|define
name|TULIP_EADDR_FMT
value|"%s"
end_define

begin_define
define|#
directive|define
name|TULIP_EADDR_ARGS
parameter_list|(
name|addr
parameter_list|)
value|ether_sprintf(addr)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|TULIP_CRC32_POLY
value|0xEDB88320UL
end_define

begin_comment
comment|/* CRC-32 Poly -- Little Endian */
end_comment

begin_define
define|#
directive|define
name|TULIP_MAX_TXSEG
value|30
end_define

begin_define
define|#
directive|define
name|TULIP_ADDREQUAL
parameter_list|(
name|a1
parameter_list|,
name|a2
parameter_list|)
define|\
value|(((u_int16_t *)a1)[0] == ((u_int16_t *)a2)[0] \&& ((u_int16_t *)a1)[1] == ((u_int16_t *)a2)[1] \&& ((u_int16_t *)a1)[2] == ((u_int16_t *)a2)[2])
end_define

begin_define
define|#
directive|define
name|TULIP_ADDRBRDCST
parameter_list|(
name|a1
parameter_list|)
define|\
value|(((u_int16_t *)a1)[0] == 0xFFFFU \&& ((u_int16_t *)a1)[1] == 0xFFFFU \&& ((u_int16_t *)a1)[2] == 0xFFFFU)
end_define

begin_typedef
typedef|typedef
name|int
name|tulip_spl_t
typedef|;
end_typedef

begin_function_decl
specifier|static
name|tulip_intrfunc_t
name|tulip_intr_shared
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tulip_intrfunc_t
name|tulip_intr_normal
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|tulip_reset
parameter_list|(
name|tulip_softc_t
modifier|*
specifier|const
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ifnet_ret_t
name|tulip_ifstart
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|tulip_rx_intr
parameter_list|(
name|tulip_softc_t
modifier|*
specifier|const
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|tulip_addr_filter
parameter_list|(
name|tulip_softc_t
modifier|*
specifier|const
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|unsigned
name|tulip_mii_readreg
parameter_list|(
name|tulip_softc_t
modifier|*
specifier|const
name|sc
parameter_list|,
name|unsigned
name|devaddr
parameter_list|,
name|unsigned
name|regno
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|tulip_mii_writereg
parameter_list|(
name|tulip_softc_t
modifier|*
specifier|const
name|sc
parameter_list|,
name|unsigned
name|devaddr
parameter_list|,
name|unsigned
name|regno
parameter_list|,
name|unsigned
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_escape
end_escape

begin_function
specifier|static
name|int
name|tulip_21040_media_probe
parameter_list|(
name|tulip_softc_t
modifier|*
specifier|const
name|sc
parameter_list|)
block|{
name|int
name|cnt
decl_stmt|;
name|TULIP_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_sia_connectivity
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TULIP_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_sia_connectivity
argument_list|,
name|TULIP_SIACONN_10BASET
argument_list|)
expr_stmt|;
for|for
control|(
name|cnt
operator|=
literal|0
init|;
name|cnt
operator|<
literal|2400
condition|;
name|cnt
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|TULIP_CSR_READ
argument_list|(
name|sc
argument_list|,
name|csr_sia_status
argument_list|)
operator|&
name|TULIP_SIASTS_LINKFAIL
operator|)
operator|==
literal|0
condition|)
break|break;
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|tulip_if
operator|.
name|if_baudrate
operator|=
literal|10000000
expr_stmt|;
return|return
operator|(
name|TULIP_CSR_READ
argument_list|(
name|sc
argument_list|,
name|csr_sia_status
argument_list|)
operator|&
name|TULIP_SIASTS_LINKFAIL
operator|)
operator|!=
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|tulip_21040_media_select
parameter_list|(
name|tulip_softc_t
modifier|*
specifier|const
name|sc
parameter_list|)
block|{
name|sc
operator|->
name|tulip_cmdmode
operator||=
name|TULIP_CMD_CAPTREFFCT
operator||
name|TULIP_CMD_THRSHLD160
operator||
name|TULIP_CMD_BACKOFFCTR
expr_stmt|;
name|TULIP_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_sia_connectivity
argument_list|,
name|TULIP_SIACONN_RESET
argument_list|)
expr_stmt|;
name|sc
operator|->
name|tulip_flags
operator||=
name|TULIP_SQETEST
operator||
name|TULIP_LINKUP
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|tulip_if
operator|.
name|if_flags
operator|&
name|IFF_ALTPHYS
condition|)
block|{
name|TULIP_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_sia_connectivity
argument_list|,
name|TULIP_SIACONN_AUI
argument_list|)
expr_stmt|;
name|sc
operator|->
name|tulip_media
operator|=
name|TULIP_MEDIA_BNCAUI
expr_stmt|;
name|sc
operator|->
name|tulip_cmdmode
operator|&=
operator|~
name|TULIP_CMD_FULLDUPLEX
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|tulip_flags
operator|&
name|TULIP_ALTPHYS
operator|)
operator|==
literal|0
condition|)
name|sc
operator|->
name|tulip_flags
operator||=
name|TULIP_PRINTMEDIA
operator||
name|TULIP_ALTPHYS
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|sc
operator|->
name|tulip_if
operator|.
name|if_flags
operator|&
name|IFF_FULLDUPLEX
condition|)
block|{
name|sc
operator|->
name|tulip_cmdmode
operator||=
name|TULIP_CMD_FULLDUPLEX
expr_stmt|;
name|sc
operator|->
name|tulip_media
operator|=
name|TULIP_MEDIA_10BASET_FD
expr_stmt|;
name|sc
operator|->
name|tulip_flags
operator|&=
operator|~
name|TULIP_SQETEST
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|tulip_cmdmode
operator|&=
operator|~
name|TULIP_CMD_FULLDUPLEX
expr_stmt|;
name|sc
operator|->
name|tulip_media
operator|=
name|TULIP_MEDIA_10BASET
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|tulip_flags
operator|&
name|TULIP_ALTPHYS
condition|)
name|sc
operator|->
name|tulip_flags
operator|^=
name|TULIP_PRINTMEDIA
operator||
name|TULIP_ALTPHYS
expr_stmt|;
name|TULIP_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_sia_connectivity
argument_list|,
name|TULIP_SIACONN_10BASET
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|tulip_21040_10baset_only_media_probe
parameter_list|(
name|tulip_softc_t
modifier|*
specifier|const
name|sc
parameter_list|)
block|{
name|TULIP_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_sia_connectivity
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TULIP_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_sia_connectivity
argument_list|,
name|TULIP_SIACONN_10BASET
argument_list|)
expr_stmt|;
name|sc
operator|->
name|tulip_if
operator|.
name|if_baudrate
operator|=
literal|10000000
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|tulip_21040_10baset_only_media_select
parameter_list|(
name|tulip_softc_t
modifier|*
specifier|const
name|sc
parameter_list|)
block|{
name|sc
operator|->
name|tulip_cmdmode
operator||=
name|TULIP_CMD_CAPTREFFCT
operator||
name|TULIP_CMD_THRSHLD160
operator||
name|TULIP_CMD_BACKOFFCTR
expr_stmt|;
name|sc
operator|->
name|tulip_flags
operator||=
name|TULIP_LINKUP
expr_stmt|;
name|TULIP_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_sia_connectivity
argument_list|,
name|TULIP_SIACONN_RESET
argument_list|)
expr_stmt|;
name|TULIP_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_sia_connectivity
argument_list|,
name|TULIP_SIACONN_10BASET
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|tulip_if
operator|.
name|if_flags
operator|&
name|IFF_FULLDUPLEX
condition|)
block|{
name|sc
operator|->
name|tulip_cmdmode
operator||=
name|TULIP_CMD_FULLDUPLEX
expr_stmt|;
name|sc
operator|->
name|tulip_media
operator|=
name|TULIP_MEDIA_10BASET_FD
expr_stmt|;
name|sc
operator|->
name|tulip_flags
operator|&=
operator|~
name|TULIP_SQETEST
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|tulip_cmdmode
operator|&=
operator|~
name|TULIP_CMD_FULLDUPLEX
expr_stmt|;
name|sc
operator|->
name|tulip_media
operator|=
name|TULIP_MEDIA_10BASET
expr_stmt|;
name|sc
operator|->
name|tulip_flags
operator||=
name|TULIP_SQETEST
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|tulip_flags
operator|&
name|TULIP_ALTPHYS
condition|)
name|sc
operator|->
name|tulip_flags
operator|^=
name|TULIP_PRINTMEDIA
operator||
name|TULIP_ALTPHYS
expr_stmt|;
name|sc
operator|->
name|tulip_flags
operator|&=
operator|~
name|TULIP_ALTPHYS
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|tulip_21040_auibnc_only_media_probe
parameter_list|(
name|tulip_softc_t
modifier|*
specifier|const
name|sc
parameter_list|)
block|{
name|TULIP_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_sia_connectivity
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TULIP_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_sia_connectivity
argument_list|,
name|TULIP_SIACONN_AUI
argument_list|)
expr_stmt|;
name|sc
operator|->
name|tulip_if
operator|.
name|if_baudrate
operator|=
literal|10000000
expr_stmt|;
name|sc
operator|->
name|tulip_flags
operator||=
name|TULIP_SQETEST
operator||
name|TULIP_LINKUP
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|tulip_21040_auibnc_only_media_select
parameter_list|(
name|tulip_softc_t
modifier|*
specifier|const
name|sc
parameter_list|)
block|{
name|sc
operator|->
name|tulip_cmdmode
operator||=
name|TULIP_CMD_CAPTREFFCT
operator||
name|TULIP_CMD_THRSHLD160
operator||
name|TULIP_CMD_BACKOFFCTR
expr_stmt|;
name|TULIP_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_sia_connectivity
argument_list|,
name|TULIP_SIACONN_RESET
argument_list|)
expr_stmt|;
name|TULIP_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_sia_connectivity
argument_list|,
name|TULIP_SIACONN_AUI
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|tulip_if
operator|.
name|if_flags
operator|&
name|IFF_FULLDUPLEX
condition|)
name|sc
operator|->
name|tulip_if
operator|.
name|if_flags
operator|&=
operator|~
name|IFF_FULLDUPLEX
expr_stmt|;
name|sc
operator|->
name|tulip_media
operator|=
name|TULIP_MEDIA_BNCAUI
expr_stmt|;
name|sc
operator|->
name|tulip_cmdmode
operator|&=
operator|~
name|TULIP_CMD_FULLDUPLEX
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|tulip_flags
operator|&
name|TULIP_ALTPHYS
operator|)
operator|==
literal|0
condition|)
name|sc
operator|->
name|tulip_flags
operator||=
name|TULIP_PRINTMEDIA
operator||
name|TULIP_ALTPHYS
expr_stmt|;
name|sc
operator|->
name|tulip_flags
operator|&=
operator|~
name|TULIP_ALTPHYS
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|tulip_boardsw_t
name|tulip_21040_boardsw
init|=
block|{
name|TULIP_21040_GENERIC
block|,
literal|""
block|,
name|tulip_21040_media_probe
block|,
name|tulip_21040_media_select
block|,
name|NULL
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|tulip_boardsw_t
name|tulip_21040_10baset_only_boardsw
init|=
block|{
name|TULIP_21040_GENERIC
block|,
literal|""
block|,
name|tulip_21040_10baset_only_media_probe
block|,
name|tulip_21040_10baset_only_media_select
block|,
name|NULL
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|tulip_boardsw_t
name|tulip_21040_auibnc_only_boardsw
init|=
block|{
name|TULIP_21040_GENERIC
block|,
literal|""
block|,
name|tulip_21040_auibnc_only_media_probe
block|,
name|tulip_21040_auibnc_only_media_select
block|,
name|NULL
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|tulip_boardsw_t
name|tulip_21040_zx314_master_boardsw
init|=
block|{
name|TULIP_21040_ZX314_MASTER
block|,
literal|"ZNYX ZX314 "
block|,
name|tulip_21040_10baset_only_media_probe
block|,
name|tulip_21040_10baset_only_media_select
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|tulip_boardsw_t
name|tulip_21040_zx314_slave_boardsw
init|=
block|{
name|TULIP_21040_ZX314_SLAVE
block|,
literal|"ZNYX ZX314 "
block|,
name|tulip_21040_10baset_only_media_probe
block|,
name|tulip_21040_10baset_only_media_select
block|}
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_decl_stmt
specifier|static
specifier|const
name|phy_attr_t
name|tulip_phy_attrlist
index|[]
init|=
block|{
block|{
literal|"NS DP83840"
block|,
literal|0x20005c00
block|,
literal|0
block|,
comment|/* 08-00-17 */
block|{
block|{
literal|0x19
block|,
literal|0x40
block|,
literal|0x40
block|}
block|,
comment|/* 10TX */
block|{
literal|0x19
block|,
literal|0x40
block|,
literal|0x00
block|}
block|,
comment|/* 100TX */
block|}
block|}
block|,
block|{
literal|"Seeq 80C240"
block|,
literal|0x0281F400
block|,
literal|0
block|,
comment|/* 00-A0-7D */
block|{
block|{
literal|0x12
block|,
literal|0x10
block|,
literal|0x00
block|}
block|,
comment|/* 10T */
block|{ }
block|,
comment|/* 100TX */
block|{
literal|0x12
block|,
literal|0x10
block|,
literal|0x10
block|}
block|,
comment|/* 100T4 */
block|{
literal|0x12
block|,
literal|0x08
block|,
literal|0x08
block|}
block|,
comment|/* FULL_DUPLEX */
block|}
block|}
block|,
block|{
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|tulip_21140_mii_probe
parameter_list|(
name|tulip_softc_t
modifier|*
specifier|const
name|sc
parameter_list|)
block|{
name|unsigned
name|devaddr
decl_stmt|;
for|for
control|(
name|devaddr
operator|=
literal|31
init|;
name|devaddr
operator|>
literal|0
condition|;
name|devaddr
operator|--
control|)
block|{
name|unsigned
name|status
init|=
name|tulip_mii_readreg
argument_list|(
name|sc
argument_list|,
name|devaddr
argument_list|,
name|PHYREG_STATUS
argument_list|)
decl_stmt|;
name|unsigned
name|media
decl_stmt|;
name|unsigned
name|id
decl_stmt|;
specifier|const
name|phy_attr_t
modifier|*
name|attr
decl_stmt|;
name|tulip_phy_t
modifier|*
name|phy
decl_stmt|;
specifier|const
name|char
modifier|*
name|sep
decl_stmt|;
if|if
condition|(
name|status
operator|==
literal|0
operator|||
name|status
operator|==
literal|0xFFFF
operator|||
name|status
operator|<
name|PHYSTS_10BASET
condition|)
continue|continue;
if|if
condition|(
operator|(
name|status
operator|&
name|PHYSTS_EXTENDED_REGS
operator|)
operator|==
literal|0
condition|)
block|{
name|loudprintf
argument_list|(
name|TULIP_PRINTF_FMT
literal|"(phy%d): skipping (no extended register set)\n"
argument_list|,
name|TULIP_PRINTF_ARGS
argument_list|,
name|devaddr
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|id
operator|=
operator|(
name|tulip_mii_readreg
argument_list|(
name|sc
argument_list|,
name|devaddr
argument_list|,
name|PHYREG_IDLOW
argument_list|)
operator|<<
literal|16
operator|)
operator||
name|tulip_mii_readreg
argument_list|(
name|sc
argument_list|,
name|devaddr
argument_list|,
name|PHYREG_IDHIGH
argument_list|)
expr_stmt|;
for|for
control|(
name|attr
operator|=
name|tulip_phy_attrlist
init|;
name|attr
operator|->
name|attr_name
operator|!=
name|NULL
condition|;
name|attr
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|id
operator|&
operator|~
literal|0x0F
operator|)
operator|==
name|attr
operator|->
name|attr_id
condition|)
break|break;
block|}
if|if
condition|(
name|attr
operator|->
name|attr_name
operator|==
name|NULL
condition|)
block|{
name|loudprintf
argument_list|(
name|TULIP_PRINTF_FMT
literal|"(phy%d): skipping (unrecogized id 0x%08x)\n"
argument_list|,
name|TULIP_PRINTF_ARGS
argument_list|,
name|devaddr
argument_list|,
name|id
operator|&
operator|~
literal|0x0F
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|MALLOC
argument_list|(
name|phy
argument_list|,
name|tulip_phy_t
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
name|tulip_phy_t
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|phy
operator|==
name|NULL
condition|)
block|{
name|loudprintf
argument_list|(
name|TULIP_PRINTF_FMT
literal|"(phy%d): skipping (memory allocation failed)\n"
argument_list|,
name|TULIP_PRINTF_ARGS
argument_list|,
name|devaddr
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|phy
operator|->
name|phy_attr
operator|=
name|attr
expr_stmt|;
name|phy
operator|->
name|phy_devaddr
operator|=
name|devaddr
expr_stmt|;
name|phy
operator|->
name|phy_status
operator|=
name|status
expr_stmt|;
name|phy
operator|->
name|phy_next
operator|=
name|sc
operator|->
name|tulip_phys
expr_stmt|;
name|sc
operator|->
name|tulip_phys
operator|=
name|phy
expr_stmt|;
name|loudprintf
argument_list|(
name|TULIP_PRINTF_FMT
literal|"(phy%d): model = %s%s\n"
argument_list|,
name|TULIP_PRINTF_ARGS
argument_list|,
name|phy
operator|->
name|phy_devaddr
argument_list|,
name|phy
operator|->
name|phy_attr
operator|->
name|attr_name
argument_list|,
operator|(
name|phy
operator|->
name|phy_status
operator|&
name|PHYSTS_CAN_AUTONEG
operator|)
condition|?
literal|" (supports media autonegotiation)"
else|:
literal|""
argument_list|)
expr_stmt|;
name|loudprintf
argument_list|(
name|TULIP_PRINTF_FMT
literal|"(phy%d): media = "
argument_list|,
name|TULIP_PRINTF_ARGS
argument_list|,
name|phy
operator|->
name|phy_devaddr
argument_list|)
expr_stmt|;
for|for
control|(
name|media
operator|=
literal|11
operator|,
name|sep
operator|=
literal|""
init|;
name|media
operator|<
literal|16
condition|;
name|media
operator|++
control|)
block|{
if|if
condition|(
name|status
operator|&
operator|(
literal|1
operator|<<
name|media
operator|)
condition|)
block|{
name|loudprintf
argument_list|(
literal|"%s%s"
argument_list|,
name|sep
argument_list|,
name|tulip_mediums
index|[
name|tulip_phy_statuses
index|[
name|media
operator|-
literal|11
index|]
index|]
argument_list|)
expr_stmt|;
name|sep
operator|=
literal|", "
expr_stmt|;
block|}
block|}
name|loudprintf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  * The general purpose timer of the 21140/21140a/21142 is kind  * of strange.  It can run on one of 3 speeds depending on the mode  * of the chip.  *  *	10Mb/s port	204.8  microseconds (also speed of 21041 timer)  *	100Mb/s MII	 81.92 microseconds  *	10Mb/s MII	819.2  microseconds  *  * So we use a tick of a 819.2 microseconds and bias the number of ticks  * required based on the mode in which we are running.  2560/3125 = .8192  * so we use the reciprocal to scale the ms delay to 21140 ticks.  */
end_comment

begin_function
specifier|static
name|void
name|tulip_21140_gp_timer_set
parameter_list|(
name|tulip_softc_t
modifier|*
specifier|const
name|sc
parameter_list|,
name|unsigned
name|msdelay
parameter_list|)
block|{
name|u_int32_t
name|cmdmode
init|=
name|TULIP_CSR_READ
argument_list|(
name|sc
argument_list|,
name|csr_command
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|TULIP_DEBUG
name|sc
operator|->
name|tulip_dbg
operator|.
name|dbg_msdelay
operator|=
name|msdelay
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|cmdmode
operator|&
name|TULIP_CMD_PORTSELECT
operator|)
operator|==
literal|0
condition|)
block|{
name|msdelay
operator|*=
literal|4
expr_stmt|;
ifdef|#
directive|ifdef
name|TULIP_DEBUG
name|sc
operator|->
name|tulip_dbg
operator|.
name|dbg_gprate
operator|=
name|TULIP_GPTMR_10MB_MII
expr_stmt|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
operator|(
name|cmdmode
operator|&
name|TULIP_CMD_TXTHRSHLDCTL
operator|)
operator|==
literal|0
condition|)
block|{
name|msdelay
operator|*=
literal|10
expr_stmt|;
ifdef|#
directive|ifdef
name|TULIP_DEBUG
name|sc
operator|->
name|tulip_dbg
operator|.
name|dbg_gprate
operator|=
name|TULIP_GPTMR_100MB_MII
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|tulip_dbg
operator|.
name|dbg_gprate
operator|=
name|TULIP_GPTMR_10MB
expr_stmt|;
endif|#
directive|endif
block|}
if|#
directive|if
literal|0
block|if (sc->tulip_chipid == TULIP_21140A) 	msdelay *= 10;
endif|#
directive|endif
name|TULIP_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_status
argument_list|,
name|TULIP_STS_GPTIMEOUT
argument_list|)
expr_stmt|;
name|TULIP_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_gp_timer
argument_list|,
operator|(
name|msdelay
operator|*
literal|313
operator|+
literal|128
operator|)
operator|/
literal|256
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|tulip_flags
operator|&
name|TULIP_DEVICEPROBE
condition|)
block|{
name|sc
operator|->
name|tulip_flags
operator||=
name|TULIP_FAKEGPTIMEOUT
expr_stmt|;
block|}
else|else
block|{
name|TULIP_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_intr
argument_list|,
name|sc
operator|->
name|tulip_intrmask
argument_list|)
expr_stmt|;
name|sc
operator|->
name|tulip_flags
operator|&=
operator|~
name|TULIP_FAKEGPTIMEOUT
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|TULIP_DEBUG
name|sc
operator|->
name|tulip_dbg
operator|.
name|dbg_gpticks
operator|=
operator|(
name|msdelay
operator|*
literal|313
operator|+
literal|128
operator|)
operator|/
literal|256
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|int
name|tulip_21140_map_abilities
parameter_list|(
name|tulip_softc_t
modifier|*
specifier|const
name|sc
parameter_list|,
specifier|const
name|tulip_phy_t
modifier|*
specifier|const
name|phy
parameter_list|,
name|unsigned
name|abilities
parameter_list|)
block|{
name|sc
operator|->
name|tulip_abilities
operator|=
name|abilities
expr_stmt|;
if|if
condition|(
name|abilities
operator|&
name|PHYSTS_100BASETX_FD
condition|)
block|{
name|sc
operator|->
name|tulip_media
operator|=
name|TULIP_MEDIA_100BASETX_FD
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|abilities
operator|&
name|PHYSTS_100BASETX
condition|)
block|{
name|sc
operator|->
name|tulip_media
operator|=
name|TULIP_MEDIA_100BASETX
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|abilities
operator|&
name|PHYSTS_100BASET4
condition|)
block|{
name|sc
operator|->
name|tulip_media
operator|=
name|TULIP_MEDIA_100BASET4
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|abilities
operator|&
name|PHYSTS_10BASET_FD
condition|)
block|{
name|sc
operator|->
name|tulip_media
operator|=
name|TULIP_MEDIA_10BASET_FD
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|abilities
operator|&
name|PHYSTS_10BASET
condition|)
block|{
name|sc
operator|->
name|tulip_media
operator|=
name|TULIP_MEDIA_10BASET
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|tulip_media
operator|=
name|TULIP_MEDIA_UNKNOWN
expr_stmt|;
name|sc
operator|->
name|tulip_probe_state
operator|=
name|TULIP_PROBE_MEDIATEST
expr_stmt|;
return|return
literal|1
return|;
block|}
name|sc
operator|->
name|tulip_intrmask
operator|&=
operator|~
name|TULIP_STS_GPTIMEOUT
expr_stmt|;
name|sc
operator|->
name|tulip_flags
operator|&=
operator|~
name|TULIP_TXPROBE_ACTIVE
expr_stmt|;
name|sc
operator|->
name|tulip_flags
operator||=
name|TULIP_PRINTMEDIA
operator||
name|TULIP_NEEDRESET
expr_stmt|;
name|sc
operator|->
name|tulip_probe_state
operator|=
name|TULIP_PROBE_INACTIVE
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|tulip_21140_autonegotiate
parameter_list|(
name|tulip_softc_t
modifier|*
specifier|const
name|sc
parameter_list|,
specifier|const
name|tulip_phy_t
modifier|*
specifier|const
name|phy
parameter_list|)
block|{
name|u_int32_t
name|data
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|tulip_flags
operator|&
name|TULIP_INRESET
condition|)
block|{
name|sc
operator|->
name|tulip_probe_state
operator|=
name|TULIP_PROBE_INACTIVE
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|tulip_if
operator|.
name|if_flags
operator|&
name|IFF_NOAUTONEG
condition|)
block|{
name|sc
operator|->
name|tulip_probe_state
operator|=
name|TULIP_PROBE_MEDIATEST
expr_stmt|;
name|data
operator|=
name|tulip_mii_readreg
argument_list|(
name|sc
argument_list|,
name|phy
operator|->
name|phy_devaddr
argument_list|,
name|PHYREG_CONTROL
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|&
name|PHYCTL_AUTONEG_ENABLE
condition|)
block|{
name|data
operator|&=
operator|~
name|PHYCTL_AUTONEG_ENABLE
expr_stmt|;
name|tulip_mii_writereg
argument_list|(
name|sc
argument_list|,
name|phy
operator|->
name|phy_devaddr
argument_list|,
name|PHYREG_CONTROL
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
name|again
label|:
switch|switch
condition|(
name|sc
operator|->
name|tulip_probe_state
condition|)
block|{
case|case
name|TULIP_PROBE_INACTIVE
case|:
block|{
name|sc
operator|->
name|tulip_flags
operator||=
name|TULIP_TXPROBE_ACTIVE
expr_stmt|;
name|tulip_mii_writereg
argument_list|(
name|sc
argument_list|,
name|phy
operator|->
name|phy_devaddr
argument_list|,
name|PHYREG_CONTROL
argument_list|,
name|PHYCTL_RESET
argument_list|)
expr_stmt|;
name|sc
operator|->
name|tulip_gpticks
operator|=
literal|10
expr_stmt|;
name|sc
operator|->
name|tulip_intrmask
operator||=
name|TULIP_STS_ABNRMLINTR
operator||
name|TULIP_STS_GPTIMEOUT
operator||
name|TULIP_STS_NORMALINTR
expr_stmt|;
name|sc
operator|->
name|tulip_probe_state
operator|=
name|TULIP_PROBE_PHYRESET
expr_stmt|;
goto|goto
name|again
goto|;
block|}
case|case
name|TULIP_PROBE_PHYRESET
case|:
block|{
name|data
operator|=
name|tulip_mii_readreg
argument_list|(
name|sc
argument_list|,
name|phy
operator|->
name|phy_devaddr
argument_list|,
name|PHYREG_CONTROL
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|&
name|PHYCTL_RESET
condition|)
block|{
if|if
condition|(
operator|--
name|sc
operator|->
name|tulip_gpticks
operator|>
literal|0
condition|)
block|{
name|tulip_21140_gp_timer_set
argument_list|(
name|sc
argument_list|,
literal|100
argument_list|)
expr_stmt|;
return|return;
block|}
name|printf
argument_list|(
name|TULIP_PRINTF_FMT
literal|"(phy%d): error: reset of PHY never completed!\n"
argument_list|,
name|TULIP_PRINTF_ARGS
argument_list|,
name|phy
operator|->
name|phy_devaddr
argument_list|)
expr_stmt|;
name|sc
operator|->
name|tulip_flags
operator|&=
operator|~
name|TULIP_TXPROBE_ACTIVE
expr_stmt|;
name|sc
operator|->
name|tulip_probe_state
operator|=
name|TULIP_PROBE_FAILED
expr_stmt|;
name|sc
operator|->
name|tulip_if
operator|.
name|if_flags
operator|&=
operator|~
operator|(
name|IFF_UP
operator||
name|IFF_RUNNING
operator|)
expr_stmt|;
name|sc
operator|->
name|tulip_intrmask
operator|&=
operator|~
name|TULIP_STS_GPTIMEOUT
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|phy
operator|->
name|phy_status
operator|&
name|PHYSTS_CAN_AUTONEG
operator|)
operator|==
literal|0
operator|&&
operator|(
name|sc
operator|->
name|tulip_if
operator|.
name|if_flags
operator|&
name|IFF_NOAUTONEG
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|TULIP_DEBUG
name|loudprintf
argument_list|(
name|TULIP_PRINTF_FMT
literal|"(phy%d): autonegotiation disabled\n"
argument_list|,
name|TULIP_PRINTF_ARGS
argument_list|,
name|phy
operator|->
name|phy_devaddr
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sc
operator|->
name|tulip_probe_state
operator|=
name|TULIP_PROBE_MEDIATEST
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|tulip_mii_readreg
argument_list|(
name|sc
argument_list|,
name|phy
operator|->
name|phy_devaddr
argument_list|,
name|PHYREG_AUTONEG_ADVERTISEMENT
argument_list|)
operator|!=
operator|(
operator|(
name|phy
operator|->
name|phy_status
operator|>>
literal|6
operator|)
operator||
literal|0x01
operator|)
condition|)
name|tulip_mii_writereg
argument_list|(
name|sc
argument_list|,
name|phy
operator|->
name|phy_devaddr
argument_list|,
name|PHYREG_AUTONEG_ADVERTISEMENT
argument_list|,
operator|(
name|phy
operator|->
name|phy_status
operator|>>
literal|6
operator|)
operator||
literal|0x01
argument_list|)
expr_stmt|;
name|tulip_mii_writereg
argument_list|(
name|sc
argument_list|,
name|phy
operator|->
name|phy_devaddr
argument_list|,
name|PHYREG_CONTROL
argument_list|,
name|data
operator||
name|PHYCTL_AUTONEG_RESTART
operator||
name|PHYCTL_AUTONEG_ENABLE
argument_list|)
expr_stmt|;
name|data
operator|=
name|tulip_mii_readreg
argument_list|(
name|sc
argument_list|,
name|phy
operator|->
name|phy_devaddr
argument_list|,
name|PHYREG_CONTROL
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TULIP_DEBUG
if|if
condition|(
operator|(
name|data
operator|&
name|PHYCTL_AUTONEG_ENABLE
operator|)
operator|==
literal|0
condition|)
name|loudprintf
argument_list|(
name|TULIP_PRINTF_FMT
literal|"(phy%d): oops: enable autonegotiation failed: 0x%04x\n"
argument_list|,
name|TULIP_PRINTF_ARGS
argument_list|,
name|phy
operator|->
name|phy_devaddr
argument_list|,
name|data
argument_list|)
expr_stmt|;
else|else
name|loudprintf
argument_list|(
name|TULIP_PRINTF_FMT
literal|"(phy%d): autonegotiation restarted: 0x%04x\n"
argument_list|,
name|TULIP_PRINTF_ARGS
argument_list|,
name|phy
operator|->
name|phy_devaddr
argument_list|,
name|data
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sc
operator|->
name|tulip_probe_state
operator|=
name|TULIP_PROBE_PHYAUTONEG
expr_stmt|;
name|sc
operator|->
name|tulip_gpticks
operator|=
literal|60
expr_stmt|;
goto|goto
name|again
goto|;
block|}
case|case
name|TULIP_PROBE_PHYAUTONEG
case|:
block|{
name|data
operator|=
name|tulip_mii_readreg
argument_list|(
name|sc
argument_list|,
name|phy
operator|->
name|phy_devaddr
argument_list|,
name|PHYREG_STATUS
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|data
operator|&
name|PHYSTS_AUTONEG_DONE
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|--
name|sc
operator|->
name|tulip_gpticks
operator|>
literal|0
condition|)
block|{
name|tulip_21140_gp_timer_set
argument_list|(
name|sc
argument_list|,
literal|100
argument_list|)
expr_stmt|;
return|return;
block|}
ifdef|#
directive|ifdef
name|TULIP_DEBUG
name|loudprintf
argument_list|(
name|TULIP_PRINTF_FMT
literal|"(phy%d): autonegotiation timeout: sts=0x%04x, ctl=0x%04x\n"
argument_list|,
name|TULIP_PRINTF_ARGS
argument_list|,
name|phy
operator|->
name|phy_devaddr
argument_list|,
name|data
argument_list|,
name|tulip_mii_readreg
argument_list|(
name|sc
argument_list|,
name|phy
operator|->
name|phy_devaddr
argument_list|,
name|PHYREG_CONTROL
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sc
operator|->
name|tulip_probe_state
operator|=
name|TULIP_PROBE_MEDIATEST
expr_stmt|;
return|return;
block|}
name|data
operator|=
name|tulip_mii_readreg
argument_list|(
name|sc
argument_list|,
name|phy
operator|->
name|phy_devaddr
argument_list|,
name|PHYREG_AUTONEG_ABILITIES
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TULIP_DEBUG
name|loudprintf
argument_list|(
name|TULIP_PRINTF_FMT
literal|"(phy%d): autonegotiation complete: 0x%04x\n"
argument_list|,
name|TULIP_PRINTF_ARGS
argument_list|,
name|phy
operator|->
name|phy_devaddr
argument_list|,
name|data
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|data
operator|=
operator|(
name|data
operator|<<
literal|6
operator|)
operator|&
name|phy
operator|->
name|phy_status
expr_stmt|;
name|tulip_21140_map_abilities
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|data
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
ifdef|#
directive|ifdef
name|TULIP_DEBUG
name|loudprintf
argument_list|(
name|TULIP_PRINTF_FMT
literal|"(phy%d): autonegotiation failure: state = %d\n"
argument_list|,
name|TULIP_PRINTF_ARGS
argument_list|,
name|phy
operator|->
name|phy_devaddr
argument_list|,
name|sc
operator|->
name|tulip_probe_state
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|tulip_media_t
name|tulip_21140_phy_readspecific
parameter_list|(
name|tulip_softc_t
modifier|*
specifier|const
name|sc
parameter_list|,
specifier|const
name|tulip_phy_t
modifier|*
specifier|const
name|phy
parameter_list|)
block|{
specifier|const
name|phy_attr_t
modifier|*
specifier|const
name|attr
init|=
name|phy
operator|->
name|phy_attr
decl_stmt|;
name|unsigned
name|data
decl_stmt|;
name|unsigned
name|idx
init|=
literal|0
decl_stmt|;
specifier|static
specifier|const
name|tulip_media_t
name|table
index|[]
init|=
block|{
name|TULIP_MEDIA_UNKNOWN
block|,
name|TULIP_MEDIA_10BASET
block|,
name|TULIP_MEDIA_100BASETX
block|,
name|TULIP_MEDIA_100BASET4
block|,
name|TULIP_MEDIA_UNKNOWN
block|,
name|TULIP_MEDIA_10BASET_FD
block|,
name|TULIP_MEDIA_100BASETX_FD
block|,
name|TULIP_MEDIA_UNKNOWN
block|}
decl_stmt|;
comment|/*      * Don't read phy specific registers if link is not up.      */
name|data
operator|=
name|tulip_mii_readreg
argument_list|(
name|sc
argument_list|,
name|phy
operator|->
name|phy_devaddr
argument_list|,
name|PHYREG_STATUS
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|data
operator|&
name|PHYSTS_LINK_UP
operator|)
operator|==
literal|0
condition|)
return|return
name|TULIP_MEDIA_UNKNOWN
return|;
if|if
condition|(
name|attr
operator|->
name|attr_modes
index|[
name|PHY_MODE_100TX
index|]
operator|.
name|pm_regno
condition|)
block|{
specifier|const
name|phy_modedata_t
modifier|*
specifier|const
name|pm
init|=
operator|&
name|attr
operator|->
name|attr_modes
index|[
name|PHY_MODE_100TX
index|]
decl_stmt|;
name|data
operator|=
name|tulip_mii_readreg
argument_list|(
name|sc
argument_list|,
name|phy
operator|->
name|phy_devaddr
argument_list|,
name|pm
operator|->
name|pm_regno
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|data
operator|&
name|pm
operator|->
name|pm_mask
operator|)
operator|==
name|pm
operator|->
name|pm_value
condition|)
name|idx
operator|=
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|idx
operator|==
literal|0
operator|&&
name|attr
operator|->
name|attr_modes
index|[
name|PHY_MODE_100T4
index|]
operator|.
name|pm_regno
condition|)
block|{
specifier|const
name|phy_modedata_t
modifier|*
specifier|const
name|pm
init|=
operator|&
name|attr
operator|->
name|attr_modes
index|[
name|PHY_MODE_100T4
index|]
decl_stmt|;
name|data
operator|=
name|tulip_mii_readreg
argument_list|(
name|sc
argument_list|,
name|phy
operator|->
name|phy_devaddr
argument_list|,
name|pm
operator|->
name|pm_regno
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|data
operator|&
name|pm
operator|->
name|pm_mask
operator|)
operator|==
name|pm
operator|->
name|pm_value
condition|)
name|idx
operator|=
literal|3
expr_stmt|;
block|}
if|if
condition|(
name|idx
operator|==
literal|0
operator|&&
name|attr
operator|->
name|attr_modes
index|[
name|PHY_MODE_10T
index|]
operator|.
name|pm_regno
condition|)
block|{
specifier|const
name|phy_modedata_t
modifier|*
specifier|const
name|pm
init|=
operator|&
name|attr
operator|->
name|attr_modes
index|[
name|PHY_MODE_10T
index|]
decl_stmt|;
name|data
operator|=
name|tulip_mii_readreg
argument_list|(
name|sc
argument_list|,
name|phy
operator|->
name|phy_devaddr
argument_list|,
name|pm
operator|->
name|pm_regno
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|data
operator|&
name|pm
operator|->
name|pm_mask
operator|)
operator|==
name|pm
operator|->
name|pm_value
condition|)
name|idx
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|idx
operator|!=
literal|0
operator|&&
name|attr
operator|->
name|attr_modes
index|[
name|PHY_MODE_FULLDUPLEX
index|]
operator|.
name|pm_regno
condition|)
block|{
specifier|const
name|phy_modedata_t
modifier|*
specifier|const
name|pm
init|=
operator|&
name|attr
operator|->
name|attr_modes
index|[
name|PHY_MODE_FULLDUPLEX
index|]
decl_stmt|;
name|data
operator|=
name|tulip_mii_readreg
argument_list|(
name|sc
argument_list|,
name|phy
operator|->
name|phy_devaddr
argument_list|,
name|pm
operator|->
name|pm_regno
argument_list|)
expr_stmt|;
name|idx
operator|+=
operator|(
operator|(
name|data
operator|&
name|pm
operator|->
name|pm_mask
operator|)
operator|==
name|pm
operator|->
name|pm_value
condition|?
literal|4
else|:
literal|0
operator|)
expr_stmt|;
block|}
return|return
name|table
index|[
name|idx
index|]
return|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|void
name|tulip_21140_mii_link_monitor
parameter_list|(
name|tulip_softc_t
modifier|*
specifier|const
name|sc
parameter_list|,
specifier|const
name|tulip_phy_t
modifier|*
specifier|const
name|phy
parameter_list|)
block|{
name|u_int32_t
name|data
decl_stmt|;
name|tulip_21140_gp_timer_set
argument_list|(
name|sc
argument_list|,
literal|425
argument_list|)
expr_stmt|;
comment|/*      * Have we seen some packets?  If so, the link must be good.      */
if|if
condition|(
operator|(
name|sc
operator|->
name|tulip_flags
operator|&
operator|(
name|TULIP_RXACT
operator||
name|TULIP_LINKSUSPECT
operator||
name|TULIP_LINKUP
operator|)
operator|)
operator|==
operator|(
name|TULIP_RXACT
operator||
name|TULIP_LINKUP
operator|)
condition|)
block|{
name|sc
operator|->
name|tulip_flags
operator|&=
operator|~
name|TULIP_RXACT
expr_stmt|;
return|return;
block|}
comment|/*      * Read the PHY status register.      */
name|data
operator|=
name|tulip_mii_readreg
argument_list|(
name|sc
argument_list|,
name|phy
operator|->
name|phy_devaddr
argument_list|,
name|PHYREG_STATUS
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|tulip_if
operator|.
name|if_flags
operator|&
name|IFF_NOAUTONEG
operator|)
operator|==
literal|0
operator|&&
operator|(
name|data
operator|&
name|PHYSTS_AUTONEG_DONE
operator|)
condition|)
block|{
comment|/* 	 * If autonegotiation hasn't been disabled and the PHY has complete  	 * autonegotiation, see the if the remote systems abilities have changed. 	 * If so, upgrade or downgrade as appropriate. 	 */
name|unsigned
name|abilities
init|=
name|tulip_mii_readreg
argument_list|(
name|sc
argument_list|,
name|phy
operator|->
name|phy_devaddr
argument_list|,
name|PHYREG_AUTONEG_ABILITIES
argument_list|)
decl_stmt|;
name|abilities
operator|=
operator|(
name|abilities
operator|<<
literal|6
operator|)
operator|&
name|phy
operator|->
name|phy_status
expr_stmt|;
if|if
condition|(
name|abilities
operator|!=
name|sc
operator|->
name|tulip_abilities
condition|)
block|{
name|sc
operator|->
name|tulip_flags
operator||=
name|TULIP_PRINTMEDIA
expr_stmt|;
ifdef|#
directive|ifdef
name|TULIP_DEBUG
name|loudprintf
argument_list|(
name|TULIP_PRINTF_FMT
literal|"(phy%d): autonegotiation changed: 0x%04x -> 0x%04x\n"
argument_list|,
name|TULIP_PRINTF_ARGS
argument_list|,
name|phy
operator|->
name|phy_devaddr
argument_list|,
name|sc
operator|->
name|tulip_abilities
argument_list|,
name|abilities
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|tulip_21140_map_abilities
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|abilities
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/*      * The link is now up.  If was down, say its back up.      */
if|if
condition|(
operator|(
name|data
operator|&
operator|(
name|PHYSTS_LINK_UP
operator||
name|PHYSTS_REMOTE_FAULT
operator|)
operator|)
operator|==
name|PHYSTS_LINK_UP
condition|)
block|{
if|if
condition|(
operator|(
name|sc
operator|->
name|tulip_if
operator|.
name|if_flags
operator|&
name|IFF_NOAUTONEG
operator|)
operator|==
literal|0
condition|)
block|{
name|tulip_media_t
name|media
init|=
name|tulip_21140_phy_readspecific
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|)
decl_stmt|;
if|if
condition|(
name|media
operator|!=
name|sc
operator|->
name|tulip_media
operator|&&
name|media
operator|!=
name|TULIP_MEDIA_UNKNOWN
condition|)
block|{
name|sc
operator|->
name|tulip_media
operator|=
name|media
expr_stmt|;
name|sc
operator|->
name|tulip_flags
operator||=
name|TULIP_PRINTMEDIA
expr_stmt|;
block|}
block|}
name|sc
operator|->
name|tulip_gpticks
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|tulip_flags
operator|&
name|TULIP_PRINTMEDIA
condition|)
block|{
name|printf
argument_list|(
name|TULIP_PRINTF_FMT
literal|": %senabling %s port\n"
argument_list|,
name|TULIP_PRINTF_ARGS
argument_list|,
operator|(
name|sc
operator|->
name|tulip_flags
operator|&
name|TULIP_LINKUP
operator|)
condition|?
literal|""
else|:
literal|"link up: "
argument_list|,
name|tulip_mediums
index|[
name|sc
operator|->
name|tulip_media
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|sc
operator|->
name|tulip_flags
operator|&
name|TULIP_LINKUP
operator|)
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
name|TULIP_PRINTF_FMT
literal|": link up\n"
argument_list|,
name|TULIP_PRINTF_ARGS
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|tulip_flags
operator|&=
operator|~
operator|(
name|TULIP_PRINTMEDIA
operator||
name|TULIP_LINKSUSPECT
operator||
name|TULIP_RXACT
operator|)
expr_stmt|;
name|sc
operator|->
name|tulip_flags
operator||=
name|TULIP_LINKUP
expr_stmt|;
return|return;
block|}
comment|/*      * The link may be down.  Mark it as suspect.  If suspect for 12 ticks,      * mark it down.  If autonegotiation is not disabled, restart the media      * probe to see if the media has changed.      */
if|if
condition|(
operator|(
name|sc
operator|->
name|tulip_flags
operator|&
name|TULIP_LINKSUSPECT
operator|)
operator|==
literal|0
condition|)
block|{
name|sc
operator|->
name|tulip_flags
operator||=
name|TULIP_LINKSUSPECT
expr_stmt|;
name|sc
operator|->
name|tulip_flags
operator|&=
operator|~
name|TULIP_LINKUP
expr_stmt|;
name|sc
operator|->
name|tulip_gpticks
operator|=
literal|12
expr_stmt|;
ifdef|#
directive|ifdef
name|TULIP_DEBUG
name|sc
operator|->
name|tulip_dbg
operator|.
name|dbg_link_suspected
operator|++
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
if|if
condition|(
operator|--
name|sc
operator|->
name|tulip_gpticks
operator|>
literal|0
condition|)
return|return;
if|if
condition|(
name|sc
operator|->
name|tulip_flags
operator|&
name|TULIP_LINKSUSPECT
condition|)
block|{
name|printf
argument_list|(
name|TULIP_PRINTF_FMT
literal|": link down: cable problem?\n"
argument_list|,
name|TULIP_PRINTF_ARGS
argument_list|)
expr_stmt|;
name|sc
operator|->
name|tulip_flags
operator|&=
operator|~
name|TULIP_LINKSUSPECT
expr_stmt|;
ifdef|#
directive|ifdef
name|TULIP_DEBUG
name|sc
operator|->
name|tulip_dbg
operator|.
name|dbg_link_downed
operator|++
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|sc
operator|->
name|tulip_if
operator|.
name|if_flags
operator|&
name|IFF_NOAUTONEG
condition|)
return|return;
name|sc
operator|->
name|tulip_media
operator|=
name|TULIP_MEDIA_UNKNOWN
expr_stmt|;
name|sc
operator|->
name|tulip_probe_state
operator|=
name|TULIP_PROBE_INACTIVE
expr_stmt|;
name|tulip_21140_autonegotiate
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|void
name|tulip_21140_nomii_media_preset
parameter_list|(
name|tulip_softc_t
modifier|*
specifier|const
name|sc
parameter_list|)
block|{
name|sc
operator|->
name|tulip_flags
operator|&=
operator|~
name|TULIP_SQETEST
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|tulip_if
operator|.
name|if_flags
operator|&
name|IFF_ALTPHYS
condition|)
block|{
name|sc
operator|->
name|tulip_cmdmode
operator||=
name|TULIP_CMD_PORTSELECT
operator||
name|TULIP_CMD_PCSFUNCTION
operator||
name|TULIP_CMD_SCRAMBLER
expr_stmt|;
name|sc
operator|->
name|tulip_if
operator|.
name|if_baudrate
operator|=
literal|100000000
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|tulip_cmdmode
operator|&=
operator|~
operator|(
name|TULIP_CMD_PORTSELECT
operator||
name|TULIP_CMD_PCSFUNCTION
operator||
name|TULIP_CMD_SCRAMBLER
operator|)
expr_stmt|;
name|sc
operator|->
name|tulip_if
operator|.
name|if_baudrate
operator|=
literal|10000000
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|tulip_cmdmode
operator|&
name|TULIP_CMD_FULLDUPLEX
operator|)
operator|==
literal|0
condition|)
name|sc
operator|->
name|tulip_flags
operator||=
name|TULIP_SQETEST
expr_stmt|;
block|}
name|TULIP_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_command
argument_list|,
name|sc
operator|->
name|tulip_cmdmode
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|tulip_21140_mii_media_preset
parameter_list|(
name|tulip_softc_t
modifier|*
specifier|const
name|sc
parameter_list|)
block|{
name|sc
operator|->
name|tulip_cmdmode
operator||=
name|TULIP_CMD_PORTSELECT
expr_stmt|;
name|sc
operator|->
name|tulip_flags
operator|&=
operator|~
name|TULIP_SQETEST
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|tulip_media
operator|!=
name|TULIP_MEDIA_UNKNOWN
condition|)
block|{
switch|switch
condition|(
name|sc
operator|->
name|tulip_media
condition|)
block|{
case|case
name|TULIP_MEDIA_10BASET
case|:
block|{
name|sc
operator|->
name|tulip_cmdmode
operator|&=
operator|~
name|TULIP_CMD_FULLDUPLEX
expr_stmt|;
name|sc
operator|->
name|tulip_cmdmode
operator||=
name|TULIP_CMD_TXTHRSHLDCTL
expr_stmt|;
name|sc
operator|->
name|tulip_if
operator|.
name|if_baudrate
operator|=
literal|10000000
expr_stmt|;
name|sc
operator|->
name|tulip_flags
operator||=
name|TULIP_SQETEST
expr_stmt|;
break|break;
block|}
case|case
name|TULIP_MEDIA_10BASET_FD
case|:
block|{
name|sc
operator|->
name|tulip_cmdmode
operator||=
name|TULIP_CMD_FULLDUPLEX
operator||
name|TULIP_CMD_TXTHRSHLDCTL
expr_stmt|;
name|sc
operator|->
name|tulip_if
operator|.
name|if_baudrate
operator|=
literal|10000000
expr_stmt|;
break|break;
block|}
case|case
name|TULIP_MEDIA_100BASET4
case|:
case|case
name|TULIP_MEDIA_100BASETX
case|:
block|{
name|sc
operator|->
name|tulip_cmdmode
operator|&=
operator|~
operator|(
name|TULIP_CMD_FULLDUPLEX
operator||
name|TULIP_CMD_TXTHRSHLDCTL
operator|)
expr_stmt|;
name|sc
operator|->
name|tulip_if
operator|.
name|if_baudrate
operator|=
literal|100000000
expr_stmt|;
break|break;
block|}
case|case
name|TULIP_MEDIA_100BASETX_FD
case|:
block|{
name|sc
operator|->
name|tulip_cmdmode
operator||=
name|TULIP_CMD_FULLDUPLEX
expr_stmt|;
name|sc
operator|->
name|tulip_cmdmode
operator|&=
operator|~
name|TULIP_CMD_TXTHRSHLDCTL
expr_stmt|;
name|sc
operator|->
name|tulip_if
operator|.
name|if_baudrate
operator|=
literal|100000000
expr_stmt|;
break|break;
block|}
block|}
block|}
name|TULIP_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_command
argument_list|,
name|sc
operator|->
name|tulip_cmdmode
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|tulip_21140_nomii_100only_media_preset
parameter_list|(
name|tulip_softc_t
modifier|*
specifier|const
name|sc
parameter_list|)
block|{
name|sc
operator|->
name|tulip_cmdmode
operator||=
name|TULIP_CMD_PORTSELECT
operator||
name|TULIP_CMD_PCSFUNCTION
operator||
name|TULIP_CMD_SCRAMBLER
expr_stmt|;
name|TULIP_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_command
argument_list|,
name|sc
operator|->
name|tulip_cmdmode
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|int
name|tulip_21140_evalboard_media_probe
parameter_list|(
name|tulip_softc_t
modifier|*
specifier|const
name|sc
parameter_list|)
block|{
name|TULIP_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_gp
argument_list|,
name|TULIP_GP_EB_PINS
argument_list|)
expr_stmt|;
name|TULIP_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_gp
argument_list|,
name|TULIP_GP_EB_INIT
argument_list|)
expr_stmt|;
name|TULIP_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_command
argument_list|,
name|TULIP_CSR_READ
argument_list|(
name|sc
argument_list|,
name|csr_command
argument_list|)
operator||
name|TULIP_CMD_PORTSELECT
operator||
name|TULIP_CMD_PCSFUNCTION
operator||
name|TULIP_CMD_SCRAMBLER
operator||
name|TULIP_CMD_MUSTBEONE
argument_list|)
expr_stmt|;
name|TULIP_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_command
argument_list|,
name|TULIP_CSR_READ
argument_list|(
name|sc
argument_list|,
name|csr_command
argument_list|)
operator|&
operator|~
name|TULIP_CMD_TXTHRSHLDCTL
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1000000
argument_list|)
expr_stmt|;
return|return
operator|(
name|TULIP_CSR_READ
argument_list|(
name|sc
argument_list|,
name|csr_gp
argument_list|)
operator|&
name|TULIP_GP_EB_OK100
operator|)
operator|!=
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|tulip_21140_evalboard_media_select
parameter_list|(
name|tulip_softc_t
modifier|*
specifier|const
name|sc
parameter_list|)
block|{
name|sc
operator|->
name|tulip_cmdmode
operator||=
name|TULIP_CMD_STOREFWD
operator||
name|TULIP_CMD_MUSTBEONE
operator||
name|TULIP_CMD_BACKOFFCTR
expr_stmt|;
name|sc
operator|->
name|tulip_flags
operator||=
name|TULIP_LINKUP
expr_stmt|;
name|TULIP_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_gp
argument_list|,
name|TULIP_GP_EB_PINS
argument_list|)
expr_stmt|;
name|TULIP_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_gp
argument_list|,
name|TULIP_GP_EB_INIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|tulip_if
operator|.
name|if_flags
operator|&
name|IFF_ALTPHYS
condition|)
block|{
if|if
condition|(
operator|(
name|sc
operator|->
name|tulip_flags
operator|&
name|TULIP_ALTPHYS
operator|)
operator|==
literal|0
condition|)
name|sc
operator|->
name|tulip_flags
operator||=
name|TULIP_PRINTMEDIA
operator||
name|TULIP_ALTPHYS
expr_stmt|;
name|sc
operator|->
name|tulip_cmdmode
operator|&=
operator|~
name|TULIP_CMD_TXTHRSHLDCTL
expr_stmt|;
name|sc
operator|->
name|tulip_media
operator|=
name|TULIP_MEDIA_100BASETX
expr_stmt|;
name|sc
operator|->
name|tulip_flags
operator|&=
operator|~
name|TULIP_SQETEST
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|sc
operator|->
name|tulip_flags
operator|&
name|TULIP_ALTPHYS
condition|)
name|sc
operator|->
name|tulip_flags
operator|^=
name|TULIP_PRINTMEDIA
operator||
name|TULIP_ALTPHYS
expr_stmt|;
name|sc
operator|->
name|tulip_cmdmode
operator||=
name|TULIP_CMD_TXTHRSHLDCTL
expr_stmt|;
name|sc
operator|->
name|tulip_media
operator|=
name|TULIP_MEDIA_10BASET
expr_stmt|;
name|sc
operator|->
name|tulip_flags
operator||=
name|TULIP_SQETEST
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|BIG_PACKET
if|if
condition|(
name|sc
operator|->
name|tulip_if
operator|.
name|if_mtu
operator|>
name|ETHERMTU
condition|)
block|{
name|TULIP_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_watchdog
argument_list|,
name|TULIP_WATCHDOG_RXDISABLE
operator||
name|TULIP_WATCHDOG_TXDISABLE
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|tulip_boardsw_t
name|tulip_21140_eb_boardsw
init|=
block|{
name|TULIP_21140_DEC_EB
block|,
literal|""
block|,
name|tulip_21140_evalboard_media_probe
block|,
name|tulip_21140_evalboard_media_select
block|,
name|tulip_21140_nomii_media_preset
block|, }
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_function
specifier|static
name|int
name|tulip_21140_smc9332_media_probe
parameter_list|(
name|tulip_softc_t
modifier|*
specifier|const
name|sc
parameter_list|)
block|{
name|int
name|idx
decl_stmt|,
name|cnt
init|=
literal|0
decl_stmt|;
name|TULIP_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_command
argument_list|,
name|TULIP_CMD_PORTSELECT
operator||
name|TULIP_CMD_MUSTBEONE
argument_list|)
expr_stmt|;
name|TULIP_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_busmode
argument_list|,
name|TULIP_BUSMODE_SWRESET
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
comment|/* Wait 10 microseconds (actually 50 PCI cycles but at  		   33MHz that comes to two microseconds but wait a 		   bit longer anyways) */
name|TULIP_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_command
argument_list|,
name|TULIP_CMD_PORTSELECT
operator||
name|TULIP_CMD_PCSFUNCTION
operator||
name|TULIP_CMD_SCRAMBLER
operator||
name|TULIP_CMD_MUSTBEONE
argument_list|)
expr_stmt|;
name|TULIP_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_gp
argument_list|,
name|TULIP_GP_SMC_9332_PINS
argument_list|)
expr_stmt|;
name|TULIP_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_gp
argument_list|,
name|TULIP_GP_SMC_9332_INIT
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|200000
argument_list|)
expr_stmt|;
for|for
control|(
name|idx
operator|=
literal|1000
init|;
name|idx
operator|>
literal|0
condition|;
name|idx
operator|--
control|)
block|{
name|u_int32_t
name|csr
init|=
name|TULIP_CSR_READ
argument_list|(
name|sc
argument_list|,
name|csr_gp
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|csr
operator|&
operator|(
name|TULIP_GP_SMC_9332_OK10
operator||
name|TULIP_GP_SMC_9332_OK100
operator|)
operator|)
operator|==
operator|(
name|TULIP_GP_SMC_9332_OK10
operator||
name|TULIP_GP_SMC_9332_OK100
operator|)
condition|)
block|{
if|if
condition|(
operator|++
name|cnt
operator|>
literal|100
condition|)
break|break;
block|}
elseif|else
if|if
condition|(
operator|(
name|csr
operator|&
name|TULIP_GP_SMC_9332_OK10
operator|)
operator|==
literal|0
condition|)
block|{
break|break;
block|}
else|else
block|{
name|cnt
operator|=
literal|0
expr_stmt|;
block|}
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
block|}
return|return
name|cnt
operator|>
literal|100
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|tulip_21140_smc9332_media_select
parameter_list|(
name|tulip_softc_t
modifier|*
specifier|const
name|sc
parameter_list|)
block|{
name|sc
operator|->
name|tulip_cmdmode
operator||=
name|TULIP_CMD_STOREFWD
operator||
name|TULIP_CMD_MUSTBEONE
operator||
name|TULIP_CMD_BACKOFFCTR
expr_stmt|;
name|sc
operator|->
name|tulip_flags
operator||=
name|TULIP_LINKUP
expr_stmt|;
name|TULIP_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_gp
argument_list|,
name|TULIP_GP_SMC_9332_PINS
argument_list|)
expr_stmt|;
name|TULIP_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_gp
argument_list|,
name|TULIP_GP_SMC_9332_INIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|tulip_if
operator|.
name|if_flags
operator|&
name|IFF_ALTPHYS
condition|)
block|{
if|if
condition|(
operator|(
name|sc
operator|->
name|tulip_flags
operator|&
name|TULIP_ALTPHYS
operator|)
operator|==
literal|0
condition|)
name|sc
operator|->
name|tulip_flags
operator||=
name|TULIP_PRINTMEDIA
operator||
name|TULIP_ALTPHYS
expr_stmt|;
name|sc
operator|->
name|tulip_cmdmode
operator|&=
operator|~
name|TULIP_CMD_TXTHRSHLDCTL
expr_stmt|;
name|sc
operator|->
name|tulip_media
operator|=
name|TULIP_MEDIA_100BASETX
expr_stmt|;
name|sc
operator|->
name|tulip_flags
operator|&=
operator|~
name|TULIP_SQETEST
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|sc
operator|->
name|tulip_flags
operator|&
name|TULIP_ALTPHYS
condition|)
name|sc
operator|->
name|tulip_flags
operator|^=
name|TULIP_PRINTMEDIA
operator||
name|TULIP_ALTPHYS
expr_stmt|;
name|sc
operator|->
name|tulip_cmdmode
operator||=
name|TULIP_CMD_TXTHRSHLDCTL
expr_stmt|;
name|sc
operator|->
name|tulip_media
operator|=
name|TULIP_MEDIA_10BASET
expr_stmt|;
name|sc
operator|->
name|tulip_flags
operator||=
name|TULIP_SQETEST
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|BIG_PACKET
if|if
condition|(
name|sc
operator|->
name|tulip_if
operator|.
name|if_mtu
operator|>
name|ETHERMTU
condition|)
block|{
name|TULIP_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_watchdog
argument_list|,
name|TULIP_WATCHDOG_RXDISABLE
operator||
name|TULIP_WATCHDOG_TXDISABLE
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|tulip_boardsw_t
name|tulip_21140_smc9332_boardsw
init|=
block|{
name|TULIP_21140_SMC_9332
block|,
literal|"SMC 9332 "
block|,
name|tulip_21140_smc9332_media_probe
block|,
name|tulip_21140_smc9332_media_select
block|,
name|tulip_21140_nomii_media_preset
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|tulip_boardsw_t
name|tulip_21140A_smc9332bdt_boardsw
init|=
block|{
name|TULIP_21140A_SMC_9332BDT
block|,
literal|"SMC 9332BDT "
block|,
name|tulip_21140_smc9332_media_probe
block|,
name|tulip_21140_mii_media_preset
block|,
name|tulip_21140_mii_probe
block|, }
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_function
specifier|static
name|int
name|tulip_21140_cogent_em100_media_probe
parameter_list|(
name|tulip_softc_t
modifier|*
specifier|const
name|sc
parameter_list|)
block|{
name|TULIP_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_gp
argument_list|,
name|TULIP_GP_EM100_PINS
argument_list|)
expr_stmt|;
name|TULIP_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_gp
argument_list|,
name|TULIP_GP_EM100_INIT
argument_list|)
expr_stmt|;
name|TULIP_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_command
argument_list|,
name|TULIP_CSR_READ
argument_list|(
name|sc
argument_list|,
name|csr_command
argument_list|)
operator||
name|TULIP_CMD_PORTSELECT
operator||
name|TULIP_CMD_PCSFUNCTION
operator||
name|TULIP_CMD_SCRAMBLER
operator||
name|TULIP_CMD_MUSTBEONE
argument_list|)
expr_stmt|;
name|TULIP_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_command
argument_list|,
name|TULIP_CSR_READ
argument_list|(
name|sc
argument_list|,
name|csr_command
argument_list|)
operator|&
operator|~
name|TULIP_CMD_TXTHRSHLDCTL
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|tulip_21140_cogent_em100_media_select
parameter_list|(
name|tulip_softc_t
modifier|*
specifier|const
name|sc
parameter_list|)
block|{
name|sc
operator|->
name|tulip_cmdmode
operator||=
name|TULIP_CMD_STOREFWD
operator||
name|TULIP_CMD_MUSTBEONE
operator||
name|TULIP_CMD_BACKOFFCTR
expr_stmt|;
name|sc
operator|->
name|tulip_flags
operator||=
name|TULIP_LINKUP
expr_stmt|;
name|TULIP_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_gp
argument_list|,
name|TULIP_GP_EM100_PINS
argument_list|)
expr_stmt|;
name|TULIP_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_gp
argument_list|,
name|TULIP_GP_EM100_INIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|tulip_flags
operator|&
name|TULIP_ALTPHYS
operator|)
operator|==
literal|0
condition|)
name|sc
operator|->
name|tulip_flags
operator||=
name|TULIP_PRINTMEDIA
operator||
name|TULIP_ALTPHYS
expr_stmt|;
name|sc
operator|->
name|tulip_cmdmode
operator|&=
operator|~
name|TULIP_CMD_TXTHRSHLDCTL
expr_stmt|;
name|sc
operator|->
name|tulip_media
operator|=
name|TULIP_MEDIA_100BASETX
expr_stmt|;
ifdef|#
directive|ifdef
name|BIG_PACKET
if|if
condition|(
name|sc
operator|->
name|tulip_if
operator|.
name|if_mtu
operator|>
name|ETHERMTU
condition|)
block|{
name|TULIP_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_watchdog
argument_list|,
name|TULIP_WATCHDOG_RXDISABLE
operator||
name|TULIP_WATCHDOG_TXDISABLE
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|tulip_boardsw_t
name|tulip_21140_cogent_em100_boardsw
init|=
block|{
name|TULIP_21140_COGENT_EM100
block|,
literal|"Cogent EM100 "
block|,
name|tulip_21140_cogent_em100_media_probe
block|,
name|tulip_21140_cogent_em100_media_select
block|,
name|tulip_21140_nomii_100only_media_preset
block|}
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_function
specifier|static
name|int
name|tulip_21140_znyx_zx34x_media_probe
parameter_list|(
name|tulip_softc_t
modifier|*
specifier|const
name|sc
parameter_list|)
block|{
name|TULIP_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_gp
argument_list|,
name|TULIP_GP_ZX34X_PINS
argument_list|)
expr_stmt|;
name|TULIP_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_gp
argument_list|,
name|TULIP_GP_ZX34X_INIT
argument_list|)
expr_stmt|;
name|TULIP_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_command
argument_list|,
name|TULIP_CSR_READ
argument_list|(
name|sc
argument_list|,
name|csr_command
argument_list|)
operator||
name|TULIP_CMD_PORTSELECT
operator||
name|TULIP_CMD_PCSFUNCTION
operator||
name|TULIP_CMD_SCRAMBLER
operator||
name|TULIP_CMD_MUSTBEONE
argument_list|)
expr_stmt|;
name|TULIP_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_command
argument_list|,
name|TULIP_CSR_READ
argument_list|(
name|sc
argument_list|,
name|csr_command
argument_list|)
operator|&
operator|~
name|TULIP_CMD_TXTHRSHLDCTL
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1000000
argument_list|)
expr_stmt|;
return|return
operator|(
name|TULIP_CSR_READ
argument_list|(
name|sc
argument_list|,
name|csr_gp
argument_list|)
operator|&
name|TULIP_GP_ZX34X_OK10
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|tulip_21140_znyx_zx34x_media_select
parameter_list|(
name|tulip_softc_t
modifier|*
specifier|const
name|sc
parameter_list|)
block|{
name|sc
operator|->
name|tulip_cmdmode
operator||=
name|TULIP_CMD_STOREFWD
operator||
name|TULIP_CMD_MUSTBEONE
operator||
name|TULIP_CMD_BACKOFFCTR
expr_stmt|;
name|sc
operator|->
name|tulip_flags
operator||=
name|TULIP_LINKUP
expr_stmt|;
name|TULIP_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_gp
argument_list|,
name|TULIP_GP_ZX34X_PINS
argument_list|)
expr_stmt|;
name|TULIP_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_gp
argument_list|,
name|TULIP_GP_ZX34X_INIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|tulip_if
operator|.
name|if_flags
operator|&
name|IFF_ALTPHYS
condition|)
block|{
if|if
condition|(
operator|(
name|sc
operator|->
name|tulip_flags
operator|&
name|TULIP_ALTPHYS
operator|)
operator|==
literal|0
condition|)
name|sc
operator|->
name|tulip_flags
operator||=
name|TULIP_PRINTMEDIA
operator||
name|TULIP_ALTPHYS
expr_stmt|;
name|sc
operator|->
name|tulip_cmdmode
operator|&=
operator|~
name|TULIP_CMD_TXTHRSHLDCTL
expr_stmt|;
name|sc
operator|->
name|tulip_media
operator|=
name|TULIP_MEDIA_100BASETX
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|sc
operator|->
name|tulip_flags
operator|&
name|TULIP_ALTPHYS
condition|)
name|sc
operator|->
name|tulip_flags
operator|^=
name|TULIP_PRINTMEDIA
operator||
name|TULIP_ALTPHYS
expr_stmt|;
name|sc
operator|->
name|tulip_cmdmode
operator||=
name|TULIP_CMD_TXTHRSHLDCTL
expr_stmt|;
name|sc
operator|->
name|tulip_media
operator|=
name|TULIP_MEDIA_10BASET
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|BIG_PACKET
if|if
condition|(
name|sc
operator|->
name|tulip_if
operator|.
name|if_mtu
operator|>
name|ETHERMTU
condition|)
block|{
name|TULIP_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_watchdog
argument_list|,
name|TULIP_WATCHDOG_RXDISABLE
operator||
name|TULIP_WATCHDOG_TXDISABLE
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|tulip_boardsw_t
name|tulip_21140_znyx_zx34x_boardsw
init|=
block|{
name|TULIP_21140_ZNYX_ZX34X
block|,
literal|"ZNYX ZX34X "
block|,
name|tulip_21140_znyx_zx34x_media_probe
block|,
name|tulip_21140_znyx_zx34x_media_select
block|,
name|tulip_21140_nomii_media_preset
block|, }
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_struct
specifier|static
specifier|const
struct|struct
block|{
name|unsigned
name|short
name|value_gp
decl_stmt|;
name|unsigned
name|short
name|value_phyctl
decl_stmt|;
block|}
name|tulip_21140_de500_csrvalues
index|[]
init|=
block|{
block|{
name|TULIP_GP_DE500_HALFDUPLEX
block|,
literal|0
block|}
block|,
comment|/* TULIP_MEDIA_UNKNOWN */
block|{
name|TULIP_GP_DE500_HALFDUPLEX
block|,
literal|0
block|}
block|,
comment|/* TULIP_MEDIA_10BASET */
block|{
comment|/* n/a */
block|}
block|,
comment|/* TULIP_MEDIA_BNC */
block|{
comment|/* n/a */
block|}
block|,
comment|/* TULIP_MEDIA_AUI */
block|{
comment|/* n/a */
block|}
block|,
comment|/* TULIP_MEDIA_BNCAUI */
block|{
literal|0
block|,
name|PHYCTL_FULL_DUPLEX
block|}
block|,
comment|/* TULIP_MEDIA_10BASET_FD */
block|{
name|TULIP_GP_DE500_HALFDUPLEX
operator||
comment|/* TULIP_MEDIA_100BASET */
name|TULIP_GP_DE500_FORCE_100
block|,
name|PHYCTL_SELECT_100MB
block|}
block|,
block|{
name|TULIP_GP_DE500_FORCE_100
block|,
comment|/* TULIP_MEDIA_100BASET_FD */
name|PHYCTL_SELECT_100MB
operator||
name|PHYCTL_FULL_DUPLEX
block|}
block|,
block|{
name|TULIP_GP_DE500_HALFDUPLEX
operator||
comment|/* TULIP_MEDIA_100BASET4 */
name|TULIP_GP_DE500_FORCE_100
block|,
name|PHYCTL_SELECT_100MB
block|}
block|, }
struct|;
end_struct

begin_escape
end_escape

begin_function
specifier|static
name|void
name|tulip_21140_de500_media_select
parameter_list|(
name|tulip_softc_t
modifier|*
specifier|const
name|sc
parameter_list|)
block|{
if|if
condition|(
name|sc
operator|->
name|tulip_if
operator|.
name|if_flags
operator|&
name|IFF_ALTPHYS
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|tulip_if
operator|.
name|if_flags
operator|&
name|IFF_FULLDUPLEX
condition|)
block|{
name|sc
operator|->
name|tulip_media
operator|=
name|TULIP_MEDIA_100BASETX_FD
expr_stmt|;
name|sc
operator|->
name|tulip_cmdmode
operator||=
name|TULIP_CMD_FULLDUPLEX
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|tulip_media
operator|=
name|TULIP_MEDIA_100BASETX
expr_stmt|;
name|sc
operator|->
name|tulip_cmdmode
operator|&=
operator|~
name|TULIP_CMD_FULLDUPLEX
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|sc
operator|->
name|tulip_flags
operator|&
name|TULIP_ALTPHYS
operator|)
operator|==
literal|0
condition|)
name|sc
operator|->
name|tulip_flags
operator||=
name|TULIP_PRINTMEDIA
operator||
name|TULIP_ALTPHYS
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|sc
operator|->
name|tulip_if
operator|.
name|if_flags
operator|&
name|IFF_FULLDUPLEX
condition|)
block|{
name|sc
operator|->
name|tulip_media
operator|=
name|TULIP_MEDIA_10BASET_FD
expr_stmt|;
name|sc
operator|->
name|tulip_cmdmode
operator||=
name|TULIP_CMD_FULLDUPLEX
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|tulip_media
operator|=
name|TULIP_MEDIA_10BASET
expr_stmt|;
name|sc
operator|->
name|tulip_cmdmode
operator|&=
operator|~
name|TULIP_CMD_FULLDUPLEX
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|tulip_flags
operator|&
name|TULIP_ALTPHYS
condition|)
name|sc
operator|->
name|tulip_flags
operator|^=
name|TULIP_PRINTMEDIA
operator||
name|TULIP_ALTPHYS
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|tulip_21140_de500xa_media_probe
parameter_list|(
name|tulip_softc_t
modifier|*
specifier|const
name|sc
parameter_list|)
block|{
name|int
name|idx
decl_stmt|;
name|TULIP_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_gp
argument_list|,
name|TULIP_GP_DE500_PINS
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|500
argument_list|)
expr_stmt|;
name|TULIP_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_gp
argument_list|,
name|TULIP_GP_DE500_HALFDUPLEX
operator||
name|TULIP_GP_DE500_FORCE_100
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
name|TULIP_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_command
argument_list|,
name|TULIP_CSR_READ
argument_list|(
name|sc
argument_list|,
name|csr_command
argument_list|)
operator||
name|TULIP_CMD_PORTSELECT
operator||
name|TULIP_CMD_PCSFUNCTION
operator||
name|TULIP_CMD_SCRAMBLER
operator||
name|TULIP_CMD_MUSTBEONE
argument_list|)
expr_stmt|;
name|TULIP_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_command
argument_list|,
name|TULIP_CSR_READ
argument_list|(
name|sc
argument_list|,
name|csr_command
argument_list|)
operator|&
operator|~
name|TULIP_CMD_TXTHRSHLDCTL
argument_list|)
expr_stmt|;
for|for
control|(
name|idx
operator|=
literal|2400
init|;
name|idx
operator|>
literal|0
condition|;
name|idx
operator|--
control|)
block|{
name|u_int32_t
name|data
decl_stmt|;
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
name|data
operator|=
operator|~
name|TULIP_CSR_READ
argument_list|(
name|sc
argument_list|,
name|csr_gp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|data
operator|&
operator|(
name|TULIP_GP_DE500_LINK_PASS
operator||
name|TULIP_GP_DE500_SYM_LINK
operator|)
operator|)
operator|==
operator|(
name|TULIP_GP_DE500_SYM_LINK
operator||
name|TULIP_GP_DE500_LINK_PASS
operator|)
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|tulip_21140_de500xa_media_select
parameter_list|(
name|tulip_softc_t
modifier|*
specifier|const
name|sc
parameter_list|)
block|{
name|sc
operator|->
name|tulip_cmdmode
operator||=
name|TULIP_CMD_STOREFWD
operator||
name|TULIP_CMD_MUSTBEONE
operator||
name|TULIP_CMD_BACKOFFCTR
expr_stmt|;
name|sc
operator|->
name|tulip_flags
operator||=
name|TULIP_LINKUP
expr_stmt|;
name|TULIP_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_gp
argument_list|,
name|TULIP_GP_DE500_PINS
argument_list|)
expr_stmt|;
name|tulip_21140_de500_media_select
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|TULIP_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_gp
argument_list|,
name|tulip_21140_de500_csrvalues
index|[
name|sc
operator|->
name|tulip_media
index|]
operator|.
name|value_gp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|BIG_PACKET
if|if
condition|(
name|sc
operator|->
name|tulip_if
operator|.
name|if_mtu
operator|>
name|ETHERMTU
condition|)
block|{
name|TULIP_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_watchdog
argument_list|,
name|TULIP_WATCHDOG_RXDISABLE
operator||
name|TULIP_WATCHDOG_TXDISABLE
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|tulip_boardsw_t
name|tulip_21140_de500xa_boardsw
init|=
block|{
name|TULIP_21140_DEC_DE500
block|,
literal|"Digital DE500-XA "
block|,
name|tulip_21140_de500xa_media_probe
block|,
name|tulip_21140_de500xa_media_select
block|,
name|tulip_21140_nomii_media_preset
block|, }
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_function
specifier|static
name|int
name|tulip_21140_de500aa_media_probe
parameter_list|(
name|tulip_softc_t
modifier|*
specifier|const
name|sc
parameter_list|)
block|{
name|TULIP_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_gp
argument_list|,
name|TULIP_GP_DE500_PINS
argument_list|)
expr_stmt|;
name|TULIP_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_gp
argument_list|,
name|TULIP_GP_DE500_PHY_RESET
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
name|TULIP_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_gp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TULIP_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_command
argument_list|,
name|TULIP_CMD_PORTSELECT
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|tulip_21140_de500aa_media_select
parameter_list|(
name|tulip_softc_t
modifier|*
specifier|const
name|sc
parameter_list|)
block|{
specifier|const
name|tulip_phy_t
modifier|*
name|phy
init|=
name|sc
operator|->
name|tulip_phys
decl_stmt|;
name|u_int32_t
name|data
decl_stmt|;
if|if
condition|(
name|phy
operator|==
name|NULL
condition|)
return|return;
comment|/*      * Defer autosensing until out of device probe (will be      * triggered by ifwatchdog or ifioctl).      */
if|if
condition|(
name|sc
operator|->
name|tulip_media
operator|==
name|TULIP_MEDIA_UNKNOWN
condition|)
block|{
name|tulip_media_t
name|old_media
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|tulip_probe_state
operator|!=
name|TULIP_PROBE_MEDIATEST
condition|)
name|tulip_21140_autonegotiate
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|tulip_probe_state
operator|!=
name|TULIP_PROBE_MEDIATEST
condition|)
return|return;
name|old_media
operator|=
name|sc
operator|->
name|tulip_media
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|tulip_if
operator|.
name|if_flags
operator|&
name|IFF_NOAUTONEG
condition|)
block|{
name|tulip_21140_de500_media_select
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|tulip_media
operator|=
name|tulip_21140_phy_readspecific
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|tulip_media
operator|==
name|TULIP_MEDIA_UNKNOWN
condition|)
block|{
name|sc
operator|->
name|tulip_probe_state
operator|=
name|TULIP_PROBE_INACTIVE
expr_stmt|;
name|tulip_21140_autonegotiate
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|)
expr_stmt|;
return|return;
block|}
name|sc
operator|->
name|tulip_flags
operator||=
name|TULIP_PRINTMEDIA
expr_stmt|;
block|}
name|sc
operator|->
name|tulip_probe_state
operator|=
name|TULIP_PROBE_INACTIVE
expr_stmt|;
name|sc
operator|->
name|tulip_flags
operator|&=
operator|~
name|TULIP_TXPROBE_ACTIVE
expr_stmt|;
name|sc
operator|->
name|tulip_intrmask
operator|&=
operator|~
name|TULIP_STS_GPTIMEOUT
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|tulip_flags
operator|&
name|TULIP_INRESET
condition|)
goto|goto
name|in_reset
goto|;
if|if
condition|(
name|sc
operator|->
name|tulip_media
operator|!=
name|old_media
condition|)
name|sc
operator|->
name|tulip_flags
operator||=
name|TULIP_NEEDRESET
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|sc
operator|->
name|tulip_flags
operator|&
name|TULIP_INRESET
operator|)
operator|==
literal|0
condition|)
block|{
name|tulip_21140_mii_link_monitor
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|)
expr_stmt|;
return|return;
block|}
name|in_reset
label|:
if|if
condition|(
name|sc
operator|->
name|tulip_if
operator|.
name|if_flags
operator|&
name|IFF_ALTPHYS
condition|)
block|{
name|sc
operator|->
name|tulip_flags
operator||=
name|TULIP_ALTPHYS
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|tulip_flags
operator|&=
operator|~
name|TULIP_ALTPHYS
expr_stmt|;
block|}
name|sc
operator|->
name|tulip_gpticks
operator|=
literal|8
expr_stmt|;
name|sc
operator|->
name|tulip_intrmask
operator||=
name|TULIP_STS_ABNRMLINTR
operator||
name|TULIP_STS_GPTIMEOUT
operator||
name|TULIP_STS_NORMALINTR
expr_stmt|;
name|tulip_21140_gp_timer_set
argument_list|(
name|sc
argument_list|,
literal|425
argument_list|)
expr_stmt|;
name|data
operator|=
name|tulip_mii_readreg
argument_list|(
name|sc
argument_list|,
name|phy
operator|->
name|phy_devaddr
argument_list|,
name|PHYREG_CONTROL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|data
operator|&
name|PHYCTL_AUTONEG_ENABLE
operator|)
operator|==
literal|0
condition|)
block|{
name|data
operator|&=
operator|~
operator|(
name|PHYCTL_SELECT_100MB
operator||
name|PHYCTL_FULL_DUPLEX
operator|)
expr_stmt|;
name|data
operator||=
name|tulip_21140_de500_csrvalues
index|[
name|sc
operator|->
name|tulip_media
index|]
operator|.
name|value_phyctl
expr_stmt|;
name|tulip_mii_writereg
argument_list|(
name|sc
argument_list|,
name|phy
operator|->
name|phy_devaddr
argument_list|,
name|PHYREG_CONTROL
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|tulip_boardsw_t
name|tulip_21140_de500aa_boardsw
init|=
block|{
name|TULIP_21140_DEC_DE500
block|,
literal|"Digital DE500-AA "
block|,
name|tulip_21140_de500aa_media_probe
block|,
name|tulip_21140_de500aa_media_select
block|,
name|tulip_21140_mii_media_preset
block|,
name|tulip_21140_mii_probe
block|, }
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_function
specifier|static
name|int
name|tulip_21041_media_probe
parameter_list|(
name|tulip_softc_t
modifier|*
specifier|const
name|sc
parameter_list|)
block|{
name|sc
operator|->
name|tulip_if
operator|.
name|if_baudrate
operator|=
literal|10000000
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|BIG_PACKET
end_ifdef

begin_define
define|#
directive|define
name|TULIP_21041_SIAGEN_WATCHDOG
value|(sc->tulip_if.if_mtu> ETHERMTU ? TULIP_WATCHDOG_RXDISABLE|TULIP_WATCHDOG_TXDISABLE : 0)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|TULIP_21041_SIAGEN_WATCHDOG
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|tulip_21041_media_select
parameter_list|(
name|tulip_softc_t
modifier|*
specifier|const
name|sc
parameter_list|)
block|{
name|sc
operator|->
name|tulip_cmdmode
operator||=
name|TULIP_CMD_CAPTREFFCT
operator||
name|TULIP_CMD_ENHCAPTEFFCT
operator||
name|TULIP_CMD_THRSHLD160
operator||
name|TULIP_CMD_BACKOFFCTR
expr_stmt|;
name|sc
operator|->
name|tulip_intrmask
operator||=
name|TULIP_STS_NORMALINTR
operator||
name|TULIP_STS_GPTIMEOUT
operator||
name|TULIP_STS_TXINTR
operator||
name|TULIP_STS_ABNRMLINTR
operator||
name|TULIP_STS_LINKPASS
operator||
name|TULIP_STS_LINKFAIL
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|tulip_if
operator|.
name|if_flags
operator|&
name|IFF_ALTPHYS
condition|)
block|{
if|if
condition|(
operator|(
name|sc
operator|->
name|tulip_flags
operator|&
name|TULIP_ALTPHYS
operator|)
operator|==
literal|0
condition|)
block|{
name|sc
operator|->
name|tulip_media
operator|=
name|TULIP_MEDIA_UNKNOWN
expr_stmt|;
name|sc
operator|->
name|tulip_flags
operator|&=
operator|~
operator|(
name|TULIP_TXPROBE_OK
operator||
name|TULIP_TXPROBE_ACTIVE
operator|)
expr_stmt|;
name|sc
operator|->
name|tulip_flags
operator||=
name|TULIP_ALTPHYS
operator||
name|TULIP_WANTRXACT
expr_stmt|;
name|sc
operator|->
name|tulip_probe_state
operator|=
name|TULIP_PROBE_INACTIVE
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|sc
operator|->
name|tulip_flags
operator|&
name|TULIP_ALTPHYS
condition|)
block|{
name|sc
operator|->
name|tulip_media
operator|=
name|TULIP_MEDIA_UNKNOWN
expr_stmt|;
name|sc
operator|->
name|tulip_flags
operator|&=
operator|~
operator|(
name|TULIP_TXPROBE_OK
operator||
name|TULIP_TXPROBE_ACTIVE
operator||
name|TULIP_ALTPHYS
operator|)
expr_stmt|;
name|sc
operator|->
name|tulip_flags
operator||=
name|TULIP_WANTRXACT
expr_stmt|;
name|sc
operator|->
name|tulip_probe_state
operator|=
name|TULIP_PROBE_INACTIVE
expr_stmt|;
block|}
block|}
if|if
condition|(
name|TULIP_CSR_READ
argument_list|(
name|sc
argument_list|,
name|csr_sia_status
argument_list|)
operator|&
name|TULIP_SIASTS_LINKFAIL
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|tulip_media
operator|==
name|TULIP_MEDIA_BNC
condition|)
block|{
name|sc
operator|->
name|tulip_intrmask
operator|&=
operator|~
name|TULIP_STS_GPTIMEOUT
expr_stmt|;
name|TULIP_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_sia_connectivity
argument_list|,
name|TULIP_SIACONN_RESET
argument_list|)
expr_stmt|;
name|TULIP_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_sia_connectivity
argument_list|,
name|TULIP_21041_SIACONN_BNC
argument_list|)
expr_stmt|;
name|TULIP_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_sia_tx_rx
argument_list|,
name|TULIP_21041_SIATXRX_BNC
argument_list|)
expr_stmt|;
name|TULIP_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_sia_general
argument_list|,
name|TULIP_21041_SIAGEN_BNC
operator||
name|TULIP_21041_SIAGEN_WATCHDOG
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|sc
operator|->
name|tulip_media
operator|==
name|TULIP_MEDIA_AUI
condition|)
block|{
name|sc
operator|->
name|tulip_intrmask
operator|&=
operator|~
name|TULIP_STS_GPTIMEOUT
expr_stmt|;
name|TULIP_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_sia_connectivity
argument_list|,
name|TULIP_SIACONN_RESET
argument_list|)
expr_stmt|;
name|TULIP_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_sia_connectivity
argument_list|,
name|TULIP_21041_SIACONN_AUI
argument_list|)
expr_stmt|;
name|TULIP_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_sia_tx_rx
argument_list|,
name|TULIP_21041_SIATXRX_AUI
argument_list|)
expr_stmt|;
name|TULIP_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_sia_general
argument_list|,
name|TULIP_21041_SIAGEN_AUI
operator||
name|TULIP_21041_SIAGEN_WATCHDOG
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * If we've been reset, the SIA is reset.  Restart the probe. 	 */
if|if
condition|(
name|sc
operator|->
name|tulip_probe_state
operator|==
name|TULIP_PROBE_10BASET
operator|&&
operator|(
name|sc
operator|->
name|tulip_flags
operator|&
name|TULIP_INRESET
operator|)
condition|)
name|sc
operator|->
name|tulip_probe_state
operator|=
name|TULIP_PROBE_INACTIVE
expr_stmt|;
comment|/* 	 * Reset OACTIVE in case were being called from tulip_reset. 	 */
name|sc
operator|->
name|tulip_if
operator|.
name|if_flags
operator||=
name|IFF_OACTIVE
expr_stmt|;
switch|switch
condition|(
name|sc
operator|->
name|tulip_probe_state
condition|)
block|{
case|case
name|TULIP_PROBE_INACTIVE
case|:
block|{
name|sc
operator|->
name|tulip_gpticks
operator|=
literal|200
expr_stmt|;
name|sc
operator|->
name|tulip_probe_state
operator|=
name|TULIP_PROBE_10BASET
expr_stmt|;
name|TULIP_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_command
argument_list|,
name|sc
operator|->
name|tulip_cmdmode
argument_list|)
expr_stmt|;
name|TULIP_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_sia_connectivity
argument_list|,
name|TULIP_SIACONN_RESET
argument_list|)
expr_stmt|;
name|TULIP_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_sia_connectivity
argument_list|,
name|TULIP_21041_SIACONN_10BASET
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|tulip_cmdmode
operator|&
name|TULIP_CMD_FULLDUPLEX
condition|)
name|TULIP_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_sia_tx_rx
argument_list|,
name|TULIP_21041_SIATXRX_10BASET_FD
argument_list|)
expr_stmt|;
else|else
name|TULIP_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_sia_tx_rx
argument_list|,
name|TULIP_21041_SIATXRX_10BASET
argument_list|)
expr_stmt|;
name|TULIP_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_sia_general
argument_list|,
name|TULIP_21041_SIAGEN_10BASET
operator||
name|TULIP_21041_SIAGEN_WATCHDOG
argument_list|)
expr_stmt|;
name|TULIP_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_gp_timer
argument_list|,
literal|12000000
operator|/
literal|204800
argument_list|)
expr_stmt|;
comment|/* 120 ms */
name|TULIP_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_status
argument_list|,
name|TULIP_STS_GPTIMEOUT
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|TULIP_PROBE_10BASET
case|:
block|{
if|if
condition|(
operator|--
name|sc
operator|->
name|tulip_gpticks
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|TULIP_CSR_READ
argument_list|(
name|sc
argument_list|,
name|csr_sia_status
argument_list|)
operator|&
name|TULIP_SIASTS_OTHERRXACTIVITY
operator|)
operator|==
literal|0
condition|)
block|{
name|TULIP_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_gp_timer
argument_list|,
literal|12000000
operator|/
literal|204800
argument_list|)
expr_stmt|;
comment|/* 120 ms */
break|break;
block|}
block|}
name|sc
operator|->
name|tulip_gpticks
operator|=
literal|4
expr_stmt|;
if|if
condition|(
name|TULIP_CSR_READ
argument_list|(
name|sc
argument_list|,
name|csr_sia_status
argument_list|)
operator|&
name|TULIP_SIASTS_OTHERRXACTIVITY
condition|)
block|{
name|sc
operator|->
name|tulip_probe_state
operator|=
name|TULIP_PROBE_BNC
expr_stmt|;
name|TULIP_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_sia_connectivity
argument_list|,
name|TULIP_SIACONN_RESET
argument_list|)
expr_stmt|;
name|TULIP_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_sia_connectivity
argument_list|,
name|TULIP_21041_SIACONN_BNC
argument_list|)
expr_stmt|;
name|TULIP_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_sia_tx_rx
argument_list|,
name|TULIP_21041_SIATXRX_BNC
argument_list|)
expr_stmt|;
name|TULIP_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_sia_general
argument_list|,
name|TULIP_21041_SIAGEN_BNC
operator||
name|TULIP_21041_SIAGEN_WATCHDOG
argument_list|)
expr_stmt|;
name|TULIP_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_sia_status
argument_list|,
name|TULIP_SIASTS_OTHERRXACTIVITY
argument_list|)
expr_stmt|;
name|TULIP_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_gp_timer
argument_list|,
literal|100000000
operator|/
literal|204800
argument_list|)
expr_stmt|;
comment|/* 100 ms */
block|}
else|else
block|{
name|sc
operator|->
name|tulip_probe_state
operator|=
name|TULIP_PROBE_AUI
expr_stmt|;
name|TULIP_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_sia_connectivity
argument_list|,
name|TULIP_SIACONN_RESET
argument_list|)
expr_stmt|;
name|TULIP_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_sia_connectivity
argument_list|,
name|TULIP_21041_SIACONN_AUI
argument_list|)
expr_stmt|;
name|TULIP_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_sia_tx_rx
argument_list|,
name|TULIP_21041_SIATXRX_AUI
argument_list|)
expr_stmt|;
name|TULIP_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_sia_general
argument_list|,
name|TULIP_21041_SIAGEN_AUI
operator||
name|TULIP_21041_SIAGEN_WATCHDOG
argument_list|)
expr_stmt|;
name|TULIP_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_gp_timer
argument_list|,
literal|100000000
operator|/
literal|204800
argument_list|)
expr_stmt|;
comment|/* 100 ms */
block|}
break|break;
block|}
case|case
name|TULIP_PROBE_BNC
case|:
case|case
name|TULIP_PROBE_AUI
case|:
block|{
if|if
condition|(
name|sc
operator|->
name|tulip_flags
operator|&
name|TULIP_TXPROBE_OK
condition|)
block|{
name|sc
operator|->
name|tulip_intrmask
operator|&=
operator|~
name|TULIP_STS_GPTIMEOUT
expr_stmt|;
name|sc
operator|->
name|tulip_flags
operator|&=
operator|~
operator|(
name|TULIP_TXPROBE_OK
operator||
name|TULIP_TXPROBE_ACTIVE
operator|)
expr_stmt|;
name|sc
operator|->
name|tulip_flags
operator||=
name|TULIP_LINKUP
expr_stmt|;
name|TULIP_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_gp_timer
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* disable */
if|if
condition|(
name|sc
operator|->
name|tulip_probe_state
operator|==
name|TULIP_PROBE_AUI
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|tulip_media
operator|!=
name|TULIP_MEDIA_AUI
condition|)
block|{
name|sc
operator|->
name|tulip_media
operator|=
name|TULIP_MEDIA_AUI
expr_stmt|;
name|sc
operator|->
name|tulip_flags
operator||=
name|TULIP_PRINTMEDIA
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|sc
operator|->
name|tulip_probe_state
operator|==
name|TULIP_PROBE_BNC
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|tulip_media
operator|!=
name|TULIP_MEDIA_BNC
condition|)
block|{
name|sc
operator|->
name|tulip_media
operator|=
name|TULIP_MEDIA_BNC
expr_stmt|;
name|sc
operator|->
name|tulip_flags
operator||=
name|TULIP_PRINTMEDIA
expr_stmt|;
block|}
block|}
name|TULIP_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_command
argument_list|,
name|sc
operator|->
name|tulip_cmdmode
argument_list|)
expr_stmt|;
name|sc
operator|->
name|tulip_probe_state
operator|=
name|TULIP_PROBE_INACTIVE
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|sc
operator|->
name|tulip_flags
operator|&
name|TULIP_WANTRXACT
operator|)
operator|==
literal|0
operator|||
operator|(
name|TULIP_CSR_READ
argument_list|(
name|sc
argument_list|,
name|csr_sia_status
argument_list|)
operator|&
name|TULIP_SIASTS_RXACTIVITY
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|sc
operator|->
name|tulip_flags
operator|&
name|TULIP_TXPROBE_ACTIVE
operator|)
operator|==
literal|0
condition|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
comment|/* 			 * Before we are sure this is the right media we need 			 * to send a small packet to make sure there's carrier. 			 * Strangely, BNC and AUI will 'see" receive data if 			 * either is connected so the transmit is the only way 			 * to verify the connectivity. 			 */
name|MGETHDR
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|TULIP_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_gp_timer
argument_list|,
literal|100000000
operator|/
literal|204800
argument_list|)
expr_stmt|;
comment|/* 100 ms */
break|break;
block|}
comment|/* 			 * Construct a LLC TEST message which will point to ourselves. 			 */
name|bcopy
argument_list|(
name|sc
operator|->
name|tulip_hwaddr
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ether_header
operator|*
argument_list|)
operator|->
name|ether_dhost
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|sc
operator|->
name|tulip_hwaddr
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ether_header
operator|*
argument_list|)
operator|->
name|ether_shost
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ether_header
operator|*
argument_list|)
operator|->
name|ether_type
operator|=
name|htons
argument_list|(
literal|3
argument_list|)
expr_stmt|;
name|mtod
argument_list|(
argument|m
argument_list|,
argument|unsigned char *
argument_list|)
index|[
literal|14
index|]
operator|=
literal|0
expr_stmt|;
name|mtod
argument_list|(
argument|m
argument_list|,
argument|unsigned char *
argument_list|)
index|[
literal|15
index|]
operator|=
literal|0
expr_stmt|;
name|mtod
argument_list|(
argument|m
argument_list|,
argument|unsigned char *
argument_list|)
index|[
literal|16
index|]
operator|=
literal|0xE3
expr_stmt|;
comment|/* LLC Class1 TEST (no poll) */
name|m
operator|->
name|m_len
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
operator|+
literal|3
expr_stmt|;
comment|/* 			 * send it! 			 */
name|sc
operator|->
name|tulip_flags
operator||=
name|TULIP_TXPROBE_ACTIVE
expr_stmt|;
name|sc
operator|->
name|tulip_flags
operator|&=
operator|~
name|TULIP_TXPROBE_OK
expr_stmt|;
name|sc
operator|->
name|tulip_cmdmode
operator||=
name|TULIP_CMD_TXRUN
expr_stmt|;
name|TULIP_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_command
argument_list|,
name|sc
operator|->
name|tulip_cmdmode
argument_list|)
expr_stmt|;
name|IF_PREPEND
argument_list|(
operator|&
name|sc
operator|->
name|tulip_if
operator|.
name|if_snd
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|tulip_ifstart
argument_list|(
operator|&
name|sc
operator|->
name|tulip_if
argument_list|)
expr_stmt|;
break|break;
block|}
name|sc
operator|->
name|tulip_flags
operator|&=
operator|~
name|TULIP_TXPROBE_ACTIVE
expr_stmt|;
block|}
comment|/* 		 * Take 2 passes through before deciding to not 		 * wait for receive activity.  Then take another 		 * two passes before spitting out a warning. 		 */
if|if
condition|(
name|sc
operator|->
name|tulip_gpticks
operator|>
literal|0
operator|&&
operator|--
name|sc
operator|->
name|tulip_gpticks
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|tulip_flags
operator|&
name|TULIP_WANTRXACT
condition|)
block|{
name|sc
operator|->
name|tulip_flags
operator|&=
operator|~
name|TULIP_WANTRXACT
expr_stmt|;
name|sc
operator|->
name|tulip_gpticks
operator|=
literal|4
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
name|TULIP_PRINTF_FMT
literal|": autosense failed: cable problem?\n"
argument_list|,
name|TULIP_PRINTF_ARGS
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 		 * Since this media failed to probe, try the other one. 		 */
if|if
condition|(
name|sc
operator|->
name|tulip_probe_state
operator|==
name|TULIP_PROBE_AUI
condition|)
block|{
name|sc
operator|->
name|tulip_probe_state
operator|=
name|TULIP_PROBE_BNC
expr_stmt|;
name|TULIP_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_sia_connectivity
argument_list|,
name|TULIP_SIACONN_RESET
argument_list|)
expr_stmt|;
name|TULIP_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_sia_connectivity
argument_list|,
name|TULIP_21041_SIACONN_BNC
argument_list|)
expr_stmt|;
name|TULIP_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_sia_tx_rx
argument_list|,
name|TULIP_21041_SIATXRX_BNC
argument_list|)
expr_stmt|;
name|TULIP_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_sia_general
argument_list|,
name|TULIP_21041_SIAGEN_BNC
operator||
name|TULIP_21041_SIAGEN_WATCHDOG
argument_list|)
expr_stmt|;
name|TULIP_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_gp_timer
argument_list|,
literal|100000000
operator|/
literal|204800
argument_list|)
expr_stmt|;
comment|/* 100 ms */
block|}
else|else
block|{
name|sc
operator|->
name|tulip_probe_state
operator|=
name|TULIP_PROBE_AUI
expr_stmt|;
name|TULIP_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_sia_connectivity
argument_list|,
name|TULIP_SIACONN_RESET
argument_list|)
expr_stmt|;
name|TULIP_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_sia_connectivity
argument_list|,
name|TULIP_21041_SIACONN_AUI
argument_list|)
expr_stmt|;
name|TULIP_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_sia_tx_rx
argument_list|,
name|TULIP_21041_SIATXRX_AUI
argument_list|)
expr_stmt|;
name|TULIP_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_sia_general
argument_list|,
name|TULIP_21041_SIAGEN_AUI
operator||
name|TULIP_21041_SIAGEN_WATCHDOG
argument_list|)
expr_stmt|;
name|TULIP_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_gp_timer
argument_list|,
literal|100000000
operator|/
literal|204800
argument_list|)
expr_stmt|;
comment|/* 100 ms */
block|}
break|break;
block|}
block|}
block|}
else|else
block|{
comment|/* 	 * If the link has passed LinkPass, 10baseT is the 	 * proper media to use. 	 */
if|if
condition|(
name|sc
operator|->
name|tulip_if
operator|.
name|if_flags
operator|&
name|IFF_FULLDUPLEX
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|tulip_media
operator|!=
name|TULIP_MEDIA_10BASET_FD
condition|)
block|{
name|sc
operator|->
name|tulip_media
operator|=
name|TULIP_MEDIA_10BASET_FD
expr_stmt|;
name|sc
operator|->
name|tulip_flags
operator||=
name|TULIP_PRINTMEDIA
expr_stmt|;
name|sc
operator|->
name|tulip_cmdmode
operator||=
name|TULIP_CMD_FULLDUPLEX
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|sc
operator|->
name|tulip_media
operator|!=
name|TULIP_MEDIA_10BASET
condition|)
block|{
name|sc
operator|->
name|tulip_media
operator|=
name|TULIP_MEDIA_10BASET
expr_stmt|;
name|sc
operator|->
name|tulip_flags
operator||=
name|TULIP_PRINTMEDIA
expr_stmt|;
name|sc
operator|->
name|tulip_cmdmode
operator|&=
operator|~
name|TULIP_CMD_FULLDUPLEX
expr_stmt|;
block|}
block|}
if|if
condition|(
name|sc
operator|->
name|tulip_flags
operator|&
operator|(
name|TULIP_INRESET
operator||
name|TULIP_PRINTMEDIA
operator|)
condition|)
block|{
name|TULIP_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_sia_connectivity
argument_list|,
name|TULIP_SIACONN_RESET
argument_list|)
expr_stmt|;
name|TULIP_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_sia_connectivity
argument_list|,
name|TULIP_21041_SIACONN_10BASET
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|tulip_cmdmode
operator|&
name|TULIP_CMD_FULLDUPLEX
condition|)
name|TULIP_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_sia_tx_rx
argument_list|,
name|TULIP_21041_SIATXRX_10BASET_FD
argument_list|)
expr_stmt|;
else|else
name|TULIP_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_sia_tx_rx
argument_list|,
name|TULIP_21041_SIATXRX_10BASET
argument_list|)
expr_stmt|;
name|TULIP_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_sia_general
argument_list|,
name|TULIP_21041_SIAGEN_10BASET
operator||
name|TULIP_21041_SIAGEN_WATCHDOG
argument_list|)
expr_stmt|;
block|}
name|TULIP_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_gp_timer
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* disable */
name|sc
operator|->
name|tulip_gpticks
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|tulip_probe_state
operator|=
name|TULIP_PROBE_INACTIVE
expr_stmt|;
name|sc
operator|->
name|tulip_intrmask
operator|&=
operator|~
name|TULIP_STS_GPTIMEOUT
expr_stmt|;
name|sc
operator|->
name|tulip_flags
operator||=
name|TULIP_LINKUP
expr_stmt|;
name|sc
operator|->
name|tulip_flags
operator|&=
operator|~
operator|(
name|TULIP_TXPROBE_OK
operator||
name|TULIP_TXPROBE_ACTIVE
operator|)
expr_stmt|;
name|sc
operator|->
name|tulip_if
operator|.
name|if_flags
operator|&=
operator|~
name|IFF_OACTIVE
expr_stmt|;
name|TULIP_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_command
argument_list|,
name|sc
operator|->
name|tulip_cmdmode
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|tulip_flags
operator|&
name|TULIP_DEVICEPROBE
condition|)
block|{
name|sc
operator|->
name|tulip_flags
operator||=
name|TULIP_FAKEGPTIMEOUT
expr_stmt|;
block|}
else|else
block|{
name|TULIP_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_intr
argument_list|,
name|sc
operator|->
name|tulip_intrmask
argument_list|)
expr_stmt|;
name|sc
operator|->
name|tulip_flags
operator|&=
operator|~
name|TULIP_FAKEGPTIMEOUT
expr_stmt|;
block|}
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|tulip_boardsw_t
name|tulip_21041_boardsw
init|=
block|{
name|TULIP_21041_GENERIC
block|,
literal|""
block|,
name|tulip_21041_media_probe
block|,
name|tulip_21041_media_select
block|}
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_function
specifier|static
name|void
name|tulip_reset
parameter_list|(
name|tulip_softc_t
modifier|*
specifier|const
name|sc
parameter_list|)
block|{
name|tulip_ringinfo_t
modifier|*
name|ri
decl_stmt|;
name|tulip_desc_t
modifier|*
name|di
decl_stmt|;
comment|/*      * Brilliant.  Simply brilliant.  When switching modes/speeds      * on a 2114*, you need to set the appriopriate MII/PCS/SCL/PS      * bits in CSR6 and then do a software reset to get the 21140      * to properly reset its internal pathways to the right places.      *   Grrrr.      */
if|if
condition|(
name|sc
operator|->
name|tulip_boardsw
operator|->
name|bd_media_preset
operator|!=
name|NULL
condition|)
call|(
modifier|*
name|sc
operator|->
name|tulip_boardsw
operator|->
name|bd_media_preset
call|)
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|TULIP_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_busmode
argument_list|,
name|TULIP_BUSMODE_SWRESET
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
comment|/* Wait 10 microseconds (actually 50 PCI cycles but at  		   33MHz that comes to two microseconds but wait a 		   bit longer anyways) */
name|sc
operator|->
name|tulip_flags
operator||=
name|TULIP_INRESET
expr_stmt|;
name|sc
operator|->
name|tulip_flags
operator|&=
operator|~
operator|(
name|TULIP_NEEDRESET
operator||
name|TULIP_RXBUFSLOW
operator|)
expr_stmt|;
name|sc
operator|->
name|tulip_intrmask
operator|=
literal|0
expr_stmt|;
name|TULIP_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_intr
argument_list|,
name|sc
operator|->
name|tulip_intrmask
argument_list|)
expr_stmt|;
name|TULIP_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_txlist
argument_list|,
name|TULIP_KVATOPHYS
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|tulip_txinfo
operator|.
name|ri_first
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|TULIP_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_rxlist
argument_list|,
name|TULIP_KVATOPHYS
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|tulip_rxinfo
operator|.
name|ri_first
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|TULIP_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_busmode
argument_list|,
operator|(
literal|1
operator|<<
operator|(
name|TULIP_BURSTSIZE
argument_list|(
name|sc
operator|->
name|tulip_unit
argument_list|)
operator|+
literal|8
operator|)
operator|)
operator||
name|TULIP_BUSMODE_CACHE_ALIGN8
operator||
operator|(
name|BYTE_ORDER
operator|!=
name|LITTLE_ENDIAN
condition|?
name|TULIP_BUSMODE_BIGENDIAN
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|tulip_txtimer
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|tulip_txq
operator|.
name|ifq_maxlen
operator|=
name|TULIP_TXDESCS
expr_stmt|;
name|sc
operator|->
name|tulip_if
operator|.
name|if_flags
operator|&=
operator|~
name|IFF_OACTIVE
expr_stmt|;
comment|/*      * Free all the mbufs that were on the transmit ring.      */
for|for
control|(
init|;
condition|;
control|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|IF_DEQUEUE
argument_list|(
operator|&
name|sc
operator|->
name|tulip_txq
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
break|break;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
name|ri
operator|=
operator|&
name|sc
operator|->
name|tulip_txinfo
expr_stmt|;
name|ri
operator|->
name|ri_nextin
operator|=
name|ri
operator|->
name|ri_nextout
operator|=
name|ri
operator|->
name|ri_first
expr_stmt|;
name|ri
operator|->
name|ri_free
operator|=
name|ri
operator|->
name|ri_max
expr_stmt|;
for|for
control|(
name|di
operator|=
name|ri
operator|->
name|ri_first
init|;
name|di
operator|<
name|ri
operator|->
name|ri_last
condition|;
name|di
operator|++
control|)
name|di
operator|->
name|d_status
operator|=
literal|0
expr_stmt|;
comment|/*      * We need to collect all the mbufs were on the       * receive ring before we reinit it either to put      * them back on or to know if we have to allocate      * more.      */
name|ri
operator|=
operator|&
name|sc
operator|->
name|tulip_rxinfo
expr_stmt|;
name|ri
operator|->
name|ri_nextin
operator|=
name|ri
operator|->
name|ri_nextout
operator|=
name|ri
operator|->
name|ri_first
expr_stmt|;
name|ri
operator|->
name|ri_free
operator|=
name|ri
operator|->
name|ri_max
expr_stmt|;
for|for
control|(
name|di
operator|=
name|ri
operator|->
name|ri_first
init|;
name|di
operator|<
name|ri
operator|->
name|ri_last
condition|;
name|di
operator|++
control|)
block|{
name|di
operator|->
name|d_status
operator|=
literal|0
expr_stmt|;
name|di
operator|->
name|d_length1
operator|=
literal|0
expr_stmt|;
name|di
operator|->
name|d_addr1
operator|=
literal|0
expr_stmt|;
name|di
operator|->
name|d_length2
operator|=
literal|0
expr_stmt|;
name|di
operator|->
name|d_addr2
operator|=
literal|0
expr_stmt|;
block|}
for|for
control|(
init|;
condition|;
control|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|IF_DEQUEUE
argument_list|(
operator|&
name|sc
operator|->
name|tulip_rxq
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
break|break;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
call|(
modifier|*
name|sc
operator|->
name|tulip_boardsw
operator|->
name|bd_media_select
call|)
argument_list|(
name|sc
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TULIP_DEBUG
if|if
condition|(
operator|(
name|sc
operator|->
name|tulip_flags
operator|&
operator|(
name|TULIP_DEVICEPROBE
operator||
name|TULIP_NEEDRESET
operator|)
operator|)
operator|==
name|TULIP_NEEDRESET
condition|)
name|printf
argument_list|(
name|TULIP_PRINTF_FMT
literal|": tulip_reset: additional reset needed?!?\n"
argument_list|,
name|TULIP_PRINTF_ARGS
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|sc
operator|->
name|tulip_flags
operator|&
operator|(
name|TULIP_LINKUP
operator||
name|TULIP_PRINTMEDIA
operator|)
operator|)
operator|==
operator|(
name|TULIP_LINKUP
operator||
name|TULIP_PRINTMEDIA
operator|)
condition|)
block|{
name|printf
argument_list|(
name|TULIP_PRINTF_FMT
literal|": enabling %s port\n"
argument_list|,
name|TULIP_PRINTF_ARGS
argument_list|,
name|tulip_mediums
index|[
name|sc
operator|->
name|tulip_media
index|]
argument_list|)
expr_stmt|;
name|sc
operator|->
name|tulip_flags
operator|&=
operator|~
name|TULIP_PRINTMEDIA
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|tulip_chipid
operator|==
name|TULIP_21041
condition|)
name|TULIP_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_sia_status
argument_list|,
name|TULIP_CSR_READ
argument_list|(
name|sc
argument_list|,
name|csr_sia_status
argument_list|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|tulip_intrmask
operator||=
name|TULIP_STS_NORMALINTR
operator||
name|TULIP_STS_RXINTR
operator||
name|TULIP_STS_TXINTR
operator||
name|TULIP_STS_ABNRMLINTR
operator||
name|TULIP_STS_SYSERROR
operator||
name|TULIP_STS_TXSTOPPED
operator||
name|TULIP_STS_TXBABBLE
operator||
name|TULIP_STS_LINKFAIL
operator||
name|TULIP_STS_RXSTOPPED
expr_stmt|;
name|sc
operator|->
name|tulip_flags
operator|&=
operator|~
operator|(
name|TULIP_DOINGSETUP
operator||
name|TULIP_WANTSETUP
operator||
name|TULIP_INRESET
operator||
name|TULIP_RXACT
operator|)
expr_stmt|;
name|tulip_addr_filter
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|void
name|tulip_init
parameter_list|(
name|tulip_softc_t
modifier|*
specifier|const
name|sc
parameter_list|)
block|{
if|if
condition|(
name|sc
operator|->
name|tulip_if
operator|.
name|if_flags
operator|&
name|IFF_UP
condition|)
block|{
if|if
condition|(
operator|(
name|sc
operator|->
name|tulip_if
operator|.
name|if_flags
operator|&
name|IFF_RUNNING
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* initialize the media */
name|tulip_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|tulip_if
operator|.
name|if_flags
operator||=
name|IFF_RUNNING
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|tulip_if
operator|.
name|if_flags
operator|&
name|IFF_PROMISC
condition|)
block|{
name|sc
operator|->
name|tulip_cmdmode
operator||=
name|TULIP_CMD_PROMISCUOUS
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|tulip_cmdmode
operator|&=
operator|~
name|TULIP_CMD_PROMISCUOUS
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|tulip_if
operator|.
name|if_flags
operator|&
name|IFF_ALLMULTI
condition|)
block|{
name|sc
operator|->
name|tulip_cmdmode
operator||=
name|TULIP_CMD_ALLMULTI
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|tulip_cmdmode
operator|&=
operator|~
name|TULIP_CMD_ALLMULTI
expr_stmt|;
block|}
block|}
name|sc
operator|->
name|tulip_cmdmode
operator||=
name|TULIP_CMD_TXRUN
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|tulip_flags
operator|&
name|TULIP_WANTSETUP
operator|)
operator|==
literal|0
condition|)
block|{
name|tulip_rx_intr
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|tulip_cmdmode
operator||=
name|TULIP_CMD_RXRUN
expr_stmt|;
name|sc
operator|->
name|tulip_intrmask
operator||=
name|TULIP_STS_RXSTOPPED
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|tulip_intrmask
operator|&=
operator|~
name|TULIP_STS_RXSTOPPED
expr_stmt|;
name|tulip_ifstart
argument_list|(
operator|&
name|sc
operator|->
name|tulip_if
argument_list|)
expr_stmt|;
block|}
name|TULIP_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_intr
argument_list|,
name|sc
operator|->
name|tulip_intrmask
argument_list|)
expr_stmt|;
name|TULIP_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_command
argument_list|,
name|sc
operator|->
name|tulip_cmdmode
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|tulip_if
operator|.
name|if_flags
operator|&=
operator|~
name|IFF_RUNNING
expr_stmt|;
name|tulip_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|void
name|tulip_rx_intr
parameter_list|(
name|tulip_softc_t
modifier|*
specifier|const
name|sc
parameter_list|)
block|{
name|tulip_ringinfo_t
modifier|*
specifier|const
name|ri
init|=
operator|&
name|sc
operator|->
name|tulip_rxinfo
decl_stmt|;
name|struct
name|ifnet
modifier|*
specifier|const
name|ifp
init|=
operator|&
name|sc
operator|->
name|tulip_if
decl_stmt|;
name|int
name|fillok
init|=
literal|1
decl_stmt|;
ifdef|#
directive|ifdef
name|TULIP_DEBUG
name|int
name|cnt
init|=
literal|0
decl_stmt|;
endif|#
directive|endif
for|for
control|(
init|;
condition|;
control|)
block|{
name|struct
name|ether_header
name|eh
decl_stmt|;
name|tulip_desc_t
modifier|*
name|eop
init|=
name|ri
operator|->
name|ri_nextin
decl_stmt|;
name|int
name|total_len
init|=
literal|0
decl_stmt|,
name|last_offset
init|=
literal|0
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|ms
init|=
name|NULL
decl_stmt|,
modifier|*
name|me
init|=
name|NULL
decl_stmt|;
name|int
name|accept
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|fillok
operator|&&
name|sc
operator|->
name|tulip_rxq
operator|.
name|ifq_len
operator|<
name|TULIP_RXQ_TARGET
condition|)
goto|goto
name|queue_mbuf
goto|;
ifdef|#
directive|ifdef
name|TULIP_DEBUG
if|if
condition|(
name|cnt
operator|==
name|ri
operator|->
name|ri_max
condition|)
break|break;
endif|#
directive|endif
comment|/* 	 * If the TULIP has no descriptors, there can't be any receive 	 * descriptors to process.  	 */
if|if
condition|(
name|eop
operator|==
name|ri
operator|->
name|ri_nextout
condition|)
break|break;
comment|/* 	 * 90% of the packets will fit in one descriptor.  So we optimize 	 * for that case. 	 */
if|if
condition|(
operator|(
operator|(
operator|(
specifier|volatile
name|tulip_desc_t
operator|*
operator|)
name|eop
operator|)
operator|->
name|d_status
operator|&
operator|(
name|TULIP_DSTS_OWNER
operator||
name|TULIP_DSTS_RxFIRSTDESC
operator||
name|TULIP_DSTS_RxLASTDESC
operator|)
operator|)
operator|==
operator|(
name|TULIP_DSTS_RxFIRSTDESC
operator||
name|TULIP_DSTS_RxLASTDESC
operator|)
condition|)
block|{
name|IF_DEQUEUE
argument_list|(
operator|&
name|sc
operator|->
name|tulip_rxq
argument_list|,
name|ms
argument_list|)
expr_stmt|;
name|me
operator|=
name|ms
expr_stmt|;
block|}
else|else
block|{
comment|/* 	     * If still owned by the TULIP, don't touch it. 	     */
if|if
condition|(
operator|(
operator|(
specifier|volatile
name|tulip_desc_t
operator|*
operator|)
name|eop
operator|)
operator|->
name|d_status
operator|&
name|TULIP_DSTS_OWNER
condition|)
break|break;
comment|/* 	     * It is possible (though improbable unless the BIG_PACKET support 	     * is enabled or MCLBYTES< 1518) for a received packet to cross 	     * more than one receive descriptor.   	     */
while|while
condition|(
operator|(
operator|(
operator|(
specifier|volatile
name|tulip_desc_t
operator|*
operator|)
name|eop
operator|)
operator|->
name|d_status
operator|&
name|TULIP_DSTS_RxLASTDESC
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|++
name|eop
operator|==
name|ri
operator|->
name|ri_last
condition|)
name|eop
operator|=
name|ri
operator|->
name|ri_first
expr_stmt|;
if|if
condition|(
name|eop
operator|==
name|ri
operator|->
name|ri_nextout
operator|||
operator|(
operator|(
operator|(
operator|(
specifier|volatile
name|tulip_desc_t
operator|*
operator|)
name|eop
operator|)
operator|->
name|d_status
operator|&
name|TULIP_DSTS_OWNER
operator|)
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|TULIP_DEBUG
name|sc
operator|->
name|tulip_dbg
operator|.
name|dbg_rxintrs
operator|++
expr_stmt|;
name|sc
operator|->
name|tulip_dbg
operator|.
name|dbg_rxpktsperintr
index|[
name|cnt
index|]
operator|++
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
name|total_len
operator|++
expr_stmt|;
block|}
comment|/* 	     * Dequeue the first buffer for the start of the packet.  Hopefully 	     * this will be the only one we need to dequeue.  However, if the 	     * packet consumed multiple descriptors, then we need to dequeue 	     * those buffers and chain to the starting mbuf.  All buffers but 	     * the last buffer have the same length so we can set that now. 	     * (we add to last_offset instead of multiplying since we normally 	     * won't go into the loop and thereby saving a ourselves from 	     * doing a multiplication by 0 in the normal case). 	     */
name|IF_DEQUEUE
argument_list|(
operator|&
name|sc
operator|->
name|tulip_rxq
argument_list|,
name|ms
argument_list|)
expr_stmt|;
for|for
control|(
name|me
operator|=
name|ms
init|;
name|total_len
operator|>
literal|0
condition|;
name|total_len
operator|--
control|)
block|{
name|me
operator|->
name|m_len
operator|=
name|TULIP_RX_BUFLEN
expr_stmt|;
name|last_offset
operator|+=
name|TULIP_RX_BUFLEN
expr_stmt|;
name|IF_DEQUEUE
argument_list|(
operator|&
name|sc
operator|->
name|tulip_rxq
argument_list|,
name|me
operator|->
name|m_next
argument_list|)
expr_stmt|;
name|me
operator|=
name|me
operator|->
name|m_next
expr_stmt|;
block|}
block|}
comment|/* 	 *  Now get the size of received packet (minus the CRC). 	 */
name|total_len
operator|=
operator|(
operator|(
name|eop
operator|->
name|d_status
operator|>>
literal|16
operator|)
operator|&
literal|0x7FFF
operator|)
operator|-
literal|4
expr_stmt|;
if|if
condition|(
operator|(
name|eop
operator|->
name|d_status
operator|&
name|TULIP_DSTS_ERRSUM
operator|)
operator|==
literal|0
ifdef|#
directive|ifdef
name|BIG_PACKET
operator|||
operator|(
name|total_len
operator|<=
name|sc
operator|->
name|tulip_if
operator|.
name|if_mtu
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
operator|&&
operator|(
name|eop
operator|->
name|d_status
operator|&
operator|(
name|TULIP_DSTS_RxBADLENGTH
operator||
name|TULIP_DSTS_RxRUNT
operator||
name|TULIP_DSTS_RxCOLLSEEN
operator||
name|TULIP_DSTS_RxBADCRC
operator||
name|TULIP_DSTS_RxOVERFLOW
operator|)
operator|)
operator|==
literal|0
operator|)
endif|#
directive|endif
condition|)
block|{
name|me
operator|->
name|m_len
operator|=
name|total_len
operator|-
name|last_offset
expr_stmt|;
name|eh
operator|=
operator|*
name|mtod
argument_list|(
name|ms
argument_list|,
expr|struct
name|ether_header
operator|*
argument_list|)
expr_stmt|;
if|#
directive|if
name|NBPFILTER
operator|>
literal|0
if|if
condition|(
name|sc
operator|->
name|tulip_bpf
operator|!=
name|NULL
condition|)
if|if
condition|(
name|me
operator|==
name|ms
condition|)
name|TULIP_BPF_TAP
argument_list|(
name|sc
argument_list|,
name|mtod
argument_list|(
name|ms
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
name|total_len
argument_list|)
expr_stmt|;
else|else
name|TULIP_BPF_MTAP
argument_list|(
name|sc
argument_list|,
name|ms
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|sc
operator|->
name|tulip_if
operator|.
name|if_flags
operator|&
name|IFF_PROMISC
operator|)
operator|&&
operator|(
name|eh
operator|.
name|ether_dhost
index|[
literal|0
index|]
operator|&
literal|1
operator|)
operator|==
literal|0
operator|&&
operator|!
name|TULIP_ADDREQUAL
argument_list|(
name|eh
operator|.
name|ether_dhost
argument_list|,
name|sc
operator|->
name|tulip_ac
operator|.
name|ac_enaddr
argument_list|)
condition|)
goto|goto
name|next
goto|;
name|accept
operator|=
literal|1
expr_stmt|;
name|sc
operator|->
name|tulip_flags
operator||=
name|TULIP_RXACT
expr_stmt|;
name|total_len
operator|-=
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
if|if
condition|(
name|eop
operator|->
name|d_status
operator|&
operator|(
name|TULIP_DSTS_RxBADLENGTH
operator||
name|TULIP_DSTS_RxOVERFLOW
operator||
name|TULIP_DSTS_RxWATCHDOG
operator|)
condition|)
block|{
name|sc
operator|->
name|tulip_dot3stats
operator|.
name|dot3StatsInternalMacReceiveErrors
operator|++
expr_stmt|;
block|}
else|else
block|{
specifier|const
name|char
modifier|*
name|error
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|eop
operator|->
name|d_status
operator|&
name|TULIP_DSTS_RxTOOLONG
condition|)
block|{
name|sc
operator|->
name|tulip_dot3stats
operator|.
name|dot3StatsFrameTooLongs
operator|++
expr_stmt|;
name|error
operator|=
literal|"frame too long"
expr_stmt|;
block|}
if|if
condition|(
name|eop
operator|->
name|d_status
operator|&
name|TULIP_DSTS_RxBADCRC
condition|)
block|{
if|if
condition|(
name|eop
operator|->
name|d_status
operator|&
name|TULIP_DSTS_RxDRBBLBIT
condition|)
block|{
name|sc
operator|->
name|tulip_dot3stats
operator|.
name|dot3StatsAlignmentErrors
operator|++
expr_stmt|;
name|error
operator|=
literal|"alignment error"
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|tulip_dot3stats
operator|.
name|dot3StatsFCSErrors
operator|++
expr_stmt|;
name|error
operator|=
literal|"bad crc"
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
name|error
operator|!=
name|NULL
operator|&&
operator|(
name|sc
operator|->
name|tulip_flags
operator|&
name|TULIP_NOMESSAGES
operator|)
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
name|TULIP_PRINTF_FMT
literal|": receive: "
name|TULIP_EADDR_FMT
literal|": %s\n"
argument_list|,
name|TULIP_PRINTF_ARGS
argument_list|,
name|TULIP_EADDR_ARGS
argument_list|(
name|mtod
argument_list|(
name|ms
argument_list|,
name|u_char
operator|*
argument_list|)
operator|+
literal|6
argument_list|)
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|sc
operator|->
name|tulip_flags
operator||=
name|TULIP_NOMESSAGES
expr_stmt|;
block|}
endif|#
directive|endif
block|}
block|}
name|next
label|:
ifdef|#
directive|ifdef
name|TULIP_DEBUG
name|cnt
operator|++
expr_stmt|;
endif|#
directive|endif
name|ifp
operator|->
name|if_ipackets
operator|++
expr_stmt|;
if|if
condition|(
operator|++
name|eop
operator|==
name|ri
operator|->
name|ri_last
condition|)
name|eop
operator|=
name|ri
operator|->
name|ri_first
expr_stmt|;
name|ri
operator|->
name|ri_nextin
operator|=
name|eop
expr_stmt|;
name|queue_mbuf
label|:
comment|/* 	 * Either we are priming the TULIP with mbufs (m == NULL) 	 * or we are about to accept an mbuf for the upper layers 	 * so we need to allocate an mbuf to replace it.  If we 	 * can't replace it, send up it anyways.  This may cause 	 * us to drop packets in the future but that's better than 	 * being caught in livelock. 	 * 	 * Note that if this packet crossed multiple descriptors 	 * we don't even try to reallocate all the mbufs here. 	 * Instead we rely on the test of the beginning of 	 * the loop to refill for the extra consumed mbufs. 	 */
if|if
condition|(
name|accept
operator|||
name|ms
operator|==
name|NULL
condition|)
block|{
name|struct
name|mbuf
modifier|*
name|m0
decl_stmt|;
name|MGETHDR
argument_list|(
name|m0
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m0
operator|!=
name|NULL
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|TULIP_COPY_RXDATA
argument_list|)
if|if
condition|(
operator|!
name|accept
operator|||
name|total_len
operator|>=
name|MHLEN
condition|)
block|{
endif|#
directive|endif
name|MCLGET
argument_list|(
name|m0
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|m0
operator|->
name|m_flags
operator|&
name|M_EXT
operator|)
operator|==
literal|0
condition|)
block|{
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
name|m0
operator|=
name|NULL
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|TULIP_COPY_RXDATA
argument_list|)
block|}
endif|#
directive|endif
block|}
if|if
condition|(
name|accept
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|__bsdi__
argument_list|)
name|eh
operator|.
name|ether_type
operator|=
name|ntohs
argument_list|(
name|eh
operator|.
name|ether_type
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
operator|!
name|defined
argument_list|(
name|TULIP_COPY_RXDATA
argument_list|)
name|ms
operator|->
name|m_data
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
expr_stmt|;
name|ms
operator|->
name|m_len
operator|-=
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
expr_stmt|;
name|ms
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|total_len
expr_stmt|;
name|ms
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|ifp
expr_stmt|;
name|ether_input
argument_list|(
name|ifp
argument_list|,
operator|&
name|eh
argument_list|,
name|ms
argument_list|)
expr_stmt|;
else|#
directive|else
ifdef|#
directive|ifdef
name|BIG_PACKET
error|#
directive|error
error|BIG_PACKET is incompatible with TULIP_COPY_RXDATA
endif|#
directive|endif
if|if
condition|(
name|ms
operator|==
name|me
condition|)
name|bcopy
argument_list|(
name|mtod
argument_list|(
name|ms
argument_list|,
name|caddr_t
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
argument_list|,
name|mtod
argument_list|(
name|m0
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
name|total_len
argument_list|)
expr_stmt|;
else|else
name|m_copydata
argument_list|(
name|ms
argument_list|,
literal|0
argument_list|,
name|total_len
argument_list|,
name|mtod
argument_list|(
name|m0
argument_list|,
name|caddr_t
argument_list|)
argument_list|)
expr_stmt|;
name|m0
operator|->
name|m_len
operator|=
name|m0
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|total_len
expr_stmt|;
name|m0
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|ifp
expr_stmt|;
name|ether_input
argument_list|(
name|ifp
argument_list|,
operator|&
name|eh
argument_list|,
name|m0
argument_list|)
expr_stmt|;
name|m0
operator|=
name|ms
expr_stmt|;
endif|#
directive|endif
block|}
name|ms
operator|=
name|m0
expr_stmt|;
block|}
if|if
condition|(
name|ms
operator|==
name|NULL
condition|)
block|{
comment|/* 	     * Couldn't allocate a new buffer.  Don't bother  	     * trying to replenish the receive queue. 	     */
name|fillok
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|tulip_flags
operator||=
name|TULIP_RXBUFSLOW
expr_stmt|;
ifdef|#
directive|ifdef
name|TULIP_DEBUG
name|sc
operator|->
name|tulip_dbg
operator|.
name|dbg_rxlowbufs
operator|++
expr_stmt|;
endif|#
directive|endif
continue|continue;
block|}
comment|/* 	 * Now give the buffer(s) to the TULIP and save in our 	 * receive queue. 	 */
do|do
block|{
name|ri
operator|->
name|ri_nextout
operator|->
name|d_length1
operator|=
name|TULIP_RX_BUFLEN
expr_stmt|;
name|ri
operator|->
name|ri_nextout
operator|->
name|d_addr1
operator|=
name|TULIP_KVATOPHYS
argument_list|(
name|sc
argument_list|,
name|mtod
argument_list|(
name|ms
argument_list|,
name|caddr_t
argument_list|)
argument_list|)
expr_stmt|;
name|ri
operator|->
name|ri_nextout
operator|->
name|d_status
operator|=
name|TULIP_DSTS_OWNER
expr_stmt|;
if|if
condition|(
operator|++
name|ri
operator|->
name|ri_nextout
operator|==
name|ri
operator|->
name|ri_last
condition|)
name|ri
operator|->
name|ri_nextout
operator|=
name|ri
operator|->
name|ri_first
expr_stmt|;
name|me
operator|=
name|ms
operator|->
name|m_next
expr_stmt|;
name|ms
operator|->
name|m_next
operator|=
name|NULL
expr_stmt|;
name|IF_ENQUEUE
argument_list|(
operator|&
name|sc
operator|->
name|tulip_rxq
argument_list|,
name|ms
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|ms
operator|=
name|me
operator|)
operator|!=
name|NULL
condition|)
do|;
if|if
condition|(
name|sc
operator|->
name|tulip_rxq
operator|.
name|ifq_len
operator|>=
name|TULIP_RXQ_TARGET
condition|)
name|sc
operator|->
name|tulip_flags
operator|&=
operator|~
name|TULIP_RXBUFSLOW
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|TULIP_DEBUG
name|sc
operator|->
name|tulip_dbg
operator|.
name|dbg_rxintrs
operator|++
expr_stmt|;
name|sc
operator|->
name|tulip_dbg
operator|.
name|dbg_rxpktsperintr
index|[
name|cnt
index|]
operator|++
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|int
name|tulip_tx_intr
parameter_list|(
name|tulip_softc_t
modifier|*
specifier|const
name|sc
parameter_list|)
block|{
name|tulip_ringinfo_t
modifier|*
specifier|const
name|ri
init|=
operator|&
name|sc
operator|->
name|tulip_txinfo
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|xmits
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|ri
operator|->
name|ri_free
operator|<
name|ri
operator|->
name|ri_max
condition|)
block|{
if|if
condition|(
operator|(
operator|(
specifier|volatile
name|tulip_desc_t
operator|*
operator|)
name|ri
operator|->
name|ri_nextin
operator|)
operator|->
name|d_status
operator|&
name|TULIP_DSTS_OWNER
condition|)
break|break;
if|if
condition|(
name|ri
operator|->
name|ri_nextin
operator|->
name|d_flag
operator|&
name|TULIP_DFLAG_TxLASTSEG
condition|)
block|{
if|if
condition|(
name|ri
operator|->
name|ri_nextin
operator|->
name|d_flag
operator|&
name|TULIP_DFLAG_TxSETUPPKT
condition|)
block|{
comment|/* 		 * We've just finished processing a setup packet. 		 * Mark that we can finished it.  If there's not 		 * another pending, startup the TULIP receiver. 		 * Make sure we ack the RXSTOPPED so we won't get 		 * an abormal interrupt indication. 		 */
name|sc
operator|->
name|tulip_flags
operator|&=
operator|~
name|TULIP_DOINGSETUP
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|tulip_flags
operator|&
name|TULIP_WANTSETUP
operator|)
operator|==
literal|0
condition|)
block|{
name|tulip_rx_intr
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|tulip_cmdmode
operator||=
name|TULIP_CMD_RXRUN
expr_stmt|;
name|sc
operator|->
name|tulip_intrmask
operator||=
name|TULIP_STS_RXSTOPPED
expr_stmt|;
name|TULIP_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_status
argument_list|,
name|TULIP_STS_RXSTOPPED
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|tulip_flags
operator|&
name|TULIP_TXPROBE_ACTIVE
operator|)
operator|==
literal|0
condition|)
name|TULIP_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_command
argument_list|,
name|sc
operator|->
name|tulip_cmdmode
argument_list|)
expr_stmt|;
name|TULIP_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_intr
argument_list|,
name|sc
operator|->
name|tulip_intrmask
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|tulip_desc_t
modifier|*
name|eop
init|=
name|ri
operator|->
name|ri_nextin
decl_stmt|;
name|IF_DEQUEUE
argument_list|(
operator|&
name|sc
operator|->
name|tulip_txq
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|xmits
operator|++
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|tulip_flags
operator|&
name|TULIP_TXPROBE_ACTIVE
condition|)
block|{
if|if
condition|(
operator|(
name|eop
operator|->
name|d_status
operator|&
operator|(
name|TULIP_DSTS_TxNOCARR
operator||
name|TULIP_DSTS_TxEXCCOLL
operator|)
operator|)
operator|==
literal|0
condition|)
name|sc
operator|->
name|tulip_flags
operator||=
name|TULIP_TXPROBE_OK
expr_stmt|;
call|(
modifier|*
name|sc
operator|->
name|tulip_boardsw
operator|->
name|bd_media_select
call|)
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|tulip_chipid
operator|==
name|TULIP_21041
condition|)
name|TULIP_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_sia_status
argument_list|,
name|TULIP_CSR_READ
argument_list|(
name|sc
argument_list|,
name|csr_sia_status
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|eop
operator|->
name|d_status
operator|&
name|TULIP_DSTS_ERRSUM
condition|)
block|{
name|sc
operator|->
name|tulip_if
operator|.
name|if_oerrors
operator|++
expr_stmt|;
if|if
condition|(
name|eop
operator|->
name|d_status
operator|&
name|TULIP_DSTS_TxEXCCOLL
condition|)
name|sc
operator|->
name|tulip_dot3stats
operator|.
name|dot3StatsExcessiveCollisions
operator|++
expr_stmt|;
if|if
condition|(
name|eop
operator|->
name|d_status
operator|&
name|TULIP_DSTS_TxLATECOLL
condition|)
name|sc
operator|->
name|tulip_dot3stats
operator|.
name|dot3StatsLateCollisions
operator|++
expr_stmt|;
if|if
condition|(
name|eop
operator|->
name|d_status
operator|&
operator|(
name|TULIP_DSTS_TxNOCARR
operator||
name|TULIP_DSTS_TxCARRLOSS
operator|)
condition|)
name|sc
operator|->
name|tulip_dot3stats
operator|.
name|dot3StatsCarrierSenseErrors
operator|++
expr_stmt|;
if|if
condition|(
name|eop
operator|->
name|d_status
operator|&
operator|(
name|TULIP_DSTS_TxUNDERFLOW
operator||
name|TULIP_DSTS_TxBABBLE
operator|)
condition|)
name|sc
operator|->
name|tulip_dot3stats
operator|.
name|dot3StatsInternalMacTransmitErrors
operator|++
expr_stmt|;
block|}
else|else
block|{
name|u_int32_t
name|collisions
init|=
operator|(
name|eop
operator|->
name|d_status
operator|&
name|TULIP_DSTS_TxCOLLMASK
operator|)
operator|>>
name|TULIP_DSTS_V_TxCOLLCNT
decl_stmt|;
name|sc
operator|->
name|tulip_if
operator|.
name|if_collisions
operator|+=
name|collisions
expr_stmt|;
if|if
condition|(
name|collisions
operator|==
literal|1
condition|)
name|sc
operator|->
name|tulip_dot3stats
operator|.
name|dot3StatsSingleCollisionFrames
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|collisions
operator|>
literal|1
condition|)
name|sc
operator|->
name|tulip_dot3stats
operator|.
name|dot3StatsMultipleCollisionFrames
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|eop
operator|->
name|d_status
operator|&
name|TULIP_DSTS_TxDEFERRED
condition|)
name|sc
operator|->
name|tulip_dot3stats
operator|.
name|dot3StatsDeferredTransmissions
operator|++
expr_stmt|;
comment|/* 			 * SQE is only valid for 10baseT/BNC/AUI when not 			 * running in full-duplex.  In order to speed up the 			 * test, the corresponding bit in tulip_flags needs to 			 * set as well to get us to count SQE Test Errors. 			 */
if|if
condition|(
name|eop
operator|->
name|d_status
operator|&
name|TULIP_DSTS_TxNOHRTBT
operator|&
name|sc
operator|->
name|tulip_flags
condition|)
name|sc
operator|->
name|tulip_dot3stats
operator|.
name|dot3StatsSQETestErrors
operator|++
expr_stmt|;
block|}
block|}
block|}
block|}
if|if
condition|(
operator|++
name|ri
operator|->
name|ri_nextin
operator|==
name|ri
operator|->
name|ri_last
condition|)
name|ri
operator|->
name|ri_nextin
operator|=
name|ri
operator|->
name|ri_first
expr_stmt|;
name|ri
operator|->
name|ri_free
operator|++
expr_stmt|;
name|sc
operator|->
name|tulip_if
operator|.
name|if_flags
operator|&=
operator|~
name|IFF_OACTIVE
expr_stmt|;
block|}
comment|/*      * If nothing left to transmit, disable the timer.      * Else if progress, reset the timer back to 2 ticks.      */
if|if
condition|(
name|ri
operator|->
name|ri_free
operator|==
name|ri
operator|->
name|ri_max
operator|||
operator|(
name|sc
operator|->
name|tulip_flags
operator|&
name|TULIP_TXPROBE_ACTIVE
operator|)
condition|)
name|sc
operator|->
name|tulip_txtimer
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|xmits
operator|>
literal|0
condition|)
name|sc
operator|->
name|tulip_txtimer
operator|=
name|TULIP_TXTIMER
expr_stmt|;
name|sc
operator|->
name|tulip_if
operator|.
name|if_opackets
operator|+=
name|xmits
expr_stmt|;
return|return
name|xmits
return|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|void
name|tulip_print_abnormal_interrupt
parameter_list|(
name|tulip_softc_t
modifier|*
specifier|const
name|sc
parameter_list|,
name|u_int32_t
name|csr
parameter_list|)
block|{
specifier|const
name|char
modifier|*
specifier|const
modifier|*
name|msgp
init|=
name|tulip_status_bits
decl_stmt|;
specifier|const
name|char
modifier|*
name|sep
decl_stmt|;
name|csr
operator|&=
operator|(
literal|1
operator|<<
operator|(
sizeof|sizeof
argument_list|(
name|tulip_status_bits
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|tulip_status_bits
index|[
literal|0
index|]
argument_list|)
operator|)
operator|)
operator|-
literal|1
expr_stmt|;
name|printf
argument_list|(
name|TULIP_PRINTF_FMT
literal|": abnormal interrupt:"
argument_list|,
name|TULIP_PRINTF_ARGS
argument_list|)
expr_stmt|;
for|for
control|(
name|sep
operator|=
literal|" "
init|;
name|csr
operator|!=
literal|0
condition|;
name|csr
operator|>>=
literal|1
operator|,
name|msgp
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|csr
operator|&
literal|1
operator|)
operator|&&
operator|*
name|msgp
operator|!=
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"%s%s"
argument_list|,
name|sep
argument_list|,
operator|*
name|msgp
argument_list|)
expr_stmt|;
name|sep
operator|=
literal|", "
expr_stmt|;
block|}
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|tulip_intr_handler
parameter_list|(
name|tulip_softc_t
modifier|*
specifier|const
name|sc
parameter_list|,
name|int
modifier|*
name|progress_p
parameter_list|)
block|{
name|u_int32_t
name|csr
decl_stmt|;
while|while
condition|(
operator|(
name|csr
operator|=
name|TULIP_CSR_READ
argument_list|(
name|sc
argument_list|,
name|csr_status
argument_list|)
operator|)
operator|&
name|sc
operator|->
name|tulip_intrmask
condition|)
block|{
operator|*
name|progress_p
operator|=
literal|1
expr_stmt|;
name|TULIP_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_status
argument_list|,
name|csr
argument_list|)
expr_stmt|;
if|if
condition|(
name|csr
operator|&
name|TULIP_STS_SYSERROR
condition|)
block|{
name|sc
operator|->
name|tulip_last_system_error
operator|=
operator|(
name|csr
operator|&
name|TULIP_STS_ERRORMASK
operator|)
operator|>>
name|TULIP_STS_ERR_SHIFT
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|tulip_flags
operator|&
name|TULIP_NOMESSAGES
condition|)
block|{
name|sc
operator|->
name|tulip_flags
operator||=
name|TULIP_SYSTEMERROR
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
name|TULIP_PRINTF_FMT
literal|": system error: %s\n"
argument_list|,
name|TULIP_PRINTF_ARGS
argument_list|,
name|tulip_system_errors
index|[
name|sc
operator|->
name|tulip_last_system_error
index|]
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|tulip_flags
operator||=
name|TULIP_NEEDRESET
expr_stmt|;
name|sc
operator|->
name|tulip_system_errors
operator|++
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|csr
operator|&
operator|(
name|TULIP_STS_GPTIMEOUT
operator||
name|TULIP_STS_LINKPASS
operator||
name|TULIP_STS_LINKFAIL
operator|)
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|TULIP_DEBUG
argument_list|)
name|sc
operator|->
name|tulip_dbg
operator|.
name|dbg_gpintrs
operator|++
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|sc
operator|->
name|tulip_chipid
operator|==
name|TULIP_21041
condition|)
block|{
call|(
modifier|*
name|sc
operator|->
name|tulip_boardsw
operator|->
name|bd_media_select
call|)
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|csr
operator|&
operator|(
name|TULIP_STS_LINKPASS
operator||
name|TULIP_STS_LINKFAIL
operator|)
condition|)
name|csr
operator|&=
operator|~
name|TULIP_STS_ABNRMLINTR
expr_stmt|;
name|TULIP_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_sia_status
argument_list|,
name|TULIP_CSR_READ
argument_list|(
name|sc
argument_list|,
name|csr_sia_status
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sc
operator|->
name|tulip_chipid
operator|==
name|TULIP_21140
operator|||
name|sc
operator|->
name|tulip_chipid
operator|==
name|TULIP_21140A
condition|)
block|{
call|(
modifier|*
name|sc
operator|->
name|tulip_boardsw
operator|->
name|bd_media_select
call|)
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|csr
operator|&=
operator|~
operator|(
name|TULIP_STS_ABNRMLINTR
operator||
name|TULIP_STS_GPTIMEOUT
operator|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|sc
operator|->
name|tulip_flags
operator|&
operator|(
name|TULIP_LINKUP
operator||
name|TULIP_PRINTMEDIA
operator|)
operator|)
operator|==
operator|(
name|TULIP_LINKUP
operator||
name|TULIP_PRINTMEDIA
operator|)
condition|)
block|{
name|printf
argument_list|(
name|TULIP_PRINTF_FMT
literal|": enabling %s port\n"
argument_list|,
name|TULIP_PRINTF_ARGS
argument_list|,
name|tulip_mediums
index|[
name|sc
operator|->
name|tulip_media
index|]
argument_list|)
expr_stmt|;
name|sc
operator|->
name|tulip_flags
operator|&=
operator|~
name|TULIP_PRINTMEDIA
expr_stmt|;
block|}
block|}
if|if
condition|(
name|csr
operator|&
name|TULIP_STS_ABNRMLINTR
condition|)
block|{
name|u_int32_t
name|tmp
init|=
name|csr
operator|&
name|sc
operator|->
name|tulip_intrmask
operator|&
operator|~
operator|(
name|TULIP_STS_NORMALINTR
operator||
name|TULIP_STS_ABNRMLINTR
operator|)
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|tulip_flags
operator|&
name|TULIP_NOMESSAGES
condition|)
block|{
name|sc
operator|->
name|tulip_statusbits
operator||=
name|tmp
expr_stmt|;
block|}
else|else
block|{
name|tulip_print_abnormal_interrupt
argument_list|(
name|sc
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|sc
operator|->
name|tulip_flags
operator||=
name|TULIP_NOMESSAGES
expr_stmt|;
block|}
name|TULIP_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_command
argument_list|,
name|sc
operator|->
name|tulip_cmdmode
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|csr
operator|&
operator|(
name|TULIP_STS_RXINTR
operator||
name|TULIP_STS_RXNOBUF
operator|)
condition|)
block|{
name|tulip_rx_intr
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|csr
operator|&
name|TULIP_STS_RXNOBUF
condition|)
name|sc
operator|->
name|tulip_dot3stats
operator|.
name|dot3StatsMissedFrames
operator|+=
name|TULIP_CSR_READ
argument_list|(
name|sc
argument_list|,
name|csr_missed_frames
argument_list|)
operator|&
literal|0xFFFF
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|tulip_txinfo
operator|.
name|ri_free
operator|<
name|sc
operator|->
name|tulip_txinfo
operator|.
name|ri_max
condition|)
block|{
name|tulip_tx_intr
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|tulip_flags
operator|&
name|TULIP_TXPROBE_ACTIVE
operator|)
operator|==
literal|0
condition|)
name|tulip_ifstart
argument_list|(
operator|&
name|sc
operator|->
name|tulip_if
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|sc
operator|->
name|tulip_flags
operator|&
name|TULIP_NEEDRESET
condition|)
block|{
name|tulip_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|tulip_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|TULIP_USE_SOFTINTR
argument_list|)
end_if

begin_comment
comment|/*  * This is a experimental idea to alleviate problems due to interrupt  * livelock.  What is interrupt livelock?  It's when you spend all your  * time servicing device interrupts and never drop below device ipl  * to do "useful" work.  *  * So what we do here is see if the device needs service and if so,  * disable interrupts (dismiss the interrupt), place it in a list of devices  * needing service, and issue a network software interrupt.  *  * When our network software interrupt routine gets called, we simply  * walk done the list of devices that we have created and deal with them  * at splnet/splsoftnet.  *  */
end_comment

begin_function
specifier|static
name|void
name|tulip_hardintr_handler
parameter_list|(
name|tulip_softc_t
modifier|*
specifier|const
name|sc
parameter_list|,
name|int
modifier|*
name|progress_p
parameter_list|)
block|{
if|if
condition|(
name|TULIP_CSR_READ
argument_list|(
name|sc
argument_list|,
name|csr_status
argument_list|)
operator|&
operator|(
name|TULIP_STS_NORMALINTR
operator||
name|TULIP_STS_ABNRMLINTR
operator|)
operator|==
literal|0
condition|)
return|return;
operator|*
name|progress_p
operator|=
literal|1
expr_stmt|;
comment|/*      * disable interrupts      */
name|TULIP_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_intr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/*      * mark it as needing a software interrupt      */
name|tulip_softintr_mask
operator||=
operator|(
literal|1U
operator|<<
name|sc
operator|->
name|tulip_unit
operator|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|tulip_softintr
parameter_list|(
name|void
parameter_list|)
block|{
name|u_int32_t
name|softintr_mask
decl_stmt|,
name|mask
decl_stmt|;
name|int
name|progress
init|=
literal|0
decl_stmt|;
name|int
name|unit
decl_stmt|;
name|tulip_spl_t
name|s
decl_stmt|;
comment|/*      * Copy mask to local copy and reset global one to 0.      */
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|softintr_mask
operator|=
name|tulip_softintr_mask
expr_stmt|;
name|tulip_softintr_mask
operator|=
literal|0
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/*      * Optimize for the single unit case.      */
if|if
condition|(
name|tulip_softintr_max_unit
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|softintr_mask
operator|&
literal|1
condition|)
block|{
name|tulip_softc_t
modifier|*
specifier|const
name|sc
init|=
name|TULIP_UNIT_TO_SOFTC
argument_list|(
literal|0
argument_list|)
decl_stmt|;
comment|/* 	     * Handle the "interrupt" and then reenable interrupts 	     */
name|tulip_intr_handler
argument_list|(
name|sc
argument_list|,
operator|&
name|progress
argument_list|)
expr_stmt|;
name|TULIP_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_intr
argument_list|,
name|sc
operator|->
name|tulip_intrmask
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
comment|/*      * Handle all "queued" interrupts in a round robin fashion.      * This is done so as not to favor a particular interface.      */
name|unit
operator|=
name|tulip_softintr_last_unit
expr_stmt|;
name|mask
operator|=
operator|(
literal|1U
operator|<<
name|unit
operator|)
expr_stmt|;
while|while
condition|(
name|softintr_mask
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|tulip_softintr_max_unit
operator|==
name|unit
condition|)
block|{
name|unit
operator|=
literal|0
expr_stmt|;
name|mask
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|unit
operator|+=
literal|1
expr_stmt|;
name|mask
operator|<<=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|softintr_mask
operator|&
name|mask
condition|)
block|{
name|tulip_softc_t
modifier|*
specifier|const
name|sc
init|=
name|TULIP_UNIT_TO_SOFTC
argument_list|(
name|unit
argument_list|)
decl_stmt|;
comment|/* 	     * Handle the "interrupt" and then reenable interrupts 	     */
name|tulip_intr_handler
argument_list|(
name|sc
argument_list|,
operator|&
name|progress
argument_list|)
expr_stmt|;
name|TULIP_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_intr
argument_list|,
name|sc
operator|->
name|tulip_intrmask
argument_list|)
expr_stmt|;
name|softintr_mask
operator|^=
name|mask
expr_stmt|;
block|}
block|}
comment|/*      * Save where we ending up.      */
name|tulip_softintr_last_unit
operator|=
name|unit
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* TULIP_USE_SOFTINTR */
end_comment

begin_function
specifier|static
name|tulip_intrfunc_t
name|tulip_intr_shared
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|tulip_softc_t
modifier|*
name|sc
decl_stmt|;
name|int
name|progress
init|=
literal|0
decl_stmt|;
for|for
control|(
name|sc
operator|=
operator|(
name|tulip_softc_t
operator|*
operator|)
name|arg
init|;
name|sc
operator|!=
name|NULL
condition|;
name|sc
operator|=
name|sc
operator|->
name|tulip_slaves
control|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|TULIP_DEBUG
argument_list|)
name|sc
operator|->
name|tulip_dbg
operator|.
name|dbg_intrs
operator|++
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|TULIP_USE_SOFTINTR
argument_list|)
name|tulip_hardintr_handler
argument_list|(
name|sc
argument_list|,
operator|&
name|progress
argument_list|)
expr_stmt|;
else|#
directive|else
name|tulip_intr_handler
argument_list|(
name|sc
argument_list|,
operator|&
name|progress
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|#
directive|if
name|defined
argument_list|(
name|TULIP_USE_SOFTINTR
argument_list|)
if|if
condition|(
name|progress
condition|)
name|schednetisr
argument_list|(
name|NETISR_DE
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
operator|!
name|defined
argument_list|(
name|TULIP_VOID_INTRFUNC
argument_list|)
return|return
name|progress
return|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|tulip_intrfunc_t
name|tulip_intr_normal
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|tulip_softc_t
modifier|*
name|sc
init|=
operator|(
name|tulip_softc_t
operator|*
operator|)
name|arg
decl_stmt|;
name|int
name|progress
init|=
literal|0
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|TULIP_DEBUG
argument_list|)
name|sc
operator|->
name|tulip_dbg
operator|.
name|dbg_intrs
operator|++
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|TULIP_USE_SOFTINTR
argument_list|)
name|tulip_hardintr_handler
argument_list|(
name|sc
argument_list|,
operator|&
name|progress
argument_list|)
expr_stmt|;
if|if
condition|(
name|progress
condition|)
name|schednetisr
argument_list|(
name|NETISR_DE
argument_list|)
expr_stmt|;
else|#
directive|else
name|tulip_intr_handler
argument_list|(
name|sc
argument_list|,
operator|&
name|progress
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
operator|!
name|defined
argument_list|(
name|TULIP_VOID_INTRFUNC
argument_list|)
return|return
name|progress
return|;
endif|#
directive|endif
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *   */
end_comment

begin_function
specifier|static
name|void
name|tulip_delay_300ns
parameter_list|(
name|tulip_softc_t
modifier|*
specifier|const
name|sc
parameter_list|)
block|{
name|int
name|idx
decl_stmt|;
for|for
control|(
name|idx
operator|=
operator|(
literal|300
operator|/
literal|33
operator|)
operator|+
literal|1
init|;
name|idx
operator|>
literal|0
condition|;
name|idx
operator|--
control|)
name|TULIP_CSR_READ
argument_list|(
name|sc
argument_list|,
name|csr_busmode
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_define
define|#
directive|define
name|EMIT
value|do { TULIP_CSR_WRITE(sc, csr_srom_mii, csr); tulip_delay_300ns(sc); } while (0)
end_define

begin_function
specifier|static
name|void
name|tulip_srom_idle
parameter_list|(
name|tulip_softc_t
modifier|*
specifier|const
name|sc
parameter_list|)
block|{
name|unsigned
name|bit
decl_stmt|,
name|csr
decl_stmt|;
name|csr
operator|=
name|SROMSEL
expr_stmt|;
name|EMIT
expr_stmt|;
name|csr
operator|=
name|SROMSEL
operator||
name|SROMRD
expr_stmt|;
name|EMIT
expr_stmt|;
name|csr
operator|^=
name|SROMCS
expr_stmt|;
name|EMIT
expr_stmt|;
name|csr
operator|^=
name|SROMCLKON
expr_stmt|;
name|EMIT
expr_stmt|;
comment|/*      * Write 25 cycles of 0 which will force the SROM to be idle.      */
for|for
control|(
name|bit
operator|=
literal|3
operator|+
name|SROM_BITWIDTH
operator|+
literal|16
init|;
name|bit
operator|>
literal|0
condition|;
name|bit
operator|--
control|)
block|{
name|csr
operator|^=
name|SROMCLKOFF
expr_stmt|;
name|EMIT
expr_stmt|;
comment|/* clock low; data not valid */
name|csr
operator|^=
name|SROMCLKON
expr_stmt|;
name|EMIT
expr_stmt|;
comment|/* clock high; data valid */
block|}
name|csr
operator|^=
name|SROMCLKOFF
expr_stmt|;
name|EMIT
expr_stmt|;
name|csr
operator|^=
name|SROMCS
expr_stmt|;
name|EMIT
expr_stmt|;
name|csr
operator|=
literal|0
expr_stmt|;
name|EMIT
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|tulip_srom_read
parameter_list|(
name|tulip_softc_t
modifier|*
specifier|const
name|sc
parameter_list|)
block|{
name|int
name|idx
decl_stmt|;
specifier|const
name|unsigned
name|bitwidth
init|=
name|SROM_BITWIDTH
decl_stmt|;
specifier|const
name|unsigned
name|cmdmask
init|=
operator|(
name|SROMCMD_RD
operator|<<
name|bitwidth
operator|)
decl_stmt|;
specifier|const
name|unsigned
name|msb
init|=
literal|1
operator|<<
operator|(
name|bitwidth
operator|+
literal|3
operator|-
literal|1
operator|)
decl_stmt|;
name|unsigned
name|lastidx
init|=
operator|(
literal|1
operator|<<
name|bitwidth
operator|)
operator|-
literal|1
decl_stmt|;
name|tulip_srom_idle
argument_list|(
name|sc
argument_list|)
expr_stmt|;
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<=
name|lastidx
condition|;
name|idx
operator|++
control|)
block|{
name|unsigned
name|lastbit
decl_stmt|,
name|data
decl_stmt|,
name|bits
decl_stmt|,
name|bit
decl_stmt|,
name|csr
decl_stmt|;
name|csr
operator|=
name|SROMSEL
expr_stmt|;
name|EMIT
expr_stmt|;
name|csr
operator|=
name|SROMSEL
operator||
name|SROMRD
expr_stmt|;
name|EMIT
expr_stmt|;
name|csr
operator|^=
name|SROMCSON
expr_stmt|;
name|EMIT
expr_stmt|;
name|csr
operator|^=
name|SROMCLKON
expr_stmt|;
name|EMIT
expr_stmt|;
name|lastbit
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|bits
operator|=
name|idx
operator||
name|cmdmask
operator|,
name|bit
operator|=
name|bitwidth
operator|+
literal|3
init|;
name|bit
operator|>
literal|0
condition|;
name|bit
operator|--
operator|,
name|bits
operator|<<=
literal|1
control|)
block|{
specifier|const
name|unsigned
name|thisbit
init|=
name|bits
operator|&
name|msb
decl_stmt|;
name|csr
operator|^=
name|SROMCLKOFF
expr_stmt|;
name|EMIT
expr_stmt|;
comment|/* clock low; data not valid */
if|if
condition|(
name|thisbit
operator|!=
name|lastbit
condition|)
block|{
name|csr
operator|^=
name|SROMDOUT
expr_stmt|;
name|EMIT
expr_stmt|;
comment|/* clock low; invert data */
block|}
else|else
block|{
name|EMIT
expr_stmt|;
block|}
name|csr
operator|^=
name|SROMCLKON
expr_stmt|;
name|EMIT
expr_stmt|;
comment|/* clock high; data valid */
name|lastbit
operator|=
name|thisbit
expr_stmt|;
block|}
name|csr
operator|^=
name|SROMCLKOFF
expr_stmt|;
name|EMIT
expr_stmt|;
for|for
control|(
name|data
operator|=
literal|0
operator|,
name|bits
operator|=
literal|0
init|;
name|bits
operator|<
literal|16
condition|;
name|bits
operator|++
control|)
block|{
name|data
operator|<<=
literal|1
expr_stmt|;
name|csr
operator|^=
name|SROMCLKON
expr_stmt|;
name|EMIT
expr_stmt|;
comment|/* clock high; data valid */
name|data
operator||=
name|TULIP_CSR_READ
argument_list|(
name|sc
argument_list|,
name|csr_srom_mii
argument_list|)
operator|&
name|SROMDIN
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|csr
operator|^=
name|SROMCLKOFF
expr_stmt|;
name|EMIT
expr_stmt|;
comment|/* clock low; data not valid */
block|}
name|sc
operator|->
name|tulip_rombuf
index|[
name|idx
operator|*
literal|2
index|]
operator|=
name|data
operator|&
literal|0xFF
expr_stmt|;
name|sc
operator|->
name|tulip_rombuf
index|[
name|idx
operator|*
literal|2
operator|+
literal|1
index|]
operator|=
name|data
operator|>>
literal|8
expr_stmt|;
name|csr
operator|=
name|SROMSEL
operator||
name|SROMRD
expr_stmt|;
name|EMIT
expr_stmt|;
name|csr
operator|=
literal|0
expr_stmt|;
name|EMIT
expr_stmt|;
block|}
name|tulip_srom_idle
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_define
define|#
directive|define
name|MII_EMIT
value|do { TULIP_CSR_WRITE(sc, csr_srom_mii, csr); tulip_delay_300ns(sc); } while (0)
end_define

begin_function
specifier|static
name|void
name|tulip_mii_sendbits
parameter_list|(
name|tulip_softc_t
modifier|*
specifier|const
name|sc
parameter_list|,
name|unsigned
name|data
parameter_list|,
name|unsigned
name|bits
parameter_list|)
block|{
name|unsigned
name|msb
init|=
literal|1
operator|<<
operator|(
name|bits
operator|-
literal|1
operator|)
decl_stmt|;
name|unsigned
name|csr
init|=
name|TULIP_CSR_READ
argument_list|(
name|sc
argument_list|,
name|csr_srom_mii
argument_list|)
operator|&
operator|(
name|MII_RD
operator||
name|MII_DOUT
operator||
name|MII_CLK
operator|)
decl_stmt|;
name|unsigned
name|lastbit
init|=
operator|(
name|csr
operator|&
name|MII_DOUT
operator|)
condition|?
name|msb
else|:
literal|0
decl_stmt|;
name|csr
operator||=
name|MII_WR
expr_stmt|;
name|MII_EMIT
expr_stmt|;
comment|/* clock low; assert write */
for|for
control|(
init|;
name|bits
operator|>
literal|0
condition|;
name|bits
operator|--
operator|,
name|data
operator|<<=
literal|1
control|)
block|{
specifier|const
name|unsigned
name|thisbit
init|=
name|data
operator|&
name|msb
decl_stmt|;
if|if
condition|(
name|thisbit
operator|!=
name|lastbit
condition|)
block|{
name|csr
operator|^=
name|MII_DOUT
expr_stmt|;
name|MII_EMIT
expr_stmt|;
comment|/* clock low; invert data */
block|}
name|csr
operator|^=
name|MII_CLKON
expr_stmt|;
name|MII_EMIT
expr_stmt|;
comment|/* clock high; data valid */
name|lastbit
operator|=
name|thisbit
expr_stmt|;
name|csr
operator|^=
name|MII_CLKOFF
expr_stmt|;
name|MII_EMIT
expr_stmt|;
comment|/* clock low; data not valid */
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|tulip_mii_turnaround
parameter_list|(
name|tulip_softc_t
modifier|*
specifier|const
name|sc
parameter_list|,
name|unsigned
name|cmd
parameter_list|)
block|{
name|unsigned
name|csr
init|=
name|TULIP_CSR_READ
argument_list|(
name|sc
argument_list|,
name|csr_srom_mii
argument_list|)
operator|&
operator|(
name|MII_RD
operator||
name|MII_DOUT
operator||
name|MII_CLK
operator|)
decl_stmt|;
if|if
condition|(
name|cmd
operator|==
name|MII_WRCMD
condition|)
block|{
name|csr
operator||=
name|MII_DOUT
expr_stmt|;
name|MII_EMIT
expr_stmt|;
comment|/* clock low; change data */
name|csr
operator|^=
name|MII_CLKON
expr_stmt|;
name|MII_EMIT
expr_stmt|;
comment|/* clock high; data valid */
name|csr
operator|^=
name|MII_CLKOFF
expr_stmt|;
name|MII_EMIT
expr_stmt|;
comment|/* clock low; data not valid */
name|csr
operator|^=
name|MII_DOUT
expr_stmt|;
name|MII_EMIT
expr_stmt|;
comment|/* clock low; change data */
block|}
else|else
block|{
name|csr
operator||=
name|MII_RD
expr_stmt|;
name|MII_EMIT
expr_stmt|;
comment|/* clock low; switch to read */
block|}
name|csr
operator|^=
name|MII_CLKON
expr_stmt|;
name|MII_EMIT
expr_stmt|;
comment|/* clock high; data valid */
name|csr
operator|^=
name|MII_CLKOFF
expr_stmt|;
name|MII_EMIT
expr_stmt|;
comment|/* clock low; data not valid */
block|}
end_function

begin_function
specifier|static
name|unsigned
name|tulip_mii_readbits
parameter_list|(
name|tulip_softc_t
modifier|*
specifier|const
name|sc
parameter_list|)
block|{
name|unsigned
name|data
decl_stmt|;
name|unsigned
name|csr
init|=
name|TULIP_CSR_READ
argument_list|(
name|sc
argument_list|,
name|csr_srom_mii
argument_list|)
operator|&
operator|(
name|MII_RD
operator||
name|MII_DOUT
operator||
name|MII_CLK
operator|)
decl_stmt|;
name|int
name|idx
decl_stmt|;
for|for
control|(
name|idx
operator|=
literal|0
operator|,
name|data
operator|=
literal|0
init|;
name|idx
operator|<
literal|16
condition|;
name|idx
operator|++
control|)
block|{
name|data
operator|<<=
literal|1
expr_stmt|;
comment|/* this is NOOP on the first pass through */
name|csr
operator|^=
name|MII_CLKON
expr_stmt|;
name|MII_EMIT
expr_stmt|;
comment|/* clock high; data valid */
if|if
condition|(
name|TULIP_CSR_READ
argument_list|(
name|sc
argument_list|,
name|csr_srom_mii
argument_list|)
operator|&
name|MII_DIN
condition|)
name|data
operator||=
literal|1
expr_stmt|;
name|csr
operator|^=
name|MII_CLKOFF
expr_stmt|;
name|MII_EMIT
expr_stmt|;
comment|/* clock low; data not valid */
block|}
name|csr
operator|^=
name|MII_RD
expr_stmt|;
name|MII_EMIT
expr_stmt|;
comment|/* clock low; turn off read */
return|return
name|data
return|;
block|}
end_function

begin_function
specifier|static
name|unsigned
name|tulip_mii_readreg
parameter_list|(
name|tulip_softc_t
modifier|*
specifier|const
name|sc
parameter_list|,
name|unsigned
name|devaddr
parameter_list|,
name|unsigned
name|regno
parameter_list|)
block|{
name|unsigned
name|csr
init|=
name|TULIP_CSR_READ
argument_list|(
name|sc
argument_list|,
name|csr_srom_mii
argument_list|)
operator|&
operator|(
name|MII_RD
operator||
name|MII_DOUT
operator||
name|MII_CLK
operator|)
decl_stmt|;
name|unsigned
name|data
decl_stmt|;
name|csr
operator|&=
operator|~
operator|(
name|MII_RD
operator||
name|MII_CLK
operator|)
expr_stmt|;
name|MII_EMIT
expr_stmt|;
name|tulip_mii_sendbits
argument_list|(
name|sc
argument_list|,
name|MII_PREAMBLE
argument_list|,
literal|32
argument_list|)
expr_stmt|;
name|tulip_mii_sendbits
argument_list|(
name|sc
argument_list|,
name|MII_RDCMD
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|tulip_mii_sendbits
argument_list|(
name|sc
argument_list|,
name|devaddr
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|tulip_mii_sendbits
argument_list|(
name|sc
argument_list|,
name|regno
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|tulip_mii_turnaround
argument_list|(
name|sc
argument_list|,
name|MII_RDCMD
argument_list|)
expr_stmt|;
name|data
operator|=
name|tulip_mii_readbits
argument_list|(
name|sc
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TULIP_DEBUG
name|sc
operator|->
name|tulip_dbg
operator|.
name|dbg_phyregs
index|[
name|regno
index|]
index|[
literal|0
index|]
operator|=
name|data
expr_stmt|;
name|sc
operator|->
name|tulip_dbg
operator|.
name|dbg_phyregs
index|[
name|regno
index|]
index|[
literal|1
index|]
operator|++
expr_stmt|;
endif|#
directive|endif
return|return
name|data
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|tulip_mii_writereg
parameter_list|(
name|tulip_softc_t
modifier|*
specifier|const
name|sc
parameter_list|,
name|unsigned
name|devaddr
parameter_list|,
name|unsigned
name|regno
parameter_list|,
name|unsigned
name|data
parameter_list|)
block|{
name|unsigned
name|csr
init|=
name|TULIP_CSR_READ
argument_list|(
name|sc
argument_list|,
name|csr_srom_mii
argument_list|)
operator|&
operator|(
name|MII_RD
operator||
name|MII_DOUT
operator||
name|MII_CLK
operator|)
decl_stmt|;
name|csr
operator|&=
operator|~
operator|(
name|MII_RD
operator||
name|MII_CLK
operator|)
expr_stmt|;
name|MII_EMIT
expr_stmt|;
name|tulip_mii_sendbits
argument_list|(
name|sc
argument_list|,
name|MII_PREAMBLE
argument_list|,
literal|32
argument_list|)
expr_stmt|;
name|tulip_mii_sendbits
argument_list|(
name|sc
argument_list|,
name|MII_WRCMD
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|tulip_mii_sendbits
argument_list|(
name|sc
argument_list|,
name|devaddr
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|tulip_mii_sendbits
argument_list|(
name|sc
argument_list|,
name|regno
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|tulip_mii_turnaround
argument_list|(
name|sc
argument_list|,
name|MII_WRCMD
argument_list|)
expr_stmt|;
name|tulip_mii_sendbits
argument_list|(
name|sc
argument_list|,
name|data
argument_list|,
literal|16
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TULIP_DEBUG
name|sc
operator|->
name|tulip_dbg
operator|.
name|dbg_phyregs
index|[
name|regno
index|]
index|[
literal|2
index|]
operator|=
name|data
expr_stmt|;
name|sc
operator|->
name|tulip_dbg
operator|.
name|dbg_phyregs
index|[
name|regno
index|]
index|[
literal|3
index|]
operator|++
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_escape
end_escape

begin_define
define|#
directive|define
name|tulip_mchash
parameter_list|(
name|mca
parameter_list|)
value|(tulip_crc32(mca, 6)& 0x1FF)
end_define

begin_define
define|#
directive|define
name|tulip_srom_crcok
parameter_list|(
name|databuf
parameter_list|)
value|( \     ((tulip_crc32(databuf, 126)& 0xFFFF) ^ 0xFFFF)== \      ((databuf)[126] | ((databuf)[127]<< 8)))
end_define

begin_function
specifier|static
name|unsigned
name|tulip_crc32
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|databuf
parameter_list|,
name|size_t
name|datalen
parameter_list|)
block|{
name|u_int
name|idx
decl_stmt|,
name|bit
decl_stmt|,
name|data
decl_stmt|,
name|crc
init|=
literal|0xFFFFFFFFUL
decl_stmt|;
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
name|datalen
condition|;
name|idx
operator|++
control|)
for|for
control|(
name|data
operator|=
operator|*
name|databuf
operator|++
operator|,
name|bit
operator|=
literal|0
init|;
name|bit
operator|<
literal|8
condition|;
name|bit
operator|++
operator|,
name|data
operator|>>=
literal|1
control|)
name|crc
operator|=
operator|(
name|crc
operator|>>
literal|1
operator|)
operator|^
operator|(
operator|(
operator|(
name|crc
operator|^
name|data
operator|)
operator|&
literal|1
operator|)
condition|?
name|TULIP_CRC32_POLY
else|:
literal|0
operator|)
expr_stmt|;
return|return
name|crc
return|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|void
name|tulip_identify_smc_nic
parameter_list|(
name|tulip_softc_t
modifier|*
name|sc
parameter_list|)
block|{
name|u_int32_t
name|id1
decl_stmt|,
name|id2
decl_stmt|,
name|ei
decl_stmt|;
name|int
name|auibnc
init|=
literal|0
decl_stmt|,
name|utp
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|tulip_chipid
operator|==
name|TULIP_21041
condition|)
return|return;
if|if
condition|(
name|sc
operator|->
name|tulip_chipid
operator|==
name|TULIP_21140
condition|)
block|{
name|sc
operator|->
name|tulip_boardsw
operator|=
operator|&
name|tulip_21140_smc9332_boardsw
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|sc
operator|->
name|tulip_chipid
operator|==
name|TULIP_21140A
condition|)
block|{
name|sc
operator|->
name|tulip_boardsw
operator|=
operator|&
name|tulip_21140A_smc9332bdt_boardsw
expr_stmt|;
return|return;
block|}
name|id1
operator|=
name|sc
operator|->
name|tulip_rombuf
index|[
literal|0x60
index|]
operator||
operator|(
name|sc
operator|->
name|tulip_rombuf
index|[
literal|0x61
index|]
operator|<<
literal|8
operator|)
expr_stmt|;
name|id2
operator|=
name|sc
operator|->
name|tulip_rombuf
index|[
literal|0x62
index|]
operator||
operator|(
name|sc
operator|->
name|tulip_rombuf
index|[
literal|0x63
index|]
operator|<<
literal|8
operator|)
expr_stmt|;
name|ei
operator|=
name|sc
operator|->
name|tulip_rombuf
index|[
literal|0x66
index|]
operator||
operator|(
name|sc
operator|->
name|tulip_rombuf
index|[
literal|0x67
index|]
operator|<<
literal|8
operator|)
expr_stmt|;
name|strcpy
argument_list|(
name|sc
operator|->
name|tulip_boardidbuf
argument_list|,
literal|"SMC 8432"
argument_list|)
expr_stmt|;
name|cp
operator|=
operator|&
name|sc
operator|->
name|tulip_boardidbuf
index|[
literal|8
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|id1
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
operator|*
name|cp
operator|++
operator|=
literal|'B'
operator|,
name|auibnc
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|id1
operator|&
literal|0xFF
operator|)
operator|>
literal|0x32
condition|)
operator|*
name|cp
operator|++
operator|=
literal|'T'
operator|,
name|utp
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|id1
operator|&
literal|0x4000
operator|)
operator|==
literal|0
condition|)
operator|*
name|cp
operator|++
operator|=
literal|'A'
operator|,
name|auibnc
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|id2
operator|==
literal|0x15
condition|)
block|{
name|sc
operator|->
name|tulip_boardidbuf
index|[
literal|7
index|]
operator|=
literal|'4'
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
literal|'-'
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
literal|'C'
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
literal|'H'
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
operator|(
name|ei
condition|?
literal|'2'
else|:
literal|'1'
operator|)
expr_stmt|;
block|}
operator|*
name|cp
operator|++
operator|=
literal|' '
expr_stmt|;
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|utp
operator|&&
operator|!
name|auibnc
condition|)
name|sc
operator|->
name|tulip_boardsw
operator|=
operator|&
name|tulip_21040_10baset_only_boardsw
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|utp
operator|&&
name|auibnc
condition|)
name|sc
operator|->
name|tulip_boardsw
operator|=
operator|&
name|tulip_21040_auibnc_only_boardsw
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  * This deals with the vagaries of the address roms and the  * brain-deadness that various vendors commit in using them.  */
end_comment

begin_function
specifier|static
name|int
name|tulip_read_macaddr
parameter_list|(
name|tulip_softc_t
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|cksum
decl_stmt|,
name|rom_cksum
decl_stmt|,
name|idx
decl_stmt|;
name|u_int32_t
name|csr
decl_stmt|;
name|unsigned
name|char
name|tmpbuf
index|[
literal|8
index|]
decl_stmt|;
specifier|static
specifier|const
name|u_char
name|testpat
index|[]
init|=
block|{
literal|0xFF
block|,
literal|0
block|,
literal|0x55
block|,
literal|0xAA
block|,
literal|0xFF
block|,
literal|0
block|,
literal|0x55
block|,
literal|0xAA
block|}
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|tulip_chipid
operator|==
name|TULIP_21040
condition|)
block|{
name|TULIP_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_enetrom
argument_list|,
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|tulip_rombuf
argument_list|)
condition|;
name|idx
operator|++
control|)
block|{
name|int
name|cnt
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|(
operator|(
name|csr
operator|=
name|TULIP_CSR_READ
argument_list|(
name|sc
argument_list|,
name|csr_enetrom
argument_list|)
operator|)
operator|&
literal|0x80000000L
operator|)
operator|&&
name|cnt
operator|<
literal|10000
condition|)
name|cnt
operator|++
expr_stmt|;
name|sc
operator|->
name|tulip_rombuf
index|[
name|idx
index|]
operator|=
name|csr
operator|&
literal|0xFF
expr_stmt|;
block|}
name|sc
operator|->
name|tulip_boardsw
operator|=
operator|&
name|tulip_21040_boardsw
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|TULIP_EISA
argument_list|)
block|}
elseif|else
if|if
condition|(
name|sc
operator|->
name|tulip_chipid
operator|==
name|TULIP_DE425
condition|)
block|{
name|int
name|cnt
decl_stmt|;
for|for
control|(
name|idx
operator|=
literal|0
operator|,
name|cnt
operator|=
literal|0
init|;
name|idx
operator|<
sizeof|sizeof
argument_list|(
name|testpat
argument_list|)
operator|&&
name|cnt
operator|<
literal|32
condition|;
name|cnt
operator|++
control|)
block|{
name|tmpbuf
index|[
name|idx
index|]
operator|=
name|TULIP_CSR_READBYTE
argument_list|(
name|sc
argument_list|,
name|csr_enetrom
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmpbuf
index|[
name|idx
index|]
operator|==
name|testpat
index|[
name|idx
index|]
condition|)
operator|++
name|idx
expr_stmt|;
else|else
name|idx
operator|=
literal|0
expr_stmt|;
block|}
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
literal|32
condition|;
name|idx
operator|++
control|)
name|sc
operator|->
name|tulip_rombuf
index|[
name|idx
index|]
operator|=
name|TULIP_CSR_READBYTE
argument_list|(
name|sc
argument_list|,
name|csr_enetrom
argument_list|)
expr_stmt|;
name|sc
operator|->
name|tulip_boardsw
operator|=
operator|&
name|tulip_21040_boardsw
expr_stmt|;
endif|#
directive|endif
comment|/* TULIP_EISA */
block|}
else|else
block|{
name|int
name|new_srom_fmt
init|=
literal|0
decl_stmt|;
comment|/* 	 * Thankfully all 21041's act the same. 	 * Assume all 21140 board are compatible with the 	 * DEC 10/100 evaluation board.  Not really valid but 	 * it's the best we can do until every one switches to 	 * the new SROM format. 	 */
if|if
condition|(
name|sc
operator|->
name|tulip_chipid
operator|==
name|TULIP_21041
condition|)
name|sc
operator|->
name|tulip_boardsw
operator|=
operator|&
name|tulip_21041_boardsw
expr_stmt|;
else|else
name|sc
operator|->
name|tulip_boardsw
operator|=
operator|&
name|tulip_21140_eb_boardsw
expr_stmt|;
name|tulip_srom_read
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|tulip_srom_crcok
argument_list|(
name|sc
operator|->
name|tulip_rombuf
argument_list|)
condition|)
block|{
comment|/* 	     * SROM CRC is valid therefore it must be in the 	     * new format. 	     */
name|new_srom_fmt
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sc
operator|->
name|tulip_rombuf
index|[
literal|126
index|]
operator|==
literal|0xff
operator|&&
name|sc
operator|->
name|tulip_rombuf
index|[
literal|127
index|]
operator|==
literal|0xFF
condition|)
block|{
comment|/* 	     * No checksum is present.  See if the SROM id checks out; 	     * the first 18 bytes should be 0 followed by a 1 followed 	     * by the number of adapters (which we don't deal with yet). 	     */
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
literal|18
condition|;
name|idx
operator|++
control|)
block|{
if|if
condition|(
name|sc
operator|->
name|tulip_rombuf
index|[
name|idx
index|]
operator|!=
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|idx
operator|==
literal|18
operator|&&
name|sc
operator|->
name|tulip_rombuf
index|[
literal|18
index|]
operator|==
literal|1
operator|&&
name|sc
operator|->
name|tulip_rombuf
index|[
literal|19
index|]
operator|!=
literal|0
condition|)
name|new_srom_fmt
operator|=
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|new_srom_fmt
condition|)
block|{
name|int
name|copy_name
init|=
literal|0
decl_stmt|;
comment|/* 	     * New SROM format.  Copy out the Ethernet address. 	     * If it contains a DE500-XA string, then it must be 	     * a DE500-XA. 	     */
name|bcopy
argument_list|(
name|sc
operator|->
name|tulip_rombuf
operator|+
literal|20
argument_list|,
name|sc
operator|->
name|tulip_hwaddr
argument_list|,
literal|6
argument_list|)
expr_stmt|;
if|if
condition|(
name|bcmp
argument_list|(
name|sc
operator|->
name|tulip_rombuf
operator|+
literal|29
argument_list|,
literal|"DE500-XA"
argument_list|,
literal|8
argument_list|)
operator|==
literal|0
condition|)
block|{
name|sc
operator|->
name|tulip_boardsw
operator|=
operator|&
name|tulip_21140_de500xa_boardsw
expr_stmt|;
name|copy_name
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bcmp
argument_list|(
name|sc
operator|->
name|tulip_rombuf
operator|+
literal|29
argument_list|,
literal|"DE500-AA"
argument_list|,
literal|8
argument_list|)
operator|==
literal|0
condition|)
block|{
name|sc
operator|->
name|tulip_boardsw
operator|=
operator|&
name|tulip_21140_de500aa_boardsw
expr_stmt|;
name|copy_name
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bcmp
argument_list|(
name|sc
operator|->
name|tulip_rombuf
operator|+
literal|29
argument_list|,
literal|"DE450"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
block|{
name|copy_name
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|copy_name
condition|)
block|{
name|bcopy
argument_list|(
name|sc
operator|->
name|tulip_rombuf
operator|+
literal|29
argument_list|,
name|sc
operator|->
name|tulip_boardidbuf
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|sc
operator|->
name|tulip_boardidbuf
index|[
literal|8
index|]
operator|=
literal|' '
expr_stmt|;
name|sc
operator|->
name|tulip_boardid
operator|=
name|sc
operator|->
name|tulip_boardidbuf
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|tulip_boardsw
operator|==
name|NULL
condition|)
return|return
operator|-
literal|6
return|;
goto|goto
name|check_oui
goto|;
block|}
block|}
if|if
condition|(
name|bcmp
argument_list|(
operator|&
name|sc
operator|->
name|tulip_rombuf
index|[
literal|0
index|]
argument_list|,
operator|&
name|sc
operator|->
name|tulip_rombuf
index|[
literal|16
index|]
argument_list|,
literal|8
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* 	 * Some folks don't use the standard ethernet rom format 	 * but instead just put the address in the first 6 bytes 	 * of the rom and let the rest be all 0xffs.  (Can we say 	 * ZNYX???) (well sometimes they put in a checksum so we'll 	 * start at 8). 	 */
for|for
control|(
name|idx
operator|=
literal|8
init|;
name|idx
operator|<
literal|32
condition|;
name|idx
operator|++
control|)
block|{
if|if
condition|(
name|sc
operator|->
name|tulip_rombuf
index|[
name|idx
index|]
operator|!=
literal|0xFF
condition|)
return|return
operator|-
literal|4
return|;
block|}
comment|/* 	 * Make sure the address is not multicast or locally assigned 	 * that the OUI is not 00-00-00. 	 */
if|if
condition|(
operator|(
name|sc
operator|->
name|tulip_rombuf
index|[
literal|0
index|]
operator|&
literal|3
operator|)
operator|!=
literal|0
condition|)
return|return
operator|-
literal|4
return|;
if|if
condition|(
name|sc
operator|->
name|tulip_rombuf
index|[
literal|0
index|]
operator|==
literal|0
operator|&&
name|sc
operator|->
name|tulip_rombuf
index|[
literal|1
index|]
operator|==
literal|0
operator|&&
name|sc
operator|->
name|tulip_rombuf
index|[
literal|2
index|]
operator|==
literal|0
condition|)
return|return
operator|-
literal|4
return|;
name|bcopy
argument_list|(
name|sc
operator|->
name|tulip_rombuf
argument_list|,
name|sc
operator|->
name|tulip_hwaddr
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|sc
operator|->
name|tulip_flags
operator||=
name|TULIP_ROMOK
expr_stmt|;
goto|goto
name|check_oui
goto|;
block|}
else|else
block|{
comment|/* 	 * A number of makers of multiport boards (ZNYX and Cogent) 	 * only put on one address ROM on their 21040 boards.  So 	 * if the ROM is all zeros and this is a 21040, look at the 	 * previous configured boards (as long as they are on the same 	 * PCI bus and the bus number is non-zero) until we find the 	 * master board with address ROM.  We then use its address ROM 	 * as the base for this board.  (we add our relative board 	 * to the last byte of its address). 	 */
if|if
condition|(
name|sc
operator|->
name|tulip_chipid
operator|==
name|TULIP_21040
comment|/*&& sc->tulip_bus != 0 XXX */
condition|)
block|{
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
literal|32
condition|;
name|idx
operator|++
control|)
block|{
if|if
condition|(
name|sc
operator|->
name|tulip_rombuf
index|[
name|idx
index|]
operator|!=
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|idx
operator|==
literal|32
condition|)
block|{
name|int
name|root_unit
decl_stmt|;
name|tulip_softc_t
modifier|*
name|root_sc
init|=
name|NULL
decl_stmt|;
for|for
control|(
name|root_unit
operator|=
name|sc
operator|->
name|tulip_unit
operator|-
literal|1
init|;
name|root_unit
operator|>=
literal|0
condition|;
name|root_unit
operator|--
control|)
block|{
name|root_sc
operator|=
name|TULIP_UNIT_TO_SOFTC
argument_list|(
name|root_unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|root_sc
operator|==
name|NULL
operator|||
operator|(
name|root_sc
operator|->
name|tulip_flags
operator|&
operator|(
name|TULIP_ROMOK
operator||
name|TULIP_SLAVEDROM
operator|)
operator|)
operator|==
name|TULIP_ROMOK
condition|)
break|break;
name|root_sc
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|root_sc
operator|!=
name|NULL
comment|/*&& root_sc->tulip_bus == sc->tulip_bus XXX */
condition|)
block|{
name|bcopy
argument_list|(
name|root_sc
operator|->
name|tulip_hwaddr
argument_list|,
name|sc
operator|->
name|tulip_hwaddr
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|sc
operator|->
name|tulip_hwaddr
index|[
literal|5
index|]
operator|+=
name|sc
operator|->
name|tulip_unit
operator|-
name|root_sc
operator|->
name|tulip_unit
expr_stmt|;
name|sc
operator|->
name|tulip_flags
operator||=
name|TULIP_SLAVEDROM
expr_stmt|;
if|if
condition|(
name|root_sc
operator|->
name|tulip_boardsw
operator|->
name|bd_type
operator|==
name|TULIP_21040_ZX314_MASTER
condition|)
block|{
name|sc
operator|->
name|tulip_boardsw
operator|=
operator|&
name|tulip_21040_zx314_slave_boardsw
expr_stmt|;
comment|/* 			 * Now for a truly disgusting kludge: all 4 21040s on 			 * the ZX314 share the same INTA line so the mapping 			 * setup by the BIOS on the PCI bridge is worthless. 			 * Rather than reprogramming the value in the config 			 * register, we will handle this internally. 			 */
name|sc
operator|->
name|tulip_slaves
operator|=
name|root_sc
operator|->
name|tulip_slaves
expr_stmt|;
name|root_sc
operator|->
name|tulip_slaves
operator|=
name|sc
expr_stmt|;
name|sc
operator|->
name|tulip_flags
operator||=
name|TULIP_SLAVEDINTR
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
block|}
block|}
block|}
comment|/*      * This is the standard DEC address ROM test.      */
if|if
condition|(
name|bcmp
argument_list|(
operator|&
name|sc
operator|->
name|tulip_rombuf
index|[
literal|24
index|]
argument_list|,
name|testpat
argument_list|,
literal|8
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|-
literal|3
return|;
name|tmpbuf
index|[
literal|0
index|]
operator|=
name|sc
operator|->
name|tulip_rombuf
index|[
literal|15
index|]
expr_stmt|;
name|tmpbuf
index|[
literal|1
index|]
operator|=
name|sc
operator|->
name|tulip_rombuf
index|[
literal|14
index|]
expr_stmt|;
name|tmpbuf
index|[
literal|2
index|]
operator|=
name|sc
operator|->
name|tulip_rombuf
index|[
literal|13
index|]
expr_stmt|;
name|tmpbuf
index|[
literal|3
index|]
operator|=
name|sc
operator|->
name|tulip_rombuf
index|[
literal|12
index|]
expr_stmt|;
name|tmpbuf
index|[
literal|4
index|]
operator|=
name|sc
operator|->
name|tulip_rombuf
index|[
literal|11
index|]
expr_stmt|;
name|tmpbuf
index|[
literal|5
index|]
operator|=
name|sc
operator|->
name|tulip_rombuf
index|[
literal|10
index|]
expr_stmt|;
name|tmpbuf
index|[
literal|6
index|]
operator|=
name|sc
operator|->
name|tulip_rombuf
index|[
literal|9
index|]
expr_stmt|;
name|tmpbuf
index|[
literal|7
index|]
operator|=
name|sc
operator|->
name|tulip_rombuf
index|[
literal|8
index|]
expr_stmt|;
if|if
condition|(
name|bcmp
argument_list|(
operator|&
name|sc
operator|->
name|tulip_rombuf
index|[
literal|0
index|]
argument_list|,
name|tmpbuf
argument_list|,
literal|8
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|-
literal|2
return|;
name|bcopy
argument_list|(
name|sc
operator|->
name|tulip_rombuf
argument_list|,
name|sc
operator|->
name|tulip_hwaddr
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|cksum
operator|=
operator|*
operator|(
name|u_int16_t
operator|*
operator|)
operator|&
name|sc
operator|->
name|tulip_hwaddr
index|[
literal|0
index|]
expr_stmt|;
name|cksum
operator|*=
literal|2
expr_stmt|;
if|if
condition|(
name|cksum
operator|>
literal|65535
condition|)
name|cksum
operator|-=
literal|65535
expr_stmt|;
name|cksum
operator|+=
operator|*
operator|(
name|u_int16_t
operator|*
operator|)
operator|&
name|sc
operator|->
name|tulip_hwaddr
index|[
literal|2
index|]
expr_stmt|;
if|if
condition|(
name|cksum
operator|>
literal|65535
condition|)
name|cksum
operator|-=
literal|65535
expr_stmt|;
name|cksum
operator|*=
literal|2
expr_stmt|;
if|if
condition|(
name|cksum
operator|>
literal|65535
condition|)
name|cksum
operator|-=
literal|65535
expr_stmt|;
name|cksum
operator|+=
operator|*
operator|(
name|u_int16_t
operator|*
operator|)
operator|&
name|sc
operator|->
name|tulip_hwaddr
index|[
literal|4
index|]
expr_stmt|;
if|if
condition|(
name|cksum
operator|>=
literal|65535
condition|)
name|cksum
operator|-=
literal|65535
expr_stmt|;
name|rom_cksum
operator|=
operator|*
operator|(
name|u_int16_t
operator|*
operator|)
operator|&
name|sc
operator|->
name|tulip_rombuf
index|[
literal|6
index|]
expr_stmt|;
if|if
condition|(
name|cksum
operator|!=
name|rom_cksum
condition|)
return|return
operator|-
literal|1
return|;
name|check_oui
label|:
comment|/*      * Check for various boards based on OUI.  Did I say braindead?      */
if|if
condition|(
name|sc
operator|->
name|tulip_hwaddr
index|[
literal|0
index|]
operator|==
name|TULIP_OUI_COGENT_0
operator|&&
name|sc
operator|->
name|tulip_hwaddr
index|[
literal|1
index|]
operator|==
name|TULIP_OUI_COGENT_1
operator|&&
name|sc
operator|->
name|tulip_hwaddr
index|[
literal|2
index|]
operator|==
name|TULIP_OUI_COGENT_2
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|tulip_chipid
operator|==
name|TULIP_21140
operator|||
name|sc
operator|->
name|tulip_chipid
operator|==
name|TULIP_21140A
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|tulip_rombuf
index|[
literal|32
index|]
operator|==
name|TULIP_COGENT_EM100_ID
condition|)
name|sc
operator|->
name|tulip_boardsw
operator|=
operator|&
name|tulip_21140_cogent_em100_boardsw
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|sc
operator|->
name|tulip_hwaddr
index|[
literal|0
index|]
operator|==
name|TULIP_OUI_ZNYX_0
operator|&&
name|sc
operator|->
name|tulip_hwaddr
index|[
literal|1
index|]
operator|==
name|TULIP_OUI_ZNYX_1
operator|&&
name|sc
operator|->
name|tulip_hwaddr
index|[
literal|2
index|]
operator|==
name|TULIP_OUI_ZNYX_2
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|tulip_chipid
operator|==
name|TULIP_21140
operator|||
name|sc
operator|->
name|tulip_chipid
operator|==
name|TULIP_21140A
condition|)
block|{
comment|/* this at least works for the zx342 from Znyx */
name|sc
operator|->
name|tulip_boardsw
operator|=
operator|&
name|tulip_21140_znyx_zx34x_boardsw
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sc
operator|->
name|tulip_chipid
operator|==
name|TULIP_21040
operator|&&
operator|(
name|sc
operator|->
name|tulip_hwaddr
index|[
literal|3
index|]
operator|&
operator|~
literal|3
operator|)
operator|==
literal|0xF0
operator|&&
operator|(
name|sc
operator|->
name|tulip_hwaddr
index|[
literal|5
index|]
operator|&
literal|2
operator|)
operator|==
literal|0
condition|)
block|{
name|sc
operator|->
name|tulip_boardsw
operator|=
operator|&
name|tulip_21040_zx314_master_boardsw
expr_stmt|;
name|sc
operator|->
name|tulip_flags
operator||=
name|TULIP_SHAREDINTR
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|sc
operator|->
name|tulip_hwaddr
index|[
literal|0
index|]
operator|==
name|TULIP_OUI_SMC_0
operator|&&
name|sc
operator|->
name|tulip_hwaddr
index|[
literal|1
index|]
operator|==
name|TULIP_OUI_SMC_1
operator|&&
name|sc
operator|->
name|tulip_hwaddr
index|[
literal|2
index|]
operator|==
name|TULIP_OUI_SMC_2
condition|)
block|{
name|tulip_identify_smc_nic
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|tulip_boardidbuf
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
name|sc
operator|->
name|tulip_boardid
operator|=
name|sc
operator|->
name|tulip_boardidbuf
expr_stmt|;
else|else
name|sc
operator|->
name|tulip_boardid
operator|=
name|sc
operator|->
name|tulip_boardsw
operator|->
name|bd_description
expr_stmt|;
name|sc
operator|->
name|tulip_flags
operator||=
name|TULIP_ROMOK
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|void
name|tulip_addr_filter
parameter_list|(
name|tulip_softc_t
modifier|*
specifier|const
name|sc
parameter_list|)
block|{
name|u_int32_t
modifier|*
name|sp
init|=
name|sc
operator|->
name|tulip_setupdata
decl_stmt|;
name|struct
name|ether_multistep
name|step
decl_stmt|;
name|struct
name|ether_multi
modifier|*
name|enm
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
name|sc
operator|->
name|tulip_flags
operator|&=
operator|~
name|TULIP_WANTHASH
expr_stmt|;
name|sc
operator|->
name|tulip_flags
operator||=
name|TULIP_WANTSETUP
expr_stmt|;
name|sc
operator|->
name|tulip_cmdmode
operator|&=
operator|~
name|TULIP_CMD_RXRUN
expr_stmt|;
name|sc
operator|->
name|tulip_intrmask
operator|&=
operator|~
name|TULIP_STS_RXSTOPPED
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|tulip_ac
operator|.
name|ac_multicnt
operator|>
literal|14
condition|)
block|{
name|unsigned
name|hash
decl_stmt|;
comment|/* 	 * If we have more than 14 multicasts, we have 	 * go into hash perfect mode (512 bit multicast 	 * hash and one perfect hardware). 	 */
name|bzero
argument_list|(
name|sc
operator|->
name|tulip_setupdata
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|tulip_setupdata
argument_list|)
argument_list|)
expr_stmt|;
name|hash
operator|=
name|tulip_mchash
argument_list|(
name|etherbroadcastaddr
argument_list|)
expr_stmt|;
name|sp
index|[
name|hash
operator|>>
literal|4
index|]
operator||=
literal|1
operator|<<
operator|(
name|hash
operator|&
literal|0xF
operator|)
expr_stmt|;
name|ETHER_FIRST_MULTI
argument_list|(
name|step
argument_list|,
operator|&
name|sc
operator|->
name|tulip_ac
argument_list|,
name|enm
argument_list|)
expr_stmt|;
while|while
condition|(
name|enm
operator|!=
name|NULL
condition|)
block|{
name|hash
operator|=
name|tulip_mchash
argument_list|(
name|enm
operator|->
name|enm_addrlo
argument_list|)
expr_stmt|;
name|sp
index|[
name|hash
operator|>>
literal|4
index|]
operator||=
literal|1
operator|<<
operator|(
name|hash
operator|&
literal|0xF
operator|)
expr_stmt|;
name|ETHER_NEXT_MULTI
argument_list|(
name|step
argument_list|,
name|enm
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|tulip_flags
operator||=
name|TULIP_WANTHASH
expr_stmt|;
name|sp
index|[
literal|39
index|]
operator|=
operator|(
operator|(
name|u_int16_t
operator|*
operator|)
name|sc
operator|->
name|tulip_ac
operator|.
name|ac_enaddr
operator|)
index|[
literal|0
index|]
expr_stmt|;
name|sp
index|[
literal|40
index|]
operator|=
operator|(
operator|(
name|u_int16_t
operator|*
operator|)
name|sc
operator|->
name|tulip_ac
operator|.
name|ac_enaddr
operator|)
index|[
literal|1
index|]
expr_stmt|;
name|sp
index|[
literal|41
index|]
operator|=
operator|(
operator|(
name|u_int16_t
operator|*
operator|)
name|sc
operator|->
name|tulip_ac
operator|.
name|ac_enaddr
operator|)
index|[
literal|2
index|]
expr_stmt|;
block|}
else|else
block|{
comment|/* 	 * Else can get perfect filtering for 16 addresses. 	 */
name|ETHER_FIRST_MULTI
argument_list|(
name|step
argument_list|,
operator|&
name|sc
operator|->
name|tulip_ac
argument_list|,
name|enm
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|enm
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
operator|*
name|sp
operator|++
operator|=
operator|(
operator|(
name|u_int16_t
operator|*
operator|)
name|enm
operator|->
name|enm_addrlo
operator|)
index|[
literal|0
index|]
expr_stmt|;
operator|*
name|sp
operator|++
operator|=
operator|(
operator|(
name|u_int16_t
operator|*
operator|)
name|enm
operator|->
name|enm_addrlo
operator|)
index|[
literal|1
index|]
expr_stmt|;
operator|*
name|sp
operator|++
operator|=
operator|(
operator|(
name|u_int16_t
operator|*
operator|)
name|enm
operator|->
name|enm_addrlo
operator|)
index|[
literal|2
index|]
expr_stmt|;
name|ETHER_NEXT_MULTI
argument_list|(
name|step
argument_list|,
name|enm
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Add the broadcast address. 	 */
name|i
operator|++
expr_stmt|;
operator|*
name|sp
operator|++
operator|=
literal|0xFFFF
expr_stmt|;
operator|*
name|sp
operator|++
operator|=
literal|0xFFFF
expr_stmt|;
operator|*
name|sp
operator|++
operator|=
literal|0xFFFF
expr_stmt|;
comment|/* 	 * Pad the rest with our hardware address 	 */
for|for
control|(
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
block|{
operator|*
name|sp
operator|++
operator|=
operator|(
operator|(
name|u_int16_t
operator|*
operator|)
name|sc
operator|->
name|tulip_ac
operator|.
name|ac_enaddr
operator|)
index|[
literal|0
index|]
expr_stmt|;
operator|*
name|sp
operator|++
operator|=
operator|(
operator|(
name|u_int16_t
operator|*
operator|)
name|sc
operator|->
name|tulip_ac
operator|.
name|ac_enaddr
operator|)
index|[
literal|1
index|]
expr_stmt|;
operator|*
name|sp
operator|++
operator|=
operator|(
operator|(
name|u_int16_t
operator|*
operator|)
name|sc
operator|->
name|tulip_ac
operator|.
name|ac_enaddr
operator|)
index|[
literal|2
index|]
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  * This routine is entered at splnet() and thereby imposes no problems  * when TULIP_USE_SOFTINTR is defined or not.  */
end_comment

begin_function
specifier|static
name|int
name|tulip_ifioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
specifier|const
name|ifp
parameter_list|,
name|ioctl_cmd_t
name|cmd
parameter_list|,
name|caddr_t
name|data
parameter_list|)
block|{
name|tulip_softc_t
modifier|*
specifier|const
name|sc
init|=
name|TULIP_IFP_TO_SOFTC
argument_list|(
name|ifp
argument_list|)
decl_stmt|;
name|struct
name|ifreq
modifier|*
name|ifr
init|=
operator|(
expr|struct
name|ifreq
operator|*
operator|)
name|data
decl_stmt|;
name|tulip_spl_t
name|s
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|TULIP_USE_SOFTINTR
argument_list|)
name|s
operator|=
name|splnet
argument_list|()
expr_stmt|;
else|#
directive|else
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|SIOCSIFADDR
case|:
case|case
name|SIOCGIFADDR
case|:
name|ether_ioctl
argument_list|(
name|ifp
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCSIFFLAGS
case|:
block|{
comment|/* 	     * Changing the connection forces a reset. 	     */
if|if
condition|(
name|sc
operator|->
name|tulip_flags
operator|&
name|TULIP_ALTPHYS
condition|)
block|{
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_ALTPHYS
operator|)
operator|==
literal|0
condition|)
block|{
name|sc
operator|->
name|tulip_flags
operator||=
name|TULIP_NEEDRESET
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_ALTPHYS
condition|)
block|{
name|sc
operator|->
name|tulip_flags
operator||=
name|TULIP_NEEDRESET
expr_stmt|;
block|}
block|}
if|if
condition|(
name|sc
operator|->
name|tulip_flags
operator|&
name|TULIP_NEEDRESET
condition|)
block|{
name|sc
operator|->
name|tulip_media
operator|=
name|TULIP_MEDIA_UNKNOWN
expr_stmt|;
name|sc
operator|->
name|tulip_probe_state
operator|=
name|TULIP_PROBE_INACTIVE
expr_stmt|;
name|sc
operator|->
name|tulip_flags
operator|&=
operator|~
operator|(
name|TULIP_TXPROBE_ACTIVE
operator||
name|TULIP_TXPROBE_OK
operator||
name|TULIP_WANTRXACT
operator|)
expr_stmt|;
name|tulip_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
name|tulip_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|SIOCADDMULTI
case|:
case|case
name|SIOCDELMULTI
case|:
block|{
comment|/* 	     * Update multicast listeners 	     */
if|if
condition|(
name|cmd
operator|==
name|SIOCADDMULTI
condition|)
name|error
operator|=
name|ether_addmulti
argument_list|(
name|ifr
argument_list|,
operator|&
name|sc
operator|->
name|tulip_ac
argument_list|)
expr_stmt|;
else|else
name|error
operator|=
name|ether_delmulti
argument_list|(
name|ifr
argument_list|,
operator|&
name|sc
operator|->
name|tulip_ac
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|ENETRESET
condition|)
block|{
name|tulip_addr_filter
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* reset multicast filtering */
name|tulip_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
block|}
break|break;
block|}
if|#
directive|if
name|defined
argument_list|(
name|SIOCSIFMTU
argument_list|)
if|#
directive|if
operator|!
name|defined
argument_list|(
name|ifr_mtu
argument_list|)
define|#
directive|define
name|ifr_mtu
value|ifr_metric
endif|#
directive|endif
case|case
name|SIOCSIFMTU
case|:
comment|/* 	     * Set the interface MTU. 	     */
if|if
condition|(
name|ifr
operator|->
name|ifr_mtu
operator|>
name|ETHERMTU
ifdef|#
directive|ifdef
name|BIG_PACKET
operator|&&
name|sc
operator|->
name|tulip_chipid
operator|!=
name|TULIP_21140
operator|&&
name|sc
operator|->
name|tulip_chipid
operator|!=
name|TULIP_21140A
operator|&&
name|sc
operator|->
name|tulip_chipid
operator|!=
name|TULIP_21041
endif|#
directive|endif
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|ifp
operator|->
name|if_mtu
operator|=
name|ifr
operator|->
name|ifr_mtu
expr_stmt|;
ifdef|#
directive|ifdef
name|BIG_PACKET
name|tulip_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|tulip_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
endif|#
directive|endif
comment|/* SIOCSIFMTU */
default|default:
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  * This routine gets called at splimp (from ether_output).  This might pose  * a problem for TULIP_USE_SOFTINTR if ether_output is called at splimp  * from another driver.  */
end_comment

begin_function
specifier|static
name|ifnet_ret_t
name|tulip_ifstart
parameter_list|(
name|struct
name|ifnet
modifier|*
specifier|const
name|ifp
parameter_list|)
block|{
name|tulip_softc_t
modifier|*
specifier|const
name|sc
init|=
name|TULIP_IFP_TO_SOFTC
argument_list|(
name|ifp
argument_list|)
decl_stmt|;
name|struct
name|ifqueue
modifier|*
specifier|const
name|ifq
init|=
operator|&
name|ifp
operator|->
name|if_snd
decl_stmt|;
name|tulip_ringinfo_t
modifier|*
specifier|const
name|ri
init|=
operator|&
name|sc
operator|->
name|tulip_txinfo
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|,
modifier|*
name|m0
decl_stmt|,
modifier|*
name|next_m0
decl_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
operator|)
operator|==
literal|0
operator|&&
operator|(
name|sc
operator|->
name|tulip_flags
operator|&
name|TULIP_TXPROBE_ACTIVE
operator|)
operator|==
literal|0
condition|)
return|return;
for|for
control|(
init|;
condition|;
control|)
block|{
name|tulip_desc_t
modifier|*
name|eop
decl_stmt|,
modifier|*
name|nextout
decl_stmt|;
name|int
name|segcnt
decl_stmt|,
name|free
decl_stmt|,
name|recopy
decl_stmt|;
name|u_int32_t
name|d_status
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|tulip_flags
operator|&
name|TULIP_WANTSETUP
condition|)
block|{
if|if
condition|(
operator|(
name|sc
operator|->
name|tulip_flags
operator|&
name|TULIP_DOINGSETUP
operator|)
operator|||
name|ri
operator|->
name|ri_free
operator|==
literal|1
condition|)
block|{
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_OACTIVE
expr_stmt|;
return|return;
block|}
name|bcopy
argument_list|(
name|sc
operator|->
name|tulip_setupdata
argument_list|,
name|sc
operator|->
name|tulip_setupbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|tulip_setupbuf
argument_list|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|tulip_flags
operator|&=
operator|~
name|TULIP_WANTSETUP
expr_stmt|;
name|sc
operator|->
name|tulip_flags
operator||=
name|TULIP_DOINGSETUP
expr_stmt|;
name|ri
operator|->
name|ri_free
operator|--
expr_stmt|;
name|ri
operator|->
name|ri_nextout
operator|->
name|d_flag
operator|&=
name|TULIP_DFLAG_ENDRING
operator||
name|TULIP_DFLAG_CHAIN
expr_stmt|;
name|ri
operator|->
name|ri_nextout
operator|->
name|d_flag
operator||=
name|TULIP_DFLAG_TxFIRSTSEG
operator||
name|TULIP_DFLAG_TxLASTSEG
operator||
name|TULIP_DFLAG_TxSETUPPKT
operator||
name|TULIP_DFLAG_TxWANTINTR
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|tulip_flags
operator|&
name|TULIP_WANTHASH
condition|)
name|ri
operator|->
name|ri_nextout
operator|->
name|d_flag
operator||=
name|TULIP_DFLAG_TxHASHFILT
expr_stmt|;
name|ri
operator|->
name|ri_nextout
operator|->
name|d_length1
operator|=
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|tulip_setupbuf
argument_list|)
expr_stmt|;
name|ri
operator|->
name|ri_nextout
operator|->
name|d_addr1
operator|=
name|TULIP_KVATOPHYS
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|tulip_setupbuf
argument_list|)
expr_stmt|;
name|ri
operator|->
name|ri_nextout
operator|->
name|d_length2
operator|=
literal|0
expr_stmt|;
name|ri
operator|->
name|ri_nextout
operator|->
name|d_addr2
operator|=
literal|0
expr_stmt|;
name|ri
operator|->
name|ri_nextout
operator|->
name|d_status
operator|=
name|TULIP_DSTS_OWNER
expr_stmt|;
name|TULIP_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_txpoll
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* 	     * Advance the ring for the next transmit packet. 	     */
if|if
condition|(
operator|++
name|ri
operator|->
name|ri_nextout
operator|==
name|ri
operator|->
name|ri_last
condition|)
name|ri
operator|->
name|ri_nextout
operator|=
name|ri
operator|->
name|ri_first
expr_stmt|;
comment|/* 	     * Make sure the next descriptor is owned by us since it 	     * may have been set up above if we ran out of room in the 	     * ring. 	     */
name|ri
operator|->
name|ri_nextout
operator|->
name|d_status
operator|=
literal|0
expr_stmt|;
block|}
name|IF_DEQUEUE
argument_list|(
name|ifq
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
break|break;
if|#
directive|if
name|defined
argument_list|(
name|TULIP_DEBUG
argument_list|)
if|if
condition|(
operator|(
name|sc
operator|->
name|tulip_cmdmode
operator|&
name|TULIP_CMD_TXRUN
operator|)
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
name|TULIP_PRINTF_FMT
literal|": ifstart%s: tx not running\n"
argument_list|,
name|TULIP_PRINTF_ARGS
argument_list|,
operator|(
name|sc
operator|->
name|tulip_flags
operator|&
name|TULIP_TXPROBE_ACTIVE
operator|)
condition|?
literal|"(probe)"
else|:
literal|""
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_OACTIVE
expr_stmt|;
name|IF_PREPEND
argument_list|(
name|ifq
argument_list|,
name|m
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
comment|/* 	 * Now we try to fill in our transmit descriptors.  This is 	 * a bit reminiscent of going on the Ark two by two 	 * since each descriptor for the TULIP can describe 	 * two buffers.  So we advance through packet filling 	 * each of the two entries at a time to to fill each 	 * descriptor.  Clear the first and last segment bits 	 * in each descriptor (actually just clear everything 	 * but the end-of-ring or chain bits) to make sure 	 * we don't get messed up by previously sent packets. 	 * 	 * We may fail to put the entire packet on the ring if 	 * there is either not enough ring entries free or if the 	 * packet has more than MAX_TXSEG segments.  In the former 	 * case we will just wait for the ring to empty.  In the 	 * latter case we have to recopy. 	 */
name|d_status
operator|=
literal|0
expr_stmt|;
name|recopy
operator|=
literal|0
expr_stmt|;
name|eop
operator|=
name|nextout
operator|=
name|ri
operator|->
name|ri_nextout
expr_stmt|;
name|m0
operator|=
name|m
expr_stmt|;
name|segcnt
operator|=
literal|0
expr_stmt|;
name|free
operator|=
name|ri
operator|->
name|ri_free
expr_stmt|;
do|do
block|{
name|int
name|len
init|=
name|m0
operator|->
name|m_len
decl_stmt|;
name|caddr_t
name|addr
init|=
name|mtod
argument_list|(
name|m0
argument_list|,
name|caddr_t
argument_list|)
decl_stmt|;
name|unsigned
name|clsize
init|=
name|CLBYTES
operator|-
operator|(
operator|(
operator|(
name|u_long
operator|)
name|addr
operator|)
operator|&
operator|(
name|CLBYTES
operator|-
literal|1
operator|)
operator|)
decl_stmt|;
name|next_m0
operator|=
name|m0
operator|->
name|m_next
expr_stmt|;
while|while
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|unsigned
name|slen
init|=
name|min
argument_list|(
name|len
argument_list|,
name|clsize
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|BIG_PACKET
name|int
name|partial
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|slen
operator|>=
literal|2048
condition|)
name|slen
operator|=
literal|2040
operator|,
name|partial
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
name|segcnt
operator|++
expr_stmt|;
if|if
condition|(
name|segcnt
operator|>
name|TULIP_MAX_TXSEG
condition|)
block|{
name|recopy
operator|=
literal|1
expr_stmt|;
name|next_m0
operator|=
name|NULL
expr_stmt|;
comment|/* to break out of outside loop */
break|break;
block|}
if|if
condition|(
name|segcnt
operator|&
literal|1
condition|)
block|{
if|if
condition|(
operator|--
name|free
operator|==
literal|0
condition|)
block|{
comment|/* 			 * There's no more room but since nothing 			 * has been committed at this point, just 			 * show output is active, put back the 			 * mbuf and return. 			 */
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_OACTIVE
expr_stmt|;
name|IF_PREPEND
argument_list|(
name|ifq
argument_list|,
name|m
argument_list|)
expr_stmt|;
return|return;
block|}
name|eop
operator|=
name|nextout
expr_stmt|;
if|if
condition|(
operator|++
name|nextout
operator|==
name|ri
operator|->
name|ri_last
condition|)
name|nextout
operator|=
name|ri
operator|->
name|ri_first
expr_stmt|;
name|eop
operator|->
name|d_flag
operator|&=
name|TULIP_DFLAG_ENDRING
operator||
name|TULIP_DFLAG_CHAIN
expr_stmt|;
name|eop
operator|->
name|d_status
operator|=
name|d_status
expr_stmt|;
name|eop
operator|->
name|d_addr1
operator|=
name|TULIP_KVATOPHYS
argument_list|(
name|sc
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|eop
operator|->
name|d_length1
operator|=
name|slen
expr_stmt|;
block|}
else|else
block|{
comment|/* 		     *  Fill in second half of descriptor 		     */
name|eop
operator|->
name|d_addr2
operator|=
name|TULIP_KVATOPHYS
argument_list|(
name|sc
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|eop
operator|->
name|d_length2
operator|=
name|slen
expr_stmt|;
block|}
name|d_status
operator|=
name|TULIP_DSTS_OWNER
expr_stmt|;
name|len
operator|-=
name|slen
expr_stmt|;
name|addr
operator|+=
name|slen
expr_stmt|;
ifdef|#
directive|ifdef
name|BIG_PACKET
if|if
condition|(
name|partial
condition|)
continue|continue;
endif|#
directive|endif
name|clsize
operator|=
name|CLBYTES
expr_stmt|;
block|}
block|}
do|while
condition|(
operator|(
name|m0
operator|=
name|next_m0
operator|)
operator|!=
name|NULL
condition|)
do|;
comment|/* 	 * The packet exceeds the number of transmit buffer 	 * entries that we can use for one packet, so we have 	 * recopy it into one mbuf and then try again. 	 */
if|if
condition|(
name|recopy
condition|)
block|{
name|MGETHDR
argument_list|(
name|m0
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m0
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|>
name|MHLEN
condition|)
block|{
name|MCLGET
argument_list|(
name|m0
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|m0
operator|->
name|m_flags
operator|&
name|M_EXT
operator|)
operator|==
literal|0
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
name|m_copydata
argument_list|(
name|m
argument_list|,
literal|0
argument_list|,
name|m
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|,
name|mtod
argument_list|(
name|m0
argument_list|,
name|caddr_t
argument_list|)
argument_list|)
expr_stmt|;
name|m0
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|m0
operator|->
name|m_len
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
name|IF_PREPEND
argument_list|(
name|ifq
argument_list|,
name|m0
argument_list|)
expr_stmt|;
block|}
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* 	 * The descriptors have been filled in.  Now get ready 	 * to transmit. 	 */
if|#
directive|if
name|NBPFILTER
operator|>
literal|0
if|if
condition|(
name|sc
operator|->
name|tulip_bpf
operator|!=
name|NULL
condition|)
name|TULIP_BPF_MTAP
argument_list|(
name|sc
argument_list|,
name|m
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|IF_ENQUEUE
argument_list|(
operator|&
name|sc
operator|->
name|tulip_txq
argument_list|,
name|m
argument_list|)
expr_stmt|;
comment|/* 	 * Make sure the next descriptor after this packet is owned 	 * by us since it may have been set up above if we ran out 	 * of room in the ring. 	 */
name|nextout
operator|->
name|d_status
operator|=
literal|0
expr_stmt|;
comment|/* 	 * If we only used the first segment of the last descriptor, 	 * make sure the second segment will not be used. 	 */
if|if
condition|(
name|segcnt
operator|&
literal|1
condition|)
block|{
name|eop
operator|->
name|d_addr2
operator|=
literal|0
expr_stmt|;
name|eop
operator|->
name|d_length2
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 	 * Mark the last and first segments, indicate we want a transmit 	 * complete interrupt, give the descriptors to the TULIP, and tell 	 * it to transmit! 	 */
name|eop
operator|->
name|d_flag
operator||=
name|TULIP_DFLAG_TxLASTSEG
operator||
name|TULIP_DFLAG_TxWANTINTR
expr_stmt|;
comment|/* 	 * Note that ri->ri_nextout is still the start of the packet 	 * and until we set the OWNER bit, we can still back out of 	 * everything we have done. 	 */
name|ri
operator|->
name|ri_nextout
operator|->
name|d_flag
operator||=
name|TULIP_DFLAG_TxFIRSTSEG
expr_stmt|;
name|ri
operator|->
name|ri_nextout
operator|->
name|d_status
operator|=
name|TULIP_DSTS_OWNER
expr_stmt|;
comment|/* 	 * This advances the ring for us. 	 */
name|ri
operator|->
name|ri_nextout
operator|=
name|nextout
expr_stmt|;
name|ri
operator|->
name|ri_free
operator|=
name|free
expr_stmt|;
name|TULIP_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_txpoll
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|tulip_flags
operator|&
name|TULIP_TXPROBE_ACTIVE
condition|)
block|{
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_OACTIVE
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|sc
operator|->
name|tulip_txtimer
operator|==
literal|0
condition|)
name|sc
operator|->
name|tulip_txtimer
operator|=
name|TULIP_TXTIMER
expr_stmt|;
block|}
if|if
condition|(
name|m
operator|!=
name|NULL
condition|)
block|{
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_OACTIVE
expr_stmt|;
name|IF_PREPEND
argument_list|(
name|ifq
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  * Even though this routine runs at splimp, it does not break  * our use of splnet (splsoftnet under NetBSD) for the majority  * of this driver (if TULIP_USE_SOFTINTR defined) since   * if_watcbog is called from if_watchdog which is called from  * splsoftclock which is below splnet.  */
end_comment

begin_function
specifier|static
name|void
name|tulip_ifwatchdog
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|tulip_softc_t
modifier|*
specifier|const
name|sc
init|=
name|TULIP_IFP_TO_SOFTC
argument_list|(
name|ifp
argument_list|)
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|TULIP_DEBUG
argument_list|)
name|u_int32_t
name|rxintrs
init|=
name|sc
operator|->
name|tulip_dbg
operator|.
name|dbg_rxintrs
operator|-
name|sc
operator|->
name|tulip_dbg
operator|.
name|dbg_last_rxintrs
decl_stmt|;
if|if
condition|(
name|rxintrs
operator|>
name|sc
operator|->
name|tulip_dbg
operator|.
name|dbg_high_rxintrs_hz
condition|)
name|sc
operator|->
name|tulip_dbg
operator|.
name|dbg_high_rxintrs_hz
operator|=
name|rxintrs
expr_stmt|;
name|sc
operator|->
name|tulip_dbg
operator|.
name|dbg_last_rxintrs
operator|=
name|sc
operator|->
name|tulip_dbg
operator|.
name|dbg_rxintrs
expr_stmt|;
name|sc
operator|->
name|tulip_dbg
operator|.
name|dbg_gpintrs_hz
operator|=
name|sc
operator|->
name|tulip_dbg
operator|.
name|dbg_gpintrs
expr_stmt|;
name|sc
operator|->
name|tulip_dbg
operator|.
name|dbg_gpintrs
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* TULIP_DEBUG */
name|sc
operator|->
name|tulip_if
operator|.
name|if_timer
operator|=
literal|1
expr_stmt|;
comment|/*      * These should be rare so do a bulk test up front so we can just skip      * them if needed.      */
if|if
condition|(
name|sc
operator|->
name|tulip_flags
operator|&
operator|(
name|TULIP_SYSTEMERROR
operator||
name|TULIP_RXBUFSLOW
operator||
name|TULIP_FAKEGPTIMEOUT
operator||
name|TULIP_NOMESSAGES
operator|)
condition|)
block|{
comment|/* 	 * This for those devices that need to autosense.  Interrupts are not 	 * allowed during device probe so we fake one here to start the 	 * autosense.  Do this before the others since it can effect their 	 * state. 	 */
if|if
condition|(
name|sc
operator|->
name|tulip_flags
operator|&
name|TULIP_FAKEGPTIMEOUT
condition|)
call|(
modifier|*
name|sc
operator|->
name|tulip_boardsw
operator|->
name|bd_media_select
call|)
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * If the number of receive buffer is low, try to refill 	 */
if|if
condition|(
name|sc
operator|->
name|tulip_flags
operator|&
name|TULIP_RXBUFSLOW
condition|)
name|tulip_rx_intr
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|tulip_flags
operator|&
name|TULIP_SYSTEMERROR
condition|)
block|{
name|printf
argument_list|(
name|TULIP_PRINTF_FMT
literal|": %d system errors: last was %s\n"
argument_list|,
name|TULIP_PRINTF_ARGS
argument_list|,
name|sc
operator|->
name|tulip_system_errors
argument_list|,
name|tulip_system_errors
index|[
name|sc
operator|->
name|tulip_last_system_error
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|tulip_statusbits
condition|)
block|{
name|tulip_print_abnormal_interrupt
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|tulip_statusbits
argument_list|)
expr_stmt|;
name|sc
operator|->
name|tulip_statusbits
operator|=
literal|0
expr_stmt|;
block|}
name|sc
operator|->
name|tulip_flags
operator|&=
operator|~
operator|(
name|TULIP_NOMESSAGES
operator||
name|TULIP_SYSTEMERROR
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|tulip_txtimer
operator|&&
operator|--
name|sc
operator|->
name|tulip_txtimer
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
name|TULIP_PRINTF_FMT
literal|": transmission timeout\n"
argument_list|,
name|TULIP_PRINTF_ARGS
argument_list|)
expr_stmt|;
name|sc
operator|->
name|tulip_media
operator|=
name|TULIP_MEDIA_UNKNOWN
expr_stmt|;
name|sc
operator|->
name|tulip_probe_state
operator|=
name|TULIP_PROBE_INACTIVE
expr_stmt|;
name|sc
operator|->
name|tulip_flags
operator|&=
operator|~
operator|(
name|TULIP_TXPROBE_ACTIVE
operator||
name|TULIP_TXPROBE_OK
operator||
name|TULIP_WANTRXACT
operator||
name|TULIP_LINKUP
operator||
name|TULIP_LINKSUSPECT
operator|)
expr_stmt|;
name|tulip_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|tulip_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__bsdi__
argument_list|)
operator|||
operator|(
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
operator|&&
name|BSD
operator|<
literal|199506
operator|)
end_if

begin_function
specifier|static
name|ifnet_ret_t
name|tulip_ifwatchdog_wrapper
parameter_list|(
name|int
name|unit
parameter_list|)
block|{
name|tulip_ifwatchdog
argument_list|(
operator|&
name|TULIP_UNIT_TO_SOFTC
argument_list|(
name|unit
argument_list|)
operator|->
name|tulip_if
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|tulip_ifwatchdog
value|tulip_ifwatchdog_wrapper
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/*  * All printf's are real as of now!  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|printf
end_ifdef

begin_undef
undef|#
directive|undef
name|printf
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|IFF_NOTRAILERS
argument_list|)
end_if

begin_define
define|#
directive|define
name|IFF_NOTRAILERS
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|tulip_attach
parameter_list|(
name|tulip_softc_t
modifier|*
specifier|const
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
specifier|const
name|ifp
init|=
operator|&
name|sc
operator|->
name|tulip_if
decl_stmt|;
name|ifp
operator|->
name|if_flags
operator|=
name|IFF_BROADCAST
operator||
name|IFF_SIMPLEX
operator||
name|IFF_NOTRAILERS
operator||
name|IFF_MULTICAST
expr_stmt|;
name|ifp
operator|->
name|if_ioctl
operator|=
name|tulip_ifioctl
expr_stmt|;
name|ifp
operator|->
name|if_start
operator|=
name|tulip_ifstart
expr_stmt|;
name|ifp
operator|->
name|if_watchdog
operator|=
name|tulip_ifwatchdog
expr_stmt|;
name|ifp
operator|->
name|if_init
operator|=
operator|(
name|if_init_f_t
operator|*
operator|)
name|tulip_init
expr_stmt|;
name|ifp
operator|->
name|if_timer
operator|=
literal|1
expr_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|__bsdi__
argument_list|)
operator|||
name|_BSDI_VERSION
operator|<
literal|199401
name|ifp
operator|->
name|if_output
operator|=
name|ether_output
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|__bsdi__
argument_list|)
operator|&&
name|_BSDI_VERSION
operator|<
literal|199401
name|ifp
operator|->
name|if_mtu
operator|=
name|ETHERMTU
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|__bsdi__
argument_list|)
operator|&&
name|_BSDI_VERSION
operator|>=
literal|199510
name|aprint_naive
argument_list|(
literal|": DEC Ethernet"
argument_list|)
expr_stmt|;
name|aprint_normal
argument_list|(
literal|": %s%s"
argument_list|,
name|sc
operator|->
name|tulip_boardid
argument_list|,
name|tulip_chipdescs
index|[
name|sc
operator|->
name|tulip_chipid
index|]
argument_list|)
expr_stmt|;
name|aprint_verbose
argument_list|(
literal|" pass %d.%d"
argument_list|,
operator|(
name|sc
operator|->
name|tulip_revinfo
operator|&
literal|0xF0
operator|)
operator|>>
literal|4
argument_list|,
name|sc
operator|->
name|tulip_revinfo
operator|&
literal|0x0F
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|tulip_pf
operator|=
name|aprint_normal
expr_stmt|;
name|aprint_normal
argument_list|(
name|TULIP_PRINTF_FMT
literal|": address "
name|TULIP_EADDR_FMT
literal|"\n"
argument_list|,
name|TULIP_PRINTF_ARGS
argument_list|,
name|TULIP_EADDR_ARGS
argument_list|(
name|sc
operator|->
name|tulip_hwaddr
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|printf
argument_list|(
if|#
directive|if
name|defined
argument_list|(
name|__bsdi__
argument_list|)
literal|"\n"
endif|#
directive|endif
name|TULIP_PRINTF_FMT
literal|": %s%s pass %d.%d\n"
argument_list|,
name|TULIP_PRINTF_ARGS
argument_list|,
name|sc
operator|->
name|tulip_boardid
argument_list|,
name|tulip_chipdescs
index|[
name|sc
operator|->
name|tulip_chipid
index|]
argument_list|,
operator|(
name|sc
operator|->
name|tulip_revinfo
operator|&
literal|0xF0
operator|)
operator|>>
literal|4
argument_list|,
name|sc
operator|->
name|tulip_revinfo
operator|&
literal|0x0F
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|TULIP_PRINTF_FMT
literal|": address "
name|TULIP_EADDR_FMT
literal|"\n"
argument_list|,
name|TULIP_PRINTF_ARGS
argument_list|,
name|TULIP_EADDR_ARGS
argument_list|(
name|sc
operator|->
name|tulip_hwaddr
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sc
operator|->
name|tulip_dot3stats
operator|.
name|dot3Compliance
operator|=
name|DOT3COMPLIANCE_STATS
expr_stmt|;
name|sc
operator|->
name|tulip_dot3stats
operator|.
name|dot3StatsEtherChipSet
operator|=
name|tulip_chip2mib
index|[
name|sc
operator|->
name|tulip_chipid
index|]
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|tulip_boardsw
operator|->
name|bd_mii_probe
operator|!=
name|NULL
condition|)
call|(
modifier|*
name|sc
operator|->
name|tulip_boardsw
operator|->
name|bd_mii_probe
call|)
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
call|(
modifier|*
name|sc
operator|->
name|tulip_boardsw
operator|->
name|bd_media_probe
call|)
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_ALTPHYS
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|tulip_flags
operator||=
name|TULIP_ALTPHYS
expr_stmt|;
block|}
name|sc
operator|->
name|tulip_flags
operator||=
name|TULIP_DEVICEPROBE
expr_stmt|;
name|tulip_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|tulip_flags
operator|&=
operator|~
name|TULIP_DEVICEPROBE
expr_stmt|;
name|ifp
operator|->
name|if_linkmib
operator|=
operator|&
name|sc
operator|->
name|tulip_dot3stats
expr_stmt|;
name|ifp
operator|->
name|if_linkmiblen
operator|=
sizeof|sizeof
name|sc
operator|->
name|tulip_dot3stats
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__bsdi__
argument_list|)
operator|&&
name|_BSDI_VERSION
operator|>=
literal|199510
name|sc
operator|->
name|tulip_pf
operator|=
name|printf
expr_stmt|;
name|ether_attach
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
else|#
directive|else
name|if_attach
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
operator|||
operator|(
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
operator|&&
name|BSD
operator|>=
literal|199506
operator|)
name|ether_ifattach
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
comment|/* __bsdi__ */
if|#
directive|if
name|NBPFILTER
operator|>
literal|0
name|TULIP_BPF_ATTACH
argument_list|(
name|sc
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|void
name|tulip_initcsrs
parameter_list|(
name|tulip_softc_t
modifier|*
specifier|const
name|sc
parameter_list|,
name|tulip_csrptr_t
name|csr_base
parameter_list|,
name|size_t
name|csr_size
parameter_list|)
block|{
name|sc
operator|->
name|tulip_csrs
operator|.
name|csr_busmode
operator|=
name|csr_base
operator|+
literal|0
operator|*
name|csr_size
expr_stmt|;
name|sc
operator|->
name|tulip_csrs
operator|.
name|csr_txpoll
operator|=
name|csr_base
operator|+
literal|1
operator|*
name|csr_size
expr_stmt|;
name|sc
operator|->
name|tulip_csrs
operator|.
name|csr_rxpoll
operator|=
name|csr_base
operator|+
literal|2
operator|*
name|csr_size
expr_stmt|;
name|sc
operator|->
name|tulip_csrs
operator|.
name|csr_rxlist
operator|=
name|csr_base
operator|+
literal|3
operator|*
name|csr_size
expr_stmt|;
name|sc
operator|->
name|tulip_csrs
operator|.
name|csr_txlist
operator|=
name|csr_base
operator|+
literal|4
operator|*
name|csr_size
expr_stmt|;
name|sc
operator|->
name|tulip_csrs
operator|.
name|csr_status
operator|=
name|csr_base
operator|+
literal|5
operator|*
name|csr_size
expr_stmt|;
name|sc
operator|->
name|tulip_csrs
operator|.
name|csr_command
operator|=
name|csr_base
operator|+
literal|6
operator|*
name|csr_size
expr_stmt|;
name|sc
operator|->
name|tulip_csrs
operator|.
name|csr_intr
operator|=
name|csr_base
operator|+
literal|7
operator|*
name|csr_size
expr_stmt|;
name|sc
operator|->
name|tulip_csrs
operator|.
name|csr_missed_frames
operator|=
name|csr_base
operator|+
literal|8
operator|*
name|csr_size
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|tulip_chipid
operator|==
name|TULIP_21040
condition|)
block|{
name|sc
operator|->
name|tulip_csrs
operator|.
name|csr_enetrom
operator|=
name|csr_base
operator|+
literal|9
operator|*
name|csr_size
expr_stmt|;
name|sc
operator|->
name|tulip_csrs
operator|.
name|csr_reserved
operator|=
name|csr_base
operator|+
literal|10
operator|*
name|csr_size
expr_stmt|;
name|sc
operator|->
name|tulip_csrs
operator|.
name|csr_full_duplex
operator|=
name|csr_base
operator|+
literal|11
operator|*
name|csr_size
expr_stmt|;
name|sc
operator|->
name|tulip_csrs
operator|.
name|csr_sia_status
operator|=
name|csr_base
operator|+
literal|12
operator|*
name|csr_size
expr_stmt|;
name|sc
operator|->
name|tulip_csrs
operator|.
name|csr_sia_connectivity
operator|=
name|csr_base
operator|+
literal|13
operator|*
name|csr_size
expr_stmt|;
name|sc
operator|->
name|tulip_csrs
operator|.
name|csr_sia_tx_rx
operator|=
name|csr_base
operator|+
literal|14
operator|*
name|csr_size
expr_stmt|;
name|sc
operator|->
name|tulip_csrs
operator|.
name|csr_sia_general
operator|=
name|csr_base
operator|+
literal|15
operator|*
name|csr_size
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|TULIP_EISA
argument_list|)
block|}
elseif|else
if|if
condition|(
name|sc
operator|->
name|tulip_chipid
operator|==
name|TULIP_DE425
condition|)
block|{
name|sc
operator|->
name|tulip_csrs
operator|.
name|csr_enetrom
operator|=
name|csr_base
operator|+
name|DE425_ENETROM_OFFSET
expr_stmt|;
name|sc
operator|->
name|tulip_csrs
operator|.
name|csr_reserved
operator|=
name|csr_base
operator|+
literal|10
operator|*
name|csr_size
expr_stmt|;
name|sc
operator|->
name|tulip_csrs
operator|.
name|csr_full_duplex
operator|=
name|csr_base
operator|+
literal|11
operator|*
name|csr_size
expr_stmt|;
name|sc
operator|->
name|tulip_csrs
operator|.
name|csr_sia_status
operator|=
name|csr_base
operator|+
literal|12
operator|*
name|csr_size
expr_stmt|;
name|sc
operator|->
name|tulip_csrs
operator|.
name|csr_sia_connectivity
operator|=
name|csr_base
operator|+
literal|13
operator|*
name|csr_size
expr_stmt|;
name|sc
operator|->
name|tulip_csrs
operator|.
name|csr_sia_tx_rx
operator|=
name|csr_base
operator|+
literal|14
operator|*
name|csr_size
expr_stmt|;
name|sc
operator|->
name|tulip_csrs
operator|.
name|csr_sia_general
operator|=
name|csr_base
operator|+
literal|15
operator|*
name|csr_size
expr_stmt|;
endif|#
directive|endif
comment|/* TULIP_EISA */
block|}
elseif|else
if|if
condition|(
name|sc
operator|->
name|tulip_chipid
operator|==
name|TULIP_21140
operator|||
name|sc
operator|->
name|tulip_chipid
operator|==
name|TULIP_21140A
condition|)
block|{
name|sc
operator|->
name|tulip_csrs
operator|.
name|csr_srom_mii
operator|=
name|csr_base
operator|+
literal|9
operator|*
name|csr_size
expr_stmt|;
name|sc
operator|->
name|tulip_csrs
operator|.
name|csr_gp_timer
operator|=
name|csr_base
operator|+
literal|11
operator|*
name|csr_size
expr_stmt|;
name|sc
operator|->
name|tulip_csrs
operator|.
name|csr_gp
operator|=
name|csr_base
operator|+
literal|12
operator|*
name|csr_size
expr_stmt|;
name|sc
operator|->
name|tulip_csrs
operator|.
name|csr_watchdog
operator|=
name|csr_base
operator|+
literal|15
operator|*
name|csr_size
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sc
operator|->
name|tulip_chipid
operator|==
name|TULIP_21041
condition|)
block|{
name|sc
operator|->
name|tulip_csrs
operator|.
name|csr_srom_mii
operator|=
name|csr_base
operator|+
literal|9
operator|*
name|csr_size
expr_stmt|;
name|sc
operator|->
name|tulip_csrs
operator|.
name|csr_bootrom
operator|=
name|csr_base
operator|+
literal|10
operator|*
name|csr_size
expr_stmt|;
name|sc
operator|->
name|tulip_csrs
operator|.
name|csr_gp_timer
operator|=
name|csr_base
operator|+
literal|11
operator|*
name|csr_size
expr_stmt|;
name|sc
operator|->
name|tulip_csrs
operator|.
name|csr_sia_status
operator|=
name|csr_base
operator|+
literal|12
operator|*
name|csr_size
expr_stmt|;
name|sc
operator|->
name|tulip_csrs
operator|.
name|csr_sia_connectivity
operator|=
name|csr_base
operator|+
literal|13
operator|*
name|csr_size
expr_stmt|;
name|sc
operator|->
name|tulip_csrs
operator|.
name|csr_sia_tx_rx
operator|=
name|csr_base
operator|+
literal|14
operator|*
name|csr_size
expr_stmt|;
name|sc
operator|->
name|tulip_csrs
operator|.
name|csr_sia_general
operator|=
name|csr_base
operator|+
literal|15
operator|*
name|csr_size
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|void
name|tulip_initring
parameter_list|(
name|tulip_softc_t
modifier|*
specifier|const
name|sc
parameter_list|,
name|tulip_ringinfo_t
modifier|*
specifier|const
name|ri
parameter_list|,
name|tulip_desc_t
modifier|*
name|descs
parameter_list|,
name|int
name|ndescs
parameter_list|)
block|{
name|ri
operator|->
name|ri_max
operator|=
name|ndescs
expr_stmt|;
name|ri
operator|->
name|ri_first
operator|=
name|descs
expr_stmt|;
name|ri
operator|->
name|ri_last
operator|=
name|ri
operator|->
name|ri_first
operator|+
name|ri
operator|->
name|ri_max
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
name|ri
operator|->
name|ri_first
argument_list|,
sizeof|sizeof
argument_list|(
name|ri
operator|->
name|ri_first
index|[
literal|0
index|]
argument_list|)
operator|*
name|ri
operator|->
name|ri_max
argument_list|)
expr_stmt|;
name|ri
operator|->
name|ri_last
index|[
operator|-
literal|1
index|]
operator|.
name|d_flag
operator|=
name|TULIP_DFLAG_ENDRING
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  * This is the PCI configuration support.  Since the 21040 is available  * on both EISA and PCI boards, one must be careful in how defines the  * 21040 in the config file.  */
end_comment

begin_define
define|#
directive|define
name|PCI_CFID
value|0x00
end_define

begin_comment
comment|/* Configuration ID */
end_comment

begin_define
define|#
directive|define
name|PCI_CFCS
value|0x04
end_define

begin_comment
comment|/* Configurtion Command/Status */
end_comment

begin_define
define|#
directive|define
name|PCI_CFRV
value|0x08
end_define

begin_comment
comment|/* Configuration Revision */
end_comment

begin_define
define|#
directive|define
name|PCI_CFLT
value|0x0c
end_define

begin_comment
comment|/* Configuration Latency Timer */
end_comment

begin_define
define|#
directive|define
name|PCI_CBIO
value|0x10
end_define

begin_comment
comment|/* Configuration Base IO Address */
end_comment

begin_define
define|#
directive|define
name|PCI_CBMA
value|0x14
end_define

begin_comment
comment|/* Configuration Base Memory Address */
end_comment

begin_define
define|#
directive|define
name|PCI_CFIT
value|0x3c
end_define

begin_comment
comment|/* Configuration Interrupt */
end_comment

begin_define
define|#
directive|define
name|PCI_CFDA
value|0x40
end_define

begin_comment
comment|/* Configuration Driver Area */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|TULIP_EISA
argument_list|)
end_if

begin_decl_stmt
specifier|static
specifier|const
name|int
name|tulip_eisa_irqs
index|[
literal|4
index|]
init|=
block|{
name|IRQ5
block|,
name|IRQ9
block|,
name|IRQ10
block|,
name|IRQ11
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
end_if

begin_define
define|#
directive|define
name|TULIP_PCI_ATTACH_ARGS
value|pcici_t config_id, int unit
end_define

begin_function
specifier|static
name|void
name|tulip_shutdown
parameter_list|(
name|int
name|howto
parameter_list|,
name|void
modifier|*
name|sc
parameter_list|)
block|{
name|TULIP_CSR_WRITE
argument_list|(
operator|(
name|tulip_softc_t
operator|*
operator|)
name|sc
argument_list|,
name|csr_busmode
argument_list|,
name|TULIP_BUSMODE_SWRESET
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
comment|/* Wait 10 microseconds (actually 50 PCI cycles but at  		   33MHz that comes to two microseconds but wait a 		   bit longer anyways) */
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|tulip_pci_probe
parameter_list|(
name|pcici_t
name|config_id
parameter_list|,
name|pcidi_t
name|device_id
parameter_list|)
block|{
if|if
condition|(
name|PCI_VENDORID
argument_list|(
name|device_id
argument_list|)
operator|!=
name|DEC_VENDORID
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|PCI_CHIPID
argument_list|(
name|device_id
argument_list|)
operator|==
name|CHIPID_21040
condition|)
return|return
literal|"Digital 21040 Ethernet"
return|;
if|if
condition|(
name|PCI_CHIPID
argument_list|(
name|device_id
argument_list|)
operator|==
name|CHIPID_21041
condition|)
return|return
literal|"Digital 21041 Ethernet"
return|;
if|if
condition|(
name|PCI_CHIPID
argument_list|(
name|device_id
argument_list|)
operator|==
name|CHIPID_21140
condition|)
block|{
name|u_int32_t
name|revinfo
init|=
name|pci_conf_read
argument_list|(
name|config_id
argument_list|,
name|PCI_CFRV
argument_list|)
operator|&
literal|0xFF
decl_stmt|;
if|if
condition|(
name|revinfo
operator|>=
literal|0x20
condition|)
return|return
literal|"Digital 21140A Fast Ethernet"
return|;
else|else
return|return
literal|"Digital 21140 Fast Ethernet"
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function_decl
specifier|static
name|void
name|tulip_pci_attach
parameter_list|(
name|TULIP_PCI_ATTACH_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|u_long
name|tulip_pci_count
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|pci_device
name|dedevice
init|=
block|{
literal|"de"
block|,
name|tulip_pci_probe
block|,
name|tulip_pci_attach
block|,
operator|&
name|tulip_pci_count
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DATA_SET
argument_list|(
name|pcidevice_set
argument_list|,
name|dedevice
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __FreeBSD__ */
end_comment

begin_escape
end_escape

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__bsdi__
argument_list|)
end_if

begin_define
define|#
directive|define
name|TULIP_PCI_ATTACH_ARGS
value|struct device * const parent, struct device * const self, void * const aux
end_define

begin_function
specifier|static
name|void
name|tulip_shutdown
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|tulip_softc_t
modifier|*
specifier|const
name|sc
init|=
operator|(
name|tulip_softc_t
operator|*
operator|)
name|arg
decl_stmt|;
name|TULIP_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_busmode
argument_list|,
name|TULIP_BUSMODE_SWRESET
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
comment|/* Wait 10 microseconds (actually 50 PCI cycles but at  			   33MHz that comes to two microseconds but wait a 			   bit longer anyways) */
block|}
end_function

begin_function
specifier|static
name|int
name|tulip_pci_match
parameter_list|(
name|pci_devaddr_t
modifier|*
name|pa
parameter_list|)
block|{
name|int
name|irq
decl_stmt|;
name|unsigned
name|id
decl_stmt|;
name|id
operator|=
name|pci_inl
argument_list|(
name|pa
argument_list|,
name|PCI_VENDOR_ID
argument_list|)
expr_stmt|;
if|if
condition|(
name|PCI_VENDORID
argument_list|(
name|id
argument_list|)
operator|!=
name|DEC_VENDORID
condition|)
return|return
literal|0
return|;
name|id
operator|=
name|PCI_CHIPID
argument_list|(
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
name|id
operator|!=
name|CHIPID_21040
operator|&&
name|id
operator|!=
name|CHIPID_21041
operator|&&
name|id
operator|!=
name|CHIPID_21140
condition|)
return|return
literal|0
return|;
name|irq
operator|=
name|pci_inl
argument_list|(
name|pa
argument_list|,
name|PCI_I_LINE
argument_list|)
operator|&
literal|0xFF
expr_stmt|;
if|if
condition|(
name|irq
operator|==
literal|0
operator|||
name|irq
operator|>=
literal|16
condition|)
block|{
name|printf
argument_list|(
literal|"de?: invalid IRQ %d; skipping\n"
argument_list|,
name|irq
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|tulip_probe
parameter_list|(
name|struct
name|device
modifier|*
name|parent
parameter_list|,
name|struct
name|cfdata
modifier|*
name|cf
parameter_list|,
name|void
modifier|*
name|aux
parameter_list|)
block|{
name|struct
name|isa_attach_args
modifier|*
specifier|const
name|ia
init|=
operator|(
expr|struct
name|isa_attach_args
operator|*
operator|)
name|aux
decl_stmt|;
name|unsigned
name|irq
decl_stmt|,
name|slot
decl_stmt|;
name|pci_devaddr_t
modifier|*
name|pa
decl_stmt|;
if|#
directive|if
name|_BSDI_VERSION
operator|>=
literal|199401
switch|switch
condition|(
name|ia
operator|->
name|ia_bustype
condition|)
block|{
case|case
name|BUS_PCI
case|:
endif|#
directive|endif
name|pa
operator|=
name|pci_scan
argument_list|(
name|tulip_pci_match
argument_list|)
expr_stmt|;
if|if
condition|(
name|pa
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|irq
operator|=
operator|(
literal|1
operator|<<
operator|(
name|pci_inl
argument_list|(
name|pa
argument_list|,
name|PCI_I_LINE
argument_list|)
operator|&
literal|0xFF
operator|)
operator|)
expr_stmt|;
comment|/* Get the base address; assume the BIOS set it up correctly */
if|#
directive|if
name|defined
argument_list|(
name|TULIP_IOMAPPED
argument_list|)
name|ia
operator|->
name|ia_maddr
operator|=
name|NULL
expr_stmt|;
name|ia
operator|->
name|ia_msize
operator|=
literal|0
expr_stmt|;
name|ia
operator|->
name|ia_iobase
operator|=
name|pci_inl
argument_list|(
name|pa
argument_list|,
name|PCI_CBIO
argument_list|)
operator|&
operator|~
literal|7
expr_stmt|;
name|pci_outl
argument_list|(
name|pa
argument_list|,
name|PCI_CBIO
argument_list|,
literal|0xFFFFFFFF
argument_list|)
expr_stmt|;
name|ia
operator|->
name|ia_iosize
operator|=
operator|(
operator|(
operator|~
name|pci_inl
argument_list|(
name|pa
argument_list|,
name|PCI_CBIO
argument_list|)
operator|)
operator||
literal|7
operator|)
operator|+
literal|1
expr_stmt|;
name|pci_outl
argument_list|(
name|pa
argument_list|,
name|PCI_CBIO
argument_list|,
operator|(
name|int
operator|)
name|ia
operator|->
name|ia_iobase
argument_list|)
expr_stmt|;
comment|/* Disable memory space access */
name|pci_outl
argument_list|(
name|pa
argument_list|,
name|PCI_COMMAND
argument_list|,
name|pci_inl
argument_list|(
name|pa
argument_list|,
name|PCI_COMMAND
argument_list|)
operator|&
operator|~
literal|2
argument_list|)
expr_stmt|;
else|#
directive|else
name|ia
operator|->
name|ia_maddr
operator|=
call|(
name|caddr_t
call|)
argument_list|(
name|pci_inl
argument_list|(
name|pa
argument_list|,
name|PCI_CBMA
argument_list|)
operator|&
operator|~
literal|7
argument_list|)
expr_stmt|;
name|pci_outl
argument_list|(
name|pa
argument_list|,
name|PCI_CBMA
argument_list|,
literal|0xFFFFFFFF
argument_list|)
expr_stmt|;
name|ia
operator|->
name|ia_msize
operator|=
operator|(
operator|(
operator|~
name|pci_inl
argument_list|(
name|pa
argument_list|,
name|PCI_CBMA
argument_list|)
operator|)
operator||
literal|7
operator|)
operator|+
literal|1
expr_stmt|;
name|pci_outl
argument_list|(
name|pa
argument_list|,
name|PCI_CBMA
argument_list|,
operator|(
name|int
operator|)
name|ia
operator|->
name|ia_maddr
argument_list|)
expr_stmt|;
name|ia
operator|->
name|ia_iobase
operator|=
literal|0
expr_stmt|;
name|ia
operator|->
name|ia_iosize
operator|=
literal|0
expr_stmt|;
comment|/* Disable I/O space access */
name|pci_outl
argument_list|(
name|pa
argument_list|,
name|PCI_COMMAND
argument_list|,
name|pci_inl
argument_list|(
name|pa
argument_list|,
name|PCI_COMMAND
argument_list|)
operator|&
operator|~
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* TULIP_IOMAPPED */
name|ia
operator|->
name|ia_aux
operator|=
operator|(
name|void
operator|*
operator|)
name|pa
expr_stmt|;
if|#
directive|if
name|_BSDI_VERSION
operator|>=
literal|199401
break|break;
if|#
directive|if
name|defined
argument_list|(
name|TULIP_EISA
argument_list|)
case|case
name|BUS_EISA
case|:
block|{
name|unsigned
name|tmp
decl_stmt|;
if|if
condition|(
operator|(
name|slot
operator|=
name|eisa_match
argument_list|(
name|cf
argument_list|,
name|ia
argument_list|)
operator|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|ia
operator|->
name|ia_iobase
operator|=
name|slot
operator|<<
literal|12
expr_stmt|;
name|ia
operator|->
name|ia_iosize
operator|=
name|EISA_NPORT
expr_stmt|;
name|eisa_slotalloc
argument_list|(
name|slot
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|inb
argument_list|(
name|ia
operator|->
name|ia_iobase
operator|+
name|DE425_CFG0
argument_list|)
expr_stmt|;
name|irq
operator|=
name|tulip_eisa_irqs
index|[
operator|(
name|tmp
operator|>>
literal|1
operator|)
operator|&
literal|0x03
index|]
expr_stmt|;
comment|/* 	 * Until BSD/OS likes level interrupts, force 	 * the DE425 into edge-triggered mode. 	 */
if|if
condition|(
operator|(
name|tmp
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
name|outb
argument_list|(
name|ia
operator|->
name|ia_iobase
operator|+
name|DE425_CFG0
argument_list|,
name|tmp
operator||
literal|1
argument_list|)
expr_stmt|;
comment|/* 	 * CBIO needs to map to the EISA slot 	 * enable I/O access and Master 	 */
name|outl
argument_list|(
name|ia
operator|->
name|ia_iobase
operator|+
name|DE425_CBIO
argument_list|,
name|ia
operator|->
name|ia_iobase
argument_list|)
expr_stmt|;
name|outl
argument_list|(
name|ia
operator|->
name|ia_iobase
operator|+
name|DE425_CFCS
argument_list|,
literal|5
operator||
name|inl
argument_list|(
name|ia
operator|->
name|ia_iobase
operator|+
name|DE425_CFCS
argument_list|)
argument_list|)
expr_stmt|;
name|ia
operator|->
name|ia_aux
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
comment|/* TULIP_EISA */
default|default:
return|return
literal|0
return|;
block|}
endif|#
directive|endif
comment|/* PCI bus masters don't use host DMA channels */
name|ia
operator|->
name|ia_drq
operator|=
name|DRQNONE
expr_stmt|;
if|if
condition|(
name|ia
operator|->
name|ia_irq
operator|!=
name|IRQUNK
operator|&&
name|irq
operator|!=
name|ia
operator|->
name|ia_irq
condition|)
block|{
name|printf
argument_list|(
literal|"de%d: error: desired IRQ of %d does not match device's "
literal|"actual IRQ of %d,\n"
argument_list|,
name|cf
operator|->
name|cf_unit
argument_list|,
name|ffs
argument_list|(
name|ia
operator|->
name|ia_irq
argument_list|)
operator|-
literal|1
argument_list|,
name|ffs
argument_list|(
name|irq
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|ia
operator|->
name|ia_irq
operator|==
name|IRQUNK
condition|)
name|ia
operator|->
name|ia_irq
operator|=
name|irq
expr_stmt|;
ifdef|#
directive|ifdef
name|IRQSHARE
name|ia
operator|->
name|ia_irq
operator||=
name|IRQSHARE
expr_stmt|;
endif|#
directive|endif
return|return
literal|1
return|;
block|}
end_function

begin_function_decl
specifier|static
name|void
name|tulip_pci_attach
parameter_list|(
name|TULIP_PCI_ATTACH_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_if
if|#
directive|if
name|defined
argument_list|(
name|TULIP_EISA
argument_list|)
end_if

begin_decl_stmt
specifier|static
name|char
modifier|*
name|tulip_eisa_ids
index|[]
init|=
block|{
literal|"DEC4250"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|struct
name|cfdriver
name|decd
init|=
block|{
literal|0
block|,
literal|"de"
block|,
name|tulip_probe
block|,
name|tulip_pci_attach
block|,
if|#
directive|if
name|_BSDI_VERSION
operator|>=
literal|199401
name|DV_IFNET
block|,
endif|#
directive|endif
sizeof|sizeof
argument_list|(
name|tulip_softc_t
argument_list|)
block|,
if|#
directive|if
name|defined
argument_list|(
name|TULIP_EISA
argument_list|)
name|tulip_eisa_ids
endif|#
directive|endif
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __bsdi__ */
end_comment

begin_escape
end_escape

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
end_if

begin_define
define|#
directive|define
name|TULIP_PCI_ATTACH_ARGS
value|struct device * const parent, struct device * const self, void * const aux
end_define

begin_function
specifier|static
name|void
name|tulip_pci_shutdown
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|tulip_softc_t
modifier|*
specifier|const
name|sc
init|=
operator|(
name|tulip_softc_t
operator|*
operator|)
name|arg
decl_stmt|;
name|TULIP_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_busmode
argument_list|,
name|TULIP_BUSMODE_SWRESET
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
comment|/* Wait 10 microseconds (actually 50 PCI cycles but at  			   33MHz that comes to two microseconds but wait a 			   bit longer anyways) */
block|}
end_function

begin_function
specifier|static
name|int
name|tulip_pci_probe
parameter_list|(
name|struct
name|device
modifier|*
name|parent
parameter_list|,
name|void
modifier|*
name|match
parameter_list|,
name|void
modifier|*
name|aux
parameter_list|)
block|{
name|struct
name|pci_attach_args
modifier|*
name|pa
init|=
operator|(
expr|struct
name|pci_attach_args
operator|*
operator|)
name|aux
decl_stmt|;
if|if
condition|(
name|PCI_VENDORID
argument_list|(
name|pa
operator|->
name|pa_id
argument_list|)
operator|!=
name|DEC_VENDORID
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|PCI_CHIPID
argument_list|(
name|pa
operator|->
name|pa_id
argument_list|)
operator|==
name|CHIPID_21040
operator|||
name|PCI_CHIPID
argument_list|(
name|pa
operator|->
name|pa_id
argument_list|)
operator|==
name|CHIPID_21041
operator|||
name|PCI_CHIPID
argument_list|(
name|pa
operator|->
name|pa_id
argument_list|)
operator|==
name|CHIPID_21140
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function_decl
specifier|static
name|void
name|tulip_pci_attach
parameter_list|(
name|TULIP_PCI_ATTACH_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|struct
name|cfattach
name|de_ca
init|=
block|{
sizeof|sizeof
argument_list|(
name|tulip_softc_t
argument_list|)
block|,
name|tulip_pci_probe
block|,
name|tulip_pci_attach
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|cfdriver
name|de_cd
init|=
block|{
literal|0
block|,
literal|"de"
block|,
name|DV_IFNET
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __NetBSD__ */
end_comment

begin_escape
end_escape

begin_function
specifier|static
name|void
name|tulip_pci_attach
parameter_list|(
name|TULIP_PCI_ATTACH_ARGS
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
name|tulip_softc_t
modifier|*
name|sc
decl_stmt|;
define|#
directive|define
name|PCI_CONF_WRITE
parameter_list|(
name|r
parameter_list|,
name|v
parameter_list|)
value|pci_conf_write(config_id, (r), (v))
define|#
directive|define
name|PCI_CONF_READ
parameter_list|(
name|r
parameter_list|)
value|pci_conf_read(config_id, (r))
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|__bsdi__
argument_list|)
name|tulip_softc_t
modifier|*
specifier|const
name|sc
init|=
operator|(
name|tulip_softc_t
operator|*
operator|)
name|self
decl_stmt|;
name|struct
name|isa_attach_args
modifier|*
specifier|const
name|ia
init|=
operator|(
expr|struct
name|isa_attach_args
operator|*
operator|)
name|aux
decl_stmt|;
name|pci_devaddr_t
modifier|*
name|pa
init|=
operator|(
name|pci_devaddr_t
operator|*
operator|)
name|ia
operator|->
name|ia_aux
decl_stmt|;
specifier|const
name|int
name|unit
init|=
name|sc
operator|->
name|tulip_dev
operator|.
name|dv_unit
decl_stmt|;
define|#
directive|define
name|PCI_CONF_WRITE
parameter_list|(
name|r
parameter_list|,
name|v
parameter_list|)
value|pci_outl(pa, (r), (v))
define|#
directive|define
name|PCI_CONF_READ
parameter_list|(
name|r
parameter_list|)
value|pci_inl(pa, (r))
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
name|tulip_softc_t
modifier|*
specifier|const
name|sc
init|=
operator|(
name|tulip_softc_t
operator|*
operator|)
name|self
decl_stmt|;
name|struct
name|pci_attach_args
modifier|*
specifier|const
name|pa
init|=
operator|(
expr|struct
name|pci_attach_args
operator|*
operator|)
name|aux
decl_stmt|;
specifier|const
name|int
name|unit
init|=
name|sc
operator|->
name|tulip_dev
operator|.
name|dv_unit
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|TULIP_IOMAPPED
argument_list|)
name|bus_io_addr_t
name|iobase
decl_stmt|;
name|bus_io_size_t
name|iosize
decl_stmt|;
else|#
directive|else
name|bus_mem_addr_t
name|membase
decl_stmt|;
name|bus_mem_size_t
name|memsize
decl_stmt|;
endif|#
directive|endif
define|#
directive|define
name|PCI_CONF_WRITE
parameter_list|(
name|r
parameter_list|,
name|v
parameter_list|)
value|pci_conf_write(pa->pa_pc, pa->pa_tag, (r), (v))
define|#
directive|define
name|PCI_CONF_READ
parameter_list|(
name|r
parameter_list|)
value|pci_conf_read(pa->pa_pc, pa->pa_tag, (r))
endif|#
directive|endif
comment|/* __NetBSD__ */
name|int
name|retval
decl_stmt|,
name|idx
decl_stmt|;
name|u_int32_t
name|revinfo
decl_stmt|,
name|cfdainfo
decl_stmt|,
name|id
decl_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|TULIP_IOMAPPED
argument_list|)
operator|&&
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
name|vm_offset_t
name|pa_csrs
decl_stmt|;
endif|#
directive|endif
name|unsigned
name|csroffset
init|=
name|TULIP_PCI_CSROFFSET
decl_stmt|;
name|unsigned
name|csrsize
init|=
name|TULIP_PCI_CSRSIZE
decl_stmt|;
name|tulip_csrptr_t
name|csr_base
decl_stmt|;
name|tulip_chipid_t
name|chipid
init|=
name|TULIP_CHIPID_UNKNOWN
decl_stmt|;
if|if
condition|(
name|unit
operator|>=
name|TULIP_MAX_DEVICES
condition|)
block|{
ifdef|#
directive|ifdef
name|__FreeBSD__
name|printf
argument_list|(
literal|"de%d"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|printf
argument_list|(
literal|": not configured; limit of %d reached or exceeded\n"
argument_list|,
name|TULIP_MAX_DEVICES
argument_list|)
expr_stmt|;
return|return;
block|}
if|#
directive|if
name|defined
argument_list|(
name|__bsdi__
argument_list|)
if|if
condition|(
name|pa
operator|!=
name|NULL
condition|)
block|{
name|revinfo
operator|=
name|pci_inl
argument_list|(
name|pa
argument_list|,
name|PCI_CFRV
argument_list|)
operator|&
literal|0xFF
expr_stmt|;
name|id
operator|=
name|pci_inl
argument_list|(
name|pa
argument_list|,
name|PCI_CFID
argument_list|)
expr_stmt|;
name|cfdainfo
operator|=
name|pci_inl
argument_list|(
name|pa
argument_list|,
name|PCI_CFDA
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|TULIP_EISA
argument_list|)
block|}
else|else
block|{
name|revinfo
operator|=
name|inl
argument_list|(
name|ia
operator|->
name|ia_iobase
operator|+
name|DE425_CFRV
argument_list|)
operator|&
literal|0xFF
expr_stmt|;
name|csroffset
operator|=
name|TULIP_EISA_CSROFFSET
expr_stmt|;
name|csrsize
operator|=
name|TULIP_EISA_CSRSIZE
expr_stmt|;
name|chipid
operator|=
name|TULIP_DE425
expr_stmt|;
name|cfdainfo
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
block|}
else|#
directive|else
comment|/* __bsdi__ */
name|revinfo
operator|=
name|PCI_CONF_READ
argument_list|(
name|PCI_CFRV
argument_list|)
operator|&
literal|0xFF
expr_stmt|;
name|id
operator|=
name|PCI_CONF_READ
argument_list|(
name|PCI_CFID
argument_list|)
expr_stmt|;
name|cfdainfo
operator|=
name|PCI_CONF_READ
argument_list|(
name|PCI_CFDA
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|PCI_VENDORID
argument_list|(
name|id
argument_list|)
operator|==
name|DEC_VENDORID
condition|)
block|{
if|if
condition|(
name|PCI_CHIPID
argument_list|(
name|id
argument_list|)
operator|==
name|CHIPID_21040
condition|)
name|chipid
operator|=
name|TULIP_21040
expr_stmt|;
elseif|else
if|if
condition|(
name|PCI_CHIPID
argument_list|(
name|id
argument_list|)
operator|==
name|CHIPID_21140
condition|)
block|{
name|chipid
operator|=
operator|(
name|revinfo
operator|>=
literal|0x20
operator|)
condition|?
name|TULIP_21140A
else|:
name|TULIP_21140
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|PCI_CHIPID
argument_list|(
name|id
argument_list|)
operator|==
name|CHIPID_21041
condition|)
name|chipid
operator|=
name|TULIP_21041
expr_stmt|;
block|}
if|if
condition|(
name|chipid
operator|==
name|TULIP_CHIPID_UNKNOWN
condition|)
return|return;
if|if
condition|(
operator|(
name|chipid
operator|==
name|TULIP_21040
operator|||
name|chipid
operator|==
name|TULIP_DE425
operator|)
operator|&&
name|revinfo
operator|<
literal|0x20
condition|)
block|{
ifdef|#
directive|ifdef
name|__FreeBSD__
name|printf
argument_list|(
literal|"de%d"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|printf
argument_list|(
literal|": not configured; 21040 pass 2.0 required (%d.%d found)\n"
argument_list|,
name|revinfo
operator|>>
literal|4
argument_list|,
name|revinfo
operator|&
literal|0x0f
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|chipid
operator|==
name|TULIP_21140
operator|&&
name|revinfo
operator|<
literal|0x11
condition|)
block|{
ifndef|#
directive|ifndef
name|__FreeBSD__
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|printf
argument_list|(
literal|"de%d: not configured; 21140 pass 1.1 required (%d.%d found)\n"
argument_list|,
name|unit
argument_list|,
name|revinfo
operator|>>
literal|4
argument_list|,
name|revinfo
operator|&
literal|0x0f
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|chipid
operator|==
name|TULIP_21041
operator|||
name|chipid
operator|==
name|TULIP_21140A
operator|)
operator|&&
operator|(
name|cfdainfo
operator|&
operator|(
name|TULIP_CFDA_SLEEP
operator||
name|TULIP_CFDA_SNOOZE
operator|)
operator|)
condition|)
block|{
name|cfdainfo
operator|&=
operator|~
operator|(
name|TULIP_CFDA_SLEEP
operator||
name|TULIP_CFDA_SNOOZE
operator|)
expr_stmt|;
name|PCI_CONF_WRITE
argument_list|(
name|PCI_CFDA
argument_list|,
name|cfdainfo
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"de%d: waking device from sleep/snooze mode\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|11
operator|*
literal|1000
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
name|sc
operator|=
operator|(
name|tulip_softc_t
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|sc
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
return|return;
name|bzero
argument_list|(
name|sc
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sc
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Zero out the softc*/
endif|#
directive|endif
name|sc
operator|->
name|tulip_chipid
operator|=
name|chipid
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
name|bcopy
argument_list|(
name|self
operator|->
name|dv_xname
argument_list|,
name|sc
operator|->
name|tulip_if
operator|.
name|if_xname
argument_list|,
name|IFNAMSIZ
argument_list|)
expr_stmt|;
name|sc
operator|->
name|tulip_if
operator|.
name|if_softc
operator|=
name|sc
expr_stmt|;
name|sc
operator|->
name|tulip_bc
operator|=
name|pa
operator|->
name|pa_bc
expr_stmt|;
name|sc
operator|->
name|tulip_pc
operator|=
name|pa
operator|->
name|pa_pc
expr_stmt|;
else|#
directive|else
name|sc
operator|->
name|tulip_unit
operator|=
name|unit
expr_stmt|;
name|sc
operator|->
name|tulip_name
operator|=
literal|"de"
expr_stmt|;
endif|#
directive|endif
name|sc
operator|->
name|tulip_revinfo
operator|=
name|revinfo
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
if|#
directive|if
name|BSD
operator|>=
literal|199506
name|sc
operator|->
name|tulip_if
operator|.
name|if_softc
operator|=
name|sc
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|TULIP_IOMAPPED
argument_list|)
name|retval
operator|=
name|pci_map_port
argument_list|(
name|config_id
argument_list|,
name|PCI_CBIO
argument_list|,
operator|&
name|csr_base
argument_list|)
expr_stmt|;
else|#
directive|else
name|retval
operator|=
name|pci_map_mem
argument_list|(
name|config_id
argument_list|,
name|PCI_CBMA
argument_list|,
operator|(
name|vm_offset_t
operator|*
operator|)
operator|&
name|csr_base
argument_list|,
operator|&
name|pa_csrs
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|retval
condition|)
block|{
name|free
argument_list|(
operator|(
name|caddr_t
operator|)
name|sc
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return;
block|}
name|tulips
index|[
name|unit
index|]
operator|=
name|sc
expr_stmt|;
endif|#
directive|endif
comment|/* __FreeBSD__ */
if|#
directive|if
name|defined
argument_list|(
name|__bsdi__
argument_list|)
if|#
directive|if
name|defined
argument_list|(
name|TULIP_IOMAPPED
argument_list|)
name|csr_base
operator|=
name|ia
operator|->
name|ia_iobase
expr_stmt|;
else|#
directive|else
name|csr_base
operator|=
operator|(
name|vm_offset_t
operator|)
name|mapphys
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|ia
operator|->
name|ia_maddr
argument_list|,
name|ia
operator|->
name|ia_msize
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
comment|/* __bsdi__ */
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
name|csr_base
operator|=
literal|0
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|TULIP_IOMAPPED
argument_list|)
if|if
condition|(
name|pci_io_find
argument_list|(
name|pa
operator|->
name|pa_pc
argument_list|,
name|pa
operator|->
name|pa_tag
argument_list|,
name|PCI_CBIO
argument_list|,
operator|&
name|iobase
argument_list|,
operator|&
name|iosize
argument_list|)
operator|||
name|bus_io_map
argument_list|(
name|pa
operator|->
name|pa_bc
argument_list|,
name|iobase
argument_list|,
name|iosize
argument_list|,
operator|&
name|sc
operator|->
name|tulip_ioh
argument_list|)
condition|)
return|return;
else|#
directive|else
if|if
condition|(
name|pci_mem_find
argument_list|(
name|pa
operator|->
name|pa_pc
argument_list|,
name|pa
operator|->
name|pa_tag
argument_list|,
name|PCI_CBMA
argument_list|,
operator|&
name|membase
argument_list|,
operator|&
name|memsize
argument_list|,
name|NULL
argument_list|)
operator|||
name|bus_mem_map
argument_list|(
name|pa
operator|->
name|pa_bc
argument_list|,
name|membase
argument_list|,
name|memsize
argument_list|,
literal|0
argument_list|,
operator|&
name|sc
operator|->
name|tulip_memh
argument_list|)
condition|)
return|return;
endif|#
directive|endif
endif|#
directive|endif
comment|/* __NetBSD__ */
name|tulip_initcsrs
argument_list|(
name|sc
argument_list|,
name|csr_base
operator|+
name|csroffset
argument_list|,
name|csrsize
argument_list|)
expr_stmt|;
name|tulip_initring
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|tulip_rxinfo
argument_list|,
name|sc
operator|->
name|tulip_rxdescs
argument_list|,
name|TULIP_RXDESCS
argument_list|)
expr_stmt|;
name|tulip_initring
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|tulip_txinfo
argument_list|,
name|sc
operator|->
name|tulip_txdescs
argument_list|,
name|TULIP_TXDESCS
argument_list|)
expr_stmt|;
comment|/*      * Make sure there won't be any interrupts or such...      */
name|TULIP_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_busmode
argument_list|,
name|TULIP_BUSMODE_SWRESET
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
comment|/* Wait 10 microseconds (actually 50 PCI cycles but at  		   33MHz that comes to two microseconds but wait a 		   bit longer anyways) */
if|if
condition|(
operator|(
name|retval
operator|=
name|tulip_read_macaddr
argument_list|(
name|sc
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|__FreeBSD__
name|printf
argument_list|(
name|TULIP_PRINTF_FMT
argument_list|,
name|TULIP_PRINTF_ARGS
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|printf
argument_list|(
literal|": can't read ENET ROM (why=%d) ("
argument_list|,
name|retval
argument_list|)
expr_stmt|;
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
literal|32
condition|;
name|idx
operator|++
control|)
name|printf
argument_list|(
literal|"%02x"
argument_list|,
name|sc
operator|->
name|tulip_rombuf
index|[
name|idx
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|TULIP_PRINTF_FMT
literal|": %s%s pass %d.%d\n"
argument_list|,
name|TULIP_PRINTF_ARGS
argument_list|,
operator|(
name|sc
operator|->
name|tulip_boardid
operator|!=
name|NULL
condition|?
name|sc
operator|->
name|tulip_boardid
else|:
literal|""
operator|)
argument_list|,
name|tulip_chipdescs
index|[
name|sc
operator|->
name|tulip_chipid
index|]
argument_list|,
operator|(
name|sc
operator|->
name|tulip_revinfo
operator|&
literal|0xF0
operator|)
operator|>>
literal|4
argument_list|,
name|sc
operator|->
name|tulip_revinfo
operator|&
literal|0x0F
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|TULIP_PRINTF_FMT
literal|": address unknown\n"
argument_list|,
name|TULIP_PRINTF_ARGS
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|s
decl_stmt|;
name|tulip_intrfunc_t
function_decl|(
modifier|*
name|intr_rtn
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|)
init|=
name|tulip_intr_normal
function_decl|;
if|if
condition|(
name|sc
operator|->
name|tulip_flags
operator|&
name|TULIP_SHAREDINTR
condition|)
name|intr_rtn
operator|=
name|tulip_intr_shared
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
if|if
condition|(
operator|(
name|sc
operator|->
name|tulip_flags
operator|&
name|TULIP_SLAVEDINTR
operator|)
operator|==
literal|0
condition|)
block|{
name|pci_intr_handle_t
name|intrhandle
decl_stmt|;
specifier|const
name|char
modifier|*
name|intrstr
decl_stmt|;
if|if
condition|(
name|pci_intr_map
argument_list|(
name|pa
operator|->
name|pa_pc
argument_list|,
name|pa
operator|->
name|pa_intrtag
argument_list|,
name|pa
operator|->
name|pa_intrpin
argument_list|,
name|pa
operator|->
name|pa_intrline
argument_list|,
operator|&
name|intrhandle
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|": couldn't map interrupt\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|intrstr
operator|=
name|pci_intr_string
argument_list|(
name|pa
operator|->
name|pa_pc
argument_list|,
name|intrhandle
argument_list|)
expr_stmt|;
name|sc
operator|->
name|tulip_ih
operator|=
name|pci_intr_establish
argument_list|(
name|pa
operator|->
name|pa_pc
argument_list|,
name|intrhandle
argument_list|,
name|IPL_NET
argument_list|,
name|intr_rtn
argument_list|,
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|tulip_ih
operator|==
name|NULL
condition|)
name|printf
argument_list|(
literal|": couldn't establish interrupt"
argument_list|)
expr_stmt|;
if|if
condition|(
name|intrstr
operator|!=
name|NULL
condition|)
name|printf
argument_list|(
literal|" at %s"
argument_list|,
name|intrstr
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|tulip_ih
operator|==
name|NULL
condition|)
return|return;
block|}
name|sc
operator|->
name|tulip_ats
operator|=
name|shutdownhook_establish
argument_list|(
name|tulip_pci_shutdown
argument_list|,
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|tulip_ats
operator|==
name|NULL
condition|)
name|printf
argument_list|(
literal|"\n%s: warning: couldn't establish shutdown hook\n"
argument_list|,
name|sc
operator|->
name|tulip_xname
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
if|if
condition|(
operator|(
name|sc
operator|->
name|tulip_flags
operator|&
name|TULIP_SLAVEDINTR
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|pci_map_int
argument_list|(
name|config_id
argument_list|,
name|intr_rtn
argument_list|,
operator|(
name|void
operator|*
operator|)
name|sc
argument_list|,
operator|&
name|net_imask
argument_list|)
condition|)
block|{
name|printf
argument_list|(
name|TULIP_PRINTF_FMT
literal|": couldn't map interrupt\n"
argument_list|,
name|TULIP_PRINTF_ARGS
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|at_shutdown
argument_list|(
name|tulip_shutdown
argument_list|,
name|sc
argument_list|,
name|SHUTDOWN_POST_SYNC
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|__bsdi__
argument_list|)
if|if
condition|(
operator|(
name|sc
operator|->
name|tulip_flags
operator|&
name|TULIP_SLAVEDINTR
operator|)
operator|==
literal|0
condition|)
block|{
name|isa_establish
argument_list|(
operator|&
name|sc
operator|->
name|tulip_id
argument_list|,
operator|&
name|sc
operator|->
name|tulip_dev
argument_list|)
expr_stmt|;
name|sc
operator|->
name|tulip_ih
operator|.
name|ih_fun
operator|=
name|intr_rtn
expr_stmt|;
name|sc
operator|->
name|tulip_ih
operator|.
name|ih_arg
operator|=
operator|(
name|void
operator|*
operator|)
name|sc
expr_stmt|;
name|intr_establish
argument_list|(
name|ia
operator|->
name|ia_irq
argument_list|,
operator|&
name|sc
operator|->
name|tulip_ih
argument_list|,
name|DV_NET
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|tulip_ats
operator|.
name|func
operator|=
name|tulip_shutdown
expr_stmt|;
name|sc
operator|->
name|tulip_ats
operator|.
name|arg
operator|=
operator|(
name|void
operator|*
operator|)
name|sc
expr_stmt|;
name|atshutdown
argument_list|(
operator|&
name|sc
operator|->
name|tulip_ats
argument_list|,
name|ATSH_ADD
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|TULIP_USE_SOFTINTR
argument_list|)
if|if
condition|(
name|sc
operator|->
name|tulip_unit
operator|>
name|tulip_softintr_max_unit
condition|)
name|tulip_softintr_max_unit
operator|=
name|sc
operator|->
name|tulip_unit
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|TULIP_DEBUG
argument_list|)
if|if
condition|(
name|sc
operator|->
name|tulip_chipid
operator|==
name|TULIP_21041
condition|)
block|{
name|TULIP_CSR_WRITE
argument_list|(
name|sc
argument_list|,
name|csr_sia_connectivity
argument_list|,
name|TULIP_SIACONN_RESET
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
name|PCI_CONF_WRITE
argument_list|(
name|PCI_CFDA
argument_list|,
name|TULIP_CFDA_SLEEP
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|20000
argument_list|)
expr_stmt|;
name|PCI_CONF_WRITE
argument_list|(
name|PCI_CFDA
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|20000
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|tulip_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|tulip_attach
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

