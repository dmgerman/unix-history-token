begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1995 Mark Tinguely and Jim Lowe  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by Mark Tinguely and Jim Lowe  * 4. The name of the author may not be used to endorse or promote products   *    derived from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE  * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,  * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN  * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  * POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*		Change History: 	8/21/95		Release 	8/23/95		On advice from Stefan Esser, added volatile to PCI 			memory pointers to remove PCI caching . 	8/29/95		Fixes suggested by Bruce Evans. 			meteor_mmap should return -1 on error rather than 0. 			unit #> NMETEOR should be unit #>= NMETEOR. 	10/24/95	Turn 50 Hz processing for SECAM and 60 Hz processing 			off for AUTOMODE. 	11/11/95	Change UV from always begin signed to ioctl selected 			to either signed or unsigned. */
end_comment

begin_include
include|#
directive|include
file|"meteor.h"
end_include

begin_if
if|#
directive|if
name|NMETEOR
operator|>
literal|0
end_if

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/protosw.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/signalvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/devconf.h>
end_include

begin_include
include|#
directive|include
file|<sys/mman.h>
end_include

begin_include
include|#
directive|include
file|<machine/clock.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_kern.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_param.h>
end_include

begin_include
include|#
directive|include
file|<pci.h>
end_include

begin_if
if|#
directive|if
name|NPCI
operator|>
literal|0
end_if

begin_include
include|#
directive|include
file|<pci/pcivar.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<machine/ioctl_meteor.h>
end_include

begin_comment
comment|/* enough memory for 640x48 RGB16, or YUV (16 storage bits/pixel) or 			     450x340 RGB24 (32 storage bits/pixel) 	  options "METEOR_ALLOC_PAGES=" 	*/
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|METEOR_ALLOC_PAGES
end_ifndef

begin_define
define|#
directive|define
name|METEOR_ALLOC_PAGES
value|151
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|METEOR_ALLOC
value|(METEOR_ALLOC_PAGES * PAGE_SIZE)
end_define

begin_define
define|#
directive|define
name|NUM_SAA7116_PCI_REGS
value|37
end_define

begin_define
define|#
directive|define
name|NUM_SAA7196_I2C_REGS
value|49
end_define

begin_typedef
typedef|typedef
struct|struct
block|{
name|vm_offset_t
name|virt_baseaddr
decl_stmt|;
comment|/* saa7116 register virtual address */
name|vm_offset_t
name|phys_baseaddr
decl_stmt|;
comment|/* saa7116 register physical address */
name|vm_offset_t
name|capt_cntrl
decl_stmt|;
comment|/* capture control register offset 0x40 */
name|vm_offset_t
name|stat_reg
decl_stmt|;
comment|/* status register offset 0x60 */
name|vm_offset_t
name|iic_virt_addr
decl_stmt|;
comment|/* ICC bus register  offset 0x64 */
name|pcici_t
name|tag
decl_stmt|;
comment|/* PCI tag, for doing PCI commands */
name|vm_offset_t
name|bigbuf
decl_stmt|;
comment|/* buffer that holds the captured image */
name|int
name|alloc_pages
decl_stmt|;
comment|/* number of pages in bigbuf */
name|struct
name|proc
modifier|*
name|proc
decl_stmt|;
comment|/* process to receive raised signal */
name|struct
name|meteor_mem
modifier|*
name|mem
decl_stmt|;
comment|/* used to control sync. multi-frame output */
name|u_long
name|hiwat_cnt
decl_stmt|;
comment|/* mark and count frames lost due to hiwat */
name|short
name|ecurrent
decl_stmt|;
comment|/* even frame number in buffer (1-frames) */
name|short
name|ocurrent
decl_stmt|;
comment|/* odd frame number in buffer (1-frames) */
name|short
name|rows
decl_stmt|;
comment|/* number of rows in a frame */
name|short
name|cols
decl_stmt|;
comment|/* number of columns in a frame */
name|short
name|depth
decl_stmt|;
comment|/* number of byte per pixel */
name|short
name|frames
decl_stmt|;
comment|/* number of frames allocated */
name|int
name|frame_size
decl_stmt|;
comment|/* number of bytes in a frame */
name|u_long
name|fifo_errors
decl_stmt|;
comment|/* number of fifo capture errors since open */
name|u_long
name|dma_errors
decl_stmt|;
comment|/* number of DMA capture errors since open */
name|u_long
name|frames_captured
decl_stmt|;
comment|/* number of frames captured since open */
name|unsigned
name|flags
decl_stmt|;
define|#
directive|define
name|METEOR_INITALIZED
value|0x00000001
define|#
directive|define
name|METEOR_OPEN
value|0x00000002
define|#
directive|define
name|METEOR_MMAP
value|0x00000004
define|#
directive|define
name|METEOR_INTR
value|0x00000008
define|#
directive|define
name|METEOR_READ
value|0x00000010
define|#
directive|define
name|METEOR_SINGLE
value|0x00000020
define|#
directive|define
name|METEOR_CONTIN
value|0x00000040
define|#
directive|define
name|METEOR_SYNCAP
value|0x00000080
define|#
directive|define
name|METEOR_CAP_MASK
value|0x000000f0
define|#
directive|define
name|METEOR_NTSC
value|0x00000100
define|#
directive|define
name|METEOR_PAL
value|0x00000200
define|#
directive|define
name|METEOR_SECAM
value|0x00000400
define|#
directive|define
name|METEOR_AUTOMODE
value|0x00000800
define|#
directive|define
name|METEOR_FORM_MASK
value|0x00000f00
define|#
directive|define
name|METEOR_DEV0
value|0x00001000
define|#
directive|define
name|METEOR_DEV1
value|0x00002000
define|#
directive|define
name|METEOR_DEV2
value|0x00004000
define|#
directive|define
name|METEOR_DEV3
value|0x00008000
define|#
directive|define
name|METEOR_DEV_MASK
value|0x0000f000
define|#
directive|define
name|METEOR_RGB16
value|0x00010000
define|#
directive|define
name|METEOR_RGB24
value|0x00020000
define|#
directive|define
name|METEOR_YUV_PACKED
value|0x00040000
define|#
directive|define
name|METEOR_YUV_PLANER
value|0x00080000
define|#
directive|define
name|METEOR_PRO_MASK
value|0x000f0000
define|#
directive|define
name|METEOR_SINGLE_EVEN
value|0x00100000
define|#
directive|define
name|METEOR_SINGLE_ODD
value|0x00200000
define|#
directive|define
name|METEOR_SINGLE_MASK
value|0x00300000
name|u_char
name|saa7196_i2c
index|[
name|NUM_SAA7196_I2C_REGS
index|]
decl_stmt|;
comment|/* saa7196 register values */
block|}
name|meteor_reg_t
typedef|;
end_typedef

begin_decl_stmt
name|meteor_reg_t
name|meteor
index|[
name|NMETEOR
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_long
name|read_intr_wait
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|METPRI
value|(PZERO+8)|PCATCH
end_define

begin_comment
comment|/*--------------------------------------------------------- ** **	Meteor PCI probe and initialization routines ** **--------------------------------------------------------- */
end_comment

begin_function_decl
specifier|static
name|char
modifier|*
name|met_probe
parameter_list|(
name|pcici_t
name|tag
parameter_list|,
name|pcidi_t
name|type
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|met_attach
parameter_list|(
name|pcici_t
name|tag
parameter_list|,
name|int
name|unit
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|u_long
name|met_count
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|pci_device
name|met_device
init|=
block|{
literal|"meteor"
block|,
name|met_probe
block|,
name|met_attach
block|,
operator|&
name|met_count
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DATA_SET
argument_list|(
name|pcidevice_set
argument_list|,
name|met_device
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|u_long
name|saa7116_pci_default
index|[
name|NUM_SAA7116_PCI_REGS
index|]
init|=
block|{
comment|/* PCI Memory registers	    	*/
comment|/* BITS	  Type	Description	*/
comment|/* 0x00 */
literal|0x00000000
block|,
comment|/* 31:1   e*RW	DMA 1 (Even) 				      0   RO    0x0 		*/
comment|/* 0x04 */
literal|0x00000000
block|,
comment|/* 31:2   e*RW	DMA 2 (Even) 				    1:0   RO	0x0		*/
comment|/* 0x08 */
literal|0x00000000
block|,
comment|/* 31:2   e*RW  DMA 3 (Even) 				    1:0   RO    0x0		*/
comment|/* 0x0c */
literal|0x00000000
block|,
comment|/* 31:1   o*RW	DMA 1 (Odd) 				      0   RO	0x0		*/
comment|/* 0x10 */
literal|0x00000000
block|,
comment|/* 31:2	  o*RW	DMA 2 (Odd) 				    1:0	  RO	0x0		*/
comment|/* 0x14 */
literal|0x00000000
block|,
comment|/* 31:2   o*RW	DMA 3 (Odd) 				    1:0   RO	0x0		*/
comment|/* 0x18 */
literal|0x00000500
block|,
comment|/* 15:2   e*RW  Stride 1 (Even) 				    1:0   RO	0x0		*/
comment|/* 0x1c */
literal|0x00000000
block|,
comment|/* 15:2	  e*RW	Stride 2 (Even) 				    1:0	  RO	0x0		*/
comment|/* 0x20 */
literal|0x00000000
block|,
comment|/* 15:2	  e*RW	Stride 3 (Even) 				    1:0	  RO	0x0		*/
comment|/* 0x24 */
literal|0x00000500
block|,
comment|/* 15:2	  o*RW	Stride 1 (Odd) 				    1:0	  RO	0x0		*/
comment|/* 0x28 */
literal|0x00000000
block|,
comment|/* 15:2	  o*RW	Stride 2 (Odd) 				    1:0	  RO	0x0		*/
comment|/* 0x2c */
literal|0x00000000
block|,
comment|/* 15:2	  o*RW	Stride 3 (Odd) 				    1:0	  RO	0x0		*/
comment|/* 0x30 */
literal|0xeeeeee01
block|,
comment|/* 31:8	  *RW	Route (Even) 				    7:0	  *RW	Mode (Even)	*/
comment|/* 0x34 */
literal|0xeeeeee01
block|,
comment|/* 31:8	  *RW	Route (Odd) 				    7:0	  *RW	Mode (Odd)	*/
comment|/* 0x38 */
literal|0x00200020
block|,
comment|/* 22:16  *RW	FIFO Trigger Planer Mode, 				    6:0	  *RW	FIFO Trigger Packed Mode */
comment|/* 0x3c */
literal|0x00000103
block|,
comment|/*  9:8   *RW	Reserved (0x0) 				      2	  *RW	Field Toggle 				      1	  *RW	Reserved (0x1) 				      0	  *RW	Reserved (0x1)		*/
comment|/* 0x40 */
literal|0x000000c0
block|,
comment|/*    15  *RW	Range Enable 				      14  *RW	Corrupt Disable 				      11  *RR	Address Error (Odd) 				      10  *RR	Address Error (Even) 				      9   *RR	Field Corrupt (Odd) 				      8   *RR	Field Corrupt (Even) 				      7	  *RW	Fifo Enable 				      6   *RW	VRSTN# 				      5	  *RR	Field Done (Odd) 				      4   *RR	Field Done (Even) 				      3	  *RS	Single Field Capture (Odd) 				      2	  *RS	Single Field Capture (Even) 				      1	  *RW	Capture (ODD) Continous 				      0	  *RW	Capture (Even) Continous */
comment|/* 0x44 */
literal|0x00000000
block|,
comment|/*  7:0	  *RW	Retry Wait Counter */
comment|/* 0x48 */
literal|0x00000307
block|,
comment|/*    10  *RW	Interrupt mask, start of field 				      9   *RW	Interrupt mask, end odd field 				      8	  *RW	Interrupt mask, end even field 				      2   *RR	Interrupt status, start of field 				      1   *RR	Interrupt status, end of odd 				      0	  *RR	Interrupt status, end of even */
comment|/* 0x4c */
literal|0x00000001
block|,
comment|/* 31:0   *RW	Field Mask (Even) continous */
comment|/* 0x50 */
literal|0x00000001
block|,
comment|/* 31:0   *RW	Field Mask (Odd) continous */
comment|/* 0x54 */
literal|0x00000000
block|,
comment|/* 20:16  *RW	Mask Length (Odd) 				    4:0	  *RW	Mask Length (Even)	*/
comment|/* 0x58 */
literal|0x0005007c
block|,
comment|/* 22:16  *RW	FIFO almost empty 				    6:0	  *RW	FIFO almost full	*/
comment|/* 0x5c */
literal|0x461e1e0f
block|,
comment|/* 31:24  *RW	I2C Phase 4 				   23:16  *RW	I2C Phase 3 				   15:8   *RW	I2C Phase 2 				    7:0	  *RW	I2C Phase 1	*/
comment|/* 0x60 */
literal|0x00000300
block|,
comment|/* 31:24  *RO	I2C Read Data 				   23:16  **RW  I2C Auto Address 				      11  RO	I2C SCL Input 				      10  RO	I2C SDA Input 				      9	  RR	I2C Direct Abort 				      8   RR	I2C Auto Abort 				      3   RW	I2C SCL Output 				      2   RW	I2C SDA Output 				      1	  RW	I2C Bypass 				      0	  RW	I2C Auto Enable	*/
comment|/* 0x64 */
literal|0x00000000
block|,
comment|/*    24  RS	I2C New Cycle 				   23:16  **RW	I2C Direct Address 				   15:8   **RW	I2C Direct Sub-address 				    7:0	  **RW	I2C Direct Write Address */
comment|/* 0x68 */
literal|0x00000000
block|,
comment|/* 31:24  **RW  I2C Auto Sub-address 1 (Even) 				   23:16  **RW  I2C Auto Data 1 (Even) 				   15:8   **RW  I2C Auto Sub-address 0 (Even) 				    7:0	  **RW	I2C Auto Data 0 (Even) */
comment|/* 0x6c */
literal|0x00000000
block|,
comment|/* 31:24  **RW  I2C Auto Sub-address 3 (Even) 				   23:16  **RW  I2C Auto Data 3 (Even) 				   15:8   **RW  I2C Auto Sub-address 2 (Even) 				    7:0	  **RW	I2C Auto Data 2 (Even) */
comment|/* 0x70 */
literal|0x00000000
block|,
comment|/* 31:24  **RW  I2C Auto Sub-address 5 (Even) 				   23:16  **RW  I2C Auto Data 5 (Even) 				   15:8   **RW  I2C Auto Sub-address 4 (Even) 				    7:0	  **RW	I2C Auto Data 4 (Even) */
comment|/* 0x74 */
literal|0x00000000
block|,
comment|/* 31:24  **RW  I2C Auto Sub-address 7 (Even) 				   23:16  **RW  I2C Auto Data 7 (Even) 				   15:8   **RW  I2C Auto Sub-address 6 (Even) 				    7:0	  **RW	I2C Auto Data 6 (Even) */
comment|/* 0x78 */
literal|0x00000000
block|,
comment|/* 31:24  **RW  I2C Auto Sub-address 1 (Odd) 				   23:16  **RW  I2C Auto Data 1 (Odd) 				   15:8   **RW  I2C Auto Sub-address 0 (Odd) 				    7:0	  **RW	I2C Auto Data 0 (Odd) */
comment|/* 0x7c */
literal|0x00000000
block|,
comment|/* 31:24  **RW  I2C Auto Sub-address 3 (Odd) 				   23:16  **RW  I2C Auto Data 3 (Odd) 				   15:8   **RW  I2C Auto Sub-address 2 (Odd) 				    7:0	  **RW	I2C Auto Data 2 (Odd) */
comment|/* 0x80 */
literal|0x00000000
block|,
comment|/* 31:24  **RW  I2C Auto Sub-address 5 (Odd) 				   23:16  **RW  I2C Auto Data 5 (Odd) 				   15:8   **RW  I2C Auto Sub-address 4 (Odd) 				    7:0	  **RW	I2C Auto Data 4 (Odd) */
comment|/* 0x84 */
literal|0x00000000
block|,
comment|/* 31:24  **RW  I2C Auto Sub-address 7 (Odd) 				   23:16  **RW  I2C Auto Data 7 (Odd) 				   15:8   **RW  I2C Auto Sub-address 6 (Odd) 				    7:0	  **RW	I2C Auto Data 6 (Odd) */
comment|/* 0x88 */
literal|0x00000000
block|,
comment|/* 23:16  **RW	I2C Register Enable (Odd) 				    7:0	  **RW	I2C Register Enable (Even) */
comment|/* 0x8c */
literal|0x00000000
block|,
comment|/* 23:2	  e*RW	DMA End (Even) 				    1:0	  RO	0x0	*/
comment|/* 0x90 */
literal|0x00000000
comment|/* 23:2	  e*RW	DMA End (Odd) 				    1:0	  RO	0x0	*/
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_char
name|saa7196_i2c_default
index|[
name|NUM_SAA7196_I2C_REGS
index|]
init|=
block|{
comment|/* SAA7196 I2C bus control			*/
comment|/* BITS	Function				*/
comment|/* 00 */
literal|0x50
block|,
comment|/* 7:0	Increment Delay				*/
comment|/* 01 */
literal|0x7f
block|,
comment|/* 7:0	Horizontal Sync Begin for 50hz		*/
comment|/* 02 */
literal|0x53
block|,
comment|/* 7:0	Horizontal Sync Stop for 50hz		*/
comment|/* 03 */
literal|0x43
block|,
comment|/* 7:0	Horizontal Sync Clamp Start for 50hz	*/
comment|/* 04 */
literal|0x19
block|,
comment|/* 7:0	Horizontal Sync Clamp Stop for 50hz 	*/
comment|/* 05 */
literal|0x00
block|,
comment|/* 7:0	Horizontal Sync Start after PH1 for 50hz */
comment|/* 06 */
literal|0x46
block|,
comment|/*   7	Input mode =0 CVBS, =1 S-Video  			     6	Pre filter 			   5:4  Aperture Bandpass characteristics 			   3:2	Coring range for high freq 			   1:0	Aperture bandpass filter weights	*/
comment|/* 07 */
literal|0x00
block|,
comment|/* 7:0	Hue					*/
comment|/* 08 */
literal|0x7f
block|,
comment|/* 7:3	Colour-killer threshold QAM (PAL, NTSC) */
comment|/* 09 */
literal|0x7f
block|,
comment|/* 7:3	Colour-killer threshold SECAM		*/
comment|/* 0a */
literal|0x7f
block|,
comment|/* 7:0	PAL switch sensitivity			*/
comment|/* 0b */
literal|0x7f
block|,
comment|/* 7:0	SECAM switch sensitivity		*/
comment|/* 0c */
literal|0x40
block|,
comment|/*   7	Colour-on bit 			   6:5	AGC filter				*/
comment|/* 0d */
literal|0x84
block|,
comment|/*   7	VTR/TV mode bit = 1->VTR mode 			     3	Realtime output mode select bit 			     2	HREF position select 			     1	Status byte select 			     0	SECAM mode bit				*/
comment|/* 0e */
literal|0x38
block|,
comment|/*   7	Horizontal clock PLL 			     5	Select interal/external clock source 			     4	Output enable of Horizontal/Vertical sync 			     3	Data output YUV enable 			     2	S-VHS bit 			     1	GPSW2 			     0	GPSW1					*/
comment|/* 0f */
literal|0x50
block|,
comment|/*   7	Automatic Field detection 			     6	Field Select 0 = 50hz, 1=60hz 			     5	SECAM cross-colour reduction 			     4	Enable sync and clamping pulse 			   3:1	Luminance delay compensation		*/
comment|/* 10 */
literal|0x00
block|,
comment|/*   2	Select HREF Position 			   1:0  Vertical noise reduction		*/
comment|/* 11 */
literal|0x2c
block|,
comment|/* 7:0	Chrominance gain conrtol for QAM	*/
comment|/* 12 */
literal|0x40
block|,
comment|/* 7:0	Chrominance saturation control for VRAM port */
comment|/* 13 */
literal|0x40
block|,
comment|/* 7:0	Luminance contract control for VRAM port */
comment|/* 14 */
literal|0x34
block|,
comment|/* 7:0	Horizontal sync begin for 60hz		*/
comment|/* 15 */
literal|0x0c
block|,
comment|/* 7:0	Horizontal sync stop for 60hz		*/
comment|/* 16 */
literal|0xfb
block|,
comment|/* 7:0	Horizontal clamp begin for 60hz		*/
comment|/* 17 */
literal|0xd4
block|,
comment|/* 7:0	Horizontal clamp stop for 60hz		*/
comment|/* 18 */
literal|0xec
block|,
comment|/* 7:0	Horizontal sync start after PH1 for 60hz */
comment|/* 19 */
literal|0x80
block|,
comment|/* 7:0	Luminance brightness control for VRAM port */
comment|/* 1a */
literal|0x00
block|,
comment|/* 1b */
literal|0x00
block|,
comment|/* 1c */
literal|0x00
block|,
comment|/* 1d */
literal|0x00
block|,
comment|/* 1e */
literal|0x00
block|,
comment|/* 1f */
literal|0x00
block|,
comment|/* 20 */
literal|0x90
block|,
comment|/*   7	ROM table bypass switch 			   6:5	Set output field mode 			     4	VRAM port outputs enable 			   3:2	First pixel position in VRO data 			   1:0	FIFO output register select		*/
comment|/* 21 */
literal|0x80
block|,
comment|/* 7:0	[7:0] Pixel number per line on output	*/
comment|/* 22 */
literal|0x80
block|,
comment|/* 7:0	[7:0] Pixel number per line on input	*/
comment|/* 23 */
literal|0x03
block|,
comment|/* 7:0	[7:0] Horizontal start position of scaling win*/
comment|/* 24 */
literal|0x8a
block|,
comment|/* 7:5	Horizontal decimation filter 			     4  [8] Horizontal start position of scaling win 			   3:2	[9:8] Pixel number per line on input 			   1:0  [9:8] Pixel number per line on output 	*/
comment|/* 25 */
literal|0xf0
block|,
comment|/* 7:0	[7:0] Line number per output field	*/
comment|/* 26 */
literal|0xf0
block|,
comment|/* 7:0	[7:0] Line number per input field	*/
comment|/* 27 */
literal|0x0f
block|,
comment|/* 7:0	[7:0] Vertical start of scaling window	*/
comment|/* 28 */
literal|0x80
block|,
comment|/*   7	Adaptive filter switch 			   6:5	Vertical luminance data processing 			     4	[8] Vertical start of scaling window  			   3:2  [9:8] Line number per input field 			   1:0	[9:8] Line number per output field	*/
comment|/* 29 */
literal|0x16
block|,
comment|/* 7:0	[7:0] Vertical bypass start		*/
comment|/* 2a */
literal|0x00
block|,
comment|/* 7:0	[7:0] Vertical bypass count		*/
comment|/* 2b */
literal|0x00
block|,
comment|/*   4  [8] Vertical bypass start 			     2  [8] Vertical bypass count 			     0	Polarity, internally detected odd even flag */
comment|/* 2c */
literal|0x80
block|,
comment|/* 7:0	Set lower limit V for colour-keying	*/
comment|/* 2d */
literal|0x7f
block|,
comment|/* 7:0	Set upper limit V for colour-keying	*/
comment|/* 2e */
literal|0x80
block|,
comment|/* 7:0	Set lower limit U for colour-keying	*/
comment|/* 2f */
literal|0x7f
block|,
comment|/* 7:0	Set upper limit U for colour-keying	*/
comment|/* 30 */
literal|0xbf
comment|/*   7	VRAM bus output format 			     6	Adaptive geometrical filter 			     5	Luminance limiting value 			     4	Monochrome and two's complement output data sel 			     3	Line quailifier flag 			     2	Pixel qualifier flag 			     1	Transparent data transfer 			     0	Extended formats enable bit		*/
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * i2c_write:  * Returns	0	Succesful completion.  * Returns	1	If transfer aborted or timeout occured.  *  */
end_comment

begin_define
define|#
directive|define
name|SAA7196_I2C_ADDR
value|0x40
end_define

begin_define
define|#
directive|define
name|I2C_WRITE
value|0x00
end_define

begin_define
define|#
directive|define
name|I2C_READ
value|0x01
end_define

begin_define
define|#
directive|define
name|SAA7116_IIC_NEW_CYCLE
value|0x1000000L
end_define

begin_define
define|#
directive|define
name|IIC_DIRECT_TRANSFER_ABORTED
value|0x0000200L
end_define

begin_define
define|#
directive|define
name|SAA7196_WRITE
parameter_list|(
name|mtr
parameter_list|,
name|reg
parameter_list|,
name|data
parameter_list|)
define|\
value|i2c_write(mtr, SAA7196_I2C_ADDR, I2C_WRITE, reg, data); \ 	mtr->saa7196_i2c[reg] = data
end_define

begin_define
define|#
directive|define
name|SAA7196_REG
parameter_list|(
name|mtr
parameter_list|,
name|reg
parameter_list|)
value|mtr->saa7196_i2c[reg]
end_define

begin_define
define|#
directive|define
name|SAA7196_READ
parameter_list|(
name|mtr
parameter_list|)
define|\
value|i2c_write(mtr, SAA7196_I2C_ADDR, I2C_READ, 0x0, 0x0)
end_define

begin_function
specifier|static
name|int
name|i2c_write
parameter_list|(
name|meteor_reg_t
modifier|*
name|mtr
parameter_list|,
name|u_char
name|slave
parameter_list|,
name|u_char
name|rw
parameter_list|,
name|u_char
name|reg
parameter_list|,
name|u_char
name|data
parameter_list|)
block|{
specifier|register
name|unsigned
name|long
name|wait_counter
init|=
literal|0x0001ffff
decl_stmt|;
specifier|register
specifier|volatile
name|u_long
modifier|*
name|iic_write_loc
init|=
operator|(
specifier|volatile
name|u_long
operator|*
operator|)
name|mtr
operator|->
name|iic_virt_addr
decl_stmt|;
specifier|register
name|int
name|err
init|=
literal|0
decl_stmt|;
comment|/* Write the data the the i2c write register */
operator|*
name|iic_write_loc
operator|=
name|SAA7116_IIC_NEW_CYCLE
operator||
operator|(
operator|(
operator|(
name|u_long
operator|)
name|slave
operator||
operator|(
name|u_long
operator|)
name|rw
operator|)
operator|<<
literal|16
operator|)
operator||
operator|(
operator|(
name|u_long
operator|)
name|reg
operator|<<
literal|8
operator|)
operator||
operator|(
name|u_long
operator|)
name|data
expr_stmt|;
comment|/* Wait until the i2c cycle is compeleted */
while|while
condition|(
operator|(
operator|*
name|iic_write_loc
operator|&
name|SAA7116_IIC_NEW_CYCLE
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|wait_counter
condition|)
break|break;
name|wait_counter
operator|--
expr_stmt|;
block|}
comment|/*#ifdef notdef*/
comment|/* it seems the iic_write_loc is cached, until we can 	   figure out how to uncache the pci registers, then we 	   will just ignore the timeout.  Hopefully 1ffff will 	   be enough delay time for the i2c cycle to complete */
if|if
condition|(
operator|!
name|wait_counter
condition|)
block|{
name|printf
argument_list|(
literal|"meteor: saa7116 i2c %s transfer timeout 0x%x"
argument_list|,
name|rw
condition|?
literal|"read"
else|:
literal|"write"
argument_list|,
operator|*
name|iic_write_loc
argument_list|)
expr_stmt|;
name|err
operator|=
literal|1
expr_stmt|;
block|}
comment|/*#endif*/
comment|/* Check for error on direct write, clear if any */
if|if
condition|(
operator|(
operator|*
operator|(
operator|(
specifier|volatile
name|u_long
operator|*
operator|)
name|mtr
operator|->
name|stat_reg
operator|)
operator|)
operator|&
name|IIC_DIRECT_TRANSFER_ABORTED
condition|)
block|{
name|printf
argument_list|(
literal|"meteor: saa7116 i2c %s tranfer aborted"
argument_list|,
name|rw
condition|?
literal|"read"
else|:
literal|"write"
argument_list|)
expr_stmt|;
name|err
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|err
condition|)
block|{
name|printf
argument_list|(
literal|" - reg=0x%x, value=0x%x.\n"
argument_list|,
name|reg
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|met_probe
parameter_list|(
name|pcici_t
name|tag
parameter_list|,
name|pcidi_t
name|type
parameter_list|)
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
literal|0x12238086ul
case|:
comment|/* meteor */
return|return
operator|(
literal|"Matrox Meteor"
operator|)
return|;
block|}
empty_stmt|;
return|return
operator|(
operator|(
name|char
operator|*
operator|)
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* interrupt handling routine  	   complete meteor_read() if using interrupts 	*/
end_comment

begin_function
name|int
name|meteor_intr
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
specifier|register
name|meteor_reg_t
modifier|*
name|mtr
init|=
operator|(
name|meteor_reg_t
operator|*
operator|)
name|arg
decl_stmt|;
specifier|register
specifier|volatile
name|u_long
modifier|*
name|cap
decl_stmt|,
modifier|*
name|base
decl_stmt|,
modifier|*
name|status
decl_stmt|,
name|cap_err
decl_stmt|;
name|struct
name|meteor_mem
modifier|*
name|mm
decl_stmt|;
name|base
operator|=
operator|(
specifier|volatile
name|u_long
operator|*
operator|)
name|mtr
operator|->
name|virt_baseaddr
expr_stmt|;
name|cap
operator|=
operator|(
specifier|volatile
name|u_long
operator|*
operator|)
name|mtr
operator|->
name|capt_cntrl
expr_stmt|;
comment|/* capture control ptr */
name|status
operator|=
name|base
operator|+
literal|18
expr_stmt|;
comment|/*  mtr->virt_base + 0x48  save a dereference */
comment|/* the even field has to make the decision of whether the high water 	   has been reached. If hiwat has been reach do not advance the buffer. 	   continue to save frames on this buffer until we can advance again */
if|if
condition|(
operator|*
name|status
operator|&
literal|0x1
condition|)
block|{
comment|/* even field */
if|if
condition|(
name|mtr
operator|->
name|flags
operator|&
name|METEOR_SYNCAP
condition|)
block|{
name|mm
operator|=
name|mtr
operator|->
name|mem
expr_stmt|;
comment|/* shared SYNCAP struct */
if|if
condition|(
operator|(
operator|!
name|mtr
operator|->
name|hiwat_cnt
operator|&&
name|mm
operator|->
name|num_active_bufs
operator|<
name|mm
operator|->
name|hiwat
operator|)
operator|||
operator|(
name|mm
operator|->
name|num_active_bufs
operator|<=
name|mm
operator|->
name|lowat
operator|)
condition|)
block|{
name|mtr
operator|->
name|hiwat_cnt
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|++
name|mtr
operator|->
name|ecurrent
operator|>
name|mtr
operator|->
name|frames
condition|)
block|{
operator|*
name|base
operator|=
name|mtr
operator|->
name|bigbuf
expr_stmt|;
name|mtr
operator|->
name|ecurrent
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
operator|*
name|base
operator|=
operator|*
name|base
operator|+
name|mtr
operator|->
name|frame_size
expr_stmt|;
block|}
block|}
else|else
block|{
name|mtr
operator|->
name|hiwat_cnt
operator|++
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|mtr
operator|->
name|flags
operator|&
name|METEOR_SINGLE
condition|)
block|{
operator|*
name|cap
operator|&=
literal|0x0ffe
expr_stmt|;
name|mtr
operator|->
name|flags
operator|&=
operator|~
name|METEOR_SINGLE_EVEN
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|mtr
operator|->
name|flags
operator|&
name|METEOR_SINGLE_MASK
operator|)
condition|)
block|{
name|mtr
operator|->
name|frames_captured
operator|++
expr_stmt|;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|read_intr_wait
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|/* odd field */
if|if
condition|(
name|mtr
operator|->
name|flags
operator|&
name|METEOR_SINGLE
condition|)
block|{
operator|*
name|cap
operator|&=
literal|0x0ffd
expr_stmt|;
name|mtr
operator|->
name|flags
operator|&=
operator|~
name|METEOR_SINGLE_ODD
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|mtr
operator|->
name|flags
operator|&
name|METEOR_SINGLE_MASK
operator|)
condition|)
block|{
name|mtr
operator|->
name|frames_captured
operator|++
expr_stmt|;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|read_intr_wait
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|mtr
operator|->
name|flags
operator|&
name|METEOR_SYNCAP
condition|)
block|{
name|mm
operator|=
name|mtr
operator|->
name|mem
expr_stmt|;
comment|/* shared SYNCAP struct */
comment|/* even field decided to advance or not, we 				   simply add stride to that decision */
operator|*
operator|(
name|base
operator|+
literal|3
operator|)
operator|=
operator|*
name|base
operator|+
operator|*
operator|(
name|base
operator|+
literal|6
operator|)
expr_stmt|;
if|if
condition|(
name|mtr
operator|->
name|ecurrent
operator|!=
name|mtr
operator|->
name|ocurrent
condition|)
block|{
name|mm
operator|->
name|active
operator||=
operator|(
literal|1
operator|<<
operator|(
name|mtr
operator|->
name|ocurrent
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
name|mtr
operator|->
name|ocurrent
operator|=
name|mtr
operator|->
name|ecurrent
expr_stmt|;
name|mm
operator|->
name|num_active_bufs
operator|++
expr_stmt|;
if|if
condition|(
name|mtr
operator|->
name|proc
operator|&&
name|mm
operator|->
name|signal
condition|)
block|{
name|mtr
operator|->
name|frames_captured
operator|++
expr_stmt|;
name|psignal
argument_list|(
name|mtr
operator|->
name|proc
argument_list|,
name|mm
operator|->
name|signal
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
if|if
condition|(
name|cap_err
operator|=
operator|(
operator|*
name|cap
operator|&
literal|0xf00
operator|)
condition|)
block|{
if|if
condition|(
name|cap_err
operator|&
literal|0x3
condition|)
name|mtr
operator|->
name|fifo_errors
operator|++
expr_stmt|;
comment|/* incrememnt fifo capture errors cnt */
if|if
condition|(
name|cap_err
operator|&
literal|0xc
condition|)
name|mtr
operator|->
name|dma_errors
operator|++
expr_stmt|;
comment|/* increment DMA capture errors cnt */
block|}
operator|*
name|cap
operator||=
literal|0xf30
expr_stmt|;
comment|/* clear error and field done */
operator|*
name|status
operator||=
literal|0xf
expr_stmt|;
comment|/* clear interrupt status */
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Initialize the capture card to NTSC RGB 16 640x480  */
end_comment

begin_function
specifier|static
name|void
name|meteor_init
parameter_list|(
name|meteor_reg_t
modifier|*
name|mtr
parameter_list|)
block|{
specifier|volatile
name|u_long
modifier|*
name|vbase_addr
decl_stmt|;
name|int
name|i
decl_stmt|;
operator|*
operator|(
operator|(
specifier|volatile
name|u_long
operator|*
operator|)
operator|(
name|mtr
operator|->
name|capt_cntrl
operator|)
operator|)
operator|=
literal|0x00000040L
expr_stmt|;
name|vbase_addr
operator|=
operator|(
specifier|volatile
name|u_long
operator|*
operator|)
name|mtr
operator|->
name|virt_baseaddr
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_SAA7116_PCI_REGS
condition|;
name|i
operator|++
control|)
operator|*
name|vbase_addr
operator|++
operator|=
name|saa7116_pci_default
index|[
name|i
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_SAA7196_I2C_REGS
condition|;
name|i
operator|++
control|)
block|{
name|SAA7196_WRITE
argument_list|(
name|mtr
argument_list|,
name|i
argument_list|,
name|saa7196_i2c_default
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|met_attach
parameter_list|(
name|pcici_t
name|tag
parameter_list|,
name|int
name|unit
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|METEOR_IRQ
comment|/* from the meteor.h file */
name|u_long
name|old_irq
decl_stmt|,
name|new_irq
decl_stmt|;
endif|#
directive|endif
endif|METEOR_IRQ
comment|/* from the meteor.h file */
name|meteor_reg_t
modifier|*
name|mtr
decl_stmt|;
name|vm_offset_t
name|buf
decl_stmt|;
if|if
condition|(
name|unit
operator|>=
name|NMETEOR
condition|)
block|{
name|printf
argument_list|(
literal|"meteor_attach: mx%d: invalid unit number\n"
argument_list|)
expr_stmt|;
return|return ;
block|}
name|mtr
operator|=
operator|&
name|meteor
index|[
name|unit
index|]
expr_stmt|;
name|pci_map_mem
argument_list|(
name|tag
argument_list|,
literal|0x10
argument_list|,
operator|&
operator|(
name|mtr
operator|->
name|virt_baseaddr
operator|)
argument_list|,
operator|&
operator|(
name|mtr
operator|->
name|phys_baseaddr
operator|)
argument_list|)
expr_stmt|;
comment|/* IIC addres at 0x64 offset bytes */
name|mtr
operator|->
name|capt_cntrl
operator|=
name|mtr
operator|->
name|virt_baseaddr
operator|+
literal|0x40
expr_stmt|;
name|mtr
operator|->
name|stat_reg
operator|=
name|mtr
operator|->
name|virt_baseaddr
operator|+
literal|0x60
expr_stmt|;
name|mtr
operator|->
name|iic_virt_addr
operator|=
name|mtr
operator|->
name|virt_baseaddr
operator|+
literal|0x64
expr_stmt|;
ifdef|#
directive|ifdef
name|METEOR_IRQ
comment|/* from the meteor.h file */
name|old_irq
operator|=
name|pci_conf_read
argument_list|(
name|tag
argument_list|,
name|PCI_INTERRUPT_REG
argument_list|)
expr_stmt|;
name|pci_conf_write
argument_list|(
name|tag
argument_list|,
name|PCI_INTERRUPT_REG
argument_list|,
name|METEOR_IRQ
argument_list|)
expr_stmt|;
name|new_irq
operator|=
name|pci_conf_read
argument_list|(
name|tag
argument_list|,
name|PCI_INTERRUPT_REG
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"meteor_attach: irq changed from %d to %d\n"
argument_list|,
operator|(
name|old_irq
operator|&
literal|0xff
operator|)
argument_list|,
operator|(
name|new_irq
operator|&
literal|0xff
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|METEOR_IRQ
name|meteor_init
argument_list|(
name|mtr
argument_list|)
expr_stmt|;
comment|/* set up saa7116 and saa7196 chips */
name|mtr
operator|->
name|tag
operator|=
name|tag
expr_stmt|;
comment|/* setup the interrupt handling routine */
name|pci_map_int
argument_list|(
name|tag
argument_list|,
name|meteor_intr
argument_list|,
operator|(
name|void
operator|*
operator|)
name|mtr
argument_list|,
operator|&
name|net_imask
argument_list|)
expr_stmt|;
comment|/* 640*240*3 round up to nearest pag e*/
name|buf
operator|=
name|vm_page_alloc_contig
argument_list|(
name|METEOR_ALLOC
argument_list|,
literal|0x100000
argument_list|,
literal|0xffffffff
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"meteor_attach: big buffer allocation failed\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|mtr
operator|->
name|bigbuf
operator|=
name|buf
expr_stmt|;
name|mtr
operator|->
name|alloc_pages
operator|=
name|METEOR_ALLOC_PAGES
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
name|buf
argument_list|,
name|METEOR_ALLOC
argument_list|)
expr_stmt|;
name|buf
operator|=
name|vtophys
argument_list|(
name|buf
argument_list|)
expr_stmt|;
operator|*
operator|(
operator|(
specifier|volatile
name|u_long
operator|*
operator|)
name|mtr
operator|->
name|virt_baseaddr
operator|)
operator|=
name|buf
expr_stmt|;
comment|/* 640x480 RGB 16 */
operator|*
operator|(
operator|(
specifier|volatile
name|u_long
operator|*
operator|)
name|mtr
operator|->
name|virt_baseaddr
operator|+
literal|3
operator|)
operator|=
name|buf
operator|+
literal|0x500
expr_stmt|;
operator|*
operator|(
operator|(
specifier|volatile
name|u_long
operator|*
operator|)
name|mtr
operator|->
name|virt_baseaddr
operator|+
literal|36
operator|)
operator|=
operator|*
operator|(
operator|(
specifier|volatile
name|u_long
operator|*
operator|)
name|mtr
operator|->
name|virt_baseaddr
operator|+
literal|35
operator|)
operator|=
name|buf
operator|+
name|METEOR_ALLOC
expr_stmt|;
name|mtr
operator|->
name|flags
operator|=
name|METEOR_INITALIZED
operator||
name|METEOR_NTSC
operator||
name|METEOR_DEV0
operator||
name|METEOR_RGB16
expr_stmt|;
comment|/* 1 frame of 640x480 RGB 16 */
name|mtr
operator|->
name|cols
operator|=
literal|640
expr_stmt|;
name|mtr
operator|->
name|rows
operator|=
literal|480
expr_stmt|;
name|mtr
operator|->
name|depth
operator|=
literal|2
expr_stmt|;
comment|/* two bytes per pixel */
name|mtr
operator|->
name|frames
operator|=
literal|1
expr_stmt|;
comment|/* one frame */
block|}
end_function

begin_function
specifier|static
name|void
name|meteor_reset
parameter_list|(
name|meteor_reg_t
modifier|*
specifier|const
name|sc
parameter_list|)
block|{  }
end_function

begin_comment
comment|/*--------------------------------------------------------- ** **	Meteor character device driver routines ** **--------------------------------------------------------- */
end_comment

begin_define
define|#
directive|define
name|UNIT
parameter_list|(
name|x
parameter_list|)
value|((x)& 0x07)
end_define

begin_function
name|int
name|meteor_open
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|flag
parameter_list|)
block|{
name|meteor_reg_t
modifier|*
name|mtr
decl_stmt|;
name|int
name|unit
decl_stmt|;
name|int
name|i
decl_stmt|;
name|unit
operator|=
name|UNIT
argument_list|(
name|minor
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|unit
operator|>=
name|NMETEOR
condition|)
comment|/* unit out of range */
return|return
operator|(
name|ENXIO
operator|)
return|;
name|mtr
operator|=
operator|&
operator|(
name|meteor
index|[
name|unit
index|]
operator|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|mtr
operator|->
name|flags
operator|&
name|METEOR_INITALIZED
operator|)
condition|)
comment|/* device not found */
return|return
operator|(
name|ENXIO
operator|)
return|;
if|if
condition|(
name|mtr
operator|->
name|flags
operator|&
name|METEOR_OPEN
condition|)
comment|/* device is busy */
return|return
operator|(
name|EBUSY
operator|)
return|;
name|mtr
operator|->
name|flags
operator||=
name|METEOR_OPEN
expr_stmt|;
comment|/* 	 * Make sure that the i2c regs are set the same for each open. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_SAA7196_I2C_REGS
condition|;
name|i
operator|++
control|)
block|{
name|SAA7196_WRITE
argument_list|(
name|mtr
argument_list|,
name|i
argument_list|,
name|saa7196_i2c_default
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|mtr
operator|->
name|fifo_errors
operator|=
literal|0
expr_stmt|;
name|mtr
operator|->
name|dma_errors
operator|=
literal|0
expr_stmt|;
name|mtr
operator|->
name|frames_captured
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|meteor_close
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|flag
parameter_list|)
block|{
name|meteor_reg_t
modifier|*
name|mtr
decl_stmt|;
name|int
name|unit
decl_stmt|;
name|int
name|temp
decl_stmt|;
name|unit
operator|=
name|UNIT
argument_list|(
name|minor
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|unit
operator|>=
name|NMETEOR
condition|)
comment|/* unit out of range */
return|return
operator|(
name|ENXIO
operator|)
return|;
name|mtr
operator|=
operator|&
operator|(
name|meteor
index|[
name|unit
index|]
operator|)
expr_stmt|;
name|mtr
operator|->
name|flags
operator|&=
operator|~
name|METEOR_OPEN
expr_stmt|;
comment|/* XXX stop any capture modes running */
switch|switch
condition|(
name|mtr
operator|->
name|flags
operator|&
name|METEOR_CAP_MASK
condition|)
block|{
case|case
name|METEOR_SINGLE
case|:
comment|/* this should not happen, the read capture  				  should have completed or in the very least 				  recieved a signal before close is called. */
name|mtr
operator|->
name|flags
operator|&=
operator|~
operator|(
name|METEOR_SINGLE
operator||
name|METEOR_SINGLE_MASK
operator|)
expr_stmt|;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|read_intr_wait
argument_list|)
expr_stmt|;
comment|/* continue read */
break|break;
case|case
name|METEOR_CONTIN
case|:
comment|/* continous unsync-ed reading, we can 				   simply turn off the capture */
name|mtr
operator|->
name|flags
operator|&=
operator|~
name|METEOR_CONTIN
expr_stmt|;
operator|*
operator|(
operator|(
specifier|volatile
name|u_long
operator|*
operator|)
name|mtr
operator|->
name|capt_cntrl
operator|)
operator|=
literal|0x0ff0
expr_stmt|;
comment|/* turn off capture */
break|break;
case|case
name|METEOR_SYNCAP
case|:
name|mtr
operator|->
name|flags
operator|&=
operator|~
name|METEOR_SYNCAP
expr_stmt|;
operator|*
operator|(
operator|(
specifier|volatile
name|u_long
operator|*
operator|)
name|mtr
operator|->
name|capt_cntrl
operator|)
operator|=
literal|0x0ff0
expr_stmt|;
comment|/* turn off capture */
name|mtr
operator|->
name|proc
operator|=
name|NULL
expr_stmt|;
name|mtr
operator|->
name|mem
operator|=
name|NULL
expr_stmt|;
name|mtr
operator|->
name|ecurrent
operator|=
name|mtr
operator|->
name|ocurrent
operator|=
literal|1
expr_stmt|;
comment|/* re-initalize the even/odd DMA positions to top of buffer */
operator|*
operator|(
operator|(
specifier|volatile
name|u_long
operator|*
operator|)
name|mtr
operator|->
name|virt_baseaddr
operator|)
operator|=
name|mtr
operator|->
name|bigbuf
expr_stmt|;
operator|*
operator|(
operator|(
specifier|volatile
name|u_long
operator|*
operator|)
name|mtr
operator|->
name|virt_baseaddr
operator|+
literal|3
operator|)
operator|=
operator|*
operator|(
operator|(
specifier|volatile
name|u_long
operator|*
operator|)
name|mtr
operator|->
name|virt_baseaddr
operator|)
operator|+
operator|*
operator|(
operator|(
specifier|volatile
name|u_long
operator|*
operator|)
name|mtr
operator|->
name|virt_baseaddr
operator|+
literal|6
operator|)
expr_stmt|;
break|break;
case|case
literal|0
case|:
break|break;
default|default:
name|printf
argument_list|(
literal|"meteor_close: bad capture state on close %d\n"
argument_list|,
name|mtr
operator|->
name|flags
operator|&
name|METEOR_CAP_MASK
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|METEOR_DEALLOC_PAGES
if|if
condition|(
name|mtr
operator|->
name|bigbuf
condition|)
block|{
name|kmem_free
argument_list|(
name|kernel_map
argument_list|,
name|mtr
operator|->
name|bigbuf
argument_list|,
operator|(
name|mtr
operator|->
name|alloc_pages
operator|*
name|PAGE_SIZE
operator|)
argument_list|)
expr_stmt|;
name|mtr
operator|->
name|bigbuf
operator|=
name|NULL
expr_stmt|;
name|mtr
operator|->
name|alloc_pages
operator|=
literal|0
expr_stmt|;
block|}
else|#
directive|else
ifdef|#
directive|ifdef
name|METEOR_DEALLOC_ABOVE
if|if
condition|(
name|mtr
operator|->
name|bigbuf
operator|&&
name|mtr
operator|->
name|alloc_pages
operator|>
name|METEOR_DEALLOC_ABOVE
condition|)
block|{
name|temp
operator|=
name|METEOR_DEALLOC_ABOVE
operator|-
name|mtr
operator|->
name|alloc_pages
expr_stmt|;
name|kmem_free
argument_list|(
name|kernel_map
argument_list|,
name|mtr
operator|->
name|bigbuf
operator|+
operator|(
operator|(
name|mtr
operator|->
name|alloc_pages
operator|-
name|temp
operator|)
operator|*
name|PAGE_SIZE
operator|)
argument_list|,
operator|(
name|temp
operator|*
name|PAGE_SIZE
operator|)
argument_list|)
expr_stmt|;
name|mtr
operator|->
name|alloc_pages
operator|=
name|METEOR_DEALLOC_ABOVE
expr_stmt|;
block|}
endif|#
directive|endif
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|meteor_read
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|)
block|{
name|meteor_reg_t
modifier|*
name|mtr
decl_stmt|;
name|int
name|unit
decl_stmt|;
name|int
name|status
decl_stmt|;
name|int
name|count
decl_stmt|;
name|unit
operator|=
name|UNIT
argument_list|(
name|minor
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|unit
operator|>=
name|NMETEOR
condition|)
comment|/* unit out of range */
return|return
operator|(
name|ENXIO
operator|)
return|;
name|mtr
operator|=
operator|&
operator|(
name|meteor
index|[
name|unit
index|]
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|mtr
operator|->
name|bigbuf
condition|)
comment|/* no frame buffer allocated (ioctl failed) */
return|return
operator|(
name|ENXIO
operator|)
return|;
if|if
condition|(
name|mtr
operator|->
name|flags
operator|&
name|METEOR_CAP_MASK
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
comment|/* already capturing */
name|count
operator|=
name|mtr
operator|->
name|rows
operator|*
name|mtr
operator|->
name|cols
operator|*
name|mtr
operator|->
name|depth
expr_stmt|;
if|if
condition|(
name|uio
operator|->
name|uio_iov
operator|->
name|iov_len
operator|<
name|count
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|mtr
operator|->
name|flags
operator||=
name|METEOR_SINGLE
operator||
name|METEOR_SINGLE_MASK
expr_stmt|;
operator|*
operator|(
operator|(
specifier|volatile
name|u_long
operator|*
operator|)
name|mtr
operator|->
name|capt_cntrl
operator|)
operator|=
literal|0x0ff3
expr_stmt|;
comment|/* capture */
name|status
operator|=
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|read_intr_wait
argument_list|,
name|METPRI
argument_list|,
literal|"capturing"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|status
condition|)
comment|/* successful capture */
name|status
operator|=
name|uiomove
argument_list|(
operator|(
name|caddr_t
operator|)
name|mtr
operator|->
name|bigbuf
argument_list|,
name|count
argument_list|,
name|uio
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"meteor_read: bad tsleep\n"
argument_list|)
expr_stmt|;
name|mtr
operator|->
name|flags
operator|&=
operator|~
operator|(
name|METEOR_SINGLE
operator||
name|METEOR_SINGLE_MASK
operator|)
expr_stmt|;
return|return
operator|(
name|status
operator|)
return|;
block|}
end_function

begin_function
name|int
name|meteor_write
parameter_list|()
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|meteor_ioctl
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|cmd
parameter_list|,
name|caddr_t
name|arg
parameter_list|,
name|int
name|flag
parameter_list|,
name|struct
name|proc
modifier|*
name|pr
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|int
name|unit
decl_stmt|;
name|int
name|temp
decl_stmt|;
name|meteor_reg_t
modifier|*
name|mtr
decl_stmt|;
name|struct
name|meteor_counts
modifier|*
name|cnt
decl_stmt|;
name|struct
name|meteor_geomet
modifier|*
name|geo
decl_stmt|;
name|struct
name|meteor_mem
modifier|*
name|mem
decl_stmt|;
name|struct
name|meteor_capframe
modifier|*
name|frame
decl_stmt|;
specifier|volatile
name|u_long
modifier|*
name|p
decl_stmt|;
name|vm_offset_t
name|buf
decl_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|arg
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|unit
operator|=
name|UNIT
argument_list|(
name|minor
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|unit
operator|>=
name|NMETEOR
condition|)
comment|/* unit out of range */
return|return
operator|(
name|ENXIO
operator|)
return|;
name|mtr
operator|=
operator|&
operator|(
name|meteor
index|[
name|unit
index|]
operator|)
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|METEORSTATUS
case|:
comment|/* get 7196 status */
name|temp
operator|=
literal|0
expr_stmt|;
name|SAA7196_WRITE
argument_list|(
name|mtr
argument_list|,
literal|0x0d
argument_list|,
name|SAA7196_REG
argument_list|(
name|mtr
argument_list|,
literal|0x0d
argument_list|)
operator||
literal|0x02
argument_list|)
expr_stmt|;
name|SAA7196_READ
argument_list|(
name|mtr
argument_list|)
expr_stmt|;
name|temp
operator||=
operator|(
operator|(
operator|*
operator|(
operator|(
specifier|volatile
name|u_long
operator|*
operator|)
name|mtr
operator|->
name|stat_reg
operator|)
operator|)
operator|&
literal|0xff000000L
operator|)
operator|>>
literal|24
expr_stmt|;
name|SAA7196_WRITE
argument_list|(
name|mtr
argument_list|,
literal|0x0d
argument_list|,
name|SAA7196_REG
argument_list|(
name|mtr
argument_list|,
literal|0x0d
argument_list|)
operator|&
literal|0x02
argument_list|)
expr_stmt|;
name|SAA7196_READ
argument_list|(
name|mtr
argument_list|)
expr_stmt|;
name|temp
operator||=
operator|(
operator|(
operator|*
operator|(
operator|(
specifier|volatile
name|u_long
operator|*
operator|)
name|mtr
operator|->
name|stat_reg
operator|)
operator|)
operator|&
literal|0xff000000L
operator|)
operator|>>
literal|16
expr_stmt|;
operator|*
operator|(
name|u_short
operator|*
operator|)
name|arg
operator|=
name|temp
expr_stmt|;
break|break;
case|case
name|METEORSHUE
case|:
comment|/* set hue */
name|SAA7196_WRITE
argument_list|(
name|mtr
argument_list|,
literal|0x07
argument_list|,
operator|*
operator|(
name|char
operator|*
operator|)
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
name|METEORGHUE
case|:
comment|/* get hue */
operator|*
operator|(
name|char
operator|*
operator|)
name|arg
operator|=
name|SAA7196_REG
argument_list|(
name|mtr
argument_list|,
literal|0x07
argument_list|)
expr_stmt|;
break|break;
case|case
name|METEORSCHCV
case|:
comment|/* set chrominance gain */
name|SAA7196_WRITE
argument_list|(
name|mtr
argument_list|,
literal|0x11
argument_list|,
operator|*
operator|(
name|char
operator|*
operator|)
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
name|METEORGCHCV
case|:
comment|/* get chrominance gain */
operator|*
operator|(
name|char
operator|*
operator|)
name|arg
operator|=
name|SAA7196_REG
argument_list|(
name|mtr
argument_list|,
literal|0x11
argument_list|)
expr_stmt|;
break|break;
case|case
name|METEORSINPUT
case|:
comment|/* set input device */
switch|switch
condition|(
operator|*
operator|(
name|unsigned
name|long
operator|*
operator|)
name|arg
operator|&
name|METEOR_DEV_MASK
condition|)
block|{
case|case
literal|0
case|:
comment|/* default */
case|case
name|METEOR_INPUT_DEV0
case|:
name|mtr
operator|->
name|flags
operator|=
operator|(
name|mtr
operator|->
name|flags
operator|&
operator|~
name|METEOR_DEV_MASK
operator|)
operator||
name|METEOR_DEV0
expr_stmt|;
name|SAA7196_WRITE
argument_list|(
name|mtr
argument_list|,
literal|0x0e
argument_list|,
operator|(
name|SAA7196_REG
argument_list|(
name|mtr
argument_list|,
literal|0x0e
argument_list|)
operator|&
operator|~
literal|0x3
operator|)
operator||
literal|0x0
argument_list|)
expr_stmt|;
break|break;
case|case
name|METEOR_INPUT_DEV1
case|:
name|mtr
operator|->
name|flags
operator|=
operator|(
name|mtr
operator|->
name|flags
operator|&
operator|~
name|METEOR_DEV_MASK
operator|)
operator||
name|METEOR_DEV1
expr_stmt|;
name|SAA7196_WRITE
argument_list|(
name|mtr
argument_list|,
literal|0x0e
argument_list|,
operator|(
name|SAA7196_REG
argument_list|(
name|mtr
argument_list|,
literal|0x0e
argument_list|)
operator|&
operator|~
literal|0x3
operator|)
operator||
literal|0x1
argument_list|)
expr_stmt|;
break|break;
case|case
name|METEOR_INPUT_DEV2
case|:
name|mtr
operator|->
name|flags
operator|=
operator|(
name|mtr
operator|->
name|flags
operator|&
operator|~
name|METEOR_DEV_MASK
operator|)
operator||
name|METEOR_DEV2
expr_stmt|;
name|SAA7196_WRITE
argument_list|(
name|mtr
argument_list|,
literal|0x0e
argument_list|,
operator|(
name|SAA7196_REG
argument_list|(
name|mtr
argument_list|,
literal|0x0e
argument_list|)
operator|&
operator|~
literal|0x3
operator|)
operator||
literal|0x2
argument_list|)
expr_stmt|;
break|break;
case|case
name|METEOR_INPUT_DEV3
case|:
name|mtr
operator|->
name|flags
operator|=
operator|(
name|mtr
operator|->
name|flags
operator|&
operator|~
name|METEOR_DEV_MASK
operator|)
operator||
name|METEOR_DEV3
expr_stmt|;
name|SAA7196_WRITE
argument_list|(
name|mtr
argument_list|,
literal|0x0e
argument_list|,
operator|(
name|SAA7196_REG
argument_list|(
name|mtr
argument_list|,
literal|0x0e
argument_list|)
operator||
literal|0x3
operator|)
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
name|EINVAL
return|;
block|}
break|break;
case|case
name|METEORGINPUT
case|:
comment|/* get input device */
operator|*
operator|(
name|u_long
operator|*
operator|)
name|arg
operator|=
name|mtr
operator|->
name|flags
operator|&
name|METEOR_DEV_MASK
expr_stmt|;
break|break;
case|case
name|METEORSFMT
case|:
comment|/* set input format */
switch|switch
condition|(
operator|*
operator|(
name|unsigned
name|long
operator|*
operator|)
name|arg
operator|&
name|METEOR_FORM_MASK
condition|)
block|{
case|case
literal|0
case|:
comment|/* default */
case|case
name|METEOR_FMT_NTSC
case|:
name|mtr
operator|->
name|flags
operator|=
operator|(
name|mtr
operator|->
name|flags
operator|&
operator|~
name|METEOR_FORM_MASK
operator|)
operator||
name|METEOR_NTSC
expr_stmt|;
name|SAA7196_WRITE
argument_list|(
name|mtr
argument_list|,
literal|0x0d
argument_list|,
operator|(
name|SAA7196_REG
argument_list|(
name|mtr
argument_list|,
literal|0x0d
argument_list|)
operator|&
operator|~
literal|0x01
operator|)
argument_list|)
expr_stmt|;
name|SAA7196_WRITE
argument_list|(
name|mtr
argument_list|,
literal|0x0f
argument_list|,
operator|(
name|SAA7196_REG
argument_list|(
name|mtr
argument_list|,
literal|0x0f
argument_list|)
operator|&
operator|~
literal|0xc0
operator|)
operator||
literal|0x40
argument_list|)
expr_stmt|;
name|SAA7196_WRITE
argument_list|(
name|mtr
argument_list|,
literal|0x22
argument_list|,
literal|0x80
argument_list|)
expr_stmt|;
name|SAA7196_WRITE
argument_list|(
name|mtr
argument_list|,
literal|0x24
argument_list|,
operator|(
name|SAA7196_REG
argument_list|(
name|mtr
argument_list|,
literal|0x24
argument_list|)
operator|&
operator|~
literal|0x0c
operator|)
operator||
literal|0x08
argument_list|)
expr_stmt|;
name|SAA7196_WRITE
argument_list|(
name|mtr
argument_list|,
literal|0x26
argument_list|,
literal|0xf0
argument_list|)
expr_stmt|;
name|SAA7196_WRITE
argument_list|(
name|mtr
argument_list|,
literal|0x28
argument_list|,
operator|(
name|SAA7196_REG
argument_list|(
name|mtr
argument_list|,
literal|0x28
argument_list|)
operator|&
operator|~
literal|0x0c
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|METEOR_FMT_PAL
case|:
name|mtr
operator|->
name|flags
operator|=
operator|(
name|mtr
operator|->
name|flags
operator|&
operator|~
name|METEOR_FORM_MASK
operator|)
operator||
name|METEOR_PAL
expr_stmt|;
name|SAA7196_WRITE
argument_list|(
name|mtr
argument_list|,
literal|0x0d
argument_list|,
operator|(
name|SAA7196_REG
argument_list|(
name|mtr
argument_list|,
literal|0x0d
argument_list|)
operator|&
operator|~
literal|0x01
operator|)
argument_list|)
expr_stmt|;
name|SAA7196_WRITE
argument_list|(
name|mtr
argument_list|,
literal|0x0f
argument_list|,
operator|(
name|SAA7196_REG
argument_list|(
name|mtr
argument_list|,
literal|0x0f
argument_list|)
operator|&
operator|~
literal|0xc0
operator|)
argument_list|)
expr_stmt|;
name|SAA7196_WRITE
argument_list|(
name|mtr
argument_list|,
literal|0x22
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
name|SAA7196_WRITE
argument_list|(
name|mtr
argument_list|,
literal|0x24
argument_list|,
operator|(
name|SAA7196_REG
argument_list|(
name|mtr
argument_list|,
literal|0x24
argument_list|)
operator||
literal|0x0c
operator|)
argument_list|)
expr_stmt|;
name|SAA7196_WRITE
argument_list|(
name|mtr
argument_list|,
literal|0x26
argument_list|,
literal|0x20
argument_list|)
expr_stmt|;
name|SAA7196_WRITE
argument_list|(
name|mtr
argument_list|,
literal|0x28
argument_list|,
operator|(
name|SAA7196_REG
argument_list|(
name|mtr
argument_list|,
literal|0x28
argument_list|)
operator|&
operator|~
literal|0x0c
operator|)
operator||
literal|0x01
argument_list|)
expr_stmt|;
break|break;
case|case
name|METEOR_FMT_SECAM
case|:
name|mtr
operator|->
name|flags
operator|=
operator|(
name|mtr
operator|->
name|flags
operator|&
operator|~
name|METEOR_FORM_MASK
operator|)
operator||
name|METEOR_SECAM
expr_stmt|;
name|SAA7196_WRITE
argument_list|(
name|mtr
argument_list|,
literal|0x0d
argument_list|,
operator|(
name|SAA7196_REG
argument_list|(
name|mtr
argument_list|,
literal|0x0d
argument_list|)
operator|&
operator|~
literal|0x01
operator|)
operator||
literal|0x1
argument_list|)
expr_stmt|;
name|SAA7196_WRITE
argument_list|(
name|mtr
argument_list|,
literal|0x0f
argument_list|,
operator|(
name|SAA7196_REG
argument_list|(
name|mtr
argument_list|,
literal|0x0f
argument_list|)
operator|&
operator|~
literal|0xe0
operator|)
operator||
literal|0x20
argument_list|)
expr_stmt|;
name|SAA7196_WRITE
argument_list|(
name|mtr
argument_list|,
literal|0x22
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
name|SAA7196_WRITE
argument_list|(
name|mtr
argument_list|,
literal|0x24
argument_list|,
operator|(
name|SAA7196_REG
argument_list|(
name|mtr
argument_list|,
literal|0x24
argument_list|)
operator||
literal|0x0c
operator|)
argument_list|)
expr_stmt|;
name|SAA7196_WRITE
argument_list|(
name|mtr
argument_list|,
literal|0x26
argument_list|,
literal|0x20
argument_list|)
expr_stmt|;
name|SAA7196_WRITE
argument_list|(
name|mtr
argument_list|,
literal|0x28
argument_list|,
operator|(
name|SAA7196_REG
argument_list|(
name|mtr
argument_list|,
literal|0x28
argument_list|)
operator|&
operator|~
literal|0x0c
operator|)
operator||
literal|0x01
argument_list|)
expr_stmt|;
break|break;
case|case
name|METEOR_FMT_AUTOMODE
case|:
name|mtr
operator|->
name|flags
operator|=
operator|(
name|mtr
operator|->
name|flags
operator|&
operator|~
name|METEOR_FORM_MASK
operator|)
operator||
name|METEOR_AUTOMODE
expr_stmt|;
name|SAA7196_WRITE
argument_list|(
name|mtr
argument_list|,
literal|0x0d
argument_list|,
operator|(
name|SAA7196_REG
argument_list|(
name|mtr
argument_list|,
literal|0x0d
argument_list|)
operator|&
operator|~
literal|0x01
operator|)
argument_list|)
expr_stmt|;
name|SAA7196_WRITE
argument_list|(
name|mtr
argument_list|,
literal|0x0f
argument_list|,
operator|(
name|SAA7196_REG
argument_list|(
name|mtr
argument_list|,
literal|0x0f
argument_list|)
operator|&
operator|~
literal|0xc0
operator|)
operator||
literal|0x80
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
name|EINVAL
return|;
block|}
break|break;
case|case
name|METEORGFMT
case|:
comment|/* get input format */
operator|*
operator|(
name|u_long
operator|*
operator|)
name|arg
operator|=
name|mtr
operator|->
name|flags
operator|&
name|METEOR_FORM_MASK
expr_stmt|;
break|break;
case|case
name|METEORCAPTUR
case|:
switch|switch
condition|(
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
condition|)
block|{
case|case
name|METEOR_CAP_SINGLE
case|:
if|if
condition|(
operator|!
name|mtr
operator|->
name|bigbuf
condition|)
comment|/* no frame buffer allocated */
return|return
operator|(
name|ENXIO
operator|)
return|;
if|if
condition|(
name|mtr
operator|->
name|flags
operator|&
name|METEOR_CAP_MASK
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
comment|/* already capturing */
name|mtr
operator|->
name|flags
operator||=
name|METEOR_SINGLE
operator||
name|METEOR_SINGLE_MASK
expr_stmt|;
operator|*
operator|(
operator|(
specifier|volatile
name|u_long
operator|*
operator|)
name|mtr
operator|->
name|capt_cntrl
operator|)
operator|=
literal|0x0ff3
expr_stmt|;
comment|/* capture */
name|error
operator|=
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|read_intr_wait
argument_list|,
name|METPRI
argument_list|,
literal|"capturing"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mtr
operator|->
name|flags
operator|&=
operator|~
operator|(
name|METEOR_SINGLE
operator||
name|METEOR_SINGLE_MASK
operator|)
expr_stmt|;
break|break;
case|case
name|METEOR_CAP_CONTINOUS
case|:
if|if
condition|(
operator|!
name|mtr
operator|->
name|bigbuf
condition|)
comment|/* no frame buffer allocated */
return|return
operator|(
name|ENXIO
operator|)
return|;
if|if
condition|(
name|mtr
operator|->
name|flags
operator|&
name|METEOR_CAP_MASK
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
comment|/* already capturing */
name|mtr
operator|->
name|flags
operator||=
name|METEOR_CONTIN
expr_stmt|;
operator|*
operator|(
operator|(
specifier|volatile
name|u_long
operator|*
operator|)
name|mtr
operator|->
name|capt_cntrl
operator|)
operator|=
literal|0x0ff3
expr_stmt|;
comment|/* capture */
break|break;
case|case
name|METEOR_CAP_STOP_CONT
case|:
if|if
condition|(
name|mtr
operator|->
name|flags
operator|&
name|METEOR_CONTIN
condition|)
block|{
name|mtr
operator|->
name|flags
operator|&=
operator|~
name|METEOR_CONTIN
expr_stmt|;
comment|/* turn off capture */
operator|*
operator|(
operator|(
specifier|volatile
name|u_long
operator|*
operator|)
name|mtr
operator|->
name|capt_cntrl
operator|)
operator|=
literal|0x0ff0
expr_stmt|;
block|}
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|METEORCAPFRM
case|:
name|frame
operator|=
operator|(
expr|struct
name|meteor_capframe
operator|*
operator|)
name|arg
expr_stmt|;
if|if
condition|(
operator|!
name|frame
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
switch|switch
condition|(
name|frame
operator|->
name|command
condition|)
block|{
case|case
name|METEOR_CAP_N_FRAMES
case|:
if|if
condition|(
name|mtr
operator|->
name|flags
operator|&
name|METEOR_CAP_MASK
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
if|if
condition|(
name|mtr
operator|->
name|flags
operator|&
name|METEOR_YUV_PLANER
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
operator|!
name|mtr
operator|->
name|bigbuf
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
if|if
condition|(
operator|(
name|mtr
operator|->
name|frames
operator|<
literal|2
operator|)
operator|||
operator|(
name|frame
operator|->
name|lowat
operator|<
literal|1
operator|||
name|frame
operator|->
name|lowat
operator|>=
name|mtr
operator|->
name|frames
operator|)
operator|||
operator|(
name|frame
operator|->
name|hiwat
operator|<
literal|1
operator|||
name|frame
operator|->
name|hiwat
operator|>=
name|mtr
operator|->
name|frames
operator|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|mtr
operator|->
name|flags
operator||=
name|METEOR_SYNCAP
expr_stmt|;
name|mtr
operator|->
name|proc
operator|=
name|pr
expr_stmt|;
comment|/* meteor_mem structure is on the page after the data */
name|mem
operator|=
name|mtr
operator|->
name|mem
operator|=
operator|(
expr|struct
name|meteor_mem
operator|*
operator|)
operator|(
name|mtr
operator|->
name|bigbuf
operator|+
operator|(
operator|(
name|mtr
operator|->
name|rows
operator|*
name|mtr
operator|->
name|cols
operator|*
name|mtr
operator|->
name|depth
operator|*
name|mtr
operator|->
name|frames
operator|+
name|PAGE_SIZE
operator|-
literal|1
operator|)
operator|/
name|PAGE_SIZE
operator|)
operator|*
name|PAGE_SIZE
operator|)
expr_stmt|;
name|mtr
operator|->
name|ecurrent
operator|=
name|mtr
operator|->
name|ocurrent
operator|=
literal|1
expr_stmt|;
name|mem
operator|->
name|signal
operator|=
name|frame
operator|->
name|signal
expr_stmt|;
name|mem
operator|->
name|num_bufs
operator|=
name|mtr
operator|->
name|frames
expr_stmt|;
name|mem
operator|->
name|frame_size
operator|=
name|mtr
operator|->
name|frame_size
operator|=
name|mtr
operator|->
name|rows
operator|*
name|mtr
operator|->
name|cols
operator|*
name|mtr
operator|->
name|depth
expr_stmt|;
comment|/* user and kernel change these */
name|mem
operator|->
name|lowat
operator|=
name|frame
operator|->
name|lowat
expr_stmt|;
name|mem
operator|->
name|hiwat
operator|=
name|frame
operator|->
name|hiwat
expr_stmt|;
name|mem
operator|->
name|active
operator|=
literal|0
expr_stmt|;
name|mem
operator|->
name|num_active_bufs
operator|=
literal|0
expr_stmt|;
operator|*
operator|(
operator|(
name|u_long
operator|*
operator|)
name|mtr
operator|->
name|capt_cntrl
operator|)
operator|=
literal|0x0ff3
expr_stmt|;
break|break;
case|case
name|METEOR_CAP_STOP_FRAMES
case|:
if|if
condition|(
name|mtr
operator|->
name|flags
operator|&
name|METEOR_SYNCAP
condition|)
block|{
name|mtr
operator|->
name|flags
operator|&=
operator|~
name|METEOR_SYNCAP
expr_stmt|;
comment|/* turn off capture */
operator|*
operator|(
operator|(
name|u_long
operator|*
operator|)
name|mtr
operator|->
name|capt_cntrl
operator|)
operator|=
literal|0x0ff0
expr_stmt|;
name|mtr
operator|->
name|proc
operator|=
name|NULL
expr_stmt|;
name|mtr
operator|->
name|mem
operator|=
name|NULL
expr_stmt|;
name|mtr
operator|->
name|ecurrent
operator|=
name|mtr
operator|->
name|ocurrent
operator|=
literal|0
expr_stmt|;
comment|/* re-initalize the even/odd DMA positions to top of buffer*/
comment|/* XXX if a capture is in progress, this may be trouble */
operator|*
operator|(
operator|(
specifier|volatile
name|u_long
operator|*
operator|)
name|mtr
operator|->
name|virt_baseaddr
operator|)
operator|=
name|mtr
operator|->
name|bigbuf
expr_stmt|;
operator|*
operator|(
operator|(
specifier|volatile
name|u_long
operator|*
operator|)
name|mtr
operator|->
name|virt_baseaddr
operator|+
literal|3
operator|)
operator|=
operator|*
operator|(
operator|(
specifier|volatile
name|u_long
operator|*
operator|)
name|mtr
operator|->
name|virt_baseaddr
operator|)
operator|+
operator|*
operator|(
operator|(
specifier|volatile
name|u_long
operator|*
operator|)
name|mtr
operator|->
name|virt_baseaddr
operator|+
literal|6
operator|)
expr_stmt|;
block|}
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|METEORSETGEO
case|:
name|geo
operator|=
operator|(
expr|struct
name|meteor_geomet
operator|*
operator|)
name|arg
expr_stmt|;
comment|/* can't change parameters while capturing */
if|if
condition|(
name|mtr
operator|->
name|flags
operator|&
name|METEOR_CAP_MASK
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
if|if
condition|(
operator|(
name|geo
operator|->
name|columns
operator|&
literal|0x3fe
operator|)
operator|!=
name|geo
operator|->
name|columns
condition|)
block|{
name|printf
argument_list|(
literal|"meteor ioctl: column too large or not even\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|geo
operator|->
name|rows
operator|&
literal|0x7fe
operator|)
operator|!=
name|geo
operator|->
name|rows
condition|)
block|{
name|printf
argument_list|(
literal|"meteor ioctl: rows too large or not even\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
if|if
condition|(
name|geo
operator|->
name|frames
operator|>
literal|32
condition|)
block|{
name|printf
argument_list|(
literal|"meteor ioctl: frames too large\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|error
operator|&&
operator|(
name|temp
operator|=
name|geo
operator|->
name|rows
operator|*
name|geo
operator|->
name|columns
operator|*
name|geo
operator|->
name|frames
operator|*
literal|2
operator|)
condition|)
block|{
if|if
condition|(
name|geo
operator|->
name|oformat
operator|&
name|METEOR_GEO_RGB24
condition|)
name|temp
operator|=
name|temp
operator|*
literal|2
expr_stmt|;
comment|/* meteor_mem structure for SYNC Capture */
if|if
condition|(
name|geo
operator|->
name|frames
operator|>
literal|1
condition|)
name|temp
operator|+=
name|PAGE_SIZE
expr_stmt|;
name|temp
operator|=
operator|(
name|temp
operator|+
name|PAGE_SIZE
operator|-
literal|1
operator|)
operator|/
name|PAGE_SIZE
expr_stmt|;
if|if
condition|(
name|temp
operator|>
name|mtr
operator|->
name|alloc_pages
condition|)
block|{
if|if
condition|(
name|mtr
operator|->
name|bigbuf
condition|)
name|kmem_free
argument_list|(
name|kernel_map
argument_list|,
name|mtr
operator|->
name|bigbuf
argument_list|,
operator|(
name|mtr
operator|->
name|alloc_pages
operator|*
name|PAGE_SIZE
operator|)
argument_list|)
expr_stmt|;
name|mtr
operator|->
name|bigbuf
operator|=
name|vm_page_alloc_contig
argument_list|(
operator|(
name|temp
operator|*
name|PAGE_SIZE
operator|)
argument_list|,
literal|0x100000
argument_list|,
literal|0xffffffff
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
name|mtr
operator|->
name|alloc_pages
operator|=
name|temp
expr_stmt|;
block|}
if|if
condition|(
name|mtr
operator|->
name|bigbuf
condition|)
block|{
name|mtr
operator|->
name|rows
operator|=
name|geo
operator|->
name|rows
expr_stmt|;
name|mtr
operator|->
name|cols
operator|=
name|geo
operator|->
name|columns
expr_stmt|;
name|mtr
operator|->
name|frames
operator|=
name|geo
operator|->
name|frames
expr_stmt|;
block|}
else|else
block|{
name|mtr
operator|->
name|alloc_pages
operator|=
literal|0
expr_stmt|;
name|printf
argument_list|(
literal|"meteor_ioctl: buffer allocation failed\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
block|}
block|}
name|p
operator|=
operator|(
specifier|volatile
name|u_long
operator|*
operator|)
name|mtr
operator|->
name|virt_baseaddr
expr_stmt|;
if|if
condition|(
name|mtr
operator|->
name|bigbuf
condition|)
name|buf
operator|=
name|vtophys
argument_list|(
name|mtr
operator|->
name|bigbuf
argument_list|)
expr_stmt|;
else|else
name|buf
operator|=
literal|0
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|buf
expr_stmt|;
comment|/* even y or even RGB */
comment|/* set end of buffer location */
operator|*
operator|(
name|p
operator|+
literal|36
operator|)
operator|=
operator|*
operator|(
name|p
operator|+
literal|35
operator|)
operator|=
name|buf
operator|+
name|mtr
operator|->
name|alloc_pages
operator|*
name|PAGE_SIZE
expr_stmt|;
switch|switch
condition|(
name|geo
operator|->
name|oformat
operator|&
name|METEOR_PRO_MASK
condition|)
block|{
case|case
literal|0
case|:
comment|/* default */
case|case
name|METEOR_GEO_RGB16
case|:
name|mtr
operator|->
name|depth
operator|=
literal|2
expr_stmt|;
if|if
condition|(
name|mtr
operator|->
name|flags
operator|&
name|METEOR_RGB16
operator|==
literal|0
condition|)
block|{
name|mtr
operator|->
name|flags
operator|=
operator|(
name|mtr
operator|->
name|flags
operator|&
operator|~
operator|(
name|METEOR_RGB24
operator||
name|METEOR_YUV_PACKED
operator||
name|METEOR_YUV_PLANER
operator|)
operator|)
operator||
name|METEOR_RGB16
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
comment|/* recal stride and odd starting point */
operator|*
name|p
operator|++
operator|=
literal|0
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|0
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|buf
operator|+
name|mtr
operator|->
name|cols
operator|*
literal|2
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|0
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* stride */
operator|*
name|p
operator|=
operator|*
operator|(
name|p
operator|+
literal|3
operator|)
operator|=
name|mtr
operator|->
name|cols
operator|*
literal|2
expr_stmt|;
operator|*
operator|(
name|p
operator|+
literal|6
operator|)
operator|=
operator|*
operator|(
name|p
operator|+
literal|7
operator|)
operator|=
literal|0xeeeeee01
expr_stmt|;
comment|/* set up the saa7196 */
name|SAA7196_WRITE
argument_list|(
name|mtr
argument_list|,
literal|0x20
argument_list|,
literal|0x90
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|METEOR_GEO_RGB24
case|:
name|mtr
operator|->
name|depth
operator|=
literal|4
expr_stmt|;
if|if
condition|(
name|mtr
operator|->
name|flags
operator|&
name|METEOR_RGB24
operator|==
literal|0
condition|)
block|{
name|mtr
operator|->
name|flags
operator|=
operator|(
name|mtr
operator|->
name|flags
operator|&
operator|~
operator|(
name|METEOR_RGB16
operator||
name|METEOR_YUV_PACKED
operator||
name|METEOR_YUV_PLANER
operator|)
operator|)
operator||
name|METEOR_RGB24
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
comment|/* recal stride and odd starting point */
operator|*
name|p
operator|++
operator|=
literal|0
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|0
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|buf
operator|+
name|mtr
operator|->
name|cols
operator|*
literal|4
expr_stmt|;
comment|/* routes */
operator|*
name|p
operator|++
operator|=
literal|0
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* stride */
operator|*
name|p
operator|=
operator|*
operator|(
name|p
operator|+
literal|3
operator|)
operator|=
name|mtr
operator|->
name|cols
operator|*
literal|4
expr_stmt|;
comment|/* routes */
operator|*
operator|(
name|p
operator|+
literal|6
operator|)
operator|=
operator|*
operator|(
name|p
operator|+
literal|7
operator|)
operator|=
literal|0x39393900
expr_stmt|;
comment|/* set up the saa7196 */
name|SAA7196_WRITE
argument_list|(
name|mtr
argument_list|,
literal|0x20
argument_list|,
literal|0x92
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|METEOR_GEO_YUV_PLANER
case|:
name|mtr
operator|->
name|depth
operator|=
literal|2
expr_stmt|;
if|if
condition|(
name|mtr
operator|->
name|flags
operator|&
name|METEOR_YUV_PLANER
operator|==
literal|0
condition|)
block|{
name|mtr
operator|->
name|flags
operator|=
operator|(
name|mtr
operator|->
name|flags
operator|&
operator|~
operator|(
name|METEOR_RGB16
operator||
name|METEOR_RGB24
operator||
name|METEOR_YUV_PACKED
operator|)
operator|)
operator||
name|METEOR_YUV_PLANER
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
comment|/* recal stride and odd starting point */
name|temp
operator|=
name|mtr
operator|->
name|rows
operator|*
name|mtr
operator|->
name|cols
expr_stmt|;
comment|/* even u */
operator|*
name|p
operator|++
operator|=
name|buf
operator|+
name|temp
expr_stmt|;
comment|/* even v */
operator|*
name|p
operator|++
operator|=
name|buf
operator|+
name|temp
operator|+
operator|(
name|temp
operator|>>
literal|2
operator|)
expr_stmt|;
comment|/* odd y */
operator|*
name|p
operator|++
operator|=
name|buf
operator|+
name|mtr
operator|->
name|cols
expr_stmt|;
comment|/* odd u */
operator|*
name|p
operator|++
operator|=
name|buf
operator|+
name|temp
operator|+
operator|(
name|temp
operator|>>
literal|1
operator|)
expr_stmt|;
comment|/* odd v */
operator|*
name|p
operator|++
operator|=
name|buf
operator|+
name|temp
operator|+
operator|(
name|temp
operator|>>
literal|1
operator|)
operator|+
operator|(
name|temp
operator|>>
literal|2
operator|)
expr_stmt|;
comment|/* stride */
operator|*
name|p
operator|=
operator|*
operator|(
name|p
operator|+
literal|3
operator|)
operator|=
name|mtr
operator|->
name|cols
expr_stmt|;
comment|/* routes */
operator|*
operator|(
name|p
operator|+
literal|6
operator|)
operator|=
operator|*
operator|(
name|p
operator|+
literal|7
operator|)
operator|=
literal|0xaaaaffc1
expr_stmt|;
comment|/* set up the saa7196 */
name|SAA7196_WRITE
argument_list|(
name|mtr
argument_list|,
literal|0x20
argument_list|,
literal|0x91
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|METEOR_GEO_YUV_PACKED
case|:
name|mtr
operator|->
name|depth
operator|=
literal|2
expr_stmt|;
if|if
condition|(
name|mtr
operator|->
name|flags
operator|&
name|METEOR_YUV_PACKED
operator|==
literal|0
condition|)
block|{
name|mtr
operator|->
name|flags
operator|=
operator|(
name|mtr
operator|->
name|flags
operator|&
operator|~
operator|(
name|METEOR_RGB16
operator||
name|METEOR_RGB24
operator||
name|METEOR_YUV_PLANER
operator|)
operator|)
operator||
name|METEOR_YUV_PACKED
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
comment|/* recal stride and odd starting point */
operator|*
name|p
operator|++
operator|=
literal|0
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|0
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|buf
operator|+
name|mtr
operator|->
name|cols
operator|*
literal|2
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|0
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* stride */
operator|*
name|p
operator|=
operator|*
operator|(
name|p
operator|+
literal|3
operator|)
operator|=
name|mtr
operator|->
name|cols
operator|*
literal|2
expr_stmt|;
comment|/* routes */
operator|*
operator|(
name|p
operator|+
literal|6
operator|)
operator|=
operator|*
operator|(
name|p
operator|+
literal|7
operator|)
operator|=
literal|0xeeeeee41
expr_stmt|;
comment|/* set up the saa7196 */
name|SAA7196_WRITE
argument_list|(
name|mtr
argument_list|,
literal|0x20
argument_list|,
literal|0x91
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
comment|/* invalid arguement */
name|printf
argument_list|(
literal|"meteor_ioctl: invalid output format\n"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
comment|/* set cols */
name|SAA7196_WRITE
argument_list|(
name|mtr
argument_list|,
literal|0x21
argument_list|,
name|mtr
operator|->
name|cols
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|SAA7196_WRITE
argument_list|(
name|mtr
argument_list|,
literal|0x24
argument_list|,
operator|(
operator|(
name|SAA7196_REG
argument_list|(
name|mtr
argument_list|,
literal|0x24
argument_list|)
operator|&
operator|~
literal|0x03
operator|)
operator||
operator|(
operator|(
name|mtr
operator|->
name|cols
operator|>>
literal|8
operator|)
operator|&
literal|0x03
operator|)
operator|)
argument_list|)
expr_stmt|;
comment|/* set rows */
name|SAA7196_WRITE
argument_list|(
name|mtr
argument_list|,
literal|0x25
argument_list|,
operator|(
operator|(
name|mtr
operator|->
name|rows
operator|>>
literal|1
operator|)
operator|&
literal|0xff
operator|)
argument_list|)
expr_stmt|;
name|SAA7196_WRITE
argument_list|(
name|mtr
argument_list|,
literal|0x28
argument_list|,
operator|(
operator|(
name|SAA7196_REG
argument_list|(
name|mtr
argument_list|,
literal|0x28
argument_list|)
operator|&
operator|~
literal|0x03
operator|)
operator||
operator|(
operator|(
name|mtr
operator|->
name|rows
operator|>>
literal|9
operator|)
operator|&
literal|0x03
operator|)
operator|)
argument_list|)
expr_stmt|;
comment|/* set signed/unsigned */
name|SAA7196_WRITE
argument_list|(
name|mtr
argument_list|,
literal|0x30
argument_list|,
operator|(
name|SAA7196_REG
argument_list|(
name|mtr
argument_list|,
literal|0x30
argument_list|)
operator|&
operator|~
literal|0x10
operator|)
operator||
operator|(
operator|(
name|geo
operator|->
name|oformat
operator|&
name|METEOR_GEO_UNSIGNED
operator|)
condition|?
literal|0
else|:
literal|0x10
operator|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|METEORGETGEO
case|:
name|geo
operator|=
operator|(
expr|struct
name|meteor_geomet
operator|*
operator|)
name|arg
expr_stmt|;
name|geo
operator|->
name|rows
operator|=
name|mtr
operator|->
name|rows
expr_stmt|;
name|geo
operator|->
name|columns
operator|=
name|mtr
operator|->
name|cols
expr_stmt|;
name|geo
operator|->
name|frames
operator|=
name|mtr
operator|->
name|frames
expr_stmt|;
name|geo
operator|->
name|oformat
operator|=
name|mtr
operator|->
name|flags
operator|&
name|METEOR_PRO_MASK
expr_stmt|;
break|break;
case|case
name|METEORSCOUNT
case|:
comment|/* (re)set error counts */
name|cnt
operator|=
operator|(
expr|struct
name|meteor_counts
operator|*
operator|)
name|arg
expr_stmt|;
name|mtr
operator|->
name|fifo_errors
operator|=
name|cnt
operator|->
name|fifo_errors
expr_stmt|;
name|mtr
operator|->
name|dma_errors
operator|=
name|cnt
operator|->
name|dma_errors
expr_stmt|;
name|mtr
operator|->
name|frames_captured
operator|=
name|cnt
operator|->
name|frames_captured
expr_stmt|;
break|break;
case|case
name|METEORGCOUNT
case|:
comment|/* get error counts */
name|cnt
operator|=
operator|(
expr|struct
name|meteor_counts
operator|*
operator|)
name|arg
expr_stmt|;
name|cnt
operator|->
name|fifo_errors
operator|=
name|mtr
operator|->
name|fifo_errors
expr_stmt|;
name|cnt
operator|->
name|dma_errors
operator|=
name|mtr
operator|->
name|dma_errors
expr_stmt|;
name|cnt
operator|->
name|frames_captured
operator|=
name|mtr
operator|->
name|frames_captured
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"meteor_ioctl: invalid ioctl request\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOTTY
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|meteor_mmap
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|nprot
parameter_list|)
block|{
name|int
name|unit
decl_stmt|;
name|meteor_reg_t
modifier|*
name|mtr
decl_stmt|;
name|unit
operator|=
name|UNIT
argument_list|(
name|minor
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|unit
operator|>=
name|NMETEOR
condition|)
comment|/* at this point could this happen? */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|mtr
operator|=
operator|&
operator|(
name|meteor
index|[
name|unit
index|]
operator|)
expr_stmt|;
if|if
condition|(
name|nprot
operator|&
name|PROT_EXEC
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|offset
operator|>=
name|mtr
operator|->
name|alloc_pages
operator|*
name|PAGE_SIZE
condition|)
return|return
operator|-
literal|1
return|;
return|return
name|i386_btop
argument_list|(
operator|(
name|vtophys
argument_list|(
name|mtr
operator|->
name|bigbuf
argument_list|)
operator|+
name|offset
operator|)
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NMETEOR> 0 */
end_comment

end_unit

