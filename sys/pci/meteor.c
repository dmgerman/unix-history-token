begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1995 Mark Tinguely and Jim Lowe  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by Mark Tinguely and Jim Lowe  * 4. The name of the author may not be used to endorse or promote products   *    derived from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE  * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,  * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN  * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  * POSSIBILITY OF SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_comment
comment|/*		Change History: 	8/21/95		Release 	8/23/95		On advice from Stefan Esser, added volatile to PCI 			memory pointers to remove PCI caching . 	8/29/95		Fixes suggested by Bruce Evans. 			meteor_mmap should return -1 on error rather than 0. 			unit #> NMETEOR should be unit #>= NMETEOR. 	10/24/95	Turn 50 Hz processing for SECAM and 60 Hz processing 			off for AUTOMODE. 	11/11/95	Change UV from always begin signed to ioctl selected 			to either signed or unsigned. 	12/07/95	Changed 7196 startup codes for 50 Hz as recommended 			by Luigi Rizzo (luigi@iet.unipi.it) 	12/08/95	Clear SECAM bit in PAL/NTSC and set input field count 			bits for 50 Hz mode (PAL/SECAM) before I was setting the 			output count bits. by Luigi Rizzo (luigi@iet.unipi.it) 	12/18/95	Correct odd DMA field (never exceed, but good for safety 			Changed 7196 startup codes for 50 Hz as recommended 			by Luigi Rizzo (luigi@iet.unipi.it) 	12/19/95	Changed field toggle mode to enable (offset 0x3c) 			recommended by luigi@iet.unipi.it 			Added in prototyping, include file, staticizing, 			and DEVFS changes from FreeBSD team. 			Changed the default allocated pages from 151 (NTSC) 			to 217 (PAL). 			Cleaned up some old comments in iic_write(). 			Added a Field (even or odd) only capture mode to  			eliminate the high frequency problems with compression 			algorithms.  Recommended by luigi@iet.unipi.it. 			Changed geometry ioctl so if it couldn't allocated a 			large enough contiguous space, it wouldn't free the 			stuff it already had. 			Added new mode called YUV_422 which delivers the 			data in planer Y followed by U followed by V. This 			differs from the standard YUV_PACKED mode in that 			the chrominance (UV) data is in the correct (different) 			order. This is for programs like vic and mpeg_encode 			so they don't have to reorder the chrominance data. 			Added field count to stats. 			Increment frame count stat if capturing continuous on 			even frame grabs. 			Added my email address to these comments 			(james@cs.uwm.edu) suggested by (luigi@iet.unipt.it :-). 			Changed the user mode signal mechanism to allow the 			user program to be interrupted at the end of a frame 			in any one of the modes.  Added SSIGNAL ioctl. 			Added a SFPS/GFPS ioctl so one may set the frames per 			second that the card catpures.  This code needs to be 			completed. 			Changed the interrupt routine so synchronous capture 			will work on fields or frames and the starting frame 			can be either even or odd. 			Added HALT_N_FRAMES and CONT_N_FRAMES so one could 			stop and continue synchronous capture mode. 			Change the tsleep/wakeup function to wait on mtr 			rather than&read_intr_wait. 	1/22/96		Add option (METEOR_FreeBSD_210) for FreeBSD 2.1 			to compile. 			Changed intr so it only printed errors every 50 times. 			Added unit number to error messages. 			Added get_meteor_mem and enabled range checking. 	1/30/96		Added prelim test stuff for direct video dma transfers 			from Amancio Hasty (hasty@rah.star-gate.com).  Until 			we get some stuff sorted out, this will be ifdef'ed 			with METEOR_DIRECT_VIDEO.  This is very dangerous to 			use at present since we don't check the address that 			is passed by the user!!!!! 	2/26/96		Added special SVIDEO input device type. 	2/27/96		Added meteor_reg.h file and associate types Converted 			meteor.c over to using meteor.h file.  Prompted by 			Lars Jonas Olsson<ljo@po.cwru.edu>. 	2/28/96		Added meteor RGB code from Lars Jonas Olsson<ljo@po.cwru.edu>.  I make some mods to this code, so 			I hope it still works as I don't have an rgb card to 			test with. 	2/29/96<ljo@po.cwru.edu> tested the meteor RGB and supplied 			me with diffs.  Thanks, we now have a working RGB 			version of the driver.  Still need to clean up this 			code. 	3/1/96		Fixed a nasty little bug that was clearing the VTR 			mode bit when the 7196 status was requested. 	3/15/96		Fixed bug introduced in previous version that 			stopped the only fields mode from working. 			Added METEOR{GS}TS ioctl, still needs work. 	3/25/96		Added YUV_9 and YUV_12 modes.  Cleaned up some of the 			code and converted variables to use the new register 			types. 	4/8/96		Fixed the a bug in with the range enable.  Pointed 			out by Jim Bray. 	5/13/96		Fix the FPS ioctl so it actually sets the frames 			per second.  Code supplied by ian@robots.ox.ac.uk. 			The new code implements a new define: 			METEOR_SYSTEM_DEFAULT  which should be defined as 			METEOR_PAL, METEOR_SECAM, or METEOR_NTSC in your system 			configuration file.  If METEOR_SYSTEM_DEFAULT isn't 			defined, and there is not a signal when set_fps is 			called, then the call has no effect. 			Changed the spelling of PLANER to PLANAR as pointed 			out by Paco Hope<paco@cs.virigina.edu> and define 			PLANER to be PLANAR for backward compatibility. 	5/28/95		METEOR_INPUT_DEV_RCA -> METEOR_INPUT_DEV0, not 			METEOR_GEO_DEV0.  Pointed out by Ian Reid,<ian@robots.ox.ac.uk>. 			METEOR_DEV_MASK should be 0x0000f000 and not  			0x2000f000, otherwise METEOR_RGB gets masked 			out.  Pointed out by Ian Reid. 			Changed the fps code to give even distribution for 			low frame rates.  Code supplied by Ian Reid. 			Fix some problems with the RGB version.  Patch supplied 			by<ljo@po.cwru.edu>. 			Added METEOR_FIELD_MODE to include files for a  			future version of this driver. */
end_comment

begin_include
include|#
directive|include
file|"meteor.h"
end_include

begin_include
include|#
directive|include
file|"opt_meteor.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/signalvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/mman.h>
end_include

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|METEOR_FreeBSD_210
argument_list|)
end_if

begin_include
include|#
directive|include
file|<machine/cpu.h>
end_include

begin_comment
comment|/* bootverbose */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_kern.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_extern.h>
end_include

begin_include
include|#
directive|include
file|<pci/pcivar.h>
end_include

begin_include
include|#
directive|include
file|<pci/pcireg.h>
end_include

begin_include
include|#
directive|include
file|<machine/ioctl_meteor.h>
end_include

begin_include
include|#
directive|include
file|<pci/meteor_reg.h>
end_include

begin_decl_stmt
specifier|static
name|void
name|meteor_intr
name|__P
argument_list|(
operator|(
name|void
operator|*
name|arg
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*   * Allocate enough memory for:  *	768x576 RGB 16 or YUV (16 storage bits/pixel) = 884736 = 216 pages  *  * You may override this using the options "METEOR_ALLOC_PAGES=value" in your  * kernel configuration file.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|METEOR_ALLOC_PAGES
end_ifndef

begin_define
define|#
directive|define
name|METEOR_ALLOC_PAGES
value|217
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|METEOR_ALLOC
value|(METEOR_ALLOC_PAGES * PAGE_SIZE)
end_define

begin_decl_stmt
specifier|static
name|meteor_reg_t
name|meteor
index|[
name|NMETEOR
index|]
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|METEOR_NUM
parameter_list|(
name|mtr
parameter_list|)
value|((mtr -&meteor[0])/sizeof(meteor_reg_t))
end_define

begin_define
define|#
directive|define
name|METPRI
value|(PZERO+8)|PCATCH
end_define

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|met_probe
parameter_list|(
name|pcici_t
name|tag
parameter_list|,
name|pcidi_t
name|type
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|met_attach
parameter_list|(
name|pcici_t
name|tag
parameter_list|,
name|int
name|unit
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|u_long
name|met_count
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|pci_device
name|met_device
init|=
block|{
literal|"meteor"
block|,
name|met_probe
block|,
name|met_attach
block|,
operator|&
name|met_count
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|COMPAT_PCI_DRIVER
argument_list|(
name|meteor
argument_list|,
name|met_device
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|#
directive|if
name|defined
argument_list|(
name|METEOR_FreeBSD_210
argument_list|)
end_if

begin_comment
comment|/* XXX */
end_comment

begin_decl_stmt
name|d_open_t
name|meteor_open
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|d_close_t
name|meteor_close
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|d_read_t
name|meteor_read
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|d_write_t
name|meteor_write
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|d_ioctl_t
name|meteor_ioctl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|d_mmap_t
name|meteor_mmap
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|static
name|d_open_t
name|meteor_open
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_close_t
name|meteor_close
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_read_t
name|meteor_read
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_write_t
name|meteor_write
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_ioctl_t
name|meteor_ioctl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_mmap_t
name|meteor_mmap
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|CDEV_MAJOR
value|67
end_define

begin_decl_stmt
specifier|static
name|struct
name|cdevsw
name|meteor_cdevsw
init|=
block|{
comment|/* open */
name|meteor_open
block|,
comment|/* close */
name|meteor_close
block|,
comment|/* read */
name|meteor_read
block|,
comment|/* write */
name|meteor_write
block|,
comment|/* ioctl */
name|meteor_ioctl
block|,
comment|/* poll */
name|nopoll
block|,
comment|/* mmap */
name|meteor_mmap
block|,
comment|/* strategy */
name|nostrategy
block|,
comment|/* name */
literal|"meteor"
block|,
comment|/* maj */
name|CDEV_MAJOR
block|,
comment|/* dump */
name|nodump
block|,
comment|/* psize */
name|nopsize
block|,
comment|/* flags */
literal|0
block|,
comment|/* bmaj */
operator|-
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|mreg_t
name|saa7116_pci_default
index|[
sizeof|sizeof
argument_list|(
expr|struct
name|saa7116_regs
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|mreg_t
argument_list|)
index|]
init|=
block|{
comment|/* PCI Memory registers	    	*/
comment|/* BITS	  Type	Description	*/
comment|/* 0x00 */
literal|0x00000000
block|,
comment|/* 31:1   e*RW	DMA 1 (Even) 				      0   RO    0x0 		*/
comment|/* 0x04 */
literal|0x00000000
block|,
comment|/* 31:2   e*RW	DMA 2 (Even) 				    1:0   RO	0x0		*/
comment|/* 0x08 */
literal|0x00000000
block|,
comment|/* 31:2   e*RW  DMA 3 (Even) 				    1:0   RO    0x0		*/
comment|/* 0x0c */
literal|0x00000000
block|,
comment|/* 31:1   o*RW	DMA 1 (Odd) 				      0   RO	0x0		*/
comment|/* 0x10 */
literal|0x00000000
block|,
comment|/* 31:2	  o*RW	DMA 2 (Odd) 				    1:0	  RO	0x0		*/
comment|/* 0x14 */
literal|0x00000000
block|,
comment|/* 31:2   o*RW	DMA 3 (Odd) 				    1:0   RO	0x0		*/
comment|/* 0x18 */
literal|0x00000500
block|,
comment|/* 15:2   e*RW  Stride 1 (Even) 				    1:0   RO	0x0		*/
comment|/* 0x1c */
literal|0x00000000
block|,
comment|/* 15:2	  e*RW	Stride 2 (Even) 				    1:0	  RO	0x0		*/
comment|/* 0x20 */
literal|0x00000000
block|,
comment|/* 15:2	  e*RW	Stride 3 (Even) 				    1:0	  RO	0x0		*/
comment|/* 0x24 */
literal|0x00000500
block|,
comment|/* 15:2	  o*RW	Stride 1 (Odd) 				    1:0	  RO	0x0		*/
comment|/* 0x28 */
literal|0x00000000
block|,
comment|/* 15:2	  o*RW	Stride 2 (Odd) 				    1:0	  RO	0x0		*/
comment|/* 0x2c */
literal|0x00000000
block|,
comment|/* 15:2	  o*RW	Stride 3 (Odd) 				    1:0	  RO	0x0		*/
comment|/* 0x30 */
literal|0xeeeeee01
block|,
comment|/* 31:8	  *RW	Route (Even) 				    7:0	  *RW	Mode (Even)	*/
comment|/* 0x34 */
literal|0xeeeeee01
block|,
comment|/* 31:8	  *RW	Route (Odd) 				    7:0	  *RW	Mode (Odd)	*/
comment|/* 0x38 */
literal|0x00200020
block|,
comment|/* 22:16  *RW	FIFO Trigger Planer Mode, 				    6:0	  *RW	FIFO Trigger Packed Mode */
comment|/* 0x3c */
literal|0x00000107
block|,
comment|/*  9:8   *RW	Reserved (0x0) 				      2	  *RW	Field Toggle 				      1	  *RW	Reserved (0x1) 				      0	  *RW	Reserved (0x1)		*/
comment|/* 0x40 */
literal|0x000000c0
block|,
comment|/*    15  *RW	Range Enable 				      14  *RW	Corrupt Disable 				      11  *RR	Address Error (Odd) 				      10  *RR	Address Error (Even) 				      9   *RR	Field Corrupt (Odd) 				      8   *RR	Field Corrupt (Even) 				      7	  *RW	Fifo Enable 				      6   *RW	VRSTN# 				      5	  *RR	Field Done (Odd) 				      4   *RR	Field Done (Even) 				      3	  *RS	Single Field Capture (Odd) 				      2	  *RS	Single Field Capture (Even) 				      1	  *RW	Capture (ODD) Continous 				      0	  *RW	Capture (Even) Continous */
comment|/* 0x44 */
literal|0x00000000
block|,
comment|/*  7:0	  *RW	Retry Wait Counter */
comment|/* 0x48 */
literal|0x00000307
block|,
comment|/*    10  *RW	Interrupt mask, start of field 				      9   *RW	Interrupt mask, end odd field 				      8	  *RW	Interrupt mask, end even field 				      2   *RR	Interrupt status, start of field 				      1   *RR	Interrupt status, end of odd 				      0	  *RR	Interrupt status, end of even */
comment|/* 0x4c */
literal|0x00000001
block|,
comment|/* 31:0   *RW	Field Mask (Even) continous */
comment|/* 0x50 */
literal|0x00000001
block|,
comment|/* 31:0   *RW	Field Mask (Odd) continous */
comment|/* 0x54 */
literal|0x00000000
block|,
comment|/* 20:16  *RW	Mask Length (Odd) 				    4:0	  *RW	Mask Length (Even)	*/
comment|/* 0x58 */
literal|0x0005007c
block|,
comment|/* 22:16  *RW	FIFO almost empty 				    6:0	  *RW	FIFO almost full	*/
comment|/* 0x5c */
literal|0x461e1e0f
block|,
comment|/* 31:24  *RW	I2C Phase 4 				   23:16  *RW	I2C Phase 3 				   15:8   *RW	I2C Phase 2 				    7:0	  *RW	I2C Phase 1	*/
comment|/* 0x60 */
literal|0x00000300
block|,
comment|/* 31:24  *RO	I2C Read Data 				   23:16  **RW  I2C Auto Address 				      11  RO	I2C SCL Input 				      10  RO	I2C SDA Input 				      9	  RR	I2C Direct Abort 				      8   RR	I2C Auto Abort 				      3   RW	I2C SCL Output 				      2   RW	I2C SDA Output 				      1	  RW	I2C Bypass 				      0	  RW	I2C Auto Enable	*/
comment|/* 0x64 */
literal|0x00000000
block|,
comment|/*    24  RS	I2C New Cycle 				   23:16  **RW	I2C Direct Address 				   15:8   **RW	I2C Direct Sub-address 				    7:0	  **RW	I2C Direct Write Address */
comment|/* 0x68 */
literal|0x00000000
block|,
comment|/* 31:24  **RW  I2C Auto Sub-address 1 (Even) 				   23:16  **RW  I2C Auto Data 1 (Even) 				   15:8   **RW  I2C Auto Sub-address 0 (Even) 				    7:0	  **RW	I2C Auto Data 0 (Even) */
comment|/* 0x6c */
literal|0x00000000
block|,
comment|/* 31:24  **RW  I2C Auto Sub-address 3 (Even) 				   23:16  **RW  I2C Auto Data 3 (Even) 				   15:8   **RW  I2C Auto Sub-address 2 (Even) 				    7:0	  **RW	I2C Auto Data 2 (Even) */
comment|/* 0x70 */
literal|0x00000000
block|,
comment|/* 31:24  **RW  I2C Auto Sub-address 5 (Even) 				   23:16  **RW  I2C Auto Data 5 (Even) 				   15:8   **RW  I2C Auto Sub-address 4 (Even) 				    7:0	  **RW	I2C Auto Data 4 (Even) */
comment|/* 0x74 */
literal|0x00000000
block|,
comment|/* 31:24  **RW  I2C Auto Sub-address 7 (Even) 				   23:16  **RW  I2C Auto Data 7 (Even) 				   15:8   **RW  I2C Auto Sub-address 6 (Even) 				    7:0	  **RW	I2C Auto Data 6 (Even) */
comment|/* 0x78 */
literal|0x00000000
block|,
comment|/* 31:24  **RW  I2C Auto Sub-address 1 (Odd) 				   23:16  **RW  I2C Auto Data 1 (Odd) 				   15:8   **RW  I2C Auto Sub-address 0 (Odd) 				    7:0	  **RW	I2C Auto Data 0 (Odd) */
comment|/* 0x7c */
literal|0x00000000
block|,
comment|/* 31:24  **RW  I2C Auto Sub-address 3 (Odd) 				   23:16  **RW  I2C Auto Data 3 (Odd) 				   15:8   **RW  I2C Auto Sub-address 2 (Odd) 				    7:0	  **RW	I2C Auto Data 2 (Odd) */
comment|/* 0x80 */
literal|0x00000000
block|,
comment|/* 31:24  **RW  I2C Auto Sub-address 5 (Odd) 				   23:16  **RW  I2C Auto Data 5 (Odd) 				   15:8   **RW  I2C Auto Sub-address 4 (Odd) 				    7:0	  **RW	I2C Auto Data 4 (Odd) */
comment|/* 0x84 */
literal|0x00000000
block|,
comment|/* 31:24  **RW  I2C Auto Sub-address 7 (Odd) 				   23:16  **RW  I2C Auto Data 7 (Odd) 				   15:8   **RW  I2C Auto Sub-address 6 (Odd) 				    7:0	  **RW	I2C Auto Data 6 (Odd) */
comment|/* 0x88 */
literal|0x00000000
block|,
comment|/* 23:16  **RW	I2C Register Enable (Odd) 				    7:0	  **RW	I2C Register Enable (Even) */
comment|/* 0x8c */
literal|0x00000000
block|,
comment|/* 23:2	  e*RW	DMA End (Even) 				    1:0	  RO	0x0	*/
comment|/* 0x90 */
literal|0x00000000
comment|/* 23:2	  e*RW	DMA End (Odd) 				    1:0	  RO	0x0	*/
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_char
name|saa7196_i2c_default
index|[
name|NUM_SAA7196_I2C_REGS
index|]
init|=
block|{
comment|/* SAA7196 I2C bus control			*/
comment|/* BITS	Function				*/
comment|/* 00 */
literal|0x50
block|,
comment|/* 7:0	Increment Delay				*/
comment|/* 01 */
literal|0x30
block|,
comment|/* 7:0	Horizontal Sync Begin for 50hz		*/
comment|/* 02 */
literal|0x00
block|,
comment|/* 7:0	Horizontal Sync Stop for 50hz		*/
comment|/* 03 */
literal|0xe8
block|,
comment|/* 7:0	Horizontal Sync Clamp Start for 50hz	*/
comment|/* 04 */
literal|0xb6
block|,
comment|/* 7:0	Horizontal Sync Clamp Stop for 50hz 	*/
comment|/* 05 */
literal|0xf4
block|,
comment|/* 7:0	Horizontal Sync Start after PH1 for 50hz */
comment|/* 06 */
literal|0x46
block|,
comment|/*   7	Input mode =0 CVBS, =1 S-Video  			     6	Pre filter 			   5:4  Aperture Bandpass characteristics 			   3:2	Coring range for high freq 			   1:0	Aperture bandpass filter weights	*/
comment|/* 07 */
literal|0x00
block|,
comment|/* 7:0	Hue					*/
comment|/* 08 */
literal|0x7f
block|,
comment|/* 7:3	Colour-killer threshold QAM (PAL, NTSC) */
comment|/* 09 */
literal|0x7f
block|,
comment|/* 7:3	Colour-killer threshold SECAM		*/
comment|/* 0a */
literal|0x7f
block|,
comment|/* 7:0	PAL switch sensitivity			*/
comment|/* 0b */
literal|0x7f
block|,
comment|/* 7:0	SECAM switch sensitivity		*/
comment|/* 0c */
literal|0x40
block|,
comment|/*   7	Colour-on bit 			   6:5	AGC filter				*/
comment|/* 0d */
literal|0x84
block|,
comment|/*   7	VTR/TV mode bit = 1->VTR mode 			     3	Realtime output mode select bit 			     2	HREF position select 			     1	Status byte select 			     0	SECAM mode bit				*/
comment|/* 0e */
literal|0x38
block|,
comment|/*   7	Horizontal clock PLL 			     5	Select interal/external clock source 			     4	Output enable of Horizontal/Vertical sync 			     3	Data output YUV enable 			     2	S-VHS bit 			     1	GPSW2 			     0	GPSW1					*/
comment|/* 0f */
literal|0x50
block|,
comment|/*   7	Automatic Field detection 			     6	Field Select 0 = 50hz, 1=60hz 			     5	SECAM cross-colour reduction 			     4	Enable sync and clamping pulse 			   3:1	Luminance delay compensation		*/
comment|/* 10 */
literal|0x00
block|,
comment|/*   2	Select HREF Position 			   1:0  Vertical noise reduction		*/
comment|/* 11 */
literal|0x2c
block|,
comment|/* 7:0	Chrominance gain conrtol for QAM	*/
comment|/* 12 */
literal|0x40
block|,
comment|/* 7:0	Chrominance saturation control for VRAM port */
comment|/* 13 */
literal|0x40
block|,
comment|/* 7:0	Luminance contract control for VRAM port */
comment|/* 14 */
literal|0x34
block|,
comment|/* 7:0	Horizontal sync begin for 60hz		*/
ifdef|#
directive|ifdef
name|notdef
comment|/* 15 */
literal|0x0c
block|,
comment|/* 7:0	Horizontal sync stop for 60hz		*/
comment|/* 16 */
literal|0xfb
block|,
comment|/* 7:0	Horizontal clamp begin for 60hz		*/
comment|/* 17 */
literal|0xd4
block|,
comment|/* 7:0	Horizontal clamp stop for 60hz		*/
comment|/* 18 */
literal|0xec
block|,
comment|/* 7:0	Horizontal sync start after PH1 for 60hz */
else|#
directive|else
literal|0x0a
block|,
literal|0xf4
block|,
literal|0xce
block|,
literal|0xf4
block|,
endif|#
directive|endif
comment|/* 19 */
literal|0x80
block|,
comment|/* 7:0	Luminance brightness control for VRAM port */
comment|/* 1a */
literal|0x00
block|,
comment|/* 1b */
literal|0x00
block|,
comment|/* 1c */
literal|0x00
block|,
comment|/* 1d */
literal|0x00
block|,
comment|/* 1e */
literal|0x00
block|,
comment|/* 1f */
literal|0x00
block|,
comment|/* 20 */
literal|0x90
block|,
comment|/*   7	ROM table bypass switch 			   6:5	Set output field mode 			     4	VRAM port outputs enable 			   3:2	First pixel position in VRO data 			   1:0	FIFO output register select		*/
comment|/* 21 */
literal|0x80
block|,
comment|/* 7:0	[7:0] Pixel number per line on output	*/
comment|/* 22 */
literal|0x80
block|,
comment|/* 7:0	[7:0] Pixel number per line on input	*/
comment|/* 23 */
literal|0x03
block|,
comment|/* 7:0	[7:0] Horizontal start position of scaling win*/
comment|/* 24 */
literal|0x8a
block|,
comment|/* 7:5	Horizontal decimation filter 			     4  [8] Horizontal start position of scaling win 			   3:2	[9:8] Pixel number per line on input 			   1:0  [9:8] Pixel number per line on output 	*/
comment|/* 25 */
literal|0xf0
block|,
comment|/* 7:0	[7:0] Line number per output field	*/
comment|/* 26 */
literal|0xf0
block|,
comment|/* 7:0	[7:0] Line number per input field	*/
comment|/* 27 */
literal|0x0f
block|,
comment|/* 7:0	[7:0] Vertical start of scaling window	*/
comment|/* 28 */
literal|0x80
block|,
comment|/*   7	Adaptive filter switch 			   6:5	Vertical luminance data processing 			     4	[8] Vertical start of scaling window  			   3:2  [9:8] Line number per input field 			   1:0	[9:8] Line number per output field	*/
comment|/* 29 */
literal|0x16
block|,
comment|/* 7:0	[7:0] Vertical bypass start		*/
comment|/* 2a */
literal|0x00
block|,
comment|/* 7:0	[7:0] Vertical bypass count		*/
comment|/* 2b */
literal|0x00
block|,
comment|/*   4  [8] Vertical bypass start 			     2  [8] Vertical bypass count 			     0	Polarity, internally detected odd even flag */
comment|/* 2c */
literal|0x80
block|,
comment|/* 7:0	Set lower limit V for colour-keying	*/
comment|/* 2d */
literal|0x7f
block|,
comment|/* 7:0	Set upper limit V for colour-keying	*/
comment|/* 2e */
literal|0x80
block|,
comment|/* 7:0	Set lower limit U for colour-keying	*/
comment|/* 2f */
literal|0x7f
block|,
comment|/* 7:0	Set upper limit U for colour-keying	*/
comment|/* 30 */
literal|0xbf
comment|/*   7	VRAM bus output format 			     6	Adaptive geometrical filter 			     5	Luminance limiting value 			     4	Monochrome and two's complement output data sel 			     3	Line quailifier flag 			     2	Pixel qualifier flag 			     1	Transparent data transfer 			     0	Extended formats enable bit		*/
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_char
name|bt254_default
index|[
name|NUM_BT254_REGS
index|]
init|=
block|{
literal|0x00
block|,
comment|/* 24 bpp */
literal|0xa0
block|,
literal|0xa0
block|,
literal|0xa0
block|,
literal|0x50
block|,
literal|0x50
block|,
literal|0x50
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * i2c_write:  * Returns	0	Succesful completion.  * Returns	1	If transfer aborted or timeout occured.  *  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|i2c_print_err
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|i2c_write
parameter_list|(
name|meteor_reg_t
modifier|*
name|mtr
parameter_list|,
name|u_char
name|slave
parameter_list|,
name|u_char
name|rw
parameter_list|,
name|u_char
name|reg
parameter_list|,
name|u_char
name|data
parameter_list|)
block|{
specifier|register
name|unsigned
name|long
name|wait_counter
init|=
literal|0x0001ffff
decl_stmt|;
specifier|register
name|mreg_t
modifier|*
name|iic_write_loc
init|=
operator|&
name|mtr
operator|->
name|base
operator|->
name|i2c_write
decl_stmt|;
specifier|register
name|int
name|err
init|=
literal|0
decl_stmt|;
comment|/* Write the data the the i2c write register */
operator|*
name|iic_write_loc
operator|=
name|SAA7116_IIC_NEW_CYCLE
operator||
operator|(
operator|(
operator|(
name|u_long
operator|)
name|slave
operator||
operator|(
name|u_long
operator|)
name|rw
operator|)
operator|<<
literal|16
operator|)
operator||
operator|(
operator|(
name|u_long
operator|)
name|reg
operator|<<
literal|8
operator|)
operator||
operator|(
name|u_long
operator|)
name|data
expr_stmt|;
comment|/* Wait until the i2c cycle is compeleted */
while|while
condition|(
operator|(
operator|*
name|iic_write_loc
operator|&
name|SAA7116_IIC_NEW_CYCLE
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|wait_counter
condition|)
break|break;
name|wait_counter
operator|--
expr_stmt|;
block|}
comment|/* 1ffff should be enough delay time for the i2c cycle to complete */
if|if
condition|(
operator|!
name|wait_counter
condition|)
block|{
if|if
condition|(
name|i2c_print_err
condition|)
name|printf
argument_list|(
literal|"meteor%d: %d i2c %s transfer timeout 0x%x"
argument_list|,
name|METEOR_NUM
argument_list|(
name|mtr
argument_list|)
argument_list|,
name|slave
argument_list|,
name|rw
condition|?
literal|"read"
else|:
literal|"write"
argument_list|,
operator|*
name|iic_write_loc
argument_list|)
expr_stmt|;
name|err
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Check for error on direct write, clear if any */
if|if
condition|(
name|mtr
operator|->
name|base
operator|->
name|i2c_read
operator|&
name|SAA7116_IIC_DIRECT_TRANSFER_ABORTED
condition|)
block|{
name|mtr
operator|->
name|base
operator|->
name|i2c_read
operator||=
name|SAA7116_IIC_DIRECT_TRANSFER_ABORTED
expr_stmt|;
if|if
condition|(
name|i2c_print_err
condition|)
name|printf
argument_list|(
literal|"meteor%d: 0x%x i2c %s tranfer aborted"
argument_list|,
name|METEOR_NUM
argument_list|(
name|mtr
argument_list|)
argument_list|,
name|slave
argument_list|,
name|rw
condition|?
literal|"read"
else|:
literal|"write"
argument_list|)
expr_stmt|;
name|err
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|err
condition|)
block|{
if|if
condition|(
name|i2c_print_err
condition|)
name|printf
argument_list|(
literal|" - reg=0x%x, value=0x%x.\n"
argument_list|,
name|reg
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
return|return
name|err
return|;
block|}
end_function

begin_undef
undef|#
directive|undef
name|i2c_print
end_undef

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|met_probe
parameter_list|(
name|pcici_t
name|tag
parameter_list|,
name|pcidi_t
name|type
parameter_list|)
block|{
specifier|static
name|int
name|once
decl_stmt|;
if|if
condition|(
operator|!
name|once
operator|++
condition|)
name|cdevsw_add
argument_list|(
operator|&
name|meteor_cdevsw
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|SAA7116_PHILIPS_ID
case|:
comment|/* meteor */
return|return
operator|(
literal|"Philips SAA 7116"
operator|)
return|;
block|}
empty_stmt|;
return|return
operator|(
operator|(
name|char
operator|*
operator|)
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* interrupt handling routine  	   complete meteor_read() if using interrupts 	*/
end_comment

begin_function
specifier|static
name|void
name|meteor_intr
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|meteor_reg_t
modifier|*
name|mtr
init|=
operator|(
name|meteor_reg_t
operator|*
operator|)
name|arg
decl_stmt|;
name|mreg_t
modifier|*
name|cap
init|=
operator|&
name|mtr
operator|->
name|base
operator|->
name|cap_cntl
decl_stmt|,
modifier|*
name|base
init|=
operator|&
name|mtr
operator|->
name|base
operator|->
name|dma1e
decl_stmt|,
modifier|*
name|stat
init|=
operator|&
name|mtr
operator|->
name|base
operator|->
name|irq_stat
decl_stmt|;
name|u_long
name|status
init|=
operator|*
name|stat
decl_stmt|,
name|cap_err
init|=
operator|*
name|cap
operator|&
literal|0x00000f00
decl_stmt|,
ifdef|#
directive|ifdef
name|METEOR_CHECK_PCI_BUS
name|pci_err
init|=
name|pci_conf_read
argument_list|(
name|mtr
operator|->
name|tag
argument_list|,
name|PCI_COMMAND_STATUS_REG
argument_list|)
decl_stmt|,
endif|#
directive|endif
name|next_base
init|=
call|(
name|u_long
call|)
argument_list|(
name|vtophys
argument_list|(
name|mtr
operator|->
name|bigbuf
argument_list|)
argument_list|)
decl_stmt|;
comment|/* 	 * Disable future interrupts if a capture mode is not selected. 	 * This can happen when we are in the process of closing or  	 * changing capture modes, otherwise it shouldn't happen. 	 */
if|if
condition|(
operator|!
operator|(
name|mtr
operator|->
name|flags
operator|&
name|METEOR_CAP_MASK
operator|)
condition|)
block|{
operator|*
name|cap
operator|&=
literal|0x8ff0
expr_stmt|;
comment|/* disable future interrupts */
block|}
ifdef|#
directive|ifdef
name|METEOR_CHECK_PCI_BUS
comment|/* 	 * Check for pci bus errors. 	 */
define|#
directive|define
name|METEOR_MASTER_ABORT
value|0x20000000
define|#
directive|define
name|METEOR_TARGET_ABORT
value|0x10000000
if|if
condition|(
name|pci_err
operator|&
name|METEOR_MASTER_ABORT
condition|)
block|{
name|printf
argument_list|(
literal|"meteor%d: intr: pci bus master dma abort: 0x%x 0x%x.\n"
argument_list|,
name|METEOR_NUM
argument_list|(
name|mtr
argument_list|)
argument_list|,
operator|*
name|base
argument_list|,
operator|*
operator|(
name|base
operator|+
literal|3
operator|)
argument_list|)
expr_stmt|;
name|pci_conf_write
argument_list|(
name|mtr
operator|->
name|tag
argument_list|,
name|PCI_COMMAND_STATUS_REG
argument_list|,
name|pci_err
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pci_err
operator|&
name|METEOR_TARGET_ABORT
condition|)
block|{
name|printf
argument_list|(
literal|"meteor%d: intr: pci bus target dma abort: 0x%x 0x%x.\n"
argument_list|,
name|METEOR_NUM
argument_list|(
name|mtr
argument_list|)
argument_list|,
operator|*
name|base
argument_list|,
operator|*
operator|(
name|base
operator|+
literal|3
operator|)
argument_list|)
expr_stmt|;
name|pci_conf_write
argument_list|(
name|mtr
operator|->
name|tag
argument_list|,
name|PCI_COMMAND_STATUS_REG
argument_list|,
name|pci_err
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* 	 * Check for errors. 	 */
if|if
condition|(
name|cap_err
condition|)
block|{
if|if
condition|(
name|cap_err
operator|&
literal|0x300
condition|)
block|{
if|if
condition|(
name|mtr
operator|->
name|fifo_errors
operator|%
literal|50
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"meteor%d: capture error"
argument_list|,
name|METEOR_NUM
argument_list|(
name|mtr
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|": %s FIFO overflow.\n"
argument_list|,
name|cap_err
operator|&
literal|0x0100
condition|?
literal|"even"
else|:
literal|"odd"
argument_list|)
expr_stmt|;
block|}
name|mtr
operator|->
name|fifo_errors
operator|++
expr_stmt|;
comment|/* increment fifo capture errors cnt */
block|}
if|if
condition|(
name|cap_err
operator|&
literal|0xc00
condition|)
block|{
if|if
condition|(
name|mtr
operator|->
name|dma_errors
operator|%
literal|50
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"meteor%d: capture error"
argument_list|,
name|METEOR_NUM
argument_list|(
name|mtr
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|": %s DMA address.\n"
argument_list|,
name|cap_err
operator|&
literal|0x0400
condition|?
literal|"even"
else|:
literal|"odd"
argument_list|)
expr_stmt|;
block|}
name|mtr
operator|->
name|dma_errors
operator|++
expr_stmt|;
comment|/* increment DMA capture errors cnt */
block|}
block|}
operator|*
name|cap
operator||=
literal|0x0f30
expr_stmt|;
comment|/* clear error and field done */
comment|/* 	 * In synchronous capture mode we need to know what the address 	 * offset for the next field/frame will be.  next_base holds the 	 * value for the even dma buffers (for odd, one must add stride). 	 */
if|if
condition|(
operator|(
name|mtr
operator|->
name|flags
operator|&
name|METEOR_SYNCAP
operator|)
operator|&&
operator|!
name|mtr
operator|->
name|synch_wait
operator|&&
operator|(
name|mtr
operator|->
name|current
operator|<
name|mtr
operator|->
name|frames
operator|)
condition|)
block|{
comment|/* could be !=, but< is safer */
comment|/* next_base is initialized to mtr->bigbuf */
name|next_base
operator|+=
name|mtr
operator|->
name|frame_size
operator|*
name|mtr
operator|->
name|current
expr_stmt|;
if|if
condition|(
name|mtr
operator|->
name|flags
operator|&
name|METEOR_WANT_TS
condition|)
name|next_base
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|timeval
argument_list|)
operator|*
name|mtr
operator|->
name|current
expr_stmt|;
block|}
comment|/* 	 * Count the field and clear the field flag. 	 * 	 * In single mode capture, clear the continuous capture mode. 	 * 	 * In synchronous capture mode, if we have room for another field, 	 * adjust DMA buffer pointers. 	 * When we are above the hi water mark (hiwat), mtr->synch_wait will 	 * be set and we will not bump the DMA buffer pointers.  Thus, once 	 * we reach the hi water mark,  the driver acts like a continuous mode 	 * capture on the mtr->current frame until we hit the low water 	 * mark (lowat).  The user had the option of stopping or halting 	 * the capture if this is not the desired effect. 	 */
if|if
condition|(
name|status
operator|&
literal|0x1
condition|)
block|{
comment|/* even field */
name|mtr
operator|->
name|even_fields_captured
operator|++
expr_stmt|;
name|mtr
operator|->
name|flags
operator|&=
operator|~
name|METEOR_WANT_EVEN
expr_stmt|;
if|if
condition|(
operator|(
name|mtr
operator|->
name|flags
operator|&
name|METEOR_SYNCAP
operator|)
operator|&&
operator|!
name|mtr
operator|->
name|synch_wait
condition|)
block|{
operator|*
name|base
operator|=
name|next_base
expr_stmt|;
comment|/* XXX should add adjustments for YUV_422& PLANAR */
block|}
comment|/* 		 * If the user requested to be notified via signal, 		 * let them know the field is complete. 		 */
if|if
condition|(
name|mtr
operator|->
name|proc
operator|&&
operator|(
name|mtr
operator|->
name|signal
operator|&
name|METEOR_SIG_MODE_MASK
operator|)
condition|)
name|psignal
argument_list|(
name|mtr
operator|->
name|proc
argument_list|,
name|mtr
operator|->
name|signal
operator|&
operator|(
operator|~
name|METEOR_SIG_MODE_MASK
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|status
operator|&
literal|0x2
condition|)
block|{
comment|/* odd field */
name|mtr
operator|->
name|odd_fields_captured
operator|++
expr_stmt|;
name|mtr
operator|->
name|flags
operator|&=
operator|~
name|METEOR_WANT_ODD
expr_stmt|;
if|if
condition|(
operator|(
name|mtr
operator|->
name|flags
operator|&
name|METEOR_SYNCAP
operator|)
operator|&&
operator|!
name|mtr
operator|->
name|synch_wait
condition|)
block|{
operator|*
operator|(
name|base
operator|+
literal|3
operator|)
operator|=
name|next_base
operator|+
operator|*
operator|(
name|base
operator|+
literal|6
operator|)
expr_stmt|;
comment|/* XXX should add adjustments for YUV_422& PLANAR */
block|}
comment|/* 		 * If the user requested to be notified via signal, 		 * let them know the field is complete. 		 */
if|if
condition|(
name|mtr
operator|->
name|proc
operator|&&
operator|(
name|mtr
operator|->
name|signal
operator|&
name|METEOR_SIG_MODE_MASK
operator|)
condition|)
name|psignal
argument_list|(
name|mtr
operator|->
name|proc
argument_list|,
name|mtr
operator|->
name|signal
operator|&
operator|(
operator|~
name|METEOR_SIG_MODE_MASK
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If we have a complete frame. 	 */
if|if
condition|(
operator|!
operator|(
name|mtr
operator|->
name|flags
operator|&
name|METEOR_WANT_MASK
operator|)
condition|)
block|{
name|mtr
operator|->
name|frames_captured
operator|++
expr_stmt|;
comment|/* 		 * post the completion time.  		 */
if|if
condition|(
name|mtr
operator|->
name|flags
operator|&
name|METEOR_WANT_TS
condition|)
block|{
name|struct
name|timeval
modifier|*
name|ts
decl_stmt|;
if|if
condition|(
name|mtr
operator|->
name|alloc_pages
operator|*
name|PAGE_SIZE
operator|<=
operator|(
name|mtr
operator|->
name|frame_size
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|timeval
argument_list|)
operator|)
condition|)
block|{
name|ts
operator|=
operator|(
expr|struct
name|timeval
operator|*
operator|)
name|mtr
operator|->
name|bigbuf
operator|+
name|mtr
operator|->
name|frame_size
expr_stmt|;
comment|/* doesn't work in synch mode except for first frame */
comment|/* XXX */
name|microtime
argument_list|(
name|ts
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 		 * Wake up the user in single capture mode. 		 */
if|if
condition|(
name|mtr
operator|->
name|flags
operator|&
name|METEOR_SINGLE
condition|)
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
name|mtr
argument_list|)
expr_stmt|;
comment|/* 		 * If the user requested to be notified via signal, 		 * let them know the frame is complete. 		 */
if|if
condition|(
name|mtr
operator|->
name|proc
operator|&&
operator|!
operator|(
name|mtr
operator|->
name|signal
operator|&
name|METEOR_SIG_MODE_MASK
operator|)
condition|)
name|psignal
argument_list|(
name|mtr
operator|->
name|proc
argument_list|,
name|mtr
operator|->
name|signal
operator|&
operator|(
operator|~
name|METEOR_SIG_MODE_MASK
operator|)
argument_list|)
expr_stmt|;
comment|/* 		 * Reset the want flags if in continuous or 		 * synchronous capture mode. 		 */
if|if
condition|(
name|mtr
operator|->
name|flags
operator|&
operator|(
name|METEOR_CONTIN
operator||
name|METEOR_SYNCAP
operator|)
condition|)
block|{
switch|switch
condition|(
name|mtr
operator|->
name|flags
operator|&
name|METEOR_ONLY_FIELDS_MASK
condition|)
block|{
case|case
name|METEOR_ONLY_ODD_FIELDS
case|:
name|mtr
operator|->
name|flags
operator||=
name|METEOR_WANT_ODD
expr_stmt|;
break|break;
case|case
name|METEOR_ONLY_EVEN_FIELDS
case|:
name|mtr
operator|->
name|flags
operator||=
name|METEOR_WANT_EVEN
expr_stmt|;
break|break;
default|default:
name|mtr
operator|->
name|flags
operator||=
name|METEOR_WANT_MASK
expr_stmt|;
break|break;
block|}
block|}
comment|/* 		 * Special handling for synchronous capture mode. 		 */
if|if
condition|(
name|mtr
operator|->
name|flags
operator|&
name|METEOR_SYNCAP
condition|)
block|{
name|struct
name|meteor_mem
modifier|*
name|mm
init|=
name|mtr
operator|->
name|mem
decl_stmt|;
comment|/* 			 * Mark the current frame as active.  It is up to 			 * the user to clear this, but we will clear it 			 * for the user for the current frame being captured 			 * if we are within the water marks (see below). 			 */
name|mm
operator|->
name|active
operator||=
literal|1
operator|<<
operator|(
name|mtr
operator|->
name|current
operator|-
literal|1
operator|)
expr_stmt|;
comment|/* 			 * Since the user can muck with these values, we need 			 * to check and see if they are sane. If they don't 			 * pass the sanity check, disable the capture mode. 			 * This is rather rude, but then so was the user. 			 * 			 * Do we really need all of this or should we just 			 * eliminate the possiblity of allowing the 			 * user to change hi and lo water marks while it 			 * is running? XXX 			 */
if|if
condition|(
name|mm
operator|->
name|num_active_bufs
operator|<
literal|0
operator|||
name|mm
operator|->
name|num_active_bufs
operator|>
name|mtr
operator|->
name|frames
operator|||
name|mm
operator|->
name|lowat
operator|<
literal|1
operator|||
name|mm
operator|->
name|lowat
operator|>=
name|mtr
operator|->
name|frames
operator|||
name|mm
operator|->
name|hiwat
operator|<
literal|1
operator|||
name|mm
operator|->
name|hiwat
operator|>=
name|mtr
operator|->
name|frames
operator|||
name|mm
operator|->
name|lowat
operator|>
name|mm
operator|->
name|hiwat
condition|)
block|{
operator|*
name|cap
operator|&=
literal|0x8ff0
expr_stmt|;
name|mtr
operator|->
name|flags
operator|&=
operator|~
operator|(
name|METEOR_SYNCAP
operator||
name|METEOR_WANT_MASK
operator|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 	 * Ok, they are sane, now we want to 				 * check the water marks. 			 	 */
if|if
condition|(
name|mm
operator|->
name|num_active_bufs
operator|<=
name|mm
operator|->
name|lowat
condition|)
name|mtr
operator|->
name|synch_wait
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|mm
operator|->
name|num_active_bufs
operator|>=
name|mm
operator|->
name|hiwat
condition|)
name|mtr
operator|->
name|synch_wait
operator|=
literal|1
expr_stmt|;
comment|/* 				 * Clear the active frame bit for this frame 				 * and advance the counters if we are within 				 * the banks of the water marks.  				 */
if|if
condition|(
operator|!
name|mtr
operator|->
name|synch_wait
condition|)
block|{
name|mm
operator|->
name|active
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|mtr
operator|->
name|current
operator|)
expr_stmt|;
name|mtr
operator|->
name|current
operator|++
expr_stmt|;
if|if
condition|(
name|mtr
operator|->
name|current
operator|>
name|mtr
operator|->
name|frames
condition|)
name|mtr
operator|->
name|current
operator|=
literal|1
expr_stmt|;
name|mm
operator|->
name|num_active_bufs
operator|++
expr_stmt|;
block|}
block|}
block|}
block|}
operator|*
name|stat
operator||=
literal|0x7
expr_stmt|;
comment|/* clear interrupt status */
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|set_fps
parameter_list|(
name|meteor_reg_t
modifier|*
name|mtr
parameter_list|,
name|u_short
name|fps
parameter_list|)
block|{
name|struct
name|saa7116_regs
modifier|*
name|s7116
init|=
name|mtr
operator|->
name|base
decl_stmt|;
name|unsigned
name|status
decl_stmt|;
name|unsigned
name|maxfps
decl_stmt|,
name|mask
init|=
literal|0x1
decl_stmt|,
name|length
init|=
literal|0
decl_stmt|;
name|SAA7196_WRITE
argument_list|(
name|mtr
argument_list|,
name|SAA7196_STDC
argument_list|,
name|SAA7196_REG
argument_list|(
name|mtr
argument_list|,
name|SAA7196_STDC
argument_list|)
operator||
literal|0x02
argument_list|)
expr_stmt|;
name|SAA7196_READ
argument_list|(
name|mtr
argument_list|)
expr_stmt|;
name|status
operator|=
operator|(
name|s7116
operator|->
name|i2c_read
operator|&
literal|0xff000000L
operator|)
operator|>>
literal|24
expr_stmt|;
comment|/* 	 * Determine if there is an input signal.  Depending on the 	 * frequency we either have a max of 25 fps (50 hz) or 30 fps (60 hz). 	 * If there is no input signal, then we need some defaults.  If the 	 * user neglected to specify any defaults, just set to the fps to max. 	 */
if|if
condition|(
operator|(
name|status
operator|&
literal|0x40
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* Is there a signal ? */
if|if
condition|(
name|status
operator|&
literal|0x20
condition|)
block|{
name|maxfps
operator|=
literal|30
expr_stmt|;
comment|/* 60 hz system */
block|}
else|else
block|{
name|maxfps
operator|=
literal|25
expr_stmt|;
comment|/* 50 hz system */
block|}
block|}
else|else
block|{
comment|/* We have no signal, check defaults */
if|#
directive|if
name|METEOR_SYSTEM_DEFAULT
operator|==
name|METEOR_PAL
operator|||
name|METEOR_SYSTEM_DEFAULT
operator|==
name|METEOR_SECAM
name|maxfps
operator|=
literal|25
expr_stmt|;
elif|#
directive|elif
name|METEOR_SYSTEM_DEFAULT
operator|==
name|METEOR_NTSC
name|maxfps
operator|=
literal|30
expr_stmt|;
else|#
directive|else
comment|/* Don't really know what to do, just set max */
name|maxfps
operator|=
literal|30
expr_stmt|;
name|fps
operator|=
literal|30
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* 	 * A little sanity checking... 	 */
if|if
condition|(
name|fps
operator|<
literal|1
condition|)
name|fps
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|fps
operator|>
name|maxfps
condition|)
name|fps
operator|=
name|maxfps
expr_stmt|;
comment|/* 	 * Compute the mask/length using the fps. 	 */
if|if
condition|(
name|fps
operator|==
name|maxfps
condition|)
block|{
name|mask
operator|=
literal|0x1
expr_stmt|;
name|length
operator|=
literal|0x0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|float
operator|)
name|fps
operator|==
name|maxfps
operator|/
literal|2.0
condition|)
block|{
name|mask
operator|=
literal|0x1
expr_stmt|;
name|length
operator|=
literal|0x1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fps
operator|>
name|maxfps
operator|/
literal|2
condition|)
block|{
name|float
name|step
decl_stmt|,
name|b
decl_stmt|;
name|mask
operator|=
operator|(
literal|1
operator|<<
name|maxfps
operator|)
operator|-
literal|1
expr_stmt|;
name|length
operator|=
name|maxfps
operator|-
literal|1
expr_stmt|;
name|step
operator|=
call|(
name|float
call|)
argument_list|(
name|maxfps
operator|-
literal|1
argument_list|)
operator|/
call|(
name|float
call|)
argument_list|(
name|maxfps
operator|-
name|fps
argument_list|)
expr_stmt|;
for|for
control|(
name|b
operator|=
name|step
init|;
name|b
operator|<
name|maxfps
condition|;
name|b
operator|+=
name|step
control|)
block|{
name|mask
operator|&=
operator|~
operator|(
literal|1
operator|<<
operator|(
operator|(
name|int
operator|)
name|b
operator|)
operator|)
expr_stmt|;
comment|/* mask out the bth frame */
block|}
block|}
else|else
block|{
comment|/* fps< maxfps/2 */
name|float
name|step
decl_stmt|,
name|b
decl_stmt|;
name|mask
operator|=
literal|0x1
expr_stmt|;
name|length
operator|=
name|maxfps
operator|-
literal|1
expr_stmt|;
name|step
operator|=
call|(
name|float
call|)
argument_list|(
name|maxfps
operator|-
literal|1
argument_list|)
operator|/
call|(
name|float
call|)
argument_list|(
name|fps
argument_list|)
expr_stmt|;
for|for
control|(
name|b
operator|=
name|step
operator|+
literal|1
init|;
name|b
operator|<
name|maxfps
operator|-
literal|1
condition|;
name|b
operator|+=
name|step
control|)
block|{
name|mask
operator||=
operator|(
literal|1
operator|<<
operator|(
operator|(
name|int
operator|)
name|b
operator|)
operator|)
expr_stmt|;
comment|/* mask in the bth frame */
block|}
block|}
comment|/* 	 * Set the fps. 	 */
name|s7116
operator|->
name|fme
operator|=
name|s7116
operator|->
name|fmo
operator|=
name|mask
expr_stmt|;
name|s7116
operator|->
name|fml
operator|=
operator|(
name|length
operator|<<
literal|16
operator|)
operator||
name|length
expr_stmt|;
empty_stmt|;
name|mtr
operator|->
name|fps
operator|=
name|fps
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * There is also a problem with range checking on the 7116.  * It seems to only work for 22 bits, so the max size we can allocate  * is 22 bits long or 4194304 bytes assuming that we put the beginning  * of the buffer on a 2^24 bit boundary.  The range registers will use  * the top 8 bits of the dma start registers along with the bottom 22  * bits of the range register to determine if we go out of range.  * This makes getting memory a real kludge.  *  */
end_comment

begin_define
define|#
directive|define
name|RANGE_BOUNDARY
value|(1<<22)
end_define

begin_function
specifier|static
name|vm_offset_t
name|get_meteor_mem
parameter_list|(
name|int
name|unit
parameter_list|,
name|unsigned
name|size
parameter_list|)
block|{
name|vm_offset_t
name|addr
init|=
literal|0
decl_stmt|;
name|addr
operator|=
name|vm_page_alloc_contig
argument_list|(
name|size
argument_list|,
literal|0
argument_list|,
literal|0xffffffff
argument_list|,
literal|1
operator|<<
literal|24
argument_list|)
expr_stmt|;
if|if
condition|(
name|addr
operator|==
literal|0
condition|)
name|addr
operator|=
name|vm_page_alloc_contig
argument_list|(
name|size
argument_list|,
literal|0
argument_list|,
literal|0xffffffff
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|addr
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"meteor%d: Unable to allocate %d bytes of memory.\n"
argument_list|,
name|unit
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
return|return
name|addr
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|bt254_write
parameter_list|(
name|meteor_reg_t
modifier|*
name|mtr
parameter_list|,
name|u_char
name|addr
parameter_list|,
name|u_char
name|data
parameter_list|)
block|{
name|addr
operator|&=
literal|0x7
expr_stmt|;
comment|/* sanity? */
name|mtr
operator|->
name|bt254_reg
index|[
name|addr
index|]
operator|=
name|data
expr_stmt|;
name|PCF8574_DATA_WRITE
argument_list|(
name|mtr
argument_list|,
name|data
argument_list|)
expr_stmt|;
comment|/* set data */
name|PCF8574_CTRL_WRITE
argument_list|(
name|mtr
argument_list|,
operator|(
name|PCF8574_CTRL_REG
argument_list|(
name|mtr
argument_list|)
operator|&
operator|~
literal|0x7
operator|)
operator||
name|addr
argument_list|)
expr_stmt|;
name|PCF8574_CTRL_WRITE
argument_list|(
name|mtr
argument_list|,
name|PCF8574_CTRL_REG
argument_list|(
name|mtr
argument_list|)
operator|&
operator|~
literal|0x10
argument_list|)
expr_stmt|;
comment|/* WR/ to 0 */
name|PCF8574_CTRL_WRITE
argument_list|(
name|mtr
argument_list|,
name|PCF8574_CTRL_REG
argument_list|(
name|mtr
argument_list|)
operator||
literal|0x10
argument_list|)
expr_stmt|;
comment|/* WR to 1 */
name|PCF8574_DATA_WRITE
argument_list|(
name|mtr
argument_list|,
literal|0xff
argument_list|)
expr_stmt|;
comment|/* clr data */
block|}
end_function

begin_function
specifier|static
name|void
name|bt254_init
parameter_list|(
name|meteor_reg_t
modifier|*
name|mtr
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|PCF8574_CTRL_WRITE
argument_list|(
name|mtr
argument_list|,
literal|0x7f
argument_list|)
expr_stmt|;
name|PCF8574_DATA_WRITE
argument_list|(
name|mtr
argument_list|,
literal|0xff
argument_list|)
expr_stmt|;
comment|/* data port must be 0xff */
name|PCF8574_CTRL_WRITE
argument_list|(
name|mtr
argument_list|,
literal|0x7f
argument_list|)
expr_stmt|;
comment|/* init RGB module for 24bpp, composite input */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_BT254_REGS
condition|;
name|i
operator|++
control|)
name|bt254_write
argument_list|(
name|mtr
argument_list|,
name|i
argument_list|,
name|bt254_default
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|bt254_write
argument_list|(
name|mtr
argument_list|,
name|BT254_COMMAND
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
comment|/* 24 bpp */
block|}
end_function

begin_function
specifier|static
name|void
name|bt254_ntsc
parameter_list|(
name|meteor_reg_t
modifier|*
name|mtr
parameter_list|,
name|int
name|arg
parameter_list|)
block|{
if|if
condition|(
name|arg
condition|)
block|{
comment|/* Set NTSC bit */
name|PCF8574_CTRL_WRITE
argument_list|(
name|mtr
argument_list|,
name|PCF8574_CTRL_REG
argument_list|(
name|mtr
argument_list|)
operator||
literal|0x20
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* reset NTSC bit */
name|PCF8574_CTRL_WRITE
argument_list|(
name|mtr
argument_list|,
name|PCF8574_CTRL_REG
argument_list|(
name|mtr
argument_list|)
operator|&=
operator|~
literal|0x20
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|select_bt254
parameter_list|(
name|meteor_reg_t
modifier|*
name|mtr
parameter_list|)
block|{
comment|/* disable saa7196, saaen = 1 */
name|PCF8574_CTRL_WRITE
argument_list|(
name|mtr
argument_list|,
name|PCF8574_CTRL_REG
argument_list|(
name|mtr
argument_list|)
operator||
literal|0x80
argument_list|)
expr_stmt|;
comment|/* enable Bt254, bten = 0 */
name|PCF8574_CTRL_WRITE
argument_list|(
name|mtr
argument_list|,
name|PCF8574_CTRL_REG
argument_list|(
name|mtr
argument_list|)
operator|&
operator|~
literal|0x40
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|select_saa7196
parameter_list|(
name|meteor_reg_t
modifier|*
name|mtr
parameter_list|)
block|{
comment|/* disable Bt254, bten = 1 */
name|PCF8574_CTRL_WRITE
argument_list|(
name|mtr
argument_list|,
name|PCF8574_CTRL_REG
argument_list|(
name|mtr
argument_list|)
operator||
literal|0x40
argument_list|)
expr_stmt|;
comment|/* enable saa7196, saaen = 0 */
name|PCF8574_CTRL_WRITE
argument_list|(
name|mtr
argument_list|,
name|PCF8574_CTRL_REG
argument_list|(
name|mtr
argument_list|)
operator|&
operator|~
literal|0x80
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Initialize the 7116, 7196 and the RGB module.  */
end_comment

begin_function
specifier|static
name|void
name|meteor_init
parameter_list|(
name|meteor_reg_t
modifier|*
name|mtr
parameter_list|)
block|{
name|mreg_t
modifier|*
name|vbase_addr
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* 	 * Initialize the Philips SAA7116 	 */
name|mtr
operator|->
name|base
operator|->
name|cap_cntl
operator|=
literal|0x00000040L
expr_stmt|;
name|vbase_addr
operator|=
operator|&
name|mtr
operator|->
name|base
operator|->
name|dma1e
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|saa7116_regs
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|mreg_t
argument_list|)
operator|)
condition|;
name|i
operator|++
control|)
operator|*
name|vbase_addr
operator|++
operator|=
name|saa7116_pci_default
index|[
name|i
index|]
expr_stmt|;
comment|/* 	 * Check for the Philips SAA7196 	 */
name|i2c_print_err
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|i2c_write
argument_list|(
name|mtr
argument_list|,
name|SAA7196_I2C_ADDR
argument_list|,
name|SAA7116_I2C_WRITE
argument_list|,
literal|0
argument_list|,
literal|0xff
argument_list|)
operator|==
literal|0
condition|)
block|{
name|i2c_print_err
operator|=
literal|1
expr_stmt|;
comment|/* 		 * Initialize 7196 		 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_SAA7196_I2C_REGS
condition|;
name|i
operator|++
control|)
name|SAA7196_WRITE
argument_list|(
name|mtr
argument_list|,
name|i
argument_list|,
name|saa7196_i2c_default
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|/* 		 * Get version number. 		 */
name|SAA7196_WRITE
argument_list|(
name|mtr
argument_list|,
name|SAA7196_STDC
argument_list|,
name|SAA7196_REG
argument_list|(
name|mtr
argument_list|,
name|SAA7196_STDC
argument_list|)
operator|&
operator|~
literal|0x02
argument_list|)
expr_stmt|;
name|SAA7196_READ
argument_list|(
name|mtr
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"meteor%d:<Philips SAA 7196> rev 0x%x\n"
argument_list|,
name|METEOR_NUM
argument_list|(
name|mtr
argument_list|)
argument_list|,
call|(
name|unsigned
call|)
argument_list|(
operator|(
name|mtr
operator|->
name|base
operator|->
name|i2c_read
operator|&
literal|0xff000000L
operator|)
operator|>>
literal|28
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|i2c_print_err
operator|=
literal|1
expr_stmt|;
name|printf
argument_list|(
literal|"meteor%d:<Philips SAA 7196 NOT FOUND>\n"
argument_list|,
name|METEOR_NUM
argument_list|(
name|mtr
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Check for RGB module, initialized if found. 	 */
name|i2c_print_err
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|i2c_write
argument_list|(
name|mtr
argument_list|,
name|PCF8574_DATA_I2C_ADDR
argument_list|,
name|SAA7116_I2C_WRITE
argument_list|,
literal|0
argument_list|,
literal|0xff
argument_list|)
operator|==
literal|0
condition|)
block|{
name|i2c_print_err
operator|=
literal|1
expr_stmt|;
name|printf
argument_list|(
literal|"meteor%d:<Booktree 254 (RGB module)>\n"
argument_list|,
name|METEOR_NUM
argument_list|(
name|mtr
argument_list|)
argument_list|)
expr_stmt|;
comment|/* does this have a rev #? */
name|bt254_init
argument_list|(
name|mtr
argument_list|)
expr_stmt|;
comment|/* Set up RGB module */
name|mtr
operator|->
name|flags
operator|=
name|METEOR_RGB
expr_stmt|;
block|}
else|else
block|{
name|i2c_print_err
operator|=
literal|1
expr_stmt|;
name|mtr
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
block|}
name|set_fps
argument_list|(
name|mtr
argument_list|,
literal|30
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|met_attach
parameter_list|(
name|pcici_t
name|tag
parameter_list|,
name|int
name|unit
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|METEOR_IRQ
name|u_long
name|old_irq
decl_stmt|,
name|new_irq
decl_stmt|;
endif|#
directive|endif
endif|METEOR_IRQ
name|meteor_reg_t
modifier|*
name|mtr
decl_stmt|;
name|vm_offset_t
name|buf
decl_stmt|;
name|u_long
name|latency
decl_stmt|;
if|if
condition|(
name|unit
operator|>=
name|NMETEOR
condition|)
block|{
name|printf
argument_list|(
literal|"meteor%d: attach: only %d units configured.\n"
argument_list|,
name|unit
argument_list|,
name|NMETEOR
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"meteor%d: attach: invalid unit number.\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return ;
block|}
comment|/* 	 * Check for Meteor/PPB (PCI-PCI Bridge) 	 * Reprogram IBM Bridge if detected. 	 * New Meteor cards have an IBM PCI-PCI bridge, creating a secondary 	 * PCI bus. The SAA chip is connected to this secondary bus. 	 */
comment|/* If we are not on PCI Bus 0, check for the Bridge */
if|if
condition|(
name|pci_get_bus_from_tag
argument_list|(
name|tag
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|pcici_t
name|bridge_tag
decl_stmt|;
comment|/* get tag of parent bridge */
name|bridge_tag
operator|=
name|pci_get_parent_from_tag
argument_list|(
name|tag
argument_list|)
expr_stmt|;
comment|/* Look for IBM 82351, 82352 or 82353 */
if|if
condition|(
name|pci_conf_read
argument_list|(
name|bridge_tag
argument_list|,
name|PCI_ID_REG
argument_list|)
operator|==
literal|0x00221014
condition|)
block|{
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"meteor%d: PPB device detected, reprogramming IBM bridge.\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
comment|/* disable SERR */
name|pci_cfgwrite
argument_list|(
name|bridge_tag
argument_list|,
literal|0x05
argument_list|,
literal|0x00
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* set LATENCY */
name|pci_cfgwrite
argument_list|(
name|bridge_tag
argument_list|,
literal|0x0d
argument_list|,
literal|0x20
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* write posting enable, prefetch enabled --> GRAB direction */
name|pci_cfgwrite
argument_list|(
name|bridge_tag
argument_list|,
literal|0x42
argument_list|,
literal|0x14
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* set PRTR Primary retry timer register */
name|pci_cfgwrite
argument_list|(
name|bridge_tag
argument_list|,
literal|0x4c
argument_list|,
literal|0x10
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
name|mtr
operator|=
operator|&
name|meteor
index|[
name|unit
index|]
expr_stmt|;
name|mtr
operator|->
name|tag
operator|=
name|tag
expr_stmt|;
name|pci_map_mem
argument_list|(
name|tag
argument_list|,
name|PCI_MAP_REG_START
argument_list|,
operator|(
name|vm_offset_t
operator|*
operator|)
operator|&
name|mtr
operator|->
name|base
argument_list|,
operator|&
name|mtr
operator|->
name|phys_base
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|METEOR_IRQ
comment|/* from the configuration file */
name|old_irq
operator|=
name|pci_conf_read
argument_list|(
name|tag
argument_list|,
name|PCI_INTERRUPT_REG
argument_list|)
expr_stmt|;
name|pci_conf_write
argument_list|(
name|tag
argument_list|,
name|PCI_INTERRUPT_REG
argument_list|,
name|METEOR_IRQ
argument_list|)
expr_stmt|;
name|new_irq
operator|=
name|pci_conf_read
argument_list|(
name|tag
argument_list|,
name|PCI_INTERRUPT_REG
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"meteor%d: attach: irq changed from %d to %d\n"
argument_list|,
name|unit
argument_list|,
operator|(
name|old_irq
operator|&
literal|0xff
operator|)
argument_list|,
operator|(
name|new_irq
operator|&
literal|0xff
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|METEOR_IRQ
comment|/* setup the interrupt handling routine */
name|pci_map_int
argument_list|(
name|tag
argument_list|,
name|meteor_intr
argument_list|,
operator|(
name|void
operator|*
operator|)
name|mtr
argument_list|,
operator|&
name|net_imask
argument_list|)
expr_stmt|;
comment|/*  * PCI latency timer.  32 is a good value for 4 bus mastering slots, if  * you have more than for, then 16 would probably be a better value.  *  */
ifndef|#
directive|ifndef
name|METEOR_DEF_LATENCY_VALUE
define|#
directive|define
name|METEOR_DEF_LATENCY_VALUE
value|32
endif|#
directive|endif
name|latency
operator|=
name|pci_conf_read
argument_list|(
name|tag
argument_list|,
name|PCI_LATENCY_TIMER
argument_list|)
expr_stmt|;
name|latency
operator|=
operator|(
name|latency
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
block|{
if|if
condition|(
name|latency
condition|)
name|printf
argument_list|(
literal|"meteor%d: PCI bus latency is"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"meteor%d: PCI bus latency was 0 changing to"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|latency
condition|)
block|{
name|latency
operator|=
name|METEOR_DEF_LATENCY_VALUE
expr_stmt|;
name|pci_conf_write
argument_list|(
name|tag
argument_list|,
name|PCI_LATENCY_TIMER
argument_list|,
name|latency
operator|<<
literal|8
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bootverbose
condition|)
block|{
name|printf
argument_list|(
literal|" %lu.\n"
argument_list|,
name|latency
argument_list|)
expr_stmt|;
block|}
name|meteor_init
argument_list|(
name|mtr
argument_list|)
expr_stmt|;
comment|/* set up saa7116, saa7196, and rgb module */
if|if
condition|(
name|METEOR_ALLOC
condition|)
name|buf
operator|=
name|get_meteor_mem
argument_list|(
name|unit
argument_list|,
name|METEOR_ALLOC
argument_list|)
expr_stmt|;
else|else
name|buf
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
block|{
name|printf
argument_list|(
literal|"meteor%d: buffer size %d, addr 0x%x\n"
argument_list|,
name|unit
argument_list|,
name|METEOR_ALLOC
argument_list|,
name|vtophys
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|mtr
operator|->
name|bigbuf
operator|=
name|buf
expr_stmt|;
name|mtr
operator|->
name|alloc_pages
operator|=
name|METEOR_ALLOC_PAGES
expr_stmt|;
if|if
condition|(
name|buf
operator|!=
literal|0
condition|)
block|{
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
name|buf
argument_list|,
name|METEOR_ALLOC
argument_list|)
expr_stmt|;
name|buf
operator|=
name|vtophys
argument_list|(
name|buf
argument_list|)
expr_stmt|;
comment|/* 640x480 RGB 16 */
name|mtr
operator|->
name|base
operator|->
name|dma1e
operator|=
name|buf
expr_stmt|;
name|mtr
operator|->
name|base
operator|->
name|dma1o
operator|=
name|buf
operator|+
literal|0x500
expr_stmt|;
name|mtr
operator|->
name|base
operator|->
name|dma_end_e
operator|=
name|mtr
operator|->
name|base
operator|->
name|dma_end_o
operator|=
name|buf
operator|+
name|METEOR_ALLOC
expr_stmt|;
block|}
comment|/* 1 frame of 640x480 RGB 16 */
name|mtr
operator|->
name|cols
operator|=
literal|640
expr_stmt|;
name|mtr
operator|->
name|rows
operator|=
literal|480
expr_stmt|;
name|mtr
operator|->
name|depth
operator|=
literal|2
expr_stmt|;
comment|/* two bytes per pixel */
name|mtr
operator|->
name|frames
operator|=
literal|1
expr_stmt|;
comment|/* one frame */
name|mtr
operator|->
name|flags
operator||=
name|METEOR_INITALIZED
operator||
name|METEOR_AUTOMODE
operator||
name|METEOR_DEV0
operator||
name|METEOR_RGB16
expr_stmt|;
name|make_dev
argument_list|(
operator|&
name|meteor_cdevsw
argument_list|,
name|unit
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0644
argument_list|,
literal|"meteor"
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|UNIT
parameter_list|(
name|x
parameter_list|)
value|((x)& 0x07)
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|unused
end_ifdef

begin_function
specifier|static
name|int
name|meteor_reset
parameter_list|(
name|dev_t
name|dev
parameter_list|)
block|{
name|int
name|unit
init|=
name|UNIT
argument_list|(
name|minor
argument_list|(
name|dev
argument_list|)
argument_list|)
decl_stmt|;
name|struct
name|saa7116_regs
modifier|*
name|m
decl_stmt|;
if|if
condition|(
name|unit
operator|>=
name|NMETEOR
condition|)
return|return
name|ENXIO
return|;
name|m
operator|=
name|meteor
index|[
name|unit
index|]
operator|.
name|base
expr_stmt|;
name|m
operator|->
name|cap_cntl
operator|=
literal|0x0
expr_stmt|;
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
name|m
argument_list|,
name|METPRI
argument_list|,
literal|"Mreset"
argument_list|,
name|hz
operator|/
literal|50
argument_list|)
expr_stmt|;
name|m
operator|->
name|cap_cntl
operator|=
literal|0x8ff0
expr_stmt|;
name|m
operator|->
name|cap_cntl
operator|=
literal|0x80c0
expr_stmt|;
name|m
operator|->
name|cap_cntl
operator|=
literal|0x8040
expr_stmt|;
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
name|m
argument_list|,
name|METPRI
argument_list|,
literal|"Mreset"
argument_list|,
name|hz
operator|/
literal|10
argument_list|)
expr_stmt|;
name|m
operator|->
name|cap_cntl
operator|=
literal|0x80c0
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*--------------------------------------------------------- ** **	Meteor character device driver routines ** **--------------------------------------------------------- */
end_comment

begin_function
name|int
name|meteor_open
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|fmt
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|meteor_reg_t
modifier|*
name|mtr
decl_stmt|;
name|int
name|unit
decl_stmt|;
name|int
name|i
decl_stmt|;
name|unit
operator|=
name|UNIT
argument_list|(
name|minor
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|unit
operator|>=
name|NMETEOR
condition|)
comment|/* unit out of range */
return|return
operator|(
name|ENXIO
operator|)
return|;
name|mtr
operator|=
operator|&
operator|(
name|meteor
index|[
name|unit
index|]
operator|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|mtr
operator|->
name|flags
operator|&
name|METEOR_INITALIZED
operator|)
condition|)
comment|/* device not found */
return|return
operator|(
name|ENXIO
operator|)
return|;
if|if
condition|(
name|mtr
operator|->
name|flags
operator|&
name|METEOR_OPEN
condition|)
comment|/* device is busy */
return|return
operator|(
name|EBUSY
operator|)
return|;
name|mtr
operator|->
name|flags
operator||=
name|METEOR_OPEN
expr_stmt|;
comment|/* 	 * Make sure that the i2c regs are set the same for each open. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_SAA7196_I2C_REGS
condition|;
name|i
operator|++
control|)
block|{
name|SAA7196_WRITE
argument_list|(
name|mtr
argument_list|,
name|i
argument_list|,
name|saa7196_i2c_default
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|mtr
operator|->
name|fifo_errors
operator|=
literal|0
expr_stmt|;
name|mtr
operator|->
name|dma_errors
operator|=
literal|0
expr_stmt|;
name|mtr
operator|->
name|frames_captured
operator|=
literal|0
expr_stmt|;
name|mtr
operator|->
name|even_fields_captured
operator|=
literal|0
expr_stmt|;
name|mtr
operator|->
name|odd_fields_captured
operator|=
literal|0
expr_stmt|;
name|mtr
operator|->
name|proc
operator|=
operator|(
expr|struct
name|proc
operator|*
operator|)
literal|0
expr_stmt|;
name|set_fps
argument_list|(
name|mtr
argument_list|,
literal|30
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|METEOR_TEST_VIDEO
name|mtr
operator|->
name|video
operator|.
name|addr
operator|=
literal|0
expr_stmt|;
name|mtr
operator|->
name|video
operator|.
name|width
operator|=
literal|0
expr_stmt|;
name|mtr
operator|->
name|video
operator|.
name|banksize
operator|=
literal|0
expr_stmt|;
name|mtr
operator|->
name|video
operator|.
name|ramsize
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|meteor_close
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|fmt
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|meteor_reg_t
modifier|*
name|mtr
decl_stmt|;
name|int
name|unit
decl_stmt|;
ifdef|#
directive|ifdef
name|METEOR_DEALLOC_ABOVE
name|int
name|temp
decl_stmt|;
endif|#
directive|endif
name|unit
operator|=
name|UNIT
argument_list|(
name|minor
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|unit
operator|>=
name|NMETEOR
condition|)
comment|/* unit out of range */
return|return
operator|(
name|ENXIO
operator|)
return|;
name|mtr
operator|=
operator|&
operator|(
name|meteor
index|[
name|unit
index|]
operator|)
expr_stmt|;
name|mtr
operator|->
name|flags
operator|&=
operator|~
name|METEOR_OPEN
expr_stmt|;
if|if
condition|(
name|mtr
operator|->
name|flags
operator|&
name|METEOR_SINGLE
condition|)
comment|/* this should not happen, the read capture  				  should have completed or in the very least 				  recieved a signal before close is called. */
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
name|mtr
argument_list|)
expr_stmt|;
comment|/* continue read */
comment|/* 	 * Turn off capture mode. 	 */
name|mtr
operator|->
name|base
operator|->
name|cap_cntl
operator|=
literal|0x8ff0
expr_stmt|;
name|mtr
operator|->
name|flags
operator|&=
operator|~
operator|(
name|METEOR_CAP_MASK
operator||
name|METEOR_WANT_MASK
operator|)
expr_stmt|;
name|mtr
operator|->
name|proc
operator|=
operator|(
expr|struct
name|proc
operator|*
operator|)
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|METEOR_DEALLOC_PAGES
if|if
condition|(
name|mtr
operator|->
name|bigbuf
operator|!=
name|NULL
condition|)
block|{
name|kmem_free
argument_list|(
name|kernel_map
argument_list|,
name|mtr
operator|->
name|bigbuf
argument_list|,
operator|(
name|mtr
operator|->
name|alloc_pages
operator|*
name|PAGE_SIZE
operator|)
argument_list|)
expr_stmt|;
name|mtr
operator|->
name|bigbuf
operator|=
name|NULL
expr_stmt|;
name|mtr
operator|->
name|alloc_pages
operator|=
literal|0
expr_stmt|;
block|}
else|#
directive|else
ifdef|#
directive|ifdef
name|METEOR_DEALLOC_ABOVE
if|if
condition|(
name|mtr
operator|->
name|bigbuf
operator|!=
name|NULL
operator|&&
name|mtr
operator|->
name|alloc_pages
operator|>
name|METEOR_DEALLOC_ABOVE
condition|)
block|{
name|temp
operator|=
name|METEOR_DEALLOC_ABOVE
operator|-
name|mtr
operator|->
name|alloc_pages
expr_stmt|;
name|kmem_free
argument_list|(
name|kernel_map
argument_list|,
name|mtr
operator|->
name|bigbuf
operator|+
operator|(
operator|(
name|mtr
operator|->
name|alloc_pages
operator|-
name|temp
operator|)
operator|*
name|PAGE_SIZE
operator|)
argument_list|,
operator|(
name|temp
operator|*
name|PAGE_SIZE
operator|)
argument_list|)
expr_stmt|;
name|mtr
operator|->
name|alloc_pages
operator|=
name|METEOR_DEALLOC_ABOVE
expr_stmt|;
block|}
endif|#
directive|endif
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|start_capture
parameter_list|(
name|meteor_reg_t
modifier|*
name|mtr
parameter_list|,
name|unsigned
name|type
parameter_list|)
block|{
name|mreg_t
modifier|*
name|cap
init|=
operator|&
name|mtr
operator|->
name|base
operator|->
name|cap_cntl
decl_stmt|;
name|mtr
operator|->
name|flags
operator||=
name|type
expr_stmt|;
switch|switch
condition|(
name|mtr
operator|->
name|flags
operator|&
name|METEOR_ONLY_FIELDS_MASK
condition|)
block|{
case|case
name|METEOR_ONLY_EVEN_FIELDS
case|:
name|mtr
operator|->
name|flags
operator||=
name|METEOR_WANT_EVEN
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|METEOR_SINGLE
condition|)
operator|*
name|cap
operator|=
literal|0x0ff4
operator||
name|mtr
operator|->
name|range_enable
expr_stmt|;
else|else
operator|*
name|cap
operator|=
literal|0x0ff1
operator||
name|mtr
operator|->
name|range_enable
expr_stmt|;
break|break;
case|case
name|METEOR_ONLY_ODD_FIELDS
case|:
name|mtr
operator|->
name|flags
operator||=
name|METEOR_WANT_ODD
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|METEOR_SINGLE
condition|)
operator|*
name|cap
operator|=
literal|0x0ff8
operator||
name|mtr
operator|->
name|range_enable
expr_stmt|;
else|else
operator|*
name|cap
operator|=
literal|0x0ff2
operator||
name|mtr
operator|->
name|range_enable
expr_stmt|;
break|break;
default|default:
name|mtr
operator|->
name|flags
operator||=
name|METEOR_WANT_MASK
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|METEOR_SINGLE
condition|)
operator|*
name|cap
operator|=
literal|0x0ffc
operator||
name|mtr
operator|->
name|range_enable
expr_stmt|;
else|else
operator|*
name|cap
operator|=
literal|0x0ff3
operator||
name|mtr
operator|->
name|range_enable
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
name|int
name|meteor_read
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|,
name|int
name|ioflag
parameter_list|)
block|{
name|meteor_reg_t
modifier|*
name|mtr
decl_stmt|;
name|int
name|unit
decl_stmt|;
name|int
name|status
decl_stmt|;
name|int
name|count
decl_stmt|;
name|unit
operator|=
name|UNIT
argument_list|(
name|minor
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|unit
operator|>=
name|NMETEOR
condition|)
comment|/* unit out of range */
return|return
operator|(
name|ENXIO
operator|)
return|;
name|mtr
operator|=
operator|&
operator|(
name|meteor
index|[
name|unit
index|]
operator|)
expr_stmt|;
if|if
condition|(
name|mtr
operator|->
name|bigbuf
operator|==
literal|0
condition|)
comment|/* no frame buffer allocated (ioctl failed) */
return|return
operator|(
name|ENOMEM
operator|)
return|;
if|if
condition|(
name|mtr
operator|->
name|flags
operator|&
name|METEOR_CAP_MASK
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
comment|/* already capturing */
name|count
operator|=
name|mtr
operator|->
name|rows
operator|*
name|mtr
operator|->
name|cols
operator|*
name|mtr
operator|->
name|depth
expr_stmt|;
if|if
condition|(
name|uio
operator|->
name|uio_iov
operator|->
name|iov_len
operator|<
name|count
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* Start capture */
name|start_capture
argument_list|(
name|mtr
argument_list|,
name|METEOR_SINGLE
argument_list|)
expr_stmt|;
name|status
operator|=
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
name|mtr
argument_list|,
name|METPRI
argument_list|,
literal|"capturing"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|status
condition|)
comment|/* successful capture */
name|status
operator|=
name|uiomove
argument_list|(
operator|(
name|caddr_t
operator|)
name|mtr
operator|->
name|bigbuf
argument_list|,
name|count
argument_list|,
name|uio
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"meteor%d: read: tsleep error %d\n"
argument_list|,
name|unit
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|mtr
operator|->
name|flags
operator|&=
operator|~
operator|(
name|METEOR_SINGLE
operator||
name|METEOR_WANT_MASK
operator|)
expr_stmt|;
return|return
operator|(
name|status
operator|)
return|;
block|}
end_function

begin_function
name|int
name|meteor_write
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|,
name|int
name|ioflag
parameter_list|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|meteor_ioctl
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|arg
parameter_list|,
name|int
name|flag
parameter_list|,
name|struct
name|proc
modifier|*
name|pr
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|int
name|unit
decl_stmt|;
name|unsigned
name|int
name|temp
decl_stmt|;
name|meteor_reg_t
modifier|*
name|mtr
decl_stmt|;
name|struct
name|meteor_counts
modifier|*
name|cnt
decl_stmt|;
name|struct
name|meteor_geomet
modifier|*
name|geo
decl_stmt|;
name|struct
name|meteor_mem
modifier|*
name|mem
decl_stmt|;
name|struct
name|meteor_capframe
modifier|*
name|frame
decl_stmt|;
ifdef|#
directive|ifdef
name|METEOR_TEST_VIDEO
name|struct
name|meteor_video
modifier|*
name|video
decl_stmt|;
endif|#
directive|endif
name|vm_offset_t
name|buf
decl_stmt|;
name|struct
name|saa7116_regs
modifier|*
name|base
decl_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|arg
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|unit
operator|=
name|UNIT
argument_list|(
name|minor
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|unit
operator|>=
name|NMETEOR
condition|)
comment|/* unit out of range */
return|return
operator|(
name|ENXIO
operator|)
return|;
name|mtr
operator|=
operator|&
operator|(
name|meteor
index|[
name|unit
index|]
operator|)
expr_stmt|;
name|base
operator|=
name|mtr
operator|->
name|base
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|METEORSTS
case|:
if|if
condition|(
operator|*
name|arg
condition|)
name|mtr
operator|->
name|flags
operator||=
name|METEOR_WANT_TS
expr_stmt|;
else|else
name|mtr
operator|->
name|flags
operator|&=
operator|~
name|METEOR_WANT_TS
expr_stmt|;
break|break;
case|case
name|METEORGTS
case|:
if|if
condition|(
name|mtr
operator|->
name|flags
operator|&
name|METEOR_WANT_TS
condition|)
operator|*
name|arg
operator|=
literal|1
expr_stmt|;
else|else
operator|*
name|arg
operator|=
literal|0
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|METEOR_TEST_VIDEO
case|case
name|METEORGVIDEO
case|:
name|video
operator|=
operator|(
expr|struct
name|meteor_video
operator|*
operator|)
name|arg
expr_stmt|;
name|video
operator|->
name|addr
operator|=
name|mtr
operator|->
name|video
operator|.
name|addr
expr_stmt|;
name|video
operator|->
name|width
operator|=
name|mtr
operator|->
name|video
operator|.
name|width
expr_stmt|;
name|video
operator|->
name|banksize
operator|=
name|mtr
operator|->
name|video
operator|.
name|banksize
expr_stmt|;
name|video
operator|->
name|ramsize
operator|=
name|mtr
operator|->
name|video
operator|.
name|ramsize
expr_stmt|;
break|break;
case|case
name|METEORSVIDEO
case|:
name|video
operator|=
operator|(
expr|struct
name|meteor_video
operator|*
operator|)
name|arg
expr_stmt|;
name|mtr
operator|->
name|video
operator|.
name|addr
operator|=
name|video
operator|->
name|addr
expr_stmt|;
name|mtr
operator|->
name|video
operator|.
name|width
operator|=
name|video
operator|->
name|width
expr_stmt|;
name|mtr
operator|->
name|video
operator|.
name|banksize
operator|=
name|video
operator|->
name|banksize
expr_stmt|;
name|mtr
operator|->
name|video
operator|.
name|ramsize
operator|=
name|video
operator|->
name|ramsize
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|METEORSFPS
case|:
name|set_fps
argument_list|(
name|mtr
argument_list|,
operator|*
operator|(
name|u_short
operator|*
operator|)
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
name|METEORGFPS
case|:
operator|*
operator|(
name|u_short
operator|*
operator|)
name|arg
operator|=
name|mtr
operator|->
name|fps
expr_stmt|;
break|break;
case|case
name|METEORSSIGNAL
case|:
name|mtr
operator|->
name|signal
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
expr_stmt|;
if|if
condition|(
name|mtr
operator|->
name|signal
condition|)
block|{
name|mtr
operator|->
name|proc
operator|=
name|pr
expr_stmt|;
block|}
else|else
block|{
name|mtr
operator|->
name|proc
operator|=
operator|(
expr|struct
name|proc
operator|*
operator|)
literal|0
expr_stmt|;
block|}
break|break;
case|case
name|METEORGSIGNAL
case|:
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|=
name|mtr
operator|->
name|signal
expr_stmt|;
break|break;
case|case
name|METEORSTATUS
case|:
comment|/* get 7196 status */
name|temp
operator|=
literal|0
expr_stmt|;
name|SAA7196_WRITE
argument_list|(
name|mtr
argument_list|,
name|SAA7196_STDC
argument_list|,
name|SAA7196_REG
argument_list|(
name|mtr
argument_list|,
name|SAA7196_STDC
argument_list|)
operator||
literal|0x02
argument_list|)
expr_stmt|;
name|SAA7196_READ
argument_list|(
name|mtr
argument_list|)
expr_stmt|;
name|temp
operator||=
operator|(
name|base
operator|->
name|i2c_read
operator|&
literal|0xff000000L
operator|)
operator|>>
literal|24
expr_stmt|;
name|SAA7196_WRITE
argument_list|(
name|mtr
argument_list|,
name|SAA7196_STDC
argument_list|,
name|SAA7196_REG
argument_list|(
name|mtr
argument_list|,
name|SAA7196_STDC
argument_list|)
operator|&
operator|~
literal|0x02
argument_list|)
expr_stmt|;
name|SAA7196_READ
argument_list|(
name|mtr
argument_list|)
expr_stmt|;
name|temp
operator||=
operator|(
name|base
operator|->
name|i2c_read
operator|&
literal|0xff000000L
operator|)
operator|>>
literal|16
expr_stmt|;
operator|*
operator|(
name|u_short
operator|*
operator|)
name|arg
operator|=
name|temp
expr_stmt|;
break|break;
case|case
name|METEORSHUE
case|:
comment|/* set hue */
name|SAA7196_WRITE
argument_list|(
name|mtr
argument_list|,
name|SAA7196_HUEC
argument_list|,
operator|*
operator|(
name|char
operator|*
operator|)
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
name|METEORGHUE
case|:
comment|/* get hue */
operator|*
operator|(
name|char
operator|*
operator|)
name|arg
operator|=
name|SAA7196_REG
argument_list|(
name|mtr
argument_list|,
name|SAA7196_HUEC
argument_list|)
expr_stmt|;
break|break;
case|case
name|METEORSCHCV
case|:
comment|/* set chrominance gain */
name|SAA7196_WRITE
argument_list|(
name|mtr
argument_list|,
name|SAA7196_CGAINR
argument_list|,
operator|*
operator|(
name|char
operator|*
operator|)
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
name|METEORGCHCV
case|:
comment|/* get chrominance gain */
operator|*
operator|(
name|char
operator|*
operator|)
name|arg
operator|=
name|SAA7196_REG
argument_list|(
name|mtr
argument_list|,
name|SAA7196_CGAINR
argument_list|)
expr_stmt|;
break|break;
case|case
name|METEORSBRIG
case|:
comment|/* set brightness */
name|SAA7196_WRITE
argument_list|(
name|mtr
argument_list|,
name|SAA7196_BRIG
argument_list|,
operator|*
operator|(
name|char
operator|*
operator|)
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
name|METEORGBRIG
case|:
comment|/* get brightness */
operator|*
operator|(
name|char
operator|*
operator|)
name|arg
operator|=
name|SAA7196_REG
argument_list|(
name|mtr
argument_list|,
name|SAA7196_BRIG
argument_list|)
expr_stmt|;
break|break;
case|case
name|METEORSCSAT
case|:
comment|/* set chroma saturation */
name|SAA7196_WRITE
argument_list|(
name|mtr
argument_list|,
name|SAA7196_CSAT
argument_list|,
operator|*
operator|(
name|char
operator|*
operator|)
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
name|METEORGCSAT
case|:
comment|/* get chroma saturation */
operator|*
operator|(
name|char
operator|*
operator|)
name|arg
operator|=
name|SAA7196_REG
argument_list|(
name|mtr
argument_list|,
name|SAA7196_CSAT
argument_list|)
expr_stmt|;
break|break;
case|case
name|METEORSCONT
case|:
comment|/* set contrast */
name|SAA7196_WRITE
argument_list|(
name|mtr
argument_list|,
name|SAA7196_CONT
argument_list|,
operator|*
operator|(
name|char
operator|*
operator|)
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
name|METEORGCONT
case|:
comment|/* get contrast */
operator|*
operator|(
name|char
operator|*
operator|)
name|arg
operator|=
name|SAA7196_REG
argument_list|(
name|mtr
argument_list|,
name|SAA7196_CONT
argument_list|)
expr_stmt|;
break|break;
case|case
name|METEORSBT254
case|:
if|if
condition|(
operator|(
name|mtr
operator|->
name|flags
operator|&
name|METEOR_RGB
operator|)
operator|==
literal|0
condition|)
return|return
name|EINVAL
return|;
name|temp
operator|=
operator|*
operator|(
name|unsigned
name|short
operator|*
operator|)
name|arg
expr_stmt|;
name|bt254_write
argument_list|(
name|mtr
argument_list|,
name|temp
operator|&
literal|0xf
argument_list|,
operator|(
name|temp
operator|&
literal|0x0ff0
operator|)
operator|>>
literal|4
argument_list|)
expr_stmt|;
break|break;
case|case
name|METEORGBT254
case|:
if|if
condition|(
operator|(
name|mtr
operator|->
name|flags
operator|&
name|METEOR_RGB
operator|)
operator|==
literal|0
condition|)
return|return
name|EINVAL
return|;
name|temp
operator|=
operator|*
operator|(
name|unsigned
name|short
operator|*
operator|)
name|arg
operator|&
literal|0x7
expr_stmt|;
operator|*
operator|(
name|unsigned
name|short
operator|*
operator|)
name|arg
operator|=
name|mtr
operator|->
name|bt254_reg
index|[
name|temp
index|]
operator|<<
literal|4
operator||
name|temp
expr_stmt|;
break|break;
case|case
name|METEORSHWS
case|:
comment|/* set horizontal window start */
name|SAA7196_WRITE
argument_list|(
name|mtr
argument_list|,
name|SAA7196_HWS
argument_list|,
operator|*
operator|(
name|char
operator|*
operator|)
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
name|METEORGHWS
case|:
comment|/* get horizontal window start */
operator|*
operator|(
name|char
operator|*
operator|)
name|arg
operator|=
name|SAA7196_REG
argument_list|(
name|mtr
argument_list|,
name|SAA7196_HWS
argument_list|)
expr_stmt|;
break|break;
case|case
name|METEORSVWS
case|:
comment|/* set vertical window start */
name|SAA7196_WRITE
argument_list|(
name|mtr
argument_list|,
name|SAA7196_VWS
argument_list|,
operator|*
operator|(
name|char
operator|*
operator|)
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
name|METEORGVWS
case|:
comment|/* get vertical window start */
operator|*
operator|(
name|char
operator|*
operator|)
name|arg
operator|=
name|SAA7196_REG
argument_list|(
name|mtr
argument_list|,
name|SAA7196_VWS
argument_list|)
expr_stmt|;
break|break;
case|case
name|METEORSINPUT
case|:
comment|/* set input device */
switch|switch
condition|(
operator|*
operator|(
name|unsigned
name|long
operator|*
operator|)
name|arg
operator|&
name|METEOR_DEV_MASK
condition|)
block|{
case|case
literal|0
case|:
comment|/* default */
case|case
name|METEOR_INPUT_DEV0
case|:
if|if
condition|(
name|mtr
operator|->
name|flags
operator|&
name|METEOR_RGB
condition|)
name|select_saa7196
argument_list|(
name|mtr
argument_list|)
expr_stmt|;
name|mtr
operator|->
name|flags
operator|=
operator|(
name|mtr
operator|->
name|flags
operator|&
operator|~
name|METEOR_DEV_MASK
operator|)
operator||
name|METEOR_DEV0
expr_stmt|;
name|SAA7196_WRITE
argument_list|(
name|mtr
argument_list|,
literal|0x0e
argument_list|,
operator|(
name|SAA7196_REG
argument_list|(
name|mtr
argument_list|,
literal|0x0e
argument_list|)
operator|&
operator|~
literal|0x3
operator|)
operator||
literal|0x0
argument_list|)
expr_stmt|;
name|SAA7196_WRITE
argument_list|(
name|mtr
argument_list|,
literal|0x06
argument_list|,
operator|(
name|SAA7196_REG
argument_list|(
name|mtr
argument_list|,
literal|0x06
argument_list|)
operator|&
operator|~
literal|0x80
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|METEOR_INPUT_DEV1
case|:
if|if
condition|(
name|mtr
operator|->
name|flags
operator|&
name|METEOR_RGB
condition|)
name|select_saa7196
argument_list|(
name|mtr
argument_list|)
expr_stmt|;
name|mtr
operator|->
name|flags
operator|=
operator|(
name|mtr
operator|->
name|flags
operator|&
operator|~
name|METEOR_DEV_MASK
operator|)
operator||
name|METEOR_DEV1
expr_stmt|;
name|SAA7196_WRITE
argument_list|(
name|mtr
argument_list|,
literal|0x0e
argument_list|,
operator|(
name|SAA7196_REG
argument_list|(
name|mtr
argument_list|,
literal|0x0e
argument_list|)
operator|&
operator|~
literal|0x3
operator|)
operator||
literal|0x1
argument_list|)
expr_stmt|;
name|SAA7196_WRITE
argument_list|(
name|mtr
argument_list|,
literal|0x06
argument_list|,
operator|(
name|SAA7196_REG
argument_list|(
name|mtr
argument_list|,
literal|0x06
argument_list|)
operator|&
operator|~
literal|0x80
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|METEOR_INPUT_DEV2
case|:
if|if
condition|(
name|mtr
operator|->
name|flags
operator|&
name|METEOR_RGB
condition|)
name|select_saa7196
argument_list|(
name|mtr
argument_list|)
expr_stmt|;
name|mtr
operator|->
name|flags
operator|=
operator|(
name|mtr
operator|->
name|flags
operator|&
operator|~
name|METEOR_DEV_MASK
operator|)
operator||
name|METEOR_DEV2
expr_stmt|;
name|SAA7196_WRITE
argument_list|(
name|mtr
argument_list|,
literal|0x0e
argument_list|,
operator|(
name|SAA7196_REG
argument_list|(
name|mtr
argument_list|,
literal|0x0e
argument_list|)
operator|&
operator|~
literal|0x3
operator|)
operator||
literal|0x2
argument_list|)
expr_stmt|;
name|SAA7196_WRITE
argument_list|(
name|mtr
argument_list|,
literal|0x06
argument_list|,
operator|(
name|SAA7196_REG
argument_list|(
name|mtr
argument_list|,
literal|0x06
argument_list|)
operator|&
operator|~
literal|0x80
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|METEOR_INPUT_DEV3
case|:
if|if
condition|(
name|mtr
operator|->
name|flags
operator|&
name|METEOR_RGB
condition|)
name|select_saa7196
argument_list|(
name|mtr
argument_list|)
expr_stmt|;
name|mtr
operator|->
name|flags
operator|=
operator|(
name|mtr
operator|->
name|flags
operator|&
operator|~
name|METEOR_DEV_MASK
operator|)
operator||
name|METEOR_DEV3
expr_stmt|;
name|SAA7196_WRITE
argument_list|(
name|mtr
argument_list|,
literal|0x0e
argument_list|,
operator|(
name|SAA7196_REG
argument_list|(
name|mtr
argument_list|,
literal|0x0e
argument_list|)
operator||
literal|0x3
operator|)
argument_list|)
expr_stmt|;
name|SAA7196_WRITE
argument_list|(
name|mtr
argument_list|,
literal|0x06
argument_list|,
operator|(
name|SAA7196_REG
argument_list|(
name|mtr
argument_list|,
literal|0x06
argument_list|)
operator|&
operator|~
literal|0x80
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|METEOR_INPUT_DEV_SVIDEO
case|:
if|if
condition|(
name|mtr
operator|->
name|flags
operator|&
name|METEOR_RGB
condition|)
name|select_saa7196
argument_list|(
name|mtr
argument_list|)
expr_stmt|;
name|mtr
operator|->
name|flags
operator|=
operator|(
name|mtr
operator|->
name|flags
operator|&
operator|~
name|METEOR_DEV_MASK
operator|)
operator||
name|METEOR_DEV_SVIDEO
expr_stmt|;
name|SAA7196_WRITE
argument_list|(
name|mtr
argument_list|,
literal|0x0e
argument_list|,
operator|(
name|SAA7196_REG
argument_list|(
name|mtr
argument_list|,
literal|0x0e
argument_list|)
operator|&
operator|~
literal|0x3
operator|)
operator||
literal|0x2
argument_list|)
expr_stmt|;
name|SAA7196_WRITE
argument_list|(
name|mtr
argument_list|,
literal|0x06
argument_list|,
operator|(
name|SAA7196_REG
argument_list|(
name|mtr
argument_list|,
literal|0x06
argument_list|)
operator|&
operator|~
literal|0x80
operator|)
operator||
literal|0x80
argument_list|)
expr_stmt|;
break|break;
case|case
name|METEOR_INPUT_DEV_RGB
case|:
if|if
condition|(
operator|(
name|mtr
operator|->
name|flags
operator|&
name|METEOR_RGB
operator|)
operator|==
literal|0
condition|)
return|return
name|EINVAL
return|;
name|mtr
operator|->
name|flags
operator|=
operator|(
name|mtr
operator|->
name|flags
operator|&
operator|~
name|METEOR_DEV_MASK
operator|)
operator||
name|METEOR_DEV_RGB
expr_stmt|;
name|SAA7196_WRITE
argument_list|(
name|mtr
argument_list|,
literal|0x0e
argument_list|,
operator|(
name|SAA7196_REG
argument_list|(
name|mtr
argument_list|,
literal|0x0e
argument_list|)
operator|&
operator|~
literal|0x3
operator|)
operator||
literal|0x3
argument_list|)
expr_stmt|;
name|SAA7196_WRITE
argument_list|(
name|mtr
argument_list|,
literal|0x06
argument_list|,
operator|(
name|SAA7196_REG
argument_list|(
name|mtr
argument_list|,
literal|0x06
argument_list|)
operator|&
operator|~
literal|0x80
operator|)
argument_list|)
expr_stmt|;
name|select_bt254
argument_list|(
name|mtr
argument_list|)
expr_stmt|;
name|SAA7196_WRITE
argument_list|(
name|mtr
argument_list|,
literal|0x0e
argument_list|,
comment|/* chn 3 for synch */
operator|(
name|SAA7196_REG
argument_list|(
name|mtr
argument_list|,
literal|0x0e
argument_list|)
operator|&
operator|~
literal|0x3
operator|)
operator||
literal|0x3
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
name|EINVAL
return|;
block|}
break|break;
case|case
name|METEORGINPUT
case|:
comment|/* get input device */
operator|*
operator|(
name|u_long
operator|*
operator|)
name|arg
operator|=
name|mtr
operator|->
name|flags
operator|&
name|METEOR_DEV_MASK
expr_stmt|;
break|break;
case|case
name|METEORSFMT
case|:
comment|/* set input format */
switch|switch
condition|(
operator|*
operator|(
name|unsigned
name|long
operator|*
operator|)
name|arg
operator|&
name|METEOR_FORM_MASK
condition|)
block|{
case|case
literal|0
case|:
comment|/* default */
case|case
name|METEOR_FMT_NTSC
case|:
name|mtr
operator|->
name|flags
operator|=
operator|(
name|mtr
operator|->
name|flags
operator|&
operator|~
name|METEOR_FORM_MASK
operator|)
operator||
name|METEOR_NTSC
expr_stmt|;
name|SAA7196_WRITE
argument_list|(
name|mtr
argument_list|,
name|SAA7196_STDC
argument_list|,
operator|(
name|SAA7196_REG
argument_list|(
name|mtr
argument_list|,
name|SAA7196_STDC
argument_list|)
operator|&
operator|~
literal|0x01
operator|)
argument_list|)
expr_stmt|;
name|SAA7196_WRITE
argument_list|(
name|mtr
argument_list|,
literal|0x0f
argument_list|,
operator|(
name|SAA7196_REG
argument_list|(
name|mtr
argument_list|,
literal|0x0f
argument_list|)
operator|&
operator|~
literal|0xe0
operator|)
operator||
literal|0x40
argument_list|)
expr_stmt|;
name|SAA7196_WRITE
argument_list|(
name|mtr
argument_list|,
literal|0x22
argument_list|,
literal|0x80
argument_list|)
expr_stmt|;
name|SAA7196_WRITE
argument_list|(
name|mtr
argument_list|,
literal|0x24
argument_list|,
operator|(
name|SAA7196_REG
argument_list|(
name|mtr
argument_list|,
literal|0x24
argument_list|)
operator|&
operator|~
literal|0x0c
operator|)
operator||
literal|0x08
argument_list|)
expr_stmt|;
name|SAA7196_WRITE
argument_list|(
name|mtr
argument_list|,
literal|0x26
argument_list|,
literal|0xf0
argument_list|)
expr_stmt|;
name|SAA7196_WRITE
argument_list|(
name|mtr
argument_list|,
literal|0x28
argument_list|,
operator|(
name|SAA7196_REG
argument_list|(
name|mtr
argument_list|,
literal|0x28
argument_list|)
operator|&
operator|~
literal|0x0c
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mtr
operator|->
name|flags
operator|&
name|METEOR_RGB
condition|)
block|{
name|bt254_ntsc
argument_list|(
name|mtr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|METEOR_FMT_PAL
case|:
name|mtr
operator|->
name|flags
operator|=
operator|(
name|mtr
operator|->
name|flags
operator|&
operator|~
name|METEOR_FORM_MASK
operator|)
operator||
name|METEOR_PAL
expr_stmt|;
name|SAA7196_WRITE
argument_list|(
name|mtr
argument_list|,
name|SAA7196_STDC
argument_list|,
operator|(
name|SAA7196_REG
argument_list|(
name|mtr
argument_list|,
name|SAA7196_STDC
argument_list|)
operator|&
operator|~
literal|0x01
operator|)
argument_list|)
expr_stmt|;
name|SAA7196_WRITE
argument_list|(
name|mtr
argument_list|,
literal|0x0f
argument_list|,
operator|(
name|SAA7196_REG
argument_list|(
name|mtr
argument_list|,
literal|0x0f
argument_list|)
operator|&
operator|~
literal|0xe0
operator|)
argument_list|)
expr_stmt|;
name|SAA7196_WRITE
argument_list|(
name|mtr
argument_list|,
literal|0x22
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
name|SAA7196_WRITE
argument_list|(
name|mtr
argument_list|,
literal|0x24
argument_list|,
operator|(
name|SAA7196_REG
argument_list|(
name|mtr
argument_list|,
literal|0x24
argument_list|)
operator||
literal|0x0c
operator|)
argument_list|)
expr_stmt|;
name|SAA7196_WRITE
argument_list|(
name|mtr
argument_list|,
literal|0x26
argument_list|,
literal|0x20
argument_list|)
expr_stmt|;
name|SAA7196_WRITE
argument_list|(
name|mtr
argument_list|,
literal|0x28
argument_list|,
operator|(
name|SAA7196_REG
argument_list|(
name|mtr
argument_list|,
literal|0x28
argument_list|)
operator|&
operator|~
literal|0x0c
operator|)
operator||
literal|0x04
argument_list|)
expr_stmt|;
if|if
condition|(
name|mtr
operator|->
name|flags
operator|&
name|METEOR_RGB
condition|)
block|{
name|bt254_ntsc
argument_list|(
name|mtr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|METEOR_FMT_SECAM
case|:
name|mtr
operator|->
name|flags
operator|=
operator|(
name|mtr
operator|->
name|flags
operator|&
operator|~
name|METEOR_FORM_MASK
operator|)
operator||
name|METEOR_SECAM
expr_stmt|;
name|SAA7196_WRITE
argument_list|(
name|mtr
argument_list|,
name|SAA7196_STDC
argument_list|,
operator|(
name|SAA7196_REG
argument_list|(
name|mtr
argument_list|,
name|SAA7196_STDC
argument_list|)
operator|&
operator|~
literal|0x01
operator|)
operator||
literal|0x1
argument_list|)
expr_stmt|;
name|SAA7196_WRITE
argument_list|(
name|mtr
argument_list|,
literal|0x0f
argument_list|,
operator|(
name|SAA7196_REG
argument_list|(
name|mtr
argument_list|,
literal|0x0f
argument_list|)
operator|&
operator|~
literal|0xe0
operator|)
operator||
literal|0x20
argument_list|)
expr_stmt|;
name|SAA7196_WRITE
argument_list|(
name|mtr
argument_list|,
literal|0x22
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
name|SAA7196_WRITE
argument_list|(
name|mtr
argument_list|,
literal|0x24
argument_list|,
operator|(
name|SAA7196_REG
argument_list|(
name|mtr
argument_list|,
literal|0x24
argument_list|)
operator||
literal|0x0c
operator|)
argument_list|)
expr_stmt|;
name|SAA7196_WRITE
argument_list|(
name|mtr
argument_list|,
literal|0x26
argument_list|,
literal|0x20
argument_list|)
expr_stmt|;
name|SAA7196_WRITE
argument_list|(
name|mtr
argument_list|,
literal|0x28
argument_list|,
operator|(
name|SAA7196_REG
argument_list|(
name|mtr
argument_list|,
literal|0x28
argument_list|)
operator|&
operator|~
literal|0x0c
operator|)
operator||
literal|0x04
argument_list|)
expr_stmt|;
if|if
condition|(
name|mtr
operator|->
name|flags
operator|&
name|METEOR_RGB
condition|)
block|{
name|bt254_ntsc
argument_list|(
name|mtr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|METEOR_FMT_AUTOMODE
case|:
name|mtr
operator|->
name|flags
operator|=
operator|(
name|mtr
operator|->
name|flags
operator|&
operator|~
name|METEOR_FORM_MASK
operator|)
operator||
name|METEOR_AUTOMODE
expr_stmt|;
name|SAA7196_WRITE
argument_list|(
name|mtr
argument_list|,
name|SAA7196_STDC
argument_list|,
operator|(
name|SAA7196_REG
argument_list|(
name|mtr
argument_list|,
name|SAA7196_STDC
argument_list|)
operator|&
operator|~
literal|0x01
operator|)
argument_list|)
expr_stmt|;
name|SAA7196_WRITE
argument_list|(
name|mtr
argument_list|,
literal|0x0f
argument_list|,
operator|(
name|SAA7196_REG
argument_list|(
name|mtr
argument_list|,
literal|0x0f
argument_list|)
operator|&
operator|~
literal|0xe0
operator|)
operator||
literal|0x80
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
name|EINVAL
return|;
block|}
break|break;
case|case
name|METEORGFMT
case|:
comment|/* get input format */
operator|*
operator|(
name|u_long
operator|*
operator|)
name|arg
operator|=
name|mtr
operator|->
name|flags
operator|&
name|METEOR_FORM_MASK
expr_stmt|;
break|break;
case|case
name|METEORCAPTUR
case|:
name|temp
operator|=
name|mtr
operator|->
name|flags
expr_stmt|;
switch|switch
condition|(
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
condition|)
block|{
case|case
name|METEOR_CAP_SINGLE
case|:
if|if
condition|(
name|mtr
operator|->
name|bigbuf
operator|==
literal|0
condition|)
comment|/* no frame buffer allocated */
return|return
operator|(
name|ENOMEM
operator|)
return|;
if|if
condition|(
name|temp
operator|&
name|METEOR_CAP_MASK
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
comment|/* already capturing */
name|start_capture
argument_list|(
name|mtr
argument_list|,
name|METEOR_SINGLE
argument_list|)
expr_stmt|;
comment|/* wait for capture to complete */
name|error
operator|=
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
name|mtr
argument_list|,
name|METPRI
argument_list|,
literal|"capturing"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|printf
argument_list|(
literal|"meteor%d: ioctl: tsleep error %d\n"
argument_list|,
name|unit
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|mtr
operator|->
name|flags
operator|&=
operator|~
operator|(
name|METEOR_SINGLE
operator||
name|METEOR_WANT_MASK
operator|)
expr_stmt|;
break|break;
case|case
name|METEOR_CAP_CONTINOUS
case|:
if|if
condition|(
name|mtr
operator|->
name|bigbuf
operator|==
literal|0
condition|)
comment|/* no frame buffer allocated */
return|return
operator|(
name|ENOMEM
operator|)
return|;
if|if
condition|(
name|temp
operator|&
name|METEOR_CAP_MASK
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
comment|/* already capturing */
name|start_capture
argument_list|(
name|mtr
argument_list|,
name|METEOR_CONTIN
argument_list|)
expr_stmt|;
break|break;
case|case
name|METEOR_CAP_STOP_CONT
case|:
if|if
condition|(
name|mtr
operator|->
name|flags
operator|&
name|METEOR_CONTIN
condition|)
block|{
comment|/* turn off capture */
name|base
operator|->
name|cap_cntl
operator|=
literal|0x8ff0
expr_stmt|;
name|mtr
operator|->
name|flags
operator|&=
operator|~
operator|(
name|METEOR_CONTIN
operator||
name|METEOR_WANT_MASK
operator|)
expr_stmt|;
block|}
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|METEORCAPFRM
case|:
name|frame
operator|=
operator|(
expr|struct
name|meteor_capframe
operator|*
operator|)
name|arg
expr_stmt|;
if|if
condition|(
operator|!
name|frame
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
switch|switch
condition|(
name|frame
operator|->
name|command
condition|)
block|{
case|case
name|METEOR_CAP_N_FRAMES
case|:
if|if
condition|(
name|mtr
operator|->
name|flags
operator|&
name|METEOR_CAP_MASK
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
if|if
condition|(
name|mtr
operator|->
name|flags
operator|&
operator|(
name|METEOR_YUV_PLANAR
operator||
name|METEOR_YUV_422
operator|)
condition|)
comment|/* XXX */
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* should fix intr so we allow these */
if|if
condition|(
name|mtr
operator|->
name|bigbuf
operator|==
literal|0
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
if|if
condition|(
operator|(
name|mtr
operator|->
name|frames
operator|<
literal|2
operator|)
operator|||
operator|(
name|frame
operator|->
name|lowat
operator|<
literal|1
operator|||
name|frame
operator|->
name|lowat
operator|>=
name|mtr
operator|->
name|frames
operator|)
operator|||
operator|(
name|frame
operator|->
name|hiwat
operator|<
literal|1
operator|||
name|frame
operator|->
name|hiwat
operator|>=
name|mtr
operator|->
name|frames
operator|)
operator|||
operator|(
name|frame
operator|->
name|lowat
operator|>
name|frame
operator|->
name|hiwat
operator|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* meteor_mem structure is on the page after the data */
name|mem
operator|=
name|mtr
operator|->
name|mem
operator|=
operator|(
expr|struct
name|meteor_mem
operator|*
operator|)
operator|(
name|mtr
operator|->
name|bigbuf
operator|+
operator|(
name|round_page
argument_list|(
name|mtr
operator|->
name|frame_size
operator|*
name|mtr
operator|->
name|frames
argument_list|)
operator|)
operator|)
expr_stmt|;
name|mtr
operator|->
name|current
operator|=
literal|1
expr_stmt|;
name|mtr
operator|->
name|synch_wait
operator|=
literal|0
expr_stmt|;
name|mem
operator|->
name|num_bufs
operator|=
name|mtr
operator|->
name|frames
expr_stmt|;
name|mem
operator|->
name|frame_size
operator|=
name|mtr
operator|->
name|frame_size
expr_stmt|;
comment|/* user and kernel change these */
name|mem
operator|->
name|lowat
operator|=
name|frame
operator|->
name|lowat
expr_stmt|;
name|mem
operator|->
name|hiwat
operator|=
name|frame
operator|->
name|hiwat
expr_stmt|;
name|mem
operator|->
name|active
operator|=
literal|0
expr_stmt|;
name|mem
operator|->
name|num_active_bufs
operator|=
literal|0
expr_stmt|;
comment|/* Start capture */
name|start_capture
argument_list|(
name|mtr
argument_list|,
name|METEOR_SYNCAP
argument_list|)
expr_stmt|;
break|break;
case|case
name|METEOR_CAP_STOP_FRAMES
case|:
if|if
condition|(
name|mtr
operator|->
name|flags
operator|&
name|METEOR_SYNCAP
condition|)
block|{
comment|/* turn off capture */
name|base
operator|->
name|cap_cntl
operator|=
literal|0x8ff0
expr_stmt|;
name|mtr
operator|->
name|flags
operator|&=
operator|~
operator|(
name|METEOR_SYNCAP
operator||
name|METEOR_WANT_MASK
operator|)
expr_stmt|;
block|}
break|break;
case|case
name|METEOR_HALT_N_FRAMES
case|:
if|if
condition|(
name|mtr
operator|->
name|flags
operator|&
name|METEOR_SYNCAP
condition|)
block|{
name|base
operator|->
name|cap_cntl
operator|=
literal|0x8ff0
expr_stmt|;
name|mtr
operator|->
name|flags
operator|&=
operator|~
operator|(
name|METEOR_WANT_MASK
operator|)
expr_stmt|;
block|}
break|break;
case|case
name|METEOR_CONT_N_FRAMES
case|:
if|if
condition|(
operator|!
operator|(
name|mtr
operator|->
name|flags
operator|&
name|METEOR_SYNCAP
operator|)
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|start_capture
argument_list|(
name|mtr
argument_list|,
name|METEOR_SYNCAP
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|METEORSETGEO
case|:
name|geo
operator|=
operator|(
expr|struct
name|meteor_geomet
operator|*
operator|)
name|arg
expr_stmt|;
comment|/* Either even or odd, if even& odd, then these a zero */
if|if
condition|(
operator|(
name|geo
operator|->
name|oformat
operator|&
name|METEOR_GEO_ODD_ONLY
operator|)
operator|&&
operator|(
name|geo
operator|->
name|oformat
operator|&
name|METEOR_GEO_EVEN_ONLY
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"meteor%d: ioctl: Geometry odd or even only.\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
comment|/* set/clear even/odd flags */
if|if
condition|(
name|geo
operator|->
name|oformat
operator|&
name|METEOR_GEO_ODD_ONLY
condition|)
name|mtr
operator|->
name|flags
operator||=
name|METEOR_ONLY_ODD_FIELDS
expr_stmt|;
else|else
name|mtr
operator|->
name|flags
operator|&=
operator|~
name|METEOR_ONLY_ODD_FIELDS
expr_stmt|;
if|if
condition|(
name|geo
operator|->
name|oformat
operator|&
name|METEOR_GEO_EVEN_ONLY
condition|)
name|mtr
operator|->
name|flags
operator||=
name|METEOR_ONLY_EVEN_FIELDS
expr_stmt|;
else|else
name|mtr
operator|->
name|flags
operator|&=
operator|~
name|METEOR_ONLY_EVEN_FIELDS
expr_stmt|;
comment|/* can't change parameters while capturing */
if|if
condition|(
name|mtr
operator|->
name|flags
operator|&
name|METEOR_CAP_MASK
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
if|if
condition|(
operator|(
name|geo
operator|->
name|columns
operator|&
literal|0x3fe
operator|)
operator|!=
name|geo
operator|->
name|columns
condition|)
block|{
name|printf
argument_list|(
literal|"meteor%d: ioctl: %d: columns too large or not even.\n"
argument_list|,
name|unit
argument_list|,
name|geo
operator|->
name|columns
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|(
name|geo
operator|->
name|rows
operator|&
literal|0x7fe
operator|)
operator|!=
name|geo
operator|->
name|rows
operator|)
operator|||
operator|(
operator|(
name|geo
operator|->
name|oformat
operator|&
name|METEOR_GEO_FIELD_MASK
operator|)
operator|&&
operator|(
operator|(
name|geo
operator|->
name|rows
operator|&
literal|0x3fe
operator|)
operator|!=
name|geo
operator|->
name|rows
operator|)
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"meteor%d: ioctl: %d: rows too large or not even.\n"
argument_list|,
name|unit
argument_list|,
name|geo
operator|->
name|rows
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
if|if
condition|(
name|geo
operator|->
name|frames
operator|>
literal|32
condition|)
block|{
name|printf
argument_list|(
literal|"meteor%d: ioctl: too many frames.\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
if|if
condition|(
operator|(
name|temp
operator|=
name|geo
operator|->
name|rows
operator|*
name|geo
operator|->
name|columns
operator|*
name|geo
operator|->
name|frames
operator|*
literal|2
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|geo
operator|->
name|oformat
operator|&
name|METEOR_GEO_RGB24
condition|)
name|temp
operator|=
name|temp
operator|*
literal|2
expr_stmt|;
comment|/* meteor_mem structure for SYNC Capture */
if|if
condition|(
name|geo
operator|->
name|frames
operator|>
literal|1
condition|)
name|temp
operator|+=
name|PAGE_SIZE
expr_stmt|;
name|temp
operator|=
name|btoc
argument_list|(
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|>
name|mtr
operator|->
name|alloc_pages
ifdef|#
directive|ifdef
name|METEOR_TEST_VIDEO
operator|&&
name|mtr
operator|->
name|video
operator|.
name|addr
operator|==
literal|0
endif|#
directive|endif
condition|)
block|{
name|buf
operator|=
name|get_meteor_mem
argument_list|(
name|unit
argument_list|,
name|temp
operator|*
name|PAGE_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|!=
literal|0
condition|)
block|{
name|kmem_free
argument_list|(
name|kernel_map
argument_list|,
name|mtr
operator|->
name|bigbuf
argument_list|,
operator|(
name|mtr
operator|->
name|alloc_pages
operator|*
name|PAGE_SIZE
operator|)
argument_list|)
expr_stmt|;
name|mtr
operator|->
name|bigbuf
operator|=
name|buf
expr_stmt|;
name|mtr
operator|->
name|alloc_pages
operator|=
name|temp
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"meteor%d: ioctl: Allocating %d bytes\n"
argument_list|,
name|unit
argument_list|,
name|temp
operator|*
name|PAGE_SIZE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|ENOMEM
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
name|mtr
operator|->
name|rows
operator|=
name|geo
operator|->
name|rows
expr_stmt|;
name|mtr
operator|->
name|cols
operator|=
name|geo
operator|->
name|columns
expr_stmt|;
name|mtr
operator|->
name|frames
operator|=
name|geo
operator|->
name|frames
expr_stmt|;
ifdef|#
directive|ifdef
name|METEOR_TEST_VIDEO
if|if
condition|(
name|mtr
operator|->
name|video
operator|.
name|addr
condition|)
name|buf
operator|=
name|vtophys
argument_list|(
name|mtr
operator|->
name|video
operator|.
name|addr
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|buf
operator|=
name|vtophys
argument_list|(
name|mtr
operator|->
name|bigbuf
argument_list|)
expr_stmt|;
comment|/* set defaults and end of buffer locations */
name|base
operator|->
name|dma1e
operator|=
name|buf
expr_stmt|;
name|base
operator|->
name|dma2e
operator|=
name|buf
expr_stmt|;
name|base
operator|->
name|dma3e
operator|=
name|buf
expr_stmt|;
name|base
operator|->
name|dma1o
operator|=
name|buf
expr_stmt|;
name|base
operator|->
name|dma2o
operator|=
name|buf
expr_stmt|;
name|base
operator|->
name|dma3o
operator|=
name|buf
expr_stmt|;
name|base
operator|->
name|stride1e
operator|=
literal|0
expr_stmt|;
name|base
operator|->
name|stride2e
operator|=
literal|0
expr_stmt|;
name|base
operator|->
name|stride3e
operator|=
literal|0
expr_stmt|;
name|base
operator|->
name|stride1o
operator|=
literal|0
expr_stmt|;
name|base
operator|->
name|stride2o
operator|=
literal|0
expr_stmt|;
name|base
operator|->
name|stride3o
operator|=
literal|0
expr_stmt|;
comment|/* set end of DMA location, even/odd */
name|base
operator|->
name|dma_end_e
operator|=
name|base
operator|->
name|dma_end_o
operator|=
name|buf
operator|+
name|mtr
operator|->
name|alloc_pages
operator|*
name|PAGE_SIZE
expr_stmt|;
comment|/* 		 * Determine if we can use the hardware range detect. 		 */
if|if
condition|(
name|mtr
operator|->
name|alloc_pages
operator|*
name|PAGE_SIZE
operator|<
name|RANGE_BOUNDARY
operator|&&
operator|(
operator|(
name|buf
operator|&
literal|0xff000000
operator|)
operator||
name|base
operator|->
name|dma_end_e
operator|)
operator|==
operator|(
name|buf
operator|+
name|mtr
operator|->
name|alloc_pages
operator|*
name|PAGE_SIZE
operator|)
condition|)
name|mtr
operator|->
name|range_enable
operator|=
literal|0x8000
expr_stmt|;
else|else
block|{
name|mtr
operator|->
name|range_enable
operator|=
literal|0x0
expr_stmt|;
name|base
operator|->
name|dma_end_e
operator|=
name|base
operator|->
name|dma_end_o
operator|=
literal|0xffffffff
expr_stmt|;
block|}
switch|switch
condition|(
name|geo
operator|->
name|oformat
operator|&
name|METEOR_GEO_OUTPUT_MASK
condition|)
block|{
case|case
literal|0
case|:
comment|/* default */
case|case
name|METEOR_GEO_RGB16
case|:
name|mtr
operator|->
name|depth
operator|=
literal|2
expr_stmt|;
name|mtr
operator|->
name|frame_size
operator|=
name|mtr
operator|->
name|rows
operator|*
name|mtr
operator|->
name|cols
operator|*
name|mtr
operator|->
name|depth
expr_stmt|;
name|mtr
operator|->
name|flags
operator|&=
operator|~
name|METEOR_OUTPUT_FMT_MASK
expr_stmt|;
name|mtr
operator|->
name|flags
operator||=
name|METEOR_RGB16
expr_stmt|;
name|temp
operator|=
name|mtr
operator|->
name|cols
operator|*
name|mtr
operator|->
name|depth
expr_stmt|;
comment|/* recal stride and starting point */
switch|switch
condition|(
name|mtr
operator|->
name|flags
operator|&
name|METEOR_ONLY_FIELDS_MASK
condition|)
block|{
case|case
name|METEOR_ONLY_ODD_FIELDS
case|:
name|base
operator|->
name|dma1o
operator|=
name|buf
expr_stmt|;
ifdef|#
directive|ifdef
name|METEOR_TEST_VIDEO
if|if
condition|(
name|mtr
operator|->
name|video
operator|.
name|addr
operator|&&
name|mtr
operator|->
name|video
operator|.
name|width
condition|)
name|base
operator|->
name|stride1o
operator|=
name|mtr
operator|->
name|video
operator|.
name|width
operator|-
name|temp
expr_stmt|;
endif|#
directive|endif
name|SAA7196_WRITE
argument_list|(
name|mtr
argument_list|,
literal|0x20
argument_list|,
literal|0xd0
argument_list|)
expr_stmt|;
break|break;
case|case
name|METEOR_ONLY_EVEN_FIELDS
case|:
name|base
operator|->
name|dma1e
operator|=
name|buf
expr_stmt|;
ifdef|#
directive|ifdef
name|METEOR_TEST_VIDEO
if|if
condition|(
name|mtr
operator|->
name|video
operator|.
name|addr
operator|&&
name|mtr
operator|->
name|video
operator|.
name|width
condition|)
name|base
operator|->
name|stride1e
operator|=
name|mtr
operator|->
name|video
operator|.
name|width
operator|-
name|temp
expr_stmt|;
endif|#
directive|endif
name|SAA7196_WRITE
argument_list|(
name|mtr
argument_list|,
literal|0x20
argument_list|,
literal|0xf0
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* interlaced even/odd */
name|base
operator|->
name|dma1e
operator|=
name|buf
expr_stmt|;
name|base
operator|->
name|dma1o
operator|=
name|buf
operator|+
name|temp
expr_stmt|;
name|base
operator|->
name|stride1e
operator|=
name|base
operator|->
name|stride1o
operator|=
name|temp
expr_stmt|;
ifdef|#
directive|ifdef
name|METEOR_TEST_VIDEO
if|if
condition|(
name|mtr
operator|->
name|video
operator|.
name|addr
operator|&&
name|mtr
operator|->
name|video
operator|.
name|width
condition|)
block|{
name|base
operator|->
name|dma1o
operator|=
name|buf
operator|+
name|mtr
operator|->
name|video
operator|.
name|width
expr_stmt|;
name|base
operator|->
name|stride1e
operator|=
name|base
operator|->
name|stride1o
operator|=
name|mtr
operator|->
name|video
operator|.
name|width
operator|-
name|temp
operator|+
name|mtr
operator|->
name|video
operator|.
name|width
expr_stmt|;
block|}
endif|#
directive|endif
name|SAA7196_WRITE
argument_list|(
name|mtr
argument_list|,
literal|0x20
argument_list|,
literal|0x90
argument_list|)
expr_stmt|;
break|break;
block|}
name|base
operator|->
name|routee
operator|=
name|base
operator|->
name|routeo
operator|=
literal|0xeeeeee01
expr_stmt|;
break|break;
case|case
name|METEOR_GEO_RGB24
case|:
name|mtr
operator|->
name|depth
operator|=
literal|4
expr_stmt|;
name|mtr
operator|->
name|frame_size
operator|=
name|mtr
operator|->
name|rows
operator|*
name|mtr
operator|->
name|cols
operator|*
name|mtr
operator|->
name|depth
expr_stmt|;
name|mtr
operator|->
name|flags
operator|&=
operator|~
name|METEOR_OUTPUT_FMT_MASK
expr_stmt|;
name|mtr
operator|->
name|flags
operator||=
name|METEOR_RGB24
expr_stmt|;
name|temp
operator|=
name|mtr
operator|->
name|cols
operator|*
name|mtr
operator|->
name|depth
expr_stmt|;
comment|/* recal stride and starting point */
switch|switch
condition|(
name|mtr
operator|->
name|flags
operator|&
name|METEOR_ONLY_FIELDS_MASK
condition|)
block|{
case|case
name|METEOR_ONLY_ODD_FIELDS
case|:
name|base
operator|->
name|dma1o
operator|=
name|buf
expr_stmt|;
ifdef|#
directive|ifdef
name|METEOR_TEST_VIDEO
if|if
condition|(
name|mtr
operator|->
name|video
operator|.
name|addr
operator|&&
name|mtr
operator|->
name|video
operator|.
name|width
condition|)
name|base
operator|->
name|stride1o
operator|=
name|mtr
operator|->
name|video
operator|.
name|width
operator|-
name|temp
expr_stmt|;
endif|#
directive|endif
name|SAA7196_WRITE
argument_list|(
name|mtr
argument_list|,
literal|0x20
argument_list|,
literal|0xd2
argument_list|)
expr_stmt|;
break|break;
case|case
name|METEOR_ONLY_EVEN_FIELDS
case|:
name|base
operator|->
name|dma1e
operator|=
name|buf
expr_stmt|;
ifdef|#
directive|ifdef
name|METEOR_TEST_VIDEO
if|if
condition|(
name|mtr
operator|->
name|video
operator|.
name|addr
operator|&&
name|mtr
operator|->
name|video
operator|.
name|width
condition|)
name|base
operator|->
name|stride1e
operator|=
name|mtr
operator|->
name|video
operator|.
name|width
operator|-
name|temp
expr_stmt|;
endif|#
directive|endif
name|SAA7196_WRITE
argument_list|(
name|mtr
argument_list|,
literal|0x20
argument_list|,
literal|0xf2
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* interlaced even/odd */
name|base
operator|->
name|dma1e
operator|=
name|buf
expr_stmt|;
name|base
operator|->
name|dma1o
operator|=
name|buf
operator|+
name|mtr
operator|->
name|cols
operator|*
name|mtr
operator|->
name|depth
expr_stmt|;
name|base
operator|->
name|stride1e
operator|=
name|base
operator|->
name|stride1o
operator|=
name|mtr
operator|->
name|cols
operator|*
name|mtr
operator|->
name|depth
expr_stmt|;
ifdef|#
directive|ifdef
name|METEOR_TEST_VIDEO
if|if
condition|(
name|mtr
operator|->
name|video
operator|.
name|addr
operator|&&
name|mtr
operator|->
name|video
operator|.
name|width
condition|)
block|{
name|base
operator|->
name|dma1o
operator|=
name|buf
operator|+
name|mtr
operator|->
name|video
operator|.
name|width
expr_stmt|;
name|base
operator|->
name|stride1e
operator|=
name|base
operator|->
name|stride1o
operator|=
name|mtr
operator|->
name|video
operator|.
name|width
operator|-
name|temp
operator|+
name|mtr
operator|->
name|video
operator|.
name|width
expr_stmt|;
block|}
endif|#
directive|endif
name|SAA7196_WRITE
argument_list|(
name|mtr
argument_list|,
literal|0x20
argument_list|,
literal|0x92
argument_list|)
expr_stmt|;
break|break;
block|}
name|base
operator|->
name|routee
operator|=
name|base
operator|->
name|routeo
operator|=
literal|0x39393900
expr_stmt|;
break|break;
case|case
name|METEOR_GEO_YUV_PLANAR
case|:
name|mtr
operator|->
name|depth
operator|=
literal|2
expr_stmt|;
name|temp
operator|=
name|mtr
operator|->
name|rows
operator|*
name|mtr
operator|->
name|cols
expr_stmt|;
comment|/* compute frame size */
name|mtr
operator|->
name|frame_size
operator|=
name|temp
operator|*
name|mtr
operator|->
name|depth
expr_stmt|;
name|mtr
operator|->
name|flags
operator|&=
operator|~
name|METEOR_OUTPUT_FMT_MASK
expr_stmt|;
name|mtr
operator|->
name|flags
operator||=
name|METEOR_YUV_PLANAR
expr_stmt|;
comment|/* recal stride and starting point */
switch|switch
condition|(
name|mtr
operator|->
name|flags
operator|&
name|METEOR_ONLY_FIELDS_MASK
condition|)
block|{
case|case
name|METEOR_ONLY_ODD_FIELDS
case|:
name|base
operator|->
name|dma1o
operator|=
name|buf
expr_stmt|;
comment|/* Y Odd */
name|base
operator|->
name|dma2o
operator|=
name|buf
operator|+
name|temp
expr_stmt|;
comment|/* U Odd */
name|temp
operator|>>=
literal|1
expr_stmt|;
name|base
operator|->
name|dma3o
operator|=
name|base
operator|->
name|dma2o
operator|+
name|temp
expr_stmt|;
comment|/* V Odd */
name|SAA7196_WRITE
argument_list|(
name|mtr
argument_list|,
literal|0x20
argument_list|,
literal|0xd1
argument_list|)
expr_stmt|;
break|break;
case|case
name|METEOR_ONLY_EVEN_FIELDS
case|:
name|base
operator|->
name|dma1e
operator|=
name|buf
expr_stmt|;
comment|/* Y Even */
name|base
operator|->
name|dma2e
operator|=
name|buf
operator|+
name|temp
expr_stmt|;
comment|/* U Even */
name|temp
operator|>>=
literal|1
expr_stmt|;
name|base
operator|->
name|dma2e
operator|=
name|base
operator|->
name|dma2e
operator|+
name|temp
expr_stmt|;
comment|/* V Even */
name|SAA7196_WRITE
argument_list|(
name|mtr
argument_list|,
literal|0x20
argument_list|,
literal|0xf1
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* interlaced even/odd */
name|base
operator|->
name|dma1e
operator|=
name|buf
expr_stmt|;
comment|/* Y Even */
name|base
operator|->
name|dma2e
operator|=
name|buf
operator|+
name|temp
expr_stmt|;
comment|/* U Even */
name|temp
operator|>>=
literal|2
expr_stmt|;
name|base
operator|->
name|dma3e
operator|=
name|base
operator|->
name|dma2e
operator|+
name|temp
expr_stmt|;
comment|/* V Even */
name|base
operator|->
name|dma1o
operator|=
name|base
operator|->
name|dma1e
operator|+
name|mtr
operator|->
name|cols
expr_stmt|;
comment|/* Y Odd */
name|base
operator|->
name|dma2o
operator|=
name|base
operator|->
name|dma3e
operator|+
name|temp
expr_stmt|;
comment|/* U Odd */
name|base
operator|->
name|dma3o
operator|=
name|base
operator|->
name|dma2o
operator|+
name|temp
expr_stmt|;
comment|/* V Odd */
name|base
operator|->
name|stride1e
operator|=
name|base
operator|->
name|stride1o
operator|=
name|mtr
operator|->
name|cols
expr_stmt|;
name|SAA7196_WRITE
argument_list|(
name|mtr
argument_list|,
literal|0x20
argument_list|,
literal|0x91
argument_list|)
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
name|geo
operator|->
name|oformat
operator|&
operator|(
name|METEOR_GEO_YUV_12
operator||
name|METEOR_GEO_YUV_9
operator|)
condition|)
block|{
case|case
name|METEOR_GEO_YUV_9
case|:
name|base
operator|->
name|routee
operator|=
name|base
operator|->
name|routeo
operator|=
literal|0xaaaaffc3
expr_stmt|;
break|break;
case|case
name|METEOR_GEO_YUV_12
case|:
name|base
operator|->
name|routee
operator|=
name|base
operator|->
name|routeo
operator|=
literal|0xaaaaffc2
expr_stmt|;
break|break;
default|default:
name|base
operator|->
name|routee
operator|=
name|base
operator|->
name|routeo
operator|=
literal|0xaaaaffc1
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|METEOR_GEO_YUV_422
case|:
comment|/* same as planer, different uv order */
name|mtr
operator|->
name|depth
operator|=
literal|2
expr_stmt|;
name|temp
operator|=
name|mtr
operator|->
name|rows
operator|*
name|mtr
operator|->
name|cols
expr_stmt|;
comment|/* compute frame size */
name|mtr
operator|->
name|frame_size
operator|=
name|temp
operator|*
name|mtr
operator|->
name|depth
expr_stmt|;
name|mtr
operator|->
name|flags
operator|&=
operator|~
name|METEOR_OUTPUT_FMT_MASK
expr_stmt|;
name|mtr
operator|->
name|flags
operator||=
name|METEOR_YUV_422
expr_stmt|;
switch|switch
condition|(
name|mtr
operator|->
name|flags
operator|&
name|METEOR_ONLY_FIELDS_MASK
condition|)
block|{
case|case
name|METEOR_ONLY_ODD_FIELDS
case|:
name|base
operator|->
name|dma1o
operator|=
name|buf
expr_stmt|;
name|base
operator|->
name|dma2o
operator|=
name|buf
operator|+
name|temp
expr_stmt|;
name|base
operator|->
name|dma3o
operator|=
name|base
operator|->
name|dma2o
operator|+
operator|(
name|temp
operator|>>
literal|1
operator|)
expr_stmt|;
name|SAA7196_WRITE
argument_list|(
name|mtr
argument_list|,
literal|0x20
argument_list|,
literal|0xd1
argument_list|)
expr_stmt|;
break|break;
case|case
name|METEOR_ONLY_EVEN_FIELDS
case|:
name|base
operator|->
name|dma1e
operator|=
name|buf
expr_stmt|;
name|base
operator|->
name|dma2e
operator|=
name|buf
operator|+
name|temp
expr_stmt|;
name|base
operator|->
name|dma3e
operator|=
name|base
operator|->
name|dma2e
operator|+
operator|(
name|temp
operator|>>
literal|1
operator|)
expr_stmt|;
name|SAA7196_WRITE
argument_list|(
name|mtr
argument_list|,
literal|0x20
argument_list|,
literal|0xf1
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* interlaced even/odd */
name|base
operator|->
name|dma1e
operator|=
name|buf
expr_stmt|;
comment|/* Y even */
name|base
operator|->
name|dma2e
operator|=
name|buf
operator|+
name|temp
expr_stmt|;
comment|/* U even */
name|base
operator|->
name|dma3e
operator|=
name|base
operator|->
name|dma2e
operator|+
operator|(
name|temp
operator|>>
literal|1
operator|)
expr_stmt|;
comment|/* V even */
name|base
operator|->
name|dma1o
operator|=
name|base
operator|->
name|dma1e
operator|+
name|mtr
operator|->
name|cols
expr_stmt|;
comment|/* Y odd */
name|temp
operator|=
name|mtr
operator|->
name|cols
operator|>>
literal|1
expr_stmt|;
name|base
operator|->
name|dma2o
operator|=
name|base
operator|->
name|dma2e
operator|+
name|temp
expr_stmt|;
comment|/* U odd */
name|base
operator|->
name|dma3o
operator|=
name|base
operator|->
name|dma3e
operator|+
name|temp
expr_stmt|;
comment|/* V odd */
name|base
operator|->
name|stride1e
operator|=
name|base
operator|->
name|stride1o
operator|=
name|mtr
operator|->
name|cols
expr_stmt|;
comment|/* Y stride */
name|base
operator|->
name|stride2e
operator|=
name|base
operator|->
name|stride2o
operator|=
name|temp
expr_stmt|;
comment|/* U stride */
name|base
operator|->
name|stride3e
operator|=
name|base
operator|->
name|stride3o
operator|=
name|temp
expr_stmt|;
comment|/* V stride */
name|SAA7196_WRITE
argument_list|(
name|mtr
argument_list|,
literal|0x20
argument_list|,
literal|0x91
argument_list|)
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
name|geo
operator|->
name|oformat
operator|&
operator|(
name|METEOR_GEO_YUV_12
operator||
name|METEOR_GEO_YUV_9
operator|)
condition|)
block|{
case|case
name|METEOR_GEO_YUV_9
case|:
name|base
operator|->
name|routee
operator|=
name|base
operator|->
name|routeo
operator|=
literal|0xaaaaffc3
expr_stmt|;
break|break;
case|case
name|METEOR_GEO_YUV_12
case|:
name|base
operator|->
name|routee
operator|=
name|base
operator|->
name|routeo
operator|=
literal|0xaaaaffc2
expr_stmt|;
break|break;
default|default:
name|base
operator|->
name|routee
operator|=
name|base
operator|->
name|routeo
operator|=
literal|0xaaaaffc1
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|METEOR_GEO_YUV_PACKED
case|:
name|mtr
operator|->
name|depth
operator|=
literal|2
expr_stmt|;
name|mtr
operator|->
name|frame_size
operator|=
name|mtr
operator|->
name|rows
operator|*
name|mtr
operator|->
name|cols
operator|*
name|mtr
operator|->
name|depth
expr_stmt|;
name|mtr
operator|->
name|flags
operator|&=
operator|~
name|METEOR_OUTPUT_FMT_MASK
expr_stmt|;
name|mtr
operator|->
name|flags
operator||=
name|METEOR_YUV_PACKED
expr_stmt|;
comment|/* recal stride and odd starting point */
switch|switch
condition|(
name|mtr
operator|->
name|flags
operator|&
name|METEOR_ONLY_FIELDS_MASK
condition|)
block|{
case|case
name|METEOR_ONLY_ODD_FIELDS
case|:
name|base
operator|->
name|dma1o
operator|=
name|buf
expr_stmt|;
name|SAA7196_WRITE
argument_list|(
name|mtr
argument_list|,
literal|0x20
argument_list|,
literal|0xd1
argument_list|)
expr_stmt|;
break|break;
case|case
name|METEOR_ONLY_EVEN_FIELDS
case|:
name|base
operator|->
name|dma1e
operator|=
name|buf
expr_stmt|;
name|SAA7196_WRITE
argument_list|(
name|mtr
argument_list|,
literal|0x20
argument_list|,
literal|0xf1
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* interlaced even/odd */
name|base
operator|->
name|dma1e
operator|=
name|buf
expr_stmt|;
name|base
operator|->
name|dma1o
operator|=
name|buf
operator|+
name|mtr
operator|->
name|cols
operator|*
name|mtr
operator|->
name|depth
expr_stmt|;
name|base
operator|->
name|stride1e
operator|=
name|base
operator|->
name|stride1o
operator|=
name|mtr
operator|->
name|cols
operator|*
name|mtr
operator|->
name|depth
expr_stmt|;
name|SAA7196_WRITE
argument_list|(
name|mtr
argument_list|,
literal|0x20
argument_list|,
literal|0x91
argument_list|)
expr_stmt|;
break|break;
block|}
name|base
operator|->
name|routee
operator|=
name|base
operator|->
name|routeo
operator|=
literal|0xeeeeee41
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
comment|/* invalid argument */
name|printf
argument_list|(
literal|"meteor%d: ioctl: invalid output format\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* set cols */
name|SAA7196_WRITE
argument_list|(
name|mtr
argument_list|,
literal|0x21
argument_list|,
name|mtr
operator|->
name|cols
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|SAA7196_WRITE
argument_list|(
name|mtr
argument_list|,
literal|0x24
argument_list|,
operator|(
operator|(
name|SAA7196_REG
argument_list|(
name|mtr
argument_list|,
literal|0x24
argument_list|)
operator|&
operator|~
literal|0x03
operator|)
operator||
operator|(
operator|(
name|mtr
operator|->
name|cols
operator|>>
literal|8
operator|)
operator|&
literal|0x03
operator|)
operator|)
argument_list|)
expr_stmt|;
comment|/* set rows */
if|if
condition|(
name|mtr
operator|->
name|flags
operator|&
name|METEOR_ONLY_FIELDS_MASK
condition|)
block|{
name|SAA7196_WRITE
argument_list|(
name|mtr
argument_list|,
literal|0x25
argument_list|,
operator|(
operator|(
name|mtr
operator|->
name|rows
operator|)
operator|&
literal|0xff
operator|)
argument_list|)
expr_stmt|;
name|SAA7196_WRITE
argument_list|(
name|mtr
argument_list|,
literal|0x28
argument_list|,
operator|(
operator|(
name|SAA7196_REG
argument_list|(
name|mtr
argument_list|,
literal|0x28
argument_list|)
operator|&
operator|~
literal|0x03
operator|)
operator||
operator|(
operator|(
name|mtr
operator|->
name|rows
operator|>>
literal|8
operator|)
operator|&
literal|0x03
operator|)
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Interlaced */
name|SAA7196_WRITE
argument_list|(
name|mtr
argument_list|,
literal|0x25
argument_list|,
operator|(
operator|(
name|mtr
operator|->
name|rows
operator|>>
literal|1
operator|)
operator|&
literal|0xff
operator|)
argument_list|)
expr_stmt|;
name|SAA7196_WRITE
argument_list|(
name|mtr
argument_list|,
literal|0x28
argument_list|,
operator|(
operator|(
name|SAA7196_REG
argument_list|(
name|mtr
argument_list|,
literal|0x28
argument_list|)
operator|&
operator|~
literal|0x03
operator|)
operator||
operator|(
operator|(
name|mtr
operator|->
name|rows
operator|>>
literal|9
operator|)
operator|&
literal|0x03
operator|)
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* set signed/unsigned chrominance */
name|SAA7196_WRITE
argument_list|(
name|mtr
argument_list|,
literal|0x30
argument_list|,
operator|(
name|SAA7196_REG
argument_list|(
name|mtr
argument_list|,
literal|0x30
argument_list|)
operator|&
operator|~
literal|0x10
operator|)
operator||
operator|(
operator|(
name|geo
operator|->
name|oformat
operator|&
name|METEOR_GEO_UNSIGNED
operator|)
condition|?
literal|0
else|:
literal|0x10
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|METEORGETGEO
case|:
name|geo
operator|=
operator|(
expr|struct
name|meteor_geomet
operator|*
operator|)
name|arg
expr_stmt|;
name|geo
operator|->
name|rows
operator|=
name|mtr
operator|->
name|rows
expr_stmt|;
name|geo
operator|->
name|columns
operator|=
name|mtr
operator|->
name|cols
expr_stmt|;
name|geo
operator|->
name|frames
operator|=
name|mtr
operator|->
name|frames
expr_stmt|;
name|geo
operator|->
name|oformat
operator|=
operator|(
name|mtr
operator|->
name|flags
operator|&
name|METEOR_OUTPUT_FMT_MASK
operator|)
operator||
operator|(
name|mtr
operator|->
name|flags
operator|&
name|METEOR_ONLY_FIELDS_MASK
operator|)
operator||
operator|(
name|SAA7196_REG
argument_list|(
name|mtr
argument_list|,
literal|0x30
argument_list|)
operator|&
literal|0x10
condition|?
literal|0
else|:
name|METEOR_GEO_UNSIGNED
operator|)
expr_stmt|;
switch|switch
condition|(
name|base
operator|->
name|routee
operator|&
literal|0xff
condition|)
block|{
case|case
literal|0xc3
case|:
name|geo
operator|->
name|oformat
operator||=
name|METEOR_GEO_YUV_9
expr_stmt|;
break|break;
case|case
literal|0xc2
case|:
name|geo
operator|->
name|oformat
operator||=
name|METEOR_GEO_YUV_12
expr_stmt|;
break|break;
default|default:
break|break;
block|}
break|break;
case|case
name|METEORSCOUNT
case|:
comment|/* (re)set error counts */
name|cnt
operator|=
operator|(
expr|struct
name|meteor_counts
operator|*
operator|)
name|arg
expr_stmt|;
name|mtr
operator|->
name|fifo_errors
operator|=
name|cnt
operator|->
name|fifo_errors
expr_stmt|;
name|mtr
operator|->
name|dma_errors
operator|=
name|cnt
operator|->
name|dma_errors
expr_stmt|;
name|mtr
operator|->
name|frames_captured
operator|=
name|cnt
operator|->
name|frames_captured
expr_stmt|;
name|mtr
operator|->
name|even_fields_captured
operator|=
name|cnt
operator|->
name|even_fields_captured
expr_stmt|;
name|mtr
operator|->
name|odd_fields_captured
operator|=
name|cnt
operator|->
name|odd_fields_captured
expr_stmt|;
break|break;
case|case
name|METEORGCOUNT
case|:
comment|/* get error counts */
name|cnt
operator|=
operator|(
expr|struct
name|meteor_counts
operator|*
operator|)
name|arg
expr_stmt|;
name|cnt
operator|->
name|fifo_errors
operator|=
name|mtr
operator|->
name|fifo_errors
expr_stmt|;
name|cnt
operator|->
name|dma_errors
operator|=
name|mtr
operator|->
name|dma_errors
expr_stmt|;
name|cnt
operator|->
name|frames_captured
operator|=
name|mtr
operator|->
name|frames_captured
expr_stmt|;
name|cnt
operator|->
name|even_fields_captured
operator|=
name|mtr
operator|->
name|even_fields_captured
expr_stmt|;
name|cnt
operator|->
name|odd_fields_captured
operator|=
name|mtr
operator|->
name|odd_fields_captured
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"meteor%d: ioctl: invalid ioctl request\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOTTY
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|meteor_mmap
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|vm_offset_t
name|offset
parameter_list|,
name|int
name|nprot
parameter_list|)
block|{
name|int
name|unit
decl_stmt|;
name|meteor_reg_t
modifier|*
name|mtr
decl_stmt|;
name|unit
operator|=
name|UNIT
argument_list|(
name|minor
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|unit
operator|>=
name|NMETEOR
condition|)
comment|/* at this point could this happen? */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|mtr
operator|=
operator|&
operator|(
name|meteor
index|[
name|unit
index|]
operator|)
expr_stmt|;
if|if
condition|(
name|nprot
operator|&
name|PROT_EXEC
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|offset
operator|>=
name|mtr
operator|->
name|alloc_pages
operator|*
name|PAGE_SIZE
condition|)
return|return
operator|-
literal|1
return|;
return|return
name|i386_btop
argument_list|(
name|vtophys
argument_list|(
name|mtr
operator|->
name|bigbuf
argument_list|)
operator|+
name|offset
argument_list|)
return|;
block|}
end_function

end_unit

