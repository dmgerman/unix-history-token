begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* BT848 1.3-ALPHA  Driver for Brooktree's Bt848 based cards.    The Brooktree  BT848 Driver driver is based upon Mark Tinguely and    Jim Lowe's driver for the Matrox Meteor PCI card . The     Philips SAA 7116 and SAA 7196 are very different chipsets than    the BT848. For starters, the BT848 is a one chipset solution and    it incorporates a RISC engine to control the DMA transfers --    that is it the actual dma process is control by a program which    resides in the hosts memory also the register definitions between    the Philips chipsets and the Bt848 are very different.     The original copyright notice by Mark and Jim is included mostly    to honor their fantastic work in the Matrox Meteor driver!        Enjoy,       Amancio   */
end_comment

begin_comment
comment|/*  * 1. Redistributions of source code must retain the   * Copyright (c) 1997 Amancio Hasty  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by Amancio Hasty  * 4. The name of the author may not be used to endorse or promote products   *    derived from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE  * DISCLAIMED.	IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,  * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN  * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  * POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * 1. Redistributions of source code must retain the   * Copyright (c) 1995 Mark Tinguely and Jim Lowe  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by Mark Tinguely and Jim Lowe  * 4. The name of the author may not be used to endorse or promote products   *    derived from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE  * DISCLAIMED.	IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,  * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN  * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  * POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*		Change History: 1.0		1/24/97	   First Alpha release  1.1		2/20/97	   Added video ioctl so we can do PCI To PCI 			   data transfers. This is for capturing data 			   directly to a vga frame buffer which has 			   a linear frame buffer. Minor code clean-up.  1.3		2/23/97	   Fixed system lock-up reported by  			   Randall Hopper<rhh@ct.picker.com>. This 			   problem seems somehow to be exhibited only 			   in his system. I changed the setting of 			   INT_MASK for CAP_CONTINUOUS to be exactly 			   the same as CAP_SINGLE apparently setting 			   bit 23 cleared the system lock up.  			   version 1.1 of the driver has been reported 			   to work with STB's WinTv, Hauppage's Wincast/Tv 			   and last but not least with the Intel Smart 			   Video Recorder.  1.4		3/9/97	   fsmp@freefall.org 			   Merged code to support tuners on STB and WinCast 			   cards. 			   Modifications to the contrast and chroma ioctls. 			   Textual cleanup.  1.5             3/15/97    fsmp@freefall.org                 	   new bt848 specific versions of hue/bright/                            contrast/satu/satv.                            Amancio's patch to fix "screen freeze" problem.  1.6             3/19/97    fsmp@freefall.org 			   new table-driven frequency lookup. 			   removed disable_intr()/enable_intr() calls from i2c. 			   misc. cleanup.  1.7             3/19/97    fsmp@freefall.org 			   added audio support submitted by: 				Michael Petry<petry@netwolf.NetMasters.com>  1.8             3/20/97    fsmp@freefall.org 			   extended audio support. 			   card auto-detection. 			   major cleanup, order of routines, declarations, etc.  1.9             3/22/97    fsmp@freefall.org 			   merged in Amancio's minor unit for tuner control 			   mods. 			   misc. cleanup, especially in the _intr routine. 			   made AUDIO_SUPPORT mainline code.  1.10            3/23/97    fsmp@freefall.org 			   added polled hardware i2c routines, 			   removed all existing software i2c routines. 			   created software i2cProbe() routine. 			   Randall Hopper's fixes of BT848_GHUE& BT848_GBRIG. 			   eeprom support.  1.11            3/24/97    fsmp@freefall.org 			   Louis Mamakos's new bt848 struct.  1.12		3/25/97    fsmp@freefall.org 			   japanese freq table from Naohiro Shichijo. 			   new table structs for tuner lookups. 			   major scrub for "magic numbers".  1.13		3/28/97    fsmp@freefall.org 			   1st PAL support. 			   MAGIC_[1-4] demarcates magic #s needing PAL work. 			   AFC code submitted by Richard Tobin<richard@cogsci.ed.ac.uk>.  1.14		3/29/97    richard@cogsci.ed.ac.uk 			   PAL support: magic numbers moved into 			   format_params structure. 			   Revised AFC interface. 			   fixed DMA_PROG_ALLOC size misdefinition.  1.15		4/18/97	   John-Mark Gurney<gurney_j@resnet.uoregon.edu>                            Added [SR]RGBMASKs ioctl for byte swapping.  1.16		4/20/97	   Randall Hopper<rhh@ct.picker.com>                            Generalized RGBMASK ioctls for general pixel 			   format setting [SG]ACTPIXFMT, and added query API 			   to return driver-supported pix fmts GSUPPIXFMT.  1.17		4/21/97	   hasty@rah.star-gate.com                            Clipping support added.  1.18		4/23/97	   Clean up after failed CAP_SINGLEs where bt                             interrupt isn't delivered, and fixed fixing  			   CAP_SINGLEs that for ODD_ONLY fields.  */
end_comment

begin_include
include|#
directive|include
file|"bktr.h"
end_include

begin_if
if|#
directive|if
name|NBKTR
operator|>
literal|0
end_if

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/protosw.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/signalvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/mman.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|DEVFS
end_ifdef

begin_include
include|#
directive|include
file|<sys/devfsext.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DEVFS */
end_comment

begin_include
include|#
directive|include
file|<machine/clock.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_kern.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_param.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_extern.h>
end_include

begin_include
include|#
directive|include
file|"pci.h"
end_include

begin_if
if|#
directive|if
name|NPCI
operator|>
literal|0
end_if

begin_include
include|#
directive|include
file|<pci/pcivar.h>
end_include

begin_include
include|#
directive|include
file|<pci/pcireg.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<machine/ioctl_meteor.h>
end_include

begin_include
include|#
directive|include
file|<machine/ioctl_bt848.h>
end_include

begin_comment
comment|/* extensions to ioctl_meteor.h */
end_comment

begin_include
include|#
directive|include
file|<pci/brktree_reg.h>
end_include

begin_typedef
typedef|typedef
name|u_char
name|bool_t
typedef|;
end_typedef

begin_define
define|#
directive|define
name|METPRI
value|(PZERO+8)|PCATCH
end_define

begin_decl_stmt
specifier|static
name|void
name|bktr_intr
name|__P
argument_list|(
operator|(
name|void
operator|*
name|arg
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  FIXME:  Dead code?  bt_enable_cnt is always 0; effectively   */
end_comment

begin_comment
comment|/*    a do-nothing when ORed in with SOL/EOL RISC instructions.  */
end_comment

begin_expr_stmt
specifier|static
name|bt_enable_cnt
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * memory allocated for DMA programs  */
end_comment

begin_define
define|#
directive|define
name|DMA_PROG_ALLOC
value|(8 * PAGE_SIZE)
end_define

begin_comment
comment|/* When to split a dma transfer , the bt848 has timing as well as    dma transfer size limitations so that we have to split dma    transfers into two dma requests     */
end_comment

begin_define
define|#
directive|define
name|DMA_BT848_SPLIT
value|319*2
end_define

begin_comment
comment|/*   * Allocate enough memory for:  *	768x576 RGB 16 or YUV (16 storage bits/pixel) = 884736 = 216 pages  *  * You may override this using the options "METEOR_ALLOC_PAGES=value" in your  * kernel configuration file.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|BROOKTREE_ALLOC_PAGES
end_ifndef

begin_define
define|#
directive|define
name|BROOKTREE_ALLOC_PAGES
value|217*4
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|BROOKTREE_ALLOC
value|(BROOKTREE_ALLOC_PAGES * PAGE_SIZE)
end_define

begin_decl_stmt
specifier|static
name|bktr_reg_t
name|brooktree
index|[
name|NBKTR
index|]
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|BROOKTRE_NUM
parameter_list|(
name|mtr
parameter_list|)
value|((bktr -&brooktree[0])/sizeof(bktr_reg_t))
end_define

begin_define
define|#
directive|define
name|BKTRPRI
value|(PZERO+8)|PCATCH
end_define

begin_function_decl
specifier|static
name|char
modifier|*
name|bktr_probe
parameter_list|(
name|pcici_t
name|tag
parameter_list|,
name|pcidi_t
name|type
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bktr_attach
parameter_list|(
name|pcici_t
name|tag
parameter_list|,
name|int
name|unit
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|u_long
name|bktr_count
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|pci_device
name|bktr_device
init|=
block|{
literal|"bktr"
block|,
name|bktr_probe
block|,
name|bktr_attach
block|,
operator|&
name|bktr_count
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DATA_SET
argument_list|(
name|pcidevice_set
argument_list|,
name|bktr_device
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|d_open_t
name|bktr_open
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_close_t
name|bktr_close
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_read_t
name|bktr_read
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_write_t
name|bktr_write
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_ioctl_t
name|bktr_ioctl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_mmap_t
name|bktr_mmap
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|CDEV_MAJOR
value|79
end_define

begin_decl_stmt
specifier|static
name|struct
name|cdevsw
name|bktr_cdevsw
init|=
block|{
name|bktr_open
block|,
name|bktr_close
block|,
name|bktr_read
block|,
name|bktr_write
block|,
name|bktr_ioctl
block|,
name|nostop
block|,
name|nullreset
block|,
name|nodevtotty
block|,
name|seltrue
block|,
name|bktr_mmap
block|,
name|NULL
block|,
literal|"bktr"
block|,
name|NULL
block|,
operator|-
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * This is for start-up convenience only, NOT mandatory.  */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|DEFAULT_CHNLSET
argument_list|)
end_if

begin_define
define|#
directive|define
name|DEFAULT_CHNLSET
value|CHNLSET_NABCST
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Parameters describing size of transmitted image.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|format_params
name|format_params
index|[]
init|=
block|{
define|#
directive|define
name|FORMAT_PARAMS_NTSC525
value|0
block|{
literal|525
block|,
literal|22
block|,
literal|480
block|,
literal|910
block|,
literal|135
block|,
literal|754
block|,
operator|(
literal|640.0
operator|/
literal|780.0
operator|)
block|}
block|,
define|#
directive|define
name|FORMAT_PARAMS_PAL625
value|1
block|{
literal|625
block|,
literal|32
block|,
literal|576
block|,
literal|1135
block|,
literal|186
block|,
literal|922
block|,
operator|(
literal|768.0
operator|/
literal|944.0
operator|)
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Table of supported Pixel Formats   */
end_comment

begin_struct
specifier|static
struct|struct
name|meteor_pixfmt_internal
block|{
name|struct
name|meteor_pixfmt
name|public
decl_stmt|;
name|u_int
name|color_fmt
decl_stmt|;
block|}
name|pixfmt_table
index|[]
init|=
block|{
block|{
block|{
literal|0
block|,
name|METEOR_PIXTYPE_RGB
block|,
literal|2
block|,
block|{
literal|0x7c00
block|,
literal|0x03e0
block|,
literal|0x001f
block|}
block|,
literal|0
block|,
literal|0
block|}
block|,
literal|0x33
block|}
block|,
block|{
block|{
literal|0
block|,
name|METEOR_PIXTYPE_RGB
block|,
literal|2
block|,
block|{
literal|0x7c00
block|,
literal|0x03e0
block|,
literal|0x001f
block|}
block|,
literal|1
block|,
literal|0
block|}
block|,
literal|0x33
block|}
block|,
block|{
block|{
literal|0
block|,
name|METEOR_PIXTYPE_RGB
block|,
literal|2
block|,
block|{
literal|0xf800
block|,
literal|0x07e0
block|,
literal|0x001f
block|}
block|,
literal|0
block|,
literal|0
block|}
block|,
literal|0x22
block|}
block|,
block|{
block|{
literal|0
block|,
name|METEOR_PIXTYPE_RGB
block|,
literal|2
block|,
block|{
literal|0xf800
block|,
literal|0x07e0
block|,
literal|0x001f
block|}
block|,
literal|1
block|,
literal|0
block|}
block|,
literal|0x22
block|}
block|,
block|{
block|{
literal|0
block|,
name|METEOR_PIXTYPE_RGB
block|,
literal|3
block|,
block|{
literal|0xff0000
block|,
literal|0x00ff00
block|,
literal|0x0000ff
block|}
block|,
literal|1
block|,
literal|0
block|}
block|,
literal|0x11
block|}
block|,
block|{
block|{
literal|0
block|,
name|METEOR_PIXTYPE_RGB
block|,
literal|4
block|,
block|{
literal|0xff0000
block|,
literal|0x00ff00
block|,
literal|0x0000ff
block|}
block|,
literal|0
block|,
literal|0
block|}
block|,
literal|0x00
block|}
block|,
block|{
block|{
literal|0
block|,
name|METEOR_PIXTYPE_RGB
block|,
literal|4
block|,
block|{
literal|0xff0000
block|,
literal|0x00ff00
block|,
literal|0x0000ff
block|}
block|,
literal|0
block|,
literal|1
block|}
block|,
literal|0x00
block|}
block|,
block|{
block|{
literal|0
block|,
name|METEOR_PIXTYPE_RGB
block|,
literal|4
block|,
block|{
literal|0xff0000
block|,
literal|0x00ff00
block|,
literal|0x0000ff
block|}
block|,
literal|1
block|,
literal|0
block|}
block|,
literal|0x00
block|}
block|,
block|{
block|{
literal|0
block|,
name|METEOR_PIXTYPE_RGB
block|,
literal|4
block|,
block|{
literal|0xff0000
block|,
literal|0x00ff00
block|,
literal|0x0000ff
block|}
block|,
literal|1
block|,
literal|1
block|}
block|,
literal|0x00
block|}
block|,  }
struct|;
end_struct

begin_define
define|#
directive|define
name|PIXFMT_TABLE_SIZE
value|( sizeof(pixfmt_table) / sizeof(pixfmt_table[0]) )
end_define

begin_comment
comment|/*  * Table of Meteor-supported Pixel Formats (for SETGEO compatibility)  */
end_comment

begin_comment
comment|/*  FIXME:  Also add YUV_422 and YUV_PACKED as well  */
end_comment

begin_struct
specifier|static
struct|struct
block|{
name|u_long
name|meteor_format
decl_stmt|;
name|struct
name|meteor_pixfmt
name|public
decl_stmt|;
block|}
name|meteor_pixfmt_table
index|[]
init|=
block|{
comment|/* FIXME: Should byte swap flag be on for this one; negative in drvr? */
block|{
name|METEOR_GEO_RGB16
block|,
block|{
literal|0
block|,
name|METEOR_PIXTYPE_RGB
block|,
literal|2
block|,
block|{
literal|0x7c00
block|,
literal|0x03e0
block|,
literal|0x001f
block|}
block|,
literal|0
block|,
literal|0
block|}
block|}
block|,
block|{
name|METEOR_GEO_RGB24
block|,
block|{
literal|0
block|,
name|METEOR_PIXTYPE_RGB
block|,
literal|4
block|,
block|{
literal|0xff0000
block|,
literal|0x00ff00
block|,
literal|0x0000ff
block|}
block|,
literal|0
block|,
literal|0
block|}
block|}
block|, }
struct|;
end_struct

begin_define
define|#
directive|define
name|METEOR_PIXFMT_TABLE_SIZE
value|( sizeof(meteor_pixfmt_table) / \ 				   sizeof(meteor_pixfmt_table[0]) )
end_define

begin_define
define|#
directive|define
name|BSWAP
value|(BT848_COLOR_CTL_BSWAP_ODD | BT848_COLOR_CTL_BSWAP_EVEN)
end_define

begin_define
define|#
directive|define
name|WSWAP
value|(BT848_COLOR_CTL_WSWAP_ODD | BT848_COLOR_CTL_WSWAP_EVEN)
end_define

begin_comment
comment|/* experimental code for Automatic Frequency Control */
end_comment

begin_define
define|#
directive|define
name|TUNER_AFC
end_define

begin_define
define|#
directive|define
name|TEST_TUNER_AFC_NOT
end_define

begin_if
if|#
directive|if
name|defined
argument_list|(
name|TUNER_AFC
argument_list|)
end_if

begin_define
define|#
directive|define
name|AFC_DELAY
value|10000
end_define

begin_comment
comment|/* 10 millisend delay */
end_comment

begin_define
define|#
directive|define
name|AFC_BITS
value|0x07
end_define

begin_define
define|#
directive|define
name|AFC_FREQ_MINUS_125
value|0x00
end_define

begin_define
define|#
directive|define
name|AFC_FREQ_MINUS_62
value|0x01
end_define

begin_define
define|#
directive|define
name|AFC_FREQ_CENTERED
value|0x02
end_define

begin_define
define|#
directive|define
name|AFC_FREQ_PLUS_62
value|0x03
end_define

begin_define
define|#
directive|define
name|AFC_FREQ_PLUS_125
value|0x04
end_define

begin_define
define|#
directive|define
name|AFC_MAX_STEP
value|(5 * FREQFACTOR)
end_define

begin_comment
comment|/* no more than 5 MHz */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* TUNER_AFC */
end_comment

begin_comment
comment|/*  * i2c things:  */
end_comment

begin_define
define|#
directive|define
name|TEST_PAL
end_define

begin_comment
comment|/* PLL on a Temic NTSC tuner: 4032FY5 */
end_comment

begin_define
define|#
directive|define
name|TEMIC_NTSC_WADDR
value|0xc0
end_define

begin_define
define|#
directive|define
name|TEMIC_NTSC_RADDR
value|0xc1
end_define

begin_comment
comment|/* PLL on a Temic PAL I tuner: 4062FY5 */
end_comment

begin_define
define|#
directive|define
name|TEMIC_PALI_WADDR
value|0xc2
end_define

begin_define
define|#
directive|define
name|TEMIC_PALI_RADDR
value|0xc3
end_define

begin_comment
comment|/* PLL on a Philips tuner */
end_comment

begin_define
define|#
directive|define
name|PHILIPS_NTSC_WADDR
value|0xc6
end_define

begin_define
define|#
directive|define
name|PHILIPS_NTSC_RADDR
value|0xc7
end_define

begin_comment
comment|/* guaranteed address for any TSA5522/3 (PLL on all(?) tuners) */
end_comment

begin_define
define|#
directive|define
name|TSA552x_WADDR
value|0xc2
end_define

begin_define
define|#
directive|define
name|TSA552x_RADDR
value|0xc3
end_define

begin_define
define|#
directive|define
name|TSA552x_CB_MSB
value|(0x80)
end_define

begin_define
define|#
directive|define
name|TSA552x_CB_CP
value|(1<<6)
end_define

begin_define
define|#
directive|define
name|TSA552x_CB_T2
value|(1<<5)
end_define

begin_define
define|#
directive|define
name|TSA552x_CB_T1
value|(1<<4)
end_define

begin_define
define|#
directive|define
name|TSA552x_CB_T0
value|(1<<3)
end_define

begin_define
define|#
directive|define
name|TSA552x_CB_RSA
value|(1<<2)
end_define

begin_define
define|#
directive|define
name|TSA552x_CB_RSB
value|(1<<1)
end_define

begin_define
define|#
directive|define
name|TSA552x_CB_OS
value|(1<<0)
end_define

begin_comment
comment|/* address of BTSC/SAP decoder chip */
end_comment

begin_define
define|#
directive|define
name|TDA9850_WADDR
value|0xb6
end_define

begin_define
define|#
directive|define
name|TDA9850_RADDR
value|0xb7
end_define

begin_comment
comment|/* EEProm (128 * 8) on an STB card */
end_comment

begin_define
define|#
directive|define
name|X24C01_WADDR
value|0xae
end_define

begin_define
define|#
directive|define
name|X24C01_RADDR
value|0xaf
end_define

begin_comment
comment|/* EEProm (256 * 8) on a Hauppauge card */
end_comment

begin_define
define|#
directive|define
name|PFC8582_WADDR
value|0xa0
end_define

begin_define
define|#
directive|define
name|PFC8582_RADDR
value|0xa1
end_define

begin_comment
comment|/* registers in the BTSC/dbx chip */
end_comment

begin_define
define|#
directive|define
name|CON1ADDR
value|0x04
end_define

begin_define
define|#
directive|define
name|CON2ADDR
value|0x05
end_define

begin_define
define|#
directive|define
name|CON3ADDR
value|0x06
end_define

begin_define
define|#
directive|define
name|CON4ADDR
value|0x07
end_define

begin_comment
comment|/* raise the charge pump voltage for fast tuning */
end_comment

begin_define
define|#
directive|define
name|TSA552x_FCONTROL
value|(TSA552x_CB_MSB |	\ 				 TSA552x_CB_CP  |	\ 				 TSA552x_CB_T0  |	\ 				 TSA552x_CB_RSA |	\ 				 TSA552x_CB_RSB)
end_define

begin_comment
comment|/* lower the charge pump voltage for better residual oscillator FM */
end_comment

begin_define
define|#
directive|define
name|TSA552x_SCONTROL
value|(TSA552x_CB_MSB |	\ 				 TSA552x_CB_T0  |	\ 				 TSA552x_CB_RSA |	\ 				 TSA552x_CB_RSB)
end_define

begin_comment
comment|/* sync detect threshold */
end_comment

begin_if
if|#
directive|if
literal|1
end_if

begin_define
define|#
directive|define
name|SYNC_LEVEL
value|(BT848_ADC_RESERVED |	\ 				 BT848_ADC_CRUSH)
end_define

begin_comment
comment|/* threshold ~125 mV */
end_comment

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|SYNC_LEVEL
value|(BT848_ADC_RESERVED |	\ 				 BT848_ADC_CRUSH    |	\ 				 BT848_ADC_SYNC_T)
end_define

begin_comment
comment|/* threshold ~75 mV */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* the GPIO bits that control the audio MUXes */
end_comment

begin_define
define|#
directive|define
name|GPIO_AUDIOMUX_BITS
value|0x07
end_define

begin_comment
comment|/* debug utility for holding previous INT_STAT contents */
end_comment

begin_define
define|#
directive|define
name|STATUS_SUM
end_define

begin_decl_stmt
specifier|static
name|u_long
name|status_sum
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * defines to make certain bit-fiddles understandable  */
end_comment

begin_define
define|#
directive|define
name|FIFO_ENABLED
value|BT848_DMA_CTL_FIFO_EN
end_define

begin_define
define|#
directive|define
name|RISC_ENABLED
value|BT848_DMA_CTL_RISC_EN
end_define

begin_define
define|#
directive|define
name|FIFO_RISC_ENABLED
value|(BT848_DMA_CTL_FIFO_EN | BT848_DMA_CTL_RISC_EN)
end_define

begin_define
define|#
directive|define
name|FIFO_RISC_DISABLED
value|0
end_define

begin_define
define|#
directive|define
name|ALL_INTS_DISABLED
value|0
end_define

begin_define
define|#
directive|define
name|ALL_INTS_CLEARED
value|0xffffffff
end_define

begin_define
define|#
directive|define
name|CAPTURE_OFF
value|0
end_define

begin_define
define|#
directive|define
name|BIT_SEVEN_HIGH
value|(1<<7)
end_define

begin_define
define|#
directive|define
name|BIT_EIGHT_HIGH
value|(1<<8)
end_define

begin_define
define|#
directive|define
name|I2C_BITS
value|(BT848_INT_RACK | BT848_INT_I2CDONE)
end_define

begin_comment
comment|/*  * misc. support routines.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|CARDTYPE
name|cards
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|TUNER
name|tuners
index|[]
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|signCard
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|count
parameter_list|,
name|u_char
modifier|*
name|sig
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|probeCard
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|,
name|int
name|verbose
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|vm_offset_t
name|get_bktr_mem
parameter_list|(
name|int
name|unit
parameter_list|,
name|unsigned
name|size
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|oformat_meteor_to_bt
parameter_list|(
name|u_long
name|format
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u_int
name|pixfmt_swap_flags
parameter_list|(
name|int
name|pixfmt
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * bt848 RISC programming routines.  */
end_comment

begin_function_decl
specifier|static
name|int
name|dump_bt848
parameter_list|(
name|bt848_ptr_t
name|bt848
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|yuvpack_prog
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|,
name|char
name|i_flag
parameter_list|,
name|int
name|cols
parameter_list|,
name|int
name|rows
parameter_list|,
name|int
name|interlace
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|yuv422_prog
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|,
name|char
name|i_flag
parameter_list|,
name|int
name|cols
parameter_list|,
name|int
name|rows
parameter_list|,
name|int
name|interlace
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rgb_prog
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|,
name|char
name|i_flag
parameter_list|,
name|int
name|cols
parameter_list|,
name|int
name|rows
parameter_list|,
name|int
name|interlace
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|build_dma_prog
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|,
name|char
name|i_flag
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool_t
name|getline
parameter_list|(
name|bktr_reg_t
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool_t
name|notclipped
parameter_list|(
name|bktr_reg_t
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool_t
name|split
parameter_list|(
name|bktr_reg_t
modifier|*
parameter_list|,
specifier|volatile
name|u_long
modifier|*
modifier|*
parameter_list|,
name|int
parameter_list|,
name|u_long
parameter_list|,
name|int
parameter_list|,
specifier|volatile
name|u_char
modifier|*
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * video& video capture specific routines.  */
end_comment

begin_function_decl
specifier|static
name|int
name|video_open
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|video_close
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|video_ioctl
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|,
name|int
name|unit
parameter_list|,
name|int
name|cmd
parameter_list|,
name|caddr_t
name|arg
parameter_list|,
name|struct
name|proc
modifier|*
name|pr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|start_capture
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|,
name|unsigned
name|type
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|set_fps
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|,
name|u_short
name|fps
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * tuner specific functions.  */
end_comment

begin_function_decl
specifier|static
name|int
name|tuner_open
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|tuner_close
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|tuner_ioctl
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|,
name|int
name|unit
parameter_list|,
name|int
name|cmd
parameter_list|,
name|caddr_t
name|arg
parameter_list|,
name|struct
name|proc
modifier|*
name|pr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|tv_channel
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|,
name|int
name|channel
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|tv_freq
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|,
name|int
name|frequency
parameter_list|)
function_decl|;
end_function_decl

begin_if
if|#
directive|if
name|defined
argument_list|(
name|TUNER_AFC
argument_list|)
end_if

begin_function_decl
specifier|static
name|int
name|do_afc
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|,
name|int
name|addr
parameter_list|,
name|int
name|frequency
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* TUNER_AFC */
end_comment

begin_comment
comment|/*  * audio specific functions.  */
end_comment

begin_function_decl
specifier|static
name|int
name|set_audio
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|,
name|int
name|mode
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|temp_mute
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|,
name|int
name|flag
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|set_BTSC
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|,
name|int
name|control
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * ioctls common to both video& tuner.  */
end_comment

begin_function_decl
specifier|static
name|int
name|common_ioctl
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|,
name|bt848_ptr_t
name|bt848
parameter_list|,
name|int
name|cmd
parameter_list|,
name|caddr_t
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * i2c primitives  */
end_comment

begin_function_decl
specifier|static
name|int
name|i2cWrite
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|,
name|int
name|addr
parameter_list|,
name|int
name|byte1
parameter_list|,
name|int
name|byte2
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|i2cRead
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|,
name|int
name|addr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|writeEEProm
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|count
parameter_list|,
name|u_char
modifier|*
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|readEEProm
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|count
parameter_list|,
name|u_char
modifier|*
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * the boot time probe routine.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|bktr_probe
parameter_list|(
name|pcici_t
name|tag
parameter_list|,
name|pcidi_t
name|type
parameter_list|)
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|BROOKTREE_848_ID
case|:
return|return
operator|(
literal|"BrookTree 848"
operator|)
return|;
block|}
empty_stmt|;
return|return
operator|(
operator|(
name|char
operator|*
operator|)
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * what should we do here?  */
end_comment

begin_function
specifier|static
name|void
name|bktr_init
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|)
block|{
return|return;
block|}
end_function

begin_comment
comment|/*  * the attach routine.  */
end_comment

begin_function
specifier|static
name|void
name|bktr_attach
parameter_list|(
name|pcici_t
name|tag
parameter_list|,
name|int
name|unit
parameter_list|)
block|{
name|bktr_ptr_t
name|bktr
decl_stmt|;
name|bt848_ptr_t
name|bt848
decl_stmt|;
ifdef|#
directive|ifdef
name|BROOKTREE_IRQ
name|u_long
name|old_irq
decl_stmt|,
name|new_irq
decl_stmt|;
endif|#
directive|endif
name|u_char
modifier|*
name|test
decl_stmt|;
name|vm_offset_t
name|buf
decl_stmt|;
name|u_long
name|latency
decl_stmt|;
name|u_long
name|fun
decl_stmt|;
name|bt_enable_cnt
operator|=
literal|0
expr_stmt|;
name|bktr
operator|=
operator|&
name|brooktree
index|[
name|unit
index|]
expr_stmt|;
if|if
condition|(
name|unit
operator|>=
name|NBKTR
condition|)
block|{
name|printf
argument_list|(
literal|"brooktree%d: attach: only %d units configured.\n"
argument_list|,
name|unit
argument_list|,
name|NBKTR
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"brooktree%d: attach: invalid unit number.\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return;
block|}
name|bktr
operator|->
name|tag
operator|=
name|tag
expr_stmt|;
name|pci_map_mem
argument_list|(
name|tag
argument_list|,
name|PCI_MAP_REG_START
argument_list|,
operator|(
name|vm_offset_t
operator|*
operator|)
operator|&
name|bktr
operator|->
name|base
argument_list|,
operator|&
name|bktr
operator|->
name|phys_base
argument_list|)
expr_stmt|;
name|fun
operator|=
name|pci_conf_read
argument_list|(
name|tag
argument_list|,
name|PCI_COMMAND_STATUS_REG
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|BROOKTREE_IRQ
comment|/* from the configuration file */
name|old_irq
operator|=
name|pci_conf_read
argument_list|(
name|tag
argument_list|,
name|PCI_INTERRUPT_REG
argument_list|)
expr_stmt|;
name|pci_conf_write
argument_list|(
name|tag
argument_list|,
name|PCI_INTERRUPT_REG
argument_list|,
name|BROOKTREE_IRQ
argument_list|)
expr_stmt|;
name|new_irq
operator|=
name|pci_conf_read
argument_list|(
name|tag
argument_list|,
name|PCI_INTERRUPT_REG
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"bktr%d: attach: irq changed from %d to %d\n"
argument_list|,
name|unit
argument_list|,
operator|(
name|old_irq
operator|&
literal|0xff
operator|)
argument_list|,
operator|(
name|new_irq
operator|&
literal|0xff
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* setup the interrupt handling routine */
name|pci_map_int
argument_list|(
name|tag
argument_list|,
name|bktr_intr
argument_list|,
operator|(
name|void
operator|*
operator|)
name|bktr
argument_list|,
operator|&
name|net_imask
argument_list|)
expr_stmt|;
comment|/*  * PCI latency timer.  32 is a good value for 4 bus mastering slots, if  * you have more than four, then 16 would probably be a better value.  */
ifndef|#
directive|ifndef
name|BROOKTREE_DEF_LATENCY_VALUE
define|#
directive|define
name|BROOKTREE_DEF_LATENCY_VALUE
value|10
endif|#
directive|endif
name|latency
operator|=
name|pci_conf_read
argument_list|(
name|tag
argument_list|,
name|PCI_LATENCY_TIMER
argument_list|)
expr_stmt|;
name|latency
operator|=
operator|(
name|latency
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
block|{
if|if
condition|(
name|latency
condition|)
name|printf
argument_list|(
literal|"brooktree%d: PCI bus latency is"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"brooktree%d: PCI bus latency was 0 changing to"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|latency
condition|)
block|{
name|latency
operator|=
name|BROOKTREE_DEF_LATENCY_VALUE
expr_stmt|;
name|pci_conf_write
argument_list|(
name|tag
argument_list|,
name|PCI_LATENCY_TIMER
argument_list|,
name|latency
operator|<<
literal|8
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bootverbose
condition|)
block|{
name|printf
argument_list|(
literal|" %d.\n"
argument_list|,
name|latency
argument_list|)
expr_stmt|;
block|}
comment|/*	bktr_init(bktr);	 set up the bt848 */
comment|/* allocate space for dma program */
name|bktr
operator|->
name|dma_prog
operator|=
name|get_bktr_mem
argument_list|(
name|unit
argument_list|,
name|DMA_PROG_ALLOC
argument_list|)
expr_stmt|;
name|bktr
operator|->
name|odd_dma_prog
operator|=
name|get_bktr_mem
argument_list|(
name|unit
argument_list|,
name|DMA_PROG_ALLOC
argument_list|)
expr_stmt|;
comment|/* allocate space for pixel buffer */
if|if
condition|(
name|BROOKTREE_ALLOC
condition|)
name|buf
operator|=
name|get_bktr_mem
argument_list|(
name|unit
argument_list|,
name|BROOKTREE_ALLOC
argument_list|)
expr_stmt|;
else|else
name|buf
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
block|{
name|printf
argument_list|(
literal|"bktr%d: buffer size %d, addr 0x%x\n"
argument_list|,
name|unit
argument_list|,
name|BROOKTREE_ALLOC
argument_list|,
name|vtophys
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|bktr
operator|->
name|bigbuf
operator|=
name|buf
expr_stmt|;
name|bktr
operator|->
name|alloc_pages
operator|=
name|BROOKTREE_ALLOC_PAGES
expr_stmt|;
if|if
condition|(
name|buf
operator|!=
literal|0
condition|)
block|{
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
name|buf
argument_list|,
name|BROOKTREE_ALLOC
argument_list|)
expr_stmt|;
name|buf
operator|=
name|vtophys
argument_list|(
name|buf
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|amancio
comment|/* 640x480 RGB 16 */
name|amancio
label|:
name|setup
name|dma
name|risc
name|program
name|bktr
operator|->
name|base
operator|->
name|dma1e
init|=
name|buf
decl_stmt|;
name|bktr
operator|->
name|base
operator|->
name|dma1o
operator|=
name|buf
operator|+
literal|0x500
expr_stmt|;
name|bktr
operator|->
name|base
operator|->
name|dma_end_e
operator|=
name|bktr
operator|->
name|base
operator|->
name|dma_end_o
operator|=
name|buf
operator|+
name|METEOR_ALLOC
expr_stmt|;
name|end
name|of
name|setup
name|up
name|dma
name|risc
name|program
comment|/* 1 frame of 640x480 RGB 16 */
name|bktr
operator|->
name|flags
operator||=
name|METEOR_INITALIZED
operator||
name|METEOR_AUTOMODE
operator||
name|METEOR_DEV0
operator||
name|METEOR_RGB16
expr_stmt|;
endif|#
directive|endif
comment|/* amancio */
name|bktr
operator|->
name|flags
operator|=
name|METEOR_INITALIZED
operator||
name|METEOR_AUTOMODE
operator||
name|METEOR_DEV0
operator||
name|METEOR_RGB16
expr_stmt|;
name|bktr
operator|->
name|dma_prog_loaded
operator|=
name|FALSE
expr_stmt|;
name|bktr
operator|->
name|cols
operator|=
literal|640
expr_stmt|;
name|bktr
operator|->
name|rows
operator|=
literal|480
expr_stmt|;
name|bktr
operator|->
name|frames
operator|=
literal|1
expr_stmt|;
comment|/* one frame */
name|bktr
operator|->
name|format
operator|=
name|METEOR_GEO_RGB16
expr_stmt|;
name|bktr
operator|->
name|pixfmt
operator|=
name|oformat_meteor_to_bt
argument_list|(
name|bktr
operator|->
name|format
argument_list|)
expr_stmt|;
name|bktr
operator|->
name|pixfmt_compat
operator|=
name|TRUE
expr_stmt|;
name|bt848
operator|=
name|bktr
operator|->
name|base
expr_stmt|;
name|bt848
operator|->
name|int_mask
operator|=
name|ALL_INTS_DISABLED
expr_stmt|;
name|bt848
operator|->
name|gpio_dma_ctl
operator|=
name|FIFO_RISC_DISABLED
expr_stmt|;
block|}
comment|/* defaults for the tuner section of the card */
name|bktr
operator|->
name|tflags
operator|=
name|TUNER_INITALIZED
expr_stmt|;
name|bktr
operator|->
name|tuner
operator|.
name|frequency
operator|=
literal|0
expr_stmt|;
name|bktr
operator|->
name|tuner
operator|.
name|channel
operator|=
literal|0
expr_stmt|;
name|bktr
operator|->
name|tuner
operator|.
name|chnlset
operator|=
name|DEFAULT_CHNLSET
expr_stmt|;
name|bktr
operator|->
name|audio_mux_select
operator|=
literal|0
expr_stmt|;
name|bktr
operator|->
name|audio_mute_state
operator|=
name|FALSE
expr_stmt|;
name|probeCard
argument_list|(
name|bktr
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEVFS
name|bktr
operator|->
name|devfs_token
operator|=
name|devfs_add_devswf
argument_list|(
operator|&
name|bktr_cdevsw
argument_list|,
name|unit
argument_list|,
name|DV_CHR
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0644
argument_list|,
literal|"brooktree"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEVFS */
block|}
end_function

begin_comment
comment|/*  * interrupt handling routine complete bktr_read() if using interrupts.  */
end_comment

begin_function
specifier|static
name|void
name|bktr_intr
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|bktr_ptr_t
name|bktr
decl_stmt|;
name|bt848_ptr_t
name|bt848
decl_stmt|;
name|u_long
name|bktr_status
decl_stmt|;
name|u_char
name|dstatus
decl_stmt|;
name|bktr
operator|=
operator|(
name|bktr_ptr_t
operator|)
name|arg
expr_stmt|;
name|bt848
operator|=
name|bktr
operator|->
name|base
expr_stmt|;
comment|/* 	 * check to see if any interrupts are unmasked on this device.  If 	 * none are, then we likely got here by way of being on a PCI shared 	 * interrupt dispatch list. 	 */
if|if
condition|(
name|bt848
operator|->
name|int_mask
operator|==
name|ALL_INTS_DISABLED
condition|)
return|return;
comment|/* bail out now, before we do something we 				   shouldn't */
if|if
condition|(
operator|!
operator|(
name|bktr
operator|->
name|flags
operator|&
name|METEOR_OPEN
operator|)
condition|)
block|{
name|bt848
operator|->
name|gpio_dma_ctl
operator|=
name|FIFO_RISC_DISABLED
expr_stmt|;
name|bt848
operator|->
name|int_mask
operator|=
name|ALL_INTS_DISABLED
expr_stmt|;
comment|/* return; ?? */
block|}
comment|/* record and clear the INTerrupt status bits */
name|bktr_status
operator|=
name|bt848
operator|->
name|int_stat
expr_stmt|;
name|bt848
operator|->
name|int_stat
operator|=
name|bktr_status
operator|&
operator|~
name|I2C_BITS
expr_stmt|;
comment|/* don't touch i2c */
comment|/* record and clear the device status register */
name|dstatus
operator|=
name|bt848
operator|->
name|dstatus
expr_stmt|;
name|bt848
operator|->
name|dstatus
operator|=
literal|0x00
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|STATUS_SUM
argument_list|)
comment|/* add any new device status or INTerrupt status bits */
name|status_sum
operator||=
operator|(
name|bktr_status
operator|&
operator|~
operator|(
name|BT848_INT_RSV0
operator||
name|BT848_INT_RSV1
operator|)
operator|)
expr_stmt|;
name|status_sum
operator||=
operator|(
operator|(
name|dstatus
operator|&
operator|(
name|BT848_DSTATUS_COF
operator||
name|BT848_DSTATUS_LOF
operator|)
operator|)
operator|<<
literal|6
operator|)
expr_stmt|;
endif|#
directive|endif
comment|/* STATUS_SUM */
comment|/* 	printf( " STATUS %x %x %x \n", 		dstatus, bktr_status, bt848->risc_count ); 	*/
comment|/* if risc was disabled re-start process again */
if|if
condition|(
operator|!
operator|(
name|bktr_status
operator|&
name|BT848_INT_RISC_EN
operator|)
operator|||
operator|(
operator|(
name|bktr_status
operator|&
operator|(
name|BT848_INT_FBUS
operator||
name|BT848_INT_FTRGT
operator||
name|BT848_INT_FDSR
operator||
name|BT848_INT_PPERR
operator||
name|BT848_INT_RIPERR
operator||
name|BT848_INT_PABORT
operator||
name|BT848_INT_OCERR
operator||
name|BT848_INT_SCERR
operator|)
operator|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|bt848
operator|->
name|gpio_dma_ctl
operator|=
name|FIFO_RISC_DISABLED
expr_stmt|;
name|bt848
operator|->
name|int_mask
operator|=
name|ALL_INTS_DISABLED
expr_stmt|;
name|bt848
operator|->
name|risc_strt_add
operator|=
name|vtophys
argument_list|(
name|bktr
operator|->
name|dma_prog
argument_list|)
expr_stmt|;
name|bt848
operator|->
name|gpio_dma_ctl
operator|=
name|FIFO_ENABLED
expr_stmt|;
name|bt848
operator|->
name|gpio_dma_ctl
operator|=
name|bktr
operator|->
name|capcontrol
expr_stmt|;
name|bt848
operator|->
name|int_mask
operator|=
name|BT848_INT_MYSTERYBIT
operator||
name|BT848_INT_RISCI
operator||
name|BT848_INT_VSYNC
operator||
name|BT848_INT_FMTCHG
expr_stmt|;
name|bt848
operator|->
name|cap_ctl
operator|=
name|bktr
operator|->
name|bktr_cap_ctl
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
operator|(
name|bktr_status
operator|&
name|BT848_INT_RISCI
operator|)
condition|)
return|return;
comment|/** 	printf( "intr status %x %x %x\n", 		bktr_status, dstatus, bt848->risc_count );  */
comment|/* 	 * Disable future interrupts if a capture mode is not selected. 	 * This can happen when we are in the process of closing or  	 * changing capture modes, otherwise it shouldn't happen. 	 */
if|if
condition|(
operator|!
operator|(
name|bktr
operator|->
name|flags
operator|&
name|METEOR_CAP_MASK
operator|)
condition|)
name|bt848
operator|->
name|cap_ctl
operator|=
name|CAPTURE_OFF
expr_stmt|;
comment|/* 	 *  Register the completed field 	 */
if|if
condition|(
name|bktr_status
operator|&
name|BT848_INT_FIELD
condition|)
name|bktr
operator|->
name|flags
operator|&=
operator|~
name|METEOR_WANT_EVEN
expr_stmt|;
else|else
name|bktr
operator|->
name|flags
operator|&=
operator|~
name|METEOR_WANT_ODD
expr_stmt|;
comment|/* 	 * If we have a complete frame. 	 */
if|if
condition|(
operator|!
operator|(
name|bktr
operator|->
name|flags
operator|&
name|METEOR_WANT_MASK
operator|)
condition|)
block|{
name|bktr
operator|->
name|frames_captured
operator|++
expr_stmt|;
comment|/* 		 * post the completion time.  		 */
if|if
condition|(
name|bktr
operator|->
name|flags
operator|&
name|METEOR_WANT_TS
condition|)
block|{
name|struct
name|timeval
modifier|*
name|ts
decl_stmt|;
if|if
condition|(
operator|(
name|u_int
operator|)
name|bktr
operator|->
name|alloc_pages
operator|*
name|PAGE_SIZE
operator|<=
operator|(
name|bktr
operator|->
name|frame_size
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|timeval
argument_list|)
operator|)
condition|)
block|{
name|ts
operator|=
operator|(
expr|struct
name|timeval
operator|*
operator|)
name|bktr
operator|->
name|bigbuf
operator|+
name|bktr
operator|->
name|frame_size
expr_stmt|;
comment|/* doesn't work in synch mode except 				 *  for first frame */
comment|/* XXX */
name|microtime
argument_list|(
name|ts
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 		 * Wake up the user in single capture mode. 		 */
if|if
condition|(
name|bktr
operator|->
name|flags
operator|&
name|METEOR_SINGLE
condition|)
block|{
comment|/* stop dma */
name|bt848
operator|->
name|int_mask
operator|=
name|ALL_INTS_DISABLED
expr_stmt|;
comment|/* disable risc, leave fifo running */
name|bt848
operator|->
name|gpio_dma_ctl
operator|=
name|FIFO_ENABLED
expr_stmt|;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
name|bktr
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * If the user requested to be notified via signal, 		 * let them know the frame is complete. 		 */
if|if
condition|(
name|bktr
operator|->
name|proc
operator|&&
operator|!
operator|(
name|bktr
operator|->
name|signal
operator|&
name|METEOR_SIG_MODE_MASK
operator|)
condition|)
name|psignal
argument_list|(
name|bktr
operator|->
name|proc
argument_list|,
name|bktr
operator|->
name|signal
operator|&
operator|(
operator|~
name|METEOR_SIG_MODE_MASK
operator|)
argument_list|)
expr_stmt|;
comment|/* 		 * Reset the want flags if in continuous or 		 * synchronous capture mode. 		 */
if|if
condition|(
name|bktr
operator|->
name|flags
operator|&
operator|(
name|METEOR_CONTIN
operator||
name|METEOR_SYNCAP
operator|)
condition|)
block|{
switch|switch
condition|(
name|bktr
operator|->
name|flags
operator|&
name|METEOR_ONLY_FIELDS_MASK
condition|)
block|{
case|case
name|METEOR_ONLY_ODD_FIELDS
case|:
name|bktr
operator|->
name|flags
operator||=
name|METEOR_WANT_ODD
expr_stmt|;
break|break;
case|case
name|METEOR_ONLY_EVEN_FIELDS
case|:
name|bktr
operator|->
name|flags
operator||=
name|METEOR_WANT_EVEN
expr_stmt|;
break|break;
default|default:
name|bktr
operator|->
name|flags
operator||=
name|METEOR_WANT_MASK
expr_stmt|;
break|break;
block|}
block|}
block|}
return|return;
block|}
end_function

begin_comment
comment|/*--------------------------------------------------------- ** **	BrookTree 848 character device driver routines ** **--------------------------------------------------------- */
end_comment

begin_define
define|#
directive|define
name|UNIT
parameter_list|(
name|x
parameter_list|)
value|((x)& 0x0f)
end_define

begin_define
define|#
directive|define
name|MINOR
parameter_list|(
name|x
parameter_list|)
value|((x>> 4)& 0x0f)
end_define

begin_define
define|#
directive|define
name|VIDEO_DEV
value|0x00
end_define

begin_define
define|#
directive|define
name|TUNER_DEV
value|0x01
end_define

begin_comment
comment|/*  *   */
end_comment

begin_function
name|int
name|bktr_open
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|fmt
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|bktr_ptr_t
name|bktr
decl_stmt|;
name|int
name|unit
decl_stmt|;
name|unit
operator|=
name|UNIT
argument_list|(
name|minor
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|unit
operator|>=
name|NBKTR
condition|)
comment|/* unit out of range */
return|return
operator|(
name|ENXIO
operator|)
return|;
name|bktr
operator|=
operator|&
operator|(
name|brooktree
index|[
name|unit
index|]
operator|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|bktr
operator|->
name|flags
operator|&
name|METEOR_INITALIZED
operator|)
condition|)
comment|/* device not found */
return|return
operator|(
name|ENXIO
operator|)
return|;
switch|switch
condition|(
name|MINOR
argument_list|(
name|minor
argument_list|(
name|dev
argument_list|)
argument_list|)
condition|)
block|{
case|case
name|VIDEO_DEV
case|:
return|return
operator|(
name|video_open
argument_list|(
name|bktr
argument_list|)
operator|)
return|;
case|case
name|TUNER_DEV
case|:
return|return
operator|(
name|tuner_open
argument_list|(
name|bktr
argument_list|)
operator|)
return|;
block|}
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *   */
end_comment

begin_function
specifier|static
name|int
name|video_open
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|)
block|{
name|bt848_ptr_t
name|bt848
decl_stmt|;
if|if
condition|(
name|bktr
operator|->
name|flags
operator|&
name|METEOR_OPEN
condition|)
comment|/* device is busy */
return|return
operator|(
name|EBUSY
operator|)
return|;
name|bktr
operator|->
name|flags
operator||=
name|METEOR_OPEN
expr_stmt|;
name|bt848
operator|=
name|bktr
operator|->
name|base
expr_stmt|;
comment|/** 	dump_bt848( bt848 );  */
name|bt848
operator|->
name|dstatus
operator|=
literal|0x00
expr_stmt|;
comment|/* clear device status reg. */
name|bt848
operator|->
name|adc
operator|=
name|SYNC_LEVEL
expr_stmt|;
name|bt848
operator|->
name|iform
operator|=
name|BT848_IFORM_M_MUX1
operator||
name|BT848_IFORM_X_XT0
operator||
name|BT848_IFORM_F_NTSCM
expr_stmt|;
name|bktr
operator|->
name|flags
operator|=
operator|(
name|bktr
operator|->
name|flags
operator|&
operator|~
name|METEOR_DEV_MASK
operator|)
operator||
name|METEOR_DEV0
expr_stmt|;
name|bktr
operator|->
name|format_params
operator|=
name|FORMAT_PARAMS_NTSC525
expr_stmt|;
name|bktr
operator|->
name|max_clip_node
operator|=
literal|0
expr_stmt|;
name|bt848
operator|->
name|color_ctl_gamma
operator|=
literal|0
expr_stmt|;
name|bt848
operator|->
name|color_ctl_rgb_ded
operator|=
literal|1
expr_stmt|;
name|bt848
operator|->
name|color_ctl_color_bars
operator|=
literal|0
expr_stmt|;
name|bt848
operator|->
name|color_ctl_ext_frmrate
operator|=
literal|0
expr_stmt|;
name|bt848
operator|->
name|color_ctl_swap
operator|=
literal|0
expr_stmt|;
name|bt848
operator|->
name|e_hscale_lo
operator|=
literal|170
expr_stmt|;
name|bt848
operator|->
name|o_hscale_lo
operator|=
literal|170
expr_stmt|;
name|bt848
operator|->
name|e_delay_lo
operator|=
literal|0x72
expr_stmt|;
name|bt848
operator|->
name|o_delay_lo
operator|=
literal|0x72
expr_stmt|;
name|bt848
operator|->
name|e_scloop
operator|=
literal|0
expr_stmt|;
name|bt848
operator|->
name|o_scloop
operator|=
literal|0
expr_stmt|;
name|bt848
operator|->
name|vbi_pack_size
operator|=
literal|0
expr_stmt|;
name|bt848
operator|->
name|vbi_pack_del
operator|=
literal|0
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|u_char
operator|*
operator|)
name|bktr
operator|->
name|bigbuf
argument_list|,
literal|640
operator|*
literal|480
operator|*
literal|4
argument_list|)
expr_stmt|;
name|bktr
operator|->
name|fifo_errors
operator|=
literal|0
expr_stmt|;
name|bktr
operator|->
name|dma_errors
operator|=
literal|0
expr_stmt|;
name|bktr
operator|->
name|frames_captured
operator|=
literal|0
expr_stmt|;
name|bktr
operator|->
name|even_fields_captured
operator|=
literal|0
expr_stmt|;
name|bktr
operator|->
name|odd_fields_captured
operator|=
literal|0
expr_stmt|;
name|bktr
operator|->
name|proc
operator|=
operator|(
expr|struct
name|proc
operator|*
operator|)
literal|0
expr_stmt|;
name|set_fps
argument_list|(
name|bktr
argument_list|,
literal|30
argument_list|)
expr_stmt|;
name|bktr
operator|->
name|video
operator|.
name|addr
operator|=
literal|0
expr_stmt|;
name|bktr
operator|->
name|video
operator|.
name|width
operator|=
literal|0
expr_stmt|;
name|bktr
operator|->
name|video
operator|.
name|banksize
operator|=
literal|0
expr_stmt|;
name|bktr
operator|->
name|video
operator|.
name|ramsize
operator|=
literal|0
expr_stmt|;
name|bt848
operator|->
name|int_mask
operator|=
name|BT848_INT_MYSTERYBIT
expr_stmt|;
comment|/* what does this bit do ??? */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *   */
end_comment

begin_function
specifier|static
name|int
name|tuner_open
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|bktr
operator|->
name|tflags
operator|&
name|TUNER_INITALIZED
operator|)
condition|)
comment|/* device not found */
return|return
operator|(
name|ENXIO
operator|)
return|;
if|if
condition|(
name|bktr
operator|->
name|tflags
operator|&
name|TUNER_OPEN
condition|)
comment|/* already open */
return|return
operator|(
literal|0
operator|)
return|;
name|bktr
operator|->
name|tflags
operator||=
name|TUNER_OPEN
expr_stmt|;
comment|/* enable drivers on the GPIO port that control the MUXes */
name|bktr
operator|->
name|base
operator|->
name|gpio_out_en
operator|=
name|GPIO_AUDIOMUX_BITS
expr_stmt|;
comment|/* unmure the audio stream */
name|set_audio
argument_list|(
name|bktr
argument_list|,
name|AUDIO_UNMUTE
argument_list|)
expr_stmt|;
comment|/* enable stereo if appropriate */
if|if
condition|(
name|bktr
operator|->
name|card
operator|.
name|dbx
condition|)
name|set_BTSC
argument_list|(
name|bktr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *   */
end_comment

begin_function
name|int
name|bktr_close
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|fmt
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|bktr_ptr_t
name|bktr
decl_stmt|;
name|int
name|unit
decl_stmt|;
name|unit
operator|=
name|UNIT
argument_list|(
name|minor
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|unit
operator|>=
name|NBKTR
condition|)
comment|/* unit out of range */
return|return
operator|(
name|ENXIO
operator|)
return|;
name|bktr
operator|=
operator|&
operator|(
name|brooktree
index|[
name|unit
index|]
operator|)
expr_stmt|;
switch|switch
condition|(
name|MINOR
argument_list|(
name|minor
argument_list|(
name|dev
argument_list|)
argument_list|)
condition|)
block|{
case|case
name|VIDEO_DEV
case|:
return|return
operator|(
name|video_close
argument_list|(
name|bktr
argument_list|)
operator|)
return|;
case|case
name|TUNER_DEV
case|:
return|return
operator|(
name|tuner_close
argument_list|(
name|bktr
argument_list|)
operator|)
return|;
block|}
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *   */
end_comment

begin_function
specifier|static
name|int
name|video_close
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|)
block|{
name|bt848_ptr_t
name|bt848
decl_stmt|;
name|bktr
operator|->
name|flags
operator|&=
operator|~
operator|(
name|METEOR_OPEN
operator||
name|METEOR_SINGLE
operator||
name|METEOR_CAP_MASK
operator||
name|METEOR_WANT_MASK
operator|)
expr_stmt|;
name|bt848
operator|=
name|bktr
operator|->
name|base
expr_stmt|;
name|bt848
operator|->
name|gpio_dma_ctl
operator|=
name|FIFO_RISC_DISABLED
expr_stmt|;
name|bt848
operator|->
name|cap_ctl
operator|=
name|CAPTURE_OFF
expr_stmt|;
name|bktr
operator|->
name|dma_prog_loaded
operator|=
name|FALSE
expr_stmt|;
name|bt848
operator|->
name|tdec
operator|=
literal|0
expr_stmt|;
name|bt848
operator|->
name|int_mask
operator|=
name|ALL_INTS_DISABLED
expr_stmt|;
comment|/** FIXME: is 0xf magic, wouldn't 0x00 work ??? */
name|bt848
operator|->
name|sreset
operator|=
literal|0xf
expr_stmt|;
name|bt848
operator|->
name|int_stat
operator|=
name|ALL_INTS_CLEARED
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * tuner close handle,  *  place holder for tuner specific operations on a close.  */
end_comment

begin_function
specifier|static
name|int
name|tuner_close
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|)
block|{
name|bktr
operator|->
name|tflags
operator|&=
operator|~
name|TUNER_OPEN
expr_stmt|;
comment|/* mute the audio by switching the mux */
name|set_audio
argument_list|(
name|bktr
argument_list|,
name|AUDIO_MUTE
argument_list|)
expr_stmt|;
comment|/* disable drivers on the GPIO port that control the MUXes */
name|bktr
operator|->
name|base
operator|->
name|gpio_out_en
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *   */
end_comment

begin_function
name|int
name|bktr_read
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|,
name|int
name|ioflag
parameter_list|)
block|{
name|bktr_ptr_t
name|bktr
decl_stmt|;
name|bt848_ptr_t
name|bt848
decl_stmt|;
name|int
name|unit
decl_stmt|;
name|int
name|status
decl_stmt|;
name|int
name|count
decl_stmt|;
if|if
condition|(
name|minor
argument_list|(
name|dev
argument_list|)
operator|>
literal|0
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|unit
operator|=
name|UNIT
argument_list|(
name|minor
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|unit
operator|>=
name|NBKTR
condition|)
comment|/* unit out of range */
return|return
operator|(
name|ENXIO
operator|)
return|;
name|bktr
operator|=
operator|&
operator|(
name|brooktree
index|[
name|unit
index|]
operator|)
expr_stmt|;
if|if
condition|(
name|bktr
operator|->
name|bigbuf
operator|==
literal|0
condition|)
comment|/* no frame buffer allocated (ioctl failed) */
return|return
operator|(
name|ENOMEM
operator|)
return|;
if|if
condition|(
name|bktr
operator|->
name|flags
operator|&
name|METEOR_CAP_MASK
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
comment|/* already capturing */
name|count
operator|=
name|bktr
operator|->
name|rows
operator|*
name|bktr
operator|->
name|cols
operator|*
name|pixfmt_table
index|[
name|bktr
operator|->
name|pixfmt
index|]
operator|.
name|public
operator|.
name|Bpp
expr_stmt|;
if|if
condition|(
operator|(
name|int
operator|)
name|uio
operator|->
name|uio_iov
operator|->
name|iov_len
operator|<
name|count
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|bktr
operator|->
name|flags
operator|&=
operator|~
operator|(
name|METEOR_CAP_MASK
operator||
name|METEOR_WANT_MASK
operator|)
expr_stmt|;
comment|/* Start capture */
name|bt848
operator|=
name|bktr
operator|->
name|base
expr_stmt|;
name|bt848
operator|->
name|gpio_dma_ctl
operator|=
name|FIFO_ENABLED
expr_stmt|;
name|bt848
operator|->
name|gpio_dma_ctl
operator|=
name|FIFO_RISC_ENABLED
expr_stmt|;
name|status
operator|=
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
name|bktr
argument_list|,
name|METPRI
argument_list|,
literal|"captur"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|status
condition|)
comment|/* successful capture */
name|status
operator|=
name|uiomove
argument_list|(
operator|(
name|caddr_t
operator|)
name|bktr
operator|->
name|bigbuf
argument_list|,
name|count
argument_list|,
name|uio
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"meteor%d: read: tsleep error %d\n"
argument_list|,
name|unit
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|bktr
operator|->
name|flags
operator|&=
operator|~
operator|(
name|METEOR_SINGLE
operator||
name|METEOR_WANT_MASK
operator|)
expr_stmt|;
return|return
operator|(
name|status
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *   */
end_comment

begin_function
name|int
name|bktr_write
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|,
name|int
name|ioflag
parameter_list|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *   */
end_comment

begin_function
name|int
name|bktr_ioctl
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|cmd
parameter_list|,
name|caddr_t
name|arg
parameter_list|,
name|int
name|flag
parameter_list|,
name|struct
name|proc
modifier|*
name|pr
parameter_list|)
block|{
name|bktr_ptr_t
name|bktr
decl_stmt|;
name|int
name|unit
decl_stmt|;
name|unit
operator|=
name|UNIT
argument_list|(
name|minor
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|unit
operator|>=
name|NBKTR
condition|)
comment|/* unit out of range */
return|return
operator|(
name|ENXIO
operator|)
return|;
name|bktr
operator|=
operator|&
operator|(
name|brooktree
index|[
name|unit
index|]
operator|)
expr_stmt|;
if|if
condition|(
name|bktr
operator|->
name|bigbuf
operator|==
literal|0
condition|)
comment|/* no frame buffer allocated (ioctl failed) */
return|return
operator|(
name|ENOMEM
operator|)
return|;
switch|switch
condition|(
name|MINOR
argument_list|(
name|minor
argument_list|(
name|dev
argument_list|)
argument_list|)
condition|)
block|{
case|case
name|VIDEO_DEV
case|:
return|return
operator|(
name|video_ioctl
argument_list|(
name|bktr
argument_list|,
name|unit
argument_list|,
name|cmd
argument_list|,
name|arg
argument_list|,
name|pr
argument_list|)
operator|)
return|;
case|case
name|TUNER_DEV
case|:
return|return
operator|(
name|tuner_ioctl
argument_list|(
name|bktr
argument_list|,
name|unit
argument_list|,
name|cmd
argument_list|,
name|arg
argument_list|,
name|pr
argument_list|)
operator|)
return|;
block|}
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * video ioctls  */
end_comment

begin_function
specifier|static
name|int
name|video_ioctl
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|,
name|int
name|unit
parameter_list|,
name|int
name|cmd
parameter_list|,
name|caddr_t
name|arg
parameter_list|,
name|struct
name|proc
modifier|*
name|pr
parameter_list|)
block|{
name|int
name|status
decl_stmt|;
name|int
name|count
decl_stmt|;
name|int
name|tmp_int
decl_stmt|;
name|bt848_ptr_t
name|bt848
decl_stmt|;
specifier|volatile
name|u_char
name|c_temp
decl_stmt|;
specifier|volatile
name|u_short
name|s_temp
decl_stmt|;
name|unsigned
name|int
name|temp
decl_stmt|,
name|temp1
decl_stmt|;
name|unsigned
name|int
name|error
decl_stmt|;
name|struct
name|meteor_geomet
modifier|*
name|geo
decl_stmt|;
name|struct
name|meteor_counts
modifier|*
name|cnt
decl_stmt|;
name|struct
name|meteor_video
modifier|*
name|video
decl_stmt|;
name|vm_offset_t
name|buf
decl_stmt|;
name|struct
name|format_params
modifier|*
name|fp
decl_stmt|;
name|int
name|i
decl_stmt|;
name|bt848
operator|=
name|bktr
operator|->
name|base
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|BT848SCLIP
case|:
comment|/* set clip region */
name|bktr
operator|->
name|max_clip_node
operator|=
literal|0
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|bktr
operator|->
name|clip_list
argument_list|,
name|arg
argument_list|,
sizeof|sizeof
argument_list|(
name|bktr
operator|->
name|clip_list
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|BT848_MAX_CLIP_NODE
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|bktr
operator|->
name|clip_list
index|[
name|i
index|]
operator|.
name|y_min
operator|==
literal|0
operator|&&
name|bktr
operator|->
name|clip_list
index|[
name|i
index|]
operator|.
name|y_max
operator|==
literal|0
condition|)
block|{
name|bktr
operator|->
name|max_clip_node
operator|=
name|i
expr_stmt|;
break|break;
block|}
block|}
comment|/* make sure that the list contains a valid clip secquence */
comment|/* the clip rectangles should be sorted by x then by y as the                second order sort key */
comment|/* clip rectangle list is terminated by y_min and y_max set to 0 */
comment|/* to disable clipping set  y_min and y_max to 0 in the first                clip rectangle . The first clip rectangle is clip_list[0].              */
if|if
condition|(
name|bktr
operator|->
name|max_clip_node
operator|==
literal|0
operator|&&
operator|(
name|bktr
operator|->
name|clip_list
index|[
literal|0
index|]
operator|.
name|y_min
operator|!=
literal|0
operator|&&
name|bktr
operator|->
name|clip_list
index|[
literal|0
index|]
operator|.
name|y_max
operator|!=
literal|0
operator|)
condition|)
block|{
return|return
name|EINVAL
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|BT848_MAX_CLIP_NODE
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|bktr
operator|->
name|clip_list
index|[
name|i
index|]
operator|.
name|y_min
operator|==
literal|0
operator|&&
name|bktr
operator|->
name|clip_list
index|[
name|i
index|]
operator|.
name|y_max
operator|==
literal|0
condition|)
block|{
break|break;
block|}
if|if
condition|(
name|bktr
operator|->
name|clip_list
index|[
name|i
operator|+
literal|1
index|]
operator|.
name|y_min
operator|!=
literal|0
operator|&&
name|bktr
operator|->
name|clip_list
index|[
name|i
operator|+
literal|1
index|]
operator|.
name|y_max
operator|!=
literal|0
operator|&&
name|bktr
operator|->
name|clip_list
index|[
name|i
index|]
operator|.
name|x_min
operator|>
name|bktr
operator|->
name|clip_list
index|[
name|i
operator|+
literal|1
index|]
operator|.
name|x_min
condition|)
block|{
name|bktr
operator|->
name|max_clip_node
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
name|bktr
operator|->
name|clip_list
index|[
name|i
index|]
operator|.
name|x_min
operator|>=
name|bktr
operator|->
name|clip_list
index|[
name|i
index|]
operator|.
name|x_max
operator|||
name|bktr
operator|->
name|clip_list
index|[
name|i
index|]
operator|.
name|y_min
operator|>=
name|bktr
operator|->
name|clip_list
index|[
name|i
index|]
operator|.
name|y_max
operator|||
name|bktr
operator|->
name|clip_list
index|[
name|i
index|]
operator|.
name|x_min
operator|<
literal|0
operator|||
name|bktr
operator|->
name|clip_list
index|[
name|i
index|]
operator|.
name|x_max
operator|<
literal|0
operator|||
name|bktr
operator|->
name|clip_list
index|[
name|i
index|]
operator|.
name|y_min
operator|<
literal|0
operator|||
name|bktr
operator|->
name|clip_list
index|[
name|i
index|]
operator|.
name|y_max
operator|<
literal|0
condition|)
block|{
name|bktr
operator|->
name|max_clip_node
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
block|}
name|bktr
operator|->
name|dma_prog_loaded
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
name|METEORSTATUS
case|:
comment|/* get Bt848 status */
name|c_temp
operator|=
name|bt848
operator|->
name|dstatus
expr_stmt|;
name|temp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|c_temp
operator|&
literal|0x40
operator|)
condition|)
name|temp
operator||=
name|METEOR_STATUS_HCLK
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|c_temp
operator|&
literal|0x10
operator|)
condition|)
name|temp
operator||=
name|METEOR_STATUS_FIDT
expr_stmt|;
operator|*
operator|(
name|u_short
operator|*
operator|)
name|arg
operator|=
name|temp
expr_stmt|;
break|break;
case|case
name|METEORSFMT
case|:
comment|/* set input format */
switch|switch
condition|(
operator|*
operator|(
name|unsigned
name|long
operator|*
operator|)
name|arg
operator|&
name|METEOR_FORM_MASK
condition|)
block|{
case|case
literal|0
case|:
comment|/* default */
case|case
name|METEOR_FMT_NTSC
case|:
name|bktr
operator|->
name|flags
operator|=
operator|(
name|bktr
operator|->
name|flags
operator|&
operator|~
name|METEOR_FORM_MASK
operator|)
operator||
name|METEOR_NTSC
expr_stmt|;
name|bt848
operator|->
name|iform
operator|&=
operator|~
name|BT848_IFORM_FORMAT
expr_stmt|;
name|bt848
operator|->
name|iform
operator||=
name|BT848_IFORM_F_NTSCM
expr_stmt|;
name|bt848
operator|->
name|adelay
operator|=
literal|0x68
expr_stmt|;
name|bt848
operator|->
name|bdelay
operator|=
literal|0x5d
expr_stmt|;
name|bktr
operator|->
name|format_params
operator|=
name|FORMAT_PARAMS_NTSC525
expr_stmt|;
break|break;
case|case
name|METEOR_FMT_PAL
case|:
name|bktr
operator|->
name|flags
operator|=
operator|(
name|bktr
operator|->
name|flags
operator|&
operator|~
name|METEOR_FORM_MASK
operator|)
operator||
name|METEOR_PAL
expr_stmt|;
name|bt848
operator|->
name|iform
operator|&=
operator|~
name|BT848_IFORM_FORMAT
expr_stmt|;
name|bt848
operator|->
name|iform
operator||=
name|BT848_IFORM_F_PALBDGHI
expr_stmt|;
name|bt848
operator|->
name|adelay
operator|=
literal|0x7f
expr_stmt|;
name|bt848
operator|->
name|bdelay
operator|=
literal|0x72
expr_stmt|;
name|bktr
operator|->
name|format_params
operator|=
name|FORMAT_PARAMS_PAL625
expr_stmt|;
break|break;
case|case
name|METEOR_FMT_AUTOMODE
case|:
name|bktr
operator|->
name|flags
operator|=
operator|(
name|bktr
operator|->
name|flags
operator|&
operator|~
name|METEOR_FORM_MASK
operator|)
operator||
name|METEOR_AUTOMODE
expr_stmt|;
name|bt848
operator|->
name|iform
operator|&=
operator|~
name|BT848_IFORM_FORMAT
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
break|break;
case|case
name|METEORGFMT
case|:
comment|/* get input format */
operator|*
operator|(
name|u_long
operator|*
operator|)
name|arg
operator|=
name|bktr
operator|->
name|flags
operator|&
name|METEOR_FORM_MASK
expr_stmt|;
break|break;
case|case
name|METEORSCOUNT
case|:
comment|/* (re)set error counts */
name|cnt
operator|=
operator|(
expr|struct
name|meteor_counts
operator|*
operator|)
name|arg
expr_stmt|;
name|bktr
operator|->
name|fifo_errors
operator|=
name|cnt
operator|->
name|fifo_errors
expr_stmt|;
name|bktr
operator|->
name|dma_errors
operator|=
name|cnt
operator|->
name|dma_errors
expr_stmt|;
name|bktr
operator|->
name|frames_captured
operator|=
name|cnt
operator|->
name|frames_captured
expr_stmt|;
name|bktr
operator|->
name|even_fields_captured
operator|=
name|cnt
operator|->
name|even_fields_captured
expr_stmt|;
name|bktr
operator|->
name|odd_fields_captured
operator|=
name|cnt
operator|->
name|odd_fields_captured
expr_stmt|;
break|break;
case|case
name|METEORGCOUNT
case|:
comment|/* get error counts */
name|cnt
operator|=
operator|(
expr|struct
name|meteor_counts
operator|*
operator|)
name|arg
expr_stmt|;
name|cnt
operator|->
name|fifo_errors
operator|=
name|bktr
operator|->
name|fifo_errors
expr_stmt|;
name|cnt
operator|->
name|dma_errors
operator|=
name|bktr
operator|->
name|dma_errors
expr_stmt|;
name|cnt
operator|->
name|frames_captured
operator|=
name|bktr
operator|->
name|frames_captured
expr_stmt|;
name|cnt
operator|->
name|even_fields_captured
operator|=
name|bktr
operator|->
name|even_fields_captured
expr_stmt|;
name|cnt
operator|->
name|odd_fields_captured
operator|=
name|bktr
operator|->
name|odd_fields_captured
expr_stmt|;
break|break;
case|case
name|METEORGVIDEO
case|:
name|video
operator|=
operator|(
expr|struct
name|meteor_video
operator|*
operator|)
name|arg
expr_stmt|;
name|video
operator|->
name|addr
operator|=
name|bktr
operator|->
name|video
operator|.
name|addr
expr_stmt|;
name|video
operator|->
name|width
operator|=
name|bktr
operator|->
name|video
operator|.
name|width
expr_stmt|;
name|video
operator|->
name|banksize
operator|=
name|bktr
operator|->
name|video
operator|.
name|banksize
expr_stmt|;
name|video
operator|->
name|ramsize
operator|=
name|bktr
operator|->
name|video
operator|.
name|ramsize
expr_stmt|;
break|break;
case|case
name|METEORSVIDEO
case|:
name|video
operator|=
operator|(
expr|struct
name|meteor_video
operator|*
operator|)
name|arg
expr_stmt|;
name|bktr
operator|->
name|video
operator|.
name|addr
operator|=
name|video
operator|->
name|addr
expr_stmt|;
name|bktr
operator|->
name|video
operator|.
name|width
operator|=
name|video
operator|->
name|width
expr_stmt|;
name|bktr
operator|->
name|video
operator|.
name|banksize
operator|=
name|video
operator|->
name|banksize
expr_stmt|;
name|bktr
operator|->
name|video
operator|.
name|ramsize
operator|=
name|video
operator|->
name|ramsize
expr_stmt|;
break|break;
case|case
name|METEORSFPS
case|:
name|set_fps
argument_list|(
name|bktr
argument_list|,
operator|*
operator|(
name|u_short
operator|*
operator|)
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
name|METEORGFPS
case|:
operator|*
operator|(
name|u_short
operator|*
operator|)
name|arg
operator|=
name|bktr
operator|->
name|fps
expr_stmt|;
break|break;
case|case
name|METEORSHUE
case|:
comment|/* set hue */
name|bt848
operator|->
name|hue
operator|=
operator|(
operator|*
operator|(
name|u_char
operator|*
operator|)
name|arg
operator|)
operator|&
literal|0xff
expr_stmt|;
break|break;
case|case
name|METEORGHUE
case|:
comment|/* get hue */
operator|*
operator|(
name|u_char
operator|*
operator|)
name|arg
operator|=
name|bt848
operator|->
name|hue
expr_stmt|;
break|break;
case|case
name|METEORSBRIG
case|:
comment|/* set brightness */
name|bt848
operator|->
name|bright
operator|=
operator|*
operator|(
name|u_char
operator|*
operator|)
name|arg
operator|&
literal|0xff
expr_stmt|;
break|break;
case|case
name|METEORGBRIG
case|:
comment|/* get brightness */
operator|*
operator|(
name|u_char
operator|*
operator|)
name|arg
operator|=
name|bt848
operator|->
name|bright
expr_stmt|;
break|break;
case|case
name|METEORSCSAT
case|:
comment|/* set chroma saturation */
name|temp
operator|=
operator|(
name|int
operator|)
operator|*
operator|(
name|u_char
operator|*
operator|)
name|arg
expr_stmt|;
name|bt848
operator|->
name|sat_u_lo
operator|=
name|bt848
operator|->
name|sat_v_lo
operator|=
operator|(
name|temp
operator|<<
literal|1
operator|)
operator|&
literal|0xff
expr_stmt|;
name|bt848
operator|->
name|e_control
operator|&=
operator|~
operator|(
name|BT848_E_CONTROL_SAT_U_MSB
operator||
name|BT848_E_CONTROL_SAT_V_MSB
operator|)
expr_stmt|;
name|bt848
operator|->
name|o_control
operator|&=
operator|~
operator|(
name|BT848_O_CONTROL_SAT_U_MSB
operator||
name|BT848_O_CONTROL_SAT_V_MSB
operator|)
expr_stmt|;
if|if
condition|(
name|temp
operator|&
name|BIT_SEVEN_HIGH
condition|)
block|{
name|bt848
operator|->
name|e_control
operator||=
operator|(
name|BT848_E_CONTROL_SAT_U_MSB
operator||
name|BT848_E_CONTROL_SAT_V_MSB
operator|)
expr_stmt|;
name|bt848
operator|->
name|o_control
operator||=
operator|(
name|BT848_O_CONTROL_SAT_U_MSB
operator||
name|BT848_O_CONTROL_SAT_V_MSB
operator|)
expr_stmt|;
block|}
break|break;
case|case
name|METEORGCSAT
case|:
comment|/* get chroma saturation */
name|temp
operator|=
operator|(
name|bt848
operator|->
name|sat_v_lo
operator|>>
literal|1
operator|)
operator|&
literal|0xff
expr_stmt|;
if|if
condition|(
name|bt848
operator|->
name|e_control
operator|&
name|BT848_E_CONTROL_SAT_V_MSB
condition|)
name|temp
operator||=
name|BIT_SEVEN_HIGH
expr_stmt|;
operator|*
operator|(
name|u_char
operator|*
operator|)
name|arg
operator|=
operator|(
name|u_char
operator|)
name|temp
expr_stmt|;
break|break;
case|case
name|METEORSCONT
case|:
comment|/* set contrast */
name|temp
operator|=
operator|(
name|int
operator|)
operator|*
operator|(
name|u_char
operator|*
operator|)
name|arg
operator|&
literal|0xff
expr_stmt|;
name|temp
operator|<<=
literal|1
expr_stmt|;
name|bt848
operator|->
name|contrast_lo
operator|=
name|temp
operator|&
literal|0xff
expr_stmt|;
name|bt848
operator|->
name|e_control
operator|&=
operator|~
name|BT848_E_CONTROL_CON_MSB
expr_stmt|;
name|bt848
operator|->
name|o_control
operator|&=
operator|~
name|BT848_O_CONTROL_CON_MSB
expr_stmt|;
name|bt848
operator|->
name|e_control
operator||=
operator|(
operator|(
name|temp
operator|&
literal|0x100
operator|)
operator|>>
literal|6
operator|)
operator|&
name|BT848_E_CONTROL_CON_MSB
expr_stmt|;
name|bt848
operator|->
name|o_control
operator||=
operator|(
operator|(
name|temp
operator|&
literal|0x100
operator|)
operator|>>
literal|6
operator|)
operator|&
name|BT848_O_CONTROL_CON_MSB
expr_stmt|;
break|break;
case|case
name|METEORGCONT
case|:
comment|/* get contrast */
name|temp
operator|=
operator|(
name|int
operator|)
name|bt848
operator|->
name|contrast_lo
operator|&
literal|0xff
expr_stmt|;
name|temp
operator||=
operator|(
operator|(
name|int
operator|)
name|bt848
operator|->
name|o_control
operator|&
literal|0x04
operator|)
operator|<<
literal|6
expr_stmt|;
operator|*
operator|(
name|u_char
operator|*
operator|)
name|arg
operator|=
call|(
name|u_char
call|)
argument_list|(
operator|(
name|temp
operator|>>
literal|1
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
break|break;
case|case
name|METEORSSIGNAL
case|:
if|if
condition|(
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|==
literal|0
operator|||
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|>=
name|NSIG
condition|)
block|{
return|return
operator|(
name|EINVAL
operator|)
return|;
break|break;
block|}
name|bktr
operator|->
name|signal
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
expr_stmt|;
name|bktr
operator|->
name|proc
operator|=
name|pr
expr_stmt|;
break|break;
case|case
name|METEORGSIGNAL
case|:
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|=
name|bktr
operator|->
name|signal
expr_stmt|;
break|break;
case|case
name|METEORCAPTUR
case|:
name|temp
operator|=
name|bktr
operator|->
name|flags
expr_stmt|;
switch|switch
condition|(
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
condition|)
block|{
case|case
name|METEOR_CAP_SINGLE
case|:
if|if
condition|(
name|bktr
operator|->
name|bigbuf
operator|==
literal|0
condition|)
comment|/* no frame buffer allocated */
return|return
operator|(
name|ENOMEM
operator|)
return|;
comment|/* already capturing */
comment|/* XXX: 			if (temp& METEOR_CAP_MASK) 				return( EIO );  */
name|start_capture
argument_list|(
name|bktr
argument_list|,
name|METEOR_SINGLE
argument_list|)
expr_stmt|;
comment|/* wait for capture to complete */
name|bt848
operator|->
name|int_stat
operator|=
name|ALL_INTS_CLEARED
expr_stmt|;
name|bt848
operator|->
name|gpio_dma_ctl
operator|=
name|FIFO_ENABLED
expr_stmt|;
name|bt848
operator|->
name|gpio_dma_ctl
operator|=
name|bktr
operator|->
name|capcontrol
expr_stmt|;
name|bt848
operator|->
name|int_mask
operator|=
name|BT848_INT_MYSTERYBIT
operator||
name|BT848_INT_RISCI
operator||
name|BT848_INT_VSYNC
operator||
name|BT848_INT_FMTCHG
expr_stmt|;
name|bt848
operator|->
name|cap_ctl
operator|=
name|bktr
operator|->
name|bktr_cap_ctl
expr_stmt|;
name|error
operator|=
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
name|bktr
argument_list|,
name|METPRI
argument_list|,
literal|"captur"
argument_list|,
name|hz
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|&&
operator|(
name|error
operator|!=
name|ERESTART
operator|)
condition|)
block|{
comment|/*  Here if we didn't get complete frame  */
name|printf
argument_list|(
literal|"bktr%d: ioctl: tsleep error %d %x\n"
argument_list|,
name|unit
argument_list|,
name|error
argument_list|,
name|bt848
operator|->
name|risc_count
argument_list|)
expr_stmt|;
comment|/* stop dma */
name|bt848
operator|->
name|int_mask
operator|=
name|ALL_INTS_DISABLED
expr_stmt|;
comment|/* disable risc, leave fifo running */
name|bt848
operator|->
name|gpio_dma_ctl
operator|=
name|FIFO_ENABLED
expr_stmt|;
block|}
name|bktr
operator|->
name|flags
operator|&=
operator|~
operator|(
name|METEOR_SINGLE
operator||
name|METEOR_WANT_MASK
operator|)
expr_stmt|;
comment|/* FIXME: should we set bt848->int_stat ??? */
break|break;
case|case
name|METEOR_CAP_CONTINOUS
case|:
if|if
condition|(
name|bktr
operator|->
name|bigbuf
operator|==
literal|0
condition|)
comment|/* no frame buffer allocated */
return|return
operator|(
name|ENOMEM
operator|)
return|;
if|if
condition|(
name|temp
operator|&
name|METEOR_CAP_MASK
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
comment|/* already capturing */
name|start_capture
argument_list|(
name|bktr
argument_list|,
name|METEOR_CONTIN
argument_list|)
expr_stmt|;
name|bt848
operator|->
name|int_stat
operator|=
name|bt848
operator|->
name|int_stat
expr_stmt|;
name|bt848
operator|->
name|gpio_dma_ctl
operator|=
name|FIFO_ENABLED
expr_stmt|;
name|bt848
operator|->
name|gpio_dma_ctl
operator|=
name|bktr
operator|->
name|capcontrol
expr_stmt|;
name|bt848
operator|->
name|cap_ctl
operator|=
name|bktr
operator|->
name|bktr_cap_ctl
expr_stmt|;
name|bt848
operator|->
name|int_mask
operator|=
name|BT848_INT_MYSTERYBIT
operator||
name|BT848_INT_RISCI
operator||
name|BT848_INT_VSYNC
operator||
name|BT848_INT_FMTCHG
expr_stmt|;
comment|/** 			dump_bt848( bt848 );  */
break|break;
case|case
name|METEOR_CAP_STOP_CONT
case|:
if|if
condition|(
name|bktr
operator|->
name|flags
operator|&
name|METEOR_CONTIN
condition|)
block|{
comment|/* turn off capture */
name|bt848
operator|->
name|int_mask
operator|=
name|ALL_INTS_DISABLED
expr_stmt|;
name|bt848
operator|->
name|gpio_dma_ctl
operator|=
name|FIFO_RISC_DISABLED
expr_stmt|;
name|bt848
operator|->
name|cap_ctl
operator|=
name|CAPTURE_OFF
expr_stmt|;
name|bktr
operator|->
name|flags
operator|&=
operator|~
operator|(
name|METEOR_CONTIN
operator||
name|METEOR_WANT_MASK
operator|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|METEORSETGEO
case|:
name|geo
operator|=
operator|(
expr|struct
name|meteor_geomet
operator|*
operator|)
name|arg
expr_stmt|;
name|fp
operator|=
operator|&
name|format_params
index|[
name|bktr
operator|->
name|format_params
index|]
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
comment|/* Either even or odd, if even& odd, then these a zero */
if|if
condition|(
operator|(
name|geo
operator|->
name|oformat
operator|&
name|METEOR_GEO_ODD_ONLY
operator|)
operator|&&
operator|(
name|geo
operator|->
name|oformat
operator|&
name|METEOR_GEO_EVEN_ONLY
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"bktr%d: ioctl: Geometry odd or even only.\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* set/clear even/odd flags */
if|if
condition|(
name|geo
operator|->
name|oformat
operator|&
name|METEOR_GEO_ODD_ONLY
condition|)
name|bktr
operator|->
name|flags
operator||=
name|METEOR_ONLY_ODD_FIELDS
expr_stmt|;
else|else
name|bktr
operator|->
name|flags
operator|&=
operator|~
name|METEOR_ONLY_ODD_FIELDS
expr_stmt|;
if|if
condition|(
name|geo
operator|->
name|oformat
operator|&
name|METEOR_GEO_EVEN_ONLY
condition|)
name|bktr
operator|->
name|flags
operator||=
name|METEOR_ONLY_EVEN_FIELDS
expr_stmt|;
else|else
name|bktr
operator|->
name|flags
operator|&=
operator|~
name|METEOR_ONLY_EVEN_FIELDS
expr_stmt|;
comment|/* can't change parameters while capturing */
comment|/* XXX: 		if (bktr->flags& METEOR_CAP_MASK) 			return( EBUSY );  */
if|if
condition|(
operator|(
name|geo
operator|->
name|columns
operator|&
literal|0x3fe
operator|)
operator|!=
name|geo
operator|->
name|columns
condition|)
block|{
name|printf
argument_list|(
literal|"bktr%d: ioctl: %d: columns too large or not even.\n"
argument_list|,
name|unit
argument_list|,
name|geo
operator|->
name|columns
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|(
name|geo
operator|->
name|rows
operator|&
literal|0x7fe
operator|)
operator|!=
name|geo
operator|->
name|rows
operator|)
operator|||
operator|(
operator|(
name|geo
operator|->
name|oformat
operator|&
name|METEOR_GEO_FIELD_MASK
operator|)
operator|&&
operator|(
operator|(
name|geo
operator|->
name|rows
operator|&
literal|0x3fe
operator|)
operator|!=
name|geo
operator|->
name|rows
operator|)
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"bktr%d: ioctl: %d: rows too large or not even.\n"
argument_list|,
name|unit
argument_list|,
name|geo
operator|->
name|rows
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
if|if
condition|(
name|geo
operator|->
name|frames
operator|>
literal|32
condition|)
block|{
name|printf
argument_list|(
literal|"bktr%d: ioctl: too many frames.\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|bktr
operator|->
name|dma_prog_loaded
operator|=
name|FALSE
expr_stmt|;
name|bt848
operator|->
name|gpio_dma_ctl
operator|=
name|FIFO_RISC_DISABLED
expr_stmt|;
name|bt848
operator|->
name|int_mask
operator|=
name|ALL_INTS_DISABLED
expr_stmt|;
if|if
condition|(
name|temp
operator|=
name|geo
operator|->
name|rows
operator|*
name|geo
operator|->
name|columns
operator|*
name|geo
operator|->
name|frames
operator|*
literal|2
condition|)
block|{
if|if
condition|(
name|geo
operator|->
name|oformat
operator|&
name|METEOR_GEO_RGB24
condition|)
name|temp
operator|=
name|temp
operator|*
literal|2
expr_stmt|;
comment|/* meteor_mem structure for SYNC Capture */
if|if
condition|(
name|geo
operator|->
name|frames
operator|>
literal|1
condition|)
name|temp
operator|+=
name|PAGE_SIZE
expr_stmt|;
name|temp
operator|=
name|btoc
argument_list|(
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|int
operator|)
name|temp
operator|>
name|bktr
operator|->
name|alloc_pages
operator|&&
name|bktr
operator|->
name|video
operator|.
name|addr
operator|==
literal|0
condition|)
block|{
name|buf
operator|=
name|get_bktr_mem
argument_list|(
name|unit
argument_list|,
name|temp
operator|*
name|PAGE_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|!=
literal|0
condition|)
block|{
name|kmem_free
argument_list|(
name|kernel_map
argument_list|,
name|bktr
operator|->
name|bigbuf
argument_list|,
operator|(
name|bktr
operator|->
name|alloc_pages
operator|*
name|PAGE_SIZE
operator|)
argument_list|)
expr_stmt|;
name|bktr
operator|->
name|bigbuf
operator|=
name|buf
expr_stmt|;
name|bktr
operator|->
name|alloc_pages
operator|=
name|temp
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"meteor%d: ioctl: Allocating %d bytes\n"
argument_list|,
name|unit
argument_list|,
name|temp
operator|*
name|PAGE_SIZE
argument_list|)
expr_stmt|;
block|}
else|else
name|error
operator|=
name|ENOMEM
expr_stmt|;
block|}
block|}
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
name|bktr
operator|->
name|rows
operator|=
name|geo
operator|->
name|rows
expr_stmt|;
name|bktr
operator|->
name|cols
operator|=
name|geo
operator|->
name|columns
expr_stmt|;
name|bktr
operator|->
name|frames
operator|=
name|geo
operator|->
name|frames
expr_stmt|;
comment|/* horizontal scale */
name|temp
operator|=
operator|(
operator|(
name|fp
operator|->
name|htotal
operator|*
name|fp
operator|->
name|hactive_frac
operator|)
operator|/
name|bktr
operator|->
name|cols
operator|-
literal|1
operator|)
operator|*
literal|4096
expr_stmt|;
name|bt848
operator|->
name|e_hscale_lo
operator|=
name|temp
operator|&
literal|0xff
expr_stmt|;
name|bt848
operator|->
name|o_hscale_lo
operator|=
name|temp
operator|&
literal|0xff
expr_stmt|;
name|bt848
operator|->
name|e_hscale_hi
operator|=
operator|(
name|temp
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
name|bt848
operator|->
name|o_hscale_hi
operator|=
operator|(
name|temp
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
comment|/* horizontal active */
name|temp
operator|=
name|bktr
operator|->
name|cols
expr_stmt|;
name|bt848
operator|->
name|e_hactive_lo
operator|=
name|temp
operator|&
literal|0xff
expr_stmt|;
name|bt848
operator|->
name|o_hactive_lo
operator|=
name|temp
operator|&
literal|0xff
expr_stmt|;
name|bt848
operator|->
name|e_crop
operator|&=
operator|~
literal|0x3
expr_stmt|;
name|bt848
operator|->
name|o_crop
operator|&=
operator|~
literal|0x3
expr_stmt|;
name|bt848
operator|->
name|e_crop
operator||=
operator|(
name|temp
operator|>>
literal|8
operator|)
operator|&
literal|0x3
expr_stmt|;
name|bt848
operator|->
name|o_crop
operator||=
operator|(
name|temp
operator|>>
literal|8
operator|)
operator|&
literal|0x3
expr_stmt|;
comment|/* horizontal delay */
name|temp
operator|=
operator|(
operator|(
name|float
operator|)
name|fp
operator|->
name|hdelay
operator|/
name|fp
operator|->
name|hactive
operator|)
operator|*
name|bktr
operator|->
name|cols
expr_stmt|;
name|temp
operator|=
name|temp
operator|+
literal|2
expr_stmt|;
comment|/* why?? - rmt */
name|temp
operator|=
name|temp
operator|&
literal|0x3fe
expr_stmt|;
name|bt848
operator|->
name|e_delay_lo
operator|=
name|temp
operator|&
literal|0xff
expr_stmt|;
name|bt848
operator|->
name|o_delay_lo
operator|=
name|temp
operator|&
literal|0xff
expr_stmt|;
name|bt848
operator|->
name|e_crop
operator|&=
operator|~
literal|0xc
expr_stmt|;
name|bt848
operator|->
name|o_crop
operator|&=
operator|~
literal|0xc
expr_stmt|;
name|bt848
operator|->
name|e_crop
operator||=
operator|(
name|temp
operator|>>
literal|6
operator|)
operator|&
literal|0xc
expr_stmt|;
name|bt848
operator|->
name|o_crop
operator||=
operator|(
name|temp
operator|>>
literal|6
operator|)
operator|&
literal|0xc
expr_stmt|;
comment|/* vertical scale */
if|if
condition|(
name|geo
operator|->
name|oformat
operator|&
name|METEOR_GEO_ODD_ONLY
operator|||
name|geo
operator|->
name|oformat
operator|&
name|METEOR_GEO_EVEN_ONLY
condition|)
name|tmp_int
operator|=
literal|65536.0
operator|-
operator|(
operator|(
name|float
operator|)
name|fp
operator|->
name|vactive
operator|/
literal|2
operator|/
name|bktr
operator|->
name|rows
operator|-
literal|1
operator|)
operator|*
literal|512.0
expr_stmt|;
else|else
name|tmp_int
operator|=
literal|65536.0
operator|-
operator|(
operator|(
name|float
operator|)
name|fp
operator|->
name|vactive
operator|/
name|bktr
operator|->
name|rows
operator|-
literal|1
operator|)
operator|*
literal|512.0
expr_stmt|;
name|tmp_int
operator|&=
literal|0x1fff
expr_stmt|;
name|bt848
operator|->
name|e_vscale_lo
operator|=
name|tmp_int
operator|&
literal|0xff
expr_stmt|;
name|bt848
operator|->
name|o_vscale_lo
operator|=
name|tmp_int
operator|&
literal|0xff
expr_stmt|;
name|bt848
operator|->
name|e_vscale_hi
operator|&=
operator|~
literal|0x1f
expr_stmt|;
name|bt848
operator|->
name|o_vscale_hi
operator|&=
operator|~
literal|0x1f
expr_stmt|;
name|bt848
operator|->
name|e_vscale_hi
operator||=
operator|(
name|tmp_int
operator|>>
literal|8
operator|)
operator|&
literal|0x1f
expr_stmt|;
name|bt848
operator|->
name|o_vscale_hi
operator||=
operator|(
name|tmp_int
operator|>>
literal|8
operator|)
operator|&
literal|0x1f
expr_stmt|;
comment|/* vertical active */
name|bt848
operator|->
name|e_crop
operator|&=
operator|~
literal|0x30
expr_stmt|;
name|bt848
operator|->
name|e_crop
operator||=
operator|(
name|fp
operator|->
name|vactive
operator|>>
literal|4
operator|)
operator|&
literal|0x30
expr_stmt|;
name|bt848
operator|->
name|e_vactive_lo
operator|=
name|fp
operator|->
name|vactive
operator|&
literal|0xff
expr_stmt|;
name|bt848
operator|->
name|o_crop
operator|&=
operator|~
literal|0x30
expr_stmt|;
name|bt848
operator|->
name|o_crop
operator||=
operator|(
name|fp
operator|->
name|vactive
operator|>>
literal|4
operator|)
operator|&
literal|0x30
expr_stmt|;
name|bt848
operator|->
name|o_vactive_lo
operator|=
name|fp
operator|->
name|vactive
operator|&
literal|0xff
expr_stmt|;
comment|/* vertical delay */
name|bt848
operator|->
name|e_vdelay_lo
operator|=
name|fp
operator|->
name|vdelay
expr_stmt|;
name|bt848
operator|->
name|o_vdelay_lo
operator|=
name|fp
operator|->
name|vdelay
expr_stmt|;
comment|/*  Pixel format (if in meteor pixfmt compatibility mode)  */
if|if
condition|(
name|bktr
operator|->
name|pixfmt_compat
condition|)
block|{
name|bktr
operator|->
name|format
operator|=
name|METEOR_GEO_YUV_422
expr_stmt|;
switch|switch
condition|(
name|geo
operator|->
name|oformat
operator|&
name|METEOR_GEO_OUTPUT_MASK
condition|)
block|{
case|case
literal|0
case|:
comment|/* default */
case|case
name|METEOR_GEO_RGB16
case|:
name|bktr
operator|->
name|format
operator|=
name|METEOR_GEO_RGB16
expr_stmt|;
break|break;
case|case
name|METEOR_GEO_RGB24
case|:
name|bktr
operator|->
name|format
operator|=
name|METEOR_GEO_RGB24
expr_stmt|;
break|break;
case|case
name|METEOR_GEO_YUV_422
case|:
name|bktr
operator|->
name|format
operator|=
name|METEOR_GEO_YUV_422
expr_stmt|;
break|break;
case|case
name|METEOR_GEO_YUV_PACKED
case|:
name|bktr
operator|->
name|format
operator|=
name|METEOR_GEO_YUV_PACKED
expr_stmt|;
break|break;
block|}
name|bktr
operator|->
name|pixfmt
operator|=
name|oformat_meteor_to_bt
argument_list|(
name|bktr
operator|->
name|format
argument_list|)
expr_stmt|;
block|}
comment|/* 		if (geo->oformat& METEOR_GEO_YUV_12 ) 			bktr->format |= METEOR_GEO_YUV_12; 		else if (geo->oformat& METEOR_GEO_YUV_9 ) 			bktr->format |= METEOR_GEO_YUV_9;  */
if|if
condition|(
name|bktr
operator|->
name|flags
operator|&
name|METEOR_CAP_MASK
condition|)
block|{
if|if
condition|(
name|bktr
operator|->
name|flags
operator|&
operator|(
name|METEOR_CONTIN
operator||
name|METEOR_SYNCAP
operator|)
condition|)
block|{
switch|switch
condition|(
name|bktr
operator|->
name|flags
operator|&
name|METEOR_ONLY_FIELDS_MASK
condition|)
block|{
case|case
name|METEOR_ONLY_ODD_FIELDS
case|:
name|bktr
operator|->
name|flags
operator||=
name|METEOR_WANT_ODD
expr_stmt|;
break|break;
case|case
name|METEOR_ONLY_EVEN_FIELDS
case|:
name|bktr
operator|->
name|flags
operator||=
name|METEOR_WANT_EVEN
expr_stmt|;
break|break;
default|default:
name|bktr
operator|->
name|flags
operator||=
name|METEOR_WANT_MASK
expr_stmt|;
break|break;
block|}
name|start_capture
argument_list|(
name|bktr
argument_list|,
name|METEOR_CONTIN
argument_list|)
expr_stmt|;
name|bt848
operator|->
name|int_stat
operator|=
name|bt848
operator|->
name|int_stat
expr_stmt|;
name|bt848
operator|->
name|gpio_dma_ctl
operator|=
name|FIFO_ENABLED
expr_stmt|;
name|bt848
operator|->
name|gpio_dma_ctl
operator|=
name|bktr
operator|->
name|capcontrol
expr_stmt|;
name|bt848
operator|->
name|int_mask
operator|=
name|BT848_INT_MYSTERYBIT
operator||
name|BT848_INT_VSYNC
operator||
name|BT848_INT_FMTCHG
expr_stmt|;
block|}
block|}
break|break;
comment|/* end of METEORSETGEO */
default|default:
return|return
name|common_ioctl
argument_list|(
name|bktr
argument_list|,
name|bt848
argument_list|,
name|cmd
argument_list|,
name|arg
argument_list|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * tuner ioctls  */
end_comment

begin_function
specifier|static
name|int
name|tuner_ioctl
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|,
name|int
name|unit
parameter_list|,
name|int
name|cmd
parameter_list|,
name|caddr_t
name|arg
parameter_list|,
name|struct
name|proc
modifier|*
name|pr
parameter_list|)
block|{
name|bt848_ptr_t
name|bt848
decl_stmt|;
name|int
name|status
decl_stmt|;
name|int
name|tmp_int
decl_stmt|;
name|unsigned
name|int
name|temp
decl_stmt|,
name|temp1
decl_stmt|;
name|int
name|offset
decl_stmt|;
name|int
name|count
decl_stmt|;
name|u_char
modifier|*
name|buf
decl_stmt|;
name|bt848
operator|=
name|bktr
operator|->
name|base
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|TUNER_AFC
argument_list|)
case|case
name|TVTUNER_SETAFC
case|:
name|bktr
operator|->
name|tuner
operator|.
name|afc
operator|=
operator|(
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|!=
literal|0
operator|)
expr_stmt|;
break|break;
case|case
name|TVTUNER_GETAFC
case|:
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|=
name|bktr
operator|->
name|tuner
operator|.
name|afc
expr_stmt|;
comment|/* XXX Perhaps use another bit to indicate AFC success? */
break|break;
endif|#
directive|endif
comment|/* TUNER_AFC */
case|case
name|TVTUNER_SETCHNL
case|:
name|temp_mute
argument_list|(
name|bktr
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|temp
operator|=
name|tv_channel
argument_list|(
name|bktr
argument_list|,
operator|(
name|int
operator|)
operator|*
operator|(
name|unsigned
name|long
operator|*
operator|)
name|arg
argument_list|)
expr_stmt|;
name|temp_mute
argument_list|(
name|bktr
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|<
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
operator|*
operator|(
name|unsigned
name|long
operator|*
operator|)
name|arg
operator|=
name|temp
expr_stmt|;
break|break;
case|case
name|TVTUNER_GETCHNL
case|:
operator|*
operator|(
name|unsigned
name|long
operator|*
operator|)
name|arg
operator|=
name|bktr
operator|->
name|tuner
operator|.
name|channel
expr_stmt|;
break|break;
case|case
name|TVTUNER_SETTYPE
case|:
name|temp
operator|=
operator|*
operator|(
name|unsigned
name|long
operator|*
operator|)
name|arg
expr_stmt|;
if|if
condition|(
operator|(
name|temp
operator|<
name|CHNLSET_MIN
operator|)
operator|||
operator|(
name|temp
operator|>
name|CHNLSET_MAX
operator|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|bktr
operator|->
name|tuner
operator|.
name|chnlset
operator|=
name|temp
expr_stmt|;
break|break;
case|case
name|TVTUNER_GETTYPE
case|:
operator|*
operator|(
name|unsigned
name|long
operator|*
operator|)
name|arg
operator|=
name|bktr
operator|->
name|tuner
operator|.
name|chnlset
expr_stmt|;
break|break;
case|case
name|TVTUNER_GETSTATUS
case|:
name|temp
operator|=
name|i2cRead
argument_list|(
name|bktr
argument_list|,
name|TSA552x_RADDR
argument_list|)
expr_stmt|;
operator|*
operator|(
name|unsigned
name|long
operator|*
operator|)
name|arg
operator|=
name|temp
operator|&
literal|0xff
expr_stmt|;
break|break;
case|case
name|TVTUNER_SETFREQ
case|:
name|temp_mute
argument_list|(
name|bktr
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|temp
operator|=
name|tv_freq
argument_list|(
name|bktr
argument_list|,
operator|(
name|int
operator|)
operator|*
operator|(
name|unsigned
name|long
operator|*
operator|)
name|arg
argument_list|)
expr_stmt|;
name|temp_mute
argument_list|(
name|bktr
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|<
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
operator|*
operator|(
name|unsigned
name|long
operator|*
operator|)
name|arg
operator|=
name|temp
expr_stmt|;
break|break;
case|case
name|TVTUNER_GETFREQ
case|:
operator|*
operator|(
name|unsigned
name|long
operator|*
operator|)
name|arg
operator|=
name|bktr
operator|->
name|tuner
operator|.
name|frequency
expr_stmt|;
break|break;
case|case
name|BT848_SAUDIO
case|:
comment|/* set audio channel */
if|if
condition|(
name|set_audio
argument_list|(
name|bktr
argument_list|,
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
break|break;
comment|/* hue is a 2's compliment number, -90' to +89.3' in 0.7' steps */
case|case
name|BT848_SHUE
case|:
comment|/* set hue */
name|bt848
operator|->
name|hue
operator|=
call|(
name|u_char
call|)
argument_list|(
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|&
literal|0xff
argument_list|)
expr_stmt|;
break|break;
case|case
name|BT848_GHUE
case|:
comment|/* get hue */
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|=
call|(
name|signed
name|char
call|)
argument_list|(
name|bt848
operator|->
name|hue
operator|&
literal|0xff
argument_list|)
expr_stmt|;
break|break;
comment|/* brightness is a 2's compliment #, -50 to +%49.6% in 0.39% steps */
case|case
name|BT848_SBRIG
case|:
comment|/* set brightness */
name|bt848
operator|->
name|bright
operator|=
call|(
name|u_char
call|)
argument_list|(
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|&
literal|0xff
argument_list|)
expr_stmt|;
break|break;
case|case
name|BT848_GBRIG
case|:
comment|/* get brightness */
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|=
call|(
name|signed
name|char
call|)
argument_list|(
name|bt848
operator|->
name|bright
operator|&
literal|0xff
argument_list|)
expr_stmt|;
break|break;
comment|/*  */
case|case
name|BT848_SCSAT
case|:
comment|/* set chroma saturation */
name|tmp_int
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
expr_stmt|;
name|temp
operator|=
name|bt848
operator|->
name|e_control
expr_stmt|;
name|temp1
operator|=
name|bt848
operator|->
name|o_control
expr_stmt|;
if|if
condition|(
name|tmp_int
operator|&
name|BIT_EIGHT_HIGH
condition|)
block|{
name|temp
operator||=
operator|(
name|BT848_E_CONTROL_SAT_U_MSB
operator||
name|BT848_E_CONTROL_SAT_V_MSB
operator|)
expr_stmt|;
name|temp1
operator||=
operator|(
name|BT848_O_CONTROL_SAT_U_MSB
operator||
name|BT848_O_CONTROL_SAT_V_MSB
operator|)
expr_stmt|;
block|}
else|else
block|{
name|temp
operator|&=
operator|~
operator|(
name|BT848_E_CONTROL_SAT_U_MSB
operator||
name|BT848_E_CONTROL_SAT_V_MSB
operator|)
expr_stmt|;
name|temp1
operator|&=
operator|~
operator|(
name|BT848_O_CONTROL_SAT_U_MSB
operator||
name|BT848_O_CONTROL_SAT_V_MSB
operator|)
expr_stmt|;
block|}
name|bt848
operator|->
name|sat_u_lo
operator|=
call|(
name|u_char
call|)
argument_list|(
name|tmp_int
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|bt848
operator|->
name|sat_v_lo
operator|=
call|(
name|u_char
call|)
argument_list|(
name|tmp_int
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|bt848
operator|->
name|e_control
operator|=
name|temp
expr_stmt|;
name|bt848
operator|->
name|o_control
operator|=
name|temp1
expr_stmt|;
break|break;
case|case
name|BT848_GCSAT
case|:
comment|/* get chroma saturation */
name|tmp_int
operator|=
call|(
name|int
call|)
argument_list|(
name|bt848
operator|->
name|sat_v_lo
operator|&
literal|0xff
argument_list|)
expr_stmt|;
if|if
condition|(
name|bt848
operator|->
name|e_control
operator|&
name|BT848_E_CONTROL_SAT_V_MSB
condition|)
name|tmp_int
operator||=
name|BIT_EIGHT_HIGH
expr_stmt|;
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|=
name|tmp_int
expr_stmt|;
break|break;
comment|/*  */
case|case
name|BT848_SVSAT
case|:
comment|/* set chroma V saturation */
name|tmp_int
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
expr_stmt|;
name|temp
operator|=
name|bt848
operator|->
name|e_control
expr_stmt|;
name|temp1
operator|=
name|bt848
operator|->
name|o_control
expr_stmt|;
if|if
condition|(
name|tmp_int
operator|&
name|BIT_EIGHT_HIGH
condition|)
block|{
name|temp
operator||=
name|BT848_E_CONTROL_SAT_V_MSB
expr_stmt|;
name|temp1
operator||=
name|BT848_O_CONTROL_SAT_V_MSB
expr_stmt|;
block|}
else|else
block|{
name|temp
operator|&=
operator|~
name|BT848_E_CONTROL_SAT_V_MSB
expr_stmt|;
name|temp1
operator|&=
operator|~
name|BT848_O_CONTROL_SAT_V_MSB
expr_stmt|;
block|}
name|bt848
operator|->
name|sat_v_lo
operator|=
call|(
name|u_char
call|)
argument_list|(
name|tmp_int
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|bt848
operator|->
name|e_control
operator|=
name|temp
expr_stmt|;
name|bt848
operator|->
name|o_control
operator|=
name|temp1
expr_stmt|;
break|break;
case|case
name|BT848_GVSAT
case|:
comment|/* get chroma V saturation */
name|tmp_int
operator|=
operator|(
name|int
operator|)
name|bt848
operator|->
name|sat_v_lo
operator|&
literal|0xff
expr_stmt|;
if|if
condition|(
name|bt848
operator|->
name|e_control
operator|&
name|BT848_E_CONTROL_SAT_V_MSB
condition|)
name|tmp_int
operator||=
name|BIT_EIGHT_HIGH
expr_stmt|;
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|=
name|tmp_int
expr_stmt|;
break|break;
comment|/*  */
case|case
name|BT848_SUSAT
case|:
comment|/* set chroma U saturation */
name|tmp_int
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
expr_stmt|;
name|temp
operator|=
name|bt848
operator|->
name|e_control
expr_stmt|;
name|temp1
operator|=
name|bt848
operator|->
name|o_control
expr_stmt|;
if|if
condition|(
name|tmp_int
operator|&
name|BIT_EIGHT_HIGH
condition|)
block|{
name|temp
operator||=
name|BT848_E_CONTROL_SAT_U_MSB
expr_stmt|;
name|temp1
operator||=
name|BT848_O_CONTROL_SAT_U_MSB
expr_stmt|;
block|}
else|else
block|{
name|temp
operator|&=
operator|~
name|BT848_E_CONTROL_SAT_U_MSB
expr_stmt|;
name|temp1
operator|&=
operator|~
name|BT848_O_CONTROL_SAT_U_MSB
expr_stmt|;
block|}
name|bt848
operator|->
name|sat_u_lo
operator|=
call|(
name|u_char
call|)
argument_list|(
name|tmp_int
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|bt848
operator|->
name|e_control
operator|=
name|temp
expr_stmt|;
name|bt848
operator|->
name|o_control
operator|=
name|temp1
expr_stmt|;
break|break;
case|case
name|BT848_GUSAT
case|:
comment|/* get chroma U saturation */
name|tmp_int
operator|=
operator|(
name|int
operator|)
name|bt848
operator|->
name|sat_u_lo
operator|&
literal|0xff
expr_stmt|;
if|if
condition|(
name|bt848
operator|->
name|e_control
operator|&
name|BT848_E_CONTROL_SAT_U_MSB
condition|)
name|tmp_int
operator||=
name|BIT_EIGHT_HIGH
expr_stmt|;
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|=
name|tmp_int
expr_stmt|;
break|break;
comment|/*  */
case|case
name|BT848_SCONT
case|:
comment|/* set contrast */
name|tmp_int
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
expr_stmt|;
name|temp
operator|=
name|bt848
operator|->
name|e_control
expr_stmt|;
name|temp1
operator|=
name|bt848
operator|->
name|o_control
expr_stmt|;
if|if
condition|(
name|tmp_int
operator|&
name|BIT_EIGHT_HIGH
condition|)
block|{
name|temp
operator||=
name|BT848_E_CONTROL_CON_MSB
expr_stmt|;
name|temp1
operator||=
name|BT848_O_CONTROL_CON_MSB
expr_stmt|;
block|}
else|else
block|{
name|temp
operator|&=
operator|~
name|BT848_E_CONTROL_CON_MSB
expr_stmt|;
name|temp1
operator|&=
operator|~
name|BT848_O_CONTROL_CON_MSB
expr_stmt|;
block|}
name|bt848
operator|->
name|contrast_lo
operator|=
call|(
name|u_char
call|)
argument_list|(
name|tmp_int
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|bt848
operator|->
name|e_control
operator|=
name|temp
expr_stmt|;
name|bt848
operator|->
name|o_control
operator|=
name|temp1
expr_stmt|;
break|break;
case|case
name|BT848_GCONT
case|:
comment|/* get contrast */
name|tmp_int
operator|=
operator|(
name|int
operator|)
name|bt848
operator|->
name|contrast_lo
operator|&
literal|0xff
expr_stmt|;
if|if
condition|(
name|bt848
operator|->
name|e_control
operator|&
name|BT848_E_CONTROL_CON_MSB
condition|)
name|tmp_int
operator||=
name|BIT_EIGHT_HIGH
expr_stmt|;
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|=
name|tmp_int
expr_stmt|;
break|break;
comment|/*  FIXME:  SCBARS and CCBARS require a valid int *        */
comment|/*    argument to succeed, but its not used; consider      */
comment|/*    using the arg to store the on/off state so           */
comment|/*    there's only one ioctl() needed to turn cbars on/off */
case|case
name|BT848_SCBARS
case|:
comment|/* set colorbar output */
name|bt848
operator|->
name|color_ctl_color_bars
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|BT848_CCBARS
case|:
comment|/* clear colorbar output */
name|bt848
operator|->
name|color_ctl_color_bars
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|BT848_GAUDIO
case|:
comment|/* get audio channel */
name|temp
operator|=
name|bktr
operator|->
name|audio_mux_select
expr_stmt|;
if|if
condition|(
name|bktr
operator|->
name|audio_mute_state
operator|==
name|TRUE
condition|)
name|temp
operator||=
name|AUDIO_MUTE
expr_stmt|;
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|=
name|temp
expr_stmt|;
break|break;
case|case
name|BT848_SBTSC
case|:
comment|/* set audio channel */
if|if
condition|(
name|set_BTSC
argument_list|(
name|bktr
argument_list|,
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
break|break;
case|case
name|BT848_WEEPROM
case|:
comment|/* write eeprom */
name|offset
operator|=
operator|(
operator|(
operator|(
expr|struct
name|eeProm
operator|*
operator|)
name|arg
operator|)
operator|->
name|offset
operator|)
expr_stmt|;
name|count
operator|=
operator|(
operator|(
operator|(
expr|struct
name|eeProm
operator|*
operator|)
name|arg
operator|)
operator|->
name|count
operator|)
expr_stmt|;
name|buf
operator|=
operator|&
operator|(
operator|(
operator|(
expr|struct
name|eeProm
operator|*
operator|)
name|arg
operator|)
operator|->
name|bytes
index|[
literal|0
index|]
operator|)
expr_stmt|;
if|if
condition|(
name|writeEEProm
argument_list|(
name|bktr
argument_list|,
name|offset
argument_list|,
name|count
argument_list|,
name|buf
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
break|break;
case|case
name|BT848_REEPROM
case|:
comment|/* read eeprom */
name|offset
operator|=
operator|(
operator|(
operator|(
expr|struct
name|eeProm
operator|*
operator|)
name|arg
operator|)
operator|->
name|offset
operator|)
expr_stmt|;
name|count
operator|=
operator|(
operator|(
operator|(
expr|struct
name|eeProm
operator|*
operator|)
name|arg
operator|)
operator|->
name|count
operator|)
expr_stmt|;
name|buf
operator|=
operator|&
operator|(
operator|(
operator|(
expr|struct
name|eeProm
operator|*
operator|)
name|arg
operator|)
operator|->
name|bytes
index|[
literal|0
index|]
operator|)
expr_stmt|;
if|if
condition|(
name|readEEProm
argument_list|(
name|bktr
argument_list|,
name|offset
argument_list|,
name|count
argument_list|,
name|buf
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
break|break;
case|case
name|BT848_SIGNATURE
case|:
name|offset
operator|=
operator|(
operator|(
operator|(
expr|struct
name|eeProm
operator|*
operator|)
name|arg
operator|)
operator|->
name|offset
operator|)
expr_stmt|;
name|count
operator|=
operator|(
operator|(
operator|(
expr|struct
name|eeProm
operator|*
operator|)
name|arg
operator|)
operator|->
name|count
operator|)
expr_stmt|;
name|buf
operator|=
operator|&
operator|(
operator|(
operator|(
expr|struct
name|eeProm
operator|*
operator|)
name|arg
operator|)
operator|->
name|bytes
index|[
literal|0
index|]
operator|)
expr_stmt|;
if|if
condition|(
name|signCard
argument_list|(
name|bktr
argument_list|,
name|offset
argument_list|,
name|count
argument_list|,
name|buf
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
break|break;
default|default:
return|return
name|common_ioctl
argument_list|(
name|bktr
argument_list|,
name|bt848
argument_list|,
name|cmd
argument_list|,
name|arg
argument_list|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * common ioctls  */
end_comment

begin_function
name|int
name|common_ioctl
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|,
name|bt848_ptr_t
name|bt848
parameter_list|,
name|int
name|cmd
parameter_list|,
name|caddr_t
name|arg
parameter_list|)
block|{
name|int
name|status
decl_stmt|,
name|pixfmt
decl_stmt|;
name|unsigned
name|int
name|temp
decl_stmt|;
name|struct
name|meteor_pixfmt_internal
modifier|*
name|pf_int
decl_stmt|;
name|struct
name|meteor_pixfmt
modifier|*
name|pf_pub
decl_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|METEORSINPUT
case|:
comment|/* set input device */
switch|switch
condition|(
operator|*
operator|(
name|unsigned
name|long
operator|*
operator|)
name|arg
operator|&
name|METEOR_DEV_MASK
condition|)
block|{
comment|/* this is the RCA video input */
case|case
literal|0
case|:
comment|/* default */
case|case
name|METEOR_INPUT_DEV0
case|:
name|bktr
operator|->
name|flags
operator|=
operator|(
name|bktr
operator|->
name|flags
operator|&
operator|~
name|METEOR_DEV_MASK
operator|)
operator||
name|METEOR_DEV0
expr_stmt|;
name|bt848
operator|->
name|iform
operator|&=
operator|~
name|BT848_IFORM_MUXSEL
expr_stmt|;
name|bt848
operator|->
name|iform
operator||=
name|BT848_IFORM_M_MUX1
expr_stmt|;
name|bt848
operator|->
name|e_control
operator|&=
operator|~
name|BT848_E_CONTROL_COMP
expr_stmt|;
name|bt848
operator|->
name|o_control
operator|&=
operator|~
name|BT848_O_CONTROL_COMP
expr_stmt|;
name|set_audio
argument_list|(
name|bktr
argument_list|,
name|AUDIO_EXTERN
argument_list|)
expr_stmt|;
break|break;
comment|/* this is the tuner input */
case|case
name|METEOR_INPUT_DEV1
case|:
name|bktr
operator|->
name|flags
operator|=
operator|(
name|bktr
operator|->
name|flags
operator|&
operator|~
name|METEOR_DEV_MASK
operator|)
operator||
name|METEOR_DEV1
expr_stmt|;
name|bt848
operator|->
name|iform
operator|&=
operator|~
name|BT848_IFORM_MUXSEL
expr_stmt|;
name|bt848
operator|->
name|iform
operator||=
name|BT848_IFORM_M_MUX0
expr_stmt|;
name|bt848
operator|->
name|e_control
operator|&=
operator|~
name|BT848_E_CONTROL_COMP
expr_stmt|;
name|bt848
operator|->
name|o_control
operator|&=
operator|~
name|BT848_O_CONTROL_COMP
expr_stmt|;
name|set_audio
argument_list|(
name|bktr
argument_list|,
name|AUDIO_TUNER
argument_list|)
expr_stmt|;
break|break;
comment|/* this is the S-VHS input */
case|case
name|METEOR_INPUT_DEV2
case|:
case|case
name|METEOR_INPUT_DEV_SVIDEO
case|:
name|bktr
operator|->
name|flags
operator|=
operator|(
name|bktr
operator|->
name|flags
operator|&
operator|~
name|METEOR_DEV_MASK
operator|)
operator||
name|METEOR_DEV2
expr_stmt|;
name|bt848
operator|->
name|iform
operator|&=
operator|~
name|BT848_IFORM_MUXSEL
expr_stmt|;
name|bt848
operator|->
name|iform
operator||=
name|BT848_IFORM_M_MUX2
expr_stmt|;
name|bt848
operator|->
name|e_control
operator||=
name|BT848_E_CONTROL_COMP
expr_stmt|;
name|bt848
operator|->
name|o_control
operator||=
name|BT848_O_CONTROL_COMP
expr_stmt|;
name|set_audio
argument_list|(
name|bktr
argument_list|,
name|AUDIO_EXTERN
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
break|break;
case|case
name|METEORGINPUT
case|:
comment|/* get input device */
operator|*
operator|(
name|u_long
operator|*
operator|)
name|arg
operator|=
name|bktr
operator|->
name|flags
operator|&
name|METEOR_DEV_MASK
expr_stmt|;
break|break;
case|case
name|METEORSACTPIXFMT
case|:
if|if
condition|(
operator|(
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|<
literal|0
operator|)
operator|||
operator|(
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|>=
name|PIXFMT_TABLE_SIZE
operator|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|bktr
operator|->
name|pixfmt
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
expr_stmt|;
name|bt848
operator|->
name|color_ctl_swap
operator|=
name|pixfmt_swap_flags
argument_list|(
name|bktr
operator|->
name|pixfmt
argument_list|)
expr_stmt|;
name|bktr
operator|->
name|pixfmt_compat
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
name|METEORGACTPIXFMT
case|:
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|=
name|bktr
operator|->
name|pixfmt
expr_stmt|;
break|break;
case|case
name|METEORGSUPPIXFMT
case|:
name|pf_pub
operator|=
operator|(
expr|struct
name|meteor_pixfmt
operator|*
operator|)
name|arg
expr_stmt|;
name|pixfmt
operator|=
name|pf_pub
operator|->
name|index
expr_stmt|;
if|if
condition|(
operator|(
name|pixfmt
operator|<
literal|0
operator|)
operator|||
operator|(
name|pixfmt
operator|>=
name|PIXFMT_TABLE_SIZE
operator|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|memcpy
argument_list|(
name|pf_pub
argument_list|,
operator|&
name|pixfmt_table
index|[
name|pixfmt
index|]
operator|.
name|public
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|pf_pub
argument_list|)
argument_list|)
expr_stmt|;
comment|/*  Patch in our format index  */
name|pf_pub
operator|->
name|index
operator|=
name|pixfmt
expr_stmt|;
break|break;
if|#
directive|if
name|defined
argument_list|(
name|STATUS_SUM
argument_list|)
case|case
name|BT848_GSTATUS
case|:
comment|/* reap status */
name|disable_intr
argument_list|()
expr_stmt|;
name|temp
operator|=
name|status_sum
expr_stmt|;
name|status_sum
operator|=
literal|0
expr_stmt|;
name|enable_intr
argument_list|()
expr_stmt|;
operator|*
operator|(
name|u_int
operator|*
operator|)
name|arg
operator|=
name|temp
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* STATUS_SUM */
default|default:
return|return
operator|(
name|ENOTTY
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *   */
end_comment

begin_function
name|int
name|bktr_mmap
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|nprot
parameter_list|)
block|{
name|int
name|unit
decl_stmt|;
name|bktr_ptr_t
name|bktr
decl_stmt|;
name|unit
operator|=
name|UNIT
argument_list|(
name|minor
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|unit
operator|>=
name|NBKTR
operator|||
name|minor
argument_list|(
name|dev
argument_list|)
operator|>
literal|0
condition|)
comment|/* could this happen here? */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|bktr
operator|=
operator|&
operator|(
name|brooktree
index|[
name|unit
index|]
operator|)
expr_stmt|;
if|if
condition|(
name|nprot
operator|&
name|PROT_EXEC
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|offset
operator|>=
name|bktr
operator|->
name|alloc_pages
operator|*
name|PAGE_SIZE
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
return|return
operator|(
name|i386_btop
argument_list|(
name|vtophys
argument_list|(
name|bktr
operator|->
name|bigbuf
argument_list|)
operator|+
name|offset
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************  * bt848 RISC programming routines:  */
end_comment

begin_comment
comment|/*  *   */
end_comment

begin_function
specifier|static
name|int
name|dump_bt848
parameter_list|(
name|bt848_ptr_t
name|bt848
parameter_list|)
block|{
specifier|volatile
name|u_char
modifier|*
name|bt848r
init|=
operator|(
name|u_char
operator|*
operator|)
name|bt848
decl_stmt|;
name|int
name|r
index|[
literal|60
index|]
init|=
block|{
literal|4
block|,
literal|8
block|,
literal|0xc
block|,
literal|0x8c
block|,
literal|0x10
block|,
literal|0x90
block|,
literal|0x14
block|,
literal|0x94
block|,
literal|0x18
block|,
literal|0x98
block|,
literal|0x1c
block|,
literal|0x9c
block|,
literal|0x20
block|,
literal|0xa0
block|,
literal|0x24
block|,
literal|0xa4
block|,
literal|0x28
block|,
literal|0x2c
block|,
literal|0xac
block|,
literal|0x30
block|,
literal|0x34
block|,
literal|0x38
block|,
literal|0x3c
block|,
literal|0x40
block|,
literal|0xc0
block|,
literal|0x48
block|,
literal|0x4c
block|,
literal|0xcc
block|,
literal|0x50
block|,
literal|0xd0
block|,
literal|0xd4
block|,
literal|0x60
block|,
literal|0x64
block|,
literal|0x68
block|,
literal|0x6c
block|,
literal|0xec
block|,
literal|0xd8
block|,
literal|0xdc
block|,
literal|0xe0
block|,
literal|0xe4
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|40
condition|;
name|i
operator|+=
literal|4
control|)
block|{
name|printf
argument_list|(
literal|" Reg:value : \t%x:%x \t%x:%x \t %x:%x \t %x:%x\n"
argument_list|,
name|r
index|[
name|i
index|]
argument_list|,
name|bt848r
index|[
name|r
index|[
name|i
index|]
index|]
argument_list|,
name|r
index|[
name|i
operator|+
literal|1
index|]
argument_list|,
name|bt848r
index|[
name|r
index|[
name|i
operator|+
literal|1
index|]
index|]
argument_list|,
name|r
index|[
name|i
operator|+
literal|2
index|]
argument_list|,
name|bt848r
index|[
name|r
index|[
name|i
operator|+
literal|2
index|]
index|]
argument_list|,
name|r
index|[
name|i
operator|+
literal|3
index|]
argument_list|,
name|bt848r
index|[
name|r
index|[
name|i
operator|+
literal|3
index|]
index|]
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|" INT STAT %x \n"
argument_list|,
name|bt848
operator|->
name|int_stat
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" Reg INT_MASK %x \n"
argument_list|,
name|bt848
operator|->
name|int_mask
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" Reg GPIO_DMA_CTL %x \n"
argument_list|,
name|bt848
operator|->
name|gpio_dma_ctl
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * build write instruction  */
end_comment

begin_define
define|#
directive|define
name|BKTR_FM1
value|0x6
end_define

begin_define
define|#
directive|define
name|BKTR_FM3
value|0xe
end_define

begin_define
define|#
directive|define
name|BKTR_VRE
value|0x4
end_define

begin_define
define|#
directive|define
name|BKTR_VRO
value|0xC
end_define

begin_define
define|#
directive|define
name|BKTR_PXV
value|0x0
end_define

begin_define
define|#
directive|define
name|BKTR_EOL
value|0x1
end_define

begin_define
define|#
directive|define
name|BKTR_SOL
value|0x2
end_define

begin_define
define|#
directive|define
name|OP_WRITE
value|(0x1<< 28)
end_define

begin_define
define|#
directive|define
name|OP_SKIP
value|(0x2<< 28)
end_define

begin_define
define|#
directive|define
name|OP_WRITEC
value|(0x5<< 28)
end_define

begin_define
define|#
directive|define
name|OP_JUMP
value|(0x7<< 28)
end_define

begin_define
define|#
directive|define
name|OP_SYNC
value|(0x8<< 28)
end_define

begin_define
define|#
directive|define
name|OP_WRITE123
value|(0x9<< 28)
end_define

begin_define
define|#
directive|define
name|OP_WRITES123
value|(0xb<< 28)
end_define

begin_define
define|#
directive|define
name|OP_SOL
value|(1<< 27)
end_define

begin_define
define|#
directive|define
name|OP_EOL
value|(1<< 26)
end_define

begin_function
name|bool_t
name|notclipped
parameter_list|(
name|bktr_reg_t
modifier|*
name|bktr
parameter_list|,
name|int
name|x
parameter_list|,
name|int
name|width
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|bktr_clip_t
modifier|*
name|clip_node
decl_stmt|;
name|bktr
operator|->
name|clip_start
operator|=
operator|-
literal|1
expr_stmt|;
name|bktr
operator|->
name|last_y
operator|=
literal|0
expr_stmt|;
name|bktr
operator|->
name|y
operator|=
literal|0
expr_stmt|;
name|bktr
operator|->
name|y2
operator|=
name|width
expr_stmt|;
name|bktr
operator|->
name|line_length
operator|=
name|width
expr_stmt|;
name|bktr
operator|->
name|yclip
operator|=
operator|-
literal|1
expr_stmt|;
name|bktr
operator|->
name|yclip2
operator|=
operator|-
literal|1
expr_stmt|;
name|bktr
operator|->
name|current_col
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|bktr
operator|->
name|max_clip_node
operator|==
literal|0
condition|)
return|return
name|TRUE
return|;
name|clip_node
operator|=
operator|(
name|bktr_clip_t
operator|*
operator|)
operator|&
name|bktr
operator|->
name|clip_list
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|bktr
operator|->
name|max_clip_node
condition|;
name|i
operator|++
control|)
block|{
name|clip_node
operator|=
operator|(
name|bktr_clip_t
operator|*
operator|)
operator|&
name|bktr
operator|->
name|clip_list
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|x
operator|>=
name|clip_node
operator|->
name|x_min
operator|&&
name|x
operator|<=
name|clip_node
operator|->
name|x_max
condition|)
block|{
name|bktr
operator|->
name|clip_start
operator|=
name|i
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_function
name|bool_t
name|getline
parameter_list|(
name|bktr_reg_t
modifier|*
name|bktr
parameter_list|,
name|int
name|x
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|bktr_clip_t
modifier|*
name|clip_node
decl_stmt|;
if|if
condition|(
name|bktr
operator|->
name|line_length
operator|==
literal|0
operator|||
name|bktr
operator|->
name|current_col
operator|>=
name|bktr
operator|->
name|line_length
condition|)
return|return
name|FALSE
return|;
name|bktr
operator|->
name|y
operator|=
name|min
argument_list|(
name|bktr
operator|->
name|last_y
argument_list|,
name|bktr
operator|->
name|line_length
argument_list|)
expr_stmt|;
name|bktr
operator|->
name|y2
operator|=
name|bktr
operator|->
name|line_length
expr_stmt|;
name|bktr
operator|->
name|yclip
operator|=
name|bktr
operator|->
name|yclip2
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
name|bktr
operator|->
name|clip_start
init|;
name|i
operator|<
name|bktr
operator|->
name|max_clip_node
condition|;
name|i
operator|++
control|)
block|{
name|clip_node
operator|=
operator|(
name|bktr_clip_t
operator|*
operator|)
operator|&
name|bktr
operator|->
name|clip_list
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|x
operator|>=
name|clip_node
operator|->
name|x_min
operator|&&
name|x
operator|<=
name|clip_node
operator|->
name|x_max
condition|)
block|{
if|if
condition|(
name|bktr
operator|->
name|last_y
operator|<=
name|clip_node
operator|->
name|y_min
condition|)
block|{
name|bktr
operator|->
name|y
operator|=
name|min
argument_list|(
name|bktr
operator|->
name|last_y
argument_list|,
name|bktr
operator|->
name|line_length
argument_list|)
expr_stmt|;
name|bktr
operator|->
name|y2
operator|=
name|min
argument_list|(
name|clip_node
operator|->
name|y_min
argument_list|,
name|bktr
operator|->
name|line_length
argument_list|)
expr_stmt|;
name|bktr
operator|->
name|yclip
operator|=
name|min
argument_list|(
name|clip_node
operator|->
name|y_min
argument_list|,
name|bktr
operator|->
name|line_length
argument_list|)
expr_stmt|;
name|bktr
operator|->
name|yclip2
operator|=
name|min
argument_list|(
name|clip_node
operator|->
name|y_max
argument_list|,
name|bktr
operator|->
name|line_length
argument_list|)
expr_stmt|;
name|bktr
operator|->
name|last_y
operator|=
name|bktr
operator|->
name|yclip2
expr_stmt|;
name|bktr
operator|->
name|clip_start
operator|=
name|i
expr_stmt|;
for|for
control|(
name|j
operator|=
name|i
operator|+
literal|1
init|;
name|j
operator|<
name|bktr
operator|->
name|max_clip_node
condition|;
name|j
operator|++
control|)
block|{
name|clip_node
operator|=
operator|(
name|bktr_clip_t
operator|*
operator|)
operator|&
name|bktr
operator|->
name|clip_list
index|[
name|j
index|]
expr_stmt|;
if|if
condition|(
name|x
operator|>=
name|clip_node
operator|->
name|x_min
operator|&&
name|x
operator|<=
name|clip_node
operator|->
name|x_max
condition|)
block|{
if|if
condition|(
name|bktr
operator|->
name|last_y
operator|>=
name|clip_node
operator|->
name|y_min
condition|)
block|{
name|bktr
operator|->
name|yclip2
operator|=
name|min
argument_list|(
name|clip_node
operator|->
name|y_max
argument_list|,
name|bktr
operator|->
name|line_length
argument_list|)
expr_stmt|;
name|bktr
operator|->
name|last_y
operator|=
name|bktr
operator|->
name|yclip2
expr_stmt|;
name|bktr
operator|->
name|clip_start
operator|=
name|j
expr_stmt|;
block|}
block|}
else|else
break|break  ;
block|}
return|return
name|TRUE
return|;
block|}
block|}
block|}
if|if
condition|(
name|bktr
operator|->
name|current_col
operator|<=
name|bktr
operator|->
name|line_length
condition|)
block|{
name|bktr
operator|->
name|current_col
operator|=
name|bktr
operator|->
name|line_length
expr_stmt|;
return|return
name|TRUE
return|;
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_function
specifier|static
name|bool_t
name|split
parameter_list|(
name|bktr_reg_t
modifier|*
name|bktr
parameter_list|,
specifier|volatile
name|u_long
modifier|*
modifier|*
name|dma_prog
parameter_list|,
name|int
name|width
parameter_list|,
name|u_long
name|operation
parameter_list|,
name|int
name|pixel_width
parameter_list|,
specifier|volatile
name|u_char
modifier|*
modifier|*
name|target_buffer
parameter_list|,
name|int
name|cols
parameter_list|)
block|{
name|u_long
name|flag
decl_stmt|,
name|flag2
decl_stmt|;
if|if
condition|(
operator|(
name|width
operator|*
name|pixel_width
operator|)
operator|<
name|DMA_BT848_SPLIT
condition|)
block|{
if|if
condition|(
name|width
operator|==
name|cols
condition|)
block|{
name|flag
operator|=
name|OP_SOL
operator||
name|OP_EOL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bktr
operator|->
name|current_col
operator|==
literal|0
condition|)
block|{
name|flag
operator|=
name|OP_SOL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bktr
operator|->
name|current_col
operator|==
name|cols
condition|)
block|{
name|flag
operator|=
name|OP_EOL
expr_stmt|;
block|}
else|else
name|flag
operator|=
literal|0
expr_stmt|;
operator|*
operator|(
operator|*
name|dma_prog
operator|)
operator|++
operator|=
name|operation
operator||
name|flag
operator||
name|bt_enable_cnt
operator|<<
literal|12
operator||
name|width
operator|*
name|pixel_width
expr_stmt|;
if|if
condition|(
name|operation
operator|!=
name|OP_SKIP
condition|)
operator|*
operator|(
operator|*
name|dma_prog
operator|)
operator|++
operator|=
operator|(
name|u_long
operator|)
operator|*
name|target_buffer
expr_stmt|;
operator|*
name|target_buffer
operator|+=
name|width
operator|*
name|pixel_width
expr_stmt|;
name|bktr
operator|->
name|current_col
operator|+=
name|width
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|bktr
operator|->
name|current_col
operator|==
literal|0
operator|&&
name|width
operator|==
name|cols
condition|)
block|{
name|flag
operator|=
name|OP_SOL
expr_stmt|;
name|flag2
operator|=
name|OP_EOL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bktr
operator|->
name|current_col
operator|==
literal|0
condition|)
block|{
name|flag
operator|=
name|OP_SOL
expr_stmt|;
name|flag2
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bktr
operator|->
name|current_col
operator|>=
name|cols
condition|)
block|{
name|flag
operator|=
literal|0
expr_stmt|;
name|flag2
operator|=
name|OP_EOL
expr_stmt|;
block|}
else|else
block|{
name|flag
operator|=
literal|0
expr_stmt|;
name|flag2
operator|=
literal|0
expr_stmt|;
block|}
operator|*
operator|(
operator|*
name|dma_prog
operator|)
operator|++
operator|=
name|operation
operator||
name|bt_enable_cnt
operator|<<
literal|12
operator||
name|flag
operator||
operator|(
name|width
operator|*
name|pixel_width
operator|/
literal|2
operator|)
expr_stmt|;
if|if
condition|(
name|operation
operator|!=
name|OP_SKIP
condition|)
operator|*
operator|(
operator|*
name|dma_prog
operator|)
operator|++
operator|=
operator|(
name|u_long
operator|)
operator|*
name|target_buffer
expr_stmt|;
operator|*
name|target_buffer
operator|+=
operator|(
name|width
operator|*
name|pixel_width
operator|/
literal|2
operator|)
expr_stmt|;
operator|*
operator|(
operator|*
name|dma_prog
operator|)
operator|++
operator|=
name|operation
operator||
name|bt_enable_cnt
operator|<<
literal|12
operator||
name|flag2
operator||
operator|(
name|width
operator|*
name|pixel_width
operator|/
literal|2
operator|)
expr_stmt|;
if|if
condition|(
name|operation
operator|!=
name|OP_SKIP
condition|)
operator|*
operator|(
operator|*
name|dma_prog
operator|)
operator|++
operator|=
operator|(
name|u_long
operator|)
operator|*
name|target_buffer
expr_stmt|;
operator|*
name|target_buffer
operator|+=
operator|(
name|width
operator|*
name|pixel_width
operator|/
literal|2
operator|)
expr_stmt|;
name|bktr
operator|->
name|current_col
operator|+=
name|width
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|rgb_prog
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|,
name|char
name|i_flag
parameter_list|,
name|int
name|cols
parameter_list|,
name|int
name|rows
parameter_list|,
name|int
name|interlace
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|byte_count
decl_stmt|;
name|bt848_ptr_t
name|bt848
decl_stmt|;
specifier|volatile
name|u_long
name|target_buffer
decl_stmt|,
name|buffer
decl_stmt|,
name|target
decl_stmt|,
name|width
decl_stmt|;
specifier|volatile
name|u_long
name|pitch
decl_stmt|;
specifier|volatile
name|u_long
modifier|*
name|dma_prog
decl_stmt|,
modifier|*
name|t_test
decl_stmt|;
name|int
name|c
decl_stmt|;
name|struct
name|meteor_pixfmt_internal
modifier|*
name|pf_int
init|=
operator|&
name|pixfmt_table
index|[
name|bktr
operator|->
name|pixfmt
index|]
decl_stmt|;
name|u_int
name|Bpp
init|=
name|pf_int
operator|->
name|public
operator|.
name|Bpp
decl_stmt|;
name|bt848
operator|=
name|bktr
operator|->
name|base
expr_stmt|;
name|bt848
operator|->
name|color_fmt
operator|=
name|pf_int
operator|->
name|color_fmt
expr_stmt|;
name|bt848
operator|->
name|vbi_pack_size
operator|=
literal|0
expr_stmt|;
name|bt848
operator|->
name|vbi_pack_del
operator|=
literal|0
expr_stmt|;
name|bt848
operator|->
name|adc
operator|=
name|SYNC_LEVEL
expr_stmt|;
name|bt848
operator|->
name|color_ctl_rgb_ded
operator|=
literal|1
expr_stmt|;
name|bt848
operator|->
name|e_vscale_hi
operator||=
literal|0xc0
expr_stmt|;
name|bt848
operator|->
name|o_vscale_hi
operator||=
literal|0xc0
expr_stmt|;
if|if
condition|(
name|cols
operator|>
literal|385
condition|)
block|{
name|bt848
operator|->
name|e_vtc
operator|=
literal|0
expr_stmt|;
name|bt848
operator|->
name|o_vtc
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|bt848
operator|->
name|e_vtc
operator|=
literal|1
expr_stmt|;
name|bt848
operator|->
name|o_vtc
operator|=
literal|1
expr_stmt|;
block|}
name|bktr
operator|->
name|capcontrol
operator|=
literal|3
operator|<<
literal|2
operator||
literal|3
expr_stmt|;
name|dma_prog
operator|=
operator|(
name|u_long
operator|*
operator|)
name|bktr
operator|->
name|dma_prog
expr_stmt|;
comment|/* Construct Write */
name|bt_enable_cnt
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|bktr
operator|->
name|video
operator|.
name|addr
condition|)
block|{
name|target_buffer
operator|=
operator|(
name|u_long
operator|)
name|bktr
operator|->
name|video
operator|.
name|addr
expr_stmt|;
name|pitch
operator|=
name|bktr
operator|->
name|video
operator|.
name|width
expr_stmt|;
block|}
else|else
block|{
name|target_buffer
operator|=
operator|(
name|u_long
operator|)
name|vtophys
argument_list|(
name|bktr
operator|->
name|bigbuf
argument_list|)
expr_stmt|;
name|pitch
operator|=
name|cols
operator|*
name|Bpp
expr_stmt|;
block|}
name|buffer
operator|=
name|target_buffer
expr_stmt|;
if|if
condition|(
name|interlace
operator|==
literal|2
operator|&&
name|rows
operator|<
literal|320
condition|)
name|target_buffer
operator|+=
name|pitch
expr_stmt|;
comment|/* contruct sync : for video packet format */
operator|*
name|dma_prog
operator|++
operator|=
name|OP_SYNC
operator||
literal|1
operator|<<
literal|15
operator||
name|BKTR_FM1
expr_stmt|;
comment|/* sync, mode indicator packed data */
operator|*
name|dma_prog
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* NULL WORD */
name|width
operator|=
name|cols
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|rows
operator|/
name|interlace
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|target
operator|=
name|target_buffer
expr_stmt|;
if|if
condition|(
name|notclipped
argument_list|(
name|bktr
argument_list|,
name|i
argument_list|,
name|width
argument_list|)
condition|)
block|{
name|split
argument_list|(
name|bktr
argument_list|,
operator|(
specifier|volatile
name|u_long
operator|*
operator|*
operator|)
operator|&
name|dma_prog
argument_list|,
name|bktr
operator|->
name|y2
operator|-
name|bktr
operator|->
name|y
argument_list|,
name|OP_WRITE
argument_list|,
name|Bpp
argument_list|,
operator|(
specifier|volatile
name|u_char
operator|*
operator|*
operator|)
operator|&
name|target
argument_list|,
name|cols
argument_list|)
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
name|getline
argument_list|(
name|bktr
argument_list|,
name|i
argument_list|)
condition|)
block|{
if|if
condition|(
name|bktr
operator|->
name|y
operator|!=
name|bktr
operator|->
name|y2
condition|)
block|{
name|split
argument_list|(
name|bktr
argument_list|,
operator|(
specifier|volatile
name|u_long
operator|*
operator|*
operator|)
operator|&
name|dma_prog
argument_list|,
name|bktr
operator|->
name|y2
operator|-
name|bktr
operator|->
name|y
argument_list|,
name|OP_WRITE
argument_list|,
name|Bpp
argument_list|,
operator|(
specifier|volatile
name|u_char
operator|*
operator|*
operator|)
operator|&
name|target
argument_list|,
name|cols
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bktr
operator|->
name|yclip
operator|!=
name|bktr
operator|->
name|yclip2
condition|)
block|{
name|split
argument_list|(
name|bktr
argument_list|,
operator|(
specifier|volatile
name|u_long
operator|*
operator|*
operator|)
operator|&
name|dma_prog
argument_list|,
name|bktr
operator|->
name|yclip2
operator|-
name|bktr
operator|->
name|yclip
argument_list|,
name|OP_SKIP
argument_list|,
name|Bpp
argument_list|,
operator|(
specifier|volatile
name|u_char
operator|*
operator|*
operator|)
operator|&
name|target
argument_list|,
name|cols
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|target_buffer
operator|+=
name|interlace
operator|*
name|pitch
expr_stmt|;
block|}
switch|switch
condition|(
name|i_flag
condition|)
block|{
case|case
literal|1
case|:
comment|/* sync vre */
operator|*
name|dma_prog
operator|++
operator|=
name|OP_SYNC
operator||
literal|0xC
operator|<<
literal|24
operator||
literal|1
operator|<<
literal|24
operator||
name|BKTR_VRE
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* NULL WORD */
operator|*
name|dma_prog
operator|++
operator|=
name|OP_JUMP
operator||
literal|0xC
operator|<<
literal|24
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
operator|(
name|u_long
operator|)
name|vtophys
argument_list|(
name|bktr
operator|->
name|dma_prog
argument_list|)
expr_stmt|;
return|return;
case|case
literal|2
case|:
comment|/* sync vro */
operator|*
name|dma_prog
operator|++
operator|=
name|OP_SYNC
operator||
literal|1
operator|<<
literal|24
operator||
literal|1
operator|<<
literal|20
operator||
name|BKTR_VRO
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* NULL WORD */
operator|*
name|dma_prog
operator|++
operator|=
name|OP_JUMP
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
operator|(
name|u_long
operator|)
name|vtophys
argument_list|(
name|bktr
operator|->
name|dma_prog
argument_list|)
expr_stmt|;
return|return;
case|case
literal|3
case|:
comment|/* sync vro */
operator|*
name|dma_prog
operator|++
operator|=
name|OP_SYNC
operator||
literal|1
operator|<<
literal|24
operator||
literal|1
operator|<<
literal|15
operator||
name|BKTR_VRO
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* NULL WORD */
operator|*
name|dma_prog
operator|++
operator|=
name|OP_JUMP
operator||
literal|0xc
operator|<<
literal|24
expr_stmt|;
operator|*
name|dma_prog
operator|=
operator|(
name|u_long
operator|)
name|vtophys
argument_list|(
name|bktr
operator|->
name|odd_dma_prog
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|interlace
operator|==
literal|2
condition|)
block|{
if|if
condition|(
name|rows
operator|<
literal|320
condition|)
name|target_buffer
operator|=
name|buffer
expr_stmt|;
else|else
name|target_buffer
operator|=
name|buffer
operator|+
name|pitch
expr_stmt|;
name|dma_prog
operator|=
operator|(
name|u_long
operator|*
operator|)
name|bktr
operator|->
name|odd_dma_prog
expr_stmt|;
comment|/* sync vre IRQ bit */
operator|*
name|dma_prog
operator|++
operator|=
name|OP_SYNC
operator||
literal|1
operator|<<
literal|15
operator||
name|BKTR_FM1
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* NULL WORD */
name|width
operator|=
name|cols
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|rows
operator|/
name|interlace
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|target
operator|=
name|target_buffer
expr_stmt|;
if|if
condition|(
name|notclipped
argument_list|(
name|bktr
argument_list|,
name|i
argument_list|,
name|width
argument_list|)
condition|)
block|{
name|split
argument_list|(
name|bktr
argument_list|,
operator|(
specifier|volatile
name|u_long
operator|*
operator|*
operator|)
operator|&
name|dma_prog
argument_list|,
name|bktr
operator|->
name|y2
operator|-
name|bktr
operator|->
name|y
argument_list|,
name|OP_WRITE
argument_list|,
name|Bpp
argument_list|,
operator|(
specifier|volatile
name|u_char
operator|*
operator|*
operator|)
operator|&
name|target
argument_list|,
name|cols
argument_list|)
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
name|getline
argument_list|(
name|bktr
argument_list|,
name|i
argument_list|)
condition|)
block|{
if|if
condition|(
name|bktr
operator|->
name|y
operator|!=
name|bktr
operator|->
name|y2
condition|)
block|{
name|split
argument_list|(
name|bktr
argument_list|,
operator|(
specifier|volatile
name|u_long
operator|*
operator|*
operator|)
operator|&
name|dma_prog
argument_list|,
name|bktr
operator|->
name|y2
operator|-
name|bktr
operator|->
name|y
argument_list|,
name|OP_WRITE
argument_list|,
name|Bpp
argument_list|,
operator|(
specifier|volatile
name|u_char
operator|*
operator|*
operator|)
operator|&
name|target
argument_list|,
name|cols
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bktr
operator|->
name|yclip
operator|!=
name|bktr
operator|->
name|yclip2
condition|)
block|{
name|split
argument_list|(
name|bktr
argument_list|,
operator|(
specifier|volatile
name|u_long
operator|*
operator|*
operator|)
operator|&
name|dma_prog
argument_list|,
name|bktr
operator|->
name|yclip2
operator|-
name|bktr
operator|->
name|yclip
argument_list|,
name|OP_SKIP
argument_list|,
name|Bpp
argument_list|,
operator|(
specifier|volatile
name|u_char
operator|*
operator|*
operator|)
operator|&
name|target
argument_list|,
name|cols
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|target_buffer
operator|+=
name|interlace
operator|*
name|pitch
expr_stmt|;
block|}
block|}
comment|/* sync vre IRQ bit */
operator|*
name|dma_prog
operator|++
operator|=
name|OP_SYNC
operator||
literal|1
operator|<<
literal|24
operator||
literal|1
operator|<<
literal|15
operator||
name|BKTR_VRE
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* NULL WORD */
operator|*
name|dma_prog
operator|++
operator|=
name|OP_JUMP
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
operator|(
name|u_long
operator|)
name|vtophys
argument_list|(
name|bktr
operator|->
name|dma_prog
argument_list|)
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* NULL WORD */
block|}
end_function

begin_comment
comment|/*  *   */
end_comment

begin_function
specifier|static
name|void
name|yuvpack_prog
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|,
name|char
name|i_flag
parameter_list|,
name|int
name|cols
parameter_list|,
name|int
name|rows
parameter_list|,
name|int
name|interlace
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|byte_count
decl_stmt|;
specifier|volatile
name|unsigned
name|int
name|inst
decl_stmt|;
specifier|volatile
name|unsigned
name|int
name|inst3
decl_stmt|;
specifier|volatile
name|u_long
name|target_buffer
decl_stmt|,
name|buffer
decl_stmt|;
name|bt848_ptr_t
name|bt848
decl_stmt|;
specifier|volatile
name|u_long
modifier|*
name|dma_prog
decl_stmt|;
name|int
name|b
decl_stmt|;
name|bt848
operator|=
name|bktr
operator|->
name|base
expr_stmt|;
comment|/* color format : yuvpack */
name|bt848
operator|->
name|color_fmt
operator|=
literal|0x44
expr_stmt|;
name|bt848
operator|->
name|e_scloop
operator||=
name|BT848_E_SCLOOP_CAGC
expr_stmt|;
comment|/* enable chroma comb */
name|bt848
operator|->
name|o_scloop
operator||=
name|BT848_O_SCLOOP_CAGC
expr_stmt|;
name|bt848
operator|->
name|color_ctl_rgb_ded
operator|=
literal|1
expr_stmt|;
name|bt848
operator|->
name|color_ctl_gamma
operator|=
literal|1
expr_stmt|;
name|bt848
operator|->
name|adc
operator|=
name|SYNC_LEVEL
expr_stmt|;
name|bktr
operator|->
name|capcontrol
operator|=
literal|1
operator|<<
literal|6
operator||
literal|1
operator|<<
literal|4
operator||
literal|1
operator|<<
literal|2
operator||
literal|3
expr_stmt|;
name|bktr
operator|->
name|capcontrol
operator|=
literal|1
operator|<<
literal|5
operator||
literal|1
operator|<<
literal|4
operator||
literal|1
operator|<<
literal|2
operator||
literal|3
expr_stmt|;
name|dma_prog
operator|=
operator|(
name|u_long
operator|*
operator|)
name|bktr
operator|->
name|dma_prog
expr_stmt|;
comment|/* Construct Write */
name|bt_enable_cnt
operator|=
literal|0
expr_stmt|;
comment|/* write , sol, eol */
name|inst
operator|=
name|OP_WRITE
operator||
name|OP_SOL
operator||
literal|0xf
operator|<<
literal|16
operator||
name|bt_enable_cnt
operator|<<
literal|12
operator||
operator|(
name|cols
operator|*
literal|2
operator|)
expr_stmt|;
comment|/* write , sol, eol */
name|inst3
operator|=
name|OP_WRITE
operator||
name|OP_EOL
operator||
literal|0xf
operator|<<
literal|16
operator||
name|bt_enable_cnt
operator|<<
literal|12
operator||
operator|(
name|cols
operator|)
expr_stmt|;
if|if
condition|(
name|bktr
operator|->
name|video
operator|.
name|addr
condition|)
name|target_buffer
operator|=
operator|(
name|u_long
operator|)
name|bktr
operator|->
name|video
operator|.
name|addr
expr_stmt|;
else|else
name|target_buffer
operator|=
operator|(
name|u_long
operator|)
name|vtophys
argument_list|(
name|bktr
operator|->
name|bigbuf
argument_list|)
expr_stmt|;
name|buffer
operator|=
name|target_buffer
expr_stmt|;
comment|/* contruct sync : for video packet format */
comment|/* sync, mode indicator packed data */
operator|*
name|dma_prog
operator|++
operator|=
name|OP_SYNC
operator||
literal|1
operator|<<
literal|24
operator||
literal|1
operator|<<
literal|15
operator||
name|BKTR_FM1
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* NULL WORD */
name|b
operator|=
name|cols
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|rows
operator|/
name|interlace
operator|)
condition|;
name|i
operator|++
control|)
block|{
operator|*
name|dma_prog
operator|++
operator|=
name|inst
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
name|target_buffer
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
name|inst3
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
name|target_buffer
operator|+
name|b
expr_stmt|;
name|target_buffer
operator|+=
name|interlace
operator|*
operator|(
name|cols
operator|*
literal|2
operator|)
expr_stmt|;
block|}
switch|switch
condition|(
name|i_flag
condition|)
block|{
case|case
literal|1
case|:
comment|/* sync vre */
operator|*
name|dma_prog
operator|++
operator|=
name|OP_SYNC
operator||
literal|1
operator|<<
literal|24
operator||
name|BKTR_VRE
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* NULL WORD */
operator|*
name|dma_prog
operator|++
operator|=
name|OP_JUMP
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
operator|(
name|u_long
operator|)
name|vtophys
argument_list|(
name|bktr
operator|->
name|dma_prog
argument_list|)
expr_stmt|;
return|return;
case|case
literal|2
case|:
comment|/* sync vro */
operator|*
name|dma_prog
operator|++
operator|=
name|OP_SYNC
operator||
literal|1
operator|<<
literal|24
operator||
literal|1
operator|<<
literal|20
operator||
name|BKTR_VRO
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* NULL WORD */
operator|*
name|dma_prog
operator|++
operator|=
name|OP_JUMP
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
operator|(
name|u_long
operator|)
name|vtophys
argument_list|(
name|bktr
operator|->
name|dma_prog
argument_list|)
expr_stmt|;
return|return;
case|case
literal|3
case|:
comment|/* sync vre */
operator|*
name|dma_prog
operator|++
operator|=
name|OP_SYNC
operator||
literal|1
operator|<<
literal|24
operator||
literal|0xf
operator|<<
literal|16
operator||
name|BKTR_VRE
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* NULL WORD */
operator|*
name|dma_prog
operator|++
operator|=
name|OP_JUMP
expr_stmt|;
operator|*
name|dma_prog
operator|=
operator|(
name|u_long
operator|)
name|vtophys
argument_list|(
name|bktr
operator|->
name|odd_dma_prog
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|interlace
operator|==
literal|2
condition|)
block|{
name|target_buffer
operator|=
operator|(
name|u_long
operator|)
name|buffer
operator|+
name|cols
operator|*
literal|2
expr_stmt|;
name|dma_prog
operator|=
operator|(
name|u_long
operator|*
operator|)
name|bktr
operator|->
name|odd_dma_prog
expr_stmt|;
comment|/* sync vre */
operator|*
name|dma_prog
operator|++
operator|=
name|OP_SYNC
operator||
literal|1
operator|<<
literal|24
operator||
literal|0xf
operator|<<
literal|16
operator||
literal|1
operator|<<
literal|15
operator||
name|BKTR_FM1
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* NULL WORD */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|rows
operator|/
name|interlace
operator|)
condition|;
name|i
operator|++
control|)
block|{
operator|*
name|dma_prog
operator|++
operator|=
name|inst
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
name|target_buffer
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
name|inst3
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
name|target_buffer
operator|+
name|b
expr_stmt|;
name|target_buffer
operator|+=
name|interlace
operator|*
operator|(
name|cols
operator|*
literal|2
operator|)
expr_stmt|;
block|}
block|}
comment|/* sync vro IRQ bit */
operator|*
name|dma_prog
operator|++
operator|=
name|OP_SYNC
operator||
literal|1
operator|<<
literal|24
operator||
literal|0xf
operator|<<
literal|16
operator||
name|BKTR_VRO
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* NULL WORD */
operator|*
name|dma_prog
operator|++
operator|=
name|OP_JUMP
operator||
literal|0xf
operator|<<
literal|16
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
operator|(
name|u_long
operator|)
name|vtophys
argument_list|(
name|bktr
operator|->
name|dma_prog
argument_list|)
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
name|OP_JUMP
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
operator|(
name|u_long
operator|)
name|vtophys
argument_list|(
name|bktr
operator|->
name|dma_prog
argument_list|)
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* NULL WORD */
block|}
end_function

begin_comment
comment|/*  *   */
end_comment

begin_function
specifier|static
name|void
name|yuv422_prog
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|,
name|char
name|i_flag
parameter_list|,
name|int
name|cols
parameter_list|,
name|int
name|rows
parameter_list|,
name|int
name|interlace
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|int
name|byte_count
decl_stmt|;
specifier|volatile
name|unsigned
name|int
name|inst
decl_stmt|;
specifier|volatile
name|unsigned
name|int
name|instskip
decl_stmt|,
name|instskip2
decl_stmt|,
name|instskip3
decl_stmt|;
specifier|volatile
name|unsigned
name|int
name|inst3
decl_stmt|;
specifier|volatile
name|u_long
name|target_buffer
decl_stmt|,
name|t1
decl_stmt|,
name|buffer
decl_stmt|;
name|bt848_ptr_t
name|bt848
decl_stmt|;
specifier|volatile
name|u_long
modifier|*
name|dma_prog
decl_stmt|;
name|int
name|b
decl_stmt|,
name|b1
decl_stmt|;
name|bt848
operator|=
name|bktr
operator|->
name|base
expr_stmt|;
name|dma_prog
operator|=
operator|(
name|u_long
operator|*
operator|)
name|bktr
operator|->
name|dma_prog
expr_stmt|;
name|bktr
operator|->
name|capcontrol
operator|=
literal|1
operator|<<
literal|6
operator||
literal|1
operator|<<
literal|4
operator||
literal|3
expr_stmt|;
name|bt848
operator|->
name|adc
operator|=
name|SYNC_LEVEL
expr_stmt|;
name|bt848
operator|->
name|oform
operator|=
literal|0x00
expr_stmt|;
name|bt848
operator|->
name|e_control
operator||=
name|BT848_E_CONTROL_LDEC
expr_stmt|;
comment|/* disable luma decimation */
name|bt848
operator|->
name|o_control
operator||=
name|BT848_O_CONTROL_LDEC
expr_stmt|;
name|bt848
operator|->
name|e_scloop
operator||=
name|BT848_O_SCLOOP_CAGC
expr_stmt|;
comment|/* chroma agc enable */
name|bt848
operator|->
name|o_scloop
operator||=
name|BT848_O_SCLOOP_CAGC
expr_stmt|;
name|bt848
operator|->
name|e_vscale_hi
operator||=
literal|0xc0
expr_stmt|;
comment|/* luma comb and comb enable */
name|bt848
operator|->
name|o_vscale_hi
operator||=
literal|0xc0
expr_stmt|;
name|bt848
operator|->
name|color_fmt
operator|=
literal|0x88
expr_stmt|;
comment|/* disable gamma correction removal */
name|bt848
operator|->
name|color_ctl_gamma
operator|=
literal|1
expr_stmt|;
name|bt_enable_cnt
operator|=
literal|0
expr_stmt|;
comment|/* Construct Write */
name|inst
operator|=
name|OP_WRITE123
operator||
name|OP_SOL
operator||
name|OP_EOL
operator||
name|bt_enable_cnt
operator|<<
literal|12
operator||
operator|(
name|cols
operator|)
expr_stmt|;
if|if
condition|(
name|bktr
operator|->
name|video
operator|.
name|addr
condition|)
name|target_buffer
operator|=
operator|(
name|u_long
operator|)
name|bktr
operator|->
name|video
operator|.
name|addr
expr_stmt|;
else|else
name|target_buffer
operator|=
operator|(
name|u_long
operator|)
name|vtophys
argument_list|(
name|bktr
operator|->
name|bigbuf
argument_list|)
expr_stmt|;
name|buffer
operator|=
name|target_buffer
expr_stmt|;
name|t1
operator|=
name|target_buffer
expr_stmt|;
comment|/* contruct sync : for video packet format */
operator|*
name|dma_prog
operator|++
operator|=
name|OP_SYNC
operator||
literal|1
operator|<<
literal|15
operator||
name|BKTR_FM3
expr_stmt|;
comment|/*sync, mode indicator packed data*/
operator|*
name|dma_prog
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* NULL WORD */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|rows
operator|/
name|interlace
operator|)
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
operator|*
name|dma_prog
operator|++
operator|=
name|inst
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
name|cols
operator|/
literal|2
operator||
name|cols
operator|/
literal|2
operator|<<
literal|16
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
name|target_buffer
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
name|t1
operator|+
operator|(
name|cols
operator|*
name|rows
operator|)
operator|+
name|i
operator|*
name|cols
operator|/
literal|2
operator|*
name|interlace
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
name|t1
operator|+
operator|(
name|cols
operator|*
name|rows
operator|)
operator|+
operator|(
name|cols
operator|*
name|rows
operator|/
literal|2
operator|)
operator|+
name|i
operator|*
name|cols
operator|/
literal|2
operator|*
name|interlace
expr_stmt|;
name|target_buffer
operator|+=
name|interlace
operator|*
name|cols
expr_stmt|;
block|}
switch|switch
condition|(
name|i_flag
condition|)
block|{
case|case
literal|1
case|:
operator|*
name|dma_prog
operator|++
operator|=
name|OP_SYNC
operator||
literal|0xC
operator|<<
literal|24
operator||
literal|1
operator|<<
literal|24
operator||
name|BKTR_VRE
expr_stmt|;
comment|/*sync vre*/
operator|*
name|dma_prog
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* NULL WORD */
operator|*
name|dma_prog
operator|++
operator|=
name|OP_JUMP
operator||
literal|0xc
operator|<<
literal|24
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
operator|(
name|u_long
operator|)
name|vtophys
argument_list|(
name|bktr
operator|->
name|dma_prog
argument_list|)
expr_stmt|;
return|return;
case|case
literal|2
case|:
operator|*
name|dma_prog
operator|++
operator|=
name|OP_SYNC
operator||
literal|0xC
operator|<<
literal|24
operator||
literal|1
operator|<<
literal|24
operator||
name|BKTR_VRO
expr_stmt|;
comment|/*sync vre*/
operator|*
name|dma_prog
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* NULL WORD */
operator|*
name|dma_prog
operator|++
operator|=
name|OP_JUMP
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
operator|(
name|u_long
operator|)
name|vtophys
argument_list|(
name|bktr
operator|->
name|dma_prog
argument_list|)
expr_stmt|;
return|return;
case|case
literal|3
case|:
operator|*
name|dma_prog
operator|++
operator|=
name|OP_SYNC
operator||
literal|1
operator|<<
literal|15
operator||
name|BKTR_VRO
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* NULL WORD */
operator|*
name|dma_prog
operator|++
operator|=
name|OP_JUMP
expr_stmt|;
operator|*
name|dma_prog
operator|=
operator|(
name|u_long
operator|)
name|vtophys
argument_list|(
name|bktr
operator|->
name|odd_dma_prog
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|interlace
operator|==
literal|2
condition|)
block|{
name|dma_prog
operator|=
operator|(
name|u_long
operator|*
operator|)
name|bktr
operator|->
name|odd_dma_prog
expr_stmt|;
name|target_buffer
operator|=
operator|(
name|u_long
operator|)
name|buffer
operator|+
name|cols
expr_stmt|;
name|t1
operator|=
name|target_buffer
operator|+
name|cols
operator|/
literal|2
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
name|OP_SYNC
operator||
literal|1
operator|<<
literal|15
operator||
name|BKTR_FM3
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* NULL WORD */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|rows
operator|/
name|interlace
operator|)
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
operator|*
name|dma_prog
operator|++
operator|=
name|inst
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
name|cols
operator|/
literal|2
operator||
name|cols
operator|/
literal|2
operator|<<
literal|16
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
name|target_buffer
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
name|t1
operator|+
operator|(
name|cols
operator|*
name|rows
operator|)
operator|+
name|i
operator|*
name|cols
operator|/
literal|2
operator|*
name|interlace
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
name|t1
operator|+
operator|(
name|cols
operator|*
name|rows
operator|)
operator|+
operator|(
name|cols
operator|*
name|rows
operator|/
literal|2
operator|)
operator|+
name|i
operator|*
name|cols
operator|/
literal|2
operator|*
name|interlace
expr_stmt|;
name|target_buffer
operator|+=
name|interlace
operator|*
name|cols
expr_stmt|;
block|}
block|}
operator|*
name|dma_prog
operator|++
operator|=
name|OP_SYNC
operator||
literal|1
operator|<<
literal|24
operator||
name|BKTR_VRE
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* NULL WORD */
operator|*
name|dma_prog
operator|++
operator|=
name|OP_JUMP
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
operator|(
name|u_long
operator|)
name|vtophys
argument_list|(
name|bktr
operator|->
name|dma_prog
argument_list|)
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* NULL WORD */
block|}
end_function

begin_comment
comment|/*  *   */
end_comment

begin_function
specifier|static
name|void
name|build_dma_prog
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|,
name|char
name|i_flag
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|rows
decl_stmt|,
name|cols
decl_stmt|,
name|byte_count
decl_stmt|,
name|interlace
decl_stmt|;
specifier|volatile
name|unsigned
name|int
name|inst
decl_stmt|;
specifier|volatile
name|unsigned
name|int
name|inst3
decl_stmt|;
specifier|volatile
name|u_long
name|target_buffer
decl_stmt|;
name|bt848_ptr_t
name|bt848
decl_stmt|;
specifier|volatile
name|u_long
modifier|*
name|dma_prog
decl_stmt|;
name|int
name|b
decl_stmt|;
name|struct
name|meteor_pixfmt_internal
modifier|*
name|pf_int
init|=
operator|&
name|pixfmt_table
index|[
name|bktr
operator|->
name|pixfmt
index|]
decl_stmt|;
name|bt848
operator|=
name|bktr
operator|->
name|base
expr_stmt|;
name|bt848
operator|->
name|int_mask
operator|=
name|ALL_INTS_DISABLED
expr_stmt|;
comment|/* disable FIFO& RISC, leave other bits alone */
name|bt848
operator|->
name|gpio_dma_ctl
operator|&=
operator|~
name|FIFO_RISC_ENABLED
expr_stmt|;
comment|/* capture control */
switch|switch
condition|(
name|i_flag
condition|)
block|{
case|case
literal|1
case|:
name|bktr
operator|->
name|bktr_cap_ctl
operator|=
operator|(
name|BT848_CAP_CTL_DITH_FRAME
operator||
name|BT848_CAP_CTL_EVEN
operator|)
expr_stmt|;
name|bt848
operator|->
name|e_vscale_hi
operator|&=
operator|~
literal|0x20
expr_stmt|;
name|bt848
operator|->
name|o_vscale_hi
operator|&=
operator|~
literal|0x20
expr_stmt|;
name|interlace
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|bktr
operator|->
name|bktr_cap_ctl
operator|=
operator|(
name|BT848_CAP_CTL_DITH_FRAME
operator||
name|BT848_CAP_CTL_ODD
operator|)
expr_stmt|;
name|bt848
operator|->
name|e_vscale_hi
operator|&=
operator|~
literal|0x20
expr_stmt|;
name|bt848
operator|->
name|o_vscale_hi
operator|&=
operator|~
literal|0x20
expr_stmt|;
name|interlace
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
name|bktr
operator|->
name|bktr_cap_ctl
operator|=
operator|(
name|BT848_CAP_CTL_DITH_FRAME
operator||
name|BT848_CAP_CTL_EVEN
operator||
name|BT848_CAP_CTL_ODD
operator|)
expr_stmt|;
name|bt848
operator|->
name|e_vscale_hi
operator||=
literal|0x20
expr_stmt|;
name|bt848
operator|->
name|o_vscale_hi
operator||=
literal|0x20
expr_stmt|;
name|interlace
operator|=
literal|2
expr_stmt|;
break|break;
block|}
name|bt848
operator|->
name|risc_strt_add
operator|=
name|vtophys
argument_list|(
name|bktr
operator|->
name|dma_prog
argument_list|)
expr_stmt|;
name|rows
operator|=
name|bktr
operator|->
name|rows
expr_stmt|;
name|cols
operator|=
name|bktr
operator|->
name|cols
expr_stmt|;
if|if
condition|(
name|pf_int
operator|->
name|public
operator|.
name|type
operator|==
name|METEOR_PIXTYPE_RGB
condition|)
block|{
name|rgb_prog
argument_list|(
name|bktr
argument_list|,
name|i_flag
argument_list|,
name|cols
argument_list|,
name|rows
argument_list|,
name|interlace
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/*  FIXME:  The YUV stuff needs added to the pixfmt table  */
if|if
condition|(
name|bktr
operator|->
name|format
operator|==
name|METEOR_GEO_YUV_422
condition|)
block|{
name|yuv422_prog
argument_list|(
name|bktr
argument_list|,
name|i_flag
argument_list|,
name|cols
argument_list|,
name|rows
argument_list|,
name|interlace
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|bktr
operator|->
name|format
operator|==
name|METEOR_GEO_YUV_PACKED
condition|)
block|{
name|yuvpack_prog
argument_list|(
name|bktr
argument_list|,
name|i_flag
argument_list|,
name|cols
argument_list|,
name|rows
argument_list|,
name|interlace
argument_list|)
expr_stmt|;
return|return;
block|}
return|return;
block|}
end_function

begin_comment
comment|/******************************************************************************  * video& video capture specific routines:  */
end_comment

begin_comment
comment|/*  *   */
end_comment

begin_function
specifier|static
name|void
name|start_capture
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|,
name|unsigned
name|type
parameter_list|)
block|{
name|bt848_ptr_t
name|bt848
decl_stmt|;
name|u_char
name|i_flag
decl_stmt|;
name|bt848
operator|=
name|bktr
operator|->
name|base
expr_stmt|;
name|bt848
operator|->
name|dstatus
operator|=
literal|0
expr_stmt|;
name|bt848
operator|->
name|int_stat
operator|=
name|bt848
operator|->
name|int_stat
expr_stmt|;
name|bktr
operator|->
name|flags
operator||=
name|type
expr_stmt|;
switch|switch
condition|(
name|bktr
operator|->
name|flags
operator|&
name|METEOR_ONLY_FIELDS_MASK
condition|)
block|{
case|case
name|METEOR_ONLY_EVEN_FIELDS
case|:
name|bktr
operator|->
name|flags
operator||=
name|METEOR_WANT_EVEN
expr_stmt|;
name|i_flag
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|METEOR_ONLY_ODD_FIELDS
case|:
name|bktr
operator|->
name|flags
operator||=
name|METEOR_WANT_ODD
expr_stmt|;
name|i_flag
operator|=
literal|2
expr_stmt|;
break|break;
default|default:
name|bktr
operator|->
name|flags
operator||=
name|METEOR_WANT_MASK
expr_stmt|;
name|i_flag
operator|=
literal|3
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|bktr
operator|->
name|dma_prog_loaded
operator|==
name|FALSE
condition|)
block|{
name|build_dma_prog
argument_list|(
name|bktr
argument_list|,
name|i_flag
argument_list|)
expr_stmt|;
name|bktr
operator|->
name|dma_prog_loaded
operator|=
name|TRUE
expr_stmt|;
block|}
comment|/* XXX: 	switch (bktr->flags& METEOR_ONLY_FIELDS_MASK) { 	default: 		*bts_reg |= 0xb;   bts_reg never been initialized! 	}  */
name|bt848
operator|->
name|risc_strt_add
operator|=
name|vtophys
argument_list|(
name|bktr
operator|->
name|dma_prog
argument_list|)
expr_stmt|;
comment|/* XXX: 	bt848->gpio_dma_ctl = FIFO_RISC_ENABLED;  */
block|}
end_function

begin_comment
comment|/*  *   */
end_comment

begin_function
specifier|static
name|void
name|set_fps
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|,
name|u_short
name|fps
parameter_list|)
block|{
name|bt848_ptr_t
name|bt848
decl_stmt|;
name|bt848
operator|=
name|bktr
operator|->
name|base
expr_stmt|;
name|bt848
operator|->
name|gpio_dma_ctl
operator|=
name|FIFO_RISC_DISABLED
expr_stmt|;
name|bt848
operator|->
name|int_stat
operator|=
name|ALL_INTS_CLEARED
expr_stmt|;
name|bktr
operator|->
name|fps
operator|=
name|fps
expr_stmt|;
if|if
condition|(
name|fps
operator|==
literal|30
condition|)
block|{
name|bt848
operator|->
name|tdec
operator|=
literal|0
expr_stmt|;
return|return;
block|}
else|else
block|{
name|bt848
operator|->
name|tdec
operator|=
call|(
name|int
call|)
argument_list|(
operator|(
operator|(
name|float
operator|)
name|fps
operator|/
literal|30.0
operator|)
operator|*
literal|60.0
argument_list|)
operator|&
literal|0x3f
expr_stmt|;
name|bt848
operator|->
name|tdec
operator||=
literal|0x80
expr_stmt|;
block|}
if|if
condition|(
name|bktr
operator|->
name|flags
operator|&
name|METEOR_CAP_MASK
condition|)
block|{
name|bt848
operator|->
name|int_stat
operator|=
name|ALL_INTS_CLEARED
expr_stmt|;
name|bt848
operator|->
name|risc_strt_add
operator|=
name|vtophys
argument_list|(
name|bktr
operator|->
name|dma_prog
argument_list|)
expr_stmt|;
name|bt848
operator|->
name|gpio_dma_ctl
operator|=
name|FIFO_ENABLED
expr_stmt|;
name|bt848
operator|->
name|gpio_dma_ctl
operator|=
name|bktr
operator|->
name|capcontrol
expr_stmt|;
name|bt848
operator|->
name|int_mask
operator|=
name|BT848_INT_MYSTERYBIT
operator||
name|BT848_INT_RISCI
operator||
name|BT848_INT_VSYNC
operator||
name|BT848_INT_FMTCHG
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/*  * There is also a problem with range checking on the 7116.  * It seems to only work for 22 bits, so the max size we can allocate  * is 22 bits long or 4194304 bytes assuming that we put the beginning  * of the buffer on a 2^24 bit boundary.  The range registers will use  * the top 8 bits of the dma start registers along with the bottom 22  * bits of the range register to determine if we go out of range.  * This makes getting memory a real kludge.  *  */
end_comment

begin_define
define|#
directive|define
name|RANGE_BOUNDARY
value|(1<<22)
end_define

begin_function
specifier|static
name|vm_offset_t
name|get_bktr_mem
parameter_list|(
name|int
name|unit
parameter_list|,
name|unsigned
name|size
parameter_list|)
block|{
name|vm_offset_t
name|addr
init|=
literal|0
decl_stmt|;
name|addr
operator|=
name|vm_page_alloc_contig
argument_list|(
name|size
argument_list|,
literal|0x100000
argument_list|,
literal|0xffffffff
argument_list|,
literal|1
operator|<<
literal|24
argument_list|)
expr_stmt|;
if|if
condition|(
name|addr
operator|==
literal|0
condition|)
name|addr
operator|=
name|vm_page_alloc_contig
argument_list|(
name|size
argument_list|,
literal|0x100000
argument_list|,
literal|0xffffffff
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|addr
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"meteor%d: Unable to allocate %d bytes of memory.\n"
argument_list|,
name|unit
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|addr
operator|)
return|;
block|}
end_function

begin_comment
comment|/*   * Given a pixfmt index, compute the bt848 swap_flags necessary to   *   achieve the specified swapping.  * Note that without bt swapping, 2Bpp and 3Bpp modes are written   *   byte-swapped, and 4Bpp modes are byte and word swapped (see Table 6   *   and read R->L).    * This is abstracted here: e.g. no swaps = RGBA; byte& short swap = ABGR  *   as one would expect.  */
end_comment

begin_function
specifier|static
name|u_int
name|pixfmt_swap_flags
parameter_list|(
name|int
name|pixfmt
parameter_list|)
block|{
name|struct
name|meteor_pixfmt
modifier|*
name|pf
init|=
operator|&
name|pixfmt_table
index|[
name|pixfmt
index|]
operator|.
name|public
decl_stmt|;
name|u_int
name|swapf
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|pf
operator|->
name|Bpp
condition|)
block|{
case|case
literal|2
case|:
name|swapf
operator|=
operator|(
name|pf
operator|->
name|swap_bytes
condition|?
literal|0
else|:
name|BSWAP
operator|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
comment|/* no swaps supported for 3bpp - makes no sense w/ bt848 */
break|break;
case|case
literal|4
case|:
if|if
condition|(
name|pf
operator|->
name|swap_bytes
condition|)
name|swapf
operator|=
name|pf
operator|->
name|swap_shorts
condition|?
literal|0
else|:
name|WSWAP
expr_stmt|;
else|else
name|swapf
operator|=
name|pf
operator|->
name|swap_shorts
condition|?
name|BSWAP
else|:
operator|(
name|BSWAP
operator||
name|WSWAP
operator|)
expr_stmt|;
break|break;
block|}
return|return
name|swapf
return|;
block|}
end_function

begin_comment
comment|/*   * Converts meteor-defined pixel formats (e.g. METEOR_GEO_RGB16) into  *   our pixfmt_table indices.  */
end_comment

begin_function
specifier|static
name|int
name|oformat_meteor_to_bt
parameter_list|(
name|u_long
name|format
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|meteor_pixfmt
modifier|*
name|pf1
decl_stmt|,
modifier|*
name|pf2
decl_stmt|;
comment|/*  Find format in compatibility table  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|METEOR_PIXFMT_TABLE_SIZE
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|meteor_pixfmt_table
index|[
name|i
index|]
operator|.
name|meteor_format
operator|==
name|format
condition|)
break|break;
if|if
condition|(
name|i
operator|>=
name|METEOR_PIXFMT_TABLE_SIZE
condition|)
return|return
operator|-
literal|1
return|;
name|pf1
operator|=
operator|&
name|meteor_pixfmt_table
index|[
name|i
index|]
operator|.
name|public
expr_stmt|;
comment|/*  Match it with an entry in master pixel format table  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|PIXFMT_TABLE_SIZE
condition|;
name|i
operator|++
control|)
block|{
name|pf2
operator|=
operator|&
name|pixfmt_table
index|[
name|i
index|]
operator|.
name|public
expr_stmt|;
if|if
condition|(
operator|(
name|pf1
operator|->
name|type
operator|==
name|pf2
operator|->
name|type
operator|)
operator|&&
operator|(
name|pf1
operator|->
name|Bpp
operator|==
name|pf2
operator|->
name|Bpp
operator|)
operator|&&
operator|!
name|memcmp
argument_list|(
name|pf1
operator|->
name|masks
argument_list|,
name|pf2
operator|->
name|masks
argument_list|,
sizeof|sizeof
argument_list|(
name|pf1
operator|->
name|masks
argument_list|)
argument_list|)
operator|&&
operator|(
name|pf1
operator|->
name|swap_bytes
operator|==
name|pf2
operator|->
name|swap_bytes
operator|)
operator|&&
operator|(
name|pf1
operator|->
name|swap_shorts
operator|==
name|pf2
operator|->
name|swap_shorts
operator|)
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|>=
name|PIXFMT_TABLE_SIZE
condition|)
return|return
operator|-
literal|1
return|;
return|return
name|i
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************  * i2c primitives:  */
end_comment

begin_comment
comment|/* */
end_comment

begin_define
define|#
directive|define
name|I2CBITTIME
value|(0x5<<4)
end_define

begin_comment
comment|/* 5 * 0.48uS */
end_comment

begin_define
define|#
directive|define
name|I2C_READ
value|0x01
end_define

begin_define
define|#
directive|define
name|I2C_COMMAND
value|(I2CBITTIME |			\ 				 BT848_DATA_CTL_I2CSCL |	\ 				 BT848_DATA_CTL_I2CSDA)
end_define

begin_comment
comment|/*  *   */
end_comment

begin_function
specifier|static
name|int
name|i2cWrite
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|,
name|int
name|addr
parameter_list|,
name|int
name|byte1
parameter_list|,
name|int
name|byte2
parameter_list|)
block|{
name|u_long
name|x
decl_stmt|;
name|u_long
name|data
decl_stmt|;
name|bt848_ptr_t
name|bt848
decl_stmt|;
name|bt848
operator|=
name|bktr
operator|->
name|base
expr_stmt|;
comment|/* clear status bits */
name|bt848
operator|->
name|int_stat
operator|=
operator|(
name|BT848_INT_RACK
operator||
name|BT848_INT_I2CDONE
operator|)
expr_stmt|;
comment|/* build the command datum */
name|data
operator|=
operator|(
operator|(
name|addr
operator|&
literal|0xff
operator|)
operator|<<
literal|24
operator|)
operator||
operator|(
operator|(
name|byte1
operator|&
literal|0xff
operator|)
operator|<<
literal|16
operator|)
operator||
name|I2C_COMMAND
expr_stmt|;
if|if
condition|(
name|byte2
operator|!=
operator|-
literal|1
condition|)
block|{
name|data
operator||=
operator|(
operator|(
name|byte2
operator|&
literal|0xff
operator|)
operator|<<
literal|8
operator|)
expr_stmt|;
name|data
operator||=
name|BT848_DATA_CTL_I2CW3B
expr_stmt|;
block|}
comment|/* write the address and data */
name|bt848
operator|->
name|i2c_data_ctl
operator|=
name|data
expr_stmt|;
comment|/* wait for completion */
for|for
control|(
name|x
operator|=
literal|0x7fffffff
init|;
name|x
condition|;
operator|--
name|x
control|)
block|{
comment|/* safety valve */
if|if
condition|(
name|bt848
operator|->
name|int_stat
operator|&
name|BT848_INT_I2CDONE
condition|)
break|break;
block|}
comment|/* check for ACK */
if|if
condition|(
operator|!
name|x
operator|||
operator|!
operator|(
name|bt848
operator|->
name|int_stat
operator|&
name|BT848_INT_RACK
operator|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* return OK */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *   */
end_comment

begin_function
specifier|static
name|int
name|i2cRead
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|,
name|int
name|addr
parameter_list|)
block|{
name|u_long
name|x
decl_stmt|;
name|bt848_ptr_t
name|bt848
decl_stmt|;
name|bt848
operator|=
name|bktr
operator|->
name|base
expr_stmt|;
comment|/* clear status bits */
name|bt848
operator|->
name|int_stat
operator|=
operator|(
name|BT848_INT_RACK
operator||
name|BT848_INT_I2CDONE
operator|)
expr_stmt|;
comment|/* write the READ address */
name|bt848
operator|->
name|i2c_data_ctl
operator|=
operator|(
operator|(
name|addr
operator|&
literal|0xff
operator|)
operator|<<
literal|24
operator|)
operator||
name|I2C_COMMAND
expr_stmt|;
comment|/* wait for completion */
for|for
control|(
name|x
operator|=
literal|0x7fffffff
init|;
name|x
condition|;
operator|--
name|x
control|)
block|{
comment|/* safety valve */
if|if
condition|(
name|bt848
operator|->
name|int_stat
operator|&
name|BT848_INT_I2CDONE
condition|)
break|break;
block|}
comment|/* check for ACK */
if|if
condition|(
operator|!
name|x
operator|||
operator|!
operator|(
name|bt848
operator|->
name|int_stat
operator|&
name|BT848_INT_RACK
operator|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* it was a read */
return|return
operator|(
operator|(
name|bt848
operator|->
name|i2c_data_ctl
operator|>>
literal|8
operator|)
operator|&
literal|0xff
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|I2C_SOFTWARE_PROBE
argument_list|)
end_if

begin_comment
comment|/*  * we are keeping this around for any parts that we need to probe  * but that CANNOT be probed via an i2c read.  * this is necessary because the hardware i2c mechanism  * cannot be programmed for 1 byte writes.  * currently there are no known i2c parts that we need to probe  * and that cannot be safely read.  */
end_comment

begin_function_decl
specifier|static
name|int
name|i2cProbe
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|,
name|int
name|addr
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|BITD
value|40
end_define

begin_define
define|#
directive|define
name|EXTRA_START
end_define

begin_comment
comment|/*  * probe for an I2C device at addr.  */
end_comment

begin_function
specifier|static
name|int
name|i2cProbe
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|,
name|int
name|addr
parameter_list|)
block|{
name|int
name|x
decl_stmt|,
name|status
decl_stmt|;
name|bt848_ptr_t
name|bt848
decl_stmt|;
name|bt848
operator|=
name|bktr
operator|->
name|base
expr_stmt|;
comment|/* the START */
if|#
directive|if
name|defined
argument_list|(
name|EXTRA_START
argument_list|)
name|bt848
operator|->
name|i2c_data_ctl
operator|=
literal|1
expr_stmt|;
name|DELAY
argument_list|(
name|BITD
argument_list|)
expr_stmt|;
comment|/* release data */
name|bt848
operator|->
name|i2c_data_ctl
operator|=
literal|3
expr_stmt|;
name|DELAY
argument_list|(
name|BITD
argument_list|)
expr_stmt|;
comment|/* release clock */
endif|#
directive|endif
comment|/* EXTRA_START */
name|bt848
operator|->
name|i2c_data_ctl
operator|=
literal|2
expr_stmt|;
name|DELAY
argument_list|(
name|BITD
argument_list|)
expr_stmt|;
comment|/* lower data */
name|bt848
operator|->
name|i2c_data_ctl
operator|=
literal|0
expr_stmt|;
name|DELAY
argument_list|(
name|BITD
argument_list|)
expr_stmt|;
comment|/* lower clock */
comment|/* write addr */
for|for
control|(
name|x
operator|=
literal|7
init|;
name|x
operator|>=
literal|0
condition|;
operator|--
name|x
control|)
block|{
if|if
condition|(
name|addr
operator|&
operator|(
literal|1
operator|<<
name|x
operator|)
condition|)
block|{
name|bt848
operator|->
name|i2c_data_ctl
operator|=
literal|1
expr_stmt|;
name|DELAY
argument_list|(
name|BITD
argument_list|)
expr_stmt|;
comment|/* assert HI data */
name|bt848
operator|->
name|i2c_data_ctl
operator|=
literal|3
expr_stmt|;
name|DELAY
argument_list|(
name|BITD
argument_list|)
expr_stmt|;
comment|/* strobe clock */
name|bt848
operator|->
name|i2c_data_ctl
operator|=
literal|1
expr_stmt|;
name|DELAY
argument_list|(
name|BITD
argument_list|)
expr_stmt|;
comment|/* release clock */
block|}
else|else
block|{
name|bt848
operator|->
name|i2c_data_ctl
operator|=
literal|0
expr_stmt|;
name|DELAY
argument_list|(
name|BITD
argument_list|)
expr_stmt|;
comment|/* assert LO data */
name|bt848
operator|->
name|i2c_data_ctl
operator|=
literal|2
expr_stmt|;
name|DELAY
argument_list|(
name|BITD
argument_list|)
expr_stmt|;
comment|/* strobe clock */
name|bt848
operator|->
name|i2c_data_ctl
operator|=
literal|0
expr_stmt|;
name|DELAY
argument_list|(
name|BITD
argument_list|)
expr_stmt|;
comment|/* release clock */
block|}
block|}
comment|/* look for an ACK */
name|bt848
operator|->
name|i2c_data_ctl
operator|=
literal|1
expr_stmt|;
name|DELAY
argument_list|(
name|BITD
argument_list|)
expr_stmt|;
comment|/* float data */
name|bt848
operator|->
name|i2c_data_ctl
operator|=
literal|3
expr_stmt|;
name|DELAY
argument_list|(
name|BITD
argument_list|)
expr_stmt|;
comment|/* strobe clock */
name|status
operator|=
name|bt848
operator|->
name|i2c_data_ctl
operator|&
literal|1
expr_stmt|;
comment|/* read the ACK bit */
name|bt848
operator|->
name|i2c_data_ctl
operator|=
literal|1
expr_stmt|;
name|DELAY
argument_list|(
name|BITD
argument_list|)
expr_stmt|;
comment|/* release clock */
comment|/* the STOP */
name|bt848
operator|->
name|i2c_data_ctl
operator|=
literal|0
expr_stmt|;
name|DELAY
argument_list|(
name|BITD
argument_list|)
expr_stmt|;
comment|/* lower clock& data */
name|bt848
operator|->
name|i2c_data_ctl
operator|=
literal|2
expr_stmt|;
name|DELAY
argument_list|(
name|BITD
argument_list|)
expr_stmt|;
comment|/* release clock */
name|bt848
operator|->
name|i2c_data_ctl
operator|=
literal|3
expr_stmt|;
name|DELAY
argument_list|(
name|BITD
argument_list|)
expr_stmt|;
comment|/* release data */
return|return
operator|(
name|status
operator|)
return|;
block|}
end_function

begin_undef
undef|#
directive|undef
name|EXTRA_START
end_undef

begin_undef
undef|#
directive|undef
name|BITD
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* I2C_SOFTWARE_PROBE */
end_comment

begin_comment
comment|/*  *   */
end_comment

begin_function
specifier|static
name|int
name|writeEEProm
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|count
parameter_list|,
name|u_char
modifier|*
name|data
parameter_list|)
block|{
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *   */
end_comment

begin_function
specifier|static
name|int
name|readEEProm
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|count
parameter_list|,
name|u_char
modifier|*
name|data
parameter_list|)
block|{
name|int
name|x
decl_stmt|;
name|int
name|addr
decl_stmt|;
name|int
name|max
decl_stmt|;
name|int
name|byte
decl_stmt|;
comment|/* get the address of the EEProm */
name|addr
operator|=
call|(
name|int
call|)
argument_list|(
name|bktr
operator|->
name|card
operator|.
name|eepromAddr
operator|&
literal|0xff
argument_list|)
expr_stmt|;
if|if
condition|(
name|addr
operator|==
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|max
operator|=
call|(
name|int
call|)
argument_list|(
name|bktr
operator|->
name|card
operator|.
name|eepromSize
operator|*
name|EEPROMBLOCKSIZE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|offset
operator|+
name|count
operator|)
operator|>
name|max
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* set the start address */
if|if
condition|(
name|i2cWrite
argument_list|(
name|bktr
argument_list|,
name|addr
argument_list|,
name|offset
argument_list|,
operator|-
literal|1
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* the read cycle */
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|count
condition|;
operator|++
name|x
control|)
block|{
if|if
condition|(
operator|(
name|byte
operator|=
name|i2cRead
argument_list|(
name|bktr
argument_list|,
operator|(
name|addr
operator||
literal|1
operator|)
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|data
index|[
name|x
index|]
operator|=
name|byte
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************  * card probe  */
end_comment

begin_comment
comment|/*  * the recognized cards, used as indexes of several tables.  *  * if probeCard() fails to detect the proper card on boot you can  * override it by setting the following define to the card you are using:  * #define OVERRIDE_CARD<card type>  *  * where<card type> is one of the following card defines.  */
end_comment

begin_define
define|#
directive|define
name|CARD_UNKNOWN
value|0
end_define

begin_define
define|#
directive|define
name|CARD_MIRO
value|1
end_define

begin_define
define|#
directive|define
name|CARD_HAUPPAUGE
value|2
end_define

begin_define
define|#
directive|define
name|CARD_STB
value|3
end_define

begin_define
define|#
directive|define
name|CARD_INTEL
value|4
end_define

begin_comment
comment|/*  * the data for each type of card  *  * Note:  *   these entried MUST be kept in the order defined by the CARD_XXX defines!  */
end_comment

begin_decl_stmt
specifier|const
name|struct
name|CARDTYPE
name|cards
index|[]
init|=
block|{
comment|/* CARD_UNKNOWN */
block|{
literal|"Unknown"
block|,
comment|/* the 'name' */
name|NULL
block|,
comment|/* the tuner */
literal|0
block|,
comment|/* dbx unknown */
literal|0
block|,
comment|/* EEProm unknown */
literal|0
block|,
comment|/* EEProm unknown */
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
block|,
comment|/* CARD_MIRO */
block|{
literal|"Miro TV"
block|,
comment|/* the 'name' */
name|NULL
block|,
comment|/* the tuner */
literal|0
block|,
comment|/* dbx unknown */
literal|0
block|,
comment|/* EEProm unknown */
literal|0
block|,
comment|/* size unknown */
block|{
literal|0x02
block|,
literal|0x01
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|1
block|}
block|}
block|,
comment|/* XXX ??? */
comment|/* CARD_HAUPPAUGE */
block|{
literal|"Hauppauge WinCast/TV"
block|,
comment|/* the 'name' */
name|NULL
block|,
comment|/* the tuner */
literal|0
block|,
comment|/* dbx is optional */
name|PFC8582_WADDR
block|,
comment|/* EEProm type */
call|(
name|u_char
call|)
argument_list|(
literal|256
operator|/
name|EEPROMBLOCKSIZE
argument_list|)
block|,
comment|/* 256 bytes */
block|{
literal|0x00
block|,
literal|0x02
block|,
literal|0x01
block|,
literal|0x01
block|,
literal|1
block|}
block|}
block|,
comment|/* audio MUX values */
comment|/* CARD_STB */
block|{
literal|"STB TV/PCI"
block|,
comment|/* the 'name' */
name|NULL
block|,
comment|/* the tuner */
literal|0
block|,
comment|/* dbx is optional */
name|X24C01_WADDR
block|,
comment|/* EEProm type */
call|(
name|u_char
call|)
argument_list|(
literal|128
operator|/
name|EEPROMBLOCKSIZE
argument_list|)
block|,
comment|/* 128 bytes */
block|{
literal|0x00
block|,
literal|0x01
block|,
literal|0x02
block|,
literal|0x02
block|,
literal|1
block|}
block|}
block|,
comment|/* audio MUX values */
comment|/* CARD_INTEL */
block|{
literal|"Intel Smart Video III"
block|,
comment|/* the 'name' */
name|NULL
block|,
comment|/* the tuner */
literal|0
block|,
literal|0
block|,
literal|0
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * the data for each type of tuner  */
end_comment

begin_comment
comment|/* indexes into tuners[] */
end_comment

begin_define
define|#
directive|define
name|NO_TUNER
value|0
end_define

begin_define
define|#
directive|define
name|TEMIC_NTSC
value|1
end_define

begin_define
define|#
directive|define
name|TEMIC_PAL
value|2
end_define

begin_define
define|#
directive|define
name|TEMIC_SECAM
value|3
end_define

begin_define
define|#
directive|define
name|PHILIPS_NTSC
value|4
end_define

begin_define
define|#
directive|define
name|PHILIPS_PAL
value|5
end_define

begin_define
define|#
directive|define
name|PHILIPS_SECAM
value|6
end_define

begin_comment
comment|/* XXX FIXME: this list is incomplete */
end_comment

begin_comment
comment|/* input types */
end_comment

begin_define
define|#
directive|define
name|TTYPE_XXX
value|0
end_define

begin_define
define|#
directive|define
name|TTYPE_NTSC
value|1
end_define

begin_define
define|#
directive|define
name|TTYPE_NTSC_J
value|2
end_define

begin_define
define|#
directive|define
name|TTYPE_PAL
value|3
end_define

begin_define
define|#
directive|define
name|TTYPE_PAL_M
value|4
end_define

begin_define
define|#
directive|define
name|TTYPE_PAL_N
value|5
end_define

begin_define
define|#
directive|define
name|TTYPE_SECAM
value|6
end_define

begin_comment
comment|/** struct TUNER { 	char*		name; 	u_char		type; 	u_char		pllAddr; 	u_char		pllControl; 	u_char		bandLimits[ 2 ]; 	u_char		bandAddrs[ 3 ]; };  */
end_comment

begin_decl_stmt
specifier|const
name|struct
name|TUNER
name|tuners
index|[]
init|=
block|{
comment|/* XXX FIXME: fill in the band-switch crosspoints */
comment|/* NO_TUNER */
block|{
literal|"<none>"
block|,
comment|/* the 'name' */
name|TTYPE_XXX
block|,
comment|/* input type */
literal|0x00
block|,
comment|/* PLL write address */
literal|0x00
block|,
comment|/* control byte for PLL */
block|{
literal|0x00
block|,
literal|0x00
block|}
block|,
comment|/* band-switch crosspoints */
block|{
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|}
block|}
block|,
comment|/* the band-switch values */
comment|/* TEMIC_NTSC */
block|{
literal|"Temic NTSC"
block|,
comment|/* the 'name' */
name|TTYPE_NTSC
block|,
comment|/* input type */
name|TEMIC_NTSC_WADDR
block|,
comment|/* PLL write address */
name|TSA552x_SCONTROL
block|,
comment|/* control byte for PLL */
block|{
literal|0x00
block|,
literal|0x00
block|}
block|,
comment|/* band-switch crosspoints */
block|{
literal|0x02
block|,
literal|0x04
block|,
literal|0x01
block|}
block|}
block|,
comment|/* the band-switch values */
comment|/* TEMIC_PAL */
block|{
literal|"Temic PAL"
block|,
comment|/* the 'name' */
name|TTYPE_PAL
block|,
comment|/* input type */
name|TEMIC_PALI_WADDR
block|,
comment|/* PLL write address */
name|TSA552x_SCONTROL
block|,
comment|/* control byte for PLL */
block|{
literal|0x00
block|,
literal|0x00
block|}
block|,
comment|/* band-switch crosspoints */
block|{
literal|0x02
block|,
literal|0x04
block|,
literal|0x01
block|}
block|}
block|,
comment|/* the band-switch values */
comment|/* TEMIC_SECAM */
block|{
literal|"Temic SECAM"
block|,
comment|/* the 'name' */
name|TTYPE_SECAM
block|,
comment|/* input type */
literal|0x00
block|,
comment|/* PLL write address */
name|TSA552x_SCONTROL
block|,
comment|/* control byte for PLL */
block|{
literal|0x00
block|,
literal|0x00
block|}
block|,
comment|/* band-switch crosspoints */
block|{
literal|0x02
block|,
literal|0x04
block|,
literal|0x01
block|}
block|}
block|,
comment|/* the band-switch values */
comment|/* PHILIPS_NTSC */
block|{
literal|"Philips NTSC"
block|,
comment|/* the 'name' */
name|TTYPE_NTSC
block|,
comment|/* input type */
name|PHILIPS_NTSC_WADDR
block|,
comment|/* PLL write address */
name|TSA552x_SCONTROL
block|,
comment|/* control byte for PLL */
block|{
literal|0x00
block|,
literal|0x00
block|}
block|,
comment|/* band-switch crosspoints */
block|{
literal|0xa0
block|,
literal|0x90
block|,
literal|0x30
block|}
block|}
block|,
comment|/* the band-switch values */
comment|/* PHILIPS_PAL */
block|{
literal|"Philips PAL"
block|,
comment|/* the 'name' */
name|TTYPE_PAL
block|,
comment|/* input type */
literal|0x00
block|,
comment|/* PLL write address */
name|TSA552x_SCONTROL
block|,
comment|/* control byte for PLL */
block|{
literal|0x00
block|,
literal|0x00
block|}
block|,
comment|/* band-switch crosspoints */
block|{
literal|0xa0
block|,
literal|0x90
block|,
literal|0x30
block|}
block|}
block|,
comment|/* the band-switch values */
comment|/* PHILIPS_SECAM */
block|{
literal|"Philips SECAM"
block|,
comment|/* the 'name' */
name|TTYPE_SECAM
block|,
comment|/* input type */
literal|0x00
block|,
comment|/* PLL write address */
name|TSA552x_SCONTROL
block|,
comment|/* control byte for PLL */
block|{
literal|0x00
block|,
literal|0x00
block|}
block|,
comment|/* band-switch crosspoints */
block|{
literal|0xa0
block|,
literal|0x90
block|,
literal|0x30
block|}
block|}
comment|/* the band-switch values */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * get a signature of the card  * read all 128 possible i2c read addresses from 0x01 thru 0xff  * build a bit array with a 1 bit for each i2c device that responds  *  * XXX FIXME: use offset& count args  */
end_comment

begin_define
define|#
directive|define
name|ABSENT
value|(-1)
end_define

begin_function
specifier|static
name|int
name|signCard
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|count
parameter_list|,
name|u_char
modifier|*
name|sig
parameter_list|)
block|{
name|int
name|x
decl_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
literal|16
condition|;
operator|++
name|x
control|)
name|sig
index|[
name|x
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
literal|128
condition|;
operator|++
name|x
control|)
block|{
if|if
condition|(
name|i2cRead
argument_list|(
name|bktr
argument_list|,
operator|(
literal|2
operator|*
name|x
operator|)
operator|+
literal|1
argument_list|)
operator|!=
name|ABSENT
condition|)
block|{
name|sig
index|[
name|x
operator|/
literal|8
index|]
operator||=
operator|(
literal|1
operator|<<
operator|(
name|x
operator|%
literal|8
operator|)
operator|)
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_undef
undef|#
directive|undef
name|ABSENT
end_undef

begin_comment
comment|/*  * determine the card brand/model  */
end_comment

begin_define
define|#
directive|define
name|ABSENT
value|(-1)
end_define

begin_function
specifier|static
name|void
name|probeCard
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|,
name|int
name|verbose
parameter_list|)
block|{
name|int
name|card
decl_stmt|;
name|int
name|status
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|OVERRIDE_CARD
argument_list|)
name|bktr
operator|->
name|card
operator|=
name|cards
index|[
operator|(
name|card
operator|=
name|OVERRIDE_CARD
operator|)
index|]
expr_stmt|;
goto|goto
name|checkTuner
goto|;
endif|#
directive|endif
comment|/* look for a tuner */
if|if
condition|(
name|i2cRead
argument_list|(
name|bktr
argument_list|,
name|TSA552x_RADDR
argument_list|)
operator|==
name|ABSENT
condition|)
block|{
name|bktr
operator|->
name|card
operator|=
name|cards
index|[
operator|(
name|card
operator|=
name|CARD_INTEL
operator|)
index|]
expr_stmt|;
name|bktr
operator|->
name|card
operator|.
name|tuner
operator|=
operator|&
name|tuners
index|[
name|NO_TUNER
index|]
expr_stmt|;
goto|goto
name|checkDBX
goto|;
block|}
comment|/* look for a hauppauge card */
if|if
condition|(
operator|(
name|status
operator|=
name|i2cRead
argument_list|(
name|bktr
argument_list|,
name|PFC8582_RADDR
argument_list|)
operator|)
operator|!=
name|ABSENT
condition|)
block|{
name|bktr
operator|->
name|card
operator|=
name|cards
index|[
operator|(
name|card
operator|=
name|CARD_HAUPPAUGE
operator|)
index|]
expr_stmt|;
goto|goto
name|checkTuner
goto|;
block|}
comment|/* look for an STB card */
if|if
condition|(
operator|(
name|status
operator|=
name|i2cRead
argument_list|(
name|bktr
argument_list|,
name|X24C01_RADDR
argument_list|)
operator|)
operator|!=
name|ABSENT
condition|)
block|{
name|bktr
operator|->
name|card
operator|=
name|cards
index|[
operator|(
name|card
operator|=
name|CARD_STB
operator|)
index|]
expr_stmt|;
goto|goto
name|checkTuner
goto|;
block|}
comment|/* XXX FIXME: (how do I) look for a Miro card */
name|bktr
operator|->
name|card
operator|=
name|cards
index|[
operator|(
name|card
operator|=
name|CARD_MIRO
operator|)
index|]
expr_stmt|;
name|checkTuner
label|:
comment|/* differentiate type of tuner */
if|if
condition|(
name|i2cRead
argument_list|(
name|bktr
argument_list|,
name|TEMIC_NTSC_RADDR
argument_list|)
operator|!=
name|ABSENT
condition|)
block|{
name|bktr
operator|->
name|card
operator|.
name|tuner
operator|=
operator|&
name|tuners
index|[
name|TEMIC_NTSC
index|]
expr_stmt|;
goto|goto
name|checkDBX
goto|;
block|}
if|if
condition|(
name|i2cRead
argument_list|(
name|bktr
argument_list|,
name|PHILIPS_NTSC_RADDR
argument_list|)
operator|!=
name|ABSENT
condition|)
block|{
name|bktr
operator|->
name|card
operator|.
name|tuner
operator|=
operator|&
name|tuners
index|[
name|PHILIPS_NTSC
index|]
expr_stmt|;
goto|goto
name|checkDBX
goto|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|TEST_PAL
argument_list|)
comment|/** WARNING: this is a test */
if|if
condition|(
name|card
operator|==
name|CARD_HAUPPAUGE
condition|)
block|{
if|if
condition|(
name|i2cRead
argument_list|(
name|bktr
argument_list|,
name|TEMIC_PALI_RADDR
argument_list|)
operator|!=
name|ABSENT
condition|)
block|{
name|bktr
operator|->
name|card
operator|.
name|tuner
operator|=
operator|&
name|tuners
index|[
name|TEMIC_PAL
index|]
expr_stmt|;
goto|goto
name|checkDBX
goto|;
block|}
block|}
endif|#
directive|endif
comment|/* TEST_PAL */
comment|/* no tuner found */
name|bktr
operator|->
name|card
operator|.
name|tuner
operator|=
operator|&
name|tuners
index|[
name|NO_TUNER
index|]
expr_stmt|;
name|checkDBX
label|:
comment|/* probe for BTSC (dbx) chips */
if|if
condition|(
name|i2cRead
argument_list|(
name|bktr
argument_list|,
name|TDA9850_RADDR
argument_list|)
operator|!=
name|ABSENT
condition|)
name|bktr
operator|->
name|card
operator|.
name|dbx
operator|=
literal|1
expr_stmt|;
name|end
label|:
if|if
condition|(
name|verbose
condition|)
block|{
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|bktr
operator|->
name|card
operator|.
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|bktr
operator|->
name|card
operator|.
name|tuner
condition|)
name|printf
argument_list|(
literal|", %s tuner"
argument_list|,
name|bktr
operator|->
name|card
operator|.
name|tuner
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|bktr
operator|->
name|card
operator|.
name|dbx
condition|)
name|printf
argument_list|(
literal|", dbx stereo"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|".\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_undef
undef|#
directive|undef
name|ABSENT
end_undef

begin_comment
comment|/******************************************************************************  * tuner specific routines:  */
end_comment

begin_comment
comment|/* scaling factor for frequencies expressed as ints */
end_comment

begin_define
define|#
directive|define
name|FREQFACTOR
value|16
end_define

begin_comment
comment|/*  * Format:  *	entry 0:         MAX legal channel  *	entry 1:         IF frequency  *			 expressed as fi{mHz} * 16,  *			 eg 45.75mHz == 45.75 * 16 = 732  *	entry 2:         [place holder/future]  *	entry 3:         base of channel record 0  *	entry 3 + (x*3): base of channel record 'x'  *	entry LAST:      NULL channel entry marking end of records  *  * Record:  *	int 0:		base channel  *	int 1:		frequency of base channel,  *			 expressed as fb{mHz} * 16,  *	int 2:		offset frequency between channels,  *			 expressed as fo{mHz} * 16,  */
end_comment

begin_comment
comment|/*  * North American Broadcast Channels:  *  *  2:  55.25 mHz -  4:  67.25 mHz  *  5:  77.25 mHz -  6:	 83.25 mHz  *  7: 175.25 mHz - 13:	211.25 mHz  * 14: 471.25 mHz - 83:	885.25 mHz  *  * IF freq: 45.75 mHz  */
end_comment

begin_define
define|#
directive|define
name|OFFSET
value|6.00
end_define

begin_decl_stmt
name|int
name|nabcst
index|[]
init|=
block|{
literal|83
block|,
call|(
name|int
call|)
argument_list|(
literal|45.75
operator|*
name|FREQFACTOR
argument_list|)
block|,
literal|0
block|,
literal|14
block|,
call|(
name|int
call|)
argument_list|(
literal|471.25
operator|*
name|FREQFACTOR
argument_list|)
block|,
call|(
name|int
call|)
argument_list|(
name|OFFSET
operator|*
name|FREQFACTOR
argument_list|)
block|,
literal|7
block|,
call|(
name|int
call|)
argument_list|(
literal|175.25
operator|*
name|FREQFACTOR
argument_list|)
block|,
call|(
name|int
call|)
argument_list|(
name|OFFSET
operator|*
name|FREQFACTOR
argument_list|)
block|,
literal|5
block|,
call|(
name|int
call|)
argument_list|(
literal|77.25
operator|*
name|FREQFACTOR
argument_list|)
block|,
call|(
name|int
call|)
argument_list|(
name|OFFSET
operator|*
name|FREQFACTOR
argument_list|)
block|,
literal|2
block|,
call|(
name|int
call|)
argument_list|(
literal|55.25
operator|*
name|FREQFACTOR
argument_list|)
block|,
call|(
name|int
call|)
argument_list|(
name|OFFSET
operator|*
name|FREQFACTOR
argument_list|)
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_undef
undef|#
directive|undef
name|OFFSET
end_undef

begin_comment
comment|/*  * North American Cable Channels, IRC:  *  *  2:  55.25 mHz -  4:  67.25 mHz  *  5:  77.25 mHz -  6:  83.25 mHz  *  7: 175.25 mHz - 13: 211.25 mHz  * 14: 121.25 mHz - 22: 169.25 mHz  * 23: 217.25 mHz - 94: 643.25 mHz  * 95:  91.25 mHz - 99: 115.25 mHz  *  * IF freq: 45.75 mHz  */
end_comment

begin_define
define|#
directive|define
name|OFFSET
value|6.00
end_define

begin_decl_stmt
name|int
name|irccable
index|[]
init|=
block|{
literal|99
block|,
call|(
name|int
call|)
argument_list|(
literal|45.75
operator|*
name|FREQFACTOR
argument_list|)
block|,
literal|0
block|,
literal|95
block|,
call|(
name|int
call|)
argument_list|(
literal|91.25
operator|*
name|FREQFACTOR
argument_list|)
block|,
call|(
name|int
call|)
argument_list|(
name|OFFSET
operator|*
name|FREQFACTOR
argument_list|)
block|,
literal|23
block|,
call|(
name|int
call|)
argument_list|(
literal|217.25
operator|*
name|FREQFACTOR
argument_list|)
block|,
call|(
name|int
call|)
argument_list|(
name|OFFSET
operator|*
name|FREQFACTOR
argument_list|)
block|,
literal|14
block|,
call|(
name|int
call|)
argument_list|(
literal|121.25
operator|*
name|FREQFACTOR
argument_list|)
block|,
call|(
name|int
call|)
argument_list|(
name|OFFSET
operator|*
name|FREQFACTOR
argument_list|)
block|,
literal|7
block|,
call|(
name|int
call|)
argument_list|(
literal|175.25
operator|*
name|FREQFACTOR
argument_list|)
block|,
call|(
name|int
call|)
argument_list|(
name|OFFSET
operator|*
name|FREQFACTOR
argument_list|)
block|,
literal|5
block|,
call|(
name|int
call|)
argument_list|(
literal|77.25
operator|*
name|FREQFACTOR
argument_list|)
block|,
call|(
name|int
call|)
argument_list|(
name|OFFSET
operator|*
name|FREQFACTOR
argument_list|)
block|,
literal|2
block|,
call|(
name|int
call|)
argument_list|(
literal|55.25
operator|*
name|FREQFACTOR
argument_list|)
block|,
call|(
name|int
call|)
argument_list|(
name|OFFSET
operator|*
name|FREQFACTOR
argument_list|)
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_undef
undef|#
directive|undef
name|OFFSET
end_undef

begin_comment
comment|/*  * North American Cable Channels, HRC:  */
end_comment

begin_decl_stmt
name|int
name|hrccable
index|[]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Western European broadcast channels:  *  * (there are others that appear to vary between countries - rmt)  *  * here's the table Philips provides:  * caution, some of the offsets don't compute...  *  *  1	 4525	700	N21  *   *  2	 4825	700	E2  *  3	 5525	700	E3  *  4	 6225	700	E4  *   *  5	17525	700	E5  *  6	18225	700	E6  *  7	18925	700	E7  *  8	19625	700	E8  *  9	20325	700	E9  * 10	21025	700	E10  * 11	21725	700	E11  * 12	22425	700	E12  *   * 13	 5375	700	ITA  * 14	 6225	700	ITB  *   * 15	 8225	700	ITC  *   * 16	17525	700	ITD  * 17	18325	700	ITE  *   * 18	19225	700	ITF  * 19	20125	700	ITG  * 20	21025	700	ITH  *   * 21	47125	800	E21  * 22	47925	800	E22  * 23	48725	800	E23  * 24	49525	800	E24  * 25	50325	800	E25  * 26	51125	800	E26  * 27	51925	800	E27  * 28	52725	800	E28  * 29	53525	800	E29  * 30	54325	800	E30  * 31	55125	800	E31  * 32	55925	800	E32  * 33	56725	800	E33  * 34	57525	800	E34  * 35	58325	800	E35  * 36	59125	800	E36  * 37	59925	800	E37  * 38	60725	800	E38  * 39	61525	800	E39  * 40	62325	800	E40  * 41	63125	800	E41  * 42	63925	800	E42  * 43	64725	800	E43  * 44	65525	800	E44  * 45	66325	800	E45  * 46	67125	800	E46  * 47	67925	800	E47  * 48	68725	800	E48  * 49	69525	800	E49  * 50	70325	800	E50  * 51	71125	800	E51  * 52	71925	800	E52  * 53	72725	800	E53  * 54	73525	800	E54  * 55	74325	800	E55  * 56	75125	800	E56  * 57	75925	800	E57  * 58	76725	800	E58  * 59	77525	800	E59  * 60	78325	800	E60  * 61	79125	800	E61  * 62	79925	800	E62  * 63	80725	800	E63  * 64	81525	800	E64  * 65	82325	800	E65  * 66	83125	800	E66  * 67	83925	800	E67  * 68	84725	800	E68  * 69	85525	800	E69  *   * 70	 4575	800	IA  * 71	 5375	800	IB  * 72	 6175	800	IC  *   * 74	 6925	700	S01  * 75	 7625	700	S02  * 76	 8325	700	S03  *   * 80	10525	700	S1  * 81	11225	700	S2  * 82	11925	700	S3  * 83	12625	700	S4  * 84	13325	700	S5  * 85	14025	700	S6  * 86	14725	700	S7  * 87	15425	700	S8  * 88	16125	700	S9  * 89	16825	700	S10  * 90	23125	700	S11  * 91	23825	700	S12  * 92	24525	700	S13  * 93	25225	700	S14  * 94	25925	700	S15  * 95	26625	700	S16  * 96	27325	700	S17  * 97	28025	700	S18  * 98	28725	700	S19  * 99	29425	700	S20  *   * 100	 3890	000	IFFREQ  *   */
end_comment

begin_define
define|#
directive|define
name|OFFSET
value|8.00
end_define

begin_decl_stmt
name|int
name|weurope
index|[]
init|=
block|{
literal|69
block|,
call|(
name|int
call|)
argument_list|(
literal|38.90
operator|*
name|FREQFACTOR
argument_list|)
block|,
literal|0
block|,
literal|21
block|,
call|(
name|int
call|)
argument_list|(
literal|471.25
operator|*
name|FREQFACTOR
argument_list|)
block|,
call|(
name|int
call|)
argument_list|(
name|OFFSET
operator|*
name|FREQFACTOR
argument_list|)
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_undef
undef|#
directive|undef
name|OFFSET
end_undef

begin_comment
comment|/*  * Japanese Broadcast Channels:  *  *  1:  91.25MHz -  3: 103.25MHz  *  4: 171.25MHz -  7: 189.25MHz  *  8: 193.25MHz - 12: 217.25MHz  (VHF)  * 13: 471.25MHz - 62: 765.25MHz  (UHF)  *  * IF freq: 45.75 mHz  *  OR  * IF freq: 58.75 mHz  */
end_comment

begin_define
define|#
directive|define
name|OFFSET
value|6.00
end_define

begin_define
define|#
directive|define
name|IF_FREQ
value|45.75
end_define

begin_decl_stmt
name|int
name|jpnbcst
index|[]
init|=
block|{
literal|62
block|,
call|(
name|int
call|)
argument_list|(
name|IF_FREQ
operator|*
name|FREQFACTOR
argument_list|)
block|,
literal|0
block|,
literal|13
block|,
call|(
name|int
call|)
argument_list|(
literal|471.25
operator|*
name|FREQFACTOR
argument_list|)
block|,
call|(
name|int
call|)
argument_list|(
name|OFFSET
operator|*
name|FREQFACTOR
argument_list|)
block|,
literal|8
block|,
call|(
name|int
call|)
argument_list|(
literal|193.25
operator|*
name|FREQFACTOR
argument_list|)
block|,
call|(
name|int
call|)
argument_list|(
name|OFFSET
operator|*
name|FREQFACTOR
argument_list|)
block|,
literal|4
block|,
call|(
name|int
call|)
argument_list|(
literal|171.25
operator|*
name|FREQFACTOR
argument_list|)
block|,
call|(
name|int
call|)
argument_list|(
name|OFFSET
operator|*
name|FREQFACTOR
argument_list|)
block|,
literal|1
block|,
call|(
name|int
call|)
argument_list|(
literal|91.25
operator|*
name|FREQFACTOR
argument_list|)
block|,
call|(
name|int
call|)
argument_list|(
name|OFFSET
operator|*
name|FREQFACTOR
argument_list|)
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_undef
undef|#
directive|undef
name|IF_FREQ
end_undef

begin_undef
undef|#
directive|undef
name|OFFSET
end_undef

begin_decl_stmt
name|int
modifier|*
name|freqTable
index|[]
init|=
block|{
name|NULL
block|,
name|nabcst
block|,
name|irccable
block|,
name|hrccable
block|,
name|weurope
block|,
name|jpnbcst
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|TBL_CHNL
value|freqTable[ bktr->tuner.chnlset ][ x ]
end_define

begin_define
define|#
directive|define
name|TBL_BASE_FREQ
value|freqTable[ bktr->tuner.chnlset ][ x + 1 ]
end_define

begin_define
define|#
directive|define
name|TBL_OFFSET
value|freqTable[ bktr->tuner.chnlset ][ x + 2 ]
end_define

begin_function
specifier|static
name|int
name|frequency_lookup
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|,
name|int
name|channel
parameter_list|)
block|{
name|int
name|x
decl_stmt|;
comment|/* check for "> MAX channel" */
name|x
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|channel
operator|>
name|TBL_CHNL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* search the table for data */
for|for
control|(
name|x
operator|=
literal|3
init|;
name|TBL_CHNL
condition|;
name|x
operator|+=
literal|3
control|)
block|{
if|if
condition|(
name|channel
operator|>=
name|TBL_CHNL
condition|)
block|{
return|return
operator|(
name|TBL_BASE_FREQ
operator|+
operator|(
operator|(
name|channel
operator|-
name|TBL_CHNL
operator|)
operator|*
name|TBL_OFFSET
operator|)
operator|)
return|;
block|}
block|}
comment|/* not found, must be below the MIN channel */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_undef
undef|#
directive|undef
name|TBL_OFFSET
end_undef

begin_undef
undef|#
directive|undef
name|TBL_BASE_FREQ
end_undef

begin_undef
undef|#
directive|undef
name|TBL_CHNL
end_undef

begin_define
define|#
directive|define
name|TBL_IF
value|freqTable[ bktr->tuner.chnlset ][ 1 ]
end_define

begin_comment
comment|/*  * set the frequency of the tuner  */
end_comment

begin_function
specifier|static
name|int
name|tv_freq
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|,
name|int
name|frequency
parameter_list|)
block|{
specifier|const
name|struct
name|TUNER
modifier|*
name|tuner
decl_stmt|;
name|u_char
name|addr
decl_stmt|;
name|u_char
name|control
decl_stmt|;
name|u_char
name|band
decl_stmt|;
name|int
name|N
decl_stmt|;
name|int
name|order
decl_stmt|;
name|tuner
operator|=
name|bktr
operator|->
name|card
operator|.
name|tuner
expr_stmt|;
if|if
condition|(
name|tuner
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* 	 * select the band based on frequency 	 * XXX FIXME: get the cross-over points from the tuner struct 	 */
if|if
condition|(
name|frequency
operator|<
operator|(
literal|160
operator|*
name|FREQFACTOR
operator|)
condition|)
name|band
operator|=
name|tuner
operator|->
name|bandAddrs
index|[
literal|0
index|]
expr_stmt|;
elseif|else
if|if
condition|(
name|frequency
operator|<
operator|(
literal|454
operator|*
name|FREQFACTOR
operator|)
condition|)
name|band
operator|=
name|tuner
operator|->
name|bandAddrs
index|[
literal|1
index|]
expr_stmt|;
else|else
name|band
operator|=
name|tuner
operator|->
name|bandAddrs
index|[
literal|2
index|]
expr_stmt|;
comment|/* set the address of the PLL */
name|addr
operator|=
name|tuner
operator|->
name|pllAddr
expr_stmt|;
name|control
operator|=
name|tuner
operator|->
name|pllControl
expr_stmt|;
comment|/* 	 * N = 16 * { fRF(pc) + fIF(pc) } 	 * where: 	 *  pc is picture carrier, fRF& fIF are in mHz 	 * 	 * frequency was passed in as mHz * 16 	 */
if|#
directive|if
name|defined
argument_list|(
name|TEST_TUNER_AFC
argument_list|)
if|if
condition|(
name|bktr
operator|->
name|tuner
operator|.
name|afc
condition|)
name|frequency
operator|-=
literal|4
expr_stmt|;
endif|#
directive|endif
name|N
operator|=
name|frequency
operator|+
name|TBL_IF
expr_stmt|;
if|if
condition|(
name|frequency
operator|>
name|bktr
operator|->
name|tuner
operator|.
name|frequency
condition|)
block|{
name|i2cWrite
argument_list|(
name|bktr
argument_list|,
name|addr
argument_list|,
operator|(
name|N
operator|>>
literal|8
operator|)
operator|&
literal|0x7f
argument_list|,
name|N
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|i2cWrite
argument_list|(
name|bktr
argument_list|,
name|addr
argument_list|,
name|control
argument_list|,
name|band
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|i2cWrite
argument_list|(
name|bktr
argument_list|,
name|addr
argument_list|,
name|control
argument_list|,
name|band
argument_list|)
expr_stmt|;
name|i2cWrite
argument_list|(
name|bktr
argument_list|,
name|addr
argument_list|,
operator|(
name|N
operator|>>
literal|8
operator|)
operator|&
literal|0x7f
argument_list|,
name|N
operator|&
literal|0xff
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|TUNER_AFC
argument_list|)
if|if
condition|(
name|bktr
operator|->
name|tuner
operator|.
name|afc
operator|==
name|TRUE
condition|)
block|{
if|if
condition|(
operator|(
name|N
operator|=
name|do_afc
argument_list|(
name|bktr
argument_list|,
name|addr
argument_list|,
name|N
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
comment|/* AFC failed, restore requested frequency */
name|N
operator|=
name|frequency
operator|+
name|TBL_IF
expr_stmt|;
name|i2cWrite
argument_list|(
name|bktr
argument_list|,
name|addr
argument_list|,
operator|(
name|N
operator|>>
literal|8
operator|)
operator|&
literal|0x7f
argument_list|,
name|N
operator|&
literal|0xff
argument_list|)
expr_stmt|;
block|}
else|else
name|frequency
operator|=
name|N
operator|-
name|TBL_IF
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* TUNER_AFC */
comment|/* update frequency */
name|bktr
operator|->
name|tuner
operator|.
name|frequency
operator|=
name|frequency
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|TUNER_AFC
argument_list|)
end_if

begin_comment
comment|/*  *   */
end_comment

begin_function
specifier|static
name|int
name|do_afc
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|,
name|int
name|addr
parameter_list|,
name|int
name|frequency
parameter_list|)
block|{
name|int
name|step
decl_stmt|;
name|int
name|status
decl_stmt|;
name|int
name|origFrequency
decl_stmt|;
name|origFrequency
operator|=
name|frequency
expr_stmt|;
comment|/* wait for first setting to take effect */
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
name|bktr
argument_list|,
name|PZERO
argument_list|,
literal|"tuning"
argument_list|,
name|hz
operator|/
literal|8
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|status
operator|=
name|i2cRead
argument_list|(
name|bktr
argument_list|,
name|addr
operator|+
literal|1
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|#
directive|if
name|defined
argument_list|(
name|TEST_TUNER_AFC
argument_list|)
name|printf
argument_list|(
literal|"\nOriginal freq: %d, status: 0x%02x\n"
argument_list|,
name|frequency
argument_list|,
name|status
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|step
operator|=
literal|0
init|;
name|step
operator|<
name|AFC_MAX_STEP
condition|;
operator|++
name|step
control|)
block|{
if|if
condition|(
operator|(
name|status
operator|=
name|i2cRead
argument_list|(
name|bktr
argument_list|,
name|addr
operator|+
literal|1
argument_list|)
operator|)
operator|<
literal|0
condition|)
goto|goto
name|fubar
goto|;
if|if
condition|(
operator|!
operator|(
name|status
operator|&
literal|0x40
operator|)
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|TEST_TUNER_AFC
argument_list|)
name|printf
argument_list|(
literal|"no lock!\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
goto|goto
name|fubar
goto|;
block|}
switch|switch
condition|(
name|status
operator|&
name|AFC_BITS
condition|)
block|{
case|case
name|AFC_FREQ_CENTERED
case|:
if|#
directive|if
name|defined
argument_list|(
name|TEST_TUNER_AFC
argument_list|)
name|printf
argument_list|(
literal|"Centered, freq: %d, status: 0x%02x\n"
argument_list|,
name|frequency
argument_list|,
name|status
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|frequency
operator|)
return|;
case|case
name|AFC_FREQ_MINUS_125
case|:
case|case
name|AFC_FREQ_MINUS_62
case|:
if|#
directive|if
name|defined
argument_list|(
name|TEST_TUNER_AFC
argument_list|)
name|printf
argument_list|(
literal|"Low, freq: %d, status: 0x%02x\n"
argument_list|,
name|frequency
argument_list|,
name|status
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|--
name|frequency
expr_stmt|;
break|break;
case|case
name|AFC_FREQ_PLUS_62
case|:
case|case
name|AFC_FREQ_PLUS_125
case|:
if|#
directive|if
name|defined
argument_list|(
name|TEST_TUNER_AFC
argument_list|)
name|printf
argument_list|(
literal|"Hi, freq: %d, status: 0x%02x\n"
argument_list|,
name|frequency
argument_list|,
name|status
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|++
name|frequency
expr_stmt|;
break|break;
block|}
name|i2cWrite
argument_list|(
name|bktr
argument_list|,
name|addr
argument_list|,
operator|(
name|frequency
operator|>>
literal|8
operator|)
operator|&
literal|0x7f
argument_list|,
name|frequency
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
name|AFC_DELAY
argument_list|)
expr_stmt|;
block|}
name|fubar
label|:
name|i2cWrite
argument_list|(
name|bktr
argument_list|,
name|addr
argument_list|,
operator|(
name|origFrequency
operator|>>
literal|8
operator|)
operator|&
literal|0x7f
argument_list|,
name|origFrequency
operator|&
literal|0xff
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* TUNER_AFC */
end_comment

begin_undef
undef|#
directive|undef
name|TBL_IF
end_undef

begin_comment
comment|/*  * set the channel of the tuner  */
end_comment

begin_function
specifier|static
name|int
name|tv_channel
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|,
name|int
name|channel
parameter_list|)
block|{
name|int
name|frequency
decl_stmt|;
comment|/* calculate the frequency according to tuner type */
if|if
condition|(
operator|(
name|frequency
operator|=
name|frequency_lookup
argument_list|(
name|bktr
argument_list|,
name|channel
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* set the new frequency */
if|if
condition|(
name|tv_freq
argument_list|(
name|bktr
argument_list|,
name|frequency
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* OK to update records */
return|return
operator|(
operator|(
name|bktr
operator|->
name|tuner
operator|.
name|channel
operator|=
name|channel
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************  * audio specific routines:  */
end_comment

begin_comment
comment|/*  *   */
end_comment

begin_define
define|#
directive|define
name|AUDIOMUX_DISCOVER_NOT
end_define

begin_function
specifier|static
name|int
name|set_audio
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|,
name|int
name|cmd
parameter_list|)
block|{
name|bt848_ptr_t
name|bt848
decl_stmt|;
name|u_long
name|temp
decl_stmt|;
specifier|volatile
name|u_char
name|idx
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|AUDIOMUX_DISCOVER
argument_list|)
if|if
condition|(
name|cmd
operator|>=
literal|200
condition|)
name|cmd
operator|-=
literal|200
expr_stmt|;
elseif|else
endif|#
directive|endif
comment|/* AUDIOMUX_DISCOVER */
comment|/* check for existance of audio MUXes */
if|if
condition|(
operator|!
name|bktr
operator|->
name|card
operator|.
name|audiomuxs
index|[
literal|4
index|]
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|AUDIO_TUNER
case|:
name|bktr
operator|->
name|audio_mux_select
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|AUDIO_EXTERN
case|:
name|bktr
operator|->
name|audio_mux_select
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|AUDIO_INTERN
case|:
name|bktr
operator|->
name|audio_mux_select
operator|=
literal|2
expr_stmt|;
break|break;
case|case
name|AUDIO_MUTE
case|:
name|bktr
operator|->
name|audio_mute_state
operator|=
name|TRUE
expr_stmt|;
comment|/* set mute */
break|break;
case|case
name|AUDIO_UNMUTE
case|:
name|bktr
operator|->
name|audio_mute_state
operator|=
name|FALSE
expr_stmt|;
comment|/* clear mute */
break|break;
default|default:
name|printf
argument_list|(
literal|"bktr: audio cmd error %02x\n"
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|bt848
operator|=
name|bktr
operator|->
name|base
expr_stmt|;
comment|/* 	 * Leave the upper bits of the GPIO port alone in case they control 	 * something like the dbx or teletext chips.  This doesn't guarantee 	 * success, but follows the rule of least astonishment. 	 */
comment|/* XXX FIXME: this was an 8 bit reference before new struct ??? */
name|bt848
operator|->
name|gpio_reg_inp
operator|=
operator|(
operator|~
name|GPIO_AUDIOMUX_BITS
operator|&
literal|0xff
operator|)
expr_stmt|;
if|if
condition|(
name|bktr
operator|->
name|audio_mute_state
operator|==
name|TRUE
condition|)
name|idx
operator|=
literal|3
expr_stmt|;
else|else
name|idx
operator|=
name|bktr
operator|->
name|audio_mux_select
expr_stmt|;
name|temp
operator|=
name|bt848
operator|->
name|gpio_data
operator|&
operator|~
name|GPIO_AUDIOMUX_BITS
expr_stmt|;
name|bt848
operator|->
name|gpio_data
operator|=
if|#
directive|if
name|defined
argument_list|(
name|AUDIOMUX_DISCOVER
argument_list|)
name|bt848
operator|->
name|gpio_data
operator|=
name|temp
operator||
operator|(
name|cmd
operator|&
literal|0xff
operator|)
expr_stmt|;
name|printf
argument_list|(
literal|"cmd: %d\n"
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
else|#
directive|else
name|temp
operator||
name|bktr
operator|->
name|card
operator|.
name|audiomuxs
index|[
name|idx
index|]
expr_stmt|;
endif|#
directive|endif
comment|/* AUDIOMUX_DISCOVER */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *   */
end_comment

begin_function
specifier|static
name|void
name|temp_mute
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|,
name|int
name|flag
parameter_list|)
block|{
specifier|static
name|int
name|muteState
init|=
name|FALSE
decl_stmt|;
if|if
condition|(
name|flag
operator|==
name|TRUE
condition|)
block|{
name|muteState
operator|=
name|bktr
operator|->
name|audio_mute_state
expr_stmt|;
name|set_audio
argument_list|(
name|bktr
argument_list|,
name|AUDIO_MUTE
argument_list|)
expr_stmt|;
comment|/* prevent 'click' */
block|}
else|else
block|{
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
name|bktr
argument_list|,
name|PZERO
argument_list|,
literal|"tuning"
argument_list|,
name|hz
operator|/
literal|8
argument_list|)
expr_stmt|;
if|if
condition|(
name|muteState
operator|==
name|FALSE
condition|)
name|set_audio
argument_list|(
name|bktr
argument_list|,
name|AUDIO_UNMUTE
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * setup the dbx chip  * XXX FIXME: alot of work to be done here, this merely unmutes it.  */
end_comment

begin_function
specifier|static
name|int
name|set_BTSC
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|,
name|int
name|control
parameter_list|)
block|{
return|return
operator|(
name|i2cWrite
argument_list|(
name|bktr
argument_list|,
name|TDA9850_WADDR
argument_list|,
name|CON3ADDR
argument_list|,
name|control
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************  * magic:  */
end_comment

begin_expr_stmt
specifier|static
name|bktr_devsw_installed
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|void
name|bktr_drvinit
parameter_list|(
name|void
modifier|*
name|unused
parameter_list|)
block|{
name|dev_t
name|dev
decl_stmt|;
if|if
condition|(
operator|!
name|bktr_devsw_installed
condition|)
block|{
name|dev
operator|=
name|makedev
argument_list|(
name|CDEV_MAJOR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cdevsw_add
argument_list|(
operator|&
name|dev
argument_list|,
operator|&
name|bktr_cdevsw
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|bktr_devsw_installed
operator|=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_macro
name|SYSINIT
argument_list|(
argument|bktrdev
argument_list|,
argument|SI_SUB_DRIVERS
argument_list|,
argument|SI_ORDER_MIDDLE+CDEV_MAJOR
argument_list|,
argument|bktr_drvinit
argument_list|,
argument|NULL
argument_list|)
end_macro

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NBKTR> 0 */
end_comment

begin_comment
comment|/* Local Variables: */
end_comment

begin_comment
comment|/* mode: C */
end_comment

begin_comment
comment|/* c-indent-level: 8 */
end_comment

begin_comment
comment|/* c-brace-offset: -8 */
end_comment

begin_comment
comment|/* c-argdecl-indent: 8 */
end_comment

begin_comment
comment|/* c-label-offset: -8 */
end_comment

begin_comment
comment|/* c-continued-statement-offset: 8 */
end_comment

begin_comment
comment|/* c-tab-always-indent: nil */
end_comment

begin_comment
comment|/* End: */
end_comment

end_unit

