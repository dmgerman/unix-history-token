begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* $FreeBSD$ */
end_comment

begin_comment
comment|/* BT848 Driver for Brooktree's Bt848, Bt848A, Bt849A, Bt878, Bt879 based cards.    The Brooktree  BT848 Driver driver is based upon Mark Tinguely and    Jim Lowe's driver for the Matrox Meteor PCI card . The     Philips SAA 7116 and SAA 7196 are very different chipsets than    the BT848. For starters, the BT848 is a one chipset solution and    it incorporates a RISC engine to control the DMA transfers --    that is it the actual dma process is control by a program which    resides in the hosts memory also the register definitions between    the Philips chipsets and the Bt848 are very different.     The original copyright notice by Mark and Jim is included mostly    to honor their fantastic work in the Matrox Meteor driver!        Enjoy,       Amancio   */
end_comment

begin_comment
comment|/*  * 1. Redistributions of source code must retain the   * Copyright (c) 1997 Amancio Hasty  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by Amancio Hasty  * 4. The name of the author may not be used to endorse or promote products   *    derived from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE  * DISCLAIMED.	IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,  * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN  * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  * POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * 1. Redistributions of source code must retain the   * Copyright (c) 1995 Mark Tinguely and Jim Lowe  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by Mark Tinguely and Jim Lowe  * 4. The name of the author may not be used to endorse or promote products   *    derived from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE  * DISCLAIMED.	IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,  * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN  * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  * POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*		Change History: Note: These version numbers represent the authors own numbering. They are unrelated to Revision Control numbering of FreeBSD or any other system. 1.0		1/24/97	   First Alpha release  1.1		2/20/97	   Added video ioctl so we can do PCI To PCI 			   data transfers. This is for capturing data 			   directly to a vga frame buffer which has 			   a linear frame buffer. Minor code clean-up.  1.3		2/23/97	   Fixed system lock-up reported by  			   Randall Hopper<rhh@ct.picker.com>. This 			   problem seems somehow to be exhibited only 			   in his system. I changed the setting of 			   INT_MASK for CAP_CONTINUOUS to be exactly 			   the same as CAP_SINGLE apparently setting 			   bit 23 cleared the system lock up.  			   version 1.1 of the driver has been reported 			   to work with STB's WinTv, Hauppage's Wincast/Tv 			   and last but not least with the Intel Smart 			   Video Recorder.  1.4		3/9/97	   fsmp@freefall.org 			   Merged code to support tuners on STB and WinCast 			   cards. 			   Modifications to the contrast and chroma ioctls. 			   Textual cleanup.  1.5             3/15/97    fsmp@freefall.org                 	   new bt848 specific versions of hue/bright/                            contrast/satu/satv.                            Amancio's patch to fix "screen freeze" problem.  1.6             3/19/97    fsmp@freefall.org 			   new table-driven frequency lookup. 			   removed disable_intr()/enable_intr() calls from i2c. 			   misc. cleanup.  1.7             3/19/97    fsmp@freefall.org 			   added audio support submitted by: 				Michael Petry<petry@netwolf.NetMasters.com>  1.8             3/20/97    fsmp@freefall.org 			   extended audio support. 			   card auto-detection. 			   major cleanup, order of routines, declarations, etc.  1.9             3/22/97    fsmp@freefall.org 			   merged in Amancio's minor unit for tuner control 			   mods. 			   misc. cleanup, especially in the _intr routine. 			   made AUDIO_SUPPORT mainline code.  1.10            3/23/97    fsmp@freefall.org 			   added polled hardware i2c routines, 			   removed all existing software i2c routines. 			   created software i2cProbe() routine. 			   Randall Hopper's fixes of BT848_GHUE& BT848_GBRIG. 			   eeprom support.  1.11            3/24/97    fsmp@freefall.org 			   Louis Mamakos's new bt848 struct.  1.12		3/25/97    fsmp@freefall.org 			   japanese freq table from Naohiro Shichijo. 			   new table structs for tuner lookups. 			   major scrub for "magic numbers".  1.13		3/28/97    fsmp@freefall.org 			   1st PAL support. 			   MAGIC_[1-4] demarcates magic #s needing PAL work. 			   AFC code submitted by Richard Tobin<richard@cogsci.ed.ac.uk>.  1.14		3/29/97    richard@cogsci.ed.ac.uk 			   PAL support: magic numbers moved into 			   format_params structure. 			   Revised AFC interface. 			   fixed DMA_PROG_ALLOC size misdefinition.  1.15		4/18/97	   John-Mark Gurney<gurney_j@resnet.uoregon.edu>                            Added [SR]RGBMASKs ioctl for byte swapping.  1.16		4/20/97	   Randall Hopper<rhh@ct.picker.com>                            Generalized RGBMASK ioctls for general pixel 			   format setting [SG]ACTPIXFMT, and added query API 			   to return driver-supported pix fmts GSUPPIXFMT.  1.17		4/21/97	   hasty@rah.star-gate.com                            Clipping support added.  1.18		4/23/97	   Clean up after failed CAP_SINGLEs where bt                             interrupt isn't delivered, and fixed fixing  			   CAP_SINGLEs that for ODD_ONLY fields. 1.19            9/8/97     improved yuv support , cleaned up weurope                            channel table, incorporated cleanup work from                            Luigi, fixed pci interface bug due to a                            change in the pci interface which disables                            interrupts from a PCI device by default,                            Added Luigi's, ioctl's BT848_SLNOTCH,                             BT848_GLNOTCH (set luma notch and get luma not) 1.20            10/5/97    Keith Sklower<sklower@CS.Berkeley.EDU> submitted                            a patch to fix compilation of the BSDI's PCI                            interface.                             Hideyuki Suzuki<hideyuki@sat.t.u-tokyo.ac.jp>                            Submitted a patch for Japanese cable channels                            Joao Carlos Mendes Luis jonny@gta.ufrj.br                            Submitted general ioctl to set video broadcast                            formats (PAL, NTSC, etc..) previously we depended                            on the Bt848 auto video detect feature. 1.21            10/24/97   Randall Hopper<rhh@ct.picker.com>                            Fix temporal decimation, disable it when                            doing CAP_SINGLEs, and in dual-field capture, don't                            capture fields for different frames 1.22            11/08/97   Randall Hopper<rhh@ct.picker.com>                            Fixes for packed 24bpp - FIFO alignment 1.23            11/17/97   Amancio<hasty@star-gate.com>                            Added yuv support mpeg encoding  1.24            12/27/97   Jonathan Hanna<pangolin@rogers.wave.ca>                            Patch to support Philips FR1236MK2 tuner 1.25            02/02/98   Takeshi Ohashi<ohashi@atohasi.mickey.ai.kyutech.ac.jp> submitted                            code to support bktr_read .                            Flemming Jacobsen<fj@schizo.dk.tfs.com>                            submitted code to support  radio available with in                            some bt848 based cards;additionally, wrote code to                            correctly recognized his bt848 card.                            Roger Hardiman<roger@cs.strath.ac.uk> submitted                             various fixes to smooth out the microcode and made                             all modes consistent. 1.26                       Moved Luigi's I2CWR ioctl from the video_ioctl                            section to the tuner_ioctl section                            Changed Major device from 79 to 92 and reserved                            our Major device number -- hasty@star-gate.com 1.27                       Last batch of patches for radio support from                            Flemming Jacobsen<fj@trw.nl>.                            Added B849 PCI ID submitted by:                             Tomi Vainio<tomppa@fidata.fi> 1.28                       Frank Nobis<fn@Radio-do.de> added tuner support                            for the  German Phillips PAL tuner and                            additional channels for german cable tv. 1.29                       Roger Hardiman<roger@cs.strath.ac.uk>                            Revised autodetection code to correctly handle both                            old and new VideoLogic Captivator PCI cards.                            Added tsleep of 2 seconds to initialistion code                            for PAL users.Corrected clock selection code on                            format change. 1.30                       Bring back Frank Nobis<fn@Radio-do.de>'s opt_bktr.h  1.31                       Randall Hopper<rhh@ct.picker.com>                            submitted ioctl to clear the video buffer                            prior to starting video capture 			   Amancio : clean up yuv12 so that it does not                            affect rgb capture. Basically, fxtv after                            capturing in yuv12 mode , switching to rgb                            would cause the video capture to be too bright. 1.32                       disable inverse gamma function for rgb and yuv                            capture. fixed meteor brightness ioctl it now                            converts the brightness value from unsigned to                             signed. 1.33                       added sysctl: hw.bt848.tuner, hw.bt848.reverse_mute,                            hw.bt848.card 			   card takes a value from 0 to bt848_max_card                            tuner takes a value from 0 to bt848_max_tuner                            reverse_mute : 0 no effect, 1 reverse tuner                            mute function some tuners are wired reversed :( 1.34                       reverse mute function for ims turbo card  1.35                       Roger Hardiman<roger@cs.strath.ac.uk>                            options BROOKTREE_SYSTEM_DEFAULT=BROOKTREE_PAL                            in the kernel config file makes the driver's                            video_open() function select PAL rather than NTSC.                            This fixed all the hangs on my Dual Crystal card                            when using a PAL video signal. As a result, you                            can loose the tsleep (of 2 seconds - now 0.25!!)                            which I previously added. (Unless someone else                            wanted the 0.25 second tsleep).  1.36                       added bt848.format sysctl variable.                             1 denotes NTSC , 0 denotes PAL  1.37                       added support for Bt878 and improved Hauppauge's                            bt848 tuner recognition 1.38                       Further improvements on Hauppauge's rely on                            eeprom[9] to determine the tuner type 8)                             AVerMedia card type added<sos@freebsd.org>  1.39            08/05/98   Roger Hardiman<roger@cs.strath.ac.uk>                            Updated Hauppauge detection code for Tuner ID 0x0a                             for newer NTSC WinCastTV 404 with Bt878 chipset.                            Tidied up PAL default in video_open()  1.49       10 August 1998  Roger Hardiman<roger@cs.strath.ac.uk>                            Added Capture Area ioctl - BT848[SG]CAPAREA.                            Normally the full 640x480 (768x576 PAL) image                            is grabbed. This ioctl allows a smaller area                            from anywhere within the video image to be                            grabbed, eg a 400x300 image from (50,10).                            See restrictions in BT848SCAPAREA.  1.50       31 August 1998  Roger Hardiman<roger@cs.strath.ac.uk>                            Renamed BT848[SG]CAPAREA to BT848_[SG]CAPAREA.                            Added PR kern/7177 for SECAM Video Highway Xtreme                            with single crystal PLL configuration                            submitted by Vsevolod Lobko<seva@alex-ua.com>.                            In kernel configuration file add                              options OVERRIDE_CARD=2                              options OVERRIDE_TUNER=11                              options BKTR_USE_PLL  1.51       31 August 1998  Roger Hardiman<roger@cs.strath.ac.uk>                            Fixed bug in Miro Tuner detection. Missing Goto.                            Removed Hauppauge EEPROM 0x10 detection as I think 			   0x10 should be a PAL tuner, not NTSC. 			   Reinstated some Tuner Guesswork code from 1.27  1.52           3 Sep 1998  Roger Hardiman<roger@cs.strath.ac.uk>                            Submitted patch by Vsevolod Lobko<seva@alex-ua.com>                            to correct SECAM B-Delay and add XUSSR channel set.  1.53           9 Sep 1998  Roger Hardiman<roger@cs.strath.ac.uk>                            Changed METEORSINPUT for Hauppauge cards with bt878.                            Submitted by Fred Templin<templin@erg.sri.com>                            Also fixed video_open defines and 878 support.  1.54          18 Sep 1998  Roger Hardiman<roger@cs.strath.ac.uk>                            Changed tuner code to autodetect tuner i2c address.                            Addresses were incorrectly hardcoded.  1.55          21 Sep 1998  Roger Hardiman<roger@cs.strath.ac.uk>                            Hauppauge Tech Support confirmed all Hauppauge 878                            PAL/SECAM boards will use PLL mode. 			   Added to card probe. Thanks to Ken and Fred.  1.56    21 Jan 1999 Roger Hardiman<roger@cs.strath.ac.uk>                     Added detection of Hauppauge IR remote control.                     and MSP34xx Audio chip. Fixed i2c read error.                     Hauppauge supplied details of new Tuner Types.                     Danny Braniss<danny@cs.huji.ac.il> submitted Bt878                     AverMedia detection with PCI subsystem vendor id.  1.57    26 Jan 1999 Roger Hardiman<roger@cs.strath.ac.uk>                     Support for MSP3410D / MSP3415D Stereo/Mono audio                     using the audio format Auto Detection Mode.                     Nicolas Souchu<nsouch@freebsd.org> ported the                     msp_read/write/reset functions to smbus/iicbus.                     METEOR_INPUT_DEV2 now selects a composite camera on                     the SVIDEO port for Johan Larsson<gozer@ludd.luth.se>                     For true SVIDEO, use METEOR_INPUT_DEV_SVIDEO  1.58     8 Feb 1999 Roger Hardiman<roger@cs.strath.ac.uk>                     Added check to bktr_mmap from OpenBSD driver.                     Improved MSP34xx reset for bt848 Hauppauge boards.                     Added detection for Bt848a.                     Vsevolod Lobko<seva@sevasoft.alex-ua.com> added                     more XUSSR channels.  1.59     9 Feb 1999 Added ioctl REMOTE_GETKEY for Hauppauge Infra-Red                     Remote Control. Submitted by Roger Hardiman.                     Added ioctl TVTUNER_GETCHANSET and                     BT848_GPIO_SET_EN,BT848_GPIO_SET_DATA (and GETs)                     Submitted by Vsevolod Lobko<seva@alex-ua.com>  1.60    23 Feb 1999 Roger Hardiman<roger@freebsd.org>                     Corrected Mute on Hauppauge Radio cards.                     Autodetect MMAC Osprey by looking for "MMAC" in the EEPROM.                     Added for Jan Schmidt<mmedia@rz.uni-greifswald.de>                     Added ALPS Tuner Type from Hiroki Mori<mori@infocity.co.jp>  1.61    29 Apr 1999 Roger Hardiman<roger@freebsd.org>                     Fix row=0/columns=0 bug. From Randal Hopper<aa8vb@ipass.net>                     Add option to block the reset of the MSP34xx audio chip by                     adding options BKTR_NO_MSP_RESET to the kernel config file.                     This is usefull if you run another operating system                     first to initialise the audio chip, then do a soft reboot.                     Added for Yuri Gindin<yuri@xpert.com>  1.62    29 Apr 1999 Added new cards: NEC PK-UG-X017 and I/O DATA GV-BCTV2/PCI                     Added new tuner: ALPS_TSBH1 (plus FM Radio for ALPS_TSCH5)                     Added support for BCTV audio mux.                     All submitted by Hiroki Mori<mori@infocity.co.jp>   1.63    29 Apr 1999 Roger Hardiman<roger@freebsd.org>                     Added initial code for VBI capture based on work by                     Hiroki Mori<mori@infocity.co.jp> and reworked by myself.                     This allows software decoding of teletext, intercast and                     subtitles via /dev/vbi.  1.64     7 May 1999 Roger Hardiman<roger@freebsd.org>                     Support LifeView FlyVideo 98 cards. Use EEPROM for card                     autodetection. Use bttv's audio mux values.                       Thanks to Paul Reece<paul@fastlane.net.au>,                               Ivan Brawley<brawley@internode.com.au> and                               Gilad Rom<rom_glsa@ein-hashofet.co.il> 		    Automatically locate the EEPROM i2c address and read the 		    subsystem_vendor_id from EEPROM and not the PCI registers.                     Add NSMBUS checks around smbus/iicbus i2c bus code                     making it easier to compile the driver under 2.2.x.                     Add GPIO mask for the audio mux to each card type.                     Add CARD_ZOLTRIX and CARD_KISS from mailing list searches.  1.65    18 May 1999 Roger Hardiman<roger@freebsd.org>                     Change Intel GPIO mask to stop turning the Intel Camera off                     Fixed tuner selection on Hauppauge card with tuner 0x0a                     Replaced none tuner with no tuner for Theo de Raadt.                     Ivan Brawley<brawley@internode.com.au> added                     the Australian channel frequencies.  1.66    19 May 1999 Ivan Brawley<brawley@internode.com.au> added better                     Australian channel frequencies.                      1.67    23 May 1999 Roger Hardiman<roger@freebsd.org>                     Added rgb_vbi_prog() to capture VBI data and video at the                     same time. To capture VBI data, /dev/vbi must be opened                     before starting video capture.  1.68    25 May 1999 Roger Hardiman<roger@freebsd.org>                     Due to differences in PCI bus implementations from various                     motherboard chipset manufactuers, the Bt878/Bt879 has 3                     PCI bus compatibility modes. These are                       NORMAL PCI 2.1  for proper PCI 2.1 compatible chipsets.                       INTEL 430 FX    for the Intel 430 FX chipset.                       SIS VIA CHIPSET for certain SiS and VIA chipsets.                     Older Intel and non-Intel chipsets may also benefit from                     either 430_FX or SIS/VIA mode.                                          NORMAL PCI mode is enabled by default.                     For INTEL 430 FX mode, add this to your kenel config:                            options "BKTR_430_FX_MODE"                     For SiS / VIA mode, add this to your kernel config:                            options "BKTR_SIS_VIA_MODE"                                          Using quotes in these options is not needed in FreeBSD 4.x.                      Note. Newer VIA chipsets should be fully PCI 2.1 compatible                     and should work fine in the Default mode.                      Also rename 849 to 849A, the correct name for the chip.  1.69   12 June 1999 Roger Hardiman<roger@freebsd.org>                     Updates for FreeBSD 4.x device driver interface.                     BSDI code removed. Will be restored later.  1.70   12 July 1999 Roger Hardiman<roger@freebsd.org>                     Reorganise OS device dependant parts (based on a port to                     linux by Brad Parker).                     Make the driver compile on FreeBSD 2.2.x systems again.                     Change number of VBI lines from 16 to 12 for NTSC formats.                     Changes to probeCard() for better eeprom identification.                     Added STB Bt878 card identification.                     Add Hauppauge model identification to probeCard().                     Added TDA9850 initialisation code taken from Linux bttv.                     Juha.Nurmela@quicknet.inet.fi found/fixed bug in VBI_SLEEP.                     Matt Brown<matt@dqc.org> added MSP3430G DBX initialisation. */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__FreeBSD__
end_ifdef

begin_include
include|#
directive|include
file|"bktr.h"
end_include

begin_include
include|#
directive|include
file|"opt_bktr.h"
end_include

begin_include
include|#
directive|include
file|"pci.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __FreeBSD__ */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
operator|||
name|defined
argument_list|(
name|__OpenBSD__
argument_list|)
end_if

begin_include
include|#
directive|include
file|"bktr.h"
end_include

begin_include
include|#
directive|include
file|"pci.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __NetBSD__  || __OpenBSD__ */
end_comment

begin_if
if|#
directive|if
operator|(
expr|\
operator|(
operator|(
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
operator|)
operator|&&
operator|(
name|NBKTR
operator|>
literal|0
operator|)
operator|&&
operator|(
name|NPCI
operator|>
literal|0
operator|)
operator|)
expr|\
operator|||
operator|(
name|defined
argument_list|(
name|__bsdi__
argument_list|)
operator|)
expr|\
operator|||
operator|(
name|defined
argument_list|(
name|__OpenBSD__
argument_list|)
operator|)
expr|\
operator|||
operator|(
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
operator|)
expr|\
operator|)
end_if

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/signalvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/mman.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_kern.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_extern.h>
end_include

begin_comment
comment|/*******************/
end_comment

begin_comment
comment|/* *** FreeBSD *** */
end_comment

begin_comment
comment|/*******************/
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__FreeBSD__
end_ifdef

begin_comment
comment|/* Read NSMBUS on FreeBSD 3.1 or later */
end_comment

begin_if
if|#
directive|if
operator|(
name|__FreeBSD_version
operator|>=
literal|310000
operator|)
end_if

begin_include
include|#
directive|include
file|"smbus.h"
end_include

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|NSMBUS
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|(
name|__FreeBSD_version
operator|>=
literal|400000
operator|)
operator|||
operator|(
name|NSMBUS
operator|>
literal|0
operator|)
end_if

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_comment
comment|/* used by smbus and newbus */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|(
name|__FreeBSD_version
operator|>=
literal|400000
operator|)
end_if

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_comment
comment|/* used by newbus */
end_comment

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_comment
comment|/* used by newbus */
end_comment

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_comment
comment|/* used by newbus */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<machine/clock.h>
end_include

begin_comment
comment|/* for DELAY */
end_comment

begin_include
include|#
directive|include
file|<pci/pcivar.h>
end_include

begin_include
include|#
directive|include
file|<pci/pcireg.h>
end_include

begin_include
include|#
directive|include
file|<machine/ioctl_meteor.h>
end_include

begin_include
include|#
directive|include
file|<machine/ioctl_bt848.h>
end_include

begin_comment
comment|/* extensions to ioctl_meteor.h */
end_comment

begin_include
include|#
directive|include
file|<pci/brktree_reg.h>
end_include

begin_if
if|#
directive|if
operator|(
name|NSMBUS
operator|>
literal|0
operator|)
end_if

begin_include
include|#
directive|include
file|<pci/bt848_i2c.h>
end_include

begin_include
include|#
directive|include
file|<dev/smbus/smbconf.h>
end_include

begin_include
include|#
directive|include
file|<dev/iicbus/iiconf.h>
end_include

begin_include
include|#
directive|include
file|"smbus_if.h"
end_include

begin_include
include|#
directive|include
file|"iicbus_if.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_decl_stmt
specifier|static
name|int
name|bt848_card
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|bt848_tuner
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|bt848_reverse_mute
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|bt848_format
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_hw
argument_list|,
name|OID_AUTO
argument_list|,
name|bt848
argument_list|,
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
literal|"Bt848 Driver mgmt"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_bt848
argument_list|,
name|OID_AUTO
argument_list|,
name|card
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|bt848_card
argument_list|,
operator|-
literal|1
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_bt848
argument_list|,
name|OID_AUTO
argument_list|,
name|tuner
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|bt848_tuner
argument_list|,
operator|-
literal|1
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_bt848
argument_list|,
name|OID_AUTO
argument_list|,
name|reverse_mute
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|bt848_reverse_mute
argument_list|,
operator|-
literal|1
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_bt848
argument_list|,
name|OID_AUTO
argument_list|,
name|format
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|bt848_format
argument_list|,
operator|-
literal|1
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|#
directive|if
operator|(
name|__FreeBSD_version
operator|>=
literal|300000
operator|)
end_if

begin_typedef
typedef|typedef
name|u_long
name|ioctl_cmd_t
typedef|;
end_typedef

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|(
name|__FreeBSD__
operator|==
literal|2
operator|)
end_if

begin_typedef
typedef|typedef
name|int
name|ioctl_cmd_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|unsigned
name|int
name|uintptr_t
typedef|;
end_typedef

begin_define
define|#
directive|define
name|PCIR_REVID
value|PCI_CLASS_REG
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __FreeBSD__ */
end_comment

begin_typedef
typedef|typedef
name|u_char
name|bool_t
typedef|;
end_typedef

begin_define
define|#
directive|define
name|BKTRPRI
value|(PZERO+8)|PCATCH
end_define

begin_comment
comment|/*  * memory allocated for DMA programs  */
end_comment

begin_define
define|#
directive|define
name|DMA_PROG_ALLOC
value|(8 * PAGE_SIZE)
end_define

begin_comment
comment|/* When to split a dma transfer , the bt848 has timing as well as    dma transfer size limitations so that we have to split dma    transfers into two dma requests     */
end_comment

begin_define
define|#
directive|define
name|DMA_BT848_SPLIT
value|319*2
end_define

begin_comment
comment|/*   * Allocate enough memory for:  *	768x576 RGB 16 or YUV (16 storage bits/pixel) = 884736 = 216 pages  *  * You may override this using the options "BROOKTREE_ALLOC_PAGES=value"  * in your  kernel configuration file.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|BROOKTREE_ALLOC_PAGES
end_ifndef

begin_define
define|#
directive|define
name|BROOKTREE_ALLOC_PAGES
value|217*4
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|BROOKTREE_ALLOC
value|(BROOKTREE_ALLOC_PAGES * PAGE_SIZE)
end_define

begin_comment
comment|/* Definitions for VBI capture.  * There are 16 VBI lines in a PAL video field (32 in a frame),  * and we take 2044 samples from each line (placed in a 2048 byte buffer  * for alignment).  * VBI lines are held in a circular buffer before being read by a  * user program from /dev/vbi.  */
end_comment

begin_define
define|#
directive|define
name|MAX_VBI_LINES
value|16
end_define

begin_comment
comment|/* Maximum for all vidoe formats */
end_comment

begin_define
define|#
directive|define
name|VBI_LINE_SIZE
value|2048
end_define

begin_comment
comment|/* Store upto 2048 bytes per line */
end_comment

begin_define
define|#
directive|define
name|VBI_BUFFER_ITEMS
value|20
end_define

begin_comment
comment|/* Number of frames we buffer */
end_comment

begin_define
define|#
directive|define
name|VBI_DATA_SIZE
value|(VBI_LINE_SIZE * MAX_VBI_LINES * 2)
end_define

begin_define
define|#
directive|define
name|VBI_BUFFER_SIZE
value|(VBI_DATA_SIZE * VBI_BUFFER_ITEMS)
end_define

begin_comment
comment|/*  Defines for fields  */
end_comment

begin_define
define|#
directive|define
name|ODD_F
value|0x01
end_define

begin_define
define|#
directive|define
name|EVEN_F
value|0x02
end_define

begin_comment
comment|/*  * Defines for userland processes blocked in this driver  *   For /dev/bktr[n] use memory address of bktr structure  *   For /dev/vbi[n] use memory address of bktr structure + 1  *                   this is ok as the bktr structure is> 1 byte  */
end_comment

begin_define
define|#
directive|define
name|BKTR_SLEEP
value|((caddr_t)bktr    )
end_define

begin_define
define|#
directive|define
name|VBI_SLEEP
value|((caddr_t)bktr + 1)
end_define

begin_comment
comment|/*  * This is for start-up convenience only, NOT mandatory.  */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|DEFAULT_CHNLSET
argument_list|)
end_if

begin_define
define|#
directive|define
name|DEFAULT_CHNLSET
value|CHNLSET_WEUROPE
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Parameters describing size of transmitted image.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|format_params
name|format_params
index|[]
init|=
block|{
comment|/* # define BT848_IFORM_F_AUTO             (0x0) - don't matter. */
block|{
literal|525
block|,
literal|26
block|,
literal|480
block|,
literal|910
block|,
literal|135
block|,
literal|754
block|,
literal|640
block|,
literal|780
block|,
literal|30
block|,
literal|0x68
block|,
literal|0x5d
block|,
name|BT848_IFORM_X_AUTO
block|,
literal|12
block|,
literal|1600
block|}
block|,
comment|/* # define BT848_IFORM_F_NTSCM            (0x1) */
block|{
literal|525
block|,
literal|26
block|,
literal|480
block|,
literal|910
block|,
literal|135
block|,
literal|754
block|,
literal|640
block|,
literal|780
block|,
literal|30
block|,
literal|0x68
block|,
literal|0x5d
block|,
name|BT848_IFORM_X_XT0
block|,
literal|12
block|,
literal|1600
block|}
block|,
comment|/* # define BT848_IFORM_F_NTSCJ            (0x2) */
block|{
literal|525
block|,
literal|22
block|,
literal|480
block|,
literal|910
block|,
literal|135
block|,
literal|754
block|,
literal|640
block|,
literal|780
block|,
literal|30
block|,
literal|0x68
block|,
literal|0x5d
block|,
name|BT848_IFORM_X_XT0
block|,
literal|12
block|,
literal|1600
block|}
block|,
comment|/* # define BT848_IFORM_F_PALBDGHI         (0x3) */
block|{
literal|625
block|,
literal|32
block|,
literal|576
block|,
literal|1135
block|,
literal|186
block|,
literal|924
block|,
literal|768
block|,
literal|944
block|,
literal|25
block|,
literal|0x7f
block|,
literal|0x72
block|,
name|BT848_IFORM_X_XT1
block|,
literal|16
block|,
literal|2044
block|}
block|,
comment|/* # define BT848_IFORM_F_PALM             (0x4) */
block|{
literal|525
block|,
literal|22
block|,
literal|480
block|,
literal|910
block|,
literal|135
block|,
literal|754
block|,
literal|640
block|,
literal|780
block|,
literal|30
block|,
literal|0x68
block|,
literal|0x5d
block|,
name|BT848_IFORM_X_XT0
block|,
literal|12
block|,
literal|1600
block|}
block|,
comment|/* # define BT848_IFORM_F_PALN             (0x5) */
block|{
literal|625
block|,
literal|32
block|,
literal|576
block|,
literal|1135
block|,
literal|186
block|,
literal|924
block|,
literal|768
block|,
literal|944
block|,
literal|25
block|,
literal|0x7f
block|,
literal|0x72
block|,
name|BT848_IFORM_X_XT1
block|,
literal|16
block|,
literal|2044
block|}
block|,
comment|/* # define BT848_IFORM_F_SECAM            (0x6) */
block|{
literal|625
block|,
literal|32
block|,
literal|576
block|,
literal|1135
block|,
literal|186
block|,
literal|924
block|,
literal|768
block|,
literal|944
block|,
literal|25
block|,
literal|0x7f
block|,
literal|0xa0
block|,
name|BT848_IFORM_X_XT1
block|,
literal|16
block|,
literal|2044
block|}
block|,
comment|/* # define BT848_IFORM_F_RSVD             (0x7) - ???? */
block|{
literal|625
block|,
literal|32
block|,
literal|576
block|,
literal|1135
block|,
literal|186
block|,
literal|924
block|,
literal|768
block|,
literal|944
block|,
literal|25
block|,
literal|0x7f
block|,
literal|0x72
block|,
name|BT848_IFORM_X_XT0
block|,
literal|16
block|,
literal|2044
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Table of supported Pixel Formats   */
end_comment

begin_struct
specifier|static
struct|struct
name|meteor_pixfmt_internal
block|{
name|struct
name|meteor_pixfmt
name|public
decl_stmt|;
name|u_int
name|color_fmt
decl_stmt|;
block|}
name|pixfmt_table
index|[]
init|=
block|{
block|{
block|{
literal|0
block|,
name|METEOR_PIXTYPE_RGB
block|,
literal|2
block|,
block|{
literal|0x7c00
block|,
literal|0x03e0
block|,
literal|0x001f
block|}
block|,
literal|0
block|,
literal|0
block|}
block|,
literal|0x33
block|}
block|,
block|{
block|{
literal|0
block|,
name|METEOR_PIXTYPE_RGB
block|,
literal|2
block|,
block|{
literal|0x7c00
block|,
literal|0x03e0
block|,
literal|0x001f
block|}
block|,
literal|1
block|,
literal|0
block|}
block|,
literal|0x33
block|}
block|,
block|{
block|{
literal|0
block|,
name|METEOR_PIXTYPE_RGB
block|,
literal|2
block|,
block|{
literal|0xf800
block|,
literal|0x07e0
block|,
literal|0x001f
block|}
block|,
literal|0
block|,
literal|0
block|}
block|,
literal|0x22
block|}
block|,
block|{
block|{
literal|0
block|,
name|METEOR_PIXTYPE_RGB
block|,
literal|2
block|,
block|{
literal|0xf800
block|,
literal|0x07e0
block|,
literal|0x001f
block|}
block|,
literal|1
block|,
literal|0
block|}
block|,
literal|0x22
block|}
block|,
block|{
block|{
literal|0
block|,
name|METEOR_PIXTYPE_RGB
block|,
literal|3
block|,
block|{
literal|0xff0000
block|,
literal|0x00ff00
block|,
literal|0x0000ff
block|}
block|,
literal|1
block|,
literal|0
block|}
block|,
literal|0x11
block|}
block|,
block|{
block|{
literal|0
block|,
name|METEOR_PIXTYPE_RGB
block|,
literal|4
block|,
block|{
literal|0xff0000
block|,
literal|0x00ff00
block|,
literal|0x0000ff
block|}
block|,
literal|0
block|,
literal|0
block|}
block|,
literal|0x00
block|}
block|,
block|{
block|{
literal|0
block|,
name|METEOR_PIXTYPE_RGB
block|,
literal|4
block|,
block|{
literal|0xff0000
block|,
literal|0x00ff00
block|,
literal|0x0000ff
block|}
block|,
literal|0
block|,
literal|1
block|}
block|,
literal|0x00
block|}
block|,
block|{
block|{
literal|0
block|,
name|METEOR_PIXTYPE_RGB
block|,
literal|4
block|,
block|{
literal|0xff0000
block|,
literal|0x00ff00
block|,
literal|0x0000ff
block|}
block|,
literal|1
block|,
literal|0
block|}
block|,
literal|0x00
block|}
block|,
block|{
block|{
literal|0
block|,
name|METEOR_PIXTYPE_RGB
block|,
literal|4
block|,
block|{
literal|0xff0000
block|,
literal|0x00ff00
block|,
literal|0x0000ff
block|}
block|,
literal|1
block|,
literal|1
block|}
block|,
literal|0x00
block|}
block|,
block|{
block|{
literal|0
block|,
name|METEOR_PIXTYPE_YUV
block|,
literal|2
block|,
block|{
literal|0xff0000
block|,
literal|0x00ff00
block|,
literal|0x0000ff
block|}
block|,
literal|1
block|,
literal|1
block|}
block|,
literal|0x88
block|}
block|,
block|{
block|{
literal|0
block|,
name|METEOR_PIXTYPE_YUV_PACKED
block|,
literal|2
block|,
block|{
literal|0xff0000
block|,
literal|0x00ff00
block|,
literal|0x0000ff
block|}
block|,
literal|0
block|,
literal|1
block|}
block|,
literal|0x44
block|}
block|,
block|{
block|{
literal|0
block|,
name|METEOR_PIXTYPE_YUV_12
block|,
literal|2
block|,
block|{
literal|0xff0000
block|,
literal|0x00ff00
block|,
literal|0x0000ff
block|}
block|,
literal|1
block|,
literal|1
block|}
block|,
literal|0x88
block|}
block|,  }
struct|;
end_struct

begin_define
define|#
directive|define
name|PIXFMT_TABLE_SIZE
value|( sizeof(pixfmt_table) / sizeof(pixfmt_table[0]) )
end_define

begin_comment
comment|/*  * Table of Meteor-supported Pixel Formats (for SETGEO compatibility)  */
end_comment

begin_comment
comment|/*  FIXME:  Also add YUV_422 and YUV_PACKED as well  */
end_comment

begin_struct
specifier|static
struct|struct
block|{
name|u_long
name|meteor_format
decl_stmt|;
name|struct
name|meteor_pixfmt
name|public
decl_stmt|;
block|}
name|meteor_pixfmt_table
index|[]
init|=
block|{
block|{
name|METEOR_GEO_YUV_12
block|,
block|{
literal|0
block|,
name|METEOR_PIXTYPE_YUV_12
block|,
literal|2
block|,
block|{
literal|0xff0000
block|,
literal|0x00ff00
block|,
literal|0x0000ff
block|}
block|,
literal|1
block|,
literal|1
block|}
block|}
block|,
comment|/* FIXME: Should byte swap flag be on for this one; negative in drvr? */
block|{
name|METEOR_GEO_YUV_422
block|,
block|{
literal|0
block|,
name|METEOR_PIXTYPE_YUV
block|,
literal|2
block|,
block|{
literal|0xff0000
block|,
literal|0x00ff00
block|,
literal|0x0000ff
block|}
block|,
literal|1
block|,
literal|1
block|}
block|}
block|,
block|{
name|METEOR_GEO_YUV_PACKED
block|,
block|{
literal|0
block|,
name|METEOR_PIXTYPE_YUV_PACKED
block|,
literal|2
block|,
block|{
literal|0xff0000
block|,
literal|0x00ff00
block|,
literal|0x0000ff
block|}
block|,
literal|0
block|,
literal|1
block|}
block|}
block|,
block|{
name|METEOR_GEO_RGB16
block|,
block|{
literal|0
block|,
name|METEOR_PIXTYPE_RGB
block|,
literal|2
block|,
block|{
literal|0x7c00
block|,
literal|0x03e0
block|,
literal|0x001f
block|}
block|,
literal|0
block|,
literal|0
block|}
block|}
block|,
block|{
name|METEOR_GEO_RGB24
block|,
block|{
literal|0
block|,
name|METEOR_PIXTYPE_RGB
block|,
literal|4
block|,
block|{
literal|0xff0000
block|,
literal|0x00ff00
block|,
literal|0x0000ff
block|}
block|,
literal|0
block|,
literal|0
block|}
block|}
block|,  }
struct|;
end_struct

begin_define
define|#
directive|define
name|METEOR_PIXFMT_TABLE_SIZE
value|( sizeof(meteor_pixfmt_table) / \ 				   sizeof(meteor_pixfmt_table[0]) )
end_define

begin_define
define|#
directive|define
name|BSWAP
value|(BT848_COLOR_CTL_BSWAP_ODD | BT848_COLOR_CTL_BSWAP_EVEN)
end_define

begin_define
define|#
directive|define
name|WSWAP
value|(BT848_COLOR_CTL_WSWAP_ODD | BT848_COLOR_CTL_WSWAP_EVEN)
end_define

begin_comment
comment|/* experimental code for Automatic Frequency Control */
end_comment

begin_define
define|#
directive|define
name|TUNER_AFC
end_define

begin_define
define|#
directive|define
name|TEST_TUNER_AFC_NOT
end_define

begin_if
if|#
directive|if
name|defined
argument_list|(
name|TUNER_AFC
argument_list|)
end_if

begin_define
define|#
directive|define
name|AFC_DELAY
value|10000
end_define

begin_comment
comment|/* 10 millisend delay */
end_comment

begin_define
define|#
directive|define
name|AFC_BITS
value|0x07
end_define

begin_define
define|#
directive|define
name|AFC_FREQ_MINUS_125
value|0x00
end_define

begin_define
define|#
directive|define
name|AFC_FREQ_MINUS_62
value|0x01
end_define

begin_define
define|#
directive|define
name|AFC_FREQ_CENTERED
value|0x02
end_define

begin_define
define|#
directive|define
name|AFC_FREQ_PLUS_62
value|0x03
end_define

begin_define
define|#
directive|define
name|AFC_FREQ_PLUS_125
value|0x04
end_define

begin_define
define|#
directive|define
name|AFC_MAX_STEP
value|(5 * FREQFACTOR)
end_define

begin_comment
comment|/* no more than 5 MHz */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* TUNER_AFC */
end_comment

begin_comment
comment|/*  * i2c things:  */
end_comment

begin_define
define|#
directive|define
name|TSA552x_CB_MSB
value|(0x80)
end_define

begin_define
define|#
directive|define
name|TSA552x_CB_CP
value|(1<<6)
end_define

begin_define
define|#
directive|define
name|TSA552x_CB_T2
value|(1<<5)
end_define

begin_define
define|#
directive|define
name|TSA552x_CB_T1
value|(1<<4)
end_define

begin_define
define|#
directive|define
name|TSA552x_CB_T0
value|(1<<3)
end_define

begin_define
define|#
directive|define
name|TSA552x_CB_RSA
value|(1<<2)
end_define

begin_define
define|#
directive|define
name|TSA552x_CB_RSB
value|(1<<1)
end_define

begin_define
define|#
directive|define
name|TSA552x_CB_OS
value|(1<<0)
end_define

begin_define
define|#
directive|define
name|TSA552x_RADIO
value|(TSA552x_CB_MSB |       \ 				 TSA552x_CB_T0)
end_define

begin_comment
comment|/* Add RADIO_OFFSET to the "frequency" to indicate that we want to tune	*/
end_comment

begin_comment
comment|/* the radio (if present) not the TV tuner.				*/
end_comment

begin_comment
comment|/* 20000 is equivalent to 20000MHz/16 = 1.25GHz - this area is unused.	*/
end_comment

begin_define
define|#
directive|define
name|RADIO_OFFSET
value|20000
end_define

begin_comment
comment|/* address(s) of the Hauppauge Infra-Red Remote Control adapter */
end_comment

begin_define
define|#
directive|define
name|HAUP_REMOTE_INT_WADDR
value|0x30
end_define

begin_define
define|#
directive|define
name|HAUP_REMOTE_INT_RADDR
value|0x31
end_define

begin_define
define|#
directive|define
name|HAUP_REMOTE_EXT_WADDR
value|0x34
end_define

begin_define
define|#
directive|define
name|HAUP_REMOTE_EXT_RADDR
value|0x35
end_define

begin_comment
comment|/* address of BTSC/SAP decoder chip */
end_comment

begin_define
define|#
directive|define
name|TDA9850_WADDR
value|0xb6
end_define

begin_define
define|#
directive|define
name|TDA9850_RADDR
value|0xb7
end_define

begin_comment
comment|/* address of MSP3400C chip */
end_comment

begin_define
define|#
directive|define
name|MSP3400C_WADDR
value|0x80
end_define

begin_define
define|#
directive|define
name|MSP3400C_RADDR
value|0x81
end_define

begin_comment
comment|/* EEProm (128 * 8) on an STB card */
end_comment

begin_define
define|#
directive|define
name|X24C01_WADDR
value|0xae
end_define

begin_define
define|#
directive|define
name|X24C01_RADDR
value|0xaf
end_define

begin_comment
comment|/* EEProm (256 * 8) on a Hauppauge card */
end_comment

begin_comment
comment|/* and on most BT878s cards to store the sub-system vendor id */
end_comment

begin_define
define|#
directive|define
name|PFC8582_WADDR
value|0xa0
end_define

begin_define
define|#
directive|define
name|PFC8582_RADDR
value|0xa1
end_define

begin_comment
comment|/* registers in the TDA9850 BTSC/dbx chip */
end_comment

begin_define
define|#
directive|define
name|CON1ADDR
value|0x04
end_define

begin_define
define|#
directive|define
name|CON2ADDR
value|0x05
end_define

begin_define
define|#
directive|define
name|CON3ADDR
value|0x06
end_define

begin_define
define|#
directive|define
name|CON4ADDR
value|0x07
end_define

begin_define
define|#
directive|define
name|ALI1ADDR
value|0x08
end_define

begin_define
define|#
directive|define
name|ALI2ADDR
value|0x09
end_define

begin_define
define|#
directive|define
name|ALI3ADDR
value|0x0a
end_define

begin_comment
comment|/* raise the charge pump voltage for fast tuning */
end_comment

begin_define
define|#
directive|define
name|TSA552x_FCONTROL
value|(TSA552x_CB_MSB |	\ 				 TSA552x_CB_CP  |	\ 				 TSA552x_CB_T0  |	\ 				 TSA552x_CB_RSA |	\ 				 TSA552x_CB_RSB)
end_define

begin_comment
comment|/* lower the charge pump voltage for better residual oscillator FM */
end_comment

begin_define
define|#
directive|define
name|TSA552x_SCONTROL
value|(TSA552x_CB_MSB |	\ 				 TSA552x_CB_T0  |	\ 				 TSA552x_CB_RSA |	\ 				 TSA552x_CB_RSB)
end_define

begin_comment
comment|/* The control value for the ALPS TSCH5 Tuner */
end_comment

begin_define
define|#
directive|define
name|TSCH5_FCONTROL
value|0x82
end_define

begin_define
define|#
directive|define
name|TSCH5_RADIO
value|0x86
end_define

begin_comment
comment|/* The control value for the ALPS TSBH1 Tuner */
end_comment

begin_define
define|#
directive|define
name|TSBH1_FCONTROL
value|0xce
end_define

begin_comment
comment|/* sync detect threshold */
end_comment

begin_if
if|#
directive|if
literal|0
end_if

begin_define
define|#
directive|define
name|SYNC_LEVEL
value|(BT848_ADC_RESERVED |	\ 				 BT848_ADC_CRUSH)
end_define

begin_comment
comment|/* threshold ~125 mV */
end_comment

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|SYNC_LEVEL
value|(BT848_ADC_RESERVED |	\ 				 BT848_ADC_SYNC_T)
end_define

begin_comment
comment|/* threshold ~75 mV */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * the data for each type of tuner  *  * if probeCard() fails to detect the proper tuner on boot you can  * override it by setting the following define to the tuner present:  * #define OVERRIDE_TUNER<tuner type>  *  * where<tuner type> is one of the following tuner defines.  */
end_comment

begin_comment
comment|/* indexes into tuners[] */
end_comment

begin_define
define|#
directive|define
name|NO_TUNER
value|0
end_define

begin_define
define|#
directive|define
name|TEMIC_NTSC
value|1
end_define

begin_define
define|#
directive|define
name|TEMIC_PAL
value|2
end_define

begin_define
define|#
directive|define
name|TEMIC_SECAM
value|3
end_define

begin_define
define|#
directive|define
name|PHILIPS_NTSC
value|4
end_define

begin_define
define|#
directive|define
name|PHILIPS_PAL
value|5
end_define

begin_define
define|#
directive|define
name|PHILIPS_SECAM
value|6
end_define

begin_define
define|#
directive|define
name|TEMIC_PALI
value|7
end_define

begin_define
define|#
directive|define
name|PHILIPS_PALI
value|8
end_define

begin_define
define|#
directive|define
name|PHILIPS_FR1236_NTSC
value|9
end_define

begin_define
define|#
directive|define
name|PHILIPS_FR1216_PAL
value|10
end_define

begin_define
define|#
directive|define
name|PHILIPS_FR1236_SECAM
value|11
end_define

begin_define
define|#
directive|define
name|ALPS_TSCH5
value|12
end_define

begin_define
define|#
directive|define
name|ALPS_TSBH1
value|13
end_define

begin_define
define|#
directive|define
name|Bt848_MAX_TUNER
value|14
end_define

begin_comment
comment|/* If we do not know the tuner type, make a guess based on the    video format */
end_comment

begin_if
if|#
directive|if
name|BROOKTREE_SYSTEM_DEFAULT
operator|==
name|BROOKTREE_PAL
end_if

begin_define
define|#
directive|define
name|DEFAULT_TUNER
value|PHILIPS_PALI
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|DEFAULT_TUNER
value|PHILIPS_NTSC
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* XXX FIXME: this list is incomplete */
end_comment

begin_comment
comment|/* input types */
end_comment

begin_define
define|#
directive|define
name|TTYPE_XXX
value|0
end_define

begin_define
define|#
directive|define
name|TTYPE_NTSC
value|1
end_define

begin_define
define|#
directive|define
name|TTYPE_NTSC_J
value|2
end_define

begin_define
define|#
directive|define
name|TTYPE_PAL
value|3
end_define

begin_define
define|#
directive|define
name|TTYPE_PAL_M
value|4
end_define

begin_define
define|#
directive|define
name|TTYPE_PAL_N
value|5
end_define

begin_define
define|#
directive|define
name|TTYPE_SECAM
value|6
end_define

begin_comment
comment|/** struct TUNER { 	char*		name; 	u_char		type; 	u_char		pllControl; 	u_char		bandLimits[ 2 ]; 	u_char		bandAddrs[ 3 ]; };  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|TUNER
name|tuners
index|[]
init|=
block|{
comment|/* XXX FIXME: fill in the band-switch crosspoints */
comment|/* NO_TUNER */
block|{
literal|"<no>"
block|,
comment|/* the 'name' */
name|TTYPE_XXX
block|,
comment|/* input type */
block|{
literal|0x00
block|,
comment|/* control byte for Tuner PLL */
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|}
block|,
block|{
literal|0x00
block|,
literal|0x00
block|}
block|,
comment|/* band-switch crosspoints */
block|{
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|}
block|}
block|,
comment|/* the band-switch values */
comment|/* TEMIC_NTSC */
block|{
literal|"Temic NTSC"
block|,
comment|/* the 'name' */
name|TTYPE_NTSC
block|,
comment|/* input type */
block|{
name|TSA552x_SCONTROL
block|,
comment|/* control byte for Tuner PLL */
name|TSA552x_SCONTROL
block|,
name|TSA552x_SCONTROL
block|,
literal|0x00
block|}
block|,
block|{
literal|0x00
block|,
literal|0x00
block|}
block|,
comment|/* band-switch crosspoints */
block|{
literal|0x02
block|,
literal|0x04
block|,
literal|0x01
block|,
literal|0x00
block|}
block|}
block|,
comment|/* the band-switch values */
comment|/* TEMIC_PAL */
block|{
literal|"Temic PAL"
block|,
comment|/* the 'name' */
name|TTYPE_PAL
block|,
comment|/* input type */
block|{
name|TSA552x_SCONTROL
block|,
comment|/* control byte for Tuner PLL */
name|TSA552x_SCONTROL
block|,
name|TSA552x_SCONTROL
block|,
literal|0x00
block|}
block|,
block|{
literal|0x00
block|,
literal|0x00
block|}
block|,
comment|/* band-switch crosspoints */
block|{
literal|0x02
block|,
literal|0x04
block|,
literal|0x01
block|,
literal|0x00
block|}
block|}
block|,
comment|/* the band-switch values */
comment|/* TEMIC_SECAM */
block|{
literal|"Temic SECAM"
block|,
comment|/* the 'name' */
name|TTYPE_SECAM
block|,
comment|/* input type */
block|{
name|TSA552x_SCONTROL
block|,
comment|/* control byte for Tuner PLL */
name|TSA552x_SCONTROL
block|,
name|TSA552x_SCONTROL
block|,
literal|0x00
block|}
block|,
block|{
literal|0x00
block|,
literal|0x00
block|}
block|,
comment|/* band-switch crosspoints */
block|{
literal|0x02
block|,
literal|0x04
block|,
literal|0x01
block|,
literal|0x00
block|}
block|}
block|,
comment|/* the band-switch values */
comment|/* PHILIPS_NTSC */
block|{
literal|"Philips NTSC"
block|,
comment|/* the 'name' */
name|TTYPE_NTSC
block|,
comment|/* input type */
block|{
name|TSA552x_SCONTROL
block|,
comment|/* control byte for Tuner PLL */
name|TSA552x_SCONTROL
block|,
name|TSA552x_SCONTROL
block|,
literal|0x00
block|}
block|,
block|{
literal|0x00
block|,
literal|0x00
block|}
block|,
comment|/* band-switch crosspoints */
block|{
literal|0xa0
block|,
literal|0x90
block|,
literal|0x30
block|,
literal|0x00
block|}
block|}
block|,
comment|/* the band-switch values */
comment|/* PHILIPS_PAL */
block|{
literal|"Philips PAL"
block|,
comment|/* the 'name' */
name|TTYPE_PAL
block|,
comment|/* input type */
block|{
name|TSA552x_FCONTROL
block|,
comment|/* control byte for Tuner PLL */
name|TSA552x_FCONTROL
block|,
name|TSA552x_FCONTROL
block|,
name|TSA552x_RADIO
block|}
block|,
block|{
literal|0x00
block|,
literal|0x00
block|}
block|,
comment|/* band-switch crosspoints */
block|{
literal|0xa0
block|,
literal|0x90
block|,
literal|0x30
block|,
literal|0xa4
block|}
block|}
block|,
comment|/* the band-switch values */
comment|/* PHILIPS_SECAM */
block|{
literal|"Philips SECAM"
block|,
comment|/* the 'name' */
name|TTYPE_SECAM
block|,
comment|/* input type */
block|{
name|TSA552x_SCONTROL
block|,
comment|/* control byte for Tuner PLL */
name|TSA552x_SCONTROL
block|,
name|TSA552x_SCONTROL
block|,
name|TSA552x_RADIO
block|}
block|,
block|{
literal|0x00
block|,
literal|0x00
block|}
block|,
comment|/* band-switch crosspoints */
block|{
literal|0xa0
block|,
literal|0x90
block|,
literal|0x30
block|,
literal|0xa4
block|}
block|}
block|,
comment|/* the band-switch values */
comment|/* TEMIC_PAL I */
block|{
literal|"Temic PAL I"
block|,
comment|/* the 'name' */
name|TTYPE_PAL
block|,
comment|/* input type */
block|{
name|TSA552x_SCONTROL
block|,
comment|/* control byte for Tuner PLL */
name|TSA552x_SCONTROL
block|,
name|TSA552x_SCONTROL
block|,
literal|0x00
block|}
block|,
block|{
literal|0x00
block|,
literal|0x00
block|}
block|,
comment|/* band-switch crosspoints */
block|{
literal|0x02
block|,
literal|0x04
block|,
literal|0x01
block|,
literal|0x00
block|}
block|}
block|,
comment|/* the band-switch values */
comment|/* PHILIPS_PAL */
block|{
literal|"Philips PAL I"
block|,
comment|/* the 'name' */
name|TTYPE_PAL
block|,
comment|/* input type */
block|{
name|TSA552x_SCONTROL
block|,
comment|/* control byte for Tuner PLL */
name|TSA552x_SCONTROL
block|,
name|TSA552x_SCONTROL
block|,
literal|0x00
block|}
block|,
block|{
literal|0x00
block|,
literal|0x00
block|}
block|,
comment|/* band-switch crosspoints */
block|{
literal|0xa0
block|,
literal|0x90
block|,
literal|0x30
block|,
literal|0x00
block|}
block|}
block|,
comment|/* the band-switch values */
comment|/* PHILIPS_FR1236_NTSC */
block|{
literal|"Philips FR1236 NTSC FM"
block|,
comment|/* the 'name' */
name|TTYPE_NTSC
block|,
comment|/* input type */
block|{
name|TSA552x_SCONTROL
block|,
comment|/* control byte for Tuner PLL */
name|TSA552x_SCONTROL
block|,
name|TSA552x_SCONTROL
block|,
name|TSA552x_RADIO
block|}
block|,
block|{
literal|0x00
block|,
literal|0x00
block|}
block|,
comment|/* band-switch crosspoints */
block|{
literal|0xa0
block|,
literal|0x90
block|,
literal|0x30
block|,
literal|0xa4
block|}
block|}
block|,
comment|/* the band-switch values */
comment|/* PHILIPS_FR1216_PAL */
block|{
literal|"Philips FR1216 PAL"
block|,
comment|/* the 'name' */
name|TTYPE_PAL
block|,
comment|/* input type */
block|{
name|TSA552x_FCONTROL
block|,
comment|/* control byte for Tuner PLL */
name|TSA552x_FCONTROL
block|,
name|TSA552x_FCONTROL
block|,
name|TSA552x_RADIO
block|}
block|,
block|{
literal|0x00
block|,
literal|0x00
block|}
block|,
comment|/* band-switch crosspoints */
block|{
literal|0xa0
block|,
literal|0x90
block|,
literal|0x30
block|,
literal|0xa4
block|}
block|}
block|,
comment|/* the band-switch values */
comment|/* PHILIPS_FR1236_SECAM */
block|{
literal|"Philips FR1236 SECAM FM"
block|,
comment|/* the 'name' */
name|TTYPE_SECAM
block|,
comment|/* input type */
block|{
name|TSA552x_FCONTROL
block|,
comment|/* control byte for Tuner PLL */
name|TSA552x_FCONTROL
block|,
name|TSA552x_FCONTROL
block|,
name|TSA552x_RADIO
block|}
block|,
block|{
literal|0x00
block|,
literal|0x00
block|}
block|,
comment|/* band-switch crosspoints */
block|{
literal|0xa0
block|,
literal|0x90
block|,
literal|0x30
block|,
literal|0xa4
block|}
block|}
block|,
comment|/* the band-switch values */
comment|/* ALPS TSCH5 NTSC */
block|{
literal|"ALPS TSCH5"
block|,
comment|/* the 'name' */
name|TTYPE_NTSC
block|,
comment|/* input type */
block|{
name|TSCH5_FCONTROL
block|,
comment|/* control byte for Tuner PLL */
name|TSCH5_FCONTROL
block|,
name|TSCH5_FCONTROL
block|,
name|TSCH5_RADIO
block|}
block|,
block|{
literal|0x00
block|,
literal|0x00
block|}
block|,
comment|/* band-switch crosspoints */
block|{
literal|0x14
block|,
literal|0x12
block|,
literal|0x11
block|,
literal|0x04
block|}
block|}
block|,
comment|/* the band-switch values */
comment|/* ALPS TSBH1 NTSC */
block|{
literal|"ALPS TSBH1"
block|,
comment|/* the 'name' */
name|TTYPE_NTSC
block|,
comment|/* input type */
block|{
name|TSBH1_FCONTROL
block|,
comment|/* control byte for Tuner PLL */
name|TSBH1_FCONTROL
block|,
name|TSBH1_FCONTROL
block|,
literal|0x00
block|}
block|,
block|{
literal|0x00
block|,
literal|0x00
block|}
block|,
comment|/* band-switch crosspoints */
block|{
literal|0x01
block|,
literal|0x02
block|,
literal|0x08
block|,
literal|0x00
block|}
block|}
comment|/* the band-switch values */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/******************************************************************************  * card probe  */
end_comment

begin_comment
comment|/*  * the recognized cards, used as indexes of several tables.  *  * if probeCard() fails to detect the proper card on boot you can  * override it by setting the following define to the card you are using:  * #define OVERRIDE_CARD<card type>  *  * where<card type> is one of the following card defines.  */
end_comment

begin_define
define|#
directive|define
name|CARD_UNKNOWN
value|0
end_define

begin_define
define|#
directive|define
name|CARD_MIRO
value|1
end_define

begin_define
define|#
directive|define
name|CARD_HAUPPAUGE
value|2
end_define

begin_define
define|#
directive|define
name|CARD_STB
value|3
end_define

begin_define
define|#
directive|define
name|CARD_INTEL
value|4
end_define

begin_define
define|#
directive|define
name|CARD_IMS_TURBO
value|5
end_define

begin_define
define|#
directive|define
name|CARD_AVER_MEDIA
value|6
end_define

begin_define
define|#
directive|define
name|CARD_OSPREY
value|7
end_define

begin_define
define|#
directive|define
name|CARD_NEC_PK
value|8
end_define

begin_define
define|#
directive|define
name|CARD_IO_GV
value|9
end_define

begin_define
define|#
directive|define
name|CARD_FLYVIDEO
value|10
end_define

begin_define
define|#
directive|define
name|CARD_ZOLTRIX
value|11
end_define

begin_define
define|#
directive|define
name|CARD_KISS
value|12
end_define

begin_define
define|#
directive|define
name|Bt848_MAX_CARD
value|13
end_define

begin_comment
comment|/*  * the data for each type of card  *  * Note:  *   these entried MUST be kept in the order defined by the CARD_XXX defines!  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|CARDTYPE
name|cards
index|[]
init|=
block|{
block|{
name|CARD_UNKNOWN
block|,
comment|/* the card id */
literal|"Unknown"
block|,
comment|/* the 'name' */
name|NULL
block|,
comment|/* the tuner */
literal|0
block|,
comment|/* the tuner i2c address */
literal|0
block|,
comment|/* dbx unknown */
literal|0
block|,
literal|0
block|,
comment|/* EEProm unknown */
literal|0
block|,
comment|/* EEProm unknown */
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
literal|0
block|}
block|,
comment|/* GPIO mask */
block|{
name|CARD_MIRO
block|,
comment|/* the card id */
literal|"Miro TV"
block|,
comment|/* the 'name' */
name|NULL
block|,
comment|/* the tuner */
literal|0
block|,
comment|/* the tuner i2c address */
literal|0
block|,
comment|/* dbx unknown */
literal|0
block|,
literal|0
block|,
comment|/* EEProm unknown */
literal|0
block|,
comment|/* size unknown */
block|{
literal|0x02
block|,
literal|0x01
block|,
literal|0x00
block|,
literal|0x0a
block|,
literal|1
block|}
block|,
comment|/* audio MUX values */
literal|0x0f
block|}
block|,
comment|/* GPIO mask */
block|{
name|CARD_HAUPPAUGE
block|,
comment|/* the card id */
literal|"Hauppauge WinCast/TV"
block|,
comment|/* the 'name' */
name|NULL
block|,
comment|/* the tuner */
literal|0
block|,
comment|/* the tuner i2c address */
literal|0
block|,
comment|/* dbx is optional */
literal|0
block|,
name|PFC8582_WADDR
block|,
comment|/* EEProm type */
call|(
name|u_char
call|)
argument_list|(
literal|256
operator|/
name|EEPROMBLOCKSIZE
argument_list|)
block|,
comment|/* 256 bytes */
block|{
literal|0x00
block|,
literal|0x02
block|,
literal|0x01
block|,
literal|0x04
block|,
literal|1
block|}
block|,
comment|/* audio MUX values */
literal|0x0f
block|}
block|,
comment|/* GPIO mask */
block|{
name|CARD_STB
block|,
comment|/* the card id */
literal|"STB TV/PCI"
block|,
comment|/* the 'name' */
name|NULL
block|,
comment|/* the tuner */
literal|0
block|,
comment|/* the tuner i2c address */
literal|0
block|,
comment|/* dbx is optional */
literal|0
block|,
name|X24C01_WADDR
block|,
comment|/* EEProm type */
call|(
name|u_char
call|)
argument_list|(
literal|128
operator|/
name|EEPROMBLOCKSIZE
argument_list|)
block|,
comment|/* 128 bytes */
block|{
literal|0x00
block|,
literal|0x01
block|,
literal|0x02
block|,
literal|0x02
block|,
literal|1
block|}
block|,
comment|/* audio MUX values */
literal|0x0f
block|}
block|,
comment|/* GPIO mask */
block|{
name|CARD_INTEL
block|,
comment|/* the card id */
literal|"Intel Smart Video III/VideoLogic Captivator PCI"
block|,
comment|/* the 'name' */
name|NULL
block|,
comment|/* the tuner */
literal|0
block|,
comment|/* the tuner i2c address */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* audio MUX values */
literal|0x00
block|}
block|,
comment|/* GPIO mask */
block|{
name|CARD_IMS_TURBO
block|,
comment|/* the card id */
literal|"IMS TV Turbo"
block|,
comment|/* the 'name' */
name|NULL
block|,
comment|/* the tuner */
literal|0
block|,
comment|/* the tuner i2c address */
literal|0
block|,
comment|/* dbx is optional */
literal|0
block|,
name|PFC8582_WADDR
block|,
comment|/* EEProm type */
call|(
name|u_char
call|)
argument_list|(
literal|256
operator|/
name|EEPROMBLOCKSIZE
argument_list|)
block|,
comment|/* 256 bytes */
block|{
literal|0x01
block|,
literal|0x02
block|,
literal|0x01
block|,
literal|0x00
block|,
literal|1
block|}
block|,
comment|/* audio MUX values */
literal|0x0f
block|}
block|,
comment|/* GPIO mask */
block|{
name|CARD_AVER_MEDIA
block|,
comment|/* the card id */
literal|"AVer Media TV/FM"
block|,
comment|/* the 'name' */
name|NULL
block|,
comment|/* the tuner */
literal|0
block|,
comment|/* the tuner i2c address */
literal|0
block|,
comment|/* dbx is optional */
literal|0
block|,
literal|0
block|,
comment|/* EEProm type */
literal|0
block|,
comment|/* EEProm size */
block|{
literal|0x0c
block|,
literal|0x00
block|,
literal|0x0b
block|,
literal|0x0b
block|,
literal|1
block|}
block|,
comment|/* audio MUX values */
literal|0x0f
block|}
block|,
comment|/* GPIO mask */
block|{
name|CARD_OSPREY
block|,
comment|/* the card id */
literal|"MMAC Osprey"
block|,
comment|/* the 'name' */
name|NULL
block|,
comment|/* the tuner */
literal|0
block|,
comment|/* the tuner i2c address */
literal|0
block|,
comment|/* dbx is optional */
literal|0
block|,
name|PFC8582_WADDR
block|,
comment|/* EEProm type */
call|(
name|u_char
call|)
argument_list|(
literal|256
operator|/
name|EEPROMBLOCKSIZE
argument_list|)
block|,
comment|/* 256 bytes */
block|{
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0
block|}
block|,
comment|/* audio MUX values */
literal|0
block|}
block|,
comment|/* GPIO mask */
block|{
name|CARD_NEC_PK
block|,
comment|/* the card id */
literal|"NEC PK-UG-X017"
block|,
comment|/* the 'name' */
name|NULL
block|,
comment|/* the tuner */
literal|0
block|,
comment|/* the tuner i2c address */
literal|0
block|,
comment|/* dbx is optional */
literal|0
block|,
literal|0
block|,
comment|/* EEProm type */
literal|0
block|,
comment|/* EEProm size */
block|{
literal|0x01
block|,
literal|0x02
block|,
literal|0x01
block|,
literal|0x00
block|,
literal|1
block|}
block|,
comment|/* audio MUX values */
literal|0x0f
block|}
block|,
comment|/* GPIO mask */
block|{
name|CARD_IO_GV
block|,
comment|/* the card id */
literal|"I/O DATA GV-BCTV2/PCI"
block|,
comment|/* the 'name' */
name|NULL
block|,
comment|/* the tuner */
literal|0
block|,
comment|/* the tuner i2c address */
literal|0
block|,
comment|/* dbx is optional */
literal|0
block|,
literal|0
block|,
comment|/* EEProm type */
literal|0
block|,
comment|/* EEProm size */
block|{
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|1
block|}
block|,
comment|/* Has special MUX handler */
literal|0x0f
block|}
block|,
comment|/* GPIO mask */
block|{
name|CARD_FLYVIDEO
block|,
comment|/* the card id */
literal|"FlyVideo"
block|,
comment|/* the 'name' */
name|NULL
block|,
comment|/* the tuner */
literal|0
block|,
comment|/* the tuner i2c address */
literal|0
block|,
comment|/* dbx is optional */
literal|0
block|,
comment|/* msp34xx is optional */
literal|0xac
block|,
comment|/* EEProm type */
call|(
name|u_char
call|)
argument_list|(
literal|256
operator|/
name|EEPROMBLOCKSIZE
argument_list|)
block|,
comment|/* 256 bytes */
block|{
literal|0x000
block|,
literal|0x800
block|,
literal|0x400
block|,
literal|0x8dff00
block|,
literal|1
block|}
block|,
comment|/* audio MUX values */
literal|0x8dff00
block|}
block|,
comment|/* GPIO mask */
block|{
name|CARD_ZOLTRIX
block|,
comment|/* the card id */
literal|"Zoltrix"
block|,
comment|/* the 'name' */
name|NULL
block|,
comment|/* the tuner */
literal|0
block|,
comment|/* the tuner i2c address */
literal|0
block|,
comment|/* dbx is optional */
literal|0
block|,
comment|/* msp34xx is optional */
literal|0
block|,
comment|/* EEProm type */
literal|0
block|,
comment|/* EEProm size */
block|{
literal|0x04
block|,
literal|0x01
block|,
literal|0x00
block|,
literal|0x0a
block|,
literal|1
block|}
block|,
comment|/* audio MUX values */
literal|0x0f
block|}
block|,
comment|/* GPIO mask */
block|{
name|CARD_KISS
block|,
comment|/* the card id */
literal|"KISS TV/FM PCI"
block|,
comment|/* the 'name' */
name|NULL
block|,
comment|/* the tuner */
literal|0
block|,
comment|/* the tuner i2c address */
literal|0
block|,
comment|/* dbx is optional */
literal|0
block|,
comment|/* msp34xx is optional */
literal|0
block|,
comment|/* EEProm type */
literal|0
block|,
comment|/* EEProm size */
block|{
literal|0x0c
block|,
literal|0x00
block|,
literal|0x0b
block|,
literal|0x0b
block|,
literal|1
block|}
block|,
comment|/* audio MUX values */
literal|0x0f
block|}
block|,
comment|/* GPIO mask */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|bt848_card_sig
name|bt848_card_signature
index|[
literal|1
index|]
init|=
block|{
comment|/* IMS TURBO TV : card 5 */
block|{
literal|5
block|,
literal|9
block|,
block|{
literal|00
block|,
literal|00
block|,
literal|00
block|,
literal|00
block|,
literal|00
block|,
literal|00
block|,
literal|00
block|,
literal|00
block|,
literal|00
block|,
literal|00
block|,
literal|00
block|,
literal|00
block|,
literal|02
block|,
literal|00
block|,
literal|00
block|,
literal|00
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* debug utility for holding previous INT_STAT contents */
end_comment

begin_define
define|#
directive|define
name|STATUS_SUM
end_define

begin_decl_stmt
specifier|static
name|u_long
name|status_sum
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * defines to make certain bit-fiddles understandable  */
end_comment

begin_define
define|#
directive|define
name|FIFO_ENABLED
value|BT848_DMA_CTL_FIFO_EN
end_define

begin_define
define|#
directive|define
name|RISC_ENABLED
value|BT848_DMA_CTL_RISC_EN
end_define

begin_define
define|#
directive|define
name|FIFO_RISC_ENABLED
value|(BT848_DMA_CTL_FIFO_EN | BT848_DMA_CTL_RISC_EN)
end_define

begin_define
define|#
directive|define
name|FIFO_RISC_DISABLED
value|0
end_define

begin_define
define|#
directive|define
name|ALL_INTS_DISABLED
value|0
end_define

begin_define
define|#
directive|define
name|ALL_INTS_CLEARED
value|0xffffffff
end_define

begin_define
define|#
directive|define
name|CAPTURE_OFF
value|0
end_define

begin_define
define|#
directive|define
name|BIT_SEVEN_HIGH
value|(1<<7)
end_define

begin_define
define|#
directive|define
name|BIT_EIGHT_HIGH
value|(1<<8)
end_define

begin_define
define|#
directive|define
name|I2C_BITS
value|(BT848_INT_RACK | BT848_INT_I2CDONE)
end_define

begin_define
define|#
directive|define
name|TDEC_BITS
value|(BT848_INT_FDSR | BT848_INT_FBUS)
end_define

begin_comment
comment|/*  * misc. support routines.  */
end_comment

begin_function_decl
specifier|static
name|int
name|signCard
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|count
parameter_list|,
name|u_char
modifier|*
name|sig
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|probeCard
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|,
name|int
name|verbose
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|common_bktr_attach
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|,
name|int
name|unit
parameter_list|,
name|u_long
name|pci_id
parameter_list|,
name|u_int
name|rev
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/**************************************************/
end_comment

begin_comment
comment|/* *** Memory Allocation is still OS specific *** */
end_comment

begin_comment
comment|/**************************************************/
end_comment

begin_if
if|#
directive|if
operator|(
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
operator|||
name|defined
argument_list|(
name|__bsdi__
argument_list|)
operator|)
end_if

begin_function_decl
specifier|static
name|vm_offset_t
name|get_bktr_mem
parameter_list|(
name|int
name|unit
parameter_list|,
name|unsigned
name|size
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|(
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
operator|||
name|defined
argument_list|(
name|__OpenBSD__
argument_list|)
operator|)
end_if

begin_function_decl
specifier|static
name|vm_offset_t
name|get_bktr_mem
parameter_list|(
name|bktr_ptr_t
parameter_list|,
name|bus_dmamap_t
modifier|*
parameter_list|,
name|unsigned
name|size
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|free_bktr_mem
parameter_list|(
name|bktr_ptr_t
parameter_list|,
name|bus_dmamap_t
parameter_list|,
name|vm_offset_t
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|int
name|oformat_meteor_to_bt
parameter_list|(
name|u_long
name|format
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u_int
name|pixfmt_swap_flags
parameter_list|(
name|int
name|pixfmt
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * bt848 RISC programming routines.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|BT848_DUMP
end_ifdef

begin_function_decl
specifier|static
name|int
name|dump_bt848
parameter_list|(
name|bt848_ptr_t
name|bt848
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|yuvpack_prog
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|,
name|char
name|i_flag
parameter_list|,
name|int
name|cols
parameter_list|,
name|int
name|rows
parameter_list|,
name|int
name|interlace
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|yuv422_prog
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|,
name|char
name|i_flag
parameter_list|,
name|int
name|cols
parameter_list|,
name|int
name|rows
parameter_list|,
name|int
name|interlace
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|yuv12_prog
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|,
name|char
name|i_flag
parameter_list|,
name|int
name|cols
parameter_list|,
name|int
name|rows
parameter_list|,
name|int
name|interlace
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rgb_prog
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|,
name|char
name|i_flag
parameter_list|,
name|int
name|cols
parameter_list|,
name|int
name|rows
parameter_list|,
name|int
name|interlace
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rgb_vbi_prog
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|,
name|char
name|i_flag
parameter_list|,
name|int
name|cols
parameter_list|,
name|int
name|rows
parameter_list|,
name|int
name|interlace
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|build_dma_prog
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|,
name|char
name|i_flag
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool_t
name|getline
parameter_list|(
name|bktr_reg_t
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool_t
name|notclipped
parameter_list|(
name|bktr_reg_t
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool_t
name|split
parameter_list|(
name|bktr_reg_t
modifier|*
parameter_list|,
specifier|volatile
name|u_long
modifier|*
modifier|*
parameter_list|,
name|int
parameter_list|,
name|u_long
parameter_list|,
name|int
parameter_list|,
specifier|volatile
name|u_char
modifier|*
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * video& video capture specific routines.  */
end_comment

begin_function_decl
specifier|static
name|int
name|video_open
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|video_close
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|video_read
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|,
name|int
name|unit
parameter_list|,
name|dev_t
name|dev
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|video_ioctl
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|,
name|int
name|unit
parameter_list|,
name|int
name|cmd
parameter_list|,
name|caddr_t
name|arg
parameter_list|,
name|struct
name|proc
modifier|*
name|pr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|start_capture
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|,
name|unsigned
name|type
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|set_fps
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|,
name|u_short
name|fps
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * tuner specific functions.  */
end_comment

begin_function_decl
specifier|static
name|int
name|tuner_open
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|tuner_close
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|tuner_ioctl
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|,
name|int
name|unit
parameter_list|,
name|int
name|cmd
parameter_list|,
name|caddr_t
name|arg
parameter_list|,
name|struct
name|proc
modifier|*
name|pr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|tuner_getchnlset
parameter_list|(
name|struct
name|bktr_chnlset
modifier|*
name|chnlset
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|tv_channel
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|,
name|int
name|channel
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|tv_freq
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|,
name|int
name|frequency
parameter_list|)
function_decl|;
end_function_decl

begin_if
if|#
directive|if
name|defined
argument_list|(
name|TUNER_AFC
argument_list|)
end_if

begin_function_decl
specifier|static
name|int
name|do_afc
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|,
name|int
name|addr
parameter_list|,
name|int
name|frequency
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* TUNER_AFC */
end_comment

begin_comment
comment|/*  * vbi specific functions.  */
end_comment

begin_function_decl
specifier|static
name|int
name|vbi_open
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|vbi_close
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|vbi_read
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|,
name|dev_t
name|dev
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * audio specific functions.  */
end_comment

begin_function_decl
specifier|static
name|int
name|set_audio
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|,
name|int
name|mode
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|temp_mute
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|,
name|int
name|flag
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|init_BTSC
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|set_BTSC
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|,
name|int
name|control
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|msp_autodetect
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|msp_read_id
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|msp_reset
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|unsigned
name|int
name|msp_read
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|,
name|unsigned
name|char
name|dev
parameter_list|,
name|unsigned
name|int
name|addr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|msp_write
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|,
name|unsigned
name|char
name|dev
parameter_list|,
name|unsigned
name|int
name|addr
parameter_list|,
name|unsigned
name|int
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Remote Control Functions  */
end_comment

begin_function_decl
specifier|static
name|void
name|remote_read
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|,
name|struct
name|bktr_remote
modifier|*
name|remote
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * ioctls common to both video& tuner.  */
end_comment

begin_function_decl
specifier|static
name|int
name|common_ioctl
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|,
name|bt848_ptr_t
name|bt848
parameter_list|,
name|int
name|cmd
parameter_list|,
name|caddr_t
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * i2c primitives  */
end_comment

begin_function_decl
specifier|static
name|int
name|i2cWrite
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|,
name|int
name|addr
parameter_list|,
name|int
name|byte1
parameter_list|,
name|int
name|byte2
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|i2cRead
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|,
name|int
name|addr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|writeEEProm
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|count
parameter_list|,
name|u_char
modifier|*
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|readEEProm
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|count
parameter_list|,
name|u_char
modifier|*
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_if
if|#
directive|if
operator|(
operator|(
operator|!
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
operator|)
operator|||
operator|(
name|NSMBUS
operator|==
literal|0
operator|)
operator|)
end_if

begin_comment
comment|/*  * i2c primatives for low level control of i2c bus. Added for MSP34xx control  */
end_comment

begin_function_decl
specifier|static
name|void
name|i2c_start
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|i2c_stop
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|i2c_write_byte
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|,
name|unsigned
name|char
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|i2c_read_byte
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|,
name|unsigned
name|char
modifier|*
name|data
parameter_list|,
name|int
name|last
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * CARD_GV_BCTV specific functions.  */
end_comment

begin_function_decl
specifier|static
name|void
name|set_bctv_audio
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bctv_gpio_write
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|,
name|int
name|port
parameter_list|,
name|int
name|val
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*static int bctv_gpio_read( bktr_ptr_t bktr, int port );*/
end_comment

begin_comment
comment|/* Not used */
end_comment

begin_comment
comment|/*  * the common attarch code, used by all OS versions.  */
end_comment

begin_function
specifier|static
name|void
name|common_bktr_attach
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|,
name|int
name|unit
parameter_list|,
name|u_long
name|pci_id
parameter_list|,
name|u_int
name|rev
parameter_list|)
block|{
name|bt848_ptr_t
name|bt848
decl_stmt|;
name|vm_offset_t
name|buf
decl_stmt|;
name|bt848
operator|=
name|bktr
operator|->
name|base
expr_stmt|;
comment|/***************************************/
comment|/* *** OS Specific memory routines *** */
comment|/***************************************/
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
operator|||
name|defined
argument_list|(
name|__OpenBSD__
argument_list|)
comment|/* allocate space for dma program */
name|bktr
operator|->
name|dmat
operator|=
name|pa
operator|->
name|pa_dmat
expr_stmt|;
name|bktr
operator|->
name|dma_prog
operator|=
name|get_bktr_mem
argument_list|(
name|bktr
argument_list|,
operator|&
name|bktr
operator|->
name|dm_prog
argument_list|,
name|DMA_PROG_ALLOC
argument_list|)
expr_stmt|;
name|bktr
operator|->
name|odd_dma_prog
operator|=
name|get_bktr_mem
argument_list|(
name|bktr
argument_list|,
operator|&
name|bktr
operator|->
name|dm_oprog
argument_list|,
name|DMA_PROG_ALLOC
argument_list|)
expr_stmt|;
comment|/* allocte space for the VBI buffer */
name|bktr
operator|->
name|vbidata
operator|=
name|get_bktr_mem
argument_list|(
name|bktr
argument_list|,
operator|&
name|bktr
operator|->
name|vbidata
argument_list|,
name|VBI_DATA_SIZE
argument_list|)
expr_stmt|;
name|bktr
operator|->
name|vbibuffer
operator|=
name|get_bktr_mem
argument_list|(
name|bktr
argument_list|,
operator|&
name|bktr
operator|->
name|vbibuffer
argument_list|,
name|VBI_BUFFER_SIZE
argument_list|)
expr_stmt|;
comment|/* allocate space for pixel buffer */
if|if
condition|(
name|BROOKTREE_ALLOC
condition|)
name|buf
operator|=
name|get_bktr_mem
argument_list|(
name|bktr
argument_list|,
operator|&
name|bktr
operator|->
name|dm_mem
argument_list|,
name|BROOKTREE_ALLOC
argument_list|)
expr_stmt|;
else|else
name|buf
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
operator|||
name|defined
argument_list|(
name|__bsdi__
argument_list|)
comment|/* allocate space for dma program */
name|bktr
operator|->
name|dma_prog
operator|=
name|get_bktr_mem
argument_list|(
name|unit
argument_list|,
name|DMA_PROG_ALLOC
argument_list|)
expr_stmt|;
name|bktr
operator|->
name|odd_dma_prog
operator|=
name|get_bktr_mem
argument_list|(
name|unit
argument_list|,
name|DMA_PROG_ALLOC
argument_list|)
expr_stmt|;
comment|/* allocte space for the VBI buffer */
name|bktr
operator|->
name|vbidata
operator|=
name|get_bktr_mem
argument_list|(
name|unit
argument_list|,
name|VBI_DATA_SIZE
argument_list|)
expr_stmt|;
name|bktr
operator|->
name|vbibuffer
operator|=
name|get_bktr_mem
argument_list|(
name|unit
argument_list|,
name|VBI_BUFFER_SIZE
argument_list|)
expr_stmt|;
comment|/* allocate space for pixel buffer */
if|if
condition|(
name|BROOKTREE_ALLOC
condition|)
name|buf
operator|=
name|get_bktr_mem
argument_list|(
name|unit
argument_list|,
name|BROOKTREE_ALLOC
argument_list|)
expr_stmt|;
else|else
name|buf
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|bootverbose
condition|)
block|{
name|printf
argument_list|(
literal|"bktr%d: buffer size %d, addr 0x%x\n"
argument_list|,
name|unit
argument_list|,
name|BROOKTREE_ALLOC
argument_list|,
name|vtophys
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|buf
operator|!=
literal|0
condition|)
block|{
name|bktr
operator|->
name|bigbuf
operator|=
name|buf
expr_stmt|;
name|bktr
operator|->
name|alloc_pages
operator|=
name|BROOKTREE_ALLOC_PAGES
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
name|bktr
operator|->
name|bigbuf
argument_list|,
name|BROOKTREE_ALLOC
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bktr
operator|->
name|alloc_pages
operator|=
literal|0
expr_stmt|;
block|}
name|bktr
operator|->
name|flags
operator|=
name|METEOR_INITALIZED
operator||
name|METEOR_AUTOMODE
operator||
name|METEOR_DEV0
operator||
name|METEOR_RGB16
expr_stmt|;
name|bktr
operator|->
name|dma_prog_loaded
operator|=
name|FALSE
expr_stmt|;
name|bktr
operator|->
name|cols
operator|=
literal|640
expr_stmt|;
name|bktr
operator|->
name|rows
operator|=
literal|480
expr_stmt|;
name|bktr
operator|->
name|frames
operator|=
literal|1
expr_stmt|;
comment|/* one frame */
name|bktr
operator|->
name|format
operator|=
name|METEOR_GEO_RGB16
expr_stmt|;
name|bktr
operator|->
name|pixfmt
operator|=
name|oformat_meteor_to_bt
argument_list|(
name|bktr
operator|->
name|format
argument_list|)
expr_stmt|;
name|bktr
operator|->
name|pixfmt_compat
operator|=
name|TRUE
expr_stmt|;
name|bktr
operator|->
name|vbiinsert
operator|=
literal|0
expr_stmt|;
name|bktr
operator|->
name|vbistart
operator|=
literal|0
expr_stmt|;
name|bktr
operator|->
name|vbisize
operator|=
literal|0
expr_stmt|;
name|bktr
operator|->
name|vbiflags
operator|=
literal|0
expr_stmt|;
comment|/* using the pci device id and revision id */
comment|/* and determine the card type            */
switch|switch
condition|(
name|pci_id
condition|)
block|{
case|case
name|BROOKTREE_848_PCI_ID
case|:
if|if
condition|(
name|rev
operator|==
literal|0x12
condition|)
name|bktr
operator|->
name|id
operator|=
name|BROOKTREE_848A
expr_stmt|;
else|else
name|bktr
operator|->
name|id
operator|=
name|BROOKTREE_848
expr_stmt|;
break|break;
case|case
name|BROOKTREE_849_PCI_ID
case|:
name|bktr
operator|->
name|id
operator|=
name|BROOKTREE_849A
expr_stmt|;
break|break;
case|case
name|BROOKTREE_878_PCI_ID
case|:
name|bktr
operator|->
name|id
operator|=
name|BROOKTREE_878
expr_stmt|;
break|break;
case|case
name|BROOKTREE_879_PCI_ID
case|:
name|bktr
operator|->
name|id
operator|=
name|BROOKTREE_879
expr_stmt|;
break|break;
block|}
empty_stmt|;
name|bktr
operator|->
name|clr_on_start
operator|=
name|FALSE
expr_stmt|;
comment|/* defaults for the tuner section of the card */
name|bktr
operator|->
name|tflags
operator|=
name|TUNER_INITALIZED
expr_stmt|;
name|bktr
operator|->
name|tuner
operator|.
name|frequency
operator|=
literal|0
expr_stmt|;
name|bktr
operator|->
name|tuner
operator|.
name|channel
operator|=
literal|0
expr_stmt|;
name|bktr
operator|->
name|tuner
operator|.
name|chnlset
operator|=
name|DEFAULT_CHNLSET
expr_stmt|;
name|bktr
operator|->
name|audio_mux_select
operator|=
literal|0
expr_stmt|;
name|bktr
operator|->
name|audio_mute_state
operator|=
name|FALSE
expr_stmt|;
name|bktr
operator|->
name|bt848_card
operator|=
operator|-
literal|1
expr_stmt|;
name|bktr
operator|->
name|bt848_tuner
operator|=
operator|-
literal|1
expr_stmt|;
name|bktr
operator|->
name|reverse_mute
operator|=
operator|-
literal|1
expr_stmt|;
name|probeCard
argument_list|(
name|bktr
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
comment|/* If there is an MSP Audio device, reset it and display the model */
if|if
condition|(
name|bktr
operator|->
name|card
operator|.
name|msp3400c
condition|)
name|msp_reset
argument_list|(
name|bktr
argument_list|)
expr_stmt|;
if|if
condition|(
name|bktr
operator|->
name|card
operator|.
name|msp3400c
condition|)
name|msp_read_id
argument_list|(
name|bktr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Copy the vbi lines from 'vbidata' into the circular buffer, 'vbibuffer'.  * The circular buffer holds 'n' fixed size data blocks.   * vbisize   is the number of bytes in the circular buffer   * vbiread   is the point we reading data out of the circular buffer   * vbiinsert is the point we insert data into the circular buffer   */
end_comment

begin_function
specifier|static
name|void
name|vbidecode
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
name|dest
decl_stmt|;
comment|/* Check if there is room in the buffer to insert the data. */
if|if
condition|(
name|bktr
operator|->
name|vbisize
operator|+
name|VBI_DATA_SIZE
operator|>
name|VBI_BUFFER_SIZE
condition|)
return|return;
comment|/* Copy the VBI data into the next free slot in the buffer. */
comment|/* 'dest' is the point in vbibuffer where we want to insert new data */
name|dest
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|bktr
operator|->
name|vbibuffer
operator|+
name|bktr
operator|->
name|vbiinsert
expr_stmt|;
comment|/* block copy the vbi data into the buffer */
name|memcpy
argument_list|(
name|dest
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|bktr
operator|->
name|vbidata
argument_list|,
name|VBI_DATA_SIZE
argument_list|)
expr_stmt|;
comment|/* Increment the vbiinsert pointer */
comment|/* This can wrap around */
name|bktr
operator|->
name|vbiinsert
operator|+=
name|VBI_DATA_SIZE
expr_stmt|;
name|bktr
operator|->
name|vbiinsert
operator|=
operator|(
name|bktr
operator|->
name|vbiinsert
operator|%
name|VBI_BUFFER_SIZE
operator|)
expr_stmt|;
comment|/* And increase the amount of vbi data in the buffer */
name|bktr
operator|->
name|vbisize
operator|=
name|bktr
operator|->
name|vbisize
operator|+
name|VBI_DATA_SIZE
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * the common interrupt handler.  * Returns a 0 or 1 depending on whether the interrupt has handled.  * In the OS specific section, bktr_intr() is defined which calls this  * common interrupt handler.  */
end_comment

begin_function
specifier|static
name|int
name|common_bktr_intr
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|bktr_ptr_t
name|bktr
decl_stmt|;
name|bt848_ptr_t
name|bt848
decl_stmt|;
name|u_long
name|bktr_status
decl_stmt|;
name|u_char
name|dstatus
decl_stmt|;
name|u_long
name|field
decl_stmt|;
name|u_long
name|w_field
decl_stmt|;
name|u_long
name|req_field
decl_stmt|;
name|bktr
operator|=
operator|(
name|bktr_ptr_t
operator|)
name|arg
expr_stmt|;
name|bt848
operator|=
name|bktr
operator|->
name|base
expr_stmt|;
comment|/* 	 * check to see if any interrupts are unmasked on this device.  If 	 * none are, then we likely got here by way of being on a PCI shared 	 * interrupt dispatch list. 	 */
if|if
condition|(
name|bt848
operator|->
name|int_mask
operator|==
name|ALL_INTS_DISABLED
condition|)
return|return
literal|0
return|;
comment|/* bail out now, before we do something we 				   shouldn't */
if|if
condition|(
operator|!
operator|(
name|bktr
operator|->
name|flags
operator|&
name|METEOR_OPEN
operator|)
condition|)
block|{
name|bt848
operator|->
name|gpio_dma_ctl
operator|=
name|FIFO_RISC_DISABLED
expr_stmt|;
name|bt848
operator|->
name|int_mask
operator|=
name|ALL_INTS_DISABLED
expr_stmt|;
comment|/* return; ?? */
block|}
comment|/* record and clear the INTerrupt status bits */
name|bktr_status
operator|=
name|bt848
operator|->
name|int_stat
expr_stmt|;
name|bt848
operator|->
name|int_stat
operator|=
name|bktr_status
operator|&
operator|~
name|I2C_BITS
expr_stmt|;
comment|/* don't touch i2c */
comment|/* record and clear the device status register */
name|dstatus
operator|=
name|bt848
operator|->
name|dstatus
expr_stmt|;
name|bt848
operator|->
name|dstatus
operator|=
literal|0x00
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|STATUS_SUM
argument_list|)
comment|/* add any new device status or INTerrupt status bits */
name|status_sum
operator||=
operator|(
name|bktr_status
operator|&
operator|~
operator|(
name|BT848_INT_RSV0
operator||
name|BT848_INT_RSV1
operator|)
operator|)
expr_stmt|;
name|status_sum
operator||=
operator|(
operator|(
name|dstatus
operator|&
operator|(
name|BT848_DSTATUS_COF
operator||
name|BT848_DSTATUS_LOF
operator|)
operator|)
operator|<<
literal|6
operator|)
expr_stmt|;
endif|#
directive|endif
comment|/* STATUS_SUM */
comment|/* printf( " STATUS %x %x %x \n", 		dstatus, bktr_status, bt848->risc_count ); 	*/
comment|/* if risc was disabled re-start process again */
if|if
condition|(
operator|!
operator|(
name|bktr_status
operator|&
name|BT848_INT_RISC_EN
operator|)
operator|||
operator|(
operator|(
name|bktr_status
operator|&
operator|(
name|BT848_INT_FBUS
operator||
name|BT848_INT_FTRGT
operator||
name|BT848_INT_FDSR
operator||
name|BT848_INT_PPERR
operator||
name|BT848_INT_RIPERR
operator||
name|BT848_INT_PABORT
operator||
name|BT848_INT_OCERR
operator||
name|BT848_INT_SCERR
operator|)
operator|)
operator|!=
literal|0
operator|)
operator|||
operator|(
operator|(
name|bt848
operator|->
name|tdec
operator|==
literal|0
operator|)
operator|&&
operator|(
name|bktr_status
operator|&
name|TDEC_BITS
operator|)
operator|)
condition|)
block|{
name|u_short
name|tdec_save
init|=
name|bt848
operator|->
name|tdec
decl_stmt|;
name|bt848
operator|->
name|gpio_dma_ctl
operator|=
name|FIFO_RISC_DISABLED
expr_stmt|;
name|bt848
operator|->
name|int_mask
operator|=
name|ALL_INTS_DISABLED
expr_stmt|;
comment|/*  Reset temporal decimation ctr  */
name|bt848
operator|->
name|tdec
operator|=
literal|0
expr_stmt|;
name|bt848
operator|->
name|tdec
operator|=
name|tdec_save
expr_stmt|;
comment|/*  Reset to no-fields captured state  */
if|if
condition|(
name|bktr
operator|->
name|flags
operator|&
operator|(
name|METEOR_CONTIN
operator||
name|METEOR_SYNCAP
operator|)
condition|)
block|{
switch|switch
condition|(
name|bktr
operator|->
name|flags
operator|&
name|METEOR_ONLY_FIELDS_MASK
condition|)
block|{
case|case
name|METEOR_ONLY_ODD_FIELDS
case|:
name|bktr
operator|->
name|flags
operator||=
name|METEOR_WANT_ODD
expr_stmt|;
break|break;
case|case
name|METEOR_ONLY_EVEN_FIELDS
case|:
name|bktr
operator|->
name|flags
operator||=
name|METEOR_WANT_EVEN
expr_stmt|;
break|break;
default|default:
name|bktr
operator|->
name|flags
operator||=
name|METEOR_WANT_MASK
expr_stmt|;
break|break;
block|}
block|}
name|bt848
operator|->
name|risc_strt_add
operator|=
name|vtophys
argument_list|(
name|bktr
operator|->
name|dma_prog
argument_list|)
expr_stmt|;
name|bt848
operator|->
name|gpio_dma_ctl
operator|=
name|FIFO_ENABLED
expr_stmt|;
name|bt848
operator|->
name|gpio_dma_ctl
operator|=
name|bktr
operator|->
name|capcontrol
expr_stmt|;
name|bt848
operator|->
name|int_mask
operator|=
name|BT848_INT_MYSTERYBIT
operator||
name|BT848_INT_RISCI
operator||
name|BT848_INT_VSYNC
operator||
name|BT848_INT_FMTCHG
expr_stmt|;
name|bt848
operator|->
name|cap_ctl
operator|=
name|bktr
operator|->
name|bktr_cap_ctl
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* If this is not a RISC program interrupt, return */
if|if
condition|(
operator|!
operator|(
name|bktr_status
operator|&
name|BT848_INT_RISCI
operator|)
condition|)
return|return
literal|0
return|;
comment|/** 	printf( "intr status %x %x %x\n", 		bktr_status, dstatus, bt848->risc_count );  */
comment|/* 	 * Disable future interrupts if a capture mode is not selected. 	 * This can happen when we are in the process of closing or  	 * changing capture modes, otherwise it shouldn't happen. 	 */
if|if
condition|(
operator|!
operator|(
name|bktr
operator|->
name|flags
operator|&
name|METEOR_CAP_MASK
operator|)
condition|)
name|bt848
operator|->
name|cap_ctl
operator|=
name|CAPTURE_OFF
expr_stmt|;
comment|/* 	 *  Register the completed field 	 *    (For dual-field mode, require fields from the same frame) 	 */
name|field
operator|=
operator|(
name|bktr_status
operator|&
name|BT848_INT_FIELD
operator|)
condition|?
name|EVEN_F
else|:
name|ODD_F
expr_stmt|;
switch|switch
condition|(
name|bktr
operator|->
name|flags
operator|&
name|METEOR_WANT_MASK
condition|)
block|{
case|case
name|METEOR_WANT_ODD
case|:
name|w_field
operator|=
name|ODD_F
expr_stmt|;
break|break;
case|case
name|METEOR_WANT_EVEN
case|:
name|w_field
operator|=
name|EVEN_F
expr_stmt|;
break|break;
default|default               :
name|w_field
operator|=
operator|(
name|ODD_F
operator||
name|EVEN_F
operator|)
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
name|bktr
operator|->
name|flags
operator|&
name|METEOR_ONLY_FIELDS_MASK
condition|)
block|{
case|case
name|METEOR_ONLY_ODD_FIELDS
case|:
name|req_field
operator|=
name|ODD_F
expr_stmt|;
break|break;
case|case
name|METEOR_ONLY_EVEN_FIELDS
case|:
name|req_field
operator|=
name|EVEN_F
expr_stmt|;
break|break;
default|default                      :
name|req_field
operator|=
operator|(
name|ODD_F
operator||
name|EVEN_F
operator|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|field
operator|==
name|EVEN_F
operator|)
operator|&&
operator|(
name|w_field
operator|==
name|EVEN_F
operator|)
condition|)
name|bktr
operator|->
name|flags
operator|&=
operator|~
name|METEOR_WANT_EVEN
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|field
operator|==
name|ODD_F
operator|)
operator|&&
operator|(
name|req_field
operator|==
name|ODD_F
operator|)
operator|&&
operator|(
name|w_field
operator|==
name|ODD_F
operator|)
condition|)
name|bktr
operator|->
name|flags
operator|&=
operator|~
name|METEOR_WANT_ODD
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|field
operator|==
name|ODD_F
operator|)
operator|&&
operator|(
name|req_field
operator|==
operator|(
name|ODD_F
operator||
name|EVEN_F
operator|)
operator|)
operator|&&
operator|(
name|w_field
operator|==
operator|(
name|ODD_F
operator||
name|EVEN_F
operator|)
operator|)
condition|)
name|bktr
operator|->
name|flags
operator|&=
operator|~
name|METEOR_WANT_ODD
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|field
operator|==
name|ODD_F
operator|)
operator|&&
operator|(
name|req_field
operator|==
operator|(
name|ODD_F
operator||
name|EVEN_F
operator|)
operator|)
operator|&&
operator|(
name|w_field
operator|==
name|ODD_F
operator|)
condition|)
block|{
name|bktr
operator|->
name|flags
operator|&=
operator|~
name|METEOR_WANT_ODD
expr_stmt|;
name|bktr
operator|->
name|flags
operator||=
name|METEOR_WANT_EVEN
expr_stmt|;
block|}
else|else
block|{
comment|/*  We're out of sync.  Start over.  */
if|if
condition|(
name|bktr
operator|->
name|flags
operator|&
operator|(
name|METEOR_CONTIN
operator||
name|METEOR_SYNCAP
operator|)
condition|)
block|{
switch|switch
condition|(
name|bktr
operator|->
name|flags
operator|&
name|METEOR_ONLY_FIELDS_MASK
condition|)
block|{
case|case
name|METEOR_ONLY_ODD_FIELDS
case|:
name|bktr
operator|->
name|flags
operator||=
name|METEOR_WANT_ODD
expr_stmt|;
break|break;
case|case
name|METEOR_ONLY_EVEN_FIELDS
case|:
name|bktr
operator|->
name|flags
operator||=
name|METEOR_WANT_EVEN
expr_stmt|;
break|break;
default|default:
name|bktr
operator|->
name|flags
operator||=
name|METEOR_WANT_MASK
expr_stmt|;
break|break;
block|}
block|}
return|return
literal|1
return|;
block|}
comment|/* 	 * If we have a complete frame. 	 */
if|if
condition|(
operator|!
operator|(
name|bktr
operator|->
name|flags
operator|&
name|METEOR_WANT_MASK
operator|)
condition|)
block|{
name|bktr
operator|->
name|frames_captured
operator|++
expr_stmt|;
comment|/* 		 * post the completion time.  		 */
if|if
condition|(
name|bktr
operator|->
name|flags
operator|&
name|METEOR_WANT_TS
condition|)
block|{
name|struct
name|timeval
modifier|*
name|ts
decl_stmt|;
if|if
condition|(
operator|(
name|u_int
operator|)
name|bktr
operator|->
name|alloc_pages
operator|*
name|PAGE_SIZE
operator|<=
operator|(
name|bktr
operator|->
name|frame_size
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|timeval
argument_list|)
operator|)
condition|)
block|{
name|ts
operator|=
operator|(
expr|struct
name|timeval
operator|*
operator|)
name|bktr
operator|->
name|bigbuf
operator|+
name|bktr
operator|->
name|frame_size
expr_stmt|;
comment|/* doesn't work in synch mode except 				 *  for first frame */
comment|/* XXX */
name|microtime
argument_list|(
name|ts
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 		 * Process the VBI data if it is being captured 		 */
if|if
condition|(
name|bktr
operator|->
name|vbiflags
operator|&
name|VBI_CAPTURE
condition|)
block|{
name|vbidecode
argument_list|(
name|bktr
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
name|VBI_SLEEP
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Wake up the user in single capture mode. 		 */
if|if
condition|(
name|bktr
operator|->
name|flags
operator|&
name|METEOR_SINGLE
condition|)
block|{
comment|/* stop dma */
name|bt848
operator|->
name|int_mask
operator|=
name|ALL_INTS_DISABLED
expr_stmt|;
comment|/* disable risc, leave fifo running */
name|bt848
operator|->
name|gpio_dma_ctl
operator|=
name|FIFO_ENABLED
expr_stmt|;
name|wakeup
argument_list|(
name|BKTR_SLEEP
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * If the user requested to be notified via signal, 		 * let them know the frame is complete. 		 */
if|if
condition|(
name|bktr
operator|->
name|proc
operator|&&
operator|!
operator|(
name|bktr
operator|->
name|signal
operator|&
name|METEOR_SIG_MODE_MASK
operator|)
condition|)
name|psignal
argument_list|(
name|bktr
operator|->
name|proc
argument_list|,
name|bktr
operator|->
name|signal
operator|&
operator|(
operator|~
name|METEOR_SIG_MODE_MASK
operator|)
argument_list|)
expr_stmt|;
comment|/* 		 * Reset the want flags if in continuous or 		 * synchronous capture mode. 		 */
comment|/* * XXX NOTE (Luigi): * currently we only support 3 capture modes: odd only, even only, * odd+even interlaced (odd field first). A fourth mode (non interlaced, * either even OR odd) could provide 60 (50 for PAL) pictures per * second, but it would require this routine to toggle the desired frame * each time, and one more different DMA program for the Bt848. * As a consequence, this fourth mode is currently unsupported. */
if|if
condition|(
name|bktr
operator|->
name|flags
operator|&
operator|(
name|METEOR_CONTIN
operator||
name|METEOR_SYNCAP
operator|)
condition|)
block|{
switch|switch
condition|(
name|bktr
operator|->
name|flags
operator|&
name|METEOR_ONLY_FIELDS_MASK
condition|)
block|{
case|case
name|METEOR_ONLY_ODD_FIELDS
case|:
name|bktr
operator|->
name|flags
operator||=
name|METEOR_WANT_ODD
expr_stmt|;
break|break;
case|case
name|METEOR_ONLY_EVEN_FIELDS
case|:
name|bktr
operator|->
name|flags
operator||=
name|METEOR_WANT_EVEN
expr_stmt|;
break|break;
default|default:
name|bktr
operator|->
name|flags
operator||=
name|METEOR_WANT_MASK
expr_stmt|;
break|break;
block|}
block|}
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  *   */
end_comment

begin_function
specifier|static
name|int
name|video_open
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|)
block|{
name|bt848_ptr_t
name|bt848
decl_stmt|;
name|int
name|frame_rate
decl_stmt|,
name|video_format
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|bktr
operator|->
name|flags
operator|&
name|METEOR_OPEN
condition|)
comment|/* device is busy */
return|return
operator|(
name|EBUSY
operator|)
return|;
name|bktr
operator|->
name|flags
operator||=
name|METEOR_OPEN
expr_stmt|;
name|bt848
operator|=
name|bktr
operator|->
name|base
expr_stmt|;
ifdef|#
directive|ifdef
name|BT848_DUMP
name|dump_bt848
argument_list|(
name|bt848
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|bktr
operator|->
name|clr_on_start
operator|=
name|FALSE
expr_stmt|;
name|bt848
operator|->
name|dstatus
operator|=
literal|0x00
expr_stmt|;
comment|/* clear device status reg. */
name|bt848
operator|->
name|adc
operator|=
name|SYNC_LEVEL
expr_stmt|;
if|#
directive|if
name|BROOKTREE_SYSTEM_DEFAULT
operator|==
name|BROOKTREE_PAL
name|video_format
operator|=
literal|0
expr_stmt|;
else|#
directive|else
name|video_format
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|bt848_format
operator|==
literal|0
condition|)
name|video_format
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|bt848_format
operator|==
literal|1
condition|)
name|video_format
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|video_format
operator|==
literal|1
condition|)
block|{
name|bt848
operator|->
name|iform
operator|=
name|BT848_IFORM_F_NTSCM
expr_stmt|;
name|bktr
operator|->
name|format_params
operator|=
name|BT848_IFORM_F_NTSCM
expr_stmt|;
block|}
else|else
block|{
name|bt848
operator|->
name|iform
operator|=
name|BT848_IFORM_F_PALBDGHI
expr_stmt|;
name|bktr
operator|->
name|format_params
operator|=
name|BT848_IFORM_F_PALBDGHI
expr_stmt|;
block|}
name|bt848
operator|->
name|iform
operator||=
name|format_params
index|[
name|bktr
operator|->
name|format_params
index|]
operator|.
name|iform_xtsel
expr_stmt|;
comment|/* work around for new Hauppauge 878 cards */
if|if
condition|(
operator|(
name|bktr
operator|->
name|card
operator|.
name|card_id
operator|==
name|CARD_HAUPPAUGE
operator|)
operator|&&
operator|(
name|bktr
operator|->
name|id
operator|==
name|BROOKTREE_878
operator|||
name|bktr
operator|->
name|id
operator|==
name|BROOKTREE_879
operator|)
condition|)
name|bt848
operator|->
name|iform
operator||=
name|BT848_IFORM_M_MUX3
expr_stmt|;
else|else
name|bt848
operator|->
name|iform
operator||=
name|BT848_IFORM_M_MUX1
expr_stmt|;
name|bt848
operator|->
name|adelay
operator|=
name|format_params
index|[
name|bktr
operator|->
name|format_params
index|]
operator|.
name|adelay
expr_stmt|;
name|bt848
operator|->
name|bdelay
operator|=
name|format_params
index|[
name|bktr
operator|->
name|format_params
index|]
operator|.
name|bdelay
expr_stmt|;
name|frame_rate
operator|=
name|format_params
index|[
name|bktr
operator|->
name|format_params
index|]
operator|.
name|frame_rate
expr_stmt|;
comment|/* enable PLL mode using 28Mhz crystal for PAL/SECAM users */
if|if
condition|(
name|bktr
operator|->
name|xtal_pll_mode
operator|==
name|BT848_USE_PLL
condition|)
block|{
name|bt848
operator|->
name|tgctrl
operator|=
literal|0
expr_stmt|;
name|bt848
operator|->
name|pll_f_lo
operator|=
literal|0xf9
expr_stmt|;
name|bt848
operator|->
name|pll_f_hi
operator|=
literal|0xdc
expr_stmt|;
name|bt848
operator|->
name|pll_f_xci
operator|=
literal|0x8e
expr_stmt|;
block|}
name|bktr
operator|->
name|flags
operator|=
operator|(
name|bktr
operator|->
name|flags
operator|&
operator|~
name|METEOR_DEV_MASK
operator|)
operator||
name|METEOR_DEV0
expr_stmt|;
name|bktr
operator|->
name|max_clip_node
operator|=
literal|0
expr_stmt|;
name|bt848
operator|->
name|color_ctl_gamma
operator|=
literal|1
expr_stmt|;
name|bt848
operator|->
name|color_ctl_rgb_ded
operator|=
literal|1
expr_stmt|;
name|bt848
operator|->
name|color_ctl_color_bars
operator|=
literal|0
expr_stmt|;
name|bt848
operator|->
name|color_ctl_ext_frmrate
operator|=
literal|0
expr_stmt|;
name|bt848
operator|->
name|color_ctl_swap
operator|=
literal|0
expr_stmt|;
name|bt848
operator|->
name|e_hscale_lo
operator|=
literal|170
expr_stmt|;
name|bt848
operator|->
name|o_hscale_lo
operator|=
literal|170
expr_stmt|;
name|bt848
operator|->
name|e_delay_lo
operator|=
literal|0x72
expr_stmt|;
name|bt848
operator|->
name|o_delay_lo
operator|=
literal|0x72
expr_stmt|;
name|bt848
operator|->
name|e_scloop
operator|=
literal|0
expr_stmt|;
name|bt848
operator|->
name|o_scloop
operator|=
literal|0
expr_stmt|;
name|bt848
operator|->
name|vbi_pack_size
operator|=
literal|0
expr_stmt|;
name|bt848
operator|->
name|vbi_pack_del
operator|=
literal|0
expr_stmt|;
name|bktr
operator|->
name|fifo_errors
operator|=
literal|0
expr_stmt|;
name|bktr
operator|->
name|dma_errors
operator|=
literal|0
expr_stmt|;
name|bktr
operator|->
name|frames_captured
operator|=
literal|0
expr_stmt|;
name|bktr
operator|->
name|even_fields_captured
operator|=
literal|0
expr_stmt|;
name|bktr
operator|->
name|odd_fields_captured
operator|=
literal|0
expr_stmt|;
name|bktr
operator|->
name|proc
operator|=
operator|(
expr|struct
name|proc
operator|*
operator|)
literal|0
expr_stmt|;
name|set_fps
argument_list|(
name|bktr
argument_list|,
name|frame_rate
argument_list|)
expr_stmt|;
name|bktr
operator|->
name|video
operator|.
name|addr
operator|=
literal|0
expr_stmt|;
name|bktr
operator|->
name|video
operator|.
name|width
operator|=
literal|0
expr_stmt|;
name|bktr
operator|->
name|video
operator|.
name|banksize
operator|=
literal|0
expr_stmt|;
name|bktr
operator|->
name|video
operator|.
name|ramsize
operator|=
literal|0
expr_stmt|;
name|bktr
operator|->
name|pixfmt_compat
operator|=
name|TRUE
expr_stmt|;
name|bktr
operator|->
name|format
operator|=
name|METEOR_GEO_RGB16
expr_stmt|;
name|bktr
operator|->
name|pixfmt
operator|=
name|oformat_meteor_to_bt
argument_list|(
name|bktr
operator|->
name|format
argument_list|)
expr_stmt|;
name|bktr
operator|->
name|capture_area_enabled
operator|=
name|FALSE
expr_stmt|;
name|bt848
operator|->
name|int_mask
operator|=
name|BT848_INT_MYSTERYBIT
expr_stmt|;
comment|/* if you take this out triton                                                    based motherboards will  						   operate unreliably */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|vbi_open
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|)
block|{
if|if
condition|(
name|bktr
operator|->
name|vbiflags
operator|&
name|VBI_OPEN
condition|)
comment|/* device is busy */
return|return
operator|(
name|EBUSY
operator|)
return|;
name|bktr
operator|->
name|vbiflags
operator||=
name|VBI_OPEN
expr_stmt|;
comment|/* reset the VBI circular buffer pointers and clear the buffers */
name|bktr
operator|->
name|vbiinsert
operator|=
literal|0
expr_stmt|;
name|bktr
operator|->
name|vbistart
operator|=
literal|0
expr_stmt|;
name|bktr
operator|->
name|vbisize
operator|=
literal|0
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
name|bktr
operator|->
name|vbibuffer
argument_list|,
name|VBI_BUFFER_SIZE
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
name|bktr
operator|->
name|vbidata
argument_list|,
name|VBI_DATA_SIZE
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *   */
end_comment

begin_function
specifier|static
name|int
name|tuner_open
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|bktr
operator|->
name|tflags
operator|&
name|TUNER_INITALIZED
operator|)
condition|)
comment|/* device not found */
return|return
operator|(
name|ENXIO
operator|)
return|;
if|if
condition|(
name|bktr
operator|->
name|tflags
operator|&
name|TUNER_OPEN
condition|)
comment|/* already open */
return|return
operator|(
literal|0
operator|)
return|;
name|bktr
operator|->
name|tflags
operator||=
name|TUNER_OPEN
expr_stmt|;
name|bktr
operator|->
name|tuner
operator|.
name|radio_mode
operator|=
literal|0
expr_stmt|;
comment|/* enable drivers on the GPIO port that control the MUXes */
name|bktr
operator|->
name|base
operator|->
name|gpio_out_en
operator||=
name|bktr
operator|->
name|card
operator|.
name|gpio_mux_bits
expr_stmt|;
comment|/* unmute the audio stream */
name|set_audio
argument_list|(
name|bktr
argument_list|,
name|AUDIO_UNMUTE
argument_list|)
expr_stmt|;
comment|/* enable stereo if appropriate on TDA audio chip */
if|if
condition|(
name|bktr
operator|->
name|card
operator|.
name|dbx
condition|)
name|init_BTSC
argument_list|(
name|bktr
argument_list|)
expr_stmt|;
comment|/* reset the MSP34xx stereo audio chip */
if|if
condition|(
name|bktr
operator|->
name|card
operator|.
name|msp3400c
condition|)
name|msp_reset
argument_list|(
name|bktr
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *   */
end_comment

begin_function
specifier|static
name|int
name|video_close
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|)
block|{
name|bt848_ptr_t
name|bt848
decl_stmt|;
name|bktr
operator|->
name|flags
operator|&=
operator|~
operator|(
name|METEOR_OPEN
operator||
name|METEOR_SINGLE
operator||
name|METEOR_CAP_MASK
operator||
name|METEOR_WANT_MASK
operator|)
expr_stmt|;
name|bt848
operator|=
name|bktr
operator|->
name|base
expr_stmt|;
name|bt848
operator|->
name|gpio_dma_ctl
operator|=
name|FIFO_RISC_DISABLED
expr_stmt|;
name|bt848
operator|->
name|cap_ctl
operator|=
name|CAPTURE_OFF
expr_stmt|;
name|bktr
operator|->
name|dma_prog_loaded
operator|=
name|FALSE
expr_stmt|;
name|bt848
operator|->
name|tdec
operator|=
literal|0
expr_stmt|;
name|bt848
operator|->
name|int_mask
operator|=
name|ALL_INTS_DISABLED
expr_stmt|;
comment|/** FIXME: is 0xf magic, wouldn't 0x00 work ??? */
name|bt848
operator|->
name|sreset
operator|=
literal|0xf
expr_stmt|;
name|bt848
operator|->
name|int_stat
operator|=
name|ALL_INTS_CLEARED
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * tuner close handle,  *  place holder for tuner specific operations on a close.  */
end_comment

begin_function
specifier|static
name|int
name|tuner_close
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|)
block|{
name|bktr
operator|->
name|tflags
operator|&=
operator|~
name|TUNER_OPEN
expr_stmt|;
comment|/* mute the audio by switching the mux */
name|set_audio
argument_list|(
name|bktr
argument_list|,
name|AUDIO_MUTE
argument_list|)
expr_stmt|;
comment|/* disable drivers on the GPIO port that control the MUXes */
name|bktr
operator|->
name|base
operator|->
name|gpio_out_en
operator|=
name|bktr
operator|->
name|base
operator|->
name|gpio_out_en
operator|&
operator|~
name|bktr
operator|->
name|card
operator|.
name|gpio_mux_bits
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|vbi_close
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|)
block|{
name|bktr
operator|->
name|vbiflags
operator|&=
operator|~
name|VBI_OPEN
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *  */
end_comment

begin_function
specifier|static
name|int
name|video_read
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|,
name|int
name|unit
parameter_list|,
name|dev_t
name|dev
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|)
block|{
name|bt848_ptr_t
name|bt848
decl_stmt|;
name|int
name|status
decl_stmt|;
name|int
name|count
decl_stmt|;
name|bt848
operator|=
name|bktr
operator|->
name|base
expr_stmt|;
if|if
condition|(
name|bktr
operator|->
name|bigbuf
operator|==
literal|0
condition|)
comment|/* no frame buffer allocated (ioctl failed) */
return|return
operator|(
name|ENOMEM
operator|)
return|;
if|if
condition|(
name|bktr
operator|->
name|flags
operator|&
name|METEOR_CAP_MASK
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
comment|/* already capturing */
name|bt848
operator|->
name|cap_ctl
operator|=
name|bktr
operator|->
name|bktr_cap_ctl
expr_stmt|;
name|count
operator|=
name|bktr
operator|->
name|rows
operator|*
name|bktr
operator|->
name|cols
operator|*
name|pixfmt_table
index|[
name|bktr
operator|->
name|pixfmt
index|]
operator|.
name|public
operator|.
name|Bpp
expr_stmt|;
if|if
condition|(
operator|(
name|int
operator|)
name|uio
operator|->
name|uio_iov
operator|->
name|iov_len
operator|<
name|count
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|bktr
operator|->
name|flags
operator|&=
operator|~
operator|(
name|METEOR_CAP_MASK
operator||
name|METEOR_WANT_MASK
operator|)
expr_stmt|;
comment|/* capture one frame */
name|start_capture
argument_list|(
name|bktr
argument_list|,
name|METEOR_SINGLE
argument_list|)
expr_stmt|;
comment|/* wait for capture to complete */
name|bt848
operator|->
name|int_stat
operator|=
name|ALL_INTS_CLEARED
expr_stmt|;
name|bt848
operator|->
name|gpio_dma_ctl
operator|=
name|FIFO_ENABLED
expr_stmt|;
name|bt848
operator|->
name|gpio_dma_ctl
operator|=
name|bktr
operator|->
name|capcontrol
expr_stmt|;
name|bt848
operator|->
name|int_mask
operator|=
name|BT848_INT_MYSTERYBIT
operator||
name|BT848_INT_RISCI
operator||
name|BT848_INT_VSYNC
operator||
name|BT848_INT_FMTCHG
expr_stmt|;
name|status
operator|=
name|tsleep
argument_list|(
name|BKTR_SLEEP
argument_list|,
name|BKTRPRI
argument_list|,
literal|"captur"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|status
condition|)
comment|/* successful capture */
name|status
operator|=
name|uiomove
argument_list|(
operator|(
name|caddr_t
operator|)
name|bktr
operator|->
name|bigbuf
argument_list|,
name|count
argument_list|,
name|uio
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"bktr%d: read: tsleep error %d\n"
argument_list|,
name|unit
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|bktr
operator|->
name|flags
operator|&=
operator|~
operator|(
name|METEOR_SINGLE
operator||
name|METEOR_WANT_MASK
operator|)
expr_stmt|;
return|return
operator|(
name|status
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Read VBI data from the vbi circular buffer  * The buffer holds vbi data blocks which are the same size  * vbiinsert is the position we will insert the next item into the buffer  * vbistart is the actual position in the buffer we want to read from  * vbisize is the exact number of bytes in the buffer left to read   */
end_comment

begin_function
specifier|static
name|int
name|vbi_read
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|,
name|dev_t
name|dev
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|)
block|{
name|int
name|readsize
decl_stmt|,
name|readsize2
decl_stmt|;
name|int
name|status
decl_stmt|;
if|if
condition|(
name|bktr
operator|->
name|vbisize
operator|==
literal|0
condition|)
name|status
operator|=
name|tsleep
argument_list|(
name|VBI_SLEEP
argument_list|,
name|BKTRPRI
argument_list|,
literal|"vbi"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|readsize
operator|=
operator|(
name|int
operator|)
name|uio
operator|->
name|uio_iov
operator|->
name|iov_len
expr_stmt|;
comment|/* We cannot read more bytes than there are in the circular buffer */
if|if
condition|(
name|readsize
operator|>
name|bktr
operator|->
name|vbisize
condition|)
name|readsize
operator|=
name|bktr
operator|->
name|vbisize
expr_stmt|;
comment|/* Check if we can read this number of bytes without having to wrap around the circular buffer */
if|if
condition|(
operator|(
name|bktr
operator|->
name|vbistart
operator|+
name|readsize
operator|)
operator|>=
name|VBI_BUFFER_SIZE
condition|)
block|{
comment|/* We need to wrap around */
name|readsize2
operator|=
name|VBI_BUFFER_SIZE
operator|-
name|bktr
operator|->
name|vbistart
expr_stmt|;
name|status
operator|=
name|uiomove
argument_list|(
operator|(
name|caddr_t
operator|)
name|bktr
operator|->
name|vbibuffer
operator|+
name|bktr
operator|->
name|vbistart
argument_list|,
name|readsize2
argument_list|,
name|uio
argument_list|)
expr_stmt|;
name|status
operator|+=
name|uiomove
argument_list|(
operator|(
name|caddr_t
operator|)
name|bktr
operator|->
name|vbibuffer
argument_list|,
operator|(
name|readsize
operator|-
name|readsize2
operator|)
argument_list|,
name|uio
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* We do not need to wrap around */
name|status
operator|=
name|uiomove
argument_list|(
operator|(
name|caddr_t
operator|)
name|bktr
operator|->
name|vbibuffer
operator|+
name|bktr
operator|->
name|vbistart
argument_list|,
name|readsize
argument_list|,
name|uio
argument_list|)
expr_stmt|;
block|}
comment|/* Update the number of bytes left to read */
name|bktr
operator|->
name|vbisize
operator|-=
name|readsize
expr_stmt|;
comment|/* Update vbistart */
name|bktr
operator|->
name|vbistart
operator|+=
name|readsize
expr_stmt|;
name|bktr
operator|->
name|vbistart
operator|=
name|bktr
operator|->
name|vbistart
operator|%
name|VBI_BUFFER_SIZE
expr_stmt|;
comment|/* wrap around if needed */
return|return
operator|(
name|status
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * video ioctls  */
end_comment

begin_function
specifier|static
name|int
name|video_ioctl
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|,
name|int
name|unit
parameter_list|,
name|int
name|cmd
parameter_list|,
name|caddr_t
name|arg
parameter_list|,
name|struct
name|proc
modifier|*
name|pr
parameter_list|)
block|{
name|bt848_ptr_t
name|bt848
decl_stmt|;
specifier|volatile
name|u_char
name|c_temp
decl_stmt|;
name|unsigned
name|int
name|temp
decl_stmt|;
name|unsigned
name|int
name|temp_iform
decl_stmt|;
name|unsigned
name|int
name|error
decl_stmt|;
name|struct
name|meteor_geomet
modifier|*
name|geo
decl_stmt|;
name|struct
name|meteor_counts
modifier|*
name|cnt
decl_stmt|;
name|struct
name|meteor_video
modifier|*
name|video
decl_stmt|;
name|struct
name|bktr_capture_area
modifier|*
name|cap_area
decl_stmt|;
name|vm_offset_t
name|buf
decl_stmt|;
name|int
name|i
decl_stmt|;
name|char
name|char_temp
decl_stmt|;
name|bt848
operator|=
name|bktr
operator|->
name|base
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|BT848SCLIP
case|:
comment|/* set clip region */
name|bktr
operator|->
name|max_clip_node
operator|=
literal|0
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|bktr
operator|->
name|clip_list
argument_list|,
name|arg
argument_list|,
sizeof|sizeof
argument_list|(
name|bktr
operator|->
name|clip_list
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|BT848_MAX_CLIP_NODE
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|bktr
operator|->
name|clip_list
index|[
name|i
index|]
operator|.
name|y_min
operator|==
literal|0
operator|&&
name|bktr
operator|->
name|clip_list
index|[
name|i
index|]
operator|.
name|y_max
operator|==
literal|0
condition|)
break|break;
block|}
name|bktr
operator|->
name|max_clip_node
operator|=
name|i
expr_stmt|;
comment|/* make sure that the list contains a valid clip secquence */
comment|/* the clip rectangles should be sorted by x then by y as the                second order sort key */
comment|/* clip rectangle list is terminated by y_min and y_max set to 0 */
comment|/* to disable clipping set  y_min and y_max to 0 in the first                clip rectangle . The first clip rectangle is clip_list[0].              */
if|if
condition|(
name|bktr
operator|->
name|max_clip_node
operator|==
literal|0
operator|&&
operator|(
name|bktr
operator|->
name|clip_list
index|[
literal|0
index|]
operator|.
name|y_min
operator|!=
literal|0
operator|&&
name|bktr
operator|->
name|clip_list
index|[
literal|0
index|]
operator|.
name|y_max
operator|!=
literal|0
operator|)
condition|)
block|{
return|return
name|EINVAL
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|BT848_MAX_CLIP_NODE
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|bktr
operator|->
name|clip_list
index|[
name|i
index|]
operator|.
name|y_min
operator|==
literal|0
operator|&&
name|bktr
operator|->
name|clip_list
index|[
name|i
index|]
operator|.
name|y_max
operator|==
literal|0
condition|)
block|{
break|break;
block|}
if|if
condition|(
name|bktr
operator|->
name|clip_list
index|[
name|i
operator|+
literal|1
index|]
operator|.
name|y_min
operator|!=
literal|0
operator|&&
name|bktr
operator|->
name|clip_list
index|[
name|i
operator|+
literal|1
index|]
operator|.
name|y_max
operator|!=
literal|0
operator|&&
name|bktr
operator|->
name|clip_list
index|[
name|i
index|]
operator|.
name|x_min
operator|>
name|bktr
operator|->
name|clip_list
index|[
name|i
operator|+
literal|1
index|]
operator|.
name|x_min
condition|)
block|{
name|bktr
operator|->
name|max_clip_node
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
name|bktr
operator|->
name|clip_list
index|[
name|i
index|]
operator|.
name|x_min
operator|>=
name|bktr
operator|->
name|clip_list
index|[
name|i
index|]
operator|.
name|x_max
operator|||
name|bktr
operator|->
name|clip_list
index|[
name|i
index|]
operator|.
name|y_min
operator|>=
name|bktr
operator|->
name|clip_list
index|[
name|i
index|]
operator|.
name|y_max
operator|||
name|bktr
operator|->
name|clip_list
index|[
name|i
index|]
operator|.
name|x_min
operator|<
literal|0
operator|||
name|bktr
operator|->
name|clip_list
index|[
name|i
index|]
operator|.
name|x_max
operator|<
literal|0
operator|||
name|bktr
operator|->
name|clip_list
index|[
name|i
index|]
operator|.
name|y_min
operator|<
literal|0
operator|||
name|bktr
operator|->
name|clip_list
index|[
name|i
index|]
operator|.
name|y_max
operator|<
literal|0
condition|)
block|{
name|bktr
operator|->
name|max_clip_node
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
block|}
name|bktr
operator|->
name|dma_prog_loaded
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
name|METEORSTATUS
case|:
comment|/* get Bt848 status */
name|c_temp
operator|=
name|bt848
operator|->
name|dstatus
expr_stmt|;
name|temp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|c_temp
operator|&
literal|0x40
operator|)
condition|)
name|temp
operator||=
name|METEOR_STATUS_HCLK
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|c_temp
operator|&
literal|0x10
operator|)
condition|)
name|temp
operator||=
name|METEOR_STATUS_FIDT
expr_stmt|;
operator|*
operator|(
name|u_short
operator|*
operator|)
name|arg
operator|=
name|temp
expr_stmt|;
break|break;
case|case
name|BT848SFMT
case|:
comment|/* set input format */
name|temp
operator|=
operator|*
operator|(
name|unsigned
name|long
operator|*
operator|)
name|arg
operator|&
name|BT848_IFORM_FORMAT
expr_stmt|;
name|temp_iform
operator|=
name|bt848
operator|->
name|iform
expr_stmt|;
name|temp_iform
operator|&=
operator|~
name|BT848_IFORM_FORMAT
expr_stmt|;
name|temp_iform
operator|&=
operator|~
name|BT848_IFORM_XTSEL
expr_stmt|;
name|bt848
operator|->
name|iform
operator|=
operator|(
name|temp_iform
operator||
name|temp
operator||
name|format_params
index|[
name|temp
index|]
operator|.
name|iform_xtsel
operator|)
expr_stmt|;
switch|switch
condition|(
name|temp
condition|)
block|{
case|case
name|BT848_IFORM_F_AUTO
case|:
name|bktr
operator|->
name|flags
operator|=
operator|(
name|bktr
operator|->
name|flags
operator|&
operator|~
name|METEOR_FORM_MASK
operator|)
operator||
name|METEOR_AUTOMODE
expr_stmt|;
break|break;
case|case
name|BT848_IFORM_F_NTSCM
case|:
case|case
name|BT848_IFORM_F_NTSCJ
case|:
name|bktr
operator|->
name|flags
operator|=
operator|(
name|bktr
operator|->
name|flags
operator|&
operator|~
name|METEOR_FORM_MASK
operator|)
operator||
name|METEOR_NTSC
expr_stmt|;
name|bt848
operator|->
name|adelay
operator|=
name|format_params
index|[
name|temp
index|]
operator|.
name|adelay
expr_stmt|;
name|bt848
operator|->
name|bdelay
operator|=
name|format_params
index|[
name|temp
index|]
operator|.
name|bdelay
expr_stmt|;
name|bktr
operator|->
name|format_params
operator|=
name|temp
expr_stmt|;
break|break;
case|case
name|BT848_IFORM_F_PALBDGHI
case|:
case|case
name|BT848_IFORM_F_PALN
case|:
case|case
name|BT848_IFORM_F_SECAM
case|:
case|case
name|BT848_IFORM_F_RSVD
case|:
case|case
name|BT848_IFORM_F_PALM
case|:
name|bktr
operator|->
name|flags
operator|=
operator|(
name|bktr
operator|->
name|flags
operator|&
operator|~
name|METEOR_FORM_MASK
operator|)
operator||
name|METEOR_PAL
expr_stmt|;
name|bt848
operator|->
name|adelay
operator|=
name|format_params
index|[
name|temp
index|]
operator|.
name|adelay
expr_stmt|;
name|bt848
operator|->
name|bdelay
operator|=
name|format_params
index|[
name|temp
index|]
operator|.
name|bdelay
expr_stmt|;
name|bktr
operator|->
name|format_params
operator|=
name|temp
expr_stmt|;
break|break;
block|}
name|bktr
operator|->
name|dma_prog_loaded
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
name|METEORSFMT
case|:
comment|/* set input format */
name|temp_iform
operator|=
name|bt848
operator|->
name|iform
expr_stmt|;
name|temp_iform
operator|&=
operator|~
name|BT848_IFORM_FORMAT
expr_stmt|;
name|temp_iform
operator|&=
operator|~
name|BT848_IFORM_XTSEL
expr_stmt|;
switch|switch
condition|(
operator|*
operator|(
name|unsigned
name|long
operator|*
operator|)
name|arg
operator|&
name|METEOR_FORM_MASK
condition|)
block|{
case|case
literal|0
case|:
comment|/* default */
case|case
name|METEOR_FMT_NTSC
case|:
name|bktr
operator|->
name|flags
operator|=
operator|(
name|bktr
operator|->
name|flags
operator|&
operator|~
name|METEOR_FORM_MASK
operator|)
operator||
name|METEOR_NTSC
expr_stmt|;
name|bt848
operator|->
name|iform
operator|=
name|temp_iform
operator||
name|BT848_IFORM_F_NTSCM
operator||
name|format_params
index|[
name|BT848_IFORM_F_NTSCM
index|]
operator|.
name|iform_xtsel
expr_stmt|;
name|bt848
operator|->
name|adelay
operator|=
name|format_params
index|[
name|BT848_IFORM_F_NTSCM
index|]
operator|.
name|adelay
expr_stmt|;
name|bt848
operator|->
name|bdelay
operator|=
name|format_params
index|[
name|BT848_IFORM_F_NTSCM
index|]
operator|.
name|bdelay
expr_stmt|;
name|bktr
operator|->
name|format_params
operator|=
name|BT848_IFORM_F_NTSCM
expr_stmt|;
break|break;
case|case
name|METEOR_FMT_PAL
case|:
name|bktr
operator|->
name|flags
operator|=
operator|(
name|bktr
operator|->
name|flags
operator|&
operator|~
name|METEOR_FORM_MASK
operator|)
operator||
name|METEOR_PAL
expr_stmt|;
name|bt848
operator|->
name|iform
operator|=
name|temp_iform
operator||
name|BT848_IFORM_F_PALBDGHI
operator||
name|format_params
index|[
name|BT848_IFORM_F_PALBDGHI
index|]
operator|.
name|iform_xtsel
expr_stmt|;
name|bt848
operator|->
name|adelay
operator|=
name|format_params
index|[
name|BT848_IFORM_F_PALBDGHI
index|]
operator|.
name|adelay
expr_stmt|;
name|bt848
operator|->
name|bdelay
operator|=
name|format_params
index|[
name|BT848_IFORM_F_PALBDGHI
index|]
operator|.
name|bdelay
expr_stmt|;
name|bktr
operator|->
name|format_params
operator|=
name|BT848_IFORM_F_PALBDGHI
expr_stmt|;
break|break;
case|case
name|METEOR_FMT_AUTOMODE
case|:
name|bktr
operator|->
name|flags
operator|=
operator|(
name|bktr
operator|->
name|flags
operator|&
operator|~
name|METEOR_FORM_MASK
operator|)
operator||
name|METEOR_AUTOMODE
expr_stmt|;
name|bt848
operator|->
name|iform
operator|=
name|temp_iform
operator||
name|BT848_IFORM_F_AUTO
operator||
name|format_params
index|[
name|BT848_IFORM_F_AUTO
index|]
operator|.
name|iform_xtsel
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|bktr
operator|->
name|dma_prog_loaded
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
name|METEORGFMT
case|:
comment|/* get input format */
operator|*
operator|(
name|u_long
operator|*
operator|)
name|arg
operator|=
name|bktr
operator|->
name|flags
operator|&
name|METEOR_FORM_MASK
expr_stmt|;
break|break;
case|case
name|BT848GFMT
case|:
comment|/* get input format */
operator|*
operator|(
name|u_long
operator|*
operator|)
name|arg
operator|=
name|bt848
operator|->
name|iform
operator|&
name|BT848_IFORM_FORMAT
expr_stmt|;
break|break;
case|case
name|METEORSCOUNT
case|:
comment|/* (re)set error counts */
name|cnt
operator|=
operator|(
expr|struct
name|meteor_counts
operator|*
operator|)
name|arg
expr_stmt|;
name|bktr
operator|->
name|fifo_errors
operator|=
name|cnt
operator|->
name|fifo_errors
expr_stmt|;
name|bktr
operator|->
name|dma_errors
operator|=
name|cnt
operator|->
name|dma_errors
expr_stmt|;
name|bktr
operator|->
name|frames_captured
operator|=
name|cnt
operator|->
name|frames_captured
expr_stmt|;
name|bktr
operator|->
name|even_fields_captured
operator|=
name|cnt
operator|->
name|even_fields_captured
expr_stmt|;
name|bktr
operator|->
name|odd_fields_captured
operator|=
name|cnt
operator|->
name|odd_fields_captured
expr_stmt|;
break|break;
case|case
name|METEORGCOUNT
case|:
comment|/* get error counts */
name|cnt
operator|=
operator|(
expr|struct
name|meteor_counts
operator|*
operator|)
name|arg
expr_stmt|;
name|cnt
operator|->
name|fifo_errors
operator|=
name|bktr
operator|->
name|fifo_errors
expr_stmt|;
name|cnt
operator|->
name|dma_errors
operator|=
name|bktr
operator|->
name|dma_errors
expr_stmt|;
name|cnt
operator|->
name|frames_captured
operator|=
name|bktr
operator|->
name|frames_captured
expr_stmt|;
name|cnt
operator|->
name|even_fields_captured
operator|=
name|bktr
operator|->
name|even_fields_captured
expr_stmt|;
name|cnt
operator|->
name|odd_fields_captured
operator|=
name|bktr
operator|->
name|odd_fields_captured
expr_stmt|;
break|break;
case|case
name|METEORGVIDEO
case|:
name|video
operator|=
operator|(
expr|struct
name|meteor_video
operator|*
operator|)
name|arg
expr_stmt|;
name|video
operator|->
name|addr
operator|=
name|bktr
operator|->
name|video
operator|.
name|addr
expr_stmt|;
name|video
operator|->
name|width
operator|=
name|bktr
operator|->
name|video
operator|.
name|width
expr_stmt|;
name|video
operator|->
name|banksize
operator|=
name|bktr
operator|->
name|video
operator|.
name|banksize
expr_stmt|;
name|video
operator|->
name|ramsize
operator|=
name|bktr
operator|->
name|video
operator|.
name|ramsize
expr_stmt|;
break|break;
case|case
name|METEORSVIDEO
case|:
name|video
operator|=
operator|(
expr|struct
name|meteor_video
operator|*
operator|)
name|arg
expr_stmt|;
name|bktr
operator|->
name|video
operator|.
name|addr
operator|=
name|video
operator|->
name|addr
expr_stmt|;
name|bktr
operator|->
name|video
operator|.
name|width
operator|=
name|video
operator|->
name|width
expr_stmt|;
name|bktr
operator|->
name|video
operator|.
name|banksize
operator|=
name|video
operator|->
name|banksize
expr_stmt|;
name|bktr
operator|->
name|video
operator|.
name|ramsize
operator|=
name|video
operator|->
name|ramsize
expr_stmt|;
break|break;
case|case
name|METEORSFPS
case|:
name|set_fps
argument_list|(
name|bktr
argument_list|,
operator|*
operator|(
name|u_short
operator|*
operator|)
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
name|METEORGFPS
case|:
operator|*
operator|(
name|u_short
operator|*
operator|)
name|arg
operator|=
name|bktr
operator|->
name|fps
expr_stmt|;
break|break;
case|case
name|METEORSHUE
case|:
comment|/* set hue */
name|bt848
operator|->
name|hue
operator|=
operator|(
operator|*
operator|(
name|u_char
operator|*
operator|)
name|arg
operator|)
operator|&
literal|0xff
expr_stmt|;
break|break;
case|case
name|METEORGHUE
case|:
comment|/* get hue */
operator|*
operator|(
name|u_char
operator|*
operator|)
name|arg
operator|=
name|bt848
operator|->
name|hue
expr_stmt|;
break|break;
case|case
name|METEORSBRIG
case|:
comment|/* set brightness */
name|char_temp
operator|=
operator|(
operator|*
operator|(
name|u_char
operator|*
operator|)
name|arg
operator|&
literal|0xff
operator|)
operator|-
literal|128
expr_stmt|;
name|bt848
operator|->
name|bright
operator|=
name|char_temp
expr_stmt|;
break|break;
case|case
name|METEORGBRIG
case|:
comment|/* get brightness */
operator|*
operator|(
name|u_char
operator|*
operator|)
name|arg
operator|=
name|bt848
operator|->
name|bright
expr_stmt|;
break|break;
case|case
name|METEORSCSAT
case|:
comment|/* set chroma saturation */
name|temp
operator|=
operator|(
name|int
operator|)
operator|*
operator|(
name|u_char
operator|*
operator|)
name|arg
expr_stmt|;
name|bt848
operator|->
name|sat_u_lo
operator|=
name|bt848
operator|->
name|sat_v_lo
operator|=
operator|(
name|temp
operator|<<
literal|1
operator|)
operator|&
literal|0xff
expr_stmt|;
name|bt848
operator|->
name|e_control
operator|&=
operator|~
operator|(
name|BT848_E_CONTROL_SAT_U_MSB
operator||
name|BT848_E_CONTROL_SAT_V_MSB
operator|)
expr_stmt|;
name|bt848
operator|->
name|o_control
operator|&=
operator|~
operator|(
name|BT848_O_CONTROL_SAT_U_MSB
operator||
name|BT848_O_CONTROL_SAT_V_MSB
operator|)
expr_stmt|;
if|if
condition|(
name|temp
operator|&
name|BIT_SEVEN_HIGH
condition|)
block|{
name|bt848
operator|->
name|e_control
operator||=
operator|(
name|BT848_E_CONTROL_SAT_U_MSB
operator||
name|BT848_E_CONTROL_SAT_V_MSB
operator|)
expr_stmt|;
name|bt848
operator|->
name|o_control
operator||=
operator|(
name|BT848_O_CONTROL_SAT_U_MSB
operator||
name|BT848_O_CONTROL_SAT_V_MSB
operator|)
expr_stmt|;
block|}
break|break;
case|case
name|METEORGCSAT
case|:
comment|/* get chroma saturation */
name|temp
operator|=
operator|(
name|bt848
operator|->
name|sat_v_lo
operator|>>
literal|1
operator|)
operator|&
literal|0xff
expr_stmt|;
if|if
condition|(
name|bt848
operator|->
name|e_control
operator|&
name|BT848_E_CONTROL_SAT_V_MSB
condition|)
name|temp
operator||=
name|BIT_SEVEN_HIGH
expr_stmt|;
operator|*
operator|(
name|u_char
operator|*
operator|)
name|arg
operator|=
operator|(
name|u_char
operator|)
name|temp
expr_stmt|;
break|break;
case|case
name|METEORSCONT
case|:
comment|/* set contrast */
name|temp
operator|=
operator|(
name|int
operator|)
operator|*
operator|(
name|u_char
operator|*
operator|)
name|arg
operator|&
literal|0xff
expr_stmt|;
name|temp
operator|<<=
literal|1
expr_stmt|;
name|bt848
operator|->
name|contrast_lo
operator|=
name|temp
operator|&
literal|0xff
expr_stmt|;
name|bt848
operator|->
name|e_control
operator|&=
operator|~
name|BT848_E_CONTROL_CON_MSB
expr_stmt|;
name|bt848
operator|->
name|o_control
operator|&=
operator|~
name|BT848_O_CONTROL_CON_MSB
expr_stmt|;
name|bt848
operator|->
name|e_control
operator||=
operator|(
operator|(
name|temp
operator|&
literal|0x100
operator|)
operator|>>
literal|6
operator|)
operator|&
name|BT848_E_CONTROL_CON_MSB
expr_stmt|;
name|bt848
operator|->
name|o_control
operator||=
operator|(
operator|(
name|temp
operator|&
literal|0x100
operator|)
operator|>>
literal|6
operator|)
operator|&
name|BT848_O_CONTROL_CON_MSB
expr_stmt|;
break|break;
case|case
name|METEORGCONT
case|:
comment|/* get contrast */
name|temp
operator|=
operator|(
name|int
operator|)
name|bt848
operator|->
name|contrast_lo
operator|&
literal|0xff
expr_stmt|;
name|temp
operator||=
operator|(
operator|(
name|int
operator|)
name|bt848
operator|->
name|o_control
operator|&
literal|0x04
operator|)
operator|<<
literal|6
expr_stmt|;
operator|*
operator|(
name|u_char
operator|*
operator|)
name|arg
operator|=
call|(
name|u_char
call|)
argument_list|(
operator|(
name|temp
operator|>>
literal|1
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
break|break;
case|case
name|BT848SCBUF
case|:
comment|/* set Clear-Buffer-on-start flag */
name|bktr
operator|->
name|clr_on_start
operator|=
operator|(
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|!=
literal|0
operator|)
expr_stmt|;
break|break;
case|case
name|BT848GCBUF
case|:
comment|/* get Clear-Buffer-on-start flag */
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|=
operator|(
name|int
operator|)
name|bktr
operator|->
name|clr_on_start
expr_stmt|;
break|break;
case|case
name|METEORSSIGNAL
case|:
if|if
condition|(
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|==
literal|0
operator|||
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|>=
name|NSIG
condition|)
block|{
return|return
operator|(
name|EINVAL
operator|)
return|;
break|break;
block|}
name|bktr
operator|->
name|signal
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
expr_stmt|;
name|bktr
operator|->
name|proc
operator|=
name|pr
expr_stmt|;
break|break;
case|case
name|METEORGSIGNAL
case|:
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|=
name|bktr
operator|->
name|signal
expr_stmt|;
break|break;
case|case
name|METEORCAPTUR
case|:
name|temp
operator|=
name|bktr
operator|->
name|flags
expr_stmt|;
switch|switch
condition|(
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
condition|)
block|{
case|case
name|METEOR_CAP_SINGLE
case|:
if|if
condition|(
name|bktr
operator|->
name|bigbuf
operator|==
literal|0
condition|)
comment|/* no frame buffer allocated */
return|return
operator|(
name|ENOMEM
operator|)
return|;
comment|/* already capturing */
if|if
condition|(
name|temp
operator|&
name|METEOR_CAP_MASK
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
name|start_capture
argument_list|(
name|bktr
argument_list|,
name|METEOR_SINGLE
argument_list|)
expr_stmt|;
comment|/* wait for capture to complete */
name|bt848
operator|->
name|int_stat
operator|=
name|ALL_INTS_CLEARED
expr_stmt|;
name|bt848
operator|->
name|gpio_dma_ctl
operator|=
name|FIFO_ENABLED
expr_stmt|;
name|bt848
operator|->
name|gpio_dma_ctl
operator|=
name|bktr
operator|->
name|capcontrol
expr_stmt|;
name|bt848
operator|->
name|int_mask
operator|=
name|BT848_INT_MYSTERYBIT
operator||
name|BT848_INT_RISCI
operator||
name|BT848_INT_VSYNC
operator||
name|BT848_INT_FMTCHG
expr_stmt|;
name|bt848
operator|->
name|cap_ctl
operator|=
name|bktr
operator|->
name|bktr_cap_ctl
expr_stmt|;
name|error
operator|=
name|tsleep
argument_list|(
name|BKTR_SLEEP
argument_list|,
name|BKTRPRI
argument_list|,
literal|"captur"
argument_list|,
name|hz
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|&&
operator|(
name|error
operator|!=
name|ERESTART
operator|)
condition|)
block|{
comment|/*  Here if we didn't get complete frame  */
ifdef|#
directive|ifdef
name|DIAGNOSTIC
name|printf
argument_list|(
literal|"bktr%d: ioctl: tsleep error %d %x\n"
argument_list|,
name|unit
argument_list|,
name|error
argument_list|,
name|bt848
operator|->
name|risc_count
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* stop dma */
name|bt848
operator|->
name|int_mask
operator|=
name|ALL_INTS_DISABLED
expr_stmt|;
comment|/* disable risc, leave fifo running */
name|bt848
operator|->
name|gpio_dma_ctl
operator|=
name|FIFO_ENABLED
expr_stmt|;
block|}
name|bktr
operator|->
name|flags
operator|&=
operator|~
operator|(
name|METEOR_SINGLE
operator||
name|METEOR_WANT_MASK
operator|)
expr_stmt|;
comment|/* FIXME: should we set bt848->int_stat ??? */
break|break;
case|case
name|METEOR_CAP_CONTINOUS
case|:
if|if
condition|(
name|bktr
operator|->
name|bigbuf
operator|==
literal|0
condition|)
comment|/* no frame buffer allocated */
return|return
operator|(
name|ENOMEM
operator|)
return|;
comment|/* already capturing */
if|if
condition|(
name|temp
operator|&
name|METEOR_CAP_MASK
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
name|start_capture
argument_list|(
name|bktr
argument_list|,
name|METEOR_CONTIN
argument_list|)
expr_stmt|;
name|bt848
operator|->
name|int_stat
operator|=
name|bt848
operator|->
name|int_stat
expr_stmt|;
name|bt848
operator|->
name|gpio_dma_ctl
operator|=
name|FIFO_ENABLED
expr_stmt|;
name|bt848
operator|->
name|gpio_dma_ctl
operator|=
name|bktr
operator|->
name|capcontrol
expr_stmt|;
name|bt848
operator|->
name|cap_ctl
operator|=
name|bktr
operator|->
name|bktr_cap_ctl
expr_stmt|;
name|bt848
operator|->
name|int_mask
operator|=
name|BT848_INT_MYSTERYBIT
operator||
name|BT848_INT_RISCI
operator||
name|BT848_INT_VSYNC
operator||
name|BT848_INT_FMTCHG
expr_stmt|;
ifdef|#
directive|ifdef
name|BT848_DUMP
name|dump_bt848
argument_list|(
name|bt848
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|METEOR_CAP_STOP_CONT
case|:
if|if
condition|(
name|bktr
operator|->
name|flags
operator|&
name|METEOR_CONTIN
condition|)
block|{
comment|/* turn off capture */
name|bt848
operator|->
name|gpio_dma_ctl
operator|=
name|FIFO_RISC_DISABLED
expr_stmt|;
name|bt848
operator|->
name|cap_ctl
operator|=
name|CAPTURE_OFF
expr_stmt|;
name|bt848
operator|->
name|int_mask
operator|=
name|ALL_INTS_DISABLED
expr_stmt|;
name|bktr
operator|->
name|flags
operator|&=
operator|~
operator|(
name|METEOR_CONTIN
operator||
name|METEOR_WANT_MASK
operator|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|METEORSETGEO
case|:
comment|/* can't change parameters while capturing */
if|if
condition|(
name|bktr
operator|->
name|flags
operator|&
name|METEOR_CAP_MASK
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
name|geo
operator|=
operator|(
expr|struct
name|meteor_geomet
operator|*
operator|)
name|arg
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
comment|/* Either even or odd, if even& odd, then these a zero */
if|if
condition|(
operator|(
name|geo
operator|->
name|oformat
operator|&
name|METEOR_GEO_ODD_ONLY
operator|)
operator|&&
operator|(
name|geo
operator|->
name|oformat
operator|&
name|METEOR_GEO_EVEN_ONLY
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"bktr%d: ioctl: Geometry odd or even only.\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* set/clear even/odd flags */
if|if
condition|(
name|geo
operator|->
name|oformat
operator|&
name|METEOR_GEO_ODD_ONLY
condition|)
name|bktr
operator|->
name|flags
operator||=
name|METEOR_ONLY_ODD_FIELDS
expr_stmt|;
else|else
name|bktr
operator|->
name|flags
operator|&=
operator|~
name|METEOR_ONLY_ODD_FIELDS
expr_stmt|;
if|if
condition|(
name|geo
operator|->
name|oformat
operator|&
name|METEOR_GEO_EVEN_ONLY
condition|)
name|bktr
operator|->
name|flags
operator||=
name|METEOR_ONLY_EVEN_FIELDS
expr_stmt|;
else|else
name|bktr
operator|->
name|flags
operator|&=
operator|~
name|METEOR_ONLY_EVEN_FIELDS
expr_stmt|;
if|if
condition|(
name|geo
operator|->
name|columns
operator|<=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"bktr%d: ioctl: %d: columns must be greater than zero.\n"
argument_list|,
name|unit
argument_list|,
name|geo
operator|->
name|columns
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|geo
operator|->
name|columns
operator|&
literal|0x3fe
operator|)
operator|!=
name|geo
operator|->
name|columns
condition|)
block|{
name|printf
argument_list|(
literal|"bktr%d: ioctl: %d: columns too large or not even.\n"
argument_list|,
name|unit
argument_list|,
name|geo
operator|->
name|columns
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
if|if
condition|(
name|geo
operator|->
name|rows
operator|<=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"bktr%d: ioctl: %d: rows must be greater than zero.\n"
argument_list|,
name|unit
argument_list|,
name|geo
operator|->
name|rows
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|(
name|geo
operator|->
name|rows
operator|&
literal|0x7fe
operator|)
operator|!=
name|geo
operator|->
name|rows
operator|)
operator|||
operator|(
operator|(
name|geo
operator|->
name|oformat
operator|&
name|METEOR_GEO_FIELD_MASK
operator|)
operator|&&
operator|(
operator|(
name|geo
operator|->
name|rows
operator|&
literal|0x3fe
operator|)
operator|!=
name|geo
operator|->
name|rows
operator|)
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"bktr%d: ioctl: %d: rows too large or not even.\n"
argument_list|,
name|unit
argument_list|,
name|geo
operator|->
name|rows
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
if|if
condition|(
name|geo
operator|->
name|frames
operator|>
literal|32
condition|)
block|{
name|printf
argument_list|(
literal|"bktr%d: ioctl: too many frames.\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|bktr
operator|->
name|dma_prog_loaded
operator|=
name|FALSE
expr_stmt|;
name|bt848
operator|->
name|gpio_dma_ctl
operator|=
name|FIFO_RISC_DISABLED
expr_stmt|;
name|bt848
operator|->
name|int_mask
operator|=
name|ALL_INTS_DISABLED
expr_stmt|;
if|if
condition|(
operator|(
name|temp
operator|=
operator|(
name|geo
operator|->
name|rows
operator|*
name|geo
operator|->
name|columns
operator|*
name|geo
operator|->
name|frames
operator|*
literal|2
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|geo
operator|->
name|oformat
operator|&
name|METEOR_GEO_RGB24
condition|)
name|temp
operator|=
name|temp
operator|*
literal|2
expr_stmt|;
comment|/* meteor_mem structure for SYNC Capture */
if|if
condition|(
name|geo
operator|->
name|frames
operator|>
literal|1
condition|)
name|temp
operator|+=
name|PAGE_SIZE
expr_stmt|;
name|temp
operator|=
name|btoc
argument_list|(
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|int
operator|)
name|temp
operator|>
name|bktr
operator|->
name|alloc_pages
operator|&&
name|bktr
operator|->
name|video
operator|.
name|addr
operator|==
literal|0
condition|)
block|{
comment|/*****************************/
comment|/* *** OS Dependant code *** */
comment|/*****************************/
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
operator|||
name|defined
argument_list|(
name|__OpenBSD__
argument_list|)
name|bus_dmamap_t
name|dmamap
decl_stmt|;
name|buf
operator|=
name|get_bktr_mem
argument_list|(
name|bktr
argument_list|,
operator|&
name|dmamap
argument_list|,
name|temp
operator|*
name|PAGE_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|!=
literal|0
condition|)
block|{
name|free_bktr_mem
argument_list|(
name|bktr
argument_list|,
name|bktr
operator|->
name|dm_mem
argument_list|,
name|bktr
operator|->
name|bigbuf
argument_list|)
expr_stmt|;
name|bktr
operator|->
name|dm_mem
operator|=
name|dmamap
expr_stmt|;
else|#
directive|else
name|buf
operator|=
name|get_bktr_mem
argument_list|(
name|unit
argument_list|,
name|temp
operator|*
name|PAGE_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|!=
literal|0
condition|)
block|{
name|kmem_free
argument_list|(
name|kernel_map
argument_list|,
name|bktr
operator|->
name|bigbuf
argument_list|,
operator|(
name|bktr
operator|->
name|alloc_pages
operator|*
name|PAGE_SIZE
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|bktr
operator|->
name|bigbuf
operator|=
name|buf
expr_stmt|;
name|bktr
operator|->
name|alloc_pages
operator|=
name|temp
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"bktr%d: ioctl: Allocating %d bytes\n"
argument_list|,
name|unit
argument_list|,
name|temp
operator|*
name|PAGE_SIZE
argument_list|)
expr_stmt|;
block|}
else|else
name|error
operator|=
name|ENOMEM
expr_stmt|;
block|}
block|}
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
name|bktr
operator|->
name|rows
operator|=
name|geo
operator|->
name|rows
expr_stmt|;
name|bktr
operator|->
name|cols
operator|=
name|geo
operator|->
name|columns
expr_stmt|;
name|bktr
operator|->
name|frames
operator|=
name|geo
operator|->
name|frames
expr_stmt|;
comment|/*  Pixel format (if in meteor pixfmt compatibility mode)  */
if|if
condition|(
name|bktr
operator|->
name|pixfmt_compat
condition|)
block|{
name|bktr
operator|->
name|format
operator|=
name|METEOR_GEO_YUV_422
expr_stmt|;
switch|switch
condition|(
name|geo
operator|->
name|oformat
operator|&
name|METEOR_GEO_OUTPUT_MASK
condition|)
block|{
case|case
literal|0
case|:
comment|/* default */
case|case
name|METEOR_GEO_RGB16
case|:
name|bktr
operator|->
name|format
operator|=
name|METEOR_GEO_RGB16
expr_stmt|;
break|break;
case|case
name|METEOR_GEO_RGB24
case|:
name|bktr
operator|->
name|format
operator|=
name|METEOR_GEO_RGB24
expr_stmt|;
break|break;
case|case
name|METEOR_GEO_YUV_422
case|:
name|bktr
operator|->
name|format
operator|=
name|METEOR_GEO_YUV_422
expr_stmt|;
if|if
condition|(
name|geo
operator|->
name|oformat
operator|&
name|METEOR_GEO_YUV_12
condition|)
name|bktr
operator|->
name|format
operator|=
name|METEOR_GEO_YUV_12
expr_stmt|;
break|break;
case|case
name|METEOR_GEO_YUV_PACKED
case|:
name|bktr
operator|->
name|format
operator|=
name|METEOR_GEO_YUV_PACKED
expr_stmt|;
break|break;
block|}
name|bktr
operator|->
name|pixfmt
operator|=
name|oformat_meteor_to_bt
argument_list|(
name|bktr
operator|->
name|format
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bktr
operator|->
name|flags
operator|&
name|METEOR_CAP_MASK
condition|)
block|{
if|if
condition|(
name|bktr
operator|->
name|flags
operator|&
operator|(
name|METEOR_CONTIN
operator||
name|METEOR_SYNCAP
operator|)
condition|)
block|{
switch|switch
condition|(
name|bktr
operator|->
name|flags
operator|&
name|METEOR_ONLY_FIELDS_MASK
condition|)
block|{
case|case
name|METEOR_ONLY_ODD_FIELDS
case|:
name|bktr
operator|->
name|flags
operator||=
name|METEOR_WANT_ODD
expr_stmt|;
break|break;
case|case
name|METEOR_ONLY_EVEN_FIELDS
case|:
name|bktr
operator|->
name|flags
operator||=
name|METEOR_WANT_EVEN
expr_stmt|;
break|break;
default|default:
name|bktr
operator|->
name|flags
operator||=
name|METEOR_WANT_MASK
expr_stmt|;
break|break;
block|}
name|start_capture
argument_list|(
name|bktr
argument_list|,
name|METEOR_CONTIN
argument_list|)
expr_stmt|;
name|bt848
operator|->
name|int_stat
operator|=
name|bt848
operator|->
name|int_stat
expr_stmt|;
name|bt848
operator|->
name|gpio_dma_ctl
operator|=
name|FIFO_ENABLED
expr_stmt|;
name|bt848
operator|->
name|gpio_dma_ctl
operator|=
name|bktr
operator|->
name|capcontrol
expr_stmt|;
name|bt848
operator|->
name|int_mask
operator|=
name|BT848_INT_MYSTERYBIT
operator||
name|BT848_INT_VSYNC
operator||
name|BT848_INT_FMTCHG
expr_stmt|;
block|}
block|}
break|break;
comment|/* end of METEORSETGEO */
comment|/* FIXME. The Capture Area currently has the following restrictions: 	GENERAL 	 y_offset may need to be even in interlaced modes 	RGB24 - Interlaced mode 	 x_size must be greater than or equal to 1.666*METEORSETGEO width (cols) 	 y_size must be greater than or equal to METEORSETGEO height (rows) 	RGB24 - Even Only (or Odd Only) mode 	 x_size must be greater than or equal to 1.666*METEORSETGEO width (cols) 	 y_size must be greater than or equal to 2*METEORSETGEO height (rows) 	YUV12 - Interlaced mode 	 x_size must be greater than or equal to METEORSETGEO width (cols) 	 y_size must be greater than or equal to METEORSETGEO height (rows) 	YUV12 - Even Only (or Odd Only) mode 	 x_size must be greater than or equal to METEORSETGEO width (cols) 	 y_size must be greater than or equal to 2*METEORSETGEO height (rows) 	*/
case|case
name|BT848_SCAPAREA
case|:
comment|/* set capture area of each video frame */
comment|/* can't change parameters while capturing */
if|if
condition|(
name|bktr
operator|->
name|flags
operator|&
name|METEOR_CAP_MASK
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
name|cap_area
operator|=
operator|(
expr|struct
name|bktr_capture_area
operator|*
operator|)
name|arg
expr_stmt|;
name|bktr
operator|->
name|capture_area_x_offset
operator|=
name|cap_area
operator|->
name|x_offset
expr_stmt|;
name|bktr
operator|->
name|capture_area_y_offset
operator|=
name|cap_area
operator|->
name|y_offset
expr_stmt|;
name|bktr
operator|->
name|capture_area_x_size
operator|=
name|cap_area
operator|->
name|x_size
expr_stmt|;
name|bktr
operator|->
name|capture_area_y_size
operator|=
name|cap_area
operator|->
name|y_size
expr_stmt|;
name|bktr
operator|->
name|capture_area_enabled
operator|=
name|TRUE
expr_stmt|;
name|bktr
operator|->
name|dma_prog_loaded
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
name|BT848_GCAPAREA
case|:
comment|/* get capture area of each video frame */
name|cap_area
operator|=
operator|(
expr|struct
name|bktr_capture_area
operator|*
operator|)
name|arg
expr_stmt|;
if|if
condition|(
name|bktr
operator|->
name|capture_area_enabled
operator|==
name|FALSE
condition|)
block|{
name|cap_area
operator|->
name|x_offset
operator|=
literal|0
expr_stmt|;
name|cap_area
operator|->
name|y_offset
operator|=
literal|0
expr_stmt|;
name|cap_area
operator|->
name|x_size
operator|=
name|format_params
index|[
name|bktr
operator|->
name|format_params
index|]
operator|.
name|scaled_hactive
expr_stmt|;
name|cap_area
operator|->
name|y_size
operator|=
name|format_params
index|[
name|bktr
operator|->
name|format_params
index|]
operator|.
name|vactive
expr_stmt|;
block|}
else|else
block|{
name|cap_area
operator|->
name|x_offset
operator|=
name|bktr
operator|->
name|capture_area_x_offset
expr_stmt|;
name|cap_area
operator|->
name|y_offset
operator|=
name|bktr
operator|->
name|capture_area_y_offset
expr_stmt|;
name|cap_area
operator|->
name|x_size
operator|=
name|bktr
operator|->
name|capture_area_x_size
expr_stmt|;
name|cap_area
operator|->
name|y_size
operator|=
name|bktr
operator|->
name|capture_area_y_size
expr_stmt|;
block|}
break|break;
default|default:
return|return
name|common_ioctl
argument_list|(
name|bktr
argument_list|,
name|bt848
argument_list|,
name|cmd
argument_list|,
name|arg
argument_list|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/*  * tuner ioctls  */
specifier|static
name|int
name|tuner_ioctl
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|,
name|int
name|unit
parameter_list|,
name|int
name|cmd
parameter_list|,
name|caddr_t
name|arg
parameter_list|,
name|struct
name|proc
modifier|*
name|pr
parameter_list|)
block|{
name|bt848_ptr_t
name|bt848
decl_stmt|;
name|int
name|tmp_int
decl_stmt|;
name|unsigned
name|int
name|temp
decl_stmt|,
name|temp1
decl_stmt|;
name|int
name|offset
decl_stmt|;
name|int
name|count
decl_stmt|;
name|u_char
modifier|*
name|buf
decl_stmt|;
name|u_long
name|par
decl_stmt|;
name|u_char
name|write
decl_stmt|;
name|int
name|i2c_addr
decl_stmt|;
name|int
name|i2c_port
decl_stmt|;
name|u_long
name|data
decl_stmt|;
name|bt848
operator|=
name|bktr
operator|->
name|base
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|REMOTE_GETKEY
case|:
comment|/* Read the last key pressed by the Remote Control */
if|if
condition|(
name|bktr
operator|->
name|remote_control
operator|==
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|remote_read
argument_list|(
name|bktr
argument_list|,
operator|(
expr|struct
name|bktr_remote
operator|*
operator|)
name|arg
argument_list|)
expr_stmt|;
break|break;
if|#
directive|if
name|defined
argument_list|(
name|TUNER_AFC
argument_list|)
case|case
name|TVTUNER_SETAFC
case|:
name|bktr
operator|->
name|tuner
operator|.
name|afc
operator|=
operator|(
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|!=
literal|0
operator|)
expr_stmt|;
break|break;
case|case
name|TVTUNER_GETAFC
case|:
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|=
name|bktr
operator|->
name|tuner
operator|.
name|afc
expr_stmt|;
comment|/* XXX Perhaps use another bit to indicate AFC success? */
break|break;
endif|#
directive|endif
comment|/* TUNER_AFC */
case|case
name|TVTUNER_SETCHNL
case|:
name|temp_mute
argument_list|(
name|bktr
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|temp
operator|=
name|tv_channel
argument_list|(
name|bktr
argument_list|,
operator|(
name|int
operator|)
operator|*
operator|(
name|unsigned
name|long
operator|*
operator|)
name|arg
argument_list|)
expr_stmt|;
name|temp_mute
argument_list|(
name|bktr
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|<
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
operator|*
operator|(
name|unsigned
name|long
operator|*
operator|)
name|arg
operator|=
name|temp
expr_stmt|;
comment|/* after every channel change, we must restart the MSP34xx */
comment|/* audio chip to reselect NICAM STEREO or MONO audio */
if|if
condition|(
name|bktr
operator|->
name|card
operator|.
name|msp3400c
condition|)
name|msp_autodetect
argument_list|(
name|bktr
argument_list|)
expr_stmt|;
break|break;
case|case
name|TVTUNER_GETCHNL
case|:
operator|*
operator|(
name|unsigned
name|long
operator|*
operator|)
name|arg
operator|=
name|bktr
operator|->
name|tuner
operator|.
name|channel
expr_stmt|;
break|break;
case|case
name|TVTUNER_SETTYPE
case|:
name|temp
operator|=
operator|*
operator|(
name|unsigned
name|long
operator|*
operator|)
name|arg
expr_stmt|;
if|if
condition|(
operator|(
name|temp
operator|<
name|CHNLSET_MIN
operator|)
operator|||
operator|(
name|temp
operator|>
name|CHNLSET_MAX
operator|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|bktr
operator|->
name|tuner
operator|.
name|chnlset
operator|=
name|temp
expr_stmt|;
break|break;
case|case
name|TVTUNER_GETTYPE
case|:
operator|*
operator|(
name|unsigned
name|long
operator|*
operator|)
name|arg
operator|=
name|bktr
operator|->
name|tuner
operator|.
name|chnlset
expr_stmt|;
break|break;
case|case
name|TVTUNER_GETSTATUS
case|:
name|temp
operator|=
name|i2cRead
argument_list|(
name|bktr
argument_list|,
name|bktr
operator|->
name|card
operator|.
name|tuner_pllAddr
operator|+
literal|1
argument_list|)
expr_stmt|;
operator|*
operator|(
name|unsigned
name|long
operator|*
operator|)
name|arg
operator|=
name|temp
operator|&
literal|0xff
expr_stmt|;
break|break;
case|case
name|TVTUNER_SETFREQ
case|:
name|temp_mute
argument_list|(
name|bktr
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|temp
operator|=
name|tv_freq
argument_list|(
name|bktr
argument_list|,
operator|(
name|int
operator|)
operator|*
operator|(
name|unsigned
name|long
operator|*
operator|)
name|arg
argument_list|)
expr_stmt|;
name|temp_mute
argument_list|(
name|bktr
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|<
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
operator|*
operator|(
name|unsigned
name|long
operator|*
operator|)
name|arg
operator|=
name|temp
expr_stmt|;
comment|/* after every channel change, we must restart the MSP34xx */
comment|/* audio chip to reselect NICAM STEREO or MONO audio */
if|if
condition|(
name|bktr
operator|->
name|card
operator|.
name|msp3400c
condition|)
name|msp_autodetect
argument_list|(
name|bktr
argument_list|)
expr_stmt|;
break|break;
case|case
name|TVTUNER_GETFREQ
case|:
operator|*
operator|(
name|unsigned
name|long
operator|*
operator|)
name|arg
operator|=
name|bktr
operator|->
name|tuner
operator|.
name|frequency
expr_stmt|;
break|break;
case|case
name|TVTUNER_GETCHNLSET
case|:
return|return
name|tuner_getchnlset
argument_list|(
operator|(
expr|struct
name|bktr_chnlset
operator|*
operator|)
name|arg
argument_list|)
return|;
case|case
name|BT848_SAUDIO
case|:
comment|/* set audio channel */
if|if
condition|(
name|set_audio
argument_list|(
name|bktr
argument_list|,
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
break|break;
comment|/* hue is a 2's compliment number, -90' to +89.3' in 0.7' steps */
case|case
name|BT848_SHUE
case|:
comment|/* set hue */
name|bt848
operator|->
name|hue
operator|=
call|(
name|u_char
call|)
argument_list|(
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|&
literal|0xff
argument_list|)
expr_stmt|;
break|break;
case|case
name|BT848_GHUE
case|:
comment|/* get hue */
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|=
call|(
name|signed
name|char
call|)
argument_list|(
name|bt848
operator|->
name|hue
operator|&
literal|0xff
argument_list|)
expr_stmt|;
break|break;
comment|/* brightness is a 2's compliment #, -50 to +%49.6% in 0.39% steps */
case|case
name|BT848_SBRIG
case|:
comment|/* set brightness */
name|bt848
operator|->
name|bright
operator|=
call|(
name|u_char
call|)
argument_list|(
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|&
literal|0xff
argument_list|)
expr_stmt|;
break|break;
case|case
name|BT848_GBRIG
case|:
comment|/* get brightness */
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|=
call|(
name|signed
name|char
call|)
argument_list|(
name|bt848
operator|->
name|bright
operator|&
literal|0xff
argument_list|)
expr_stmt|;
break|break;
comment|/*  */
case|case
name|BT848_SCSAT
case|:
comment|/* set chroma saturation */
name|tmp_int
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
expr_stmt|;
name|temp
operator|=
name|bt848
operator|->
name|e_control
expr_stmt|;
name|temp1
operator|=
name|bt848
operator|->
name|o_control
expr_stmt|;
if|if
condition|(
name|tmp_int
operator|&
name|BIT_EIGHT_HIGH
condition|)
block|{
name|temp
operator||=
operator|(
name|BT848_E_CONTROL_SAT_U_MSB
operator||
name|BT848_E_CONTROL_SAT_V_MSB
operator|)
expr_stmt|;
name|temp1
operator||=
operator|(
name|BT848_O_CONTROL_SAT_U_MSB
operator||
name|BT848_O_CONTROL_SAT_V_MSB
operator|)
expr_stmt|;
block|}
else|else
block|{
name|temp
operator|&=
operator|~
operator|(
name|BT848_E_CONTROL_SAT_U_MSB
operator||
name|BT848_E_CONTROL_SAT_V_MSB
operator|)
expr_stmt|;
name|temp1
operator|&=
operator|~
operator|(
name|BT848_O_CONTROL_SAT_U_MSB
operator||
name|BT848_O_CONTROL_SAT_V_MSB
operator|)
expr_stmt|;
block|}
name|bt848
operator|->
name|sat_u_lo
operator|=
call|(
name|u_char
call|)
argument_list|(
name|tmp_int
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|bt848
operator|->
name|sat_v_lo
operator|=
call|(
name|u_char
call|)
argument_list|(
name|tmp_int
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|bt848
operator|->
name|e_control
operator|=
name|temp
expr_stmt|;
name|bt848
operator|->
name|o_control
operator|=
name|temp1
expr_stmt|;
break|break;
case|case
name|BT848_GCSAT
case|:
comment|/* get chroma saturation */
name|tmp_int
operator|=
call|(
name|int
call|)
argument_list|(
name|bt848
operator|->
name|sat_v_lo
operator|&
literal|0xff
argument_list|)
expr_stmt|;
if|if
condition|(
name|bt848
operator|->
name|e_control
operator|&
name|BT848_E_CONTROL_SAT_V_MSB
condition|)
name|tmp_int
operator||=
name|BIT_EIGHT_HIGH
expr_stmt|;
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|=
name|tmp_int
expr_stmt|;
break|break;
comment|/*  */
case|case
name|BT848_SVSAT
case|:
comment|/* set chroma V saturation */
name|tmp_int
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
expr_stmt|;
name|temp
operator|=
name|bt848
operator|->
name|e_control
expr_stmt|;
name|temp1
operator|=
name|bt848
operator|->
name|o_control
expr_stmt|;
if|if
condition|(
name|tmp_int
operator|&
name|BIT_EIGHT_HIGH
condition|)
block|{
name|temp
operator||=
name|BT848_E_CONTROL_SAT_V_MSB
expr_stmt|;
name|temp1
operator||=
name|BT848_O_CONTROL_SAT_V_MSB
expr_stmt|;
block|}
else|else
block|{
name|temp
operator|&=
operator|~
name|BT848_E_CONTROL_SAT_V_MSB
expr_stmt|;
name|temp1
operator|&=
operator|~
name|BT848_O_CONTROL_SAT_V_MSB
expr_stmt|;
block|}
name|bt848
operator|->
name|sat_v_lo
operator|=
call|(
name|u_char
call|)
argument_list|(
name|tmp_int
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|bt848
operator|->
name|e_control
operator|=
name|temp
expr_stmt|;
name|bt848
operator|->
name|o_control
operator|=
name|temp1
expr_stmt|;
break|break;
case|case
name|BT848_GVSAT
case|:
comment|/* get chroma V saturation */
name|tmp_int
operator|=
operator|(
name|int
operator|)
name|bt848
operator|->
name|sat_v_lo
operator|&
literal|0xff
expr_stmt|;
if|if
condition|(
name|bt848
operator|->
name|e_control
operator|&
name|BT848_E_CONTROL_SAT_V_MSB
condition|)
name|tmp_int
operator||=
name|BIT_EIGHT_HIGH
expr_stmt|;
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|=
name|tmp_int
expr_stmt|;
break|break;
comment|/*  */
case|case
name|BT848_SUSAT
case|:
comment|/* set chroma U saturation */
name|tmp_int
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
expr_stmt|;
name|temp
operator|=
name|bt848
operator|->
name|e_control
expr_stmt|;
name|temp1
operator|=
name|bt848
operator|->
name|o_control
expr_stmt|;
if|if
condition|(
name|tmp_int
operator|&
name|BIT_EIGHT_HIGH
condition|)
block|{
name|temp
operator||=
name|BT848_E_CONTROL_SAT_U_MSB
expr_stmt|;
name|temp1
operator||=
name|BT848_O_CONTROL_SAT_U_MSB
expr_stmt|;
block|}
else|else
block|{
name|temp
operator|&=
operator|~
name|BT848_E_CONTROL_SAT_U_MSB
expr_stmt|;
name|temp1
operator|&=
operator|~
name|BT848_O_CONTROL_SAT_U_MSB
expr_stmt|;
block|}
name|bt848
operator|->
name|sat_u_lo
operator|=
call|(
name|u_char
call|)
argument_list|(
name|tmp_int
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|bt848
operator|->
name|e_control
operator|=
name|temp
expr_stmt|;
name|bt848
operator|->
name|o_control
operator|=
name|temp1
expr_stmt|;
break|break;
case|case
name|BT848_GUSAT
case|:
comment|/* get chroma U saturation */
name|tmp_int
operator|=
operator|(
name|int
operator|)
name|bt848
operator|->
name|sat_u_lo
operator|&
literal|0xff
expr_stmt|;
if|if
condition|(
name|bt848
operator|->
name|e_control
operator|&
name|BT848_E_CONTROL_SAT_U_MSB
condition|)
name|tmp_int
operator||=
name|BIT_EIGHT_HIGH
expr_stmt|;
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|=
name|tmp_int
expr_stmt|;
break|break;
comment|/* lr 970528 luma notch etc - 3 high bits of e_control/o_control */
case|case
name|BT848_SLNOTCH
case|:
comment|/* set luma notch */
name|tmp_int
operator|=
operator|(
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|&
literal|0x7
operator|)
operator|<<
literal|5
expr_stmt|;
name|bt848
operator|->
name|e_control
operator|&=
operator|~
literal|0xe0
expr_stmt|;
name|bt848
operator|->
name|o_control
operator|&=
operator|~
literal|0xe0
expr_stmt|;
name|bt848
operator|->
name|e_control
operator||=
name|tmp_int
expr_stmt|;
name|bt848
operator|->
name|o_control
operator||=
name|tmp_int
expr_stmt|;
break|break;
case|case
name|BT848_GLNOTCH
case|:
comment|/* get luma notch */
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|=
call|(
name|int
call|)
argument_list|(
operator|(
name|bt848
operator|->
name|e_control
operator|&
literal|0xe0
operator|)
operator|>>
literal|5
argument_list|)
expr_stmt|;
break|break;
comment|/*  */
case|case
name|BT848_SCONT
case|:
comment|/* set contrast */
name|tmp_int
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
expr_stmt|;
name|temp
operator|=
name|bt848
operator|->
name|e_control
expr_stmt|;
name|temp1
operator|=
name|bt848
operator|->
name|o_control
expr_stmt|;
if|if
condition|(
name|tmp_int
operator|&
name|BIT_EIGHT_HIGH
condition|)
block|{
name|temp
operator||=
name|BT848_E_CONTROL_CON_MSB
expr_stmt|;
name|temp1
operator||=
name|BT848_O_CONTROL_CON_MSB
expr_stmt|;
block|}
else|else
block|{
name|temp
operator|&=
operator|~
name|BT848_E_CONTROL_CON_MSB
expr_stmt|;
name|temp1
operator|&=
operator|~
name|BT848_O_CONTROL_CON_MSB
expr_stmt|;
block|}
name|bt848
operator|->
name|contrast_lo
operator|=
call|(
name|u_char
call|)
argument_list|(
name|tmp_int
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|bt848
operator|->
name|e_control
operator|=
name|temp
expr_stmt|;
name|bt848
operator|->
name|o_control
operator|=
name|temp1
expr_stmt|;
break|break;
case|case
name|BT848_GCONT
case|:
comment|/* get contrast */
name|tmp_int
operator|=
operator|(
name|int
operator|)
name|bt848
operator|->
name|contrast_lo
operator|&
literal|0xff
expr_stmt|;
if|if
condition|(
name|bt848
operator|->
name|e_control
operator|&
name|BT848_E_CONTROL_CON_MSB
condition|)
name|tmp_int
operator||=
name|BIT_EIGHT_HIGH
expr_stmt|;
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|=
name|tmp_int
expr_stmt|;
break|break;
comment|/*  FIXME:  SCBARS and CCBARS require a valid int *        */
comment|/*    argument to succeed, but its not used; consider      */
comment|/*    using the arg to store the on/off state so           */
comment|/*    there's only one ioctl() needed to turn cbars on/off */
case|case
name|BT848_SCBARS
case|:
comment|/* set colorbar output */
name|bt848
operator|->
name|color_ctl_color_bars
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|BT848_CCBARS
case|:
comment|/* clear colorbar output */
name|bt848
operator|->
name|color_ctl_color_bars
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|BT848_GAUDIO
case|:
comment|/* get audio channel */
name|temp
operator|=
name|bktr
operator|->
name|audio_mux_select
expr_stmt|;
if|if
condition|(
name|bktr
operator|->
name|audio_mute_state
operator|==
name|TRUE
condition|)
name|temp
operator||=
name|AUDIO_MUTE
expr_stmt|;
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|=
name|temp
expr_stmt|;
break|break;
case|case
name|BT848_SBTSC
case|:
comment|/* set audio channel */
if|if
condition|(
name|set_BTSC
argument_list|(
name|bktr
argument_list|,
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
break|break;
case|case
name|BT848_WEEPROM
case|:
comment|/* write eeprom */
name|offset
operator|=
operator|(
operator|(
operator|(
expr|struct
name|eeProm
operator|*
operator|)
name|arg
operator|)
operator|->
name|offset
operator|)
expr_stmt|;
name|count
operator|=
operator|(
operator|(
operator|(
expr|struct
name|eeProm
operator|*
operator|)
name|arg
operator|)
operator|->
name|count
operator|)
expr_stmt|;
name|buf
operator|=
operator|&
operator|(
operator|(
operator|(
expr|struct
name|eeProm
operator|*
operator|)
name|arg
operator|)
operator|->
name|bytes
index|[
literal|0
index|]
operator|)
expr_stmt|;
if|if
condition|(
name|writeEEProm
argument_list|(
name|bktr
argument_list|,
name|offset
argument_list|,
name|count
argument_list|,
name|buf
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
break|break;
case|case
name|BT848_REEPROM
case|:
comment|/* read eeprom */
name|offset
operator|=
operator|(
operator|(
operator|(
expr|struct
name|eeProm
operator|*
operator|)
name|arg
operator|)
operator|->
name|offset
operator|)
expr_stmt|;
name|count
operator|=
operator|(
operator|(
operator|(
expr|struct
name|eeProm
operator|*
operator|)
name|arg
operator|)
operator|->
name|count
operator|)
expr_stmt|;
name|buf
operator|=
operator|&
operator|(
operator|(
operator|(
expr|struct
name|eeProm
operator|*
operator|)
name|arg
operator|)
operator|->
name|bytes
index|[
literal|0
index|]
operator|)
expr_stmt|;
if|if
condition|(
name|readEEProm
argument_list|(
name|bktr
argument_list|,
name|offset
argument_list|,
name|count
argument_list|,
name|buf
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
break|break;
case|case
name|BT848_SIGNATURE
case|:
name|offset
operator|=
operator|(
operator|(
operator|(
expr|struct
name|eeProm
operator|*
operator|)
name|arg
operator|)
operator|->
name|offset
operator|)
expr_stmt|;
name|count
operator|=
operator|(
operator|(
operator|(
expr|struct
name|eeProm
operator|*
operator|)
name|arg
operator|)
operator|->
name|count
operator|)
expr_stmt|;
name|buf
operator|=
operator|&
operator|(
operator|(
operator|(
expr|struct
name|eeProm
operator|*
operator|)
name|arg
operator|)
operator|->
name|bytes
index|[
literal|0
index|]
operator|)
expr_stmt|;
if|if
condition|(
name|signCard
argument_list|(
name|bktr
argument_list|,
name|offset
argument_list|,
name|count
argument_list|,
name|buf
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
break|break;
comment|/* Ioctl's for direct gpio access */
ifdef|#
directive|ifdef
name|BKTR_GPIO_ACCESS
case|case
name|BT848_GPIO_GET_EN
case|:
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|=
name|bt848
operator|->
name|gpio_out_en
expr_stmt|;
break|break;
case|case
name|BT848_GPIO_SET_EN
case|:
name|bt848
operator|->
name|gpio_out_en
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
expr_stmt|;
break|break;
case|case
name|BT848_GPIO_GET_DATA
case|:
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|=
name|bt848
operator|->
name|gpio_data
expr_stmt|;
break|break;
case|case
name|BT848_GPIO_SET_DATA
case|:
name|bt848
operator|->
name|gpio_data
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* BKTR_GPIO_ACCESS */
comment|/* Ioctl's for running the tuner device in radio mode		*/
case|case
name|RADIO_GETMODE
case|:
operator|*
operator|(
name|unsigned
name|char
operator|*
operator|)
name|arg
operator|=
name|bktr
operator|->
name|tuner
operator|.
name|radio_mode
expr_stmt|;
break|break;
case|case
name|RADIO_SETMODE
case|:
name|bktr
operator|->
name|tuner
operator|.
name|radio_mode
operator|=
operator|*
operator|(
name|unsigned
name|char
operator|*
operator|)
name|arg
expr_stmt|;
break|break;
case|case
name|RADIO_GETFREQ
case|:
operator|*
operator|(
name|unsigned
name|long
operator|*
operator|)
name|arg
operator|=
operator|(
name|bktr
operator|->
name|tuner
operator|.
name|frequency
operator|+
literal|407
operator|)
operator|*
literal|5
expr_stmt|;
break|break;
case|case
name|RADIO_SETFREQ
case|:
comment|/* The argument to this ioctl is NOT freq*16. It is 	    ** freq*100. 	    */
comment|/* The radio in my stereo and the linear regression function 	    ** in my HP48 have reached the conclusion that in order to 	    ** set the radio tuner of the FM1216 to f MHz, the value to 	    ** enter into the Tuner PLL is: f*20-407 	    ** If anyone has the exact values from the spec. sheet 	    ** please forward them  -- fj@login.dknet.dk 	    */
if|if
condition|(
name|bktr
operator|->
name|bt848_tuner
operator|==
name|ALPS_TSCH5
condition|)
block|{
name|temp
operator|=
operator|(
operator|(
name|int
operator|)
operator|*
operator|(
name|unsigned
name|long
operator|*
operator|)
name|arg
operator|+
literal|4125
operator|)
operator|*
literal|32
expr_stmt|;
name|temp
operator|=
name|temp
operator|/
literal|100
operator|+
operator|(
name|temp
operator|%
literal|100
operator|>=
literal|50
condition|?
literal|1
else|:
literal|0
operator|)
operator|+
name|RADIO_OFFSET
expr_stmt|;
block|}
else|else
block|{
name|temp
operator|=
operator|(
name|int
operator|)
operator|*
operator|(
name|unsigned
name|long
operator|*
operator|)
name|arg
operator|/
literal|5
operator|-
literal|407
operator|+
name|RADIO_OFFSET
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|BKTR_RADIO_DEBUG
name|printf
argument_list|(
literal|"bktr%d: arg=%d temp=%d\n"
argument_list|,
name|unit
argument_list|,
operator|(
name|int
operator|)
operator|*
operator|(
name|unsigned
name|long
operator|*
operator|)
name|arg
argument_list|,
name|temp
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|BKTR_RADIO_NOFREQCHECK
comment|/* According to the spec. sheet the band: 87.5MHz-108MHz	*/
comment|/* is supported.						*/
if|if
condition|(
name|temp
operator|<
literal|1343
operator|+
name|RADIO_OFFSET
operator|||
name|temp
operator|>
literal|1753
operator|+
name|RADIO_OFFSET
condition|)
block|{
name|printf
argument_list|(
literal|"bktr%d: Radio frequency out of range\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
endif|#
directive|endif
name|temp_mute
argument_list|(
name|bktr
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|temp
operator|=
name|tv_freq
argument_list|(
name|bktr
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|temp_mute
argument_list|(
name|bktr
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|BKTR_RADIO_DEBUG
if|if
condition|(
name|temp
condition|)
name|printf
argument_list|(
literal|"bktr%d: tv_freq returned: %d\n"
argument_list|,
name|unit
argument_list|,
name|temp
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|temp
operator|<
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
operator|*
operator|(
name|unsigned
name|long
operator|*
operator|)
name|arg
operator|=
name|temp
expr_stmt|;
break|break;
comment|/* Luigi's I2CWR ioctl */
case|case
name|BT848_I2CWR
case|:
name|par
operator|=
operator|*
operator|(
name|u_long
operator|*
operator|)
name|arg
expr_stmt|;
name|write
operator|=
operator|(
name|par
operator|>>
literal|24
operator|)
operator|&
literal|0xff
expr_stmt|;
name|i2c_addr
operator|=
operator|(
name|par
operator|>>
literal|16
operator|)
operator|&
literal|0xff
expr_stmt|;
name|i2c_port
operator|=
operator|(
name|par
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
name|data
operator|=
operator|(
name|par
operator|)
operator|&
literal|0xff
expr_stmt|;
if|if
condition|(
name|write
condition|)
block|{
name|i2cWrite
argument_list|(
name|bktr
argument_list|,
name|i2c_addr
argument_list|,
name|i2c_port
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|data
operator|=
name|i2cRead
argument_list|(
name|bktr
argument_list|,
name|i2c_addr
argument_list|)
expr_stmt|;
block|}
operator|*
operator|(
name|u_long
operator|*
operator|)
name|arg
operator|=
operator|(
name|par
operator|&
literal|0xffffff00
operator|)
operator||
operator|(
name|data
operator|&
literal|0xff
operator|)
expr_stmt|;
break|break;
default|default:
return|return
name|common_ioctl
argument_list|(
name|bktr
argument_list|,
name|bt848
argument_list|,
name|cmd
argument_list|,
name|arg
argument_list|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/*  * common ioctls  */
name|int
name|common_ioctl
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|,
name|bt848_ptr_t
name|bt848
parameter_list|,
name|int
name|cmd
parameter_list|,
name|caddr_t
name|arg
parameter_list|)
block|{
name|int
name|pixfmt
decl_stmt|;
name|unsigned
name|int
name|temp
decl_stmt|;
name|struct
name|meteor_pixfmt
modifier|*
name|pf_pub
decl_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|METEORSINPUT
case|:
comment|/* set input device */
comment|/*Bt848 has 3 MUX Inputs. Bt848A/849A/878/879 has 4 MUX Inputs*/
comment|/* On the original bt848 boards, */
comment|/*   Tuner is MUX0, RCA is MUX1, S-Video is MUX2 */
comment|/* On the Hauppauge bt878 boards, */
comment|/*   Tuner is MUX0, RCA is MUX3 */
comment|/* Unfortunatly Meteor driver codes DEV_RCA as DEV_0, so we */
comment|/* stick with this system in our Meteor Emulation */
switch|switch
condition|(
operator|*
operator|(
name|unsigned
name|long
operator|*
operator|)
name|arg
operator|&
name|METEOR_DEV_MASK
condition|)
block|{
comment|/* this is the RCA video input */
case|case
literal|0
case|:
comment|/* default */
case|case
name|METEOR_INPUT_DEV0
case|:
comment|/* METEOR_INPUT_DEV_RCA: */
name|bktr
operator|->
name|flags
operator|=
operator|(
name|bktr
operator|->
name|flags
operator|&
operator|~
name|METEOR_DEV_MASK
operator|)
operator||
name|METEOR_DEV0
expr_stmt|;
name|bt848
operator|->
name|iform
operator|&=
operator|~
name|BT848_IFORM_MUXSEL
expr_stmt|;
comment|/* work around for new Hauppauge 878 cards */
if|if
condition|(
operator|(
name|bktr
operator|->
name|card
operator|.
name|card_id
operator|==
name|CARD_HAUPPAUGE
operator|)
operator|&&
operator|(
name|bktr
operator|->
name|id
operator|==
name|BROOKTREE_878
operator|||
name|bktr
operator|->
name|id
operator|==
name|BROOKTREE_879
operator|)
condition|)
name|bt848
operator|->
name|iform
operator||=
name|BT848_IFORM_M_MUX3
expr_stmt|;
else|else
name|bt848
operator|->
name|iform
operator||=
name|BT848_IFORM_M_MUX1
expr_stmt|;
name|bt848
operator|->
name|e_control
operator|&=
operator|~
name|BT848_E_CONTROL_COMP
expr_stmt|;
name|bt848
operator|->
name|o_control
operator|&=
operator|~
name|BT848_O_CONTROL_COMP
expr_stmt|;
name|set_audio
argument_list|(
name|bktr
argument_list|,
name|AUDIO_EXTERN
argument_list|)
expr_stmt|;
break|break;
comment|/* this is the tuner input */
case|case
name|METEOR_INPUT_DEV1
case|:
name|bktr
operator|->
name|flags
operator|=
operator|(
name|bktr
operator|->
name|flags
operator|&
operator|~
name|METEOR_DEV_MASK
operator|)
operator||
name|METEOR_DEV1
expr_stmt|;
name|bt848
operator|->
name|iform
operator|&=
operator|~
name|BT848_IFORM_MUXSEL
expr_stmt|;
name|bt848
operator|->
name|iform
operator||=
name|BT848_IFORM_M_MUX0
expr_stmt|;
name|bt848
operator|->
name|e_control
operator|&=
operator|~
name|BT848_E_CONTROL_COMP
expr_stmt|;
name|bt848
operator|->
name|o_control
operator|&=
operator|~
name|BT848_O_CONTROL_COMP
expr_stmt|;
name|set_audio
argument_list|(
name|bktr
argument_list|,
name|AUDIO_TUNER
argument_list|)
expr_stmt|;
break|break;
comment|/* this is the S-VHS input, but with a composite camera */
case|case
name|METEOR_INPUT_DEV2
case|:
name|bktr
operator|->
name|flags
operator|=
operator|(
name|bktr
operator|->
name|flags
operator|&
operator|~
name|METEOR_DEV_MASK
operator|)
operator||
name|METEOR_DEV2
expr_stmt|;
name|bt848
operator|->
name|iform
operator|&=
operator|~
name|BT848_IFORM_MUXSEL
expr_stmt|;
name|bt848
operator|->
name|iform
operator||=
name|BT848_IFORM_M_MUX2
expr_stmt|;
name|bt848
operator|->
name|e_control
operator|&=
operator|~
name|BT848_E_CONTROL_COMP
expr_stmt|;
name|bt848
operator|->
name|o_control
operator|&=
operator|~
name|BT848_O_CONTROL_COMP
expr_stmt|;
name|set_audio
argument_list|(
name|bktr
argument_list|,
name|AUDIO_EXTERN
argument_list|)
expr_stmt|;
break|break;
comment|/* this is the S-VHS input */
case|case
name|METEOR_INPUT_DEV_SVIDEO
case|:
name|bktr
operator|->
name|flags
operator|=
operator|(
name|bktr
operator|->
name|flags
operator|&
operator|~
name|METEOR_DEV_MASK
operator|)
operator||
name|METEOR_DEV_SVIDEO
expr_stmt|;
name|bt848
operator|->
name|iform
operator|&=
operator|~
name|BT848_IFORM_MUXSEL
expr_stmt|;
name|bt848
operator|->
name|iform
operator||=
name|BT848_IFORM_M_MUX2
expr_stmt|;
name|bt848
operator|->
name|e_control
operator||=
name|BT848_E_CONTROL_COMP
expr_stmt|;
name|bt848
operator|->
name|o_control
operator||=
name|BT848_O_CONTROL_COMP
expr_stmt|;
name|set_audio
argument_list|(
name|bktr
argument_list|,
name|AUDIO_EXTERN
argument_list|)
expr_stmt|;
break|break;
case|case
name|METEOR_INPUT_DEV3
case|:
if|if
condition|(
operator|(
name|bktr
operator|->
name|id
operator|==
name|BROOKTREE_848A
operator|)
operator|||
operator|(
name|bktr
operator|->
name|id
operator|==
name|BROOKTREE_849A
operator|)
operator|||
operator|(
name|bktr
operator|->
name|id
operator|==
name|BROOKTREE_878
operator|)
operator|||
operator|(
name|bktr
operator|->
name|id
operator|==
name|BROOKTREE_879
operator|)
condition|)
block|{
name|bktr
operator|->
name|flags
operator|=
operator|(
name|bktr
operator|->
name|flags
operator|&
operator|~
name|METEOR_DEV_MASK
operator|)
operator||
name|METEOR_DEV3
expr_stmt|;
name|bt848
operator|->
name|iform
operator|&=
operator|~
name|BT848_IFORM_MUXSEL
expr_stmt|;
comment|/* work around for new Hauppauge 878 cards */
if|if
condition|(
operator|(
name|bktr
operator|->
name|card
operator|.
name|card_id
operator|==
name|CARD_HAUPPAUGE
operator|)
operator|&&
operator|(
name|bktr
operator|->
name|id
operator|==
name|BROOKTREE_878
operator|||
name|bktr
operator|->
name|id
operator|==
name|BROOKTREE_879
operator|)
condition|)
name|bt848
operator|->
name|iform
operator||=
name|BT848_IFORM_M_MUX1
expr_stmt|;
else|else
name|bt848
operator|->
name|iform
operator||=
name|BT848_IFORM_M_MUX3
expr_stmt|;
name|bt848
operator|->
name|e_control
operator|&=
operator|~
name|BT848_E_CONTROL_COMP
expr_stmt|;
name|bt848
operator|->
name|o_control
operator|&=
operator|~
name|BT848_O_CONTROL_COMP
expr_stmt|;
name|set_audio
argument_list|(
name|bktr
argument_list|,
name|AUDIO_EXTERN
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
break|break;
case|case
name|METEORGINPUT
case|:
comment|/* get input device */
operator|*
operator|(
name|u_long
operator|*
operator|)
name|arg
operator|=
name|bktr
operator|->
name|flags
operator|&
name|METEOR_DEV_MASK
expr_stmt|;
break|break;
case|case
name|METEORSACTPIXFMT
case|:
if|if
condition|(
operator|(
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|<
literal|0
operator|)
operator|||
operator|(
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|>=
name|PIXFMT_TABLE_SIZE
operator|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|bktr
operator|->
name|pixfmt
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
expr_stmt|;
name|bt848
operator|->
name|color_ctl_swap
operator|=
name|pixfmt_swap_flags
argument_list|(
name|bktr
operator|->
name|pixfmt
argument_list|)
expr_stmt|;
name|bktr
operator|->
name|pixfmt_compat
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
name|METEORGACTPIXFMT
case|:
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|=
name|bktr
operator|->
name|pixfmt
expr_stmt|;
break|break;
case|case
name|METEORGSUPPIXFMT
case|:
name|pf_pub
operator|=
operator|(
expr|struct
name|meteor_pixfmt
operator|*
operator|)
name|arg
expr_stmt|;
name|pixfmt
operator|=
name|pf_pub
operator|->
name|index
expr_stmt|;
if|if
condition|(
operator|(
name|pixfmt
operator|<
literal|0
operator|)
operator|||
operator|(
name|pixfmt
operator|>=
name|PIXFMT_TABLE_SIZE
operator|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|memcpy
argument_list|(
name|pf_pub
argument_list|,
operator|&
name|pixfmt_table
index|[
name|pixfmt
index|]
operator|.
name|public
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|pf_pub
argument_list|)
argument_list|)
expr_stmt|;
comment|/*  Patch in our format index  */
name|pf_pub
operator|->
name|index
operator|=
name|pixfmt
expr_stmt|;
break|break;
if|#
directive|if
name|defined
argument_list|(
name|STATUS_SUM
argument_list|)
case|case
name|BT848_GSTATUS
case|:
comment|/* reap status */
name|disable_intr
argument_list|()
expr_stmt|;
name|temp
operator|=
name|status_sum
expr_stmt|;
name|status_sum
operator|=
literal|0
expr_stmt|;
name|enable_intr
argument_list|()
expr_stmt|;
operator|*
operator|(
name|u_int
operator|*
operator|)
name|arg
operator|=
name|temp
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* STATUS_SUM */
default|default:
return|return
operator|(
name|ENOTTY
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/******************************************************************************  * bt848 RISC programming routines:  */
comment|/*  *   */
ifdef|#
directive|ifdef
name|BT848_DEBUG
specifier|static
name|int
name|dump_bt848
parameter_list|(
name|bt848_ptr_t
name|bt848
parameter_list|)
block|{
specifier|volatile
name|u_char
modifier|*
name|bt848r
init|=
operator|(
name|u_char
operator|*
operator|)
name|bt848
decl_stmt|;
name|int
name|r
index|[
literal|60
index|]
init|=
block|{
literal|4
block|,
literal|8
block|,
literal|0xc
block|,
literal|0x8c
block|,
literal|0x10
block|,
literal|0x90
block|,
literal|0x14
block|,
literal|0x94
block|,
literal|0x18
block|,
literal|0x98
block|,
literal|0x1c
block|,
literal|0x9c
block|,
literal|0x20
block|,
literal|0xa0
block|,
literal|0x24
block|,
literal|0xa4
block|,
literal|0x28
block|,
literal|0x2c
block|,
literal|0xac
block|,
literal|0x30
block|,
literal|0x34
block|,
literal|0x38
block|,
literal|0x3c
block|,
literal|0x40
block|,
literal|0xc0
block|,
literal|0x48
block|,
literal|0x4c
block|,
literal|0xcc
block|,
literal|0x50
block|,
literal|0xd0
block|,
literal|0xd4
block|,
literal|0x60
block|,
literal|0x64
block|,
literal|0x68
block|,
literal|0x6c
block|,
literal|0xec
block|,
literal|0xd8
block|,
literal|0xdc
block|,
literal|0xe0
block|,
literal|0xe4
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|40
condition|;
name|i
operator|+=
literal|4
control|)
block|{
name|printf
argument_list|(
literal|" Reg:value : \t%x:%x \t%x:%x \t %x:%x \t %x:%x\n"
argument_list|,
name|r
index|[
name|i
index|]
argument_list|,
name|bt848r
index|[
name|r
index|[
name|i
index|]
index|]
argument_list|,
name|r
index|[
name|i
operator|+
literal|1
index|]
argument_list|,
name|bt848r
index|[
name|r
index|[
name|i
operator|+
literal|1
index|]
index|]
argument_list|,
name|r
index|[
name|i
operator|+
literal|2
index|]
argument_list|,
name|bt848r
index|[
name|r
index|[
name|i
operator|+
literal|2
index|]
index|]
argument_list|,
name|r
index|[
name|i
operator|+
literal|3
index|]
argument_list|,
name|bt848r
index|[
name|r
index|[
name|i
operator|+
literal|3
index|]
index|]
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|" INT STAT %x \n"
argument_list|,
name|bt848
operator|->
name|int_stat
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" Reg INT_MASK %x \n"
argument_list|,
name|bt848
operator|->
name|int_mask
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" Reg GPIO_DMA_CTL %x \n"
argument_list|,
name|bt848
operator|->
name|gpio_dma_ctl
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
endif|#
directive|endif
comment|/*  * build write instruction  */
define|#
directive|define
name|BKTR_FM1
value|0x6
comment|/* packed data to follow */
define|#
directive|define
name|BKTR_FM3
value|0xe
comment|/* planar data to follow */
define|#
directive|define
name|BKTR_VRE
value|0x4
comment|/* Marks the end of the even field */
define|#
directive|define
name|BKTR_VRO
value|0xC
comment|/* Marks the end of the odd field */
define|#
directive|define
name|BKTR_PXV
value|0x0
comment|/* valid word (never used) */
define|#
directive|define
name|BKTR_EOL
value|0x1
comment|/* last dword, 4 bytes */
define|#
directive|define
name|BKTR_SOL
value|0x2
comment|/* first dword */
define|#
directive|define
name|OP_WRITE
value|(0x1<< 28)
define|#
directive|define
name|OP_SKIP
value|(0x2<< 28)
define|#
directive|define
name|OP_WRITEC
value|(0x5<< 28)
define|#
directive|define
name|OP_JUMP
value|(0x7<< 28)
define|#
directive|define
name|OP_SYNC
value|(0x8<< 28)
define|#
directive|define
name|OP_WRITE123
value|(0x9<< 28)
define|#
directive|define
name|OP_WRITES123
value|(0xb<< 28)
define|#
directive|define
name|OP_SOL
value|(1<< 27)
comment|/* first instr for scanline */
define|#
directive|define
name|OP_EOL
value|(1<< 26)
define|#
directive|define
name|BKTR_RESYNC
value|(1<< 15)
define|#
directive|define
name|BKTR_GEN_IRQ
value|(1<< 24)
comment|/*  * The RISC status bits can be set/cleared in the RISC programs  * and tested in the Interrupt Handler  */
define|#
directive|define
name|BKTR_SET_RISC_STATUS_BIT0
value|(1<< 16)
define|#
directive|define
name|BKTR_SET_RISC_STATUS_BIT1
value|(1<< 17)
define|#
directive|define
name|BKTR_SET_RISC_STATUS_BIT2
value|(1<< 18)
define|#
directive|define
name|BKTR_SET_RISC_STATUS_BIT3
value|(1<< 19)
define|#
directive|define
name|BKTR_CLEAR_RISC_STATUS_BIT0
value|(1<< 20)
define|#
directive|define
name|BKTR_CLEAR_RISC_STATUS_BIT1
value|(1<< 21)
define|#
directive|define
name|BKTR_CLEAR_RISC_STATUS_BIT2
value|(1<< 22)
define|#
directive|define
name|BKTR_CLEAR_RISC_STATUS_BIT3
value|(1<< 23)
define|#
directive|define
name|BKTR_TEST_RISC_STATUS_BIT0
value|(1<< 28)
define|#
directive|define
name|BKTR_TEST_RISC_STATUS_BIT1
value|(1<< 29)
define|#
directive|define
name|BKTR_TEST_RISC_STATUS_BIT2
value|(1<< 30)
define|#
directive|define
name|BKTR_TEST_RISC_STATUS_BIT3
value|(1<< 31)
name|bool_t
name|notclipped
parameter_list|(
name|bktr_reg_t
modifier|*
name|bktr
parameter_list|,
name|int
name|x
parameter_list|,
name|int
name|width
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|bktr_clip_t
modifier|*
name|clip_node
decl_stmt|;
name|bktr
operator|->
name|clip_start
operator|=
operator|-
literal|1
expr_stmt|;
name|bktr
operator|->
name|last_y
operator|=
literal|0
expr_stmt|;
name|bktr
operator|->
name|y
operator|=
literal|0
expr_stmt|;
name|bktr
operator|->
name|y2
operator|=
name|width
expr_stmt|;
name|bktr
operator|->
name|line_length
operator|=
name|width
expr_stmt|;
name|bktr
operator|->
name|yclip
operator|=
operator|-
literal|1
expr_stmt|;
name|bktr
operator|->
name|yclip2
operator|=
operator|-
literal|1
expr_stmt|;
name|bktr
operator|->
name|current_col
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|bktr
operator|->
name|max_clip_node
operator|==
literal|0
condition|)
return|return
name|TRUE
return|;
name|clip_node
operator|=
operator|(
name|bktr_clip_t
operator|*
operator|)
operator|&
name|bktr
operator|->
name|clip_list
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|bktr
operator|->
name|max_clip_node
condition|;
name|i
operator|++
control|)
block|{
name|clip_node
operator|=
operator|(
name|bktr_clip_t
operator|*
operator|)
operator|&
name|bktr
operator|->
name|clip_list
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|x
operator|>=
name|clip_node
operator|->
name|x_min
operator|&&
name|x
operator|<=
name|clip_node
operator|->
name|x_max
condition|)
block|{
name|bktr
operator|->
name|clip_start
operator|=
name|i
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
return|return
name|TRUE
return|;
block|}
name|bool_t
name|getline
parameter_list|(
name|bktr_reg_t
modifier|*
name|bktr
parameter_list|,
name|int
name|x
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|bktr_clip_t
modifier|*
name|clip_node
decl_stmt|;
if|if
condition|(
name|bktr
operator|->
name|line_length
operator|==
literal|0
operator|||
name|bktr
operator|->
name|current_col
operator|>=
name|bktr
operator|->
name|line_length
condition|)
return|return
name|FALSE
return|;
name|bktr
operator|->
name|y
operator|=
name|min
argument_list|(
name|bktr
operator|->
name|last_y
argument_list|,
name|bktr
operator|->
name|line_length
argument_list|)
expr_stmt|;
name|bktr
operator|->
name|y2
operator|=
name|bktr
operator|->
name|line_length
expr_stmt|;
name|bktr
operator|->
name|yclip
operator|=
name|bktr
operator|->
name|yclip2
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
name|bktr
operator|->
name|clip_start
init|;
name|i
operator|<
name|bktr
operator|->
name|max_clip_node
condition|;
name|i
operator|++
control|)
block|{
name|clip_node
operator|=
operator|(
name|bktr_clip_t
operator|*
operator|)
operator|&
name|bktr
operator|->
name|clip_list
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|x
operator|>=
name|clip_node
operator|->
name|x_min
operator|&&
name|x
operator|<=
name|clip_node
operator|->
name|x_max
condition|)
block|{
if|if
condition|(
name|bktr
operator|->
name|last_y
operator|<=
name|clip_node
operator|->
name|y_min
condition|)
block|{
name|bktr
operator|->
name|y
operator|=
name|min
argument_list|(
name|bktr
operator|->
name|last_y
argument_list|,
name|bktr
operator|->
name|line_length
argument_list|)
expr_stmt|;
name|bktr
operator|->
name|y2
operator|=
name|min
argument_list|(
name|clip_node
operator|->
name|y_min
argument_list|,
name|bktr
operator|->
name|line_length
argument_list|)
expr_stmt|;
name|bktr
operator|->
name|yclip
operator|=
name|min
argument_list|(
name|clip_node
operator|->
name|y_min
argument_list|,
name|bktr
operator|->
name|line_length
argument_list|)
expr_stmt|;
name|bktr
operator|->
name|yclip2
operator|=
name|min
argument_list|(
name|clip_node
operator|->
name|y_max
argument_list|,
name|bktr
operator|->
name|line_length
argument_list|)
expr_stmt|;
name|bktr
operator|->
name|last_y
operator|=
name|bktr
operator|->
name|yclip2
expr_stmt|;
name|bktr
operator|->
name|clip_start
operator|=
name|i
expr_stmt|;
for|for
control|(
name|j
operator|=
name|i
operator|+
literal|1
init|;
name|j
operator|<
name|bktr
operator|->
name|max_clip_node
condition|;
name|j
operator|++
control|)
block|{
name|clip_node
operator|=
operator|(
name|bktr_clip_t
operator|*
operator|)
operator|&
name|bktr
operator|->
name|clip_list
index|[
name|j
index|]
expr_stmt|;
if|if
condition|(
name|x
operator|>=
name|clip_node
operator|->
name|x_min
operator|&&
name|x
operator|<=
name|clip_node
operator|->
name|x_max
condition|)
block|{
if|if
condition|(
name|bktr
operator|->
name|last_y
operator|>=
name|clip_node
operator|->
name|y_min
condition|)
block|{
name|bktr
operator|->
name|yclip2
operator|=
name|min
argument_list|(
name|clip_node
operator|->
name|y_max
argument_list|,
name|bktr
operator|->
name|line_length
argument_list|)
expr_stmt|;
name|bktr
operator|->
name|last_y
operator|=
name|bktr
operator|->
name|yclip2
expr_stmt|;
name|bktr
operator|->
name|clip_start
operator|=
name|j
expr_stmt|;
block|}
block|}
else|else
break|break  ;
block|}
return|return
name|TRUE
return|;
block|}
block|}
block|}
if|if
condition|(
name|bktr
operator|->
name|current_col
operator|<=
name|bktr
operator|->
name|line_length
condition|)
block|{
name|bktr
operator|->
name|current_col
operator|=
name|bktr
operator|->
name|line_length
expr_stmt|;
return|return
name|TRUE
return|;
block|}
return|return
name|FALSE
return|;
block|}
specifier|static
name|bool_t
name|split
parameter_list|(
name|bktr_reg_t
modifier|*
name|bktr
parameter_list|,
specifier|volatile
name|u_long
modifier|*
modifier|*
name|dma_prog
parameter_list|,
name|int
name|width
parameter_list|,
name|u_long
name|operation
parameter_list|,
name|int
name|pixel_width
parameter_list|,
specifier|volatile
name|u_char
modifier|*
modifier|*
name|target_buffer
parameter_list|,
name|int
name|cols
parameter_list|)
block|{
name|u_long
name|flag
decl_stmt|,
name|flag2
decl_stmt|;
name|struct
name|meteor_pixfmt
modifier|*
name|pf
init|=
operator|&
name|pixfmt_table
index|[
name|bktr
operator|->
name|pixfmt
index|]
operator|.
name|public
decl_stmt|;
name|u_int
name|skip
decl_stmt|,
name|start_skip
decl_stmt|;
comment|/*  For RGB24, we need to align the component in FIFO Byte Lane 0         */
comment|/*    to the 1st byte in the mem dword containing our start addr.         */
comment|/*    BTW, we know this pixfmt's 1st byte is Blue; thus the start addr    */
comment|/*     must be Blue.                                                      */
name|start_skip
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|pf
operator|->
name|type
operator|==
name|METEOR_PIXTYPE_RGB
operator|)
operator|&&
operator|(
name|pf
operator|->
name|Bpp
operator|==
literal|3
operator|)
condition|)
switch|switch
condition|(
operator|(
call|(
name|uintptr_t
call|)
argument_list|(
specifier|volatile
name|void
operator|*
argument_list|)
operator|*
name|target_buffer
operator|)
operator|%
literal|4
condition|)
block|{
case|case
literal|2
case|:
name|start_skip
operator|=
literal|4
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|start_skip
operator|=
literal|8
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|width
operator|*
name|pixel_width
operator|)
operator|<
name|DMA_BT848_SPLIT
condition|)
block|{
if|if
condition|(
name|width
operator|==
name|cols
condition|)
block|{
name|flag
operator|=
name|OP_SOL
operator||
name|OP_EOL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bktr
operator|->
name|current_col
operator|==
literal|0
condition|)
block|{
name|flag
operator|=
name|OP_SOL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bktr
operator|->
name|current_col
operator|==
name|cols
condition|)
block|{
name|flag
operator|=
name|OP_EOL
expr_stmt|;
block|}
else|else
name|flag
operator|=
literal|0
expr_stmt|;
name|skip
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|flag
operator|&
name|OP_SOL
operator|)
operator|&&
operator|(
name|start_skip
operator|>
literal|0
operator|)
condition|)
block|{
operator|*
operator|(
operator|*
name|dma_prog
operator|)
operator|++
operator|=
name|OP_SKIP
operator||
name|OP_SOL
operator||
name|start_skip
expr_stmt|;
name|flag
operator|&=
operator|~
name|OP_SOL
expr_stmt|;
name|skip
operator|=
name|start_skip
expr_stmt|;
block|}
operator|*
operator|(
operator|*
name|dma_prog
operator|)
operator|++
operator|=
name|operation
operator||
name|flag
operator||
operator|(
name|width
operator|*
name|pixel_width
operator|-
name|skip
operator|)
expr_stmt|;
if|if
condition|(
name|operation
operator|!=
name|OP_SKIP
condition|)
operator|*
operator|(
operator|*
name|dma_prog
operator|)
operator|++
operator|=
call|(
name|uintptr_t
call|)
argument_list|(
specifier|volatile
name|void
operator|*
argument_list|)
operator|*
name|target_buffer
expr_stmt|;
operator|*
name|target_buffer
operator|+=
name|width
operator|*
name|pixel_width
expr_stmt|;
name|bktr
operator|->
name|current_col
operator|+=
name|width
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|bktr
operator|->
name|current_col
operator|==
literal|0
operator|&&
name|width
operator|==
name|cols
condition|)
block|{
name|flag
operator|=
name|OP_SOL
expr_stmt|;
name|flag2
operator|=
name|OP_EOL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bktr
operator|->
name|current_col
operator|==
literal|0
condition|)
block|{
name|flag
operator|=
name|OP_SOL
expr_stmt|;
name|flag2
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bktr
operator|->
name|current_col
operator|>=
name|cols
condition|)
block|{
name|flag
operator|=
literal|0
expr_stmt|;
name|flag2
operator|=
name|OP_EOL
expr_stmt|;
block|}
else|else
block|{
name|flag
operator|=
literal|0
expr_stmt|;
name|flag2
operator|=
literal|0
expr_stmt|;
block|}
name|skip
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|flag
operator|&
name|OP_SOL
operator|)
operator|&&
operator|(
name|start_skip
operator|>
literal|0
operator|)
condition|)
block|{
operator|*
operator|(
operator|*
name|dma_prog
operator|)
operator|++
operator|=
name|OP_SKIP
operator||
name|OP_SOL
operator||
name|start_skip
expr_stmt|;
name|flag
operator|&=
operator|~
name|OP_SOL
expr_stmt|;
name|skip
operator|=
name|start_skip
expr_stmt|;
block|}
operator|*
operator|(
operator|*
name|dma_prog
operator|)
operator|++
operator|=
name|operation
operator||
name|flag
operator||
operator|(
name|width
operator|*
name|pixel_width
operator|/
literal|2
operator|-
name|skip
operator|)
expr_stmt|;
if|if
condition|(
name|operation
operator|!=
name|OP_SKIP
condition|)
operator|*
operator|(
operator|*
name|dma_prog
operator|)
operator|++
operator|=
call|(
name|uintptr_t
call|)
argument_list|(
specifier|volatile
name|void
operator|*
argument_list|)
operator|*
name|target_buffer
expr_stmt|;
operator|*
name|target_buffer
operator|+=
operator|(
name|width
operator|*
name|pixel_width
operator|/
literal|2
operator|)
expr_stmt|;
if|if
condition|(
name|operation
operator|==
name|OP_WRITE
condition|)
name|operation
operator|=
name|OP_WRITEC
expr_stmt|;
operator|*
operator|(
operator|*
name|dma_prog
operator|)
operator|++
operator|=
name|operation
operator||
name|flag2
operator||
operator|(
name|width
operator|*
name|pixel_width
operator|/
literal|2
operator|)
expr_stmt|;
operator|*
name|target_buffer
operator|+=
operator|(
name|width
operator|*
name|pixel_width
operator|/
literal|2
operator|)
expr_stmt|;
name|bktr
operator|->
name|current_col
operator|+=
name|width
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
comment|/*  * Generate the RISC instructions to capture both VBI and video images  */
specifier|static
name|void
name|rgb_vbi_prog
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|,
name|char
name|i_flag
parameter_list|,
name|int
name|cols
parameter_list|,
name|int
name|rows
parameter_list|,
name|int
name|interlace
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|bt848_ptr_t
name|bt848
decl_stmt|;
specifier|volatile
name|u_long
name|target_buffer
decl_stmt|,
name|buffer
decl_stmt|,
name|target
decl_stmt|,
name|width
decl_stmt|;
specifier|volatile
name|u_long
name|pitch
decl_stmt|;
specifier|volatile
name|u_long
modifier|*
name|dma_prog
decl_stmt|;
name|struct
name|meteor_pixfmt_internal
modifier|*
name|pf_int
init|=
operator|&
name|pixfmt_table
index|[
name|bktr
operator|->
name|pixfmt
index|]
decl_stmt|;
name|u_int
name|Bpp
init|=
name|pf_int
operator|->
name|public
operator|.
name|Bpp
decl_stmt|;
name|unsigned
name|int
name|vbisamples
decl_stmt|;
comment|/* VBI samples per line */
name|unsigned
name|int
name|vbilines
decl_stmt|;
comment|/* VBI lines per field */
name|unsigned
name|int
name|num_dwords
decl_stmt|;
comment|/* DWORDS per line */
name|vbisamples
operator|=
name|format_params
index|[
name|bktr
operator|->
name|format_params
index|]
operator|.
name|vbi_num_samples
expr_stmt|;
name|vbilines
operator|=
name|format_params
index|[
name|bktr
operator|->
name|format_params
index|]
operator|.
name|vbi_num_lines
expr_stmt|;
name|num_dwords
operator|=
name|vbisamples
operator|/
literal|4
expr_stmt|;
name|bt848
operator|=
name|bktr
operator|->
name|base
expr_stmt|;
name|bt848
operator|->
name|color_fmt
operator|=
name|pf_int
operator|->
name|color_fmt
expr_stmt|;
name|bt848
operator|->
name|adc
operator|=
name|SYNC_LEVEL
expr_stmt|;
name|bt848
operator|->
name|vbi_pack_size
operator|=
operator|(
operator|(
name|num_dwords
operator|)
operator|)
operator|&
literal|0xff
expr_stmt|;
name|bt848
operator|->
name|vbi_pack_del
operator|=
operator|(
operator|(
name|num_dwords
operator|)
operator|>>
literal|8
operator|)
operator|&
literal|0x01
expr_stmt|;
comment|/* no hdelay    */
comment|/* no ext frame */
name|bt848
operator|->
name|oform
operator|=
literal|0x00
expr_stmt|;
name|bt848
operator|->
name|e_vscale_hi
operator||=
literal|0x40
expr_stmt|;
comment|/* set chroma comb */
name|bt848
operator|->
name|o_vscale_hi
operator||=
literal|0x40
expr_stmt|;
name|bt848
operator|->
name|e_vscale_hi
operator|&=
operator|~
literal|0x80
expr_stmt|;
comment|/* clear Ycomb */
name|bt848
operator|->
name|o_vscale_hi
operator|&=
operator|~
literal|0x80
expr_stmt|;
comment|/* disable gamma correction removal */
name|bt848
operator|->
name|color_ctl_gamma
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|cols
operator|>
literal|385
condition|)
block|{
name|bt848
operator|->
name|e_vtc
operator|=
literal|0
expr_stmt|;
name|bt848
operator|->
name|o_vtc
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|bt848
operator|->
name|e_vtc
operator|=
literal|1
expr_stmt|;
name|bt848
operator|->
name|o_vtc
operator|=
literal|1
expr_stmt|;
block|}
name|bktr
operator|->
name|capcontrol
operator|=
literal|3
operator|<<
literal|2
operator||
literal|3
expr_stmt|;
name|dma_prog
operator|=
operator|(
name|u_long
operator|*
operator|)
name|bktr
operator|->
name|dma_prog
expr_stmt|;
comment|/* Construct Write */
if|if
condition|(
name|bktr
operator|->
name|video
operator|.
name|addr
condition|)
block|{
name|target_buffer
operator|=
operator|(
name|u_long
operator|)
name|bktr
operator|->
name|video
operator|.
name|addr
expr_stmt|;
name|pitch
operator|=
name|bktr
operator|->
name|video
operator|.
name|width
expr_stmt|;
block|}
else|else
block|{
name|target_buffer
operator|=
operator|(
name|u_long
operator|)
name|vtophys
argument_list|(
name|bktr
operator|->
name|bigbuf
argument_list|)
expr_stmt|;
name|pitch
operator|=
name|cols
operator|*
name|Bpp
expr_stmt|;
block|}
name|buffer
operator|=
name|target_buffer
expr_stmt|;
comment|/* store the VBI data */
comment|/* look for sync with packed data */
operator|*
name|dma_prog
operator|++
operator|=
name|OP_SYNC
operator||
name|BKTR_RESYNC
operator||
name|BKTR_FM1
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|vbilines
condition|;
name|i
operator|++
control|)
block|{
operator|*
name|dma_prog
operator|++
operator|=
name|OP_WRITE
operator||
name|OP_SOL
operator||
name|OP_EOL
operator||
name|vbisamples
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
operator|(
name|u_long
operator|)
name|vtophys
argument_list|(
name|bktr
operator|->
name|vbidata
operator|+
operator|(
name|i
operator|*
name|VBI_LINE_SIZE
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* store the video image */
comment|/* look for sync with packed data */
operator|*
name|dma_prog
operator|++
operator|=
name|OP_SYNC
operator||
name|BKTR_RESYNC
operator||
name|BKTR_FM1
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* NULL WORD */
name|width
operator|=
name|cols
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|rows
operator|/
name|interlace
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|target
operator|=
name|target_buffer
expr_stmt|;
if|if
condition|(
name|notclipped
argument_list|(
name|bktr
argument_list|,
name|i
argument_list|,
name|width
argument_list|)
condition|)
block|{
name|split
argument_list|(
name|bktr
argument_list|,
operator|(
specifier|volatile
name|u_long
operator|*
operator|*
operator|)
operator|&
name|dma_prog
argument_list|,
name|bktr
operator|->
name|y2
operator|-
name|bktr
operator|->
name|y
argument_list|,
name|OP_WRITE
argument_list|,
name|Bpp
argument_list|,
operator|(
specifier|volatile
name|u_char
operator|*
operator|*
operator|)
operator|&
name|target
argument_list|,
name|cols
argument_list|)
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
name|getline
argument_list|(
name|bktr
argument_list|,
name|i
argument_list|)
condition|)
block|{
if|if
condition|(
name|bktr
operator|->
name|y
operator|!=
name|bktr
operator|->
name|y2
condition|)
block|{
name|split
argument_list|(
name|bktr
argument_list|,
operator|(
specifier|volatile
name|u_long
operator|*
operator|*
operator|)
operator|&
name|dma_prog
argument_list|,
name|bktr
operator|->
name|y2
operator|-
name|bktr
operator|->
name|y
argument_list|,
name|OP_WRITE
argument_list|,
name|Bpp
argument_list|,
operator|(
specifier|volatile
name|u_char
operator|*
operator|*
operator|)
operator|&
name|target
argument_list|,
name|cols
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bktr
operator|->
name|yclip
operator|!=
name|bktr
operator|->
name|yclip2
condition|)
block|{
name|split
argument_list|(
name|bktr
argument_list|,
operator|(
specifier|volatile
name|u_long
operator|*
operator|*
operator|)
operator|&
name|dma_prog
argument_list|,
name|bktr
operator|->
name|yclip2
operator|-
name|bktr
operator|->
name|yclip
argument_list|,
name|OP_SKIP
argument_list|,
name|Bpp
argument_list|,
operator|(
specifier|volatile
name|u_char
operator|*
operator|*
operator|)
operator|&
name|target
argument_list|,
name|cols
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|target_buffer
operator|+=
name|interlace
operator|*
name|pitch
expr_stmt|;
block|}
switch|switch
condition|(
name|i_flag
condition|)
block|{
case|case
literal|1
case|:
comment|/* EVEN field grabs. Look for end of 'Even Field' Marker 		 * We cannot look for VRO, because we have not enabled ODD 		 * field capture 		 */
operator|*
name|dma_prog
operator|++
operator|=
name|OP_SYNC
operator||
name|BKTR_GEN_IRQ
operator||
name|BKTR_RESYNC
operator||
name|BKTR_VRE
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* NULL WORD */
operator|*
name|dma_prog
operator|++
operator|=
name|OP_JUMP
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
operator|(
name|u_long
operator|)
name|vtophys
argument_list|(
name|bktr
operator|->
name|dma_prog
argument_list|)
expr_stmt|;
return|return;
case|case
literal|2
case|:
comment|/* ODD field grabs. Look for end of 'Odd Field' Marker 		 * We cannot look for VRE, because we have not enabled EVEN 		 * field capture 		 */
operator|*
name|dma_prog
operator|++
operator|=
name|OP_SYNC
operator||
name|BKTR_GEN_IRQ
operator||
name|BKTR_RESYNC
operator||
name|BKTR_VRO
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* NULL WORD */
operator|*
name|dma_prog
operator|++
operator|=
name|OP_JUMP
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
operator|(
name|u_long
operator|)
name|vtophys
argument_list|(
name|bktr
operator|->
name|dma_prog
argument_list|)
expr_stmt|;
return|return;
case|case
literal|3
case|:
comment|/* INTERLACED grabs (ODD then EVEN). We have read the old field 		 * so look for the end of 'Odd Field' Marker. 		 * Then jump to the 'odd_dma_prog' which actually captures 		 * the EVEN field! 		 */
operator|*
name|dma_prog
operator|++
operator|=
name|OP_SYNC
operator||
name|BKTR_GEN_IRQ
operator||
name|BKTR_RESYNC
operator||
name|BKTR_VRO
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* NULL WORD */
operator|*
name|dma_prog
operator|++
operator|=
name|OP_JUMP
expr_stmt|;
operator|*
name|dma_prog
operator|=
operator|(
name|u_long
operator|)
name|vtophys
argument_list|(
name|bktr
operator|->
name|odd_dma_prog
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|interlace
operator|==
literal|2
condition|)
block|{
name|target_buffer
operator|=
name|buffer
operator|+
name|pitch
expr_stmt|;
name|dma_prog
operator|=
operator|(
name|u_long
operator|*
operator|)
name|bktr
operator|->
name|odd_dma_prog
expr_stmt|;
comment|/* store the VBI data */
comment|/* look for sync with packed data */
operator|*
name|dma_prog
operator|++
operator|=
name|OP_SYNC
operator||
name|BKTR_RESYNC
operator||
name|BKTR_FM1
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|vbilines
condition|;
name|i
operator|++
control|)
block|{
operator|*
name|dma_prog
operator|++
operator|=
name|OP_WRITE
operator||
name|OP_SOL
operator||
name|OP_EOL
operator||
name|vbisamples
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
operator|(
name|u_long
operator|)
name|vtophys
argument_list|(
name|bktr
operator|->
name|vbidata
operator|+
operator|(
operator|(
name|i
operator|+
name|MAX_VBI_LINES
operator|)
operator|*
name|VBI_LINE_SIZE
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* store the video image */
comment|/* look for sync with packed data */
operator|*
name|dma_prog
operator|++
operator|=
name|OP_SYNC
operator||
name|BKTR_RESYNC
operator||
name|BKTR_FM1
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* NULL WORD */
name|width
operator|=
name|cols
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|rows
operator|/
name|interlace
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|target
operator|=
name|target_buffer
expr_stmt|;
if|if
condition|(
name|notclipped
argument_list|(
name|bktr
argument_list|,
name|i
argument_list|,
name|width
argument_list|)
condition|)
block|{
name|split
argument_list|(
name|bktr
argument_list|,
operator|(
specifier|volatile
name|u_long
operator|*
operator|*
operator|)
operator|&
name|dma_prog
argument_list|,
name|bktr
operator|->
name|y2
operator|-
name|bktr
operator|->
name|y
argument_list|,
name|OP_WRITE
argument_list|,
name|Bpp
argument_list|,
operator|(
specifier|volatile
name|u_char
operator|*
operator|*
operator|)
operator|&
name|target
argument_list|,
name|cols
argument_list|)
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
name|getline
argument_list|(
name|bktr
argument_list|,
name|i
argument_list|)
condition|)
block|{
if|if
condition|(
name|bktr
operator|->
name|y
operator|!=
name|bktr
operator|->
name|y2
condition|)
block|{
name|split
argument_list|(
name|bktr
argument_list|,
operator|(
specifier|volatile
name|u_long
operator|*
operator|*
operator|)
operator|&
name|dma_prog
argument_list|,
name|bktr
operator|->
name|y2
operator|-
name|bktr
operator|->
name|y
argument_list|,
name|OP_WRITE
argument_list|,
name|Bpp
argument_list|,
operator|(
specifier|volatile
name|u_char
operator|*
operator|*
operator|)
operator|&
name|target
argument_list|,
name|cols
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bktr
operator|->
name|yclip
operator|!=
name|bktr
operator|->
name|yclip2
condition|)
block|{
name|split
argument_list|(
name|bktr
argument_list|,
operator|(
specifier|volatile
name|u_long
operator|*
operator|*
operator|)
operator|&
name|dma_prog
argument_list|,
name|bktr
operator|->
name|yclip2
operator|-
name|bktr
operator|->
name|yclip
argument_list|,
name|OP_SKIP
argument_list|,
name|Bpp
argument_list|,
operator|(
specifier|volatile
name|u_char
operator|*
operator|*
operator|)
operator|&
name|target
argument_list|,
name|cols
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|target_buffer
operator|+=
name|interlace
operator|*
name|pitch
expr_stmt|;
block|}
block|}
comment|/* Look for end of 'Even Field' */
operator|*
name|dma_prog
operator|++
operator|=
name|OP_SYNC
operator||
name|BKTR_GEN_IRQ
operator||
name|BKTR_RESYNC
operator||
name|BKTR_VRE
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* NULL WORD */
operator|*
name|dma_prog
operator|++
operator|=
name|OP_JUMP
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
operator|(
name|u_long
operator|)
name|vtophys
argument_list|(
name|bktr
operator|->
name|dma_prog
argument_list|)
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* NULL WORD */
block|}
specifier|static
name|void
name|rgb_prog
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|,
name|char
name|i_flag
parameter_list|,
name|int
name|cols
parameter_list|,
name|int
name|rows
parameter_list|,
name|int
name|interlace
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|bt848_ptr_t
name|bt848
decl_stmt|;
specifier|volatile
name|u_long
name|target_buffer
decl_stmt|,
name|buffer
decl_stmt|,
name|target
decl_stmt|,
name|width
decl_stmt|;
specifier|volatile
name|u_long
name|pitch
decl_stmt|;
specifier|volatile
name|u_long
modifier|*
name|dma_prog
decl_stmt|;
name|struct
name|meteor_pixfmt_internal
modifier|*
name|pf_int
init|=
operator|&
name|pixfmt_table
index|[
name|bktr
operator|->
name|pixfmt
index|]
decl_stmt|;
name|u_int
name|Bpp
init|=
name|pf_int
operator|->
name|public
operator|.
name|Bpp
decl_stmt|;
name|bt848
operator|=
name|bktr
operator|->
name|base
expr_stmt|;
name|bt848
operator|->
name|color_fmt
operator|=
name|pf_int
operator|->
name|color_fmt
expr_stmt|;
name|bt848
operator|->
name|vbi_pack_size
operator|=
literal|0
expr_stmt|;
name|bt848
operator|->
name|vbi_pack_del
operator|=
literal|0
expr_stmt|;
name|bt848
operator|->
name|adc
operator|=
name|SYNC_LEVEL
expr_stmt|;
name|bt848
operator|->
name|oform
operator|=
literal|0x00
expr_stmt|;
name|bt848
operator|->
name|e_vscale_hi
operator||=
literal|0x40
expr_stmt|;
comment|/* set chroma comb */
name|bt848
operator|->
name|o_vscale_hi
operator||=
literal|0x40
expr_stmt|;
name|bt848
operator|->
name|e_vscale_hi
operator|&=
operator|~
literal|0x80
expr_stmt|;
comment|/* clear Ycomb */
name|bt848
operator|->
name|o_vscale_hi
operator|&=
operator|~
literal|0x80
expr_stmt|;
comment|/* disable gamma correction removal */
name|bt848
operator|->
name|color_ctl_gamma
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|cols
operator|>
literal|385
condition|)
block|{
name|bt848
operator|->
name|e_vtc
operator|=
literal|0
expr_stmt|;
name|bt848
operator|->
name|o_vtc
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|bt848
operator|->
name|e_vtc
operator|=
literal|1
expr_stmt|;
name|bt848
operator|->
name|o_vtc
operator|=
literal|1
expr_stmt|;
block|}
name|bktr
operator|->
name|capcontrol
operator|=
literal|3
operator|<<
literal|2
operator||
literal|3
expr_stmt|;
name|dma_prog
operator|=
operator|(
name|u_long
operator|*
operator|)
name|bktr
operator|->
name|dma_prog
expr_stmt|;
comment|/* Construct Write */
if|if
condition|(
name|bktr
operator|->
name|video
operator|.
name|addr
condition|)
block|{
name|target_buffer
operator|=
operator|(
name|u_long
operator|)
name|bktr
operator|->
name|video
operator|.
name|addr
expr_stmt|;
name|pitch
operator|=
name|bktr
operator|->
name|video
operator|.
name|width
expr_stmt|;
block|}
else|else
block|{
name|target_buffer
operator|=
operator|(
name|u_long
operator|)
name|vtophys
argument_list|(
name|bktr
operator|->
name|bigbuf
argument_list|)
expr_stmt|;
name|pitch
operator|=
name|cols
operator|*
name|Bpp
expr_stmt|;
block|}
name|buffer
operator|=
name|target_buffer
expr_stmt|;
comment|/* contruct sync : for video packet format */
operator|*
name|dma_prog
operator|++
operator|=
name|OP_SYNC
operator||
name|BKTR_RESYNC
operator||
name|BKTR_FM1
expr_stmt|;
comment|/* sync, mode indicator packed data */
operator|*
name|dma_prog
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* NULL WORD */
name|width
operator|=
name|cols
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|rows
operator|/
name|interlace
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|target
operator|=
name|target_buffer
expr_stmt|;
if|if
condition|(
name|notclipped
argument_list|(
name|bktr
argument_list|,
name|i
argument_list|,
name|width
argument_list|)
condition|)
block|{
name|split
argument_list|(
name|bktr
argument_list|,
operator|(
specifier|volatile
name|u_long
operator|*
operator|*
operator|)
operator|&
name|dma_prog
argument_list|,
name|bktr
operator|->
name|y2
operator|-
name|bktr
operator|->
name|y
argument_list|,
name|OP_WRITE
argument_list|,
name|Bpp
argument_list|,
operator|(
specifier|volatile
name|u_char
operator|*
operator|*
operator|)
operator|&
name|target
argument_list|,
name|cols
argument_list|)
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
name|getline
argument_list|(
name|bktr
argument_list|,
name|i
argument_list|)
condition|)
block|{
if|if
condition|(
name|bktr
operator|->
name|y
operator|!=
name|bktr
operator|->
name|y2
condition|)
block|{
name|split
argument_list|(
name|bktr
argument_list|,
operator|(
specifier|volatile
name|u_long
operator|*
operator|*
operator|)
operator|&
name|dma_prog
argument_list|,
name|bktr
operator|->
name|y2
operator|-
name|bktr
operator|->
name|y
argument_list|,
name|OP_WRITE
argument_list|,
name|Bpp
argument_list|,
operator|(
specifier|volatile
name|u_char
operator|*
operator|*
operator|)
operator|&
name|target
argument_list|,
name|cols
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bktr
operator|->
name|yclip
operator|!=
name|bktr
operator|->
name|yclip2
condition|)
block|{
name|split
argument_list|(
name|bktr
argument_list|,
operator|(
specifier|volatile
name|u_long
operator|*
operator|*
operator|)
operator|&
name|dma_prog
argument_list|,
name|bktr
operator|->
name|yclip2
operator|-
name|bktr
operator|->
name|yclip
argument_list|,
name|OP_SKIP
argument_list|,
name|Bpp
argument_list|,
operator|(
specifier|volatile
name|u_char
operator|*
operator|*
operator|)
operator|&
name|target
argument_list|,
name|cols
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|target_buffer
operator|+=
name|interlace
operator|*
name|pitch
expr_stmt|;
block|}
switch|switch
condition|(
name|i_flag
condition|)
block|{
case|case
literal|1
case|:
comment|/* sync vre */
operator|*
name|dma_prog
operator|++
operator|=
name|OP_SYNC
operator||
name|BKTR_GEN_IRQ
operator||
name|BKTR_VRO
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* NULL WORD */
operator|*
name|dma_prog
operator|++
operator|=
name|OP_JUMP
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
operator|(
name|u_long
operator|)
name|vtophys
argument_list|(
name|bktr
operator|->
name|dma_prog
argument_list|)
expr_stmt|;
return|return;
case|case
literal|2
case|:
comment|/* sync vro */
operator|*
name|dma_prog
operator|++
operator|=
name|OP_SYNC
operator||
name|BKTR_GEN_IRQ
operator||
name|BKTR_VRE
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* NULL WORD */
operator|*
name|dma_prog
operator|++
operator|=
name|OP_JUMP
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
operator|(
name|u_long
operator|)
name|vtophys
argument_list|(
name|bktr
operator|->
name|dma_prog
argument_list|)
expr_stmt|;
return|return;
case|case
literal|3
case|:
comment|/* sync vro */
operator|*
name|dma_prog
operator|++
operator|=
name|OP_SYNC
operator||
name|BKTR_GEN_IRQ
operator||
name|BKTR_RESYNC
operator||
name|BKTR_VRO
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* NULL WORD */
operator|*
name|dma_prog
operator|++
operator|=
name|OP_JUMP
expr_stmt|;
empty_stmt|;
operator|*
name|dma_prog
operator|=
operator|(
name|u_long
operator|)
name|vtophys
argument_list|(
name|bktr
operator|->
name|odd_dma_prog
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|interlace
operator|==
literal|2
condition|)
block|{
name|target_buffer
operator|=
name|buffer
operator|+
name|pitch
expr_stmt|;
name|dma_prog
operator|=
operator|(
name|u_long
operator|*
operator|)
name|bktr
operator|->
name|odd_dma_prog
expr_stmt|;
comment|/* sync vre IRQ bit */
operator|*
name|dma_prog
operator|++
operator|=
name|OP_SYNC
operator||
name|BKTR_RESYNC
operator||
name|BKTR_FM1
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* NULL WORD */
name|width
operator|=
name|cols
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|rows
operator|/
name|interlace
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|target
operator|=
name|target_buffer
expr_stmt|;
if|if
condition|(
name|notclipped
argument_list|(
name|bktr
argument_list|,
name|i
argument_list|,
name|width
argument_list|)
condition|)
block|{
name|split
argument_list|(
name|bktr
argument_list|,
operator|(
specifier|volatile
name|u_long
operator|*
operator|*
operator|)
operator|&
name|dma_prog
argument_list|,
name|bktr
operator|->
name|y2
operator|-
name|bktr
operator|->
name|y
argument_list|,
name|OP_WRITE
argument_list|,
name|Bpp
argument_list|,
operator|(
specifier|volatile
name|u_char
operator|*
operator|*
operator|)
operator|&
name|target
argument_list|,
name|cols
argument_list|)
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
name|getline
argument_list|(
name|bktr
argument_list|,
name|i
argument_list|)
condition|)
block|{
if|if
condition|(
name|bktr
operator|->
name|y
operator|!=
name|bktr
operator|->
name|y2
condition|)
block|{
name|split
argument_list|(
name|bktr
argument_list|,
operator|(
specifier|volatile
name|u_long
operator|*
operator|*
operator|)
operator|&
name|dma_prog
argument_list|,
name|bktr
operator|->
name|y2
operator|-
name|bktr
operator|->
name|y
argument_list|,
name|OP_WRITE
argument_list|,
name|Bpp
argument_list|,
operator|(
specifier|volatile
name|u_char
operator|*
operator|*
operator|)
operator|&
name|target
argument_list|,
name|cols
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bktr
operator|->
name|yclip
operator|!=
name|bktr
operator|->
name|yclip2
condition|)
block|{
name|split
argument_list|(
name|bktr
argument_list|,
operator|(
specifier|volatile
name|u_long
operator|*
operator|*
operator|)
operator|&
name|dma_prog
argument_list|,
name|bktr
operator|->
name|yclip2
operator|-
name|bktr
operator|->
name|yclip
argument_list|,
name|OP_SKIP
argument_list|,
name|Bpp
argument_list|,
operator|(
specifier|volatile
name|u_char
operator|*
operator|*
operator|)
operator|&
name|target
argument_list|,
name|cols
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|target_buffer
operator|+=
name|interlace
operator|*
name|pitch
expr_stmt|;
block|}
block|}
comment|/* sync vre IRQ bit */
operator|*
name|dma_prog
operator|++
operator|=
name|OP_SYNC
operator||
name|BKTR_GEN_IRQ
operator||
name|BKTR_RESYNC
operator||
name|BKTR_VRE
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* NULL WORD */
operator|*
name|dma_prog
operator|++
operator|=
name|OP_JUMP
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
operator|(
name|u_long
operator|)
name|vtophys
argument_list|(
name|bktr
operator|->
name|dma_prog
argument_list|)
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* NULL WORD */
block|}
comment|/*  *   */
specifier|static
name|void
name|yuvpack_prog
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|,
name|char
name|i_flag
parameter_list|,
name|int
name|cols
parameter_list|,
name|int
name|rows
parameter_list|,
name|int
name|interlace
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
specifier|volatile
name|unsigned
name|int
name|inst
decl_stmt|;
specifier|volatile
name|unsigned
name|int
name|inst3
decl_stmt|;
specifier|volatile
name|u_long
name|target_buffer
decl_stmt|,
name|buffer
decl_stmt|;
name|bt848_ptr_t
name|bt848
decl_stmt|;
specifier|volatile
name|u_long
modifier|*
name|dma_prog
decl_stmt|;
name|struct
name|meteor_pixfmt_internal
modifier|*
name|pf_int
init|=
operator|&
name|pixfmt_table
index|[
name|bktr
operator|->
name|pixfmt
index|]
decl_stmt|;
name|int
name|b
decl_stmt|;
name|bt848
operator|=
name|bktr
operator|->
name|base
expr_stmt|;
name|bt848
operator|->
name|color_fmt
operator|=
name|pf_int
operator|->
name|color_fmt
expr_stmt|;
name|bt848
operator|->
name|e_scloop
operator||=
name|BT848_E_SCLOOP_CAGC
expr_stmt|;
comment|/* enable chroma comb */
name|bt848
operator|->
name|o_scloop
operator||=
name|BT848_O_SCLOOP_CAGC
expr_stmt|;
name|bt848
operator|->
name|color_ctl_rgb_ded
operator|=
literal|1
expr_stmt|;
name|bt848
operator|->
name|color_ctl_gamma
operator|=
literal|1
expr_stmt|;
name|bt848
operator|->
name|adc
operator|=
name|SYNC_LEVEL
expr_stmt|;
name|bktr
operator|->
name|capcontrol
operator|=
literal|1
operator|<<
literal|6
operator||
literal|1
operator|<<
literal|4
operator||
literal|1
operator|<<
literal|2
operator||
literal|3
expr_stmt|;
name|bktr
operator|->
name|capcontrol
operator|=
literal|3
operator|<<
literal|2
operator||
literal|3
expr_stmt|;
name|dma_prog
operator|=
operator|(
name|u_long
operator|*
operator|)
name|bktr
operator|->
name|dma_prog
expr_stmt|;
comment|/* Construct Write */
comment|/* write , sol, eol */
name|inst
operator|=
name|OP_WRITE
operator||
name|OP_SOL
operator||
operator|(
name|cols
operator|)
expr_stmt|;
comment|/* write , sol, eol */
name|inst3
operator|=
name|OP_WRITE
operator||
name|OP_EOL
operator||
operator|(
name|cols
operator|)
expr_stmt|;
if|if
condition|(
name|bktr
operator|->
name|video
operator|.
name|addr
condition|)
name|target_buffer
operator|=
operator|(
name|u_long
operator|)
name|bktr
operator|->
name|video
operator|.
name|addr
expr_stmt|;
else|else
name|target_buffer
operator|=
operator|(
name|u_long
operator|)
name|vtophys
argument_list|(
name|bktr
operator|->
name|bigbuf
argument_list|)
expr_stmt|;
name|buffer
operator|=
name|target_buffer
expr_stmt|;
comment|/* contruct sync : for video packet format */
comment|/* sync, mode indicator packed data */
operator|*
name|dma_prog
operator|++
operator|=
name|OP_SYNC
operator||
literal|1
operator|<<
literal|15
operator||
name|BKTR_FM1
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* NULL WORD */
name|b
operator|=
name|cols
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|rows
operator|/
name|interlace
operator|)
condition|;
name|i
operator|++
control|)
block|{
operator|*
name|dma_prog
operator|++
operator|=
name|inst
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
name|target_buffer
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
name|inst3
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
name|target_buffer
operator|+
name|b
expr_stmt|;
name|target_buffer
operator|+=
name|interlace
operator|*
operator|(
name|cols
operator|*
literal|2
operator|)
expr_stmt|;
block|}
switch|switch
condition|(
name|i_flag
condition|)
block|{
case|case
literal|1
case|:
comment|/* sync vre */
operator|*
name|dma_prog
operator|++
operator|=
name|OP_SYNC
operator||
literal|1
operator|<<
literal|24
operator||
name|BKTR_VRE
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* NULL WORD */
operator|*
name|dma_prog
operator|++
operator|=
name|OP_JUMP
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
operator|(
name|u_long
operator|)
name|vtophys
argument_list|(
name|bktr
operator|->
name|dma_prog
argument_list|)
expr_stmt|;
return|return;
case|case
literal|2
case|:
comment|/* sync vro */
operator|*
name|dma_prog
operator|++
operator|=
name|OP_SYNC
operator||
literal|1
operator|<<
literal|24
operator||
name|BKTR_VRO
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* NULL WORD */
operator|*
name|dma_prog
operator|++
operator|=
name|OP_JUMP
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
operator|(
name|u_long
operator|)
name|vtophys
argument_list|(
name|bktr
operator|->
name|dma_prog
argument_list|)
expr_stmt|;
return|return;
case|case
literal|3
case|:
comment|/* sync vro */
operator|*
name|dma_prog
operator|++
operator|=
name|OP_SYNC
operator||
literal|1
operator|<<
literal|24
operator||
literal|1
operator|<<
literal|15
operator||
name|BKTR_VRO
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* NULL WORD */
operator|*
name|dma_prog
operator|++
operator|=
name|OP_JUMP
expr_stmt|;
operator|*
name|dma_prog
operator|=
operator|(
name|u_long
operator|)
name|vtophys
argument_list|(
name|bktr
operator|->
name|odd_dma_prog
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|interlace
operator|==
literal|2
condition|)
block|{
name|target_buffer
operator|=
operator|(
name|u_long
operator|)
name|buffer
operator|+
name|cols
operator|*
literal|2
expr_stmt|;
name|dma_prog
operator|=
operator|(
name|u_long
operator|*
operator|)
name|bktr
operator|->
name|odd_dma_prog
expr_stmt|;
comment|/* sync vre */
operator|*
name|dma_prog
operator|++
operator|=
name|OP_SYNC
operator||
literal|1
operator|<<
literal|24
operator||
literal|1
operator|<<
literal|15
operator||
name|BKTR_FM1
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* NULL WORD */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|rows
operator|/
name|interlace
operator|)
condition|;
name|i
operator|++
control|)
block|{
operator|*
name|dma_prog
operator|++
operator|=
name|inst
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
name|target_buffer
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
name|inst3
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
name|target_buffer
operator|+
name|b
expr_stmt|;
name|target_buffer
operator|+=
name|interlace
operator|*
operator|(
name|cols
operator|*
literal|2
operator|)
expr_stmt|;
block|}
block|}
comment|/* sync vro IRQ bit */
operator|*
name|dma_prog
operator|++
operator|=
name|OP_SYNC
operator||
literal|1
operator|<<
literal|24
operator||
literal|1
operator|<<
literal|15
operator||
name|BKTR_VRE
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* NULL WORD */
operator|*
name|dma_prog
operator|++
operator|=
name|OP_JUMP
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
operator|(
name|u_long
operator|)
name|vtophys
argument_list|(
name|bktr
operator|->
name|dma_prog
argument_list|)
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
name|OP_JUMP
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
operator|(
name|u_long
operator|)
name|vtophys
argument_list|(
name|bktr
operator|->
name|dma_prog
argument_list|)
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* NULL WORD */
block|}
comment|/*  *   */
specifier|static
name|void
name|yuv422_prog
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|,
name|char
name|i_flag
parameter_list|,
name|int
name|cols
parameter_list|,
name|int
name|rows
parameter_list|,
name|int
name|interlace
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
specifier|volatile
name|unsigned
name|int
name|inst
decl_stmt|;
specifier|volatile
name|u_long
name|target_buffer
decl_stmt|,
name|t1
decl_stmt|,
name|buffer
decl_stmt|;
name|bt848_ptr_t
name|bt848
decl_stmt|;
specifier|volatile
name|u_long
modifier|*
name|dma_prog
decl_stmt|;
name|struct
name|meteor_pixfmt_internal
modifier|*
name|pf_int
init|=
operator|&
name|pixfmt_table
index|[
name|bktr
operator|->
name|pixfmt
index|]
decl_stmt|;
name|bt848
operator|=
name|bktr
operator|->
name|base
expr_stmt|;
name|bt848
operator|->
name|color_fmt
operator|=
name|pf_int
operator|->
name|color_fmt
expr_stmt|;
name|dma_prog
operator|=
operator|(
name|u_long
operator|*
operator|)
name|bktr
operator|->
name|dma_prog
expr_stmt|;
name|bktr
operator|->
name|capcontrol
operator|=
literal|1
operator|<<
literal|6
operator||
literal|1
operator|<<
literal|4
operator||
literal|3
expr_stmt|;
name|bt848
operator|->
name|adc
operator|=
name|SYNC_LEVEL
expr_stmt|;
name|bt848
operator|->
name|oform
operator|=
literal|0x00
expr_stmt|;
name|bt848
operator|->
name|e_control
operator||=
name|BT848_E_CONTROL_LDEC
expr_stmt|;
comment|/* disable luma decimation */
name|bt848
operator|->
name|o_control
operator||=
name|BT848_O_CONTROL_LDEC
expr_stmt|;
name|bt848
operator|->
name|e_scloop
operator||=
name|BT848_O_SCLOOP_CAGC
expr_stmt|;
comment|/* chroma agc enable */
name|bt848
operator|->
name|o_scloop
operator||=
name|BT848_O_SCLOOP_CAGC
expr_stmt|;
name|bt848
operator|->
name|e_vscale_hi
operator|&=
operator|~
literal|0x80
expr_stmt|;
comment|/* clear Ycomb */
name|bt848
operator|->
name|o_vscale_hi
operator|&=
operator|~
literal|0x80
expr_stmt|;
name|bt848
operator|->
name|e_vscale_hi
operator||=
literal|0x40
expr_stmt|;
comment|/* set chroma comb */
name|bt848
operator|->
name|o_vscale_hi
operator||=
literal|0x40
expr_stmt|;
comment|/* disable gamma correction removal */
name|bt848
operator|->
name|color_ctl_gamma
operator|=
literal|1
expr_stmt|;
comment|/* Construct Write */
name|inst
operator|=
name|OP_WRITE123
operator||
name|OP_SOL
operator||
name|OP_EOL
operator||
operator|(
name|cols
operator|)
expr_stmt|;
if|if
condition|(
name|bktr
operator|->
name|video
operator|.
name|addr
condition|)
name|target_buffer
operator|=
operator|(
name|u_long
operator|)
name|bktr
operator|->
name|video
operator|.
name|addr
expr_stmt|;
else|else
name|target_buffer
operator|=
operator|(
name|u_long
operator|)
name|vtophys
argument_list|(
name|bktr
operator|->
name|bigbuf
argument_list|)
expr_stmt|;
name|buffer
operator|=
name|target_buffer
expr_stmt|;
name|t1
operator|=
name|buffer
expr_stmt|;
comment|/* contruct sync : for video packet format */
operator|*
name|dma_prog
operator|++
operator|=
name|OP_SYNC
operator||
literal|1
operator|<<
literal|15
operator||
name|BKTR_FM3
expr_stmt|;
comment|/*sync, mode indicator packed data*/
operator|*
name|dma_prog
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* NULL WORD */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|rows
operator|/
name|interlace
operator|)
condition|;
name|i
operator|++
control|)
block|{
operator|*
name|dma_prog
operator|++
operator|=
name|inst
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
name|cols
operator|/
literal|2
operator||
name|cols
operator|/
literal|2
operator|<<
literal|16
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
name|target_buffer
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
name|t1
operator|+
operator|(
name|cols
operator|*
name|rows
operator|)
operator|+
name|i
operator|*
name|cols
operator|/
literal|2
operator|*
name|interlace
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
name|t1
operator|+
operator|(
name|cols
operator|*
name|rows
operator|)
operator|+
operator|(
name|cols
operator|*
name|rows
operator|/
literal|2
operator|)
operator|+
name|i
operator|*
name|cols
operator|/
literal|2
operator|*
name|interlace
expr_stmt|;
name|target_buffer
operator|+=
name|interlace
operator|*
name|cols
expr_stmt|;
block|}
switch|switch
condition|(
name|i_flag
condition|)
block|{
case|case
literal|1
case|:
operator|*
name|dma_prog
operator|++
operator|=
name|OP_SYNC
operator||
literal|1
operator|<<
literal|24
operator||
name|BKTR_VRE
expr_stmt|;
comment|/*sync vre*/
operator|*
name|dma_prog
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* NULL WORD */
operator|*
name|dma_prog
operator|++
operator|=
name|OP_JUMP
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
operator|(
name|u_long
operator|)
name|vtophys
argument_list|(
name|bktr
operator|->
name|dma_prog
argument_list|)
expr_stmt|;
return|return;
case|case
literal|2
case|:
operator|*
name|dma_prog
operator|++
operator|=
name|OP_SYNC
operator||
literal|1
operator|<<
literal|24
operator||
name|BKTR_VRO
expr_stmt|;
comment|/*sync vre*/
operator|*
name|dma_prog
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* NULL WORD */
operator|*
name|dma_prog
operator|++
operator|=
name|OP_JUMP
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
operator|(
name|u_long
operator|)
name|vtophys
argument_list|(
name|bktr
operator|->
name|dma_prog
argument_list|)
expr_stmt|;
return|return;
case|case
literal|3
case|:
operator|*
name|dma_prog
operator|++
operator|=
name|OP_SYNC
operator||
literal|1
operator|<<
literal|24
operator||
literal|1
operator|<<
literal|15
operator||
name|BKTR_VRO
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* NULL WORD */
operator|*
name|dma_prog
operator|++
operator|=
name|OP_JUMP
expr_stmt|;
operator|*
name|dma_prog
operator|=
operator|(
name|u_long
operator|)
name|vtophys
argument_list|(
name|bktr
operator|->
name|odd_dma_prog
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|interlace
operator|==
literal|2
condition|)
block|{
name|dma_prog
operator|=
operator|(
name|u_long
operator|*
operator|)
name|bktr
operator|->
name|odd_dma_prog
expr_stmt|;
name|target_buffer
operator|=
operator|(
name|u_long
operator|)
name|buffer
operator|+
name|cols
expr_stmt|;
name|t1
operator|=
name|buffer
operator|+
name|cols
operator|/
literal|2
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
name|OP_SYNC
operator||
literal|1
operator|<<
literal|15
operator||
name|BKTR_FM3
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* NULL WORD */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|rows
operator|/
name|interlace
operator|)
condition|;
name|i
operator|++
control|)
block|{
operator|*
name|dma_prog
operator|++
operator|=
name|inst
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
name|cols
operator|/
literal|2
operator||
name|cols
operator|/
literal|2
operator|<<
literal|16
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
name|target_buffer
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
name|t1
operator|+
operator|(
name|cols
operator|*
name|rows
operator|)
operator|+
name|i
operator|*
name|cols
operator|/
literal|2
operator|*
name|interlace
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
name|t1
operator|+
operator|(
name|cols
operator|*
name|rows
operator|)
operator|+
operator|(
name|cols
operator|*
name|rows
operator|/
literal|2
operator|)
operator|+
name|i
operator|*
name|cols
operator|/
literal|2
operator|*
name|interlace
expr_stmt|;
name|target_buffer
operator|+=
name|interlace
operator|*
name|cols
expr_stmt|;
block|}
block|}
operator|*
name|dma_prog
operator|++
operator|=
name|OP_SYNC
operator||
literal|1
operator|<<
literal|24
operator||
literal|1
operator|<<
literal|15
operator||
name|BKTR_VRE
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* NULL WORD */
operator|*
name|dma_prog
operator|++
operator|=
name|OP_JUMP
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
operator|(
name|u_long
operator|)
name|vtophys
argument_list|(
name|bktr
operator|->
name|dma_prog
argument_list|)
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* NULL WORD */
block|}
comment|/*  *   */
specifier|static
name|void
name|yuv12_prog
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|,
name|char
name|i_flag
parameter_list|,
name|int
name|cols
parameter_list|,
name|int
name|rows
parameter_list|,
name|int
name|interlace
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
specifier|volatile
name|unsigned
name|int
name|inst
decl_stmt|;
specifier|volatile
name|unsigned
name|int
name|inst1
decl_stmt|;
specifier|volatile
name|u_long
name|target_buffer
decl_stmt|,
name|t1
decl_stmt|,
name|buffer
decl_stmt|;
name|bt848_ptr_t
name|bt848
decl_stmt|;
specifier|volatile
name|u_long
modifier|*
name|dma_prog
decl_stmt|;
name|struct
name|meteor_pixfmt_internal
modifier|*
name|pf_int
init|=
operator|&
name|pixfmt_table
index|[
name|bktr
operator|->
name|pixfmt
index|]
decl_stmt|;
name|bt848
operator|=
name|bktr
operator|->
name|base
expr_stmt|;
name|bt848
operator|->
name|color_fmt
operator|=
name|pf_int
operator|->
name|color_fmt
expr_stmt|;
name|dma_prog
operator|=
operator|(
name|u_long
operator|*
operator|)
name|bktr
operator|->
name|dma_prog
expr_stmt|;
name|bktr
operator|->
name|capcontrol
operator|=
literal|1
operator|<<
literal|6
operator||
literal|1
operator|<<
literal|4
operator||
literal|3
expr_stmt|;
name|bt848
operator|->
name|adc
operator|=
name|SYNC_LEVEL
expr_stmt|;
name|bt848
operator|->
name|oform
operator|=
literal|0x0
expr_stmt|;
comment|/* Construct Write */
name|inst
operator|=
name|OP_WRITE123
operator||
name|OP_SOL
operator||
name|OP_EOL
operator||
operator|(
name|cols
operator|)
expr_stmt|;
name|inst1
operator|=
name|OP_WRITES123
operator||
name|OP_SOL
operator||
name|OP_EOL
operator||
operator|(
name|cols
operator|)
expr_stmt|;
if|if
condition|(
name|bktr
operator|->
name|video
operator|.
name|addr
condition|)
name|target_buffer
operator|=
operator|(
name|u_long
operator|)
name|bktr
operator|->
name|video
operator|.
name|addr
expr_stmt|;
else|else
name|target_buffer
operator|=
operator|(
name|u_long
operator|)
name|vtophys
argument_list|(
name|bktr
operator|->
name|bigbuf
argument_list|)
expr_stmt|;
name|buffer
operator|=
name|target_buffer
expr_stmt|;
name|t1
operator|=
name|buffer
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
name|OP_SYNC
operator||
literal|1
operator|<<
literal|15
operator||
name|BKTR_FM3
expr_stmt|;
comment|/*sync, mode indicator packed data*/
operator|*
name|dma_prog
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* NULL WORD */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|rows
operator|/
name|interlace
operator|)
operator|/
literal|2
condition|;
name|i
operator|++
control|)
block|{
operator|*
name|dma_prog
operator|++
operator|=
name|inst
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
name|cols
operator|/
literal|2
operator||
operator|(
name|cols
operator|/
literal|2
operator|<<
literal|16
operator|)
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
name|target_buffer
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
name|t1
operator|+
operator|(
name|cols
operator|*
name|rows
operator|)
operator|+
name|i
operator|*
name|cols
operator|/
literal|2
operator|*
name|interlace
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
name|t1
operator|+
operator|(
name|cols
operator|*
name|rows
operator|)
operator|+
operator|(
name|cols
operator|*
name|rows
operator|/
literal|4
operator|)
operator|+
name|i
operator|*
name|cols
operator|/
literal|2
operator|*
name|interlace
expr_stmt|;
name|target_buffer
operator|+=
name|interlace
operator|*
name|cols
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
name|inst1
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
name|cols
operator|/
literal|2
operator||
operator|(
name|cols
operator|/
literal|2
operator|<<
literal|16
operator|)
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
name|target_buffer
expr_stmt|;
name|target_buffer
operator|+=
name|interlace
operator|*
name|cols
expr_stmt|;
block|}
switch|switch
condition|(
name|i_flag
condition|)
block|{
case|case
literal|1
case|:
operator|*
name|dma_prog
operator|++
operator|=
name|OP_SYNC
operator||
literal|1
operator|<<
literal|24
operator||
name|BKTR_VRE
expr_stmt|;
comment|/*sync vre*/
operator|*
name|dma_prog
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* NULL WORD */
operator|*
name|dma_prog
operator|++
operator|=
name|OP_JUMP
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
operator|(
name|u_long
operator|)
name|vtophys
argument_list|(
name|bktr
operator|->
name|dma_prog
argument_list|)
expr_stmt|;
return|return;
case|case
literal|2
case|:
operator|*
name|dma_prog
operator|++
operator|=
name|OP_SYNC
operator||
literal|1
operator|<<
literal|24
operator||
name|BKTR_VRO
expr_stmt|;
comment|/*sync vro*/
operator|*
name|dma_prog
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* NULL WORD */
operator|*
name|dma_prog
operator|++
operator|=
name|OP_JUMP
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
operator|(
name|u_long
operator|)
name|vtophys
argument_list|(
name|bktr
operator|->
name|dma_prog
argument_list|)
expr_stmt|;
return|return;
case|case
literal|3
case|:
operator|*
name|dma_prog
operator|++
operator|=
name|OP_SYNC
operator||
literal|1
operator|<<
literal|24
operator||
literal|1
operator|<<
literal|15
operator||
name|BKTR_VRO
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* NULL WORD */
operator|*
name|dma_prog
operator|++
operator|=
name|OP_JUMP
expr_stmt|;
operator|*
name|dma_prog
operator|=
operator|(
name|u_long
operator|)
name|vtophys
argument_list|(
name|bktr
operator|->
name|odd_dma_prog
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|interlace
operator|==
literal|2
condition|)
block|{
name|dma_prog
operator|=
operator|(
name|u_long
operator|*
operator|)
name|bktr
operator|->
name|odd_dma_prog
expr_stmt|;
name|target_buffer
operator|=
operator|(
name|u_long
operator|)
name|buffer
operator|+
name|cols
expr_stmt|;
name|t1
operator|=
name|buffer
operator|+
name|cols
operator|/
literal|2
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
name|OP_SYNC
operator||
literal|1
operator|<<
literal|15
operator||
name|BKTR_FM3
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* NULL WORD */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
operator|(
name|rows
operator|/
name|interlace
operator|)
operator|/
literal|2
operator|)
condition|;
name|i
operator|++
control|)
block|{
operator|*
name|dma_prog
operator|++
operator|=
name|inst
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
name|cols
operator|/
literal|2
operator||
operator|(
name|cols
operator|/
literal|2
operator|<<
literal|16
operator|)
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
name|target_buffer
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
name|t1
operator|+
operator|(
name|cols
operator|*
name|rows
operator|)
operator|+
name|i
operator|*
name|cols
operator|/
literal|2
operator|*
name|interlace
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
name|t1
operator|+
operator|(
name|cols
operator|*
name|rows
operator|)
operator|+
operator|(
name|cols
operator|*
name|rows
operator|/
literal|4
operator|)
operator|+
name|i
operator|*
name|cols
operator|/
literal|2
operator|*
name|interlace
expr_stmt|;
name|target_buffer
operator|+=
name|interlace
operator|*
name|cols
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
name|inst1
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
name|cols
operator|/
literal|2
operator||
operator|(
name|cols
operator|/
literal|2
operator|<<
literal|16
operator|)
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
name|target_buffer
expr_stmt|;
name|target_buffer
operator|+=
name|interlace
operator|*
name|cols
expr_stmt|;
block|}
block|}
operator|*
name|dma_prog
operator|++
operator|=
name|OP_SYNC
operator||
literal|1
operator|<<
literal|24
operator||
literal|1
operator|<<
literal|15
operator||
name|BKTR_VRE
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* NULL WORD */
operator|*
name|dma_prog
operator|++
operator|=
name|OP_JUMP
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
operator|(
name|u_long
operator|)
name|vtophys
argument_list|(
name|bktr
operator|->
name|dma_prog
argument_list|)
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* NULL WORD */
block|}
comment|/*  *   */
specifier|static
name|void
name|build_dma_prog
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|,
name|char
name|i_flag
parameter_list|)
block|{
name|int
name|rows
decl_stmt|,
name|cols
decl_stmt|,
name|interlace
decl_stmt|;
name|bt848_ptr_t
name|bt848
decl_stmt|;
name|int
name|tmp_int
decl_stmt|;
name|unsigned
name|int
name|temp
decl_stmt|;
name|struct
name|format_params
modifier|*
name|fp
decl_stmt|;
name|struct
name|meteor_pixfmt_internal
modifier|*
name|pf_int
init|=
operator|&
name|pixfmt_table
index|[
name|bktr
operator|->
name|pixfmt
index|]
decl_stmt|;
name|fp
operator|=
operator|&
name|format_params
index|[
name|bktr
operator|->
name|format_params
index|]
expr_stmt|;
name|bt848
operator|=
name|bktr
operator|->
name|base
expr_stmt|;
name|bt848
operator|->
name|int_mask
operator|=
name|ALL_INTS_DISABLED
expr_stmt|;
comment|/* disable FIFO& RISC, leave other bits alone */
name|bt848
operator|->
name|gpio_dma_ctl
operator|&=
operator|~
name|FIFO_RISC_ENABLED
expr_stmt|;
comment|/* set video parameters */
if|if
condition|(
name|bktr
operator|->
name|capture_area_enabled
condition|)
name|temp
operator|=
operator|(
operator|(
name|quad_t
operator|)
name|fp
operator|->
name|htotal
operator|*
operator|(
name|quad_t
operator|)
name|bktr
operator|->
name|capture_area_x_size
operator|*
literal|4096
operator|/
name|fp
operator|->
name|scaled_htotal
operator|/
name|bktr
operator|->
name|cols
operator|)
operator|-
literal|4096
expr_stmt|;
else|else
name|temp
operator|=
operator|(
operator|(
name|quad_t
operator|)
name|fp
operator|->
name|htotal
operator|*
operator|(
name|quad_t
operator|)
name|fp
operator|->
name|scaled_hactive
operator|*
literal|4096
operator|/
name|fp
operator|->
name|scaled_htotal
operator|/
name|bktr
operator|->
name|cols
operator|)
operator|-
literal|4096
expr_stmt|;
comment|/* printf("HSCALE value is %d\n",temp); */
name|bt848
operator|->
name|e_hscale_lo
operator|=
name|temp
operator|&
literal|0xff
expr_stmt|;
name|bt848
operator|->
name|o_hscale_lo
operator|=
name|temp
operator|&
literal|0xff
expr_stmt|;
name|bt848
operator|->
name|e_hscale_hi
operator|=
operator|(
name|temp
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
name|bt848
operator|->
name|o_hscale_hi
operator|=
operator|(
name|temp
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
comment|/* horizontal active */
name|temp
operator|=
name|bktr
operator|->
name|cols
expr_stmt|;
comment|/* printf("HACTIVE value is %d\n",temp); */
name|bt848
operator|->
name|e_hactive_lo
operator|=
name|temp
operator|&
literal|0xff
expr_stmt|;
name|bt848
operator|->
name|o_hactive_lo
operator|=
name|temp
operator|&
literal|0xff
expr_stmt|;
name|bt848
operator|->
name|e_crop
operator|&=
operator|~
literal|0x3
expr_stmt|;
name|bt848
operator|->
name|o_crop
operator|&=
operator|~
literal|0x3
expr_stmt|;
name|bt848
operator|->
name|e_crop
operator||=
operator|(
name|temp
operator|>>
literal|8
operator|)
operator|&
literal|0x3
expr_stmt|;
name|bt848
operator|->
name|o_crop
operator||=
operator|(
name|temp
operator|>>
literal|8
operator|)
operator|&
literal|0x3
expr_stmt|;
comment|/* horizontal delay */
if|if
condition|(
name|bktr
operator|->
name|capture_area_enabled
condition|)
name|temp
operator|=
operator|(
operator|(
name|fp
operator|->
name|hdelay
operator|*
name|fp
operator|->
name|scaled_hactive
operator|+
name|bktr
operator|->
name|capture_area_x_offset
operator|*
name|fp
operator|->
name|scaled_htotal
operator|)
operator|*
name|bktr
operator|->
name|cols
operator|)
operator|/
operator|(
name|bktr
operator|->
name|capture_area_x_size
operator|*
name|fp
operator|->
name|hactive
operator|)
expr_stmt|;
else|else
name|temp
operator|=
operator|(
name|fp
operator|->
name|hdelay
operator|*
name|bktr
operator|->
name|cols
operator|)
operator|/
name|fp
operator|->
name|hactive
expr_stmt|;
name|temp
operator|=
name|temp
operator|&
literal|0x3fe
expr_stmt|;
comment|/* printf("HDELAY value is %d\n",temp); */
name|bt848
operator|->
name|e_delay_lo
operator|=
name|temp
operator|&
literal|0xff
expr_stmt|;
name|bt848
operator|->
name|o_delay_lo
operator|=
name|temp
operator|&
literal|0xff
expr_stmt|;
name|bt848
operator|->
name|e_crop
operator|&=
operator|~
literal|0xc
expr_stmt|;
name|bt848
operator|->
name|o_crop
operator|&=
operator|~
literal|0xc
expr_stmt|;
name|bt848
operator|->
name|e_crop
operator||=
operator|(
name|temp
operator|>>
literal|6
operator|)
operator|&
literal|0xc
expr_stmt|;
name|bt848
operator|->
name|o_crop
operator||=
operator|(
name|temp
operator|>>
literal|6
operator|)
operator|&
literal|0xc
expr_stmt|;
comment|/* vertical scale */
if|if
condition|(
name|bktr
operator|->
name|capture_area_enabled
condition|)
block|{
if|if
condition|(
name|bktr
operator|->
name|flags
operator|&
name|METEOR_ONLY_ODD_FIELDS
operator|||
name|bktr
operator|->
name|flags
operator|&
name|METEOR_ONLY_EVEN_FIELDS
condition|)
name|tmp_int
operator|=
literal|65536
operator|-
operator|(
operator|(
operator|(
name|bktr
operator|->
name|capture_area_y_size
operator|*
literal|256
operator|+
operator|(
name|bktr
operator|->
name|rows
operator|/
literal|2
operator|)
operator|)
operator|/
name|bktr
operator|->
name|rows
operator|)
operator|-
literal|512
operator|)
expr_stmt|;
else|else
block|{
name|tmp_int
operator|=
literal|65536
operator|-
operator|(
operator|(
operator|(
name|bktr
operator|->
name|capture_area_y_size
operator|*
literal|512
operator|+
operator|(
name|bktr
operator|->
name|rows
operator|/
literal|2
operator|)
operator|)
operator|/
name|bktr
operator|->
name|rows
operator|)
operator|-
literal|512
operator|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|bktr
operator|->
name|flags
operator|&
name|METEOR_ONLY_ODD_FIELDS
operator|||
name|bktr
operator|->
name|flags
operator|&
name|METEOR_ONLY_EVEN_FIELDS
condition|)
name|tmp_int
operator|=
literal|65536
operator|-
operator|(
operator|(
operator|(
name|fp
operator|->
name|vactive
operator|*
literal|256
operator|+
operator|(
name|bktr
operator|->
name|rows
operator|/
literal|2
operator|)
operator|)
operator|/
name|bktr
operator|->
name|rows
operator|)
operator|-
literal|512
operator|)
expr_stmt|;
else|else
block|{
name|tmp_int
operator|=
literal|65536
operator|-
operator|(
operator|(
operator|(
name|fp
operator|->
name|vactive
operator|*
literal|512
operator|+
operator|(
name|bktr
operator|->
name|rows
operator|/
literal|2
operator|)
operator|)
operator|/
name|bktr
operator|->
name|rows
operator|)
operator|-
literal|512
operator|)
expr_stmt|;
block|}
block|}
name|tmp_int
operator|&=
literal|0x1fff
expr_stmt|;
comment|/* printf("VSCALE value is %d\n",tmp_int); */
name|bt848
operator|->
name|e_vscale_lo
operator|=
name|tmp_int
operator|&
literal|0xff
expr_stmt|;
name|bt848
operator|->
name|o_vscale_lo
operator|=
name|tmp_int
operator|&
literal|0xff
expr_stmt|;
name|bt848
operator|->
name|e_vscale_hi
operator|&=
operator|~
literal|0x1f
expr_stmt|;
name|bt848
operator|->
name|o_vscale_hi
operator|&=
operator|~
literal|0x1f
expr_stmt|;
name|bt848
operator|->
name|e_vscale_hi
operator||=
operator|(
name|tmp_int
operator|>>
literal|8
operator|)
operator|&
literal|0x1f
expr_stmt|;
name|bt848
operator|->
name|o_vscale_hi
operator||=
operator|(
name|tmp_int
operator|>>
literal|8
operator|)
operator|&
literal|0x1f
expr_stmt|;
comment|/* vertical active */
if|if
condition|(
name|bktr
operator|->
name|capture_area_enabled
condition|)
name|temp
operator|=
name|bktr
operator|->
name|capture_area_y_size
expr_stmt|;
else|else
name|temp
operator|=
name|fp
operator|->
name|vactive
expr_stmt|;
comment|/* printf("VACTIVE is %d\n",temp); */
name|bt848
operator|->
name|e_crop
operator|&=
operator|~
literal|0x30
expr_stmt|;
name|bt848
operator|->
name|e_crop
operator||=
operator|(
name|temp
operator|>>
literal|4
operator|)
operator|&
literal|0x30
expr_stmt|;
name|bt848
operator|->
name|e_vactive_lo
operator|=
name|temp
operator|&
literal|0xff
expr_stmt|;
name|bt848
operator|->
name|o_crop
operator|&=
operator|~
literal|0x30
expr_stmt|;
name|bt848
operator|->
name|o_crop
operator||=
operator|(
name|temp
operator|>>
literal|4
operator|)
operator|&
literal|0x30
expr_stmt|;
name|bt848
operator|->
name|o_vactive_lo
operator|=
name|temp
operator|&
literal|0xff
expr_stmt|;
comment|/* vertical delay */
if|if
condition|(
name|bktr
operator|->
name|capture_area_enabled
condition|)
name|temp
operator|=
name|fp
operator|->
name|vdelay
operator|+
operator|(
name|bktr
operator|->
name|capture_area_y_offset
operator|)
expr_stmt|;
else|else
name|temp
operator|=
name|fp
operator|->
name|vdelay
expr_stmt|;
comment|/* printf("VDELAY is %d\n",temp); */
name|bt848
operator|->
name|e_crop
operator|&=
operator|~
literal|0xC0
expr_stmt|;
name|bt848
operator|->
name|e_crop
operator||=
operator|(
name|temp
operator|>>
literal|2
operator|)
operator|&
literal|0xC0
expr_stmt|;
name|bt848
operator|->
name|e_vdelay_lo
operator|=
name|temp
operator|&
literal|0xff
expr_stmt|;
name|bt848
operator|->
name|o_crop
operator|&=
operator|~
literal|0xC0
expr_stmt|;
name|bt848
operator|->
name|o_crop
operator||=
operator|(
name|temp
operator|>>
literal|2
operator|)
operator|&
literal|0xC0
expr_stmt|;
name|bt848
operator|->
name|o_vdelay_lo
operator|=
name|temp
operator|&
literal|0xff
expr_stmt|;
comment|/* end of video params */
if|if
condition|(
operator|(
name|bktr
operator|->
name|xtal_pll_mode
operator|==
name|BT848_USE_PLL
operator|)
operator|&&
operator|(
name|fp
operator|->
name|iform_xtsel
operator|==
name|BT848_IFORM_X_XT1
operator|)
condition|)
block|{
name|bt848
operator|->
name|tgctrl
operator|=
literal|8
expr_stmt|;
comment|/* Select PLL mode */
block|}
else|else
block|{
name|bt848
operator|->
name|tgctrl
operator|=
literal|0
expr_stmt|;
comment|/* Select Normal xtal 0/xtal 1 mode */
block|}
comment|/* capture control */
switch|switch
condition|(
name|i_flag
condition|)
block|{
case|case
literal|1
case|:
name|bktr
operator|->
name|bktr_cap_ctl
operator|=
operator|(
name|BT848_CAP_CTL_DITH_FRAME
operator||
name|BT848_CAP_CTL_EVEN
operator|)
expr_stmt|;
name|bt848
operator|->
name|e_vscale_hi
operator|&=
operator|~
literal|0x20
expr_stmt|;
name|bt848
operator|->
name|o_vscale_hi
operator|&=
operator|~
literal|0x20
expr_stmt|;
name|interlace
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|bktr
operator|->
name|bktr_cap_ctl
operator|=
operator|(
name|BT848_CAP_CTL_DITH_FRAME
operator||
name|BT848_CAP_CTL_ODD
operator|)
expr_stmt|;
name|bt848
operator|->
name|e_vscale_hi
operator|&=
operator|~
literal|0x20
expr_stmt|;
name|bt848
operator|->
name|o_vscale_hi
operator|&=
operator|~
literal|0x20
expr_stmt|;
name|interlace
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
name|bktr
operator|->
name|bktr_cap_ctl
operator|=
operator|(
name|BT848_CAP_CTL_DITH_FRAME
operator||
name|BT848_CAP_CTL_EVEN
operator||
name|BT848_CAP_CTL_ODD
operator|)
expr_stmt|;
name|bt848
operator|->
name|e_vscale_hi
operator||=
literal|0x20
expr_stmt|;
name|bt848
operator|->
name|o_vscale_hi
operator||=
literal|0x20
expr_stmt|;
name|interlace
operator|=
literal|2
expr_stmt|;
break|break;
block|}
name|bt848
operator|->
name|risc_strt_add
operator|=
name|vtophys
argument_list|(
name|bktr
operator|->
name|dma_prog
argument_list|)
expr_stmt|;
name|rows
operator|=
name|bktr
operator|->
name|rows
expr_stmt|;
name|cols
operator|=
name|bktr
operator|->
name|cols
expr_stmt|;
name|bktr
operator|->
name|vbiflags
operator|&=
operator|~
name|VBI_CAPTURE
expr_stmt|;
comment|/* default - no vbi capture */
comment|/* If /dev/vbi is already open, then use the rgb_vbi RISC program */
if|if
condition|(
operator|(
name|pf_int
operator|->
name|public
operator|.
name|type
operator|==
name|METEOR_PIXTYPE_RGB
operator|)
operator|&&
operator|(
name|bktr
operator|->
name|vbiflags
operator|&
name|VBI_OPEN
operator|)
condition|)
block|{
if|if
condition|(
name|i_flag
operator|==
literal|1
condition|)
name|bktr
operator|->
name|bktr_cap_ctl
operator||=
name|BT848_CAP_CTL_VBI_EVEN
expr_stmt|;
if|if
condition|(
name|i_flag
operator|==
literal|2
condition|)
name|bktr
operator|->
name|bktr_cap_ctl
operator||=
name|BT848_CAP_CTL_VBI_ODD
expr_stmt|;
if|if
condition|(
name|i_flag
operator|==
literal|3
condition|)
name|bktr
operator|->
name|bktr_cap_ctl
operator||=
name|BT848_CAP_CTL_VBI_EVEN
operator||
name|BT848_CAP_CTL_VBI_ODD
expr_stmt|;
name|bktr
operator|->
name|vbiflags
operator||=
name|VBI_CAPTURE
expr_stmt|;
name|rgb_vbi_prog
argument_list|(
name|bktr
argument_list|,
name|i_flag
argument_list|,
name|cols
argument_list|,
name|rows
argument_list|,
name|interlace
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|pf_int
operator|->
name|public
operator|.
name|type
operator|==
name|METEOR_PIXTYPE_RGB
condition|)
block|{
name|rgb_prog
argument_list|(
name|bktr
argument_list|,
name|i_flag
argument_list|,
name|cols
argument_list|,
name|rows
argument_list|,
name|interlace
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|pf_int
operator|->
name|public
operator|.
name|type
operator|==
name|METEOR_PIXTYPE_YUV
condition|)
block|{
name|yuv422_prog
argument_list|(
name|bktr
argument_list|,
name|i_flag
argument_list|,
name|cols
argument_list|,
name|rows
argument_list|,
name|interlace
argument_list|)
expr_stmt|;
name|bt848
operator|->
name|color_ctl_swap
operator|=
name|pixfmt_swap_flags
argument_list|(
name|bktr
operator|->
name|pixfmt
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|pf_int
operator|->
name|public
operator|.
name|type
operator|==
name|METEOR_PIXTYPE_YUV_PACKED
condition|)
block|{
name|yuvpack_prog
argument_list|(
name|bktr
argument_list|,
name|i_flag
argument_list|,
name|cols
argument_list|,
name|rows
argument_list|,
name|interlace
argument_list|)
expr_stmt|;
name|bt848
operator|->
name|color_ctl_swap
operator|=
name|pixfmt_swap_flags
argument_list|(
name|bktr
operator|->
name|pixfmt
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|pf_int
operator|->
name|public
operator|.
name|type
operator|==
name|METEOR_PIXTYPE_YUV_12
condition|)
block|{
name|yuv12_prog
argument_list|(
name|bktr
argument_list|,
name|i_flag
argument_list|,
name|cols
argument_list|,
name|rows
argument_list|,
name|interlace
argument_list|)
expr_stmt|;
name|bt848
operator|->
name|color_ctl_swap
operator|=
name|pixfmt_swap_flags
argument_list|(
name|bktr
operator|->
name|pixfmt
argument_list|)
expr_stmt|;
return|return;
block|}
return|return;
block|}
comment|/******************************************************************************  * video& video capture specific routines:  */
comment|/*  *   */
specifier|static
name|void
name|start_capture
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|,
name|unsigned
name|type
parameter_list|)
block|{
name|bt848_ptr_t
name|bt848
decl_stmt|;
name|u_char
name|i_flag
decl_stmt|;
name|struct
name|format_params
modifier|*
name|fp
decl_stmt|;
name|fp
operator|=
operator|&
name|format_params
index|[
name|bktr
operator|->
name|format_params
index|]
expr_stmt|;
comment|/*  If requested, clear out capture buf first  */
if|if
condition|(
name|bktr
operator|->
name|clr_on_start
operator|&&
operator|(
name|bktr
operator|->
name|video
operator|.
name|addr
operator|==
literal|0
operator|)
condition|)
block|{
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
name|bktr
operator|->
name|bigbuf
argument_list|,
operator|(
name|size_t
operator|)
name|bktr
operator|->
name|rows
operator|*
name|bktr
operator|->
name|cols
operator|*
name|bktr
operator|->
name|frames
operator|*
name|pixfmt_table
index|[
name|bktr
operator|->
name|pixfmt
index|]
operator|.
name|public
operator|.
name|Bpp
argument_list|)
expr_stmt|;
block|}
name|bt848
operator|=
name|bktr
operator|->
name|base
expr_stmt|;
name|bt848
operator|->
name|dstatus
operator|=
literal|0
expr_stmt|;
name|bt848
operator|->
name|int_stat
operator|=
name|bt848
operator|->
name|int_stat
expr_stmt|;
name|bktr
operator|->
name|flags
operator||=
name|type
expr_stmt|;
name|bktr
operator|->
name|flags
operator|&=
operator|~
name|METEOR_WANT_MASK
expr_stmt|;
switch|switch
condition|(
name|bktr
operator|->
name|flags
operator|&
name|METEOR_ONLY_FIELDS_MASK
condition|)
block|{
case|case
name|METEOR_ONLY_EVEN_FIELDS
case|:
name|bktr
operator|->
name|flags
operator||=
name|METEOR_WANT_EVEN
expr_stmt|;
name|i_flag
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|METEOR_ONLY_ODD_FIELDS
case|:
name|bktr
operator|->
name|flags
operator||=
name|METEOR_WANT_ODD
expr_stmt|;
name|i_flag
operator|=
literal|2
expr_stmt|;
break|break;
default|default:
name|bktr
operator|->
name|flags
operator||=
name|METEOR_WANT_MASK
expr_stmt|;
name|i_flag
operator|=
literal|3
expr_stmt|;
break|break;
block|}
comment|/*  TDEC is only valid for continuous captures  */
if|if
condition|(
name|type
operator|==
name|METEOR_SINGLE
condition|)
block|{
name|u_short
name|fps_save
init|=
name|bktr
operator|->
name|fps
decl_stmt|;
name|set_fps
argument_list|(
name|bktr
argument_list|,
name|fp
operator|->
name|frame_rate
argument_list|)
expr_stmt|;
name|bktr
operator|->
name|fps
operator|=
name|fps_save
expr_stmt|;
block|}
else|else
name|set_fps
argument_list|(
name|bktr
argument_list|,
name|bktr
operator|->
name|fps
argument_list|)
expr_stmt|;
if|if
condition|(
name|bktr
operator|->
name|dma_prog_loaded
operator|==
name|FALSE
condition|)
block|{
name|build_dma_prog
argument_list|(
name|bktr
argument_list|,
name|i_flag
argument_list|)
expr_stmt|;
name|bktr
operator|->
name|dma_prog_loaded
operator|=
name|TRUE
expr_stmt|;
block|}
name|bt848
operator|->
name|risc_strt_add
operator|=
name|vtophys
argument_list|(
name|bktr
operator|->
name|dma_prog
argument_list|)
expr_stmt|;
block|}
comment|/*  *   */
specifier|static
name|void
name|set_fps
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|,
name|u_short
name|fps
parameter_list|)
block|{
name|bt848_ptr_t
name|bt848
decl_stmt|;
name|struct
name|format_params
modifier|*
name|fp
decl_stmt|;
name|int
name|i_flag
decl_stmt|;
name|fp
operator|=
operator|&
name|format_params
index|[
name|bktr
operator|->
name|format_params
index|]
expr_stmt|;
name|bt848
operator|=
name|bktr
operator|->
name|base
expr_stmt|;
switch|switch
condition|(
name|bktr
operator|->
name|flags
operator|&
name|METEOR_ONLY_FIELDS_MASK
condition|)
block|{
case|case
name|METEOR_ONLY_EVEN_FIELDS
case|:
name|bktr
operator|->
name|flags
operator||=
name|METEOR_WANT_EVEN
expr_stmt|;
name|i_flag
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|METEOR_ONLY_ODD_FIELDS
case|:
name|bktr
operator|->
name|flags
operator||=
name|METEOR_WANT_ODD
expr_stmt|;
name|i_flag
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
name|bktr
operator|->
name|flags
operator||=
name|METEOR_WANT_MASK
expr_stmt|;
name|i_flag
operator|=
literal|2
expr_stmt|;
break|break;
block|}
name|bt848
operator|->
name|gpio_dma_ctl
operator|=
name|FIFO_RISC_DISABLED
expr_stmt|;
name|bt848
operator|->
name|int_stat
operator|=
name|ALL_INTS_CLEARED
expr_stmt|;
name|bktr
operator|->
name|fps
operator|=
name|fps
expr_stmt|;
name|bt848
operator|->
name|tdec
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|fps
operator|<
name|fp
operator|->
name|frame_rate
condition|)
name|bt848
operator|->
name|tdec
operator|=
name|i_flag
operator|*
operator|(
name|fp
operator|->
name|frame_rate
operator|-
name|fps
operator|)
operator|&
literal|0x3f
expr_stmt|;
else|else
name|bt848
operator|->
name|tdec
operator|=
literal|0
expr_stmt|;
return|return;
block|}
comment|/*   * Given a pixfmt index, compute the bt848 swap_flags necessary to   *   achieve the specified swapping.  * Note that without bt swapping, 2Bpp and 3Bpp modes are written   *   byte-swapped, and 4Bpp modes are byte and word swapped (see Table 6   *   and read R->L).    * Note also that for 3Bpp, we may additionally need to do some creative   *   SKIPing to align the FIFO bytelines with the target buffer (see split()).  * This is abstracted here: e.g. no swaps = RGBA; byte& short swap = ABGR  *   as one would expect.  */
specifier|static
name|u_int
name|pixfmt_swap_flags
parameter_list|(
name|int
name|pixfmt
parameter_list|)
block|{
name|struct
name|meteor_pixfmt
modifier|*
name|pf
init|=
operator|&
name|pixfmt_table
index|[
name|pixfmt
index|]
operator|.
name|public
decl_stmt|;
name|u_int
name|swapf
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|pf
operator|->
name|Bpp
condition|)
block|{
case|case
literal|2
case|:
name|swapf
operator|=
operator|(
name|pf
operator|->
name|swap_bytes
condition|?
literal|0
else|:
name|BSWAP
operator|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
comment|/* no swaps supported for 3bpp - makes no sense w/ bt848 */
break|break;
case|case
literal|4
case|:
if|if
condition|(
name|pf
operator|->
name|swap_bytes
condition|)
name|swapf
operator|=
name|pf
operator|->
name|swap_shorts
condition|?
literal|0
else|:
name|WSWAP
expr_stmt|;
else|else
name|swapf
operator|=
name|pf
operator|->
name|swap_shorts
condition|?
name|BSWAP
else|:
operator|(
name|BSWAP
operator||
name|WSWAP
operator|)
expr_stmt|;
break|break;
block|}
return|return
name|swapf
return|;
block|}
comment|/*   * Converts meteor-defined pixel formats (e.g. METEOR_GEO_RGB16) into  *   our pixfmt_table indices.  */
specifier|static
name|int
name|oformat_meteor_to_bt
parameter_list|(
name|u_long
name|format
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|meteor_pixfmt
modifier|*
name|pf1
decl_stmt|,
modifier|*
name|pf2
decl_stmt|;
comment|/*  Find format in compatibility table  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|METEOR_PIXFMT_TABLE_SIZE
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|meteor_pixfmt_table
index|[
name|i
index|]
operator|.
name|meteor_format
operator|==
name|format
condition|)
break|break;
if|if
condition|(
name|i
operator|>=
name|METEOR_PIXFMT_TABLE_SIZE
condition|)
return|return
operator|-
literal|1
return|;
name|pf1
operator|=
operator|&
name|meteor_pixfmt_table
index|[
name|i
index|]
operator|.
name|public
expr_stmt|;
comment|/*  Match it with an entry in master pixel format table  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|PIXFMT_TABLE_SIZE
condition|;
name|i
operator|++
control|)
block|{
name|pf2
operator|=
operator|&
name|pixfmt_table
index|[
name|i
index|]
operator|.
name|public
expr_stmt|;
if|if
condition|(
operator|(
name|pf1
operator|->
name|type
operator|==
name|pf2
operator|->
name|type
operator|)
operator|&&
operator|(
name|pf1
operator|->
name|Bpp
operator|==
name|pf2
operator|->
name|Bpp
operator|)
operator|&&
operator|!
name|bcmp
argument_list|(
name|pf1
operator|->
name|masks
argument_list|,
name|pf2
operator|->
name|masks
argument_list|,
sizeof|sizeof
argument_list|(
name|pf1
operator|->
name|masks
argument_list|)
argument_list|)
operator|&&
operator|(
name|pf1
operator|->
name|swap_bytes
operator|==
name|pf2
operator|->
name|swap_bytes
operator|)
operator|&&
operator|(
name|pf1
operator|->
name|swap_shorts
operator|==
name|pf2
operator|->
name|swap_shorts
operator|)
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|>=
name|PIXFMT_TABLE_SIZE
condition|)
return|return
operator|-
literal|1
return|;
return|return
name|i
return|;
block|}
comment|/******************************************************************************  * i2c primitives:  */
comment|/* */
define|#
directive|define
name|I2CBITTIME
value|(0x5<<4)
comment|/* 5 * 0.48uS */
define|#
directive|define
name|I2CBITTIME_878
value|(1<< 7)
define|#
directive|define
name|I2C_READ
value|0x01
define|#
directive|define
name|I2C_COMMAND
value|(I2CBITTIME |			\ 				 BT848_DATA_CTL_I2CSCL |	\ 				 BT848_DATA_CTL_I2CSDA)
define|#
directive|define
name|I2C_COMMAND_878
value|(I2CBITTIME_878 |			\ 				 BT848_DATA_CTL_I2CSCL |	\ 				 BT848_DATA_CTL_I2CSDA)
comment|/* Select between old i2c code and new iicbus / smbus code */
if|#
directive|if
operator|(
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
operator|&&
operator|(
name|NSMBUS
operator|>
literal|0
operator|)
operator|)
comment|/*  * The hardware interface is actually SMB commands  */
specifier|static
name|int
name|i2cWrite
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|,
name|int
name|addr
parameter_list|,
name|int
name|byte1
parameter_list|,
name|int
name|byte2
parameter_list|)
block|{
name|char
name|cmd
decl_stmt|;
if|if
condition|(
name|bktr
operator|->
name|id
operator|==
name|BROOKTREE_848
operator|||
name|bktr
operator|->
name|id
operator|==
name|BROOKTREE_848A
operator|||
name|bktr
operator|->
name|id
operator|==
name|BROOKTREE_849A
condition|)
name|cmd
operator|=
name|I2C_COMMAND
expr_stmt|;
else|else
name|cmd
operator|=
name|I2C_COMMAND_878
expr_stmt|;
if|if
condition|(
name|byte2
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|smbus_writew
argument_list|(
name|bktr
operator|->
name|i2c_sc
operator|.
name|smbus
argument_list|,
name|addr
argument_list|,
name|cmd
argument_list|,
call|(
name|short
call|)
argument_list|(
operator|(
operator|(
name|byte2
operator|&
literal|0xff
operator|)
operator|<<
literal|8
operator|)
operator||
operator|(
name|byte1
operator|&
literal|0xff
operator|)
argument_list|)
argument_list|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
else|else
block|{
if|if
condition|(
name|smbus_writeb
argument_list|(
name|bktr
operator|->
name|i2c_sc
operator|.
name|smbus
argument_list|,
name|addr
argument_list|,
name|cmd
argument_list|,
call|(
name|char
call|)
argument_list|(
name|byte1
operator|&
literal|0xff
argument_list|)
argument_list|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* return OK */
return|return
operator|(
literal|0
operator|)
return|;
block|}
specifier|static
name|int
name|i2cRead
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|,
name|int
name|addr
parameter_list|)
block|{
name|char
name|result
decl_stmt|;
name|char
name|cmd
decl_stmt|;
if|if
condition|(
name|bktr
operator|->
name|id
operator|==
name|BROOKTREE_848
operator|||
name|bktr
operator|->
name|id
operator|==
name|BROOKTREE_848A
operator|||
name|bktr
operator|->
name|id
operator|==
name|BROOKTREE_849A
condition|)
name|cmd
operator|=
name|I2C_COMMAND
expr_stmt|;
else|else
name|cmd
operator|=
name|I2C_COMMAND_878
expr_stmt|;
if|if
condition|(
name|smbus_readb
argument_list|(
name|bktr
operator|->
name|i2c_sc
operator|.
name|smbus
argument_list|,
name|addr
argument_list|,
name|cmd
argument_list|,
operator|&
name|result
argument_list|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
return|return
operator|(
call|(
name|int
call|)
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|result
argument_list|)
operator|)
return|;
block|}
define|#
directive|define
name|IICBUS
parameter_list|(
name|bktr
parameter_list|)
value|((bktr)->i2c_sc.iicbus)
comment|/* The MSP34xx Audio chip require i2c bus writes of up to 5 bytes which the */
comment|/* bt848 automated i2c bus controller cannot handle */
comment|/* Therefore we need low level control of the i2c bus hardware */
comment|/* Write to the MSP registers */
specifier|static
name|void
name|msp_write
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|,
name|unsigned
name|char
name|dev
parameter_list|,
name|unsigned
name|int
name|addr
parameter_list|,
name|unsigned
name|int
name|data
parameter_list|)
block|{
name|unsigned
name|char
name|addr_l
decl_stmt|,
name|addr_h
decl_stmt|,
name|data_h
decl_stmt|,
name|data_l
decl_stmt|;
name|addr_h
operator|=
operator|(
name|addr
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
name|addr_l
operator|=
name|addr
operator|&
literal|0xff
expr_stmt|;
name|data_h
operator|=
operator|(
name|data
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
name|data_l
operator|=
name|data
operator|&
literal|0xff
expr_stmt|;
name|iicbus_start
argument_list|(
name|IICBUS
argument_list|(
name|bktr
argument_list|)
argument_list|,
name|MSP3400C_WADDR
argument_list|,
literal|0
comment|/* no timeout? */
argument_list|)
expr_stmt|;
name|iicbus_write_byte
argument_list|(
name|IICBUS
argument_list|(
name|bktr
argument_list|)
argument_list|,
name|dev
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|iicbus_write_byte
argument_list|(
name|IICBUS
argument_list|(
name|bktr
argument_list|)
argument_list|,
name|addr_h
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|iicbus_write_byte
argument_list|(
name|IICBUS
argument_list|(
name|bktr
argument_list|)
argument_list|,
name|addr_l
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|iicbus_write_byte
argument_list|(
name|IICBUS
argument_list|(
name|bktr
argument_list|)
argument_list|,
name|data_h
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|iicbus_write_byte
argument_list|(
name|IICBUS
argument_list|(
name|bktr
argument_list|)
argument_list|,
name|data_l
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|iicbus_stop
argument_list|(
name|IICBUS
argument_list|(
name|bktr
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Write to the MSP registers */
specifier|static
name|unsigned
name|int
name|msp_read
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|,
name|unsigned
name|char
name|dev
parameter_list|,
name|unsigned
name|int
name|addr
parameter_list|)
block|{
name|unsigned
name|int
name|data
decl_stmt|;
name|unsigned
name|char
name|addr_l
decl_stmt|,
name|addr_h
decl_stmt|,
name|dev_r
decl_stmt|;
name|int
name|read
decl_stmt|;
name|u_char
name|data_read
index|[
literal|2
index|]
decl_stmt|;
name|addr_h
operator|=
operator|(
name|addr
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
name|addr_l
operator|=
name|addr
operator|&
literal|0xff
expr_stmt|;
name|dev_r
operator|=
name|dev
operator|+
literal|1
expr_stmt|;
comment|/* XXX errors ignored */
name|iicbus_start
argument_list|(
name|IICBUS
argument_list|(
name|bktr
argument_list|)
argument_list|,
name|MSP3400C_WADDR
argument_list|,
literal|0
comment|/* no timeout? */
argument_list|)
expr_stmt|;
name|iicbus_write_byte
argument_list|(
name|IICBUS
argument_list|(
name|bktr
argument_list|)
argument_list|,
name|dev_r
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|iicbus_write_byte
argument_list|(
name|IICBUS
argument_list|(
name|bktr
argument_list|)
argument_list|,
name|addr_h
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|iicbus_write_byte
argument_list|(
name|IICBUS
argument_list|(
name|bktr
argument_list|)
argument_list|,
name|addr_l
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|iicbus_repeated_start
argument_list|(
name|IICBUS
argument_list|(
name|bktr
argument_list|)
argument_list|,
name|MSP3400C_RADDR
argument_list|,
literal|0
comment|/* no timeout? */
argument_list|)
expr_stmt|;
name|iicbus_read
argument_list|(
name|IICBUS
argument_list|(
name|bktr
argument_list|)
argument_list|,
name|data_read
argument_list|,
literal|2
argument_list|,
operator|&
name|read
argument_list|,
name|IIC_LAST_READ
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|iicbus_stop
argument_list|(
name|IICBUS
argument_list|(
name|bktr
argument_list|)
argument_list|)
expr_stmt|;
name|data
operator|=
operator|(
name|data_read
index|[
literal|0
index|]
operator|<<
literal|8
operator|)
operator||
name|data_read
index|[
literal|1
index|]
expr_stmt|;
return|return
operator|(
name|data
operator|)
return|;
block|}
comment|/* Reset the MSP chip */
comment|/* The user can block the reset (which is handy if you initialise the  * MSP audio in another operating system first (eg in Windows)  */
specifier|static
name|void
name|msp_reset
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|BKTR_NO_MSP_RESET
comment|/* put into reset mode */
name|iicbus_start
argument_list|(
name|IICBUS
argument_list|(
name|bktr
argument_list|)
argument_list|,
name|MSP3400C_WADDR
argument_list|,
literal|0
comment|/* no timeout? */
argument_list|)
expr_stmt|;
name|iicbus_write_byte
argument_list|(
name|IICBUS
argument_list|(
name|bktr
argument_list|)
argument_list|,
literal|0x00
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|iicbus_write_byte
argument_list|(
name|IICBUS
argument_list|(
name|bktr
argument_list|)
argument_list|,
literal|0x80
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|iicbus_write_byte
argument_list|(
name|IICBUS
argument_list|(
name|bktr
argument_list|)
argument_list|,
literal|0x00
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|iicbus_stop
argument_list|(
name|IICBUS
argument_list|(
name|bktr
argument_list|)
argument_list|)
expr_stmt|;
comment|/* put back to operational mode */
name|iicbus_start
argument_list|(
name|IICBUS
argument_list|(
name|bktr
argument_list|)
argument_list|,
name|MSP3400C_WADDR
argument_list|,
literal|0
comment|/* no timeout? */
argument_list|)
expr_stmt|;
name|iicbus_write_byte
argument_list|(
name|IICBUS
argument_list|(
name|bktr
argument_list|)
argument_list|,
literal|0x00
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|iicbus_write_byte
argument_list|(
name|IICBUS
argument_list|(
name|bktr
argument_list|)
argument_list|,
literal|0x00
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|iicbus_write_byte
argument_list|(
name|IICBUS
argument_list|(
name|bktr
argument_list|)
argument_list|,
literal|0x00
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|iicbus_stop
argument_list|(
name|IICBUS
argument_list|(
name|bktr
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
specifier|static
name|void
name|remote_read
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|,
name|struct
name|bktr_remote
modifier|*
name|remote
parameter_list|)
block|{
name|int
name|read
decl_stmt|;
comment|/* XXX errors ignored */
name|iicbus_start
argument_list|(
name|IICBUS
argument_list|(
name|bktr
argument_list|)
argument_list|,
name|bktr
operator|->
name|remote_control_addr
argument_list|,
literal|0
comment|/* no timeout? */
argument_list|)
expr_stmt|;
name|iicbus_read
argument_list|(
name|IICBUS
argument_list|(
name|bktr
argument_list|)
argument_list|,
name|remote
operator|->
name|data
argument_list|,
literal|3
argument_list|,
operator|&
name|read
argument_list|,
name|IIC_LAST_READ
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|iicbus_stop
argument_list|(
name|IICBUS
argument_list|(
name|bktr
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
else|#
directive|else
comment|/* defined(__FreeBSD__)&& (NSMBUS> 0) */
comment|/*  * Program the i2c bus directly  */
specifier|static
name|int
name|i2cWrite
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|,
name|int
name|addr
parameter_list|,
name|int
name|byte1
parameter_list|,
name|int
name|byte2
parameter_list|)
block|{
name|u_long
name|x
decl_stmt|;
name|u_long
name|data
decl_stmt|;
name|bt848_ptr_t
name|bt848
decl_stmt|;
name|bt848
operator|=
name|bktr
operator|->
name|base
expr_stmt|;
comment|/* clear status bits */
name|bt848
operator|->
name|int_stat
operator|=
operator|(
name|BT848_INT_RACK
operator||
name|BT848_INT_I2CDONE
operator|)
expr_stmt|;
comment|/* build the command datum */
if|if
condition|(
name|bktr
operator|->
name|id
operator|==
name|BROOKTREE_848
operator|||
name|bktr
operator|->
name|id
operator|==
name|BROOKTREE_848A
operator|||
name|bktr
operator|->
name|id
operator|==
name|BROOKTREE_849A
condition|)
block|{
name|data
operator|=
operator|(
operator|(
name|addr
operator|&
literal|0xff
operator|)
operator|<<
literal|24
operator|)
operator||
operator|(
operator|(
name|byte1
operator|&
literal|0xff
operator|)
operator|<<
literal|16
operator|)
operator||
name|I2C_COMMAND
expr_stmt|;
block|}
else|else
block|{
name|data
operator|=
operator|(
operator|(
name|addr
operator|&
literal|0xff
operator|)
operator|<<
literal|24
operator|)
operator||
operator|(
operator|(
name|byte1
operator|&
literal|0xff
operator|)
operator|<<
literal|16
operator|)
operator||
name|I2C_COMMAND_878
expr_stmt|;
block|}
if|if
condition|(
name|byte2
operator|!=
operator|-
literal|1
condition|)
block|{
name|data
operator||=
operator|(
operator|(
name|byte2
operator|&
literal|0xff
operator|)
operator|<<
literal|8
operator|)
expr_stmt|;
name|data
operator||=
name|BT848_DATA_CTL_I2CW3B
expr_stmt|;
block|}
comment|/* write the address and data */
name|bt848
operator|->
name|i2c_data_ctl
operator|=
name|data
expr_stmt|;
comment|/* wait for completion */
for|for
control|(
name|x
operator|=
literal|0x7fffffff
init|;
name|x
condition|;
operator|--
name|x
control|)
block|{
comment|/* safety valve */
if|if
condition|(
name|bt848
operator|->
name|int_stat
operator|&
name|BT848_INT_I2CDONE
condition|)
break|break;
block|}
comment|/* check for ACK */
if|if
condition|(
operator|!
name|x
operator|||
operator|!
operator|(
name|bt848
operator|->
name|int_stat
operator|&
name|BT848_INT_RACK
operator|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* return OK */
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/*  *   */
specifier|static
name|int
name|i2cRead
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|,
name|int
name|addr
parameter_list|)
block|{
name|u_long
name|x
decl_stmt|;
name|bt848_ptr_t
name|bt848
decl_stmt|;
name|bt848
operator|=
name|bktr
operator|->
name|base
expr_stmt|;
comment|/* clear status bits */
name|bt848
operator|->
name|int_stat
operator|=
operator|(
name|BT848_INT_RACK
operator||
name|BT848_INT_I2CDONE
operator|)
expr_stmt|;
comment|/* write the READ address */
comment|/* The Bt878 and Bt879  differed on the treatment of i2c commands */
if|if
condition|(
name|bktr
operator|->
name|id
operator|==
name|BROOKTREE_848
operator|||
name|bktr
operator|->
name|id
operator|==
name|BROOKTREE_848A
operator|||
name|bktr
operator|->
name|id
operator|==
name|BROOKTREE_849A
condition|)
block|{
name|bt848
operator|->
name|i2c_data_ctl
operator|=
operator|(
operator|(
name|addr
operator|&
literal|0xff
operator|)
operator|<<
literal|24
operator|)
operator||
name|I2C_COMMAND
expr_stmt|;
block|}
else|else
block|{
name|bt848
operator|->
name|i2c_data_ctl
operator|=
operator|(
operator|(
name|addr
operator|&
literal|0xff
operator|)
operator|<<
literal|24
operator|)
operator||
name|I2C_COMMAND_878
expr_stmt|;
block|}
comment|/* wait for completion */
for|for
control|(
name|x
operator|=
literal|0x7fffffff
init|;
name|x
condition|;
operator|--
name|x
control|)
block|{
comment|/* safety valve */
if|if
condition|(
name|bt848
operator|->
name|int_stat
operator|&
name|BT848_INT_I2CDONE
condition|)
break|break;
block|}
comment|/* check for ACK */
if|if
condition|(
operator|!
name|x
operator|||
operator|!
operator|(
name|bt848
operator|->
name|int_stat
operator|&
name|BT848_INT_RACK
operator|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* it was a read */
return|return
operator|(
operator|(
name|bt848
operator|->
name|i2c_data_ctl
operator|>>
literal|8
operator|)
operator|&
literal|0xff
operator|)
return|;
block|}
comment|/* The MSP34xx Audio chip require i2c bus writes of up to 5 bytes which the */
comment|/* bt848 automated i2c bus controller cannot handle */
comment|/* Therefore we need low level control of the i2c bus hardware */
comment|/* Idea for the following functions are from elsewhere in this driver and */
comment|/* from the Linux BTTV i2c driver by Gerd Knorr<kraxel@cs.tu-berlin.de> */
define|#
directive|define
name|BITD
value|40
specifier|static
name|void
name|i2c_start
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|)
block|{
name|bt848_ptr_t
name|bt848
decl_stmt|;
name|bt848
operator|=
name|bktr
operator|->
name|base
expr_stmt|;
name|bt848
operator|->
name|i2c_data_ctl
operator|=
literal|1
expr_stmt|;
name|DELAY
argument_list|(
name|BITD
argument_list|)
expr_stmt|;
comment|/* release data */
name|bt848
operator|->
name|i2c_data_ctl
operator|=
literal|3
expr_stmt|;
name|DELAY
argument_list|(
name|BITD
argument_list|)
expr_stmt|;
comment|/* release clock */
name|bt848
operator|->
name|i2c_data_ctl
operator|=
literal|2
expr_stmt|;
name|DELAY
argument_list|(
name|BITD
argument_list|)
expr_stmt|;
comment|/* lower data */
name|bt848
operator|->
name|i2c_data_ctl
operator|=
literal|0
expr_stmt|;
name|DELAY
argument_list|(
name|BITD
argument_list|)
expr_stmt|;
comment|/* lower clock */
block|}
specifier|static
name|void
name|i2c_stop
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|)
block|{
name|bt848_ptr_t
name|bt848
decl_stmt|;
name|bt848
operator|=
name|bktr
operator|->
name|base
expr_stmt|;
name|bt848
operator|->
name|i2c_data_ctl
operator|=
literal|0
expr_stmt|;
name|DELAY
argument_list|(
name|BITD
argument_list|)
expr_stmt|;
comment|/* lower clock& data */
name|bt848
operator|->
name|i2c_data_ctl
operator|=
literal|2
expr_stmt|;
name|DELAY
argument_list|(
name|BITD
argument_list|)
expr_stmt|;
comment|/* release clock */
name|bt848
operator|->
name|i2c_data_ctl
operator|=
literal|3
expr_stmt|;
name|DELAY
argument_list|(
name|BITD
argument_list|)
expr_stmt|;
comment|/* release data */
block|}
specifier|static
name|int
name|i2c_write_byte
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|,
name|unsigned
name|char
name|data
parameter_list|)
block|{
name|int
name|x
decl_stmt|;
name|int
name|status
decl_stmt|;
name|bt848_ptr_t
name|bt848
decl_stmt|;
name|bt848
operator|=
name|bktr
operator|->
name|base
expr_stmt|;
comment|/* write out the byte */
for|for
control|(
name|x
operator|=
literal|7
init|;
name|x
operator|>=
literal|0
condition|;
operator|--
name|x
control|)
block|{
if|if
condition|(
name|data
operator|&
operator|(
literal|1
operator|<<
name|x
operator|)
condition|)
block|{
name|bt848
operator|->
name|i2c_data_ctl
operator|=
literal|1
expr_stmt|;
name|DELAY
argument_list|(
name|BITD
argument_list|)
expr_stmt|;
comment|/* assert HI data */
name|bt848
operator|->
name|i2c_data_ctl
operator|=
literal|3
expr_stmt|;
name|DELAY
argument_list|(
name|BITD
argument_list|)
expr_stmt|;
comment|/* strobe clock */
name|bt848
operator|->
name|i2c_data_ctl
operator|=
literal|1
expr_stmt|;
name|DELAY
argument_list|(
name|BITD
argument_list|)
expr_stmt|;
comment|/* release clock */
block|}
else|else
block|{
name|bt848
operator|->
name|i2c_data_ctl
operator|=
literal|0
expr_stmt|;
name|DELAY
argument_list|(
name|BITD
argument_list|)
expr_stmt|;
comment|/* assert LO data */
name|bt848
operator|->
name|i2c_data_ctl
operator|=
literal|2
expr_stmt|;
name|DELAY
argument_list|(
name|BITD
argument_list|)
expr_stmt|;
comment|/* strobe clock */
name|bt848
operator|->
name|i2c_data_ctl
operator|=
literal|0
expr_stmt|;
name|DELAY
argument_list|(
name|BITD
argument_list|)
expr_stmt|;
comment|/* release clock */
block|}
block|}
comment|/* look for an ACK */
name|bt848
operator|->
name|i2c_data_ctl
operator|=
literal|1
expr_stmt|;
name|DELAY
argument_list|(
name|BITD
argument_list|)
expr_stmt|;
comment|/* float data */
name|bt848
operator|->
name|i2c_data_ctl
operator|=
literal|3
expr_stmt|;
name|DELAY
argument_list|(
name|BITD
argument_list|)
expr_stmt|;
comment|/* strobe clock */
name|status
operator|=
name|bt848
operator|->
name|i2c_data_ctl
operator|&
literal|1
expr_stmt|;
comment|/* read the ACK bit */
name|bt848
operator|->
name|i2c_data_ctl
operator|=
literal|1
expr_stmt|;
name|DELAY
argument_list|(
name|BITD
argument_list|)
expr_stmt|;
comment|/* release clock */
return|return
operator|(
name|status
operator|)
return|;
block|}
specifier|static
name|int
name|i2c_read_byte
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|,
name|unsigned
name|char
modifier|*
name|data
parameter_list|,
name|int
name|last
parameter_list|)
block|{
name|int
name|x
decl_stmt|;
name|int
name|bit
decl_stmt|;
name|int
name|byte
init|=
literal|0
decl_stmt|;
name|bt848_ptr_t
name|bt848
decl_stmt|;
name|bt848
operator|=
name|bktr
operator|->
name|base
expr_stmt|;
comment|/* read in the byte */
name|bt848
operator|->
name|i2c_data_ctl
operator|=
literal|1
expr_stmt|;
name|DELAY
argument_list|(
name|BITD
argument_list|)
expr_stmt|;
comment|/* float data */
for|for
control|(
name|x
operator|=
literal|7
init|;
name|x
operator|>=
literal|0
condition|;
operator|--
name|x
control|)
block|{
name|bt848
operator|->
name|i2c_data_ctl
operator|=
literal|3
expr_stmt|;
name|DELAY
argument_list|(
name|BITD
argument_list|)
expr_stmt|;
comment|/* strobe clock */
name|bit
operator|=
name|bt848
operator|->
name|i2c_data_ctl
operator|&
literal|1
expr_stmt|;
comment|/* read the data bit */
if|if
condition|(
name|bit
condition|)
name|byte
operator||=
operator|(
literal|1
operator|<<
name|x
operator|)
expr_stmt|;
name|bt848
operator|->
name|i2c_data_ctl
operator|=
literal|1
expr_stmt|;
name|DELAY
argument_list|(
name|BITD
argument_list|)
expr_stmt|;
comment|/* release clock */
block|}
comment|/* After reading the byte, send an ACK */
comment|/* (unless that was the last byte, for which we send a NAK */
if|if
condition|(
name|last
condition|)
block|{
comment|/* send NAK - same a writing a 1 */
name|bt848
operator|->
name|i2c_data_ctl
operator|=
literal|1
expr_stmt|;
name|DELAY
argument_list|(
name|BITD
argument_list|)
expr_stmt|;
comment|/* set data bit */
name|bt848
operator|->
name|i2c_data_ctl
operator|=
literal|3
expr_stmt|;
name|DELAY
argument_list|(
name|BITD
argument_list|)
expr_stmt|;
comment|/* strobe clock */
name|bt848
operator|->
name|i2c_data_ctl
operator|=
literal|1
expr_stmt|;
name|DELAY
argument_list|(
name|BITD
argument_list|)
expr_stmt|;
comment|/* release clock */
block|}
else|else
block|{
comment|/* send ACK - same as writing a 0 */
name|bt848
operator|->
name|i2c_data_ctl
operator|=
literal|0
expr_stmt|;
name|DELAY
argument_list|(
name|BITD
argument_list|)
expr_stmt|;
comment|/* set data bit */
name|bt848
operator|->
name|i2c_data_ctl
operator|=
literal|2
expr_stmt|;
name|DELAY
argument_list|(
name|BITD
argument_list|)
expr_stmt|;
comment|/* strobe clock */
name|bt848
operator|->
name|i2c_data_ctl
operator|=
literal|0
expr_stmt|;
name|DELAY
argument_list|(
name|BITD
argument_list|)
expr_stmt|;
comment|/* release clock */
block|}
operator|*
name|data
operator|=
name|byte
expr_stmt|;
return|return
literal|0
return|;
block|}
undef|#
directive|undef
name|BITD
comment|/* Write to the MSP registers */
specifier|static
name|void
name|msp_write
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|,
name|unsigned
name|char
name|dev
parameter_list|,
name|unsigned
name|int
name|addr
parameter_list|,
name|unsigned
name|int
name|data
parameter_list|)
block|{
name|unsigned
name|int
name|msp_w_addr
init|=
name|MSP3400C_WADDR
decl_stmt|;
name|unsigned
name|char
name|addr_l
decl_stmt|,
name|addr_h
decl_stmt|,
name|data_h
decl_stmt|,
name|data_l
decl_stmt|;
name|addr_h
operator|=
operator|(
name|addr
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
name|addr_l
operator|=
name|addr
operator|&
literal|0xff
expr_stmt|;
name|data_h
operator|=
operator|(
name|data
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
name|data_l
operator|=
name|data
operator|&
literal|0xff
expr_stmt|;
name|i2c_start
argument_list|(
name|bktr
argument_list|)
expr_stmt|;
name|i2c_write_byte
argument_list|(
name|bktr
argument_list|,
name|msp_w_addr
argument_list|)
expr_stmt|;
name|i2c_write_byte
argument_list|(
name|bktr
argument_list|,
name|dev
argument_list|)
expr_stmt|;
name|i2c_write_byte
argument_list|(
name|bktr
argument_list|,
name|addr_h
argument_list|)
expr_stmt|;
name|i2c_write_byte
argument_list|(
name|bktr
argument_list|,
name|addr_l
argument_list|)
expr_stmt|;
name|i2c_write_byte
argument_list|(
name|bktr
argument_list|,
name|data_h
argument_list|)
expr_stmt|;
name|i2c_write_byte
argument_list|(
name|bktr
argument_list|,
name|data_l
argument_list|)
expr_stmt|;
name|i2c_stop
argument_list|(
name|bktr
argument_list|)
expr_stmt|;
block|}
comment|/* Write to the MSP registers */
specifier|static
name|unsigned
name|int
name|msp_read
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|,
name|unsigned
name|char
name|dev
parameter_list|,
name|unsigned
name|int
name|addr
parameter_list|)
block|{
name|unsigned
name|int
name|data
decl_stmt|;
name|unsigned
name|char
name|addr_l
decl_stmt|,
name|addr_h
decl_stmt|,
name|data_1
decl_stmt|,
name|data_2
decl_stmt|,
name|dev_r
decl_stmt|;
name|addr_h
operator|=
operator|(
name|addr
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
name|addr_l
operator|=
name|addr
operator|&
literal|0xff
expr_stmt|;
name|dev_r
operator|=
name|dev
operator|+
literal|1
expr_stmt|;
name|i2c_start
argument_list|(
name|bktr
argument_list|)
expr_stmt|;
name|i2c_write_byte
argument_list|(
name|bktr
argument_list|,
name|MSP3400C_WADDR
argument_list|)
expr_stmt|;
name|i2c_write_byte
argument_list|(
name|bktr
argument_list|,
name|dev_r
argument_list|)
expr_stmt|;
name|i2c_write_byte
argument_list|(
name|bktr
argument_list|,
name|addr_h
argument_list|)
expr_stmt|;
name|i2c_write_byte
argument_list|(
name|bktr
argument_list|,
name|addr_l
argument_list|)
expr_stmt|;
name|i2c_start
argument_list|(
name|bktr
argument_list|)
expr_stmt|;
name|i2c_write_byte
argument_list|(
name|bktr
argument_list|,
name|MSP3400C_RADDR
argument_list|)
expr_stmt|;
name|i2c_read_byte
argument_list|(
name|bktr
argument_list|,
operator|&
name|data_1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|i2c_read_byte
argument_list|(
name|bktr
argument_list|,
operator|&
name|data_2
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|i2c_stop
argument_list|(
name|bktr
argument_list|)
expr_stmt|;
name|data
operator|=
operator|(
name|data_1
operator|<<
literal|8
operator|)
operator||
name|data_2
expr_stmt|;
return|return
name|data
return|;
block|}
comment|/* Reset the MSP chip */
comment|/* The user can block the reset (which is handy if you initialise the  * MSP audio in another operating system first (eg in Windows)  */
specifier|static
name|void
name|msp_reset
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|BKTR_NO_MSP_RESET
comment|/* put into reset mode */
name|i2c_start
argument_list|(
name|bktr
argument_list|)
expr_stmt|;
name|i2c_write_byte
argument_list|(
name|bktr
argument_list|,
name|MSP3400C_WADDR
argument_list|)
expr_stmt|;
name|i2c_write_byte
argument_list|(
name|bktr
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
name|i2c_write_byte
argument_list|(
name|bktr
argument_list|,
literal|0x80
argument_list|)
expr_stmt|;
name|i2c_write_byte
argument_list|(
name|bktr
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
name|i2c_stop
argument_list|(
name|bktr
argument_list|)
expr_stmt|;
comment|/* put back to operational mode */
name|i2c_start
argument_list|(
name|bktr
argument_list|)
expr_stmt|;
name|i2c_write_byte
argument_list|(
name|bktr
argument_list|,
name|MSP3400C_WADDR
argument_list|)
expr_stmt|;
name|i2c_write_byte
argument_list|(
name|bktr
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
name|i2c_write_byte
argument_list|(
name|bktr
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
name|i2c_write_byte
argument_list|(
name|bktr
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
name|i2c_stop
argument_list|(
name|bktr
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
specifier|static
name|void
name|remote_read
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|,
name|struct
name|bktr_remote
modifier|*
name|remote
parameter_list|)
block|{
comment|/* XXX errors ignored */
name|i2c_start
argument_list|(
name|bktr
argument_list|)
expr_stmt|;
name|i2c_write_byte
argument_list|(
name|bktr
argument_list|,
name|bktr
operator|->
name|remote_control_addr
argument_list|)
expr_stmt|;
name|i2c_read_byte
argument_list|(
name|bktr
argument_list|,
operator|&
operator|(
name|remote
operator|->
name|data
index|[
literal|0
index|]
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|i2c_read_byte
argument_list|(
name|bktr
argument_list|,
operator|&
operator|(
name|remote
operator|->
name|data
index|[
literal|1
index|]
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|i2c_read_byte
argument_list|(
name|bktr
argument_list|,
operator|&
operator|(
name|remote
operator|->
name|data
index|[
literal|2
index|]
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|i2c_stop
argument_list|(
name|bktr
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
comment|/* defined(__FreeBSD__)&& (NSMBUS> 0) */
if|#
directive|if
name|defined
argument_list|(
name|I2C_SOFTWARE_PROBE
argument_list|)
comment|/*  * we are keeping this around for any parts that we need to probe  * but that CANNOT be probed via an i2c read.  * this is necessary because the hardware i2c mechanism  * cannot be programmed for 1 byte writes.  * currently there are no known i2c parts that we need to probe  * and that cannot be safely read.  */
specifier|static
name|int
name|i2cProbe
argument_list|(
name|bktr_ptr_t
name|bktr
argument_list|,
name|int
name|addr
argument_list|)
decl_stmt|;
define|#
directive|define
name|BITD
value|40
define|#
directive|define
name|EXTRA_START
comment|/*  * probe for an I2C device at addr.  */
specifier|static
name|int
name|i2cProbe
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|,
name|int
name|addr
parameter_list|)
block|{
name|int
name|x
decl_stmt|,
name|status
decl_stmt|;
name|bt848_ptr_t
name|bt848
decl_stmt|;
name|bt848
operator|=
name|bktr
operator|->
name|base
expr_stmt|;
comment|/* the START */
if|#
directive|if
name|defined
argument_list|(
name|EXTRA_START
argument_list|)
name|bt848
operator|->
name|i2c_data_ctl
operator|=
literal|1
expr_stmt|;
name|DELAY
argument_list|(
name|BITD
argument_list|)
expr_stmt|;
comment|/* release data */
name|bt848
operator|->
name|i2c_data_ctl
operator|=
literal|3
expr_stmt|;
name|DELAY
argument_list|(
name|BITD
argument_list|)
expr_stmt|;
comment|/* release clock */
endif|#
directive|endif
comment|/* EXTRA_START */
name|bt848
operator|->
name|i2c_data_ctl
operator|=
literal|2
expr_stmt|;
name|DELAY
argument_list|(
name|BITD
argument_list|)
expr_stmt|;
comment|/* lower data */
name|bt848
operator|->
name|i2c_data_ctl
operator|=
literal|0
expr_stmt|;
name|DELAY
argument_list|(
name|BITD
argument_list|)
expr_stmt|;
comment|/* lower clock */
comment|/* write addr */
for|for
control|(
name|x
operator|=
literal|7
init|;
name|x
operator|>=
literal|0
condition|;
operator|--
name|x
control|)
block|{
if|if
condition|(
name|addr
operator|&
operator|(
literal|1
operator|<<
name|x
operator|)
condition|)
block|{
name|bt848
operator|->
name|i2c_data_ctl
operator|=
literal|1
expr_stmt|;
name|DELAY
argument_list|(
name|BITD
argument_list|)
expr_stmt|;
comment|/* assert HI data */
name|bt848
operator|->
name|i2c_data_ctl
operator|=
literal|3
expr_stmt|;
name|DELAY
argument_list|(
name|BITD
argument_list|)
expr_stmt|;
comment|/* strobe clock */
name|bt848
operator|->
name|i2c_data_ctl
operator|=
literal|1
expr_stmt|;
name|DELAY
argument_list|(
name|BITD
argument_list|)
expr_stmt|;
comment|/* release clock */
block|}
else|else
block|{
name|bt848
operator|->
name|i2c_data_ctl
operator|=
literal|0
expr_stmt|;
name|DELAY
argument_list|(
name|BITD
argument_list|)
expr_stmt|;
comment|/* assert LO data */
name|bt848
operator|->
name|i2c_data_ctl
operator|=
literal|2
expr_stmt|;
name|DELAY
argument_list|(
name|BITD
argument_list|)
expr_stmt|;
comment|/* strobe clock */
name|bt848
operator|->
name|i2c_data_ctl
operator|=
literal|0
expr_stmt|;
name|DELAY
argument_list|(
name|BITD
argument_list|)
expr_stmt|;
comment|/* release clock */
block|}
block|}
comment|/* look for an ACK */
name|bt848
operator|->
name|i2c_data_ctl
operator|=
literal|1
expr_stmt|;
name|DELAY
argument_list|(
name|BITD
argument_list|)
expr_stmt|;
comment|/* float data */
name|bt848
operator|->
name|i2c_data_ctl
operator|=
literal|3
expr_stmt|;
name|DELAY
argument_list|(
name|BITD
argument_list|)
expr_stmt|;
comment|/* strobe clock */
name|status
operator|=
name|bt848
operator|->
name|i2c_data_ctl
operator|&
literal|1
expr_stmt|;
comment|/* read the ACK bit */
name|bt848
operator|->
name|i2c_data_ctl
operator|=
literal|1
expr_stmt|;
name|DELAY
argument_list|(
name|BITD
argument_list|)
expr_stmt|;
comment|/* release clock */
comment|/* the STOP */
name|bt848
operator|->
name|i2c_data_ctl
operator|=
literal|0
expr_stmt|;
name|DELAY
argument_list|(
name|BITD
argument_list|)
expr_stmt|;
comment|/* lower clock& data */
name|bt848
operator|->
name|i2c_data_ctl
operator|=
literal|2
expr_stmt|;
name|DELAY
argument_list|(
name|BITD
argument_list|)
expr_stmt|;
comment|/* release clock */
name|bt848
operator|->
name|i2c_data_ctl
operator|=
literal|3
expr_stmt|;
name|DELAY
argument_list|(
name|BITD
argument_list|)
expr_stmt|;
comment|/* release data */
return|return
operator|(
name|status
operator|)
return|;
block|}
undef|#
directive|undef
name|EXTRA_START
undef|#
directive|undef
name|BITD
endif|#
directive|endif
comment|/* I2C_SOFTWARE_PROBE */
comment|/*  *   */
specifier|static
name|int
name|writeEEProm
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|count
parameter_list|,
name|u_char
modifier|*
name|data
parameter_list|)
block|{
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/*  *   */
specifier|static
name|int
name|readEEProm
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|count
parameter_list|,
name|u_char
modifier|*
name|data
parameter_list|)
block|{
name|int
name|x
decl_stmt|;
name|int
name|addr
decl_stmt|;
name|int
name|max
decl_stmt|;
name|int
name|byte
decl_stmt|;
comment|/* get the address of the EEProm */
name|addr
operator|=
call|(
name|int
call|)
argument_list|(
name|bktr
operator|->
name|card
operator|.
name|eepromAddr
operator|&
literal|0xff
argument_list|)
expr_stmt|;
if|if
condition|(
name|addr
operator|==
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|max
operator|=
call|(
name|int
call|)
argument_list|(
name|bktr
operator|->
name|card
operator|.
name|eepromSize
operator|*
name|EEPROMBLOCKSIZE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|offset
operator|+
name|count
operator|)
operator|>
name|max
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* set the start address */
if|if
condition|(
name|i2cWrite
argument_list|(
name|bktr
argument_list|,
name|addr
argument_list|,
name|offset
argument_list|,
operator|-
literal|1
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* the read cycle */
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|count
condition|;
operator|++
name|x
control|)
block|{
if|if
condition|(
operator|(
name|byte
operator|=
name|i2cRead
argument_list|(
name|bktr
argument_list|,
operator|(
name|addr
operator||
literal|1
operator|)
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|data
index|[
name|x
index|]
operator|=
name|byte
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
define|#
directive|define
name|ABSENT
value|(-1)
comment|/*  * get a signature of the card  * read all 128 possible i2c read addresses from 0x01 thru 0xff  * build a bit array with a 1 bit for each i2c device that responds  *  * XXX FIXME: use offset& count args  */
specifier|static
name|int
name|signCard
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|count
parameter_list|,
name|u_char
modifier|*
name|sig
parameter_list|)
block|{
name|int
name|x
decl_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
literal|16
condition|;
operator|++
name|x
control|)
name|sig
index|[
name|x
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|count
condition|;
operator|++
name|x
control|)
block|{
if|if
condition|(
name|i2cRead
argument_list|(
name|bktr
argument_list|,
operator|(
literal|2
operator|*
name|x
operator|)
operator|+
literal|1
argument_list|)
operator|!=
name|ABSENT
condition|)
block|{
name|sig
index|[
name|x
operator|/
literal|8
index|]
operator||=
operator|(
literal|1
operator|<<
operator|(
name|x
operator|%
literal|8
operator|)
operator|)
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/*  * any_i2c_devices.  * Some BT848/BT848A cards have no tuner and no additional i2c devices  * eg stereo decoder. These are used for video conferencing or capture from  * a video camera. (VideoLogic Captivator PCI, Intel SmartCapture card).  *  * Determine if there are any i2c devices present. There are none present if  *  a) reading from all 128 devices returns ABSENT (-1) for each one  *     (eg VideoLogic Captivator PCI with BT848)  *  b) reading from all 128 devices returns 0 for each one  *     (eg VideoLogic Captivator PCI rev. 2F with BT848A)  */
specifier|static
name|int
name|check_for_i2c_devices
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|)
block|{
name|int
name|x
decl_stmt|,
name|temp_read
decl_stmt|;
name|int
name|i2c_all_0
init|=
literal|1
decl_stmt|;
name|int
name|i2c_all_absent
init|=
literal|1
decl_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
literal|128
condition|;
operator|++
name|x
control|)
block|{
name|temp_read
operator|=
name|i2cRead
argument_list|(
name|bktr
argument_list|,
operator|(
literal|2
operator|*
name|x
operator|)
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp_read
operator|!=
literal|0
condition|)
name|i2c_all_0
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|temp_read
operator|!=
name|ABSENT
condition|)
name|i2c_all_absent
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|i2c_all_0
operator|)
operator|||
operator|(
name|i2c_all_absent
operator|)
condition|)
return|return
literal|0
return|;
else|else
return|return
literal|1
return|;
block|}
comment|/*  * Temic/Philips datasheets say tuners can be at i2c addresses 0xc0, 0xc2,  * 0xc4 or 0xc6, settable by links on the tuner  * Determine the actual address used on the TV card by probing read addresses  */
specifier|static
name|int
name|locate_tuner_address
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|)
block|{
if|if
condition|(
name|i2cRead
argument_list|(
name|bktr
argument_list|,
literal|0xc1
argument_list|)
operator|!=
name|ABSENT
condition|)
return|return
literal|0xc0
return|;
if|if
condition|(
name|i2cRead
argument_list|(
name|bktr
argument_list|,
literal|0xc3
argument_list|)
operator|!=
name|ABSENT
condition|)
return|return
literal|0xc2
return|;
if|if
condition|(
name|i2cRead
argument_list|(
name|bktr
argument_list|,
literal|0xc5
argument_list|)
operator|!=
name|ABSENT
condition|)
return|return
literal|0xc4
return|;
if|if
condition|(
name|i2cRead
argument_list|(
name|bktr
argument_list|,
literal|0xc7
argument_list|)
operator|!=
name|ABSENT
condition|)
return|return
literal|0xc6
return|;
return|return
operator|-
literal|1
return|;
comment|/* no tuner found */
block|}
comment|/*  * Search for a configuration EEPROM on the i2c bus by looking at i2c addresses  * where EEPROMs are usually found.  */
specifier|static
name|int
name|locate_eeprom_address
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|)
block|{
if|if
condition|(
name|i2cRead
argument_list|(
name|bktr
argument_list|,
literal|0xa0
argument_list|)
operator|!=
name|ABSENT
condition|)
return|return
literal|0xa0
return|;
if|if
condition|(
name|i2cRead
argument_list|(
name|bktr
argument_list|,
literal|0xac
argument_list|)
operator|!=
name|ABSENT
condition|)
return|return
literal|0xac
return|;
if|if
condition|(
name|i2cRead
argument_list|(
name|bktr
argument_list|,
literal|0xae
argument_list|)
operator|!=
name|ABSENT
condition|)
return|return
literal|0xae
return|;
return|return
operator|-
literal|1
return|;
comment|/* no eeprom found */
block|}
comment|/*  * determine the card brand/model  * OVERRIDE_CARD, OVERRIDE_TUNER, OVERRIDE_DBX and OVERRIDE_MSP  * can be used to select a specific device, regardless of the  * autodetection and i2c device checks.  *  * The scheme used for probing cards has one major drawback:  *  on bt848/849 based cards, it is impossible to work out which type  *  of tuner is actually fitted, or if there is extra hardware on board  *  connected to GPIO pins (eg radio chips or MSP34xx reset logic)  *  The driver cannot tell if the Tuner is PAL,NTSC, Temic or Philips.  *  *  All Hauppauge cards have a configuration eeprom which tells us the  *  tuner type and other features of the their cards.  *  Also, Bt878 based cards (certainly Hauppauge and AverMedia) should support   *  sub-system vendor id, identifying the make and model of the card.  *  * The current probe code works as follows  * 1) Check if it is a BT878. If so, read the sub-system vendor id.  *    Select the required tuner and other onboard features.  * 2) If it is a BT848, 848A or 849A, continue on:  *   3) Some cards have no I2C devices. Check if the i2c bus is empty  *      and if so, our detection job is nearly over.  *   4) Check I2C address 0xa0. If present this will be a Hauppauge card  *      or an Osprey card. The Hauppauge EEPROM can determine on board tuner  *      type and other features.   *   4) Check I2C address 0xa8. If present this is a STB card.  *      Still have to guess on the tuner type.  *   5) Otherwise we are in the dark. Miro cards have the tuner type  *      hard-coded on the GPIO pins, but we do not actually know if we have   *      a Miro card.  *      Some older makes of card put Philips tuners and Temic tuners at  *      different I2C addresses, so an i2c bus probe can help, but it is  *      really just a guess.  *                * 6) After determining the Tuner Type, we probe the i2c bus for other  *    devices at known locations, eg IR-Remote Control, MSP34xx and TDA  *    stereo chips.  */
define|#
directive|define
name|VENDOR_AVER_MEDIA
value|0x1431
define|#
directive|define
name|VENDOR_HAUPPAUGE
value|0x0070
define|#
directive|define
name|VENDOR_FLYVIDEO
value|0x1851
define|#
directive|define
name|VENDOR_STB
value|0x10B4
specifier|static
name|void
name|probeCard
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|,
name|int
name|verbose
parameter_list|)
block|{
name|int
name|card
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|,
name|card_found
decl_stmt|;
name|int
name|status
decl_stmt|;
name|bt848_ptr_t
name|bt848
decl_stmt|;
name|u_char
name|probe_signature
index|[
literal|128
index|]
decl_stmt|,
modifier|*
name|probe_temp
decl_stmt|;
name|int
name|any_i2c_devices
decl_stmt|;
name|u_char
name|eeprom
index|[
literal|256
index|]
decl_stmt|;
name|u_char
name|tuner_code
init|=
literal|0
decl_stmt|;
name|int
name|tuner_i2c_address
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|eeprom_i2c_address
init|=
operator|-
literal|1
decl_stmt|;
name|bt848
operator|=
name|bktr
operator|->
name|base
expr_stmt|;
comment|/* Select all GPIO bits as inputs */
name|bt848
operator|->
name|gpio_out_en
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"bktr: GPIO is 0x%08x\n"
argument_list|,
name|bt848
operator|->
name|gpio_data
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAUPPAUGE_MSP_RESET
comment|/* Reset the MSP34xx audio chip. This resolves bootup card 	 * detection problems with old Bt848 based Hauppauge cards with 	 * MSP34xx stereo audio chips. This must be user enabled because 	 * at this point the probe function does not know the card type. */
name|bt848
operator|->
name|gpio_out_en
operator|=
name|bt848
operator|->
name|gpio_out_en
operator||
operator|(
literal|1
operator|<<
literal|5
operator|)
expr_stmt|;
name|bt848
operator|->
name|gpio_data
operator|=
name|bt848
operator|->
name|gpio_data
operator||
operator|(
literal|1
operator|<<
literal|5
operator|)
expr_stmt|;
comment|/* write '1' */
name|DELAY
argument_list|(
literal|2500
argument_list|)
expr_stmt|;
comment|/* wait 2.5ms */
name|bt848
operator|->
name|gpio_data
operator|=
name|bt848
operator|->
name|gpio_data
operator|&
operator|~
operator|(
literal|1
operator|<<
literal|5
operator|)
expr_stmt|;
comment|/* write '0' */
name|DELAY
argument_list|(
literal|2500
argument_list|)
expr_stmt|;
comment|/* wait 2.5ms */
name|bt848
operator|->
name|gpio_data
operator|=
name|bt848
operator|->
name|gpio_data
operator||
operator|(
literal|1
operator|<<
literal|5
operator|)
expr_stmt|;
comment|/* write '1' */
name|DELAY
argument_list|(
literal|2500
argument_list|)
expr_stmt|;
comment|/* wait 2.5ms */
endif|#
directive|endif
comment|/* Check for the presence of i2c devices */
name|any_i2c_devices
operator|=
name|check_for_i2c_devices
argument_list|(
name|bktr
argument_list|)
expr_stmt|;
comment|/* Check for a user specified override on the card selection */
if|#
directive|if
name|defined
argument_list|(
name|OVERRIDE_CARD
argument_list|)
name|bktr
operator|->
name|card
operator|=
name|cards
index|[
operator|(
name|card
operator|=
name|OVERRIDE_CARD
operator|)
index|]
expr_stmt|;
goto|goto
name|checkEEPROM
goto|;
endif|#
directive|endif
if|if
condition|(
name|bktr
operator|->
name|bt848_card
operator|!=
operator|-
literal|1
condition|)
block|{
name|bktr
operator|->
name|card
operator|=
name|cards
index|[
operator|(
name|card
operator|=
name|bktr
operator|->
name|bt848_card
operator|)
index|]
expr_stmt|;
goto|goto
name|checkEEPROM
goto|;
block|}
comment|/* No override, so try and determine the make of the card */
comment|/* On BT878/879 cards, read the sub-system vendor id */
comment|/* This identifies the manufacturer of the card and the model */
comment|/* In theory this can be read from PCI registers but this does not */
comment|/* appear to work on the FlyVideo 98. Hauppauge also warned that */
comment|/* the PCI registers are sometimes not loaded correctly. */
comment|/* Therefore, I will read the sub-system vendor ID from the EEPROM */
comment|/* (just like the Bt878 does during power up initialisation) */
if|if
condition|(
name|bktr
operator|->
name|id
operator|==
name|BROOKTREE_878
operator|||
name|bktr
operator|->
name|id
operator|==
name|BROOKTREE_879
condition|)
block|{
comment|/* Try and locate the EEPROM */
name|eeprom_i2c_address
operator|=
name|locate_eeprom_address
argument_list|(
name|bktr
argument_list|)
expr_stmt|;
if|if
condition|(
name|eeprom_i2c_address
operator|!=
operator|-
literal|1
condition|)
block|{
name|unsigned
name|int
name|subsystem_vendor_id
decl_stmt|;
comment|/* vendors PCI-SIG ID */
name|unsigned
name|int
name|subsystem_id
decl_stmt|;
comment|/* board model number */
name|unsigned
name|int
name|byte_252
decl_stmt|,
name|byte_253
decl_stmt|,
name|byte_254
decl_stmt|,
name|byte_255
decl_stmt|;
name|bktr
operator|->
name|card
operator|=
name|cards
index|[
operator|(
name|card
operator|=
name|CARD_UNKNOWN
operator|)
index|]
expr_stmt|;
name|bktr
operator|->
name|card
operator|.
name|eepromAddr
operator|=
name|eeprom_i2c_address
expr_stmt|;
name|bktr
operator|->
name|card
operator|.
name|eepromSize
operator|=
call|(
name|u_char
call|)
argument_list|(
literal|256
operator|/
name|EEPROMBLOCKSIZE
argument_list|)
expr_stmt|;
name|readEEProm
argument_list|(
name|bktr
argument_list|,
literal|0
argument_list|,
literal|256
argument_list|,
operator|(
name|u_char
operator|*
operator|)
operator|&
name|eeprom
argument_list|)
expr_stmt|;
name|byte_252
operator|=
operator|(
name|unsigned
name|int
operator|)
name|eeprom
index|[
literal|252
index|]
expr_stmt|;
name|byte_253
operator|=
operator|(
name|unsigned
name|int
operator|)
name|eeprom
index|[
literal|253
index|]
expr_stmt|;
name|byte_254
operator|=
operator|(
name|unsigned
name|int
operator|)
name|eeprom
index|[
literal|254
index|]
expr_stmt|;
name|byte_255
operator|=
operator|(
name|unsigned
name|int
operator|)
name|eeprom
index|[
literal|255
index|]
expr_stmt|;
name|subsystem_id
operator|=
operator|(
name|byte_252
operator|<<
literal|8
operator|)
operator||
name|byte_253
expr_stmt|;
name|subsystem_vendor_id
operator|=
operator|(
name|byte_254
operator|<<
literal|8
operator|)
operator||
name|byte_255
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"subsytem 0x%04x 0x%04x\n"
argument_list|,
name|subsystem_vendor_id
argument_list|,
name|subsystem_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|subsystem_vendor_id
operator|==
name|VENDOR_AVER_MEDIA
condition|)
block|{
name|bktr
operator|->
name|card
operator|=
name|cards
index|[
operator|(
name|card
operator|=
name|CARD_AVER_MEDIA
operator|)
index|]
expr_stmt|;
name|bktr
operator|->
name|card
operator|.
name|eepromAddr
operator|=
name|eeprom_i2c_address
expr_stmt|;
name|bktr
operator|->
name|card
operator|.
name|eepromSize
operator|=
call|(
name|u_char
call|)
argument_list|(
literal|256
operator|/
name|EEPROMBLOCKSIZE
argument_list|)
expr_stmt|;
goto|goto
name|checkTuner
goto|;
block|}
if|if
condition|(
name|subsystem_vendor_id
operator|==
name|VENDOR_HAUPPAUGE
condition|)
block|{
name|bktr
operator|->
name|card
operator|=
name|cards
index|[
operator|(
name|card
operator|=
name|CARD_HAUPPAUGE
operator|)
index|]
expr_stmt|;
name|bktr
operator|->
name|card
operator|.
name|eepromAddr
operator|=
name|eeprom_i2c_address
expr_stmt|;
name|bktr
operator|->
name|card
operator|.
name|eepromSize
operator|=
call|(
name|u_char
call|)
argument_list|(
literal|256
operator|/
name|EEPROMBLOCKSIZE
argument_list|)
expr_stmt|;
goto|goto
name|checkTuner
goto|;
block|}
if|if
condition|(
name|subsystem_vendor_id
operator|==
name|VENDOR_FLYVIDEO
condition|)
block|{
name|bktr
operator|->
name|card
operator|=
name|cards
index|[
operator|(
name|card
operator|=
name|CARD_FLYVIDEO
operator|)
index|]
expr_stmt|;
name|bktr
operator|->
name|card
operator|.
name|eepromAddr
operator|=
name|eeprom_i2c_address
expr_stmt|;
name|bktr
operator|->
name|card
operator|.
name|eepromSize
operator|=
call|(
name|u_char
call|)
argument_list|(
literal|256
operator|/
name|EEPROMBLOCKSIZE
argument_list|)
expr_stmt|;
goto|goto
name|checkTuner
goto|;
block|}
if|if
condition|(
name|subsystem_vendor_id
operator|==
name|VENDOR_STB
condition|)
block|{
name|bktr
operator|->
name|card
operator|=
name|cards
index|[
operator|(
name|card
operator|=
name|CARD_STB
operator|)
index|]
expr_stmt|;
name|bktr
operator|->
name|card
operator|.
name|eepromAddr
operator|=
name|eeprom_i2c_address
expr_stmt|;
name|bktr
operator|->
name|card
operator|.
name|eepromSize
operator|=
call|(
name|u_char
call|)
argument_list|(
literal|256
operator|/
name|EEPROMBLOCKSIZE
argument_list|)
expr_stmt|;
goto|goto
name|checkTuner
goto|;
block|}
comment|/* Vendor is unknown. We will use the standard probe code */
comment|/* which may not give best results */
name|printf
argument_list|(
literal|"Warning - card vendor 0x%04x (model 0x%04x) unknown. This may cause poor performance\n"
argument_list|,
name|subsystem_vendor_id
argument_list|,
name|subsystem_id
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"Warning - card has no configuration EEPROM. Cannot determine card make. This may cause poor performance\n"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* end of bt878/bt879 card detection code */
comment|/* If we get to this point, we must have a Bt848/848A/849A card */
comment|/* or a Bt878/879 with an unknown subsystem vendor id */
comment|/* Try and determine the make of card by clever i2c probing */
comment|/* Check for i2c devices. If none, move on */
if|if
condition|(
operator|!
name|any_i2c_devices
condition|)
block|{
name|bktr
operator|->
name|card
operator|=
name|cards
index|[
operator|(
name|card
operator|=
name|CARD_INTEL
operator|)
index|]
expr_stmt|;
name|bktr
operator|->
name|card
operator|.
name|eepromAddr
operator|=
literal|0
expr_stmt|;
name|bktr
operator|->
name|card
operator|.
name|eepromSize
operator|=
literal|0
expr_stmt|;
goto|goto
name|checkTuner
goto|;
block|}
comment|/* Look for Hauppauge, STB and Osprey cards by the presence */
comment|/* of an EEPROM */
comment|/* Note: Bt878 based cards also use EEPROMs so we can only do this */
comment|/* test on BT848/848A and 849A based cards. */
if|if
condition|(
operator|(
name|bktr
operator|->
name|id
operator|==
name|BROOKTREE_848
operator|)
operator|||
operator|(
name|bktr
operator|->
name|id
operator|==
name|BROOKTREE_848A
operator|)
operator|||
operator|(
name|bktr
operator|->
name|id
operator|==
name|BROOKTREE_849A
operator|)
condition|)
block|{
comment|/* At i2c address 0xa0, look for Hauppauge and Osprey cards */
if|if
condition|(
operator|(
name|status
operator|=
name|i2cRead
argument_list|(
name|bktr
argument_list|,
name|PFC8582_RADDR
argument_list|)
operator|)
operator|!=
name|ABSENT
condition|)
block|{
comment|/* Read the eeprom contents */
name|bktr
operator|->
name|card
operator|=
name|cards
index|[
operator|(
name|card
operator|=
name|CARD_UNKNOWN
operator|)
index|]
expr_stmt|;
name|bktr
operator|->
name|card
operator|.
name|eepromAddr
operator|=
name|PFC8582_WADDR
expr_stmt|;
name|bktr
operator|->
name|card
operator|.
name|eepromSize
operator|=
call|(
name|u_char
call|)
argument_list|(
literal|256
operator|/
name|EEPROMBLOCKSIZE
argument_list|)
expr_stmt|;
name|readEEProm
argument_list|(
name|bktr
argument_list|,
literal|0
argument_list|,
literal|128
argument_list|,
operator|(
name|u_char
operator|*
operator|)
operator|&
name|eeprom
argument_list|)
expr_stmt|;
comment|/* For Hauppauge, check the EEPROM begins with 0x84 */
if|if
condition|(
name|eeprom
index|[
literal|0
index|]
operator|==
literal|0x84
condition|)
block|{
name|bktr
operator|->
name|card
operator|=
name|cards
index|[
operator|(
name|card
operator|=
name|CARD_HAUPPAUGE
operator|)
index|]
expr_stmt|;
name|bktr
operator|->
name|card
operator|.
name|eepromAddr
operator|=
name|PFC8582_WADDR
expr_stmt|;
name|bktr
operator|->
name|card
operator|.
name|eepromSize
operator|=
call|(
name|u_char
call|)
argument_list|(
literal|256
operator|/
name|EEPROMBLOCKSIZE
argument_list|)
expr_stmt|;
goto|goto
name|checkTuner
goto|;
block|}
comment|/* For Osprey, check the EEPROM begins with "MMAC" */
if|if
condition|(
operator|(
name|eeprom
index|[
literal|0
index|]
operator|==
literal|'M'
operator|)
operator|&&
operator|(
name|eeprom
index|[
literal|1
index|]
operator|==
literal|'M'
operator|)
operator|&&
operator|(
name|eeprom
index|[
literal|2
index|]
operator|==
literal|'A'
operator|)
operator|&&
operator|(
name|eeprom
index|[
literal|3
index|]
operator|==
literal|'C'
operator|)
condition|)
block|{
name|bktr
operator|->
name|card
operator|=
name|cards
index|[
operator|(
name|card
operator|=
name|CARD_OSPREY
operator|)
index|]
expr_stmt|;
name|bktr
operator|->
name|card
operator|.
name|eepromAddr
operator|=
name|PFC8582_WADDR
expr_stmt|;
name|bktr
operator|->
name|card
operator|.
name|eepromSize
operator|=
call|(
name|u_char
call|)
argument_list|(
literal|256
operator|/
name|EEPROMBLOCKSIZE
argument_list|)
expr_stmt|;
goto|goto
name|checkTuner
goto|;
block|}
name|printf
argument_list|(
literal|"Warning: Unknown card type. EEPROM data not recognised\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%x %x %x %x\n"
argument_list|,
name|eeprom
index|[
literal|0
index|]
argument_list|,
name|eeprom
index|[
literal|1
index|]
argument_list|,
name|eeprom
index|[
literal|2
index|]
argument_list|,
name|eeprom
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* look for an STB card */
if|if
condition|(
operator|(
name|status
operator|=
name|i2cRead
argument_list|(
name|bktr
argument_list|,
name|X24C01_RADDR
argument_list|)
operator|)
operator|!=
name|ABSENT
condition|)
block|{
name|bktr
operator|->
name|card
operator|=
name|cards
index|[
operator|(
name|card
operator|=
name|CARD_STB
operator|)
index|]
expr_stmt|;
name|bktr
operator|->
name|card
operator|.
name|eepromAddr
operator|=
name|X24C01_WADDR
expr_stmt|;
name|bktr
operator|->
name|card
operator|.
name|eepromSize
operator|=
call|(
name|u_char
call|)
argument_list|(
literal|128
operator|/
name|EEPROMBLOCKSIZE
argument_list|)
expr_stmt|;
goto|goto
name|checkTuner
goto|;
block|}
block|}
name|signCard
argument_list|(
name|bktr
argument_list|,
literal|1
argument_list|,
literal|128
argument_list|,
operator|(
name|u_char
operator|*
operator|)
operator|&
name|probe_signature
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
block|{
name|printf
argument_list|(
literal|"card signature \n"
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|Bt848_MAX_SIGN
condition|;
name|j
operator|++
control|)
block|{
name|printf
argument_list|(
literal|" %02x "
argument_list|,
name|probe_signature
index|[
name|j
index|]
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n\n"
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
sizeof|sizeof
name|bt848_card_signature
operator|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|bt848_card_sig
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|card_found
operator|=
literal|1
expr_stmt|;
name|probe_temp
operator|=
operator|(
name|u_char
operator|*
operator|)
operator|&
name|bt848_card_signature
index|[
name|i
index|]
operator|.
name|signature
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|Bt848_MAX_SIGN
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|probe_temp
index|[
name|j
index|]
operator|&
literal|0xf
operator|)
operator|!=
operator|(
name|probe_signature
index|[
name|j
index|]
operator|&
literal|0xf
operator|)
condition|)
block|{
name|card_found
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|card_found
condition|)
block|{
name|bktr
operator|->
name|card
operator|=
name|cards
index|[
name|card
operator|=
name|bt848_card_signature
index|[
name|i
index|]
operator|.
name|card
index|]
expr_stmt|;
name|bktr
operator|->
name|card
operator|.
name|tuner
operator|=
operator|&
name|tuners
index|[
name|bt848_card_signature
index|[
name|i
index|]
operator|.
name|tuner
index|]
expr_stmt|;
name|eeprom_i2c_address
operator|=
name|locate_eeprom_address
argument_list|(
name|bktr
argument_list|)
expr_stmt|;
if|if
condition|(
name|eeprom_i2c_address
operator|!=
operator|-
literal|1
condition|)
block|{
name|bktr
operator|->
name|card
operator|.
name|eepromAddr
operator|=
name|eeprom_i2c_address
expr_stmt|;
name|bktr
operator|->
name|card
operator|.
name|eepromSize
operator|=
call|(
name|u_char
call|)
argument_list|(
literal|256
operator|/
name|EEPROMBLOCKSIZE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bktr
operator|->
name|card
operator|.
name|eepromAddr
operator|=
literal|0
expr_stmt|;
name|bktr
operator|->
name|card
operator|.
name|eepromSize
operator|=
literal|0
expr_stmt|;
block|}
goto|goto
name|checkDBX
goto|;
block|}
block|}
comment|/* We do not know the card type. Default to Miro */
name|bktr
operator|->
name|card
operator|=
name|cards
index|[
operator|(
name|card
operator|=
name|CARD_MIRO
operator|)
index|]
expr_stmt|;
name|checkEEPROM
label|:
comment|/* look for a configuration eeprom */
name|eeprom_i2c_address
operator|=
name|locate_eeprom_address
argument_list|(
name|bktr
argument_list|)
expr_stmt|;
if|if
condition|(
name|eeprom_i2c_address
operator|!=
operator|-
literal|1
condition|)
block|{
name|bktr
operator|->
name|card
operator|.
name|eepromAddr
operator|=
name|eeprom_i2c_address
expr_stmt|;
name|bktr
operator|->
name|card
operator|.
name|eepromSize
operator|=
call|(
name|u_char
call|)
argument_list|(
literal|256
operator|/
name|EEPROMBLOCKSIZE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bktr
operator|->
name|card
operator|.
name|eepromAddr
operator|=
literal|0
expr_stmt|;
name|bktr
operator|->
name|card
operator|.
name|eepromSize
operator|=
literal|0
expr_stmt|;
block|}
name|checkTuner
label|:
comment|/* look for a tuner */
name|tuner_i2c_address
operator|=
name|locate_tuner_address
argument_list|(
name|bktr
argument_list|)
expr_stmt|;
if|if
condition|(
name|tuner_i2c_address
operator|==
operator|-
literal|1
condition|)
block|{
name|bktr
operator|->
name|card
operator|.
name|tuner
operator|=
operator|&
name|tuners
index|[
name|NO_TUNER
index|]
expr_stmt|;
goto|goto
name|checkDBX
goto|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|OVERRIDE_TUNER
argument_list|)
name|bktr
operator|->
name|card
operator|.
name|tuner
operator|=
operator|&
name|tuners
index|[
name|OVERRIDE_TUNER
index|]
expr_stmt|;
goto|goto
name|checkDBX
goto|;
endif|#
directive|endif
if|if
condition|(
name|bktr
operator|->
name|bt848_tuner
operator|!=
operator|-
literal|1
condition|)
block|{
name|bktr
operator|->
name|card
operator|.
name|tuner
operator|=
operator|&
name|tuners
index|[
name|bktr
operator|->
name|bt848_tuner
operator|&
literal|0xff
index|]
expr_stmt|;
goto|goto
name|checkDBX
goto|;
block|}
comment|/* Check for i2c devices */
if|if
condition|(
operator|!
name|any_i2c_devices
condition|)
block|{
name|bktr
operator|->
name|card
operator|.
name|tuner
operator|=
operator|&
name|tuners
index|[
name|NO_TUNER
index|]
expr_stmt|;
goto|goto
name|checkDBX
goto|;
block|}
comment|/* differentiate type of tuner */
switch|switch
condition|(
name|card
condition|)
block|{
case|case
name|CARD_MIRO
case|:
switch|switch
condition|(
operator|(
operator|(
name|bt848
operator|->
name|gpio_data
operator|>>
literal|10
operator|)
operator|-
literal|1
operator|)
operator|&
literal|7
condition|)
block|{
case|case
literal|0
case|:
name|bktr
operator|->
name|card
operator|.
name|tuner
operator|=
operator|&
name|tuners
index|[
name|TEMIC_PAL
index|]
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|bktr
operator|->
name|card
operator|.
name|tuner
operator|=
operator|&
name|tuners
index|[
name|PHILIPS_PAL
index|]
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|bktr
operator|->
name|card
operator|.
name|tuner
operator|=
operator|&
name|tuners
index|[
name|PHILIPS_NTSC
index|]
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|bktr
operator|->
name|card
operator|.
name|tuner
operator|=
operator|&
name|tuners
index|[
name|PHILIPS_SECAM
index|]
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|bktr
operator|->
name|card
operator|.
name|tuner
operator|=
operator|&
name|tuners
index|[
name|NO_TUNER
index|]
expr_stmt|;
break|break;
case|case
literal|5
case|:
name|bktr
operator|->
name|card
operator|.
name|tuner
operator|=
operator|&
name|tuners
index|[
name|PHILIPS_PALI
index|]
expr_stmt|;
break|break;
case|case
literal|6
case|:
name|bktr
operator|->
name|card
operator|.
name|tuner
operator|=
operator|&
name|tuners
index|[
name|TEMIC_NTSC
index|]
expr_stmt|;
break|break;
case|case
literal|7
case|:
name|bktr
operator|->
name|card
operator|.
name|tuner
operator|=
operator|&
name|tuners
index|[
name|TEMIC_PALI
index|]
expr_stmt|;
break|break;
block|}
goto|goto
name|checkDBX
goto|;
break|break;
case|case
name|CARD_HAUPPAUGE
case|:
comment|/* Hauppauge kindly supplied the following Tuner Table */
comment|/* FIXME: I think the tuners the driver selects for types */
comment|/* 0x08 and 0x15 may be incorrect but no one has complained. */
comment|/*    	    	ID Tuner Model          Format         	We select Format 	   	 0 NONE                		 1 EXTERNAL              		 2 OTHER                 		 3 Philips FI1216       BG  		 4 Philips FI1216MF     BGLL'  		 5 Philips FI1236       MN 		PHILIPS_NTSC 		 6 Philips FI1246       I  		 7 Philips FI1256       DK  		 8 Philips FI1216 MK2   BG 		PHILIPS_PALI 		 9 Philips FI1216MF MK2 BGLL'  		 a Philips FI1236 MK2   MN 		PHILIPS_NTSC 		 b Philips FI1246 MK2   I 		PHILIPS_PALI 		 c Philips FI1256 MK2   DK  		 d Temic 4032FY5        NTSC		TEMIC_NTSC 		 e Temic 4002FH5        BG		TEMIC_PAL 		 f Temic 4062FY5        I 		TEMIC_PALI 		10 Philips FR1216 MK2   BG  		11 Philips FR1216MF MK2 BGLL'  		12 Philips FR1236 MK2   MN 		PHILIPS_FR1236_NTSC 		13 Philips FR1246 MK2   I  		14 Philips FR1256 MK2   DK  		15 Philips FM1216       BG 		PHILIPS_FR1216_PAL 		16 Philips FM1216MF     BGLL'  		17 Philips FM1236       MN 		PHILIPS_FR1236_NTSC 		18 Philips FM1246       I  		19 Philips FM1256       DK  		1a Temic 4036FY5        MN - FI1236 MK2 clone 		1b Samsung TCPN9082D    MN  		1c Samsung TCPM9092P    Pal BG/I/DK  		1d Temic 4006FH5        BG  		1e Samsung TCPN9085D    MN/Radio  		1f Samsung TCPB9085P    Pal BG/I/DK / Radio  		20 Samsung TCPL9091P    Pal BG& Secam L/L'  		21 Temic 4039FY5        NTSC Radio  	    */
name|readEEProm
argument_list|(
name|bktr
argument_list|,
literal|0
argument_list|,
literal|128
argument_list|,
operator|(
name|u_char
operator|*
operator|)
operator|&
name|eeprom
argument_list|)
expr_stmt|;
comment|/* Determine the model number from the eeprom */
block|{
name|u_int
name|model
decl_stmt|;
name|u_int
name|revision
decl_stmt|;
name|model
operator|=
operator|(
name|eeprom
index|[
literal|12
index|]
operator|<<
literal|8
operator||
name|eeprom
index|[
literal|11
index|]
operator|)
expr_stmt|;
name|revision
operator|=
operator|(
name|eeprom
index|[
literal|15
index|]
operator|<<
literal|16
operator||
name|eeprom
index|[
literal|14
index|]
operator|<<
literal|8
operator||
name|eeprom
index|[
literal|13
index|]
operator|)
expr_stmt|;
if|if
condition|(
name|verbose
condition|)
name|printf
argument_list|(
literal|"Hauppauge Model %d %c%c%c%c\n"
argument_list|,
name|model
argument_list|,
operator|(
operator|(
name|revision
operator|>>
literal|18
operator|)
operator|&
literal|0x3f
operator|)
operator|+
literal|32
argument_list|,
operator|(
operator|(
name|revision
operator|>>
literal|12
operator|)
operator|&
literal|0x3f
operator|)
operator|+
literal|32
argument_list|,
operator|(
operator|(
name|revision
operator|>>
literal|6
operator|)
operator|&
literal|0x3f
operator|)
operator|+
literal|32
argument_list|,
operator|(
operator|(
name|revision
operator|>>
literal|0
operator|)
operator|&
literal|0x3f
operator|)
operator|+
literal|32
argument_list|)
expr_stmt|;
block|}
comment|/* Determine the tuner type from the eeprom */
name|tuner_code
operator|=
name|eeprom
index|[
literal|9
index|]
expr_stmt|;
switch|switch
condition|(
name|tuner_code
condition|)
block|{
case|case
literal|0x5
case|:
case|case
literal|0x0a
case|:
case|case
literal|0x1a
case|:
name|bktr
operator|->
name|card
operator|.
name|tuner
operator|=
operator|&
name|tuners
index|[
name|PHILIPS_NTSC
index|]
expr_stmt|;
goto|goto
name|checkDBX
goto|;
case|case
literal|0x12
case|:
case|case
literal|0x17
case|:
name|bktr
operator|->
name|card
operator|.
name|tuner
operator|=
operator|&
name|tuners
index|[
name|PHILIPS_FR1236_NTSC
index|]
expr_stmt|;
goto|goto
name|checkDBX
goto|;
case|case
literal|0x8
case|:
case|case
literal|0xb
case|:
name|bktr
operator|->
name|card
operator|.
name|tuner
operator|=
operator|&
name|tuners
index|[
name|PHILIPS_PALI
index|]
expr_stmt|;
goto|goto
name|checkDBX
goto|;
case|case
literal|0xd
case|:
name|bktr
operator|->
name|card
operator|.
name|tuner
operator|=
operator|&
name|tuners
index|[
name|TEMIC_NTSC
index|]
expr_stmt|;
goto|goto
name|checkDBX
goto|;
case|case
literal|0xe
case|:
name|bktr
operator|->
name|card
operator|.
name|tuner
operator|=
operator|&
name|tuners
index|[
name|TEMIC_PAL
index|]
expr_stmt|;
goto|goto
name|checkDBX
goto|;
case|case
literal|0xf
case|:
name|bktr
operator|->
name|card
operator|.
name|tuner
operator|=
operator|&
name|tuners
index|[
name|TEMIC_PALI
index|]
expr_stmt|;
goto|goto
name|checkDBX
goto|;
case|case
literal|0x15
case|:
name|bktr
operator|->
name|card
operator|.
name|tuner
operator|=
operator|&
name|tuners
index|[
name|PHILIPS_FR1216_PAL
index|]
expr_stmt|;
goto|goto
name|checkDBX
goto|;
default|default :
name|printf
argument_list|(
literal|"Warning - Unknown Hauppauge Tuner 0x%x\n"
argument_list|,
name|tuner_code
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
comment|/* end switch(card) */
comment|/* At this point, a goto checkDBX has not occured */
comment|/* We have not been able to select a Tuner */
comment|/* Some cards make use of the tuner address to */
comment|/* identify the make/model of tuner */
comment|/* At address 0xc0/0xc1 we often find a TEMIC NTSC */
if|if
condition|(
name|i2cRead
argument_list|(
name|bktr
argument_list|,
literal|0xc1
argument_list|)
operator|!=
name|ABSENT
condition|)
block|{
name|bktr
operator|->
name|card
operator|.
name|tuner
operator|=
operator|&
name|tuners
index|[
name|TEMIC_NTSC
index|]
expr_stmt|;
goto|goto
name|checkDBX
goto|;
block|}
comment|/* At address 0xc6/0xc7 we often find a PHILIPS NTSC Tuner */
if|if
condition|(
name|i2cRead
argument_list|(
name|bktr
argument_list|,
literal|0xc7
argument_list|)
operator|!=
name|ABSENT
condition|)
block|{
name|bktr
operator|->
name|card
operator|.
name|tuner
operator|=
operator|&
name|tuners
index|[
name|PHILIPS_NTSC
index|]
expr_stmt|;
goto|goto
name|checkDBX
goto|;
block|}
comment|/* Address 0xc2/0xc3 is default (or common address) for several */
comment|/* tuners and we cannot tell which is which. */
comment|/* And for all other tuner i2c addresses, select the default */
name|bktr
operator|->
name|card
operator|.
name|tuner
operator|=
operator|&
name|tuners
index|[
name|DEFAULT_TUNER
index|]
expr_stmt|;
name|checkDBX
label|:
if|#
directive|if
name|defined
argument_list|(
name|OVERRIDE_DBX
argument_list|)
name|bktr
operator|->
name|card
operator|.
name|dbx
operator|=
name|OVERRIDE_DBX
expr_stmt|;
goto|goto
name|checkMSP
goto|;
endif|#
directive|endif
comment|/* Check for i2c devices */
if|if
condition|(
operator|!
name|any_i2c_devices
condition|)
block|{
goto|goto
name|checkMSP
goto|;
block|}
comment|/* probe for BTSC (dbx) chip */
if|if
condition|(
name|i2cRead
argument_list|(
name|bktr
argument_list|,
name|TDA9850_RADDR
argument_list|)
operator|!=
name|ABSENT
condition|)
name|bktr
operator|->
name|card
operator|.
name|dbx
operator|=
literal|1
expr_stmt|;
name|checkMSP
label|:
comment|/* If this is a Hauppauge Bt878 card, we need to enable the 	 * MSP 34xx audio chip.  	 * If this is a Hauppauge Bt848 card, reset the MSP device. 	 * The MSP reset line is wired to GPIO pin 5. On Bt878 cards a pulldown 	 * resistor holds the device in reset until we set GPIO pin 5.          */
comment|/* Optionally skip the MSP reset. This is handy if you initialise the 	 * MSP audio in another operating system (eg Windows) first and then 	 * do a soft reboot. 	 */
ifndef|#
directive|ifndef
name|BKTR_NO_MSP_RESET
if|if
condition|(
name|card
operator|==
name|CARD_HAUPPAUGE
condition|)
block|{
name|bt848
operator|->
name|gpio_out_en
operator|=
name|bt848
operator|->
name|gpio_out_en
operator||
operator|(
literal|1
operator|<<
literal|5
operator|)
expr_stmt|;
name|bt848
operator|->
name|gpio_data
operator|=
name|bt848
operator|->
name|gpio_data
operator||
operator|(
literal|1
operator|<<
literal|5
operator|)
expr_stmt|;
comment|/* write '1' */
name|DELAY
argument_list|(
literal|2500
argument_list|)
expr_stmt|;
comment|/* wait 2.5ms */
name|bt848
operator|->
name|gpio_data
operator|=
name|bt848
operator|->
name|gpio_data
operator|&
operator|~
operator|(
literal|1
operator|<<
literal|5
operator|)
expr_stmt|;
comment|/* write '0' */
name|DELAY
argument_list|(
literal|2500
argument_list|)
expr_stmt|;
comment|/* wait 2.5ms */
name|bt848
operator|->
name|gpio_data
operator|=
name|bt848
operator|->
name|gpio_data
operator||
operator|(
literal|1
operator|<<
literal|5
operator|)
expr_stmt|;
comment|/* write '1' */
name|DELAY
argument_list|(
literal|2500
argument_list|)
expr_stmt|;
comment|/* wait 2.5ms */
block|}
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|OVERRIDE_MSP
argument_list|)
name|bktr
operator|->
name|card
operator|.
name|msp3400c
operator|=
name|OVERRIDE_MSP
expr_stmt|;
goto|goto
name|checkMSPEnd
goto|;
endif|#
directive|endif
comment|/* Check for i2c devices */
if|if
condition|(
operator|!
name|any_i2c_devices
condition|)
block|{
goto|goto
name|checkMSPEnd
goto|;
block|}
if|if
condition|(
name|i2cRead
argument_list|(
name|bktr
argument_list|,
name|MSP3400C_RADDR
argument_list|)
operator|!=
name|ABSENT
condition|)
name|bktr
operator|->
name|card
operator|.
name|msp3400c
operator|=
literal|1
expr_stmt|;
name|checkMSPEnd
label|:
comment|/* Start of Check Remote */
comment|/* Check for the Hauppauge IR Remote Control */
comment|/* If there is an external unit, the internal will be ignored */
name|bktr
operator|->
name|remote_control
operator|=
literal|0
expr_stmt|;
comment|/* initial value */
if|if
condition|(
name|any_i2c_devices
condition|)
block|{
if|if
condition|(
name|i2cRead
argument_list|(
name|bktr
argument_list|,
name|HAUP_REMOTE_EXT_RADDR
argument_list|)
operator|!=
name|ABSENT
condition|)
block|{
name|bktr
operator|->
name|remote_control
operator|=
literal|1
expr_stmt|;
name|bktr
operator|->
name|remote_control_addr
operator|=
name|HAUP_REMOTE_EXT_RADDR
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|i2cRead
argument_list|(
name|bktr
argument_list|,
name|HAUP_REMOTE_INT_RADDR
argument_list|)
operator|!=
name|ABSENT
condition|)
block|{
name|bktr
operator|->
name|remote_control
operator|=
literal|1
expr_stmt|;
name|bktr
operator|->
name|remote_control_addr
operator|=
name|HAUP_REMOTE_INT_RADDR
expr_stmt|;
block|}
block|}
comment|/* If a remote control is found, poll it 5 times to turn off the LED */
if|if
condition|(
name|bktr
operator|->
name|remote_control
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|5
condition|;
name|i
operator|++
control|)
name|i2cRead
argument_list|(
name|bktr
argument_list|,
name|bktr
operator|->
name|remote_control_addr
argument_list|)
expr_stmt|;
block|}
comment|/* End of Check Remote */
if|#
directive|if
name|defined
argument_list|(
name|BKTR_USE_PLL
argument_list|)
name|bktr
operator|->
name|xtal_pll_mode
operator|=
name|BT848_USE_PLL
expr_stmt|;
goto|goto
name|checkPLLEnd
goto|;
endif|#
directive|endif
comment|/* Default is to use XTALS and not PLL mode */
name|bktr
operator|->
name|xtal_pll_mode
operator|=
name|BT848_USE_XTALS
expr_stmt|;
comment|/* Enable PLL mode for PAL/SECAM users on Hauppauge 878 cards */
if|if
condition|(
operator|(
name|card
operator|==
name|CARD_HAUPPAUGE
operator|)
operator|&&
operator|(
name|bktr
operator|->
name|id
operator|==
name|BROOKTREE_878
operator|||
name|bktr
operator|->
name|id
operator|==
name|BROOKTREE_879
operator|)
condition|)
name|bktr
operator|->
name|xtal_pll_mode
operator|=
name|BT848_USE_PLL
expr_stmt|;
comment|/* Enable PLL mode for OSPREY users */
if|if
condition|(
name|card
operator|==
name|CARD_OSPREY
condition|)
name|bktr
operator|->
name|xtal_pll_mode
operator|=
name|BT848_USE_PLL
expr_stmt|;
comment|/* Enable PLL mode for PAL/SECAM users on FlyVideo 878 cards */
if|if
condition|(
operator|(
name|card
operator|==
name|CARD_FLYVIDEO
operator|)
operator|&&
operator|(
name|bktr
operator|->
name|id
operator|==
name|BROOKTREE_878
operator|||
name|bktr
operator|->
name|id
operator|==
name|BROOKTREE_879
operator|)
condition|)
name|bktr
operator|->
name|xtal_pll_mode
operator|=
name|BT848_USE_PLL
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|BKTR_USE_PLL
argument_list|)
name|checkPLLEnd
label|:
endif|#
directive|endif
name|bktr
operator|->
name|card
operator|.
name|tuner_pllAddr
operator|=
name|tuner_i2c_address
expr_stmt|;
if|if
condition|(
name|verbose
condition|)
block|{
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|bktr
operator|->
name|card
operator|.
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|bktr
operator|->
name|card
operator|.
name|tuner
condition|)
name|printf
argument_list|(
literal|", %s tuner"
argument_list|,
name|bktr
operator|->
name|card
operator|.
name|tuner
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|bktr
operator|->
name|card
operator|.
name|dbx
condition|)
name|printf
argument_list|(
literal|", dbx stereo"
argument_list|)
expr_stmt|;
if|if
condition|(
name|bktr
operator|->
name|card
operator|.
name|msp3400c
condition|)
name|printf
argument_list|(
literal|", msp3400c stereo"
argument_list|)
expr_stmt|;
if|if
condition|(
name|bktr
operator|->
name|remote_control
condition|)
name|printf
argument_list|(
literal|", remote control"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|".\n"
argument_list|)
expr_stmt|;
block|}
block|}
undef|#
directive|undef
name|ABSENT
comment|/******************************************************************************  * tuner specific routines:  */
comment|/* scaling factor for frequencies expressed as ints */
define|#
directive|define
name|FREQFACTOR
value|16
comment|/*  * Format:  *	entry 0:         MAX legal channel  *	entry 1:         IF frequency  *			 expressed as fi{mHz} * 16,  *			 eg 45.75mHz == 45.75 * 16 = 732  *	entry 2:         [place holder/future]  *	entry 3:         base of channel record 0  *	entry 3 + (x*3): base of channel record 'x'  *	entry LAST:      NULL channel entry marking end of records  *  * Record:  *	int 0:		base channel  *	int 1:		frequency of base channel,  *			 expressed as fb{mHz} * 16,  *	int 2:		offset frequency between channels,  *			 expressed as fo{mHz} * 16,  */
comment|/*  * North American Broadcast Channels:  *  *  2:  55.25 mHz -  4:  67.25 mHz  *  5:  77.25 mHz -  6:	 83.25 mHz  *  7: 175.25 mHz - 13:	211.25 mHz  * 14: 471.25 mHz - 83:	885.25 mHz  *  * IF freq: 45.75 mHz  */
define|#
directive|define
name|OFFSET
value|6.00
specifier|static
name|int
name|nabcst
index|[]
init|=
block|{
literal|83
block|,
call|(
name|int
call|)
argument_list|(
literal|45.75
operator|*
name|FREQFACTOR
argument_list|)
block|,
literal|0
block|,
literal|14
block|,
call|(
name|int
call|)
argument_list|(
literal|471.25
operator|*
name|FREQFACTOR
argument_list|)
block|,
call|(
name|int
call|)
argument_list|(
name|OFFSET
operator|*
name|FREQFACTOR
argument_list|)
block|,
literal|7
block|,
call|(
name|int
call|)
argument_list|(
literal|175.25
operator|*
name|FREQFACTOR
argument_list|)
block|,
call|(
name|int
call|)
argument_list|(
name|OFFSET
operator|*
name|FREQFACTOR
argument_list|)
block|,
literal|5
block|,
call|(
name|int
call|)
argument_list|(
literal|77.25
operator|*
name|FREQFACTOR
argument_list|)
block|,
call|(
name|int
call|)
argument_list|(
name|OFFSET
operator|*
name|FREQFACTOR
argument_list|)
block|,
literal|2
block|,
call|(
name|int
call|)
argument_list|(
literal|55.25
operator|*
name|FREQFACTOR
argument_list|)
block|,
call|(
name|int
call|)
argument_list|(
name|OFFSET
operator|*
name|FREQFACTOR
argument_list|)
block|,
literal|0
block|}
decl_stmt|;
undef|#
directive|undef
name|OFFSET
comment|/*  * North American Cable Channels, IRC:  *  *  2:  55.25 mHz -  4:  67.25 mHz  *  5:  77.25 mHz -  6:  83.25 mHz  *  7: 175.25 mHz - 13: 211.25 mHz  * 14: 121.25 mHz - 22: 169.25 mHz  * 23: 217.25 mHz - 94: 643.25 mHz  * 95:  91.25 mHz - 99: 115.25 mHz  *  * IF freq: 45.75 mHz  */
define|#
directive|define
name|OFFSET
value|6.00
specifier|static
name|int
name|irccable
index|[]
init|=
block|{
literal|99
block|,
call|(
name|int
call|)
argument_list|(
literal|45.75
operator|*
name|FREQFACTOR
argument_list|)
block|,
literal|0
block|,
literal|95
block|,
call|(
name|int
call|)
argument_list|(
literal|91.25
operator|*
name|FREQFACTOR
argument_list|)
block|,
call|(
name|int
call|)
argument_list|(
name|OFFSET
operator|*
name|FREQFACTOR
argument_list|)
block|,
literal|23
block|,
call|(
name|int
call|)
argument_list|(
literal|217.25
operator|*
name|FREQFACTOR
argument_list|)
block|,
call|(
name|int
call|)
argument_list|(
name|OFFSET
operator|*
name|FREQFACTOR
argument_list|)
block|,
literal|14
block|,
call|(
name|int
call|)
argument_list|(
literal|121.25
operator|*
name|FREQFACTOR
argument_list|)
block|,
call|(
name|int
call|)
argument_list|(
name|OFFSET
operator|*
name|FREQFACTOR
argument_list|)
block|,
literal|7
block|,
call|(
name|int
call|)
argument_list|(
literal|175.25
operator|*
name|FREQFACTOR
argument_list|)
block|,
call|(
name|int
call|)
argument_list|(
name|OFFSET
operator|*
name|FREQFACTOR
argument_list|)
block|,
literal|5
block|,
call|(
name|int
call|)
argument_list|(
literal|77.25
operator|*
name|FREQFACTOR
argument_list|)
block|,
call|(
name|int
call|)
argument_list|(
name|OFFSET
operator|*
name|FREQFACTOR
argument_list|)
block|,
literal|2
block|,
call|(
name|int
call|)
argument_list|(
literal|55.25
operator|*
name|FREQFACTOR
argument_list|)
block|,
call|(
name|int
call|)
argument_list|(
name|OFFSET
operator|*
name|FREQFACTOR
argument_list|)
block|,
literal|0
block|}
decl_stmt|;
undef|#
directive|undef
name|OFFSET
comment|/*  * North American Cable Channels, HRC:  *  * 2:   54 mHz  - 4:    66 mHz  * 5:   78 mHz  - 6:    84 mHz  * 7:  174 mHz  - 13:  210 mHz  * 14: 120 mHz  - 22:  168 mHz  * 23: 216 mHz  - 94:  642 mHz  * 95:  90 mHz  - 99:  114 mHz  *  * IF freq: 45.75 mHz  */
define|#
directive|define
name|OFFSET
value|6.00
specifier|static
name|int
name|hrccable
index|[]
init|=
block|{
literal|99
block|,
call|(
name|int
call|)
argument_list|(
literal|45.75
operator|*
name|FREQFACTOR
argument_list|)
block|,
literal|0
block|,
literal|95
block|,
call|(
name|int
call|)
argument_list|(
literal|90.00
operator|*
name|FREQFACTOR
argument_list|)
block|,
call|(
name|int
call|)
argument_list|(
name|OFFSET
operator|*
name|FREQFACTOR
argument_list|)
block|,
literal|23
block|,
call|(
name|int
call|)
argument_list|(
literal|216.00
operator|*
name|FREQFACTOR
argument_list|)
block|,
call|(
name|int
call|)
argument_list|(
name|OFFSET
operator|*
name|FREQFACTOR
argument_list|)
block|,
literal|14
block|,
call|(
name|int
call|)
argument_list|(
literal|120.00
operator|*
name|FREQFACTOR
argument_list|)
block|,
call|(
name|int
call|)
argument_list|(
name|OFFSET
operator|*
name|FREQFACTOR
argument_list|)
block|,
literal|7
block|,
call|(
name|int
call|)
argument_list|(
literal|174.00
operator|*
name|FREQFACTOR
argument_list|)
block|,
call|(
name|int
call|)
argument_list|(
name|OFFSET
operator|*
name|FREQFACTOR
argument_list|)
block|,
literal|5
block|,
call|(
name|int
call|)
argument_list|(
literal|78.00
operator|*
name|FREQFACTOR
argument_list|)
block|,
call|(
name|int
call|)
argument_list|(
name|OFFSET
operator|*
name|FREQFACTOR
argument_list|)
block|,
literal|2
block|,
call|(
name|int
call|)
argument_list|(
literal|54.00
operator|*
name|FREQFACTOR
argument_list|)
block|,
call|(
name|int
call|)
argument_list|(
name|OFFSET
operator|*
name|FREQFACTOR
argument_list|)
block|,
literal|0
block|}
decl_stmt|;
undef|#
directive|undef
name|OFFSET
comment|/*  * Western European broadcast channels:  *  * (there are others that appear to vary between countries - rmt)  *  * here's the table Philips provides:  * caution, some of the offsets don't compute...  *  *  1	 4525	700	N21  *   *  2	 4825	700	E2  *  3	 5525	700	E3  *  4	 6225	700	E4  *   *  5	17525	700	E5  *  6	18225	700	E6  *  7	18925	700	E7  *  8	19625	700	E8  *  9	20325	700	E9  * 10	21025	700	E10  * 11	21725	700	E11  * 12	22425	700	E12  *   * 13	 5375	700	ITA  * 14	 6225	700	ITB  *   * 15	 8225	700	ITC  *   * 16	17525	700	ITD  * 17	18325	700	ITE  *   * 18	19225	700	ITF  * 19	20125	700	ITG  * 20	21025	700	ITH  *   * 21	47125	800	E21  * 22	47925	800	E22  * 23	48725	800	E23  * 24	49525	800	E24  * 25	50325	800	E25  * 26	51125	800	E26  * 27	51925	800	E27  * 28	52725	800	E28  * 29	53525	800	E29  * 30	54325	800	E30  * 31	55125	800	E31  * 32	55925	800	E32  * 33	56725	800	E33  * 34	57525	800	E34  * 35	58325	800	E35  * 36	59125	800	E36  * 37	59925	800	E37  * 38	60725	800	E38  * 39	61525	800	E39  * 40	62325	800	E40  * 41	63125	800	E41  * 42	63925	800	E42  * 43	64725	800	E43  * 44	65525	800	E44  * 45	66325	800	E45  * 46	67125	800	E46  * 47	67925	800	E47  * 48	68725	800	E48  * 49	69525	800	E49  * 50	70325	800	E50  * 51	71125	800	E51  * 52	71925	800	E52  * 53	72725	800	E53  * 54	73525	800	E54  * 55	74325	800	E55  * 56	75125	800	E56  * 57	75925	800	E57  * 58	76725	800	E58  * 59	77525	800	E59  * 60	78325	800	E60  * 61	79125	800	E61  * 62	79925	800	E62  * 63	80725	800	E63  * 64	81525	800	E64  * 65	82325	800	E65  * 66	83125	800	E66  * 67	83925	800	E67  * 68	84725	800	E68  * 69	85525	800	E69  *   * 70	 4575	800	IA  * 71	 5375	800	IB  * 72	 6175	800	IC  *   * 74	 6925	700	S01  * 75	 7625	700	S02  * 76	 8325	700	S03  *   * 80	10525	700	S1  * 81	11225	700	S2  * 82	11925	700	S3  * 83	12625	700	S4  * 84	13325	700	S5  * 85	14025	700	S6  * 86	14725	700	S7  * 87	15425	700	S8  * 88	16125	700	S9  * 89	16825	700	S10  * 90	23125	700	S11  * 91	23825	700	S12  * 92	24525	700	S13  * 93	25225	700	S14  * 94	25925	700	S15  * 95	26625	700	S16  * 96	27325	700	S17  * 97	28025	700	S18  * 98	28725	700	S19  * 99	29425	700	S20  *  *  * Channels S21 - S41 are taken from  * http://gemma.apple.com:80/dev/technotes/tn/tn1012.html  *  * 100	30325	800	S21  * 101	31125	800	S22  * 102	31925	800	S23  * 103	32725	800	S24  * 104	33525	800	S25  * 105	34325	800	S26           * 106	35125	800	S27           * 107	35925	800	S28           * 108	36725	800	S29           * 109	37525	800	S30           * 110	38325	800	S31           * 111	39125	800	S32           * 112	39925	800	S33           * 113	40725	800	S34           * 114	41525	800	S35           * 115	42325	800	S36           * 116	43125	800	S37           * 117	43925	800	S38           * 118	44725	800	S39           * 119	45525	800	S40           * 120	46325	800	S41  *   * 121	 3890	000	IFFREQ  *   */
specifier|static
name|int
name|weurope
index|[]
init|=
block|{
literal|121
block|,
call|(
name|int
call|)
argument_list|(
literal|38.90
operator|*
name|FREQFACTOR
argument_list|)
block|,
literal|0
block|,
literal|100
block|,
call|(
name|int
call|)
argument_list|(
literal|303.25
operator|*
name|FREQFACTOR
argument_list|)
block|,
call|(
name|int
call|)
argument_list|(
literal|8.00
operator|*
name|FREQFACTOR
argument_list|)
block|,
literal|90
block|,
call|(
name|int
call|)
argument_list|(
literal|231.25
operator|*
name|FREQFACTOR
argument_list|)
block|,
call|(
name|int
call|)
argument_list|(
literal|7.00
operator|*
name|FREQFACTOR
argument_list|)
block|,
literal|80
block|,
call|(
name|int
call|)
argument_list|(
literal|105.25
operator|*
name|FREQFACTOR
argument_list|)
block|,
call|(
name|int
call|)
argument_list|(
literal|7.00
operator|*
name|FREQFACTOR
argument_list|)
block|,
literal|74
block|,
call|(
name|int
call|)
argument_list|(
literal|69.25
operator|*
name|FREQFACTOR
argument_list|)
block|,
call|(
name|int
call|)
argument_list|(
literal|7.00
operator|*
name|FREQFACTOR
argument_list|)
block|,
literal|21
block|,
call|(
name|int
call|)
argument_list|(
literal|471.25
operator|*
name|FREQFACTOR
argument_list|)
block|,
call|(
name|int
call|)
argument_list|(
literal|8.00
operator|*
name|FREQFACTOR
argument_list|)
block|,
literal|17
block|,
call|(
name|int
call|)
argument_list|(
literal|183.25
operator|*
name|FREQFACTOR
argument_list|)
block|,
call|(
name|int
call|)
argument_list|(
literal|9.00
operator|*
name|FREQFACTOR
argument_list|)
block|,
literal|16
block|,
call|(
name|int
call|)
argument_list|(
literal|175.25
operator|*
name|FREQFACTOR
argument_list|)
block|,
call|(
name|int
call|)
argument_list|(
literal|9.00
operator|*
name|FREQFACTOR
argument_list|)
block|,
literal|15
block|,
call|(
name|int
call|)
argument_list|(
literal|82.25
operator|*
name|FREQFACTOR
argument_list|)
block|,
call|(
name|int
call|)
argument_list|(
literal|8.50
operator|*
name|FREQFACTOR
argument_list|)
block|,
literal|13
block|,
call|(
name|int
call|)
argument_list|(
literal|53.75
operator|*
name|FREQFACTOR
argument_list|)
block|,
call|(
name|int
call|)
argument_list|(
literal|8.50
operator|*
name|FREQFACTOR
argument_list|)
block|,
literal|5
block|,
call|(
name|int
call|)
argument_list|(
literal|175.25
operator|*
name|FREQFACTOR
argument_list|)
block|,
call|(
name|int
call|)
argument_list|(
literal|7.00
operator|*
name|FREQFACTOR
argument_list|)
block|,
literal|2
block|,
call|(
name|int
call|)
argument_list|(
literal|48.25
operator|*
name|FREQFACTOR
argument_list|)
block|,
call|(
name|int
call|)
argument_list|(
literal|7.00
operator|*
name|FREQFACTOR
argument_list|)
block|,
literal|0
block|}
decl_stmt|;
comment|/*  * Japanese Broadcast Channels:  *  *  1:  91.25MHz -  3: 103.25MHz  *  4: 171.25MHz -  7: 189.25MHz  *  8: 193.25MHz - 12: 217.25MHz  (VHF)  * 13: 471.25MHz - 62: 765.25MHz  (UHF)  *  * IF freq: 45.75 mHz  *  OR  * IF freq: 58.75 mHz  */
define|#
directive|define
name|OFFSET
value|6.00
define|#
directive|define
name|IF_FREQ
value|45.75
specifier|static
name|int
name|jpnbcst
index|[]
init|=
block|{
literal|62
block|,
call|(
name|int
call|)
argument_list|(
name|IF_FREQ
operator|*
name|FREQFACTOR
argument_list|)
block|,
literal|0
block|,
literal|13
block|,
call|(
name|int
call|)
argument_list|(
literal|471.25
operator|*
name|FREQFACTOR
argument_list|)
block|,
call|(
name|int
call|)
argument_list|(
name|OFFSET
operator|*
name|FREQFACTOR
argument_list|)
block|,
literal|8
block|,
call|(
name|int
call|)
argument_list|(
literal|193.25
operator|*
name|FREQFACTOR
argument_list|)
block|,
call|(
name|int
call|)
argument_list|(
name|OFFSET
operator|*
name|FREQFACTOR
argument_list|)
block|,
literal|4
block|,
call|(
name|int
call|)
argument_list|(
literal|171.25
operator|*
name|FREQFACTOR
argument_list|)
block|,
call|(
name|int
call|)
argument_list|(
name|OFFSET
operator|*
name|FREQFACTOR
argument_list|)
block|,
literal|1
block|,
call|(
name|int
call|)
argument_list|(
literal|91.25
operator|*
name|FREQFACTOR
argument_list|)
block|,
call|(
name|int
call|)
argument_list|(
name|OFFSET
operator|*
name|FREQFACTOR
argument_list|)
block|,
literal|0
block|}
decl_stmt|;
undef|#
directive|undef
name|IF_FREQ
undef|#
directive|undef
name|OFFSET
comment|/*  * Japanese Cable Channels:  *  *  1:  91.25MHz -  3: 103.25MHz  *  4: 171.25MHz -  7: 189.25MHz  *  8: 193.25MHz - 12: 217.25MHz  * 13: 109.25MHz - 21: 157.25MHz  * 22: 165.25MHz  * 23: 223.25MHz - 63: 463.25MHz  *  * IF freq: 45.75 mHz  */
define|#
directive|define
name|OFFSET
value|6.00
define|#
directive|define
name|IF_FREQ
value|45.75
specifier|static
name|int
name|jpncable
index|[]
init|=
block|{
literal|63
block|,
call|(
name|int
call|)
argument_list|(
name|IF_FREQ
operator|*
name|FREQFACTOR
argument_list|)
block|,
literal|0
block|,
literal|23
block|,
call|(
name|int
call|)
argument_list|(
literal|223.25
operator|*
name|FREQFACTOR
argument_list|)
block|,
call|(
name|int
call|)
argument_list|(
name|OFFSET
operator|*
name|FREQFACTOR
argument_list|)
block|,
literal|22
block|,
call|(
name|int
call|)
argument_list|(
literal|165.25
operator|*
name|FREQFACTOR
argument_list|)
block|,
call|(
name|int
call|)
argument_list|(
name|OFFSET
operator|*
name|FREQFACTOR
argument_list|)
block|,
literal|13
block|,
call|(
name|int
call|)
argument_list|(
literal|109.25
operator|*
name|FREQFACTOR
argument_list|)
block|,
call|(
name|int
call|)
argument_list|(
name|OFFSET
operator|*
name|FREQFACTOR
argument_list|)
block|,
literal|8
block|,
call|(
name|int
call|)
argument_list|(
literal|193.25
operator|*
name|FREQFACTOR
argument_list|)
block|,
call|(
name|int
call|)
argument_list|(
name|OFFSET
operator|*
name|FREQFACTOR
argument_list|)
block|,
literal|4
block|,
call|(
name|int
call|)
argument_list|(
literal|171.25
operator|*
name|FREQFACTOR
argument_list|)
block|,
call|(
name|int
call|)
argument_list|(
name|OFFSET
operator|*
name|FREQFACTOR
argument_list|)
block|,
literal|1
block|,
call|(
name|int
call|)
argument_list|(
literal|91.25
operator|*
name|FREQFACTOR
argument_list|)
block|,
call|(
name|int
call|)
argument_list|(
name|OFFSET
operator|*
name|FREQFACTOR
argument_list|)
block|,
literal|0
block|}
decl_stmt|;
undef|#
directive|undef
name|IF_FREQ
undef|#
directive|undef
name|OFFSET
comment|/*  * xUSSR Broadcast Channels:  *  *  1:  49.75MHz -  2:  59.25MHz  *  3:  77.25MHz -  5:  93.25MHz  *  6: 175.25MHz - 12: 223.25MHz  * 13-20 - not exist  * 21: 471.25MHz - 34: 575.25MHz  * 35: 583.25MHz - 69: 855.25MHz  *  * Cable channels  *  * 70: 111.25MHz - 77: 167.25MHz  * 78: 231.25MHz -107: 463.25MHz  *  * IF freq: 38.90 MHz  */
define|#
directive|define
name|IF_FREQ
value|38.90
specifier|static
name|int
name|xussr
index|[]
init|=
block|{
literal|107
block|,
call|(
name|int
call|)
argument_list|(
name|IF_FREQ
operator|*
name|FREQFACTOR
argument_list|)
block|,
literal|0
block|,
literal|78
block|,
call|(
name|int
call|)
argument_list|(
literal|231.25
operator|*
name|FREQFACTOR
argument_list|)
block|,
call|(
name|int
call|)
argument_list|(
literal|8.00
operator|*
name|FREQFACTOR
argument_list|)
block|,
literal|70
block|,
call|(
name|int
call|)
argument_list|(
literal|111.25
operator|*
name|FREQFACTOR
argument_list|)
block|,
call|(
name|int
call|)
argument_list|(
literal|8.00
operator|*
name|FREQFACTOR
argument_list|)
block|,
literal|35
block|,
call|(
name|int
call|)
argument_list|(
literal|583.25
operator|*
name|FREQFACTOR
argument_list|)
block|,
call|(
name|int
call|)
argument_list|(
literal|8.00
operator|*
name|FREQFACTOR
argument_list|)
block|,
literal|21
block|,
call|(
name|int
call|)
argument_list|(
literal|471.25
operator|*
name|FREQFACTOR
argument_list|)
block|,
call|(
name|int
call|)
argument_list|(
literal|8.00
operator|*
name|FREQFACTOR
argument_list|)
block|,
literal|6
block|,
call|(
name|int
call|)
argument_list|(
literal|175.25
operator|*
name|FREQFACTOR
argument_list|)
block|,
call|(
name|int
call|)
argument_list|(
literal|8.00
operator|*
name|FREQFACTOR
argument_list|)
block|,
literal|3
block|,
call|(
name|int
call|)
argument_list|(
literal|77.25
operator|*
name|FREQFACTOR
argument_list|)
block|,
call|(
name|int
call|)
argument_list|(
literal|8.00
operator|*
name|FREQFACTOR
argument_list|)
block|,
literal|1
block|,
call|(
name|int
call|)
argument_list|(
literal|49.75
operator|*
name|FREQFACTOR
argument_list|)
block|,
call|(
name|int
call|)
argument_list|(
literal|9.50
operator|*
name|FREQFACTOR
argument_list|)
block|,
literal|0
block|}
decl_stmt|;
undef|#
directive|undef
name|IF_FREQ
comment|/*  * Australian broadcast channels  */
define|#
directive|define
name|OFFSET
value|7.00
specifier|static
name|int
name|australia
index|[]
init|=
block|{
literal|83
block|,
call|(
name|int
call|)
argument_list|(
literal|45.00
operator|*
name|FREQFACTOR
argument_list|)
block|,
literal|0
block|,
literal|28
block|,
call|(
name|int
call|)
argument_list|(
literal|520.00
operator|*
name|FREQFACTOR
argument_list|)
block|,
call|(
name|int
call|)
argument_list|(
name|OFFSET
operator|*
name|FREQFACTOR
argument_list|)
block|,
literal|14
block|,
call|(
name|int
call|)
argument_list|(
literal|471.25
operator|*
name|FREQFACTOR
argument_list|)
block|,
call|(
name|int
call|)
argument_list|(
name|OFFSET
operator|*
name|FREQFACTOR
argument_list|)
block|,
literal|11
block|,
call|(
name|int
call|)
argument_list|(
literal|214.50
operator|*
name|FREQFACTOR
argument_list|)
block|,
call|(
name|int
call|)
argument_list|(
name|OFFSET
operator|*
name|FREQFACTOR
argument_list|)
block|,
literal|10
block|,
call|(
name|int
call|)
argument_list|(
literal|201.50
operator|*
name|FREQFACTOR
argument_list|)
block|,
call|(
name|int
call|)
argument_list|(
literal|13.00
operator|*
name|FREQFACTOR
argument_list|)
block|,
literal|7
block|,
call|(
name|int
call|)
argument_list|(
literal|174.00
operator|*
name|FREQFACTOR
argument_list|)
block|,
call|(
name|int
call|)
argument_list|(
name|OFFSET
operator|*
name|FREQFACTOR
argument_list|)
block|,
literal|3
block|,
call|(
name|int
call|)
argument_list|(
literal|85.00
operator|*
name|FREQFACTOR
argument_list|)
block|,
call|(
name|int
call|)
argument_list|(
name|OFFSET
operator|*
name|FREQFACTOR
argument_list|)
block|,
literal|2
block|,
call|(
name|int
call|)
argument_list|(
literal|56.00
operator|*
name|FREQFACTOR
argument_list|)
block|,
call|(
name|int
call|)
argument_list|(
name|OFFSET
operator|*
name|FREQFACTOR
argument_list|)
block|,
literal|0
block|}
decl_stmt|;
undef|#
directive|undef
name|OFFSET
specifier|static
struct|struct
block|{
name|int
modifier|*
name|ptr
decl_stmt|;
name|char
name|name
index|[
name|BT848_MAX_CHNLSET_NAME_LEN
index|]
decl_stmt|;
block|}
name|freqTable
index|[]
init|=
block|{
block|{
name|NULL
block|,
literal|""
block|}
block|,
block|{
name|nabcst
block|,
literal|"nabcst"
block|}
block|,
block|{
name|irccable
block|,
literal|"cableirc"
block|}
block|,
block|{
name|hrccable
block|,
literal|"cablehrc"
block|}
block|,
block|{
name|weurope
block|,
literal|"weurope"
block|}
block|,
block|{
name|jpnbcst
block|,
literal|"jpnbcst"
block|}
block|,
block|{
name|jpncable
block|,
literal|"jpncable"
block|}
block|,
block|{
name|xussr
block|,
literal|"xussr"
block|}
block|,
block|{
name|australia
block|,
literal|"australia"
block|}
block|,   }
struct|;
define|#
directive|define
name|TBL_CHNL
value|freqTable[ bktr->tuner.chnlset ].ptr[ x ]
define|#
directive|define
name|TBL_BASE_FREQ
value|freqTable[ bktr->tuner.chnlset ].ptr[ x + 1 ]
define|#
directive|define
name|TBL_OFFSET
value|freqTable[ bktr->tuner.chnlset ].ptr[ x + 2 ]
specifier|static
name|int
name|frequency_lookup
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|,
name|int
name|channel
parameter_list|)
block|{
name|int
name|x
decl_stmt|;
comment|/* check for "> MAX channel" */
name|x
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|channel
operator|>
name|TBL_CHNL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* search the table for data */
for|for
control|(
name|x
operator|=
literal|3
init|;
name|TBL_CHNL
condition|;
name|x
operator|+=
literal|3
control|)
block|{
if|if
condition|(
name|channel
operator|>=
name|TBL_CHNL
condition|)
block|{
return|return
operator|(
name|TBL_BASE_FREQ
operator|+
operator|(
operator|(
name|channel
operator|-
name|TBL_CHNL
operator|)
operator|*
name|TBL_OFFSET
operator|)
operator|)
return|;
block|}
block|}
comment|/* not found, must be below the MIN channel */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
undef|#
directive|undef
name|TBL_OFFSET
undef|#
directive|undef
name|TBL_BASE_FREQ
undef|#
directive|undef
name|TBL_CHNL
define|#
directive|define
name|TBL_IF
value|freqTable[ bktr->tuner.chnlset ].ptr[ 1 ]
comment|/*  * set the frequency of the tuner  */
specifier|static
name|int
name|tv_freq
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|,
name|int
name|frequency
parameter_list|)
block|{
specifier|const
name|struct
name|TUNER
modifier|*
name|tuner
decl_stmt|;
name|u_char
name|addr
decl_stmt|;
name|u_char
name|control
decl_stmt|;
name|u_char
name|band
decl_stmt|;
name|int
name|N
decl_stmt|;
name|tuner
operator|=
name|bktr
operator|->
name|card
operator|.
name|tuner
expr_stmt|;
if|if
condition|(
name|tuner
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* 	 * select the band based on frequency 	 * XXX FIXME: get the cross-over points from the tuner struct 	 */
if|if
condition|(
name|frequency
operator|<
operator|(
literal|160
operator|*
name|FREQFACTOR
operator|)
condition|)
name|N
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|frequency
operator|<
operator|(
literal|454
operator|*
name|FREQFACTOR
operator|)
condition|)
name|N
operator|=
literal|1
expr_stmt|;
else|else
name|N
operator|=
literal|2
expr_stmt|;
if|if
condition|(
name|frequency
operator|>
name|RADIO_OFFSET
condition|)
block|{
name|N
operator|=
literal|3
expr_stmt|;
name|frequency
operator|-=
name|RADIO_OFFSET
expr_stmt|;
block|}
comment|/* set the address of the PLL */
name|addr
operator|=
name|bktr
operator|->
name|card
operator|.
name|tuner_pllAddr
expr_stmt|;
name|control
operator|=
name|tuner
operator|->
name|pllControl
index|[
name|N
index|]
expr_stmt|;
name|band
operator|=
name|tuner
operator|->
name|bandAddrs
index|[
name|N
index|]
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|band
operator|&&
name|control
operator|)
condition|)
comment|/* Don't try to set un-	*/
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* supported modes.	*/
if|if
condition|(
name|N
operator|==
literal|3
condition|)
name|band
operator||=
name|bktr
operator|->
name|tuner
operator|.
name|radio_mode
expr_stmt|;
comment|/* 	 * N = 16 * { fRF(pc) + fIF(pc) } 	 * where: 	 *  pc is picture carrier, fRF& fIF are in mHz 	 * 	 * frequency was passed in as mHz * 16 	 */
if|#
directive|if
name|defined
argument_list|(
name|TEST_TUNER_AFC
argument_list|)
if|if
condition|(
name|bktr
operator|->
name|tuner
operator|.
name|afc
condition|)
name|frequency
operator|-=
literal|4
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|bktr
operator|->
name|bt848_tuner
operator|==
name|ALPS_TSCH5
operator|&&
name|N
operator|==
literal|3
condition|)
comment|/* for FM frequency */
name|N
operator|=
name|frequency
expr_stmt|;
else|else
name|N
operator|=
name|frequency
operator|+
name|TBL_IF
expr_stmt|;
if|if
condition|(
name|frequency
operator|>
name|bktr
operator|->
name|tuner
operator|.
name|frequency
condition|)
block|{
name|i2cWrite
argument_list|(
name|bktr
argument_list|,
name|addr
argument_list|,
operator|(
name|N
operator|>>
literal|8
operator|)
operator|&
literal|0x7f
argument_list|,
name|N
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|i2cWrite
argument_list|(
name|bktr
argument_list|,
name|addr
argument_list|,
name|control
argument_list|,
name|band
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|i2cWrite
argument_list|(
name|bktr
argument_list|,
name|addr
argument_list|,
name|control
argument_list|,
name|band
argument_list|)
expr_stmt|;
name|i2cWrite
argument_list|(
name|bktr
argument_list|,
name|addr
argument_list|,
operator|(
name|N
operator|>>
literal|8
operator|)
operator|&
literal|0x7f
argument_list|,
name|N
operator|&
literal|0xff
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|TUNER_AFC
argument_list|)
if|if
condition|(
name|bktr
operator|->
name|tuner
operator|.
name|afc
operator|==
name|TRUE
condition|)
block|{
if|if
condition|(
operator|(
name|N
operator|=
name|do_afc
argument_list|(
name|bktr
argument_list|,
name|addr
argument_list|,
name|N
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
comment|/* AFC failed, restore requested frequency */
name|N
operator|=
name|frequency
operator|+
name|TBL_IF
expr_stmt|;
name|i2cWrite
argument_list|(
name|bktr
argument_list|,
name|addr
argument_list|,
operator|(
name|N
operator|>>
literal|8
operator|)
operator|&
literal|0x7f
argument_list|,
name|N
operator|&
literal|0xff
argument_list|)
expr_stmt|;
block|}
else|else
name|frequency
operator|=
name|N
operator|-
name|TBL_IF
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* TUNER_AFC */
comment|/* update frequency */
name|bktr
operator|->
name|tuner
operator|.
name|frequency
operator|=
name|frequency
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|TUNER_AFC
argument_list|)
comment|/*  *   */
specifier|static
name|int
name|do_afc
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|,
name|int
name|addr
parameter_list|,
name|int
name|frequency
parameter_list|)
block|{
name|int
name|step
decl_stmt|;
name|int
name|status
decl_stmt|;
name|int
name|origFrequency
decl_stmt|;
name|origFrequency
operator|=
name|frequency
expr_stmt|;
comment|/* wait for first setting to take effect */
name|tsleep
argument_list|(
name|BKTR_SLEEP
argument_list|,
name|PZERO
argument_list|,
literal|"tuning"
argument_list|,
name|hz
operator|/
literal|8
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|status
operator|=
name|i2cRead
argument_list|(
name|bktr
argument_list|,
name|addr
operator|+
literal|1
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|#
directive|if
name|defined
argument_list|(
name|TEST_TUNER_AFC
argument_list|)
name|printf
argument_list|(
literal|"\nOriginal freq: %d, status: 0x%02x\n"
argument_list|,
name|frequency
argument_list|,
name|status
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|step
operator|=
literal|0
init|;
name|step
operator|<
name|AFC_MAX_STEP
condition|;
operator|++
name|step
control|)
block|{
if|if
condition|(
operator|(
name|status
operator|=
name|i2cRead
argument_list|(
name|bktr
argument_list|,
name|addr
operator|+
literal|1
argument_list|)
operator|)
operator|<
literal|0
condition|)
goto|goto
name|fubar
goto|;
if|if
condition|(
operator|!
operator|(
name|status
operator|&
literal|0x40
operator|)
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|TEST_TUNER_AFC
argument_list|)
name|printf
argument_list|(
literal|"no lock!\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
goto|goto
name|fubar
goto|;
block|}
switch|switch
condition|(
name|status
operator|&
name|AFC_BITS
condition|)
block|{
case|case
name|AFC_FREQ_CENTERED
case|:
if|#
directive|if
name|defined
argument_list|(
name|TEST_TUNER_AFC
argument_list|)
name|printf
argument_list|(
literal|"Centered, freq: %d, status: 0x%02x\n"
argument_list|,
name|frequency
argument_list|,
name|status
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|frequency
operator|)
return|;
case|case
name|AFC_FREQ_MINUS_125
case|:
case|case
name|AFC_FREQ_MINUS_62
case|:
if|#
directive|if
name|defined
argument_list|(
name|TEST_TUNER_AFC
argument_list|)
name|printf
argument_list|(
literal|"Low, freq: %d, status: 0x%02x\n"
argument_list|,
name|frequency
argument_list|,
name|status
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|--
name|frequency
expr_stmt|;
break|break;
case|case
name|AFC_FREQ_PLUS_62
case|:
case|case
name|AFC_FREQ_PLUS_125
case|:
if|#
directive|if
name|defined
argument_list|(
name|TEST_TUNER_AFC
argument_list|)
name|printf
argument_list|(
literal|"Hi, freq: %d, status: 0x%02x\n"
argument_list|,
name|frequency
argument_list|,
name|status
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|++
name|frequency
expr_stmt|;
break|break;
block|}
name|i2cWrite
argument_list|(
name|bktr
argument_list|,
name|addr
argument_list|,
operator|(
name|frequency
operator|>>
literal|8
operator|)
operator|&
literal|0x7f
argument_list|,
name|frequency
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
name|AFC_DELAY
argument_list|)
expr_stmt|;
block|}
name|fubar
label|:
name|i2cWrite
argument_list|(
name|bktr
argument_list|,
name|addr
argument_list|,
operator|(
name|origFrequency
operator|>>
literal|8
operator|)
operator|&
literal|0x7f
argument_list|,
name|origFrequency
operator|&
literal|0xff
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
endif|#
directive|endif
comment|/* TUNER_AFC */
undef|#
directive|undef
name|TBL_IF
comment|/*  * set the channel of the tuner  */
specifier|static
name|int
name|tv_channel
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|,
name|int
name|channel
parameter_list|)
block|{
name|int
name|frequency
decl_stmt|;
comment|/* calculate the frequency according to tuner type */
if|if
condition|(
operator|(
name|frequency
operator|=
name|frequency_lookup
argument_list|(
name|bktr
argument_list|,
name|channel
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* set the new frequency */
if|if
condition|(
name|tv_freq
argument_list|(
name|bktr
argument_list|,
name|frequency
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* OK to update records */
return|return
operator|(
operator|(
name|bktr
operator|->
name|tuner
operator|.
name|channel
operator|=
name|channel
operator|)
operator|)
return|;
block|}
comment|/*  * get channelset name  */
specifier|static
name|int
name|tuner_getchnlset
parameter_list|(
name|struct
name|bktr_chnlset
modifier|*
name|chnlset
parameter_list|)
block|{
if|if
condition|(
operator|(
name|chnlset
operator|->
name|index
operator|<
name|CHNLSET_MIN
operator|)
operator|||
operator|(
name|chnlset
operator|->
name|index
operator|>
name|CHNLSET_MAX
operator|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|memcpy
argument_list|(
operator|&
name|chnlset
operator|->
name|name
argument_list|,
operator|&
name|freqTable
index|[
name|chnlset
operator|->
name|index
index|]
operator|.
name|name
argument_list|,
name|BT848_MAX_CHNLSET_NAME_LEN
argument_list|)
expr_stmt|;
name|chnlset
operator|->
name|max_channel
operator|=
name|freqTable
index|[
name|chnlset
operator|->
name|index
index|]
operator|.
name|ptr
index|[
literal|0
index|]
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/******************************************************************************  * audio specific routines:  */
comment|/*  *   */
define|#
directive|define
name|AUDIOMUX_DISCOVER_NOT
specifier|static
name|int
name|set_audio
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|,
name|int
name|cmd
parameter_list|)
block|{
name|bt848_ptr_t
name|bt848
decl_stmt|;
name|u_long
name|temp
decl_stmt|;
specifier|volatile
name|u_char
name|idx
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|AUDIOMUX_DISCOVER
argument_list|)
if|if
condition|(
name|cmd
operator|>=
literal|200
condition|)
name|cmd
operator|-=
literal|200
expr_stmt|;
elseif|else
endif|#
directive|endif
comment|/* AUDIOMUX_DISCOVER */
comment|/* check for existance of audio MUXes */
if|if
condition|(
operator|!
name|bktr
operator|->
name|card
operator|.
name|audiomuxs
index|[
literal|4
index|]
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|AUDIO_TUNER
case|:
ifdef|#
directive|ifdef
name|BKTR_REVERSEMUTE
name|bktr
operator|->
name|audio_mux_select
operator|=
literal|3
expr_stmt|;
else|#
directive|else
name|bktr
operator|->
name|audio_mux_select
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|bktr
operator|->
name|reverse_mute
condition|)
name|bktr
operator|->
name|audio_mux_select
operator|=
literal|0
expr_stmt|;
else|else
name|bktr
operator|->
name|audio_mux_select
operator|=
literal|3
expr_stmt|;
break|break;
case|case
name|AUDIO_EXTERN
case|:
name|bktr
operator|->
name|audio_mux_select
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|AUDIO_INTERN
case|:
name|bktr
operator|->
name|audio_mux_select
operator|=
literal|2
expr_stmt|;
break|break;
case|case
name|AUDIO_MUTE
case|:
name|bktr
operator|->
name|audio_mute_state
operator|=
name|TRUE
expr_stmt|;
comment|/* set mute */
break|break;
case|case
name|AUDIO_UNMUTE
case|:
name|bktr
operator|->
name|audio_mute_state
operator|=
name|FALSE
expr_stmt|;
comment|/* clear mute */
break|break;
default|default:
name|printf
argument_list|(
literal|"bktr: audio cmd error %02x\n"
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* Most cards have a simple audio multiplexer to select the 	 * audio source. The I/O_GV card has a more advanced multiplexer 	 * and requires special handling. 	 */
if|if
condition|(
name|bktr
operator|->
name|bt848_card
operator|==
name|CARD_IO_GV
condition|)
block|{
name|set_bctv_audio
argument_list|(
name|bktr
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* Proceed with the simpler audio multiplexer code for the majority 	 * of Bt848 cards. 	 */
name|bt848
operator|=
name|bktr
operator|->
name|base
expr_stmt|;
comment|/* 	 * Leave the upper bits of the GPIO port alone in case they control 	 * something like the dbx or teletext chips.  This doesn't guarantee 	 * success, but follows the rule of least astonishment. 	 */
if|if
condition|(
name|bktr
operator|->
name|audio_mute_state
operator|==
name|TRUE
condition|)
block|{
ifdef|#
directive|ifdef
name|BKTR_REVERSEMUTE
name|idx
operator|=
literal|0
expr_stmt|;
else|#
directive|else
name|idx
operator|=
literal|3
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|bktr
operator|->
name|reverse_mute
condition|)
name|idx
operator|=
literal|3
expr_stmt|;
else|else
name|idx
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|idx
operator|=
name|bktr
operator|->
name|audio_mux_select
expr_stmt|;
name|temp
operator|=
name|bt848
operator|->
name|gpio_data
operator|&
operator|~
name|bktr
operator|->
name|card
operator|.
name|gpio_mux_bits
expr_stmt|;
name|bt848
operator|->
name|gpio_data
operator|=
if|#
directive|if
name|defined
argument_list|(
name|AUDIOMUX_DISCOVER
argument_list|)
name|bt848
operator|->
name|gpio_data
operator|=
name|temp
operator||
operator|(
name|cmd
operator|&
literal|0xff
operator|)
expr_stmt|;
name|printf
argument_list|(
literal|"cmd: %d audio mux %x temp %x \n"
argument_list|,
name|cmd
argument_list|,
name|bktr
operator|->
name|card
operator|.
name|audiomuxs
index|[
name|idx
index|]
argument_list|,
name|temp
argument_list|)
expr_stmt|;
else|#
directive|else
name|temp
operator||
name|bktr
operator|->
name|card
operator|.
name|audiomuxs
index|[
name|idx
index|]
expr_stmt|;
endif|#
directive|endif
comment|/* AUDIOMUX_DISCOVER */
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/*  *   */
specifier|static
name|void
name|temp_mute
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|,
name|int
name|flag
parameter_list|)
block|{
specifier|static
name|int
name|muteState
init|=
name|FALSE
decl_stmt|;
if|if
condition|(
name|flag
operator|==
name|TRUE
condition|)
block|{
name|muteState
operator|=
name|bktr
operator|->
name|audio_mute_state
expr_stmt|;
name|set_audio
argument_list|(
name|bktr
argument_list|,
name|AUDIO_MUTE
argument_list|)
expr_stmt|;
comment|/* prevent 'click' */
block|}
else|else
block|{
name|tsleep
argument_list|(
name|BKTR_SLEEP
argument_list|,
name|PZERO
argument_list|,
literal|"tuning"
argument_list|,
name|hz
operator|/
literal|8
argument_list|)
expr_stmt|;
if|if
condition|(
name|muteState
operator|==
name|FALSE
condition|)
name|set_audio
argument_list|(
name|bktr
argument_list|,
name|AUDIO_UNMUTE
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*  * initialise the dbx chip  * taken from the Linux bttv driver TDA9850 initialisation code  */
specifier|static
name|void
name|init_BTSC
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|)
block|{
name|i2cWrite
argument_list|(
name|bktr
argument_list|,
name|TDA9850_WADDR
argument_list|,
name|CON1ADDR
argument_list|,
literal|0x08
argument_list|)
expr_stmt|;
comment|/* noise threshold st */
name|i2cWrite
argument_list|(
name|bktr
argument_list|,
name|TDA9850_WADDR
argument_list|,
name|CON2ADDR
argument_list|,
literal|0x08
argument_list|)
expr_stmt|;
comment|/* noise threshold sap */
name|i2cWrite
argument_list|(
name|bktr
argument_list|,
name|TDA9850_WADDR
argument_list|,
name|CON3ADDR
argument_list|,
literal|0x40
argument_list|)
expr_stmt|;
comment|/* stereo mode */
name|i2cWrite
argument_list|(
name|bktr
argument_list|,
name|TDA9850_WADDR
argument_list|,
name|CON4ADDR
argument_list|,
literal|0x07
argument_list|)
expr_stmt|;
comment|/* 0 dB input gain? */
name|i2cWrite
argument_list|(
name|bktr
argument_list|,
name|TDA9850_WADDR
argument_list|,
name|ALI1ADDR
argument_list|,
literal|0x10
argument_list|)
expr_stmt|;
comment|/* wideband alignment? */
name|i2cWrite
argument_list|(
name|bktr
argument_list|,
name|TDA9850_WADDR
argument_list|,
name|ALI2ADDR
argument_list|,
literal|0x10
argument_list|)
expr_stmt|;
comment|/* spectral alignment? */
name|i2cWrite
argument_list|(
name|bktr
argument_list|,
name|TDA9850_WADDR
argument_list|,
name|ALI3ADDR
argument_list|,
literal|0x03
argument_list|)
expr_stmt|;
block|}
comment|/*  * setup the dbx chip  * XXX FIXME: alot of work to be done here, this merely unmutes it.  */
specifier|static
name|int
name|set_BTSC
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|,
name|int
name|control
parameter_list|)
block|{
return|return
operator|(
name|i2cWrite
argument_list|(
name|bktr
argument_list|,
name|TDA9850_WADDR
argument_list|,
name|CON3ADDR
argument_list|,
name|control
argument_list|)
operator|)
return|;
block|}
comment|/*  * CARD_GV_BCTV specific functions.  */
define|#
directive|define
name|BCTV_AUDIO_MAIN
value|0x10
comment|/* main audio program */
define|#
directive|define
name|BCTV_AUDIO_SUB
value|0x20
comment|/* sub audio program */
define|#
directive|define
name|BCTV_AUDIO_BOTH
value|0x30
comment|/* main(L) + sub(R) program */
define|#
directive|define
name|BCTV_GPIO_REG0
value|1
define|#
directive|define
name|BCTV_GPIO_REG1
value|3
define|#
directive|define
name|BCTV_GR0_AUDIO_MODE
value|3
define|#
directive|define
name|BCTV_GR0_AUDIO_MAIN
value|0
comment|/* main program */
define|#
directive|define
name|BCTV_GR0_AUDIO_SUB
value|3
comment|/* sub program */
define|#
directive|define
name|BCTV_GR0_AUDIO_BOTH
value|1
comment|/* main(L) + sub(R) */
define|#
directive|define
name|BCTV_GR0_AUDIO_MUTE
value|4
comment|/* audio mute */
define|#
directive|define
name|BCTV_GR0_AUDIO_MONO
value|8
comment|/* force mono */
specifier|static
name|void
name|set_bctv_audio
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|)
block|{
name|int
name|data
decl_stmt|;
switch|switch
condition|(
name|bktr
operator|->
name|audio_mux_select
condition|)
block|{
case|case
literal|1
case|:
comment|/* external */
case|case
literal|2
case|:
comment|/* internal */
name|bctv_gpio_write
argument_list|(
name|bktr
argument_list|,
name|BCTV_GPIO_REG1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* tuner */
name|bctv_gpio_write
argument_list|(
name|bktr
argument_list|,
name|BCTV_GPIO_REG1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/*      switch (bktr->audio_sap_select) { */
switch|switch
condition|(
name|BCTV_AUDIO_BOTH
condition|)
block|{
case|case
name|BCTV_AUDIO_SUB
case|:
name|data
operator|=
name|BCTV_GR0_AUDIO_SUB
expr_stmt|;
break|break;
case|case
name|BCTV_AUDIO_BOTH
case|:
name|data
operator|=
name|BCTV_GR0_AUDIO_BOTH
expr_stmt|;
break|break;
case|case
name|BCTV_AUDIO_MAIN
case|:
default|default:
name|data
operator|=
name|BCTV_GR0_AUDIO_MAIN
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|bktr
operator|->
name|audio_mute_state
operator|==
name|TRUE
condition|)
name|data
operator||=
name|BCTV_GR0_AUDIO_MUTE
expr_stmt|;
name|bctv_gpio_write
argument_list|(
name|bktr
argument_list|,
name|BCTV_GPIO_REG0
argument_list|,
name|data
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* gpio_data bit assignment */
define|#
directive|define
name|BCTV_GPIO_ADDR_MASK
value|0x000300
define|#
directive|define
name|BCTV_GPIO_WE
value|0x000400
define|#
directive|define
name|BCTV_GPIO_OE
value|0x000800
define|#
directive|define
name|BCTV_GPIO_VAL_MASK
value|0x00f000
define|#
directive|define
name|BCTV_GPIO_PORT_MASK
value|3
define|#
directive|define
name|BCTV_GPIO_ADDR_SHIFT
value|8
define|#
directive|define
name|BCTV_GPIO_VAL_SHIFT
value|12
comment|/* gpio_out_en value for read/write */
define|#
directive|define
name|BCTV_GPIO_OUT_RMASK
value|0x000f00
define|#
directive|define
name|BCTV_GPIO_OUT_WMASK
value|0x00ff00
define|#
directive|define
name|BCTV_BITS
value|100
specifier|static
name|void
name|bctv_gpio_write
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|,
name|int
name|port
parameter_list|,
name|int
name|val
parameter_list|)
block|{
name|bt848_ptr_t
name|bt848
init|=
name|bktr
operator|->
name|base
decl_stmt|;
name|u_long
name|data
decl_stmt|,
name|outbits
decl_stmt|;
name|port
operator|&=
name|BCTV_GPIO_PORT_MASK
expr_stmt|;
switch|switch
condition|(
name|port
condition|)
block|{
case|case
literal|1
case|:
case|case
literal|3
case|:
name|data
operator|=
operator|(
operator|(
name|val
operator|<<
name|BCTV_GPIO_VAL_SHIFT
operator|)
operator|&
name|BCTV_GPIO_VAL_MASK
operator|)
operator||
operator|(
operator|(
name|port
operator|<<
name|BCTV_GPIO_ADDR_SHIFT
operator|)
operator|&
name|BCTV_GPIO_ADDR_MASK
operator|)
operator||
name|BCTV_GPIO_WE
operator||
name|BCTV_GPIO_OE
expr_stmt|;
name|outbits
operator|=
name|BCTV_GPIO_OUT_WMASK
expr_stmt|;
break|break;
default|default:
return|return;
block|}
name|bt848
operator|->
name|gpio_out_en
operator|=
literal|0
expr_stmt|;
name|bt848
operator|->
name|gpio_data
operator|=
name|data
expr_stmt|;
name|bt848
operator|->
name|gpio_out_en
operator|=
name|outbits
expr_stmt|;
name|DELAY
argument_list|(
name|BCTV_BITS
argument_list|)
expr_stmt|;
name|bt848
operator|->
name|gpio_data
operator|=
name|data
operator|&
operator|~
name|BCTV_GPIO_WE
expr_stmt|;
name|DELAY
argument_list|(
name|BCTV_BITS
argument_list|)
expr_stmt|;
name|bt848
operator|->
name|gpio_data
operator|=
name|data
expr_stmt|;
name|DELAY
argument_list|(
name|BCTV_BITS
argument_list|)
expr_stmt|;
name|bt848
operator|->
name|gpio_data
operator|=
operator|~
literal|0
expr_stmt|;
name|bt848
operator|->
name|gpio_out_en
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Not yet used static int bctv_gpio_read( bktr_ptr_t bktr, int port ) {         bt848_ptr_t bt848 = bktr->base;         u_long data, outbits, ret;          port&= BCTV_GPIO_PORT_MASK;         switch (port) {         case 1:         case 3:                 data = ((port<< BCTV_GPIO_ADDR_SHIFT)& BCTV_GPIO_ADDR_MASK) |                        BCTV_GPIO_WE | BCTV_GPIO_OE;                 outbits = BCTV_GPIO_OUT_RMASK;                 break;         default:                 return( -1 );         }         bt848->gpio_out_en = 0;         bt848->gpio_data = data;         bt848->gpio_out_en = outbits;         DELAY(BCTV_BITS);         bt848->gpio_data = data& ~BCTV_GPIO_OE;         DELAY(BCTV_BITS);         ret = bt848->gpio_data;         DELAY(BCTV_BITS);         bt848->gpio_data = data;         DELAY(BCTV_BITS);         bt848->gpio_data = ~0;         bt848->gpio_out_en = 0;         return( (ret& BCTV_GPIO_VAL_MASK)>> BCTV_GPIO_VAL_SHIFT ); } */
comment|/*  * setup the MSP34xx Stereo Audio Chip  * This uses the Auto Configuration Option on MSP3410D and MSP3415D chips  * and DBX mode selection for MSP3430G chips.  * For MSP3400C support, the full programming sequence is required and is  * not yet supported.  */
comment|/* Read the MSP version string */
specifier|static
name|void
name|msp_read_id
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|)
block|{
name|int
name|rev1
init|=
literal|0
decl_stmt|,
name|rev2
init|=
literal|0
decl_stmt|;
name|rev1
operator|=
name|msp_read
argument_list|(
name|bktr
argument_list|,
literal|0x12
argument_list|,
literal|0x001e
argument_list|)
expr_stmt|;
name|rev2
operator|=
name|msp_read
argument_list|(
name|bktr
argument_list|,
literal|0x12
argument_list|,
literal|0x001f
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|bktr
operator|->
name|msp_version_string
argument_list|,
literal|"34%02d%c-%c%d"
argument_list|,
operator|(
name|rev2
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|,
operator|(
name|rev1
operator|&
literal|0xff
operator|)
operator|+
literal|'@'
argument_list|,
operator|(
operator|(
name|rev1
operator|>>
literal|8
operator|)
operator|&
literal|0xff
operator|)
operator|+
literal|'@'
argument_list|,
name|rev2
operator|&
literal|0x1f
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Detected a MSP%s\n"
argument_list|,
name|bktr
operator|->
name|msp_version_string
argument_list|)
expr_stmt|;
block|}
comment|/* Configure the MSP chip to Auto-detect the audio format */
specifier|static
name|void
name|msp_autodetect
parameter_list|(
name|bktr_ptr_t
name|bktr
parameter_list|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
literal|"3430G"
argument_list|,
name|bktr
operator|->
name|msp_version_string
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* For MSP3430G - countries with mono and DBX stereo */
name|msp_write
argument_list|(
name|bktr
argument_list|,
literal|0x10
argument_list|,
literal|0x0030
argument_list|,
literal|0x2003
argument_list|)
expr_stmt|;
comment|/* Enable Auto format detection */
name|msp_write
argument_list|(
name|bktr
argument_list|,
literal|0x10
argument_list|,
literal|0x0020
argument_list|,
literal|0x0020
argument_list|)
expr_stmt|;
comment|/* Standard Select Reg. = BTSC-Stereo*/
name|msp_write
argument_list|(
name|bktr
argument_list|,
literal|0x12
argument_list|,
literal|0x000E
argument_list|,
literal|0x2403
argument_list|)
expr_stmt|;
comment|/* darned if I know */
name|msp_write
argument_list|(
name|bktr
argument_list|,
literal|0x12
argument_list|,
literal|0x0008
argument_list|,
literal|0x0320
argument_list|)
expr_stmt|;
comment|/* Source select = (St or A) */
comment|/*& Ch. Matrix = St */
name|msp_write
argument_list|(
name|bktr
argument_list|,
literal|0x12
argument_list|,
literal|0x0000
argument_list|,
literal|0x7300
argument_list|)
expr_stmt|;
comment|/* Set volume to 0db gain */
block|}
else|else
block|{
comment|/* For MSP3410 / 3415 - countries with mono, FM stereo and NICAM */
name|msp_write
argument_list|(
name|bktr
argument_list|,
literal|0x12
argument_list|,
literal|0x0000
argument_list|,
literal|0x7300
argument_list|)
expr_stmt|;
comment|/* Set volume to 0db gain */
name|msp_write
argument_list|(
name|bktr
argument_list|,
literal|0x10
argument_list|,
literal|0x0020
argument_list|,
literal|0x0001
argument_list|)
expr_stmt|;
comment|/* Enable Auto format detection */
name|msp_write
argument_list|(
name|bktr
argument_list|,
literal|0x10
argument_list|,
literal|0x0021
argument_list|,
literal|0x0001
argument_list|)
expr_stmt|;
comment|/* Auto selection of NICAM/MONO mode */
block|}
comment|/* uncomment the following line to enable the MSP34xx 1Khz Tone Generator */
comment|/* turn your speaker volume down low before trying this */
comment|/* msp_write(bktr, 0x12, 0x0014, 0x7f40); */
block|}
comment|/*  *  * Operating System Dependant Parts  * This section contains OS Dependant code like  * probe and attach and the cdev open/close/read/mmap interface  *  */
comment|/****************************/
comment|/* *** FreeBSD 4.x code *** */
comment|/****************************/
if|#
directive|if
operator|(
name|__FreeBSD_version
operator|>=
literal|400000
operator|)
specifier|static
name|int
name|bktr_probe
argument_list|(
name|device_t
name|dev
argument_list|)
decl_stmt|;
specifier|static
name|int
name|bktr_attach
argument_list|(
name|device_t
name|dev
argument_list|)
decl_stmt|;
specifier|static
name|int
name|bktr_detach
argument_list|(
name|device_t
name|dev
argument_list|)
decl_stmt|;
specifier|static
name|int
name|bktr_shutdown
argument_list|(
name|device_t
name|dev
argument_list|)
decl_stmt|;
specifier|static
name|void
name|bktr_intr
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|common_bktr_intr
argument_list|(
name|arg
argument_list|)
expr_stmt|;
block|}
specifier|static
name|device_method_t
name|bktr_methods
index|[]
init|=
block|{
comment|/* Device interface */
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|bktr_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|bktr_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|bktr_detach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_shutdown
argument_list|,
name|bktr_shutdown
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
specifier|static
name|driver_t
name|bktr_driver
init|=
block|{
literal|"bktr"
block|,
name|bktr_methods
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|bktr_softc
argument_list|)
block|, }
decl_stmt|;
specifier|static
name|devclass_t
name|bktr_devclass
decl_stmt|;
specifier|static
name|d_open_t
name|bktr_open
decl_stmt|;
specifier|static
name|d_close_t
name|bktr_close
decl_stmt|;
specifier|static
name|d_read_t
name|bktr_read
decl_stmt|;
specifier|static
name|d_write_t
name|bktr_write
decl_stmt|;
specifier|static
name|d_ioctl_t
name|bktr_ioctl
decl_stmt|;
specifier|static
name|d_mmap_t
name|bktr_mmap
decl_stmt|;
define|#
directive|define
name|CDEV_MAJOR
value|92
specifier|static
name|struct
name|cdevsw
name|bktr_cdevsw
init|=
block|{
comment|/* open */
name|bktr_open
block|,
comment|/* close */
name|bktr_close
block|,
comment|/* read */
name|bktr_read
block|,
comment|/* write */
name|bktr_write
block|,
comment|/* ioctl */
name|bktr_ioctl
block|,
comment|/* stop */
name|nostop
block|,
comment|/* reset */
name|noreset
block|,
comment|/* devtotty */
name|nodevtotty
block|,
comment|/* poll */
name|nopoll
block|,
comment|/* mmap */
name|bktr_mmap
block|,
comment|/* strategy */
name|nostrategy
block|,
comment|/* name */
literal|"bktr"
block|,
comment|/* parms */
name|noparms
block|,
comment|/* maj */
name|CDEV_MAJOR
block|,
comment|/* dump */
name|nodump
block|,
comment|/* psize */
name|nopsize
block|,
comment|/* flags */
literal|0
block|,
comment|/* maxio */
literal|0
block|,
comment|/* bmaj */
operator|-
literal|1
block|}
decl_stmt|;
name|DEV_DRIVER_MODULE
argument_list|(
name|bktr
argument_list|,
name|pci
argument_list|,
name|bktr_driver
argument_list|,
name|bktr_devclass
argument_list|,
name|bktr_cdevsw
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/*  * the boot time probe routine.  */
specifier|static
name|int
name|bktr_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|unsigned
name|int
name|type
init|=
name|pci_get_devid
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|rev
init|=
name|pci_get_revid
argument_list|(
name|dev
argument_list|)
decl_stmt|;
specifier|static
name|int
name|once
decl_stmt|;
if|if
condition|(
operator|!
name|once
operator|++
condition|)
name|cdevsw_add
argument_list|(
operator|&
name|bktr_cdevsw
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|BROOKTREE_848_PCI_ID
case|:
if|if
condition|(
name|rev
operator|==
literal|0x12
condition|)
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"BrookTree 848A"
argument_list|)
expr_stmt|;
else|else
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"BrookTree 848"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|BROOKTREE_849_PCI_ID
case|:
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"BrookTree 849A"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|BROOKTREE_878_PCI_ID
case|:
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"BrookTree 878"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|BROOKTREE_879_PCI_ID
case|:
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"BrookTree 879"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
empty_stmt|;
return|return
name|ENXIO
return|;
block|}
comment|/*  * the attach routine.  */
specifier|static
name|int
name|bktr_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|bt848_ptr_t
name|bt848
decl_stmt|;
name|u_long
name|latency
decl_stmt|;
name|u_long
name|fun
decl_stmt|;
name|u_long
name|val
decl_stmt|;
name|unsigned
name|int
name|rev
decl_stmt|;
name|unsigned
name|int
name|unit
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|int
name|rid
decl_stmt|;
ifdef|#
directive|ifdef
name|BROOKTREE_IRQ
name|u_long
name|old_irq
decl_stmt|,
name|new_irq
decl_stmt|;
endif|#
directive|endif
name|struct
name|bktr_softc
modifier|*
name|bktr
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|unit
operator|=
name|device_get_unit
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* 	 * Enable bus mastering and Memory Mapped device 	 */
name|val
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_COMMAND
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|val
operator||=
operator|(
name|PCIM_CMD_MEMEN
operator||
name|PCIM_CMD_BUSMASTEREN
operator|)
expr_stmt|;
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|PCIR_COMMAND
argument_list|,
name|val
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* 	 * Map control/status registers. 	 */
name|rid
operator|=
name|PCI_MAP_REG_START
expr_stmt|;
name|bktr
operator|->
name|res_mem
operator|=
name|bus_alloc_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
operator|&
name|rid
argument_list|,
literal|0
argument_list|,
operator|~
literal|0
argument_list|,
literal|1
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bktr
operator|->
name|res_mem
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"could not map memory\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|bktr
operator|->
name|base
operator|=
name|rman_get_virtual
argument_list|(
name|bktr
operator|->
name|res_mem
argument_list|)
expr_stmt|;
comment|/* XXX use bus_space */
comment|/* 	 * Disable the brooktree device 	 */
name|bt848
operator|=
name|bktr
operator|->
name|base
expr_stmt|;
name|bt848
operator|->
name|int_mask
operator|=
name|ALL_INTS_DISABLED
expr_stmt|;
name|bt848
operator|->
name|gpio_dma_ctl
operator|=
name|FIFO_RISC_DISABLED
expr_stmt|;
ifdef|#
directive|ifdef
name|BROOKTREE_IRQ
comment|/* from the configuration file */
name|old_irq
operator|=
name|pci_conf_read
argument_list|(
name|tag
argument_list|,
name|PCI_INTERRUPT_REG
argument_list|)
expr_stmt|;
name|pci_conf_write
argument_list|(
name|tag
argument_list|,
name|PCI_INTERRUPT_REG
argument_list|,
name|BROOKTREE_IRQ
argument_list|)
expr_stmt|;
name|new_irq
operator|=
name|pci_conf_read
argument_list|(
name|tag
argument_list|,
name|PCI_INTERRUPT_REG
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"bktr%d: attach: irq changed from %d to %d\n"
argument_list|,
name|unit
argument_list|,
operator|(
name|old_irq
operator|&
literal|0xff
operator|)
argument_list|,
operator|(
name|new_irq
operator|&
literal|0xff
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Allocate our interrupt. 	 */
name|rid
operator|=
literal|0
expr_stmt|;
name|bktr
operator|->
name|res_irq
operator|=
name|bus_alloc_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|rid
argument_list|,
literal|0
argument_list|,
operator|~
literal|0
argument_list|,
literal|1
argument_list|,
name|RF_SHAREABLE
operator||
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|bktr
operator|->
name|res_irq
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"could not map interrupt\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|error
operator|=
name|bus_setup_intr
argument_list|(
name|dev
argument_list|,
name|bktr
operator|->
name|res_irq
argument_list|,
name|INTR_TYPE_NET
argument_list|,
name|bktr_intr
argument_list|,
name|bktr
argument_list|,
operator|&
name|bktr
operator|->
name|res_ih
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"could not setup irq\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* Update the Device Control Register */
comment|/* on Bt878 and Bt879 cards           */
name|fun
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
literal|0x40
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|fun
operator|=
name|fun
operator||
literal|1
expr_stmt|;
comment|/* Enable writes to the sub-system vendor ID */
if|#
directive|if
name|defined
argument_list|(
name|BKTR_430_FX_MODE
argument_list|)
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"Using 430 FX chipset compatibilty mode\n"
argument_list|)
expr_stmt|;
name|fun
operator|=
name|fun
operator||
literal|2
expr_stmt|;
comment|/* Enable Intel 430 FX compatibility mode */
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|BKTR_SIS_VIA_MODE
argument_list|)
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"Using SiS/VIA chipset compatibilty mode\n"
argument_list|)
expr_stmt|;
name|fun
operator|=
name|fun
operator||
literal|4
expr_stmt|;
comment|/* Enable SiS/VIA compatibility mode (usefull for                            OPTi chipset motherboards too */
endif|#
directive|endif
name|pci_write_config
argument_list|(
name|dev
argument_list|,
literal|0x40
argument_list|,
name|fun
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* XXX call bt848_i2c dependent attach() routine */
if|#
directive|if
operator|(
name|NSMBUS
operator|>
literal|0
operator|)
if|if
condition|(
name|bt848_i2c_attach
argument_list|(
name|unit
argument_list|,
name|bktr
operator|->
name|base
argument_list|,
operator|&
name|bktr
operator|->
name|i2c_sc
argument_list|)
condition|)
name|printf
argument_list|(
literal|"bktr%d: i2c_attach: can't attach\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*  * PCI latency timer.  32 is a good value for 4 bus mastering slots, if  * you have more than four, then 16 would probably be a better value.  */
ifndef|#
directive|ifndef
name|BROOKTREE_DEF_LATENCY_VALUE
define|#
directive|define
name|BROOKTREE_DEF_LATENCY_VALUE
value|10
endif|#
directive|endif
name|latency
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCI_LATENCY_TIMER
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|latency
operator|=
operator|(
name|latency
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
block|{
if|if
condition|(
name|latency
condition|)
name|printf
argument_list|(
literal|"brooktree%d: PCI bus latency is"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"brooktree%d: PCI bus latency was 0 changing to"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|latency
condition|)
block|{
name|latency
operator|=
name|BROOKTREE_DEF_LATENCY_VALUE
expr_stmt|;
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|PCI_LATENCY_TIMER
argument_list|,
name|latency
operator|<<
literal|8
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bootverbose
condition|)
block|{
name|printf
argument_list|(
literal|" %d.\n"
argument_list|,
operator|(
name|int
operator|)
name|latency
argument_list|)
expr_stmt|;
block|}
comment|/* read the pci device id and revision id */
name|fun
operator|=
name|pci_get_devid
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|rev
operator|=
name|pci_get_revid
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* call the common attach code */
name|common_bktr_attach
argument_list|(
name|bktr
argument_list|,
name|unit
argument_list|,
name|fun
argument_list|,
name|rev
argument_list|)
expr_stmt|;
name|make_dev
argument_list|(
operator|&
name|bktr_cdevsw
argument_list|,
name|unit
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0444
argument_list|,
literal|"bktr%d"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|make_dev
argument_list|(
operator|&
name|bktr_cdevsw
argument_list|,
name|unit
operator|+
literal|16
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0444
argument_list|,
literal|"tuner%d"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|make_dev
argument_list|(
operator|&
name|bktr_cdevsw
argument_list|,
name|unit
operator|+
literal|32
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0444
argument_list|,
literal|"vbi%d"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
name|fail
label|:
return|return
name|error
return|;
block|}
comment|/*  * the detach routine.  */
specifier|static
name|int
name|bktr_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|bktr_softc
modifier|*
name|bktr
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|bt848_ptr_t
name|bt848
decl_stmt|;
comment|/* Disable the brooktree device */
name|bt848
operator|=
name|bktr
operator|->
name|base
expr_stmt|;
name|bt848
operator|->
name|int_mask
operator|=
name|ALL_INTS_DISABLED
expr_stmt|;
name|bt848
operator|->
name|gpio_dma_ctl
operator|=
name|FIFO_RISC_DISABLED
expr_stmt|;
comment|/* FIXME - Free memory for RISC programs, grab buffer, vbi buffers */
comment|/* 	 * Deallocate resources. 	 */
name|bus_teardown_intr
argument_list|(
name|dev
argument_list|,
name|bktr
operator|->
name|res_irq
argument_list|,
name|bktr
operator|->
name|res_ih
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
literal|0
argument_list|,
name|bktr
operator|->
name|res_irq
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|PCI_MAP_REG_START
argument_list|,
name|bktr
operator|->
name|res_mem
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/*  * the shutdown routine.  */
specifier|static
name|int
name|bktr_shutdown
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|bktr_softc
modifier|*
name|bktr
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|bt848_ptr_t
name|bt848
decl_stmt|;
comment|/* Disable the brooktree device */
name|bt848
operator|=
name|bktr
operator|->
name|base
expr_stmt|;
name|bt848
operator|->
name|int_mask
operator|=
name|ALL_INTS_DISABLED
expr_stmt|;
name|bt848
operator|->
name|gpio_dma_ctl
operator|=
name|FIFO_RISC_DISABLED
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/*  * Special Memory Allocation  */
specifier|static
name|vm_offset_t
name|get_bktr_mem
parameter_list|(
name|int
name|unit
parameter_list|,
name|unsigned
name|size
parameter_list|)
block|{
name|vm_offset_t
name|addr
init|=
literal|0
decl_stmt|;
name|addr
operator|=
name|vm_page_alloc_contig
argument_list|(
name|size
argument_list|,
literal|0x100000
argument_list|,
literal|0xffffffff
argument_list|,
literal|1
operator|<<
literal|24
argument_list|)
expr_stmt|;
if|if
condition|(
name|addr
operator|==
literal|0
condition|)
name|addr
operator|=
name|vm_page_alloc_contig
argument_list|(
name|size
argument_list|,
literal|0x100000
argument_list|,
literal|0xffffffff
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|addr
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"bktr%d: Unable to allocate %d bytes of memory.\n"
argument_list|,
name|unit
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|addr
operator|)
return|;
block|}
comment|/*--------------------------------------------------------- ** **	BrookTree 848 character device driver routines ** **--------------------------------------------------------- */
define|#
directive|define
name|VIDEO_DEV
value|0x00
define|#
directive|define
name|TUNER_DEV
value|0x01
define|#
directive|define
name|VBI_DEV
value|0x02
define|#
directive|define
name|UNIT
parameter_list|(
name|x
parameter_list|)
value|((x)& 0x0f)
define|#
directive|define
name|FUNCTION
parameter_list|(
name|x
parameter_list|)
value|(x>> 4)
comment|/*  *   */
name|int
name|bktr_open
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|fmt
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|bktr_ptr_t
name|bktr
decl_stmt|;
name|int
name|unit
decl_stmt|;
name|int
name|result
decl_stmt|;
name|unit
operator|=
name|UNIT
argument_list|(
name|minor
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Get the device data */
name|bktr
operator|=
operator|(
expr|struct
name|bktr_softc
operator|*
operator|)
name|devclass_get_softc
argument_list|(
name|bktr_devclass
argument_list|,
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|bktr
operator|==
name|NULL
condition|)
block|{
comment|/* the device is no longer valid/functioning */
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
if|if
condition|(
operator|!
operator|(
name|bktr
operator|->
name|flags
operator|&
name|METEOR_INITALIZED
operator|)
condition|)
comment|/* device not found */
return|return
operator|(
name|ENXIO
operator|)
return|;
comment|/* Record that the device is now busy */
name|device_busy
argument_list|(
name|devclass_get_device
argument_list|(
name|bktr_devclass
argument_list|,
name|unit
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|bt848_card
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
operator|(
name|bt848_card
operator|>>
literal|8
operator|==
name|unit
operator|)
operator|&&
operator|(
operator|(
name|bt848_card
operator|&
literal|0xff
operator|)
operator|<
name|Bt848_MAX_CARD
operator|)
condition|)
block|{
if|if
condition|(
name|bktr
operator|->
name|bt848_card
operator|!=
operator|(
name|bt848_card
operator|&
literal|0xff
operator|)
condition|)
block|{
name|bktr
operator|->
name|bt848_card
operator|=
operator|(
name|bt848_card
operator|&
literal|0xff
operator|)
expr_stmt|;
name|probeCard
argument_list|(
name|bktr
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|bt848_tuner
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
operator|(
name|bt848_tuner
operator|>>
literal|8
operator|==
name|unit
operator|)
operator|&&
operator|(
operator|(
name|bt848_tuner
operator|&
literal|0xff
operator|)
operator|<
name|Bt848_MAX_TUNER
operator|)
condition|)
block|{
if|if
condition|(
name|bktr
operator|->
name|bt848_tuner
operator|!=
operator|(
name|bt848_tuner
operator|&
literal|0xff
operator|)
condition|)
block|{
name|bktr
operator|->
name|bt848_tuner
operator|=
operator|(
name|bt848_tuner
operator|&
literal|0xff
operator|)
expr_stmt|;
name|probeCard
argument_list|(
name|bktr
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|bt848_reverse_mute
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
operator|(
operator|(
name|bt848_reverse_mute
operator|>>
literal|8
operator|)
operator|==
name|unit
operator|)
operator|&&
operator|(
operator|(
name|bt848_reverse_mute
operator|&
literal|0xff
operator|)
operator|<
name|Bt848_MAX_TUNER
operator|)
condition|)
block|{
name|bktr
operator|->
name|reverse_mute
operator|=
name|bt848_reverse_mute
operator|&
literal|0xff
expr_stmt|;
name|bt848_reverse_mute
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
switch|switch
condition|(
name|FUNCTION
argument_list|(
name|minor
argument_list|(
name|dev
argument_list|)
argument_list|)
condition|)
block|{
case|case
name|VIDEO_DEV
case|:
name|result
operator|=
name|video_open
argument_list|(
name|bktr
argument_list|)
expr_stmt|;
break|break;
case|case
name|TUNER_DEV
case|:
name|result
operator|=
name|tuner_open
argument_list|(
name|bktr
argument_list|)
expr_stmt|;
break|break;
case|case
name|VBI_DEV
case|:
name|result
operator|=
name|vbi_open
argument_list|(
name|bktr
argument_list|)
expr_stmt|;
break|break;
default|default:
name|result
operator|=
name|ENXIO
expr_stmt|;
break|break;
block|}
comment|/* If there was an error opening the device, undo the busy status */
if|if
condition|(
name|result
operator|!=
literal|0
condition|)
name|device_unbusy
argument_list|(
name|devclass_get_device
argument_list|(
name|bktr_devclass
argument_list|,
name|unit
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
comment|/*  *   */
name|int
name|bktr_close
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|fmt
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|bktr_ptr_t
name|bktr
decl_stmt|;
name|int
name|unit
decl_stmt|;
name|int
name|result
decl_stmt|;
name|unit
operator|=
name|UNIT
argument_list|(
name|minor
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Get the device data */
name|bktr
operator|=
operator|(
expr|struct
name|bktr_softc
operator|*
operator|)
name|devclass_get_softc
argument_list|(
name|bktr_devclass
argument_list|,
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|bktr
operator|==
name|NULL
condition|)
block|{
comment|/* the device is no longer valid/functioning */
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
switch|switch
condition|(
name|FUNCTION
argument_list|(
name|minor
argument_list|(
name|dev
argument_list|)
argument_list|)
condition|)
block|{
case|case
name|VIDEO_DEV
case|:
name|result
operator|=
name|video_close
argument_list|(
name|bktr
argument_list|)
expr_stmt|;
break|break;
case|case
name|TUNER_DEV
case|:
name|result
operator|=
name|tuner_close
argument_list|(
name|bktr
argument_list|)
expr_stmt|;
break|break;
case|case
name|VBI_DEV
case|:
name|result
operator|=
name|vbi_close
argument_list|(
name|bktr
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|ENXIO
operator|)
return|;
break|break;
block|}
name|device_unbusy
argument_list|(
name|devclass_get_device
argument_list|(
name|bktr_devclass
argument_list|,
name|unit
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
comment|/*  *   */
name|int
name|bktr_read
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|,
name|int
name|ioflag
parameter_list|)
block|{
name|bktr_ptr_t
name|bktr
decl_stmt|;
name|int
name|unit
decl_stmt|;
name|unit
operator|=
name|UNIT
argument_list|(
name|minor
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Get the device data */
name|bktr
operator|=
operator|(
expr|struct
name|bktr_softc
operator|*
operator|)
name|devclass_get_softc
argument_list|(
name|bktr_devclass
argument_list|,
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|bktr
operator|==
name|NULL
condition|)
block|{
comment|/* the device is no longer valid/functioning */
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
switch|switch
condition|(
name|FUNCTION
argument_list|(
name|minor
argument_list|(
name|dev
argument_list|)
argument_list|)
condition|)
block|{
case|case
name|VIDEO_DEV
case|:
return|return
operator|(
name|video_read
argument_list|(
name|bktr
argument_list|,
name|unit
argument_list|,
name|dev
argument_list|,
name|uio
argument_list|)
operator|)
return|;
case|case
name|VBI_DEV
case|:
return|return
operator|(
name|vbi_read
argument_list|(
name|bktr
argument_list|,
name|dev
argument_list|,
name|uio
argument_list|)
operator|)
return|;
block|}
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/*  *   */
name|int
name|bktr_write
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|,
name|int
name|ioflag
parameter_list|)
block|{
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* XXX or ENXIO ? */
block|}
comment|/*  *   */
name|int
name|bktr_ioctl
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|ioctl_cmd_t
name|cmd
parameter_list|,
name|caddr_t
name|arg
parameter_list|,
name|int
name|flag
parameter_list|,
name|struct
name|proc
modifier|*
name|pr
parameter_list|)
block|{
name|bktr_ptr_t
name|bktr
decl_stmt|;
name|int
name|unit
decl_stmt|;
name|unit
operator|=
name|UNIT
argument_list|(
name|minor
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Get the device data */
name|bktr
operator|=
operator|(
expr|struct
name|bktr_softc
operator|*
operator|)
name|devclass_get_softc
argument_list|(
name|bktr_devclass
argument_list|,
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|bktr
operator|==
name|NULL
condition|)
block|{
comment|/* the device is no longer valid/functioning */
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
if|if
condition|(
name|bktr
operator|->
name|bigbuf
operator|==
literal|0
condition|)
comment|/* no frame buffer allocated (ioctl failed) */
return|return
operator|(
name|ENOMEM
operator|)
return|;
switch|switch
condition|(
name|FUNCTION
argument_list|(
name|minor
argument_list|(
name|dev
argument_list|)
argument_list|)
condition|)
block|{
case|case
name|VIDEO_DEV
case|:
return|return
operator|(
name|video_ioctl
argument_list|(
name|bktr
argument_list|,
name|unit
argument_list|,
name|cmd
argument_list|,
name|arg
argument_list|,
name|pr
argument_list|)
operator|)
return|;
case|case
name|TUNER_DEV
case|:
return|return
operator|(
name|tuner_ioctl
argument_list|(
name|bktr
argument_list|,
name|unit
argument_list|,
name|cmd
argument_list|,
name|arg
argument_list|,
name|pr
argument_list|)
operator|)
return|;
block|}
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/*  *   */
name|int
name|bktr_mmap
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|vm_offset_t
name|offset
parameter_list|,
name|int
name|nprot
parameter_list|)
block|{
name|int
name|unit
decl_stmt|;
name|bktr_ptr_t
name|bktr
decl_stmt|;
name|unit
operator|=
name|UNIT
argument_list|(
name|minor
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|FUNCTION
argument_list|(
name|minor
argument_list|(
name|dev
argument_list|)
argument_list|)
operator|>
literal|0
condition|)
comment|/* only allow mmap on /dev/bktr[n] */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* Get the device data */
name|bktr
operator|=
operator|(
expr|struct
name|bktr_softc
operator|*
operator|)
name|devclass_get_softc
argument_list|(
name|bktr_devclass
argument_list|,
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|bktr
operator|==
name|NULL
condition|)
block|{
comment|/* the device is no longer valid/functioning */
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
if|if
condition|(
name|nprot
operator|&
name|PROT_EXEC
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|offset
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|offset
operator|>=
name|bktr
operator|->
name|alloc_pages
operator|*
name|PAGE_SIZE
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
return|return
operator|(
name|i386_btop
argument_list|(
name|vtophys
argument_list|(
name|bktr
operator|->
name|bigbuf
argument_list|)
operator|+
name|offset
argument_list|)
operator|)
return|;
block|}
endif|#
directive|endif
comment|/* FreeBSD 4.x specific kernel interface routines */
comment|/**********************************/
comment|/* *** FreeBSD 2.2.x and 3.x  *** */
comment|/**********************************/
if|#
directive|if
operator|(
operator|(
name|__FreeBSD__
operator|==
literal|2
operator|)
operator|||
operator|(
name|__FreeBSD__
operator|==
literal|3
operator|)
operator|)
specifier|static
name|bktr_reg_t
name|brooktree
index|[
name|NBKTR
index|]
decl_stmt|;
specifier|static
specifier|const
name|char
modifier|*
name|bktr_probe
argument_list|(
name|pcici_t
name|tag
argument_list|,
name|pcidi_t
name|type
argument_list|)
decl_stmt|;
specifier|static
name|void
name|bktr_attach
argument_list|(
name|pcici_t
name|tag
argument_list|,
name|int
name|unit
argument_list|)
decl_stmt|;
specifier|static
name|void
name|bktr_intr
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|common_bktr_intr
argument_list|(
name|arg
argument_list|)
expr_stmt|;
block|}
specifier|static
name|u_long
name|bktr_count
decl_stmt|;
specifier|static
name|struct
name|pci_device
name|bktr_device
init|=
block|{
literal|"bktr"
block|,
name|bktr_probe
block|,
name|bktr_attach
block|,
operator|&
name|bktr_count
block|}
decl_stmt|;
name|DATA_SET
argument_list|(
name|pcidevice_set
argument_list|,
name|bktr_device
argument_list|)
expr_stmt|;
specifier|static
name|d_open_t
name|bktr_open
decl_stmt|;
specifier|static
name|d_close_t
name|bktr_close
decl_stmt|;
specifier|static
name|d_read_t
name|bktr_read
decl_stmt|;
specifier|static
name|d_write_t
name|bktr_write
decl_stmt|;
specifier|static
name|d_ioctl_t
name|bktr_ioctl
decl_stmt|;
specifier|static
name|d_mmap_t
name|bktr_mmap
decl_stmt|;
define|#
directive|define
name|CDEV_MAJOR
value|92
specifier|static
name|struct
name|cdevsw
name|bktr_cdevsw
init|=
block|{
name|bktr_open
block|,
name|bktr_close
block|,
name|bktr_read
block|,
name|bktr_write
block|,
name|bktr_ioctl
block|,
name|nostop
block|,
name|nullreset
block|,
name|nodevtotty
block|,
name|seltrue
block|,
name|bktr_mmap
block|,
name|NULL
block|,
literal|"bktr"
block|,
name|NULL
block|,
operator|-
literal|1
block|}
decl_stmt|;
specifier|static
name|int
name|bktr_devsw_installed
decl_stmt|;
specifier|static
name|void
name|bktr_drvinit
parameter_list|(
name|void
modifier|*
name|unused
parameter_list|)
block|{
name|dev_t
name|dev
decl_stmt|;
if|if
condition|(
operator|!
name|bktr_devsw_installed
condition|)
block|{
name|dev
operator|=
name|makedev
argument_list|(
name|CDEV_MAJOR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cdevsw_add
argument_list|(
operator|&
name|dev
argument_list|,
operator|&
name|bktr_cdevsw
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|bktr_devsw_installed
operator|=
literal|1
expr_stmt|;
block|}
block|}
name|SYSINIT
argument_list|(
argument|bktrdev
argument_list|,
argument|SI_SUB_DRIVERS
argument_list|,
argument|SI_ORDER_MIDDLE+CDEV_MAJOR
argument_list|,
argument|bktr_drvinit
argument_list|,
argument|NULL
argument_list|)
comment|/*  * the boot time probe routine.  */
specifier|static
specifier|const
name|char
modifier|*
name|bktr_probe
parameter_list|(
name|pcici_t
name|tag
parameter_list|,
name|pcidi_t
name|type
parameter_list|)
block|{
name|unsigned
name|int
name|rev
init|=
name|pci_conf_read
argument_list|(
name|tag
argument_list|,
name|PCIR_REVID
argument_list|)
operator|&
literal|0x000000ff
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|BROOKTREE_848_PCI_ID
case|:
if|if
condition|(
name|rev
operator|==
literal|0x12
condition|)
return|return
operator|(
literal|"BrookTree 848A"
operator|)
return|;
else|else
return|return
operator|(
literal|"BrookTree 848"
operator|)
return|;
case|case
name|BROOKTREE_849_PCI_ID
case|:
return|return
operator|(
literal|"BrookTree 849A"
operator|)
return|;
case|case
name|BROOKTREE_878_PCI_ID
case|:
return|return
operator|(
literal|"BrookTree 878"
operator|)
return|;
case|case
name|BROOKTREE_879_PCI_ID
case|:
return|return
operator|(
literal|"BrookTree 879"
operator|)
return|;
block|}
empty_stmt|;
return|return
operator|(
operator|(
name|char
operator|*
operator|)
literal|0
operator|)
return|;
block|}
comment|/*  * the attach routine.  */
specifier|static
name|void
name|bktr_attach
parameter_list|(
name|pcici_t
name|tag
parameter_list|,
name|int
name|unit
parameter_list|)
block|{
name|bktr_ptr_t
name|bktr
decl_stmt|;
name|bt848_ptr_t
name|bt848
decl_stmt|;
name|u_long
name|latency
decl_stmt|;
name|u_long
name|fun
decl_stmt|;
name|unsigned
name|int
name|rev
decl_stmt|;
ifdef|#
directive|ifdef
name|BROOKTREE_IRQ
name|u_long
name|old_irq
decl_stmt|,
name|new_irq
decl_stmt|;
endif|#
directive|endif
name|bktr
operator|=
operator|&
name|brooktree
index|[
name|unit
index|]
expr_stmt|;
if|if
condition|(
name|unit
operator|>=
name|NBKTR
condition|)
block|{
name|printf
argument_list|(
literal|"brooktree%d: attach: only %d units configured.\n"
argument_list|,
name|unit
argument_list|,
name|NBKTR
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"brooktree%d: attach: invalid unit number.\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Enable Memory Mapping */
name|fun
operator|=
name|pci_conf_read
argument_list|(
name|tag
argument_list|,
name|PCI_COMMAND_STATUS_REG
argument_list|)
expr_stmt|;
name|pci_conf_write
argument_list|(
name|tag
argument_list|,
name|PCI_COMMAND_STATUS_REG
argument_list|,
name|fun
operator||
literal|2
argument_list|)
expr_stmt|;
comment|/* Enable Bus Mastering */
name|fun
operator|=
name|pci_conf_read
argument_list|(
name|tag
argument_list|,
name|PCI_COMMAND_STATUS_REG
argument_list|)
expr_stmt|;
name|pci_conf_write
argument_list|(
name|tag
argument_list|,
name|PCI_COMMAND_STATUS_REG
argument_list|,
name|fun
operator||
literal|4
argument_list|)
expr_stmt|;
name|bktr
operator|->
name|tag
operator|=
name|tag
expr_stmt|;
comment|/* 	 * Map control/status registers 	 */
name|pci_map_mem
argument_list|(
name|tag
argument_list|,
name|PCI_MAP_REG_START
argument_list|,
operator|(
name|vm_offset_t
operator|*
operator|)
operator|&
name|bktr
operator|->
name|base
argument_list|,
operator|&
name|bktr
operator|->
name|phys_base
argument_list|)
expr_stmt|;
comment|/* 	 * Disable the brooktree device 	 */
name|bt848
operator|=
name|bktr
operator|->
name|base
expr_stmt|;
name|bt848
operator|->
name|int_mask
operator|=
name|ALL_INTS_DISABLED
expr_stmt|;
name|bt848
operator|->
name|gpio_dma_ctl
operator|=
name|FIFO_RISC_DISABLED
expr_stmt|;
ifdef|#
directive|ifdef
name|BROOKTREE_IRQ
comment|/* from the configuration file */
name|old_irq
operator|=
name|pci_conf_read
argument_list|(
name|tag
argument_list|,
name|PCI_INTERRUPT_REG
argument_list|)
expr_stmt|;
name|pci_conf_write
argument_list|(
name|tag
argument_list|,
name|PCI_INTERRUPT_REG
argument_list|,
name|BROOKTREE_IRQ
argument_list|)
expr_stmt|;
name|new_irq
operator|=
name|pci_conf_read
argument_list|(
name|tag
argument_list|,
name|PCI_INTERRUPT_REG
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"bktr%d: attach: irq changed from %d to %d\n"
argument_list|,
name|unit
argument_list|,
operator|(
name|old_irq
operator|&
literal|0xff
operator|)
argument_list|,
operator|(
name|new_irq
operator|&
literal|0xff
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * setup the interrupt handling routine 	 */
name|pci_map_int
argument_list|(
name|tag
argument_list|,
name|bktr_intr
argument_list|,
operator|(
name|void
operator|*
operator|)
name|bktr
argument_list|,
operator|&
name|net_imask
argument_list|)
expr_stmt|;
comment|/* Update the Device Control Register */
comment|/* on Bt878 and Bt879 cards */
name|fun
operator|=
name|pci_conf_read
argument_list|(
name|tag
argument_list|,
literal|0x40
argument_list|)
expr_stmt|;
name|fun
operator|=
name|fun
operator||
literal|1
expr_stmt|;
comment|/* Enable writes to the sub-system vendor ID */
if|#
directive|if
name|defined
argument_list|(
name|BKTR_430_FX_MODE
argument_list|)
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"Using 430 FX chipset compatibilty mode\n"
argument_list|)
expr_stmt|;
name|fun
operator|=
name|fun
operator||
literal|2
expr_stmt|;
comment|/* Enable Intel 430 FX compatibility mode */
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|BKTR_SIS_VIA_MODE
argument_list|)
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"Using SiS/VIA chipset compatibilty mode\n"
argument_list|)
expr_stmt|;
name|fun
operator|=
name|fun
operator||
literal|4
expr_stmt|;
comment|/* Enable SiS/VIA compatibility mode (usefull for                            OPTi chipset motherboards too */
endif|#
directive|endif
name|pci_conf_write
argument_list|(
name|tag
argument_list|,
literal|0x40
argument_list|,
name|fun
argument_list|)
expr_stmt|;
comment|/* XXX call bt848_i2c dependent attach() routine */
if|#
directive|if
operator|(
name|NSMBUS
operator|>
literal|0
operator|)
if|if
condition|(
name|bt848_i2c_attach
argument_list|(
name|unit
argument_list|,
name|bktr
operator|->
name|base
argument_list|,
operator|&
name|bktr
operator|->
name|i2c_sc
argument_list|)
condition|)
name|printf
argument_list|(
literal|"bktr%d: i2c_attach: can't attach\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*  * PCI latency timer.  32 is a good value for 4 bus mastering slots, if  * you have more than four, then 16 would probably be a better value.  */
ifndef|#
directive|ifndef
name|BROOKTREE_DEF_LATENCY_VALUE
define|#
directive|define
name|BROOKTREE_DEF_LATENCY_VALUE
value|10
endif|#
directive|endif
name|latency
operator|=
name|pci_conf_read
argument_list|(
name|tag
argument_list|,
name|PCI_LATENCY_TIMER
argument_list|)
expr_stmt|;
name|latency
operator|=
operator|(
name|latency
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
block|{
if|if
condition|(
name|latency
condition|)
name|printf
argument_list|(
literal|"brooktree%d: PCI bus latency is"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"brooktree%d: PCI bus latency was 0 changing to"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|latency
condition|)
block|{
name|latency
operator|=
name|BROOKTREE_DEF_LATENCY_VALUE
expr_stmt|;
name|pci_conf_write
argument_list|(
name|tag
argument_list|,
name|PCI_LATENCY_TIMER
argument_list|,
name|latency
operator|<<
literal|8
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bootverbose
condition|)
block|{
name|printf
argument_list|(
literal|" %d.\n"
argument_list|,
operator|(
name|int
operator|)
name|latency
argument_list|)
expr_stmt|;
block|}
comment|/* read the pci device id and revision id */
name|fun
operator|=
name|pci_conf_read
argument_list|(
name|tag
argument_list|,
name|PCI_ID_REG
argument_list|)
expr_stmt|;
name|rev
operator|=
name|pci_conf_read
argument_list|(
name|tag
argument_list|,
name|PCIR_REVID
argument_list|)
operator|&
literal|0x000000ff
expr_stmt|;
comment|/* call the common attach code */
name|common_bktr_attach
argument_list|(
name|bktr
argument_list|,
name|unit
argument_list|,
name|fun
argument_list|,
name|rev
argument_list|)
expr_stmt|;
name|make_dev
argument_list|(
operator|&
name|bktr_cdevsw
argument_list|,
name|unit
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0444
argument_list|,
literal|"bktr%d"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|make_dev
argument_list|(
operator|&
name|bktr_cdevsw
argument_list|,
name|unit
operator|+
literal|16
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0444
argument_list|,
literal|"tuner%d"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|make_dev
argument_list|(
operator|&
name|bktr_cdevsw
argument_list|,
name|unit
operator|+
literal|32
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0444
argument_list|,
literal|"vbi%d"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
block|}
comment|/*  * Special Memory Allocation  */
specifier|static
name|vm_offset_t
name|get_bktr_mem
parameter_list|(
name|int
name|unit
parameter_list|,
name|unsigned
name|size
parameter_list|)
block|{
name|vm_offset_t
name|addr
init|=
literal|0
decl_stmt|;
name|addr
operator|=
name|vm_page_alloc_contig
argument_list|(
name|size
argument_list|,
literal|0x100000
argument_list|,
literal|0xffffffff
argument_list|,
literal|1
operator|<<
literal|24
argument_list|)
expr_stmt|;
if|if
condition|(
name|addr
operator|==
literal|0
condition|)
name|addr
operator|=
name|vm_page_alloc_contig
argument_list|(
name|size
argument_list|,
literal|0x100000
argument_list|,
literal|0xffffffff
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|addr
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"bktr%d: Unable to allocate %d bytes of memory.\n"
argument_list|,
name|unit
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|addr
operator|)
return|;
block|}
comment|/*--------------------------------------------------------- ** **	BrookTree 848 character device driver routines ** **--------------------------------------------------------- */
define|#
directive|define
name|VIDEO_DEV
value|0x00
define|#
directive|define
name|TUNER_DEV
value|0x01
define|#
directive|define
name|VBI_DEV
value|0x02
define|#
directive|define
name|UNIT
parameter_list|(
name|x
parameter_list|)
value|((x)& 0x0f)
define|#
directive|define
name|FUNCTION
parameter_list|(
name|x
parameter_list|)
value|((x>> 4)& 0x0f)
comment|/*  *   */
name|int
name|bktr_open
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|fmt
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|bktr_ptr_t
name|bktr
decl_stmt|;
name|int
name|unit
decl_stmt|;
name|unit
operator|=
name|UNIT
argument_list|(
name|minor
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|unit
operator|>=
name|NBKTR
condition|)
comment|/* unit out of range */
return|return
operator|(
name|ENXIO
operator|)
return|;
name|bktr
operator|=
operator|&
operator|(
name|brooktree
index|[
name|unit
index|]
operator|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|bktr
operator|->
name|flags
operator|&
name|METEOR_INITALIZED
operator|)
condition|)
comment|/* device not found */
return|return
operator|(
name|ENXIO
operator|)
return|;
if|if
condition|(
name|bt848_card
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
operator|(
name|bt848_card
operator|>>
literal|8
operator|==
name|unit
operator|)
operator|&&
operator|(
operator|(
name|bt848_card
operator|&
literal|0xff
operator|)
operator|<
name|Bt848_MAX_CARD
operator|)
condition|)
block|{
if|if
condition|(
name|bktr
operator|->
name|bt848_card
operator|!=
operator|(
name|bt848_card
operator|&
literal|0xff
operator|)
condition|)
block|{
name|bktr
operator|->
name|bt848_card
operator|=
operator|(
name|bt848_card
operator|&
literal|0xff
operator|)
expr_stmt|;
name|probeCard
argument_list|(
name|bktr
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|bt848_tuner
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
operator|(
name|bt848_tuner
operator|>>
literal|8
operator|==
name|unit
operator|)
operator|&&
operator|(
operator|(
name|bt848_tuner
operator|&
literal|0xff
operator|)
operator|<
name|Bt848_MAX_TUNER
operator|)
condition|)
block|{
if|if
condition|(
name|bktr
operator|->
name|bt848_tuner
operator|!=
operator|(
name|bt848_tuner
operator|&
literal|0xff
operator|)
condition|)
block|{
name|bktr
operator|->
name|bt848_tuner
operator|=
operator|(
name|bt848_tuner
operator|&
literal|0xff
operator|)
expr_stmt|;
name|probeCard
argument_list|(
name|bktr
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|bt848_reverse_mute
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
operator|(
operator|(
name|bt848_reverse_mute
operator|>>
literal|8
operator|)
operator|==
name|unit
operator|)
operator|&&
operator|(
operator|(
name|bt848_reverse_mute
operator|&
literal|0xff
operator|)
operator|<
name|Bt848_MAX_TUNER
operator|)
condition|)
block|{
name|bktr
operator|->
name|reverse_mute
operator|=
name|bt848_reverse_mute
operator|&
literal|0xff
expr_stmt|;
name|bt848_reverse_mute
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
switch|switch
condition|(
name|FUNCTION
argument_list|(
name|minor
argument_list|(
name|dev
argument_list|)
argument_list|)
condition|)
block|{
case|case
name|VIDEO_DEV
case|:
return|return
operator|(
name|video_open
argument_list|(
name|bktr
argument_list|)
operator|)
return|;
case|case
name|TUNER_DEV
case|:
return|return
operator|(
name|tuner_open
argument_list|(
name|bktr
argument_list|)
operator|)
return|;
case|case
name|VBI_DEV
case|:
return|return
operator|(
name|vbi_open
argument_list|(
name|bktr
argument_list|)
operator|)
return|;
block|}
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/*  *   */
name|int
name|bktr_close
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|fmt
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|bktr_ptr_t
name|bktr
decl_stmt|;
name|int
name|unit
decl_stmt|;
name|unit
operator|=
name|UNIT
argument_list|(
name|minor
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|unit
operator|>=
name|NBKTR
condition|)
comment|/* unit out of range */
return|return
operator|(
name|ENXIO
operator|)
return|;
name|bktr
operator|=
operator|&
operator|(
name|brooktree
index|[
name|unit
index|]
operator|)
expr_stmt|;
switch|switch
condition|(
name|FUNCTION
argument_list|(
name|minor
argument_list|(
name|dev
argument_list|)
argument_list|)
condition|)
block|{
case|case
name|VIDEO_DEV
case|:
return|return
operator|(
name|video_close
argument_list|(
name|bktr
argument_list|)
operator|)
return|;
case|case
name|TUNER_DEV
case|:
return|return
operator|(
name|tuner_close
argument_list|(
name|bktr
argument_list|)
operator|)
return|;
case|case
name|VBI_DEV
case|:
return|return
operator|(
name|vbi_close
argument_list|(
name|bktr
argument_list|)
operator|)
return|;
block|}
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/*  *   */
name|int
name|bktr_read
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|,
name|int
name|ioflag
parameter_list|)
block|{
name|bktr_ptr_t
name|bktr
decl_stmt|;
name|int
name|unit
decl_stmt|;
name|unit
operator|=
name|UNIT
argument_list|(
name|minor
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|unit
operator|>=
name|NBKTR
condition|)
comment|/* unit out of range */
return|return
operator|(
name|ENXIO
operator|)
return|;
name|bktr
operator|=
operator|&
operator|(
name|brooktree
index|[
name|unit
index|]
operator|)
expr_stmt|;
switch|switch
condition|(
name|FUNCTION
argument_list|(
name|minor
argument_list|(
name|dev
argument_list|)
argument_list|)
condition|)
block|{
case|case
name|VIDEO_DEV
case|:
return|return
operator|(
name|video_read
argument_list|(
name|bktr
argument_list|,
name|unit
argument_list|,
name|dev
argument_list|,
name|uio
argument_list|)
operator|)
return|;
case|case
name|VBI_DEV
case|:
return|return
operator|(
name|vbi_read
argument_list|(
name|bktr
argument_list|,
name|dev
argument_list|,
name|uio
argument_list|)
operator|)
return|;
block|}
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/*  *   */
name|int
name|bktr_write
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|,
name|int
name|ioflag
parameter_list|)
block|{
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* XXX or ENXIO ? */
block|}
comment|/*  *   */
name|int
name|bktr_ioctl
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|ioctl_cmd_t
name|cmd
parameter_list|,
name|caddr_t
name|arg
parameter_list|,
name|int
name|flag
parameter_list|,
name|struct
name|proc
modifier|*
name|pr
parameter_list|)
block|{
name|bktr_ptr_t
name|bktr
decl_stmt|;
name|int
name|unit
decl_stmt|;
name|unit
operator|=
name|UNIT
argument_list|(
name|minor
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|unit
operator|>=
name|NBKTR
condition|)
comment|/* unit out of range */
return|return
operator|(
name|ENXIO
operator|)
return|;
name|bktr
operator|=
operator|&
operator|(
name|brooktree
index|[
name|unit
index|]
operator|)
expr_stmt|;
if|if
condition|(
name|bktr
operator|->
name|bigbuf
operator|==
literal|0
condition|)
comment|/* no frame buffer allocated (ioctl failed) */
return|return
operator|(
name|ENOMEM
operator|)
return|;
switch|switch
condition|(
name|FUNCTION
argument_list|(
name|minor
argument_list|(
name|dev
argument_list|)
argument_list|)
condition|)
block|{
case|case
name|VIDEO_DEV
case|:
return|return
operator|(
name|video_ioctl
argument_list|(
name|bktr
argument_list|,
name|unit
argument_list|,
name|cmd
argument_list|,
name|arg
argument_list|,
name|pr
argument_list|)
operator|)
return|;
case|case
name|TUNER_DEV
case|:
return|return
operator|(
name|tuner_ioctl
argument_list|(
name|bktr
argument_list|,
name|unit
argument_list|,
name|cmd
argument_list|,
name|arg
argument_list|,
name|pr
argument_list|)
operator|)
return|;
block|}
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/*  * bktr_mmap.  * Note: 2.2.5/2.2.6/2.2.7/3.0 users must manually  * edit the following line and change  "vm_offset_t" to "int""  */
name|int
name|bktr_mmap
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|vm_offset_t
name|offset
parameter_list|,
name|int
name|nprot
parameter_list|)
block|{
name|int
name|unit
decl_stmt|;
name|bktr_ptr_t
name|bktr
decl_stmt|;
name|unit
operator|=
name|UNIT
argument_list|(
name|minor
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|unit
operator|>=
name|NBKTR
operator|||
name|FUNCTION
argument_list|(
name|minor
argument_list|(
name|dev
argument_list|)
argument_list|)
operator|>
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|bktr
operator|=
operator|&
operator|(
name|brooktree
index|[
name|unit
index|]
operator|)
expr_stmt|;
if|if
condition|(
name|nprot
operator|&
name|PROT_EXEC
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|offset
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|offset
operator|>=
name|bktr
operator|->
name|alloc_pages
operator|*
name|PAGE_SIZE
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
return|return
operator|(
name|i386_btop
argument_list|(
name|vtophys
argument_list|(
name|bktr
operator|->
name|bigbuf
argument_list|)
operator|+
name|offset
argument_list|)
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* FreeBSD 2.2.x and 3.x specific kernel interface routines */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !defined(__FreeBSD__) || (NBKTR> 0&& NPCI> 0) */
end_comment

begin_comment
comment|/* Local Variables: */
end_comment

begin_comment
comment|/* mode: C */
end_comment

begin_comment
comment|/* c-indent-level: 8 */
end_comment

begin_comment
comment|/* c-brace-offset: -8 */
end_comment

begin_comment
comment|/* c-argdecl-indent: 8 */
end_comment

begin_comment
comment|/* c-label-offset: -8 */
end_comment

begin_comment
comment|/* c-continued-statement-offset: 8 */
end_comment

begin_comment
comment|/* c-tab-always-indent: nil */
end_comment

begin_comment
comment|/* tab-width: 8 */
end_comment

begin_comment
comment|/* End: */
end_comment

end_unit

