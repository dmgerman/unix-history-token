begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* BT848 1.3-ALPHA  Driver for Brooktree's Bt848 based cards.    The Brooktree  BT848 Driver driver is based upon Mark Tinguely and    Jim Lowe's driver for the Matrox Meteor PCI card . The     Philips SAA 7116 and SAA 7196 are very different chipsets than    the BT848. For starters, the BT848 is a one chipset solution and    it incorporates a RISC engine to control the DMA transfers --    that is it the actual dma process is control by a program which    resides in the hosts memory also the register definitions between    the Philips chipsets and the Bt848 are very different.     The original copyright notice by Mark and Jim is included mostly    to honor their fantastic work in the Matrox Meteor driver!        Enjoy,       Amancio   */
end_comment

begin_comment
comment|/*  * 1. Redistributions of source code must retain the   * Copyright (c) 1997 Amancio Hasty  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by Amancio Hasty  * 4. The name of the author may not be used to endorse or promote products   *    derived from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE  * DISCLAIMED.	IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,  * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN  * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  * POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * 1. Redistributions of source code must retain the   * Copyright (c) 1995 Mark Tinguely and Jim Lowe  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by Mark Tinguely and Jim Lowe  * 4. The name of the author may not be used to endorse or promote products   *    derived from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE  * DISCLAIMED.	IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,  * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN  * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  * POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*		Change History: 1.0		1/24/97	   First Alpha release  1.1		2/20/97	   Added video ioctl so we can do PCI To PCI 			   data transfers. This is for capturing data 			   directly to a vga frame buffer which has 			   a linear frame buffer. Minor code clean-up.  1.3		2/23/97	   Fixed system lock-up reported by  			   Randall Hopper<rhh@ct.picker.com>. This 			   problem seems somehow to be exhibited only 			   in his system. I changed the setting of 			   INT_MASK for CAP_CONTINUOUS to be exactly 			   the same as CAP_SINGLE apparently setting 			   bit 23 cleared the system lock up.  			   version 1.1 of the driver has been reported 			   to work with STB's WinTv, Hauppage's Wincast/Tv 			   and last but not least with the Intel Smart 			   Video Recorder.  1.4		3/9/97	   fsmp@freefall.org 			   Merged code to support tuners on STB and WinCast 			   cards. 			   Modifications to the contrast and chroma ioctls. 			   Textual cleanup.  1.5             3/15/97    fsmp@freefall.org                 	   new bt848 specific versions of hue/bright/                            contrast/satu/satv.                            Amancio's patch to fix "screen freeze" problem. */
end_comment

begin_include
include|#
directive|include
file|"bktr.h"
end_include

begin_if
if|#
directive|if
name|NBKTR
operator|>
literal|0
end_if

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/protosw.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/signalvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/mman.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|DEVFS
end_ifdef

begin_include
include|#
directive|include
file|<sys/devfsext.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DEVFS */
end_comment

begin_include
include|#
directive|include
file|<machine/clock.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_kern.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_param.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_extern.h>
end_include

begin_comment
comment|/*  * XXX: include code to support specific tuners.  * once we add auto-probe code to detect tuner types this can go away.  *  * the STB card has a TEMIC tuner, others(?) have the PHILIPS tuner.  * check the label on the metal can to be sure!  *  * in your kernel config file set one of: options	TEMIC_TUNER		# STB TV PCI options	PHILIPS_TUNER		# WinCast/TV  *  * alternately, in this file, you can select one of:  * #define TEMIC_TUNER #define PHILIPS_TUNER  */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|TEMIC_TUNER
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|PHILIPS_TUNER
argument_list|)
end_if

begin_define
define|#
directive|define
name|PHILIPS_TUNER
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * XXX: the 'options' aspect of this is a REAL KLUDGE, fix it!  * XXX: we need to support additional sets of frequencies.  *  * this selects the set of frequencies used by the tuner.  * in your kernel config file set one of: options	DEFAULT_TUNERTYPE=1	# TUNERTYPE_NABCST options	DEFAULT_TUNERTYPE=2	# TUNERTYPE_CABLEIRC  *  * alternately, in this file, you can select one of:  * #define DEFAULT_TUNERTYPE	TUNERTYPE_NABCST #define DEFAULT_TUNERTYPE	TUNERTYPE_CABLEIRC  */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|DEFAULT_TUNERTYPE
argument_list|)
end_if

begin_define
define|#
directive|define
name|DEFAULT_TUNERTYPE
value|TUNERTYPE_NABCST
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * XXX: hack to allow multiple programs to open the device,  *      ie., a tv client and a remote control  *      we need to make this a MINOR UNIT type thing someday...  */
end_comment

begin_define
define|#
directive|define
name|MULTIPLE_OPENS
end_define

begin_comment
comment|/* XXX Fixme: remove me??? */
end_comment

begin_define
define|#
directive|define
name|ORIGINAL_DELAYS_NOT
end_define

begin_comment
comment|/* XXX Fixme: anomolies still exist in the i2c code */
end_comment

begin_define
define|#
directive|define
name|EXTRA_START
end_define

begin_define
define|#
directive|define
name|FUNNY_HI
end_define

begin_define
define|#
directive|define
name|REALLY_ACK
end_define

begin_comment
comment|/* XXX attempt to hold sync on marginal signals, experimental */
end_comment

begin_define
define|#
directive|define
name|LOW_SYNC_NOT
end_define

begin_include
include|#
directive|include
file|"pci.h"
end_include

begin_if
if|#
directive|if
name|NPCI
operator|>
literal|0
end_if

begin_include
include|#
directive|include
file|<pci/pcivar.h>
end_include

begin_include
include|#
directive|include
file|<pci/pcireg.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<machine/ioctl_meteor.h>
end_include

begin_include
include|#
directive|include
file|<machine/ioctl_bt848.h>
end_include

begin_comment
comment|/* extensions to ioctl_meteor.h */
end_comment

begin_include
include|#
directive|include
file|<pci/brktree_reg.h>
end_include

begin_comment
comment|/*  * tuner specific functions  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|tv_channel
name|__P
argument_list|(
operator|(
name|bktr_reg_t
operator|*
name|bktr
operator|,
name|int
name|channel
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|tv_freq
name|__P
argument_list|(
operator|(
name|bktr_reg_t
operator|*
name|bktr
operator|,
name|int
name|frequency
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|tuner_status
name|__P
argument_list|(
operator|(
name|bktr_reg_t
operator|*
name|bktr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|METPRI
value|(PZERO+8)|PCATCH
end_define

begin_decl_stmt
specifier|static
name|void
name|bktr_intr
name|__P
argument_list|(
operator|(
name|void
operator|*
name|arg
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|static
name|bt_enable_cnt
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|u_long
name|btl_status_prev
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*   * Allocate enough memory for:  *	768x576 RGB 16 or YUV (16 storage bits/pixel) = 884736 = 216 pages  *  * You may override this using the options "METEOR_ALLOC_PAGES=value" in your  * kernel configuration file.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|BROOKTREE_ALLOC_PAGES
end_ifndef

begin_define
define|#
directive|define
name|BROOKTREE_ALLOC_PAGES
value|217*4
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|BROOKTREE_ALLOC
value|(BROOKTREE_ALLOC_PAGES * PAGE_SIZE)
end_define

begin_decl_stmt
specifier|static
name|bktr_reg_t
name|brooktree
index|[
name|NBKTR
index|]
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|BROOKTRE_NUM
parameter_list|(
name|mtr
parameter_list|)
value|((bktr -&brooktree[0])/sizeof(bktr_reg_t))
end_define

begin_define
define|#
directive|define
name|BKTRPRI
value|(PZERO+8)|PCATCH
end_define

begin_function_decl
specifier|static
name|char
modifier|*
name|bktr_probe
parameter_list|(
name|pcici_t
name|tag
parameter_list|,
name|pcidi_t
name|type
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bktr_attach
parameter_list|(
name|pcici_t
name|tag
parameter_list|,
name|int
name|unit
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|dump_bt848
parameter_list|(
specifier|volatile
name|u_char
modifier|*
name|bt848
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|yuvpack_prog
parameter_list|(
name|bktr_reg_t
modifier|*
name|bktr
parameter_list|,
name|char
name|i_flag
parameter_list|,
name|int
name|cols
parameter_list|,
name|int
name|rows
parameter_list|,
name|int
name|interlace
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|yuv422_prog
parameter_list|(
name|bktr_reg_t
modifier|*
name|bktr
parameter_list|,
name|char
name|i_flag
parameter_list|,
name|int
name|cols
parameter_list|,
name|int
name|rows
parameter_list|,
name|int
name|interlace
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|rgb_prog
parameter_list|(
name|bktr_reg_t
modifier|*
name|bktr
parameter_list|,
name|char
name|i_flag
parameter_list|,
name|int
name|cols
parameter_list|,
name|int
name|rows
parameter_list|,
name|int
name|pixel_width
parameter_list|,
name|int
name|interlace
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|start_capture
parameter_list|(
name|bktr_reg_t
modifier|*
name|bktr
parameter_list|,
name|unsigned
name|type
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|build_dma_prog
parameter_list|(
name|bktr_reg_t
modifier|*
name|bktr
parameter_list|,
name|char
name|i_flag
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|u_long
name|bktr_count
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|pci_device
name|bktr_device
init|=
block|{
literal|"bktr"
block|,
name|bktr_probe
block|,
name|bktr_attach
block|,
operator|&
name|bktr_count
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DATA_SET
argument_list|(
name|pcidevice_set
argument_list|,
name|bktr_device
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|d_open_t
name|bktr_open
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_close_t
name|bktr_close
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_read_t
name|bktr_read
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_write_t
name|bktr_write
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_ioctl_t
name|bktr_ioctl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_mmap_t
name|bktr_mmap
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|CDEV_MAJOR
value|79
end_define

begin_decl_stmt
specifier|static
name|struct
name|cdevsw
name|bktr_cdevsw
init|=
block|{
name|bktr_open
block|,
name|bktr_close
block|,
name|bktr_read
block|,
name|bktr_write
block|,
name|bktr_ioctl
block|,
name|nostop
block|,
name|nullreset
block|,
name|nodevtotty
block|,
name|seltrue
block|,
name|bktr_mmap
block|,
name|NULL
block|,
literal|"bktr"
block|,
name|NULL
block|,
operator|-
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  *   */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|bktr_probe
parameter_list|(
name|pcici_t
name|tag
parameter_list|,
name|pcidi_t
name|type
parameter_list|)
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|BROOKTREE_848_ID
case|:
return|return
operator|(
literal|"BrookTree 848"
operator|)
return|;
block|}
empty_stmt|;
return|return
operator|(
operator|(
name|char
operator|*
operator|)
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * interrupt handling routine complete meteor_read() if using interrupts  */
end_comment

begin_function
specifier|static
name|void
name|bktr_intr
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|bktr_reg_t
modifier|*
name|bktr
init|=
operator|(
name|bktr_reg_t
operator|*
operator|)
name|arg
decl_stmt|;
specifier|volatile
name|u_long
modifier|*
name|btl_reg
decl_stmt|,
name|t_pc
decl_stmt|;
specifier|volatile
name|u_char
modifier|*
name|bt848
decl_stmt|,
modifier|*
name|bt_reg
decl_stmt|,
name|s_status
decl_stmt|;
specifier|volatile
name|u_short
modifier|*
name|bts_reg
decl_stmt|;
name|u_long
name|bktr_status
decl_stmt|,
modifier|*
name|bktr_pc
decl_stmt|;
if|#
directive|if
literal|0
comment|/* XXX: what is this for??? */
block|u_long	next_base  = (u_long)(vtophys(bktr->bigbuf)), stat;
endif|#
directive|endif
name|bt848
operator|=
name|bktr
operator|->
name|base
expr_stmt|;
name|bt_reg
operator|=
operator|(
name|u_char
operator|*
operator|)
operator|&
name|bt848
expr_stmt|;
name|s_status
operator|=
operator|*
name|bt_reg
expr_stmt|;
operator|*
name|bt_reg
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|bktr
operator|->
name|flags
operator|&
name|METEOR_OPEN
operator|)
condition|)
block|{
name|bts_reg
operator|=
operator|(
name|u_short
operator|*
operator|)
operator|&
name|bt848
index|[
name|BKTR_GPIO_DMA_CTL
index|]
expr_stmt|;
operator|*
name|bts_reg
operator|=
literal|0
expr_stmt|;
name|btl_reg
operator|=
operator|(
name|u_long
operator|*
operator|)
operator|&
name|bt848
index|[
name|BKTR_INT_MASK
index|]
expr_stmt|;
operator|*
name|btl_reg
operator|=
literal|0
expr_stmt|;
block|}
name|btl_reg
operator|=
operator|(
name|u_long
operator|*
operator|)
operator|&
name|bt848
index|[
name|BKTR_INT_STAT
index|]
expr_stmt|;
name|bktr_status
operator|=
operator|*
name|btl_reg
expr_stmt|;
operator|*
name|btl_reg
operator|=
operator|*
name|btl_reg
expr_stmt|;
operator|*
name|btl_reg
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|*
name|btl_reg
operator|&
operator|(
literal|1
operator|<<
literal|25
operator|)
condition|)
operator|*
name|btl_reg
operator||=
literal|1
operator|<<
literal|8
expr_stmt|;
name|bktr_pc
operator|=
operator|(
name|u_long
operator|*
operator|)
operator|&
name|bt848
index|[
name|BKTR_RISC_COUNT
index|]
expr_stmt|;
name|t_pc
operator|=
operator|*
name|bktr_pc
expr_stmt|;
comment|/*    printf(" STATUS %x %x %x \n", s_status, bktr_status, t_pc);  */
if|if
condition|(
operator|!
operator|(
operator|(
name|bktr_status
operator|&
literal|0x800
operator|)
operator|||
operator|(
name|bktr_status
operator|&
literal|1
operator|<<
literal|19
operator|)
operator|)
condition|)
block|{
name|btl_status_prev
operator|=
name|bktr_status
expr_stmt|;
comment|/* return; */
block|}
comment|/* if risc was disabled re-start process again */
if|if
condition|(
operator|!
operator|(
name|bktr_status
operator|&
operator|(
literal|1
operator|<<
literal|27
operator|)
operator|)
operator|||
operator|(
operator|(
name|bktr_status
operator|&
literal|0xff000
operator|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|btl_reg
operator|=
operator|(
name|u_long
operator|*
operator|)
operator|&
name|bt848
index|[
name|BKTR_INT_STAT
index|]
expr_stmt|;
operator|*
name|btl_reg
operator|=
operator|*
name|btl_reg
expr_stmt|;
name|bts_reg
operator|=
operator|(
name|u_short
operator|*
operator|)
operator|&
name|bt848
index|[
name|BKTR_GPIO_DMA_CTL
index|]
expr_stmt|;
operator|*
name|bts_reg
operator|=
literal|0
expr_stmt|;
name|btl_reg
operator|=
operator|(
name|u_long
operator|*
operator|)
operator|&
name|bt848
index|[
name|BKTR_INT_MASK
index|]
expr_stmt|;
operator|*
name|btl_reg
operator|=
literal|0
expr_stmt|;
name|btl_reg
operator|=
operator|(
name|u_long
operator|*
operator|)
operator|&
name|bt848
index|[
name|BKTR_RISC_STRT_ADD
index|]
expr_stmt|;
operator|*
name|btl_reg
operator|=
name|vtophys
argument_list|(
name|bktr
operator|->
name|dma_prog
argument_list|)
expr_stmt|;
name|bts_reg
operator|=
operator|(
name|u_short
operator|*
operator|)
operator|&
name|bt848
index|[
name|BKTR_GPIO_DMA_CTL
index|]
expr_stmt|;
operator|*
name|bts_reg
operator|=
literal|1
expr_stmt|;
operator|*
name|bts_reg
operator|=
name|bktr
operator|->
name|capcontrol
expr_stmt|;
name|btl_reg
operator|=
operator|(
name|u_long
operator|*
operator|)
operator|&
name|bt848
index|[
name|BKTR_INT_MASK
index|]
expr_stmt|;
operator|*
name|btl_reg
operator|=
literal|1
operator|<<
literal|23
operator||
literal|1
operator|<<
literal|11
operator||
literal|2
operator||
literal|1
expr_stmt|;
name|bt848
index|[
name|BKTR_CAP_CTL
index|]
operator|=
name|bktr
operator|->
name|bktr_cap_ctl
expr_stmt|;
return|return;
block|}
name|btl_reg
operator|=
operator|(
name|u_long
operator|*
operator|)
operator|&
name|bt848
index|[
name|BKTR_CAP_CTL
index|]
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|bktr_status
operator|&
operator|(
literal|1
operator|<<
literal|11
operator|)
operator|)
condition|)
return|return;
name|bktr_pc
operator|=
operator|(
name|u_long
operator|*
operator|)
operator|&
name|bt848
index|[
name|BKTR_RISC_COUNT
index|]
expr_stmt|;
comment|/*printf("intr status %x %x %x\n", bktr_status, s_status, *bktr_pc);*/
comment|/* 	 * Disable future interrupts if a capture mode is not selected. 	 * This can happen when we are in the process of closing or  	 * changing capture modes, otherwise it shouldn't happen. 	 */
if|if
condition|(
operator|!
operator|(
name|bktr
operator|->
name|flags
operator|&
name|METEOR_CAP_MASK
operator|)
condition|)
operator|*
name|btl_reg
operator|=
literal|0
expr_stmt|;
comment|/* 	 * If we have a complete frame. 	 */
if|if
condition|(
operator|!
operator|(
name|bktr
operator|->
name|flags
operator|&
name|METEOR_WANT_MASK
operator|)
condition|)
block|{
name|bktr
operator|->
name|frames_captured
operator|++
expr_stmt|;
comment|/* 		 * post the completion time.  		 */
if|if
condition|(
name|bktr
operator|->
name|flags
operator|&
name|METEOR_WANT_TS
condition|)
block|{
name|struct
name|timeval
modifier|*
name|ts
decl_stmt|;
if|if
condition|(
operator|(
name|u_int
operator|)
name|bktr
operator|->
name|alloc_pages
operator|*
name|PAGE_SIZE
operator|<=
operator|(
name|bktr
operator|->
name|frame_size
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|timeval
argument_list|)
operator|)
condition|)
block|{
name|ts
operator|=
operator|(
expr|struct
name|timeval
operator|*
operator|)
name|bktr
operator|->
name|bigbuf
operator|+
name|bktr
operator|->
name|frame_size
expr_stmt|;
comment|/* doesn't work in synch mode except 				 *  for first frame */
comment|/* XXX */
name|microtime
argument_list|(
name|ts
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 		 * Wake up the user in single capture mode. 		 */
if|if
condition|(
name|bktr
operator|->
name|flags
operator|&
name|METEOR_SINGLE
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|bktr_status
operator|&
operator|(
literal|1
operator|<<
literal|24
operator|)
operator|)
condition|)
return|return;
comment|/* stop dma */
name|btl_reg
operator|=
operator|(
name|u_long
operator|*
operator|)
operator|&
name|bt848
index|[
name|BKTR_INT_MASK
index|]
expr_stmt|;
operator|*
name|btl_reg
operator|=
literal|0
expr_stmt|;
name|bts_reg
operator|=
operator|(
name|u_short
operator|*
operator|)
operator|&
name|bt848
index|[
name|BKTR_GPIO_DMA_CTL
index|]
expr_stmt|;
operator|*
name|bts_reg
operator|=
literal|1
expr_stmt|;
comment|/* disable risc and fifo */
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
name|bktr
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * If the user requested to be notified via signal, 		 * let them know the frame is complete. 		 */
if|if
condition|(
name|bktr
operator|->
name|proc
operator|&&
operator|!
operator|(
name|bktr
operator|->
name|signal
operator|&
name|METEOR_SIG_MODE_MASK
operator|)
condition|)
name|psignal
argument_list|(
name|bktr
operator|->
name|proc
argument_list|,
name|bktr
operator|->
name|signal
operator|&
operator|(
operator|~
name|METEOR_SIG_MODE_MASK
operator|)
argument_list|)
expr_stmt|;
comment|/* 		 * Reset the want flags if in continuous or 		 * synchronous capture mode. 		 */
if|if
condition|(
name|bktr
operator|->
name|flags
operator|&
operator|(
name|METEOR_CONTIN
operator||
name|METEOR_SYNCAP
operator|)
condition|)
block|{
switch|switch
condition|(
name|bktr
operator|->
name|flags
operator|&
name|METEOR_ONLY_FIELDS_MASK
condition|)
block|{
case|case
name|METEOR_ONLY_ODD_FIELDS
case|:
name|bktr
operator|->
name|flags
operator||=
name|METEOR_WANT_ODD
expr_stmt|;
break|break;
case|case
name|METEOR_ONLY_EVEN_FIELDS
case|:
name|bktr
operator|->
name|flags
operator||=
name|METEOR_WANT_EVEN
expr_stmt|;
break|break;
default|default:
name|bktr
operator|->
name|flags
operator||=
name|METEOR_WANT_MASK
expr_stmt|;
break|break;
block|}
block|}
block|}
return|return;
block|}
end_function

begin_comment
comment|/*  *   */
end_comment

begin_function
name|int
name|dump_bt848
parameter_list|(
specifier|volatile
name|u_char
modifier|*
name|bt848
parameter_list|)
block|{
name|u_long
modifier|*
name|bt_long
decl_stmt|;
name|u_short
modifier|*
name|bt_short
decl_stmt|;
name|int
name|r
index|[
literal|60
index|]
init|=
block|{
literal|4
block|,
literal|8
block|,
literal|0xc
block|,
literal|0x8c
block|,
literal|0x10
block|,
literal|0x90
block|,
literal|0x14
block|,
literal|0x94
block|,
literal|0x18
block|,
literal|0x98
block|,
literal|0x1c
block|,
literal|0x9c
block|,
literal|0x20
block|,
literal|0xa0
block|,
literal|0x24
block|,
literal|0xa4
block|,
literal|0x28
block|,
literal|0x2c
block|,
literal|0xac
block|,
literal|0x30
block|,
literal|0x34
block|,
literal|0x38
block|,
literal|0x3c
block|,
literal|0x40
block|,
literal|0xc0
block|,
literal|0x48
block|,
literal|0x4c
block|,
literal|0xcc
block|,
literal|0x50
block|,
literal|0xd0
block|,
literal|0xd4
block|,
literal|0x60
block|,
literal|0x64
block|,
literal|0x68
block|,
literal|0x6c
block|,
literal|0xec
block|,
literal|0xd8
block|,
literal|0xdc
block|,
literal|0xe0
block|,
literal|0xe4
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|40
condition|;
name|i
operator|+=
literal|4
control|)
block|{
name|printf
argument_list|(
literal|" Reg:value : \t%x:%x \t%x:%x \t %x:%x \t %x:%x\n"
argument_list|,
name|r
index|[
name|i
index|]
argument_list|,
name|bt848
index|[
name|r
index|[
name|i
index|]
index|]
argument_list|,
name|r
index|[
name|i
operator|+
literal|1
index|]
argument_list|,
name|bt848
index|[
name|r
index|[
name|i
operator|+
literal|1
index|]
index|]
argument_list|,
name|r
index|[
name|i
operator|+
literal|2
index|]
argument_list|,
name|bt848
index|[
name|r
index|[
name|i
operator|+
literal|2
index|]
index|]
argument_list|,
name|r
index|[
name|i
operator|+
literal|3
index|]
argument_list|,
name|bt848
index|[
name|r
index|[
name|i
operator|+
literal|3
index|]
index|]
argument_list|)
expr_stmt|;
block|}
name|bt_long
operator|=
operator|(
name|u_long
operator|*
operator|)
operator|&
name|bt848
index|[
name|BKTR_INT_STAT
index|]
expr_stmt|;
name|printf
argument_list|(
literal|" Reg 100 %x \n"
argument_list|,
operator|*
name|bt_long
argument_list|)
expr_stmt|;
name|bt_long
operator|=
operator|(
name|u_long
operator|*
operator|)
operator|&
name|bt848
index|[
name|BKTR_INT_MASK
index|]
expr_stmt|;
name|printf
argument_list|(
literal|" Reg 104 %x \n"
argument_list|,
operator|*
name|bt_long
argument_list|)
expr_stmt|;
name|bt_long
operator|=
operator|(
name|u_long
operator|*
operator|)
operator|&
name|bt848
index|[
name|BKTR_GPIO_DMA_CTL
index|]
expr_stmt|;
name|printf
argument_list|(
literal|" Reg 10C %x \n"
argument_list|,
operator|*
name|bt_long
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * build write instruction  */
end_comment

begin_define
define|#
directive|define
name|BKTR_FM1
value|0x6
end_define

begin_define
define|#
directive|define
name|BKTR_FM3
value|0xe
end_define

begin_define
define|#
directive|define
name|BKTR_VRE
value|0x4
end_define

begin_define
define|#
directive|define
name|BKTR_VRO
value|0xC
end_define

begin_define
define|#
directive|define
name|BKTR_PXV
value|0x0
end_define

begin_define
define|#
directive|define
name|BKTR_EOL
value|0x1
end_define

begin_define
define|#
directive|define
name|BKTR_SOL
value|0x2
end_define

begin_define
define|#
directive|define
name|OP_WRITE
value|0x1<< 28
end_define

begin_define
define|#
directive|define
name|OP_WRITEC
value|0x5<< 28
end_define

begin_define
define|#
directive|define
name|OP_JUMP
value|0x7<< 28
end_define

begin_define
define|#
directive|define
name|OP_SYNC
value|0x8<< 28
end_define

begin_define
define|#
directive|define
name|OP_WRITE123
value|0x9<< 28
end_define

begin_define
define|#
directive|define
name|OP_WRITES123
value|0xb<< 28
end_define

begin_define
define|#
directive|define
name|OP_SOL
value|1<< 27
end_define

begin_define
define|#
directive|define
name|OP_EOL
value|1<< 26
end_define

begin_function
name|void
name|rgb_prog
parameter_list|(
name|bktr_reg_t
modifier|*
name|bktr
parameter_list|,
name|char
name|i_flag
parameter_list|,
name|int
name|cols
parameter_list|,
name|int
name|rows
parameter_list|,
name|int
name|pixel_width
parameter_list|,
name|int
name|interlace
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|byte_count
decl_stmt|;
specifier|volatile
name|unsigned
name|int
name|inst
decl_stmt|;
specifier|volatile
name|unsigned
name|int
name|inst2
decl_stmt|;
specifier|volatile
name|unsigned
name|int
name|inst3
decl_stmt|;
specifier|volatile
name|u_long
name|target_buffer
decl_stmt|,
name|buffer
decl_stmt|;
specifier|volatile
name|u_char
modifier|*
name|bt848
decl_stmt|,
modifier|*
name|bt_reg
decl_stmt|;
specifier|volatile
name|u_short
modifier|*
name|bts_reg
decl_stmt|;
specifier|volatile
name|u_long
name|pitch
decl_stmt|;
specifier|volatile
name|u_long
modifier|*
name|dma_prog
decl_stmt|,
modifier|*
name|foo
decl_stmt|,
modifier|*
name|btl_reg
decl_stmt|,
modifier|*
name|t_test
decl_stmt|;
name|int
name|b
decl_stmt|,
name|c
decl_stmt|;
name|bt848
operator|=
name|bktr
operator|->
name|base
expr_stmt|;
comment|/* color format : rgb32 */
if|if
condition|(
name|bktr
operator|->
name|depth
operator|==
literal|4
condition|)
name|bt848
index|[
name|BKTR_COLOR_FMT
index|]
operator|=
literal|0
expr_stmt|;
else|else
name|bt848
index|[
name|BKTR_COLOR_FMT
index|]
operator|=
literal|0x33
expr_stmt|;
name|bt848
index|[
name|BKTR_COLOR_CTL
index|]
operator|=
literal|0x40
expr_stmt|;
name|bt848
index|[
name|BKTR_COLOR_CTL
index|]
operator|=
literal|0x10
expr_stmt|;
if|#
directive|if
literal|0
block|bt848[0x10] = 0x1C; 	bt848[0x90] = 0x1C;
endif|#
directive|endif
name|bt848
index|[
name|BKTR_VBI_PACK_SIZE
index|]
operator|=
literal|0
expr_stmt|;
name|bt848
index|[
name|BKTR_VBI_PACK_DEL
index|]
operator|=
literal|0
expr_stmt|;
name|bt848
index|[
name|BKTR_ADC
index|]
operator|=
literal|0x81
expr_stmt|;
name|bt848
index|[
name|BKTR_COLOR_CTL
index|]
operator|=
literal|0x20
expr_stmt|;
name|bt848
index|[
name|BKTR_E_VSCALE_HI
index|]
operator||=
literal|0xc0
expr_stmt|;
name|bt848
index|[
name|BKTR_O_VSCALE_HI
index|]
operator||=
literal|0xc0
expr_stmt|;
name|bktr
operator|->
name|capcontrol
operator|=
literal|3
operator|<<
literal|2
operator||
literal|3
expr_stmt|;
name|dma_prog
operator|=
operator|(
name|u_long
operator|*
operator|)
name|bktr
operator|->
name|dma_prog
expr_stmt|;
comment|/* Construct Write */
name|bt_enable_cnt
operator|=
literal|0
expr_stmt|;
name|b
operator|=
operator|(
name|cols
operator|*
name|pixel_width
operator|)
operator|/
literal|2
expr_stmt|;
comment|/* write, sol, eol */
name|inst
operator|=
name|OP_WRITE
operator||
name|OP_SOL
operator||
name|bt_enable_cnt
operator|<<
literal|12
operator||
operator|(
name|b
operator|)
expr_stmt|;
name|inst2
operator|=
name|OP_WRITE
operator||
name|bt_enable_cnt
operator|<<
literal|12
operator||
operator|(
name|cols
operator|*
name|pixel_width
operator|/
literal|2
operator|)
expr_stmt|;
comment|/* write , sol, eol */
name|inst3
operator|=
name|OP_WRITE
operator||
name|OP_EOL
operator||
name|bt_enable_cnt
operator|<<
literal|12
operator||
operator|(
name|b
operator|)
expr_stmt|;
if|if
condition|(
name|bktr
operator|->
name|video
operator|.
name|addr
condition|)
block|{
name|target_buffer
operator|=
operator|(
name|u_long
operator|)
name|bktr
operator|->
name|video
operator|.
name|addr
expr_stmt|;
name|pitch
operator|=
name|bktr
operator|->
name|video
operator|.
name|width
expr_stmt|;
block|}
else|else
block|{
name|target_buffer
operator|=
operator|(
name|u_long
operator|)
name|vtophys
argument_list|(
name|bktr
operator|->
name|bigbuf
argument_list|)
expr_stmt|;
name|pitch
operator|=
name|cols
operator|*
name|pixel_width
expr_stmt|;
block|}
name|buffer
operator|=
name|target_buffer
expr_stmt|;
comment|/* contruct sync : for video packet format */
operator|*
name|dma_prog
operator|++
operator|=
name|OP_SYNC
operator||
literal|0xC
operator|<<
literal|24
operator||
literal|1
operator|<<
literal|15
operator||
name|BKTR_FM1
expr_stmt|;
comment|/* sync, mode indicator packed data */
operator|*
name|dma_prog
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* NULL WORD */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|rows
operator|/
name|interlace
operator|)
condition|;
name|i
operator|++
control|)
block|{
operator|*
name|dma_prog
operator|++
operator|=
name|inst
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
name|target_buffer
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
name|inst3
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
name|target_buffer
operator|+
name|b
expr_stmt|;
name|target_buffer
operator|+=
name|interlace
operator|*
name|pitch
expr_stmt|;
block|}
switch|switch
condition|(
name|i_flag
condition|)
block|{
case|case
literal|1
case|:
comment|/* sync vre */
operator|*
name|dma_prog
operator|++
operator|=
name|OP_SYNC
operator||
literal|0xC
operator|<<
literal|24
operator||
literal|1
operator|<<
literal|24
operator||
name|BKTR_VRE
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* NULL WORD */
operator|*
name|dma_prog
operator|++
operator|=
name|OP_JUMP
operator||
literal|0xC
operator|<<
literal|24
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
operator|(
name|u_long
operator|)
name|vtophys
argument_list|(
name|bktr
operator|->
name|dma_prog
argument_list|)
expr_stmt|;
return|return;
case|case
literal|2
case|:
comment|/* sync vre */
operator|*
name|dma_prog
operator|++
operator|=
name|OP_SYNC
operator||
literal|1
operator|<<
literal|24
operator||
literal|1
operator|<<
literal|20
operator||
name|BKTR_VRO
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* NULL WORD */
operator|*
name|dma_prog
operator|++
operator|=
name|OP_JUMP
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
operator|(
name|u_long
operator|)
name|vtophys
argument_list|(
name|bktr
operator|->
name|dma_prog
argument_list|)
expr_stmt|;
return|return;
case|case
literal|3
case|:
comment|/* sync vre */
operator|*
name|dma_prog
operator|++
operator|=
name|OP_SYNC
operator||
literal|0xC
operator|<<
literal|24
operator||
literal|1
operator|<<
literal|24
operator||
literal|1
operator|<<
literal|15
operator||
name|BKTR_VRO
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* NULL WORD */
operator|*
name|dma_prog
operator|++
operator|=
name|OP_JUMP
operator||
literal|0xc
operator|<<
literal|24
expr_stmt|;
operator|*
name|dma_prog
operator|=
operator|(
name|u_long
operator|)
name|vtophys
argument_list|(
name|bktr
operator|->
name|odd_dma_prog
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|interlace
operator|==
literal|2
condition|)
block|{
name|target_buffer
operator|=
operator|(
name|u_long
operator|)
name|buffer
operator|+
name|pitch
expr_stmt|;
name|dma_prog
operator|=
operator|(
name|u_long
operator|*
operator|)
name|bktr
operator|->
name|odd_dma_prog
expr_stmt|;
comment|/* sync vre IRQ bit */
operator|*
name|dma_prog
operator|++
operator|=
name|OP_SYNC
operator||
literal|0xc
operator|<<
literal|24
operator||
literal|1
operator|<<
literal|15
operator||
name|BKTR_FM1
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* NULL WORD */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|rows
operator|/
name|interlace
operator|)
condition|;
name|i
operator|++
control|)
block|{
operator|*
name|dma_prog
operator|++
operator|=
name|inst
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
name|target_buffer
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
name|inst3
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
name|target_buffer
operator|+
name|b
expr_stmt|;
name|target_buffer
operator|+=
name|interlace
operator|*
name|pitch
expr_stmt|;
block|}
block|}
comment|/* sync vre IRQ bit */
operator|*
name|dma_prog
operator|++
operator|=
name|OP_SYNC
operator||
literal|0xc
operator|<<
literal|24
operator||
literal|1
operator|<<
literal|24
operator||
literal|1
operator|<<
literal|15
operator||
name|BKTR_VRE
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* NULL WORD */
operator|*
name|dma_prog
operator|++
operator|=
name|OP_JUMP
operator||
literal|0xc
operator|<<
literal|24
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
operator|(
name|u_long
operator|)
name|vtophys
argument_list|(
name|bktr
operator|->
name|dma_prog
argument_list|)
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* NULL WORD */
block|}
end_function

begin_comment
comment|/*  *   */
end_comment

begin_function
name|void
name|yuvpack_prog
parameter_list|(
name|bktr_reg_t
modifier|*
name|bktr
parameter_list|,
name|char
name|i_flag
parameter_list|,
name|int
name|cols
parameter_list|,
name|int
name|rows
parameter_list|,
name|int
name|interlace
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|byte_count
decl_stmt|;
specifier|volatile
name|unsigned
name|int
name|inst
decl_stmt|;
specifier|volatile
name|unsigned
name|int
name|inst2
decl_stmt|;
specifier|volatile
name|unsigned
name|int
name|inst3
decl_stmt|;
specifier|volatile
name|u_long
name|target_buffer
decl_stmt|,
name|buffer
decl_stmt|;
specifier|volatile
name|u_char
modifier|*
name|bt848
decl_stmt|,
modifier|*
name|bt_reg
decl_stmt|;
specifier|volatile
name|u_short
modifier|*
name|bts_reg
decl_stmt|;
specifier|volatile
name|u_long
modifier|*
name|dma_prog
decl_stmt|,
modifier|*
name|foo
decl_stmt|,
modifier|*
name|btl_reg
decl_stmt|;
name|int
name|b
decl_stmt|;
name|bt848
operator|=
name|bktr
operator|->
name|base
expr_stmt|;
comment|/* color format : yuvpack */
name|bt848
index|[
name|BKTR_COLOR_FMT
index|]
operator|=
literal|0x44
expr_stmt|;
name|bt848
index|[
name|BKTR_E_SCLOOP
index|]
operator||=
literal|0x40
expr_stmt|;
comment|/* enable chroma comb */
name|bt848
index|[
name|BKTR_O_SCLOOP
index|]
operator||=
literal|0x40
expr_stmt|;
name|bt848
index|[
name|BKTR_COLOR_CTL
index|]
operator|=
literal|0x30
expr_stmt|;
name|bt848
index|[
name|BKTR_ADC
index|]
operator|=
literal|0x81
expr_stmt|;
name|bktr
operator|->
name|capcontrol
operator|=
literal|1
operator|<<
literal|6
operator||
literal|1
operator|<<
literal|4
operator||
literal|1
operator|<<
literal|2
operator||
literal|3
expr_stmt|;
name|bktr
operator|->
name|capcontrol
operator|=
literal|1
operator|<<
literal|5
operator||
literal|1
operator|<<
literal|4
operator||
literal|1
operator|<<
literal|2
operator||
literal|3
expr_stmt|;
name|dma_prog
operator|=
operator|(
name|u_long
operator|*
operator|)
name|bktr
operator|->
name|dma_prog
expr_stmt|;
comment|/* Construct Write */
name|bt_enable_cnt
operator|=
literal|0
expr_stmt|;
comment|/* write , sol, eol */
name|inst
operator|=
name|OP_WRITE
operator||
name|OP_SOL
operator||
literal|0xf
operator|<<
literal|16
operator||
name|bt_enable_cnt
operator|<<
literal|12
operator||
operator|(
name|cols
operator|*
literal|2
operator|)
expr_stmt|;
comment|/* write , sol, eol */
name|inst3
operator|=
name|OP_WRITE
operator||
name|OP_EOL
operator||
literal|0xf
operator|<<
literal|16
operator||
name|bt_enable_cnt
operator|<<
literal|12
operator||
operator|(
name|cols
operator|)
expr_stmt|;
name|inst2
operator|=
name|OP_WRITE
operator||
name|bt_enable_cnt
operator|<<
literal|12
operator||
operator|(
name|cols
operator|)
expr_stmt|;
if|if
condition|(
name|bktr
operator|->
name|video
operator|.
name|addr
condition|)
name|target_buffer
operator|=
operator|(
name|u_long
operator|)
name|bktr
operator|->
name|video
operator|.
name|addr
expr_stmt|;
else|else
name|target_buffer
operator|=
operator|(
name|u_long
operator|)
name|vtophys
argument_list|(
name|bktr
operator|->
name|bigbuf
argument_list|)
expr_stmt|;
name|buffer
operator|=
name|target_buffer
expr_stmt|;
comment|/* contruct sync : for video packet format */
comment|/* sync, mode indicator packed data */
operator|*
name|dma_prog
operator|++
operator|=
name|OP_SYNC
operator||
literal|1
operator|<<
literal|24
operator||
literal|1
operator|<<
literal|15
operator||
name|BKTR_FM1
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* NULL WORD */
name|b
operator|=
name|cols
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|rows
operator|/
name|interlace
operator|)
condition|;
name|i
operator|++
control|)
block|{
operator|*
name|dma_prog
operator|++
operator|=
name|inst
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
name|target_buffer
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
name|inst3
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
name|target_buffer
operator|+
name|b
expr_stmt|;
name|target_buffer
operator|+=
name|interlace
operator|*
operator|(
name|cols
operator|*
literal|2
operator|)
expr_stmt|;
block|}
switch|switch
condition|(
name|i_flag
condition|)
block|{
case|case
literal|1
case|:
comment|/* sync vre */
operator|*
name|dma_prog
operator|++
operator|=
name|OP_SYNC
operator||
literal|1
operator|<<
literal|24
operator||
name|BKTR_VRE
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* NULL WORD */
operator|*
name|dma_prog
operator|++
operator|=
name|OP_JUMP
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
operator|(
name|u_long
operator|)
name|vtophys
argument_list|(
name|bktr
operator|->
name|dma_prog
argument_list|)
expr_stmt|;
return|return;
case|case
literal|2
case|:
comment|/* sync vre */
operator|*
name|dma_prog
operator|++
operator|=
name|OP_SYNC
operator||
literal|1
operator|<<
literal|24
operator||
literal|1
operator|<<
literal|20
operator||
name|BKTR_VRO
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* NULL WORD */
operator|*
name|dma_prog
operator|++
operator|=
name|OP_JUMP
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
operator|(
name|u_long
operator|)
name|vtophys
argument_list|(
name|bktr
operator|->
name|dma_prog
argument_list|)
expr_stmt|;
return|return;
case|case
literal|3
case|:
comment|/* sync vre */
operator|*
name|dma_prog
operator|++
operator|=
name|OP_SYNC
operator||
literal|1
operator|<<
literal|24
operator||
literal|0xf
operator|<<
literal|16
operator||
name|BKTR_VRE
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* NULL WORD */
operator|*
name|dma_prog
operator|++
operator|=
name|OP_JUMP
expr_stmt|;
operator|*
name|dma_prog
operator|=
operator|(
name|u_long
operator|)
name|vtophys
argument_list|(
name|bktr
operator|->
name|odd_dma_prog
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|interlace
operator|==
literal|2
condition|)
block|{
name|target_buffer
operator|=
operator|(
name|u_long
operator|)
name|buffer
operator|+
name|cols
operator|*
literal|2
expr_stmt|;
name|dma_prog
operator|=
operator|(
name|u_long
operator|*
operator|)
name|bktr
operator|->
name|odd_dma_prog
expr_stmt|;
comment|/* sync vre */
operator|*
name|dma_prog
operator|++
operator|=
name|OP_SYNC
operator||
literal|1
operator|<<
literal|24
operator||
literal|0xf
operator|<<
literal|16
operator||
literal|1
operator|<<
literal|15
operator||
name|BKTR_FM1
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* NULL WORD */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|rows
operator|/
name|interlace
operator|)
condition|;
name|i
operator|++
control|)
block|{
operator|*
name|dma_prog
operator|++
operator|=
name|inst
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
name|target_buffer
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
name|inst3
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
name|target_buffer
operator|+
name|b
expr_stmt|;
name|target_buffer
operator|+=
name|interlace
operator|*
operator|(
name|cols
operator|*
literal|2
operator|)
expr_stmt|;
block|}
block|}
comment|/* sync vre IRQ bit */
operator|*
name|dma_prog
operator|++
operator|=
name|OP_SYNC
operator||
literal|1
operator|<<
literal|24
operator||
literal|0xf
operator|<<
literal|16
operator||
name|BKTR_VRO
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* NULL WORD */
operator|*
name|dma_prog
operator|++
operator|=
name|OP_JUMP
operator||
literal|0xf
operator|<<
literal|16
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
operator|(
name|u_long
operator|)
name|vtophys
argument_list|(
name|bktr
operator|->
name|dma_prog
argument_list|)
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
name|OP_JUMP
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
operator|(
name|u_long
operator|)
name|vtophys
argument_list|(
name|bktr
operator|->
name|dma_prog
argument_list|)
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* NULL WORD */
block|}
end_function

begin_comment
comment|/*  *   */
end_comment

begin_function
name|void
name|yuv422_prog
parameter_list|(
name|bktr_reg_t
modifier|*
name|bktr
parameter_list|,
name|char
name|i_flag
parameter_list|,
name|int
name|cols
parameter_list|,
name|int
name|rows
parameter_list|,
name|int
name|interlace
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|int
name|byte_count
decl_stmt|;
specifier|volatile
name|unsigned
name|int
name|inst
decl_stmt|;
specifier|volatile
name|unsigned
name|int
name|inst2
decl_stmt|;
specifier|volatile
name|unsigned
name|int
name|instskip
decl_stmt|,
name|instskip2
decl_stmt|,
name|instskip3
decl_stmt|;
specifier|volatile
name|unsigned
name|int
name|inst3
decl_stmt|;
specifier|volatile
name|u_long
name|target_buffer
decl_stmt|,
name|t1
decl_stmt|,
name|buffer
decl_stmt|;
specifier|volatile
name|u_char
modifier|*
name|bt848
decl_stmt|,
modifier|*
name|bt_reg
decl_stmt|;
specifier|volatile
name|u_short
modifier|*
name|bts_reg
decl_stmt|;
specifier|volatile
name|u_long
modifier|*
name|dma_prog
decl_stmt|,
modifier|*
name|foo
decl_stmt|,
modifier|*
name|btl_reg
decl_stmt|;
name|int
name|b
decl_stmt|,
name|b1
decl_stmt|;
name|bt848
operator|=
name|bktr
operator|->
name|base
expr_stmt|;
name|dma_prog
operator|=
operator|(
name|u_long
operator|*
operator|)
name|bktr
operator|->
name|dma_prog
expr_stmt|;
name|bktr
operator|->
name|capcontrol
operator|=
literal|1
operator|<<
literal|6
operator||
literal|1
operator|<<
literal|4
operator||
literal|3
expr_stmt|;
name|bt848
index|[
name|BKTR_ADC
index|]
operator|=
literal|0x81
expr_stmt|;
name|bt848
index|[
name|BKTR_OFORM
index|]
operator|=
literal|0x00
expr_stmt|;
name|bt848
index|[
name|BKTR_E_CONTROL
index|]
operator||=
literal|0x20
expr_stmt|;
comment|/* disable luma decimation */
name|bt848
index|[
name|BKTR_O_CONTROL
index|]
operator||=
literal|0x20
expr_stmt|;
name|bt848
index|[
name|BKTR_E_SCLOOP
index|]
operator||=
literal|0x40
expr_stmt|;
comment|/* chroma agc enable */
name|bt848
index|[
name|BKTR_O_SCLOOP
index|]
operator||=
literal|0x40
expr_stmt|;
name|bt848
index|[
name|BKTR_E_VSCALE_HI
index|]
operator||=
literal|0xc0
expr_stmt|;
comment|/* luma comb and comb enable */
name|bt848
index|[
name|BKTR_O_VSCALE_HI
index|]
operator||=
literal|0xc0
expr_stmt|;
name|bt848
index|[
name|BKTR_COLOR_FMT
index|]
operator|=
literal|0x88
expr_stmt|;
name|bt848
index|[
name|BKTR_COLOR_CTL
index|]
operator|=
literal|0x10
expr_stmt|;
comment|/* disable gamma correction */
name|bt_enable_cnt
operator|=
literal|0
expr_stmt|;
comment|/* Construct Write */
name|inst
operator|=
name|OP_WRITE123
operator||
name|OP_SOL
operator||
name|OP_EOL
operator||
name|bt_enable_cnt
operator|<<
literal|12
operator||
operator|(
name|cols
operator|)
expr_stmt|;
name|inst2
operator|=
name|OP_WRITES123
operator||
name|OP_SOL
operator||
name|OP_EOL
operator||
name|bt_enable_cnt
operator|<<
literal|12
operator||
operator|(
name|cols
operator|)
expr_stmt|;
if|if
condition|(
name|bktr
operator|->
name|video
operator|.
name|addr
condition|)
name|target_buffer
operator|=
operator|(
name|u_long
operator|)
name|bktr
operator|->
name|video
operator|.
name|addr
expr_stmt|;
else|else
name|target_buffer
operator|=
operator|(
name|u_long
operator|)
name|vtophys
argument_list|(
name|bktr
operator|->
name|bigbuf
argument_list|)
expr_stmt|;
name|buffer
operator|=
name|target_buffer
expr_stmt|;
name|t1
operator|=
name|target_buffer
expr_stmt|;
comment|/* contruct sync : for video packet format */
operator|*
name|dma_prog
operator|++
operator|=
name|OP_SYNC
operator||
literal|0xC
operator|<<
literal|24
operator||
literal|1
operator|<<
literal|15
operator||
name|BKTR_FM3
expr_stmt|;
comment|/*sync, mode indicator packed data*/
operator|*
name|dma_prog
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* NULL WORD */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|rows
operator|/
name|interlace
operator|)
condition|;
name|i
operator|++
control|)
block|{
operator|*
name|dma_prog
operator|++
operator|=
name|inst
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
name|cols
operator|/
literal|2
operator||
name|cols
operator|/
literal|2
operator|<<
literal|16
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
name|target_buffer
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
name|t1
operator|+
operator|(
name|cols
operator|*
name|rows
operator|)
operator|+
name|i
operator|*
name|cols
operator|/
literal|2
operator|*
name|interlace
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
name|t1
operator|+
operator|(
name|cols
operator|*
name|rows
operator|)
operator|+
operator|(
name|cols
operator|*
name|rows
operator|/
literal|2
operator|)
operator|+
name|i
operator|*
name|cols
operator|/
literal|2
operator|*
name|interlace
expr_stmt|;
name|target_buffer
operator|+=
name|interlace
operator|*
name|cols
expr_stmt|;
block|}
switch|switch
condition|(
name|i_flag
condition|)
block|{
case|case
literal|1
case|:
operator|*
name|dma_prog
operator|++
operator|=
name|OP_SYNC
operator||
literal|0xC
operator|<<
literal|24
operator||
literal|1
operator|<<
literal|24
operator||
name|BKTR_VRE
expr_stmt|;
comment|/*sync vre*/
operator|*
name|dma_prog
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* NULL WORD */
operator|*
name|dma_prog
operator|++
operator|=
name|OP_JUMP
operator||
literal|0xc
operator|<<
literal|24
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
operator|(
name|u_long
operator|)
name|vtophys
argument_list|(
name|bktr
operator|->
name|dma_prog
argument_list|)
expr_stmt|;
return|return;
break|break;
case|case
literal|2
case|:
operator|*
name|dma_prog
operator|++
operator|=
name|OP_SYNC
operator||
literal|0xC
operator|<<
literal|24
operator||
literal|1
operator|<<
literal|24
operator||
name|BKTR_VRO
expr_stmt|;
comment|/*sync vre*/
operator|*
name|dma_prog
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* NULL WORD */
operator|*
name|dma_prog
operator|++
operator|=
name|OP_JUMP
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
operator|(
name|u_long
operator|)
name|vtophys
argument_list|(
name|bktr
operator|->
name|dma_prog
argument_list|)
expr_stmt|;
return|return;
break|break;
case|case
literal|3
case|:
operator|*
name|dma_prog
operator|++
operator|=
name|OP_SYNC
operator||
literal|0xc
operator|<<
literal|24
operator||
literal|1
operator|<<
literal|15
operator||
name|BKTR_VRO
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* NULL WORD */
operator|*
name|dma_prog
operator|++
operator|=
name|OP_JUMP
operator||
literal|0xc
operator|<<
literal|24
expr_stmt|;
operator|*
name|dma_prog
operator|=
operator|(
name|u_long
operator|)
name|vtophys
argument_list|(
name|bktr
operator|->
name|odd_dma_prog
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|interlace
operator|==
literal|2
condition|)
block|{
name|dma_prog
operator|=
operator|(
name|u_long
operator|*
operator|)
name|bktr
operator|->
name|odd_dma_prog
expr_stmt|;
name|target_buffer
operator|=
operator|(
name|u_long
operator|)
name|buffer
operator|+
name|cols
expr_stmt|;
name|t1
operator|=
name|target_buffer
operator|+
name|cols
operator|/
literal|2
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
name|OP_SYNC
operator||
literal|0xc
operator|<<
literal|24
operator||
literal|1
operator|<<
literal|24
operator||
literal|1
operator|<<
literal|15
operator||
name|BKTR_FM3
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* NULL WORD */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|rows
operator|/
name|interlace
operator|)
condition|;
name|i
operator|++
control|)
block|{
operator|*
name|dma_prog
operator|++
operator|=
name|inst
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
name|cols
operator|/
literal|2
operator||
name|cols
operator|/
literal|2
operator|<<
literal|16
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
name|target_buffer
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
name|t1
operator|+
operator|(
name|cols
operator|*
name|rows
operator|)
operator|+
name|i
operator|*
name|cols
operator|/
literal|2
operator|*
name|interlace
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
name|t1
operator|+
operator|(
name|cols
operator|*
name|rows
operator|)
operator|+
operator|(
name|cols
operator|*
name|rows
operator|/
literal|2
operator|)
operator|+
name|i
operator|*
name|cols
operator|/
literal|2
operator|*
name|interlace
expr_stmt|;
name|target_buffer
operator|+=
name|interlace
operator|*
name|cols
expr_stmt|;
block|}
block|}
operator|*
name|dma_prog
operator|++
operator|=
name|OP_SYNC
operator||
literal|0xC
operator|<<
literal|24
operator||
literal|1
operator|<<
literal|24
operator||
name|BKTR_VRE
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* NULL WORD */
operator|*
name|dma_prog
operator|++
operator|=
name|OP_JUMP
operator||
literal|0xC
operator|<<
literal|24
expr_stmt|;
empty_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
operator|(
name|u_long
operator|)
name|vtophys
argument_list|(
name|bktr
operator|->
name|dma_prog
argument_list|)
expr_stmt|;
operator|*
name|dma_prog
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* NULL WORD */
block|}
end_function

begin_comment
comment|/*  *   */
end_comment

begin_function
name|void
name|build_dma_prog
parameter_list|(
name|bktr_reg_t
modifier|*
name|bktr
parameter_list|,
name|char
name|i_flag
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|pixel_width
decl_stmt|,
name|rows
decl_stmt|,
name|cols
decl_stmt|,
name|byte_count
decl_stmt|,
name|interlace
decl_stmt|;
specifier|volatile
name|unsigned
name|int
name|inst
decl_stmt|;
specifier|volatile
name|unsigned
name|int
name|inst2
decl_stmt|;
specifier|volatile
name|unsigned
name|int
name|inst3
decl_stmt|;
specifier|volatile
name|u_long
name|target_buffer
decl_stmt|;
specifier|volatile
name|u_char
modifier|*
name|bt848
decl_stmt|,
modifier|*
name|bt_reg
decl_stmt|;
specifier|volatile
name|u_short
modifier|*
name|bts_reg
decl_stmt|;
specifier|volatile
name|u_long
modifier|*
name|dma_prog
decl_stmt|,
modifier|*
name|foo
decl_stmt|,
modifier|*
name|btl_reg
decl_stmt|;
name|int
name|b
decl_stmt|;
name|bt848
operator|=
name|bktr
operator|->
name|base
expr_stmt|;
name|btl_reg
operator|=
operator|(
name|u_long
operator|*
operator|)
operator|&
name|bt848
index|[
name|BKTR_INT_MASK
index|]
expr_stmt|;
operator|*
name|btl_reg
operator|=
literal|0
expr_stmt|;
name|bts_reg
operator|=
operator|(
name|u_short
operator|*
operator|)
operator|&
name|bt848
index|[
name|BKTR_GPIO_DMA_CTL
index|]
expr_stmt|;
operator|*
name|bts_reg
operator|&=
operator|~
literal|3
expr_stmt|;
comment|/* capture control */
switch|switch
condition|(
name|i_flag
condition|)
block|{
case|case
literal|1
case|:
name|bktr
operator|->
name|bktr_cap_ctl
operator|=
literal|0x11
expr_stmt|;
name|bt848
index|[
name|BKTR_CAP_CTL
index|]
operator|=
literal|0x11
expr_stmt|;
name|bt848
index|[
name|BKTR_E_VSCALE_HI
index|]
operator|&=
operator|~
literal|0x20
expr_stmt|;
name|bt848
index|[
name|BKTR_O_VSCALE_HI
index|]
operator|&=
operator|~
literal|0x20
expr_stmt|;
name|interlace
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|bktr
operator|->
name|bktr_cap_ctl
operator|=
literal|0x12
expr_stmt|;
name|bt848
index|[
name|BKTR_CAP_CTL
index|]
operator|=
literal|0x12
expr_stmt|;
name|bt848
index|[
name|BKTR_E_VSCALE_HI
index|]
operator|&=
operator|~
literal|0x20
expr_stmt|;
name|bt848
index|[
name|BKTR_O_VSCALE_HI
index|]
operator|&=
operator|~
literal|0x20
expr_stmt|;
name|interlace
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
name|bktr
operator|->
name|bktr_cap_ctl
operator|=
literal|0x13
expr_stmt|;
name|bt848
index|[
name|BKTR_CAP_CTL
index|]
operator|=
literal|0x13
expr_stmt|;
name|bt848
index|[
name|BKTR_E_VSCALE_HI
index|]
operator||=
literal|0x20
expr_stmt|;
name|bt848
index|[
name|BKTR_O_VSCALE_HI
index|]
operator||=
literal|0x20
expr_stmt|;
name|interlace
operator|=
literal|2
expr_stmt|;
break|break;
block|}
name|btl_reg
operator|=
operator|(
name|u_long
operator|*
operator|)
operator|&
name|bt848
index|[
name|BKTR_RISC_STRT_ADD
index|]
expr_stmt|;
operator|*
name|btl_reg
operator|=
name|vtophys
argument_list|(
name|bktr
operator|->
name|dma_prog
argument_list|)
expr_stmt|;
name|pixel_width
operator|=
name|bktr
operator|->
name|depth
expr_stmt|;
name|rows
operator|=
name|bktr
operator|->
name|rows
expr_stmt|;
name|cols
operator|=
name|bktr
operator|->
name|cols
expr_stmt|;
if|if
condition|(
name|bktr
operator|->
name|format
operator|==
name|METEOR_GEO_RGB24
operator|||
name|bktr
operator|->
name|format
operator|==
name|METEOR_GEO_RGB16
condition|)
block|{
name|rgb_prog
argument_list|(
name|bktr
argument_list|,
name|i_flag
argument_list|,
name|cols
argument_list|,
name|rows
argument_list|,
name|pixel_width
argument_list|,
name|interlace
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|bktr
operator|->
name|format
operator|==
name|METEOR_GEO_YUV_422
condition|)
block|{
name|yuv422_prog
argument_list|(
name|bktr
argument_list|,
name|i_flag
argument_list|,
name|cols
argument_list|,
name|rows
argument_list|,
name|interlace
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|bktr
operator|->
name|format
operator|==
name|METEOR_GEO_YUV_PACKED
condition|)
block|{
name|yuvpack_prog
argument_list|(
name|bktr
argument_list|,
name|i_flag
argument_list|,
name|cols
argument_list|,
name|rows
argument_list|,
name|interlace
argument_list|)
expr_stmt|;
return|return;
block|}
return|return;
block|}
end_function

begin_comment
comment|/*  *   */
end_comment

begin_function
name|void
name|start_capture
parameter_list|(
name|bktr_reg_t
modifier|*
name|bktr
parameter_list|,
name|unsigned
name|type
parameter_list|)
block|{
specifier|volatile
name|u_char
modifier|*
name|bt848
decl_stmt|,
modifier|*
name|bt_reg
decl_stmt|,
name|i_flag
decl_stmt|;
specifier|volatile
name|u_short
modifier|*
name|bts_reg
decl_stmt|;
specifier|volatile
name|u_long
modifier|*
name|btl_reg
decl_stmt|;
name|bt848
operator|=
operator|(
name|u_char
operator|*
operator|)
name|bktr
operator|->
name|base
expr_stmt|;
operator|*
name|bt848
operator|=
literal|0
expr_stmt|;
name|btl_reg
operator|=
operator|(
name|u_long
operator|*
operator|)
operator|&
name|bt848
index|[
name|BKTR_INT_STAT
index|]
expr_stmt|;
operator|*
name|btl_reg
operator|=
operator|*
name|btl_reg
expr_stmt|;
name|bktr
operator|->
name|flags
operator||=
name|type
expr_stmt|;
switch|switch
condition|(
name|bktr
operator|->
name|flags
operator|&
name|METEOR_ONLY_FIELDS_MASK
condition|)
block|{
case|case
name|METEOR_ONLY_EVEN_FIELDS
case|:
name|bktr
operator|->
name|flags
operator||=
name|METEOR_WANT_EVEN
expr_stmt|;
name|i_flag
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|METEOR_ONLY_ODD_FIELDS
case|:
name|bktr
operator|->
name|flags
operator||=
name|METEOR_WANT_ODD
expr_stmt|;
name|i_flag
operator|=
literal|2
expr_stmt|;
break|break;
default|default:
name|bktr
operator|->
name|flags
operator||=
name|METEOR_WANT_MASK
expr_stmt|;
name|i_flag
operator|=
literal|3
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|bktr
operator|->
name|dma_prog_loaded
condition|)
block|{
name|build_dma_prog
argument_list|(
name|bktr
argument_list|,
name|i_flag
argument_list|)
expr_stmt|;
name|bktr
operator|->
name|dma_prog_loaded
operator|=
literal|1
expr_stmt|;
block|}
comment|/*XXX 	switch(bktr->flags& METEOR_ONLY_FIELDS_MASK) { 	default: 	*bts_reg |= 0xb; 	} */
name|btl_reg
operator|=
operator|(
name|u_long
operator|*
operator|)
operator|&
name|bt848
index|[
name|BKTR_RISC_STRT_ADD
index|]
expr_stmt|;
operator|*
name|btl_reg
operator|=
name|vtophys
argument_list|(
name|bktr
operator|->
name|dma_prog
argument_list|)
expr_stmt|;
comment|/*XXX 	bts_reg = (u_short *)&bt848[BKTR_GPIO_DMA_CTL]; 	*bts_reg = 0x3; */
block|}
end_function

begin_comment
comment|/*  *   */
end_comment

begin_function
specifier|static
name|void
name|set_fps
parameter_list|(
name|bktr_reg_t
modifier|*
name|bktr
parameter_list|,
name|u_short
name|fps
parameter_list|)
block|{
specifier|volatile
name|u_char
modifier|*
name|bt848
decl_stmt|,
modifier|*
name|bt_reg
decl_stmt|;
specifier|volatile
name|u_long
modifier|*
name|btl_reg
decl_stmt|;
specifier|volatile
name|u_short
modifier|*
name|bts_reg
decl_stmt|;
name|bt848
operator|=
operator|(
name|u_char
operator|*
operator|)
name|bktr
operator|->
name|base
expr_stmt|;
name|bts_reg
operator|=
operator|(
name|u_short
operator|*
operator|)
operator|&
name|bt848
index|[
name|BKTR_GPIO_DMA_CTL
index|]
expr_stmt|;
operator|*
name|bts_reg
operator|=
literal|0
expr_stmt|;
name|btl_reg
operator|=
operator|(
name|u_long
operator|*
operator|)
operator|&
name|bt848
index|[
name|BKTR_INT_STAT
index|]
expr_stmt|;
operator|*
name|btl_reg
operator|=
literal|0xffffffff
expr_stmt|;
name|bktr
operator|->
name|fps
operator|=
name|fps
expr_stmt|;
if|if
condition|(
name|fps
operator|==
literal|30
condition|)
block|{
name|bt848
index|[
name|BKTR_TDEC
index|]
operator|=
literal|0
expr_stmt|;
return|return;
block|}
else|else
block|{
name|bt848
index|[
name|BKTR_TDEC
index|]
operator|=
call|(
name|int
call|)
argument_list|(
operator|(
operator|(
name|float
operator|)
name|fps
operator|/
literal|30.0
operator|)
operator|*
literal|60.0
argument_list|)
operator|&
literal|0x3f
expr_stmt|;
name|bt848
index|[
name|BKTR_TDEC
index|]
operator||=
literal|0x80
expr_stmt|;
block|}
if|if
condition|(
name|bktr
operator|->
name|flags
operator|&
name|METEOR_CAP_MASK
condition|)
block|{
name|btl_reg
operator|=
operator|(
name|u_long
operator|*
operator|)
operator|&
name|bt848
index|[
name|BKTR_INT_STAT
index|]
expr_stmt|;
operator|*
name|btl_reg
operator|=
literal|0xffffffff
expr_stmt|;
name|btl_reg
operator|=
operator|(
name|u_long
operator|*
operator|)
operator|&
name|bt848
index|[
name|BKTR_RISC_STRT_ADD
index|]
expr_stmt|;
operator|*
name|btl_reg
operator|=
name|vtophys
argument_list|(
name|bktr
operator|->
name|dma_prog
argument_list|)
expr_stmt|;
name|bts_reg
operator|=
operator|(
name|u_short
operator|*
operator|)
operator|&
name|bt848
index|[
name|BKTR_GPIO_DMA_CTL
index|]
expr_stmt|;
operator|*
name|bts_reg
operator|=
literal|1
expr_stmt|;
operator|*
name|bts_reg
operator|=
name|bktr
operator|->
name|capcontrol
expr_stmt|;
name|btl_reg
operator|=
operator|(
name|u_long
operator|*
operator|)
operator|&
name|bt848
index|[
name|BKTR_INT_MASK
index|]
expr_stmt|;
operator|*
name|btl_reg
operator|=
literal|1
operator|<<
literal|11
operator||
literal|2
operator||
literal|1
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/*  * There is also a problem with range checking on the 7116.  * It seems to only work for 22 bits, so the max size we can allocate  * is 22 bits long or 4194304 bytes assuming that we put the beginning  * of the buffer on a 2^24 bit boundary.  The range registers will use  * the top 8 bits of the dma start registers along with the bottom 22  * bits of the range register to determine if we go out of range.  * This makes getting memory a real kludge.  *  */
end_comment

begin_define
define|#
directive|define
name|RANGE_BOUNDARY
value|(1<<22)
end_define

begin_function
specifier|static
name|vm_offset_t
name|get_bktr_mem
parameter_list|(
name|int
name|unit
parameter_list|,
name|unsigned
name|size
parameter_list|)
block|{
name|vm_offset_t
name|addr
init|=
literal|0
decl_stmt|;
name|addr
operator|=
name|vm_page_alloc_contig
argument_list|(
name|size
argument_list|,
literal|0x100000
argument_list|,
literal|0xffffffff
argument_list|,
literal|1
operator|<<
literal|24
argument_list|)
expr_stmt|;
if|if
condition|(
name|addr
operator|==
literal|0
condition|)
name|addr
operator|=
name|vm_page_alloc_contig
argument_list|(
name|size
argument_list|,
literal|0x100000
argument_list|,
literal|0xffffffff
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|addr
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"meteor%d: Unable to allocate %d bytes of memory.\n"
argument_list|,
name|unit
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
return|return
name|addr
return|;
block|}
end_function

begin_comment
comment|/*  * what should we do here?  */
end_comment

begin_function
specifier|static
name|void
name|bktr_init
parameter_list|(
name|bktr_reg_t
modifier|*
name|bktr
parameter_list|)
block|{
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|bktr_attach
parameter_list|(
name|pcici_t
name|tag
parameter_list|,
name|int
name|unit
parameter_list|)
block|{
name|bktr_reg_t
modifier|*
name|bktr
decl_stmt|;
specifier|volatile
name|u_char
modifier|*
name|bt848
decl_stmt|;
specifier|volatile
name|u_long
modifier|*
name|btl_reg
decl_stmt|;
ifdef|#
directive|ifdef
name|BROOKTREE_IRQ
name|u_long
name|old_irq
decl_stmt|,
name|new_irq
decl_stmt|;
endif|#
directive|endif
name|u_char
modifier|*
name|test
decl_stmt|;
name|vm_offset_t
name|buf
decl_stmt|;
name|u_long
name|latency
decl_stmt|;
name|u_long
name|foo
decl_stmt|,
name|fun
decl_stmt|;
name|bt_enable_cnt
operator|=
literal|0
expr_stmt|;
name|bktr
operator|=
operator|&
name|brooktree
index|[
name|unit
index|]
expr_stmt|;
if|if
condition|(
name|unit
operator|>=
name|NBKTR
condition|)
block|{
name|printf
argument_list|(
literal|"brooktree%d: attach: only %d units configured.\n"
argument_list|,
name|unit
argument_list|,
name|NBKTR
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"brooktree%d: attach: invalid unit number.\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return ;
block|}
name|bktr
operator|->
name|tag
operator|=
name|tag
expr_stmt|;
name|pci_map_mem
argument_list|(
name|tag
argument_list|,
name|PCI_MAP_REG_START
argument_list|,
operator|(
name|vm_offset_t
operator|*
operator|)
operator|&
name|bktr
operator|->
name|base
argument_list|,
operator|&
name|bktr
operator|->
name|phys_base
argument_list|)
expr_stmt|;
name|fun
operator|=
name|pci_conf_read
argument_list|(
name|tag
argument_list|,
name|PCI_COMMAND_STATUS_REG
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|BROOKTREE_IRQ
comment|/* from the configuration file */
name|old_irq
operator|=
name|pci_conf_read
argument_list|(
name|tag
argument_list|,
name|PCI_INTERRUPT_REG
argument_list|)
expr_stmt|;
name|pci_conf_write
argument_list|(
name|tag
argument_list|,
name|PCI_INTERRUPT_REG
argument_list|,
name|BROOKTREE_IRQ
argument_list|)
expr_stmt|;
name|new_irq
operator|=
name|pci_conf_read
argument_list|(
name|tag
argument_list|,
name|PCI_INTERRUPT_REG
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"bktr%d: attach: irq changed from %d to %d\n"
argument_list|,
name|unit
argument_list|,
operator|(
name|old_irq
operator|&
literal|0xff
operator|)
argument_list|,
operator|(
name|new_irq
operator|&
literal|0xff
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* setup the interrupt handling routine */
name|pci_map_int
argument_list|(
name|tag
argument_list|,
name|bktr_intr
argument_list|,
operator|(
name|void
operator|*
operator|)
name|bktr
argument_list|,
operator|&
name|net_imask
argument_list|)
expr_stmt|;
comment|/*  * PCI latency timer.  32 is a good value for 4 bus mastering slots, if  * you have more than for, then 16 would probably be a better value.  *  */
ifndef|#
directive|ifndef
name|BROOKTREE_DEF_LATENCY_VALUE
define|#
directive|define
name|BROOKTREE_DEF_LATENCY_VALUE
value|10
endif|#
directive|endif
name|latency
operator|=
name|pci_conf_read
argument_list|(
name|tag
argument_list|,
name|PCI_LATENCY_TIMER
argument_list|)
expr_stmt|;
name|latency
operator|=
operator|(
name|latency
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
block|{
if|if
condition|(
name|latency
condition|)
name|printf
argument_list|(
literal|"brooktree%d: PCI bus latency is"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"brooktree%d: PCI bus latency was 0 changing to"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|latency
condition|)
block|{
name|latency
operator|=
name|BROOKTREE_DEF_LATENCY_VALUE
expr_stmt|;
name|pci_conf_write
argument_list|(
name|tag
argument_list|,
name|PCI_LATENCY_TIMER
argument_list|,
name|latency
operator|<<
literal|8
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bootverbose
condition|)
block|{
name|printf
argument_list|(
literal|" %d.\n"
argument_list|,
name|latency
argument_list|)
expr_stmt|;
block|}
comment|/*	bktr_init(bktr);	 set up the bt848 */
comment|/* allocate space for dma program */
name|bktr
operator|->
name|dma_prog
operator|=
name|get_bktr_mem
argument_list|(
name|unit
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|bktr
operator|->
name|odd_dma_prog
operator|=
name|get_bktr_mem
argument_list|(
name|unit
argument_list|,
literal|8
argument_list|)
expr_stmt|;
if|if
condition|(
name|BROOKTREE_ALLOC
condition|)
name|buf
operator|=
name|get_bktr_mem
argument_list|(
name|unit
argument_list|,
name|BROOKTREE_ALLOC
argument_list|)
expr_stmt|;
else|else
name|buf
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
block|{
name|printf
argument_list|(
literal|"bktr%d: buffer size %d, addr 0x%x\n"
argument_list|,
name|unit
argument_list|,
name|BROOKTREE_ALLOC
argument_list|,
name|vtophys
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|bktr
operator|->
name|bigbuf
operator|=
name|buf
expr_stmt|;
name|bktr
operator|->
name|alloc_pages
operator|=
name|BROOKTREE_ALLOC_PAGES
expr_stmt|;
if|if
condition|(
name|buf
operator|!=
literal|0
condition|)
block|{
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
name|buf
argument_list|,
name|BROOKTREE_ALLOC
argument_list|)
expr_stmt|;
name|buf
operator|=
name|vtophys
argument_list|(
name|buf
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|amancio
comment|/* 640x480 RGB 16 */
name|amancio
label|:
name|setup
name|dma
name|risc
name|program
name|bktr
operator|->
name|base
operator|->
name|dma1e
init|=
name|buf
decl_stmt|;
name|bktr
operator|->
name|base
operator|->
name|dma1o
operator|=
name|buf
operator|+
literal|0x500
expr_stmt|;
name|bktr
operator|->
name|base
operator|->
name|dma_end_e
operator|=
name|bktr
operator|->
name|base
operator|->
name|dma_end_o
operator|=
name|buf
operator|+
name|METEOR_ALLOC
expr_stmt|;
name|end
name|of
name|setup
name|up
name|dma
name|risc
name|program
comment|/* 1 frame of 640x480 RGB 16 */
name|bktr
operator|->
name|flags
operator||=
name|METEOR_INITALIZED
operator||
name|METEOR_AUTOMODE
operator||
name|METEOR_DEV0
operator||
name|METEOR_RGB16
expr_stmt|;
endif|#
directive|endif
comment|/* amancio */
name|bktr
operator|->
name|flags
operator|=
name|METEOR_INITALIZED
operator||
name|METEOR_AUTOMODE
operator||
name|METEOR_DEV0
operator||
name|METEOR_RGB16
expr_stmt|;
name|bktr
operator|->
name|dma_prog_loaded
operator|=
literal|0
expr_stmt|;
name|bktr
operator|->
name|cols
operator|=
literal|640
expr_stmt|;
name|bktr
operator|->
name|rows
operator|=
literal|480
expr_stmt|;
name|bktr
operator|->
name|depth
operator|=
literal|2
expr_stmt|;
comment|/* two bytes per pixel */
name|bktr
operator|->
name|frames
operator|=
literal|1
expr_stmt|;
comment|/* one frame */
name|bt848
operator|=
name|bktr
operator|->
name|base
expr_stmt|;
name|btl_reg
operator|=
operator|(
name|u_long
operator|*
operator|)
operator|&
name|bt848
index|[
name|BKTR_INT_MASK
index|]
expr_stmt|;
operator|*
name|btl_reg
operator|=
literal|0
expr_stmt|;
name|bt848
index|[
name|BKTR_GPIO_DMA_CTL
index|]
operator|=
literal|0
expr_stmt|;
block|}
comment|/* defaults for the tuner section of the card */
name|bktr
operator|->
name|tuner
operator|.
name|frequency
operator|=
literal|0
expr_stmt|;
name|bktr
operator|->
name|tuner
operator|.
name|channel
operator|=
literal|0
expr_stmt|;
name|bktr
operator|->
name|tuner
operator|.
name|tunertype
operator|=
name|DEFAULT_TUNERTYPE
expr_stmt|;
ifdef|#
directive|ifdef
name|DEVFS
name|bktr
operator|->
name|devfs_token
operator|=
name|devfs_add_devswf
argument_list|(
operator|&
name|bktr_cdevsw
argument_list|,
name|unit
argument_list|,
name|DV_CHR
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0644
argument_list|,
literal|"brooktree"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEVFS */
block|}
end_function

begin_define
define|#
directive|define
name|UNIT
parameter_list|(
name|x
parameter_list|)
value|((x)& 0x07)
end_define

begin_comment
comment|/*--------------------------------------------------------- ** **	BrookTree 848 character device driver routines ** **--------------------------------------------------------- */
end_comment

begin_comment
comment|/*  *   */
end_comment

begin_function
name|int
name|bktr_open
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|fmt
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|bktr_reg_t
modifier|*
name|bktr
decl_stmt|;
name|int
name|unit
decl_stmt|;
name|int
name|i
decl_stmt|;
specifier|volatile
name|u_char
modifier|*
name|bt848
decl_stmt|;
specifier|volatile
name|u_char
modifier|*
name|bt_reg
decl_stmt|;
specifier|volatile
name|u_long
modifier|*
name|btl_reg
decl_stmt|;
name|unit
operator|=
name|UNIT
argument_list|(
name|minor
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|unit
operator|>=
name|NBKTR
condition|)
comment|/* unit out of range */
return|return
operator|(
name|ENXIO
operator|)
return|;
name|bktr
operator|=
operator|&
operator|(
name|brooktree
index|[
name|unit
index|]
operator|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|bktr
operator|->
name|flags
operator|&
name|METEOR_INITALIZED
operator|)
condition|)
comment|/* device not found */
return|return
operator|(
name|ENXIO
operator|)
return|;
if|#
directive|if
name|defined
argument_list|(
name|MULTIPLE_OPENS
argument_list|)
if|if
condition|(
name|bktr
operator|->
name|flags
operator|&
name|METEOR_OPEN
condition|)
comment|/* device already open */
return|return
literal|0
return|;
else|#
directive|else
if|if
condition|(
name|bktr
operator|->
name|flags
operator|&
name|METEOR_OPEN
condition|)
comment|/* device is busy */
return|return
operator|(
name|EBUSY
operator|)
return|;
endif|#
directive|endif
comment|/* MULTIPLE_OPENS */
name|bktr
operator|->
name|flags
operator||=
name|METEOR_OPEN
expr_stmt|;
name|bt848
operator|=
name|bktr
operator|->
name|base
expr_stmt|;
comment|/* dump_bt848(bt848); */
operator|*
name|bt848
operator|=
literal|0x3
expr_stmt|;
comment|/* bt848[ 0 ] */
operator|*
name|bt848
operator|=
literal|0xc0
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|LOW_SYNC
argument_list|)
name|bt848
index|[
name|BKTR_ADC
index|]
operator|=
literal|0xa1
expr_stmt|;
else|#
directive|else
name|bt848
index|[
name|BKTR_ADC
index|]
operator|=
literal|0x81
expr_stmt|;
endif|#
directive|endif
comment|/* LOW_SYNC */
name|bt848
index|[
name|BKTR_IFORM
index|]
operator|=
literal|0x69
expr_stmt|;
name|bktr
operator|->
name|flags
operator|=
operator|(
name|bktr
operator|->
name|flags
operator|&
operator|~
name|METEOR_DEV_MASK
operator|)
operator||
name|METEOR_DEV0
expr_stmt|;
name|bt848
index|[
name|BKTR_COLOR_CTL
index|]
operator|=
literal|0x20
expr_stmt|;
name|bt848
index|[
name|BKTR_E_HSCALE_LO
index|]
operator|=
literal|0xaa
expr_stmt|;
name|bt848
index|[
name|BKTR_O_HSCALE_LO
index|]
operator|=
literal|0xaa
expr_stmt|;
name|bt848
index|[
name|BKTR_E_DELAY_LO
index|]
operator|=
literal|0x72
expr_stmt|;
name|bt848
index|[
name|BKTR_O_DELAY_LO
index|]
operator|=
literal|0x72
expr_stmt|;
name|bt848
index|[
name|BKTR_E_SCLOOP
index|]
operator|=
literal|0
expr_stmt|;
name|bt848
index|[
name|BKTR_O_SCLOOP
index|]
operator|=
literal|0
expr_stmt|;
name|bt848
index|[
name|BKTR_VBI_PACK_SIZE
index|]
operator|=
literal|0
expr_stmt|;
name|bt848
index|[
name|BKTR_VBI_PACK_DEL
index|]
operator|=
literal|0
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|u_char
operator|*
operator|)
name|bktr
operator|->
name|bigbuf
argument_list|,
literal|640
operator|*
literal|480
operator|*
literal|4
argument_list|)
expr_stmt|;
name|bktr
operator|->
name|fifo_errors
operator|=
literal|0
expr_stmt|;
name|bktr
operator|->
name|dma_errors
operator|=
literal|0
expr_stmt|;
name|bktr
operator|->
name|frames_captured
operator|=
literal|0
expr_stmt|;
name|bktr
operator|->
name|even_fields_captured
operator|=
literal|0
expr_stmt|;
name|bktr
operator|->
name|odd_fields_captured
operator|=
literal|0
expr_stmt|;
name|bktr
operator|->
name|proc
operator|=
operator|(
expr|struct
name|proc
operator|*
operator|)
literal|0
expr_stmt|;
name|set_fps
argument_list|(
name|bktr
argument_list|,
literal|30
argument_list|)
expr_stmt|;
name|bktr
operator|->
name|video
operator|.
name|addr
operator|=
literal|0
expr_stmt|;
name|bktr
operator|->
name|video
operator|.
name|width
operator|=
literal|0
expr_stmt|;
name|bktr
operator|->
name|video
operator|.
name|banksize
operator|=
literal|0
expr_stmt|;
name|bktr
operator|->
name|video
operator|.
name|ramsize
operator|=
literal|0
expr_stmt|;
name|btl_reg
operator|=
operator|(
name|u_long
operator|*
operator|)
operator|&
name|bt848
index|[
name|BKTR_INT_MASK
index|]
expr_stmt|;
operator|*
name|btl_reg
operator|=
literal|1
operator|<<
literal|23
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *   */
end_comment

begin_function
name|int
name|bktr_close
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|fmt
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|bktr_reg_t
modifier|*
name|bktr
decl_stmt|;
name|int
name|unit
decl_stmt|;
specifier|volatile
name|u_char
modifier|*
name|bt848
decl_stmt|;
specifier|volatile
name|u_long
modifier|*
name|btl_reg
decl_stmt|;
name|u_short
modifier|*
name|bts_reg
decl_stmt|;
ifdef|#
directive|ifdef
name|METEOR_DEALLOC_ABOVE
name|int
name|temp
decl_stmt|;
endif|#
directive|endif
name|unit
operator|=
name|UNIT
argument_list|(
name|minor
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|unit
operator|>=
name|NBKTR
condition|)
comment|/* unit out of range */
return|return
operator|(
name|ENXIO
operator|)
return|;
name|bktr
operator|=
operator|&
operator|(
name|brooktree
index|[
name|unit
index|]
operator|)
expr_stmt|;
name|bktr
operator|->
name|flags
operator|&=
operator|~
name|METEOR_OPEN
expr_stmt|;
name|bktr
operator|->
name|flags
operator|&=
operator|~
operator|(
name|METEOR_SINGLE
operator||
name|METEOR_WANT_MASK
operator|)
expr_stmt|;
name|bktr
operator|->
name|flags
operator|&=
operator|~
operator|(
name|METEOR_CAP_MASK
operator||
name|METEOR_WANT_MASK
operator|)
expr_stmt|;
name|bt848
operator|=
name|bktr
operator|->
name|base
expr_stmt|;
name|bts_reg
operator|=
operator|(
name|u_short
operator|*
operator|)
operator|&
name|bt848
index|[
name|BKTR_GPIO_DMA_CTL
index|]
expr_stmt|;
operator|*
name|bts_reg
operator|=
literal|0
expr_stmt|;
name|bt848
index|[
name|BKTR_CAP_CTL
index|]
operator|=
literal|0
expr_stmt|;
name|bktr
operator|->
name|dma_prog_loaded
operator|=
literal|0
expr_stmt|;
name|bt848
index|[
name|BKTR_TDEC
index|]
operator|=
literal|0
expr_stmt|;
name|btl_reg
operator|=
operator|(
name|u_long
operator|*
operator|)
operator|&
name|bt848
index|[
name|BKTR_INT_MASK
index|]
expr_stmt|;
operator|*
name|btl_reg
operator|=
literal|0
expr_stmt|;
name|bt848
index|[
name|BKTR_SRESET
index|]
operator|=
literal|0xf
expr_stmt|;
name|btl_reg
operator|=
operator|(
name|u_long
operator|*
operator|)
operator|&
name|bt848
index|[
name|BKTR_INT_STAT
index|]
expr_stmt|;
operator|*
name|btl_reg
operator|=
literal|0xffffffff
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *   */
end_comment

begin_function
name|int
name|bktr_read
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|,
name|int
name|ioflag
parameter_list|)
block|{
name|bktr_reg_t
modifier|*
name|bktr
decl_stmt|;
name|int
name|unit
decl_stmt|;
name|int
name|status
decl_stmt|;
name|int
name|count
decl_stmt|;
specifier|volatile
name|u_char
modifier|*
name|bt848
decl_stmt|;
name|u_short
modifier|*
name|bts_reg
decl_stmt|;
name|unit
operator|=
name|UNIT
argument_list|(
name|minor
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|unit
operator|>=
name|NBKTR
condition|)
comment|/* unit out of range */
return|return
operator|(
name|ENXIO
operator|)
return|;
name|bktr
operator|=
operator|&
operator|(
name|brooktree
index|[
name|unit
index|]
operator|)
expr_stmt|;
if|if
condition|(
name|bktr
operator|->
name|bigbuf
operator|==
literal|0
condition|)
comment|/* no frame buffer allocated (ioctl failed) */
return|return
operator|(
name|ENOMEM
operator|)
return|;
if|if
condition|(
name|bktr
operator|->
name|flags
operator|&
name|METEOR_CAP_MASK
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
comment|/* already capturing */
name|bt848
operator|=
operator|(
name|u_char
operator|*
operator|)
name|bktr
operator|->
name|base
expr_stmt|;
name|count
operator|=
name|bktr
operator|->
name|rows
operator|*
name|bktr
operator|->
name|cols
operator|*
name|bktr
operator|->
name|depth
expr_stmt|;
if|if
condition|(
operator|(
name|int
operator|)
name|uio
operator|->
name|uio_iov
operator|->
name|iov_len
operator|<
name|count
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|bktr
operator|->
name|flags
operator|&=
operator|~
operator|(
name|METEOR_CAP_MASK
operator||
name|METEOR_WANT_MASK
operator|)
expr_stmt|;
comment|/* Start capture */
name|bts_reg
operator|=
operator|(
name|u_short
operator|*
operator|)
operator|&
name|bt848
index|[
name|BKTR_GPIO_DMA_CTL
index|]
expr_stmt|;
operator|*
name|bts_reg
operator|=
literal|0x1
expr_stmt|;
operator|*
name|bts_reg
operator|=
literal|0x3
expr_stmt|;
name|status
operator|=
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
name|bktr
argument_list|,
name|METPRI
argument_list|,
literal|"capturing"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|status
condition|)
comment|/* successful capture */
name|status
operator|=
name|uiomove
argument_list|(
operator|(
name|caddr_t
operator|)
name|bktr
operator|->
name|bigbuf
argument_list|,
name|count
argument_list|,
name|uio
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"meteor%d: read: tsleep error %d\n"
argument_list|,
name|unit
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|bktr
operator|->
name|flags
operator|&=
operator|~
operator|(
name|METEOR_SINGLE
operator||
name|METEOR_WANT_MASK
operator|)
expr_stmt|;
return|return
operator|(
name|status
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *   */
end_comment

begin_function
name|int
name|bktr_write
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|,
name|int
name|ioflag
parameter_list|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *   */
end_comment

begin_function
name|int
name|bktr_ioctl
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|cmd
parameter_list|,
name|caddr_t
name|arg
parameter_list|,
name|int
name|flag
parameter_list|,
name|struct
name|proc
modifier|*
name|pr
parameter_list|)
block|{
name|bktr_reg_t
modifier|*
name|bktr
decl_stmt|;
name|int
name|unit
decl_stmt|;
name|int
name|status
decl_stmt|;
name|int
name|count
decl_stmt|;
name|int
name|tmp_int
decl_stmt|;
specifier|volatile
name|u_char
modifier|*
name|bt848
decl_stmt|,
name|c_temp
decl_stmt|;
specifier|volatile
name|u_short
modifier|*
name|bts_reg
decl_stmt|,
name|s_temp
decl_stmt|;
specifier|volatile
name|u_long
modifier|*
name|btl_reg
decl_stmt|;
name|unsigned
name|int
name|temp
decl_stmt|,
name|temp1
decl_stmt|;
name|unsigned
name|int
name|error
decl_stmt|;
name|struct
name|meteor_geomet
modifier|*
name|geo
decl_stmt|;
name|struct
name|meteor_counts
modifier|*
name|cnt
decl_stmt|;
name|struct
name|meteor_video
modifier|*
name|video
decl_stmt|;
name|u_long
modifier|*
name|foo
decl_stmt|;
name|vm_offset_t
name|buf
decl_stmt|;
name|unit
operator|=
name|UNIT
argument_list|(
name|minor
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|unit
operator|>=
name|NBKTR
condition|)
comment|/* unit out of range */
return|return
operator|(
name|ENXIO
operator|)
return|;
name|bktr
operator|=
operator|&
operator|(
name|brooktree
index|[
name|unit
index|]
operator|)
expr_stmt|;
if|if
condition|(
name|bktr
operator|->
name|bigbuf
operator|==
literal|0
condition|)
comment|/* no frame buffer allocated (ioctl failed) */
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|bt848
operator|=
name|bktr
operator|->
name|base
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|TVTUNER_SETCHNL
case|:
name|temp
operator|=
name|tv_channel
argument_list|(
name|bktr
argument_list|,
operator|(
name|int
operator|)
operator|*
operator|(
name|unsigned
name|long
operator|*
operator|)
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|<
literal|0
condition|)
return|return
name|EINVAL
return|;
operator|*
operator|(
name|unsigned
name|long
operator|*
operator|)
name|arg
operator|=
name|temp
expr_stmt|;
break|break;
case|case
name|TVTUNER_GETCHNL
case|:
operator|*
operator|(
name|unsigned
name|long
operator|*
operator|)
name|arg
operator|=
name|bktr
operator|->
name|tuner
operator|.
name|channel
expr_stmt|;
break|break;
case|case
name|TVTUNER_SETTYPE
case|:
name|temp
operator|=
operator|*
operator|(
name|unsigned
name|long
operator|*
operator|)
name|arg
expr_stmt|;
if|if
condition|(
operator|(
name|temp
operator|<
name|TUNERTYPE_MIN
operator|)
operator|||
operator|(
name|temp
operator|>
name|TUNERTYPE_MAX
operator|)
condition|)
return|return
name|EINVAL
return|;
name|bktr
operator|->
name|tuner
operator|.
name|tunertype
operator|=
name|temp
expr_stmt|;
break|break;
case|case
name|TVTUNER_GETTYPE
case|:
operator|*
operator|(
name|unsigned
name|long
operator|*
operator|)
name|arg
operator|=
name|bktr
operator|->
name|tuner
operator|.
name|tunertype
expr_stmt|;
break|break;
case|case
name|TVTUNER_GETSTATUS
case|:
name|temp
operator|=
name|tuner_status
argument_list|(
name|bktr
argument_list|)
expr_stmt|;
operator|*
operator|(
name|unsigned
name|long
operator|*
operator|)
name|arg
operator|=
name|temp
operator|&
literal|0xff
expr_stmt|;
break|break;
case|case
name|TVTUNER_SETFREQ
case|:
name|temp
operator|=
name|tv_freq
argument_list|(
name|bktr
argument_list|,
operator|(
name|int
operator|)
operator|*
operator|(
name|unsigned
name|long
operator|*
operator|)
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|<
literal|0
condition|)
return|return
name|EINVAL
return|;
operator|*
operator|(
name|unsigned
name|long
operator|*
operator|)
name|arg
operator|=
name|temp
expr_stmt|;
break|break;
case|case
name|TVTUNER_GETFREQ
case|:
operator|*
operator|(
name|unsigned
name|long
operator|*
operator|)
name|arg
operator|=
name|bktr
operator|->
name|tuner
operator|.
name|frequency
expr_stmt|;
break|break;
case|case
name|METEORSTATUS
case|:
comment|/* get 7196 status */
name|c_temp
operator|=
name|bt848
index|[
literal|0
index|]
expr_stmt|;
name|temp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|c_temp
operator|&
literal|0x40
operator|)
condition|)
name|temp
operator||=
name|METEOR_STATUS_HCLK
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|c_temp
operator|&
literal|0x10
operator|)
condition|)
name|temp
operator||=
name|METEOR_STATUS_FIDT
expr_stmt|;
operator|*
operator|(
name|u_short
operator|*
operator|)
name|arg
operator|=
name|temp
expr_stmt|;
break|break;
case|case
name|METEORSINPUT
case|:
comment|/* set input device */
switch|switch
condition|(
operator|*
operator|(
name|unsigned
name|long
operator|*
operator|)
name|arg
operator|&
name|METEOR_DEV_MASK
condition|)
block|{
case|case
literal|0
case|:
comment|/* default */
case|case
name|METEOR_INPUT_DEV0
case|:
name|bktr
operator|->
name|flags
operator|=
operator|(
name|bktr
operator|->
name|flags
operator|&
operator|~
name|METEOR_DEV_MASK
operator|)
operator||
name|METEOR_DEV0
expr_stmt|;
name|bt848
index|[
name|BKTR_IFORM
index|]
operator|&=
operator|~
literal|0x60
expr_stmt|;
name|bt848
index|[
name|BKTR_IFORM
index|]
operator||=
literal|0x60
expr_stmt|;
name|bt848
index|[
name|BKTR_E_CONTROL
index|]
operator|&=
operator|~
literal|0x40
expr_stmt|;
name|bt848
index|[
name|BKTR_O_CONTROL
index|]
operator|&=
operator|~
literal|0x40
expr_stmt|;
break|break;
case|case
name|METEOR_INPUT_DEV1
case|:
name|bktr
operator|->
name|flags
operator|=
operator|(
name|bktr
operator|->
name|flags
operator|&
operator|~
name|METEOR_DEV_MASK
operator|)
operator||
name|METEOR_DEV1
expr_stmt|;
name|bt848
index|[
name|BKTR_IFORM
index|]
operator|&=
operator|~
literal|0x60
expr_stmt|;
name|bt848
index|[
name|BKTR_IFORM
index|]
operator||=
literal|0x40
expr_stmt|;
name|bt848
index|[
name|BKTR_E_CONTROL
index|]
operator|&=
operator|~
literal|0x40
expr_stmt|;
name|bt848
index|[
name|BKTR_O_CONTROL
index|]
operator|&=
operator|~
literal|0x40
expr_stmt|;
break|break;
case|case
name|METEOR_INPUT_DEV2
case|:
name|bktr
operator|->
name|flags
operator|=
operator|(
name|bktr
operator|->
name|flags
operator|&
operator|~
name|METEOR_DEV_MASK
operator|)
operator||
name|METEOR_DEV2
expr_stmt|;
name|bt848
index|[
name|BKTR_IFORM
index|]
operator|&=
operator|~
literal|0x60
expr_stmt|;
name|bt848
index|[
name|BKTR_IFORM
index|]
operator||=
literal|0x20
expr_stmt|;
name|bt848
index|[
name|BKTR_E_CONTROL
index|]
operator||=
literal|0x40
expr_stmt|;
name|bt848
index|[
name|BKTR_O_CONTROL
index|]
operator||=
literal|0x40
expr_stmt|;
break|break;
case|case
name|METEOR_INPUT_DEV_SVIDEO
case|:
name|bktr
operator|->
name|flags
operator|=
operator|(
name|bktr
operator|->
name|flags
operator|&
operator|~
name|METEOR_DEV_MASK
operator|)
operator||
name|METEOR_DEV2
expr_stmt|;
name|bt848
index|[
name|BKTR_IFORM
index|]
operator|&=
operator|~
literal|0x60
expr_stmt|;
name|bt848
index|[
name|BKTR_IFORM
index|]
operator||=
literal|0x20
expr_stmt|;
name|bt848
index|[
name|BKTR_E_CONTROL
index|]
operator||=
literal|0x40
expr_stmt|;
name|bt848
index|[
name|BKTR_O_CONTROL
index|]
operator||=
literal|0x40
expr_stmt|;
break|break;
default|default:
return|return
name|EINVAL
return|;
block|}
break|break;
case|case
name|METEORGINPUT
case|:
comment|/* get input device */
operator|*
operator|(
name|u_long
operator|*
operator|)
name|arg
operator|=
name|bktr
operator|->
name|flags
operator|&
name|METEOR_DEV_MASK
expr_stmt|;
break|break;
case|case
name|METEORSFMT
case|:
comment|/* set input format */
switch|switch
condition|(
operator|*
operator|(
name|unsigned
name|long
operator|*
operator|)
name|arg
operator|&
name|METEOR_FORM_MASK
condition|)
block|{
case|case
literal|0
case|:
comment|/* default */
case|case
name|METEOR_FMT_NTSC
case|:
name|bktr
operator|->
name|flags
operator|=
operator|(
name|bktr
operator|->
name|flags
operator|&
operator|~
name|METEOR_FORM_MASK
operator|)
operator||
name|METEOR_NTSC
expr_stmt|;
name|bt848
index|[
name|BKTR_IFORM
index|]
operator|&=
operator|~
literal|0x3
expr_stmt|;
name|bt848
index|[
name|BKTR_IFORM
index|]
operator||=
literal|1
expr_stmt|;
break|break;
case|case
name|METEOR_FMT_AUTOMODE
case|:
name|bktr
operator|->
name|flags
operator|=
operator|(
name|bktr
operator|->
name|flags
operator|&
operator|~
name|METEOR_FORM_MASK
operator|)
operator||
name|METEOR_AUTOMODE
expr_stmt|;
name|bt848
index|[
name|BKTR_IFORM
index|]
operator|&=
operator|~
literal|0x3
expr_stmt|;
break|break;
default|default:
return|return
name|EINVAL
return|;
block|}
break|break;
case|case
name|METEORGFMT
case|:
comment|/* get input format */
operator|*
operator|(
name|u_long
operator|*
operator|)
name|arg
operator|=
name|bktr
operator|->
name|flags
operator|&
name|METEOR_FORM_MASK
expr_stmt|;
break|break;
case|case
name|METEORSCOUNT
case|:
comment|/* (re)set error counts */
name|cnt
operator|=
operator|(
expr|struct
name|meteor_counts
operator|*
operator|)
name|arg
expr_stmt|;
name|bktr
operator|->
name|fifo_errors
operator|=
name|cnt
operator|->
name|fifo_errors
expr_stmt|;
name|bktr
operator|->
name|dma_errors
operator|=
name|cnt
operator|->
name|dma_errors
expr_stmt|;
name|bktr
operator|->
name|frames_captured
operator|=
name|cnt
operator|->
name|frames_captured
expr_stmt|;
name|bktr
operator|->
name|even_fields_captured
operator|=
name|cnt
operator|->
name|even_fields_captured
expr_stmt|;
name|bktr
operator|->
name|odd_fields_captured
operator|=
name|cnt
operator|->
name|odd_fields_captured
expr_stmt|;
break|break;
case|case
name|METEORGCOUNT
case|:
comment|/* get error counts */
name|cnt
operator|=
operator|(
expr|struct
name|meteor_counts
operator|*
operator|)
name|arg
expr_stmt|;
name|cnt
operator|->
name|fifo_errors
operator|=
name|bktr
operator|->
name|fifo_errors
expr_stmt|;
name|cnt
operator|->
name|dma_errors
operator|=
name|bktr
operator|->
name|dma_errors
expr_stmt|;
name|cnt
operator|->
name|frames_captured
operator|=
name|bktr
operator|->
name|frames_captured
expr_stmt|;
name|cnt
operator|->
name|even_fields_captured
operator|=
name|bktr
operator|->
name|even_fields_captured
expr_stmt|;
name|cnt
operator|->
name|odd_fields_captured
operator|=
name|bktr
operator|->
name|odd_fields_captured
expr_stmt|;
break|break;
case|case
name|METEORGVIDEO
case|:
name|video
operator|=
operator|(
expr|struct
name|meteor_video
operator|*
operator|)
name|arg
expr_stmt|;
name|video
operator|->
name|addr
operator|=
name|bktr
operator|->
name|video
operator|.
name|addr
expr_stmt|;
name|video
operator|->
name|width
operator|=
name|bktr
operator|->
name|video
operator|.
name|width
expr_stmt|;
name|video
operator|->
name|banksize
operator|=
name|bktr
operator|->
name|video
operator|.
name|banksize
expr_stmt|;
name|video
operator|->
name|ramsize
operator|=
name|bktr
operator|->
name|video
operator|.
name|ramsize
expr_stmt|;
break|break;
case|case
name|METEORSVIDEO
case|:
name|video
operator|=
operator|(
expr|struct
name|meteor_video
operator|*
operator|)
name|arg
expr_stmt|;
name|bktr
operator|->
name|video
operator|.
name|addr
operator|=
name|video
operator|->
name|addr
expr_stmt|;
name|bktr
operator|->
name|video
operator|.
name|width
operator|=
name|video
operator|->
name|width
expr_stmt|;
name|bktr
operator|->
name|video
operator|.
name|banksize
operator|=
name|video
operator|->
name|banksize
expr_stmt|;
name|bktr
operator|->
name|video
operator|.
name|ramsize
operator|=
name|video
operator|->
name|ramsize
expr_stmt|;
break|break;
case|case
name|METEORSFPS
case|:
name|set_fps
argument_list|(
name|bktr
argument_list|,
operator|*
operator|(
name|u_short
operator|*
operator|)
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
name|METEORGFPS
case|:
operator|*
operator|(
name|u_short
operator|*
operator|)
name|arg
operator|=
name|bktr
operator|->
name|fps
expr_stmt|;
break|break;
case|case
name|METEORSHUE
case|:
comment|/* set hue */
name|bt848
index|[
name|BKTR_HUE
index|]
operator|=
operator|(
operator|*
operator|(
name|u_char
operator|*
operator|)
name|arg
operator|)
operator|&
literal|0xff
expr_stmt|;
break|break;
case|case
name|METEORGHUE
case|:
comment|/* get hue */
operator|*
operator|(
name|u_char
operator|*
operator|)
name|arg
operator|=
name|bt848
index|[
name|BKTR_HUE
index|]
expr_stmt|;
break|break;
case|case
name|METEORSBRIG
case|:
comment|/* set brightness */
name|bt848
index|[
name|BKTR_BRIGHT
index|]
operator|=
operator|*
operator|(
name|u_char
operator|*
operator|)
name|arg
operator|&
literal|0xff
expr_stmt|;
break|break;
case|case
name|METEORGBRIG
case|:
comment|/* get brightness */
operator|*
operator|(
name|u_char
operator|*
operator|)
name|arg
operator|=
name|bt848
index|[
name|BKTR_BRIGHT
index|]
expr_stmt|;
break|break;
case|case
name|METEORSCSAT
case|:
comment|/* set chroma saturation */
name|temp
operator|=
operator|(
name|int
operator|)
operator|*
operator|(
name|u_char
operator|*
operator|)
name|arg
expr_stmt|;
name|bt848
index|[
name|BKTR_SAT_U_LO
index|]
operator|=
name|bt848
index|[
name|BKTR_SAT_V_LO
index|]
operator|=
operator|(
name|temp
operator|<<
literal|1
operator|)
operator|&
literal|0xff
expr_stmt|;
name|bt848
index|[
name|BKTR_E_CONTROL
index|]
operator|&=
operator|~
literal|0x3
expr_stmt|;
comment|/* clear U/V MSBs */
name|bt848
index|[
name|BKTR_O_CONTROL
index|]
operator|&=
operator|~
literal|0x3
expr_stmt|;
comment|/* clear U/V MSBs */
if|if
condition|(
name|temp
operator|&
literal|0x80
condition|)
block|{
name|bt848
index|[
name|BKTR_E_CONTROL
index|]
operator||=
literal|0x3
expr_stmt|;
name|bt848
index|[
name|BKTR_O_CONTROL
index|]
operator||=
literal|0x3
expr_stmt|;
block|}
break|break;
case|case
name|METEORGCSAT
case|:
comment|/* get chroma saturation */
name|temp
operator|=
operator|(
name|bt848
index|[
name|BKTR_SAT_V_LO
index|]
operator|>>
literal|1
operator|)
operator|&
literal|0xff
expr_stmt|;
if|if
condition|(
name|bt848
index|[
name|BKTR_E_CONTROL
index|]
operator|&
literal|0x01
condition|)
name|temp
operator||=
literal|0x80
expr_stmt|;
operator|*
operator|(
name|u_char
operator|*
operator|)
name|arg
operator|=
operator|(
name|u_char
operator|)
name|temp
expr_stmt|;
break|break;
case|case
name|METEORSCONT
case|:
comment|/* set contrast */
name|temp
operator|=
operator|(
name|int
operator|)
operator|*
operator|(
name|u_char
operator|*
operator|)
name|arg
operator|&
literal|0xff
expr_stmt|;
name|temp
operator|<<=
literal|1
expr_stmt|;
name|bt848
index|[
name|BKTR_CONTRAST_LO
index|]
operator|=
name|temp
operator|&
literal|0xff
expr_stmt|;
name|bt848
index|[
name|BKTR_E_CONTROL
index|]
operator|&=
operator|~
literal|0x4
expr_stmt|;
name|bt848
index|[
name|BKTR_O_CONTROL
index|]
operator|&=
operator|~
literal|0x4
expr_stmt|;
name|bt848
index|[
name|BKTR_E_CONTROL
index|]
operator||=
operator|(
operator|(
name|temp
operator|&
literal|0x100
operator|)
operator|>>
literal|6
operator|)
operator|&
literal|0x4
expr_stmt|;
name|bt848
index|[
name|BKTR_O_CONTROL
index|]
operator||=
operator|(
operator|(
name|temp
operator|&
literal|0x100
operator|)
operator|>>
literal|6
operator|)
operator|&
literal|0x4
expr_stmt|;
break|break;
case|case
name|METEORGCONT
case|:
comment|/* get contrast */
name|temp
operator|=
operator|(
name|int
operator|)
name|bt848
index|[
name|BKTR_CONTRAST_LO
index|]
operator|&
literal|0xff
expr_stmt|;
name|temp
operator||=
operator|(
operator|(
name|int
operator|)
name|bt848
index|[
name|BKTR_O_CONTROL
index|]
operator|&
literal|0x04
operator|)
operator|<<
literal|6
expr_stmt|;
operator|*
operator|(
name|u_char
operator|*
operator|)
name|arg
operator|=
call|(
name|u_char
call|)
argument_list|(
operator|(
name|temp
operator|>>
literal|1
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
break|break;
comment|/* hue is a 2's compliment number, -90' to +89.3' in 0.7' steps */
case|case
name|BT848_SHUE
case|:
comment|/* set hue */
name|bt848
index|[
name|BKTR_HUE
index|]
operator|=
call|(
name|u_char
call|)
argument_list|(
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|&
literal|0xff
argument_list|)
expr_stmt|;
break|break;
case|case
name|BT848_GHUE
case|:
comment|/* get hue */
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|=
name|bt848
index|[
name|BKTR_HUE
index|]
operator|&
literal|0xff
expr_stmt|;
break|break;
comment|/* brightness is a 2's compliment #, -50 to +%49.6% in 0.39% steps */
case|case
name|BT848_SBRIG
case|:
comment|/* set brightness */
name|bt848
index|[
name|BKTR_BRIGHT
index|]
operator|=
call|(
name|u_char
call|)
argument_list|(
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|&
literal|0xff
argument_list|)
expr_stmt|;
break|break;
case|case
name|BT848_GBRIG
case|:
comment|/* get brightness */
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|=
name|bt848
index|[
name|BKTR_BRIGHT
index|]
operator|&
literal|0xff
expr_stmt|;
break|break;
comment|/*  */
case|case
name|BT848_SCSAT
case|:
comment|/* set chroma saturation */
name|tmp_int
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
expr_stmt|;
name|temp
operator|=
name|bt848
index|[
name|BKTR_E_CONTROL
index|]
operator|&
literal|0xfc
expr_stmt|;
name|temp1
operator|=
name|bt848
index|[
name|BKTR_O_CONTROL
index|]
operator|&
literal|0xfc
expr_stmt|;
if|if
condition|(
name|tmp_int
operator|&
literal|0x100
condition|)
block|{
name|temp
operator||=
literal|0x03
expr_stmt|;
name|temp1
operator||=
literal|0x03
expr_stmt|;
block|}
name|bt848
index|[
name|BKTR_SAT_U_LO
index|]
operator|=
call|(
name|u_char
call|)
argument_list|(
name|tmp_int
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|bt848
index|[
name|BKTR_SAT_V_LO
index|]
operator|=
call|(
name|u_char
call|)
argument_list|(
name|tmp_int
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|bt848
index|[
name|BKTR_E_CONTROL
index|]
operator|=
name|temp
expr_stmt|;
name|bt848
index|[
name|BKTR_O_CONTROL
index|]
operator|=
name|temp1
expr_stmt|;
break|break;
case|case
name|BT848_GCSAT
case|:
comment|/* get chroma saturation */
name|tmp_int
operator|=
operator|(
name|int
operator|)
name|bt848
index|[
name|BKTR_SAT_V_LO
index|]
operator|&
literal|0xff
expr_stmt|;
if|if
condition|(
name|bt848
index|[
name|BKTR_E_CONTROL
index|]
operator|&
literal|0x01
condition|)
name|tmp_int
operator||=
literal|0x0100
expr_stmt|;
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|=
name|tmp_int
expr_stmt|;
break|break;
comment|/*  */
case|case
name|BT848_SVSAT
case|:
comment|/* set chroma V saturation */
name|tmp_int
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
expr_stmt|;
name|temp
operator|=
name|bt848
index|[
name|BKTR_E_CONTROL
index|]
operator|&
literal|0xfe
expr_stmt|;
name|temp1
operator|=
name|bt848
index|[
name|BKTR_O_CONTROL
index|]
operator|&
literal|0xfe
expr_stmt|;
if|if
condition|(
name|tmp_int
operator|&
literal|0x100
condition|)
block|{
name|temp
operator||=
literal|0x01
expr_stmt|;
name|temp1
operator||=
literal|0x01
expr_stmt|;
block|}
name|bt848
index|[
name|BKTR_SAT_V_LO
index|]
operator|=
call|(
name|u_char
call|)
argument_list|(
name|tmp_int
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|bt848
index|[
name|BKTR_E_CONTROL
index|]
operator|=
name|temp
expr_stmt|;
name|bt848
index|[
name|BKTR_O_CONTROL
index|]
operator|=
name|temp1
expr_stmt|;
break|break;
case|case
name|BT848_GVSAT
case|:
comment|/* get chroma V saturation */
name|tmp_int
operator|=
operator|(
name|int
operator|)
name|bt848
index|[
name|BKTR_SAT_V_LO
index|]
operator|&
literal|0xff
expr_stmt|;
if|if
condition|(
name|bt848
index|[
name|BKTR_E_CONTROL
index|]
operator|&
literal|0x01
condition|)
name|tmp_int
operator||=
literal|0x0100
expr_stmt|;
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|=
name|tmp_int
expr_stmt|;
break|break;
comment|/*  */
case|case
name|BT848_SUSAT
case|:
comment|/* set chroma U saturation */
name|tmp_int
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
expr_stmt|;
name|temp
operator|=
name|bt848
index|[
name|BKTR_E_CONTROL
index|]
operator|&
literal|0xfd
expr_stmt|;
name|temp1
operator|=
name|bt848
index|[
name|BKTR_O_CONTROL
index|]
operator|&
literal|0xfd
expr_stmt|;
if|if
condition|(
name|tmp_int
operator|&
literal|0x100
condition|)
block|{
name|temp
operator||=
literal|0x02
expr_stmt|;
name|temp1
operator||=
literal|0x02
expr_stmt|;
block|}
name|bt848
index|[
name|BKTR_SAT_U_LO
index|]
operator|=
call|(
name|u_char
call|)
argument_list|(
name|tmp_int
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|bt848
index|[
name|BKTR_E_CONTROL
index|]
operator|=
name|temp
expr_stmt|;
name|bt848
index|[
name|BKTR_O_CONTROL
index|]
operator|=
name|temp1
expr_stmt|;
break|break;
case|case
name|BT848_GUSAT
case|:
comment|/* get chroma U saturation */
name|tmp_int
operator|=
operator|(
name|int
operator|)
name|bt848
index|[
name|BKTR_SAT_U_LO
index|]
operator|&
literal|0xff
expr_stmt|;
if|if
condition|(
name|bt848
index|[
name|BKTR_E_CONTROL
index|]
operator|&
literal|0x02
condition|)
name|tmp_int
operator||=
literal|0x0100
expr_stmt|;
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|=
name|tmp_int
expr_stmt|;
break|break;
comment|/*  */
case|case
name|BT848_SCONT
case|:
comment|/* set contrast */
name|tmp_int
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
expr_stmt|;
name|temp
operator|=
name|bt848
index|[
name|BKTR_E_CONTROL
index|]
operator|&
literal|0xfb
expr_stmt|;
name|temp1
operator|=
name|bt848
index|[
name|BKTR_O_CONTROL
index|]
operator|&
literal|0xfb
expr_stmt|;
if|if
condition|(
name|tmp_int
operator|&
literal|0x100
condition|)
block|{
name|temp
operator||=
literal|0x04
expr_stmt|;
name|temp1
operator||=
literal|0x04
expr_stmt|;
block|}
name|bt848
index|[
name|BKTR_CONTRAST_LO
index|]
operator|=
call|(
name|u_char
call|)
argument_list|(
name|tmp_int
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|bt848
index|[
name|BKTR_E_CONTROL
index|]
operator|=
name|temp
expr_stmt|;
name|bt848
index|[
name|BKTR_O_CONTROL
index|]
operator|=
name|temp1
expr_stmt|;
break|break;
case|case
name|BT848_GCONT
case|:
comment|/* get contrast */
name|tmp_int
operator|=
operator|(
name|int
operator|)
name|bt848
index|[
name|BKTR_CONTRAST_LO
index|]
operator|&
literal|0xff
expr_stmt|;
if|if
condition|(
name|bt848
index|[
name|BKTR_E_CONTROL
index|]
operator|&
literal|0x04
condition|)
name|tmp_int
operator||=
literal|0x0100
expr_stmt|;
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|=
name|tmp_int
expr_stmt|;
break|break;
case|case
name|BT848_SCBARS
case|:
comment|/* set colorbar output */
name|bt848
index|[
name|BKTR_COLOR_CTL
index|]
operator||=
literal|0x40
expr_stmt|;
break|break;
case|case
name|BT848_CCBARS
case|:
comment|/* clear colorbar output */
name|bt848
index|[
name|BKTR_COLOR_CTL
index|]
operator|&=
operator|~
literal|0x40
expr_stmt|;
break|break;
case|case
name|METEORSSIGNAL
case|:
name|bktr
operator|->
name|signal
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
expr_stmt|;
name|bktr
operator|->
name|proc
operator|=
name|pr
expr_stmt|;
break|break;
case|case
name|METEORGSIGNAL
case|:
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|=
name|bktr
operator|->
name|signal
expr_stmt|;
break|break;
case|case
name|METEORCAPTUR
case|:
name|temp
operator|=
name|bktr
operator|->
name|flags
expr_stmt|;
switch|switch
condition|(
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
condition|)
block|{
case|case
name|METEOR_CAP_SINGLE
case|:
if|if
condition|(
name|bktr
operator|->
name|bigbuf
operator|==
literal|0
condition|)
comment|/* no frame buffer allocated */
return|return
operator|(
name|ENOMEM
operator|)
return|;
comment|/*			if (temp& METEOR_CAP_MASK) 				return(EIO);		 already capturing */
name|start_capture
argument_list|(
name|bktr
argument_list|,
name|METEOR_SINGLE
argument_list|)
expr_stmt|;
name|bktr
operator|->
name|flags
operator||=
name|METEOR_SINGLE
expr_stmt|;
name|bktr
operator|->
name|flags
operator|&=
operator|~
name|METEOR_WANT_MASK
expr_stmt|;
comment|/* wait for capture to complete */
name|btl_reg
operator|=
operator|(
name|u_long
operator|*
operator|)
operator|&
name|bt848
index|[
name|BKTR_INT_STAT
index|]
expr_stmt|;
operator|*
name|btl_reg
operator|=
literal|0xffffffff
expr_stmt|;
name|btl_reg
operator|=
operator|(
name|u_long
operator|*
operator|)
operator|&
name|bt848
index|[
name|BKTR_GPIO_OUT_EN
index|]
expr_stmt|;
operator|*
name|btl_reg
operator|=
literal|1
expr_stmt|;
name|bts_reg
operator|=
operator|(
name|u_short
operator|*
operator|)
operator|&
name|bt848
index|[
name|BKTR_GPIO_DMA_CTL
index|]
expr_stmt|;
operator|*
name|bts_reg
operator|=
literal|0x1
expr_stmt|;
operator|*
name|bts_reg
operator|=
name|bktr
operator|->
name|capcontrol
expr_stmt|;
name|btl_reg
operator|=
operator|(
name|u_long
operator|*
operator|)
operator|&
name|bt848
index|[
name|BKTR_INT_MASK
index|]
expr_stmt|;
operator|*
name|btl_reg
operator|=
literal|1
operator|<<
literal|23
operator||
literal|1
operator|<<
literal|11
operator||
literal|2
operator||
literal|1
expr_stmt|;
name|error
operator|=
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
name|bktr
argument_list|,
name|METPRI
argument_list|,
literal|"capturing"
argument_list|,
name|hz
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|btl_reg
operator|=
operator|(
name|u_long
operator|*
operator|)
operator|&
name|bt848
index|[
name|BKTR_RISC_COUNT
index|]
expr_stmt|;
name|printf
argument_list|(
literal|"bktr%d: ioctl: tsleep error %d %x\n"
argument_list|,
name|unit
argument_list|,
name|error
argument_list|,
operator|*
name|btl_reg
argument_list|)
expr_stmt|;
block|}
name|bktr
operator|->
name|flags
operator|&=
operator|~
operator|(
name|METEOR_SINGLE
operator||
name|METEOR_WANT_MASK
operator|)
expr_stmt|;
name|btl_reg
operator|=
operator|(
name|u_long
operator|*
operator|)
operator|&
name|bt848
index|[
name|BKTR_INT_STAT
index|]
expr_stmt|;
break|break;
case|case
name|METEOR_CAP_CONTINOUS
case|:
if|if
condition|(
name|bktr
operator|->
name|bigbuf
operator|==
literal|0
condition|)
comment|/* no frame buffer allocated */
return|return
operator|(
name|ENOMEM
operator|)
return|;
if|if
condition|(
name|temp
operator|&
name|METEOR_CAP_MASK
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
comment|/* already capturing */
name|start_capture
argument_list|(
name|bktr
argument_list|,
name|METEOR_CONTIN
argument_list|)
expr_stmt|;
name|btl_reg
operator|=
operator|(
name|u_long
operator|*
operator|)
operator|&
name|bt848
index|[
name|BKTR_INT_STAT
index|]
expr_stmt|;
operator|*
name|btl_reg
operator|=
operator|*
name|btl_reg
expr_stmt|;
name|bts_reg
operator|=
operator|(
name|u_short
operator|*
operator|)
operator|&
name|bt848
index|[
name|BKTR_GPIO_DMA_CTL
index|]
expr_stmt|;
operator|*
name|bts_reg
operator|=
literal|1
expr_stmt|;
operator|*
name|bts_reg
operator|=
name|bktr
operator|->
name|capcontrol
expr_stmt|;
name|btl_reg
operator|=
operator|(
name|u_long
operator|*
operator|)
operator|&
name|bt848
index|[
name|BKTR_INT_MASK
index|]
expr_stmt|;
operator|*
name|btl_reg
operator|=
literal|1
operator|<<
literal|23
operator||
literal|1
operator|<<
literal|11
operator||
literal|2
operator||
literal|1
expr_stmt|;
comment|/*			dump_bt848(bt848); */
break|break;
case|case
name|METEOR_CAP_STOP_CONT
case|:
if|if
condition|(
name|bktr
operator|->
name|flags
operator|&
name|METEOR_CONTIN
condition|)
block|{
comment|/* turn off capture */
name|btl_reg
operator|=
operator|(
name|u_long
operator|*
operator|)
operator|&
name|bt848
index|[
name|BKTR_INT_MASK
index|]
expr_stmt|;
operator|*
name|btl_reg
operator|=
literal|0
expr_stmt|;
name|bts_reg
operator|=
operator|(
name|u_short
operator|*
operator|)
operator|&
name|bt848
index|[
name|BKTR_GPIO_DMA_CTL
index|]
expr_stmt|;
operator|*
name|bts_reg
operator|=
literal|0
expr_stmt|;
name|bktr
operator|->
name|flags
operator|&=
operator|~
operator|(
name|METEOR_CONTIN
operator||
name|METEOR_WANT_MASK
operator|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|METEORSETGEO
case|:
name|geo
operator|=
operator|(
expr|struct
name|meteor_geomet
operator|*
operator|)
name|arg
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
comment|/* Either even or odd, if even& odd, then these a zero */
if|if
condition|(
operator|(
name|geo
operator|->
name|oformat
operator|&
name|METEOR_GEO_ODD_ONLY
operator|)
operator|&&
operator|(
name|geo
operator|->
name|oformat
operator|&
name|METEOR_GEO_EVEN_ONLY
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"bktr%d: ioctl: Geometry odd or even only.\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
comment|/* set/clear even/odd flags */
if|if
condition|(
name|geo
operator|->
name|oformat
operator|&
name|METEOR_GEO_ODD_ONLY
condition|)
name|bktr
operator|->
name|flags
operator||=
name|METEOR_ONLY_ODD_FIELDS
expr_stmt|;
else|else
name|bktr
operator|->
name|flags
operator|&=
operator|~
name|METEOR_ONLY_ODD_FIELDS
expr_stmt|;
if|if
condition|(
name|geo
operator|->
name|oformat
operator|&
name|METEOR_GEO_EVEN_ONLY
condition|)
name|bktr
operator|->
name|flags
operator||=
name|METEOR_ONLY_EVEN_FIELDS
expr_stmt|;
else|else
name|bktr
operator|->
name|flags
operator|&=
operator|~
name|METEOR_ONLY_EVEN_FIELDS
expr_stmt|;
comment|/* can't change parameters while capturing */
comment|/* XXX: 		if (bktr->flags& METEOR_CAP_MASK) 			return(EBUSY); */
if|if
condition|(
operator|(
name|geo
operator|->
name|columns
operator|&
literal|0x3fe
operator|)
operator|!=
name|geo
operator|->
name|columns
condition|)
block|{
name|printf
argument_list|(
literal|"bktr%d: ioctl: %d: columns too large or not even.\n"
argument_list|,
name|unit
argument_list|,
name|geo
operator|->
name|columns
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|(
name|geo
operator|->
name|rows
operator|&
literal|0x7fe
operator|)
operator|!=
name|geo
operator|->
name|rows
operator|)
operator|||
operator|(
operator|(
name|geo
operator|->
name|oformat
operator|&
name|METEOR_GEO_FIELD_MASK
operator|)
operator|&&
operator|(
operator|(
name|geo
operator|->
name|rows
operator|&
literal|0x3fe
operator|)
operator|!=
name|geo
operator|->
name|rows
operator|)
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"bktr%d: ioctl: %d: rows too large or not even.\n"
argument_list|,
name|unit
argument_list|,
name|geo
operator|->
name|rows
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
if|if
condition|(
name|geo
operator|->
name|frames
operator|>
literal|32
condition|)
block|{
name|printf
argument_list|(
literal|"bktr%d: ioctl: too many frames.\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
name|bktr
operator|->
name|dma_prog_loaded
operator|=
literal|0
expr_stmt|;
name|bts_reg
operator|=
operator|(
name|u_short
operator|*
operator|)
operator|&
name|bt848
index|[
name|BKTR_GPIO_DMA_CTL
index|]
expr_stmt|;
operator|*
name|bts_reg
operator|=
literal|0
expr_stmt|;
name|btl_reg
operator|=
operator|(
name|u_long
operator|*
operator|)
operator|&
name|bt848
index|[
name|BKTR_INT_MASK
index|]
expr_stmt|;
operator|*
name|btl_reg
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|temp
operator|=
name|geo
operator|->
name|rows
operator|*
name|geo
operator|->
name|columns
operator|*
name|geo
operator|->
name|frames
operator|*
literal|2
condition|)
block|{
if|if
condition|(
name|geo
operator|->
name|oformat
operator|&
name|METEOR_GEO_RGB24
condition|)
name|temp
operator|=
name|temp
operator|*
literal|2
expr_stmt|;
comment|/* meteor_mem structure for SYNC Capture */
if|if
condition|(
name|geo
operator|->
name|frames
operator|>
literal|1
condition|)
name|temp
operator|+=
name|PAGE_SIZE
expr_stmt|;
name|temp
operator|=
name|btoc
argument_list|(
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|int
operator|)
name|temp
operator|>
name|bktr
operator|->
name|alloc_pages
operator|&&
name|bktr
operator|->
name|video
operator|.
name|addr
operator|==
literal|0
condition|)
block|{
name|buf
operator|=
name|get_bktr_mem
argument_list|(
name|unit
argument_list|,
name|temp
operator|*
name|PAGE_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|!=
literal|0
condition|)
block|{
name|kmem_free
argument_list|(
name|kernel_map
argument_list|,
name|bktr
operator|->
name|bigbuf
argument_list|,
operator|(
name|bktr
operator|->
name|alloc_pages
operator|*
name|PAGE_SIZE
operator|)
argument_list|)
expr_stmt|;
name|bktr
operator|->
name|bigbuf
operator|=
name|buf
expr_stmt|;
name|bktr
operator|->
name|alloc_pages
operator|=
name|temp
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"meteor%d: ioctl: Allocating %d bytes\n"
argument_list|,
name|unit
argument_list|,
name|temp
operator|*
name|PAGE_SIZE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|ENOMEM
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
name|bktr
operator|->
name|rows
operator|=
name|geo
operator|->
name|rows
expr_stmt|;
name|bktr
operator|->
name|cols
operator|=
name|geo
operator|->
name|columns
expr_stmt|;
name|bktr
operator|->
name|frames
operator|=
name|geo
operator|->
name|frames
expr_stmt|;
comment|/* horizontal scale */
comment|/* temp = ((910.0/( (float) bktr->cols *1.21875)) - 1.0) * 4096.0;*/
comment|/* temp = ((910.0/( (float) bktr->cols *1.212)) - 1.0) * 4096.0; */
name|temp
operator|=
operator|(
operator|(
literal|910.0
operator|/
operator|(
operator|(
name|float
operator|)
name|bktr
operator|->
name|cols
operator|*
literal|1.21875
operator|)
operator|)
operator|-
literal|1.0
operator|)
operator|*
literal|4096.0
expr_stmt|;
comment|/* temp = ((754.0/(float) bktr->cols) - 1 ) * 4096.0;*/
name|bt848
index|[
name|BKTR_E_HSCALE_LO
index|]
operator|=
name|temp
operator|&
literal|0xff
expr_stmt|;
name|bt848
index|[
name|BKTR_O_HSCALE_LO
index|]
operator|=
name|temp
operator|&
literal|0xff
expr_stmt|;
name|bt848
index|[
name|BKTR_E_HSCALE_HI
index|]
operator|=
operator|(
name|temp
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
name|bt848
index|[
name|BKTR_O_HSCALE_HI
index|]
operator|=
operator|(
name|temp
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
comment|/* horizontal active */
name|temp
operator|=
name|bktr
operator|->
name|cols
expr_stmt|;
name|bt848
index|[
name|BKTR_E_HACTIVE_LO
index|]
operator|=
name|temp
operator|&
literal|0xff
expr_stmt|;
name|bt848
index|[
name|BKTR_O_HACTIVE_LO
index|]
operator|=
name|temp
operator|&
literal|0xff
expr_stmt|;
name|bt848
index|[
name|BKTR_EVEN_CROP
index|]
operator|&=
operator|~
literal|0x3
expr_stmt|;
name|bt848
index|[
name|BKTR_ODD_CROP
index|]
operator|&=
operator|~
literal|0x3
expr_stmt|;
name|bt848
index|[
name|BKTR_EVEN_CROP
index|]
operator||=
operator|(
name|temp
operator|>>
literal|8
operator|)
operator|&
literal|0x3
expr_stmt|;
name|bt848
index|[
name|BKTR_ODD_CROP
index|]
operator||=
operator|(
name|temp
operator|>>
literal|8
operator|)
operator|&
literal|0x3
expr_stmt|;
comment|/* horizontal delay */
name|temp
operator|=
operator|(
operator|(
literal|135.0
operator|/
literal|754.0
operator|)
operator|*
operator|(
name|float
operator|)
name|bktr
operator|->
name|cols
operator|)
expr_stmt|;
name|temp
operator|=
name|temp
operator|+
literal|2
expr_stmt|;
name|temp
operator|=
name|temp
operator|&
literal|0x3fe
expr_stmt|;
name|bt848
index|[
name|BKTR_E_DELAY_LO
index|]
operator|=
name|temp
operator|&
literal|0xff
expr_stmt|;
name|bt848
index|[
name|BKTR_O_DELAY_LO
index|]
operator|=
name|temp
operator|&
literal|0xff
expr_stmt|;
name|bt848
index|[
name|BKTR_EVEN_CROP
index|]
operator|&=
operator|~
literal|0xc
expr_stmt|;
name|bt848
index|[
name|BKTR_ODD_CROP
index|]
operator|&=
operator|~
literal|0xc
expr_stmt|;
name|bt848
index|[
name|BKTR_EVEN_CROP
index|]
operator||=
operator|(
name|temp
operator|>>
literal|6
operator|)
operator|&
literal|0xc
expr_stmt|;
name|bt848
index|[
name|BKTR_ODD_CROP
index|]
operator||=
operator|(
name|temp
operator|>>
literal|6
operator|)
operator|&
literal|0xc
expr_stmt|;
comment|/* vscale */
if|if
condition|(
name|geo
operator|->
name|oformat
operator|&
name|METEOR_GEO_ODD_ONLY
operator|||
name|geo
operator|->
name|oformat
operator|&
name|METEOR_GEO_EVEN_ONLY
condition|)
block|{
name|tmp_int
operator|=
literal|65536.0
operator|-
operator|(
operator|(
operator|(
literal|240.0
operator|/
operator|(
name|float
operator|)
name|bktr
operator|->
name|rows
operator|)
operator|-
literal|1.0
operator|)
operator|*
literal|512.0
operator|)
expr_stmt|;
block|}
else|else
block|{
name|tmp_int
operator|=
literal|65536
operator|-
operator|(
operator|(
operator|(
literal|480.0
operator|/
operator|(
name|float
operator|)
name|bktr
operator|->
name|rows
operator|)
operator|-
literal|1.0
operator|)
operator|*
literal|512
operator|)
expr_stmt|;
block|}
name|tmp_int
operator|&=
literal|0x1fff
expr_stmt|;
comment|/* Vertical scaling */
name|bt848
index|[
name|BKTR_E_VSCALE_LO
index|]
operator|=
name|tmp_int
operator|&
literal|0xff
expr_stmt|;
name|bt848
index|[
name|BKTR_O_VSCALE_LO
index|]
operator|=
name|tmp_int
operator|&
literal|0xff
expr_stmt|;
name|bt848
index|[
name|BKTR_E_VSCALE_HI
index|]
operator|&=
operator|~
literal|0x1f
expr_stmt|;
name|bt848
index|[
name|BKTR_O_VSCALE_HI
index|]
operator|&=
operator|~
literal|0x1f
expr_stmt|;
name|bt848
index|[
name|BKTR_E_VSCALE_HI
index|]
operator||=
operator|(
name|tmp_int
operator|>>
literal|8
operator|)
operator|&
literal|0x1f
expr_stmt|;
name|bt848
index|[
name|BKTR_O_VSCALE_HI
index|]
operator||=
operator|(
name|tmp_int
operator|>>
literal|8
operator|)
operator|&
literal|0x1f
expr_stmt|;
name|bktr
operator|->
name|format
operator|=
name|METEOR_GEO_YUV_422
expr_stmt|;
switch|switch
condition|(
name|geo
operator|->
name|oformat
operator|&
name|METEOR_GEO_OUTPUT_MASK
condition|)
block|{
case|case
literal|0
case|:
comment|/* default */
case|case
name|METEOR_GEO_RGB16
case|:
name|bktr
operator|->
name|format
operator|=
name|METEOR_GEO_RGB16
expr_stmt|;
name|bktr
operator|->
name|depth
operator|=
literal|2
expr_stmt|;
break|break;
case|case
name|METEOR_GEO_RGB24
case|:
name|bktr
operator|->
name|format
operator|=
name|METEOR_GEO_RGB24
expr_stmt|;
name|bktr
operator|->
name|depth
operator|=
literal|4
expr_stmt|;
break|break;
case|case
name|METEOR_GEO_YUV_422
case|:
name|bktr
operator|->
name|format
operator|=
name|METEOR_GEO_YUV_422
expr_stmt|;
break|break;
case|case
name|METEOR_GEO_YUV_PACKED
case|:
name|bktr
operator|->
name|format
operator|=
name|METEOR_GEO_YUV_PACKED
expr_stmt|;
break|break;
block|}
comment|/* 		if (geo->oformat& METEOR_GEO_YUV_12 ) 			bktr->format |= METEOR_GEO_YUV_12; 		else if (geo->oformat& METEOR_GEO_YUV_9 ) 			bktr->format |= METEOR_GEO_YUV_9; */
if|if
condition|(
name|bktr
operator|->
name|flags
operator|&
name|METEOR_CAP_MASK
condition|)
block|{
if|if
condition|(
name|bktr
operator|->
name|flags
operator|&
operator|(
name|METEOR_CONTIN
operator||
name|METEOR_SYNCAP
operator|)
condition|)
block|{
switch|switch
condition|(
name|bktr
operator|->
name|flags
operator|&
name|METEOR_ONLY_FIELDS_MASK
condition|)
block|{
case|case
name|METEOR_ONLY_ODD_FIELDS
case|:
name|bktr
operator|->
name|flags
operator||=
name|METEOR_WANT_ODD
expr_stmt|;
break|break;
case|case
name|METEOR_ONLY_EVEN_FIELDS
case|:
name|bktr
operator|->
name|flags
operator||=
name|METEOR_WANT_EVEN
expr_stmt|;
break|break;
default|default:
name|bktr
operator|->
name|flags
operator||=
name|METEOR_WANT_MASK
expr_stmt|;
break|break;
block|}
name|start_capture
argument_list|(
name|bktr
argument_list|,
name|METEOR_CONTIN
argument_list|)
expr_stmt|;
name|btl_reg
operator|=
operator|(
name|u_long
operator|*
operator|)
operator|&
name|bt848
index|[
name|BKTR_INT_STAT
index|]
expr_stmt|;
operator|*
name|btl_reg
operator|=
operator|*
name|btl_reg
expr_stmt|;
name|bts_reg
operator|=
operator|(
name|u_short
operator|*
operator|)
operator|&
name|bt848
index|[
name|BKTR_GPIO_DMA_CTL
index|]
expr_stmt|;
operator|*
name|bts_reg
operator|=
literal|0x1
expr_stmt|;
operator|*
name|bts_reg
operator|=
name|bktr
operator|->
name|capcontrol
expr_stmt|;
name|btl_reg
operator|=
operator|(
name|u_long
operator|*
operator|)
operator|&
name|bt848
index|[
name|BKTR_INT_MASK
index|]
expr_stmt|;
operator|*
name|btl_reg
operator|=
literal|1
operator|<<
literal|23
operator||
literal|2
operator||
literal|1
expr_stmt|;
block|}
block|}
break|break;
comment|/* end of METEORSETGEO */
default|default:
return|return
name|ENODEV
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  *   */
end_comment

begin_function
name|int
name|bktr_mmap
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|nprot
parameter_list|)
block|{
name|int
name|unit
decl_stmt|;
name|bktr_reg_t
modifier|*
name|bktr
decl_stmt|;
name|unit
operator|=
name|UNIT
argument_list|(
name|minor
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|unit
operator|>=
name|NBKTR
condition|)
comment|/* at this point could this happen? */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|bktr
operator|=
operator|&
operator|(
name|brooktree
index|[
name|unit
index|]
operator|)
expr_stmt|;
if|if
condition|(
name|nprot
operator|&
name|PROT_EXEC
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|offset
operator|>=
name|bktr
operator|->
name|alloc_pages
operator|*
name|PAGE_SIZE
condition|)
return|return
operator|-
literal|1
return|;
return|return
name|i386_btop
argument_list|(
name|vtophys
argument_list|(
name|bktr
operator|->
name|bigbuf
argument_list|)
operator|+
name|offset
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************  * tuner specific routines:  */
end_comment

begin_comment
comment|/* guaranteed address for any TSA5522 */
end_comment

begin_define
define|#
directive|define
name|TSA5522_WADDR
value|0xc2
end_define

begin_define
define|#
directive|define
name|TSA5522_RADDR
value|0xc3
end_define

begin_comment
comment|/* EEProm */
end_comment

begin_define
define|#
directive|define
name|X24C01_WADDR
value|0xae
end_define

begin_comment
comment|/* STB */
end_comment

begin_define
define|#
directive|define
name|X24C01_RADDR
value|0xaf
end_define

begin_comment
comment|/*  * bit 7: CONTROL BYTE = 1  * bit 6: CP = 0		moderate speed tuning, better FM  * bit 5: T2 = 0		normal operation  * bit 4: T1 = 0		normal operation  * bit 3: T0 = 1		normal operation  * bit 2: RSA = 1		62.5kHz  * bit 1: RSB = 1		62.5kHz  * bit 0: OS = 0		normal operation  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|TEMIC_TUNER
argument_list|)
end_if

begin_define
define|#
directive|define
name|TSA5522_CONTROL
value|0xce
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|TSA5522_CONTROL
value|0x8e
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|TEMIC_TUNER
argument_list|)
end_if

begin_define
define|#
directive|define
name|TSA5522_BANDA
value|0x02
end_define

begin_define
define|#
directive|define
name|TSA5522_BANDB
value|0x04
end_define

begin_define
define|#
directive|define
name|TSA5522_BANDC
value|0x01
end_define

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|PHILIPS_TUNER
argument_list|)
end_elif

begin_define
define|#
directive|define
name|TSA5522_BANDA
value|0xa0
end_define

begin_define
define|#
directive|define
name|TSA5522_BANDB
value|0x90
end_define

begin_define
define|#
directive|define
name|TSA5522_BANDC
value|0x30
end_define

begin_else
else|#
directive|else
end_else

begin_error
error|#
directive|error
error|you must define a tuner type
end_error

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* XXXXXX_TUNER */
end_comment

begin_comment
comment|/******************************* i2c primitives ******************************/
end_comment

begin_comment
comment|/* delays for the I2C bus transactions */
end_comment

begin_define
define|#
directive|define
name|NDELAY
value|0
end_define

begin_if
if|#
directive|if
name|defined
argument_list|(
name|ORIGINAL_DELAYS
argument_list|)
end_if

begin_define
define|#
directive|define
name|SDELAY
value|2
end_define

begin_define
define|#
directive|define
name|LDELAY
value|20
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|SDELAY
value|10
end_define

begin_define
define|#
directive|define
name|LDELAY
value|40
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ORIGINAL_DELAYS */
end_comment

begin_comment
comment|/* macros to show the details more clearly */
end_comment

begin_typedef
typedef|typedef
specifier|volatile
name|u_long
modifier|*
name|i2c_regptr_t
typedef|;
end_typedef

begin_comment
comment|/*  * primitives for the I2C clock phases  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|DataLo_ClockLo
parameter_list|(
name|i2c_regptr_t
name|bti2c
parameter_list|,
name|int
name|delay
parameter_list|)
block|{
operator|*
name|bti2c
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|delay
condition|)
name|DELAY
argument_list|(
name|delay
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|DataHi_ClockLo
parameter_list|(
name|i2c_regptr_t
name|bti2c
parameter_list|,
name|int
name|delay
parameter_list|)
block|{
operator|*
name|bti2c
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|delay
condition|)
name|DELAY
argument_list|(
name|delay
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|DataLo_ClockHi
parameter_list|(
name|i2c_regptr_t
name|bti2c
parameter_list|,
name|int
name|delay
parameter_list|)
block|{
operator|*
name|bti2c
operator|=
literal|2
expr_stmt|;
if|if
condition|(
name|delay
condition|)
name|DELAY
argument_list|(
name|delay
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|DataHi_ClockHi
parameter_list|(
name|i2c_regptr_t
name|bti2c
parameter_list|,
name|int
name|delay
parameter_list|)
block|{
operator|*
name|bti2c
operator|=
literal|3
expr_stmt|;
if|if
condition|(
name|delay
condition|)
name|DELAY
argument_list|(
name|delay
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|DataRead
parameter_list|(
name|i2c_regptr_t
name|bti2c
parameter_list|)
block|{
return|return
operator|(
operator|*
name|bti2c
operator|&
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* forward reference */
end_comment

begin_function_decl
specifier|static
name|int
name|i2cWrite
parameter_list|(
name|i2c_regptr_t
parameter_list|,
name|u_char
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * start an I2C bus transaction  */
end_comment

begin_function
specifier|static
name|int
name|i2cStart
parameter_list|(
name|i2c_regptr_t
name|bti2c
parameter_list|,
name|int
name|address
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|EXTRA_START
argument_list|)
comment|/* ensure the proper starting state */
name|DataHi_ClockLo
argument_list|(
name|bti2c
argument_list|,
name|LDELAY
argument_list|)
expr_stmt|;
comment|/* release data */
name|DataHi_ClockHi
argument_list|(
name|bti2c
argument_list|,
name|LDELAY
argument_list|)
expr_stmt|;
comment|/* release clock */
endif|#
directive|endif
comment|/* EXTRA_START */
name|DataLo_ClockHi
argument_list|(
name|bti2c
argument_list|,
name|LDELAY
argument_list|)
expr_stmt|;
comment|/* lower data */
name|DataLo_ClockLo
argument_list|(
name|bti2c
argument_list|,
name|LDELAY
argument_list|)
expr_stmt|;
comment|/* lower clock */
comment|/* send the address of the device */
return|return
name|i2cWrite
argument_list|(
name|bti2c
argument_list|,
name|address
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * stop an I2C bus transaction  */
end_comment

begin_function
specifier|static
name|void
name|i2cStop
parameter_list|(
name|i2c_regptr_t
name|bti2c
parameter_list|)
block|{
name|DELAY
argument_list|(
name|LDELAY
argument_list|)
expr_stmt|;
name|DataLo_ClockLo
argument_list|(
name|bti2c
argument_list|,
name|LDELAY
argument_list|)
expr_stmt|;
comment|/* lower clock& data */
name|DataLo_ClockHi
argument_list|(
name|bti2c
argument_list|,
name|LDELAY
argument_list|)
expr_stmt|;
comment|/* release clock */
name|DataHi_ClockHi
argument_list|(
name|bti2c
argument_list|,
name|LDELAY
argument_list|)
expr_stmt|;
comment|/* release data */
block|}
end_function

begin_comment
comment|/*  * place a '1' bit on the I2C bus  */
end_comment

begin_function
specifier|static
name|void
name|i2cHi
parameter_list|(
name|i2c_regptr_t
name|bti2c
parameter_list|)
block|{
name|DataHi_ClockLo
argument_list|(
name|bti2c
argument_list|,
name|LDELAY
argument_list|)
expr_stmt|;
comment|/* assert HI data */
name|DataHi_ClockHi
argument_list|(
name|bti2c
argument_list|,
name|LDELAY
argument_list|)
expr_stmt|;
comment|/* strobe clock */
name|DataHi_ClockLo
argument_list|(
name|bti2c
argument_list|,
name|LDELAY
argument_list|)
expr_stmt|;
comment|/* release clock */
block|}
end_function

begin_comment
comment|/*  * place a '0' bit on the I2C bus  */
end_comment

begin_function
specifier|static
name|void
name|i2cLo
parameter_list|(
name|i2c_regptr_t
name|bti2c
parameter_list|)
block|{
name|DataLo_ClockLo
argument_list|(
name|bti2c
argument_list|,
name|LDELAY
argument_list|)
expr_stmt|;
comment|/* assert LO data */
name|DataLo_ClockHi
argument_list|(
name|bti2c
argument_list|,
name|LDELAY
argument_list|)
expr_stmt|;
comment|/* strobe clock */
name|DataLo_ClockLo
argument_list|(
name|bti2c
argument_list|,
name|LDELAY
argument_list|)
expr_stmt|;
comment|/* release clock */
block|}
end_function

begin_comment
comment|/*  * give an 'ACK' to the slave  */
end_comment

begin_function
specifier|static
name|void
name|i2cGrantAck
parameter_list|(
name|i2c_regptr_t
name|bti2c
parameter_list|)
block|{
name|DataLo_ClockLo
argument_list|(
name|bti2c
argument_list|,
name|LDELAY
argument_list|)
expr_stmt|;
comment|/* assert LO data */
name|DataLo_ClockHi
argument_list|(
name|bti2c
argument_list|,
name|LDELAY
argument_list|)
expr_stmt|;
comment|/* strobe clock */
name|DataLo_ClockLo
argument_list|(
name|bti2c
argument_list|,
name|LDELAY
argument_list|)
expr_stmt|;
comment|/* remove clock */
name|DataHi_ClockLo
argument_list|(
name|bti2c
argument_list|,
name|NDELAY
argument_list|)
expr_stmt|;
comment|/* float data */
block|}
end_function

begin_comment
comment|/*  * get an 'ACK' from the slave  */
end_comment

begin_function
specifier|static
name|int
name|i2cAck
parameter_list|(
name|i2c_regptr_t
name|bti2c
parameter_list|)
block|{
name|int
name|acknowledge
decl_stmt|;
name|DataHi_ClockLo
argument_list|(
name|bti2c
argument_list|,
name|LDELAY
argument_list|)
expr_stmt|;
comment|/* float data */
name|DataHi_ClockHi
argument_list|(
name|bti2c
argument_list|,
name|LDELAY
argument_list|)
expr_stmt|;
comment|/* strobe clock */
name|acknowledge
operator|=
name|DataRead
argument_list|(
name|bti2c
argument_list|)
expr_stmt|;
comment|/* read ACK bit */
name|DataHi_ClockLo
argument_list|(
name|bti2c
argument_list|,
name|LDELAY
argument_list|)
expr_stmt|;
comment|/* release clock */
return|return
name|acknowledge
return|;
block|}
end_function

begin_comment
comment|/*  * read a byte from the I2C bus  */
end_comment

begin_function
specifier|static
name|int
name|i2cRead
parameter_list|(
name|i2c_regptr_t
name|bti2c
parameter_list|,
name|int
name|ack
parameter_list|)
block|{
name|int
name|x
decl_stmt|;
name|int
name|byte
decl_stmt|;
name|DataHi_ClockLo
argument_list|(
name|bti2c
argument_list|,
name|SDELAY
argument_list|)
expr_stmt|;
comment|/* float data */
for|for
control|(
name|byte
operator|=
literal|0
operator|,
name|x
operator|=
literal|7
init|;
name|x
operator|>=
literal|0
condition|;
operator|--
name|x
control|)
block|{
name|DataHi_ClockHi
argument_list|(
name|bti2c
argument_list|,
name|SDELAY
argument_list|)
expr_stmt|;
comment|/* strobe clock */
if|if
condition|(
name|DataRead
argument_list|(
name|bti2c
argument_list|)
condition|)
comment|/* read data */
name|byte
operator||=
operator|(
literal|1
operator|<<
name|x
operator|)
expr_stmt|;
comment|/* bit was Hi */
name|DataHi_ClockLo
argument_list|(
name|bti2c
argument_list|,
name|SDELAY
argument_list|)
expr_stmt|;
comment|/* release clock */
block|}
if|#
directive|if
name|defined
argument_list|(
name|FUNNY_HI
argument_list|)
name|i2cHi
argument_list|(
name|bti2c
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* FUNNY_HI */
if|#
directive|if
name|defined
argument_list|(
name|REALLY_ACK
argument_list|)
if|if
condition|(
name|ack
condition|)
name|i2cGrantAck
argument_list|(
name|bti2c
argument_list|)
expr_stmt|;
comment|/* Grant ACK */
endif|#
directive|endif
comment|/* REALLY_ACK */
return|return
name|byte
return|;
block|}
end_function

begin_comment
comment|/*  * write a byte to the I2C bus  */
end_comment

begin_function
specifier|static
name|int
name|i2cWrite
parameter_list|(
name|i2c_regptr_t
name|bti2c
parameter_list|,
name|u_char
name|byte
parameter_list|)
block|{
name|int
name|x
decl_stmt|;
name|DataLo_ClockLo
argument_list|(
name|bti2c
argument_list|,
name|LDELAY
argument_list|)
expr_stmt|;
comment|/* lower data& clock */
for|for
control|(
name|x
operator|=
literal|7
init|;
name|x
operator|>=
literal|0
condition|;
operator|--
name|x
control|)
operator|(
name|byte
operator|&
operator|(
literal|1
operator|<<
name|x
operator|)
operator|)
condition|?
name|i2cHi
argument_list|(
name|bti2c
argument_list|)
else|:
name|i2cLo
argument_list|(
name|bti2c
argument_list|)
expr_stmt|;
return|return
name|i2cAck
argument_list|(
name|bti2c
argument_list|)
return|;
block|}
end_function

begin_undef
undef|#
directive|undef
name|NDELAY
end_undef

begin_undef
undef|#
directive|undef
name|SDELAY
end_undef

begin_undef
undef|#
directive|undef
name|LDELAY
end_undef

begin_comment
comment|/*************************** end of i2c primitives ***************************/
end_comment

begin_define
define|#
directive|define
name|I2C_REGADDR
parameter_list|()
value|(i2c_regptr_t)&bktr->base[ BKTR_I2C_CONTROL ]
end_define

begin_comment
comment|/* scaling factor for frequencies expressed as ints */
end_comment

begin_define
define|#
directive|define
name|FREQFACTOR
value|16
end_define

begin_comment
comment|/*  * Format:  *	entry 0:         MAX legal channel  *	entry 1:         IF frequency  *			 expressed as fi{mHz} * 16,  *			 eg 45.75mHz == 45.75 * 16 = 732  *	entry 2:         [place holder/future]  *	entry 3:         base of channel record 0  *	entry 3 + (x*3): base of channel record 'x'  *	entry LAST:      NULL channel entry marking end of records  *  * Record:  *	int 0:		base channel  *	int 1:		frequency of base channel,  *			 expressed as fb{mHz} * 16,  *	int 2:		offset frequency between channels,  *			 expressed as fo{mHz} * 16,  */
end_comment

begin_comment
comment|/*  * North American Broadcast Channels:  *  *  2:  55.25 mHz -  4:  67.25 mHz  *  5:  77.25 mHz -  6:	 83.25 mHz  *  7: 175.25 mHz - 13:	211.25 mHz  * 14: 471.25 mHz - 83:	885.25 mHz  *  * IF freq: 45.75 mHz  */
end_comment

begin_decl_stmt
name|int
name|nabcst
index|[]
init|=
block|{
literal|83
block|,
call|(
name|int
call|)
argument_list|(
literal|45.75
operator|*
name|FREQFACTOR
argument_list|)
block|,
literal|0
block|,
literal|14
block|,
call|(
name|int
call|)
argument_list|(
literal|471.25
operator|*
name|FREQFACTOR
argument_list|)
block|,
call|(
name|int
call|)
argument_list|(
literal|6.00
operator|*
name|FREQFACTOR
argument_list|)
block|,
literal|7
block|,
call|(
name|int
call|)
argument_list|(
literal|175.25
operator|*
name|FREQFACTOR
argument_list|)
block|,
call|(
name|int
call|)
argument_list|(
literal|6.00
operator|*
name|FREQFACTOR
argument_list|)
block|,
literal|5
block|,
call|(
name|int
call|)
argument_list|(
literal|77.25
operator|*
name|FREQFACTOR
argument_list|)
block|,
call|(
name|int
call|)
argument_list|(
literal|6.00
operator|*
name|FREQFACTOR
argument_list|)
block|,
literal|2
block|,
call|(
name|int
call|)
argument_list|(
literal|55.25
operator|*
name|FREQFACTOR
argument_list|)
block|,
call|(
name|int
call|)
argument_list|(
literal|6.00
operator|*
name|FREQFACTOR
argument_list|)
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * North American Cable Channels, IRC:  *  *  2:  55.25 mHz -  4:  67.25 mHz  *  5:  77.25 mHz -  6:  83.25 mHz  *  7: 175.25 mHz - 13: 211.25 mHz  * 14: 121.25 mHz - 22: 169.25 mHz  * 23: 217.25 mHz - 94: 643.25 mHz  * 95:  91.25 mHz - 99: 115.25 mHz  *  * IF freq: 45.75 mHz  */
end_comment

begin_decl_stmt
name|int
name|irccable
index|[]
init|=
block|{
literal|99
block|,
call|(
name|int
call|)
argument_list|(
literal|45.75
operator|*
name|FREQFACTOR
argument_list|)
block|,
literal|0
block|,
literal|95
block|,
call|(
name|int
call|)
argument_list|(
literal|91.25
operator|*
name|FREQFACTOR
argument_list|)
block|,
call|(
name|int
call|)
argument_list|(
literal|6.00
operator|*
name|FREQFACTOR
argument_list|)
block|,
literal|23
block|,
call|(
name|int
call|)
argument_list|(
literal|217.25
operator|*
name|FREQFACTOR
argument_list|)
block|,
call|(
name|int
call|)
argument_list|(
literal|6.00
operator|*
name|FREQFACTOR
argument_list|)
block|,
literal|14
block|,
call|(
name|int
call|)
argument_list|(
literal|121.25
operator|*
name|FREQFACTOR
argument_list|)
block|,
call|(
name|int
call|)
argument_list|(
literal|6.00
operator|*
name|FREQFACTOR
argument_list|)
block|,
literal|7
block|,
call|(
name|int
call|)
argument_list|(
literal|175.25
operator|*
name|FREQFACTOR
argument_list|)
block|,
call|(
name|int
call|)
argument_list|(
literal|6.00
operator|*
name|FREQFACTOR
argument_list|)
block|,
literal|5
block|,
call|(
name|int
call|)
argument_list|(
literal|77.25
operator|*
name|FREQFACTOR
argument_list|)
block|,
call|(
name|int
call|)
argument_list|(
literal|6.00
operator|*
name|FREQFACTOR
argument_list|)
block|,
literal|2
block|,
call|(
name|int
call|)
argument_list|(
literal|55.25
operator|*
name|FREQFACTOR
argument_list|)
block|,
call|(
name|int
call|)
argument_list|(
literal|6.00
operator|*
name|FREQFACTOR
argument_list|)
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * North American Cable Channels, HRC:  *  */
end_comment

begin_decl_stmt
name|int
name|hrccable
index|[]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Western European channels:  *  */
end_comment

begin_decl_stmt
name|int
name|weurope
index|[]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|freqTable
index|[]
init|=
block|{
name|NULL
block|,
name|nabcst
block|,
name|irccable
block|,
name|hrccable
block|,
name|weurope
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|TBL_CHNL
value|freqTable[ bktr->tuner.tunertype ][ x ]
end_define

begin_define
define|#
directive|define
name|TBL_BASE_FREQ
value|freqTable[ bktr->tuner.tunertype ][ x + 1 ]
end_define

begin_define
define|#
directive|define
name|TBL_OFFSET
value|freqTable[ bktr->tuner.tunertype ][ x + 2 ]
end_define

begin_function
specifier|static
name|int
name|frequency_lookup
parameter_list|(
name|bktr_reg_t
modifier|*
name|bktr
parameter_list|,
name|int
name|channel
parameter_list|)
block|{
name|int
name|x
decl_stmt|;
comment|/* check for "> MAX channel" */
name|x
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|channel
operator|>
name|TBL_CHNL
condition|)
return|return
operator|-
literal|1
return|;
comment|/* search the table for data */
for|for
control|(
name|x
operator|=
literal|3
init|;
name|TBL_CHNL
condition|;
name|x
operator|+=
literal|3
control|)
block|{
if|if
condition|(
name|channel
operator|>=
name|TBL_CHNL
condition|)
block|{
return|return
operator|(
name|TBL_BASE_FREQ
operator|+
operator|(
operator|(
name|channel
operator|-
name|TBL_CHNL
operator|)
operator|*
name|TBL_OFFSET
operator|)
operator|)
return|;
block|}
block|}
comment|/* not found, must be below the MIN channel */
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_undef
undef|#
directive|undef
name|TBL_OFFSET
end_undef

begin_undef
undef|#
directive|undef
name|TBL_BASE_FREQ
end_undef

begin_undef
undef|#
directive|undef
name|TBL_CHNL
end_undef

begin_define
define|#
directive|define
name|TBL_IF
value|freqTable[ bktr->tuner.tunertype ][ 1 ]
end_define

begin_comment
comment|/*  * set the frequency of the tuner  */
end_comment

begin_function
specifier|static
name|int
name|tv_freq
parameter_list|(
name|bktr_reg_t
modifier|*
name|bktr
parameter_list|,
name|int
name|frequency
parameter_list|)
block|{
name|i2c_regptr_t
name|bti2c
decl_stmt|;
name|u_char
name|band
decl_stmt|;
name|int
name|N
decl_stmt|;
name|int
name|order
decl_stmt|;
comment|/* select the band based on frequency */
if|if
condition|(
name|frequency
operator|<
operator|(
literal|160
operator|*
name|FREQFACTOR
operator|)
condition|)
name|band
operator|=
name|TSA5522_BANDA
expr_stmt|;
elseif|else
if|if
condition|(
name|frequency
operator|<
operator|(
literal|454
operator|*
name|FREQFACTOR
operator|)
condition|)
name|band
operator|=
name|TSA5522_BANDB
expr_stmt|;
else|else
name|band
operator|=
name|TSA5522_BANDC
expr_stmt|;
comment|/* 	 * N = 16 * { fRF(pc) + fIF(pc) } 	 * where: 	 *  pc is picture carrier, fRF& fIF are in mHz 	 * 	 * frequency is mHz * 16, eg. 55.25 mHz * 16 == 884 	 */
name|N
operator|=
name|frequency
operator|+
name|TBL_IF
expr_stmt|;
comment|/* get the i2c register address */
name|bti2c
operator|=
name|I2C_REGADDR
argument_list|()
expr_stmt|;
comment|/* send the data to the TSA5522 */
name|i2cStart
argument_list|(
name|bti2c
argument_list|,
name|TSA5522_WADDR
argument_list|)
expr_stmt|;
comment|/* the data sheet wants the order set according to direction */
if|if
condition|(
name|frequency
operator|>
name|bktr
operator|->
name|tuner
operator|.
name|frequency
condition|)
block|{
name|i2cWrite
argument_list|(
name|bti2c
argument_list|,
operator|(
name|N
operator|>>
literal|8
operator|)
operator|&
literal|0x7f
argument_list|)
expr_stmt|;
comment|/* divisor MSB */
name|i2cWrite
argument_list|(
name|bti2c
argument_list|,
name|N
operator|&
literal|0xff
argument_list|)
expr_stmt|;
comment|/* divisor LSB */
name|i2cWrite
argument_list|(
name|bti2c
argument_list|,
name|TSA5522_CONTROL
argument_list|)
expr_stmt|;
comment|/* control bits */
name|i2cWrite
argument_list|(
name|bti2c
argument_list|,
name|band
argument_list|)
expr_stmt|;
comment|/* band select */
block|}
else|else
block|{
name|i2cWrite
argument_list|(
name|bti2c
argument_list|,
name|TSA5522_CONTROL
argument_list|)
expr_stmt|;
comment|/* control bits */
name|i2cWrite
argument_list|(
name|bti2c
argument_list|,
name|band
argument_list|)
expr_stmt|;
comment|/* band select */
name|i2cWrite
argument_list|(
name|bti2c
argument_list|,
operator|(
name|N
operator|>>
literal|8
operator|)
operator|&
literal|0x7f
argument_list|)
expr_stmt|;
comment|/* divisor MSB */
name|i2cWrite
argument_list|(
name|bti2c
argument_list|,
name|N
operator|&
literal|0xff
argument_list|)
expr_stmt|;
comment|/* divisor LSB */
block|}
name|i2cStop
argument_list|(
name|bti2c
argument_list|)
expr_stmt|;
name|bktr
operator|->
name|tuner
operator|.
name|frequency
operator|=
name|frequency
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_undef
undef|#
directive|undef
name|TBL_IF
end_undef

begin_comment
comment|/*  * set the channel of the tuner  */
end_comment

begin_function
specifier|static
name|int
name|tv_channel
parameter_list|(
name|bktr_reg_t
modifier|*
name|bktr
parameter_list|,
name|int
name|channel
parameter_list|)
block|{
name|int
name|frequency
decl_stmt|;
comment|/* calculate the frequency according to tuner type */
if|if
condition|(
operator|(
name|frequency
operator|=
name|frequency_lookup
argument_list|(
name|bktr
argument_list|,
name|channel
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
comment|/* set the new frequency */
if|if
condition|(
name|tv_freq
argument_list|(
name|bktr
argument_list|,
name|frequency
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
comment|/* OK to update records */
name|bktr
operator|->
name|tuner
operator|.
name|channel
operator|=
name|channel
expr_stmt|;
return|return
name|channel
return|;
block|}
end_function

begin_comment
comment|/*  * get the status of the tuner  */
end_comment

begin_function
specifier|static
name|int
name|tuner_status
parameter_list|(
name|bktr_reg_t
modifier|*
name|bktr
parameter_list|)
block|{
name|i2c_regptr_t
name|bti2c
decl_stmt|;
name|int
name|status
decl_stmt|;
comment|/* get the i2c register address */
name|bti2c
operator|=
name|I2C_REGADDR
argument_list|()
expr_stmt|;
comment|/* send the request to the TSA5522 */
name|i2cStart
argument_list|(
name|bti2c
argument_list|,
name|TSA5522_RADDR
argument_list|)
expr_stmt|;
name|status
operator|=
name|i2cRead
argument_list|(
name|bti2c
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* no ACK */
name|i2cStop
argument_list|(
name|bti2c
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/*  *   */
end_comment

begin_expr_stmt
specifier|static
name|bktr_devsw_installed
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|void
name|bktr_drvinit
parameter_list|(
name|void
modifier|*
name|unused
parameter_list|)
block|{
name|dev_t
name|dev
decl_stmt|;
if|if
condition|(
operator|!
name|bktr_devsw_installed
condition|)
block|{
name|dev
operator|=
name|makedev
argument_list|(
name|CDEV_MAJOR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cdevsw_add
argument_list|(
operator|&
name|dev
argument_list|,
operator|&
name|bktr_cdevsw
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|bktr_devsw_installed
operator|=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_macro
name|SYSINIT
argument_list|(
argument|bktrdev
argument_list|,
argument|SI_SUB_DRIVERS
argument_list|,
argument|SI_ORDER_MIDDLE+CDEV_MAJOR
argument_list|,
argument|bktr_drvinit
argument_list|,
argument|NULL
argument_list|)
end_macro

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NBKTR> 0 */
end_comment

end_unit

