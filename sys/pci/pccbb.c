begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1998 and 1999 HAYAKAWA Koichi.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by HAYAKAWA Koichi.  * 4. The name of the author may not be used to endorse or promote products  *    derived from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_comment
comment|/* $Id: pccbb.c,v 1.12 1999/09/07 17:38:17 gehenna Exp $ */
end_comment

begin_comment
comment|/* FreeBSD/newconfig version UCHIYAMA Yasushi 1999 */
end_comment

begin_comment
comment|/* $FreeBSD$ */
end_comment

begin_define
define|#
directive|define
name|CBB_DEBUG
end_define

begin_undef
undef|#
directive|undef
name|SHOW_REGS
end_undef

begin_undef
undef|#
directive|undef
name|PCCBB_PCMCIA_POLL
end_undef

begin_define
define|#
directive|define
name|CB_PCMCIA_POLL
end_define

begin_define
define|#
directive|define
name|CB_PCMCIA_POLL_ONLY
end_define

begin_define
define|#
directive|define
name|LEVEL2
end_define

begin_undef
undef|#
directive|undef
name|CB_PCMCIA_POLL
end_undef

begin_undef
undef|#
directive|undef
name|CB_PCMCIA_POLL_ONLY
end_undef

begin_undef
undef|#
directive|undef
name|LEVEL2
end_undef

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<sys/syslog.h>
end_include

begin_include
include|#
directive|include
file|<sys/device.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/kthread.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<machine/intr.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcireg.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcivar.h>
end_include

begin_define
define|#
directive|define
name|delay
parameter_list|(
name|arg
parameter_list|)
value|DELAY(arg)
end_define

begin_include
include|#
directive|include
file|<machine/clock.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcidevs.h>
end_include

begin_include
include|#
directive|include
file|<dev/cardbus/cardbusreg.h>
end_include

begin_include
include|#
directive|include
file|<dev/cardbus/cardbusvar.h>
end_include

begin_include
include|#
directive|include
file|<dev/pcmcia/pcmciareg.h>
end_include

begin_include
include|#
directive|include
file|<dev/pcmcia/pcmciavar.h>
end_include

begin_include
include|#
directive|include
file|<dev/ic/i82365reg.h>
end_include

begin_include
include|#
directive|include
file|<dev/ic/i82365reg.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pccbbreg.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pccbbvar.h>
end_include

begin_define
define|#
directive|define
name|PCIC_FLAG_SOCKETP
value|0x0001
end_define

begin_define
define|#
directive|define
name|PCIC_FLAG_CARDP
value|0x0002
end_define

begin_comment
comment|/* Chipset ID */
end_comment

begin_define
define|#
directive|define
name|CB_UNKNOWN
value|0
end_define

begin_comment
comment|/* NOT Cardbus-PCI bridge */
end_comment

begin_define
define|#
directive|define
name|CB_TI113X
value|1
end_define

begin_comment
comment|/* TI PCI1130/1131 */
end_comment

begin_define
define|#
directive|define
name|CB_TI12XX
value|2
end_define

begin_comment
comment|/* TI PCI1250/1220 */
end_comment

begin_define
define|#
directive|define
name|CB_RF5C47X
value|3
end_define

begin_comment
comment|/* RICOH RF5C475/476/477 */
end_comment

begin_define
define|#
directive|define
name|CB_RF5C46X
value|4
end_define

begin_comment
comment|/* RICOH RF5C465/466/467 */
end_comment

begin_define
define|#
directive|define
name|CB_TOPIC95
value|5
end_define

begin_comment
comment|/* Toshiba ToPIC95 */
end_comment

begin_define
define|#
directive|define
name|CB_TOPIC95B
value|6
end_define

begin_comment
comment|/* Toshiba ToPIC95B */
end_comment

begin_define
define|#
directive|define
name|CB_TOPIC97
value|7
end_define

begin_comment
comment|/* Toshiba ToPIC97 */
end_comment

begin_define
define|#
directive|define
name|CB_CHIPS_LAST
value|8
end_define

begin_comment
comment|/* Sentinel */
end_comment

begin_if
if|#
directive|if
name|defined
name|CBB_DEBUG
end_if

begin_define
define|#
directive|define
name|DPRINTF
parameter_list|(
name|x
parameter_list|)
value|printf x
end_define

begin_define
define|#
directive|define
name|STATIC
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|DPRINTF
parameter_list|(
name|x
parameter_list|)
end_define

begin_define
define|#
directive|define
name|STATIC
value|static
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|pccbb_event_thread
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|pccbb_softc
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
name|bus_space_tag_t
name|memt
init|=
name|sc
operator|->
name|sc_base_memt
decl_stmt|;
name|bus_space_handle_t
name|memh
init|=
name|sc
operator|->
name|sc_base_memh
decl_stmt|;
name|u_int32_t
name|sockstate
decl_stmt|;
name|int
name|s
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|s
operator|=
name|splhigh
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|sc
operator|->
name|sc_queued
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|tsleep
argument_list|(
operator|&
name|sc
operator|->
name|events
argument_list|,
name|PWAIT
argument_list|,
literal|"pccbbev"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sockstate
operator|=
name|bus_space_read_4
argument_list|(
name|memt
argument_list|,
name|memh
argument_list|,
name|CB_SOCKET_STAT
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
name|CBB_CARDEXIST
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"%s: card removed\n"
operator|,
name|sc
operator|->
name|sc_dev
operator|.
name|dv_xname
operator|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_flags
operator|&=
operator|~
name|CBB_CARDEXIST
expr_stmt|;
if|if
condition|(
name|sockstate
operator|&
name|CB_SOCKET_STAT_16BIT
condition|)
block|{
name|struct
name|cbb_pcic_handle
modifier|*
name|ph
init|=
operator|&
name|sc
operator|->
name|sc_pcmcia_h
decl_stmt|;
name|struct
name|pcmcia_softc
modifier|*
name|psc
init|=
operator|(
name|void
operator|*
operator|)
name|ph
operator|->
name|pcmcia
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|ph
operator|->
name|flags
operator|&
name|PCIC_FLAG_CARDP
operator|)
condition|)
block|{
name|panic
argument_list|(
literal|"pccbbintr: already detached"
argument_list|)
expr_stmt|;
block|}
name|psc
operator|->
name|sc_if
operator|.
name|if_card_deactivate
argument_list|(
name|ph
operator|->
name|pcmcia
argument_list|)
expr_stmt|;
name|pccbb_pcmcia_socket_disable
argument_list|(
name|ph
argument_list|)
expr_stmt|;
name|pccbb_pcmcia_detach_card
argument_list|(
name|ph
argument_list|,
name|DETACH_FORCE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|sc
operator|->
name|sc_cbdev
condition|)
name|config_detach
argument_list|(
name|sc
operator|->
name|sc_cbdev
argument_list|,
name|DETACH_FORCE
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"no corresponding device instance.\n"
argument_list|)
expr_stmt|;
comment|/* XXX should panic */
block|}
block|}
else|else
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"%s: card inserted\n"
operator|,
name|sc
operator|->
name|sc_dev
operator|.
name|dv_xname
operator|)
argument_list|)
expr_stmt|;
name|pccbb_insert
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|sc_queued
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_flags
operator|&=
operator|~
name|CBB_CARDSTATUS_BUSY
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
block|}
name|kthread_exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pccbb_create_event_thread
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|pccbb_softc
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
if|if
condition|(
name|kthread_create1
argument_list|(
name|pccbb_event_thread
argument_list|,
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|event_thread
argument_list|,
literal|"%s,%s"
argument_list|,
name|sc
operator|->
name|sc_dev
operator|.
name|dv_xname
argument_list|,
literal|"cardbus"
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"%s: unable to create event thread.\n"
argument_list|,
name|sc
operator|->
name|sc_dev
operator|.
name|dv_xname
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"pccbb_create_event_thread"
argument_list|)
expr_stmt|;
block|}
else|else
name|printf
argument_list|(
literal|"%s: create event thread\n"
argument_list|,
name|sc
operator|->
name|sc_dev
operator|.
name|dv_xname
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pccbb_kthread_init
parameter_list|(
name|struct
name|pccbb_softc
modifier|*
name|sc
parameter_list|)
block|{
name|kthread_create
argument_list|(
name|pccbb_create_event_thread
argument_list|,
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|int
name|pccbbmatch
name|__P
argument_list|(
operator|(
expr|struct
name|device
operator|*
operator|,
expr|struct
name|cfdata
operator|*
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|pccbbattach
name|__P
argument_list|(
operator|(
expr|struct
name|device
operator|*
operator|,
expr|struct
name|device
operator|*
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|pccbbintr
name|__P
argument_list|(
operator|(
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|pccbb_insert
name|__P
argument_list|(
operator|(
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|pccbb_detect_card
name|__P
argument_list|(
operator|(
expr|struct
name|pccbb_softc
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|pccbb_pcmcia_write
name|__P
argument_list|(
operator|(
expr|struct
name|cbb_pcic_handle
operator|*
operator|,
name|int
operator|,
name|u_int8_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_int8_t
name|pccbb_pcmcia_read
name|__P
argument_list|(
operator|(
expr|struct
name|cbb_pcic_handle
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|Pcic_read
parameter_list|(
name|ph
parameter_list|,
name|reg
parameter_list|)
value|((ph)->ph_read((ph), (reg)))
end_define

begin_define
define|#
directive|define
name|Pcic_write
parameter_list|(
name|ph
parameter_list|,
name|reg
parameter_list|,
name|val
parameter_list|)
value|((ph)->ph_write((ph), (reg), (val)))
end_define

begin_decl_stmt
name|STATIC
name|int
name|cb_reset
name|__P
argument_list|(
operator|(
expr|struct
name|pccbb_softc
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|int
name|cb_detect_voltage
name|__P
argument_list|(
operator|(
expr|struct
name|pccbb_softc
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|int
name|cbbprint
name|__P
argument_list|(
operator|(
name|void
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|cb_chipset
name|__P
argument_list|(
operator|(
name|u_int32_t
operator|,
name|char
specifier|const
operator|*
operator|*
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|pccbb_chipinit
name|__P
argument_list|(
operator|(
expr|struct
name|pci_attach_args
operator|*
operator|,
expr|struct
name|pccbb_softc
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|void
name|pccbb_pcmcia_attach
name|__P
argument_list|(
operator|(
expr|struct
name|pccbb_softc
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|void
name|pccbb_pcmcia_attach_card
name|__P
argument_list|(
operator|(
expr|struct
name|cbb_pcic_handle
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|void
name|pccbb_pcmcia_detach_card
name|__P
argument_list|(
operator|(
expr|struct
name|cbb_pcic_handle
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|void
name|pccbb_pcmcia_deactivate_card
name|__P
argument_list|(
operator|(
expr|struct
name|cbb_pcic_handle
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|int
name|pccbb_ctrl
name|__P
argument_list|(
operator|(
name|cardbus_chipset_tag_t
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|int
name|pccbb_power
name|__P
argument_list|(
operator|(
name|cardbus_chipset_tag_t
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|int
name|pccbb_cardenable
name|__P
argument_list|(
operator|(
expr|struct
name|pccbb_softc
operator|*
name|sc
operator|,
name|int
name|function
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|pccbb_io_open
name|__P
argument_list|(
operator|(
name|cardbus_chipset_tag_t
operator|,
name|int
operator|,
name|u_int32_t
operator|,
name|u_int32_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|pccbb_io_close
name|__P
argument_list|(
operator|(
name|cardbus_chipset_tag_t
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|pccbb_mem_open
name|__P
argument_list|(
operator|(
name|cardbus_chipset_tag_t
operator|,
name|int
operator|,
name|u_int32_t
operator|,
name|u_int32_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|pccbb_mem_close
name|__P
argument_list|(
operator|(
name|cardbus_chipset_tag_t
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
modifier|*
name|pccbb_intr_establish
name|__P
argument_list|(
operator|(
name|cardbus_chipset_tag_t
operator|,
name|int
name|irq
operator|,
name|int
name|level
operator|,
name|int
argument_list|(
operator|*
name|ih
argument_list|)
argument_list|(
name|void
operator|*
argument_list|)
operator|,
name|void
operator|*
name|sc
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|pccbb_intr_disestablish
name|__P
argument_list|(
operator|(
name|cardbus_chipset_tag_t
name|ct
operator|,
name|void
operator|*
name|ih
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cardbustag_t
name|pccbb_make_tag
name|__P
argument_list|(
operator|(
name|cardbus_chipset_tag_t
operator|,
name|int
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|pccbb_free_tag
name|__P
argument_list|(
operator|(
name|cardbus_chipset_tag_t
operator|,
name|cardbustag_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cardbusreg_t
name|pccbb_conf_read
name|__P
argument_list|(
operator|(
name|cardbus_chipset_tag_t
operator|,
name|cardbustag_t
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|pccbb_conf_write
name|__P
argument_list|(
operator|(
name|cardbus_chipset_tag_t
operator|,
name|cardbustag_t
operator|,
name|int
operator|,
name|cardbusreg_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|int
name|pccbb_pcmcia_mem_alloc
name|__P
argument_list|(
operator|(
name|pcmcia_chipset_handle_t
operator|,
name|bus_size_t
operator|,
expr|struct
name|pcmcia_mem_handle
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|void
name|pccbb_pcmcia_mem_free
name|__P
argument_list|(
operator|(
name|pcmcia_chipset_handle_t
operator|,
expr|struct
name|pcmcia_mem_handle
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|int
name|pccbb_pcmcia_mem_map
name|__P
argument_list|(
operator|(
name|pcmcia_chipset_handle_t
operator|,
name|int
operator|,
name|bus_addr_t
operator|,
name|bus_size_t
operator|,
expr|struct
name|pcmcia_mem_handle
operator|*
operator|,
name|bus_addr_t
operator|*
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|void
name|pccbb_pcmcia_mem_unmap
name|__P
argument_list|(
operator|(
name|pcmcia_chipset_handle_t
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|int
name|pccbb_pcmcia_io_alloc
name|__P
argument_list|(
operator|(
name|pcmcia_chipset_handle_t
operator|,
name|bus_addr_t
operator|,
name|bus_size_t
operator|,
name|bus_size_t
operator|,
expr|struct
name|pcmcia_io_handle
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|void
name|pccbb_pcmcia_io_free
name|__P
argument_list|(
operator|(
name|pcmcia_chipset_handle_t
operator|,
expr|struct
name|pcmcia_io_handle
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|int
name|pccbb_pcmcia_io_map
name|__P
argument_list|(
operator|(
name|pcmcia_chipset_handle_t
operator|,
name|int
operator|,
name|bus_addr_t
operator|,
name|bus_size_t
operator|,
expr|struct
name|pcmcia_io_handle
operator|*
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|void
name|pccbb_pcmcia_io_unmap
name|__P
argument_list|(
operator|(
name|pcmcia_chipset_handle_t
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|void
modifier|*
name|pccbb_pcmcia_intr_establish
name|__P
argument_list|(
operator|(
name|pcmcia_chipset_handle_t
operator|,
expr|struct
name|pcmcia_function
operator|*
operator|,
name|int
operator|,
name|int
argument_list|(
operator|*
argument_list|)
argument_list|(
name|void
operator|*
argument_list|)
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|void
name|pccbb_pcmcia_intr_disestablish
name|__P
argument_list|(
operator|(
name|pcmcia_chipset_handle_t
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|void
name|pccbb_pcmcia_socket_enable
name|__P
argument_list|(
operator|(
name|pcmcia_chipset_handle_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|void
name|pccbb_pcmcia_socket_disable
name|__P
argument_list|(
operator|(
name|pcmcia_chipset_handle_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|pccbb_pcmcia_do_io_map
name|__P
argument_list|(
operator|(
expr|struct
name|cbb_pcic_handle
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|pccbb_pcmcia_wait_ready
name|__P
argument_list|(
operator|(
expr|struct
name|cbb_pcic_handle
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|pccbb_pcmcia_do_mem_map
name|__P
argument_list|(
operator|(
expr|struct
name|cbb_pcic_handle
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|pccbb_pcmcia_print
name|__P
argument_list|(
operator|(
name|void
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|pccbb_pcmcia_submatch
name|__P
argument_list|(
operator|(
expr|struct
name|device
operator|*
operator|,
expr|struct
name|cfdata
operator|*
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|pccbb_cardbus_submatch
name|__P
argument_list|(
operator|(
expr|struct
name|device
operator|*
operator|,
expr|struct
name|cfdata
operator|*
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|defined
name|SHOW_REGS
end_if

begin_decl_stmt
specifier|static
name|void
name|cb_show_regs
name|__P
argument_list|(
operator|(
name|pci_chipset_tag_t
name|pc
operator|,
name|pcitag_t
name|tag
operator|,
name|bus_space_tag_t
name|memt
operator|,
name|bus_space_handle_t
name|memh
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|struct
name|cfattach
name|cbb_pci_ca
init|=
block|{
sizeof|sizeof
argument_list|(
expr|struct
name|pccbb_softc
argument_list|)
block|,
name|pccbbmatch
block|,
name|pccbbattach
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|pcmcia_chip_functions
name|pccbb_pcmcia_funcs
init|=
block|{
name|pccbb_pcmcia_mem_alloc
block|,
name|pccbb_pcmcia_mem_free
block|,
name|pccbb_pcmcia_mem_map
block|,
name|pccbb_pcmcia_mem_unmap
block|,
name|pccbb_pcmcia_io_alloc
block|,
name|pccbb_pcmcia_io_free
block|,
name|pccbb_pcmcia_io_map
block|,
name|pccbb_pcmcia_io_unmap
block|,
name|pccbb_pcmcia_intr_establish
block|,
name|pccbb_pcmcia_intr_disestablish
block|,
name|pccbb_pcmcia_socket_enable
block|,
name|pccbb_pcmcia_socket_disable
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|cardbus_functions
name|pccbb_funcs
init|=
block|{
name|pccbb_ctrl
block|,
name|pccbb_power
block|,
name|pccbb_mem_open
block|,
name|pccbb_mem_close
block|,
name|pccbb_io_open
block|,
name|pccbb_io_close
block|,
name|pccbb_intr_establish
block|,
name|pccbb_intr_disestablish
block|,
name|pccbb_make_tag
block|,
name|pccbb_free_tag
block|,
name|pccbb_conf_read
block|,
name|pccbb_conf_write
block|, }
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|pccbbmatch
parameter_list|(
name|parent
parameter_list|,
name|match
parameter_list|,
name|aux
parameter_list|)
name|struct
name|device
modifier|*
name|parent
decl_stmt|;
name|struct
name|cfdata
modifier|*
name|match
decl_stmt|;
name|void
modifier|*
name|aux
decl_stmt|;
block|{
name|struct
name|pci_attach_args
modifier|*
name|pa
init|=
operator|(
expr|struct
name|pci_attach_args
operator|*
operator|)
name|aux
decl_stmt|;
if|if
condition|(
operator|(
name|pa
operator|->
name|pa_class
operator|&
name|PCI_CLASS_INTERFACE_MASK
operator|)
operator|==
name|PCI_CLASS_INTERFACE_YENTA
condition|)
block|{
comment|/* OK, It must be YENTA PCI-CardBus bridge */
return|return
literal|2
return|;
comment|/* beat chipset_match */
block|}
return|return
literal|0
return|;
block|}
end_function

begin_define
define|#
directive|define
name|MAKEID
parameter_list|(
name|vendor
parameter_list|,
name|prod
parameter_list|)
value|(((vendor)<< PCI_VENDOR_SHIFT) \                               | ((prod)<< PCI_PRODUCT_SHIFT))
end_define

begin_struct
struct|struct
name|yenta_chipinfo
block|{
name|pcireg_t
name|yc_id
decl_stmt|;
comment|/* vendor tag | product tag */
specifier|const
name|char
modifier|*
name|yc_name
decl_stmt|;
name|int
name|yc_chiptype
decl_stmt|;
name|int
name|yc_flags
decl_stmt|;
block|}
name|yc_chipsets
index|[]
init|=
block|{
comment|/* Texas Instruments chips */
block|{
name|MAKEID
argument_list|(
name|PCI_VENDOR_TI
argument_list|,
name|PCI_PRODUCT_TI_PCI1130
argument_list|)
block|,
literal|"TI1130"
block|,
name|CB_TI113X
block|,
name|PCCBB_PCMCIA_IO_RELOC
operator||
name|PCCBB_PCMCIA_MEM_32
block|}
block|,
block|{
name|MAKEID
argument_list|(
name|PCI_VENDOR_TI
argument_list|,
name|PCI_PRODUCT_TI_PCI1131
argument_list|)
block|,
literal|"TI1131"
block|,
name|CB_TI113X
block|,
name|PCCBB_PCMCIA_IO_RELOC
operator||
name|PCCBB_PCMCIA_MEM_32
block|}
block|,
block|{
name|MAKEID
argument_list|(
name|PCI_VENDOR_TI
argument_list|,
name|PCI_PRODUCT_TI_PCI1250
argument_list|)
block|,
literal|"TI1250"
block|,
name|CB_TI12XX
block|,
name|PCCBB_PCMCIA_IO_RELOC
operator||
name|PCCBB_PCMCIA_MEM_32
block|}
block|,
block|{
name|MAKEID
argument_list|(
name|PCI_VENDOR_TI
argument_list|,
name|PCI_PRODUCT_TI_PCI1220
argument_list|)
block|,
literal|"TI1220"
block|,
name|CB_TI12XX
block|,
name|PCCBB_PCMCIA_IO_RELOC
operator||
name|PCCBB_PCMCIA_MEM_32
block|}
block|,
block|{
name|MAKEID
argument_list|(
name|PCI_VENDOR_TI
argument_list|,
name|PCI_PRODUCT_TI_PCI1221
argument_list|)
block|,
literal|"TI1221"
block|,
name|CB_TI12XX
block|,
name|PCCBB_PCMCIA_IO_RELOC
operator||
name|PCCBB_PCMCIA_MEM_32
block|}
block|,
block|{
name|MAKEID
argument_list|(
name|PCI_VENDOR_TI
argument_list|,
name|PCI_PRODUCT_TI_PCI1225
argument_list|)
block|,
literal|"TI1225"
block|,
name|CB_TI12XX
block|,
name|PCCBB_PCMCIA_IO_RELOC
operator||
name|PCCBB_PCMCIA_MEM_32
block|}
block|,
block|{
name|MAKEID
argument_list|(
name|PCI_VENDOR_TI
argument_list|,
name|PCI_PRODUCT_TI_PCI2030
argument_list|)
block|,
literal|"TI2030"
block|,
name|CB_UNKNOWN
block|,
name|PCCBB_PCMCIA_IO_RELOC
operator||
name|PCCBB_PCMCIA_MEM_32
block|}
block|,
comment|/* Ricoh chips */
block|{
name|MAKEID
argument_list|(
name|PCI_VENDOR_RICOH
argument_list|,
name|PCI_PRODUCT_RICOH_RF5C475
argument_list|)
block|,
literal|"RF5C475"
block|,
name|CB_RF5C47X
block|,
name|PCCBB_PCMCIA_MEM_32
block|}
block|,
block|{
name|MAKEID
argument_list|(
name|PCI_VENDOR_RICOH
argument_list|,
name|PCI_PRODUCT_RICOH_RF5C476
argument_list|)
block|,
literal|"RF5C476"
block|,
name|CB_RF5C47X
block|,
name|PCCBB_PCMCIA_MEM_32
block|}
block|,
block|{
name|MAKEID
argument_list|(
name|PCI_VENDOR_RICOH
argument_list|,
name|PCI_PRODUCT_RICOH_RF5C477
argument_list|)
block|,
literal|"RF5C477"
block|,
name|CB_RF5C47X
block|,
name|PCCBB_PCMCIA_MEM_32
block|}
block|,
block|{
name|MAKEID
argument_list|(
name|PCI_VENDOR_RICOH
argument_list|,
name|PCI_PRODUCT_RICOH_RF5C477
argument_list|)
block|,
literal|"RF5C478"
block|,
name|CB_RF5C47X
block|,
name|PCCBB_PCMCIA_MEM_32
block|}
block|,
block|{
name|MAKEID
argument_list|(
name|PCI_VENDOR_RICOH
argument_list|,
name|PCI_PRODUCT_RICOH_RF5C465
argument_list|)
block|,
literal|"RF5C465"
block|,
name|CB_RF5C46X
block|,
name|PCCBB_PCMCIA_MEM_32
block|}
block|,
block|{
name|MAKEID
argument_list|(
name|PCI_VENDOR_RICOH
argument_list|,
name|PCI_PRODUCT_RICOH_RF5C466
argument_list|)
block|,
literal|"RF5C466"
block|,
name|CB_RF5C46X
block|,
name|PCCBB_PCMCIA_MEM_32
block|}
block|,
comment|/* Toshiba products */
block|{
name|MAKEID
argument_list|(
name|PCI_VENDOR_TOSHIBA2
argument_list|,
name|PCI_PRODUCT_TOSHIBA2_ToPIC95
argument_list|)
block|,
literal|"ToPIC95"
block|,
name|CB_TOPIC95
block|,
name|PCCBB_PCMCIA_MEM_32
block|}
block|,
block|{
name|MAKEID
argument_list|(
name|PCI_VENDOR_TOSHIBA2
argument_list|,
name|PCI_PRODUCT_TOSHIBA2_ToPIC95B
argument_list|)
block|,
literal|"ToPIC95B"
block|,
name|CB_TOPIC95B
block|,
name|PCCBB_PCMCIA_MEM_32
block|}
block|,
block|{
name|MAKEID
argument_list|(
name|PCI_VENDOR_TOSHIBA2
argument_list|,
name|PCI_PRODUCT_TOSHIBA2_ToPIC95B
argument_list|)
block|,
literal|"ToPIC97"
block|,
name|CB_TOPIC97
block|,
name|PCCBB_PCMCIA_MEM_32
block|}
block|,
comment|/* sentinel */
block|{
literal|0
comment|/* null id */
block|,
literal|"unknown"
block|,
name|CB_UNKNOWN
block|,
literal|0
block|}
block|, }
struct|;
end_struct

begin_function
specifier|static
name|int
name|cb_chipset
parameter_list|(
name|pci_id
parameter_list|,
name|namep
parameter_list|,
name|flagp
parameter_list|)
name|u_int32_t
name|pci_id
decl_stmt|;
name|char
specifier|const
modifier|*
modifier|*
name|namep
decl_stmt|;
name|int
modifier|*
name|flagp
decl_stmt|;
block|{
name|int
name|loopend
init|=
sizeof|sizeof
argument_list|(
name|yc_chipsets
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|yc_chipsets
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
name|struct
name|yenta_chipinfo
modifier|*
name|ycp
decl_stmt|,
modifier|*
name|ycend
decl_stmt|;
name|ycend
operator|=
name|yc_chipsets
operator|+
name|loopend
expr_stmt|;
for|for
control|(
name|ycp
operator|=
name|yc_chipsets
init|;
name|ycp
operator|<
name|ycend
operator|&&
name|pci_id
operator|!=
name|ycp
operator|->
name|yc_id
condition|;
operator|++
name|ycp
control|)
empty_stmt|;
if|if
condition|(
name|ycp
operator|==
name|ycend
condition|)
block|{
comment|/* not found */
name|ycp
operator|=
name|yc_chipsets
operator|+
name|loopend
operator|-
literal|1
expr_stmt|;
comment|/* to point the sentinel */
block|}
if|if
condition|(
name|namep
operator|!=
name|NULL
condition|)
block|{
operator|*
name|namep
operator|=
name|ycp
operator|->
name|yc_name
expr_stmt|;
block|}
if|if
condition|(
name|flagp
operator|!=
name|NULL
condition|)
block|{
operator|*
name|flagp
operator|=
name|ycp
operator|->
name|yc_flags
expr_stmt|;
block|}
return|return
name|ycp
operator|->
name|yc_chiptype
return|;
block|}
end_function

begin_function
name|void
name|pccbbattach
parameter_list|(
name|parent
parameter_list|,
name|self
parameter_list|,
name|aux
parameter_list|)
name|struct
name|device
modifier|*
name|parent
decl_stmt|;
name|struct
name|device
modifier|*
name|self
decl_stmt|;
name|void
modifier|*
name|aux
decl_stmt|;
block|{
name|struct
name|pccbb_softc
modifier|*
name|sc
init|=
operator|(
name|void
operator|*
operator|)
name|self
decl_stmt|;
name|struct
name|pci_attach_args
modifier|*
name|pa
init|=
name|aux
decl_stmt|;
name|pci_chipset_tag_t
name|pc
init|=
name|pa
operator|->
name|pa_pc
decl_stmt|;
name|pcireg_t
name|sock_base
decl_stmt|,
name|cbctrl
decl_stmt|;
name|bus_addr_t
name|sockbase
decl_stmt|;
name|bus_space_tag_t
name|base_memt
decl_stmt|;
name|bus_space_handle_t
name|base_memh
decl_stmt|;
name|u_int32_t
name|maskreg
decl_stmt|;
name|pci_intr_handle_t
name|ih
decl_stmt|;
specifier|const
name|char
modifier|*
name|intrstr
init|=
name|NULL
decl_stmt|;
name|char
specifier|const
modifier|*
name|name
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|sc
operator|->
name|sc_chipset
operator|=
name|cb_chipset
argument_list|(
name|pa
operator|->
name|pa_id
argument_list|,
operator|&
name|name
argument_list|,
operator|&
name|flags
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" (%s), flags %d\n"
argument_list|,
name|name
argument_list|,
name|flags
argument_list|)
expr_stmt|;
comment|/* pccbb_machdep.c start */
if|#
directive|if
literal|0
block|pcbb_attach_machdef(pa, sc);
endif|#
directive|endif
comment|/* MAP socket registers and ExCA registers on memory-space        When no valid address is set on socket base registers (on pci        config space), get it not polite way */
name|sock_base
operator|=
name|pci_conf_read
argument_list|(
name|pc
argument_list|,
name|pa
operator|->
name|pa_tag
argument_list|,
name|PCI_SOCKBASE
argument_list|)
expr_stmt|;
if|if
condition|(
name|PCI_MAPREG_MEM_ADDR
argument_list|(
name|sock_base
argument_list|)
operator|<=
literal|0x100000
operator|||
name|PCI_MAPREG_MEM_ADDR
argument_list|(
name|sock_base
argument_list|)
operator|==
literal|0xfffffff0
condition|)
block|{
comment|/* The address may be invalid. */
name|sc
operator|->
name|sc_base_memt
operator|=
name|pa
operator|->
name|pa_memt
expr_stmt|;
if|#
directive|if
operator|!
name|defined
name|CBB_PCI_BASE
define|#
directive|define
name|CBB_PCI_BASE
value|0x20000000
endif|#
directive|endif
if|if
condition|(
name|bus_space_alloc
argument_list|(
name|sc
operator|->
name|sc_base_memt
argument_list|,
name|CBB_PCI_BASE
argument_list|,
literal|0xffffffff
argument_list|,
literal|0x1000
argument_list|,
comment|/* size */
operator|(
name|sc
operator|->
name|sc_chipset
operator|==
name|CB_RF5C47X
operator|||
name|sc
operator|->
name|sc_chipset
operator|==
name|CB_TI113X
operator|)
condition|?
literal|0x10000
else|:
literal|0x1000
argument_list|,
comment|/* alignment */
literal|0
argument_list|,
comment|/* boundary */
literal|0
argument_list|,
comment|/* flags */
operator|&
name|sockbase
argument_list|,
operator|&
name|sc
operator|->
name|sc_base_memh
argument_list|)
condition|)
block|{
comment|/* cannot allocate memory space */
return|return;
block|}
name|pci_conf_write
argument_list|(
name|pc
argument_list|,
name|pa
operator|->
name|pa_tag
argument_list|,
name|PCI_SOCKBASE
argument_list|,
name|sockbase
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"%s: CardBus resister address 0x%x -> 0x%lx\n"
operator|,
name|sc
operator|->
name|sc_dev
operator|.
name|dv_xname
operator|,
name|sock_base
operator|,
name|pci_conf_read
argument_list|(
name|pc
argument_list|,
name|pa
operator|->
name|pa_tag
argument_list|,
name|PCI_SOCKBASE
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* The address must be valid. */
if|if
condition|(
name|pci_mapreg_map
argument_list|(
name|pa
argument_list|,
name|PCI_SOCKBASE
argument_list|,
name|PCI_MAPREG_TYPE_MEM
argument_list|,
literal|0
argument_list|,
operator|&
name|sc
operator|->
name|sc_base_memt
argument_list|,
operator|&
name|sc
operator|->
name|sc_base_memh
argument_list|,
operator|&
name|sockbase
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"%s: can't map socket base address 0x%x\n"
argument_list|,
name|sc
operator|->
name|sc_dev
operator|.
name|dv_xname
argument_list|,
name|sock_base
argument_list|)
expr_stmt|;
comment|/* I think it's funny: socket base registers must be mapped on 	       memory space, but ... */
if|if
condition|(
name|pci_mapreg_map
argument_list|(
name|pa
argument_list|,
name|PCI_SOCKBASE
argument_list|,
name|PCI_MAPREG_TYPE_IO
argument_list|,
literal|0
argument_list|,
operator|&
name|sc
operator|->
name|sc_base_memt
argument_list|,
operator|&
name|sc
operator|->
name|sc_base_memh
argument_list|,
operator|&
name|sockbase
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"%s: can't map socket base address 0x%lx: io mode\n"
argument_list|,
name|sc
operator|->
name|sc_dev
operator|.
name|dv_xname
argument_list|,
operator|(
name|u_long
operator|)
name|sockbase
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
else|else
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"%s: socket base address 0x%lx"
operator|,
name|sc
operator|->
name|sc_dev
operator|.
name|dv_xname
operator|,
operator|(
name|u_long
operator|)
name|sockbase
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
name|sc
operator|->
name|sc_mem_start
operator|=
name|CBB_PCI_BASE
expr_stmt|;
comment|/* XXX */
name|sc
operator|->
name|sc_mem_end
operator|=
literal|0xffffffff
expr_stmt|;
comment|/* XXX */
comment|/* pccbb_machdep.c end */
if|#
directive|if
name|defined
name|CBB_DEBUG
block|{
specifier|static
name|char
modifier|*
name|intrname
index|[
literal|5
index|]
init|=
block|{
literal|"NON"
block|,
literal|"A"
block|,
literal|"B"
block|,
literal|"C"
block|,
literal|"D"
block|}
decl_stmt|;
name|printf
argument_list|(
literal|" intrpin %s, intrtag %d\n"
argument_list|,
name|intrname
index|[
name|pa
operator|->
name|pa_intrpin
index|]
argument_list|,
name|pa
operator|->
name|pa_intrline
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/****** setup softc ******/
name|sc
operator|->
name|sc_pc
operator|=
name|pc
expr_stmt|;
name|sc
operator|->
name|sc_iot
operator|=
name|pa
operator|->
name|pa_iot
expr_stmt|;
name|sc
operator|->
name|sc_memt
operator|=
name|pa
operator|->
name|pa_memt
expr_stmt|;
name|sc
operator|->
name|sc_tag
operator|=
name|pa
operator|->
name|pa_tag
expr_stmt|;
name|sc
operator|->
name|sc_function
operator|=
name|pa
operator|->
name|pa_function
expr_stmt|;
name|sc
operator|->
name|sc_intrline
operator|=
name|pa
operator|->
name|pa_intrline
expr_stmt|;
name|sc
operator|->
name|sc_intrtag
operator|=
name|pa
operator|->
name|pa_intrtag
expr_stmt|;
name|sc
operator|->
name|sc_intrpin
operator|=
name|pa
operator|->
name|pa_intrpin
expr_stmt|;
name|pccbb_chipinit
argument_list|(
name|pa
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|base_memt
operator|=
name|sc
operator|->
name|sc_base_memt
expr_stmt|;
comment|/* socket regs memory tag */
name|base_memh
operator|=
name|sc
operator|->
name|sc_base_memh
expr_stmt|;
comment|/* socket regs memory handle */
comment|/* CSC Interrupt: Card detect interrupt on */
name|maskreg
operator|=
name|bus_space_read_4
argument_list|(
name|base_memt
argument_list|,
name|base_memh
argument_list|,
name|CB_SOCKET_MASK
argument_list|)
expr_stmt|;
name|maskreg
operator||=
name|CB_SOCKET_MASK_CD
expr_stmt|;
comment|/* Card detect intr is turned on. */
name|bus_space_write_4
argument_list|(
name|base_memt
argument_list|,
name|base_memh
argument_list|,
name|CB_SOCKET_MASK
argument_list|,
name|maskreg
argument_list|)
expr_stmt|;
comment|/* reset interrupt */
name|bus_space_write_4
argument_list|(
name|base_memt
argument_list|,
name|base_memh
argument_list|,
name|CB_SOCKET_EVENT
argument_list|,
name|bus_space_read_4
argument_list|(
name|base_memt
argument_list|,
name|base_memh
argument_list|,
name|CB_SOCKET_EVENT
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Map and establish the interrupt. */
if|if
condition|(
name|pci_intr_map
argument_list|(
name|pc
argument_list|,
name|pa
operator|->
name|pa_intrtag
argument_list|,
name|pa
operator|->
name|pa_intrpin
argument_list|,
name|pa
operator|->
name|pa_intrline
argument_list|,
operator|&
name|ih
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"%s: couldn't map interrupt\n"
argument_list|,
name|sc
operator|->
name|sc_dev
operator|.
name|dv_xname
argument_list|)
expr_stmt|;
return|return;
block|}
name|intrstr
operator|=
name|pci_intr_string
argument_list|(
name|pc
argument_list|,
name|ih
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_ih
operator|=
name|pci_intr_establish
argument_list|(
name|pc
argument_list|,
name|ih
argument_list|,
name|IPL_BIO
argument_list|,
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
name|void
operator|*
argument_list|)
operator|)
name|pccbbintr
argument_list|,
name|sc
argument_list|)
expr_stmt|;
comment|/*      * queue creation of a kernel thread to handle insert/removal events.      */
name|pccbb_kthread_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_ih
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"%s: couldn't establish interrupt"
argument_list|,
name|sc
operator|->
name|sc_dev
operator|.
name|dv_xname
argument_list|)
expr_stmt|;
if|if
condition|(
name|intrstr
operator|!=
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|" at %s"
argument_list|,
name|intrstr
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|printf
argument_list|(
literal|"%s: interrupting at %s\n"
argument_list|,
name|sc
operator|->
name|sc_dev
operator|.
name|dv_xname
argument_list|,
name|intrstr
argument_list|)
expr_stmt|;
comment|/* Check card exists or not. if exists, cb_reset will reset card */
block|{
name|u_int32_t
name|sockstat
init|=
name|bus_space_read_4
argument_list|(
name|base_memt
argument_list|,
name|base_memh
argument_list|,
name|CB_SOCKET_STAT
argument_list|)
decl_stmt|;
if|if
condition|(
literal|0
operator|==
operator|(
name|sockstat
operator|&
name|CB_SOCKET_STAT_CD
operator|)
condition|)
block|{
comment|/* card exist */
name|sc
operator|->
name|sc_flags
operator||=
name|CBB_CARDEXIST
expr_stmt|;
block|}
block|}
comment|/****** attach cardbus ******/
block|{
name|struct
name|cbslot_attach_args
name|cba
decl_stmt|;
name|struct
name|cardbus_softc
modifier|*
name|csc
decl_stmt|;
comment|/* child softc */
name|u_int32_t
name|busreg
init|=
name|pci_conf_read
argument_list|(
name|pc
argument_list|,
name|pa
operator|->
name|pa_tag
argument_list|,
name|PCI_BUSNUM
argument_list|)
decl_stmt|;
comment|/* initialise cbslot_attach */
name|cba
operator|.
name|cba_busname
operator|=
literal|"cardbus"
expr_stmt|;
name|cba
operator|.
name|cba_iot
operator|=
name|pa
operator|->
name|pa_iot
expr_stmt|;
name|cba
operator|.
name|cba_memt
operator|=
name|pa
operator|->
name|pa_memt
expr_stmt|;
name|cba
operator|.
name|cba_dmat
operator|=
name|pa
operator|->
name|pa_dmat
expr_stmt|;
if|#
directive|if
literal|1
comment|/* XXX */
name|cba
operator|.
name|cba_function
operator|=
name|pa
operator|->
name|pa_function
expr_stmt|;
else|#
directive|else
name|cba
operator|.
name|cba_function
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|cba
operator|.
name|cba_bus
operator|=
operator|(
name|busreg
operator|>>
literal|8
operator|)
operator|&
literal|0x0ff
expr_stmt|;
name|cba
operator|.
name|cba_cc
operator|=
operator|(
name|void
operator|*
operator|)
name|sc
expr_stmt|;
name|cba
operator|.
name|cba_cf
operator|=
operator|&
name|pccbb_funcs
expr_stmt|;
name|cba
operator|.
name|cba_intrline
operator|=
name|pci_intr_line
argument_list|(
name|pa
argument_list|,
name|ih
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
name|SHOW_REGS
name|cb_show_regs
argument_list|(
name|sc
operator|->
name|sc_pc
argument_list|,
name|sc
operator|->
name|sc_tag
argument_list|,
name|sc
operator|->
name|sc_base_memt
argument_list|,
name|sc
operator|->
name|sc_base_memh
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|NULL
operator|!=
operator|(
name|csc
operator|=
operator|(
name|void
operator|*
operator|)
name|config_found
argument_list|(
name|self
argument_list|,
operator|&
name|cba
argument_list|,
name|cbbprint
argument_list|)
operator|)
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"pccbbattach: found cardbus\n"
operator|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_csc
operator|=
name|csc
expr_stmt|;
block|}
block|}
comment|/****** attach pccard bus ******/
name|pccbb_pcmcia_attach
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|pccbb_chipinit
parameter_list|(
name|pa
parameter_list|,
name|sc
parameter_list|)
name|struct
name|pci_attach_args
modifier|*
name|pa
decl_stmt|;
name|struct
name|pccbb_softc
modifier|*
name|sc
decl_stmt|;
block|{
name|pci_chipset_tag_t
name|pc
init|=
name|pa
operator|->
name|pa_pc
decl_stmt|;
name|bus_space_tag_t
name|base_memt
init|=
name|sc
operator|->
name|sc_base_memt
decl_stmt|;
comment|/* socket regs memory tag */
name|bus_space_handle_t
name|base_memh
init|=
name|sc
operator|->
name|sc_base_memh
decl_stmt|;
comment|/* socket regs memory handle */
name|pcireg_t
name|cbctrl
decl_stmt|;
comment|/*       Set CardBus latency timer     */
block|{
name|pcireg_t
name|pci_lscp
init|=
name|pci_conf_read
argument_list|(
name|pc
argument_list|,
name|pa
operator|->
name|pa_tag
argument_list|,
name|PCI_CB_LSCP_REG
argument_list|)
decl_stmt|;
if|if
condition|(
name|PCI_CB_LATENCY
argument_list|(
name|pci_lscp
argument_list|)
operator|<
literal|0x20
condition|)
block|{
name|pci_lscp
operator|&=
operator|~
operator|(
name|PCI_CB_LATENCY_MASK
operator|<<
name|PCI_CB_LATENCY_SHIFT
operator|)
expr_stmt|;
name|pci_lscp
operator||=
operator|(
literal|0x20
operator|<<
name|PCI_CB_LATENCY_SHIFT
operator|)
expr_stmt|;
name|pci_conf_write
argument_list|(
name|pc
argument_list|,
name|pa
operator|->
name|pa_tag
argument_list|,
name|PCI_CB_LSCP_REG
argument_list|,
name|pci_lscp
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"CardBus latency time 0x%x\n"
argument_list|,
name|PCI_CB_LATENCY
argument_list|(
name|pci_lscp
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/*       Set PCI latency timer     */
block|{
name|pcireg_t
name|pci_bhlc
init|=
name|pci_conf_read
argument_list|(
name|pc
argument_list|,
name|pa
operator|->
name|pa_tag
argument_list|,
name|PCI_BHLC_REG
argument_list|)
decl_stmt|;
if|if
condition|(
name|PCI_LATTIMER
argument_list|(
name|pci_bhlc
argument_list|)
operator|<
literal|0x20
condition|)
block|{
name|pci_bhlc
operator|&=
operator|~
operator|(
name|PCI_LATTIMER_MASK
operator|<<
name|PCI_LATTIMER_SHIFT
operator|)
expr_stmt|;
name|pci_bhlc
operator||=
operator|(
literal|0x20
operator|<<
name|PCI_LATTIMER_SHIFT
operator|)
expr_stmt|;
name|pci_conf_write
argument_list|(
name|pc
argument_list|,
name|pa
operator|->
name|pa_tag
argument_list|,
name|PCI_BHLC_REG
argument_list|,
name|pci_bhlc
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"PCI latency time 0x%x\n"
argument_list|,
name|PCI_LATTIMER
argument_list|(
name|pci_bhlc
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* disable Legacy IO */
switch|switch
condition|(
name|sc
operator|->
name|sc_chipset
condition|)
block|{
case|case
name|CB_RF5C46X
case|:
block|{
name|pcireg_t
name|bcri
init|=
name|pci_conf_read
argument_list|(
name|pc
argument_list|,
name|pa
operator|->
name|pa_tag
argument_list|,
name|PCI_BCR_INTR
argument_list|)
decl_stmt|;
name|bcri
operator|&=
operator|~
operator|(
name|CB_BCRI_RL_3E0_ENA
operator||
name|CB_BCRI_RL_3E2_ENA
operator|)
expr_stmt|;
name|pci_conf_write
argument_list|(
name|pc
argument_list|,
name|pa
operator|->
name|pa_tag
argument_list|,
name|PCI_BCR_INTR
argument_list|,
name|bcri
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
comment|/* XXX: I don't know how to kill Legacy IO properly. */
name|pci_conf_write
argument_list|(
name|pc
argument_list|,
name|pa
operator|->
name|pa_tag
argument_list|,
name|PCI_LEGACY
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/****** Interrupt routing ******/
comment|/* use PCI interrupt */
block|{
name|u_int32_t
name|bcr
init|=
name|pci_conf_read
argument_list|(
name|pc
argument_list|,
name|pa
operator|->
name|pa_tag
argument_list|,
name|PCI_BCR_INTR
argument_list|)
decl_stmt|;
name|bcr
operator|&=
operator|~
name|CB_BCR_INTR_IREQ_ENABLE
expr_stmt|;
comment|/* use PCI Intr */
name|bcr
operator||=
name|CB_BCR_WRITE_POST_ENABLE
expr_stmt|;
comment|/* enable write post */
name|pci_conf_write
argument_list|(
name|pc
argument_list|,
name|pa
operator|->
name|pa_tag
argument_list|,
name|PCI_BCR_INTR
argument_list|,
name|bcr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|CB_TI113X
operator|==
name|sc
operator|->
name|sc_chipset
condition|)
block|{
name|cbctrl
operator|=
name|pci_conf_read
argument_list|(
name|pc
argument_list|,
name|pa
operator|->
name|pa_tag
argument_list|,
name|PCI_CBCTRL
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
operator|==
name|pa
operator|->
name|pa_function
condition|)
block|{
name|cbctrl
operator||=
name|PCI113X_CBCTRL_PCI_IRQ_ENA
expr_stmt|;
block|}
name|cbctrl
operator||=
name|PCI113X_CBCTRL_PCI_IRQ_ENA
expr_stmt|;
comment|/* XXX: bug in PCI113X */
name|cbctrl
operator||=
name|PCI113X_CBCTRL_PCI_CSC
expr_stmt|;
comment|/* CSC intr enable */
name|cbctrl
operator|&=
operator|~
name|PCI113X_CBCTRL_PCI_INTR
expr_stmt|;
comment|/* functional intr prohibit */
name|cbctrl
operator|&=
operator|~
name|PCI113X_CBCTRL_INT_MASK
expr_stmt|;
comment|/* prohibit ISA routing */
name|pci_conf_write
argument_list|(
name|pc
argument_list|,
name|pa
operator|->
name|pa_tag
argument_list|,
name|PCI_CBCTRL
argument_list|,
name|cbctrl
argument_list|)
expr_stmt|;
comment|/* set ExCA regs: PCI113X required to be set bit 4 at Interrupt 	   and General Register, which is IRQ Enable Register, and clear 	   bit 3:0 to zero in order to route CSC interrupt to PCI 	   interrupt pin. */
name|bus_space_write_1
argument_list|(
name|base_memt
argument_list|,
name|base_memh
argument_list|,
literal|0x0803
argument_list|,
literal|0x10
argument_list|)
expr_stmt|;
comment|/* set ExCA regs: prohibit all pcmcia-style CSC intr. */
name|bus_space_write_1
argument_list|(
name|base_memt
argument_list|,
name|base_memh
argument_list|,
literal|0x0805
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
if|#
directive|if
literal|1
name|DPRINTF
argument_list|(
operator|(
literal|"ExCA regs:"
operator|)
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|" 0x803: %02x"
operator|,
name|bus_space_read_1
argument_list|(
name|base_memt
argument_list|,
name|base_memh
argument_list|,
literal|0x803
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|" 0x805: %02x"
operator|,
name|bus_space_read_1
argument_list|(
name|base_memt
argument_list|,
name|base_memh
argument_list|,
literal|0x805
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|" 0x81e: %02x\n"
operator|,
name|bus_space_read_1
argument_list|(
name|base_memt
argument_list|,
name|base_memh
argument_list|,
literal|0x81e
argument_list|)
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|sc
operator|->
name|sc_chipset
operator|==
name|CB_TI12XX
condition|)
block|{
name|cbctrl
operator|=
name|pci_conf_read
argument_list|(
name|pc
argument_list|,
name|pa
operator|->
name|pa_tag
argument_list|,
name|PCI_CBCTRL
argument_list|)
expr_stmt|;
name|cbctrl
operator|&=
operator|~
name|PCI12XX_CBCTRL_INT_MASK
expr_stmt|;
comment|/* intr routing reset */
name|cbctrl
operator||=
name|PCI12XX_CBCTRL_INT_PCI
expr_stmt|;
comment|/* PCI intr */
name|pci_conf_write
argument_list|(
name|pc
argument_list|,
name|pa
operator|->
name|pa_tag
argument_list|,
name|PCI_CBCTRL
argument_list|,
name|cbctrl
argument_list|)
expr_stmt|;
name|bus_space_write_1
argument_list|(
name|base_memt
argument_list|,
name|base_memh
argument_list|,
literal|0x0803
argument_list|,
literal|0x10
argument_list|)
expr_stmt|;
name|bus_space_write_1
argument_list|(
name|base_memt
argument_list|,
name|base_memh
argument_list|,
literal|0x0805
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sc
operator|->
name|sc_chipset
operator|==
name|CB_TOPIC95B
condition|)
block|{
name|cardbusreg_t
name|sock_ctrl
decl_stmt|,
name|slot_ctrl
decl_stmt|;
name|sock_ctrl
operator|=
name|pci_conf_read
argument_list|(
name|pc
argument_list|,
name|pa
operator|->
name|pa_tag
argument_list|,
name|TOPIC_SOCKET_CTRL
argument_list|)
expr_stmt|;
name|pci_conf_write
argument_list|(
name|pc
argument_list|,
name|pa
operator|->
name|pa_tag
argument_list|,
name|TOPIC_SOCKET_CTRL
argument_list|,
name|sock_ctrl
operator||
name|TOPIC_SOCKET_CTRL_SCR_IRQSEL
argument_list|)
expr_stmt|;
name|slot_ctrl
operator|=
name|pci_conf_read
argument_list|(
name|pc
argument_list|,
name|pa
operator|->
name|pa_tag
argument_list|,
name|TOPIC_SLOT_CTRL
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"%s: topic slot ctrl reg 0x%x -> "
operator|,
name|sc
operator|->
name|sc_dev
operator|.
name|dv_xname
operator|,
name|slot_ctrl
operator|)
argument_list|)
expr_stmt|;
comment|/*    slot_ctrl&= ~TOPIC_SLOT_CTRL_CLOCK_MASK;*/
name|slot_ctrl
operator||=
operator|(
name|TOPIC_SLOT_CTRL_SLOTON
operator||
name|TOPIC_SLOT_CTRL_SLOTEN
operator||
name|TOPIC_SLOT_CTRL_ID_LOCK
operator|)
expr_stmt|;
name|slot_ctrl
operator||=
name|TOPIC_SLOT_CTRL_CARDBUS
expr_stmt|;
name|slot_ctrl
operator|&=
operator|~
name|TOPIC_SLOT_CTRL_SWDETECT
expr_stmt|;
name|pci_conf_write
argument_list|(
name|pc
argument_list|,
name|pa
operator|->
name|pa_tag
argument_list|,
name|TOPIC_SLOT_CTRL
argument_list|,
name|slot_ctrl
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"0x%x\n"
operator|,
name|slot_ctrl
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* close all memory and io windows */
name|pci_conf_write
argument_list|(
name|pc
argument_list|,
name|pa
operator|->
name|pa_tag
argument_list|,
name|PCI_CB_MEMBASE0
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
name|pci_conf_write
argument_list|(
name|pc
argument_list|,
name|pa
operator|->
name|pa_tag
argument_list|,
name|PCI_CB_MEMLIMIT0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pci_conf_write
argument_list|(
name|pc
argument_list|,
name|pa
operator|->
name|pa_tag
argument_list|,
name|PCI_CB_MEMBASE1
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
name|pci_conf_write
argument_list|(
name|pc
argument_list|,
name|pa
operator|->
name|pa_tag
argument_list|,
name|PCI_CB_MEMLIMIT1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pci_conf_write
argument_list|(
name|pc
argument_list|,
name|pa
operator|->
name|pa_tag
argument_list|,
name|PCI_CB_IOBASE0
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
name|pci_conf_write
argument_list|(
name|pc
argument_list|,
name|pa
operator|->
name|pa_tag
argument_list|,
name|PCI_CB_IOLIMIT0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pci_conf_write
argument_list|(
name|pc
argument_list|,
name|pa
operator|->
name|pa_tag
argument_list|,
name|PCI_CB_IOBASE1
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
name|pci_conf_write
argument_list|(
name|pc
argument_list|,
name|pa
operator|->
name|pa_tag
argument_list|,
name|PCI_CB_IOLIMIT1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/****** attach pccard bus ******/
end_comment

begin_function
name|STATIC
name|void
name|pccbb_pcmcia_attach
parameter_list|(
name|sc
parameter_list|)
name|struct
name|pccbb_softc
modifier|*
name|sc
decl_stmt|;
block|{
name|struct
name|cbb_pcic_handle
modifier|*
name|ph
init|=
operator|&
name|sc
operator|->
name|sc_pcmcia_h
decl_stmt|;
name|struct
name|pcmciabus_attach_args
name|paa
decl_stmt|;
name|sc
operator|->
name|sc_pcmcia_flags
operator||=
operator|(
name|PCCBB_PCMCIA_IO_RELOC
operator||
name|PCCBB_PCMCIA_MEM_32
operator|)
expr_stmt|;
comment|/* initialise pcmcia part in pccbb_softc */
name|ph
operator|->
name|sc
operator|=
name|sc
expr_stmt|;
name|ph
operator|->
name|sock
operator|=
name|sc
operator|->
name|sc_function
expr_stmt|;
name|ph
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|ph
operator|->
name|shutdown
operator|=
literal|0
expr_stmt|;
name|ph
operator|->
name|ih_irq
operator|=
name|sc
operator|->
name|sc_intrline
expr_stmt|;
name|ph
operator|->
name|ph_iot
operator|=
name|sc
operator|->
name|sc_base_memt
expr_stmt|;
name|ph
operator|->
name|ph_ioh
operator|=
name|sc
operator|->
name|sc_base_memh
expr_stmt|;
name|ph
operator|->
name|ph_read
operator|=
name|pccbb_pcmcia_read
expr_stmt|;
name|ph
operator|->
name|ph_write
operator|=
name|pccbb_pcmcia_write
expr_stmt|;
name|sc
operator|->
name|sc_pct
operator|=
operator|&
name|pccbb_pcmcia_funcs
expr_stmt|;
name|Pcic_write
argument_list|(
name|ph
argument_list|,
name|PCIC_CSC_INTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|Pcic_read
argument_list|(
name|ph
argument_list|,
name|PCIC_CSC
argument_list|)
expr_stmt|;
comment|/* initialise pcmcia bus attachment */
name|paa
operator|.
name|paa_busname
operator|=
literal|"pcmcia"
expr_stmt|;
name|paa
operator|.
name|pct
operator|=
name|sc
operator|->
name|sc_pct
expr_stmt|;
name|paa
operator|.
name|pch
operator|=
name|ph
expr_stmt|;
name|paa
operator|.
name|iobase
operator|=
literal|0
expr_stmt|;
comment|/* I don't use them */
name|paa
operator|.
name|iosize
operator|=
literal|0
expr_stmt|;
name|ph
operator|->
name|pcmcia
operator|=
name|config_found_sm
argument_list|(
operator|&
name|ph
operator|->
name|sc
operator|->
name|sc_dev
argument_list|,
operator|&
name|paa
argument_list|,
name|pccbb_pcmcia_print
argument_list|,
name|pccbb_pcmcia_submatch
argument_list|)
expr_stmt|;
if|if
condition|(
name|ph
operator|->
name|pcmcia
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
literal|1
operator|==
name|pccbb_detect_card
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"%s: a 16-bit pcmcia card found.\n"
argument_list|,
name|sc
operator|->
name|sc_dev
operator|.
name|dv_xname
argument_list|)
expr_stmt|;
comment|/*XXX*/
name|pccbb_pcmcia_attach_card
argument_list|(
name|ph
argument_list|)
expr_stmt|;
block|}
block|}
return|return;
block|}
end_function

begin_function
name|STATIC
name|void
name|pccbb_pcmcia_attach_card
parameter_list|(
name|ph
parameter_list|)
name|struct
name|cbb_pcic_handle
modifier|*
name|ph
decl_stmt|;
block|{
name|struct
name|pcmcia_softc
modifier|*
name|psc
init|=
operator|(
name|void
operator|*
operator|)
name|ph
operator|->
name|pcmcia
decl_stmt|;
if|if
condition|(
name|ph
operator|->
name|flags
operator|&
name|PCIC_FLAG_CARDP
condition|)
block|{
name|panic
argument_list|(
literal|"pccbb_pcmcia_attach_card: already attached"
argument_list|)
expr_stmt|;
block|}
comment|/* call the MI attach function */
name|psc
operator|->
name|sc_if
operator|.
name|if_card_attach
argument_list|(
name|ph
operator|->
name|pcmcia
argument_list|)
expr_stmt|;
name|ph
operator|->
name|flags
operator||=
name|PCIC_FLAG_CARDP
expr_stmt|;
block|}
end_function

begin_function
name|STATIC
name|void
name|pccbb_pcmcia_detach_card
parameter_list|(
name|ph
parameter_list|,
name|flags
parameter_list|)
name|struct
name|cbb_pcic_handle
modifier|*
name|ph
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|{
name|struct
name|pcmcia_softc
modifier|*
name|psc
init|=
operator|(
name|void
operator|*
operator|)
name|ph
operator|->
name|pcmcia
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|ph
operator|->
name|flags
operator|&
name|PCIC_FLAG_CARDP
operator|)
condition|)
block|{
name|panic
argument_list|(
literal|"pccbb_pcmcia_detach_card: already detached"
argument_list|)
expr_stmt|;
block|}
name|ph
operator|->
name|flags
operator|&=
operator|~
name|PCIC_FLAG_CARDP
expr_stmt|;
comment|/* call the MI detach function */
name|psc
operator|->
name|sc_if
operator|.
name|if_card_detach
argument_list|(
name|ph
operator|->
name|pcmcia
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/********************************************************************** * int pccbbintr(arg) *    void *arg; *   This routine handles the interrupt from Yenta PCI-CardBus bridge *   itself. **********************************************************************/
end_comment

begin_function
name|int
name|pccbbintr
parameter_list|(
name|arg
parameter_list|)
name|void
modifier|*
name|arg
decl_stmt|;
block|{
name|struct
name|pccbb_softc
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
name|bus_space_tag_t
name|memt
init|=
name|sc
operator|->
name|sc_base_memt
decl_stmt|;
name|bus_space_handle_t
name|memh
init|=
name|sc
operator|->
name|sc_base_memh
decl_stmt|;
name|u_int32_t
name|sockevent
decl_stmt|,
name|sockstate
decl_stmt|;
name|int
name|s
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|sockevent
operator|=
name|bus_space_read_4
argument_list|(
name|memt
argument_list|,
name|memh
argument_list|,
name|CB_SOCKET_EVENT
argument_list|)
operator|)
condition|)
return|return
literal|0
return|;
comment|/* not for me */
comment|/* reset bit */
name|bus_space_write_4
argument_list|(
name|memt
argument_list|,
name|memh
argument_list|,
name|CB_SOCKET_EVENT
argument_list|,
name|sockevent
argument_list|)
expr_stmt|;
if|if
condition|(
name|sockevent
operator|&
name|CB_SOCKET_EVENT_CD
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|CBB_CARDSTATUS_BUSY
operator|)
condition|)
block|{
name|s
operator|=
name|splhigh
argument_list|()
expr_stmt|;
comment|/* lock softc */
name|sc
operator|->
name|sc_queued
operator|=
literal|1
expr_stmt|;
name|sc
operator|->
name|sc_flags
operator||=
name|CBB_CARDSTATUS_BUSY
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* unlock softc */
name|wakeup
argument_list|(
operator|&
name|sc
operator|->
name|events
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"%s (pccbbintr): busy"
operator|,
name|sc
operator|->
name|sc_dev
operator|.
name|dv_xname
operator|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_flags
operator|&=
operator|~
name|CBB_CARDSTATUS_BUSY
expr_stmt|;
comment|/* XXX chatterling interrupts. Should change code like as i82365.c */
block|}
block|}
else|else
block|{
name|sockstate
operator|=
name|bus_space_read_4
argument_list|(
name|memt
argument_list|,
name|memh
argument_list|,
name|CB_SOCKET_STAT
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"%s (pccbbintr): 0x%08x"
operator|,
name|sc
operator|->
name|sc_dev
operator|.
name|dv_xname
operator|,
name|sockevent
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sockevent
operator|&
name|CB_SOCKET_EVENT_CSTS
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|" cstsevent occures, 0x%08x\n"
operator|,
name|sockstate
operator|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sockevent
operator|&
name|CB_SOCKET_EVENT_POWER
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|" pwrevent occures, 0x%08x\n"
operator|,
name|sockstate
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|DPRINTF
argument_list|(
operator|(
literal|" unknown event, 0x%08x\n"
operator|,
name|sockstate
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|pccbb_insert
parameter_list|(
name|arg
parameter_list|)
name|void
modifier|*
name|arg
decl_stmt|;
block|{
name|struct
name|pccbb_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|pccbb_softc
operator|*
operator|)
name|arg
decl_stmt|;
name|u_int32_t
name|sockevent
decl_stmt|,
name|sockstate
decl_stmt|;
name|int
name|timeout
init|=
literal|30
decl_stmt|;
do|do
block|{
name|sockevent
operator|=
name|bus_space_read_4
argument_list|(
name|sc
operator|->
name|sc_base_memt
argument_list|,
name|sc
operator|->
name|sc_base_memh
argument_list|,
name|CB_SOCKET_EVENT
argument_list|)
expr_stmt|;
name|sockstate
operator|=
name|bus_space_read_4
argument_list|(
name|sc
operator|->
name|sc_base_memt
argument_list|,
name|sc
operator|->
name|sc_base_memh
argument_list|,
name|CB_SOCKET_STAT
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|sockstate
operator|&
name|CB_SOCKET_STAT_CD
operator|&&
operator|--
name|timeout
operator|>
literal|0
condition|)
do|;
if|if
condition|(
name|timeout
operator|<
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%s: insert timeout"
argument_list|,
name|sc
operator|->
name|sc_dev
operator|.
name|dv_xname
argument_list|)
expr_stmt|;
return|return;
block|}
name|DPRINTF
argument_list|(
operator|(
literal|"%s: 0x%08x"
operator|,
name|sc
operator|->
name|sc_dev
operator|.
name|dv_xname
operator|,
name|sockevent
operator|)
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|" card inserted, 0x%08x\n"
operator|,
name|sockstate
operator|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_flags
operator||=
name|CBB_CARDEXIST
expr_stmt|;
comment|/* call pccard intterupt handler here */
if|if
condition|(
name|sockstate
operator|&
name|CB_SOCKET_STAT_16BIT
condition|)
block|{
comment|/* 16-bit card */
name|pccbb_pcmcia_attach_card
argument_list|(
operator|&
name|sc
operator|->
name|sc_pcmcia_h
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sockstate
operator|&
name|CB_SOCKET_STAT_CB
condition|)
block|{
comment|/* 32-bit card */
name|sc
operator|->
name|sc_cbdev
operator|=
name|sc
operator|->
name|sc_csc
operator|->
name|sc_if
operator|.
name|if_card_attach
argument_list|(
name|sc
operator|->
name|sc_csc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"unknown card type.\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_define
define|#
directive|define
name|PCCBB_PCMCIA_OFFSET
value|0x800
end_define

begin_function
specifier|static
name|u_int8_t
name|pccbb_pcmcia_read
parameter_list|(
name|ph
parameter_list|,
name|reg
parameter_list|)
name|struct
name|cbb_pcic_handle
modifier|*
name|ph
decl_stmt|;
name|int
name|reg
decl_stmt|;
block|{
return|return
name|bus_space_read_1
argument_list|(
name|ph
operator|->
name|ph_iot
argument_list|,
name|ph
operator|->
name|ph_ioh
argument_list|,
name|PCCBB_PCMCIA_OFFSET
operator|+
name|reg
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|pccbb_pcmcia_write
parameter_list|(
name|ph
parameter_list|,
name|reg
parameter_list|,
name|val
parameter_list|)
name|struct
name|cbb_pcic_handle
modifier|*
name|ph
decl_stmt|;
name|int
name|reg
decl_stmt|;
name|u_int8_t
name|val
decl_stmt|;
block|{
name|bus_space_write_1
argument_list|(
name|ph
operator|->
name|ph_iot
argument_list|,
name|ph
operator|->
name|ph_ioh
argument_list|,
name|PCCBB_PCMCIA_OFFSET
operator|+
name|reg
argument_list|,
name|val
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/********************************************************************** * STATIC int pccbb_ctrl(cardbus_chipset_tag_t, int) **********************************************************************/
end_comment

begin_function
name|STATIC
name|int
name|pccbb_ctrl
parameter_list|(
name|ct
parameter_list|,
name|command
parameter_list|)
name|cardbus_chipset_tag_t
name|ct
decl_stmt|;
name|int
name|command
decl_stmt|;
block|{
name|struct
name|pccbb_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|pccbb_softc
operator|*
operator|)
name|ct
decl_stmt|;
switch|switch
condition|(
name|command
condition|)
block|{
case|case
name|CARDBUS_CD
case|:
if|if
condition|(
literal|2
operator|==
name|pccbb_detect_card
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|int
name|retval
init|=
literal|0
decl_stmt|;
name|int
name|status
init|=
name|cb_detect_voltage
argument_list|(
name|sc
argument_list|)
decl_stmt|;
if|if
condition|(
name|PCCARD_VCC_5V
operator|&
name|status
condition|)
block|{
name|retval
operator||=
name|CARDBUS_5V_CARD
expr_stmt|;
block|}
if|if
condition|(
name|PCCARD_VCC_3V
operator|&
name|status
condition|)
block|{
name|retval
operator||=
name|CARDBUS_3V_CARD
expr_stmt|;
block|}
if|if
condition|(
name|PCCARD_VCC_XV
operator|&
name|status
condition|)
block|{
name|retval
operator||=
name|CARDBUS_XV_CARD
expr_stmt|;
block|}
if|if
condition|(
name|PCCARD_VCC_YV
operator|&
name|status
condition|)
block|{
name|retval
operator||=
name|CARDBUS_YV_CARD
expr_stmt|;
block|}
return|return
name|retval
return|;
block|}
else|else
block|{
return|return
literal|0
return|;
block|}
break|break;
case|case
name|CARDBUS_RESET
case|:
return|return
name|cb_reset
argument_list|(
name|sc
argument_list|)
return|;
break|break;
case|case
name|CARDBUS_IO_ENABLE
case|:
comment|/* fallthrough */
case|case
name|CARDBUS_IO_DISABLE
case|:
comment|/* fallthrough */
case|case
name|CARDBUS_MEM_ENABLE
case|:
comment|/* fallthrough */
case|case
name|CARDBUS_MEM_DISABLE
case|:
comment|/* fallthrough */
case|case
name|CARDBUS_BM_ENABLE
case|:
comment|/* fallthrough */
case|case
name|CARDBUS_BM_DISABLE
case|:
comment|/* fallthrough */
return|return
name|pccbb_cardenable
argument_list|(
name|sc
argument_list|,
name|command
argument_list|)
return|;
break|break;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/********************************************************************** * STATIC int pccbb_power(cardbus_chipset_tag_t, int) *   This function returns true when it succeeds and returns false when *   it fails. **********************************************************************/
end_comment

begin_function
name|STATIC
name|int
name|pccbb_power
parameter_list|(
name|ct
parameter_list|,
name|command
parameter_list|)
name|cardbus_chipset_tag_t
name|ct
decl_stmt|;
name|int
name|command
decl_stmt|;
block|{
name|struct
name|pccbb_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|pccbb_softc
operator|*
operator|)
name|ct
decl_stmt|;
name|u_int32_t
name|status
decl_stmt|,
name|sock_ctrl
decl_stmt|;
name|bus_space_tag_t
name|memt
init|=
name|sc
operator|->
name|sc_base_memt
decl_stmt|;
name|bus_space_handle_t
name|memh
init|=
name|sc
operator|->
name|sc_base_memh
decl_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"pccbb_power: %s and %s [%x]\n"
operator|,
operator|(
name|command
operator|&
name|CARDBUS_VCCMASK
operator|)
operator|==
name|CARDBUS_VCC_UC
condition|?
literal|"CARDBUS_VCC_UC"
else|:
operator|(
name|command
operator|&
name|CARDBUS_VCCMASK
operator|)
operator|==
name|CARDBUS_VCC_5V
condition|?
literal|"CARDBUS_VCC_5V"
else|:
operator|(
name|command
operator|&
name|CARDBUS_VCCMASK
operator|)
operator|==
name|CARDBUS_VCC_3V
condition|?
literal|"CARDBUS_VCC_3V"
else|:
operator|(
name|command
operator|&
name|CARDBUS_VCCMASK
operator|)
operator|==
name|CARDBUS_VCC_XV
condition|?
literal|"CARDBUS_VCC_XV"
else|:
operator|(
name|command
operator|&
name|CARDBUS_VCCMASK
operator|)
operator|==
name|CARDBUS_VCC_YV
condition|?
literal|"CARDBUS_VCC_YV"
else|:
operator|(
name|command
operator|&
name|CARDBUS_VCCMASK
operator|)
operator|==
name|CARDBUS_VCC_0V
condition|?
literal|"CARDBUS_VCC_0V"
else|:
literal|"UNKNOWN"
operator|,
operator|(
name|command
operator|&
name|CARDBUS_VPPMASK
operator|)
operator|==
name|CARDBUS_VPP_UC
condition|?
literal|"CARDBUS_VPP_UC"
else|:
operator|(
name|command
operator|&
name|CARDBUS_VPPMASK
operator|)
operator|==
name|CARDBUS_VPP_12V
condition|?
literal|"CARDBUS_VPP_12V"
else|:
operator|(
name|command
operator|&
name|CARDBUS_VPPMASK
operator|)
operator|==
name|CARDBUS_VPP_VCC
condition|?
literal|"CARDBUS_VPP_VCC"
else|:
operator|(
name|command
operator|&
name|CARDBUS_VPPMASK
operator|)
operator|==
name|CARDBUS_VPP_0V
condition|?
literal|"CARDBUS_VPP_0V"
else|:
literal|"UNKNOWN"
operator|,
name|command
operator|)
argument_list|)
expr_stmt|;
name|status
operator|=
name|bus_space_read_4
argument_list|(
name|memt
argument_list|,
name|memh
argument_list|,
name|CB_SOCKET_STAT
argument_list|)
expr_stmt|;
name|sock_ctrl
operator|=
name|bus_space_read_4
argument_list|(
name|memt
argument_list|,
name|memh
argument_list|,
name|CB_SOCKET_CTRL
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|command
operator|&
name|CARDBUS_VCCMASK
condition|)
block|{
case|case
name|CARDBUS_VCC_UC
case|:
break|break;
case|case
name|CARDBUS_VCC_5V
case|:
if|if
condition|(
name|CB_SOCKET_STAT_5VCARD
operator|&
name|status
condition|)
block|{
comment|/* check 5 V card */
name|sock_ctrl
operator|&=
operator|~
name|CB_SOCKET_CTRL_VCCMASK
expr_stmt|;
name|sock_ctrl
operator||=
name|CB_SOCKET_CTRL_VCC_5V
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"%s: BAD voltage request: no 5 V card\n"
argument_list|,
name|sc
operator|->
name|sc_dev
operator|.
name|dv_xname
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CARDBUS_VCC_3V
case|:
if|if
condition|(
name|CB_SOCKET_STAT_3VCARD
operator|&
name|status
condition|)
block|{
name|sock_ctrl
operator|&=
operator|~
name|CB_SOCKET_CTRL_VCCMASK
expr_stmt|;
name|sock_ctrl
operator||=
name|CB_SOCKET_CTRL_VCC_3V
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"%s: BAD voltage request: no 3.3 V card\n"
argument_list|,
name|sc
operator|->
name|sc_dev
operator|.
name|dv_xname
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CARDBUS_VCC_0V
case|:
name|sock_ctrl
operator|&=
operator|~
name|CB_SOCKET_CTRL_VCCMASK
expr_stmt|;
break|break;
default|default:
return|return
literal|0
return|;
comment|/* power NEVER changed */
break|break;
block|}
switch|switch
condition|(
name|command
operator|&
name|CARDBUS_VPPMASK
condition|)
block|{
case|case
name|CARDBUS_VPP_UC
case|:
break|break;
case|case
name|CARDBUS_VPP_0V
case|:
name|sock_ctrl
operator|&=
operator|~
name|CB_SOCKET_CTRL_VPPMASK
expr_stmt|;
break|break;
case|case
name|CARDBUS_VPP_VCC
case|:
name|sock_ctrl
operator|&=
operator|~
name|CB_SOCKET_CTRL_VPPMASK
expr_stmt|;
name|sock_ctrl
operator||=
operator|(
operator|(
name|sock_ctrl
operator|>>
literal|4
operator|)
operator|&
literal|0x07
operator|)
expr_stmt|;
break|break;
case|case
name|CARDBUS_VPP_12V
case|:
name|sock_ctrl
operator|&=
operator|~
name|CB_SOCKET_CTRL_VPPMASK
expr_stmt|;
name|sock_ctrl
operator||=
name|CB_SOCKET_CTRL_VPP_12V
expr_stmt|;
break|break;
block|}
if|#
directive|if
literal|0
block|DPRINTF(("sock_ctrl: %x\n", sock_ctrl));
endif|#
directive|endif
name|bus_space_write_4
argument_list|(
name|memt
argument_list|,
name|memh
argument_list|,
name|CB_SOCKET_CTRL
argument_list|,
name|sock_ctrl
argument_list|)
expr_stmt|;
name|status
operator|=
name|bus_space_read_4
argument_list|(
name|memt
argument_list|,
name|memh
argument_list|,
name|CB_SOCKET_STAT
argument_list|)
expr_stmt|;
block|{
name|int
name|timeout
init|=
literal|20
decl_stmt|;
name|u_int32_t
name|sockevent
decl_stmt|;
do|do
block|{
name|delay
argument_list|(
literal|20
operator|*
literal|1000
argument_list|)
expr_stmt|;
comment|/* wait 20 ms: Vcc setup time */
name|sockevent
operator|=
name|bus_space_read_4
argument_list|(
name|memt
argument_list|,
name|memh
argument_list|,
name|CB_SOCKET_EVENT
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|!
operator|(
name|sockevent
operator|&
name|CB_SOCKET_EVENT_POWER
operator|)
operator|&&
operator|--
name|timeout
operator|>
literal|0
condition|)
do|;
comment|/* reset event status */
name|bus_space_write_4
argument_list|(
name|memt
argument_list|,
name|memh
argument_list|,
name|CB_SOCKET_EVENT
argument_list|,
name|sockevent
argument_list|)
expr_stmt|;
if|if
condition|(
name|timeout
operator|<
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"VCC supply failed.\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
comment|/* XXX        delay 400 ms: thgough the standard defines that the Vcc set-up time        is 20 ms, some PC-Card bridge requires longer duration.     */
name|delay
argument_list|(
literal|400
operator|*
literal|1000
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|&
name|CB_SOCKET_STAT_BADVCC
condition|)
block|{
comment|/* bad Vcc request */
name|printf
argument_list|(
literal|"%s: bad Vcc request. sock_ctrl 0x%x, sock_status 0x%x\n"
argument_list|,
name|sc
operator|->
name|sc_dev
operator|.
name|dv_xname
argument_list|,
name|sock_ctrl
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"pccbb_power: %s and %s [%x]\n"
argument_list|,
operator|(
name|command
operator|&
name|CARDBUS_VCCMASK
operator|)
operator|==
name|CARDBUS_VCC_UC
condition|?
literal|"CARDBUS_VCC_UC"
else|:
operator|(
name|command
operator|&
name|CARDBUS_VCCMASK
operator|)
operator|==
name|CARDBUS_VCC_5V
condition|?
literal|"CARDBUS_VCC_5V"
else|:
operator|(
name|command
operator|&
name|CARDBUS_VCCMASK
operator|)
operator|==
name|CARDBUS_VCC_3V
condition|?
literal|"CARDBUS_VCC_3V"
else|:
operator|(
name|command
operator|&
name|CARDBUS_VCCMASK
operator|)
operator|==
name|CARDBUS_VCC_XV
condition|?
literal|"CARDBUS_VCC_XV"
else|:
operator|(
name|command
operator|&
name|CARDBUS_VCCMASK
operator|)
operator|==
name|CARDBUS_VCC_YV
condition|?
literal|"CARDBUS_VCC_YV"
else|:
operator|(
name|command
operator|&
name|CARDBUS_VCCMASK
operator|)
operator|==
name|CARDBUS_VCC_0V
condition|?
literal|"CARDBUS_VCC_0V"
else|:
literal|"UNKNOWN"
argument_list|,
operator|(
name|command
operator|&
name|CARDBUS_VPPMASK
operator|)
operator|==
name|CARDBUS_VPP_UC
condition|?
literal|"CARDBUS_VPP_UC"
else|:
operator|(
name|command
operator|&
name|CARDBUS_VPPMASK
operator|)
operator|==
name|CARDBUS_VPP_12V
condition|?
literal|"CARDBUS_VPP_12V"
else|:
operator|(
name|command
operator|&
name|CARDBUS_VPPMASK
operator|)
operator|==
name|CARDBUS_VPP_VCC
condition|?
literal|"CARDBUS_VPP_VCC"
else|:
operator|(
name|command
operator|&
name|CARDBUS_VPPMASK
operator|)
operator|==
name|CARDBUS_VPP_0V
condition|?
literal|"CARDBUS_VPP_0V"
else|:
literal|"UNKNOWN"
argument_list|,
name|command
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
name|DIAGNOSTIC
if|if
condition|(
name|command
operator|==
operator|(
name|CARDBUS_VCC_0V
operator||
name|CARDBUS_VPP_0V
operator|)
condition|)
block|{
name|u_int32_t
name|force
init|=
name|bus_space_read_4
argument_list|(
name|memt
argument_list|,
name|memh
argument_list|,
name|CB_SOCKET_FORCE
argument_list|)
decl_stmt|;
comment|/* Reset Bad Vcc request */
name|force
operator|&=
operator|~
name|CB_SOCKET_FORCE_BADVCC
expr_stmt|;
name|bus_space_write_4
argument_list|(
name|memt
argument_list|,
name|memh
argument_list|,
name|CB_SOCKET_FORCE
argument_list|,
name|force
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"new status 0x%x\n"
argument_list|,
name|bus_space_read_4
argument_list|(
name|memt
argument_list|,
name|memh
argument_list|,
name|CB_SOCKET_STAT
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
endif|#
directive|endif
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
comment|/* power changed correctly */
block|}
end_function

begin_comment
comment|/********************************************************************** * static int pccbb_detect_card(struct pccbb_softc *sc) *   return value:  0 if no card exists. *                  1 if 16-bit card exists. *                  2 if cardbus card exists. **********************************************************************/
end_comment

begin_function
specifier|static
name|int
name|pccbb_detect_card
parameter_list|(
name|sc
parameter_list|)
name|struct
name|pccbb_softc
modifier|*
name|sc
decl_stmt|;
block|{
name|bus_space_handle_t
name|base_memh
init|=
name|sc
operator|->
name|sc_base_memh
decl_stmt|;
name|bus_space_tag_t
name|base_memt
init|=
name|sc
operator|->
name|sc_base_memt
decl_stmt|;
name|u_int32_t
name|sockstat
init|=
name|bus_space_read_4
argument_list|(
name|base_memt
argument_list|,
name|base_memh
argument_list|,
name|CB_SOCKET_STAT
argument_list|)
decl_stmt|;
name|int
name|retval
init|=
literal|0
decl_stmt|;
if|if
condition|(
literal|0x00
operator|==
operator|(
name|sockstat
operator|&
name|CB_SOCKET_STAT_CD
operator|)
condition|)
block|{
comment|/* CD1 and CD2 asserted */
comment|/* card must be present */
if|if
condition|(
operator|!
operator|(
name|CB_SOCKET_STAT_NOTCARD
operator|&
name|sockstat
operator|)
condition|)
block|{
comment|/* NOTACARD DEASSERTED */
if|if
condition|(
name|CB_SOCKET_STAT_CB
operator|&
name|sockstat
condition|)
block|{
comment|/* CardBus mode */
name|retval
operator|=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|CB_SOCKET_STAT_16BIT
operator|&
name|sockstat
condition|)
block|{
comment|/* 16-bit mode */
name|retval
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
return|return
name|retval
return|;
block|}
end_function

begin_comment
comment|/********************************************************************** * STATIC int cb_reset(struct pccbb_softc *sc) *   This function resets the card. **********************************************************************/
end_comment

begin_function
name|STATIC
name|int
name|cb_reset
parameter_list|(
name|sc
parameter_list|)
name|struct
name|pccbb_softc
modifier|*
name|sc
decl_stmt|;
block|{
name|u_int32_t
name|bcr
init|=
name|pci_conf_read
argument_list|(
name|sc
operator|->
name|sc_pc
argument_list|,
name|sc
operator|->
name|sc_tag
argument_list|,
name|PCI_BCR_INTR
argument_list|)
decl_stmt|;
name|int
name|delay_us
decl_stmt|;
name|delay_us
operator|=
name|sc
operator|->
name|sc_chipset
operator|==
name|CB_RF5C47X
condition|?
literal|400
operator|*
literal|1000
else|:
literal|20
operator|*
literal|1000
expr_stmt|;
name|bcr
operator||=
operator|(
literal|0x40
operator|<<
literal|16
operator|)
expr_stmt|;
comment|/* Reset bit Assert (bit 6 at 0x3E) */
name|pci_conf_write
argument_list|(
name|sc
operator|->
name|sc_pc
argument_list|,
name|sc
operator|->
name|sc_tag
argument_list|,
name|PCI_BCR_INTR
argument_list|,
name|bcr
argument_list|)
expr_stmt|;
comment|/* Reset Assert at least 20 ms */
name|delay
argument_list|(
name|delay_us
argument_list|)
expr_stmt|;
if|if
condition|(
name|CBB_CARDEXIST
operator|&
name|sc
operator|->
name|sc_flags
condition|)
block|{
comment|/* A card exists.  Reset it! */
name|bcr
operator|&=
operator|~
operator|(
literal|0x40
operator|<<
literal|16
operator|)
expr_stmt|;
comment|/* Reset bit Deassert (bit 6 at 0x3E) */
name|pci_conf_write
argument_list|(
name|sc
operator|->
name|sc_pc
argument_list|,
name|sc
operator|->
name|sc_tag
argument_list|,
name|PCI_BCR_INTR
argument_list|,
name|bcr
argument_list|)
expr_stmt|;
name|delay
argument_list|(
name|delay_us
argument_list|)
expr_stmt|;
block|}
comment|/* No card found on the slot. Keep Reset. */
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/********************************************************************** * STATIC int cb_detect_voltage(struct pccbb_softc *sc) *  This function detect card Voltage. **********************************************************************/
end_comment

begin_function
name|STATIC
name|int
name|cb_detect_voltage
parameter_list|(
name|sc
parameter_list|)
name|struct
name|pccbb_softc
modifier|*
name|sc
decl_stmt|;
block|{
name|u_int32_t
name|psr
decl_stmt|;
comment|/* socket present-state reg */
name|bus_space_tag_t
name|iot
init|=
name|sc
operator|->
name|sc_base_memt
decl_stmt|;
name|bus_space_handle_t
name|ioh
init|=
name|sc
operator|->
name|sc_base_memh
decl_stmt|;
name|int
name|vol
init|=
name|PCCARD_VCC_UKN
decl_stmt|;
comment|/* set 0 */
name|psr
operator|=
name|bus_space_read_4
argument_list|(
name|iot
argument_list|,
name|ioh
argument_list|,
name|CB_SOCKET_STAT
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0x400u
operator|&
name|psr
condition|)
block|{
name|vol
operator||=
name|PCCARD_VCC_5V
expr_stmt|;
block|}
if|if
condition|(
literal|0x800u
operator|&
name|psr
condition|)
block|{
name|vol
operator||=
name|PCCARD_VCC_3V
expr_stmt|;
block|}
return|return
name|vol
return|;
block|}
end_function

begin_comment
comment|/********************************************************************** * STATIC int pccbb_cardenable(struct pccbb_softc *sc, int function) *   This function enables and disables the card **********************************************************************/
end_comment

begin_function
name|STATIC
name|int
name|pccbb_cardenable
parameter_list|(
name|sc
parameter_list|,
name|function
parameter_list|)
name|struct
name|pccbb_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|function
decl_stmt|;
block|{
name|u_int32_t
name|command
init|=
name|pci_conf_read
argument_list|(
name|sc
operator|->
name|sc_pc
argument_list|,
name|sc
operator|->
name|sc_tag
argument_list|,
name|PCI_COMMAND_STATUS_REG
argument_list|)
decl_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"pccbb_cardenable:"
operator|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|function
condition|)
block|{
case|case
name|CARDBUS_IO_ENABLE
case|:
name|command
operator||=
name|PCI_COMMAND_IO_ENABLE
expr_stmt|;
break|break;
case|case
name|CARDBUS_IO_DISABLE
case|:
name|command
operator|&=
operator|~
name|PCI_COMMAND_IO_ENABLE
expr_stmt|;
break|break;
case|case
name|CARDBUS_MEM_ENABLE
case|:
name|command
operator||=
name|PCI_COMMAND_MEM_ENABLE
expr_stmt|;
break|break;
case|case
name|CARDBUS_MEM_DISABLE
case|:
name|command
operator|&=
operator|~
name|PCI_COMMAND_MEM_ENABLE
expr_stmt|;
break|break;
case|case
name|CARDBUS_BM_ENABLE
case|:
name|command
operator||=
name|PCI_COMMAND_MASTER_ENABLE
expr_stmt|;
break|break;
case|case
name|CARDBUS_BM_DISABLE
case|:
name|command
operator|&=
operator|~
name|PCI_COMMAND_MASTER_ENABLE
expr_stmt|;
break|break;
default|default:
return|return
literal|0
return|;
block|}
name|pci_conf_write
argument_list|(
name|sc
operator|->
name|sc_pc
argument_list|,
name|sc
operator|->
name|sc_tag
argument_list|,
name|PCI_COMMAND_STATUS_REG
argument_list|,
name|command
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|" command reg 0x%x\n"
operator|,
name|command
operator|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/********************************************************************** * int pccbb_io_open(cardbus_chipset_tag_t, int, u_int32_t, u_int32_t) **********************************************************************/
end_comment

begin_function
specifier|static
name|int
name|pccbb_io_open
parameter_list|(
name|ct
parameter_list|,
name|win
parameter_list|,
name|start
parameter_list|,
name|end
parameter_list|)
name|cardbus_chipset_tag_t
name|ct
decl_stmt|;
name|int
name|win
decl_stmt|;
name|u_int32_t
name|start
decl_stmt|,
name|end
decl_stmt|;
block|{
name|struct
name|pccbb_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|pccbb_softc
operator|*
operator|)
name|ct
decl_stmt|;
name|int
name|basereg
decl_stmt|;
name|int
name|limitreg
decl_stmt|;
if|if
condition|(
operator|(
name|win
operator|<
literal|0
operator|)
operator|||
operator|(
name|win
operator|>
literal|2
operator|)
condition|)
block|{
if|#
directive|if
name|defined
name|DIAGNOSTIC
name|printf
argument_list|(
literal|"cardbus_io_open: window out of range %d\n"
argument_list|,
name|win
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|0
return|;
block|}
name|basereg
operator|=
name|win
operator|*
literal|8
operator|+
literal|0x2c
expr_stmt|;
name|limitreg
operator|=
name|win
operator|*
literal|8
operator|+
literal|0x30
expr_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"pccbb_io_open: 0x%x[0x%x] - 0x%x[0x%x]\n"
operator|,
name|start
operator|,
name|basereg
operator|,
name|end
operator|,
name|limitreg
operator|)
argument_list|)
expr_stmt|;
name|pci_conf_write
argument_list|(
name|sc
operator|->
name|sc_pc
argument_list|,
name|sc
operator|->
name|sc_tag
argument_list|,
name|basereg
argument_list|,
name|start
argument_list|)
expr_stmt|;
name|pci_conf_write
argument_list|(
name|sc
operator|->
name|sc_pc
argument_list|,
name|sc
operator|->
name|sc_tag
argument_list|,
name|limitreg
argument_list|,
name|end
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/********************************************************************** * int pccbb_io_close(cardbus_chipset_tag_t, int) **********************************************************************/
end_comment

begin_function
specifier|static
name|int
name|pccbb_io_close
parameter_list|(
name|ct
parameter_list|,
name|win
parameter_list|)
name|cardbus_chipset_tag_t
name|ct
decl_stmt|;
name|int
name|win
decl_stmt|;
block|{
name|struct
name|pccbb_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|pccbb_softc
operator|*
operator|)
name|ct
decl_stmt|;
name|int
name|basereg
decl_stmt|;
name|int
name|limitreg
decl_stmt|;
if|if
condition|(
operator|(
name|win
operator|<
literal|0
operator|)
operator|||
operator|(
name|win
operator|>
literal|2
operator|)
condition|)
block|{
if|#
directive|if
name|defined
name|DIAGNOSTIC
name|printf
argument_list|(
literal|"cardbus_io_close: window out of range %d\n"
argument_list|,
name|win
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|0
return|;
block|}
name|basereg
operator|=
name|win
operator|*
literal|8
operator|+
literal|0x2c
expr_stmt|;
name|limitreg
operator|=
name|win
operator|*
literal|8
operator|+
literal|0x30
expr_stmt|;
name|pci_conf_write
argument_list|(
name|sc
operator|->
name|sc_pc
argument_list|,
name|sc
operator|->
name|sc_tag
argument_list|,
name|basereg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pci_conf_write
argument_list|(
name|sc
operator|->
name|sc_pc
argument_list|,
name|sc
operator|->
name|sc_tag
argument_list|,
name|limitreg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/********************************************************************** * int pccbb_mem_open(cardbus_chipset_tag_t, int, u_int32_t, u_int32_t) **********************************************************************/
end_comment

begin_function
specifier|static
name|int
name|pccbb_mem_open
parameter_list|(
name|ct
parameter_list|,
name|win
parameter_list|,
name|start
parameter_list|,
name|end
parameter_list|)
name|cardbus_chipset_tag_t
name|ct
decl_stmt|;
name|int
name|win
decl_stmt|;
name|u_int32_t
name|start
decl_stmt|,
name|end
decl_stmt|;
block|{
name|struct
name|pccbb_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|pccbb_softc
operator|*
operator|)
name|ct
decl_stmt|;
name|int
name|basereg
decl_stmt|;
name|int
name|limitreg
decl_stmt|;
if|if
condition|(
operator|(
name|win
operator|<
literal|0
operator|)
operator|||
operator|(
name|win
operator|>
literal|2
operator|)
condition|)
block|{
if|#
directive|if
name|defined
name|DIAGNOSTIC
name|printf
argument_list|(
literal|"cardbus_mem_open: window out of range %d\n"
argument_list|,
name|win
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|0
return|;
block|}
name|basereg
operator|=
name|win
operator|*
literal|8
operator|+
literal|0x1c
expr_stmt|;
name|limitreg
operator|=
name|win
operator|*
literal|8
operator|+
literal|0x20
expr_stmt|;
name|pci_conf_write
argument_list|(
name|sc
operator|->
name|sc_pc
argument_list|,
name|sc
operator|->
name|sc_tag
argument_list|,
name|basereg
argument_list|,
name|start
argument_list|)
expr_stmt|;
name|pci_conf_write
argument_list|(
name|sc
operator|->
name|sc_pc
argument_list|,
name|sc
operator|->
name|sc_tag
argument_list|,
name|limitreg
argument_list|,
name|end
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/********************************************************************** * int pccbb_mem_close(cardbus_chipset_tag_t, int); **********************************************************************/
end_comment

begin_function
specifier|static
name|int
name|pccbb_mem_close
parameter_list|(
name|ct
parameter_list|,
name|win
parameter_list|)
name|cardbus_chipset_tag_t
name|ct
decl_stmt|;
name|int
name|win
decl_stmt|;
block|{
name|struct
name|pccbb_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|pccbb_softc
operator|*
operator|)
name|ct
decl_stmt|;
name|int
name|basereg
decl_stmt|;
name|int
name|limitreg
decl_stmt|;
if|if
condition|(
operator|(
name|win
operator|<
literal|0
operator|)
operator|||
operator|(
name|win
operator|>
literal|2
operator|)
condition|)
block|{
if|#
directive|if
name|defined
name|DIAGNOSTIC
name|printf
argument_list|(
literal|"cardbus_mem_close: window out of range %d\n"
argument_list|,
name|win
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|0
return|;
block|}
name|basereg
operator|=
name|win
operator|*
literal|8
operator|+
literal|0x1c
expr_stmt|;
name|limitreg
operator|=
name|win
operator|*
literal|8
operator|+
literal|0x20
expr_stmt|;
name|pci_conf_write
argument_list|(
name|sc
operator|->
name|sc_pc
argument_list|,
name|sc
operator|->
name|sc_tag
argument_list|,
name|basereg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pci_conf_write
argument_list|(
name|sc
operator|->
name|sc_pc
argument_list|,
name|sc
operator|->
name|sc_tag
argument_list|,
name|limitreg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function_decl
specifier|static
name|void
modifier|*
name|pccbb_intr_establish
parameter_list|(
name|ct
parameter_list|,
name|irq
parameter_list|,
name|level
parameter_list|,
name|func
parameter_list|,
name|arg
parameter_list|)
name|cardbus_chipset_tag_t
name|ct
decl_stmt|;
name|int
name|irq
decl_stmt|,
name|level
decl_stmt|;
function_decl|int
parameter_list|(
function_decl|* func
end_function_decl

begin_expr_stmt
unit|)
name|__P
argument_list|(
operator|(
name|void
operator|*
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|void
modifier|*
name|arg
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|pccbb_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|pccbb_softc
operator|*
operator|)
name|ct
decl_stmt|;
switch|switch
condition|(
name|sc
operator|->
name|sc_chipset
condition|)
block|{
case|case
name|CB_TI113X
case|:
block|{
name|pcireg_t
name|cbctrl
init|=
name|pci_conf_read
argument_list|(
name|sc
operator|->
name|sc_pc
argument_list|,
name|sc
operator|->
name|sc_tag
argument_list|,
name|PCI_CBCTRL
argument_list|)
decl_stmt|;
name|cbctrl
operator||=
name|PCI113X_CBCTRL_PCI_INTR
expr_stmt|;
comment|/* functional intr enabled */
name|pci_conf_write
argument_list|(
name|sc
operator|->
name|sc_pc
argument_list|,
name|sc
operator|->
name|sc_tag
argument_list|,
name|PCI_CBCTRL
argument_list|,
name|cbctrl
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
break|break;
block|}
return|return
name|pci_intr_establish
argument_list|(
name|sc
operator|->
name|sc_pc
argument_list|,
name|irq
argument_list|,
name|level
argument_list|,
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
name|void
operator|*
argument_list|)
operator|)
name|func
argument_list|,
name|arg
argument_list|)
return|;
block|}
end_block

begin_function
specifier|static
name|void
name|pccbb_intr_disestablish
parameter_list|(
name|ct
parameter_list|,
name|ih
parameter_list|)
name|cardbus_chipset_tag_t
name|ct
decl_stmt|;
name|void
modifier|*
name|ih
decl_stmt|;
block|{
name|struct
name|pccbb_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|pccbb_softc
operator|*
operator|)
name|ct
decl_stmt|;
switch|switch
condition|(
name|sc
operator|->
name|sc_chipset
condition|)
block|{
case|case
name|CB_TI113X
case|:
block|{
name|pcireg_t
name|cbctrl
init|=
name|pci_conf_read
argument_list|(
name|sc
operator|->
name|sc_pc
argument_list|,
name|sc
operator|->
name|sc_tag
argument_list|,
name|PCI_CBCTRL
argument_list|)
decl_stmt|;
name|cbctrl
operator|&=
operator|~
name|PCI113X_CBCTRL_PCI_INTR
expr_stmt|;
comment|/* functional intr disabled */
name|pci_conf_write
argument_list|(
name|sc
operator|->
name|sc_pc
argument_list|,
name|sc
operator|->
name|sc_tag
argument_list|,
name|PCI_CBCTRL
argument_list|,
name|cbctrl
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
break|break;
block|}
name|pci_intr_disestablish
argument_list|(
name|sc
operator|->
name|sc_pc
argument_list|,
name|ih
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
name|SHOW_REGS
end_if

begin_function
specifier|static
name|void
name|cb_show_regs
parameter_list|(
name|pc
parameter_list|,
name|tag
parameter_list|,
name|memt
parameter_list|,
name|memh
parameter_list|)
name|pci_chipset_tag_t
name|pc
decl_stmt|;
name|pcitag_t
name|tag
decl_stmt|;
name|bus_space_tag_t
name|memt
decl_stmt|;
name|bus_space_handle_t
name|memh
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|printf
argument_list|(
literal|"PCI config regs:"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|0x50
condition|;
name|i
operator|+=
literal|4
control|)
block|{
if|if
condition|(
name|i
operator|%
literal|16
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"\n 0x%02x:"
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|" %08lx"
argument_list|,
name|pci_conf_read
argument_list|(
name|pc
argument_list|,
name|tag
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0x80
init|;
name|i
operator|<
literal|0xb0
condition|;
name|i
operator|+=
literal|4
control|)
block|{
if|if
condition|(
name|i
operator|%
literal|16
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"\n 0x%02x:"
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|" %08lx"
argument_list|,
name|pci_conf_read
argument_list|(
name|pc
argument_list|,
name|tag
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|memh
operator|.
name|addr
operator|==
literal|0
condition|)
block|{
comment|/* XXX */
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|printf
argument_list|(
literal|"\nsocket regs:"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
literal|0x10
condition|;
name|i
operator|+=
literal|0x04
control|)
block|{
name|printf
argument_list|(
literal|" %08x"
argument_list|,
name|bus_space_read_4
argument_list|(
name|memt
argument_list|,
name|memh
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\nExCA regs:"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|0x08
condition|;
operator|++
name|i
control|)
block|{
name|printf
argument_list|(
literal|" %02x"
argument_list|,
name|bus_space_read_1
argument_list|(
name|memt
argument_list|,
name|memh
argument_list|,
literal|0x800
operator|+
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/********************************************************************** * static cardbustag_t pccbb_make_tag(cardbus_chipset_tag_t cc, *                                    int busno, int devno, int function); *   This is the function to make a tag to access config space of *  a CardBus Card.  It works same as pci_conf_read. **********************************************************************/
end_comment

begin_function
specifier|static
name|cardbustag_t
name|pccbb_make_tag
parameter_list|(
name|cc
parameter_list|,
name|busno
parameter_list|,
name|devno
parameter_list|,
name|function
parameter_list|)
name|cardbus_chipset_tag_t
name|cc
decl_stmt|;
name|int
name|busno
decl_stmt|,
name|devno
decl_stmt|,
name|function
decl_stmt|;
block|{
name|struct
name|pccbb_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|pccbb_softc
operator|*
operator|)
name|cc
decl_stmt|;
return|return
name|pci_make_tag
argument_list|(
name|sc
operator|->
name|sc_pc
argument_list|,
name|busno
argument_list|,
name|devno
argument_list|,
name|function
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|pccbb_free_tag
parameter_list|(
name|cardbus_chipset_tag_t
name|cc
parameter_list|,
name|cardbustag_t
name|tag
parameter_list|)
block|{
name|struct
name|pccbb_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|pccbb_softc
operator|*
operator|)
name|cc
decl_stmt|;
name|pci_free_tag
argument_list|(
name|tag
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/********************************************************************** * static cardbusreg_t pccbb_conf_read(cardbus_chipset_tag_t cc, *                                     cardbustag_t tag, int offset) *   This is the function to read the config space of a CardBus Card. *  It works same as pci_conf_read. **********************************************************************/
end_comment

begin_function
specifier|static
name|cardbusreg_t
name|pccbb_conf_read
parameter_list|(
name|ct
parameter_list|,
name|tag
parameter_list|,
name|offset
parameter_list|)
name|cardbus_chipset_tag_t
name|ct
decl_stmt|;
name|cardbustag_t
name|tag
decl_stmt|;
name|int
name|offset
decl_stmt|;
comment|/* register offset */
block|{
name|struct
name|pccbb_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|pccbb_softc
operator|*
operator|)
name|ct
decl_stmt|;
return|return
name|pci_conf_read
argument_list|(
name|sc
operator|->
name|sc_pc
argument_list|,
name|tag
argument_list|,
name|offset
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/********************************************************************** * static void pccbb_conf_write(cardbus_chipset_tag_t cc, cardbustag_t tag, *                              int offs, cardbusreg_t val) *   This is the function to write the config space of a CardBus Card. *  It works same as pci_conf_write. **********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|pccbb_conf_write
parameter_list|(
name|ct
parameter_list|,
name|tag
parameter_list|,
name|reg
parameter_list|,
name|val
parameter_list|)
name|cardbus_chipset_tag_t
name|ct
decl_stmt|;
name|cardbustag_t
name|tag
decl_stmt|;
name|int
name|reg
decl_stmt|;
comment|/* register offset */
name|cardbusreg_t
name|val
decl_stmt|;
block|{
name|struct
name|pccbb_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|pccbb_softc
operator|*
operator|)
name|ct
decl_stmt|;
name|pci_conf_write
argument_list|(
name|sc
operator|->
name|sc_pc
argument_list|,
name|tag
argument_list|,
name|reg
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/********************************************************************** * STATIC int pccbb_pcmcia_io_alloc(pcmcia_chipset_handle_t pch, *                                  bus_addr_t start, bus_size_t size, *                                  bus_size_t align, *                                  struct pcmcia_io_handle *pcihp * * This function only allocates I/O region for pccard. This function * never maps the allcated region to pccard I/O area. * * XXX: The interface of this function is not very good, I believe. **********************************************************************/
end_comment

begin_function
name|STATIC
name|int
name|pccbb_pcmcia_io_alloc
parameter_list|(
name|pch
parameter_list|,
name|start
parameter_list|,
name|size
parameter_list|,
name|align
parameter_list|,
name|pcihp
parameter_list|)
name|pcmcia_chipset_handle_t
name|pch
decl_stmt|;
name|bus_addr_t
name|start
decl_stmt|;
comment|/* start address */
name|bus_size_t
name|size
decl_stmt|;
name|bus_size_t
name|align
decl_stmt|;
name|struct
name|pcmcia_io_handle
modifier|*
name|pcihp
decl_stmt|;
block|{
name|struct
name|cbb_pcic_handle
modifier|*
name|ph
init|=
operator|(
expr|struct
name|cbb_pcic_handle
operator|*
operator|)
name|pch
decl_stmt|;
name|bus_addr_t
name|ioaddr
decl_stmt|;
name|int
name|flags
init|=
literal|0
decl_stmt|;
name|bus_space_tag_t
name|iot
decl_stmt|;
name|bus_space_handle_t
name|ioh
decl_stmt|;
comment|/*      * Allocate some arbitrary I/O space.      */
name|iot
operator|=
name|ph
operator|->
name|sc
operator|->
name|sc_iot
expr_stmt|;
if|if
condition|(
name|start
condition|)
block|{
name|ioaddr
operator|=
name|start
expr_stmt|;
if|if
condition|(
name|bus_space_map
argument_list|(
name|iot
argument_list|,
name|start
argument_list|,
name|size
argument_list|,
literal|0
argument_list|,
operator|&
name|ioh
argument_list|)
condition|)
block|{
return|return
literal|1
return|;
block|}
name|DPRINTF
argument_list|(
operator|(
literal|"pccbb_pcmcia_io_alloc map port %lx+%lx\n"
operator|,
operator|(
name|u_long
operator|)
name|ioaddr
operator|,
operator|(
name|u_long
operator|)
name|size
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|flags
operator||=
name|PCMCIA_IO_ALLOCATED
expr_stmt|;
if|if
condition|(
name|bus_space_alloc
argument_list|(
name|iot
argument_list|,
literal|0x700
comment|/* ph->sc->sc_iobase */
argument_list|,
literal|0x800
comment|/* ph->sc->sc_iobase + ph->sc->sc_iosize*/
argument_list|,
name|size
argument_list|,
name|align
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|&
name|ioaddr
argument_list|,
operator|&
name|ioh
argument_list|)
condition|)
block|{
comment|/* No room be able to be get. */
return|return
literal|1
return|;
block|}
name|DPRINTF
argument_list|(
operator|(
literal|"pccbb_pcmmcia_io_alloc alloc port 0x%lx+0x%lx\n"
operator|,
operator|(
name|u_long
operator|)
name|ioaddr
operator|,
operator|(
name|u_long
operator|)
name|size
operator|)
argument_list|)
expr_stmt|;
block|}
name|pcihp
operator|->
name|iot
operator|=
name|iot
expr_stmt|;
name|pcihp
operator|->
name|ioh
operator|=
name|ioh
expr_stmt|;
name|pcihp
operator|->
name|addr
operator|=
name|ioaddr
expr_stmt|;
name|pcihp
operator|->
name|size
operator|=
name|size
expr_stmt|;
name|pcihp
operator|->
name|flags
operator|=
name|flags
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/********************************************************************** * STATIC int pccbb_pcmcia_io_free(pcmcia_chipset_handle_t pch, *                                 struct pcmcia_io_handle *pcihp) * * This function only frees I/O region for pccard. * * XXX: The interface of this function is not very good, I believe. **********************************************************************/
end_comment

begin_function
name|void
name|pccbb_pcmcia_io_free
parameter_list|(
name|pch
parameter_list|,
name|pcihp
parameter_list|)
name|pcmcia_chipset_handle_t
name|pch
decl_stmt|;
name|struct
name|pcmcia_io_handle
modifier|*
name|pcihp
decl_stmt|;
block|{
name|bus_space_tag_t
name|iot
init|=
name|pcihp
operator|->
name|iot
decl_stmt|;
name|bus_space_handle_t
name|ioh
init|=
name|pcihp
operator|->
name|ioh
decl_stmt|;
name|bus_size_t
name|size
init|=
name|pcihp
operator|->
name|size
decl_stmt|;
if|if
condition|(
name|pcihp
operator|->
name|flags
operator|&
name|PCMCIA_IO_ALLOCATED
condition|)
name|bus_space_free
argument_list|(
name|iot
argument_list|,
name|ioh
argument_list|,
name|size
argument_list|)
expr_stmt|;
else|else
name|bus_space_unmap
argument_list|(
name|iot
argument_list|,
name|ioh
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/********************************************************************** * STATIC int pccbb_pcmcia_io_map(pcmcia_chipset_handle_t pch, int width, *                                bus_addr_t offset, bus_size_t size, *                                struct pcmcia_io_handle *pcihp, *                                int *windowp) * * This function maps the allocated I/O region to pccard. This function * never allocates any I/O region for pccard I/O area.  I don't * understand why the original authors of pcmciabus separated alloc and * map.  I believe the two must be unite. * * XXX: no wait timing control? **********************************************************************/
end_comment

begin_function
name|int
name|pccbb_pcmcia_io_map
parameter_list|(
name|pch
parameter_list|,
name|width
parameter_list|,
name|offset
parameter_list|,
name|size
parameter_list|,
name|pcihp
parameter_list|,
name|windowp
parameter_list|)
name|pcmcia_chipset_handle_t
name|pch
decl_stmt|;
name|int
name|width
decl_stmt|;
name|bus_addr_t
name|offset
decl_stmt|;
name|bus_size_t
name|size
decl_stmt|;
name|struct
name|pcmcia_io_handle
modifier|*
name|pcihp
decl_stmt|;
name|int
modifier|*
name|windowp
decl_stmt|;
block|{
name|struct
name|cbb_pcic_handle
modifier|*
name|ph
init|=
operator|(
expr|struct
name|cbb_pcic_handle
operator|*
operator|)
name|pch
decl_stmt|;
name|bus_addr_t
name|ioaddr
init|=
name|pcihp
operator|->
name|addr
operator|+
name|offset
decl_stmt|;
name|int
name|i
decl_stmt|,
name|win
decl_stmt|;
if|#
directive|if
name|defined
name|CBB_DEBUG
specifier|static
name|char
modifier|*
name|width_names
index|[]
init|=
block|{
literal|"dynamic"
block|,
literal|"io8"
block|,
literal|"io16"
block|}
decl_stmt|;
endif|#
directive|endif
comment|/* Sanity check I/O handle. */
if|if
condition|(
name|ph
operator|->
name|sc
operator|->
name|sc_iot
operator|!=
name|pcihp
operator|->
name|iot
condition|)
block|{
name|panic
argument_list|(
literal|"pccbb_pcmcia_io_map iot is bogus"
argument_list|)
expr_stmt|;
block|}
comment|/* XXX Sanity check offset/size. */
name|win
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|PCIC_IO_WINS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|ph
operator|->
name|ioalloc
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
name|win
operator|=
name|i
expr_stmt|;
name|ph
operator|->
name|ioalloc
operator||=
operator|(
literal|1
operator|<<
name|i
operator|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|win
operator|==
operator|-
literal|1
condition|)
block|{
return|return
literal|1
return|;
block|}
operator|*
name|windowp
operator|=
name|win
expr_stmt|;
comment|/* XXX this is pretty gross */
name|DPRINTF
argument_list|(
operator|(
literal|"pccbb_pcmcia_io_map window %d %s port %lx+%lx\n"
operator|,
name|win
operator|,
name|width_names
index|[
name|width
index|]
operator|,
operator|(
name|u_long
operator|)
name|ioaddr
operator|,
operator|(
name|u_long
operator|)
name|size
operator|)
argument_list|)
expr_stmt|;
comment|/* XXX wtf is this doing here? */
if|#
directive|if
literal|0
block|printf(" port 0x%lx", (u_long) ioaddr);     if (size> 1) { 	printf("-0x%lx", (u_long) ioaddr + (u_long) size - 1);     }
endif|#
directive|endif
name|ph
operator|->
name|io
index|[
name|win
index|]
operator|.
name|addr
operator|=
name|ioaddr
expr_stmt|;
name|ph
operator|->
name|io
index|[
name|win
index|]
operator|.
name|size
operator|=
name|size
expr_stmt|;
name|ph
operator|->
name|io
index|[
name|win
index|]
operator|.
name|width
operator|=
name|width
expr_stmt|;
comment|/* actual dirty register-value changing in the function below. */
name|pccbb_pcmcia_do_io_map
argument_list|(
name|ph
argument_list|,
name|win
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/********************************************************************** * STATIC void pccbb_pcmcia_do_io_map(struct pcic_handle *h, int win) * * This function changes register-value to map I/O region for pccard. **********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|pccbb_pcmcia_do_io_map
parameter_list|(
name|ph
parameter_list|,
name|win
parameter_list|)
name|struct
name|cbb_pcic_handle
modifier|*
name|ph
decl_stmt|;
name|int
name|win
decl_stmt|;
block|{
specifier|static
name|u_int8_t
name|pcic_iowidth
index|[
literal|3
index|]
init|=
block|{
name|PCIC_IOCTL_IO0_IOCS16SRC_CARD
block|,
name|PCIC_IOCTL_IO0_IOCS16SRC_DATASIZE
operator||
name|PCIC_IOCTL_IO0_DATASIZE_8BIT
block|,
name|PCIC_IOCTL_IO0_IOCS16SRC_DATASIZE
operator||
name|PCIC_IOCTL_IO0_DATASIZE_16BIT
block|,     }
decl_stmt|;
define|#
directive|define
name|PCIC_SIA_START_LOW
value|0
define|#
directive|define
name|PCIC_SIA_START_HIGH
value|1
define|#
directive|define
name|PCIC_SIA_STOP_LOW
value|2
define|#
directive|define
name|PCIC_SIA_STOP_HIGH
value|3
name|int
name|regbase_win
init|=
literal|0x8
operator|+
name|win
operator|*
literal|0x04
decl_stmt|;
name|u_int8_t
name|ioctl
decl_stmt|,
name|enable
decl_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"pccbb_pcmcia_do_io_map win %d addr 0x%lx size 0x%lx width %d\n"
operator|,
name|win
operator|,
operator|(
name|long
operator|)
name|ph
operator|->
name|io
index|[
name|win
index|]
operator|.
name|addr
operator|,
operator|(
name|long
operator|)
name|ph
operator|->
name|io
index|[
name|win
index|]
operator|.
name|size
operator|,
name|ph
operator|->
name|io
index|[
name|win
index|]
operator|.
name|width
operator|*
literal|8
operator|)
argument_list|)
expr_stmt|;
name|Pcic_write
argument_list|(
name|ph
argument_list|,
name|regbase_win
operator|+
name|PCIC_SIA_START_LOW
argument_list|,
name|ph
operator|->
name|io
index|[
name|win
index|]
operator|.
name|addr
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|Pcic_write
argument_list|(
name|ph
argument_list|,
name|regbase_win
operator|+
name|PCIC_SIA_START_HIGH
argument_list|,
operator|(
name|ph
operator|->
name|io
index|[
name|win
index|]
operator|.
name|addr
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|Pcic_write
argument_list|(
name|ph
argument_list|,
name|regbase_win
operator|+
name|PCIC_SIA_STOP_LOW
argument_list|,
operator|(
name|ph
operator|->
name|io
index|[
name|win
index|]
operator|.
name|addr
operator|+
name|ph
operator|->
name|io
index|[
name|win
index|]
operator|.
name|size
operator|-
literal|1
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|Pcic_write
argument_list|(
name|ph
argument_list|,
name|regbase_win
operator|+
name|PCIC_SIA_STOP_HIGH
argument_list|,
operator|(
operator|(
name|ph
operator|->
name|io
index|[
name|win
index|]
operator|.
name|addr
operator|+
name|ph
operator|->
name|io
index|[
name|win
index|]
operator|.
name|size
operator|-
literal|1
operator|)
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|ioctl
operator|=
name|Pcic_read
argument_list|(
name|ph
argument_list|,
name|PCIC_IOCTL
argument_list|)
expr_stmt|;
name|enable
operator|=
name|Pcic_read
argument_list|(
name|ph
argument_list|,
name|PCIC_ADDRWIN_ENABLE
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|win
condition|)
block|{
case|case
literal|0
case|:
name|ioctl
operator|&=
operator|~
operator|(
name|PCIC_IOCTL_IO0_WAITSTATE
operator||
name|PCIC_IOCTL_IO0_ZEROWAIT
operator||
name|PCIC_IOCTL_IO0_IOCS16SRC_MASK
operator||
name|PCIC_IOCTL_IO0_DATASIZE_MASK
operator|)
expr_stmt|;
name|ioctl
operator||=
name|pcic_iowidth
index|[
name|ph
operator|->
name|io
index|[
name|win
index|]
operator|.
name|width
index|]
expr_stmt|;
name|enable
operator||=
name|PCIC_ADDRWIN_ENABLE_IO0
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|ioctl
operator|&=
operator|~
operator|(
name|PCIC_IOCTL_IO1_WAITSTATE
operator||
name|PCIC_IOCTL_IO1_ZEROWAIT
operator||
name|PCIC_IOCTL_IO1_IOCS16SRC_MASK
operator||
name|PCIC_IOCTL_IO1_DATASIZE_MASK
operator|)
expr_stmt|;
name|ioctl
operator||=
operator|(
name|pcic_iowidth
index|[
name|ph
operator|->
name|io
index|[
name|win
index|]
operator|.
name|width
index|]
operator|<<
literal|4
operator|)
expr_stmt|;
name|enable
operator||=
name|PCIC_ADDRWIN_ENABLE_IO1
expr_stmt|;
break|break;
block|}
name|Pcic_write
argument_list|(
name|ph
argument_list|,
name|PCIC_IOCTL
argument_list|,
name|ioctl
argument_list|)
expr_stmt|;
name|Pcic_write
argument_list|(
name|ph
argument_list|,
name|PCIC_ADDRWIN_ENABLE
argument_list|,
name|enable
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
name|CBB_DEBUG
block|{
name|u_int8_t
name|start_low
init|=
name|Pcic_read
argument_list|(
name|ph
argument_list|,
name|regbase_win
operator|+
name|PCIC_SIA_START_LOW
argument_list|)
decl_stmt|;
name|u_int8_t
name|start_high
init|=
name|Pcic_read
argument_list|(
name|ph
argument_list|,
name|regbase_win
operator|+
name|PCIC_SIA_START_HIGH
argument_list|)
decl_stmt|;
name|u_int8_t
name|stop_low
init|=
name|Pcic_read
argument_list|(
name|ph
argument_list|,
name|regbase_win
operator|+
name|PCIC_SIA_STOP_LOW
argument_list|)
decl_stmt|;
name|u_int8_t
name|stop_high
init|=
name|Pcic_read
argument_list|(
name|ph
argument_list|,
name|regbase_win
operator|+
name|PCIC_SIA_STOP_HIGH
argument_list|)
decl_stmt|;
name|printf
argument_list|(
literal|" start %02x %02x, stop %02x %02x, ioctl %02x enable %02x\n"
argument_list|,
name|start_low
argument_list|,
name|start_high
argument_list|,
name|stop_low
argument_list|,
name|stop_high
argument_list|,
name|ioctl
argument_list|,
name|enable
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/********************************************************************** * STATIC void pccbb_pcmcia_io_unmap(pcmcia_chipset_handle_t *h, int win) * * This function unmapss I/O region.  No return value. **********************************************************************/
end_comment

begin_function
name|STATIC
name|void
name|pccbb_pcmcia_io_unmap
parameter_list|(
name|pch
parameter_list|,
name|win
parameter_list|)
name|pcmcia_chipset_handle_t
name|pch
decl_stmt|;
name|int
name|win
decl_stmt|;
block|{
name|struct
name|cbb_pcic_handle
modifier|*
name|ph
init|=
operator|(
expr|struct
name|cbb_pcic_handle
operator|*
operator|)
name|pch
decl_stmt|;
name|int
name|reg
decl_stmt|;
if|if
condition|(
name|win
operator|>=
name|PCIC_IO_WINS
operator|||
name|win
operator|<
literal|0
condition|)
block|{
name|panic
argument_list|(
literal|"pccbb_pcmcia_io_unmap: window out of range"
argument_list|)
expr_stmt|;
block|}
name|reg
operator|=
name|Pcic_read
argument_list|(
name|ph
argument_list|,
name|PCIC_ADDRWIN_ENABLE
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|win
condition|)
block|{
case|case
literal|0
case|:
name|reg
operator|&=
operator|~
name|PCIC_ADDRWIN_ENABLE_IO0
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|reg
operator|&=
operator|~
name|PCIC_ADDRWIN_ENABLE_IO1
expr_stmt|;
break|break;
block|}
name|Pcic_write
argument_list|(
name|ph
argument_list|,
name|PCIC_ADDRWIN_ENABLE
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|ph
operator|->
name|ioalloc
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|win
operator|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/********************************************************************** * static void pccbb_pcmcia_wait_ready(struct cbb_pcic_handle *ph) * * This function enables the card.  All information is stored in * the first argument, pcmcia_chipset_handle_t. **********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|pccbb_pcmcia_wait_ready
parameter_list|(
name|ph
parameter_list|)
name|struct
name|cbb_pcic_handle
modifier|*
name|ph
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"pccbb_pcmcia_wait_ready: status 0x%02x\n"
operator|,
name|Pcic_read
argument_list|(
name|ph
argument_list|,
name|PCIC_IF_STATUS
argument_list|)
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|10000
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|Pcic_read
argument_list|(
name|ph
argument_list|,
name|PCIC_IF_STATUS
argument_list|)
operator|&
name|PCIC_IF_STATUS_READY
condition|)
block|{
return|return;
block|}
name|delay
argument_list|(
literal|500
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|CBB_DEBUG
if|if
condition|(
operator|(
name|i
operator|>
literal|5000
operator|)
operator|&&
operator|(
name|i
operator|%
literal|100
operator|==
literal|99
operator|)
condition|)
name|printf
argument_list|(
literal|"."
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
ifdef|#
directive|ifdef
name|DIAGNOSTIC
name|printf
argument_list|(
literal|"pcic_wait_ready: ready never happened, status = %02x\n"
argument_list|,
name|Pcic_read
argument_list|(
name|ph
argument_list|,
name|PCIC_IF_STATUS
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/********************************************************************** * STATIC void pccbb_pcmcia_socket_enable(pcmcia_chipset_handle_t pch) * * This function enables the card.  All information is stored in * the first argument, pcmcia_chipset_handle_t. **********************************************************************/
end_comment

begin_function
name|STATIC
name|void
name|pccbb_pcmcia_socket_enable
parameter_list|(
name|pch
parameter_list|)
name|pcmcia_chipset_handle_t
name|pch
decl_stmt|;
block|{
name|struct
name|cbb_pcic_handle
modifier|*
name|ph
init|=
operator|(
expr|struct
name|cbb_pcic_handle
operator|*
operator|)
name|pch
decl_stmt|;
name|struct
name|pccbb_softc
modifier|*
name|sc
init|=
name|ph
operator|->
name|sc
decl_stmt|;
name|struct
name|pcmcia_softc
modifier|*
name|psc
init|=
operator|(
name|void
operator|*
operator|)
name|ph
operator|->
name|pcmcia
decl_stmt|;
name|int
name|cardtype
decl_stmt|,
name|win
decl_stmt|;
name|u_int8_t
name|power
decl_stmt|,
name|intr
decl_stmt|;
name|pcireg_t
name|spsr
decl_stmt|;
name|int
name|voltage
decl_stmt|;
define|#
directive|define
name|PCIC_INTR_PCI
value|PCIC_INTR_ENABLE
comment|/* this bit is mostly stolen from pcic_attach_card */
name|DPRINTF
argument_list|(
operator|(
literal|"pccbb_pcmcia_socket_enable:\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* get card Vcc info */
name|spsr
operator|=
name|bus_space_read_4
argument_list|(
name|sc
operator|->
name|sc_base_memt
argument_list|,
name|sc
operator|->
name|sc_base_memh
argument_list|,
name|CB_SOCKET_STAT
argument_list|)
expr_stmt|;
if|if
condition|(
name|spsr
operator|&
name|CB_SOCKET_STAT_5VCARD
condition|)
block|{
name|printf
argument_list|(
literal|"5V card\n"
argument_list|)
expr_stmt|;
comment|/* XXX */
name|voltage
operator|=
name|CARDBUS_VCC_5V
operator||
name|CARDBUS_VPP_VCC
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|spsr
operator|&
name|CB_SOCKET_STAT_3VCARD
condition|)
block|{
name|printf
argument_list|(
literal|"3V card\n"
argument_list|)
expr_stmt|;
comment|/* XXX */
name|voltage
operator|=
name|CARDBUS_VCC_3V
operator||
name|CARDBUS_VPP_VCC
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"?V card, 0x%x\n"
argument_list|,
name|spsr
argument_list|)
expr_stmt|;
comment|/* XXX */
return|return;
block|}
comment|/* assert reset bit */
name|intr
operator|=
name|Pcic_read
argument_list|(
name|ph
argument_list|,
name|PCIC_INTR
argument_list|)
expr_stmt|;
name|intr
operator|&=
operator|~
name|PCIC_INTR_RESET
expr_stmt|;
name|intr
operator||=
name|PCIC_INTR_PCI
expr_stmt|;
comment|/* XXX */
name|Pcic_write
argument_list|(
name|ph
argument_list|,
name|PCIC_INTR
argument_list|,
name|intr
argument_list|)
expr_stmt|;
comment|/* disable socket i/o: negate output enable bit */
name|power
operator|=
name|Pcic_read
argument_list|(
name|ph
argument_list|,
name|PCIC_PWRCTL
argument_list|)
expr_stmt|;
name|power
operator|&=
operator|~
name|PCIC_PWRCTL_OE
expr_stmt|;
name|Pcic_write
argument_list|(
name|ph
argument_list|,
name|PCIC_PWRCTL
argument_list|,
name|power
argument_list|)
expr_stmt|;
comment|/* power down the socket to reset it, clear the card reset pin */
name|pccbb_power
argument_list|(
name|sc
argument_list|,
name|CARDBUS_VCC_0V
operator||
name|CARDBUS_VPP_0V
argument_list|)
expr_stmt|;
comment|/*       * wait 300ms until power fails (Tpf).  Then, wait 100ms since      * we are changing Vcc (Toff).      */
name|delay
argument_list|(
operator|(
literal|300
operator|+
literal|100
operator|)
operator|*
literal|1000
argument_list|)
expr_stmt|;
comment|/* power up the socket */
name|pccbb_power
argument_list|(
name|sc
argument_list|,
name|voltage
argument_list|)
expr_stmt|;
comment|/*      * wait 100ms until power raise (Tpr) and 20ms to become      * stable (Tsu(Vcc)).      *      * some machines require some more time to be settled      * (another 200ms is added here).      */
name|delay
argument_list|(
operator|(
literal|100
operator|+
literal|20
operator|+
literal|200
operator|)
operator|*
literal|1000
argument_list|)
expr_stmt|;
name|power
operator|=
name|Pcic_read
argument_list|(
name|ph
argument_list|,
name|PCIC_PWRCTL
argument_list|)
expr_stmt|;
name|Pcic_write
argument_list|(
name|ph
argument_list|,
name|PCIC_PWRCTL
argument_list|,
name|power
operator||
name|PCIC_PWRCTL_OE
argument_list|)
expr_stmt|;
comment|/*      * hold RESET at least 10us.      */
name|delay
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|delay
argument_list|(
literal|2
operator|*
literal|1000
argument_list|)
expr_stmt|;
comment|/* XXX: TI1130 requires it. */
comment|/* clear the reset flag */
name|intr
operator|=
name|Pcic_read
argument_list|(
name|ph
argument_list|,
name|PCIC_INTR
argument_list|)
expr_stmt|;
name|Pcic_write
argument_list|(
name|ph
argument_list|,
name|PCIC_INTR
argument_list|,
name|intr
operator||
name|PCIC_INTR_RESET
argument_list|)
expr_stmt|;
comment|/* wait 20ms as per pc card standard (r2.01) section 4.3.6 */
name|delay
argument_list|(
literal|20000
argument_list|)
expr_stmt|;
comment|/* wait for the chip to finish initializing */
name|pccbb_pcmcia_wait_ready
argument_list|(
name|ph
argument_list|)
expr_stmt|;
comment|/* zero out the address windows */
name|Pcic_write
argument_list|(
name|ph
argument_list|,
name|PCIC_ADDRWIN_ENABLE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* set the card type */
name|cardtype
operator|=
name|psc
operator|->
name|sc_if
operator|.
name|if_card_gettype
argument_list|(
name|ph
operator|->
name|pcmcia
argument_list|)
expr_stmt|;
name|intr
operator|=
name|Pcic_read
argument_list|(
name|ph
argument_list|,
name|PCIC_INTR
argument_list|)
expr_stmt|;
name|intr
operator|&=
operator|~
name|PCIC_INTR_CARDTYPE_MASK
expr_stmt|;
name|intr
operator||=
operator|(
operator|(
name|cardtype
operator|==
name|PCMCIA_IFTYPE_IO
operator|)
condition|?
name|PCIC_INTR_CARDTYPE_IO
else|:
name|PCIC_INTR_CARDTYPE_MEM
operator|)
expr_stmt|;
name|Pcic_write
argument_list|(
name|ph
argument_list|,
name|PCIC_INTR
argument_list|,
name|intr
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"%s: pccbb_pcmcia_socket_enable %02x cardtype %s %02x\n"
operator|,
name|ph
operator|->
name|sc
operator|->
name|sc_dev
operator|.
name|dv_xname
operator|,
name|ph
operator|->
name|sock
operator|,
operator|(
operator|(
name|cardtype
operator|==
name|PCMCIA_IFTYPE_IO
operator|)
condition|?
literal|"io"
else|:
literal|"mem"
operator|)
operator|,
name|intr
operator|)
argument_list|)
expr_stmt|;
comment|/* reinstall all the memory and io mappings */
for|for
control|(
name|win
operator|=
literal|0
init|;
name|win
operator|<
name|PCIC_MEM_WINS
condition|;
operator|++
name|win
control|)
block|{
if|if
condition|(
name|ph
operator|->
name|memalloc
operator|&
operator|(
literal|1
operator|<<
name|win
operator|)
condition|)
block|{
name|pccbb_pcmcia_do_mem_map
argument_list|(
name|ph
argument_list|,
name|win
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|win
operator|=
literal|0
init|;
name|win
operator|<
name|PCIC_IO_WINS
condition|;
operator|++
name|win
control|)
block|{
if|if
condition|(
name|ph
operator|->
name|ioalloc
operator|&
operator|(
literal|1
operator|<<
name|win
operator|)
condition|)
block|{
name|pccbb_pcmcia_do_io_map
argument_list|(
name|ph
argument_list|,
name|win
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/********************************************************************** * STATIC void pccbb_pcmcia_socket_disable(pcmcia_chipset_handle_t *ph) * * This function disables the card.  All information is stored in * the first argument, pcmcia_chipset_handle_t. **********************************************************************/
end_comment

begin_function
name|STATIC
name|void
name|pccbb_pcmcia_socket_disable
parameter_list|(
name|pch
parameter_list|)
name|pcmcia_chipset_handle_t
name|pch
decl_stmt|;
block|{
name|struct
name|cbb_pcic_handle
modifier|*
name|ph
init|=
operator|(
expr|struct
name|cbb_pcic_handle
operator|*
operator|)
name|pch
decl_stmt|;
name|struct
name|pccbb_softc
modifier|*
name|sc
init|=
name|ph
operator|->
name|sc
decl_stmt|;
name|u_int8_t
name|power
decl_stmt|,
name|intr
decl_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"pccbb_pcmcia_socket_disable\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* reset signal asserting... */
name|intr
operator|=
name|Pcic_read
argument_list|(
name|ph
argument_list|,
name|PCIC_INTR
argument_list|)
expr_stmt|;
name|intr
operator|&=
operator|~
name|PCIC_INTR_RESET
expr_stmt|;
name|Pcic_write
argument_list|(
name|ph
argument_list|,
name|PCIC_INTR
argument_list|,
name|intr
argument_list|)
expr_stmt|;
name|delay
argument_list|(
literal|2
operator|*
literal|1000
argument_list|)
expr_stmt|;
comment|/* power down the socket */
name|power
operator|=
name|Pcic_read
argument_list|(
name|ph
argument_list|,
name|PCIC_PWRCTL
argument_list|)
expr_stmt|;
name|power
operator|&=
operator|~
name|PCIC_PWRCTL_OE
expr_stmt|;
name|Pcic_write
argument_list|(
name|ph
argument_list|,
name|PCIC_PWRCTL
argument_list|,
name|power
argument_list|)
expr_stmt|;
name|pccbb_power
argument_list|(
name|sc
argument_list|,
name|CARDBUS_VCC_0V
operator||
name|CARDBUS_VPP_0V
argument_list|)
expr_stmt|;
comment|/*      * wait 300ms until power fails (Tpf).      */
name|delay
argument_list|(
literal|300
operator|*
literal|1000
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/********************************************************************** * STATIC int pccbb_pcmcia_mem_alloc(pcmcia_chipset_handle_t pch, *                                   bus_size_t size, *                                   struct pcmcia_mem_handle *pcmhp) * * This function only allocates memory region for pccard. This * function never maps the allcated region to pccard memory area. * * XXX: Why the argument of start address is not in? **********************************************************************/
end_comment

begin_function
name|STATIC
name|int
name|pccbb_pcmcia_mem_alloc
parameter_list|(
name|pch
parameter_list|,
name|size
parameter_list|,
name|pcmhp
parameter_list|)
name|pcmcia_chipset_handle_t
name|pch
decl_stmt|;
name|bus_size_t
name|size
decl_stmt|;
name|struct
name|pcmcia_mem_handle
modifier|*
name|pcmhp
decl_stmt|;
block|{
name|struct
name|cbb_pcic_handle
modifier|*
name|ph
init|=
operator|(
expr|struct
name|cbb_pcic_handle
operator|*
operator|)
name|pch
decl_stmt|;
name|bus_space_handle_t
name|memh
decl_stmt|;
name|bus_addr_t
name|addr
decl_stmt|;
name|bus_size_t
name|sizepg
decl_stmt|;
name|struct
name|pccbb_softc
modifier|*
name|sc
init|=
name|ph
operator|->
name|sc
decl_stmt|;
comment|/* out of sc->memh, allocate as many pages as necessary */
comment|/* convert size to PCIC pages */
comment|/*       This is not enough; when the requested region is on the       page boundaries, this may calculate wrong result.     */
name|sizepg
operator|=
operator|(
name|size
operator|+
operator|(
name|PCIC_MEM_PAGESIZE
operator|-
literal|1
operator|)
operator|)
operator|/
name|PCIC_MEM_PAGESIZE
expr_stmt|;
if|#
directive|if
literal|0
block|if (sizepg> PCIC_MAX_MEM_PAGES) { 	return 1;     }
endif|#
directive|endif
if|if
condition|(
operator|!
operator|(
name|sc
operator|->
name|sc_pcmcia_flags
operator|&
name|PCCBB_PCMCIA_MEM_32
operator|)
condition|)
block|{
return|return
literal|1
return|;
block|}
name|addr
operator|=
literal|0
expr_stmt|;
comment|/* XXX gcc -Wuninitialized */
if|if
condition|(
name|bus_space_alloc
argument_list|(
name|sc
operator|->
name|sc_memt
argument_list|,
name|sc
operator|->
name|sc_mem_start
argument_list|,
name|sc
operator|->
name|sc_mem_end
argument_list|,
name|sizepg
operator|*
name|PCIC_MEM_PAGESIZE
argument_list|,
name|PCIC_MEM_PAGESIZE
argument_list|,
literal|0
comment|/* boundary */
argument_list|,
literal|0
comment|/* flags */
argument_list|,
operator|&
name|addr
argument_list|,
operator|&
name|memh
argument_list|)
condition|)
block|{
return|return
literal|1
return|;
block|}
name|DPRINTF
argument_list|(
operator|(
literal|"pccbb_pcmcia_alloc_mem: addr 0x%lx size 0x%lx, realsize 0x%lx\n"
operator|,
operator|(
name|u_long
operator|)
name|addr
operator|,
operator|(
name|u_long
operator|)
name|size
operator|,
operator|(
name|u_long
operator|)
name|sizepg
operator|*
name|PCIC_MEM_PAGESIZE
operator|)
argument_list|)
expr_stmt|;
name|pcmhp
operator|->
name|memt
operator|=
name|sc
operator|->
name|sc_memt
expr_stmt|;
name|pcmhp
operator|->
name|memh
operator|=
name|memh
expr_stmt|;
name|pcmhp
operator|->
name|addr
operator|=
name|addr
expr_stmt|;
name|pcmhp
operator|->
name|size
operator|=
name|size
expr_stmt|;
name|pcmhp
operator|->
name|realsize
operator|=
name|sizepg
operator|*
name|PCIC_MEM_PAGESIZE
expr_stmt|;
comment|/* What is mhandle?  I feel it is very dirty and it must go trush. */
name|pcmhp
operator|->
name|mhandle
operator|=
literal|0
expr_stmt|;
comment|/* No offset???  Funny. */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/********************************************************************** * STATIC void pccbb_pcmcia_mem_free(pcmcia_chipset_handle_t pch, *                                   struct pcmcia_mem_handle *pcmhp) * * This function release the memory space allocated by the fuction * pccbb_pcmcia_mem_alloc(). **********************************************************************/
end_comment

begin_function
name|STATIC
name|void
name|pccbb_pcmcia_mem_free
parameter_list|(
name|pch
parameter_list|,
name|pcmhp
parameter_list|)
name|pcmcia_chipset_handle_t
name|pch
decl_stmt|;
name|struct
name|pcmcia_mem_handle
modifier|*
name|pcmhp
decl_stmt|;
block|{
name|bus_space_free
argument_list|(
name|pcmhp
operator|->
name|memt
argument_list|,
name|pcmhp
operator|->
name|memh
argument_list|,
name|pcmhp
operator|->
name|realsize
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/********************************************************************** * STATIC void pccbb_pcmcia_do_mem_map(struct cbb_pcic_handle *ph, *                                     int win) * * This function release the memory space allocated by the fuction * pccbb_pcmcia_mem_alloc(). **********************************************************************/
end_comment

begin_function
name|STATIC
name|void
name|pccbb_pcmcia_do_mem_map
parameter_list|(
name|ph
parameter_list|,
name|win
parameter_list|)
name|struct
name|cbb_pcic_handle
modifier|*
name|ph
decl_stmt|;
name|int
name|win
decl_stmt|;
block|{
name|int
name|regbase_win
decl_stmt|;
name|bus_addr_t
name|phys_addr
decl_stmt|;
name|bus_addr_t
name|phys_end
decl_stmt|;
define|#
directive|define
name|PCIC_SMM_START_LOW
value|0
define|#
directive|define
name|PCIC_SMM_START_HIGH
value|1
define|#
directive|define
name|PCIC_SMM_STOP_LOW
value|2
define|#
directive|define
name|PCIC_SMM_STOP_HIGH
value|3
define|#
directive|define
name|PCIC_CMA_LOW
value|4
define|#
directive|define
name|PCIC_CMA_HIGH
value|5
name|u_int8_t
name|start_low
decl_stmt|,
name|start_high
init|=
literal|0
decl_stmt|;
name|u_int8_t
name|stop_low
decl_stmt|,
name|stop_high
decl_stmt|;
name|u_int8_t
name|off_low
decl_stmt|,
name|off_high
decl_stmt|;
name|u_int8_t
name|mem_window
decl_stmt|;
name|int
name|reg
decl_stmt|;
name|regbase_win
operator|=
literal|0x10
operator|+
name|win
operator|*
literal|0x08
expr_stmt|;
name|phys_addr
operator|=
name|ph
operator|->
name|mem
index|[
name|win
index|]
operator|.
name|addr
expr_stmt|;
name|phys_end
operator|=
name|phys_addr
operator|+
name|ph
operator|->
name|mem
index|[
name|win
index|]
operator|.
name|size
expr_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"pccbb_pcmcia_do_mem_map: start 0x%lx end 0x%lx off 0x%lx\n"
operator|,
operator|(
name|u_long
operator|)
name|phys_addr
operator|,
operator|(
name|u_long
operator|)
name|phys_end
operator|,
name|ph
operator|->
name|mem
index|[
name|win
index|]
operator|.
name|offset
operator|)
argument_list|)
expr_stmt|;
define|#
directive|define
name|PCIC_MEMREG_LSB_SHIFT
value|PCIC_SYSMEM_ADDRX_SHIFT
define|#
directive|define
name|PCIC_MEMREG_MSB_SHIFT
value|(PCIC_SYSMEM_ADDRX_SHIFT + 8)
define|#
directive|define
name|PCIC_MEMREG_WIN_SHIFT
value|(PCIC_SYSMEM_ADDRX_SHIFT + 12)
name|start_low
operator|=
operator|(
name|phys_addr
operator|>>
name|PCIC_MEMREG_LSB_SHIFT
operator|)
operator|&
literal|0xff
expr_stmt|;
comment|/* bit 19:12 */
name|start_high
operator|=
operator|(
operator|(
name|phys_addr
operator|>>
name|PCIC_MEMREG_MSB_SHIFT
operator|)
operator|&
literal|0x0f
operator|)
comment|/* bit 23:20 */
operator||
name|PCIC_SYSMEM_ADDRX_START_MSB_DATASIZE_16BIT
expr_stmt|;
comment|/* bit 7 on */
comment|/* bit 31:24, for 32-bit address */
name|mem_window
operator|=
operator|(
name|phys_addr
operator|>>
name|PCIC_MEMREG_WIN_SHIFT
operator|)
operator|&
literal|0xff
expr_stmt|;
comment|/* bit 31:24 */
name|Pcic_write
argument_list|(
name|ph
argument_list|,
name|regbase_win
operator|+
name|PCIC_SMM_START_LOW
argument_list|,
name|start_low
argument_list|)
expr_stmt|;
name|Pcic_write
argument_list|(
name|ph
argument_list|,
name|regbase_win
operator|+
name|PCIC_SMM_START_HIGH
argument_list|,
name|start_high
argument_list|)
expr_stmt|;
if|if
condition|(
name|ph
operator|->
name|sc
operator|->
name|sc_pcmcia_flags
operator|&
name|PCCBB_PCMCIA_MEM_32
condition|)
block|{
name|Pcic_write
argument_list|(
name|ph
argument_list|,
literal|0x40
operator|+
name|win
argument_list|,
name|mem_window
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
literal|0
comment|/* XXX do I want 16 bit all the time? */
block|PCIC_SYSMEM_ADDRX_START_MSB_DATASIZE_16BIT;
endif|#
directive|endif
name|stop_low
operator|=
operator|(
name|phys_end
operator|>>
name|PCIC_MEMREG_LSB_SHIFT
operator|)
operator|&
literal|0xff
expr_stmt|;
name|stop_high
operator|=
operator|(
operator|(
name|phys_end
operator|>>
name|PCIC_MEMREG_MSB_SHIFT
operator|)
operator|&
literal|0x0f
operator|)
operator||
name|PCIC_SYSMEM_ADDRX_STOP_MSB_WAIT2
expr_stmt|;
comment|/* wait 2 cycles */
comment|/* XXX Geee, WAIT2!! Crazy!!  I must rewrite this routine. */
name|Pcic_write
argument_list|(
name|ph
argument_list|,
name|regbase_win
operator|+
name|PCIC_SMM_STOP_LOW
argument_list|,
name|stop_low
argument_list|)
expr_stmt|;
name|Pcic_write
argument_list|(
name|ph
argument_list|,
name|regbase_win
operator|+
name|PCIC_SMM_STOP_HIGH
argument_list|,
name|stop_high
argument_list|)
expr_stmt|;
name|off_low
operator|=
operator|(
name|ph
operator|->
name|mem
index|[
name|win
index|]
operator|.
name|offset
operator|>>
name|PCIC_CARDMEM_ADDRX_SHIFT
operator|)
operator|&
literal|0xff
expr_stmt|;
name|off_high
operator|=
operator|(
operator|(
name|ph
operator|->
name|mem
index|[
name|win
index|]
operator|.
name|offset
operator|>>
operator|(
name|PCIC_CARDMEM_ADDRX_SHIFT
operator|+
literal|8
operator|)
operator|)
operator|&
name|PCIC_CARDMEM_ADDRX_MSB_ADDR_MASK
operator|)
operator||
operator|(
operator|(
name|ph
operator|->
name|mem
index|[
name|win
index|]
operator|.
name|kind
operator|==
name|PCMCIA_MEM_ATTR
operator|)
condition|?
name|PCIC_CARDMEM_ADDRX_MSB_REGACTIVE_ATTR
else|:
literal|0
operator|)
expr_stmt|;
name|Pcic_write
argument_list|(
name|ph
argument_list|,
name|regbase_win
operator|+
name|PCIC_CMA_LOW
argument_list|,
name|off_low
argument_list|)
expr_stmt|;
name|Pcic_write
argument_list|(
name|ph
argument_list|,
name|regbase_win
operator|+
name|PCIC_CMA_HIGH
argument_list|,
name|off_high
argument_list|)
expr_stmt|;
name|reg
operator|=
name|Pcic_read
argument_list|(
name|ph
argument_list|,
name|PCIC_ADDRWIN_ENABLE
argument_list|)
expr_stmt|;
name|reg
operator||=
operator|(
operator|(
literal|1
operator|<<
name|win
operator|)
operator||
name|PCIC_ADDRWIN_ENABLE_MEMCS16
operator|)
expr_stmt|;
name|Pcic_write
argument_list|(
name|ph
argument_list|,
name|PCIC_ADDRWIN_ENABLE
argument_list|,
name|reg
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
name|CBB_DEBUG
block|{
name|int
name|r1
decl_stmt|,
name|r2
decl_stmt|,
name|r3
decl_stmt|,
name|r4
decl_stmt|,
name|r5
decl_stmt|,
name|r6
decl_stmt|,
name|r7
init|=
literal|0
decl_stmt|;
name|r1
operator|=
name|Pcic_read
argument_list|(
name|ph
argument_list|,
name|regbase_win
operator|+
name|PCIC_SMM_START_LOW
argument_list|)
expr_stmt|;
name|r2
operator|=
name|Pcic_read
argument_list|(
name|ph
argument_list|,
name|regbase_win
operator|+
name|PCIC_SMM_START_HIGH
argument_list|)
expr_stmt|;
name|r3
operator|=
name|Pcic_read
argument_list|(
name|ph
argument_list|,
name|regbase_win
operator|+
name|PCIC_SMM_STOP_LOW
argument_list|)
expr_stmt|;
name|r4
operator|=
name|Pcic_read
argument_list|(
name|ph
argument_list|,
name|regbase_win
operator|+
name|PCIC_SMM_STOP_HIGH
argument_list|)
expr_stmt|;
name|r5
operator|=
name|Pcic_read
argument_list|(
name|ph
argument_list|,
name|regbase_win
operator|+
name|PCIC_CMA_LOW
argument_list|)
expr_stmt|;
name|r6
operator|=
name|Pcic_read
argument_list|(
name|ph
argument_list|,
name|regbase_win
operator|+
name|PCIC_CMA_HIGH
argument_list|)
expr_stmt|;
if|if
condition|(
name|ph
operator|->
name|sc
operator|->
name|sc_pcmcia_flags
operator|&
name|PCCBB_PCMCIA_MEM_32
condition|)
block|{
name|r7
operator|=
name|Pcic_read
argument_list|(
name|ph
argument_list|,
literal|0x40
operator|+
name|win
argument_list|)
expr_stmt|;
block|}
name|DPRINTF
argument_list|(
operator|(
literal|"pccbb_pcmcia_do_mem_map window %d: %02x%02x %02x%02x "
literal|"%02x%02x"
operator|,
name|win
operator|,
name|r1
operator|,
name|r2
operator|,
name|r3
operator|,
name|r4
operator|,
name|r5
operator|,
name|r6
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ph
operator|->
name|sc
operator|->
name|sc_pcmcia_flags
operator|&
name|PCCBB_PCMCIA_MEM_32
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|" %02x"
operator|,
name|r7
operator|)
argument_list|)
expr_stmt|;
block|}
name|DPRINTF
argument_list|(
operator|(
literal|"\n"
operator|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/********************************************************************** * STATIC int pccbb_pcmcia_mem_map(pcmcia_chipset_handle_t pch, int kind, *                                 bus_addr_t card_addr, bus_size_t size, *                                 struct pcmcia_mem_handle *pcmhp, *                                 bus_addr_t *offsetp, int *windowp) * * This function maps memory space allocated by the fuction * pccbb_pcmcia_mem_alloc(). **********************************************************************/
end_comment

begin_function
name|STATIC
name|int
name|pccbb_pcmcia_mem_map
parameter_list|(
name|pch
parameter_list|,
name|kind
parameter_list|,
name|card_addr
parameter_list|,
name|size
parameter_list|,
name|pcmhp
parameter_list|,
name|offsetp
parameter_list|,
name|windowp
parameter_list|)
name|pcmcia_chipset_handle_t
name|pch
decl_stmt|;
name|int
name|kind
decl_stmt|;
name|bus_addr_t
name|card_addr
decl_stmt|;
name|bus_size_t
name|size
decl_stmt|;
name|struct
name|pcmcia_mem_handle
modifier|*
name|pcmhp
decl_stmt|;
name|bus_addr_t
modifier|*
name|offsetp
decl_stmt|;
name|int
modifier|*
name|windowp
decl_stmt|;
block|{
name|struct
name|cbb_pcic_handle
modifier|*
name|ph
init|=
operator|(
expr|struct
name|cbb_pcic_handle
operator|*
operator|)
name|pch
decl_stmt|;
name|bus_addr_t
name|busaddr
decl_stmt|;
name|long
name|card_offset
decl_stmt|;
name|int
name|win
decl_stmt|;
for|for
control|(
name|win
operator|=
literal|0
init|;
name|win
operator|<
name|PCIC_MEM_WINS
condition|;
operator|++
name|win
control|)
block|{
if|if
condition|(
operator|(
name|ph
operator|->
name|memalloc
operator|&
operator|(
literal|1
operator|<<
name|win
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
name|ph
operator|->
name|memalloc
operator||=
operator|(
literal|1
operator|<<
name|win
operator|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|win
operator|==
name|PCIC_MEM_WINS
condition|)
block|{
return|return
literal|1
return|;
block|}
operator|*
name|windowp
operator|=
name|win
expr_stmt|;
comment|/* XXX this is pretty gross */
if|if
condition|(
name|ph
operator|->
name|sc
operator|->
name|sc_memt
operator|!=
name|pcmhp
operator|->
name|memt
condition|)
block|{
name|panic
argument_list|(
literal|"pccbb_pcmcia_mem_map memt is bogus"
argument_list|)
expr_stmt|;
block|}
name|busaddr
operator|=
name|pcmhp
operator|->
name|addr
expr_stmt|;
comment|/*      * compute the address offset to the pcmcia address space for the      * pcic.  this is intentionally signed.  The masks and shifts below      * will cause TRT to happen in the pcic registers.  Deal with making      * sure the address is aligned, and return the alignment offset.      */
operator|*
name|offsetp
operator|=
name|card_addr
operator|%
name|PCIC_MEM_PAGESIZE
expr_stmt|;
name|card_addr
operator|-=
operator|*
name|offsetp
expr_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"pccbb_pcmcia_mem_map window %d bus %lx+%lx+%lx at card addr "
literal|"%lx\n"
operator|,
name|win
operator|,
operator|(
name|u_long
operator|)
name|busaddr
operator|,
operator|(
name|u_long
operator|)
operator|*
name|offsetp
operator|,
operator|(
name|u_long
operator|)
name|size
operator|,
operator|(
name|u_long
operator|)
name|card_addr
operator|)
argument_list|)
expr_stmt|;
comment|/*      * include the offset in the size, and decrement size by one, since      * the hw wants start/stop      */
name|size
operator|+=
operator|*
name|offsetp
operator|-
literal|1
expr_stmt|;
name|card_offset
operator|=
operator|(
operator|(
operator|(
name|long
operator|)
name|card_addr
operator|)
operator|-
operator|(
operator|(
name|long
operator|)
name|busaddr
operator|)
operator|)
expr_stmt|;
name|ph
operator|->
name|mem
index|[
name|win
index|]
operator|.
name|addr
operator|=
name|busaddr
expr_stmt|;
name|ph
operator|->
name|mem
index|[
name|win
index|]
operator|.
name|size
operator|=
name|size
expr_stmt|;
name|ph
operator|->
name|mem
index|[
name|win
index|]
operator|.
name|offset
operator|=
name|card_offset
expr_stmt|;
name|ph
operator|->
name|mem
index|[
name|win
index|]
operator|.
name|kind
operator|=
name|kind
expr_stmt|;
name|pccbb_pcmcia_do_mem_map
argument_list|(
name|ph
argument_list|,
name|win
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/********************************************************************** * STATIC int pccbb_pcmcia_mem_unmap(pcmcia_chipset_handle_t pch, *                                   int window) * * This function unmaps memory space which mapped by the fuction * pccbb_pcmcia_mem_map(). **********************************************************************/
end_comment

begin_function
name|STATIC
name|void
name|pccbb_pcmcia_mem_unmap
parameter_list|(
name|pch
parameter_list|,
name|window
parameter_list|)
name|pcmcia_chipset_handle_t
name|pch
decl_stmt|;
name|int
name|window
decl_stmt|;
block|{
name|struct
name|cbb_pcic_handle
modifier|*
name|ph
init|=
operator|(
expr|struct
name|cbb_pcic_handle
operator|*
operator|)
name|pch
decl_stmt|;
name|int
name|reg
decl_stmt|;
if|if
condition|(
name|window
operator|>=
name|PCIC_MEM_WINS
condition|)
block|{
name|panic
argument_list|(
literal|"pccbb_pcmcia_mem_unmap: window out of range"
argument_list|)
expr_stmt|;
block|}
name|reg
operator|=
name|Pcic_read
argument_list|(
name|ph
argument_list|,
name|PCIC_ADDRWIN_ENABLE
argument_list|)
expr_stmt|;
name|reg
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|window
operator|)
expr_stmt|;
name|Pcic_write
argument_list|(
name|ph
argument_list|,
name|PCIC_ADDRWIN_ENABLE
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|ph
operator|->
name|memalloc
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|window
operator|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
name|PCCBB_PCMCIA_POLL
end_if

begin_struct
struct|struct
name|pccbb_poll_str
block|{
name|void
modifier|*
name|arg
decl_stmt|;
name|int
argument_list|(
argument|* func
argument_list|)
name|__P
argument_list|(
operator|(
name|void
operator|*
operator|)
argument_list|)
expr_stmt|;
name|int
name|level
decl_stmt|;
name|struct
name|cbb_pcic_handle
modifier|*
name|ph
decl_stmt|;
name|int
name|count
decl_stmt|;
name|int
name|num
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|pccbb_poll_str
name|pccbb_poll
index|[
literal|10
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|pccbb_poll_n
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|pccbb_pcmcia_poll
name|__P
argument_list|(
operator|(
name|void
operator|*
name|arg
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|pccbb_pcmcia_poll
parameter_list|(
name|arg
parameter_list|)
name|void
modifier|*
name|arg
decl_stmt|;
block|{
name|struct
name|pccbb_poll_str
modifier|*
name|poll
init|=
name|arg
decl_stmt|;
name|struct
name|cbb_pcic_handle
modifier|*
name|ph
init|=
name|poll
operator|->
name|ph
decl_stmt|;
name|struct
name|pccbb_softc
modifier|*
name|sc
init|=
name|ph
operator|->
name|sc
decl_stmt|;
name|int
name|s
decl_stmt|;
name|u_int32_t
name|spsr
decl_stmt|;
comment|/* socket present-state reg */
name|timeout
argument_list|(
name|pccbb_pcmcia_poll
argument_list|,
name|arg
argument_list|,
name|hz
operator|*
literal|2
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|poll
operator|->
name|level
condition|)
block|{
case|case
name|IPL_NET
case|:
name|s
operator|=
name|splnet
argument_list|()
expr_stmt|;
break|break;
case|case
name|IPL_BIO
case|:
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
break|break;
case|case
name|IPL_TTY
case|:
comment|/* fallthrough */
default|default:
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
break|break;
block|}
name|spsr
operator|=
name|bus_space_read_4
argument_list|(
name|sc
operator|->
name|sc_base_memt
argument_list|,
name|sc
operator|->
name|sc_base_memh
argument_list|,
name|CB_SOCKET_STAT
argument_list|)
expr_stmt|;
comment|//  printf("pccbb_pcmcia_poll: socket 0x%08x\n", spsr);
if|#
directive|if
name|defined
name|PCCBB_PCMCIA_POLL_ONLY
operator|&&
name|defined
name|LEVEL2
if|if
condition|(
operator|!
operator|(
name|spsr
operator|&
literal|0x40
operator|)
condition|)
comment|/* CINT low */
else|#
directive|else
if|if
condition|(
literal|1
condition|)
endif|#
directive|endif
block|{
if|if
condition|(
call|(
modifier|*
name|poll
operator|->
name|func
call|)
argument_list|(
name|poll
operator|->
name|arg
argument_list|)
operator|>
literal|0
condition|)
block|{
operator|++
name|poll
operator|->
name|count
expr_stmt|;
comment|//	printf("intr: reported from poller, 0x%x\n", spsr);
if|#
directive|if
name|defined
name|LEVEL2
block|}
else|else
block|{
name|printf
argument_list|(
literal|"intr: miss! 0x%x\n"
argument_list|,
name|spsr
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* defined CB_PCMCIA_POLL */
end_comment

begin_comment
comment|/********************************************************************** * STATIC void *pccbb_pcmcia_intr_establish(pcmcia_chipset_handle_t pch, *                                          struct pcmcia_function *pf, *                                          int ipl, *                                          int (*func)(void *), *                                          void *arg); * * This function enables PC-Card interrupt.  PCCBB uses PCI interrupt line. **********************************************************************/
end_comment

begin_function_decl
name|STATIC
name|void
modifier|*
name|pccbb_pcmcia_intr_establish
parameter_list|(
name|pch
parameter_list|,
name|pf
parameter_list|,
name|ipl
parameter_list|,
name|func
parameter_list|,
name|arg
parameter_list|)
name|pcmcia_chipset_handle_t
name|pch
decl_stmt|;
name|struct
name|pcmcia_function
modifier|*
name|pf
decl_stmt|;
name|int
name|ipl
decl_stmt|;
function_decl|int
parameter_list|(
function_decl|*func
end_function_decl

begin_expr_stmt
unit|)
name|__P
argument_list|(
operator|(
name|void
operator|*
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|void
modifier|*
name|arg
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|cbb_pcic_handle
modifier|*
name|ph
init|=
operator|(
expr|struct
name|cbb_pcic_handle
operator|*
operator|)
name|pch
decl_stmt|;
name|struct
name|pccbb_softc
modifier|*
name|sc
init|=
name|ph
operator|->
name|sc
decl_stmt|;
name|pci_intr_handle_t
name|handle
decl_stmt|;
name|void
modifier|*
name|ih
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|pf
operator|->
name|cfe
operator|->
name|flags
operator|&
name|PCMCIA_CFE_IRQLEVEL
operator|)
condition|)
block|{
comment|/* what should I do? */
if|if
condition|(
operator|(
name|pf
operator|->
name|cfe
operator|->
name|flags
operator|&
name|PCMCIA_CFE_IRQLEVEL
operator|)
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"%s does not provide edge nor pulse interrupt\n"
operator|,
name|sc
operator|->
name|sc_dev
operator|.
name|dv_xname
operator|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* XXX Noooooo!  The interrupt flag must set properly!! */
comment|/* dumb pcmcia driver!! */
block|}
if|if
condition|(
name|pci_intr_map
argument_list|(
name|sc
operator|->
name|sc_pc
argument_list|,
name|sc
operator|->
name|sc_intrtag
argument_list|,
name|sc
operator|->
name|sc_intrpin
argument_list|,
name|sc
operator|->
name|sc_intrline
argument_list|,
operator|&
name|handle
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"%s: couldn't map interrupt\n"
argument_list|,
name|sc
operator|->
name|sc_dev
operator|.
name|dv_xname
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|DPRINTF
argument_list|(
operator|(
literal|"pccbb_pcmcia_intr_establish: line %d, handle %d\n"
operator|,
name|sc
operator|->
name|sc_intrline
operator|,
name|handle
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|!=
operator|(
name|ih
operator|=
name|pci_intr_establish
argument_list|(
name|sc
operator|->
name|sc_pc
argument_list|,
name|handle
argument_list|,
name|ipl
argument_list|,
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
name|void
operator|*
argument_list|)
operator|)
name|func
argument_list|,
name|arg
argument_list|)
operator|)
condition|)
block|{
name|u_int32_t
name|cbctrl
decl_stmt|;
if|if
condition|(
operator|(
name|CB_TI113X
operator|==
name|sc
operator|->
name|sc_chipset
operator|)
condition|)
block|{
name|cbctrl
operator|=
name|pci_conf_read
argument_list|(
name|sc
operator|->
name|sc_pc
argument_list|,
name|sc
operator|->
name|sc_tag
argument_list|,
name|PCI_CBCTRL
argument_list|)
expr_stmt|;
name|cbctrl
operator||=
name|PCI113X_CBCTRL_PCI_INTR
expr_stmt|;
comment|/* PCI functional intr req */
name|pci_conf_write
argument_list|(
name|sc
operator|->
name|sc_pc
argument_list|,
name|sc
operator|->
name|sc_tag
argument_list|,
name|PCI_CBCTRL
argument_list|,
name|cbctrl
argument_list|)
expr_stmt|;
block|}
block|}
if|#
directive|if
name|defined
name|PCCBB_PCMCIA_POLL
if|if
condition|(
name|pccbb_poll_n
operator|<
literal|10
condition|)
block|{
name|pccbb_poll
index|[
name|pccbb_poll_n
index|]
operator|.
name|arg
operator|=
name|arg
expr_stmt|;
name|pccbb_poll
index|[
name|pccbb_poll_n
index|]
operator|.
name|func
operator|=
name|func
expr_stmt|;
name|pccbb_poll
index|[
name|pccbb_poll_n
index|]
operator|.
name|level
operator|=
name|ipl
expr_stmt|;
name|pccbb_poll
index|[
name|pccbb_poll_n
index|]
operator|.
name|count
operator|=
literal|0
expr_stmt|;
name|pccbb_poll
index|[
name|pccbb_poll_n
index|]
operator|.
name|num
operator|=
name|pccbb_poll_n
expr_stmt|;
name|pccbb_poll
index|[
name|pccbb_poll_n
index|]
operator|.
name|ph
operator|=
name|ph
expr_stmt|;
name|timeout
argument_list|(
name|pccbb_pcmcia_poll
argument_list|,
operator|&
name|pccbb_poll
index|[
name|pccbb_poll_n
operator|++
index|]
argument_list|,
name|hz
operator|*
literal|2
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"polling set\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|#
directive|if
name|defined
name|SHOW_REGS
name|cb_show_regs
argument_list|(
name|sc
operator|->
name|sc_pc
argument_list|,
name|sc
operator|->
name|sc_tag
argument_list|,
name|sc
operator|->
name|sc_base_memt
argument_list|,
name|sc
operator|->
name|sc_base_memh
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|ih
return|;
block|}
end_block

begin_comment
comment|/********************************************************************** * STATIC void pccbb_pcmcia_intr_disestablish(pcmcia_chipset_handle_t pch, *                                            void *ih) * * This function disables PC-Card interrupt. **********************************************************************/
end_comment

begin_function
name|STATIC
name|void
name|pccbb_pcmcia_intr_disestablish
parameter_list|(
name|pch
parameter_list|,
name|ih
parameter_list|)
name|pcmcia_chipset_handle_t
name|pch
decl_stmt|;
name|void
modifier|*
name|ih
decl_stmt|;
block|{
name|struct
name|cbb_pcic_handle
modifier|*
name|ph
init|=
operator|(
expr|struct
name|cbb_pcic_handle
operator|*
operator|)
name|pch
decl_stmt|;
name|struct
name|pccbb_softc
modifier|*
name|sc
init|=
name|ph
operator|->
name|sc
decl_stmt|;
name|pci_intr_disestablish
argument_list|(
name|sc
operator|->
name|sc_pc
argument_list|,
name|ih
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|pccbb_pcmcia_submatch
parameter_list|(
name|parent
parameter_list|,
name|cf
parameter_list|,
name|aux
parameter_list|)
name|struct
name|device
modifier|*
name|parent
decl_stmt|;
name|struct
name|cfdata
modifier|*
name|cf
decl_stmt|;
name|void
modifier|*
name|aux
decl_stmt|;
block|{
name|struct
name|pcmciabus_attach_args
modifier|*
name|paa
init|=
name|aux
decl_stmt|;
name|struct
name|cbb_pcic_handle
modifier|*
name|ph
init|=
operator|(
expr|struct
name|cbb_pcic_handle
operator|*
operator|)
name|paa
operator|->
name|pch
decl_stmt|;
if|if
condition|(
name|cf
operator|->
name|cf_loc
index|[
name|PCMCIABUSCF_CONTROLLER
index|]
operator|!=
name|PCMCIABUSCF_CONTROLLER_DEFAULT
operator|&&
name|cf
operator|->
name|cf_loc
index|[
name|PCMCIABUSCF_CONTROLLER
index|]
operator|!=
literal|0
condition|)
block|{
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|(
name|cf
operator|->
name|cf_loc
index|[
name|PCMCIABUSCF_CONTROLLER
index|]
operator|==
name|PCMCIABUSCF_CONTROLLER_DEFAULT
operator|)
operator|||
name|cf
operator|->
name|cf_loc
index|[
name|PCMCIABUSCF_CONTROLLER
index|]
operator|!=
name|ph
operator|->
name|sock
condition|)
block|{
return|return
operator|(
call|(
modifier|*
name|cf
operator|->
name|cf_attach
operator|->
name|ca_match
call|)
argument_list|(
name|parent
argument_list|,
name|cf
argument_list|,
name|aux
argument_list|)
operator|)
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pccbb_pcmcia_print
parameter_list|(
name|arg
parameter_list|,
name|pnp
parameter_list|)
name|void
modifier|*
name|arg
decl_stmt|;
specifier|const
name|char
modifier|*
name|pnp
decl_stmt|;
block|{
name|struct
name|pcmciabus_attach_args
modifier|*
name|paa
init|=
name|arg
decl_stmt|;
name|struct
name|cbb_pcic_handle
modifier|*
name|ph
init|=
operator|(
expr|struct
name|cbb_pcic_handle
operator|*
operator|)
name|paa
operator|->
name|pch
decl_stmt|;
if|if
condition|(
name|pnp
condition|)
block|{
name|printf
argument_list|(
literal|"pcmcia at %s"
argument_list|,
name|pnp
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|" slot %d"
argument_list|,
name|ph
operator|->
name|sock
argument_list|)
expr_stmt|;
return|return
name|UNCONF
return|;
block|}
end_function

begin_function
name|STATIC
name|int
name|cbbprint
parameter_list|(
name|aux
parameter_list|,
name|pcic
parameter_list|)
name|void
modifier|*
name|aux
decl_stmt|;
specifier|const
name|char
modifier|*
name|pcic
decl_stmt|;
block|{
comment|/*   struct cbslot_attach_args *cba = aux;    if (cba->cba_slot>= 0) {   printf(" slot %d", cba->cba_slot);   } */
return|return
name|UNCONF
return|;
block|}
end_function

end_unit

