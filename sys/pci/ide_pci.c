begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright 1996 Massachusetts Institute of Technology  *  * Permission to use, copy, modify, and distribute this software and  * its documentation for any purpose and without fee is hereby  * granted, provided that both the above copyright notice and this  * permission notice appear in all copies, that both the above  * copyright notice and this permission notice appear in all  * supporting documentation, and that the name of M.I.T. not be used  * in advertising or publicity pertaining to distribution of the  * software without specific, written prior permission.  M.I.T. makes  * no representations about the suitability of this software for any  * purpose.  It is provided "as is" without express or implied  * warranty.  *   * THIS SOFTWARE IS PROVIDED BY M.I.T. ``AS IS''.  M.I.T. DISCLAIMS  * ALL EXPRESS OR IMPLIED WARRANTIES WITH REGARD TO THIS SOFTWARE,  * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF  * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT  * SHALL M.I.T. BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF  * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,  * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT  * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *	From: wd82371.c,v 1.5.2.1 1996/11/16 21:19:51 phk Exp $  *	$Id: ide_pci.c,v 1.1 1997/07/29 12:57:09 sos Exp $  */
end_comment

begin_include
include|#
directive|include
file|"pci.h"
end_include

begin_if
if|#
directive|if
name|NPCI
operator|>
literal|0
end_if

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/buf.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/wdreg.h>
end_include

begin_include
include|#
directive|include
file|<pci/pcivar.h>
end_include

begin_include
include|#
directive|include
file|<pci/pcireg.h>
end_include

begin_include
include|#
directive|include
file|<pci/ide_pcireg.h>
end_include

begin_struct_decl
struct_decl|struct
name|ide_pci_cookie
struct_decl|;
end_struct_decl

begin_comment
comment|/* structs vendor_fns, ide_pci_cookie are recursive */
end_comment

begin_struct
struct|struct
name|vendor_fns
block|{
name|int
function_decl|(
modifier|*
name|vendor_dmainit
function_decl|)
comment|/* initialize DMA controller and drive */
parameter_list|(
name|struct
name|ide_pci_cookie
modifier|*
name|cookie
parameter_list|,
name|struct
name|wdparams
modifier|*
name|wp
parameter_list|,
name|int
function_decl|(
modifier|*
name|wdcmd
function_decl|)
parameter_list|(
name|int
parameter_list|,
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
name|void
function_decl|(
modifier|*
name|vendor_status
function_decl|)
comment|/* prints off DMA timing info */
parameter_list|(
name|int
name|iobase_wd
parameter_list|,
name|int
name|unit
parameter_list|,
name|int
name|iobase_bm
parameter_list|,
name|pcici_t
name|tag
parameter_list|,
name|pcidi_t
name|type
parameter_list|)
function_decl|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * XXX the fact that this list keeps all kinds of info on PCI controllers  * is pretty grotty-- much of this should be replaced by a proper integration  * of PCI probes into the wd driver.  * XXX if we're going to support native-PCI controllers, we also need to  * keep the address of the IDE control block register, which is something wd.c  * needs to know, which is why this info is in the wrong place.  */
end_comment

begin_struct
struct|struct
name|ide_pci_cookie
block|{
name|LIST_ENTRY
argument_list|(
argument|ide_pci_cookie
argument_list|)
name|le
expr_stmt|;
name|int
name|iobase_wd
decl_stmt|;
name|int
name|unit
decl_stmt|;
name|int
name|iobase_bm
decl_stmt|;
comment|/* SFF-8038 control registers */
name|pcici_t
name|tag
decl_stmt|;
name|pcidi_t
name|type
decl_stmt|;
name|struct
name|ide_pci_prd
modifier|*
name|prd
decl_stmt|;
name|struct
name|vendor_fns
name|vs
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|ide_pci_softc
block|{
name|LIST_HEAD
argument_list|(
argument_list|,
argument|ide_pci_cookie
argument_list|)
name|cookies
expr_stmt|;
block|}
struct|;
end_struct

begin_function_decl
specifier|static
name|int
name|generic_dmainit
parameter_list|(
name|struct
name|ide_pci_cookie
modifier|*
name|cookie
parameter_list|,
name|struct
name|wdparams
modifier|*
name|wp
parameter_list|,
name|int
function_decl|(
modifier|*
name|wdcmd
function_decl|)
parameter_list|(
name|int
parameter_list|,
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
name|wdinfo
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|generic_status
parameter_list|(
name|int
name|iobase_wd
parameter_list|,
name|int
name|unit
parameter_list|,
name|int
name|iobase_bm
parameter_list|,
name|pcici_t
name|tag
parameter_list|,
name|pcidi_t
name|type
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|via_571_status
parameter_list|(
name|int
name|iobase_wd
parameter_list|,
name|int
name|unit
parameter_list|,
name|int
name|iobase_bm
parameter_list|,
name|pcici_t
name|tag
parameter_list|,
name|pcidi_t
name|type
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|intel_piix_dump_drive
parameter_list|(
name|char
modifier|*
name|ctlr
parameter_list|,
name|int
name|sitre
parameter_list|,
name|int
name|word40
parameter_list|,
name|int
name|word44
parameter_list|,
name|int
name|drive
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|intel_piix_status
parameter_list|(
name|int
name|iobase_wd
parameter_list|,
name|int
name|unit
parameter_list|,
name|int
name|iobase_bm
parameter_list|,
name|pcici_t
name|tag
parameter_list|,
name|pcidi_t
name|type
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|ide_pci_cookie
modifier|*
name|mkcookie
parameter_list|(
name|int
name|iobase_wd
parameter_list|,
name|int
name|unit
parameter_list|,
name|int
name|iobase_bm
parameter_list|,
name|pcici_t
name|tag
parameter_list|,
name|pcidi_t
name|type
parameter_list|,
name|struct
name|vendor_fns
modifier|*
name|vp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ide_pci_attach
parameter_list|(
name|pcici_t
name|tag
parameter_list|,
name|int
name|unit
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
modifier|*
name|ide_pci_candma
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ide_pci_dmainit
parameter_list|(
name|void
modifier|*
parameter_list|,
name|struct
name|wdparams
modifier|*
parameter_list|,
name|int
function_decl|(
modifier|*
function_decl|)
parameter_list|(
name|int
parameter_list|,
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ide_pci_dmaverify
parameter_list|(
name|void
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|u_long
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ide_pci_dmasetup
parameter_list|(
name|void
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|u_long
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ide_pci_dmastart
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ide_pci_dmadone
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ide_pci_status
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ide_pci_timing
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|struct
name|ide_pci_softc
name|softc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ide_pci_softc_cookies_initted
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * PRD_ALLOC_SIZE should be something that will not be allocated across a 64k  * boundary.  * PRD_MAX_SEGS is defined to be the maximum number of segments required for  * a transfer on an IDE drive, for an xfer that is linear in virtual memory.  * PRD_BUF_SIZE is the size of the buffer needed for a PRD table.  */
end_comment

begin_define
define|#
directive|define
name|PRD_ALLOC_SIZE
value|PAGE_SIZE
end_define

begin_define
define|#
directive|define
name|PRD_MAX_SEGS
value|((256 * 512 / PAGE_SIZE) + 1)
end_define

begin_define
define|#
directive|define
name|PRD_BUF_SIZE
value|PRD_MAX_SEGS * 8
end_define

begin_decl_stmt
specifier|static
name|void
modifier|*
name|prdbuf
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
modifier|*
name|prdbuf_next
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*   * Hardware specific IDE controller code.  All vendor-specific code  * for handling IDE timing and other chipset peculiarities should be  * encapsulated here.  */
end_comment

begin_comment
comment|/* Generic busmastering PCI-IDE */
end_comment

begin_function
specifier|static
name|int
name|generic_dmainit
parameter_list|(
name|struct
name|ide_pci_cookie
modifier|*
name|cookie
parameter_list|,
name|struct
name|wdparams
modifier|*
name|wp
parameter_list|,
name|int
function_decl|(
modifier|*
name|wdcmd
function_decl|)
parameter_list|(
name|int
parameter_list|,
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
name|wdinfo
parameter_list|)
block|{
name|int
name|mode
decl_stmt|,
name|r
decl_stmt|;
comment|/*      * XXX punt on the whole timing issue by looking for either a      * drive programmed for both PIO4 and mDMA2 (which use similar      * timing) or a drive in an UltraDMA mode (hopefully all      * controllers have separate timing for UDMA).  one hopes that if      * the drive's DMA mode has been configured by the BIOS, the      * controller's has also.  this code may eventually be replaced      * by gunk in the hw-specific code to deal with specific      * controllers.      */
comment|/* XXX way too sick and twisted conditional */
if|if
condition|(
operator|!
operator|(
operator|(
operator|(
operator|(
name|wp
operator|->
name|wdp_atavalid
operator|&
literal|2
operator|)
operator|==
literal|2
operator|)
operator|&&
operator|(
operator|(
name|wp
operator|->
name|wdp_dmamword
operator|&
literal|0x404
operator|)
operator|==
literal|0x404
operator|)
operator|&&
operator|(
operator|(
name|wp
operator|->
name|wdp_eidepiomodes
operator|&
literal|2
operator|)
operator|==
literal|2
operator|)
operator|)
operator|||
operator|(
operator|(
operator|(
name|wp
operator|->
name|wdp_atavalid
operator|&
literal|4
operator|)
operator|==
literal|4
operator|)
operator|&&
operator|(
name|wp
operator|->
name|wdp_udmamode
operator|==
literal|4
operator|)
operator|)
operator|)
condition|)
return|return
literal|0
return|;
if|#
directive|if
literal|0
comment|/*      * XXX flesh this out into real code that actually      * does something-- this was just testing gunk.      */
block|if (((wp->wdp_atavalid& 0x4) == 0x4)&& 	(wp->wdp_udmamode == 4)) { 	printf("UDMA mode\n"); 	mode = 0x42;
comment|/* XXX where's the #defines... */
block|}     else { 	printf("MDMA mode\n"); 	mode = 0x24;     }      r = wdcmd(mode, wdinfo);     printf("dmainit out like we expect\n");     if (!r) 	return 0;
endif|#
directive|endif
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|generic_status
parameter_list|(
name|int
name|iobase_wd
parameter_list|,
name|int
name|unit
parameter_list|,
name|int
name|iobase_bm
parameter_list|,
name|pcici_t
name|tag
parameter_list|,
name|pcidi_t
name|type
parameter_list|)
block|{
name|printf
argument_list|(
literal|"generic_status: no PCI IDE timing info available\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|vendor_fns
name|vs_generic
init|=
block|{
name|generic_dmainit
block|,
name|generic_status
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* VIA Technologies "82C571" PCI-IDE controller core */
end_comment

begin_function
specifier|static
name|void
name|via_571_status
parameter_list|(
name|int
name|iobase_wd
parameter_list|,
name|int
name|unit
parameter_list|,
name|int
name|iobase_bm
parameter_list|,
name|pcici_t
name|tag
parameter_list|,
name|pcidi_t
name|type
parameter_list|)
block|{
name|unsigned
name|int
name|word40
index|[
literal|5
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* XXX how to handle four calls for one controller? */
if|if
condition|(
name|iobase_wd
operator|!=
literal|0x1f0
operator|||
name|unit
operator|!=
literal|0
condition|)
return|return;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|5
condition|;
name|i
operator|++
control|)
block|{
name|word40
index|[
name|i
index|]
operator|=
name|pci_conf_read
argument_list|(
name|tag
argument_list|,
name|i
operator|*
literal|4
operator|+
literal|0x40
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"via_571_status: Primary IDE prefetch/postwrite %s/%s\n"
argument_list|,
name|word40
index|[
literal|0
index|]
operator|&
literal|0x8000
condition|?
literal|"enabled"
else|:
literal|"disabled"
argument_list|,
name|word40
index|[
literal|0
index|]
operator|&
literal|0x4000
condition|?
literal|"enabled"
else|:
literal|"disabled"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"via_571_status: Secondary IDE prefetch/postwrite %s/%s\n"
argument_list|,
name|word40
index|[
literal|0
index|]
operator|&
literal|0x2000
condition|?
literal|"enabled"
else|:
literal|"disabled"
argument_list|,
name|word40
index|[
literal|0
index|]
operator|&
literal|0x1000
condition|?
literal|"enabled"
else|:
literal|"disabled"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"via_571_status: Master %d read/%d write IRDY# wait states\n"
argument_list|,
operator|(
name|word40
index|[
literal|1
index|]
operator|&
literal|0x40
operator|)
operator|>>
literal|6
argument_list|,
operator|(
name|word40
index|[
literal|1
index|]
operator|&
literal|0x20
operator|)
operator|>>
literal|5
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"via_571_status: busmaster status read retry %s\n"
argument_list|,
operator|(
name|word40
index|[
literal|1
index|]
operator|&
literal|0x10
operator|)
condition|?
literal|"enabled"
else|:
literal|"disabled"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|"via_571_status: %s drive %d setup=%d active=%d recovery=%d\n"
argument_list|,
name|i
operator|<
literal|2
condition|?
literal|"primary"
else|:
literal|"secondary"
argument_list|,
name|i
operator|&
literal|1
argument_list|,
operator|(
operator|(
name|word40
index|[
literal|3
index|]
operator|>>
operator|(
operator|(
literal|3
operator|-
name|i
operator|)
operator|*
literal|2
operator|)
operator|)
operator|&
literal|3
operator|)
operator|+
literal|1
argument_list|,
operator|(
operator|(
name|word40
index|[
literal|2
index|]
operator|>>
operator|(
operator|(
operator|(
literal|3
operator|-
name|i
operator|)
operator|*
literal|8
operator|)
operator|+
literal|4
operator|)
operator|)
operator|&
literal|0x0f
operator|)
operator|+
literal|1
argument_list|,
operator|(
operator|(
name|word40
index|[
literal|2
index|]
operator|>>
operator|(
operator|(
literal|3
operator|-
name|i
operator|)
operator|*
literal|8
operator|)
operator|)
operator|&
literal|0x0f
operator|)
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* XXX could go on and do UDMA status for '586B */
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|vendor_fns
name|vs_via_571
init|=
block|{
name|generic_dmainit
block|,
name|via_571_status
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Intel PIIX, PIIX3, and PIIX4 IDE controller subfunctions */
end_comment

begin_function
specifier|static
name|void
name|intel_piix_dump_drive
parameter_list|(
name|char
modifier|*
name|ctlr
parameter_list|,
name|int
name|sitre
parameter_list|,
name|int
name|word40
parameter_list|,
name|int
name|word44
parameter_list|,
name|int
name|drive
parameter_list|)
block|{
name|char
modifier|*
name|ms
decl_stmt|;
if|if
condition|(
operator|!
name|sitre
condition|)
name|ms
operator|=
literal|"master/slave"
expr_stmt|;
elseif|else
if|if
condition|(
name|drive
operator|==
literal|0
condition|)
name|ms
operator|=
literal|"master"
expr_stmt|;
else|else
name|ms
operator|=
literal|"slave"
expr_stmt|;
if|if
condition|(
name|sitre
operator|||
name|drive
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"intel_piix_status: %s %s sample = %d, %s recovery = %d\n"
argument_list|,
name|ctlr
argument_list|,
name|ms
argument_list|,
literal|5
operator|-
operator|(
operator|(
name|sitre
operator|&&
name|drive
operator|)
condition|?
operator|(
operator|(
name|word44
operator|>>
literal|2
operator|)
operator|&
literal|3
operator|)
else|:
operator|(
operator|(
name|word40
operator|>>
literal|12
operator|)
operator|&
literal|3
operator|)
operator|)
argument_list|,
name|ms
argument_list|,
literal|4
operator|-
operator|(
operator|(
name|sitre
operator|&&
name|drive
operator|)
condition|?
operator|(
operator|(
name|word44
operator|>>
literal|0
operator|)
operator|&
literal|3
operator|)
else|:
operator|(
operator|(
name|word40
operator|>>
literal|8
operator|)
operator|&
literal|3
operator|)
operator|)
argument_list|)
expr_stmt|;
name|word40
operator|>>=
operator|(
name|drive
operator|*
literal|4
operator|)
expr_stmt|;
name|printf
argument_list|(
literal|"\ intel_piix_status: %s %s fastDMAonly %s, pre/post %s,\n\ intel_piix_status:  IORDY sampling %s,\n\ intel_piix_status:  fast PIO %s%s\n"
argument_list|,
name|ctlr
argument_list|,
operator|(
name|drive
operator|==
literal|0
operator|)
condition|?
literal|"master"
else|:
literal|"slave"
argument_list|,
operator|(
name|word40
operator|&
literal|8
operator|)
condition|?
literal|"enabled"
else|:
literal|"disabled"
argument_list|,
operator|(
name|word40
operator|&
literal|4
operator|)
condition|?
literal|"enabled"
else|:
literal|"disabled"
argument_list|,
operator|(
name|word40
operator|&
literal|2
operator|)
condition|?
literal|"enabled"
else|:
literal|"disabled"
argument_list|,
operator|(
name|word40
operator|&
literal|1
operator|)
condition|?
literal|"enabled"
else|:
literal|"disabled"
argument_list|,
operator|(
operator|(
name|word40
operator|&
literal|9
operator|)
operator|==
literal|9
operator|)
condition|?
literal|" (overridden by fastDMAonly)"
else|:
literal|""
argument_list|)
expr_stmt|;
comment|/* XXX extend to dump 82371AB's UltraDMA modes */
block|}
end_function

begin_function
specifier|static
name|void
name|intel_piix_status
parameter_list|(
name|int
name|iobase_wd
parameter_list|,
name|int
name|unit
parameter_list|,
name|int
name|iobase_bm
parameter_list|,
name|pcici_t
name|tag
parameter_list|,
name|pcidi_t
name|type
parameter_list|)
block|{
name|unsigned
name|int
name|word40
decl_stmt|,
name|word44
decl_stmt|;
name|int
name|sitre
decl_stmt|;
comment|/* XXX how to handle four calls for one controller? */
if|if
condition|(
name|iobase_wd
operator|!=
literal|0x1f0
operator|||
name|unit
operator|!=
literal|0
condition|)
return|return;
name|word40
operator|=
name|pci_conf_read
argument_list|(
name|tag
argument_list|,
literal|0x40
argument_list|)
expr_stmt|;
name|word44
operator|=
name|pci_conf_read
argument_list|(
name|tag
argument_list|,
literal|0x44
argument_list|)
expr_stmt|;
name|sitre
operator|=
name|word40
operator|&
literal|0x4000
expr_stmt|;
name|intel_piix_dump_drive
argument_list|(
literal|"primary"
argument_list|,
name|sitre
argument_list|,
name|word40
operator|&
literal|0xffff
argument_list|,
name|word44
operator|&
literal|0x0f
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|intel_piix_dump_drive
argument_list|(
literal|"primary"
argument_list|,
name|sitre
argument_list|,
name|word40
operator|&
literal|0xffff
argument_list|,
name|word44
operator|&
literal|0x0f
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|intel_piix_dump_drive
argument_list|(
literal|"secondary"
argument_list|,
name|sitre
argument_list|,
operator|(
name|word40
operator|>>
literal|16
operator|)
operator|&
literal|0xffff
argument_list|,
operator|(
name|word44
operator|>>
literal|4
operator|)
operator|&
literal|0x0f
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|intel_piix_dump_drive
argument_list|(
literal|"secondary"
argument_list|,
name|sitre
argument_list|,
operator|(
name|word40
operator|>>
literal|16
operator|)
operator|&
literal|0xffff
argument_list|,
operator|(
name|word44
operator|>>
literal|4
operator|)
operator|&
literal|0x0f
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|vendor_fns
name|vs_intel_piix
init|=
block|{
name|generic_dmainit
block|,
name|intel_piix_status
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Generic SFF-8038i code-- all code below here, except for PCI probes,  * more or less conforms to the SFF-8038i spec as extended for PCI.  * There should be no code that goes beyond that feature set below.  */
end_comment

begin_comment
comment|/* XXX mkcookie is overloaded with too many parameters */
end_comment

begin_function
specifier|static
name|struct
name|ide_pci_cookie
modifier|*
name|mkcookie
parameter_list|(
name|int
name|iobase_wd
parameter_list|,
name|int
name|unit
parameter_list|,
name|int
name|iobase_bm
parameter_list|,
name|pcici_t
name|tag
parameter_list|,
name|pcidi_t
name|type
parameter_list|,
name|struct
name|vendor_fns
modifier|*
name|vp
parameter_list|)
block|{
name|struct
name|ide_pci_cookie
modifier|*
name|cp
decl_stmt|;
name|cp
operator|=
name|malloc
argument_list|(
sizeof|sizeof
expr|*
name|cp
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cp
condition|)
return|return
name|cp
return|;
name|cp
operator|->
name|iobase_wd
operator|=
name|iobase_wd
expr_stmt|;
name|cp
operator|->
name|unit
operator|=
name|unit
expr_stmt|;
name|cp
operator|->
name|tag
operator|=
name|tag
expr_stmt|;
name|cp
operator|->
name|type
operator|=
name|type
expr_stmt|;
name|cp
operator|->
name|iobase_bm
operator|=
name|iobase_bm
expr_stmt|;
name|bcopy
argument_list|(
name|vp
argument_list|,
operator|&
name|cp
operator|->
name|vs
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|vendor_fns
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|prdbuf
condition|)
block|{
name|prdbuf
operator|=
name|malloc
argument_list|(
name|PRD_ALLOC_SIZE
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|prdbuf
condition|)
block|{
name|FREE
argument_list|(
name|cp
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|(
operator|(
name|int
operator|)
name|prdbuf
operator|>>
name|PAGE_SHIFT
operator|)
operator|^
operator|(
operator|(
operator|(
name|int
operator|)
name|prdbuf
operator|+
name|PRD_ALLOC_SIZE
operator|-
literal|1
operator|)
operator|>>
name|PAGE_SHIFT
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"ide_pci: prdbuf straddles page boundary, no DMA"
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|cp
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|prdbuf
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|prdbuf_next
operator|=
name|prdbuf
expr_stmt|;
block|}
name|cp
operator|->
name|prd
operator|=
name|prdbuf_next
expr_stmt|;
operator|(
name|char
operator|*
operator|)
name|prdbuf_next
operator|+=
name|PRD_BUF_SIZE
expr_stmt|;
if|if
condition|(
operator|(
name|char
operator|*
operator|)
name|prdbuf_next
operator|>
operator|(
operator|(
name|char
operator|*
operator|)
name|prdbuf
operator|+
name|PRD_ALLOC_SIZE
operator|)
condition|)
name|panic
argument_list|(
literal|"ide_pci: too many prdbufs allocated"
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"ide_pci: mkcookie %04x:%d: PRD vstart = %08x vend = %08x\n"
argument_list|,
name|iobase_wd
argument_list|,
name|unit
argument_list|,
operator|(
name|int
operator|)
name|cp
operator|->
name|prd
argument_list|,
operator|(
operator|(
name|int
operator|)
name|cp
operator|->
name|prd
operator|)
operator|+
name|PRD_BUF_SIZE
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|softc
operator|.
name|cookies
argument_list|,
name|cp
argument_list|,
name|le
argument_list|)
expr_stmt|;
return|return
name|cp
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|ide_pci_probe
parameter_list|(
name|pcici_t
name|tag
parameter_list|,
name|pcidi_t
name|type
parameter_list|)
block|{
name|int
name|data
init|=
name|pci_conf_read
argument_list|(
name|tag
argument_list|,
name|PCI_CLASS_REG
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|data
operator|&
name|PCI_CLASS_MASK
condition|)
block|{
case|case
name|PCI_CLASS_MASS_STORAGE
case|:
if|if
condition|(
operator|(
name|data
operator|&
name|PCI_SUBCLASS_MASK
operator|)
operator|==
literal|0x00010000
condition|)
block|{
if|if
condition|(
name|type
operator|==
literal|0x71118086
condition|)
return|return
operator|(
literal|"Intel PIIX4 Bus-master IDE controller"
operator|)
return|;
if|if
condition|(
name|type
operator|==
literal|0x70108086
condition|)
return|return
operator|(
literal|"Intel PIIX3 Bus-master IDE controller"
operator|)
return|;
if|if
condition|(
name|type
operator|==
literal|0x12308086
condition|)
return|return
operator|(
literal|"Intel PIIX Bus-master IDE controller"
operator|)
return|;
if|if
condition|(
name|type
operator|==
literal|0x05711106
condition|)
return|return
operator|(
literal|"VIA 82C586x (Apollo) Bus-master IDE controller"
operator|)
return|;
if|if
condition|(
name|data
operator|&
literal|0x8000
condition|)
return|return
operator|(
literal|"PCI IDE controller (busmaster capable)"
operator|)
return|;
comment|/*  * XXX leave this out for now, to allow CMD640B hack to work.  said  * hack should be better integrated, or something.  */
if|#
directive|if
literal|0
block|else 		return ("PCI IDE controller (not busmaster capable)");
endif|#
directive|endif
block|}
block|}
empty_stmt|;
return|return
operator|(
operator|(
name|char
operator|*
operator|)
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ide_pci_attach
parameter_list|(
name|pcici_t
name|tag
parameter_list|,
name|int
name|unit
parameter_list|)
block|{
name|u_long
name|idetm
decl_stmt|;
name|int
name|class
decl_stmt|;
name|int
name|bmista
decl_stmt|;
name|int
name|iobase_wd
decl_stmt|,
name|iobase_bm
decl_stmt|;
name|int
name|cmd
decl_stmt|;
name|struct
name|vendor_fns
modifier|*
name|vp
decl_stmt|;
name|pcidi_t
name|type
decl_stmt|;
if|if
condition|(
name|unit
condition|)
return|return;
comment|/* is it busmaster capable?  bail if not */
name|class
operator|=
name|pci_conf_read
argument_list|(
name|tag
argument_list|,
name|PCI_CLASS_REG
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|class
operator|&
literal|0x8000
operator|)
condition|)
return|return;
comment|/* is it enabled and is busmastering turned on? */
name|cmd
operator|=
name|pci_conf_read
argument_list|(
name|tag
argument_list|,
name|PCI_COMMAND_STATUS_REG
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cmd
operator|&
literal|5
operator|)
operator|!=
literal|5
condition|)
return|return;
comment|/* set up vendor-specific stuff */
name|type
operator|=
name|pci_conf_read
argument_list|(
name|tag
argument_list|,
name|PCI_ID_REG
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
literal|0x71118086
case|:
case|case
literal|0x70108086
case|:
case|case
literal|0x12308086
case|:
comment|/* Intel PIIX, PIIX3, PIIX4 */
name|vp
operator|=
operator|&
name|vs_intel_piix
expr_stmt|;
break|break;
case|case
literal|0x5711106
case|:
comment|/* VIA Apollo chipset family */
name|vp
operator|=
operator|&
name|vs_via_571
expr_stmt|;
break|break;
default|default:
comment|/* everybody else */
name|vp
operator|=
operator|&
name|vs_generic
expr_stmt|;
break|break;
block|}
name|iobase_wd
operator|=
operator|(
name|class
operator|&
literal|0x100
operator|)
condition|?
operator|(
name|pci_conf_read
argument_list|(
name|tag
argument_list|,
literal|0x10
argument_list|)
operator|&
literal|0xfffc
operator|)
else|:
literal|0x1f0
expr_stmt|;
name|iobase_bm
operator|=
name|pci_conf_read
argument_list|(
name|tag
argument_list|,
literal|0x20
argument_list|)
operator|&
literal|0xfffc
expr_stmt|;
if|if
condition|(
operator|!
name|ide_pci_softc_cookies_initted
condition|)
block|{
name|LIST_INIT
argument_list|(
operator|&
name|softc
operator|.
name|cookies
argument_list|)
expr_stmt|;
name|ide_pci_softc_cookies_initted
operator|=
literal|1
expr_stmt|;
block|}
name|bmista
operator|=
name|inb
argument_list|(
name|iobase_bm
operator|+
name|BMISTA_PORT
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"ide_pci: busmaster 0 status: %02x from port: %08x\n"
argument_list|,
name|bmista
argument_list|,
name|iobase_bm
operator|+
name|BMISTA_PORT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|bmista
operator|&
name|BMISTA_DMA0CAP
operator|)
condition|)
name|printf
argument_list|(
literal|"ide_pci: warning, ide0:0 not configured for DMA?\n"
argument_list|)
expr_stmt|;
name|mkcookie
argument_list|(
name|iobase_wd
argument_list|,
literal|0
argument_list|,
name|iobase_bm
argument_list|,
name|tag
argument_list|,
name|type
argument_list|,
name|vp
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|vp
operator|->
name|vendor_status
argument_list|(
name|iobase_wd
argument_list|,
literal|0
argument_list|,
name|iobase_bm
argument_list|,
name|tag
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|bmista
operator|&
name|BMISTA_DMA1CAP
operator|)
condition|)
name|printf
argument_list|(
literal|"ide_pci: warning, ide0:1 not configured for DMA?\n"
argument_list|)
expr_stmt|;
name|mkcookie
argument_list|(
name|iobase_wd
argument_list|,
literal|1
argument_list|,
name|iobase_bm
argument_list|,
name|tag
argument_list|,
name|type
argument_list|,
name|vp
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|vp
operator|->
name|vendor_status
argument_list|(
name|iobase_wd
argument_list|,
literal|1
argument_list|,
name|iobase_bm
argument_list|,
name|tag
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|bmista
operator|&
name|BMISTA_SIMPLEX
condition|)
block|{
name|printf
argument_list|(
literal|"ide_pci: primary is simplex-only, no DMA on secondary\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|iobase_wd
operator|=
operator|(
name|class
operator|&
literal|0x400
operator|)
condition|?
operator|(
name|pci_conf_read
argument_list|(
name|tag
argument_list|,
literal|0x10
argument_list|)
operator|&
literal|0xfffc
operator|)
else|:
literal|0x170
expr_stmt|;
name|iobase_bm
operator|+=
name|SFF8038_CTLR_1
expr_stmt|;
name|bmista
operator|=
name|inb
argument_list|(
name|iobase_bm
operator|+
name|BMISTA_PORT
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"ide_pci: busmaster 1 status: %02x from port: %08x\n"
argument_list|,
name|bmista
argument_list|,
name|iobase_bm
operator|+
name|BMISTA_PORT
argument_list|)
expr_stmt|;
if|if
condition|(
name|bmista
operator|&
name|BMISTA_SIMPLEX
condition|)
block|{
name|printf
argument_list|(
literal|"ide_pci: secondary is simplex-only, no DMA on secondary\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
operator|(
name|bmista
operator|&
name|BMISTA_DMA0CAP
operator|)
condition|)
name|printf
argument_list|(
literal|"ide_pci: warning, ide1:0 not configured for DMA?\n"
argument_list|)
expr_stmt|;
name|mkcookie
argument_list|(
name|iobase_wd
argument_list|,
literal|0
argument_list|,
name|iobase_bm
argument_list|,
name|tag
argument_list|,
name|type
argument_list|,
name|vp
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|vp
operator|->
name|vendor_status
argument_list|(
name|iobase_wd
argument_list|,
literal|0
argument_list|,
name|iobase_bm
argument_list|,
name|tag
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|bmista
operator|&
name|BMISTA_DMA1CAP
operator|)
condition|)
name|printf
argument_list|(
literal|"ide_pci: warning, ide1:1 not configured for DMA?\n"
argument_list|)
expr_stmt|;
name|mkcookie
argument_list|(
name|iobase_wd
argument_list|,
literal|1
argument_list|,
name|iobase_bm
argument_list|,
name|tag
argument_list|,
name|type
argument_list|,
name|vp
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|vp
operator|->
name|vendor_status
argument_list|(
name|iobase_wd
argument_list|,
literal|1
argument_list|,
name|iobase_bm
argument_list|,
name|tag
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
block|}
name|wddma
operator|.
name|wdd_candma
operator|=
name|ide_pci_candma
expr_stmt|;
name|wddma
operator|.
name|wdd_dmainit
operator|=
name|ide_pci_dmainit
expr_stmt|;
name|wddma
operator|.
name|wdd_dmaverify
operator|=
name|ide_pci_dmaverify
expr_stmt|;
name|wddma
operator|.
name|wdd_dmaprep
operator|=
name|ide_pci_dmasetup
expr_stmt|;
name|wddma
operator|.
name|wdd_dmastart
operator|=
name|ide_pci_dmastart
expr_stmt|;
name|wddma
operator|.
name|wdd_dmadone
operator|=
name|ide_pci_dmadone
expr_stmt|;
name|wddma
operator|.
name|wdd_dmastatus
operator|=
name|ide_pci_status
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|u_long
name|ide_pci_count
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|pci_device
name|ide_pci_device
init|=
block|{
literal|"ide_pci"
block|,
name|ide_pci_probe
block|,
name|ide_pci_attach
block|,
operator|&
name|ide_pci_count
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DATA_SET
argument_list|(
name|pcidevice_set
argument_list|,
name|ide_pci_device
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Return a cookie if we can do DMA on the specified (iobase_wd, unit).  */
end_comment

begin_function
specifier|static
name|void
modifier|*
name|ide_pci_candma
parameter_list|(
name|int
name|iobase_wd
parameter_list|,
name|int
name|unit
parameter_list|)
block|{
name|struct
name|ide_pci_cookie
modifier|*
name|cp
decl_stmt|;
name|cp
operator|=
name|softc
operator|.
name|cookies
operator|.
name|lh_first
expr_stmt|;
while|while
condition|(
name|cp
condition|)
block|{
if|if
condition|(
name|cp
operator|->
name|unit
operator|==
name|unit
operator|&&
name|cp
operator|->
name|iobase_wd
operator|==
name|iobase_wd
condition|)
break|break;
name|cp
operator|=
name|cp
operator|->
name|le
operator|.
name|le_next
expr_stmt|;
block|}
return|return
name|cp
return|;
block|}
end_function

begin_comment
comment|/*  * Initialize controller and drive for DMA operation, including timing modes.  * Uses data passed from the wd driver and a callback function to initialize  * timing modes on the drive.  */
end_comment

begin_function
specifier|static
name|int
name|ide_pci_dmainit
parameter_list|(
name|void
modifier|*
name|cookie
parameter_list|,
name|struct
name|wdparams
modifier|*
name|wp
parameter_list|,
name|int
function_decl|(
modifier|*
name|wdcmd
function_decl|)
parameter_list|(
name|int
parameter_list|,
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
name|wdinfo
parameter_list|)
block|{
name|struct
name|ide_pci_cookie
modifier|*
name|cp
init|=
name|cookie
decl_stmt|;
return|return
operator|(
name|cp
operator|->
name|vs
operator|.
name|vendor_dmainit
argument_list|(
name|cp
argument_list|,
name|wp
argument_list|,
name|wdcmd
argument_list|,
name|wdinfo
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Verify that controller can handle a dma request for cp.  Should  * not affect any hardware or driver state.  */
end_comment

begin_function
specifier|static
name|int
name|ide_pci_dmaverify
parameter_list|(
name|void
modifier|*
name|xcp
parameter_list|,
name|char
modifier|*
name|vaddr
parameter_list|,
name|u_long
name|count
parameter_list|,
name|int
name|dir
parameter_list|)
block|{
name|int
name|badfu
decl_stmt|;
comment|/*      * check for nonaligned or odd-length Stuff      */
name|badfu
operator|=
operator|(
operator|(
name|unsigned
name|int
operator|)
name|vaddr
operator|&
literal|1
operator|)
operator|||
operator|(
name|count
operator|&
literal|1
operator|)
expr_stmt|;
if|#
directive|if
literal|1
if|if
condition|(
name|badfu
condition|)
block|{
name|printf
argument_list|(
literal|"ide_pci: dmaverify odd vaddr or length, "
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"vaddr = %08x length = %08x\n"
argument_list|,
operator|(
name|int
operator|)
name|vaddr
argument_list|,
name|count
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/*       * XXX should perhaps be checking that length of generated table      * does not exceed space available, but that Would Be Hairy       */
return|return
operator|(
operator|!
name|badfu
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Set up DMA for cp.  It is the responsibility of the caller  * to ensure that the controller is idle before this routine  * is called.  */
end_comment

begin_function
specifier|static
name|int
name|ide_pci_dmasetup
parameter_list|(
name|void
modifier|*
name|xcp
parameter_list|,
name|char
modifier|*
name|vaddr
parameter_list|,
name|u_long
name|count
parameter_list|,
name|int
name|dir
parameter_list|)
block|{
name|struct
name|ide_pci_cookie
modifier|*
name|cp
init|=
name|xcp
decl_stmt|;
name|struct
name|ide_pci_prd
modifier|*
name|prd
decl_stmt|;
name|int
name|i
decl_stmt|;
name|u_long
name|pgresid
decl_stmt|;
name|int
name|iobase_bm
decl_stmt|;
specifier|static
name|int
name|trashmore
decl_stmt|;
specifier|static
name|int
modifier|*
name|trashmore_p
init|=
literal|0
decl_stmt|;
name|prd
operator|=
name|cp
operator|->
name|prd
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
name|iobase_bm
operator|=
name|cp
operator|->
name|iobase_bm
expr_stmt|;
comment|/*      * ensure that 0-length transfers get a PRD that won't smash much      */
if|if
condition|(
operator|!
name|trashmore_p
condition|)
name|trashmore_p
operator|=
operator|(
name|void
operator|*
operator|)
name|vtophys
argument_list|(
operator|&
name|trashmore
argument_list|)
expr_stmt|;
name|prd
index|[
literal|0
index|]
operator|.
name|prd_base
operator|=
operator|(
name|unsigned
name|int
operator|)
name|trashmore_p
expr_stmt|;
name|prd
index|[
literal|0
index|]
operator|.
name|prd_count
operator|=
literal|0x80000002
expr_stmt|;
if|if
condition|(
name|count
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"ide_pci: dmasetup 0-length transfer, "
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"vaddr = %08x length = %08x\n"
argument_list|,
operator|(
name|int
operator|)
name|vaddr
argument_list|,
name|count
argument_list|)
expr_stmt|;
block|}
comment|/*       * XXX the PRD generation code is somewhat ugly and will not      * port easily to big endian systems.        *      * but it works.      */
comment|/*      * Deal with transfers that don't start on a page      * boundary.      */
name|pgresid
operator|=
operator|(
name|u_long
operator|)
name|vaddr
operator|%
name|PAGE_SIZE
expr_stmt|;
if|if
condition|(
name|pgresid
condition|)
block|{
name|prd
index|[
name|i
index|]
operator|.
name|prd_base
operator|=
name|vtophys
argument_list|(
name|vaddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|>=
operator|(
name|PAGE_SIZE
operator|-
name|pgresid
operator|)
condition|)
name|prd
index|[
name|i
index|]
operator|.
name|prd_count
operator|=
name|PAGE_SIZE
operator|-
name|pgresid
expr_stmt|;
else|else
name|prd
index|[
name|i
index|]
operator|.
name|prd_count
operator|=
name|count
expr_stmt|;
name|vaddr
operator|+=
name|prd
index|[
name|i
index|]
operator|.
name|prd_count
expr_stmt|;
name|count
operator|-=
name|prd
index|[
name|i
index|]
operator|.
name|prd_count
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
comment|/*      * We have now ensured that vaddr is page-aligned, so just      * step through the pages adding each one onto the list.      */
while|while
condition|(
name|count
condition|)
block|{
name|u_long
name|phys
decl_stmt|,
name|n
decl_stmt|;
name|phys
operator|=
name|vtophys
argument_list|(
name|vaddr
argument_list|)
expr_stmt|;
name|n
operator|=
operator|(
operator|(
name|count
operator|>
name|PAGE_SIZE
operator|)
condition|?
name|PAGE_SIZE
else|:
name|count
operator|)
expr_stmt|;
comment|/* 	 * If the current page is physically contiguous with 	 * whatever we have in the previous PRD, just tack it 	 * onto the end. 	 * CAVEAT: due to a hardware deficiency, PRDs 	 * cannot cross a 64K boundary. 	 * XXX should we bother with this collapsing?  scattered 	 * pages appear to be the common case anyway. 	 */
if|if
condition|(
name|i
operator|>
literal|0
operator|&&
operator|(
name|phys
operator|==
name|prd
index|[
name|i
operator|-
literal|1
index|]
operator|.
name|prd_base
operator|+
name|prd
index|[
name|i
operator|-
literal|1
index|]
operator|.
name|prd_count
operator|)
operator|&&
operator|(
operator|(
name|prd
index|[
name|i
operator|-
literal|1
index|]
operator|.
name|prd_base
operator|&
literal|0xffff
operator|)
operator|+
name|prd
index|[
name|i
operator|-
literal|1
index|]
operator|.
name|prd_count
operator|+
name|n
operator|)
operator|<=
literal|65535
condition|)
block|{
name|prd
index|[
name|i
operator|-
literal|1
index|]
operator|.
name|prd_count
operator|+=
name|n
expr_stmt|;
block|}
else|else
block|{
name|prd
index|[
name|i
index|]
operator|.
name|prd_base
operator|=
name|phys
expr_stmt|;
name|prd
index|[
name|i
index|]
operator|.
name|prd_count
operator|=
name|n
expr_stmt|;
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|i
operator|>=
name|PRD_MAX_SEGS
condition|)
name|panic
argument_list|(
literal|"wd82371: too many segments\n"
argument_list|)
expr_stmt|;
block|}
name|count
operator|-=
name|n
expr_stmt|;
name|vaddr
operator|+=
name|n
expr_stmt|;
block|}
comment|/* put a sign at the edge of the cliff... */
name|prd
index|[
operator|(
name|i
operator|>
literal|0
operator|)
condition|?
operator|(
name|i
operator|-
literal|1
operator|)
else|:
literal|0
index|]
operator|.
name|prd_count
operator||=
name|PRD_EOT_BIT
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"ide_pci: dmasetup 0-length PRD???\n"
argument_list|)
expr_stmt|;
comment|/* Set up PRD base register */
name|outl
argument_list|(
name|iobase_bm
operator|+
name|BMIDTP_PORT
argument_list|,
name|vtophys
argument_list|(
name|prd
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Set direction of transfer */
if|if
condition|(
name|dir
operator|==
name|B_READ
condition|)
block|{
name|outb
argument_list|(
name|iobase_bm
operator|+
name|BMICOM_PORT
argument_list|,
name|BMICOM_READ_WRITE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|outb
argument_list|(
name|iobase_bm
operator|+
name|BMICOM_PORT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Clear interrupt and error bits */
name|outb
argument_list|(
name|iobase_bm
operator|+
name|BMISTA_PORT
argument_list|,
operator|(
name|inb
argument_list|(
name|iobase_bm
operator|+
name|BMISTA_PORT
argument_list|)
operator||
operator|(
name|BMISTA_INTERRUPT
operator||
name|BMISTA_DMA_ERROR
operator|)
operator|)
argument_list|)
expr_stmt|;
comment|/* printf("dma enable: iobase_bm = %08x command/status = %08x pointer = %08x\n", iobase_bm, inl(iobase_bm + BMICOM_PORT), inl(iobase_bm + BMIDTP_PORT)); */
comment|/* printf("P"); */
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ide_pci_dmastart
parameter_list|(
name|void
modifier|*
name|xcp
parameter_list|)
block|{
name|struct
name|ide_pci_cookie
modifier|*
name|cp
init|=
name|xcp
decl_stmt|;
name|int
name|iobase_bm
decl_stmt|;
name|iobase_bm
operator|=
name|cp
operator|->
name|iobase_bm
expr_stmt|;
name|outb
argument_list|(
name|iobase_bm
operator|+
name|BMICOM_PORT
argument_list|,
name|inb
argument_list|(
name|iobase_bm
operator|+
name|BMICOM_PORT
argument_list|)
operator||
name|BMICOM_STOP_START
argument_list|)
expr_stmt|;
comment|/* printf("["); */
block|}
end_function

begin_function
specifier|static
name|int
name|ide_pci_dmadone
parameter_list|(
name|void
modifier|*
name|xcp
parameter_list|)
block|{
name|struct
name|ide_pci_cookie
modifier|*
name|cp
init|=
name|xcp
decl_stmt|;
name|int
name|iobase_bm
decl_stmt|,
name|status
decl_stmt|;
name|status
operator|=
name|ide_pci_status
argument_list|(
name|xcp
argument_list|)
expr_stmt|;
name|iobase_bm
operator|=
name|cp
operator|->
name|iobase_bm
expr_stmt|;
name|outb
argument_list|(
name|iobase_bm
operator|+
name|BMICOM_PORT
argument_list|,
name|inb
argument_list|(
name|iobase_bm
operator|+
name|BMICOM_PORT
argument_list|)
operator|&
operator|~
name|BMICOM_STOP_START
argument_list|)
expr_stmt|;
comment|/* printf("]"); */
return|return
name|status
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ide_pci_status
parameter_list|(
name|void
modifier|*
name|xcp
parameter_list|)
block|{
name|struct
name|ide_pci_cookie
modifier|*
name|cp
init|=
name|xcp
decl_stmt|;
name|int
name|iobase_bm
decl_stmt|,
name|status
decl_stmt|,
name|bmista
decl_stmt|;
name|status
operator|=
literal|0
expr_stmt|;
name|iobase_bm
operator|=
name|cp
operator|->
name|iobase_bm
expr_stmt|;
name|bmista
operator|=
name|inb
argument_list|(
name|iobase_bm
operator|+
name|BMISTA_PORT
argument_list|)
expr_stmt|;
comment|/* printf("dmastatus: iobase_bm = %08x status = %02x command/status = %08x pointer = %08x\n", iobase_bm, bmista, inl(iobase_bm + BMICOM_PORT), inl(iobase_bm + BMIDTP_PORT)); */
if|if
condition|(
name|bmista
operator|&
name|BMISTA_INTERRUPT
condition|)
name|status
operator||=
name|WDDS_INTERRUPT
expr_stmt|;
if|if
condition|(
name|bmista
operator|&
name|BMISTA_DMA_ERROR
condition|)
name|status
operator||=
name|WDDS_ERROR
expr_stmt|;
if|if
condition|(
name|bmista
operator|&
name|BMISTA_DMA_ACTIVE
condition|)
name|status
operator||=
name|WDDS_ACTIVE
expr_stmt|;
comment|/* printf( (bmista == BMISTA_INTERRUPT)? "?":"!"); */
return|return
name|status
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NPCI> 0 */
end_comment

end_unit

