begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright 1996 Massachusetts Institute of Technology  *  * Permission to use, copy, modify, and distribute this software and  * its documentation for any purpose and without fee is hereby  * granted, provided that both the above copyright notice and this  * permission notice appear in all copies, that both the above  * copyright notice and this permission notice appear in all  * supporting documentation, and that the name of M.I.T. not be used  * in advertising or publicity pertaining to distribution of the  * software without specific, written prior permission.  M.I.T. makes  * no representations about the suitability of this software for any  * purpose.  It is provided "as is" without express or implied  * warranty.  *   * THIS SOFTWARE IS PROVIDED BY M.I.T. ``AS IS''.  M.I.T. DISCLAIMS  * ALL EXPRESS OR IMPLIED WARRANTIES WITH REGARD TO THIS SOFTWARE,  * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF  * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT  * SHALL M.I.T. BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF  * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,  * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT  * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *	$Id: ide_pci.c,v 1.5 1997/11/07 08:53:27 phk Exp $  */
end_comment

begin_include
include|#
directive|include
file|"pci.h"
end_include

begin_if
if|#
directive|if
name|NPCI
operator|>
literal|0
end_if

begin_include
include|#
directive|include
file|"opt_wd.h"
end_include

begin_include
include|#
directive|include
file|"wd.h"
end_include

begin_if
if|#
directive|if
name|NWDC
operator|>
literal|0
end_if

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/buf.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/wdreg.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/isa.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/isa_device.h>
end_include

begin_include
include|#
directive|include
file|<pci/pcivar.h>
end_include

begin_include
include|#
directive|include
file|<pci/pcireg.h>
end_include

begin_include
include|#
directive|include
file|<pci/ide_pcireg.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|MIN
end_ifndef

begin_define
define|#
directive|define
name|MIN
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|(((a)<(b))?(a):(b))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|PROMISE_ULTRA33
value|0x4d33105a
end_define

begin_struct_decl
struct_decl|struct
name|ide_pci_cookie
struct_decl|;
end_struct_decl

begin_comment
comment|/* structs vendor_fns, ide_pci_cookie are recursive */
end_comment

begin_struct
struct|struct
name|vendor_fns
block|{
name|int
function_decl|(
modifier|*
name|vendor_dmainit
function_decl|)
comment|/* initialize DMA controller and drive */
parameter_list|(
name|struct
name|ide_pci_cookie
modifier|*
name|cookie
parameter_list|,
name|struct
name|wdparams
modifier|*
name|wp
parameter_list|,
name|int
function_decl|(
modifier|*
name|wdcmd
function_decl|)
parameter_list|(
name|int
parameter_list|,
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
name|void
function_decl|(
modifier|*
name|vendor_status
function_decl|)
comment|/* prints off DMA timing info */
parameter_list|(
name|struct
name|ide_pci_cookie
modifier|*
name|cookie
parameter_list|)
function_decl|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * XXX the fact that this list keeps all kinds of info on PCI controllers  * is pretty grotty-- much of this should be replaced by a proper integration  * of PCI probes into the wd driver.  * XXX if we're going to support native-PCI controllers, we also need to  * keep the address of the IDE control block register, which is something wd.c  * needs to know, which is why this info is in the wrong place.  */
end_comment

begin_struct
struct|struct
name|ide_pci_cookie
block|{
name|LIST_ENTRY
argument_list|(
argument|ide_pci_cookie
argument_list|)
name|le
expr_stmt|;
name|int
name|iobase_wd
decl_stmt|;
name|int
name|ctlr
decl_stmt|;
comment|/* controller 0/1 on PCI IDE interface */
name|int
name|unit
decl_stmt|;
name|int
name|iobase_bm
decl_stmt|;
comment|/* SFF-8038 control registers */
name|int
name|altiobase_wd
decl_stmt|;
name|pcici_t
name|tag
decl_stmt|;
name|pcidi_t
name|type
decl_stmt|;
name|struct
name|ide_pci_prd
modifier|*
name|prd
decl_stmt|;
name|struct
name|vendor_fns
name|vs
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|ide_pci_softc
block|{
name|LIST_HEAD
argument_list|(
argument_list|,
argument|ide_pci_cookie
argument_list|)
name|cookies
expr_stmt|;
block|}
struct|;
end_struct

begin_function_decl
specifier|static
name|int
name|generic_dmainit
parameter_list|(
name|struct
name|ide_pci_cookie
modifier|*
name|cookie
parameter_list|,
name|struct
name|wdparams
modifier|*
name|wp
parameter_list|,
name|int
function_decl|(
modifier|*
name|wdcmd
function_decl|)
parameter_list|(
name|int
parameter_list|,
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
name|wdinfo
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|generic_status
parameter_list|(
name|struct
name|ide_pci_cookie
modifier|*
name|cookie
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|via_571_status
parameter_list|(
name|struct
name|ide_pci_cookie
modifier|*
name|cookie
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|via_571_dmainit
parameter_list|(
name|struct
name|ide_pci_cookie
modifier|*
name|cookie
parameter_list|,
name|struct
name|wdparams
modifier|*
name|wp
parameter_list|,
name|int
function_decl|(
modifier|*
name|wdcmd
function_decl|)
parameter_list|(
name|int
parameter_list|,
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
name|wdinfo
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|intel_piix_dump_drive
parameter_list|(
name|char
modifier|*
name|ctlr
parameter_list|,
name|int
name|sitre
parameter_list|,
name|int
name|is_piix4
parameter_list|,
name|int
name|word40
parameter_list|,
name|int
name|word44
parameter_list|,
name|int
name|word48
parameter_list|,
name|int
name|word4a
parameter_list|,
name|int
name|drive
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|intel_piix_status
parameter_list|(
name|struct
name|ide_pci_cookie
modifier|*
name|cookie
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|intel_piix_dmainit
parameter_list|(
name|struct
name|ide_pci_cookie
modifier|*
name|cookie
parameter_list|,
name|struct
name|wdparams
modifier|*
name|wp
parameter_list|,
name|int
function_decl|(
modifier|*
name|wdcmd
function_decl|)
parameter_list|(
name|int
parameter_list|,
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
name|wdinfo
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|ide_pci_cookie
modifier|*
name|mkcookie
parameter_list|(
name|int
name|iobase_wd
parameter_list|,
name|int
name|ctlr
parameter_list|,
name|int
name|unit
parameter_list|,
name|int
name|iobase_bm
parameter_list|,
name|pcici_t
name|tag
parameter_list|,
name|pcidi_t
name|type
parameter_list|,
name|struct
name|vendor_fns
modifier|*
name|vp
parameter_list|,
name|int
name|altiobase_wd
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ide_pci_attach
parameter_list|(
name|pcici_t
name|tag
parameter_list|,
name|int
name|unit
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
modifier|*
name|ide_pci_candma
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ide_pci_dmainit
parameter_list|(
name|void
modifier|*
parameter_list|,
name|struct
name|wdparams
modifier|*
parameter_list|,
name|int
function_decl|(
modifier|*
function_decl|)
parameter_list|(
name|int
parameter_list|,
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ide_pci_dmaverify
parameter_list|(
name|void
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|u_long
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ide_pci_dmasetup
parameter_list|(
name|void
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|u_long
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ide_pci_dmastart
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ide_pci_dmadone
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ide_pci_status
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ide_pci_iobase
parameter_list|(
name|void
modifier|*
name|xcp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ide_pci_altiobase
parameter_list|(
name|void
modifier|*
name|xcp
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|struct
name|ide_pci_softc
name|softc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ide_pci_softc_cookies_initted
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|void
name|wdintr
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|extern
name|struct
name|isa_driver
name|wdcdriver
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * PRD_ALLOC_SIZE should be something that will not be allocated across a 64k  * boundary.  * PRD_MAX_SEGS is defined to be the maximum number of segments required for  * a transfer on an IDE drive, for an xfer that is linear in virtual memory.  * PRD_BUF_SIZE is the size of the buffer needed for a PRD table.  */
end_comment

begin_define
define|#
directive|define
name|PRD_ALLOC_SIZE
value|PAGE_SIZE
end_define

begin_define
define|#
directive|define
name|PRD_MAX_SEGS
value|((256 * 512 / PAGE_SIZE) + 1)
end_define

begin_define
define|#
directive|define
name|PRD_BUF_SIZE
value|PRD_MAX_SEGS * 8
end_define

begin_decl_stmt
specifier|static
name|void
modifier|*
name|prdbuf
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
modifier|*
name|prdbuf_next
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*   * Hardware specific IDE controller code.  All vendor-specific code  * for handling IDE timing and other chipset peculiarities should be  * encapsulated here.  */
end_comment

begin_comment
comment|/* helper funcs */
end_comment

begin_comment
comment|/*  * nnn_mode() return the highest valid mode, or -1 if the mode class is  * not supported  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|pio_mode
parameter_list|(
name|struct
name|wdparams
modifier|*
name|wp
parameter_list|)
block|{
if|if
condition|(
operator|(
name|wp
operator|->
name|wdp_atavalid
operator|&
literal|2
operator|)
operator|==
literal|2
condition|)
block|{
if|if
condition|(
operator|(
name|wp
operator|->
name|wdp_eidepiomodes
operator|&
literal|2
operator|)
operator|==
literal|2
condition|)
return|return
literal|4
return|;
if|if
condition|(
operator|(
name|wp
operator|->
name|wdp_eidepiomodes
operator|&
literal|1
operator|)
operator|==
literal|1
condition|)
return|return
literal|3
return|;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
unit|static inline int dma_mode(struct wdparams *wp) {
comment|/* XXX not quite sure how to verify validity on this field */
end_comment

begin_endif
unit|}
endif|#
directive|endif
end_endif

begin_function
specifier|static
specifier|inline
name|int
name|mwdma_mode
parameter_list|(
name|struct
name|wdparams
modifier|*
name|wp
parameter_list|)
block|{
comment|/*  	 * XXX technically, using wdp_atavalid to test for validity of 	 * this field is not quite correct 	 */
if|if
condition|(
operator|(
name|wp
operator|->
name|wdp_atavalid
operator|&
literal|2
operator|)
operator|==
literal|2
condition|)
block|{
if|if
condition|(
operator|(
name|wp
operator|->
name|wdp_dmamword
operator|&
literal|4
operator|)
operator|==
literal|4
condition|)
return|return
literal|2
return|;
if|if
condition|(
operator|(
name|wp
operator|->
name|wdp_dmamword
operator|&
literal|2
operator|)
operator|==
literal|2
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|(
name|wp
operator|->
name|wdp_dmamword
operator|&
literal|1
operator|)
operator|==
literal|1
condition|)
return|return
literal|0
return|;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|udma_mode
parameter_list|(
name|struct
name|wdparams
modifier|*
name|wp
parameter_list|)
block|{
if|if
condition|(
operator|(
name|wp
operator|->
name|wdp_atavalid
operator|&
literal|4
operator|)
operator|==
literal|4
condition|)
block|{
if|if
condition|(
operator|(
name|wp
operator|->
name|wdp_udmamode
operator|&
literal|4
operator|)
operator|==
literal|4
condition|)
return|return
literal|2
return|;
if|if
condition|(
operator|(
name|wp
operator|->
name|wdp_udmamode
operator|&
literal|2
operator|)
operator|==
literal|2
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|(
name|wp
operator|->
name|wdp_udmamode
operator|&
literal|1
operator|)
operator|==
literal|1
condition|)
return|return
literal|0
return|;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Generic busmastering PCI-IDE */
end_comment

begin_function
specifier|static
name|int
name|generic_dmainit
parameter_list|(
name|struct
name|ide_pci_cookie
modifier|*
name|cookie
parameter_list|,
name|struct
name|wdparams
modifier|*
name|wp
parameter_list|,
name|int
function_decl|(
modifier|*
name|wdcmd
function_decl|)
parameter_list|(
name|int
parameter_list|,
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
name|wdinfo
parameter_list|)
block|{
comment|/* 	 * punt on the whole timing issue by looking for either a 	 * drive programmed for both PIO4 and mDMA2 (which use similar 	 * timing) or a drive in an UltraDMA mode (hopefully all 	 * controllers have separate timing for UDMA).  one hopes that if 	 * the drive's DMA mode has been configured by the BIOS, the 	 * controller's has also. 	 * 	 * XXX there are examples where this approach is now known to be 	 * broken, at least on systems based on Intel chipsets. 	 */
if|if
condition|(
operator|(
name|pio_mode
argument_list|(
name|wp
argument_list|)
operator|>=
literal|4
operator|&&
name|mwdma_mode
argument_list|(
name|wp
argument_list|)
operator|>=
literal|2
operator|)
operator|||
operator|(
name|udma_mode
argument_list|(
name|wp
argument_list|)
operator|>=
literal|2
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"ide_pci: generic_dmainit %04x:%d: warning, IDE controller timing not set\n"
argument_list|,
name|cookie
operator|->
name|iobase_wd
argument_list|,
name|cookie
operator|->
name|unit
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
ifdef|#
directive|ifdef
name|IDE_PCI_DEBUG
name|printf
argument_list|(
literal|"pio_mode: %d, mwdma_mode(wp): %d, udma_mode(wp): %d\n"
argument_list|,
name|pio_mode
argument_list|(
name|wp
argument_list|)
argument_list|,
name|mwdma_mode
argument_list|(
name|wp
argument_list|)
argument_list|,
name|udma_mode
argument_list|(
name|wp
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|generic_status
parameter_list|(
name|struct
name|ide_pci_cookie
modifier|*
name|cookie
parameter_list|)
block|{
name|printf
argument_list|(
literal|"generic_status: no PCI IDE timing info available\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|vendor_fns
name|vs_generic
init|=
block|{
name|generic_dmainit
block|,
name|generic_status
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* VIA Technologies "82C571" PCI-IDE controller core */
end_comment

begin_function
specifier|static
name|void
name|via_571_status
parameter_list|(
name|struct
name|ide_pci_cookie
modifier|*
name|cookie
parameter_list|)
block|{
name|int
name|iobase_wd
decl_stmt|;
name|int
name|ctlr
decl_stmt|,
name|unit
decl_stmt|;
name|int
name|iobase_bm
decl_stmt|;
name|pcici_t
name|tag
decl_stmt|;
name|pcidi_t
name|type
decl_stmt|;
name|u_long
name|word40
index|[
literal|5
index|]
decl_stmt|;
name|int
name|i
decl_stmt|,
name|unitno
decl_stmt|;
name|iobase_wd
operator|=
name|cookie
operator|->
name|iobase_wd
expr_stmt|;
name|unit
operator|=
name|cookie
operator|->
name|unit
expr_stmt|;
name|ctlr
operator|=
name|cookie
operator|->
name|ctlr
expr_stmt|;
name|iobase_bm
operator|=
name|cookie
operator|->
name|iobase_bm
expr_stmt|;
name|tag
operator|=
name|cookie
operator|->
name|tag
expr_stmt|;
name|type
operator|=
name|cookie
operator|->
name|type
expr_stmt|;
name|unitno
operator|=
name|ctlr
operator|*
literal|2
operator|+
name|unit
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|5
condition|;
name|i
operator|++
control|)
block|{
name|word40
index|[
name|i
index|]
operator|=
name|pci_conf_read
argument_list|(
name|tag
argument_list|,
name|i
operator|*
literal|4
operator|+
literal|0x40
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ctlr
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"via_571_status: Primary IDE prefetch/postwrite %s/%s\n"
argument_list|,
name|word40
index|[
literal|0
index|]
operator|&
literal|0x8000
condition|?
literal|"enabled"
else|:
literal|"disabled"
argument_list|,
name|word40
index|[
literal|0
index|]
operator|&
literal|0x4000
condition|?
literal|"enabled"
else|:
literal|"disabled"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"via_571_status: Secondary IDE prefetch/postwrite %s/%s\n"
argument_list|,
name|word40
index|[
literal|0
index|]
operator|&
literal|0x2000
condition|?
literal|"enabled"
else|:
literal|"disabled"
argument_list|,
name|word40
index|[
literal|0
index|]
operator|&
literal|0x1000
condition|?
literal|"enabled"
else|:
literal|"disabled"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"via_571_status: busmaster status read retry %s\n"
argument_list|,
operator|(
name|word40
index|[
literal|1
index|]
operator|&
literal|0x08
operator|)
condition|?
literal|"enabled"
else|:
literal|"disabled"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"via_571_status: %s drive %d data setup=%d active=%d recovery=%d\n"
argument_list|,
name|unitno
operator|<
literal|2
condition|?
literal|"primary"
else|:
literal|"secondary"
argument_list|,
name|unitno
operator|&
literal|1
argument_list|,
operator|(
operator|(
name|word40
index|[
literal|3
index|]
operator|>>
operator|(
operator|(
literal|3
operator|-
name|unitno
operator|)
operator|*
literal|2
operator|)
operator|)
operator|&
literal|3
operator|)
operator|+
literal|1
argument_list|,
operator|(
operator|(
name|word40
index|[
literal|2
index|]
operator|>>
operator|(
operator|(
operator|(
literal|3
operator|-
name|unitno
operator|)
operator|*
literal|8
operator|)
operator|+
literal|4
operator|)
operator|)
operator|&
literal|0x0f
operator|)
operator|+
literal|1
argument_list|,
operator|(
operator|(
name|word40
index|[
literal|2
index|]
operator|>>
operator|(
operator|(
literal|3
operator|-
name|unitno
operator|)
operator|*
literal|8
operator|)
operator|)
operator|&
literal|0x0f
operator|)
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctlr
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"via_571_status: primary ctrl active=%d recovery=%d\n"
argument_list|,
operator|(
operator|(
name|word40
index|[
literal|3
index|]
operator|>>
literal|28
operator|)
operator|&
literal|0x0f
operator|)
operator|+
literal|1
argument_list|,
operator|(
operator|(
name|word40
index|[
literal|2
index|]
operator|>>
literal|24
operator|)
operator|&
literal|0x0f
operator|)
operator|+
literal|1
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"via_571_status: secondary ctrl active=%d recovery=%d\n"
argument_list|,
operator|(
operator|(
name|word40
index|[
literal|3
index|]
operator|>>
literal|20
operator|)
operator|&
literal|0x0f
operator|)
operator|+
literal|1
argument_list|,
operator|(
operator|(
name|word40
index|[
literal|2
index|]
operator|>>
literal|16
operator|)
operator|&
literal|0x0f
operator|)
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* UltraDMA dump */
block|{
name|int
name|foo
decl_stmt|;
name|foo
operator|=
name|word40
index|[
literal|4
index|]
operator|>>
operator|(
operator|(
literal|3
operator|-
name|unitno
operator|)
operator|*
literal|8
operator|)
expr_stmt|;
name|printf
argument_list|(
literal|"via_571_status: %s drive %d udma method=%d enable=%d PIOmode=%d cycle=%d\n"
argument_list|,
name|i
operator|<
literal|2
condition|?
literal|"primary"
else|:
literal|"secondary"
argument_list|,
name|i
operator|&
literal|1
argument_list|,
operator|(
name|foo
operator|>>
literal|7
operator|)
operator|&
literal|1
argument_list|,
operator|(
name|foo
operator|>>
literal|6
operator|)
operator|&
literal|1
argument_list|,
operator|(
name|foo
operator|>>
literal|5
operator|)
operator|&
literal|1
argument_list|,
operator|(
name|foo
operator|&
literal|3
operator|)
operator|+
literal|2
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * XXX timing values set here are only good for 30/33MHz buses; should deal  * with slower ones too (BTW: you overclock-- you lose)  */
end_comment

begin_function
specifier|static
name|int
name|via_571_dmainit
parameter_list|(
name|struct
name|ide_pci_cookie
modifier|*
name|cookie
parameter_list|,
name|struct
name|wdparams
modifier|*
name|wp
parameter_list|,
name|int
function_decl|(
modifier|*
name|wdcmd
function_decl|)
parameter_list|(
name|int
parameter_list|,
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
name|wdinfo
parameter_list|)
block|{
name|int
name|r
decl_stmt|;
name|u_long
name|pci_revision
decl_stmt|;
name|int
name|unitno
decl_stmt|;
name|pci_revision
operator|=
name|pci_conf_read
argument_list|(
name|cookie
operator|->
name|tag
argument_list|,
name|PCI_CLASS_REG
argument_list|)
operator|&
name|PCI_REVISION_MASK
expr_stmt|;
name|unitno
operator|=
name|cookie
operator|->
name|ctlr
operator|*
literal|2
operator|+
name|cookie
operator|->
name|unit
expr_stmt|;
comment|/* If it's a UDMA drive on a '590, set it up */
comment|/*  	 * XXX the revision number we check for is of dubious validity. 	 * it's extracted from the AMD 645 datasheet. 	 */
if|if
condition|(
name|pci_revision
operator|>=
literal|1
operator|&&
name|udma_mode
argument_list|(
name|wp
argument_list|)
operator|>=
literal|2
condition|)
block|{
name|unsigned
name|int
name|word50
decl_stmt|,
name|mask
decl_stmt|,
name|new
decl_stmt|;
name|word50
operator|=
name|pci_conf_read
argument_list|(
name|cookie
operator|->
name|tag
argument_list|,
literal|0x50
argument_list|)
expr_stmt|;
comment|/* UDMA enable by SET FEATURES, DMA cycles, cycle time 2T */
name|mask
operator|=
literal|0xe3000000
operator|>>
operator|(
name|unitno
operator|*
literal|8
operator|)
expr_stmt|;
name|new
operator|=
literal|0x80000000
operator|>>
operator|(
name|unitno
operator|*
literal|8
operator|)
expr_stmt|;
name|word50
operator|&=
operator|~
name|mask
expr_stmt|;
name|word50
operator||=
name|new
expr_stmt|;
name|pci_conf_write
argument_list|(
name|cookie
operator|->
name|tag
argument_list|,
literal|0x50
argument_list|,
name|word50
argument_list|)
expr_stmt|;
comment|/* 		 * With the '590, drive configuration should come *after* the 		 * controller configuration, to make sure the controller sees  		 * the SET FEATURES command and does the right thing. 		 */
comment|/* Set UDMA mode 2 on drive */
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"intel_piix_dmainit: setting ultra DMA mode 2\n"
argument_list|)
expr_stmt|;
name|r
operator|=
name|wdcmd
argument_list|(
name|WDDMA_UDMA2
argument_list|,
name|wdinfo
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|r
condition|)
block|{
name|printf
argument_list|(
literal|"intel_piix_dmainit: setting DMA mode failed\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|bootverbose
condition|)
name|via_571_status
argument_list|(
name|cookie
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* otherwise, try and program it for MW DMA mode 2 */
elseif|else
if|if
condition|(
name|mwdma_mode
argument_list|(
name|wp
argument_list|)
operator|>=
literal|2
operator|&&
name|pio_mode
argument_list|(
name|wp
argument_list|)
operator|>=
literal|4
condition|)
block|{
name|u_long
name|workword
decl_stmt|;
comment|/* Set multiword DMA mode 2 on drive */
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"intel_piix_dmainit: setting multiword DMA mode 2\n"
argument_list|)
expr_stmt|;
name|r
operator|=
name|wdcmd
argument_list|(
name|WDDMA_MDMA2
argument_list|,
name|wdinfo
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|r
condition|)
block|{
name|printf
argument_list|(
literal|"intel_piix_dmainit: setting DMA mode failed\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Configure the controller appropriately for MWDMA mode 2 */
name|workword
operator|=
name|pci_conf_read
argument_list|(
name|cookie
operator|->
name|tag
argument_list|,
literal|0x40
argument_list|)
expr_stmt|;
comment|/*  		 * enable prefetch/postwrite-- XXX may cause problems 		 * with CD-ROMs?  		 */
name|workword
operator|&=
operator|~
operator|(
literal|3
operator|<<
operator|(
name|cookie
operator|->
name|ctlr
operator|*
literal|2
operator|+
literal|12
operator|)
operator|)
expr_stmt|;
name|workword
operator||=
literal|3
operator|<<
operator|(
name|cookie
operator|->
name|ctlr
operator|*
literal|2
operator|+
literal|12
operator|)
expr_stmt|;
comment|/* FIFO configurations-- equal split, threshold 1/2 */
name|workword
operator|&=
literal|0x90ffffff
expr_stmt|;
name|workword
operator||=
literal|0x2a000000
expr_stmt|;
name|pci_conf_write
argument_list|(
name|cookie
operator|->
name|tag
argument_list|,
literal|0x40
argument_list|,
name|workword
argument_list|)
expr_stmt|;
name|workword
operator|=
name|pci_conf_read
argument_list|(
name|cookie
operator|->
name|tag
argument_list|,
literal|0x44
argument_list|)
expr_stmt|;
comment|/* enable status read retry */
name|workword
operator||=
literal|8
expr_stmt|;
comment|/* enable FIFO flush on interrupt and end of sector */
name|workword
operator|&=
literal|0xff0cffff
expr_stmt|;
name|workword
operator||=
literal|0x00f00000
expr_stmt|;
name|pci_conf_write
argument_list|(
name|cookie
operator|->
name|tag
argument_list|,
literal|0x44
argument_list|,
name|workword
argument_list|)
expr_stmt|;
name|workword
operator|=
name|pci_conf_read
argument_list|(
name|cookie
operator|->
name|tag
argument_list|,
literal|0x48
argument_list|)
expr_stmt|;
comment|/* set Mode2 timing */
name|workword
operator|&=
operator|~
operator|(
literal|0xff000000
operator|>>
operator|(
name|unitno
operator|*
literal|8
operator|)
operator|)
expr_stmt|;
name|workword
operator||=
literal|0x31000000
operator|>>
operator|(
name|unitno
operator|*
literal|8
operator|)
expr_stmt|;
name|pci_conf_write
argument_list|(
name|cookie
operator|->
name|tag
argument_list|,
literal|0x48
argument_list|,
name|workword
argument_list|)
expr_stmt|;
comment|/* set sector size */
name|pci_conf_write
argument_list|(
name|cookie
operator|->
name|tag
argument_list|,
name|cookie
operator|->
name|ctlr
condition|?
literal|0x68
else|:
literal|0x60
argument_list|,
literal|0x200
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|via_571_status
argument_list|(
name|cookie
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|vendor_fns
name|vs_via_571
init|=
block|{
name|via_571_dmainit
block|,
name|via_571_status
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|promise_status
parameter_list|(
name|struct
name|ide_pci_cookie
modifier|*
name|cookie
parameter_list|)
block|{
name|pcici_t
name|tag
decl_stmt|;
name|int
name|i
decl_stmt|;
name|u_int32_t
name|port0_command
decl_stmt|,
name|port0_altstatus
decl_stmt|;
name|u_int32_t
name|port1_command
decl_stmt|,
name|port1_altstatus
decl_stmt|;
name|u_int32_t
name|dma_block
decl_stmt|;
name|u_int32_t
name|lat_and_interrupt
decl_stmt|;
name|u_int32_t
name|drivetiming
decl_stmt|;
name|int
name|pa
decl_stmt|,
name|pb
decl_stmt|,
name|mb
decl_stmt|,
name|mc
decl_stmt|;
name|tag
operator|=
name|cookie
operator|->
name|tag
expr_stmt|;
name|port0_command
operator|=
name|pci_conf_read
argument_list|(
name|tag
argument_list|,
literal|0x10
argument_list|)
expr_stmt|;
name|port0_altstatus
operator|=
name|pci_conf_read
argument_list|(
name|tag
argument_list|,
literal|0x14
argument_list|)
expr_stmt|;
name|port1_command
operator|=
name|pci_conf_read
argument_list|(
name|tag
argument_list|,
literal|0x18
argument_list|)
expr_stmt|;
name|port1_altstatus
operator|=
name|pci_conf_read
argument_list|(
name|tag
argument_list|,
literal|0x1c
argument_list|)
expr_stmt|;
name|dma_block
operator|=
name|pci_conf_read
argument_list|(
name|tag
argument_list|,
literal|0x20
argument_list|)
expr_stmt|;
name|lat_and_interrupt
operator|=
name|pci_conf_read
argument_list|(
name|tag
argument_list|,
literal|0x3c
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"promise_status: port0: 0x%lx, port0_alt: 0x%lx, port1: 0x%lx, port1_alt: 0x%lx\n"
argument_list|,
name|port0_command
argument_list|,
name|port0_altstatus
argument_list|,
name|port1_command
argument_list|,
name|port1_altstatus
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"promise_status: dma control blk address: 0x%lx, int: %d, irq: %d\n"
argument_list|,
name|dma_block
argument_list|,
operator|(
name|lat_and_interrupt
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|,
name|lat_and_interrupt
operator|&
literal|0xff
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|+=
literal|2
control|)
block|{
name|drivetiming
operator|=
name|pci_conf_read
argument_list|(
name|tag
argument_list|,
literal|0x60
operator|+
name|i
operator|*
literal|4
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"drivebits%d-%d: %b\n"
argument_list|,
name|i
argument_list|,
name|i
operator|+
literal|1
argument_list|,
name|drivetiming
argument_list|,
literal|"\020\05Prefetch\06Iordy\07Errdy\010Sync\025DmaW\026DmaR"
argument_list|)
expr_stmt|;
name|pa
operator|=
name|drivetiming
operator|&
literal|0xf
expr_stmt|;
name|pb
operator|=
operator|(
name|drivetiming
operator|>>
literal|8
operator|)
operator|&
literal|0x1f
expr_stmt|;
name|mb
operator|=
operator|(
name|drivetiming
operator|>>
literal|13
operator|)
operator|&
literal|0x7
expr_stmt|;
name|mc
operator|=
operator|(
name|drivetiming
operator|>>
literal|16
operator|)
operator|&
literal|0xf
expr_stmt|;
name|printf
argument_list|(
literal|"drivetiming%d: pa: 0x%x, pb: 0x%x, mb: 0x%x, mc: 0x%x\n"
argument_list|,
name|i
argument_list|,
name|pa
argument_list|,
name|pb
argument_list|,
name|mb
argument_list|,
name|mc
argument_list|)
expr_stmt|;
name|drivetiming
operator|=
name|pci_conf_read
argument_list|(
name|tag
argument_list|,
literal|0x60
operator|+
operator|(
name|i
operator|+
literal|1
operator|)
operator|*
literal|4
argument_list|)
expr_stmt|;
name|pa
operator|=
name|drivetiming
operator|&
literal|0xf
expr_stmt|;
name|pb
operator|=
operator|(
name|drivetiming
operator|>>
literal|8
operator|)
operator|&
literal|0x1f
expr_stmt|;
name|mb
operator|=
operator|(
name|drivetiming
operator|>>
literal|13
operator|)
operator|&
literal|0x7
expr_stmt|;
name|mc
operator|=
operator|(
name|drivetiming
operator|>>
literal|16
operator|)
operator|&
literal|0xf
expr_stmt|;
name|printf
argument_list|(
literal|"drivetiming%d: pa: 0x%x, pb: 0x%x, mb: 0x%x, mc: 0x%x\n"
argument_list|,
name|i
operator|+
literal|1
argument_list|,
name|pa
argument_list|,
name|pb
argument_list|,
name|mb
argument_list|,
name|mc
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|vendor_fns
name|vs_promise
init|=
block|{
name|generic_dmainit
block|,
name|promise_status
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Intel PIIX, PIIX3, and PIIX4 IDE controller subfunctions */
end_comment

begin_function
specifier|static
name|void
name|intel_piix_dump_drive
parameter_list|(
name|char
modifier|*
name|ctlr
parameter_list|,
name|int
name|sitre
parameter_list|,
name|int
name|is_piix4
parameter_list|,
name|int
name|word40
parameter_list|,
name|int
name|word44
parameter_list|,
name|int
name|word48
parameter_list|,
name|int
name|word4a
parameter_list|,
name|int
name|drive
parameter_list|)
block|{
name|char
modifier|*
name|ms
decl_stmt|;
if|if
condition|(
operator|!
name|sitre
condition|)
name|ms
operator|=
literal|"master/slave"
expr_stmt|;
elseif|else
if|if
condition|(
name|drive
operator|==
literal|0
condition|)
name|ms
operator|=
literal|"master"
expr_stmt|;
else|else
name|ms
operator|=
literal|"slave"
expr_stmt|;
name|printf
argument_list|(
literal|"intel_piix_status: %s %s sample = %d, %s recovery = %d\n"
argument_list|,
name|ctlr
argument_list|,
name|ms
argument_list|,
literal|5
operator|-
operator|(
operator|(
name|sitre
operator|&&
name|drive
operator|)
condition|?
operator|(
operator|(
name|word44
operator|>>
literal|2
operator|)
operator|&
literal|3
operator|)
else|:
operator|(
operator|(
name|word40
operator|>>
literal|12
operator|)
operator|&
literal|3
operator|)
operator|)
argument_list|,
name|ms
argument_list|,
literal|4
operator|-
operator|(
operator|(
name|sitre
operator|&&
name|drive
operator|)
condition|?
operator|(
operator|(
name|word44
operator|>>
literal|0
operator|)
operator|&
literal|3
operator|)
else|:
operator|(
operator|(
name|word40
operator|>>
literal|8
operator|)
operator|&
literal|3
operator|)
operator|)
argument_list|)
expr_stmt|;
name|word40
operator|>>=
operator|(
name|drive
operator|*
literal|4
operator|)
expr_stmt|;
name|printf
argument_list|(
literal|"intel_piix_status: %s %s fastDMAonly %s, pre/post %s,\n\ intel_piix_status:  IORDY sampling %s,\n\ intel_piix_status:  fast PIO %s%s\n"
argument_list|,
name|ctlr
argument_list|,
operator|(
name|drive
operator|==
literal|0
operator|)
condition|?
literal|"master"
else|:
literal|"slave"
argument_list|,
operator|(
name|word40
operator|&
literal|8
operator|)
condition|?
literal|"enabled"
else|:
literal|"disabled"
argument_list|,
operator|(
name|word40
operator|&
literal|4
operator|)
condition|?
literal|"enabled"
else|:
literal|"disabled"
argument_list|,
operator|(
name|word40
operator|&
literal|2
operator|)
condition|?
literal|"enabled"
else|:
literal|"disabled"
argument_list|,
operator|(
name|word40
operator|&
literal|1
operator|)
condition|?
literal|"enabled"
else|:
literal|"disabled"
argument_list|,
operator|(
operator|(
name|word40
operator|&
literal|9
operator|)
operator|==
literal|9
operator|)
condition|?
literal|" (overridden by fastDMAonly)"
else|:
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_piix4
condition|)
name|printf
argument_list|(
literal|"intel_piix_status: UltraDMA %s, CT/RP = %d/%d\n"
argument_list|,
name|word48
condition|?
literal|"enabled"
else|:
literal|"disabled"
argument_list|,
literal|4
operator|-
operator|(
name|word4a
operator|&
literal|3
operator|)
argument_list|,
literal|6
operator|-
operator|(
name|word4a
operator|&
literal|3
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|intel_piix_status
parameter_list|(
name|struct
name|ide_pci_cookie
modifier|*
name|cookie
parameter_list|)
block|{
name|int
name|iobase_wd
decl_stmt|;
name|int
name|unit
decl_stmt|;
name|int
name|iobase_bm
decl_stmt|;
name|pcici_t
name|tag
decl_stmt|;
name|pcidi_t
name|type
decl_stmt|;
name|int
name|ctlr
decl_stmt|;
name|u_long
name|word40
decl_stmt|,
name|word44
decl_stmt|,
name|word48
decl_stmt|;
name|int
name|sitre
decl_stmt|,
name|is_piix4
decl_stmt|;
name|iobase_wd
operator|=
name|cookie
operator|->
name|iobase_wd
expr_stmt|;
name|unit
operator|=
name|cookie
operator|->
name|unit
expr_stmt|;
name|iobase_bm
operator|=
name|cookie
operator|->
name|iobase_bm
expr_stmt|;
name|tag
operator|=
name|cookie
operator|->
name|tag
expr_stmt|;
name|type
operator|=
name|cookie
operator|->
name|type
expr_stmt|;
name|ctlr
operator|=
name|cookie
operator|->
name|ctlr
expr_stmt|;
name|word40
operator|=
name|pci_conf_read
argument_list|(
name|tag
argument_list|,
literal|0x40
argument_list|)
expr_stmt|;
name|word44
operator|=
name|pci_conf_read
argument_list|(
name|tag
argument_list|,
literal|0x44
argument_list|)
expr_stmt|;
name|word48
operator|=
name|pci_conf_read
argument_list|(
name|tag
argument_list|,
literal|0x48
argument_list|)
expr_stmt|;
comment|/*  	 * XXX will not be right for the *next* generation of upward-compatible 	 * intel IDE controllers... 	 */
name|is_piix4
operator|=
name|pci_conf_read
argument_list|(
name|tag
argument_list|,
name|PCI_CLASS_REG
argument_list|)
operator|==
literal|0x71118086
expr_stmt|;
name|sitre
operator|=
name|word40
operator|&
literal|0x4000
expr_stmt|;
switch|switch
condition|(
name|ctlr
operator|*
literal|2
operator|+
name|unit
condition|)
block|{
case|case
literal|0
case|:
name|intel_piix_dump_drive
argument_list|(
literal|"primary"
argument_list|,
name|sitre
argument_list|,
name|is_piix4
argument_list|,
name|word40
operator|&
literal|0xffff
argument_list|,
name|word44
operator|&
literal|0x0f
argument_list|,
name|word48
argument_list|,
name|word48
operator|>>
literal|16
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|intel_piix_dump_drive
argument_list|(
literal|"primary"
argument_list|,
name|sitre
argument_list|,
name|is_piix4
argument_list|,
name|word40
operator|&
literal|0xffff
argument_list|,
name|word44
operator|&
literal|0x0f
argument_list|,
name|word48
operator|>>
literal|1
argument_list|,
name|word48
operator|>>
literal|20
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|intel_piix_dump_drive
argument_list|(
literal|"secondary"
argument_list|,
name|sitre
argument_list|,
name|is_piix4
argument_list|,
operator|(
name|word40
operator|>>
literal|16
operator|)
operator|&
literal|0xffff
argument_list|,
operator|(
name|word44
operator|>>
literal|4
operator|)
operator|&
literal|0x0f
argument_list|,
name|word48
operator|>>
literal|2
argument_list|,
name|word48
operator|>>
literal|24
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|intel_piix_dump_drive
argument_list|(
literal|"secondary"
argument_list|,
name|sitre
argument_list|,
name|is_piix4
argument_list|,
operator|(
name|word40
operator|>>
literal|16
operator|)
operator|&
literal|0xffff
argument_list|,
operator|(
name|word44
operator|>>
literal|4
operator|)
operator|&
literal|0x0f
argument_list|,
name|word48
operator|>>
literal|3
argument_list|,
name|word48
operator|>>
literal|28
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"intel_piix_status: bad drive or controller number\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * XXX timing values set hereare only good for 30/33MHz buses; should deal  * with slower ones too (BTW: you overclock-- you lose)  */
end_comment

begin_function
specifier|static
name|int
name|intel_piix_dmainit
parameter_list|(
name|struct
name|ide_pci_cookie
modifier|*
name|cookie
parameter_list|,
name|struct
name|wdparams
modifier|*
name|wp
parameter_list|,
name|int
function_decl|(
modifier|*
name|wdcmd
function_decl|)
parameter_list|(
name|int
parameter_list|,
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
name|wdinfo
parameter_list|)
block|{
name|int
name|r
decl_stmt|;
comment|/* If it's a UDMA drive and a PIIX4, set it up */
if|if
condition|(
name|cookie
operator|->
name|type
operator|==
literal|0x71118086
operator|&&
name|udma_mode
argument_list|(
name|wp
argument_list|)
operator|>=
literal|2
condition|)
block|{
comment|/* Set UDMA mode 2 on controller */
name|int
name|unitno
decl_stmt|,
name|mask
decl_stmt|,
name|new
decl_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"intel_piix_dmainit: setting ultra DMA mode 2\n"
argument_list|)
expr_stmt|;
name|r
operator|=
name|wdcmd
argument_list|(
name|WDDMA_UDMA2
argument_list|,
name|wdinfo
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|r
condition|)
block|{
name|printf
argument_list|(
literal|"intel_piix_dmainit: setting DMA mode failed\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|unitno
operator|=
name|cookie
operator|->
name|ctlr
operator|*
literal|2
operator|+
name|cookie
operator|->
name|unit
expr_stmt|;
name|mask
operator|=
literal|1
operator|<<
name|unitno
operator|+
literal|3
operator|<<
operator|(
literal|16
operator|+
name|unitno
operator|*
literal|4
operator|)
expr_stmt|;
name|new
operator|=
literal|1
operator|<<
name|unitno
operator|+
literal|2
operator|<<
operator|(
literal|16
operator|+
name|unitno
operator|*
literal|4
operator|)
expr_stmt|;
name|pci_conf_write
argument_list|(
name|cookie
operator|->
name|tag
argument_list|,
literal|0x48
argument_list|,
operator|(
name|pci_conf_read
argument_list|(
name|cookie
operator|->
name|tag
argument_list|,
literal|0x48
argument_list|)
operator|&
operator|~
name|mask
operator|)
operator||
name|new
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|intel_piix_status
argument_list|(
name|cookie
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/*  	 * if it's an 82371FB, which can't do independent programming of 	 * drive timing, we punt; we're not going to fuss with trying to 	 * coordinate timing modes between drives.  if this is you, get a 	 * new motherboard.  or contribute patches :) 	 * 	 * we do now at least see if the modes set are OK to use.  this should 	 * satisfy the majority of people, with mwdma mode2 drives. 	 */
elseif|else
if|if
condition|(
name|cookie
operator|->
name|type
operator|==
literal|0x12308086
condition|)
block|{
name|u_long
name|word40
decl_stmt|;
comment|/* can drive do PIO 4 and MW DMA 2? */
if|if
condition|(
operator|!
operator|(
name|mwdma_mode
argument_list|(
name|wp
argument_list|)
operator|>=
literal|2
operator|&&
name|pio_mode
argument_list|(
name|wp
argument_list|)
operator|>=
literal|4
operator|)
condition|)
return|return
literal|0
return|;
name|word40
operator|=
name|pci_conf_read
argument_list|(
name|cookie
operator|->
name|tag
argument_list|,
literal|0x40
argument_list|)
expr_stmt|;
name|word40
operator|>>=
name|cookie
operator|->
name|ctlr
operator|*
literal|16
expr_stmt|;
comment|/* Check for timing config usable for DMA on controller */
if|if
condition|(
operator|!
operator|(
operator|(
name|word40
operator|&
literal|0x3300
operator|)
operator|==
literal|0x2300
operator|&&
operator|(
operator|(
name|word40
operator|>>
operator|(
name|cookie
operator|->
name|unit
operator|*
literal|4
operator|)
operator|)
operator|&
literal|1
operator|)
operator|==
literal|1
operator|)
condition|)
return|return
literal|0
return|;
comment|/* Set multiword DMA mode 2 on drive */
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"intel_piix_dmainit: setting multiword DMA mode 2\n"
argument_list|)
expr_stmt|;
name|r
operator|=
name|wdcmd
argument_list|(
name|WDDMA_MDMA2
argument_list|,
name|wdinfo
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|r
condition|)
block|{
name|printf
argument_list|(
literal|"intel_piix_dmainit: setting DMA mode failed\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
comment|/* otherwise, treat it as a PIIX3 and program it for MW DMA mode 2 */
elseif|else
if|if
condition|(
name|mwdma_mode
argument_list|(
name|wp
argument_list|)
operator|>=
literal|2
operator|&&
name|pio_mode
argument_list|(
name|wp
argument_list|)
operator|>=
literal|4
condition|)
block|{
name|u_long
name|mask40
decl_stmt|,
name|mask44
decl_stmt|,
name|new40
decl_stmt|,
name|new44
decl_stmt|;
comment|/*  		 * If SITRE is not set, set it and copy the 		 * appropriate bits into the secondary registers.  Do 		 * both controllers at once. 		 */
if|if
condition|(
operator|(
operator|(
name|pci_conf_read
argument_list|(
name|cookie
operator|->
name|tag
argument_list|,
literal|0x40
argument_list|)
operator|>>
operator|(
literal|16
operator|*
name|cookie
operator|->
name|ctlr
operator|)
operator|)
operator|&
literal|0x4000
operator|)
operator|==
literal|0
condition|)
block|{
name|unsigned
name|int
name|word40
decl_stmt|,
name|word44
decl_stmt|;
name|word40
operator|=
name|pci_conf_read
argument_list|(
name|cookie
operator|->
name|tag
argument_list|,
literal|0x40
argument_list|)
expr_stmt|;
comment|/* copy bits to secondary register */
name|word44
operator|=
name|pci_conf_read
argument_list|(
name|cookie
operator|->
name|tag
argument_list|,
literal|0x44
argument_list|)
expr_stmt|;
comment|/* 			 * I've got a Biostar motherboard with Award 			 * BIOS that sets SITRE and secondary timing 			 * on one controller but not the other. 			 * Bizarre. 			 */
if|if
condition|(
operator|(
name|word40
operator|&
literal|0x4000
operator|)
operator|==
literal|0
condition|)
block|{
name|word44
operator|&=
operator|~
literal|0xf
expr_stmt|;
name|word44
operator||=
operator|(
operator|(
name|word40
operator|&
literal|0x3000
operator|)
operator|>>
literal|10
operator|)
operator||
operator|(
operator|(
name|word40
operator|&
literal|0x0300
operator|)
operator|>>
literal|8
operator|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|word40
operator|&
literal|0x40000000
operator|)
operator|==
literal|0
condition|)
block|{
name|word44
operator|&=
operator|~
literal|0xf0
expr_stmt|;
name|word44
operator||=
operator|(
operator|(
name|word40
operator|&
literal|0x30000000
operator|)
operator|>>
literal|22
operator|)
operator||
operator|(
operator|(
name|word40
operator|&
literal|0x03000000
operator|)
operator|>>
literal|20
operator|)
expr_stmt|;
block|}
comment|/* set SITRE */
name|word40
operator||=
literal|0x40004000
expr_stmt|;
name|pci_conf_write
argument_list|(
name|cookie
operator|->
name|tag
argument_list|,
literal|0x40
argument_list|,
name|word40
argument_list|)
expr_stmt|;
name|pci_conf_write
argument_list|(
name|cookie
operator|->
name|tag
argument_list|,
literal|0x44
argument_list|,
name|word44
argument_list|)
expr_stmt|;
block|}
comment|/* Set multiword DMA mode 2 on drive */
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"intel_piix_dmainit: setting multiword DMA mode 2\n"
argument_list|)
expr_stmt|;
name|r
operator|=
name|wdcmd
argument_list|(
name|WDDMA_MDMA2
argument_list|,
name|wdinfo
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|r
condition|)
block|{
name|printf
argument_list|(
literal|"intel_piix_dmainit: setting DMA mode failed\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/*  		 * backward compatible hardware leaves us with such 		 * twisted masses of software (aka twiddle the 		 * extremely weird register layout on a PIIX3, setting 		 * PIO mode 4 and MWDMA mode 2) 		 */
if|if
condition|(
name|cookie
operator|->
name|unit
operator|==
literal|0
condition|)
block|{
name|mask40
operator|=
literal|0x330f
expr_stmt|;
name|new40
operator|=
literal|0x2307
expr_stmt|;
name|mask44
operator|=
literal|0
expr_stmt|;
name|new44
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|mask40
operator|=
literal|0x00f0
expr_stmt|;
name|new40
operator|=
literal|0x0070
expr_stmt|;
name|mask44
operator|=
literal|0x000f
expr_stmt|;
name|new44
operator|=
literal|0x000b
expr_stmt|;
block|}
if|if
condition|(
name|cookie
operator|->
name|ctlr
condition|)
block|{
name|mask40
operator|<<=
literal|16
expr_stmt|;
name|new40
operator|<<=
literal|16
expr_stmt|;
name|mask44
operator|<<=
literal|4
expr_stmt|;
name|new44
operator|<<=
literal|4
expr_stmt|;
block|}
name|pci_conf_write
argument_list|(
name|cookie
operator|->
name|tag
argument_list|,
literal|0x40
argument_list|,
operator|(
name|pci_conf_read
argument_list|(
name|cookie
operator|->
name|tag
argument_list|,
literal|0x40
argument_list|)
operator|&
operator|~
name|mask40
operator|)
operator||
name|new40
argument_list|)
expr_stmt|;
name|pci_conf_write
argument_list|(
name|cookie
operator|->
name|tag
argument_list|,
literal|0x44
argument_list|,
operator|(
name|pci_conf_read
argument_list|(
name|cookie
operator|->
name|tag
argument_list|,
literal|0x44
argument_list|)
operator|&
operator|~
name|mask44
operator|)
operator||
name|new44
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|intel_piix_status
argument_list|(
name|cookie
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|vendor_fns
name|vs_intel_piix
init|=
block|{
name|intel_piix_dmainit
block|,
name|intel_piix_status
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Generic SFF-8038i code-- all code below here, except for PCI probes,  * more or less conforms to the SFF-8038i spec as extended for PCI.  * There should be no code that goes beyond that feature set below.  */
end_comment

begin_comment
comment|/* XXX mkcookie is overloaded with too many parameters */
end_comment

begin_function
specifier|static
name|struct
name|ide_pci_cookie
modifier|*
name|mkcookie
parameter_list|(
name|int
name|iobase_wd
parameter_list|,
name|int
name|ctlr
parameter_list|,
name|int
name|unit
parameter_list|,
name|int
name|iobase_bm
parameter_list|,
name|pcici_t
name|tag
parameter_list|,
name|pcidi_t
name|type
parameter_list|,
name|struct
name|vendor_fns
modifier|*
name|vp
parameter_list|,
name|int
name|altiobase_wd
parameter_list|)
block|{
name|struct
name|ide_pci_cookie
modifier|*
name|cp
decl_stmt|;
name|cp
operator|=
name|malloc
argument_list|(
sizeof|sizeof
expr|*
name|cp
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cp
condition|)
return|return
literal|0
return|;
name|cp
operator|->
name|iobase_wd
operator|=
name|iobase_wd
expr_stmt|;
name|cp
operator|->
name|ctlr
operator|=
name|ctlr
expr_stmt|;
name|cp
operator|->
name|unit
operator|=
name|unit
expr_stmt|;
name|cp
operator|->
name|tag
operator|=
name|tag
expr_stmt|;
name|cp
operator|->
name|type
operator|=
name|type
expr_stmt|;
name|cp
operator|->
name|iobase_bm
operator|=
name|iobase_bm
expr_stmt|;
name|cp
operator|->
name|altiobase_wd
operator|=
name|altiobase_wd
expr_stmt|;
name|bcopy
argument_list|(
name|vp
argument_list|,
operator|&
name|cp
operator|->
name|vs
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|vendor_fns
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|prdbuf
condition|)
block|{
name|prdbuf
operator|=
name|malloc
argument_list|(
name|PRD_ALLOC_SIZE
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|prdbuf
condition|)
block|{
name|FREE
argument_list|(
name|cp
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|(
operator|(
name|int
operator|)
name|prdbuf
operator|>>
name|PAGE_SHIFT
operator|)
operator|^
operator|(
operator|(
operator|(
name|int
operator|)
name|prdbuf
operator|+
name|PRD_ALLOC_SIZE
operator|-
literal|1
operator|)
operator|>>
name|PAGE_SHIFT
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"ide_pci: prdbuf straddles page boundary, no DMA\n"
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|cp
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|prdbuf
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|prdbuf_next
operator|=
name|prdbuf
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|(
name|char
operator|*
operator|)
name|prdbuf_next
operator|+
name|PRD_BUF_SIZE
operator|)
operator|>
operator|(
operator|(
name|char
operator|*
operator|)
name|prdbuf
operator|+
name|PRD_ALLOC_SIZE
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"ide_pci: mkcookie %04x:%d: no more space for PRDs, no DMA\n"
argument_list|,
name|iobase_wd
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|cp
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|cp
operator|->
name|prd
operator|=
name|prdbuf_next
expr_stmt|;
operator|(
name|char
operator|*
operator|)
name|prdbuf_next
operator|+=
name|PRD_BUF_SIZE
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|softc
operator|.
name|cookies
argument_list|,
name|cp
argument_list|,
name|le
argument_list|)
expr_stmt|;
return|return
name|cp
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|ide_pci_probe
parameter_list|(
name|pcici_t
name|tag
parameter_list|,
name|pcidi_t
name|type
parameter_list|)
block|{
name|u_long
name|data
decl_stmt|;
name|data
operator|=
name|pci_conf_read
argument_list|(
name|tag
argument_list|,
name|PCI_CLASS_REG
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|data
operator|&
name|PCI_CLASS_MASK
operator|)
operator|==
name|PCI_CLASS_MASS_STORAGE
operator|&&
operator|(
operator|(
name|data
operator|&
name|PCI_SUBCLASS_MASK
operator|)
operator|==
literal|0x00010000
operator|||
operator|(
operator|(
name|data
operator|&
name|PCI_SUBCLASS_MASK
operator|)
operator|==
literal|0x00040000
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|type
operator|==
literal|0x71118086
condition|)
return|return
operator|(
literal|"Intel PIIX4 Bus-master IDE controller"
operator|)
return|;
if|if
condition|(
name|type
operator|==
literal|0x70108086
condition|)
return|return
operator|(
literal|"Intel PIIX3 Bus-master IDE controller"
operator|)
return|;
if|if
condition|(
name|type
operator|==
literal|0x12308086
condition|)
return|return
operator|(
literal|"Intel PIIX Bus-master IDE controller"
operator|)
return|;
if|if
condition|(
name|type
operator|==
name|PROMISE_ULTRA33
condition|)
return|return
operator|(
literal|"Promise Ultra/33 IDE controller"
operator|)
return|;
if|if
condition|(
name|type
operator|==
literal|0x05711106
condition|)
return|return
operator|(
literal|"VIA 82C586x (Apollo) Bus-master IDE controller"
operator|)
return|;
if|if
condition|(
name|data
operator|&
literal|0x8000
condition|)
return|return
operator|(
literal|"PCI IDE controller (busmaster capable)"
operator|)
return|;
ifndef|#
directive|ifndef
name|CMD640
comment|/* 		 * XXX the CMD640B hack should be better integrated, or 		 * something. 		 */
else|else
return|return
operator|(
literal|"PCI IDE controller (not busmaster capable)"
operator|)
return|;
endif|#
directive|endif
block|}
empty_stmt|;
return|return
operator|(
operator|(
name|char
operator|*
operator|)
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ide_pci_attach
parameter_list|(
name|pcici_t
name|tag
parameter_list|,
name|int
name|unit
parameter_list|)
block|{
name|u_long
name|class
decl_stmt|,
name|cmd
decl_stmt|;
name|int
name|bmista_1
decl_stmt|,
name|bmista_2
decl_stmt|;
name|int
name|iobase_wd_1
decl_stmt|,
name|iobase_wd_2
decl_stmt|,
name|iobase_bm_1
decl_stmt|,
name|iobase_bm_2
decl_stmt|;
name|int
name|altiobase_wd_1
decl_stmt|,
name|altiobase_wd_2
decl_stmt|;
name|struct
name|vendor_fns
modifier|*
name|vp
decl_stmt|;
name|pcidi_t
name|type
decl_stmt|;
name|struct
name|ide_pci_cookie
modifier|*
name|cookie
decl_stmt|;
name|int
name|ctlridx
decl_stmt|;
name|ctlridx
operator|=
name|unit
operator|*
literal|2
expr_stmt|;
comment|/* set up vendor-specific stuff */
name|type
operator|=
name|pci_conf_read
argument_list|(
name|tag
argument_list|,
name|PCI_ID_REG
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|!=
name|PROMISE_ULTRA33
condition|)
block|{
comment|/* is it busmaster capable?  bail if not */
name|class
operator|=
name|pci_conf_read
argument_list|(
name|tag
argument_list|,
name|PCI_CLASS_REG
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|class
operator|&
literal|0x8000
operator|)
condition|)
block|{
return|return;
block|}
comment|/* is it enabled and is busmastering turned on? */
name|cmd
operator|=
name|pci_conf_read
argument_list|(
name|tag
argument_list|,
name|PCI_COMMAND_STATUS_REG
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cmd
operator|&
literal|5
operator|)
operator|!=
literal|5
condition|)
block|{
return|return;
block|}
block|}
switch|switch
condition|(
name|type
condition|)
block|{
case|case
literal|0x71118086
case|:
case|case
literal|0x70108086
case|:
case|case
literal|0x12308086
case|:
comment|/* Intel PIIX, PIIX3, PIIX4 */
name|vp
operator|=
operator|&
name|vs_intel_piix
expr_stmt|;
break|break;
case|case
literal|0x5711106
case|:
comment|/* VIA Apollo chipset family */
name|vp
operator|=
operator|&
name|vs_via_571
expr_stmt|;
break|break;
case|case
name|PROMISE_ULTRA33
case|:
comment|/* Promise controllers */
name|vp
operator|=
operator|&
name|vs_promise
expr_stmt|;
break|break;
default|default:
comment|/* everybody else */
name|vp
operator|=
operator|&
name|vs_generic
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|type
operator|!=
name|PROMISE_ULTRA33
condition|)
block|{
if|if
condition|(
operator|(
name|class
operator|&
literal|0x100
operator|)
operator|==
literal|0
condition|)
block|{
name|iobase_wd_1
operator|=
name|IO_WD1
expr_stmt|;
name|altiobase_wd_1
operator|=
name|iobase_wd_1
operator|+
name|wd_altsts
expr_stmt|;
block|}
else|else
block|{
name|iobase_wd_1
operator|=
name|pci_conf_read
argument_list|(
name|tag
argument_list|,
literal|0x10
argument_list|)
operator|&
literal|0xfffc
expr_stmt|;
name|altiobase_wd_1
operator|=
name|pci_conf_read
argument_list|(
name|tag
argument_list|,
literal|0x14
argument_list|)
operator|&
literal|0xfffc
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|class
operator|&
literal|0x400
operator|)
operator|==
literal|0
condition|)
block|{
name|iobase_wd_2
operator|=
name|IO_WD2
expr_stmt|;
name|altiobase_wd_2
operator|=
name|iobase_wd_2
operator|+
name|wd_altsts
expr_stmt|;
block|}
else|else
block|{
name|iobase_wd_2
operator|=
name|pci_conf_read
argument_list|(
name|tag
argument_list|,
literal|0x18
argument_list|)
operator|&
literal|0xfffc
expr_stmt|;
name|altiobase_wd_2
operator|=
name|pci_conf_read
argument_list|(
name|tag
argument_list|,
literal|0x1c
argument_list|)
operator|&
literal|0xfffc
expr_stmt|;
block|}
block|}
else|else
block|{
name|iobase_wd_1
operator|=
name|pci_conf_read
argument_list|(
name|tag
argument_list|,
literal|0x10
argument_list|)
operator|&
literal|0xfffc
expr_stmt|;
name|altiobase_wd_1
operator|=
name|pci_conf_read
argument_list|(
name|tag
argument_list|,
literal|0x14
argument_list|)
operator|&
literal|0xfffc
expr_stmt|;
name|iobase_wd_2
operator|=
name|pci_conf_read
argument_list|(
name|tag
argument_list|,
literal|0x18
argument_list|)
operator|&
literal|0xfffc
expr_stmt|;
name|altiobase_wd_2
operator|=
name|pci_conf_read
argument_list|(
name|tag
argument_list|,
literal|0x1c
argument_list|)
operator|&
literal|0xfffc
expr_stmt|;
block|}
name|iobase_bm_1
operator|=
name|pci_conf_read
argument_list|(
name|tag
argument_list|,
literal|0x20
argument_list|)
operator|&
literal|0xfffc
expr_stmt|;
name|iobase_bm_2
operator|=
name|iobase_bm_1
operator|+
name|SFF8038_CTLR_1
expr_stmt|;
if|if
condition|(
name|iobase_bm_1
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"ide_pci: BIOS has not configured busmaster I/O address,\n\ ide_pci:  giving up\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|wddma
index|[
name|unit
index|]
operator|.
name|wdd_candma
operator|=
name|ide_pci_candma
expr_stmt|;
name|wddma
index|[
name|unit
index|]
operator|.
name|wdd_dmainit
operator|=
name|ide_pci_dmainit
expr_stmt|;
name|wddma
index|[
name|unit
index|]
operator|.
name|wdd_dmaverify
operator|=
name|ide_pci_dmaverify
expr_stmt|;
name|wddma
index|[
name|unit
index|]
operator|.
name|wdd_dmaprep
operator|=
name|ide_pci_dmasetup
expr_stmt|;
name|wddma
index|[
name|unit
index|]
operator|.
name|wdd_dmastart
operator|=
name|ide_pci_dmastart
expr_stmt|;
name|wddma
index|[
name|unit
index|]
operator|.
name|wdd_dmadone
operator|=
name|ide_pci_dmadone
expr_stmt|;
name|wddma
index|[
name|unit
index|]
operator|.
name|wdd_dmastatus
operator|=
name|ide_pci_status
expr_stmt|;
name|wddma
index|[
name|unit
index|]
operator|.
name|wdd_iobase
operator|=
name|ide_pci_iobase
expr_stmt|;
name|wddma
index|[
name|unit
index|]
operator|.
name|wdd_altiobase
operator|=
name|ide_pci_altiobase
expr_stmt|;
comment|/* 	 * This code below is mighty bogus.  The config entries for the 	 * isa_devtab_bio are plugged in before the standard ISA bios scan. 	 * This is our "hack" way to simulate a dynamic assignment of I/O 	 * addresses, from a PCI device to an ISA probe.  Sorry :-). 	 */
if|if
condition|(
name|iobase_wd_1
operator|!=
name|IO_WD1
condition|)
block|{
name|struct
name|isa_device
modifier|*
name|dvp
decl_stmt|,
modifier|*
name|dvp1
decl_stmt|,
modifier|*
name|dvup
decl_stmt|;
for|for
control|(
name|dvp
operator|=
name|isa_devtab_bio
init|;
name|dvp
operator|->
name|id_id
operator|!=
literal|0
condition|;
name|dvp
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|dvp
operator|->
name|id_driver
operator|==
operator|&
name|wdcdriver
operator|)
operator|&&
operator|(
name|dvp
operator|->
name|id_iobase
operator|==
literal|0
operator|)
condition|)
block|{
name|int
name|biotabunit
decl_stmt|;
name|biotabunit
operator|=
name|dvp
operator|->
name|id_unit
operator|*
literal|2
expr_stmt|;
name|dvp
operator|->
name|id_iobase
operator|=
name|iobase_wd_1
expr_stmt|;
name|dvp1
operator|=
name|dvp
operator|+
literal|1
expr_stmt|;
name|dvp1
operator|->
name|id_iobase
operator|=
name|iobase_wd_2
expr_stmt|;
name|printf
argument_list|(
literal|"ide_pci%d: adding drives to controller %d:"
argument_list|,
name|unit
argument_list|,
name|biotabunit
argument_list|)
expr_stmt|;
for|for
control|(
name|dvup
operator|=
name|isa_biotab_wdc
init|;
name|dvup
operator|->
name|id_id
operator|!=
literal|0
condition|;
name|dvup
operator|++
control|)
block|{
if|if
condition|(
name|dvup
operator|->
name|id_driver
operator|!=
operator|&
name|wdcdriver
condition|)
continue|continue;
if|if
condition|(
name|dvup
operator|->
name|id_unit
operator|!=
name|biotabunit
condition|)
continue|continue;
name|dvup
operator|->
name|id_iobase
operator|=
name|dvp
operator|->
name|id_iobase
expr_stmt|;
name|printf
argument_list|(
literal|" %d"
argument_list|,
name|dvup
operator|->
name|id_unit
argument_list|)
expr_stmt|;
name|dvup
operator|++
expr_stmt|;
name|pci_map_int
argument_list|(
name|tag
argument_list|,
name|wdintr
argument_list|,
operator|(
name|void
operator|*
operator|)
name|dvp
operator|->
name|id_unit
argument_list|,
operator|&
name|bio_imask
argument_list|)
expr_stmt|;
if|if
condition|(
name|dvup
operator|->
name|id_id
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|dvup
operator|->
name|id_unit
operator|==
name|biotabunit
operator|+
literal|1
condition|)
block|{
name|dvup
operator|->
name|id_iobase
operator|=
name|dvp
operator|->
name|id_iobase
expr_stmt|;
name|printf
argument_list|(
literal|" %d"
argument_list|,
name|dvup
operator|->
name|id_unit
argument_list|)
expr_stmt|;
name|dvup
operator|++
expr_stmt|;
if|if
condition|(
name|dvup
operator|->
name|id_id
operator|==
literal|0
condition|)
block|{
name|iobase_wd_2
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|dvup
operator|->
name|id_unit
operator|==
name|biotabunit
operator|+
literal|2
condition|)
block|{
name|pci_map_int
argument_list|(
name|tag
argument_list|,
name|wdintr
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|int
operator|)
name|dvp
operator|->
name|id_unit
operator|+
literal|1
operator|)
argument_list|,
operator|&
name|bio_imask
argument_list|)
expr_stmt|;
name|dvup
operator|->
name|id_iobase
operator|=
name|dvp1
operator|->
name|id_iobase
expr_stmt|;
name|printf
argument_list|(
literal|" %d"
argument_list|,
name|dvup
operator|->
name|id_unit
argument_list|)
expr_stmt|;
name|dvup
operator|++
expr_stmt|;
if|if
condition|(
name|dvup
operator|->
name|id_id
operator|==
literal|0
condition|)
block|{
break|break;
block|}
block|}
if|if
condition|(
name|dvup
operator|->
name|id_unit
operator|==
name|biotabunit
operator|+
literal|3
condition|)
block|{
name|pci_map_int
argument_list|(
name|tag
argument_list|,
name|wdintr
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|int
operator|)
name|dvp
operator|->
name|id_unit
operator|+
literal|1
operator|)
argument_list|,
operator|&
name|bio_imask
argument_list|)
expr_stmt|;
name|dvup
operator|->
name|id_iobase
operator|=
name|dvp1
operator|->
name|id_iobase
expr_stmt|;
name|printf
argument_list|(
literal|" %d"
argument_list|,
name|dvup
operator|->
name|id_unit
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
name|bmista_1
operator|=
name|inb
argument_list|(
name|iobase_bm_1
operator|+
name|BMISTA_PORT
argument_list|)
expr_stmt|;
name|bmista_2
operator|=
name|inb
argument_list|(
name|iobase_bm_2
operator|+
name|BMISTA_PORT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ide_pci_softc_cookies_initted
condition|)
block|{
name|LIST_INIT
argument_list|(
operator|&
name|softc
operator|.
name|cookies
argument_list|)
expr_stmt|;
name|ide_pci_softc_cookies_initted
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|iobase_wd_1
operator|!=
literal|0
condition|)
block|{
name|cookie
operator|=
name|mkcookie
argument_list|(
name|iobase_wd_1
argument_list|,
name|ctlridx
argument_list|,
literal|0
argument_list|,
name|iobase_bm_1
argument_list|,
name|tag
argument_list|,
name|type
argument_list|,
name|vp
argument_list|,
name|altiobase_wd_1
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|vp
operator|->
name|vendor_status
argument_list|(
name|cookie
argument_list|)
expr_stmt|;
name|cookie
operator|=
name|mkcookie
argument_list|(
name|iobase_wd_1
argument_list|,
name|ctlridx
argument_list|,
literal|1
argument_list|,
name|iobase_bm_1
argument_list|,
name|tag
argument_list|,
name|type
argument_list|,
name|vp
argument_list|,
name|altiobase_wd_1
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
block|{
name|vp
operator|->
name|vendor_status
argument_list|(
name|cookie
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"ide_pci: busmaster 0 status: %02x from port: %08x\n"
argument_list|,
name|bmista_1
argument_list|,
name|iobase_bm_1
operator|+
name|BMISTA_PORT
argument_list|)
expr_stmt|;
if|if
condition|(
name|bmista_1
operator|&
name|BMISTA_DMA0CAP
condition|)
name|printf
argument_list|(
literal|"ide_pci: ide0:0 has been configured for DMA by BIOS\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|bmista_1
operator|&
name|BMISTA_DMA1CAP
condition|)
name|printf
argument_list|(
literal|"ide_pci: ide0:1 has been configured for DMA by BIOS\n"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|bmista_1
operator|&
name|BMISTA_SIMPLEX
operator|||
name|bmista_2
operator|&
name|BMISTA_SIMPLEX
condition|)
block|{
name|printf
argument_list|(
literal|"ide_pci: controller is simplex, no DMA on secondary channel\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|iobase_wd_2
operator|!=
literal|0
condition|)
block|{
name|cookie
operator|=
name|mkcookie
argument_list|(
name|iobase_wd_2
argument_list|,
name|ctlridx
operator|+
literal|1
argument_list|,
literal|0
argument_list|,
name|iobase_bm_2
argument_list|,
name|tag
argument_list|,
name|type
argument_list|,
name|vp
argument_list|,
name|altiobase_wd_2
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|vp
operator|->
name|vendor_status
argument_list|(
name|cookie
argument_list|)
expr_stmt|;
name|cookie
operator|=
name|mkcookie
argument_list|(
name|iobase_wd_2
argument_list|,
name|ctlridx
operator|+
literal|1
argument_list|,
literal|1
argument_list|,
name|iobase_bm_2
argument_list|,
name|tag
argument_list|,
name|type
argument_list|,
name|vp
argument_list|,
name|altiobase_wd_2
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
block|{
name|vp
operator|->
name|vendor_status
argument_list|(
name|cookie
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"ide_pci: busmaster 1 status: %02x from port: %08x\n"
argument_list|,
name|bmista_2
argument_list|,
name|iobase_bm_2
operator|+
name|BMISTA_PORT
argument_list|)
expr_stmt|;
if|if
condition|(
name|bmista_2
operator|&
name|BMISTA_DMA0CAP
condition|)
name|printf
argument_list|(
literal|"ide_pci: ide1:0 has been configured for DMA by BIOS\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|bmista_2
operator|&
name|BMISTA_DMA1CAP
condition|)
name|printf
argument_list|(
literal|"ide_pci: ide1:1 has been configured for DMA by BIOS\n"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_decl_stmt
specifier|static
name|u_long
name|ide_pci_count
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|pci_device
name|ide_pci_device
init|=
block|{
literal|"ide_pci"
block|,
name|ide_pci_probe
block|,
name|ide_pci_attach
block|,
operator|&
name|ide_pci_count
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DATA_SET
argument_list|(
name|pcidevice_set
argument_list|,
name|ide_pci_device
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Return a cookie if we can do DMA on the specified (iobase_wd, unit).  */
end_comment

begin_function
specifier|static
name|void
modifier|*
name|ide_pci_candma
parameter_list|(
name|int
name|iobase_wd
parameter_list|,
name|int
name|unit
parameter_list|)
block|{
name|struct
name|ide_pci_cookie
modifier|*
name|cp
decl_stmt|;
name|cp
operator|=
name|softc
operator|.
name|cookies
operator|.
name|lh_first
expr_stmt|;
while|while
condition|(
name|cp
condition|)
block|{
if|if
condition|(
name|cp
operator|->
name|ctlr
operator|==
name|unit
operator|&&
operator|(
operator|(
name|iobase_wd
operator|==
literal|0
operator|)
operator|||
operator|(
name|cp
operator|->
name|iobase_wd
operator|==
name|iobase_wd
operator|)
operator|)
condition|)
break|break;
name|cp
operator|=
name|cp
operator|->
name|le
operator|.
name|le_next
expr_stmt|;
block|}
return|return
name|cp
return|;
block|}
end_function

begin_comment
comment|/*  * Initialize controller and drive for DMA operation, including timing modes.  * Uses data passed from the wd driver and a callback function to initialize  * timing modes on the drive.  */
end_comment

begin_function
specifier|static
name|int
name|ide_pci_dmainit
parameter_list|(
name|void
modifier|*
name|cookie
parameter_list|,
name|struct
name|wdparams
modifier|*
name|wp
parameter_list|,
name|int
function_decl|(
modifier|*
name|wdcmd
function_decl|)
parameter_list|(
name|int
parameter_list|,
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
name|wdinfo
parameter_list|)
block|{
name|struct
name|ide_pci_cookie
modifier|*
name|cp
init|=
name|cookie
decl_stmt|;
comment|/*  	 * If the controller status indicates that DMA is configured already, 	 * we flounce happily away 	 */
if|if
condition|(
name|inb
argument_list|(
name|cp
operator|->
name|iobase_bm
operator|+
name|BMISTA_PORT
argument_list|)
operator|&
operator|(
operator|(
name|cp
operator|->
name|unit
operator|==
literal|0
operator|)
condition|?
name|BMISTA_DMA0CAP
else|:
name|BMISTA_DMA1CAP
operator|)
condition|)
return|return
literal|1
return|;
comment|/* We take a stab at it with device-dependent code */
return|return
operator|(
name|cp
operator|->
name|vs
operator|.
name|vendor_dmainit
argument_list|(
name|cp
argument_list|,
name|wp
argument_list|,
name|wdcmd
argument_list|,
name|wdinfo
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Verify that controller can handle a dma request for cp.  Should  * not affect any hardware or driver state.  */
end_comment

begin_function
specifier|static
name|int
name|ide_pci_dmaverify
parameter_list|(
name|void
modifier|*
name|xcp
parameter_list|,
name|char
modifier|*
name|vaddr
parameter_list|,
name|u_long
name|count
parameter_list|,
name|int
name|dir
parameter_list|)
block|{
name|int
name|badfu
decl_stmt|;
comment|/* 	 * check for nonaligned or odd-length Stuff 	 */
name|badfu
operator|=
operator|(
operator|(
name|unsigned
name|int
operator|)
name|vaddr
operator|&
literal|1
operator|)
operator|||
operator|(
name|count
operator|&
literal|1
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
name|badfu
condition|)
block|{
name|printf
argument_list|(
literal|"ide_pci: dmaverify odd vaddr or length, "
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"vaddr = %08x length = %08x\n"
argument_list|,
operator|(
name|int
operator|)
name|vaddr
argument_list|,
name|count
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return
operator|(
operator|!
name|badfu
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Set up DMA for cp.  It is the responsibility of the caller  * to ensure that the controller is idle before this routine  * is called.  */
end_comment

begin_function
specifier|static
name|int
name|ide_pci_dmasetup
parameter_list|(
name|void
modifier|*
name|xcp
parameter_list|,
name|char
modifier|*
name|vaddr
parameter_list|,
name|u_long
name|vcount
parameter_list|,
name|int
name|dir
parameter_list|)
block|{
name|struct
name|ide_pci_cookie
modifier|*
name|cp
init|=
name|xcp
decl_stmt|;
name|struct
name|ide_pci_prd
modifier|*
name|prd
decl_stmt|;
name|int
name|i
decl_stmt|;
name|u_long
name|firstpage
decl_stmt|;
name|u_long
name|prd_base
decl_stmt|,
name|prd_count
decl_stmt|;
name|u_long
name|nbase
decl_stmt|,
name|ncount
decl_stmt|,
name|nend
decl_stmt|;
name|int
name|iobase_bm
decl_stmt|;
name|u_long
name|count
decl_stmt|,
name|checkcount
decl_stmt|;
name|prd
operator|=
name|cp
operator|->
name|prd
expr_stmt|;
name|count
operator|=
name|vcount
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
name|iobase_bm
operator|=
name|cp
operator|->
name|iobase_bm
expr_stmt|;
if|if
condition|(
name|count
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"ide_pci: dmasetup 0-length transfer, "
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"vaddr = %08x length = %08x\n"
argument_list|,
operator|(
name|int
operator|)
name|vaddr
argument_list|,
name|count
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* Generate first PRD entry, which may be non-aligned. */
name|firstpage
operator|=
name|PAGE_SIZE
operator|-
operator|(
operator|(
name|u_long
operator|)
name|vaddr
operator|&
name|PAGE_MASK
operator|)
expr_stmt|;
name|prd_base
operator|=
name|vtophys
argument_list|(
name|vaddr
argument_list|)
expr_stmt|;
name|prd_count
operator|=
name|MIN
argument_list|(
name|count
argument_list|,
name|firstpage
argument_list|)
expr_stmt|;
name|vaddr
operator|+=
name|prd_count
expr_stmt|;
name|count
operator|-=
name|prd_count
expr_stmt|;
comment|/* Step through virtual pages, coalescing as needed. */
while|while
condition|(
name|count
condition|)
block|{
name|nbase
operator|=
name|vtophys
argument_list|(
name|vaddr
argument_list|)
expr_stmt|;
name|ncount
operator|=
name|MIN
argument_list|(
name|count
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
name|nend
operator|=
name|nbase
operator|+
name|ncount
expr_stmt|;
comment|/*  		 * Coalesce if physically contiguous and not crossing 		 * 64k boundary.  		 */
if|if
condition|(
operator|(
name|prd_base
operator|+
name|prd_count
operator|==
name|nbase
operator|)
operator|&&
operator|(
operator|(
operator|(
operator|(
name|nend
operator|-
literal|1
operator|)
operator|^
name|prd_base
operator|)
operator|&
operator|~
literal|0xffff
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
name|prd_count
operator|+=
name|ncount
expr_stmt|;
block|}
else|else
block|{
name|prd
index|[
name|i
index|]
operator|.
name|prd_base
operator|=
name|prd_base
expr_stmt|;
name|prd
index|[
name|i
index|]
operator|.
name|prd_count
operator|=
operator|(
name|prd_count
operator|&
literal|0xffff
operator|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|i
operator|>=
name|PRD_MAX_SEGS
condition|)
block|{
name|printf
argument_list|(
literal|"wd82371: too many segments in PRD table\n"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|prd_base
operator|=
name|nbase
expr_stmt|;
name|prd_count
operator|=
name|ncount
expr_stmt|;
block|}
name|vaddr
operator|+=
name|ncount
expr_stmt|;
name|count
operator|-=
name|ncount
expr_stmt|;
block|}
comment|/* Write last PRD entry. */
name|prd
index|[
name|i
index|]
operator|.
name|prd_base
operator|=
name|prd_base
expr_stmt|;
name|prd
index|[
name|i
index|]
operator|.
name|prd_count
operator|=
operator|(
name|prd_count
operator|&
literal|0xffff
operator|)
operator||
name|PRD_EOT_BIT
expr_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
comment|/* sanity check the transfer for length and page-alignment, at least */
name|checkcount
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
condition|;
name|i
operator|++
control|)
block|{
name|unsigned
name|int
name|modcount
decl_stmt|;
name|modcount
operator|=
name|prd
index|[
name|i
index|]
operator|.
name|prd_count
operator|&
literal|0xffffe
expr_stmt|;
if|if
condition|(
name|modcount
operator|==
literal|0
condition|)
name|modcount
operator|=
literal|0x10000
expr_stmt|;
name|checkcount
operator|+=
name|modcount
expr_stmt|;
if|if
condition|(
name|i
operator|!=
literal|0
operator|&&
operator|(
operator|(
name|prd
index|[
name|i
index|]
operator|.
name|prd_base
operator|&
name|PAGE_MASK
operator|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"ide_pci: dmasetup() diagnostic fails-- unaligned page\n"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|prd
index|[
name|i
index|]
operator|.
name|prd_count
operator|&
name|PRD_EOT_BIT
condition|)
break|break;
block|}
if|if
condition|(
name|checkcount
operator|!=
name|vcount
condition|)
block|{
name|printf
argument_list|(
literal|"ide_pci: dmasetup() diagnostic fails-- bad length\n"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
endif|#
directive|endif
comment|/* Set up PRD base register */
name|outl
argument_list|(
name|iobase_bm
operator|+
name|BMIDTP_PORT
argument_list|,
name|vtophys
argument_list|(
name|prd
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Set direction of transfer */
name|outb
argument_list|(
name|iobase_bm
operator|+
name|BMICOM_PORT
argument_list|,
operator|(
name|dir
operator|==
name|B_READ
operator|)
condition|?
name|BMICOM_READ_WRITE
else|:
literal|0
argument_list|)
expr_stmt|;
comment|/* Clear interrupt and error bits */
name|outb
argument_list|(
name|iobase_bm
operator|+
name|BMISTA_PORT
argument_list|,
operator|(
name|inb
argument_list|(
name|iobase_bm
operator|+
name|BMISTA_PORT
argument_list|)
operator||
operator|(
name|BMISTA_INTERRUPT
operator||
name|BMISTA_DMA_ERROR
operator|)
operator|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ide_pci_dmastart
parameter_list|(
name|void
modifier|*
name|xcp
parameter_list|)
block|{
name|struct
name|ide_pci_cookie
modifier|*
name|cp
init|=
name|xcp
decl_stmt|;
name|int
name|iobase_bm
decl_stmt|;
name|iobase_bm
operator|=
name|cp
operator|->
name|iobase_bm
expr_stmt|;
name|outb
argument_list|(
name|iobase_bm
operator|+
name|BMICOM_PORT
argument_list|,
name|inb
argument_list|(
name|iobase_bm
operator|+
name|BMICOM_PORT
argument_list|)
operator||
name|BMICOM_STOP_START
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|ide_pci_dmadone
parameter_list|(
name|void
modifier|*
name|xcp
parameter_list|)
block|{
name|struct
name|ide_pci_cookie
modifier|*
name|cp
init|=
name|xcp
decl_stmt|;
name|int
name|iobase_bm
decl_stmt|,
name|status
decl_stmt|;
name|status
operator|=
name|ide_pci_status
argument_list|(
name|xcp
argument_list|)
expr_stmt|;
name|iobase_bm
operator|=
name|cp
operator|->
name|iobase_bm
expr_stmt|;
name|outb
argument_list|(
name|iobase_bm
operator|+
name|BMICOM_PORT
argument_list|,
name|inb
argument_list|(
name|iobase_bm
operator|+
name|BMICOM_PORT
argument_list|)
operator|&
operator|~
name|BMICOM_STOP_START
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ide_pci_status
parameter_list|(
name|void
modifier|*
name|xcp
parameter_list|)
block|{
name|struct
name|ide_pci_cookie
modifier|*
name|cp
init|=
name|xcp
decl_stmt|;
name|int
name|iobase_bm
decl_stmt|,
name|status
decl_stmt|,
name|bmista
decl_stmt|;
name|status
operator|=
literal|0
expr_stmt|;
name|iobase_bm
operator|=
name|cp
operator|->
name|iobase_bm
expr_stmt|;
name|bmista
operator|=
name|inb
argument_list|(
name|iobase_bm
operator|+
name|BMISTA_PORT
argument_list|)
expr_stmt|;
if|if
condition|(
name|bmista
operator|&
name|BMISTA_INTERRUPT
condition|)
name|status
operator||=
name|WDDS_INTERRUPT
expr_stmt|;
if|if
condition|(
name|bmista
operator|&
name|BMISTA_DMA_ERROR
condition|)
name|status
operator||=
name|WDDS_ERROR
expr_stmt|;
if|if
condition|(
name|bmista
operator|&
name|BMISTA_DMA_ACTIVE
condition|)
name|status
operator||=
name|WDDS_ACTIVE
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ide_pci_altiobase
parameter_list|(
name|void
modifier|*
name|xcp
parameter_list|)
block|{
name|struct
name|ide_pci_cookie
modifier|*
name|cp
init|=
name|xcp
decl_stmt|;
if|if
condition|(
name|cp
operator|==
literal|0
condition|)
block|{
return|return
literal|0
return|;
block|}
else|else
block|{
return|return
name|cp
operator|->
name|altiobase_wd
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|ide_pci_iobase
parameter_list|(
name|void
modifier|*
name|xcp
parameter_list|)
block|{
name|struct
name|ide_pci_cookie
modifier|*
name|cp
init|=
name|xcp
decl_stmt|;
if|if
condition|(
name|cp
operator|==
literal|0
condition|)
block|{
return|return
literal|0
return|;
block|}
else|else
block|{
return|return
name|cp
operator|->
name|iobase_wd
return|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NPCI> 0 */
end_comment

end_unit

