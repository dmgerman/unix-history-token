begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright 1996 Massachusetts Institute of Technology  *  * Permission to use, copy, modify, and distribute this software and  * its documentation for any purpose and without fee is hereby  * granted, provided that both the above copyright notice and this  * permission notice appear in all copies, that both the above  * copyright notice and this permission notice appear in all  * supporting documentation, and that the name of M.I.T. not be used  * in advertising or publicity pertaining to distribution of the  * software without specific, written prior permission.  M.I.T. makes  * no representations about the suitability of this software for any  * purpose.  It is provided "as is" without express or implied  * warranty.  *   * THIS SOFTWARE IS PROVIDED BY M.I.T. ``AS IS''.  M.I.T. DISCLAIMS  * ALL EXPRESS OR IMPLIED WARRANTIES WITH REGARD TO THIS SOFTWARE,  * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF  * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT  * SHALL M.I.T. BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF  * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,  * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT  * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *      From: wd82371.c,v 1.5.2.1 1996/11/16 21:19:51 phk Exp $  *      $Id: ide_pci.c,v 1.2 1997/08/02 14:33:09 bde Exp $  */
end_comment

begin_include
include|#
directive|include
file|"pci.h"
end_include

begin_if
if|#
directive|if
name|NPCI
operator|>
literal|0
end_if

begin_include
include|#
directive|include
file|"opt_wd.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/buf.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/wdreg.h>
end_include

begin_include
include|#
directive|include
file|<pci/pcivar.h>
end_include

begin_include
include|#
directive|include
file|<pci/pcireg.h>
end_include

begin_include
include|#
directive|include
file|<pci/ide_pcireg.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|MIN
end_ifndef

begin_define
define|#
directive|define
name|MIN
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|(((a)<(b))?(a):(b))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_struct_decl
struct_decl|struct
name|ide_pci_cookie
struct_decl|;
end_struct_decl

begin_comment
comment|/* structs vendor_fns, ide_pci_cookie are recursive */
end_comment

begin_struct
struct|struct
name|vendor_fns
block|{
name|int
function_decl|(
modifier|*
name|vendor_dmainit
function_decl|)
comment|/* initialize DMA controller and drive */
parameter_list|(
name|struct
name|ide_pci_cookie
modifier|*
name|cookie
parameter_list|,
name|struct
name|wdparams
modifier|*
name|wp
parameter_list|,
name|int
function_decl|(
modifier|*
name|wdcmd
function_decl|)
parameter_list|(
name|int
parameter_list|,
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
name|void
function_decl|(
modifier|*
name|vendor_status
function_decl|)
comment|/* prints off DMA timing info */
parameter_list|(
name|struct
name|ide_pci_cookie
modifier|*
name|cookie
parameter_list|)
function_decl|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * XXX the fact that this list keeps all kinds of info on PCI controllers  * is pretty grotty-- much of this should be replaced by a proper integration  * of PCI probes into the wd driver.  * XXX if we're going to support native-PCI controllers, we also need to  * keep the address of the IDE control block register, which is something wd.c  * needs to know, which is why this info is in the wrong place.  */
end_comment

begin_struct
struct|struct
name|ide_pci_cookie
block|{
name|LIST_ENTRY
argument_list|(
argument|ide_pci_cookie
argument_list|)
name|le
expr_stmt|;
name|int
name|iobase_wd
decl_stmt|;
name|int
name|ctlr
decl_stmt|;
comment|/* pri/sec controller on this PCI IDE interface */
name|int
name|unit
decl_stmt|;
name|int
name|iobase_bm
decl_stmt|;
comment|/* SFF-8038 control registers */
name|pcici_t
name|tag
decl_stmt|;
name|pcidi_t
name|type
decl_stmt|;
name|struct
name|ide_pci_prd
modifier|*
name|prd
decl_stmt|;
name|struct
name|vendor_fns
name|vs
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|ide_pci_softc
block|{
name|LIST_HEAD
argument_list|(
argument_list|,
argument|ide_pci_cookie
argument_list|)
name|cookies
expr_stmt|;
block|}
struct|;
end_struct

begin_function_decl
specifier|static
name|int
name|generic_dmainit
parameter_list|(
name|struct
name|ide_pci_cookie
modifier|*
name|cookie
parameter_list|,
name|struct
name|wdparams
modifier|*
name|wp
parameter_list|,
name|int
function_decl|(
modifier|*
name|wdcmd
function_decl|)
parameter_list|(
name|int
parameter_list|,
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
name|wdinfo
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|generic_status
parameter_list|(
name|struct
name|ide_pci_cookie
modifier|*
name|cookie
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|via_571_status
parameter_list|(
name|struct
name|ide_pci_cookie
modifier|*
name|cookie
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|intel_piix_dump_drive
parameter_list|(
name|char
modifier|*
name|ctlr
parameter_list|,
name|int
name|sitre
parameter_list|,
name|int
name|is_piix4
parameter_list|,
name|int
name|word40
parameter_list|,
name|int
name|word44
parameter_list|,
name|int
name|word48
parameter_list|,
name|int
name|word4a
parameter_list|,
name|int
name|drive
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|intel_piix_status
parameter_list|(
name|struct
name|ide_pci_cookie
modifier|*
name|cookie
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|intel_piix_dmainit
parameter_list|(
name|struct
name|ide_pci_cookie
modifier|*
name|cookie
parameter_list|,
name|struct
name|wdparams
modifier|*
name|wp
parameter_list|,
name|int
function_decl|(
modifier|*
name|wdcmd
function_decl|)
parameter_list|(
name|int
parameter_list|,
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
name|wdinfo
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|ide_pci_cookie
modifier|*
name|mkcookie
parameter_list|(
name|int
name|iobase_wd
parameter_list|,
name|int
name|ctlr
parameter_list|,
name|int
name|unit
parameter_list|,
name|int
name|iobase_bm
parameter_list|,
name|pcici_t
name|tag
parameter_list|,
name|pcidi_t
name|type
parameter_list|,
name|struct
name|vendor_fns
modifier|*
name|vp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ide_pci_attach
parameter_list|(
name|pcici_t
name|tag
parameter_list|,
name|int
name|unit
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
modifier|*
name|ide_pci_candma
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ide_pci_dmainit
parameter_list|(
name|void
modifier|*
parameter_list|,
name|struct
name|wdparams
modifier|*
parameter_list|,
name|int
function_decl|(
modifier|*
function_decl|)
parameter_list|(
name|int
parameter_list|,
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ide_pci_dmaverify
parameter_list|(
name|void
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|u_long
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ide_pci_dmasetup
parameter_list|(
name|void
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|u_long
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ide_pci_dmastart
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ide_pci_dmadone
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ide_pci_status
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ide_pci_timing
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|struct
name|ide_pci_softc
name|softc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ide_pci_softc_cookies_initted
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * PRD_ALLOC_SIZE should be something that will not be allocated across a 64k  * boundary.  * PRD_MAX_SEGS is defined to be the maximum number of segments required for  * a transfer on an IDE drive, for an xfer that is linear in virtual memory.  * PRD_BUF_SIZE is the size of the buffer needed for a PRD table.  */
end_comment

begin_define
define|#
directive|define
name|PRD_ALLOC_SIZE
value|PAGE_SIZE
end_define

begin_define
define|#
directive|define
name|PRD_MAX_SEGS
value|((256 * 512 / PAGE_SIZE) + 1)
end_define

begin_define
define|#
directive|define
name|PRD_BUF_SIZE
value|PRD_MAX_SEGS * 8
end_define

begin_decl_stmt
specifier|static
name|void
modifier|*
name|prdbuf
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
modifier|*
name|prdbuf_next
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*   * Hardware specific IDE controller code.  All vendor-specific code  * for handling IDE timing and other chipset peculiarities should be  * encapsulated here.  */
end_comment

begin_comment
comment|/* Generic busmastering PCI-IDE */
end_comment

begin_function
specifier|static
name|int
name|generic_dmainit
parameter_list|(
name|struct
name|ide_pci_cookie
modifier|*
name|cookie
parameter_list|,
name|struct
name|wdparams
modifier|*
name|wp
parameter_list|,
name|int
function_decl|(
modifier|*
name|wdcmd
function_decl|)
parameter_list|(
name|int
parameter_list|,
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
name|wdinfo
parameter_list|)
block|{
comment|/*      * punt on the whole timing issue by looking for either a      * drive programmed for both PIO4 and mDMA2 (which use similar      * timing) or a drive in an UltraDMA mode (hopefully all      * controllers have separate timing for UDMA).  one hopes that if      * the drive's DMA mode has been configured by the BIOS, the      * controller's has also.      */
comment|/* XXX way too sick and twisted conditional */
if|if
condition|(
operator|!
operator|(
operator|(
operator|(
operator|(
name|wp
operator|->
name|wdp_atavalid
operator|&
literal|2
operator|)
operator|==
literal|2
operator|)
operator|&&
operator|(
operator|(
name|wp
operator|->
name|wdp_dmamword
operator|&
literal|0x404
operator|)
operator|==
literal|0x404
operator|)
operator|&&
operator|(
operator|(
name|wp
operator|->
name|wdp_eidepiomodes
operator|&
literal|2
operator|)
operator|==
literal|2
operator|)
operator|)
operator|||
operator|(
operator|(
operator|(
name|wp
operator|->
name|wdp_atavalid
operator|&
literal|4
operator|)
operator|==
literal|4
operator|)
operator|&&
operator|(
name|wp
operator|->
name|wdp_udmamode
operator|==
literal|4
operator|)
operator|)
operator|)
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|generic_status
parameter_list|(
name|struct
name|ide_pci_cookie
modifier|*
name|cookie
parameter_list|)
block|{
name|printf
argument_list|(
literal|"generic_status: no PCI IDE timing info available\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|vendor_fns
name|vs_generic
init|=
block|{
name|generic_dmainit
block|,
name|generic_status
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* VIA Technologies "82C571" PCI-IDE controller core */
end_comment

begin_function
specifier|static
name|void
name|via_571_status
parameter_list|(
name|struct
name|ide_pci_cookie
modifier|*
name|cookie
parameter_list|)
block|{
name|int
name|iobase_wd
decl_stmt|;
name|int
name|unit
decl_stmt|;
name|int
name|iobase_bm
decl_stmt|;
name|pcici_t
name|tag
decl_stmt|;
name|pcidi_t
name|type
decl_stmt|;
name|unsigned
name|int
name|word40
index|[
literal|5
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
name|iobase_wd
operator|=
name|cookie
operator|->
name|iobase_wd
expr_stmt|;
name|unit
operator|=
name|cookie
operator|->
name|unit
expr_stmt|;
name|iobase_bm
operator|=
name|cookie
operator|->
name|iobase_bm
expr_stmt|;
name|tag
operator|=
name|cookie
operator|->
name|tag
expr_stmt|;
name|type
operator|=
name|cookie
operator|->
name|type
expr_stmt|;
comment|/* XXX how to handle four calls for one controller? */
if|if
condition|(
name|iobase_wd
operator|!=
literal|0x1f0
operator|||
name|unit
operator|!=
literal|0
condition|)
return|return;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|5
condition|;
name|i
operator|++
control|)
block|{
name|word40
index|[
name|i
index|]
operator|=
name|pci_conf_read
argument_list|(
name|tag
argument_list|,
name|i
operator|*
literal|4
operator|+
literal|0x40
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"via_571_status: Primary IDE prefetch/postwrite %s/%s\n"
argument_list|,
name|word40
index|[
literal|0
index|]
operator|&
literal|0x8000
condition|?
literal|"enabled"
else|:
literal|"disabled"
argument_list|,
name|word40
index|[
literal|0
index|]
operator|&
literal|0x4000
condition|?
literal|"enabled"
else|:
literal|"disabled"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"via_571_status: Secondary IDE prefetch/postwrite %s/%s\n"
argument_list|,
name|word40
index|[
literal|0
index|]
operator|&
literal|0x2000
condition|?
literal|"enabled"
else|:
literal|"disabled"
argument_list|,
name|word40
index|[
literal|0
index|]
operator|&
literal|0x1000
condition|?
literal|"enabled"
else|:
literal|"disabled"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"via_571_status: Master %d read/%d write IRDY# wait states\n"
argument_list|,
operator|(
name|word40
index|[
literal|1
index|]
operator|&
literal|0x40
operator|)
operator|>>
literal|6
argument_list|,
operator|(
name|word40
index|[
literal|1
index|]
operator|&
literal|0x20
operator|)
operator|>>
literal|5
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"via_571_status: busmaster status read retry %s\n"
argument_list|,
operator|(
name|word40
index|[
literal|1
index|]
operator|&
literal|0x10
operator|)
condition|?
literal|"enabled"
else|:
literal|"disabled"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|"via_571_status: %s drive %d setup=%d active=%d recovery=%d\n"
argument_list|,
name|i
operator|<
literal|2
condition|?
literal|"primary"
else|:
literal|"secondary"
argument_list|,
name|i
operator|&
literal|1
argument_list|,
operator|(
operator|(
name|word40
index|[
literal|3
index|]
operator|>>
operator|(
operator|(
literal|3
operator|-
name|i
operator|)
operator|*
literal|2
operator|)
operator|)
operator|&
literal|3
operator|)
operator|+
literal|1
argument_list|,
operator|(
operator|(
name|word40
index|[
literal|2
index|]
operator|>>
operator|(
operator|(
operator|(
literal|3
operator|-
name|i
operator|)
operator|*
literal|8
operator|)
operator|+
literal|4
operator|)
operator|)
operator|&
literal|0x0f
operator|)
operator|+
literal|1
argument_list|,
operator|(
operator|(
name|word40
index|[
literal|2
index|]
operator|>>
operator|(
operator|(
literal|3
operator|-
name|i
operator|)
operator|*
literal|8
operator|)
operator|)
operator|&
literal|0x0f
operator|)
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* XXX could go on and do UDMA status for '586B */
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|vendor_fns
name|vs_via_571
init|=
block|{
name|generic_dmainit
block|,
name|via_571_status
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Intel PIIX, PIIX3, and PIIX4 IDE controller subfunctions */
end_comment

begin_function
specifier|static
name|void
name|intel_piix_dump_drive
parameter_list|(
name|char
modifier|*
name|ctlr
parameter_list|,
name|int
name|sitre
parameter_list|,
name|int
name|is_piix4
parameter_list|,
name|int
name|word40
parameter_list|,
name|int
name|word44
parameter_list|,
name|int
name|word48
parameter_list|,
name|int
name|word4a
parameter_list|,
name|int
name|drive
parameter_list|)
block|{
name|char
modifier|*
name|ms
decl_stmt|;
if|if
condition|(
operator|!
name|sitre
condition|)
name|ms
operator|=
literal|"master/slave"
expr_stmt|;
elseif|else
if|if
condition|(
name|drive
operator|==
literal|0
condition|)
name|ms
operator|=
literal|"master"
expr_stmt|;
else|else
name|ms
operator|=
literal|"slave"
expr_stmt|;
if|if
condition|(
name|sitre
operator|||
name|drive
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"intel_piix_status: %s %s sample = %d, %s recovery = %d\n"
argument_list|,
name|ctlr
argument_list|,
name|ms
argument_list|,
literal|5
operator|-
operator|(
operator|(
name|sitre
operator|&&
name|drive
operator|)
condition|?
operator|(
operator|(
name|word44
operator|>>
literal|2
operator|)
operator|&
literal|3
operator|)
else|:
operator|(
operator|(
name|word40
operator|>>
literal|12
operator|)
operator|&
literal|3
operator|)
operator|)
argument_list|,
name|ms
argument_list|,
literal|4
operator|-
operator|(
operator|(
name|sitre
operator|&&
name|drive
operator|)
condition|?
operator|(
operator|(
name|word44
operator|>>
literal|0
operator|)
operator|&
literal|3
operator|)
else|:
operator|(
operator|(
name|word40
operator|>>
literal|8
operator|)
operator|&
literal|3
operator|)
operator|)
argument_list|)
expr_stmt|;
name|word40
operator|>>=
operator|(
name|drive
operator|*
literal|4
operator|)
expr_stmt|;
name|printf
argument_list|(
literal|"\ intel_piix_status: %s %s fastDMAonly %s, pre/post %s,\n\ intel_piix_status:  IORDY sampling %s,\n\ intel_piix_status:  fast PIO %s%s\n"
argument_list|,
name|ctlr
argument_list|,
operator|(
name|drive
operator|==
literal|0
operator|)
condition|?
literal|"master"
else|:
literal|"slave"
argument_list|,
operator|(
name|word40
operator|&
literal|8
operator|)
condition|?
literal|"enabled"
else|:
literal|"disabled"
argument_list|,
operator|(
name|word40
operator|&
literal|4
operator|)
condition|?
literal|"enabled"
else|:
literal|"disabled"
argument_list|,
operator|(
name|word40
operator|&
literal|2
operator|)
condition|?
literal|"enabled"
else|:
literal|"disabled"
argument_list|,
operator|(
name|word40
operator|&
literal|1
operator|)
condition|?
literal|"enabled"
else|:
literal|"disabled"
argument_list|,
operator|(
operator|(
name|word40
operator|&
literal|9
operator|)
operator|==
literal|9
operator|)
condition|?
literal|" (overridden by fastDMAonly)"
else|:
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_piix4
condition|)
name|printf
argument_list|(
literal|"intel_piix_status: UltraDMA %s, CT/RP = %d/%d\n"
argument_list|,
name|word48
condition|?
literal|"enabled"
else|:
literal|"disabled"
argument_list|,
literal|4
operator|-
operator|(
name|word4a
operator|&
literal|3
operator|)
argument_list|,
literal|6
operator|-
operator|(
name|word4a
operator|&
literal|3
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|intel_piix_status
parameter_list|(
name|struct
name|ide_pci_cookie
modifier|*
name|cookie
parameter_list|)
block|{
name|int
name|iobase_wd
decl_stmt|;
name|int
name|unit
decl_stmt|;
name|int
name|iobase_bm
decl_stmt|;
name|pcici_t
name|tag
decl_stmt|;
name|pcidi_t
name|type
decl_stmt|;
name|int
name|ctlr
decl_stmt|;
name|unsigned
name|int
name|word40
decl_stmt|,
name|word44
decl_stmt|,
name|word48
decl_stmt|;
name|int
name|sitre
decl_stmt|,
name|is_piix4
decl_stmt|;
name|iobase_wd
operator|=
name|cookie
operator|->
name|iobase_wd
expr_stmt|;
name|unit
operator|=
name|cookie
operator|->
name|unit
expr_stmt|;
name|iobase_bm
operator|=
name|cookie
operator|->
name|iobase_bm
expr_stmt|;
name|tag
operator|=
name|cookie
operator|->
name|tag
expr_stmt|;
name|type
operator|=
name|cookie
operator|->
name|type
expr_stmt|;
name|ctlr
operator|=
name|cookie
operator|->
name|ctlr
expr_stmt|;
name|word40
operator|=
name|pci_conf_read
argument_list|(
name|tag
argument_list|,
literal|0x40
argument_list|)
expr_stmt|;
name|word44
operator|=
name|pci_conf_read
argument_list|(
name|tag
argument_list|,
literal|0x44
argument_list|)
expr_stmt|;
name|word48
operator|=
name|pci_conf_read
argument_list|(
name|tag
argument_list|,
literal|0x48
argument_list|)
expr_stmt|;
comment|/*       * XXX will not be right for the *next* generation of upward-compatible      * intel IDE controllers...      */
name|is_piix4
operator|=
name|pci_conf_read
argument_list|(
name|tag
argument_list|,
name|PCI_CLASS_REG
argument_list|)
operator|==
literal|0x71118086
expr_stmt|;
name|sitre
operator|=
name|word40
operator|&
literal|0x4000
expr_stmt|;
switch|switch
condition|(
name|ctlr
operator|*
literal|2
operator|+
name|unit
condition|)
block|{
case|case
literal|0
case|:
name|intel_piix_dump_drive
argument_list|(
literal|"primary"
argument_list|,
name|sitre
argument_list|,
name|is_piix4
argument_list|,
name|word40
operator|&
literal|0xffff
argument_list|,
name|word44
operator|&
literal|0x0f
argument_list|,
name|word48
argument_list|,
name|word48
operator|>>
literal|16
argument_list|,
literal|0
argument_list|)
expr_stmt|;
case|case
literal|1
case|:
name|intel_piix_dump_drive
argument_list|(
literal|"primary"
argument_list|,
name|sitre
argument_list|,
name|is_piix4
argument_list|,
name|word40
operator|&
literal|0xffff
argument_list|,
name|word44
operator|&
literal|0x0f
argument_list|,
name|word48
operator|>>
literal|1
argument_list|,
name|word48
operator|>>
literal|20
argument_list|,
literal|1
argument_list|)
expr_stmt|;
case|case
literal|2
case|:
name|intel_piix_dump_drive
argument_list|(
literal|"secondary"
argument_list|,
name|sitre
argument_list|,
name|is_piix4
argument_list|,
operator|(
name|word40
operator|>>
literal|16
operator|)
operator|&
literal|0xffff
argument_list|,
operator|(
name|word44
operator|>>
literal|4
operator|)
operator|&
literal|0x0f
argument_list|,
name|word48
operator|>>
literal|2
argument_list|,
name|word48
operator|>>
literal|24
argument_list|,
literal|0
argument_list|)
expr_stmt|;
case|case
literal|3
case|:
name|intel_piix_dump_drive
argument_list|(
literal|"secondary"
argument_list|,
name|sitre
argument_list|,
name|is_piix4
argument_list|,
operator|(
name|word40
operator|>>
literal|16
operator|)
operator|&
literal|0xffff
argument_list|,
operator|(
name|word44
operator|>>
literal|4
operator|)
operator|&
literal|0x0f
argument_list|,
name|word48
operator|>>
literal|3
argument_list|,
name|word48
operator|>>
literal|28
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|intel_piix_dmainit
parameter_list|(
name|struct
name|ide_pci_cookie
modifier|*
name|cookie
parameter_list|,
name|struct
name|wdparams
modifier|*
name|wp
parameter_list|,
name|int
function_decl|(
modifier|*
name|wdcmd
function_decl|)
parameter_list|(
name|int
parameter_list|,
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
name|wdinfo
parameter_list|)
block|{
name|int
name|r
decl_stmt|,
name|pci_id
decl_stmt|;
name|pci_id
operator|=
name|pci_conf_read
argument_list|(
name|cookie
operator|->
name|tag
argument_list|,
name|PCI_CLASS_REG
argument_list|)
expr_stmt|;
comment|/*      * If the drive is already in mDMA2 or UDMA2, we leave it and the      * controller alone, on the theory that the BIOS already DTRT.      *      * XXX this does not handle the conceivable case where the drive      * has been left in a the right mode from a previous boot, the      * BIOS has not reset it, and the BIOS has also not set the modes      * on the controller.  The one case seen so far where the BIOS      * doesn't dink the drives (Tyan S1563D with Award v4.01) it      * *does* seem to correctly program the controller.      *      * Aren't PC's fun?      */
comment|/* XXX way too sick and twisted conditional */
if|if
condition|(
operator|(
operator|(
operator|(
name|wp
operator|->
name|wdp_atavalid
operator|&
literal|2
operator|)
operator|==
literal|2
operator|)
operator|&&
operator|(
operator|(
name|wp
operator|->
name|wdp_dmamword
operator|&
literal|0x404
operator|)
operator|==
literal|0x404
operator|)
operator|&&
operator|(
operator|(
name|wp
operator|->
name|wdp_eidepiomodes
operator|&
literal|2
operator|)
operator|==
literal|2
operator|)
operator|)
operator|||
operator|(
operator|(
operator|(
name|wp
operator|->
name|wdp_atavalid
operator|&
literal|4
operator|)
operator|==
literal|4
operator|)
operator|&&
operator|(
name|wp
operator|->
name|wdp_udmamode
operator|&
literal|0x404
operator|==
literal|0x404
operator|)
operator|)
condition|)
return|return
literal|1
return|;
comment|/* If it's a UDMA drive and a PIIX4, set it up */
if|if
condition|(
operator|(
operator|(
name|wp
operator|->
name|wdp_atavalid
operator|&
literal|4
operator|)
operator|==
literal|4
operator|)
operator|&&
operator|(
operator|(
name|wp
operator|->
name|wdp_udmamode
operator|&
literal|4
operator|)
operator|==
literal|4
operator|)
operator|&&
name|pci_id
operator|==
literal|0x71118086
condition|)
block|{
comment|/* Set UDMA mode 2 on controller */
name|int
name|unitno
decl_stmt|,
name|mask
decl_stmt|,
name|new
decl_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"intel_piix_dmainit: setting ultra DMA mode 2\n"
argument_list|)
expr_stmt|;
name|r
operator|=
name|wdcmd
argument_list|(
name|WDDMA_UDMA2
argument_list|,
name|wdinfo
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|r
condition|)
block|{
name|printf
argument_list|(
literal|"intel_piix_dmainit: setting DMA mode failed\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|unitno
operator|=
name|cookie
operator|->
name|ctlr
operator|*
literal|2
operator|+
name|cookie
operator|->
name|unit
expr_stmt|;
name|mask
operator|=
literal|1
operator|<<
name|unitno
operator|+
literal|3
operator|<<
operator|(
literal|16
operator|+
name|unitno
operator|*
literal|4
operator|)
expr_stmt|;
name|new
operator|=
literal|1
operator|<<
name|unitno
operator|+
literal|2
operator|<<
operator|(
literal|16
operator|+
name|unitno
operator|*
literal|4
operator|)
expr_stmt|;
name|pci_conf_write
argument_list|(
name|cookie
operator|->
name|tag
argument_list|,
literal|0x48
argument_list|,
operator|(
name|pci_conf_read
argument_list|(
name|cookie
operator|->
name|tag
argument_list|,
literal|0x48
argument_list|)
operator|&
operator|~
name|mask
operator|)
operator||
name|new
argument_list|)
expr_stmt|;
block|}
comment|/*       * if the SITRE bit is not set, indicating independent programming      * of drive timing, we punt; we're not gonna fuss with trying to      * coordinate timing modes between drives.  if this is you, get a      * BIOS that does this for us, or get a new motherboard if it's an      * 82371FB (Triton FX).  Or contribute patches :)      */
elseif|else
if|if
condition|(
operator|(
name|pci_conf_read
argument_list|(
name|cookie
operator|->
name|tag
argument_list|,
literal|0x40
argument_list|)
operator|>>
operator|(
literal|16
operator|*
name|cookie
operator|->
name|ctlr
operator|)
operator|)
operator|&
literal|0x4000
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* otherwise, program it for MW DMA mode 2 */
elseif|else
if|if
condition|(
operator|(
operator|(
name|wp
operator|->
name|wdp_atavalid
operator|&
literal|2
operator|)
operator|==
literal|2
operator|)
operator|&&
operator|(
operator|(
name|wp
operator|->
name|wdp_dmamword
operator|&
literal|4
operator|)
operator|==
literal|4
operator|)
condition|)
block|{
comment|/* Set multiword DMA mode 2 on controller */
name|unsigned
name|int
name|mask40
decl_stmt|,
name|mask44
decl_stmt|,
name|new40
decl_stmt|,
name|new44
decl_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"intel_piix_dmainit: setting multiword DMA mode 2\n"
argument_list|)
expr_stmt|;
name|r
operator|=
name|wdcmd
argument_list|(
name|WDDMA_MDMA2
argument_list|,
name|wdinfo
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|r
condition|)
block|{
name|printf
argument_list|(
literal|"intel_piix_dmainit: setting DMA mode failed\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/*  	 * backward compatible hardware leaves us with such twisted masses  	 * of software (aka twiddle the extremely weird register layout on 	 * a PIIX3) 	 */
if|if
condition|(
name|cookie
operator|->
name|unit
operator|==
literal|0
condition|)
block|{
name|mask40
operator|=
literal|0x330f
expr_stmt|;
name|new40
operator|=
literal|0x2307
expr_stmt|;
name|mask44
operator|=
literal|0
expr_stmt|;
name|new44
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|mask40
operator|=
literal|0x00f0
expr_stmt|;
name|new40
operator|=
literal|0x0070
expr_stmt|;
name|mask44
operator|=
literal|0x000f
expr_stmt|;
name|new44
operator|=
literal|0x000b
expr_stmt|;
block|}
if|if
condition|(
name|cookie
operator|->
name|ctlr
condition|)
block|{
name|mask40
operator|<<=
literal|16
expr_stmt|;
name|new40
operator|<<=
literal|16
expr_stmt|;
name|mask44
operator|<<=
literal|4
expr_stmt|;
name|new44
operator|<<=
literal|4
expr_stmt|;
block|}
name|pci_conf_write
argument_list|(
name|cookie
operator|->
name|tag
argument_list|,
literal|0x40
argument_list|,
operator|(
name|pci_conf_read
argument_list|(
name|cookie
operator|->
name|tag
argument_list|,
literal|0x40
argument_list|)
operator|&
operator|~
name|mask40
operator|)
operator||
name|new40
argument_list|)
expr_stmt|;
name|pci_conf_write
argument_list|(
name|cookie
operator|->
name|tag
argument_list|,
literal|0x44
argument_list|,
operator|(
name|pci_conf_read
argument_list|(
name|cookie
operator|->
name|tag
argument_list|,
literal|0x44
argument_list|)
operator|&
operator|~
name|mask44
operator|)
operator||
name|new44
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bootverbose
condition|)
name|intel_piix_status
argument_list|(
name|cookie
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|vendor_fns
name|vs_intel_piix
init|=
block|{
name|intel_piix_dmainit
block|,
name|intel_piix_status
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Generic SFF-8038i code-- all code below here, except for PCI probes,  * more or less conforms to the SFF-8038i spec as extended for PCI.  * There should be no code that goes beyond that feature set below.  */
end_comment

begin_comment
comment|/* XXX mkcookie is overloaded with too many parameters */
end_comment

begin_function
specifier|static
name|struct
name|ide_pci_cookie
modifier|*
name|mkcookie
parameter_list|(
name|int
name|iobase_wd
parameter_list|,
name|int
name|ctlr
parameter_list|,
name|int
name|unit
parameter_list|,
name|int
name|iobase_bm
parameter_list|,
name|pcici_t
name|tag
parameter_list|,
name|pcidi_t
name|type
parameter_list|,
name|struct
name|vendor_fns
modifier|*
name|vp
parameter_list|)
block|{
name|struct
name|ide_pci_cookie
modifier|*
name|cp
decl_stmt|;
name|cp
operator|=
name|malloc
argument_list|(
sizeof|sizeof
expr|*
name|cp
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cp
condition|)
return|return
name|cp
return|;
name|cp
operator|->
name|iobase_wd
operator|=
name|iobase_wd
expr_stmt|;
name|cp
operator|->
name|ctlr
operator|=
name|ctlr
expr_stmt|;
name|cp
operator|->
name|unit
operator|=
name|unit
expr_stmt|;
name|cp
operator|->
name|tag
operator|=
name|tag
expr_stmt|;
name|cp
operator|->
name|type
operator|=
name|type
expr_stmt|;
name|cp
operator|->
name|iobase_bm
operator|=
name|iobase_bm
expr_stmt|;
name|bcopy
argument_list|(
name|vp
argument_list|,
operator|&
name|cp
operator|->
name|vs
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|vendor_fns
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|prdbuf
condition|)
block|{
name|prdbuf
operator|=
name|malloc
argument_list|(
name|PRD_ALLOC_SIZE
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|prdbuf
condition|)
block|{
name|FREE
argument_list|(
name|cp
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|(
operator|(
name|int
operator|)
name|prdbuf
operator|>>
name|PAGE_SHIFT
operator|)
operator|^
operator|(
operator|(
operator|(
name|int
operator|)
name|prdbuf
operator|+
name|PRD_ALLOC_SIZE
operator|-
literal|1
operator|)
operator|>>
name|PAGE_SHIFT
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"ide_pci: prdbuf straddles page boundary, no DMA\n"
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|cp
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|prdbuf
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|prdbuf_next
operator|=
name|prdbuf
expr_stmt|;
block|}
name|cp
operator|->
name|prd
operator|=
name|prdbuf_next
expr_stmt|;
operator|(
name|char
operator|*
operator|)
name|prdbuf_next
operator|+=
name|PRD_BUF_SIZE
expr_stmt|;
if|if
condition|(
operator|(
name|char
operator|*
operator|)
name|prdbuf_next
operator|>
operator|(
operator|(
name|char
operator|*
operator|)
name|prdbuf
operator|+
name|PRD_ALLOC_SIZE
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"ide_pci: mkcookie %04x:%d: no more space for PRDs, no DMA\n"
argument_list|,
name|iobase_wd
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|#
directive|if
literal|0
block|if (bootverbose) 	printf("ide_pci: mkcookie %04x:%d: PRD vstart = %08x vend = %08x\n", 	       iobase_wd, unit, (int)cp->prd, ((int)cp->prd)+PRD_BUF_SIZE);
endif|#
directive|endif
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|softc
operator|.
name|cookies
argument_list|,
name|cp
argument_list|,
name|le
argument_list|)
expr_stmt|;
return|return
name|cp
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|ide_pci_probe
parameter_list|(
name|pcici_t
name|tag
parameter_list|,
name|pcidi_t
name|type
parameter_list|)
block|{
name|int
name|data
init|=
name|pci_conf_read
argument_list|(
name|tag
argument_list|,
name|PCI_CLASS_REG
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|data
operator|&
name|PCI_CLASS_MASK
operator|)
operator|==
name|PCI_CLASS_MASS_STORAGE
operator|&&
operator|(
name|data
operator|&
name|PCI_SUBCLASS_MASK
operator|)
operator|==
literal|0x00010000
condition|)
block|{
if|if
condition|(
name|type
operator|==
literal|0x71118086
condition|)
return|return
operator|(
literal|"Intel PIIX4 Bus-master IDE controller"
operator|)
return|;
if|if
condition|(
name|type
operator|==
literal|0x70108086
condition|)
return|return
operator|(
literal|"Intel PIIX3 Bus-master IDE controller"
operator|)
return|;
if|if
condition|(
name|type
operator|==
literal|0x12308086
condition|)
return|return
operator|(
literal|"Intel PIIX Bus-master IDE controller"
operator|)
return|;
if|if
condition|(
name|type
operator|==
literal|0x05711106
condition|)
return|return
operator|(
literal|"VIA 82C586x (Apollo) Bus-master IDE controller"
operator|)
return|;
if|if
condition|(
name|data
operator|&
literal|0x8000
condition|)
return|return
operator|(
literal|"PCI IDE controller (busmaster capable)"
operator|)
return|;
ifndef|#
directive|ifndef
name|CMD640
comment|/* 	 * XXX the CMD640B hack should be better integrated, or 	 * something. 	 */
else|else
return|return
operator|(
literal|"PCI IDE controller (not busmaster capable)"
operator|)
return|;
endif|#
directive|endif
block|}
empty_stmt|;
return|return
operator|(
operator|(
name|char
operator|*
operator|)
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ide_pci_attach
parameter_list|(
name|pcici_t
name|tag
parameter_list|,
name|int
name|unit
parameter_list|)
block|{
name|u_long
name|idetm
decl_stmt|;
name|int
name|class
decl_stmt|;
name|int
name|bmista_1
decl_stmt|,
name|bmista_2
decl_stmt|;
name|int
name|iobase_wd_1
decl_stmt|,
name|iobase_wd_2
decl_stmt|,
name|iobase_bm_1
decl_stmt|,
name|iobase_bm_2
decl_stmt|;
name|int
name|cmd
decl_stmt|;
name|struct
name|vendor_fns
modifier|*
name|vp
decl_stmt|;
name|pcidi_t
name|type
decl_stmt|;
name|struct
name|ide_pci_cookie
modifier|*
name|cookie
decl_stmt|;
if|if
condition|(
name|unit
condition|)
return|return;
comment|/* is it busmaster capable?  bail if not */
name|class
operator|=
name|pci_conf_read
argument_list|(
name|tag
argument_list|,
name|PCI_CLASS_REG
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|class
operator|&
literal|0x8000
operator|)
condition|)
return|return;
comment|/* is it enabled and is busmastering turned on? */
name|cmd
operator|=
name|pci_conf_read
argument_list|(
name|tag
argument_list|,
name|PCI_COMMAND_STATUS_REG
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cmd
operator|&
literal|5
operator|)
operator|!=
literal|5
condition|)
return|return;
comment|/* set up vendor-specific stuff */
name|type
operator|=
name|pci_conf_read
argument_list|(
name|tag
argument_list|,
name|PCI_ID_REG
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
literal|0x71118086
case|:
case|case
literal|0x70108086
case|:
case|case
literal|0x12308086
case|:
comment|/* Intel PIIX, PIIX3, PIIX4 */
name|vp
operator|=
operator|&
name|vs_intel_piix
expr_stmt|;
break|break;
case|case
literal|0x5711106
case|:
comment|/* VIA Apollo chipset family */
name|vp
operator|=
operator|&
name|vs_via_571
expr_stmt|;
break|break;
default|default:
comment|/* everybody else */
name|vp
operator|=
operator|&
name|vs_generic
expr_stmt|;
break|break;
block|}
name|iobase_wd_1
operator|=
operator|(
name|class
operator|&
literal|0x100
operator|)
condition|?
operator|(
name|pci_conf_read
argument_list|(
name|tag
argument_list|,
literal|0x10
argument_list|)
operator|&
literal|0xfffc
operator|)
else|:
literal|0x1f0
expr_stmt|;
name|iobase_bm_1
operator|=
name|pci_conf_read
argument_list|(
name|tag
argument_list|,
literal|0x20
argument_list|)
operator|&
literal|0xfffc
expr_stmt|;
name|iobase_wd_2
operator|=
operator|(
name|class
operator|&
literal|0x400
operator|)
condition|?
operator|(
name|pci_conf_read
argument_list|(
name|tag
argument_list|,
literal|0x10
argument_list|)
operator|&
literal|0xfffc
operator|)
else|:
literal|0x170
expr_stmt|;
name|iobase_bm_2
operator|=
name|iobase_bm_1
operator|+
name|SFF8038_CTLR_1
expr_stmt|;
if|if
condition|(
name|iobase_bm_1
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"ide_pci: BIOS has not configured busmaster I/O address,\n"
literal|"ide_pci:  giving up\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|wddma
operator|.
name|wdd_candma
operator|=
name|ide_pci_candma
expr_stmt|;
name|wddma
operator|.
name|wdd_dmainit
operator|=
name|ide_pci_dmainit
expr_stmt|;
name|wddma
operator|.
name|wdd_dmaverify
operator|=
name|ide_pci_dmaverify
expr_stmt|;
name|wddma
operator|.
name|wdd_dmaprep
operator|=
name|ide_pci_dmasetup
expr_stmt|;
name|wddma
operator|.
name|wdd_dmastart
operator|=
name|ide_pci_dmastart
expr_stmt|;
name|wddma
operator|.
name|wdd_dmadone
operator|=
name|ide_pci_dmadone
expr_stmt|;
name|wddma
operator|.
name|wdd_dmastatus
operator|=
name|ide_pci_status
expr_stmt|;
name|bmista_1
operator|=
name|inb
argument_list|(
name|iobase_bm_1
operator|+
name|BMISTA_PORT
argument_list|)
expr_stmt|;
name|bmista_2
operator|=
name|inb
argument_list|(
name|iobase_bm_2
operator|+
name|BMISTA_PORT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ide_pci_softc_cookies_initted
condition|)
block|{
name|LIST_INIT
argument_list|(
operator|&
name|softc
operator|.
name|cookies
argument_list|)
expr_stmt|;
name|ide_pci_softc_cookies_initted
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|iobase_wd_1
operator|!=
literal|0
condition|)
block|{
name|cookie
operator|=
name|mkcookie
argument_list|(
name|iobase_wd_1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|iobase_bm_1
argument_list|,
name|tag
argument_list|,
name|type
argument_list|,
name|vp
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|vp
operator|->
name|vendor_status
argument_list|(
name|cookie
argument_list|)
expr_stmt|;
name|cookie
operator|=
name|mkcookie
argument_list|(
name|iobase_wd_1
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
name|iobase_bm_1
argument_list|,
name|tag
argument_list|,
name|type
argument_list|,
name|vp
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
block|{
name|vp
operator|->
name|vendor_status
argument_list|(
name|cookie
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"ide_pci: busmaster 0 status: %02x from port: %08x\n"
argument_list|,
name|bmista_1
argument_list|,
name|iobase_bm_1
operator|+
name|BMISTA_PORT
argument_list|)
expr_stmt|;
if|if
condition|(
name|bmista_1
operator|&
name|BMISTA_DMA0CAP
condition|)
name|printf
argument_list|(
literal|"ide_pci: ide0:0 has been configured for DMA by BIOS\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|bmista_1
operator|&
name|BMISTA_DMA1CAP
condition|)
name|printf
argument_list|(
literal|"ide_pci: ide0:1 has been configured for DMA by BIOS\n"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|bmista_1
operator|&
name|BMISTA_SIMPLEX
operator|||
name|bmista_2
operator|&
name|BMISTA_SIMPLEX
condition|)
block|{
name|printf
argument_list|(
literal|"ide_pci: controller is simplex, no DMA on secondary channel\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|iobase_wd_2
operator|!=
literal|0
condition|)
block|{
name|cookie
operator|=
name|mkcookie
argument_list|(
name|iobase_wd_2
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|iobase_bm_2
argument_list|,
name|tag
argument_list|,
name|type
argument_list|,
name|vp
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|vp
operator|->
name|vendor_status
argument_list|(
name|cookie
argument_list|)
expr_stmt|;
name|cookie
operator|=
name|mkcookie
argument_list|(
name|iobase_wd_2
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|iobase_bm_2
argument_list|,
name|tag
argument_list|,
name|type
argument_list|,
name|vp
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
block|{
name|vp
operator|->
name|vendor_status
argument_list|(
name|cookie
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"ide_pci: busmaster 1 status: %02x from port: %08x\n"
argument_list|,
name|bmista_2
argument_list|,
name|iobase_bm_2
operator|+
name|BMISTA_PORT
argument_list|)
expr_stmt|;
if|if
condition|(
name|bmista_2
operator|&
name|BMISTA_DMA0CAP
condition|)
name|printf
argument_list|(
literal|"ide_pci: ide1:0 has been configured for DMA by BIOS\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|bmista_2
operator|&
name|BMISTA_DMA1CAP
condition|)
name|printf
argument_list|(
literal|"ide_pci: ide1:1 has been configured for DMA by BIOS\n"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_decl_stmt
specifier|static
name|u_long
name|ide_pci_count
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|pci_device
name|ide_pci_device
init|=
block|{
literal|"ide_pci"
block|,
name|ide_pci_probe
block|,
name|ide_pci_attach
block|,
operator|&
name|ide_pci_count
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DATA_SET
argument_list|(
name|pcidevice_set
argument_list|,
name|ide_pci_device
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Return a cookie if we can do DMA on the specified (iobase_wd, unit).  */
end_comment

begin_function
specifier|static
name|void
modifier|*
name|ide_pci_candma
parameter_list|(
name|int
name|iobase_wd
parameter_list|,
name|int
name|unit
parameter_list|)
block|{
name|struct
name|ide_pci_cookie
modifier|*
name|cp
decl_stmt|;
name|cp
operator|=
name|softc
operator|.
name|cookies
operator|.
name|lh_first
expr_stmt|;
while|while
condition|(
name|cp
condition|)
block|{
if|if
condition|(
name|cp
operator|->
name|unit
operator|==
name|unit
operator|&&
name|cp
operator|->
name|iobase_wd
operator|==
name|iobase_wd
condition|)
break|break;
name|cp
operator|=
name|cp
operator|->
name|le
operator|.
name|le_next
expr_stmt|;
block|}
return|return
name|cp
return|;
block|}
end_function

begin_comment
comment|/*  * Initialize controller and drive for DMA operation, including timing modes.  * Uses data passed from the wd driver and a callback function to initialize  * timing modes on the drive.  */
end_comment

begin_function
specifier|static
name|int
name|ide_pci_dmainit
parameter_list|(
name|void
modifier|*
name|cookie
parameter_list|,
name|struct
name|wdparams
modifier|*
name|wp
parameter_list|,
name|int
function_decl|(
modifier|*
name|wdcmd
function_decl|)
parameter_list|(
name|int
parameter_list|,
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
name|wdinfo
parameter_list|)
block|{
name|struct
name|ide_pci_cookie
modifier|*
name|cp
init|=
name|cookie
decl_stmt|;
comment|/*       * If the controller status indicates that DMA is configured already,      * we flounce happily away      */
if|if
condition|(
name|inb
argument_list|(
name|cp
operator|->
name|iobase_bm
operator|+
name|BMISTA_PORT
argument_list|)
operator|&
operator|(
operator|(
name|cp
operator|->
name|unit
operator|==
literal|0
operator|)
condition|?
name|BMISTA_DMA0CAP
else|:
name|BMISTA_DMA1CAP
operator|)
condition|)
return|return
literal|1
return|;
comment|/* We take a stab at it with device-dependent code */
return|return
operator|(
name|cp
operator|->
name|vs
operator|.
name|vendor_dmainit
argument_list|(
name|cp
argument_list|,
name|wp
argument_list|,
name|wdcmd
argument_list|,
name|wdinfo
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Verify that controller can handle a dma request for cp.  Should  * not affect any hardware or driver state.  */
end_comment

begin_function
specifier|static
name|int
name|ide_pci_dmaverify
parameter_list|(
name|void
modifier|*
name|xcp
parameter_list|,
name|char
modifier|*
name|vaddr
parameter_list|,
name|u_long
name|count
parameter_list|,
name|int
name|dir
parameter_list|)
block|{
name|int
name|badfu
decl_stmt|;
comment|/*      * check for nonaligned or odd-length Stuff      */
name|badfu
operator|=
operator|(
operator|(
name|unsigned
name|int
operator|)
name|vaddr
operator|&
literal|1
operator|)
operator|||
operator|(
name|count
operator|&
literal|1
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
name|badfu
condition|)
block|{
name|printf
argument_list|(
literal|"ide_pci: dmaverify odd vaddr or length, "
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"vaddr = %08x length = %08x\n"
argument_list|,
operator|(
name|int
operator|)
name|vaddr
argument_list|,
name|count
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return
operator|(
operator|!
name|badfu
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Set up DMA for cp.  It is the responsibility of the caller  * to ensure that the controller is idle before this routine  * is called.  */
end_comment

begin_function
specifier|static
name|int
name|ide_pci_dmasetup
parameter_list|(
name|void
modifier|*
name|xcp
parameter_list|,
name|char
modifier|*
name|vaddr
parameter_list|,
name|u_long
name|vcount
parameter_list|,
name|int
name|dir
parameter_list|)
block|{
name|struct
name|ide_pci_cookie
modifier|*
name|cp
init|=
name|xcp
decl_stmt|;
name|struct
name|ide_pci_prd
modifier|*
name|prd
decl_stmt|;
name|int
name|i
decl_stmt|;
name|u_long
name|firstpage
decl_stmt|;
name|u_long
name|prd_base
decl_stmt|,
name|prd_count
decl_stmt|;
name|u_long
name|nbase
decl_stmt|,
name|ncount
decl_stmt|,
name|nend
decl_stmt|;
name|int
name|iobase_bm
decl_stmt|;
specifier|static
name|int
name|trashmore
init|=
literal|0xdeadbeef
decl_stmt|;
specifier|static
name|int
modifier|*
name|trashmore_p
init|=
literal|0
decl_stmt|;
name|u_long
name|count
decl_stmt|,
name|checkcount
decl_stmt|;
name|prd
operator|=
name|cp
operator|->
name|prd
expr_stmt|;
name|count
operator|=
name|vcount
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
name|iobase_bm
operator|=
name|cp
operator|->
name|iobase_bm
expr_stmt|;
if|if
condition|(
name|count
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"ide_pci: dmasetup 0-length transfer, "
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"vaddr = %08x length = %08x\n"
argument_list|,
operator|(
name|int
operator|)
name|vaddr
argument_list|,
name|count
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* Generate first PRD entry, which may be non-aligned. */
name|firstpage
operator|=
name|PAGE_SIZE
operator|-
operator|(
operator|(
name|u_long
operator|)
name|vaddr
operator|&
name|PAGE_MASK
operator|)
expr_stmt|;
name|prd_base
operator|=
name|vtophys
argument_list|(
name|vaddr
argument_list|)
expr_stmt|;
name|prd_count
operator|=
name|MIN
argument_list|(
name|count
argument_list|,
name|firstpage
argument_list|)
expr_stmt|;
name|vaddr
operator|+=
name|prd_count
expr_stmt|;
name|count
operator|-=
name|prd_count
expr_stmt|;
comment|/* Step through virtual pages, coalescing as needed. */
while|while
condition|(
name|count
condition|)
block|{
name|nbase
operator|=
name|vtophys
argument_list|(
name|vaddr
argument_list|)
expr_stmt|;
name|ncount
operator|=
name|MIN
argument_list|(
name|count
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
name|nend
operator|=
name|nbase
operator|+
name|ncount
expr_stmt|;
comment|/* Coalesce if physically contiguous and not crossing 64k boundary. */
if|if
condition|(
operator|(
name|prd_base
operator|+
name|prd_count
operator|==
name|nbase
operator|)
operator|&&
operator|(
operator|(
operator|(
operator|(
name|nend
operator|-
literal|1
operator|)
operator|^
name|prd_base
operator|)
operator|&
operator|~
literal|0xffff
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
name|prd_count
operator|+=
name|ncount
expr_stmt|;
block|}
else|else
block|{
name|prd
index|[
name|i
index|]
operator|.
name|prd_base
operator|=
name|prd_base
expr_stmt|;
name|prd
index|[
name|i
index|]
operator|.
name|prd_count
operator|=
operator|(
name|prd_count
operator|&
literal|0xffff
operator|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|i
operator|>=
name|PRD_MAX_SEGS
condition|)
block|{
name|printf
argument_list|(
literal|"wd82371: too many segments in PRD table\n"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|prd_base
operator|=
name|nbase
expr_stmt|;
name|prd_count
operator|=
name|ncount
expr_stmt|;
block|}
name|vaddr
operator|+=
name|ncount
expr_stmt|;
name|count
operator|-=
name|ncount
expr_stmt|;
block|}
comment|/* Write last PRD entry. */
name|prd
index|[
name|i
index|]
operator|.
name|prd_base
operator|=
name|prd_base
expr_stmt|;
name|prd
index|[
name|i
index|]
operator|.
name|prd_count
operator|=
operator|(
name|prd_count
operator|&
literal|0xffff
operator|)
operator||
name|PRD_EOT_BIT
expr_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
comment|/* sanity check the transfer for length and page-alignment, at least */
name|checkcount
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
condition|;
name|i
operator|++
control|)
block|{
name|unsigned
name|int
name|modcount
decl_stmt|;
name|modcount
operator|=
name|prd
index|[
name|i
index|]
operator|.
name|prd_count
operator|&
literal|0xffffe
expr_stmt|;
if|if
condition|(
name|modcount
operator|==
literal|0
condition|)
name|modcount
operator|=
literal|0x10000
expr_stmt|;
name|checkcount
operator|+=
name|modcount
expr_stmt|;
if|if
condition|(
name|i
operator|!=
literal|0
operator|&&
operator|(
operator|(
name|prd
index|[
name|i
index|]
operator|.
name|prd_base
operator|&
name|PAGE_MASK
operator|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"ide_pci: dmasetup() diagnostic fails-- unaligned page\n"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|prd
index|[
name|i
index|]
operator|.
name|prd_count
operator|&
name|PRD_EOT_BIT
condition|)
break|break;
block|}
if|if
condition|(
name|checkcount
operator|!=
name|vcount
condition|)
block|{
name|printf
argument_list|(
literal|"ide_pci: dmasetup() diagnostic fails-- bad length\n"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
endif|#
directive|endif
comment|/* Set up PRD base register */
name|outl
argument_list|(
name|iobase_bm
operator|+
name|BMIDTP_PORT
argument_list|,
name|vtophys
argument_list|(
name|prd
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Set direction of transfer */
name|outb
argument_list|(
name|iobase_bm
operator|+
name|BMICOM_PORT
argument_list|,
operator|(
name|dir
operator|==
name|B_READ
operator|)
condition|?
name|BMICOM_READ_WRITE
else|:
literal|0
argument_list|)
expr_stmt|;
comment|/* Clear interrupt and error bits */
name|outb
argument_list|(
name|iobase_bm
operator|+
name|BMISTA_PORT
argument_list|,
operator|(
name|inb
argument_list|(
name|iobase_bm
operator|+
name|BMISTA_PORT
argument_list|)
operator||
operator|(
name|BMISTA_INTERRUPT
operator||
name|BMISTA_DMA_ERROR
operator|)
operator|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ide_pci_dmastart
parameter_list|(
name|void
modifier|*
name|xcp
parameter_list|)
block|{
name|struct
name|ide_pci_cookie
modifier|*
name|cp
init|=
name|xcp
decl_stmt|;
name|int
name|iobase_bm
decl_stmt|;
name|iobase_bm
operator|=
name|cp
operator|->
name|iobase_bm
expr_stmt|;
name|outb
argument_list|(
name|iobase_bm
operator|+
name|BMICOM_PORT
argument_list|,
name|inb
argument_list|(
name|iobase_bm
operator|+
name|BMICOM_PORT
argument_list|)
operator||
name|BMICOM_STOP_START
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|ide_pci_dmadone
parameter_list|(
name|void
modifier|*
name|xcp
parameter_list|)
block|{
name|struct
name|ide_pci_cookie
modifier|*
name|cp
init|=
name|xcp
decl_stmt|;
name|int
name|iobase_bm
decl_stmt|,
name|status
decl_stmt|;
name|status
operator|=
name|ide_pci_status
argument_list|(
name|xcp
argument_list|)
expr_stmt|;
name|iobase_bm
operator|=
name|cp
operator|->
name|iobase_bm
expr_stmt|;
name|outb
argument_list|(
name|iobase_bm
operator|+
name|BMICOM_PORT
argument_list|,
name|inb
argument_list|(
name|iobase_bm
operator|+
name|BMICOM_PORT
argument_list|)
operator|&
operator|~
name|BMICOM_STOP_START
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ide_pci_status
parameter_list|(
name|void
modifier|*
name|xcp
parameter_list|)
block|{
name|struct
name|ide_pci_cookie
modifier|*
name|cp
init|=
name|xcp
decl_stmt|;
name|int
name|iobase_bm
decl_stmt|,
name|status
decl_stmt|,
name|bmista
decl_stmt|;
name|status
operator|=
literal|0
expr_stmt|;
name|iobase_bm
operator|=
name|cp
operator|->
name|iobase_bm
expr_stmt|;
name|bmista
operator|=
name|inb
argument_list|(
name|iobase_bm
operator|+
name|BMISTA_PORT
argument_list|)
expr_stmt|;
if|if
condition|(
name|bmista
operator|&
name|BMISTA_INTERRUPT
condition|)
name|status
operator||=
name|WDDS_INTERRUPT
expr_stmt|;
if|if
condition|(
name|bmista
operator|&
name|BMISTA_DMA_ERROR
condition|)
name|status
operator||=
name|WDDS_ERROR
expr_stmt|;
if|if
condition|(
name|bmista
operator|&
name|BMISTA_DMA_ACTIVE
condition|)
name|status
operator||=
name|WDDS_ACTIVE
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NPCI> 0 */
end_comment

end_unit

