begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright 1996 Massachusetts Institute of Technology  *  * Permission to use, copy, modify, and distribute this software and  * its documentation for any purpose and without fee is hereby  * granted, provided that both the above copyright notice and this  * permission notice appear in all copies, that both the above  * copyright notice and this permission notice appear in all  * supporting documentation, and that the name of M.I.T. not be used  * in advertising or publicity pertaining to distribution of the  * software without specific, written prior permission.  M.I.T. makes  * no representations about the suitability of this software for any  * purpose.  It is provided "as is" without express or implied  * warranty.  *   * THIS SOFTWARE IS PROVIDED BY M.I.T. ``AS IS''.  M.I.T. DISCLAIMS  * ALL EXPRESS OR IMPLIED WARRANTIES WITH REGARD TO THIS SOFTWARE,  * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF  * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT  * SHALL M.I.T. BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF  * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,  * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT  * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/buf.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/wdreg.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|PC98
end_ifdef

begin_include
include|#
directive|include
file|<pc98/pc98/pc98.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<i386/isa/isa.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<i386/isa/isa_device.h>
end_include

begin_include
include|#
directive|include
file|<pci/pcivar.h>
end_include

begin_include
include|#
directive|include
file|<pci/pcireg.h>
end_include

begin_include
include|#
directive|include
file|<pci/ide_pcireg.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|MIN
end_ifndef

begin_define
define|#
directive|define
name|MIN
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|(((a)<(b))?(a):(b))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|PROMISE_ULTRA33
value|0x4d33105a
end_define

begin_define
define|#
directive|define
name|CMD640B_PCI_ID
value|0x06401095
end_define

begin_struct_decl
struct_decl|struct
name|ide_pci_cookie
struct_decl|;
end_struct_decl

begin_comment
comment|/* structs vendor_fns, ide_pci_cookie are recursive */
end_comment

begin_struct
struct|struct
name|vendor_fns
block|{
name|int
function_decl|(
modifier|*
name|vendor_dmainit
function_decl|)
comment|/* initialize DMA controller and drive */
parameter_list|(
name|struct
name|ide_pci_cookie
modifier|*
name|cookie
parameter_list|,
name|struct
name|wdparams
modifier|*
name|wp
parameter_list|,
name|int
function_decl|(
modifier|*
name|wdcmd
function_decl|)
parameter_list|(
name|int
parameter_list|,
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
name|void
function_decl|(
modifier|*
name|vendor_status
function_decl|)
comment|/* prints off DMA timing info */
parameter_list|(
name|struct
name|ide_pci_cookie
modifier|*
name|cookie
parameter_list|)
function_decl|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * XXX the fact that this list keeps all kinds of info on PCI controllers  * is pretty grotty-- much of this should be replaced by a proper integration  * of PCI probes into the wd driver.  * XXX if we're going to support native-PCI controllers, we also need to  * keep the address of the IDE control block register, which is something wd.c  * needs to know, which is why this info is in the wrong place.  */
end_comment

begin_struct
struct|struct
name|ide_pci_cookie
block|{
name|LIST_ENTRY
argument_list|(
argument|ide_pci_cookie
argument_list|)
name|le
expr_stmt|;
name|int
name|iobase_wd
decl_stmt|;
name|int
name|ctlr
decl_stmt|;
comment|/* controller 0/1 on PCI IDE interface */
name|int
name|unit
decl_stmt|;
name|int
name|iobase_bm
decl_stmt|;
comment|/* SFF-8038 control registers */
name|int
name|altiobase_wd
decl_stmt|;
name|pcici_t
name|tag
decl_stmt|;
name|pcidi_t
name|type
decl_stmt|;
name|struct
name|ide_pci_prd
modifier|*
name|prd
decl_stmt|;
name|struct
name|vendor_fns
name|vs
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|ide_pci_softc
block|{
name|LIST_HEAD
argument_list|(
argument_list|,
argument|ide_pci_cookie
argument_list|)
name|cookies
expr_stmt|;
block|}
struct|;
end_struct

begin_function_decl
specifier|static
name|int
name|generic_dmainit
parameter_list|(
name|struct
name|ide_pci_cookie
modifier|*
name|cookie
parameter_list|,
name|struct
name|wdparams
modifier|*
name|wp
parameter_list|,
name|int
function_decl|(
modifier|*
name|wdcmd
function_decl|)
parameter_list|(
name|int
parameter_list|,
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
name|wdinfo
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|generic_status
parameter_list|(
name|struct
name|ide_pci_cookie
modifier|*
name|cookie
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sis_5591_dmainit
parameter_list|(
name|struct
name|ide_pci_cookie
modifier|*
name|cookie
parameter_list|,
name|struct
name|wdparams
modifier|*
name|wp
parameter_list|,
name|int
function_decl|(
modifier|*
name|wdcmd
function_decl|)
parameter_list|(
name|int
parameter_list|,
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
name|wdinfo
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sis_5591_status
parameter_list|(
name|struct
name|ide_pci_cookie
modifier|*
name|cookie
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|via_571_status
parameter_list|(
name|struct
name|ide_pci_cookie
modifier|*
name|cookie
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|via_571_dmainit
parameter_list|(
name|struct
name|ide_pci_cookie
modifier|*
name|cookie
parameter_list|,
name|struct
name|wdparams
modifier|*
name|wp
parameter_list|,
name|int
function_decl|(
modifier|*
name|wdcmd
function_decl|)
parameter_list|(
name|int
parameter_list|,
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
name|wdinfo
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|acer_status
parameter_list|(
name|struct
name|ide_pci_cookie
modifier|*
name|cookie
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|acer_dmainit
parameter_list|(
name|struct
name|ide_pci_cookie
modifier|*
name|cookie
parameter_list|,
name|struct
name|wdparams
modifier|*
name|wp
parameter_list|,
name|int
function_decl|(
modifier|*
name|wdcmd
function_decl|)
parameter_list|(
name|int
parameter_list|,
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
name|wdinfo
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|intel_piix_dump_drive
parameter_list|(
name|char
modifier|*
name|ctlr
parameter_list|,
name|int
name|sitre
parameter_list|,
name|int
name|is_piix4
parameter_list|,
name|int
name|word40
parameter_list|,
name|int
name|word44
parameter_list|,
name|int
name|word48
parameter_list|,
name|int
name|word4a
parameter_list|,
name|int
name|drive
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|intel_piix_status
parameter_list|(
name|struct
name|ide_pci_cookie
modifier|*
name|cookie
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|intel_piix_dmainit
parameter_list|(
name|struct
name|ide_pci_cookie
modifier|*
name|cookie
parameter_list|,
name|struct
name|wdparams
modifier|*
name|wp
parameter_list|,
name|int
function_decl|(
modifier|*
name|wdcmd
function_decl|)
parameter_list|(
name|int
parameter_list|,
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
name|wdinfo
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|ide_pci_cookie
modifier|*
name|mkcookie
parameter_list|(
name|int
name|iobase_wd
parameter_list|,
name|int
name|ctlr
parameter_list|,
name|int
name|unit
parameter_list|,
name|int
name|iobase_bm
parameter_list|,
name|pcici_t
name|tag
parameter_list|,
name|pcidi_t
name|type
parameter_list|,
name|struct
name|vendor_fns
modifier|*
name|vp
parameter_list|,
name|int
name|altiobase_wd
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ide_pci_attach
parameter_list|(
name|pcici_t
name|tag
parameter_list|,
name|int
name|unit
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
modifier|*
name|ide_pci_candma
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ide_pci_dmainit
parameter_list|(
name|void
modifier|*
parameter_list|,
name|struct
name|wdparams
modifier|*
parameter_list|,
name|int
function_decl|(
modifier|*
function_decl|)
parameter_list|(
name|int
parameter_list|,
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ide_pci_dmaverify
parameter_list|(
name|void
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|u_long
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ide_pci_dmasetup
parameter_list|(
name|void
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|u_long
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ide_pci_dmastart
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ide_pci_dmadone
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ide_pci_status
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ide_pci_iobase
parameter_list|(
name|void
modifier|*
name|xcp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ide_pci_altiobase
parameter_list|(
name|void
modifier|*
name|xcp
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|struct
name|ide_pci_softc
name|softc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ide_pci_softc_cookies_initted
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|isa_driver
name|wdcdriver
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * PRD_ALLOC_SIZE should be something that will not be allocated across a 64k  * boundary.  * PRD_MAX_SEGS is defined to be the maximum number of segments required for  * a transfer on an IDE drive, for an xfer that is linear in virtual memory.  * PRD_BUF_SIZE is the size of the buffer needed for a PRD table.  */
end_comment

begin_define
define|#
directive|define
name|PRD_ALLOC_SIZE
value|PAGE_SIZE
end_define

begin_define
define|#
directive|define
name|PRD_MAX_SEGS
value|((256 * 512 / PAGE_SIZE) + 1)
end_define

begin_define
define|#
directive|define
name|PRD_BUF_SIZE
value|PRD_MAX_SEGS * 8
end_define

begin_decl_stmt
specifier|static
name|void
modifier|*
name|prdbuf
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
modifier|*
name|prdbuf_next
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*   * Hardware specific IDE controller code.  All vendor-specific code  * for handling IDE timing and other chipset peculiarities should be  * encapsulated here.  */
end_comment

begin_comment
comment|/* helper funcs */
end_comment

begin_comment
comment|/*  * nnn_mode() return the highest valid mode, or -1 if the mode class is  * not supported  */
end_comment

begin_function
specifier|static
name|__inline
name|int
name|pio_mode
parameter_list|(
name|struct
name|wdparams
modifier|*
name|wp
parameter_list|)
block|{
if|if
condition|(
operator|(
name|wp
operator|->
name|wdp_atavalid
operator|&
literal|2
operator|)
operator|==
literal|2
condition|)
block|{
if|if
condition|(
operator|(
name|wp
operator|->
name|wdp_eidepiomodes
operator|&
literal|2
operator|)
operator|==
literal|2
condition|)
return|return
literal|4
return|;
if|if
condition|(
operator|(
name|wp
operator|->
name|wdp_eidepiomodes
operator|&
literal|1
operator|)
operator|==
literal|1
condition|)
return|return
literal|3
return|;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
unit|static __inline int dma_mode(struct wdparams *wp) {
comment|/* XXX not quite sure how to verify validity on this field */
end_comment

begin_endif
unit|}
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|__inline
name|int
name|mwdma_mode
parameter_list|(
name|struct
name|wdparams
modifier|*
name|wp
parameter_list|)
block|{
comment|/*  	 * XXX technically, using wdp_atavalid to test for validity of 	 * this field is not quite correct 	 */
if|if
condition|(
operator|(
name|wp
operator|->
name|wdp_atavalid
operator|&
literal|2
operator|)
operator|==
literal|2
condition|)
block|{
if|if
condition|(
operator|(
name|wp
operator|->
name|wdp_dmamword
operator|&
literal|4
operator|)
operator|==
literal|4
condition|)
return|return
literal|2
return|;
if|if
condition|(
operator|(
name|wp
operator|->
name|wdp_dmamword
operator|&
literal|2
operator|)
operator|==
literal|2
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|(
name|wp
operator|->
name|wdp_dmamword
operator|&
literal|1
operator|)
operator|==
literal|1
condition|)
return|return
literal|0
return|;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|int
name|udma_mode
parameter_list|(
name|struct
name|wdparams
modifier|*
name|wp
parameter_list|)
block|{
if|if
condition|(
operator|(
name|wp
operator|->
name|wdp_atavalid
operator|&
literal|4
operator|)
operator|==
literal|4
condition|)
block|{
if|if
condition|(
operator|(
name|wp
operator|->
name|wdp_udmamode
operator|&
literal|4
operator|)
operator|==
literal|4
condition|)
return|return
literal|2
return|;
if|if
condition|(
operator|(
name|wp
operator|->
name|wdp_udmamode
operator|&
literal|2
operator|)
operator|==
literal|2
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|(
name|wp
operator|->
name|wdp_udmamode
operator|&
literal|1
operator|)
operator|==
literal|1
condition|)
return|return
literal|0
return|;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Generic busmastering PCI-IDE */
end_comment

begin_function
specifier|static
name|int
name|generic_dmainit
parameter_list|(
name|struct
name|ide_pci_cookie
modifier|*
name|cookie
parameter_list|,
name|struct
name|wdparams
modifier|*
name|wp
parameter_list|,
name|int
function_decl|(
modifier|*
name|wdcmd
function_decl|)
parameter_list|(
name|int
parameter_list|,
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
name|wdinfo
parameter_list|)
block|{
comment|/* 	 * punt on the whole timing issue by looking for either a 	 * drive programmed for both PIO4 and mDMA2 (which use similar 	 * timing) or a drive in an UltraDMA mode (hopefully all 	 * controllers have separate timing for UDMA).  one hopes that if 	 * the drive's DMA mode has been configured by the BIOS, the 	 * controller's has also. 	 * 	 * XXX there are examples where this approach is now known to be 	 * broken, at least on systems based on Intel chipsets. 	 */
if|if
condition|(
operator|(
name|pio_mode
argument_list|(
name|wp
argument_list|)
operator|>=
literal|4
operator|&&
name|mwdma_mode
argument_list|(
name|wp
argument_list|)
operator|>=
literal|2
operator|)
operator|||
operator|(
name|udma_mode
argument_list|(
name|wp
argument_list|)
operator|>=
literal|2
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"ide_pci: generic_dmainit %04x:%d: warning, IDE controller timing not set\n"
argument_list|,
name|cookie
operator|->
name|iobase_wd
argument_list|,
name|cookie
operator|->
name|unit
argument_list|)
expr_stmt|;
comment|/* If we're here, then this controller is most likely not set  		   for UDMA, even if the drive may be. Make the drive wise 		   up. */
if|if
condition|(
operator|!
name|wdcmd
argument_list|(
name|WDDMA_MDMA2
argument_list|,
name|wdinfo
argument_list|)
condition|)
name|printf
argument_list|(
literal|"generic_dmainit: could not set multiword DMA mode!\n"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
ifdef|#
directive|ifdef
name|IDE_PCI_DEBUG
name|printf
argument_list|(
literal|"pio_mode: %d, mwdma_mode(wp): %d, udma_mode(wp): %d\n"
argument_list|,
name|pio_mode
argument_list|(
name|wp
argument_list|)
argument_list|,
name|mwdma_mode
argument_list|(
name|wp
argument_list|)
argument_list|,
name|udma_mode
argument_list|(
name|wp
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|generic_status
parameter_list|(
name|struct
name|ide_pci_cookie
modifier|*
name|cookie
parameter_list|)
block|{
name|printf
argument_list|(
literal|"generic_status: no PCI IDE timing info available\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|vendor_fns
name|vs_generic
init|=
block|{
name|generic_dmainit
block|,
name|generic_status
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* VIA Technologies "82C571" PCI-IDE controller core */
end_comment

begin_function
specifier|static
name|void
name|via_571_status
parameter_list|(
name|struct
name|ide_pci_cookie
modifier|*
name|cookie
parameter_list|)
block|{
name|int
name|iobase_wd
decl_stmt|;
name|int
name|ctlr
decl_stmt|,
name|unit
decl_stmt|;
name|int
name|iobase_bm
decl_stmt|;
name|pcici_t
name|tag
decl_stmt|;
name|pcidi_t
name|type
decl_stmt|;
name|u_long
name|word40
index|[
literal|5
index|]
decl_stmt|;
name|int
name|i
decl_stmt|,
name|unitno
decl_stmt|;
name|iobase_wd
operator|=
name|cookie
operator|->
name|iobase_wd
expr_stmt|;
name|unit
operator|=
name|cookie
operator|->
name|unit
expr_stmt|;
name|ctlr
operator|=
name|cookie
operator|->
name|ctlr
expr_stmt|;
name|iobase_bm
operator|=
name|cookie
operator|->
name|iobase_bm
expr_stmt|;
name|tag
operator|=
name|cookie
operator|->
name|tag
expr_stmt|;
name|type
operator|=
name|cookie
operator|->
name|type
expr_stmt|;
name|unitno
operator|=
name|ctlr
operator|*
literal|2
operator|+
name|unit
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|5
condition|;
name|i
operator|++
control|)
block|{
name|word40
index|[
name|i
index|]
operator|=
name|pci_conf_read
argument_list|(
name|tag
argument_list|,
name|i
operator|*
literal|4
operator|+
literal|0x40
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ctlr
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"via_571_status: Primary IDE prefetch/postwrite %s/%s\n"
argument_list|,
name|word40
index|[
literal|0
index|]
operator|&
literal|0x8000
condition|?
literal|"enabled"
else|:
literal|"disabled"
argument_list|,
name|word40
index|[
literal|0
index|]
operator|&
literal|0x4000
condition|?
literal|"enabled"
else|:
literal|"disabled"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"via_571_status: Secondary IDE prefetch/postwrite %s/%s\n"
argument_list|,
name|word40
index|[
literal|0
index|]
operator|&
literal|0x2000
condition|?
literal|"enabled"
else|:
literal|"disabled"
argument_list|,
name|word40
index|[
literal|0
index|]
operator|&
literal|0x1000
condition|?
literal|"enabled"
else|:
literal|"disabled"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"via_571_status: busmaster status read retry %s\n"
argument_list|,
operator|(
name|word40
index|[
literal|1
index|]
operator|&
literal|0x08
operator|)
condition|?
literal|"enabled"
else|:
literal|"disabled"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"via_571_status: %s drive %d data setup=%d active=%d recovery=%d\n"
argument_list|,
name|unitno
operator|<
literal|2
condition|?
literal|"primary"
else|:
literal|"secondary"
argument_list|,
name|unitno
operator|&
literal|1
argument_list|,
operator|(
call|(
name|u_int
call|)
argument_list|(
name|word40
index|[
literal|3
index|]
operator|>>
operator|(
operator|(
literal|3
operator|-
name|unitno
operator|)
operator|*
literal|2
operator|)
argument_list|)
operator|&
literal|3
operator|)
operator|+
literal|1
argument_list|,
operator|(
call|(
name|u_int
call|)
argument_list|(
name|word40
index|[
literal|2
index|]
operator|>>
operator|(
operator|(
operator|(
literal|3
operator|-
name|unitno
operator|)
operator|*
literal|8
operator|)
operator|+
literal|4
operator|)
argument_list|)
operator|&
literal|0x0f
operator|)
operator|+
literal|1
argument_list|,
operator|(
call|(
name|u_int
call|)
argument_list|(
name|word40
index|[
literal|2
index|]
operator|>>
operator|(
operator|(
literal|3
operator|-
name|unitno
operator|)
operator|*
literal|8
operator|)
argument_list|)
operator|&
literal|0x0f
operator|)
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctlr
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"via_571_status: primary ctrl active=%d recovery=%d\n"
argument_list|,
operator|(
call|(
name|u_int
call|)
argument_list|(
name|word40
index|[
literal|3
index|]
operator|>>
literal|28
argument_list|)
operator|&
literal|0x0f
operator|)
operator|+
literal|1
argument_list|,
operator|(
call|(
name|u_int
call|)
argument_list|(
name|word40
index|[
literal|2
index|]
operator|>>
literal|24
argument_list|)
operator|&
literal|0x0f
operator|)
operator|+
literal|1
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"via_571_status: secondary ctrl active=%d recovery=%d\n"
argument_list|,
operator|(
call|(
name|u_int
call|)
argument_list|(
name|word40
index|[
literal|3
index|]
operator|>>
literal|20
argument_list|)
operator|&
literal|0x0f
operator|)
operator|+
literal|1
argument_list|,
operator|(
call|(
name|u_int
call|)
argument_list|(
name|word40
index|[
literal|2
index|]
operator|>>
literal|16
argument_list|)
operator|&
literal|0x0f
operator|)
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* UltraDMA dump */
block|{
name|int
name|foo
decl_stmt|;
name|foo
operator|=
name|word40
index|[
literal|4
index|]
operator|>>
operator|(
operator|(
literal|3
operator|-
name|unitno
operator|)
operator|*
literal|8
operator|)
expr_stmt|;
name|printf
argument_list|(
literal|"via_571_status: %s drive %d udma method=%d enable=%d PIOmode=%d cycle=%d\n"
argument_list|,
name|i
operator|<
literal|2
condition|?
literal|"primary"
else|:
literal|"secondary"
argument_list|,
name|i
operator|&
literal|1
argument_list|,
operator|(
name|foo
operator|>>
literal|7
operator|)
operator|&
literal|1
argument_list|,
operator|(
name|foo
operator|>>
literal|6
operator|)
operator|&
literal|1
argument_list|,
operator|(
name|foo
operator|>>
literal|5
operator|)
operator|&
literal|1
argument_list|,
operator|(
name|foo
operator|&
literal|3
operator|)
operator|+
literal|2
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * XXX timing values set here are only good for 30/33MHz buses; should deal  * with slower ones too (BTW: you overclock-- you lose)  */
end_comment

begin_function
specifier|static
name|int
name|via_571_dmainit
parameter_list|(
name|struct
name|ide_pci_cookie
modifier|*
name|cookie
parameter_list|,
name|struct
name|wdparams
modifier|*
name|wp
parameter_list|,
name|int
function_decl|(
modifier|*
name|wdcmd
function_decl|)
parameter_list|(
name|int
parameter_list|,
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
name|wdinfo
parameter_list|)
block|{
name|u_long
name|pci_revision
decl_stmt|;
name|int
name|unitno
decl_stmt|;
name|pci_revision
operator|=
name|pci_conf_read
argument_list|(
name|cookie
operator|->
name|tag
argument_list|,
name|PCI_CLASS_REG
argument_list|)
operator|&
name|PCI_REVISION_MASK
expr_stmt|;
name|unitno
operator|=
name|cookie
operator|->
name|ctlr
operator|*
literal|2
operator|+
name|cookie
operator|->
name|unit
expr_stmt|;
comment|/* If it's a UDMA drive on a '590, set it up */
comment|/*  	 * XXX the revision number we check for is of dubious validity. 	 * it's extracted from the AMD 645 datasheet. 	 */
if|if
condition|(
name|pci_revision
operator|>=
literal|1
operator|&&
name|udma_mode
argument_list|(
name|wp
argument_list|)
operator|>=
literal|2
condition|)
block|{
name|unsigned
name|int
name|word50
decl_stmt|,
name|mask
decl_stmt|,
name|new
decl_stmt|;
name|word50
operator|=
name|pci_conf_read
argument_list|(
name|cookie
operator|->
name|tag
argument_list|,
literal|0x50
argument_list|)
expr_stmt|;
comment|/* UDMA enable by SET FEATURES, DMA cycles, cycle time 2T */
name|mask
operator|=
literal|0xe3000000
operator|>>
operator|(
name|unitno
operator|*
literal|8
operator|)
expr_stmt|;
name|new
operator|=
literal|0x40000000
operator|>>
operator|(
name|unitno
operator|*
literal|8
operator|)
expr_stmt|;
name|word50
operator|&=
operator|~
name|mask
expr_stmt|;
name|word50
operator||=
name|new
expr_stmt|;
name|pci_conf_write
argument_list|(
name|cookie
operator|->
name|tag
argument_list|,
literal|0x50
argument_list|,
name|word50
argument_list|)
expr_stmt|;
comment|/* 		 * With the '590, drive configuration should come *after* the 		 * controller configuration, to make sure the controller sees  		 * the SET FEATURES command and does the right thing. 		 */
comment|/* Set UDMA mode 2 on drive */
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"via_571_dmainit: setting ultra DMA mode 2\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|wdcmd
argument_list|(
name|WDDMA_UDMA2
argument_list|,
name|wdinfo
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"via_571_dmainit: setting DMA mode failed\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|bootverbose
condition|)
name|via_571_status
argument_list|(
name|cookie
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* otherwise, try and program it for MW DMA mode 2 */
elseif|else
if|if
condition|(
name|mwdma_mode
argument_list|(
name|wp
argument_list|)
operator|>=
literal|2
operator|&&
name|pio_mode
argument_list|(
name|wp
argument_list|)
operator|>=
literal|4
condition|)
block|{
name|u_long
name|workword
decl_stmt|;
comment|/* Set multiword DMA mode 2 on drive */
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"via_571_dmainit: setting multiword DMA mode 2\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|wdcmd
argument_list|(
name|WDDMA_MDMA2
argument_list|,
name|wdinfo
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"via_571_dmainit: setting DMA mode failed\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Configure the controller appropriately for MWDMA mode 2 */
name|workword
operator|=
name|pci_conf_read
argument_list|(
name|cookie
operator|->
name|tag
argument_list|,
literal|0x40
argument_list|)
expr_stmt|;
comment|/*  		 * enable prefetch/postwrite-- XXX may cause problems 		 * with CD-ROMs?  		 */
name|workword
operator||=
literal|0xc000
operator|>>
operator|(
name|cookie
operator|->
name|ctlr
operator|*
literal|2
operator|)
expr_stmt|;
comment|/* FIFO configurations-- equal split, threshold 1/2 */
name|workword
operator|&=
literal|0x90ffffff
expr_stmt|;
name|workword
operator||=
literal|0x2a000000
expr_stmt|;
name|pci_conf_write
argument_list|(
name|cookie
operator|->
name|tag
argument_list|,
literal|0x40
argument_list|,
name|workword
argument_list|)
expr_stmt|;
name|workword
operator|=
name|pci_conf_read
argument_list|(
name|cookie
operator|->
name|tag
argument_list|,
literal|0x44
argument_list|)
expr_stmt|;
comment|/* enable status read retry */
name|workword
operator||=
literal|8
expr_stmt|;
comment|/* enable FIFO flush on interrupt and end of sector */
name|workword
operator|&=
literal|0xff0cffff
expr_stmt|;
name|workword
operator||=
literal|0x00f00000
expr_stmt|;
name|pci_conf_write
argument_list|(
name|cookie
operator|->
name|tag
argument_list|,
literal|0x44
argument_list|,
name|workword
argument_list|)
expr_stmt|;
name|workword
operator|=
name|pci_conf_read
argument_list|(
name|cookie
operator|->
name|tag
argument_list|,
literal|0x48
argument_list|)
expr_stmt|;
comment|/* set Mode2 timing */
name|workword
operator|&=
operator|~
operator|(
literal|0xff000000
operator|>>
operator|(
name|unitno
operator|*
literal|8
operator|)
operator|)
expr_stmt|;
name|workword
operator||=
literal|0x31000000
operator|>>
operator|(
name|unitno
operator|*
literal|8
operator|)
expr_stmt|;
name|pci_conf_write
argument_list|(
name|cookie
operator|->
name|tag
argument_list|,
literal|0x48
argument_list|,
name|workword
argument_list|)
expr_stmt|;
comment|/* set sector size */
name|pci_conf_write
argument_list|(
name|cookie
operator|->
name|tag
argument_list|,
name|cookie
operator|->
name|ctlr
condition|?
literal|0x68
else|:
literal|0x60
argument_list|,
literal|0x200
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|via_571_status
argument_list|(
name|cookie
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|vendor_fns
name|vs_via_571
init|=
block|{
name|via_571_dmainit
block|,
name|via_571_status
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Cyrix Cx5530 Courtesy of Whistle Communications */
end_comment

begin_comment
comment|/*  * Verify that controller can handle a dma request for cp.  Should  * not affect any hardware or driver state.  * Special version for 5530 that allows only transfers on 16 byte boundaries.(!)  * (Yes the Cyrix 5530 can only UDMA to cache-line boundaries.(bleh!))  * Luckily nearly all disk IO is to kernel bufers which are page alligned.  * They may fix this in some other version of the chip, but it's in the latest  * at this time (Jan 1999).  */
end_comment

begin_function
specifier|static
name|int
name|cyrix_5530_dmaverify
parameter_list|(
name|void
modifier|*
name|xcp
parameter_list|,
name|char
modifier|*
name|vaddr
parameter_list|,
name|u_long
name|count
parameter_list|,
name|int
name|dir
parameter_list|)
block|{
name|int
name|badfu
decl_stmt|;
comment|/* 	 * check for nonaligned or odd-length Stuff 	 */
name|badfu
operator|=
operator|(
operator|(
name|unsigned
name|int
operator|)
name|vaddr
operator|&
literal|0xf
operator|)
operator|||
operator|(
name|count
operator|&
literal|0xf
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
name|badfu
condition|)
block|{
name|printf
argument_list|(
literal|"ide_pci: dmaverify odd vaddr or length, "
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"vaddr = %p length = %08lx\n"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|vaddr
argument_list|,
name|count
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return
operator|(
operator|!
name|badfu
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * XXX Unit number handling  may be broken in the Cx5530 modules.  * It has only been checked with a single drive.  * 12MByte/Sec transfer rates were seen with Quantum Fireball drives  * with negligable CPU usage.  */
end_comment

begin_function
specifier|static
name|void
name|cyrix_5530_status
parameter_list|(
name|struct
name|ide_pci_cookie
modifier|*
name|cookie
parameter_list|)
block|{
name|int
name|iobase_wd
decl_stmt|;
name|int
name|ctlr
decl_stmt|,
name|unit
decl_stmt|;
name|int
name|iobase_bm
decl_stmt|;
name|pcici_t
name|tag
decl_stmt|;
name|pcidi_t
name|type
decl_stmt|;
name|u_long
name|PIO_config
decl_stmt|;
name|u_long
name|DMA_config
decl_stmt|;
name|int
name|unitno
decl_stmt|;
name|iobase_wd
operator|=
name|cookie
operator|->
name|iobase_wd
expr_stmt|;
name|unit
operator|=
name|cookie
operator|->
name|unit
expr_stmt|;
name|ctlr
operator|=
name|cookie
operator|->
name|ctlr
expr_stmt|;
name|iobase_bm
operator|=
name|cookie
operator|->
name|iobase_bm
expr_stmt|;
name|tag
operator|=
name|cookie
operator|->
name|tag
expr_stmt|;
name|type
operator|=
name|cookie
operator|->
name|type
expr_stmt|;
name|unitno
operator|=
name|ctlr
operator|*
literal|2
operator|+
name|unit
expr_stmt|;
name|PIO_config
operator|=
name|inl
argument_list|(
name|iobase_bm
operator|+
operator|(
name|unit
operator|*
literal|0x10
operator|)
operator|+
literal|0x20
argument_list|)
expr_stmt|;
name|DMA_config
operator|=
name|inl
argument_list|(
name|iobase_bm
operator|+
operator|(
name|unit
operator|*
literal|0x10
operator|)
operator|+
literal|0x24
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"cyrix_5530_status: %s:%u IDE PIO cfg: 0x%08lx\n"
argument_list|,
operator|(
name|ctlr
condition|?
literal|"Secondary"
else|:
literal|"Primary"
operator|)
argument_list|,
name|unit
argument_list|,
name|PIO_config
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"cyrix_5530_status: %s:%u IDE DMA cfg: 0x%08lx\n"
argument_list|,
operator|(
name|ctlr
condition|?
literal|"Secondary"
else|:
literal|"Primary"
operator|)
argument_list|,
name|unit
argument_list|,
name|DMA_config
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * XXX timing values set here are only good for 30/33MHz buses; should deal  * with slower ones too (BTW: you overclock-- you lose)  */
end_comment

begin_function
specifier|static
name|int
name|cyrix_5530_dmainit
parameter_list|(
name|struct
name|ide_pci_cookie
modifier|*
name|cookie
parameter_list|,
name|struct
name|wdparams
modifier|*
name|wp
parameter_list|,
name|int
function_decl|(
modifier|*
name|wdcmd
function_decl|)
parameter_list|(
name|int
parameter_list|,
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
name|wdinfo
parameter_list|)
block|{
name|u_long
name|pci_revision
decl_stmt|;
name|int
name|unitno
decl_stmt|;
name|int
name|iobase_bm
decl_stmt|;
name|int
name|unit
decl_stmt|;
name|int
name|drivemode
decl_stmt|;
name|int
name|mode
decl_stmt|;
name|int
name|regval
decl_stmt|;
comment|/*cookie->unit = 0; */
comment|/* XXX */
name|unit
operator|=
name|cookie
operator|->
name|unit
expr_stmt|;
name|pci_revision
operator|=
name|pci_conf_read
argument_list|(
name|cookie
operator|->
name|tag
argument_list|,
name|PCI_CLASS_REG
argument_list|)
operator|&
name|PCI_REVISION_MASK
expr_stmt|;
name|unitno
operator|=
name|cookie
operator|->
name|ctlr
operator|*
literal|2
operator|+
name|unit
expr_stmt|;
name|iobase_bm
operator|=
name|cookie
operator|->
name|iobase_bm
expr_stmt|;
name|printf
argument_list|(
literal|"Setting using 0x%x\n"
argument_list|,
name|iobase_bm
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cookie
operator|->
name|ctlr
operator|==
literal|0
operator|)
operator|&&
operator|(
name|unit
operator|==
literal|0
operator|)
condition|)
comment|/* XXX */
name|outb
argument_list|(
name|iobase_bm
operator|+
operator|(
name|unit
operator|*
literal|0x10
operator|)
operator|+
name|BMISTA_PORT
argument_list|,
literal|0xe6
argument_list|)
expr_stmt|;
comment|/* If it's a UDMA drive on a '5530, set it up */
comment|/*  	 * depending on what the drive can do, 	 * set the correct modes, 	 */
name|printf
argument_list|(
literal|"wd%d: mw=0x%x, pio=0x%x, pcirev=0x%lx, udma=0x%x\n"
argument_list|,
name|unitno
argument_list|,
name|mwdma_mode
argument_list|(
name|wp
argument_list|)
argument_list|,
name|pio_mode
argument_list|(
name|wp
argument_list|)
argument_list|,
name|pci_revision
argument_list|,
name|udma_mode
argument_list|(
name|wp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
comment|/* pci_revision>= 1&& */
name|udma_mode
argument_list|(
name|wp
argument_list|)
operator|>=
literal|0
condition|)
block|{
switch|switch
condition|(
name|udma_mode
argument_list|(
name|wp
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
name|mode
operator|=
literal|0
expr_stmt|;
name|drivemode
operator|=
name|WDDMA_UDMA0
expr_stmt|;
name|regval
operator|=
literal|0x00921250
expr_stmt|;
break|break;
default|default:
comment|/* newer modes not supported */
case|case
literal|2
case|:
if|#
directive|if
literal|0
comment|/*  * XXX The 5530 can do mode 2 but if you do use it, it will block all   * access to the PCI bus (and thus the ISA bus, PICs, PIT, etc. etc.) until the  * transfer is complete. Mode 2 swamps the 5530 so much it can't really cope  * with any other operations. Therefore, use mode 1 for drives that can  * do mode 2 (or more). (FALL THROUGH)  */
block|mode = 2; 			drivemode = WDDMA_UDMA2; 			regval = 0x00911030; 			break;
endif|#
directive|endif
case|case
literal|1
case|:
name|mode
operator|=
literal|1
expr_stmt|;
name|drivemode
operator|=
name|WDDMA_UDMA1
expr_stmt|;
name|regval
operator|=
literal|0x00911140
expr_stmt|;
break|break;
block|}
comment|/* 		 * With the Cx5530, drive configuration 		 * should come *after* the controller configuration, 		 * to make sure the controller sees  		 * the command and does the right thing. 		 */
comment|/* Set UDMA mode on drive */
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"cyrix_5530_dmainit: set UDMA mode %d\n"
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|outl
argument_list|(
name|iobase_bm
operator|+
literal|0x24
operator|+
operator|(
name|unit
operator|*
literal|16
operator|)
argument_list|,
name|regval
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|wdcmd
argument_list|(
name|drivemode
argument_list|,
name|wdinfo
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"cyrix_5530_dmainit: setting DMA mode failed\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|bootverbose
condition|)
name|cyrix_5530_status
argument_list|(
name|cookie
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* otherwise, try and program it for MW DMA mode 2 */
elseif|else
if|if
condition|(
name|mwdma_mode
argument_list|(
name|wp
argument_list|)
operator|>=
literal|0
operator|&&
name|pio_mode
argument_list|(
name|wp
argument_list|)
operator|>=
literal|4
condition|)
block|{
switch|switch
condition|(
name|mwdma_mode
argument_list|(
name|wp
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
name|mode
operator|=
literal|0
expr_stmt|;
name|drivemode
operator|=
name|WDDMA_MDMA0
expr_stmt|;
name|regval
operator|=
literal|0x00017771
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|mode
operator|=
literal|1
expr_stmt|;
name|drivemode
operator|=
name|WDDMA_MDMA1
expr_stmt|;
name|regval
operator|=
literal|0x00012121
expr_stmt|;
break|break;
default|default:
comment|/* newer modes not supported */
case|case
literal|2
case|:
name|mode
operator|=
literal|2
expr_stmt|;
name|drivemode
operator|=
name|WDDMA_MDMA2
expr_stmt|;
name|regval
operator|=
literal|0x00002020
expr_stmt|;
break|break;
block|}
comment|/* Set multiword DMA mode 2 on drive */
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"cyrix_5530_dmainit: multiword DMA mode %d\n"
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|wdcmd
argument_list|(
name|drivemode
argument_list|,
name|wdinfo
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"cyrix_5530_dmainit: setting DMA mode failed\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Configure the controller appropriately for MWDMA mode */
name|outl
argument_list|(
name|iobase_bm
operator|+
literal|0x24
operator|+
operator|(
name|unit
operator|*
literal|16
operator|)
argument_list|,
name|regval
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|cyrix_5530_status
argument_list|(
name|cookie
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* 	 * Always set the PIO mode values. 	 */
switch|switch
condition|(
name|pio_mode
argument_list|(
name|wp
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
name|mode
operator|=
literal|0
expr_stmt|;
name|drivemode
operator|=
name|WDDMA_MDMA0
expr_stmt|;
name|regval
operator|=
literal|0x0000E132
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|mode
operator|=
literal|1
expr_stmt|;
name|drivemode
operator|=
name|WDDMA_MDMA1
expr_stmt|;
name|regval
operator|=
literal|0x00001812
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|mode
operator|=
literal|2
expr_stmt|;
name|drivemode
operator|=
name|WDDMA_MDMA1
expr_stmt|;
name|regval
operator|=
literal|0x00024020
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|mode
operator|=
literal|3
expr_stmt|;
name|drivemode
operator|=
name|WDDMA_MDMA1
expr_stmt|;
name|regval
operator|=
literal|0x00032010
expr_stmt|;
break|break;
default|default:
comment|/* newer modes not supported */
case|case
literal|4
case|:
name|mode
operator|=
literal|4
expr_stmt|;
name|drivemode
operator|=
name|WDDMA_MDMA2
expr_stmt|;
name|regval
operator|=
literal|0x00040010
expr_stmt|;
break|break;
block|}
name|outl
argument_list|(
name|iobase_bm
operator|+
literal|0x20
operator|+
operator|(
name|unit
operator|*
literal|16
operator|)
argument_list|,
name|regval
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"cyrix_5530_dmainit: setting PIO mode %d\n"
argument_list|,
name|mode
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|vendor_fns
name|vs_cyrix_5530
init|=
block|{
name|cyrix_5530_dmainit
block|,
name|cyrix_5530_status
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|promise_status
parameter_list|(
name|struct
name|ide_pci_cookie
modifier|*
name|cookie
parameter_list|)
block|{
name|pcici_t
name|tag
decl_stmt|;
name|int
name|i
decl_stmt|;
name|u_int32_t
name|port0_command
decl_stmt|,
name|port0_altstatus
decl_stmt|;
name|u_int32_t
name|port1_command
decl_stmt|,
name|port1_altstatus
decl_stmt|;
name|u_int32_t
name|dma_block
decl_stmt|;
name|u_int32_t
name|lat_and_interrupt
decl_stmt|;
name|u_int32_t
name|drivetiming
decl_stmt|;
name|int
name|pa
decl_stmt|,
name|pb
decl_stmt|,
name|mb
decl_stmt|,
name|mc
decl_stmt|;
name|tag
operator|=
name|cookie
operator|->
name|tag
expr_stmt|;
name|port0_command
operator|=
name|pci_conf_read
argument_list|(
name|tag
argument_list|,
literal|0x10
argument_list|)
expr_stmt|;
name|port0_altstatus
operator|=
name|pci_conf_read
argument_list|(
name|tag
argument_list|,
literal|0x14
argument_list|)
expr_stmt|;
name|port1_command
operator|=
name|pci_conf_read
argument_list|(
name|tag
argument_list|,
literal|0x18
argument_list|)
expr_stmt|;
name|port1_altstatus
operator|=
name|pci_conf_read
argument_list|(
name|tag
argument_list|,
literal|0x1c
argument_list|)
expr_stmt|;
name|dma_block
operator|=
name|pci_conf_read
argument_list|(
name|tag
argument_list|,
literal|0x20
argument_list|)
expr_stmt|;
name|lat_and_interrupt
operator|=
name|pci_conf_read
argument_list|(
name|tag
argument_list|,
literal|0x3c
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"promise_status: port0: 0x%lx, port0_alt: 0x%lx, port1: 0x%lx, port1_alt: 0x%lx\n"
argument_list|,
operator|(
name|u_long
operator|)
name|port0_command
argument_list|,
operator|(
name|u_long
operator|)
name|port0_altstatus
argument_list|,
operator|(
name|u_long
operator|)
name|port1_command
argument_list|,
operator|(
name|u_long
operator|)
name|port1_altstatus
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"promise_status: dma control blk address: 0x%lx, int: %d, irq: %d\n"
argument_list|,
operator|(
name|u_long
operator|)
name|dma_block
argument_list|,
call|(
name|u_int
call|)
argument_list|(
name|lat_and_interrupt
operator|>>
literal|8
argument_list|)
operator|&
literal|0xff
argument_list|,
operator|(
name|u_int
operator|)
name|lat_and_interrupt
operator|&
literal|0xff
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|+=
literal|2
control|)
block|{
name|drivetiming
operator|=
name|pci_conf_read
argument_list|(
name|tag
argument_list|,
literal|0x60
operator|+
name|i
operator|*
literal|4
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"drivebits%d-%d: %b\n"
argument_list|,
name|i
argument_list|,
name|i
operator|+
literal|1
argument_list|,
name|drivetiming
argument_list|,
literal|"\020\05Prefetch\06Iordy\07Errdy\010Sync\025DmaW\026DmaR"
argument_list|)
expr_stmt|;
name|pa
operator|=
name|drivetiming
operator|&
literal|0xf
expr_stmt|;
name|pb
operator|=
operator|(
name|drivetiming
operator|>>
literal|8
operator|)
operator|&
literal|0x1f
expr_stmt|;
name|mb
operator|=
operator|(
name|drivetiming
operator|>>
literal|13
operator|)
operator|&
literal|0x7
expr_stmt|;
name|mc
operator|=
operator|(
name|drivetiming
operator|>>
literal|16
operator|)
operator|&
literal|0xf
expr_stmt|;
name|printf
argument_list|(
literal|"drivetiming%d: pa: 0x%x, pb: 0x%x, mb: 0x%x, mc: 0x%x\n"
argument_list|,
name|i
argument_list|,
name|pa
argument_list|,
name|pb
argument_list|,
name|mb
argument_list|,
name|mc
argument_list|)
expr_stmt|;
name|drivetiming
operator|=
name|pci_conf_read
argument_list|(
name|tag
argument_list|,
literal|0x60
operator|+
operator|(
name|i
operator|+
literal|1
operator|)
operator|*
literal|4
argument_list|)
expr_stmt|;
name|pa
operator|=
name|drivetiming
operator|&
literal|0xf
expr_stmt|;
name|pb
operator|=
operator|(
name|drivetiming
operator|>>
literal|8
operator|)
operator|&
literal|0x1f
expr_stmt|;
name|mb
operator|=
operator|(
name|drivetiming
operator|>>
literal|13
operator|)
operator|&
literal|0x7
expr_stmt|;
name|mc
operator|=
operator|(
name|drivetiming
operator|>>
literal|16
operator|)
operator|&
literal|0xf
expr_stmt|;
name|printf
argument_list|(
literal|"drivetiming%d: pa: 0x%x, pb: 0x%x, mb: 0x%x, mc: 0x%x\n"
argument_list|,
name|i
operator|+
literal|1
argument_list|,
name|pa
argument_list|,
name|pb
argument_list|,
name|mb
argument_list|,
name|mc
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|vendor_fns
name|vs_promise
init|=
block|{
name|generic_dmainit
block|,
name|promise_status
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Intel PIIX, PIIX3, and PIIX4 IDE controller subfunctions */
end_comment

begin_function
specifier|static
name|void
name|intel_piix_dump_drive
parameter_list|(
name|char
modifier|*
name|ctlr
parameter_list|,
name|int
name|sitre
parameter_list|,
name|int
name|is_piix4
parameter_list|,
name|int
name|word40
parameter_list|,
name|int
name|word44
parameter_list|,
name|int
name|word48
parameter_list|,
name|int
name|word4a
parameter_list|,
name|int
name|drive
parameter_list|)
block|{
name|char
modifier|*
name|ms
decl_stmt|;
if|if
condition|(
operator|!
name|sitre
condition|)
name|ms
operator|=
literal|"master/slave"
expr_stmt|;
elseif|else
if|if
condition|(
name|drive
operator|==
literal|0
condition|)
name|ms
operator|=
literal|"master"
expr_stmt|;
else|else
name|ms
operator|=
literal|"slave"
expr_stmt|;
name|printf
argument_list|(
literal|"intel_piix_status: %s %s sample = %d, %s recovery = %d\n"
argument_list|,
name|ctlr
argument_list|,
name|ms
argument_list|,
literal|5
operator|-
operator|(
operator|(
name|sitre
operator|&&
name|drive
operator|)
condition|?
operator|(
operator|(
name|word44
operator|>>
literal|2
operator|)
operator|&
literal|3
operator|)
else|:
operator|(
operator|(
name|word40
operator|>>
literal|12
operator|)
operator|&
literal|3
operator|)
operator|)
argument_list|,
name|ms
argument_list|,
literal|4
operator|-
operator|(
operator|(
name|sitre
operator|&&
name|drive
operator|)
condition|?
operator|(
operator|(
name|word44
operator|>>
literal|0
operator|)
operator|&
literal|3
operator|)
else|:
operator|(
operator|(
name|word40
operator|>>
literal|8
operator|)
operator|&
literal|3
operator|)
operator|)
argument_list|)
expr_stmt|;
name|word40
operator|>>=
operator|(
name|drive
operator|*
literal|4
operator|)
expr_stmt|;
name|printf
argument_list|(
literal|"intel_piix_status: %s %s fastDMAonly %s, pre/post %s,\n\ intel_piix_status:  IORDY sampling %s,\n\ intel_piix_status:  fast PIO %s%s\n"
argument_list|,
name|ctlr
argument_list|,
operator|(
name|drive
operator|==
literal|0
operator|)
condition|?
literal|"master"
else|:
literal|"slave"
argument_list|,
operator|(
name|word40
operator|&
literal|8
operator|)
condition|?
literal|"enabled"
else|:
literal|"disabled"
argument_list|,
operator|(
name|word40
operator|&
literal|4
operator|)
condition|?
literal|"enabled"
else|:
literal|"disabled"
argument_list|,
operator|(
name|word40
operator|&
literal|2
operator|)
condition|?
literal|"enabled"
else|:
literal|"disabled"
argument_list|,
operator|(
name|word40
operator|&
literal|1
operator|)
condition|?
literal|"enabled"
else|:
literal|"disabled"
argument_list|,
operator|(
operator|(
name|word40
operator|&
literal|9
operator|)
operator|==
literal|9
operator|)
condition|?
literal|" (overridden by fastDMAonly)"
else|:
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_piix4
condition|)
name|printf
argument_list|(
literal|"intel_piix_status: UltraDMA %s, CT/RP = %d/%d\n"
argument_list|,
name|word48
condition|?
literal|"enabled"
else|:
literal|"disabled"
argument_list|,
literal|4
operator|-
operator|(
name|word4a
operator|&
literal|3
operator|)
argument_list|,
literal|6
operator|-
operator|(
name|word4a
operator|&
literal|3
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|intel_piix_status
parameter_list|(
name|struct
name|ide_pci_cookie
modifier|*
name|cookie
parameter_list|)
block|{
name|int
name|iobase_wd
decl_stmt|;
name|int
name|unit
decl_stmt|;
name|int
name|iobase_bm
decl_stmt|;
name|pcici_t
name|tag
decl_stmt|;
name|pcidi_t
name|type
decl_stmt|;
name|int
name|ctlr
decl_stmt|;
name|u_long
name|word40
decl_stmt|,
name|word44
decl_stmt|,
name|word48
decl_stmt|;
name|int
name|sitre
decl_stmt|,
name|is_piix4
decl_stmt|;
name|iobase_wd
operator|=
name|cookie
operator|->
name|iobase_wd
expr_stmt|;
name|unit
operator|=
name|cookie
operator|->
name|unit
expr_stmt|;
name|iobase_bm
operator|=
name|cookie
operator|->
name|iobase_bm
expr_stmt|;
name|tag
operator|=
name|cookie
operator|->
name|tag
expr_stmt|;
name|type
operator|=
name|cookie
operator|->
name|type
expr_stmt|;
name|ctlr
operator|=
name|cookie
operator|->
name|ctlr
expr_stmt|;
name|word40
operator|=
name|pci_conf_read
argument_list|(
name|tag
argument_list|,
literal|0x40
argument_list|)
expr_stmt|;
name|word44
operator|=
name|pci_conf_read
argument_list|(
name|tag
argument_list|,
literal|0x44
argument_list|)
expr_stmt|;
name|word48
operator|=
name|pci_conf_read
argument_list|(
name|tag
argument_list|,
literal|0x48
argument_list|)
expr_stmt|;
comment|/*  	 * XXX will not be right for the *next* generation of upward-compatible 	 * intel IDE controllers... 	 */
name|is_piix4
operator|=
name|pci_conf_read
argument_list|(
name|tag
argument_list|,
name|PCI_CLASS_REG
argument_list|)
operator|==
literal|0x71118086
expr_stmt|;
name|sitre
operator|=
name|word40
operator|&
literal|0x4000
expr_stmt|;
switch|switch
condition|(
name|ctlr
operator|*
literal|2
operator|+
name|unit
condition|)
block|{
case|case
literal|0
case|:
name|intel_piix_dump_drive
argument_list|(
literal|"primary"
argument_list|,
name|sitre
argument_list|,
name|is_piix4
argument_list|,
name|word40
operator|&
literal|0xffff
argument_list|,
name|word44
operator|&
literal|0x0f
argument_list|,
name|word48
argument_list|,
name|word48
operator|>>
literal|16
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|intel_piix_dump_drive
argument_list|(
literal|"primary"
argument_list|,
name|sitre
argument_list|,
name|is_piix4
argument_list|,
name|word40
operator|&
literal|0xffff
argument_list|,
name|word44
operator|&
literal|0x0f
argument_list|,
name|word48
operator|>>
literal|1
argument_list|,
name|word48
operator|>>
literal|20
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|intel_piix_dump_drive
argument_list|(
literal|"secondary"
argument_list|,
name|sitre
argument_list|,
name|is_piix4
argument_list|,
operator|(
name|word40
operator|>>
literal|16
operator|)
operator|&
literal|0xffff
argument_list|,
operator|(
name|word44
operator|>>
literal|4
operator|)
operator|&
literal|0x0f
argument_list|,
name|word48
operator|>>
literal|2
argument_list|,
name|word48
operator|>>
literal|24
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|intel_piix_dump_drive
argument_list|(
literal|"secondary"
argument_list|,
name|sitre
argument_list|,
name|is_piix4
argument_list|,
operator|(
name|word40
operator|>>
literal|16
operator|)
operator|&
literal|0xffff
argument_list|,
operator|(
name|word44
operator|>>
literal|4
operator|)
operator|&
literal|0x0f
argument_list|,
name|word48
operator|>>
literal|3
argument_list|,
name|word48
operator|>>
literal|28
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"intel_piix_status: bad drive or controller number\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * XXX timing values set hereare only good for 30/33MHz buses; should deal  * with slower ones too (BTW: you overclock-- you lose)  */
end_comment

begin_function
specifier|static
name|int
name|intel_piix_dmainit
parameter_list|(
name|struct
name|ide_pci_cookie
modifier|*
name|cookie
parameter_list|,
name|struct
name|wdparams
modifier|*
name|wp
parameter_list|,
name|int
function_decl|(
modifier|*
name|wdcmd
function_decl|)
parameter_list|(
name|int
parameter_list|,
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
name|wdinfo
parameter_list|)
block|{
comment|/* If it's a UDMA drive and a PIIX4, set it up */
if|if
condition|(
name|cookie
operator|->
name|type
operator|==
literal|0x71118086
operator|&&
name|udma_mode
argument_list|(
name|wp
argument_list|)
operator|>=
literal|2
condition|)
block|{
comment|/* Set UDMA mode 2 on controller */
name|int
name|unitno
decl_stmt|,
name|mask
decl_stmt|,
name|new
decl_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"intel_piix_dmainit: setting ultra DMA mode 2\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|wdcmd
argument_list|(
name|WDDMA_UDMA2
argument_list|,
name|wdinfo
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"intel_piix_dmainit: setting DMA mode failed\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|unitno
operator|=
name|cookie
operator|->
name|ctlr
operator|*
literal|2
operator|+
name|cookie
operator|->
name|unit
expr_stmt|;
name|mask
operator|=
operator|(
literal|1
operator|<<
name|unitno
operator|)
operator|+
operator|(
literal|3
operator|<<
operator|(
literal|16
operator|+
name|unitno
operator|*
literal|4
operator|)
operator|)
expr_stmt|;
name|new
operator|=
operator|(
literal|1
operator|<<
name|unitno
operator|)
operator|+
operator|(
literal|2
operator|<<
operator|(
literal|16
operator|+
name|unitno
operator|*
literal|4
operator|)
operator|)
expr_stmt|;
name|pci_conf_write
argument_list|(
name|cookie
operator|->
name|tag
argument_list|,
literal|0x48
argument_list|,
operator|(
name|pci_conf_read
argument_list|(
name|cookie
operator|->
name|tag
argument_list|,
literal|0x48
argument_list|)
operator|&
operator|~
name|mask
operator|)
operator||
name|new
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|intel_piix_status
argument_list|(
name|cookie
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/*  	 * if it's an 82371FB, which can't do independent programming of 	 * drive timing, we punt; we're not going to fuss with trying to 	 * coordinate timing modes between drives.  if this is you, get a 	 * new motherboard.  or contribute patches :) 	 * 	 * we do now at least see if the modes set are OK to use.  this should 	 * satisfy the majority of people, with mwdma mode2 drives. 	 */
elseif|else
if|if
condition|(
name|cookie
operator|->
name|type
operator|==
literal|0x12308086
condition|)
block|{
name|u_long
name|word40
decl_stmt|;
comment|/* can drive do PIO 4 and MW DMA 2? */
if|if
condition|(
operator|!
operator|(
name|mwdma_mode
argument_list|(
name|wp
argument_list|)
operator|>=
literal|2
operator|&&
name|pio_mode
argument_list|(
name|wp
argument_list|)
operator|>=
literal|4
operator|)
condition|)
return|return
literal|0
return|;
name|word40
operator|=
name|pci_conf_read
argument_list|(
name|cookie
operator|->
name|tag
argument_list|,
literal|0x40
argument_list|)
expr_stmt|;
name|word40
operator|>>=
name|cookie
operator|->
name|ctlr
operator|*
literal|16
expr_stmt|;
comment|/* Check for timing config usable for DMA on controller */
if|if
condition|(
operator|!
operator|(
operator|(
name|word40
operator|&
literal|0x3300
operator|)
operator|==
literal|0x2300
operator|&&
operator|(
operator|(
name|word40
operator|>>
operator|(
name|cookie
operator|->
name|unit
operator|*
literal|4
operator|)
operator|)
operator|&
literal|1
operator|)
operator|==
literal|1
operator|)
condition|)
return|return
literal|0
return|;
comment|/* Set multiword DMA mode 2 on drive */
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"intel_piix_dmainit: setting multiword DMA mode 2\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|wdcmd
argument_list|(
name|WDDMA_MDMA2
argument_list|,
name|wdinfo
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"intel_piix_dmainit: setting DMA mode failed\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
comment|/* otherwise, treat it as a PIIX3 and program it for MW DMA mode 2 */
elseif|else
if|if
condition|(
name|mwdma_mode
argument_list|(
name|wp
argument_list|)
operator|>=
literal|2
operator|&&
name|pio_mode
argument_list|(
name|wp
argument_list|)
operator|>=
literal|4
condition|)
block|{
name|u_long
name|mask40
decl_stmt|,
name|mask44
decl_stmt|,
name|new40
decl_stmt|,
name|new44
decl_stmt|;
comment|/*  		 * If SITRE is not set, set it and copy the 		 * appropriate bits into the secondary registers.  Do 		 * both controllers at once. 		 */
if|if
condition|(
operator|(
operator|(
name|pci_conf_read
argument_list|(
name|cookie
operator|->
name|tag
argument_list|,
literal|0x40
argument_list|)
operator|>>
operator|(
literal|16
operator|*
name|cookie
operator|->
name|ctlr
operator|)
operator|)
operator|&
literal|0x4000
operator|)
operator|==
literal|0
condition|)
block|{
name|unsigned
name|int
name|word40
decl_stmt|,
name|word44
decl_stmt|;
name|word40
operator|=
name|pci_conf_read
argument_list|(
name|cookie
operator|->
name|tag
argument_list|,
literal|0x40
argument_list|)
expr_stmt|;
comment|/* copy bits to secondary register */
name|word44
operator|=
name|pci_conf_read
argument_list|(
name|cookie
operator|->
name|tag
argument_list|,
literal|0x44
argument_list|)
expr_stmt|;
comment|/* 			 * I've got a Biostar motherboard with Award 			 * BIOS that sets SITRE and secondary timing 			 * on one controller but not the other. 			 * Bizarre. 			 */
if|if
condition|(
operator|(
name|word40
operator|&
literal|0x4000
operator|)
operator|==
literal|0
condition|)
block|{
name|word44
operator|&=
operator|~
literal|0xf
expr_stmt|;
name|word44
operator||=
operator|(
operator|(
name|word40
operator|&
literal|0x3000
operator|)
operator|>>
literal|10
operator|)
operator||
operator|(
operator|(
name|word40
operator|&
literal|0x0300
operator|)
operator|>>
literal|8
operator|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|word40
operator|&
literal|0x40000000
operator|)
operator|==
literal|0
condition|)
block|{
name|word44
operator|&=
operator|~
literal|0xf0
expr_stmt|;
name|word44
operator||=
operator|(
operator|(
name|word40
operator|&
literal|0x30000000
operator|)
operator|>>
literal|22
operator|)
operator||
operator|(
operator|(
name|word40
operator|&
literal|0x03000000
operator|)
operator|>>
literal|20
operator|)
expr_stmt|;
block|}
comment|/* set SITRE */
name|word40
operator||=
literal|0x40004000
expr_stmt|;
name|pci_conf_write
argument_list|(
name|cookie
operator|->
name|tag
argument_list|,
literal|0x40
argument_list|,
name|word40
argument_list|)
expr_stmt|;
name|pci_conf_write
argument_list|(
name|cookie
operator|->
name|tag
argument_list|,
literal|0x44
argument_list|,
name|word44
argument_list|)
expr_stmt|;
block|}
comment|/* Set multiword DMA mode 2 on drive */
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"intel_piix_dmainit: setting multiword DMA mode 2\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|wdcmd
argument_list|(
name|WDDMA_MDMA2
argument_list|,
name|wdinfo
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"intel_piix_dmainit: setting DMA mode failed\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/*  		 * backward compatible hardware leaves us with such 		 * twisted masses of software (aka twiddle the 		 * extremely weird register layout on a PIIX3, setting 		 * PIO mode 4 and MWDMA mode 2) 		 */
if|if
condition|(
name|cookie
operator|->
name|unit
operator|==
literal|0
condition|)
block|{
name|mask40
operator|=
literal|0x330f
expr_stmt|;
name|new40
operator|=
literal|0x2307
expr_stmt|;
name|mask44
operator|=
literal|0
expr_stmt|;
name|new44
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|mask40
operator|=
literal|0x00f0
expr_stmt|;
name|new40
operator|=
literal|0x0070
expr_stmt|;
name|mask44
operator|=
literal|0x000f
expr_stmt|;
name|new44
operator|=
literal|0x000b
expr_stmt|;
block|}
if|if
condition|(
name|cookie
operator|->
name|ctlr
condition|)
block|{
name|mask40
operator|<<=
literal|16
expr_stmt|;
name|new40
operator|<<=
literal|16
expr_stmt|;
name|mask44
operator|<<=
literal|4
expr_stmt|;
name|new44
operator|<<=
literal|4
expr_stmt|;
block|}
name|pci_conf_write
argument_list|(
name|cookie
operator|->
name|tag
argument_list|,
literal|0x40
argument_list|,
operator|(
name|pci_conf_read
argument_list|(
name|cookie
operator|->
name|tag
argument_list|,
literal|0x40
argument_list|)
operator|&
operator|~
name|mask40
operator|)
operator||
name|new40
argument_list|)
expr_stmt|;
name|pci_conf_write
argument_list|(
name|cookie
operator|->
name|tag
argument_list|,
literal|0x44
argument_list|,
operator|(
name|pci_conf_read
argument_list|(
name|cookie
operator|->
name|tag
argument_list|,
literal|0x44
argument_list|)
operator|&
operator|~
name|mask44
operator|)
operator||
name|new44
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|intel_piix_status
argument_list|(
name|cookie
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|vendor_fns
name|vs_intel_piix
init|=
block|{
name|intel_piix_dmainit
block|,
name|intel_piix_status
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|acer_status
parameter_list|(
name|struct
name|ide_pci_cookie
modifier|*
name|cookie
parameter_list|)
block|{
comment|/* XXX does not do anything right now */
block|}
end_function

begin_function
specifier|static
name|int
name|acer_dmainit
parameter_list|(
name|struct
name|ide_pci_cookie
modifier|*
name|cookie
parameter_list|,
name|struct
name|wdparams
modifier|*
name|wp
parameter_list|,
name|int
function_decl|(
modifier|*
name|wdcmd
function_decl|)
parameter_list|(
name|int
parameter_list|,
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
name|wdinfo
parameter_list|)
block|{
comment|/* Acer Aladdin DMA setup code. UDMA looks to be sinfully easy to set 	   on this thing - just one register. */
name|u_long
name|word54
init|=
name|pci_conf_read
argument_list|(
name|cookie
operator|->
name|tag
argument_list|,
literal|0x54
argument_list|)
decl_stmt|;
comment|/* Set the default Acer FIFO settings (0x55 = 13-word depth and 	   slave operation mode 1) */
name|word54
operator||=
literal|0x5555
expr_stmt|;
comment|/* Is this drive UDMA? Set it up if so... */
if|if
condition|(
name|udma_mode
argument_list|(
name|wp
argument_list|)
operator|>=
literal|2
condition|)
block|{
comment|/* This is really easy to do. Just write 0xa (enable  		   UDMA mode with 2T timing) into the word at the right 		   places. */
name|word54
operator||=
operator|(
literal|0xA
operator|<<
operator|(
literal|16
operator|+
operator|(
name|cookie
operator|->
name|ctlr
operator|*
literal|8
operator|)
operator|+
operator|(
name|cookie
operator|->
name|unit
operator|*
literal|4
operator|)
operator|)
operator|)
expr_stmt|;
comment|/* Now set the drive for UDMA2. */
if|if
condition|(
operator|!
name|wdcmd
argument_list|(
name|WDDMA_UDMA2
argument_list|,
name|wdinfo
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"acer_dmainit: could not set UDMA2 mode on wdc%d:%d!\n"
argument_list|,
name|cookie
operator|->
name|ctlr
argument_list|,
name|cookie
operator|->
name|unit
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Write the new config into the registers. I'm not  		   sure if I'm doing this in the right order. */
name|pci_conf_write
argument_list|(
name|cookie
operator|->
name|tag
argument_list|,
literal|0x54
argument_list|,
name|word54
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mwdma_mode
argument_list|(
name|wp
argument_list|)
operator|>=
literal|2
operator|&&
name|pio_mode
argument_list|(
name|wp
argument_list|)
operator|>=
literal|4
condition|)
block|{
comment|/* Otherwise, we're already set for regular DMA. */
if|if
condition|(
operator|!
name|wdcmd
argument_list|(
name|WDDMA_MDMA2
argument_list|,
name|wdinfo
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"acer_dmainit: could not set MWDMA2 mode on wdc%d:%d!\n"
argument_list|,
name|cookie
operator|->
name|ctlr
argument_list|,
name|cookie
operator|->
name|unit
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|vendor_fns
name|vs_acer
init|=
block|{
name|acer_dmainit
block|,
name|acer_status
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* SiS 5591 */
end_comment

begin_function
specifier|static
name|void
name|sis_5591_status
parameter_list|(
name|struct
name|ide_pci_cookie
modifier|*
name|cookie
parameter_list|)
block|{
name|int
name|iobase_wd
decl_stmt|;
name|int
name|ctlr
decl_stmt|,
name|unit
decl_stmt|;
name|int
name|iobase_bm
decl_stmt|;
name|pcici_t
name|tag
decl_stmt|;
name|pcidi_t
name|type
decl_stmt|;
name|u_int
name|word40
index|[
literal|5
index|]
decl_stmt|;
name|int
name|i
decl_stmt|,
name|unitno
decl_stmt|;
name|int
name|DRTC
decl_stmt|,
name|DATC
decl_stmt|;
name|int
name|val
decl_stmt|;
name|iobase_wd
operator|=
name|cookie
operator|->
name|iobase_wd
expr_stmt|;
name|unit
operator|=
name|cookie
operator|->
name|unit
expr_stmt|;
name|ctlr
operator|=
name|cookie
operator|->
name|ctlr
expr_stmt|;
name|iobase_bm
operator|=
name|cookie
operator|->
name|iobase_bm
expr_stmt|;
name|tag
operator|=
name|cookie
operator|->
name|tag
expr_stmt|;
name|type
operator|=
name|cookie
operator|->
name|type
expr_stmt|;
name|unitno
operator|=
name|ctlr
operator|*
literal|2
operator|+
name|unit
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|5
condition|;
name|i
operator|++
control|)
block|{
name|word40
index|[
name|i
index|]
operator|=
name|pci_conf_read
argument_list|(
name|tag
argument_list|,
name|i
operator|*
literal|4
operator|+
literal|0x40
argument_list|)
expr_stmt|;
block|}
name|DRTC
operator|=
name|word40
index|[
name|ctlr
index|]
operator|>>
operator|(
literal|16
operator|*
name|unit
operator|)
expr_stmt|;
name|DATC
operator|=
name|word40
index|[
name|ctlr
index|]
operator|>>
operator|(
literal|8
operator|+
literal|16
operator|*
name|unit
operator|)
expr_stmt|;
if|if
condition|(
name|unitno
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|word40
index|[
literal|4
index|]
operator|&
literal|0x80000
operator|)
operator|==
literal|0
condition|)
block|{
name|val
operator|=
name|word40
index|[
literal|2
index|]
operator|&
literal|0xf
expr_stmt|;
if|if
condition|(
name|val
operator|==
literal|0
condition|)
name|val
operator|=
literal|12
expr_stmt|;
elseif|else
if|if
condition|(
name|val
operator|>
literal|11
condition|)
name|val
operator|++
expr_stmt|;
name|printf
argument_list|(
literal|"SiS 5591 status: CRTC %d PCICLK, "
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|val
operator|=
operator|(
name|word40
index|[
literal|2
index|]
operator|>>
literal|8
operator|)
operator|&
literal|0x7
expr_stmt|;
if|if
condition|(
name|val
operator|==
literal|0
condition|)
name|val
operator|=
literal|8
expr_stmt|;
elseif|else
if|if
condition|(
name|val
operator|>
literal|6
condition|)
name|val
operator|=
literal|12
expr_stmt|;
name|printf
argument_list|(
literal|"CATC %d PCICLK, applies to all IDE devices\n"
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"SiS 5591 status: CRTC and CATC timings are per device, taken from DRTC and DATC\n"
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"SiS 5591 status: burst cycles %s, fast post write control %s\n"
argument_list|,
operator|(
operator|(
name|word40
index|[
literal|2
index|]
operator|>>
literal|16
operator|)
operator|&
literal|0x80
operator|)
condition|?
literal|"enabled"
else|:
literal|"disabled"
argument_list|,
operator|(
operator|(
name|word40
index|[
literal|2
index|]
operator|>>
literal|16
operator|)
operator|&
literal|0x20
operator|)
condition|?
literal|"enabled"
else|:
literal|"disabled"
argument_list|)
expr_stmt|;
block|}
name|val
operator|=
name|DRTC
operator|&
literal|0xf
expr_stmt|;
if|if
condition|(
name|val
operator|==
literal|0
condition|)
name|val
operator|=
literal|12
expr_stmt|;
elseif|else
if|if
condition|(
name|val
operator|>
literal|11
condition|)
name|val
operator|++
expr_stmt|;
name|printf
argument_list|(
literal|"SiS 5591 status: %s drive %d DRTC %d PCICLK,"
argument_list|,
name|unitno
operator|<
literal|2
condition|?
literal|"primary"
else|:
literal|"secondary"
argument_list|,
name|unitno
operator|&
literal|1
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|val
operator|=
name|DATC
operator|&
literal|0x7
expr_stmt|;
if|if
condition|(
name|val
operator|==
literal|0
condition|)
name|val
operator|=
literal|8
expr_stmt|;
elseif|else
if|if
condition|(
name|val
operator|>
literal|6
condition|)
name|val
operator|=
literal|12
expr_stmt|;
name|printf
argument_list|(
literal|" DATC %d PCICLK\n"
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"SiS 5591 status: %s drive %d Ultra DMA %s"
argument_list|,
name|unitno
operator|<
literal|2
condition|?
literal|"primary"
else|:
literal|"secondary"
argument_list|,
name|unitno
operator|&
literal|1
argument_list|,
operator|(
name|DATC
operator|&
literal|0x80
operator|)
condition|?
literal|"disabled\n"
else|:
literal|"enabled"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|DATC
operator|&
literal|0x80
operator|)
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|", %d PCICLK data out\n"
argument_list|,
operator|(
operator|(
name|DATC
operator|>>
literal|5
operator|)
operator|&
literal|0x3
operator|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"SiS 5591 status: %s drive %d postwrite %s, prefetch %s prefetch count is %d\n"
argument_list|,
name|unitno
operator|<
literal|2
condition|?
literal|"primary"
else|:
literal|"secondary"
argument_list|,
name|unitno
operator|&
literal|1
argument_list|,
operator|(
operator|(
name|word40
index|[
literal|2
index|]
operator|>>
operator|(
literal|28
operator|+
name|unitno
operator|)
operator|)
operator|&
literal|1
operator|)
condition|?
literal|"enabled"
else|:
literal|"disabled"
argument_list|,
operator|(
operator|(
name|word40
index|[
literal|2
index|]
operator|>>
operator|(
literal|24
operator|+
name|unitno
operator|)
operator|)
operator|&
literal|1
operator|)
condition|?
literal|"enabled"
else|:
literal|"disabled"
argument_list|,
operator|(
name|word40
index|[
literal|3
index|]
operator|>>
operator|(
literal|16
operator|*
name|ctlr
operator|)
operator|)
operator|&
literal|0xffff
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"SiS 5591 status: %s drive %d has%s been configured for DMA\n"
argument_list|,
name|unitno
operator|<
literal|2
condition|?
literal|"primary"
else|:
literal|"secondary"
argument_list|,
name|unitno
operator|&
literal|1
argument_list|,
operator|(
name|inb
argument_list|(
name|iobase_bm
operator|+
name|BMISTA_PORT
argument_list|)
operator|&
operator|(
operator|(
name|unit
operator|==
literal|0
operator|)
condition|?
name|BMISTA_DMA0CAP
else|:
name|BMISTA_DMA1CAP
operator|)
operator|)
condition|?
literal|" "
else|:
literal|" not"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|sis_5591_dmainit
parameter_list|(
name|struct
name|ide_pci_cookie
modifier|*
name|cookie
parameter_list|,
name|struct
name|wdparams
modifier|*
name|wp
parameter_list|,
name|int
function_decl|(
modifier|*
name|wdcmd
function_decl|)
parameter_list|(
name|int
parameter_list|,
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
name|wdinfo
parameter_list|)
block|{
name|int
name|r
decl_stmt|;
name|unsigned
name|int
name|workword
decl_stmt|,
name|new
decl_stmt|,
name|mask
decl_stmt|;
name|int
name|ctlr
decl_stmt|,
name|unit
decl_stmt|;
name|int
name|iobase_bm
decl_stmt|;
name|pcici_t
name|tag
decl_stmt|;
name|int
name|unitno
decl_stmt|;
name|unit
operator|=
name|cookie
operator|->
name|unit
expr_stmt|;
name|ctlr
operator|=
name|cookie
operator|->
name|ctlr
expr_stmt|;
name|iobase_bm
operator|=
name|cookie
operator|->
name|iobase_bm
expr_stmt|;
name|tag
operator|=
name|cookie
operator|->
name|tag
expr_stmt|;
name|unitno
operator|=
name|ctlr
operator|*
literal|2
operator|+
name|unit
expr_stmt|;
if|if
condition|(
name|udma_mode
argument_list|(
name|wp
argument_list|)
operator|>=
literal|2
condition|)
block|{
name|workword
operator|=
name|pci_conf_read
argument_list|(
name|tag
argument_list|,
name|ctlr
operator|*
literal|4
operator|+
literal|0x40
argument_list|)
expr_stmt|;
comment|/* These settings are a little arbitrary.  They're taken from my 		 * system, where the BIOS has already set the values, but where  		 * we don't detect that we're initialized because the 		 * BMISTA_DMA?CAP values aren't set by the BIOS. 		 * 0x8000 turns on UDMA 		 * 0x2000 sets UDMA cycle time to 2 PCI clocks for data out 		 * 0x0300 sets DATC to 3 PCI clocks 		 * 0x0001 sets DRTC to 1 PCI clock 		 */
if|if
condition|(
name|unit
condition|)
block|{
name|mask
operator|=
literal|0x0000ffff
expr_stmt|;
name|new
operator|=
literal|0xa3010000
expr_stmt|;
block|}
else|else
block|{
name|mask
operator|=
literal|0xffff0000
expr_stmt|;
name|new
operator|=
literal|0x0000a301
expr_stmt|;
block|}
name|workword
operator|&=
name|mask
expr_stmt|;
name|workword
operator||=
name|new
expr_stmt|;
name|pci_conf_write
argument_list|(
name|tag
argument_list|,
name|ctlr
operator|*
literal|4
operator|+
literal|0x40
argument_list|,
name|workword
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|iobase_bm
operator|+
name|BMISTA_PORT
argument_list|,
operator|(
name|inb
argument_list|(
name|iobase_bm
operator|+
name|BMISTA_PORT
argument_list|)
operator||
operator|(
operator|(
name|unit
operator|==
literal|0
operator|)
condition|?
name|BMISTA_DMA0CAP
else|:
name|BMISTA_DMA1CAP
operator|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"SiS 5591 dmainit: %s drive %d setting ultra DMA mode 2\n"
argument_list|,
name|unitno
operator|<
literal|2
condition|?
literal|"primary"
else|:
literal|"secondary"
argument_list|,
name|unitno
operator|&
literal|1
argument_list|)
expr_stmt|;
name|r
operator|=
name|wdcmd
argument_list|(
name|WDDMA_UDMA2
argument_list|,
name|wdinfo
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|r
condition|)
block|{
name|printf
argument_list|(
literal|"SiS 5591 dmainit: %s drive %d setting DMA mode failed\n"
argument_list|,
name|unitno
operator|<
literal|2
condition|?
literal|"primary"
else|:
literal|"secondary"
argument_list|,
name|unitno
operator|&
literal|1
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|bootverbose
condition|)
name|sis_5591_status
argument_list|(
name|cookie
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* otherwise, try and program it for MW DMA mode 2 */
elseif|else
if|if
condition|(
name|mwdma_mode
argument_list|(
name|wp
argument_list|)
operator|>=
literal|2
operator|&&
name|pio_mode
argument_list|(
name|wp
argument_list|)
operator|>=
literal|4
condition|)
block|{
name|workword
operator|=
name|pci_conf_read
argument_list|(
name|tag
argument_list|,
name|ctlr
operator|*
literal|4
operator|+
literal|0x40
argument_list|)
expr_stmt|;
comment|/* These settings are a little arbitrary.  They're taken from my 		 * system, where the BIOS has already set the values, but where  		 * we don't detect that we're initialized because the 		 * BMISTA_DMA?CAP values aren't set by the BIOS. 		 * 0x0300 sets DATC to 3 PCI clocks 		 * 0x0001 sets DRTC to 1 PCI clock 		 */
if|if
condition|(
name|unit
condition|)
block|{
name|mask
operator|=
literal|0x0000ffff
expr_stmt|;
name|new
operator|=
literal|0x03010000
expr_stmt|;
block|}
else|else
block|{
name|mask
operator|=
literal|0xffff0000
expr_stmt|;
name|new
operator|=
literal|0x00000301
expr_stmt|;
block|}
name|workword
operator|&=
name|mask
expr_stmt|;
name|workword
operator||=
name|new
expr_stmt|;
name|pci_conf_write
argument_list|(
name|tag
argument_list|,
name|ctlr
operator|*
literal|4
operator|+
literal|0x40
argument_list|,
name|workword
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|iobase_bm
operator|+
name|BMISTA_PORT
argument_list|,
operator|(
name|inb
argument_list|(
name|iobase_bm
operator|+
name|BMISTA_PORT
argument_list|)
operator||
operator|(
operator|(
name|unit
operator|==
literal|0
operator|)
condition|?
name|BMISTA_DMA0CAP
else|:
name|BMISTA_DMA1CAP
operator|)
operator|)
argument_list|)
expr_stmt|;
comment|/* Set multiword DMA mode 2 on drive */
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"SiS 5591 dmainit: %s drive %d setting multiword DMA mode 2\n"
argument_list|,
name|unitno
operator|<
literal|2
condition|?
literal|"primary"
else|:
literal|"secondary"
argument_list|,
name|unitno
operator|&
literal|1
argument_list|)
expr_stmt|;
name|r
operator|=
name|wdcmd
argument_list|(
name|WDDMA_MDMA2
argument_list|,
name|wdinfo
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|r
condition|)
block|{
name|printf
argument_list|(
literal|"SiS 5591 dmainit: %s drive %d setting DMA mode failed\n"
argument_list|,
name|unitno
operator|<
literal|2
condition|?
literal|"primary"
else|:
literal|"secondary"
argument_list|,
name|unitno
operator|&
literal|1
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|bootverbose
condition|)
name|sis_5591_status
argument_list|(
name|cookie
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|vendor_fns
name|vs_sis_5591
init|=
block|{
name|sis_5591_dmainit
block|,
name|sis_5591_status
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Generic SFF-8038i code-- all code below here, except for PCI probes,  * more or less conforms to the SFF-8038i spec as extended for PCI.  * There should be no code that goes beyond that feature set below.  */
end_comment

begin_comment
comment|/* XXX mkcookie is overloaded with too many parameters */
end_comment

begin_function
specifier|static
name|struct
name|ide_pci_cookie
modifier|*
name|mkcookie
parameter_list|(
name|int
name|iobase_wd
parameter_list|,
name|int
name|ctlr
parameter_list|,
name|int
name|unit
parameter_list|,
name|int
name|iobase_bm
parameter_list|,
name|pcici_t
name|tag
parameter_list|,
name|pcidi_t
name|type
parameter_list|,
name|struct
name|vendor_fns
modifier|*
name|vp
parameter_list|,
name|int
name|altiobase_wd
parameter_list|)
block|{
name|struct
name|ide_pci_cookie
modifier|*
name|cp
decl_stmt|;
name|cp
operator|=
name|malloc
argument_list|(
sizeof|sizeof
expr|*
name|cp
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cp
condition|)
return|return
literal|0
return|;
name|cp
operator|->
name|iobase_wd
operator|=
name|iobase_wd
expr_stmt|;
name|cp
operator|->
name|ctlr
operator|=
name|ctlr
expr_stmt|;
name|cp
operator|->
name|unit
operator|=
name|unit
expr_stmt|;
name|cp
operator|->
name|tag
operator|=
name|tag
expr_stmt|;
name|cp
operator|->
name|type
operator|=
name|type
expr_stmt|;
name|cp
operator|->
name|iobase_bm
operator|=
name|iobase_bm
expr_stmt|;
name|cp
operator|->
name|altiobase_wd
operator|=
name|altiobase_wd
expr_stmt|;
name|bcopy
argument_list|(
name|vp
argument_list|,
operator|&
name|cp
operator|->
name|vs
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|vendor_fns
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|prdbuf
condition|)
block|{
name|prdbuf
operator|=
name|malloc
argument_list|(
name|PRD_ALLOC_SIZE
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|prdbuf
condition|)
block|{
name|FREE
argument_list|(
name|cp
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|(
operator|(
name|int
operator|)
name|prdbuf
operator|>>
name|PAGE_SHIFT
operator|)
operator|^
operator|(
operator|(
operator|(
name|int
operator|)
name|prdbuf
operator|+
name|PRD_ALLOC_SIZE
operator|-
literal|1
operator|)
operator|>>
name|PAGE_SHIFT
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"ide_pci: prdbuf straddles page boundary, no DMA\n"
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|cp
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|prdbuf
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|prdbuf_next
operator|=
name|prdbuf
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|(
name|char
operator|*
operator|)
name|prdbuf_next
operator|+
name|PRD_BUF_SIZE
operator|)
operator|>
operator|(
operator|(
name|char
operator|*
operator|)
name|prdbuf
operator|+
name|PRD_ALLOC_SIZE
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"ide_pci: mkcookie %04x:%d: no more space for PRDs, no DMA\n"
argument_list|,
name|iobase_wd
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|cp
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|cp
operator|->
name|prd
operator|=
name|prdbuf_next
expr_stmt|;
operator|(
name|char
operator|*
operator|)
name|prdbuf_next
operator|+=
name|PRD_BUF_SIZE
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|softc
operator|.
name|cookies
argument_list|,
name|cp
argument_list|,
name|le
argument_list|)
expr_stmt|;
return|return
name|cp
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|ide_pci_probe
parameter_list|(
name|pcici_t
name|tag
parameter_list|,
name|pcidi_t
name|type
parameter_list|)
block|{
name|u_long
name|data
decl_stmt|;
name|data
operator|=
name|pci_conf_read
argument_list|(
name|tag
argument_list|,
name|PCI_CLASS_REG
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|data
operator|&
name|PCI_CLASS_MASK
operator|)
operator|==
name|PCI_CLASS_MASS_STORAGE
operator|&&
operator|(
operator|(
name|data
operator|&
name|PCI_SUBCLASS_MASK
operator|)
operator|==
literal|0x00010000
operator|||
operator|(
operator|(
name|data
operator|&
name|PCI_SUBCLASS_MASK
operator|)
operator|==
literal|0x00040000
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|type
operator|==
literal|0x71118086
condition|)
return|return
operator|(
literal|"Intel PIIX4 Bus-master IDE controller"
operator|)
return|;
if|if
condition|(
name|type
operator|==
literal|0x70108086
condition|)
return|return
operator|(
literal|"Intel PIIX3 Bus-master IDE controller"
operator|)
return|;
if|if
condition|(
name|type
operator|==
literal|0x12308086
condition|)
return|return
operator|(
literal|"Intel PIIX Bus-master IDE controller"
operator|)
return|;
if|if
condition|(
name|type
operator|==
name|PROMISE_ULTRA33
condition|)
return|return
operator|(
literal|"Promise Ultra/33 IDE controller"
operator|)
return|;
if|if
condition|(
name|type
operator|==
literal|0x05711106
condition|)
return|return
operator|(
literal|"VIA 82C586x (Apollo) Bus-master IDE controller"
operator|)
return|;
if|if
condition|(
name|type
operator|==
literal|0x01021078
condition|)
return|return
operator|(
literal|"Cyrix 5530 Bus-master IDE controller"
operator|)
return|;
if|if
condition|(
name|type
operator|==
literal|0x522910b9
condition|)
return|return
operator|(
literal|"Acer Aladdin IV/V (M5229) Bus-master IDE controller"
operator|)
return|;
if|if
condition|(
name|type
operator|==
literal|0x55131039
condition|)
return|return
operator|(
literal|"SiS 5591 Bus-master IDE Controller"
operator|)
return|;
if|if
condition|(
name|type
operator|==
name|CMD640B_PCI_ID
condition|)
return|return
literal|"CMD 640B IDE controller"
return|;
if|if
condition|(
name|data
operator|&
literal|0x8000
condition|)
return|return
operator|(
literal|"PCI IDE controller (busmaster capable)"
operator|)
return|;
else|else
return|return
operator|(
literal|"PCI IDE controller (not busmaster capable)"
operator|)
return|;
block|}
empty_stmt|;
return|return
operator|(
operator|(
name|char
operator|*
operator|)
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ide_pci_attach
parameter_list|(
name|pcici_t
name|tag
parameter_list|,
name|int
name|unit
parameter_list|)
block|{
name|u_long
name|class
init|=
literal|0
decl_stmt|,
name|cmd
decl_stmt|;
name|int
name|bmista_1
decl_stmt|,
name|bmista_2
decl_stmt|;
name|int
name|iobase_wd_1
decl_stmt|,
name|iobase_wd_2
decl_stmt|,
name|iobase_bm_1
decl_stmt|,
name|iobase_bm_2
decl_stmt|;
name|int
name|altiobase_wd_1
decl_stmt|,
name|altiobase_wd_2
decl_stmt|;
name|struct
name|vendor_fns
modifier|*
name|vp
decl_stmt|;
name|pcidi_t
name|type
decl_stmt|;
name|struct
name|ide_pci_cookie
modifier|*
name|cookie
decl_stmt|;
name|int
name|ctlridx
decl_stmt|;
name|ctlridx
operator|=
name|unit
operator|*
literal|2
expr_stmt|;
comment|/* set up vendor-specific stuff */
name|type
operator|=
name|pci_conf_read
argument_list|(
name|tag
argument_list|,
name|PCI_ID_REG
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|CMD640B_PCI_ID
condition|)
block|{
name|wdc_pci
argument_list|(
name|Q_CMD640B
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|type
operator|!=
name|PROMISE_ULTRA33
condition|)
block|{
comment|/* is it busmaster capable?  bail if not */
name|class
operator|=
name|pci_conf_read
argument_list|(
name|tag
argument_list|,
name|PCI_CLASS_REG
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|class
operator|&
literal|0x8000
operator|)
condition|)
block|{
return|return;
block|}
comment|/* is it enabled and is busmastering turned on? */
name|cmd
operator|=
name|pci_conf_read
argument_list|(
name|tag
argument_list|,
name|PCI_COMMAND_STATUS_REG
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cmd
operator|&
literal|5
operator|)
operator|!=
literal|5
condition|)
block|{
return|return;
block|}
block|}
switch|switch
condition|(
name|type
condition|)
block|{
case|case
literal|0x71118086
case|:
case|case
literal|0x70108086
case|:
case|case
literal|0x12308086
case|:
comment|/* Intel PIIX, PIIX3, PIIX4 */
name|vp
operator|=
operator|&
name|vs_intel_piix
expr_stmt|;
break|break;
case|case
literal|0x5711106
case|:
comment|/* VIA Apollo chipset family */
name|vp
operator|=
operator|&
name|vs_via_571
expr_stmt|;
break|break;
case|case
name|PROMISE_ULTRA33
case|:
comment|/* Promise controllers */
name|vp
operator|=
operator|&
name|vs_promise
expr_stmt|;
break|break;
case|case
literal|0x01021078
case|:
comment|/* cyrix 5530 */
name|printf
argument_list|(
literal|"cyrix 5530\n"
argument_list|)
expr_stmt|;
name|vp
operator|=
operator|&
name|vs_cyrix_5530
expr_stmt|;
break|break;
case|case
literal|0x522910B9
case|:
comment|/* Acer Aladdin IV/V (M5229) */
name|vp
operator|=
operator|&
name|vs_acer
expr_stmt|;
break|break;
case|case
literal|0x55131039
case|:
comment|/* SiS 5591 */
name|vp
operator|=
operator|&
name|vs_sis_5591
expr_stmt|;
break|break;
default|default:
comment|/* everybody else */
name|vp
operator|=
operator|&
name|vs_generic
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|type
operator|!=
name|PROMISE_ULTRA33
condition|)
block|{
if|if
condition|(
operator|(
name|class
operator|&
literal|0x100
operator|)
operator|==
literal|0
condition|)
block|{
name|iobase_wd_1
operator|=
name|IO_WD1
expr_stmt|;
name|altiobase_wd_1
operator|=
name|iobase_wd_1
operator|+
name|wd_altsts
expr_stmt|;
block|}
else|else
block|{
name|iobase_wd_1
operator|=
name|pci_conf_read
argument_list|(
name|tag
argument_list|,
literal|0x10
argument_list|)
operator|&
literal|0xfffc
expr_stmt|;
name|altiobase_wd_1
operator|=
name|pci_conf_read
argument_list|(
name|tag
argument_list|,
literal|0x14
argument_list|)
operator|&
literal|0xfffc
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|class
operator|&
literal|0x400
operator|)
operator|==
literal|0
condition|)
block|{
name|iobase_wd_2
operator|=
name|IO_WD2
expr_stmt|;
name|altiobase_wd_2
operator|=
name|iobase_wd_2
operator|+
name|wd_altsts
expr_stmt|;
block|}
else|else
block|{
name|iobase_wd_2
operator|=
name|pci_conf_read
argument_list|(
name|tag
argument_list|,
literal|0x18
argument_list|)
operator|&
literal|0xfffc
expr_stmt|;
name|altiobase_wd_2
operator|=
name|pci_conf_read
argument_list|(
name|tag
argument_list|,
literal|0x1c
argument_list|)
operator|&
literal|0xfffc
expr_stmt|;
block|}
block|}
else|else
block|{
name|iobase_wd_1
operator|=
name|pci_conf_read
argument_list|(
name|tag
argument_list|,
literal|0x10
argument_list|)
operator|&
literal|0xfffc
expr_stmt|;
name|altiobase_wd_1
operator|=
name|pci_conf_read
argument_list|(
name|tag
argument_list|,
literal|0x14
argument_list|)
operator|&
literal|0xfffc
expr_stmt|;
name|iobase_wd_2
operator|=
name|pci_conf_read
argument_list|(
name|tag
argument_list|,
literal|0x18
argument_list|)
operator|&
literal|0xfffc
expr_stmt|;
name|altiobase_wd_2
operator|=
name|pci_conf_read
argument_list|(
name|tag
argument_list|,
literal|0x1c
argument_list|)
operator|&
literal|0xfffc
expr_stmt|;
block|}
name|iobase_bm_1
operator|=
name|pci_conf_read
argument_list|(
name|tag
argument_list|,
literal|0x20
argument_list|)
operator|&
literal|0xfffc
expr_stmt|;
if|if
condition|(
name|iobase_bm_1
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"ide_pci: BIOS has not configured busmaster"
literal|"I/O address,\n ide_pci:  giving up\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|iobase_bm_2
operator|=
name|iobase_bm_1
operator|+
name|SFF8038_CTLR_1
expr_stmt|;
name|wddma
index|[
name|unit
index|]
operator|.
name|wdd_candma
operator|=
name|ide_pci_candma
expr_stmt|;
name|wddma
index|[
name|unit
index|]
operator|.
name|wdd_dmainit
operator|=
name|ide_pci_dmainit
expr_stmt|;
if|if
condition|(
name|type
operator|==
literal|0x01021078
comment|/*CYRIX_5530*/
condition|)
name|wddma
index|[
name|unit
index|]
operator|.
name|wdd_dmaverify
operator|=
name|cyrix_5530_dmaverify
expr_stmt|;
else|else
name|wddma
index|[
name|unit
index|]
operator|.
name|wdd_dmaverify
operator|=
name|ide_pci_dmaverify
expr_stmt|;
name|wddma
index|[
name|unit
index|]
operator|.
name|wdd_dmaprep
operator|=
name|ide_pci_dmasetup
expr_stmt|;
name|wddma
index|[
name|unit
index|]
operator|.
name|wdd_dmastart
operator|=
name|ide_pci_dmastart
expr_stmt|;
name|wddma
index|[
name|unit
index|]
operator|.
name|wdd_dmadone
operator|=
name|ide_pci_dmadone
expr_stmt|;
name|wddma
index|[
name|unit
index|]
operator|.
name|wdd_dmastatus
operator|=
name|ide_pci_status
expr_stmt|;
name|wddma
index|[
name|unit
index|]
operator|.
name|wdd_iobase
operator|=
name|ide_pci_iobase
expr_stmt|;
name|wddma
index|[
name|unit
index|]
operator|.
name|wdd_altiobase
operator|=
name|ide_pci_altiobase
expr_stmt|;
name|bmista_1
operator|=
name|inb
argument_list|(
name|iobase_bm_1
operator|+
name|BMISTA_PORT
argument_list|)
expr_stmt|;
name|bmista_2
operator|=
name|inb
argument_list|(
name|iobase_bm_2
operator|+
name|BMISTA_PORT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ide_pci_softc_cookies_initted
condition|)
block|{
name|LIST_INIT
argument_list|(
operator|&
name|softc
operator|.
name|cookies
argument_list|)
expr_stmt|;
name|ide_pci_softc_cookies_initted
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|iobase_wd_1
operator|!=
literal|0
condition|)
block|{
name|cookie
operator|=
name|mkcookie
argument_list|(
name|iobase_wd_1
argument_list|,
name|ctlridx
argument_list|,
literal|0
argument_list|,
name|iobase_bm_1
argument_list|,
name|tag
argument_list|,
name|type
argument_list|,
name|vp
argument_list|,
name|altiobase_wd_1
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|vp
operator|->
name|vendor_status
argument_list|(
name|cookie
argument_list|)
expr_stmt|;
name|cookie
operator|=
name|mkcookie
argument_list|(
name|iobase_wd_1
argument_list|,
name|ctlridx
argument_list|,
literal|1
argument_list|,
name|iobase_bm_1
argument_list|,
name|tag
argument_list|,
name|type
argument_list|,
name|vp
argument_list|,
name|altiobase_wd_1
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
block|{
name|vp
operator|->
name|vendor_status
argument_list|(
name|cookie
argument_list|)
expr_stmt|;
name|bmista_1
operator|=
name|inb
argument_list|(
name|iobase_bm_1
operator|+
name|BMISTA_PORT
argument_list|)
expr_stmt|;
name|bmista_2
operator|=
name|inb
argument_list|(
name|iobase_bm_2
operator|+
name|BMISTA_PORT
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"ide_pci: busmaster 0 status: %02x from port: %08x\n"
argument_list|,
name|bmista_1
argument_list|,
name|iobase_bm_1
operator|+
name|BMISTA_PORT
argument_list|)
expr_stmt|;
if|if
condition|(
name|bmista_1
operator|&
name|BMISTA_DMA0CAP
condition|)
name|printf
argument_list|(
literal|"ide_pci: ide0:0 has been configured for DMA by BIOS\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|bmista_1
operator|&
name|BMISTA_DMA1CAP
condition|)
name|printf
argument_list|(
literal|"ide_pci: ide0:1 has been configured for DMA by BIOS\n"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|iobase_wd_2
operator|!=
literal|0
condition|)
block|{
name|cookie
operator|=
name|mkcookie
argument_list|(
name|iobase_wd_2
argument_list|,
name|ctlridx
operator|+
literal|1
argument_list|,
literal|0
argument_list|,
name|iobase_bm_2
argument_list|,
name|tag
argument_list|,
name|type
argument_list|,
name|vp
argument_list|,
name|altiobase_wd_2
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|vp
operator|->
name|vendor_status
argument_list|(
name|cookie
argument_list|)
expr_stmt|;
name|cookie
operator|=
name|mkcookie
argument_list|(
name|iobase_wd_2
argument_list|,
name|ctlridx
operator|+
literal|1
argument_list|,
literal|1
argument_list|,
name|iobase_bm_2
argument_list|,
name|tag
argument_list|,
name|type
argument_list|,
name|vp
argument_list|,
name|altiobase_wd_2
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
block|{
name|vp
operator|->
name|vendor_status
argument_list|(
name|cookie
argument_list|)
expr_stmt|;
name|bmista_1
operator|=
name|inb
argument_list|(
name|iobase_bm_1
operator|+
name|BMISTA_PORT
argument_list|)
expr_stmt|;
name|bmista_2
operator|=
name|inb
argument_list|(
name|iobase_bm_2
operator|+
name|BMISTA_PORT
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"ide_pci: busmaster 1 status: %02x from port: %08x\n"
argument_list|,
name|bmista_2
argument_list|,
name|iobase_bm_2
operator|+
name|BMISTA_PORT
argument_list|)
expr_stmt|;
if|if
condition|(
name|bmista_2
operator|&
name|BMISTA_DMA0CAP
condition|)
name|printf
argument_list|(
literal|"ide_pci: ide1:0 has been configured for DMA by BIOS\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|bmista_2
operator|&
name|BMISTA_DMA1CAP
condition|)
name|printf
argument_list|(
literal|"ide_pci: ide1:1 has been configured for DMA by BIOS\n"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_decl_stmt
specifier|static
name|u_long
name|ide_pci_count
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|pci_device
name|ide_pci_device
init|=
block|{
literal|"ide_pci"
block|,
name|ide_pci_probe
block|,
name|ide_pci_attach
block|,
operator|&
name|ide_pci_count
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|COMPAT_PCI_DRIVER
argument_list|(
name|ide_pci
argument_list|,
name|ide_pci_device
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Return a cookie if we may be able to do DMA on the specified  * (iobase_wd, ctlr, unit).  */
end_comment

begin_function
specifier|static
name|void
modifier|*
name|ide_pci_candma
parameter_list|(
name|int
name|iobase_wd
parameter_list|,
name|int
name|ctlr
parameter_list|,
name|int
name|unit
parameter_list|)
block|{
name|struct
name|ide_pci_cookie
modifier|*
name|cp
decl_stmt|;
name|cp
operator|=
name|softc
operator|.
name|cookies
operator|.
name|lh_first
expr_stmt|;
while|while
condition|(
name|cp
condition|)
block|{
if|if
condition|(
name|cp
operator|->
name|ctlr
operator|==
name|ctlr
operator|&&
name|cp
operator|->
name|unit
operator|==
name|unit
operator|&&
operator|(
operator|(
name|iobase_wd
operator|==
literal|0
operator|)
operator|||
operator|(
name|cp
operator|->
name|iobase_wd
operator|==
name|iobase_wd
operator|)
operator|)
condition|)
break|break;
name|cp
operator|=
name|cp
operator|->
name|le
operator|.
name|le_next
expr_stmt|;
block|}
return|return
name|cp
return|;
block|}
end_function

begin_comment
comment|/*  * Initialize controller and drive for DMA operation, including timing modes.  * Uses data passed from the wd driver and a callback function to initialize  * timing modes on the drive.  */
end_comment

begin_function
specifier|static
name|int
name|ide_pci_dmainit
parameter_list|(
name|void
modifier|*
name|cookie
parameter_list|,
name|struct
name|wdparams
modifier|*
name|wp
parameter_list|,
name|int
function_decl|(
modifier|*
name|wdcmd
function_decl|)
parameter_list|(
name|int
parameter_list|,
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
name|wdinfo
parameter_list|)
block|{
name|struct
name|ide_pci_cookie
modifier|*
name|cp
init|=
name|cookie
decl_stmt|;
comment|/*  	 * If the controller status indicates that DMA is configured already, 	 * we flounce happily away 	 */
if|if
condition|(
name|inb
argument_list|(
name|cp
operator|->
name|iobase_bm
operator|+
name|BMISTA_PORT
argument_list|)
operator|&
operator|(
operator|(
name|cp
operator|->
name|unit
operator|==
literal|0
operator|)
condition|?
name|BMISTA_DMA0CAP
else|:
name|BMISTA_DMA1CAP
operator|)
condition|)
return|return
literal|1
return|;
comment|/* We take a stab at it with device-dependent code */
return|return
operator|(
name|cp
operator|->
name|vs
operator|.
name|vendor_dmainit
argument_list|(
name|cp
argument_list|,
name|wp
argument_list|,
name|wdcmd
argument_list|,
name|wdinfo
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Verify that controller can handle a dma request for cp.  Should  * not affect any hardware or driver state.  */
end_comment

begin_function
specifier|static
name|int
name|ide_pci_dmaverify
parameter_list|(
name|void
modifier|*
name|xcp
parameter_list|,
name|char
modifier|*
name|vaddr
parameter_list|,
name|u_long
name|count
parameter_list|,
name|int
name|dir
parameter_list|)
block|{
name|int
name|badfu
decl_stmt|;
comment|/* 	 * check for nonaligned or odd-length Stuff 	 */
name|badfu
operator|=
operator|(
operator|(
name|unsigned
name|int
operator|)
name|vaddr
operator|&
literal|1
operator|)
operator|||
operator|(
name|count
operator|&
literal|1
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
name|badfu
condition|)
block|{
name|printf
argument_list|(
literal|"ide_pci: dmaverify odd vaddr or length, "
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"vaddr = %p length = %08lx\n"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|vaddr
argument_list|,
name|count
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return
operator|(
operator|!
name|badfu
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Set up DMA for cp.  It is the responsibility of the caller  * to ensure that the controller is idle before this routine  * is called.  */
end_comment

begin_function
specifier|static
name|int
name|ide_pci_dmasetup
parameter_list|(
name|void
modifier|*
name|xcp
parameter_list|,
name|char
modifier|*
name|vaddr
parameter_list|,
name|u_long
name|vcount
parameter_list|,
name|int
name|dir
parameter_list|)
block|{
name|struct
name|ide_pci_cookie
modifier|*
name|cp
init|=
name|xcp
decl_stmt|;
name|struct
name|ide_pci_prd
modifier|*
name|prd
decl_stmt|;
name|int
name|i
decl_stmt|;
name|u_long
name|firstpage
decl_stmt|;
name|u_long
name|prd_base
decl_stmt|,
name|prd_count
decl_stmt|;
name|u_long
name|nbase
decl_stmt|,
name|ncount
decl_stmt|,
name|nend
decl_stmt|;
name|int
name|iobase_bm
decl_stmt|;
name|u_long
name|count
decl_stmt|;
name|prd
operator|=
name|cp
operator|->
name|prd
expr_stmt|;
name|count
operator|=
name|vcount
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
name|iobase_bm
operator|=
name|cp
operator|->
name|iobase_bm
expr_stmt|;
if|if
condition|(
name|count
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"ide_pci: dmasetup 0-length transfer, "
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"vaddr = %p length = %08lx\n"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|vaddr
argument_list|,
name|count
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* Generate first PRD entry, which may be non-aligned. */
name|firstpage
operator|=
name|PAGE_SIZE
operator|-
operator|(
operator|(
name|uintptr_t
operator|)
name|vaddr
operator|&
name|PAGE_MASK
operator|)
expr_stmt|;
name|prd_base
operator|=
name|vtophys
argument_list|(
name|vaddr
argument_list|)
expr_stmt|;
name|prd_count
operator|=
name|MIN
argument_list|(
name|count
argument_list|,
name|firstpage
argument_list|)
expr_stmt|;
name|vaddr
operator|+=
name|prd_count
expr_stmt|;
name|count
operator|-=
name|prd_count
expr_stmt|;
comment|/* 	 * Step through virtual pages. 	 * Note that it is not worth trying to coalesce pages that are  	 * next to each other physically, and some DMA engines (e.g. 	 * Cyrix Cx5530) actually blow up if you do. 	 */
while|while
condition|(
name|count
condition|)
block|{
name|nbase
operator|=
name|vtophys
argument_list|(
name|vaddr
argument_list|)
expr_stmt|;
name|ncount
operator|=
name|MIN
argument_list|(
name|count
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
name|nend
operator|=
name|nbase
operator|+
name|ncount
expr_stmt|;
name|prd
index|[
name|i
index|]
operator|.
name|prd_base
operator|=
name|prd_base
expr_stmt|;
name|prd
index|[
name|i
index|]
operator|.
name|prd_count
operator|=
operator|(
name|prd_count
operator|&
literal|0xffff
operator|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|i
operator|>=
name|PRD_MAX_SEGS
condition|)
block|{
name|printf
argument_list|(
literal|"wd82371: too many segments in PRD table\n"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|prd_base
operator|=
name|nbase
expr_stmt|;
name|prd_count
operator|=
name|ncount
expr_stmt|;
name|vaddr
operator|+=
name|ncount
expr_stmt|;
name|count
operator|-=
name|ncount
expr_stmt|;
block|}
comment|/* Write last PRD entry. */
name|prd
index|[
name|i
index|]
operator|.
name|prd_base
operator|=
name|prd_base
expr_stmt|;
name|prd
index|[
name|i
index|]
operator|.
name|prd_count
operator|=
operator|(
name|prd_count
operator|&
literal|0xffff
operator|)
operator||
name|PRD_EOT_BIT
expr_stmt|;
comment|/* Set up PRD base register */
name|outl
argument_list|(
name|iobase_bm
operator|+
name|BMIDTP_PORT
argument_list|,
name|vtophys
argument_list|(
name|prd
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Set direction of transfer */
name|outb
argument_list|(
name|iobase_bm
operator|+
name|BMICOM_PORT
argument_list|,
operator|(
name|dir
operator|==
name|B_READ
operator|)
condition|?
name|BMICOM_READ_WRITE
else|:
literal|0
argument_list|)
expr_stmt|;
comment|/* Clear interrupt and error bits */
name|outb
argument_list|(
name|iobase_bm
operator|+
name|BMISTA_PORT
argument_list|,
operator|(
name|inb
argument_list|(
name|iobase_bm
operator|+
name|BMISTA_PORT
argument_list|)
operator||
operator|(
name|BMISTA_INTERRUPT
operator||
name|BMISTA_DMA_ERROR
operator|)
operator|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ide_pci_dmastart
parameter_list|(
name|void
modifier|*
name|xcp
parameter_list|)
block|{
name|struct
name|ide_pci_cookie
modifier|*
name|cp
init|=
name|xcp
decl_stmt|;
name|int
name|iobase_bm
decl_stmt|;
name|iobase_bm
operator|=
name|cp
operator|->
name|iobase_bm
expr_stmt|;
name|outb
argument_list|(
name|iobase_bm
operator|+
name|BMICOM_PORT
argument_list|,
name|inb
argument_list|(
name|iobase_bm
operator|+
name|BMICOM_PORT
argument_list|)
operator||
name|BMICOM_STOP_START
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|ide_pci_dmadone
parameter_list|(
name|void
modifier|*
name|xcp
parameter_list|)
block|{
name|struct
name|ide_pci_cookie
modifier|*
name|cp
init|=
name|xcp
decl_stmt|;
name|int
name|iobase_bm
decl_stmt|,
name|status
decl_stmt|;
name|status
operator|=
name|ide_pci_status
argument_list|(
name|xcp
argument_list|)
expr_stmt|;
name|iobase_bm
operator|=
name|cp
operator|->
name|iobase_bm
expr_stmt|;
name|outb
argument_list|(
name|iobase_bm
operator|+
name|BMICOM_PORT
argument_list|,
name|inb
argument_list|(
name|iobase_bm
operator|+
name|BMICOM_PORT
argument_list|)
operator|&
operator|~
name|BMICOM_STOP_START
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ide_pci_status
parameter_list|(
name|void
modifier|*
name|xcp
parameter_list|)
block|{
name|int
name|iobase_bm
decl_stmt|,
name|status
decl_stmt|,
name|bmista
decl_stmt|;
name|status
operator|=
literal|0
expr_stmt|;
name|iobase_bm
operator|=
operator|(
operator|(
expr|struct
name|ide_pci_cookie
operator|*
operator|)
name|xcp
operator|)
operator|->
name|iobase_bm
expr_stmt|;
name|bmista
operator|=
name|inb
argument_list|(
name|iobase_bm
operator|+
name|BMISTA_PORT
argument_list|)
expr_stmt|;
if|if
condition|(
name|bmista
operator|&
name|BMISTA_INTERRUPT
condition|)
name|status
operator||=
name|WDDS_INTERRUPT
expr_stmt|;
if|if
condition|(
name|bmista
operator|&
name|BMISTA_DMA_ERROR
condition|)
name|status
operator||=
name|WDDS_ERROR
expr_stmt|;
if|if
condition|(
name|bmista
operator|&
name|BMISTA_DMA_ACTIVE
condition|)
name|status
operator||=
name|WDDS_ACTIVE
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ide_pci_altiobase
parameter_list|(
name|void
modifier|*
name|xcp
parameter_list|)
block|{
name|struct
name|ide_pci_cookie
modifier|*
name|cp
init|=
name|xcp
decl_stmt|;
if|if
condition|(
name|cp
operator|==
literal|0
condition|)
block|{
return|return
literal|0
return|;
block|}
else|else
block|{
return|return
name|cp
operator|->
name|altiobase_wd
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|ide_pci_iobase
parameter_list|(
name|void
modifier|*
name|xcp
parameter_list|)
block|{
name|struct
name|ide_pci_cookie
modifier|*
name|cp
init|=
name|xcp
decl_stmt|;
if|if
condition|(
name|cp
operator|==
literal|0
condition|)
block|{
return|return
literal|0
return|;
block|}
else|else
block|{
return|return
name|cp
operator|->
name|iobase_wd
return|;
block|}
block|}
end_function

end_unit

