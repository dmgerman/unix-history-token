begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/************************************************************************** ** ** **  Device driver for the   NCR 53C8XX   PCI-SCSI-Controller Family. ** **------------------------------------------------------------------------- ** **  Written for 386bsd and FreeBSD by **	Wolfgang Stanglmeier<wolf@cologne.de> **	Stefan Esser<se@mi.Uni-Koeln.de> ** **------------------------------------------------------------------------- */
end_comment

begin_comment
comment|/*- ** Copyright (c) 1994 Wolfgang Stanglmeier.  All rights reserved. ** ** Redistribution and use in source and binary forms, with or without ** modification, are permitted provided that the following conditions ** are met: ** 1. Redistributions of source code must retain the above copyright **    notice, this list of conditions and the following disclaimer. ** 2. Redistributions in binary form must reproduce the above copyright **    notice, this list of conditions and the following disclaimer in the **    documentation and/or other materials provided with the distribution. ** 3. The name of the author may not be used to endorse or promote products **    derived from this software without specific prior written permission. ** ** THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR ** IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES ** OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. ** IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, ** INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT ** NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, ** DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY ** THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT ** (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF ** THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ** *************************************************************************** */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|NCR_DATE
value|"pl30 98/1/1"
end_define

begin_define
define|#
directive|define
name|NCR_VERSION
value|(2)
end_define

begin_define
define|#
directive|define
name|MAX_UNITS
value|(16)
end_define

begin_define
define|#
directive|define
name|NCR_GETCC_WITHMSG
end_define

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
operator|&&
name|defined
argument_list|(
name|_KERNEL
argument_list|)
end_if

begin_include
include|#
directive|include
file|"opt_ncr.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*========================================================== ** **	Configuration and Debugging ** **	May be overwritten in<arch/conf/xxxx> ** **========================================================== */
end_comment

begin_comment
comment|/* **    SCSI address of this device. **    The boot routines should have set it. **    If not, use this. */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|SCSI_NCR_MYADDR
end_ifndef

begin_define
define|#
directive|define
name|SCSI_NCR_MYADDR
value|(7)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SCSI_NCR_MYADDR */
end_comment

begin_comment
comment|/* **    The default synchronous period factor **    (0=asynchronous) **    If maximum synchronous frequency is defined, use it instead. */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|SCSI_NCR_MAX_SYNC
end_ifndef

begin_ifndef
ifndef|#
directive|ifndef
name|SCSI_NCR_DFLT_SYNC
end_ifndef

begin_define
define|#
directive|define
name|SCSI_NCR_DFLT_SYNC
value|(12)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SCSI_NCR_DFLT_SYNC */
end_comment

begin_else
else|#
directive|else
end_else

begin_if
if|#
directive|if
name|SCSI_NCR_MAX_SYNC
operator|==
literal|0
end_if

begin_define
define|#
directive|define
name|SCSI_NCR_DFLT_SYNC
value|0
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|SCSI_NCR_DFLT_SYNC
value|(250000 / SCSI_NCR_MAX_SYNC)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* **    The minimal asynchronous pre-scaler period (ns) **    Shall be 40. */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|SCSI_NCR_MIN_ASYNC
end_ifndef

begin_define
define|#
directive|define
name|SCSI_NCR_MIN_ASYNC
value|(40)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SCSI_NCR_MIN_ASYNC */
end_comment

begin_comment
comment|/* **    The maximal bus with (in log2 byte) **    (0=8 bit, 1=16 bit) */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|SCSI_NCR_MAX_WIDE
end_ifndef

begin_define
define|#
directive|define
name|SCSI_NCR_MAX_WIDE
value|(1)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SCSI_NCR_MAX_WIDE */
end_comment

begin_comment
comment|/*========================================================== ** **      Configuration and Debugging ** **========================================================== */
end_comment

begin_comment
comment|/* **    Number of targets supported by the driver. **    n permits target numbers 0..n-1. **    Default is 7, meaning targets #0..#6. **    #7 .. is myself. */
end_comment

begin_define
define|#
directive|define
name|MAX_TARGET
value|(16)
end_define

begin_comment
comment|/* **    Number of logic units supported by the driver. **    n enables logic unit numbers 0..n-1. **    The common SCSI devices require only **    one lun, so take 1 as the default. */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|MAX_LUN
end_ifndef

begin_define
define|#
directive|define
name|MAX_LUN
value|(8)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* MAX_LUN */
end_comment

begin_comment
comment|/* **    The maximum number of jobs scheduled for starting. **    There should be one slot per target, and one slot **    for each tag of each target in use. */
end_comment

begin_define
define|#
directive|define
name|MAX_START
value|(256)
end_define

begin_comment
comment|/* **    The maximum number of segments a transfer is split into. */
end_comment

begin_define
define|#
directive|define
name|MAX_SCATTER
value|(33)
end_define

begin_comment
comment|/* **    The maximum transfer length (should be>= 64k). **    MUST NOT be greater than (MAX_SCATTER-1) * PAGE_SIZE. */
end_comment

begin_define
define|#
directive|define
name|MAX_SIZE
value|((MAX_SCATTER-1) * (long) PAGE_SIZE)
end_define

begin_comment
comment|/* **	other */
end_comment

begin_define
define|#
directive|define
name|NCR_SNOOP_TIMEOUT
value|(1000000)
end_define

begin_comment
comment|/*========================================================== ** **      Include files ** **========================================================== */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|_KERNEL
end_ifdef

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/kdb.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/md_var.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_extern.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<dev/pci/pcivar.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcireg.h>
end_include

begin_include
include|#
directive|include
file|<pci/ncrreg.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_ccb.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_sim.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_xpt_sim.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_debug.h>
end_include

begin_include
include|#
directive|include
file|<cam/scsi/scsi_all.h>
end_include

begin_include
include|#
directive|include
file|<cam/scsi/scsi_message.h>
end_include

begin_comment
comment|/*========================================================== ** **	Debugging tags ** **========================================================== */
end_comment

begin_define
define|#
directive|define
name|DEBUG_ALLOC
value|(0x0001)
end_define

begin_define
define|#
directive|define
name|DEBUG_PHASE
value|(0x0002)
end_define

begin_define
define|#
directive|define
name|DEBUG_POLL
value|(0x0004)
end_define

begin_define
define|#
directive|define
name|DEBUG_QUEUE
value|(0x0008)
end_define

begin_define
define|#
directive|define
name|DEBUG_RESULT
value|(0x0010)
end_define

begin_define
define|#
directive|define
name|DEBUG_SCATTER
value|(0x0020)
end_define

begin_define
define|#
directive|define
name|DEBUG_SCRIPT
value|(0x0040)
end_define

begin_define
define|#
directive|define
name|DEBUG_TINY
value|(0x0080)
end_define

begin_define
define|#
directive|define
name|DEBUG_TIMING
value|(0x0100)
end_define

begin_define
define|#
directive|define
name|DEBUG_NEGO
value|(0x0200)
end_define

begin_define
define|#
directive|define
name|DEBUG_TAGS
value|(0x0400)
end_define

begin_define
define|#
directive|define
name|DEBUG_FREEZE
value|(0x0800)
end_define

begin_define
define|#
directive|define
name|DEBUG_RESTART
value|(0x1000)
end_define

begin_comment
comment|/* **    Enable/Disable debug messages. **    Can be changed at runtime too. */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|SCSI_NCR_DEBUG
end_ifdef

begin_define
define|#
directive|define
name|DEBUG_FLAGS
value|ncr_debug
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* SCSI_NCR_DEBUG */
end_comment

begin_define
define|#
directive|define
name|SCSI_NCR_DEBUG
value|0
end_define

begin_define
define|#
directive|define
name|DEBUG_FLAGS
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SCSI_NCR_DEBUG */
end_comment

begin_comment
comment|/*========================================================== ** **	assert () ** **========================================================== ** **	modified copy from 386bsd:/usr/include/sys/assert.h ** **---------------------------------------------------------- */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|DIAGNOSTIC
end_ifdef

begin_define
define|#
directive|define
name|assert
parameter_list|(
name|expression
parameter_list|)
value|{					\ 	if (!(expression)) {					\ 		(void)printf("assertion \"%s\" failed: "	\ 			     "file \"%s\", line %d\n",		\ 			     #expression, __FILE__, __LINE__);	\ 	     kdb_enter("");					\ 	}							\ }
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|assert
parameter_list|(
name|expression
parameter_list|)
value|{					\ 	if (!(expression)) {					\ 		(void)printf("assertion \"%s\" failed: "	\ 			     "file \"%s\", line %d\n",		\ 			     #expression, __FILE__, __LINE__);	\ 	}							\ }
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*========================================================== ** **	Access to the controller chip. ** **========================================================== */
end_comment

begin_define
define|#
directive|define
name|INB
parameter_list|(
name|r
parameter_list|)
value|bus_space_read_1(np->bst, np->bsh, offsetof(struct ncr_reg, r))
end_define

begin_define
define|#
directive|define
name|INW
parameter_list|(
name|r
parameter_list|)
value|bus_space_read_2(np->bst, np->bsh, offsetof(struct ncr_reg, r))
end_define

begin_define
define|#
directive|define
name|INL
parameter_list|(
name|r
parameter_list|)
value|bus_space_read_4(np->bst, np->bsh, offsetof(struct ncr_reg, r))
end_define

begin_define
define|#
directive|define
name|OUTB
parameter_list|(
name|r
parameter_list|,
name|val
parameter_list|)
value|bus_space_write_1(np->bst, np->bsh, \ 				       offsetof(struct ncr_reg, r), val)
end_define

begin_define
define|#
directive|define
name|OUTW
parameter_list|(
name|r
parameter_list|,
name|val
parameter_list|)
value|bus_space_write_2(np->bst, np->bsh, \ 				       offsetof(struct ncr_reg, r), val)
end_define

begin_define
define|#
directive|define
name|OUTL
parameter_list|(
name|r
parameter_list|,
name|val
parameter_list|)
value|bus_space_write_4(np->bst, np->bsh, \ 				       offsetof(struct ncr_reg, r), val)
end_define

begin_define
define|#
directive|define
name|OUTL_OFF
parameter_list|(
name|o
parameter_list|,
name|val
parameter_list|)
value|bus_space_write_4(np->bst, np->bsh, o, val)
end_define

begin_define
define|#
directive|define
name|INB_OFF
parameter_list|(
name|o
parameter_list|)
value|bus_space_read_1(np->bst, np->bsh, o)
end_define

begin_define
define|#
directive|define
name|INW_OFF
parameter_list|(
name|o
parameter_list|)
value|bus_space_read_2(np->bst, np->bsh, o)
end_define

begin_define
define|#
directive|define
name|INL_OFF
parameter_list|(
name|o
parameter_list|)
value|bus_space_read_4(np->bst, np->bsh, o)
end_define

begin_define
define|#
directive|define
name|READSCRIPT_OFF
parameter_list|(
name|base
parameter_list|,
name|off
parameter_list|)
define|\
value|(base ? *((volatile u_int32_t *)((volatile char *)base + (off))) :	\     bus_space_read_4(np->bst2, np->bsh2, off))
end_define

begin_define
define|#
directive|define
name|WRITESCRIPT_OFF
parameter_list|(
name|base
parameter_list|,
name|off
parameter_list|,
name|val
parameter_list|)
define|\
value|do {								\     	if (base)							\     		*((volatile u_int32_t *)				\ 			((volatile char *)base + (off))) = (val);	\     	else								\ 		bus_space_write_4(np->bst2, np->bsh2, off, val);	\     } while (0)
end_define

begin_define
define|#
directive|define
name|READSCRIPT
parameter_list|(
name|r
parameter_list|)
define|\
value|READSCRIPT_OFF(np->script, offsetof(struct script, r))
end_define

begin_define
define|#
directive|define
name|WRITESCRIPT
parameter_list|(
name|r
parameter_list|,
name|val
parameter_list|)
define|\
value|WRITESCRIPT_OFF(np->script, offsetof(struct script, r), val)
end_define

begin_comment
comment|/* **	Set bit field ON, OFF  */
end_comment

begin_define
define|#
directive|define
name|OUTONB
parameter_list|(
name|r
parameter_list|,
name|m
parameter_list|)
value|OUTB(r, INB(r) | (m))
end_define

begin_define
define|#
directive|define
name|OUTOFFB
parameter_list|(
name|r
parameter_list|,
name|m
parameter_list|)
value|OUTB(r, INB(r)& ~(m))
end_define

begin_define
define|#
directive|define
name|OUTONW
parameter_list|(
name|r
parameter_list|,
name|m
parameter_list|)
value|OUTW(r, INW(r) | (m))
end_define

begin_define
define|#
directive|define
name|OUTOFFW
parameter_list|(
name|r
parameter_list|,
name|m
parameter_list|)
value|OUTW(r, INW(r)& ~(m))
end_define

begin_define
define|#
directive|define
name|OUTONL
parameter_list|(
name|r
parameter_list|,
name|m
parameter_list|)
value|OUTL(r, INL(r) | (m))
end_define

begin_define
define|#
directive|define
name|OUTOFFL
parameter_list|(
name|r
parameter_list|,
name|m
parameter_list|)
value|OUTL(r, INL(r)& ~(m))
end_define

begin_comment
comment|/*========================================================== ** **	Command control block states. ** **========================================================== */
end_comment

begin_define
define|#
directive|define
name|HS_IDLE
value|(0)
end_define

begin_define
define|#
directive|define
name|HS_BUSY
value|(1)
end_define

begin_define
define|#
directive|define
name|HS_NEGOTIATE
value|(2)
end_define

begin_comment
comment|/* sync/wide data transfer*/
end_comment

begin_define
define|#
directive|define
name|HS_DISCONNECT
value|(3)
end_define

begin_comment
comment|/* Disconnected by target */
end_comment

begin_define
define|#
directive|define
name|HS_COMPLETE
value|(4)
end_define

begin_define
define|#
directive|define
name|HS_SEL_TIMEOUT
value|(5)
end_define

begin_comment
comment|/* Selection timeout      */
end_comment

begin_define
define|#
directive|define
name|HS_RESET
value|(6)
end_define

begin_comment
comment|/* SCSI reset	     */
end_comment

begin_define
define|#
directive|define
name|HS_ABORTED
value|(7)
end_define

begin_comment
comment|/* Transfer aborted       */
end_comment

begin_define
define|#
directive|define
name|HS_TIMEOUT
value|(8)
end_define

begin_comment
comment|/* Software timeout       */
end_comment

begin_define
define|#
directive|define
name|HS_FAIL
value|(9)
end_define

begin_comment
comment|/* SCSI or PCI bus errors */
end_comment

begin_define
define|#
directive|define
name|HS_UNEXPECTED
value|(10)
end_define

begin_comment
comment|/* Unexpected disconnect  */
end_comment

begin_define
define|#
directive|define
name|HS_STALL
value|(11)
end_define

begin_comment
comment|/* QUEUE FULL or BUSY	  */
end_comment

begin_define
define|#
directive|define
name|HS_DONEMASK
value|(0xfc)
end_define

begin_comment
comment|/*========================================================== ** **	Software Interrupt Codes ** **========================================================== */
end_comment

begin_define
define|#
directive|define
name|SIR_SENSE_RESTART
value|(1)
end_define

begin_define
define|#
directive|define
name|SIR_SENSE_FAILED
value|(2)
end_define

begin_define
define|#
directive|define
name|SIR_STALL_RESTART
value|(3)
end_define

begin_define
define|#
directive|define
name|SIR_STALL_QUEUE
value|(4)
end_define

begin_define
define|#
directive|define
name|SIR_NEGO_SYNC
value|(5)
end_define

begin_define
define|#
directive|define
name|SIR_NEGO_WIDE
value|(6)
end_define

begin_define
define|#
directive|define
name|SIR_NEGO_FAILED
value|(7)
end_define

begin_define
define|#
directive|define
name|SIR_NEGO_PROTO
value|(8)
end_define

begin_define
define|#
directive|define
name|SIR_REJECT_RECEIVED
value|(9)
end_define

begin_define
define|#
directive|define
name|SIR_REJECT_SENT
value|(10)
end_define

begin_define
define|#
directive|define
name|SIR_IGN_RESIDUE
value|(11)
end_define

begin_define
define|#
directive|define
name|SIR_MISSING_SAVE
value|(12)
end_define

begin_define
define|#
directive|define
name|SIR_MAX
value|(12)
end_define

begin_comment
comment|/*========================================================== ** **	Extended error codes. **	xerr_status field of struct nccb. ** **========================================================== */
end_comment

begin_define
define|#
directive|define
name|XE_OK
value|(0)
end_define

begin_define
define|#
directive|define
name|XE_EXTRA_DATA
value|(1)
end_define

begin_comment
comment|/* unexpected data phase */
end_comment

begin_define
define|#
directive|define
name|XE_BAD_PHASE
value|(2)
end_define

begin_comment
comment|/* illegal phase (4/5)   */
end_comment

begin_comment
comment|/*========================================================== ** **	Negotiation status. **	nego_status field	of struct nccb. ** **========================================================== */
end_comment

begin_define
define|#
directive|define
name|NS_SYNC
value|(1)
end_define

begin_define
define|#
directive|define
name|NS_WIDE
value|(2)
end_define

begin_comment
comment|/*========================================================== ** **	XXX These are no longer used.  Remove once the **	    script is updated. **	"Special features" of targets. **	quirks field of struct tcb. **	actualquirks field of struct nccb. ** **========================================================== */
end_comment

begin_define
define|#
directive|define
name|QUIRK_AUTOSAVE
value|(0x01)
end_define

begin_define
define|#
directive|define
name|QUIRK_NOMSG
value|(0x02)
end_define

begin_define
define|#
directive|define
name|QUIRK_NOSYNC
value|(0x10)
end_define

begin_define
define|#
directive|define
name|QUIRK_NOWIDE16
value|(0x20)
end_define

begin_define
define|#
directive|define
name|QUIRK_NOTAGS
value|(0x40)
end_define

begin_define
define|#
directive|define
name|QUIRK_UPDATE
value|(0x80)
end_define

begin_comment
comment|/*========================================================== ** **	Misc. ** **========================================================== */
end_comment

begin_define
define|#
directive|define
name|CCB_MAGIC
value|(0xf2691ad2)
end_define

begin_define
define|#
directive|define
name|MAX_TAGS
value|(32)
end_define

begin_comment
comment|/* hard limit */
end_comment

begin_comment
comment|/*========================================================== ** **	OS dependencies. ** **========================================================== */
end_comment

begin_define
define|#
directive|define
name|PRINT_ADDR
parameter_list|(
name|ccb
parameter_list|)
value|xpt_print_path((ccb)->ccb_h.path)
end_define

begin_comment
comment|/*========================================================== ** **	Declaration of structs. ** **========================================================== */
end_comment

begin_struct_decl
struct_decl|struct
name|tcb
struct_decl|;
end_struct_decl

begin_struct_decl
struct_decl|struct
name|lcb
struct_decl|;
end_struct_decl

begin_struct_decl
struct_decl|struct
name|nccb
struct_decl|;
end_struct_decl

begin_struct_decl
struct_decl|struct
name|ncb
struct_decl|;
end_struct_decl

begin_struct_decl
struct_decl|struct
name|script
struct_decl|;
end_struct_decl

begin_typedef
typedef|typedef
name|struct
name|ncb
modifier|*
name|ncb_p
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|struct
name|tcb
modifier|*
name|tcb_p
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|struct
name|lcb
modifier|*
name|lcb_p
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|struct
name|nccb
modifier|*
name|nccb_p
typedef|;
end_typedef

begin_struct
struct|struct
name|link
block|{
name|ncrcmd
name|l_cmd
decl_stmt|;
name|ncrcmd
name|l_paddr
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|usrcmd
block|{
name|u_long
name|target
decl_stmt|;
name|u_long
name|lun
decl_stmt|;
name|u_long
name|data
decl_stmt|;
name|u_long
name|cmd
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|UC_SETSYNC
value|10
end_define

begin_define
define|#
directive|define
name|UC_SETTAGS
value|11
end_define

begin_define
define|#
directive|define
name|UC_SETDEBUG
value|12
end_define

begin_define
define|#
directive|define
name|UC_SETORDER
value|13
end_define

begin_define
define|#
directive|define
name|UC_SETWIDE
value|14
end_define

begin_define
define|#
directive|define
name|UC_SETFLAG
value|15
end_define

begin_define
define|#
directive|define
name|UF_TRACE
value|(0x01)
end_define

begin_comment
comment|/*--------------------------------------- ** **	Timestamps for profiling ** **--------------------------------------- */
end_comment

begin_comment
comment|/* Type of the kernel variable `ticks'.  XXX should be declared with the var. */
end_comment

begin_typedef
typedef|typedef
name|int
name|ticks_t
typedef|;
end_typedef

begin_struct
struct|struct
name|tstamp
block|{
name|ticks_t
name|start
decl_stmt|;
name|ticks_t
name|end
decl_stmt|;
name|ticks_t
name|select
decl_stmt|;
name|ticks_t
name|command
decl_stmt|;
name|ticks_t
name|data
decl_stmt|;
name|ticks_t
name|status
decl_stmt|;
name|ticks_t
name|disconnect
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* **	profiling data (per device) */
end_comment

begin_struct
struct|struct
name|profile
block|{
name|u_long
name|num_trans
decl_stmt|;
name|u_long
name|num_bytes
decl_stmt|;
name|u_long
name|num_disc
decl_stmt|;
name|u_long
name|num_break
decl_stmt|;
name|u_long
name|num_int
decl_stmt|;
name|u_long
name|num_fly
decl_stmt|;
name|u_long
name|ms_setup
decl_stmt|;
name|u_long
name|ms_data
decl_stmt|;
name|u_long
name|ms_disc
decl_stmt|;
name|u_long
name|ms_post
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*========================================================== ** **	Declaration of structs:		target control block ** **========================================================== */
end_comment

begin_define
define|#
directive|define
name|NCR_TRANS_CUR
value|0x01
end_define

begin_comment
comment|/* Modify current neogtiation status */
end_comment

begin_define
define|#
directive|define
name|NCR_TRANS_ACTIVE
value|0x03
end_define

begin_comment
comment|/* Assume this is the active target */
end_comment

begin_define
define|#
directive|define
name|NCR_TRANS_GOAL
value|0x04
end_define

begin_comment
comment|/* Modify negotiation goal */
end_comment

begin_define
define|#
directive|define
name|NCR_TRANS_USER
value|0x08
end_define

begin_comment
comment|/* Modify user negotiation settings */
end_comment

begin_struct
struct|struct
name|ncr_transinfo
block|{
name|u_int8_t
name|width
decl_stmt|;
name|u_int8_t
name|period
decl_stmt|;
name|u_int8_t
name|offset
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|ncr_target_tinfo
block|{
comment|/* Hardware version of our sync settings */
name|u_int8_t
name|disc_tag
decl_stmt|;
define|#
directive|define
name|NCR_CUR_DISCENB
value|0x01
define|#
directive|define
name|NCR_CUR_TAGENB
value|0x02
define|#
directive|define
name|NCR_USR_DISCENB
value|0x04
define|#
directive|define
name|NCR_USR_TAGENB
value|0x08
name|u_int8_t
name|sval
decl_stmt|;
name|struct
name|ncr_transinfo
name|current
decl_stmt|;
name|struct
name|ncr_transinfo
name|goal
decl_stmt|;
name|struct
name|ncr_transinfo
name|user
decl_stmt|;
comment|/* Hardware version of our wide settings */
name|u_int8_t
name|wval
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|tcb
block|{
comment|/* 	**	during reselection the ncr jumps to this point 	**	with SFBR set to the encoded target number 	**	with bit 7 set. 	**	if it's not this target, jump to the next. 	** 	**	JUMP  IF (SFBR != #target#) 	**	@(next tcb) 	*/
name|struct
name|link
name|jump_tcb
decl_stmt|;
comment|/* 	**	load the actual values for the sxfer and the scntl3 	**	register (sync/wide mode). 	** 	**	SCR_COPY (1); 	**	@(sval field of this tcb) 	**	@(sxfer register) 	**	SCR_COPY (1); 	**	@(wval field of this tcb) 	**	@(scntl3 register) 	*/
name|ncrcmd
name|getscr
index|[
literal|6
index|]
decl_stmt|;
comment|/* 	**	if next message is "identify" 	**	then load the message to SFBR, 	**	else load 0 to SFBR. 	** 	**	CALL 	**<RESEL_LUN> 	*/
name|struct
name|link
name|call_lun
decl_stmt|;
comment|/* 	**	now look for the right lun. 	** 	**	JUMP 	**	@(first nccb of this lun) 	*/
name|struct
name|link
name|jump_lcb
decl_stmt|;
comment|/* 	**	pointer to interrupted getcc nccb 	*/
name|nccb_p
name|hold_cp
decl_stmt|;
comment|/* 	**	pointer to nccb used for negotiating. 	**	Avoid to start a nego for all queued commands  	**	when tagged command queuing is enabled. 	*/
name|nccb_p
name|nego_cp
decl_stmt|;
comment|/* 	**	statistical data 	*/
name|u_long
name|transfers
decl_stmt|;
name|u_long
name|bytes
decl_stmt|;
comment|/* 	**	user settable limits for sync transfer 	**	and tagged commands. 	*/
name|struct
name|ncr_target_tinfo
name|tinfo
decl_stmt|;
comment|/* 	**	the lcb's of this tcb 	*/
name|lcb_p
name|lp
index|[
name|MAX_LUN
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*========================================================== ** **	Declaration of structs:		lun control block ** **========================================================== */
end_comment

begin_struct
struct|struct
name|lcb
block|{
comment|/* 	**	during reselection the ncr jumps to this point 	**	with SFBR set to the "Identify" message. 	**	if it's not this lun, jump to the next. 	** 	**	JUMP  IF (SFBR != #lun#) 	**	@(next lcb of this target) 	*/
name|struct
name|link
name|jump_lcb
decl_stmt|;
comment|/* 	**	if next message is "simple tag", 	**	then load the tag to SFBR, 	**	else load 0 to SFBR. 	** 	**	CALL 	**<RESEL_TAG> 	*/
name|struct
name|link
name|call_tag
decl_stmt|;
comment|/* 	**	now look for the right nccb. 	** 	**	JUMP 	**	@(first nccb of this lun) 	*/
name|struct
name|link
name|jump_nccb
decl_stmt|;
comment|/* 	**	start of the nccb chain 	*/
name|nccb_p
name|next_nccb
decl_stmt|;
comment|/* 	**	Control of tagged queueing 	*/
name|u_char
name|reqnccbs
decl_stmt|;
name|u_char
name|reqlink
decl_stmt|;
name|u_char
name|actlink
decl_stmt|;
name|u_char
name|usetags
decl_stmt|;
name|u_char
name|lasttag
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*========================================================== ** **      Declaration of structs:     COMMAND control block ** **========================================================== ** **	This substructure is copied from the nccb to a **	global address after selection (or reselection) **	and copied back before disconnect. ** **	These fields are accessible to the script processor. ** **---------------------------------------------------------- */
end_comment

begin_struct
struct|struct
name|head
block|{
comment|/* 	**	Execution of a nccb starts at this point. 	**	It's a jump to the "SELECT" label 	**	of the script. 	** 	**	After successful selection the script 	**	processor overwrites it with a jump to 	**	the IDLE label of the script. 	*/
name|struct
name|link
name|launch
decl_stmt|;
comment|/* 	**	Saved data pointer. 	**	Points to the position in the script 	**	responsible for the actual transfer 	**	of data. 	**	It's written after reception of a 	**	"SAVE_DATA_POINTER" message. 	**	The goalpointer points after 	**	the last transfer command. 	*/
name|u_int32_t
name|savep
decl_stmt|;
name|u_int32_t
name|lastp
decl_stmt|;
name|u_int32_t
name|goalp
decl_stmt|;
comment|/* 	**	The virtual address of the nccb 	**	containing this header. 	*/
name|nccb_p
name|cp
decl_stmt|;
comment|/* 	**	space for some timestamps to gather 	**	profiling data about devices and this driver. 	*/
name|struct
name|tstamp
name|stamp
decl_stmt|;
comment|/* 	**	status fields. 	*/
name|u_char
name|status
index|[
literal|8
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* **	The status bytes are used by the host and the script processor. ** **	The first four byte are copied to the scratchb register **	(declared as scr0..scr3 in ncr_reg.h) just after the select/reselect, **	and copied back just after disconnecting. **	Inside the script the XX_REG are used. ** **	The last four bytes are used inside the script by "COPY" commands. **	Because source and destination must have the same alignment **	in a longword, the fields HAVE to be at the choosen offsets. **		xerr_st	(4)	0	(0x34)	scratcha **		sync_st	(5)	1	(0x05)	sxfer **		wide_st	(7)	3	(0x03)	scntl3 */
end_comment

begin_comment
comment|/* **	First four bytes (script) */
end_comment

begin_define
define|#
directive|define
name|QU_REG
value|scr0
end_define

begin_define
define|#
directive|define
name|HS_REG
value|scr1
end_define

begin_define
define|#
directive|define
name|HS_PRT
value|nc_scr1
end_define

begin_define
define|#
directive|define
name|SS_REG
value|scr2
end_define

begin_define
define|#
directive|define
name|PS_REG
value|scr3
end_define

begin_comment
comment|/* **	First four bytes (host) */
end_comment

begin_define
define|#
directive|define
name|actualquirks
value|phys.header.status[0]
end_define

begin_define
define|#
directive|define
name|host_status
value|phys.header.status[1]
end_define

begin_define
define|#
directive|define
name|s_status
value|phys.header.status[2]
end_define

begin_define
define|#
directive|define
name|parity_status
value|phys.header.status[3]
end_define

begin_comment
comment|/* **	Last four bytes (script) */
end_comment

begin_define
define|#
directive|define
name|xerr_st
value|header.status[4]
end_define

begin_comment
comment|/* MUST be ==0 mod 4 */
end_comment

begin_define
define|#
directive|define
name|sync_st
value|header.status[5]
end_define

begin_comment
comment|/* MUST be ==1 mod 4 */
end_comment

begin_define
define|#
directive|define
name|nego_st
value|header.status[6]
end_define

begin_define
define|#
directive|define
name|wide_st
value|header.status[7]
end_define

begin_comment
comment|/* MUST be ==3 mod 4 */
end_comment

begin_comment
comment|/* **	Last four bytes (host) */
end_comment

begin_define
define|#
directive|define
name|xerr_status
value|phys.xerr_st
end_define

begin_define
define|#
directive|define
name|sync_status
value|phys.sync_st
end_define

begin_define
define|#
directive|define
name|nego_status
value|phys.nego_st
end_define

begin_define
define|#
directive|define
name|wide_status
value|phys.wide_st
end_define

begin_comment
comment|/*========================================================== ** **      Declaration of structs:     Data structure block ** **========================================================== ** **	During execution of a nccb by the script processor, **	the DSA (data structure address) register points **	to this substructure of the nccb. **	This substructure contains the header with **	the script-processor-changable data and **	data blocks for the indirect move commands. ** **---------------------------------------------------------- */
end_comment

begin_struct
struct|struct
name|dsb
block|{
comment|/* 	**	Header. 	**	Has to be the first entry, 	**	because it's jumped to by the 	**	script processor 	*/
name|struct
name|head
name|header
decl_stmt|;
comment|/* 	**	Table data for Script 	*/
name|struct
name|scr_tblsel
name|select
decl_stmt|;
name|struct
name|scr_tblmove
name|smsg
decl_stmt|;
name|struct
name|scr_tblmove
name|smsg2
decl_stmt|;
name|struct
name|scr_tblmove
name|cmd
decl_stmt|;
name|struct
name|scr_tblmove
name|scmd
decl_stmt|;
name|struct
name|scr_tblmove
name|sense
decl_stmt|;
name|struct
name|scr_tblmove
name|data
index|[
name|MAX_SCATTER
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*========================================================== ** **      Declaration of structs:     Command control block. ** **========================================================== ** **	During execution of a nccb by the script processor, **	the DSA (data structure address) register points **	to this substructure of the nccb. **	This substructure contains the header with **	the script-processor-changable data and then **	data blocks for the indirect move commands. ** **---------------------------------------------------------- */
end_comment

begin_struct
struct|struct
name|nccb
block|{
comment|/* 	**	This filler ensures that the global header is  	**	cache line size aligned. 	*/
name|ncrcmd
name|filler
index|[
literal|4
index|]
decl_stmt|;
comment|/* 	**	during reselection the ncr jumps to this point. 	**	If a "SIMPLE_TAG" message was received, 	**	then SFBR is set to the tag. 	**	else SFBR is set to 0 	**	If looking for another tag, jump to the next nccb. 	** 	**	JUMP  IF (SFBR != #TAG#) 	**	@(next nccb of this lun) 	*/
name|struct
name|link
name|jump_nccb
decl_stmt|;
comment|/* 	**	After execution of this call, the return address 	**	(in  the TEMP register) points to the following 	**	data structure block. 	**	So copy it to the DSA register, and start 	**	processing of this data structure. 	** 	**	CALL 	**<RESEL_TMP> 	*/
name|struct
name|link
name|call_tmp
decl_stmt|;
comment|/* 	**	This is the data structure which is 	**	to be executed by the script processor. 	*/
name|struct
name|dsb
name|phys
decl_stmt|;
comment|/* 	**	If a data transfer phase is terminated too early 	**	(after reception of a message (i.e. DISCONNECT)), 	**	we have to prepare a mini script to transfer 	**	the rest of the data. 	*/
name|ncrcmd
name|patch
index|[
literal|8
index|]
decl_stmt|;
comment|/* 	**	The general SCSI driver provides a 	**	pointer to a control block. 	*/
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
comment|/* 	**	We prepare a message to be sent after selection, 	**	and a second one to be sent after getcc selection. 	**      Contents are IDENTIFY and SIMPLE_TAG. 	**	While negotiating sync or wide transfer, 	**	a SDTM or WDTM message is appended. 	*/
name|u_char
name|scsi_smsg
index|[
literal|8
index|]
decl_stmt|;
name|u_char
name|scsi_smsg2
index|[
literal|8
index|]
decl_stmt|;
comment|/* 	**	Lock this nccb. 	**	Flag is used while looking for a free nccb. 	*/
name|u_long
name|magic
decl_stmt|;
comment|/* 	**	Physical address of this instance of nccb 	*/
name|u_long
name|p_nccb
decl_stmt|;
comment|/* 	**	Completion time out for this job. 	**	It's set to time of start + allowed number of seconds. 	*/
name|time_t
name|tlimit
decl_stmt|;
comment|/* 	**	All nccbs of one hostadapter are chained. 	*/
name|nccb_p
name|link_nccb
decl_stmt|;
comment|/* 	**	All nccbs of one target/lun are chained. 	*/
name|nccb_p
name|next_nccb
decl_stmt|;
comment|/* 	**	Sense command 	*/
name|u_char
name|sensecmd
index|[
literal|6
index|]
decl_stmt|;
comment|/* 	**	Tag for this transfer. 	**	It's patched into jump_nccb. 	**	If it's not zero, a SIMPLE_TAG 	**	message is included in smsg. 	*/
name|u_char
name|tag
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|CCB_PHYS
parameter_list|(
name|cp
parameter_list|,
name|lbl
parameter_list|)
value|(cp->p_nccb + offsetof(struct nccb, lbl))
end_define

begin_comment
comment|/*========================================================== ** **      Declaration of structs:     NCR device descriptor ** **========================================================== */
end_comment

begin_struct
struct|struct
name|ncb
block|{
comment|/* 	**	The global header. 	**	Accessible to both the host and the 	**	script-processor. 	**	We assume it is cache line size aligned. 	*/
name|struct
name|head
name|header
decl_stmt|;
name|int
name|unit
decl_stmt|;
comment|/*----------------------------------------------- 	**	Scripts .. 	**----------------------------------------------- 	** 	**	During reselection the ncr jumps to this point. 	**	The SFBR register is loaded with the encoded target id. 	** 	**	Jump to the first target. 	** 	**	JUMP 	**	@(next tcb) 	*/
name|struct
name|link
name|jump_tcb
decl_stmt|;
comment|/*----------------------------------------------- 	**	Configuration .. 	**----------------------------------------------- 	** 	**	virtual and physical addresses 	**	of the 53c810 chip. 	*/
name|int
name|reg_rid
decl_stmt|;
name|struct
name|resource
modifier|*
name|reg_res
decl_stmt|;
name|bus_space_tag_t
name|bst
decl_stmt|;
name|bus_space_handle_t
name|bsh
decl_stmt|;
name|int
name|sram_rid
decl_stmt|;
name|struct
name|resource
modifier|*
name|sram_res
decl_stmt|;
name|bus_space_tag_t
name|bst2
decl_stmt|;
name|bus_space_handle_t
name|bsh2
decl_stmt|;
name|struct
name|resource
modifier|*
name|irq_res
decl_stmt|;
name|void
modifier|*
name|irq_handle
decl_stmt|;
comment|/* 	**	Scripts instance virtual address. 	*/
name|struct
name|script
modifier|*
name|script
decl_stmt|;
name|struct
name|scripth
modifier|*
name|scripth
decl_stmt|;
comment|/* 	**	Scripts instance physical address. 	*/
name|u_long
name|p_script
decl_stmt|;
name|u_long
name|p_scripth
decl_stmt|;
comment|/* 	**	The SCSI address of the host adapter. 	*/
name|u_char
name|myaddr
decl_stmt|;
comment|/* 	**	timing parameters 	*/
name|u_char
name|minsync
decl_stmt|;
comment|/* Minimum sync period factor	*/
name|u_char
name|maxsync
decl_stmt|;
comment|/* Maximum sync period factor	*/
name|u_char
name|maxoffs
decl_stmt|;
comment|/* Max scsi offset		*/
name|u_char
name|clock_divn
decl_stmt|;
comment|/* Number of clock divisors	*/
name|u_long
name|clock_khz
decl_stmt|;
comment|/* SCSI clock frequency in KHz	*/
name|u_long
name|features
decl_stmt|;
comment|/* Chip features map		*/
name|u_char
name|multiplier
decl_stmt|;
comment|/* Clock multiplier (1,2,4)	*/
name|u_char
name|maxburst
decl_stmt|;
comment|/* log base 2 of dwords burst	*/
comment|/* 	**	BIOS supplied PCI bus options 	*/
name|u_char
name|rv_scntl3
decl_stmt|;
name|u_char
name|rv_dcntl
decl_stmt|;
name|u_char
name|rv_dmode
decl_stmt|;
name|u_char
name|rv_ctest3
decl_stmt|;
name|u_char
name|rv_ctest4
decl_stmt|;
name|u_char
name|rv_ctest5
decl_stmt|;
name|u_char
name|rv_gpcntl
decl_stmt|;
name|u_char
name|rv_stest2
decl_stmt|;
comment|/*----------------------------------------------- 	**	CAM SIM information for this instance 	**----------------------------------------------- 	*/
name|struct
name|cam_sim
modifier|*
name|sim
decl_stmt|;
name|struct
name|cam_path
modifier|*
name|path
decl_stmt|;
comment|/*----------------------------------------------- 	**	Job control 	**----------------------------------------------- 	** 	**	Commands from user 	*/
name|struct
name|usrcmd
name|user
decl_stmt|;
comment|/* 	**	Target data 	*/
name|struct
name|tcb
name|target
index|[
name|MAX_TARGET
index|]
decl_stmt|;
comment|/* 	**	Start queue. 	*/
name|u_int32_t
name|squeue
index|[
name|MAX_START
index|]
decl_stmt|;
name|u_short
name|squeueput
decl_stmt|;
comment|/* 	**	Timeout handler 	*/
name|time_t
name|heartbeat
decl_stmt|;
name|u_short
name|ticks
decl_stmt|;
name|u_short
name|latetime
decl_stmt|;
name|time_t
name|lasttime
decl_stmt|;
name|struct
name|callout_handle
name|timeout_ch
decl_stmt|;
comment|/*----------------------------------------------- 	**	Debug and profiling 	**----------------------------------------------- 	** 	**	register dump 	*/
name|struct
name|ncr_reg
name|regdump
decl_stmt|;
name|time_t
name|regtime
decl_stmt|;
comment|/* 	**	Profiling data 	*/
name|struct
name|profile
name|profile
decl_stmt|;
name|u_long
name|disc_phys
decl_stmt|;
name|u_long
name|disc_ref
decl_stmt|;
comment|/* 	**	Head of list of all nccbs for this controller. 	*/
name|nccb_p
name|link_nccb
decl_stmt|;
comment|/* 	**	message buffers. 	**	Should be longword aligned, 	**	because they're written with a 	**	COPY script command. 	*/
name|u_char
name|msgout
index|[
literal|8
index|]
decl_stmt|;
name|u_char
name|msgin
index|[
literal|8
index|]
decl_stmt|;
name|u_int32_t
name|lastmsg
decl_stmt|;
comment|/* 	**	Buffer for STATUS_IN phase. 	*/
name|u_char
name|scratch
decl_stmt|;
comment|/* 	**	controller chip dependent maximal transfer width. 	*/
name|u_char
name|maxwide
decl_stmt|;
ifdef|#
directive|ifdef
name|NCR_IOMAPPED
comment|/* 	**	address of the ncr control registers in io space 	*/
name|pci_port_t
name|port
decl_stmt|;
endif|#
directive|endif
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|NCB_SCRIPT_PHYS
parameter_list|(
name|np
parameter_list|,
name|lbl
parameter_list|)
value|(np->p_script + offsetof (struct script, lbl))
end_define

begin_define
define|#
directive|define
name|NCB_SCRIPTH_PHYS
parameter_list|(
name|np
parameter_list|,
name|lbl
parameter_list|)
value|(np->p_scripth + offsetof (struct scripth,lbl))
end_define

begin_comment
comment|/*========================================================== ** ** **      Script for NCR-Processor. ** **	Use ncr_script_fill() to create the variable parts. **	Use ncr_script_copy_and_bind() to make a copy and **	bind to physical addresses. ** ** **========================================================== ** **	We have to know the offsets of all labels before **	we reach them (for forward jumps). **	Therefore we declare a struct here. **	If you make changes inside the script, **	DONT FORGET TO CHANGE THE LENGTHS HERE! ** **---------------------------------------------------------- */
end_comment

begin_comment
comment|/* **	Script fragments which are loaded into the on-board RAM  **	of 825A, 875 and 895 chips. */
end_comment

begin_struct
struct|struct
name|script
block|{
name|ncrcmd
name|start
index|[
literal|7
index|]
decl_stmt|;
name|ncrcmd
name|start0
index|[
literal|2
index|]
decl_stmt|;
name|ncrcmd
name|start1
index|[
literal|3
index|]
decl_stmt|;
name|ncrcmd
name|startpos
index|[
literal|1
index|]
decl_stmt|;
name|ncrcmd
name|trysel
index|[
literal|8
index|]
decl_stmt|;
name|ncrcmd
name|skip
index|[
literal|8
index|]
decl_stmt|;
name|ncrcmd
name|skip2
index|[
literal|3
index|]
decl_stmt|;
name|ncrcmd
name|idle
index|[
literal|2
index|]
decl_stmt|;
name|ncrcmd
name|select
index|[
literal|18
index|]
decl_stmt|;
name|ncrcmd
name|prepare
index|[
literal|4
index|]
decl_stmt|;
name|ncrcmd
name|loadpos
index|[
literal|14
index|]
decl_stmt|;
name|ncrcmd
name|prepare2
index|[
literal|24
index|]
decl_stmt|;
name|ncrcmd
name|setmsg
index|[
literal|5
index|]
decl_stmt|;
name|ncrcmd
name|clrack
index|[
literal|2
index|]
decl_stmt|;
name|ncrcmd
name|dispatch
index|[
literal|33
index|]
decl_stmt|;
name|ncrcmd
name|no_data
index|[
literal|17
index|]
decl_stmt|;
name|ncrcmd
name|checkatn
index|[
literal|10
index|]
decl_stmt|;
name|ncrcmd
name|command
index|[
literal|15
index|]
decl_stmt|;
name|ncrcmd
name|status
index|[
literal|27
index|]
decl_stmt|;
name|ncrcmd
name|msg_in
index|[
literal|26
index|]
decl_stmt|;
name|ncrcmd
name|msg_bad
index|[
literal|6
index|]
decl_stmt|;
name|ncrcmd
name|complete
index|[
literal|13
index|]
decl_stmt|;
name|ncrcmd
name|cleanup
index|[
literal|12
index|]
decl_stmt|;
name|ncrcmd
name|cleanup0
index|[
literal|9
index|]
decl_stmt|;
name|ncrcmd
name|signal
index|[
literal|12
index|]
decl_stmt|;
name|ncrcmd
name|save_dp
index|[
literal|5
index|]
decl_stmt|;
name|ncrcmd
name|restore_dp
index|[
literal|5
index|]
decl_stmt|;
name|ncrcmd
name|disconnect
index|[
literal|12
index|]
decl_stmt|;
name|ncrcmd
name|disconnect0
index|[
literal|5
index|]
decl_stmt|;
name|ncrcmd
name|disconnect1
index|[
literal|23
index|]
decl_stmt|;
name|ncrcmd
name|msg_out
index|[
literal|9
index|]
decl_stmt|;
name|ncrcmd
name|msg_out_done
index|[
literal|7
index|]
decl_stmt|;
name|ncrcmd
name|badgetcc
index|[
literal|6
index|]
decl_stmt|;
name|ncrcmd
name|reselect
index|[
literal|8
index|]
decl_stmt|;
name|ncrcmd
name|reselect1
index|[
literal|8
index|]
decl_stmt|;
name|ncrcmd
name|reselect2
index|[
literal|8
index|]
decl_stmt|;
name|ncrcmd
name|resel_tmp
index|[
literal|5
index|]
decl_stmt|;
name|ncrcmd
name|resel_lun
index|[
literal|18
index|]
decl_stmt|;
name|ncrcmd
name|resel_tag
index|[
literal|24
index|]
decl_stmt|;
name|ncrcmd
name|data_in
index|[
name|MAX_SCATTER
operator|*
literal|4
operator|+
literal|7
index|]
decl_stmt|;
name|ncrcmd
name|data_out
index|[
name|MAX_SCATTER
operator|*
literal|4
operator|+
literal|7
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* **	Script fragments which stay in main memory for all chips. */
end_comment

begin_struct
struct|struct
name|scripth
block|{
name|ncrcmd
name|tryloop
index|[
name|MAX_START
operator|*
literal|5
operator|+
literal|2
index|]
decl_stmt|;
name|ncrcmd
name|msg_parity
index|[
literal|6
index|]
decl_stmt|;
name|ncrcmd
name|msg_reject
index|[
literal|8
index|]
decl_stmt|;
name|ncrcmd
name|msg_ign_residue
index|[
literal|32
index|]
decl_stmt|;
name|ncrcmd
name|msg_extended
index|[
literal|18
index|]
decl_stmt|;
name|ncrcmd
name|msg_ext_2
index|[
literal|18
index|]
decl_stmt|;
name|ncrcmd
name|msg_wdtr
index|[
literal|27
index|]
decl_stmt|;
name|ncrcmd
name|msg_ext_3
index|[
literal|18
index|]
decl_stmt|;
name|ncrcmd
name|msg_sdtr
index|[
literal|27
index|]
decl_stmt|;
name|ncrcmd
name|msg_out_abort
index|[
literal|10
index|]
decl_stmt|;
name|ncrcmd
name|getcc
index|[
literal|4
index|]
decl_stmt|;
name|ncrcmd
name|getcc1
index|[
literal|5
index|]
decl_stmt|;
ifdef|#
directive|ifdef
name|NCR_GETCC_WITHMSG
name|ncrcmd
name|getcc2
index|[
literal|29
index|]
decl_stmt|;
else|#
directive|else
name|ncrcmd
name|getcc2
index|[
literal|14
index|]
decl_stmt|;
endif|#
directive|endif
name|ncrcmd
name|getcc3
index|[
literal|6
index|]
decl_stmt|;
name|ncrcmd
name|aborttag
index|[
literal|4
index|]
decl_stmt|;
name|ncrcmd
name|abort
index|[
literal|22
index|]
decl_stmt|;
name|ncrcmd
name|snooptest
index|[
literal|9
index|]
decl_stmt|;
name|ncrcmd
name|snoopend
index|[
literal|2
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*========================================================== ** ** **      Function headers. ** ** **========================================================== */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|_KERNEL
end_ifdef

begin_function_decl
specifier|static
name|nccb_p
name|ncr_alloc_nccb
parameter_list|(
name|ncb_p
name|np
parameter_list|,
name|u_long
name|target
parameter_list|,
name|u_long
name|lun
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ncr_complete
parameter_list|(
name|ncb_p
name|np
parameter_list|,
name|nccb_p
name|cp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ncr_delta
parameter_list|(
name|int
modifier|*
name|from
parameter_list|,
name|int
modifier|*
name|to
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ncr_exception
parameter_list|(
name|ncb_p
name|np
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ncr_free_nccb
parameter_list|(
name|ncb_p
name|np
parameter_list|,
name|nccb_p
name|cp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ncr_freeze_devq
parameter_list|(
name|ncb_p
name|np
parameter_list|,
name|struct
name|cam_path
modifier|*
name|path
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ncr_selectclock
parameter_list|(
name|ncb_p
name|np
parameter_list|,
name|u_char
name|scntl3
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ncr_getclock
parameter_list|(
name|ncb_p
name|np
parameter_list|,
name|u_char
name|multiplier
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|nccb_p
name|ncr_get_nccb
parameter_list|(
name|ncb_p
name|np
parameter_list|,
name|u_long
name|t
parameter_list|,
name|u_long
name|l
parameter_list|)
function_decl|;
end_function_decl

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static  u_int32_t ncr_info(int unit);
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|ncr_init
parameter_list|(
name|ncb_p
name|np
parameter_list|,
name|char
modifier|*
name|msg
parameter_list|,
name|u_long
name|code
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ncr_intr
parameter_list|(
name|void
modifier|*
name|vnp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ncr_int_ma
parameter_list|(
name|ncb_p
name|np
parameter_list|,
name|u_char
name|dstat
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ncr_int_sir
parameter_list|(
name|ncb_p
name|np
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ncr_int_sto
parameter_list|(
name|ncb_p
name|np
parameter_list|)
function_decl|;
end_function_decl

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static	void	ncr_min_phys(struct buf *bp);
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|ncr_poll
parameter_list|(
name|struct
name|cam_sim
modifier|*
name|sim
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ncb_profile
parameter_list|(
name|ncb_p
name|np
parameter_list|,
name|nccb_p
name|cp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ncr_script_copy_and_bind
parameter_list|(
name|ncb_p
name|np
parameter_list|,
name|ncrcmd
modifier|*
name|src
parameter_list|,
name|ncrcmd
modifier|*
name|dst
parameter_list|,
name|int
name|len
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ncr_script_fill
parameter_list|(
name|struct
name|script
modifier|*
name|scr
parameter_list|,
name|struct
name|scripth
modifier|*
name|scrh
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ncr_scatter
parameter_list|(
name|struct
name|dsb
modifier|*
name|phys
parameter_list|,
name|vm_offset_t
name|vaddr
parameter_list|,
name|vm_size_t
name|datalen
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ncr_getsync
parameter_list|(
name|ncb_p
name|np
parameter_list|,
name|u_char
name|sfac
parameter_list|,
name|u_char
modifier|*
name|fakp
parameter_list|,
name|u_char
modifier|*
name|scntl3p
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ncr_setsync
parameter_list|(
name|ncb_p
name|np
parameter_list|,
name|nccb_p
name|cp
parameter_list|,
name|u_char
name|scntl3
parameter_list|,
name|u_char
name|sxfer
parameter_list|,
name|u_char
name|period
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ncr_setwide
parameter_list|(
name|ncb_p
name|np
parameter_list|,
name|nccb_p
name|cp
parameter_list|,
name|u_char
name|wide
parameter_list|,
name|u_char
name|ack
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ncr_show_msg
parameter_list|(
name|u_char
modifier|*
name|msg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ncr_snooptest
parameter_list|(
name|ncb_p
name|np
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ncr_action
parameter_list|(
name|struct
name|cam_sim
modifier|*
name|sim
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ncr_timeout
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ncr_wakeup
parameter_list|(
name|ncb_p
name|np
parameter_list|,
name|u_long
name|code
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ncr_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ncr_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* _KERNEL */
end_comment

begin_comment
comment|/*========================================================== ** ** **      Global static data. ** ** **========================================================== */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|u_long
name|ncr_version
init|=
name|NCR_VERSION
operator|*
literal|11
operator|+
operator|(
name|u_long
operator|)
sizeof|sizeof
argument_list|(
expr|struct
name|ncb
argument_list|)
operator|*
literal|7
operator|+
operator|(
name|u_long
operator|)
sizeof|sizeof
argument_list|(
expr|struct
name|nccb
argument_list|)
operator|*
literal|5
operator|+
operator|(
name|u_long
operator|)
sizeof|sizeof
argument_list|(
expr|struct
name|lcb
argument_list|)
operator|*
literal|3
operator|+
operator|(
name|u_long
operator|)
sizeof|sizeof
argument_list|(
expr|struct
name|tcb
argument_list|)
operator|*
literal|2
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|_KERNEL
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|ncr_debug
init|=
name|SCSI_NCR_DEBUG
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_debug
argument_list|,
name|OID_AUTO
argument_list|,
name|ncr_debug
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|ncr_debug
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|ncr_cache
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* to be aligned _NOT_ static */
end_comment

begin_comment
comment|/*========================================================== ** ** **      Global static data:	auto configure ** ** **========================================================== */
end_comment

begin_define
define|#
directive|define
name|NCR_810_ID
value|(0x00011000ul)
end_define

begin_define
define|#
directive|define
name|NCR_815_ID
value|(0x00041000ul)
end_define

begin_define
define|#
directive|define
name|NCR_820_ID
value|(0x00021000ul)
end_define

begin_define
define|#
directive|define
name|NCR_825_ID
value|(0x00031000ul)
end_define

begin_define
define|#
directive|define
name|NCR_860_ID
value|(0x00061000ul)
end_define

begin_define
define|#
directive|define
name|NCR_875_ID
value|(0x000f1000ul)
end_define

begin_define
define|#
directive|define
name|NCR_875_ID2
value|(0x008f1000ul)
end_define

begin_define
define|#
directive|define
name|NCR_885_ID
value|(0x000d1000ul)
end_define

begin_define
define|#
directive|define
name|NCR_895_ID
value|(0x000c1000ul)
end_define

begin_define
define|#
directive|define
name|NCR_896_ID
value|(0x000b1000ul)
end_define

begin_define
define|#
directive|define
name|NCR_895A_ID
value|(0x00121000ul)
end_define

begin_define
define|#
directive|define
name|NCR_1510D_ID
value|(0x000a1000ul)
end_define

begin_function
specifier|static
name|char
modifier|*
name|ncr_name
parameter_list|(
name|ncb_p
name|np
parameter_list|)
block|{
specifier|static
name|char
name|name
index|[
literal|10
index|]
decl_stmt|;
name|snprintf
argument_list|(
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|name
argument_list|)
argument_list|,
literal|"ncr%d"
argument_list|,
name|np
operator|->
name|unit
argument_list|)
expr_stmt|;
return|return
operator|(
name|name
operator|)
return|;
block|}
end_function

begin_comment
comment|/*========================================================== ** ** **      Scripts for NCR-Processor. ** **      Use ncr_script_bind for binding to physical addresses. ** ** **========================================================== ** **	NADDR generates a reference to a field of the controller data. **	PADDR generates a reference to another part of the script. **	RADDR generates a reference to a script processor register. **	FADDR generates a reference to a script processor register **		with offset. ** **---------------------------------------------------------- */
end_comment

begin_define
define|#
directive|define
name|RELOC_SOFTC
value|0x40000000
end_define

begin_define
define|#
directive|define
name|RELOC_LABEL
value|0x50000000
end_define

begin_define
define|#
directive|define
name|RELOC_REGISTER
value|0x60000000
end_define

begin_define
define|#
directive|define
name|RELOC_KVAR
value|0x70000000
end_define

begin_define
define|#
directive|define
name|RELOC_LABELH
value|0x80000000
end_define

begin_define
define|#
directive|define
name|RELOC_MASK
value|0xf0000000
end_define

begin_define
define|#
directive|define
name|NADDR
parameter_list|(
name|label
parameter_list|)
value|(RELOC_SOFTC | offsetof(struct ncb, label))
end_define

begin_define
define|#
directive|define
name|PADDR
parameter_list|(
name|label
parameter_list|)
value|(RELOC_LABEL | offsetof(struct script, label))
end_define

begin_define
define|#
directive|define
name|PADDRH
parameter_list|(
name|label
parameter_list|)
value|(RELOC_LABELH | offsetof(struct scripth, label))
end_define

begin_define
define|#
directive|define
name|RADDR
parameter_list|(
name|label
parameter_list|)
value|(RELOC_REGISTER | REG(label))
end_define

begin_define
define|#
directive|define
name|FADDR
parameter_list|(
name|label
parameter_list|,
name|ofs
parameter_list|)
value|(RELOC_REGISTER | ((REG(label))+(ofs)))
end_define

begin_define
define|#
directive|define
name|KVAR
parameter_list|(
name|which
parameter_list|)
value|(RELOC_KVAR | (which))
end_define

begin_define
define|#
directive|define
name|KVAR_SECOND
value|(0)
end_define

begin_define
define|#
directive|define
name|KVAR_TICKS
value|(1)
end_define

begin_define
define|#
directive|define
name|KVAR_NCR_CACHE
value|(2)
end_define

begin_define
define|#
directive|define
name|SCRIPT_KVAR_FIRST
value|(0)
end_define

begin_define
define|#
directive|define
name|SCRIPT_KVAR_LAST
value|(3)
end_define

begin_comment
comment|/*  * Kernel variables referenced in the scripts.  * THESE MUST ALL BE ALIGNED TO A 4-BYTE BOUNDARY.  */
end_comment

begin_decl_stmt
specifier|static
name|void
modifier|*
name|script_kvars
index|[]
init|=
block|{
operator|&
name|time_second
block|,
operator|&
name|ticks
block|,
operator|&
name|ncr_cache
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|script
name|script0
init|=
block|{
comment|/*--------------------------< START>-----------------------*/
block|{
comment|/* 	**	Claim to be still alive ... 	*/
name|SCR_COPY
argument_list|(
sizeof|sizeof
argument_list|(
operator|(
operator|(
expr|struct
name|ncb
operator|*
operator|)
literal|0
operator|)
operator|->
name|heartbeat
argument_list|)
argument_list|)
block|,
name|KVAR
argument_list|(
name|KVAR_SECOND
argument_list|)
block|,
name|NADDR
argument_list|(
name|heartbeat
argument_list|)
block|,
comment|/* 	**      Make data structure address invalid. 	**      clear SIGP. 	*/
name|SCR_LOAD_REG
argument_list|(
name|dsa
argument_list|,
literal|0xff
argument_list|)
block|,
literal|0
block|,
name|SCR_FROM_REG
argument_list|(
name|ctest2
argument_list|)
block|,
literal|0
block|, }
comment|/*-------------------------< START0>----------------------*/
block|,
block|{
comment|/* 	**	Hook for interrupted GetConditionCode. 	**	Will be patched to ... IFTRUE by 	**	the interrupt handler. 	*/
name|SCR_INT
operator|^
name|IFFALSE
argument_list|(
literal|0
argument_list|)
block|,
name|SIR_SENSE_RESTART
block|,  }
comment|/*-------------------------< START1>----------------------*/
block|,
block|{
comment|/* 	**	Hook for stalled start queue. 	**	Will be patched to IFTRUE by the interrupt handler. 	*/
name|SCR_INT
operator|^
name|IFFALSE
argument_list|(
literal|0
argument_list|)
block|,
name|SIR_STALL_RESTART
block|,
comment|/* 	**	Then jump to a certain point in tryloop. 	**	Due to the lack of indirect addressing the code 	**	is self modifying here. 	*/
name|SCR_JUMP
block|, }
comment|/*-------------------------< STARTPOS>--------------------*/
block|,
block|{
name|PADDRH
argument_list|(
name|tryloop
argument_list|)
block|,  }
comment|/*-------------------------< TRYSEL>----------------------*/
block|,
block|{
comment|/* 	**	Now: 	**	DSA: Address of a Data Structure 	**	or   Address of the IDLE-Label. 	** 	**	TEMP:	Address of a script, which tries to 	**		start the NEXT entry. 	** 	**	Save the TEMP register into the SCRATCHA register. 	**	Then copy the DSA to TEMP and RETURN. 	**	This is kind of an indirect jump. 	**	(The script processor has NO stack, so the 	**	CALL is actually a jump and link, and the 	**	RETURN is an indirect jump.) 	** 	**	If the slot was empty, DSA contains the address 	**	of the IDLE part of this script. The processor 	**	jumps to IDLE and waits for a reselect. 	**	It will wake up and try the same slot again 	**	after the SIGP bit becomes set by the host. 	** 	**	If the slot was not empty, DSA contains 	**	the address of the phys-part of a nccb. 	**	The processor jumps to this address. 	**	phys starts with head, 	**	head starts with launch, 	**	so actually the processor jumps to 	**	the lauch part. 	**	If the entry is scheduled for execution, 	**	then launch contains a jump to SELECT. 	**	If it's not scheduled, it contains a jump to IDLE. 	*/
name|SCR_COPY
argument_list|(
literal|4
argument_list|)
block|,
name|RADDR
argument_list|(
name|temp
argument_list|)
block|,
name|RADDR
argument_list|(
name|scratcha
argument_list|)
block|,
name|SCR_COPY
argument_list|(
literal|4
argument_list|)
block|,
name|RADDR
argument_list|(
name|dsa
argument_list|)
block|,
name|RADDR
argument_list|(
name|temp
argument_list|)
block|,
name|SCR_RETURN
block|,
literal|0
block|}
comment|/*-------------------------< SKIP>------------------------*/
block|,
block|{
comment|/* 	**	This entry has been canceled. 	**	Next time use the next slot. 	*/
name|SCR_COPY
argument_list|(
literal|4
argument_list|)
block|,
name|RADDR
argument_list|(
name|scratcha
argument_list|)
block|,
name|PADDR
argument_list|(
name|startpos
argument_list|)
block|,
comment|/* 	**	patch the launch field. 	**	should look like an idle process. 	*/
name|SCR_COPY_F
argument_list|(
literal|4
argument_list|)
block|,
name|RADDR
argument_list|(
name|dsa
argument_list|)
block|,
name|PADDR
argument_list|(
name|skip2
argument_list|)
block|,
name|SCR_COPY
argument_list|(
literal|8
argument_list|)
block|,
name|PADDR
argument_list|(
name|idle
argument_list|)
block|, }
comment|/*-------------------------< SKIP2>-----------------------*/
block|,
block|{
literal|0
block|,
name|SCR_JUMP
block|,
name|PADDR
argument_list|(
name|start
argument_list|)
block|, }
comment|/*-------------------------< IDLE>------------------------*/
block|,
block|{
comment|/* 	**	Nothing to do? 	**	Wait for reselect. 	*/
name|SCR_JUMP
block|,
name|PADDR
argument_list|(
name|reselect
argument_list|)
block|,  }
comment|/*-------------------------< SELECT>----------------------*/
block|,
block|{
comment|/* 	**	DSA	contains the address of a scheduled 	**		data structure. 	** 	**	SCRATCHA contains the address of the script, 	**		which starts the next entry. 	** 	**	Set Initiator mode. 	** 	**	(Target mode is left as an exercise for the reader) 	*/
name|SCR_CLR
argument_list|(
name|SCR_TRG
argument_list|)
block|,
literal|0
block|,
name|SCR_LOAD_REG
argument_list|(
name|HS_REG
argument_list|,
literal|0xff
argument_list|)
block|,
literal|0
block|,
comment|/* 	**      And try to select this target. 	*/
name|SCR_SEL_TBL_ATN
operator|^
name|offsetof
argument_list|(
expr|struct
name|dsb
argument_list|,
name|select
argument_list|)
block|,
name|PADDR
argument_list|(
name|reselect
argument_list|)
block|,
comment|/* 	**	Now there are 4 possibilities: 	** 	**	(1) The ncr loses arbitration. 	**	This is ok, because it will try again, 	**	when the bus becomes idle. 	**	(But beware of the timeout function!) 	** 	**	(2) The ncr is reselected. 	**	Then the script processor takes the jump 	**	to the RESELECT label. 	** 	**	(3) The ncr completes the selection. 	**	Then it will execute the next statement. 	** 	**	(4) There is a selection timeout. 	**	Then the ncr should interrupt the host and stop. 	**	Unfortunately, it seems to continue execution 	**	of the script. But it will fail with an 	**	IID-interrupt on the next WHEN. 	*/
name|SCR_JUMPR
operator|^
name|IFTRUE
argument_list|(
name|WHEN
argument_list|(
name|SCR_MSG_IN
argument_list|)
argument_list|)
block|,
literal|0
block|,
comment|/* 	**	Send the IDENTIFY and SIMPLE_TAG messages 	**	(and the MSG_EXT_SDTR message) 	*/
name|SCR_MOVE_TBL
operator|^
name|SCR_MSG_OUT
block|,
name|offsetof
argument_list|(
expr|struct
name|dsb
argument_list|,
name|smsg
argument_list|)
block|,
ifdef|#
directive|ifdef
name|undef
comment|/* XXX better fail than try to deal with this ... */
name|SCR_JUMPR
operator|^
name|IFTRUE
argument_list|(
name|WHEN
argument_list|(
name|SCR_MSG_OUT
argument_list|)
argument_list|)
block|,
operator|-
literal|16
block|,
endif|#
directive|endif
name|SCR_CLR
argument_list|(
name|SCR_ATN
argument_list|)
block|,
literal|0
block|,
name|SCR_COPY
argument_list|(
literal|1
argument_list|)
block|,
name|RADDR
argument_list|(
name|sfbr
argument_list|)
block|,
name|NADDR
argument_list|(
name|lastmsg
argument_list|)
block|,
comment|/* 	**	Selection complete. 	**	Next time use the next slot. 	*/
name|SCR_COPY
argument_list|(
literal|4
argument_list|)
block|,
name|RADDR
argument_list|(
name|scratcha
argument_list|)
block|,
name|PADDR
argument_list|(
name|startpos
argument_list|)
block|, }
comment|/*-------------------------< PREPARE>----------------------*/
block|,
block|{
comment|/* 	**      The ncr doesn't have an indirect load 	**	or store command. So we have to 	**	copy part of the control block to a 	**	fixed place, where we can access it. 	** 	**	We patch the address part of a 	**	COPY command with the DSA-register. 	*/
name|SCR_COPY_F
argument_list|(
literal|4
argument_list|)
block|,
name|RADDR
argument_list|(
name|dsa
argument_list|)
block|,
name|PADDR
argument_list|(
name|loadpos
argument_list|)
block|,
comment|/* 	**	then we do the actual copy. 	*/
name|SCR_COPY
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|head
argument_list|)
argument_list|)
block|,
comment|/* 	**	continued after the next label ... 	*/
block|}
comment|/*-------------------------< LOADPOS>---------------------*/
block|,
block|{
literal|0
block|,
name|NADDR
argument_list|(
name|header
argument_list|)
block|,
comment|/* 	**      Mark this nccb as not scheduled. 	*/
name|SCR_COPY
argument_list|(
literal|8
argument_list|)
block|,
name|PADDR
argument_list|(
name|idle
argument_list|)
block|,
name|NADDR
argument_list|(
name|header
operator|.
name|launch
argument_list|)
block|,
comment|/* 	**      Set a time stamp for this selection 	*/
name|SCR_COPY
argument_list|(
sizeof|sizeof
argument_list|(
name|ticks
argument_list|)
argument_list|)
block|,
name|KVAR
argument_list|(
name|KVAR_TICKS
argument_list|)
block|,
name|NADDR
argument_list|(
name|header
operator|.
name|stamp
operator|.
name|select
argument_list|)
block|,
comment|/* 	**      load the savep (saved pointer) into 	**      the TEMP register (actual pointer) 	*/
name|SCR_COPY
argument_list|(
literal|4
argument_list|)
block|,
name|NADDR
argument_list|(
name|header
operator|.
name|savep
argument_list|)
block|,
name|RADDR
argument_list|(
name|temp
argument_list|)
block|,
comment|/* 	**      Initialize the status registers 	*/
name|SCR_COPY
argument_list|(
literal|4
argument_list|)
block|,
name|NADDR
argument_list|(
name|header
operator|.
name|status
argument_list|)
block|,
name|RADDR
argument_list|(
name|scr0
argument_list|)
block|,  }
comment|/*-------------------------< PREPARE2>---------------------*/
block|,
block|{
comment|/* 	**      Load the synchronous mode register 	*/
name|SCR_COPY
argument_list|(
literal|1
argument_list|)
block|,
name|NADDR
argument_list|(
name|sync_st
argument_list|)
block|,
name|RADDR
argument_list|(
name|sxfer
argument_list|)
block|,
comment|/* 	**      Load the wide mode and timing register 	*/
name|SCR_COPY
argument_list|(
literal|1
argument_list|)
block|,
name|NADDR
argument_list|(
name|wide_st
argument_list|)
block|,
name|RADDR
argument_list|(
name|scntl3
argument_list|)
block|,
comment|/* 	**	Initialize the msgout buffer with a NOOP message. 	*/
name|SCR_LOAD_REG
argument_list|(
name|scratcha
argument_list|,
name|MSG_NOOP
argument_list|)
block|,
literal|0
block|,
name|SCR_COPY
argument_list|(
literal|1
argument_list|)
block|,
name|RADDR
argument_list|(
name|scratcha
argument_list|)
block|,
name|NADDR
argument_list|(
name|msgout
argument_list|)
block|,
name|SCR_COPY
argument_list|(
literal|1
argument_list|)
block|,
name|RADDR
argument_list|(
name|scratcha
argument_list|)
block|,
name|NADDR
argument_list|(
name|msgin
argument_list|)
block|,
comment|/* 	**	Message in phase ? 	*/
name|SCR_JUMP
operator|^
name|IFFALSE
argument_list|(
name|WHEN
argument_list|(
name|SCR_MSG_IN
argument_list|)
argument_list|)
block|,
name|PADDR
argument_list|(
name|dispatch
argument_list|)
block|,
comment|/* 	**	Extended or reject message ? 	*/
name|SCR_FROM_REG
argument_list|(
name|sbdl
argument_list|)
block|,
literal|0
block|,
name|SCR_JUMP
operator|^
name|IFTRUE
argument_list|(
name|DATA
argument_list|(
name|MSG_EXTENDED
argument_list|)
argument_list|)
block|,
name|PADDR
argument_list|(
name|msg_in
argument_list|)
block|,
name|SCR_JUMP
operator|^
name|IFTRUE
argument_list|(
name|DATA
argument_list|(
name|MSG_MESSAGE_REJECT
argument_list|)
argument_list|)
block|,
name|PADDRH
argument_list|(
name|msg_reject
argument_list|)
block|,
comment|/* 	**	normal processing 	*/
name|SCR_JUMP
block|,
name|PADDR
argument_list|(
name|dispatch
argument_list|)
block|, }
comment|/*-------------------------< SETMSG>----------------------*/
block|,
block|{
name|SCR_COPY
argument_list|(
literal|1
argument_list|)
block|,
name|RADDR
argument_list|(
name|scratcha
argument_list|)
block|,
name|NADDR
argument_list|(
name|msgout
argument_list|)
block|,
name|SCR_SET
argument_list|(
name|SCR_ATN
argument_list|)
block|,
literal|0
block|, }
comment|/*-------------------------< CLRACK>----------------------*/
block|,
block|{
comment|/* 	**	Terminate possible pending message phase. 	*/
name|SCR_CLR
argument_list|(
name|SCR_ACK
argument_list|)
block|,
literal|0
block|,  }
comment|/*-----------------------< DISPATCH>----------------------*/
block|,
block|{
name|SCR_FROM_REG
argument_list|(
name|HS_REG
argument_list|)
block|,
literal|0
block|,
name|SCR_INT
operator|^
name|IFTRUE
argument_list|(
name|DATA
argument_list|(
name|HS_NEGOTIATE
argument_list|)
argument_list|)
block|,
name|SIR_NEGO_FAILED
block|,
comment|/* 	**	remove bogus output signals 	*/
name|SCR_REG_REG
argument_list|(
name|socl
argument_list|,
name|SCR_AND
argument_list|,
name|CACK
operator||
name|CATN
argument_list|)
block|,
literal|0
block|,
name|SCR_RETURN
operator|^
name|IFTRUE
argument_list|(
name|WHEN
argument_list|(
name|SCR_DATA_OUT
argument_list|)
argument_list|)
block|,
literal|0
block|,
name|SCR_RETURN
operator|^
name|IFTRUE
argument_list|(
name|IF
argument_list|(
name|SCR_DATA_IN
argument_list|)
argument_list|)
block|,
literal|0
block|,
name|SCR_JUMP
operator|^
name|IFTRUE
argument_list|(
name|IF
argument_list|(
name|SCR_MSG_OUT
argument_list|)
argument_list|)
block|,
name|PADDR
argument_list|(
name|msg_out
argument_list|)
block|,
name|SCR_JUMP
operator|^
name|IFTRUE
argument_list|(
name|IF
argument_list|(
name|SCR_MSG_IN
argument_list|)
argument_list|)
block|,
name|PADDR
argument_list|(
name|msg_in
argument_list|)
block|,
name|SCR_JUMP
operator|^
name|IFTRUE
argument_list|(
name|IF
argument_list|(
name|SCR_COMMAND
argument_list|)
argument_list|)
block|,
name|PADDR
argument_list|(
name|command
argument_list|)
block|,
name|SCR_JUMP
operator|^
name|IFTRUE
argument_list|(
name|IF
argument_list|(
name|SCR_STATUS
argument_list|)
argument_list|)
block|,
name|PADDR
argument_list|(
name|status
argument_list|)
block|,
comment|/* 	**      Discard one illegal phase byte, if required. 	*/
name|SCR_LOAD_REG
argument_list|(
name|scratcha
argument_list|,
name|XE_BAD_PHASE
argument_list|)
block|,
literal|0
block|,
name|SCR_COPY
argument_list|(
literal|1
argument_list|)
block|,
name|RADDR
argument_list|(
name|scratcha
argument_list|)
block|,
name|NADDR
argument_list|(
name|xerr_st
argument_list|)
block|,
name|SCR_JUMPR
operator|^
name|IFFALSE
argument_list|(
name|IF
argument_list|(
name|SCR_ILG_OUT
argument_list|)
argument_list|)
block|,
literal|8
block|,
name|SCR_MOVE_ABS
argument_list|(
literal|1
argument_list|)
operator|^
name|SCR_ILG_OUT
block|,
name|NADDR
argument_list|(
name|scratch
argument_list|)
block|,
name|SCR_JUMPR
operator|^
name|IFFALSE
argument_list|(
name|IF
argument_list|(
name|SCR_ILG_IN
argument_list|)
argument_list|)
block|,
literal|8
block|,
name|SCR_MOVE_ABS
argument_list|(
literal|1
argument_list|)
operator|^
name|SCR_ILG_IN
block|,
name|NADDR
argument_list|(
name|scratch
argument_list|)
block|,
name|SCR_JUMP
block|,
name|PADDR
argument_list|(
name|dispatch
argument_list|)
block|,  }
comment|/*-------------------------< NO_DATA>--------------------*/
block|,
block|{
comment|/* 	**	The target wants to tranfer too much data 	**	or in the wrong direction. 	**      Remember that in extended error. 	*/
name|SCR_LOAD_REG
argument_list|(
name|scratcha
argument_list|,
name|XE_EXTRA_DATA
argument_list|)
block|,
literal|0
block|,
name|SCR_COPY
argument_list|(
literal|1
argument_list|)
block|,
name|RADDR
argument_list|(
name|scratcha
argument_list|)
block|,
name|NADDR
argument_list|(
name|xerr_st
argument_list|)
block|,
comment|/* 	**      Discard one data byte, if required. 	*/
name|SCR_JUMPR
operator|^
name|IFFALSE
argument_list|(
name|WHEN
argument_list|(
name|SCR_DATA_OUT
argument_list|)
argument_list|)
block|,
literal|8
block|,
name|SCR_MOVE_ABS
argument_list|(
literal|1
argument_list|)
operator|^
name|SCR_DATA_OUT
block|,
name|NADDR
argument_list|(
name|scratch
argument_list|)
block|,
name|SCR_JUMPR
operator|^
name|IFFALSE
argument_list|(
name|IF
argument_list|(
name|SCR_DATA_IN
argument_list|)
argument_list|)
block|,
literal|8
block|,
name|SCR_MOVE_ABS
argument_list|(
literal|1
argument_list|)
operator|^
name|SCR_DATA_IN
block|,
name|NADDR
argument_list|(
name|scratch
argument_list|)
block|,
comment|/* 	**      .. and repeat as required. 	*/
name|SCR_CALL
block|,
name|PADDR
argument_list|(
name|dispatch
argument_list|)
block|,
name|SCR_JUMP
block|,
name|PADDR
argument_list|(
name|no_data
argument_list|)
block|, }
comment|/*-------------------------< CHECKATN>--------------------*/
block|,
block|{
comment|/* 	**	If AAP (bit 1 of scntl0 register) is set 	**	and a parity error is detected, 	**	the script processor asserts ATN. 	** 	**	The target should switch to a MSG_OUT phase 	**	to get the message. 	*/
name|SCR_FROM_REG
argument_list|(
name|socl
argument_list|)
block|,
literal|0
block|,
name|SCR_JUMP
operator|^
name|IFFALSE
argument_list|(
name|MASK
argument_list|(
name|CATN
argument_list|,
name|CATN
argument_list|)
argument_list|)
block|,
name|PADDR
argument_list|(
name|dispatch
argument_list|)
block|,
comment|/* 	**	count it 	*/
name|SCR_REG_REG
argument_list|(
name|PS_REG
argument_list|,
name|SCR_ADD
argument_list|,
literal|1
argument_list|)
block|,
literal|0
block|,
comment|/* 	**	Prepare a MSG_INITIATOR_DET_ERR message 	**	(initiator detected error). 	**	The target should retry the transfer. 	*/
name|SCR_LOAD_REG
argument_list|(
name|scratcha
argument_list|,
name|MSG_INITIATOR_DET_ERR
argument_list|)
block|,
literal|0
block|,
name|SCR_JUMP
block|,
name|PADDR
argument_list|(
name|setmsg
argument_list|)
block|,  }
comment|/*-------------------------< COMMAND>--------------------*/
block|,
block|{
comment|/* 	**	If this is not a GETCC transfer ... 	*/
name|SCR_FROM_REG
argument_list|(
name|SS_REG
argument_list|)
block|,
literal|0
block|,
comment|/*<<<*/
name|SCR_JUMPR
operator|^
name|IFTRUE
argument_list|(
name|DATA
argument_list|(
name|SCSI_STATUS_CHECK_COND
argument_list|)
argument_list|)
block|,
literal|28
block|,
comment|/* 	**	... set a timestamp ... 	*/
name|SCR_COPY
argument_list|(
sizeof|sizeof
argument_list|(
name|ticks
argument_list|)
argument_list|)
block|,
name|KVAR
argument_list|(
name|KVAR_TICKS
argument_list|)
block|,
name|NADDR
argument_list|(
name|header
operator|.
name|stamp
operator|.
name|command
argument_list|)
block|,
comment|/* 	**	... and send the command 	*/
name|SCR_MOVE_TBL
operator|^
name|SCR_COMMAND
block|,
name|offsetof
argument_list|(
expr|struct
name|dsb
argument_list|,
name|cmd
argument_list|)
block|,
name|SCR_JUMP
block|,
name|PADDR
argument_list|(
name|dispatch
argument_list|)
block|,
comment|/* 	**	Send the GETCC command 	*/
comment|/*>>>*/
name|SCR_MOVE_TBL
operator|^
name|SCR_COMMAND
block|,
name|offsetof
argument_list|(
expr|struct
name|dsb
argument_list|,
name|scmd
argument_list|)
block|,
name|SCR_JUMP
block|,
name|PADDR
argument_list|(
name|dispatch
argument_list|)
block|,  }
comment|/*-------------------------< STATUS>--------------------*/
block|,
block|{
comment|/* 	**	set the timestamp. 	*/
name|SCR_COPY
argument_list|(
sizeof|sizeof
argument_list|(
name|ticks
argument_list|)
argument_list|)
block|,
name|KVAR
argument_list|(
name|KVAR_TICKS
argument_list|)
block|,
name|NADDR
argument_list|(
name|header
operator|.
name|stamp
operator|.
name|status
argument_list|)
block|,
comment|/* 	**	If this is a GETCC transfer, 	*/
name|SCR_FROM_REG
argument_list|(
name|SS_REG
argument_list|)
block|,
literal|0
block|,
comment|/*<<<*/
name|SCR_JUMPR
operator|^
name|IFFALSE
argument_list|(
name|DATA
argument_list|(
name|SCSI_STATUS_CHECK_COND
argument_list|)
argument_list|)
block|,
literal|40
block|,
comment|/* 	**	get the status 	*/
name|SCR_MOVE_ABS
argument_list|(
literal|1
argument_list|)
operator|^
name|SCR_STATUS
block|,
name|NADDR
argument_list|(
name|scratch
argument_list|)
block|,
comment|/* 	**	Save status to scsi_status. 	**	Mark as complete. 	**	And wait for disconnect. 	*/
name|SCR_TO_REG
argument_list|(
name|SS_REG
argument_list|)
block|,
literal|0
block|,
name|SCR_REG_REG
argument_list|(
name|SS_REG
argument_list|,
name|SCR_OR
argument_list|,
name|SCSI_STATUS_SENSE
argument_list|)
block|,
literal|0
block|,
name|SCR_LOAD_REG
argument_list|(
name|HS_REG
argument_list|,
name|HS_COMPLETE
argument_list|)
block|,
literal|0
block|,
name|SCR_JUMP
block|,
name|PADDR
argument_list|(
name|checkatn
argument_list|)
block|,
comment|/* 	**	If it was no GETCC transfer, 	**	save the status to scsi_status. 	*/
comment|/*>>>*/
name|SCR_MOVE_ABS
argument_list|(
literal|1
argument_list|)
operator|^
name|SCR_STATUS
block|,
name|NADDR
argument_list|(
name|scratch
argument_list|)
block|,
name|SCR_TO_REG
argument_list|(
name|SS_REG
argument_list|)
block|,
literal|0
block|,
comment|/* 	**	if it was no check condition ... 	*/
name|SCR_JUMP
operator|^
name|IFTRUE
argument_list|(
name|DATA
argument_list|(
name|SCSI_STATUS_CHECK_COND
argument_list|)
argument_list|)
block|,
name|PADDR
argument_list|(
name|checkatn
argument_list|)
block|,
comment|/* 	**	... mark as complete. 	*/
name|SCR_LOAD_REG
argument_list|(
name|HS_REG
argument_list|,
name|HS_COMPLETE
argument_list|)
block|,
literal|0
block|,
name|SCR_JUMP
block|,
name|PADDR
argument_list|(
name|checkatn
argument_list|)
block|,  }
comment|/*-------------------------< MSG_IN>--------------------*/
block|,
block|{
comment|/* 	**	Get the first byte of the message 	**	and save it to SCRATCHA. 	** 	**	The script processor doesn't negate the 	**	ACK signal after this transfer. 	*/
name|SCR_MOVE_ABS
argument_list|(
literal|1
argument_list|)
operator|^
name|SCR_MSG_IN
block|,
name|NADDR
argument_list|(
name|msgin
index|[
literal|0
index|]
argument_list|)
block|,
comment|/* 	**	Check for message parity error. 	*/
name|SCR_TO_REG
argument_list|(
name|scratcha
argument_list|)
block|,
literal|0
block|,
name|SCR_FROM_REG
argument_list|(
name|socl
argument_list|)
block|,
literal|0
block|,
name|SCR_JUMP
operator|^
name|IFTRUE
argument_list|(
name|MASK
argument_list|(
name|CATN
argument_list|,
name|CATN
argument_list|)
argument_list|)
block|,
name|PADDRH
argument_list|(
name|msg_parity
argument_list|)
block|,
name|SCR_FROM_REG
argument_list|(
name|scratcha
argument_list|)
block|,
literal|0
block|,
comment|/* 	**	Parity was ok, handle this message. 	*/
name|SCR_JUMP
operator|^
name|IFTRUE
argument_list|(
name|DATA
argument_list|(
name|MSG_CMDCOMPLETE
argument_list|)
argument_list|)
block|,
name|PADDR
argument_list|(
name|complete
argument_list|)
block|,
name|SCR_JUMP
operator|^
name|IFTRUE
argument_list|(
name|DATA
argument_list|(
name|MSG_SAVEDATAPOINTER
argument_list|)
argument_list|)
block|,
name|PADDR
argument_list|(
name|save_dp
argument_list|)
block|,
name|SCR_JUMP
operator|^
name|IFTRUE
argument_list|(
name|DATA
argument_list|(
name|MSG_RESTOREPOINTERS
argument_list|)
argument_list|)
block|,
name|PADDR
argument_list|(
name|restore_dp
argument_list|)
block|,
name|SCR_JUMP
operator|^
name|IFTRUE
argument_list|(
name|DATA
argument_list|(
name|MSG_DISCONNECT
argument_list|)
argument_list|)
block|,
name|PADDR
argument_list|(
name|disconnect
argument_list|)
block|,
name|SCR_JUMP
operator|^
name|IFTRUE
argument_list|(
name|DATA
argument_list|(
name|MSG_EXTENDED
argument_list|)
argument_list|)
block|,
name|PADDRH
argument_list|(
name|msg_extended
argument_list|)
block|,
name|SCR_JUMP
operator|^
name|IFTRUE
argument_list|(
name|DATA
argument_list|(
name|MSG_NOOP
argument_list|)
argument_list|)
block|,
name|PADDR
argument_list|(
name|clrack
argument_list|)
block|,
name|SCR_JUMP
operator|^
name|IFTRUE
argument_list|(
name|DATA
argument_list|(
name|MSG_MESSAGE_REJECT
argument_list|)
argument_list|)
block|,
name|PADDRH
argument_list|(
name|msg_reject
argument_list|)
block|,
name|SCR_JUMP
operator|^
name|IFTRUE
argument_list|(
name|DATA
argument_list|(
name|MSG_IGN_WIDE_RESIDUE
argument_list|)
argument_list|)
block|,
name|PADDRH
argument_list|(
name|msg_ign_residue
argument_list|)
block|,
comment|/* 	**	Rest of the messages left as 	**	an exercise ... 	** 	**	Unimplemented messages: 	**	fall through to MSG_BAD. 	*/
block|}
comment|/*-------------------------< MSG_BAD>------------------*/
block|,
block|{
comment|/* 	**	unimplemented message - reject it. 	*/
name|SCR_INT
block|,
name|SIR_REJECT_SENT
block|,
name|SCR_LOAD_REG
argument_list|(
name|scratcha
argument_list|,
name|MSG_MESSAGE_REJECT
argument_list|)
block|,
literal|0
block|,
name|SCR_JUMP
block|,
name|PADDR
argument_list|(
name|setmsg
argument_list|)
block|,  }
comment|/*-------------------------< COMPLETE>-----------------*/
block|,
block|{
comment|/* 	**	Complete message. 	** 	**	If it's not the get condition code, 	**	copy TEMP register to LASTP in header. 	*/
name|SCR_FROM_REG
argument_list|(
name|SS_REG
argument_list|)
block|,
literal|0
block|,
comment|/*<<<*/
name|SCR_JUMPR
operator|^
name|IFTRUE
argument_list|(
name|MASK
argument_list|(
name|SCSI_STATUS_SENSE
argument_list|,
name|SCSI_STATUS_SENSE
argument_list|)
argument_list|)
block|,
literal|12
block|,
name|SCR_COPY
argument_list|(
literal|4
argument_list|)
block|,
name|RADDR
argument_list|(
name|temp
argument_list|)
block|,
name|NADDR
argument_list|(
name|header
operator|.
name|lastp
argument_list|)
block|,
comment|/*>>>*/
comment|/* 	**	When we terminate the cycle by clearing ACK, 	**	the target may disconnect immediately. 	** 	**	We don't want to be told of an 	**	"unexpected disconnect", 	**	so we disable this feature. 	*/
name|SCR_REG_REG
argument_list|(
name|scntl2
argument_list|,
name|SCR_AND
argument_list|,
literal|0x7f
argument_list|)
block|,
literal|0
block|,
comment|/* 	**	Terminate cycle ... 	*/
name|SCR_CLR
argument_list|(
name|SCR_ACK
operator||
name|SCR_ATN
argument_list|)
block|,
literal|0
block|,
comment|/* 	**	... and wait for the disconnect. 	*/
name|SCR_WAIT_DISC
block|,
literal|0
block|, }
comment|/*-------------------------< CLEANUP>-------------------*/
block|,
block|{
comment|/* 	**      dsa:    Pointer to nccb 	**	      or xxxxxxFF (no nccb) 	** 	**      HS_REG:   Host-Status (<>0!) 	*/
name|SCR_FROM_REG
argument_list|(
name|dsa
argument_list|)
block|,
literal|0
block|,
name|SCR_JUMP
operator|^
name|IFTRUE
argument_list|(
name|DATA
argument_list|(
literal|0xff
argument_list|)
argument_list|)
block|,
name|PADDR
argument_list|(
name|signal
argument_list|)
block|,
comment|/* 	**      dsa is valid. 	**	save the status registers 	*/
name|SCR_COPY
argument_list|(
literal|4
argument_list|)
block|,
name|RADDR
argument_list|(
name|scr0
argument_list|)
block|,
name|NADDR
argument_list|(
name|header
operator|.
name|status
argument_list|)
block|,
comment|/* 	**	and copy back the header to the nccb. 	*/
name|SCR_COPY_F
argument_list|(
literal|4
argument_list|)
block|,
name|RADDR
argument_list|(
name|dsa
argument_list|)
block|,
name|PADDR
argument_list|(
name|cleanup0
argument_list|)
block|,
name|SCR_COPY
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|head
argument_list|)
argument_list|)
block|,
name|NADDR
argument_list|(
name|header
argument_list|)
block|, }
comment|/*-------------------------< CLEANUP0>--------------------*/
block|,
block|{
literal|0
block|,
comment|/* 	**	If command resulted in "check condition" 	**	status and is not yet completed, 	**	try to get the condition code. 	*/
name|SCR_FROM_REG
argument_list|(
name|HS_REG
argument_list|)
block|,
literal|0
block|,
comment|/*<<<*/
name|SCR_JUMPR
operator|^
name|IFFALSE
argument_list|(
name|MASK
argument_list|(
literal|0
argument_list|,
name|HS_DONEMASK
argument_list|)
argument_list|)
block|,
literal|16
block|,
name|SCR_FROM_REG
argument_list|(
name|SS_REG
argument_list|)
block|,
literal|0
block|,
name|SCR_JUMP
operator|^
name|IFTRUE
argument_list|(
name|DATA
argument_list|(
name|SCSI_STATUS_CHECK_COND
argument_list|)
argument_list|)
block|,
name|PADDRH
argument_list|(
name|getcc2
argument_list|)
block|, }
comment|/*-------------------------< SIGNAL>----------------------*/
block|,
block|{
comment|/* 	**	if status = queue full, 	**	reinsert in startqueue and stall queue. 	*/
comment|/*>>>*/
name|SCR_FROM_REG
argument_list|(
name|SS_REG
argument_list|)
block|,
literal|0
block|,
name|SCR_INT
operator|^
name|IFTRUE
argument_list|(
name|DATA
argument_list|(
name|SCSI_STATUS_QUEUE_FULL
argument_list|)
argument_list|)
block|,
name|SIR_STALL_QUEUE
block|,
comment|/* 	**	And make the DSA register invalid. 	*/
name|SCR_LOAD_REG
argument_list|(
name|dsa
argument_list|,
literal|0xff
argument_list|)
block|,
comment|/* invalid */
literal|0
block|,
comment|/* 	**	if job completed ... 	*/
name|SCR_FROM_REG
argument_list|(
name|HS_REG
argument_list|)
block|,
literal|0
block|,
comment|/* 	**	... signal completion to the host 	*/
name|SCR_INT_FLY
operator|^
name|IFFALSE
argument_list|(
name|MASK
argument_list|(
literal|0
argument_list|,
name|HS_DONEMASK
argument_list|)
argument_list|)
block|,
literal|0
block|,
comment|/* 	**	Auf zu neuen Schandtaten! 	*/
name|SCR_JUMP
block|,
name|PADDR
argument_list|(
name|start
argument_list|)
block|,  }
comment|/*-------------------------< SAVE_DP>------------------*/
block|,
block|{
comment|/* 	**	SAVE_DP message: 	**	Copy TEMP register to SAVEP in header. 	*/
name|SCR_COPY
argument_list|(
literal|4
argument_list|)
block|,
name|RADDR
argument_list|(
name|temp
argument_list|)
block|,
name|NADDR
argument_list|(
name|header
operator|.
name|savep
argument_list|)
block|,
name|SCR_JUMP
block|,
name|PADDR
argument_list|(
name|clrack
argument_list|)
block|, }
comment|/*-------------------------< RESTORE_DP>---------------*/
block|,
block|{
comment|/* 	**	RESTORE_DP message: 	**	Copy SAVEP in header to TEMP register. 	*/
name|SCR_COPY
argument_list|(
literal|4
argument_list|)
block|,
name|NADDR
argument_list|(
name|header
operator|.
name|savep
argument_list|)
block|,
name|RADDR
argument_list|(
name|temp
argument_list|)
block|,
name|SCR_JUMP
block|,
name|PADDR
argument_list|(
name|clrack
argument_list|)
block|,  }
comment|/*-------------------------< DISCONNECT>---------------*/
block|,
block|{
comment|/* 	**	If QUIRK_AUTOSAVE is set, 	**	do a "save pointer" operation. 	*/
name|SCR_FROM_REG
argument_list|(
name|QU_REG
argument_list|)
block|,
literal|0
block|,
comment|/*<<<*/
name|SCR_JUMPR
operator|^
name|IFFALSE
argument_list|(
name|MASK
argument_list|(
name|QUIRK_AUTOSAVE
argument_list|,
name|QUIRK_AUTOSAVE
argument_list|)
argument_list|)
block|,
literal|12
block|,
comment|/* 	**	like SAVE_DP message: 	**	Copy TEMP register to SAVEP in header. 	*/
name|SCR_COPY
argument_list|(
literal|4
argument_list|)
block|,
name|RADDR
argument_list|(
name|temp
argument_list|)
block|,
name|NADDR
argument_list|(
name|header
operator|.
name|savep
argument_list|)
block|,
comment|/*>>>*/
comment|/* 	**	Check if temp==savep or temp==goalp: 	**	if not, log a missing save pointer message. 	**	In fact, it's a comparison mod 256. 	** 	**	Hmmm, I hadn't thought that I would be urged to 	**	write this kind of ugly self modifying code. 	** 	**	It's unbelievable, but the ncr53c8xx isn't able 	**	to subtract one register from another. 	*/
name|SCR_FROM_REG
argument_list|(
name|temp
argument_list|)
block|,
literal|0
block|,
comment|/* 	**	You are not expected to understand this .. 	** 	**	CAUTION: only little endian architectures supported! XXX 	*/
name|SCR_COPY_F
argument_list|(
literal|1
argument_list|)
block|,
name|NADDR
argument_list|(
name|header
operator|.
name|savep
argument_list|)
block|,
name|PADDR
argument_list|(
name|disconnect0
argument_list|)
block|, }
comment|/*-------------------------< DISCONNECT0>--------------*/
block|,
block|{
comment|/*<<<*/
name|SCR_JUMPR
operator|^
name|IFTRUE
argument_list|(
name|DATA
argument_list|(
literal|1
argument_list|)
argument_list|)
block|,
literal|20
block|,
comment|/* 	**	neither this 	*/
name|SCR_COPY_F
argument_list|(
literal|1
argument_list|)
block|,
name|NADDR
argument_list|(
name|header
operator|.
name|goalp
argument_list|)
block|,
name|PADDR
argument_list|(
name|disconnect1
argument_list|)
block|, }
comment|/*-------------------------< DISCONNECT1>--------------*/
block|,
block|{
name|SCR_INT
operator|^
name|IFFALSE
argument_list|(
name|DATA
argument_list|(
literal|1
argument_list|)
argument_list|)
block|,
name|SIR_MISSING_SAVE
block|,
comment|/*>>>*/
comment|/* 	**	DISCONNECTing  ... 	** 	**	disable the "unexpected disconnect" feature, 	**	and remove the ACK signal. 	*/
name|SCR_REG_REG
argument_list|(
name|scntl2
argument_list|,
name|SCR_AND
argument_list|,
literal|0x7f
argument_list|)
block|,
literal|0
block|,
name|SCR_CLR
argument_list|(
name|SCR_ACK
operator||
name|SCR_ATN
argument_list|)
block|,
literal|0
block|,
comment|/* 	**	Wait for the disconnect. 	*/
name|SCR_WAIT_DISC
block|,
literal|0
block|,
comment|/* 	**	Profiling: 	**	Set a time stamp, 	**	and count the disconnects. 	*/
name|SCR_COPY
argument_list|(
sizeof|sizeof
argument_list|(
name|ticks
argument_list|)
argument_list|)
block|,
name|KVAR
argument_list|(
name|KVAR_TICKS
argument_list|)
block|,
name|NADDR
argument_list|(
name|header
operator|.
name|stamp
operator|.
name|disconnect
argument_list|)
block|,
name|SCR_COPY
argument_list|(
literal|4
argument_list|)
block|,
name|NADDR
argument_list|(
name|disc_phys
argument_list|)
block|,
name|RADDR
argument_list|(
name|temp
argument_list|)
block|,
name|SCR_REG_REG
argument_list|(
name|temp
argument_list|,
name|SCR_ADD
argument_list|,
literal|0x01
argument_list|)
block|,
literal|0
block|,
name|SCR_COPY
argument_list|(
literal|4
argument_list|)
block|,
name|RADDR
argument_list|(
name|temp
argument_list|)
block|,
name|NADDR
argument_list|(
name|disc_phys
argument_list|)
block|,
comment|/* 	**	Status is: DISCONNECTED. 	*/
name|SCR_LOAD_REG
argument_list|(
name|HS_REG
argument_list|,
name|HS_DISCONNECT
argument_list|)
block|,
literal|0
block|,
name|SCR_JUMP
block|,
name|PADDR
argument_list|(
name|cleanup
argument_list|)
block|,  }
comment|/*-------------------------< MSG_OUT>-------------------*/
block|,
block|{
comment|/* 	**	The target requests a message. 	*/
name|SCR_MOVE_ABS
argument_list|(
literal|1
argument_list|)
operator|^
name|SCR_MSG_OUT
block|,
name|NADDR
argument_list|(
name|msgout
argument_list|)
block|,
name|SCR_COPY
argument_list|(
literal|1
argument_list|)
block|,
name|RADDR
argument_list|(
name|sfbr
argument_list|)
block|,
name|NADDR
argument_list|(
name|lastmsg
argument_list|)
block|,
comment|/* 	**	If it was no ABORT message ... 	*/
name|SCR_JUMP
operator|^
name|IFTRUE
argument_list|(
name|DATA
argument_list|(
name|MSG_ABORT
argument_list|)
argument_list|)
block|,
name|PADDRH
argument_list|(
name|msg_out_abort
argument_list|)
block|,
comment|/* 	**	... wait for the next phase 	**	if it's a message out, send it again, ... 	*/
name|SCR_JUMP
operator|^
name|IFTRUE
argument_list|(
name|WHEN
argument_list|(
name|SCR_MSG_OUT
argument_list|)
argument_list|)
block|,
name|PADDR
argument_list|(
name|msg_out
argument_list|)
block|, }
comment|/*-------------------------< MSG_OUT_DONE>--------------*/
block|,
block|{
comment|/* 	**	... else clear the message ... 	*/
name|SCR_LOAD_REG
argument_list|(
name|scratcha
argument_list|,
name|MSG_NOOP
argument_list|)
block|,
literal|0
block|,
name|SCR_COPY
argument_list|(
literal|4
argument_list|)
block|,
name|RADDR
argument_list|(
name|scratcha
argument_list|)
block|,
name|NADDR
argument_list|(
name|msgout
argument_list|)
block|,
comment|/* 	**	... and process the next phase 	*/
name|SCR_JUMP
block|,
name|PADDR
argument_list|(
name|dispatch
argument_list|)
block|,  }
comment|/*------------------------< BADGETCC>---------------------*/
block|,
block|{
comment|/* 	**	If SIGP was set, clear it and try again. 	*/
name|SCR_FROM_REG
argument_list|(
name|ctest2
argument_list|)
block|,
literal|0
block|,
name|SCR_JUMP
operator|^
name|IFTRUE
argument_list|(
name|MASK
argument_list|(
name|CSIGP
argument_list|,
name|CSIGP
argument_list|)
argument_list|)
block|,
name|PADDRH
argument_list|(
name|getcc2
argument_list|)
block|,
name|SCR_INT
block|,
name|SIR_SENSE_FAILED
block|, }
comment|/*-------------------------< RESELECT>--------------------*/
block|,
block|{
comment|/* 	**	This NOP will be patched with LED OFF 	**	SCR_REG_REG (gpreg, SCR_OR, 0x01) 	*/
name|SCR_NO_OP
block|,
literal|0
block|,
comment|/* 	**	make the DSA invalid. 	*/
name|SCR_LOAD_REG
argument_list|(
name|dsa
argument_list|,
literal|0xff
argument_list|)
block|,
literal|0
block|,
name|SCR_CLR
argument_list|(
name|SCR_TRG
argument_list|)
block|,
literal|0
block|,
comment|/* 	**	Sleep waiting for a reselection. 	**	If SIGP is set, special treatment. 	** 	**	Zu allem bereit .. 	*/
name|SCR_WAIT_RESEL
block|,
name|PADDR
argument_list|(
name|reselect2
argument_list|)
block|, }
comment|/*-------------------------< RESELECT1>--------------------*/
block|,
block|{
comment|/* 	**	This NOP will be patched with LED ON 	**	SCR_REG_REG (gpreg, SCR_AND, 0xfe) 	*/
name|SCR_NO_OP
block|,
literal|0
block|,
comment|/* 	**	... zu nichts zu gebrauchen ? 	** 	**      load the target id into the SFBR 	**	and jump to the control block. 	** 	**	Look at the declarations of 	**	- struct ncb 	**	- struct tcb 	**	- struct lcb 	**	- struct nccb 	**	to understand what's going on. 	*/
name|SCR_REG_SFBR
argument_list|(
name|ssid
argument_list|,
name|SCR_AND
argument_list|,
literal|0x8F
argument_list|)
block|,
literal|0
block|,
name|SCR_TO_REG
argument_list|(
name|sdid
argument_list|)
block|,
literal|0
block|,
name|SCR_JUMP
block|,
name|NADDR
argument_list|(
name|jump_tcb
argument_list|)
block|, }
comment|/*-------------------------< RESELECT2>-------------------*/
block|,
block|{
comment|/* 	**	This NOP will be patched with LED ON 	**	SCR_REG_REG (gpreg, SCR_AND, 0xfe) 	*/
name|SCR_NO_OP
block|,
literal|0
block|,
comment|/* 	**	If it's not connected :( 	**	-> interrupted by SIGP bit. 	**	Jump to start. 	*/
name|SCR_FROM_REG
argument_list|(
name|ctest2
argument_list|)
block|,
literal|0
block|,
name|SCR_JUMP
operator|^
name|IFTRUE
argument_list|(
name|MASK
argument_list|(
name|CSIGP
argument_list|,
name|CSIGP
argument_list|)
argument_list|)
block|,
name|PADDR
argument_list|(
name|start
argument_list|)
block|,
name|SCR_JUMP
block|,
name|PADDR
argument_list|(
name|reselect
argument_list|)
block|,  }
comment|/*-------------------------< RESEL_TMP>-------------------*/
block|,
block|{
comment|/* 	**	The return address in TEMP 	**	is in fact the data structure address, 	**	so copy it to the DSA register. 	*/
name|SCR_COPY
argument_list|(
literal|4
argument_list|)
block|,
name|RADDR
argument_list|(
name|temp
argument_list|)
block|,
name|RADDR
argument_list|(
name|dsa
argument_list|)
block|,
name|SCR_JUMP
block|,
name|PADDR
argument_list|(
name|prepare
argument_list|)
block|,  }
comment|/*-------------------------< RESEL_LUN>-------------------*/
block|,
block|{
comment|/* 	**	come back to this point 	**	to get an IDENTIFY message 	**	Wait for a msg_in phase. 	*/
comment|/*<<<*/
name|SCR_JUMPR
operator|^
name|IFFALSE
argument_list|(
name|WHEN
argument_list|(
name|SCR_MSG_IN
argument_list|)
argument_list|)
block|,
literal|48
block|,
comment|/* 	**	message phase 	**	It's not a sony, it's a trick: 	**	read the data without acknowledging it. 	*/
name|SCR_FROM_REG
argument_list|(
name|sbdl
argument_list|)
block|,
literal|0
block|,
comment|/*<<<*/
name|SCR_JUMPR
operator|^
name|IFFALSE
argument_list|(
name|MASK
argument_list|(
name|MSG_IDENTIFYFLAG
argument_list|,
literal|0x98
argument_list|)
argument_list|)
block|,
literal|32
block|,
comment|/* 	**	It WAS an Identify message. 	**	get it and ack it! 	*/
name|SCR_MOVE_ABS
argument_list|(
literal|1
argument_list|)
operator|^
name|SCR_MSG_IN
block|,
name|NADDR
argument_list|(
name|msgin
argument_list|)
block|,
name|SCR_CLR
argument_list|(
name|SCR_ACK
argument_list|)
block|,
literal|0
block|,
comment|/* 	**	Mask out the lun. 	*/
name|SCR_REG_REG
argument_list|(
name|sfbr
argument_list|,
name|SCR_AND
argument_list|,
literal|0x07
argument_list|)
block|,
literal|0
block|,
name|SCR_RETURN
block|,
literal|0
block|,
comment|/* 	**	No message phase or no IDENTIFY message: 	**	return 0. 	*/
comment|/*>>>*/
name|SCR_LOAD_SFBR
argument_list|(
literal|0
argument_list|)
block|,
literal|0
block|,
name|SCR_RETURN
block|,
literal|0
block|,  }
comment|/*-------------------------< RESEL_TAG>-------------------*/
block|,
block|{
comment|/* 	**	come back to this point 	**	to get a SIMPLE_TAG message 	**	Wait for a MSG_IN phase. 	*/
comment|/*<<<*/
name|SCR_JUMPR
operator|^
name|IFFALSE
argument_list|(
name|WHEN
argument_list|(
name|SCR_MSG_IN
argument_list|)
argument_list|)
block|,
literal|64
block|,
comment|/* 	**	message phase 	**	It's a trick - read the data 	**	without acknowledging it. 	*/
name|SCR_FROM_REG
argument_list|(
name|sbdl
argument_list|)
block|,
literal|0
block|,
comment|/*<<<*/
name|SCR_JUMPR
operator|^
name|IFFALSE
argument_list|(
name|DATA
argument_list|(
name|MSG_SIMPLE_Q_TAG
argument_list|)
argument_list|)
block|,
literal|48
block|,
comment|/* 	**	It WAS a SIMPLE_TAG message. 	**	get it and ack it! 	*/
name|SCR_MOVE_ABS
argument_list|(
literal|1
argument_list|)
operator|^
name|SCR_MSG_IN
block|,
name|NADDR
argument_list|(
name|msgin
argument_list|)
block|,
name|SCR_CLR
argument_list|(
name|SCR_ACK
argument_list|)
block|,
literal|0
block|,
comment|/* 	**	Wait for the second byte (the tag) 	*/
comment|/*<<<*/
name|SCR_JUMPR
operator|^
name|IFFALSE
argument_list|(
name|WHEN
argument_list|(
name|SCR_MSG_IN
argument_list|)
argument_list|)
block|,
literal|24
block|,
comment|/* 	**	Get it and ack it! 	*/
name|SCR_MOVE_ABS
argument_list|(
literal|1
argument_list|)
operator|^
name|SCR_MSG_IN
block|,
name|NADDR
argument_list|(
name|msgin
argument_list|)
block|,
name|SCR_CLR
argument_list|(
name|SCR_ACK
operator||
name|SCR_CARRY
argument_list|)
block|,
literal|0
block|,
name|SCR_RETURN
block|,
literal|0
block|,
comment|/* 	**	No message phase or no SIMPLE_TAG message 	**	or no second byte: return 0. 	*/
comment|/*>>>*/
name|SCR_LOAD_SFBR
argument_list|(
literal|0
argument_list|)
block|,
literal|0
block|,
name|SCR_SET
argument_list|(
name|SCR_CARRY
argument_list|)
block|,
literal|0
block|,
name|SCR_RETURN
block|,
literal|0
block|,  }
comment|/*-------------------------< DATA_IN>--------------------*/
block|,
block|{
comment|/* **	Because the size depends on the **	#define MAX_SCATTER parameter, **	it is filled in at runtime. ** **	SCR_JUMP ^ IFFALSE (WHEN (SCR_DATA_IN)), **		PADDR (no_data), **	SCR_COPY (sizeof (ticks)), **		KVAR (KVAR_TICKS), **		NADDR (header.stamp.data), **	SCR_MOVE_TBL ^ SCR_DATA_IN, **		offsetof (struct dsb, data[ 0]), ** **  ##===========< i=1; i<MAX_SCATTER>========= **  ||	SCR_CALL ^ IFFALSE (WHEN (SCR_DATA_IN)), **  ||		PADDR (checkatn), **  ||	SCR_MOVE_TBL ^ SCR_DATA_IN, **  ||		offsetof (struct dsb, data[ i]), **  ##========================================== ** **	SCR_CALL, **		PADDR (checkatn), **	SCR_JUMP, **		PADDR (no_data), */
literal|0
block|}
comment|/*-------------------------< DATA_OUT>-------------------*/
block|,
block|{
comment|/* **	Because the size depends on the **	#define MAX_SCATTER parameter, **	it is filled in at runtime. ** **	SCR_JUMP ^ IFFALSE (WHEN (SCR_DATA_OUT)), **		PADDR (no_data), **	SCR_COPY (sizeof (ticks)), **		KVAR (KVAR_TICKS), **		NADDR (header.stamp.data), **	SCR_MOVE_TBL ^ SCR_DATA_OUT, **		offsetof (struct dsb, data[ 0]), ** **  ##===========< i=1; i<MAX_SCATTER>========= **  ||	SCR_CALL ^ IFFALSE (WHEN (SCR_DATA_OUT)), **  ||		PADDR (dispatch), **  ||	SCR_MOVE_TBL ^ SCR_DATA_OUT, **  ||		offsetof (struct dsb, data[ i]), **  ##========================================== ** **	SCR_CALL, **		PADDR (dispatch), **	SCR_JUMP, **		PADDR (no_data), ** **--------------------------------------------------------- */
operator|(
name|u_long
operator|)
literal|0
block|}
comment|/*--------------------------------------------------------*/
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|scripth
name|scripth0
init|=
block|{
comment|/*-------------------------< TRYLOOP>---------------------*/
block|{
comment|/* **	Load an entry of the start queue into dsa **	and try to start it by jumping to TRYSEL. ** **	Because the size depends on the **	#define MAX_START parameter, it is filled **	in at runtime. ** **----------------------------------------------------------- ** **  ##===========< I=0; i<MAX_START>=========== **  ||	SCR_COPY (4), **  ||		NADDR (squeue[i]), **  ||		RADDR (dsa), **  ||	SCR_CALL, **  ||		PADDR (trysel), **  ##========================================== ** **	SCR_JUMP, **		PADDRH(tryloop), ** **----------------------------------------------------------- */
literal|0
block|}
comment|/*-------------------------< MSG_PARITY>---------------*/
block|,
block|{
comment|/* 	**	count it 	*/
name|SCR_REG_REG
argument_list|(
name|PS_REG
argument_list|,
name|SCR_ADD
argument_list|,
literal|0x01
argument_list|)
block|,
literal|0
block|,
comment|/* 	**	send a "message parity error" message. 	*/
name|SCR_LOAD_REG
argument_list|(
name|scratcha
argument_list|,
name|MSG_PARITY_ERROR
argument_list|)
block|,
literal|0
block|,
name|SCR_JUMP
block|,
name|PADDR
argument_list|(
name|setmsg
argument_list|)
block|, }
comment|/*-------------------------< MSG_MESSAGE_REJECT>---------------*/
block|,
block|{
comment|/* 	**	If a negotiation was in progress, 	**	negotiation failed. 	*/
name|SCR_FROM_REG
argument_list|(
name|HS_REG
argument_list|)
block|,
literal|0
block|,
name|SCR_INT
operator|^
name|IFTRUE
argument_list|(
name|DATA
argument_list|(
name|HS_NEGOTIATE
argument_list|)
argument_list|)
block|,
name|SIR_NEGO_FAILED
block|,
comment|/* 	**	else make host log this message 	*/
name|SCR_INT
operator|^
name|IFFALSE
argument_list|(
name|DATA
argument_list|(
name|HS_NEGOTIATE
argument_list|)
argument_list|)
block|,
name|SIR_REJECT_RECEIVED
block|,
name|SCR_JUMP
block|,
name|PADDR
argument_list|(
name|clrack
argument_list|)
block|,  }
comment|/*-------------------------< MSG_IGN_RESIDUE>----------*/
block|,
block|{
comment|/* 	**	Terminate cycle 	*/
name|SCR_CLR
argument_list|(
name|SCR_ACK
argument_list|)
block|,
literal|0
block|,
name|SCR_JUMP
operator|^
name|IFFALSE
argument_list|(
name|WHEN
argument_list|(
name|SCR_MSG_IN
argument_list|)
argument_list|)
block|,
name|PADDR
argument_list|(
name|dispatch
argument_list|)
block|,
comment|/* 	**	get residue size. 	*/
name|SCR_MOVE_ABS
argument_list|(
literal|1
argument_list|)
operator|^
name|SCR_MSG_IN
block|,
name|NADDR
argument_list|(
name|msgin
index|[
literal|1
index|]
argument_list|)
block|,
comment|/* 	**	Check for message parity error. 	*/
name|SCR_TO_REG
argument_list|(
name|scratcha
argument_list|)
block|,
literal|0
block|,
name|SCR_FROM_REG
argument_list|(
name|socl
argument_list|)
block|,
literal|0
block|,
name|SCR_JUMP
operator|^
name|IFTRUE
argument_list|(
name|MASK
argument_list|(
name|CATN
argument_list|,
name|CATN
argument_list|)
argument_list|)
block|,
name|PADDRH
argument_list|(
name|msg_parity
argument_list|)
block|,
name|SCR_FROM_REG
argument_list|(
name|scratcha
argument_list|)
block|,
literal|0
block|,
comment|/* 	**	Size is 0 .. ignore message. 	*/
name|SCR_JUMP
operator|^
name|IFTRUE
argument_list|(
name|DATA
argument_list|(
literal|0
argument_list|)
argument_list|)
block|,
name|PADDR
argument_list|(
name|clrack
argument_list|)
block|,
comment|/* 	**	Size is not 1 .. have to interrupt. 	*/
comment|/*<<<*/
name|SCR_JUMPR
operator|^
name|IFFALSE
argument_list|(
name|DATA
argument_list|(
literal|1
argument_list|)
argument_list|)
block|,
literal|40
block|,
comment|/* 	**	Check for residue byte in swide register 	*/
name|SCR_FROM_REG
argument_list|(
name|scntl2
argument_list|)
block|,
literal|0
block|,
comment|/*<<<*/
name|SCR_JUMPR
operator|^
name|IFFALSE
argument_list|(
name|MASK
argument_list|(
name|WSR
argument_list|,
name|WSR
argument_list|)
argument_list|)
block|,
literal|16
block|,
comment|/* 	**	There IS data in the swide register. 	**	Discard it. 	*/
name|SCR_REG_REG
argument_list|(
name|scntl2
argument_list|,
name|SCR_OR
argument_list|,
name|WSR
argument_list|)
block|,
literal|0
block|,
name|SCR_JUMP
block|,
name|PADDR
argument_list|(
name|clrack
argument_list|)
block|,
comment|/* 	**	Load again the size to the sfbr register. 	*/
comment|/*>>>*/
name|SCR_FROM_REG
argument_list|(
name|scratcha
argument_list|)
block|,
literal|0
block|,
comment|/*>>>*/
name|SCR_INT
block|,
name|SIR_IGN_RESIDUE
block|,
name|SCR_JUMP
block|,
name|PADDR
argument_list|(
name|clrack
argument_list|)
block|,  }
comment|/*-------------------------< MSG_EXTENDED>-------------*/
block|,
block|{
comment|/* 	**	Terminate cycle 	*/
name|SCR_CLR
argument_list|(
name|SCR_ACK
argument_list|)
block|,
literal|0
block|,
name|SCR_JUMP
operator|^
name|IFFALSE
argument_list|(
name|WHEN
argument_list|(
name|SCR_MSG_IN
argument_list|)
argument_list|)
block|,
name|PADDR
argument_list|(
name|dispatch
argument_list|)
block|,
comment|/* 	**	get length. 	*/
name|SCR_MOVE_ABS
argument_list|(
literal|1
argument_list|)
operator|^
name|SCR_MSG_IN
block|,
name|NADDR
argument_list|(
name|msgin
index|[
literal|1
index|]
argument_list|)
block|,
comment|/* 	**	Check for message parity error. 	*/
name|SCR_TO_REG
argument_list|(
name|scratcha
argument_list|)
block|,
literal|0
block|,
name|SCR_FROM_REG
argument_list|(
name|socl
argument_list|)
block|,
literal|0
block|,
name|SCR_JUMP
operator|^
name|IFTRUE
argument_list|(
name|MASK
argument_list|(
name|CATN
argument_list|,
name|CATN
argument_list|)
argument_list|)
block|,
name|PADDRH
argument_list|(
name|msg_parity
argument_list|)
block|,
name|SCR_FROM_REG
argument_list|(
name|scratcha
argument_list|)
block|,
literal|0
block|,
comment|/* 	*/
name|SCR_JUMP
operator|^
name|IFTRUE
argument_list|(
name|DATA
argument_list|(
literal|3
argument_list|)
argument_list|)
block|,
name|PADDRH
argument_list|(
name|msg_ext_3
argument_list|)
block|,
name|SCR_JUMP
operator|^
name|IFFALSE
argument_list|(
name|DATA
argument_list|(
literal|2
argument_list|)
argument_list|)
block|,
name|PADDR
argument_list|(
name|msg_bad
argument_list|)
block|, }
comment|/*-------------------------< MSG_EXT_2>----------------*/
block|,
block|{
name|SCR_CLR
argument_list|(
name|SCR_ACK
argument_list|)
block|,
literal|0
block|,
name|SCR_JUMP
operator|^
name|IFFALSE
argument_list|(
name|WHEN
argument_list|(
name|SCR_MSG_IN
argument_list|)
argument_list|)
block|,
name|PADDR
argument_list|(
name|dispatch
argument_list|)
block|,
comment|/* 	**	get extended message code. 	*/
name|SCR_MOVE_ABS
argument_list|(
literal|1
argument_list|)
operator|^
name|SCR_MSG_IN
block|,
name|NADDR
argument_list|(
name|msgin
index|[
literal|2
index|]
argument_list|)
block|,
comment|/* 	**	Check for message parity error. 	*/
name|SCR_TO_REG
argument_list|(
name|scratcha
argument_list|)
block|,
literal|0
block|,
name|SCR_FROM_REG
argument_list|(
name|socl
argument_list|)
block|,
literal|0
block|,
name|SCR_JUMP
operator|^
name|IFTRUE
argument_list|(
name|MASK
argument_list|(
name|CATN
argument_list|,
name|CATN
argument_list|)
argument_list|)
block|,
name|PADDRH
argument_list|(
name|msg_parity
argument_list|)
block|,
name|SCR_FROM_REG
argument_list|(
name|scratcha
argument_list|)
block|,
literal|0
block|,
name|SCR_JUMP
operator|^
name|IFTRUE
argument_list|(
name|DATA
argument_list|(
name|MSG_EXT_WDTR
argument_list|)
argument_list|)
block|,
name|PADDRH
argument_list|(
name|msg_wdtr
argument_list|)
block|,
comment|/* 	**	unknown extended message 	*/
name|SCR_JUMP
block|,
name|PADDR
argument_list|(
argument|msg_bad
argument_list|)
block|}
comment|/*-------------------------< MSG_WDTR>-----------------*/
block|,
block|{
name|SCR_CLR
argument_list|(
name|SCR_ACK
argument_list|)
block|,
literal|0
block|,
name|SCR_JUMP
operator|^
name|IFFALSE
argument_list|(
name|WHEN
argument_list|(
name|SCR_MSG_IN
argument_list|)
argument_list|)
block|,
name|PADDR
argument_list|(
name|dispatch
argument_list|)
block|,
comment|/* 	**	get data bus width 	*/
name|SCR_MOVE_ABS
argument_list|(
literal|1
argument_list|)
operator|^
name|SCR_MSG_IN
block|,
name|NADDR
argument_list|(
name|msgin
index|[
literal|3
index|]
argument_list|)
block|,
name|SCR_FROM_REG
argument_list|(
name|socl
argument_list|)
block|,
literal|0
block|,
name|SCR_JUMP
operator|^
name|IFTRUE
argument_list|(
name|MASK
argument_list|(
name|CATN
argument_list|,
name|CATN
argument_list|)
argument_list|)
block|,
name|PADDRH
argument_list|(
name|msg_parity
argument_list|)
block|,
comment|/* 	**	let the host do the real work. 	*/
name|SCR_INT
block|,
name|SIR_NEGO_WIDE
block|,
comment|/* 	**	let the target fetch our answer. 	*/
name|SCR_SET
argument_list|(
name|SCR_ATN
argument_list|)
block|,
literal|0
block|,
name|SCR_CLR
argument_list|(
name|SCR_ACK
argument_list|)
block|,
literal|0
block|,
name|SCR_INT
operator|^
name|IFFALSE
argument_list|(
name|WHEN
argument_list|(
name|SCR_MSG_OUT
argument_list|)
argument_list|)
block|,
name|SIR_NEGO_PROTO
block|,
comment|/* 	**	Send the MSG_EXT_WDTR 	*/
name|SCR_MOVE_ABS
argument_list|(
literal|4
argument_list|)
operator|^
name|SCR_MSG_OUT
block|,
name|NADDR
argument_list|(
name|msgout
argument_list|)
block|,
name|SCR_CLR
argument_list|(
name|SCR_ATN
argument_list|)
block|,
literal|0
block|,
name|SCR_COPY
argument_list|(
literal|1
argument_list|)
block|,
name|RADDR
argument_list|(
name|sfbr
argument_list|)
block|,
name|NADDR
argument_list|(
name|lastmsg
argument_list|)
block|,
name|SCR_JUMP
block|,
name|PADDR
argument_list|(
name|msg_out_done
argument_list|)
block|,  }
comment|/*-------------------------< MSG_EXT_3>----------------*/
block|,
block|{
name|SCR_CLR
argument_list|(
name|SCR_ACK
argument_list|)
block|,
literal|0
block|,
name|SCR_JUMP
operator|^
name|IFFALSE
argument_list|(
name|WHEN
argument_list|(
name|SCR_MSG_IN
argument_list|)
argument_list|)
block|,
name|PADDR
argument_list|(
name|dispatch
argument_list|)
block|,
comment|/* 	**	get extended message code. 	*/
name|SCR_MOVE_ABS
argument_list|(
literal|1
argument_list|)
operator|^
name|SCR_MSG_IN
block|,
name|NADDR
argument_list|(
name|msgin
index|[
literal|2
index|]
argument_list|)
block|,
comment|/* 	**	Check for message parity error. 	*/
name|SCR_TO_REG
argument_list|(
name|scratcha
argument_list|)
block|,
literal|0
block|,
name|SCR_FROM_REG
argument_list|(
name|socl
argument_list|)
block|,
literal|0
block|,
name|SCR_JUMP
operator|^
name|IFTRUE
argument_list|(
name|MASK
argument_list|(
name|CATN
argument_list|,
name|CATN
argument_list|)
argument_list|)
block|,
name|PADDRH
argument_list|(
name|msg_parity
argument_list|)
block|,
name|SCR_FROM_REG
argument_list|(
name|scratcha
argument_list|)
block|,
literal|0
block|,
name|SCR_JUMP
operator|^
name|IFTRUE
argument_list|(
name|DATA
argument_list|(
name|MSG_EXT_SDTR
argument_list|)
argument_list|)
block|,
name|PADDRH
argument_list|(
name|msg_sdtr
argument_list|)
block|,
comment|/* 	**	unknown extended message 	*/
name|SCR_JUMP
block|,
name|PADDR
argument_list|(
argument|msg_bad
argument_list|)
block|}
comment|/*-------------------------< MSG_SDTR>-----------------*/
block|,
block|{
name|SCR_CLR
argument_list|(
name|SCR_ACK
argument_list|)
block|,
literal|0
block|,
name|SCR_JUMP
operator|^
name|IFFALSE
argument_list|(
name|WHEN
argument_list|(
name|SCR_MSG_IN
argument_list|)
argument_list|)
block|,
name|PADDR
argument_list|(
name|dispatch
argument_list|)
block|,
comment|/* 	**	get period and offset 	*/
name|SCR_MOVE_ABS
argument_list|(
literal|2
argument_list|)
operator|^
name|SCR_MSG_IN
block|,
name|NADDR
argument_list|(
name|msgin
index|[
literal|3
index|]
argument_list|)
block|,
name|SCR_FROM_REG
argument_list|(
name|socl
argument_list|)
block|,
literal|0
block|,
name|SCR_JUMP
operator|^
name|IFTRUE
argument_list|(
name|MASK
argument_list|(
name|CATN
argument_list|,
name|CATN
argument_list|)
argument_list|)
block|,
name|PADDRH
argument_list|(
name|msg_parity
argument_list|)
block|,
comment|/* 	**	let the host do the real work. 	*/
name|SCR_INT
block|,
name|SIR_NEGO_SYNC
block|,
comment|/* 	**	let the target fetch our answer. 	*/
name|SCR_SET
argument_list|(
name|SCR_ATN
argument_list|)
block|,
literal|0
block|,
name|SCR_CLR
argument_list|(
name|SCR_ACK
argument_list|)
block|,
literal|0
block|,
name|SCR_INT
operator|^
name|IFFALSE
argument_list|(
name|WHEN
argument_list|(
name|SCR_MSG_OUT
argument_list|)
argument_list|)
block|,
name|SIR_NEGO_PROTO
block|,
comment|/* 	**	Send the MSG_EXT_SDTR 	*/
name|SCR_MOVE_ABS
argument_list|(
literal|5
argument_list|)
operator|^
name|SCR_MSG_OUT
block|,
name|NADDR
argument_list|(
name|msgout
argument_list|)
block|,
name|SCR_CLR
argument_list|(
name|SCR_ATN
argument_list|)
block|,
literal|0
block|,
name|SCR_COPY
argument_list|(
literal|1
argument_list|)
block|,
name|RADDR
argument_list|(
name|sfbr
argument_list|)
block|,
name|NADDR
argument_list|(
name|lastmsg
argument_list|)
block|,
name|SCR_JUMP
block|,
name|PADDR
argument_list|(
name|msg_out_done
argument_list|)
block|,  }
comment|/*-------------------------< MSG_OUT_ABORT>-------------*/
block|,
block|{
comment|/* 	**	After ABORT message, 	** 	**	expect an immediate disconnect, ... 	*/
name|SCR_REG_REG
argument_list|(
name|scntl2
argument_list|,
name|SCR_AND
argument_list|,
literal|0x7f
argument_list|)
block|,
literal|0
block|,
name|SCR_CLR
argument_list|(
name|SCR_ACK
operator||
name|SCR_ATN
argument_list|)
block|,
literal|0
block|,
name|SCR_WAIT_DISC
block|,
literal|0
block|,
comment|/* 	**	... and set the status to "ABORTED" 	*/
name|SCR_LOAD_REG
argument_list|(
name|HS_REG
argument_list|,
name|HS_ABORTED
argument_list|)
block|,
literal|0
block|,
name|SCR_JUMP
block|,
name|PADDR
argument_list|(
name|cleanup
argument_list|)
block|,  }
comment|/*-------------------------< GETCC>-----------------------*/
block|,
block|{
comment|/* 	**	The ncr doesn't have an indirect load 	**	or store command. So we have to 	**	copy part of the control block to a 	**	fixed place, where we can modify it. 	** 	**	We patch the address part of a COPY command 	**	with the address of the dsa register ... 	*/
name|SCR_COPY_F
argument_list|(
literal|4
argument_list|)
block|,
name|RADDR
argument_list|(
name|dsa
argument_list|)
block|,
name|PADDRH
argument_list|(
name|getcc1
argument_list|)
block|,
comment|/* 	**	... then we do the actual copy. 	*/
name|SCR_COPY
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|head
argument_list|)
argument_list|)
block|, }
comment|/*-------------------------< GETCC1>----------------------*/
block|,
block|{
literal|0
block|,
name|NADDR
argument_list|(
name|header
argument_list|)
block|,
comment|/* 	**	Initialize the status registers 	*/
name|SCR_COPY
argument_list|(
literal|4
argument_list|)
block|,
name|NADDR
argument_list|(
name|header
operator|.
name|status
argument_list|)
block|,
name|RADDR
argument_list|(
name|scr0
argument_list|)
block|, }
comment|/*-------------------------< GETCC2>----------------------*/
block|,
block|{
comment|/* 	**	Get the condition code from a target. 	** 	**	DSA points to a data structure. 	**	Set TEMP to the script location 	**	that receives the condition code. 	** 	**	Because there is no script command 	**	to load a longword into a register, 	**	we use a CALL command. 	*/
comment|/*<<<*/
name|SCR_CALLR
block|,
literal|24
block|,
comment|/* 	**	Get the condition code. 	*/
name|SCR_MOVE_TBL
operator|^
name|SCR_DATA_IN
block|,
name|offsetof
argument_list|(
expr|struct
name|dsb
argument_list|,
name|sense
argument_list|)
block|,
comment|/* 	**	No data phase may follow! 	*/
name|SCR_CALL
block|,
name|PADDR
argument_list|(
name|checkatn
argument_list|)
block|,
name|SCR_JUMP
block|,
name|PADDR
argument_list|(
name|no_data
argument_list|)
block|,
comment|/*>>>*/
comment|/* 	**	The CALL jumps to this point. 	**	Prepare for a RESTORE_POINTER message. 	**	Save the TEMP register into the saved pointer. 	*/
name|SCR_COPY
argument_list|(
literal|4
argument_list|)
block|,
name|RADDR
argument_list|(
name|temp
argument_list|)
block|,
name|NADDR
argument_list|(
name|header
operator|.
name|savep
argument_list|)
block|,
comment|/* 	**	Load scratcha, because in case of a selection timeout, 	**	the host will expect a new value for startpos in 	**	the scratcha register. 	*/
name|SCR_COPY
argument_list|(
literal|4
argument_list|)
block|,
name|PADDR
argument_list|(
name|startpos
argument_list|)
block|,
name|RADDR
argument_list|(
name|scratcha
argument_list|)
block|,
ifdef|#
directive|ifdef
name|NCR_GETCC_WITHMSG
comment|/* 	**	If QUIRK_NOMSG is set, select without ATN. 	**	and don't send a message. 	*/
name|SCR_FROM_REG
argument_list|(
name|QU_REG
argument_list|)
block|,
literal|0
block|,
name|SCR_JUMP
operator|^
name|IFTRUE
argument_list|(
name|MASK
argument_list|(
name|QUIRK_NOMSG
argument_list|,
name|QUIRK_NOMSG
argument_list|)
argument_list|)
block|,
name|PADDRH
argument_list|(
name|getcc3
argument_list|)
block|,
comment|/* 	**	Then try to connect to the target. 	**	If we are reselected, special treatment 	**	of the current job is required before 	**	accepting the reselection. 	*/
name|SCR_SEL_TBL_ATN
operator|^
name|offsetof
argument_list|(
expr|struct
name|dsb
argument_list|,
name|select
argument_list|)
block|,
name|PADDR
argument_list|(
name|badgetcc
argument_list|)
block|,
comment|/* 	**	Send the IDENTIFY message. 	**	In case of short transfer, remove ATN. 	*/
name|SCR_MOVE_TBL
operator|^
name|SCR_MSG_OUT
block|,
name|offsetof
argument_list|(
expr|struct
name|dsb
argument_list|,
name|smsg2
argument_list|)
block|,
name|SCR_CLR
argument_list|(
name|SCR_ATN
argument_list|)
block|,
literal|0
block|,
comment|/* 	**	save the first byte of the message. 	*/
name|SCR_COPY
argument_list|(
literal|1
argument_list|)
block|,
name|RADDR
argument_list|(
name|sfbr
argument_list|)
block|,
name|NADDR
argument_list|(
name|lastmsg
argument_list|)
block|,
name|SCR_JUMP
block|,
name|PADDR
argument_list|(
name|prepare2
argument_list|)
block|,
endif|#
directive|endif
block|}
comment|/*-------------------------< GETCC3>----------------------*/
block|,
block|{
comment|/* 	**	Try to connect to the target. 	**	If we are reselected, special treatment 	**	of the current job is required before 	**	accepting the reselection. 	** 	**	Silly target won't accept a message. 	**	Select without ATN. 	*/
name|SCR_SEL_TBL
operator|^
name|offsetof
argument_list|(
expr|struct
name|dsb
argument_list|,
name|select
argument_list|)
block|,
name|PADDR
argument_list|(
name|badgetcc
argument_list|)
block|,
comment|/* 	**	Force error if selection timeout 	*/
name|SCR_JUMPR
operator|^
name|IFTRUE
argument_list|(
name|WHEN
argument_list|(
name|SCR_MSG_IN
argument_list|)
argument_list|)
block|,
literal|0
block|,
comment|/* 	**	don't negotiate. 	*/
name|SCR_JUMP
block|,
name|PADDR
argument_list|(
name|prepare2
argument_list|)
block|, }
comment|/*-------------------------< ABORTTAG>-------------------*/
block|,
block|{
comment|/* 	**      Abort a bad reselection. 	**	Set the message to ABORT vs. ABORT_TAG 	*/
name|SCR_LOAD_REG
argument_list|(
name|scratcha
argument_list|,
name|MSG_ABORT_TAG
argument_list|)
block|,
literal|0
block|,
name|SCR_JUMPR
operator|^
name|IFFALSE
argument_list|(
name|CARRYSET
argument_list|)
block|,
literal|8
block|, }
comment|/*-------------------------< ABORT>----------------------*/
block|,
block|{
name|SCR_LOAD_REG
argument_list|(
name|scratcha
argument_list|,
name|MSG_ABORT
argument_list|)
block|,
literal|0
block|,
name|SCR_COPY
argument_list|(
literal|1
argument_list|)
block|,
name|RADDR
argument_list|(
name|scratcha
argument_list|)
block|,
name|NADDR
argument_list|(
name|msgout
argument_list|)
block|,
name|SCR_SET
argument_list|(
name|SCR_ATN
argument_list|)
block|,
literal|0
block|,
name|SCR_CLR
argument_list|(
name|SCR_ACK
argument_list|)
block|,
literal|0
block|,
comment|/* 	**	and send it. 	**	we expect an immediate disconnect 	*/
name|SCR_REG_REG
argument_list|(
name|scntl2
argument_list|,
name|SCR_AND
argument_list|,
literal|0x7f
argument_list|)
block|,
literal|0
block|,
name|SCR_MOVE_ABS
argument_list|(
literal|1
argument_list|)
operator|^
name|SCR_MSG_OUT
block|,
name|NADDR
argument_list|(
name|msgout
argument_list|)
block|,
name|SCR_COPY
argument_list|(
literal|1
argument_list|)
block|,
name|RADDR
argument_list|(
name|sfbr
argument_list|)
block|,
name|NADDR
argument_list|(
name|lastmsg
argument_list|)
block|,
name|SCR_CLR
argument_list|(
name|SCR_ACK
operator||
name|SCR_ATN
argument_list|)
block|,
literal|0
block|,
name|SCR_WAIT_DISC
block|,
literal|0
block|,
name|SCR_JUMP
block|,
name|PADDR
argument_list|(
name|start
argument_list|)
block|, }
comment|/*-------------------------< SNOOPTEST>-------------------*/
block|,
block|{
comment|/* 	**	Read the variable. 	*/
name|SCR_COPY
argument_list|(
literal|4
argument_list|)
block|,
name|KVAR
argument_list|(
name|KVAR_NCR_CACHE
argument_list|)
block|,
name|RADDR
argument_list|(
name|scratcha
argument_list|)
block|,
comment|/* 	**	Write the variable. 	*/
name|SCR_COPY
argument_list|(
literal|4
argument_list|)
block|,
name|RADDR
argument_list|(
name|temp
argument_list|)
block|,
name|KVAR
argument_list|(
name|KVAR_NCR_CACHE
argument_list|)
block|,
comment|/* 	**	Read back the variable. 	*/
name|SCR_COPY
argument_list|(
literal|4
argument_list|)
block|,
name|KVAR
argument_list|(
name|KVAR_NCR_CACHE
argument_list|)
block|,
name|RADDR
argument_list|(
name|temp
argument_list|)
block|, }
comment|/*-------------------------< SNOOPEND>-------------------*/
block|,
block|{
comment|/* 	**	And stop. 	*/
name|SCR_INT
block|,
literal|99
block|, }
comment|/*--------------------------------------------------------*/
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*========================================================== ** ** **	Fill in #define dependent parts of the script ** ** **========================================================== */
end_comment

begin_function
specifier|static
name|void
name|ncr_script_fill
parameter_list|(
name|struct
name|script
modifier|*
name|scr
parameter_list|,
name|struct
name|scripth
modifier|*
name|scrh
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|ncrcmd
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|scrh
operator|->
name|tryloop
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_START
condition|;
name|i
operator|++
control|)
block|{
operator|*
name|p
operator|++
operator|=
name|SCR_COPY
argument_list|(
literal|4
argument_list|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|NADDR
argument_list|(
name|squeue
index|[
name|i
index|]
argument_list|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|RADDR
argument_list|(
name|dsa
argument_list|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|SCR_CALL
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|PADDR
argument_list|(
name|trysel
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
operator|*
name|p
operator|++
operator|=
name|SCR_JUMP
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|PADDRH
argument_list|(
name|tryloop
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|(
name|char
operator|*
operator|)
name|p
operator|==
operator|(
name|char
operator|*
operator|)
operator|&
name|scrh
operator|->
name|tryloop
operator|+
sizeof|sizeof
argument_list|(
name|scrh
operator|->
name|tryloop
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|=
name|scr
operator|->
name|data_in
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|SCR_JUMP
operator|^
name|IFFALSE
argument_list|(
name|WHEN
argument_list|(
name|SCR_DATA_IN
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|PADDR
argument_list|(
name|no_data
argument_list|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|SCR_COPY
argument_list|(
sizeof|sizeof
argument_list|(
name|ticks
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
operator|(
name|ncrcmd
operator|)
name|KVAR
argument_list|(
name|KVAR_TICKS
argument_list|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|NADDR
argument_list|(
name|header
operator|.
name|stamp
operator|.
name|data
argument_list|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|SCR_MOVE_TBL
operator|^
name|SCR_DATA_IN
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|offsetof
argument_list|(
expr|struct
name|dsb
argument_list|,
name|data
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|MAX_SCATTER
condition|;
name|i
operator|++
control|)
block|{
operator|*
name|p
operator|++
operator|=
name|SCR_CALL
operator|^
name|IFFALSE
argument_list|(
name|WHEN
argument_list|(
name|SCR_DATA_IN
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|PADDR
argument_list|(
name|checkatn
argument_list|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|SCR_MOVE_TBL
operator|^
name|SCR_DATA_IN
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|offsetof
argument_list|(
expr|struct
name|dsb
argument_list|,
name|data
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
operator|*
name|p
operator|++
operator|=
name|SCR_CALL
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|PADDR
argument_list|(
name|checkatn
argument_list|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|SCR_JUMP
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|PADDR
argument_list|(
name|no_data
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|(
name|char
operator|*
operator|)
name|p
operator|==
operator|(
name|char
operator|*
operator|)
operator|&
name|scr
operator|->
name|data_in
operator|+
sizeof|sizeof
argument_list|(
name|scr
operator|->
name|data_in
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|=
name|scr
operator|->
name|data_out
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|SCR_JUMP
operator|^
name|IFFALSE
argument_list|(
name|WHEN
argument_list|(
name|SCR_DATA_OUT
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|PADDR
argument_list|(
name|no_data
argument_list|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|SCR_COPY
argument_list|(
sizeof|sizeof
argument_list|(
name|ticks
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
operator|(
name|ncrcmd
operator|)
name|KVAR
argument_list|(
name|KVAR_TICKS
argument_list|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|NADDR
argument_list|(
name|header
operator|.
name|stamp
operator|.
name|data
argument_list|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|SCR_MOVE_TBL
operator|^
name|SCR_DATA_OUT
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|offsetof
argument_list|(
expr|struct
name|dsb
argument_list|,
name|data
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|MAX_SCATTER
condition|;
name|i
operator|++
control|)
block|{
operator|*
name|p
operator|++
operator|=
name|SCR_CALL
operator|^
name|IFFALSE
argument_list|(
name|WHEN
argument_list|(
name|SCR_DATA_OUT
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|PADDR
argument_list|(
name|dispatch
argument_list|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|SCR_MOVE_TBL
operator|^
name|SCR_DATA_OUT
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|offsetof
argument_list|(
expr|struct
name|dsb
argument_list|,
name|data
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
operator|*
name|p
operator|++
operator|=
name|SCR_CALL
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|PADDR
argument_list|(
name|dispatch
argument_list|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|SCR_JUMP
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|PADDR
argument_list|(
name|no_data
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|(
name|char
operator|*
operator|)
name|p
operator|==
operator|(
name|char
operator|*
operator|)
operator|&
name|scr
operator|->
name|data_out
operator|+
sizeof|sizeof
argument_list|(
name|scr
operator|->
name|data_out
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*========================================================== ** ** **	Copy and rebind a script. ** ** **========================================================== */
end_comment

begin_function
specifier|static
name|void
name|ncr_script_copy_and_bind
parameter_list|(
name|ncb_p
name|np
parameter_list|,
name|ncrcmd
modifier|*
name|src
parameter_list|,
name|ncrcmd
modifier|*
name|dst
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|ncrcmd
name|opcode
decl_stmt|,
name|new
decl_stmt|,
name|old
decl_stmt|,
name|tmp1
decl_stmt|,
name|tmp2
decl_stmt|;
name|ncrcmd
modifier|*
name|start
decl_stmt|,
modifier|*
name|end
decl_stmt|;
name|int
name|relocs
decl_stmt|,
name|offset
decl_stmt|;
name|start
operator|=
name|src
expr_stmt|;
name|end
operator|=
name|src
operator|+
name|len
operator|/
literal|4
expr_stmt|;
name|offset
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|src
operator|<
name|end
condition|)
block|{
name|opcode
operator|=
operator|*
name|src
operator|++
expr_stmt|;
name|WRITESCRIPT_OFF
argument_list|(
name|dst
argument_list|,
name|offset
argument_list|,
name|opcode
argument_list|)
expr_stmt|;
name|offset
operator|+=
literal|4
expr_stmt|;
comment|/* 		**	If we forget to change the length 		**	in struct script, a field will be 		**	padded with 0. This is an illegal 		**	command. 		*/
if|if
condition|(
name|opcode
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%s: ERROR0 IN SCRIPT at %d.\n"
argument_list|,
name|ncr_name
argument_list|(
name|np
argument_list|)
argument_list|,
call|(
name|int
call|)
argument_list|(
name|src
operator|-
name|start
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1000000
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
if|if
condition|(
name|DEBUG_FLAGS
operator|&
name|DEBUG_SCRIPT
condition|)
name|printf
argument_list|(
literal|"%p:<%x>\n"
argument_list|,
operator|(
name|src
operator|-
literal|1
operator|)
argument_list|,
operator|(
name|unsigned
operator|)
name|opcode
argument_list|)
expr_stmt|;
comment|/* 		**	We don't have to decode ALL commands 		*/
switch|switch
condition|(
name|opcode
operator|>>
literal|28
condition|)
block|{
case|case
literal|0xc
case|:
comment|/* 			**	COPY has TWO arguments. 			*/
name|relocs
operator|=
literal|2
expr_stmt|;
name|tmp1
operator|=
name|src
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|tmp1
operator|&
name|RELOC_MASK
operator|)
operator|==
name|RELOC_KVAR
condition|)
name|tmp1
operator|=
literal|0
expr_stmt|;
name|tmp2
operator|=
name|src
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|tmp2
operator|&
name|RELOC_MASK
operator|)
operator|==
name|RELOC_KVAR
condition|)
name|tmp2
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|tmp1
operator|^
name|tmp2
operator|)
operator|&
literal|3
condition|)
block|{
name|printf
argument_list|(
literal|"%s: ERROR1 IN SCRIPT at %d.\n"
argument_list|,
name|ncr_name
argument_list|(
name|np
argument_list|)
argument_list|,
call|(
name|int
call|)
argument_list|(
name|src
operator|-
name|start
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1000000
argument_list|)
expr_stmt|;
block|}
comment|/* 			**	If PREFETCH feature not enabled, remove  			**	the NO FLUSH bit if present. 			*/
if|if
condition|(
operator|(
name|opcode
operator|&
name|SCR_NO_FLUSH
operator|)
operator|&&
operator|!
operator|(
name|np
operator|->
name|features
operator|&
name|FE_PFEN
operator|)
condition|)
name|WRITESCRIPT_OFF
argument_list|(
name|dst
argument_list|,
name|offset
operator|-
literal|4
argument_list|,
operator|(
name|opcode
operator|&
operator|~
name|SCR_NO_FLUSH
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x0
case|:
comment|/* 			**	MOVE (absolute address) 			*/
name|relocs
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|0x8
case|:
comment|/* 			**	JUMP / CALL 			**	dont't relocate if relative :-) 			*/
if|if
condition|(
name|opcode
operator|&
literal|0x00800000
condition|)
name|relocs
operator|=
literal|0
expr_stmt|;
else|else
name|relocs
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|0x4
case|:
case|case
literal|0x5
case|:
case|case
literal|0x6
case|:
case|case
literal|0x7
case|:
name|relocs
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
name|relocs
operator|=
literal|0
expr_stmt|;
break|break;
block|}
empty_stmt|;
if|if
condition|(
name|relocs
condition|)
block|{
while|while
condition|(
name|relocs
operator|--
condition|)
block|{
name|old
operator|=
operator|*
name|src
operator|++
expr_stmt|;
switch|switch
condition|(
name|old
operator|&
name|RELOC_MASK
condition|)
block|{
case|case
name|RELOC_REGISTER
case|:
name|new
operator|=
operator|(
name|old
operator|&
operator|~
name|RELOC_MASK
operator|)
operator|+
name|rman_get_start
argument_list|(
name|np
operator|->
name|reg_res
argument_list|)
expr_stmt|;
break|break;
case|case
name|RELOC_LABEL
case|:
name|new
operator|=
operator|(
name|old
operator|&
operator|~
name|RELOC_MASK
operator|)
operator|+
name|np
operator|->
name|p_script
expr_stmt|;
break|break;
case|case
name|RELOC_LABELH
case|:
name|new
operator|=
operator|(
name|old
operator|&
operator|~
name|RELOC_MASK
operator|)
operator|+
name|np
operator|->
name|p_scripth
expr_stmt|;
break|break;
case|case
name|RELOC_SOFTC
case|:
name|new
operator|=
operator|(
name|old
operator|&
operator|~
name|RELOC_MASK
operator|)
operator|+
name|vtophys
argument_list|(
name|np
argument_list|)
expr_stmt|;
break|break;
case|case
name|RELOC_KVAR
case|:
if|if
condition|(
operator|(
operator|(
name|old
operator|&
operator|~
name|RELOC_MASK
operator|)
operator|<
name|SCRIPT_KVAR_FIRST
operator|)
operator|||
operator|(
operator|(
name|old
operator|&
operator|~
name|RELOC_MASK
operator|)
operator|>
name|SCRIPT_KVAR_LAST
operator|)
condition|)
name|panic
argument_list|(
literal|"ncr KVAR out of range"
argument_list|)
expr_stmt|;
name|new
operator|=
name|vtophys
argument_list|(
name|script_kvars
index|[
name|old
operator|&
operator|~
name|RELOC_MASK
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0
case|:
comment|/* Don't relocate a 0 address. */
if|if
condition|(
name|old
operator|==
literal|0
condition|)
block|{
name|new
operator|=
name|old
expr_stmt|;
break|break;
block|}
comment|/* FALLTHROUGH */
default|default:
name|panic
argument_list|(
literal|"ncr_script_copy_and_bind: weird relocation %x @ %d\n"
argument_list|,
name|old
argument_list|,
call|(
name|int
call|)
argument_list|(
name|src
operator|-
name|start
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|WRITESCRIPT_OFF
argument_list|(
name|dst
argument_list|,
name|offset
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|offset
operator|+=
literal|4
expr_stmt|;
block|}
block|}
else|else
block|{
name|WRITESCRIPT_OFF
argument_list|(
name|dst
argument_list|,
name|offset
argument_list|,
operator|*
name|src
operator|++
argument_list|)
expr_stmt|;
name|offset
operator|+=
literal|4
expr_stmt|;
block|}
block|}
empty_stmt|;
block|}
end_function

begin_comment
comment|/*========================================================== ** ** **      Auto configuration. ** ** **========================================================== */
end_comment

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/*---------------------------------------------------------- ** **	Reduce the transfer length to the max value **	we can transfer safely. ** **      Reading a block greater then MAX_SIZE from the **	raw (character) device exercises a memory leak **	in the vm subsystem. This is common to ALL devices. **	We have submitted a description of this bug to **<FreeBSD-bugs@freefall.cdrom.com>. **	It should be fixed in the current release. ** **---------------------------------------------------------- */
end_comment

begin_endif
unit|void ncr_min_phys (struct  buf *bp) { 	if ((unsigned long)bp->b_bcount> MAX_SIZE) bp->b_bcount = MAX_SIZE; }
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/*---------------------------------------------------------- ** **	Maximal number of outstanding requests per target. ** **---------------------------------------------------------- */
end_comment

begin_comment
unit|u_int32_t ncr_info (int unit) { 	return (1);
comment|/* may be changed later */
end_comment

begin_endif
unit|}
endif|#
directive|endif
end_endif

begin_comment
comment|/*---------------------------------------------------------- ** **	NCR chip devices table and chip look up function. **	Features bit are defined in ncrreg.h. Is it the  **	right place? ** **---------------------------------------------------------- */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|unsigned
name|long
name|device_id
decl_stmt|;
name|unsigned
name|short
name|minrevid
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|unsigned
name|char
name|maxburst
decl_stmt|;
name|unsigned
name|char
name|maxoffs
decl_stmt|;
name|unsigned
name|char
name|clock_divn
decl_stmt|;
name|unsigned
name|int
name|features
decl_stmt|;
block|}
name|ncr_chip
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|ncr_chip
name|ncr_chip_table
index|[]
init|=
block|{
block|{
name|NCR_810_ID
block|,
literal|0x00
block|,
literal|"ncr 53c810 fast10 scsi"
block|,
literal|4
block|,
literal|8
block|,
literal|4
block|,
name|FE_ERL
block|}
block|,
block|{
name|NCR_810_ID
block|,
literal|0x10
block|,
literal|"ncr 53c810a fast10 scsi"
block|,
literal|4
block|,
literal|8
block|,
literal|4
block|,
name|FE_ERL
operator||
name|FE_LDSTR
operator||
name|FE_PFEN
operator||
name|FE_BOF
block|}
block|,
block|{
name|NCR_815_ID
block|,
literal|0x00
block|,
literal|"ncr 53c815 fast10 scsi"
block|,
literal|4
block|,
literal|8
block|,
literal|4
block|,
name|FE_ERL
operator||
name|FE_BOF
block|}
block|,
block|{
name|NCR_820_ID
block|,
literal|0x00
block|,
literal|"ncr 53c820 fast10 wide scsi"
block|,
literal|4
block|,
literal|8
block|,
literal|4
block|,
name|FE_WIDE
operator||
name|FE_ERL
block|}
block|,
block|{
name|NCR_825_ID
block|,
literal|0x00
block|,
literal|"ncr 53c825 fast10 wide scsi"
block|,
literal|4
block|,
literal|8
block|,
literal|4
block|,
name|FE_WIDE
operator||
name|FE_ERL
operator||
name|FE_BOF
block|}
block|,
block|{
name|NCR_825_ID
block|,
literal|0x10
block|,
literal|"ncr 53c825a fast10 wide scsi"
block|,
literal|7
block|,
literal|8
block|,
literal|4
block|,
name|FE_WIDE
operator||
name|FE_CACHE_SET
operator||
name|FE_DFS
operator||
name|FE_LDSTR
operator||
name|FE_PFEN
operator||
name|FE_RAM
block|}
block|,
block|{
name|NCR_860_ID
block|,
literal|0x00
block|,
literal|"ncr 53c860 fast20 scsi"
block|,
literal|4
block|,
literal|8
block|,
literal|5
block|,
name|FE_ULTRA
operator||
name|FE_CLK80
operator||
name|FE_CACHE_SET
operator||
name|FE_LDSTR
operator||
name|FE_PFEN
block|}
block|,
block|{
name|NCR_875_ID
block|,
literal|0x00
block|,
literal|"ncr 53c875 fast20 wide scsi"
block|,
literal|7
block|,
literal|16
block|,
literal|5
block|,
name|FE_WIDE
operator||
name|FE_ULTRA
operator||
name|FE_CLK80
operator||
name|FE_CACHE_SET
operator||
name|FE_DFS
operator||
name|FE_LDSTR
operator||
name|FE_PFEN
operator||
name|FE_RAM
block|}
block|,
block|{
name|NCR_875_ID
block|,
literal|0x02
block|,
literal|"ncr 53c875 fast20 wide scsi"
block|,
literal|7
block|,
literal|16
block|,
literal|5
block|,
name|FE_WIDE
operator||
name|FE_ULTRA
operator||
name|FE_DBLR
operator||
name|FE_CACHE_SET
operator||
name|FE_DFS
operator||
name|FE_LDSTR
operator||
name|FE_PFEN
operator||
name|FE_RAM
block|}
block|,
block|{
name|NCR_875_ID2
block|,
literal|0x00
block|,
literal|"ncr 53c875j fast20 wide scsi"
block|,
literal|7
block|,
literal|16
block|,
literal|5
block|,
name|FE_WIDE
operator||
name|FE_ULTRA
operator||
name|FE_DBLR
operator||
name|FE_CACHE_SET
operator||
name|FE_DFS
operator||
name|FE_LDSTR
operator||
name|FE_PFEN
operator||
name|FE_RAM
block|}
block|,
block|{
name|NCR_885_ID
block|,
literal|0x00
block|,
literal|"ncr 53c885 fast20 wide scsi"
block|,
literal|7
block|,
literal|16
block|,
literal|5
block|,
name|FE_WIDE
operator||
name|FE_ULTRA
operator||
name|FE_DBLR
operator||
name|FE_CACHE_SET
operator||
name|FE_DFS
operator||
name|FE_LDSTR
operator||
name|FE_PFEN
operator||
name|FE_RAM
block|}
block|,
block|{
name|NCR_895_ID
block|,
literal|0x00
block|,
literal|"ncr 53c895 fast40 wide scsi"
block|,
literal|7
block|,
literal|31
block|,
literal|7
block|,
name|FE_WIDE
operator||
name|FE_ULTRA2
operator||
name|FE_QUAD
operator||
name|FE_CACHE_SET
operator||
name|FE_DFS
operator||
name|FE_LDSTR
operator||
name|FE_PFEN
operator||
name|FE_RAM
block|}
block|,
block|{
name|NCR_896_ID
block|,
literal|0x00
block|,
literal|"ncr 53c896 fast40 wide scsi"
block|,
literal|7
block|,
literal|31
block|,
literal|7
block|,
name|FE_WIDE
operator||
name|FE_ULTRA2
operator||
name|FE_QUAD
operator||
name|FE_CACHE_SET
operator||
name|FE_DFS
operator||
name|FE_LDSTR
operator||
name|FE_PFEN
operator||
name|FE_RAM
block|}
block|,
block|{
name|NCR_895A_ID
block|,
literal|0x00
block|,
literal|"ncr 53c895a fast40 wide scsi"
block|,
literal|7
block|,
literal|31
block|,
literal|7
block|,
name|FE_WIDE
operator||
name|FE_ULTRA2
operator||
name|FE_QUAD
operator||
name|FE_CACHE_SET
operator||
name|FE_DFS
operator||
name|FE_LDSTR
operator||
name|FE_PFEN
operator||
name|FE_RAM
block|}
block|,
block|{
name|NCR_1510D_ID
block|,
literal|0x00
block|,
literal|"ncr 53c1510d fast40 wide scsi"
block|,
literal|7
block|,
literal|31
block|,
literal|7
block|,
name|FE_WIDE
operator||
name|FE_ULTRA2
operator||
name|FE_QUAD
operator||
name|FE_CACHE_SET
operator||
name|FE_DFS
operator||
name|FE_LDSTR
operator||
name|FE_PFEN
operator||
name|FE_RAM
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|ncr_chip_lookup
parameter_list|(
name|u_long
name|device_id
parameter_list|,
name|u_char
name|revision_id
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|found
decl_stmt|;
name|found
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|ncr_chip_table
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|ncr_chip_table
index|[
literal|0
index|]
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|device_id
operator|==
name|ncr_chip_table
index|[
name|i
index|]
operator|.
name|device_id
operator|&&
name|ncr_chip_table
index|[
name|i
index|]
operator|.
name|minrevid
operator|<=
name|revision_id
condition|)
block|{
if|if
condition|(
name|found
operator|<
literal|0
operator|||
name|ncr_chip_table
index|[
name|found
index|]
operator|.
name|minrevid
operator|<
name|ncr_chip_table
index|[
name|i
index|]
operator|.
name|minrevid
condition|)
block|{
name|found
operator|=
name|i
expr_stmt|;
block|}
block|}
block|}
return|return
name|found
return|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------- ** **	Probe the hostadapter. ** **---------------------------------------------------------- */
end_comment

begin_function
specifier|static
name|int
name|ncr_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|i
operator|=
name|ncr_chip_lookup
argument_list|(
name|pci_get_devid
argument_list|(
name|dev
argument_list|)
argument_list|,
name|pci_get_revid
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>=
literal|0
condition|)
block|{
name|device_set_desc
argument_list|(
name|dev
argument_list|,
name|ncr_chip_table
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|BUS_PROBE_DEFAULT
operator|)
return|;
block|}
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
end_function

begin_comment
comment|/*========================================================== ** **	NCR chip clock divisor table. **	Divisors are multiplied by 10,000,000 in order to make  **	calculations more simple. ** **========================================================== */
end_comment

begin_define
define|#
directive|define
name|_5M
value|5000000
end_define

begin_decl_stmt
specifier|static
name|u_long
name|div_10M
index|[]
init|=
block|{
literal|2
operator|*
name|_5M
block|,
literal|3
operator|*
name|_5M
block|,
literal|4
operator|*
name|_5M
block|,
literal|6
operator|*
name|_5M
block|,
literal|8
operator|*
name|_5M
block|,
literal|12
operator|*
name|_5M
block|,
literal|16
operator|*
name|_5M
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*=============================================================== ** **	NCR chips allow burst lengths of 2, 4, 8, 16, 32, 64, 128  **	transfers. 32,64,128 are only supported by 875 and 895 chips. **	We use log base 2 (burst length) as internal code, with  **	value 0 meaning "burst disabled". ** **=============================================================== */
end_comment

begin_comment
comment|/*  *	Burst length from burst code.  */
end_comment

begin_define
define|#
directive|define
name|burst_length
parameter_list|(
name|bc
parameter_list|)
value|(!(bc))? 0 : 1<< (bc)
end_define

begin_comment
comment|/*  *	Burst code from io register bits.  */
end_comment

begin_define
define|#
directive|define
name|burst_code
parameter_list|(
name|dmode
parameter_list|,
name|ctest4
parameter_list|,
name|ctest5
parameter_list|)
define|\
value|(ctest4)& 0x80? 0 : (((dmode)& 0xc0)>> 6) + ((ctest5)& 0x04) + 1
end_define

begin_comment
comment|/*  *	Set initial io register bits from burst code.  */
end_comment

begin_function
specifier|static
name|void
name|ncr_init_burst
parameter_list|(
name|ncb_p
name|np
parameter_list|,
name|u_char
name|bc
parameter_list|)
block|{
name|np
operator|->
name|rv_ctest4
operator|&=
operator|~
literal|0x80
expr_stmt|;
name|np
operator|->
name|rv_dmode
operator|&=
operator|~
operator|(
literal|0x3
operator|<<
literal|6
operator|)
expr_stmt|;
name|np
operator|->
name|rv_ctest5
operator|&=
operator|~
literal|0x4
expr_stmt|;
if|if
condition|(
operator|!
name|bc
condition|)
block|{
name|np
operator|->
name|rv_ctest4
operator||=
literal|0x80
expr_stmt|;
block|}
else|else
block|{
operator|--
name|bc
expr_stmt|;
name|np
operator|->
name|rv_dmode
operator||=
operator|(
operator|(
name|bc
operator|&
literal|0x3
operator|)
operator|<<
literal|6
operator|)
expr_stmt|;
name|np
operator|->
name|rv_ctest5
operator||=
operator|(
name|bc
operator|&
literal|0x4
operator|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*========================================================== ** ** **      Auto configuration:  attach and init a host adapter. ** ** **========================================================== */
end_comment

begin_function
specifier|static
name|int
name|ncr_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|ncb_p
name|np
init|=
operator|(
expr|struct
name|ncb
operator|*
operator|)
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|u_char
name|rev
init|=
literal|0
decl_stmt|;
name|u_long
name|period
decl_stmt|;
name|int
name|i
decl_stmt|,
name|rid
decl_stmt|;
name|u_int8_t
name|usrsync
decl_stmt|;
name|u_int8_t
name|usrwide
decl_stmt|;
name|struct
name|cam_devq
modifier|*
name|devq
decl_stmt|;
comment|/* 	**	allocate and initialize structures. 	*/
name|np
operator|->
name|unit
operator|=
name|device_get_unit
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* 	**	Try to map the controller chip to 	**	virtual and physical memory. 	*/
name|np
operator|->
name|reg_rid
operator|=
literal|0x14
expr_stmt|;
name|np
operator|->
name|reg_res
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
operator|&
name|np
operator|->
name|reg_rid
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|np
operator|->
name|reg_res
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"could not map memory\n"
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
comment|/* 	**	Make the controller's registers available. 	**	Now the INB INW INL OUTB OUTW OUTL macros 	**	can be used safely. 	*/
name|np
operator|->
name|bst
operator|=
name|rman_get_bustag
argument_list|(
name|np
operator|->
name|reg_res
argument_list|)
expr_stmt|;
name|np
operator|->
name|bsh
operator|=
name|rman_get_bushandle
argument_list|(
name|np
operator|->
name|reg_res
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|NCR_IOMAPPED
comment|/* 	**	Try to map the controller chip into iospace. 	*/
if|if
condition|(
operator|!
name|pci_map_port
argument_list|(
name|config_id
argument_list|,
literal|0x10
argument_list|,
operator|&
name|np
operator|->
name|port
argument_list|)
condition|)
return|return;
endif|#
directive|endif
comment|/* 	**	Save some controller register default values 	*/
name|np
operator|->
name|rv_scntl3
operator|=
name|INB
argument_list|(
name|nc_scntl3
argument_list|)
operator|&
literal|0x77
expr_stmt|;
name|np
operator|->
name|rv_dmode
operator|=
name|INB
argument_list|(
name|nc_dmode
argument_list|)
operator|&
literal|0xce
expr_stmt|;
name|np
operator|->
name|rv_dcntl
operator|=
name|INB
argument_list|(
name|nc_dcntl
argument_list|)
operator|&
literal|0xa9
expr_stmt|;
name|np
operator|->
name|rv_ctest3
operator|=
name|INB
argument_list|(
name|nc_ctest3
argument_list|)
operator|&
literal|0x01
expr_stmt|;
name|np
operator|->
name|rv_ctest4
operator|=
name|INB
argument_list|(
name|nc_ctest4
argument_list|)
operator|&
literal|0x88
expr_stmt|;
name|np
operator|->
name|rv_ctest5
operator|=
name|INB
argument_list|(
name|nc_ctest5
argument_list|)
operator|&
literal|0x24
expr_stmt|;
name|np
operator|->
name|rv_gpcntl
operator|=
name|INB
argument_list|(
name|nc_gpcntl
argument_list|)
expr_stmt|;
name|np
operator|->
name|rv_stest2
operator|=
name|INB
argument_list|(
name|nc_stest2
argument_list|)
operator|&
literal|0x20
expr_stmt|;
if|if
condition|(
name|bootverbose
operator|>=
literal|2
condition|)
block|{
name|printf
argument_list|(
literal|"\tBIOS values:  SCNTL3:%02x DMODE:%02x  DCNTL:%02x\n"
argument_list|,
name|np
operator|->
name|rv_scntl3
argument_list|,
name|np
operator|->
name|rv_dmode
argument_list|,
name|np
operator|->
name|rv_dcntl
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\t              CTEST3:%02x CTEST4:%02x CTEST5:%02x\n"
argument_list|,
name|np
operator|->
name|rv_ctest3
argument_list|,
name|np
operator|->
name|rv_ctest4
argument_list|,
name|np
operator|->
name|rv_ctest5
argument_list|)
expr_stmt|;
block|}
name|np
operator|->
name|rv_dcntl
operator||=
name|NOCOM
expr_stmt|;
comment|/* 	**	Do chip dependent initialization. 	*/
name|rev
operator|=
name|pci_get_revid
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* 	**	Get chip features from chips table. 	*/
name|i
operator|=
name|ncr_chip_lookup
argument_list|(
name|pci_get_devid
argument_list|(
name|dev
argument_list|)
argument_list|,
name|rev
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>=
literal|0
condition|)
block|{
name|np
operator|->
name|maxburst
operator|=
name|ncr_chip_table
index|[
name|i
index|]
operator|.
name|maxburst
expr_stmt|;
name|np
operator|->
name|maxoffs
operator|=
name|ncr_chip_table
index|[
name|i
index|]
operator|.
name|maxoffs
expr_stmt|;
name|np
operator|->
name|clock_divn
operator|=
name|ncr_chip_table
index|[
name|i
index|]
operator|.
name|clock_divn
expr_stmt|;
name|np
operator|->
name|features
operator|=
name|ncr_chip_table
index|[
name|i
index|]
operator|.
name|features
expr_stmt|;
block|}
else|else
block|{
comment|/* Should'nt happen if probe() is ok */
name|np
operator|->
name|maxburst
operator|=
literal|4
expr_stmt|;
name|np
operator|->
name|maxoffs
operator|=
literal|8
expr_stmt|;
name|np
operator|->
name|clock_divn
operator|=
literal|4
expr_stmt|;
name|np
operator|->
name|features
operator|=
name|FE_ERL
expr_stmt|;
block|}
name|np
operator|->
name|maxwide
operator|=
name|np
operator|->
name|features
operator|&
name|FE_WIDE
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|np
operator|->
name|clock_khz
operator|=
name|np
operator|->
name|features
operator|&
name|FE_CLK80
condition|?
literal|80000
else|:
literal|40000
expr_stmt|;
if|if
condition|(
name|np
operator|->
name|features
operator|&
name|FE_QUAD
condition|)
name|np
operator|->
name|multiplier
operator|=
literal|4
expr_stmt|;
elseif|else
if|if
condition|(
name|np
operator|->
name|features
operator|&
name|FE_DBLR
condition|)
name|np
operator|->
name|multiplier
operator|=
literal|2
expr_stmt|;
else|else
name|np
operator|->
name|multiplier
operator|=
literal|1
expr_stmt|;
comment|/* 	**	Get the frequency of the chip's clock. 	**	Find the right value for scntl3. 	*/
if|if
condition|(
name|np
operator|->
name|features
operator|&
operator|(
name|FE_ULTRA
operator||
name|FE_ULTRA2
operator|)
condition|)
name|ncr_getclock
argument_list|(
name|np
argument_list|,
name|np
operator|->
name|multiplier
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|NCR_TEKRAM_EEPROM
if|if
condition|(
name|bootverbose
condition|)
block|{
name|printf
argument_list|(
literal|"%s: Tekram EEPROM read %s\n"
argument_list|,
name|ncr_name
argument_list|(
name|np
argument_list|)
argument_list|,
name|read_tekram_eeprom
argument_list|(
name|np
argument_list|,
name|NULL
argument_list|)
condition|?
literal|"succeeded"
else|:
literal|"failed"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* NCR_TEKRAM_EEPROM */
comment|/* 	 *	If scntl3 != 0, we assume BIOS is present. 	 */
if|if
condition|(
name|np
operator|->
name|rv_scntl3
condition|)
name|np
operator|->
name|features
operator||=
name|FE_BIOS
expr_stmt|;
comment|/* 	 * Divisor to be used for async (timer pre-scaler). 	 */
name|i
operator|=
name|np
operator|->
name|clock_divn
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|i
operator|>=
literal|0
condition|)
block|{
operator|--
name|i
expr_stmt|;
if|if
condition|(
literal|10ul
operator|*
name|SCSI_NCR_MIN_ASYNC
operator|*
name|np
operator|->
name|clock_khz
operator|>
name|div_10M
index|[
name|i
index|]
condition|)
block|{
operator|++
name|i
expr_stmt|;
break|break;
block|}
block|}
name|np
operator|->
name|rv_scntl3
operator|=
name|i
operator|+
literal|1
expr_stmt|;
comment|/* 	 * Minimum synchronous period factor supported by the chip. 	 * Btw, 'period' is in tenths of nanoseconds. 	 */
name|period
operator|=
operator|(
literal|4
operator|*
name|div_10M
index|[
literal|0
index|]
operator|+
name|np
operator|->
name|clock_khz
operator|-
literal|1
operator|)
operator|/
name|np
operator|->
name|clock_khz
expr_stmt|;
if|if
condition|(
name|period
operator|<=
literal|250
condition|)
name|np
operator|->
name|minsync
operator|=
literal|10
expr_stmt|;
elseif|else
if|if
condition|(
name|period
operator|<=
literal|303
condition|)
name|np
operator|->
name|minsync
operator|=
literal|11
expr_stmt|;
elseif|else
if|if
condition|(
name|period
operator|<=
literal|500
condition|)
name|np
operator|->
name|minsync
operator|=
literal|12
expr_stmt|;
else|else
name|np
operator|->
name|minsync
operator|=
operator|(
name|period
operator|+
literal|40
operator|-
literal|1
operator|)
operator|/
literal|40
expr_stmt|;
comment|/* 	 * Check against chip SCSI standard support (SCSI-2,ULTRA,ULTRA2). 	 */
if|if
condition|(
name|np
operator|->
name|minsync
operator|<
literal|25
operator|&&
operator|!
operator|(
name|np
operator|->
name|features
operator|&
operator|(
name|FE_ULTRA
operator||
name|FE_ULTRA2
operator|)
operator|)
condition|)
name|np
operator|->
name|minsync
operator|=
literal|25
expr_stmt|;
elseif|else
if|if
condition|(
name|np
operator|->
name|minsync
operator|<
literal|12
operator|&&
operator|!
operator|(
name|np
operator|->
name|features
operator|&
name|FE_ULTRA2
operator|)
condition|)
name|np
operator|->
name|minsync
operator|=
literal|12
expr_stmt|;
comment|/* 	 * Maximum synchronous period factor supported by the chip. 	 */
name|period
operator|=
operator|(
literal|11
operator|*
name|div_10M
index|[
name|np
operator|->
name|clock_divn
operator|-
literal|1
index|]
operator|)
operator|/
operator|(
literal|4
operator|*
name|np
operator|->
name|clock_khz
operator|)
expr_stmt|;
name|np
operator|->
name|maxsync
operator|=
name|period
operator|>
literal|2540
condition|?
literal|254
else|:
name|period
operator|/
literal|10
expr_stmt|;
comment|/* 	 * Now, some features available with Symbios compatible boards. 	 * LED support through GPIO0 and DIFF support. 	 */
ifdef|#
directive|ifdef
name|SCSI_NCR_SYMBIOS_COMPAT
if|if
condition|(
operator|!
operator|(
name|np
operator|->
name|rv_gpcntl
operator|&
literal|0x01
operator|)
condition|)
name|np
operator|->
name|features
operator||=
name|FE_LED0
expr_stmt|;
if|#
directive|if
literal|0
comment|/* Not safe enough without NVRAM support or user settable option */
block|if (!(INB(nc_gpreg)& 0x08)) 		np->features |= FE_DIFF;
endif|#
directive|endif
endif|#
directive|endif
comment|/* SCSI_NCR_SYMBIOS_COMPAT */
comment|/* 	 * Prepare initial IO registers settings. 	 * Trust BIOS only if we believe we have one and if we want to. 	 */
ifdef|#
directive|ifdef
name|SCSI_NCR_TRUST_BIOS
if|if
condition|(
operator|!
operator|(
name|np
operator|->
name|features
operator|&
name|FE_BIOS
operator|)
condition|)
block|{
else|#
directive|else
if|if
condition|(
literal|1
condition|)
block|{
endif|#
directive|endif
name|np
operator|->
name|rv_dmode
operator|=
literal|0
expr_stmt|;
name|np
operator|->
name|rv_dcntl
operator|=
name|NOCOM
expr_stmt|;
name|np
operator|->
name|rv_ctest3
operator|=
literal|0
expr_stmt|;
name|np
operator|->
name|rv_ctest4
operator|=
name|MPEE
expr_stmt|;
name|np
operator|->
name|rv_ctest5
operator|=
literal|0
expr_stmt|;
name|np
operator|->
name|rv_stest2
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|np
operator|->
name|features
operator|&
name|FE_ERL
condition|)
name|np
operator|->
name|rv_dmode
operator||=
name|ERL
expr_stmt|;
comment|/* Enable Read Line */
if|if
condition|(
name|np
operator|->
name|features
operator|&
name|FE_BOF
condition|)
name|np
operator|->
name|rv_dmode
operator||=
name|BOF
expr_stmt|;
comment|/* Burst Opcode Fetch */
if|if
condition|(
name|np
operator|->
name|features
operator|&
name|FE_ERMP
condition|)
name|np
operator|->
name|rv_dmode
operator||=
name|ERMP
expr_stmt|;
comment|/* Enable Read Multiple */
if|if
condition|(
name|np
operator|->
name|features
operator|&
name|FE_CLSE
condition|)
name|np
operator|->
name|rv_dcntl
operator||=
name|CLSE
expr_stmt|;
comment|/* Cache Line Size Enable */
if|if
condition|(
name|np
operator|->
name|features
operator|&
name|FE_WRIE
condition|)
name|np
operator|->
name|rv_ctest3
operator||=
name|WRIE
expr_stmt|;
comment|/* Write and Invalidate */
if|if
condition|(
name|np
operator|->
name|features
operator|&
name|FE_PFEN
condition|)
name|np
operator|->
name|rv_dcntl
operator||=
name|PFEN
expr_stmt|;
comment|/* Prefetch Enable */
if|if
condition|(
name|np
operator|->
name|features
operator|&
name|FE_DFS
condition|)
name|np
operator|->
name|rv_ctest5
operator||=
name|DFS
expr_stmt|;
comment|/* Dma Fifo Size */
if|if
condition|(
name|np
operator|->
name|features
operator|&
name|FE_DIFF
condition|)
name|np
operator|->
name|rv_stest2
operator||=
literal|0x20
expr_stmt|;
comment|/* Differential mode */
name|ncr_init_burst
argument_list|(
name|np
argument_list|,
name|np
operator|->
name|maxburst
argument_list|)
expr_stmt|;
comment|/* Max dwords burst length */
block|}
else|else
block|{
name|np
operator|->
name|maxburst
operator|=
name|burst_code
argument_list|(
name|np
operator|->
name|rv_dmode
argument_list|,
name|np
operator|->
name|rv_ctest4
argument_list|,
name|np
operator|->
name|rv_ctest5
argument_list|)
expr_stmt|;
block|}
comment|/* 	**	Get on-chip SRAM address, if supported 	*/
if|if
condition|(
operator|(
name|np
operator|->
name|features
operator|&
name|FE_RAM
operator|)
operator|&&
sizeof|sizeof
argument_list|(
expr|struct
name|script
argument_list|)
operator|<=
literal|4096
condition|)
block|{
name|np
operator|->
name|sram_rid
operator|=
literal|0x18
expr_stmt|;
name|np
operator|->
name|sram_res
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
operator|&
name|np
operator|->
name|sram_rid
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
block|}
comment|/* 	**	Allocate structure for script relocation. 	*/
if|if
condition|(
name|np
operator|->
name|sram_res
operator|!=
name|NULL
condition|)
block|{
name|np
operator|->
name|script
operator|=
name|NULL
expr_stmt|;
name|np
operator|->
name|p_script
operator|=
name|rman_get_start
argument_list|(
name|np
operator|->
name|sram_res
argument_list|)
expr_stmt|;
name|np
operator|->
name|bst2
operator|=
name|rman_get_bustag
argument_list|(
name|np
operator|->
name|sram_res
argument_list|)
expr_stmt|;
name|np
operator|->
name|bsh2
operator|=
name|rman_get_bushandle
argument_list|(
name|np
operator|->
name|sram_res
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
sizeof|sizeof
argument_list|(
expr|struct
name|script
argument_list|)
operator|>
name|PAGE_SIZE
condition|)
block|{
name|np
operator|->
name|script
operator|=
operator|(
expr|struct
name|script
operator|*
operator|)
name|contigmalloc
argument_list|(
name|round_page
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|script
argument_list|)
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
argument_list|,
literal|0
argument_list|,
literal|0xffffffff
argument_list|,
name|PAGE_SIZE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|np
operator|->
name|script
operator|=
operator|(
expr|struct
name|script
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|script
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
sizeof|sizeof
argument_list|(
expr|struct
name|scripth
argument_list|)
operator|>
name|PAGE_SIZE
condition|)
block|{
name|np
operator|->
name|scripth
operator|=
operator|(
expr|struct
name|scripth
operator|*
operator|)
name|contigmalloc
argument_list|(
name|round_page
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|scripth
argument_list|)
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
argument_list|,
literal|0
argument_list|,
literal|0xffffffff
argument_list|,
name|PAGE_SIZE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|np
operator|->
name|scripth
operator|=
operator|(
expr|struct
name|scripth
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|scripth
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|SCSI_NCR_PCI_CONFIG_FIXUP
comment|/* 	**	If cache line size is enabled, check PCI config space and  	**	try to fix it up if necessary. 	*/
ifdef|#
directive|ifdef
name|PCIR_CACHELNSZ
comment|/* To be sure that new PCI stuff is present */
block|{
name|u_char
name|cachelnsz
init|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_CACHELNSZ
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|u_short
name|command
init|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_COMMAND
argument_list|,
literal|2
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|cachelnsz
condition|)
block|{
name|cachelnsz
operator|=
literal|8
expr_stmt|;
name|printf
argument_list|(
literal|"%s: setting PCI cache line size register to %d.\n"
argument_list|,
name|ncr_name
argument_list|(
name|np
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|cachelnsz
argument_list|)
expr_stmt|;
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|PCIR_CACHELNSZ
argument_list|,
name|cachelnsz
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|command
operator|&
operator|(
literal|1
operator|<<
literal|4
operator|)
operator|)
condition|)
block|{
name|command
operator||=
operator|(
literal|1
operator|<<
literal|4
operator|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s: setting PCI command write and invalidate.\n"
argument_list|,
name|ncr_name
argument_list|(
name|np
argument_list|)
argument_list|)
expr_stmt|;
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|PCIR_COMMAND
argument_list|,
name|command
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* PCIR_CACHELNSZ */
endif|#
directive|endif
comment|/* SCSI_NCR_PCI_CONFIG_FIXUP */
comment|/* Initialize per-target user settings */
name|usrsync
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|SCSI_NCR_DFLT_SYNC
condition|)
block|{
name|usrsync
operator|=
name|SCSI_NCR_DFLT_SYNC
expr_stmt|;
if|if
condition|(
name|usrsync
operator|>
name|np
operator|->
name|maxsync
condition|)
name|usrsync
operator|=
name|np
operator|->
name|maxsync
expr_stmt|;
if|if
condition|(
name|usrsync
operator|<
name|np
operator|->
name|minsync
condition|)
name|usrsync
operator|=
name|np
operator|->
name|minsync
expr_stmt|;
block|}
empty_stmt|;
name|usrwide
operator|=
operator|(
name|SCSI_NCR_MAX_WIDE
operator|)
expr_stmt|;
if|if
condition|(
name|usrwide
operator|>
name|np
operator|->
name|maxwide
condition|)
name|usrwide
operator|=
name|np
operator|->
name|maxwide
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_TARGET
condition|;
name|i
operator|++
control|)
block|{
name|tcb_p
name|tp
init|=
operator|&
name|np
operator|->
name|target
index|[
name|i
index|]
decl_stmt|;
name|tp
operator|->
name|tinfo
operator|.
name|user
operator|.
name|period
operator|=
name|usrsync
expr_stmt|;
name|tp
operator|->
name|tinfo
operator|.
name|user
operator|.
name|offset
operator|=
name|usrsync
operator|!=
literal|0
condition|?
name|np
operator|->
name|maxoffs
else|:
literal|0
expr_stmt|;
name|tp
operator|->
name|tinfo
operator|.
name|user
operator|.
name|width
operator|=
name|usrwide
expr_stmt|;
name|tp
operator|->
name|tinfo
operator|.
name|disc_tag
operator|=
name|NCR_CUR_DISCENB
operator||
name|NCR_CUR_TAGENB
operator||
name|NCR_USR_DISCENB
operator||
name|NCR_USR_TAGENB
expr_stmt|;
block|}
comment|/* 	**	Bells and whistles   ;-) 	*/
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"%s: minsync=%d, maxsync=%d, maxoffs=%d, %d dwords burst, %s dma fifo\n"
argument_list|,
name|ncr_name
argument_list|(
name|np
argument_list|)
argument_list|,
name|np
operator|->
name|minsync
argument_list|,
name|np
operator|->
name|maxsync
argument_list|,
name|np
operator|->
name|maxoffs
argument_list|,
name|burst_length
argument_list|(
name|np
operator|->
name|maxburst
argument_list|)
argument_list|,
operator|(
name|np
operator|->
name|rv_ctest5
operator|&
name|DFS
operator|)
condition|?
literal|"large"
else|:
literal|"normal"
argument_list|)
expr_stmt|;
comment|/* 	**	Print some complementary information that can be helpfull. 	*/
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"%s: %s, %s IRQ driver%s\n"
argument_list|,
name|ncr_name
argument_list|(
name|np
argument_list|)
argument_list|,
name|np
operator|->
name|rv_stest2
operator|&
literal|0x20
condition|?
literal|"differential"
else|:
literal|"single-ended"
argument_list|,
name|np
operator|->
name|rv_dcntl
operator|&
name|IRQM
condition|?
literal|"totem pole"
else|:
literal|"open drain"
argument_list|,
name|np
operator|->
name|sram_res
condition|?
literal|", using on-chip SRAM"
else|:
literal|""
argument_list|)
expr_stmt|;
comment|/* 	**	Patch scripts to physical addresses 	*/
name|ncr_script_fill
argument_list|(
operator|&
name|script0
argument_list|,
operator|&
name|scripth0
argument_list|)
expr_stmt|;
if|if
condition|(
name|np
operator|->
name|script
condition|)
name|np
operator|->
name|p_script
operator|=
name|vtophys
argument_list|(
name|np
operator|->
name|script
argument_list|)
expr_stmt|;
name|np
operator|->
name|p_scripth
operator|=
name|vtophys
argument_list|(
name|np
operator|->
name|scripth
argument_list|)
expr_stmt|;
name|ncr_script_copy_and_bind
argument_list|(
name|np
argument_list|,
operator|(
name|ncrcmd
operator|*
operator|)
operator|&
name|script0
argument_list|,
operator|(
name|ncrcmd
operator|*
operator|)
name|np
operator|->
name|script
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|script
argument_list|)
argument_list|)
expr_stmt|;
name|ncr_script_copy_and_bind
argument_list|(
name|np
argument_list|,
operator|(
name|ncrcmd
operator|*
operator|)
operator|&
name|scripth0
argument_list|,
operator|(
name|ncrcmd
operator|*
operator|)
name|np
operator|->
name|scripth
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|scripth
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	**    Patch the script for LED support. 	*/
if|if
condition|(
name|np
operator|->
name|features
operator|&
name|FE_LED0
condition|)
block|{
name|WRITESCRIPT
argument_list|(
name|reselect
index|[
literal|0
index|]
argument_list|,
name|SCR_REG_REG
argument_list|(
name|gpreg
argument_list|,
name|SCR_OR
argument_list|,
literal|0x01
argument_list|)
argument_list|)
expr_stmt|;
name|WRITESCRIPT
argument_list|(
name|reselect1
index|[
literal|0
index|]
argument_list|,
name|SCR_REG_REG
argument_list|(
name|gpreg
argument_list|,
name|SCR_AND
argument_list|,
literal|0xfe
argument_list|)
argument_list|)
expr_stmt|;
name|WRITESCRIPT
argument_list|(
name|reselect2
index|[
literal|0
index|]
argument_list|,
name|SCR_REG_REG
argument_list|(
name|gpreg
argument_list|,
name|SCR_AND
argument_list|,
literal|0xfe
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* 	**	init data structure 	*/
name|np
operator|->
name|jump_tcb
operator|.
name|l_cmd
operator|=
name|SCR_JUMP
expr_stmt|;
name|np
operator|->
name|jump_tcb
operator|.
name|l_paddr
operator|=
name|NCB_SCRIPTH_PHYS
argument_list|(
name|np
argument_list|,
name|abort
argument_list|)
expr_stmt|;
comment|/* 	**  Get SCSI addr of host adapter (set by bios?). 	*/
name|np
operator|->
name|myaddr
operator|=
name|INB
argument_list|(
name|nc_scid
argument_list|)
operator|&
literal|0x07
expr_stmt|;
if|if
condition|(
operator|!
name|np
operator|->
name|myaddr
condition|)
name|np
operator|->
name|myaddr
operator|=
name|SCSI_NCR_MYADDR
expr_stmt|;
ifdef|#
directive|ifdef
name|NCR_DUMP_REG
comment|/* 	**	Log the initial register contents 	*/
block|{
name|int
name|reg
decl_stmt|;
for|for
control|(
name|reg
operator|=
literal|0
init|;
name|reg
operator|<
literal|256
condition|;
name|reg
operator|+=
literal|4
control|)
block|{
if|if
condition|(
name|reg
operator|%
literal|16
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"reg[%2x]"
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" %08x"
argument_list|,
operator|(
name|int
operator|)
name|pci_conf_read
argument_list|(
name|config_id
argument_list|,
name|reg
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg
operator|%
literal|16
operator|==
literal|12
condition|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* NCR_DUMP_REG */
comment|/* 	**	Reset chip. 	*/
name|OUTB
argument_list|(
name|nc_istat
argument_list|,
name|SRST
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
name|nc_istat
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	**	Now check the cache handling of the pci chipset. 	*/
if|if
condition|(
name|ncr_snooptest
argument_list|(
name|np
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"CACHE INCORRECTLY CONFIGURED.\n"
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
empty_stmt|;
comment|/* 	**	Install the interrupt handler. 	*/
name|rid
operator|=
literal|0
expr_stmt|;
name|np
operator|->
name|irq_res
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|rid
argument_list|,
name|RF_SHAREABLE
operator||
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|np
operator|->
name|irq_res
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"interruptless mode: reduced performance.\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bus_setup_intr
argument_list|(
name|dev
argument_list|,
name|np
operator|->
name|irq_res
argument_list|,
name|INTR_TYPE_CAM
operator||
name|INTR_ENTROPY
argument_list|,
name|NULL
argument_list|,
name|ncr_intr
argument_list|,
name|np
argument_list|,
operator|&
name|np
operator|->
name|irq_handle
argument_list|)
expr_stmt|;
block|}
comment|/* 	** Create the device queue.  We only allow MAX_START-1 concurrent 	** transactions so we can be sure to have one element free in our 	** start queue to reset to the idle loop. 	*/
name|devq
operator|=
name|cam_simq_alloc
argument_list|(
name|MAX_START
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|devq
operator|==
name|NULL
condition|)
return|return
name|ENOMEM
return|;
comment|/* 	**	Now tell the generic SCSI layer 	**	about our bus. 	*/
name|np
operator|->
name|sim
operator|=
name|cam_sim_alloc
argument_list|(
name|ncr_action
argument_list|,
name|ncr_poll
argument_list|,
literal|"ncr"
argument_list|,
name|np
argument_list|,
name|np
operator|->
name|unit
argument_list|,
operator|&
name|Giant
argument_list|,
literal|1
argument_list|,
name|MAX_TAGS
argument_list|,
name|devq
argument_list|)
expr_stmt|;
if|if
condition|(
name|np
operator|->
name|sim
operator|==
name|NULL
condition|)
block|{
name|cam_simq_free
argument_list|(
name|devq
argument_list|)
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
if|if
condition|(
name|xpt_bus_register
argument_list|(
name|np
operator|->
name|sim
argument_list|,
literal|0
argument_list|)
operator|!=
name|CAM_SUCCESS
condition|)
block|{
name|cam_sim_free
argument_list|(
name|np
operator|->
name|sim
argument_list|,
comment|/*free_devq*/
name|TRUE
argument_list|)
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
if|if
condition|(
name|xpt_create_path
argument_list|(
operator|&
name|np
operator|->
name|path
argument_list|,
comment|/*periph*/
name|NULL
argument_list|,
name|cam_sim_path
argument_list|(
name|np
operator|->
name|sim
argument_list|)
argument_list|,
name|CAM_TARGET_WILDCARD
argument_list|,
name|CAM_LUN_WILDCARD
argument_list|)
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|xpt_bus_deregister
argument_list|(
name|cam_sim_path
argument_list|(
name|np
operator|->
name|sim
argument_list|)
argument_list|)
expr_stmt|;
name|cam_sim_free
argument_list|(
name|np
operator|->
name|sim
argument_list|,
comment|/*free_devq*/
name|TRUE
argument_list|)
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
comment|/* 	**	start the timeout daemon 	*/
name|ncr_timeout
argument_list|(
name|np
argument_list|)
expr_stmt|;
name|np
operator|->
name|lasttime
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/*========================================================== ** ** **	Process pending device interrupts. ** ** **========================================================== */
specifier|static
name|void
name|ncr_intr
parameter_list|(
name|vnp
parameter_list|)
name|void
modifier|*
name|vnp
decl_stmt|;
block|{
name|ncb_p
name|np
init|=
name|vnp
decl_stmt|;
name|int
name|oldspl
init|=
name|splcam
argument_list|()
decl_stmt|;
if|if
condition|(
name|DEBUG_FLAGS
operator|&
name|DEBUG_TINY
condition|)
name|printf
argument_list|(
literal|"["
argument_list|)
expr_stmt|;
if|if
condition|(
name|INB
argument_list|(
name|nc_istat
argument_list|)
operator|&
operator|(
name|INTF
operator||
name|SIP
operator||
name|DIP
operator|)
condition|)
block|{
comment|/* 		**	Repeat until no outstanding ints 		*/
do|do
block|{
name|ncr_exception
argument_list|(
name|np
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|INB
argument_list|(
name|nc_istat
argument_list|)
operator|&
operator|(
name|INTF
operator||
name|SIP
operator||
name|DIP
operator|)
condition|)
do|;
name|np
operator|->
name|ticks
operator|=
literal|100
expr_stmt|;
block|}
empty_stmt|;
if|if
condition|(
name|DEBUG_FLAGS
operator|&
name|DEBUG_TINY
condition|)
name|printf
argument_list|(
literal|"]\n"
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|oldspl
argument_list|)
expr_stmt|;
block|}
comment|/*========================================================== ** ** **	Start execution of a SCSI command. **	This is called from the generic SCSI driver. ** ** **========================================================== */
specifier|static
name|void
name|ncr_action
parameter_list|(
name|struct
name|cam_sim
modifier|*
name|sim
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
block|{
name|ncb_p
name|np
decl_stmt|;
name|np
operator|=
operator|(
name|ncb_p
operator|)
name|cam_sim_softc
argument_list|(
name|sim
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
condition|)
block|{
comment|/* Common cases first */
case|case
name|XPT_SCSI_IO
case|:
comment|/* Execute the requested I/O operation */
block|{
name|nccb_p
name|cp
decl_stmt|;
name|lcb_p
name|lp
decl_stmt|;
name|tcb_p
name|tp
decl_stmt|;
name|int
name|oldspl
decl_stmt|;
name|struct
name|ccb_scsiio
modifier|*
name|csio
decl_stmt|;
name|u_int8_t
modifier|*
name|msgptr
decl_stmt|;
name|u_int
name|msglen
decl_stmt|;
name|u_int
name|msglen2
decl_stmt|;
name|int
name|segments
decl_stmt|;
name|u_int8_t
name|nego
decl_stmt|;
name|u_int8_t
name|idmsg
decl_stmt|;
name|int
name|qidx
decl_stmt|;
name|tp
operator|=
operator|&
name|np
operator|->
name|target
index|[
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
index|]
expr_stmt|;
name|csio
operator|=
operator|&
name|ccb
operator|->
name|csio
expr_stmt|;
name|oldspl
operator|=
name|splcam
argument_list|()
expr_stmt|;
comment|/* 		 * Last time we need to check if this CCB needs to 		 * be aborted. 		 */
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
operator|)
operator|!=
name|CAM_REQ_INPROG
condition|)
block|{
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|oldspl
argument_list|)
expr_stmt|;
return|return;
block|}
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_SIM_QUEUED
expr_stmt|;
comment|/*--------------------------------------------------- 		** 		**	Assign an nccb / bind ccb 		** 		**---------------------------------------------------- 		*/
name|cp
operator|=
name|ncr_get_nccb
argument_list|(
name|np
argument_list|,
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
argument_list|,
name|ccb
operator|->
name|ccb_h
operator|.
name|target_lun
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
block|{
comment|/* XXX JGibbs - Freeze SIMQ */
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_RESRC_UNAVAIL
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return;
block|}
empty_stmt|;
name|cp
operator|->
name|ccb
operator|=
name|ccb
expr_stmt|;
comment|/*--------------------------------------------------- 		** 		**	timestamp 		** 		**---------------------------------------------------- 		*/
comment|/* 		** XXX JGibbs - Isn't this expensive 		**		enough to be conditionalized?? 		*/
name|bzero
argument_list|(
operator|&
name|cp
operator|->
name|phys
operator|.
name|header
operator|.
name|stamp
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|tstamp
argument_list|)
argument_list|)
expr_stmt|;
name|cp
operator|->
name|phys
operator|.
name|header
operator|.
name|stamp
operator|.
name|start
operator|=
name|ticks
expr_stmt|;
name|nego
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|nego_cp
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|tp
operator|->
name|tinfo
operator|.
name|current
operator|.
name|width
operator|!=
name|tp
operator|->
name|tinfo
operator|.
name|goal
operator|.
name|width
condition|)
block|{
name|tp
operator|->
name|nego_cp
operator|=
name|cp
expr_stmt|;
name|nego
operator|=
name|NS_WIDE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|tp
operator|->
name|tinfo
operator|.
name|current
operator|.
name|period
operator|!=
name|tp
operator|->
name|tinfo
operator|.
name|goal
operator|.
name|period
operator|)
operator|||
operator|(
name|tp
operator|->
name|tinfo
operator|.
name|current
operator|.
name|offset
operator|!=
name|tp
operator|->
name|tinfo
operator|.
name|goal
operator|.
name|offset
operator|)
condition|)
block|{
name|tp
operator|->
name|nego_cp
operator|=
name|cp
expr_stmt|;
name|nego
operator|=
name|NS_SYNC
expr_stmt|;
block|}
empty_stmt|;
block|}
empty_stmt|;
comment|/*--------------------------------------------------- 		** 		**	choose a new tag ... 		** 		**---------------------------------------------------- 		*/
name|lp
operator|=
name|tp
operator|->
name|lp
index|[
name|ccb
operator|->
name|ccb_h
operator|.
name|target_lun
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_TAG_ACTION_VALID
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|ccb
operator|->
name|csio
operator|.
name|tag_action
operator|!=
name|CAM_TAG_ACTION_NONE
operator|)
operator|&&
operator|(
name|nego
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* 			**	assign a tag to this nccb 			*/
while|while
condition|(
operator|!
name|cp
operator|->
name|tag
condition|)
block|{
name|nccb_p
name|cp2
init|=
name|lp
operator|->
name|next_nccb
decl_stmt|;
name|lp
operator|->
name|lasttag
operator|=
name|lp
operator|->
name|lasttag
operator|%
literal|255
operator|+
literal|1
expr_stmt|;
while|while
condition|(
name|cp2
operator|&&
name|cp2
operator|->
name|tag
operator|!=
name|lp
operator|->
name|lasttag
condition|)
name|cp2
operator|=
name|cp2
operator|->
name|next_nccb
expr_stmt|;
if|if
condition|(
name|cp2
condition|)
continue|continue;
name|cp
operator|->
name|tag
operator|=
name|lp
operator|->
name|lasttag
expr_stmt|;
if|if
condition|(
name|DEBUG_FLAGS
operator|&
name|DEBUG_TAGS
condition|)
block|{
name|PRINT_ADDR
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"using tag #%d.\n"
argument_list|,
name|cp
operator|->
name|tag
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
block|}
empty_stmt|;
block|}
else|else
block|{
name|cp
operator|->
name|tag
operator|=
literal|0
expr_stmt|;
block|}
empty_stmt|;
comment|/*---------------------------------------------------- 		** 		**	Build the identify / tag / sdtr message 		** 		**---------------------------------------------------- 		*/
name|idmsg
operator|=
name|MSG_IDENTIFYFLAG
operator||
name|ccb
operator|->
name|ccb_h
operator|.
name|target_lun
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|tinfo
operator|.
name|disc_tag
operator|&
name|NCR_CUR_DISCENB
condition|)
name|idmsg
operator||=
name|MSG_IDENTIFY_DISCFLAG
expr_stmt|;
name|msgptr
operator|=
name|cp
operator|->
name|scsi_smsg
expr_stmt|;
name|msglen
operator|=
literal|0
expr_stmt|;
name|msgptr
index|[
name|msglen
operator|++
index|]
operator|=
name|idmsg
expr_stmt|;
if|if
condition|(
name|cp
operator|->
name|tag
condition|)
block|{
name|msgptr
index|[
name|msglen
operator|++
index|]
operator|=
name|ccb
operator|->
name|csio
operator|.
name|tag_action
expr_stmt|;
name|msgptr
index|[
name|msglen
operator|++
index|]
operator|=
name|cp
operator|->
name|tag
expr_stmt|;
block|}
switch|switch
condition|(
name|nego
condition|)
block|{
case|case
name|NS_SYNC
case|:
name|msgptr
index|[
name|msglen
operator|++
index|]
operator|=
name|MSG_EXTENDED
expr_stmt|;
name|msgptr
index|[
name|msglen
operator|++
index|]
operator|=
name|MSG_EXT_SDTR_LEN
expr_stmt|;
name|msgptr
index|[
name|msglen
operator|++
index|]
operator|=
name|MSG_EXT_SDTR
expr_stmt|;
name|msgptr
index|[
name|msglen
operator|++
index|]
operator|=
name|tp
operator|->
name|tinfo
operator|.
name|goal
operator|.
name|period
expr_stmt|;
name|msgptr
index|[
name|msglen
operator|++
index|]
operator|=
name|tp
operator|->
name|tinfo
operator|.
name|goal
operator|.
name|offset
expr_stmt|;
empty_stmt|;
if|if
condition|(
name|DEBUG_FLAGS
operator|&
name|DEBUG_NEGO
condition|)
block|{
name|PRINT_ADDR
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"sync msgout: "
argument_list|)
expr_stmt|;
name|ncr_show_msg
argument_list|(
operator|&
name|cp
operator|->
name|scsi_smsg
index|[
name|msglen
operator|-
literal|5
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|".\n"
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
break|break;
case|case
name|NS_WIDE
case|:
name|msgptr
index|[
name|msglen
operator|++
index|]
operator|=
name|MSG_EXTENDED
expr_stmt|;
name|msgptr
index|[
name|msglen
operator|++
index|]
operator|=
name|MSG_EXT_WDTR_LEN
expr_stmt|;
name|msgptr
index|[
name|msglen
operator|++
index|]
operator|=
name|MSG_EXT_WDTR
expr_stmt|;
name|msgptr
index|[
name|msglen
operator|++
index|]
operator|=
name|tp
operator|->
name|tinfo
operator|.
name|goal
operator|.
name|width
expr_stmt|;
if|if
condition|(
name|DEBUG_FLAGS
operator|&
name|DEBUG_NEGO
condition|)
block|{
name|PRINT_ADDR
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"wide msgout: "
argument_list|)
expr_stmt|;
name|ncr_show_msg
argument_list|(
operator|&
name|cp
operator|->
name|scsi_smsg
index|[
name|msglen
operator|-
literal|4
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|".\n"
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
break|break;
block|}
empty_stmt|;
comment|/*---------------------------------------------------- 		** 		**	Build the identify message for getcc. 		** 		**---------------------------------------------------- 		*/
name|cp
operator|->
name|scsi_smsg2
index|[
literal|0
index|]
operator|=
name|idmsg
expr_stmt|;
name|msglen2
operator|=
literal|1
expr_stmt|;
comment|/*---------------------------------------------------- 		** 		**	Build the data descriptors 		** 		**---------------------------------------------------- 		*/
comment|/* XXX JGibbs - Handle other types of I/O */
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DIR_MASK
operator|)
operator|!=
name|CAM_DIR_NONE
condition|)
block|{
name|segments
operator|=
name|ncr_scatter
argument_list|(
operator|&
name|cp
operator|->
name|phys
argument_list|,
operator|(
name|vm_offset_t
operator|)
name|csio
operator|->
name|data_ptr
argument_list|,
operator|(
name|vm_size_t
operator|)
name|csio
operator|->
name|dxfer_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|segments
operator|<
literal|0
condition|)
block|{
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_TOO_BIG
expr_stmt|;
name|ncr_free_nccb
argument_list|(
name|np
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|oldspl
argument_list|)
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DIR_MASK
operator|)
operator|==
name|CAM_DIR_IN
condition|)
block|{
name|cp
operator|->
name|phys
operator|.
name|header
operator|.
name|savep
operator|=
name|NCB_SCRIPT_PHYS
argument_list|(
name|np
argument_list|,
name|data_in
argument_list|)
expr_stmt|;
name|cp
operator|->
name|phys
operator|.
name|header
operator|.
name|goalp
operator|=
name|cp
operator|->
name|phys
operator|.
name|header
operator|.
name|savep
operator|+
literal|20
operator|+
name|segments
operator|*
literal|16
expr_stmt|;
block|}
else|else
block|{
comment|/* CAM_DIR_OUT */
name|cp
operator|->
name|phys
operator|.
name|header
operator|.
name|savep
operator|=
name|NCB_SCRIPT_PHYS
argument_list|(
name|np
argument_list|,
name|data_out
argument_list|)
expr_stmt|;
name|cp
operator|->
name|phys
operator|.
name|header
operator|.
name|goalp
operator|=
name|cp
operator|->
name|phys
operator|.
name|header
operator|.
name|savep
operator|+
literal|20
operator|+
name|segments
operator|*
literal|16
expr_stmt|;
block|}
block|}
else|else
block|{
name|cp
operator|->
name|phys
operator|.
name|header
operator|.
name|savep
operator|=
name|NCB_SCRIPT_PHYS
argument_list|(
name|np
argument_list|,
name|no_data
argument_list|)
expr_stmt|;
name|cp
operator|->
name|phys
operator|.
name|header
operator|.
name|goalp
operator|=
name|cp
operator|->
name|phys
operator|.
name|header
operator|.
name|savep
expr_stmt|;
block|}
name|cp
operator|->
name|phys
operator|.
name|header
operator|.
name|lastp
operator|=
name|cp
operator|->
name|phys
operator|.
name|header
operator|.
name|savep
expr_stmt|;
comment|/*---------------------------------------------------- 		** 		**	fill in nccb 		** 		**---------------------------------------------------- 		** 		** 		**	physical -> virtual backlink 		**	Generic SCSI command 		*/
name|cp
operator|->
name|phys
operator|.
name|header
operator|.
name|cp
operator|=
name|cp
expr_stmt|;
comment|/* 		**	Startqueue 		*/
name|cp
operator|->
name|phys
operator|.
name|header
operator|.
name|launch
operator|.
name|l_paddr
operator|=
name|NCB_SCRIPT_PHYS
argument_list|(
name|np
argument_list|,
name|select
argument_list|)
expr_stmt|;
name|cp
operator|->
name|phys
operator|.
name|header
operator|.
name|launch
operator|.
name|l_cmd
operator|=
name|SCR_JUMP
expr_stmt|;
comment|/* 		**	select 		*/
name|cp
operator|->
name|phys
operator|.
name|select
operator|.
name|sel_id
operator|=
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
expr_stmt|;
name|cp
operator|->
name|phys
operator|.
name|select
operator|.
name|sel_scntl3
operator|=
name|tp
operator|->
name|tinfo
operator|.
name|wval
expr_stmt|;
name|cp
operator|->
name|phys
operator|.
name|select
operator|.
name|sel_sxfer
operator|=
name|tp
operator|->
name|tinfo
operator|.
name|sval
expr_stmt|;
comment|/* 		**	message 		*/
name|cp
operator|->
name|phys
operator|.
name|smsg
operator|.
name|addr
operator|=
name|CCB_PHYS
argument_list|(
name|cp
argument_list|,
name|scsi_smsg
argument_list|)
expr_stmt|;
name|cp
operator|->
name|phys
operator|.
name|smsg
operator|.
name|size
operator|=
name|msglen
expr_stmt|;
name|cp
operator|->
name|phys
operator|.
name|smsg2
operator|.
name|addr
operator|=
name|CCB_PHYS
argument_list|(
name|cp
argument_list|,
name|scsi_smsg2
argument_list|)
expr_stmt|;
name|cp
operator|->
name|phys
operator|.
name|smsg2
operator|.
name|size
operator|=
name|msglen2
expr_stmt|;
comment|/* 		**	command 		*/
comment|/* XXX JGibbs - Support other command types */
name|cp
operator|->
name|phys
operator|.
name|cmd
operator|.
name|addr
operator|=
name|vtophys
argument_list|(
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
argument_list|)
expr_stmt|;
name|cp
operator|->
name|phys
operator|.
name|cmd
operator|.
name|size
operator|=
name|csio
operator|->
name|cdb_len
expr_stmt|;
comment|/* 		**	sense command 		*/
name|cp
operator|->
name|phys
operator|.
name|scmd
operator|.
name|addr
operator|=
name|CCB_PHYS
argument_list|(
name|cp
argument_list|,
name|sensecmd
argument_list|)
expr_stmt|;
name|cp
operator|->
name|phys
operator|.
name|scmd
operator|.
name|size
operator|=
literal|6
expr_stmt|;
comment|/* 		**	patch requested size into sense command 		*/
name|cp
operator|->
name|sensecmd
index|[
literal|0
index|]
operator|=
literal|0x03
expr_stmt|;
name|cp
operator|->
name|sensecmd
index|[
literal|1
index|]
operator|=
name|ccb
operator|->
name|ccb_h
operator|.
name|target_lun
operator|<<
literal|5
expr_stmt|;
name|cp
operator|->
name|sensecmd
index|[
literal|4
index|]
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_sense_data
argument_list|)
expr_stmt|;
name|cp
operator|->
name|sensecmd
index|[
literal|4
index|]
operator|=
name|csio
operator|->
name|sense_len
expr_stmt|;
comment|/* 		**	sense data 		*/
name|cp
operator|->
name|phys
operator|.
name|sense
operator|.
name|addr
operator|=
name|vtophys
argument_list|(
operator|&
name|csio
operator|->
name|sense_data
argument_list|)
expr_stmt|;
name|cp
operator|->
name|phys
operator|.
name|sense
operator|.
name|size
operator|=
name|csio
operator|->
name|sense_len
expr_stmt|;
comment|/* 		**	status 		*/
name|cp
operator|->
name|actualquirks
operator|=
name|QUIRK_NOMSG
expr_stmt|;
name|cp
operator|->
name|host_status
operator|=
name|nego
condition|?
name|HS_NEGOTIATE
else|:
name|HS_BUSY
expr_stmt|;
name|cp
operator|->
name|s_status
operator|=
name|SCSI_STATUS_ILLEGAL
expr_stmt|;
name|cp
operator|->
name|parity_status
operator|=
literal|0
expr_stmt|;
name|cp
operator|->
name|xerr_status
operator|=
name|XE_OK
expr_stmt|;
name|cp
operator|->
name|sync_status
operator|=
name|tp
operator|->
name|tinfo
operator|.
name|sval
expr_stmt|;
name|cp
operator|->
name|nego_status
operator|=
name|nego
expr_stmt|;
name|cp
operator|->
name|wide_status
operator|=
name|tp
operator|->
name|tinfo
operator|.
name|wval
expr_stmt|;
comment|/*---------------------------------------------------- 		** 		**	Critical region: start this job. 		** 		**---------------------------------------------------- 		*/
comment|/* 		**	reselect pattern and activate this job. 		*/
name|cp
operator|->
name|jump_nccb
operator|.
name|l_cmd
operator|=
operator|(
name|SCR_JUMP
operator|^
name|IFFALSE
argument_list|(
name|DATA
argument_list|(
name|cp
operator|->
name|tag
argument_list|)
argument_list|)
operator|)
expr_stmt|;
name|cp
operator|->
name|tlimit
operator|=
name|time_second
operator|+
name|ccb
operator|->
name|ccb_h
operator|.
name|timeout
operator|/
literal|1000
operator|+
literal|2
expr_stmt|;
name|cp
operator|->
name|magic
operator|=
name|CCB_MAGIC
expr_stmt|;
comment|/* 		**	insert into start queue. 		*/
name|qidx
operator|=
name|np
operator|->
name|squeueput
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|qidx
operator|>=
name|MAX_START
condition|)
name|qidx
operator|=
literal|0
expr_stmt|;
name|np
operator|->
name|squeue
index|[
name|qidx
index|]
operator|=
name|NCB_SCRIPT_PHYS
argument_list|(
name|np
argument_list|,
name|idle
argument_list|)
expr_stmt|;
name|np
operator|->
name|squeue
index|[
name|np
operator|->
name|squeueput
index|]
operator|=
name|CCB_PHYS
argument_list|(
name|cp
argument_list|,
name|phys
argument_list|)
expr_stmt|;
name|np
operator|->
name|squeueput
operator|=
name|qidx
expr_stmt|;
if|if
condition|(
name|DEBUG_FLAGS
operator|&
name|DEBUG_QUEUE
condition|)
name|printf
argument_list|(
literal|"%s: queuepos=%d tryoffset=%d.\n"
argument_list|,
name|ncr_name
argument_list|(
name|np
argument_list|)
argument_list|,
name|np
operator|->
name|squeueput
argument_list|,
call|(
name|unsigned
call|)
argument_list|(
name|READSCRIPT
argument_list|(
name|startpos
index|[
literal|0
index|]
argument_list|)
operator|-
operator|(
name|NCB_SCRIPTH_PHYS
argument_list|(
name|np
argument_list|,
name|tryloop
argument_list|)
operator|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 		**	Script processor may be waiting for reselect. 		**	Wake it up. 		*/
name|OUTB
argument_list|(
name|nc_istat
argument_list|,
name|SIGP
argument_list|)
expr_stmt|;
comment|/* 		**	and reenable interrupts 		*/
name|splx
argument_list|(
name|oldspl
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|XPT_RESET_DEV
case|:
comment|/* Bus Device Reset the specified SCSI device */
case|case
name|XPT_EN_LUN
case|:
comment|/* Enable LUN as a target */
case|case
name|XPT_TARGET_IO
case|:
comment|/* Execute target I/O request */
case|case
name|XPT_ACCEPT_TARGET_IO
case|:
comment|/* Accept Host Target Mode CDB */
case|case
name|XPT_CONT_TARGET_IO
case|:
comment|/* Continue Host Target I/O Connection*/
case|case
name|XPT_ABORT
case|:
comment|/* Abort the specified CCB */
comment|/* XXX Implement */
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_INVALID
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
case|case
name|XPT_SET_TRAN_SETTINGS
case|:
block|{
name|struct
name|ccb_trans_settings
modifier|*
name|cts
init|=
operator|&
name|ccb
operator|->
name|cts
decl_stmt|;
name|tcb_p
name|tp
decl_stmt|;
name|u_int
name|update_type
decl_stmt|;
name|int
name|s
decl_stmt|;
name|struct
name|ccb_trans_settings_scsi
modifier|*
name|scsi
init|=
operator|&
name|cts
operator|->
name|proto_specific
operator|.
name|scsi
decl_stmt|;
name|struct
name|ccb_trans_settings_spi
modifier|*
name|spi
init|=
operator|&
name|cts
operator|->
name|xport_specific
operator|.
name|spi
decl_stmt|;
name|update_type
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|cts
operator|->
name|type
operator|==
name|CTS_TYPE_CURRENT_SETTINGS
condition|)
name|update_type
operator||=
name|NCR_TRANS_GOAL
expr_stmt|;
if|if
condition|(
name|cts
operator|->
name|type
operator|==
name|CTS_TYPE_USER_SETTINGS
condition|)
name|update_type
operator||=
name|NCR_TRANS_USER
expr_stmt|;
name|s
operator|=
name|splcam
argument_list|()
expr_stmt|;
name|tp
operator|=
operator|&
name|np
operator|->
name|target
index|[
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
index|]
expr_stmt|;
comment|/* Tag and disc enables */
if|if
condition|(
operator|(
name|spi
operator|->
name|valid
operator|&
name|CTS_SPI_VALID_DISC
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|update_type
operator|&
name|NCR_TRANS_GOAL
condition|)
block|{
if|if
condition|(
operator|(
name|spi
operator|->
name|flags
operator|&
name|CTS_SPI_FLAGS_DISC_ENB
operator|)
operator|!=
literal|0
condition|)
name|tp
operator|->
name|tinfo
operator|.
name|disc_tag
operator||=
name|NCR_CUR_DISCENB
expr_stmt|;
else|else
name|tp
operator|->
name|tinfo
operator|.
name|disc_tag
operator|&=
operator|~
name|NCR_CUR_DISCENB
expr_stmt|;
block|}
if|if
condition|(
name|update_type
operator|&
name|NCR_TRANS_USER
condition|)
block|{
if|if
condition|(
operator|(
name|spi
operator|->
name|flags
operator|&
name|CTS_SPI_FLAGS_DISC_ENB
operator|)
operator|!=
literal|0
condition|)
name|tp
operator|->
name|tinfo
operator|.
name|disc_tag
operator||=
name|NCR_USR_DISCENB
expr_stmt|;
else|else
name|tp
operator|->
name|tinfo
operator|.
name|disc_tag
operator|&=
operator|~
name|NCR_USR_DISCENB
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|scsi
operator|->
name|valid
operator|&
name|CTS_SCSI_VALID_TQ
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|update_type
operator|&
name|NCR_TRANS_GOAL
condition|)
block|{
if|if
condition|(
operator|(
name|scsi
operator|->
name|flags
operator|&
name|CTS_SCSI_FLAGS_TAG_ENB
operator|)
operator|!=
literal|0
condition|)
name|tp
operator|->
name|tinfo
operator|.
name|disc_tag
operator||=
name|NCR_CUR_TAGENB
expr_stmt|;
else|else
name|tp
operator|->
name|tinfo
operator|.
name|disc_tag
operator|&=
operator|~
name|NCR_CUR_TAGENB
expr_stmt|;
block|}
if|if
condition|(
name|update_type
operator|&
name|NCR_TRANS_USER
condition|)
block|{
if|if
condition|(
operator|(
name|scsi
operator|->
name|flags
operator|&
name|CTS_SCSI_FLAGS_TAG_ENB
operator|)
operator|!=
literal|0
condition|)
name|tp
operator|->
name|tinfo
operator|.
name|disc_tag
operator||=
name|NCR_USR_TAGENB
expr_stmt|;
else|else
name|tp
operator|->
name|tinfo
operator|.
name|disc_tag
operator|&=
operator|~
name|NCR_USR_TAGENB
expr_stmt|;
block|}
block|}
comment|/* Filter bus width and sync negotiation settings */
if|if
condition|(
operator|(
name|spi
operator|->
name|valid
operator|&
name|CTS_SPI_VALID_BUS_WIDTH
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|spi
operator|->
name|bus_width
operator|>
name|np
operator|->
name|maxwide
condition|)
name|spi
operator|->
name|bus_width
operator|=
name|np
operator|->
name|maxwide
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|(
name|spi
operator|->
name|valid
operator|&
name|CTS_SPI_VALID_SYNC_RATE
operator|)
operator|!=
literal|0
operator|)
operator|||
operator|(
operator|(
name|spi
operator|->
name|valid
operator|&
name|CTS_SPI_VALID_SYNC_OFFSET
operator|)
operator|!=
literal|0
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|spi
operator|->
name|valid
operator|&
name|CTS_SPI_VALID_SYNC_RATE
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|spi
operator|->
name|sync_period
operator|!=
literal|0
operator|&&
operator|(
name|spi
operator|->
name|sync_period
operator|<
name|np
operator|->
name|minsync
operator|)
condition|)
name|spi
operator|->
name|sync_period
operator|=
name|np
operator|->
name|minsync
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|spi
operator|->
name|valid
operator|&
name|CTS_SPI_VALID_SYNC_OFFSET
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|spi
operator|->
name|sync_offset
operator|==
literal|0
condition|)
name|spi
operator|->
name|sync_period
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|spi
operator|->
name|sync_offset
operator|>
name|np
operator|->
name|maxoffs
condition|)
name|spi
operator|->
name|sync_offset
operator|=
name|np
operator|->
name|maxoffs
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|update_type
operator|&
name|NCR_TRANS_USER
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|spi
operator|->
name|valid
operator|&
name|CTS_SPI_VALID_SYNC_RATE
operator|)
operator|!=
literal|0
condition|)
name|tp
operator|->
name|tinfo
operator|.
name|user
operator|.
name|period
operator|=
name|spi
operator|->
name|sync_period
expr_stmt|;
if|if
condition|(
operator|(
name|spi
operator|->
name|valid
operator|&
name|CTS_SPI_VALID_SYNC_OFFSET
operator|)
operator|!=
literal|0
condition|)
name|tp
operator|->
name|tinfo
operator|.
name|user
operator|.
name|offset
operator|=
name|spi
operator|->
name|sync_offset
expr_stmt|;
if|if
condition|(
operator|(
name|spi
operator|->
name|valid
operator|&
name|CTS_SPI_VALID_BUS_WIDTH
operator|)
operator|!=
literal|0
condition|)
name|tp
operator|->
name|tinfo
operator|.
name|user
operator|.
name|width
operator|=
name|spi
operator|->
name|bus_width
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|update_type
operator|&
name|NCR_TRANS_GOAL
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|spi
operator|->
name|valid
operator|&
name|CTS_SPI_VALID_SYNC_RATE
operator|)
operator|!=
literal|0
condition|)
name|tp
operator|->
name|tinfo
operator|.
name|goal
operator|.
name|period
operator|=
name|spi
operator|->
name|sync_period
expr_stmt|;
if|if
condition|(
operator|(
name|spi
operator|->
name|valid
operator|&
name|CTS_SPI_VALID_SYNC_OFFSET
operator|)
operator|!=
literal|0
condition|)
name|tp
operator|->
name|tinfo
operator|.
name|goal
operator|.
name|offset
operator|=
name|spi
operator|->
name|sync_offset
expr_stmt|;
if|if
condition|(
operator|(
name|spi
operator|->
name|valid
operator|&
name|CTS_SPI_VALID_BUS_WIDTH
operator|)
operator|!=
literal|0
condition|)
name|tp
operator|->
name|tinfo
operator|.
name|goal
operator|.
name|width
operator|=
name|spi
operator|->
name|bus_width
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|XPT_GET_TRAN_SETTINGS
case|:
comment|/* Get default/user set transfer settings for the target */
block|{
name|struct
name|ccb_trans_settings
modifier|*
name|cts
init|=
operator|&
name|ccb
operator|->
name|cts
decl_stmt|;
name|struct
name|ncr_transinfo
modifier|*
name|tinfo
decl_stmt|;
name|tcb_p
name|tp
init|=
operator|&
name|np
operator|->
name|target
index|[
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
index|]
decl_stmt|;
name|int
name|s
decl_stmt|;
name|struct
name|ccb_trans_settings_scsi
modifier|*
name|scsi
init|=
operator|&
name|cts
operator|->
name|proto_specific
operator|.
name|scsi
decl_stmt|;
name|struct
name|ccb_trans_settings_spi
modifier|*
name|spi
init|=
operator|&
name|cts
operator|->
name|xport_specific
operator|.
name|spi
decl_stmt|;
name|cts
operator|->
name|protocol
operator|=
name|PROTO_SCSI
expr_stmt|;
name|cts
operator|->
name|protocol_version
operator|=
name|SCSI_REV_2
expr_stmt|;
name|cts
operator|->
name|transport
operator|=
name|XPORT_SPI
expr_stmt|;
name|cts
operator|->
name|transport_version
operator|=
literal|2
expr_stmt|;
name|s
operator|=
name|splcam
argument_list|()
expr_stmt|;
if|if
condition|(
name|cts
operator|->
name|type
operator|==
name|CTS_TYPE_CURRENT_SETTINGS
condition|)
block|{
name|tinfo
operator|=
operator|&
name|tp
operator|->
name|tinfo
operator|.
name|current
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|tinfo
operator|.
name|disc_tag
operator|&
name|NCR_CUR_DISCENB
condition|)
name|spi
operator|->
name|flags
operator||=
name|CTS_SPI_FLAGS_DISC_ENB
expr_stmt|;
else|else
name|spi
operator|->
name|flags
operator|&=
operator|~
name|CTS_SPI_FLAGS_DISC_ENB
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|tinfo
operator|.
name|disc_tag
operator|&
name|NCR_CUR_TAGENB
condition|)
name|scsi
operator|->
name|flags
operator||=
name|CTS_SCSI_FLAGS_TAG_ENB
expr_stmt|;
else|else
name|scsi
operator|->
name|flags
operator|&=
operator|~
name|CTS_SCSI_FLAGS_TAG_ENB
expr_stmt|;
block|}
else|else
block|{
name|tinfo
operator|=
operator|&
name|tp
operator|->
name|tinfo
operator|.
name|user
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|tinfo
operator|.
name|disc_tag
operator|&
name|NCR_USR_DISCENB
condition|)
name|spi
operator|->
name|flags
operator||=
name|CTS_SPI_FLAGS_DISC_ENB
expr_stmt|;
else|else
name|spi
operator|->
name|flags
operator|&=
operator|~
name|CTS_SPI_FLAGS_DISC_ENB
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|tinfo
operator|.
name|disc_tag
operator|&
name|NCR_USR_TAGENB
condition|)
name|scsi
operator|->
name|flags
operator||=
name|CTS_SCSI_FLAGS_TAG_ENB
expr_stmt|;
else|else
name|scsi
operator|->
name|flags
operator|&=
operator|~
name|CTS_SCSI_FLAGS_TAG_ENB
expr_stmt|;
block|}
name|spi
operator|->
name|sync_period
operator|=
name|tinfo
operator|->
name|period
expr_stmt|;
name|spi
operator|->
name|sync_offset
operator|=
name|tinfo
operator|->
name|offset
expr_stmt|;
name|spi
operator|->
name|bus_width
operator|=
name|tinfo
operator|->
name|width
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|spi
operator|->
name|valid
operator|=
name|CTS_SPI_VALID_SYNC_RATE
operator||
name|CTS_SPI_VALID_SYNC_OFFSET
operator||
name|CTS_SPI_VALID_BUS_WIDTH
operator||
name|CTS_SPI_VALID_DISC
expr_stmt|;
name|scsi
operator|->
name|valid
operator|=
name|CTS_SCSI_VALID_TQ
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|XPT_CALC_GEOMETRY
case|:
block|{
comment|/* XXX JGibbs - I'm sure the NCR uses a different strategy, 		 *		but it should be able to deal with Adaptec 		 *		geometry too. 		 */
name|cam_calc_geometry
argument_list|(
operator|&
name|ccb
operator|->
name|ccg
argument_list|,
comment|/*extended*/
literal|1
argument_list|)
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|XPT_RESET_BUS
case|:
comment|/* Reset the specified SCSI bus */
block|{
name|OUTB
argument_list|(
name|nc_scntl1
argument_list|,
name|CRST
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
name|DELAY
argument_list|(
literal|10000
argument_list|)
expr_stmt|;
comment|/* Wait until our interrupt handler sees it */
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|XPT_TERM_IO
case|:
comment|/* Terminate the I/O process */
comment|/* XXX Implement */
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_INVALID
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
case|case
name|XPT_PATH_INQ
case|:
comment|/* Path routing inquiry */
block|{
name|struct
name|ccb_pathinq
modifier|*
name|cpi
init|=
operator|&
name|ccb
operator|->
name|cpi
decl_stmt|;
name|cpi
operator|->
name|version_num
operator|=
literal|1
expr_stmt|;
comment|/* XXX??? */
name|cpi
operator|->
name|hba_inquiry
operator|=
name|PI_SDTR_ABLE
operator||
name|PI_TAG_ABLE
expr_stmt|;
if|if
condition|(
operator|(
name|np
operator|->
name|features
operator|&
name|FE_WIDE
operator|)
operator|!=
literal|0
condition|)
name|cpi
operator|->
name|hba_inquiry
operator||=
name|PI_WIDE_16
expr_stmt|;
name|cpi
operator|->
name|target_sprt
operator|=
literal|0
expr_stmt|;
name|cpi
operator|->
name|hba_misc
operator|=
literal|0
expr_stmt|;
name|cpi
operator|->
name|hba_eng_cnt
operator|=
literal|0
expr_stmt|;
name|cpi
operator|->
name|max_target
operator|=
operator|(
name|np
operator|->
name|features
operator|&
name|FE_WIDE
operator|)
condition|?
literal|15
else|:
literal|7
expr_stmt|;
name|cpi
operator|->
name|max_lun
operator|=
name|MAX_LUN
operator|-
literal|1
expr_stmt|;
name|cpi
operator|->
name|initiator_id
operator|=
name|np
operator|->
name|myaddr
expr_stmt|;
name|cpi
operator|->
name|bus_id
operator|=
name|cam_sim_bus
argument_list|(
name|sim
argument_list|)
expr_stmt|;
name|cpi
operator|->
name|base_transfer_speed
operator|=
literal|3300
expr_stmt|;
name|strncpy
argument_list|(
name|cpi
operator|->
name|sim_vid
argument_list|,
literal|"FreeBSD"
argument_list|,
name|SIM_IDLEN
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|cpi
operator|->
name|hba_vid
argument_list|,
literal|"Symbios"
argument_list|,
name|HBA_IDLEN
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|cpi
operator|->
name|dev_name
argument_list|,
name|cam_sim_name
argument_list|(
name|sim
argument_list|)
argument_list|,
name|DEV_IDLEN
argument_list|)
expr_stmt|;
name|cpi
operator|->
name|unit_number
operator|=
name|cam_sim_unit
argument_list|(
name|sim
argument_list|)
expr_stmt|;
name|cpi
operator|->
name|transport
operator|=
name|XPORT_SPI
expr_stmt|;
name|cpi
operator|->
name|transport_version
operator|=
literal|2
expr_stmt|;
name|cpi
operator|->
name|protocol
operator|=
name|PROTO_SCSI
expr_stmt|;
name|cpi
operator|->
name|protocol_version
operator|=
name|SCSI_REV_2
expr_stmt|;
name|cpi
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_INVALID
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
comment|/*========================================================== ** ** **	Complete execution of a SCSI command. **	Signal completion to the generic SCSI driver. ** ** **========================================================== */
specifier|static
name|void
name|ncr_complete
parameter_list|(
name|ncb_p
name|np
parameter_list|,
name|nccb_p
name|cp
parameter_list|)
block|{
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|tcb_p
name|tp
decl_stmt|;
comment|/* 	**	Sanity check 	*/
if|if
condition|(
operator|!
name|cp
operator|||
operator|(
name|cp
operator|->
name|magic
operator|!=
name|CCB_MAGIC
operator|)
operator|||
operator|!
name|cp
operator|->
name|ccb
condition|)
return|return;
name|cp
operator|->
name|magic
operator|=
literal|1
expr_stmt|;
name|cp
operator|->
name|tlimit
operator|=
literal|0
expr_stmt|;
comment|/* 	**	No Reselect anymore. 	*/
name|cp
operator|->
name|jump_nccb
operator|.
name|l_cmd
operator|=
operator|(
name|SCR_JUMP
operator|)
expr_stmt|;
comment|/* 	**	No starting. 	*/
name|cp
operator|->
name|phys
operator|.
name|header
operator|.
name|launch
operator|.
name|l_paddr
operator|=
name|NCB_SCRIPT_PHYS
argument_list|(
name|np
argument_list|,
name|idle
argument_list|)
expr_stmt|;
comment|/* 	**	timestamp 	*/
name|ncb_profile
argument_list|(
name|np
argument_list|,
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|DEBUG_FLAGS
operator|&
name|DEBUG_TINY
condition|)
name|printf
argument_list|(
literal|"CCB=%x STAT=%x/%x\n"
argument_list|,
operator|(
name|int
operator|)
operator|(
name|intptr_t
operator|)
name|cp
operator|&
literal|0xfff
argument_list|,
name|cp
operator|->
name|host_status
argument_list|,
name|cp
operator|->
name|s_status
argument_list|)
expr_stmt|;
name|ccb
operator|=
name|cp
operator|->
name|ccb
expr_stmt|;
name|cp
operator|->
name|ccb
operator|=
name|NULL
expr_stmt|;
name|tp
operator|=
operator|&
name|np
operator|->
name|target
index|[
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
index|]
expr_stmt|;
comment|/* 	**	We do not queue more than 1 nccb per target  	**	with negotiation at any time. If this nccb was  	**	used for negotiation, clear this info in the tcb. 	*/
if|if
condition|(
name|cp
operator|==
name|tp
operator|->
name|nego_cp
condition|)
name|tp
operator|->
name|nego_cp
operator|=
name|NULL
expr_stmt|;
comment|/* 	**	Check for parity errors. 	*/
comment|/* XXX JGibbs - What about reporting them??? */
if|if
condition|(
name|cp
operator|->
name|parity_status
condition|)
block|{
name|PRINT_ADDR
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%d parity error(s), fallback.\n"
argument_list|,
name|cp
operator|->
name|parity_status
argument_list|)
expr_stmt|;
comment|/* 		**	fallback to asynch transfer. 		*/
name|tp
operator|->
name|tinfo
operator|.
name|goal
operator|.
name|period
operator|=
literal|0
expr_stmt|;
name|tp
operator|->
name|tinfo
operator|.
name|goal
operator|.
name|offset
operator|=
literal|0
expr_stmt|;
block|}
empty_stmt|;
comment|/* 	**	Check for extended errors. 	*/
if|if
condition|(
name|cp
operator|->
name|xerr_status
operator|!=
name|XE_OK
condition|)
block|{
name|PRINT_ADDR
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|cp
operator|->
name|xerr_status
condition|)
block|{
case|case
name|XE_EXTRA_DATA
case|:
name|printf
argument_list|(
literal|"extraneous data discarded.\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|XE_BAD_PHASE
case|:
name|printf
argument_list|(
literal|"illegal scsi phase (4/5).\n"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"extended error %d.\n"
argument_list|,
name|cp
operator|->
name|xerr_status
argument_list|)
expr_stmt|;
break|break;
block|}
empty_stmt|;
if|if
condition|(
name|cp
operator|->
name|host_status
operator|==
name|HS_COMPLETE
condition|)
name|cp
operator|->
name|host_status
operator|=
name|HS_FAIL
expr_stmt|;
block|}
empty_stmt|;
comment|/* 	**	Check the status. 	*/
if|if
condition|(
name|cp
operator|->
name|host_status
operator|==
name|HS_COMPLETE
condition|)
block|{
if|if
condition|(
name|cp
operator|->
name|s_status
operator|==
name|SCSI_STATUS_OK
condition|)
block|{
comment|/* 			**	All went well. 			*/
comment|/* XXX JGibbs - Properly calculate residual */
name|tp
operator|->
name|bytes
operator|+=
name|ccb
operator|->
name|csio
operator|.
name|dxfer_len
expr_stmt|;
name|tp
operator|->
name|transfers
operator|++
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|cp
operator|->
name|s_status
operator|&
name|SCSI_STATUS_SENSE
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* 			 * XXX Could be TERMIO too.  Should record 			 * original status. 			 */
name|ccb
operator|->
name|csio
operator|.
name|scsi_status
operator|=
name|SCSI_STATUS_CHECK_COND
expr_stmt|;
name|cp
operator|->
name|s_status
operator|&=
operator|~
name|SCSI_STATUS_SENSE
expr_stmt|;
if|if
condition|(
name|cp
operator|->
name|s_status
operator|==
name|SCSI_STATUS_OK
condition|)
block|{
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_AUTOSNS_VALID
operator||
name|CAM_SCSI_STATUS_ERROR
expr_stmt|;
block|}
else|else
block|{
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_AUTOSENSE_FAIL
expr_stmt|;
block|}
block|}
else|else
block|{
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_SCSI_STATUS_ERROR
expr_stmt|;
name|ccb
operator|->
name|csio
operator|.
name|scsi_status
operator|=
name|cp
operator|->
name|s_status
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|cp
operator|->
name|host_status
operator|==
name|HS_SEL_TIMEOUT
condition|)
block|{
comment|/* 		**   Device failed selection 		*/
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_SEL_TIMEOUT
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cp
operator|->
name|host_status
operator|==
name|HS_TIMEOUT
condition|)
block|{
comment|/* 		**   No response 		*/
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_CMD_TIMEOUT
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cp
operator|->
name|host_status
operator|==
name|HS_STALL
condition|)
block|{
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQUEUE_REQ
expr_stmt|;
block|}
else|else
block|{
comment|/* 		**  Other protocol messes 		*/
name|PRINT_ADDR
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"COMMAND FAILED (%x %x) @%p.\n"
argument_list|,
name|cp
operator|->
name|host_status
argument_list|,
name|cp
operator|->
name|s_status
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_CMD_TIMEOUT
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
operator|)
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|xpt_freeze_devq
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
comment|/*count*/
literal|1
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_DEV_QFRZN
expr_stmt|;
block|}
comment|/* 	**	Free this nccb 	*/
name|ncr_free_nccb
argument_list|(
name|np
argument_list|,
name|cp
argument_list|)
expr_stmt|;
comment|/* 	**	signal completion to generic driver. 	*/
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
block|}
comment|/*========================================================== ** ** **	Signal all (or one) control block done. ** ** **========================================================== */
specifier|static
name|void
name|ncr_wakeup
parameter_list|(
name|ncb_p
name|np
parameter_list|,
name|u_long
name|code
parameter_list|)
block|{
comment|/* 	**	Starting at the default nccb and following 	**	the links, complete all jobs with a 	**	host_status greater than "disconnect". 	** 	**	If the "code" parameter is not zero, 	**	complete all jobs that are not IDLE. 	*/
name|nccb_p
name|cp
init|=
name|np
operator|->
name|link_nccb
decl_stmt|;
while|while
condition|(
name|cp
condition|)
block|{
switch|switch
condition|(
name|cp
operator|->
name|host_status
condition|)
block|{
case|case
name|HS_IDLE
case|:
break|break;
case|case
name|HS_DISCONNECT
case|:
if|if
condition|(
name|DEBUG_FLAGS
operator|&
name|DEBUG_TINY
condition|)
name|printf
argument_list|(
literal|"D"
argument_list|)
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
name|HS_BUSY
case|:
case|case
name|HS_NEGOTIATE
case|:
if|if
condition|(
operator|!
name|code
condition|)
break|break;
name|cp
operator|->
name|host_status
operator|=
name|code
expr_stmt|;
comment|/* FALLTHROUGH */
default|default:
name|ncr_complete
argument_list|(
name|np
argument_list|,
name|cp
argument_list|)
expr_stmt|;
break|break;
block|}
empty_stmt|;
name|cp
operator|=
name|cp
operator|->
name|link_nccb
expr_stmt|;
block|}
empty_stmt|;
block|}
specifier|static
name|void
name|ncr_freeze_devq
parameter_list|(
name|ncb_p
name|np
parameter_list|,
name|struct
name|cam_path
modifier|*
name|path
parameter_list|)
block|{
name|nccb_p
name|cp
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|count
decl_stmt|;
name|int
name|firstskip
decl_stmt|;
comment|/* 	**	Starting at the first nccb and following 	**	the links, complete all jobs that match 	**	the passed in path and are in the start queue. 	*/
name|cp
operator|=
name|np
operator|->
name|link_nccb
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
name|firstskip
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|cp
condition|)
block|{
switch|switch
condition|(
name|cp
operator|->
name|host_status
condition|)
block|{
case|case
name|HS_BUSY
case|:
case|case
name|HS_NEGOTIATE
case|:
if|if
condition|(
operator|(
name|cp
operator|->
name|phys
operator|.
name|header
operator|.
name|launch
operator|.
name|l_paddr
operator|==
name|NCB_SCRIPT_PHYS
argument_list|(
name|np
argument_list|,
name|select
argument_list|)
operator|)
operator|&&
operator|(
name|xpt_path_comp
argument_list|(
name|path
argument_list|,
name|cp
operator|->
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|)
operator|>=
literal|0
operator|)
condition|)
block|{
comment|/* Mark for removal from the start queue */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|MAX_START
condition|;
name|i
operator|++
control|)
block|{
name|int
name|idx
decl_stmt|;
name|idx
operator|=
name|np
operator|->
name|squeueput
operator|-
name|i
expr_stmt|;
if|if
condition|(
name|idx
operator|<
literal|0
condition|)
name|idx
operator|=
name|MAX_START
operator|+
name|idx
expr_stmt|;
if|if
condition|(
name|np
operator|->
name|squeue
index|[
name|idx
index|]
operator|==
name|CCB_PHYS
argument_list|(
name|cp
argument_list|,
name|phys
argument_list|)
condition|)
block|{
name|np
operator|->
name|squeue
index|[
name|idx
index|]
operator|=
name|NCB_SCRIPT_PHYS
argument_list|(
name|np
argument_list|,
name|skip
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>
name|firstskip
condition|)
name|firstskip
operator|=
name|i
expr_stmt|;
break|break;
block|}
block|}
name|cp
operator|->
name|host_status
operator|=
name|HS_STALL
expr_stmt|;
name|ncr_complete
argument_list|(
name|np
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
break|break;
default|default:
break|break;
block|}
name|cp
operator|=
name|cp
operator|->
name|link_nccb
expr_stmt|;
block|}
if|if
condition|(
name|count
operator|>
literal|0
condition|)
block|{
name|int
name|j
decl_stmt|;
name|int
name|bidx
decl_stmt|;
comment|/* Compress the start queue */
name|j
operator|=
literal|0
expr_stmt|;
name|bidx
operator|=
name|np
operator|->
name|squeueput
expr_stmt|;
name|i
operator|=
name|np
operator|->
name|squeueput
operator|-
name|firstskip
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
name|i
operator|=
name|MAX_START
operator|+
name|i
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|bidx
operator|=
name|i
operator|-
name|j
expr_stmt|;
if|if
condition|(
name|bidx
operator|<
literal|0
condition|)
name|bidx
operator|=
name|MAX_START
operator|+
name|bidx
expr_stmt|;
if|if
condition|(
name|np
operator|->
name|squeue
index|[
name|i
index|]
operator|==
name|NCB_SCRIPT_PHYS
argument_list|(
name|np
argument_list|,
name|skip
argument_list|)
condition|)
block|{
name|j
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|j
operator|!=
literal|0
condition|)
block|{
name|np
operator|->
name|squeue
index|[
name|bidx
index|]
operator|=
name|np
operator|->
name|squeue
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|np
operator|->
name|squeue
index|[
name|bidx
index|]
operator|==
name|NCB_SCRIPT_PHYS
argument_list|(
name|np
argument_list|,
name|idle
argument_list|)
condition|)
break|break;
block|}
name|i
operator|=
operator|(
name|i
operator|+
literal|1
operator|)
operator|%
name|MAX_START
expr_stmt|;
block|}
name|np
operator|->
name|squeueput
operator|=
name|bidx
expr_stmt|;
block|}
block|}
comment|/*========================================================== ** ** **	Start NCR chip. ** ** **========================================================== */
specifier|static
name|void
name|ncr_init
parameter_list|(
name|ncb_p
name|np
parameter_list|,
name|char
modifier|*
name|msg
parameter_list|,
name|u_long
name|code
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
comment|/* 	**	Reset chip. 	*/
name|OUTB
argument_list|(
name|nc_istat
argument_list|,
name|SRST
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
name|nc_istat
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	**	Message. 	*/
if|if
condition|(
name|msg
condition|)
name|printf
argument_list|(
literal|"%s: restart (%s).\n"
argument_list|,
name|ncr_name
argument_list|(
name|np
argument_list|)
argument_list|,
name|msg
argument_list|)
expr_stmt|;
comment|/* 	**	Clear Start Queue 	*/
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_START
condition|;
name|i
operator|++
control|)
name|np
operator|->
name|squeue
index|[
name|i
index|]
operator|=
name|NCB_SCRIPT_PHYS
argument_list|(
name|np
argument_list|,
name|idle
argument_list|)
expr_stmt|;
comment|/* 	**	Start at first entry. 	*/
name|np
operator|->
name|squeueput
operator|=
literal|0
expr_stmt|;
name|WRITESCRIPT
argument_list|(
name|startpos
index|[
literal|0
index|]
argument_list|,
name|NCB_SCRIPTH_PHYS
argument_list|(
name|np
argument_list|,
name|tryloop
argument_list|)
argument_list|)
expr_stmt|;
name|WRITESCRIPT
argument_list|(
name|start0
index|[
literal|0
index|]
argument_list|,
name|SCR_INT
operator|^
name|IFFALSE
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	**	Wakeup all pending jobs. 	*/
name|ncr_wakeup
argument_list|(
name|np
argument_list|,
name|code
argument_list|)
expr_stmt|;
comment|/* 	**	Init chip. 	*/
name|OUTB
argument_list|(
name|nc_istat
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
comment|/*  Remove Reset, abort ...	     */
name|OUTB
argument_list|(
name|nc_scntl0
argument_list|,
literal|0xca
argument_list|)
expr_stmt|;
comment|/*  full arb., ena parity, par->ATN  */
name|OUTB
argument_list|(
name|nc_scntl1
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
comment|/*  odd parity, and remove CRST!!    */
name|ncr_selectclock
argument_list|(
name|np
argument_list|,
name|np
operator|->
name|rv_scntl3
argument_list|)
expr_stmt|;
comment|/* Select SCSI clock             */
name|OUTB
argument_list|(
name|nc_scid
argument_list|,
name|RRE
operator||
name|np
operator|->
name|myaddr
argument_list|)
expr_stmt|;
comment|/*  host adapter SCSI address       */
name|OUTW
argument_list|(
name|nc_respid
argument_list|,
literal|1ul
operator|<<
name|np
operator|->
name|myaddr
argument_list|)
expr_stmt|;
comment|/*  id to respond to		     */
name|OUTB
argument_list|(
name|nc_istat
argument_list|,
name|SIGP
argument_list|)
expr_stmt|;
comment|/*  Signal Process		     */
name|OUTB
argument_list|(
name|nc_dmode
argument_list|,
name|np
operator|->
name|rv_dmode
argument_list|)
expr_stmt|;
comment|/* XXX modify burstlen ??? */
name|OUTB
argument_list|(
name|nc_dcntl
argument_list|,
name|np
operator|->
name|rv_dcntl
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
name|nc_ctest3
argument_list|,
name|np
operator|->
name|rv_ctest3
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
name|nc_ctest5
argument_list|,
name|np
operator|->
name|rv_ctest5
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
name|nc_ctest4
argument_list|,
name|np
operator|->
name|rv_ctest4
argument_list|)
expr_stmt|;
comment|/*  enable master parity checking    */
name|OUTB
argument_list|(
name|nc_stest2
argument_list|,
name|np
operator|->
name|rv_stest2
operator||
name|EXT
argument_list|)
expr_stmt|;
comment|/* Extended Sreq/Sack filtering */
name|OUTB
argument_list|(
name|nc_stest3
argument_list|,
name|TE
argument_list|)
expr_stmt|;
comment|/*  TolerANT enable		     */
name|OUTB
argument_list|(
name|nc_stime0
argument_list|,
literal|0x0b
argument_list|)
expr_stmt|;
comment|/*  HTH = disabled, STO = 0.1 sec.   */
if|if
condition|(
name|bootverbose
operator|>=
literal|2
condition|)
block|{
name|printf
argument_list|(
literal|"\tACTUAL values:SCNTL3:%02x DMODE:%02x  DCNTL:%02x\n"
argument_list|,
name|np
operator|->
name|rv_scntl3
argument_list|,
name|np
operator|->
name|rv_dmode
argument_list|,
name|np
operator|->
name|rv_dcntl
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\t              CTEST3:%02x CTEST4:%02x CTEST5:%02x\n"
argument_list|,
name|np
operator|->
name|rv_ctest3
argument_list|,
name|np
operator|->
name|rv_ctest4
argument_list|,
name|np
operator|->
name|rv_ctest5
argument_list|)
expr_stmt|;
block|}
comment|/* 	**    Enable GPIO0 pin for writing if LED support. 	*/
if|if
condition|(
name|np
operator|->
name|features
operator|&
name|FE_LED0
condition|)
block|{
name|OUTOFFB
argument_list|(
name|nc_gpcntl
argument_list|,
literal|0x01
argument_list|)
expr_stmt|;
block|}
comment|/* 	**	Fill in target structure. 	*/
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_TARGET
condition|;
name|i
operator|++
control|)
block|{
name|tcb_p
name|tp
init|=
operator|&
name|np
operator|->
name|target
index|[
name|i
index|]
decl_stmt|;
name|tp
operator|->
name|tinfo
operator|.
name|sval
operator|=
literal|0
expr_stmt|;
name|tp
operator|->
name|tinfo
operator|.
name|wval
operator|=
name|np
operator|->
name|rv_scntl3
expr_stmt|;
name|tp
operator|->
name|tinfo
operator|.
name|current
operator|.
name|period
operator|=
literal|0
expr_stmt|;
name|tp
operator|->
name|tinfo
operator|.
name|current
operator|.
name|offset
operator|=
literal|0
expr_stmt|;
name|tp
operator|->
name|tinfo
operator|.
name|current
operator|.
name|width
operator|=
name|MSG_EXT_WDTR_BUS_8_BIT
expr_stmt|;
block|}
comment|/* 	**      enable ints 	*/
name|OUTW
argument_list|(
name|nc_sien
argument_list|,
name|STO
operator||
name|HTH
operator||
name|MA
operator||
name|SGE
operator||
name|UDC
operator||
name|RST
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
name|nc_dien
argument_list|,
name|MDPE
operator||
name|BF
operator||
name|ABRT
operator||
name|SSI
operator||
name|SIR
operator||
name|IID
argument_list|)
expr_stmt|;
comment|/* 	**    Start script processor. 	*/
name|OUTL
argument_list|(
name|nc_dsp
argument_list|,
name|NCB_SCRIPT_PHYS
argument_list|(
name|np
argument_list|,
name|start
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Notify the XPT of the event 	 */
if|if
condition|(
name|code
operator|==
name|HS_RESET
condition|)
name|xpt_async
argument_list|(
name|AC_BUS_RESET
argument_list|,
name|np
operator|->
name|path
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
specifier|static
name|void
name|ncr_poll
parameter_list|(
name|struct
name|cam_sim
modifier|*
name|sim
parameter_list|)
block|{
name|ncr_intr
argument_list|(
name|cam_sim_softc
argument_list|(
name|sim
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/*========================================================== ** **	Get clock factor and sync divisor for a given  **	synchronous factor period. **	Returns the clock factor (in sxfer) and scntl3  **	synchronous divisor field. ** **========================================================== */
specifier|static
name|void
name|ncr_getsync
parameter_list|(
name|ncb_p
name|np
parameter_list|,
name|u_char
name|sfac
parameter_list|,
name|u_char
modifier|*
name|fakp
parameter_list|,
name|u_char
modifier|*
name|scntl3p
parameter_list|)
block|{
name|u_long
name|clk
init|=
name|np
operator|->
name|clock_khz
decl_stmt|;
comment|/* SCSI clock frequency in kHz	*/
name|int
name|div
init|=
name|np
operator|->
name|clock_divn
decl_stmt|;
comment|/* Number of divisors supported	*/
name|u_long
name|fak
decl_stmt|;
comment|/* Sync factor in sxfer		*/
name|u_long
name|per
decl_stmt|;
comment|/* Period in tenths of ns	*/
name|u_long
name|kpc
decl_stmt|;
comment|/* (per * clk)			*/
comment|/* 	**	Compute the synchronous period in tenths of nano-seconds 	*/
if|if
condition|(
name|sfac
operator|<=
literal|10
condition|)
name|per
operator|=
literal|250
expr_stmt|;
elseif|else
if|if
condition|(
name|sfac
operator|==
literal|11
condition|)
name|per
operator|=
literal|303
expr_stmt|;
elseif|else
if|if
condition|(
name|sfac
operator|==
literal|12
condition|)
name|per
operator|=
literal|500
expr_stmt|;
else|else
name|per
operator|=
literal|40
operator|*
name|sfac
expr_stmt|;
comment|/* 	**	Look for the greatest clock divisor that allows an  	**	input speed faster than the period. 	*/
name|kpc
operator|=
name|per
operator|*
name|clk
expr_stmt|;
while|while
condition|(
operator|--
name|div
operator|>=
literal|0
condition|)
if|if
condition|(
name|kpc
operator|>=
operator|(
name|div_10M
index|[
name|div
index|]
operator|*
literal|4
operator|)
condition|)
break|break;
comment|/* 	**	Calculate the lowest clock factor that allows an output  	**	speed not faster than the period. 	*/
name|fak
operator|=
operator|(
name|kpc
operator|-
literal|1
operator|)
operator|/
name|div_10M
index|[
name|div
index|]
operator|+
literal|1
expr_stmt|;
if|#
directive|if
literal|0
comment|/* You can #if 1 if you think this optimization is usefull */
block|per = (fak * div_10M[div]) / clk;
comment|/* 	**	Why not to try the immediate lower divisor and to choose  	**	the one that allows the fastest output speed ? 	**	We dont want input speed too much greater than output speed. 	*/
block|if (div>= 1&& fak< 6) { 		u_long fak2, per2; 		fak2 = (kpc - 1) / div_10M[div-1] + 1; 		per2 = (fak2 * div_10M[div-1]) / clk; 		if (per2< per&& fak2<= 6) { 			fak = fak2; 			per = per2; 			--div; 		} 	}
endif|#
directive|endif
if|if
condition|(
name|fak
operator|<
literal|4
condition|)
name|fak
operator|=
literal|4
expr_stmt|;
comment|/* Should never happen, too bad ... */
comment|/* 	**	Compute and return sync parameters for the ncr 	*/
operator|*
name|fakp
operator|=
name|fak
operator|-
literal|4
expr_stmt|;
operator|*
name|scntl3p
operator|=
operator|(
operator|(
name|div
operator|+
literal|1
operator|)
operator|<<
literal|4
operator|)
operator|+
operator|(
name|sfac
operator|<
literal|25
condition|?
literal|0x80
else|:
literal|0
operator|)
expr_stmt|;
block|}
comment|/*========================================================== ** **	Switch sync mode for current job and its target ** **========================================================== */
specifier|static
name|void
name|ncr_setsync
parameter_list|(
name|ncb_p
name|np
parameter_list|,
name|nccb_p
name|cp
parameter_list|,
name|u_char
name|scntl3
parameter_list|,
name|u_char
name|sxfer
parameter_list|,
name|u_char
name|period
parameter_list|)
block|{
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|struct
name|ccb_trans_settings
name|neg
decl_stmt|;
name|tcb_p
name|tp
decl_stmt|;
name|int
name|div
decl_stmt|;
name|u_int
name|target
init|=
name|INB
argument_list|(
name|nc_sdid
argument_list|)
operator|&
literal|0x0f
decl_stmt|;
name|u_int
name|period_10ns
decl_stmt|;
name|assert
argument_list|(
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cp
condition|)
return|return;
name|ccb
operator|=
name|cp
operator|->
name|ccb
expr_stmt|;
name|assert
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ccb
condition|)
return|return;
name|assert
argument_list|(
name|target
operator|==
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
argument_list|)
expr_stmt|;
name|tp
operator|=
operator|&
name|np
operator|->
name|target
index|[
name|target
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|scntl3
operator|||
operator|!
operator|(
name|sxfer
operator|&
literal|0x1f
operator|)
condition|)
name|scntl3
operator|=
name|np
operator|->
name|rv_scntl3
expr_stmt|;
name|scntl3
operator|=
operator|(
name|scntl3
operator|&
literal|0xf0
operator|)
operator||
operator|(
name|tp
operator|->
name|tinfo
operator|.
name|wval
operator|&
name|EWS
operator|)
operator||
operator|(
name|np
operator|->
name|rv_scntl3
operator|&
literal|0x07
operator|)
expr_stmt|;
comment|/* 	**	Deduce the value of controller sync period from scntl3. 	**	period is in tenths of nano-seconds. 	*/
name|div
operator|=
operator|(
operator|(
name|scntl3
operator|>>
literal|4
operator|)
operator|&
literal|0x7
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|sxfer
operator|&
literal|0x1f
operator|)
operator|&&
name|div
condition|)
name|period_10ns
operator|=
operator|(
operator|(
operator|(
name|sxfer
operator|>>
literal|5
operator|)
operator|+
literal|4
operator|)
operator|*
name|div_10M
index|[
name|div
operator|-
literal|1
index|]
operator|)
operator|/
name|np
operator|->
name|clock_khz
expr_stmt|;
else|else
name|period_10ns
operator|=
literal|0
expr_stmt|;
name|tp
operator|->
name|tinfo
operator|.
name|goal
operator|.
name|period
operator|=
name|period
expr_stmt|;
name|tp
operator|->
name|tinfo
operator|.
name|goal
operator|.
name|offset
operator|=
name|sxfer
operator|&
literal|0x1f
expr_stmt|;
name|tp
operator|->
name|tinfo
operator|.
name|current
operator|.
name|period
operator|=
name|period
expr_stmt|;
name|tp
operator|->
name|tinfo
operator|.
name|current
operator|.
name|offset
operator|=
name|sxfer
operator|&
literal|0x1f
expr_stmt|;
comment|/* 	**	 Stop there if sync parameters are unchanged 	*/
if|if
condition|(
name|tp
operator|->
name|tinfo
operator|.
name|sval
operator|==
name|sxfer
operator|&&
name|tp
operator|->
name|tinfo
operator|.
name|wval
operator|==
name|scntl3
condition|)
return|return;
name|tp
operator|->
name|tinfo
operator|.
name|sval
operator|=
name|sxfer
expr_stmt|;
name|tp
operator|->
name|tinfo
operator|.
name|wval
operator|=
name|scntl3
expr_stmt|;
if|if
condition|(
name|sxfer
operator|&
literal|0x1f
condition|)
block|{
comment|/* 		**  Disable extended Sreq/Sack filtering 		*/
if|if
condition|(
name|period_10ns
operator|<=
literal|2000
condition|)
name|OUTOFFB
argument_list|(
name|nc_stest2
argument_list|,
name|EXT
argument_list|)
expr_stmt|;
block|}
comment|/* 	** Tell the SCSI layer about the 	** new transfer parameters. 	*/
name|memset
argument_list|(
operator|&
name|neg
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|neg
argument_list|)
argument_list|)
expr_stmt|;
name|neg
operator|.
name|protocol
operator|=
name|PROTO_SCSI
expr_stmt|;
name|neg
operator|.
name|protocol_version
operator|=
name|SCSI_REV_2
expr_stmt|;
name|neg
operator|.
name|transport
operator|=
name|XPORT_SPI
expr_stmt|;
name|neg
operator|.
name|transport_version
operator|=
literal|2
expr_stmt|;
name|neg
operator|.
name|xport_specific
operator|.
name|spi
operator|.
name|sync_period
operator|=
name|period
expr_stmt|;
name|neg
operator|.
name|xport_specific
operator|.
name|spi
operator|.
name|sync_offset
operator|=
name|sxfer
operator|&
literal|0x1f
expr_stmt|;
name|neg
operator|.
name|xport_specific
operator|.
name|spi
operator|.
name|valid
operator|=
name|CTS_SPI_VALID_SYNC_RATE
operator||
name|CTS_SPI_VALID_SYNC_OFFSET
expr_stmt|;
name|xpt_setup_ccb
argument_list|(
operator|&
name|neg
operator|.
name|ccb_h
argument_list|,
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
comment|/*priority*/
literal|1
argument_list|)
expr_stmt|;
name|xpt_async
argument_list|(
name|AC_TRANSFER_NEG
argument_list|,
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
operator|&
name|neg
argument_list|)
expr_stmt|;
comment|/* 	**	set actual value and sync_status 	*/
name|OUTB
argument_list|(
name|nc_sxfer
argument_list|,
name|sxfer
argument_list|)
expr_stmt|;
name|np
operator|->
name|sync_st
operator|=
name|sxfer
expr_stmt|;
name|OUTB
argument_list|(
name|nc_scntl3
argument_list|,
name|scntl3
argument_list|)
expr_stmt|;
name|np
operator|->
name|wide_st
operator|=
name|scntl3
expr_stmt|;
comment|/* 	**	patch ALL nccbs of this target. 	*/
for|for
control|(
name|cp
operator|=
name|np
operator|->
name|link_nccb
init|;
name|cp
condition|;
name|cp
operator|=
name|cp
operator|->
name|link_nccb
control|)
block|{
if|if
condition|(
operator|!
name|cp
operator|->
name|ccb
condition|)
continue|continue;
if|if
condition|(
name|cp
operator|->
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
operator|!=
name|target
condition|)
continue|continue;
name|cp
operator|->
name|sync_status
operator|=
name|sxfer
expr_stmt|;
name|cp
operator|->
name|wide_status
operator|=
name|scntl3
expr_stmt|;
block|}
empty_stmt|;
block|}
comment|/*========================================================== ** **	Switch wide mode for current job and its target **	SCSI specs say: a SCSI device that accepts a WDTR  **	message shall reset the synchronous agreement to  **	asynchronous mode. ** **========================================================== */
specifier|static
name|void
name|ncr_setwide
parameter_list|(
name|ncb_p
name|np
parameter_list|,
name|nccb_p
name|cp
parameter_list|,
name|u_char
name|wide
parameter_list|,
name|u_char
name|ack
parameter_list|)
block|{
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|struct
name|ccb_trans_settings
name|neg
decl_stmt|;
name|u_int
name|target
init|=
name|INB
argument_list|(
name|nc_sdid
argument_list|)
operator|&
literal|0x0f
decl_stmt|;
name|tcb_p
name|tp
decl_stmt|;
name|u_char
name|scntl3
decl_stmt|;
name|u_char
name|sxfer
decl_stmt|;
name|assert
argument_list|(
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cp
condition|)
return|return;
name|ccb
operator|=
name|cp
operator|->
name|ccb
expr_stmt|;
name|assert
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ccb
condition|)
return|return;
name|assert
argument_list|(
name|target
operator|==
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
argument_list|)
expr_stmt|;
name|tp
operator|=
operator|&
name|np
operator|->
name|target
index|[
name|target
index|]
expr_stmt|;
name|tp
operator|->
name|tinfo
operator|.
name|current
operator|.
name|width
operator|=
name|wide
expr_stmt|;
name|tp
operator|->
name|tinfo
operator|.
name|goal
operator|.
name|width
operator|=
name|wide
expr_stmt|;
name|tp
operator|->
name|tinfo
operator|.
name|current
operator|.
name|period
operator|=
literal|0
expr_stmt|;
name|tp
operator|->
name|tinfo
operator|.
name|current
operator|.
name|offset
operator|=
literal|0
expr_stmt|;
name|scntl3
operator|=
operator|(
name|tp
operator|->
name|tinfo
operator|.
name|wval
operator|&
operator|(
operator|~
name|EWS
operator|)
operator|)
operator||
operator|(
name|wide
condition|?
name|EWS
else|:
literal|0
operator|)
expr_stmt|;
name|sxfer
operator|=
name|ack
condition|?
literal|0
else|:
name|tp
operator|->
name|tinfo
operator|.
name|sval
expr_stmt|;
comment|/* 	**	 Stop there if sync/wide parameters are unchanged 	*/
if|if
condition|(
name|tp
operator|->
name|tinfo
operator|.
name|sval
operator|==
name|sxfer
operator|&&
name|tp
operator|->
name|tinfo
operator|.
name|wval
operator|==
name|scntl3
condition|)
return|return;
name|tp
operator|->
name|tinfo
operator|.
name|sval
operator|=
name|sxfer
expr_stmt|;
name|tp
operator|->
name|tinfo
operator|.
name|wval
operator|=
name|scntl3
expr_stmt|;
comment|/* Tell the SCSI layer about the new transfer params */
name|memset
argument_list|(
operator|&
name|neg
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|neg
argument_list|)
argument_list|)
expr_stmt|;
name|neg
operator|.
name|protocol
operator|=
name|PROTO_SCSI
expr_stmt|;
name|neg
operator|.
name|protocol_version
operator|=
name|SCSI_REV_2
expr_stmt|;
name|neg
operator|.
name|transport
operator|=
name|XPORT_SPI
expr_stmt|;
name|neg
operator|.
name|transport_version
operator|=
literal|2
expr_stmt|;
name|neg
operator|.
name|xport_specific
operator|.
name|spi
operator|.
name|bus_width
operator|=
operator|(
name|scntl3
operator|&
name|EWS
operator|)
condition|?
name|MSG_EXT_WDTR_BUS_16_BIT
else|:
name|MSG_EXT_WDTR_BUS_8_BIT
expr_stmt|;
name|neg
operator|.
name|xport_specific
operator|.
name|spi
operator|.
name|sync_period
operator|=
literal|0
expr_stmt|;
name|neg
operator|.
name|xport_specific
operator|.
name|spi
operator|.
name|sync_offset
operator|=
literal|0
expr_stmt|;
name|neg
operator|.
name|xport_specific
operator|.
name|spi
operator|.
name|valid
operator|=
name|CTS_SPI_VALID_SYNC_RATE
operator||
name|CTS_SPI_VALID_SYNC_OFFSET
operator||
name|CTS_SPI_VALID_BUS_WIDTH
expr_stmt|;
name|xpt_setup_ccb
argument_list|(
operator|&
name|neg
operator|.
name|ccb_h
argument_list|,
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
comment|/*priority*/
literal|1
argument_list|)
expr_stmt|;
name|xpt_async
argument_list|(
name|AC_TRANSFER_NEG
argument_list|,
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
operator|&
name|neg
argument_list|)
expr_stmt|;
comment|/* 	**	set actual value and sync_status 	*/
name|OUTB
argument_list|(
name|nc_sxfer
argument_list|,
name|sxfer
argument_list|)
expr_stmt|;
name|np
operator|->
name|sync_st
operator|=
name|sxfer
expr_stmt|;
name|OUTB
argument_list|(
name|nc_scntl3
argument_list|,
name|scntl3
argument_list|)
expr_stmt|;
name|np
operator|->
name|wide_st
operator|=
name|scntl3
expr_stmt|;
comment|/* 	**	patch ALL nccbs of this target. 	*/
for|for
control|(
name|cp
operator|=
name|np
operator|->
name|link_nccb
init|;
name|cp
condition|;
name|cp
operator|=
name|cp
operator|->
name|link_nccb
control|)
block|{
if|if
condition|(
operator|!
name|cp
operator|->
name|ccb
condition|)
continue|continue;
if|if
condition|(
name|cp
operator|->
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
operator|!=
name|target
condition|)
continue|continue;
name|cp
operator|->
name|sync_status
operator|=
name|sxfer
expr_stmt|;
name|cp
operator|->
name|wide_status
operator|=
name|scntl3
expr_stmt|;
block|}
empty_stmt|;
block|}
comment|/*========================================================== ** ** **	ncr timeout handler. ** ** **========================================================== ** **	Misused to keep the driver running when **	interrupts are not configured correctly. ** **---------------------------------------------------------- */
specifier|static
name|void
name|ncr_timeout
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|ncb_p
name|np
init|=
name|arg
decl_stmt|;
name|time_t
name|thistime
init|=
name|time_second
decl_stmt|;
name|ticks_t
name|step
init|=
name|np
operator|->
name|ticks
decl_stmt|;
name|u_long
name|count
init|=
literal|0
decl_stmt|;
name|long
name|signed
name|t
decl_stmt|;
name|nccb_p
name|cp
decl_stmt|;
if|if
condition|(
name|np
operator|->
name|lasttime
operator|!=
name|thistime
condition|)
block|{
comment|/* 		**	block ncr interrupts 		*/
name|int
name|oldspl
init|=
name|splcam
argument_list|()
decl_stmt|;
name|np
operator|->
name|lasttime
operator|=
name|thistime
expr_stmt|;
comment|/*---------------------------------------------------- 		** 		**	handle ncr chip timeouts 		** 		**	Assumption: 		**	We have a chance to arbitrate for the 		**	SCSI bus at least every 10 seconds. 		** 		**---------------------------------------------------- 		*/
name|t
operator|=
name|thistime
operator|-
name|np
operator|->
name|heartbeat
expr_stmt|;
if|if
condition|(
name|t
operator|<
literal|2
condition|)
name|np
operator|->
name|latetime
operator|=
literal|0
expr_stmt|;
else|else
name|np
operator|->
name|latetime
operator|++
expr_stmt|;
if|if
condition|(
name|np
operator|->
name|latetime
operator|>
literal|2
condition|)
block|{
comment|/* 			**      If there are no requests, the script 			**      processor will sleep on SEL_WAIT_RESEL. 			**      But we have to check whether it died. 			**      Let's try to wake it up. 			*/
name|OUTB
argument_list|(
name|nc_istat
argument_list|,
name|SIGP
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
comment|/*---------------------------------------------------- 		** 		**	handle nccb timeouts 		** 		**---------------------------------------------------- 		*/
for|for
control|(
name|cp
operator|=
name|np
operator|->
name|link_nccb
init|;
name|cp
condition|;
name|cp
operator|=
name|cp
operator|->
name|link_nccb
control|)
block|{
comment|/* 			**	look for timed out nccbs. 			*/
if|if
condition|(
operator|!
name|cp
operator|->
name|host_status
condition|)
continue|continue;
name|count
operator|++
expr_stmt|;
if|if
condition|(
name|cp
operator|->
name|tlimit
operator|>
name|thistime
condition|)
continue|continue;
comment|/* 			**	Disable reselect. 			**      Remove it from startqueue. 			*/
name|cp
operator|->
name|jump_nccb
operator|.
name|l_cmd
operator|=
operator|(
name|SCR_JUMP
operator|)
expr_stmt|;
if|if
condition|(
name|cp
operator|->
name|phys
operator|.
name|header
operator|.
name|launch
operator|.
name|l_paddr
operator|==
name|NCB_SCRIPT_PHYS
argument_list|(
name|np
argument_list|,
name|select
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"%s: timeout nccb=%p (skip)\n"
argument_list|,
name|ncr_name
argument_list|(
name|np
argument_list|)
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|cp
operator|->
name|phys
operator|.
name|header
operator|.
name|launch
operator|.
name|l_paddr
operator|=
name|NCB_SCRIPT_PHYS
argument_list|(
name|np
argument_list|,
name|skip
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
switch|switch
condition|(
name|cp
operator|->
name|host_status
condition|)
block|{
case|case
name|HS_BUSY
case|:
case|case
name|HS_NEGOTIATE
case|:
comment|/* FALLTHROUGH */
case|case
name|HS_DISCONNECT
case|:
name|cp
operator|->
name|host_status
operator|=
name|HS_TIMEOUT
expr_stmt|;
block|}
empty_stmt|;
name|cp
operator|->
name|tag
operator|=
literal|0
expr_stmt|;
comment|/* 			**	wakeup this nccb. 			*/
name|ncr_complete
argument_list|(
name|np
argument_list|,
name|cp
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
name|splx
argument_list|(
name|oldspl
argument_list|)
expr_stmt|;
block|}
name|np
operator|->
name|timeout_ch
operator|=
name|timeout
argument_list|(
name|ncr_timeout
argument_list|,
operator|(
name|caddr_t
operator|)
name|np
argument_list|,
name|step
condition|?
name|step
else|:
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|INB
argument_list|(
name|nc_istat
argument_list|)
operator|&
operator|(
name|INTF
operator||
name|SIP
operator||
name|DIP
operator|)
condition|)
block|{
comment|/* 		**	Process pending interrupts. 		*/
name|int
name|oldspl
init|=
name|splcam
argument_list|()
decl_stmt|;
if|if
condition|(
name|DEBUG_FLAGS
operator|&
name|DEBUG_TINY
condition|)
name|printf
argument_list|(
literal|"{"
argument_list|)
expr_stmt|;
name|ncr_exception
argument_list|(
name|np
argument_list|)
expr_stmt|;
if|if
condition|(
name|DEBUG_FLAGS
operator|&
name|DEBUG_TINY
condition|)
name|printf
argument_list|(
literal|"}"
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|oldspl
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
block|}
comment|/*========================================================== ** **	log message for real hard errors ** **	"ncr0 targ 0?: ERROR (ds:si) (so-si-sd) (sxfer/scntl3) @ name (dsp:dbc)." **	"	      reg: r0 r1 r2 r3 r4 r5 r6 ..... rf." ** **	exception register: **		ds:	dstat **		si:	sist ** **	SCSI bus lines: **		so:	control lines as driver by NCR. **		si:	control lines as seen by NCR. **		sd:	scsi data lines as seen by NCR. ** **	wide/fastmode: **		sxfer:	(see the manual) **		scntl3:	(see the manual) ** **	current script command: **		dsp:	script address (relative to start of script). **		dbc:	first word of script command. ** **	First 16 register of the chip: **		r0..rf ** **========================================================== */
specifier|static
name|void
name|ncr_log_hard_error
parameter_list|(
name|ncb_p
name|np
parameter_list|,
name|u_short
name|sist
parameter_list|,
name|u_char
name|dstat
parameter_list|)
block|{
name|u_int32_t
name|dsp
decl_stmt|;
name|int
name|script_ofs
decl_stmt|;
name|int
name|script_size
decl_stmt|;
name|char
modifier|*
name|script_name
decl_stmt|;
name|u_char
modifier|*
name|script_base
decl_stmt|;
name|int
name|i
decl_stmt|;
name|dsp
operator|=
name|INL
argument_list|(
name|nc_dsp
argument_list|)
expr_stmt|;
if|if
condition|(
name|np
operator|->
name|p_script
operator|<
name|dsp
operator|&&
name|dsp
operator|<=
name|np
operator|->
name|p_script
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|script
argument_list|)
condition|)
block|{
name|script_ofs
operator|=
name|dsp
operator|-
name|np
operator|->
name|p_script
expr_stmt|;
name|script_size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|script
argument_list|)
expr_stmt|;
name|script_base
operator|=
operator|(
name|u_char
operator|*
operator|)
name|np
operator|->
name|script
expr_stmt|;
name|script_name
operator|=
literal|"script"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|np
operator|->
name|p_scripth
operator|<
name|dsp
operator|&&
name|dsp
operator|<=
name|np
operator|->
name|p_scripth
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|scripth
argument_list|)
condition|)
block|{
name|script_ofs
operator|=
name|dsp
operator|-
name|np
operator|->
name|p_scripth
expr_stmt|;
name|script_size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|scripth
argument_list|)
expr_stmt|;
name|script_base
operator|=
operator|(
name|u_char
operator|*
operator|)
name|np
operator|->
name|scripth
expr_stmt|;
name|script_name
operator|=
literal|"scripth"
expr_stmt|;
block|}
else|else
block|{
name|script_ofs
operator|=
name|dsp
expr_stmt|;
name|script_size
operator|=
literal|0
expr_stmt|;
name|script_base
operator|=
literal|0
expr_stmt|;
name|script_name
operator|=
literal|"mem"
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"%s:%d: ERROR (%x:%x) (%x-%x-%x) (%x/%x) @ (%s %x:%08x).\n"
argument_list|,
name|ncr_name
argument_list|(
name|np
argument_list|)
argument_list|,
operator|(
name|unsigned
operator|)
name|INB
argument_list|(
name|nc_sdid
argument_list|)
operator|&
literal|0x0f
argument_list|,
name|dstat
argument_list|,
name|sist
argument_list|,
operator|(
name|unsigned
operator|)
name|INB
argument_list|(
name|nc_socl
argument_list|)
argument_list|,
operator|(
name|unsigned
operator|)
name|INB
argument_list|(
name|nc_sbcl
argument_list|)
argument_list|,
operator|(
name|unsigned
operator|)
name|INB
argument_list|(
name|nc_sbdl
argument_list|)
argument_list|,
operator|(
name|unsigned
operator|)
name|INB
argument_list|(
name|nc_sxfer
argument_list|)
argument_list|,
operator|(
name|unsigned
operator|)
name|INB
argument_list|(
name|nc_scntl3
argument_list|)
argument_list|,
name|script_name
argument_list|,
name|script_ofs
argument_list|,
operator|(
name|unsigned
operator|)
name|INL
argument_list|(
name|nc_dbc
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|script_ofs
operator|&
literal|3
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|unsigned
operator|)
name|script_ofs
operator|<
name|script_size
condition|)
block|{
name|printf
argument_list|(
literal|"%s: script cmd = %08x\n"
argument_list|,
name|ncr_name
argument_list|(
name|np
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|READSCRIPT_OFF
argument_list|(
name|script_base
argument_list|,
name|script_ofs
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"%s: regdump:"
argument_list|,
name|ncr_name
argument_list|(
name|np
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|" %02x"
argument_list|,
operator|(
name|unsigned
operator|)
name|INB_OFF
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|".\n"
argument_list|)
expr_stmt|;
block|}
comment|/*========================================================== ** ** **	ncr chip exception handler. ** ** **========================================================== */
specifier|static
name|void
name|ncr_exception
parameter_list|(
name|ncb_p
name|np
parameter_list|)
block|{
name|u_char
name|istat
decl_stmt|,
name|dstat
decl_stmt|;
name|u_short
name|sist
decl_stmt|;
comment|/* 	**	interrupt on the fly ? 	*/
while|while
condition|(
operator|(
name|istat
operator|=
name|INB
argument_list|(
name|nc_istat
argument_list|)
operator|)
operator|&
name|INTF
condition|)
block|{
if|if
condition|(
name|DEBUG_FLAGS
operator|&
name|DEBUG_TINY
condition|)
name|printf
argument_list|(
literal|"F "
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
name|nc_istat
argument_list|,
name|INTF
argument_list|)
expr_stmt|;
name|np
operator|->
name|profile
operator|.
name|num_fly
operator|++
expr_stmt|;
name|ncr_wakeup
argument_list|(
name|np
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
if|if
condition|(
operator|!
operator|(
name|istat
operator|&
operator|(
name|SIP
operator||
name|DIP
operator|)
operator|)
condition|)
block|{
return|return;
block|}
comment|/* 	**	Steinbach's Guideline for Systems Programming: 	**	Never test for an error condition you don't know how to handle. 	*/
name|sist
operator|=
operator|(
name|istat
operator|&
name|SIP
operator|)
condition|?
name|INW
argument_list|(
name|nc_sist
argument_list|)
else|:
literal|0
expr_stmt|;
name|dstat
operator|=
operator|(
name|istat
operator|&
name|DIP
operator|)
condition|?
name|INB
argument_list|(
name|nc_dstat
argument_list|)
else|:
literal|0
expr_stmt|;
name|np
operator|->
name|profile
operator|.
name|num_int
operator|++
expr_stmt|;
if|if
condition|(
name|DEBUG_FLAGS
operator|&
name|DEBUG_TINY
condition|)
name|printf
argument_list|(
literal|"<%d|%x:%x|%x:%x>"
argument_list|,
name|INB
argument_list|(
name|nc_scr0
argument_list|)
argument_list|,
name|dstat
argument_list|,
name|sist
argument_list|,
operator|(
name|unsigned
operator|)
name|INL
argument_list|(
name|nc_dsp
argument_list|)
argument_list|,
operator|(
name|unsigned
operator|)
name|INL
argument_list|(
name|nc_dbc
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|dstat
operator|==
name|DFE
operator|)
operator|&&
operator|(
name|sist
operator|==
name|PAR
operator|)
condition|)
return|return;
comment|/*========================================================== ** **	First the normal cases. ** **========================================================== */
comment|/*------------------------------------------- 	**	SCSI reset 	**------------------------------------------- 	*/
if|if
condition|(
name|sist
operator|&
name|RST
condition|)
block|{
name|ncr_init
argument_list|(
name|np
argument_list|,
name|bootverbose
condition|?
literal|"scsi reset"
else|:
name|NULL
argument_list|,
name|HS_RESET
argument_list|)
expr_stmt|;
return|return;
block|}
empty_stmt|;
comment|/*------------------------------------------- 	**	selection timeout 	** 	**	IID excluded from dstat mask! 	**	(chip bug) 	**------------------------------------------- 	*/
if|if
condition|(
operator|(
name|sist
operator|&
name|STO
operator|)
operator|&&
operator|!
operator|(
name|sist
operator|&
operator|(
name|GEN
operator||
name|HTH
operator||
name|MA
operator||
name|SGE
operator||
name|UDC
operator||
name|RST
operator||
name|PAR
operator|)
operator|)
operator|&&
operator|!
operator|(
name|dstat
operator|&
operator|(
name|MDPE
operator||
name|BF
operator||
name|ABRT
operator||
name|SIR
operator|)
operator|)
condition|)
block|{
name|ncr_int_sto
argument_list|(
name|np
argument_list|)
expr_stmt|;
return|return;
block|}
empty_stmt|;
comment|/*------------------------------------------- 	**      Phase mismatch. 	**------------------------------------------- 	*/
if|if
condition|(
operator|(
name|sist
operator|&
name|MA
operator|)
operator|&&
operator|!
operator|(
name|sist
operator|&
operator|(
name|STO
operator||
name|GEN
operator||
name|HTH
operator||
name|SGE
operator||
name|UDC
operator||
name|RST
operator||
name|PAR
operator|)
operator|)
operator|&&
operator|!
operator|(
name|dstat
operator|&
operator|(
name|MDPE
operator||
name|BF
operator||
name|ABRT
operator||
name|SIR
operator||
name|IID
operator|)
operator|)
condition|)
block|{
name|ncr_int_ma
argument_list|(
name|np
argument_list|,
name|dstat
argument_list|)
expr_stmt|;
return|return;
block|}
empty_stmt|;
comment|/*---------------------------------------- 	**	move command with length 0 	**---------------------------------------- 	*/
if|if
condition|(
operator|(
name|dstat
operator|&
name|IID
operator|)
operator|&&
operator|!
operator|(
name|sist
operator|&
operator|(
name|STO
operator||
name|GEN
operator||
name|HTH
operator||
name|MA
operator||
name|SGE
operator||
name|UDC
operator||
name|RST
operator||
name|PAR
operator|)
operator|)
operator|&&
operator|!
operator|(
name|dstat
operator|&
operator|(
name|MDPE
operator||
name|BF
operator||
name|ABRT
operator||
name|SIR
operator|)
operator|)
operator|&&
operator|(
operator|(
name|INL
argument_list|(
name|nc_dbc
argument_list|)
operator|&
literal|0xf8000000
operator|)
operator|==
name|SCR_MOVE_TBL
operator|)
condition|)
block|{
comment|/* 		**      Target wants more data than available. 		**	The "no_data" script will do it. 		*/
name|OUTL
argument_list|(
name|nc_dsp
argument_list|,
name|NCB_SCRIPT_PHYS
argument_list|(
name|np
argument_list|,
name|no_data
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
empty_stmt|;
comment|/*------------------------------------------- 	**	Programmed interrupt 	**------------------------------------------- 	*/
if|if
condition|(
operator|(
name|dstat
operator|&
name|SIR
operator|)
operator|&&
operator|!
operator|(
name|sist
operator|&
operator|(
name|STO
operator||
name|GEN
operator||
name|HTH
operator||
name|MA
operator||
name|SGE
operator||
name|UDC
operator||
name|RST
operator||
name|PAR
operator|)
operator|)
operator|&&
operator|!
operator|(
name|dstat
operator|&
operator|(
name|MDPE
operator||
name|BF
operator||
name|ABRT
operator||
name|IID
operator|)
operator|)
operator|&&
operator|(
name|INB
argument_list|(
name|nc_dsps
argument_list|)
operator|<=
name|SIR_MAX
operator|)
condition|)
block|{
name|ncr_int_sir
argument_list|(
name|np
argument_list|)
expr_stmt|;
return|return;
block|}
empty_stmt|;
comment|/*======================================== 	**	log message for real hard errors 	**======================================== 	*/
name|ncr_log_hard_error
argument_list|(
name|np
argument_list|,
name|sist
argument_list|,
name|dstat
argument_list|)
expr_stmt|;
comment|/*======================================== 	**	do the register dump 	**======================================== 	*/
if|if
condition|(
name|time_second
operator|-
name|np
operator|->
name|regtime
operator|>
literal|10
condition|)
block|{
name|int
name|i
decl_stmt|;
name|np
operator|->
name|regtime
operator|=
name|time_second
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|np
operator|->
name|regdump
argument_list|)
condition|;
name|i
operator|++
control|)
operator|(
operator|(
specifier|volatile
name|char
operator|*
operator|)
operator|&
name|np
operator|->
name|regdump
operator|)
index|[
name|i
index|]
operator|=
name|INB_OFF
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|np
operator|->
name|regdump
operator|.
name|nc_dstat
operator|=
name|dstat
expr_stmt|;
name|np
operator|->
name|regdump
operator|.
name|nc_sist
operator|=
name|sist
expr_stmt|;
block|}
empty_stmt|;
comment|/*---------------------------------------- 	**	clean up the dma fifo 	**---------------------------------------- 	*/
if|if
condition|(
operator|(
name|INB
argument_list|(
name|nc_sstat0
argument_list|)
operator|&
operator|(
name|ILF
operator||
name|ORF
operator||
name|OLF
operator|)
operator|)
operator|||
operator|(
name|INB
argument_list|(
name|nc_sstat1
argument_list|)
operator|&
operator|(
name|FF3210
operator|)
operator|)
operator|||
operator|(
name|INB
argument_list|(
name|nc_sstat2
argument_list|)
operator|&
operator|(
name|ILF1
operator||
name|ORF1
operator||
name|OLF1
operator|)
operator|)
operator|||
comment|/* wide .. */
operator|!
operator|(
name|dstat
operator|&
name|DFE
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"%s: have to clear fifos.\n"
argument_list|,
name|ncr_name
argument_list|(
name|np
argument_list|)
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
name|nc_stest3
argument_list|,
name|TE
operator||
name|CSF
argument_list|)
expr_stmt|;
comment|/* clear scsi fifo */
name|OUTB
argument_list|(
name|nc_ctest3
argument_list|,
name|np
operator|->
name|rv_ctest3
operator||
name|CLF
argument_list|)
expr_stmt|;
comment|/* clear dma fifo  */
block|}
comment|/*---------------------------------------- 	**	handshake timeout 	**---------------------------------------- 	*/
if|if
condition|(
name|sist
operator|&
name|HTH
condition|)
block|{
name|printf
argument_list|(
literal|"%s: handshake timeout\n"
argument_list|,
name|ncr_name
argument_list|(
name|np
argument_list|)
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
name|nc_scntl1
argument_list|,
name|CRST
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
name|nc_scntl1
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
name|nc_scr0
argument_list|,
name|HS_FAIL
argument_list|)
expr_stmt|;
name|OUTL
argument_list|(
name|nc_dsp
argument_list|,
name|NCB_SCRIPT_PHYS
argument_list|(
name|np
argument_list|,
name|cleanup
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/*---------------------------------------- 	**	unexpected disconnect 	**---------------------------------------- 	*/
if|if
condition|(
operator|(
name|sist
operator|&
name|UDC
operator|)
operator|&&
operator|!
operator|(
name|sist
operator|&
operator|(
name|STO
operator||
name|GEN
operator||
name|HTH
operator||
name|MA
operator||
name|SGE
operator||
name|RST
operator||
name|PAR
operator|)
operator|)
operator|&&
operator|!
operator|(
name|dstat
operator|&
operator|(
name|MDPE
operator||
name|BF
operator||
name|ABRT
operator||
name|SIR
operator||
name|IID
operator|)
operator|)
condition|)
block|{
name|OUTB
argument_list|(
name|nc_scr0
argument_list|,
name|HS_UNEXPECTED
argument_list|)
expr_stmt|;
name|OUTL
argument_list|(
name|nc_dsp
argument_list|,
name|NCB_SCRIPT_PHYS
argument_list|(
name|np
argument_list|,
name|cleanup
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
empty_stmt|;
comment|/*---------------------------------------- 	**	cannot disconnect 	**---------------------------------------- 	*/
if|if
condition|(
operator|(
name|dstat
operator|&
name|IID
operator|)
operator|&&
operator|!
operator|(
name|sist
operator|&
operator|(
name|STO
operator||
name|GEN
operator||
name|HTH
operator||
name|MA
operator||
name|SGE
operator||
name|UDC
operator||
name|RST
operator||
name|PAR
operator|)
operator|)
operator|&&
operator|!
operator|(
name|dstat
operator|&
operator|(
name|MDPE
operator||
name|BF
operator||
name|ABRT
operator||
name|SIR
operator|)
operator|)
operator|&&
operator|(
operator|(
name|INL
argument_list|(
name|nc_dbc
argument_list|)
operator|&
literal|0xf8000000
operator|)
operator|==
name|SCR_WAIT_DISC
operator|)
condition|)
block|{
comment|/* 		**      Unexpected data cycle while waiting for disconnect. 		*/
if|if
condition|(
name|INB
argument_list|(
name|nc_sstat2
argument_list|)
operator|&
name|LDSC
condition|)
block|{
comment|/* 			**	It's an early reconnect. 			**	Let's continue ... 			*/
name|OUTB
argument_list|(
name|nc_dcntl
argument_list|,
name|np
operator|->
name|rv_dcntl
operator||
name|STD
argument_list|)
expr_stmt|;
comment|/* 			**	info message 			*/
name|printf
argument_list|(
literal|"%s: INFO: LDSC while IID.\n"
argument_list|,
name|ncr_name
argument_list|(
name|np
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
empty_stmt|;
name|printf
argument_list|(
literal|"%s: target %d doesn't release the bus.\n"
argument_list|,
name|ncr_name
argument_list|(
name|np
argument_list|)
argument_list|,
name|INB
argument_list|(
name|nc_sdid
argument_list|)
operator|&
literal|0x0f
argument_list|)
expr_stmt|;
comment|/* 		**	return without restarting the NCR. 		**	timeout will do the real work. 		*/
return|return;
block|}
empty_stmt|;
comment|/*---------------------------------------- 	**	single step 	**---------------------------------------- 	*/
if|if
condition|(
operator|(
name|dstat
operator|&
name|SSI
operator|)
operator|&&
operator|!
operator|(
name|sist
operator|&
operator|(
name|STO
operator||
name|GEN
operator||
name|HTH
operator||
name|MA
operator||
name|SGE
operator||
name|UDC
operator||
name|RST
operator||
name|PAR
operator|)
operator|)
operator|&&
operator|!
operator|(
name|dstat
operator|&
operator|(
name|MDPE
operator||
name|BF
operator||
name|ABRT
operator||
name|SIR
operator||
name|IID
operator|)
operator|)
condition|)
block|{
name|OUTB
argument_list|(
name|nc_dcntl
argument_list|,
name|np
operator|->
name|rv_dcntl
operator||
name|STD
argument_list|)
expr_stmt|;
return|return;
block|}
empty_stmt|;
comment|/* **	@RECOVER@ HTH, SGE, ABRT. ** **	We should try to recover from these interrupts. **	They may occur if there are problems with synch transfers, or  **	if targets are switched on or off while the driver is running. */
if|if
condition|(
name|sist
operator|&
name|SGE
condition|)
block|{
comment|/* clear scsi offsets */
name|OUTB
argument_list|(
name|nc_ctest3
argument_list|,
name|np
operator|->
name|rv_ctest3
operator||
name|CLF
argument_list|)
expr_stmt|;
block|}
comment|/* 	**	Freeze controller to be able to read the messages. 	*/
if|if
condition|(
name|DEBUG_FLAGS
operator|&
name|DEBUG_FREEZE
condition|)
block|{
name|int
name|i
decl_stmt|;
name|unsigned
name|char
name|val
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|0x60
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
name|i
operator|%
literal|16
condition|)
block|{
case|case
literal|0
case|:
name|printf
argument_list|(
literal|"%s: reg[%d0]: "
argument_list|,
name|ncr_name
argument_list|(
name|np
argument_list|)
argument_list|,
name|i
operator|/
literal|16
argument_list|)
expr_stmt|;
break|break;
case|case
literal|4
case|:
case|case
literal|8
case|:
case|case
literal|12
case|:
name|printf
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
break|break;
block|}
empty_stmt|;
name|val
operator|=
name|bus_space_read_1
argument_list|(
name|np
operator|->
name|bst
argument_list|,
name|np
operator|->
name|bsh
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" %x%x"
argument_list|,
name|val
operator|/
literal|16
argument_list|,
name|val
operator|%
literal|16
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|%
literal|16
operator|==
literal|15
condition|)
name|printf
argument_list|(
literal|".\n"
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
name|untimeout
argument_list|(
name|ncr_timeout
argument_list|,
operator|(
name|caddr_t
operator|)
name|np
argument_list|,
name|np
operator|->
name|timeout_ch
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s: halted!\n"
argument_list|,
name|ncr_name
argument_list|(
name|np
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 		**	don't restart controller ... 		*/
name|OUTB
argument_list|(
name|nc_istat
argument_list|,
name|SRST
argument_list|)
expr_stmt|;
return|return;
block|}
empty_stmt|;
ifdef|#
directive|ifdef
name|NCR_FREEZE
comment|/* 	**	Freeze system to be able to read the messages. 	*/
name|printf
argument_list|(
literal|"ncr: fatal error: system halted - press reset to reboot ..."
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|splhigh
argument_list|()
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
empty_stmt|;
endif|#
directive|endif
comment|/* 	**	sorry, have to kill ALL jobs ... 	*/
name|ncr_init
argument_list|(
name|np
argument_list|,
literal|"fatal error"
argument_list|,
name|HS_FAIL
argument_list|)
expr_stmt|;
block|}
comment|/*========================================================== ** **	ncr chip exception handler for selection timeout ** **========================================================== ** **	There seems to be a bug in the 53c810. **	Although a STO-Interrupt is pending, **	it continues executing script commands. **	But it will fail and interrupt (IID) on **	the next instruction where it's looking **	for a valid phase. ** **---------------------------------------------------------- */
specifier|static
name|void
name|ncr_int_sto
parameter_list|(
name|ncb_p
name|np
parameter_list|)
block|{
name|u_long
name|dsa
decl_stmt|,
name|scratcha
decl_stmt|,
name|diff
decl_stmt|;
name|nccb_p
name|cp
decl_stmt|;
if|if
condition|(
name|DEBUG_FLAGS
operator|&
name|DEBUG_TINY
condition|)
name|printf
argument_list|(
literal|"T"
argument_list|)
expr_stmt|;
comment|/* 	**	look for nccb and set the status. 	*/
name|dsa
operator|=
name|INL
argument_list|(
name|nc_dsa
argument_list|)
expr_stmt|;
name|cp
operator|=
name|np
operator|->
name|link_nccb
expr_stmt|;
while|while
condition|(
name|cp
operator|&&
operator|(
name|CCB_PHYS
argument_list|(
name|cp
argument_list|,
name|phys
argument_list|)
operator|!=
name|dsa
operator|)
condition|)
name|cp
operator|=
name|cp
operator|->
name|link_nccb
expr_stmt|;
if|if
condition|(
name|cp
condition|)
block|{
name|cp
operator|->
name|host_status
operator|=
name|HS_SEL_TIMEOUT
expr_stmt|;
name|ncr_complete
argument_list|(
name|np
argument_list|,
name|cp
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
comment|/* 	**	repair start queue 	*/
name|scratcha
operator|=
name|INL
argument_list|(
name|nc_scratcha
argument_list|)
expr_stmt|;
name|diff
operator|=
name|scratcha
operator|-
name|NCB_SCRIPTH_PHYS
argument_list|(
name|np
argument_list|,
name|tryloop
argument_list|)
expr_stmt|;
comment|/*	assert ((diff<= MAX_START * 20)&& !(diff % 20));*/
if|if
condition|(
operator|(
name|diff
operator|<=
name|MAX_START
operator|*
literal|20
operator|)
operator|&&
operator|!
operator|(
name|diff
operator|%
literal|20
operator|)
condition|)
block|{
name|WRITESCRIPT
argument_list|(
name|startpos
index|[
literal|0
index|]
argument_list|,
name|scratcha
argument_list|)
expr_stmt|;
name|OUTL
argument_list|(
name|nc_dsp
argument_list|,
name|NCB_SCRIPT_PHYS
argument_list|(
name|np
argument_list|,
name|start
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
empty_stmt|;
name|ncr_init
argument_list|(
name|np
argument_list|,
literal|"selection timeout"
argument_list|,
name|HS_FAIL
argument_list|)
expr_stmt|;
block|}
comment|/*========================================================== ** ** **	ncr chip exception handler for phase errors. ** ** **========================================================== ** **	We have to construct a new transfer descriptor, **	to transfer the rest of the current block. ** **---------------------------------------------------------- */
specifier|static
name|void
name|ncr_int_ma
parameter_list|(
name|ncb_p
name|np
parameter_list|,
name|u_char
name|dstat
parameter_list|)
block|{
name|u_int32_t
name|dbc
decl_stmt|;
name|u_int32_t
name|rest
decl_stmt|;
name|u_int32_t
name|dsa
decl_stmt|;
name|u_int32_t
name|dsp
decl_stmt|;
name|u_int32_t
name|nxtdsp
decl_stmt|;
specifier|volatile
name|void
modifier|*
name|vdsp_base
decl_stmt|;
name|size_t
name|vdsp_off
decl_stmt|;
name|u_int32_t
name|oadr
decl_stmt|,
name|olen
decl_stmt|;
name|u_int32_t
modifier|*
name|tblp
decl_stmt|,
modifier|*
name|newcmd
decl_stmt|;
name|u_char
name|cmd
decl_stmt|,
name|sbcl
decl_stmt|,
name|ss0
decl_stmt|,
name|ss2
decl_stmt|,
name|ctest5
decl_stmt|;
name|u_short
name|delta
decl_stmt|;
name|nccb_p
name|cp
decl_stmt|;
name|dsp
operator|=
name|INL
argument_list|(
name|nc_dsp
argument_list|)
expr_stmt|;
name|dsa
operator|=
name|INL
argument_list|(
name|nc_dsa
argument_list|)
expr_stmt|;
name|dbc
operator|=
name|INL
argument_list|(
name|nc_dbc
argument_list|)
expr_stmt|;
name|ss0
operator|=
name|INB
argument_list|(
name|nc_sstat0
argument_list|)
expr_stmt|;
name|ss2
operator|=
name|INB
argument_list|(
name|nc_sstat2
argument_list|)
expr_stmt|;
name|sbcl
operator|=
name|INB
argument_list|(
name|nc_sbcl
argument_list|)
expr_stmt|;
name|cmd
operator|=
name|dbc
operator|>>
literal|24
expr_stmt|;
name|rest
operator|=
name|dbc
operator|&
literal|0xffffff
expr_stmt|;
name|ctest5
operator|=
operator|(
name|np
operator|->
name|rv_ctest5
operator|&
name|DFS
operator|)
condition|?
name|INB
argument_list|(
name|nc_ctest5
argument_list|)
else|:
literal|0
expr_stmt|;
if|if
condition|(
name|ctest5
operator|&
name|DFS
condition|)
name|delta
operator|=
operator|(
operator|(
operator|(
name|ctest5
operator|<<
literal|8
operator|)
operator||
operator|(
name|INB
argument_list|(
name|nc_dfifo
argument_list|)
operator|&
literal|0xff
operator|)
operator|)
operator|-
name|rest
operator|)
operator|&
literal|0x3ff
expr_stmt|;
else|else
name|delta
operator|=
operator|(
name|INB
argument_list|(
name|nc_dfifo
argument_list|)
operator|-
name|rest
operator|)
operator|&
literal|0x7f
expr_stmt|;
comment|/* 	**	The data in the dma fifo has not been transfered to 	**	the target -> add the amount to the rest 	**	and clear the data. 	**	Check the sstat2 register in case of wide transfer. 	*/
if|if
condition|(
operator|!
operator|(
name|dstat
operator|&
name|DFE
operator|)
condition|)
name|rest
operator|+=
name|delta
expr_stmt|;
if|if
condition|(
name|ss0
operator|&
name|OLF
condition|)
name|rest
operator|++
expr_stmt|;
if|if
condition|(
name|ss0
operator|&
name|ORF
condition|)
name|rest
operator|++
expr_stmt|;
if|if
condition|(
name|INB
argument_list|(
name|nc_scntl3
argument_list|)
operator|&
name|EWS
condition|)
block|{
if|if
condition|(
name|ss2
operator|&
name|OLF1
condition|)
name|rest
operator|++
expr_stmt|;
if|if
condition|(
name|ss2
operator|&
name|ORF1
condition|)
name|rest
operator|++
expr_stmt|;
block|}
empty_stmt|;
name|OUTB
argument_list|(
name|nc_ctest3
argument_list|,
name|np
operator|->
name|rv_ctest3
operator||
name|CLF
argument_list|)
expr_stmt|;
comment|/* clear dma fifo  */
name|OUTB
argument_list|(
name|nc_stest3
argument_list|,
name|TE
operator||
name|CSF
argument_list|)
expr_stmt|;
comment|/* clear scsi fifo */
comment|/* 	**	locate matching cp 	*/
name|cp
operator|=
name|np
operator|->
name|link_nccb
expr_stmt|;
while|while
condition|(
name|cp
operator|&&
operator|(
name|CCB_PHYS
argument_list|(
name|cp
argument_list|,
name|phys
argument_list|)
operator|!=
name|dsa
operator|)
condition|)
name|cp
operator|=
name|cp
operator|->
name|link_nccb
expr_stmt|;
if|if
condition|(
operator|!
name|cp
condition|)
block|{
name|printf
argument_list|(
literal|"%s: SCSI phase error fixup: CCB already dequeued (%p)\n"
argument_list|,
name|ncr_name
argument_list|(
name|np
argument_list|)
argument_list|,
operator|(
name|void
operator|*
operator|)
name|np
operator|->
name|header
operator|.
name|cp
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|cp
operator|!=
name|np
operator|->
name|header
operator|.
name|cp
condition|)
block|{
name|printf
argument_list|(
literal|"%s: SCSI phase error fixup: CCB address mismatch "
literal|"(%p != %p) np->nccb = %p\n"
argument_list|,
name|ncr_name
argument_list|(
name|np
argument_list|)
argument_list|,
operator|(
name|void
operator|*
operator|)
name|cp
argument_list|,
operator|(
name|void
operator|*
operator|)
name|np
operator|->
name|header
operator|.
name|cp
argument_list|,
operator|(
name|void
operator|*
operator|)
name|np
operator|->
name|link_nccb
argument_list|)
expr_stmt|;
comment|/*	    return;*/
block|}
comment|/* 	**	find the interrupted script command, 	**	and the address at which to continue. 	*/
if|if
condition|(
name|dsp
operator|==
name|vtophys
argument_list|(
operator|&
name|cp
operator|->
name|patch
index|[
literal|2
index|]
argument_list|)
condition|)
block|{
name|vdsp_base
operator|=
name|cp
expr_stmt|;
name|vdsp_off
operator|=
name|offsetof
argument_list|(
expr|struct
name|nccb
argument_list|,
name|patch
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|nxtdsp
operator|=
name|READSCRIPT_OFF
argument_list|(
name|vdsp_base
argument_list|,
name|vdsp_off
operator|+
literal|3
operator|*
literal|4
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dsp
operator|==
name|vtophys
argument_list|(
operator|&
name|cp
operator|->
name|patch
index|[
literal|6
index|]
argument_list|)
condition|)
block|{
name|vdsp_base
operator|=
name|cp
expr_stmt|;
name|vdsp_off
operator|=
name|offsetof
argument_list|(
expr|struct
name|nccb
argument_list|,
name|patch
index|[
literal|4
index|]
argument_list|)
expr_stmt|;
name|nxtdsp
operator|=
name|READSCRIPT_OFF
argument_list|(
name|vdsp_base
argument_list|,
name|vdsp_off
operator|+
literal|3
operator|*
literal|4
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dsp
operator|>
name|np
operator|->
name|p_script
operator|&&
name|dsp
operator|<=
name|np
operator|->
name|p_script
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|script
argument_list|)
condition|)
block|{
name|vdsp_base
operator|=
name|np
operator|->
name|script
expr_stmt|;
name|vdsp_off
operator|=
name|dsp
operator|-
name|np
operator|->
name|p_script
operator|-
literal|8
expr_stmt|;
name|nxtdsp
operator|=
name|dsp
expr_stmt|;
block|}
else|else
block|{
name|vdsp_base
operator|=
name|np
operator|->
name|scripth
expr_stmt|;
name|vdsp_off
operator|=
name|dsp
operator|-
name|np
operator|->
name|p_scripth
operator|-
literal|8
expr_stmt|;
name|nxtdsp
operator|=
name|dsp
expr_stmt|;
block|}
empty_stmt|;
comment|/* 	**	log the information 	*/
if|if
condition|(
name|DEBUG_FLAGS
operator|&
operator|(
name|DEBUG_TINY
operator||
name|DEBUG_PHASE
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"P%x%x "
argument_list|,
name|cmd
operator|&
literal|7
argument_list|,
name|sbcl
operator|&
literal|7
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"RL=%d D=%d SS0=%x "
argument_list|,
operator|(
name|unsigned
operator|)
name|rest
argument_list|,
operator|(
name|unsigned
operator|)
name|delta
argument_list|,
name|ss0
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
if|if
condition|(
name|DEBUG_FLAGS
operator|&
name|DEBUG_PHASE
condition|)
block|{
name|printf
argument_list|(
literal|"\nCP=%p CP2=%p DSP=%x NXT=%x VDSP=%p CMD=%x "
argument_list|,
name|cp
argument_list|,
name|np
operator|->
name|header
operator|.
name|cp
argument_list|,
name|dsp
argument_list|,
name|nxtdsp
argument_list|,
operator|(
specifier|volatile
name|char
operator|*
operator|)
name|vdsp_base
operator|+
name|vdsp_off
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
comment|/* 	**	get old startaddress and old length. 	*/
name|oadr
operator|=
name|READSCRIPT_OFF
argument_list|(
name|vdsp_base
argument_list|,
name|vdsp_off
operator|+
literal|1
operator|*
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmd
operator|&
literal|0x10
condition|)
block|{
comment|/* Table indirect */
name|tblp
operator|=
operator|(
name|u_int32_t
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
operator|&
name|cp
operator|->
name|phys
operator|+
name|oadr
operator|)
expr_stmt|;
name|olen
operator|=
name|tblp
index|[
literal|0
index|]
expr_stmt|;
name|oadr
operator|=
name|tblp
index|[
literal|1
index|]
expr_stmt|;
block|}
else|else
block|{
name|tblp
operator|=
operator|(
name|u_int32_t
operator|*
operator|)
literal|0
expr_stmt|;
name|olen
operator|=
name|READSCRIPT_OFF
argument_list|(
name|vdsp_base
argument_list|,
name|vdsp_off
argument_list|)
operator|&
literal|0xffffff
expr_stmt|;
block|}
empty_stmt|;
if|if
condition|(
name|DEBUG_FLAGS
operator|&
name|DEBUG_PHASE
condition|)
block|{
name|printf
argument_list|(
literal|"OCMD=%x\nTBLP=%p OLEN=%lx OADR=%lx\n"
argument_list|,
call|(
name|unsigned
call|)
argument_list|(
name|READSCRIPT_OFF
argument_list|(
name|vdsp_base
argument_list|,
name|vdsp_off
argument_list|)
operator|>>
literal|24
argument_list|)
argument_list|,
operator|(
name|void
operator|*
operator|)
name|tblp
argument_list|,
operator|(
name|u_long
operator|)
name|olen
argument_list|,
operator|(
name|u_long
operator|)
name|oadr
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
comment|/* 	**	if old phase not dataphase, leave here. 	*/
if|if
condition|(
name|cmd
operator|!=
operator|(
name|READSCRIPT_OFF
argument_list|(
name|vdsp_base
argument_list|,
name|vdsp_off
argument_list|)
operator|>>
literal|24
operator|)
condition|)
block|{
name|PRINT_ADDR
argument_list|(
name|cp
operator|->
name|ccb
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"internal error: cmd=%02x != %02x=(vdsp[0]>> 24)\n"
argument_list|,
operator|(
name|unsigned
operator|)
name|cmd
argument_list|,
operator|(
name|unsigned
operator|)
name|READSCRIPT_OFF
argument_list|(
name|vdsp_base
argument_list|,
name|vdsp_off
argument_list|)
operator|>>
literal|24
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|cmd
operator|&
literal|0x06
condition|)
block|{
name|PRINT_ADDR
argument_list|(
name|cp
operator|->
name|ccb
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"phase change %x-%x %d@%08x resid=%d.\n"
argument_list|,
name|cmd
operator|&
literal|7
argument_list|,
name|sbcl
operator|&
literal|7
argument_list|,
operator|(
name|unsigned
operator|)
name|olen
argument_list|,
operator|(
name|unsigned
operator|)
name|oadr
argument_list|,
operator|(
name|unsigned
operator|)
name|rest
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
name|nc_dcntl
argument_list|,
name|np
operator|->
name|rv_dcntl
operator||
name|STD
argument_list|)
expr_stmt|;
return|return;
block|}
empty_stmt|;
comment|/* 	**	choose the correct patch area. 	**	if savep points to one, choose the other. 	*/
name|newcmd
operator|=
name|cp
operator|->
name|patch
expr_stmt|;
if|if
condition|(
name|cp
operator|->
name|phys
operator|.
name|header
operator|.
name|savep
operator|==
name|vtophys
argument_list|(
name|newcmd
argument_list|)
condition|)
name|newcmd
operator|+=
literal|4
expr_stmt|;
comment|/* 	**	fillin the commands 	*/
name|newcmd
index|[
literal|0
index|]
operator|=
operator|(
operator|(
name|cmd
operator|&
literal|0x0f
operator|)
operator|<<
literal|24
operator|)
operator||
name|rest
expr_stmt|;
name|newcmd
index|[
literal|1
index|]
operator|=
name|oadr
operator|+
name|olen
operator|-
name|rest
expr_stmt|;
name|newcmd
index|[
literal|2
index|]
operator|=
name|SCR_JUMP
expr_stmt|;
name|newcmd
index|[
literal|3
index|]
operator|=
name|nxtdsp
expr_stmt|;
if|if
condition|(
name|DEBUG_FLAGS
operator|&
name|DEBUG_PHASE
condition|)
block|{
name|PRINT_ADDR
argument_list|(
name|cp
operator|->
name|ccb
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"newcmd[%d] %x %x %x %x.\n"
argument_list|,
call|(
name|int
call|)
argument_list|(
name|newcmd
operator|-
name|cp
operator|->
name|patch
argument_list|)
argument_list|,
operator|(
name|unsigned
operator|)
name|newcmd
index|[
literal|0
index|]
argument_list|,
operator|(
name|unsigned
operator|)
name|newcmd
index|[
literal|1
index|]
argument_list|,
operator|(
name|unsigned
operator|)
name|newcmd
index|[
literal|2
index|]
argument_list|,
operator|(
name|unsigned
operator|)
name|newcmd
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* 	**	fake the return address (to the patch). 	**	and restart script processor at dispatcher. 	*/
name|np
operator|->
name|profile
operator|.
name|num_break
operator|++
expr_stmt|;
name|OUTL
argument_list|(
name|nc_temp
argument_list|,
name|vtophys
argument_list|(
name|newcmd
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cmd
operator|&
literal|7
operator|)
operator|==
literal|0
condition|)
name|OUTL
argument_list|(
name|nc_dsp
argument_list|,
name|NCB_SCRIPT_PHYS
argument_list|(
name|np
argument_list|,
name|dispatch
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|OUTL
argument_list|(
name|nc_dsp
argument_list|,
name|NCB_SCRIPT_PHYS
argument_list|(
name|np
argument_list|,
name|checkatn
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/*========================================================== ** ** **      ncr chip exception handler for programmed interrupts. ** ** **========================================================== */
specifier|static
name|int
name|ncr_show_msg
parameter_list|(
name|u_char
modifier|*
name|msg
parameter_list|)
block|{
name|u_char
name|i
decl_stmt|;
name|printf
argument_list|(
literal|"%x"
argument_list|,
operator|*
name|msg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|msg
operator|==
name|MSG_EXTENDED
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|-
literal|1
operator|>
name|msg
index|[
literal|1
index|]
condition|)
break|break;
name|printf
argument_list|(
literal|"-%x"
argument_list|,
name|msg
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
return|return
operator|(
name|i
operator|+
literal|1
operator|)
return|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|*
name|msg
operator|&
literal|0xf0
operator|)
operator|==
literal|0x20
condition|)
block|{
name|printf
argument_list|(
literal|"-%x"
argument_list|,
name|msg
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
literal|2
operator|)
return|;
block|}
empty_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
specifier|static
name|void
name|ncr_int_sir
parameter_list|(
name|ncb_p
name|np
parameter_list|)
block|{
name|u_char
name|scntl3
decl_stmt|;
name|u_char
name|chg
decl_stmt|,
name|ofs
decl_stmt|,
name|per
decl_stmt|,
name|fak
decl_stmt|,
name|wide
decl_stmt|;
name|u_char
name|num
init|=
name|INB
argument_list|(
name|nc_dsps
argument_list|)
decl_stmt|;
name|nccb_p
name|cp
init|=
literal|0
decl_stmt|;
name|u_long
name|dsa
decl_stmt|;
name|u_int
name|target
init|=
name|INB
argument_list|(
name|nc_sdid
argument_list|)
operator|&
literal|0x0f
decl_stmt|;
name|tcb_p
name|tp
init|=
operator|&
name|np
operator|->
name|target
index|[
name|target
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|DEBUG_FLAGS
operator|&
name|DEBUG_TINY
condition|)
name|printf
argument_list|(
literal|"I#%d"
argument_list|,
name|num
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|num
condition|)
block|{
case|case
name|SIR_SENSE_RESTART
case|:
case|case
name|SIR_STALL_RESTART
case|:
break|break;
default|default:
comment|/* 		**	lookup the nccb 		*/
name|dsa
operator|=
name|INL
argument_list|(
name|nc_dsa
argument_list|)
expr_stmt|;
name|cp
operator|=
name|np
operator|->
name|link_nccb
expr_stmt|;
while|while
condition|(
name|cp
operator|&&
operator|(
name|CCB_PHYS
argument_list|(
name|cp
argument_list|,
name|phys
argument_list|)
operator|!=
name|dsa
operator|)
condition|)
name|cp
operator|=
name|cp
operator|->
name|link_nccb
expr_stmt|;
name|assert
argument_list|(
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cp
condition|)
goto|goto
name|out
goto|;
name|assert
argument_list|(
name|cp
operator|==
name|np
operator|->
name|header
operator|.
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|!=
name|np
operator|->
name|header
operator|.
name|cp
condition|)
goto|goto
name|out
goto|;
block|}
switch|switch
condition|(
name|num
condition|)
block|{
comment|/*-------------------------------------------------------------------- ** **	Processing of interrupted getcc selects ** **-------------------------------------------------------------------- */
case|case
name|SIR_SENSE_RESTART
case|:
comment|/*------------------------------------------ 		**	Script processor is idle. 		**	Look for interrupted "check cond" 		**------------------------------------------ 		*/
if|if
condition|(
name|DEBUG_FLAGS
operator|&
name|DEBUG_RESTART
condition|)
name|printf
argument_list|(
literal|"%s: int#%d"
argument_list|,
name|ncr_name
argument_list|(
name|np
argument_list|)
argument_list|,
name|num
argument_list|)
expr_stmt|;
name|cp
operator|=
operator|(
name|nccb_p
operator|)
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_TARGET
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|DEBUG_FLAGS
operator|&
name|DEBUG_RESTART
condition|)
name|printf
argument_list|(
literal|" t%d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|tp
operator|=
operator|&
name|np
operator|->
name|target
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|DEBUG_FLAGS
operator|&
name|DEBUG_RESTART
condition|)
name|printf
argument_list|(
literal|"+"
argument_list|)
expr_stmt|;
name|cp
operator|=
name|tp
operator|->
name|hold_cp
expr_stmt|;
if|if
condition|(
operator|!
name|cp
condition|)
continue|continue;
if|if
condition|(
name|DEBUG_FLAGS
operator|&
name|DEBUG_RESTART
condition|)
name|printf
argument_list|(
literal|"+"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cp
operator|->
name|host_status
operator|==
name|HS_BUSY
operator|)
operator|&&
operator|(
name|cp
operator|->
name|s_status
operator|==
name|SCSI_STATUS_CHECK_COND
operator|)
condition|)
break|break;
if|if
condition|(
name|DEBUG_FLAGS
operator|&
name|DEBUG_RESTART
condition|)
name|printf
argument_list|(
literal|"- (remove)"
argument_list|)
expr_stmt|;
name|tp
operator|->
name|hold_cp
operator|=
name|cp
operator|=
operator|(
name|nccb_p
operator|)
literal|0
expr_stmt|;
block|}
empty_stmt|;
if|if
condition|(
name|cp
condition|)
block|{
if|if
condition|(
name|DEBUG_FLAGS
operator|&
name|DEBUG_RESTART
condition|)
name|printf
argument_list|(
literal|"+ restart job ..\n"
argument_list|)
expr_stmt|;
name|OUTL
argument_list|(
name|nc_dsa
argument_list|,
name|CCB_PHYS
argument_list|(
name|cp
argument_list|,
name|phys
argument_list|)
argument_list|)
expr_stmt|;
name|OUTL
argument_list|(
name|nc_dsp
argument_list|,
name|NCB_SCRIPTH_PHYS
argument_list|(
name|np
argument_list|,
name|getcc
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
empty_stmt|;
comment|/* 		**	no job, resume normal processing 		*/
if|if
condition|(
name|DEBUG_FLAGS
operator|&
name|DEBUG_RESTART
condition|)
name|printf
argument_list|(
literal|" -- remove trap\n"
argument_list|)
expr_stmt|;
name|WRITESCRIPT
argument_list|(
name|start0
index|[
literal|0
index|]
argument_list|,
name|SCR_INT
operator|^
name|IFFALSE
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIR_SENSE_FAILED
case|:
comment|/*------------------------------------------- 		**	While trying to select for 		**	getting the condition code, 		**	a target reselected us. 		**------------------------------------------- 		*/
if|if
condition|(
name|DEBUG_FLAGS
operator|&
name|DEBUG_RESTART
condition|)
block|{
name|PRINT_ADDR
argument_list|(
name|cp
operator|->
name|ccb
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"in getcc reselect by t%d.\n"
argument_list|,
name|INB
argument_list|(
name|nc_ssid
argument_list|)
operator|&
literal|0x0f
argument_list|)
expr_stmt|;
block|}
comment|/* 		**	Mark this job 		*/
name|cp
operator|->
name|host_status
operator|=
name|HS_BUSY
expr_stmt|;
name|cp
operator|->
name|s_status
operator|=
name|SCSI_STATUS_CHECK_COND
expr_stmt|;
name|np
operator|->
name|target
index|[
name|cp
operator|->
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
index|]
operator|.
name|hold_cp
operator|=
name|cp
expr_stmt|;
comment|/* 		**	And patch code to restart it. 		*/
name|WRITESCRIPT
argument_list|(
name|start0
index|[
literal|0
index|]
argument_list|,
name|SCR_INT
argument_list|)
expr_stmt|;
break|break;
comment|/*----------------------------------------------------------------------------- ** **	Was Sie schon immer ueber transfermode negotiation wissen wollten ... ** **	We try to negotiate sync and wide transfer only after **	a successfull inquire command. We look at byte 7 of the **	inquire data to determine the capabilities if the target. ** **	When we try to negotiate, we append the negotiation message **	to the identify and (maybe) simple tag message. **	The host status field is set to HS_NEGOTIATE to mark this **	situation. ** **	If the target doesn't answer this message immidiately **	(as required by the standard), the SIR_NEGO_FAIL interrupt **	will be raised eventually. **	The handler removes the HS_NEGOTIATE status, and sets the **	negotiated value to the default (async / nowide). ** **	If we receive a matching answer immediately, we check it **	for validity, and set the values. ** **	If we receive a Reject message immediately, we assume the **	negotiation has failed, and fall back to standard values. ** **	If we receive a negotiation message while not in HS_NEGOTIATE **	state, it's a target initiated negotiation. We prepare a **	(hopefully) valid answer, set our parameters, and send back  **	this answer to the target. ** **	If the target doesn't fetch the answer (no message out phase), **	we assume the negotiation has failed, and fall back to default **	settings. ** **	When we set the values, we adjust them in all nccbs belonging  **	to this target, in the controller's register, and in the "phys" **	field of the controller's struct ncb. ** **	Possible cases:		   hs  sir   msg_in value  send   goto **	We try try to negotiate: **	-> target doesnt't msgin   NEG FAIL  noop   defa.  -      dispatch **	-> target rejected our msg NEG FAIL  reject defa.  -      dispatch **	-> target answered  (ok)   NEG SYNC  sdtr   set    -      clrack **	-> target answered (!ok)   NEG SYNC  sdtr   defa.  REJ--->msg_bad **	-> target answered  (ok)   NEG WIDE  wdtr   set    -      clrack **	-> target answered (!ok)   NEG WIDE  wdtr   defa.  REJ--->msg_bad **	-> any other msgin	   NEG FAIL  noop   defa.  -      dispatch ** **	Target tries to negotiate: **	-> incoming message	   --- SYNC  sdtr   set    SDTR   - **	-> incoming message	   --- WIDE  wdtr   set    WDTR   - **      We sent our answer: **	-> target doesn't msgout   --- PROTO ?      defa.  -      dispatch ** **----------------------------------------------------------------------------- */
case|case
name|SIR_NEGO_FAILED
case|:
comment|/*------------------------------------------------------- 		** 		**	Negotiation failed. 		**	Target doesn't send an answer message, 		**	or target rejected our message. 		** 		**      Remove negotiation request. 		** 		**------------------------------------------------------- 		*/
name|OUTB
argument_list|(
name|HS_PRT
argument_list|,
name|HS_BUSY
argument_list|)
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
name|SIR_NEGO_PROTO
case|:
comment|/*------------------------------------------------------- 		** 		**	Negotiation failed. 		**	Target doesn't fetch the answer message. 		** 		**------------------------------------------------------- 		*/
if|if
condition|(
name|DEBUG_FLAGS
operator|&
name|DEBUG_NEGO
condition|)
block|{
name|PRINT_ADDR
argument_list|(
name|cp
operator|->
name|ccb
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"negotiation failed sir=%x status=%x.\n"
argument_list|,
name|num
argument_list|,
name|cp
operator|->
name|nego_status
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
comment|/* 		**	any error in negotiation: 		**	fall back to default mode. 		*/
switch|switch
condition|(
name|cp
operator|->
name|nego_status
condition|)
block|{
case|case
name|NS_SYNC
case|:
name|ncr_setsync
argument_list|(
name|np
argument_list|,
name|cp
argument_list|,
literal|0
argument_list|,
literal|0xe0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|NS_WIDE
case|:
name|ncr_setwide
argument_list|(
name|np
argument_list|,
name|cp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
empty_stmt|;
name|np
operator|->
name|msgin
index|[
literal|0
index|]
operator|=
name|MSG_NOOP
expr_stmt|;
name|np
operator|->
name|msgout
index|[
literal|0
index|]
operator|=
name|MSG_NOOP
expr_stmt|;
name|cp
operator|->
name|nego_status
operator|=
literal|0
expr_stmt|;
name|OUTL
argument_list|(
name|nc_dsp
argument_list|,
name|NCB_SCRIPT_PHYS
argument_list|(
name|np
argument_list|,
name|dispatch
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIR_NEGO_SYNC
case|:
comment|/* 		**	Synchronous request message received. 		*/
if|if
condition|(
name|DEBUG_FLAGS
operator|&
name|DEBUG_NEGO
condition|)
block|{
name|PRINT_ADDR
argument_list|(
name|cp
operator|->
name|ccb
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"sync msgin: "
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|ncr_show_msg
argument_list|(
name|np
operator|->
name|msgin
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|".\n"
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
comment|/* 		**	get requested values. 		*/
name|chg
operator|=
literal|0
expr_stmt|;
name|per
operator|=
name|np
operator|->
name|msgin
index|[
literal|3
index|]
expr_stmt|;
name|ofs
operator|=
name|np
operator|->
name|msgin
index|[
literal|4
index|]
expr_stmt|;
if|if
condition|(
name|ofs
operator|==
literal|0
condition|)
name|per
operator|=
literal|255
expr_stmt|;
comment|/* 		**	check values against driver limits. 		*/
if|if
condition|(
name|per
operator|<
name|np
operator|->
name|minsync
condition|)
block|{
name|chg
operator|=
literal|1
expr_stmt|;
name|per
operator|=
name|np
operator|->
name|minsync
expr_stmt|;
block|}
if|if
condition|(
name|per
operator|<
name|tp
operator|->
name|tinfo
operator|.
name|user
operator|.
name|period
condition|)
block|{
name|chg
operator|=
literal|1
expr_stmt|;
name|per
operator|=
name|tp
operator|->
name|tinfo
operator|.
name|user
operator|.
name|period
expr_stmt|;
block|}
if|if
condition|(
name|ofs
operator|>
name|tp
operator|->
name|tinfo
operator|.
name|user
operator|.
name|offset
condition|)
block|{
name|chg
operator|=
literal|1
expr_stmt|;
name|ofs
operator|=
name|tp
operator|->
name|tinfo
operator|.
name|user
operator|.
name|offset
expr_stmt|;
block|}
comment|/* 		**	Check against controller limits. 		*/
name|fak
operator|=
literal|7
expr_stmt|;
name|scntl3
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ofs
operator|!=
literal|0
condition|)
block|{
name|ncr_getsync
argument_list|(
name|np
argument_list|,
name|per
argument_list|,
operator|&
name|fak
argument_list|,
operator|&
name|scntl3
argument_list|)
expr_stmt|;
if|if
condition|(
name|fak
operator|>
literal|7
condition|)
block|{
name|chg
operator|=
literal|1
expr_stmt|;
name|ofs
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ofs
operator|==
literal|0
condition|)
block|{
name|fak
operator|=
literal|7
expr_stmt|;
name|per
operator|=
literal|0
expr_stmt|;
name|scntl3
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|DEBUG_FLAGS
operator|&
name|DEBUG_NEGO
condition|)
block|{
name|PRINT_ADDR
argument_list|(
name|cp
operator|->
name|ccb
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"sync: per=%d scntl3=0x%x ofs=%d fak=%d chg=%d.\n"
argument_list|,
name|per
argument_list|,
name|scntl3
argument_list|,
name|ofs
argument_list|,
name|fak
argument_list|,
name|chg
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|INB
argument_list|(
name|HS_PRT
argument_list|)
operator|==
name|HS_NEGOTIATE
condition|)
block|{
name|OUTB
argument_list|(
name|HS_PRT
argument_list|,
name|HS_BUSY
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|cp
operator|->
name|nego_status
condition|)
block|{
case|case
name|NS_SYNC
case|:
comment|/* 				**      This was an answer message 				*/
if|if
condition|(
name|chg
condition|)
block|{
comment|/* 					**	Answer wasn't acceptable. 					*/
name|ncr_setsync
argument_list|(
name|np
argument_list|,
name|cp
argument_list|,
literal|0
argument_list|,
literal|0xe0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OUTL
argument_list|(
name|nc_dsp
argument_list|,
name|NCB_SCRIPT_PHYS
argument_list|(
name|np
argument_list|,
name|msg_bad
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 					**	Answer is ok. 					*/
name|ncr_setsync
argument_list|(
name|np
argument_list|,
name|cp
argument_list|,
name|scntl3
argument_list|,
operator|(
name|fak
operator|<<
literal|5
operator|)
operator||
name|ofs
argument_list|,
name|per
argument_list|)
expr_stmt|;
name|OUTL
argument_list|(
name|nc_dsp
argument_list|,
name|NCB_SCRIPT_PHYS
argument_list|(
name|np
argument_list|,
name|clrack
argument_list|)
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
return|return;
case|case
name|NS_WIDE
case|:
name|ncr_setwide
argument_list|(
name|np
argument_list|,
name|cp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
empty_stmt|;
block|}
empty_stmt|;
comment|/* 		**	It was a request. Set value and 		**      prepare an answer message 		*/
name|ncr_setsync
argument_list|(
name|np
argument_list|,
name|cp
argument_list|,
name|scntl3
argument_list|,
operator|(
name|fak
operator|<<
literal|5
operator|)
operator||
name|ofs
argument_list|,
name|per
argument_list|)
expr_stmt|;
name|np
operator|->
name|msgout
index|[
literal|0
index|]
operator|=
name|MSG_EXTENDED
expr_stmt|;
name|np
operator|->
name|msgout
index|[
literal|1
index|]
operator|=
literal|3
expr_stmt|;
name|np
operator|->
name|msgout
index|[
literal|2
index|]
operator|=
name|MSG_EXT_SDTR
expr_stmt|;
name|np
operator|->
name|msgout
index|[
literal|3
index|]
operator|=
name|per
expr_stmt|;
name|np
operator|->
name|msgout
index|[
literal|4
index|]
operator|=
name|ofs
expr_stmt|;
name|cp
operator|->
name|nego_status
operator|=
name|NS_SYNC
expr_stmt|;
if|if
condition|(
name|DEBUG_FLAGS
operator|&
name|DEBUG_NEGO
condition|)
block|{
name|PRINT_ADDR
argument_list|(
name|cp
operator|->
name|ccb
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"sync msgout: "
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|ncr_show_msg
argument_list|(
name|np
operator|->
name|msgout
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|".\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|ofs
condition|)
block|{
name|OUTL
argument_list|(
name|nc_dsp
argument_list|,
name|NCB_SCRIPT_PHYS
argument_list|(
name|np
argument_list|,
name|msg_bad
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|np
operator|->
name|msgin
index|[
literal|0
index|]
operator|=
name|MSG_NOOP
expr_stmt|;
break|break;
case|case
name|SIR_NEGO_WIDE
case|:
comment|/* 		**	Wide request message received. 		*/
if|if
condition|(
name|DEBUG_FLAGS
operator|&
name|DEBUG_NEGO
condition|)
block|{
name|PRINT_ADDR
argument_list|(
name|cp
operator|->
name|ccb
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"wide msgin: "
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|ncr_show_msg
argument_list|(
name|np
operator|->
name|msgin
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|".\n"
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
comment|/* 		**	get requested values. 		*/
name|chg
operator|=
literal|0
expr_stmt|;
name|wide
operator|=
name|np
operator|->
name|msgin
index|[
literal|3
index|]
expr_stmt|;
comment|/* 		**	check values against driver limits. 		*/
if|if
condition|(
name|wide
operator|>
name|tp
operator|->
name|tinfo
operator|.
name|user
operator|.
name|width
condition|)
block|{
name|chg
operator|=
literal|1
expr_stmt|;
name|wide
operator|=
name|tp
operator|->
name|tinfo
operator|.
name|user
operator|.
name|width
expr_stmt|;
block|}
if|if
condition|(
name|DEBUG_FLAGS
operator|&
name|DEBUG_NEGO
condition|)
block|{
name|PRINT_ADDR
argument_list|(
name|cp
operator|->
name|ccb
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"wide: wide=%d chg=%d.\n"
argument_list|,
name|wide
argument_list|,
name|chg
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|INB
argument_list|(
name|HS_PRT
argument_list|)
operator|==
name|HS_NEGOTIATE
condition|)
block|{
name|OUTB
argument_list|(
name|HS_PRT
argument_list|,
name|HS_BUSY
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|cp
operator|->
name|nego_status
condition|)
block|{
case|case
name|NS_WIDE
case|:
comment|/* 				**      This was an answer message 				*/
if|if
condition|(
name|chg
condition|)
block|{
comment|/* 					**	Answer wasn't acceptable. 					*/
name|ncr_setwide
argument_list|(
name|np
argument_list|,
name|cp
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|OUTL
argument_list|(
name|nc_dsp
argument_list|,
name|NCB_SCRIPT_PHYS
argument_list|(
name|np
argument_list|,
name|msg_bad
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 					**	Answer is ok. 					*/
name|ncr_setwide
argument_list|(
name|np
argument_list|,
name|cp
argument_list|,
name|wide
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|OUTL
argument_list|(
name|nc_dsp
argument_list|,
name|NCB_SCRIPT_PHYS
argument_list|(
name|np
argument_list|,
name|clrack
argument_list|)
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
return|return;
case|case
name|NS_SYNC
case|:
name|ncr_setsync
argument_list|(
name|np
argument_list|,
name|cp
argument_list|,
literal|0
argument_list|,
literal|0xe0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
empty_stmt|;
block|}
empty_stmt|;
comment|/* 		**	It was a request, set value and 		**      prepare an answer message 		*/
name|ncr_setwide
argument_list|(
name|np
argument_list|,
name|cp
argument_list|,
name|wide
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|np
operator|->
name|msgout
index|[
literal|0
index|]
operator|=
name|MSG_EXTENDED
expr_stmt|;
name|np
operator|->
name|msgout
index|[
literal|1
index|]
operator|=
literal|2
expr_stmt|;
name|np
operator|->
name|msgout
index|[
literal|2
index|]
operator|=
name|MSG_EXT_WDTR
expr_stmt|;
name|np
operator|->
name|msgout
index|[
literal|3
index|]
operator|=
name|wide
expr_stmt|;
name|np
operator|->
name|msgin
index|[
literal|0
index|]
operator|=
name|MSG_NOOP
expr_stmt|;
name|cp
operator|->
name|nego_status
operator|=
name|NS_WIDE
expr_stmt|;
if|if
condition|(
name|DEBUG_FLAGS
operator|&
name|DEBUG_NEGO
condition|)
block|{
name|PRINT_ADDR
argument_list|(
name|cp
operator|->
name|ccb
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"wide msgout: "
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|ncr_show_msg
argument_list|(
name|np
operator|->
name|msgout
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|".\n"
argument_list|)
expr_stmt|;
block|}
break|break;
comment|/*-------------------------------------------------------------------- ** **	Processing of special messages ** **-------------------------------------------------------------------- */
case|case
name|SIR_REJECT_RECEIVED
case|:
comment|/*----------------------------------------------- 		** 		**	We received a MSG_MESSAGE_REJECT message. 		** 		**----------------------------------------------- 		*/
name|PRINT_ADDR
argument_list|(
name|cp
operator|->
name|ccb
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"MSG_MESSAGE_REJECT received (%x:%x).\n"
argument_list|,
operator|(
name|unsigned
operator|)
name|np
operator|->
name|lastmsg
argument_list|,
name|np
operator|->
name|msgout
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIR_REJECT_SENT
case|:
comment|/*----------------------------------------------- 		** 		**	We received an unknown message 		** 		**----------------------------------------------- 		*/
name|PRINT_ADDR
argument_list|(
name|cp
operator|->
name|ccb
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"MSG_MESSAGE_REJECT sent for "
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|ncr_show_msg
argument_list|(
name|np
operator|->
name|msgin
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|".\n"
argument_list|)
expr_stmt|;
break|break;
comment|/*-------------------------------------------------------------------- ** **	Processing of special messages ** **-------------------------------------------------------------------- */
case|case
name|SIR_IGN_RESIDUE
case|:
comment|/*----------------------------------------------- 		** 		**	We received an IGNORE RESIDUE message, 		**	which couldn't be handled by the script. 		** 		**----------------------------------------------- 		*/
name|PRINT_ADDR
argument_list|(
name|cp
operator|->
name|ccb
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"MSG_IGN_WIDE_RESIDUE received, but not yet implemented.\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIR_MISSING_SAVE
case|:
comment|/*----------------------------------------------- 		** 		**	We received an DISCONNECT message, 		**	but the datapointer wasn't saved before. 		** 		**----------------------------------------------- 		*/
name|PRINT_ADDR
argument_list|(
name|cp
operator|->
name|ccb
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"MSG_DISCONNECT received, but datapointer not saved:\n"
literal|"\tdata=%x save=%x goal=%x.\n"
argument_list|,
operator|(
name|unsigned
operator|)
name|INL
argument_list|(
name|nc_temp
argument_list|)
argument_list|,
operator|(
name|unsigned
operator|)
name|np
operator|->
name|header
operator|.
name|savep
argument_list|,
operator|(
name|unsigned
operator|)
name|np
operator|->
name|header
operator|.
name|goalp
argument_list|)
expr_stmt|;
break|break;
comment|/*-------------------------------------------------------------------- ** **	Processing of a "SCSI_STATUS_QUEUE_FULL" status. ** **	XXX JGibbs - We should do the same thing for BUSY status. ** **	The current command has been rejected, **	because there are too many in the command queue. **	We have started too many commands for that target. ** **-------------------------------------------------------------------- */
case|case
name|SIR_STALL_QUEUE
case|:
name|cp
operator|->
name|xerr_status
operator|=
name|XE_OK
expr_stmt|;
name|cp
operator|->
name|host_status
operator|=
name|HS_COMPLETE
expr_stmt|;
name|cp
operator|->
name|s_status
operator|=
name|SCSI_STATUS_QUEUE_FULL
expr_stmt|;
name|ncr_freeze_devq
argument_list|(
name|np
argument_list|,
name|cp
operator|->
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|)
expr_stmt|;
name|ncr_complete
argument_list|(
name|np
argument_list|,
name|cp
argument_list|)
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
name|SIR_STALL_RESTART
case|:
comment|/*----------------------------------------------- 		** 		**	Enable selecting again, 		**	if NO disconnected jobs. 		** 		**----------------------------------------------- 		*/
comment|/* 		**	Look for a disconnected job. 		*/
name|cp
operator|=
name|np
operator|->
name|link_nccb
expr_stmt|;
while|while
condition|(
name|cp
operator|&&
name|cp
operator|->
name|host_status
operator|!=
name|HS_DISCONNECT
condition|)
name|cp
operator|=
name|cp
operator|->
name|link_nccb
expr_stmt|;
comment|/* 		**	if there is one, ... 		*/
if|if
condition|(
name|cp
condition|)
block|{
comment|/* 			**	wait for reselection 			*/
name|OUTL
argument_list|(
name|nc_dsp
argument_list|,
name|NCB_SCRIPT_PHYS
argument_list|(
name|np
argument_list|,
name|reselect
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
empty_stmt|;
comment|/* 		**	else remove the interrupt. 		*/
name|printf
argument_list|(
literal|"%s: queue empty.\n"
argument_list|,
name|ncr_name
argument_list|(
name|np
argument_list|)
argument_list|)
expr_stmt|;
name|WRITESCRIPT
argument_list|(
name|start1
index|[
literal|0
index|]
argument_list|,
name|SCR_INT
operator|^
name|IFFALSE
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
empty_stmt|;
name|out
label|:
name|OUTB
argument_list|(
name|nc_dcntl
argument_list|,
name|np
operator|->
name|rv_dcntl
operator||
name|STD
argument_list|)
expr_stmt|;
block|}
comment|/*========================================================== ** ** **	Aquire a control block ** ** **========================================================== */
specifier|static
name|nccb_p
name|ncr_get_nccb
parameter_list|(
name|ncb_p
name|np
parameter_list|,
name|u_long
name|target
parameter_list|,
name|u_long
name|lun
parameter_list|)
block|{
name|lcb_p
name|lp
decl_stmt|;
name|int
name|s
decl_stmt|;
name|nccb_p
name|cp
init|=
name|NULL
decl_stmt|;
comment|/* Keep our timeout handler out */
name|s
operator|=
name|splsoftclock
argument_list|()
expr_stmt|;
comment|/* 	**	Lun structure available ? 	*/
name|lp
operator|=
name|np
operator|->
name|target
index|[
name|target
index|]
operator|.
name|lp
index|[
name|lun
index|]
expr_stmt|;
if|if
condition|(
name|lp
condition|)
block|{
name|cp
operator|=
name|lp
operator|->
name|next_nccb
expr_stmt|;
comment|/* 		**	Look for free CCB 		*/
while|while
condition|(
name|cp
operator|&&
name|cp
operator|->
name|magic
condition|)
block|{
name|cp
operator|=
name|cp
operator|->
name|next_nccb
expr_stmt|;
block|}
block|}
comment|/* 	**	if nothing available, create one. 	*/
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
name|cp
operator|=
name|ncr_alloc_nccb
argument_list|(
name|np
argument_list|,
name|target
argument_list|,
name|lun
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|cp
operator|->
name|magic
condition|)
block|{
name|printf
argument_list|(
literal|"%s: Bogus free cp found\n"
argument_list|,
name|ncr_name
argument_list|(
name|np
argument_list|)
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|cp
operator|->
name|magic
operator|=
literal|1
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|cp
operator|)
return|;
block|}
comment|/*========================================================== ** ** **	Release one control block ** ** **========================================================== */
specifier|static
name|void
name|ncr_free_nccb
parameter_list|(
name|ncb_p
name|np
parameter_list|,
name|nccb_p
name|cp
parameter_list|)
block|{
comment|/* 	**    sanity 	*/
name|assert
argument_list|(
name|cp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|cp
operator|->
name|host_status
operator|=
name|HS_IDLE
expr_stmt|;
name|cp
operator|->
name|magic
operator|=
literal|0
expr_stmt|;
block|}
comment|/*========================================================== ** ** **      Allocation of resources for Targets/Luns/Tags. ** ** **========================================================== */
specifier|static
name|nccb_p
name|ncr_alloc_nccb
parameter_list|(
name|ncb_p
name|np
parameter_list|,
name|u_long
name|target
parameter_list|,
name|u_long
name|lun
parameter_list|)
block|{
name|tcb_p
name|tp
decl_stmt|;
name|lcb_p
name|lp
decl_stmt|;
name|nccb_p
name|cp
decl_stmt|;
name|assert
argument_list|(
name|np
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
operator|>=
name|MAX_TARGET
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
name|lun
operator|>=
name|MAX_LUN
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|tp
operator|=
operator|&
name|np
operator|->
name|target
index|[
name|target
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|tp
operator|->
name|jump_tcb
operator|.
name|l_cmd
condition|)
block|{
comment|/* 		**	initialize it. 		*/
name|tp
operator|->
name|jump_tcb
operator|.
name|l_cmd
operator|=
operator|(
name|SCR_JUMP
operator|^
name|IFFALSE
argument_list|(
name|DATA
argument_list|(
literal|0x80
operator|+
name|target
argument_list|)
argument_list|)
operator|)
expr_stmt|;
name|tp
operator|->
name|jump_tcb
operator|.
name|l_paddr
operator|=
name|np
operator|->
name|jump_tcb
operator|.
name|l_paddr
expr_stmt|;
name|tp
operator|->
name|getscr
index|[
literal|0
index|]
operator|=
operator|(
name|np
operator|->
name|features
operator|&
name|FE_PFEN
operator|)
condition|?
name|SCR_COPY
argument_list|(
literal|1
argument_list|)
else|:
name|SCR_COPY_F
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|tp
operator|->
name|getscr
index|[
literal|1
index|]
operator|=
name|vtophys
argument_list|(
operator|&
name|tp
operator|->
name|tinfo
operator|.
name|sval
argument_list|)
expr_stmt|;
name|tp
operator|->
name|getscr
index|[
literal|2
index|]
operator|=
name|rman_get_start
argument_list|(
name|np
operator|->
name|reg_res
argument_list|)
operator|+
name|offsetof
argument_list|(
expr|struct
name|ncr_reg
argument_list|,
name|nc_sxfer
argument_list|)
expr_stmt|;
name|tp
operator|->
name|getscr
index|[
literal|3
index|]
operator|=
operator|(
name|np
operator|->
name|features
operator|&
name|FE_PFEN
operator|)
condition|?
name|SCR_COPY
argument_list|(
literal|1
argument_list|)
else|:
name|SCR_COPY_F
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|tp
operator|->
name|getscr
index|[
literal|4
index|]
operator|=
name|vtophys
argument_list|(
operator|&
name|tp
operator|->
name|tinfo
operator|.
name|wval
argument_list|)
expr_stmt|;
name|tp
operator|->
name|getscr
index|[
literal|5
index|]
operator|=
name|rman_get_start
argument_list|(
name|np
operator|->
name|reg_res
argument_list|)
operator|+
name|offsetof
argument_list|(
expr|struct
name|ncr_reg
argument_list|,
name|nc_scntl3
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|(
operator|(
name|offsetof
argument_list|(
expr|struct
name|ncr_reg
argument_list|,
name|nc_sxfer
argument_list|)
operator|^
operator|(
name|offsetof
argument_list|(
expr|struct
name|tcb
argument_list|,
name|tinfo
argument_list|)
operator|+
name|offsetof
argument_list|(
expr|struct
name|ncr_target_tinfo
argument_list|,
name|sval
argument_list|)
operator|)
operator|)
operator|&
literal|3
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|(
operator|(
name|offsetof
argument_list|(
expr|struct
name|ncr_reg
argument_list|,
name|nc_scntl3
argument_list|)
operator|^
operator|(
name|offsetof
argument_list|(
expr|struct
name|tcb
argument_list|,
name|tinfo
argument_list|)
operator|+
name|offsetof
argument_list|(
expr|struct
name|ncr_target_tinfo
argument_list|,
name|wval
argument_list|)
operator|)
operator|)
operator|&
literal|3
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|tp
operator|->
name|call_lun
operator|.
name|l_cmd
operator|=
operator|(
name|SCR_CALL
operator|)
expr_stmt|;
name|tp
operator|->
name|call_lun
operator|.
name|l_paddr
operator|=
name|NCB_SCRIPT_PHYS
argument_list|(
name|np
argument_list|,
name|resel_lun
argument_list|)
expr_stmt|;
name|tp
operator|->
name|jump_lcb
operator|.
name|l_cmd
operator|=
operator|(
name|SCR_JUMP
operator|)
expr_stmt|;
name|tp
operator|->
name|jump_lcb
operator|.
name|l_paddr
operator|=
name|NCB_SCRIPTH_PHYS
argument_list|(
name|np
argument_list|,
name|abort
argument_list|)
expr_stmt|;
name|np
operator|->
name|jump_tcb
operator|.
name|l_paddr
operator|=
name|vtophys
argument_list|(
operator|&
name|tp
operator|->
name|jump_tcb
argument_list|)
expr_stmt|;
block|}
comment|/* 	**	Logic unit control block 	*/
name|lp
operator|=
name|tp
operator|->
name|lp
index|[
name|lun
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|lp
condition|)
block|{
comment|/* 		**	Allocate a lcb 		*/
name|lp
operator|=
operator|(
name|lcb_p
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|lcb
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|lp
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* 		**	Initialize it 		*/
name|lp
operator|->
name|jump_lcb
operator|.
name|l_cmd
operator|=
operator|(
name|SCR_JUMP
operator|^
name|IFFALSE
argument_list|(
name|DATA
argument_list|(
name|lun
argument_list|)
argument_list|)
operator|)
expr_stmt|;
name|lp
operator|->
name|jump_lcb
operator|.
name|l_paddr
operator|=
name|tp
operator|->
name|jump_lcb
operator|.
name|l_paddr
expr_stmt|;
name|lp
operator|->
name|call_tag
operator|.
name|l_cmd
operator|=
operator|(
name|SCR_CALL
operator|)
expr_stmt|;
name|lp
operator|->
name|call_tag
operator|.
name|l_paddr
operator|=
name|NCB_SCRIPT_PHYS
argument_list|(
name|np
argument_list|,
name|resel_tag
argument_list|)
expr_stmt|;
name|lp
operator|->
name|jump_nccb
operator|.
name|l_cmd
operator|=
operator|(
name|SCR_JUMP
operator|)
expr_stmt|;
name|lp
operator|->
name|jump_nccb
operator|.
name|l_paddr
operator|=
name|NCB_SCRIPTH_PHYS
argument_list|(
name|np
argument_list|,
name|aborttag
argument_list|)
expr_stmt|;
name|lp
operator|->
name|actlink
operator|=
literal|1
expr_stmt|;
comment|/* 		**   Chain into LUN list 		*/
name|tp
operator|->
name|jump_lcb
operator|.
name|l_paddr
operator|=
name|vtophys
argument_list|(
operator|&
name|lp
operator|->
name|jump_lcb
argument_list|)
expr_stmt|;
name|tp
operator|->
name|lp
index|[
name|lun
index|]
operator|=
name|lp
expr_stmt|;
block|}
comment|/* 	**	Allocate a nccb 	*/
name|cp
operator|=
operator|(
name|nccb_p
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|nccb
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cp
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
name|DEBUG_FLAGS
operator|&
name|DEBUG_ALLOC
condition|)
block|{
name|printf
argument_list|(
literal|"new nccb @%p.\n"
argument_list|,
name|cp
argument_list|)
expr_stmt|;
block|}
comment|/* 	**	Fill in physical addresses 	*/
name|cp
operator|->
name|p_nccb
operator|=
name|vtophys
argument_list|(
name|cp
argument_list|)
expr_stmt|;
comment|/* 	**	Chain into reselect list 	*/
name|cp
operator|->
name|jump_nccb
operator|.
name|l_cmd
operator|=
name|SCR_JUMP
expr_stmt|;
name|cp
operator|->
name|jump_nccb
operator|.
name|l_paddr
operator|=
name|lp
operator|->
name|jump_nccb
operator|.
name|l_paddr
expr_stmt|;
name|lp
operator|->
name|jump_nccb
operator|.
name|l_paddr
operator|=
name|CCB_PHYS
argument_list|(
name|cp
argument_list|,
name|jump_nccb
argument_list|)
expr_stmt|;
name|cp
operator|->
name|call_tmp
operator|.
name|l_cmd
operator|=
name|SCR_CALL
expr_stmt|;
name|cp
operator|->
name|call_tmp
operator|.
name|l_paddr
operator|=
name|NCB_SCRIPT_PHYS
argument_list|(
name|np
argument_list|,
name|resel_tmp
argument_list|)
expr_stmt|;
comment|/* 	**	Chain into wakeup list 	*/
name|cp
operator|->
name|link_nccb
operator|=
name|np
operator|->
name|link_nccb
expr_stmt|;
name|np
operator|->
name|link_nccb
operator|=
name|cp
expr_stmt|;
comment|/* 	**	Chain into CCB list 	*/
name|cp
operator|->
name|next_nccb
operator|=
name|lp
operator|->
name|next_nccb
expr_stmt|;
name|lp
operator|->
name|next_nccb
operator|=
name|cp
expr_stmt|;
return|return
operator|(
name|cp
operator|)
return|;
block|}
comment|/*========================================================== ** ** **	Build Scatter Gather Block ** ** **========================================================== ** **	The transfer area may be scattered among **	several non adjacent physical pages. ** **	We may use MAX_SCATTER blocks. ** **---------------------------------------------------------- */
specifier|static
name|int
name|ncr_scatter
parameter_list|(
name|struct
name|dsb
modifier|*
name|phys
parameter_list|,
name|vm_offset_t
name|vaddr
parameter_list|,
name|vm_size_t
name|datalen
parameter_list|)
block|{
name|u_long
name|paddr
decl_stmt|,
name|pnext
decl_stmt|;
name|u_short
name|segment
init|=
literal|0
decl_stmt|;
name|u_long
name|segsize
decl_stmt|,
name|segaddr
decl_stmt|;
name|u_long
name|size
decl_stmt|,
name|csize
init|=
literal|0
decl_stmt|;
name|u_long
name|chunk
init|=
name|MAX_SIZE
decl_stmt|;
name|int
name|free
decl_stmt|;
name|bzero
argument_list|(
operator|&
name|phys
operator|->
name|data
argument_list|,
sizeof|sizeof
argument_list|(
name|phys
operator|->
name|data
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|datalen
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|paddr
operator|=
name|vtophys
argument_list|(
name|vaddr
argument_list|)
expr_stmt|;
comment|/* 	**	insert extra break points at a distance of chunk. 	**	We try to reduce the number of interrupts caused 	**	by unexpected phase changes due to disconnects. 	**	A typical harddisk may disconnect before ANY block. 	**	If we wanted to avoid unexpected phase changes at all 	**	we had to use a break point every 512 bytes. 	**	Of course the number of scatter/gather blocks is 	**	limited. 	*/
name|free
operator|=
name|MAX_SCATTER
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|vaddr
operator|&
name|PAGE_MASK
condition|)
name|free
operator|-=
name|datalen
operator|/
name|PAGE_SIZE
expr_stmt|;
if|if
condition|(
name|free
operator|>
literal|1
condition|)
while|while
condition|(
operator|(
name|chunk
operator|*
name|free
operator|>=
literal|2
operator|*
name|datalen
operator|)
operator|&&
operator|(
name|chunk
operator|>=
literal|1024
operator|)
condition|)
name|chunk
operator|/=
literal|2
expr_stmt|;
if|if
condition|(
name|DEBUG_FLAGS
operator|&
name|DEBUG_SCATTER
condition|)
name|printf
argument_list|(
literal|"ncr?:\tscattering virtual=%p size=%d chunk=%d.\n"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|vaddr
argument_list|,
operator|(
name|unsigned
operator|)
name|datalen
argument_list|,
operator|(
name|unsigned
operator|)
name|chunk
argument_list|)
expr_stmt|;
comment|/* 	**   Build data descriptors. 	*/
while|while
condition|(
name|datalen
operator|&&
operator|(
name|segment
operator|<
name|MAX_SCATTER
operator|)
condition|)
block|{
comment|/* 		**	this segment is empty 		*/
name|segsize
operator|=
literal|0
expr_stmt|;
name|segaddr
operator|=
name|paddr
expr_stmt|;
name|pnext
operator|=
name|paddr
expr_stmt|;
if|if
condition|(
operator|!
name|csize
condition|)
name|csize
operator|=
name|chunk
expr_stmt|;
while|while
condition|(
operator|(
name|datalen
operator|)
operator|&&
operator|(
name|paddr
operator|==
name|pnext
operator|)
operator|&&
operator|(
name|csize
operator|)
condition|)
block|{
comment|/* 			**	continue this segment 			*/
name|pnext
operator|=
operator|(
name|paddr
operator|&
operator|(
operator|~
name|PAGE_MASK
operator|)
operator|)
operator|+
name|PAGE_SIZE
expr_stmt|;
comment|/* 			**	Compute max size 			*/
name|size
operator|=
name|pnext
operator|-
name|paddr
expr_stmt|;
comment|/* page size */
if|if
condition|(
name|size
operator|>
name|datalen
condition|)
name|size
operator|=
name|datalen
expr_stmt|;
comment|/* data size */
if|if
condition|(
name|size
operator|>
name|csize
condition|)
name|size
operator|=
name|csize
expr_stmt|;
comment|/* chunksize */
name|segsize
operator|+=
name|size
expr_stmt|;
name|vaddr
operator|+=
name|size
expr_stmt|;
name|csize
operator|-=
name|size
expr_stmt|;
name|datalen
operator|-=
name|size
expr_stmt|;
name|paddr
operator|=
name|vtophys
argument_list|(
name|vaddr
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
if|if
condition|(
name|DEBUG_FLAGS
operator|&
name|DEBUG_SCATTER
condition|)
name|printf
argument_list|(
literal|"\tseg #%d  addr=%x  size=%d  (rest=%d).\n"
argument_list|,
name|segment
argument_list|,
operator|(
name|unsigned
operator|)
name|segaddr
argument_list|,
operator|(
name|unsigned
operator|)
name|segsize
argument_list|,
operator|(
name|unsigned
operator|)
name|datalen
argument_list|)
expr_stmt|;
name|phys
operator|->
name|data
index|[
name|segment
index|]
operator|.
name|addr
operator|=
name|segaddr
expr_stmt|;
name|phys
operator|->
name|data
index|[
name|segment
index|]
operator|.
name|size
operator|=
name|segsize
expr_stmt|;
name|segment
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|datalen
condition|)
block|{
name|printf
argument_list|(
literal|"ncr?: scatter/gather failed (residue=%d).\n"
argument_list|,
operator|(
name|unsigned
operator|)
name|datalen
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
empty_stmt|;
return|return
operator|(
name|segment
operator|)
return|;
block|}
comment|/*========================================================== ** ** **	Test the pci bus snoop logic :-( ** **	Has to be called with interrupts disabled. ** ** **========================================================== */
ifndef|#
directive|ifndef
name|NCR_IOMAPPED
specifier|static
name|int
name|ncr_regtest
parameter_list|(
name|struct
name|ncb
modifier|*
name|np
parameter_list|)
block|{
specifier|register
specifier|volatile
name|u_int32_t
name|data
decl_stmt|;
comment|/* 	**	ncr registers may NOT be cached. 	**	write 0xffffffff to a read only register area, 	**	and try to read it back. 	*/
name|data
operator|=
literal|0xffffffff
expr_stmt|;
name|OUTL_OFF
argument_list|(
name|offsetof
argument_list|(
expr|struct
name|ncr_reg
argument_list|,
name|nc_dstat
argument_list|)
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|data
operator|=
name|INL_OFF
argument_list|(
name|offsetof
argument_list|(
expr|struct
name|ncr_reg
argument_list|,
name|nc_dstat
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
literal|1
if|if
condition|(
name|data
operator|==
literal|0xffffffff
condition|)
block|{
else|#
directive|else
if|if
condition|(
operator|(
name|data
operator|&
literal|0xe2f0fffd
operator|)
operator|!=
literal|0x02000080
condition|)
block|{
endif|#
directive|endif
name|printf
argument_list|(
literal|"CACHE TEST FAILED: reg dstat-sstat2 readback %x.\n"
argument_list|,
operator|(
name|unsigned
operator|)
name|data
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0x10
operator|)
return|;
block|}
empty_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
endif|#
directive|endif
specifier|static
name|int
name|ncr_snooptest
parameter_list|(
name|struct
name|ncb
modifier|*
name|np
parameter_list|)
block|{
name|u_int32_t
name|ncr_rd
decl_stmt|,
name|ncr_wr
decl_stmt|,
name|ncr_bk
decl_stmt|,
name|host_rd
decl_stmt|,
name|host_wr
decl_stmt|,
name|pc
decl_stmt|;
name|int
name|i
decl_stmt|,
name|err
init|=
literal|0
decl_stmt|;
ifndef|#
directive|ifndef
name|NCR_IOMAPPED
name|err
operator||=
name|ncr_regtest
argument_list|(
name|np
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
endif|#
directive|endif
comment|/* 	**	init 	*/
name|pc
operator|=
name|NCB_SCRIPTH_PHYS
argument_list|(
name|np
argument_list|,
name|snooptest
argument_list|)
expr_stmt|;
name|host_wr
operator|=
literal|1
expr_stmt|;
name|ncr_wr
operator|=
literal|2
expr_stmt|;
comment|/* 	**	Set memory and register. 	*/
name|ncr_cache
operator|=
name|host_wr
expr_stmt|;
name|OUTL
argument_list|(
name|nc_temp
argument_list|,
name|ncr_wr
argument_list|)
expr_stmt|;
comment|/* 	**	Start script (exchange values) 	*/
name|OUTL
argument_list|(
name|nc_dsp
argument_list|,
name|pc
argument_list|)
expr_stmt|;
comment|/* 	**	Wait 'til done (with timeout) 	*/
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NCR_SNOOP_TIMEOUT
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|INB
argument_list|(
name|nc_istat
argument_list|)
operator|&
operator|(
name|INTF
operator||
name|SIP
operator||
name|DIP
operator|)
condition|)
break|break;
comment|/* 	**	Save termination position. 	*/
name|pc
operator|=
name|INL
argument_list|(
name|nc_dsp
argument_list|)
expr_stmt|;
comment|/* 	**	Read memory and register. 	*/
name|host_rd
operator|=
name|ncr_cache
expr_stmt|;
name|ncr_rd
operator|=
name|INL
argument_list|(
name|nc_scratcha
argument_list|)
expr_stmt|;
name|ncr_bk
operator|=
name|INL
argument_list|(
name|nc_temp
argument_list|)
expr_stmt|;
comment|/* 	**	Reset ncr chip 	*/
name|OUTB
argument_list|(
name|nc_istat
argument_list|,
name|SRST
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
name|nc_istat
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	**	check for timeout 	*/
if|if
condition|(
name|i
operator|>=
name|NCR_SNOOP_TIMEOUT
condition|)
block|{
name|printf
argument_list|(
literal|"CACHE TEST FAILED: timeout.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0x20
operator|)
return|;
block|}
empty_stmt|;
comment|/* 	**	Check termination position. 	*/
if|if
condition|(
name|pc
operator|!=
name|NCB_SCRIPTH_PHYS
argument_list|(
name|np
argument_list|,
name|snoopend
argument_list|)
operator|+
literal|8
condition|)
block|{
name|printf
argument_list|(
literal|"CACHE TEST FAILED: script execution failed.\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"start=%08lx, pc=%08lx, end=%08lx\n"
argument_list|,
operator|(
name|u_long
operator|)
name|NCB_SCRIPTH_PHYS
argument_list|(
name|np
argument_list|,
name|snooptest
argument_list|)
argument_list|,
operator|(
name|u_long
operator|)
name|pc
argument_list|,
operator|(
name|u_long
operator|)
name|NCB_SCRIPTH_PHYS
argument_list|(
name|np
argument_list|,
name|snoopend
argument_list|)
operator|+
literal|8
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0x40
operator|)
return|;
block|}
empty_stmt|;
comment|/* 	**	Show results. 	*/
if|if
condition|(
name|host_wr
operator|!=
name|ncr_rd
condition|)
block|{
name|printf
argument_list|(
literal|"CACHE TEST FAILED: host wrote %d, ncr read %d.\n"
argument_list|,
operator|(
name|int
operator|)
name|host_wr
argument_list|,
operator|(
name|int
operator|)
name|ncr_rd
argument_list|)
expr_stmt|;
name|err
operator||=
literal|1
expr_stmt|;
block|}
empty_stmt|;
if|if
condition|(
name|host_rd
operator|!=
name|ncr_wr
condition|)
block|{
name|printf
argument_list|(
literal|"CACHE TEST FAILED: ncr wrote %d, host read %d.\n"
argument_list|,
operator|(
name|int
operator|)
name|ncr_wr
argument_list|,
operator|(
name|int
operator|)
name|host_rd
argument_list|)
expr_stmt|;
name|err
operator||=
literal|2
expr_stmt|;
block|}
empty_stmt|;
if|if
condition|(
name|ncr_bk
operator|!=
name|ncr_wr
condition|)
block|{
name|printf
argument_list|(
literal|"CACHE TEST FAILED: ncr wrote %d, read back %d.\n"
argument_list|,
operator|(
name|int
operator|)
name|ncr_wr
argument_list|,
operator|(
name|int
operator|)
name|ncr_bk
argument_list|)
expr_stmt|;
name|err
operator||=
literal|4
expr_stmt|;
block|}
empty_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
comment|/*========================================================== ** ** **	Profiling the drivers and targets performance. ** ** **========================================================== */
comment|/* **	Compute the difference in milliseconds. **/
specifier|static
name|int
name|ncr_delta
parameter_list|(
name|int
modifier|*
name|from
parameter_list|,
name|int
modifier|*
name|to
parameter_list|)
block|{
if|if
condition|(
operator|!
name|from
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
operator|!
name|to
condition|)
return|return
operator|(
operator|-
literal|2
operator|)
return|;
return|return
operator|(
operator|(
name|to
operator|-
name|from
operator|)
operator|*
literal|1000
operator|/
name|hz
operator|)
return|;
block|}
define|#
directive|define
name|PROFILE
value|cp->phys.header.stamp
specifier|static
name|void
name|ncb_profile
parameter_list|(
name|ncb_p
name|np
parameter_list|,
name|nccb_p
name|cp
parameter_list|)
block|{
name|int
name|co
decl_stmt|,
name|da
decl_stmt|,
name|st
decl_stmt|,
name|en
decl_stmt|,
name|di
decl_stmt|,
name|se
decl_stmt|,
name|post
decl_stmt|,
name|work
decl_stmt|,
name|disc
decl_stmt|;
name|u_long
name|diff
decl_stmt|;
name|PROFILE
operator|.
name|end
operator|=
name|ticks
expr_stmt|;
name|st
operator|=
name|ncr_delta
argument_list|(
operator|&
name|PROFILE
operator|.
name|start
argument_list|,
operator|&
name|PROFILE
operator|.
name|status
argument_list|)
expr_stmt|;
if|if
condition|(
name|st
operator|<
literal|0
condition|)
return|return;
comment|/* status  not reached  */
name|da
operator|=
name|ncr_delta
argument_list|(
operator|&
name|PROFILE
operator|.
name|start
argument_list|,
operator|&
name|PROFILE
operator|.
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|da
operator|<
literal|0
condition|)
return|return;
comment|/* No data transfer phase */
name|co
operator|=
name|ncr_delta
argument_list|(
operator|&
name|PROFILE
operator|.
name|start
argument_list|,
operator|&
name|PROFILE
operator|.
name|command
argument_list|)
expr_stmt|;
if|if
condition|(
name|co
operator|<
literal|0
condition|)
return|return;
comment|/* command not executed */
name|en
operator|=
name|ncr_delta
argument_list|(
operator|&
name|PROFILE
operator|.
name|start
argument_list|,
operator|&
name|PROFILE
operator|.
name|end
argument_list|)
operator|,
name|di
operator|=
name|ncr_delta
argument_list|(
operator|&
name|PROFILE
operator|.
name|start
argument_list|,
operator|&
name|PROFILE
operator|.
name|disconnect
argument_list|)
operator|,
name|se
operator|=
name|ncr_delta
argument_list|(
operator|&
name|PROFILE
operator|.
name|start
argument_list|,
operator|&
name|PROFILE
operator|.
name|select
argument_list|)
expr_stmt|;
name|post
operator|=
name|en
operator|-
name|st
expr_stmt|;
comment|/* 	**	@PROFILE@  Disconnect time invalid if multiple disconnects 	*/
if|if
condition|(
name|di
operator|>=
literal|0
condition|)
name|disc
operator|=
name|se
operator|-
name|di
expr_stmt|;
else|else
name|disc
operator|=
literal|0
expr_stmt|;
name|work
operator|=
operator|(
name|st
operator|-
name|co
operator|)
operator|-
name|disc
expr_stmt|;
name|diff
operator|=
operator|(
name|np
operator|->
name|disc_phys
operator|-
name|np
operator|->
name|disc_ref
operator|)
operator|&
literal|0xff
expr_stmt|;
name|np
operator|->
name|disc_ref
operator|+=
name|diff
expr_stmt|;
name|np
operator|->
name|profile
operator|.
name|num_trans
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
name|cp
operator|->
name|ccb
condition|)
name|np
operator|->
name|profile
operator|.
name|num_bytes
operator|+=
name|cp
operator|->
name|ccb
operator|->
name|csio
operator|.
name|dxfer_len
expr_stmt|;
name|np
operator|->
name|profile
operator|.
name|num_disc
operator|+=
name|diff
expr_stmt|;
name|np
operator|->
name|profile
operator|.
name|ms_setup
operator|+=
name|co
expr_stmt|;
name|np
operator|->
name|profile
operator|.
name|ms_data
operator|+=
name|work
expr_stmt|;
name|np
operator|->
name|profile
operator|.
name|ms_disc
operator|+=
name|disc
expr_stmt|;
name|np
operator|->
name|profile
operator|.
name|ms_post
operator|+=
name|post
expr_stmt|;
block|}
undef|#
directive|undef
name|PROFILE
comment|/*========================================================== ** **	Determine the ncr's clock frequency. **	This is essential for the negotiation **	of the synchronous transfer rate. ** **========================================================== ** **	Note: we have to return the correct value. **	THERE IS NO SAVE DEFAULT VALUE. ** **	Most NCR/SYMBIOS boards are delivered with a 40 Mhz clock. **	53C860 and 53C875 rev. 1 support fast20 transfers but  **	do not have a clock doubler and so are provided with a  **	80 MHz clock. All other fast20 boards incorporate a doubler  **	and so should be delivered with a 40 MHz clock. **	The future fast40 chips (895/895) use a 40 Mhz base clock  **	and provide a clock quadrupler (160 Mhz). The code below  **	tries to deal as cleverly as possible with all this stuff. ** **---------------------------------------------------------- */
comment|/*  *	Select NCR SCSI clock frequency  */
specifier|static
name|void
name|ncr_selectclock
parameter_list|(
name|ncb_p
name|np
parameter_list|,
name|u_char
name|scntl3
parameter_list|)
block|{
if|if
condition|(
name|np
operator|->
name|multiplier
operator|<
literal|2
condition|)
block|{
name|OUTB
argument_list|(
name|nc_scntl3
argument_list|,
name|scntl3
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|bootverbose
operator|>=
literal|2
condition|)
name|printf
argument_list|(
literal|"%s: enabling clock multiplier\n"
argument_list|,
name|ncr_name
argument_list|(
name|np
argument_list|)
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
name|nc_stest1
argument_list|,
name|DBLEN
argument_list|)
expr_stmt|;
comment|/* Enable clock multiplier		  */
if|if
condition|(
name|np
operator|->
name|multiplier
operator|>
literal|2
condition|)
block|{
comment|/* Poll bit 5 of stest4 for quadrupler */
name|int
name|i
init|=
literal|20
decl_stmt|;
while|while
condition|(
operator|!
operator|(
name|INB
argument_list|(
name|nc_stest4
argument_list|)
operator|&
name|LCKFRQ
operator|)
operator|&&
operator|--
name|i
operator|>
literal|0
condition|)
name|DELAY
argument_list|(
literal|20
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|i
condition|)
name|printf
argument_list|(
literal|"%s: the chip cannot lock the frequency\n"
argument_list|,
name|ncr_name
argument_list|(
name|np
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* Wait 20 micro-seconds for doubler	*/
name|DELAY
argument_list|(
literal|20
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
name|nc_stest3
argument_list|,
name|HSC
argument_list|)
expr_stmt|;
comment|/* Halt the scsi clock		*/
name|OUTB
argument_list|(
name|nc_scntl3
argument_list|,
name|scntl3
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
name|nc_stest1
argument_list|,
operator|(
name|DBLEN
operator||
name|DBLSEL
operator|)
argument_list|)
expr_stmt|;
comment|/* Select clock multiplier	*/
name|OUTB
argument_list|(
name|nc_stest3
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
comment|/* Restart scsi clock 		*/
block|}
comment|/*  *	calculate NCR SCSI clock frequency (in KHz)  */
specifier|static
name|unsigned
name|ncrgetfreq
parameter_list|(
name|ncb_p
name|np
parameter_list|,
name|int
name|gen
parameter_list|)
block|{
name|int
name|ms
init|=
literal|0
decl_stmt|;
comment|/* 	 * Measure GEN timer delay in order  	 * to calculate SCSI clock frequency 	 * 	 * This code will never execute too 	 * many loop iterations (if DELAY is  	 * reasonably correct). It could get 	 * too low a delay (too high a freq.) 	 * if the CPU is slow executing the  	 * loop for some reason (an NMI, for 	 * example). For this reason we will 	 * if multiple measurements are to be  	 * performed trust the higher delay  	 * (lower frequency returned). 	 */
name|OUTB
argument_list|(
name|nc_stest1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* make sure clock doubler is OFF	    */
name|OUTW
argument_list|(
name|nc_sien
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* mask all scsi interrupts		    */
operator|(
name|void
operator|)
name|INW
argument_list|(
name|nc_sist
argument_list|)
expr_stmt|;
comment|/* clear pending scsi interrupt		    */
name|OUTB
argument_list|(
name|nc_dien
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* mask all dma interrupts		    */
operator|(
name|void
operator|)
name|INW
argument_list|(
name|nc_sist
argument_list|)
expr_stmt|;
comment|/* another one, just to be sure :)	    */
name|OUTB
argument_list|(
name|nc_scntl3
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* set pre-scaler to divide by 3	    */
name|OUTB
argument_list|(
name|nc_stime1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* disable general purpose timer	    */
name|OUTB
argument_list|(
name|nc_stime1
argument_list|,
name|gen
argument_list|)
expr_stmt|;
comment|/* set to nominal delay of (1<<gen) * 125us */
while|while
condition|(
operator|!
operator|(
name|INW
argument_list|(
name|nc_sist
argument_list|)
operator|&
name|GEN
operator|)
operator|&&
name|ms
operator|++
operator|<
literal|1000
condition|)
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
comment|/* count ms				    */
name|OUTB
argument_list|(
name|nc_stime1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* disable general purpose timer	    */
name|OUTB
argument_list|(
name|nc_scntl3
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Set prescaler to divide by whatever "0" means. 	 * "0" ought to choose divide by 2, but appears 	 * to set divide by 3.5 mode in my 53c810 ... 	 */
name|OUTB
argument_list|(
name|nc_scntl3
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
operator|>=
literal|2
condition|)
name|printf
argument_list|(
literal|"\tDelay (GEN=%d): %u msec\n"
argument_list|,
name|gen
argument_list|,
name|ms
argument_list|)
expr_stmt|;
comment|/* 	 * adjust for prescaler, and convert into KHz  	 */
return|return
name|ms
condition|?
operator|(
operator|(
literal|1
operator|<<
name|gen
operator|)
operator|*
literal|4440
operator|)
operator|/
name|ms
else|:
literal|0
return|;
block|}
specifier|static
name|void
name|ncr_getclock
parameter_list|(
name|ncb_p
name|np
parameter_list|,
name|u_char
name|multiplier
parameter_list|)
block|{
name|unsigned
name|char
name|scntl3
decl_stmt|;
name|unsigned
name|char
name|stest1
decl_stmt|;
name|scntl3
operator|=
name|INB
argument_list|(
name|nc_scntl3
argument_list|)
expr_stmt|;
name|stest1
operator|=
name|INB
argument_list|(
name|nc_stest1
argument_list|)
expr_stmt|;
name|np
operator|->
name|multiplier
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|multiplier
operator|>
literal|1
condition|)
block|{
name|np
operator|->
name|multiplier
operator|=
name|multiplier
expr_stmt|;
name|np
operator|->
name|clock_khz
operator|=
literal|40000
operator|*
name|multiplier
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|scntl3
operator|&
literal|7
operator|)
operator|==
literal|0
condition|)
block|{
name|unsigned
name|f1
decl_stmt|,
name|f2
decl_stmt|;
comment|/* throw away first result */
operator|(
name|void
operator|)
name|ncrgetfreq
argument_list|(
name|np
argument_list|,
literal|11
argument_list|)
expr_stmt|;
name|f1
operator|=
name|ncrgetfreq
argument_list|(
name|np
argument_list|,
literal|11
argument_list|)
expr_stmt|;
name|f2
operator|=
name|ncrgetfreq
argument_list|(
name|np
argument_list|,
literal|11
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
operator|>=
literal|2
condition|)
name|printf
argument_list|(
literal|"\tNCR clock is %uKHz, %uKHz\n"
argument_list|,
name|f1
argument_list|,
name|f2
argument_list|)
expr_stmt|;
if|if
condition|(
name|f1
operator|>
name|f2
condition|)
name|f1
operator|=
name|f2
expr_stmt|;
comment|/* trust lower result	*/
if|if
condition|(
name|f1
operator|>
literal|45000
condition|)
block|{
name|scntl3
operator|=
literal|5
expr_stmt|;
comment|/*>45Mhz: assume 80MHz	*/
block|}
else|else
block|{
name|scntl3
operator|=
literal|3
expr_stmt|;
comment|/*<45Mhz: assume 40MHz	*/
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|scntl3
operator|&
literal|7
operator|)
operator|==
literal|5
condition|)
name|np
operator|->
name|clock_khz
operator|=
literal|80000
expr_stmt|;
comment|/* Probably a 875 rev. 1 ? */
block|}
block|}
comment|/*=========================================================================*/
ifdef|#
directive|ifdef
name|NCR_TEKRAM_EEPROM
struct|struct
name|tekram_eeprom_dev
block|{
name|u_char
name|devmode
decl_stmt|;
define|#
directive|define
name|TKR_PARCHK
value|0x01
define|#
directive|define
name|TKR_TRYSYNC
value|0x02
define|#
directive|define
name|TKR_ENDISC
value|0x04
define|#
directive|define
name|TKR_STARTUNIT
value|0x08
define|#
directive|define
name|TKR_USETAGS
value|0x10
define|#
directive|define
name|TKR_TRYWIDE
value|0x20
name|u_char
name|syncparam
decl_stmt|;
comment|/* max. sync transfer rate (table ?) */
name|u_char
name|filler1
decl_stmt|;
name|u_char
name|filler2
decl_stmt|;
block|}
struct|;
struct|struct
name|tekram_eeprom
block|{
name|struct
name|tekram_eeprom_dev
name|dev
index|[
literal|16
index|]
decl_stmt|;
name|u_char
name|adaptid
decl_stmt|;
name|u_char
name|adaptmode
decl_stmt|;
define|#
directive|define
name|TKR_ADPT_GT2DRV
value|0x01
define|#
directive|define
name|TKR_ADPT_GT1GB
value|0x02
define|#
directive|define
name|TKR_ADPT_RSTBUS
value|0x04
define|#
directive|define
name|TKR_ADPT_ACTNEG
value|0x08
define|#
directive|define
name|TKR_ADPT_NOSEEK
value|0x10
define|#
directive|define
name|TKR_ADPT_MORLUN
value|0x20
name|u_char
name|delay
decl_stmt|;
comment|/* unit ? ( table ??? ) */
name|u_char
name|tags
decl_stmt|;
comment|/* use 4 times as many ... */
name|u_char
name|filler
index|[
literal|60
index|]
decl_stmt|;
block|}
struct|;
specifier|static
name|void
name|tekram_write_bit
parameter_list|(
name|ncb_p
name|np
parameter_list|,
name|int
name|bit
parameter_list|)
block|{
name|u_char
name|val
init|=
literal|0x10
operator|+
operator|(
operator|(
name|bit
operator|&
literal|1
operator|)
operator|<<
literal|1
operator|)
decl_stmt|;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
name|nc_gpreg
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
name|nc_gpreg
argument_list|,
name|val
operator||
literal|0x04
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
name|nc_gpreg
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
specifier|static
name|int
name|tekram_read_bit
parameter_list|(
name|ncb_p
name|np
parameter_list|)
block|{
name|OUTB
argument_list|(
name|nc_gpreg
argument_list|,
literal|0x10
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
name|nc_gpreg
argument_list|,
literal|0x14
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
return|return
name|INB
argument_list|(
name|nc_gpreg
argument_list|)
operator|&
literal|1
return|;
block|}
specifier|static
name|u_short
name|read_tekram_eeprom_reg
parameter_list|(
name|ncb_p
name|np
parameter_list|,
name|int
name|reg
parameter_list|)
block|{
name|int
name|bit
decl_stmt|;
name|u_short
name|result
init|=
literal|0
decl_stmt|;
name|int
name|cmd
init|=
literal|0x80
operator||
name|reg
decl_stmt|;
name|OUTB
argument_list|(
name|nc_gpreg
argument_list|,
literal|0x10
argument_list|)
expr_stmt|;
name|tekram_write_bit
argument_list|(
name|np
argument_list|,
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|bit
operator|=
literal|7
init|;
name|bit
operator|>=
literal|0
condition|;
name|bit
operator|--
control|)
block|{
name|tekram_write_bit
argument_list|(
name|np
argument_list|,
name|cmd
operator|>>
name|bit
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|bit
operator|=
literal|0
init|;
name|bit
operator|<
literal|16
condition|;
name|bit
operator|++
control|)
block|{
name|result
operator|<<=
literal|1
expr_stmt|;
name|result
operator||=
name|tekram_read_bit
argument_list|(
name|np
argument_list|)
expr_stmt|;
block|}
name|OUTB
argument_list|(
name|nc_gpreg
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
specifier|static
name|int
name|read_tekram_eeprom
parameter_list|(
name|ncb_p
name|np
parameter_list|,
name|struct
name|tekram_eeprom
modifier|*
name|buffer
parameter_list|)
block|{
name|u_short
modifier|*
name|p
init|=
operator|(
name|u_short
operator|*
operator|)
name|buffer
decl_stmt|;
name|u_short
name|sum
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|INB
argument_list|(
name|nc_gpcntl
argument_list|)
operator|!=
literal|0x09
condition|)
block|{
return|return
literal|0
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|64
condition|;
name|i
operator|++
control|)
block|{
name|u_short
name|val
decl_stmt|;
if|if
condition|(
operator|(
name|i
operator|&
literal|0x0f
operator|)
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"%02x:"
argument_list|,
name|i
operator|*
literal|2
argument_list|)
expr_stmt|;
name|val
operator|=
name|read_tekram_eeprom_reg
argument_list|(
name|np
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
condition|)
operator|*
name|p
operator|++
operator|=
name|val
expr_stmt|;
name|sum
operator|+=
name|val
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|&
literal|0x01
operator|)
operator|==
literal|0x00
condition|)
name|printf
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%02x%02x"
argument_list|,
name|val
operator|&
literal|0xff
argument_list|,
operator|(
name|val
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|&
literal|0x0f
operator|)
operator|==
literal|0x0f
condition|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"Sum = %04x\n"
argument_list|,
name|sum
argument_list|)
expr_stmt|;
return|return
name|sum
operator|==
literal|0x1234
return|;
block|}
endif|#
directive|endif
comment|/* NCR_TEKRAM_EEPROM */
specifier|static
name|device_method_t
name|ncr_methods
index|[]
init|=
block|{
comment|/* Device interface */
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|ncr_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|ncr_attach
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
specifier|static
name|driver_t
name|ncr_driver
init|=
block|{
literal|"ncr"
block|,
name|ncr_methods
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|ncb
argument_list|)
block|, }
decl_stmt|;
specifier|static
name|devclass_t
name|ncr_devclass
decl_stmt|;
name|DRIVER_MODULE
argument_list|(
name|ncr
argument_list|,
name|pci
argument_list|,
name|ncr_driver
argument_list|,
name|ncr_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|MODULE_DEPEND
argument_list|(
name|ncr
argument_list|,
name|cam
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|MODULE_DEPEND
argument_list|(
name|ncr
argument_list|,
name|pci
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_function

begin_comment
comment|/*=========================================================================*/
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* _KERNEL */
end_comment

end_unit

