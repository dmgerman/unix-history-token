begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/************************************************************************** ** **  $Id: ncr.c,v 1.82.2.7 1997/07/11 18:39:59 se Exp $ ** **  Device driver for the   NCR 53C810   PCI-SCSI-Controller. ** **  FreeBSD / NetBSD ** **------------------------------------------------------------------------- ** **  Written for 386bsd and FreeBSD by **	Wolfgang Stanglmeier<wolf@cologne.de> **	Stefan Esser<se@mi.Uni-Koeln.de> ** **  Ported to NetBSD by **	Charles M. Hannum<mycroft@gnu.ai.mit.edu> ** **------------------------------------------------------------------------- ** ** Copyright (c) 1994 Wolfgang Stanglmeier.  All rights reserved. ** ** Redistribution and use in source and binary forms, with or without ** modification, are permitted provided that the following conditions ** are met: ** 1. Redistributions of source code must retain the above copyright **    notice, this list of conditions and the following disclaimer. ** 2. Redistributions in binary form must reproduce the above copyright **    notice, this list of conditions and the following disclaimer in the **    documentation and/or other materials provided with the distribution. ** 3. The name of the author may not be used to endorse or promote products **    derived from this software without specific prior written permission. ** ** THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR ** IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES ** OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. ** IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, ** INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT ** NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, ** DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY ** THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT ** (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF ** THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ** *************************************************************************** */
end_comment

begin_define
define|#
directive|define
name|NCR_DATE
value|"pl24 96/12/14"
end_define

begin_define
define|#
directive|define
name|NCR_VERSION
value|(2)
end_define

begin_define
define|#
directive|define
name|MAX_UNITS
value|(16)
end_define

begin_define
define|#
directive|define
name|NCR_GETCC_WITHMSG
end_define

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
operator|&&
name|defined
argument_list|(
name|KERNEL
argument_list|)
end_if

begin_include
include|#
directive|include
file|"opt_ncr.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* defined (__FreeBSD__)&& defined(KERNEL) */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|FAILSAFE
end_ifdef

begin_ifndef
ifndef|#
directive|ifndef
name|SCSI_NCR_DFLT_TAGS
end_ifndef

begin_define
define|#
directive|define
name|SCSI_NCR_DFLT_TAGS
value|(0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SCSI_NCR_DFLT_TAGS */
end_comment

begin_define
define|#
directive|define
name|CDROM_ASYNC
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* FAILSAFE */
end_comment

begin_comment
comment|/*========================================================== ** **	Configuration and Debugging ** **	May be overwritten in<arch/conf/xxxx> ** **========================================================== */
end_comment

begin_comment
comment|/* **    SCSI address of this device. **    The boot routines should have set it. **    If not, use this. */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|SCSI_NCR_MYADDR
end_ifndef

begin_define
define|#
directive|define
name|SCSI_NCR_MYADDR
value|(7)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SCSI_NCR_MYADDR */
end_comment

begin_comment
comment|/* **    The maximal synchronous frequency in kHz. **    (0=asynchronous) */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|SCSI_NCR_MAX_SYNC
end_ifndef

begin_define
define|#
directive|define
name|SCSI_NCR_MAX_SYNC
value|(10000)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SCSI_NCR_MAX_SYNC */
end_comment

begin_comment
comment|/* **    The maximal bus with (in log2 byte) **    (0=8 bit, 1=16 bit) */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|SCSI_NCR_MAX_WIDE
end_ifndef

begin_define
define|#
directive|define
name|SCSI_NCR_MAX_WIDE
value|(1)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SCSI_NCR_MAX_WIDE */
end_comment

begin_comment
comment|/* **    The maximum number of tags per logic unit. **    Used only for disk devices that support tags. */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|SCSI_NCR_DFLT_TAGS
end_ifndef

begin_define
define|#
directive|define
name|SCSI_NCR_DFLT_TAGS
value|(4)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SCSI_NCR_DFLT_TAGS */
end_comment

begin_comment
comment|/*========================================================== ** **      Configuration and Debugging ** **========================================================== */
end_comment

begin_comment
comment|/* **    Number of targets supported by the driver. **    n permits target numbers 0..n-1. **    Default is 7, meaning targets #0..#6. **    #7 .. is myself. */
end_comment

begin_define
define|#
directive|define
name|MAX_TARGET
value|(16)
end_define

begin_comment
comment|/* **    Number of logic units supported by the driver. **    n enables logic unit numbers 0..n-1. **    The common SCSI devices require only **    one lun, so take 1 as the default. */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|MAX_LUN
end_ifndef

begin_define
define|#
directive|define
name|MAX_LUN
value|(8)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* MAX_LUN */
end_comment

begin_comment
comment|/* **    The maximum number of jobs scheduled for starting. **    There should be one slot per target, and one slot **    for each tag of each target in use. **    The calculation below is actually quite silly ... */
end_comment

begin_define
define|#
directive|define
name|MAX_START
value|(MAX_TARGET + 7 * SCSI_NCR_DFLT_TAGS)
end_define

begin_comment
comment|/* **    The maximum number of segments a transfer is split into. */
end_comment

begin_define
define|#
directive|define
name|MAX_SCATTER
value|(33)
end_define

begin_comment
comment|/* **    The maximum transfer length (should be>= 64k). **    MUST NOT be greater than (MAX_SCATTER-1) * PAGE_SIZE. */
end_comment

begin_define
define|#
directive|define
name|MAX_SIZE
value|((MAX_SCATTER-1) * (long) PAGE_SIZE)
end_define

begin_comment
comment|/* **	other */
end_comment

begin_define
define|#
directive|define
name|NCR_SNOOP_TIMEOUT
value|(1000000)
end_define

begin_comment
comment|/*========================================================== ** **      Include files ** **========================================================== */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__NetBSD__
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|_KERNEL
end_ifdef

begin_define
define|#
directive|define
name|KERNEL
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<stddef.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|KERNEL
end_ifdef

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/buf.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|__NetBSD__
end_ifdef

begin_define
define|#
directive|define
name|bootverbose
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|__NetBSD__
end_ifndef

begin_include
include|#
directive|include
file|<machine/clock.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_param.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_extern.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* KERNEL */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|__NetBSD__
end_ifndef

begin_include
include|#
directive|include
file|<pci/pcivar.h>
end_include

begin_include
include|#
directive|include
file|<pci/pcireg.h>
end_include

begin_include
include|#
directive|include
file|<pci/ncrreg.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<sys/device.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/ncr_reg.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcivar.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcireg.h>
end_include

begin_define
define|#
directive|define
name|DELAY
parameter_list|(
name|x
parameter_list|)
value|delay(x)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __NetBSD */
end_comment

begin_include
include|#
directive|include
file|<scsi/scsi_all.h>
end_include

begin_include
include|#
directive|include
file|<scsi/scsiconf.h>
end_include

begin_comment
comment|/*========================================================== ** **	Debugging tags ** **========================================================== */
end_comment

begin_define
define|#
directive|define
name|DEBUG_ALLOC
value|(0x0001)
end_define

begin_define
define|#
directive|define
name|DEBUG_PHASE
value|(0x0002)
end_define

begin_define
define|#
directive|define
name|DEBUG_POLL
value|(0x0004)
end_define

begin_define
define|#
directive|define
name|DEBUG_QUEUE
value|(0x0008)
end_define

begin_define
define|#
directive|define
name|DEBUG_RESULT
value|(0x0010)
end_define

begin_define
define|#
directive|define
name|DEBUG_SCATTER
value|(0x0020)
end_define

begin_define
define|#
directive|define
name|DEBUG_SCRIPT
value|(0x0040)
end_define

begin_define
define|#
directive|define
name|DEBUG_TINY
value|(0x0080)
end_define

begin_define
define|#
directive|define
name|DEBUG_TIMING
value|(0x0100)
end_define

begin_define
define|#
directive|define
name|DEBUG_NEGO
value|(0x0200)
end_define

begin_define
define|#
directive|define
name|DEBUG_TAGS
value|(0x0400)
end_define

begin_define
define|#
directive|define
name|DEBUG_FREEZE
value|(0x0800)
end_define

begin_define
define|#
directive|define
name|DEBUG_RESTART
value|(0x1000)
end_define

begin_comment
comment|/* **    Enable/Disable debug messages. **    Can be changed at runtime too. */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|SCSI_NCR_DEBUG
end_ifdef

begin_define
define|#
directive|define
name|DEBUG_FLAGS
value|ncr_debug
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* SCSI_NCR_DEBUG */
end_comment

begin_define
define|#
directive|define
name|SCSI_NCR_DEBUG
value|0
end_define

begin_define
define|#
directive|define
name|DEBUG_FLAGS
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SCSI_NCR_DEBUG */
end_comment

begin_comment
comment|/*========================================================== ** **	assert () ** **========================================================== ** **	modified copy from 386bsd:/usr/include/sys/assert.h ** **---------------------------------------------------------- */
end_comment

begin_define
define|#
directive|define
name|assert
parameter_list|(
name|expression
parameter_list|)
value|{ \ 	if (!(expression)) { \ 		(void)printf(\ 			"assertion \"%s\" failed: file \"%s\", line %d\n", \ 			#expression, \ 			__FILE__, __LINE__); \ 	} \ }
end_define

begin_comment
comment|/*========================================================== ** **	Access to the controller chip. ** **========================================================== */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|NCR_IOMAPPED
end_ifdef

begin_define
define|#
directive|define
name|INB
parameter_list|(
name|r
parameter_list|)
value|inb (np->port + offsetof(struct ncr_reg, r))
end_define

begin_define
define|#
directive|define
name|INW
parameter_list|(
name|r
parameter_list|)
value|inw (np->port + offsetof(struct ncr_reg, r))
end_define

begin_define
define|#
directive|define
name|INL
parameter_list|(
name|r
parameter_list|)
value|inl (np->port + offsetof(struct ncr_reg, r))
end_define

begin_define
define|#
directive|define
name|OUTB
parameter_list|(
name|r
parameter_list|,
name|val
parameter_list|)
value|outb (np->port+offsetof(struct ncr_reg,r),(val))
end_define

begin_define
define|#
directive|define
name|OUTW
parameter_list|(
name|r
parameter_list|,
name|val
parameter_list|)
value|outw (np->port+offsetof(struct ncr_reg,r),(val))
end_define

begin_define
define|#
directive|define
name|OUTL
parameter_list|(
name|r
parameter_list|,
name|val
parameter_list|)
value|outl (np->port+offsetof(struct ncr_reg,r),(val))
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|INB
parameter_list|(
name|r
parameter_list|)
value|(np->reg->r)
end_define

begin_define
define|#
directive|define
name|INW
parameter_list|(
name|r
parameter_list|)
value|(np->reg->r)
end_define

begin_define
define|#
directive|define
name|INL
parameter_list|(
name|r
parameter_list|)
value|(np->reg->r)
end_define

begin_define
define|#
directive|define
name|OUTB
parameter_list|(
name|r
parameter_list|,
name|val
parameter_list|)
value|np->reg->r = (val)
end_define

begin_define
define|#
directive|define
name|OUTW
parameter_list|(
name|r
parameter_list|,
name|val
parameter_list|)
value|np->reg->r = (val)
end_define

begin_define
define|#
directive|define
name|OUTL
parameter_list|(
name|r
parameter_list|,
name|val
parameter_list|)
value|np->reg->r = (val)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*========================================================== ** **	Command control block states. ** **========================================================== */
end_comment

begin_define
define|#
directive|define
name|HS_IDLE
value|(0)
end_define

begin_define
define|#
directive|define
name|HS_BUSY
value|(1)
end_define

begin_define
define|#
directive|define
name|HS_NEGOTIATE
value|(2)
end_define

begin_comment
comment|/* sync/wide data transfer*/
end_comment

begin_define
define|#
directive|define
name|HS_DISCONNECT
value|(3)
end_define

begin_comment
comment|/* Disconnected by target */
end_comment

begin_define
define|#
directive|define
name|HS_COMPLETE
value|(4)
end_define

begin_define
define|#
directive|define
name|HS_SEL_TIMEOUT
value|(5)
end_define

begin_comment
comment|/* Selection timeout      */
end_comment

begin_define
define|#
directive|define
name|HS_RESET
value|(6)
end_define

begin_comment
comment|/* SCSI reset	     */
end_comment

begin_define
define|#
directive|define
name|HS_ABORTED
value|(7)
end_define

begin_comment
comment|/* Transfer aborted       */
end_comment

begin_define
define|#
directive|define
name|HS_TIMEOUT
value|(8)
end_define

begin_comment
comment|/* Software timeout       */
end_comment

begin_define
define|#
directive|define
name|HS_FAIL
value|(9)
end_define

begin_comment
comment|/* SCSI or PCI bus errors */
end_comment

begin_define
define|#
directive|define
name|HS_UNEXPECTED
value|(10)
end_define

begin_comment
comment|/* Unexpected disconnect  */
end_comment

begin_define
define|#
directive|define
name|HS_DONEMASK
value|(0xfc)
end_define

begin_comment
comment|/*========================================================== ** **	Software Interrupt Codes ** **========================================================== */
end_comment

begin_define
define|#
directive|define
name|SIR_SENSE_RESTART
value|(1)
end_define

begin_define
define|#
directive|define
name|SIR_SENSE_FAILED
value|(2)
end_define

begin_define
define|#
directive|define
name|SIR_STALL_RESTART
value|(3)
end_define

begin_define
define|#
directive|define
name|SIR_STALL_QUEUE
value|(4)
end_define

begin_define
define|#
directive|define
name|SIR_NEGO_SYNC
value|(5)
end_define

begin_define
define|#
directive|define
name|SIR_NEGO_WIDE
value|(6)
end_define

begin_define
define|#
directive|define
name|SIR_NEGO_FAILED
value|(7)
end_define

begin_define
define|#
directive|define
name|SIR_NEGO_PROTO
value|(8)
end_define

begin_define
define|#
directive|define
name|SIR_REJECT_RECEIVED
value|(9)
end_define

begin_define
define|#
directive|define
name|SIR_REJECT_SENT
value|(10)
end_define

begin_define
define|#
directive|define
name|SIR_IGN_RESIDUE
value|(11)
end_define

begin_define
define|#
directive|define
name|SIR_MISSING_SAVE
value|(12)
end_define

begin_define
define|#
directive|define
name|SIR_MAX
value|(12)
end_define

begin_comment
comment|/*========================================================== ** **	Extended error codes. **	xerr_status field of struct ccb. ** **========================================================== */
end_comment

begin_define
define|#
directive|define
name|XE_OK
value|(0)
end_define

begin_define
define|#
directive|define
name|XE_EXTRA_DATA
value|(1)
end_define

begin_comment
comment|/* unexpected data phase */
end_comment

begin_define
define|#
directive|define
name|XE_BAD_PHASE
value|(2)
end_define

begin_comment
comment|/* illegal phase (4/5)   */
end_comment

begin_comment
comment|/*========================================================== ** **	Negotiation status. **	nego_status field	of struct ccb. ** **========================================================== */
end_comment

begin_define
define|#
directive|define
name|NS_SYNC
value|(1)
end_define

begin_define
define|#
directive|define
name|NS_WIDE
value|(2)
end_define

begin_comment
comment|/*========================================================== ** **	"Special features" of targets. **	quirks field		of struct tcb. **	actualquirks field	of struct ccb. ** **========================================================== */
end_comment

begin_define
define|#
directive|define
name|QUIRK_AUTOSAVE
value|(0x01)
end_define

begin_define
define|#
directive|define
name|QUIRK_NOMSG
value|(0x02)
end_define

begin_define
define|#
directive|define
name|QUIRK_NOSYNC
value|(0x10)
end_define

begin_define
define|#
directive|define
name|QUIRK_NOWIDE16
value|(0x20)
end_define

begin_define
define|#
directive|define
name|QUIRK_UPDATE
value|(0x80)
end_define

begin_comment
comment|/*========================================================== ** **	Capability bits in Inquire response byte 7. ** **========================================================== */
end_comment

begin_define
define|#
directive|define
name|INQ7_QUEUE
value|(0x02)
end_define

begin_define
define|#
directive|define
name|INQ7_SYNC
value|(0x10)
end_define

begin_define
define|#
directive|define
name|INQ7_WIDE16
value|(0x20)
end_define

begin_comment
comment|/*========================================================== ** **	Misc. ** **========================================================== */
end_comment

begin_define
define|#
directive|define
name|CCB_MAGIC
value|(0xf2691ad2)
end_define

begin_define
define|#
directive|define
name|MAX_TAGS
value|(16)
end_define

begin_comment
comment|/* hard limit */
end_comment

begin_comment
comment|/*========================================================== ** **	OS dependencies. ** **========================================================== */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__NetBSD__
end_ifdef

begin_define
define|#
directive|define
name|TIMEOUT
value|(void*)
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/*__NetBSD__*/
end_comment

begin_define
define|#
directive|define
name|TIMEOUT
value|(timeout_func_t)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*__NetBSD__*/
end_comment

begin_define
define|#
directive|define
name|PRINT_ADDR
parameter_list|(
name|xp
parameter_list|)
value|sc_print_addr(xp->sc_link)
end_define

begin_comment
comment|/*========================================================== ** **	Declaration of structs. ** **========================================================== */
end_comment

begin_struct_decl
struct_decl|struct
name|tcb
struct_decl|;
end_struct_decl

begin_struct_decl
struct_decl|struct
name|lcb
struct_decl|;
end_struct_decl

begin_struct_decl
struct_decl|struct
name|ccb
struct_decl|;
end_struct_decl

begin_struct_decl
struct_decl|struct
name|ncb
struct_decl|;
end_struct_decl

begin_struct_decl
struct_decl|struct
name|script
struct_decl|;
end_struct_decl

begin_typedef
typedef|typedef
name|struct
name|ncb
modifier|*
name|ncb_p
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|struct
name|tcb
modifier|*
name|tcb_p
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|struct
name|lcb
modifier|*
name|lcb_p
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|struct
name|ccb
modifier|*
name|ccb_p
typedef|;
end_typedef

begin_struct
struct|struct
name|link
block|{
name|u_long
name|l_cmd
decl_stmt|;
name|u_long
name|l_paddr
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|usrcmd
block|{
name|u_long
name|target
decl_stmt|;
name|u_long
name|lun
decl_stmt|;
name|u_long
name|data
decl_stmt|;
name|u_long
name|cmd
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|UC_SETSYNC
value|10
end_define

begin_define
define|#
directive|define
name|UC_SETTAGS
value|11
end_define

begin_define
define|#
directive|define
name|UC_SETDEBUG
value|12
end_define

begin_define
define|#
directive|define
name|UC_SETORDER
value|13
end_define

begin_define
define|#
directive|define
name|UC_SETWIDE
value|14
end_define

begin_define
define|#
directive|define
name|UC_SETFLAG
value|15
end_define

begin_define
define|#
directive|define
name|UF_TRACE
value|(0x01)
end_define

begin_comment
comment|/*--------------------------------------- ** **	Timestamps for profiling ** **--------------------------------------- */
end_comment

begin_struct
struct|struct
name|tstamp
block|{
name|struct
name|timeval
name|start
decl_stmt|;
name|struct
name|timeval
name|end
decl_stmt|;
name|struct
name|timeval
name|select
decl_stmt|;
name|struct
name|timeval
name|command
decl_stmt|;
name|struct
name|timeval
name|data
decl_stmt|;
name|struct
name|timeval
name|status
decl_stmt|;
name|struct
name|timeval
name|disconnect
decl_stmt|;
name|struct
name|timeval
name|reselect
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* **	profiling data (per device) */
end_comment

begin_struct
struct|struct
name|profile
block|{
name|u_long
name|num_trans
decl_stmt|;
name|u_long
name|num_bytes
decl_stmt|;
name|u_long
name|num_disc
decl_stmt|;
name|u_long
name|num_break
decl_stmt|;
name|u_long
name|num_int
decl_stmt|;
name|u_long
name|num_fly
decl_stmt|;
name|u_long
name|ms_setup
decl_stmt|;
name|u_long
name|ms_data
decl_stmt|;
name|u_long
name|ms_disc
decl_stmt|;
name|u_long
name|ms_post
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*========================================================== ** **	Declaration of structs:		target control block ** **========================================================== */
end_comment

begin_struct
struct|struct
name|tcb
block|{
comment|/* 	**	during reselection the ncr jumps to this point 	**	with SFBR set to the encoded target number 	**	with bit 7 set. 	**	if it's not this target, jump to the next. 	** 	**	JUMP  IF (SFBR != #target#) 	**	@(next tcb) 	*/
name|struct
name|link
name|jump_tcb
decl_stmt|;
comment|/* 	**	load the actual values for the sxfer and the scntl3 	**	register (sync/wide mode). 	** 	**	SCR_COPY (1); 	**	@(sval field of this tcb) 	**	@(sxfer register) 	**	SCR_COPY (1); 	**	@(wval field of this tcb) 	**	@(scntl3 register) 	*/
name|ncrcmd
name|getscr
index|[
literal|6
index|]
decl_stmt|;
comment|/* 	**	if next message is "identify" 	**	then load the message to SFBR, 	**	else load 0 to SFBR. 	** 	**	CALL 	**<RESEL_LUN> 	*/
name|struct
name|link
name|call_lun
decl_stmt|;
comment|/* 	**	now look for the right lun. 	** 	**	JUMP 	**	@(first ccb of this lun) 	*/
name|struct
name|link
name|jump_lcb
decl_stmt|;
comment|/* 	**	pointer to interrupted getcc ccb 	*/
name|ccb_p
name|hold_cp
decl_stmt|;
comment|/* 	**	statistical data 	*/
name|u_long
name|transfers
decl_stmt|;
name|u_long
name|bytes
decl_stmt|;
comment|/* 	**	user settable limits for sync transfer 	**	and tagged commands. 	*/
name|u_char
name|usrsync
decl_stmt|;
name|u_char
name|usrtags
decl_stmt|;
name|u_char
name|usrwide
decl_stmt|;
name|u_char
name|usrflag
decl_stmt|;
comment|/* 	**	negotiation of wide and synch transfer. 	**	device quirks. 	*/
comment|/*0*/
name|u_char
name|minsync
decl_stmt|;
comment|/*1*/
name|u_char
name|sval
decl_stmt|;
comment|/*2*/
name|u_short
name|period
decl_stmt|;
comment|/*0*/
name|u_char
name|maxoffs
decl_stmt|;
comment|/*1*/
name|u_char
name|quirks
decl_stmt|;
comment|/*2*/
name|u_char
name|widedone
decl_stmt|;
comment|/*3*/
name|u_char
name|wval
decl_stmt|;
comment|/* 	**	inquire data 	*/
define|#
directive|define
name|MAX_INQUIRE
value|36
name|u_char
name|inqdata
index|[
name|MAX_INQUIRE
index|]
decl_stmt|;
comment|/* 	**	the lcb's of this tcb 	*/
name|lcb_p
name|lp
index|[
name|MAX_LUN
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*========================================================== ** **	Declaration of structs:		lun control block ** **========================================================== */
end_comment

begin_struct
struct|struct
name|lcb
block|{
comment|/* 	**	during reselection the ncr jumps to this point 	**	with SFBR set to the "Identify" message. 	**	if it's not this lun, jump to the next. 	** 	**	JUMP  IF (SFBR != #lun#) 	**	@(next lcb of this target) 	*/
name|struct
name|link
name|jump_lcb
decl_stmt|;
comment|/* 	**	if next message is "simple tag", 	**	then load the tag to SFBR, 	**	else load 0 to SFBR. 	** 	**	CALL 	**<RESEL_TAG> 	*/
name|struct
name|link
name|call_tag
decl_stmt|;
comment|/* 	**	now look for the right ccb. 	** 	**	JUMP 	**	@(first ccb of this lun) 	*/
name|struct
name|link
name|jump_ccb
decl_stmt|;
comment|/* 	**	start of the ccb chain 	*/
name|ccb_p
name|next_ccb
decl_stmt|;
comment|/* 	**	Control of tagged queueing 	*/
name|u_char
name|reqccbs
decl_stmt|;
name|u_char
name|actccbs
decl_stmt|;
name|u_char
name|reqlink
decl_stmt|;
name|u_char
name|actlink
decl_stmt|;
name|u_char
name|usetags
decl_stmt|;
name|u_char
name|lasttag
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*========================================================== ** **      Declaration of structs:     COMMAND control block ** **========================================================== ** **	This substructure is copied from the ccb to a **	global address after selection (or reselection) **	and copied back before disconnect. ** **	These fields are accessible to the script processor. ** **---------------------------------------------------------- */
end_comment

begin_struct
struct|struct
name|head
block|{
comment|/* 	**	Execution of a ccb starts at this point. 	**	It's a jump to the "SELECT" label 	**	of the script. 	** 	**	After successful selection the script 	**	processor overwrites it with a jump to 	**	the IDLE label of the script. 	*/
name|struct
name|link
name|launch
decl_stmt|;
comment|/* 	**	Saved data pointer. 	**	Points to the position in the script 	**	responsible for the actual transfer 	**	of data. 	**	It's written after reception of a 	**	"SAVE_DATA_POINTER" message. 	**	The goalpointer points after 	**	the last transfer command. 	*/
name|u_long
name|savep
decl_stmt|;
name|u_long
name|lastp
decl_stmt|;
name|u_long
name|goalp
decl_stmt|;
comment|/* 	**	The virtual address of the ccb 	**	containing this header. 	*/
name|ccb_p
name|cp
decl_stmt|;
comment|/* 	**	space for some timestamps to gather 	**	profiling data about devices and this driver. 	*/
name|struct
name|tstamp
name|stamp
decl_stmt|;
comment|/* 	**	status fields. 	*/
name|u_char
name|status
index|[
literal|8
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* **	The status bytes are used by the host and the script processor. ** **	The first four byte are copied to the scratchb register **	(declared as scr0..scr3 in ncr_reg.h) just after the select/reselect, **	and copied back just after disconnecting. **	Inside the script the XX_REG are used. ** **	The last four bytes are used inside the script by "COPY" commands. **	Because source and destination must have the same alignment **	in a longword, the fields HAVE to be at the choosen offsets. **		xerr_st	(4)	0	(0x34)	scratcha **		sync_st	(5)	1	(0x05)	sxfer **		wide_st	(7)	3	(0x03)	scntl3 */
end_comment

begin_comment
comment|/* **	First four bytes (script) */
end_comment

begin_define
define|#
directive|define
name|QU_REG
value|scr0
end_define

begin_define
define|#
directive|define
name|HS_REG
value|scr1
end_define

begin_define
define|#
directive|define
name|HS_PRT
value|nc_scr1
end_define

begin_define
define|#
directive|define
name|SS_REG
value|scr2
end_define

begin_define
define|#
directive|define
name|PS_REG
value|scr3
end_define

begin_comment
comment|/* **	First four bytes (host) */
end_comment

begin_define
define|#
directive|define
name|actualquirks
value|phys.header.status[0]
end_define

begin_define
define|#
directive|define
name|host_status
value|phys.header.status[1]
end_define

begin_define
define|#
directive|define
name|scsi_status
value|phys.header.status[2]
end_define

begin_define
define|#
directive|define
name|parity_status
value|phys.header.status[3]
end_define

begin_comment
comment|/* **	Last four bytes (script) */
end_comment

begin_define
define|#
directive|define
name|xerr_st
value|header.status[4]
end_define

begin_comment
comment|/* MUST be ==0 mod 4 */
end_comment

begin_define
define|#
directive|define
name|sync_st
value|header.status[5]
end_define

begin_comment
comment|/* MUST be ==1 mod 4 */
end_comment

begin_define
define|#
directive|define
name|nego_st
value|header.status[6]
end_define

begin_define
define|#
directive|define
name|wide_st
value|header.status[7]
end_define

begin_comment
comment|/* MUST be ==3 mod 4 */
end_comment

begin_comment
comment|/* **	Last four bytes (host) */
end_comment

begin_define
define|#
directive|define
name|xerr_status
value|phys.xerr_st
end_define

begin_define
define|#
directive|define
name|sync_status
value|phys.sync_st
end_define

begin_define
define|#
directive|define
name|nego_status
value|phys.nego_st
end_define

begin_define
define|#
directive|define
name|wide_status
value|phys.wide_st
end_define

begin_comment
comment|/*========================================================== ** **      Declaration of structs:     Data structure block ** **========================================================== ** **	During execution of a ccb by the script processor, **	the DSA (data structure address) register points **	to this substructure of the ccb. **	This substructure contains the header with **	the script-processor-changable data and **	data blocks for the indirect move commands. ** **---------------------------------------------------------- */
end_comment

begin_struct
struct|struct
name|dsb
block|{
comment|/* 	**	Header. 	**	Has to be the first entry, 	**	because it's jumped to by the 	**	script processor 	*/
name|struct
name|head
name|header
decl_stmt|;
comment|/* 	**	Table data for Script 	*/
name|struct
name|scr_tblsel
name|select
decl_stmt|;
name|struct
name|scr_tblmove
name|smsg
decl_stmt|;
name|struct
name|scr_tblmove
name|smsg2
decl_stmt|;
name|struct
name|scr_tblmove
name|cmd
decl_stmt|;
name|struct
name|scr_tblmove
name|scmd
decl_stmt|;
name|struct
name|scr_tblmove
name|sense
decl_stmt|;
name|struct
name|scr_tblmove
name|data
index|[
name|MAX_SCATTER
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*========================================================== ** **      Declaration of structs:     Command control block. ** **========================================================== ** **	During execution of a ccb by the script processor, **	the DSA (data structure address) register points **	to this substructure of the ccb. **	This substructure contains the header with **	the script-processor-changable data and then **	data blocks for the indirect move commands. ** **---------------------------------------------------------- */
end_comment

begin_struct
struct|struct
name|ccb
block|{
comment|/* 	**	during reselection the ncr jumps to this point. 	**	If a "SIMPLE_TAG" message was received, 	**	then SFBR is set to the tag. 	**	else SFBR is set to 0 	**	If looking for another tag, jump to the next ccb. 	** 	**	JUMP  IF (SFBR != #TAG#) 	**	@(next ccb of this lun) 	*/
name|struct
name|link
name|jump_ccb
decl_stmt|;
comment|/* 	**	After execution of this call, the return address 	**	(in  the TEMP register) points to the following 	**	data structure block. 	**	So copy it to the DSA register, and start 	**	processing of this data structure. 	** 	**	CALL 	**<RESEL_TMP> 	*/
name|struct
name|link
name|call_tmp
decl_stmt|;
comment|/* 	**	This is the data structure which is 	**	to be executed by the script processor. 	*/
name|struct
name|dsb
name|phys
decl_stmt|;
comment|/* 	**	If a data transfer phase is terminated too early 	**	(after reception of a message (i.e. DISCONNECT)), 	**	we have to prepare a mini script to transfer 	**	the rest of the data. 	*/
name|u_long
name|patch
index|[
literal|8
index|]
decl_stmt|;
comment|/* 	**	The general SCSI driver provides a 	**	pointer to a control block. 	*/
name|struct
name|scsi_xfer
modifier|*
name|xfer
decl_stmt|;
comment|/* 	**	We prepare a message to be sent after selection, 	**	and a second one to be sent after getcc selection. 	**      Contents are IDENTIFY and SIMPLE_TAG. 	**	While negotiating sync or wide transfer, 	**	a SDTM or WDTM message is appended. 	*/
name|u_char
name|scsi_smsg
index|[
literal|8
index|]
decl_stmt|;
name|u_char
name|scsi_smsg2
index|[
literal|8
index|]
decl_stmt|;
comment|/* 	**	Lock this ccb. 	**	Flag is used while looking for a free ccb. 	*/
name|u_long
name|magic
decl_stmt|;
comment|/* 	**	Physical address of this instance of ccb 	*/
name|u_long
name|p_ccb
decl_stmt|;
comment|/* 	**	Completion time out for this job. 	**	It's set to time of start + allowed number of seconds. 	*/
name|u_long
name|tlimit
decl_stmt|;
comment|/* 	**	All ccbs of one hostadapter are chained. 	*/
name|ccb_p
name|link_ccb
decl_stmt|;
comment|/* 	**	All ccbs of one target/lun are chained. 	*/
name|ccb_p
name|next_ccb
decl_stmt|;
comment|/* 	**	Sense command 	*/
name|u_char
name|sensecmd
index|[
literal|6
index|]
decl_stmt|;
comment|/* 	**	Tag for this transfer. 	**	It's patched into jump_ccb. 	**	If it's not zero, a SIMPLE_TAG 	**	message is included in smsg. 	*/
name|u_char
name|tag
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|CCB_PHYS
parameter_list|(
name|cp
parameter_list|,
name|lbl
parameter_list|)
value|(cp->p_ccb + offsetof(struct ccb, lbl))
end_define

begin_comment
comment|/*========================================================== ** **      Declaration of structs:     NCR device descriptor ** **========================================================== */
end_comment

begin_struct
struct|struct
name|ncb
block|{
ifdef|#
directive|ifdef
name|__NetBSD__
name|struct
name|device
name|sc_dev
decl_stmt|;
name|void
modifier|*
name|sc_ih
decl_stmt|;
else|#
directive|else
comment|/* !__NetBSD__ */
name|int
name|unit
decl_stmt|;
endif|#
directive|endif
comment|/* __NetBSD__ */
comment|/*----------------------------------------------- 	**	Scripts .. 	**----------------------------------------------- 	** 	**	During reselection the ncr jumps to this point. 	**	The SFBR register is loaded with the encoded target id. 	** 	**	Jump to the first target. 	** 	**	JUMP 	**	@(next tcb) 	*/
name|struct
name|link
name|jump_tcb
decl_stmt|;
comment|/*----------------------------------------------- 	**	Configuration .. 	**----------------------------------------------- 	** 	**	virtual and physical addresses 	**	of the 53c810 chip. 	*/
name|vm_offset_t
name|vaddr
decl_stmt|;
name|vm_offset_t
name|paddr
decl_stmt|;
comment|/* 	**	pointer to the chip's registers. 	*/
specifier|volatile
name|struct
name|ncr_reg
modifier|*
name|reg
decl_stmt|;
comment|/* 	**	A copy of the script, relocated for this ncb. 	*/
name|struct
name|script
modifier|*
name|script
decl_stmt|;
comment|/* 	**	Physical address of this instance of ncb->script 	*/
name|u_long
name|p_script
decl_stmt|;
comment|/* 	**	The SCSI address of the host adapter. 	*/
name|u_char
name|myaddr
decl_stmt|;
comment|/* 	**	timing parameters 	*/
name|u_char
name|ns_sync
decl_stmt|;
name|u_char
name|maxoffs
decl_stmt|;
name|u_char
name|rv_scntl3
decl_stmt|;
comment|/*----------------------------------------------- 	**	Link to the generic SCSI driver 	**----------------------------------------------- 	*/
name|struct
name|scsi_link
name|sc_link
decl_stmt|;
comment|/*----------------------------------------------- 	**	Job control 	**----------------------------------------------- 	** 	**	Commands from user 	*/
name|struct
name|usrcmd
name|user
decl_stmt|;
name|u_char
name|order
decl_stmt|;
comment|/* 	**	Target data 	*/
name|struct
name|tcb
name|target
index|[
name|MAX_TARGET
index|]
decl_stmt|;
comment|/* 	**	Start queue. 	*/
name|u_long
name|squeue
index|[
name|MAX_START
index|]
decl_stmt|;
name|u_short
name|squeueput
decl_stmt|;
name|u_short
name|actccbs
decl_stmt|;
comment|/* 	**	Timeout handler 	*/
name|u_long
name|heartbeat
decl_stmt|;
name|u_short
name|ticks
decl_stmt|;
name|u_short
name|latetime
decl_stmt|;
name|u_long
name|lasttime
decl_stmt|;
comment|/*----------------------------------------------- 	**	Debug and profiling 	**----------------------------------------------- 	** 	**	register dump 	*/
name|struct
name|ncr_reg
name|regdump
decl_stmt|;
name|struct
name|timeval
name|regtime
decl_stmt|;
comment|/* 	**	Profiling data 	*/
name|struct
name|profile
name|profile
decl_stmt|;
name|u_long
name|disc_phys
decl_stmt|;
name|u_long
name|disc_ref
decl_stmt|;
comment|/* 	**	The global header. 	**	Accessible to both the host and the 	**	script-processor. 	*/
name|struct
name|head
name|header
decl_stmt|;
comment|/* 	**	The global control block. 	**	It's used only during the configuration phase. 	**	A target control block will be created 	**	after the first successful transfer. 	*/
name|struct
name|ccb
name|ccb
decl_stmt|;
comment|/* 	**	message buffers. 	**	Should be longword aligned, 	**	because they're written with a 	**	COPY script command. 	*/
name|u_char
name|msgout
index|[
literal|8
index|]
decl_stmt|;
name|u_char
name|msgin
index|[
literal|8
index|]
decl_stmt|;
name|u_long
name|lastmsg
decl_stmt|;
comment|/* 	**	Buffer for STATUS_IN phase. 	*/
name|u_char
name|scratch
decl_stmt|;
comment|/* 	**	controller chip dependent maximal transfer width. 	*/
name|u_char
name|maxwide
decl_stmt|;
comment|/* 	**	option for M_IDENTIFY message: enables disconnecting 	*/
name|u_char
name|disc
decl_stmt|;
ifdef|#
directive|ifdef
name|NCR_IOMAPPED
comment|/* 	**	address of the ncr control registers in io space 	*/
name|u_short
name|port
decl_stmt|;
endif|#
directive|endif
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|NCB_SCRIPT_PHYS
parameter_list|(
name|np
parameter_list|,
name|lbl
parameter_list|)
value|(np->p_script + offsetof (struct script, lbl))
end_define

begin_comment
comment|/*========================================================== ** ** **      Script for NCR-Processor. ** **	Use ncr_script_fill() to create the variable parts. **	Use ncr_script_copy_and_bind() to make a copy and **	bind to physical addresses. ** ** **========================================================== ** **	We have to know the offsets of all labels before **	we reach them (for forward jumps). **	Therefore we declare a struct here. **	If you make changes inside the script, **	DONT FORGET TO CHANGE THE LENGTHS HERE! ** **---------------------------------------------------------- */
end_comment

begin_struct
struct|struct
name|script
block|{
name|ncrcmd
name|start
index|[
literal|7
index|]
decl_stmt|;
name|ncrcmd
name|start0
index|[
literal|2
index|]
decl_stmt|;
name|ncrcmd
name|start1
index|[
literal|3
index|]
decl_stmt|;
name|ncrcmd
name|startpos
index|[
literal|1
index|]
decl_stmt|;
name|ncrcmd
name|tryloop
index|[
name|MAX_START
operator|*
literal|5
operator|+
literal|2
index|]
decl_stmt|;
name|ncrcmd
name|trysel
index|[
literal|8
index|]
decl_stmt|;
name|ncrcmd
name|skip
index|[
literal|8
index|]
decl_stmt|;
name|ncrcmd
name|skip2
index|[
literal|3
index|]
decl_stmt|;
name|ncrcmd
name|idle
index|[
literal|2
index|]
decl_stmt|;
name|ncrcmd
name|select
index|[
literal|22
index|]
decl_stmt|;
name|ncrcmd
name|prepare
index|[
literal|4
index|]
decl_stmt|;
name|ncrcmd
name|loadpos
index|[
literal|14
index|]
decl_stmt|;
name|ncrcmd
name|prepare2
index|[
literal|24
index|]
decl_stmt|;
name|ncrcmd
name|setmsg
index|[
literal|5
index|]
decl_stmt|;
name|ncrcmd
name|clrack
index|[
literal|2
index|]
decl_stmt|;
name|ncrcmd
name|dispatch
index|[
literal|33
index|]
decl_stmt|;
name|ncrcmd
name|no_data
index|[
literal|17
index|]
decl_stmt|;
name|ncrcmd
name|checkatn
index|[
literal|10
index|]
decl_stmt|;
name|ncrcmd
name|command
index|[
literal|15
index|]
decl_stmt|;
name|ncrcmd
name|status
index|[
literal|27
index|]
decl_stmt|;
name|ncrcmd
name|msg_in
index|[
literal|26
index|]
decl_stmt|;
name|ncrcmd
name|msg_bad
index|[
literal|6
index|]
decl_stmt|;
name|ncrcmd
name|msg_parity
index|[
literal|6
index|]
decl_stmt|;
name|ncrcmd
name|msg_reject
index|[
literal|8
index|]
decl_stmt|;
name|ncrcmd
name|msg_ign_residue
index|[
literal|32
index|]
decl_stmt|;
name|ncrcmd
name|msg_extended
index|[
literal|18
index|]
decl_stmt|;
name|ncrcmd
name|msg_ext_2
index|[
literal|18
index|]
decl_stmt|;
name|ncrcmd
name|msg_wdtr
index|[
literal|27
index|]
decl_stmt|;
name|ncrcmd
name|msg_ext_3
index|[
literal|18
index|]
decl_stmt|;
name|ncrcmd
name|msg_sdtr
index|[
literal|27
index|]
decl_stmt|;
name|ncrcmd
name|complete
index|[
literal|13
index|]
decl_stmt|;
name|ncrcmd
name|cleanup
index|[
literal|12
index|]
decl_stmt|;
name|ncrcmd
name|cleanup0
index|[
literal|11
index|]
decl_stmt|;
name|ncrcmd
name|signal
index|[
literal|10
index|]
decl_stmt|;
name|ncrcmd
name|save_dp
index|[
literal|5
index|]
decl_stmt|;
name|ncrcmd
name|restore_dp
index|[
literal|5
index|]
decl_stmt|;
name|ncrcmd
name|disconnect
index|[
literal|12
index|]
decl_stmt|;
name|ncrcmd
name|disconnect0
index|[
literal|5
index|]
decl_stmt|;
name|ncrcmd
name|disconnect1
index|[
literal|23
index|]
decl_stmt|;
name|ncrcmd
name|msg_out
index|[
literal|9
index|]
decl_stmt|;
name|ncrcmd
name|msg_out_done
index|[
literal|7
index|]
decl_stmt|;
name|ncrcmd
name|msg_out_abort
index|[
literal|10
index|]
decl_stmt|;
name|ncrcmd
name|getcc
index|[
literal|4
index|]
decl_stmt|;
name|ncrcmd
name|getcc1
index|[
literal|5
index|]
decl_stmt|;
ifdef|#
directive|ifdef
name|NCR_GETCC_WITHMSG
name|ncrcmd
name|getcc2
index|[
literal|33
index|]
decl_stmt|;
else|#
directive|else
name|ncrcmd
name|getcc2
index|[
literal|14
index|]
decl_stmt|;
endif|#
directive|endif
name|ncrcmd
name|getcc3
index|[
literal|10
index|]
decl_stmt|;
name|ncrcmd
name|badgetcc
index|[
literal|6
index|]
decl_stmt|;
name|ncrcmd
name|reselect
index|[
literal|12
index|]
decl_stmt|;
name|ncrcmd
name|reselect2
index|[
literal|6
index|]
decl_stmt|;
name|ncrcmd
name|resel_tmp
index|[
literal|5
index|]
decl_stmt|;
name|ncrcmd
name|resel_lun
index|[
literal|18
index|]
decl_stmt|;
name|ncrcmd
name|resel_tag
index|[
literal|24
index|]
decl_stmt|;
name|ncrcmd
name|data_in
index|[
name|MAX_SCATTER
operator|*
literal|4
operator|+
literal|7
index|]
decl_stmt|;
name|ncrcmd
name|data_out
index|[
name|MAX_SCATTER
operator|*
literal|4
operator|+
literal|7
index|]
decl_stmt|;
name|ncrcmd
name|aborttag
index|[
literal|4
index|]
decl_stmt|;
name|ncrcmd
name|abort
index|[
literal|22
index|]
decl_stmt|;
name|ncrcmd
name|snooptest
index|[
literal|9
index|]
decl_stmt|;
name|ncrcmd
name|snoopend
index|[
literal|2
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*========================================================== ** ** **      Function headers. ** ** **========================================================== */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|KERNEL
end_ifdef

begin_function_decl
specifier|static
name|void
name|ncr_alloc_ccb
parameter_list|(
name|ncb_p
name|np
parameter_list|,
name|u_long
name|target
parameter_list|,
name|u_long
name|lun
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ncr_complete
parameter_list|(
name|ncb_p
name|np
parameter_list|,
name|ccb_p
name|cp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ncr_delta
parameter_list|(
name|struct
name|timeval
modifier|*
name|from
parameter_list|,
name|struct
name|timeval
modifier|*
name|to
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ncr_exception
parameter_list|(
name|ncb_p
name|np
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ncr_free_ccb
parameter_list|(
name|ncb_p
name|np
parameter_list|,
name|ccb_p
name|cp
parameter_list|,
name|int
name|flags
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ncr_getclock
parameter_list|(
name|ncb_p
name|np
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ccb_p
name|ncr_get_ccb
parameter_list|(
name|ncb_p
name|np
parameter_list|,
name|u_long
name|flags
parameter_list|,
name|u_long
name|t
parameter_list|,
name|u_long
name|l
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u_int32_t
name|ncr_info
parameter_list|(
name|int
name|unit
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ncr_init
parameter_list|(
name|ncb_p
name|np
parameter_list|,
name|char
modifier|*
name|msg
parameter_list|,
name|u_long
name|code
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ncr_intr
parameter_list|(
name|void
modifier|*
name|vnp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ncr_int_ma
parameter_list|(
name|ncb_p
name|np
parameter_list|,
name|u_char
name|dstat
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ncr_int_sir
parameter_list|(
name|ncb_p
name|np
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ncr_int_sto
parameter_list|(
name|ncb_p
name|np
parameter_list|)
function_decl|;
end_function_decl

begin_ifndef
ifndef|#
directive|ifndef
name|NEW_SCSICONF
end_ifndef

begin_function_decl
specifier|static
name|u_long
name|ncr_lookup
parameter_list|(
name|char
modifier|*
name|id
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NEW_SCSICONF */
end_comment

begin_function_decl
specifier|static
name|void
name|ncr_min_phys
parameter_list|(
name|struct
name|buf
modifier|*
name|bp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ncr_negotiate
parameter_list|(
name|struct
name|ncb
modifier|*
name|np
parameter_list|,
name|struct
name|tcb
modifier|*
name|tp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ncr_opennings
parameter_list|(
name|ncb_p
name|np
parameter_list|,
name|lcb_p
name|lp
parameter_list|,
name|struct
name|scsi_xfer
modifier|*
name|xp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ncb_profile
parameter_list|(
name|ncb_p
name|np
parameter_list|,
name|ccb_p
name|cp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ncr_script_copy_and_bind
parameter_list|(
name|struct
name|script
modifier|*
name|script
parameter_list|,
name|ncb_p
name|np
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ncr_script_fill
parameter_list|(
name|struct
name|script
modifier|*
name|scr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ncr_scatter
parameter_list|(
name|struct
name|dsb
modifier|*
name|phys
parameter_list|,
name|vm_offset_t
name|vaddr
parameter_list|,
name|vm_size_t
name|datalen
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ncr_setmaxtags
parameter_list|(
name|tcb_p
name|tp
parameter_list|,
name|u_long
name|usrtags
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ncr_setsync
parameter_list|(
name|ncb_p
name|np
parameter_list|,
name|ccb_p
name|cp
parameter_list|,
name|u_char
name|sxfer
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ncr_settags
parameter_list|(
name|tcb_p
name|tp
parameter_list|,
name|lcb_p
name|lp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ncr_setwide
parameter_list|(
name|ncb_p
name|np
parameter_list|,
name|ccb_p
name|cp
parameter_list|,
name|u_char
name|wide
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ncr_show_msg
parameter_list|(
name|u_char
modifier|*
name|msg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ncr_snooptest
parameter_list|(
name|ncb_p
name|np
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int32_t
name|ncr_start
parameter_list|(
name|struct
name|scsi_xfer
modifier|*
name|xp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ncr_timeout
parameter_list|(
name|ncb_p
name|np
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ncr_usercmd
parameter_list|(
name|ncb_p
name|np
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ncr_wakeup
parameter_list|(
name|ncb_p
name|np
parameter_list|,
name|u_long
name|code
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|__NetBSD__
end_ifdef

begin_function_decl
specifier|static
name|int
name|ncr_probe
parameter_list|(
name|struct
name|device
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ncr_attach
parameter_list|(
name|struct
name|device
modifier|*
parameter_list|,
name|struct
name|device
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* !__NetBSD */
end_comment

begin_function_decl
specifier|static
name|char
modifier|*
name|ncr_probe
parameter_list|(
name|pcici_t
name|tag
parameter_list|,
name|pcidi_t
name|type
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ncr_attach
parameter_list|(
name|pcici_t
name|tag
parameter_list|,
name|int
name|unit
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __NetBSD__ */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* KERNEL */
end_comment

begin_comment
comment|/*========================================================== ** ** **      Global static data. ** ** **========================================================== */
end_comment

begin_decl_stmt
specifier|static
name|char
name|ident
index|[]
init|=
literal|"\n$Id: ncr.c,v 1.82.2.7 1997/07/11 18:39:59 se Exp $\n"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|u_long
name|ncr_version
init|=
name|NCR_VERSION
operator|*
literal|11
operator|+
operator|(
name|u_long
operator|)
sizeof|sizeof
argument_list|(
expr|struct
name|ncb
argument_list|)
operator|*
literal|7
operator|+
operator|(
name|u_long
operator|)
sizeof|sizeof
argument_list|(
expr|struct
name|ccb
argument_list|)
operator|*
literal|5
operator|+
operator|(
name|u_long
operator|)
sizeof|sizeof
argument_list|(
expr|struct
name|lcb
argument_list|)
operator|*
literal|3
operator|+
operator|(
name|u_long
operator|)
sizeof|sizeof
argument_list|(
expr|struct
name|tcb
argument_list|)
operator|*
literal|2
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|KERNEL
end_ifdef

begin_decl_stmt
specifier|static
specifier|const
name|int
name|nncr
init|=
name|MAX_UNITS
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* XXX to be replaced by SYSCTL */
end_comment

begin_decl_stmt
name|ncb_p
name|ncrp
index|[
name|MAX_UNITS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* XXX to be replaced by SYSCTL */
end_comment

begin_decl_stmt
specifier|static
name|int
name|ncr_debug
init|=
name|SCSI_NCR_DEBUG
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_debug
argument_list|,
name|OID_AUTO
argument_list|,
name|ncr_debug
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|ncr_debug
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|ncr_cache
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* to be aligned _NOT_ static */
end_comment

begin_comment
comment|/*========================================================== ** ** **      Global static data:	auto configure ** ** **========================================================== */
end_comment

begin_define
define|#
directive|define
name|NCR_810_ID
value|(0x00011000ul)
end_define

begin_define
define|#
directive|define
name|NCR_815_ID
value|(0x00041000ul)
end_define

begin_define
define|#
directive|define
name|NCR_820_ID
value|(0x00021000ul)
end_define

begin_define
define|#
directive|define
name|NCR_825_ID
value|(0x00031000ul)
end_define

begin_define
define|#
directive|define
name|NCR_860_ID
value|(0x00061000ul)
end_define

begin_define
define|#
directive|define
name|NCR_875_ID
value|(0x000f1000ul)
end_define

begin_define
define|#
directive|define
name|NCR_875_ID2
value|(0x008f1000ul)
end_define

begin_define
define|#
directive|define
name|NCR_885_ID
value|(0x000d1000ul)
end_define

begin_define
define|#
directive|define
name|NCR_895_ID
value|(0x000c1000ul)
end_define

begin_define
define|#
directive|define
name|NCR_896_ID
value|(0x000b1000ul)
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|__NetBSD__
end_ifdef

begin_decl_stmt
name|struct
name|cfdriver
name|ncrcd
init|=
block|{
name|NULL
block|,
literal|"ncr"
block|,
name|ncr_probe
block|,
name|ncr_attach
block|,
name|DV_DISK
block|,
expr|sizeof
operator|(
expr|struct
name|ncb
operator|)
block|}
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* !__NetBSD__ */
end_comment

begin_decl_stmt
specifier|static
name|u_long
name|ncr_count
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|pci_device
name|ncr_device
init|=
block|{
literal|"ncr"
block|,
name|ncr_probe
block|,
name|ncr_attach
block|,
operator|&
name|ncr_count
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DATA_SET
argument_list|(
name|pcidevice_set
argument_list|,
name|ncr_device
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !__NetBSD__ */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|scsi_adapter
name|ncr_switch
init|=
block|{
name|ncr_start
block|,
name|ncr_min_phys
block|,
literal|0
block|,
literal|0
block|,
ifndef|#
directive|ifndef
name|__NetBSD__
name|ncr_info
block|,
literal|"ncr"
block|,
endif|#
directive|endif
comment|/* !__NetBSD__ */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|scsi_device
name|ncr_dev
init|=
block|{
name|NULL
block|,
comment|/* Use default error handler */
name|NULL
block|,
comment|/* have a queue, served by this */
name|NULL
block|,
comment|/* have no async handler */
name|NULL
block|,
comment|/* Use default 'done' routine */
ifndef|#
directive|ifndef
name|__NetBSD__
literal|"ncr"
block|,
endif|#
directive|endif
comment|/* !__NetBSD__ */
block|}
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|__NetBSD__
end_ifdef

begin_define
define|#
directive|define
name|ncr_name
parameter_list|(
name|np
parameter_list|)
value|(np->sc_dev.dv_xname)
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* !__NetBSD__ */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|ncr_name
parameter_list|(
name|ncb_p
name|np
parameter_list|)
block|{
specifier|static
name|char
name|name
index|[
literal|10
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|name
argument_list|,
literal|"ncr%d"
argument_list|,
name|np
operator|->
name|unit
argument_list|)
expr_stmt|;
return|return
operator|(
name|name
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*========================================================== ** ** **      Scripts for NCR-Processor. ** **      Use ncr_script_bind for binding to physical addresses. ** ** **========================================================== ** **	NADDR generates a reference to a field of the controller data. **	PADDR generates a reference to another part of the script. **	RADDR generates a reference to a script processor register. **	FADDR generates a reference to a script processor register **		with offset. ** **---------------------------------------------------------- */
end_comment

begin_define
define|#
directive|define
name|RELOC_SOFTC
value|0x40000000
end_define

begin_define
define|#
directive|define
name|RELOC_LABEL
value|0x50000000
end_define

begin_define
define|#
directive|define
name|RELOC_REGISTER
value|0x60000000
end_define

begin_define
define|#
directive|define
name|RELOC_MASK
value|0xf0000000
end_define

begin_define
define|#
directive|define
name|NADDR
parameter_list|(
name|label
parameter_list|)
value|(RELOC_SOFTC | offsetof(struct ncb, label))
end_define

begin_define
define|#
directive|define
name|PADDR
parameter_list|(
name|label
parameter_list|)
value|(RELOC_LABEL | offsetof(struct script, label))
end_define

begin_define
define|#
directive|define
name|RADDR
parameter_list|(
name|label
parameter_list|)
value|(RELOC_REGISTER | REG(label))
end_define

begin_define
define|#
directive|define
name|FADDR
parameter_list|(
name|label
parameter_list|,
name|ofs
parameter_list|)
value|(RELOC_REGISTER | ((REG(label))+(ofs)))
end_define

begin_decl_stmt
specifier|static
name|struct
name|script
name|script0
init|=
block|{
comment|/*--------------------------< START>-----------------------*/
block|{
comment|/* 	**	Claim to be still alive ... 	*/
name|SCR_COPY
argument_list|(
sizeof|sizeof
argument_list|(
operator|(
operator|(
expr|struct
name|ncb
operator|*
operator|)
literal|0
operator|)
operator|->
name|heartbeat
argument_list|)
argument_list|)
block|,
operator|(
name|ncrcmd
operator|)
operator|&
name|time
operator|.
name|tv_sec
block|,
name|NADDR
argument_list|(
name|heartbeat
argument_list|)
block|,
comment|/* 	**      Make data structure address invalid. 	**      clear SIGP. 	*/
name|SCR_LOAD_REG
argument_list|(
name|dsa
argument_list|,
literal|0xff
argument_list|)
block|,
literal|0
block|,
name|SCR_FROM_REG
argument_list|(
name|ctest2
argument_list|)
block|,
literal|0
block|, }
comment|/*-------------------------< START0>----------------------*/
block|,
block|{
comment|/* 	**	Hook for interrupted GetConditionCode. 	**	Will be patched to ... IFTRUE by 	**	the interrupt handler. 	*/
name|SCR_INT
operator|^
name|IFFALSE
argument_list|(
literal|0
argument_list|)
block|,
name|SIR_SENSE_RESTART
block|,  }
comment|/*-------------------------< START1>----------------------*/
block|,
block|{
comment|/* 	**	Hook for stalled start queue. 	**	Will be patched to IFTRUE by the interrupt handler. 	*/
name|SCR_INT
operator|^
name|IFFALSE
argument_list|(
literal|0
argument_list|)
block|,
name|SIR_STALL_RESTART
block|,
comment|/* 	**	Then jump to a certain point in tryloop. 	**	Due to the lack of indirect addressing the code 	**	is self modifying here. 	*/
name|SCR_JUMP
block|, }
comment|/*-------------------------< STARTPOS>--------------------*/
block|,
block|{
name|PADDR
argument_list|(
name|tryloop
argument_list|)
block|, }
comment|/*-------------------------< TRYLOOP>---------------------*/
block|,
block|{
comment|/* **	Load an entry of the start queue into dsa **	and try to start it by jumping to TRYSEL. ** **	Because the size depends on the **	#define MAX_START parameter, it is filled **	in at runtime. ** **----------------------------------------------------------- ** **  ##===========< I=0; i<MAX_START>=========== **  ||	SCR_COPY (4), **  ||		NADDR (squeue[i]), **  ||		RADDR (dsa), **  ||	SCR_CALL, **  ||		PADDR (trysel), **  ##========================================== ** **	SCR_JUMP, **		PADDR(tryloop), ** **----------------------------------------------------------- */
literal|0
block|}
comment|/*-------------------------< TRYSEL>----------------------*/
block|,
block|{
comment|/* 	**	Now: 	**	DSA: Address of a Data Structure 	**	or   Address of the IDLE-Label. 	** 	**	TEMP:	Address of a script, which tries to 	**		start the NEXT entry. 	** 	**	Save the TEMP register into the SCRATCHA register. 	**	Then copy the DSA to TEMP and RETURN. 	**	This is kind of an indirect jump. 	**	(The script processor has NO stack, so the 	**	CALL is actually a jump and link, and the 	**	RETURN is an indirect jump.) 	** 	**	If the slot was empty, DSA contains the address 	**	of the IDLE part of this script. The processor 	**	jumps to IDLE and waits for a reselect. 	**	It will wake up and try the same slot again 	**	after the SIGP bit becomes set by the host. 	** 	**	If the slot was not empty, DSA contains 	**	the address of the phys-part of a ccb. 	**	The processor jumps to this address. 	**	phys starts with head, 	**	head starts with launch, 	**	so actually the processor jumps to 	**	the lauch part. 	**	If the entry is scheduled for execution, 	**	then launch contains a jump to SELECT. 	**	If it's not scheduled, it contains a jump to IDLE. 	*/
name|SCR_COPY
argument_list|(
literal|4
argument_list|)
block|,
name|RADDR
argument_list|(
name|temp
argument_list|)
block|,
name|RADDR
argument_list|(
name|scratcha
argument_list|)
block|,
name|SCR_COPY
argument_list|(
literal|4
argument_list|)
block|,
name|RADDR
argument_list|(
name|dsa
argument_list|)
block|,
name|RADDR
argument_list|(
name|temp
argument_list|)
block|,
name|SCR_RETURN
block|,
literal|0
block|}
comment|/*-------------------------< SKIP>------------------------*/
block|,
block|{
comment|/* 	**	This entry has been canceled. 	**	Next time use the next slot. 	*/
name|SCR_COPY
argument_list|(
literal|4
argument_list|)
block|,
name|RADDR
argument_list|(
name|scratcha
argument_list|)
block|,
name|PADDR
argument_list|(
name|startpos
argument_list|)
block|,
comment|/* 	**	patch the launch field. 	**	should look like an idle process. 	*/
name|SCR_COPY
argument_list|(
literal|4
argument_list|)
block|,
name|RADDR
argument_list|(
name|dsa
argument_list|)
block|,
name|PADDR
argument_list|(
name|skip2
argument_list|)
block|,
name|SCR_COPY
argument_list|(
literal|8
argument_list|)
block|,
name|PADDR
argument_list|(
name|idle
argument_list|)
block|, }
comment|/*-------------------------< SKIP2>-----------------------*/
block|,
block|{
literal|0
block|,
name|SCR_JUMP
block|,
name|PADDR
argument_list|(
name|start
argument_list|)
block|, }
comment|/*-------------------------< IDLE>------------------------*/
block|,
block|{
comment|/* 	**	Nothing to do? 	**	Wait for reselect. 	*/
name|SCR_JUMP
block|,
name|PADDR
argument_list|(
name|reselect
argument_list|)
block|,  }
comment|/*-------------------------< SELECT>----------------------*/
block|,
block|{
comment|/* 	**	DSA	contains the address of a scheduled 	**		data structure. 	** 	**	SCRATCHA contains the address of the script, 	**		which starts the next entry. 	** 	**	Set Initiator mode. 	** 	**	(Target mode is left as an exercise for the reader) 	*/
name|SCR_CLR
argument_list|(
name|SCR_TRG
argument_list|)
block|,
literal|0
block|,
name|SCR_LOAD_REG
argument_list|(
name|HS_REG
argument_list|,
literal|0xff
argument_list|)
block|,
literal|0
block|,
comment|/* 	**      And try to select this target. 	*/
name|SCR_SEL_TBL_ATN
operator|^
name|offsetof
argument_list|(
expr|struct
name|dsb
argument_list|,
name|select
argument_list|)
block|,
name|PADDR
argument_list|(
name|reselect
argument_list|)
block|,
comment|/* 	**	Now there are 4 possibilities: 	** 	**	(1) The ncr looses arbitration. 	**	This is ok, because it will try again, 	**	when the bus becomes idle. 	**	(But beware of the timeout function!) 	** 	**	(2) The ncr is reselected. 	**	Then the script processor takes the jump 	**	to the RESELECT label. 	** 	**	(3) The ncr completes the selection. 	**	Then it will execute the next statement. 	** 	**	(4) There is a selection timeout. 	**	Then the ncr should interrupt the host and stop. 	**	Unfortunately, it seems to continue execution 	**	of the script. But it will fail with an 	**	IID-interrupt on the next WHEN. 	*/
name|SCR_JUMPR
operator|^
name|IFTRUE
argument_list|(
name|WHEN
argument_list|(
name|SCR_MSG_IN
argument_list|)
argument_list|)
block|,
literal|0
block|,
comment|/* 	**	Save target id to ctest0 register 	*/
name|SCR_FROM_REG
argument_list|(
name|sdid
argument_list|)
block|,
literal|0
block|,
name|SCR_TO_REG
argument_list|(
name|ctest0
argument_list|)
block|,
literal|0
block|,
comment|/* 	**	Send the IDENTIFY and SIMPLE_TAG messages 	**	(and the M_X_SYNC_REQ message) 	*/
name|SCR_MOVE_TBL
operator|^
name|SCR_MSG_OUT
block|,
name|offsetof
argument_list|(
expr|struct
name|dsb
argument_list|,
name|smsg
argument_list|)
block|,
ifdef|#
directive|ifdef
name|undef
comment|/* XXX better fail than try to deal with this ... */
name|SCR_JUMPR
operator|^
name|IFTRUE
argument_list|(
name|WHEN
argument_list|(
name|SCR_MSG_OUT
argument_list|)
argument_list|)
block|,
operator|-
literal|16
block|,
endif|#
directive|endif
name|SCR_CLR
argument_list|(
name|SCR_ATN
argument_list|)
block|,
literal|0
block|,
name|SCR_COPY
argument_list|(
literal|1
argument_list|)
block|,
name|RADDR
argument_list|(
name|sfbr
argument_list|)
block|,
name|NADDR
argument_list|(
name|lastmsg
argument_list|)
block|,
comment|/* 	**	Selection complete. 	**	Next time use the next slot. 	*/
name|SCR_COPY
argument_list|(
literal|4
argument_list|)
block|,
name|RADDR
argument_list|(
name|scratcha
argument_list|)
block|,
name|PADDR
argument_list|(
name|startpos
argument_list|)
block|, }
comment|/*-------------------------< PREPARE>----------------------*/
block|,
block|{
comment|/* 	**      The ncr doesn't have an indirect load 	**	or store command. So we have to 	**	copy part of the control block to a 	**	fixed place, where we can access it. 	** 	**	We patch the address part of a 	**	COPY command with the DSA-register. 	*/
name|SCR_COPY
argument_list|(
literal|4
argument_list|)
block|,
name|RADDR
argument_list|(
name|dsa
argument_list|)
block|,
name|PADDR
argument_list|(
name|loadpos
argument_list|)
block|,
comment|/* 	**	then we do the actual copy. 	*/
name|SCR_COPY
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|head
argument_list|)
argument_list|)
block|,
comment|/* 	**	continued after the next label ... 	*/
block|}
comment|/*-------------------------< LOADPOS>---------------------*/
block|,
block|{
literal|0
block|,
name|NADDR
argument_list|(
name|header
argument_list|)
block|,
comment|/* 	**      Mark this ccb as not scheduled. 	*/
name|SCR_COPY
argument_list|(
literal|8
argument_list|)
block|,
name|PADDR
argument_list|(
name|idle
argument_list|)
block|,
name|NADDR
argument_list|(
name|header
operator|.
name|launch
argument_list|)
block|,
comment|/* 	**      Set a time stamp for this selection 	*/
name|SCR_COPY
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|timeval
argument_list|)
argument_list|)
block|,
operator|(
name|ncrcmd
operator|)
operator|&
name|time
block|,
name|NADDR
argument_list|(
name|header
operator|.
name|stamp
operator|.
name|select
argument_list|)
block|,
comment|/* 	**      load the savep (saved pointer) into 	**      the TEMP register (actual pointer) 	*/
name|SCR_COPY
argument_list|(
literal|4
argument_list|)
block|,
name|NADDR
argument_list|(
name|header
operator|.
name|savep
argument_list|)
block|,
name|RADDR
argument_list|(
name|temp
argument_list|)
block|,
comment|/* 	**      Initialize the status registers 	*/
name|SCR_COPY
argument_list|(
literal|4
argument_list|)
block|,
name|NADDR
argument_list|(
name|header
operator|.
name|status
argument_list|)
block|,
name|RADDR
argument_list|(
name|scr0
argument_list|)
block|,  }
comment|/*-------------------------< PREPARE2>---------------------*/
block|,
block|{
comment|/* 	**      Load the synchronous mode register 	*/
name|SCR_COPY
argument_list|(
literal|1
argument_list|)
block|,
name|NADDR
argument_list|(
name|sync_st
argument_list|)
block|,
name|RADDR
argument_list|(
name|sxfer
argument_list|)
block|,
comment|/* 	**      Load the wide mode and timing register 	*/
name|SCR_COPY
argument_list|(
literal|1
argument_list|)
block|,
name|NADDR
argument_list|(
name|wide_st
argument_list|)
block|,
name|RADDR
argument_list|(
name|scntl3
argument_list|)
block|,
comment|/* 	**	Initialize the msgout buffer with a NOOP message. 	*/
name|SCR_LOAD_REG
argument_list|(
name|scratcha
argument_list|,
name|M_NOOP
argument_list|)
block|,
literal|0
block|,
name|SCR_COPY
argument_list|(
literal|1
argument_list|)
block|,
name|RADDR
argument_list|(
name|scratcha
argument_list|)
block|,
name|NADDR
argument_list|(
name|msgout
argument_list|)
block|,
name|SCR_COPY
argument_list|(
literal|1
argument_list|)
block|,
name|RADDR
argument_list|(
name|scratcha
argument_list|)
block|,
name|NADDR
argument_list|(
name|msgin
argument_list|)
block|,
comment|/* 	**	Message in phase ? 	*/
name|SCR_JUMP
operator|^
name|IFFALSE
argument_list|(
name|WHEN
argument_list|(
name|SCR_MSG_IN
argument_list|)
argument_list|)
block|,
name|PADDR
argument_list|(
name|dispatch
argument_list|)
block|,
comment|/* 	**	Extended or reject message ? 	*/
name|SCR_FROM_REG
argument_list|(
name|sbdl
argument_list|)
block|,
literal|0
block|,
name|SCR_JUMP
operator|^
name|IFTRUE
argument_list|(
name|DATA
argument_list|(
name|M_EXTENDED
argument_list|)
argument_list|)
block|,
name|PADDR
argument_list|(
name|msg_in
argument_list|)
block|,
name|SCR_JUMP
operator|^
name|IFTRUE
argument_list|(
name|DATA
argument_list|(
name|M_REJECT
argument_list|)
argument_list|)
block|,
name|PADDR
argument_list|(
name|msg_reject
argument_list|)
block|,
comment|/* 	**	normal processing 	*/
name|SCR_JUMP
block|,
name|PADDR
argument_list|(
name|dispatch
argument_list|)
block|, }
comment|/*-------------------------< SETMSG>----------------------*/
block|,
block|{
name|SCR_COPY
argument_list|(
literal|1
argument_list|)
block|,
name|RADDR
argument_list|(
name|scratcha
argument_list|)
block|,
name|NADDR
argument_list|(
name|msgout
argument_list|)
block|,
name|SCR_SET
argument_list|(
name|SCR_ATN
argument_list|)
block|,
literal|0
block|, }
comment|/*-------------------------< CLRACK>----------------------*/
block|,
block|{
comment|/* 	**	Terminate possible pending message phase. 	*/
name|SCR_CLR
argument_list|(
name|SCR_ACK
argument_list|)
block|,
literal|0
block|,  }
comment|/*-----------------------< DISPATCH>----------------------*/
block|,
block|{
name|SCR_FROM_REG
argument_list|(
name|HS_REG
argument_list|)
block|,
literal|0
block|,
name|SCR_INT
operator|^
name|IFTRUE
argument_list|(
name|DATA
argument_list|(
name|HS_NEGOTIATE
argument_list|)
argument_list|)
block|,
name|SIR_NEGO_FAILED
block|,
comment|/* 	**	remove bogus output signals 	*/
name|SCR_REG_REG
argument_list|(
name|socl
argument_list|,
name|SCR_AND
argument_list|,
name|CACK
operator||
name|CATN
argument_list|)
block|,
literal|0
block|,
name|SCR_RETURN
operator|^
name|IFTRUE
argument_list|(
name|WHEN
argument_list|(
name|SCR_DATA_OUT
argument_list|)
argument_list|)
block|,
literal|0
block|,
name|SCR_RETURN
operator|^
name|IFTRUE
argument_list|(
name|IF
argument_list|(
name|SCR_DATA_IN
argument_list|)
argument_list|)
block|,
literal|0
block|,
name|SCR_JUMP
operator|^
name|IFTRUE
argument_list|(
name|IF
argument_list|(
name|SCR_MSG_OUT
argument_list|)
argument_list|)
block|,
name|PADDR
argument_list|(
name|msg_out
argument_list|)
block|,
name|SCR_JUMP
operator|^
name|IFTRUE
argument_list|(
name|IF
argument_list|(
name|SCR_MSG_IN
argument_list|)
argument_list|)
block|,
name|PADDR
argument_list|(
name|msg_in
argument_list|)
block|,
name|SCR_JUMP
operator|^
name|IFTRUE
argument_list|(
name|IF
argument_list|(
name|SCR_COMMAND
argument_list|)
argument_list|)
block|,
name|PADDR
argument_list|(
name|command
argument_list|)
block|,
name|SCR_JUMP
operator|^
name|IFTRUE
argument_list|(
name|IF
argument_list|(
name|SCR_STATUS
argument_list|)
argument_list|)
block|,
name|PADDR
argument_list|(
name|status
argument_list|)
block|,
comment|/* 	**      Discard one illegal phase byte, if required. 	*/
name|SCR_LOAD_REG
argument_list|(
name|scratcha
argument_list|,
name|XE_BAD_PHASE
argument_list|)
block|,
literal|0
block|,
name|SCR_COPY
argument_list|(
literal|1
argument_list|)
block|,
name|RADDR
argument_list|(
name|scratcha
argument_list|)
block|,
name|NADDR
argument_list|(
name|xerr_st
argument_list|)
block|,
name|SCR_JUMPR
operator|^
name|IFFALSE
argument_list|(
name|IF
argument_list|(
name|SCR_ILG_OUT
argument_list|)
argument_list|)
block|,
literal|8
block|,
name|SCR_MOVE_ABS
argument_list|(
literal|1
argument_list|)
operator|^
name|SCR_ILG_OUT
block|,
name|NADDR
argument_list|(
name|scratch
argument_list|)
block|,
name|SCR_JUMPR
operator|^
name|IFFALSE
argument_list|(
name|IF
argument_list|(
name|SCR_ILG_IN
argument_list|)
argument_list|)
block|,
literal|8
block|,
name|SCR_MOVE_ABS
argument_list|(
literal|1
argument_list|)
operator|^
name|SCR_ILG_IN
block|,
name|NADDR
argument_list|(
name|scratch
argument_list|)
block|,
name|SCR_JUMP
block|,
name|PADDR
argument_list|(
name|dispatch
argument_list|)
block|,  }
comment|/*-------------------------< NO_DATA>--------------------*/
block|,
block|{
comment|/* 	**	The target wants to tranfer too much data 	**	or in the wrong direction. 	**      Remember that in extended error. 	*/
name|SCR_LOAD_REG
argument_list|(
name|scratcha
argument_list|,
name|XE_EXTRA_DATA
argument_list|)
block|,
literal|0
block|,
name|SCR_COPY
argument_list|(
literal|1
argument_list|)
block|,
name|RADDR
argument_list|(
name|scratcha
argument_list|)
block|,
name|NADDR
argument_list|(
name|xerr_st
argument_list|)
block|,
comment|/* 	**      Discard one data byte, if required. 	*/
name|SCR_JUMPR
operator|^
name|IFFALSE
argument_list|(
name|WHEN
argument_list|(
name|SCR_DATA_OUT
argument_list|)
argument_list|)
block|,
literal|8
block|,
name|SCR_MOVE_ABS
argument_list|(
literal|1
argument_list|)
operator|^
name|SCR_DATA_OUT
block|,
name|NADDR
argument_list|(
name|scratch
argument_list|)
block|,
name|SCR_JUMPR
operator|^
name|IFFALSE
argument_list|(
name|IF
argument_list|(
name|SCR_DATA_IN
argument_list|)
argument_list|)
block|,
literal|8
block|,
name|SCR_MOVE_ABS
argument_list|(
literal|1
argument_list|)
operator|^
name|SCR_DATA_IN
block|,
name|NADDR
argument_list|(
name|scratch
argument_list|)
block|,
comment|/* 	**      .. and repeat as required. 	*/
name|SCR_CALL
block|,
name|PADDR
argument_list|(
name|dispatch
argument_list|)
block|,
name|SCR_JUMP
block|,
name|PADDR
argument_list|(
name|no_data
argument_list|)
block|, }
comment|/*-------------------------< CHECKATN>--------------------*/
block|,
block|{
comment|/* 	**	If AAP (bit 1 of scntl0 register) is set 	**	and a parity error is detected, 	**	the script processor asserts ATN. 	** 	**	The target should switch to a MSG_OUT phase 	**	to get the message. 	*/
name|SCR_FROM_REG
argument_list|(
name|socl
argument_list|)
block|,
literal|0
block|,
name|SCR_JUMP
operator|^
name|IFFALSE
argument_list|(
name|MASK
argument_list|(
name|CATN
argument_list|,
name|CATN
argument_list|)
argument_list|)
block|,
name|PADDR
argument_list|(
name|dispatch
argument_list|)
block|,
comment|/* 	**	count it 	*/
name|SCR_REG_REG
argument_list|(
name|PS_REG
argument_list|,
name|SCR_ADD
argument_list|,
literal|1
argument_list|)
block|,
literal|0
block|,
comment|/* 	**	Prepare a M_ID_ERROR message 	**	(initiator detected error). 	**	The target should retry the transfer. 	*/
name|SCR_LOAD_REG
argument_list|(
name|scratcha
argument_list|,
name|M_ID_ERROR
argument_list|)
block|,
literal|0
block|,
name|SCR_JUMP
block|,
name|PADDR
argument_list|(
name|setmsg
argument_list|)
block|,  }
comment|/*-------------------------< COMMAND>--------------------*/
block|,
block|{
comment|/* 	**	If this is not a GETCC transfer ... 	*/
name|SCR_FROM_REG
argument_list|(
name|SS_REG
argument_list|)
block|,
literal|0
block|,
comment|/*<<<*/
name|SCR_JUMPR
operator|^
name|IFTRUE
argument_list|(
name|DATA
argument_list|(
name|S_CHECK_COND
argument_list|)
argument_list|)
block|,
literal|28
block|,
comment|/* 	**	... set a timestamp ... 	*/
name|SCR_COPY
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|timeval
argument_list|)
argument_list|)
block|,
operator|(
name|ncrcmd
operator|)
operator|&
name|time
block|,
name|NADDR
argument_list|(
name|header
operator|.
name|stamp
operator|.
name|command
argument_list|)
block|,
comment|/* 	**	... and send the command 	*/
name|SCR_MOVE_TBL
operator|^
name|SCR_COMMAND
block|,
name|offsetof
argument_list|(
expr|struct
name|dsb
argument_list|,
name|cmd
argument_list|)
block|,
name|SCR_JUMP
block|,
name|PADDR
argument_list|(
name|dispatch
argument_list|)
block|,
comment|/* 	**	Send the GETCC command 	*/
comment|/*>>>*/
name|SCR_MOVE_TBL
operator|^
name|SCR_COMMAND
block|,
name|offsetof
argument_list|(
expr|struct
name|dsb
argument_list|,
name|scmd
argument_list|)
block|,
name|SCR_JUMP
block|,
name|PADDR
argument_list|(
name|dispatch
argument_list|)
block|,  }
comment|/*-------------------------< STATUS>--------------------*/
block|,
block|{
comment|/* 	**	set the timestamp. 	*/
name|SCR_COPY
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|timeval
argument_list|)
argument_list|)
block|,
operator|(
name|ncrcmd
operator|)
operator|&
name|time
block|,
name|NADDR
argument_list|(
name|header
operator|.
name|stamp
operator|.
name|status
argument_list|)
block|,
comment|/* 	**	If this is a GETCC transfer, 	*/
name|SCR_FROM_REG
argument_list|(
name|SS_REG
argument_list|)
block|,
literal|0
block|,
comment|/*<<<*/
name|SCR_JUMPR
operator|^
name|IFFALSE
argument_list|(
name|DATA
argument_list|(
name|S_CHECK_COND
argument_list|)
argument_list|)
block|,
literal|40
block|,
comment|/* 	**	get the status 	*/
name|SCR_MOVE_ABS
argument_list|(
literal|1
argument_list|)
operator|^
name|SCR_STATUS
block|,
name|NADDR
argument_list|(
name|scratch
argument_list|)
block|,
comment|/* 	**	Save status to scsi_status. 	**	Mark as complete. 	**	And wait for disconnect. 	*/
name|SCR_TO_REG
argument_list|(
name|SS_REG
argument_list|)
block|,
literal|0
block|,
name|SCR_REG_REG
argument_list|(
name|SS_REG
argument_list|,
name|SCR_OR
argument_list|,
name|S_SENSE
argument_list|)
block|,
literal|0
block|,
name|SCR_LOAD_REG
argument_list|(
name|HS_REG
argument_list|,
name|HS_COMPLETE
argument_list|)
block|,
literal|0
block|,
name|SCR_JUMP
block|,
name|PADDR
argument_list|(
name|checkatn
argument_list|)
block|,
comment|/* 	**	If it was no GETCC transfer, 	**	save the status to scsi_status. 	*/
comment|/*>>>*/
name|SCR_MOVE_ABS
argument_list|(
literal|1
argument_list|)
operator|^
name|SCR_STATUS
block|,
name|NADDR
argument_list|(
name|scratch
argument_list|)
block|,
name|SCR_TO_REG
argument_list|(
name|SS_REG
argument_list|)
block|,
literal|0
block|,
comment|/* 	**	if it was no check condition ... 	*/
name|SCR_JUMP
operator|^
name|IFTRUE
argument_list|(
name|DATA
argument_list|(
name|S_CHECK_COND
argument_list|)
argument_list|)
block|,
name|PADDR
argument_list|(
name|checkatn
argument_list|)
block|,
comment|/* 	**	... mark as complete. 	*/
name|SCR_LOAD_REG
argument_list|(
name|HS_REG
argument_list|,
name|HS_COMPLETE
argument_list|)
block|,
literal|0
block|,
name|SCR_JUMP
block|,
name|PADDR
argument_list|(
name|checkatn
argument_list|)
block|,  }
comment|/*-------------------------< MSG_IN>--------------------*/
block|,
block|{
comment|/* 	**	Get the first byte of the message 	**	and save it to SCRATCHA. 	** 	**	The script processor doesn't negate the 	**	ACK signal after this transfer. 	*/
name|SCR_MOVE_ABS
argument_list|(
literal|1
argument_list|)
operator|^
name|SCR_MSG_IN
block|,
name|NADDR
argument_list|(
name|msgin
index|[
literal|0
index|]
argument_list|)
block|,
comment|/* 	**	Check for message parity error. 	*/
name|SCR_TO_REG
argument_list|(
name|scratcha
argument_list|)
block|,
literal|0
block|,
name|SCR_FROM_REG
argument_list|(
name|socl
argument_list|)
block|,
literal|0
block|,
name|SCR_JUMP
operator|^
name|IFTRUE
argument_list|(
name|MASK
argument_list|(
name|CATN
argument_list|,
name|CATN
argument_list|)
argument_list|)
block|,
name|PADDR
argument_list|(
name|msg_parity
argument_list|)
block|,
name|SCR_FROM_REG
argument_list|(
name|scratcha
argument_list|)
block|,
literal|0
block|,
comment|/* 	**	Parity was ok, handle this message. 	*/
name|SCR_JUMP
operator|^
name|IFTRUE
argument_list|(
name|DATA
argument_list|(
name|M_COMPLETE
argument_list|)
argument_list|)
block|,
name|PADDR
argument_list|(
name|complete
argument_list|)
block|,
name|SCR_JUMP
operator|^
name|IFTRUE
argument_list|(
name|DATA
argument_list|(
name|M_SAVE_DP
argument_list|)
argument_list|)
block|,
name|PADDR
argument_list|(
name|save_dp
argument_list|)
block|,
name|SCR_JUMP
operator|^
name|IFTRUE
argument_list|(
name|DATA
argument_list|(
name|M_RESTORE_DP
argument_list|)
argument_list|)
block|,
name|PADDR
argument_list|(
name|restore_dp
argument_list|)
block|,
name|SCR_JUMP
operator|^
name|IFTRUE
argument_list|(
name|DATA
argument_list|(
name|M_DISCONNECT
argument_list|)
argument_list|)
block|,
name|PADDR
argument_list|(
name|disconnect
argument_list|)
block|,
name|SCR_JUMP
operator|^
name|IFTRUE
argument_list|(
name|DATA
argument_list|(
name|M_EXTENDED
argument_list|)
argument_list|)
block|,
name|PADDR
argument_list|(
name|msg_extended
argument_list|)
block|,
name|SCR_JUMP
operator|^
name|IFTRUE
argument_list|(
name|DATA
argument_list|(
name|M_NOOP
argument_list|)
argument_list|)
block|,
name|PADDR
argument_list|(
name|clrack
argument_list|)
block|,
name|SCR_JUMP
operator|^
name|IFTRUE
argument_list|(
name|DATA
argument_list|(
name|M_REJECT
argument_list|)
argument_list|)
block|,
name|PADDR
argument_list|(
name|msg_reject
argument_list|)
block|,
name|SCR_JUMP
operator|^
name|IFTRUE
argument_list|(
name|DATA
argument_list|(
name|M_IGN_RESIDUE
argument_list|)
argument_list|)
block|,
name|PADDR
argument_list|(
name|msg_ign_residue
argument_list|)
block|,
comment|/* 	**	Rest of the messages left as 	**	an exercise ... 	** 	**	Unimplemented messages: 	**	fall through to MSG_BAD. 	*/
block|}
comment|/*-------------------------< MSG_BAD>------------------*/
block|,
block|{
comment|/* 	**	unimplemented message - reject it. 	*/
name|SCR_INT
block|,
name|SIR_REJECT_SENT
block|,
name|SCR_LOAD_REG
argument_list|(
name|scratcha
argument_list|,
name|M_REJECT
argument_list|)
block|,
literal|0
block|,
name|SCR_JUMP
block|,
name|PADDR
argument_list|(
name|setmsg
argument_list|)
block|,  }
comment|/*-------------------------< MSG_PARITY>---------------*/
block|,
block|{
comment|/* 	**	count it 	*/
name|SCR_REG_REG
argument_list|(
name|PS_REG
argument_list|,
name|SCR_ADD
argument_list|,
literal|0x01
argument_list|)
block|,
literal|0
block|,
comment|/* 	**	send a "message parity error" message. 	*/
name|SCR_LOAD_REG
argument_list|(
name|scratcha
argument_list|,
name|M_PARITY
argument_list|)
block|,
literal|0
block|,
name|SCR_JUMP
block|,
name|PADDR
argument_list|(
name|setmsg
argument_list|)
block|, }
comment|/*-------------------------< MSG_REJECT>---------------*/
block|,
block|{
comment|/* 	**	If a negotiation was in progress, 	**	negotiation failed. 	*/
name|SCR_FROM_REG
argument_list|(
name|HS_REG
argument_list|)
block|,
literal|0
block|,
name|SCR_INT
operator|^
name|IFTRUE
argument_list|(
name|DATA
argument_list|(
name|HS_NEGOTIATE
argument_list|)
argument_list|)
block|,
name|SIR_NEGO_FAILED
block|,
comment|/* 	**	else make host log this message 	*/
name|SCR_INT
operator|^
name|IFFALSE
argument_list|(
name|DATA
argument_list|(
name|HS_NEGOTIATE
argument_list|)
argument_list|)
block|,
name|SIR_REJECT_RECEIVED
block|,
name|SCR_JUMP
block|,
name|PADDR
argument_list|(
name|clrack
argument_list|)
block|,  }
comment|/*-------------------------< MSG_IGN_RESIDUE>----------*/
block|,
block|{
comment|/* 	**	Terminate cycle 	*/
name|SCR_CLR
argument_list|(
name|SCR_ACK
argument_list|)
block|,
literal|0
block|,
name|SCR_JUMP
operator|^
name|IFFALSE
argument_list|(
name|WHEN
argument_list|(
name|SCR_MSG_IN
argument_list|)
argument_list|)
block|,
name|PADDR
argument_list|(
name|dispatch
argument_list|)
block|,
comment|/* 	**	get residue size. 	*/
name|SCR_MOVE_ABS
argument_list|(
literal|1
argument_list|)
operator|^
name|SCR_MSG_IN
block|,
name|NADDR
argument_list|(
name|msgin
index|[
literal|1
index|]
argument_list|)
block|,
comment|/* 	**	Check for message parity error. 	*/
name|SCR_TO_REG
argument_list|(
name|scratcha
argument_list|)
block|,
literal|0
block|,
name|SCR_FROM_REG
argument_list|(
name|socl
argument_list|)
block|,
literal|0
block|,
name|SCR_JUMP
operator|^
name|IFTRUE
argument_list|(
name|MASK
argument_list|(
name|CATN
argument_list|,
name|CATN
argument_list|)
argument_list|)
block|,
name|PADDR
argument_list|(
name|msg_parity
argument_list|)
block|,
name|SCR_FROM_REG
argument_list|(
name|scratcha
argument_list|)
block|,
literal|0
block|,
comment|/* 	**	Size is 0 .. ignore message. 	*/
name|SCR_JUMP
operator|^
name|IFTRUE
argument_list|(
name|DATA
argument_list|(
literal|0
argument_list|)
argument_list|)
block|,
name|PADDR
argument_list|(
name|clrack
argument_list|)
block|,
comment|/* 	**	Size is not 1 .. have to interrupt. 	*/
comment|/*<<<*/
name|SCR_JUMPR
operator|^
name|IFFALSE
argument_list|(
name|DATA
argument_list|(
literal|1
argument_list|)
argument_list|)
block|,
literal|40
block|,
comment|/* 	**	Check for residue byte in swide register 	*/
name|SCR_FROM_REG
argument_list|(
name|scntl2
argument_list|)
block|,
literal|0
block|,
comment|/*<<<*/
name|SCR_JUMPR
operator|^
name|IFFALSE
argument_list|(
name|MASK
argument_list|(
name|WSR
argument_list|,
name|WSR
argument_list|)
argument_list|)
block|,
literal|16
block|,
comment|/* 	**	There IS data in the swide register. 	**	Discard it. 	*/
name|SCR_REG_REG
argument_list|(
name|scntl2
argument_list|,
name|SCR_OR
argument_list|,
name|WSR
argument_list|)
block|,
literal|0
block|,
name|SCR_JUMP
block|,
name|PADDR
argument_list|(
name|clrack
argument_list|)
block|,
comment|/* 	**	Load again the size to the sfbr register. 	*/
comment|/*>>>*/
name|SCR_FROM_REG
argument_list|(
name|scratcha
argument_list|)
block|,
literal|0
block|,
comment|/*>>>*/
name|SCR_INT
block|,
name|SIR_IGN_RESIDUE
block|,
name|SCR_JUMP
block|,
name|PADDR
argument_list|(
name|clrack
argument_list|)
block|,  }
comment|/*-------------------------< MSG_EXTENDED>-------------*/
block|,
block|{
comment|/* 	**	Terminate cycle 	*/
name|SCR_CLR
argument_list|(
name|SCR_ACK
argument_list|)
block|,
literal|0
block|,
name|SCR_JUMP
operator|^
name|IFFALSE
argument_list|(
name|WHEN
argument_list|(
name|SCR_MSG_IN
argument_list|)
argument_list|)
block|,
name|PADDR
argument_list|(
name|dispatch
argument_list|)
block|,
comment|/* 	**	get length. 	*/
name|SCR_MOVE_ABS
argument_list|(
literal|1
argument_list|)
operator|^
name|SCR_MSG_IN
block|,
name|NADDR
argument_list|(
name|msgin
index|[
literal|1
index|]
argument_list|)
block|,
comment|/* 	**	Check for message parity error. 	*/
name|SCR_TO_REG
argument_list|(
name|scratcha
argument_list|)
block|,
literal|0
block|,
name|SCR_FROM_REG
argument_list|(
name|socl
argument_list|)
block|,
literal|0
block|,
name|SCR_JUMP
operator|^
name|IFTRUE
argument_list|(
name|MASK
argument_list|(
name|CATN
argument_list|,
name|CATN
argument_list|)
argument_list|)
block|,
name|PADDR
argument_list|(
name|msg_parity
argument_list|)
block|,
name|SCR_FROM_REG
argument_list|(
name|scratcha
argument_list|)
block|,
literal|0
block|,
comment|/* 	*/
name|SCR_JUMP
operator|^
name|IFTRUE
argument_list|(
name|DATA
argument_list|(
literal|3
argument_list|)
argument_list|)
block|,
name|PADDR
argument_list|(
name|msg_ext_3
argument_list|)
block|,
name|SCR_JUMP
operator|^
name|IFFALSE
argument_list|(
name|DATA
argument_list|(
literal|2
argument_list|)
argument_list|)
block|,
name|PADDR
argument_list|(
name|msg_bad
argument_list|)
block|, }
comment|/*-------------------------< MSG_EXT_2>----------------*/
block|,
block|{
name|SCR_CLR
argument_list|(
name|SCR_ACK
argument_list|)
block|,
literal|0
block|,
name|SCR_JUMP
operator|^
name|IFFALSE
argument_list|(
name|WHEN
argument_list|(
name|SCR_MSG_IN
argument_list|)
argument_list|)
block|,
name|PADDR
argument_list|(
name|dispatch
argument_list|)
block|,
comment|/* 	**	get extended message code. 	*/
name|SCR_MOVE_ABS
argument_list|(
literal|1
argument_list|)
operator|^
name|SCR_MSG_IN
block|,
name|NADDR
argument_list|(
name|msgin
index|[
literal|2
index|]
argument_list|)
block|,
comment|/* 	**	Check for message parity error. 	*/
name|SCR_TO_REG
argument_list|(
name|scratcha
argument_list|)
block|,
literal|0
block|,
name|SCR_FROM_REG
argument_list|(
name|socl
argument_list|)
block|,
literal|0
block|,
name|SCR_JUMP
operator|^
name|IFTRUE
argument_list|(
name|MASK
argument_list|(
name|CATN
argument_list|,
name|CATN
argument_list|)
argument_list|)
block|,
name|PADDR
argument_list|(
name|msg_parity
argument_list|)
block|,
name|SCR_FROM_REG
argument_list|(
name|scratcha
argument_list|)
block|,
literal|0
block|,
name|SCR_JUMP
operator|^
name|IFTRUE
argument_list|(
name|DATA
argument_list|(
name|M_X_WIDE_REQ
argument_list|)
argument_list|)
block|,
name|PADDR
argument_list|(
name|msg_wdtr
argument_list|)
block|,
comment|/* 	**	unknown extended message 	*/
name|SCR_JUMP
block|,
name|PADDR
argument_list|(
argument|msg_bad
argument_list|)
block|}
comment|/*-------------------------< MSG_WDTR>-----------------*/
block|,
block|{
name|SCR_CLR
argument_list|(
name|SCR_ACK
argument_list|)
block|,
literal|0
block|,
name|SCR_JUMP
operator|^
name|IFFALSE
argument_list|(
name|WHEN
argument_list|(
name|SCR_MSG_IN
argument_list|)
argument_list|)
block|,
name|PADDR
argument_list|(
name|dispatch
argument_list|)
block|,
comment|/* 	**	get data bus width 	*/
name|SCR_MOVE_ABS
argument_list|(
literal|1
argument_list|)
operator|^
name|SCR_MSG_IN
block|,
name|NADDR
argument_list|(
name|msgin
index|[
literal|3
index|]
argument_list|)
block|,
name|SCR_FROM_REG
argument_list|(
name|socl
argument_list|)
block|,
literal|0
block|,
name|SCR_JUMP
operator|^
name|IFTRUE
argument_list|(
name|MASK
argument_list|(
name|CATN
argument_list|,
name|CATN
argument_list|)
argument_list|)
block|,
name|PADDR
argument_list|(
name|msg_parity
argument_list|)
block|,
comment|/* 	**	let the host do the real work. 	*/
name|SCR_INT
block|,
name|SIR_NEGO_WIDE
block|,
comment|/* 	**	let the target fetch our answer. 	*/
name|SCR_SET
argument_list|(
name|SCR_ATN
argument_list|)
block|,
literal|0
block|,
name|SCR_CLR
argument_list|(
name|SCR_ACK
argument_list|)
block|,
literal|0
block|,
name|SCR_INT
operator|^
name|IFFALSE
argument_list|(
name|WHEN
argument_list|(
name|SCR_MSG_OUT
argument_list|)
argument_list|)
block|,
name|SIR_NEGO_PROTO
block|,
comment|/* 	**	Send the M_X_WIDE_REQ 	*/
name|SCR_MOVE_ABS
argument_list|(
literal|4
argument_list|)
operator|^
name|SCR_MSG_OUT
block|,
name|NADDR
argument_list|(
name|msgout
argument_list|)
block|,
name|SCR_CLR
argument_list|(
name|SCR_ATN
argument_list|)
block|,
literal|0
block|,
name|SCR_COPY
argument_list|(
literal|1
argument_list|)
block|,
name|RADDR
argument_list|(
name|sfbr
argument_list|)
block|,
name|NADDR
argument_list|(
name|lastmsg
argument_list|)
block|,
name|SCR_JUMP
block|,
name|PADDR
argument_list|(
name|msg_out_done
argument_list|)
block|,  }
comment|/*-------------------------< MSG_EXT_3>----------------*/
block|,
block|{
name|SCR_CLR
argument_list|(
name|SCR_ACK
argument_list|)
block|,
literal|0
block|,
name|SCR_JUMP
operator|^
name|IFFALSE
argument_list|(
name|WHEN
argument_list|(
name|SCR_MSG_IN
argument_list|)
argument_list|)
block|,
name|PADDR
argument_list|(
name|dispatch
argument_list|)
block|,
comment|/* 	**	get extended message code. 	*/
name|SCR_MOVE_ABS
argument_list|(
literal|1
argument_list|)
operator|^
name|SCR_MSG_IN
block|,
name|NADDR
argument_list|(
name|msgin
index|[
literal|2
index|]
argument_list|)
block|,
comment|/* 	**	Check for message parity error. 	*/
name|SCR_TO_REG
argument_list|(
name|scratcha
argument_list|)
block|,
literal|0
block|,
name|SCR_FROM_REG
argument_list|(
name|socl
argument_list|)
block|,
literal|0
block|,
name|SCR_JUMP
operator|^
name|IFTRUE
argument_list|(
name|MASK
argument_list|(
name|CATN
argument_list|,
name|CATN
argument_list|)
argument_list|)
block|,
name|PADDR
argument_list|(
name|msg_parity
argument_list|)
block|,
name|SCR_FROM_REG
argument_list|(
name|scratcha
argument_list|)
block|,
literal|0
block|,
name|SCR_JUMP
operator|^
name|IFTRUE
argument_list|(
name|DATA
argument_list|(
name|M_X_SYNC_REQ
argument_list|)
argument_list|)
block|,
name|PADDR
argument_list|(
name|msg_sdtr
argument_list|)
block|,
comment|/* 	**	unknown extended message 	*/
name|SCR_JUMP
block|,
name|PADDR
argument_list|(
argument|msg_bad
argument_list|)
block|}
comment|/*-------------------------< MSG_SDTR>-----------------*/
block|,
block|{
name|SCR_CLR
argument_list|(
name|SCR_ACK
argument_list|)
block|,
literal|0
block|,
name|SCR_JUMP
operator|^
name|IFFALSE
argument_list|(
name|WHEN
argument_list|(
name|SCR_MSG_IN
argument_list|)
argument_list|)
block|,
name|PADDR
argument_list|(
name|dispatch
argument_list|)
block|,
comment|/* 	**	get period and offset 	*/
name|SCR_MOVE_ABS
argument_list|(
literal|2
argument_list|)
operator|^
name|SCR_MSG_IN
block|,
name|NADDR
argument_list|(
name|msgin
index|[
literal|3
index|]
argument_list|)
block|,
name|SCR_FROM_REG
argument_list|(
name|socl
argument_list|)
block|,
literal|0
block|,
name|SCR_JUMP
operator|^
name|IFTRUE
argument_list|(
name|MASK
argument_list|(
name|CATN
argument_list|,
name|CATN
argument_list|)
argument_list|)
block|,
name|PADDR
argument_list|(
name|msg_parity
argument_list|)
block|,
comment|/* 	**	let the host do the real work. 	*/
name|SCR_INT
block|,
name|SIR_NEGO_SYNC
block|,
comment|/* 	**	let the target fetch our answer. 	*/
name|SCR_SET
argument_list|(
name|SCR_ATN
argument_list|)
block|,
literal|0
block|,
name|SCR_CLR
argument_list|(
name|SCR_ACK
argument_list|)
block|,
literal|0
block|,
name|SCR_INT
operator|^
name|IFFALSE
argument_list|(
name|WHEN
argument_list|(
name|SCR_MSG_OUT
argument_list|)
argument_list|)
block|,
name|SIR_NEGO_PROTO
block|,
comment|/* 	**	Send the M_X_SYNC_REQ 	*/
name|SCR_MOVE_ABS
argument_list|(
literal|5
argument_list|)
operator|^
name|SCR_MSG_OUT
block|,
name|NADDR
argument_list|(
name|msgout
argument_list|)
block|,
name|SCR_CLR
argument_list|(
name|SCR_ATN
argument_list|)
block|,
literal|0
block|,
name|SCR_COPY
argument_list|(
literal|1
argument_list|)
block|,
name|RADDR
argument_list|(
name|sfbr
argument_list|)
block|,
name|NADDR
argument_list|(
name|lastmsg
argument_list|)
block|,
name|SCR_JUMP
block|,
name|PADDR
argument_list|(
name|msg_out_done
argument_list|)
block|,  }
comment|/*-------------------------< COMPLETE>-----------------*/
block|,
block|{
comment|/* 	**	Complete message. 	** 	**	If it's not the get condition code, 	**	copy TEMP register to LASTP in header. 	*/
name|SCR_FROM_REG
argument_list|(
name|SS_REG
argument_list|)
block|,
literal|0
block|,
comment|/*<<<*/
name|SCR_JUMPR
operator|^
name|IFTRUE
argument_list|(
name|MASK
argument_list|(
name|S_SENSE
argument_list|,
name|S_SENSE
argument_list|)
argument_list|)
block|,
literal|12
block|,
name|SCR_COPY
argument_list|(
literal|4
argument_list|)
block|,
name|RADDR
argument_list|(
name|temp
argument_list|)
block|,
name|NADDR
argument_list|(
name|header
operator|.
name|lastp
argument_list|)
block|,
comment|/*>>>*/
comment|/* 	**	When we terminate the cycle by clearing ACK, 	**	the target may disconnect immediately. 	** 	**	We don't want to be told of an 	**	"unexpected disconnect", 	**	so we disable this feature. 	*/
name|SCR_REG_REG
argument_list|(
name|scntl2
argument_list|,
name|SCR_AND
argument_list|,
literal|0x7f
argument_list|)
block|,
literal|0
block|,
comment|/* 	**	Terminate cycle ... 	*/
name|SCR_CLR
argument_list|(
name|SCR_ACK
operator||
name|SCR_ATN
argument_list|)
block|,
literal|0
block|,
comment|/* 	**	... and wait for the disconnect. 	*/
name|SCR_WAIT_DISC
block|,
literal|0
block|, }
comment|/*-------------------------< CLEANUP>-------------------*/
block|,
block|{
comment|/* 	**      dsa:    Pointer to ccb 	**	      or xxxxxxFF (no ccb) 	** 	**      HS_REG:   Host-Status (<>0!) 	*/
name|SCR_FROM_REG
argument_list|(
name|dsa
argument_list|)
block|,
literal|0
block|,
name|SCR_JUMP
operator|^
name|IFTRUE
argument_list|(
name|DATA
argument_list|(
literal|0xff
argument_list|)
argument_list|)
block|,
name|PADDR
argument_list|(
name|signal
argument_list|)
block|,
comment|/* 	**      dsa is valid. 	**	save the status registers 	*/
name|SCR_COPY
argument_list|(
literal|4
argument_list|)
block|,
name|RADDR
argument_list|(
name|scr0
argument_list|)
block|,
name|NADDR
argument_list|(
name|header
operator|.
name|status
argument_list|)
block|,
comment|/* 	**	and copy back the header to the ccb. 	*/
name|SCR_COPY
argument_list|(
literal|4
argument_list|)
block|,
name|RADDR
argument_list|(
name|dsa
argument_list|)
block|,
name|PADDR
argument_list|(
name|cleanup0
argument_list|)
block|,
name|SCR_COPY
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|head
argument_list|)
argument_list|)
block|,
name|NADDR
argument_list|(
name|header
argument_list|)
block|, }
comment|/*-------------------------< CLEANUP0>--------------------*/
block|,
block|{
literal|0
block|,
comment|/* 	**	If command resulted in "check condition" 	**	status and is not yet completed, 	**	try to get the condition code. 	*/
name|SCR_FROM_REG
argument_list|(
name|HS_REG
argument_list|)
block|,
literal|0
block|,
comment|/*<<<*/
name|SCR_JUMPR
operator|^
name|IFFALSE
argument_list|(
name|MASK
argument_list|(
literal|0
argument_list|,
name|HS_DONEMASK
argument_list|)
argument_list|)
block|,
literal|16
block|,
name|SCR_FROM_REG
argument_list|(
name|SS_REG
argument_list|)
block|,
literal|0
block|,
name|SCR_JUMP
operator|^
name|IFTRUE
argument_list|(
name|DATA
argument_list|(
name|S_CHECK_COND
argument_list|)
argument_list|)
block|,
name|PADDR
argument_list|(
name|getcc2
argument_list|)
block|,
comment|/* 	**	And make the DSA register invalid. 	*/
comment|/*>>>*/
name|SCR_LOAD_REG
argument_list|(
name|dsa
argument_list|,
literal|0xff
argument_list|)
block|,
comment|/* invalid */
literal|0
block|, }
comment|/*-------------------------< SIGNAL>----------------------*/
block|,
block|{
comment|/* 	**	if status = queue full, 	**	reinsert in startqueue and stall queue. 	*/
name|SCR_FROM_REG
argument_list|(
name|SS_REG
argument_list|)
block|,
literal|0
block|,
name|SCR_INT
operator|^
name|IFTRUE
argument_list|(
name|DATA
argument_list|(
name|S_QUEUE_FULL
argument_list|)
argument_list|)
block|,
name|SIR_STALL_QUEUE
block|,
comment|/* 	**	if job completed ... 	*/
name|SCR_FROM_REG
argument_list|(
name|HS_REG
argument_list|)
block|,
literal|0
block|,
comment|/* 	**	... signal completion to the host 	*/
name|SCR_INT_FLY
operator|^
name|IFFALSE
argument_list|(
name|MASK
argument_list|(
literal|0
argument_list|,
name|HS_DONEMASK
argument_list|)
argument_list|)
block|,
literal|0
block|,
comment|/* 	**	Auf zu neuen Schandtaten! 	*/
name|SCR_JUMP
block|,
name|PADDR
argument_list|(
name|start
argument_list|)
block|,  }
comment|/*-------------------------< SAVE_DP>------------------*/
block|,
block|{
comment|/* 	**	SAVE_DP message: 	**	Copy TEMP register to SAVEP in header. 	*/
name|SCR_COPY
argument_list|(
literal|4
argument_list|)
block|,
name|RADDR
argument_list|(
name|temp
argument_list|)
block|,
name|NADDR
argument_list|(
name|header
operator|.
name|savep
argument_list|)
block|,
name|SCR_JUMP
block|,
name|PADDR
argument_list|(
name|clrack
argument_list|)
block|, }
comment|/*-------------------------< RESTORE_DP>---------------*/
block|,
block|{
comment|/* 	**	RESTORE_DP message: 	**	Copy SAVEP in header to TEMP register. 	*/
name|SCR_COPY
argument_list|(
literal|4
argument_list|)
block|,
name|NADDR
argument_list|(
name|header
operator|.
name|savep
argument_list|)
block|,
name|RADDR
argument_list|(
name|temp
argument_list|)
block|,
name|SCR_JUMP
block|,
name|PADDR
argument_list|(
name|clrack
argument_list|)
block|,  }
comment|/*-------------------------< DISCONNECT>---------------*/
block|,
block|{
comment|/* 	**	If QUIRK_AUTOSAVE is set, 	**	do an "save pointer" operation. 	*/
name|SCR_FROM_REG
argument_list|(
name|QU_REG
argument_list|)
block|,
literal|0
block|,
comment|/*<<<*/
name|SCR_JUMPR
operator|^
name|IFFALSE
argument_list|(
name|MASK
argument_list|(
name|QUIRK_AUTOSAVE
argument_list|,
name|QUIRK_AUTOSAVE
argument_list|)
argument_list|)
block|,
literal|12
block|,
comment|/* 	**	like SAVE_DP message: 	**	Copy TEMP register to SAVEP in header. 	*/
name|SCR_COPY
argument_list|(
literal|4
argument_list|)
block|,
name|RADDR
argument_list|(
name|temp
argument_list|)
block|,
name|NADDR
argument_list|(
name|header
operator|.
name|savep
argument_list|)
block|,
comment|/*>>>*/
comment|/* 	**	Check if temp==savep or temp==goalp: 	**	if not, log a missing save pointer message. 	**	In fact, it's a comparison mod 256. 	** 	**	Hmmm, I hadn't thought that I would be urged to 	**	write this kind of ugly self modifying code. 	** 	**	It's unbelievable, but the ncr53c8xx isn't able 	**	to subtract one register from another. 	*/
name|SCR_FROM_REG
argument_list|(
name|temp
argument_list|)
block|,
literal|0
block|,
comment|/* 	**	You are not expected to understand this .. 	** 	**	CAUTION: only little endian architectures supported! XXX 	*/
name|SCR_COPY
argument_list|(
literal|1
argument_list|)
block|,
name|NADDR
argument_list|(
name|header
operator|.
name|savep
argument_list|)
block|,
name|PADDR
argument_list|(
name|disconnect0
argument_list|)
block|, }
comment|/*-------------------------< DISCONNECT0>--------------*/
block|,
block|{
comment|/*<<<*/
name|SCR_JUMPR
operator|^
name|IFTRUE
argument_list|(
name|DATA
argument_list|(
literal|1
argument_list|)
argument_list|)
block|,
literal|20
block|,
comment|/* 	**	neither this 	*/
name|SCR_COPY
argument_list|(
literal|1
argument_list|)
block|,
name|NADDR
argument_list|(
name|header
operator|.
name|goalp
argument_list|)
block|,
name|PADDR
argument_list|(
name|disconnect1
argument_list|)
block|, }
comment|/*-------------------------< DISCONNECT1>--------------*/
block|,
block|{
name|SCR_INT
operator|^
name|IFFALSE
argument_list|(
name|DATA
argument_list|(
literal|1
argument_list|)
argument_list|)
block|,
name|SIR_MISSING_SAVE
block|,
comment|/*>>>*/
comment|/* 	**	DISCONNECTing  ... 	** 	**	disable the "unexpected disconnect" feature, 	**	and remove the ACK signal. 	*/
name|SCR_REG_REG
argument_list|(
name|scntl2
argument_list|,
name|SCR_AND
argument_list|,
literal|0x7f
argument_list|)
block|,
literal|0
block|,
name|SCR_CLR
argument_list|(
name|SCR_ACK
operator||
name|SCR_ATN
argument_list|)
block|,
literal|0
block|,
comment|/* 	**	Wait for the disconnect. 	*/
name|SCR_WAIT_DISC
block|,
literal|0
block|,
comment|/* 	**	Profiling: 	**	Set a time stamp, 	**	and count the disconnects. 	*/
name|SCR_COPY
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|timeval
argument_list|)
argument_list|)
block|,
operator|(
name|ncrcmd
operator|)
operator|&
name|time
block|,
name|NADDR
argument_list|(
name|header
operator|.
name|stamp
operator|.
name|disconnect
argument_list|)
block|,
name|SCR_COPY
argument_list|(
literal|4
argument_list|)
block|,
name|NADDR
argument_list|(
name|disc_phys
argument_list|)
block|,
name|RADDR
argument_list|(
name|temp
argument_list|)
block|,
name|SCR_REG_REG
argument_list|(
name|temp
argument_list|,
name|SCR_ADD
argument_list|,
literal|0x01
argument_list|)
block|,
literal|0
block|,
name|SCR_COPY
argument_list|(
literal|4
argument_list|)
block|,
name|RADDR
argument_list|(
name|temp
argument_list|)
block|,
name|NADDR
argument_list|(
name|disc_phys
argument_list|)
block|,
comment|/* 	**	Status is: DISCONNECTED. 	*/
name|SCR_LOAD_REG
argument_list|(
name|HS_REG
argument_list|,
name|HS_DISCONNECT
argument_list|)
block|,
literal|0
block|,
name|SCR_JUMP
block|,
name|PADDR
argument_list|(
name|cleanup
argument_list|)
block|,  }
comment|/*-------------------------< MSG_OUT>-------------------*/
block|,
block|{
comment|/* 	**	The target requests a message. 	*/
name|SCR_MOVE_ABS
argument_list|(
literal|1
argument_list|)
operator|^
name|SCR_MSG_OUT
block|,
name|NADDR
argument_list|(
name|msgout
argument_list|)
block|,
name|SCR_COPY
argument_list|(
literal|1
argument_list|)
block|,
name|RADDR
argument_list|(
name|sfbr
argument_list|)
block|,
name|NADDR
argument_list|(
name|lastmsg
argument_list|)
block|,
comment|/* 	**	If it was no ABORT message ... 	*/
name|SCR_JUMP
operator|^
name|IFTRUE
argument_list|(
name|DATA
argument_list|(
name|M_ABORT
argument_list|)
argument_list|)
block|,
name|PADDR
argument_list|(
name|msg_out_abort
argument_list|)
block|,
comment|/* 	**	... wait for the next phase 	**	if it's a message out, send it again, ... 	*/
name|SCR_JUMP
operator|^
name|IFTRUE
argument_list|(
name|WHEN
argument_list|(
name|SCR_MSG_OUT
argument_list|)
argument_list|)
block|,
name|PADDR
argument_list|(
name|msg_out
argument_list|)
block|, }
comment|/*-------------------------< MSG_OUT_DONE>--------------*/
block|,
block|{
comment|/* 	**	... else clear the message ... 	*/
name|SCR_LOAD_REG
argument_list|(
name|scratcha
argument_list|,
name|M_NOOP
argument_list|)
block|,
literal|0
block|,
name|SCR_COPY
argument_list|(
literal|4
argument_list|)
block|,
name|RADDR
argument_list|(
name|scratcha
argument_list|)
block|,
name|NADDR
argument_list|(
name|msgout
argument_list|)
block|,
comment|/* 	**	... and process the next phase 	*/
name|SCR_JUMP
block|,
name|PADDR
argument_list|(
name|dispatch
argument_list|)
block|, }
comment|/*-------------------------< MSG_OUT_ABORT>-------------*/
block|,
block|{
comment|/* 	**	After ABORT message, 	** 	**	expect an immediate disconnect, ... 	*/
name|SCR_REG_REG
argument_list|(
name|scntl2
argument_list|,
name|SCR_AND
argument_list|,
literal|0x7f
argument_list|)
block|,
literal|0
block|,
name|SCR_CLR
argument_list|(
name|SCR_ACK
operator||
name|SCR_ATN
argument_list|)
block|,
literal|0
block|,
name|SCR_WAIT_DISC
block|,
literal|0
block|,
comment|/* 	**	... and set the status to "ABORTED" 	*/
name|SCR_LOAD_REG
argument_list|(
name|HS_REG
argument_list|,
name|HS_ABORTED
argument_list|)
block|,
literal|0
block|,
name|SCR_JUMP
block|,
name|PADDR
argument_list|(
name|cleanup
argument_list|)
block|,  }
comment|/*-------------------------< GETCC>-----------------------*/
block|,
block|{
comment|/* 	**	The ncr doesn't have an indirect load 	**	or store command. So we have to 	**	copy part of the control block to a 	**	fixed place, where we can modify it. 	** 	**	We patch the address part of a COPY command 	**	with the address of the dsa register ... 	*/
name|SCR_COPY
argument_list|(
literal|4
argument_list|)
block|,
name|RADDR
argument_list|(
name|dsa
argument_list|)
block|,
name|PADDR
argument_list|(
name|getcc1
argument_list|)
block|,
comment|/* 	**	... then we do the actual copy. 	*/
name|SCR_COPY
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|head
argument_list|)
argument_list|)
block|, }
comment|/*-------------------------< GETCC1>----------------------*/
block|,
block|{
literal|0
block|,
name|NADDR
argument_list|(
name|header
argument_list|)
block|,
comment|/* 	**	Initialize the status registers 	*/
name|SCR_COPY
argument_list|(
literal|4
argument_list|)
block|,
name|NADDR
argument_list|(
name|header
operator|.
name|status
argument_list|)
block|,
name|RADDR
argument_list|(
name|scr0
argument_list|)
block|, }
comment|/*-------------------------< GETCC2>----------------------*/
block|,
block|{
comment|/* 	**	Get the condition code from a target. 	** 	**	DSA points to a data structure. 	**	Set TEMP to the script location 	**	that receives the condition code. 	** 	**	Because there is no script command 	**	to load a longword into a register, 	**	we use a CALL command. 	*/
comment|/*<<<*/
name|SCR_CALLR
block|,
literal|24
block|,
comment|/* 	**	Get the condition code. 	*/
name|SCR_MOVE_TBL
operator|^
name|SCR_DATA_IN
block|,
name|offsetof
argument_list|(
expr|struct
name|dsb
argument_list|,
name|sense
argument_list|)
block|,
comment|/* 	**	No data phase may follow! 	*/
name|SCR_CALL
block|,
name|PADDR
argument_list|(
name|checkatn
argument_list|)
block|,
name|SCR_JUMP
block|,
name|PADDR
argument_list|(
name|no_data
argument_list|)
block|,
comment|/*>>>*/
comment|/* 	**	The CALL jumps to this point. 	**	Prepare for a RESTORE_POINTER message. 	**	Save the TEMP register into the saved pointer. 	*/
name|SCR_COPY
argument_list|(
literal|4
argument_list|)
block|,
name|RADDR
argument_list|(
name|temp
argument_list|)
block|,
name|NADDR
argument_list|(
name|header
operator|.
name|savep
argument_list|)
block|,
comment|/* 	**	Load scratcha, because in case of a selection timeout, 	**	the host will expect a new value for startpos in 	**	the scratcha register. 	*/
name|SCR_COPY
argument_list|(
literal|4
argument_list|)
block|,
name|PADDR
argument_list|(
name|startpos
argument_list|)
block|,
name|RADDR
argument_list|(
name|scratcha
argument_list|)
block|,
ifdef|#
directive|ifdef
name|NCR_GETCC_WITHMSG
comment|/* 	**	If QUIRK_NOMSG is set, select without ATN. 	**	and don't send a message. 	*/
name|SCR_FROM_REG
argument_list|(
name|QU_REG
argument_list|)
block|,
literal|0
block|,
name|SCR_JUMP
operator|^
name|IFTRUE
argument_list|(
name|MASK
argument_list|(
name|QUIRK_NOMSG
argument_list|,
name|QUIRK_NOMSG
argument_list|)
argument_list|)
block|,
name|PADDR
argument_list|(
name|getcc3
argument_list|)
block|,
comment|/* 	**	Then try to connect to the target. 	**	If we are reselected, special treatment 	**	of the current job is required before 	**	accepting the reselection. 	*/
name|SCR_SEL_TBL_ATN
operator|^
name|offsetof
argument_list|(
expr|struct
name|dsb
argument_list|,
name|select
argument_list|)
block|,
name|PADDR
argument_list|(
name|badgetcc
argument_list|)
block|,
comment|/* 	**	save target id. 	*/
name|SCR_FROM_REG
argument_list|(
name|sdid
argument_list|)
block|,
literal|0
block|,
name|SCR_TO_REG
argument_list|(
name|ctest0
argument_list|)
block|,
literal|0
block|,
comment|/* 	**	Send the IDENTIFY message. 	**	In case of short transfer, remove ATN. 	*/
name|SCR_MOVE_TBL
operator|^
name|SCR_MSG_OUT
block|,
name|offsetof
argument_list|(
expr|struct
name|dsb
argument_list|,
name|smsg2
argument_list|)
block|,
name|SCR_CLR
argument_list|(
name|SCR_ATN
argument_list|)
block|,
literal|0
block|,
comment|/* 	**	save the first byte of the message. 	*/
name|SCR_COPY
argument_list|(
literal|1
argument_list|)
block|,
name|RADDR
argument_list|(
name|sfbr
argument_list|)
block|,
name|NADDR
argument_list|(
name|lastmsg
argument_list|)
block|,
name|SCR_JUMP
block|,
name|PADDR
argument_list|(
name|prepare2
argument_list|)
block|,
endif|#
directive|endif
block|}
comment|/*-------------------------< GETCC3>----------------------*/
block|,
block|{
comment|/* 	**	Try to connect to the target. 	**	If we are reselected, special treatment 	**	of the current job is required before 	**	accepting the reselection. 	** 	**	Silly target won't accept a message. 	**	Select without ATN. 	*/
name|SCR_SEL_TBL
operator|^
name|offsetof
argument_list|(
expr|struct
name|dsb
argument_list|,
name|select
argument_list|)
block|,
name|PADDR
argument_list|(
name|badgetcc
argument_list|)
block|,
comment|/* 	**	save target id. 	*/
name|SCR_FROM_REG
argument_list|(
name|sdid
argument_list|)
block|,
literal|0
block|,
name|SCR_TO_REG
argument_list|(
name|ctest0
argument_list|)
block|,
literal|0
block|,
comment|/* 	**	Force error if selection timeout 	*/
name|SCR_JUMPR
operator|^
name|IFTRUE
argument_list|(
name|WHEN
argument_list|(
name|SCR_MSG_IN
argument_list|)
argument_list|)
block|,
literal|0
block|,
comment|/* 	**	don't negotiate. 	*/
name|SCR_JUMP
block|,
name|PADDR
argument_list|(
name|prepare2
argument_list|)
block|,  }
comment|/*------------------------< BADGETCC>---------------------*/
block|,
block|{
comment|/* 	**	If SIGP was set, clear it and try again. 	*/
name|SCR_FROM_REG
argument_list|(
name|ctest2
argument_list|)
block|,
literal|0
block|,
name|SCR_JUMP
operator|^
name|IFTRUE
argument_list|(
name|MASK
argument_list|(
name|CSIGP
argument_list|,
name|CSIGP
argument_list|)
argument_list|)
block|,
name|PADDR
argument_list|(
name|getcc2
argument_list|)
block|,
name|SCR_INT
block|,
name|SIR_SENSE_FAILED
block|, }
comment|/*-------------------------< RESELECT>--------------------*/
block|,
block|{
comment|/* 	**	make the DSA invalid. 	*/
name|SCR_LOAD_REG
argument_list|(
name|dsa
argument_list|,
literal|0xff
argument_list|)
block|,
literal|0
block|,
name|SCR_CLR
argument_list|(
name|SCR_TRG
argument_list|)
block|,
literal|0
block|,
comment|/* 	**	Sleep waiting for a reselection. 	**	If SIGP is set, special treatment. 	** 	**	Zu allem bereit .. 	*/
name|SCR_WAIT_RESEL
block|,
name|PADDR
argument_list|(
name|reselect2
argument_list|)
block|,
comment|/* 	**	... zu nichts zu gebrauchen ? 	** 	**      load the target id into the SFBR 	**	and jump to the control block. 	** 	**	Look at the declarations of 	**	- struct ncb 	**	- struct tcb 	**	- struct lcb 	**	- struct ccb 	**	to understand what's going on. 	*/
name|SCR_REG_SFBR
argument_list|(
name|ssid
argument_list|,
name|SCR_AND
argument_list|,
literal|0x8F
argument_list|)
block|,
literal|0
block|,
name|SCR_TO_REG
argument_list|(
name|ctest0
argument_list|)
block|,
literal|0
block|,
name|SCR_JUMP
block|,
name|NADDR
argument_list|(
name|jump_tcb
argument_list|)
block|, }
comment|/*-------------------------< RESELECT2>-------------------*/
block|,
block|{
comment|/* 	**	If it's not connected :( 	**	-> interrupted by SIGP bit. 	**	Jump to start. 	*/
name|SCR_FROM_REG
argument_list|(
name|ctest2
argument_list|)
block|,
literal|0
block|,
name|SCR_JUMP
operator|^
name|IFTRUE
argument_list|(
name|MASK
argument_list|(
name|CSIGP
argument_list|,
name|CSIGP
argument_list|)
argument_list|)
block|,
name|PADDR
argument_list|(
name|start
argument_list|)
block|,
name|SCR_JUMP
block|,
name|PADDR
argument_list|(
name|reselect
argument_list|)
block|,  }
comment|/*-------------------------< RESEL_TMP>-------------------*/
block|,
block|{
comment|/* 	**	The return address in TEMP 	**	is in fact the data structure address, 	**	so copy it to the DSA register. 	*/
name|SCR_COPY
argument_list|(
literal|4
argument_list|)
block|,
name|RADDR
argument_list|(
name|temp
argument_list|)
block|,
name|RADDR
argument_list|(
name|dsa
argument_list|)
block|,
name|SCR_JUMP
block|,
name|PADDR
argument_list|(
name|prepare
argument_list|)
block|,  }
comment|/*-------------------------< RESEL_LUN>-------------------*/
block|,
block|{
comment|/* 	**	come back to this point 	**	to get an IDENTIFY message 	**	Wait for a msg_in phase. 	*/
comment|/*<<<*/
name|SCR_JUMPR
operator|^
name|IFFALSE
argument_list|(
name|WHEN
argument_list|(
name|SCR_MSG_IN
argument_list|)
argument_list|)
block|,
literal|48
block|,
comment|/* 	**	message phase 	**	It's not a sony, it's a trick: 	**	read the data without acknowledging it. 	*/
name|SCR_FROM_REG
argument_list|(
name|sbdl
argument_list|)
block|,
literal|0
block|,
comment|/*<<<*/
name|SCR_JUMPR
operator|^
name|IFFALSE
argument_list|(
name|MASK
argument_list|(
name|M_IDENTIFY
argument_list|,
literal|0x98
argument_list|)
argument_list|)
block|,
literal|32
block|,
comment|/* 	**	It WAS an Identify message. 	**	get it and ack it! 	*/
name|SCR_MOVE_ABS
argument_list|(
literal|1
argument_list|)
operator|^
name|SCR_MSG_IN
block|,
name|NADDR
argument_list|(
name|msgin
argument_list|)
block|,
name|SCR_CLR
argument_list|(
name|SCR_ACK
argument_list|)
block|,
literal|0
block|,
comment|/* 	**	Mask out the lun. 	*/
name|SCR_REG_REG
argument_list|(
name|sfbr
argument_list|,
name|SCR_AND
argument_list|,
literal|0x07
argument_list|)
block|,
literal|0
block|,
name|SCR_RETURN
block|,
literal|0
block|,
comment|/* 	**	No message phase or no IDENTIFY message: 	**	return 0. 	*/
comment|/*>>>*/
name|SCR_LOAD_SFBR
argument_list|(
literal|0
argument_list|)
block|,
literal|0
block|,
name|SCR_RETURN
block|,
literal|0
block|,  }
comment|/*-------------------------< RESEL_TAG>-------------------*/
block|,
block|{
comment|/* 	**	come back to this point 	**	to get a SIMPLE_TAG message 	**	Wait for a MSG_IN phase. 	*/
comment|/*<<<*/
name|SCR_JUMPR
operator|^
name|IFFALSE
argument_list|(
name|WHEN
argument_list|(
name|SCR_MSG_IN
argument_list|)
argument_list|)
block|,
literal|64
block|,
comment|/* 	**	message phase 	**	It's a trick - read the data 	**	without acknowledging it. 	*/
name|SCR_FROM_REG
argument_list|(
name|sbdl
argument_list|)
block|,
literal|0
block|,
comment|/*<<<*/
name|SCR_JUMPR
operator|^
name|IFFALSE
argument_list|(
name|DATA
argument_list|(
name|M_SIMPLE_TAG
argument_list|)
argument_list|)
block|,
literal|48
block|,
comment|/* 	**	It WAS a SIMPLE_TAG message. 	**	get it and ack it! 	*/
name|SCR_MOVE_ABS
argument_list|(
literal|1
argument_list|)
operator|^
name|SCR_MSG_IN
block|,
name|NADDR
argument_list|(
name|msgin
argument_list|)
block|,
name|SCR_CLR
argument_list|(
name|SCR_ACK
argument_list|)
block|,
literal|0
block|,
comment|/* 	**	Wait for the second byte (the tag) 	*/
comment|/*<<<*/
name|SCR_JUMPR
operator|^
name|IFFALSE
argument_list|(
name|WHEN
argument_list|(
name|SCR_MSG_IN
argument_list|)
argument_list|)
block|,
literal|24
block|,
comment|/* 	**	Get it and ack it! 	*/
name|SCR_MOVE_ABS
argument_list|(
literal|1
argument_list|)
operator|^
name|SCR_MSG_IN
block|,
name|NADDR
argument_list|(
name|msgin
argument_list|)
block|,
name|SCR_CLR
argument_list|(
name|SCR_ACK
operator||
name|SCR_CARRY
argument_list|)
block|,
literal|0
block|,
name|SCR_RETURN
block|,
literal|0
block|,
comment|/* 	**	No message phase or no SIMPLE_TAG message 	**	or no second byte: return 0. 	*/
comment|/*>>>*/
name|SCR_LOAD_SFBR
argument_list|(
literal|0
argument_list|)
block|,
literal|0
block|,
name|SCR_SET
argument_list|(
name|SCR_CARRY
argument_list|)
block|,
literal|0
block|,
name|SCR_RETURN
block|,
literal|0
block|,  }
comment|/*-------------------------< DATA_IN>--------------------*/
block|,
block|{
comment|/* **	Because the size depends on the **	#define MAX_SCATTER parameter, **	it is filled in at runtime. ** **	SCR_JUMP ^ IFFALSE (WHEN (SCR_DATA_IN)), **		PADDR (no_data), **	SCR_COPY (sizeof (struct timeval)), **		(ncrcmd)&time, **		NADDR (header.stamp.data), **	SCR_MOVE_TBL ^ SCR_DATA_IN, **		offsetof (struct dsb, data[ 0]), ** **  ##===========< i=1; i<MAX_SCATTER>========= **  ||	SCR_CALL ^ IFFALSE (WHEN (SCR_DATA_IN)), **  ||		PADDR (checkatn), **  ||	SCR_MOVE_TBL ^ SCR_DATA_IN, **  ||		offsetof (struct dsb, data[ i]), **  ##========================================== ** **	SCR_CALL, **		PADDR (checkatn), **	SCR_JUMP, **		PADDR (no_data), */
literal|0
block|}
comment|/*-------------------------< DATA_OUT>-------------------*/
block|,
block|{
comment|/* **	Because the size depends on the **	#define MAX_SCATTER parameter, **	it is filled in at runtime. ** **	SCR_JUMP ^ IFFALSE (WHEN (SCR_DATA_IN)), **		PADDR (no_data), **	SCR_COPY (sizeof (struct timeval)), **		(ncrcmd)&time, **		NADDR (header.stamp.data), **	SCR_MOVE_TBL ^ SCR_DATA_OUT, **		offsetof (struct dsb, data[ 0]), ** **  ##===========< i=1; i<MAX_SCATTER>========= **  ||	SCR_CALL ^ IFFALSE (WHEN (SCR_DATA_OUT)), **  ||		PADDR (dispatch), **  ||	SCR_MOVE_TBL ^ SCR_DATA_OUT, **  ||		offsetof (struct dsb, data[ i]), **  ##========================================== ** **	SCR_CALL, **		PADDR (dispatch), **	SCR_JUMP, **		PADDR (no_data), ** **--------------------------------------------------------- */
operator|(
name|u_long
operator|)
operator|&
name|ident
block|}
comment|/*-------------------------< ABORTTAG>-------------------*/
block|,
block|{
comment|/* 	**      Abort a bad reselection. 	**	Set the message to ABORT vs. ABORT_TAG 	*/
name|SCR_LOAD_REG
argument_list|(
name|scratcha
argument_list|,
name|M_ABORT_TAG
argument_list|)
block|,
literal|0
block|,
name|SCR_JUMPR
operator|^
name|IFFALSE
argument_list|(
name|CARRYSET
argument_list|)
block|,
literal|8
block|, }
comment|/*-------------------------< ABORT>----------------------*/
block|,
block|{
name|SCR_LOAD_REG
argument_list|(
name|scratcha
argument_list|,
name|M_ABORT
argument_list|)
block|,
literal|0
block|,
name|SCR_COPY
argument_list|(
literal|1
argument_list|)
block|,
name|RADDR
argument_list|(
name|scratcha
argument_list|)
block|,
name|NADDR
argument_list|(
name|msgout
argument_list|)
block|,
name|SCR_SET
argument_list|(
name|SCR_ATN
argument_list|)
block|,
literal|0
block|,
name|SCR_CLR
argument_list|(
name|SCR_ACK
argument_list|)
block|,
literal|0
block|,
comment|/* 	**	and send it. 	**	we expect an immediate disconnect 	*/
name|SCR_REG_REG
argument_list|(
name|scntl2
argument_list|,
name|SCR_AND
argument_list|,
literal|0x7f
argument_list|)
block|,
literal|0
block|,
name|SCR_MOVE_ABS
argument_list|(
literal|1
argument_list|)
operator|^
name|SCR_MSG_OUT
block|,
name|NADDR
argument_list|(
name|msgout
argument_list|)
block|,
name|SCR_COPY
argument_list|(
literal|1
argument_list|)
block|,
name|RADDR
argument_list|(
name|sfbr
argument_list|)
block|,
name|NADDR
argument_list|(
name|lastmsg
argument_list|)
block|,
name|SCR_CLR
argument_list|(
name|SCR_ACK
operator||
name|SCR_ATN
argument_list|)
block|,
literal|0
block|,
name|SCR_WAIT_DISC
block|,
literal|0
block|,
name|SCR_JUMP
block|,
name|PADDR
argument_list|(
name|start
argument_list|)
block|, }
comment|/*-------------------------< SNOOPTEST>-------------------*/
block|,
block|{
comment|/* 	**	Read the variable. 	*/
name|SCR_COPY
argument_list|(
literal|4
argument_list|)
block|,
operator|(
name|ncrcmd
operator|)
operator|&
name|ncr_cache
block|,
name|RADDR
argument_list|(
name|scratcha
argument_list|)
block|,
comment|/* 	**	Write the variable. 	*/
name|SCR_COPY
argument_list|(
literal|4
argument_list|)
block|,
name|RADDR
argument_list|(
name|temp
argument_list|)
block|,
operator|(
name|ncrcmd
operator|)
operator|&
name|ncr_cache
block|,
comment|/* 	**	Read back the variable. 	*/
name|SCR_COPY
argument_list|(
literal|4
argument_list|)
block|,
operator|(
name|ncrcmd
operator|)
operator|&
name|ncr_cache
block|,
name|RADDR
argument_list|(
name|temp
argument_list|)
block|, }
comment|/*-------------------------< SNOOPEND>-------------------*/
block|,
block|{
comment|/* 	**	And stop. 	*/
name|SCR_INT
block|,
literal|99
block|, }
comment|/*--------------------------------------------------------*/
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*========================================================== ** ** **	Fill in #define dependent parts of the script ** ** **========================================================== */
end_comment

begin_function
name|void
name|ncr_script_fill
parameter_list|(
name|struct
name|script
modifier|*
name|scr
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|ncrcmd
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|scr
operator|->
name|tryloop
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_START
condition|;
name|i
operator|++
control|)
block|{
operator|*
name|p
operator|++
operator|=
name|SCR_COPY
argument_list|(
literal|4
argument_list|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|NADDR
argument_list|(
name|squeue
index|[
name|i
index|]
argument_list|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|RADDR
argument_list|(
name|dsa
argument_list|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|SCR_CALL
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|PADDR
argument_list|(
name|trysel
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
operator|*
name|p
operator|++
operator|=
name|SCR_JUMP
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|PADDR
argument_list|(
name|tryloop
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|(
name|u_long
operator|)
name|p
operator|==
operator|(
name|u_long
operator|)
operator|&
name|scr
operator|->
name|tryloop
operator|+
sizeof|sizeof
argument_list|(
name|scr
operator|->
name|tryloop
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|=
name|scr
operator|->
name|data_in
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|SCR_JUMP
operator|^
name|IFFALSE
argument_list|(
name|WHEN
argument_list|(
name|SCR_DATA_IN
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|PADDR
argument_list|(
name|no_data
argument_list|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|SCR_COPY
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|timeval
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
operator|(
name|ncrcmd
operator|)
operator|&
name|time
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|NADDR
argument_list|(
name|header
operator|.
name|stamp
operator|.
name|data
argument_list|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|SCR_MOVE_TBL
operator|^
name|SCR_DATA_IN
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|offsetof
argument_list|(
expr|struct
name|dsb
argument_list|,
name|data
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|MAX_SCATTER
condition|;
name|i
operator|++
control|)
block|{
operator|*
name|p
operator|++
operator|=
name|SCR_CALL
operator|^
name|IFFALSE
argument_list|(
name|WHEN
argument_list|(
name|SCR_DATA_IN
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|PADDR
argument_list|(
name|checkatn
argument_list|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|SCR_MOVE_TBL
operator|^
name|SCR_DATA_IN
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|offsetof
argument_list|(
expr|struct
name|dsb
argument_list|,
name|data
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
operator|*
name|p
operator|++
operator|=
name|SCR_CALL
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|PADDR
argument_list|(
name|checkatn
argument_list|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|SCR_JUMP
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|PADDR
argument_list|(
name|no_data
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|(
name|u_long
operator|)
name|p
operator|==
operator|(
name|u_long
operator|)
operator|&
name|scr
operator|->
name|data_in
operator|+
sizeof|sizeof
argument_list|(
name|scr
operator|->
name|data_in
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|=
name|scr
operator|->
name|data_out
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|SCR_JUMP
operator|^
name|IFFALSE
argument_list|(
name|WHEN
argument_list|(
name|SCR_DATA_OUT
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|PADDR
argument_list|(
name|no_data
argument_list|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|SCR_COPY
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|timeval
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
operator|(
name|ncrcmd
operator|)
operator|&
name|time
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|NADDR
argument_list|(
name|header
operator|.
name|stamp
operator|.
name|data
argument_list|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|SCR_MOVE_TBL
operator|^
name|SCR_DATA_OUT
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|offsetof
argument_list|(
expr|struct
name|dsb
argument_list|,
name|data
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|MAX_SCATTER
condition|;
name|i
operator|++
control|)
block|{
operator|*
name|p
operator|++
operator|=
name|SCR_CALL
operator|^
name|IFFALSE
argument_list|(
name|WHEN
argument_list|(
name|SCR_DATA_OUT
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|PADDR
argument_list|(
name|dispatch
argument_list|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|SCR_MOVE_TBL
operator|^
name|SCR_DATA_OUT
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|offsetof
argument_list|(
expr|struct
name|dsb
argument_list|,
name|data
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
operator|*
name|p
operator|++
operator|=
name|SCR_CALL
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|PADDR
argument_list|(
name|dispatch
argument_list|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|SCR_JUMP
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|PADDR
argument_list|(
name|no_data
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|(
name|u_long
operator|)
name|p
operator|==
operator|(
name|u_long
operator|)
operator|&
name|scr
operator|->
name|data_out
operator|+
sizeof|sizeof
argument_list|(
name|scr
operator|->
name|data_out
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*========================================================== ** ** **	Copy and rebind a script. ** ** **========================================================== */
end_comment

begin_function
specifier|static
name|void
name|ncr_script_copy_and_bind
parameter_list|(
name|struct
name|script
modifier|*
name|script
parameter_list|,
name|ncb_p
name|np
parameter_list|)
block|{
name|ncrcmd
name|opcode
decl_stmt|,
name|new
decl_stmt|,
name|old
decl_stmt|;
name|ncrcmd
modifier|*
name|src
decl_stmt|,
modifier|*
name|dst
decl_stmt|,
modifier|*
name|start
decl_stmt|,
modifier|*
name|end
decl_stmt|;
name|int
name|relocs
decl_stmt|;
ifndef|#
directive|ifndef
name|__NetBSD__
name|np
operator|->
name|script
operator|=
operator|(
expr|struct
name|script
operator|*
operator|)
name|vm_page_alloc_contig
argument_list|(
name|round_page
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|script
argument_list|)
argument_list|)
argument_list|,
literal|0x100000
argument_list|,
literal|0xffffffff
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* !__NetBSD___ */
name|np
operator|->
name|script
operator|=
operator|(
expr|struct
name|script
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|script
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* __NetBSD__ */
name|np
operator|->
name|p_script
operator|=
name|vtophys
argument_list|(
name|np
operator|->
name|script
argument_list|)
expr_stmt|;
name|src
operator|=
name|script
operator|->
name|start
expr_stmt|;
name|dst
operator|=
name|np
operator|->
name|script
operator|->
name|start
expr_stmt|;
name|start
operator|=
name|src
expr_stmt|;
name|end
operator|=
name|src
operator|+
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|script
argument_list|)
operator|/
literal|4
operator|)
expr_stmt|;
while|while
condition|(
name|src
operator|<
name|end
condition|)
block|{
operator|*
name|dst
operator|++
operator|=
name|opcode
operator|=
operator|*
name|src
operator|++
expr_stmt|;
comment|/* 		**	If we forget to change the length 		**	in struct script, a field will be 		**	padded with 0. This is an illegal 		**	command. 		*/
if|if
condition|(
name|opcode
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%s: ERROR0 IN SCRIPT at %d.\n"
argument_list|,
name|ncr_name
argument_list|(
name|np
argument_list|)
argument_list|,
name|src
operator|-
name|start
operator|-
literal|1
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1000000
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
if|if
condition|(
name|DEBUG_FLAGS
operator|&
name|DEBUG_SCRIPT
condition|)
name|printf
argument_list|(
literal|"%x:<%x>\n"
argument_list|,
call|(
name|unsigned
call|)
argument_list|(
name|src
operator|-
literal|1
argument_list|)
argument_list|,
operator|(
name|unsigned
operator|)
name|opcode
argument_list|)
expr_stmt|;
comment|/* 		**	We don't have to decode ALL commands 		*/
switch|switch
condition|(
name|opcode
operator|>>
literal|28
condition|)
block|{
case|case
literal|0xc
case|:
comment|/* 			**	COPY has TWO arguments. 			*/
name|relocs
operator|=
literal|2
expr_stmt|;
if|if
condition|(
operator|(
name|src
index|[
literal|0
index|]
operator|^
name|src
index|[
literal|1
index|]
operator|)
operator|&
literal|3
condition|)
block|{
name|printf
argument_list|(
literal|"%s: ERROR1 IN SCRIPT at %d.\n"
argument_list|,
name|ncr_name
argument_list|(
name|np
argument_list|)
argument_list|,
name|src
operator|-
name|start
operator|-
literal|1
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1000000
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
break|break;
case|case
literal|0x0
case|:
comment|/* 			**	MOVE (absolute address) 			*/
name|relocs
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|0x8
case|:
comment|/* 			**	JUMP / CALL 			**	dont't relocate if relative :-) 			*/
if|if
condition|(
name|opcode
operator|&
literal|0x00800000
condition|)
name|relocs
operator|=
literal|0
expr_stmt|;
else|else
name|relocs
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|0x4
case|:
case|case
literal|0x5
case|:
case|case
literal|0x6
case|:
case|case
literal|0x7
case|:
name|relocs
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
name|relocs
operator|=
literal|0
expr_stmt|;
break|break;
block|}
empty_stmt|;
if|if
condition|(
name|relocs
condition|)
block|{
while|while
condition|(
name|relocs
operator|--
condition|)
block|{
name|old
operator|=
operator|*
name|src
operator|++
expr_stmt|;
switch|switch
condition|(
name|old
operator|&
name|RELOC_MASK
condition|)
block|{
case|case
name|RELOC_REGISTER
case|:
name|new
operator|=
operator|(
name|old
operator|&
operator|~
name|RELOC_MASK
operator|)
operator|+
name|np
operator|->
name|paddr
expr_stmt|;
break|break;
case|case
name|RELOC_LABEL
case|:
name|new
operator|=
operator|(
name|old
operator|&
operator|~
name|RELOC_MASK
operator|)
operator|+
name|np
operator|->
name|p_script
expr_stmt|;
break|break;
case|case
name|RELOC_SOFTC
case|:
name|new
operator|=
operator|(
name|old
operator|&
operator|~
name|RELOC_MASK
operator|)
operator|+
name|vtophys
argument_list|(
name|np
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0
case|:
comment|/* Don't relocate a 0 address. */
if|if
condition|(
name|old
operator|==
literal|0
condition|)
block|{
name|new
operator|=
name|old
expr_stmt|;
break|break;
block|}
comment|/* fall through */
default|default:
name|new
operator|=
name|vtophys
argument_list|(
name|old
argument_list|)
expr_stmt|;
break|break;
block|}
operator|*
name|dst
operator|++
operator|=
name|new
expr_stmt|;
block|}
block|}
else|else
operator|*
name|dst
operator|++
operator|=
operator|*
name|src
operator|++
expr_stmt|;
block|}
empty_stmt|;
block|}
end_function

begin_comment
comment|/*========================================================== ** ** **      Auto configuration. ** ** **========================================================== */
end_comment

begin_comment
comment|/*---------------------------------------------------------- ** **	Reduce the transfer length to the max value **	we can transfer safely. ** **      Reading a block greater then MAX_SIZE from the **	raw (character) device exercises a memory leak **	in the vm subsystem. This is common to ALL devices. **	We have submitted a description of this bug to **<FreeBSD-bugs@freefall.cdrom.com>. **	It should be fixed in the current release. ** **---------------------------------------------------------- */
end_comment

begin_function
name|void
name|ncr_min_phys
parameter_list|(
name|struct
name|buf
modifier|*
name|bp
parameter_list|)
block|{
if|if
condition|(
operator|(
name|unsigned
name|long
operator|)
name|bp
operator|->
name|b_bcount
operator|>
name|MAX_SIZE
condition|)
name|bp
operator|->
name|b_bcount
operator|=
name|MAX_SIZE
expr_stmt|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------- ** **	Maximal number of outstanding requests per target. ** **---------------------------------------------------------- */
end_comment

begin_function
name|u_int32_t
name|ncr_info
parameter_list|(
name|int
name|unit
parameter_list|)
block|{
return|return
operator|(
literal|1
operator|)
return|;
comment|/* may be changed later */
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------- ** **	Probe the hostadapter. ** **---------------------------------------------------------- */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__NetBSD__
end_ifdef

begin_function
name|int
name|ncr_probe
parameter_list|(
name|parent
parameter_list|,
name|match
parameter_list|,
name|aux
parameter_list|)
name|struct
name|device
modifier|*
name|parent
decl_stmt|;
name|void
modifier|*
name|match
decl_stmt|,
decl|*
name|aux
decl_stmt|;
end_function

begin_block
block|{
name|struct
name|cfdata
modifier|*
name|cf
init|=
name|match
decl_stmt|;
name|struct
name|pci_attach_args
modifier|*
name|pa
init|=
name|aux
decl_stmt|;
if|#
directive|if
literal|0
block|if (!pci_targmatch(cf, pa)) 		return 0;
endif|#
directive|endif
if|if
condition|(
name|pa
operator|->
name|pa_id
operator|!=
name|NCR_810_ID
operator|&&
name|pa
operator|->
name|pa_id
operator|!=
name|NCR_815_ID
operator|&&
name|pa
operator|->
name|pa_id
operator|!=
name|NCR_825_ID
operator|&&
name|pa
operator|->
name|pa_id
operator|!=
name|NCR_860_ID
operator|&&
name|pa
operator|->
name|pa_id
operator|!=
name|NCR_875_ID
operator|&&
name|pa
operator|->
name|pa_id
operator|!=
name|NCR_875_ID2
operator|&&
name|pa
operator|->
name|pa_id
operator|!=
name|NCR_885_ID
operator|&&
name|pa
operator|->
name|pa_id
operator|!=
name|NCR_895_ID
operator|&&
name|pa
operator|->
name|pa_id
operator|!=
name|NCR_896_ID
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_block

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* !__NetBSD__ */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|ncr_probe
parameter_list|(
name|pcici_t
name|tag
parameter_list|,
name|pcidi_t
name|type
parameter_list|)
block|{
name|u_char
name|rev
init|=
name|pci_conf_read
argument_list|(
name|tag
argument_list|,
name|PCI_CLASS_REG
argument_list|)
operator|&
literal|0xff
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|NCR_810_ID
case|:
return|return
operator|(
name|rev
operator|&
literal|0xf0
operator|)
operator|==
literal|0x00
condition|?
operator|(
literal|"ncr 53c810 scsi"
operator|)
else|:
operator|(
literal|"ncr 53c810a scsi"
operator|)
return|;
case|case
name|NCR_815_ID
case|:
return|return
operator|(
literal|"ncr 53c815 scsi"
operator|)
return|;
case|case
name|NCR_825_ID
case|:
return|return
operator|(
name|rev
operator|&
literal|0xf0
operator|)
operator|==
literal|0x00
condition|?
operator|(
literal|"ncr 53c825 wide scsi"
operator|)
else|:
operator|(
literal|"ncr 53c825a wide scsi"
operator|)
return|;
case|case
name|NCR_860_ID
case|:
return|return
operator|(
literal|"ncr 53c860 ultra scsi"
operator|)
return|;
case|case
name|NCR_875_ID
case|:
case|case
name|NCR_875_ID2
case|:
return|return
operator|(
literal|"ncr 53c875 ultra wide scsi"
operator|)
return|;
case|case
name|NCR_885_ID
case|:
return|return
operator|(
literal|"ncr 53c885 ultra wide scsi"
operator|)
return|;
case|case
name|NCR_895_ID
case|:
return|return
operator|(
literal|"ncr 53c895 ultra wide scsi"
operator|)
return|;
case|case
name|NCR_896_ID
case|:
return|return
operator|(
literal|"ncr 53c896 ultra wide scsi"
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !__NetBSD__ */
end_comment

begin_comment
comment|/*========================================================== ** ** **      Auto configuration:  attach and init a host adapter. ** ** **========================================================== */
end_comment

begin_define
define|#
directive|define
name|MIN_ASYNC_PD
value|40
end_define

begin_define
define|#
directive|define
name|MIN_SYNC_PD
value|20
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|__NetBSD__
end_ifdef

begin_function
name|int
name|ncr_print
parameter_list|()
block|{ }
end_function

begin_function
name|void
name|ncr_attach
parameter_list|(
name|parent
parameter_list|,
name|self
parameter_list|,
name|aux
parameter_list|)
name|struct
name|device
modifier|*
name|parent
decl_stmt|,
decl|*
name|self
decl_stmt|;
end_function

begin_decl_stmt
name|void
modifier|*
name|aux
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|pci_attach_args
modifier|*
name|pa
init|=
name|aux
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|ncb_p
name|np
init|=
operator|(
name|void
operator|*
operator|)
name|self
decl_stmt|;
comment|/* 	** XXX NetBSD 	** Perhaps try to figure what which model chip it is and print that 	** out. 	*/
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
comment|/* 	**	Try to map the controller chip to 	**	virtual and physical memory. 	*/
name|retval
operator|=
name|pci_map_mem
argument_list|(
name|pa
operator|->
name|pa_tag
argument_list|,
literal|0x14
argument_list|,
operator|&
name|np
operator|->
name|vaddr
argument_list|,
operator|&
name|np
operator|->
name|paddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
condition|)
return|return;
name|np
operator|->
name|sc_ih
operator|=
name|pci_map_int
argument_list|(
name|pa
operator|->
name|pa_tag
argument_list|,
name|PCI_IPL_BIO
argument_list|,
name|ncr_intr
argument_list|,
name|np
argument_list|)
expr_stmt|;
if|if
condition|(
name|np
operator|->
name|sc_ih
operator|==
name|NULL
condition|)
return|return;
else|#
directive|else
comment|/* !__NetBSD__ */
specifier|static
name|void
name|ncr_attach
parameter_list|(
name|pcici_t
name|config_id
parameter_list|,
name|int
name|unit
parameter_list|)
block|{
name|ncb_p
name|np
init|=
operator|(
expr|struct
name|ncb
operator|*
operator|)
literal|0
decl_stmt|;
if|#
directive|if
operator|!
operator|(
name|__FreeBSD__
operator|>=
literal|2
operator|)
specifier|extern
name|unsigned
name|bio_imask
decl_stmt|;
endif|#
directive|endif
if|#
directive|if
operator|(
name|__FreeBSD__
operator|>=
literal|2
operator|)
name|struct
name|scsibus_data
modifier|*
name|scbus
decl_stmt|;
endif|#
directive|endif
comment|/* 	**	allocate structure 	*/
if|if
condition|(
operator|!
name|np
condition|)
block|{
name|np
operator|=
operator|(
name|ncb_p
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ncb
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|np
condition|)
return|return;
name|ncrp
index|[
name|unit
index|]
operator|=
name|np
expr_stmt|;
block|}
comment|/* 	**	initialize structure. 	*/
name|bzero
argument_list|(
name|np
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|np
argument_list|)
argument_list|)
expr_stmt|;
name|np
operator|->
name|unit
operator|=
name|unit
expr_stmt|;
comment|/* 	**	Try to map the controller chip to 	**	virtual and physical memory. 	*/
if|if
condition|(
operator|!
name|pci_map_mem
argument_list|(
name|config_id
argument_list|,
literal|0x14
argument_list|,
operator|&
name|np
operator|->
name|vaddr
argument_list|,
operator|&
name|np
operator|->
name|paddr
argument_list|)
condition|)
return|return;
comment|/* 	**	Make the controller's registers available. 	**	Now the INB INW INL OUTB OUTW OUTL macros 	**	can be used safely. 	*/
name|np
operator|->
name|reg
operator|=
operator|(
expr|struct
name|ncr_reg
operator|*
operator|)
name|np
operator|->
name|vaddr
expr_stmt|;
ifdef|#
directive|ifdef
name|NCR_IOMAPPED
comment|/* 	**	Try to map the controller chip into iospace. 	*/
if|if
condition|(
operator|!
name|pci_map_port
argument_list|(
name|config_id
argument_list|,
literal|0x10
argument_list|,
operator|&
name|np
operator|->
name|port
argument_list|)
condition|)
return|return;
endif|#
directive|endif
endif|#
directive|endif
comment|/* !__NetBSD__ */
comment|/* 	**	Do chip dependent initialization. 	*/
name|np
operator|->
name|maxwide
operator|=
literal|0
expr_stmt|;
name|np
operator|->
name|rv_scntl3
operator|=
literal|0x13
expr_stmt|;
comment|/* default: 40MHz clock */
name|np
operator|->
name|ns_sync
operator|=
literal|25
expr_stmt|;
comment|/* in units of 4ns */
name|np
operator|->
name|maxoffs
operator|=
literal|8
expr_stmt|;
comment|/* 	**	Get the frequency of the chip's clock. 	**	Find the right value for scntl3. 	*/
ifdef|#
directive|ifdef
name|__NetBSD__
switch|switch
condition|(
name|pa
operator|->
name|pa_id
condition|)
block|{
else|#
directive|else
comment|/* !__NetBSD__ */
switch|switch
condition|(
name|pci_conf_read
argument_list|(
name|config_id
argument_list|,
name|PCI_ID_REG
argument_list|)
condition|)
block|{
endif|#
directive|endif
comment|/* __NetBSD__ */
case|case
name|NCR_825_ID
case|:
block|{
ifndef|#
directive|ifndef
name|__NetBSD__
name|u_char
name|rev
init|=
name|pci_conf_read
argument_list|(
name|config_id
argument_list|,
name|PCI_CLASS_REG
argument_list|)
operator|&
literal|0xff
decl_stmt|;
if|if
condition|(
operator|(
name|rev
operator|&
literal|0xf0
operator|)
operator|==
literal|0x10
condition|)
name|np
operator|->
name|maxoffs
operator|=
literal|16
expr_stmt|;
endif|#
directive|endif
comment|/* !__NetBSD__ */
name|np
operator|->
name|maxwide
operator|=
literal|1
expr_stmt|;
break|break;
block|}
case|case
name|NCR_860_ID
case|:
name|np
operator|->
name|rv_scntl3
operator|=
literal|0x35
expr_stmt|;
comment|/* always assume 80MHz clock for 860 */
break|break;
case|case
name|NCR_875_ID
case|:
case|case
name|NCR_875_ID2
case|:
case|case
name|NCR_885_ID
case|:
case|case
name|NCR_895_ID
case|:
case|case
name|NCR_896_ID
case|:
name|np
operator|->
name|maxwide
operator|=
literal|1
expr_stmt|;
name|np
operator|->
name|maxoffs
operator|=
literal|16
expr_stmt|;
name|ncr_getclock
argument_list|(
name|np
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* 	**	Patch script to physical addresses 	*/
name|ncr_script_fill
argument_list|(
operator|&
name|script0
argument_list|)
expr_stmt|;
name|ncr_script_copy_and_bind
argument_list|(
operator|&
name|script0
argument_list|,
name|np
argument_list|)
expr_stmt|;
name|np
operator|->
name|ccb
operator|.
name|p_ccb
operator|=
name|vtophys
argument_list|(
operator|&
name|np
operator|->
name|ccb
argument_list|)
expr_stmt|;
comment|/* 	**	init data structure 	*/
name|np
operator|->
name|jump_tcb
operator|.
name|l_cmd
operator|=
name|SCR_JUMP
expr_stmt|;
name|np
operator|->
name|jump_tcb
operator|.
name|l_paddr
operator|=
name|NCB_SCRIPT_PHYS
argument_list|(
name|np
argument_list|,
name|abort
argument_list|)
expr_stmt|;
comment|/* 	**  Get SCSI addr of host adapter (set by bios?). 	*/
name|np
operator|->
name|myaddr
operator|=
name|INB
argument_list|(
name|nc_scid
argument_list|)
operator|&
literal|0x07
expr_stmt|;
if|if
condition|(
operator|!
name|np
operator|->
name|myaddr
condition|)
name|np
operator|->
name|myaddr
operator|=
name|SCSI_NCR_MYADDR
expr_stmt|;
ifdef|#
directive|ifdef
name|NCR_DUMP_REG
comment|/* 	**	Log the initial register contents 	*/
block|{
name|int
name|reg
decl_stmt|;
ifdef|#
directive|ifdef
name|__NetBSD__
name|u_long
name|config_id
init|=
name|pa
operator|->
name|pa_tag
decl_stmt|;
endif|#
directive|endif
comment|/* __NetBSD__ */
for|for
control|(
name|reg
operator|=
literal|0
init|;
name|reg
operator|<
literal|256
condition|;
name|reg
operator|+=
literal|4
control|)
block|{
if|if
condition|(
name|reg
operator|%
literal|16
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"reg[%2x]"
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" %08x"
argument_list|,
operator|(
name|int
operator|)
name|pci_conf_read
argument_list|(
name|config_id
argument_list|,
name|reg
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg
operator|%
literal|16
operator|==
literal|12
condition|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* NCR_DUMP_REG */
comment|/* 	**	Reset chip. 	*/
name|OUTB
argument_list|(
name|nc_istat
argument_list|,
name|SRST
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
name|nc_istat
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	**	Now check the cache handling of the pci chipset. 	*/
if|if
condition|(
name|ncr_snooptest
argument_list|(
name|np
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"CACHE INCORRECTLY CONFIGURED.\n"
argument_list|)
expr_stmt|;
return|return;
block|}
empty_stmt|;
ifndef|#
directive|ifndef
name|__NetBSD__
comment|/* 	**	Install the interrupt handler. 	*/
if|if
condition|(
operator|!
name|pci_map_int
argument_list|(
name|config_id
argument_list|,
name|ncr_intr
argument_list|,
name|np
argument_list|,
operator|&
name|bio_imask
argument_list|)
condition|)
name|printf
argument_list|(
literal|"\tinterruptless mode: reduced performance.\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* __NetBSD__ */
comment|/* 	**	After SCSI devices have been opened, we cannot 	**	reset the bus safely, so we do it here. 	**	Interrupt handler does the real work. 	*/
name|OUTB
argument_list|(
name|nc_scntl1
argument_list|,
name|CRST
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
comment|/* 	**	Process the reset exception, 	**	if interrupts are not enabled yet. 	**	Then enable disconnects. 	*/
name|ncr_exception
argument_list|(
name|np
argument_list|)
expr_stmt|;
name|np
operator|->
name|disc
operator|=
literal|1
expr_stmt|;
comment|/* 	**	Now let the generic SCSI driver 	**	look for the SCSI devices on the bus .. 	*/
ifdef|#
directive|ifdef
name|__NetBSD__
name|np
operator|->
name|sc_link
operator|.
name|adapter_softc
operator|=
name|np
expr_stmt|;
name|np
operator|->
name|sc_link
operator|.
name|adapter_target
operator|=
name|np
operator|->
name|myaddr
expr_stmt|;
name|np
operator|->
name|sc_link
operator|.
name|openings
operator|=
literal|1
expr_stmt|;
else|#
directive|else
comment|/* !__NetBSD__ */
name|np
operator|->
name|sc_link
operator|.
name|adapter_unit
operator|=
name|unit
expr_stmt|;
name|np
operator|->
name|sc_link
operator|.
name|adapter_softc
operator|=
name|np
expr_stmt|;
name|np
operator|->
name|sc_link
operator|.
name|adapter_targ
operator|=
name|np
operator|->
name|myaddr
expr_stmt|;
name|np
operator|->
name|sc_link
operator|.
name|fordriver
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* !__NetBSD__ */
name|np
operator|->
name|sc_link
operator|.
name|adapter
operator|=
operator|&
name|ncr_switch
expr_stmt|;
name|np
operator|->
name|sc_link
operator|.
name|device
operator|=
operator|&
name|ncr_dev
expr_stmt|;
name|np
operator|->
name|sc_link
operator|.
name|flags
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|__NetBSD__
name|config_found
argument_list|(
name|self
argument_list|,
operator|&
name|np
operator|->
name|sc_link
argument_list|,
name|ncr_print
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* !__NetBSD__ */
if|#
directive|if
operator|(
name|__FreeBSD__
operator|>=
literal|2
operator|)
name|scbus
operator|=
name|scsi_alloc_bus
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|scbus
condition|)
return|return;
name|scbus
operator|->
name|adapter_link
operator|=
operator|&
name|np
operator|->
name|sc_link
expr_stmt|;
if|if
condition|(
name|np
operator|->
name|maxwide
condition|)
name|scbus
operator|->
name|maxtarg
operator|=
literal|15
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
block|{
name|unsigned
name|t_from
init|=
literal|0
decl_stmt|;
name|unsigned
name|t_to
init|=
name|scbus
operator|->
name|maxtarg
decl_stmt|;
name|unsigned
name|myaddr
init|=
name|np
operator|->
name|myaddr
decl_stmt|;
name|char
modifier|*
name|txt_and
init|=
literal|""
decl_stmt|;
name|printf
argument_list|(
literal|"%s scanning for targets "
argument_list|,
name|ncr_name
argument_list|(
name|np
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|t_from
operator|<
name|myaddr
condition|)
block|{
name|printf
argument_list|(
literal|"%d..%d "
argument_list|,
name|t_from
argument_list|,
name|myaddr
operator|-
literal|1
argument_list|)
expr_stmt|;
name|txt_and
operator|=
literal|"and "
expr_stmt|;
block|}
if|if
condition|(
name|myaddr
operator|<
name|t_to
condition|)
name|printf
argument_list|(
literal|"%s%d..%d "
argument_list|,
name|txt_and
argument_list|,
name|myaddr
operator|+
literal|1
argument_list|,
name|t_to
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"(V%d "
name|NCR_DATE
literal|")\n"
argument_list|,
name|NCR_VERSION
argument_list|)
expr_stmt|;
block|}
name|scsi_attachdevs
argument_list|(
name|scbus
argument_list|)
expr_stmt|;
name|scbus
operator|=
name|NULL
expr_stmt|;
comment|/* Upper-level SCSI code owns this now */
else|#
directive|else
name|scsi_attachdevs
argument_list|(
operator|&
name|np
operator|->
name|sc_link
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* !__FreeBSD__>= 2 */
endif|#
directive|endif
comment|/* !__NetBSD__ */
comment|/* 	**	start the timeout daemon 	*/
name|ncr_timeout
argument_list|(
name|np
argument_list|)
expr_stmt|;
name|np
operator|->
name|lasttime
operator|=
literal|0
expr_stmt|;
comment|/* 	**  use SIMPLE TAG messages by default 	*/
name|np
operator|->
name|order
operator|=
name|M_SIMPLE_TAG
expr_stmt|;
comment|/* 	**  Done. 	*/
return|return;
block|}
comment|/*========================================================== ** ** **	Process pending device interrupts. ** ** **========================================================== */
specifier|static
name|void
name|ncr_intr
parameter_list|(
name|vnp
parameter_list|)
name|void
modifier|*
name|vnp
decl_stmt|;
block|{
name|ncb_p
name|np
init|=
name|vnp
decl_stmt|;
name|int
name|oldspl
init|=
name|splbio
argument_list|()
decl_stmt|;
if|if
condition|(
name|DEBUG_FLAGS
operator|&
name|DEBUG_TINY
condition|)
name|printf
argument_list|(
literal|"["
argument_list|)
expr_stmt|;
if|if
condition|(
name|INB
argument_list|(
name|nc_istat
argument_list|)
operator|&
operator|(
name|INTF
operator||
name|SIP
operator||
name|DIP
operator|)
condition|)
block|{
comment|/* 		**	Repeat until no outstanding ints 		*/
do|do
block|{
name|ncr_exception
argument_list|(
name|np
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|INB
argument_list|(
name|nc_istat
argument_list|)
operator|&
operator|(
name|INTF
operator||
name|SIP
operator||
name|DIP
operator|)
condition|)
do|;
name|np
operator|->
name|ticks
operator|=
literal|100
expr_stmt|;
block|}
empty_stmt|;
if|if
condition|(
name|DEBUG_FLAGS
operator|&
name|DEBUG_TINY
condition|)
name|printf
argument_list|(
literal|"]\n"
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|oldspl
argument_list|)
expr_stmt|;
block|}
comment|/*========================================================== ** ** **	Start execution of a SCSI command. **	This is called from the generic SCSI driver. ** ** **========================================================== */
specifier|static
name|int32_t
name|ncr_start
parameter_list|(
name|struct
name|scsi_xfer
modifier|*
name|xp
parameter_list|)
block|{
name|ncb_p
name|np
init|=
operator|(
name|ncb_p
operator|)
name|xp
operator|->
name|sc_link
operator|->
name|adapter_softc
decl_stmt|;
name|struct
name|scsi_generic
modifier|*
name|cmd
init|=
name|xp
operator|->
name|cmd
decl_stmt|;
name|ccb_p
name|cp
decl_stmt|;
name|lcb_p
name|lp
decl_stmt|;
name|tcb_p
name|tp
init|=
operator|&
name|np
operator|->
name|target
index|[
name|xp
operator|->
name|sc_link
operator|->
name|target
index|]
decl_stmt|;
name|int
name|i
decl_stmt|,
name|oldspl
decl_stmt|,
name|segments
decl_stmt|,
name|flags
init|=
name|xp
operator|->
name|flags
decl_stmt|;
name|u_char
name|qidx
decl_stmt|,
name|nego
decl_stmt|,
name|idmsg
decl_stmt|,
modifier|*
name|msgptr
decl_stmt|;
name|u_long
name|msglen
decl_stmt|,
name|msglen2
decl_stmt|;
comment|/*--------------------------------------------- 	** 	**   Reset SCSI bus 	** 	**	Interrupt handler does the real work. 	** 	**--------------------------------------------- 	*/
if|if
condition|(
name|flags
operator|&
name|SCSI_RESET
condition|)
block|{
name|OUTB
argument_list|(
name|nc_scntl1
argument_list|,
name|CRST
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
return|return
operator|(
name|COMPLETE
operator|)
return|;
block|}
empty_stmt|;
comment|/*--------------------------------------------- 	** 	**      Some shortcuts ... 	** 	**--------------------------------------------- 	*/
if|if
condition|(
operator|(
name|xp
operator|->
name|sc_link
operator|->
name|target
operator|==
name|np
operator|->
name|myaddr
operator|)
operator|||
operator|(
name|xp
operator|->
name|sc_link
operator|->
name|target
operator|>=
name|MAX_TARGET
operator|)
operator|||
operator|(
name|xp
operator|->
name|sc_link
operator|->
name|lun
operator|>=
name|MAX_LUN
operator|)
operator|||
operator|(
name|flags
operator|&
name|SCSI_DATA_UIO
operator|)
condition|)
block|{
name|xp
operator|->
name|error
operator|=
name|XS_DRIVER_STUFFUP
expr_stmt|;
return|return
operator|(
name|COMPLETE
operator|)
return|;
block|}
empty_stmt|;
comment|/*--------------------------------------------- 	** 	**      Diskaccess to partial blocks? 	** 	**--------------------------------------------- 	*/
if|if
condition|(
operator|(
name|xp
operator|->
name|datalen
operator|&
literal|0x1ff
operator|)
operator|&&
operator|!
operator|(
name|tp
operator|->
name|inqdata
index|[
literal|0
index|]
operator|&
literal|0x1f
operator|)
condition|)
block|{
switch|switch
condition|(
name|cmd
operator|->
name|opcode
condition|)
block|{
case|case
literal|0x28
case|:
comment|/* READ_BIG  (10) */
case|case
literal|0xa8
case|:
comment|/* READ_HUGE (12) */
case|case
literal|0x2a
case|:
comment|/* WRITE_BIG (10) */
case|case
literal|0xaa
case|:
comment|/* WRITE_HUGE(12) */
name|PRINT_ADDR
argument_list|(
name|xp
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"access to partial disk block refused.\n"
argument_list|)
expr_stmt|;
name|xp
operator|->
name|error
operator|=
name|XS_DRIVER_STUFFUP
expr_stmt|;
return|return
operator|(
name|COMPLETE
operator|)
return|;
block|}
empty_stmt|;
block|}
empty_stmt|;
if|if
condition|(
operator|(
name|unsigned
operator|)
name|xp
operator|->
name|datalen
operator|>
literal|128
operator|*
literal|1024
operator|*
literal|1024
condition|)
block|{
name|PRINT_ADDR
argument_list|(
name|xp
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"trying to transfer %8x bytes, mem addr = %8x\n"
argument_list|,
name|xp
operator|->
name|datalen
argument_list|,
name|xp
operator|->
name|data
argument_list|)
expr_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|PRINT_ADDR
argument_list|(
name|xp
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"command: %2x ("
argument_list|,
name|cmd
operator|->
name|opcode
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|11
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|" %2x"
argument_list|,
name|cmd
operator|->
name|bytes
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|")\n"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|DEBUG_FLAGS
operator|&
name|DEBUG_TINY
condition|)
block|{
name|PRINT_ADDR
argument_list|(
name|xp
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"CMD=%x F=%x A=%x L=%x "
argument_list|,
name|cmd
operator|->
name|opcode
argument_list|,
operator|(
name|unsigned
operator|)
name|xp
operator|->
name|flags
argument_list|,
operator|(
name|unsigned
operator|)
name|xp
operator|->
name|data
argument_list|,
operator|(
name|unsigned
operator|)
name|xp
operator|->
name|datalen
argument_list|)
expr_stmt|;
block|}
comment|/*-------------------------------------------- 	** 	**   Sanity checks ... 	**	copied from Elischer's Adaptec driver. 	** 	**-------------------------------------------- 	*/
name|flags
operator|=
name|xp
operator|->
name|flags
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|INUSE
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"%s: ?INUSE?\n"
argument_list|,
name|ncr_name
argument_list|(
name|np
argument_list|)
argument_list|)
expr_stmt|;
name|xp
operator|->
name|flags
operator||=
name|INUSE
expr_stmt|;
block|}
empty_stmt|;
if|if
condition|(
name|flags
operator|&
name|ITSDONE
condition|)
block|{
name|printf
argument_list|(
literal|"%s: ?ITSDONE?\n"
argument_list|,
name|ncr_name
argument_list|(
name|np
argument_list|)
argument_list|)
expr_stmt|;
name|xp
operator|->
name|flags
operator|&=
operator|~
name|ITSDONE
expr_stmt|;
block|}
empty_stmt|;
if|if
condition|(
name|xp
operator|->
name|bp
condition|)
name|flags
operator||=
operator|(
name|SCSI_NOSLEEP
operator|)
expr_stmt|;
comment|/* just to be sure */
comment|/*--------------------------------------------------- 	** 	**	Assign a ccb / bind xp 	** 	**---------------------------------------------------- 	*/
name|oldspl
operator|=
name|splbio
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|cp
operator|=
name|ncr_get_ccb
argument_list|(
name|np
argument_list|,
name|flags
argument_list|,
name|xp
operator|->
name|sc_link
operator|->
name|target
argument_list|,
name|xp
operator|->
name|sc_link
operator|->
name|lun
argument_list|)
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"%s: no ccb.\n"
argument_list|,
name|ncr_name
argument_list|(
name|np
argument_list|)
argument_list|)
expr_stmt|;
name|xp
operator|->
name|error
operator|=
name|XS_DRIVER_STUFFUP
expr_stmt|;
name|splx
argument_list|(
name|oldspl
argument_list|)
expr_stmt|;
return|return
operator|(
name|TRY_AGAIN_LATER
operator|)
return|;
block|}
empty_stmt|;
name|cp
operator|->
name|xfer
operator|=
name|xp
expr_stmt|;
comment|/*--------------------------------------------------- 	** 	**	timestamp 	** 	**---------------------------------------------------- 	*/
name|bzero
argument_list|(
operator|&
name|cp
operator|->
name|phys
operator|.
name|header
operator|.
name|stamp
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|tstamp
argument_list|)
argument_list|)
expr_stmt|;
name|cp
operator|->
name|phys
operator|.
name|header
operator|.
name|stamp
operator|.
name|start
operator|=
name|time
expr_stmt|;
comment|/*---------------------------------------------------- 	** 	**	Get device quirks from a speciality table. 	** 	**	@GENSCSI@ 	**	This should be a part of the device table 	**	in "scsi_conf.c". 	** 	**---------------------------------------------------- 	*/
if|if
condition|(
name|tp
operator|->
name|quirks
operator|&
name|QUIRK_UPDATE
condition|)
block|{
ifdef|#
directive|ifdef
name|NEW_SCSICONF
name|tp
operator|->
name|quirks
operator|=
name|xp
operator|->
name|sc_link
operator|->
name|quirks
expr_stmt|;
else|#
directive|else
name|tp
operator|->
name|quirks
operator|=
name|ncr_lookup
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|tp
operator|->
name|inqdata
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|NCR_GETCC_WITHMSG
if|if
condition|(
name|tp
operator|->
name|quirks
condition|)
block|{
name|PRINT_ADDR
argument_list|(
name|xp
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"quirks=%x.\n"
argument_list|,
name|tp
operator|->
name|quirks
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
endif|#
directive|endif
block|}
empty_stmt|;
comment|/*--------------------------------------------------- 	** 	**	negotiation required? 	** 	**---------------------------------------------------- 	*/
name|nego
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|inqdata
index|[
literal|7
index|]
condition|)
block|{
comment|/* 		**	negotiate wide transfers ? 		*/
if|if
condition|(
operator|!
name|tp
operator|->
name|widedone
condition|)
block|{
if|if
condition|(
name|tp
operator|->
name|inqdata
index|[
literal|7
index|]
operator|&
name|INQ7_WIDE16
condition|)
block|{
name|nego
operator|=
name|NS_WIDE
expr_stmt|;
block|}
else|else
name|tp
operator|->
name|widedone
operator|=
literal|1
expr_stmt|;
block|}
empty_stmt|;
comment|/* 		**	negotiate synchronous transfers? 		*/
if|if
condition|(
operator|!
name|nego
operator|&&
operator|!
name|tp
operator|->
name|period
condition|)
block|{
if|if
condition|(
name|SCSI_NCR_MAX_SYNC
if|#
directive|if
name|defined
argument_list|(
name|CDROM_ASYNC
argument_list|)
operator|&&
operator|(
operator|(
name|tp
operator|->
name|inqdata
index|[
literal|0
index|]
operator|&
literal|0x1f
operator|)
operator|!=
literal|5
operator|)
endif|#
directive|endif
operator|&&
operator|(
name|tp
operator|->
name|inqdata
index|[
literal|7
index|]
operator|&
name|INQ7_SYNC
operator|)
condition|)
block|{
name|nego
operator|=
name|NS_SYNC
expr_stmt|;
block|}
else|else
block|{
name|tp
operator|->
name|period
operator|=
literal|0xffff
expr_stmt|;
name|tp
operator|->
name|sval
operator|=
literal|0xe0
expr_stmt|;
name|PRINT_ADDR
argument_list|(
name|xp
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"asynchronous.\n"
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
block|}
empty_stmt|;
block|}
empty_stmt|;
comment|/*--------------------------------------------------- 	** 	**	choose a new tag ... 	** 	**---------------------------------------------------- 	*/
if|if
condition|(
operator|(
name|lp
operator|=
name|tp
operator|->
name|lp
index|[
name|xp
operator|->
name|sc_link
operator|->
name|lun
index|]
operator|)
operator|&&
operator|(
name|lp
operator|->
name|usetags
operator|)
condition|)
block|{
comment|/* 		**	assign a tag to this ccb! 		*/
while|while
condition|(
operator|!
name|cp
operator|->
name|tag
condition|)
block|{
name|ccb_p
name|cp2
init|=
name|lp
operator|->
name|next_ccb
decl_stmt|;
name|lp
operator|->
name|lasttag
operator|=
name|lp
operator|->
name|lasttag
operator|%
literal|255
operator|+
literal|1
expr_stmt|;
while|while
condition|(
name|cp2
operator|&&
name|cp2
operator|->
name|tag
operator|!=
name|lp
operator|->
name|lasttag
condition|)
name|cp2
operator|=
name|cp2
operator|->
name|next_ccb
expr_stmt|;
if|if
condition|(
name|cp2
condition|)
continue|continue;
name|cp
operator|->
name|tag
operator|=
name|lp
operator|->
name|lasttag
expr_stmt|;
if|if
condition|(
name|DEBUG_FLAGS
operator|&
name|DEBUG_TAGS
condition|)
block|{
name|PRINT_ADDR
argument_list|(
name|xp
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"using tag #%d.\n"
argument_list|,
name|cp
operator|->
name|tag
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
block|}
empty_stmt|;
block|}
else|else
block|{
name|cp
operator|->
name|tag
operator|=
literal|0
expr_stmt|;
block|}
empty_stmt|;
comment|/*---------------------------------------------------- 	** 	**	Build the identify / tag / sdtr message 	** 	**---------------------------------------------------- 	*/
name|idmsg
operator|=
name|M_IDENTIFY
operator||
name|xp
operator|->
name|sc_link
operator|->
name|lun
expr_stmt|;
if|if
condition|(
operator|(
name|cp
operator|!=
operator|&
name|np
operator|->
name|ccb
operator|)
operator|&&
operator|(
name|np
operator|->
name|disc
operator|)
condition|)
name|idmsg
operator||=
literal|0x40
expr_stmt|;
name|msgptr
operator|=
name|cp
operator|->
name|scsi_smsg
expr_stmt|;
name|msglen
operator|=
literal|0
expr_stmt|;
name|msgptr
index|[
name|msglen
operator|++
index|]
operator|=
name|idmsg
expr_stmt|;
if|if
condition|(
name|cp
operator|->
name|tag
condition|)
block|{
name|char
name|tag
decl_stmt|;
name|tag
operator|=
name|np
operator|->
name|order
expr_stmt|;
if|if
condition|(
name|tag
operator|==
literal|0
condition|)
block|{
comment|/* 		**	Ordered write ops, unordered read ops. 		*/
switch|switch
condition|(
name|cmd
operator|->
name|opcode
condition|)
block|{
case|case
literal|0x08
case|:
comment|/* READ_SMALL (6) */
case|case
literal|0x28
case|:
comment|/* READ_BIG  (10) */
case|case
literal|0xa8
case|:
comment|/* READ_HUGE (12) */
name|tag
operator|=
name|M_SIMPLE_TAG
expr_stmt|;
break|break;
default|default:
name|tag
operator|=
name|M_ORDERED_TAG
expr_stmt|;
block|}
block|}
name|msgptr
index|[
name|msglen
operator|++
index|]
operator|=
name|tag
expr_stmt|;
name|msgptr
index|[
name|msglen
operator|++
index|]
operator|=
name|cp
operator|->
name|tag
expr_stmt|;
block|}
switch|switch
condition|(
name|nego
condition|)
block|{
case|case
name|NS_SYNC
case|:
name|msgptr
index|[
name|msglen
operator|++
index|]
operator|=
name|M_EXTENDED
expr_stmt|;
name|msgptr
index|[
name|msglen
operator|++
index|]
operator|=
literal|3
expr_stmt|;
name|msgptr
index|[
name|msglen
operator|++
index|]
operator|=
name|M_X_SYNC_REQ
expr_stmt|;
name|msgptr
index|[
name|msglen
operator|++
index|]
operator|=
name|tp
operator|->
name|minsync
expr_stmt|;
name|msgptr
index|[
name|msglen
operator|++
index|]
operator|=
name|tp
operator|->
name|maxoffs
expr_stmt|;
if|if
condition|(
name|DEBUG_FLAGS
operator|&
name|DEBUG_NEGO
condition|)
block|{
name|PRINT_ADDR
argument_list|(
name|cp
operator|->
name|xfer
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"sync msgout: "
argument_list|)
expr_stmt|;
name|ncr_show_msg
argument_list|(
operator|&
name|cp
operator|->
name|scsi_smsg
index|[
name|msglen
operator|-
literal|5
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|".\n"
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
break|break;
case|case
name|NS_WIDE
case|:
name|msgptr
index|[
name|msglen
operator|++
index|]
operator|=
name|M_EXTENDED
expr_stmt|;
name|msgptr
index|[
name|msglen
operator|++
index|]
operator|=
literal|2
expr_stmt|;
name|msgptr
index|[
name|msglen
operator|++
index|]
operator|=
name|M_X_WIDE_REQ
expr_stmt|;
name|msgptr
index|[
name|msglen
operator|++
index|]
operator|=
name|tp
operator|->
name|usrwide
expr_stmt|;
if|if
condition|(
name|DEBUG_FLAGS
operator|&
name|DEBUG_NEGO
condition|)
block|{
name|PRINT_ADDR
argument_list|(
name|cp
operator|->
name|xfer
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"wide msgout: "
argument_list|)
expr_stmt|;
name|ncr_show_msg
argument_list|(
operator|&
name|cp
operator|->
name|scsi_smsg
index|[
name|msglen
operator|-
literal|4
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|".\n"
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
break|break;
block|}
empty_stmt|;
comment|/*---------------------------------------------------- 	** 	**	Build the identify message for getcc. 	** 	**---------------------------------------------------- 	*/
name|cp
operator|->
name|scsi_smsg2
index|[
literal|0
index|]
operator|=
name|idmsg
expr_stmt|;
name|msglen2
operator|=
literal|1
expr_stmt|;
comment|/*---------------------------------------------------- 	** 	**	Build the data descriptors 	** 	**---------------------------------------------------- 	*/
name|segments
operator|=
name|ncr_scatter
argument_list|(
operator|&
name|cp
operator|->
name|phys
argument_list|,
operator|(
name|vm_offset_t
operator|)
name|xp
operator|->
name|data
argument_list|,
operator|(
name|vm_size_t
operator|)
name|xp
operator|->
name|datalen
argument_list|)
expr_stmt|;
if|if
condition|(
name|segments
operator|<
literal|0
condition|)
block|{
name|xp
operator|->
name|error
operator|=
name|XS_DRIVER_STUFFUP
expr_stmt|;
name|ncr_free_ccb
argument_list|(
name|np
argument_list|,
name|cp
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|oldspl
argument_list|)
expr_stmt|;
return|return
operator|(
name|COMPLETE
operator|)
return|;
block|}
empty_stmt|;
comment|/*---------------------------------------------------- 	** 	**	Set the SAVED_POINTER. 	** 	**---------------------------------------------------- 	*/
if|if
condition|(
name|flags
operator|&
name|SCSI_DATA_IN
condition|)
block|{
name|cp
operator|->
name|phys
operator|.
name|header
operator|.
name|savep
operator|=
name|NCB_SCRIPT_PHYS
argument_list|(
name|np
argument_list|,
name|data_in
argument_list|)
expr_stmt|;
name|cp
operator|->
name|phys
operator|.
name|header
operator|.
name|goalp
operator|=
name|cp
operator|->
name|phys
operator|.
name|header
operator|.
name|savep
operator|+
literal|20
operator|+
name|segments
operator|*
literal|16
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|flags
operator|&
name|SCSI_DATA_OUT
condition|)
block|{
name|cp
operator|->
name|phys
operator|.
name|header
operator|.
name|savep
operator|=
name|NCB_SCRIPT_PHYS
argument_list|(
name|np
argument_list|,
name|data_out
argument_list|)
expr_stmt|;
name|cp
operator|->
name|phys
operator|.
name|header
operator|.
name|goalp
operator|=
name|cp
operator|->
name|phys
operator|.
name|header
operator|.
name|savep
operator|+
literal|20
operator|+
name|segments
operator|*
literal|16
expr_stmt|;
block|}
else|else
block|{
name|cp
operator|->
name|phys
operator|.
name|header
operator|.
name|savep
operator|=
name|NCB_SCRIPT_PHYS
argument_list|(
name|np
argument_list|,
name|no_data
argument_list|)
expr_stmt|;
name|cp
operator|->
name|phys
operator|.
name|header
operator|.
name|goalp
operator|=
name|cp
operator|->
name|phys
operator|.
name|header
operator|.
name|savep
expr_stmt|;
block|}
empty_stmt|;
name|cp
operator|->
name|phys
operator|.
name|header
operator|.
name|lastp
operator|=
name|cp
operator|->
name|phys
operator|.
name|header
operator|.
name|savep
expr_stmt|;
comment|/*---------------------------------------------------- 	** 	**	fill in ccb 	** 	**---------------------------------------------------- 	** 	** 	**	physical -> virtual backlink 	**	Generic SCSI command 	*/
name|cp
operator|->
name|phys
operator|.
name|header
operator|.
name|cp
operator|=
name|cp
expr_stmt|;
comment|/* 	**	Startqueue 	*/
name|cp
operator|->
name|phys
operator|.
name|header
operator|.
name|launch
operator|.
name|l_paddr
operator|=
name|NCB_SCRIPT_PHYS
argument_list|(
name|np
argument_list|,
name|select
argument_list|)
expr_stmt|;
name|cp
operator|->
name|phys
operator|.
name|header
operator|.
name|launch
operator|.
name|l_cmd
operator|=
name|SCR_JUMP
expr_stmt|;
comment|/* 	**	select 	*/
name|cp
operator|->
name|phys
operator|.
name|select
operator|.
name|sel_id
operator|=
name|xp
operator|->
name|sc_link
operator|->
name|target
expr_stmt|;
name|cp
operator|->
name|phys
operator|.
name|select
operator|.
name|sel_scntl3
operator|=
name|tp
operator|->
name|wval
expr_stmt|;
name|cp
operator|->
name|phys
operator|.
name|select
operator|.
name|sel_sxfer
operator|=
name|tp
operator|->
name|sval
expr_stmt|;
comment|/* 	**	message 	*/
name|cp
operator|->
name|phys
operator|.
name|smsg
operator|.
name|addr
operator|=
name|CCB_PHYS
argument_list|(
name|cp
argument_list|,
name|scsi_smsg
argument_list|)
expr_stmt|;
name|cp
operator|->
name|phys
operator|.
name|smsg
operator|.
name|size
operator|=
name|msglen
expr_stmt|;
name|cp
operator|->
name|phys
operator|.
name|smsg2
operator|.
name|addr
operator|=
name|CCB_PHYS
argument_list|(
name|cp
argument_list|,
name|scsi_smsg2
argument_list|)
expr_stmt|;
name|cp
operator|->
name|phys
operator|.
name|smsg2
operator|.
name|size
operator|=
name|msglen2
expr_stmt|;
comment|/* 	**	command 	*/
name|cp
operator|->
name|phys
operator|.
name|cmd
operator|.
name|addr
operator|=
name|vtophys
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
name|cp
operator|->
name|phys
operator|.
name|cmd
operator|.
name|size
operator|=
name|xp
operator|->
name|cmdlen
expr_stmt|;
comment|/* 	**	sense command 	*/
name|cp
operator|->
name|phys
operator|.
name|scmd
operator|.
name|addr
operator|=
name|CCB_PHYS
argument_list|(
name|cp
argument_list|,
name|sensecmd
argument_list|)
expr_stmt|;
name|cp
operator|->
name|phys
operator|.
name|scmd
operator|.
name|size
operator|=
literal|6
expr_stmt|;
comment|/* 	**	patch requested size into sense command 	*/
name|cp
operator|->
name|sensecmd
index|[
literal|0
index|]
operator|=
literal|0x03
expr_stmt|;
name|cp
operator|->
name|sensecmd
index|[
literal|1
index|]
operator|=
name|xp
operator|->
name|sc_link
operator|->
name|lun
operator|<<
literal|5
expr_stmt|;
name|cp
operator|->
name|sensecmd
index|[
literal|4
index|]
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_sense_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|xp
operator|->
name|req_sense_length
condition|)
name|cp
operator|->
name|sensecmd
index|[
literal|4
index|]
operator|=
name|xp
operator|->
name|req_sense_length
expr_stmt|;
comment|/* 	**	sense data 	*/
name|cp
operator|->
name|phys
operator|.
name|sense
operator|.
name|addr
operator|=
name|vtophys
argument_list|(
operator|&
name|cp
operator|->
name|xfer
operator|->
name|sense
argument_list|)
expr_stmt|;
name|cp
operator|->
name|phys
operator|.
name|sense
operator|.
name|size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_sense_data
argument_list|)
expr_stmt|;
comment|/* 	**	status 	*/
name|cp
operator|->
name|actualquirks
operator|=
name|tp
operator|->
name|quirks
expr_stmt|;
name|cp
operator|->
name|host_status
operator|=
name|nego
condition|?
name|HS_NEGOTIATE
else|:
name|HS_BUSY
expr_stmt|;
name|cp
operator|->
name|scsi_status
operator|=
name|S_ILLEGAL
expr_stmt|;
name|cp
operator|->
name|parity_status
operator|=
literal|0
expr_stmt|;
name|cp
operator|->
name|xerr_status
operator|=
name|XE_OK
expr_stmt|;
name|cp
operator|->
name|sync_status
operator|=
name|tp
operator|->
name|sval
expr_stmt|;
name|cp
operator|->
name|nego_status
operator|=
name|nego
expr_stmt|;
name|cp
operator|->
name|wide_status
operator|=
name|tp
operator|->
name|wval
expr_stmt|;
comment|/*---------------------------------------------------- 	** 	**	Critical region: start this job. 	** 	**---------------------------------------------------- 	*/
comment|/* 	**	reselect pattern and activate this job. 	*/
name|cp
operator|->
name|jump_ccb
operator|.
name|l_cmd
operator|=
operator|(
name|SCR_JUMP
operator|^
name|IFFALSE
argument_list|(
name|DATA
argument_list|(
name|cp
operator|->
name|tag
argument_list|)
argument_list|)
operator|)
expr_stmt|;
name|cp
operator|->
name|tlimit
operator|=
name|time
operator|.
name|tv_sec
operator|+
name|xp
operator|->
name|timeout
operator|/
literal|1000
operator|+
literal|2
expr_stmt|;
name|cp
operator|->
name|magic
operator|=
name|CCB_MAGIC
expr_stmt|;
comment|/* 	**	insert into start queue. 	*/
name|qidx
operator|=
name|np
operator|->
name|squeueput
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|qidx
operator|>=
name|MAX_START
condition|)
name|qidx
operator|=
literal|0
expr_stmt|;
name|np
operator|->
name|squeue
index|[
name|qidx
index|]
operator|=
name|NCB_SCRIPT_PHYS
argument_list|(
name|np
argument_list|,
name|idle
argument_list|)
expr_stmt|;
name|np
operator|->
name|squeue
index|[
name|np
operator|->
name|squeueput
index|]
operator|=
name|CCB_PHYS
argument_list|(
name|cp
argument_list|,
name|phys
argument_list|)
expr_stmt|;
name|np
operator|->
name|squeueput
operator|=
name|qidx
expr_stmt|;
if|if
condition|(
name|DEBUG_FLAGS
operator|&
name|DEBUG_QUEUE
condition|)
name|printf
argument_list|(
literal|"%s: queuepos=%d tryoffset=%d.\n"
argument_list|,
name|ncr_name
argument_list|(
name|np
argument_list|)
argument_list|,
name|np
operator|->
name|squeueput
argument_list|,
call|(
name|unsigned
call|)
argument_list|(
name|np
operator|->
name|script
operator|->
name|startpos
index|[
literal|0
index|]
operator|-
operator|(
name|NCB_SCRIPT_PHYS
argument_list|(
name|np
argument_list|,
name|tryloop
argument_list|)
operator|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	**	Script processor may be waiting for reselect. 	**	Wake it up. 	*/
name|OUTB
argument_list|(
name|nc_istat
argument_list|,
name|SIGP
argument_list|)
expr_stmt|;
comment|/* 	**	and reenable interrupts 	*/
name|splx
argument_list|(
name|oldspl
argument_list|)
expr_stmt|;
comment|/* 	**	If interrupts are enabled, return now. 	**	Command is successfully queued. 	*/
ifdef|#
directive|ifdef
name|__NetBSD__
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|SCSI_POLL
operator|)
condition|)
block|{
else|#
directive|else
comment|/* !__NetBSD__ */
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|SCSI_NOMASK
operator|)
condition|)
block|{
endif|#
directive|endif
comment|/* __NetBSD__ */
if|if
condition|(
name|np
operator|->
name|lasttime
condition|)
block|{
if|if
condition|(
name|DEBUG_FLAGS
operator|&
name|DEBUG_TINY
condition|)
name|printf
argument_list|(
literal|"Q"
argument_list|)
expr_stmt|;
return|return
operator|(
name|SUCCESSFULLY_QUEUED
operator|)
return|;
block|}
empty_stmt|;
block|}
empty_stmt|;
comment|/*---------------------------------------------------- 	** 	**	Interrupts not yet enabled - have to poll. 	** 	**---------------------------------------------------- 	*/
if|if
condition|(
name|DEBUG_FLAGS
operator|&
name|DEBUG_POLL
condition|)
name|printf
argument_list|(
literal|"P"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|xp
operator|->
name|timeout
init|;
name|i
operator|&&
operator|!
operator|(
name|xp
operator|->
name|flags
operator|&
name|ITSDONE
operator|)
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
operator|(
name|DEBUG_FLAGS
operator|&
name|DEBUG_POLL
operator|)
operator|&&
operator|(
name|cp
operator|->
name|host_status
operator|)
condition|)
name|printf
argument_list|(
literal|"%c"
argument_list|,
operator|(
name|cp
operator|->
name|host_status
operator|&
literal|0xf
operator|)
operator|+
literal|'0'
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
name|ncr_exception
argument_list|(
name|np
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
comment|/* 	**	Abort if command not done. 	*/
if|if
condition|(
operator|!
operator|(
name|xp
operator|->
name|flags
operator|&
name|ITSDONE
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"%s: aborting job ...\n"
argument_list|,
name|ncr_name
argument_list|(
name|np
argument_list|)
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
name|nc_istat
argument_list|,
name|CABRT
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|100000
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
name|nc_istat
argument_list|,
name|SIGP
argument_list|)
expr_stmt|;
name|ncr_exception
argument_list|(
name|np
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
if|if
condition|(
operator|!
operator|(
name|xp
operator|->
name|flags
operator|&
name|ITSDONE
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"%s: abortion failed at %x.\n"
argument_list|,
name|ncr_name
argument_list|(
name|np
argument_list|)
argument_list|,
operator|(
name|unsigned
operator|)
name|INL
argument_list|(
name|nc_dsp
argument_list|)
argument_list|)
expr_stmt|;
name|ncr_init
argument_list|(
name|np
argument_list|,
literal|"timeout"
argument_list|,
name|HS_TIMEOUT
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
if|if
condition|(
operator|!
operator|(
name|xp
operator|->
name|flags
operator|&
name|ITSDONE
operator|)
condition|)
block|{
name|cp
operator|->
name|host_status
operator|=
name|HS_SEL_TIMEOUT
expr_stmt|;
name|ncr_complete
argument_list|(
name|np
argument_list|,
name|cp
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
if|if
condition|(
name|DEBUG_FLAGS
operator|&
name|DEBUG_RESULT
condition|)
block|{
name|printf
argument_list|(
literal|"%s: result: %x %x.\n"
argument_list|,
name|ncr_name
argument_list|(
name|np
argument_list|)
argument_list|,
name|cp
operator|->
name|host_status
argument_list|,
name|cp
operator|->
name|scsi_status
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
ifdef|#
directive|ifdef
name|__NetBSD__
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|SCSI_POLL
operator|)
condition|)
else|#
directive|else
comment|/* !__NetBSD__ */
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|SCSI_NOMASK
operator|)
condition|)
endif|#
directive|endif
comment|/* __NetBSD__ */
return|return
operator|(
name|SUCCESSFULLY_QUEUED
operator|)
return|;
switch|switch
condition|(
name|xp
operator|->
name|error
condition|)
block|{
case|case
literal|0
case|:
return|return
operator|(
name|COMPLETE
operator|)
return|;
case|case
name|XS_BUSY
case|:
return|return
operator|(
name|TRY_AGAIN_LATER
operator|)
return|;
block|}
empty_stmt|;
return|return
operator|(
name|COMPLETE
operator|)
return|;
block|}
comment|/*========================================================== ** ** **	Complete execution of a SCSI command. **	Signal completion to the generic SCSI driver. ** ** **========================================================== */
name|void
name|ncr_complete
parameter_list|(
name|ncb_p
name|np
parameter_list|,
name|ccb_p
name|cp
parameter_list|)
block|{
name|struct
name|scsi_xfer
modifier|*
name|xp
decl_stmt|;
name|tcb_p
name|tp
decl_stmt|;
name|lcb_p
name|lp
decl_stmt|;
comment|/* 	**	Sanity check 	*/
if|if
condition|(
operator|!
name|cp
operator|||
operator|(
name|cp
operator|->
name|magic
operator|!=
name|CCB_MAGIC
operator|)
operator|||
operator|!
name|cp
operator|->
name|xfer
condition|)
return|return;
name|cp
operator|->
name|magic
operator|=
literal|1
expr_stmt|;
name|cp
operator|->
name|tlimit
operator|=
literal|0
expr_stmt|;
comment|/* 	**	No Reselect anymore. 	*/
name|cp
operator|->
name|jump_ccb
operator|.
name|l_cmd
operator|=
operator|(
name|SCR_JUMP
operator|)
expr_stmt|;
comment|/* 	**	No starting. 	*/
name|cp
operator|->
name|phys
operator|.
name|header
operator|.
name|launch
operator|.
name|l_paddr
operator|=
name|NCB_SCRIPT_PHYS
argument_list|(
name|np
argument_list|,
name|idle
argument_list|)
expr_stmt|;
comment|/* 	**	timestamp 	*/
name|ncb_profile
argument_list|(
name|np
argument_list|,
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|DEBUG_FLAGS
operator|&
name|DEBUG_TINY
condition|)
name|printf
argument_list|(
literal|"CCB=%x STAT=%x/%x\n"
argument_list|,
operator|(
name|unsigned
operator|)
name|cp
operator|&
literal|0xfff
argument_list|,
name|cp
operator|->
name|host_status
argument_list|,
name|cp
operator|->
name|scsi_status
argument_list|)
expr_stmt|;
name|xp
operator|=
name|cp
operator|->
name|xfer
expr_stmt|;
name|cp
operator|->
name|xfer
operator|=
name|NULL
expr_stmt|;
name|tp
operator|=
operator|&
name|np
operator|->
name|target
index|[
name|xp
operator|->
name|sc_link
operator|->
name|target
index|]
expr_stmt|;
name|lp
operator|=
name|tp
operator|->
name|lp
index|[
name|xp
operator|->
name|sc_link
operator|->
name|lun
index|]
expr_stmt|;
comment|/* 	**	Check for parity errors. 	*/
if|if
condition|(
name|cp
operator|->
name|parity_status
condition|)
block|{
name|PRINT_ADDR
argument_list|(
name|xp
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%d parity error(s), fallback.\n"
argument_list|,
name|cp
operator|->
name|parity_status
argument_list|)
expr_stmt|;
comment|/* 		**	fallback to asynch transfer. 		*/
name|tp
operator|->
name|usrsync
operator|=
literal|255
expr_stmt|;
name|tp
operator|->
name|period
operator|=
literal|0
expr_stmt|;
block|}
empty_stmt|;
comment|/* 	**	Check for extended errors. 	*/
if|if
condition|(
name|cp
operator|->
name|xerr_status
operator|!=
name|XE_OK
condition|)
block|{
name|PRINT_ADDR
argument_list|(
name|xp
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|cp
operator|->
name|xerr_status
condition|)
block|{
case|case
name|XE_EXTRA_DATA
case|:
name|printf
argument_list|(
literal|"extraneous data discarded.\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|XE_BAD_PHASE
case|:
name|printf
argument_list|(
literal|"illegal scsi phase (4/5).\n"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"extended error %d.\n"
argument_list|,
name|cp
operator|->
name|xerr_status
argument_list|)
expr_stmt|;
break|break;
block|}
empty_stmt|;
if|if
condition|(
name|cp
operator|->
name|host_status
operator|==
name|HS_COMPLETE
condition|)
name|cp
operator|->
name|host_status
operator|=
name|HS_FAIL
expr_stmt|;
block|}
empty_stmt|;
comment|/* 	**	Check the status. 	*/
ifdef|#
directive|ifdef
name|__NetBSD__
if|if
condition|(
name|xp
operator|->
name|error
operator|!=
name|XS_NOERROR
condition|)
block|{
comment|/*                               **      Don't override the error value.                 */
block|}
elseif|else
endif|#
directive|endif
comment|/* __NetBSD__ */
if|if
condition|(
operator|(
name|cp
operator|->
name|host_status
operator|==
name|HS_COMPLETE
operator|)
operator|&&
operator|(
name|cp
operator|->
name|scsi_status
operator|==
name|S_GOOD
operator|)
condition|)
block|{
comment|/* 		**	All went well. 		*/
name|xp
operator|->
name|resid
operator|=
literal|0
expr_stmt|;
comment|/* 		** if (cp->phys.header.lastp != cp->phys.header.goalp)... 		** 		**	@RESID@ 		**	Could dig out the correct value for resid, 		**	but it would be quite complicated. 		** 		**	The ah1542.c driver sets it to 0 too ... 		*/
comment|/* 		**	Try to assign a ccb to this nexus 		*/
name|ncr_alloc_ccb
argument_list|(
name|np
argument_list|,
name|xp
operator|->
name|sc_link
operator|->
name|target
argument_list|,
name|xp
operator|->
name|sc_link
operator|->
name|lun
argument_list|)
expr_stmt|;
comment|/* 		**	On inquire cmd (0x12) save some data. 		*/
if|if
condition|(
name|xp
operator|->
name|cmd
operator|->
name|opcode
operator|==
literal|0x12
operator|&&
name|xp
operator|->
name|sc_link
operator|->
name|lun
operator|==
literal|0
condition|)
block|{
name|bcopy
argument_list|(
name|xp
operator|->
name|data
argument_list|,
operator|&
name|tp
operator|->
name|inqdata
argument_list|,
sizeof|sizeof
argument_list|(
name|tp
operator|->
name|inqdata
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 			**	set number of tags 			*/
name|ncr_setmaxtags
argument_list|(
name|tp
argument_list|,
name|tp
operator|->
name|usrtags
argument_list|)
expr_stmt|;
comment|/* 			**	prepare negotiation of synch and wide. 			*/
name|ncr_negotiate
argument_list|(
name|np
argument_list|,
name|tp
argument_list|)
expr_stmt|;
comment|/* 			**	force quirks update before next command start 			*/
name|tp
operator|->
name|quirks
operator||=
name|QUIRK_UPDATE
expr_stmt|;
block|}
empty_stmt|;
comment|/* 		**	Announce changes to the generic driver 		*/
if|if
condition|(
name|lp
condition|)
block|{
name|ncr_settags
argument_list|(
name|tp
argument_list|,
name|lp
argument_list|)
expr_stmt|;
if|if
condition|(
name|lp
operator|->
name|reqlink
operator|!=
name|lp
operator|->
name|actlink
condition|)
name|ncr_opennings
argument_list|(
name|np
argument_list|,
name|lp
argument_list|,
name|xp
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
name|tp
operator|->
name|bytes
operator|+=
name|xp
operator|->
name|datalen
expr_stmt|;
name|tp
operator|->
name|transfers
operator|++
expr_stmt|;
ifndef|#
directive|ifndef
name|__NetBSD__
block|}
elseif|else
if|if
condition|(
name|xp
operator|->
name|flags
operator|&
name|SCSI_ERR_OK
condition|)
block|{
comment|/* 		**   Not correct, but errors expected. 		*/
name|xp
operator|->
name|resid
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* !__NetBSD__ */
block|}
elseif|else
if|if
condition|(
operator|(
name|cp
operator|->
name|host_status
operator|==
name|HS_COMPLETE
operator|)
operator|&&
operator|(
name|cp
operator|->
name|scsi_status
operator|==
operator|(
name|S_SENSE
operator||
name|S_GOOD
operator|)
operator|)
condition|)
block|{
comment|/* 		**   Check condition code 		*/
name|xp
operator|->
name|error
operator|=
name|XS_SENSE
expr_stmt|;
if|if
condition|(
name|DEBUG_FLAGS
operator|&
operator|(
name|DEBUG_RESULT
operator||
name|DEBUG_TINY
operator|)
condition|)
block|{
name|u_char
modifier|*
name|p
init|=
operator|(
name|u_char
operator|*
operator|)
operator|&
name|xp
operator|->
name|sense
decl_stmt|;
name|int
name|i
decl_stmt|;
name|printf
argument_list|(
literal|"\n%s: sense data:"
argument_list|,
name|ncr_name
argument_list|(
name|np
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|14
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|" %x"
argument_list|,
operator|*
name|p
operator|++
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|".\n"
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|cp
operator|->
name|host_status
operator|==
name|HS_COMPLETE
operator|)
operator|&&
operator|(
name|cp
operator|->
name|scsi_status
operator|==
name|S_BUSY
operator|)
condition|)
block|{
comment|/* 		**   Target is busy. 		*/
name|xp
operator|->
name|error
operator|=
name|XS_BUSY
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cp
operator|->
name|host_status
operator|==
name|HS_SEL_TIMEOUT
condition|)
block|{
comment|/* 		**   Device failed selection 		*/
name|xp
operator|->
name|error
operator|=
name|XS_SELTIMEOUT
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cp
operator|->
name|host_status
operator|==
name|HS_TIMEOUT
condition|)
block|{
comment|/* 		**   No response 		*/
name|xp
operator|->
name|error
operator|=
name|XS_TIMEOUT
expr_stmt|;
block|}
else|else
block|{
comment|/* 		**  Other protocol messes 		*/
name|PRINT_ADDR
argument_list|(
name|xp
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"COMMAND FAILED (%x %x) @%x.\n"
argument_list|,
name|cp
operator|->
name|host_status
argument_list|,
name|cp
operator|->
name|scsi_status
argument_list|,
operator|(
name|unsigned
operator|)
name|cp
argument_list|)
expr_stmt|;
name|xp
operator|->
name|error
operator|=
name|XS_TIMEOUT
expr_stmt|;
block|}
name|xp
operator|->
name|flags
operator||=
name|ITSDONE
expr_stmt|;
comment|/* 	**	trace output 	*/
if|if
condition|(
name|tp
operator|->
name|usrflag
operator|&
name|UF_TRACE
condition|)
block|{
name|u_char
modifier|*
name|p
decl_stmt|;
name|int
name|i
decl_stmt|;
name|PRINT_ADDR
argument_list|(
name|xp
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" CMD:"
argument_list|)
expr_stmt|;
name|p
operator|=
operator|(
name|u_char
operator|*
operator|)
operator|&
name|xp
operator|->
name|cmd
operator|->
name|opcode
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|xp
operator|->
name|cmdlen
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|" %x"
argument_list|,
operator|*
name|p
operator|++
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|->
name|host_status
operator|==
name|HS_COMPLETE
condition|)
block|{
switch|switch
condition|(
name|cp
operator|->
name|scsi_status
condition|)
block|{
case|case
name|S_GOOD
case|:
name|printf
argument_list|(
literal|"  GOOD"
argument_list|)
expr_stmt|;
break|break;
case|case
name|S_CHECK_COND
case|:
name|printf
argument_list|(
literal|"  SENSE:"
argument_list|)
expr_stmt|;
name|p
operator|=
operator|(
name|u_char
operator|*
operator|)
operator|&
name|xp
operator|->
name|sense
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|xp
operator|->
name|req_sense_length
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|" %x"
argument_list|,
operator|*
name|p
operator|++
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"  STAT: %x\n"
argument_list|,
name|cp
operator|->
name|scsi_status
argument_list|)
expr_stmt|;
break|break;
block|}
empty_stmt|;
block|}
else|else
name|printf
argument_list|(
literal|"  HOSTERROR: %x"
argument_list|,
name|cp
operator|->
name|host_status
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
comment|/* 	**	Free this ccb 	*/
name|ncr_free_ccb
argument_list|(
name|np
argument_list|,
name|cp
argument_list|,
name|xp
operator|->
name|flags
argument_list|)
expr_stmt|;
comment|/* 	**	signal completion to generic driver. 	*/
name|scsi_done
argument_list|(
name|xp
argument_list|)
expr_stmt|;
block|}
comment|/*========================================================== ** ** **	Signal all (or one) control block done. ** ** **========================================================== */
name|void
name|ncr_wakeup
parameter_list|(
name|ncb_p
name|np
parameter_list|,
name|u_long
name|code
parameter_list|)
block|{
comment|/* 	**	Starting at the default ccb and following 	**	the links, complete all jobs with a 	**	host_status greater than "disconnect". 	** 	**	If the "code" parameter is not zero, 	**	complete all jobs that are not IDLE. 	*/
name|ccb_p
name|cp
init|=
operator|&
name|np
operator|->
name|ccb
decl_stmt|;
while|while
condition|(
name|cp
condition|)
block|{
switch|switch
condition|(
name|cp
operator|->
name|host_status
condition|)
block|{
case|case
name|HS_IDLE
case|:
break|break;
case|case
name|HS_DISCONNECT
case|:
if|if
condition|(
name|DEBUG_FLAGS
operator|&
name|DEBUG_TINY
condition|)
name|printf
argument_list|(
literal|"D"
argument_list|)
expr_stmt|;
comment|/* fall through */
case|case
name|HS_BUSY
case|:
case|case
name|HS_NEGOTIATE
case|:
if|if
condition|(
operator|!
name|code
condition|)
break|break;
name|cp
operator|->
name|host_status
operator|=
name|code
expr_stmt|;
comment|/* fall through */
default|default:
name|ncr_complete
argument_list|(
name|np
argument_list|,
name|cp
argument_list|)
expr_stmt|;
break|break;
block|}
empty_stmt|;
name|cp
operator|=
name|cp
operator|->
name|link_ccb
expr_stmt|;
block|}
empty_stmt|;
block|}
comment|/*========================================================== ** ** **	Start NCR chip. ** ** **========================================================== */
name|void
name|ncr_init
parameter_list|(
name|ncb_p
name|np
parameter_list|,
name|char
modifier|*
name|msg
parameter_list|,
name|u_long
name|code
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|u_long
name|usrsync
decl_stmt|;
name|u_char
name|usrwide
decl_stmt|;
name|u_char
name|burstlen
decl_stmt|;
comment|/* 	**	Reset chip. 	*/
name|OUTB
argument_list|(
name|nc_istat
argument_list|,
name|SRST
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
comment|/* 	**	Message. 	*/
if|if
condition|(
name|msg
condition|)
name|printf
argument_list|(
literal|"%s: restart (%s).\n"
argument_list|,
name|ncr_name
argument_list|(
name|np
argument_list|)
argument_list|,
name|msg
argument_list|)
expr_stmt|;
comment|/* 	**	Clear Start Queue 	*/
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_START
condition|;
name|i
operator|++
control|)
name|np
operator|->
name|squeue
index|[
name|i
index|]
operator|=
name|NCB_SCRIPT_PHYS
argument_list|(
name|np
argument_list|,
name|idle
argument_list|)
expr_stmt|;
comment|/* 	**	Start at first entry. 	*/
name|np
operator|->
name|squeueput
operator|=
literal|0
expr_stmt|;
name|np
operator|->
name|script
operator|->
name|startpos
index|[
literal|0
index|]
operator|=
name|NCB_SCRIPT_PHYS
argument_list|(
name|np
argument_list|,
name|tryloop
argument_list|)
expr_stmt|;
name|np
operator|->
name|script
operator|->
name|start0
index|[
literal|0
index|]
operator|=
name|SCR_INT
operator|^
name|IFFALSE
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* 	**	Wakeup all pending jobs. 	*/
name|ncr_wakeup
argument_list|(
name|np
argument_list|,
name|code
argument_list|)
expr_stmt|;
comment|/* 	**	Init chip. 	*/
name|burstlen
operator|=
literal|0xc0
expr_stmt|;
comment|/* XXX 53c875 needs code change to   */
comment|/*     be able to use larger bursts  */
name|OUTB
argument_list|(
name|nc_istat
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
comment|/*  Remove Reset, abort ...	     */
name|OUTB
argument_list|(
name|nc_scntl0
argument_list|,
literal|0xca
argument_list|)
expr_stmt|;
comment|/*  full arb., ena parity, par->ATN  */
name|OUTB
argument_list|(
name|nc_scntl1
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
comment|/*  odd parity, and remove CRST!!    */
name|OUTB
argument_list|(
name|nc_scntl3
argument_list|,
name|np
operator|->
name|rv_scntl3
argument_list|)
expr_stmt|;
comment|/*  timing prescaler		     */
name|OUTB
argument_list|(
name|nc_scid
argument_list|,
name|RRE
operator||
name|np
operator|->
name|myaddr
argument_list|)
expr_stmt|;
comment|/*  host adapter SCSI address       */
name|OUTW
argument_list|(
name|nc_respid
argument_list|,
literal|1ul
operator|<<
name|np
operator|->
name|myaddr
argument_list|)
expr_stmt|;
comment|/*  id to respond to		     */
name|OUTB
argument_list|(
name|nc_istat
argument_list|,
name|SIGP
argument_list|)
expr_stmt|;
comment|/*  Signal Process		     */
name|OUTB
argument_list|(
name|nc_dmode
argument_list|,
name|burstlen
argument_list|)
expr_stmt|;
comment|/*  Burst length = 2 .. 16 transfers */
name|OUTB
argument_list|(
name|nc_dcntl
argument_list|,
name|NOCOM
argument_list|)
expr_stmt|;
comment|/*  no single step mode, protect SFBR*/
name|OUTB
argument_list|(
name|nc_ctest4
argument_list|,
literal|0x08
argument_list|)
expr_stmt|;
comment|/*  enable master parity checking    */
name|OUTB
argument_list|(
name|nc_stest2
argument_list|,
name|EXT
argument_list|)
expr_stmt|;
comment|/*  Extended Sreq/Sack filtering     */
name|OUTB
argument_list|(
name|nc_stest3
argument_list|,
name|TE
argument_list|)
expr_stmt|;
comment|/*  TolerANT enable		     */
name|OUTB
argument_list|(
name|nc_stime0
argument_list|,
literal|0x0b
argument_list|)
expr_stmt|;
comment|/*  HTH = disabled, STO = 0.1 sec.   */
comment|/* 	**	Reinitialize usrsync. 	**	Have to renegotiate synch mode. 	*/
name|usrsync
operator|=
literal|255
expr_stmt|;
if|if
condition|(
name|SCSI_NCR_MAX_SYNC
condition|)
block|{
name|u_long
name|period
decl_stmt|;
name|period
operator|=
literal|1000000
operator|/
name|SCSI_NCR_MAX_SYNC
expr_stmt|;
comment|/* ns = 10e6 / kHz */
if|if
condition|(
name|period
operator|<=
literal|11
operator|*
name|np
operator|->
name|ns_sync
condition|)
block|{
if|if
condition|(
name|period
operator|<
literal|4
operator|*
name|np
operator|->
name|ns_sync
condition|)
name|usrsync
operator|=
name|np
operator|->
name|ns_sync
expr_stmt|;
else|else
name|usrsync
operator|=
name|period
operator|/
literal|4
expr_stmt|;
block|}
empty_stmt|;
block|}
empty_stmt|;
comment|/* 	**	Reinitialize usrwide. 	**	Have to renegotiate wide mode. 	*/
name|usrwide
operator|=
operator|(
name|SCSI_NCR_MAX_WIDE
operator|)
expr_stmt|;
if|if
condition|(
name|usrwide
operator|>
name|np
operator|->
name|maxwide
condition|)
name|usrwide
operator|=
name|np
operator|->
name|maxwide
expr_stmt|;
comment|/* 	**	Disable disconnects. 	*/
name|np
operator|->
name|disc
operator|=
literal|0
expr_stmt|;
comment|/* 	**	Fill in target structure. 	*/
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_TARGET
condition|;
name|i
operator|++
control|)
block|{
name|tcb_p
name|tp
init|=
operator|&
name|np
operator|->
name|target
index|[
name|i
index|]
decl_stmt|;
name|tp
operator|->
name|sval
operator|=
literal|0
expr_stmt|;
name|tp
operator|->
name|wval
operator|=
name|np
operator|->
name|rv_scntl3
expr_stmt|;
name|tp
operator|->
name|usrsync
operator|=
name|usrsync
expr_stmt|;
name|tp
operator|->
name|usrwide
operator|=
name|usrwide
expr_stmt|;
name|ncr_negotiate
argument_list|(
name|np
argument_list|,
name|tp
argument_list|)
expr_stmt|;
block|}
comment|/* 	**      enable ints 	*/
name|OUTW
argument_list|(
name|nc_sien
argument_list|,
name|STO
operator||
name|HTH
operator||
name|MA
operator||
name|SGE
operator||
name|UDC
operator||
name|RST
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
name|nc_dien
argument_list|,
name|MDPE
operator||
name|BF
operator||
name|ABRT
operator||
name|SSI
operator||
name|SIR
operator||
name|IID
argument_list|)
expr_stmt|;
comment|/* 	**    Start script processor. 	*/
name|OUTL
argument_list|(
name|nc_dsp
argument_list|,
name|NCB_SCRIPT_PHYS
argument_list|(
name|np
argument_list|,
name|start
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/*========================================================== ** **	Prepare the negotiation values for wide and **	synchronous transfers. ** **========================================================== */
specifier|static
name|void
name|ncr_negotiate
parameter_list|(
name|struct
name|ncb
modifier|*
name|np
parameter_list|,
name|struct
name|tcb
modifier|*
name|tp
parameter_list|)
block|{
comment|/* 	**	minsync unit is 4ns ! 	*/
name|u_long
name|minsync
init|=
name|tp
operator|->
name|usrsync
decl_stmt|;
if|if
condition|(
name|minsync
operator|<
literal|25
condition|)
name|minsync
operator|=
literal|25
expr_stmt|;
comment|/* 	**	if not scsi 2 	**	don't believe FAST! 	*/
if|if
condition|(
operator|(
name|minsync
operator|<
literal|50
operator|)
operator|&&
operator|(
name|tp
operator|->
name|inqdata
index|[
literal|2
index|]
operator|&
literal|0x0f
operator|)
operator|<
literal|2
condition|)
name|minsync
operator|=
literal|50
expr_stmt|;
comment|/* 	**	our limit .. 	*/
if|if
condition|(
name|minsync
operator|<
name|np
operator|->
name|ns_sync
condition|)
name|minsync
operator|=
name|np
operator|->
name|ns_sync
expr_stmt|;
comment|/* 	**	divider limit 	*/
if|if
condition|(
name|minsync
operator|>
operator|(
name|np
operator|->
name|ns_sync
operator|*
literal|11
operator|)
operator|/
literal|4
condition|)
name|minsync
operator|=
literal|255
expr_stmt|;
name|tp
operator|->
name|minsync
operator|=
name|minsync
expr_stmt|;
name|tp
operator|->
name|maxoffs
operator|=
operator|(
name|minsync
operator|<
literal|255
condition|?
name|np
operator|->
name|maxoffs
else|:
literal|0
operator|)
expr_stmt|;
comment|/* 	**	period=0: has to negotiate sync transfer 	*/
name|tp
operator|->
name|period
operator|=
literal|0
expr_stmt|;
comment|/* 	**	widedone=0: has to negotiate wide transfer 	*/
name|tp
operator|->
name|widedone
operator|=
literal|0
expr_stmt|;
block|}
comment|/*========================================================== ** **	Switch sync mode for current job and it's target ** **========================================================== */
specifier|static
name|void
name|ncr_setsync
parameter_list|(
name|ncb_p
name|np
parameter_list|,
name|ccb_p
name|cp
parameter_list|,
name|u_char
name|sxfer
parameter_list|)
block|{
name|struct
name|scsi_xfer
modifier|*
name|xp
decl_stmt|;
name|tcb_p
name|tp
decl_stmt|;
name|u_char
name|target
init|=
name|INB
argument_list|(
name|nc_ctest0
argument_list|)
operator|&
literal|0x0f
decl_stmt|;
name|assert
argument_list|(
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cp
condition|)
return|return;
name|xp
operator|=
name|cp
operator|->
name|xfer
expr_stmt|;
name|assert
argument_list|(
name|xp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|xp
condition|)
return|return;
name|assert
argument_list|(
name|target
operator|==
operator|(
name|xp
operator|->
name|sc_link
operator|->
name|target
operator|&
literal|0x0f
operator|)
argument_list|)
expr_stmt|;
name|tp
operator|=
operator|&
name|np
operator|->
name|target
index|[
name|target
index|]
expr_stmt|;
name|tp
operator|->
name|period
operator|=
name|sxfer
operator|&
literal|0x1f
condition|?
operator|(
operator|(
name|sxfer
operator|>>
literal|5
operator|)
operator|+
literal|4
operator|)
operator|*
name|np
operator|->
name|ns_sync
else|:
literal|0xffff
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|sval
operator|==
name|sxfer
condition|)
return|return;
name|tp
operator|->
name|sval
operator|=
name|sxfer
expr_stmt|;
comment|/* 	**	Bells and whistles   ;-) 	*/
name|PRINT_ADDR
argument_list|(
name|xp
argument_list|)
expr_stmt|;
if|if
condition|(
name|sxfer
operator|&
literal|0x1f
condition|)
block|{
name|unsigned
name|f10
init|=
literal|10000
operator|<<
operator|(
name|tp
operator|->
name|widedone
condition|?
name|tp
operator|->
name|widedone
operator|-
literal|1
else|:
literal|0
operator|)
decl_stmt|;
name|unsigned
name|mb10
init|=
operator|(
name|f10
operator|+
name|tp
operator|->
name|period
operator|/
literal|2
operator|)
operator|/
name|tp
operator|->
name|period
decl_stmt|;
comment|/* 		**  Disable extended Sreq/Sack filtering 		*/
if|if
condition|(
name|tp
operator|->
name|period
operator|<=
literal|200
condition|)
name|OUTB
argument_list|(
name|nc_stest2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%d.%d MB/s (%d ns, offset %d)\n"
argument_list|,
name|mb10
operator|/
literal|10
argument_list|,
name|mb10
operator|%
literal|10
argument_list|,
name|tp
operator|->
name|period
argument_list|,
name|sxfer
operator|&
literal|0x1f
argument_list|)
expr_stmt|;
block|}
else|else
name|printf
argument_list|(
literal|"asynchronous.\n"
argument_list|)
expr_stmt|;
comment|/* 	**	set actual value and sync_status 	*/
name|OUTB
argument_list|(
name|nc_sxfer
argument_list|,
name|sxfer
argument_list|)
expr_stmt|;
name|np
operator|->
name|sync_st
operator|=
name|sxfer
expr_stmt|;
comment|/* 	**	patch ALL ccbs of this target. 	*/
for|for
control|(
name|cp
operator|=
operator|&
name|np
operator|->
name|ccb
init|;
name|cp
condition|;
name|cp
operator|=
name|cp
operator|->
name|link_ccb
control|)
block|{
if|if
condition|(
operator|!
name|cp
operator|->
name|xfer
condition|)
continue|continue;
if|if
condition|(
name|cp
operator|->
name|xfer
operator|->
name|sc_link
operator|->
name|target
operator|!=
name|target
condition|)
continue|continue;
name|cp
operator|->
name|sync_status
operator|=
name|sxfer
expr_stmt|;
block|}
empty_stmt|;
block|}
comment|/*========================================================== ** **	Switch wide mode for current job and it's target ** **========================================================== */
specifier|static
name|void
name|ncr_setwide
parameter_list|(
name|ncb_p
name|np
parameter_list|,
name|ccb_p
name|cp
parameter_list|,
name|u_char
name|wide
parameter_list|)
block|{
name|struct
name|scsi_xfer
modifier|*
name|xp
decl_stmt|;
name|u_short
name|target
init|=
name|INB
argument_list|(
name|nc_ctest0
argument_list|)
operator|&
literal|0x0f
decl_stmt|;
name|tcb_p
name|tp
decl_stmt|;
name|u_char
name|scntl3
init|=
name|np
operator|->
name|rv_scntl3
operator||
operator|(
name|wide
condition|?
name|EWS
else|:
literal|0
operator|)
decl_stmt|;
name|assert
argument_list|(
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cp
condition|)
return|return;
name|xp
operator|=
name|cp
operator|->
name|xfer
expr_stmt|;
name|assert
argument_list|(
name|xp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|xp
condition|)
return|return;
name|assert
argument_list|(
name|target
operator|==
operator|(
name|xp
operator|->
name|sc_link
operator|->
name|target
operator|&
literal|0x0f
operator|)
argument_list|)
expr_stmt|;
name|tp
operator|=
operator|&
name|np
operator|->
name|target
index|[
name|target
index|]
expr_stmt|;
name|tp
operator|->
name|widedone
operator|=
name|wide
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|wval
operator|==
name|scntl3
condition|)
return|return;
name|tp
operator|->
name|wval
operator|=
name|scntl3
expr_stmt|;
comment|/* 	**	Bells and whistles   ;-) 	*/
name|PRINT_ADDR
argument_list|(
name|xp
argument_list|)
expr_stmt|;
if|if
condition|(
name|scntl3
operator|&
name|EWS
condition|)
name|printf
argument_list|(
literal|"WIDE SCSI (16 bit) enabled"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"WIDE SCSI disabled"
argument_list|)
expr_stmt|;
comment|/* 	**	set actual value and sync_status 	*/
name|OUTB
argument_list|(
name|nc_scntl3
argument_list|,
name|scntl3
argument_list|)
expr_stmt|;
name|np
operator|->
name|wide_st
operator|=
name|scntl3
expr_stmt|;
comment|/* 	**	patch ALL ccbs of this target. 	*/
for|for
control|(
name|cp
operator|=
operator|&
name|np
operator|->
name|ccb
init|;
name|cp
condition|;
name|cp
operator|=
name|cp
operator|->
name|link_ccb
control|)
block|{
if|if
condition|(
operator|!
name|cp
operator|->
name|xfer
condition|)
continue|continue;
if|if
condition|(
name|cp
operator|->
name|xfer
operator|->
name|sc_link
operator|->
name|target
operator|!=
name|target
condition|)
continue|continue;
name|cp
operator|->
name|wide_status
operator|=
name|scntl3
expr_stmt|;
block|}
empty_stmt|;
block|}
comment|/*========================================================== ** **	Switch tagged mode for a target. ** **========================================================== */
specifier|static
name|void
name|ncr_setmaxtags
parameter_list|(
name|tcb_p
name|tp
parameter_list|,
name|u_long
name|usrtags
parameter_list|)
block|{
name|int
name|l
decl_stmt|;
name|tp
operator|->
name|usrtags
operator|=
name|usrtags
expr_stmt|;
for|for
control|(
name|l
operator|=
literal|0
init|;
name|l
operator|<
name|MAX_LUN
condition|;
name|l
operator|++
control|)
block|{
name|lcb_p
name|lp
decl_stmt|;
if|if
condition|(
operator|!
name|tp
condition|)
break|break;
name|lp
operator|=
name|tp
operator|->
name|lp
index|[
name|l
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|lp
condition|)
continue|continue;
name|ncr_settags
argument_list|(
name|tp
argument_list|,
name|lp
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
block|}
specifier|static
name|void
name|ncr_settags
parameter_list|(
name|tcb_p
name|tp
parameter_list|,
name|lcb_p
name|lp
parameter_list|)
block|{
name|u_char
name|reqtags
decl_stmt|,
name|tmp
decl_stmt|;
if|if
condition|(
operator|(
operator|!
name|tp
operator|)
operator|||
operator|(
operator|!
name|lp
operator|)
condition|)
return|return;
comment|/* 	**	only devices capable of tagges commands 	**	only disk devices 	**	only if enabled by user .. 	*/
if|if
condition|(
operator|(
name|tp
operator|->
name|inqdata
index|[
literal|7
index|]
operator|&
name|INQ7_QUEUE
operator|)
operator|==
literal|0
condition|)
block|{
name|tp
operator|->
name|usrtags
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|tp
operator|->
name|usrtags
operator|&&
operator|(
operator|(
name|tp
operator|->
name|inqdata
index|[
literal|0
index|]
operator|&
literal|0x1f
operator|)
operator|==
literal|0x00
operator|)
condition|)
block|{
name|reqtags
operator|=
name|tp
operator|->
name|usrtags
expr_stmt|;
if|if
condition|(
name|lp
operator|->
name|actlink
operator|<=
literal|1
condition|)
name|lp
operator|->
name|usetags
operator|=
name|reqtags
expr_stmt|;
block|}
else|else
block|{
name|reqtags
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|lp
operator|->
name|actlink
operator|<=
literal|1
condition|)
name|lp
operator|->
name|usetags
operator|=
literal|0
expr_stmt|;
block|}
empty_stmt|;
comment|/* 	**	don't announce more than available. 	*/
name|tmp
operator|=
name|lp
operator|->
name|actccbs
expr_stmt|;
if|if
condition|(
name|tmp
operator|>
name|reqtags
condition|)
name|tmp
operator|=
name|reqtags
expr_stmt|;
name|lp
operator|->
name|reqlink
operator|=
name|tmp
expr_stmt|;
comment|/* 	**	don't discard if announced. 	*/
name|tmp
operator|=
name|lp
operator|->
name|actlink
expr_stmt|;
if|if
condition|(
name|tmp
operator|<
name|reqtags
condition|)
name|tmp
operator|=
name|reqtags
expr_stmt|;
name|lp
operator|->
name|reqccbs
operator|=
name|tmp
expr_stmt|;
block|}
comment|/*---------------------------------------------------- ** **	handle user commands ** **---------------------------------------------------- */
specifier|static
name|void
name|ncr_usercmd
parameter_list|(
name|ncb_p
name|np
parameter_list|)
block|{
name|u_char
name|t
decl_stmt|;
name|tcb_p
name|tp
decl_stmt|;
switch|switch
condition|(
name|np
operator|->
name|user
operator|.
name|cmd
condition|)
block|{
case|case
literal|0
case|:
return|return;
case|case
name|UC_SETSYNC
case|:
for|for
control|(
name|t
operator|=
literal|0
init|;
name|t
operator|<
name|MAX_TARGET
condition|;
name|t
operator|++
control|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|np
operator|->
name|user
operator|.
name|target
operator|>>
name|t
operator|)
operator|&
literal|1
operator|)
condition|)
continue|continue;
name|tp
operator|=
operator|&
name|np
operator|->
name|target
index|[
name|t
index|]
expr_stmt|;
name|tp
operator|->
name|usrsync
operator|=
name|np
operator|->
name|user
operator|.
name|data
expr_stmt|;
name|ncr_negotiate
argument_list|(
name|np
argument_list|,
name|tp
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
break|break;
case|case
name|UC_SETTAGS
case|:
if|if
condition|(
name|np
operator|->
name|user
operator|.
name|data
operator|>
name|MAX_TAGS
condition|)
break|break;
for|for
control|(
name|t
operator|=
literal|0
init|;
name|t
operator|<
name|MAX_TARGET
condition|;
name|t
operator|++
control|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|np
operator|->
name|user
operator|.
name|target
operator|>>
name|t
operator|)
operator|&
literal|1
operator|)
condition|)
continue|continue;
name|ncr_setmaxtags
argument_list|(
operator|&
name|np
operator|->
name|target
index|[
name|t
index|]
argument_list|,
name|np
operator|->
name|user
operator|.
name|data
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
break|break;
case|case
name|UC_SETDEBUG
case|:
name|ncr_debug
operator|=
name|np
operator|->
name|user
operator|.
name|data
expr_stmt|;
break|break;
case|case
name|UC_SETORDER
case|:
name|np
operator|->
name|order
operator|=
name|np
operator|->
name|user
operator|.
name|data
expr_stmt|;
break|break;
case|case
name|UC_SETWIDE
case|:
for|for
control|(
name|t
operator|=
literal|0
init|;
name|t
operator|<
name|MAX_TARGET
condition|;
name|t
operator|++
control|)
block|{
name|u_long
name|size
decl_stmt|;
if|if
condition|(
operator|!
operator|(
operator|(
name|np
operator|->
name|user
operator|.
name|target
operator|>>
name|t
operator|)
operator|&
literal|1
operator|)
condition|)
continue|continue;
name|tp
operator|=
operator|&
name|np
operator|->
name|target
index|[
name|t
index|]
expr_stmt|;
name|size
operator|=
name|np
operator|->
name|user
operator|.
name|data
expr_stmt|;
if|if
condition|(
name|size
operator|>
name|np
operator|->
name|maxwide
condition|)
name|size
operator|=
name|np
operator|->
name|maxwide
expr_stmt|;
name|tp
operator|->
name|usrwide
operator|=
name|size
expr_stmt|;
name|ncr_negotiate
argument_list|(
name|np
argument_list|,
name|tp
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
break|break;
case|case
name|UC_SETFLAG
case|:
for|for
control|(
name|t
operator|=
literal|0
init|;
name|t
operator|<
name|MAX_TARGET
condition|;
name|t
operator|++
control|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|np
operator|->
name|user
operator|.
name|target
operator|>>
name|t
operator|)
operator|&
literal|1
operator|)
condition|)
continue|continue;
name|tp
operator|=
operator|&
name|np
operator|->
name|target
index|[
name|t
index|]
expr_stmt|;
name|tp
operator|->
name|usrflag
operator|=
name|np
operator|->
name|user
operator|.
name|data
expr_stmt|;
block|}
empty_stmt|;
break|break;
block|}
name|np
operator|->
name|user
operator|.
name|cmd
operator|=
literal|0
expr_stmt|;
block|}
comment|/*========================================================== ** ** **	ncr timeout handler. ** ** **========================================================== ** **	Misused to keep the driver running when **	interrupts are not configured correctly. ** **---------------------------------------------------------- */
specifier|static
name|void
name|ncr_timeout
parameter_list|(
name|ncb_p
name|np
parameter_list|)
block|{
name|u_long
name|thistime
init|=
name|time
operator|.
name|tv_sec
decl_stmt|;
name|u_long
name|step
init|=
name|np
operator|->
name|ticks
decl_stmt|;
name|u_long
name|count
init|=
literal|0
decl_stmt|;
name|long
name|signed
name|t
decl_stmt|;
name|ccb_p
name|cp
decl_stmt|;
if|if
condition|(
name|np
operator|->
name|lasttime
operator|!=
name|thistime
condition|)
block|{
comment|/* 		**	block ncr interrupts 		*/
name|int
name|oldspl
init|=
name|splbio
argument_list|()
decl_stmt|;
name|np
operator|->
name|lasttime
operator|=
name|thistime
expr_stmt|;
name|ncr_usercmd
argument_list|(
name|np
argument_list|)
expr_stmt|;
comment|/*---------------------------------------------------- 		** 		**	handle ncr chip timeouts 		** 		**	Assumption: 		**	We have a chance to arbitrate for the 		**	SCSI bus at least every 10 seconds. 		** 		**---------------------------------------------------- 		*/
name|t
operator|=
name|thistime
operator|-
name|np
operator|->
name|heartbeat
expr_stmt|;
if|if
condition|(
name|t
operator|<
literal|2
condition|)
name|np
operator|->
name|latetime
operator|=
literal|0
expr_stmt|;
else|else
name|np
operator|->
name|latetime
operator|++
expr_stmt|;
if|if
condition|(
name|np
operator|->
name|latetime
operator|>
literal|2
condition|)
block|{
comment|/* 			**      If there are no requests, the script 			**      processor will sleep on SEL_WAIT_RESEL. 			**      But we have to check whether it died. 			**      Let's try to wake it up. 			*/
name|OUTB
argument_list|(
name|nc_istat
argument_list|,
name|SIGP
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
comment|/*---------------------------------------------------- 		** 		**	handle ccb timeouts 		** 		**---------------------------------------------------- 		*/
for|for
control|(
name|cp
operator|=
operator|&
name|np
operator|->
name|ccb
init|;
name|cp
condition|;
name|cp
operator|=
name|cp
operator|->
name|link_ccb
control|)
block|{
comment|/* 			**	look for timed out ccbs. 			*/
if|if
condition|(
operator|!
name|cp
operator|->
name|host_status
condition|)
continue|continue;
name|count
operator|++
expr_stmt|;
if|if
condition|(
name|cp
operator|->
name|tlimit
operator|>
name|thistime
condition|)
continue|continue;
comment|/* 			**	Disable reselect. 			**      Remove it from startqueue. 			*/
name|cp
operator|->
name|jump_ccb
operator|.
name|l_cmd
operator|=
operator|(
name|SCR_JUMP
operator|)
expr_stmt|;
if|if
condition|(
name|cp
operator|->
name|phys
operator|.
name|header
operator|.
name|launch
operator|.
name|l_paddr
operator|==
name|NCB_SCRIPT_PHYS
argument_list|(
name|np
argument_list|,
name|select
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"%s: timeout ccb=%x (skip)\n"
argument_list|,
name|ncr_name
argument_list|(
name|np
argument_list|)
argument_list|,
operator|(
name|unsigned
operator|)
name|cp
argument_list|)
expr_stmt|;
name|cp
operator|->
name|phys
operator|.
name|header
operator|.
name|launch
operator|.
name|l_paddr
operator|=
name|NCB_SCRIPT_PHYS
argument_list|(
name|np
argument_list|,
name|skip
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
switch|switch
condition|(
name|cp
operator|->
name|host_status
condition|)
block|{
case|case
name|HS_BUSY
case|:
case|case
name|HS_NEGOTIATE
case|:
comment|/* 				** still in start queue ? 				*/
if|if
condition|(
name|cp
operator|->
name|phys
operator|.
name|header
operator|.
name|launch
operator|.
name|l_paddr
operator|==
name|NCB_SCRIPT_PHYS
argument_list|(
name|np
argument_list|,
name|skip
argument_list|)
condition|)
continue|continue;
comment|/* fall through */
case|case
name|HS_DISCONNECT
case|:
name|cp
operator|->
name|host_status
operator|=
name|HS_TIMEOUT
expr_stmt|;
block|}
empty_stmt|;
name|cp
operator|->
name|tag
operator|=
literal|0
expr_stmt|;
comment|/* 			**	wakeup this ccb. 			*/
name|ncr_complete
argument_list|(
name|np
argument_list|,
name|cp
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
name|splx
argument_list|(
name|oldspl
argument_list|)
expr_stmt|;
block|}
name|timeout
argument_list|(
argument|TIMEOUT ncr_timeout
argument_list|,
argument|(caddr_t) np
argument_list|,
argument|step ? step :
literal|1
argument_list|)
empty_stmt|;
if|if
condition|(
name|INB
argument_list|(
name|nc_istat
argument_list|)
operator|&
operator|(
name|INTF
operator||
name|SIP
operator||
name|DIP
operator|)
condition|)
block|{
comment|/* 		**	Process pending interrupts. 		*/
name|int
name|oldspl
init|=
name|splbio
argument_list|()
decl_stmt|;
if|if
condition|(
name|DEBUG_FLAGS
operator|&
name|DEBUG_TINY
condition|)
name|printf
argument_list|(
literal|"{"
argument_list|)
expr_stmt|;
name|ncr_exception
argument_list|(
name|np
argument_list|)
expr_stmt|;
if|if
condition|(
name|DEBUG_FLAGS
operator|&
name|DEBUG_TINY
condition|)
name|printf
argument_list|(
literal|"}"
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|oldspl
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
block|}
comment|/*========================================================== ** ** **	ncr chip exception handler. ** ** **========================================================== */
name|void
name|ncr_exception
parameter_list|(
name|ncb_p
name|np
parameter_list|)
block|{
name|u_char
name|istat
decl_stmt|,
name|dstat
decl_stmt|;
name|u_short
name|sist
decl_stmt|;
name|u_long
name|dsp
decl_stmt|,
name|dsa
decl_stmt|;
name|int
name|i
decl_stmt|,
name|script_ofs
decl_stmt|;
comment|/* 	**	interrupt on the fly ? 	*/
while|while
condition|(
operator|(
name|istat
operator|=
name|INB
argument_list|(
name|nc_istat
argument_list|)
operator|)
operator|&
name|INTF
condition|)
block|{
if|if
condition|(
name|DEBUG_FLAGS
operator|&
name|DEBUG_TINY
condition|)
name|printf
argument_list|(
literal|"F "
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
name|nc_istat
argument_list|,
name|INTF
argument_list|)
expr_stmt|;
name|np
operator|->
name|profile
operator|.
name|num_fly
operator|++
expr_stmt|;
name|ncr_wakeup
argument_list|(
name|np
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
if|if
condition|(
operator|!
operator|(
name|istat
operator|&
operator|(
name|SIP
operator||
name|DIP
operator|)
operator|)
condition|)
block|{
return|return;
block|}
comment|/* 	**	Steinbach's Guideline for Systems Programming: 	**	Never test for an error condition you don't know how to handle. 	*/
name|sist
operator|=
operator|(
name|istat
operator|&
name|SIP
operator|)
condition|?
name|INW
argument_list|(
name|nc_sist
argument_list|)
else|:
literal|0
expr_stmt|;
name|dstat
operator|=
operator|(
name|istat
operator|&
name|DIP
operator|)
condition|?
name|INB
argument_list|(
name|nc_dstat
argument_list|)
else|:
literal|0
expr_stmt|;
name|np
operator|->
name|profile
operator|.
name|num_int
operator|++
expr_stmt|;
if|if
condition|(
name|DEBUG_FLAGS
operator|&
name|DEBUG_TINY
condition|)
name|printf
argument_list|(
literal|"<%d|%x:%x|%x:%x>"
argument_list|,
name|INB
argument_list|(
name|nc_scr0
argument_list|)
argument_list|,
name|dstat
argument_list|,
name|sist
argument_list|,
operator|(
name|unsigned
operator|)
name|INL
argument_list|(
name|nc_dsp
argument_list|)
argument_list|,
operator|(
name|unsigned
operator|)
name|INL
argument_list|(
name|nc_dbc
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|dstat
operator|==
name|DFE
operator|)
operator|&&
operator|(
name|sist
operator|==
name|PAR
operator|)
condition|)
return|return;
comment|/*========================================================== ** **	First the normal cases. ** **========================================================== */
comment|/*------------------------------------------- 	**	SCSI reset 	**------------------------------------------- 	*/
if|if
condition|(
name|sist
operator|&
name|RST
condition|)
block|{
name|ncr_init
argument_list|(
name|np
argument_list|,
name|bootverbose
condition|?
literal|"scsi reset"
else|:
name|NULL
argument_list|,
name|HS_RESET
argument_list|)
expr_stmt|;
return|return;
block|}
empty_stmt|;
comment|/*------------------------------------------- 	**	selection timeout 	** 	**	IID excluded from dstat mask! 	**	(chip bug) 	**------------------------------------------- 	*/
if|if
condition|(
operator|(
name|sist
operator|&
name|STO
operator|)
operator|&&
operator|!
operator|(
name|sist
operator|&
operator|(
name|GEN
operator||
name|HTH
operator||
name|MA
operator||
name|SGE
operator||
name|UDC
operator||
name|RST
operator||
name|PAR
operator|)
operator|)
operator|&&
operator|!
operator|(
name|dstat
operator|&
operator|(
name|MDPE
operator||
name|BF
operator||
name|ABRT
operator||
name|SIR
operator|)
operator|)
condition|)
block|{
name|ncr_int_sto
argument_list|(
name|np
argument_list|)
expr_stmt|;
return|return;
block|}
empty_stmt|;
comment|/*------------------------------------------- 	**      Phase mismatch. 	**------------------------------------------- 	*/
if|if
condition|(
operator|(
name|sist
operator|&
name|MA
operator|)
operator|&&
operator|!
operator|(
name|sist
operator|&
operator|(
name|STO
operator||
name|GEN
operator||
name|HTH
operator||
name|SGE
operator||
name|UDC
operator||
name|RST
operator||
name|PAR
operator|)
operator|)
operator|&&
operator|!
operator|(
name|dstat
operator|&
operator|(
name|MDPE
operator||
name|BF
operator||
name|ABRT
operator||
name|SIR
operator||
name|IID
operator|)
operator|)
condition|)
block|{
name|ncr_int_ma
argument_list|(
name|np
argument_list|,
name|dstat
argument_list|)
expr_stmt|;
return|return;
block|}
empty_stmt|;
comment|/*---------------------------------------- 	**	move command with length 0 	**---------------------------------------- 	*/
if|if
condition|(
operator|(
name|dstat
operator|&
name|IID
operator|)
operator|&&
operator|!
operator|(
name|sist
operator|&
operator|(
name|STO
operator||
name|GEN
operator||
name|HTH
operator||
name|MA
operator||
name|SGE
operator||
name|UDC
operator||
name|RST
operator||
name|PAR
operator|)
operator|)
operator|&&
operator|!
operator|(
name|dstat
operator|&
operator|(
name|MDPE
operator||
name|BF
operator||
name|ABRT
operator||
name|SIR
operator|)
operator|)
operator|&&
operator|(
operator|(
name|INL
argument_list|(
name|nc_dbc
argument_list|)
operator|&
literal|0xf8000000
operator|)
operator|==
name|SCR_MOVE_TBL
operator|)
condition|)
block|{
comment|/* 		**      Target wants more data than available. 		**	The "no_data" script will do it. 		*/
name|OUTL
argument_list|(
name|nc_dsp
argument_list|,
name|NCB_SCRIPT_PHYS
argument_list|(
name|np
argument_list|,
name|no_data
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
empty_stmt|;
comment|/*------------------------------------------- 	**	Programmed interrupt 	**------------------------------------------- 	*/
if|if
condition|(
operator|(
name|dstat
operator|&
name|SIR
operator|)
operator|&&
operator|!
operator|(
name|sist
operator|&
operator|(
name|STO
operator||
name|GEN
operator||
name|HTH
operator||
name|MA
operator||
name|SGE
operator||
name|UDC
operator||
name|RST
operator||
name|PAR
operator|)
operator|)
operator|&&
operator|!
operator|(
name|dstat
operator|&
operator|(
name|MDPE
operator||
name|BF
operator||
name|ABRT
operator||
name|IID
operator|)
operator|)
operator|&&
operator|(
name|INB
argument_list|(
name|nc_dsps
argument_list|)
operator|<=
name|SIR_MAX
operator|)
condition|)
block|{
name|ncr_int_sir
argument_list|(
name|np
argument_list|)
expr_stmt|;
return|return;
block|}
empty_stmt|;
comment|/*======================================== 	**	do the register dump 	**======================================== 	*/
if|if
condition|(
name|time
operator|.
name|tv_sec
operator|-
name|np
operator|->
name|regtime
operator|.
name|tv_sec
operator|>
literal|10
condition|)
block|{
name|int
name|i
decl_stmt|;
name|np
operator|->
name|regtime
operator|=
name|time
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|np
operator|->
name|regdump
argument_list|)
condition|;
name|i
operator|++
control|)
operator|(
operator|(
name|char
operator|*
operator|)
operator|&
name|np
operator|->
name|regdump
operator|)
index|[
name|i
index|]
operator|=
operator|(
operator|(
specifier|volatile
name|char
operator|*
operator|)
name|np
operator|->
name|reg
operator|)
index|[
name|i
index|]
expr_stmt|;
name|np
operator|->
name|regdump
operator|.
name|nc_dstat
operator|=
name|dstat
expr_stmt|;
name|np
operator|->
name|regdump
operator|.
name|nc_sist
operator|=
name|sist
expr_stmt|;
block|}
empty_stmt|;
comment|/*========================================= 	**	log message for real hard errors 	**=========================================  	"ncr0 targ 0?: ERROR (ds:si) (so-si-sd) (sxfer/scntl3) @ (dsp:dbc)." 	"	      reg: r0 r1 r2 r3 r4 r5 r6 ..... rf."  	exception register: 		ds:	dstat 		si:	sist  	SCSI bus lines: 		so:	control lines as driver by NCR. 		si:	control lines as seen by NCR. 		sd:	scsi data lines as seen by NCR.  	wide/fastmode: 		sxfer:	(see the manual) 		scntl3:	(see the manual)  	current script command: 		dsp:	script adress (relative to start of script). 		dbc:	first word of script command.  	First 16 register of the chip: 		r0..rf  	============================================= 	*/
name|dsp
operator|=
operator|(
name|unsigned
operator|)
name|INL
argument_list|(
name|nc_dsp
argument_list|)
expr_stmt|;
name|dsa
operator|=
operator|(
name|unsigned
operator|)
name|INL
argument_list|(
name|nc_dsa
argument_list|)
expr_stmt|;
name|script_ofs
operator|=
name|dsp
operator|-
name|np
operator|->
name|p_script
expr_stmt|;
name|printf
argument_list|(
literal|"%s:%d: ERROR (%x:%x) (%x-%x-%x) (%x/%x) @ (%x:%08x).\n"
argument_list|,
name|ncr_name
argument_list|(
name|np
argument_list|)
argument_list|,
name|INB
argument_list|(
name|nc_ctest0
argument_list|)
operator|&
literal|0x0f
argument_list|,
name|dstat
argument_list|,
name|sist
argument_list|,
name|INB
argument_list|(
name|nc_socl
argument_list|)
argument_list|,
name|INB
argument_list|(
name|nc_sbcl
argument_list|)
argument_list|,
name|INB
argument_list|(
name|nc_sbdl
argument_list|)
argument_list|,
name|INB
argument_list|(
name|nc_sxfer
argument_list|)
argument_list|,
name|INB
argument_list|(
name|nc_scntl3
argument_list|)
argument_list|,
name|script_ofs
argument_list|,
operator|(
name|unsigned
operator|)
name|INL
argument_list|(
name|nc_dbc
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|script_ofs
operator|&
literal|3
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|unsigned
operator|)
name|script_ofs
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|script
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"\tscript cmd = %08x\n"
argument_list|,
operator|*
operator|(
name|ncrcmd
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|np
operator|->
name|script
operator|+
name|script_ofs
operator|)
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\treg:\t"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|" %02x"
argument_list|,
operator|(
operator|(
specifier|volatile
name|u_char
operator|*
operator|)
name|np
operator|->
name|reg
operator|)
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|".\n"
argument_list|)
expr_stmt|;
comment|/*---------------------------------------- 	**	clean up the dma fifo 	**---------------------------------------- 	*/
if|if
condition|(
operator|(
name|INB
argument_list|(
name|nc_sstat0
argument_list|)
operator|&
operator|(
name|ILF
operator||
name|ORF
operator||
name|OLF
operator|)
operator|)
operator|||
operator|(
name|INB
argument_list|(
name|nc_sstat1
argument_list|)
operator|&
operator|(
name|FF3210
operator|)
operator|)
operator|||
operator|(
name|INB
argument_list|(
name|nc_sstat2
argument_list|)
operator|&
operator|(
name|ILF1
operator||
name|ORF1
operator||
name|OLF1
operator|)
operator|)
operator|||
comment|/* wide .. */
operator|!
operator|(
name|dstat
operator|&
name|DFE
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"%s: have to clear fifos.\n"
argument_list|,
name|ncr_name
argument_list|(
name|np
argument_list|)
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
name|nc_stest3
argument_list|,
name|TE
operator||
name|CSF
argument_list|)
expr_stmt|;
comment|/* clear scsi fifo */
name|OUTB
argument_list|(
name|nc_ctest3
argument_list|,
name|CLF
argument_list|)
expr_stmt|;
comment|/* clear dma fifo  */
block|}
comment|/*---------------------------------------- 	**	handshake timeout 	**---------------------------------------- 	*/
if|if
condition|(
name|sist
operator|&
name|HTH
condition|)
block|{
name|printf
argument_list|(
literal|"%s: handshake timeout\n"
argument_list|,
name|ncr_name
argument_list|(
name|np
argument_list|)
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
name|nc_scntl1
argument_list|,
name|CRST
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
name|nc_scntl1
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
name|nc_scr0
argument_list|,
name|HS_FAIL
argument_list|)
expr_stmt|;
name|OUTL
argument_list|(
name|nc_dsp
argument_list|,
name|NCB_SCRIPT_PHYS
argument_list|(
name|np
argument_list|,
name|cleanup
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/*---------------------------------------- 	**	unexpected disconnect 	**---------------------------------------- 	*/
if|if
condition|(
operator|(
name|sist
operator|&
name|UDC
operator|)
operator|&&
operator|!
operator|(
name|sist
operator|&
operator|(
name|STO
operator||
name|GEN
operator||
name|HTH
operator||
name|MA
operator||
name|SGE
operator||
name|RST
operator||
name|PAR
operator|)
operator|)
operator|&&
operator|!
operator|(
name|dstat
operator|&
operator|(
name|MDPE
operator||
name|BF
operator||
name|ABRT
operator||
name|SIR
operator||
name|IID
operator|)
operator|)
condition|)
block|{
name|OUTB
argument_list|(
name|nc_scr0
argument_list|,
name|HS_UNEXPECTED
argument_list|)
expr_stmt|;
name|OUTL
argument_list|(
name|nc_dsp
argument_list|,
name|NCB_SCRIPT_PHYS
argument_list|(
name|np
argument_list|,
name|cleanup
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
empty_stmt|;
comment|/*---------------------------------------- 	**	cannot disconnect 	**---------------------------------------- 	*/
if|if
condition|(
operator|(
name|dstat
operator|&
name|IID
operator|)
operator|&&
operator|!
operator|(
name|sist
operator|&
operator|(
name|STO
operator||
name|GEN
operator||
name|HTH
operator||
name|MA
operator||
name|SGE
operator||
name|UDC
operator||
name|RST
operator||
name|PAR
operator|)
operator|)
operator|&&
operator|!
operator|(
name|dstat
operator|&
operator|(
name|MDPE
operator||
name|BF
operator||
name|ABRT
operator||
name|SIR
operator|)
operator|)
operator|&&
operator|(
operator|(
name|INL
argument_list|(
name|nc_dbc
argument_list|)
operator|&
literal|0xf8000000
operator|)
operator|==
name|SCR_WAIT_DISC
operator|)
condition|)
block|{
comment|/* 		**      Unexpected data cycle while waiting for disconnect. 		*/
if|if
condition|(
name|INB
argument_list|(
name|nc_sstat2
argument_list|)
operator|&
name|LDSC
condition|)
block|{
comment|/* 			**	It's an early reconnect. 			**	Let's continue ... 			*/
name|OUTB
argument_list|(
name|nc_dcntl
argument_list|,
operator|(
name|STD
operator||
name|NOCOM
operator|)
argument_list|)
expr_stmt|;
comment|/* 			**	info message 			*/
name|printf
argument_list|(
literal|"%s: INFO: LDSC while IID.\n"
argument_list|,
name|ncr_name
argument_list|(
name|np
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
empty_stmt|;
name|printf
argument_list|(
literal|"%s: target %d doesn't release the bus.\n"
argument_list|,
name|ncr_name
argument_list|(
name|np
argument_list|)
argument_list|,
name|INB
argument_list|(
name|nc_ctest0
argument_list|)
operator|&
literal|0x0f
argument_list|)
expr_stmt|;
comment|/* 		**	return without restarting the NCR. 		**	timeout will do the real work. 		*/
return|return;
block|}
empty_stmt|;
comment|/*---------------------------------------- 	**	single step 	**---------------------------------------- 	*/
if|if
condition|(
operator|(
name|dstat
operator|&
name|SSI
operator|)
operator|&&
operator|!
operator|(
name|sist
operator|&
operator|(
name|STO
operator||
name|GEN
operator||
name|HTH
operator||
name|MA
operator||
name|SGE
operator||
name|UDC
operator||
name|RST
operator||
name|PAR
operator|)
operator|)
operator|&&
operator|!
operator|(
name|dstat
operator|&
operator|(
name|MDPE
operator||
name|BF
operator||
name|ABRT
operator||
name|SIR
operator||
name|IID
operator|)
operator|)
condition|)
block|{
name|OUTB
argument_list|(
name|nc_dcntl
argument_list|,
operator|(
name|STD
operator||
name|NOCOM
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
empty_stmt|;
comment|/* **	@RECOVER@ HTH, SGE, ABRT. ** **	We should try to recover from these interrupts. **	They may occur if there are problems with synch transfers, or  **	if targets are switched on or off while the driver is running. */
if|if
condition|(
name|sist
operator|&
name|SGE
condition|)
block|{
name|OUTB
argument_list|(
name|nc_ctest3
argument_list|,
name|CLF
argument_list|)
expr_stmt|;
comment|/* clear scsi offsets */
block|}
comment|/* 	**	Freeze controller to be able to read the messages. 	*/
if|if
condition|(
name|DEBUG_FLAGS
operator|&
name|DEBUG_FREEZE
condition|)
block|{
name|int
name|i
decl_stmt|;
name|unsigned
name|char
name|val
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|0x60
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
name|i
operator|%
literal|16
condition|)
block|{
case|case
literal|0
case|:
name|printf
argument_list|(
literal|"%s: reg[%d0]: "
argument_list|,
name|ncr_name
argument_list|(
name|np
argument_list|)
argument_list|,
name|i
operator|/
literal|16
argument_list|)
expr_stmt|;
break|break;
case|case
literal|4
case|:
case|case
literal|8
case|:
case|case
literal|12
case|:
name|printf
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
break|break;
block|}
empty_stmt|;
name|val
operator|=
operator|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|np
operator|->
name|vaddr
operator|)
index|[
name|i
index|]
expr_stmt|;
name|printf
argument_list|(
literal|" %x%x"
argument_list|,
name|val
operator|/
literal|16
argument_list|,
name|val
operator|%
literal|16
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|%
literal|16
operator|==
literal|15
condition|)
name|printf
argument_list|(
literal|".\n"
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
name|untimeout
argument_list|(
argument|TIMEOUT ncr_timeout
argument_list|,
argument|(caddr_t) np
argument_list|)
empty_stmt|;
name|printf
argument_list|(
literal|"%s: halted!\n"
argument_list|,
name|ncr_name
argument_list|(
name|np
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 		**	don't restart controller ... 		*/
name|OUTB
argument_list|(
name|nc_istat
argument_list|,
name|SRST
argument_list|)
expr_stmt|;
return|return;
block|}
empty_stmt|;
ifdef|#
directive|ifdef
name|NCR_FREEZE
comment|/* 	**	Freeze system to be able to read the messages. 	*/
name|printf
argument_list|(
literal|"ncr: fatal error: system halted - press reset to reboot ..."
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|splhigh
argument_list|()
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
empty_stmt|;
endif|#
directive|endif
comment|/* 	**	sorry, have to kill ALL jobs ... 	*/
name|ncr_init
argument_list|(
name|np
argument_list|,
literal|"fatal error"
argument_list|,
name|HS_FAIL
argument_list|)
expr_stmt|;
block|}
comment|/*========================================================== ** **	ncr chip exception handler for selection timeout ** **========================================================== ** **	There seems to be a bug in the 53c810. **	Although a STO-Interrupt is pending, **	it continues executing script commands. **	But it will fail and interrupt (IID) on **	the next instruction where it's looking **	for a valid phase. ** **---------------------------------------------------------- */
name|void
name|ncr_int_sto
parameter_list|(
name|ncb_p
name|np
parameter_list|)
block|{
name|u_long
name|dsa
decl_stmt|,
name|scratcha
decl_stmt|,
name|diff
decl_stmt|;
name|ccb_p
name|cp
decl_stmt|;
if|if
condition|(
name|DEBUG_FLAGS
operator|&
name|DEBUG_TINY
condition|)
name|printf
argument_list|(
literal|"T"
argument_list|)
expr_stmt|;
comment|/* 	**	look for ccb and set the status. 	*/
name|dsa
operator|=
name|INL
argument_list|(
name|nc_dsa
argument_list|)
expr_stmt|;
name|cp
operator|=
operator|&
name|np
operator|->
name|ccb
expr_stmt|;
while|while
condition|(
name|cp
operator|&&
operator|(
name|CCB_PHYS
argument_list|(
name|cp
argument_list|,
name|phys
argument_list|)
operator|!=
name|dsa
operator|)
condition|)
name|cp
operator|=
name|cp
operator|->
name|link_ccb
expr_stmt|;
if|if
condition|(
name|cp
condition|)
block|{
name|cp
operator|->
name|host_status
operator|=
name|HS_SEL_TIMEOUT
expr_stmt|;
name|ncr_complete
argument_list|(
name|np
argument_list|,
name|cp
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
comment|/* 	**	repair start queue 	*/
name|scratcha
operator|=
name|INL
argument_list|(
name|nc_scratcha
argument_list|)
expr_stmt|;
name|diff
operator|=
name|scratcha
operator|-
name|NCB_SCRIPT_PHYS
argument_list|(
name|np
argument_list|,
name|tryloop
argument_list|)
expr_stmt|;
comment|/*	assert ((diff<= MAX_START * 20)&& !(diff % 20));*/
if|if
condition|(
operator|(
name|diff
operator|<=
name|MAX_START
operator|*
literal|20
operator|)
operator|&&
operator|!
operator|(
name|diff
operator|%
literal|20
operator|)
condition|)
block|{
name|np
operator|->
name|script
operator|->
name|startpos
index|[
literal|0
index|]
operator|=
name|scratcha
expr_stmt|;
name|OUTL
argument_list|(
name|nc_dsp
argument_list|,
name|NCB_SCRIPT_PHYS
argument_list|(
name|np
argument_list|,
name|start
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
empty_stmt|;
name|ncr_init
argument_list|(
name|np
argument_list|,
literal|"selection timeout"
argument_list|,
name|HS_FAIL
argument_list|)
expr_stmt|;
block|}
comment|/*========================================================== ** ** **	ncr chip exception handler for phase errors. ** ** **========================================================== ** **	We have to construct a new transfer descriptor, **	to transfer the rest of the current block. ** **---------------------------------------------------------- */
specifier|static
name|void
name|ncr_int_ma
parameter_list|(
name|ncb_p
name|np
parameter_list|,
name|u_char
name|dstat
parameter_list|)
block|{
name|u_long
name|dbc
decl_stmt|;
name|u_long
name|rest
decl_stmt|;
name|u_long
name|dsa
decl_stmt|;
name|u_long
name|dsp
decl_stmt|;
name|u_long
name|nxtdsp
decl_stmt|;
name|u_long
modifier|*
name|vdsp
decl_stmt|;
name|u_long
name|oadr
decl_stmt|,
name|olen
decl_stmt|;
name|u_long
modifier|*
name|tblp
decl_stmt|,
modifier|*
name|newcmd
decl_stmt|;
name|u_char
name|cmd
decl_stmt|,
name|sbcl
decl_stmt|,
name|delta
decl_stmt|,
name|ss0
decl_stmt|,
name|ss2
decl_stmt|;
name|ccb_p
name|cp
decl_stmt|;
name|dsp
operator|=
name|INL
argument_list|(
name|nc_dsp
argument_list|)
expr_stmt|;
name|dsa
operator|=
name|INL
argument_list|(
name|nc_dsa
argument_list|)
expr_stmt|;
name|dbc
operator|=
name|INL
argument_list|(
name|nc_dbc
argument_list|)
expr_stmt|;
name|ss0
operator|=
name|INB
argument_list|(
name|nc_sstat0
argument_list|)
expr_stmt|;
name|ss2
operator|=
name|INB
argument_list|(
name|nc_sstat2
argument_list|)
expr_stmt|;
name|sbcl
operator|=
name|INB
argument_list|(
name|nc_sbcl
argument_list|)
expr_stmt|;
name|cmd
operator|=
name|dbc
operator|>>
literal|24
expr_stmt|;
name|rest
operator|=
name|dbc
operator|&
literal|0xffffff
expr_stmt|;
name|delta
operator|=
operator|(
name|INB
argument_list|(
name|nc_dfifo
argument_list|)
operator|-
name|rest
operator|)
operator|&
literal|0x7f
expr_stmt|;
comment|/* 	**	The data in the dma fifo has not been transfered to 	**	the target -> add the amount to the rest 	**	and clear the data. 	**	Check the sstat2 register in case of wide transfer. 	*/
if|if
condition|(
operator|!
operator|(
name|dstat
operator|&
name|DFE
operator|)
condition|)
name|rest
operator|+=
name|delta
expr_stmt|;
if|if
condition|(
name|ss0
operator|&
name|OLF
condition|)
name|rest
operator|++
expr_stmt|;
if|if
condition|(
name|ss0
operator|&
name|ORF
condition|)
name|rest
operator|++
expr_stmt|;
if|if
condition|(
name|INB
argument_list|(
name|nc_scntl3
argument_list|)
operator|&
name|EWS
condition|)
block|{
if|if
condition|(
name|ss2
operator|&
name|OLF1
condition|)
name|rest
operator|++
expr_stmt|;
if|if
condition|(
name|ss2
operator|&
name|ORF1
condition|)
name|rest
operator|++
expr_stmt|;
block|}
empty_stmt|;
name|OUTB
argument_list|(
name|nc_ctest3
argument_list|,
name|CLF
argument_list|)
expr_stmt|;
comment|/* clear dma fifo  */
name|OUTB
argument_list|(
name|nc_stest3
argument_list|,
name|TE
operator||
name|CSF
argument_list|)
expr_stmt|;
comment|/* clear scsi fifo */
comment|/* 	**	locate matching cp 	*/
name|dsa
operator|=
name|INL
argument_list|(
name|nc_dsa
argument_list|)
expr_stmt|;
name|cp
operator|=
operator|&
name|np
operator|->
name|ccb
expr_stmt|;
while|while
condition|(
name|cp
operator|&&
operator|(
name|CCB_PHYS
argument_list|(
name|cp
argument_list|,
name|phys
argument_list|)
operator|!=
name|dsa
operator|)
condition|)
name|cp
operator|=
name|cp
operator|->
name|link_ccb
expr_stmt|;
if|if
condition|(
operator|!
name|cp
condition|)
block|{
name|printf
argument_list|(
literal|"%s: SCSI phase error fixup: CCB already dequeued (0x%08lx)\n"
argument_list|,
name|ncr_name
argument_list|(
name|np
argument_list|)
argument_list|,
operator|(
name|u_long
operator|)
name|np
operator|->
name|header
operator|.
name|cp
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|cp
operator|!=
name|np
operator|->
name|header
operator|.
name|cp
condition|)
block|{
name|printf
argument_list|(
literal|"%s: SCSI phase error fixup: CCB address mismatch (0x%08lx != 0x%08lx) np.ccb = 0x%08lx\n"
argument_list|,
name|ncr_name
argument_list|(
name|np
argument_list|)
argument_list|,
operator|(
name|u_long
operator|)
name|cp
argument_list|,
operator|(
name|u_long
operator|)
name|np
operator|->
name|header
operator|.
name|cp
argument_list|,
operator|&
name|np
operator|->
name|ccb
argument_list|)
expr_stmt|;
comment|/*	    return;*/
block|}
comment|/* 	**	find the interrupted script command, 	**	and the address at which to continue. 	*/
if|if
condition|(
name|dsp
operator|==
name|vtophys
argument_list|(
operator|&
name|cp
operator|->
name|patch
index|[
literal|2
index|]
argument_list|)
condition|)
block|{
name|vdsp
operator|=
operator|&
name|cp
operator|->
name|patch
index|[
literal|0
index|]
expr_stmt|;
name|nxtdsp
operator|=
name|vdsp
index|[
literal|3
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dsp
operator|==
name|vtophys
argument_list|(
operator|&
name|cp
operator|->
name|patch
index|[
literal|6
index|]
argument_list|)
condition|)
block|{
name|vdsp
operator|=
operator|&
name|cp
operator|->
name|patch
index|[
literal|4
index|]
expr_stmt|;
name|nxtdsp
operator|=
name|vdsp
index|[
literal|3
index|]
expr_stmt|;
block|}
else|else
block|{
name|vdsp
operator|=
operator|(
name|u_long
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|np
operator|->
name|script
operator|-
name|np
operator|->
name|p_script
operator|+
name|dsp
operator|-
literal|8
operator|)
expr_stmt|;
name|nxtdsp
operator|=
name|dsp
expr_stmt|;
block|}
empty_stmt|;
comment|/* 	**	log the information 	*/
if|if
condition|(
name|DEBUG_FLAGS
operator|&
operator|(
name|DEBUG_TINY
operator||
name|DEBUG_PHASE
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"P%x%x "
argument_list|,
name|cmd
operator|&
literal|7
argument_list|,
name|sbcl
operator|&
literal|7
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"RL=%d D=%d SS0=%x "
argument_list|,
operator|(
name|unsigned
operator|)
name|rest
argument_list|,
operator|(
name|unsigned
operator|)
name|delta
argument_list|,
name|ss0
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
if|if
condition|(
name|DEBUG_FLAGS
operator|&
name|DEBUG_PHASE
condition|)
block|{
name|printf
argument_list|(
literal|"\nCP=%x CP2=%x DSP=%x NXT=%x VDSP=%x CMD=%x "
argument_list|,
operator|(
name|unsigned
operator|)
name|cp
argument_list|,
operator|(
name|unsigned
operator|)
name|np
operator|->
name|header
operator|.
name|cp
argument_list|,
operator|(
name|unsigned
operator|)
name|dsp
argument_list|,
operator|(
name|unsigned
operator|)
name|nxtdsp
argument_list|,
operator|(
name|unsigned
operator|)
name|vdsp
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
comment|/* 	**	get old startaddress and old length. 	*/
name|oadr
operator|=
name|vdsp
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|cmd
operator|&
literal|0x10
condition|)
block|{
comment|/* Table indirect */
name|tblp
operator|=
operator|(
name|u_long
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
operator|&
name|cp
operator|->
name|phys
operator|+
name|oadr
operator|)
expr_stmt|;
name|olen
operator|=
name|tblp
index|[
literal|0
index|]
expr_stmt|;
name|oadr
operator|=
name|tblp
index|[
literal|1
index|]
expr_stmt|;
block|}
else|else
block|{
name|tblp
operator|=
operator|(
name|u_long
operator|*
operator|)
literal|0
expr_stmt|;
name|olen
operator|=
name|vdsp
index|[
literal|0
index|]
operator|&
literal|0xffffff
expr_stmt|;
block|}
empty_stmt|;
if|if
condition|(
name|DEBUG_FLAGS
operator|&
name|DEBUG_PHASE
condition|)
block|{
name|printf
argument_list|(
literal|"OCMD=%x\nTBLP=%x OLEN=%x OADR=%x\n"
argument_list|,
call|(
name|unsigned
call|)
argument_list|(
name|vdsp
index|[
literal|0
index|]
operator|>>
literal|24
argument_list|)
argument_list|,
operator|(
name|unsigned
operator|)
name|tblp
argument_list|,
operator|(
name|unsigned
operator|)
name|olen
argument_list|,
operator|(
name|unsigned
operator|)
name|oadr
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
comment|/* 	**	if old phase not dataphase, leave here. 	*/
if|if
condition|(
name|cmd
operator|!=
operator|(
name|vdsp
index|[
literal|0
index|]
operator|>>
literal|24
operator|)
condition|)
block|{
name|PRINT_ADDR
argument_list|(
name|cp
operator|->
name|xfer
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"internal error: cmd=%02x != %02x=(vdsp[0]>> 24)\n"
argument_list|,
operator|(
name|unsigned
operator|)
name|cmd
argument_list|,
operator|(
name|unsigned
operator|)
name|vdsp
index|[
literal|0
index|]
operator|>>
literal|24
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|cmd
operator|&
literal|0x06
condition|)
block|{
name|PRINT_ADDR
argument_list|(
name|cp
operator|->
name|xfer
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"phase change %x-%x %d@%08x resid=%d.\n"
argument_list|,
name|cmd
operator|&
literal|7
argument_list|,
name|sbcl
operator|&
literal|7
argument_list|,
operator|(
name|unsigned
operator|)
name|olen
argument_list|,
operator|(
name|unsigned
operator|)
name|oadr
argument_list|,
operator|(
name|unsigned
operator|)
name|rest
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
name|nc_dcntl
argument_list|,
operator|(
name|STD
operator||
name|NOCOM
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
empty_stmt|;
comment|/* 	**	choose the correct patch area. 	**	if savep points to one, choose the other. 	*/
name|newcmd
operator|=
name|cp
operator|->
name|patch
expr_stmt|;
if|if
condition|(
name|cp
operator|->
name|phys
operator|.
name|header
operator|.
name|savep
operator|==
name|vtophys
argument_list|(
name|newcmd
argument_list|)
condition|)
name|newcmd
operator|+=
literal|4
expr_stmt|;
comment|/* 	**	fillin the commands 	*/
name|newcmd
index|[
literal|0
index|]
operator|=
operator|(
operator|(
name|cmd
operator|&
literal|0x0f
operator|)
operator|<<
literal|24
operator|)
operator||
name|rest
expr_stmt|;
name|newcmd
index|[
literal|1
index|]
operator|=
name|oadr
operator|+
name|olen
operator|-
name|rest
expr_stmt|;
name|newcmd
index|[
literal|2
index|]
operator|=
name|SCR_JUMP
expr_stmt|;
name|newcmd
index|[
literal|3
index|]
operator|=
name|nxtdsp
expr_stmt|;
if|if
condition|(
name|DEBUG_FLAGS
operator|&
name|DEBUG_PHASE
condition|)
block|{
name|PRINT_ADDR
argument_list|(
name|cp
operator|->
name|xfer
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"newcmd[%d] %x %x %x %x.\n"
argument_list|,
name|newcmd
operator|-
name|cp
operator|->
name|patch
argument_list|,
operator|(
name|unsigned
operator|)
name|newcmd
index|[
literal|0
index|]
argument_list|,
operator|(
name|unsigned
operator|)
name|newcmd
index|[
literal|1
index|]
argument_list|,
operator|(
name|unsigned
operator|)
name|newcmd
index|[
literal|2
index|]
argument_list|,
operator|(
name|unsigned
operator|)
name|newcmd
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* 	**	fake the return address (to the patch). 	**	and restart script processor at dispatcher. 	*/
name|np
operator|->
name|profile
operator|.
name|num_break
operator|++
expr_stmt|;
name|OUTL
argument_list|(
name|nc_temp
argument_list|,
name|vtophys
argument_list|(
name|newcmd
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cmd
operator|&
literal|7
operator|)
operator|==
literal|0
condition|)
name|OUTL
argument_list|(
name|nc_dsp
argument_list|,
name|NCB_SCRIPT_PHYS
argument_list|(
name|np
argument_list|,
name|dispatch
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|OUTL
argument_list|(
name|nc_dsp
argument_list|,
name|NCB_SCRIPT_PHYS
argument_list|(
name|np
argument_list|,
name|checkatn
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/*========================================================== ** ** **      ncr chip exception handler for programmed interrupts. ** ** **========================================================== */
specifier|static
name|int
name|ncr_show_msg
parameter_list|(
name|u_char
modifier|*
name|msg
parameter_list|)
block|{
name|u_char
name|i
decl_stmt|;
name|printf
argument_list|(
literal|"%x"
argument_list|,
operator|*
name|msg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|msg
operator|==
name|M_EXTENDED
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|-
literal|1
operator|>
name|msg
index|[
literal|1
index|]
condition|)
break|break;
name|printf
argument_list|(
literal|"-%x"
argument_list|,
name|msg
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
return|return
operator|(
name|i
operator|+
literal|1
operator|)
return|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|*
name|msg
operator|&
literal|0xf0
operator|)
operator|==
literal|0x20
condition|)
block|{
name|printf
argument_list|(
literal|"-%x"
argument_list|,
name|msg
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
literal|2
operator|)
return|;
block|}
empty_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|void
name|ncr_int_sir
parameter_list|(
name|ncb_p
name|np
parameter_list|)
block|{
name|u_char
name|chg
decl_stmt|,
name|ofs
decl_stmt|,
name|per
decl_stmt|,
name|fak
decl_stmt|,
name|wide
decl_stmt|;
name|u_char
name|num
init|=
name|INB
argument_list|(
name|nc_dsps
argument_list|)
decl_stmt|;
name|ccb_p
name|cp
init|=
literal|0
decl_stmt|;
name|u_long
name|dsa
decl_stmt|;
name|u_char
name|target
init|=
name|INB
argument_list|(
name|nc_ctest0
argument_list|)
operator|&
literal|0x0f
decl_stmt|;
name|tcb_p
name|tp
init|=
operator|&
name|np
operator|->
name|target
index|[
name|target
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|DEBUG_FLAGS
operator|&
name|DEBUG_TINY
condition|)
name|printf
argument_list|(
literal|"I#%d"
argument_list|,
name|num
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|num
condition|)
block|{
case|case
name|SIR_SENSE_RESTART
case|:
case|case
name|SIR_STALL_RESTART
case|:
break|break;
default|default:
comment|/* 		**	lookup the ccb 		*/
name|dsa
operator|=
name|INL
argument_list|(
name|nc_dsa
argument_list|)
expr_stmt|;
name|cp
operator|=
operator|&
name|np
operator|->
name|ccb
expr_stmt|;
while|while
condition|(
name|cp
operator|&&
operator|(
name|CCB_PHYS
argument_list|(
name|cp
argument_list|,
name|phys
argument_list|)
operator|!=
name|dsa
operator|)
condition|)
name|cp
operator|=
name|cp
operator|->
name|link_ccb
expr_stmt|;
name|assert
argument_list|(
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cp
condition|)
goto|goto
name|out
goto|;
name|assert
argument_list|(
name|cp
operator|==
name|np
operator|->
name|header
operator|.
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|!=
name|np
operator|->
name|header
operator|.
name|cp
condition|)
goto|goto
name|out
goto|;
block|}
switch|switch
condition|(
name|num
condition|)
block|{
comment|/*-------------------------------------------------------------------- ** **	Processing of interrupted getcc selects ** **-------------------------------------------------------------------- */
case|case
name|SIR_SENSE_RESTART
case|:
comment|/*------------------------------------------ 		**	Script processor is idle. 		**	Look for interrupted "check cond" 		**------------------------------------------ 		*/
if|if
condition|(
name|DEBUG_FLAGS
operator|&
name|DEBUG_RESTART
condition|)
name|printf
argument_list|(
literal|"%s: int#%d"
argument_list|,
name|ncr_name
argument_list|(
name|np
argument_list|)
argument_list|,
name|num
argument_list|)
expr_stmt|;
name|cp
operator|=
operator|(
name|ccb_p
operator|)
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_TARGET
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|DEBUG_FLAGS
operator|&
name|DEBUG_RESTART
condition|)
name|printf
argument_list|(
literal|" t%d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|tp
operator|=
operator|&
name|np
operator|->
name|target
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|DEBUG_FLAGS
operator|&
name|DEBUG_RESTART
condition|)
name|printf
argument_list|(
literal|"+"
argument_list|)
expr_stmt|;
name|cp
operator|=
name|tp
operator|->
name|hold_cp
expr_stmt|;
if|if
condition|(
operator|!
name|cp
condition|)
continue|continue;
if|if
condition|(
name|DEBUG_FLAGS
operator|&
name|DEBUG_RESTART
condition|)
name|printf
argument_list|(
literal|"+"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cp
operator|->
name|host_status
operator|==
name|HS_BUSY
operator|)
operator|&&
operator|(
name|cp
operator|->
name|scsi_status
operator|==
name|S_CHECK_COND
operator|)
condition|)
break|break;
if|if
condition|(
name|DEBUG_FLAGS
operator|&
name|DEBUG_RESTART
condition|)
name|printf
argument_list|(
literal|"- (remove)"
argument_list|)
expr_stmt|;
name|tp
operator|->
name|hold_cp
operator|=
name|cp
operator|=
operator|(
name|ccb_p
operator|)
literal|0
expr_stmt|;
block|}
empty_stmt|;
if|if
condition|(
name|cp
condition|)
block|{
if|if
condition|(
name|DEBUG_FLAGS
operator|&
name|DEBUG_RESTART
condition|)
name|printf
argument_list|(
literal|"+ restart job ..\n"
argument_list|)
expr_stmt|;
name|OUTL
argument_list|(
name|nc_dsa
argument_list|,
name|CCB_PHYS
argument_list|(
name|cp
argument_list|,
name|phys
argument_list|)
argument_list|)
expr_stmt|;
name|OUTL
argument_list|(
name|nc_dsp
argument_list|,
name|NCB_SCRIPT_PHYS
argument_list|(
name|np
argument_list|,
name|getcc
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
empty_stmt|;
comment|/* 		**	no job, resume normal processing 		*/
if|if
condition|(
name|DEBUG_FLAGS
operator|&
name|DEBUG_RESTART
condition|)
name|printf
argument_list|(
literal|" -- remove trap\n"
argument_list|)
expr_stmt|;
name|np
operator|->
name|script
operator|->
name|start0
index|[
literal|0
index|]
operator|=
name|SCR_INT
operator|^
name|IFFALSE
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIR_SENSE_FAILED
case|:
comment|/*------------------------------------------- 		**	While trying to select for 		**	getting the condition code, 		**	a target reselected us. 		**------------------------------------------- 		*/
if|if
condition|(
name|DEBUG_FLAGS
operator|&
name|DEBUG_RESTART
condition|)
block|{
name|PRINT_ADDR
argument_list|(
name|cp
operator|->
name|xfer
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"in getcc reselect by t%d.\n"
argument_list|,
name|INB
argument_list|(
name|nc_ssid
argument_list|)
operator|&
literal|0x0f
argument_list|)
expr_stmt|;
block|}
comment|/* 		**	Mark this job 		*/
name|cp
operator|->
name|host_status
operator|=
name|HS_BUSY
expr_stmt|;
name|cp
operator|->
name|scsi_status
operator|=
name|S_CHECK_COND
expr_stmt|;
name|np
operator|->
name|target
index|[
name|cp
operator|->
name|xfer
operator|->
name|sc_link
operator|->
name|target
index|]
operator|.
name|hold_cp
operator|=
name|cp
expr_stmt|;
comment|/* 		**	And patch code to restart it. 		*/
name|np
operator|->
name|script
operator|->
name|start0
index|[
literal|0
index|]
operator|=
name|SCR_INT
expr_stmt|;
break|break;
comment|/*----------------------------------------------------------------------------- ** **	Was Sie schon immer ueber transfermode negotiation wissen wollten ... ** **	We try to negotiate sync and wide transfer only after **	a successfull inquire command. We look at byte 7 of the **	inquire data to determine the capabilities if the target. ** **	When we try to negotiate, we append the negotiation message **	to the identify and (maybe) simple tag message. **	The host status field is set to HS_NEGOTIATE to mark this **	situation. ** **	If the target doesn't answer this message immidiately **	(as required by the standard), the SIR_NEGO_FAIL interrupt **	will be raised eventually. **	The handler removes the HS_NEGOTIATE status, and sets the **	negotiated value to the default (async / nowide). ** **	If we receive a matching answer immediately, we check it **	for validity, and set the values. ** **	If we receive a Reject message immediately, we assume the **	negotiation has failed, and fall back to standard values. ** **	If we receive a negotiation message while not in HS_NEGOTIATE **	state, it's a target initiated negotiation. We prepare a **	(hopefully) valid answer, set our parameters, and send back  **	this answer to the target. ** **	If the target doesn't fetch the answer (no message out phase), **	we assume the negotiation has failed, and fall back to default **	settings. ** **	When we set the values, we adjust them in all ccbs belonging  **	to this target, in the controller's register, and in the "phys" **	field of the controller's struct ncb. ** **	Possible cases:		   hs  sir   msg_in value  send   goto **	We try try to negotiate: **	-> target doesnt't msgin   NEG FAIL  noop   defa.  -      dispatch **	-> target rejected our msg NEG FAIL  reject defa.  -      dispatch **	-> target answered  (ok)   NEG SYNC  sdtr   set    -      clrack **	-> target answered (!ok)   NEG SYNC  sdtr   defa.  REJ--->msg_bad **	-> target answered  (ok)   NEG WIDE  wdtr   set    -      clrack **	-> target answered (!ok)   NEG WIDE  wdtr   defa.  REJ--->msg_bad **	-> any other msgin	   NEG FAIL  noop   defa.  -      dispatch ** **	Target tries to negotiate: **	-> incoming message	   --- SYNC  sdtr   set    SDTR   - **	-> incoming message	   --- WIDE  wdtr   set    WDTR   - **      We sent our answer: **	-> target doesn't msgout   --- PROTO ?      defa.  -      dispatch ** **----------------------------------------------------------------------------- */
case|case
name|SIR_NEGO_FAILED
case|:
comment|/*------------------------------------------------------- 		** 		**	Negotiation failed. 		**	Target doesn't send an answer message, 		**	or target rejected our message. 		** 		**      Remove negotiation request. 		** 		**------------------------------------------------------- 		*/
name|OUTB
argument_list|(
name|HS_PRT
argument_list|,
name|HS_BUSY
argument_list|)
expr_stmt|;
comment|/* fall through */
case|case
name|SIR_NEGO_PROTO
case|:
comment|/*------------------------------------------------------- 		** 		**	Negotiation failed. 		**	Target doesn't fetch the answer message. 		** 		**------------------------------------------------------- 		*/
if|if
condition|(
name|DEBUG_FLAGS
operator|&
name|DEBUG_NEGO
condition|)
block|{
name|PRINT_ADDR
argument_list|(
name|cp
operator|->
name|xfer
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"negotiation failed sir=%x status=%x.\n"
argument_list|,
name|num
argument_list|,
name|cp
operator|->
name|nego_status
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
comment|/* 		**	any error in negotiation: 		**	fall back to default mode. 		*/
switch|switch
condition|(
name|cp
operator|->
name|nego_status
condition|)
block|{
case|case
name|NS_SYNC
case|:
name|ncr_setsync
argument_list|(
name|np
argument_list|,
name|cp
argument_list|,
literal|0xe0
argument_list|)
expr_stmt|;
break|break;
case|case
name|NS_WIDE
case|:
name|ncr_setwide
argument_list|(
name|np
argument_list|,
name|cp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
empty_stmt|;
name|np
operator|->
name|msgin
index|[
literal|0
index|]
operator|=
name|M_NOOP
expr_stmt|;
name|np
operator|->
name|msgout
index|[
literal|0
index|]
operator|=
name|M_NOOP
expr_stmt|;
name|cp
operator|->
name|nego_status
operator|=
literal|0
expr_stmt|;
name|OUTL
argument_list|(
name|nc_dsp
argument_list|,
name|NCB_SCRIPT_PHYS
argument_list|(
name|np
argument_list|,
name|dispatch
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIR_NEGO_SYNC
case|:
comment|/* 		**	Synchronous request message received. 		*/
if|if
condition|(
name|DEBUG_FLAGS
operator|&
name|DEBUG_NEGO
condition|)
block|{
name|PRINT_ADDR
argument_list|(
name|cp
operator|->
name|xfer
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"sync msgin: "
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|ncr_show_msg
argument_list|(
name|np
operator|->
name|msgin
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|".\n"
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
comment|/* 		**	get requested values. 		*/
name|chg
operator|=
literal|0
expr_stmt|;
name|per
operator|=
name|np
operator|->
name|msgin
index|[
literal|3
index|]
expr_stmt|;
name|ofs
operator|=
name|np
operator|->
name|msgin
index|[
literal|4
index|]
expr_stmt|;
if|if
condition|(
name|ofs
operator|==
literal|0
condition|)
name|per
operator|=
literal|255
expr_stmt|;
comment|/* 		**      if target sends SDTR message, 		**	      it CAN transfer synch. 		*/
if|if
condition|(
name|ofs
condition|)
name|tp
operator|->
name|inqdata
index|[
literal|7
index|]
operator||=
name|INQ7_SYNC
expr_stmt|;
comment|/* 		**	check values against driver limits. 		*/
if|if
condition|(
name|per
operator|<
name|np
operator|->
name|ns_sync
condition|)
block|{
name|chg
operator|=
literal|1
expr_stmt|;
name|per
operator|=
name|np
operator|->
name|ns_sync
expr_stmt|;
block|}
if|if
condition|(
name|per
operator|<
name|tp
operator|->
name|minsync
condition|)
block|{
name|chg
operator|=
literal|1
expr_stmt|;
name|per
operator|=
name|tp
operator|->
name|minsync
expr_stmt|;
block|}
if|if
condition|(
name|ofs
operator|>
name|tp
operator|->
name|maxoffs
condition|)
block|{
name|chg
operator|=
literal|1
expr_stmt|;
name|ofs
operator|=
name|tp
operator|->
name|maxoffs
expr_stmt|;
block|}
comment|/* 		**	Check against controller limits. 		*/
if|if
condition|(
name|ofs
operator|!=
literal|0
condition|)
block|{
name|fak
operator|=
operator|(
literal|4ul
operator|*
name|per
operator|-
literal|1
operator|)
operator|/
name|np
operator|->
name|ns_sync
operator|-
literal|3
expr_stmt|;
if|if
condition|(
name|fak
operator|>
literal|7
condition|)
block|{
name|chg
operator|=
literal|1
expr_stmt|;
name|ofs
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ofs
operator|==
literal|0
condition|)
block|{
name|fak
operator|=
literal|7
expr_stmt|;
name|per
operator|=
literal|0
expr_stmt|;
name|tp
operator|->
name|minsync
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|DEBUG_FLAGS
operator|&
name|DEBUG_NEGO
condition|)
block|{
name|PRINT_ADDR
argument_list|(
name|cp
operator|->
name|xfer
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"sync: per=%d ofs=%d fak=%d chg=%d.\n"
argument_list|,
name|per
argument_list|,
name|ofs
argument_list|,
name|fak
argument_list|,
name|chg
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|INB
argument_list|(
name|HS_PRT
argument_list|)
operator|==
name|HS_NEGOTIATE
condition|)
block|{
name|OUTB
argument_list|(
name|HS_PRT
argument_list|,
name|HS_BUSY
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|cp
operator|->
name|nego_status
condition|)
block|{
case|case
name|NS_SYNC
case|:
comment|/* 				**      This was an answer message 				*/
if|if
condition|(
name|chg
condition|)
block|{
comment|/* 					**	Answer wasn't acceptable. 					*/
name|ncr_setsync
argument_list|(
name|np
argument_list|,
name|cp
argument_list|,
literal|0xe0
argument_list|)
expr_stmt|;
name|OUTL
argument_list|(
name|nc_dsp
argument_list|,
name|NCB_SCRIPT_PHYS
argument_list|(
name|np
argument_list|,
name|msg_bad
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 					**	Answer is ok. 					*/
name|ncr_setsync
argument_list|(
name|np
argument_list|,
name|cp
argument_list|,
operator|(
name|fak
operator|<<
literal|5
operator|)
operator||
name|ofs
argument_list|)
expr_stmt|;
name|OUTL
argument_list|(
name|nc_dsp
argument_list|,
name|NCB_SCRIPT_PHYS
argument_list|(
name|np
argument_list|,
name|clrack
argument_list|)
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
return|return;
case|case
name|NS_WIDE
case|:
name|ncr_setwide
argument_list|(
name|np
argument_list|,
name|cp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
empty_stmt|;
block|}
empty_stmt|;
comment|/* 		**	It was a request. Set value and 		**      prepare an answer message 		*/
name|ncr_setsync
argument_list|(
name|np
argument_list|,
name|cp
argument_list|,
operator|(
name|fak
operator|<<
literal|5
operator|)
operator||
name|ofs
argument_list|)
expr_stmt|;
name|np
operator|->
name|msgout
index|[
literal|0
index|]
operator|=
name|M_EXTENDED
expr_stmt|;
name|np
operator|->
name|msgout
index|[
literal|1
index|]
operator|=
literal|3
expr_stmt|;
name|np
operator|->
name|msgout
index|[
literal|2
index|]
operator|=
name|M_X_SYNC_REQ
expr_stmt|;
name|np
operator|->
name|msgout
index|[
literal|3
index|]
operator|=
name|per
expr_stmt|;
name|np
operator|->
name|msgout
index|[
literal|4
index|]
operator|=
name|ofs
expr_stmt|;
name|cp
operator|->
name|nego_status
operator|=
name|NS_SYNC
expr_stmt|;
if|if
condition|(
name|DEBUG_FLAGS
operator|&
name|DEBUG_NEGO
condition|)
block|{
name|PRINT_ADDR
argument_list|(
name|cp
operator|->
name|xfer
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"sync msgout: "
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|ncr_show_msg
argument_list|(
name|np
operator|->
name|msgout
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|".\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|ofs
condition|)
block|{
name|OUTL
argument_list|(
name|nc_dsp
argument_list|,
name|NCB_SCRIPT_PHYS
argument_list|(
name|np
argument_list|,
name|msg_bad
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|np
operator|->
name|msgin
index|[
literal|0
index|]
operator|=
name|M_NOOP
expr_stmt|;
break|break;
case|case
name|SIR_NEGO_WIDE
case|:
comment|/* 		**	Wide request message received. 		*/
if|if
condition|(
name|DEBUG_FLAGS
operator|&
name|DEBUG_NEGO
condition|)
block|{
name|PRINT_ADDR
argument_list|(
name|cp
operator|->
name|xfer
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"wide msgin: "
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|ncr_show_msg
argument_list|(
name|np
operator|->
name|msgin
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|".\n"
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
comment|/* 		**	get requested values. 		*/
name|chg
operator|=
literal|0
expr_stmt|;
name|wide
operator|=
name|np
operator|->
name|msgin
index|[
literal|3
index|]
expr_stmt|;
comment|/* 		**      if target sends WDTR message, 		**	      it CAN transfer wide. 		*/
if|if
condition|(
name|wide
condition|)
name|tp
operator|->
name|inqdata
index|[
literal|7
index|]
operator||=
name|INQ7_WIDE16
expr_stmt|;
comment|/* 		**	check values against driver limits. 		*/
if|if
condition|(
name|wide
operator|>
name|tp
operator|->
name|usrwide
condition|)
block|{
name|chg
operator|=
literal|1
expr_stmt|;
name|wide
operator|=
name|tp
operator|->
name|usrwide
expr_stmt|;
block|}
if|if
condition|(
name|DEBUG_FLAGS
operator|&
name|DEBUG_NEGO
condition|)
block|{
name|PRINT_ADDR
argument_list|(
name|cp
operator|->
name|xfer
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"wide: wide=%d chg=%d.\n"
argument_list|,
name|wide
argument_list|,
name|chg
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|INB
argument_list|(
name|HS_PRT
argument_list|)
operator|==
name|HS_NEGOTIATE
condition|)
block|{
name|OUTB
argument_list|(
name|HS_PRT
argument_list|,
name|HS_BUSY
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|cp
operator|->
name|nego_status
condition|)
block|{
case|case
name|NS_WIDE
case|:
comment|/* 				**      This was an answer message 				*/
if|if
condition|(
name|chg
condition|)
block|{
comment|/* 					**	Answer wasn't acceptable. 					*/
name|ncr_setwide
argument_list|(
name|np
argument_list|,
name|cp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OUTL
argument_list|(
name|nc_dsp
argument_list|,
name|NCB_SCRIPT_PHYS
argument_list|(
name|np
argument_list|,
name|msg_bad
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 					**	Answer is ok. 					*/
name|ncr_setwide
argument_list|(
name|np
argument_list|,
name|cp
argument_list|,
name|wide
argument_list|)
expr_stmt|;
name|OUTL
argument_list|(
name|nc_dsp
argument_list|,
name|NCB_SCRIPT_PHYS
argument_list|(
name|np
argument_list|,
name|clrack
argument_list|)
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
return|return;
case|case
name|NS_SYNC
case|:
name|ncr_setsync
argument_list|(
name|np
argument_list|,
name|cp
argument_list|,
literal|0xe0
argument_list|)
expr_stmt|;
break|break;
block|}
empty_stmt|;
block|}
empty_stmt|;
comment|/* 		**	It was a request, set value and 		**      prepare an answer message 		*/
name|ncr_setwide
argument_list|(
name|np
argument_list|,
name|cp
argument_list|,
name|wide
argument_list|)
expr_stmt|;
name|np
operator|->
name|msgout
index|[
literal|0
index|]
operator|=
name|M_EXTENDED
expr_stmt|;
name|np
operator|->
name|msgout
index|[
literal|1
index|]
operator|=
literal|2
expr_stmt|;
name|np
operator|->
name|msgout
index|[
literal|2
index|]
operator|=
name|M_X_WIDE_REQ
expr_stmt|;
name|np
operator|->
name|msgout
index|[
literal|3
index|]
operator|=
name|wide
expr_stmt|;
name|np
operator|->
name|msgin
index|[
literal|0
index|]
operator|=
name|M_NOOP
expr_stmt|;
name|cp
operator|->
name|nego_status
operator|=
name|NS_WIDE
expr_stmt|;
if|if
condition|(
name|DEBUG_FLAGS
operator|&
name|DEBUG_NEGO
condition|)
block|{
name|PRINT_ADDR
argument_list|(
name|cp
operator|->
name|xfer
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"wide msgout: "
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|ncr_show_msg
argument_list|(
name|np
operator|->
name|msgout
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|".\n"
argument_list|)
expr_stmt|;
block|}
break|break;
comment|/*-------------------------------------------------------------------- ** **	Processing of special messages ** **-------------------------------------------------------------------- */
case|case
name|SIR_REJECT_RECEIVED
case|:
comment|/*----------------------------------------------- 		** 		**	We received a M_REJECT message. 		** 		**----------------------------------------------- 		*/
name|PRINT_ADDR
argument_list|(
name|cp
operator|->
name|xfer
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"M_REJECT received (%x:%x).\n"
argument_list|,
operator|(
name|unsigned
operator|)
name|np
operator|->
name|lastmsg
argument_list|,
name|np
operator|->
name|msgout
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIR_REJECT_SENT
case|:
comment|/*----------------------------------------------- 		** 		**	We received an unknown message 		** 		**----------------------------------------------- 		*/
name|PRINT_ADDR
argument_list|(
name|cp
operator|->
name|xfer
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"M_REJECT sent for "
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|ncr_show_msg
argument_list|(
name|np
operator|->
name|msgin
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|".\n"
argument_list|)
expr_stmt|;
break|break;
comment|/*-------------------------------------------------------------------- ** **	Processing of special messages ** **-------------------------------------------------------------------- */
case|case
name|SIR_IGN_RESIDUE
case|:
comment|/*----------------------------------------------- 		** 		**	We received an IGNORE RESIDUE message, 		**	which couldn't be handled by the script. 		** 		**----------------------------------------------- 		*/
name|PRINT_ADDR
argument_list|(
name|cp
operator|->
name|xfer
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"M_IGN_RESIDUE received, but not yet implemented.\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIR_MISSING_SAVE
case|:
comment|/*----------------------------------------------- 		** 		**	We received an DISCONNECT message, 		**	but the datapointer wasn't saved before. 		** 		**----------------------------------------------- 		*/
name|PRINT_ADDR
argument_list|(
name|cp
operator|->
name|xfer
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"M_DISCONNECT received, but datapointer not saved:\n"
literal|"\tdata=%x save=%x goal=%x.\n"
argument_list|,
operator|(
name|unsigned
operator|)
name|INL
argument_list|(
name|nc_temp
argument_list|)
argument_list|,
operator|(
name|unsigned
operator|)
name|np
operator|->
name|header
operator|.
name|savep
argument_list|,
operator|(
name|unsigned
operator|)
name|np
operator|->
name|header
operator|.
name|goalp
argument_list|)
expr_stmt|;
break|break;
comment|/*-------------------------------------------------------------------- ** **	Processing of a "S_QUEUE_FULL" status. ** **	The current command has been rejected, **	because there are too many in the command queue. **	We have started too many commands for that target. ** **	If possible, reinsert at head of queue. **	Stall queue until there are no disconnected jobs **	(ncr is REALLY idle). Then restart processing. ** **	We should restart the current job after the controller **	has become idle. But this is not yet implemented. ** **-------------------------------------------------------------------- */
case|case
name|SIR_STALL_QUEUE
case|:
comment|/*----------------------------------------------- 		** 		**	Stall the start queue. 		** 		**----------------------------------------------- 		*/
name|PRINT_ADDR
argument_list|(
name|cp
operator|->
name|xfer
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"queue full.\n"
argument_list|)
expr_stmt|;
name|np
operator|->
name|script
operator|->
name|start1
index|[
literal|0
index|]
operator|=
name|SCR_INT
expr_stmt|;
comment|/* 		**	Try to disable tagged transfers. 		*/
name|ncr_setmaxtags
argument_list|(
operator|&
name|np
operator|->
name|target
index|[
name|target
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 		** @QUEUE@ 		** 		**	Should update the launch field of the 		**	current job to be able to restart it. 		**	Then prepend it to the start queue. 		*/
comment|/* fall through */
case|case
name|SIR_STALL_RESTART
case|:
comment|/*----------------------------------------------- 		** 		**	Enable selecting again, 		**	if NO disconnected jobs. 		** 		**----------------------------------------------- 		*/
comment|/* 		**	Look for a disconnected job. 		*/
name|cp
operator|=
operator|&
name|np
operator|->
name|ccb
expr_stmt|;
while|while
condition|(
name|cp
operator|&&
name|cp
operator|->
name|host_status
operator|!=
name|HS_DISCONNECT
condition|)
name|cp
operator|=
name|cp
operator|->
name|link_ccb
expr_stmt|;
comment|/* 		**	if there is one, ... 		*/
if|if
condition|(
name|cp
condition|)
block|{
comment|/* 			**	wait for reselection 			*/
name|OUTL
argument_list|(
name|nc_dsp
argument_list|,
name|NCB_SCRIPT_PHYS
argument_list|(
name|np
argument_list|,
name|reselect
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
empty_stmt|;
comment|/* 		**	else remove the interrupt. 		*/
name|printf
argument_list|(
literal|"%s: queue empty.\n"
argument_list|,
name|ncr_name
argument_list|(
name|np
argument_list|)
argument_list|)
expr_stmt|;
name|np
operator|->
name|script
operator|->
name|start1
index|[
literal|0
index|]
operator|=
name|SCR_INT
operator|^
name|IFFALSE
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
empty_stmt|;
name|out
label|:
name|OUTB
argument_list|(
name|nc_dcntl
argument_list|,
operator|(
name|STD
operator||
name|NOCOM
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/*========================================================== ** ** **	Aquire a control block ** ** **========================================================== */
specifier|static
name|ccb_p
name|ncr_get_ccb
parameter_list|(
name|ncb_p
name|np
parameter_list|,
name|u_long
name|flags
parameter_list|,
name|u_long
name|target
parameter_list|,
name|u_long
name|lun
parameter_list|)
block|{
name|lcb_p
name|lp
decl_stmt|;
name|ccb_p
name|cp
init|=
operator|(
name|ccb_p
operator|)
literal|0
decl_stmt|;
comment|/* 	**	Lun structure available ? 	*/
name|lp
operator|=
name|np
operator|->
name|target
index|[
name|target
index|]
operator|.
name|lp
index|[
name|lun
index|]
expr_stmt|;
if|if
condition|(
name|lp
condition|)
block|{
name|cp
operator|=
name|lp
operator|->
name|next_ccb
expr_stmt|;
comment|/* 		**	Look for free CCB 		*/
while|while
condition|(
name|cp
operator|&&
name|cp
operator|->
name|magic
condition|)
name|cp
operator|=
name|cp
operator|->
name|next_ccb
expr_stmt|;
block|}
comment|/* 	**	if nothing available, take the default. 	*/
if|if
condition|(
operator|!
name|cp
condition|)
name|cp
operator|=
operator|&
name|np
operator|->
name|ccb
expr_stmt|;
comment|/* 	**	Wait until available. 	*/
while|while
condition|(
name|cp
operator|->
name|magic
condition|)
block|{
if|if
condition|(
name|flags
operator|&
name|SCSI_NOSLEEP
condition|)
break|break;
if|if
condition|(
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
name|cp
argument_list|,
name|PRIBIO
operator||
name|PCATCH
argument_list|,
literal|"ncr"
argument_list|,
literal|0
argument_list|)
condition|)
break|break;
block|}
empty_stmt|;
if|if
condition|(
name|cp
operator|->
name|magic
condition|)
return|return
operator|(
operator|(
name|ccb_p
operator|)
literal|0
operator|)
return|;
name|cp
operator|->
name|magic
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|cp
operator|)
return|;
block|}
comment|/*========================================================== ** ** **	Release one control block ** ** **========================================================== */
name|void
name|ncr_free_ccb
parameter_list|(
name|ncb_p
name|np
parameter_list|,
name|ccb_p
name|cp
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
comment|/* 	**    sanity 	*/
name|assert
argument_list|(
name|cp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|cp
operator|->
name|host_status
operator|=
name|HS_IDLE
expr_stmt|;
name|cp
operator|->
name|magic
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|cp
operator|==
operator|&
name|np
operator|->
name|ccb
condition|)
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
name|cp
argument_list|)
expr_stmt|;
block|}
comment|/*========================================================== ** ** **      Allocation of resources for Targets/Luns/Tags. ** ** **========================================================== */
specifier|static
name|void
name|ncr_alloc_ccb
parameter_list|(
name|ncb_p
name|np
parameter_list|,
name|u_long
name|target
parameter_list|,
name|u_long
name|lun
parameter_list|)
block|{
name|tcb_p
name|tp
decl_stmt|;
name|lcb_p
name|lp
decl_stmt|;
name|ccb_p
name|cp
decl_stmt|;
name|assert
argument_list|(
name|np
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
operator|>=
name|MAX_TARGET
condition|)
return|return;
if|if
condition|(
name|lun
operator|>=
name|MAX_LUN
condition|)
return|return;
name|tp
operator|=
operator|&
name|np
operator|->
name|target
index|[
name|target
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|tp
operator|->
name|jump_tcb
operator|.
name|l_cmd
condition|)
block|{
comment|/* 		**	initialize it. 		*/
name|tp
operator|->
name|jump_tcb
operator|.
name|l_cmd
operator|=
operator|(
name|SCR_JUMP
operator|^
name|IFFALSE
argument_list|(
name|DATA
argument_list|(
literal|0x80
operator|+
name|target
argument_list|)
argument_list|)
operator|)
expr_stmt|;
name|tp
operator|->
name|jump_tcb
operator|.
name|l_paddr
operator|=
name|np
operator|->
name|jump_tcb
operator|.
name|l_paddr
expr_stmt|;
name|tp
operator|->
name|getscr
index|[
literal|0
index|]
operator|=
name|SCR_COPY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|tp
operator|->
name|getscr
index|[
literal|1
index|]
operator|=
name|vtophys
argument_list|(
operator|&
name|tp
operator|->
name|sval
argument_list|)
expr_stmt|;
name|tp
operator|->
name|getscr
index|[
literal|2
index|]
operator|=
name|np
operator|->
name|paddr
operator|+
name|offsetof
argument_list|(
expr|struct
name|ncr_reg
argument_list|,
name|nc_sxfer
argument_list|)
expr_stmt|;
name|tp
operator|->
name|getscr
index|[
literal|3
index|]
operator|=
name|SCR_COPY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|tp
operator|->
name|getscr
index|[
literal|4
index|]
operator|=
name|vtophys
argument_list|(
operator|&
name|tp
operator|->
name|wval
argument_list|)
expr_stmt|;
name|tp
operator|->
name|getscr
index|[
literal|5
index|]
operator|=
name|np
operator|->
name|paddr
operator|+
name|offsetof
argument_list|(
expr|struct
name|ncr_reg
argument_list|,
name|nc_scntl3
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|(
operator|(
name|offsetof
argument_list|(
expr|struct
name|ncr_reg
argument_list|,
name|nc_sxfer
argument_list|)
operator|^
name|offsetof
argument_list|(
expr|struct
name|tcb
argument_list|,
name|sval
argument_list|)
operator|)
operator|&
literal|3
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|(
operator|(
name|offsetof
argument_list|(
expr|struct
name|ncr_reg
argument_list|,
name|nc_scntl3
argument_list|)
operator|^
name|offsetof
argument_list|(
expr|struct
name|tcb
argument_list|,
name|wval
argument_list|)
operator|)
operator|&
literal|3
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|tp
operator|->
name|call_lun
operator|.
name|l_cmd
operator|=
operator|(
name|SCR_CALL
operator|)
expr_stmt|;
name|tp
operator|->
name|call_lun
operator|.
name|l_paddr
operator|=
name|NCB_SCRIPT_PHYS
argument_list|(
name|np
argument_list|,
name|resel_lun
argument_list|)
expr_stmt|;
name|tp
operator|->
name|jump_lcb
operator|.
name|l_cmd
operator|=
operator|(
name|SCR_JUMP
operator|)
expr_stmt|;
name|tp
operator|->
name|jump_lcb
operator|.
name|l_paddr
operator|=
name|NCB_SCRIPT_PHYS
argument_list|(
name|np
argument_list|,
name|abort
argument_list|)
expr_stmt|;
name|np
operator|->
name|jump_tcb
operator|.
name|l_paddr
operator|=
name|vtophys
argument_list|(
operator|&
name|tp
operator|->
name|jump_tcb
argument_list|)
expr_stmt|;
name|ncr_setmaxtags
argument_list|(
name|tp
argument_list|,
name|SCSI_NCR_DFLT_TAGS
argument_list|)
expr_stmt|;
block|}
comment|/* 	**	Logic unit control block 	*/
name|lp
operator|=
name|tp
operator|->
name|lp
index|[
name|lun
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|lp
condition|)
block|{
comment|/* 		**	Allocate a lcb 		*/
name|lp
operator|=
operator|(
name|lcb_p
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|lcb
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|lp
condition|)
return|return;
comment|/* 		**	Initialize it 		*/
name|bzero
argument_list|(
name|lp
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|lp
argument_list|)
argument_list|)
expr_stmt|;
name|lp
operator|->
name|jump_lcb
operator|.
name|l_cmd
operator|=
operator|(
name|SCR_JUMP
operator|^
name|IFFALSE
argument_list|(
name|DATA
argument_list|(
name|lun
argument_list|)
argument_list|)
operator|)
expr_stmt|;
name|lp
operator|->
name|jump_lcb
operator|.
name|l_paddr
operator|=
name|tp
operator|->
name|jump_lcb
operator|.
name|l_paddr
expr_stmt|;
name|lp
operator|->
name|call_tag
operator|.
name|l_cmd
operator|=
operator|(
name|SCR_CALL
operator|)
expr_stmt|;
name|lp
operator|->
name|call_tag
operator|.
name|l_paddr
operator|=
name|NCB_SCRIPT_PHYS
argument_list|(
name|np
argument_list|,
name|resel_tag
argument_list|)
expr_stmt|;
name|lp
operator|->
name|jump_ccb
operator|.
name|l_cmd
operator|=
operator|(
name|SCR_JUMP
operator|)
expr_stmt|;
name|lp
operator|->
name|jump_ccb
operator|.
name|l_paddr
operator|=
name|NCB_SCRIPT_PHYS
argument_list|(
name|np
argument_list|,
name|aborttag
argument_list|)
expr_stmt|;
name|lp
operator|->
name|actlink
operator|=
literal|1
expr_stmt|;
comment|/* 		**   Chain into LUN list 		*/
name|tp
operator|->
name|jump_lcb
operator|.
name|l_paddr
operator|=
name|vtophys
argument_list|(
operator|&
name|lp
operator|->
name|jump_lcb
argument_list|)
expr_stmt|;
name|tp
operator|->
name|lp
index|[
name|lun
index|]
operator|=
name|lp
expr_stmt|;
block|}
comment|/* 	**	Limit possible number of ccbs. 	** 	**	If tagged command queueing is enabled, 	**	can use more than one ccb. 	*/
if|if
condition|(
name|np
operator|->
name|actccbs
operator|>=
name|MAX_START
operator|-
literal|2
condition|)
return|return;
if|if
condition|(
name|lp
operator|->
name|actccbs
operator|&&
operator|(
name|lp
operator|->
name|actccbs
operator|>=
name|lp
operator|->
name|reqccbs
operator|)
condition|)
return|return;
comment|/* 	**	Allocate a ccb 	*/
name|cp
operator|=
operator|(
name|ccb_p
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ccb
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cp
condition|)
return|return;
if|if
condition|(
name|DEBUG_FLAGS
operator|&
name|DEBUG_ALLOC
condition|)
block|{
name|printf
argument_list|(
literal|"new ccb @%x.\n"
argument_list|,
operator|(
name|unsigned
operator|)
name|cp
argument_list|)
expr_stmt|;
block|}
comment|/* 	**	Count it 	*/
name|lp
operator|->
name|actccbs
operator|++
expr_stmt|;
name|np
operator|->
name|actccbs
operator|++
expr_stmt|;
comment|/* 	**	Initialize it 	*/
name|bzero
argument_list|(
name|cp
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|cp
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	**	Fill in physical addresses 	*/
name|cp
operator|->
name|p_ccb
operator|=
name|vtophys
argument_list|(
name|cp
argument_list|)
expr_stmt|;
comment|/* 	**	Chain into reselect list 	*/
name|cp
operator|->
name|jump_ccb
operator|.
name|l_cmd
operator|=
name|SCR_JUMP
expr_stmt|;
name|cp
operator|->
name|jump_ccb
operator|.
name|l_paddr
operator|=
name|lp
operator|->
name|jump_ccb
operator|.
name|l_paddr
expr_stmt|;
name|lp
operator|->
name|jump_ccb
operator|.
name|l_paddr
operator|=
name|CCB_PHYS
argument_list|(
name|cp
argument_list|,
name|jump_ccb
argument_list|)
expr_stmt|;
name|cp
operator|->
name|call_tmp
operator|.
name|l_cmd
operator|=
name|SCR_CALL
expr_stmt|;
name|cp
operator|->
name|call_tmp
operator|.
name|l_paddr
operator|=
name|NCB_SCRIPT_PHYS
argument_list|(
name|np
argument_list|,
name|resel_tmp
argument_list|)
expr_stmt|;
comment|/* 	**	Chain into wakeup list 	*/
name|cp
operator|->
name|link_ccb
operator|=
name|np
operator|->
name|ccb
operator|.
name|link_ccb
expr_stmt|;
name|np
operator|->
name|ccb
operator|.
name|link_ccb
operator|=
name|cp
expr_stmt|;
comment|/* 	**	Chain into CCB list 	*/
name|cp
operator|->
name|next_ccb
operator|=
name|lp
operator|->
name|next_ccb
expr_stmt|;
name|lp
operator|->
name|next_ccb
operator|=
name|cp
expr_stmt|;
block|}
comment|/*========================================================== ** ** **	Announce the number of ccbs/tags to the scsi driver. ** ** **========================================================== */
specifier|static
name|void
name|ncr_opennings
parameter_list|(
name|ncb_p
name|np
parameter_list|,
name|lcb_p
name|lp
parameter_list|,
name|struct
name|scsi_xfer
modifier|*
name|xp
parameter_list|)
block|{
comment|/* 	**	want to reduce the number ... 	*/
if|if
condition|(
name|lp
operator|->
name|actlink
operator|>
name|lp
operator|->
name|reqlink
condition|)
block|{
comment|/* 		**	Try to  reduce the count. 		**	We assume to run at splbio .. 		*/
name|u_char
name|diff
init|=
name|lp
operator|->
name|actlink
operator|-
name|lp
operator|->
name|reqlink
decl_stmt|;
if|if
condition|(
operator|!
name|diff
condition|)
return|return;
ifdef|#
directive|ifdef
name|__NetBSD__
if|if
condition|(
name|diff
operator|>
name|xp
operator|->
name|sc_link
operator|->
name|openings
condition|)
name|diff
operator|=
name|xp
operator|->
name|sc_link
operator|->
name|openings
expr_stmt|;
name|xp
operator|->
name|sc_link
operator|->
name|openings
operator|-=
name|diff
expr_stmt|;
else|#
directive|else
comment|/* !__NetBSD__ */
if|if
condition|(
name|diff
operator|>
name|xp
operator|->
name|sc_link
operator|->
name|opennings
condition|)
name|diff
operator|=
name|xp
operator|->
name|sc_link
operator|->
name|opennings
expr_stmt|;
name|xp
operator|->
name|sc_link
operator|->
name|opennings
operator|-=
name|diff
expr_stmt|;
endif|#
directive|endif
comment|/* __NetBSD__ */
name|lp
operator|->
name|actlink
operator|-=
name|diff
expr_stmt|;
if|if
condition|(
name|DEBUG_FLAGS
operator|&
name|DEBUG_TAGS
condition|)
name|printf
argument_list|(
literal|"%s: actlink: diff=%d, new=%d, req=%d\n"
argument_list|,
name|ncr_name
argument_list|(
name|np
argument_list|)
argument_list|,
name|diff
argument_list|,
name|lp
operator|->
name|actlink
argument_list|,
name|lp
operator|->
name|reqlink
argument_list|)
expr_stmt|;
return|return;
block|}
empty_stmt|;
comment|/* 	**	want to increase the number ? 	*/
if|if
condition|(
name|lp
operator|->
name|reqlink
operator|>
name|lp
operator|->
name|actlink
condition|)
block|{
name|u_char
name|diff
init|=
name|lp
operator|->
name|reqlink
operator|-
name|lp
operator|->
name|actlink
decl_stmt|;
ifdef|#
directive|ifdef
name|__NetBSD__
name|xp
operator|->
name|sc_link
operator|->
name|openings
operator|+=
name|diff
expr_stmt|;
else|#
directive|else
comment|/* !__NetBSD__ */
name|xp
operator|->
name|sc_link
operator|->
name|opennings
operator|+=
name|diff
expr_stmt|;
endif|#
directive|endif
comment|/* __NetBSD__ */
name|lp
operator|->
name|actlink
operator|+=
name|diff
expr_stmt|;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
name|xp
operator|->
name|sc_link
argument_list|)
expr_stmt|;
if|if
condition|(
name|DEBUG_FLAGS
operator|&
name|DEBUG_TAGS
condition|)
name|printf
argument_list|(
literal|"%s: actlink: diff=%d, new=%d, req=%d\n"
argument_list|,
name|ncr_name
argument_list|(
name|np
argument_list|)
argument_list|,
name|diff
argument_list|,
name|lp
operator|->
name|actlink
argument_list|,
name|lp
operator|->
name|reqlink
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
block|}
comment|/*========================================================== ** ** **	Build Scatter Gather Block ** ** **========================================================== ** **	The transfer area may be scattered among **	several non adjacent physical pages. ** **	We may use MAX_SCATTER blocks. ** **---------------------------------------------------------- */
specifier|static
name|int
name|ncr_scatter
parameter_list|(
name|struct
name|dsb
modifier|*
name|phys
parameter_list|,
name|vm_offset_t
name|vaddr
parameter_list|,
name|vm_size_t
name|datalen
parameter_list|)
block|{
name|u_long
name|paddr
decl_stmt|,
name|pnext
decl_stmt|;
name|u_short
name|segment
init|=
literal|0
decl_stmt|;
name|u_long
name|segsize
decl_stmt|,
name|segaddr
decl_stmt|;
name|u_long
name|size
decl_stmt|,
name|csize
init|=
literal|0
decl_stmt|;
name|u_long
name|chunk
init|=
name|MAX_SIZE
decl_stmt|;
name|int
name|free
decl_stmt|;
name|bzero
argument_list|(
operator|&
name|phys
operator|->
name|data
argument_list|,
sizeof|sizeof
argument_list|(
name|phys
operator|->
name|data
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|datalen
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|paddr
operator|=
name|vtophys
argument_list|(
name|vaddr
argument_list|)
expr_stmt|;
comment|/* 	**	insert extra break points at a distance of chunk. 	**	We try to reduce the number of interrupts caused 	**	by unexpected phase changes due to disconnects. 	**	A typical harddisk may disconnect before ANY block. 	**	If we wanted to avoid unexpected phase changes at all 	**	we had to use a break point every 512 bytes. 	**	Of course the number of scatter/gather blocks is 	**	limited. 	*/
name|free
operator|=
name|MAX_SCATTER
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|vaddr
operator|&
name|PAGE_MASK
condition|)
name|free
operator|-=
name|datalen
operator|/
name|PAGE_SIZE
expr_stmt|;
if|if
condition|(
name|free
operator|>
literal|1
condition|)
while|while
condition|(
operator|(
name|chunk
operator|*
name|free
operator|>=
literal|2
operator|*
name|datalen
operator|)
operator|&&
operator|(
name|chunk
operator|>=
literal|1024
operator|)
condition|)
name|chunk
operator|/=
literal|2
expr_stmt|;
if|if
condition|(
name|DEBUG_FLAGS
operator|&
name|DEBUG_SCATTER
condition|)
name|printf
argument_list|(
literal|"ncr?:\tscattering virtual=0x%x size=%d chunk=%d.\n"
argument_list|,
operator|(
name|unsigned
operator|)
name|vaddr
argument_list|,
operator|(
name|unsigned
operator|)
name|datalen
argument_list|,
operator|(
name|unsigned
operator|)
name|chunk
argument_list|)
expr_stmt|;
comment|/* 	**   Build data descriptors. 	*/
while|while
condition|(
name|datalen
operator|&&
operator|(
name|segment
operator|<
name|MAX_SCATTER
operator|)
condition|)
block|{
comment|/* 		**	this segment is empty 		*/
name|segsize
operator|=
literal|0
expr_stmt|;
name|segaddr
operator|=
name|paddr
expr_stmt|;
name|pnext
operator|=
name|paddr
expr_stmt|;
if|if
condition|(
operator|!
name|csize
condition|)
name|csize
operator|=
name|chunk
expr_stmt|;
while|while
condition|(
operator|(
name|datalen
operator|)
operator|&&
operator|(
name|paddr
operator|==
name|pnext
operator|)
operator|&&
operator|(
name|csize
operator|)
condition|)
block|{
comment|/* 			**	continue this segment 			*/
name|pnext
operator|=
operator|(
name|paddr
operator|&
operator|(
operator|~
name|PAGE_MASK
operator|)
operator|)
operator|+
name|PAGE_SIZE
expr_stmt|;
comment|/* 			**	Compute max size 			*/
name|size
operator|=
name|pnext
operator|-
name|paddr
expr_stmt|;
comment|/* page size */
if|if
condition|(
name|size
operator|>
name|datalen
condition|)
name|size
operator|=
name|datalen
expr_stmt|;
comment|/* data size */
if|if
condition|(
name|size
operator|>
name|csize
condition|)
name|size
operator|=
name|csize
expr_stmt|;
comment|/* chunksize */
name|segsize
operator|+=
name|size
expr_stmt|;
name|vaddr
operator|+=
name|size
expr_stmt|;
name|csize
operator|-=
name|size
expr_stmt|;
name|datalen
operator|-=
name|size
expr_stmt|;
name|paddr
operator|=
name|vtophys
argument_list|(
name|vaddr
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
if|if
condition|(
name|DEBUG_FLAGS
operator|&
name|DEBUG_SCATTER
condition|)
name|printf
argument_list|(
literal|"\tseg #%d  addr=%x  size=%d  (rest=%d).\n"
argument_list|,
name|segment
argument_list|,
operator|(
name|unsigned
operator|)
name|segaddr
argument_list|,
operator|(
name|unsigned
operator|)
name|segsize
argument_list|,
operator|(
name|unsigned
operator|)
name|datalen
argument_list|)
expr_stmt|;
name|phys
operator|->
name|data
index|[
name|segment
index|]
operator|.
name|addr
operator|=
name|segaddr
expr_stmt|;
name|phys
operator|->
name|data
index|[
name|segment
index|]
operator|.
name|size
operator|=
name|segsize
expr_stmt|;
name|segment
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|datalen
condition|)
block|{
name|printf
argument_list|(
literal|"ncr?: scatter/gather failed (residue=%d).\n"
argument_list|,
operator|(
name|unsigned
operator|)
name|datalen
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
empty_stmt|;
return|return
operator|(
name|segment
operator|)
return|;
block|}
comment|/*========================================================== ** ** **	Test the pci bus snoop logic :-( ** **	Has to be called with interrupts disabled. ** ** **========================================================== */
ifndef|#
directive|ifndef
name|NCR_IOMAPPED
specifier|static
name|int
name|ncr_regtest
parameter_list|(
name|struct
name|ncb
modifier|*
name|np
parameter_list|)
block|{
specifier|register
specifier|volatile
name|u_long
name|data
decl_stmt|,
modifier|*
name|addr
decl_stmt|;
comment|/* 	**	ncr registers may NOT be cached. 	**	write 0xffffffff to a read only register area, 	**	and try to read it back. 	*/
name|addr
operator|=
operator|(
specifier|volatile
name|u_long
operator|*
operator|)
operator|&
name|np
operator|->
name|reg
operator|->
name|nc_dstat
expr_stmt|;
name|data
operator|=
literal|0xffffffff
expr_stmt|;
operator|*
name|addr
operator|=
name|data
expr_stmt|;
name|data
operator|=
operator|*
name|addr
expr_stmt|;
if|#
directive|if
literal|1
if|if
condition|(
name|data
operator|==
literal|0xffffffff
condition|)
block|{
else|#
directive|else
if|if
condition|(
operator|(
name|data
operator|&
literal|0xe2f0fffd
operator|)
operator|!=
literal|0x02000080
condition|)
block|{
endif|#
directive|endif
name|printf
argument_list|(
literal|"CACHE TEST FAILED: reg dstat-sstat2 readback %x.\n"
argument_list|,
operator|(
name|unsigned
operator|)
name|data
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0x10
operator|)
return|;
block|}
empty_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
endif|#
directive|endif
specifier|static
name|int
name|ncr_snooptest
parameter_list|(
name|struct
name|ncb
modifier|*
name|np
parameter_list|)
block|{
name|u_long
name|ncr_rd
decl_stmt|,
name|ncr_wr
decl_stmt|,
name|ncr_bk
decl_stmt|,
name|host_rd
decl_stmt|,
name|host_wr
decl_stmt|,
name|pc
decl_stmt|,
name|err
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
ifndef|#
directive|ifndef
name|NCR_IOMAPPED
name|err
operator||=
name|ncr_regtest
argument_list|(
name|np
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
endif|#
directive|endif
comment|/* 	**	init 	*/
name|pc
operator|=
name|NCB_SCRIPT_PHYS
argument_list|(
name|np
argument_list|,
name|snooptest
argument_list|)
expr_stmt|;
name|host_wr
operator|=
literal|1
expr_stmt|;
name|ncr_wr
operator|=
literal|2
expr_stmt|;
comment|/* 	**	Set memory and register. 	*/
name|ncr_cache
operator|=
name|host_wr
expr_stmt|;
name|OUTL
argument_list|(
name|nc_temp
argument_list|,
name|ncr_wr
argument_list|)
expr_stmt|;
comment|/* 	**	Start script (exchange values) 	*/
name|OUTL
argument_list|(
name|nc_dsp
argument_list|,
name|pc
argument_list|)
expr_stmt|;
comment|/* 	**	Wait 'til done (with timeout) 	*/
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NCR_SNOOP_TIMEOUT
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|INB
argument_list|(
name|nc_istat
argument_list|)
operator|&
operator|(
name|INTF
operator||
name|SIP
operator||
name|DIP
operator|)
condition|)
break|break;
comment|/* 	**	Save termination position. 	*/
name|pc
operator|=
name|INL
argument_list|(
name|nc_dsp
argument_list|)
expr_stmt|;
comment|/* 	**	Read memory and register. 	*/
name|host_rd
operator|=
name|ncr_cache
expr_stmt|;
name|ncr_rd
operator|=
name|INL
argument_list|(
name|nc_scratcha
argument_list|)
expr_stmt|;
name|ncr_bk
operator|=
name|INL
argument_list|(
name|nc_temp
argument_list|)
expr_stmt|;
comment|/* 	**	Reset ncr chip 	*/
name|OUTB
argument_list|(
name|nc_istat
argument_list|,
name|SRST
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
name|nc_istat
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	**	check for timeout 	*/
if|if
condition|(
name|i
operator|>=
name|NCR_SNOOP_TIMEOUT
condition|)
block|{
name|printf
argument_list|(
literal|"CACHE TEST FAILED: timeout.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0x20
operator|)
return|;
block|}
empty_stmt|;
comment|/* 	**	Check termination position. 	*/
if|if
condition|(
name|pc
operator|!=
name|NCB_SCRIPT_PHYS
argument_list|(
name|np
argument_list|,
name|snoopend
argument_list|)
operator|+
literal|8
condition|)
block|{
name|printf
argument_list|(
literal|"CACHE TEST FAILED: script execution failed.\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\tstart=%08x, pc=%08x, end=%08x\n"
argument_list|,
name|NCB_SCRIPT_PHYS
argument_list|(
name|np
argument_list|,
name|snooptest
argument_list|)
argument_list|,
name|pc
argument_list|,
name|NCB_SCRIPT_PHYS
argument_list|(
name|np
argument_list|,
name|snoopend
argument_list|)
operator|+
literal|8
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0x40
operator|)
return|;
block|}
empty_stmt|;
comment|/* 	**	Show results. 	*/
if|if
condition|(
name|host_wr
operator|!=
name|ncr_rd
condition|)
block|{
name|printf
argument_list|(
literal|"CACHE TEST FAILED: host wrote %d, ncr read %d.\n"
argument_list|,
operator|(
name|int
operator|)
name|host_wr
argument_list|,
operator|(
name|int
operator|)
name|ncr_rd
argument_list|)
expr_stmt|;
name|err
operator||=
literal|1
expr_stmt|;
block|}
empty_stmt|;
if|if
condition|(
name|host_rd
operator|!=
name|ncr_wr
condition|)
block|{
name|printf
argument_list|(
literal|"CACHE TEST FAILED: ncr wrote %d, host read %d.\n"
argument_list|,
operator|(
name|int
operator|)
name|ncr_wr
argument_list|,
operator|(
name|int
operator|)
name|host_rd
argument_list|)
expr_stmt|;
name|err
operator||=
literal|2
expr_stmt|;
block|}
empty_stmt|;
if|if
condition|(
name|ncr_bk
operator|!=
name|ncr_wr
condition|)
block|{
name|printf
argument_list|(
literal|"CACHE TEST FAILED: ncr wrote %d, read back %d.\n"
argument_list|,
operator|(
name|int
operator|)
name|ncr_wr
argument_list|,
operator|(
name|int
operator|)
name|ncr_bk
argument_list|)
expr_stmt|;
name|err
operator||=
literal|4
expr_stmt|;
block|}
empty_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
comment|/*========================================================== ** ** **	Profiling the drivers and targets performance. ** ** **========================================================== */
comment|/* **	Compute the difference in milliseconds. **/
specifier|static
name|int
name|ncr_delta
parameter_list|(
name|struct
name|timeval
modifier|*
name|from
parameter_list|,
name|struct
name|timeval
modifier|*
name|to
parameter_list|)
block|{
if|if
condition|(
operator|!
name|from
operator|->
name|tv_sec
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
operator|!
name|to
operator|->
name|tv_sec
condition|)
return|return
operator|(
operator|-
literal|2
operator|)
return|;
return|return
operator|(
operator|(
name|to
operator|->
name|tv_sec
operator|-
name|from
operator|->
name|tv_sec
operator|-
literal|2
operator|)
operator|*
literal|1000
operator|+
operator|+
operator|(
name|to
operator|->
name|tv_usec
operator|-
name|from
operator|->
name|tv_usec
operator|+
literal|2000000
operator|)
operator|/
literal|1000
operator|)
return|;
block|}
define|#
directive|define
name|PROFILE
value|cp->phys.header.stamp
specifier|static
name|void
name|ncb_profile
parameter_list|(
name|ncb_p
name|np
parameter_list|,
name|ccb_p
name|cp
parameter_list|)
block|{
name|int
name|co
decl_stmt|,
name|da
decl_stmt|,
name|st
decl_stmt|,
name|en
decl_stmt|,
name|di
decl_stmt|,
name|se
decl_stmt|,
name|post
decl_stmt|,
name|work
decl_stmt|,
name|disc
decl_stmt|;
name|u_long
name|diff
decl_stmt|;
name|PROFILE
operator|.
name|end
operator|=
name|time
expr_stmt|;
name|st
operator|=
name|ncr_delta
argument_list|(
operator|&
name|PROFILE
operator|.
name|start
argument_list|,
operator|&
name|PROFILE
operator|.
name|status
argument_list|)
expr_stmt|;
if|if
condition|(
name|st
operator|<
literal|0
condition|)
return|return;
comment|/* status  not reached  */
name|da
operator|=
name|ncr_delta
argument_list|(
operator|&
name|PROFILE
operator|.
name|start
argument_list|,
operator|&
name|PROFILE
operator|.
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|da
operator|<
literal|0
condition|)
return|return;
comment|/* No data transfer phase */
name|co
operator|=
name|ncr_delta
argument_list|(
operator|&
name|PROFILE
operator|.
name|start
argument_list|,
operator|&
name|PROFILE
operator|.
name|command
argument_list|)
expr_stmt|;
if|if
condition|(
name|co
operator|<
literal|0
condition|)
return|return;
comment|/* command not executed */
name|en
operator|=
name|ncr_delta
argument_list|(
operator|&
name|PROFILE
operator|.
name|start
argument_list|,
operator|&
name|PROFILE
operator|.
name|end
argument_list|)
operator|,
name|di
operator|=
name|ncr_delta
argument_list|(
operator|&
name|PROFILE
operator|.
name|start
argument_list|,
operator|&
name|PROFILE
operator|.
name|disconnect
argument_list|)
operator|,
name|se
operator|=
name|ncr_delta
argument_list|(
operator|&
name|PROFILE
operator|.
name|start
argument_list|,
operator|&
name|PROFILE
operator|.
name|select
argument_list|)
expr_stmt|;
name|post
operator|=
name|en
operator|-
name|st
expr_stmt|;
comment|/* 	**	@PROFILE@  Disconnect time invalid if multiple disconnects 	*/
if|if
condition|(
name|di
operator|>=
literal|0
condition|)
name|disc
operator|=
name|se
operator|-
name|di
expr_stmt|;
else|else
name|disc
operator|=
literal|0
expr_stmt|;
name|work
operator|=
operator|(
name|st
operator|-
name|co
operator|)
operator|-
name|disc
expr_stmt|;
name|diff
operator|=
operator|(
name|np
operator|->
name|disc_phys
operator|-
name|np
operator|->
name|disc_ref
operator|)
operator|&
literal|0xff
expr_stmt|;
name|np
operator|->
name|disc_ref
operator|+=
name|diff
expr_stmt|;
name|np
operator|->
name|profile
operator|.
name|num_trans
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
name|cp
operator|->
name|xfer
condition|)
name|np
operator|->
name|profile
operator|.
name|num_bytes
operator|+=
name|cp
operator|->
name|xfer
operator|->
name|datalen
expr_stmt|;
name|np
operator|->
name|profile
operator|.
name|num_disc
operator|+=
name|diff
expr_stmt|;
name|np
operator|->
name|profile
operator|.
name|ms_setup
operator|+=
name|co
expr_stmt|;
name|np
operator|->
name|profile
operator|.
name|ms_data
operator|+=
name|work
expr_stmt|;
name|np
operator|->
name|profile
operator|.
name|ms_disc
operator|+=
name|disc
expr_stmt|;
name|np
operator|->
name|profile
operator|.
name|ms_post
operator|+=
name|post
expr_stmt|;
block|}
undef|#
directive|undef
name|PROFILE
comment|/*========================================================== ** ** **	Device lookup. ** **	@GENSCSI@ should be integrated to scsiconf.c ** ** **========================================================== */
ifndef|#
directive|ifndef
name|NEW_SCSICONF
struct|struct
name|table_entry
block|{
name|char
modifier|*
name|manufacturer
decl_stmt|;
name|char
modifier|*
name|model
decl_stmt|;
name|char
modifier|*
name|version
decl_stmt|;
name|u_long
name|info
decl_stmt|;
block|}
struct|;
specifier|static
name|struct
name|table_entry
name|device_tab
index|[]
init|=
block|{
ifdef|#
directive|ifdef
name|NCR_GETCC_WITHMSG
block|{
literal|""
block|,
literal|""
block|,
literal|""
block|,
name|QUIRK_NOMSG
block|}
block|,
block|{
literal|"SONY"
block|,
literal|"SDT-5000"
block|,
literal|"3.17"
block|,
name|QUIRK_NOMSG
block|}
block|,
block|{
literal|"WangDAT"
block|,
literal|"Model 2600"
block|,
literal|"01.7"
block|,
name|QUIRK_NOMSG
block|}
block|,
block|{
literal|"WangDAT"
block|,
literal|"Model 3200"
block|,
literal|"02.2"
block|,
name|QUIRK_NOMSG
block|}
block|,
block|{
literal|"WangDAT"
block|,
literal|"Model 1300"
block|,
literal|"02.4"
block|,
name|QUIRK_NOMSG
block|}
block|,
endif|#
directive|endif
block|{
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|0
block|}
comment|/* catch all: must be last entry. */
block|}
decl_stmt|;
specifier|static
name|u_long
name|ncr_lookup
parameter_list|(
name|char
modifier|*
name|id
parameter_list|)
block|{
name|struct
name|table_entry
modifier|*
name|p
init|=
name|device_tab
decl_stmt|;
name|char
modifier|*
name|d
decl_stmt|,
modifier|*
name|r
decl_stmt|,
name|c
decl_stmt|;
for|for
control|(
init|;
condition|;
name|p
operator|++
control|)
block|{
name|d
operator|=
name|id
operator|+
literal|8
expr_stmt|;
name|r
operator|=
name|p
operator|->
name|manufacturer
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|r
operator|++
operator|)
condition|)
if|if
condition|(
name|c
operator|!=
operator|*
name|d
operator|++
condition|)
break|break;
if|if
condition|(
name|c
condition|)
continue|continue;
name|d
operator|=
name|id
operator|+
literal|16
expr_stmt|;
name|r
operator|=
name|p
operator|->
name|model
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|r
operator|++
operator|)
condition|)
if|if
condition|(
name|c
operator|!=
operator|*
name|d
operator|++
condition|)
break|break;
if|if
condition|(
name|c
condition|)
continue|continue;
name|d
operator|=
name|id
operator|+
literal|32
expr_stmt|;
name|r
operator|=
name|p
operator|->
name|version
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|r
operator|++
operator|)
condition|)
if|if
condition|(
name|c
operator|!=
operator|*
name|d
operator|++
condition|)
break|break;
if|if
condition|(
name|c
condition|)
continue|continue;
return|return
operator|(
name|p
operator|->
name|info
operator|)
return|;
block|}
block|}
endif|#
directive|endif
comment|/*========================================================== ** **	Determine the ncr's clock frequency. **	This is important for the negotiation **	of the synchronous transfer rate. ** **========================================================== ** **	Note: we have to return the correct value. **	THERE IS NO SAVE DEFAULT VALUE. ** **	We assume that all NCR based boards are delivered **	with a 40Mhz clock. Because we have to divide **	by an integer value greater than 3, only clock **	frequencies of 40Mhz (/4) or 50MHz (/5) permit **	the FAST-SCSI rate of 10MHz. ** **---------------------------------------------------------- */
ifndef|#
directive|ifndef
name|NCR_CLOCK
define|#
directive|define
name|NCR_CLOCK
value|40
endif|#
directive|endif
comment|/* NCR_CLOCK */
comment|/*  *	calculate NCR SCSI clock frequency (in KHz)  */
specifier|static
name|unsigned
name|ncrgetfreq
parameter_list|(
name|ncb_p
name|np
parameter_list|,
name|int
name|gen
parameter_list|)
block|{
name|int
name|ms
init|=
literal|0
decl_stmt|;
comment|/* 	 * Measure GEN timer delay in order  	 * to calculate SCSI clock frequency 	 * 	 * This code will never execute too 	 * many loop iterations (if DELAY is  	 * reasonably correct). It could get 	 * too low a delay (too high a freq.) 	 * if the CPU is slow executing the  	 * loop for some reason (an NMI, for 	 * example). For this reason we will 	 * if multiple measurements are to be  	 * performed trust the higher delay  	 * (lower frequency returned). 	 */
name|OUTB
argument_list|(
name|nc_stest1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* make sure clock doubler is OFF	    */
name|OUTW
argument_list|(
name|nc_sien
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* mask all scsi interrupts		    */
operator|(
name|void
operator|)
name|INW
argument_list|(
name|nc_sist
argument_list|)
expr_stmt|;
comment|/* clear pending scsi interrupt		    */
name|OUTB
argument_list|(
name|nc_dien
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* mask all dma interrupts		    */
operator|(
name|void
operator|)
name|INW
argument_list|(
name|nc_sist
argument_list|)
expr_stmt|;
comment|/* another one, just to be sure :)	    */
name|OUTB
argument_list|(
name|nc_scntl3
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* set pre-scaler to divide by 3	    */
name|OUTB
argument_list|(
name|nc_stime1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* disable general purpose timer	    */
name|OUTB
argument_list|(
name|nc_stime1
argument_list|,
name|gen
argument_list|)
expr_stmt|;
comment|/* set to nominal delay of (1<<gen) * 125us */
while|while
condition|(
operator|!
operator|(
name|INW
argument_list|(
name|nc_sist
argument_list|)
operator|&
name|GEN
operator|)
operator|&&
name|ms
operator|++
operator|<
literal|1000
condition|)
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
comment|/* count ms				    */
name|OUTB
argument_list|(
name|nc_stime1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* disable general purpose timer	    */
name|OUTB
argument_list|(
name|nc_scntl3
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Set prescaler to divide by whatever "0" means. 	 * "0" ought to choose divide by 2, but appears 	 * to set divide by 3.5 mode in my 53c810 ... 	 */
name|OUTB
argument_list|(
name|nc_scntl3
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"\tDelay (GEN=%d): %lu msec\n"
argument_list|,
name|gen
argument_list|,
name|ms
argument_list|)
expr_stmt|;
comment|/* 	 * adjust for prescaler, and convert into KHz  	 */
return|return
name|ms
condition|?
operator|(
operator|(
literal|1
operator|<<
name|gen
operator|)
operator|*
literal|4440
operator|)
operator|/
name|ms
else|:
literal|0
return|;
block|}
specifier|static
name|void
name|ncr_getclock
parameter_list|(
name|ncb_p
name|np
parameter_list|)
block|{
name|unsigned
name|char
name|scntl3
decl_stmt|;
name|unsigned
name|char
name|stest1
decl_stmt|;
name|scntl3
operator|=
name|INB
argument_list|(
name|nc_scntl3
argument_list|)
expr_stmt|;
name|stest1
operator|=
name|INB
argument_list|(
name|nc_stest1
argument_list|)
expr_stmt|;
comment|/* always false, except for 875 with clock doubler selected */
if|if
condition|(
operator|(
name|stest1
operator|&
operator|(
name|DBLEN
operator|+
name|DBLSEL
operator|)
operator|)
operator|==
name|DBLEN
operator|+
name|DBLSEL
condition|)
block|{
name|OUTB
argument_list|(
name|nc_stest1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|scntl3
operator|=
literal|3
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|scntl3
operator|&
literal|7
operator|)
operator|==
literal|0
condition|)
block|{
name|unsigned
name|f1
decl_stmt|,
name|f2
decl_stmt|;
comment|/* throw away first result */
operator|(
name|void
operator|)
name|ncrgetfreq
argument_list|(
name|np
argument_list|,
literal|11
argument_list|)
expr_stmt|;
name|f1
operator|=
name|ncrgetfreq
argument_list|(
name|np
argument_list|,
literal|11
argument_list|)
expr_stmt|;
name|f2
operator|=
name|ncrgetfreq
argument_list|(
name|np
argument_list|,
literal|11
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"\tNCR clock is %luKHz, %luKHz\n"
argument_list|,
name|f1
argument_list|,
name|f2
argument_list|)
expr_stmt|;
if|if
condition|(
name|f1
operator|>
name|f2
condition|)
name|f1
operator|=
name|f2
expr_stmt|;
comment|/* trust lower result	*/
if|if
condition|(
name|f1
operator|>
literal|45000
condition|)
block|{
name|scntl3
operator|=
literal|5
expr_stmt|;
comment|/*>45Mhz: assume 80MHz	*/
block|}
else|else
block|{
name|scntl3
operator|=
literal|3
expr_stmt|;
comment|/*<45Mhz: assume 40MHz	*/
block|}
block|}
block|}
name|np
operator|->
name|rv_scntl3
operator|=
operator|(
operator|(
name|scntl3
operator|&
literal|0x7
operator|)
operator|<<
literal|4
operator|)
operator|-
literal|0x20
operator|+
operator|(
name|scntl3
operator|&
literal|0x7
operator|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
block|{
name|printf
argument_list|(
literal|"\tinitial value of SCNTL3 = %02x, final = %02x\n"
argument_list|,
name|scntl3
argument_list|,
name|np
operator|->
name|rv_scntl3
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*=========================================================================*/
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* KERNEL */
end_comment

end_unit

