begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1999, Traakan Software  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice unmodified, this list of conditions, and the following  *    disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_comment
comment|/*  * Intel Gigabit Ethernet (82452) Driver.  * Inspired by fxp driver by David Greenman for FreeBSD, and by  * Bill Paul's work in other FreeBSD network drivers.  */
end_comment

begin_comment
comment|/*  * Options  */
end_comment

begin_comment
comment|/*  * Use only every other 16 byte receive descriptor, leaving the ones  * in between empty. This card is most efficient at reading/writing  * 32 byte cache lines, so avoid all the (not working for early rev  * cards) MWI and/or READ/MODIFY/WRITE cycles updating one descriptor  * would have you do.  *  * This isn't debugged yet.  */
end_comment

begin_comment
comment|/* #define	PADDED_CELL	1 */
end_comment

begin_comment
comment|/*  * Since the includes are a mess, they'll all be in if_wxvar.h  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
end_if

begin_include
include|#
directive|include
file|<dev/pci/if_wxvar.h>
end_include

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
end_elif

begin_include
include|#
directive|include
file|<pci/if_wxvar.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|__alpha__
end_ifdef

begin_undef
undef|#
directive|undef
name|vtophys
end_undef

begin_define
define|#
directive|define
name|vtophys
parameter_list|(
name|va
parameter_list|)
value|alpha_XXX_dmamap((vm_offset_t)(va))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __alpha__ */
end_comment

begin_comment
comment|/*  * Function Prototpes, yadda yadda...  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|wx_intr
name|__P
argument_list|(
operator|(
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|wx_handle_link_intr
name|__P
argument_list|(
operator|(
name|wx_softc_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|wx_handle_rxint
name|__P
argument_list|(
operator|(
name|wx_softc_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|wx_gc
name|__P
argument_list|(
operator|(
name|wx_softc_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|wx_start
name|__P
argument_list|(
operator|(
expr|struct
name|ifnet
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|wx_ioctl
name|__P
argument_list|(
operator|(
expr|struct
name|ifnet
operator|*
operator|,
name|IOCTL_CMD_TYPE
operator|,
name|caddr_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|wx_ifmedia_upd
name|__P
argument_list|(
operator|(
expr|struct
name|ifnet
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|wx_ifmedia_sts
name|__P
argument_list|(
operator|(
expr|struct
name|ifnet
operator|*
operator|,
expr|struct
name|ifmediareq
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|wx_init
name|__P
argument_list|(
operator|(
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|wx_hw_stop
name|__P
argument_list|(
operator|(
name|wx_softc_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|wx_set_addr
name|__P
argument_list|(
operator|(
name|wx_softc_t
operator|*
operator|,
name|int
operator|,
name|u_int8_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|wx_hw_initialize
name|__P
argument_list|(
operator|(
name|wx_softc_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|wx_stop
name|__P
argument_list|(
operator|(
name|wx_softc_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|wx_watchdog
name|__P
argument_list|(
operator|(
expr|struct
name|ifnet
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|wx_get_rbuf
name|__P
argument_list|(
operator|(
name|wx_softc_t
operator|*
operator|,
name|rxpkt_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|wx_rxdma_map
name|__P
argument_list|(
operator|(
name|wx_softc_t
operator|*
operator|,
name|rxpkt_t
operator|*
operator|,
expr|struct
name|mbuf
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|INLINE
name|void
name|wx_eeprom_raise_clk
name|__P
argument_list|(
operator|(
name|wx_softc_t
operator|*
operator|,
name|u_int32_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|INLINE
name|void
name|wx_eeprom_lower_clk
name|__P
argument_list|(
operator|(
name|wx_softc_t
operator|*
operator|,
name|u_int32_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|INLINE
name|void
name|wx_eeprom_sobits
name|__P
argument_list|(
operator|(
name|wx_softc_t
operator|*
operator|,
name|u_int16_t
operator|,
name|u_int16_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|INLINE
name|u_int16_t
name|wx_eeprom_sibits
name|__P
argument_list|(
operator|(
name|wx_softc_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|INLINE
name|void
name|wx_eeprom_cleanup
name|__P
argument_list|(
operator|(
name|wx_softc_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|INLINE
name|u_int16_t
name|wx_read_eeprom_word
name|__P
argument_list|(
operator|(
name|wx_softc_t
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|wx_read_eeprom
name|__P
argument_list|(
operator|(
name|wx_softc_t
operator|*
operator|,
name|u_int16_t
operator|*
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|wx_attach_common
name|__P
argument_list|(
operator|(
name|wx_softc_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|wx_stats_update
name|__P
argument_list|(
operator|(
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|INLINE
name|void
name|wx_mwi_whackon
name|__P
argument_list|(
operator|(
name|wx_softc_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|INLINE
name|void
name|wx_mwi_unwhack
name|__P
argument_list|(
operator|(
name|wx_softc_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|wx_dring_setup
name|__P
argument_list|(
operator|(
name|wx_softc_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|wx_dring_teardown
name|__P
argument_list|(
operator|(
name|wx_softc_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|WX_DISABLE_INT
parameter_list|(
name|sc
parameter_list|)
value|WRITE_CSR(sc, WXREG_IMCLR, WXDISABLE)
end_define

begin_define
define|#
directive|define
name|WX_ENABLE_INT
parameter_list|(
name|sc
parameter_list|)
value|WRITE_CSR(sc, WXREG_IMASK, sc->wx_ienable)
end_define

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
end_if

begin_ifdef
ifdef|#
directive|ifdef
name|__BROKEN_INDIRECT_CONFIG
end_ifdef

begin_define
define|#
directive|define
name|MATCHARG
value|void *
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|MATCHARG
value|struct cfdata *
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|int
name|wx_match
name|__P
argument_list|(
operator|(
expr|struct
name|device
operator|*
operator|,
name|MATCHARG
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|wx_attach
name|__P
argument_list|(
operator|(
expr|struct
name|device
operator|*
operator|,
expr|struct
name|device
operator|*
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|wx_shutdown
name|__P
argument_list|(
operator|(
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|wx_ether_ioctl
name|__P
argument_list|(
operator|(
expr|struct
name|ifnet
operator|*
operator|,
name|IOCTL_CMD_TYPE
operator|,
name|caddr_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|wx_mc_setup
name|__P
argument_list|(
operator|(
name|wx_softc_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|ether_ioctl
value|wx_ether_ioctl
end_define

begin_comment
comment|/*  * Life *should* be simple- we only read/write 32 bit values in registers.  * Unfortunately, some platforms define bus_space functions in a fashion  * such that they cannot be used as part of a for loop, for example.  */
end_comment

begin_decl_stmt
specifier|static
name|INLINE
name|u_int32_t
name|_read_csr
name|__P
argument_list|(
operator|(
expr|struct
name|wx_softc
operator|*
operator|,
name|u_int32_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|INLINE
name|void
name|_write_csr
name|__P
argument_list|(
operator|(
expr|struct
name|wx_softc
operator|*
operator|,
name|u_int32_t
operator|,
name|u_int32_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|INLINE
name|u_int32_t
name|_read_csr
parameter_list|(
name|sc
parameter_list|,
name|reg
parameter_list|)
name|struct
name|wx_softc
modifier|*
name|sc
decl_stmt|;
name|u_int32_t
name|reg
decl_stmt|;
block|{
return|return
name|bus_space_read_4
argument_list|(
name|sc
operator|->
name|w
operator|.
name|st
argument_list|,
name|sc
operator|->
name|w
operator|.
name|sh
argument_list|,
name|reg
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|INLINE
name|void
name|_write_csr
parameter_list|(
name|sc
parameter_list|,
name|reg
parameter_list|,
name|val
parameter_list|)
name|struct
name|wx_softc
modifier|*
name|sc
decl_stmt|;
name|u_int32_t
name|reg
decl_stmt|;
name|u_int32_t
name|val
decl_stmt|;
block|{
name|bus_space_write_4
argument_list|(
name|sc
operator|->
name|w
operator|.
name|st
argument_list|,
name|sc
operator|->
name|w
operator|.
name|sh
argument_list|,
name|reg
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|wx_softc_t
modifier|*
name|wxlist
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|cfattach
name|wx_ca
init|=
block|{
sizeof|sizeof
argument_list|(
name|wx_softc_t
argument_list|)
block|,
name|wx_match
block|,
name|wx_attach
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Check if a device is an 82452.  */
end_comment

begin_function
specifier|static
name|int
name|wx_match
parameter_list|(
name|parent
parameter_list|,
name|match
parameter_list|,
name|aux
parameter_list|)
name|struct
name|device
modifier|*
name|parent
decl_stmt|;
name|MATCHARG
name|match
decl_stmt|;
name|void
modifier|*
name|aux
decl_stmt|;
block|{
name|struct
name|pci_attach_args
modifier|*
name|pa
init|=
name|aux
decl_stmt|;
if|if
condition|(
name|PCI_VENDOR
argument_list|(
name|pa
operator|->
name|pa_id
argument_list|)
operator|!=
name|WX_VENDOR_INTEL
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|PCI_PRODUCT
argument_list|(
name|pa
operator|->
name|pa_id
argument_list|)
operator|!=
name|WX_PRODUCT_82452
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|wx_attach
parameter_list|(
name|parent
parameter_list|,
name|self
parameter_list|,
name|aux
parameter_list|)
name|struct
name|device
modifier|*
name|parent
decl_stmt|,
decl|*
name|self
decl_stmt|;
end_function

begin_decl_stmt
name|void
modifier|*
name|aux
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|wx_softc_t
modifier|*
name|tmp
decl_stmt|,
modifier|*
name|sc
init|=
operator|(
name|wx_softc_t
operator|*
operator|)
name|self
decl_stmt|;
name|struct
name|pci_attach_args
modifier|*
name|pa
init|=
name|aux
decl_stmt|;
name|pci_chipset_tag_t
name|pc
init|=
name|pa
operator|->
name|pa_pc
decl_stmt|;
name|pci_intr_handle_t
name|ih
decl_stmt|;
specifier|const
name|char
modifier|*
name|intrstr
init|=
name|NULL
decl_stmt|;
name|u_int32_t
name|data
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|sc
operator|->
name|w
operator|.
name|pci_pc
operator|=
name|pa
operator|->
name|pa_pc
expr_stmt|;
name|sc
operator|->
name|w
operator|.
name|pci_tag
operator|=
name|pa
operator|->
name|pa_tag
expr_stmt|;
comment|/* 	 * Map control/status registers. 	 */
if|if
condition|(
name|pci_mapreg_map
argument_list|(
name|pa
argument_list|,
name|WX_MMBA
argument_list|,
name|PCI_MAPREG_TYPE_MEM
argument_list|,
literal|0
argument_list|,
operator|&
name|sc
operator|->
name|w
operator|.
name|st
argument_list|,
operator|&
name|sc
operator|->
name|w
operator|.
name|sh
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|": can't map registers\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|printf
argument_list|(
literal|": Intel GigaBit Ethernet\n"
argument_list|)
expr_stmt|;
comment|/* 	 * Allocate our interrupt. 	 */
if|if
condition|(
name|pci_intr_map
argument_list|(
name|pc
argument_list|,
name|pa
operator|->
name|pa_intrtag
argument_list|,
name|pa
operator|->
name|pa_intrpin
argument_list|,
name|pa
operator|->
name|pa_intrline
argument_list|,
operator|&
name|ih
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"%s: couldn't map interrupt\n"
argument_list|,
name|sc
operator|->
name|wx_name
argument_list|)
expr_stmt|;
return|return;
block|}
name|intrstr
operator|=
name|pci_intr_string
argument_list|(
name|pc
argument_list|,
name|ih
argument_list|)
expr_stmt|;
name|sc
operator|->
name|w
operator|.
name|ih
operator|=
name|pci_intr_establish
argument_list|(
name|pc
argument_list|,
name|ih
argument_list|,
name|IPL_NET
argument_list|,
name|wx_intr
argument_list|,
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|w
operator|.
name|ih
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"%s: couldn't establish interrupt"
argument_list|,
name|sc
operator|->
name|wx_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|intrstr
operator|!=
name|NULL
condition|)
name|printf
argument_list|(
literal|" at %s"
argument_list|,
name|intrstr
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|printf
argument_list|(
literal|"%s: interrupting at %s\n"
argument_list|,
name|sc
operator|->
name|wx_name
argument_list|,
name|intrstr
argument_list|)
expr_stmt|;
name|sc
operator|->
name|revision
operator|=
name|pci_conf_read
argument_list|(
name|pa
operator|->
name|pa_pc
argument_list|,
name|pa
operator|->
name|pa_tag
argument_list|,
name|PCI_CLASS_REG
argument_list|)
operator|&
literal|0xff
expr_stmt|;
name|data
operator|=
name|pci_conf_read
argument_list|(
name|pa
operator|->
name|pa_pc
argument_list|,
name|pa
operator|->
name|pa_tag
argument_list|,
name|PCI_BHLC_REG
argument_list|)
expr_stmt|;
name|data
operator|&=
operator|~
operator|(
name|PCI_CACHELINE_MASK
operator|<<
name|PCI_CACHELINE_SHIFT
operator|)
expr_stmt|;
name|data
operator||=
operator|(
name|WX_CACHELINE_SIZE
operator|<<
name|PCI_CACHELINE_SHIFT
operator|)
expr_stmt|;
name|pci_conf_write
argument_list|(
name|pa
operator|->
name|pa_pc
argument_list|,
name|pa
operator|->
name|pa_tag
argument_list|,
name|PCI_BHLC_REG
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|wx_attach_common
argument_list|(
name|sc
argument_list|)
condition|)
block|{
return|return;
block|}
name|printf
argument_list|(
literal|"%s: Ethernet address %s\n"
argument_list|,
name|sc
operator|->
name|wx_name
argument_list|,
name|ether_sprintf
argument_list|(
name|sc
operator|->
name|wx_enaddr
argument_list|)
argument_list|)
expr_stmt|;
name|ifp
operator|=
operator|&
name|sc
operator|->
name|w
operator|.
name|ethercom
operator|.
name|ec_if
expr_stmt|;
name|bcopy
argument_list|(
name|sc
operator|->
name|wx_name
argument_list|,
name|ifp
operator|->
name|if_xname
argument_list|,
name|IFNAMSIZ
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_softc
operator|=
name|sc
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|=
name|IFF_BROADCAST
operator||
name|IFF_SIMPLEX
operator||
name|IFF_MULTICAST
expr_stmt|;
name|ifp
operator|->
name|if_ioctl
operator|=
name|wx_ioctl
expr_stmt|;
name|ifp
operator|->
name|if_start
operator|=
name|wx_start
expr_stmt|;
name|ifp
operator|->
name|if_watchdog
operator|=
name|wx_watchdog
expr_stmt|;
comment|/* 	 * Attach the interface. 	 */
name|if_attach
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|ether_ifattach
argument_list|(
name|ifp
argument_list|,
name|sc
operator|->
name|wx_enaddr
argument_list|)
expr_stmt|;
if|#
directive|if
name|NBPFILTER
operator|>
literal|0
name|bpfattach
argument_list|(
operator|&
name|sc
operator|->
name|w
operator|.
name|ethercom
operator|.
name|ec_if
operator|.
name|if_bpf
argument_list|,
name|ifp
argument_list|,
name|DLT_EN10MB
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Add shutdown hook so that DMA is disabled prior to reboot. Not 	 * doing do could allow DMA to corrupt kernel memory during the 	 * reboot before the driver initializes. 	 */
name|shutdownhook_establish
argument_list|(
name|wx_shutdown
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|wxlist
expr_stmt|;
if|if
condition|(
name|tmp
condition|)
block|{
while|while
condition|(
name|tmp
operator|->
name|wx_next
condition|)
name|tmp
operator|=
name|tmp
operator|->
name|wx_next
expr_stmt|;
name|tmp
operator|->
name|wx_next
operator|=
name|sc
expr_stmt|;
block|}
else|else
block|{
name|wxlist
operator|=
name|sc
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * Device shutdown routine. Called at system shutdown after sync. The  * main purpose of this routine is to shut off receiver DMA so that  * kernel memory doesn't get clobbered during warmboot.  */
end_comment

begin_function
specifier|static
name|void
name|wx_shutdown
parameter_list|(
name|sc
parameter_list|)
name|void
modifier|*
name|sc
decl_stmt|;
block|{
name|wx_hw_stop
argument_list|(
operator|(
name|wx_softc_t
operator|*
operator|)
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|wx_ether_ioctl
parameter_list|(
name|ifp
parameter_list|,
name|cmd
parameter_list|,
name|data
parameter_list|)
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|IOCTL_CMD_TYPE
name|cmd
decl_stmt|;
name|caddr_t
name|data
decl_stmt|;
block|{
name|struct
name|ifaddr
modifier|*
name|ifa
init|=
operator|(
expr|struct
name|ifaddr
operator|*
operator|)
name|data
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|wx_softc_t
modifier|*
name|sc
init|=
name|SOFTC_IFP
argument_list|(
name|ifp
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|SIOCSIFADDR
case|:
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_UP
expr_stmt|;
name|error
operator|=
name|wx_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
name|IFF_UP
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
name|ifa
operator|->
name|ifa_addr
operator|->
name|sa_family
condition|)
block|{
ifdef|#
directive|ifdef
name|INET
case|case
name|AF_INET
case|:
name|arp_ifinit
argument_list|(
name|ifp
argument_list|,
name|ifa
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|NS
case|case
name|AF_NS
case|:
block|{
specifier|register
name|struct
name|ns_addr
modifier|*
name|ina
init|=
operator|&
name|IA_SNS
argument_list|(
name|ifa
argument_list|)
operator|->
name|sns_addr
decl_stmt|;
if|if
condition|(
name|ns_nullhost
argument_list|(
operator|*
name|ina
argument_list|)
condition|)
name|ina
operator|->
name|x_host
operator|=
operator|*
operator|(
expr|union
name|ns_host
operator|*
operator|)
name|LLADDR
argument_list|(
name|ifp
operator|->
name|if_sadl
argument_list|)
expr_stmt|;
else|else
name|bcopy
argument_list|(
name|ina
operator|->
name|x_host
operator|.
name|c_host
argument_list|,
name|LLADDR
argument_list|(
name|ifp
operator|->
name|if_sadl
argument_list|)
argument_list|,
name|ifp
operator|->
name|if_addrlen
argument_list|)
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
default|default:
break|break;
block|}
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Program multicast addresses.  *  * This function must be called at splimp, but it may sleep.  */
end_comment

begin_function
specifier|static
name|int
name|wx_mc_setup
parameter_list|(
name|sc
parameter_list|)
name|wx_softc_t
modifier|*
name|sc
decl_stmt|;
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
operator|&
name|sc
operator|->
name|wx_if
decl_stmt|;
name|struct
name|ether_multistep
name|step
decl_stmt|;
name|struct
name|ether_multi
modifier|*
name|enm
decl_stmt|;
comment|/* 	 * XXX: drain TX queue- use a tsleep/wakeup until done. 	 */
if|if
condition|(
name|sc
operator|->
name|tactive
condition|)
block|{
return|return
operator|(
name|EBUSY
operator|)
return|;
block|}
name|wx_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_ALLMULTI
operator|||
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_PROMISC
condition|)
block|{
name|sc
operator|->
name|all_mcasts
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|wx_init
argument_list|(
name|sc
argument_list|)
operator|)
return|;
block|}
name|ETHER_FIRST_MULTI
argument_list|(
name|step
argument_list|,
operator|&
name|sc
operator|->
name|w
operator|.
name|ethercom
argument_list|,
name|enm
argument_list|)
expr_stmt|;
while|while
condition|(
name|enm
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|memcmp
argument_list|(
name|enm
operator|->
name|enm_addrlo
argument_list|,
name|enm
operator|->
name|enm_addrhi
argument_list|,
literal|6
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
if|if
condition|(
name|sc
operator|->
name|wx_nmca
operator|>=
name|WX_RAL_TAB_SIZE
operator|-
literal|1
condition|)
block|{
name|sc
operator|->
name|wx_nmca
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|all_mcasts
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|bcopy
argument_list|(
name|enm
operator|->
name|enm_addrlo
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|sc
operator|->
name|wx_mcaddr
index|[
name|sc
operator|->
name|wx_nmca
operator|++
index|]
index|[
literal|0
index|]
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|ETHER_NEXT_MULTI
argument_list|(
name|step
argument_list|,
name|enm
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|wx_init
argument_list|(
name|sc
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|INLINE
name|void
name|wx_mwi_whackon
parameter_list|(
name|sc
parameter_list|)
name|wx_softc_t
modifier|*
name|sc
decl_stmt|;
block|{
name|sc
operator|->
name|wx_cmdw
operator|=
name|pci_conf_read
argument_list|(
name|sc
operator|->
name|w
operator|.
name|pci_pc
argument_list|,
name|sc
operator|->
name|w
operator|.
name|pci_tag
argument_list|,
name|PCI_COMMAND_STATUS_REG
argument_list|)
expr_stmt|;
name|pci_conf_write
argument_list|(
name|sc
operator|->
name|w
operator|.
name|pci_pc
argument_list|,
name|sc
operator|->
name|w
operator|.
name|pci_tag
argument_list|,
name|PCI_COMMAND_STATUS_REG
argument_list|,
name|sc
operator|->
name|wx_cmdw
operator|&
operator|~
name|MWI
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|INLINE
name|void
name|wx_mwi_unwhack
parameter_list|(
name|sc
parameter_list|)
name|wx_softc_t
modifier|*
name|sc
decl_stmt|;
block|{
if|if
condition|(
name|sc
operator|->
name|wx_cmdw
operator|&
name|MWI
condition|)
block|{
name|pci_conf_write
argument_list|(
name|sc
operator|->
name|w
operator|.
name|pci_pc
argument_list|,
name|sc
operator|->
name|w
operator|.
name|pci_tag
argument_list|,
name|PCI_COMMAND_STATUS_REG
argument_list|,
name|sc
operator|->
name|wx_cmdw
operator|&
operator|~
name|MWI
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|wx_dring_setup
parameter_list|(
name|sc
parameter_list|)
name|wx_softc_t
modifier|*
name|sc
decl_stmt|;
block|{
name|size_t
name|len
decl_stmt|;
name|len
operator|=
sizeof|sizeof
argument_list|(
name|wxrd_t
argument_list|)
operator|*
name|WX_MAX_RDESC
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|NBPG
condition|)
block|{
name|printf
argument_list|(
literal|"%s: len (%lx) over a page for the receive ring\n"
argument_list|,
name|sc
operator|->
name|wx_name
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|len
operator|=
name|NBPG
expr_stmt|;
name|sc
operator|->
name|rdescriptors
operator|=
operator|(
name|wxrd_t
operator|*
operator|)
name|WXMALLOC
argument_list|(
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|rdescriptors
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"%s: could not allocate rcv descriptors\n"
argument_list|,
name|sc
operator|->
name|wx_name
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|(
operator|(
name|u_long
operator|)
name|sc
operator|->
name|rdescriptors
operator|)
operator|&
literal|0xfff
condition|)
block|{
name|printf
argument_list|(
literal|"%s: rcv descriptors not 4KB aligned\n"
argument_list|,
name|sc
operator|->
name|wx_name
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|bzero
argument_list|(
name|sc
operator|->
name|rdescriptors
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|len
operator|=
sizeof|sizeof
argument_list|(
name|wxtd_t
argument_list|)
operator|*
name|WX_MAX_TDESC
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|NBPG
condition|)
block|{
name|printf
argument_list|(
literal|"%s: len (%lx) over a page for the xmit ring\n"
argument_list|,
name|sc
operator|->
name|wx_name
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|len
operator|=
name|NBPG
expr_stmt|;
name|sc
operator|->
name|tdescriptors
operator|=
operator|(
name|wxtd_t
operator|*
operator|)
name|WXMALLOC
argument_list|(
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|tdescriptors
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"%s: could not allocate xmt descriptors\n"
argument_list|,
name|sc
operator|->
name|wx_name
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|(
operator|(
name|u_long
operator|)
name|sc
operator|->
name|tdescriptors
operator|)
operator|&
literal|0xfff
condition|)
block|{
name|printf
argument_list|(
literal|"%s: xmt descriptors not 4KB aligned\n"
argument_list|,
name|sc
operator|->
name|wx_name
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|bzero
argument_list|(
name|sc
operator|->
name|tdescriptors
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|wx_dring_teardown
parameter_list|(
name|sc
parameter_list|)
name|wx_softc_t
modifier|*
name|sc
decl_stmt|;
block|{
if|if
condition|(
name|sc
operator|->
name|rdescriptors
condition|)
block|{
name|WXFREE
argument_list|(
name|sc
operator|->
name|rdescriptors
argument_list|)
expr_stmt|;
name|sc
operator|->
name|rdescriptors
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|tdescriptors
condition|)
block|{
name|WXFREE
argument_list|(
name|sc
operator|->
name|tdescriptors
argument_list|)
expr_stmt|;
name|sc
operator|->
name|tdescriptors
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
end_elif

begin_decl_stmt
specifier|static
name|int
name|wx_mc_setup
name|__P
argument_list|(
operator|(
name|wx_softc_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Program multicast addresses.  *  * This function must be called at splimp, but it may sleep.  */
end_comment

begin_function
specifier|static
name|int
name|wx_mc_setup
parameter_list|(
name|sc
parameter_list|)
name|wx_softc_t
modifier|*
name|sc
decl_stmt|;
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
operator|&
name|sc
operator|->
name|wx_if
decl_stmt|;
name|struct
name|ifmultiaddr
modifier|*
name|ifma
decl_stmt|;
comment|/* 	 * XXX: drain TX queue- use a tsleep/wakeup until done. 	 */
if|if
condition|(
name|sc
operator|->
name|tactive
condition|)
block|{
return|return
operator|(
name|EBUSY
operator|)
return|;
block|}
name|wx_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_ALLMULTI
operator|||
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_PROMISC
condition|)
block|{
name|sc
operator|->
name|all_mcasts
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|wx_init
argument_list|(
name|sc
argument_list|)
operator|)
return|;
block|}
for|for
control|(
name|ifma
operator|=
name|ifp
operator|->
name|if_multiaddrs
operator|.
name|lh_first
operator|,
name|sc
operator|->
name|wx_nmca
operator|=
literal|0
init|;
name|ifma
operator|!=
name|NULL
condition|;
name|ifma
operator|=
name|ifma
operator|->
name|ifma_link
operator|.
name|le_next
control|)
block|{
if|if
condition|(
name|ifma
operator|->
name|ifma_addr
operator|->
name|sa_family
operator|!=
name|AF_LINK
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|sc
operator|->
name|wx_nmca
operator|>=
name|WX_RAL_TAB_SIZE
operator|-
literal|1
condition|)
block|{
name|sc
operator|->
name|wx_nmca
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|all_mcasts
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|bcopy
argument_list|(
name|LLADDR
argument_list|(
operator|(
expr|struct
name|sockaddr_dl
operator|*
operator|)
name|ifma
operator|->
name|ifma_addr
argument_list|)
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|sc
operator|->
name|wx_mcaddr
index|[
name|sc
operator|->
name|wx_nmca
operator|++
index|]
index|[
literal|0
index|]
argument_list|,
literal|6
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|wx_init
argument_list|(
name|sc
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return identification string if this is device is ours.  */
end_comment

begin_decl_stmt
specifier|static
name|wx_softc_t
modifier|*
name|wxlist
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|wx_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
if|if
condition|(
operator|(
name|pci_get_vendor
argument_list|(
name|dev
argument_list|)
operator|==
name|WX_VENDOR_INTEL
operator|)
operator|&&
operator|(
name|pci_get_device
argument_list|(
name|dev
argument_list|)
operator|==
name|WX_PRODUCT_82452
operator|)
condition|)
block|{
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"Intel GigaBit Ethernet"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|wx_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
name|wx_softc_t
modifier|*
name|tmp
decl_stmt|,
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|int
name|s
decl_stmt|;
name|u_long
name|val
decl_stmt|;
name|int
name|rid
decl_stmt|;
name|bzero
argument_list|(
name|sc
argument_list|,
sizeof|sizeof
argument_list|(
name|wx_softc_t
argument_list|)
argument_list|)
expr_stmt|;
name|callout_handle_init
argument_list|(
operator|&
name|sc
operator|->
name|w
operator|.
name|sch
argument_list|)
expr_stmt|;
name|sc
operator|->
name|w
operator|.
name|dev
operator|=
name|dev
expr_stmt|;
if|if
condition|(
name|getenv_int
argument_list|(
literal|"wx_debug"
argument_list|,
operator|&
name|rid
argument_list|)
condition|)
block|{
if|if
condition|(
name|rid
operator|&
operator|(
literal|1
operator|<<
name|device_get_unit
argument_list|(
name|dev
argument_list|)
operator|)
condition|)
block|{
name|sc
operator|->
name|wx_debug
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|getenv_int
argument_list|(
literal|"wx_no_ilos"
argument_list|,
operator|&
name|rid
argument_list|)
condition|)
block|{
if|if
condition|(
name|rid
operator|&
operator|(
literal|1
operator|<<
name|device_get_unit
argument_list|(
name|dev
argument_list|)
operator|)
condition|)
block|{
name|sc
operator|->
name|wx_no_ilos
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|getenv_int
argument_list|(
literal|"wx_ilos"
argument_list|,
operator|&
name|rid
argument_list|)
condition|)
block|{
if|if
condition|(
name|rid
operator|&
operator|(
literal|1
operator|<<
name|device_get_unit
argument_list|(
name|dev
argument_list|)
operator|)
condition|)
block|{
name|sc
operator|->
name|wx_ilos
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|getenv_int
argument_list|(
literal|"wx_no_flow"
argument_list|,
operator|&
name|rid
argument_list|)
condition|)
block|{
if|if
condition|(
name|rid
operator|&
operator|(
literal|1
operator|<<
name|device_get_unit
argument_list|(
name|dev
argument_list|)
operator|)
condition|)
block|{
name|sc
operator|->
name|wx_no_flow
operator|=
literal|1
expr_stmt|;
block|}
block|}
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
comment|/* 	 * Enable bus mastering, make sure that the cache line size is right. 	 */
name|val
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_COMMAND
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|val
operator||=
operator|(
name|PCIM_CMD_MEMEN
operator||
name|PCIM_CMD_BUSMASTEREN
operator|)
expr_stmt|;
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|PCIR_COMMAND
argument_list|,
name|val
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|val
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_CACHELNSZ
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|!=
literal|0x10
condition|)
block|{
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|PCIR_CACHELNSZ
argument_list|,
literal|0x10
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/*  	 * get revision 	 */
name|sc
operator|->
name|revision
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_CLASS
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* 	 * Map control/status registers. 	 */
name|rid
operator|=
name|WX_MMBA
expr_stmt|;
name|sc
operator|->
name|w
operator|.
name|mem
operator|=
name|bus_alloc_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
operator|&
name|rid
argument_list|,
literal|0
argument_list|,
operator|~
literal|0
argument_list|,
literal|1
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sc
operator|->
name|w
operator|.
name|mem
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"could not map memory\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|sc
operator|->
name|w
operator|.
name|st
operator|=
name|rman_get_bustag
argument_list|(
name|sc
operator|->
name|w
operator|.
name|mem
argument_list|)
expr_stmt|;
name|sc
operator|->
name|w
operator|.
name|sh
operator|=
name|rman_get_bushandle
argument_list|(
name|sc
operator|->
name|w
operator|.
name|mem
argument_list|)
expr_stmt|;
name|rid
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|w
operator|.
name|irq
operator|=
name|bus_alloc_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|rid
argument_list|,
literal|0
argument_list|,
operator|~
literal|0
argument_list|,
literal|1
argument_list|,
name|RF_SHAREABLE
operator||
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|w
operator|.
name|irq
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"could not map interrupt\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|error
operator|=
name|bus_setup_intr
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|w
operator|.
name|irq
argument_list|,
name|INTR_TYPE_NET
argument_list|,
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
name|void
operator|*
argument_list|)
operator|)
name|wx_intr
argument_list|,
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|w
operator|.
name|ih
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"could not setup irq\n"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|wx_attach_common
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|bus_teardown_intr
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|w
operator|.
name|irq
argument_list|,
name|sc
operator|->
name|w
operator|.
name|ih
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
literal|0
argument_list|,
name|sc
operator|->
name|w
operator|.
name|irq
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|WX_MMBA
argument_list|,
name|sc
operator|->
name|w
operator|.
name|mem
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Ethernet address %02x:%02x:%02x:%02x:%02x:%02x\n"
argument_list|,
name|sc
operator|->
name|w
operator|.
name|arpcom
operator|.
name|ac_enaddr
index|[
literal|0
index|]
argument_list|,
name|sc
operator|->
name|w
operator|.
name|arpcom
operator|.
name|ac_enaddr
index|[
literal|1
index|]
argument_list|,
name|sc
operator|->
name|w
operator|.
name|arpcom
operator|.
name|ac_enaddr
index|[
literal|2
index|]
argument_list|,
name|sc
operator|->
name|w
operator|.
name|arpcom
operator|.
name|ac_enaddr
index|[
literal|3
index|]
argument_list|,
name|sc
operator|->
name|w
operator|.
name|arpcom
operator|.
name|ac_enaddr
index|[
literal|4
index|]
argument_list|,
name|sc
operator|->
name|w
operator|.
name|arpcom
operator|.
name|ac_enaddr
index|[
literal|5
index|]
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|sc
operator|->
name|wx_name
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|wx_name
argument_list|)
operator|-
literal|1
argument_list|,
literal|"wx%d"
argument_list|,
name|device_get_unit
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|ifp
operator|=
operator|&
name|sc
operator|->
name|w
operator|.
name|arpcom
operator|.
name|ac_if
expr_stmt|;
name|ifp
operator|->
name|if_unit
operator|=
name|device_get_unit
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_name
operator|=
literal|"wx"
expr_stmt|;
name|ifp
operator|->
name|if_output
operator|=
name|ether_output
expr_stmt|;
name|ifp
operator|->
name|if_baudrate
operator|=
literal|1000000000
expr_stmt|;
name|ifp
operator|->
name|if_init
operator|=
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
name|void
operator|*
argument_list|)
operator|)
name|wx_init
expr_stmt|;
name|ifp
operator|->
name|if_softc
operator|=
name|sc
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|=
name|IFF_BROADCAST
operator||
name|IFF_SIMPLEX
operator||
name|IFF_MULTICAST
expr_stmt|;
name|ifp
operator|->
name|if_ioctl
operator|=
name|wx_ioctl
expr_stmt|;
name|ifp
operator|->
name|if_start
operator|=
name|wx_start
expr_stmt|;
name|ifp
operator|->
name|if_watchdog
operator|=
name|wx_watchdog
expr_stmt|;
name|if_attach
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_snd
operator|.
name|ifq_maxlen
operator|=
name|WX_MAX_TDESC
operator|-
literal|1
expr_stmt|;
name|ether_ifattach
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|bpfattach
argument_list|(
name|ifp
argument_list|,
name|DLT_EN10MB
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|wxlist
expr_stmt|;
if|if
condition|(
name|tmp
condition|)
block|{
while|while
condition|(
name|tmp
operator|->
name|wx_next
condition|)
name|tmp
operator|=
name|tmp
operator|->
name|wx_next
expr_stmt|;
name|tmp
operator|->
name|wx_next
operator|=
name|sc
expr_stmt|;
block|}
else|else
block|{
name|wxlist
operator|=
name|sc
expr_stmt|;
block|}
name|out
label|:
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|wx_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|wx_softc_t
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|s
init|=
name|splimp
argument_list|()
decl_stmt|;
name|if_detach
argument_list|(
operator|&
name|sc
operator|->
name|w
operator|.
name|arpcom
operator|.
name|ac_if
argument_list|)
expr_stmt|;
name|wx_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bus_teardown_intr
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|w
operator|.
name|irq
argument_list|,
name|sc
operator|->
name|w
operator|.
name|ih
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
literal|0
argument_list|,
name|sc
operator|->
name|w
operator|.
name|irq
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|WX_MMBA
argument_list|,
name|sc
operator|->
name|w
operator|.
name|mem
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|wx_shutdown
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|wx_hw_stop
argument_list|(
operator|(
name|wx_softc_t
operator|*
operator|)
name|device_get_softc
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|INLINE
name|void
name|wx_mwi_whackon
parameter_list|(
name|sc
parameter_list|)
name|wx_softc_t
modifier|*
name|sc
decl_stmt|;
block|{
name|sc
operator|->
name|wx_cmdw
operator|=
name|pci_read_config
argument_list|(
name|sc
operator|->
name|w
operator|.
name|dev
argument_list|,
name|PCIR_COMMAND
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|pci_write_config
argument_list|(
name|sc
operator|->
name|w
operator|.
name|dev
argument_list|,
name|PCIR_COMMAND
argument_list|,
name|sc
operator|->
name|wx_cmdw
operator|&
operator|~
name|MWI
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|INLINE
name|void
name|wx_mwi_unwhack
parameter_list|(
name|sc
parameter_list|)
name|wx_softc_t
modifier|*
name|sc
decl_stmt|;
block|{
if|if
condition|(
name|sc
operator|->
name|wx_cmdw
operator|&
name|MWI
condition|)
block|{
name|pci_write_config
argument_list|(
name|sc
operator|->
name|w
operator|.
name|dev
argument_list|,
name|PCIR_COMMAND
argument_list|,
name|sc
operator|->
name|wx_cmdw
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|wx_dring_setup
parameter_list|(
name|sc
parameter_list|)
name|wx_softc_t
modifier|*
name|sc
decl_stmt|;
block|{
name|size_t
name|len
decl_stmt|;
name|len
operator|=
sizeof|sizeof
argument_list|(
name|wxrd_t
argument_list|)
operator|*
name|WX_MAX_RDESC
expr_stmt|;
name|sc
operator|->
name|rdescriptors
operator|=
operator|(
name|wxrd_t
operator|*
operator|)
name|contigmalloc
argument_list|(
name|len
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|,
literal|0
argument_list|,
operator|~
literal|0
argument_list|,
literal|4096
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|rdescriptors
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"%s: could not allocate rcv descriptors\n"
argument_list|,
name|sc
operator|->
name|wx_name
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|(
operator|(
name|u_long
operator|)
name|sc
operator|->
name|rdescriptors
operator|)
operator|&
literal|0xfff
condition|)
block|{
name|printf
argument_list|(
literal|"%s: rcv descriptors not 4KB aligned\n"
argument_list|,
name|sc
operator|->
name|wx_name
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|bzero
argument_list|(
name|sc
operator|->
name|rdescriptors
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|len
operator|=
sizeof|sizeof
argument_list|(
name|wxtd_t
argument_list|)
operator|*
name|WX_MAX_TDESC
expr_stmt|;
name|sc
operator|->
name|tdescriptors
operator|=
operator|(
name|wxtd_t
operator|*
operator|)
name|contigmalloc
argument_list|(
name|len
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|,
literal|0
argument_list|,
operator|~
literal|0
argument_list|,
literal|4096
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|tdescriptors
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"%s: could not allocate xmt descriptors\n"
argument_list|,
name|sc
operator|->
name|wx_name
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|(
operator|(
name|u_long
operator|)
name|sc
operator|->
name|tdescriptors
operator|)
operator|&
literal|0xfff
condition|)
block|{
name|printf
argument_list|(
literal|"%s: xmt descriptors not 4KB aligned\n"
argument_list|,
name|sc
operator|->
name|wx_name
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|bzero
argument_list|(
name|sc
operator|->
name|tdescriptors
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|wx_dring_teardown
parameter_list|(
name|sc
parameter_list|)
name|wx_softc_t
modifier|*
name|sc
decl_stmt|;
block|{
if|if
condition|(
name|sc
operator|->
name|rdescriptors
condition|)
block|{
name|WXFREE
argument_list|(
name|sc
operator|->
name|rdescriptors
argument_list|)
expr_stmt|;
name|sc
operator|->
name|rdescriptors
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|tdescriptors
condition|)
block|{
name|WXFREE
argument_list|(
name|sc
operator|->
name|tdescriptors
argument_list|)
expr_stmt|;
name|sc
operator|->
name|tdescriptors
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_decl_stmt
specifier|static
name|device_method_t
name|wx_methods
index|[]
init|=
block|{
comment|/* Device interface */
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|wx_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|wx_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|wx_detach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_shutdown
argument_list|,
name|wx_shutdown
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|wx_driver
init|=
block|{
literal|"wx"
block|,
name|wx_methods
block|,
sizeof|sizeof
argument_list|(
name|wx_softc_t
argument_list|)
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|devclass_t
name|wx_devclass
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|if_wx
argument_list|,
name|pci
argument_list|,
name|wx_driver
argument_list|,
name|wx_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Do generic parts of attach. Our registers have been mapped  * and our interrupt registered.  */
end_comment

begin_function
specifier|static
name|int
name|wx_attach_common
parameter_list|(
name|sc
parameter_list|)
name|wx_softc_t
modifier|*
name|sc
decl_stmt|;
block|{
name|size_t
name|len
decl_stmt|;
name|u_int32_t
name|tmp
decl_stmt|;
name|int
name|ll
init|=
literal|0
decl_stmt|;
comment|/* 	 * First, reset the chip. 	 */
name|wx_hw_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * Second, validate our EEPROM. 	 */
comment|/* TBD */
comment|/* 	 * Third, read eeprom for our MAC address and other things. 	 */
name|wx_read_eeprom
argument_list|(
name|sc
argument_list|,
operator|(
name|u_int16_t
operator|*
operator|)
name|sc
operator|->
name|wx_enaddr
argument_list|,
name|WX_EEPROM_MAC_OFF
argument_list|,
literal|3
argument_list|)
expr_stmt|;
comment|/* 	 * Fourth, establish some adapter parameters. 	 */
name|sc
operator|->
name|wx_txint_delay
operator|=
literal|128
expr_stmt|;
name|ifmedia_init
argument_list|(
operator|&
name|sc
operator|->
name|wx_media
argument_list|,
name|IFM_IMASK
argument_list|,
name|wx_ifmedia_upd
argument_list|,
name|wx_ifmedia_sts
argument_list|)
expr_stmt|;
name|ifmedia_add
argument_list|(
operator|&
name|sc
operator|->
name|wx_media
argument_list|,
name|IFM_ETHER
operator||
name|IFM_1000_SX
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ifmedia_add
argument_list|(
operator|&
name|sc
operator|->
name|wx_media
argument_list|,
name|IFM_ETHER
operator||
name|IFM_1000_SX
operator||
name|IFM_FDX
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ifmedia_set
argument_list|(
operator|&
name|sc
operator|->
name|wx_media
argument_list|,
name|IFM_ETHER
operator||
name|IFM_1000_SX
operator||
name|IFM_FDX
argument_list|)
expr_stmt|;
name|sc
operator|->
name|wx_media
operator|.
name|ifm_media
operator|=
name|sc
operator|->
name|wx_media
operator|.
name|ifm_cur
operator|->
name|ifm_media
expr_stmt|;
name|ll
operator|+=
literal|1
expr_stmt|;
comment|/* 	 * Fifth, establish a default device control register word. 	 */
name|sc
operator|->
name|wx_dcr
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|wx_cfg1
operator|&
name|WX_EEPROM_CTLR1_FD
condition|)
name|sc
operator|->
name|wx_dcr
operator||=
name|WXDCR_FD
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|wx_cfg1
operator|&
name|WX_EEPROM_CTLR1_ILOS
condition|)
name|sc
operator|->
name|wx_dcr
operator||=
name|WXDCR_ILOS
expr_stmt|;
name|tmp
operator|=
operator|(
name|sc
operator|->
name|wx_cfg1
operator|>>
name|WX_EEPROM_CTLR1_SWDPIO_SHIFT
operator|)
operator|&
name|WXDCR_SWDPIO_MASK
expr_stmt|;
name|sc
operator|->
name|wx_dcr
operator||=
operator|(
name|tmp
operator|<<
name|WXDCR_SWDPIO_SHIFT
operator|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|wx_no_ilos
condition|)
name|sc
operator|->
name|wx_dcr
operator|&=
operator|~
name|WXDCR_ILOS
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|wx_ilos
condition|)
name|sc
operator|->
name|wx_dcr
operator||=
name|WXDCR_ILOS
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|wx_no_flow
operator|==
literal|0
condition|)
name|sc
operator|->
name|wx_dcr
operator||=
name|WXDCR_RFCE
operator||
name|WXDCR_TFCE
expr_stmt|;
comment|/* 	 * Sixth, allocate various sw structures... 	 */
name|len
operator|=
sizeof|sizeof
argument_list|(
name|rxpkt_t
argument_list|)
operator|*
name|WX_MAX_RDESC
expr_stmt|;
name|sc
operator|->
name|rbase
operator|=
operator|(
name|rxpkt_t
operator|*
operator|)
name|WXMALLOC
argument_list|(
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|rbase
operator|==
name|NULL
condition|)
block|{
goto|goto
name|fail
goto|;
block|}
name|bzero
argument_list|(
name|sc
operator|->
name|rbase
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|ll
operator|+=
literal|1
expr_stmt|;
name|len
operator|=
sizeof|sizeof
argument_list|(
name|txpkt_t
argument_list|)
operator|*
name|WX_MAX_TDESC
expr_stmt|;
name|sc
operator|->
name|tbase
operator|=
operator|(
name|txpkt_t
operator|*
operator|)
name|WXMALLOC
argument_list|(
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|tbase
operator|==
name|NULL
condition|)
block|{
goto|goto
name|fail
goto|;
block|}
name|bzero
argument_list|(
name|sc
operator|->
name|tbase
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|ll
operator|+=
literal|1
expr_stmt|;
comment|/* 	 * Seventh, allocate and dma map (platform dependent) descriptor rings. 	 * They have to be aligned on a 4KB boundary. 	 */
if|if
condition|(
name|wx_dring_setup
argument_list|(
name|sc
argument_list|)
operator|==
literal|0
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|fail
label|:
name|printf
argument_list|(
literal|"%s: failed to do common attach (%d)\n"
argument_list|,
name|sc
operator|->
name|wx_name
argument_list|,
name|ll
argument_list|)
expr_stmt|;
name|wx_dring_teardown
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|rbase
condition|)
block|{
name|WXFREE
argument_list|(
name|sc
operator|->
name|rbase
argument_list|)
expr_stmt|;
name|sc
operator|->
name|rbase
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|tbase
condition|)
block|{
name|WXFREE
argument_list|(
name|sc
operator|->
name|tbase
argument_list|)
expr_stmt|;
name|sc
operator|->
name|tbase
operator|=
name|NULL
expr_stmt|;
block|}
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * EEPROM functions.  */
end_comment

begin_function
specifier|static
name|INLINE
name|void
name|wx_eeprom_raise_clk
parameter_list|(
name|sc
parameter_list|,
name|regval
parameter_list|)
name|wx_softc_t
modifier|*
name|sc
decl_stmt|;
name|u_int32_t
name|regval
decl_stmt|;
block|{
name|WRITE_CSR
argument_list|(
name|sc
argument_list|,
name|WXREG_EECDR
argument_list|,
name|regval
operator||
name|WXEECD_SK
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|50
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|INLINE
name|void
name|wx_eeprom_lower_clk
parameter_list|(
name|sc
parameter_list|,
name|regval
parameter_list|)
name|wx_softc_t
modifier|*
name|sc
decl_stmt|;
name|u_int32_t
name|regval
decl_stmt|;
block|{
name|WRITE_CSR
argument_list|(
name|sc
argument_list|,
name|WXREG_EECDR
argument_list|,
name|regval
operator|&
operator|~
name|WXEECD_SK
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|50
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|INLINE
name|void
name|wx_eeprom_sobits
parameter_list|(
name|sc
parameter_list|,
name|data
parameter_list|,
name|count
parameter_list|)
name|wx_softc_t
modifier|*
name|sc
decl_stmt|;
name|u_int16_t
name|data
decl_stmt|;
name|u_int16_t
name|count
decl_stmt|;
block|{
name|u_int32_t
name|regval
decl_stmt|,
name|mask
decl_stmt|;
name|mask
operator|=
literal|1
operator|<<
operator|(
name|count
operator|-
literal|1
operator|)
expr_stmt|;
name|regval
operator|=
name|READ_CSR
argument_list|(
name|sc
argument_list|,
name|WXREG_EECDR
argument_list|)
operator|&
operator|~
operator|(
name|WXEECD_DI
operator||
name|WXEECD_DO
operator|)
expr_stmt|;
do|do
block|{
if|if
condition|(
name|data
operator|&
name|mask
condition|)
name|regval
operator||=
name|WXEECD_DI
expr_stmt|;
else|else
name|regval
operator|&=
operator|~
name|WXEECD_DI
expr_stmt|;
name|WRITE_CSR
argument_list|(
name|sc
argument_list|,
name|WXREG_EECDR
argument_list|,
name|regval
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|50
argument_list|)
expr_stmt|;
name|wx_eeprom_raise_clk
argument_list|(
name|sc
argument_list|,
name|regval
argument_list|)
expr_stmt|;
name|wx_eeprom_lower_clk
argument_list|(
name|sc
argument_list|,
name|regval
argument_list|)
expr_stmt|;
name|mask
operator|>>=
literal|1
expr_stmt|;
block|}
do|while
condition|(
name|mask
operator|!=
literal|0
condition|)
do|;
name|WRITE_CSR
argument_list|(
name|sc
argument_list|,
name|WXREG_EECDR
argument_list|,
name|regval
operator|&
operator|~
name|WXEECD_DI
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|INLINE
name|u_int16_t
name|wx_eeprom_sibits
parameter_list|(
name|sc
parameter_list|)
name|wx_softc_t
modifier|*
name|sc
decl_stmt|;
block|{
name|unsigned
name|int
name|regval
decl_stmt|,
name|i
decl_stmt|;
name|u_int16_t
name|data
decl_stmt|;
name|data
operator|=
literal|0
expr_stmt|;
name|regval
operator|=
name|READ_CSR
argument_list|(
name|sc
argument_list|,
name|WXREG_EECDR
argument_list|)
operator|&
operator|~
operator|(
name|WXEECD_DI
operator||
name|WXEECD_DO
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|!=
literal|16
condition|;
name|i
operator|++
control|)
block|{
name|data
operator|<<=
literal|1
expr_stmt|;
name|wx_eeprom_raise_clk
argument_list|(
name|sc
argument_list|,
name|regval
argument_list|)
expr_stmt|;
name|regval
operator|=
name|READ_CSR
argument_list|(
name|sc
argument_list|,
name|WXREG_EECDR
argument_list|)
operator|&
operator|~
name|WXEECD_DI
expr_stmt|;
if|if
condition|(
name|regval
operator|&
name|WXEECD_DO
condition|)
block|{
name|data
operator||=
literal|1
expr_stmt|;
block|}
name|wx_eeprom_lower_clk
argument_list|(
name|sc
argument_list|,
name|regval
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|data
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|INLINE
name|void
name|wx_eeprom_cleanup
parameter_list|(
name|sc
parameter_list|)
name|wx_softc_t
modifier|*
name|sc
decl_stmt|;
block|{
name|u_int32_t
name|regval
decl_stmt|;
name|regval
operator|=
name|READ_CSR
argument_list|(
name|sc
argument_list|,
name|WXREG_EECDR
argument_list|)
operator|&
operator|~
operator|(
name|WXEECD_DI
operator||
name|WXEECD_CS
operator|)
expr_stmt|;
name|WRITE_CSR
argument_list|(
name|sc
argument_list|,
name|WXREG_EECDR
argument_list|,
name|regval
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|50
argument_list|)
expr_stmt|;
name|wx_eeprom_raise_clk
argument_list|(
name|sc
argument_list|,
name|regval
argument_list|)
expr_stmt|;
name|wx_eeprom_lower_clk
argument_list|(
name|sc
argument_list|,
name|regval
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|u_int16_t
name|INLINE
name|wx_read_eeprom_word
parameter_list|(
name|sc
parameter_list|,
name|offset
parameter_list|)
name|wx_softc_t
modifier|*
name|sc
decl_stmt|;
name|int
name|offset
decl_stmt|;
block|{
name|u_int16_t
name|data
decl_stmt|;
name|WRITE_CSR
argument_list|(
name|sc
argument_list|,
name|WXREG_EECDR
argument_list|,
name|WXEECD_CS
argument_list|)
expr_stmt|;
name|wx_eeprom_sobits
argument_list|(
name|sc
argument_list|,
name|EEPROM_READ_OPCODE
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|wx_eeprom_sobits
argument_list|(
name|sc
argument_list|,
name|offset
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|data
operator|=
name|wx_eeprom_sibits
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|wx_eeprom_cleanup
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|data
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|wx_read_eeprom
parameter_list|(
name|sc
parameter_list|,
name|data
parameter_list|,
name|offset
parameter_list|,
name|words
parameter_list|)
name|wx_softc_t
modifier|*
name|sc
decl_stmt|;
name|u_int16_t
modifier|*
name|data
decl_stmt|;
name|int
name|offset
decl_stmt|;
name|int
name|words
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|words
condition|;
name|i
operator|++
control|)
block|{
operator|*
name|data
operator|++
operator|=
name|wx_read_eeprom_word
argument_list|(
name|sc
argument_list|,
name|offset
operator|++
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|wx_cfg1
operator|=
name|wx_read_eeprom_word
argument_list|(
name|sc
argument_list|,
name|WX_EEPROM_CTLR1_OFF
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Start packet transmission on the interface.  */
end_comment

begin_function
specifier|static
name|void
name|wx_start
parameter_list|(
name|ifp
parameter_list|)
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
block|{
name|wx_softc_t
modifier|*
name|sc
init|=
name|SOFTC_IFP
argument_list|(
name|ifp
argument_list|)
decl_stmt|;
name|u_int16_t
name|cidx
decl_stmt|,
name|nactv
decl_stmt|;
name|nactv
operator|=
name|sc
operator|->
name|tactive
expr_stmt|;
while|while
condition|(
name|nactv
operator|<
name|WX_MAX_TDESC
condition|)
block|{
name|int
name|ndesc
decl_stmt|;
name|int
name|gctried
init|=
literal|0
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|,
modifier|*
name|mb_head
decl_stmt|;
name|IF_DEQUEUE
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|mb_head
argument_list|)
expr_stmt|;
if|if
condition|(
name|mb_head
operator|==
name|NULL
condition|)
block|{
break|break;
block|}
name|sc
operator|->
name|wx_xmitwanted
operator|++
expr_stmt|;
comment|/* 		 * If we have a packet less than ethermin, pad it out. 		 */
if|if
condition|(
name|mb_head
operator|->
name|m_pkthdr
operator|.
name|len
operator|<
name|WX_MIN_RPKT_SIZE
condition|)
block|{
name|MGETHDR
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|m_freem
argument_list|(
name|mb_head
argument_list|)
expr_stmt|;
break|break;
block|}
name|m_copydata
argument_list|(
name|mb_head
argument_list|,
literal|0
argument_list|,
name|mb_head
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|m
operator|->
name|m_len
operator|=
name|WX_MIN_RPKT_SIZE
expr_stmt|;
name|bzero
argument_list|(
name|mtod
argument_list|(
name|m
argument_list|,
name|char
operator|*
argument_list|)
operator|+
name|mb_head
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|,
name|WX_MIN_RPKT_SIZE
operator|-
name|mb_head
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|)
expr_stmt|;
name|sc
operator|->
name|wx_xmitpullup
operator|++
expr_stmt|;
name|m_freem
argument_list|(
name|mb_head
argument_list|)
expr_stmt|;
name|mb_head
operator|=
name|m
expr_stmt|;
block|}
name|again
label|:
name|cidx
operator|=
name|sc
operator|->
name|tnxtfree
expr_stmt|;
name|nactv
operator|=
name|sc
operator|->
name|tactive
expr_stmt|;
comment|/* 		 * Go through each of the mbufs in the chain and initialize 		 * the transmit buffer descriptors with the physical address 		 * and size of that mbuf. If we have a length less than our 		 * minimum transmit size, we bail (to do a pullup). If we run 		 * out of descriptors, we also bail and try and do a pullup. 		 */
for|for
control|(
name|ndesc
operator|=
literal|0
operator|,
name|m
operator|=
name|mb_head
init|;
name|m
operator|!=
name|NULL
condition|;
name|m
operator|=
name|m
operator|->
name|m_next
control|)
block|{
name|vm_offset_t
name|vptr
decl_stmt|;
name|wxtd_t
modifier|*
name|td
decl_stmt|;
comment|/* 			 * If this mbuf has no data, skip it. 			 */
if|if
condition|(
name|m
operator|->
name|m_len
operator|==
literal|0
condition|)
block|{
continue|continue;
block|}
comment|/* 			 * If this packet is too small for the chip's minimum, 			 * break out to to cluster it. 			 */
if|if
condition|(
name|m
operator|->
name|m_len
operator|<
name|WX_MIN_RPKT_SIZE
condition|)
block|{
name|sc
operator|->
name|wx_xmitrunt
operator|++
expr_stmt|;
break|break;
block|}
comment|/* 			 * Do we have a descriptor available for this mbuf? 			 */
if|if
condition|(
operator|++
name|nactv
operator|==
name|WX_MAX_TDESC
condition|)
block|{
if|if
condition|(
name|gctried
operator|++
operator|==
literal|0
condition|)
block|{
name|sc
operator|->
name|wx_xmitgc
operator|++
expr_stmt|;
name|wx_gc
argument_list|(
name|sc
argument_list|)
expr_stmt|;
goto|goto
name|again
goto|;
block|}
break|break;
block|}
name|sc
operator|->
name|tbase
index|[
name|cidx
index|]
operator|.
name|dptr
operator|=
name|m
expr_stmt|;
name|td
operator|=
operator|&
name|sc
operator|->
name|tdescriptors
index|[
name|cidx
index|]
expr_stmt|;
name|td
operator|->
name|length
operator|=
name|m
operator|->
name|m_len
expr_stmt|;
name|vptr
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
name|vm_offset_t
argument_list|)
expr_stmt|;
name|td
operator|->
name|address
operator|.
name|highpart
operator|=
literal|0
expr_stmt|;
name|td
operator|->
name|address
operator|.
name|lowpart
operator|=
name|vtophys
argument_list|(
name|vptr
argument_list|)
expr_stmt|;
name|td
operator|->
name|cso
operator|=
literal|0
expr_stmt|;
name|td
operator|->
name|status
operator|=
literal|0
expr_stmt|;
name|td
operator|->
name|special
operator|=
literal|0
expr_stmt|;
name|td
operator|->
name|cmd
operator|=
literal|0
expr_stmt|;
name|td
operator|->
name|css
operator|=
literal|0
expr_stmt|;
comment|/* 			 * Mark the last descriptor with EOP and tell the 			 * chip to insert a final checksum. 			 */
if|if
condition|(
name|m
operator|->
name|m_next
operator|==
name|NULL
condition|)
block|{
name|td
operator|->
name|cmd
operator||=
name|TXCMD_EOP
operator||
name|TXCMD_IFCS
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|wx_debug
condition|)
block|{
name|printf
argument_list|(
literal|"%s: XMIT[%d] %p vptr %lx (length %d "
literal|"DMA addr %x) idx %d cmd %x\n"
argument_list|,
name|sc
operator|->
name|wx_name
argument_list|,
name|ndesc
argument_list|,
name|m
argument_list|,
operator|(
name|long
operator|)
name|vptr
argument_list|,
name|td
operator|->
name|length
argument_list|,
name|td
operator|->
name|address
operator|.
name|lowpart
argument_list|,
name|cidx
argument_list|,
name|td
operator|->
name|cmd
argument_list|)
expr_stmt|;
block|}
name|ndesc
operator|++
expr_stmt|;
name|cidx
operator|=
name|T_NXT_IDX
argument_list|(
name|cidx
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * If we get here and m is NULL, we can send 		 * the the packet chain described by mb_head. 		 */
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|sc
operator|->
name|tbase
index|[
name|sc
operator|->
name|tnxtfree
index|]
operator|.
name|sidx
operator|=
name|sc
operator|->
name|tnxtfree
expr_stmt|;
name|sc
operator|->
name|tbase
index|[
name|sc
operator|->
name|tnxtfree
index|]
operator|.
name|eidx
operator|=
name|cidx
expr_stmt|;
name|sc
operator|->
name|tbase
index|[
name|sc
operator|->
name|tnxtfree
index|]
operator|.
name|next
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|tbsyf
condition|)
block|{
name|sc
operator|->
name|tbsyl
operator|->
name|next
operator|=
operator|&
name|sc
operator|->
name|tbase
index|[
name|sc
operator|->
name|tnxtfree
index|]
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|tbsyf
operator|=
operator|&
name|sc
operator|->
name|tbase
index|[
name|sc
operator|->
name|tnxtfree
index|]
expr_stmt|;
block|}
name|sc
operator|->
name|tbsyl
operator|=
operator|&
name|sc
operator|->
name|tbase
index|[
name|sc
operator|->
name|tnxtfree
index|]
expr_stmt|;
name|sc
operator|->
name|tnxtfree
operator|=
name|cidx
expr_stmt|;
name|sc
operator|->
name|tactive
operator|=
name|nactv
expr_stmt|;
name|ifp
operator|->
name|if_timer
operator|=
literal|10
expr_stmt|;
name|WRITE_CSR
argument_list|(
name|sc
argument_list|,
name|WXREG_TDT
argument_list|,
name|cidx
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_bpf
condition|)
name|bpf_mtap
argument_list|(
name|WX_BPFTAP_ARG
argument_list|(
name|ifp
argument_list|)
argument_list|,
name|mb_head
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * Otherwise, we couldn't send this packet for some reason. 		 * 		 * If don't have a descriptor available, and this is a 		 * single mbuf packet, freeze output so that later we 		 * can restart when we have more room. Otherwise, we'll 		 * try and cluster the request. We've already tried to 		 * garbage collect completed descriptors. 		 */
if|if
condition|(
name|nactv
operator|==
name|WX_MAX_TDESC
operator|&&
name|mb_head
operator|->
name|m_next
operator|==
name|NULL
condition|)
block|{
name|sc
operator|->
name|wx_xmitputback
operator|++
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_OACTIVE
expr_stmt|;
name|IF_PREPEND
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|mb_head
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* 		 * Otherwise, it's either a fragment length somewhere in the 		 * chain that isn't at least WX_MIN_XPKT_SIZE in length or 		 * the number of fragments exceeds the number of descriptors 		 * available. 		 * 		 * We could try a variety of strategies here- if this is 		 * a length problem for single mbuf packet or a length problem 		 * for the last mbuf in a chain (we could just try and adjust 		 * it), but it's just simpler to try and cluster it. 		 */
name|MGETHDR
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|m_freem
argument_list|(
name|mb_head
argument_list|)
expr_stmt|;
break|break;
block|}
name|MCLGET
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|m
operator|->
name|m_flags
operator|&
name|M_EXT
operator|)
operator|==
literal|0
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|mb_head
argument_list|)
expr_stmt|;
break|break;
block|}
name|m_copydata
argument_list|(
name|mb_head
argument_list|,
literal|0
argument_list|,
name|mb_head
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|m
operator|->
name|m_len
operator|=
name|mb_head
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
name|m_freem
argument_list|(
name|mb_head
argument_list|)
expr_stmt|;
name|mb_head
operator|=
name|m
expr_stmt|;
name|sc
operator|->
name|wx_xmitcluster
operator|++
expr_stmt|;
goto|goto
name|again
goto|;
block|}
if|if
condition|(
name|sc
operator|->
name|tactive
operator|==
name|WX_MAX_TDESC
condition|)
block|{
name|sc
operator|->
name|wx_xmitblocked
operator|++
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_OACTIVE
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Process interface interrupts.  */
end_comment

begin_function
specifier|static
name|int
name|wx_intr
parameter_list|(
name|arg
parameter_list|)
name|void
modifier|*
name|arg
decl_stmt|;
block|{
name|wx_softc_t
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
name|int
name|claimed
init|=
literal|0
decl_stmt|;
comment|/* 	 * Read interrupt cause register. Reading it clears bits. 	 */
name|sc
operator|->
name|wx_icr
operator|=
name|READ_CSR
argument_list|(
name|sc
argument_list|,
name|WXREG_ICR
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|wx_icr
condition|)
block|{
name|claimed
operator|++
expr_stmt|;
name|WX_DISABLE_INT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|wx_intr
operator|++
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|wx_icr
operator|&
operator|(
name|WXISR_LSC
operator||
name|WXISR_RXSEQ
operator|)
condition|)
block|{
name|wx_handle_link_intr
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
name|wx_handle_rxint
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|tactive
condition|)
block|{
name|wx_gc
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|wx_if
operator|.
name|if_snd
operator|.
name|ifq_head
operator|!=
name|NULL
condition|)
block|{
name|wx_start
argument_list|(
operator|&
name|sc
operator|->
name|wx_if
argument_list|)
expr_stmt|;
block|}
name|WX_ENABLE_INT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|claimed
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|wx_handle_link_intr
parameter_list|(
name|sc
parameter_list|)
name|wx_softc_t
modifier|*
name|sc
decl_stmt|;
block|{
name|sc
operator|->
name|wx_linkintr
operator|++
expr_stmt|;
name|printf
argument_list|(
literal|"%s: link intr 0x%x\n"
argument_list|,
name|sc
operator|->
name|wx_name
argument_list|,
name|sc
operator|->
name|wx_icr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|wx_handle_rxint
parameter_list|(
name|sc
parameter_list|)
name|wx_softc_t
modifier|*
name|sc
decl_stmt|;
block|{
name|struct
name|ether_header
modifier|*
name|eh
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m0
decl_stmt|,
modifier|*
name|mb
decl_stmt|,
modifier|*
name|pending
index|[
name|WX_MAX_RDESC
index|]
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
operator|&
name|sc
operator|->
name|wx_if
decl_stmt|;
name|int
name|npkts
decl_stmt|,
name|ndesc
decl_stmt|,
name|lidx
decl_stmt|,
name|idx
decl_stmt|,
name|tlen
decl_stmt|;
for|for
control|(
name|m0
operator|=
name|sc
operator|->
name|rpending
operator|,
name|tlen
operator|=
name|ndesc
operator|=
name|npkts
operator|=
literal|0
operator|,
name|idx
operator|=
name|sc
operator|->
name|rnxt
operator|,
name|lidx
operator|=
name|R_PREV_IDX
argument_list|(
name|idx
argument_list|)
init|;
name|ndesc
operator|<
name|WX_MAX_RDESC
condition|;
name|ndesc
operator|++
operator|,
name|lidx
operator|=
name|idx
operator|,
name|idx
operator|=
name|R_NXT_IDX
argument_list|(
name|idx
argument_list|)
control|)
block|{
name|wxrd_t
modifier|*
name|rd
decl_stmt|;
name|rxpkt_t
modifier|*
name|rxpkt
decl_stmt|;
name|int
name|length
decl_stmt|,
name|offset
decl_stmt|,
name|lastframe
decl_stmt|;
name|rd
operator|=
operator|&
name|sc
operator|->
name|rdescriptors
index|[
name|idx
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|rd
operator|->
name|status
operator|&
name|RDSTAT_DD
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|m0
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|rpending
operator|==
name|NULL
condition|)
block|{
name|m0
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|tlen
expr_stmt|;
name|sc
operator|->
name|rpending
operator|=
name|m0
expr_stmt|;
block|}
else|else
block|{
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
block|}
name|m0
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|wx_debug
condition|)
block|{
name|printf
argument_list|(
literal|"WXRX: ndesc %d idx %d lidx %d\n"
argument_list|,
name|ndesc
argument_list|,
name|idx
argument_list|,
name|lidx
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
name|rd
operator|->
name|errors
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%s: packet with errors (%x)\n"
argument_list|,
name|sc
operator|->
name|wx_name
argument_list|,
name|rd
operator|->
name|errors
argument_list|)
expr_stmt|;
name|rd
operator|->
name|status
operator|=
literal|0
expr_stmt|;
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
if|if
condition|(
name|m0
condition|)
block|{
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
name|m0
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|rpending
condition|)
block|{
name|m_freem
argument_list|(
name|sc
operator|->
name|rpending
argument_list|)
expr_stmt|;
name|sc
operator|->
name|rpending
operator|=
name|NULL
expr_stmt|;
block|}
block|}
continue|continue;
block|}
name|rxpkt
operator|=
operator|&
name|sc
operator|->
name|rbase
index|[
name|idx
index|]
expr_stmt|;
name|mb
operator|=
name|rxpkt
operator|->
name|dptr
expr_stmt|;
if|if
condition|(
name|mb
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"%s: receive descriptor with no mbuf\n"
argument_list|,
name|sc
operator|->
name|wx_name
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|wx_get_rbuf
argument_list|(
name|sc
argument_list|,
name|rxpkt
argument_list|)
expr_stmt|;
name|rd
operator|->
name|status
operator|=
literal|0
expr_stmt|;
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
if|if
condition|(
name|m0
condition|)
block|{
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
name|m0
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|rpending
condition|)
block|{
name|m_freem
argument_list|(
name|sc
operator|->
name|rpending
argument_list|)
expr_stmt|;
name|sc
operator|->
name|rpending
operator|=
name|NULL
expr_stmt|;
block|}
block|}
continue|continue;
block|}
comment|/* XXX: Flush DMA for rxpkt */
if|if
condition|(
name|wx_get_rbuf
argument_list|(
name|sc
argument_list|,
name|rxpkt
argument_list|)
condition|)
block|{
name|sc
operator|->
name|wx_rxnobuf
operator|++
expr_stmt|;
name|wx_rxdma_map
argument_list|(
name|sc
argument_list|,
name|rxpkt
argument_list|,
name|mb
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
name|rd
operator|->
name|status
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|m0
condition|)
block|{
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
name|m0
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|rpending
condition|)
block|{
name|m_freem
argument_list|(
name|sc
operator|->
name|rpending
argument_list|)
expr_stmt|;
name|sc
operator|->
name|rpending
operator|=
name|NULL
expr_stmt|;
block|}
block|}
continue|continue;
block|}
comment|/* 		 * Save the completing packet's offset value and length 		 * and install the new one into the descriptor. 		 */
name|lastframe
operator|=
operator|(
name|rd
operator|->
name|status
operator|&
name|RDSTAT_EOP
operator|)
operator|!=
literal|0
expr_stmt|;
name|length
operator|=
name|rd
operator|->
name|length
expr_stmt|;
name|offset
operator|=
name|rd
operator|->
name|address
operator|.
name|lowpart
operator|&
literal|0xff
expr_stmt|;
name|bzero
argument_list|(
name|rd
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|rd
argument_list|)
argument_list|)
expr_stmt|;
name|rd
operator|->
name|address
operator|.
name|lowpart
operator|=
name|rxpkt
operator|->
name|dma_addr
operator|+
name|WX_RX_OFFSET_VALUE
expr_stmt|;
name|mb
operator|->
name|m_len
operator|=
name|length
expr_stmt|;
name|mb
operator|->
name|m_data
operator|+=
name|offset
expr_stmt|;
name|mb
operator|->
name|m_next
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|m0
operator|==
name|NULL
condition|)
block|{
name|m0
operator|=
name|mb
expr_stmt|;
name|tlen
operator|=
name|length
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|m0
operator|==
name|sc
operator|->
name|rpending
condition|)
block|{
comment|/* 			 * Pick up where we left off before. If 			 * we have an offset (we're assuming the 			 * first frame has an offset), then we've 			 * lost sync somewhere along the line. 			 */
if|if
condition|(
name|offset
condition|)
block|{
name|printf
argument_list|(
literal|"%s: lost sync with partial packet\n"
argument_list|,
name|sc
operator|->
name|wx_name
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|sc
operator|->
name|rpending
argument_list|)
expr_stmt|;
name|sc
operator|->
name|rpending
operator|=
name|NULL
expr_stmt|;
name|m0
operator|=
name|mb
expr_stmt|;
name|tlen
operator|=
name|length
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|rpending
operator|=
name|NULL
expr_stmt|;
name|tlen
operator|=
name|m0
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
block|}
block|}
else|else
block|{
name|tlen
operator|+=
name|length
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|wx_debug
condition|)
block|{
name|printf
argument_list|(
literal|"%s: RDESC[%d] len %d off %d lastframe %d\n"
argument_list|,
name|sc
operator|->
name|wx_name
argument_list|,
name|idx
argument_list|,
name|mb
operator|->
name|m_len
argument_list|,
name|offset
argument_list|,
name|lastframe
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|m0
operator|!=
name|mb
condition|)
name|m_cat
argument_list|(
name|m0
argument_list|,
name|mb
argument_list|)
expr_stmt|;
if|if
condition|(
name|lastframe
operator|==
literal|0
condition|)
block|{
continue|continue;
block|}
name|m0
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|ifp
expr_stmt|;
name|m0
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|tlen
operator|-
name|WX_CRC_LENGTH
expr_stmt|;
name|mb
operator|->
name|m_len
operator|-=
name|WX_CRC_LENGTH
expr_stmt|;
name|eh
operator|=
name|mtod
argument_list|(
name|m0
argument_list|,
expr|struct
name|ether_header
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_PROMISC
operator|)
operator|&&
operator|(
name|bcmp
argument_list|(
name|eh
operator|->
name|ether_dhost
argument_list|,
name|sc
operator|->
name|wx_enaddr
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
operator|&&
operator|(
name|eh
operator|->
name|ether_dhost
index|[
literal|0
index|]
operator|&
literal|1
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|rpending
condition|)
block|{
name|m_freem
argument_list|(
name|sc
operator|->
name|rpending
argument_list|)
expr_stmt|;
name|sc
operator|->
name|rpending
operator|=
name|NULL
expr_stmt|;
block|}
block|}
else|else
block|{
name|pending
index|[
name|npkts
operator|++
index|]
operator|=
name|m0
expr_stmt|;
block|}
name|m0
operator|=
name|NULL
expr_stmt|;
name|tlen
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|ndesc
condition|)
block|{
name|WRITE_CSR
argument_list|(
name|sc
argument_list|,
name|WXREG_RDT0
argument_list|,
name|lidx
argument_list|)
expr_stmt|;
name|sc
operator|->
name|rnxt
operator|=
name|idx
expr_stmt|;
block|}
if|if
condition|(
name|npkts
condition|)
block|{
name|sc
operator|->
name|wx_rxintr
operator|++
expr_stmt|;
block|}
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
name|npkts
condition|;
name|idx
operator|++
control|)
block|{
name|mb
operator|=
name|pending
index|[
name|idx
index|]
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_bpf
condition|)
block|{
name|bpf_mtap
argument_list|(
name|WX_BPFTAP_ARG
argument_list|(
name|ifp
argument_list|)
argument_list|,
name|mb
argument_list|)
expr_stmt|;
block|}
name|ifp
operator|->
name|if_ipackets
operator|++
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|wx_debug
condition|)
block|{
name|printf
argument_list|(
literal|"%s: RECV packet length %d\n"
argument_list|,
name|sc
operator|->
name|wx_name
argument_list|,
name|mb
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|__FreeBSD__
name|eh
operator|=
name|mtod
argument_list|(
name|mb
argument_list|,
expr|struct
name|ether_header
operator|*
argument_list|)
expr_stmt|;
name|m_adj
argument_list|(
name|mb
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
argument_list|)
expr_stmt|;
name|ether_input
argument_list|(
name|ifp
argument_list|,
name|eh
argument_list|,
name|mb
argument_list|)
expr_stmt|;
else|#
directive|else
call|(
modifier|*
name|ifp
operator|->
name|if_input
call|)
argument_list|(
name|ifp
argument_list|,
name|mb
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|wx_gc
parameter_list|(
name|sc
parameter_list|)
name|wx_softc_t
modifier|*
name|sc
decl_stmt|;
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
operator|&
name|sc
operator|->
name|wx_if
decl_stmt|;
name|txpkt_t
modifier|*
name|txpkt
init|=
name|sc
operator|->
name|tbsyf
decl_stmt|;
name|u_int32_t
name|tdh
init|=
name|READ_CSR
argument_list|(
name|sc
argument_list|,
name|WXREG_TDH
argument_list|)
decl_stmt|;
name|int
name|s
decl_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
while|while
condition|(
name|txpkt
operator|!=
name|NULL
condition|)
block|{
name|u_int32_t
name|end
init|=
name|txpkt
operator|->
name|eidx
decl_stmt|,
name|cidx
init|=
name|tdh
decl_stmt|;
comment|/* 		 * Normalize start..end indices to 2 * 	 	 * WX_MAX_TDESC range to eliminate wrap. 		 */
if|if
condition|(
name|txpkt
operator|->
name|eidx
operator|<
name|txpkt
operator|->
name|sidx
condition|)
block|{
name|end
operator|+=
name|WX_MAX_TDESC
expr_stmt|;
block|}
comment|/* 		 * Normalize current chip index to 2 * 	 	 * WX_MAX_TDESC range to eliminate wrap. 		 */
if|if
condition|(
name|cidx
operator|<
name|txpkt
operator|->
name|sidx
condition|)
block|{
name|cidx
operator|+=
name|WX_MAX_TDESC
expr_stmt|;
block|}
comment|/* 		 * If the current chip index is between low and 		 * high indices for this packet, it's not finished 		 * transmitting yet. Because transmits are done FIFO, 		 * this means we're done garbage collecting too. 		 */
if|if
condition|(
name|txpkt
operator|->
name|sidx
operator|<=
name|cidx
operator|&&
name|cidx
operator|<
name|txpkt
operator|->
name|eidx
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|wx_debug
condition|)
block|{
name|printf
argument_list|(
literal|"%s: TXGC %d..%d TDH %d\n"
argument_list|,
name|sc
operator|->
name|wx_name
argument_list|,
name|txpkt
operator|->
name|sidx
argument_list|,
name|txpkt
operator|->
name|eidx
argument_list|,
name|tdh
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
name|ifp
operator|->
name|if_opackets
operator|++
expr_stmt|;
if|if
condition|(
name|txpkt
operator|->
name|dptr
condition|)
block|{
operator|(
name|void
operator|)
name|m_freem
argument_list|(
name|txpkt
operator|->
name|dptr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"%s: null mbuf in gc\n"
argument_list|,
name|sc
operator|->
name|wx_name
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|cidx
operator|=
name|txpkt
operator|->
name|sidx
init|;
name|cidx
operator|!=
name|txpkt
operator|->
name|eidx
condition|;
name|cidx
operator|=
name|T_NXT_IDX
argument_list|(
name|cidx
argument_list|)
control|)
block|{
name|txpkt_t
modifier|*
name|tmp
decl_stmt|;
name|wxtd_t
modifier|*
name|td
decl_stmt|;
name|td
operator|=
operator|&
name|sc
operator|->
name|tdescriptors
index|[
name|cidx
index|]
expr_stmt|;
if|if
condition|(
name|td
operator|->
name|status
operator|&
name|TXSTS_EC
condition|)
block|{
name|printf
argument_list|(
literal|"%s: excess collisions\n"
argument_list|,
name|sc
operator|->
name|wx_name
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_collisions
operator|++
expr_stmt|;
name|ifp
operator|->
name|if_oerrors
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|td
operator|->
name|status
operator|&
name|TXSTS_LC
condition|)
block|{
name|printf
argument_list|(
literal|"%s: lost carrier\n"
argument_list|,
name|sc
operator|->
name|wx_name
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_oerrors
operator|++
expr_stmt|;
block|}
name|tmp
operator|=
operator|&
name|sc
operator|->
name|tbase
index|[
name|cidx
index|]
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|wx_debug
condition|)
block|{
name|printf
argument_list|(
literal|"%s: TXGC[%d] %p %d..%d done nact %d "
literal|"TDH %d\n"
argument_list|,
name|sc
operator|->
name|wx_name
argument_list|,
name|cidx
argument_list|,
name|tmp
operator|->
name|dptr
argument_list|,
name|txpkt
operator|->
name|sidx
argument_list|,
name|txpkt
operator|->
name|eidx
argument_list|,
name|sc
operator|->
name|tactive
argument_list|,
name|tdh
argument_list|)
expr_stmt|;
block|}
name|tmp
operator|->
name|dptr
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|tactive
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%s: nactive< 0?\n"
argument_list|,
name|sc
operator|->
name|wx_name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|tactive
operator|-=
literal|1
expr_stmt|;
block|}
name|bzero
argument_list|(
name|td
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|td
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|tbsyf
operator|=
name|txpkt
operator|->
name|next
expr_stmt|;
name|txpkt
operator|=
name|sc
operator|->
name|tbsyf
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|tactive
operator|<
name|WX_MAX_TDESC
condition|)
block|{
name|ifp
operator|->
name|if_timer
operator|=
literal|0
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
name|IFF_OACTIVE
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Update packet in/out/collision statistics.  */
end_comment

begin_function
specifier|static
name|void
name|wx_stats_update
parameter_list|(
name|arg
parameter_list|)
name|void
modifier|*
name|arg
decl_stmt|;
block|{
name|wx_softc_t
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
name|int
name|s
decl_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|wx_gc
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* 	 * Schedule another timeout one second from now. 	 */
name|TIMEOUT
argument_list|(
name|sc
argument_list|,
name|wx_stats_update
argument_list|,
name|sc
argument_list|,
name|hz
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Stop and reinitialize the hardware  */
end_comment

begin_function
specifier|static
name|void
name|wx_hw_stop
parameter_list|(
name|sc
parameter_list|)
name|wx_softc_t
modifier|*
name|sc
decl_stmt|;
block|{
name|u_int32_t
name|icr
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|revision
operator|==
literal|2
condition|)
block|{
name|wx_mwi_whackon
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
name|WRITE_CSR
argument_list|(
name|sc
argument_list|,
name|WXREG_DCR
argument_list|,
name|WXDCR_RST
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|20
operator|*
literal|1000
argument_list|)
expr_stmt|;
name|WRITE_CSR
argument_list|(
name|sc
argument_list|,
name|WXREG_IMASK
argument_list|,
operator|~
literal|0
argument_list|)
expr_stmt|;
name|icr
operator|=
name|READ_CSR
argument_list|(
name|sc
argument_list|,
name|WXREG_ICR
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|revision
operator|==
literal|2
condition|)
block|{
name|wx_mwi_unwhack
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
name|WX_DISABLE_INT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|wx_set_addr
parameter_list|(
name|sc
parameter_list|,
name|idx
parameter_list|,
name|mac
parameter_list|)
name|wx_softc_t
modifier|*
name|sc
decl_stmt|;
name|int
name|idx
decl_stmt|;
name|u_int8_t
modifier|*
name|mac
decl_stmt|;
block|{
name|u_int32_t
name|t0
decl_stmt|,
name|t1
decl_stmt|;
name|t0
operator|=
operator|(
name|mac
index|[
literal|0
index|]
operator|)
operator||
operator|(
name|mac
index|[
literal|1
index|]
operator|<<
literal|8
operator|)
operator||
operator|(
name|mac
index|[
literal|2
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
name|mac
index|[
literal|3
index|]
operator|<<
literal|24
operator|)
expr_stmt|;
name|t1
operator|=
operator|(
name|mac
index|[
literal|4
index|]
operator|<<
literal|0
operator|)
operator||
operator|(
name|mac
index|[
literal|5
index|]
operator|<<
literal|8
operator|)
expr_stmt|;
name|t1
operator||=
name|WX_RAL_AV
expr_stmt|;
name|WRITE_CSR
argument_list|(
name|sc
argument_list|,
name|WXREG_RAL_LO
argument_list|(
name|idx
argument_list|)
argument_list|,
name|t0
argument_list|)
expr_stmt|;
name|WRITE_CSR
argument_list|(
name|sc
argument_list|,
name|WXREG_RAL_HI
argument_list|(
name|idx
argument_list|)
argument_list|,
name|t1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|wx_hw_initialize
parameter_list|(
name|sc
parameter_list|)
name|wx_softc_t
modifier|*
name|sc
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|WRITE_CSR
argument_list|(
name|sc
argument_list|,
name|WXREG_VET
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|WX_VLAN_TAB_SIZE
operator|<<
literal|2
operator|)
condition|;
name|i
operator|+=
literal|4
control|)
block|{
name|WRITE_CSR
argument_list|(
name|sc
argument_list|,
operator|(
name|WXREG_VFTA
operator|+
name|i
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|revision
operator|==
literal|2
condition|)
block|{
name|wx_mwi_whackon
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|WRITE_CSR
argument_list|(
name|sc
argument_list|,
name|WXREG_RCTL
argument_list|,
name|WXRCTL_RST
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|5
operator|*
literal|1000
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Load the first receiver address with our MAC address, 	 * and load as many multicast addresses as can fit into 	 * the receive address array. 	 */
name|wx_set_addr
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
name|sc
operator|->
name|wx_enaddr
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|sc
operator|->
name|wx_nmca
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|>=
name|WX_RAL_TAB_SIZE
condition|)
block|{
break|break;
block|}
else|else
block|{
name|wx_set_addr
argument_list|(
name|sc
argument_list|,
name|i
argument_list|,
name|sc
operator|->
name|wx_mcaddr
index|[
name|i
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
block|}
while|while
condition|(
name|i
operator|<
name|WX_RAL_TAB_SIZE
condition|)
block|{
name|WRITE_CSR
argument_list|(
name|sc
argument_list|,
name|WXREG_RAL_LO
argument_list|(
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|WRITE_CSR
argument_list|(
name|sc
argument_list|,
name|WXREG_RAL_HI
argument_list|(
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|revision
operator|==
literal|2
condition|)
block|{
name|WRITE_CSR
argument_list|(
name|sc
argument_list|,
name|WXREG_RCTL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1
operator|*
literal|1000
argument_list|)
expr_stmt|;
name|wx_mwi_unwhack
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Clear out the hashed multicast table array. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|WX_MC_TAB_SIZE
condition|;
name|i
operator|++
control|)
block|{
name|WRITE_CSR
argument_list|(
name|sc
argument_list|,
name|WXREG_MTA
operator|+
operator|(
sizeof|sizeof
argument_list|(
name|u_int32_t
argument_list|)
operator|*
literal|4
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|wx_dcr
operator|&
operator|(
name|WXDCR_RFCE
operator||
name|WXDCR_TFCE
operator|)
condition|)
block|{
name|WRITE_CSR
argument_list|(
name|sc
argument_list|,
name|WXREG_FCAL
argument_list|,
name|FC_FRM_CONST_LO
argument_list|)
expr_stmt|;
name|WRITE_CSR
argument_list|(
name|sc
argument_list|,
name|WXREG_FCAH
argument_list|,
name|FC_FRM_CONST_HI
argument_list|)
expr_stmt|;
name|WRITE_CSR
argument_list|(
name|sc
argument_list|,
name|WXREG_FCT
argument_list|,
name|FC_TYP_CONST
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|WRITE_CSR
argument_list|(
name|sc
argument_list|,
name|WXREG_FCAL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|WRITE_CSR
argument_list|(
name|sc
argument_list|,
name|WXREG_FCAH
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|WRITE_CSR
argument_list|(
name|sc
argument_list|,
name|WXREG_FCT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|WRITE_CSR
argument_list|(
name|sc
argument_list|,
name|WXREG_FLOW_XTIMER
argument_list|,
name|WX_XTIMER_DFLT
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|revision
operator|==
literal|2
condition|)
block|{
name|WRITE_CSR
argument_list|(
name|sc
argument_list|,
name|WXREG_FLOW_RCV_HI
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|WRITE_CSR
argument_list|(
name|sc
argument_list|,
name|WXREG_FLOW_RCV_LO
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|WRITE_CSR
argument_list|(
name|sc
argument_list|,
name|WXREG_FLOW_RCV_HI
argument_list|,
name|WX_RCV_FLOW_HI_DFLT
argument_list|)
expr_stmt|;
name|WRITE_CSR
argument_list|(
name|sc
argument_list|,
name|WXREG_FLOW_RCV_LO
argument_list|,
name|WX_RCV_FLOW_LO_DFLT
argument_list|)
expr_stmt|;
block|}
name|WRITE_CSR
argument_list|(
name|sc
argument_list|,
name|WXREG_XMIT_CFGW
argument_list|,
name|WXTXCW_DEFAULT
argument_list|)
expr_stmt|;
name|WRITE_CSR
argument_list|(
name|sc
argument_list|,
name|WXREG_DCR
argument_list|,
name|sc
operator|->
name|wx_dcr
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|50
operator|*
literal|1000
argument_list|)
expr_stmt|;
comment|/* 	 * The pin stuff is all FM from the Linux driver. 	 */
if|if
condition|(
operator|(
name|READ_CSR
argument_list|(
name|sc
argument_list|,
name|WXREG_DCR
argument_list|)
operator|&
name|WXDCR_SWDPIN1
operator|)
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|500
condition|;
name|i
operator|++
control|)
block|{
name|DELAY
argument_list|(
literal|10
operator|*
literal|1000
argument_list|)
expr_stmt|;
if|if
condition|(
name|READ_CSR
argument_list|(
name|sc
argument_list|,
name|WXREG_DSR
argument_list|)
operator|&
name|WXDSR_LU
condition|)
block|{
name|sc
operator|->
name|linkup
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
block|}
else|else
block|{
name|printf
argument_list|(
literal|"%s: swdpio did not clear\n"
argument_list|,
name|sc
operator|->
name|wx_name
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|sc
operator|->
name|linkup
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%s: link never came up\n"
argument_list|,
name|sc
operator|->
name|wx_name
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|sc
operator|->
name|wx_ienable
operator|=
name|WXIENABLE_DEFAULT
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Stop the interface. Cancels the statistics updater and resets the interface.  */
end_comment

begin_function
specifier|static
name|void
name|wx_stop
parameter_list|(
name|sc
parameter_list|)
name|wx_softc_t
modifier|*
name|sc
decl_stmt|;
block|{
name|txpkt_t
modifier|*
name|txp
decl_stmt|;
name|rxpkt_t
modifier|*
name|rxp
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
operator|&
name|sc
operator|->
name|wx_if
decl_stmt|;
comment|/* 	 * Cancel stats updater. 	 */
name|UNTIMEOUT
argument_list|(
name|wx_stats_update
argument_list|,
name|sc
argument_list|,
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * Reset the chip 	 */
name|wx_hw_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * Release any xmit buffers. 	 */
for|for
control|(
name|txp
operator|=
name|sc
operator|->
name|tbase
init|;
name|txp
operator|&&
name|txp
operator|<
operator|&
name|sc
operator|->
name|tbase
index|[
name|WX_MAX_TDESC
index|]
condition|;
name|txp
operator|++
control|)
block|{
if|if
condition|(
name|txp
operator|->
name|dptr
condition|)
block|{
name|m_free
argument_list|(
name|txp
operator|->
name|dptr
argument_list|)
expr_stmt|;
name|txp
operator|->
name|dptr
operator|=
name|NULL
expr_stmt|;
block|}
block|}
comment|/* 	 * Free all the receive buffers. 	 */
for|for
control|(
name|rxp
operator|=
name|sc
operator|->
name|rbase
init|;
name|rxp
operator|&&
name|rxp
operator|<
operator|&
name|sc
operator|->
name|rbase
index|[
name|WX_MAX_RDESC
index|]
condition|;
name|rxp
operator|++
control|)
block|{
if|if
condition|(
name|rxp
operator|->
name|dptr
condition|)
block|{
name|m_free
argument_list|(
name|rxp
operator|->
name|dptr
argument_list|)
expr_stmt|;
name|rxp
operator|->
name|dptr
operator|=
name|NULL
expr_stmt|;
block|}
block|}
if|if
condition|(
name|sc
operator|->
name|rpending
condition|)
block|{
name|m_freem
argument_list|(
name|sc
operator|->
name|rpending
argument_list|)
expr_stmt|;
name|sc
operator|->
name|rpending
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* 	 * And we're outta here... 	 */
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
operator|(
name|IFF_RUNNING
operator||
name|IFF_OACTIVE
operator|)
expr_stmt|;
name|ifp
operator|->
name|if_timer
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Watchdog/transmission transmit timeout handler.  */
end_comment

begin_function
specifier|static
name|void
name|wx_watchdog
parameter_list|(
name|ifp
parameter_list|)
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
block|{
name|wx_softc_t
modifier|*
name|sc
init|=
name|SOFTC_IFP
argument_list|(
name|ifp
argument_list|)
decl_stmt|;
name|printf
argument_list|(
literal|"%s: device timeout\n"
argument_list|,
name|sc
operator|->
name|wx_name
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_oerrors
operator|++
expr_stmt|;
if|if
condition|(
name|wx_init
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"%s: could not re-init device\n"
argument_list|,
name|sc
operator|->
name|wx_name
argument_list|)
expr_stmt|;
name|VTIMEOUT
argument_list|(
name|sc
argument_list|,
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
name|void
operator|*
argument_list|)
operator|)
name|wx_init
argument_list|,
name|sc
argument_list|,
name|hz
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|wx_init
parameter_list|(
name|xsc
parameter_list|)
name|void
modifier|*
name|xsc
decl_stmt|;
block|{
name|struct
name|ifmedia
modifier|*
name|ifm
decl_stmt|;
name|wx_softc_t
modifier|*
name|sc
init|=
name|xsc
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
operator|&
name|sc
operator|->
name|wx_if
decl_stmt|;
name|rxpkt_t
modifier|*
name|rxpkt
decl_stmt|;
name|wxrd_t
modifier|*
name|rd
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|int
name|s
decl_stmt|,
name|i
decl_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
comment|/* 	 * Cancel any pending I/O by resetting things. 	 * wx_stop will free any allocated mbufs. 	 */
name|wx_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * Reset the hardware. All network addresses loaded here, but 	 * neither the receiver nor the transmitter are enabled. 	 */
if|if
condition|(
name|wx_hw_initialize
argument_list|(
name|sc
argument_list|)
condition|)
block|{
return|return
operator|(
name|EIO
operator|)
return|;
block|}
comment|/* 	 * Set up the receive ring stuff. 	 */
name|len
operator|=
sizeof|sizeof
argument_list|(
name|wxrd_t
argument_list|)
operator|*
name|WX_MAX_RDESC
expr_stmt|;
name|bzero
argument_list|(
name|sc
operator|->
name|rdescriptors
argument_list|,
name|len
argument_list|)
expr_stmt|;
for|for
control|(
name|rxpkt
operator|=
name|sc
operator|->
name|rbase
operator|,
name|i
operator|=
literal|0
init|;
name|rxpkt
operator|!=
name|NULL
operator|&&
name|i
operator|<
name|WX_MAX_RDESC
condition|;
name|i
operator|+=
name|RXINCR
operator|,
name|rxpkt
operator|++
control|)
block|{
name|rd
operator|=
operator|&
name|sc
operator|->
name|rdescriptors
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|wx_get_rbuf
argument_list|(
name|sc
argument_list|,
name|rxpkt
argument_list|)
condition|)
block|{
break|break;
block|}
name|rd
operator|->
name|address
operator|.
name|lowpart
operator|=
name|rxpkt
operator|->
name|dma_addr
operator|+
name|WX_RX_OFFSET_VALUE
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|!=
name|WX_MAX_RDESC
condition|)
block|{
name|printf
argument_list|(
literal|"%s: could not set up rbufs\n"
argument_list|,
name|sc
operator|->
name|wx_name
argument_list|)
expr_stmt|;
name|wx_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
comment|/* 	 * Set up transmit parameters and enable the transmitter. 	 */
name|sc
operator|->
name|tnxtfree
operator|=
name|sc
operator|->
name|tactive
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|tbsyf
operator|=
name|sc
operator|->
name|tbsyl
operator|=
name|NULL
expr_stmt|;
name|WRITE_CSR
argument_list|(
name|sc
argument_list|,
name|WXREG_TCTL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|5
operator|*
literal|1000
argument_list|)
expr_stmt|;
name|WRITE_CSR
argument_list|(
name|sc
argument_list|,
name|WXREG_TDBA_LO
argument_list|,
name|vtophys
argument_list|(
operator|(
name|vm_offset_t
operator|)
operator|&
name|sc
operator|->
name|tdescriptors
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|WRITE_CSR
argument_list|(
name|sc
argument_list|,
name|WXREG_TDBA_HI
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|WRITE_CSR
argument_list|(
name|sc
argument_list|,
name|WXREG_TDLEN
argument_list|,
name|WX_MAX_TDESC
operator|*
sizeof|sizeof
argument_list|(
name|wxtd_t
argument_list|)
argument_list|)
expr_stmt|;
name|WRITE_CSR
argument_list|(
name|sc
argument_list|,
name|WXREG_TDH
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|WRITE_CSR
argument_list|(
name|sc
argument_list|,
name|WXREG_TDT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|WRITE_CSR
argument_list|(
name|sc
argument_list|,
name|WXREG_TQSA_HI
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|WRITE_CSR
argument_list|(
name|sc
argument_list|,
name|WXREG_TQSA_LO
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|WRITE_CSR
argument_list|(
name|sc
argument_list|,
name|WXREG_TIPG
argument_list|,
name|WX_TIPG_DFLT
argument_list|)
expr_stmt|;
name|WRITE_CSR
argument_list|(
name|sc
argument_list|,
name|WXREG_TIDV
argument_list|,
name|sc
operator|->
name|wx_txint_delay
argument_list|)
expr_stmt|;
name|WRITE_CSR
argument_list|(
name|sc
argument_list|,
name|WXREG_TCTL
argument_list|,
operator|(
name|WXTCTL_CT
argument_list|(
name|WX_COLLISION_THRESHOLD
argument_list|)
operator||
name|WXTCTL_COLD
argument_list|(
name|WX_FDX_COLLISION_DX
argument_list|)
operator||
name|WXTCTL_EN
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Set up receive parameters and enable the receiver. 	 */
name|sc
operator|->
name|rnxt
operator|=
literal|0
expr_stmt|;
name|WRITE_CSR
argument_list|(
name|sc
argument_list|,
name|WXREG_RCTL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|5
operator|*
literal|1000
argument_list|)
expr_stmt|;
name|WRITE_CSR
argument_list|(
name|sc
argument_list|,
name|WXREG_RDTR0
argument_list|,
name|WXRDTR_FPD
argument_list|)
expr_stmt|;
name|WRITE_CSR
argument_list|(
name|sc
argument_list|,
name|WXREG_RDBA0_LO
argument_list|,
name|vtophys
argument_list|(
operator|(
name|vm_offset_t
operator|)
operator|&
name|sc
operator|->
name|rdescriptors
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|WRITE_CSR
argument_list|(
name|sc
argument_list|,
name|WXREG_RDBA0_HI
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|WRITE_CSR
argument_list|(
name|sc
argument_list|,
name|WXREG_RDLEN0
argument_list|,
name|WX_MAX_RDESC
operator|*
sizeof|sizeof
argument_list|(
name|wxrd_t
argument_list|)
argument_list|)
expr_stmt|;
name|WRITE_CSR
argument_list|(
name|sc
argument_list|,
name|WXREG_RDH0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|WRITE_CSR
argument_list|(
name|sc
argument_list|,
name|WXREG_RDT0
argument_list|,
operator|(
name|WX_MAX_RDESC
operator|-
name|RXINCR
operator|)
argument_list|)
expr_stmt|;
name|WRITE_CSR
argument_list|(
name|sc
argument_list|,
name|WXREG_RDTR1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|WRITE_CSR
argument_list|(
name|sc
argument_list|,
name|WXREG_RDBA1_LO
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|WRITE_CSR
argument_list|(
name|sc
argument_list|,
name|WXREG_RDBA1_HI
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|WRITE_CSR
argument_list|(
name|sc
argument_list|,
name|WXREG_RDLEN1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|WRITE_CSR
argument_list|(
name|sc
argument_list|,
name|WXREG_RDH1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|WRITE_CSR
argument_list|(
name|sc
argument_list|,
name|WXREG_RDT1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|WRITE_CSR(sc, WXREG_RCTL, WXRCTL_EN | WXRCTL_LPE | WXRCTL_512BRBUF | 	    ((ifp->if_flags& IFF_BROADCAST) ? WXRCTL_BAM : 0) | 	    ((ifp->if_flags& IFF_PROMISC) ? WXRCTL_UPE : 0) | 	    ((sc->all_mcasts) ? WXRCTL_MPE : 0)); 	WRITE_CSR(sc, WXREG_RCTL, WXRCTL_EN | WXRCTL_LPE | WXRCTL_2KRBUF | 	    ((ifp->if_flags& IFF_BROADCAST) ? WXRCTL_BAM : 0) | 	    ((ifp->if_flags& IFF_PROMISC) ? WXRCTL_UPE : 0) | 	    ((sc->all_mcasts) ? WXRCTL_MPE : 0));
endif|#
directive|endif
name|WRITE_CSR
argument_list|(
name|sc
argument_list|,
name|WXREG_RCTL
argument_list|,
name|WXRCTL_EN
operator||
name|WXRCTL_2KRBUF
operator||
operator|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_BROADCAST
operator|)
condition|?
name|WXRCTL_BAM
else|:
literal|0
operator|)
operator||
operator|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_PROMISC
operator|)
condition|?
name|WXRCTL_UPE
else|:
literal|0
operator|)
operator||
operator|(
operator|(
name|sc
operator|->
name|all_mcasts
operator|)
condition|?
name|WXRCTL_MPE
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Enable Interrupts 	 */
name|WX_ENABLE_INT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * Mark that we're up and running... 	 */
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_RUNNING
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
name|IFF_OACTIVE
expr_stmt|;
name|ifm
operator|=
operator|&
name|sc
operator|->
name|wx_media
expr_stmt|;
name|i
operator|=
name|ifm
operator|->
name|ifm_media
expr_stmt|;
name|ifm
operator|->
name|ifm_media
operator|=
name|ifm
operator|->
name|ifm_cur
operator|->
name|ifm_media
expr_stmt|;
name|wx_ifmedia_upd
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|ifm
operator|->
name|ifm_media
operator|=
name|i
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* 	 * Start stats updater. 	 */
name|TIMEOUT
argument_list|(
name|sc
argument_list|,
name|wx_stats_update
argument_list|,
name|sc
argument_list|,
name|hz
argument_list|)
expr_stmt|;
comment|/* 	 * And we're outta here... 	 */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Get a receive buffer for our use (and dma map the data area).  *   * This chip can have buffers be 256, 512, 1024 or 2048 bytes in size.  * It wants them aligned on 256 byte boundaries, but can actually cope  * with an offset in the first 255 bytes of the head of a receive frame.  *  * We'll allocate a MCLBYTE sized cluster but *not* adjust the data pointer  * by any alignment value. Instead, we'll tell the chip to offset by any  * alignment and we'll catch the alignment on the backend at interrupt time.  */
end_comment

begin_function
specifier|static
name|void
name|wx_rxdma_map
parameter_list|(
name|sc
parameter_list|,
name|rxpkt
parameter_list|,
name|mb
parameter_list|)
name|wx_softc_t
modifier|*
name|sc
decl_stmt|;
name|rxpkt_t
modifier|*
name|rxpkt
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|mb
decl_stmt|;
block|{
name|rxpkt
operator|->
name|dptr
operator|=
name|mb
expr_stmt|;
name|rxpkt
operator|->
name|dma_addr
operator|=
name|vtophys
argument_list|(
name|mtod
argument_list|(
name|mb
argument_list|,
name|vm_offset_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|wx_get_rbuf
parameter_list|(
name|sc
parameter_list|,
name|rxpkt
parameter_list|)
name|wx_softc_t
modifier|*
name|sc
decl_stmt|;
name|rxpkt_t
modifier|*
name|rxpkt
decl_stmt|;
block|{
name|struct
name|mbuf
modifier|*
name|mb
decl_stmt|;
name|MGETHDR
argument_list|(
name|mb
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|mb
operator|==
name|NULL
condition|)
block|{
name|rxpkt
operator|->
name|dptr
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|MCLGET
argument_list|(
name|mb
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|mb
operator|->
name|m_flags
operator|&
name|M_EXT
operator|)
operator|==
literal|0
condition|)
block|{
name|m_freem
argument_list|(
name|mb
argument_list|)
expr_stmt|;
name|rxpkt
operator|->
name|dptr
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|wx_rxdma_map
argument_list|(
name|sc
argument_list|,
name|rxpkt
argument_list|,
name|mb
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|wx_ioctl
parameter_list|(
name|ifp
parameter_list|,
name|command
parameter_list|,
name|data
parameter_list|)
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|IOCTL_CMD_TYPE
name|command
decl_stmt|;
name|caddr_t
name|data
decl_stmt|;
block|{
name|wx_softc_t
modifier|*
name|sc
init|=
name|SOFTC_IFP
argument_list|(
name|ifp
argument_list|)
decl_stmt|;
name|struct
name|ifreq
modifier|*
name|ifr
init|=
operator|(
expr|struct
name|ifreq
operator|*
operator|)
name|data
decl_stmt|;
name|int
name|s
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|command
condition|)
block|{
case|case
name|SIOCSIFADDR
case|:
if|#
directive|if
operator|!
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
case|case
name|SIOCGIFADDR
case|:
ifdef|#
directive|ifdef
name|SIOCSIFMTU
case|case
name|SIOCSIFMTU
case|:
endif|#
directive|endif
endif|#
directive|endif
name|error
operator|=
name|ether_ioctl
argument_list|(
name|ifp
argument_list|,
name|command
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCSIFFLAGS
case|:
name|sc
operator|->
name|all_mcasts
operator|=
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_ALLMULTI
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
comment|/* 		 * If interface is marked up and not running, then start it. 		 * If it is marked down and running, stop it. 		 * If it's up then re-initialize it. This is so flags 		 * such as IFF_PROMISC are handled. 		 */
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
condition|)
block|{
name|error
operator|=
name|wx_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
condition|)
block|{
name|wx_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
ifdef|#
directive|ifdef
name|SIOCADDMULTI
case|case
name|SIOCADDMULTI
case|:
case|case
name|SIOCDELMULTI
case|:
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
block|{
name|int
name|all_mc_change
init|=
operator|(
name|sc
operator|->
name|all_mcasts
operator|==
operator|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_ALLMULTI
operator|)
condition|?
literal|1
else|:
literal|0
operator|)
operator|)
decl_stmt|;
name|error
operator|=
operator|(
name|command
operator|==
name|SIOCADDMULTI
operator|)
condition|?
name|ether_addmulti
argument_list|(
name|ifr
argument_list|,
operator|&
name|sc
operator|->
name|w
operator|.
name|ethercom
argument_list|)
else|:
name|ether_delmulti
argument_list|(
name|ifr
argument_list|,
operator|&
name|sc
operator|->
name|w
operator|.
name|ethercom
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
name|ENETRESET
operator|&&
name|all_mc_change
operator|==
literal|0
condition|)
block|{
break|break;
block|}
block|}
endif|#
directive|endif
name|sc
operator|->
name|all_mcasts
operator|=
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_ALLMULTI
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|error
operator|=
name|wx_mc_setup
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIOCGIFMEDIA
case|case
name|SIOCGIFMEDIA
case|:
case|case
name|SIOCSIFMEDIA
case|:
name|error
operator|=
name|ifmedia_ioctl
argument_list|(
name|ifp
argument_list|,
name|ifr
argument_list|,
operator|&
name|sc
operator|->
name|wx_media
argument_list|,
name|command
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|wx_ifmedia_upd
parameter_list|(
name|ifp
parameter_list|)
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
block|{
name|struct
name|wx_softc
modifier|*
name|sc
init|=
name|SOFTC_IFP
argument_list|(
name|ifp
argument_list|)
decl_stmt|;
name|struct
name|ifmedia
modifier|*
name|ifm
init|=
operator|&
name|sc
operator|->
name|wx_media
decl_stmt|;
if|if
condition|(
name|IFM_TYPE
argument_list|(
name|ifm
operator|->
name|ifm_media
argument_list|)
operator|!=
name|IFM_ETHER
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|wx_ifmedia_sts
parameter_list|(
name|ifp
parameter_list|,
name|ifmr
parameter_list|)
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|ifmediareq
modifier|*
name|ifmr
decl_stmt|;
block|{
name|struct
name|wx_softc
modifier|*
name|sc
init|=
name|SOFTC_IFP
argument_list|(
name|ifp
argument_list|)
decl_stmt|;
name|ifmr
operator|->
name|ifm_status
operator|=
name|IFM_AVALID
expr_stmt|;
name|ifmr
operator|->
name|ifm_active
operator|=
name|IFM_ETHER
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|linkup
operator|==
literal|0
condition|)
return|return;
name|ifmr
operator|->
name|ifm_status
operator||=
name|IFM_ACTIVE
operator||
name|IFM_1000_SX
expr_stmt|;
if|if
condition|(
name|READ_CSR
argument_list|(
name|sc
argument_list|,
name|WXREG_DSR
argument_list|)
operator|&
name|WXDSR_FD
condition|)
name|ifmr
operator|->
name|ifm_active
operator||=
name|IFM_FDX
expr_stmt|;
block|}
end_function

end_unit

