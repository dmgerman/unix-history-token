begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$OpenBSD: if_tx.c,v 1.3 1998/10/10 04:30:09 jason Exp $	*/
end_comment

begin_comment
comment|/* $FreeBSD$ */
end_comment

begin_comment
comment|/*-  * Copyright (c) 1997 Semen Ustimenko (semen@iclub.nsu.ru)  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *  */
end_comment

begin_comment
comment|/*  * EtherPower II 10/100  Fast Ethernet (tx0)  * (aka SMC9432TX based on SMC83c170 EPIC chip)  *   * Thanks are going to Steve Bauer and Jason Wright.  *  * todo:  *	Deal with bus mastering, i.e. i realy don't know what to do with  *	    it and how it can improve performance.  *	Implement FULL IFF_MULTICAST support.  *	Test, test and test again:-(  *	  */
end_comment

begin_comment
comment|/* We should define compile time options before if_txvar.h included */
end_comment

begin_comment
comment|/*#define	EPIC_NOIFMEDIA	1*/
end_comment

begin_comment
comment|/*#define	EPIC_USEIOSPACE	1*/
end_comment

begin_define
define|#
directive|define
name|EARLY_RX
value|1
end_define

begin_comment
comment|/*#define	EPIC_DEBUG	1*/
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|EPIC_DEBUG
argument_list|)
end_if

begin_define
define|#
directive|define
name|dprintf
parameter_list|(
name|a
parameter_list|)
value|printf a
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|dprintf
parameter_list|(
name|a
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Macro to get either mbuf cluster or nothing */
end_comment

begin_define
define|#
directive|define
name|EPIC_MGETCLUSTER
parameter_list|(
name|m
parameter_list|)
define|\
value|{ MGETHDR((m),M_DONTWAIT,MT_DATA); \ 	  if (m) { \ 	    MCLGET((m),M_DONTWAIT); \ 	    if( NULL == ((m)->m_flags& M_EXT) ){ \ 	      m_freem(m); \ 	      (m) = NULL; \ 	    } \ 	  } \ 	}
end_define

begin_include
include|#
directive|include
file|"bpf.h"
end_include

begin_include
include|#
directive|include
file|"opt_bdg.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_dl.h>
end_include

begin_include
include|#
directive|include
file|<net/if_types.h>
end_include

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|SIOCSIFMEDIA
argument_list|)
operator|||
name|defined
argument_list|(
name|EPIC_NOIFMEDIA
argument_list|)
end_if

begin_define
define|#
directive|define
name|EPIC_NOIFMEDIA
value|1
end_define

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<net/if_media.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|INET
end_ifdef

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_systm.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|IPX
end_ifdef

begin_include
include|#
directive|include
file|<netipx/ipx.h>
end_include

begin_include
include|#
directive|include
file|<netipx/ipx_if.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|NS
end_ifdef

begin_include
include|#
directive|include
file|<netns/ns.h>
end_include

begin_include
include|#
directive|include
file|<netns/ns_if.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|NBPF
operator|>
literal|0
end_if

begin_include
include|#
directive|include
file|<net/bpf.h>
end_include

begin_include
include|#
directive|include
file|<net/bpfdesc.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__OpenBSD__
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/device.h>
end_include

begin_include
include|#
directive|include
file|<netinet/if_ether.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcivar.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcireg.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcidevs.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/if_txvar.h>
end_include

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* __FreeBSD__ */
end_comment

begin_include
include|#
directive|include
file|<sys/eventhandler.h>
end_include

begin_include
include|#
directive|include
file|<net/if_mib.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/if_ether.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<machine/clock.h>
end_include

begin_include
include|#
directive|include
file|<pci/pcivar.h>
end_include

begin_include
include|#
directive|include
file|<pci/if_txvar.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|BRIDGE
end_ifdef

begin_include
include|#
directive|include
file|<net/bridge.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
end_if

begin_if
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|300000
end_if

begin_define
define|#
directive|define
name|EPIC_IFIOCTL_CMD_TYPE
value|u_long
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|EPIC_IFIOCTL_CMD_TYPE
value|int
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|EPIC_INTR_RET_TYPE
value|void
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* __OpenBSD__ */
end_comment

begin_define
define|#
directive|define
name|EPIC_IFIOCTL_CMD_TYPE
value|u_long
end_define

begin_define
define|#
directive|define
name|EPIC_INTR_RET_TYPE
value|int
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|int
name|epic_ifioctl
name|__P
argument_list|(
operator|(
specifier|register
expr|struct
name|ifnet
operator|*
operator|,
name|EPIC_IFIOCTL_CMD_TYPE
operator|,
name|caddr_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|EPIC_INTR_RET_TYPE
name|epic_intr
name|__P
argument_list|(
operator|(
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|epic_common_attach
name|__P
argument_list|(
operator|(
name|epic_softc_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|epic_ifstart
name|__P
argument_list|(
operator|(
expr|struct
name|ifnet
operator|*
specifier|const
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|epic_ifwatchdog
name|__P
argument_list|(
operator|(
expr|struct
name|ifnet
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|epic_init
name|__P
argument_list|(
operator|(
name|epic_softc_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|epic_stop
name|__P
argument_list|(
operator|(
name|epic_softc_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|__inline
name|void
name|epic_rx_done
name|__P
argument_list|(
operator|(
name|epic_softc_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|__inline
name|void
name|epic_tx_done
name|__P
argument_list|(
operator|(
name|epic_softc_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|epic_init_rings
name|__P
argument_list|(
operator|(
name|epic_softc_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|epic_free_rings
name|__P
argument_list|(
operator|(
name|epic_softc_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|epic_stop_activity
name|__P
argument_list|(
operator|(
name|epic_softc_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|epic_start_activity
name|__P
argument_list|(
operator|(
name|epic_softc_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|epic_set_rx_mode
name|__P
argument_list|(
operator|(
name|epic_softc_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|epic_set_tx_mode
name|__P
argument_list|(
operator|(
name|epic_softc_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|epic_set_mc_table
name|__P
argument_list|(
operator|(
name|epic_softc_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|epic_set_media_speed
name|__P
argument_list|(
operator|(
name|epic_softc_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|epic_init_phy
name|__P
argument_list|(
operator|(
name|epic_softc_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|epic_dump_state
name|__P
argument_list|(
operator|(
name|epic_softc_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|epic_autoneg
name|__P
argument_list|(
operator|(
name|epic_softc_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|epic_read_eeprom
name|__P
argument_list|(
operator|(
name|epic_softc_t
operator|*
operator|,
name|u_int16_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|epic_output_eepromw
name|__P
argument_list|(
operator|(
name|epic_softc_t
operator|*
operator|,
name|u_int16_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_int16_t
name|epic_input_eepromw
name|__P
argument_list|(
operator|(
name|epic_softc_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_int8_t
name|epic_eeprom_clock
name|__P
argument_list|(
operator|(
name|epic_softc_t
operator|*
operator|,
name|u_int8_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|epic_write_eepromreg
name|__P
argument_list|(
operator|(
name|epic_softc_t
operator|*
operator|,
name|u_int8_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_int8_t
name|epic_read_eepromreg
name|__P
argument_list|(
operator|(
name|epic_softc_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_int16_t
name|epic_read_phy_register
name|__P
argument_list|(
operator|(
name|epic_softc_t
operator|*
operator|,
name|u_int16_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|epic_write_phy_register
name|__P
argument_list|(
operator|(
name|epic_softc_t
operator|*
operator|,
name|u_int16_t
operator|,
name|u_int16_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|EPIC_NOIFMEDIA
argument_list|)
end_if

begin_decl_stmt
specifier|static
name|int
name|epic_ifmedia_change
name|__P
argument_list|(
operator|(
expr|struct
name|ifnet
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|epic_ifmedia_status
name|__P
argument_list|(
operator|(
expr|struct
name|ifnet
operator|*
operator|,
expr|struct
name|ifmediareq
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|int
name|epic_mtypes
index|[]
init|=
block|{
name|IFM_ETHER
operator||
name|IFM_10_T
block|,
name|IFM_ETHER
operator||
name|IFM_10_T
operator||
name|IFM_FDX
block|,
name|IFM_ETHER
operator||
name|IFM_100_TX
block|,
name|IFM_ETHER
operator||
name|IFM_100_TX
operator||
name|IFM_FDX
block|,
name|IFM_ETHER
operator||
name|IFM_10_T
operator||
name|IFM_LOOP
block|,
name|IFM_ETHER
operator||
name|IFM_10_T
operator||
name|IFM_FDX
operator||
name|IFM_LOOP
block|,
name|IFM_ETHER
operator||
name|IFM_10_T
operator||
name|IFM_LOOP
operator||
name|IFM_FLAG1
block|,
name|IFM_ETHER
operator||
name|IFM_100_TX
operator||
name|IFM_LOOP
block|,
name|IFM_ETHER
operator||
name|IFM_100_TX
operator||
name|IFM_LOOP
operator||
name|IFM_FLAG1
block|,
name|IFM_ETHER
operator||
name|IFM_100_TX
operator||
name|IFM_FDX
operator||
name|IFM_LOOP
block|,
name|IFM_ETHER
operator||
name|IFM_AUTO
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|EPIC_MTYPESNUM
value|(sizeof(epic_mtypes) / sizeof(epic_mtypes[0]))
end_define

begin_comment
comment|/* -------------------------------------------------------------------------    OS-specific part    ------------------------------------------------------------------------- */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__OpenBSD__
argument_list|)
end_if

begin_comment
comment|/* -----------------------------OpenBSD------------------------------------- */
end_comment

begin_decl_stmt
specifier|static
name|int
name|epic_openbsd_probe
name|__P
argument_list|(
operator|(
expr|struct
name|device
operator|*
operator|,
name|void
operator|*
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|epic_openbsd_attach
name|__P
argument_list|(
operator|(
expr|struct
name|device
operator|*
operator|,
expr|struct
name|device
operator|*
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|epic_shutdown
name|__P
argument_list|(
operator|(
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|cfattach
name|tx_ca
init|=
block|{
sizeof|sizeof
argument_list|(
name|epic_softc_t
argument_list|)
block|,
name|epic_openbsd_probe
block|,
name|epic_openbsd_attach
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|cfdriver
name|tx_cd
init|=
block|{
name|NULL
block|,
literal|"tx"
block|,
name|DV_IFNET
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Synopsis: Check if device id corresponds with SMC83C170 id. */
end_comment

begin_function
specifier|static
name|int
name|epic_openbsd_probe
parameter_list|(
name|struct
name|device
modifier|*
name|parent
parameter_list|,
name|void
modifier|*
name|match
parameter_list|,
name|void
modifier|*
name|aux
parameter_list|)
block|{
name|struct
name|pci_attach_args
modifier|*
name|pa
init|=
name|aux
decl_stmt|;
if|if
condition|(
name|PCI_VENDOR
argument_list|(
name|pa
operator|->
name|pa_id
argument_list|)
operator|!=
name|SMC_VENDORID
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|PCI_PRODUCT
argument_list|(
name|pa
operator|->
name|pa_id
argument_list|)
operator|==
name|CHIPID_83C170
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|epic_openbsd_attach
parameter_list|(
name|struct
name|device
modifier|*
name|parent
parameter_list|,
name|struct
name|device
modifier|*
name|self
parameter_list|,
name|void
modifier|*
name|aux
parameter_list|)
block|{
name|epic_softc_t
modifier|*
name|sc
init|=
operator|(
name|epic_softc_t
operator|*
operator|)
name|self
decl_stmt|;
name|struct
name|pci_attach_args
modifier|*
name|pa
init|=
name|aux
decl_stmt|;
name|pci_chipset_tag_t
name|pc
init|=
name|pa
operator|->
name|pa_pc
decl_stmt|;
name|pci_intr_handle_t
name|ih
decl_stmt|;
specifier|const
name|char
modifier|*
name|intrstr
init|=
name|NULL
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|bus_space_tag_t
name|iot
init|=
name|pa
operator|->
name|pa_iot
decl_stmt|;
name|bus_addr_t
name|iobase
decl_stmt|;
name|bus_size_t
name|iosize
decl_stmt|;
name|int
name|i
decl_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|EPIC_NOIFMEDIA
argument_list|)
name|int
name|tmp
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|pci_io_find
argument_list|(
name|pc
argument_list|,
name|pa
operator|->
name|pa_tag
argument_list|,
name|PCI_CBIO
argument_list|,
operator|&
name|iobase
argument_list|,
operator|&
name|iosize
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|": can't find i/o space\n"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|bus_space_map
argument_list|(
name|iot
argument_list|,
name|iobase
argument_list|,
name|iosize
argument_list|,
literal|0
argument_list|,
operator|&
name|sc
operator|->
name|sc_sh
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|": can't map i/o space\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|sc
operator|->
name|sc_st
operator|=
name|iot
expr_stmt|;
name|ifp
operator|=
operator|&
name|sc
operator|->
name|sc_if
expr_stmt|;
name|bcopy
argument_list|(
name|sc
operator|->
name|sc_dev
operator|.
name|dv_xname
argument_list|,
name|ifp
operator|->
name|if_xname
argument_list|,
name|IFNAMSIZ
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_softc
operator|=
name|sc
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|=
name|IFF_BROADCAST
operator||
name|IFF_SIMPLEX
operator||
name|IFF_MULTICAST
expr_stmt|;
name|ifp
operator|->
name|if_ioctl
operator|=
name|epic_ifioctl
expr_stmt|;
name|ifp
operator|->
name|if_start
operator|=
name|epic_ifstart
expr_stmt|;
name|ifp
operator|->
name|if_watchdog
operator|=
name|epic_ifwatchdog
expr_stmt|;
comment|/* Do common attach procedure */
if|if
condition|(
name|epic_common_attach
argument_list|(
name|sc
argument_list|)
condition|)
return|return;
comment|/* Map interrupt */
if|if
condition|(
name|pci_intr_map
argument_list|(
name|pc
argument_list|,
name|pa
operator|->
name|pa_intrtag
argument_list|,
name|pa
operator|->
name|pa_intrpin
argument_list|,
name|pa
operator|->
name|pa_intrline
argument_list|,
operator|&
name|ih
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|": can't map interrupt\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|intrstr
operator|=
name|pci_intr_string
argument_list|(
name|pc
argument_list|,
name|ih
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_ih
operator|=
name|pci_intr_establish
argument_list|(
name|pc
argument_list|,
name|ih
argument_list|,
name|IPL_NET
argument_list|,
name|epic_intr
argument_list|,
name|sc
argument_list|,
name|self
operator|->
name|dv_xname
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|sc
operator|->
name|sc_ih
condition|)
block|{
name|printf
argument_list|(
literal|": can't establish interrupt"
argument_list|)
expr_stmt|;
if|if
condition|(
name|intrstr
condition|)
name|printf
argument_list|(
literal|" at %s"
argument_list|,
name|intrstr
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|printf
argument_list|(
literal|": %s"
argument_list|,
name|intrstr
argument_list|)
expr_stmt|;
comment|/* Display some info */
name|printf
argument_list|(
literal|" address %s"
argument_list|,
name|ether_sprintf
argument_list|(
name|sc
operator|->
name|sc_macaddr
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Read current media config and display it too */
name|i
operator|=
name|PHY_READ_2
argument_list|(
name|sc
argument_list|,
name|DP83840_BMCR
argument_list|)
expr_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|EPIC_NOIFMEDIA
argument_list|)
name|tmp
operator|=
name|IFM_ETHER
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|i
operator|&
name|BMCR_AUTONEGOTIATION
condition|)
block|{
name|printf
argument_list|(
literal|", Auto-Neg "
argument_list|)
expr_stmt|;
comment|/* To avoid bug in QS6612 read LPAR enstead of BMSR */
name|i
operator|=
name|PHY_READ_2
argument_list|(
name|sc
argument_list|,
name|DP83840_LPAR
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|&
operator|(
name|ANAR_100_TX
operator||
name|ANAR_100_TX_FD
operator|)
condition|)
name|printf
argument_list|(
literal|"100Mbps"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"10Mbps"
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|&
operator|(
name|ANAR_10_FD
operator||
name|ANAR_100_TX_FD
operator|)
condition|)
name|printf
argument_list|(
literal|" FD"
argument_list|)
expr_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|EPIC_NOIFMEDIA
argument_list|)
name|tmp
operator||=
name|IFM_AUTO
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
if|#
directive|if
name|defined
argument_list|(
name|EPIC_NOIFMEDIA
argument_list|)
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_LINK0
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|i
operator|&
name|BMCR_100MBPS
condition|)
block|{
name|printf
argument_list|(
literal|", 100Mbps"
argument_list|)
expr_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|EPIC_NOIFMEDIA
argument_list|)
name|tmp
operator||=
name|IFM_100_TX
expr_stmt|;
else|#
directive|else
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_LINK2
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
name|printf
argument_list|(
literal|", 10Mbps"
argument_list|)
expr_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|EPIC_NOIFMEDIA
argument_list|)
name|tmp
operator||=
name|IFM_10_T
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|i
operator|&
name|BMCR_FULL_DUPLEX
condition|)
block|{
name|printf
argument_list|(
literal|" FD"
argument_list|)
expr_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|EPIC_NOIFMEDIA
argument_list|)
name|tmp
operator||=
name|IFM_FDX
expr_stmt|;
else|#
directive|else
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_LINK1
expr_stmt|;
endif|#
directive|endif
block|}
block|}
comment|/* Init ifmedia interface */
if|#
directive|if
operator|!
name|defined
argument_list|(
name|EPIC_NOIFMEDIA
argument_list|)
name|ifmedia_init
argument_list|(
operator|&
name|sc
operator|->
name|ifmedia
argument_list|,
literal|0
argument_list|,
name|epic_ifmedia_change
argument_list|,
name|epic_ifmedia_status
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|EPIC_MTYPESNUM
condition|;
name|i
operator|++
control|)
name|ifmedia_add
argument_list|(
operator|&
name|sc
operator|->
name|ifmedia
argument_list|,
name|epic_mtypes
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ifmedia_set
argument_list|(
operator|&
name|sc
operator|->
name|ifmedia
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Attach os interface and bpf */
name|if_attach
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|ether_ifattach
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
if|#
directive|if
name|NBPF
operator|>
literal|0
name|bpfattach
argument_list|(
operator|&
name|sc
operator|->
name|sc_if
operator|.
name|if_bpf
argument_list|,
name|ifp
argument_list|,
name|DLT_EN10MB
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Set shutdown routine to stop DMA process */
name|shutdownhook_establish
argument_list|(
name|epic_shutdown
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Simple call epic_stop() */
end_comment

begin_function
specifier|static
name|void
name|epic_shutdown
parameter_list|(
name|void
modifier|*
name|sc
parameter_list|)
block|{
name|epic_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* __FreeBSD__ */
end_comment

begin_comment
comment|/* -----------------------------FreeBSD------------------------------------- */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|epic_freebsd_probe
name|__P
argument_list|(
operator|(
name|pcici_t
operator|,
name|pcidi_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|epic_freebsd_attach
name|__P
argument_list|(
operator|(
name|pcici_t
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|epic_shutdown
name|__P
argument_list|(
operator|(
name|void
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Global variables */
end_comment

begin_decl_stmt
specifier|static
name|u_long
name|epic_pci_count
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|pci_device
name|txdevice
init|=
block|{
literal|"tx"
block|,
name|epic_freebsd_probe
block|,
name|epic_freebsd_attach
block|,
operator|&
name|epic_pci_count
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Append this driver to pci drivers list */
end_comment

begin_expr_stmt
name|COMPAT_PCI_DRIVER
argument_list|(
name|tx
argument_list|,
name|txdevice
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Synopsis: Check if device id corresponds with SMC83C170 id.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|epic_freebsd_probe
parameter_list|(
name|pcici_t
name|config_id
parameter_list|,
name|pcidi_t
name|device_id
parameter_list|)
block|{
if|if
condition|(
name|PCI_VENDORID
argument_list|(
name|device_id
argument_list|)
operator|!=
name|SMC_VENDORID
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|PCI_CHIPID
argument_list|(
name|device_id
argument_list|)
operator|==
name|CHIPID_83C170
condition|)
return|return
literal|"SMC 83c170"
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/*  * Do FreeBSD-specific attach routine, like map registers, alloc softc  * structure and etc.  */
end_comment

begin_function
specifier|static
name|void
name|epic_freebsd_attach
parameter_list|(
name|pcici_t
name|config_id
parameter_list|,
name|int
name|unit
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|epic_softc_t
modifier|*
name|sc
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|EPIC_USEIOSPACE
argument_list|)
name|u_int32_t
name|iobase
decl_stmt|;
else|#
directive|else
name|caddr_t
name|pmembase
decl_stmt|;
endif|#
directive|endif
name|int
name|i
decl_stmt|,
name|s
decl_stmt|,
name|tmp
decl_stmt|;
name|printf
argument_list|(
literal|"tx%d"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
comment|/* Allocate memory for softc, hardware descriptors and frag lists */
name|sc
operator|=
operator|(
name|epic_softc_t
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|epic_softc_t
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
return|return;
comment|/* Preinitialize softc structure */
name|bzero
argument_list|(
name|sc
argument_list|,
sizeof|sizeof
argument_list|(
name|epic_softc_t
argument_list|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|unit
operator|=
name|unit
expr_stmt|;
comment|/* Fill ifnet structure */
name|ifp
operator|=
operator|&
name|sc
operator|->
name|sc_if
expr_stmt|;
name|ifp
operator|->
name|if_unit
operator|=
name|unit
expr_stmt|;
name|ifp
operator|->
name|if_name
operator|=
literal|"tx"
expr_stmt|;
name|ifp
operator|->
name|if_softc
operator|=
name|sc
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|=
name|IFF_BROADCAST
operator||
name|IFF_SIMPLEX
operator||
name|IFF_MULTICAST
expr_stmt|;
name|ifp
operator|->
name|if_ioctl
operator|=
name|epic_ifioctl
expr_stmt|;
name|ifp
operator|->
name|if_start
operator|=
name|epic_ifstart
expr_stmt|;
name|ifp
operator|->
name|if_watchdog
operator|=
name|epic_ifwatchdog
expr_stmt|;
name|ifp
operator|->
name|if_init
operator|=
operator|(
name|if_init_f_t
operator|*
operator|)
name|epic_init
expr_stmt|;
name|ifp
operator|->
name|if_timer
operator|=
literal|0
expr_stmt|;
name|ifp
operator|->
name|if_output
operator|=
name|ether_output
expr_stmt|;
name|ifp
operator|->
name|if_snd
operator|.
name|ifq_maxlen
operator|=
name|TX_RING_SIZE
expr_stmt|;
comment|/* Get iobase or membase */
if|#
directive|if
name|defined
argument_list|(
name|EPIC_USEIOSPACE
argument_list|)
if|if
condition|(
operator|!
name|pci_map_port
argument_list|(
name|config_id
argument_list|,
name|PCI_CBIO
argument_list|,
operator|(
name|u_short
operator|*
operator|)
operator|&
operator|(
name|sc
operator|->
name|iobase
operator|)
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|": cannot map port\n"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sc
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return;
block|}
else|#
directive|else
if|if
condition|(
operator|!
name|pci_map_mem
argument_list|(
name|config_id
argument_list|,
name|PCI_CBMA
argument_list|,
operator|(
name|vm_offset_t
operator|*
operator|)
operator|&
operator|(
name|sc
operator|->
name|csr
operator|)
argument_list|,
operator|(
name|vm_offset_t
operator|*
operator|)
operator|&
name|pmembase
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|": cannot map memory\n"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sc
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
if|if
condition|(
name|epic_common_attach
argument_list|(
name|sc
argument_list|)
condition|)
return|return;
comment|/* Display ethernet address ,... */
name|printf
argument_list|(
literal|": address %02x:%02x:%02x:%02x:%02x:%02x,"
argument_list|,
name|sc
operator|->
name|sc_macaddr
index|[
literal|0
index|]
argument_list|,
name|sc
operator|->
name|sc_macaddr
index|[
literal|1
index|]
argument_list|,
name|sc
operator|->
name|sc_macaddr
index|[
literal|2
index|]
argument_list|,
name|sc
operator|->
name|sc_macaddr
index|[
literal|3
index|]
argument_list|,
name|sc
operator|->
name|sc_macaddr
index|[
literal|4
index|]
argument_list|,
name|sc
operator|->
name|sc_macaddr
index|[
literal|5
index|]
argument_list|)
expr_stmt|;
comment|/* board type and ... */
name|printf
argument_list|(
literal|" type "
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0x2c
init|;
name|i
operator|<
literal|0x32
condition|;
name|i
operator|++
control|)
block|{
name|tmp
operator|=
name|epic_read_eeprom
argument_list|(
name|sc
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
literal|' '
operator|==
operator|(
name|u_int8_t
operator|)
name|tmp
condition|)
break|break;
name|printf
argument_list|(
literal|"%c"
argument_list|,
operator|(
name|u_int8_t
operator|)
name|tmp
argument_list|)
expr_stmt|;
name|tmp
operator|>>=
literal|8
expr_stmt|;
if|if
condition|(
literal|' '
operator|==
operator|(
name|u_int8_t
operator|)
name|tmp
condition|)
break|break;
name|printf
argument_list|(
literal|"%c"
argument_list|,
operator|(
name|u_int8_t
operator|)
name|tmp
argument_list|)
expr_stmt|;
block|}
comment|/* Read current media config and display it too */
name|i
operator|=
name|PHY_READ_2
argument_list|(
name|sc
argument_list|,
name|DP83840_BMCR
argument_list|)
expr_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|EPIC_NOIFMEDIA
argument_list|)
name|tmp
operator|=
name|IFM_ETHER
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|i
operator|&
name|BMCR_AUTONEGOTIATION
condition|)
block|{
name|printf
argument_list|(
literal|", Auto-Neg "
argument_list|)
expr_stmt|;
comment|/* To avoid bug in QS6612 read LPAR enstead of BMSR */
name|i
operator|=
name|PHY_READ_2
argument_list|(
name|sc
argument_list|,
name|DP83840_LPAR
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|&
operator|(
name|ANAR_100_TX
operator||
name|ANAR_100_TX_FD
operator|)
condition|)
name|printf
argument_list|(
literal|"100Mbps "
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"10Mbps "
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|&
operator|(
name|ANAR_10_FD
operator||
name|ANAR_100_TX_FD
operator|)
condition|)
name|printf
argument_list|(
literal|"FD"
argument_list|)
expr_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|EPIC_NOIFMEDIA
argument_list|)
name|tmp
operator||=
name|IFM_AUTO
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
if|#
directive|if
name|defined
argument_list|(
name|EPIC_NOIFMEDIA
argument_list|)
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_LINK0
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|i
operator|&
name|BMCR_100MBPS
condition|)
block|{
name|printf
argument_list|(
literal|", 100Mbps "
argument_list|)
expr_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|EPIC_NOIFMEDIA
argument_list|)
name|tmp
operator||=
name|IFM_100_TX
expr_stmt|;
else|#
directive|else
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_LINK2
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
name|printf
argument_list|(
literal|", 10Mbps "
argument_list|)
expr_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|EPIC_NOIFMEDIA
argument_list|)
name|tmp
operator||=
name|IFM_10_T
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|i
operator|&
name|BMCR_FULL_DUPLEX
condition|)
block|{
name|printf
argument_list|(
literal|"FD"
argument_list|)
expr_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|EPIC_NOIFMEDIA
argument_list|)
name|tmp
operator||=
name|IFM_FDX
expr_stmt|;
else|#
directive|else
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_LINK1
expr_stmt|;
endif|#
directive|endif
block|}
block|}
comment|/* Init ifmedia interface */
if|#
directive|if
operator|!
name|defined
argument_list|(
name|EPIC_NOIFMEDIA
argument_list|)
name|ifmedia_init
argument_list|(
operator|&
name|sc
operator|->
name|ifmedia
argument_list|,
literal|0
argument_list|,
name|epic_ifmedia_change
argument_list|,
name|epic_ifmedia_status
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|EPIC_MTYPESNUM
condition|;
name|i
operator|++
control|)
name|ifmedia_add
argument_list|(
operator|&
name|sc
operator|->
name|ifmedia
argument_list|,
name|epic_mtypes
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ifmedia_set
argument_list|(
operator|&
name|sc
operator|->
name|ifmedia
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
comment|/* Map interrupt */
if|if
condition|(
operator|!
name|pci_map_int
argument_list|(
name|config_id
argument_list|,
name|epic_intr
argument_list|,
operator|(
name|void
operator|*
operator|)
name|sc
argument_list|,
operator|&
name|net_imask
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|": couldn't map interrupt\n"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sc
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Set shut down routine to stop DMA processes on reboot */
name|EVENTHANDLER_REGISTER
argument_list|(
name|shutdown_post_sync
argument_list|,
name|epic_shutdown
argument_list|,
name|sc
argument_list|,
name|SHUTDOWN_PRI_DEFAULT
argument_list|)
expr_stmt|;
comment|/*  Attach to if manager */
name|if_attach
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|ether_ifattach
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
if|#
directive|if
name|NBPF
operator|>
literal|0
name|bpfattach
argument_list|(
name|ifp
argument_list|,
name|DLT_EN10MB
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|epic_shutdown
parameter_list|(
name|void
modifier|*
name|sc
parameter_list|,
name|int
name|howto
parameter_list|)
block|{
name|epic_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __OpenBSD__ */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------    OS-independing part    ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/*  * This is if_ioctl handler.   */
end_comment

begin_decl_stmt
specifier|static
name|int
name|epic_ifioctl
name|__P
argument_list|(
operator|(
specifier|register
expr|struct
name|ifnet
operator|*
name|ifp
operator|,
name|EPIC_IFIOCTL_CMD_TYPE
name|command
operator|,
name|caddr_t
name|data
operator|)
argument_list|)
block|{
name|epic_softc_t
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|int
name|x
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
name|x
operator|=
name|splimp
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|command
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
case|case
name|SIOCSIFADDR
case|:
case|case
name|SIOCGIFADDR
case|:
case|case
name|SIOCSIFMTU
case|:
name|error
operator|=
name|ether_ioctl
argument_list|(
name|ifp
argument_list|,
name|command
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
else|#
directive|else
comment|/* __OpenBSD__ */
case|case
name|SIOCSIFADDR
case|:
block|{
name|struct
name|ifaddr
modifier|*
name|ifa
init|=
operator|(
expr|struct
name|ifaddr
operator|*
operator|)
name|data
decl_stmt|;
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_UP
expr_stmt|;
switch|switch
condition|(
name|ifa
operator|->
name|ifa_addr
operator|->
name|sa_family
condition|)
block|{
if|#
directive|if
name|INET
case|case
name|AF_INET
case|:
name|epic_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|epic_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|arp_ifinit
argument_list|(
operator|&
name|sc
operator|->
name|arpcom
argument_list|,
name|ifa
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* __FreeBSD__ */
if|#
directive|if
name|NS
case|case
name|AF_NS
case|:
block|{
specifier|register
name|struct
name|ns_addr
modifier|*
name|ina
init|=
operator|&
name|IA_SNS
argument_list|(
name|ifa
argument_list|)
operator|->
name|sns_addr
decl_stmt|;
if|if
condition|(
name|ns_nullhost
argument_list|(
operator|*
name|ina
argument_list|)
condition|)
name|ina
operator|->
name|x_host
operator|=
operator|*
operator|(
expr|union
name|ns_host
operator|*
operator|)
name|LLADDR
argument_list|(
name|ifp
operator|->
name|if_sadl
argument_list|)
expr_stmt|;
else|else
name|bcopy
argument_list|(
name|ina
operator|->
name|x_host
operator|.
name|c_host
argument_list|,
name|LLADDR
argument_list|(
name|ifp
operator|->
name|if_sadl
argument_list|)
argument_list|,
name|ifp
operator|->
name|if_addrlen
argument_list|)
expr_stmt|;
name|epic_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|epic_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
default|default:
name|epic_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|epic_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
endif|#
directive|endif
case|case
name|SIOCSIFFLAGS
case|:
comment|/* 		 * If the interface is marked up and stopped, then start it. 		 * If it is marked down and running, then stop it. 		 */
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
condition|)
block|{
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
operator|)
operator|==
literal|0
condition|)
block|{
name|epic_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
condition|)
block|{
name|epic_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|epic_stop_activity
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Handle IFF_PROMISC flag */
name|epic_set_rx_mode
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|EPIC_NOIFMEDIA
argument_list|)
comment|/* Handle IFF_LINKx flags */
name|epic_set_media_speed
argument_list|(
name|sc
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|epic_start_activity
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCADDMULTI
case|:
case|case
name|SIOCDELMULTI
case|:
comment|/* Update out multicast list */
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
operator|&&
name|__FreeBSD_version
operator|>=
literal|300000
name|epic_set_mc_table
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
else|#
directive|else
name|error
operator|=
operator|(
name|command
operator|==
name|SIOCADDMULTI
operator|)
condition|?
name|ether_addmulti
argument_list|(
operator|(
expr|struct
name|ifreq
operator|*
operator|)
name|data
argument_list|,
operator|&
name|sc
operator|->
name|arpcom
argument_list|)
else|:
name|ether_delmulti
argument_list|(
operator|(
expr|struct
name|ifreq
operator|*
operator|)
name|data
argument_list|,
operator|&
name|sc
operator|->
name|arpcom
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|ENETRESET
condition|)
block|{
name|epic_set_mc_table
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
break|break;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|EPIC_NOIFMEDIA
argument_list|)
case|case
name|SIOCSIFMEDIA
case|:
case|case
name|SIOCGIFMEDIA
case|:
name|error
operator|=
name|ifmedia_ioctl
argument_list|(
name|ifp
argument_list|,
operator|(
expr|struct
name|ifreq
operator|*
operator|)
name|data
argument_list|,
operator|&
name|sc
operator|->
name|ifmedia
argument_list|,
name|command
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
name|splx
argument_list|(
name|x
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_decl_stmt

begin_comment
comment|/*  * OS-independed part of attach process. allocate memory for descriptors  * and frag lists, wake up chip, read MAC address and PHY identyfier.  * Return -1 on failure.  */
end_comment

begin_function
specifier|static
name|int
name|epic_common_attach
parameter_list|(
name|epic_softc_t
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|caddr_t
name|pool
decl_stmt|;
name|i
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|epic_frag_list
argument_list|)
operator|*
name|TX_RING_SIZE
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|epic_rx_desc
argument_list|)
operator|*
name|RX_RING_SIZE
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|epic_tx_desc
argument_list|)
operator|*
name|TX_RING_SIZE
operator|+
name|PAGE_SIZE
operator|,
name|sc
operator|->
name|pool
operator|=
operator|(
name|epic_softc_t
operator|*
operator|)
name|malloc
argument_list|(
name|i
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|pool
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|": can't allocate memory for buffers\n"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|bzero
argument_list|(
name|sc
operator|->
name|pool
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* Align pool on PAGE_SIZE */
name|pool
operator|=
operator|(
name|caddr_t
operator|)
name|sc
operator|->
name|pool
expr_stmt|;
name|pool
operator|=
call|(
name|caddr_t
call|)
argument_list|(
call|(
name|u_int32_t
call|)
argument_list|(
name|pool
operator|+
name|PAGE_SIZE
operator|-
literal|1
argument_list|)
operator|&
operator|~
operator|(
name|PAGE_SIZE
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
comment|/* Distribute memory */
name|sc
operator|->
name|tx_flist
operator|=
operator|(
name|void
operator|*
operator|)
name|pool
expr_stmt|;
name|pool
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|epic_frag_list
argument_list|)
operator|*
name|TX_RING_SIZE
expr_stmt|;
name|sc
operator|->
name|rx_desc
operator|=
operator|(
name|void
operator|*
operator|)
name|pool
expr_stmt|;
name|pool
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|epic_rx_desc
argument_list|)
operator|*
name|RX_RING_SIZE
expr_stmt|;
name|sc
operator|->
name|tx_desc
operator|=
operator|(
name|void
operator|*
operator|)
name|pool
expr_stmt|;
comment|/* Bring the chip out of low-power mode. */
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|GENCTL
argument_list|,
literal|0x0000
argument_list|)
expr_stmt|;
comment|/* Workaround for Application Note 7-15 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|TEST1
argument_list|,
name|TEST1_CLOCK_TEST
argument_list|)
expr_stmt|;
comment|/* Read mac address from EEPROM */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ETHER_ADDR_LEN
operator|/
sizeof|sizeof
argument_list|(
name|u_int16_t
argument_list|)
condition|;
name|i
operator|++
control|)
operator|(
operator|(
name|u_int16_t
operator|*
operator|)
name|sc
operator|->
name|sc_macaddr
operator|)
index|[
name|i
index|]
operator|=
name|epic_read_eeprom
argument_list|(
name|sc
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* Identify PHY */
name|sc
operator|->
name|phyid
operator|=
name|PHY_READ_2
argument_list|(
name|sc
argument_list|,
name|DP83840_PHYIDR1
argument_list|)
operator|<<
literal|6
expr_stmt|;
name|sc
operator|->
name|phyid
operator||=
operator|(
name|PHY_READ_2
argument_list|(
name|sc
argument_list|,
name|DP83840_PHYIDR2
argument_list|)
operator|>>
literal|10
operator|)
operator|&
literal|0x3F
expr_stmt|;
if|if
condition|(
name|QS6612_OUI
operator|!=
name|sc
operator|->
name|phyid
condition|)
name|printf
argument_list|(
literal|": WARNING! PHY unknown (0x%x)"
argument_list|,
name|sc
operator|->
name|phyid
argument_list|)
expr_stmt|;
name|sc
operator|->
name|tx_threshold
operator|=
name|TRANSMIT_THRESHOLD
expr_stmt|;
name|sc
operator|->
name|txcon
operator|=
name|TXCON_DEFAULT
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * This is if_start handler. It takes mbufs from if_snd queue  * and quque them for transmit, one by one, until TX ring become full  * or quque become empty.  */
end_comment

begin_function
specifier|static
name|void
name|epic_ifstart
parameter_list|(
name|struct
name|ifnet
modifier|*
specifier|const
name|ifp
parameter_list|)
block|{
name|epic_softc_t
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|epic_tx_buffer
modifier|*
name|buf
decl_stmt|;
name|struct
name|epic_tx_desc
modifier|*
name|desc
decl_stmt|;
name|struct
name|epic_frag_list
modifier|*
name|flist
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m0
decl_stmt|;
specifier|register
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
if|#
directive|if
literal|0
comment|/* If no link is established, simply free all mbufs in queue */
block|PHY_READ_2( sc, DP83840_BMSR ); 	if( !(BMSR_LINK_STATUS& PHY_READ_2( sc, DP83840_BMSR )) ){ 		IF_DEQUEUE(&ifp->if_snd, m0 ); 		while( m0 ) { 			m_freem(m0); 			IF_DEQUEUE(&ifp->if_snd, m0 ); 		} 		return; 	}
endif|#
directive|endif
comment|/* Link is OK, queue packets to NIC */
while|while
condition|(
name|sc
operator|->
name|pending_txs
operator|<
name|TX_RING_SIZE
condition|)
block|{
name|buf
operator|=
name|sc
operator|->
name|tx_buffer
operator|+
name|sc
operator|->
name|cur_tx
expr_stmt|;
name|desc
operator|=
name|sc
operator|->
name|tx_desc
operator|+
name|sc
operator|->
name|cur_tx
expr_stmt|;
name|flist
operator|=
name|sc
operator|->
name|tx_flist
operator|+
name|sc
operator|->
name|cur_tx
expr_stmt|;
comment|/* Get next packet to send */
name|IF_DEQUEUE
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|m0
argument_list|)
expr_stmt|;
comment|/* If nothing to send, return */
if|if
condition|(
name|NULL
operator|==
name|m0
condition|)
return|return;
comment|/* If descriptor is busy, set IFF_OACTIVE and exit */
if|if
condition|(
name|desc
operator|->
name|status
operator|&
literal|0x8000
condition|)
block|{
name|dprintf
argument_list|(
operator|(
name|EPIC_FORMAT
literal|": desc is busy in ifstart, up and down interface please\n"
operator|,
name|EPIC_ARGS
argument_list|(
name|sc
argument_list|)
operator|)
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|buf
operator|->
name|mbuf
condition|)
block|{
name|dprintf
argument_list|(
operator|(
name|EPIC_FORMAT
literal|": mbuf not freed in ifstart, up and down interface please\n"
operator|,
name|EPIC_ARGS
argument_list|(
name|sc
argument_list|)
operator|)
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Fill fragments list */
for|for
control|(
name|m
operator|=
name|m0
operator|,
name|i
operator|=
literal|0
init|;
operator|(
name|NULL
operator|!=
name|m
operator|)
operator|&&
operator|(
name|i
operator|<
name|EPIC_MAX_FRAGS
operator|)
condition|;
name|m
operator|=
name|m
operator|->
name|m_next
operator|,
name|i
operator|++
control|)
block|{
name|flist
operator|->
name|frag
index|[
name|i
index|]
operator|.
name|fraglen
operator|=
name|m
operator|->
name|m_len
expr_stmt|;
name|flist
operator|->
name|frag
index|[
name|i
index|]
operator|.
name|fragaddr
operator|=
name|vtophys
argument_list|(
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|flist
operator|->
name|numfrags
operator|=
name|i
expr_stmt|;
comment|/* If packet was more than EPIC_MAX_FRAGS parts, */
comment|/* recopy packet to new allocated mbuf cluster */
if|if
condition|(
name|NULL
operator|!=
name|m
condition|)
block|{
name|EPIC_MGETCLUSTER
argument_list|(
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|m
condition|)
block|{
name|printf
argument_list|(
name|EPIC_FORMAT
literal|": cannot allocate mbuf cluster\n"
argument_list|,
name|EPIC_ARGS
argument_list|(
name|sc
argument_list|)
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_oerrors
operator|++
expr_stmt|;
continue|continue;
block|}
name|m_copydata
argument_list|(
name|m0
argument_list|,
literal|0
argument_list|,
name|m0
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
argument_list|)
expr_stmt|;
name|flist
operator|->
name|frag
index|[
literal|0
index|]
operator|.
name|fraglen
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|m
operator|->
name|m_len
operator|=
name|m0
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|ifp
expr_stmt|;
name|flist
operator|->
name|numfrags
operator|=
literal|1
expr_stmt|;
name|flist
operator|->
name|frag
index|[
literal|0
index|]
operator|.
name|fragaddr
operator|=
name|vtophys
argument_list|(
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
name|m0
operator|=
name|m
expr_stmt|;
block|}
name|buf
operator|->
name|mbuf
operator|=
name|m0
expr_stmt|;
name|sc
operator|->
name|pending_txs
operator|++
expr_stmt|;
name|sc
operator|->
name|cur_tx
operator|=
operator|(
name|sc
operator|->
name|cur_tx
operator|+
literal|1
operator|)
operator|&
name|TX_RING_MASK
expr_stmt|;
name|desc
operator|->
name|control
operator|=
literal|0x01
expr_stmt|;
name|desc
operator|->
name|txlength
operator|=
name|max
argument_list|(
name|m0
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|,
name|ETHER_MIN_LEN
operator|-
name|ETHER_CRC_LEN
argument_list|)
expr_stmt|;
name|desc
operator|->
name|status
operator|=
literal|0x8000
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|COMMAND
argument_list|,
name|COMMAND_TXQUEUED
argument_list|)
expr_stmt|;
comment|/* Set watchdog timer */
name|ifp
operator|->
name|if_timer
operator|=
literal|8
expr_stmt|;
if|#
directive|if
name|NBPF
operator|>
literal|0
if|if
condition|(
name|ifp
operator|->
name|if_bpf
condition|)
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
name|bpf_mtap
argument_list|(
name|ifp
argument_list|,
name|m0
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* __OpenBSD__ */
name|bpf_mtap
argument_list|(
name|ifp
operator|->
name|if_bpf
argument_list|,
name|m0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* __FreeBSD__ */
endif|#
directive|endif
block|}
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_OACTIVE
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  *  * splimp() invoked before epic_intr_normal()  */
end_comment

begin_decl_stmt
specifier|static
name|__inline
name|void
name|epic_rx_done
name|__P
argument_list|(
operator|(
name|epic_softc_t
operator|*
name|sc
operator|)
argument_list|)
block|{
name|u_int16_t
name|len
decl_stmt|;
name|struct
name|epic_rx_buffer
modifier|*
name|buf
decl_stmt|;
name|struct
name|epic_rx_desc
modifier|*
name|desc
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|ether_header
modifier|*
name|eh
decl_stmt|;
while|while
condition|(
operator|!
operator|(
name|sc
operator|->
name|rx_desc
index|[
name|sc
operator|->
name|cur_rx
index|]
operator|.
name|status
operator|&
literal|0x8000
operator|)
condition|)
block|{
name|buf
operator|=
name|sc
operator|->
name|rx_buffer
operator|+
name|sc
operator|->
name|cur_rx
expr_stmt|;
name|desc
operator|=
name|sc
operator|->
name|rx_desc
operator|+
name|sc
operator|->
name|cur_rx
expr_stmt|;
comment|/* Switch to next descriptor */
name|sc
operator|->
name|cur_rx
operator|=
operator|(
name|sc
operator|->
name|cur_rx
operator|+
literal|1
operator|)
operator|&
name|RX_RING_MASK
expr_stmt|;
comment|/* Check for errors, this should happend */
comment|/* only if SAVE_ERRORED_PACKETS is set, */
comment|/* normaly rx errors generate RXE interrupt */
if|if
condition|(
operator|!
operator|(
name|desc
operator|->
name|status
operator|&
literal|1
operator|)
condition|)
block|{
name|dprintf
argument_list|(
operator|(
name|EPIC_FORMAT
literal|": Rx error status: 0x%x\n"
operator|,
name|EPIC_ARGS
argument_list|(
name|sc
argument_list|)
operator|,
name|desc
operator|->
name|status
operator|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_if
operator|.
name|if_ierrors
operator|++
expr_stmt|;
name|desc
operator|->
name|status
operator|=
literal|0x8000
expr_stmt|;
continue|continue;
block|}
comment|/* Save packet length and mbuf contained packet */
name|len
operator|=
name|desc
operator|->
name|rxlength
operator|-
name|ETHER_CRC_LEN
expr_stmt|;
name|m
operator|=
name|buf
operator|->
name|mbuf
expr_stmt|;
comment|/* Try to get mbuf cluster */
name|EPIC_MGETCLUSTER
argument_list|(
name|buf
operator|->
name|mbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|buf
operator|->
name|mbuf
condition|)
block|{
name|printf
argument_list|(
name|EPIC_FORMAT
literal|": cannot allocate mbuf cluster\n"
argument_list|,
name|EPIC_ARGS
argument_list|(
name|sc
argument_list|)
argument_list|)
expr_stmt|;
name|buf
operator|->
name|mbuf
operator|=
name|m
expr_stmt|;
name|desc
operator|->
name|status
operator|=
literal|0x8000
expr_stmt|;
name|sc
operator|->
name|sc_if
operator|.
name|if_ierrors
operator|++
expr_stmt|;
continue|continue;
block|}
comment|/* Point to new mbuf, and give descriptor to chip */
name|desc
operator|->
name|bufaddr
operator|=
name|vtophys
argument_list|(
name|mtod
argument_list|(
name|buf
operator|->
name|mbuf
argument_list|,
name|caddr_t
argument_list|)
argument_list|)
expr_stmt|;
name|desc
operator|->
name|status
operator|=
literal|0x8000
expr_stmt|;
comment|/* First mbuf in packet holds the ethernet and packet headers */
name|eh
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ether_header
operator|*
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
operator|&
operator|(
name|sc
operator|->
name|sc_if
operator|)
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|m
operator|->
name|m_len
operator|=
name|len
expr_stmt|;
if|#
directive|if
name|NBPF
operator|>
literal|0
comment|/* Give mbuf to BPF */
if|if
condition|(
name|sc
operator|->
name|sc_if
operator|.
name|if_bpf
condition|)
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
name|bpf_mtap
argument_list|(
operator|&
name|sc
operator|->
name|sc_if
argument_list|,
name|m
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* __OpenBSD__ */
name|bpf_mtap
argument_list|(
name|sc
operator|->
name|sc_if
operator|.
name|if_bpf
argument_list|,
name|m
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* __FreeBSD__ */
endif|#
directive|endif
comment|/* NBPF */
ifdef|#
directive|ifdef
name|BRIDGE
if|if
condition|(
name|do_bridge
condition|)
block|{
name|struct
name|ifnet
modifier|*
name|bdg_ifp
decl_stmt|;
name|bdg_ifp
operator|=
name|bridge_in
argument_list|(
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|bdg_ifp
operator|==
name|BDG_DROP
condition|)
block|{
if|if
condition|(
name|m
condition|)
name|m_free
argument_list|(
name|m
argument_list|)
expr_stmt|;
continue|continue;
comment|/* and drop */
block|}
if|if
condition|(
name|bdg_ifp
operator|!=
name|BDG_LOCAL
condition|)
name|bdg_forward
argument_list|(
operator|&
name|m
argument_list|,
name|bdg_ifp
argument_list|)
expr_stmt|;
if|if
condition|(
name|bdg_ifp
operator|!=
name|BDG_LOCAL
operator|&&
name|bdg_ifp
operator|!=
name|BDG_BCAST
operator|&&
name|bdg_ifp
operator|!=
name|BDG_MCAST
condition|)
block|{
if|if
condition|(
name|m
condition|)
name|m_free
argument_list|(
name|m
argument_list|)
expr_stmt|;
continue|continue;
comment|/* and drop */
block|}
comment|/* all others accepted locally */
block|}
endif|#
directive|endif
if|#
directive|if
name|NBPF
operator|>
literal|0
ifdef|#
directive|ifdef
name|BRIDGE
comment|/* 		 * This deserves explanation 		 * If the bridge is _on_, then the following check 		 * must not be done because occasionally the bridge 		 * gets packets that are local but have the ethernet 		 * address of one of the other interfaces. 		 * 		 * But if the bridge is off, then we have to drop 		 * stuff that came in just via bpf. 		 */
if|if
condition|(
operator|!
name|do_bridge
condition|)
endif|#
directive|endif
comment|/* Accept only our packets, broadcasts and multicasts */
if|if
condition|(
operator|(
name|eh
operator|->
name|ether_dhost
index|[
literal|0
index|]
operator|&
literal|1
operator|)
operator|==
literal|0
operator|&&
name|bcmp
argument_list|(
name|eh
operator|->
name|ether_dhost
argument_list|,
name|sc
operator|->
name|sc_macaddr
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
continue|continue;
block|}
endif|#
directive|endif
comment|/* Second mbuf holds packet ifself */
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|m
operator|->
name|m_len
operator|=
name|len
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_data
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
expr_stmt|;
comment|/* Give mbuf to OS */
name|ether_input
argument_list|(
operator|&
name|sc
operator|->
name|sc_if
argument_list|,
name|eh
argument_list|,
name|m
argument_list|)
expr_stmt|;
comment|/* Successfuly received frame */
name|sc
operator|->
name|sc_if
operator|.
name|if_ipackets
operator|++
expr_stmt|;
block|}
return|return;
block|}
end_decl_stmt

begin_comment
comment|/*  * Synopsis: Do last phase of transmission. I.e. if desc is   * transmitted, decrease pending_txs counter, free mbuf contained  * packet, switch to next descriptor and repeat until no packets  * are pending or descriptor is not transmitted yet.  */
end_comment

begin_decl_stmt
specifier|static
name|__inline
name|void
name|epic_tx_done
name|__P
argument_list|(
operator|(
specifier|register
name|epic_softc_t
operator|*
name|sc
operator|)
argument_list|)
block|{
name|struct
name|epic_tx_buffer
modifier|*
name|buf
decl_stmt|;
name|struct
name|epic_tx_desc
modifier|*
name|desc
decl_stmt|;
name|u_int16_t
name|status
decl_stmt|;
while|while
condition|(
name|sc
operator|->
name|pending_txs
operator|>
literal|0
condition|)
block|{
name|buf
operator|=
name|sc
operator|->
name|tx_buffer
operator|+
name|sc
operator|->
name|dirty_tx
expr_stmt|;
name|desc
operator|=
name|sc
operator|->
name|tx_desc
operator|+
name|sc
operator|->
name|dirty_tx
expr_stmt|;
name|status
operator|=
name|desc
operator|->
name|status
expr_stmt|;
comment|/* If packet is not transmitted, thou followed */
comment|/* packets are not transmitted too */
if|if
condition|(
name|status
operator|&
literal|0x8000
condition|)
break|break;
comment|/* Packet is transmitted. Switch to next and */
comment|/* free mbuf */
name|sc
operator|->
name|pending_txs
operator|--
expr_stmt|;
name|sc
operator|->
name|dirty_tx
operator|=
operator|(
name|sc
operator|->
name|dirty_tx
operator|+
literal|1
operator|)
operator|&
name|TX_RING_MASK
expr_stmt|;
name|m_freem
argument_list|(
name|buf
operator|->
name|mbuf
argument_list|)
expr_stmt|;
name|buf
operator|->
name|mbuf
operator|=
name|NULL
expr_stmt|;
comment|/* Check for errors and collisions */
if|if
condition|(
name|status
operator|&
literal|0x0001
condition|)
name|sc
operator|->
name|sc_if
operator|.
name|if_opackets
operator|++
expr_stmt|;
else|else
name|sc
operator|->
name|sc_if
operator|.
name|if_oerrors
operator|++
expr_stmt|;
name|sc
operator|->
name|sc_if
operator|.
name|if_collisions
operator|+=
operator|(
name|status
operator|>>
literal|8
operator|)
operator|&
literal|0x1F
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|EPIC_DEBUG
argument_list|)
if|if
condition|(
operator|(
name|status
operator|&
literal|0x1001
operator|)
operator|==
literal|0x1001
condition|)
name|dprintf
argument_list|(
operator|(
name|EPIC_FORMAT
literal|": frame not transmitted due collisions\n"
operator|,
name|EPIC_ARGS
argument_list|(
name|sc
argument_list|)
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|sc
operator|->
name|pending_txs
operator|<
name|TX_RING_SIZE
condition|)
name|sc
operator|->
name|sc_if
operator|.
name|if_flags
operator|&=
operator|~
name|IFF_OACTIVE
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|/*  * Interrupt function  *  * splimp() assumed to be done   */
end_comment

begin_function
specifier|static
name|EPIC_INTR_RET_TYPE
name|epic_intr
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|epic_softc_t
modifier|*
name|sc
init|=
operator|(
name|epic_softc_t
operator|*
operator|)
name|arg
decl_stmt|;
name|int
name|status
decl_stmt|,
name|i
init|=
literal|4
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__OpenBSD__
argument_list|)
name|int
name|claimed
init|=
literal|0
decl_stmt|;
endif|#
directive|endif
while|while
condition|(
name|i
operator|--
operator|&&
operator|(
operator|(
name|status
operator|=
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|INTSTAT
argument_list|)
operator|)
operator|&
name|INTSTAT_INT_ACTV
operator|)
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|__OpenBSD__
argument_list|)
name|claimed
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|INTSTAT
argument_list|,
name|status
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|&
operator|(
name|INTSTAT_RQE
operator||
name|INTSTAT_RCC
operator||
name|INTSTAT_OVW
operator|)
condition|)
block|{
name|epic_rx_done
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|&
operator|(
name|INTSTAT_RQE
operator||
name|INTSTAT_OVW
operator|)
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|EPIC_DEBUG
argument_list|)
if|if
condition|(
name|status
operator|&
name|INTSTAT_OVW
condition|)
name|printf
argument_list|(
name|EPIC_FORMAT
literal|": RX buffer overflow\n"
argument_list|,
name|EPIC_ARGS
argument_list|(
name|sc
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|&
name|INTSTAT_RQE
condition|)
name|printf
argument_list|(
name|EPIC_FORMAT
literal|": RX FIFO overflow\n"
argument_list|,
name|EPIC_ARGS
argument_list|(
name|sc
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_if
operator|.
name|if_flags
operator|&
name|IFF_DEBUG
condition|)
name|epic_dump_state
argument_list|(
name|sc
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
operator|(
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|COMMAND
argument_list|)
operator|&
name|COMMAND_RXQUEUED
operator|)
condition|)
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|COMMAND
argument_list|,
name|COMMAND_RXQUEUED
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_if
operator|.
name|if_ierrors
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|status
operator|&
operator|(
name|INTSTAT_TXC
operator||
name|INTSTAT_TCC
operator||
name|INTSTAT_TQE
operator|)
condition|)
block|{
name|epic_tx_done
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|sc
operator|->
name|sc_if
operator|.
name|if_flags
operator|&
name|IFF_OACTIVE
operator|)
operator|&&
name|sc
operator|->
name|sc_if
operator|.
name|if_snd
operator|.
name|ifq_head
condition|)
name|epic_ifstart
argument_list|(
operator|&
name|sc
operator|->
name|sc_if
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|status
operator|&
name|INTSTAT_GP2
operator|)
operator|&&
operator|(
name|QS6612_OUI
operator|==
name|sc
operator|->
name|phyid
operator|)
condition|)
block|{
name|u_int32_t
name|phystatus
init|=
name|PHY_READ_2
argument_list|(
name|sc
argument_list|,
name|QS6612_INTSTAT
argument_list|)
decl_stmt|;
if|if
condition|(
name|phystatus
operator|&
name|INTSTAT_AN_COMPLETE
condition|)
block|{
name|u_int32_t
name|bmcr
decl_stmt|;
if|if
condition|(
name|epic_autoneg
argument_list|(
name|sc
argument_list|)
operator|==
name|EPIC_FULL_DUPLEX
condition|)
block|{
name|dprintf
argument_list|(
operator|(
name|EPIC_FORMAT
literal|": going fullduplex\n"
operator|,
name|EPIC_ARGS
argument_list|(
name|sc
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|bmcr
operator|=
name|BMCR_FULL_DUPLEX
operator||
name|PHY_READ_2
argument_list|(
name|sc
argument_list|,
name|DP83840_BMCR
argument_list|)
expr_stmt|;
name|sc
operator|->
name|txcon
operator||=
name|TXCON_FULL_DUPLEX
expr_stmt|;
block|}
else|else
block|{
comment|/* Default to half-duplex */
name|dprintf
argument_list|(
operator|(
name|EPIC_FORMAT
literal|": going halfduplex\n"
operator|,
name|EPIC_ARGS
argument_list|(
name|sc
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|bmcr
operator|=
operator|~
name|BMCR_FULL_DUPLEX
operator|&
name|PHY_READ_2
argument_list|(
name|sc
argument_list|,
name|DP83840_BMCR
argument_list|)
expr_stmt|;
name|sc
operator|->
name|txcon
operator|&=
operator|~
name|TXCON_FULL_DUPLEX
expr_stmt|;
block|}
comment|/* There is apparently QS6612 chip bug: */
comment|/* BMCR_FULL_DUPLEX flag is not updated by */
comment|/* autonegotiation process, so update it by hands */
comment|/* so we can rely on it in epic_ifmedia_status() */
name|PHY_WRITE_2
argument_list|(
name|sc
argument_list|,
name|DP83840_BMCR
argument_list|,
name|bmcr
argument_list|)
expr_stmt|;
name|epic_stop_activity
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|epic_set_tx_mode
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|epic_start_activity
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
name|PHY_READ_2
argument_list|(
name|sc
argument_list|,
name|DP83840_BMSR
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|PHY_READ_2
argument_list|(
name|sc
argument_list|,
name|DP83840_BMSR
argument_list|)
operator|&
name|BMSR_LINK_STATUS
operator|)
condition|)
block|{
name|dprintf
argument_list|(
operator|(
name|EPIC_FORMAT
literal|": WARNING! link down\n"
operator|,
name|EPIC_ARGS
argument_list|(
name|sc
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|flags
operator||=
name|EPIC_LINK_DOWN
expr_stmt|;
block|}
else|else
block|{
name|dprintf
argument_list|(
operator|(
name|EPIC_FORMAT
literal|": link up\n"
operator|,
name|EPIC_ARGS
argument_list|(
name|sc
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|flags
operator|&=
operator|~
name|EPIC_LINK_DOWN
expr_stmt|;
block|}
comment|/* We should clear GP2 int again after we clear it on PHY */
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|INTSTAT
argument_list|,
name|INTSTAT_GP2
argument_list|)
expr_stmt|;
block|}
comment|/* Check for errors */
if|if
condition|(
name|status
operator|&
operator|(
name|INTSTAT_FATAL
operator||
name|INTSTAT_PMA
operator||
name|INTSTAT_PTA
operator||
name|INTSTAT_APE
operator||
name|INTSTAT_DPE
operator||
name|INTSTAT_TXU
operator||
name|INTSTAT_RXE
operator|)
condition|)
block|{
if|if
condition|(
name|status
operator|&
operator|(
name|INTSTAT_FATAL
operator||
name|INTSTAT_PMA
operator||
name|INTSTAT_PTA
operator||
name|INTSTAT_APE
operator||
name|INTSTAT_DPE
operator|)
condition|)
block|{
name|printf
argument_list|(
name|EPIC_FORMAT
literal|": PCI fatal error occured (%s%s%s%s)\n"
argument_list|,
name|EPIC_ARGS
argument_list|(
name|sc
argument_list|)
argument_list|,
operator|(
name|status
operator|&
name|INTSTAT_PMA
operator|)
condition|?
literal|"PMA"
else|:
literal|""
argument_list|,
operator|(
name|status
operator|&
name|INTSTAT_PTA
operator|)
condition|?
literal|" PTA"
else|:
literal|""
argument_list|,
operator|(
name|status
operator|&
name|INTSTAT_APE
operator|)
condition|?
literal|" APE"
else|:
literal|""
argument_list|,
operator|(
name|status
operator|&
name|INTSTAT_DPE
operator|)
condition|?
literal|" DPE"
else|:
literal|""
argument_list|)
expr_stmt|;
name|epic_dump_state
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|epic_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|epic_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|status
operator|&
name|INTSTAT_RXE
condition|)
block|{
name|dprintf
argument_list|(
operator|(
name|EPIC_FORMAT
literal|": CRC/Alignment error\n"
operator|,
name|EPIC_ARGS
argument_list|(
name|sc
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_if
operator|.
name|if_ierrors
operator|++
expr_stmt|;
block|}
comment|/* Tx FIFO underflow. Increase tx threshold, */
comment|/* if it grown above 2048, disable EARLY_TX */
if|if
condition|(
name|status
operator|&
name|INTSTAT_TXU
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|tx_threshold
operator|>
literal|0x800
condition|)
block|{
name|sc
operator|->
name|txcon
operator|&=
operator|~
name|TXCON_EARLY_TRANSMIT_ENABLE
expr_stmt|;
name|dprintf
argument_list|(
operator|(
name|EPIC_FORMAT
literal|": TX underrun error, early tx disabled\n"
operator|,
name|EPIC_ARGS
argument_list|(
name|sc
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|tx_threshold
operator|+=
literal|0x40
expr_stmt|;
name|dprintf
argument_list|(
operator|(
name|EPIC_FORMAT
literal|": TX underrun error, tx threshold increased to %d\n"
operator|,
name|EPIC_ARGS
argument_list|(
name|sc
argument_list|)
operator|,
name|sc
operator|->
name|tx_threshold
operator|)
argument_list|)
expr_stmt|;
block|}
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|COMMAND
argument_list|,
name|COMMAND_TXUGO
operator||
name|COMMAND_TXQUEUED
argument_list|)
expr_stmt|;
name|epic_stop_activity
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|epic_set_tx_mode
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|epic_start_activity
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_if
operator|.
name|if_oerrors
operator|++
expr_stmt|;
block|}
block|}
block|}
comment|/* If no packets are pending, thus no timeouts */
if|if
condition|(
name|sc
operator|->
name|pending_txs
operator|==
literal|0
condition|)
name|sc
operator|->
name|sc_if
operator|.
name|if_timer
operator|=
literal|0
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__OpenBSD__
argument_list|)
return|return
name|claimed
return|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * Synopsis: This one is called if packets wasn't transmitted  * during timeout. Try to deallocate transmitted packets, and   * if success continue to work.  *  * splimp() invoked here  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|epic_ifwatchdog
name|__P
argument_list|(
operator|(
expr|struct
name|ifnet
operator|*
name|ifp
operator|)
argument_list|)
block|{
name|epic_softc_t
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|int
name|x
decl_stmt|;
name|x
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|printf
argument_list|(
name|EPIC_FORMAT
literal|": device timeout %d packets, "
argument_list|,
name|EPIC_ARGS
argument_list|(
name|sc
argument_list|)
argument_list|,
name|sc
operator|->
name|pending_txs
argument_list|)
expr_stmt|;
comment|/* Try to finish queued packets */
name|epic_tx_done
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* If not successful */
if|if
condition|(
name|sc
operator|->
name|pending_txs
operator|>
literal|0
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|EPIC_DEBUG
argument_list|)
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_DEBUG
condition|)
name|epic_dump_state
argument_list|(
name|sc
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ifp
operator|->
name|if_oerrors
operator|+=
name|sc
operator|->
name|pending_txs
expr_stmt|;
comment|/* Reinitialize board */
name|printf
argument_list|(
literal|"reinitialization\n"
argument_list|)
expr_stmt|;
name|epic_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|epic_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
else|else
name|printf
argument_list|(
literal|"seems we can continue normaly\n"
argument_list|)
expr_stmt|;
comment|/* Start output */
if|if
condition|(
name|ifp
operator|->
name|if_snd
operator|.
name|ifq_head
condition|)
name|epic_ifstart
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_if
if|#
directive|if
name|defined
argument_list|(
name|SIOCSIFMEDIA
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|EPIC_NOIFMEDIA
argument_list|)
end_if

begin_decl_stmt
specifier|static
name|int
name|epic_ifmedia_change
name|__P
argument_list|(
operator|(
expr|struct
name|ifnet
operator|*
name|ifp
operator|)
argument_list|)
block|{
name|epic_softc_t
modifier|*
name|sc
init|=
operator|(
name|epic_softc_t
operator|*
operator|)
operator|(
name|ifp
operator|->
name|if_softc
operator|)
decl_stmt|;
if|if
condition|(
name|IFM_TYPE
argument_list|(
name|sc
operator|->
name|ifmedia
operator|.
name|ifm_media
argument_list|)
operator|!=
name|IFM_ETHER
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
operator|!
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|epic_stop_activity
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|epic_set_media_speed
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|epic_start_activity
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|epic_ifmedia_status
name|__P
argument_list|(
operator|(
expr|struct
name|ifnet
operator|*
name|ifp
operator|,
expr|struct
name|ifmediareq
operator|*
name|ifmr
operator|)
argument_list|)
block|{
name|epic_softc_t
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|u_int32_t
name|bmcr
decl_stmt|;
name|u_int32_t
name|bmsr
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
operator|)
condition|)
return|return;
name|bmcr
operator|=
name|PHY_READ_2
argument_list|(
name|sc
argument_list|,
name|DP83840_BMCR
argument_list|)
expr_stmt|;
name|PHY_READ_2
argument_list|(
name|sc
argument_list|,
name|DP83840_BMSR
argument_list|)
expr_stmt|;
name|bmsr
operator|=
name|PHY_READ_2
argument_list|(
name|sc
argument_list|,
name|DP83840_BMSR
argument_list|)
expr_stmt|;
name|ifmr
operator|->
name|ifm_active
operator|=
name|IFM_ETHER
expr_stmt|;
name|ifmr
operator|->
name|ifm_status
operator|=
name|IFM_AVALID
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|bmsr
operator|&
name|BMSR_LINK_STATUS
operator|)
condition|)
block|{
name|ifmr
operator|->
name|ifm_active
operator||=
operator|(
name|bmcr
operator|&
name|BMCR_AUTONEGOTIATION
operator|)
condition|?
name|IFM_AUTO
else|:
name|IFM_NONE
expr_stmt|;
return|return;
block|}
name|ifmr
operator|->
name|ifm_status
operator||=
name|IFM_ACTIVE
expr_stmt|;
name|ifmr
operator|->
name|ifm_active
operator||=
operator|(
name|bmcr
operator|&
name|BMCR_100MBPS
operator|)
condition|?
name|IFM_100_TX
else|:
name|IFM_10_T
expr_stmt|;
name|ifmr
operator|->
name|ifm_active
operator||=
operator|(
name|bmcr
operator|&
name|BMCR_FULL_DUPLEX
operator|)
condition|?
name|IFM_FDX
else|:
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|txcon
operator|&
name|TXCON_LOOPBACK_MODE
operator|)
operator|==
name|TXCON_LOOPBACK_MODE_INT
condition|)
name|ifmr
operator|->
name|ifm_active
operator||=
operator|(
name|IFM_LOOP
operator||
name|IFM_FLAG1
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|sc
operator|->
name|txcon
operator|&
name|TXCON_LOOPBACK_MODE
operator|)
operator|==
name|TXCON_LOOPBACK_MODE_PHY
condition|)
name|ifmr
operator|->
name|ifm_active
operator||=
name|IFM_LOOP
expr_stmt|;
block|}
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Reset chip, PHY, allocate rings  *   * splimp() invoked here  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|epic_init
name|__P
argument_list|(
operator|(
name|epic_softc_t
operator|*
name|sc
operator|)
argument_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
operator|&
name|sc
operator|->
name|sc_if
decl_stmt|;
name|int
name|s
decl_stmt|,
name|i
decl_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
comment|/* Soft reset the chip (we have to power up card before) */
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|GENCTL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|GENCTL
argument_list|,
name|GENCTL_SOFT_RESET
argument_list|)
expr_stmt|;
comment|/* 	 * Reset takes 15 pci ticks which depends on PCI bus speed. 	 * Assuming it>= 33000000 hz, we have wait at least 495e-6 sec. 	 */
name|DELAY
argument_list|(
literal|500
argument_list|)
expr_stmt|;
comment|/* Wake up */
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|GENCTL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Workaround for Application Note 7-15 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|TEST1
argument_list|,
name|TEST1_CLOCK_TEST
argument_list|)
expr_stmt|;
comment|/* Initialize rings */
if|if
condition|(
name|epic_init_rings
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|printf
argument_list|(
name|EPIC_FORMAT
literal|": failed to init rings\n"
argument_list|,
name|EPIC_ARGS
argument_list|(
name|sc
argument_list|)
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* Give rings to EPIC */
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|PRCDAR
argument_list|,
name|vtophys
argument_list|(
name|sc
operator|->
name|rx_desc
argument_list|)
argument_list|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|PTCDAR
argument_list|,
name|vtophys
argument_list|(
name|sc
operator|->
name|tx_desc
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Put node address to EPIC */
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|LAN0
argument_list|,
operator|(
operator|(
name|u_int16_t
operator|*
operator|)
name|sc
operator|->
name|sc_macaddr
operator|)
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|LAN1
argument_list|,
operator|(
operator|(
name|u_int16_t
operator|*
operator|)
name|sc
operator|->
name|sc_macaddr
operator|)
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|LAN2
argument_list|,
operator|(
operator|(
name|u_int16_t
operator|*
operator|)
name|sc
operator|->
name|sc_macaddr
operator|)
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
comment|/* Set tx mode, includeing transmit threshold */
name|epic_set_tx_mode
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Compute and set RXCON. */
name|epic_set_rx_mode
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Set multicast table */
name|epic_set_mc_table
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Enable interrupts by setting the interrupt mask. */
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|INTMASK
argument_list|,
name|INTSTAT_RCC
operator||
name|INTSTAT_RQE
operator||
name|INTSTAT_OVW
operator||
name|INTSTAT_RXE
operator||
name|INTSTAT_TXC
operator||
name|INTSTAT_TCC
operator||
name|INTSTAT_TQE
operator||
name|INTSTAT_TXU
operator||
name|INTSTAT_FATAL
operator||
operator|(
operator|(
name|QS6612_OUI
operator|==
name|sc
operator|->
name|phyid
operator|)
condition|?
name|INTSTAT_GP2
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
comment|/* Enable interrupts,  set for PCI read multiple and etc */
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|GENCTL
argument_list|,
name|GENCTL_ENABLE_INTERRUPT
operator||
name|GENCTL_MEMORY_READ_MULTIPLE
operator||
name|GENCTL_ONECOPY
operator||
name|GENCTL_RECEIVE_FIFO_THRESHOLD64
argument_list|)
expr_stmt|;
comment|/* Set media speed mode */
name|epic_set_media_speed
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Mark interface running ... */
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
condition|)
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_RUNNING
expr_stmt|;
else|else
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
name|IFF_RUNNING
expr_stmt|;
comment|/* ... and free */
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
name|IFF_OACTIVE
expr_stmt|;
comment|/* Start Rx process */
name|epic_start_activity
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_decl_stmt

begin_comment
comment|/*  * Synopsis: calculate and set Rx mode. Chip must be in idle state to  * access RXCON.  */
end_comment

begin_function
specifier|static
name|void
name|epic_set_rx_mode
parameter_list|(
name|epic_softc_t
modifier|*
name|sc
parameter_list|)
block|{
name|u_int32_t
name|flags
init|=
name|sc
operator|->
name|sc_if
operator|.
name|if_flags
decl_stmt|;
name|u_int32_t
name|rxcon
init|=
name|RXCON_DEFAULT
operator||
name|RXCON_RECEIVE_MULTICAST_FRAMES
operator||
name|RXCON_RECEIVE_BROADCAST_FRAMES
decl_stmt|;
name|rxcon
operator||=
operator|(
name|flags
operator|&
name|IFF_PROMISC
operator|)
condition|?
name|RXCON_PROMISCUOUS_MODE
else|:
literal|0
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|RXCON
argument_list|,
name|rxcon
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|void dump_phy_regs(epic_softc_t *sc) {  	printf("BMCR: 0x%04x\n", PHY_READ_2(sc, DP83840_BMCR)); 	printf("BMSR: 0x%04x\n", PHY_READ_2(sc, DP83840_BMSR)); 	printf("ANAR: 0x%04x\n", PHY_READ_2(sc, DP83840_ANAR)); 	printf("LPAR: 0x%04x\n", PHY_READ_2(sc, DP83840_LPAR)); 	printf("ANER: 0x%04x\n", PHY_READ_2(sc, DP83840_ANER)); 	printf("MCTL: 0x%04x\n", PHY_READ_2(sc, QS6612_MCTL)); 	printf("INTSTAT: 0x%04x\n", PHY_READ_2(sc, QS6612_INTSTAT)); 	printf("INTMASK: 0x%04x\n", PHY_READ_2(sc, QS6612_INTMASK)); 	printf("BPCR: 0x%04x\n", PHY_READ_2(sc, QS6612_BPCR)); }
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Synopsis: Reset PHY and do PHY-special initialization:  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|epic_init_phy
name|__P
argument_list|(
operator|(
name|epic_softc_t
operator|*
name|sc
operator|)
argument_list|)
block|{
name|u_int32_t
name|i
decl_stmt|;
comment|/* Reset PHY (We have to take the delay from manual XXX) */
name|PHY_WRITE_2
argument_list|(
name|sc
argument_list|,
name|DP83840_BMCR
argument_list|,
name|BMCR_RESET
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|0x1000
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|PHY_READ_2
argument_list|(
name|sc
argument_list|,
name|DP83840_BMCR
argument_list|)
operator|&
name|BMCR_RESET
operator|)
condition|)
break|break;
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|PHY_READ_2
argument_list|(
name|sc
argument_list|,
name|DP83840_BMCR
argument_list|)
operator|&
name|BMCR_RESET
condition|)
name|printf
argument_list|(
name|EPIC_FORMAT
literal|": WARNING! cant reset PHY\n"
argument_list|,
name|EPIC_ARGS
argument_list|(
name|sc
argument_list|)
argument_list|)
expr_stmt|;
name|PHY_WRITE_2
argument_list|(
name|sc
argument_list|,
name|DP83840_BMCR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|PHY_WRITE_2
argument_list|(
name|sc
argument_list|,
name|DP83840_BMCR
argument_list|,
name|BMCR_LOOPBACK
operator||
name|BMCR_ISOLATE
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|sc
operator|->
name|phyid
condition|)
block|{
case|case
name|QS6612_OUI
case|:
block|{
comment|/* Init QS6612 and EPIC to generate interrupt */
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|NVCTL
argument_list|,
name|NVCTL_GP1_OUTPUT_ENABLE
operator||
name|NVCTL_GP1
argument_list|)
expr_stmt|;
comment|/* Mask interrupts sources */
name|PHY_WRITE_2
argument_list|(
name|sc
argument_list|,
name|QS6612_INTMASK
argument_list|,
name|PHY_READ_2
argument_list|(
name|sc
argument_list|,
name|QS6612_INTSTAT
argument_list|)
operator||
name|INTMASK_THUNDERLAN
operator||
name|INTSTAT_AN_COMPLETE
operator||
name|INTSTAT_LINK_STATUS
argument_list|)
expr_stmt|;
comment|/* Enable QS6612 extended cable length capabilites */
comment|/* PHY_WRITE_2(sc, QS6612_MCTL,			   */
comment|/*	PHY_READ_2(sc, QS6612_MCTL) | MCTL_BTEXT); */
break|break;
block|}
default|default:
break|break;
block|}
block|}
end_decl_stmt

begin_comment
comment|/*  * Synopsis: Set PHY to media type specified by IFF_LINK* flags or  * ifmedia structure. Chip must be in idle state to access TXCON.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|epic_set_media_speed
name|__P
argument_list|(
operator|(
name|epic_softc_t
operator|*
name|sc
operator|)
argument_list|)
block|{
name|u_int16_t
name|media
decl_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|EPIC_NOIFMEDIA
argument_list|)
name|u_int32_t
name|tgtmedia
init|=
name|sc
operator|->
name|ifmedia
operator|.
name|ifm_cur
operator|->
name|ifm_media
decl_stmt|;
endif|#
directive|endif
name|epic_init_phy
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|EPIC_NOIFMEDIA
argument_list|)
if|if
condition|(
name|IFM_SUBTYPE
argument_list|(
name|tgtmedia
argument_list|)
operator|!=
name|IFM_AUTO
condition|)
block|{
comment|/* Clean previous values */
name|sc
operator|->
name|txcon
operator|&=
operator|~
operator|(
name|TXCON_LOOPBACK_MODE
operator||
name|TXCON_FULL_DUPLEX
operator|)
expr_stmt|;
name|media
operator|=
literal|0
expr_stmt|;
comment|/* Set mode */
name|media
operator||=
operator|(
name|IFM_SUBTYPE
argument_list|(
name|tgtmedia
argument_list|)
operator|==
name|IFM_100_TX
operator|)
condition|?
name|BMCR_100MBPS
else|:
literal|0
expr_stmt|;
if|if
condition|(
name|tgtmedia
operator|&
name|IFM_FDX
condition|)
block|{
name|media
operator||=
name|BMCR_FULL_DUPLEX
expr_stmt|;
name|sc
operator|->
name|txcon
operator||=
name|TXCON_FULL_DUPLEX
expr_stmt|;
block|}
if|if
condition|(
name|tgtmedia
operator|&
name|IFM_LOOP
condition|)
block|{
if|if
condition|(
name|tgtmedia
operator|&
name|IFM_FLAG1
condition|)
name|sc
operator|->
name|txcon
operator||=
name|TXCON_LOOPBACK_MODE_INT
expr_stmt|;
else|else
block|{
name|media
operator||=
name|BMCR_LOOPBACK
operator||
name|BMCR_ISOLATE
expr_stmt|;
name|sc
operator|->
name|txcon
operator||=
name|TXCON_LOOPBACK_MODE_PHY
expr_stmt|;
block|}
block|}
name|sc
operator|->
name|sc_if
operator|.
name|if_baudrate
operator|=
operator|(
name|IFM_SUBTYPE
argument_list|(
name|tgtmedia
argument_list|)
operator|==
name|IFM_100_TX
operator|)
condition|?
literal|100000000
else|:
literal|10000000
expr_stmt|;
name|PHY_WRITE_2
argument_list|(
name|sc
argument_list|,
name|DP83840_BMCR
argument_list|,
name|media
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
comment|/* EPIC_NOIFMEDIA */
name|struct
name|ifnet
modifier|*
name|ifp
init|=
operator|&
name|sc
operator|->
name|sc_if
decl_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_LINK0
condition|)
block|{
comment|/* Set mode */
name|media
operator|=
literal|0
expr_stmt|;
name|media
operator||=
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_LINK2
operator|)
condition|?
name|BMCR_100MBPS
else|:
literal|0
expr_stmt|;
name|media
operator||=
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_LINK1
operator|)
condition|?
name|BMCR_FULL_DUPLEX
else|:
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_if
operator|.
name|if_baudrate
operator|=
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_LINK2
operator|)
condition|?
literal|100000000
else|:
literal|10000000
expr_stmt|;
name|PHY_WRITE_2
argument_list|(
name|sc
argument_list|,
name|DP83840_BMCR
argument_list|,
name|media
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_LINK2
condition|)
name|sc
operator|->
name|txcon
operator||=
name|TXCON_FULL_DUPLEX
expr_stmt|;
else|else
name|sc
operator|->
name|txcon
operator|&=
operator|~
name|TXCON_FULL_DUPLEX
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|TXCON
argument_list|,
name|sc
operator|->
name|txcon
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* !EPIC_NOIFMEDIA */
else|else
block|{
name|sc
operator|->
name|sc_if
operator|.
name|if_baudrate
operator|=
literal|100000000
expr_stmt|;
name|sc
operator|->
name|txcon
operator|&=
operator|~
name|TXCON_FULL_DUPLEX
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|TXCON
argument_list|,
name|sc
operator|->
name|txcon
argument_list|)
expr_stmt|;
comment|/* Set and restart autoneg */
name|PHY_WRITE_2
argument_list|(
name|sc
argument_list|,
name|DP83840_BMCR
argument_list|,
name|BMCR_AUTONEGOTIATION
argument_list|)
expr_stmt|;
name|PHY_WRITE_2
argument_list|(
name|sc
argument_list|,
name|DP83840_BMCR
argument_list|,
name|BMCR_AUTONEGOTIATION
operator||
name|BMCR_RESTART_AUTONEG
argument_list|)
expr_stmt|;
comment|/* If it is not QS6612 PHY, try to get result of autoneg. */
if|if
condition|(
name|QS6612_OUI
operator|!=
name|sc
operator|->
name|phyid
condition|)
block|{
comment|/* Wait 3 seconds for the autoneg to finish 			 * This is the recommended time from the DP83840A data 			 * sheet Section 7.1 			 */
name|DELAY
argument_list|(
literal|3000000
argument_list|)
expr_stmt|;
if|if
condition|(
name|epic_autoneg
argument_list|(
name|sc
argument_list|)
operator|==
name|EPIC_FULL_DUPLEX
condition|)
block|{
name|sc
operator|->
name|txcon
operator||=
name|TXCON_FULL_DUPLEX
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|TXCON
argument_list|,
name|sc
operator|->
name|txcon
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Else it will be done when GP2 int occured */
block|}
name|epic_set_tx_mode
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
end_decl_stmt

begin_comment
comment|/*  * This functions get results of the autoneg processes of the phy  * It implements the workaround that is described in section 7.2& 7.3 of the   * DP83840A data sheet  * http://www.national.com/ds/DP/DP83840A.pdf  */
end_comment

begin_function
specifier|static
name|int
name|epic_autoneg
parameter_list|(
name|epic_softc_t
modifier|*
name|sc
parameter_list|)
block|{
name|u_int16_t
name|media
decl_stmt|;
name|u_int16_t
name|i
decl_stmt|;
comment|/* BMSR must be read twice to update the link status bit 	 * since that bit is a latch bit          */
name|PHY_READ_2
argument_list|(
name|sc
argument_list|,
name|DP83840_BMSR
argument_list|)
expr_stmt|;
name|i
operator|=
name|PHY_READ_2
argument_list|(
name|sc
argument_list|,
name|DP83840_BMSR
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|&
name|BMSR_LINK_STATUS
operator|)
operator|&&
operator|(
name|i
operator|&
name|BMSR_AUTONEG_COMPLETE
operator|)
condition|)
block|{
name|i
operator|=
name|PHY_READ_2
argument_list|(
name|sc
argument_list|,
name|DP83840_LPAR
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|&
operator|(
name|ANAR_100_TX_FD
operator||
name|ANAR_10_FD
operator|)
condition|)
return|return
name|EPIC_FULL_DUPLEX
return|;
else|else
return|return
name|EPIC_HALF_DUPLEX
return|;
block|}
else|else
block|{
comment|/*Auto-negotiation or link status is not 1 		  Thus the auto-negotiation failed and one 		  must take other means to fix it. 		 */
comment|/* ANER must be read twice to get the correct reading for the  		 * Multiple link fault bit -- it is a latched bit 	 	 */
name|PHY_READ_2
argument_list|(
name|sc
argument_list|,
name|DP83840_ANER
argument_list|)
expr_stmt|;
name|i
operator|=
name|PHY_READ_2
argument_list|(
name|sc
argument_list|,
name|DP83840_ANER
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|&
name|ANER_MULTIPLE_LINK_FAULT
condition|)
block|{
comment|/* it can be forced to 100Mb/s Half-Duplex */
name|media
operator|=
name|PHY_READ_2
argument_list|(
name|sc
argument_list|,
name|DP83840_BMCR
argument_list|)
expr_stmt|;
name|media
operator|&=
operator|~
operator|(
name|BMCR_AUTONEGOTIATION
operator||
name|BMCR_FULL_DUPLEX
operator|)
expr_stmt|;
name|media
operator||=
name|BMCR_100MBPS
expr_stmt|;
name|PHY_WRITE_2
argument_list|(
name|sc
argument_list|,
name|DP83840_BMCR
argument_list|,
name|media
argument_list|)
expr_stmt|;
comment|/* read BMSR again to determine link status */
name|PHY_READ_2
argument_list|(
name|sc
argument_list|,
name|DP83840_BMSR
argument_list|)
expr_stmt|;
name|i
operator|=
name|PHY_READ_2
argument_list|(
name|sc
argument_list|,
name|DP83840_BMSR
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|&
name|BMSR_LINK_STATUS
condition|)
block|{
comment|/* port is linked to the non Auto-Negotiation 				 * 100Mbs partner. 			 	 */
return|return
name|EPIC_HALF_DUPLEX
return|;
block|}
else|else
block|{
name|media
operator|=
name|PHY_READ_2
argument_list|(
name|sc
argument_list|,
name|DP83840_BMCR
argument_list|)
expr_stmt|;
name|media
operator|&=
operator|~
operator|(
name|BMCR_AUTONEGOTIATION
operator||
name|BMCR_FULL_DUPLEX
operator||
name|BMCR_100MBPS
operator|)
expr_stmt|;
name|PHY_WRITE_2
argument_list|(
name|sc
argument_list|,
name|DP83840_BMCR
argument_list|,
name|media
argument_list|)
expr_stmt|;
name|PHY_READ_2
argument_list|(
name|sc
argument_list|,
name|DP83840_BMSR
argument_list|)
expr_stmt|;
name|i
operator|=
name|PHY_READ_2
argument_list|(
name|sc
argument_list|,
name|DP83840_BMSR
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|&
name|BMSR_LINK_STATUS
condition|)
block|{
comment|/*port is linked to the non 					 * Auto-Negotiation10Mbs partner 			 	 	 */
return|return
name|EPIC_HALF_DUPLEX
return|;
block|}
block|}
block|}
comment|/* If we get here we are most likely not connected 		 * so lets default it to half duplex 		 */
return|return
name|EPIC_HALF_DUPLEX
return|;
block|}
block|}
end_function

begin_comment
comment|/*  */
end_comment

begin_function
specifier|static
name|void
name|epic_set_tx_mode
parameter_list|(
name|epic_softc_t
modifier|*
name|sc
parameter_list|)
block|{
if|if
condition|(
name|sc
operator|->
name|txcon
operator|&
name|TXCON_EARLY_TRANSMIT_ENABLE
condition|)
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|ETXTHR
argument_list|,
name|sc
operator|->
name|tx_threshold
argument_list|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|TXCON
argument_list|,
name|sc
operator|->
name|txcon
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Synopsis: This function should update multicast hash table.  * I suppose there is a bug in chips MC filter so this function  * only set it to receive all MC packets. The second problem is  * that we should wait for TX and RX processes to stop before  * reprogramming MC filter. The epic_stop_activity() and   * epic_start_activity() should help to do this.  */
end_comment

begin_function
specifier|static
name|void
name|epic_set_mc_table
parameter_list|(
name|epic_softc_t
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
operator|&
name|sc
operator|->
name|sc_if
decl_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_MULTICAST
condition|)
block|{
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|MC0
argument_list|,
literal|0xFFFF
argument_list|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|MC1
argument_list|,
literal|0xFFFF
argument_list|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|MC2
argument_list|,
literal|0xFFFF
argument_list|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|MC3
argument_list|,
literal|0xFFFF
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/*   * Synopsis: Start receive process and transmit one, if they need.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|epic_start_activity
name|__P
argument_list|(
operator|(
name|epic_softc_t
operator|*
name|sc
operator|)
argument_list|)
block|{
comment|/* Start rx process */
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|COMMAND
argument_list|,
name|COMMAND_RXQUEUED
operator||
name|COMMAND_START_RX
operator||
operator|(
name|sc
operator|->
name|pending_txs
condition|?
name|COMMAND_TXQUEUED
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
name|dprintf
argument_list|(
operator|(
name|EPIC_FORMAT
literal|": activity started\n"
operator|,
name|EPIC_ARGS
argument_list|(
name|sc
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|/*  * Synopsis: Completely stop Rx and Tx processes. If TQE is set additional  * packet needs to be queued to stop Tx DMA.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|epic_stop_activity
name|__P
argument_list|(
operator|(
name|epic_softc_t
operator|*
name|sc
operator|)
argument_list|)
block|{
name|int
name|i
decl_stmt|;
comment|/* Stop Tx and Rx DMA */
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|COMMAND
argument_list|,
name|COMMAND_STOP_RX
operator||
name|COMMAND_STOP_RDMA
operator||
name|COMMAND_STOP_TDMA
argument_list|)
expr_stmt|;
comment|/* Wait Rx and Tx DMA to stop (why 1 ms ??? XXX) */
name|dprintf
argument_list|(
operator|(
name|EPIC_FORMAT
literal|": waiting Rx and Tx DMA to stop\n"
operator|,
name|EPIC_ARGS
argument_list|(
name|sc
argument_list|)
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|0x1000
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|INTSTAT
argument_list|)
operator|&
operator|(
name|INTSTAT_TXIDLE
operator||
name|INTSTAT_RXIDLE
operator|)
operator|)
operator|==
operator|(
name|INTSTAT_TXIDLE
operator||
name|INTSTAT_RXIDLE
operator|)
condition|)
break|break;
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|INTSTAT
argument_list|)
operator|&
name|INTSTAT_RXIDLE
operator|)
condition|)
name|printf
argument_list|(
name|EPIC_FORMAT
literal|": can't stop Rx DMA\n"
argument_list|,
name|EPIC_ARGS
argument_list|(
name|sc
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|INTSTAT
argument_list|)
operator|&
name|INTSTAT_TXIDLE
operator|)
condition|)
name|printf
argument_list|(
name|EPIC_FORMAT
literal|": can't stop Tx DMA\n"
argument_list|,
name|EPIC_ARGS
argument_list|(
name|sc
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Catch all finished packets */
name|epic_rx_done
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|epic_tx_done
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/*      * May need to queue one more packet if TQE, this is rare but existing      * case.      */
if|if
condition|(
operator|(
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|INTSTAT
argument_list|)
operator|&
name|INTSTAT_TQE
operator|)
operator|&&
operator|!
operator|(
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|INTSTAT
argument_list|)
operator|&
name|INTSTAT_TXIDLE
operator|)
condition|)
block|{
name|struct
name|epic_tx_desc
modifier|*
name|desc
decl_stmt|;
name|struct
name|epic_frag_list
modifier|*
name|flist
decl_stmt|;
name|struct
name|epic_tx_buffer
modifier|*
name|buf
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m0
decl_stmt|;
name|dprintf
argument_list|(
operator|(
name|EPIC_FORMAT
literal|": queue last packet\n"
operator|,
name|EPIC_ARGS
argument_list|(
name|sc
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|desc
operator|=
name|sc
operator|->
name|tx_desc
operator|+
name|sc
operator|->
name|cur_tx
expr_stmt|;
name|flist
operator|=
name|sc
operator|->
name|tx_flist
operator|+
name|sc
operator|->
name|cur_tx
expr_stmt|;
name|buf
operator|=
name|sc
operator|->
name|tx_buffer
operator|+
name|sc
operator|->
name|cur_tx
expr_stmt|;
if|if
condition|(
operator|(
name|desc
operator|->
name|status
operator|&
literal|0x8000
operator|)
operator|||
operator|(
name|buf
operator|->
name|mbuf
operator|!=
name|NULL
operator|)
condition|)
return|return;
name|MGETHDR
argument_list|(
name|m0
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|m0
condition|)
return|return;
comment|/* Prepare mbuf */
name|m0
operator|->
name|m_len
operator|=
name|min
argument_list|(
name|MHLEN
argument_list|,
name|ETHER_MIN_LEN
operator|-
name|ETHER_CRC_LEN
argument_list|)
expr_stmt|;
name|flist
operator|->
name|frag
index|[
literal|0
index|]
operator|.
name|fraglen
operator|=
name|m0
operator|->
name|m_len
expr_stmt|;
name|m0
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|m0
operator|->
name|m_len
expr_stmt|;
name|m0
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
operator|&
name|sc
operator|->
name|sc_if
expr_stmt|;
name|bzero
argument_list|(
name|mtod
argument_list|(
name|m0
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
name|m0
operator|->
name|m_len
argument_list|)
expr_stmt|;
comment|/* Fill fragments list */
name|flist
operator|->
name|frag
index|[
literal|0
index|]
operator|.
name|fraglen
operator|=
name|m0
operator|->
name|m_len
expr_stmt|;
name|flist
operator|->
name|frag
index|[
literal|0
index|]
operator|.
name|fragaddr
operator|=
name|vtophys
argument_list|(
name|mtod
argument_list|(
name|m0
argument_list|,
name|caddr_t
argument_list|)
argument_list|)
expr_stmt|;
name|flist
operator|->
name|numfrags
operator|=
literal|1
expr_stmt|;
comment|/* Fill in descriptor */
name|buf
operator|->
name|mbuf
operator|=
name|m0
expr_stmt|;
name|sc
operator|->
name|pending_txs
operator|++
expr_stmt|;
name|sc
operator|->
name|cur_tx
operator|=
operator|(
name|sc
operator|->
name|cur_tx
operator|+
literal|1
operator|)
operator|&
name|TX_RING_MASK
expr_stmt|;
name|desc
operator|->
name|control
operator|=
literal|0x01
expr_stmt|;
name|desc
operator|->
name|txlength
operator|=
name|max
argument_list|(
name|m0
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|,
name|ETHER_MIN_LEN
operator|-
name|ETHER_CRC_LEN
argument_list|)
expr_stmt|;
name|desc
operator|->
name|status
operator|=
literal|0x8000
expr_stmt|;
comment|/* Launch transmition */
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|COMMAND
argument_list|,
name|COMMAND_STOP_TDMA
operator||
name|COMMAND_TXQUEUED
argument_list|)
expr_stmt|;
comment|/* Wait Tx DMA to stop (for how long??? XXX) */
name|dprintf
argument_list|(
operator|(
name|EPIC_FORMAT
literal|": waiting Tx DMA to stop\n"
operator|,
name|EPIC_ARGS
argument_list|(
name|sc
argument_list|)
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|1000
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|INTSTAT
argument_list|)
operator|&
name|INTSTAT_TXIDLE
operator|)
operator|==
name|INTSTAT_TXIDLE
condition|)
break|break;
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|INTSTAT
argument_list|)
operator|&
name|INTSTAT_TXIDLE
operator|)
condition|)
name|printf
argument_list|(
name|EPIC_FORMAT
literal|": can't stop TX DMA\n"
argument_list|,
name|EPIC_ARGS
argument_list|(
name|sc
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|epic_tx_done
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
name|dprintf
argument_list|(
operator|(
name|EPIC_FORMAT
literal|": activity stoped\n"
operator|,
name|EPIC_ARGS
argument_list|(
name|sc
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|/*  *  Synopsis: Shut down board and deallocates rings.  *  *  splimp() invoked here  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|epic_stop
name|__P
argument_list|(
operator|(
name|epic_softc_t
operator|*
name|sc
operator|)
argument_list|)
block|{
name|int
name|s
decl_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|sc
operator|->
name|sc_if
operator|.
name|if_timer
operator|=
literal|0
expr_stmt|;
comment|/* Disable interrupts */
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|INTMASK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|GENCTL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Try to stop Rx and TX processes */
name|epic_stop_activity
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Reset chip */
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|GENCTL
argument_list|,
name|GENCTL_SOFT_RESET
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
comment|/* Make chip go to bed */
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|GENCTL
argument_list|,
name|GENCTL_POWER_DOWN
argument_list|)
expr_stmt|;
comment|/* Free memory allocated for rings */
name|epic_free_rings
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Mark as stoped */
name|sc
operator|->
name|sc_if
operator|.
name|if_flags
operator|&=
operator|~
name|IFF_RUNNING
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
end_decl_stmt

begin_comment
comment|/*  * Synopsis: This function should free all memory allocated for rings.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|epic_free_rings
name|__P
argument_list|(
operator|(
name|epic_softc_t
operator|*
name|sc
operator|)
argument_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|RX_RING_SIZE
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|epic_rx_buffer
modifier|*
name|buf
init|=
name|sc
operator|->
name|rx_buffer
operator|+
name|i
decl_stmt|;
name|struct
name|epic_rx_desc
modifier|*
name|desc
init|=
name|sc
operator|->
name|rx_desc
operator|+
name|i
decl_stmt|;
name|desc
operator|->
name|status
operator|=
literal|0
expr_stmt|;
name|desc
operator|->
name|buflength
operator|=
literal|0
expr_stmt|;
name|desc
operator|->
name|bufaddr
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|buf
operator|->
name|mbuf
condition|)
name|m_freem
argument_list|(
name|buf
operator|->
name|mbuf
argument_list|)
expr_stmt|;
name|buf
operator|->
name|mbuf
operator|=
name|NULL
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TX_RING_SIZE
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|epic_tx_buffer
modifier|*
name|buf
init|=
name|sc
operator|->
name|tx_buffer
operator|+
name|i
decl_stmt|;
name|struct
name|epic_tx_desc
modifier|*
name|desc
init|=
name|sc
operator|->
name|tx_desc
operator|+
name|i
decl_stmt|;
name|desc
operator|->
name|status
operator|=
literal|0
expr_stmt|;
name|desc
operator|->
name|buflength
operator|=
literal|0
expr_stmt|;
name|desc
operator|->
name|bufaddr
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|buf
operator|->
name|mbuf
condition|)
name|m_freem
argument_list|(
name|buf
operator|->
name|mbuf
argument_list|)
expr_stmt|;
name|buf
operator|->
name|mbuf
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_decl_stmt

begin_comment
comment|/*  * Synopsis:  Allocates mbufs for Rx ring and point Rx descs to them.  * Point Tx descs to fragment lists. Check that all descs and fraglists  * are bounded and aligned properly.  */
end_comment

begin_function
specifier|static
name|int
name|epic_init_rings
parameter_list|(
name|epic_softc_t
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|sc
operator|->
name|cur_rx
operator|=
name|sc
operator|->
name|cur_tx
operator|=
name|sc
operator|->
name|dirty_tx
operator|=
name|sc
operator|->
name|pending_txs
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|RX_RING_SIZE
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|epic_rx_buffer
modifier|*
name|buf
init|=
name|sc
operator|->
name|rx_buffer
operator|+
name|i
decl_stmt|;
name|struct
name|epic_rx_desc
modifier|*
name|desc
init|=
name|sc
operator|->
name|rx_desc
operator|+
name|i
decl_stmt|;
name|desc
operator|->
name|status
operator|=
literal|0
expr_stmt|;
comment|/* Owned by driver */
name|desc
operator|->
name|next
operator|=
name|vtophys
argument_list|(
name|sc
operator|->
name|rx_desc
operator|+
operator|(
operator|(
name|i
operator|+
literal|1
operator|)
operator|&
name|RX_RING_MASK
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|desc
operator|->
name|next
operator|&
literal|3
operator|)
operator|||
operator|(
operator|(
name|desc
operator|->
name|next
operator|&
literal|0xFFF
operator|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|epic_rx_desc
argument_list|)
operator|>
literal|0x1000
operator|)
condition|)
name|printf
argument_list|(
name|EPIC_FORMAT
literal|": WARNING! rx_desc is misbound or misaligned\n"
argument_list|,
name|EPIC_ARGS
argument_list|(
name|sc
argument_list|)
argument_list|)
expr_stmt|;
name|EPIC_MGETCLUSTER
argument_list|(
name|buf
operator|->
name|mbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|buf
operator|->
name|mbuf
condition|)
block|{
name|epic_free_rings
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|desc
operator|->
name|bufaddr
operator|=
name|vtophys
argument_list|(
name|mtod
argument_list|(
name|buf
operator|->
name|mbuf
argument_list|,
name|caddr_t
argument_list|)
argument_list|)
expr_stmt|;
name|desc
operator|->
name|buflength
operator|=
name|ETHER_MAX_FRAME_LEN
expr_stmt|;
name|desc
operator|->
name|status
operator|=
literal|0x8000
expr_stmt|;
comment|/* Give to EPIC */
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TX_RING_SIZE
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|epic_tx_buffer
modifier|*
name|buf
init|=
name|sc
operator|->
name|tx_buffer
operator|+
name|i
decl_stmt|;
name|struct
name|epic_tx_desc
modifier|*
name|desc
init|=
name|sc
operator|->
name|tx_desc
operator|+
name|i
decl_stmt|;
name|desc
operator|->
name|status
operator|=
literal|0
expr_stmt|;
name|desc
operator|->
name|next
operator|=
name|vtophys
argument_list|(
name|sc
operator|->
name|tx_desc
operator|+
operator|(
operator|(
name|i
operator|+
literal|1
operator|)
operator|&
name|TX_RING_MASK
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|desc
operator|->
name|next
operator|&
literal|3
operator|)
operator|||
operator|(
operator|(
name|desc
operator|->
name|next
operator|&
literal|0xFFF
operator|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|epic_tx_desc
argument_list|)
operator|>
literal|0x1000
operator|)
condition|)
name|printf
argument_list|(
name|EPIC_FORMAT
literal|": WARNING! tx_desc is misbound or misaligned\n"
argument_list|,
name|EPIC_ARGS
argument_list|(
name|sc
argument_list|)
argument_list|)
expr_stmt|;
name|buf
operator|->
name|mbuf
operator|=
name|NULL
expr_stmt|;
name|desc
operator|->
name|bufaddr
operator|=
name|vtophys
argument_list|(
name|sc
operator|->
name|tx_flist
operator|+
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|desc
operator|->
name|bufaddr
operator|&
literal|3
operator|)
operator|||
operator|(
operator|(
name|desc
operator|->
name|bufaddr
operator|&
literal|0xFFF
operator|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|epic_frag_list
argument_list|)
operator|>
literal|0x1000
operator|)
condition|)
name|printf
argument_list|(
name|EPIC_FORMAT
literal|": WARNING! frag_list is misbound or misaligned\n"
argument_list|,
name|EPIC_ARGS
argument_list|(
name|sc
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * EEPROM operation functions  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|epic_write_eepromreg
name|__P
argument_list|(
operator|(
name|epic_softc_t
operator|*
name|sc
operator|,
name|u_int8_t
name|val
operator|)
argument_list|)
block|{
name|u_int16_t
name|i
decl_stmt|;
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|EECTL
argument_list|,
name|val
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|0xFF
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
operator|(
name|CSR_READ_1
argument_list|(
name|sc
argument_list|,
name|EECTL
argument_list|)
operator|&
literal|0x20
operator|)
condition|)
break|break;
return|return;
block|}
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_int8_t
name|epic_read_eepromreg
name|__P
argument_list|(
operator|(
name|epic_softc_t
operator|*
name|sc
operator|)
argument_list|)
block|{
return|return
name|CSR_READ_1
argument_list|(
name|sc
argument_list|,
name|EECTL
argument_list|)
return|;
block|}
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_int8_t
name|epic_eeprom_clock
name|__P
argument_list|(
operator|(
name|epic_softc_t
operator|*
name|sc
operator|,
name|u_int8_t
name|val
operator|)
argument_list|)
block|{
name|epic_write_eepromreg
argument_list|(
name|sc
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|epic_write_eepromreg
argument_list|(
name|sc
argument_list|,
operator|(
name|val
operator||
literal|0x4
operator|)
argument_list|)
expr_stmt|;
name|epic_write_eepromreg
argument_list|(
name|sc
argument_list|,
name|val
argument_list|)
expr_stmt|;
return|return
name|epic_read_eepromreg
argument_list|(
name|sc
argument_list|)
return|;
block|}
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|epic_output_eepromw
name|__P
argument_list|(
operator|(
name|epic_softc_t
operator|*
name|sc
operator|,
name|u_int16_t
name|val
operator|)
argument_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0xF
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
operator|(
name|val
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
operator|)
condition|)
name|epic_eeprom_clock
argument_list|(
name|sc
argument_list|,
literal|0x0B
argument_list|)
expr_stmt|;
else|else
name|epic_eeprom_clock
argument_list|(
name|sc
argument_list|,
literal|3
argument_list|)
expr_stmt|;
block|}
block|}
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_int16_t
name|epic_input_eepromw
name|__P
argument_list|(
operator|(
name|epic_softc_t
operator|*
name|sc
operator|)
argument_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|tmp
decl_stmt|;
name|u_int16_t
name|retval
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0xF
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|tmp
operator|=
name|epic_eeprom_clock
argument_list|(
name|sc
argument_list|,
literal|0x3
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|&
literal|0x10
condition|)
block|{
name|retval
operator||=
operator|(
literal|1
operator|<<
name|i
operator|)
expr_stmt|;
block|}
block|}
return|return
name|retval
return|;
block|}
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|epic_read_eeprom
name|__P
argument_list|(
operator|(
name|epic_softc_t
operator|*
name|sc
operator|,
name|u_int16_t
name|loc
operator|)
argument_list|)
block|{
name|u_int16_t
name|dataval
decl_stmt|;
name|u_int16_t
name|read_cmd
decl_stmt|;
name|epic_write_eepromreg
argument_list|(
name|sc
argument_list|,
literal|3
argument_list|)
expr_stmt|;
if|if
condition|(
name|epic_read_eepromreg
argument_list|(
name|sc
argument_list|)
operator|&
literal|0x40
condition|)
name|read_cmd
operator|=
operator|(
name|loc
operator|&
literal|0x3F
operator|)
operator||
literal|0x180
expr_stmt|;
else|else
name|read_cmd
operator|=
operator|(
name|loc
operator|&
literal|0xFF
operator|)
operator||
literal|0x600
expr_stmt|;
name|epic_output_eepromw
argument_list|(
name|sc
argument_list|,
name|read_cmd
argument_list|)
expr_stmt|;
name|dataval
operator|=
name|epic_input_eepromw
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|epic_write_eepromreg
argument_list|(
name|sc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
name|dataval
return|;
block|}
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_int16_t
name|epic_read_phy_register
name|__P
argument_list|(
operator|(
name|epic_softc_t
operator|*
name|sc
operator|,
name|u_int16_t
name|loc
operator|)
argument_list|)
block|{
name|int
name|i
decl_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|MIICTL
argument_list|,
operator|(
operator|(
name|loc
operator|<<
literal|4
operator|)
operator||
literal|0x0601
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|0x100
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|MIICTL
argument_list|)
operator|&
literal|1
operator|)
condition|)
break|break;
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|MIIDATA
argument_list|)
return|;
block|}
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|epic_write_phy_register
name|__P
argument_list|(
operator|(
name|epic_softc_t
operator|*
name|sc
operator|,
name|u_int16_t
name|loc
operator|,
name|u_int16_t
name|val
operator|)
argument_list|)
block|{
name|int
name|i
decl_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|MIIDATA
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|MIICTL
argument_list|,
operator|(
operator|(
name|loc
operator|<<
literal|4
operator|)
operator||
literal|0x0602
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|0x100
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|MIICTL
argument_list|)
operator|&
literal|2
operator|)
condition|)
break|break;
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|epic_dump_state
name|__P
argument_list|(
operator|(
name|epic_softc_t
operator|*
name|sc
operator|)
argument_list|)
block|{
name|int
name|j
decl_stmt|;
name|struct
name|epic_tx_desc
modifier|*
name|tdesc
decl_stmt|;
name|struct
name|epic_rx_desc
modifier|*
name|rdesc
decl_stmt|;
name|printf
argument_list|(
name|EPIC_FORMAT
literal|": cur_rx: %d, pending_txs: %d, dirty_tx: %d, cur_tx: %d\n"
argument_list|,
name|EPIC_ARGS
argument_list|(
name|sc
argument_list|)
argument_list|,
name|sc
operator|->
name|cur_rx
argument_list|,
name|sc
operator|->
name|pending_txs
argument_list|,
name|sc
operator|->
name|dirty_tx
argument_list|,
name|sc
operator|->
name|cur_tx
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|EPIC_FORMAT
literal|": COMMAND: 0x%08x, INTSTAT: 0x%08x\n"
argument_list|,
name|EPIC_ARGS
argument_list|(
name|sc
argument_list|)
argument_list|,
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|COMMAND
argument_list|)
argument_list|,
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|INTSTAT
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|EPIC_FORMAT
literal|": PRCDAR: 0x%08x, PTCDAR: 0x%08x\n"
argument_list|,
name|EPIC_ARGS
argument_list|(
name|sc
argument_list|)
argument_list|,
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|PRCDAR
argument_list|)
argument_list|,
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|PTCDAR
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|EPIC_FORMAT
literal|": dumping rx descriptors\n"
argument_list|,
name|EPIC_ARGS
argument_list|(
name|sc
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|RX_RING_SIZE
condition|;
name|j
operator|++
control|)
block|{
name|rdesc
operator|=
name|sc
operator|->
name|rx_desc
operator|+
name|j
expr_stmt|;
name|printf
argument_list|(
literal|"desc%d: %4d 0x%04x, 0x%08x, %4d, 0x%08x\n"
argument_list|,
name|j
argument_list|,
name|rdesc
operator|->
name|rxlength
argument_list|,
name|rdesc
operator|->
name|status
argument_list|,
name|rdesc
operator|->
name|bufaddr
argument_list|,
name|rdesc
operator|->
name|buflength
argument_list|,
name|rdesc
operator|->
name|next
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
name|EPIC_FORMAT
literal|": dumping tx descriptors\n"
argument_list|,
name|EPIC_ARGS
argument_list|(
name|sc
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|TX_RING_SIZE
condition|;
name|j
operator|++
control|)
block|{
name|tdesc
operator|=
name|sc
operator|->
name|tx_desc
operator|+
name|j
expr_stmt|;
name|printf
argument_list|(
literal|"desc%d: %4d 0x%04x, 0x%08lx, 0x%04x %4u, 0x%08lx, mbuf: %p\n"
argument_list|,
name|j
argument_list|,
name|tdesc
operator|->
name|txlength
argument_list|,
name|tdesc
operator|->
name|status
argument_list|,
operator|(
name|u_long
operator|)
name|tdesc
operator|->
name|bufaddr
argument_list|,
name|tdesc
operator|->
name|control
argument_list|,
name|tdesc
operator|->
name|buflength
argument_list|,
operator|(
name|u_long
operator|)
name|tdesc
operator|->
name|next
argument_list|,
operator|(
name|void
operator|*
operator|)
name|sc
operator|->
name|tx_buffer
index|[
name|j
index|]
operator|.
name|mbuf
argument_list|)
expr_stmt|;
block|}
block|}
end_decl_stmt

end_unit

