begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1997 Semen Ustimenko (semen@iclub.nsu.ru)  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * version: stable-167  *  */
end_comment

begin_comment
comment|/*  * EtherPower II 10/100  Fast Ethernet (tx0)  * (aka SMC9432TX based on SMC83c170 EPIC chip)  *  * Written by Semen Ustimenko.  *  * TODO:  *	Implement FULL IFF_MULTICAST support  *	Calculate optimal RX and TX rings size  *	Test, test and test again:)  *	  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/protosw.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
operator|&&
name|__FreeBSD__
operator|>=
literal|3
end_if

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<machine/clock.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_dl.h>
end_include

begin_include
include|#
directive|include
file|<net/if_mib.h>
end_include

begin_include
include|#
directive|include
file|<net/if_media.h>
end_include

begin_include
include|#
directive|include
file|<net/if_types.h>
end_include

begin_include
include|#
directive|include
file|<net/route.h>
end_include

begin_include
include|#
directive|include
file|<net/netisr.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_systm.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip.h>
end_include

begin_include
include|#
directive|include
file|<netinet/if_ether.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_param.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_kern.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<machine/clock.h>
end_include

begin_include
include|#
directive|include
file|"pci.h"
end_include

begin_if
if|#
directive|if
name|NPCI
operator|>
literal|0
end_if

begin_include
include|#
directive|include
file|<pci/pcivar.h>
end_include

begin_include
include|#
directive|include
file|<pci/smc83c170.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"bpfilter.h"
end_include

begin_if
if|#
directive|if
name|NBPFILTER
operator|>
literal|0
end_if

begin_include
include|#
directive|include
file|<net/bpf.h>
end_include

begin_include
include|#
directive|include
file|<net/bpfdesc.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Global variables  */
end_comment

begin_decl_stmt
specifier|static
name|u_long
name|epic_pci_count
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|epic_softc_t
modifier|*
name|epics
index|[
name|EPIC_MAX_DEVICES
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|pci_device
name|txdevice
init|=
block|{
literal|"tx"
block|,
name|epic_pci_probe
block|,
name|epic_pci_attach
block|,
operator|&
name|epic_pci_count
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Append this driver to pci drivers list  */
end_comment

begin_expr_stmt
name|DATA_SET
argument_list|(
name|pcidevice_set
argument_list|,
name|txdevice
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * ifioctl function  *  * splimp() invoked here  */
end_comment

begin_function
specifier|static
name|int
name|epic_ifioctl
parameter_list|(
specifier|register
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|int
name|command
parameter_list|,
name|caddr_t
name|data
parameter_list|)
block|{
name|epic_softc_t
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|ifreq
modifier|*
name|ifr
init|=
operator|(
expr|struct
name|ifreq
operator|*
operator|)
name|data
decl_stmt|;
name|int
name|x
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
name|x
operator|=
name|splimp
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|command
condition|)
block|{
case|case
name|SIOCSIFADDR
case|:
case|case
name|SIOCGIFADDR
case|:
name|ether_ioctl
argument_list|(
name|ifp
argument_list|,
name|command
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCSIFFLAGS
case|:
comment|/* 		 * If the interface is marked up and stopped, then start it. 		 * If it is marked down and running, then stop it. 		 */
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
condition|)
block|{
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
operator|)
operator|==
literal|0
condition|)
block|{
name|epic_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
condition|)
block|{
name|epic_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
name|IFF_RUNNING
expr_stmt|;
break|break;
block|}
block|}
comment|/* Handle IFF_PROMISC flag */
name|epic_set_rx_mode
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCADDMULTI
case|:
case|case
name|SIOCDELMULTI
case|:
comment|/* Update out multicast list */
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
operator|&&
name|__FreeBSD__
operator|>=
literal|3
name|epic_set_mc_table
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
else|#
directive|else
name|error
operator|=
operator|(
name|command
operator|==
name|SIOCADDMULTI
operator|)
condition|?
name|ether_addmulti
argument_list|(
name|ifr
argument_list|,
operator|&
name|sc
operator|->
name|epic_ac
argument_list|)
else|:
name|ether_delmulti
argument_list|(
name|ifr
argument_list|,
operator|&
name|sc
operator|->
name|epic_ac
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|ENETRESET
condition|)
block|{
name|epic_set_mc_table
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
break|break;
case|case
name|SIOCSIFMTU
case|:
comment|/* 		 * Set the interface MTU. 		 */
if|if
condition|(
name|ifr
operator|->
name|ifr_mtu
operator|>
name|ETHERMTU
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
else|else
block|{
name|ifp
operator|->
name|if_mtu
operator|=
name|ifr
operator|->
name|ifr_mtu
expr_stmt|;
block|}
break|break;
case|case
name|SIOCSIFMEDIA
case|:
case|case
name|SIOCGIFMEDIA
case|:
name|error
operator|=
name|ifmedia_ioctl
argument_list|(
name|ifp
argument_list|,
name|ifr
argument_list|,
operator|&
name|sc
operator|->
name|ifmedia
argument_list|,
name|command
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
name|splx
argument_list|(
name|x
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  * ifstart function  *  * splimp() assumed to be done  */
end_comment

begin_function
specifier|static
name|void
name|epic_ifstart
parameter_list|(
name|struct
name|ifnet
modifier|*
specifier|const
name|ifp
parameter_list|)
block|{
name|epic_softc_t
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
while|while
condition|(
name|sc
operator|->
name|pending_txs
operator|<
name|TX_RING_SIZE
condition|)
block|{
name|struct
name|epic_tx_buffer
modifier|*
name|buf
init|=
name|sc
operator|->
name|tx_buffer
operator|+
name|sc
operator|->
name|cur_tx
decl_stmt|;
name|struct
name|epic_tx_desc
modifier|*
name|desc
init|=
name|sc
operator|->
name|tx_desc
operator|+
name|sc
operator|->
name|cur_tx
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|TX_FRAG_LIST
argument_list|)
name|struct
name|epic_frag_list
modifier|*
name|flist
init|=
name|sc
operator|->
name|tx_flist
operator|+
name|sc
operator|->
name|cur_tx
decl_stmt|;
endif|#
directive|endif
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|,
modifier|*
name|m0
decl_stmt|;
name|int
name|len
decl_stmt|;
comment|/* If descriptor is busy, set IFF_OACTIVE and exit */
if|if
condition|(
name|desc
operator|->
name|status
operator|&
literal|0x8000
condition|)
break|break;
comment|/* Get next packet to send */
name|IF_DEQUEUE
argument_list|(
operator|&
operator|(
name|sc
operator|->
name|epic_if
operator|.
name|if_snd
operator|)
argument_list|,
name|m
argument_list|)
expr_stmt|;
comment|/* If no more mbuf's to send, return */
if|if
condition|(
name|NULL
operator|==
name|m
condition|)
return|return;
comment|/* Save mbuf header */
name|m0
operator|=
name|m
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|TX_FRAG_LIST
argument_list|)
if|if
condition|(
name|buf
operator|->
name|mbuf
condition|)
name|m_freem
argument_list|(
name|buf
operator|->
name|mbuf
argument_list|)
expr_stmt|;
name|buf
operator|->
name|mbuf
operator|=
name|m
expr_stmt|;
name|flist
operator|->
name|numfrags
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|len
operator|=
literal|0
init|;
operator|(
name|m0
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|flist
operator|->
name|numfrags
operator|<
literal|63
operator|)
condition|;
name|m0
operator|=
name|m0
operator|->
name|m_next
control|)
block|{
name|flist
operator|->
name|frag
index|[
name|flist
operator|->
name|numfrags
index|]
operator|.
name|fraglen
operator|=
name|m0
operator|->
name|m_len
expr_stmt|;
name|flist
operator|->
name|frag
index|[
name|flist
operator|->
name|numfrags
index|]
operator|.
name|fragaddr
operator|=
name|vtophys
argument_list|(
name|mtod
argument_list|(
name|m0
argument_list|,
name|caddr_t
argument_list|)
argument_list|)
expr_stmt|;
name|len
operator|+=
name|m0
operator|->
name|m_len
expr_stmt|;
name|flist
operator|->
name|numfrags
operator|++
expr_stmt|;
block|}
comment|/* Does not generate TXC unless ring is full more then a half */
name|desc
operator|->
name|control
operator|=
operator|(
name|sc
operator|->
name|pending_txs
operator|>
name|TX_RING_SIZE
operator|/
literal|2
operator|)
condition|?
literal|0x05
else|:
literal|0x01
expr_stmt|;
else|#
directive|else
for|for
control|(
name|len
operator|=
literal|0
init|;
name|m0
operator|!=
literal|0
condition|;
name|m0
operator|=
name|m0
operator|->
name|m_next
control|)
block|{
name|bcopy
argument_list|(
name|mtod
argument_list|(
name|m0
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
name|buf
operator|->
name|data
operator|+
name|len
argument_list|,
name|m0
operator|->
name|m_len
argument_list|)
expr_stmt|;
name|len
operator|+=
name|m0
operator|->
name|m_len
expr_stmt|;
block|}
comment|/* Does not generate TXC unless ring is full more then a half */
name|desc
operator|->
name|control
operator|=
operator|(
name|sc
operator|->
name|pending_txs
operator|>
name|TX_RING_SIZE
operator|/
literal|2
operator|)
condition|?
literal|0x14
else|:
literal|0x10
expr_stmt|;
endif|#
directive|endif
comment|/* Packet should be at least ETHER_MIN_LEN */
name|desc
operator|->
name|txlength
operator|=
name|max
argument_list|(
name|len
argument_list|,
name|ETHER_MIN_LEN
operator|-
name|ETHER_CRC_LEN
argument_list|)
expr_stmt|;
comment|/* Pass ownership to the chip */
name|desc
operator|->
name|status
operator|=
literal|0x8000
expr_stmt|;
comment|/* Set watchdog timer */
name|ifp
operator|->
name|if_timer
operator|=
literal|2
expr_stmt|;
if|#
directive|if
name|NBPFILTER
operator|>
literal|0
if|if
condition|(
name|ifp
operator|->
name|if_bpf
condition|)
name|bpf_mtap
argument_list|(
name|ifp
argument_list|,
name|m
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
operator|!
name|defined
argument_list|(
name|TX_FRAG_LIST
argument_list|)
comment|/* We don't need mbuf anyway */
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Trigger an immediate transmit demand. */
name|outl
argument_list|(
name|sc
operator|->
name|iobase
operator|+
name|COMMAND
argument_list|,
name|COMMAND_TXQUEUED
argument_list|)
expr_stmt|;
comment|/* Packet queued successful */
name|sc
operator|->
name|pending_txs
operator|++
expr_stmt|;
comment|/* Switch to next descriptor */
name|sc
operator|->
name|cur_tx
operator|=
operator|(
name|sc
operator|->
name|cur_tx
operator|+
literal|1
operator|)
operator|%
name|TX_RING_SIZE
expr_stmt|;
block|}
name|sc
operator|->
name|epic_if
operator|.
name|if_flags
operator||=
name|IFF_OACTIVE
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  *  IFWATCHDOG function  *  * splimp() invoked here  */
end_comment

begin_function
specifier|static
name|void
name|epic_ifwatchdog
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|epic_softc_t
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|int
name|x
decl_stmt|;
name|int
name|i
decl_stmt|;
name|x
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|printf
argument_list|(
literal|"tx%d: device timeout %d packets\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|,
name|sc
operator|->
name|pending_txs
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_oerrors
operator|+=
name|sc
operator|->
name|pending_txs
expr_stmt|;
name|epic_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|epic_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|epic_ifstart
argument_list|(
operator|&
name|sc
operator|->
name|epic_if
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *  * splimp() invoked before epic_intr_normal()  */
end_comment

begin_decl_stmt
specifier|static
specifier|inline
name|void
name|epic_rx_done
name|__P
argument_list|(
operator|(
name|epic_softc_t
operator|*
name|sc
operator|)
argument_list|)
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
name|u_int16_t
name|len
decl_stmt|;
name|struct
name|epic_rx_buffer
modifier|*
name|buf
decl_stmt|;
name|struct
name|epic_rx_desc
modifier|*
name|desc
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|RX_TO_MBUF
argument_list|)
name|struct
name|mbuf
modifier|*
name|m0
decl_stmt|;
endif|#
directive|endif
name|struct
name|ether_header
modifier|*
name|eh
decl_stmt|;
name|int
name|stt
decl_stmt|;
while|while
condition|(
operator|!
operator|(
name|sc
operator|->
name|rx_desc
index|[
name|sc
operator|->
name|cur_rx
index|]
operator|.
name|status
operator|&
literal|0x8000
operator|)
operator|&&
expr|\
name|i
operator|++
operator|<
name|RX_RING_SIZE
condition|)
block|{
name|buf
operator|=
name|sc
operator|->
name|rx_buffer
operator|+
name|sc
operator|->
name|cur_rx
expr_stmt|;
name|desc
operator|=
name|sc
operator|->
name|rx_desc
operator|+
name|sc
operator|->
name|cur_rx
expr_stmt|;
name|stt
operator|=
name|desc
operator|->
name|status
expr_stmt|;
comment|/* Check for errors */
if|if
condition|(
operator|!
operator|(
name|desc
operator|->
name|status
operator|&
literal|1
operator|)
condition|)
block|{
name|sc
operator|->
name|epic_if
operator|.
name|if_ierrors
operator|++
expr_stmt|;
goto|goto
name|rxerror
goto|;
block|}
comment|/* This is received frame actual length */
name|len
operator|=
name|desc
operator|->
name|rxlength
operator|-
name|ETHER_CRC_LEN
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|RX_TO_MBUF
argument_list|)
comment|/* Try to allocate mbuf cluster */
name|MGETHDR
argument_list|(
name|m0
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|m0
condition|)
block|{
name|printf
argument_list|(
literal|"tx%d: cannot allocate mbuf header\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
name|sc
operator|->
name|epic_if
operator|.
name|if_ierrors
operator|++
expr_stmt|;
goto|goto
name|rxerror
goto|;
block|}
name|MCLGET
argument_list|(
name|m0
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
operator|(
name|m0
operator|->
name|m_flags
operator|&
name|M_EXT
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"tx%d: cannot allocate mbuf cluster\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
name|sc
operator|->
name|epic_if
operator|.
name|if_ierrors
operator|++
expr_stmt|;
goto|goto
name|rxerror
goto|;
block|}
comment|/* Swap new allocated mbuf with mbuf, containing packet */
name|m
operator|=
name|buf
operator|->
name|mbuf
expr_stmt|;
name|buf
operator|->
name|mbuf
operator|=
name|m0
expr_stmt|;
comment|/* Insert new allocated mbuf into device queue */
name|desc
operator|->
name|bufaddr
operator|=
name|vtophys
argument_list|(
name|mtod
argument_list|(
name|buf
operator|->
name|mbuf
argument_list|,
name|caddr_t
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* Allocate mbuf to pass to OS */
name|MGETHDR
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|m
condition|)
block|{
name|printf
argument_list|(
literal|"tx%d: cannot allocate mbuf header\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
name|sc
operator|->
name|epic_if
operator|.
name|if_ierrors
operator|++
expr_stmt|;
goto|goto
name|rxerror
goto|;
block|}
if|if
condition|(
name|len
operator|>
name|MHLEN
condition|)
block|{
name|MCLGET
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
operator|(
name|m
operator|->
name|m_flags
operator|&
name|M_EXT
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"tx%d: cannot allocate mbuf cluster\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|sc
operator|->
name|epic_if
operator|.
name|if_ierrors
operator|++
expr_stmt|;
goto|goto
name|rxerror
goto|;
block|}
block|}
comment|/* Copy packet to new allocated mbuf */
name|memcpy
argument_list|(
name|mtod
argument_list|(
name|m
argument_list|,
name|void
operator|*
argument_list|)
argument_list|,
name|buf
operator|->
name|data
argument_list|,
name|len
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* First mbuf in packet holds the ethernet and packet headers */
name|eh
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ether_header
operator|*
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
operator|&
operator|(
name|sc
operator|->
name|epic_if
operator|)
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|len
expr_stmt|;
name|m
operator|->
name|m_len
operator|=
name|len
expr_stmt|;
if|#
directive|if
name|NBPFILTER
operator|>
literal|0
comment|/* Give mbuf to BPFILTER */
if|if
condition|(
name|sc
operator|->
name|epic_if
operator|.
name|if_bpf
condition|)
name|bpf_mtap
argument_list|(
operator|&
name|sc
operator|->
name|epic_if
argument_list|,
name|m
argument_list|)
expr_stmt|;
comment|/* Accept only our packets, broadcasts and multicasts */
if|if
condition|(
operator|(
name|eh
operator|->
name|ether_dhost
index|[
literal|0
index|]
operator|&
literal|1
operator|)
operator|==
literal|0
operator|&&
name|bcmp
argument_list|(
name|eh
operator|->
name|ether_dhost
argument_list|,
name|sc
operator|->
name|epic_ac
operator|.
name|ac_enaddr
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
goto|goto
name|rxerror
goto|;
block|}
endif|#
directive|endif
comment|/* Second mbuf holds packet ifself */
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|len
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_len
operator|=
name|len
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_data
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
expr_stmt|;
comment|/* Give mbuf to OS */
name|ether_input
argument_list|(
operator|&
name|sc
operator|->
name|epic_if
argument_list|,
name|eh
argument_list|,
name|m
argument_list|)
expr_stmt|;
comment|/* Successfuly received frame */
name|sc
operator|->
name|epic_if
operator|.
name|if_ipackets
operator|++
expr_stmt|;
name|rxerror
label|:
comment|/* Mark current descriptor as free */
name|desc
operator|->
name|rxlength
operator|=
literal|0
expr_stmt|;
name|desc
operator|->
name|status
operator|=
literal|0x8000
expr_stmt|;
comment|/* Switch to next descriptor */
name|sc
operator|->
name|cur_rx
operator|=
operator|(
name|sc
operator|->
name|cur_rx
operator|+
literal|1
operator|)
operator|%
name|RX_RING_SIZE
expr_stmt|;
block|}
return|return;
block|}
end_decl_stmt

begin_comment
comment|/*  *  * splimp() invoked before epic_intr_normal()  */
end_comment

begin_decl_stmt
specifier|static
specifier|inline
name|void
name|epic_tx_done
name|__P
argument_list|(
operator|(
name|epic_softc_t
operator|*
name|sc
operator|)
argument_list|)
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
name|u_int32_t
name|if_flags
init|=
operator|~
literal|0
decl_stmt|;
name|int
name|coll
decl_stmt|;
name|u_int16_t
name|stt
decl_stmt|;
while|while
condition|(
name|i
operator|++
operator|<
name|TX_RING_SIZE
condition|)
block|{
name|struct
name|epic_tx_buffer
modifier|*
name|buf
init|=
name|sc
operator|->
name|tx_buffer
operator|+
name|sc
operator|->
name|dirty_tx
decl_stmt|;
name|struct
name|epic_tx_desc
modifier|*
name|desc
init|=
name|sc
operator|->
name|tx_desc
operator|+
name|sc
operator|->
name|dirty_tx
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|TX_FRAG_LIST
argument_list|)
name|struct
name|epic_frag_list
modifier|*
name|flist
init|=
name|sc
operator|->
name|tx_flist
operator|+
name|sc
operator|->
name|dirty_tx
decl_stmt|;
endif|#
directive|endif
name|u_int16_t
name|len
init|=
name|desc
operator|->
name|txlength
decl_stmt|;
name|stt
operator|=
name|desc
operator|->
name|status
expr_stmt|;
if|if
condition|(
name|stt
operator|&
literal|0x8000
condition|)
break|break;
comment|/* following packets are not Txed yet */
if|if
condition|(
name|stt
operator|==
literal|0
condition|)
block|{
name|if_flags
operator|=
operator|~
name|IFF_OACTIVE
expr_stmt|;
break|break;
block|}
name|sc
operator|->
name|pending_txs
operator|--
expr_stmt|;
comment|/* packet is finished */
name|sc
operator|->
name|dirty_tx
operator|=
operator|(
name|sc
operator|->
name|dirty_tx
operator|+
literal|1
operator|)
operator|%
name|TX_RING_SIZE
expr_stmt|;
name|coll
operator|=
operator|(
name|stt
operator|>>
literal|8
operator|)
operator|&
literal|0xF
expr_stmt|;
comment|/* number of collisions*/
if|if
condition|(
name|stt
operator|&
literal|0x0001
condition|)
block|{
name|sc
operator|->
name|epic_if
operator|.
name|if_opackets
operator|++
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|stt
operator|&
literal|0x0008
condition|)
name|sc
operator|->
name|dot3stats
operator|.
name|dot3StatsCarrierSenseErrors
operator|++
expr_stmt|;
if|if
condition|(
name|stt
operator|&
literal|0x1050
condition|)
name|sc
operator|->
name|dot3stats
operator|.
name|dot3StatsInternalMacTransmitErrors
operator|++
expr_stmt|;
if|if
condition|(
name|stt
operator|&
literal|0x1000
condition|)
name|coll
operator|=
literal|16
expr_stmt|;
name|sc
operator|->
name|epic_if
operator|.
name|if_oerrors
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|stt
operator|&
literal|0x0002
condition|)
comment|/* What does it mean? */
name|sc
operator|->
name|dot3stats
operator|.
name|dot3StatsDeferredTransmissions
operator|++
expr_stmt|;
name|sc
operator|->
name|epic_if
operator|.
name|if_collisions
operator|+=
name|coll
expr_stmt|;
switch|switch
condition|(
name|coll
condition|)
block|{
case|case
literal|0
case|:
break|break;
case|case
literal|16
case|:
name|sc
operator|->
name|dot3stats
operator|.
name|dot3StatsExcessiveCollisions
operator|++
expr_stmt|;
name|sc
operator|->
name|dot3stats
operator|.
name|dot3StatsCollFrequencies
index|[
literal|15
index|]
operator|++
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|sc
operator|->
name|dot3stats
operator|.
name|dot3StatsSingleCollisionFrames
operator|++
expr_stmt|;
name|sc
operator|->
name|dot3stats
operator|.
name|dot3StatsCollFrequencies
index|[
literal|0
index|]
operator|++
expr_stmt|;
break|break;
default|default:
name|sc
operator|->
name|dot3stats
operator|.
name|dot3StatsMultipleCollisionFrames
operator|++
expr_stmt|;
name|sc
operator|->
name|dot3stats
operator|.
name|dot3StatsCollFrequencies
index|[
name|coll
operator|-
literal|1
index|]
operator|++
expr_stmt|;
break|break;
block|}
name|desc
operator|->
name|status
operator|=
literal|0
expr_stmt|;
name|desc
operator|->
name|txlength
operator|=
literal|0
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|TX_FRAG_LIST
argument_list|)
name|flist
operator|->
name|numfrags
operator|=
literal|0
expr_stmt|;
name|m_freem
argument_list|(
name|buf
operator|->
name|mbuf
argument_list|)
expr_stmt|;
name|buf
operator|->
name|mbuf
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
name|if_flags
operator|=
operator|~
name|IFF_OACTIVE
expr_stmt|;
block|}
name|sc
operator|->
name|epic_if
operator|.
name|if_flags
operator|&=
name|if_flags
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|sc
operator|->
name|epic_if
operator|.
name|if_flags
operator|&
name|IFF_OACTIVE
operator|)
condition|)
name|epic_ifstart
argument_list|(
operator|&
name|sc
operator|->
name|epic_if
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|/*  * Interrupt function  *  * splimp() assumed to be done   */
end_comment

begin_function
specifier|static
name|void
name|epic_intr_normal
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|epic_softc_t
modifier|*
name|sc
init|=
operator|(
name|epic_softc_t
operator|*
operator|)
name|arg
decl_stmt|;
name|int
name|iobase
init|=
name|sc
operator|->
name|iobase
decl_stmt|;
name|int
name|status
decl_stmt|;
name|status
operator|=
name|inl
argument_list|(
name|iobase
operator|+
name|INTSTAT
argument_list|)
expr_stmt|;
name|outl
argument_list|(
name|iobase
operator|+
name|INTSTAT
argument_list|,
name|status
operator|&
operator|(
name|INTSTAT_RQE
operator||
name|INTSTAT_HCC
operator||
name|INTSTAT_RCC
operator||
name|INTSTAT_TXC
operator||
name|INTSTAT_TCC
operator||
name|INTSTAT_TQE
operator||
name|INTSTAT_FATAL
operator||
name|INTSTAT_GP2
operator||
name|INTSTAT_CNT
operator||
name|INTSTAT_TXU
operator||
name|INTSTAT_OVW
operator||
name|INTSTAT_RXE
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|&
operator|(
name|INTSTAT_RQE
operator||
name|INTSTAT_HCC
operator||
name|INTSTAT_RCC
operator|)
condition|)
block|{
name|epic_rx_done
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|&
name|INTSTAT_RQE
condition|)
name|outl
argument_list|(
name|iobase
operator|+
name|COMMAND
argument_list|,
name|COMMAND_RXQUEUED
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|status
operator|&
operator|(
name|INTSTAT_TXC
operator||
name|INTSTAT_TCC
operator||
name|INTSTAT_TQE
operator|)
condition|)
name|epic_tx_done
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|status
operator|&
name|INTSTAT_TQE
operator|)
operator|&&
operator|!
operator|(
name|sc
operator|->
name|epic_if
operator|.
name|if_flags
operator|&
name|IFF_OACTIVE
operator|)
condition|)
name|epic_ifstart
argument_list|(
operator|&
name|sc
operator|->
name|epic_if
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|status
operator|&
name|INTSTAT_GP2
operator|)
operator|&&
operator|(
name|QS6612_OUI
operator|==
name|sc
operator|->
name|phyid
operator|)
condition|)
block|{
name|u_int32_t
name|status
decl_stmt|;
name|status
operator|=
name|epic_read_phy_register
argument_list|(
name|sc
operator|->
name|iobase
argument_list|,
literal|29
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|status
operator|&
name|INTSTAT_AN_COMPLETE
operator|)
operator|&&
operator|(
name|epic_autoneg
argument_list|(
name|sc
argument_list|)
operator|==
name|EPIC_FULL_DUPLEX
operator|)
condition|)
block|{
name|status
operator|=
name|BMCR_FULL_DUPLEX
operator||
name|epic_read_phy_register
argument_list|(
name|sc
operator|->
name|iobase
argument_list|,
name|DP83840_BMCR
argument_list|)
expr_stmt|;
name|outl
argument_list|(
name|sc
operator|->
name|iobase
operator|+
name|TXCON
argument_list|,
name|TXCON_LOOPBACK_MODE_FULL_DUPLEX
operator||
name|TXCON_DEFAULT
argument_list|)
expr_stmt|;
block|}
else|else
name|status
operator|=
operator|~
name|BMCR_FULL_DUPLEX
operator|&
name|epic_read_phy_register
argument_list|(
name|sc
operator|->
name|iobase
argument_list|,
name|DP83840_BMCR
argument_list|)
expr_stmt|;
comment|/* There is apparently QS6612 chip bug: */
comment|/* BMCR_FULL_DUPLEX flag is not updated by */
comment|/* autonegotiation process, so update manual */
name|epic_write_phy_register
argument_list|(
name|sc
operator|->
name|iobase
argument_list|,
name|DP83840_BMCR
argument_list|,
name|status
argument_list|)
expr_stmt|;
comment|/* We should clear GP2 int source after we clear it on PHY */
name|outl
argument_list|(
name|iobase
operator|+
name|INTSTAT
argument_list|,
name|INTSTAT_GP2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|status
operator|&
operator|(
name|INTSTAT_FATAL
operator||
name|INTSTAT_PMA
operator||
name|INTSTAT_PTA
operator||
name|INTSTAT_APE
operator||
name|INTSTAT_DPE
operator|)
condition|)
block|{
name|int
name|j
decl_stmt|;
name|struct
name|epic_tx_desc
modifier|*
name|desc
decl_stmt|;
name|printf
argument_list|(
literal|"tx%d: PCI fatal error occured (%s%s%s%s)\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|,
operator|(
name|status
operator|&
name|INTSTAT_PMA
operator|)
condition|?
literal|"PMA"
else|:
literal|""
argument_list|,
operator|(
name|status
operator|&
name|INTSTAT_PTA
operator|)
condition|?
literal|" PTA"
else|:
literal|""
argument_list|,
operator|(
name|status
operator|&
name|INTSTAT_APE
operator|)
condition|?
literal|" APE"
else|:
literal|""
argument_list|,
operator|(
name|status
operator|&
name|INTSTAT_DPE
operator|)
condition|?
literal|" DPE"
else|:
literal|""
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|EPIC_DEBUG
argument_list|)
name|printf
argument_list|(
literal|"tx%d: dumping descriptors\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|TX_RING_SIZE
condition|;
name|j
operator|++
control|)
block|{
name|desc
operator|=
name|sc
operator|->
name|tx_desc
operator|+
name|j
expr_stmt|;
name|printf
argument_list|(
literal|"desc%d: %d %04x, %08x, %04x %d, %08x\n"
argument_list|,
name|j
argument_list|,
name|desc
operator|->
name|txlength
argument_list|,
name|desc
operator|->
name|status
argument_list|,
name|desc
operator|->
name|bufaddr
argument_list|,
name|desc
operator|->
name|control
argument_list|,
name|desc
operator|->
name|buflength
argument_list|,
name|desc
operator|->
name|next
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|epic_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|epic_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* UPDATE statistics */
if|if
condition|(
name|status
operator|&
operator|(
name|INTSTAT_CNT
operator||
name|INTSTAT_TXU
operator||
name|INTSTAT_OVW
operator||
name|INTSTAT_RXE
operator|)
condition|)
block|{
comment|/* update dot3 Rx statistics */
name|sc
operator|->
name|dot3stats
operator|.
name|dot3StatsMissedFrames
operator|+=
name|inb
argument_list|(
name|iobase
operator|+
name|MPCNT
argument_list|)
expr_stmt|;
name|sc
operator|->
name|dot3stats
operator|.
name|dot3StatsFrameTooLongs
operator|+=
name|inb
argument_list|(
name|iobase
operator|+
name|ALICNT
argument_list|)
expr_stmt|;
name|sc
operator|->
name|dot3stats
operator|.
name|dot3StatsFCSErrors
operator|+=
name|inb
argument_list|(
name|iobase
operator|+
name|CRCCNT
argument_list|)
expr_stmt|;
comment|/* Update if Rx statistics */
if|if
condition|(
name|status
operator|&
operator|(
name|INTSTAT_OVW
operator||
name|INTSTAT_RXE
operator|)
condition|)
name|sc
operator|->
name|epic_if
operator|.
name|if_ierrors
operator|++
expr_stmt|;
comment|/* Tx FIFO underflow. */
if|if
condition|(
name|status
operator|&
name|INTSTAT_TXU
condition|)
block|{
comment|/* Inc. counters */
name|sc
operator|->
name|dot3stats
operator|.
name|dot3StatsInternalMacTransmitErrors
operator|++
expr_stmt|;
name|sc
operator|->
name|epic_if
operator|.
name|if_oerrors
operator|++
expr_stmt|;
comment|/* Restart the transmit process. */
name|outl
argument_list|(
name|iobase
operator|+
name|COMMAND
argument_list|,
name|COMMAND_TXUGO
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If no packets are pending, thus no timeouts */
if|if
condition|(
name|sc
operator|->
name|pending_txs
operator|==
literal|0
condition|)
name|sc
operator|->
name|epic_if
operator|.
name|if_timer
operator|=
literal|0
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * Probe function  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|epic_pci_probe
parameter_list|(
name|pcici_t
name|config_id
parameter_list|,
name|pcidi_t
name|device_id
parameter_list|)
block|{
if|if
condition|(
name|PCI_VENDORID
argument_list|(
name|device_id
argument_list|)
operator|!=
name|SMC_VENDORID
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|PCI_CHIPID
argument_list|(
name|device_id
argument_list|)
operator|==
name|CHIPID_83C170
condition|)
return|return
literal|"SMC 83c170"
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/*  * PCI_Attach function  *  * splimp() invoked here  */
end_comment

begin_function
specifier|static
name|void
name|epic_pci_attach
parameter_list|(
name|pcici_t
name|config_id
parameter_list|,
name|int
name|unit
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|epic_softc_t
modifier|*
name|sc
decl_stmt|;
name|u_int32_t
name|iobase
decl_stmt|;
name|u_int32_t
name|irq
decl_stmt|;
name|int
name|i
decl_stmt|,
name|s
decl_stmt|,
name|media
decl_stmt|;
name|u_int32_t
name|pool
decl_stmt|;
comment|/* 	 * Get iobase and irq level 	 */
name|irq
operator|=
name|PCI_CONF_READ
argument_list|(
name|PCI_CFIT
argument_list|)
operator|&
operator|(
literal|0xFF
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|pci_map_port
argument_list|(
name|config_id
argument_list|,
name|PCI_CBIO
argument_list|,
operator|(
name|u_short
operator|*
operator|)
operator|&
name|iobase
argument_list|)
condition|)
return|return;
comment|/* Allocate memory for softc and hardware descriptors */
name|sc
operator|=
operator|(
name|epic_softc_t
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|epic_softc_t
argument_list|)
operator|+
if|#
directive|if
name|defined
argument_list|(
name|TX_FRAG_LIST
argument_list|)
sizeof|sizeof
argument_list|(
expr|struct
name|epic_frag_list
argument_list|)
operator|*
name|TX_RING_SIZE
operator|+
endif|#
directive|endif
sizeof|sizeof
argument_list|(
expr|struct
name|epic_rx_desc
argument_list|)
operator|*
name|RX_RING_SIZE
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|epic_tx_desc
argument_list|)
operator|*
name|TX_RING_SIZE
operator|+
name|PAGE_SIZE
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
return|return;
comment|/* Align pool on PAGE_SIZE */
name|pool
operator|=
operator|(
operator|(
name|u_int32_t
operator|)
name|sc
operator|)
operator|+
sizeof|sizeof
argument_list|(
name|epic_softc_t
argument_list|)
expr_stmt|;
name|pool
operator|=
operator|(
name|pool
operator|+
name|PAGE_SIZE
operator|-
literal|1
operator|)
operator|&
operator|~
operator|(
name|PAGE_SIZE
operator|-
literal|1
operator|)
expr_stmt|;
comment|/* Preinitialize softc structure */
name|bzero
argument_list|(
name|sc
argument_list|,
sizeof|sizeof
argument_list|(
name|epic_softc_t
argument_list|)
argument_list|)
expr_stmt|;
name|epics
index|[
name|unit
index|]
operator|=
name|sc
expr_stmt|;
name|sc
operator|->
name|unit
operator|=
name|unit
expr_stmt|;
name|sc
operator|->
name|iobase
operator|=
name|iobase
expr_stmt|;
name|sc
operator|->
name|irq
operator|=
name|irq
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|TX_FRAG_LIST
argument_list|)
name|sc
operator|->
name|tx_flist
operator|=
operator|(
name|void
operator|*
operator|)
name|pool
expr_stmt|;
name|pool
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|epic_frag_list
argument_list|)
operator|*
name|TX_RING_SIZE
expr_stmt|;
endif|#
directive|endif
name|sc
operator|->
name|rx_desc
operator|=
operator|(
name|void
operator|*
operator|)
name|pool
expr_stmt|;
name|pool
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|epic_rx_desc
argument_list|)
operator|*
name|RX_RING_SIZE
expr_stmt|;
name|sc
operator|->
name|tx_desc
operator|=
operator|(
name|void
operator|*
operator|)
name|pool
expr_stmt|;
comment|/* Bring the chip out of low-power mode. */
name|outl
argument_list|(
name|iobase
operator|+
name|GENCTL
argument_list|,
literal|0x0000
argument_list|)
expr_stmt|;
comment|/* Magic?!  If we don't set this bit the MII interface won't work. */
name|outl
argument_list|(
name|iobase
operator|+
name|TEST1
argument_list|,
literal|0x0008
argument_list|)
expr_stmt|;
comment|/* Read mac address (may be better is read from EEPROM?) */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ETHER_ADDR_LEN
operator|/
sizeof|sizeof
argument_list|(
name|u_int16_t
argument_list|)
condition|;
name|i
operator|++
control|)
operator|(
operator|(
name|u_int16_t
operator|*
operator|)
name|sc
operator|->
name|epic_macaddr
operator|)
index|[
name|i
index|]
operator|=
name|inw
argument_list|(
name|iobase
operator|+
name|LAN0
operator|+
name|i
operator|*
literal|4
argument_list|)
expr_stmt|;
comment|/* Display some info */
name|printf
argument_list|(
literal|"tx%d: address %02x:%02x:%02x:%02x:%02x:%02x,"
argument_list|,
name|sc
operator|->
name|unit
argument_list|,
name|sc
operator|->
name|epic_macaddr
index|[
literal|0
index|]
argument_list|,
name|sc
operator|->
name|epic_macaddr
index|[
literal|1
index|]
argument_list|,
name|sc
operator|->
name|epic_macaddr
index|[
literal|2
index|]
argument_list|,
name|sc
operator|->
name|epic_macaddr
index|[
literal|3
index|]
argument_list|,
name|sc
operator|->
name|epic_macaddr
index|[
literal|4
index|]
argument_list|,
name|sc
operator|->
name|epic_macaddr
index|[
literal|5
index|]
argument_list|)
expr_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
comment|/* Map interrupt */
if|if
condition|(
operator|!
name|pci_map_int
argument_list|(
name|config_id
argument_list|,
name|epic_intr_normal
argument_list|,
operator|(
name|void
operator|*
operator|)
name|sc
argument_list|,
operator|&
name|net_imask
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"tx%d: couldn't map interrupt\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|epics
index|[
name|unit
index|]
operator|=
name|NULL
expr_stmt|;
name|free
argument_list|(
name|sc
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Fill ifnet structure */
name|ifp
operator|=
operator|&
name|sc
operator|->
name|epic_if
expr_stmt|;
name|ifp
operator|->
name|if_unit
operator|=
name|unit
expr_stmt|;
name|ifp
operator|->
name|if_name
operator|=
literal|"tx"
expr_stmt|;
name|ifp
operator|->
name|if_softc
operator|=
name|sc
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|=
name|IFF_BROADCAST
operator||
name|IFF_SIMPLEX
operator||
name|IFF_MULTICAST
expr_stmt|;
name|ifp
operator|->
name|if_ioctl
operator|=
name|epic_ifioctl
expr_stmt|;
name|ifp
operator|->
name|if_start
operator|=
name|epic_ifstart
expr_stmt|;
name|ifp
operator|->
name|if_watchdog
operator|=
name|epic_ifwatchdog
expr_stmt|;
name|ifp
operator|->
name|if_init
operator|=
operator|(
name|if_init_f_t
operator|*
operator|)
name|epic_init
expr_stmt|;
name|ifp
operator|->
name|if_timer
operator|=
literal|0
expr_stmt|;
name|ifp
operator|->
name|if_output
operator|=
name|ether_output
expr_stmt|;
name|ifp
operator|->
name|if_linkmib
operator|=
operator|&
name|sc
operator|->
name|dot3stats
expr_stmt|;
name|ifp
operator|->
name|if_linkmiblen
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ifmib_iso_8802_3
argument_list|)
expr_stmt|;
name|sc
operator|->
name|dot3stats
operator|.
name|dot3StatsEtherChipSet
operator|=
name|DOT3CHIPSET
argument_list|(
name|dot3VendorSMC
argument_list|,
name|dot3ChipSetSMC83c170
argument_list|)
expr_stmt|;
name|sc
operator|->
name|dot3stats
operator|.
name|dot3Compliance
operator|=
name|DOT3COMPLIANCE_COLLS
expr_stmt|;
name|printf
argument_list|(
literal|" type SMC9432TX, "
argument_list|)
expr_stmt|;
comment|/* Identify PHY */
name|sc
operator|->
name|phyid
operator|=
name|epic_read_phy_register
argument_list|(
name|iobase
argument_list|,
name|DP83840_PHYIDR1
argument_list|)
operator|<<
literal|6
expr_stmt|;
name|sc
operator|->
name|phyid
operator||=
operator|(
operator|(
name|epic_read_phy_register
argument_list|(
name|iobase
argument_list|,
name|DP83840_PHYIDR2
argument_list|)
operator|>>
literal|10
operator|)
operator|&
literal|0x3F
operator|)
expr_stmt|;
if|if
condition|(
name|QS6612_OUI
operator|==
name|sc
operator|->
name|phyid
condition|)
block|{
name|printf
argument_list|(
literal|"phy QS6612, "
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|DP83840_OUI
operator|==
name|sc
operator|->
name|phyid
condition|)
block|{
name|printf
argument_list|(
literal|"phy DP83840, "
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"phy: unknown (%x), "
argument_list|,
name|sc
operator|->
name|phyid
argument_list|)
expr_stmt|;
name|sc
operator|->
name|phyid
operator|=
name|DP83840_OUI
expr_stmt|;
block|}
comment|/* Read current config */
name|i
operator|=
name|epic_read_phy_register
argument_list|(
name|iobase
argument_list|,
name|DP83840_BMCR
argument_list|)
expr_stmt|;
name|media
operator|=
name|IFM_ETHER
expr_stmt|;
if|if
condition|(
name|i
operator|&
name|BMCR_AUTONEGOTIATION
condition|)
block|{
name|i
operator|=
name|epic_read_phy_register
argument_list|(
name|iobase
argument_list|,
name|DP83840_LPAR
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Auto-Neg "
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|&
operator|(
name|ANAR_100_TX
operator||
name|ANAR_100_TX_FD
operator|)
condition|)
name|printf
argument_list|(
literal|"100Mbps "
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"10Mbps "
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|&
operator|(
name|ANAR_10_FD
operator||
name|ANAR_100_TX_FD
operator|)
condition|)
name|printf
argument_list|(
literal|"FD"
argument_list|)
expr_stmt|;
name|media
operator||=
name|IFM_AUTO
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|i
operator|&
name|BMCR_100MBPS
condition|)
block|{
name|printf
argument_list|(
literal|"100Mbps "
argument_list|)
expr_stmt|;
name|media
operator||=
name|IFM_100_TX
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"10Mbps "
argument_list|)
expr_stmt|;
name|media
operator||=
name|IFM_10_T
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|&
name|BMCR_FULL_DUPLEX
condition|)
block|{
name|printf
argument_list|(
literal|"FD"
argument_list|)
expr_stmt|;
name|media
operator||=
name|IFM_FDX
expr_stmt|;
block|}
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
comment|/* init ifmedia interface */
name|ifmedia_init
argument_list|(
operator|&
name|sc
operator|->
name|ifmedia
argument_list|,
literal|0
argument_list|,
name|epic_ifmedia_change
argument_list|,
name|epic_ifmedia_status
argument_list|)
expr_stmt|;
name|ifmedia_add
argument_list|(
operator|&
name|sc
operator|->
name|ifmedia
argument_list|,
name|IFM_ETHER
operator||
name|IFM_10_T
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ifmedia_add
argument_list|(
operator|&
name|sc
operator|->
name|ifmedia
argument_list|,
name|IFM_ETHER
operator||
name|IFM_10_T
operator||
name|IFM_FDX
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ifmedia_add
argument_list|(
operator|&
name|sc
operator|->
name|ifmedia
argument_list|,
name|IFM_ETHER
operator||
name|IFM_100_TX
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ifmedia_add
argument_list|(
operator|&
name|sc
operator|->
name|ifmedia
argument_list|,
name|IFM_ETHER
operator||
name|IFM_100_TX
operator||
name|IFM_FDX
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ifmedia_add
argument_list|(
operator|&
name|sc
operator|->
name|ifmedia
argument_list|,
name|IFM_ETHER
operator||
name|IFM_AUTO
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ifmedia_set
argument_list|(
operator|&
name|sc
operator|->
name|ifmedia
argument_list|,
name|media
argument_list|)
expr_stmt|;
comment|/* Read MBSR twice to update latched bits */
name|epic_read_phy_register
argument_list|(
name|iobase
argument_list|,
name|DP83840_BMSR
argument_list|)
expr_stmt|;
name|i
operator|=
name|epic_read_phy_register
argument_list|(
name|iobase
argument_list|,
name|DP83840_BMSR
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|i
operator|&
name|BMSR_LINK_STATUS
operator|)
condition|)
name|printf
argument_list|(
literal|"tx%d: WARNING! no link estabilished\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
comment|/* Set shut down routine to stop DMA processes on reboot */
name|at_shutdown
argument_list|(
name|epic_shutdown
argument_list|,
name|sc
argument_list|,
name|SHUTDOWN_POST_SYNC
argument_list|)
expr_stmt|;
comment|/* 	 *  Attach to if manager 	 */
name|if_attach
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|ether_ifattach
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
if|#
directive|if
name|NBPFILTER
operator|>
literal|0
name|bpfattach
argument_list|(
name|ifp
argument_list|,
name|DLT_EN10MB
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_decl_stmt
specifier|static
name|int
name|epic_ifmedia_change
name|__P
argument_list|(
operator|(
expr|struct
name|ifnet
operator|*
name|ifp
operator|)
argument_list|)
block|{
if|if
condition|(
name|IFM_TYPE
argument_list|(
operator|(
operator|(
name|epic_softc_t
operator|*
operator|)
operator|(
name|ifp
operator|->
name|if_softc
operator|)
operator|)
operator|->
name|ifmedia
operator|.
name|ifm_media
argument_list|)
operator|!=
name|IFM_ETHER
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|epic_set_media_speed
argument_list|(
name|ifp
operator|->
name|if_softc
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|epic_ifmedia_status
name|__P
argument_list|(
operator|(
expr|struct
name|ifnet
operator|*
name|ifp
operator|,
expr|struct
name|ifmediareq
operator|*
name|ifmr
operator|)
argument_list|)
block|{
name|epic_softc_t
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|u_int32_t
name|bmcr
decl_stmt|;
name|u_int32_t
name|bmsr
decl_stmt|;
name|bmcr
operator|=
name|epic_read_phy_register
argument_list|(
name|sc
operator|->
name|iobase
argument_list|,
name|DP83840_BMCR
argument_list|)
expr_stmt|;
name|epic_read_phy_register
argument_list|(
name|sc
operator|->
name|iobase
argument_list|,
name|DP83840_BMSR
argument_list|)
expr_stmt|;
name|bmsr
operator|=
name|epic_read_phy_register
argument_list|(
name|sc
operator|->
name|iobase
argument_list|,
name|DP83840_BMSR
argument_list|)
expr_stmt|;
name|ifmr
operator|->
name|ifm_active
operator|=
name|IFM_ETHER
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|bmsr
operator|&
name|BMSR_LINK_STATUS
operator|)
condition|)
block|{
name|ifmr
operator|->
name|ifm_active
operator||=
name|bmcr
operator|&
name|BMCR_AUTONEGOTIATION
condition|?
name|IFM_AUTO
else|:
name|IFM_NONE
expr_stmt|;
return|return;
block|}
name|ifmr
operator|->
name|ifm_active
operator||=
name|bmcr
operator|&
name|BMCR_100MBPS
condition|?
name|IFM_100_TX
else|:
name|IFM_10_T
expr_stmt|;
name|ifmr
operator|->
name|ifm_active
operator||=
name|bmcr
operator|&
name|BMCR_FULL_DUPLEX
condition|?
name|IFM_FDX
else|:
literal|0
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|/*  * IFINIT function  *   * splimp() invoked here  */
end_comment

begin_function
specifier|static
name|int
name|epic_init
parameter_list|(
name|epic_softc_t
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
operator|&
name|sc
operator|->
name|epic_if
decl_stmt|;
name|int
name|iobase
init|=
name|sc
operator|->
name|iobase
decl_stmt|;
name|int
name|i
decl_stmt|,
name|s
decl_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
comment|/* Soft reset the chip */
name|outl
argument_list|(
name|iobase
operator|+
name|GENCTL
argument_list|,
name|GENCTL_SOFT_RESET
argument_list|)
expr_stmt|;
comment|/* Reset takes 15 pci ticks which depends on processor speed*/
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* Wake up */
name|outl
argument_list|(
name|iobase
operator|+
name|GENCTL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* ?????? */
name|outl
argument_list|(
name|iobase
operator|+
name|TEST1
argument_list|,
literal|0x0008
argument_list|)
expr_stmt|;
comment|/* Initialize rings */
if|if
condition|(
operator|-
literal|1
operator|==
name|epic_init_rings
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"tx%d: failed to initialize rings\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
name|epic_free_rings
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* Put node address to EPIC */
name|outl
argument_list|(
name|iobase
operator|+
name|LAN0
operator|+
literal|0x0
argument_list|,
operator|(
operator|(
name|u_int16_t
operator|*
operator|)
name|sc
operator|->
name|epic_macaddr
operator|)
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|outl
argument_list|(
name|iobase
operator|+
name|LAN0
operator|+
literal|0x4
argument_list|,
operator|(
operator|(
name|u_int16_t
operator|*
operator|)
name|sc
operator|->
name|epic_macaddr
operator|)
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|outl
argument_list|(
name|iobase
operator|+
name|LAN0
operator|+
literal|0x8
argument_list|,
operator|(
operator|(
name|u_int16_t
operator|*
operator|)
name|sc
operator|->
name|epic_macaddr
operator|)
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
comment|/* Set transmit threshold */
name|outl
argument_list|(
name|iobase
operator|+
name|ETXTHR
argument_list|,
literal|0x40
argument_list|)
expr_stmt|;
comment|/* Compute and set RXCON. */
name|epic_set_rx_mode
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Set media speed mode */
name|epic_set_media_speed
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Set multicast table */
name|epic_set_mc_table
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Enable interrupts by setting the interrupt mask. */
if|if
condition|(
name|QS6612_OUI
operator|==
name|sc
operator|->
name|phyid
condition|)
block|{
name|outl
argument_list|(
name|iobase
operator|+
name|INTMASK
argument_list|,
name|INTSTAT_RCC
operator||
name|INTSTAT_RQE
operator||
name|INTSTAT_OVW
operator||
name|INTSTAT_RXE
operator||
name|INTSTAT_TXC
operator||
name|INTSTAT_TCC
operator||
name|INTSTAT_TQE
operator||
name|INTSTAT_TXU
operator||
name|INTSTAT_CNT
operator||
name|INTSTAT_GP2
operator||
name|INTSTAT_FATAL
operator||
name|INTSTAT_PTA
operator||
name|INTSTAT_PMA
operator||
name|INTSTAT_APE
operator||
name|INTSTAT_DPE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|outl
argument_list|(
name|iobase
operator|+
name|INTMASK
argument_list|,
name|INTSTAT_RCC
operator||
name|INTSTAT_RQE
operator||
name|INTSTAT_OVW
operator||
name|INTSTAT_RXE
operator||
name|INTSTAT_TXC
operator||
name|INTSTAT_TCC
operator||
name|INTSTAT_TQE
operator||
name|INTSTAT_TXU
operator||
name|INTSTAT_CNT
operator||
name|INTSTAT_FATAL
operator||
name|INTSTAT_PTA
operator||
name|INTSTAT_PMA
operator||
name|INTSTAT_APE
operator||
name|INTSTAT_DPE
argument_list|)
expr_stmt|;
block|}
comment|/* Enable interrupts,  set for PCI read multiple and etc */
name|outl
argument_list|(
name|iobase
operator|+
name|GENCTL
argument_list|,
name|GENCTL_ENABLE_INTERRUPT
operator||
name|GENCTL_MEMORY_READ_MULTIPLE
operator||
name|GENCTL_ONECOPY
operator||
name|GENCTL_RECEIVE_FIFO_THRESHOLD64
argument_list|)
expr_stmt|;
comment|/* Start rx process */
name|outl
argument_list|(
name|iobase
operator|+
name|COMMAND
argument_list|,
name|COMMAND_RXQUEUED
operator||
name|COMMAND_START_RX
argument_list|)
expr_stmt|;
comment|/* Mark interface running ... */
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
condition|)
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_RUNNING
expr_stmt|;
else|else
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
name|IFF_RUNNING
expr_stmt|;
comment|/* ... and free */
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
name|IFF_OACTIVE
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * This function should set EPIC's registers according IFF_* flags  */
end_comment

begin_function
specifier|static
name|void
name|epic_set_rx_mode
parameter_list|(
name|epic_softc_t
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
operator|&
name|sc
operator|->
name|epic_if
decl_stmt|;
name|u_int16_t
name|rxcon
init|=
literal|0
decl_stmt|;
if|#
directive|if
name|NBPFILTER
operator|>
literal|0
if|if
condition|(
name|sc
operator|->
name|epic_if
operator|.
name|if_flags
operator|&
name|IFF_PROMISC
condition|)
name|rxcon
operator||=
name|RXCON_PROMISCUOUS_MODE
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|sc
operator|->
name|epic_if
operator|.
name|if_flags
operator|&
name|IFF_BROADCAST
condition|)
name|rxcon
operator||=
name|RXCON_RECEIVE_BROADCAST_FRAMES
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|epic_if
operator|.
name|if_flags
operator|&
name|IFF_MULTICAST
condition|)
name|rxcon
operator||=
name|RXCON_RECEIVE_MULTICAST_FRAMES
expr_stmt|;
name|outl
argument_list|(
name|sc
operator|->
name|iobase
operator|+
name|RXCON
argument_list|,
name|rxcon
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * This function should set MII to mode specified by IFF_LINK* flags  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|epic_set_media_speed
name|__P
argument_list|(
operator|(
name|epic_softc_t
operator|*
name|sc
operator|)
argument_list|)
block|{
name|u_int32_t
name|tgtmedia
init|=
name|sc
operator|->
name|ifmedia
operator|.
name|ifm_cur
operator|->
name|ifm_media
decl_stmt|;
name|u_int16_t
name|media
decl_stmt|;
name|u_int32_t
name|i
decl_stmt|;
comment|/* Reset PHY */
name|epic_write_phy_register
argument_list|(
name|sc
operator|->
name|iobase
argument_list|,
name|DP83840_BMCR
argument_list|,
name|BMCR_RESET
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|0x100000
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
operator|(
name|epic_read_phy_register
argument_list|(
name|sc
operator|->
name|iobase
argument_list|,
name|DP83840_BMCR
argument_list|)
operator|&
name|BMCR_RESET
operator|)
condition|)
break|break;
if|if
condition|(
name|epic_read_phy_register
argument_list|(
name|sc
operator|->
name|iobase
argument_list|,
name|DP83840_BMCR
argument_list|)
operator|&
name|BMCR_RESET
condition|)
name|printf
argument_list|(
literal|"tx%d: WARNING! cannot reset PHY\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
comment|/* Set media speed */
if|if
condition|(
name|IFM_SUBTYPE
argument_list|(
name|tgtmedia
argument_list|)
operator|!=
name|IFM_AUTO
condition|)
block|{
comment|/* Set mode */
name|media
operator|=
operator|(
name|IFM_SUBTYPE
argument_list|(
name|tgtmedia
argument_list|)
operator|==
name|IFM_100_TX
operator|)
condition|?
name|BMCR_100MBPS
else|:
literal|0
expr_stmt|;
name|media
operator||=
operator|(
operator|(
name|tgtmedia
operator|&
name|IFM_GMASK
operator|)
operator|==
name|IFM_FDX
operator|)
condition|?
name|BMCR_FULL_DUPLEX
else|:
literal|0
expr_stmt|;
name|sc
operator|->
name|epic_if
operator|.
name|if_baudrate
operator|=
operator|(
name|tgtmedia
operator|&
name|IFM_100_TX
operator|)
condition|?
literal|100000000
else|:
literal|10000000
expr_stmt|;
name|epic_write_phy_register
argument_list|(
name|sc
operator|->
name|iobase
argument_list|,
name|DP83840_BMCR
argument_list|,
name|media
argument_list|)
expr_stmt|;
name|outl
argument_list|(
name|sc
operator|->
name|iobase
operator|+
name|TXCON
argument_list|,
operator|(
name|tgtmedia
operator|&
name|IFM_FDX
operator|)
condition|?
name|TXCON_LOOPBACK_MODE_FULL_DUPLEX
operator||
name|TXCON_DEFAULT
else|:
name|TXCON_DEFAULT
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Init QS6612 to generate interrupt when AutoNeg complete */
if|if
condition|(
name|QS6612_OUI
operator|==
name|sc
operator|->
name|phyid
condition|)
block|{
name|outl
argument_list|(
name|sc
operator|->
name|iobase
operator|+
name|NVCTL
argument_list|,
name|NVCTL_GP1_OUTPUT_ENABLE
argument_list|)
expr_stmt|;
name|epic_read_phy_register
argument_list|(
name|sc
operator|->
name|iobase
argument_list|,
name|QS6612_INTSTAT
argument_list|)
expr_stmt|;
name|epic_write_phy_register
argument_list|(
name|sc
operator|->
name|iobase
argument_list|,
name|QS6612_INTMASK
argument_list|,
name|INTMASK_THUNDERLAN
operator||
name|INTSTAT_AN_COMPLETE
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|epic_if
operator|.
name|if_baudrate
operator|=
literal|100000000
expr_stmt|;
name|outl
argument_list|(
name|sc
operator|->
name|iobase
operator|+
name|TXCON
argument_list|,
name|TXCON_DEFAULT
argument_list|)
expr_stmt|;
comment|/* Set and restart autoneg */
name|epic_write_phy_register
argument_list|(
name|sc
operator|->
name|iobase
argument_list|,
name|DP83840_BMCR
argument_list|,
name|BMCR_AUTONEGOTIATION
operator||
name|BMCR_RESTART_AUTONEG
argument_list|)
expr_stmt|;
comment|/* If it is not QS6612 PHY, try to get result of autoneg. */
if|if
condition|(
name|QS6612_OUI
operator|!=
name|sc
operator|->
name|phyid
condition|)
block|{
comment|/* Wait 3 seconds for the autoneg to finish 			 * This is the recommended time from the DP83840A data 			 * sheet Section 7.1 			 */
name|DELAY
argument_list|(
literal|3000000
argument_list|)
expr_stmt|;
if|if
condition|(
name|epic_autoneg
argument_list|(
name|sc
argument_list|)
operator|==
name|EPIC_FULL_DUPLEX
condition|)
name|outl
argument_list|(
name|sc
operator|->
name|iobase
operator|+
name|TXCON
argument_list|,
name|TXCON_LOOPBACK_MODE_FULL_DUPLEX
operator||
name|TXCON_DEFAULT
argument_list|)
expr_stmt|;
block|}
comment|/* Else it will be done when GP2 int occured */
block|}
return|return;
block|}
end_decl_stmt

begin_comment
comment|/*  * This functions get results of the autoneg processes of the phy  * It implements the workaround that is described in section 7.2& 7.3 of the   * DP83840A data sheet  * http://www.national.com/ds/DP/DP83840A.pdf  */
end_comment

begin_function
specifier|static
name|int
name|epic_autoneg
parameter_list|(
name|epic_softc_t
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
operator|&
name|sc
operator|->
name|epic_if
decl_stmt|;
name|u_int16_t
name|media
decl_stmt|;
name|u_int16_t
name|i
decl_stmt|;
comment|/* BMSR must be read twice to update the link status bit 	 * since that bit is a latch bit          */
name|epic_read_phy_register
argument_list|(
name|sc
operator|->
name|iobase
argument_list|,
name|DP83840_BMSR
argument_list|)
expr_stmt|;
name|i
operator|=
name|epic_read_phy_register
argument_list|(
name|sc
operator|->
name|iobase
argument_list|,
name|DP83840_BMSR
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|&
name|BMSR_LINK_STATUS
operator|)
operator|&&
operator|(
name|i
operator|&
name|BMSR_AUTONEG_COMPLETE
operator|)
condition|)
block|{
name|i
operator|=
name|epic_read_phy_register
argument_list|(
name|sc
operator|->
name|iobase
argument_list|,
name|DP83840_LPAR
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|&
operator|(
name|ANAR_100_TX_FD
operator||
name|ANAR_10_FD
operator|)
condition|)
return|return
name|EPIC_FULL_DUPLEX
return|;
else|else
return|return
name|EPIC_HALF_DUPLEX
return|;
block|}
else|else
block|{
comment|/*Auto-negotiation or link status is not 1 		   Thus the auto-negotiation failed and one 		   must take other means to fix it. 		  */
comment|/* ANER must be read twice to get the correct reading for the  		 * Multiple link fault bit -- it is a latched bit 	 	 */
name|epic_read_phy_register
argument_list|(
name|sc
operator|->
name|iobase
argument_list|,
name|DP83840_ANER
argument_list|)
expr_stmt|;
name|i
operator|=
name|epic_read_phy_register
argument_list|(
name|sc
operator|->
name|iobase
argument_list|,
name|DP83840_ANER
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|&
name|ANER_MULTIPLE_LINK_FAULT
condition|)
block|{
comment|/* it can be forced to 100Mb/s Half-Duplex */
name|media
operator|=
name|epic_read_phy_register
argument_list|(
name|sc
operator|->
name|iobase
argument_list|,
name|DP83840_BMCR
argument_list|)
expr_stmt|;
name|media
operator|&=
operator|~
operator|(
name|BMCR_AUTONEGOTIATION
operator||
name|BMCR_FULL_DUPLEX
operator|)
expr_stmt|;
name|media
operator||=
name|BMCR_100MBPS
expr_stmt|;
name|epic_write_phy_register
argument_list|(
name|sc
operator|->
name|iobase
argument_list|,
name|DP83840_BMCR
argument_list|,
name|media
argument_list|)
expr_stmt|;
comment|/* read BMSR again to determine link status */
name|epic_read_phy_register
argument_list|(
name|sc
operator|->
name|iobase
argument_list|,
name|DP83840_BMSR
argument_list|)
expr_stmt|;
name|i
operator|=
name|epic_read_phy_register
argument_list|(
name|sc
operator|->
name|iobase
argument_list|,
name|DP83840_BMSR
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|&
name|BMSR_LINK_STATUS
condition|)
block|{
comment|/* port is linked to the non Auto-Negotiation 				 * 100Mbs partner. 			 	 */
return|return
name|EPIC_HALF_DUPLEX
return|;
block|}
else|else
block|{
name|media
operator|=
name|epic_read_phy_register
argument_list|(
name|sc
operator|->
name|iobase
argument_list|,
name|DP83840_BMCR
argument_list|)
expr_stmt|;
name|media
operator|&=
operator|~
operator|(
name|BMCR_AUTONEGOTIATION
operator||
name|BMCR_FULL_DUPLEX
operator||
name|BMCR_100MBPS
operator|)
expr_stmt|;
name|epic_write_phy_register
argument_list|(
name|sc
operator|->
name|iobase
argument_list|,
name|DP83840_BMCR
argument_list|,
name|media
argument_list|)
expr_stmt|;
name|epic_read_phy_register
argument_list|(
name|sc
operator|->
name|iobase
argument_list|,
name|DP83840_BMSR
argument_list|)
expr_stmt|;
name|i
operator|=
name|epic_read_phy_register
argument_list|(
name|sc
operator|->
name|iobase
argument_list|,
name|DP83840_BMSR
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|&
name|BMSR_LINK_STATUS
condition|)
block|{
comment|/*port is linked to the non 					 * Auto-Negotiation10Mbs partner 			 	 	 */
return|return
name|EPIC_HALF_DUPLEX
return|;
block|}
block|}
block|}
comment|/* If we get here we are most likely not connected 		 * so lets default it to half duplex 		 */
return|return
name|EPIC_HALF_DUPLEX
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * This function sets EPIC multicast table  */
end_comment

begin_function
specifier|static
name|void
name|epic_set_mc_table
parameter_list|(
name|epic_softc_t
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
operator|&
name|sc
operator|->
name|epic_if
decl_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_MULTICAST
condition|)
block|{
name|outl
argument_list|(
name|sc
operator|->
name|iobase
operator|+
name|MC0
argument_list|,
literal|0xFFFF
argument_list|)
expr_stmt|;
name|outl
argument_list|(
name|sc
operator|->
name|iobase
operator|+
name|MC1
argument_list|,
literal|0xFFFF
argument_list|)
expr_stmt|;
name|outl
argument_list|(
name|sc
operator|->
name|iobase
operator|+
name|MC2
argument_list|,
literal|0xFFFF
argument_list|)
expr_stmt|;
name|outl
argument_list|(
name|sc
operator|->
name|iobase
operator|+
name|MC3
argument_list|,
literal|0xFFFF
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|epic_shutdown
parameter_list|(
name|int
name|howto
parameter_list|,
name|void
modifier|*
name|sc
parameter_list|)
block|{
name|epic_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *  This function should completely stop rx and tx processes  *    *  splimp() invoked here  */
end_comment

begin_function
specifier|static
name|void
name|epic_stop
parameter_list|(
name|epic_softc_t
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|iobase
init|=
name|sc
operator|->
name|iobase
decl_stmt|;
name|int
name|i
decl_stmt|,
name|s
decl_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|sc
operator|->
name|epic_if
operator|.
name|if_timer
operator|=
literal|0
expr_stmt|;
comment|/* Disable interrupts, stop processes */
name|outl
argument_list|(
name|iobase
operator|+
name|INTMASK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|outl
argument_list|(
name|iobase
operator|+
name|GENCTL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|outl
argument_list|(
name|iobase
operator|+
name|COMMAND
argument_list|,
name|COMMAND_STOP_RX
operator||
name|COMMAND_STOP_RDMA
operator||
name|COMMAND_STOP_TDMA
argument_list|)
expr_stmt|;
comment|/* Wait RX and TX DMA to stop */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|0x100000
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|inl
argument_list|(
name|iobase
operator|+
name|INTSTAT
argument_list|)
operator|&
operator|(
name|INTSTAT_RXIDLE
operator||
name|INTSTAT_TXIDLE
operator|)
operator|)
operator|==
operator|(
name|INTSTAT_RXIDLE
operator||
name|INTSTAT_TXIDLE
operator|)
condition|)
break|break;
block|}
if|if
condition|(
operator|!
operator|(
name|inl
argument_list|(
name|iobase
operator|+
name|INTSTAT
argument_list|)
operator|&
name|INTSTAT_RXIDLE
operator|)
condition|)
name|printf
argument_list|(
literal|"tx%d: can't stop RX DMA\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|inl
argument_list|(
name|iobase
operator|+
name|INTSTAT
argument_list|)
operator|&
name|INTSTAT_TXIDLE
operator|)
condition|)
name|printf
argument_list|(
literal|"tx%d: can't stop TX DMA\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
comment|/* Reset chip and phy */
name|outl
argument_list|(
name|iobase
operator|+
name|GENCTL
argument_list|,
name|GENCTL_SOFT_RESET
argument_list|)
expr_stmt|;
comment|/* Need to wait for 15 pci ticks to pass before accessing again*/
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* Free memory allocated for rings */
name|epic_free_rings
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This function should free all allocated for rings memory.  * NB: The DMA processes must be stopped.  *  * splimp() assumed to be done  */
end_comment

begin_function
specifier|static
name|void
name|epic_free_rings
parameter_list|(
name|epic_softc_t
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|RX_RING_SIZE
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|epic_rx_buffer
modifier|*
name|buf
init|=
name|sc
operator|->
name|rx_buffer
operator|+
name|i
decl_stmt|;
name|struct
name|epic_rx_desc
modifier|*
name|desc
init|=
name|sc
operator|->
name|rx_desc
operator|+
name|i
decl_stmt|;
name|desc
operator|->
name|status
operator|=
literal|0
expr_stmt|;
name|desc
operator|->
name|buflength
operator|=
literal|0
expr_stmt|;
name|desc
operator|->
name|bufaddr
operator|=
literal|0
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|RX_TO_MBUF
argument_list|)
if|if
condition|(
name|buf
operator|->
name|mbuf
condition|)
name|m_freem
argument_list|(
name|buf
operator|->
name|mbuf
argument_list|)
expr_stmt|;
name|buf
operator|->
name|mbuf
operator|=
name|NULL
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|buf
operator|->
name|data
condition|)
name|free
argument_list|(
name|buf
operator|->
name|data
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|buf
operator|->
name|data
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TX_RING_SIZE
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|epic_tx_buffer
modifier|*
name|buf
init|=
name|sc
operator|->
name|tx_buffer
operator|+
name|i
decl_stmt|;
name|struct
name|epic_tx_desc
modifier|*
name|desc
init|=
name|sc
operator|->
name|tx_desc
operator|+
name|i
decl_stmt|;
name|desc
operator|->
name|status
operator|=
literal|0
expr_stmt|;
name|desc
operator|->
name|buflength
operator|=
literal|0
expr_stmt|;
name|desc
operator|->
name|bufaddr
operator|=
literal|0
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|TX_FRAG_LIST
argument_list|)
if|if
condition|(
name|buf
operator|->
name|mbuf
condition|)
name|m_freem
argument_list|(
name|buf
operator|->
name|mbuf
argument_list|)
expr_stmt|;
name|buf
operator|->
name|mbuf
operator|=
name|NULL
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|buf
operator|->
name|data
condition|)
name|free
argument_list|(
name|buf
operator|->
name|data
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|buf
operator|->
name|data
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
block|}
block|}
end_function

begin_comment
comment|/*  * Initialize Rx and Tx rings and give them to EPIC  *  * If RX_TO_MBUF option is enabled, mbuf cluster is allocated instead of  * static buffer for RX ringi element.  * If TX_FRAG_LIST option is enabled, nothig is done, except chaining  * descriptors to ring and point them to static fraglists.  *  * splimp() assumed to be done  */
end_comment

begin_function
specifier|static
name|int
name|epic_init_rings
parameter_list|(
name|epic_softc_t
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|sc
operator|->
name|cur_rx
operator|=
name|sc
operator|->
name|cur_tx
operator|=
name|sc
operator|->
name|dirty_tx
operator|=
name|sc
operator|->
name|pending_txs
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|RX_RING_SIZE
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|epic_rx_buffer
modifier|*
name|buf
init|=
name|sc
operator|->
name|rx_buffer
operator|+
name|i
decl_stmt|;
name|struct
name|epic_rx_desc
modifier|*
name|desc
init|=
name|sc
operator|->
name|rx_desc
operator|+
name|i
decl_stmt|;
name|desc
operator|->
name|status
operator|=
literal|0
expr_stmt|;
comment|/* Owned by driver */
name|desc
operator|->
name|next
operator|=
name|vtophys
argument_list|(
name|sc
operator|->
name|rx_desc
operator|+
operator|(
operator|(
name|i
operator|+
literal|1
operator|)
operator|%
name|RX_RING_SIZE
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|desc
operator|->
name|next
operator|&
literal|3
operator|)
operator|||
operator|(
operator|(
name|desc
operator|->
name|next
operator|&
literal|0xFFF
operator|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|epic_rx_desc
argument_list|)
operator|>
literal|0x1000
operator|)
condition|)
name|printf
argument_list|(
literal|"tx%d: WARNING! frag_list is misbound or misaligned\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|RX_TO_MBUF
argument_list|)
name|MGETHDR
argument_list|(
name|buf
operator|->
name|mbuf
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|buf
operator|->
name|mbuf
condition|)
return|return
operator|-
literal|1
return|;
name|MCLGET
argument_list|(
name|buf
operator|->
name|mbuf
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
operator|(
name|buf
operator|->
name|mbuf
operator|->
name|m_flags
operator|&
name|M_EXT
operator|)
condition|)
return|return
operator|-
literal|1
return|;
name|desc
operator|->
name|bufaddr
operator|=
name|vtophys
argument_list|(
name|mtod
argument_list|(
name|buf
operator|->
name|mbuf
argument_list|,
name|caddr_t
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|buf
operator|->
name|data
operator|=
name|malloc
argument_list|(
name|ETHER_MAX_FRAME_LEN
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|->
name|data
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
name|desc
operator|->
name|bufaddr
operator|=
name|vtophys
argument_list|(
name|buf
operator|->
name|data
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|desc
operator|->
name|buflength
operator|=
name|ETHER_MAX_FRAME_LEN
expr_stmt|;
name|desc
operator|->
name|status
operator|=
literal|0x8000
expr_stmt|;
comment|/* Give to EPIC */
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TX_RING_SIZE
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|epic_tx_buffer
modifier|*
name|buf
init|=
name|sc
operator|->
name|tx_buffer
operator|+
name|i
decl_stmt|;
name|struct
name|epic_tx_desc
modifier|*
name|desc
init|=
name|sc
operator|->
name|tx_desc
operator|+
name|i
decl_stmt|;
name|desc
operator|->
name|status
operator|=
literal|0
expr_stmt|;
name|desc
operator|->
name|next
operator|=
name|vtophys
argument_list|(
name|sc
operator|->
name|tx_desc
operator|+
operator|(
operator|(
name|i
operator|+
literal|1
operator|)
operator|%
name|TX_RING_SIZE
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|desc
operator|->
name|next
operator|&
literal|3
operator|)
operator|||
operator|(
operator|(
name|desc
operator|->
name|next
operator|&
literal|0xFFF
operator|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|epic_tx_desc
argument_list|)
operator|>
literal|0x1000
operator|)
condition|)
name|printf
argument_list|(
literal|"tx%d: WARNING! frag_list is misbound or misaligned\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|TX_FRAG_LIST
argument_list|)
name|buf
operator|->
name|mbuf
operator|=
name|NULL
expr_stmt|;
name|desc
operator|->
name|bufaddr
operator|=
name|vtophys
argument_list|(
name|sc
operator|->
name|tx_flist
operator|+
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|desc
operator|->
name|bufaddr
operator|&
literal|3
operator|)
operator|||
operator|(
operator|(
name|desc
operator|->
name|bufaddr
operator|&
literal|0xFFF
operator|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|epic_frag_list
argument_list|)
operator|>
literal|0x1000
operator|)
condition|)
name|printf
argument_list|(
literal|"tx%d: WARNING! frag_list is misbound or misaligned\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* Allocate buffer */
name|buf
operator|->
name|data
operator|=
name|malloc
argument_list|(
name|ETHER_MAX_FRAME_LEN
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|->
name|data
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
name|desc
operator|->
name|bufaddr
operator|=
name|vtophys
argument_list|(
name|buf
operator|->
name|data
argument_list|)
expr_stmt|;
name|desc
operator|->
name|buflength
operator|=
name|ETHER_MAX_FRAME_LEN
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* Give rings to EPIC */
name|outl
argument_list|(
name|sc
operator|->
name|iobase
operator|+
name|PRCDAR
argument_list|,
name|vtophys
argument_list|(
name|sc
operator|->
name|rx_desc
argument_list|)
argument_list|)
expr_stmt|;
name|outl
argument_list|(
name|sc
operator|->
name|iobase
operator|+
name|PTCDAR
argument_list|,
name|vtophys
argument_list|(
name|sc
operator|->
name|tx_desc
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * EEPROM operation functions  */
end_comment

begin_function
specifier|static
name|void
name|epic_write_eepromreg
parameter_list|(
name|u_int16_t
name|regaddr
parameter_list|,
name|u_int8_t
name|val
parameter_list|)
block|{
name|u_int16_t
name|i
decl_stmt|;
name|outb
argument_list|(
name|regaddr
argument_list|,
name|val
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|0xFF
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
operator|(
name|inb
argument_list|(
name|regaddr
argument_list|)
operator|&
literal|0x20
operator|)
condition|)
break|break;
return|return;
block|}
end_function

begin_function
specifier|static
name|u_int8_t
name|epic_read_eepromreg
parameter_list|(
name|u_int16_t
name|regaddr
parameter_list|)
block|{
return|return
name|inb
argument_list|(
name|regaddr
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|u_int8_t
name|epic_eeprom_clock
parameter_list|(
name|u_int16_t
name|ioaddr
parameter_list|,
name|u_int8_t
name|val
parameter_list|)
block|{
name|epic_write_eepromreg
argument_list|(
name|ioaddr
operator|+
name|EECTL
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|epic_write_eepromreg
argument_list|(
name|ioaddr
operator|+
name|EECTL
argument_list|,
operator|(
name|val
operator||
literal|0x4
operator|)
argument_list|)
expr_stmt|;
name|epic_write_eepromreg
argument_list|(
name|ioaddr
operator|+
name|EECTL
argument_list|,
name|val
argument_list|)
expr_stmt|;
return|return
name|epic_read_eepromreg
argument_list|(
name|ioaddr
operator|+
name|EECTL
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|epic_output_eepromw
parameter_list|(
name|u_int16_t
name|ioaddr
parameter_list|,
name|u_int16_t
name|val
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0xF
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
operator|(
name|val
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
operator|)
condition|)
name|epic_eeprom_clock
argument_list|(
name|ioaddr
argument_list|,
literal|0x0B
argument_list|)
expr_stmt|;
else|else
name|epic_eeprom_clock
argument_list|(
name|ioaddr
argument_list|,
literal|3
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|u_int16_t
name|epic_input_eepromw
parameter_list|(
name|u_int16_t
name|ioaddr
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|tmp
decl_stmt|;
name|u_int16_t
name|retval
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0xF
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|tmp
operator|=
name|epic_eeprom_clock
argument_list|(
name|ioaddr
argument_list|,
literal|0x3
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|&
literal|0x10
condition|)
block|{
name|retval
operator||=
operator|(
literal|1
operator|<<
name|i
operator|)
expr_stmt|;
block|}
block|}
return|return
name|retval
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|epic_read_eeprom
parameter_list|(
name|u_int16_t
name|ioaddr
parameter_list|,
name|u_int16_t
name|loc
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|u_int16_t
name|dataval
decl_stmt|;
name|u_int16_t
name|read_cmd
decl_stmt|;
name|epic_write_eepromreg
argument_list|(
name|ioaddr
operator|+
name|EECTL
argument_list|,
literal|3
argument_list|)
expr_stmt|;
if|if
condition|(
name|epic_read_eepromreg
argument_list|(
name|ioaddr
operator|+
name|EECTL
argument_list|)
operator|&
literal|0x40
condition|)
name|read_cmd
operator|=
operator|(
name|loc
operator|&
literal|0x3F
operator|)
operator||
literal|0x180
expr_stmt|;
else|else
name|read_cmd
operator|=
operator|(
name|loc
operator|&
literal|0xFF
operator|)
operator||
literal|0x600
expr_stmt|;
name|epic_output_eepromw
argument_list|(
name|ioaddr
argument_list|,
name|read_cmd
argument_list|)
expr_stmt|;
name|dataval
operator|=
name|epic_input_eepromw
argument_list|(
name|ioaddr
argument_list|)
expr_stmt|;
name|epic_write_eepromreg
argument_list|(
name|ioaddr
operator|+
name|EECTL
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
name|dataval
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|epic_read_phy_register
parameter_list|(
name|u_int16_t
name|iobase
parameter_list|,
name|u_int16_t
name|loc
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|outl
argument_list|(
name|iobase
operator|+
name|MIICTL
argument_list|,
operator|(
operator|(
name|loc
operator|<<
literal|4
operator|)
operator||
literal|0x0601
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|0x1000
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
operator|(
name|inl
argument_list|(
name|iobase
operator|+
name|MIICTL
argument_list|)
operator|&
literal|1
operator|)
condition|)
break|break;
return|return
name|inl
argument_list|(
name|iobase
operator|+
name|MIIDATA
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|epic_write_phy_register
parameter_list|(
name|u_int16_t
name|iobase
parameter_list|,
name|u_int16_t
name|loc
parameter_list|,
name|u_int16_t
name|val
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|outl
argument_list|(
name|iobase
operator|+
name|MIIDATA
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|outl
argument_list|(
name|iobase
operator|+
name|MIICTL
argument_list|,
operator|(
operator|(
name|loc
operator|<<
literal|4
operator|)
operator||
literal|0x0602
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|0x1000
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
operator|(
name|inl
argument_list|(
name|iobase
operator|+
name|MIICTL
argument_list|)
operator|&
literal|2
operator|)
condition|)
break|break;
return|return;
block|}
end_function

end_unit

