begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/************************************************************************** ** **  $Id: pci.c,v 1.57.2.5 1997/07/11 18:16:18 se Exp $ ** **  General subroutines for the PCI bus. **  pci_configure () ** **  FreeBSD ** **------------------------------------------------------------------------- ** ** Copyright (c) 1994 Wolfgang Stanglmeier.  All rights reserved. ** ** Redistribution and use in source and binary forms, with or without ** modification, are permitted provided that the following conditions ** are met: ** 1. Redistributions of source code must retain the above copyright **    notice, this list of conditions and the following disclaimer. ** 2. Redistributions in binary form must reproduce the above copyright **    notice, this list of conditions and the following disclaimer in the **    documentation and/or other materials provided with the distribution. ** 3. The name of the author may not be used to endorse or promote products **    derived from this software without specific prior written permission. ** ** THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR ** IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES ** OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. ** IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, ** INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT ** NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, ** DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY ** THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT ** (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF ** THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ** *************************************************************************** */
end_comment

begin_include
include|#
directive|include
file|"pci.h"
end_include

begin_if
if|#
directive|if
name|NPCI
operator|>
literal|0
end_if

begin_comment
comment|/*======================================================== ** **	#includes  and  declarations ** **======================================================== */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_comment
comment|/* declaration of wakeup(), used by vm.h */
end_comment

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|DEVFS
end_ifdef

begin_include
include|#
directive|include
file|<sys/devfsext.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DEVFS */
end_comment

begin_include
include|#
directive|include
file|<sys/fcntl.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_param.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/isa_device.h>
end_include

begin_comment
comment|/* XXX inthand2_t */
end_comment

begin_include
include|#
directive|include
file|<pci/pcivar.h>
end_include

begin_include
include|#
directive|include
file|<pci/pcireg.h>
end_include

begin_include
include|#
directive|include
file|<pci/pcibus.h>
end_include

begin_include
include|#
directive|include
file|<pci/pci_ioctl.h>
end_include

begin_define
define|#
directive|define
name|PCI_MAX_IRQ
value|(16)
end_define

begin_comment
comment|/*======================================================== ** **	Structs and Functions ** **======================================================== */
end_comment

begin_struct
struct|struct
name|pcicb
block|{
name|struct
name|pcicb
modifier|*
name|pcicb_next
decl_stmt|;
name|struct
name|pcicb
modifier|*
name|pcicb_up
decl_stmt|;
name|struct
name|pcicb
modifier|*
name|pcicb_down
decl_stmt|;
name|pcici_t
name|pcicb_bridge
decl_stmt|;
name|u_long
name|pcicb_seen
decl_stmt|;
name|u_char
name|pcicb_bus
decl_stmt|;
name|u_char
name|pcicb_subordinate
decl_stmt|;
name|u_char
name|pcicb_flags
decl_stmt|;
define|#
directive|define
name|PCICB_ISAMEM
value|0x01
name|u_int
name|pcicb_mfrom
decl_stmt|;
name|u_int
name|pcicb_mupto
decl_stmt|;
name|u_int
name|pcicb_mamount
decl_stmt|;
name|u_short
name|pcicb_pfrom
decl_stmt|;
name|u_short
name|pcicb_pupto
decl_stmt|;
name|u_short
name|pcicb_pamount
decl_stmt|;
name|u_char
name|pcicb_bfrom
decl_stmt|;
name|u_char
name|pcicb_bupto
decl_stmt|;
name|u_long
name|pcicb_iobase
decl_stmt|;
name|u_long
name|pcicb_iolimit
decl_stmt|;
name|u_long
name|pcicb_membase
decl_stmt|;
name|u_long
name|pcicb_memlimit
decl_stmt|;
name|u_long
name|pcicb_p_membase
decl_stmt|;
name|u_long
name|pcicb_p_memlimit
decl_stmt|;
block|}
struct|;
end_struct

begin_function_decl
specifier|static
name|void
name|not_supported
parameter_list|(
name|pcici_t
name|tag
parameter_list|,
name|u_long
name|type
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pci_bus_config
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pci_bridge_config
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pci_mfdev
parameter_list|(
name|int
name|bus
parameter_list|,
name|int
name|device
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pci_remember
parameter_list|(
name|int
name|bus
parameter_list|,
name|int
name|dev
parameter_list|,
name|int
name|func
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*======================================================== ** **	Variables ** **======================================================== */
end_comment

begin_comment
comment|/* **      log2 of safe burst len (in words) */
end_comment

begin_decl_stmt
name|unsigned
name|pci_max_burst_len
init|=
literal|3
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 2=16Byte, 3=32Byte, 4=64Byte, ... */
end_comment

begin_decl_stmt
name|unsigned
name|pci_mechanism
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|pci_maxdevice
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|pciroots
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* XXX pcisupport.c increments this  				 * for the Orion host to PCI bridge 				 * UGLY hack ... :( Will be changed :) 				 */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|pcibus
modifier|*
name|pcibus
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*-------------------------------------------------------- ** **	Local variables. ** **-------------------------------------------------------- */
end_comment

begin_decl_stmt
specifier|static
name|int
name|pci_conf_count
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|pci_info_done
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|pcibusmax
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|pcicb
modifier|*
name|pcicb
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*----------------------------------------------------------------- ** **	The following functions are provided for the device driver **	to read/write the configuration space. ** **	pci_conf_read(): **		Read a long word from the pci configuration space. **		Requires a tag (from pcitag) and the register **		number (should be a long word alligned one). ** **	pci_conf_write(): **		Writes a long word to the pci configuration space. **		Requires a tag (from pcitag), the register number **		(should be a long word alligned one), and a value. ** **----------------------------------------------------------------- */
end_comment

begin_function
name|u_long
name|pci_conf_read
parameter_list|(
name|pcici_t
name|tag
parameter_list|,
name|u_long
name|reg
parameter_list|)
block|{
return|return
operator|(
name|pcibus
operator|->
name|pb_read
argument_list|(
name|tag
argument_list|,
name|reg
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|void
name|pci_conf_write
parameter_list|(
name|pcici_t
name|tag
parameter_list|,
name|u_long
name|reg
parameter_list|,
name|u_long
name|data
parameter_list|)
block|{
name|pcibus
operator|->
name|pb_write
argument_list|(
name|tag
argument_list|,
name|reg
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*======================================================== ** **	Subroutines for configuration. ** **======================================================== */
end_comment

begin_function
specifier|static
name|void
name|pci_register_io
parameter_list|(
name|struct
name|pcicb
modifier|*
name|cb
parameter_list|,
name|u_int
name|base
parameter_list|,
name|u_int
name|limit
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|PCI_BRIDGE_DEBUG
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"register_io:  bus=%d base=%x limit=%x\n"
argument_list|,
name|cb
operator|->
name|pcicb_bus
argument_list|,
name|base
argument_list|,
name|limit
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|cb
operator|->
name|pcicb_pfrom
operator|||
name|base
operator|<
name|cb
operator|->
name|pcicb_pfrom
condition|)
name|cb
operator|->
name|pcicb_pfrom
operator|=
name|base
expr_stmt|;
if|if
condition|(
name|limit
operator|>
name|cb
operator|->
name|pcicb_pupto
condition|)
name|cb
operator|->
name|pcicb_pupto
operator|=
name|limit
expr_stmt|;
comment|/* 	**	XXX should set bridge io mapping here 	**	but it can be mapped in 4k blocks only, 	**	leading to conflicts with isa/eisa .. 	*/
block|}
end_function

begin_function
specifier|static
name|void
name|pci_register_memory
parameter_list|(
name|struct
name|pcicb
modifier|*
name|cb
parameter_list|,
name|u_int
name|base
parameter_list|,
name|u_int
name|limit
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|PCI_BRIDGE_DEBUG
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"register_mem: bus=%d base=%x limit=%x\n"
argument_list|,
name|cb
operator|->
name|pcicb_bus
argument_list|,
name|base
argument_list|,
name|limit
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|cb
operator|->
name|pcicb_mfrom
operator|||
name|base
operator|<
name|cb
operator|->
name|pcicb_mfrom
condition|)
name|cb
operator|->
name|pcicb_mfrom
operator|=
name|base
expr_stmt|;
if|if
condition|(
name|limit
operator|>
name|cb
operator|->
name|pcicb_mupto
condition|)
name|cb
operator|->
name|pcicb_mupto
operator|=
name|limit
expr_stmt|;
comment|/* 	**	set the bridges mapping 	** 	**	XXX should handle the 1Mb granularity. 	*/
if|if
condition|(
name|cb
operator|->
name|pcicb_bridge
operator|.
name|tag
condition|)
block|{
name|pci_conf_write
argument_list|(
name|cb
operator|->
name|pcicb_bridge
argument_list|,
name|PCI_PCI_BRIDGE_MEM_REG
argument_list|,
operator|(
name|cb
operator|->
name|pcicb_memlimit
operator|&
literal|0xffff0000
operator|)
operator||
operator|(
name|cb
operator|->
name|pcicb_membase
operator|>>
literal|16
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"\t[pci%d uses memory from %x to %x]\n"
argument_list|,
name|cb
operator|->
name|pcicb_bus
argument_list|,
operator|(
name|unsigned
operator|)
name|cb
operator|->
name|pcicb_membase
argument_list|,
operator|(
name|unsigned
operator|)
name|cb
operator|->
name|pcicb_memlimit
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* **	XXX This function is neither complete nor tested. **	It's only used if the bios hasn't done it's job **	of mapping the pci devices in the physical memory. */
end_comment

begin_function
specifier|static
name|u_int
name|pci_memalloc
parameter_list|(
name|struct
name|pcicb
modifier|*
name|cb
parameter_list|,
name|u_int
name|addr
parameter_list|,
name|u_int
name|size
parameter_list|)
block|{
name|u_int
name|result
init|=
literal|0
decl_stmt|,
name|limit
init|=
literal|0
decl_stmt|,
name|newbase
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|PCI_BRIDGE_DEBUG
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"memalloc:  bus=%d addr=%x size=%x ..\n"
argument_list|,
name|cb
operator|->
name|pcicb_bus
argument_list|,
name|addr
argument_list|,
name|size
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|cb
condition|)
goto|goto
name|done
goto|;
if|if
condition|(
operator|!
name|cb
operator|->
name|pcicb_membase
condition|)
block|{
name|printf
argument_list|(
literal|"memalloc: bus%d: membase not set.\n"
argument_list|,
name|cb
operator|->
name|pcicb_bus
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* 	**	get upper allocation limit 	*/
name|limit
operator|=
name|cb
operator|->
name|pcicb_memlimit
expr_stmt|;
if|if
condition|(
name|cb
operator|->
name|pcicb_mfrom
operator|&&
name|cb
operator|->
name|pcicb_mfrom
operator|<=
name|limit
condition|)
name|limit
operator|=
name|cb
operator|->
name|pcicb_mfrom
operator|-
literal|1
expr_stmt|;
comment|/* 	**	address fixed, and impossible to allocate ? 	*/
if|if
condition|(
name|addr
operator|&&
name|addr
operator|+
name|size
operator|-
literal|1
operator|>
name|limit
condition|)
goto|goto
name|done
goto|;
comment|/* 	**	get possible address 	*/
name|result
operator|=
name|addr
expr_stmt|;
if|if
condition|(
operator|!
name|result
condition|)
name|result
operator|=
operator|(
operator|(
name|limit
operator|+
literal|1
operator|)
operator|/
name|size
operator|-
literal|1
operator|)
operator|*
name|size
expr_stmt|;
comment|/* 	**	if not local available, request from parent. 	*/
if|if
condition|(
name|result
operator|<
name|cb
operator|->
name|pcicb_membase
condition|)
block|{
name|newbase
operator|=
name|pci_memalloc
argument_list|(
name|cb
operator|->
name|pcicb_up
argument_list|,
name|result
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|newbase
condition|)
name|cb
operator|->
name|pcicb_membase
operator|=
name|result
expr_stmt|;
else|else
name|result
operator|=
literal|0
expr_stmt|;
block|}
name|done
label|:
if|if
condition|(
name|result
condition|)
name|pci_register_memory
argument_list|(
name|cb
argument_list|,
name|result
argument_list|,
name|result
operator|+
name|size
operator|-
literal|1
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PCI_BRIDGE_DEBUG
name|printf
argument_list|(
literal|"memalloc:  bus=%d addr=%x size=%x --> %x (limit=%x).\n"
argument_list|,
name|cb
operator|->
name|pcicb_bus
argument_list|,
name|addr
argument_list|,
name|size
argument_list|,
name|result
argument_list|,
name|limit
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_comment
comment|/*======================================================== ** **	pci_bridge_config() ** **	Configuration of a pci bridge. ** **======================================================== */
end_comment

begin_function
specifier|static
name|int
name|pci_bridge_config
parameter_list|(
name|void
parameter_list|)
block|{
name|pcici_t
name|tag
decl_stmt|;
name|struct
name|pcicb
modifier|*
name|parent
decl_stmt|;
name|tag
operator|=
name|pcicb
operator|->
name|pcicb_bridge
expr_stmt|;
if|if
condition|(
name|tag
operator|.
name|tag
condition|)
block|{
if|if
condition|(
operator|!
name|pcicb
operator|->
name|pcicb_bus
condition|)
block|{
name|u_int
name|data
decl_stmt|;
comment|/* 		**	Get the lowest available bus number. 		*/
name|pcicb
operator|->
name|pcicb_bus
operator|=
operator|++
name|pcibusmax
expr_stmt|;
comment|/* 		**	and configure the bridge 		*/
name|data
operator|=
name|pci_conf_read
argument_list|(
name|tag
argument_list|,
name|PCI_PCI_BRIDGE_BUS_REG
argument_list|)
expr_stmt|;
name|data
operator|=
name|PCI_PRIMARY_BUS_INSERT
argument_list|(
name|data
argument_list|,
name|pcicb
operator|->
name|pcicb_up
operator|->
name|pcicb_bus
argument_list|)
expr_stmt|;
name|data
operator|=
name|PCI_SECONDARY_BUS_INSERT
argument_list|(
name|data
argument_list|,
name|pcicb
operator|->
name|pcicb_bus
argument_list|)
expr_stmt|;
name|data
operator|=
name|PCI_SUBORDINATE_BUS_INSERT
argument_list|(
name|data
argument_list|,
name|pcicb
operator|->
name|pcicb_bus
argument_list|)
expr_stmt|;
name|pci_conf_write
argument_list|(
name|tag
argument_list|,
name|PCI_PCI_BRIDGE_BUS_REG
argument_list|,
name|data
argument_list|)
expr_stmt|;
comment|/* 		**	Propagate the new upper bus number limit. 		*/
for|for
control|(
name|parent
operator|=
name|pcicb
operator|->
name|pcicb_up
init|;
name|parent
operator|!=
name|NULL
condition|;
name|parent
operator|=
name|parent
operator|->
name|pcicb_up
control|)
block|{
if|if
condition|(
name|parent
operator|->
name|pcicb_subordinate
operator|>=
name|pcicb
operator|->
name|pcicb_bus
condition|)
continue|continue;
name|parent
operator|->
name|pcicb_subordinate
operator|=
name|pcicb
operator|->
name|pcicb_bus
expr_stmt|;
if|if
condition|(
operator|!
name|parent
operator|->
name|pcicb_bridge
operator|.
name|tag
condition|)
continue|continue;
name|data
operator|=
name|pci_conf_read
argument_list|(
name|parent
operator|->
name|pcicb_bridge
argument_list|,
name|PCI_PCI_BRIDGE_BUS_REG
argument_list|)
expr_stmt|;
name|data
operator|=
name|PCI_SUBORDINATE_BUS_INSERT
argument_list|(
name|data
argument_list|,
name|pcicb
operator|->
name|pcicb_bus
argument_list|)
expr_stmt|;
name|pci_conf_write
argument_list|(
name|parent
operator|->
name|pcicb_bridge
argument_list|,
name|PCI_PCI_BRIDGE_BUS_REG
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|pcicb
operator|->
name|pcicb_membase
condition|)
block|{
name|u_int
name|size
init|=
literal|0x100000
decl_stmt|;
name|pcicb
operator|->
name|pcicb_membase
operator|=
name|pci_memalloc
argument_list|(
name|pcicb
operator|->
name|pcicb_up
argument_list|,
literal|0
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcicb
operator|->
name|pcicb_membase
condition|)
name|pcicb
operator|->
name|pcicb_memlimit
operator|=
name|pcicb
operator|->
name|pcicb_membase
operator|+
name|size
operator|-
literal|1
expr_stmt|;
block|}
block|}
return|return
name|pcicb
operator|->
name|pcicb_bus
return|;
block|}
end_function

begin_comment
comment|/*======================================================== ** **	pci_bus_config() ** **	Autoconfiguration of one pci bus. ** **======================================================== */
end_comment

begin_function
specifier|static
name|int
name|pci_mfdev
parameter_list|(
name|int
name|bus
parameter_list|,
name|int
name|device
parameter_list|)
block|{
name|pcici_t
name|tag0
decl_stmt|,
name|tag1
decl_stmt|;
name|unsigned
name|pci_id0
decl_stmt|,
name|pci_id1
decl_stmt|;
comment|/*     ** Detect a multi-function device that complies to the PCI 2.0 spec     */
name|tag0
operator|=
name|pcibus
operator|->
name|pb_tag
argument_list|(
name|bus
argument_list|,
name|device
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|pci_conf_read
argument_list|(
name|tag0
argument_list|,
name|PCI_HEADER_MISC
argument_list|)
operator|&
name|PCI_HEADER_MULTIFUNCTION
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|pci_bus_config
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|bus_no
decl_stmt|;
name|u_char
name|device
decl_stmt|;
name|u_char
name|reg
decl_stmt|;
name|pcici_t
name|tag
decl_stmt|,
name|mtag
decl_stmt|;
name|pcidi_t
name|type
decl_stmt|;
name|u_long
name|data
decl_stmt|;
name|int
name|unit
decl_stmt|;
name|u_char
name|pciint
decl_stmt|;
name|int
name|irq
decl_stmt|;
name|struct
name|pci_device
modifier|*
name|dvp
decl_stmt|;
comment|/* 	**	first initialize the bridge (bus controller chip) 	*/
name|bus_no
operator|=
name|pci_bridge_config
argument_list|()
expr_stmt|;
name|printf
argument_list|(
literal|"Probing for devices on PCI bus %d:\n"
argument_list|,
name|bus_no
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|PCI_QUIET
if|if
condition|(
name|bootverbose
operator|&&
operator|!
name|pci_info_done
condition|)
block|{
name|pci_info_done
operator|=
literal|1
expr_stmt|;
name|printf
argument_list|(
literal|"\tconfiguration mode %d allows %d devices.\n"
argument_list|,
name|pci_mechanism
argument_list|,
name|pci_maxdevice
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
endif|#
directive|endif
for|for
control|(
name|device
operator|=
literal|0
init|;
name|device
operator|<
name|pci_maxdevice
condition|;
name|device
operator|++
control|)
block|{
name|char
modifier|*
name|name
init|=
name|NULL
decl_stmt|;
name|struct
name|pci_device
modifier|*
modifier|*
name|dvpp
decl_stmt|;
name|int
name|func
decl_stmt|,
name|maxfunc
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|(
name|pcicb
operator|->
name|pcicb_seen
operator|>>
name|device
operator|)
operator|&
literal|1
condition|)
continue|continue;
for|for
control|(
name|func
operator|=
literal|0
init|;
name|func
operator|<=
name|maxfunc
condition|;
name|func
operator|++
control|)
block|{
name|tag
operator|=
name|pcibus
operator|->
name|pb_tag
argument_list|(
name|bus_no
argument_list|,
name|device
argument_list|,
name|func
argument_list|)
expr_stmt|;
name|type
operator|=
name|pci_conf_read
argument_list|(
name|tag
argument_list|,
name|PCI_ID_REG
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|!
name|type
operator|)
operator|||
operator|(
name|type
operator|==
literal|0xfffffffful
operator|)
condition|)
continue|continue;
comment|/* 		**	lookup device in ioconfiguration: 		*/
name|dvpp
operator|=
operator|(
expr|struct
name|pci_device
operator|*
operator|*
operator|)
name|pcidevice_set
operator|.
name|ls_items
expr_stmt|;
while|while
condition|(
name|dvp
operator|=
operator|*
name|dvpp
operator|++
condition|)
block|{
if|if
condition|(
name|dvp
operator|->
name|pd_probe
condition|)
block|{
if|if
condition|(
name|name
operator|=
call|(
modifier|*
name|dvp
operator|->
name|pd_probe
call|)
argument_list|(
name|tag
argument_list|,
name|type
argument_list|)
condition|)
break|break;
block|}
block|}
empty_stmt|;
comment|/* 		**	check for mirrored devices. 		*/
if|if
condition|(
name|func
operator|!=
literal|0
condition|)
block|{
goto|goto
name|real_device
goto|;
block|}
if|if
condition|(
name|device
operator|&
literal|0x10
condition|)
block|{
name|mtag
operator|=
name|pcibus
operator|->
name|pb_tag
argument_list|(
name|bus_no
argument_list|,
call|(
name|u_char
call|)
argument_list|(
name|device
operator|&
operator|~
literal|0x10
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|device
operator|&
literal|0x08
condition|)
block|{
name|mtag
operator|=
name|pcibus
operator|->
name|pb_tag
argument_list|(
name|bus_no
argument_list|,
call|(
name|u_char
call|)
argument_list|(
name|device
operator|&
operator|~
literal|0x08
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
goto|goto
name|real_device
goto|;
if|if
condition|(
name|type
operator|!=
name|pci_conf_read
argument_list|(
name|mtag
argument_list|,
name|PCI_ID_REG
argument_list|)
condition|)
goto|goto
name|real_device
goto|;
for|for
control|(
name|reg
operator|=
name|PCI_MAP_REG_START
init|;
name|reg
operator|<
name|PCI_MAP_REG_END
condition|;
name|reg
operator|+=
literal|4
control|)
if|if
condition|(
name|pci_conf_read
argument_list|(
name|tag
argument_list|,
name|reg
argument_list|)
operator|!=
name|pci_conf_read
argument_list|(
name|mtag
argument_list|,
name|reg
argument_list|)
condition|)
goto|goto
name|real_device
goto|;
ifndef|#
directive|ifndef
name|PCI_QUIET
if|if
condition|(
name|dvp
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"%s?<%s> mirrored on pci%d:%d\n"
argument_list|,
name|dvp
operator|->
name|pd_name
argument_list|,
name|name
argument_list|,
name|bus_no
argument_list|,
name|device
argument_list|)
expr_stmt|;
endif|#
directive|endif
continue|continue;
name|real_device
label|:
ifndef|#
directive|ifndef
name|PCI_QUIET
ifdef|#
directive|ifdef
name|PCI_BRIDGE_DEBUG
if|if
condition|(
name|bootverbose
condition|)
block|{
name|printf
argument_list|(
literal|"\tconfig header: 0x%08x 0x%08x 0x%08x 0x%08x\n"
argument_list|,
name|pci_conf_read
argument_list|(
name|tag
argument_list|,
literal|0
argument_list|)
argument_list|,
name|pci_conf_read
argument_list|(
name|tag
argument_list|,
literal|4
argument_list|)
argument_list|,
name|pci_conf_read
argument_list|(
name|tag
argument_list|,
literal|8
argument_list|)
argument_list|,
name|pci_conf_read
argument_list|(
name|tag
argument_list|,
literal|12
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
endif|#
directive|endif
if|if
condition|(
name|func
operator|==
literal|0
operator|&&
name|pci_mfdev
argument_list|(
name|bus_no
argument_list|,
name|device
argument_list|)
condition|)
block|{
name|maxfunc
operator|=
literal|7
expr_stmt|;
block|}
name|pci_remember
argument_list|(
name|bus_no
argument_list|,
name|device
argument_list|,
name|func
argument_list|)
expr_stmt|;
if|if
condition|(
name|dvp
operator|==
name|NULL
condition|)
block|{
ifndef|#
directive|ifndef
name|PCI_QUIET
if|if
condition|(
name|pci_conf_count
condition|)
continue|continue;
if|if
condition|(
name|maxfunc
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"%s%d:%d:    "
argument_list|,
name|pcibus
operator|->
name|pb_name
argument_list|,
name|bus_no
argument_list|,
name|device
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"%s%d:%d:%d: "
argument_list|,
name|pcibus
operator|->
name|pb_name
argument_list|,
name|bus_no
argument_list|,
name|device
argument_list|,
name|func
argument_list|)
expr_stmt|;
name|not_supported
argument_list|(
name|tag
argument_list|,
name|type
argument_list|)
expr_stmt|;
endif|#
directive|endif
continue|continue;
block|}
empty_stmt|;
name|pcicb
operator|->
name|pcicb_seen
operator||=
operator|(
literal|1ul
operator|<<
name|device
operator|)
expr_stmt|;
comment|/* 		**	Get and increment the unit. 		*/
name|unit
operator|=
operator|(
operator|*
name|dvp
operator|->
name|pd_count
operator|)
operator|++
expr_stmt|;
comment|/* 		**	ignore device ? 		*/
if|if
condition|(
operator|!
operator|*
name|name
condition|)
continue|continue;
comment|/* 		**	Announce this device 		*/
name|printf
argument_list|(
literal|"%s%d<%s> rev %d"
argument_list|,
name|dvp
operator|->
name|pd_name
argument_list|,
name|unit
argument_list|,
name|name
argument_list|,
operator|(
name|unsigned
operator|)
name|pci_conf_read
argument_list|(
name|tag
argument_list|,
name|PCI_CLASS_REG
argument_list|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
comment|/* 		**	Get the int pin number (pci interrupt number a-d) 		**	from the pci configuration space. 		*/
name|data
operator|=
name|pci_conf_read
argument_list|(
name|tag
argument_list|,
name|PCI_INTERRUPT_REG
argument_list|)
expr_stmt|;
name|pciint
operator|=
name|PCI_INTERRUPT_PIN_EXTRACT
argument_list|(
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|pciint
condition|)
block|{
name|printf
argument_list|(
literal|" int %c irq "
argument_list|,
literal|0x60
operator|+
name|pciint
argument_list|)
expr_stmt|;
name|irq
operator|=
name|PCI_INTERRUPT_LINE_EXTRACT
argument_list|(
name|data
argument_list|)
expr_stmt|;
comment|/* 			**	If it's zero, the isa irq number is unknown, 			**	and we cannot bind the pci interrupt. 			*/
if|if
condition|(
name|irq
operator|&&
operator|(
name|irq
operator|!=
literal|0xff
operator|)
condition|)
name|printf
argument_list|(
literal|"%d"
argument_list|,
name|irq
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"??"
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
if|if
condition|(
name|maxfunc
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|" on pci%d:%d\n"
argument_list|,
name|bus_no
argument_list|,
name|device
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|" on pci%d:%d:%d\n"
argument_list|,
name|bus_no
argument_list|,
name|device
argument_list|,
name|func
argument_list|)
expr_stmt|;
comment|/* 		**	Read the current mapping, 		**	and update the pcicb fields. 		*/
for|for
control|(
name|reg
operator|=
name|PCI_MAP_REG_START
init|;
name|reg
operator|<
name|PCI_MAP_REG_END
condition|;
name|reg
operator|+=
literal|4
control|)
block|{
name|u_int
name|map
decl_stmt|,
name|addr
decl_stmt|,
name|size
decl_stmt|;
name|data
operator|=
name|pci_conf_read
argument_list|(
name|tag
argument_list|,
name|PCI_CLASS_REG
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|data
operator|&
operator|(
name|PCI_CLASS_MASK
operator||
name|PCI_SUBCLASS_MASK
operator|)
condition|)
block|{
case|case
name|PCI_CLASS_BRIDGE
operator||
name|PCI_SUBCLASS_BRIDGE_PCI
case|:
continue|continue;
block|}
empty_stmt|;
name|map
operator|=
name|pci_conf_read
argument_list|(
name|tag
argument_list|,
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|map
operator|&
name|PCI_MAP_MEMORY_ADDRESS_MASK
operator|)
condition|)
continue|continue;
name|pci_conf_write
argument_list|(
name|tag
argument_list|,
name|reg
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
name|data
operator|=
name|pci_conf_read
argument_list|(
name|tag
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|pci_conf_write
argument_list|(
name|tag
argument_list|,
name|reg
argument_list|,
name|map
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|data
operator|&
literal|7
condition|)
block|{
default|default:
continue|continue;
case|case
literal|1
case|:
case|case
literal|5
case|:
name|addr
operator|=
name|map
operator|&
name|PCI_MAP_IO_ADDRESS_MASK
expr_stmt|;
name|size
operator|=
operator|-
operator|(
name|data
operator|&
name|PCI_MAP_IO_ADDRESS_MASK
operator|)
expr_stmt|;
name|size
operator|&=
operator|~
operator|(
name|addr
operator|^
operator|-
name|addr
operator|)
expr_stmt|;
name|pci_register_io
argument_list|(
name|pcicb
argument_list|,
name|addr
argument_list|,
name|addr
operator|+
name|size
operator|-
literal|1
argument_list|)
expr_stmt|;
name|pcicb
operator|->
name|pcicb_pamount
operator|+=
name|size
expr_stmt|;
break|break;
case|case
literal|0
case|:
case|case
literal|2
case|:
case|case
literal|4
case|:
name|size
operator|=
operator|-
operator|(
name|data
operator|&
name|PCI_MAP_MEMORY_ADDRESS_MASK
operator|)
expr_stmt|;
name|addr
operator|=
name|map
operator|&
name|PCI_MAP_MEMORY_ADDRESS_MASK
expr_stmt|;
if|if
condition|(
name|addr
operator|>=
literal|0x100000
condition|)
block|{
name|pci_register_memory
argument_list|(
name|pcicb
argument_list|,
name|addr
argument_list|,
name|addr
operator|+
name|size
operator|-
literal|1
argument_list|)
expr_stmt|;
name|pcicb
operator|->
name|pcicb_mamount
operator|+=
name|size
expr_stmt|;
block|}
else|else
block|{
name|pcicb
operator|->
name|pcicb_flags
operator||=
name|PCICB_ISAMEM
expr_stmt|;
block|}
empty_stmt|;
break|break;
block|}
empty_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"\tmapreg[%02x] type=%d addr=%08x size=%04x.\n"
argument_list|,
name|reg
argument_list|,
name|map
operator|&
literal|7
argument_list|,
name|addr
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
comment|/* 		**	attach device 		**	may produce additional log messages, 		**	i.e. when installing subdevices. 		*/
call|(
modifier|*
name|dvp
operator|->
name|pd_attach
call|)
argument_list|(
name|tag
argument_list|,
name|unit
argument_list|)
expr_stmt|;
comment|/* 		**	Special processing of certain classes 		*/
name|data
operator|=
name|pci_conf_read
argument_list|(
name|tag
argument_list|,
name|PCI_CLASS_REG
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|data
operator|&
operator|(
name|PCI_CLASS_MASK
operator||
name|PCI_SUBCLASS_MASK
operator|)
condition|)
block|{
name|struct
name|pcicb
modifier|*
name|this
decl_stmt|,
modifier|*
modifier|*
name|link
decl_stmt|;
name|unsigned
name|char
name|primary
decl_stmt|,
name|secondary
decl_stmt|,
name|subordinate
decl_stmt|;
name|u_int
name|command
decl_stmt|;
case|case
name|PCI_CLASS_BRIDGE
operator||
name|PCI_SUBCLASS_BRIDGE_PCI
case|:
comment|/* 			**	get current configuration of the bridge. 			*/
name|data
operator|=
name|pci_conf_read
argument_list|(
name|tag
argument_list|,
name|PCI_PCI_BRIDGE_BUS_REG
argument_list|)
expr_stmt|;
name|primary
operator|=
name|PCI_PRIMARY_BUS_EXTRACT
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|secondary
operator|=
name|PCI_SECONDARY_BUS_EXTRACT
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|subordinate
operator|=
name|PCI_SUBORDINATE_BUS_EXTRACT
argument_list|(
name|data
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|PCI_QUIET
if|if
condition|(
name|bootverbose
condition|)
block|{
name|printf
argument_list|(
literal|"\tbridge from pci%d to pci%d through %d.\n"
argument_list|,
name|primary
argument_list|,
name|secondary
argument_list|,
name|subordinate
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\tmapping regs: io:%08lx mem:%08lx pmem:%08lx\n"
argument_list|,
name|pci_conf_read
argument_list|(
name|tag
argument_list|,
name|PCI_PCI_BRIDGE_IO_REG
argument_list|)
argument_list|,
name|pci_conf_read
argument_list|(
name|tag
argument_list|,
name|PCI_PCI_BRIDGE_MEM_REG
argument_list|)
argument_list|,
name|pci_conf_read
argument_list|(
name|tag
argument_list|,
name|PCI_PCI_BRIDGE_PMEM_REG
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* 			**	check for uninitialized bridge. 			*/
if|if
condition|(
operator|!
operator|(
name|primary
operator|<
name|secondary
operator|&&
name|secondary
operator|<=
name|subordinate
operator|&&
name|bus_no
operator|==
name|primary
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"\tINCORRECTLY or NEVER CONFIGURED.\n"
argument_list|)
expr_stmt|;
comment|/* 				**	disable this bridge 				*/
name|pci_conf_write
argument_list|(
name|tag
argument_list|,
name|PCI_COMMAND_STATUS_REG
argument_list|,
literal|0xffff0000
argument_list|)
expr_stmt|;
name|secondary
operator|=
literal|0
expr_stmt|;
name|subordinate
operator|=
literal|0
expr_stmt|;
block|}
empty_stmt|;
comment|/* 			**  allocate bus descriptor for bus behind the bridge 			*/
name|link
operator|=
operator|&
name|pcicb
operator|->
name|pcicb_down
expr_stmt|;
while|while
condition|(
operator|*
name|link
operator|&&
operator|(
operator|*
name|link
operator|)
operator|->
name|pcicb_bus
operator|<
name|secondary
condition|)
name|link
operator|=
operator|&
operator|(
operator|*
name|link
operator|)
operator|->
name|pcicb_next
expr_stmt|;
name|this
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|this
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
comment|/* 			**	Initialize this descriptor so far. 			**	(the initialization is completed just before 			**	scanning the bus behind the bridge. 			*/
name|bzero
argument_list|(
name|this
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|this
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|->
name|pcicb_next
operator|=
operator|*
name|link
expr_stmt|;
name|this
operator|->
name|pcicb_up
operator|=
name|pcicb
expr_stmt|;
name|this
operator|->
name|pcicb_bridge
operator|=
name|tag
expr_stmt|;
name|this
operator|->
name|pcicb_bus
operator|=
name|secondary
expr_stmt|;
name|this
operator|->
name|pcicb_subordinate
operator|=
name|subordinate
expr_stmt|;
name|command
operator|=
name|pci_conf_read
argument_list|(
name|tag
argument_list|,
name|PCI_COMMAND_STATUS_REG
argument_list|)
expr_stmt|;
if|if
condition|(
name|command
operator|&
name|PCI_COMMAND_IO_ENABLE
condition|)
block|{
comment|/* 				**	Bridge was configured by the bios. 				**	Read out the mapped io region. 				*/
name|unsigned
name|reg
decl_stmt|;
name|reg
operator|=
name|pci_conf_read
argument_list|(
name|tag
argument_list|,
name|PCI_PCI_BRIDGE_IO_REG
argument_list|)
expr_stmt|;
name|this
operator|->
name|pcicb_iobase
operator|=
name|PCI_PPB_IOBASE_EXTRACT
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|this
operator|->
name|pcicb_iolimit
operator|=
name|PCI_PPB_IOLIMIT_EXTRACT
argument_list|(
name|reg
argument_list|)
expr_stmt|;
comment|/* 				**	Note the used io space. 				*/
name|pci_register_io
argument_list|(
name|pcicb
argument_list|,
name|this
operator|->
name|pcicb_iobase
argument_list|,
name|this
operator|->
name|pcicb_iolimit
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
if|if
condition|(
name|command
operator|&
name|PCI_COMMAND_MEM_ENABLE
condition|)
block|{
comment|/* 				**	Bridge was configured by the bios. 				**	Read out the mapped memory regions. 				*/
name|unsigned
name|reg
decl_stmt|;
comment|/* 				**	non prefetchable memory 				*/
name|reg
operator|=
name|pci_conf_read
argument_list|(
name|tag
argument_list|,
name|PCI_PCI_BRIDGE_MEM_REG
argument_list|)
expr_stmt|;
name|this
operator|->
name|pcicb_membase
operator|=
name|PCI_PPB_MEMBASE_EXTRACT
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|this
operator|->
name|pcicb_memlimit
operator|=
name|PCI_PPB_MEMLIMIT_EXTRACT
argument_list|(
name|reg
argument_list|)
expr_stmt|;
comment|/* 				**	Register used memory space. 				*/
name|pci_register_memory
argument_list|(
name|pcicb
argument_list|,
name|this
operator|->
name|pcicb_membase
argument_list|,
name|this
operator|->
name|pcicb_memlimit
argument_list|)
expr_stmt|;
comment|/* 				**	prefetchable memory 				*/
name|reg
operator|=
name|pci_conf_read
argument_list|(
name|tag
argument_list|,
name|PCI_PCI_BRIDGE_PMEM_REG
argument_list|)
expr_stmt|;
name|this
operator|->
name|pcicb_p_membase
operator|=
name|PCI_PPB_MEMBASE_EXTRACT
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|this
operator|->
name|pcicb_p_memlimit
operator|=
name|PCI_PPB_MEMLIMIT_EXTRACT
argument_list|(
name|reg
argument_list|)
expr_stmt|;
comment|/* 				**	Register used memory space. 				*/
name|pci_register_memory
argument_list|(
name|pcicb
argument_list|,
name|this
operator|->
name|pcicb_p_membase
argument_list|,
name|this
operator|->
name|pcicb_p_memlimit
argument_list|)
expr_stmt|;
block|}
comment|/* 			**	Link it in chain. 			*/
operator|*
name|link
operator|=
name|this
expr_stmt|;
comment|/* 			**	Update mapping info of parent bus. 			*/
if|if
condition|(
operator|!
name|pcicb
operator|->
name|pcicb_bfrom
operator|||
name|secondary
operator|<
name|pcicb
operator|->
name|pcicb_bfrom
condition|)
name|pcicb
operator|->
name|pcicb_bfrom
operator|=
name|secondary
expr_stmt|;
if|if
condition|(
name|subordinate
operator|>
name|pcicb
operator|->
name|pcicb_bupto
condition|)
name|pcicb
operator|->
name|pcicb_bupto
operator|=
name|subordinate
expr_stmt|;
break|break;
block|}
block|}
block|}
ifndef|#
directive|ifndef
name|PCI_QUIET
if|if
condition|(
name|bootverbose
condition|)
block|{
if|if
condition|(
name|pcicb
operator|->
name|pcicb_mamount
condition|)
name|printf
argument_list|(
literal|"%s%d: uses %d bytes of memory from %x upto %x.\n"
argument_list|,
name|pcibus
operator|->
name|pb_name
argument_list|,
name|bus_no
argument_list|,
name|pcicb
operator|->
name|pcicb_mamount
argument_list|,
name|pcicb
operator|->
name|pcicb_mfrom
argument_list|,
name|pcicb
operator|->
name|pcicb_mupto
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcicb
operator|->
name|pcicb_pamount
condition|)
name|printf
argument_list|(
literal|"%s%d: uses %d bytes of I/O space from %x upto %x.\n"
argument_list|,
name|pcibus
operator|->
name|pb_name
argument_list|,
name|bus_no
argument_list|,
name|pcicb
operator|->
name|pcicb_pamount
argument_list|,
name|pcicb
operator|->
name|pcicb_pfrom
argument_list|,
name|pcicb
operator|->
name|pcicb_pupto
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcicb
operator|->
name|pcicb_bfrom
condition|)
name|printf
argument_list|(
literal|"%s%d: subordinate busses from %x upto %x.\n"
argument_list|,
name|pcibus
operator|->
name|pb_name
argument_list|,
name|bus_no
argument_list|,
name|pcicb
operator|->
name|pcicb_bfrom
argument_list|,
name|pcicb
operator|->
name|pcicb_bupto
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*======================================================== ** **	pci_configure () ** **      Autoconfiguration of pci devices. ** **      May be called more than once. **      Any device is attached only once. ** **      Has to take care of mirrored devices, which are **      entailed by incomplete decoding of pci address lines. ** **======================================================== */
end_comment

begin_function
name|void
name|pci_configure
parameter_list|()
block|{
name|struct
name|pcibus
modifier|*
modifier|*
name|pbp
init|=
operator|(
expr|struct
name|pcibus
operator|*
operator|*
operator|)
name|pcibus_set
operator|.
name|ls_items
decl_stmt|;
comment|/* 	**	check pci bus present 	*/
while|while
condition|(
operator|!
name|pci_maxdevice
operator|&&
operator|(
name|pcibus
operator|=
operator|*
name|pbp
operator|++
operator|)
condition|)
block|{
call|(
modifier|*
name|pcibus
operator|->
name|pb_setup
call|)
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|pci_maxdevice
condition|)
return|return;
comment|/* 	**	hello world .. 	*/
name|pciroots
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|pciroots
operator|--
condition|)
block|{
name|pcicb
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|pcicb
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcicb
operator|==
name|NULL
condition|)
block|{
return|return;
block|}
name|bzero
argument_list|(
name|pcicb
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|pcicb
argument_list|)
argument_list|)
expr_stmt|;
name|pcicb
operator|->
name|pcicb_bus
operator|=
name|pcibusmax
expr_stmt|;
name|pcicb
operator|->
name|pcicb_iolimit
operator|=
literal|0xffff
expr_stmt|;
name|pcicb
operator|->
name|pcicb_membase
operator|=
literal|0x02000000
expr_stmt|;
name|pcicb
operator|->
name|pcicb_p_membase
operator|=
literal|0x02000000
expr_stmt|;
name|pcicb
operator|->
name|pcicb_memlimit
operator|=
literal|0xffffffff
expr_stmt|;
name|pcicb
operator|->
name|pcicb_p_memlimit
operator|=
literal|0xffffffff
expr_stmt|;
while|while
condition|(
name|pcicb
operator|!=
name|NULL
condition|)
block|{
name|pci_bus_config
argument_list|()
expr_stmt|;
if|if
condition|(
name|pcibusmax
operator|<
name|pcicb
operator|->
name|pcicb_bus
condition|)
operator|(
name|pcibusmax
operator|=
name|pcicb
operator|->
name|pcicb_bus
operator|)
expr_stmt|;
if|if
condition|(
name|pcicb
operator|->
name|pcicb_down
condition|)
block|{
name|pcicb
operator|=
name|pcicb
operator|->
name|pcicb_down
expr_stmt|;
continue|continue;
block|}
empty_stmt|;
while|while
condition|(
name|pcicb
operator|&&
operator|!
name|pcicb
operator|->
name|pcicb_next
condition|)
name|pcicb
operator|=
name|pcicb
operator|->
name|pcicb_up
expr_stmt|;
if|if
condition|(
name|pcicb
condition|)
name|pcicb
operator|=
name|pcicb
operator|->
name|pcicb_next
expr_stmt|;
block|}
name|pcibusmax
operator|++
expr_stmt|;
block|}
name|pci_conf_count
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/*----------------------------------------------------------------------- ** **	Map device into port space. ** **	Actually the device should have been mapped by the bios. **	This function only reads and verifies the value. ** **	PCI-Specification:  6.2.5.1: address maps ** **----------------------------------------------------------------------- */
end_comment

begin_function
name|int
name|pci_map_port
parameter_list|(
name|pcici_t
name|tag
parameter_list|,
name|u_long
name|reg
parameter_list|,
name|u_short
modifier|*
name|pa
parameter_list|)
block|{
name|unsigned
name|data
decl_stmt|,
name|ioaddr
decl_stmt|,
name|iosize
decl_stmt|;
name|struct
name|pcicb
modifier|*
name|link
init|=
name|pcicb
decl_stmt|;
comment|/* 	**	sanity check 	*/
if|if
condition|(
name|reg
operator|<
name|PCI_MAP_REG_START
operator|||
name|reg
operator|>=
name|PCI_MAP_REG_END
operator|||
operator|(
name|reg
operator|&
literal|3
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"pci_map_port failed: bad register=0x%x\n"
argument_list|,
operator|(
name|unsigned
operator|)
name|reg
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
empty_stmt|;
comment|/*if (pcicb->pcicb_flags& PCICB_NOIOSET) { 		printf ("pci_map_port failed: pci%d has not been configured for I/O access\n", 			pcicb->pcicb_bus); 		return (0); 	}*/
comment|/* 	**	get size and type of port 	** 	**	type is in the lowest two bits. 	**	If device requires 2^n bytes, the next 	**	n-2 bits are hardwired as 0. 	*/
name|ioaddr
operator|=
name|pci_conf_read
argument_list|(
name|tag
argument_list|,
name|reg
argument_list|)
operator|&
name|PCI_MAP_IO_ADDRESS_MASK
expr_stmt|;
if|if
condition|(
operator|!
name|ioaddr
condition|)
block|{
name|printf
argument_list|(
literal|"pci_map_port failed: not configured by bios.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
empty_stmt|;
name|pci_conf_write
argument_list|(
name|tag
argument_list|,
name|reg
argument_list|,
literal|0xfffffffful
argument_list|)
expr_stmt|;
name|data
operator|=
name|pci_conf_read
argument_list|(
name|tag
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|pci_conf_write
argument_list|(
name|tag
argument_list|,
name|reg
argument_list|,
name|ioaddr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|data
operator|&
literal|0x03
operator|)
operator|!=
name|PCI_MAP_IO
condition|)
block|{
name|printf
argument_list|(
literal|"pci_map_port failed: bad port type=0x%x\n"
argument_list|,
operator|(
name|unsigned
operator|)
name|data
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
empty_stmt|;
name|iosize
operator|=
operator|-
operator|(
name|data
operator|&
name|PCI_MAP_IO_ADDRESS_MASK
operator|)
expr_stmt|;
name|iosize
operator|&=
operator|~
operator|(
name|ioaddr
operator|^
operator|-
name|ioaddr
operator|)
expr_stmt|;
if|if
condition|(
name|ioaddr
operator|<
name|pcicb
operator|->
name|pcicb_iobase
operator|||
name|ioaddr
operator|+
name|iosize
operator|-
literal|1
operator|>
name|pcicb
operator|->
name|pcicb_iolimit
condition|)
block|{
name|printf
argument_list|(
literal|"pci_map_port failed: device's iorange 0x%x-0x%x "
literal|"is incompatible with its bridge's range 0x%x-0x%x\n"
argument_list|,
operator|(
name|unsigned
operator|)
name|ioaddr
argument_list|,
operator|(
name|unsigned
operator|)
name|ioaddr
operator|+
name|iosize
operator|-
literal|1
argument_list|,
operator|(
name|unsigned
operator|)
name|pcicb
operator|->
name|pcicb_iobase
argument_list|,
operator|(
name|unsigned
operator|)
name|pcicb
operator|->
name|pcicb_iolimit
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
ifndef|#
directive|ifndef
name|PCI_QUIET
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"\treg%d: ioaddr=0x%x size=0x%x\n"
argument_list|,
operator|(
name|unsigned
operator|)
name|reg
argument_list|,
operator|(
name|unsigned
operator|)
name|ioaddr
argument_list|,
operator|(
name|unsigned
operator|)
name|iosize
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	**	set the configuration register of and 	**      return the address to the driver. 	**	Make sure to enable each upstream bridge 	**	so I/O and DMA can go all the way. 	*/
for|for
control|(
init|;
condition|;
control|)
block|{
name|data
operator|=
name|pci_conf_read
argument_list|(
name|tag
argument_list|,
name|PCI_COMMAND_STATUS_REG
argument_list|)
operator|&
literal|0xffff
expr_stmt|;
name|data
operator||=
name|PCI_COMMAND_IO_ENABLE
operator||
name|PCI_COMMAND_MASTER_ENABLE
expr_stmt|;
operator|(
name|void
operator|)
name|pci_conf_write
argument_list|(
name|tag
argument_list|,
name|PCI_COMMAND_STATUS_REG
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|link
operator|=
name|link
operator|->
name|pcicb_up
operator|)
operator|==
name|NULL
condition|)
break|break;
name|tag
operator|=
name|link
operator|->
name|pcicb_bridge
expr_stmt|;
block|}
operator|*
name|pa
operator|=
name|ioaddr
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*----------------------------------------------------------------------- ** **	Map device into virtual and physical space ** **	Actually the device should have been mapped by the bios. **	This function only reads and verifies the value. ** **      PCI-Specification:  6.2.5.1: address maps ** **----------------------------------------------------------------------- */
end_comment

begin_function
name|int
name|pci_map_mem
parameter_list|(
name|pcici_t
name|tag
parameter_list|,
name|u_long
name|reg
parameter_list|,
name|vm_offset_t
modifier|*
name|va
parameter_list|,
name|vm_offset_t
modifier|*
name|pa
parameter_list|)
block|{
name|struct
name|pcicb
modifier|*
name|link
init|=
name|pcicb
decl_stmt|;
name|unsigned
name|data
decl_stmt|,
name|paddr
decl_stmt|;
ifndef|#
directive|ifndef
name|DPTOPT
name|vm_size_t
name|psize
decl_stmt|,
name|poffs
decl_stmt|;
else|#
directive|else
name|vm_size_t
name|psize
decl_stmt|,
name|poffs
decl_stmt|,
name|pend
decl_stmt|;
endif|#
directive|endif
comment|/* DPTOPT */
name|vm_offset_t
name|vaddr
decl_stmt|;
comment|/* 	**	sanity check 	*/
if|if
condition|(
name|reg
operator|<
name|PCI_MAP_REG_START
operator|||
name|reg
operator|>=
name|PCI_MAP_REG_END
operator|||
operator|(
name|reg
operator|&
literal|3
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"pci_map_mem failed: bad register=0x%x\n"
argument_list|,
operator|(
name|unsigned
operator|)
name|reg
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
empty_stmt|;
comment|/* 	**	save old mapping, get size and type of memory 	** 	**	type is in the lowest four bits. 	**	If device requires 2^n bytes, the next 	**	n-4 bits are read as 0. 	*/
name|paddr
operator|=
name|pci_conf_read
argument_list|(
name|tag
argument_list|,
name|reg
argument_list|)
operator|&
name|PCI_MAP_MEMORY_ADDRESS_MASK
expr_stmt|;
name|pci_conf_write
argument_list|(
name|tag
argument_list|,
name|reg
argument_list|,
literal|0xfffffffful
argument_list|)
expr_stmt|;
name|data
operator|=
name|pci_conf_read
argument_list|(
name|tag
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|pci_conf_write
argument_list|(
name|tag
argument_list|,
name|reg
argument_list|,
name|paddr
argument_list|)
expr_stmt|;
comment|/* 	**	check the type 	*/
if|if
condition|(
operator|!
operator|(
operator|(
name|data
operator|&
name|PCI_MAP_MEMORY_TYPE_MASK
operator|)
operator|==
name|PCI_MAP_MEMORY_TYPE_32BIT_1M
operator|&&
operator|(
name|paddr
operator|&
operator|~
literal|0xfffff
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|data
operator|&
name|PCI_MAP_MEMORY_TYPE_MASK
operator|)
operator|!=
name|PCI_MAP_MEMORY_TYPE_32BIT
condition|)
block|{
name|printf
argument_list|(
literal|"pci_map_mem failed: bad memory type=0x%x\n"
argument_list|,
operator|(
name|unsigned
operator|)
name|data
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
empty_stmt|;
comment|/* 	**	get the size. 	*/
name|psize
operator|=
operator|-
operator|(
name|data
operator|&
name|PCI_MAP_MEMORY_ADDRESS_MASK
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DPTOPT
name|pend
operator|=
name|paddr
operator|+
name|psize
operator|-
literal|1
expr_stmt|;
endif|#
directive|endif
comment|/* DPTOPT */
if|if
condition|(
operator|!
name|paddr
operator|||
name|paddr
operator|==
name|PCI_MAP_MEMORY_ADDRESS_MASK
condition|)
block|{
name|paddr
operator|=
name|pci_memalloc
argument_list|(
name|pcicb
argument_list|,
literal|0
argument_list|,
name|psize
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|paddr
condition|)
block|{
name|printf
argument_list|(
literal|"pci_map_mem: not configured by bios.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
empty_stmt|;
ifndef|#
directive|ifndef
name|DPTOPT
name|pci_register_memory
argument_list|(
name|pcicb
argument_list|,
name|paddr
argument_list|,
name|paddr
operator|+
name|psize
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
if|if
condition|(
name|paddr
operator|<
name|pcicb
operator|->
name|pcicb_membase
operator|||
name|paddr
operator|+
name|psize
operator|-
literal|1
operator|>
name|pcicb
operator|->
name|pcicb_memlimit
condition|)
block|{
name|printf
argument_list|(
literal|"pci_map_mem failed: device's memrange 0x%x-0x%x is "
literal|"incompatible with its bridge's memrange 0x%x-0x%x\n"
argument_list|,
argument|(unsigned) paddr
argument_list|,
argument|(unsigned) (paddr + psize -
literal|1
argument|)
argument_list|,
else|#
directive|else
argument|pci_register_memory (pcicb, paddr, pend); 	};  	if (!((pcicb->pcicb_membase<= paddr&& 	       pend<= pcicb->pcicb_memlimit) ||  	      (pcicb->pcicb_p_membase<= paddr&& 	       pend<= pcicb->pcicb_p_memlimit))) { 		printf (
literal|"pci_map_mem failed: device's memrange 0x%x-0x%x is "
literal|"incompatible with its bridge's\n"
literal|"\tmemrange 0x%x-0x%x and prefetchable memrange 0x%x-0x%x\n"
argument|, 			(unsigned) paddr, 			(unsigned) (paddr + psize -
literal|1
argument|), 			(unsigned) pcicb->pcicb_p_membase, 			(unsigned) pcicb->pcicb_p_memlimit,
endif|#
directive|endif
comment|/* DPTOPT */
argument|(unsigned) pcicb->pcicb_membase, 			(unsigned) pcicb->pcicb_memlimit);
comment|/*		return (0);*/
comment|/* ACHTUNG: Ist der Code richtig, wenn eine PCI-PCI-Bridge fuer  * die PCI-Slots verwendet wird, aber die Onboard-Devices direkt   * an der CPU-PCI-Bridge haengen (Siehe Compaq Prolinea Problem) ???  */
argument|} 	pci_conf_write (tag, reg, paddr);
comment|/* 	**	Truncate paddr to page boundary. 	**	(Or does pmap_mapdev the job?) 	*/
argument|poffs = paddr - trunc_page (paddr); 	vaddr = (vm_offset_t) pmap_mapdev (paddr-poffs, psize+poffs);  	if (!vaddr) return (
literal|0
argument|);  	vaddr += poffs;
ifndef|#
directive|ifndef
name|PCI_QUIET
comment|/* 	**	display values. 	*/
argument|if (bootverbose) 		printf (
literal|"\treg%d: virtual=0x%lx physical=0x%lx size=0x%lx\n"
argument|, 		 (unsigned) reg, (u_long)vaddr, (u_long)paddr, (u_long)psize);
endif|#
directive|endif
comment|/* 	**      set the configuration register and 	**      return the address to the driver 	**      Make sure to enable each upstream bridge 	**      so memory and DMA can go all the way. 	*/
argument|for (;;) { 		data =  pci_conf_read (tag, PCI_COMMAND_STATUS_REG)&
literal|0xffff
argument|; 		data |= PCI_COMMAND_MEM_ENABLE | PCI_COMMAND_MASTER_ENABLE; 		(void)  pci_conf_write(tag, PCI_COMMAND_STATUS_REG, data); 		if ((link = link->pcicb_up) == NULL) 			break; 		tag = link->pcicb_bridge; 	}  	*va = vaddr; 	*pa = paddr;  	return (
literal|1
argument|); }
comment|/*----------------------------------------------------------------------- ** **	Pci meta interrupt handler ** **	This handler assumes level triggered interrupts. **	It's possible to build a kernel which handles shared **	edge triggered interrupts by the options "PCI_EDGE_INT". **	But there is a performance penalty. ** **	(Of course you can delete the #ifdef PCI_EDGE_INT bracketed **	code at all :-) :-) :-) ** **----------------------------------------------------------------------- */
argument|static struct pci_int_desc* 	pci_int_desc [PCI_MAX_IRQ];
ifndef|#
directive|ifndef
name|NO_SHARED_IRQ
argument|static inline unsigned splq (unsigned mask) { 	unsigned temp=cpl; 	cpl |= mask; 	return temp; }  static void pci_int (int irq) { 	struct pci_int_desc * p; 	int s;  	if (irq<
literal|0
argument||| irq>= PCI_MAX_IRQ) { 		printf (
literal|"pci_int: irq %d out of range, ignored\n"
argument|, irq); 		return; 	}; 	for (p = pci_int_desc[irq]; p!=NULL; p=p->pcid_next) { 		s = splq (*p->pcid_maskptr); 		(*p->pcid_handler) (p->pcid_argument); 		p-> pcid_tally++; 		splx (s);
if|#
directive|if
literal|0
argument|if (p->pcid_tally<20) 			printf ("PCI_INT: irq=%d h=%p cpl o=%x n=%x val=%d\n", 				irq, p->pcid_handler, s, cpl, c);
endif|#
directive|endif
argument|}; }
endif|#
directive|endif
comment|/*----------------------------------------------------------------------- ** **	Auxiliary function for interrupt (un)mapping. ** **----------------------------------------------------------------------- */
argument|static u_int getirq (pcici_t tag) { 	u_int irq;  	irq = PCI_INTERRUPT_LINE_EXTRACT( 		pci_conf_read (tag, PCI_INTERRUPT_REG));  	if (irq ==
literal|0
argument||| irq ==
literal|0xff
argument|) { 		printf (
literal|"\tint line register not set by bios\n"
argument|); 		return (
literal|0xff
argument|); 	}  	if (irq>= PCI_MAX_IRQ) { 		printf (
literal|"\tirq %d out of bounds (must be< %d).\n"
argument|,  			irq, PCI_MAX_IRQ); 		return (
literal|0xff
argument|); 	}  	return (irq); }  static struct pci_int_desc ** getintdescbytag (u_int irq, pcici_t tag) { 	struct pci_int_desc *p
argument_list|,
argument|**pp;  	pp=&pci_int_desc[irq]; 	while (((p=*pp))&& !sametag(p->pcid_tag,tag)) 		pp=&p->pcid_next;  	if (!p) return (NULL);  	return (pp); }  static struct pci_int_desc * getintdescbymptr (u_int irq, unsigned * mptr) { 	struct pci_int_desc *p;  	for (p=pci_int_desc[irq];p;p=p->pcid_next) 		if (p->pcid_maskptr == mptr) break; 	return (p); }
comment|/*----------------------------------------------------------------------- ** **	Map pci interrupt. ** **----------------------------------------------------------------------- */
argument|static unsigned pci_mask0 =
literal|0
argument|;  int pci_map_int (pcici_t tag, pci_inthand_t *func, void *arg, unsigned *maskptr) { 	u_int irq; 	int result
argument_list|,
argument|oldspl; 	unsigned  mask; 	struct pci_int_desc *tail
argument_list|,
argument|*mdp=NULL
argument_list|,
argument|*new=NULL;
comment|/* 	**	Get irq line from configuration space, 	**	and check for consistency. 	*/
argument|irq = getirq (tag); 	if (irq ==
literal|0xff
argument|) { 		return (
literal|0
argument|); 	}; 	mask=
literal|1ul
argument|<< irq;
comment|/* 	**      disable this interrupt. 	*/
argument|oldspl = splq (mask);
comment|/* 	**	If handler for this tag already installed, 	**	remove it first. 	*/
argument|if (getintdescbytag (irq, tag) != NULL) 		pci_unmap_int (tag);
comment|/* 	**	If this irq not yet included in the mask, include it. 	*/
argument|mdp = getintdescbymptr (irq, maskptr); 	if (!mdp) { 		result = pcibus->pb_imaskinc (irq, maskptr); 		if (result) 			goto conflict; 	};
comment|/* 	**	Allocate descriptor and initialize it. 	*/
argument|tail = pci_int_desc[irq];  	new = malloc (sizeof (*new), M_DEVBUF, M_WAITOK); 	bzero (new, sizeof (*new));  	new->pcid_next	   = tail; 	new->pcid_tag      = tag; 	new->pcid_handler  = func; 	new->pcid_argument = arg; 	new->pcid_maskptr  = maskptr; 	new->pcid_tally    =
literal|0
argument|; 	new->pcid_mask	   = mask;
comment|/* 	**	If first handler:   install it. 	**	If second handler: install shared-int-handler. 	*/
argument|if (!tail) {
comment|/* 		**	first handler for this irq. 		*/
argument|result = pcibus->pb_iattach
comment|/* 			 * XXX if we get here, then `func' must be pci_int 			 * so the bogus casts are almost OK since they just 			 * undo the bogus casts that were needed to pass 			 * pci_int and its arg to pci_map_int(). 			 */
argument|(irq, (inthand2_t *) func, (int) arg, maskptr); 		if (result) goto conflict;
ifdef|#
directive|ifdef
name|NO_SHARED_IRQ
argument|} else goto conflict;
else|#
directive|else
argument|} else if (!tail->pcid_next) {
comment|/* 		**	Second handler for this irq. 		*/
argument|if (bootverbose) 			printf (
literal|"\tusing shared irq %d.\n"
argument|, irq);
comment|/* 		**	replace old handler by shared-int-handler. 		*/
argument|result = pcibus->pb_idetach (irq, 					     (inthand2_t *) tail->pcid_handler); 		if (result) 			printf (
literal|"\tCANNOT DETACH INT HANDLER.\n"
argument|);  		result = pcibus->pb_iattach (irq, pci_int, irq,&pci_mask0); 		if (result) { 			printf (
literal|"\tCANNOT ATTACH SHARED INT HANDLER.\n"
argument|); 			goto fail; 		}; 	}
endif|#
directive|endif
comment|/* 	**	Link new descriptor, reenable ints and done. 	*/
argument|pci_int_desc[irq]  = new; 	splx (oldspl); 	return (
literal|1
argument|);
comment|/* 	**	Handle some problems. 	*/
argument|conflict: 	printf (
literal|"\tirq %d already in use.\n"
argument|, irq); fail:
comment|/* 	**	If descriptor allocated, free it. 	**	If included in mask, remove it. 	*/
argument|if (new) free(new, M_DEVBUF); 	if (!mdp) (void) pcibus->pb_imaskexc (irq, maskptr); 	splx (oldspl); 	return (
literal|0
argument|); }
comment|/*----------------------------------------------------------------------- ** **	Unmap pci interrupt. ** **----------------------------------------------------------------------- */
argument|int pci_unmap_int (pcici_t tag) { 	int result
argument_list|,
argument|oldspl; 	struct pci_int_desc *this
argument_list|,
argument|**hook
argument_list|,
argument|*tail; 	u_int irq;
comment|/* 	**	Get irq line from configuration space, 	**	and check for consistency. 	*/
argument|irq = getirq (tag); 	if (irq ==
literal|0xff
argument|) { 		return (
literal|0
argument|); 	};
comment|/* 	**	Search and unlink interrupt descriptor. 	*/
argument|hook = getintdescbytag (irq, tag); 	if (hook == NULL) { 		printf (
literal|"\tno irq %d handler for pci %x\n"
argument|, 			irq, tag.tag); 		return (
literal|0
argument|); 	};  	this = *hook; 	*hook= this->pcid_next;
comment|/* 	**	Message 	*/
argument|printf (
literal|"\tirq %d handler %p(%p) unmapped for pci %x after %d ints.\n"
argument|, 		irq, this->pcid_handler, this->pcid_argument, 		this->pcid_tag.tag, this->pcid_tally);
comment|/* 	**	If this irq no longer included in the mask, remove it. 	*/
argument|if (!getintdescbymptr (irq, this->pcid_maskptr)) 		(void) pcibus->pb_imaskexc (irq, this->pcid_maskptr);  	tail = pci_int_desc[irq];  	if (tail == NULL) {
comment|/* 		**	Remove the old handler. 		*/
argument|result = pcibus->pb_idetach (irq, 					     (inthand2_t *) this->pcid_handler); 		if (result) 			printf (
literal|"\tirq %d: cannot remove handler.\n"
argument|, irq);  	} else if (tail->pcid_next == NULL) {
comment|/* 		**	Remove the shared int handler. 		**	Install the last remaining handler. 		*/
argument|oldspl = splq (
literal|1ul
argument|<< irq);  		result = pcibus->pb_idetach (irq, pci_int); 		if (result) 			printf (
literal|"\tirq %d: cannot remove handler.\n"
argument|, irq);  		result = pcibus->pb_iattach (irq, 				(inthand2_t *) tail->pcid_handler, 				(int) tail->pcid_argument, 				tail->pcid_maskptr);  		if (result) 			printf (
literal|"\tirq %d: cannot install handler.\n"
argument|, irq);  		splx (oldspl); 	};  	free (this, M_DEVBUF); 	return (
literal|1
argument|); }
comment|/*----------------------------------------------------------- ** **	Display of unknown devices. ** **----------------------------------------------------------- */
argument|struct vt { 	u_short	ident; 	char*	name; };  static struct vt VendorTable[] = { 	{
literal|0x0e11
argument_list|,
literal|"Compaq"
argument|}
argument_list|,
argument|{
literal|0x1000
argument_list|,
literal|"NCR/Symbios"
argument|}
argument_list|,
argument|{
literal|0x1002
argument_list|,
literal|"ATI Technologies Inc."
argument|}
argument_list|,
argument|{
literal|0x1004
argument_list|,
literal|"VLSI"
argument|}
argument_list|,
argument|{
literal|0x100B
argument_list|,
literal|"National Semiconductor"
argument|}
argument_list|,
argument|{
literal|0x100E
argument_list|,
literal|"Weitek"
argument|}
argument_list|,
argument|{
literal|0x1011
argument_list|,
literal|"Digital Equipment Corporation"
argument|}
argument_list|,
argument|{
literal|0x1013
argument_list|,
literal|"Cirrus Logic"
argument|}
argument_list|,
argument|{
literal|0x101A
argument_list|,
literal|"NCR"
argument|}
argument_list|,
argument|{
literal|0x1022
argument_list|,
literal|"AMD"
argument|}
argument_list|,
argument|{
literal|0x102B
argument_list|,
literal|"Matrox"
argument|}
argument_list|,
argument|{
literal|0x102C
argument_list|,
literal|"Chips& Technologies"
argument|}
argument_list|,
argument|{
literal|0x1039
argument_list|,
literal|"Silicon Integrated Systems"
argument|}
argument_list|,
argument|{
literal|0x1042
argument_list|,
literal|"SMC"
argument|}
argument_list|,
argument|{
literal|0x1044
argument_list|,
literal|"DPT"
argument|}
argument_list|,
argument|{
literal|0x1045
argument_list|,
literal|"OPTI"
argument|}
argument_list|,
argument|{
literal|0x104B
argument_list|,
literal|"Bus Logic"
argument|}
argument_list|,
argument|{
literal|0x1060
argument_list|,
literal|"UMC"
argument|}
argument_list|,
argument|{
literal|0x1080
argument_list|,
literal|"Contaq"
argument|}
argument_list|,
argument|{
literal|0x1095
argument_list|,
literal|"CMD"
argument|}
argument_list|,
argument|{
literal|0x10b9
argument_list|,
literal|"ACER Labs"
argument|}
argument_list|,
argument|{
literal|0x1106
argument_list|,
literal|"VIA Technologies"
argument|}
argument_list|,
argument|{
literal|0x5333
argument_list|,
literal|"S3 Inc."
argument|}
argument_list|,
argument|{
literal|0x8086
argument_list|,
literal|"Intel Corporation"
argument|}
argument_list|,
argument|{
literal|0x9004
argument_list|,
literal|"Adaptec"
argument|}
argument_list|,
argument|{
literal|0
argument_list|,
literal|0
argument|} };  typedef struct { 	const int	subclass; 	const char	*name; } subclass_name;
comment|/* 0x00 prehistoric subclasses */
argument|static const subclass_name old_subclasses[] = { 	{
literal|0x00
argument_list|,
literal|"misc"
argument|}
argument_list|,
argument|{
literal|0x01
argument_list|,
literal|"vga"
argument|}
argument_list|,
argument|{
literal|0x00
argument_list|,
argument|NULL	} };
comment|/* 0x01 mass storage subclasses */
argument|static const subclass_name storage_subclasses[] = { 	{
literal|0x00
argument_list|,
literal|"scsi"
argument|}
argument_list|,
argument|{
literal|0x01
argument_list|,
literal|"ide"
argument|}
argument_list|,
argument|{
literal|0x02
argument_list|,
literal|"floppy"
argument|}
argument_list|,
argument|{
literal|0x03
argument_list|,
literal|"ipi"
argument|}
argument_list|,
argument|{
literal|0x80
argument_list|,
literal|"misc"
argument|}
argument_list|,
argument|{
literal|0x00
argument_list|,
argument|NULL	} };
comment|/* 0x02 network subclasses */
argument|static const subclass_name network_subclasses[] = { 	{
literal|0x00
argument_list|,
literal|"ethernet"
argument|}
argument_list|,
argument|{
literal|0x01
argument_list|,
literal|"tokenring"
argument|}
argument_list|,
argument|{
literal|0x02
argument_list|,
literal|"fddi"
argument|}
argument_list|,
argument|{
literal|0x80
argument_list|,
literal|"misc"
argument|}
argument_list|,
argument|{
literal|0x00
argument_list|,
argument|NULL	} };
comment|/* 0x03 display subclasses */
argument|static const subclass_name display_subclasses[] = { 	{
literal|0x00
argument_list|,
literal|"vga"
argument|}
argument_list|,
argument|{
literal|0x01
argument_list|,
literal|"xga"
argument|}
argument_list|,
argument|{
literal|0x80
argument_list|,
literal|"misc"
argument|}
argument_list|,
argument|{
literal|0x00
argument_list|,
argument|NULL	} };
comment|/* 0x04 multimedia subclasses */
argument|static const subclass_name multimedia_subclasses[] = { 	{
literal|0x00
argument_list|,
literal|"video"
argument|}
argument_list|,
argument|{
literal|0x01
argument_list|,
literal|"audio"
argument|}
argument_list|,
argument|{
literal|0x80
argument_list|,
literal|"misc"
argument|}
argument_list|,
argument|{
literal|0x00
argument_list|,
argument|NULL	} };
comment|/* 0x05 memory subclasses */
argument|static const subclass_name memory_subclasses[] = { 	{
literal|0x00
argument_list|,
literal|"ram"
argument|}
argument_list|,
argument|{
literal|0x01
argument_list|,
literal|"flash"
argument|}
argument_list|,
argument|{
literal|0x80
argument_list|,
literal|"misc"
argument|}
argument_list|,
argument|{
literal|0x00
argument_list|,
argument|NULL	} };
comment|/* 0x06 bridge subclasses */
argument|static const subclass_name bridge_subclasses[] = { 	{
literal|0x00
argument_list|,
literal|"host"
argument|}
argument_list|,
argument|{
literal|0x01
argument_list|,
literal|"isa"
argument|}
argument_list|,
argument|{
literal|0x02
argument_list|,
literal|"eisa"
argument|}
argument_list|,
argument|{
literal|0x03
argument_list|,
literal|"mc"
argument|}
argument_list|,
argument|{
literal|0x04
argument_list|,
literal|"pci"
argument|}
argument_list|,
argument|{
literal|0x05
argument_list|,
literal|"pcmcia"
argument|}
argument_list|,
argument|{
literal|0x80
argument_list|,
literal|"misc"
argument|}
argument_list|,
argument|{
literal|0x00
argument_list|,
argument|NULL	} };  static const subclass_name *const subclasses[] = { 	old_subclasses
argument_list|,
argument|storage_subclasses
argument_list|,
argument|network_subclasses
argument_list|,
argument|display_subclasses
argument_list|,
argument|multimedia_subclasses
argument_list|,
argument|memory_subclasses
argument_list|,
argument|bridge_subclasses
argument_list|,
argument|};  static const char *const majclasses[] = {
literal|"old"
argument_list|,
literal|"storage"
argument_list|,
literal|"network"
argument_list|,
literal|"display"
argument_list|,
literal|"multimedia"
argument_list|,
literal|"memory"
argument_list|,
literal|"bridge"
argument|};   void not_supported (pcici_t tag, u_long type) { 	u_long	reg; 	u_long	data; 	u_char	class; 	u_char	subclass; 	struct vt * vp; 	int	pciint; 	int	irq;
comment|/* 	**	lookup the names. 	*/
argument|for (vp=VendorTable; vp->ident; vp++) 		if (vp->ident == (type&
literal|0xffff
argument|)) 			break;
comment|/* 	**	and display them. 	*/
argument|if (vp->ident) printf (vp->name); 		else   printf (
literal|"vendor=0x%04lx"
argument|, type&
literal|0xffff
argument|);  	printf (
literal|", device=0x%04lx"
argument|, type>>
literal|16
argument|);  	data = pci_conf_read(tag, PCI_CLASS_REG); 	class = (data>>
literal|24
argument|)&
literal|0xff
argument|; 	subclass = (data>>
literal|16
argument|)&
literal|0xff
argument|;  	if (class< sizeof(majclasses) / sizeof(majclasses[
literal|0
argument|])) { 		printf(
literal|", class=%s"
argument|, majclasses[class]); 	} else { 		printf(
literal|", class=0x%02x"
argument|, class); 	}  	if (class< sizeof(subclasses) / sizeof(subclasses[
literal|0
argument|])) { 		const subclass_name *p = subclasses[class]; 		while (p->name&& (p->subclass != subclass))  			p++; 		if (p->name) { 			printf(
literal|" (%s)"
argument|, p->name); 		} else { 			printf(
literal|" (unknown subclass 0x%02lx)"
argument|, subclass); 		} 	} else { 		printf(
literal|", subclass=0x%02x"
argument|, subclass); 	}  	data = pci_conf_read (tag, PCI_INTERRUPT_REG); 	pciint = PCI_INTERRUPT_PIN_EXTRACT(data);  	if (pciint) {  		printf (
literal|" int %c irq "
argument|,
literal|0x60
argument|+pciint);  		irq = PCI_INTERRUPT_LINE_EXTRACT(data);
comment|/* 		**	If it's zero, the isa irq number is unknown, 		**	and we cannot bind the pci interrupt. 		*/
argument|if (irq&& (irq !=
literal|0xff
argument|)) 			printf (
literal|"%d"
argument|, irq); 		else 			printf (
literal|"??"
argument|); 	};  	if (class != (PCI_CLASS_BRIDGE>>
literal|24
argument|)) 	    printf (
literal|" [no driver assigned]"
argument|); 	printf (
literal|"\n"
argument|);  	if (bootverbose) { 	    if (class == (PCI_CLASS_BRIDGE>>
literal|24
argument|)) { 		printf (
literal|"configuration space registers:"
argument|); 		for (reg =
literal|0
argument|; reg<
literal|0x100
argument|; reg+=
literal|4
argument|) { 		    if ((reg&
literal|0x0f
argument|) ==
literal|0
argument|) printf (
literal|"\n%02x:\t"
argument|, reg); 		    printf (
literal|"%08x "
argument|, pci_conf_read (tag, reg)); 		} 		printf (
literal|"\n"
argument|); 	    } else { 		for (reg=PCI_MAP_REG_START; reg<PCI_MAP_REG_END; reg+=
literal|4
argument|) { 		    data = pci_conf_read (tag, reg); 		    if ((data&~
literal|7
argument|)==
literal|0
argument|) continue; 		    switch (data&
literal|7
argument|) {  		case
literal|1
argument|: 		case
literal|5
argument|: 			printf (
literal|"\tmap(%x): io(%04lx)\n"
argument|, 				reg, data& ~
literal|3
argument|); 			break; 		case
literal|0
argument|: 			printf (
literal|"\tmap(%x): mem32(%08lx)\n"
argument|, 				reg, data& ~
literal|7
argument|); 			break; 		case
literal|2
argument|: 			printf (
literal|"\tmap(%x): mem20(%05lx)\n"
argument|, 				reg, data& ~
literal|7
argument|); 			break; 		case
literal|4
argument|: 			printf (
literal|"\tmap(%x): mem64(%08x%08lx)\n"
argument|, 				reg, pci_conf_read (tag, reg +
literal|4
argument|), data& ~
literal|7
argument|); 			reg +=
literal|4
argument|; 			break; 		    } 		} 	    } 	} }
comment|/*  * This is the user interface to the PCI configuration space.  */
argument|static struct pci_conf *pci_dev_list; static unsigned pci_dev_list_count; static unsigned pci_dev_list_size;  static void pci_remember(int bus, int dev, int func) { 	struct pci_conf *p; 	pcici_t tag;  	if (++pci_dev_list_count> pci_dev_list_size) { 		struct pci_conf *new;  		pci_dev_list_size +=
literal|8
argument|; 		MALLOC(new, struct pci_conf *, pci_dev_list_size * sizeof *new, 		       M_DEVL, M_NOWAIT); 		if (!new) { 			pci_dev_list_size -=
literal|8
argument|; 			pci_dev_list_count--; 			return; 		}  		if (pci_dev_list) { 			bcopy(pci_dev_list, new, ((pci_dev_list_size -
literal|8
argument|) * 						  sizeof *new)); 			FREE(pci_dev_list, M_DEVL); 		} 		pci_dev_list = new; 	}  	p =&pci_dev_list[pci_dev_list_count -
literal|1
argument|]; 	p->pc_sel.pc_bus  = bus; 	p->pc_sel.pc_dev  = dev; 	p->pc_sel.pc_func = func;  	tag = pcibus->pb_tag  (bus, dev, func); 	p->pc_hdr   = (pci_conf_read (tag, PCI_HEADER_MISC)>>
literal|16
argument|)&
literal|0xff
argument|; 	p->pc_devid = pci_conf_read(tag, PCI_ID_REG); 	p->pc_class = pci_conf_read(tag, PCI_CLASS_REG); 	switch (p->pc_hdr&
literal|0x7f
argument|) { 	case
literal|0
argument|: 		p->pc_subid = pci_conf_read(tag, PCI_SUBID_REG0); 		break; 	case
literal|1
argument|: 		p->pc_subid = pci_conf_read(tag, PCI_SUBID_REG1); 		break; 	case
literal|2
argument|: 		p->pc_subid = pci_conf_read(tag, PCI_SUBID_REG2); 		break; 	default: 		p->pc_subid =
literal|0
argument|; 	} }  static int pci_open(dev_t dev, int oflags, int devtype, struct proc *p) { 	if ((oflags& FWRITE)&& securelevel>
literal|0
argument|) { 		return EPERM; 	}  	return
literal|0
argument|; }  static int pci_close(dev_t dev, int flag, int devtype, struct proc *p) { 	return
literal|0
argument|; }  static int pci_ioctl(dev_t dev, int cmd, caddr_t data, int flag, struct proc *p) { 	struct pci_conf_io *cio; 	struct pci_io *io; 	size_t iolen; 	int error; 	pcici_t tag;  	if (cmd != PCIOCGETCONF&& !(flag& FWRITE)) 		return EPERM;  	switch(cmd) { 	case PCIOCGETCONF: 		cio = (struct pci_conf_io *)data; 		iolen = min(cio->pci_len,  			    pci_dev_list_count * sizeof(struct pci_conf)); 		cio->pci_len = pci_dev_list_count * sizeof(struct pci_conf);  		error = copyout(pci_dev_list, cio->pci_buf, iolen); 		break; 		 	case PCIOCREAD: 		io = (struct pci_io *)data; 		switch(io->pi_width) { 		case
literal|4
argument|: 			tag = pcibus->pb_tag (io->pi_sel.pc_bus,  					      io->pi_sel.pc_dev,  					      io->pi_sel.pc_func); 			io->pi_data = pci_conf_read(tag, io->pi_reg); 			error =
literal|0
argument|; 			break; 		case
literal|2
argument|: 		case
literal|1
argument|: 		default: 			error = ENODEV; 			break; 		} 		break;  	case PCIOCWRITE: 		io = (struct pci_io *)data; 		switch(io->pi_width) { 		case
literal|4
argument|: 			tag = pcibus->pb_tag (io->pi_sel.pc_bus,  					      io->pi_sel.pc_dev,  					      io->pi_sel.pc_func); 			pci_conf_write(tag, io->pi_reg, io->pi_data); 			error =
literal|0
argument|; 			break; 		case
literal|2
argument|: 		case
literal|1
argument|: 		default: 			error = ENODEV; 			break; 		} 		break;  	default: 		error = ENOTTY; 		break; 	}  	return (error); }
define|#
directive|define
name|PCI_CDEV
value|78
argument|static struct cdevsw pcicdev = { 	pci_open
argument_list|,
argument|pci_close
argument_list|,
argument|noread
argument_list|,
argument|nowrite
argument_list|,
argument|pci_ioctl
argument_list|,
argument|nostop
argument_list|,
argument|noreset
argument_list|,
argument|nodevtotty
argument_list|,
argument|noselect
argument_list|,
argument|nommap
argument_list|,
argument|nostrategy
argument_list|,
literal|"pci"
argument_list|,
literal|0
argument_list|,
argument|PCI_CDEV };
ifdef|#
directive|ifdef
name|DEVFS
argument|static void *pci_devfs_token;
endif|#
directive|endif
argument|static void pci_cdevinit(void *dummy) { 	dev_t dev;  	dev = makedev(PCI_CDEV,
literal|0
argument|); 	cdevsw_add(&dev,&pcicdev, NULL);
ifdef|#
directive|ifdef
name|DEVFS
argument|pci_devfs_token = devfs_add_devswf(&pcicdev,
literal|0
argument|, DV_CHR, 					   UID_ROOT, GID_WHEEL,
literal|0644
argument|,
literal|"pci"
argument|);
endif|#
directive|endif
argument|}  SYSINIT(pcidev, SI_SUB_DRIVERS, SI_ORDER_MIDDLE+PCI_CDEV, pci_cdevinit, NULL);
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NPCI */
end_comment

end_unit

