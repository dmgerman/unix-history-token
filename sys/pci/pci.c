begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/************************************************************************** ** **  $Id: pci.c,v 1.57.2.6 1998/03/06 23:45:13 julian Exp $ ** **  General subroutines for the PCI bus. **  pci_configure () ** **  FreeBSD ** **------------------------------------------------------------------------- ** ** Copyright (c) 1994 Wolfgang Stanglmeier.  All rights reserved. ** ** Redistribution and use in source and binary forms, with or without ** modification, are permitted provided that the following conditions ** are met: ** 1. Redistributions of source code must retain the above copyright **    notice, this list of conditions and the following disclaimer. ** 2. Redistributions in binary form must reproduce the above copyright **    notice, this list of conditions and the following disclaimer in the **    documentation and/or other materials provided with the distribution. ** 3. The name of the author may not be used to endorse or promote products **    derived from this software without specific prior written permission. ** ** THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR ** IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES ** OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. ** IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, ** INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT ** NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, ** DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY ** THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT ** (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF ** THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ** *************************************************************************** */
end_comment

begin_include
include|#
directive|include
file|"pci.h"
end_include

begin_if
if|#
directive|if
name|NPCI
operator|>
literal|0
end_if

begin_comment
comment|/*======================================================== ** **	#includes  and  declarations ** **======================================================== */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_comment
comment|/* declaration of wakeup(), used by vm.h */
end_comment

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|DEVFS
end_ifdef

begin_include
include|#
directive|include
file|<sys/devfsext.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DEVFS */
end_comment

begin_include
include|#
directive|include
file|<sys/fcntl.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_param.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/isa_device.h>
end_include

begin_comment
comment|/* XXX inthand2_t */
end_comment

begin_include
include|#
directive|include
file|<pci/pcivar.h>
end_include

begin_include
include|#
directive|include
file|<pci/pcireg.h>
end_include

begin_include
include|#
directive|include
file|<pci/pcibus.h>
end_include

begin_include
include|#
directive|include
file|<pci/pci_ioctl.h>
end_include

begin_define
define|#
directive|define
name|PCI_MAX_IRQ
value|(16)
end_define

begin_comment
comment|/*======================================================== ** **	Structs and Functions ** **======================================================== */
end_comment

begin_struct
struct|struct
name|pcicb
block|{
name|struct
name|pcicb
modifier|*
name|pcicb_next
decl_stmt|;
name|struct
name|pcicb
modifier|*
name|pcicb_up
decl_stmt|;
name|struct
name|pcicb
modifier|*
name|pcicb_down
decl_stmt|;
name|pcici_t
name|pcicb_bridge
decl_stmt|;
name|u_char
name|pcicb_bus
decl_stmt|;
name|u_char
name|pcicb_subordinate
decl_stmt|;
name|u_int
name|pcicb_mfrom
decl_stmt|;
name|u_int
name|pcicb_mupto
decl_stmt|;
name|u_int
name|pcicb_mamount
decl_stmt|;
name|u_short
name|pcicb_pfrom
decl_stmt|;
name|u_short
name|pcicb_pupto
decl_stmt|;
name|u_short
name|pcicb_pamount
decl_stmt|;
name|u_char
name|pcicb_bfrom
decl_stmt|;
name|u_char
name|pcicb_bupto
decl_stmt|;
name|u_long
name|pcicb_iobase
decl_stmt|;
name|u_long
name|pcicb_iolimit
decl_stmt|;
name|u_long
name|pcicb_membase
decl_stmt|;
name|u_long
name|pcicb_memlimit
decl_stmt|;
name|u_long
name|pcicb_p_membase
decl_stmt|;
name|u_long
name|pcicb_p_memlimit
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|pci_lkm
block|{
name|struct
name|pci_device
modifier|*
name|dvp
decl_stmt|;
name|struct
name|pci_lkm
modifier|*
name|next
decl_stmt|;
block|}
struct|;
end_struct

begin_function_decl
specifier|static
name|void
name|not_supported
parameter_list|(
name|pcici_t
name|tag
parameter_list|,
name|u_long
name|type
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pci_bus_config
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pci_rescan
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pci_attach
parameter_list|(
name|int
name|bus
parameter_list|,
name|int
name|dev
parameter_list|,
name|int
name|func
parameter_list|,
name|struct
name|pci_device
modifier|*
name|dvp
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pci_bridge_config
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pci_mfdev
parameter_list|(
name|int
name|bus
parameter_list|,
name|int
name|device
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pci_remember
parameter_list|(
name|int
name|bus
parameter_list|,
name|int
name|dev
parameter_list|,
name|int
name|func
parameter_list|,
name|struct
name|pci_device
modifier|*
name|dvp
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*======================================================== ** **	Variables ** **======================================================== */
end_comment

begin_comment
comment|/* **      log2 of safe burst len (in words) */
end_comment

begin_decl_stmt
name|unsigned
name|pci_max_burst_len
init|=
literal|3
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 2=16Byte, 3=32Byte, 4=64Byte, ... */
end_comment

begin_decl_stmt
name|unsigned
name|pci_mechanism
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|pci_maxdevice
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|pciroots
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* XXX pcisupport.c increments this  				 * for the Orion host to PCI bridge 				 * UGLY hack ... :( Will be changed :) 				 */
end_comment

begin_comment
comment|/*-------------------------------------------------------- ** **	Local variables. ** **-------------------------------------------------------- */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|pcibus
modifier|*
name|pcibus
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|pci_conf_count
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|pci_info_done
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|pcibusmax
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|pcicb
modifier|*
name|pcicb
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|pci_conf
modifier|*
name|pci_dev_list
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|pci_dev_list_count
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|pci_dev_list_size
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|pci_lkm
modifier|*
name|pci_lkm_head
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*----------------------------------------------------------------- ** **	The following functions are provided for the device driver **	to read/write the configuration space. ** **	pci_conf_read(): **		Read a long word from the pci configuration space. **		Requires a tag (from pcitag) and the register **		number (should be a long word alligned one). ** **	pci_conf_write(): **		Writes a long word to the pci configuration space. **		Requires a tag (from pcitag), the register number **		(should be a long word alligned one), and a value. ** **----------------------------------------------------------------- */
end_comment

begin_function
name|u_long
name|pci_conf_read
parameter_list|(
name|pcici_t
name|tag
parameter_list|,
name|u_long
name|reg
parameter_list|)
block|{
return|return
operator|(
name|pcibus
operator|->
name|pb_read
argument_list|(
name|tag
argument_list|,
name|reg
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|void
name|pci_conf_write
parameter_list|(
name|pcici_t
name|tag
parameter_list|,
name|u_long
name|reg
parameter_list|,
name|u_long
name|data
parameter_list|)
block|{
name|pcibus
operator|->
name|pb_write
argument_list|(
name|tag
argument_list|,
name|reg
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*======================================================== ** **	Subroutines for configuration. ** **======================================================== */
end_comment

begin_function
specifier|static
name|void
name|pci_register_io
parameter_list|(
name|struct
name|pcicb
modifier|*
name|cb
parameter_list|,
name|u_int
name|base
parameter_list|,
name|u_int
name|limit
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|PCI_BRIDGE_DEBUG
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"register_io:  bus=%d base=%x limit=%x\n"
argument_list|,
name|cb
operator|->
name|pcicb_bus
argument_list|,
name|base
argument_list|,
name|limit
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|cb
operator|->
name|pcicb_pfrom
operator|||
name|base
operator|<
name|cb
operator|->
name|pcicb_pfrom
condition|)
name|cb
operator|->
name|pcicb_pfrom
operator|=
name|base
expr_stmt|;
if|if
condition|(
name|limit
operator|>
name|cb
operator|->
name|pcicb_pupto
condition|)
name|cb
operator|->
name|pcicb_pupto
operator|=
name|limit
expr_stmt|;
comment|/* 	**	XXX should set bridge io mapping here 	**	but it can be mapped in 4k blocks only, 	**	leading to conflicts with isa/eisa .. 	*/
block|}
end_function

begin_function
specifier|static
name|void
name|pci_register_memory
parameter_list|(
name|struct
name|pcicb
modifier|*
name|cb
parameter_list|,
name|u_int
name|base
parameter_list|,
name|u_int
name|limit
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|PCI_BRIDGE_DEBUG
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"register_mem: bus=%d base=%x limit=%x\n"
argument_list|,
name|cb
operator|->
name|pcicb_bus
argument_list|,
name|base
argument_list|,
name|limit
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|cb
operator|->
name|pcicb_mfrom
operator|||
name|base
operator|<
name|cb
operator|->
name|pcicb_mfrom
condition|)
name|cb
operator|->
name|pcicb_mfrom
operator|=
name|base
expr_stmt|;
if|if
condition|(
name|limit
operator|>
name|cb
operator|->
name|pcicb_mupto
condition|)
name|cb
operator|->
name|pcicb_mupto
operator|=
name|limit
expr_stmt|;
comment|/* 	**	set the bridges mapping 	** 	**	XXX should handle the 1Mb granularity. 	*/
if|if
condition|(
name|cb
operator|->
name|pcicb_bridge
operator|.
name|tag
condition|)
block|{
name|pci_conf_write
argument_list|(
name|cb
operator|->
name|pcicb_bridge
argument_list|,
name|PCI_PCI_BRIDGE_MEM_REG
argument_list|,
operator|(
name|cb
operator|->
name|pcicb_memlimit
operator|&
literal|0xffff0000
operator|)
operator||
operator|(
name|cb
operator|->
name|pcicb_membase
operator|>>
literal|16
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"\t[pci%d uses memory from %x to %x]\n"
argument_list|,
name|cb
operator|->
name|pcicb_bus
argument_list|,
operator|(
name|unsigned
operator|)
name|cb
operator|->
name|pcicb_membase
argument_list|,
operator|(
name|unsigned
operator|)
name|cb
operator|->
name|pcicb_memlimit
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* **	XXX This function is neither complete nor tested. **	It's only used if the bios hasn't done it's job **	of mapping the pci devices in the physical memory. */
end_comment

begin_function
specifier|static
name|u_int
name|pci_memalloc
parameter_list|(
name|struct
name|pcicb
modifier|*
name|cb
parameter_list|,
name|u_int
name|addr
parameter_list|,
name|u_int
name|size
parameter_list|)
block|{
name|u_int
name|result
init|=
literal|0
decl_stmt|,
name|limit
init|=
literal|0
decl_stmt|,
name|newbase
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|PCI_BRIDGE_DEBUG
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"memalloc:  bus=%d addr=%x size=%x ..\n"
argument_list|,
name|cb
operator|->
name|pcicb_bus
argument_list|,
name|addr
argument_list|,
name|size
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|cb
condition|)
goto|goto
name|done
goto|;
if|if
condition|(
operator|!
name|cb
operator|->
name|pcicb_membase
condition|)
block|{
name|printf
argument_list|(
literal|"memalloc: bus%d: membase not set.\n"
argument_list|,
name|cb
operator|->
name|pcicb_bus
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* 	**	get upper allocation limit 	*/
name|limit
operator|=
name|cb
operator|->
name|pcicb_memlimit
expr_stmt|;
if|if
condition|(
name|cb
operator|->
name|pcicb_mfrom
operator|&&
name|cb
operator|->
name|pcicb_mfrom
operator|<=
name|limit
condition|)
name|limit
operator|=
name|cb
operator|->
name|pcicb_mfrom
operator|-
literal|1
expr_stmt|;
comment|/* 	**	address fixed, and impossible to allocate ? 	*/
if|if
condition|(
name|addr
operator|&&
name|addr
operator|+
name|size
operator|-
literal|1
operator|>
name|limit
condition|)
goto|goto
name|done
goto|;
comment|/* 	**	get possible address 	*/
name|result
operator|=
name|addr
expr_stmt|;
if|if
condition|(
operator|!
name|result
condition|)
name|result
operator|=
operator|(
operator|(
name|limit
operator|+
literal|1
operator|)
operator|/
name|size
operator|-
literal|1
operator|)
operator|*
name|size
expr_stmt|;
comment|/* 	**	if not local available, request from parent. 	*/
if|if
condition|(
name|result
operator|<
name|cb
operator|->
name|pcicb_membase
condition|)
block|{
name|newbase
operator|=
name|pci_memalloc
argument_list|(
name|cb
operator|->
name|pcicb_up
argument_list|,
name|result
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|newbase
condition|)
name|cb
operator|->
name|pcicb_membase
operator|=
name|result
expr_stmt|;
else|else
name|result
operator|=
literal|0
expr_stmt|;
block|}
name|done
label|:
if|if
condition|(
name|result
condition|)
name|pci_register_memory
argument_list|(
name|cb
argument_list|,
name|result
argument_list|,
name|result
operator|+
name|size
operator|-
literal|1
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PCI_BRIDGE_DEBUG
name|printf
argument_list|(
literal|"memalloc:  bus=%d addr=%x size=%x --> %x (limit=%x).\n"
argument_list|,
name|cb
operator|->
name|pcicb_bus
argument_list|,
name|addr
argument_list|,
name|size
argument_list|,
name|result
argument_list|,
name|limit
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_comment
comment|/*======================================================== ** **	pci_bridge_config() ** **	Configuration of a pci bridge. ** **======================================================== */
end_comment

begin_function
specifier|static
name|int
name|pci_bridge_config
parameter_list|(
name|void
parameter_list|)
block|{
name|pcici_t
name|tag
decl_stmt|;
name|struct
name|pcicb
modifier|*
name|parent
decl_stmt|;
name|tag
operator|=
name|pcicb
operator|->
name|pcicb_bridge
expr_stmt|;
if|if
condition|(
name|tag
operator|.
name|tag
condition|)
block|{
if|if
condition|(
operator|!
name|pcicb
operator|->
name|pcicb_bus
condition|)
block|{
name|u_int
name|data
decl_stmt|;
comment|/* 		**	Get the lowest available bus number. 		*/
name|pcicb
operator|->
name|pcicb_bus
operator|=
operator|++
name|pcibusmax
expr_stmt|;
comment|/* 		**	and configure the bridge 		*/
name|data
operator|=
name|pci_conf_read
argument_list|(
name|tag
argument_list|,
name|PCI_PCI_BRIDGE_BUS_REG
argument_list|)
expr_stmt|;
name|data
operator|=
name|PCI_PRIMARY_BUS_INSERT
argument_list|(
name|data
argument_list|,
name|pcicb
operator|->
name|pcicb_up
operator|->
name|pcicb_bus
argument_list|)
expr_stmt|;
name|data
operator|=
name|PCI_SECONDARY_BUS_INSERT
argument_list|(
name|data
argument_list|,
name|pcicb
operator|->
name|pcicb_bus
argument_list|)
expr_stmt|;
name|data
operator|=
name|PCI_SUBORDINATE_BUS_INSERT
argument_list|(
name|data
argument_list|,
name|pcicb
operator|->
name|pcicb_bus
argument_list|)
expr_stmt|;
name|pci_conf_write
argument_list|(
name|tag
argument_list|,
name|PCI_PCI_BRIDGE_BUS_REG
argument_list|,
name|data
argument_list|)
expr_stmt|;
comment|/* 		**	Propagate the new upper bus number limit. 		*/
for|for
control|(
name|parent
operator|=
name|pcicb
operator|->
name|pcicb_up
init|;
name|parent
operator|!=
name|NULL
condition|;
name|parent
operator|=
name|parent
operator|->
name|pcicb_up
control|)
block|{
if|if
condition|(
name|parent
operator|->
name|pcicb_subordinate
operator|>=
name|pcicb
operator|->
name|pcicb_bus
condition|)
continue|continue;
name|parent
operator|->
name|pcicb_subordinate
operator|=
name|pcicb
operator|->
name|pcicb_bus
expr_stmt|;
if|if
condition|(
operator|!
name|parent
operator|->
name|pcicb_bridge
operator|.
name|tag
condition|)
continue|continue;
name|data
operator|=
name|pci_conf_read
argument_list|(
name|parent
operator|->
name|pcicb_bridge
argument_list|,
name|PCI_PCI_BRIDGE_BUS_REG
argument_list|)
expr_stmt|;
name|data
operator|=
name|PCI_SUBORDINATE_BUS_INSERT
argument_list|(
name|data
argument_list|,
name|pcicb
operator|->
name|pcicb_bus
argument_list|)
expr_stmt|;
name|pci_conf_write
argument_list|(
name|parent
operator|->
name|pcicb_bridge
argument_list|,
name|PCI_PCI_BRIDGE_BUS_REG
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|pcicb
operator|->
name|pcicb_membase
condition|)
block|{
name|u_int
name|size
init|=
literal|0x100000
decl_stmt|;
name|pcicb
operator|->
name|pcicb_membase
operator|=
name|pci_memalloc
argument_list|(
name|pcicb
operator|->
name|pcicb_up
argument_list|,
literal|0
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcicb
operator|->
name|pcicb_membase
condition|)
name|pcicb
operator|->
name|pcicb_memlimit
operator|=
name|pcicb
operator|->
name|pcicb_membase
operator|+
name|size
operator|-
literal|1
expr_stmt|;
block|}
block|}
return|return
name|pcicb
operator|->
name|pcicb_bus
return|;
block|}
end_function

begin_comment
comment|/*======================================================== ** **	pci_attach() ** **	Attach one device ** **======================================================== */
end_comment

begin_function
specifier|static
name|void
name|pci_attach
parameter_list|(
name|int
name|bus
parameter_list|,
name|int
name|dev
parameter_list|,
name|int
name|func
parameter_list|,
name|struct
name|pci_device
modifier|*
name|dvp
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|u_long
name|data
decl_stmt|;
name|int
name|unit
decl_stmt|;
name|u_char
name|reg
decl_stmt|;
name|u_char
name|pciint
decl_stmt|;
name|int
name|irq
decl_stmt|;
name|pcici_t
name|tag
init|=
name|pcibus
operator|->
name|pb_tag
argument_list|(
name|bus
argument_list|,
name|dev
argument_list|,
name|func
argument_list|)
decl_stmt|;
comment|/* 	**	Get and increment the unit. 	*/
name|unit
operator|=
operator|(
operator|*
name|dvp
operator|->
name|pd_count
operator|)
operator|++
expr_stmt|;
comment|/* 	**	Announce this device 	*/
name|printf
argument_list|(
literal|"%s%d<%s> rev %d"
argument_list|,
name|dvp
operator|->
name|pd_name
argument_list|,
name|unit
argument_list|,
name|name
argument_list|,
operator|(
name|unsigned
operator|)
name|pci_conf_read
argument_list|(
name|tag
argument_list|,
name|PCI_CLASS_REG
argument_list|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
comment|/* 	**	Get the int pin number (pci interrupt number a-d) 	**	from the pci configuration space. 	*/
name|data
operator|=
name|pci_conf_read
argument_list|(
name|tag
argument_list|,
name|PCI_INTERRUPT_REG
argument_list|)
expr_stmt|;
name|pciint
operator|=
name|PCI_INTERRUPT_PIN_EXTRACT
argument_list|(
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|pciint
condition|)
block|{
name|printf
argument_list|(
literal|" int %c irq "
argument_list|,
literal|0x60
operator|+
name|pciint
argument_list|)
expr_stmt|;
name|irq
operator|=
name|PCI_INTERRUPT_LINE_EXTRACT
argument_list|(
name|data
argument_list|)
expr_stmt|;
comment|/* 		**	If it's zero, the isa irq number is unknown, 		**	and we cannot bind the pci interrupt. 		*/
if|if
condition|(
name|irq
operator|&&
operator|(
name|irq
operator|!=
literal|0xff
operator|)
condition|)
name|printf
argument_list|(
literal|"%d"
argument_list|,
name|irq
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"??"
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
name|printf
argument_list|(
literal|" on pci%d:%d:%d\n"
argument_list|,
name|bus
argument_list|,
name|dev
argument_list|,
name|func
argument_list|)
expr_stmt|;
comment|/* 	**	Read the current mapping, 	**	and update the pcicb fields. 	*/
for|for
control|(
name|reg
operator|=
name|PCI_MAP_REG_START
init|;
name|reg
operator|<
name|PCI_MAP_REG_END
condition|;
name|reg
operator|+=
literal|4
control|)
block|{
name|u_int
name|map
decl_stmt|,
name|addr
decl_stmt|,
name|size
decl_stmt|;
name|data
operator|=
name|pci_conf_read
argument_list|(
name|tag
argument_list|,
name|PCI_CLASS_REG
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|data
operator|&
operator|(
name|PCI_CLASS_MASK
operator||
name|PCI_SUBCLASS_MASK
operator|)
condition|)
block|{
case|case
name|PCI_CLASS_BRIDGE
operator||
name|PCI_SUBCLASS_BRIDGE_PCI
case|:
continue|continue;
block|}
empty_stmt|;
name|map
operator|=
name|pci_conf_read
argument_list|(
name|tag
argument_list|,
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|map
operator|&
name|PCI_MAP_MEMORY_ADDRESS_MASK
operator|)
condition|)
continue|continue;
name|pci_conf_write
argument_list|(
name|tag
argument_list|,
name|reg
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
name|data
operator|=
name|pci_conf_read
argument_list|(
name|tag
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|pci_conf_write
argument_list|(
name|tag
argument_list|,
name|reg
argument_list|,
name|map
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|data
operator|&
literal|7
condition|)
block|{
default|default:
continue|continue;
case|case
literal|1
case|:
case|case
literal|5
case|:
name|addr
operator|=
name|map
operator|&
name|PCI_MAP_IO_ADDRESS_MASK
expr_stmt|;
name|size
operator|=
operator|-
operator|(
name|data
operator|&
name|PCI_MAP_IO_ADDRESS_MASK
operator|)
expr_stmt|;
name|size
operator|&=
operator|~
operator|(
name|addr
operator|^
operator|-
name|addr
operator|)
expr_stmt|;
name|pci_register_io
argument_list|(
name|pcicb
argument_list|,
name|addr
argument_list|,
name|addr
operator|+
name|size
operator|-
literal|1
argument_list|)
expr_stmt|;
name|pcicb
operator|->
name|pcicb_pamount
operator|+=
name|size
expr_stmt|;
break|break;
case|case
literal|0
case|:
case|case
literal|2
case|:
case|case
literal|4
case|:
name|size
operator|=
operator|-
operator|(
name|data
operator|&
name|PCI_MAP_MEMORY_ADDRESS_MASK
operator|)
expr_stmt|;
name|addr
operator|=
name|map
operator|&
name|PCI_MAP_MEMORY_ADDRESS_MASK
expr_stmt|;
if|if
condition|(
name|addr
operator|>=
literal|0x100000
condition|)
block|{
name|pci_register_memory
argument_list|(
name|pcicb
argument_list|,
name|addr
argument_list|,
name|addr
operator|+
name|size
operator|-
literal|1
argument_list|)
expr_stmt|;
name|pcicb
operator|->
name|pcicb_mamount
operator|+=
name|size
expr_stmt|;
block|}
empty_stmt|;
break|break;
block|}
empty_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"\tmapreg[%02x] type=%d addr=%08x size=%04x.\n"
argument_list|,
name|reg
argument_list|,
name|map
operator|&
literal|7
argument_list|,
name|addr
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
comment|/* 	**	attach device 	**	may produce additional log messages, 	**	i.e. when installing subdevices. 	*/
call|(
modifier|*
name|dvp
operator|->
name|pd_attach
call|)
argument_list|(
name|tag
argument_list|,
name|unit
argument_list|)
expr_stmt|;
comment|/* 	**	Special processing of certain classes 	*/
name|data
operator|=
name|pci_conf_read
argument_list|(
name|tag
argument_list|,
name|PCI_CLASS_REG
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|data
operator|&
operator|(
name|PCI_CLASS_MASK
operator||
name|PCI_SUBCLASS_MASK
operator|)
condition|)
block|{
name|struct
name|pcicb
modifier|*
name|this
decl_stmt|,
modifier|*
modifier|*
name|link
decl_stmt|;
name|unsigned
name|char
name|primary
decl_stmt|,
name|secondary
decl_stmt|,
name|subordinate
decl_stmt|;
name|u_int
name|command
decl_stmt|;
case|case
name|PCI_CLASS_BRIDGE
operator||
name|PCI_SUBCLASS_BRIDGE_PCI
case|:
comment|/* 		**	get current configuration of the bridge. 		*/
name|data
operator|=
name|pci_conf_read
argument_list|(
name|tag
argument_list|,
name|PCI_PCI_BRIDGE_BUS_REG
argument_list|)
expr_stmt|;
name|primary
operator|=
name|PCI_PRIMARY_BUS_EXTRACT
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|secondary
operator|=
name|PCI_SECONDARY_BUS_EXTRACT
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|subordinate
operator|=
name|PCI_SUBORDINATE_BUS_EXTRACT
argument_list|(
name|data
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|PCI_QUIET
if|if
condition|(
name|bootverbose
condition|)
block|{
name|printf
argument_list|(
literal|"\tbridge from pci%d to pci%d through %d.\n"
argument_list|,
name|primary
argument_list|,
name|secondary
argument_list|,
name|subordinate
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\tmapping regs: io:%08lx mem:%08lx pmem:%08lx\n"
argument_list|,
name|pci_conf_read
argument_list|(
name|tag
argument_list|,
name|PCI_PCI_BRIDGE_IO_REG
argument_list|)
argument_list|,
name|pci_conf_read
argument_list|(
name|tag
argument_list|,
name|PCI_PCI_BRIDGE_MEM_REG
argument_list|)
argument_list|,
name|pci_conf_read
argument_list|(
name|tag
argument_list|,
name|PCI_PCI_BRIDGE_PMEM_REG
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* 		**	check for uninitialized bridge. 		*/
if|if
condition|(
operator|!
operator|(
name|primary
operator|<
name|secondary
operator|&&
name|secondary
operator|<=
name|subordinate
operator|&&
name|bus
operator|==
name|primary
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"\tINCORRECTLY or NEVER CONFIGURED.\n"
argument_list|)
expr_stmt|;
comment|/* 			**	disable this bridge 			*/
name|pci_conf_write
argument_list|(
name|tag
argument_list|,
name|PCI_COMMAND_STATUS_REG
argument_list|,
literal|0xffff0000
argument_list|)
expr_stmt|;
name|secondary
operator|=
literal|0
expr_stmt|;
name|subordinate
operator|=
literal|0
expr_stmt|;
block|}
empty_stmt|;
comment|/* 		**  allocate bus descriptor for bus behind the bridge 		*/
name|link
operator|=
operator|&
name|pcicb
operator|->
name|pcicb_down
expr_stmt|;
while|while
condition|(
operator|*
name|link
operator|&&
operator|(
operator|*
name|link
operator|)
operator|->
name|pcicb_bus
operator|<
name|secondary
condition|)
name|link
operator|=
operator|&
operator|(
operator|*
name|link
operator|)
operator|->
name|pcicb_next
expr_stmt|;
name|this
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|this
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
comment|/* 		**	Initialize this descriptor so far. 		**	(the initialization is completed just before 		**	scanning the bus behind the bridge. 		*/
name|bzero
argument_list|(
name|this
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|this
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|->
name|pcicb_next
operator|=
operator|*
name|link
expr_stmt|;
name|this
operator|->
name|pcicb_up
operator|=
name|pcicb
expr_stmt|;
name|this
operator|->
name|pcicb_bridge
operator|=
name|tag
expr_stmt|;
name|this
operator|->
name|pcicb_bus
operator|=
name|secondary
expr_stmt|;
name|this
operator|->
name|pcicb_subordinate
operator|=
name|subordinate
expr_stmt|;
name|command
operator|=
name|pci_conf_read
argument_list|(
name|tag
argument_list|,
name|PCI_COMMAND_STATUS_REG
argument_list|)
expr_stmt|;
if|if
condition|(
name|command
operator|&
name|PCI_COMMAND_IO_ENABLE
condition|)
block|{
comment|/* 			**	Bridge was configured by the bios. 			**	Read out the mapped io region. 			*/
name|unsigned
name|reg
decl_stmt|;
name|reg
operator|=
name|pci_conf_read
argument_list|(
name|tag
argument_list|,
name|PCI_PCI_BRIDGE_IO_REG
argument_list|)
expr_stmt|;
name|this
operator|->
name|pcicb_iobase
operator|=
name|PCI_PPB_IOBASE_EXTRACT
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|this
operator|->
name|pcicb_iolimit
operator|=
name|PCI_PPB_IOLIMIT_EXTRACT
argument_list|(
name|reg
argument_list|)
expr_stmt|;
comment|/* 			**	Note the used io space. 			*/
name|pci_register_io
argument_list|(
name|pcicb
argument_list|,
name|this
operator|->
name|pcicb_iobase
argument_list|,
name|this
operator|->
name|pcicb_iolimit
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
if|if
condition|(
name|command
operator|&
name|PCI_COMMAND_MEM_ENABLE
condition|)
block|{
comment|/* 			**	Bridge was configured by the bios. 			**	Read out the mapped memory regions. 			*/
name|unsigned
name|reg
decl_stmt|;
comment|/* 			**	non prefetchable memory 			*/
name|reg
operator|=
name|pci_conf_read
argument_list|(
name|tag
argument_list|,
name|PCI_PCI_BRIDGE_MEM_REG
argument_list|)
expr_stmt|;
name|this
operator|->
name|pcicb_membase
operator|=
name|PCI_PPB_MEMBASE_EXTRACT
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|this
operator|->
name|pcicb_memlimit
operator|=
name|PCI_PPB_MEMLIMIT_EXTRACT
argument_list|(
name|reg
argument_list|)
expr_stmt|;
comment|/* 			**	Register used memory space. 			*/
name|pci_register_memory
argument_list|(
name|pcicb
argument_list|,
name|this
operator|->
name|pcicb_membase
argument_list|,
name|this
operator|->
name|pcicb_memlimit
argument_list|)
expr_stmt|;
comment|/* 			**	prefetchable memory 			*/
name|reg
operator|=
name|pci_conf_read
argument_list|(
name|tag
argument_list|,
name|PCI_PCI_BRIDGE_PMEM_REG
argument_list|)
expr_stmt|;
name|this
operator|->
name|pcicb_p_membase
operator|=
name|PCI_PPB_MEMBASE_EXTRACT
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|this
operator|->
name|pcicb_p_memlimit
operator|=
name|PCI_PPB_MEMLIMIT_EXTRACT
argument_list|(
name|reg
argument_list|)
expr_stmt|;
comment|/* 			**	Register used memory space. 			*/
name|pci_register_memory
argument_list|(
name|pcicb
argument_list|,
name|this
operator|->
name|pcicb_p_membase
argument_list|,
name|this
operator|->
name|pcicb_p_memlimit
argument_list|)
expr_stmt|;
block|}
comment|/* 		**	Link it in chain. 		*/
operator|*
name|link
operator|=
name|this
expr_stmt|;
comment|/* 		**	Update mapping info of parent bus. 		*/
if|if
condition|(
operator|!
name|pcicb
operator|->
name|pcicb_bfrom
operator|||
name|secondary
operator|<
name|pcicb
operator|->
name|pcicb_bfrom
condition|)
name|pcicb
operator|->
name|pcicb_bfrom
operator|=
name|secondary
expr_stmt|;
if|if
condition|(
name|subordinate
operator|>
name|pcicb
operator|->
name|pcicb_bupto
condition|)
name|pcicb
operator|->
name|pcicb_bupto
operator|=
name|subordinate
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*======================================================== ** **	pci_bus_config() ** **	Autoconfiguration of one pci bus. ** **======================================================== */
end_comment

begin_function
specifier|static
name|int
name|pci_mfdev
parameter_list|(
name|int
name|bus
parameter_list|,
name|int
name|device
parameter_list|)
block|{
name|pcici_t
name|tag
decl_stmt|;
comment|/*     ** Detect a multi-function device that complies to the PCI 2.0 spec     */
name|tag
operator|=
name|pcibus
operator|->
name|pb_tag
argument_list|(
name|bus
argument_list|,
name|device
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|pci_conf_read
argument_list|(
name|tag
argument_list|,
name|PCI_HEADER_MISC
argument_list|)
operator|&
name|PCI_HEADER_MULTIFUNCTION
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|pci_bus_config
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|bus_no
decl_stmt|;
name|u_char
name|device
decl_stmt|;
name|u_char
name|reg
decl_stmt|;
name|pcici_t
name|tag
decl_stmt|,
name|mtag
decl_stmt|;
name|pcidi_t
name|type
decl_stmt|;
name|struct
name|pci_device
modifier|*
name|dvp
decl_stmt|;
comment|/* 	**	first initialize the bridge (bus controller chip) 	*/
name|bus_no
operator|=
name|pci_bridge_config
argument_list|()
expr_stmt|;
name|printf
argument_list|(
literal|"Probing for devices on PCI bus %d:\n"
argument_list|,
name|bus_no
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|PCI_QUIET
if|if
condition|(
name|bootverbose
operator|&&
operator|!
name|pci_info_done
condition|)
block|{
name|pci_info_done
operator|=
literal|1
expr_stmt|;
name|printf
argument_list|(
literal|"\tconfiguration mode %d allows %d devices.\n"
argument_list|,
name|pci_mechanism
argument_list|,
name|pci_maxdevice
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
endif|#
directive|endif
for|for
control|(
name|device
operator|=
literal|0
init|;
name|device
operator|<
name|pci_maxdevice
condition|;
name|device
operator|++
control|)
block|{
name|char
modifier|*
name|name
init|=
name|NULL
decl_stmt|;
name|struct
name|pci_device
modifier|*
modifier|*
name|dvpp
decl_stmt|;
name|int
name|func
decl_stmt|,
name|maxfunc
init|=
literal|0
decl_stmt|;
for|for
control|(
name|func
operator|=
literal|0
init|;
name|func
operator|<=
name|maxfunc
condition|;
name|func
operator|++
control|)
block|{
name|tag
operator|=
name|pcibus
operator|->
name|pb_tag
argument_list|(
name|bus_no
argument_list|,
name|device
argument_list|,
name|func
argument_list|)
expr_stmt|;
name|type
operator|=
name|pci_conf_read
argument_list|(
name|tag
argument_list|,
name|PCI_ID_REG
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|!
name|type
operator|)
operator|||
operator|(
name|type
operator|==
literal|0xfffffffful
operator|)
condition|)
continue|continue;
comment|/* 		**	lookup device in ioconfiguration: 		*/
name|dvpp
operator|=
operator|(
expr|struct
name|pci_device
operator|*
operator|*
operator|)
name|pcidevice_set
operator|.
name|ls_items
expr_stmt|;
while|while
condition|(
name|dvp
operator|=
operator|*
name|dvpp
operator|++
condition|)
block|{
if|if
condition|(
name|dvp
operator|->
name|pd_probe
condition|)
block|{
if|if
condition|(
name|name
operator|=
call|(
modifier|*
name|dvp
operator|->
name|pd_probe
call|)
argument_list|(
name|tag
argument_list|,
name|type
argument_list|)
condition|)
break|break;
block|}
block|}
empty_stmt|;
comment|/* 		**	check for mirrored devices. 		*/
if|if
condition|(
name|func
operator|!=
literal|0
condition|)
block|{
goto|goto
name|real_device
goto|;
block|}
if|if
condition|(
name|device
operator|&
literal|0x10
condition|)
block|{
name|mtag
operator|=
name|pcibus
operator|->
name|pb_tag
argument_list|(
name|bus_no
argument_list|,
call|(
name|u_char
call|)
argument_list|(
name|device
operator|&
operator|~
literal|0x10
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|device
operator|&
literal|0x08
condition|)
block|{
name|mtag
operator|=
name|pcibus
operator|->
name|pb_tag
argument_list|(
name|bus_no
argument_list|,
call|(
name|u_char
call|)
argument_list|(
name|device
operator|&
operator|~
literal|0x08
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
goto|goto
name|real_device
goto|;
if|if
condition|(
name|type
operator|!=
name|pci_conf_read
argument_list|(
name|mtag
argument_list|,
name|PCI_ID_REG
argument_list|)
condition|)
goto|goto
name|real_device
goto|;
for|for
control|(
name|reg
operator|=
name|PCI_MAP_REG_START
init|;
name|reg
operator|<
name|PCI_MAP_REG_END
condition|;
name|reg
operator|+=
literal|4
control|)
if|if
condition|(
name|pci_conf_read
argument_list|(
name|tag
argument_list|,
name|reg
argument_list|)
operator|!=
name|pci_conf_read
argument_list|(
name|mtag
argument_list|,
name|reg
argument_list|)
condition|)
goto|goto
name|real_device
goto|;
ifndef|#
directive|ifndef
name|PCI_QUIET
if|if
condition|(
name|dvp
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"%s?<%s> mirrored on pci%d:%d\n"
argument_list|,
name|dvp
operator|->
name|pd_name
argument_list|,
name|name
argument_list|,
name|bus_no
argument_list|,
name|device
argument_list|)
expr_stmt|;
endif|#
directive|endif
continue|continue;
name|real_device
label|:
ifndef|#
directive|ifndef
name|PCI_QUIET
ifdef|#
directive|ifdef
name|PCI_BRIDGE_DEBUG
if|if
condition|(
name|bootverbose
condition|)
block|{
name|printf
argument_list|(
literal|"\tconfig header: 0x%08x 0x%08x 0x%08x 0x%08x\n"
argument_list|,
name|pci_conf_read
argument_list|(
name|tag
argument_list|,
literal|0
argument_list|)
argument_list|,
name|pci_conf_read
argument_list|(
name|tag
argument_list|,
literal|4
argument_list|)
argument_list|,
name|pci_conf_read
argument_list|(
name|tag
argument_list|,
literal|8
argument_list|)
argument_list|,
name|pci_conf_read
argument_list|(
name|tag
argument_list|,
literal|12
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
endif|#
directive|endif
if|if
condition|(
name|func
operator|==
literal|0
operator|&&
name|pci_mfdev
argument_list|(
name|bus_no
argument_list|,
name|device
argument_list|)
condition|)
block|{
name|maxfunc
operator|=
literal|7
expr_stmt|;
block|}
name|pci_remember
argument_list|(
name|bus_no
argument_list|,
name|device
argument_list|,
name|func
argument_list|,
name|dvp
argument_list|)
expr_stmt|;
if|if
condition|(
name|dvp
operator|==
name|NULL
condition|)
block|{
ifndef|#
directive|ifndef
name|PCI_QUIET
if|if
condition|(
name|pci_conf_count
condition|)
continue|continue;
if|if
condition|(
name|maxfunc
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"%s%d:%d:    "
argument_list|,
name|pcibus
operator|->
name|pb_name
argument_list|,
name|bus_no
argument_list|,
name|device
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"%s%d:%d:%d: "
argument_list|,
name|pcibus
operator|->
name|pb_name
argument_list|,
name|bus_no
argument_list|,
name|device
argument_list|,
name|func
argument_list|)
expr_stmt|;
name|not_supported
argument_list|(
name|tag
argument_list|,
name|type
argument_list|)
expr_stmt|;
endif|#
directive|endif
continue|continue;
block|}
empty_stmt|;
if|if
condition|(
operator|*
name|name
condition|)
block|{
name|pci_attach
argument_list|(
name|bus_no
argument_list|,
name|device
argument_list|,
name|func
argument_list|,
name|dvp
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
block|}
block|}
ifndef|#
directive|ifndef
name|PCI_QUIET
if|if
condition|(
name|bootverbose
condition|)
block|{
if|if
condition|(
name|pcicb
operator|->
name|pcicb_mamount
condition|)
name|printf
argument_list|(
literal|"%s%d: uses %u bytes of memory from %x upto %x.\n"
argument_list|,
name|pcibus
operator|->
name|pb_name
argument_list|,
name|bus_no
argument_list|,
name|pcicb
operator|->
name|pcicb_mamount
argument_list|,
name|pcicb
operator|->
name|pcicb_mfrom
argument_list|,
name|pcicb
operator|->
name|pcicb_mupto
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcicb
operator|->
name|pcicb_pamount
condition|)
name|printf
argument_list|(
literal|"%s%d: uses %u bytes of I/O space from %x upto %x.\n"
argument_list|,
name|pcibus
operator|->
name|pb_name
argument_list|,
name|bus_no
argument_list|,
name|pcicb
operator|->
name|pcicb_pamount
argument_list|,
name|pcicb
operator|->
name|pcicb_pfrom
argument_list|,
name|pcicb
operator|->
name|pcicb_pupto
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcicb
operator|->
name|pcicb_bfrom
condition|)
name|printf
argument_list|(
literal|"%s%d: subordinate busses from %x upto %x.\n"
argument_list|,
name|pcibus
operator|->
name|pb_name
argument_list|,
name|bus_no
argument_list|,
name|pcicb
operator|->
name|pcicb_bfrom
argument_list|,
name|pcicb
operator|->
name|pcicb_bupto
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*======================================================== ** **	pci_configure () ** **      Autoconfiguration of pci devices. ** **      Has to take care of mirrored devices, which are **      entailed by incomplete decoding of pci address lines. ** **======================================================== */
end_comment

begin_function
name|void
name|pci_configure
parameter_list|()
block|{
name|struct
name|pcibus
modifier|*
modifier|*
name|pbp
init|=
operator|(
expr|struct
name|pcibus
operator|*
operator|*
operator|)
name|pcibus_set
operator|.
name|ls_items
decl_stmt|;
comment|/* 	**	check pci bus present 	*/
while|while
condition|(
operator|!
name|pci_maxdevice
operator|&&
operator|(
name|pcibus
operator|=
operator|*
name|pbp
operator|++
operator|)
condition|)
block|{
call|(
modifier|*
name|pcibus
operator|->
name|pb_setup
call|)
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|pci_maxdevice
condition|)
return|return;
comment|/* 	**	hello world .. 	*/
name|pciroots
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|pciroots
operator|--
condition|)
block|{
name|pcicb
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|pcicb
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcicb
operator|==
name|NULL
condition|)
block|{
return|return;
block|}
name|bzero
argument_list|(
name|pcicb
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|pcicb
argument_list|)
argument_list|)
expr_stmt|;
name|pcicb
operator|->
name|pcicb_bus
operator|=
name|pcibusmax
expr_stmt|;
name|pcicb
operator|->
name|pcicb_iolimit
operator|=
literal|0xffff
expr_stmt|;
name|pcicb
operator|->
name|pcicb_membase
operator|=
literal|0x02000000
expr_stmt|;
name|pcicb
operator|->
name|pcicb_p_membase
operator|=
literal|0x02000000
expr_stmt|;
name|pcicb
operator|->
name|pcicb_memlimit
operator|=
literal|0xffffffff
expr_stmt|;
name|pcicb
operator|->
name|pcicb_p_memlimit
operator|=
literal|0xffffffff
expr_stmt|;
while|while
condition|(
name|pcicb
operator|!=
name|NULL
condition|)
block|{
name|pci_bus_config
argument_list|()
expr_stmt|;
if|if
condition|(
name|pcibusmax
operator|<
name|pcicb
operator|->
name|pcicb_bus
condition|)
operator|(
name|pcibusmax
operator|=
name|pcicb
operator|->
name|pcicb_bus
operator|)
expr_stmt|;
if|if
condition|(
name|pcicb
operator|->
name|pcicb_down
condition|)
block|{
name|pcicb
operator|=
name|pcicb
operator|->
name|pcicb_down
expr_stmt|;
continue|continue;
block|}
empty_stmt|;
while|while
condition|(
name|pcicb
operator|&&
operator|!
name|pcicb
operator|->
name|pcicb_next
condition|)
name|pcicb
operator|=
name|pcicb
operator|->
name|pcicb_up
expr_stmt|;
if|if
condition|(
name|pcicb
condition|)
name|pcicb
operator|=
name|pcicb
operator|->
name|pcicb_next
expr_stmt|;
block|}
name|pcibusmax
operator|++
expr_stmt|;
block|}
name|pci_conf_count
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/*======================================================== ** **	pci_rescan () ** **      try to find lkm driver for device ** **      May be called more than once. **      Any device is attached only once. ** **======================================================== */
end_comment

begin_function
specifier|static
name|void
name|pci_rescan
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pci_dev_list_count
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|pci_lkm
modifier|*
name|lkm
decl_stmt|;
name|pcici_t
name|tag
decl_stmt|;
name|struct
name|pci_device
modifier|*
name|dvp
decl_stmt|;
name|pcidi_t
name|type
init|=
name|pci_dev_list
index|[
name|i
index|]
operator|.
name|pc_devid
decl_stmt|;
name|char
modifier|*
name|name
init|=
name|NULL
decl_stmt|;
name|int
name|bus
decl_stmt|,
name|dev
decl_stmt|,
name|func
decl_stmt|;
if|if
condition|(
name|pci_dev_list
index|[
name|i
index|]
operator|.
name|pc_dvp
condition|)
continue|continue;
name|bus
operator|=
name|pci_dev_list
index|[
name|i
index|]
operator|.
name|pc_sel
operator|.
name|pc_bus
expr_stmt|;
name|dev
operator|=
name|pci_dev_list
index|[
name|i
index|]
operator|.
name|pc_sel
operator|.
name|pc_dev
expr_stmt|;
name|func
operator|=
name|pci_dev_list
index|[
name|i
index|]
operator|.
name|pc_sel
operator|.
name|pc_func
expr_stmt|;
name|tag
operator|=
name|pcibus
operator|->
name|pb_tag
argument_list|(
name|bus
argument_list|,
name|dev
argument_list|,
name|func
argument_list|)
expr_stmt|;
for|for
control|(
name|lkm
operator|=
name|pci_lkm_head
init|;
name|lkm
condition|;
name|lkm
operator|=
name|lkm
operator|->
name|next
control|)
block|{
name|dvp
operator|=
name|lkm
operator|->
name|dvp
expr_stmt|;
if|if
condition|(
name|name
operator|=
call|(
modifier|*
name|dvp
operator|->
name|pd_probe
call|)
argument_list|(
name|tag
argument_list|,
name|type
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
name|name
operator|&&
operator|*
name|name
condition|)
block|{
name|pcicb
operator|=
name|pci_dev_list
index|[
name|i
index|]
operator|.
name|pc_cb
expr_stmt|;
name|pci_attach
argument_list|(
name|bus
argument_list|,
name|dev
argument_list|,
name|func
argument_list|,
name|dvp
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|pci_dev_list
index|[
name|i
index|]
operator|.
name|pc_dvp
operator|=
name|dvp
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*======================================================== ** **	pci_register_lkm () ** **      Add LKM PCI driver's struct pci_device to pci_lkm chain ** **======================================================== */
end_comment

begin_function
name|int
name|pci_register_lkm
parameter_list|(
name|struct
name|pci_device
modifier|*
name|dvp
parameter_list|,
name|int
name|if_revision
parameter_list|)
block|{
name|struct
name|pci_lkm
modifier|*
name|lkm
decl_stmt|;
if|if
condition|(
name|if_revision
operator|!=
literal|0
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
operator|!
name|dvp
operator|||
operator|!
name|dvp
operator|->
name|pd_probe
operator|||
operator|!
name|dvp
operator|->
name|pd_attach
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
name|lkm
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|lkm
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|lkm
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
name|lkm
operator|->
name|dvp
operator|=
name|dvp
expr_stmt|;
name|lkm
operator|->
name|next
operator|=
name|pci_lkm_head
expr_stmt|;
name|pci_lkm_head
operator|=
name|lkm
expr_stmt|;
name|pci_rescan
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*----------------------------------------------------------------------- ** **	Map device into port space. ** **	Actually the device should have been mapped by the bios. **	This function only reads and verifies the value. ** **	PCI-Specification:  6.2.5.1: address maps ** **----------------------------------------------------------------------- */
end_comment

begin_function
name|int
name|pci_map_port
parameter_list|(
name|pcici_t
name|tag
parameter_list|,
name|u_long
name|reg
parameter_list|,
name|u_short
modifier|*
name|pa
parameter_list|)
block|{
name|unsigned
name|data
decl_stmt|,
name|ioaddr
decl_stmt|,
name|iosize
decl_stmt|;
name|struct
name|pcicb
modifier|*
name|link
init|=
name|pcicb
decl_stmt|;
comment|/* 	**	sanity check 	*/
if|if
condition|(
name|reg
operator|<
name|PCI_MAP_REG_START
operator|||
name|reg
operator|>=
name|PCI_MAP_REG_END
operator|||
operator|(
name|reg
operator|&
literal|3
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"pci_map_port failed: bad register=0x%x\n"
argument_list|,
operator|(
name|unsigned
operator|)
name|reg
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
empty_stmt|;
comment|/* 	**	get size and type of port 	** 	**	type is in the lowest two bits. 	**	If device requires 2^n bytes, the next 	**	n-2 bits are hardwired as 0. 	*/
name|ioaddr
operator|=
name|pci_conf_read
argument_list|(
name|tag
argument_list|,
name|reg
argument_list|)
operator|&
name|PCI_MAP_IO_ADDRESS_MASK
expr_stmt|;
if|if
condition|(
operator|!
name|ioaddr
condition|)
block|{
name|printf
argument_list|(
literal|"pci_map_port failed: not configured by bios.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
empty_stmt|;
name|pci_conf_write
argument_list|(
name|tag
argument_list|,
name|reg
argument_list|,
literal|0xfffffffful
argument_list|)
expr_stmt|;
name|data
operator|=
name|pci_conf_read
argument_list|(
name|tag
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|pci_conf_write
argument_list|(
name|tag
argument_list|,
name|reg
argument_list|,
name|ioaddr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|data
operator|&
literal|0x03
operator|)
operator|!=
name|PCI_MAP_IO
condition|)
block|{
name|printf
argument_list|(
literal|"pci_map_port failed: bad port type=0x%x\n"
argument_list|,
operator|(
name|unsigned
operator|)
name|data
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
empty_stmt|;
name|iosize
operator|=
operator|-
operator|(
name|data
operator|&
name|PCI_MAP_IO_ADDRESS_MASK
operator|)
expr_stmt|;
name|iosize
operator|&=
operator|~
operator|(
name|ioaddr
operator|^
operator|-
name|ioaddr
operator|)
expr_stmt|;
if|if
condition|(
name|ioaddr
operator|<
name|pcicb
operator|->
name|pcicb_iobase
operator|||
name|ioaddr
operator|+
name|iosize
operator|-
literal|1
operator|>
name|pcicb
operator|->
name|pcicb_iolimit
condition|)
block|{
name|printf
argument_list|(
literal|"pci_map_port failed: device's iorange 0x%x-0x%x "
literal|"is incompatible with its bridge's range 0x%x-0x%x\n"
argument_list|,
operator|(
name|unsigned
operator|)
name|ioaddr
argument_list|,
operator|(
name|unsigned
operator|)
name|ioaddr
operator|+
name|iosize
operator|-
literal|1
argument_list|,
operator|(
name|unsigned
operator|)
name|pcicb
operator|->
name|pcicb_iobase
argument_list|,
operator|(
name|unsigned
operator|)
name|pcicb
operator|->
name|pcicb_iolimit
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
ifndef|#
directive|ifndef
name|PCI_QUIET
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"\treg%d: ioaddr=0x%x size=0x%x\n"
argument_list|,
operator|(
name|unsigned
operator|)
name|reg
argument_list|,
operator|(
name|unsigned
operator|)
name|ioaddr
argument_list|,
operator|(
name|unsigned
operator|)
name|iosize
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	**	set the configuration register of and 	**      return the address to the driver. 	**	Make sure to enable each upstream bridge 	**	so I/O and DMA can go all the way. 	*/
for|for
control|(
init|;
condition|;
control|)
block|{
name|data
operator|=
name|pci_conf_read
argument_list|(
name|tag
argument_list|,
name|PCI_COMMAND_STATUS_REG
argument_list|)
operator|&
literal|0xffff
expr_stmt|;
name|data
operator||=
name|PCI_COMMAND_IO_ENABLE
operator||
name|PCI_COMMAND_MASTER_ENABLE
expr_stmt|;
operator|(
name|void
operator|)
name|pci_conf_write
argument_list|(
name|tag
argument_list|,
name|PCI_COMMAND_STATUS_REG
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|link
operator|=
name|link
operator|->
name|pcicb_up
operator|)
operator|==
name|NULL
condition|)
break|break;
name|tag
operator|=
name|link
operator|->
name|pcicb_bridge
expr_stmt|;
block|}
operator|*
name|pa
operator|=
name|ioaddr
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*----------------------------------------------------------------------- ** **	Map device into virtual and physical space ** **	Actually the device should have been mapped by the bios. **	This function only reads and verifies the value. ** **      PCI-Specification:  6.2.5.1: address maps ** **----------------------------------------------------------------------- */
end_comment

begin_function
name|int
name|pci_map_mem
parameter_list|(
name|pcici_t
name|tag
parameter_list|,
name|u_long
name|reg
parameter_list|,
name|vm_offset_t
modifier|*
name|va
parameter_list|,
name|vm_offset_t
modifier|*
name|pa
parameter_list|)
block|{
name|struct
name|pcicb
modifier|*
name|link
init|=
name|pcicb
decl_stmt|;
name|unsigned
name|data
decl_stmt|,
name|paddr
decl_stmt|;
name|vm_size_t
name|psize
decl_stmt|,
name|poffs
decl_stmt|,
name|pend
decl_stmt|;
name|vm_offset_t
name|vaddr
decl_stmt|;
comment|/* 	**	sanity check 	*/
if|if
condition|(
name|reg
operator|<
name|PCI_MAP_REG_START
operator|||
name|reg
operator|>=
name|PCI_MAP_REG_END
operator|||
operator|(
name|reg
operator|&
literal|3
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"pci_map_mem failed: bad register=0x%x\n"
argument_list|,
operator|(
name|unsigned
operator|)
name|reg
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
empty_stmt|;
comment|/* 	**	save old mapping, get size and type of memory 	** 	**	type is in the lowest four bits. 	**	If device requires 2^n bytes, the next 	**	n-4 bits are read as 0. 	*/
name|paddr
operator|=
name|pci_conf_read
argument_list|(
name|tag
argument_list|,
name|reg
argument_list|)
operator|&
name|PCI_MAP_MEMORY_ADDRESS_MASK
expr_stmt|;
name|pci_conf_write
argument_list|(
name|tag
argument_list|,
name|reg
argument_list|,
literal|0xfffffffful
argument_list|)
expr_stmt|;
name|data
operator|=
name|pci_conf_read
argument_list|(
name|tag
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|pci_conf_write
argument_list|(
name|tag
argument_list|,
name|reg
argument_list|,
name|paddr
argument_list|)
expr_stmt|;
comment|/* 	**	check the type 	*/
if|if
condition|(
operator|!
operator|(
operator|(
name|data
operator|&
name|PCI_MAP_MEMORY_TYPE_MASK
operator|)
operator|==
name|PCI_MAP_MEMORY_TYPE_32BIT_1M
operator|&&
operator|(
name|paddr
operator|&
operator|~
literal|0xfffff
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|data
operator|&
name|PCI_MAP_MEMORY_TYPE_MASK
operator|)
operator|!=
name|PCI_MAP_MEMORY_TYPE_32BIT
condition|)
block|{
name|printf
argument_list|(
literal|"pci_map_mem failed: bad memory type=0x%x\n"
argument_list|,
operator|(
name|unsigned
operator|)
name|data
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
empty_stmt|;
comment|/* 	**	get the size. 	*/
name|psize
operator|=
operator|-
operator|(
name|data
operator|&
name|PCI_MAP_MEMORY_ADDRESS_MASK
operator|)
expr_stmt|;
name|pend
operator|=
name|paddr
operator|+
name|psize
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|paddr
operator|||
name|paddr
operator|==
name|PCI_MAP_MEMORY_ADDRESS_MASK
condition|)
block|{
name|paddr
operator|=
name|pci_memalloc
argument_list|(
name|pcicb
argument_list|,
literal|0
argument_list|,
name|psize
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|paddr
condition|)
block|{
name|printf
argument_list|(
literal|"pci_map_mem: not configured by bios.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
empty_stmt|;
name|pci_register_memory
argument_list|(
name|pcicb
argument_list|,
name|paddr
argument_list|,
name|pend
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
if|if
condition|(
operator|!
operator|(
operator|(
name|pcicb
operator|->
name|pcicb_membase
operator|<=
name|paddr
operator|&&
name|pend
operator|<=
name|pcicb
operator|->
name|pcicb_memlimit
operator|)
operator|||
operator|(
name|pcicb
operator|->
name|pcicb_p_membase
operator|<=
name|paddr
operator|&&
name|pend
operator|<=
name|pcicb
operator|->
name|pcicb_p_memlimit
operator|)
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"pci_map_mem: device's memrange 0x%x-0x%x is "
literal|"incompatible with its bridge's\n"
literal|"\tmemrange 0x%x-0x%x and prefetchable memrange 0x%x-0x%x\n"
argument_list|,
operator|(
name|unsigned
operator|)
name|paddr
argument_list|,
call|(
name|unsigned
call|)
argument_list|(
name|paddr
operator|+
name|psize
operator|-
literal|1
argument_list|)
argument_list|,
operator|(
name|unsigned
operator|)
name|pcicb
operator|->
name|pcicb_p_membase
argument_list|,
operator|(
name|unsigned
operator|)
name|pcicb
operator|->
name|pcicb_p_memlimit
argument_list|,
operator|(
name|unsigned
operator|)
name|pcicb
operator|->
name|pcicb_membase
argument_list|,
operator|(
name|unsigned
operator|)
name|pcicb
operator|->
name|pcicb_memlimit
argument_list|)
expr_stmt|;
block|}
name|pci_conf_write
argument_list|(
name|tag
argument_list|,
name|reg
argument_list|,
name|paddr
argument_list|)
expr_stmt|;
comment|/* 	**	Truncate paddr to page boundary. 	**	(Or does pmap_mapdev the job?) 	*/
name|poffs
operator|=
name|paddr
operator|-
name|trunc_page
argument_list|(
name|paddr
argument_list|)
expr_stmt|;
name|vaddr
operator|=
operator|(
name|vm_offset_t
operator|)
name|pmap_mapdev
argument_list|(
name|paddr
operator|-
name|poffs
argument_list|,
name|psize
operator|+
name|poffs
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|vaddr
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|vaddr
operator|+=
name|poffs
expr_stmt|;
ifndef|#
directive|ifndef
name|PCI_QUIET
comment|/* 	**	display values. 	*/
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"\treg%d: virtual=0x%lx physical=0x%lx size=0x%lx\n"
argument_list|,
operator|(
name|unsigned
operator|)
name|reg
argument_list|,
operator|(
name|u_long
operator|)
name|vaddr
argument_list|,
operator|(
name|u_long
operator|)
name|paddr
argument_list|,
operator|(
name|u_long
operator|)
name|psize
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	**      set the configuration register and 	**      return the address to the driver 	**      Make sure to enable each upstream bridge 	**      so memory and DMA can go all the way. 	*/
for|for
control|(
init|;
condition|;
control|)
block|{
name|data
operator|=
name|pci_conf_read
argument_list|(
name|tag
argument_list|,
name|PCI_COMMAND_STATUS_REG
argument_list|)
operator|&
literal|0xffff
expr_stmt|;
name|data
operator||=
name|PCI_COMMAND_MEM_ENABLE
operator||
name|PCI_COMMAND_MASTER_ENABLE
expr_stmt|;
operator|(
name|void
operator|)
name|pci_conf_write
argument_list|(
name|tag
argument_list|,
name|PCI_COMMAND_STATUS_REG
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|link
operator|=
name|link
operator|->
name|pcicb_up
operator|)
operator|==
name|NULL
condition|)
break|break;
name|tag
operator|=
name|link
operator|->
name|pcicb_bridge
expr_stmt|;
block|}
operator|*
name|va
operator|=
name|vaddr
expr_stmt|;
operator|*
name|pa
operator|=
name|paddr
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*----------------------------------------------------------------------- ** **	Pci meta interrupt handler ** **	This handler assumes level triggered interrupts. **	It's possible to build a kernel which handles shared **	edge triggered interrupts by the options "PCI_EDGE_INT". **	But there is a performance penalty. ** **	(Of course you can delete the #ifdef PCI_EDGE_INT bracketed **	code at all :-) :-) :-) ** **----------------------------------------------------------------------- */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|pci_int_desc
modifier|*
name|pci_int_desc
index|[
name|PCI_MAX_IRQ
index|]
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|NO_SHARED_IRQ
end_ifndef

begin_function
specifier|static
specifier|inline
name|unsigned
name|splq
parameter_list|(
name|unsigned
name|mask
parameter_list|)
block|{
name|unsigned
name|temp
init|=
name|cpl
decl_stmt|;
name|cpl
operator||=
name|mask
expr_stmt|;
return|return
name|temp
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|pci_int
parameter_list|(
name|int
name|irq
parameter_list|)
block|{
name|struct
name|pci_int_desc
modifier|*
name|p
decl_stmt|;
name|int
name|s
decl_stmt|;
if|if
condition|(
name|irq
operator|<
literal|0
operator|||
name|irq
operator|>=
name|PCI_MAX_IRQ
condition|)
block|{
name|printf
argument_list|(
literal|"pci_int: irq %d out of range, ignored\n"
argument_list|,
name|irq
argument_list|)
expr_stmt|;
return|return;
block|}
empty_stmt|;
for|for
control|(
name|p
operator|=
name|pci_int_desc
index|[
name|irq
index|]
init|;
name|p
operator|!=
name|NULL
condition|;
name|p
operator|=
name|p
operator|->
name|pcid_next
control|)
block|{
name|s
operator|=
name|splq
argument_list|(
operator|*
name|p
operator|->
name|pcid_maskptr
argument_list|)
expr_stmt|;
call|(
modifier|*
name|p
operator|->
name|pcid_handler
call|)
argument_list|(
name|p
operator|->
name|pcid_argument
argument_list|)
expr_stmt|;
name|p
operator|->
name|pcid_tally
operator|++
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|if (p->pcid_tally<20) 			printf ("PCI_INT: irq=%d h=%p cpl o=%x n=%x val=%d\n", 				irq, p->pcid_handler, s, cpl, c);
endif|#
directive|endif
block|}
empty_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*----------------------------------------------------------------------- ** **	Auxiliary function for interrupt (un)mapping. ** **----------------------------------------------------------------------- */
end_comment

begin_function
specifier|static
name|u_int
name|getirq
parameter_list|(
name|pcici_t
name|tag
parameter_list|)
block|{
name|u_int
name|irq
decl_stmt|;
name|irq
operator|=
name|PCI_INTERRUPT_LINE_EXTRACT
argument_list|(
name|pci_conf_read
argument_list|(
name|tag
argument_list|,
name|PCI_INTERRUPT_REG
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|irq
operator|==
literal|0
operator|||
name|irq
operator|==
literal|0xff
condition|)
block|{
name|printf
argument_list|(
literal|"\tint line register not set by bios\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0xff
operator|)
return|;
block|}
if|if
condition|(
name|irq
operator|>=
name|PCI_MAX_IRQ
condition|)
block|{
name|printf
argument_list|(
literal|"\tirq %d out of bounds (must be< %d).\n"
argument_list|,
name|irq
argument_list|,
name|PCI_MAX_IRQ
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0xff
operator|)
return|;
block|}
return|return
operator|(
name|irq
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|pci_int_desc
modifier|*
modifier|*
name|getintdescbytag
parameter_list|(
name|u_int
name|irq
parameter_list|,
name|pcici_t
name|tag
parameter_list|)
block|{
name|struct
name|pci_int_desc
modifier|*
name|p
decl_stmt|,
modifier|*
modifier|*
name|pp
decl_stmt|;
name|pp
operator|=
operator|&
name|pci_int_desc
index|[
name|irq
index|]
expr_stmt|;
while|while
condition|(
operator|(
operator|(
name|p
operator|=
operator|*
name|pp
operator|)
operator|)
operator|&&
operator|!
name|sametag
argument_list|(
name|p
operator|->
name|pcid_tag
argument_list|,
name|tag
argument_list|)
condition|)
name|pp
operator|=
operator|&
name|p
operator|->
name|pcid_next
expr_stmt|;
if|if
condition|(
operator|!
name|p
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
return|return
operator|(
name|pp
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|pci_int_desc
modifier|*
name|getintdescbymptr
parameter_list|(
name|u_int
name|irq
parameter_list|,
name|unsigned
modifier|*
name|mptr
parameter_list|)
block|{
name|struct
name|pci_int_desc
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|pci_int_desc
index|[
name|irq
index|]
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|pcid_next
control|)
if|if
condition|(
name|p
operator|->
name|pcid_maskptr
operator|==
name|mptr
condition|)
break|break;
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_comment
comment|/*----------------------------------------------------------------------- ** **	Map pci interrupt. ** **----------------------------------------------------------------------- */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|pci_mask0
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|pci_map_int
parameter_list|(
name|pcici_t
name|tag
parameter_list|,
name|pci_inthand_t
modifier|*
name|func
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|unsigned
modifier|*
name|maskptr
parameter_list|)
block|{
name|u_int
name|irq
decl_stmt|;
name|int
name|result
decl_stmt|,
name|oldspl
decl_stmt|;
name|unsigned
name|mask
decl_stmt|;
name|struct
name|pci_int_desc
modifier|*
name|tail
decl_stmt|,
modifier|*
name|mdp
init|=
name|NULL
decl_stmt|,
modifier|*
name|new
init|=
name|NULL
decl_stmt|;
comment|/* 	**	Get irq line from configuration space, 	**	and check for consistency. 	*/
name|irq
operator|=
name|getirq
argument_list|(
name|tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|irq
operator|==
literal|0xff
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
empty_stmt|;
name|mask
operator|=
literal|1ul
operator|<<
name|irq
expr_stmt|;
comment|/* 	**      disable this interrupt. 	*/
name|oldspl
operator|=
name|splq
argument_list|(
name|mask
argument_list|)
expr_stmt|;
comment|/* 	**	If handler for this tag already installed, 	**	remove it first. 	*/
if|if
condition|(
name|getintdescbytag
argument_list|(
name|irq
argument_list|,
name|tag
argument_list|)
operator|!=
name|NULL
condition|)
name|pci_unmap_int
argument_list|(
name|tag
argument_list|)
expr_stmt|;
comment|/* 	**	If this irq not yet included in the mask, include it. 	*/
name|mdp
operator|=
name|getintdescbymptr
argument_list|(
name|irq
argument_list|,
name|maskptr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mdp
condition|)
block|{
name|result
operator|=
name|pcibus
operator|->
name|pb_imaskinc
argument_list|(
name|irq
argument_list|,
name|maskptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
condition|)
goto|goto
name|conflict
goto|;
block|}
empty_stmt|;
comment|/* 	**	Allocate descriptor and initialize it. 	*/
name|tail
operator|=
name|pci_int_desc
index|[
name|irq
index|]
expr_stmt|;
name|new
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|new
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|new
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|new
argument_list|)
argument_list|)
expr_stmt|;
name|new
operator|->
name|pcid_next
operator|=
name|tail
expr_stmt|;
name|new
operator|->
name|pcid_tag
operator|=
name|tag
expr_stmt|;
name|new
operator|->
name|pcid_handler
operator|=
name|func
expr_stmt|;
name|new
operator|->
name|pcid_argument
operator|=
name|arg
expr_stmt|;
name|new
operator|->
name|pcid_maskptr
operator|=
name|maskptr
expr_stmt|;
name|new
operator|->
name|pcid_tally
operator|=
literal|0
expr_stmt|;
name|new
operator|->
name|pcid_mask
operator|=
name|mask
expr_stmt|;
comment|/* 	**	If first handler:   install it. 	**	If second handler: install shared-int-handler. 	*/
if|if
condition|(
operator|!
name|tail
condition|)
block|{
comment|/* 		**	first handler for this irq. 		*/
name|result
operator|=
name|pcibus
operator|->
name|pb_iattach
comment|/* 			 * XXX if we get here, then `func' must be pci_int 			 * so the bogus casts are almost OK since they just 			 * undo the bogus casts that were needed to pass 			 * pci_int and its arg to pci_map_int(). 			 */
argument_list|(
name|irq
argument_list|,
operator|(
name|inthand2_t
operator|*
operator|)
name|func
argument_list|,
operator|(
name|int
operator|)
name|arg
argument_list|,
name|maskptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
condition|)
goto|goto
name|conflict
goto|;
ifdef|#
directive|ifdef
name|NO_SHARED_IRQ
block|}
else|else
goto|goto
name|conflict
goto|;
else|#
directive|else
block|}
end_function

begin_elseif
elseif|else
if|if
condition|(
operator|!
name|tail
operator|->
name|pcid_next
condition|)
block|{
comment|/* 		**	Second handler for this irq. 		*/
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"\tusing shared irq %d.\n"
argument_list|,
name|irq
argument_list|)
expr_stmt|;
comment|/* 		**	replace old handler by shared-int-handler. 		*/
name|result
operator|=
name|pcibus
operator|->
name|pb_idetach
argument_list|(
name|irq
argument_list|,
operator|(
name|inthand2_t
operator|*
operator|)
name|tail
operator|->
name|pcid_handler
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
condition|)
name|printf
argument_list|(
literal|"\tCANNOT DETACH INT HANDLER.\n"
argument_list|)
expr_stmt|;
name|result
operator|=
name|pcibus
operator|->
name|pb_iattach
argument_list|(
name|irq
argument_list|,
name|pci_int
argument_list|,
name|irq
argument_list|,
operator|&
name|pci_mask0
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
condition|)
block|{
name|printf
argument_list|(
literal|"\tCANNOT ATTACH SHARED INT HANDLER.\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
empty_stmt|;
block|}
end_elseif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* 	**	Link new descriptor, reenable ints and done. 	*/
end_comment

begin_expr_stmt
name|pci_int_desc
index|[
name|irq
index|]
operator|=
name|new
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|splx
argument_list|(
name|oldspl
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
operator|(
literal|1
operator|)
return|;
end_return

begin_comment
comment|/* 	**	Handle some problems. 	*/
end_comment

begin_label
name|conflict
label|:
end_label

begin_expr_stmt
name|printf
argument_list|(
literal|"\tirq %d already in use.\n"
argument_list|,
name|irq
argument_list|)
expr_stmt|;
end_expr_stmt

begin_label
name|fail
label|:
end_label

begin_comment
comment|/* 	**	If descriptor allocated, free it. 	**	If included in mask, remove it. 	*/
end_comment

begin_if
if|if
condition|(
name|new
condition|)
name|free
argument_list|(
name|new
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
end_if

begin_if
if|if
condition|(
operator|!
name|mdp
condition|)
operator|(
name|void
operator|)
name|pcibus
operator|->
name|pb_imaskexc
argument_list|(
name|irq
argument_list|,
name|maskptr
argument_list|)
expr_stmt|;
end_if

begin_expr_stmt
name|splx
argument_list|(
name|oldspl
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
operator|(
literal|0
operator|)
return|;
end_return

begin_comment
unit|}
comment|/*----------------------------------------------------------------------- ** **	Unmap pci interrupt. ** **----------------------------------------------------------------------- */
end_comment

begin_macro
unit|int
name|pci_unmap_int
argument_list|(
argument|pcici_t tag
argument_list|)
end_macro

begin_block
block|{
name|int
name|result
decl_stmt|,
name|oldspl
decl_stmt|;
name|struct
name|pci_int_desc
modifier|*
name|this
decl_stmt|,
modifier|*
modifier|*
name|hook
decl_stmt|,
modifier|*
name|tail
decl_stmt|;
name|unsigned
name|irq
decl_stmt|;
comment|/* 	**	Get irq line from configuration space, 	**	and check for consistency. 	*/
name|irq
operator|=
name|getirq
argument_list|(
name|tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|irq
operator|==
literal|0xff
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
empty_stmt|;
comment|/* 	**	Search and unlink interrupt descriptor. 	*/
name|hook
operator|=
name|getintdescbytag
argument_list|(
name|irq
argument_list|,
name|tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|hook
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"\tno irq %d handler for pci %x\n"
argument_list|,
name|irq
argument_list|,
name|tag
operator|.
name|tag
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
empty_stmt|;
name|this
operator|=
operator|*
name|hook
expr_stmt|;
operator|*
name|hook
operator|=
name|this
operator|->
name|pcid_next
expr_stmt|;
comment|/* 	**	Message 	*/
name|printf
argument_list|(
literal|"\tirq %d handler %p(%p) unmapped for pci %x after %d ints.\n"
argument_list|,
name|irq
argument_list|,
name|this
operator|->
name|pcid_handler
argument_list|,
name|this
operator|->
name|pcid_argument
argument_list|,
name|this
operator|->
name|pcid_tag
operator|.
name|tag
argument_list|,
name|this
operator|->
name|pcid_tally
argument_list|)
expr_stmt|;
comment|/* 	**	If this irq no longer included in the mask, remove it. 	*/
if|if
condition|(
operator|!
name|getintdescbymptr
argument_list|(
name|irq
argument_list|,
name|this
operator|->
name|pcid_maskptr
argument_list|)
condition|)
operator|(
name|void
operator|)
name|pcibus
operator|->
name|pb_imaskexc
argument_list|(
name|irq
argument_list|,
name|this
operator|->
name|pcid_maskptr
argument_list|)
expr_stmt|;
name|tail
operator|=
name|pci_int_desc
index|[
name|irq
index|]
expr_stmt|;
if|if
condition|(
name|tail
operator|==
name|NULL
condition|)
block|{
comment|/* 		**	Remove the old handler. 		*/
name|result
operator|=
name|pcibus
operator|->
name|pb_idetach
argument_list|(
name|irq
argument_list|,
operator|(
name|inthand2_t
operator|*
operator|)
name|this
operator|->
name|pcid_handler
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
condition|)
name|printf
argument_list|(
literal|"\tirq %d: cannot remove handler.\n"
argument_list|,
name|irq
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tail
operator|->
name|pcid_next
operator|==
name|NULL
condition|)
block|{
comment|/* 		**	Remove the shared int handler. 		**	Install the last remaining handler. 		*/
name|oldspl
operator|=
name|splq
argument_list|(
literal|1ul
operator|<<
name|irq
argument_list|)
expr_stmt|;
name|result
operator|=
name|pcibus
operator|->
name|pb_idetach
argument_list|(
name|irq
argument_list|,
name|pci_int
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
condition|)
name|printf
argument_list|(
literal|"\tirq %d: cannot remove handler.\n"
argument_list|,
name|irq
argument_list|)
expr_stmt|;
name|result
operator|=
name|pcibus
operator|->
name|pb_iattach
argument_list|(
name|irq
argument_list|,
operator|(
name|inthand2_t
operator|*
operator|)
name|tail
operator|->
name|pcid_handler
argument_list|,
operator|(
name|int
operator|)
name|tail
operator|->
name|pcid_argument
argument_list|,
name|tail
operator|->
name|pcid_maskptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
condition|)
name|printf
argument_list|(
literal|"\tirq %d: cannot install handler.\n"
argument_list|,
name|irq
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|oldspl
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
name|free
argument_list|(
name|this
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_comment
comment|/*----------------------------------------------------------- ** **	Display of unknown devices. ** **----------------------------------------------------------- */
end_comment

begin_struct
struct|struct
name|vt
block|{
name|u_short
name|ident
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|vt
name|VendorTable
index|[]
init|=
block|{
block|{
literal|0x0e11
block|,
literal|"Compaq"
block|}
block|,
block|{
literal|0x1000
block|,
literal|"NCR/Symbios"
block|}
block|,
block|{
literal|0x1002
block|,
literal|"ATI Technologies Inc."
block|}
block|,
block|{
literal|0x1004
block|,
literal|"VLSI"
block|}
block|,
block|{
literal|0x100B
block|,
literal|"National Semiconductor"
block|}
block|,
block|{
literal|0x100E
block|,
literal|"Weitek"
block|}
block|,
block|{
literal|0x1011
block|,
literal|"Digital Equipment Corporation"
block|}
block|,
block|{
literal|0x1013
block|,
literal|"Cirrus Logic"
block|}
block|,
block|{
literal|0x101A
block|,
literal|"NCR"
block|}
block|,
block|{
literal|0x1022
block|,
literal|"AMD"
block|}
block|,
block|{
literal|0x102B
block|,
literal|"Matrox"
block|}
block|,
block|{
literal|0x102C
block|,
literal|"Chips& Technologies"
block|}
block|,
block|{
literal|0x1039
block|,
literal|"Silicon Integrated Systems"
block|}
block|,
block|{
literal|0x1042
block|,
literal|"SMC"
block|}
block|,
block|{
literal|0x1044
block|,
literal|"DPT"
block|}
block|,
block|{
literal|0x1045
block|,
literal|"OPTI"
block|}
block|,
block|{
literal|0x104B
block|,
literal|"Bus Logic"
block|}
block|,
block|{
literal|0x104C
block|,
literal|"TI"
block|}
block|,
block|{
literal|0x1060
block|,
literal|"UMC"
block|}
block|,
block|{
literal|0x1080
block|,
literal|"Contaq"
block|}
block|,
block|{
literal|0x1095
block|,
literal|"CMD"
block|}
block|,
block|{
literal|0x10b9
block|,
literal|"ACER Labs"
block|}
block|,
block|{
literal|0x10c8
block|,
literal|"NeoMagic"
block|}
block|,
block|{
literal|0x1106
block|,
literal|"VIA Technologies"
block|}
block|,
block|{
literal|0x5333
block|,
literal|"S3 Inc."
block|}
block|,
block|{
literal|0x8086
block|,
literal|"Intel Corporation"
block|}
block|,
block|{
literal|0x9004
block|,
literal|"Adaptec"
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_typedef
typedef|typedef
struct|struct
block|{
specifier|const
name|int
name|subclass
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|}
name|subclass_name
typedef|;
end_typedef

begin_comment
comment|/* 0x00 prehistoric subclasses */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|subclass_name
name|old_subclasses
index|[]
init|=
block|{
block|{
literal|0x00
block|,
literal|"misc"
block|}
block|,
block|{
literal|0x01
block|,
literal|"vga"
block|}
block|,
block|{
literal|0x00
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 0x01 mass storage subclasses */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|subclass_name
name|storage_subclasses
index|[]
init|=
block|{
block|{
literal|0x00
block|,
literal|"scsi"
block|}
block|,
block|{
literal|0x01
block|,
literal|"ide"
block|}
block|,
block|{
literal|0x02
block|,
literal|"floppy"
block|}
block|,
block|{
literal|0x03
block|,
literal|"ipi"
block|}
block|,
block|{
literal|0x80
block|,
literal|"misc"
block|}
block|,
block|{
literal|0x00
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 0x02 network subclasses */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|subclass_name
name|network_subclasses
index|[]
init|=
block|{
block|{
literal|0x00
block|,
literal|"ethernet"
block|}
block|,
block|{
literal|0x01
block|,
literal|"tokenring"
block|}
block|,
block|{
literal|0x02
block|,
literal|"fddi"
block|}
block|,
block|{
literal|0x80
block|,
literal|"misc"
block|}
block|,
block|{
literal|0x00
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 0x03 display subclasses */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|subclass_name
name|display_subclasses
index|[]
init|=
block|{
block|{
literal|0x00
block|,
literal|"vga"
block|}
block|,
block|{
literal|0x01
block|,
literal|"xga"
block|}
block|,
block|{
literal|0x80
block|,
literal|"misc"
block|}
block|,
block|{
literal|0x00
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 0x04 multimedia subclasses */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|subclass_name
name|multimedia_subclasses
index|[]
init|=
block|{
block|{
literal|0x00
block|,
literal|"video"
block|}
block|,
block|{
literal|0x01
block|,
literal|"audio"
block|}
block|,
block|{
literal|0x80
block|,
literal|"misc"
block|}
block|,
block|{
literal|0x00
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 0x05 memory subclasses */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|subclass_name
name|memory_subclasses
index|[]
init|=
block|{
block|{
literal|0x00
block|,
literal|"ram"
block|}
block|,
block|{
literal|0x01
block|,
literal|"flash"
block|}
block|,
block|{
literal|0x80
block|,
literal|"misc"
block|}
block|,
block|{
literal|0x00
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 0x06 bridge subclasses */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|subclass_name
name|bridge_subclasses
index|[]
init|=
block|{
block|{
literal|0x00
block|,
literal|"host"
block|}
block|,
block|{
literal|0x01
block|,
literal|"isa"
block|}
block|,
block|{
literal|0x02
block|,
literal|"eisa"
block|}
block|,
block|{
literal|0x03
block|,
literal|"mc"
block|}
block|,
block|{
literal|0x04
block|,
literal|"pci"
block|}
block|,
block|{
literal|0x05
block|,
literal|"pcmcia"
block|}
block|,
block|{
literal|0x07
block|,
literal|"cardbus"
block|}
block|,
block|{
literal|0x80
block|,
literal|"misc"
block|}
block|,
block|{
literal|0x00
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|subclass_name
modifier|*
specifier|const
name|subclasses
index|[]
init|=
block|{
name|old_subclasses
block|,
name|storage_subclasses
block|,
name|network_subclasses
block|,
name|display_subclasses
block|,
name|multimedia_subclasses
block|,
name|memory_subclasses
block|,
name|bridge_subclasses
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|majclasses
index|[]
init|=
block|{
literal|"old"
block|,
literal|"storage"
block|,
literal|"network"
block|,
literal|"display"
block|,
literal|"multimedia"
block|,
literal|"memory"
block|,
literal|"bridge"
block|,
literal|"comms"
block|,
literal|"system"
block|,
literal|"input"
block|,
literal|"docking"
block|,
literal|"processor"
block|,
literal|"serial"
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|not_supported
parameter_list|(
name|pcici_t
name|tag
parameter_list|,
name|u_long
name|type
parameter_list|)
block|{
name|u_long
name|reg
decl_stmt|;
name|u_long
name|data
decl_stmt|;
name|u_char
name|class
decl_stmt|;
name|u_char
name|subclass
decl_stmt|;
name|struct
name|vt
modifier|*
name|vp
decl_stmt|;
name|int
name|pciint
decl_stmt|;
name|int
name|irq
decl_stmt|;
comment|/* 	**	lookup the names. 	*/
for|for
control|(
name|vp
operator|=
name|VendorTable
init|;
name|vp
operator|->
name|ident
condition|;
name|vp
operator|++
control|)
if|if
condition|(
name|vp
operator|->
name|ident
operator|==
operator|(
name|type
operator|&
literal|0xffff
operator|)
condition|)
break|break;
comment|/* 	**	and display them. 	*/
if|if
condition|(
name|vp
operator|->
name|ident
condition|)
name|printf
argument_list|(
name|vp
operator|->
name|name
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"vendor=0x%04lx"
argument_list|,
name|type
operator|&
literal|0xffff
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|", device=0x%04lx"
argument_list|,
name|type
operator|>>
literal|16
argument_list|)
expr_stmt|;
name|data
operator|=
name|pci_conf_read
argument_list|(
name|tag
argument_list|,
name|PCI_CLASS_REG
argument_list|)
expr_stmt|;
name|class
operator|=
operator|(
name|data
operator|>>
literal|24
operator|)
operator|&
literal|0xff
expr_stmt|;
name|subclass
operator|=
operator|(
name|data
operator|>>
literal|16
operator|)
operator|&
literal|0xff
expr_stmt|;
if|if
condition|(
name|class
operator|<
sizeof|sizeof
argument_list|(
name|majclasses
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|majclasses
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|", class=%s"
argument_list|,
name|majclasses
index|[
name|class
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|", class=0x%02x"
argument_list|,
name|class
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|class
operator|<
sizeof|sizeof
argument_list|(
name|subclasses
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|subclasses
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
specifier|const
name|subclass_name
modifier|*
name|p
init|=
name|subclasses
index|[
name|class
index|]
decl_stmt|;
while|while
condition|(
name|p
operator|->
name|name
operator|&&
operator|(
name|p
operator|->
name|subclass
operator|!=
name|subclass
operator|)
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|name
condition|)
block|{
name|printf
argument_list|(
literal|" (%s)"
argument_list|,
name|p
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|" (unknown subclass 0x%02x)"
argument_list|,
name|subclass
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|printf
argument_list|(
literal|", subclass=0x%02x"
argument_list|,
name|subclass
argument_list|)
expr_stmt|;
block|}
name|data
operator|=
name|pci_conf_read
argument_list|(
name|tag
argument_list|,
name|PCI_INTERRUPT_REG
argument_list|)
expr_stmt|;
name|pciint
operator|=
name|PCI_INTERRUPT_PIN_EXTRACT
argument_list|(
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|pciint
condition|)
block|{
name|printf
argument_list|(
literal|" int %c irq "
argument_list|,
literal|0x60
operator|+
name|pciint
argument_list|)
expr_stmt|;
name|irq
operator|=
name|PCI_INTERRUPT_LINE_EXTRACT
argument_list|(
name|data
argument_list|)
expr_stmt|;
comment|/* 		**	If it's zero, the isa irq number is unknown, 		**	and we cannot bind the pci interrupt. 		*/
if|if
condition|(
name|irq
operator|&&
operator|(
name|irq
operator|!=
literal|0xff
operator|)
condition|)
name|printf
argument_list|(
literal|"%d"
argument_list|,
name|irq
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"??"
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
if|if
condition|(
name|class
operator|!=
operator|(
name|PCI_CLASS_BRIDGE
operator|>>
literal|24
operator|)
condition|)
name|printf
argument_list|(
literal|" [no driver assigned]"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
block|{
if|if
condition|(
name|class
operator|==
operator|(
name|PCI_CLASS_BRIDGE
operator|>>
literal|24
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"configuration space registers:"
argument_list|)
expr_stmt|;
for|for
control|(
name|reg
operator|=
literal|0
init|;
name|reg
operator|<
literal|0x100
condition|;
name|reg
operator|+=
literal|4
control|)
block|{
if|if
condition|(
operator|(
name|reg
operator|&
literal|0x0f
operator|)
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"\n%02lx:\t"
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%08lx "
argument_list|,
name|pci_conf_read
argument_list|(
name|tag
argument_list|,
name|reg
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|reg
operator|=
name|PCI_MAP_REG_START
init|;
name|reg
operator|<
name|PCI_MAP_REG_END
condition|;
name|reg
operator|+=
literal|4
control|)
block|{
name|data
operator|=
name|pci_conf_read
argument_list|(
name|tag
argument_list|,
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|data
operator|&
operator|~
literal|7
operator|)
operator|==
literal|0
condition|)
continue|continue;
switch|switch
condition|(
name|data
operator|&
literal|7
condition|)
block|{
case|case
literal|1
case|:
case|case
literal|5
case|:
name|printf
argument_list|(
literal|"\tmap(%lx): io(%04lx)\n"
argument_list|,
name|reg
argument_list|,
name|data
operator|&
operator|~
literal|3
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0
case|:
name|printf
argument_list|(
literal|"\tmap(%lx): mem32(%08lx)\n"
argument_list|,
name|reg
argument_list|,
name|data
operator|&
operator|~
literal|7
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|printf
argument_list|(
literal|"\tmap(%lx): mem20(%05lx)\n"
argument_list|,
name|reg
argument_list|,
name|data
operator|&
operator|~
literal|7
argument_list|)
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|printf
argument_list|(
literal|"\tmap(%lx): mem64(%08lx%08lx)\n"
argument_list|,
name|reg
argument_list|,
name|pci_conf_read
argument_list|(
name|tag
argument_list|,
name|reg
operator|+
literal|4
argument_list|)
argument_list|,
name|data
operator|&
operator|~
literal|7
argument_list|)
expr_stmt|;
name|reg
operator|+=
literal|4
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * This is the user interface to the PCI configuration space.  */
end_comment

begin_function
specifier|static
name|void
name|pci_remember
parameter_list|(
name|int
name|bus
parameter_list|,
name|int
name|dev
parameter_list|,
name|int
name|func
parameter_list|,
name|struct
name|pci_device
modifier|*
name|dvp
parameter_list|)
block|{
name|struct
name|pci_conf
modifier|*
name|p
decl_stmt|;
name|pcici_t
name|tag
decl_stmt|;
if|if
condition|(
operator|++
name|pci_dev_list_count
operator|>
name|pci_dev_list_size
condition|)
block|{
name|struct
name|pci_conf
modifier|*
name|new
decl_stmt|;
name|pci_dev_list_size
operator|+=
literal|8
expr_stmt|;
name|MALLOC
argument_list|(
name|new
argument_list|,
expr|struct
name|pci_conf
operator|*
argument_list|,
name|pci_dev_list_size
operator|*
sizeof|sizeof
expr|*
name|new
argument_list|,
name|M_DEVL
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|new
condition|)
block|{
name|pci_dev_list_size
operator|-=
literal|8
expr_stmt|;
name|pci_dev_list_count
operator|--
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|pci_dev_list
condition|)
block|{
name|bcopy
argument_list|(
name|pci_dev_list
argument_list|,
name|new
argument_list|,
operator|(
operator|(
name|pci_dev_list_size
operator|-
literal|8
operator|)
operator|*
sizeof|sizeof
expr|*
name|new
operator|)
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|pci_dev_list
argument_list|,
name|M_DEVL
argument_list|)
expr_stmt|;
block|}
name|pci_dev_list
operator|=
name|new
expr_stmt|;
block|}
name|p
operator|=
operator|&
name|pci_dev_list
index|[
name|pci_dev_list_count
operator|-
literal|1
index|]
expr_stmt|;
name|p
operator|->
name|pc_sel
operator|.
name|pc_bus
operator|=
name|bus
expr_stmt|;
name|p
operator|->
name|pc_sel
operator|.
name|pc_dev
operator|=
name|dev
expr_stmt|;
name|p
operator|->
name|pc_sel
operator|.
name|pc_func
operator|=
name|func
expr_stmt|;
name|p
operator|->
name|pc_dvp
operator|=
name|dvp
expr_stmt|;
name|p
operator|->
name|pc_cb
operator|=
name|pcicb
expr_stmt|;
name|tag
operator|=
name|pcibus
operator|->
name|pb_tag
argument_list|(
name|bus
argument_list|,
name|dev
argument_list|,
name|func
argument_list|)
expr_stmt|;
name|p
operator|->
name|pc_hdr
operator|=
operator|(
name|pci_conf_read
argument_list|(
name|tag
argument_list|,
name|PCI_HEADER_MISC
argument_list|)
operator|>>
literal|16
operator|)
operator|&
literal|0xff
expr_stmt|;
name|p
operator|->
name|pc_devid
operator|=
name|pci_conf_read
argument_list|(
name|tag
argument_list|,
name|PCI_ID_REG
argument_list|)
expr_stmt|;
name|p
operator|->
name|pc_class
operator|=
name|pci_conf_read
argument_list|(
name|tag
argument_list|,
name|PCI_CLASS_REG
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|p
operator|->
name|pc_hdr
operator|&
literal|0x7f
condition|)
block|{
case|case
literal|0
case|:
name|p
operator|->
name|pc_subid
operator|=
name|pci_conf_read
argument_list|(
name|tag
argument_list|,
name|PCI_SUBID_REG0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|p
operator|->
name|pc_subid
operator|=
name|pci_conf_read
argument_list|(
name|tag
argument_list|,
name|PCI_SUBID_REG1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|p
operator|->
name|pc_subid
operator|=
name|pci_conf_read
argument_list|(
name|tag
argument_list|,
name|PCI_SUBID_REG2
argument_list|)
expr_stmt|;
break|break;
default|default:
name|p
operator|->
name|pc_subid
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|pci_open
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|oflags
parameter_list|,
name|int
name|devtype
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
if|if
condition|(
operator|(
name|oflags
operator|&
name|FWRITE
operator|)
operator|&&
name|securelevel
operator|>
literal|0
condition|)
block|{
return|return
name|EPERM
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pci_close
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|flag
parameter_list|,
name|int
name|devtype
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pci_ioctl
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|cmd
parameter_list|,
name|caddr_t
name|data
parameter_list|,
name|int
name|flag
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|pci_conf_io
modifier|*
name|cio
decl_stmt|;
name|struct
name|pci_io
modifier|*
name|io
decl_stmt|;
name|size_t
name|iolen
decl_stmt|;
name|int
name|error
decl_stmt|;
name|pcici_t
name|tag
decl_stmt|;
if|if
condition|(
name|cmd
operator|!=
name|PCIOCGETCONF
operator|&&
operator|!
operator|(
name|flag
operator|&
name|FWRITE
operator|)
condition|)
return|return
name|EPERM
return|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|PCIOCGETCONF
case|:
name|cio
operator|=
operator|(
expr|struct
name|pci_conf_io
operator|*
operator|)
name|data
expr_stmt|;
name|iolen
operator|=
name|min
argument_list|(
name|cio
operator|->
name|pci_len
argument_list|,
name|pci_dev_list_count
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|pci_conf
argument_list|)
argument_list|)
expr_stmt|;
name|cio
operator|->
name|pci_len
operator|=
name|pci_dev_list_count
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|pci_conf
argument_list|)
expr_stmt|;
name|error
operator|=
name|copyout
argument_list|(
name|pci_dev_list
argument_list|,
name|cio
operator|->
name|pci_buf
argument_list|,
name|iolen
argument_list|)
expr_stmt|;
break|break;
case|case
name|PCIOCREAD
case|:
name|io
operator|=
operator|(
expr|struct
name|pci_io
operator|*
operator|)
name|data
expr_stmt|;
switch|switch
condition|(
name|io
operator|->
name|pi_width
condition|)
block|{
case|case
literal|4
case|:
name|tag
operator|=
name|pcibus
operator|->
name|pb_tag
argument_list|(
name|io
operator|->
name|pi_sel
operator|.
name|pc_bus
argument_list|,
name|io
operator|->
name|pi_sel
operator|.
name|pc_dev
argument_list|,
name|io
operator|->
name|pi_sel
operator|.
name|pc_func
argument_list|)
expr_stmt|;
name|io
operator|->
name|pi_data
operator|=
name|pci_conf_read
argument_list|(
name|tag
argument_list|,
name|io
operator|->
name|pi_reg
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|2
case|:
case|case
literal|1
case|:
default|default:
name|error
operator|=
name|ENODEV
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|PCIOCWRITE
case|:
name|io
operator|=
operator|(
expr|struct
name|pci_io
operator|*
operator|)
name|data
expr_stmt|;
switch|switch
condition|(
name|io
operator|->
name|pi_width
condition|)
block|{
case|case
literal|4
case|:
name|tag
operator|=
name|pcibus
operator|->
name|pb_tag
argument_list|(
name|io
operator|->
name|pi_sel
operator|.
name|pc_bus
argument_list|,
name|io
operator|->
name|pi_sel
operator|.
name|pc_dev
argument_list|,
name|io
operator|->
name|pi_sel
operator|.
name|pc_func
argument_list|)
expr_stmt|;
name|pci_conf_write
argument_list|(
name|tag
argument_list|,
name|io
operator|->
name|pi_reg
argument_list|,
name|io
operator|->
name|pi_data
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|2
case|:
case|case
literal|1
case|:
default|default:
name|error
operator|=
name|ENODEV
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|PCIOCATTACHED
case|:
name|io
operator|=
operator|(
expr|struct
name|pci_io
operator|*
operator|)
name|data
expr_stmt|;
switch|switch
condition|(
name|io
operator|->
name|pi_width
condition|)
block|{
case|case
literal|4
case|:
block|{
name|int
name|i
init|=
name|pci_dev_list_count
decl_stmt|;
name|struct
name|pci_conf
modifier|*
name|p
init|=
name|pci_dev_list
decl_stmt|;
name|error
operator|=
name|ENODEV
expr_stmt|;
while|while
condition|(
name|i
operator|--
condition|)
block|{
if|if
condition|(
name|io
operator|->
name|pi_sel
operator|.
name|pc_bus
operator|==
name|p
operator|->
name|pc_sel
operator|.
name|pc_bus
operator|&&
name|io
operator|->
name|pi_sel
operator|.
name|pc_dev
operator|==
name|p
operator|->
name|pc_sel
operator|.
name|pc_dev
operator|&&
name|io
operator|->
name|pi_sel
operator|.
name|pc_func
operator|==
name|p
operator|->
name|pc_sel
operator|.
name|pc_func
condition|)
block|{
name|io
operator|->
name|pi_data
operator|=
operator|(
name|u_int32_t
operator|)
name|p
operator|->
name|pc_dvp
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|p
operator|++
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|2
case|:
case|case
literal|1
case|:
default|default:
name|error
operator|=
name|ENODEV
expr_stmt|;
break|break;
block|}
break|break;
default|default:
name|error
operator|=
name|ENOTTY
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|PCI_CDEV
value|78
end_define

begin_decl_stmt
specifier|static
name|struct
name|cdevsw
name|pcicdev
init|=
block|{
name|pci_open
block|,
name|pci_close
block|,
name|noread
block|,
name|nowrite
block|,
name|pci_ioctl
block|,
name|nostop
block|,
name|noreset
block|,
name|nodevtotty
block|,
name|noselect
block|,
name|nommap
block|,
name|nostrategy
block|,
literal|"pci"
block|,
literal|0
block|,
name|PCI_CDEV
block|}
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|DEVFS
end_ifdef

begin_decl_stmt
specifier|static
name|void
modifier|*
name|pci_devfs_token
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|pci_cdevinit
parameter_list|(
name|void
modifier|*
name|dummy
parameter_list|)
block|{
name|dev_t
name|dev
decl_stmt|;
name|dev
operator|=
name|makedev
argument_list|(
name|PCI_CDEV
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cdevsw_add
argument_list|(
operator|&
name|dev
argument_list|,
operator|&
name|pcicdev
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEVFS
name|pci_devfs_token
operator|=
name|devfs_add_devswf
argument_list|(
operator|&
name|pcicdev
argument_list|,
literal|0
argument_list|,
name|DV_CHR
argument_list|,
name|UID_ROOT
argument_list|,
name|GID_WHEEL
argument_list|,
literal|0644
argument_list|,
literal|"pci"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_expr_stmt
name|SYSINIT
argument_list|(
name|pcidev
argument_list|,
name|SI_SUB_DRIVERS
argument_list|,
name|SI_ORDER_MIDDLE
operator|+
name|PCI_CDEV
argument_list|,
name|pci_cdevinit
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NPCI */
end_comment

end_unit

