begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/************************************************************************** ** **  $Id: pci.c,v 1.24 1995/06/28 15:59:04 se Exp $ ** **  General subroutines for the PCI bus. **  pci_configure () ** **  FreeBSD ** **------------------------------------------------------------------------- ** ** Copyright (c) 1994 Wolfgang Stanglmeier.  All rights reserved. ** ** Redistribution and use in source and binary forms, with or without ** modification, are permitted provided that the following conditions ** are met: ** 1. Redistributions of source code must retain the above copyright **    notice, this list of conditions and the following disclaimer. ** 2. Redistributions in binary form must reproduce the above copyright **    notice, this list of conditions and the following disclaimer in the **    documentation and/or other materials provided with the distribution. ** 3. The name of the author may not be used to endorse or promote products **    derived from this software without specific prior written permission. ** ** THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR ** IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES ** OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. ** IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, ** INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT ** NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, ** DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY ** THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT ** (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF ** THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ** *************************************************************************** */
end_comment

begin_define
define|#
directive|define
name|__PCI_C__
value|"pl13 95/03/21"
end_define

begin_include
include|#
directive|include
file|<pci.h>
end_include

begin_if
if|#
directive|if
name|NPCI
operator|>
literal|0
end_if

begin_comment
comment|/*======================================================== ** **	#includes  and  declarations ** **======================================================== */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_comment
comment|/* declaration of wakeup(), used by vm.h */
end_comment

begin_include
include|#
directive|include
file|<sys/devconf.h>
end_include

begin_include
include|#
directive|include
file|<machine/cpu.h>
end_include

begin_comment
comment|/* bootverbose */
end_comment

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_param.h>
end_include

begin_include
include|#
directive|include
file|<machine/pmap.h>
end_include

begin_include
include|#
directive|include
file|<sys/devconf.h>
end_include

begin_include
include|#
directive|include
file|<pci/pcivar.h>
end_include

begin_include
include|#
directive|include
file|<pci/pcireg.h>
end_include

begin_include
include|#
directive|include
file|<pci/pcibus.h>
end_include

begin_define
define|#
directive|define
name|PCI_MAX_IRQ
value|(16)
end_define

begin_comment
comment|/*======================================================== ** **	Structs and Functions ** **======================================================== */
end_comment

begin_struct
struct|struct
name|pci_devconf
block|{
name|struct
name|kern_devconf
name|pdc_kdc
decl_stmt|;
name|struct
name|pci_info
name|pdc_pi
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|pcicb
block|{
name|struct
name|pcicb
modifier|*
name|pcicb_next
decl_stmt|;
name|struct
name|pcicb
modifier|*
name|pcicb_up
decl_stmt|;
name|struct
name|pcicb
modifier|*
name|pcicb_down
decl_stmt|;
name|pcici_t
name|pcicb_bridge
decl_stmt|;
name|u_long
name|pcicb_seen
decl_stmt|;
name|u_char
name|pcicb_bus
decl_stmt|;
name|u_char
name|pcicb_subordinate
decl_stmt|;
name|u_char
name|pcicb_flags
decl_stmt|;
define|#
directive|define
name|PCICB_ISAMEM
value|0x01
name|u_int
name|pcicb_mfrom
decl_stmt|;
name|u_int
name|pcicb_mupto
decl_stmt|;
name|u_int
name|pcicb_mamount
decl_stmt|;
name|u_short
name|pcicb_pfrom
decl_stmt|;
name|u_short
name|pcicb_pupto
decl_stmt|;
name|u_short
name|pcicb_pamount
decl_stmt|;
name|u_char
name|pcicb_bfrom
decl_stmt|;
name|u_char
name|pcicb_bupto
decl_stmt|;
name|u_long
name|pcicb_iobase
decl_stmt|;
name|u_long
name|pcicb_iolimit
decl_stmt|;
name|u_long
name|pcicb_membase
decl_stmt|;
name|u_long
name|pcicb_memlimit
decl_stmt|;
name|u_long
name|pcicb_p_membase
decl_stmt|;
name|u_long
name|pcicb_p_memlimit
decl_stmt|;
block|}
struct|;
end_struct

begin_function_decl
specifier|static
name|int
name|pci_externalize
parameter_list|(
name|struct
name|proc
modifier|*
parameter_list|,
name|struct
name|kern_devconf
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pci_internalize
parameter_list|(
name|struct
name|proc
modifier|*
parameter_list|,
name|struct
name|kern_devconf
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|not_supported
parameter_list|(
name|pcici_t
name|tag
parameter_list|,
name|u_long
name|type
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pci_bus_config
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pci_bridge_config
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*======================================================== ** **	Variables ** **======================================================== */
end_comment

begin_comment
comment|/* **      log2 of safe burst len (in words) */
end_comment

begin_decl_stmt
name|unsigned
name|pci_max_burst_len
init|=
literal|2
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|pci_mechanism
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|pci_maxdevice
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|pcibus
modifier|*
name|pcibus
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*-------------------------------------------------------- ** **	Local variables. ** **-------------------------------------------------------- */
end_comment

begin_decl_stmt
specifier|static
name|int
name|pci_conf_count
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|pci_info_done
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|pcicb
name|pcibus0
init|=
block|{
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
block|{
literal|0
block|}
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* real allocation */
literal|0
block|,
literal|0xFFFF
block|,
comment|/* iobase/limit */
literal|0x4000000
block|,
literal|0xFFFFFFFFu
block|,
comment|/* nonprefetch membase/limit */
literal|0x4000000
block|,
literal|0xFFFFFFFFu
comment|/* prefetch membase/limit */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|pcicb
modifier|*
name|pcicb
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*======================================================== ** **	pci_configure () ** **      Autoconfiguration of pci devices. ** **      May be called more than once. **      Any device is attached only once. ** **      Has to take care of mirrored devices, which are **      entailed by incomplete decoding of pci address lines. ** **======================================================== */
end_comment

begin_function
name|void
name|pci_configure
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
comment|/* 	**	check pci bus present 	*/
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pcibus_set
operator|.
name|ls_length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|pci_maxdevice
condition|)
break|break;
name|pcibus
operator|=
operator|(
expr|struct
name|pcibus
operator|*
operator|)
name|pcibus_set
operator|.
name|ls_items
index|[
name|i
index|]
expr_stmt|;
name|pcibus
operator|->
name|pb_setup
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|pci_maxdevice
condition|)
return|return;
comment|/* 	**	hello world .. 	*/
for|for
control|(
name|pcicb
operator|=
operator|&
name|pcibus0
init|;
name|pcicb
operator|!=
name|NULL
condition|;
control|)
block|{
name|pci_bus_config
argument_list|()
expr_stmt|;
if|if
condition|(
name|pcicb
operator|->
name|pcicb_down
condition|)
block|{
name|pcicb
operator|=
name|pcicb
operator|->
name|pcicb_down
expr_stmt|;
continue|continue;
block|}
empty_stmt|;
while|while
condition|(
name|pcicb
operator|&&
operator|!
name|pcicb
operator|->
name|pcicb_next
condition|)
name|pcicb
operator|=
name|pcicb
operator|->
name|pcicb_up
expr_stmt|;
if|if
condition|(
name|pcicb
condition|)
name|pcicb
operator|=
name|pcicb
operator|->
name|pcicb_next
expr_stmt|;
block|}
name|pci_conf_count
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/*======================================================== ** **	Subroutines for configuration. ** **======================================================== */
end_comment

begin_function
specifier|static
name|void
name|pci_register_io
parameter_list|(
name|struct
name|pcicb
modifier|*
name|cb
parameter_list|,
name|u_int
name|base
parameter_list|,
name|u_int
name|limit
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|PCI_BRIDGE_DEBUG
name|printf
argument_list|(
literal|"register_io:  bus=%d base=%x limit=%x\n"
argument_list|,
name|cb
operator|->
name|pcicb_bus
argument_list|,
name|base
argument_list|,
name|limit
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|cb
operator|->
name|pcicb_pfrom
operator|||
name|base
operator|<
name|cb
operator|->
name|pcicb_pfrom
condition|)
name|cb
operator|->
name|pcicb_pfrom
operator|=
name|base
expr_stmt|;
if|if
condition|(
name|limit
operator|>
name|cb
operator|->
name|pcicb_pupto
condition|)
name|cb
operator|->
name|pcicb_pupto
operator|=
name|limit
expr_stmt|;
comment|/* 	**	XXX should set bridge io mapping here 	**	but it can be mapped in 4k blocks only, 	**	leading to conflicts with isa/eisa .. 	*/
block|}
end_function

begin_function
specifier|static
name|void
name|pci_register_memory
parameter_list|(
name|struct
name|pcicb
modifier|*
name|cb
parameter_list|,
name|u_int
name|base
parameter_list|,
name|u_int
name|limit
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|PCI_BRIDGE_DEBUG
name|printf
argument_list|(
literal|"register_mem: bus=%d base=%x limit=%x\n"
argument_list|,
name|cb
operator|->
name|pcicb_bus
argument_list|,
name|base
argument_list|,
name|limit
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|cb
operator|->
name|pcicb_mfrom
operator|||
name|base
operator|<
name|cb
operator|->
name|pcicb_mfrom
condition|)
name|cb
operator|->
name|pcicb_mfrom
operator|=
name|base
expr_stmt|;
if|if
condition|(
name|limit
operator|>
name|cb
operator|->
name|pcicb_mupto
condition|)
name|cb
operator|->
name|pcicb_mupto
operator|=
name|limit
expr_stmt|;
comment|/* 	**	set the bridges mapping 	** 	**	XXX should handle the 1Mb granularity. 	*/
if|if
condition|(
name|cb
operator|->
name|pcicb_bridge
operator|.
name|tag
condition|)
block|{
name|pci_conf_write
argument_list|(
name|cb
operator|->
name|pcicb_bridge
argument_list|,
name|PCI_PCI_BRIDGE_MEM_REG
argument_list|,
operator|(
name|cb
operator|->
name|pcicb_memlimit
operator|&
literal|0xffff0000
operator|)
operator||
operator|(
name|cb
operator|->
name|pcicb_membase
operator|>>
literal|16
operator|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\t[pci%d uses memory from %x to %x]\n"
argument_list|,
name|cb
operator|->
name|pcicb_bus
argument_list|,
operator|(
name|unsigned
operator|)
name|cb
operator|->
name|pcicb_membase
argument_list|,
operator|(
name|unsigned
operator|)
name|cb
operator|->
name|pcicb_memlimit
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* **	XXX This function is neither complete nor tested. **	It's only used if the bios hasn't done it's job **	of mapping the pci devices in the physical memory. */
end_comment

begin_function
specifier|static
name|u_int
name|pci_memalloc
parameter_list|(
name|struct
name|pcicb
modifier|*
name|cb
parameter_list|,
name|u_int
name|addr
parameter_list|,
name|u_int
name|size
parameter_list|)
block|{
name|u_int
name|result
init|=
literal|0
decl_stmt|,
name|limit
init|=
literal|0
decl_stmt|,
name|newbase
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|PCI_BRIDGE_DEBUG
name|printf
argument_list|(
literal|"memalloc:  bus=%d addr=%x size=%x ..\n"
argument_list|,
name|cb
operator|->
name|pcicb_bus
argument_list|,
name|addr
argument_list|,
name|size
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|cb
condition|)
goto|goto
name|done
goto|;
if|if
condition|(
operator|!
name|cb
operator|->
name|pcicb_membase
condition|)
block|{
name|printf
argument_list|(
literal|"memalloc: bus%d: membase not set.\n"
argument_list|,
name|cb
operator|->
name|pcicb_bus
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* 	**	get upper allocation limit 	*/
name|limit
operator|=
name|cb
operator|->
name|pcicb_memlimit
expr_stmt|;
if|if
condition|(
name|cb
operator|->
name|pcicb_mfrom
operator|&&
name|cb
operator|->
name|pcicb_mfrom
operator|<=
name|limit
condition|)
name|limit
operator|=
name|cb
operator|->
name|pcicb_mfrom
operator|-
literal|1
expr_stmt|;
comment|/* 	**	address fixed, and impossible to allocate ? 	*/
if|if
condition|(
name|addr
operator|&&
name|addr
operator|+
name|size
operator|-
literal|1
operator|>
name|limit
condition|)
goto|goto
name|done
goto|;
comment|/* 	**	get possible address 	*/
name|result
operator|=
name|addr
expr_stmt|;
if|if
condition|(
operator|!
name|result
condition|)
name|result
operator|=
operator|(
operator|(
name|limit
operator|+
literal|1
operator|)
operator|/
name|size
operator|-
literal|1
operator|)
operator|*
name|size
expr_stmt|;
comment|/* 	**	if not local available, request from parent. 	*/
if|if
condition|(
name|result
operator|<
name|cb
operator|->
name|pcicb_membase
condition|)
block|{
name|newbase
operator|=
name|pci_memalloc
argument_list|(
name|cb
operator|->
name|pcicb_up
argument_list|,
name|result
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|newbase
condition|)
name|cb
operator|->
name|pcicb_membase
operator|=
name|result
expr_stmt|;
else|else
name|result
operator|=
literal|0
expr_stmt|;
block|}
name|done
label|:
if|if
condition|(
name|result
condition|)
name|pci_register_memory
argument_list|(
name|cb
argument_list|,
name|result
argument_list|,
name|result
operator|+
name|size
operator|-
literal|1
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PCI_BRIDGE_DEBUG
name|printf
argument_list|(
literal|"memalloc:  bus=%d addr=%x size=%x --> %x (limit=%x).\n"
argument_list|,
name|cb
operator|->
name|pcicb_bus
argument_list|,
name|addr
argument_list|,
name|size
argument_list|,
name|result
argument_list|,
name|limit
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_comment
comment|/*======================================================== ** **	pci_bus_config() ** **	Autoconfiguration of one pci bus. ** **======================================================== */
end_comment

begin_function
specifier|static
name|void
name|pci_bus_config
parameter_list|(
name|void
parameter_list|)
block|{
name|u_char
name|device
decl_stmt|;
name|u_char
name|reg
decl_stmt|;
name|pcici_t
name|tag
decl_stmt|,
name|mtag
decl_stmt|;
name|pcidi_t
name|type
decl_stmt|;
name|u_long
name|data
decl_stmt|;
name|int
name|unit
decl_stmt|;
name|int
name|pciint
decl_stmt|;
name|int
name|irq
decl_stmt|;
name|char
modifier|*
name|name
init|=
literal|0
decl_stmt|;
name|int
name|dvi
decl_stmt|;
name|struct
name|pci_device
modifier|*
name|dvp
init|=
literal|0
decl_stmt|;
name|struct
name|pci_devconf
modifier|*
name|pdcp
decl_stmt|;
comment|/* 	**	first initialize the bridge (bus controller chip) 	*/
name|pci_bridge_config
argument_list|()
expr_stmt|;
ifndef|#
directive|ifndef
name|PCI_QUIET
name|printf
argument_list|(
literal|"Probing for devices on the %s%d bus:\n"
argument_list|,
name|pcibus
operator|->
name|pb_name
argument_list|,
name|pcicb
operator|->
name|pcicb_bus
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pci_info_done
condition|)
block|{
name|pci_info_done
operator|=
literal|1
expr_stmt|;
name|printf
argument_list|(
literal|"\tconfiguration mode %d allows %d devices.\n"
argument_list|,
name|pci_mechanism
argument_list|,
name|pci_maxdevice
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
endif|#
directive|endif
for|for
control|(
name|device
operator|=
literal|0
init|;
name|device
operator|<
name|pci_maxdevice
condition|;
name|device
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|pcicb
operator|->
name|pcicb_seen
operator|>>
name|device
operator|)
operator|&
literal|1
condition|)
continue|continue;
name|tag
operator|=
name|pcibus
operator|->
name|pb_tag
argument_list|(
name|pcicb
operator|->
name|pcicb_bus
argument_list|,
name|device
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|type
operator|=
name|pcibus
operator|->
name|pb_read
argument_list|(
name|tag
argument_list|,
name|PCI_ID_REG
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|!
name|type
operator|)
operator|||
operator|(
name|type
operator|==
literal|0xfffffffful
operator|)
condition|)
continue|continue;
comment|/* 		**	lookup device in ioconfiguration: 		*/
for|for
control|(
name|dvi
operator|=
literal|0
init|;
name|dvi
operator|<
name|pcidevice_set
operator|.
name|ls_length
condition|;
name|dvi
operator|++
control|)
block|{
name|dvp
operator|=
operator|(
expr|struct
name|pci_device
operator|*
operator|)
name|pcidevice_set
operator|.
name|ls_items
index|[
name|dvi
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|name
operator|=
call|(
modifier|*
name|dvp
operator|->
name|pd_probe
call|)
argument_list|(
name|tag
argument_list|,
name|type
argument_list|)
operator|)
condition|)
break|break;
name|dvp
operator|=
name|NULL
expr_stmt|;
block|}
empty_stmt|;
comment|/* 		**	check for mirrored devices. 		*/
if|if
condition|(
name|device
operator|&
literal|0x10
condition|)
block|{
name|mtag
operator|=
name|pcibus
operator|->
name|pb_tag
argument_list|(
name|pcicb
operator|->
name|pcicb_bus
argument_list|,
call|(
name|u_char
call|)
argument_list|(
name|device
operator|&
operator|~
literal|0x10
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|device
operator|&
literal|0x08
condition|)
block|{
name|mtag
operator|=
name|pcibus
operator|->
name|pb_tag
argument_list|(
name|pcicb
operator|->
name|pcicb_bus
argument_list|,
call|(
name|u_char
call|)
argument_list|(
name|device
operator|&
operator|~
literal|0x08
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
goto|goto
name|real_device
goto|;
if|if
condition|(
name|type
operator|!=
name|pcibus
operator|->
name|pb_read
argument_list|(
name|mtag
argument_list|,
name|PCI_ID_REG
argument_list|)
condition|)
goto|goto
name|real_device
goto|;
for|for
control|(
name|reg
operator|=
name|PCI_MAP_REG_START
init|;
name|reg
operator|<
name|PCI_MAP_REG_END
condition|;
name|reg
operator|+=
literal|4
control|)
if|if
condition|(
name|pcibus
operator|->
name|pb_read
argument_list|(
name|tag
argument_list|,
name|reg
argument_list|)
operator|!=
name|pcibus
operator|->
name|pb_read
argument_list|(
name|mtag
argument_list|,
name|reg
argument_list|)
condition|)
goto|goto
name|real_device
goto|;
ifndef|#
directive|ifndef
name|PCI_QUIET
if|if
condition|(
name|dvp
operator|==
name|NULL
condition|)
continue|continue;
name|printf
argument_list|(
literal|"%s?<%s> mirrored on pci%d:%d\n"
argument_list|,
name|dvp
operator|->
name|pd_name
argument_list|,
name|name
argument_list|,
name|pcicb
operator|->
name|pcicb_bus
argument_list|,
name|device
argument_list|)
expr_stmt|;
endif|#
directive|endif
continue|continue;
name|real_device
label|:
if|if
condition|(
name|dvp
operator|==
name|NULL
condition|)
block|{
ifndef|#
directive|ifndef
name|PCI_QUIET
if|if
condition|(
name|pci_conf_count
condition|)
continue|continue;
name|printf
argument_list|(
literal|"%s%d:%d: "
argument_list|,
name|pcibus
operator|->
name|pb_name
argument_list|,
name|pcicb
operator|->
name|pcicb_bus
argument_list|,
name|device
argument_list|)
expr_stmt|;
name|not_supported
argument_list|(
name|tag
argument_list|,
name|type
argument_list|)
expr_stmt|;
endif|#
directive|endif
continue|continue;
block|}
empty_stmt|;
name|pcicb
operator|->
name|pcicb_seen
operator||=
operator|(
literal|1ul
operator|<<
name|device
operator|)
expr_stmt|;
comment|/* 		**	Get and increment the unit. 		*/
name|unit
operator|=
operator|(
operator|*
name|dvp
operator|->
name|pd_count
operator|)
operator|++
expr_stmt|;
comment|/* 		**	ignore device ? 		*/
if|if
condition|(
operator|!
operator|*
name|name
condition|)
continue|continue;
comment|/* 		**	Announce this device 		*/
name|printf
argument_list|(
literal|"%s%d<%s> rev %d"
argument_list|,
name|dvp
operator|->
name|pd_name
argument_list|,
name|unit
argument_list|,
name|name
argument_list|,
operator|(
name|unsigned
operator|)
name|pci_conf_read
argument_list|(
name|tag
argument_list|,
name|PCI_CLASS_REG
argument_list|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
comment|/* 		**	Get the int pin number (pci interrupt number a-d) 		**	from the pci configuration space. 		*/
name|data
operator|=
name|pcibus
operator|->
name|pb_read
argument_list|(
name|tag
argument_list|,
name|PCI_INTERRUPT_REG
argument_list|)
expr_stmt|;
name|pciint
operator|=
name|PCI_INTERRUPT_PIN_EXTRACT
argument_list|(
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|pciint
condition|)
block|{
name|printf
argument_list|(
literal|" int %c irq "
argument_list|,
literal|0x60
operator|+
name|pciint
argument_list|)
expr_stmt|;
name|irq
operator|=
name|PCI_INTERRUPT_LINE_EXTRACT
argument_list|(
name|data
argument_list|)
expr_stmt|;
comment|/* 			**	If it's zero, the isa irq number is unknown, 			**	and we cannot bind the pci interrupt. 			*/
if|if
condition|(
name|irq
condition|)
name|printf
argument_list|(
literal|"%d"
argument_list|,
name|irq
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"??"
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
name|printf
argument_list|(
literal|" on pci%d:%d\n"
argument_list|,
name|pcicb
operator|->
name|pcicb_bus
argument_list|,
name|device
argument_list|)
expr_stmt|;
comment|/* 		**	Read the current mapping, 		**	and update the pcicb fields. 		*/
for|for
control|(
name|reg
operator|=
name|PCI_MAP_REG_START
init|;
name|reg
operator|<
name|PCI_MAP_REG_END
condition|;
name|reg
operator|+=
literal|4
control|)
block|{
name|u_int
name|map
decl_stmt|,
name|addr
decl_stmt|,
name|size
decl_stmt|;
name|data
operator|=
name|pci_conf_read
argument_list|(
name|tag
argument_list|,
name|PCI_CLASS_REG
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|data
operator|&
operator|(
name|PCI_CLASS_MASK
operator||
name|PCI_SUBCLASS_MASK
operator|)
condition|)
block|{
case|case
name|PCI_CLASS_BRIDGE
operator||
name|PCI_SUBCLASS_BRIDGE_PCI
case|:
continue|continue;
block|}
empty_stmt|;
name|map
operator|=
name|pcibus
operator|->
name|pb_read
argument_list|(
name|tag
argument_list|,
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|map
operator|&
name|PCI_MAP_MEMORY_ADDRESS_MASK
operator|)
condition|)
continue|continue;
name|pcibus
operator|->
name|pb_write
argument_list|(
name|tag
argument_list|,
name|reg
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
name|data
operator|=
name|pcibus
operator|->
name|pb_read
argument_list|(
name|tag
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|pcibus
operator|->
name|pb_write
argument_list|(
name|tag
argument_list|,
name|reg
argument_list|,
name|map
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|data
operator|&
literal|7
condition|)
block|{
default|default:
continue|continue;
case|case
literal|1
case|:
case|case
literal|5
case|:
name|size
operator|=
operator|-
operator|(
name|data
operator|&
name|PCI_MAP_IO_ADDRESS_MASK
operator|)
expr_stmt|;
name|addr
operator|=
name|map
operator|&
name|PCI_MAP_IO_ADDRESS_MASK
expr_stmt|;
name|pci_register_io
argument_list|(
name|pcicb
argument_list|,
name|addr
argument_list|,
name|addr
operator|+
name|size
operator|-
literal|1
argument_list|)
expr_stmt|;
name|pcicb
operator|->
name|pcicb_pamount
operator|+=
name|size
expr_stmt|;
break|break;
case|case
literal|0
case|:
case|case
literal|2
case|:
case|case
literal|4
case|:
name|size
operator|=
operator|-
operator|(
name|data
operator|&
name|PCI_MAP_MEMORY_ADDRESS_MASK
operator|)
expr_stmt|;
name|addr
operator|=
name|map
operator|&
name|PCI_MAP_MEMORY_ADDRESS_MASK
expr_stmt|;
if|if
condition|(
name|addr
operator|>=
literal|0x100000
condition|)
block|{
name|pci_register_memory
argument_list|(
name|pcicb
argument_list|,
name|addr
argument_list|,
name|addr
operator|+
name|size
operator|-
literal|1
argument_list|)
expr_stmt|;
name|pcicb
operator|->
name|pcicb_mamount
operator|+=
name|size
expr_stmt|;
block|}
else|else
block|{
name|pcicb
operator|->
name|pcicb_flags
operator||=
name|PCICB_ISAMEM
expr_stmt|;
block|}
empty_stmt|;
break|break;
block|}
empty_stmt|;
if|if
condition|(
operator|!
name|bootverbose
condition|)
continue|continue;
name|printf
argument_list|(
literal|"\tmapreg[%02x] type=%d addr=%08x size=%04x.\n"
argument_list|,
name|reg
argument_list|,
name|map
operator|&
literal|7
argument_list|,
name|addr
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
comment|/* 		**	Allocate a devconf structure 		**	We should, and eventually will, set the 		**	parent pointer to a pci bus devconf structure, 		**	and arrange to set the state field dynamically. 		*/
name|pdcp
operator|=
operator|(
expr|struct
name|pci_devconf
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|pci_devconf
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|pdcp
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|pci_devconf
argument_list|)
argument_list|)
expr_stmt|;
name|pdcp
operator|->
name|pdc_pi
operator|.
name|pi_bus
operator|=
name|pcicb
operator|->
name|pcicb_bus
expr_stmt|;
name|pdcp
operator|->
name|pdc_pi
operator|.
name|pi_device
operator|=
name|device
expr_stmt|;
name|pdcp
operator|->
name|pdc_kdc
operator|.
name|kdc_name
operator|=
name|dvp
operator|->
name|pd_name
expr_stmt|;
name|pdcp
operator|->
name|pdc_kdc
operator|.
name|kdc_unit
operator|=
name|unit
expr_stmt|;
name|pdcp
operator|->
name|pdc_kdc
operator|.
name|kdc_md
operator|.
name|mddc_devtype
operator|=
name|MDDT_PCI
expr_stmt|;
name|pdcp
operator|->
name|pdc_kdc
operator|.
name|kdc_externalize
operator|=
name|pci_externalize
expr_stmt|;
name|pdcp
operator|->
name|pdc_kdc
operator|.
name|kdc_internalize
operator|=
name|pci_internalize
expr_stmt|;
name|pdcp
operator|->
name|pdc_kdc
operator|.
name|kdc_datalen
operator|=
name|PCI_EXTERNAL_LEN
expr_stmt|;
name|pdcp
operator|->
name|pdc_kdc
operator|.
name|kdc_parentdata
operator|=
operator|&
name|pdcp
operator|->
name|pdc_pi
expr_stmt|;
name|pdcp
operator|->
name|pdc_kdc
operator|.
name|kdc_state
operator|=
name|DC_UNKNOWN
expr_stmt|;
name|pdcp
operator|->
name|pdc_kdc
operator|.
name|kdc_description
operator|=
name|name
expr_stmt|;
name|pdcp
operator|->
name|pdc_kdc
operator|.
name|kdc_shutdown
operator|=
name|dvp
operator|->
name|pd_shutdown
expr_stmt|;
comment|/* 		**	And register this device 		*/
name|dev_attach
argument_list|(
operator|&
name|pdcp
operator|->
name|pdc_kdc
argument_list|)
expr_stmt|;
comment|/* 		**	attach device 		**	may produce additional log messages, 		**	i.e. when installing subdevices. 		*/
call|(
modifier|*
name|dvp
operator|->
name|pd_attach
call|)
argument_list|(
name|tag
argument_list|,
name|unit
argument_list|)
expr_stmt|;
comment|/* 		**	Special processing of certain classes 		*/
name|data
operator|=
name|pci_conf_read
argument_list|(
name|tag
argument_list|,
name|PCI_CLASS_REG
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|data
operator|&
operator|(
name|PCI_CLASS_MASK
operator||
name|PCI_SUBCLASS_MASK
operator|)
condition|)
block|{
name|struct
name|pcicb
modifier|*
name|this
decl_stmt|,
modifier|*
modifier|*
name|link
decl_stmt|;
name|unsigned
name|char
name|primary
decl_stmt|,
name|secondary
decl_stmt|,
name|subordinate
decl_stmt|;
name|u_int
name|command
decl_stmt|;
case|case
name|PCI_CLASS_BRIDGE
operator||
name|PCI_SUBCLASS_BRIDGE_PCI
case|:
comment|/* 			**	get current configuration of the bridge. 			*/
name|data
operator|=
name|pci_conf_read
argument_list|(
name|tag
argument_list|,
name|PCI_PCI_BRIDGE_BUS_REG
argument_list|)
expr_stmt|;
name|primary
operator|=
name|PCI_PRIMARY_BUS_EXTRACT
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|secondary
operator|=
name|PCI_SECONDARY_BUS_EXTRACT
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|subordinate
operator|=
name|PCI_SUBORDINATE_BUS_EXTRACT
argument_list|(
name|data
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|PCI_QUIET
name|printf
argument_list|(
literal|"\tbridge from pci%d to pci%d through %d.\n"
argument_list|,
name|primary
argument_list|,
name|secondary
argument_list|,
name|subordinate
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\tmapping regs: io:%08x mem:%08x pmem:%08x"
argument_list|,
name|pci_conf_read
argument_list|(
name|tag
argument_list|,
name|PCI_PCI_BRIDGE_IO_REG
argument_list|)
argument_list|,
name|pci_conf_read
argument_list|(
name|tag
argument_list|,
name|PCI_PCI_BRIDGE_MEM_REG
argument_list|)
argument_list|,
name|pci_conf_read
argument_list|(
name|tag
argument_list|,
name|PCI_PCI_BRIDGE_PMEM_REG
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 			**	check for uninitialized bridge. 			*/
if|if
condition|(
name|secondary
operator|==
literal|0
operator|||
name|secondary
operator|<
name|primary
operator|||
name|pcicb
operator|->
name|pcicb_bus
operator|!=
name|primary
condition|)
block|{
name|printf
argument_list|(
literal|"\tINCORRECTLY or NEVER CONFIGURED.\n"
argument_list|)
expr_stmt|;
comment|/* 				**	disable this bridge 				*/
name|pcibus
operator|->
name|pb_write
argument_list|(
name|tag
argument_list|,
name|PCI_COMMAND_STATUS_REG
argument_list|,
literal|0xffff0000
argument_list|)
expr_stmt|;
name|secondary
operator|=
literal|0
expr_stmt|;
name|subordinate
operator|=
literal|0
expr_stmt|;
block|}
empty_stmt|;
comment|/* 			**  allocate bus descriptor for bus behind the bridge 			*/
name|link
operator|=
operator|&
name|pcicb
operator|->
name|pcicb_down
expr_stmt|;
while|while
condition|(
operator|*
name|link
condition|)
name|link
operator|=
operator|&
operator|(
operator|*
name|link
operator|)
operator|->
name|pcicb_next
expr_stmt|;
name|this
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|this
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
comment|/* 			**	Initialize this descriptor so far. 			**	(the initialization is completed just before 			**	scanning the bus behind the bridge. 			*/
name|bzero
argument_list|(
name|this
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|this
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|->
name|pcicb_up
operator|=
name|pcicb
expr_stmt|;
name|this
operator|->
name|pcicb_bridge
operator|=
name|tag
expr_stmt|;
name|this
operator|->
name|pcicb_bus
operator|=
name|secondary
expr_stmt|;
name|this
operator|->
name|pcicb_subordinate
operator|=
name|subordinate
expr_stmt|;
name|command
operator|=
name|pci_conf_read
argument_list|(
name|tag
argument_list|,
name|PCI_COMMAND_STATUS_REG
argument_list|)
expr_stmt|;
if|if
condition|(
name|command
operator|&
name|PCI_COMMAND_IO_ENABLE
condition|)
block|{
comment|/* 				**	Bridge was configured by the bios. 				**	Read out the mapped io region. 				*/
name|u_int
name|reg
decl_stmt|,
name|data
decl_stmt|,
name|mask
decl_stmt|;
name|reg
operator|=
name|pci_conf_read
argument_list|(
name|tag
argument_list|,
name|PCI_PCI_BRIDGE_IO_REG
argument_list|)
expr_stmt|;
name|pci_conf_write
argument_list|(
name|tag
argument_list|,
name|PCI_PCI_BRIDGE_IO_REG
argument_list|,
literal|0xFFFF
argument_list|)
expr_stmt|;
name|data
operator|=
name|pci_conf_read
argument_list|(
name|tag
argument_list|,
name|PCI_PCI_BRIDGE_IO_REG
argument_list|)
expr_stmt|;
name|pci_conf_write
argument_list|(
name|tag
argument_list|,
name|PCI_PCI_BRIDGE_IO_REG
argument_list|,
name|reg
operator|&
literal|0xffff
argument_list|)
expr_stmt|;
name|mask
operator|=
operator|(
literal|0xFF00
operator|^
operator|(
name|data
operator|&
literal|0xFF00
operator|)
operator|)
operator||
literal|0xFF
expr_stmt|;
name|this
operator|->
name|pcicb_iobase
operator|=
name|PCI_PPB_IOBASE_EXTRACT
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|this
operator|->
name|pcicb_iolimit
operator|=
name|PCI_PPB_IOLIMIT_EXTRACT
argument_list|(
name|reg
argument_list|)
operator||
name|mask
expr_stmt|;
comment|/* 				**	Note the used io space. 				*/
name|pci_register_io
argument_list|(
name|pcicb
argument_list|,
name|this
operator|->
name|pcicb_iobase
argument_list|,
name|this
operator|->
name|pcicb_iolimit
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
if|if
condition|(
name|command
operator|&
name|PCI_COMMAND_MEM_ENABLE
condition|)
block|{
comment|/* 				**	Bridge was configured by the bios. 				**	Read out the mapped memory regions. 				*/
name|u_int
name|reg
decl_stmt|,
name|data
decl_stmt|,
name|mask
decl_stmt|;
comment|/* 				**	non prefetchable memory 				*/
name|reg
operator|=
name|pci_conf_read
argument_list|(
name|tag
argument_list|,
name|PCI_PCI_BRIDGE_MEM_REG
argument_list|)
expr_stmt|;
name|pci_conf_write
argument_list|(
name|tag
argument_list|,
name|PCI_PCI_BRIDGE_MEM_REG
argument_list|,
literal|0xFFFFFFFF
argument_list|)
expr_stmt|;
name|data
operator|=
name|pci_conf_read
argument_list|(
name|tag
argument_list|,
name|PCI_PCI_BRIDGE_MEM_REG
argument_list|)
expr_stmt|;
name|pci_conf_write
argument_list|(
name|tag
argument_list|,
name|PCI_PCI_BRIDGE_MEM_REG
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|mask
operator|=
literal|0xFFFFFFFF
operator|^
operator|(
name|data
operator|&
literal|0xFFFF0000
operator|)
expr_stmt|;
name|this
operator|->
name|pcicb_membase
operator|=
name|PCI_PPB_MEMBASE_EXTRACT
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|this
operator|->
name|pcicb_memlimit
operator|=
name|PCI_PPB_MEMLIMIT_EXTRACT
argument_list|(
name|reg
argument_list|)
operator||
name|mask
expr_stmt|;
comment|/* 				**	Register used memory space. 				*/
name|pci_register_memory
argument_list|(
name|pcicb
argument_list|,
name|this
operator|->
name|pcicb_membase
argument_list|,
name|this
operator|->
name|pcicb_memlimit
argument_list|)
expr_stmt|;
comment|/* 				**	prefetchable memory 				*/
name|reg
operator|=
name|pci_conf_read
argument_list|(
name|tag
argument_list|,
name|PCI_PCI_BRIDGE_PMEM_REG
argument_list|)
expr_stmt|;
name|pci_conf_write
argument_list|(
name|tag
argument_list|,
name|PCI_PCI_BRIDGE_PMEM_REG
argument_list|,
literal|0xFFFFFFFF
argument_list|)
expr_stmt|;
name|data
operator|=
name|pci_conf_read
argument_list|(
name|tag
argument_list|,
name|PCI_PCI_BRIDGE_PMEM_REG
argument_list|)
expr_stmt|;
name|pci_conf_write
argument_list|(
name|tag
argument_list|,
name|PCI_PCI_BRIDGE_PMEM_REG
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|mask
operator|=
literal|0xFFFFFFFF
operator|^
operator|(
name|data
operator|&
literal|0xFFFF0000
operator|)
expr_stmt|;
name|this
operator|->
name|pcicb_p_membase
operator|=
name|PCI_PPB_MEMBASE_EXTRACT
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|this
operator|->
name|pcicb_p_memlimit
operator|=
name|PCI_PPB_MEMLIMIT_EXTRACT
argument_list|(
name|reg
argument_list|)
operator||
name|mask
expr_stmt|;
comment|/* 				**	Register used memory space. 				*/
name|pci_register_memory
argument_list|(
name|pcicb
argument_list|,
name|this
operator|->
name|pcicb_p_membase
argument_list|,
name|this
operator|->
name|pcicb_p_memlimit
argument_list|)
expr_stmt|;
block|}
comment|/* 			**	Link it in chain. 			*/
operator|*
name|link
operator|=
name|this
expr_stmt|;
comment|/* 			**	Update mapping info of parent bus. 			*/
if|if
condition|(
operator|!
name|pcicb
operator|->
name|pcicb_bfrom
operator|||
name|secondary
operator|<
name|pcicb
operator|->
name|pcicb_bfrom
condition|)
name|pcicb
operator|->
name|pcicb_bfrom
operator|=
name|secondary
expr_stmt|;
if|if
condition|(
name|subordinate
operator|>
name|pcicb
operator|->
name|pcicb_bupto
condition|)
name|pcicb
operator|->
name|pcicb_bupto
operator|=
name|subordinate
expr_stmt|;
break|break;
block|}
block|}
ifndef|#
directive|ifndef
name|PCI_QUIET
if|if
condition|(
name|pcicb
operator|->
name|pcicb_mamount
condition|)
name|printf
argument_list|(
literal|"%s%d: uses %d bytes of memory from %x upto %x.\n"
argument_list|,
name|pcibus
operator|->
name|pb_name
argument_list|,
name|pcicb
operator|->
name|pcicb_bus
argument_list|,
name|pcicb
operator|->
name|pcicb_mamount
argument_list|,
name|pcicb
operator|->
name|pcicb_mfrom
argument_list|,
name|pcicb
operator|->
name|pcicb_mupto
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcicb
operator|->
name|pcicb_pamount
condition|)
name|printf
argument_list|(
literal|"%s%d: uses %d bytes of I/O space from %x upto %x.\n"
argument_list|,
name|pcibus
operator|->
name|pb_name
argument_list|,
name|pcicb
operator|->
name|pcicb_bus
argument_list|,
name|pcicb
operator|->
name|pcicb_pamount
argument_list|,
name|pcicb
operator|->
name|pcicb_pfrom
argument_list|,
name|pcicb
operator|->
name|pcicb_pupto
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcicb
operator|->
name|pcicb_bfrom
condition|)
name|printf
argument_list|(
literal|"%s%d: subordinate busses from %x upto %x.\n"
argument_list|,
name|pcibus
operator|->
name|pb_name
argument_list|,
name|pcicb
operator|->
name|pcicb_bus
argument_list|,
name|pcicb
operator|->
name|pcicb_bfrom
argument_list|,
name|pcicb
operator|->
name|pcicb_bupto
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*======================================================== ** **	pci_bridge_config() ** **	Configuration of a pci bridge. ** **======================================================== */
end_comment

begin_function
specifier|static
name|void
name|pci_bridge_config
parameter_list|(
name|void
parameter_list|)
block|{
name|pcici_t
name|tag
decl_stmt|;
name|struct
name|pcicb
modifier|*
name|parent
decl_stmt|;
name|tag
operator|=
name|pcicb
operator|->
name|pcicb_bridge
expr_stmt|;
if|if
condition|(
operator|!
name|tag
operator|.
name|tag
condition|)
return|return;
if|if
condition|(
operator|!
name|pcicb
operator|->
name|pcicb_bus
condition|)
block|{
name|u_int
name|data
decl_stmt|;
comment|/* 		**	Get the lowest available bus number. 		*/
name|pcicb
operator|->
name|pcicb_bus
operator|=
operator|++
name|pcibus0
operator|.
name|pcicb_subordinate
expr_stmt|;
comment|/* 		**	and configure the bridge 		*/
name|data
operator|=
name|pci_conf_read
argument_list|(
name|tag
argument_list|,
name|PCI_PCI_BRIDGE_BUS_REG
argument_list|)
expr_stmt|;
name|data
operator|=
name|PCI_PRIMARY_BUS_INSERT
argument_list|(
name|data
argument_list|,
name|pcicb
operator|->
name|pcicb_up
operator|->
name|pcicb_bus
argument_list|)
expr_stmt|;
name|data
operator|=
name|PCI_SECONDARY_BUS_INSERT
argument_list|(
name|data
argument_list|,
name|pcicb
operator|->
name|pcicb_bus
argument_list|)
expr_stmt|;
name|data
operator|=
name|PCI_SUBORDINATE_BUS_INSERT
argument_list|(
name|data
argument_list|,
name|pcicb
operator|->
name|pcicb_bus
argument_list|)
expr_stmt|;
name|pci_conf_write
argument_list|(
name|tag
argument_list|,
name|PCI_PCI_BRIDGE_BUS_REG
argument_list|,
name|data
argument_list|)
expr_stmt|;
comment|/* 		**	Propagate the new upper bus number limit. 		*/
for|for
control|(
name|parent
operator|=
name|pcicb
operator|->
name|pcicb_up
init|;
name|parent
operator|!=
name|NULL
condition|;
name|parent
operator|=
name|parent
operator|->
name|pcicb_up
control|)
block|{
if|if
condition|(
name|parent
operator|->
name|pcicb_subordinate
operator|>=
name|pcicb
operator|->
name|pcicb_bus
condition|)
continue|continue;
name|parent
operator|->
name|pcicb_subordinate
operator|=
name|pcicb
operator|->
name|pcicb_bus
expr_stmt|;
if|if
condition|(
operator|!
name|parent
operator|->
name|pcicb_bridge
operator|.
name|tag
condition|)
continue|continue;
name|data
operator|=
name|pci_conf_read
argument_list|(
name|parent
operator|->
name|pcicb_bridge
argument_list|,
name|PCI_PCI_BRIDGE_BUS_REG
argument_list|)
expr_stmt|;
name|data
operator|=
name|PCI_SUBORDINATE_BUS_INSERT
argument_list|(
name|data
argument_list|,
name|pcicb
operator|->
name|pcicb_bus
argument_list|)
expr_stmt|;
name|pci_conf_write
argument_list|(
name|parent
operator|->
name|pcicb_bridge
argument_list|,
name|PCI_PCI_BRIDGE_BUS_REG
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|pcicb
operator|->
name|pcicb_membase
condition|)
block|{
name|u_int
name|size
init|=
literal|0x100000
decl_stmt|;
name|pcicb
operator|->
name|pcicb_membase
operator|=
name|pci_memalloc
argument_list|(
name|pcicb
operator|->
name|pcicb_up
argument_list|,
literal|0
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcicb
operator|->
name|pcicb_membase
condition|)
name|pcicb
operator|->
name|pcicb_memlimit
operator|=
name|pcicb
operator|->
name|pcicb_membase
operator|+
name|size
operator|-
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*----------------------------------------------------------------- ** **	The following functions are provided for the device driver **	to read/write the configuration space. ** **	pci_conf_read(): **		Read a long word from the pci configuration space. **		Requires a tag (from pcitag) and the register **		number (should be a long word alligned one). ** **	pci_conf_write(): **		Writes a long word to the pci configuration space. **		Requires a tag (from pcitag), the register number **		(should be a long word alligned one), and a value. ** **----------------------------------------------------------------- */
end_comment

begin_function
name|u_long
name|pci_conf_read
parameter_list|(
name|pcici_t
name|tag
parameter_list|,
name|u_long
name|reg
parameter_list|)
block|{
return|return
operator|(
name|pcibus
operator|->
name|pb_read
argument_list|(
name|tag
argument_list|,
name|reg
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|void
name|pci_conf_write
parameter_list|(
name|pcici_t
name|tag
parameter_list|,
name|u_long
name|reg
parameter_list|,
name|u_long
name|data
parameter_list|)
block|{
name|pcibus
operator|->
name|pb_write
argument_list|(
name|tag
argument_list|,
name|reg
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*----------------------------------------------------------------------- ** **	Map device into port space. ** **	Actually the device should have been mapped by the bios. **	This function only reads and verifies the value. ** **	PCI-Specification:  6.2.5.1: address maps ** **----------------------------------------------------------------------- */
end_comment

begin_function
name|int
name|pci_map_port
parameter_list|(
name|pcici_t
name|tag
parameter_list|,
name|u_long
name|reg
parameter_list|,
name|u_short
modifier|*
name|pa
parameter_list|)
block|{
name|unsigned
name|data
decl_stmt|,
name|ioaddr
decl_stmt|,
name|iosize
decl_stmt|;
name|struct
name|pcicb
modifier|*
name|link
init|=
name|pcicb
decl_stmt|;
comment|/* 	**	sanity check 	*/
if|if
condition|(
name|reg
operator|<
name|PCI_MAP_REG_START
operator|||
name|reg
operator|>=
name|PCI_MAP_REG_END
operator|||
operator|(
name|reg
operator|&
literal|3
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"pci_map_port failed: bad register=0x%x\n"
argument_list|,
operator|(
name|unsigned
operator|)
name|reg
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
empty_stmt|;
comment|/*if (pcicb->pcicb_flags& PCICB_NOIOSET) { 		printf ("pci_map_port failed: pci%d has not been configured for I/O access\n", 			pcicb->pcicb_bus); 		return (0); 	}*/
comment|/* 	**	get size and type of port 	** 	**	type is in the lowest two bits. 	**	If device requires 2^n bytes, the next 	**	n-2 bits are hardwired as 0. 	*/
name|ioaddr
operator|=
name|pcibus
operator|->
name|pb_read
argument_list|(
name|tag
argument_list|,
name|reg
argument_list|)
operator|&
name|PCI_MAP_IO_ADDRESS_MASK
expr_stmt|;
if|if
condition|(
operator|!
name|ioaddr
operator|||
name|ioaddr
operator|>
literal|0xfffful
condition|)
block|{
name|printf
argument_list|(
literal|"pci_map_port failed: not configured by bios.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
empty_stmt|;
name|pcibus
operator|->
name|pb_write
argument_list|(
name|tag
argument_list|,
name|reg
argument_list|,
literal|0xfffffffful
argument_list|)
expr_stmt|;
name|data
operator|=
name|pcibus
operator|->
name|pb_read
argument_list|(
name|tag
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|pcibus
operator|->
name|pb_write
argument_list|(
name|tag
argument_list|,
name|reg
argument_list|,
name|ioaddr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|data
operator|&
literal|0x03
operator|)
operator|!=
name|PCI_MAP_IO
condition|)
block|{
name|printf
argument_list|(
literal|"pci_map_port failed: bad port type=0x%x\n"
argument_list|,
operator|(
name|unsigned
operator|)
name|data
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
empty_stmt|;
name|iosize
operator|=
operator|-
operator|(
name|data
operator|&
name|PCI_MAP_IO_ADDRESS_MASK
operator|)
expr_stmt|;
if|if
condition|(
name|ioaddr
operator|<
name|pcicb
operator|->
name|pcicb_iobase
operator|||
name|ioaddr
operator|+
name|iosize
operator|>
name|pcicb
operator|->
name|pcicb_iolimit
condition|)
block|{
name|printf
argument_list|(
literal|"pci_map_port failed: device's iorange 0x%x-0x%x "
literal|"is incompatible with its bridge's range 0x%x-0x%x\n"
argument_list|,
operator|(
name|unsigned
operator|)
name|ioaddr
argument_list|,
operator|(
name|unsigned
operator|)
name|ioaddr
operator|+
name|iosize
operator|-
literal|1
argument_list|,
operator|(
name|unsigned
operator|)
name|pcicb
operator|->
name|pcicb_iobase
argument_list|,
operator|(
name|unsigned
operator|)
name|pcicb
operator|->
name|pcicb_iolimit
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
ifndef|#
directive|ifndef
name|PCI_QUIET
name|printf
argument_list|(
literal|"\treg%d: ioaddr=0x%x size=0x%x\n"
argument_list|,
operator|(
name|unsigned
operator|)
name|reg
argument_list|,
operator|(
name|unsigned
operator|)
name|ioaddr
argument_list|,
operator|(
name|unsigned
operator|)
name|iosize
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	**	set the configuration register of and 	**      return the address to the driver. 	**	Make sure to enable each upstream bridge 	**	so I/O and DMA can go all the way. 	*/
for|for
control|(
init|;
condition|;
control|)
block|{
name|data
operator|=
name|pcibus
operator|->
name|pb_read
argument_list|(
name|tag
argument_list|,
name|PCI_COMMAND_STATUS_REG
argument_list|)
operator|&
literal|0xffff
expr_stmt|;
name|data
operator||=
name|PCI_COMMAND_IO_ENABLE
operator||
name|PCI_COMMAND_MASTER_ENABLE
expr_stmt|;
operator|(
name|void
operator|)
name|pcibus
operator|->
name|pb_write
argument_list|(
name|tag
argument_list|,
name|PCI_COMMAND_STATUS_REG
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|link
operator|=
name|link
operator|->
name|pcicb_up
operator|)
operator|==
name|NULL
condition|)
break|break;
name|tag
operator|=
name|link
operator|->
name|pcicb_bridge
expr_stmt|;
block|}
operator|*
name|pa
operator|=
name|ioaddr
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*----------------------------------------------------------------------- ** **	Map device into virtual and physical space ** **	Actually the device should have been mapped by the bios. **	This function only reads and verifies the value. ** **      PCI-Specification:  6.2.5.1: address maps ** **----------------------------------------------------------------------- */
end_comment

begin_function
name|int
name|pci_map_mem
parameter_list|(
name|pcici_t
name|tag
parameter_list|,
name|u_long
name|reg
parameter_list|,
name|vm_offset_t
modifier|*
name|va
parameter_list|,
name|vm_offset_t
modifier|*
name|pa
parameter_list|)
block|{
name|struct
name|pcicb
modifier|*
name|link
init|=
name|pcicb
decl_stmt|;
name|unsigned
name|data
decl_stmt|,
name|paddr
decl_stmt|;
name|vm_size_t
name|psize
decl_stmt|,
name|poffs
decl_stmt|;
name|vm_offset_t
name|vaddr
decl_stmt|;
comment|/* 	**	sanity check 	*/
if|if
condition|(
name|reg
operator|<
name|PCI_MAP_REG_START
operator|||
name|reg
operator|>=
name|PCI_MAP_REG_END
operator|||
operator|(
name|reg
operator|&
literal|3
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"pci_map_mem failed: bad register=0x%x\n"
argument_list|,
operator|(
name|unsigned
operator|)
name|reg
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
empty_stmt|;
comment|/* 	**	save old mapping, get size and type of memory 	** 	**	type is in the lowest four bits. 	**	If device requires 2^n bytes, the next 	**	n-4 bits are read as 0. 	*/
name|paddr
operator|=
name|pcibus
operator|->
name|pb_read
argument_list|(
name|tag
argument_list|,
name|reg
argument_list|)
operator|&
name|PCI_MAP_MEMORY_ADDRESS_MASK
expr_stmt|;
name|pcibus
operator|->
name|pb_write
argument_list|(
name|tag
argument_list|,
name|reg
argument_list|,
literal|0xfffffffful
argument_list|)
expr_stmt|;
name|data
operator|=
name|pcibus
operator|->
name|pb_read
argument_list|(
name|tag
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|pcibus
operator|->
name|pb_write
argument_list|(
name|tag
argument_list|,
name|reg
argument_list|,
name|paddr
argument_list|)
expr_stmt|;
comment|/* 	**	check the type 	*/
if|if
condition|(
operator|(
name|data
operator|&
name|PCI_MAP_MEMORY_TYPE_MASK
operator|)
operator|!=
name|PCI_MAP_MEMORY_TYPE_32BIT
condition|)
block|{
name|printf
argument_list|(
literal|"pci_map_mem failed: bad memory type=0x%x\n"
argument_list|,
operator|(
name|unsigned
operator|)
name|data
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
empty_stmt|;
comment|/* 	**	get the size. 	*/
name|psize
operator|=
operator|-
operator|(
name|data
operator|&
name|PCI_MAP_MEMORY_ADDRESS_MASK
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|paddr
operator|||
name|paddr
operator|==
name|PCI_MAP_MEMORY_ADDRESS_MASK
condition|)
block|{
name|paddr
operator|=
name|pci_memalloc
argument_list|(
name|pcicb
argument_list|,
literal|0
argument_list|,
name|psize
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|paddr
condition|)
block|{
name|printf
argument_list|(
literal|"pci_map_mem: not configured by bios.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
empty_stmt|;
name|pci_register_memory
argument_list|(
name|pcicb
argument_list|,
name|paddr
argument_list|,
name|paddr
operator|+
name|psize
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
if|if
condition|(
name|paddr
operator|<
name|pcicb
operator|->
name|pcicb_membase
operator|||
name|paddr
operator|+
name|psize
operator|-
literal|1
operator|>
name|pcicb
operator|->
name|pcicb_memlimit
condition|)
block|{
name|printf
argument_list|(
literal|"pci_map_mem failed: device's memrange 0x%x-0x%x is "
literal|"incompatible with its bridge's memrange 0x%x-0x%x\n"
argument_list|,
operator|(
name|unsigned
operator|)
name|paddr
argument_list|,
call|(
name|unsigned
call|)
argument_list|(
name|paddr
operator|+
name|psize
operator|-
literal|1
argument_list|)
argument_list|,
operator|(
name|unsigned
operator|)
name|pcicb
operator|->
name|pcicb_membase
argument_list|,
operator|(
name|unsigned
operator|)
name|pcicb
operator|->
name|pcicb_memlimit
argument_list|)
expr_stmt|;
comment|/*		return (0);*/
comment|/* ACHTUNG: Ist der Code richtig, wenn eine PCI-PCI-Bridge fuer  * die PCI-Slots verwendet wird, aber die Onboard-Devices direkt   * an der CPU-PCI-Bridge haengen (Siehe Compaq Prolinea Problem) ???  */
block|}
name|pcibus
operator|->
name|pb_write
argument_list|(
name|tag
argument_list|,
name|reg
argument_list|,
name|paddr
argument_list|)
expr_stmt|;
comment|/* 	**	Truncate paddr to page boundary. 	**	(Or does pmap_mapdev the job?) 	*/
name|poffs
operator|=
name|paddr
operator|-
name|trunc_page
argument_list|(
name|paddr
argument_list|)
expr_stmt|;
name|vaddr
operator|=
operator|(
name|vm_offset_t
operator|)
name|pmap_mapdev
argument_list|(
name|paddr
operator|-
name|poffs
argument_list|,
name|psize
operator|+
name|poffs
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|vaddr
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|vaddr
operator|+=
name|poffs
expr_stmt|;
ifndef|#
directive|ifndef
name|PCI_QUIET
comment|/* 	**	display values. 	*/
name|printf
argument_list|(
literal|"\treg%d: virtual=0x%lx physical=0x%lx size=0x%lx\n"
argument_list|,
operator|(
name|unsigned
operator|)
name|reg
argument_list|,
operator|(
name|u_long
operator|)
name|vaddr
argument_list|,
operator|(
name|u_long
operator|)
name|paddr
argument_list|,
operator|(
name|u_long
operator|)
name|psize
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	**      set the configuration register and 	**      return the address to the driver 	**      Make sure to enable each upstream bridge 	**      so memory and DMA can go all the way. 	*/
for|for
control|(
init|;
condition|;
control|)
block|{
name|data
operator|=
name|pcibus
operator|->
name|pb_read
argument_list|(
name|tag
argument_list|,
name|PCI_COMMAND_STATUS_REG
argument_list|)
operator|&
literal|0xffff
expr_stmt|;
name|data
operator||=
name|PCI_COMMAND_MEM_ENABLE
operator||
name|PCI_COMMAND_MASTER_ENABLE
expr_stmt|;
operator|(
name|void
operator|)
name|pcibus
operator|->
name|pb_write
argument_list|(
name|tag
argument_list|,
name|PCI_COMMAND_STATUS_REG
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|link
operator|=
name|link
operator|->
name|pcicb_up
operator|)
operator|==
name|NULL
condition|)
break|break;
name|tag
operator|=
name|link
operator|->
name|pcicb_bridge
expr_stmt|;
block|}
operator|*
name|va
operator|=
name|vaddr
expr_stmt|;
operator|*
name|pa
operator|=
name|paddr
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------ ** **	Interface functions for the devconf module. ** **------------------------------------------------------------ */
end_comment

begin_function
specifier|static
name|int
name|pci_externalize
parameter_list|(
name|struct
name|proc
modifier|*
name|p
parameter_list|,
name|struct
name|kern_devconf
modifier|*
name|kdcp
parameter_list|,
name|void
modifier|*
name|u
parameter_list|,
name|size_t
name|l
parameter_list|)
block|{
name|struct
name|pci_externalize_buffer
name|buffer
decl_stmt|;
name|struct
name|pci_info
modifier|*
name|pip
init|=
name|kdcp
operator|->
name|kdc_parentdata
decl_stmt|;
name|pcici_t
name|tag
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|l
operator|<
sizeof|sizeof
name|buffer
condition|)
block|{
return|return
name|ENOMEM
return|;
block|}
empty_stmt|;
name|tag
operator|=
name|pcibus
operator|->
name|pb_tag
argument_list|(
name|pip
operator|->
name|pi_bus
argument_list|,
name|pip
operator|->
name|pi_device
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|buffer
operator|.
name|peb_pci_info
operator|=
operator|*
name|pip
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|PCI_EXT_CONF_LEN
condition|;
name|i
operator|++
control|)
block|{
name|buffer
operator|.
name|peb_config
index|[
name|i
index|]
operator|=
name|pcibus
operator|->
name|pb_read
argument_list|(
name|tag
argument_list|,
name|i
operator|*
literal|4
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
return|return
name|copyout
argument_list|(
operator|&
name|buffer
argument_list|,
name|u
argument_list|,
sizeof|sizeof
name|buffer
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pci_internalize
parameter_list|(
name|struct
name|proc
modifier|*
name|p
parameter_list|,
name|struct
name|kern_devconf
modifier|*
name|kdcp
parameter_list|,
name|void
modifier|*
name|u
parameter_list|,
name|size_t
name|s
parameter_list|)
block|{
return|return
name|EOPNOTSUPP
return|;
block|}
end_function

begin_comment
comment|/*----------------------------------------------------------------------- ** **	Pci meta interrupt handler ** **	This handler assumes level triggered interrupts. **	It's possible to build a kernel which handles shared **	edge triggered interrupts by the options "PCI_EDGE_INT". **	But there is a performance penalty. ** **	(Of course you can delete the #ifdef PCI_EDGE_INT bracketed **	code at all :-) :-) :-) ** **----------------------------------------------------------------------- */
end_comment

begin_decl_stmt
name|struct
name|pci_int_desc
modifier|*
name|pci_int_desc
index|[
name|PCI_MAX_IRQ
index|]
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|NO_SHARED_IRQ
end_ifndef

begin_function
specifier|static
specifier|inline
name|unsigned
name|splq
parameter_list|(
name|unsigned
name|mask
parameter_list|)
block|{
name|unsigned
name|temp
init|=
name|cpl
decl_stmt|;
name|cpl
operator||=
name|mask
expr_stmt|;
return|return
name|temp
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|pci_int
parameter_list|(
name|int
name|irq
parameter_list|)
block|{
name|struct
name|pci_int_desc
modifier|*
name|p
decl_stmt|;
name|int
name|c
decl_stmt|,
name|s
decl_stmt|;
ifdef|#
directive|ifdef
name|PCI_EDGE_INT
name|int
name|i
decl_stmt|,
name|n
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|irq
operator|<
literal|0
operator|||
name|irq
operator|>=
name|PCI_MAX_IRQ
condition|)
block|{
name|printf
argument_list|(
literal|"pci_int(%d)\n"
argument_list|,
name|irq
argument_list|)
expr_stmt|;
return|return;
block|}
empty_stmt|;
ifdef|#
directive|ifdef
name|PCI_EDGE_INT
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|1000
condition|;
name|i
operator|++
control|)
block|{
name|n
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|p
operator|=
name|pci_int_desc
index|[
name|irq
index|]
init|;
name|p
operator|!=
name|NULL
condition|;
name|p
operator|=
name|p
operator|->
name|pcid_next
control|)
block|{
name|s
operator|=
name|splq
argument_list|(
operator|*
name|p
operator|->
name|pcid_maskptr
argument_list|)
expr_stmt|;
name|c
operator|=
call|(
modifier|*
name|p
operator|->
name|pcid_handler
call|)
argument_list|(
name|p
operator|->
name|pcid_argument
argument_list|)
expr_stmt|;
name|p
operator|->
name|pcid_tally
operator|+=
name|c
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PCI_EDGE_INT
name|n
operator|+=
name|c
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
literal|0
block|if (c&& p->pcid_tally<20) 			printf ("PCI_INT: irq=%d h=%p cpl o=%x n=%x val=%d\n", 					irq, p->pcid_handler, s, cpl, c);
endif|#
directive|endif
block|}
empty_stmt|;
ifdef|#
directive|ifdef
name|PCI_EDGE_INT
if|if
condition|(
operator|!
name|n
condition|)
return|return;
block|}
empty_stmt|;
name|printf
argument_list|(
literal|"pci_int(%d): permanent interrupt request.\n"
argument_list|,
name|irq
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*----------------------------------------------------------------------- ** **	Auxiliary function for interrupt (un)mapping. ** **----------------------------------------------------------------------- */
end_comment

begin_function
specifier|static
name|u_int
name|getirq
parameter_list|(
name|pcici_t
name|tag
parameter_list|)
block|{
name|u_int
name|irq
decl_stmt|;
name|irq
operator|=
name|PCI_INTERRUPT_LINE_EXTRACT
argument_list|(
name|pcibus
operator|->
name|pb_read
argument_list|(
name|tag
argument_list|,
name|PCI_INTERRUPT_REG
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|irq
operator|<=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"\tint line register not set by bios\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|irq
operator|>=
name|pcibus
operator|->
name|pb_maxirq
operator|||
name|irq
operator|>=
name|PCI_MAX_IRQ
condition|)
block|{
name|printf
argument_list|(
literal|"\tirq %d invalid.\n"
argument_list|,
name|irq
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
name|irq
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|pci_int_desc
modifier|*
modifier|*
name|getintdescbytag
parameter_list|(
name|u_int
name|irq
parameter_list|,
name|pcici_t
name|tag
parameter_list|)
block|{
name|struct
name|pci_int_desc
modifier|*
name|p
decl_stmt|,
modifier|*
modifier|*
name|pp
decl_stmt|;
name|pp
operator|=
operator|&
name|pci_int_desc
index|[
name|irq
index|]
expr_stmt|;
while|while
condition|(
operator|(
operator|(
name|p
operator|=
operator|*
name|pp
operator|)
operator|)
operator|&&
operator|!
name|sametag
argument_list|(
name|p
operator|->
name|pcid_tag
argument_list|,
name|tag
argument_list|)
condition|)
name|pp
operator|=
operator|&
name|p
operator|->
name|pcid_next
expr_stmt|;
if|if
condition|(
operator|!
name|p
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
return|return
operator|(
name|pp
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|pci_int_desc
modifier|*
name|getintdescbymptr
parameter_list|(
name|u_int
name|irq
parameter_list|,
name|unsigned
modifier|*
name|mptr
parameter_list|)
block|{
name|struct
name|pci_int_desc
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|pci_int_desc
index|[
name|irq
index|]
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|pcid_next
control|)
if|if
condition|(
name|p
operator|->
name|pcid_maskptr
operator|==
name|mptr
condition|)
break|break;
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_comment
comment|/*----------------------------------------------------------------------- ** **	Map pci interrupt. ** **----------------------------------------------------------------------- */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|pci_mask0
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|pci_map_int
parameter_list|(
name|pcici_t
name|tag
parameter_list|,
name|int
function_decl|(
modifier|*
name|func
function_decl|)
parameter_list|()
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|unsigned
modifier|*
name|maskptr
parameter_list|)
block|{
name|u_int
name|irq
decl_stmt|;
name|int
name|result
decl_stmt|,
name|oldspl
decl_stmt|;
name|unsigned
name|mask
decl_stmt|;
name|struct
name|pci_int_desc
modifier|*
name|tail
decl_stmt|,
modifier|*
name|mdp
init|=
name|NULL
decl_stmt|,
modifier|*
name|new
init|=
name|NULL
decl_stmt|;
comment|/* 	**	Get irq line from configuration space, 	**	and check for consistency. 	*/
name|irq
operator|=
name|getirq
argument_list|(
name|tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|irq
operator|>=
name|PCI_MAX_IRQ
condition|)
block|{
name|printf
argument_list|(
literal|"\tillegal irq %d.\n"
argument_list|,
name|irq
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
empty_stmt|;
name|mask
operator|=
literal|1ul
operator|<<
name|irq
expr_stmt|;
comment|/*         **      disable this interrupt.         */
name|oldspl
operator|=
name|splq
argument_list|(
name|mask
argument_list|)
expr_stmt|;
comment|/* 	**	If handler for this tag already installed, 	**	remove it first. 	*/
if|if
condition|(
name|getintdescbytag
argument_list|(
name|irq
argument_list|,
name|tag
argument_list|)
operator|!=
name|NULL
condition|)
name|pci_unmap_int
argument_list|(
name|tag
argument_list|)
expr_stmt|;
comment|/* 	**	If this irq not yet included in the mask, include it. 	*/
name|mdp
operator|=
name|getintdescbymptr
argument_list|(
name|irq
argument_list|,
name|maskptr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mdp
condition|)
block|{
name|result
operator|=
name|pcibus
operator|->
name|pb_imaskinc
argument_list|(
name|irq
argument_list|,
name|maskptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
condition|)
goto|goto
name|conflict
goto|;
block|}
empty_stmt|;
comment|/* 	**	Allocate descriptor and initialize it. 	*/
name|tail
operator|=
name|pci_int_desc
index|[
name|irq
index|]
expr_stmt|;
name|new
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|new
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|new
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|new
argument_list|)
argument_list|)
expr_stmt|;
name|new
operator|->
name|pcid_next
operator|=
name|tail
expr_stmt|;
name|new
operator|->
name|pcid_tag
operator|=
name|tag
expr_stmt|;
name|new
operator|->
name|pcid_handler
operator|=
name|func
expr_stmt|;
name|new
operator|->
name|pcid_argument
operator|=
name|arg
expr_stmt|;
name|new
operator|->
name|pcid_maskptr
operator|=
name|maskptr
expr_stmt|;
name|new
operator|->
name|pcid_tally
operator|=
literal|0
expr_stmt|;
name|new
operator|->
name|pcid_mask
operator|=
name|mask
expr_stmt|;
comment|/* 	**	If first handler:   install it. 	**	If second handler: install shared-int-handler. 	*/
if|if
condition|(
operator|!
name|tail
condition|)
block|{
comment|/* 		**	first handler for this irq. 		*/
name|result
operator|=
name|pcibus
operator|->
name|pb_iattach
argument_list|(
name|irq
argument_list|,
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|()
operator|)
name|func
argument_list|,
operator|(
name|int
operator|)
name|arg
argument_list|,
name|maskptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
condition|)
goto|goto
name|conflict
goto|;
ifdef|#
directive|ifdef
name|NO_SHARED_IRQ
block|}
else|else
goto|goto
name|conflict
goto|;
else|#
directive|else
block|}
end_function

begin_elseif
elseif|else
if|if
condition|(
operator|!
name|tail
operator|->
name|pcid_next
condition|)
block|{
comment|/* 		**	Second handler for this irq. 		*/
name|printf
argument_list|(
literal|"\tusing shared irq %d.\n"
argument_list|,
name|irq
argument_list|)
expr_stmt|;
comment|/* 		**	replace old handler by shared-int-handler. 		*/
name|result
operator|=
name|pcibus
operator|->
name|pb_idetach
argument_list|(
name|irq
argument_list|,
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|()
operator|)
name|tail
operator|->
name|pcid_handler
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
condition|)
name|printf
argument_list|(
literal|"\tCANNOT DETACH INT HANDLER.\n"
argument_list|)
expr_stmt|;
name|result
operator|=
name|pcibus
operator|->
name|pb_iattach
argument_list|(
name|irq
argument_list|,
name|pci_int
argument_list|,
name|irq
argument_list|,
operator|&
name|pci_mask0
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
condition|)
block|{
name|printf
argument_list|(
literal|"\tCANNOT ATTACH SHARED INT HANDLER.\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
empty_stmt|;
block|}
end_elseif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* 	**	Link new descriptor, reenable ints and done. 	*/
end_comment

begin_expr_stmt
name|pci_int_desc
index|[
name|irq
index|]
operator|=
name|new
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|splx
argument_list|(
name|oldspl
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
operator|(
literal|1
operator|)
return|;
end_return

begin_comment
comment|/* 	**	Handle some problems. 	*/
end_comment

begin_label
name|conflict
label|:
end_label

begin_expr_stmt
name|printf
argument_list|(
literal|"\tirq %d already in use.\n"
argument_list|,
name|irq
argument_list|)
expr_stmt|;
end_expr_stmt

begin_label
name|fail
label|:
end_label

begin_comment
comment|/* 	**	If descriptor allocated, free it. 	**	If included in mask, remove it. 	*/
end_comment

begin_if
if|if
condition|(
name|free
condition|)
name|free
argument_list|(
name|new
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
end_if

begin_if
if|if
condition|(
operator|!
name|mdp
condition|)
operator|(
name|void
operator|)
name|pcibus
operator|->
name|pb_imaskexc
argument_list|(
name|irq
argument_list|,
name|maskptr
argument_list|)
expr_stmt|;
end_if

begin_expr_stmt
name|splx
argument_list|(
name|oldspl
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
operator|(
literal|0
operator|)
return|;
end_return

begin_comment
unit|}
comment|/*----------------------------------------------------------------------- ** **	Unmap pci interrupt. ** **----------------------------------------------------------------------- */
end_comment

begin_macro
unit|int
name|pci_unmap_int
argument_list|(
argument|pcici_t tag
argument_list|)
end_macro

begin_block
block|{
name|int
name|result
decl_stmt|,
name|oldspl
decl_stmt|;
name|struct
name|pci_int_desc
modifier|*
name|this
decl_stmt|,
modifier|*
modifier|*
name|hook
decl_stmt|,
modifier|*
name|tail
decl_stmt|;
name|unsigned
name|irq
decl_stmt|;
comment|/* 	**	Get irq line from configuration space, 	**	and check for consistency. 	*/
name|irq
operator|=
name|getirq
argument_list|(
name|tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|irq
operator|>=
name|PCI_MAX_IRQ
condition|)
block|{
name|printf
argument_list|(
literal|"\tillegal irq %d.\n"
argument_list|,
name|irq
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
empty_stmt|;
comment|/* 	**	Search and unlink interrupt descriptor. 	*/
name|hook
operator|=
name|getintdescbytag
argument_list|(
name|irq
argument_list|,
name|tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|hook
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"\tno irq %d handler for pci %x\n"
argument_list|,
name|irq
argument_list|,
name|tag
operator|.
name|tag
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
empty_stmt|;
name|this
operator|=
operator|*
name|hook
expr_stmt|;
operator|*
name|hook
operator|=
name|this
operator|->
name|pcid_next
expr_stmt|;
comment|/* 	**	Message 	*/
name|printf
argument_list|(
literal|"\tirq %d handler %p(%p) unmapped for pci %x after %d ints.\n"
argument_list|,
name|irq
argument_list|,
name|this
operator|->
name|pcid_handler
argument_list|,
name|this
operator|->
name|pcid_argument
argument_list|,
name|this
operator|->
name|pcid_tag
operator|.
name|tag
argument_list|,
name|this
operator|->
name|pcid_tally
argument_list|)
expr_stmt|;
comment|/* 	**	If this irq no longer included in the mask, remove it. 	*/
if|if
condition|(
operator|!
name|getintdescbymptr
argument_list|(
name|irq
argument_list|,
name|this
operator|->
name|pcid_maskptr
argument_list|)
condition|)
operator|(
name|void
operator|)
name|pcibus
operator|->
name|pb_imaskexc
argument_list|(
name|irq
argument_list|,
name|this
operator|->
name|pcid_maskptr
argument_list|)
expr_stmt|;
name|tail
operator|=
name|pci_int_desc
index|[
name|irq
index|]
expr_stmt|;
if|if
condition|(
name|tail
operator|==
name|NULL
condition|)
block|{
comment|/* 		**	Remove the old handler. 		*/
name|result
operator|=
name|pcibus
operator|->
name|pb_idetach
argument_list|(
name|irq
argument_list|,
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|()
operator|)
name|this
operator|->
name|pcid_handler
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
condition|)
name|printf
argument_list|(
literal|"\tirq %d: cannot remove handler.\n"
argument_list|,
name|irq
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tail
operator|->
name|pcid_next
operator|==
name|NULL
condition|)
block|{
comment|/* 		**	Remove the shared int handler. 		**	Install the last remaining handler. 		*/
name|oldspl
operator|=
name|splq
argument_list|(
literal|1ul
operator|<<
name|irq
argument_list|)
expr_stmt|;
name|result
operator|=
name|pcibus
operator|->
name|pb_idetach
argument_list|(
name|irq
argument_list|,
name|pci_int
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
condition|)
name|printf
argument_list|(
literal|"\tirq %d: cannot remove handler.\n"
argument_list|,
name|irq
argument_list|)
expr_stmt|;
name|result
operator|=
name|pcibus
operator|->
name|pb_iattach
argument_list|(
name|irq
argument_list|,
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|()
operator|)
name|tail
operator|->
name|pcid_handler
argument_list|,
operator|(
name|int
operator|)
name|tail
operator|->
name|pcid_argument
argument_list|,
name|tail
operator|->
name|pcid_maskptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
condition|)
name|printf
argument_list|(
literal|"\tirq %d: cannot install handler.\n"
argument_list|,
name|irq
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|oldspl
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
name|free
argument_list|(
name|this
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_comment
comment|/*----------------------------------------------------------- ** **	Display of unknown devices. ** **----------------------------------------------------------- */
end_comment

begin_struct
struct|struct
name|vt
block|{
name|u_short
name|ident
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|vt
name|VendorTable
index|[]
init|=
block|{
comment|/*	{0x0e11, "? 0x0e11"},*/
block|{
literal|0x1002
block|,
literal|"ATI TECHNOLOGIES INC"
block|}
block|,
block|{
literal|0x1011
block|,
literal|"DIGITAL EQUIPMENT CORPORATION"
block|}
block|,
block|{
literal|0x101A
block|,
literal|"NCR"
block|}
block|,
block|{
literal|0x1022
block|,
literal|"AMD"
block|}
block|,
block|{
literal|0x102B
block|,
literal|"MATROX"
block|}
block|,
comment|/*	{0x1039, "? 0x1039"},*/
block|{
literal|0x1045
block|,
literal|"OPTI"
block|}
block|,
comment|/*	{0x1095, "? 0x1095"},*/
block|{
literal|0x5333
block|,
literal|"S3 INC."
block|}
block|,
block|{
literal|0x8086
block|,
literal|"INTEL CORPORATION"
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|majclasses
index|[]
init|=
block|{
literal|"old"
block|,
literal|"storage"
block|,
literal|"network"
block|,
literal|"display"
block|,
literal|"multimedia"
block|,
literal|"memory"
block|,
literal|"bridge"
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|not_supported
parameter_list|(
name|pcici_t
name|tag
parameter_list|,
name|u_long
name|type
parameter_list|)
block|{
name|u_char
name|reg
decl_stmt|;
name|u_long
name|data
decl_stmt|;
name|struct
name|vt
modifier|*
name|vp
decl_stmt|;
comment|/* 	**	lookup the names. 	*/
for|for
control|(
name|vp
operator|=
name|VendorTable
init|;
name|vp
operator|->
name|ident
condition|;
name|vp
operator|++
control|)
if|if
condition|(
name|vp
operator|->
name|ident
operator|==
operator|(
name|type
operator|&
literal|0xffff
operator|)
condition|)
break|break;
comment|/* 	**	and display them. 	*/
if|if
condition|(
name|vp
operator|->
name|ident
condition|)
name|printf
argument_list|(
name|vp
operator|->
name|name
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"vendor=0x%lx"
argument_list|,
name|type
operator|&
literal|0xffff
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|", device=0x%lx"
argument_list|,
name|type
operator|>>
literal|16
argument_list|)
expr_stmt|;
name|data
operator|=
operator|(
name|pcibus
operator|->
name|pb_read
argument_list|(
name|tag
argument_list|,
name|PCI_CLASS_REG
argument_list|)
operator|>>
literal|24
operator|)
operator|&
literal|0xff
expr_stmt|;
if|if
condition|(
name|data
operator|<
sizeof|sizeof
argument_list|(
name|majclasses
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|majclasses
index|[
literal|0
index|]
argument_list|)
condition|)
name|printf
argument_list|(
literal|", class=%s"
argument_list|,
name|majclasses
index|[
name|data
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" [no driver assigned]\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|reg
operator|=
name|PCI_MAP_REG_START
init|;
name|reg
operator|<
name|PCI_MAP_REG_END
condition|;
name|reg
operator|+=
literal|4
control|)
block|{
name|data
operator|=
name|pcibus
operator|->
name|pb_read
argument_list|(
name|tag
argument_list|,
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|data
operator|&
operator|~
literal|7
operator|)
operator|==
literal|0
condition|)
continue|continue;
switch|switch
condition|(
name|data
operator|&
literal|7
condition|)
block|{
case|case
literal|1
case|:
case|case
literal|5
case|:
name|printf
argument_list|(
literal|"	map(%x): io(%lx)\n"
argument_list|,
name|reg
argument_list|,
name|data
operator|&
operator|~
literal|3
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0
case|:
name|printf
argument_list|(
literal|"	map(%x): mem32(%lx)\n"
argument_list|,
name|reg
argument_list|,
name|data
operator|&
operator|~
literal|7
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|printf
argument_list|(
literal|"	map(%x): mem20(%lx)\n"
argument_list|,
name|reg
argument_list|,
name|data
operator|&
operator|~
literal|7
argument_list|)
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|printf
argument_list|(
literal|"	map(%x): mem64(%lx)\n"
argument_list|,
name|reg
argument_list|,
name|data
operator|&
operator|~
literal|7
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NPCI */
end_comment

end_unit

