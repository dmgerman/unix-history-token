begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2000 Doug Rabson  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"opt_bus.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioccom.h>
end_include

begin_include
include|#
directive|include
file|<sys/agpio.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcivar.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcireg.h>
end_include

begin_include
include|#
directive|include
file|<pci/agppriv.h>
end_include

begin_include
include|#
directive|include
file|<pci/agpvar.h>
end_include

begin_include
include|#
directive|include
file|<pci/agpreg.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_object.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_page.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_pageout.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<machine/md_var.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_expr_stmt
name|MODULE_VERSION
argument_list|(
name|agp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_AGP
argument_list|,
literal|"agp"
argument_list|,
literal|"AGP data structures"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* agp_drv.c */
end_comment

begin_decl_stmt
specifier|static
name|d_open_t
name|agp_open
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_close_t
name|agp_close
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_ioctl_t
name|agp_ioctl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_mmap_t
name|agp_mmap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|cdevsw
name|agp_cdevsw
init|=
block|{
operator|.
name|d_version
operator|=
name|D_VERSION
block|,
operator|.
name|d_flags
operator|=
name|D_NEEDGIANT
block|,
operator|.
name|d_open
operator|=
name|agp_open
block|,
operator|.
name|d_close
operator|=
name|agp_close
block|,
operator|.
name|d_ioctl
operator|=
name|agp_ioctl
block|,
operator|.
name|d_mmap
operator|=
name|agp_mmap
block|,
operator|.
name|d_name
operator|=
literal|"agp"
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|devclass_t
name|agp_devclass
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|KDEV2DEV
parameter_list|(
name|kdev
parameter_list|)
value|devclass_get_device(agp_devclass, minor(kdev))
end_define

begin_comment
comment|/* Helper functions for implementing chipset mini drivers. */
end_comment

begin_function
name|void
name|agp_flush_cache
parameter_list|()
block|{
if|#
directive|if
name|defined
argument_list|(
name|__i386__
argument_list|)
operator|||
name|defined
argument_list|(
name|__amd64__
argument_list|)
name|wbinvd
argument_list|()
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|__alpha__
comment|/* FIXME: This is most likely not correct as it doesn't flush CPU  	 * write caches, but we don't have a facility to do that and  	 * this is all linux does, too */
name|alpha_mb
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
name|u_int8_t
name|agp_find_caps
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|int
name|capreg
decl_stmt|;
if|if
condition|(
name|pci_find_extcap
argument_list|(
name|dev
argument_list|,
name|PCIY_AGP
argument_list|,
operator|&
name|capreg
argument_list|)
operator|!=
literal|0
condition|)
name|capreg
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|capreg
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Find an AGP display device (if any).  */
end_comment

begin_function
specifier|static
name|device_t
name|agp_find_display
parameter_list|(
name|void
parameter_list|)
block|{
name|devclass_t
name|pci
init|=
name|devclass_find
argument_list|(
literal|"pci"
argument_list|)
decl_stmt|;
name|device_t
name|bus
decl_stmt|,
name|dev
init|=
literal|0
decl_stmt|;
name|device_t
modifier|*
name|kids
decl_stmt|;
name|int
name|busnum
decl_stmt|,
name|numkids
decl_stmt|,
name|i
decl_stmt|;
for|for
control|(
name|busnum
operator|=
literal|0
init|;
name|busnum
operator|<
name|devclass_get_maxunit
argument_list|(
name|pci
argument_list|)
condition|;
name|busnum
operator|++
control|)
block|{
name|bus
operator|=
name|devclass_get_device
argument_list|(
name|pci
argument_list|,
name|busnum
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bus
condition|)
continue|continue;
name|device_get_children
argument_list|(
name|bus
argument_list|,
operator|&
name|kids
argument_list|,
operator|&
name|numkids
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numkids
condition|;
name|i
operator|++
control|)
block|{
name|dev
operator|=
name|kids
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|pci_get_class
argument_list|(
name|dev
argument_list|)
operator|==
name|PCIC_DISPLAY
operator|&&
name|pci_get_subclass
argument_list|(
name|dev
argument_list|)
operator|==
name|PCIS_DISPLAY_VGA
condition|)
if|if
condition|(
name|agp_find_caps
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|kids
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
name|dev
return|;
block|}
block|}
name|free
argument_list|(
name|kids
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|struct
name|agp_gatt
modifier|*
name|agp_alloc_gatt
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|u_int32_t
name|apsize
init|=
name|AGP_GET_APERTURE
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|u_int32_t
name|entries
init|=
name|apsize
operator|>>
name|AGP_PAGE_SHIFT
decl_stmt|;
name|struct
name|agp_gatt
modifier|*
name|gatt
decl_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"allocating GATT for aperture of size %dM\n"
argument_list|,
name|apsize
operator|/
operator|(
literal|1024
operator|*
literal|1024
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|entries
operator|==
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"bad aperture size\n"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|gatt
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|agp_gatt
argument_list|)
argument_list|,
name|M_AGP
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|gatt
condition|)
return|return
literal|0
return|;
name|gatt
operator|->
name|ag_entries
operator|=
name|entries
expr_stmt|;
name|gatt
operator|->
name|ag_virtual
operator|=
name|contigmalloc
argument_list|(
name|entries
operator|*
sizeof|sizeof
argument_list|(
name|u_int32_t
argument_list|)
argument_list|,
name|M_AGP
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|~
literal|0
argument_list|,
name|PAGE_SIZE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|gatt
operator|->
name|ag_virtual
condition|)
block|{
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"contiguous allocation failed\n"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|gatt
argument_list|,
name|M_AGP
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|bzero
argument_list|(
name|gatt
operator|->
name|ag_virtual
argument_list|,
name|entries
operator|*
sizeof|sizeof
argument_list|(
name|u_int32_t
argument_list|)
argument_list|)
expr_stmt|;
name|gatt
operator|->
name|ag_physical
operator|=
name|vtophys
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|gatt
operator|->
name|ag_virtual
argument_list|)
expr_stmt|;
name|agp_flush_cache
argument_list|()
expr_stmt|;
return|return
name|gatt
return|;
block|}
end_function

begin_function
name|void
name|agp_free_gatt
parameter_list|(
name|struct
name|agp_gatt
modifier|*
name|gatt
parameter_list|)
block|{
name|contigfree
argument_list|(
name|gatt
operator|->
name|ag_virtual
argument_list|,
name|gatt
operator|->
name|ag_entries
operator|*
sizeof|sizeof
argument_list|(
name|u_int32_t
argument_list|)
argument_list|,
name|M_AGP
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|gatt
argument_list|,
name|M_AGP
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|int
name|agp_max
index|[]
index|[
literal|2
index|]
init|=
block|{
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|32
block|,
literal|4
block|}
block|,
block|{
literal|64
block|,
literal|28
block|}
block|,
block|{
literal|128
block|,
literal|96
block|}
block|,
block|{
literal|256
block|,
literal|204
block|}
block|,
block|{
literal|512
block|,
literal|440
block|}
block|,
block|{
literal|1024
block|,
literal|942
block|}
block|,
block|{
literal|2048
block|,
literal|1920
block|}
block|,
block|{
literal|4096
block|,
literal|3932
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|agp_max_size
value|(sizeof(agp_max) / sizeof(agp_max[0]))
end_define

begin_function
name|int
name|agp_generic_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|agp_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|rid
decl_stmt|,
name|memsize
decl_stmt|,
name|i
decl_stmt|;
comment|/* 	 * Find and map the aperture. 	 */
name|rid
operator|=
name|AGP_APBASE
expr_stmt|;
name|sc
operator|->
name|as_aperture
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
operator|&
name|rid
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sc
operator|->
name|as_aperture
condition|)
return|return
name|ENOMEM
return|;
comment|/* 	 * Work out an upper bound for agp memory allocation. This 	 * uses a heurisitc table from the Linux driver. 	 */
name|memsize
operator|=
name|ptoa
argument_list|(
name|Maxmem
argument_list|)
operator|>>
literal|20
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|agp_max_size
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|memsize
operator|<=
name|agp_max
index|[
name|i
index|]
index|[
literal|0
index|]
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|==
name|agp_max_size
condition|)
name|i
operator|=
name|agp_max_size
operator|-
literal|1
expr_stmt|;
name|sc
operator|->
name|as_maxmem
operator|=
name|agp_max
index|[
name|i
index|]
index|[
literal|1
index|]
operator|<<
literal|20U
expr_stmt|;
comment|/* 	 * The lock is used to prevent re-entry to 	 * agp_generic_bind_memory() since that function can sleep. 	 */
name|mtx_init
argument_list|(
operator|&
name|sc
operator|->
name|as_lock
argument_list|,
literal|"agp lock"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
comment|/* 	 * Initialise stuff for the userland device. 	 */
name|agp_devclass
operator|=
name|devclass_find
argument_list|(
literal|"agp"
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|sc
operator|->
name|as_memory
argument_list|)
expr_stmt|;
name|sc
operator|->
name|as_nextid
operator|=
literal|1
expr_stmt|;
name|sc
operator|->
name|as_devnode
operator|=
name|make_dev
argument_list|(
operator|&
name|agp_cdevsw
argument_list|,
name|device_get_unit
argument_list|(
name|dev
argument_list|)
argument_list|,
name|UID_ROOT
argument_list|,
name|GID_WHEEL
argument_list|,
literal|0600
argument_list|,
literal|"agpgart"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|agp_generic_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|agp_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|destroy_dev
argument_list|(
name|sc
operator|->
name|as_devnode
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|AGP_APBASE
argument_list|,
name|sc
operator|->
name|as_aperture
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|sc
operator|->
name|as_lock
argument_list|)
expr_stmt|;
name|agp_flush_cache
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * This does the enable logic for v3, with the same topology  * restrictions as in place for v2 -- one bus, one device on the bus.  */
end_comment

begin_function
specifier|static
name|int
name|agp_v3_enable
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|mdev
parameter_list|,
name|u_int32_t
name|mode
parameter_list|)
block|{
name|u_int32_t
name|tstatus
decl_stmt|,
name|mstatus
decl_stmt|;
name|u_int32_t
name|command
decl_stmt|;
name|int
name|rq
decl_stmt|,
name|sba
decl_stmt|,
name|fw
decl_stmt|,
name|rate
decl_stmt|,
name|arqsz
decl_stmt|,
name|cal
decl_stmt|;
name|tstatus
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|agp_find_caps
argument_list|(
name|dev
argument_list|)
operator|+
name|AGP_STATUS
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|mstatus
operator|=
name|pci_read_config
argument_list|(
name|mdev
argument_list|,
name|agp_find_caps
argument_list|(
name|mdev
argument_list|)
operator|+
name|AGP_STATUS
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* Set RQ to the min of mode, tstatus and mstatus */
name|rq
operator|=
name|AGP_MODE_GET_RQ
argument_list|(
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|AGP_MODE_GET_RQ
argument_list|(
name|tstatus
argument_list|)
operator|<
name|rq
condition|)
name|rq
operator|=
name|AGP_MODE_GET_RQ
argument_list|(
name|tstatus
argument_list|)
expr_stmt|;
if|if
condition|(
name|AGP_MODE_GET_RQ
argument_list|(
name|mstatus
argument_list|)
operator|<
name|rq
condition|)
name|rq
operator|=
name|AGP_MODE_GET_RQ
argument_list|(
name|mstatus
argument_list|)
expr_stmt|;
comment|/* 	 * ARQSZ - Set the value to the maximum one. 	 * Don't allow the mode register to override values. 	 */
name|arqsz
operator|=
name|AGP_MODE_GET_ARQSZ
argument_list|(
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|AGP_MODE_GET_ARQSZ
argument_list|(
name|tstatus
argument_list|)
operator|>
name|rq
condition|)
name|rq
operator|=
name|AGP_MODE_GET_ARQSZ
argument_list|(
name|tstatus
argument_list|)
expr_stmt|;
if|if
condition|(
name|AGP_MODE_GET_ARQSZ
argument_list|(
name|mstatus
argument_list|)
operator|>
name|rq
condition|)
name|rq
operator|=
name|AGP_MODE_GET_ARQSZ
argument_list|(
name|mstatus
argument_list|)
expr_stmt|;
comment|/* Calibration cycle - don't allow override by mode register */
name|cal
operator|=
name|AGP_MODE_GET_CAL
argument_list|(
name|tstatus
argument_list|)
expr_stmt|;
if|if
condition|(
name|AGP_MODE_GET_CAL
argument_list|(
name|mstatus
argument_list|)
operator|<
name|cal
condition|)
name|cal
operator|=
name|AGP_MODE_GET_CAL
argument_list|(
name|mstatus
argument_list|)
expr_stmt|;
comment|/* SBA must be supported for AGP v3. */
name|sba
operator|=
literal|1
expr_stmt|;
comment|/* Set FW if all three support it. */
name|fw
operator|=
operator|(
name|AGP_MODE_GET_FW
argument_list|(
name|tstatus
argument_list|)
operator|&
name|AGP_MODE_GET_FW
argument_list|(
name|mstatus
argument_list|)
operator|&
name|AGP_MODE_GET_FW
argument_list|(
name|mode
argument_list|)
operator|)
expr_stmt|;
comment|/* Figure out the max rate */
name|rate
operator|=
operator|(
name|AGP_MODE_GET_RATE
argument_list|(
name|tstatus
argument_list|)
operator|&
name|AGP_MODE_GET_RATE
argument_list|(
name|mstatus
argument_list|)
operator|&
name|AGP_MODE_GET_RATE
argument_list|(
name|mode
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|rate
operator|&
name|AGP_MODE_V3_RATE_8x
condition|)
name|rate
operator|=
name|AGP_MODE_V3_RATE_8x
expr_stmt|;
else|else
name|rate
operator|=
name|AGP_MODE_V3_RATE_4x
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Setting AGP v3 mode %d\n"
argument_list|,
name|rate
operator|*
literal|4
argument_list|)
expr_stmt|;
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|agp_find_caps
argument_list|(
name|dev
argument_list|)
operator|+
name|AGP_COMMAND
argument_list|,
literal|0
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* Construct the new mode word and tell the hardware */
name|command
operator|=
name|AGP_MODE_SET_RQ
argument_list|(
literal|0
argument_list|,
name|rq
argument_list|)
expr_stmt|;
name|command
operator|=
name|AGP_MODE_SET_ARQSZ
argument_list|(
name|command
argument_list|,
name|arqsz
argument_list|)
expr_stmt|;
name|command
operator|=
name|AGP_MODE_SET_CAL
argument_list|(
name|command
argument_list|,
name|cal
argument_list|)
expr_stmt|;
name|command
operator|=
name|AGP_MODE_SET_SBA
argument_list|(
name|command
argument_list|,
name|sba
argument_list|)
expr_stmt|;
name|command
operator|=
name|AGP_MODE_SET_FW
argument_list|(
name|command
argument_list|,
name|fw
argument_list|)
expr_stmt|;
name|command
operator|=
name|AGP_MODE_SET_RATE
argument_list|(
name|command
argument_list|,
name|rate
argument_list|)
expr_stmt|;
name|command
operator|=
name|AGP_MODE_SET_AGP
argument_list|(
name|command
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|agp_find_caps
argument_list|(
name|dev
argument_list|)
operator|+
name|AGP_COMMAND
argument_list|,
name|command
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|pci_write_config
argument_list|(
name|mdev
argument_list|,
name|agp_find_caps
argument_list|(
name|mdev
argument_list|)
operator|+
name|AGP_COMMAND
argument_list|,
name|command
argument_list|,
literal|4
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|agp_v2_enable
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|mdev
parameter_list|,
name|u_int32_t
name|mode
parameter_list|)
block|{
name|u_int32_t
name|tstatus
decl_stmt|,
name|mstatus
decl_stmt|;
name|u_int32_t
name|command
decl_stmt|;
name|int
name|rq
decl_stmt|,
name|sba
decl_stmt|,
name|fw
decl_stmt|,
name|rate
decl_stmt|;
name|tstatus
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|agp_find_caps
argument_list|(
name|dev
argument_list|)
operator|+
name|AGP_STATUS
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|mstatus
operator|=
name|pci_read_config
argument_list|(
name|mdev
argument_list|,
name|agp_find_caps
argument_list|(
name|mdev
argument_list|)
operator|+
name|AGP_STATUS
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* Set RQ to the min of mode, tstatus and mstatus */
name|rq
operator|=
name|AGP_MODE_GET_RQ
argument_list|(
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|AGP_MODE_GET_RQ
argument_list|(
name|tstatus
argument_list|)
operator|<
name|rq
condition|)
name|rq
operator|=
name|AGP_MODE_GET_RQ
argument_list|(
name|tstatus
argument_list|)
expr_stmt|;
if|if
condition|(
name|AGP_MODE_GET_RQ
argument_list|(
name|mstatus
argument_list|)
operator|<
name|rq
condition|)
name|rq
operator|=
name|AGP_MODE_GET_RQ
argument_list|(
name|mstatus
argument_list|)
expr_stmt|;
comment|/* Set SBA if all three can deal with SBA */
name|sba
operator|=
operator|(
name|AGP_MODE_GET_SBA
argument_list|(
name|tstatus
argument_list|)
operator|&
name|AGP_MODE_GET_SBA
argument_list|(
name|mstatus
argument_list|)
operator|&
name|AGP_MODE_GET_SBA
argument_list|(
name|mode
argument_list|)
operator|)
expr_stmt|;
comment|/* Similar for FW */
name|fw
operator|=
operator|(
name|AGP_MODE_GET_FW
argument_list|(
name|tstatus
argument_list|)
operator|&
name|AGP_MODE_GET_FW
argument_list|(
name|mstatus
argument_list|)
operator|&
name|AGP_MODE_GET_FW
argument_list|(
name|mode
argument_list|)
operator|)
expr_stmt|;
comment|/* Figure out the max rate */
name|rate
operator|=
operator|(
name|AGP_MODE_GET_RATE
argument_list|(
name|tstatus
argument_list|)
operator|&
name|AGP_MODE_GET_RATE
argument_list|(
name|mstatus
argument_list|)
operator|&
name|AGP_MODE_GET_RATE
argument_list|(
name|mode
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|rate
operator|&
name|AGP_MODE_V2_RATE_4x
condition|)
name|rate
operator|=
name|AGP_MODE_V2_RATE_4x
expr_stmt|;
elseif|else
if|if
condition|(
name|rate
operator|&
name|AGP_MODE_V2_RATE_2x
condition|)
name|rate
operator|=
name|AGP_MODE_V2_RATE_2x
expr_stmt|;
else|else
name|rate
operator|=
name|AGP_MODE_V2_RATE_1x
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Setting AGP v2 mode %d\n"
argument_list|,
name|rate
argument_list|)
expr_stmt|;
comment|/* Construct the new mode word and tell the hardware */
name|command
operator|=
name|AGP_MODE_SET_RQ
argument_list|(
literal|0
argument_list|,
name|rq
argument_list|)
expr_stmt|;
name|command
operator|=
name|AGP_MODE_SET_SBA
argument_list|(
name|command
argument_list|,
name|sba
argument_list|)
expr_stmt|;
name|command
operator|=
name|AGP_MODE_SET_FW
argument_list|(
name|command
argument_list|,
name|fw
argument_list|)
expr_stmt|;
name|command
operator|=
name|AGP_MODE_SET_RATE
argument_list|(
name|command
argument_list|,
name|rate
argument_list|)
expr_stmt|;
name|command
operator|=
name|AGP_MODE_SET_AGP
argument_list|(
name|command
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|agp_find_caps
argument_list|(
name|dev
argument_list|)
operator|+
name|AGP_COMMAND
argument_list|,
name|command
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|pci_write_config
argument_list|(
name|mdev
argument_list|,
name|agp_find_caps
argument_list|(
name|mdev
argument_list|)
operator|+
name|AGP_COMMAND
argument_list|,
name|command
argument_list|,
literal|4
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|agp_generic_enable
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|u_int32_t
name|mode
parameter_list|)
block|{
name|device_t
name|mdev
init|=
name|agp_find_display
argument_list|()
decl_stmt|;
name|u_int32_t
name|tstatus
decl_stmt|,
name|mstatus
decl_stmt|;
if|if
condition|(
operator|!
name|mdev
condition|)
block|{
name|AGP_DPF
argument_list|(
literal|"can't find display\n"
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
name|tstatus
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|agp_find_caps
argument_list|(
name|dev
argument_list|)
operator|+
name|AGP_STATUS
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|mstatus
operator|=
name|pci_read_config
argument_list|(
name|mdev
argument_list|,
name|agp_find_caps
argument_list|(
name|mdev
argument_list|)
operator|+
name|AGP_STATUS
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* 	 * Check display and bridge for AGP v3 support.  AGP v3 allows 	 * more variety in topology than v2, e.g. multiple AGP devices 	 * attached to one bridge, or multiple AGP bridges in one 	 * system.  This doesn't attempt to address those situations, 	 * but should work fine for a classic single AGP slot system 	 * with AGP v3. 	 */
if|if
condition|(
name|AGP_MODE_GET_MODE_3
argument_list|(
name|tstatus
argument_list|)
operator|&&
name|AGP_MODE_GET_MODE_3
argument_list|(
name|mstatus
argument_list|)
condition|)
return|return
operator|(
name|agp_v3_enable
argument_list|(
name|dev
argument_list|,
name|mdev
argument_list|,
name|mode
argument_list|)
operator|)
return|;
else|else
return|return
operator|(
name|agp_v2_enable
argument_list|(
name|dev
argument_list|,
name|mdev
argument_list|,
name|mode
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|agp_memory
modifier|*
name|agp_generic_alloc_memory
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|int
name|type
parameter_list|,
name|vm_size_t
name|size
parameter_list|)
block|{
name|struct
name|agp_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|agp_memory
modifier|*
name|mem
decl_stmt|;
if|if
condition|(
operator|(
name|size
operator|&
operator|(
name|AGP_PAGE_SIZE
operator|-
literal|1
operator|)
operator|)
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|sc
operator|->
name|as_allocated
operator|+
name|size
operator|>
name|sc
operator|->
name|as_maxmem
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|type
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"agp_generic_alloc_memory: unsupported type %d\n"
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|mem
operator|=
name|malloc
argument_list|(
sizeof|sizeof
expr|*
name|mem
argument_list|,
name|M_AGP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|mem
operator|->
name|am_id
operator|=
name|sc
operator|->
name|as_nextid
operator|++
expr_stmt|;
name|mem
operator|->
name|am_size
operator|=
name|size
expr_stmt|;
name|mem
operator|->
name|am_type
operator|=
literal|0
expr_stmt|;
name|mem
operator|->
name|am_obj
operator|=
name|vm_object_allocate
argument_list|(
name|OBJT_DEFAULT
argument_list|,
name|atop
argument_list|(
name|round_page
argument_list|(
name|size
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|mem
operator|->
name|am_physical
operator|=
literal|0
expr_stmt|;
name|mem
operator|->
name|am_offset
operator|=
literal|0
expr_stmt|;
name|mem
operator|->
name|am_is_bound
operator|=
literal|0
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|sc
operator|->
name|as_memory
argument_list|,
name|mem
argument_list|,
name|am_link
argument_list|)
expr_stmt|;
name|sc
operator|->
name|as_allocated
operator|+=
name|size
expr_stmt|;
return|return
name|mem
return|;
block|}
end_function

begin_function
name|int
name|agp_generic_free_memory
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|struct
name|agp_memory
modifier|*
name|mem
parameter_list|)
block|{
name|struct
name|agp_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
if|if
condition|(
name|mem
operator|->
name|am_is_bound
condition|)
return|return
name|EBUSY
return|;
name|sc
operator|->
name|as_allocated
operator|-=
name|mem
operator|->
name|am_size
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|sc
operator|->
name|as_memory
argument_list|,
name|mem
argument_list|,
name|am_link
argument_list|)
expr_stmt|;
name|vm_object_deallocate
argument_list|(
name|mem
operator|->
name|am_obj
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|mem
argument_list|,
name|M_AGP
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|agp_generic_bind_memory
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|struct
name|agp_memory
modifier|*
name|mem
parameter_list|,
name|vm_offset_t
name|offset
parameter_list|)
block|{
name|struct
name|agp_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|vm_offset_t
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|;
name|vm_page_t
name|m
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* Do some sanity checks first. */
if|if
condition|(
name|offset
operator|<
literal|0
operator|||
operator|(
name|offset
operator|&
operator|(
name|AGP_PAGE_SIZE
operator|-
literal|1
operator|)
operator|)
operator|!=
literal|0
operator|||
name|offset
operator|+
name|mem
operator|->
name|am_size
operator|>
name|AGP_GET_APERTURE
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"binding memory at bad offset %#x\n"
argument_list|,
operator|(
name|int
operator|)
name|offset
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
comment|/* 	 * Allocate the pages early, before acquiring the lock, 	 * because vm_page_grab() used with VM_ALLOC_RETRY may 	 * block and we can't hold a mutex while blocking. 	 */
name|VM_OBJECT_LOCK
argument_list|(
name|mem
operator|->
name|am_obj
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|mem
operator|->
name|am_size
condition|;
name|i
operator|+=
name|PAGE_SIZE
control|)
block|{
comment|/* 		 * Find a page from the object and wire it 		 * down. This page will be mapped using one or more 		 * entries in the GATT (assuming that PAGE_SIZE>= 		 * AGP_PAGE_SIZE. If this is the first call to bind, 		 * the pages will be allocated and zeroed. 		 */
name|m
operator|=
name|vm_page_grab
argument_list|(
name|mem
operator|->
name|am_obj
argument_list|,
name|OFF_TO_IDX
argument_list|(
name|i
argument_list|)
argument_list|,
name|VM_ALLOC_WIRED
operator||
name|VM_ALLOC_ZERO
operator||
name|VM_ALLOC_RETRY
argument_list|)
expr_stmt|;
name|AGP_DPF
argument_list|(
literal|"found page pa=%#x\n"
argument_list|,
name|VM_PAGE_TO_PHYS
argument_list|(
name|m
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|VM_OBJECT_UNLOCK
argument_list|(
name|mem
operator|->
name|am_obj
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|as_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|mem
operator|->
name|am_is_bound
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"memory already bound\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
name|VM_OBJECT_LOCK
argument_list|(
name|mem
operator|->
name|am_obj
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
comment|/* 	 * Bind the individual pages and flush the chipset's 	 * TLB. 	 * 	 * XXX Presumably, this needs to be the pci address on alpha 	 * (i.e. use alpha_XXX_dmamap()). I don't have access to any 	 * alpha AGP hardware to check. 	 */
name|VM_OBJECT_LOCK
argument_list|(
name|mem
operator|->
name|am_obj
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|mem
operator|->
name|am_size
condition|;
name|i
operator|+=
name|PAGE_SIZE
control|)
block|{
name|m
operator|=
name|vm_page_lookup
argument_list|(
name|mem
operator|->
name|am_obj
argument_list|,
name|OFF_TO_IDX
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 		 * Install entries in the GATT, making sure that if 		 * AGP_PAGE_SIZE< PAGE_SIZE and mem->am_size is not 		 * aligned to PAGE_SIZE, we don't modify too many GATT  		 * entries. 		 */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|PAGE_SIZE
operator|&&
name|i
operator|+
name|j
operator|<
name|mem
operator|->
name|am_size
condition|;
name|j
operator|+=
name|AGP_PAGE_SIZE
control|)
block|{
name|vm_offset_t
name|pa
init|=
name|VM_PAGE_TO_PHYS
argument_list|(
name|m
argument_list|)
operator|+
name|j
decl_stmt|;
name|AGP_DPF
argument_list|(
literal|"binding offset %#x to pa %#x\n"
argument_list|,
name|offset
operator|+
name|i
operator|+
name|j
argument_list|,
name|pa
argument_list|)
expr_stmt|;
name|error
operator|=
name|AGP_BIND_PAGE
argument_list|(
name|dev
argument_list|,
name|offset
operator|+
name|i
operator|+
name|j
argument_list|,
name|pa
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
comment|/* 				 * Bail out. Reverse all the mappings 				 * and unwire the pages. 				 */
name|vm_page_lock_queues
argument_list|()
expr_stmt|;
name|vm_page_wakeup
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|vm_page_unlock_queues
argument_list|()
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|i
operator|+
name|j
condition|;
name|k
operator|+=
name|AGP_PAGE_SIZE
control|)
name|AGP_UNBIND_PAGE
argument_list|(
name|dev
argument_list|,
name|offset
operator|+
name|k
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
block|}
name|vm_page_lock_queues
argument_list|()
expr_stmt|;
name|vm_page_wakeup
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|vm_page_unlock_queues
argument_list|()
expr_stmt|;
block|}
name|VM_OBJECT_UNLOCK
argument_list|(
name|mem
operator|->
name|am_obj
argument_list|)
expr_stmt|;
comment|/* 	 * Flush the cpu cache since we are providing a new mapping 	 * for these pages. 	 */
name|agp_flush_cache
argument_list|()
expr_stmt|;
comment|/* 	 * Make sure the chipset gets the new mappings. 	 */
name|AGP_FLUSH_TLB
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|mem
operator|->
name|am_offset
operator|=
name|offset
expr_stmt|;
name|mem
operator|->
name|am_is_bound
operator|=
literal|1
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|as_lock
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
name|bad
label|:
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|as_lock
argument_list|)
expr_stmt|;
name|VM_OBJECT_LOCK_ASSERT
argument_list|(
name|mem
operator|->
name|am_obj
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|mem
operator|->
name|am_size
condition|;
name|i
operator|+=
name|PAGE_SIZE
control|)
block|{
name|m
operator|=
name|vm_page_lookup
argument_list|(
name|mem
operator|->
name|am_obj
argument_list|,
name|OFF_TO_IDX
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|vm_page_lock_queues
argument_list|()
expr_stmt|;
name|vm_page_unwire
argument_list|(
name|m
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|vm_page_unlock_queues
argument_list|()
expr_stmt|;
block|}
name|VM_OBJECT_UNLOCK
argument_list|(
name|mem
operator|->
name|am_obj
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_function
name|int
name|agp_generic_unbind_memory
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|struct
name|agp_memory
modifier|*
name|mem
parameter_list|)
block|{
name|struct
name|agp_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|vm_page_t
name|m
decl_stmt|;
name|int
name|i
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|as_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mem
operator|->
name|am_is_bound
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"memory is not bound\n"
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|as_lock
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
comment|/* 	 * Unbind the individual pages and flush the chipset's 	 * TLB. Unwire the pages so they can be swapped. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|mem
operator|->
name|am_size
condition|;
name|i
operator|+=
name|AGP_PAGE_SIZE
control|)
name|AGP_UNBIND_PAGE
argument_list|(
name|dev
argument_list|,
name|mem
operator|->
name|am_offset
operator|+
name|i
argument_list|)
expr_stmt|;
name|VM_OBJECT_LOCK
argument_list|(
name|mem
operator|->
name|am_obj
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|mem
operator|->
name|am_size
condition|;
name|i
operator|+=
name|PAGE_SIZE
control|)
block|{
name|m
operator|=
name|vm_page_lookup
argument_list|(
name|mem
operator|->
name|am_obj
argument_list|,
name|atop
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|vm_page_lock_queues
argument_list|()
expr_stmt|;
name|vm_page_unwire
argument_list|(
name|m
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|vm_page_unlock_queues
argument_list|()
expr_stmt|;
block|}
name|VM_OBJECT_UNLOCK
argument_list|(
name|mem
operator|->
name|am_obj
argument_list|)
expr_stmt|;
name|agp_flush_cache
argument_list|()
expr_stmt|;
name|AGP_FLUSH_TLB
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|mem
operator|->
name|am_offset
operator|=
literal|0
expr_stmt|;
name|mem
operator|->
name|am_is_bound
operator|=
literal|0
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|as_lock
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Helper functions for implementing user/kernel api */
end_comment

begin_function
specifier|static
name|int
name|agp_acquire_helper
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|enum
name|agp_acquire_state
name|state
parameter_list|)
block|{
name|struct
name|agp_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|as_state
operator|!=
name|AGP_ACQUIRE_FREE
condition|)
return|return
name|EBUSY
return|;
name|sc
operator|->
name|as_state
operator|=
name|state
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|agp_release_helper
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|enum
name|agp_acquire_state
name|state
parameter_list|)
block|{
name|struct
name|agp_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|as_state
operator|==
name|AGP_ACQUIRE_FREE
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|sc
operator|->
name|as_state
operator|!=
name|state
condition|)
return|return
name|EBUSY
return|;
name|sc
operator|->
name|as_state
operator|=
name|AGP_ACQUIRE_FREE
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|agp_memory
modifier|*
name|agp_find_memory
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|int
name|id
parameter_list|)
block|{
name|struct
name|agp_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|agp_memory
modifier|*
name|mem
decl_stmt|;
name|AGP_DPF
argument_list|(
literal|"searching for memory block %d\n"
argument_list|,
name|id
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|mem
argument_list|,
argument|&sc->as_memory
argument_list|,
argument|am_link
argument_list|)
block|{
name|AGP_DPF
argument_list|(
literal|"considering memory block %d\n"
argument_list|,
name|mem
operator|->
name|am_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|mem
operator|->
name|am_id
operator|==
name|id
condition|)
return|return
name|mem
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Implementation of the userland ioctl api */
end_comment

begin_function
specifier|static
name|int
name|agp_info_user
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|agp_info
modifier|*
name|info
parameter_list|)
block|{
name|struct
name|agp_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|bzero
argument_list|(
name|info
argument_list|,
sizeof|sizeof
expr|*
name|info
argument_list|)
expr_stmt|;
name|info
operator|->
name|bridge_id
operator|=
name|pci_get_devid
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|info
operator|->
name|agp_mode
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|agp_find_caps
argument_list|(
name|dev
argument_list|)
operator|+
name|AGP_STATUS
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|info
operator|->
name|aper_base
operator|=
name|rman_get_start
argument_list|(
name|sc
operator|->
name|as_aperture
argument_list|)
expr_stmt|;
name|info
operator|->
name|aper_size
operator|=
name|AGP_GET_APERTURE
argument_list|(
name|dev
argument_list|)
operator|>>
literal|20
expr_stmt|;
name|info
operator|->
name|pg_total
operator|=
name|info
operator|->
name|pg_system
operator|=
name|sc
operator|->
name|as_maxmem
operator|>>
name|AGP_PAGE_SHIFT
expr_stmt|;
name|info
operator|->
name|pg_used
operator|=
name|sc
operator|->
name|as_allocated
operator|>>
name|AGP_PAGE_SHIFT
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|agp_setup_user
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|agp_setup
modifier|*
name|setup
parameter_list|)
block|{
return|return
name|AGP_ENABLE
argument_list|(
name|dev
argument_list|,
name|setup
operator|->
name|agp_mode
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|agp_allocate_user
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|agp_allocate
modifier|*
name|alloc
parameter_list|)
block|{
name|struct
name|agp_memory
modifier|*
name|mem
decl_stmt|;
name|mem
operator|=
name|AGP_ALLOC_MEMORY
argument_list|(
name|dev
argument_list|,
name|alloc
operator|->
name|type
argument_list|,
name|alloc
operator|->
name|pg_count
operator|<<
name|AGP_PAGE_SHIFT
argument_list|)
expr_stmt|;
if|if
condition|(
name|mem
condition|)
block|{
name|alloc
operator|->
name|key
operator|=
name|mem
operator|->
name|am_id
expr_stmt|;
name|alloc
operator|->
name|physical
operator|=
name|mem
operator|->
name|am_physical
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
block|{
return|return
name|ENOMEM
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|agp_deallocate_user
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|int
name|id
parameter_list|)
block|{
name|struct
name|agp_memory
modifier|*
name|mem
init|=
name|agp_find_memory
argument_list|(
name|dev
argument_list|,
name|id
argument_list|)
decl_stmt|;
empty_stmt|;
if|if
condition|(
name|mem
condition|)
block|{
name|AGP_FREE_MEMORY
argument_list|(
name|dev
argument_list|,
name|mem
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
block|{
return|return
name|ENOENT
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|agp_bind_user
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|agp_bind
modifier|*
name|bind
parameter_list|)
block|{
name|struct
name|agp_memory
modifier|*
name|mem
init|=
name|agp_find_memory
argument_list|(
name|dev
argument_list|,
name|bind
operator|->
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|mem
condition|)
return|return
name|ENOENT
return|;
return|return
name|AGP_BIND_MEMORY
argument_list|(
name|dev
argument_list|,
name|mem
argument_list|,
name|bind
operator|->
name|pg_start
operator|<<
name|AGP_PAGE_SHIFT
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|agp_unbind_user
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|agp_unbind
modifier|*
name|unbind
parameter_list|)
block|{
name|struct
name|agp_memory
modifier|*
name|mem
init|=
name|agp_find_memory
argument_list|(
name|dev
argument_list|,
name|unbind
operator|->
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|mem
condition|)
return|return
name|ENOENT
return|;
return|return
name|AGP_UNBIND_MEMORY
argument_list|(
name|dev
argument_list|,
name|mem
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|agp_open
parameter_list|(
name|struct
name|cdev
modifier|*
name|kdev
parameter_list|,
name|int
name|oflags
parameter_list|,
name|int
name|devtype
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|device_t
name|dev
init|=
name|KDEV2DEV
argument_list|(
name|kdev
argument_list|)
decl_stmt|;
name|struct
name|agp_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|sc
operator|->
name|as_isopen
condition|)
block|{
name|sc
operator|->
name|as_isopen
operator|=
literal|1
expr_stmt|;
name|device_busy
argument_list|(
name|dev
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|agp_close
parameter_list|(
name|struct
name|cdev
modifier|*
name|kdev
parameter_list|,
name|int
name|fflag
parameter_list|,
name|int
name|devtype
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|device_t
name|dev
init|=
name|KDEV2DEV
argument_list|(
name|kdev
argument_list|)
decl_stmt|;
name|struct
name|agp_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|agp_memory
modifier|*
name|mem
decl_stmt|;
comment|/* 	 * Clear the GATT and force release on last close 	 */
while|while
condition|(
operator|(
name|mem
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|as_memory
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|mem
operator|->
name|am_is_bound
condition|)
name|AGP_UNBIND_MEMORY
argument_list|(
name|dev
argument_list|,
name|mem
argument_list|)
expr_stmt|;
name|AGP_FREE_MEMORY
argument_list|(
name|dev
argument_list|,
name|mem
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|as_state
operator|==
name|AGP_ACQUIRE_USER
condition|)
name|agp_release_helper
argument_list|(
name|dev
argument_list|,
name|AGP_ACQUIRE_USER
argument_list|)
expr_stmt|;
name|sc
operator|->
name|as_isopen
operator|=
literal|0
expr_stmt|;
name|device_unbusy
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|agp_ioctl
parameter_list|(
name|struct
name|cdev
modifier|*
name|kdev
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|data
parameter_list|,
name|int
name|fflag
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|device_t
name|dev
init|=
name|KDEV2DEV
argument_list|(
name|kdev
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|AGPIOC_INFO
case|:
return|return
name|agp_info_user
argument_list|(
name|dev
argument_list|,
operator|(
name|agp_info
operator|*
operator|)
name|data
argument_list|)
return|;
case|case
name|AGPIOC_ACQUIRE
case|:
return|return
name|agp_acquire_helper
argument_list|(
name|dev
argument_list|,
name|AGP_ACQUIRE_USER
argument_list|)
return|;
case|case
name|AGPIOC_RELEASE
case|:
return|return
name|agp_release_helper
argument_list|(
name|dev
argument_list|,
name|AGP_ACQUIRE_USER
argument_list|)
return|;
case|case
name|AGPIOC_SETUP
case|:
return|return
name|agp_setup_user
argument_list|(
name|dev
argument_list|,
operator|(
name|agp_setup
operator|*
operator|)
name|data
argument_list|)
return|;
case|case
name|AGPIOC_ALLOCATE
case|:
return|return
name|agp_allocate_user
argument_list|(
name|dev
argument_list|,
operator|(
name|agp_allocate
operator|*
operator|)
name|data
argument_list|)
return|;
case|case
name|AGPIOC_DEALLOCATE
case|:
return|return
name|agp_deallocate_user
argument_list|(
name|dev
argument_list|,
operator|*
operator|(
name|int
operator|*
operator|)
name|data
argument_list|)
return|;
case|case
name|AGPIOC_BIND
case|:
return|return
name|agp_bind_user
argument_list|(
name|dev
argument_list|,
operator|(
name|agp_bind
operator|*
operator|)
name|data
argument_list|)
return|;
case|case
name|AGPIOC_UNBIND
case|:
return|return
name|agp_unbind_user
argument_list|(
name|dev
argument_list|,
operator|(
name|agp_unbind
operator|*
operator|)
name|data
argument_list|)
return|;
block|}
return|return
name|EINVAL
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|agp_mmap
parameter_list|(
name|struct
name|cdev
modifier|*
name|kdev
parameter_list|,
name|vm_offset_t
name|offset
parameter_list|,
name|vm_paddr_t
modifier|*
name|paddr
parameter_list|,
name|int
name|prot
parameter_list|)
block|{
name|device_t
name|dev
init|=
name|KDEV2DEV
argument_list|(
name|kdev
argument_list|)
decl_stmt|;
name|struct
name|agp_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
if|if
condition|(
name|offset
operator|>
name|AGP_GET_APERTURE
argument_list|(
name|dev
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
operator|*
name|paddr
operator|=
name|rman_get_start
argument_list|(
name|sc
operator|->
name|as_aperture
argument_list|)
operator|+
name|offset
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Implementation of the kernel api */
end_comment

begin_function
name|device_t
name|agp_find_device
parameter_list|()
block|{
if|if
condition|(
operator|!
name|agp_devclass
condition|)
return|return
literal|0
return|;
return|return
name|devclass_get_device
argument_list|(
name|agp_devclass
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_function
name|enum
name|agp_acquire_state
name|agp_state
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|agp_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
return|return
name|sc
operator|->
name|as_state
return|;
block|}
end_function

begin_function
name|void
name|agp_get_info
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|struct
name|agp_info
modifier|*
name|info
parameter_list|)
block|{
name|struct
name|agp_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|info
operator|->
name|ai_mode
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|agp_find_caps
argument_list|(
name|dev
argument_list|)
operator|+
name|AGP_STATUS
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|info
operator|->
name|ai_aperture_base
operator|=
name|rman_get_start
argument_list|(
name|sc
operator|->
name|as_aperture
argument_list|)
expr_stmt|;
name|info
operator|->
name|ai_aperture_size
operator|=
name|rman_get_size
argument_list|(
name|sc
operator|->
name|as_aperture
argument_list|)
expr_stmt|;
name|info
operator|->
name|ai_aperture_va
operator|=
operator|(
name|vm_offset_t
operator|)
name|rman_get_virtual
argument_list|(
name|sc
operator|->
name|as_aperture
argument_list|)
expr_stmt|;
name|info
operator|->
name|ai_memory_allowed
operator|=
name|sc
operator|->
name|as_maxmem
expr_stmt|;
name|info
operator|->
name|ai_memory_used
operator|=
name|sc
operator|->
name|as_allocated
expr_stmt|;
block|}
end_function

begin_function
name|int
name|agp_acquire
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
return|return
name|agp_acquire_helper
argument_list|(
name|dev
argument_list|,
name|AGP_ACQUIRE_KERNEL
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|agp_release
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
return|return
name|agp_release_helper
argument_list|(
name|dev
argument_list|,
name|AGP_ACQUIRE_KERNEL
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|agp_enable
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|u_int32_t
name|mode
parameter_list|)
block|{
return|return
name|AGP_ENABLE
argument_list|(
name|dev
argument_list|,
name|mode
argument_list|)
return|;
block|}
end_function

begin_function
name|void
modifier|*
name|agp_alloc_memory
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|int
name|type
parameter_list|,
name|vm_size_t
name|bytes
parameter_list|)
block|{
return|return
operator|(
name|void
operator|*
operator|)
name|AGP_ALLOC_MEMORY
argument_list|(
name|dev
argument_list|,
name|type
argument_list|,
name|bytes
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|agp_free_memory
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|void
modifier|*
name|handle
parameter_list|)
block|{
name|struct
name|agp_memory
modifier|*
name|mem
init|=
operator|(
expr|struct
name|agp_memory
operator|*
operator|)
name|handle
decl_stmt|;
name|AGP_FREE_MEMORY
argument_list|(
name|dev
argument_list|,
name|mem
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|agp_bind_memory
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|void
modifier|*
name|handle
parameter_list|,
name|vm_offset_t
name|offset
parameter_list|)
block|{
name|struct
name|agp_memory
modifier|*
name|mem
init|=
operator|(
expr|struct
name|agp_memory
operator|*
operator|)
name|handle
decl_stmt|;
return|return
name|AGP_BIND_MEMORY
argument_list|(
name|dev
argument_list|,
name|mem
argument_list|,
name|offset
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|agp_unbind_memory
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|void
modifier|*
name|handle
parameter_list|)
block|{
name|struct
name|agp_memory
modifier|*
name|mem
init|=
operator|(
expr|struct
name|agp_memory
operator|*
operator|)
name|handle
decl_stmt|;
return|return
name|AGP_UNBIND_MEMORY
argument_list|(
name|dev
argument_list|,
name|mem
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|agp_memory_info
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|void
modifier|*
name|handle
parameter_list|,
name|struct
name|agp_memory_info
modifier|*
name|mi
parameter_list|)
block|{
name|struct
name|agp_memory
modifier|*
name|mem
init|=
operator|(
expr|struct
name|agp_memory
operator|*
operator|)
name|handle
decl_stmt|;
name|mi
operator|->
name|ami_size
operator|=
name|mem
operator|->
name|am_size
expr_stmt|;
name|mi
operator|->
name|ami_physical
operator|=
name|mem
operator|->
name|am_physical
expr_stmt|;
name|mi
operator|->
name|ami_offset
operator|=
name|mem
operator|->
name|am_offset
expr_stmt|;
name|mi
operator|->
name|ami_is_bound
operator|=
name|mem
operator|->
name|am_is_bound
expr_stmt|;
block|}
end_function

end_unit

