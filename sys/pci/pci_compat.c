begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1997, Stefan Esser<se@freebsd.org>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice unmodified, this list of conditions, and the following  *    disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *  * $FreeBSD$  *  */
end_comment

begin_include
include|#
directive|include
file|"pci.h"
end_include

begin_if
if|#
directive|if
name|NPCI
operator|>
literal|0
end_if

begin_comment
comment|/* for compatibility to FreeBSD-2.2 version of PCI code */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/linker_set.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<sys/interrupt.h>
end_include

begin_include
include|#
directive|include
file|<pci/pcireg.h>
end_include

begin_include
include|#
directive|include
file|<pci/pcivar.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|RESOURCE_CHECK
end_ifdef

begin_include
include|#
directive|include
file|<sys/drvresource.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|APIC_IO
end_ifdef

begin_include
include|#
directive|include
file|<machine/smp.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|PCI_COMPAT
end_ifdef

begin_comment
comment|/* ------------------------------------------------------------------------- */
end_comment

begin_function
specifier|static
name|int
name|pci_mapno
parameter_list|(
name|pcicfgregs
modifier|*
name|cfg
parameter_list|,
name|int
name|reg
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|nummaps
decl_stmt|;
name|pcimap
modifier|*
name|map
decl_stmt|;
name|nummaps
operator|=
name|cfg
operator|->
name|nummaps
expr_stmt|;
name|map
operator|=
name|cfg
operator|->
name|map
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nummaps
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|map
index|[
name|i
index|]
operator|.
name|reg
operator|==
name|reg
condition|)
return|return
operator|(
name|i
operator|)
return|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pci_porten
parameter_list|(
name|pcicfgregs
modifier|*
name|cfg
parameter_list|)
block|{
return|return
operator|(
operator|(
name|cfg
operator|->
name|cmdreg
operator|&
name|PCIM_CMD_PORTEN
operator|)
operator|!=
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pci_isportmap
parameter_list|(
name|pcicfgregs
modifier|*
name|cfg
parameter_list|,
name|int
name|map
parameter_list|)
block|{
return|return
operator|(
operator|(
name|unsigned
operator|)
name|map
operator|<
name|cfg
operator|->
name|nummaps
operator|&&
operator|(
name|cfg
operator|->
name|map
index|[
name|map
index|]
operator|.
name|type
operator|&
name|PCI_MAPPORT
operator|)
operator|!=
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pci_memen
parameter_list|(
name|pcicfgregs
modifier|*
name|cfg
parameter_list|)
block|{
return|return
operator|(
operator|(
name|cfg
operator|->
name|cmdreg
operator|&
name|PCIM_CMD_MEMEN
operator|)
operator|!=
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pci_ismemmap
parameter_list|(
name|pcicfgregs
modifier|*
name|cfg
parameter_list|,
name|int
name|map
parameter_list|)
block|{
return|return
operator|(
operator|(
name|unsigned
operator|)
name|map
operator|<
name|cfg
operator|->
name|nummaps
operator|&&
operator|(
name|cfg
operator|->
name|map
index|[
name|map
index|]
operator|.
name|type
operator|&
name|PCI_MAPMEM
operator|)
operator|!=
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------- */
end_comment

begin_function
name|u_long
name|pci_conf_read
parameter_list|(
name|pcici_t
name|tag
parameter_list|,
name|u_long
name|reg
parameter_list|)
block|{
return|return
operator|(
name|pci_cfgread
argument_list|(
name|tag
argument_list|,
name|reg
argument_list|,
literal|4
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|void
name|pci_conf_write
parameter_list|(
name|pcici_t
name|tag
parameter_list|,
name|u_long
name|reg
parameter_list|,
name|u_long
name|data
parameter_list|)
block|{
name|pci_cfgwrite
argument_list|(
name|tag
argument_list|,
name|reg
argument_list|,
name|data
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|pci_map_port
parameter_list|(
name|pcici_t
name|cfg
parameter_list|,
name|u_long
name|reg
parameter_list|,
name|pci_port_t
modifier|*
name|pa
parameter_list|)
block|{
name|int
name|map
decl_stmt|;
name|map
operator|=
name|pci_mapno
argument_list|(
name|cfg
argument_list|,
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|pci_porten
argument_list|(
name|cfg
argument_list|)
operator|&&
name|pci_isportmap
argument_list|(
name|cfg
argument_list|,
name|map
argument_list|)
condition|)
block|{
name|u_int32_t
name|iobase
decl_stmt|;
name|u_int32_t
name|iosize
decl_stmt|;
name|iobase
operator|=
name|cfg
operator|->
name|map
index|[
name|map
index|]
operator|.
name|base
expr_stmt|;
name|iosize
operator|=
literal|1
operator|<<
name|cfg
operator|->
name|map
index|[
name|map
index|]
operator|.
name|ln2size
expr_stmt|;
ifdef|#
directive|ifdef
name|RESOURCE_CHECK
if|if
condition|(
name|resource_claim
argument_list|(
name|cfg
argument_list|,
name|REST_PORT
argument_list|,
name|RESF_NONE
argument_list|,
name|iobase
argument_list|,
name|iobase
operator|+
name|iosize
operator|-
literal|1
argument_list|)
operator|==
literal|0
condition|)
endif|#
directive|endif
comment|/* RESOURCE_CHECK */
block|{
operator|*
name|pa
operator|=
name|iobase
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pci_map_mem
parameter_list|(
name|pcici_t
name|cfg
parameter_list|,
name|u_long
name|reg
parameter_list|,
name|vm_offset_t
modifier|*
name|va
parameter_list|,
name|vm_offset_t
modifier|*
name|pa
parameter_list|)
block|{
name|int
name|map
decl_stmt|;
name|map
operator|=
name|pci_mapno
argument_list|(
name|cfg
argument_list|,
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|pci_memen
argument_list|(
name|cfg
argument_list|)
operator|&&
name|pci_ismemmap
argument_list|(
name|cfg
argument_list|,
name|map
argument_list|)
condition|)
block|{
name|u_int32_t
name|paddr
decl_stmt|;
name|u_int32_t
name|psize
decl_stmt|;
name|paddr
operator|=
name|cfg
operator|->
name|map
index|[
name|map
index|]
operator|.
name|base
expr_stmt|;
name|psize
operator|=
literal|1
operator|<<
name|cfg
operator|->
name|map
index|[
name|map
index|]
operator|.
name|ln2size
expr_stmt|;
ifdef|#
directive|ifdef
name|RESOURCE_CHECK
if|if
condition|(
name|resource_claim
argument_list|(
name|cfg
argument_list|,
name|REST_MEM
argument_list|,
name|RESF_NONE
argument_list|,
name|paddr
argument_list|,
name|paddr
operator|+
name|psize
operator|-
literal|1
argument_list|)
operator|==
literal|0
condition|)
endif|#
directive|endif
comment|/* RESOURCE_CHECK */
block|{
name|u_int32_t
name|poffs
decl_stmt|;
name|vm_offset_t
name|vaddr
decl_stmt|;
name|poffs
operator|=
name|paddr
operator|-
name|trunc_page
argument_list|(
name|paddr
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|__i386__
name|vaddr
operator|=
operator|(
name|vm_offset_t
operator|)
name|pmap_mapdev
argument_list|(
name|paddr
operator|-
name|poffs
argument_list|,
name|psize
operator|+
name|poffs
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|__alpha__
name|vaddr
operator|=
name|paddr
operator|-
name|poffs
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|vaddr
operator|!=
name|NULL
condition|)
block|{
name|vaddr
operator|+=
name|poffs
expr_stmt|;
operator|*
name|va
operator|=
name|vaddr
expr_stmt|;
operator|*
name|pa
operator|=
name|paddr
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pci_map_dense
parameter_list|(
name|pcici_t
name|cfg
parameter_list|,
name|u_long
name|reg
parameter_list|,
name|vm_offset_t
modifier|*
name|va
parameter_list|,
name|vm_offset_t
modifier|*
name|pa
parameter_list|)
block|{
if|if
condition|(
name|pci_map_mem
argument_list|(
name|cfg
argument_list|,
name|reg
argument_list|,
name|va
argument_list|,
name|pa
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|__alpha__
name|vm_offset_t
name|dense
decl_stmt|;
if|if
condition|(
name|dense
operator|=
name|pci_cvt_to_dense
argument_list|(
operator|*
name|pa
argument_list|)
condition|)
block|{
operator|*
name|pa
operator|=
name|dense
expr_stmt|;
operator|*
name|va
operator|=
name|ALPHA_PHYS_TO_K0SEG
argument_list|(
operator|*
name|pa
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|__i386__
return|return
operator|(
literal|1
operator|)
return|;
endif|#
directive|endif
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pci_map_bwx
parameter_list|(
name|pcici_t
name|cfg
parameter_list|,
name|u_long
name|reg
parameter_list|,
name|vm_offset_t
modifier|*
name|va
parameter_list|,
name|vm_offset_t
modifier|*
name|pa
parameter_list|)
block|{
if|if
condition|(
name|pci_map_mem
argument_list|(
name|cfg
argument_list|,
name|reg
argument_list|,
name|va
argument_list|,
name|pa
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|__alpha__
name|vm_offset_t
name|bwx
decl_stmt|;
if|if
condition|(
name|bwx
operator|=
name|pci_cvt_to_bwx
argument_list|(
operator|*
name|pa
argument_list|)
condition|)
block|{
operator|*
name|pa
operator|=
name|bwx
expr_stmt|;
operator|*
name|va
operator|=
name|ALPHA_PHYS_TO_K0SEG
argument_list|(
operator|*
name|pa
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|__i386__
return|return
operator|(
literal|1
operator|)
return|;
endif|#
directive|endif
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pci_map_int
parameter_list|(
name|pcici_t
name|cfg
parameter_list|,
name|pci_inthand_t
modifier|*
name|handler
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|intrmask_t
modifier|*
name|maskptr
parameter_list|)
block|{
return|return
operator|(
name|pci_map_int_right
argument_list|(
name|cfg
argument_list|,
name|handler
argument_list|,
name|arg
argument_list|,
name|maskptr
argument_list|,
literal|0
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pci_map_int_right
parameter_list|(
name|pcici_t
name|cfg
parameter_list|,
name|pci_inthand_t
modifier|*
name|handler
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|intrmask_t
modifier|*
name|maskptr
parameter_list|,
name|u_int
name|flags
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
ifdef|#
directive|ifdef
name|APIC_IO
name|int
name|nextpin
decl_stmt|,
name|muxcnt
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|cfg
operator|->
name|intpin
operator|!=
literal|0
condition|)
block|{
name|int
name|irq
init|=
name|cfg
operator|->
name|intline
decl_stmt|;
name|void
modifier|*
name|dev_instance
init|=
operator|(
name|void
operator|*
operator|)
operator|-
literal|1
decl_stmt|;
comment|/* XXX use cfg->devdata  */
name|void
modifier|*
name|idesc
decl_stmt|;
name|idesc
operator|=
name|intr_create
argument_list|(
name|dev_instance
argument_list|,
name|irq
argument_list|,
name|handler
argument_list|,
name|arg
argument_list|,
name|maskptr
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|error
operator|=
name|intr_connect
argument_list|(
name|idesc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
ifdef|#
directive|ifdef
name|APIC_IO
name|nextpin
operator|=
name|next_apic_irq
argument_list|(
name|irq
argument_list|)
expr_stmt|;
if|if
condition|(
name|nextpin
operator|<
literal|0
condition|)
return|return
literal|1
return|;
comment|/*  		 * Attempt handling of some broken mp tables. 		 * 		 * It's OK to yell (since the mp tables are broken). 		 *  		 * Hanging in the boot is not OK 		 */
name|muxcnt
operator|=
literal|2
expr_stmt|;
name|nextpin
operator|=
name|next_apic_irq
argument_list|(
name|nextpin
argument_list|)
expr_stmt|;
while|while
condition|(
name|muxcnt
operator|<
literal|5
operator|&&
name|nextpin
operator|>=
literal|0
condition|)
block|{
name|muxcnt
operator|++
expr_stmt|;
name|nextpin
operator|=
name|next_apic_irq
argument_list|(
name|nextpin
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|muxcnt
operator|>=
literal|5
condition|)
block|{
name|printf
argument_list|(
literal|"bogus MP table, more than 4 IO APIC pins connected to the same PCI device or ISA/EISA interrupt\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|printf
argument_list|(
literal|"bogus MP table, %d IO APIC pins connected to the same PCI device or ISA/EISA interrupt\n"
argument_list|,
name|muxcnt
argument_list|)
expr_stmt|;
name|nextpin
operator|=
name|next_apic_irq
argument_list|(
name|irq
argument_list|)
expr_stmt|;
while|while
condition|(
name|nextpin
operator|>=
literal|0
condition|)
block|{
name|idesc
operator|=
name|intr_create
argument_list|(
name|dev_instance
argument_list|,
name|nextpin
argument_list|,
name|handler
argument_list|,
name|arg
argument_list|,
name|maskptr
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|error
operator|=
name|intr_connect
argument_list|(
name|idesc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
name|printf
argument_list|(
literal|"Registered extra interrupt handler for int %d (in addition to int %d)\n"
argument_list|,
name|nextpin
argument_list|,
name|irq
argument_list|)
expr_stmt|;
name|nextpin
operator|=
name|next_apic_irq
argument_list|(
name|nextpin
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pci_unmap_int
parameter_list|(
name|pcici_t
name|cfg
parameter_list|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
comment|/* not supported, yet, since cfg doesn't know about idesc */
block|}
end_function

begin_function
name|pcici_t
name|pci_get_parent_from_tag
parameter_list|(
name|pcici_t
name|tag
parameter_list|)
block|{
return|return
operator|(
name|pcici_t
operator|)
name|pci_devlist_get_parent
argument_list|(
name|tag
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|pci_get_bus_from_tag
parameter_list|(
name|pcici_t
name|tag
parameter_list|)
block|{
return|return
name|tag
operator|->
name|bus
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------- */
end_comment

begin_comment
comment|/*  * Preliminary support for "wired" PCI devices.  * This code supports currently only devices on PCI bus 0, since the  * mapping from PCI BIOS bus numbers to configuration file bus numbers   * is not yet maintained, whenever a PCI to PCI bridge is found.  * The "bus" field of "pciwirecfg" correlates an PCI bus with the bridge   * it is attached to. The "biosbus" field is to be updated for each bus,  * whose bridge is probed. An entry with bus != 0 and biosbus == 0 is  * invalid and will be skipped in the search for a wired unit, but not  * in the test for a free unit number.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|unit
decl_stmt|;
name|u_int8_t
name|bus
decl_stmt|;
name|u_int8_t
name|slot
decl_stmt|;
name|u_int8_t
name|func
decl_stmt|;
name|u_int8_t
name|biosbus
decl_stmt|;
block|}
name|pciwirecfg
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|pciwirecfg
name|pci_wireddevs
index|[]
init|=
block|{
comment|/* driver,	unit,	bus,	slot,	func,	BIOS bus */
ifdef|#
directive|ifdef
name|PCI_DEBUG
block|{
literal|"ncr"
block|,
literal|2
block|,
literal|1
block|,
literal|4
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"ed"
block|,
literal|2
block|,
literal|1
block|,
literal|5
block|,
literal|0
block|,
literal|0
block|}
block|,
endif|#
directive|endif
comment|/* PCI_DEBUG */
comment|/* do not delete the end marker that follows this comment !!! */
block|{
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* return unit number of wired device, or -1 if no match */
end_comment

begin_function
specifier|static
name|int
name|pci_wiredunit
parameter_list|(
name|pcicfgregs
modifier|*
name|cfg
parameter_list|,
name|char
modifier|*
name|name
parameter_list|)
block|{
name|pciwirecfg
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|pci_wireddevs
expr_stmt|;
while|while
condition|(
name|p
operator|->
name|name
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|bus
operator|==
name|cfg
operator|->
name|bus
operator|&&
name|p
operator|->
name|slot
operator|==
name|cfg
operator|->
name|slot
operator|&&
name|p
operator|->
name|func
operator|==
name|cfg
operator|->
name|func
operator|&&
name|strcmp
argument_list|(
name|p
operator|->
name|name
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|p
operator|->
name|unit
operator|)
return|;
name|p
operator|++
expr_stmt|;
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* return free unit number equal or greater to the one supplied as parameter */
end_comment

begin_function
specifier|static
name|int
name|pci_freeunit
parameter_list|(
name|pcicfgregs
modifier|*
name|cfg
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|int
name|unit
parameter_list|)
block|{
name|pciwirecfg
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|pci_wireddevs
expr_stmt|;
while|while
condition|(
name|p
operator|->
name|name
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|unit
operator|==
name|unit
operator|&&
name|strcmp
argument_list|(
name|p
operator|->
name|name
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
name|p
operator|=
name|pci_wireddevs
expr_stmt|;
name|unit
operator|++
expr_stmt|;
block|}
else|else
block|{
name|p
operator|++
expr_stmt|;
block|}
block|}
return|return
operator|(
name|unit
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|drvname
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|pci_probedrv
parameter_list|(
name|pcicfgregs
modifier|*
name|cfg
parameter_list|,
name|struct
name|pci_device
modifier|*
name|dvp
parameter_list|)
block|{
if|if
condition|(
name|dvp
operator|&&
name|dvp
operator|->
name|pd_probe
condition|)
block|{
name|pcidi_t
name|type
init|=
operator|(
name|cfg
operator|->
name|device
operator|<<
literal|16
operator|)
operator|+
name|cfg
operator|->
name|vendor
decl_stmt|;
return|return
operator|(
name|dvp
operator|->
name|pd_probe
argument_list|(
name|cfg
argument_list|,
name|type
argument_list|)
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|pci_lkm
modifier|*
name|pci_lkm_head
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|struct
name|pci_device
modifier|*
name|pci_finddrv
parameter_list|(
name|pcicfgregs
modifier|*
name|cfg
parameter_list|)
block|{
name|struct
name|pci_device
modifier|*
modifier|*
name|dvpp
decl_stmt|;
name|struct
name|pci_device
modifier|*
name|dvp
init|=
name|NULL
decl_stmt|;
name|struct
name|pci_lkm
modifier|*
name|lkm
decl_stmt|;
name|drvname
operator|=
name|NULL
expr_stmt|;
name|lkm
operator|=
name|pci_lkm_head
expr_stmt|;
while|while
condition|(
name|drvname
operator|==
name|NULL
operator|&&
name|lkm
operator|!=
name|NULL
condition|)
block|{
name|dvp
operator|=
name|lkm
operator|->
name|dvp
expr_stmt|;
name|drvname
operator|=
name|pci_probedrv
argument_list|(
name|cfg
argument_list|,
name|dvp
argument_list|)
expr_stmt|;
name|lkm
operator|=
name|lkm
operator|->
name|next
expr_stmt|;
block|}
comment|/* 	 * it wasn't a loaded driver, look in the linked in ones 	 */
name|dvpp
operator|=
operator|(
expr|struct
name|pci_device
operator|*
operator|*
operator|)
name|pcidevice_set
operator|.
name|ls_items
expr_stmt|;
while|while
condition|(
name|drvname
operator|==
name|NULL
operator|&&
operator|(
name|dvp
operator|=
operator|*
name|dvpp
operator|++
operator|)
operator|!=
name|NULL
condition|)
name|drvname
operator|=
name|pci_probedrv
argument_list|(
name|cfg
argument_list|,
name|dvp
argument_list|)
expr_stmt|;
comment|/* 	 * It wasn't one of the linked in drivers either, so try the defaults. 	 */
if|if
condition|(
name|drvname
operator|==
name|NULL
condition|)
block|{
name|dvp
operator|=
operator|&
name|chipset_device
expr_stmt|;
if|if
condition|(
operator|(
name|drvname
operator|=
name|pci_probedrv
argument_list|(
name|cfg
argument_list|,
name|dvp
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|dvp
operator|=
name|NULL
expr_stmt|;
empty_stmt|;
block|}
return|return
operator|(
name|dvp
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|pci_drvmessage
parameter_list|(
name|pcicfgregs
modifier|*
name|cfg
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|int
name|unit
parameter_list|)
block|{
if|if
condition|(
name|drvname
operator|==
name|NULL
operator|||
operator|*
name|drvname
operator|==
literal|'\0'
condition|)
return|return;
name|printf
argument_list|(
literal|"%s%d:<%s> rev 0x%02x"
argument_list|,
name|name
argument_list|,
name|unit
argument_list|,
name|drvname
argument_list|,
name|cfg
operator|->
name|revid
argument_list|)
expr_stmt|;
if|if
condition|(
name|cfg
operator|->
name|intpin
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|" int %c irq %d"
argument_list|,
name|cfg
operator|->
name|intpin
operator|+
literal|'a'
operator|-
literal|1
argument_list|,
name|cfg
operator|->
name|intline
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" on pci%d.%d.%d\n"
argument_list|,
name|cfg
operator|->
name|bus
argument_list|,
name|cfg
operator|->
name|slot
argument_list|,
name|cfg
operator|->
name|func
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pci_drvattach
parameter_list|(
name|struct
name|pci_devinfo
modifier|*
name|dinfo
parameter_list|)
block|{
name|struct
name|pci_device
modifier|*
name|dvp
decl_stmt|;
name|pcicfgregs
modifier|*
name|cfg
decl_stmt|;
name|cfg
operator|=
operator|&
name|dinfo
operator|->
name|cfg
expr_stmt|;
name|dvp
operator|=
name|pci_finddrv
argument_list|(
name|cfg
argument_list|)
expr_stmt|;
if|if
condition|(
name|dvp
operator|!=
name|NULL
condition|)
block|{
name|int
name|unit
decl_stmt|;
name|unit
operator|=
name|pci_wiredunit
argument_list|(
name|cfg
argument_list|,
name|dvp
operator|->
name|pd_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|unit
operator|<
literal|0
condition|)
block|{
name|unit
operator|=
name|pci_freeunit
argument_list|(
name|cfg
argument_list|,
name|dvp
operator|->
name|pd_name
argument_list|,
operator|*
name|dvp
operator|->
name|pd_count
argument_list|)
expr_stmt|;
operator|*
name|dvp
operator|->
name|pd_count
operator|=
name|unit
operator|+
literal|1
expr_stmt|;
block|}
name|pci_drvmessage
argument_list|(
name|cfg
argument_list|,
name|dvp
operator|->
name|pd_name
argument_list|,
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|dvp
operator|->
name|pd_attach
condition|)
name|dvp
operator|->
name|pd_attach
argument_list|(
name|cfg
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|dinfo
operator|->
name|device
operator|=
name|dvp
expr_stmt|;
comment|/* 		 * XXX KDM for some devices, dvp->pd_name winds up NULL. 		 * I haven't investigated enough to figure out why this 		 * would happen. 		 */
if|if
condition|(
name|dvp
operator|->
name|pd_name
operator|!=
name|NULL
condition|)
name|strncpy
argument_list|(
name|dinfo
operator|->
name|conf
operator|.
name|pd_name
argument_list|,
name|dvp
operator|->
name|pd_name
argument_list|,
sizeof|sizeof
argument_list|(
name|dinfo
operator|->
name|conf
operator|.
name|pd_name
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|strncpy
argument_list|(
name|dinfo
operator|->
name|conf
operator|.
name|pd_name
argument_list|,
literal|"????"
argument_list|,
sizeof|sizeof
argument_list|(
name|dinfo
operator|->
name|conf
operator|.
name|pd_name
argument_list|)
argument_list|)
expr_stmt|;
name|dinfo
operator|->
name|conf
operator|.
name|pd_name
index|[
sizeof|sizeof
argument_list|(
name|dinfo
operator|->
name|conf
operator|.
name|pd_name
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|dinfo
operator|->
name|conf
operator|.
name|pd_unit
operator|=
name|unit
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------- */
end_comment

begin_function
specifier|static
name|void
name|pci_rescan
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* XXX do nothing, currently, soon to come ... */
block|}
end_function

begin_function
name|int
name|pci_register_lkm
parameter_list|(
name|struct
name|pci_device
modifier|*
name|dvp
parameter_list|,
name|int
name|if_revision
parameter_list|)
block|{
name|struct
name|pci_lkm
modifier|*
name|lkm
decl_stmt|;
if|if
condition|(
name|if_revision
operator|!=
literal|0
condition|)
block|{
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|dvp
operator|==
name|NULL
operator|||
name|dvp
operator|->
name|pd_probe
operator|==
name|NULL
operator|||
name|dvp
operator|->
name|pd_attach
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|lkm
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|lkm
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
name|lkm
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|lkm
operator|->
name|dvp
operator|=
name|dvp
expr_stmt|;
name|lkm
operator|->
name|next
operator|=
name|pci_lkm_head
expr_stmt|;
name|pci_lkm_head
operator|=
name|lkm
expr_stmt|;
name|pci_rescan
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|pci_configure
parameter_list|(
name|void
parameter_list|)
block|{
name|pci_probe
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------- */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* PCI_COMPAT */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NPCI> 0 */
end_comment

end_unit

