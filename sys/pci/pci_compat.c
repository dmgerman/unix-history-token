begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1997, Stefan Esser<se@freebsd.org>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice unmodified, this list of conditions, and the following  *    disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *  * $Id: pci_compat.c,v 1.21 1999/04/11 02:46:20 eivind Exp $  *  */
end_comment

begin_include
include|#
directive|include
file|"opt_bus.h"
end_include

begin_include
include|#
directive|include
file|"pci.h"
end_include

begin_if
if|#
directive|if
name|NPCI
operator|>
literal|0
end_if

begin_comment
comment|/* for compatibility to FreeBSD-2.2 version of PCI code */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/linker_set.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<sys/interrupt.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<pci/pcireg.h>
end_include

begin_include
include|#
directive|include
file|<pci/pcivar.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|RESOURCE_CHECK
end_ifdef

begin_include
include|#
directive|include
file|<sys/drvresource.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|APIC_IO
end_ifdef

begin_include
include|#
directive|include
file|<machine/smp.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|PCI_COMPAT
end_ifdef

begin_comment
comment|/* ------------------------------------------------------------------------- */
end_comment

begin_function
name|u_long
name|pci_conf_read
parameter_list|(
name|pcici_t
name|cfg
parameter_list|,
name|u_long
name|reg
parameter_list|)
block|{
return|return
operator|(
name|pci_read_config
argument_list|(
name|cfg
operator|->
name|dev
argument_list|,
name|reg
argument_list|,
literal|4
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|void
name|pci_conf_write
parameter_list|(
name|pcici_t
name|cfg
parameter_list|,
name|u_long
name|reg
parameter_list|,
name|u_long
name|data
parameter_list|)
block|{
name|pci_write_config
argument_list|(
name|cfg
operator|->
name|dev
argument_list|,
name|reg
argument_list|,
name|data
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|pci_map_port
parameter_list|(
name|pcici_t
name|cfg
parameter_list|,
name|u_long
name|reg
parameter_list|,
name|pci_port_t
modifier|*
name|pa
parameter_list|)
block|{
name|int
name|rid
decl_stmt|;
name|struct
name|resource
modifier|*
name|res
decl_stmt|;
name|rid
operator|=
name|reg
expr_stmt|;
name|res
operator|=
name|bus_alloc_resource
argument_list|(
name|cfg
operator|->
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
operator|&
name|rid
argument_list|,
literal|0
argument_list|,
operator|~
literal|0
argument_list|,
literal|1
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
condition|)
block|{
operator|*
name|pa
operator|=
name|rman_get_start
argument_list|(
name|res
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pci_map_mem
parameter_list|(
name|pcici_t
name|cfg
parameter_list|,
name|u_long
name|reg
parameter_list|,
name|vm_offset_t
modifier|*
name|va
parameter_list|,
name|vm_offset_t
modifier|*
name|pa
parameter_list|)
block|{
name|int
name|rid
decl_stmt|;
name|struct
name|resource
modifier|*
name|res
decl_stmt|;
name|rid
operator|=
name|reg
expr_stmt|;
name|res
operator|=
name|bus_alloc_resource
argument_list|(
name|cfg
operator|->
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
operator|&
name|rid
argument_list|,
literal|0
argument_list|,
operator|~
literal|0
argument_list|,
literal|1
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
condition|)
block|{
operator|*
name|pa
operator|=
name|rman_get_start
argument_list|(
name|res
argument_list|)
expr_stmt|;
operator|*
name|va
operator|=
operator|(
name|vm_offset_t
operator|)
name|rman_get_virtual
argument_list|(
name|res
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pci_map_dense
parameter_list|(
name|pcici_t
name|cfg
parameter_list|,
name|u_long
name|reg
parameter_list|,
name|vm_offset_t
modifier|*
name|va
parameter_list|,
name|vm_offset_t
modifier|*
name|pa
parameter_list|)
block|{
if|if
condition|(
name|pci_map_mem
argument_list|(
name|cfg
argument_list|,
name|reg
argument_list|,
name|va
argument_list|,
name|pa
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|__alpha__
name|vm_offset_t
name|dense
decl_stmt|;
if|if
condition|(
name|dense
operator|=
name|pci_cvt_to_dense
argument_list|(
operator|*
name|pa
argument_list|)
condition|)
block|{
operator|*
name|pa
operator|=
name|dense
expr_stmt|;
operator|*
name|va
operator|=
name|ALPHA_PHYS_TO_K0SEG
argument_list|(
operator|*
name|pa
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|__i386__
return|return
operator|(
literal|1
operator|)
return|;
endif|#
directive|endif
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pci_map_bwx
parameter_list|(
name|pcici_t
name|cfg
parameter_list|,
name|u_long
name|reg
parameter_list|,
name|vm_offset_t
modifier|*
name|va
parameter_list|,
name|vm_offset_t
modifier|*
name|pa
parameter_list|)
block|{
if|if
condition|(
name|pci_map_mem
argument_list|(
name|cfg
argument_list|,
name|reg
argument_list|,
name|va
argument_list|,
name|pa
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|__alpha__
name|vm_offset_t
name|bwx
decl_stmt|;
if|if
condition|(
name|bwx
operator|=
name|pci_cvt_to_bwx
argument_list|(
operator|*
name|pa
argument_list|)
condition|)
block|{
operator|*
name|pa
operator|=
name|bwx
expr_stmt|;
operator|*
name|va
operator|=
name|ALPHA_PHYS_TO_K0SEG
argument_list|(
operator|*
name|pa
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|__i386__
return|return
operator|(
literal|1
operator|)
return|;
endif|#
directive|endif
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pci_map_int
parameter_list|(
name|pcici_t
name|cfg
parameter_list|,
name|pci_inthand_t
modifier|*
name|handler
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|intrmask_t
modifier|*
name|maskptr
parameter_list|)
block|{
return|return
operator|(
name|pci_map_int_right
argument_list|(
name|cfg
argument_list|,
name|handler
argument_list|,
name|arg
argument_list|,
name|maskptr
argument_list|,
literal|0
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pci_map_int_right
parameter_list|(
name|pcici_t
name|cfg
parameter_list|,
name|pci_inthand_t
modifier|*
name|handler
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|intrmask_t
modifier|*
name|maskptr
parameter_list|,
name|u_int
name|flags
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
ifdef|#
directive|ifdef
name|APIC_IO
name|int
name|nextpin
decl_stmt|,
name|muxcnt
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|cfg
operator|->
name|intpin
operator|!=
literal|0
condition|)
block|{
name|int
name|irq
init|=
name|cfg
operator|->
name|intline
decl_stmt|;
name|driver_t
modifier|*
name|driver
init|=
name|device_get_driver
argument_list|(
name|cfg
operator|->
name|dev
argument_list|)
decl_stmt|;
name|int
name|rid
init|=
literal|0
decl_stmt|;
name|struct
name|resource
modifier|*
name|res
decl_stmt|;
name|void
modifier|*
name|ih
decl_stmt|;
name|res
operator|=
name|bus_alloc_resource
argument_list|(
name|cfg
operator|->
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|rid
argument_list|,
name|irq
argument_list|,
name|irq
argument_list|,
literal|1
argument_list|,
name|RF_SHAREABLE
operator||
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|res
condition|)
block|{
name|printf
argument_list|(
literal|"pci_map_int: can't allocate interrupt\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* 		 * This is ugly. Translate the mask into a driver type. 		 */
if|if
condition|(
name|maskptr
operator|==
operator|&
name|tty_imask
condition|)
name|driver
operator|->
name|type
operator||=
name|DRIVER_TYPE_TTY
expr_stmt|;
elseif|else
if|if
condition|(
name|maskptr
operator|==
operator|&
name|bio_imask
condition|)
name|driver
operator|->
name|type
operator||=
name|DRIVER_TYPE_BIO
expr_stmt|;
elseif|else
if|if
condition|(
name|maskptr
operator|==
operator|&
name|net_imask
condition|)
name|driver
operator|->
name|type
operator||=
name|DRIVER_TYPE_NET
expr_stmt|;
elseif|else
if|if
condition|(
name|maskptr
operator|==
operator|&
name|cam_imask
condition|)
name|driver
operator|->
name|type
operator||=
name|DRIVER_TYPE_CAM
expr_stmt|;
name|error
operator|=
name|BUS_SETUP_INTR
argument_list|(
name|device_get_parent
argument_list|(
name|cfg
operator|->
name|dev
argument_list|)
argument_list|,
name|cfg
operator|->
name|dev
argument_list|,
name|res
argument_list|,
name|handler
argument_list|,
name|arg
argument_list|,
operator|&
name|ih
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
ifdef|#
directive|ifdef
name|NEW_BUS_PCI
comment|/* 		 * XXX this apic stuff looks totally busted.  It should 		 * move to the nexus code which actually registers the 		 * interrupt. 		 */
endif|#
directive|endif
ifdef|#
directive|ifdef
name|APIC_IO
name|nextpin
operator|=
name|next_apic_irq
argument_list|(
name|irq
argument_list|)
expr_stmt|;
if|if
condition|(
name|nextpin
operator|<
literal|0
condition|)
return|return
literal|1
return|;
comment|/*  		 * Attempt handling of some broken mp tables. 		 * 		 * It's OK to yell (since the mp tables are broken). 		 *  		 * Hanging in the boot is not OK 		 */
name|muxcnt
operator|=
literal|2
expr_stmt|;
name|nextpin
operator|=
name|next_apic_irq
argument_list|(
name|nextpin
argument_list|)
expr_stmt|;
while|while
condition|(
name|muxcnt
operator|<
literal|5
operator|&&
name|nextpin
operator|>=
literal|0
condition|)
block|{
name|muxcnt
operator|++
expr_stmt|;
name|nextpin
operator|=
name|next_apic_irq
argument_list|(
name|nextpin
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|muxcnt
operator|>=
literal|5
condition|)
block|{
name|printf
argument_list|(
literal|"bogus MP table, more than 4 IO APIC pins connected to the same PCI device or ISA/EISA interrupt\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|printf
argument_list|(
literal|"bogus MP table, %d IO APIC pins connected to the same PCI device or ISA/EISA interrupt\n"
argument_list|,
name|muxcnt
argument_list|)
expr_stmt|;
name|nextpin
operator|=
name|next_apic_irq
argument_list|(
name|irq
argument_list|)
expr_stmt|;
while|while
condition|(
name|nextpin
operator|>=
literal|0
condition|)
block|{
name|rid
operator|=
literal|0
expr_stmt|;
name|res
operator|=
name|bus_alloc_resource
argument_list|(
name|cfg
operator|->
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|rid
argument_list|,
name|nextpin
argument_list|,
name|nextpin
argument_list|,
literal|1
argument_list|,
name|RF_SHAREABLE
operator||
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|res
condition|)
block|{
name|printf
argument_list|(
literal|"pci_map_int: can't allocate extra interrupt\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|error
operator|=
name|BUS_SETUP_INTR
argument_list|(
name|device_get_parent
argument_list|(
name|cfg
operator|->
name|dev
argument_list|)
argument_list|,
name|cfg
operator|->
name|dev
argument_list|,
name|res
argument_list|,
name|handler
argument_list|,
name|arg
argument_list|,
operator|&
name|ih
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"pci_map_int: BUS_SETUP_INTR failed\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|printf
argument_list|(
literal|"Registered extra interrupt handler for int %d (in addition to int %d)\n"
argument_list|,
name|nextpin
argument_list|,
name|irq
argument_list|)
expr_stmt|;
name|nextpin
operator|=
name|next_apic_irq
argument_list|(
name|nextpin
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pci_unmap_int
parameter_list|(
name|pcici_t
name|cfg
parameter_list|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
comment|/* not supported, yet, since cfg doesn't know about idesc */
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* ------------------------------------------------------------------------- */
end_comment

begin_comment
comment|/*  * Preliminary support for "wired" PCI devices.  * This code supports currently only devices on PCI bus 0, since the  * mapping from PCI BIOS bus numbers to configuration file bus numbers   * is not yet maintained, whenever a PCI to PCI bridge is found.  * The "bus" field of "pciwirecfg" correlates an PCI bus with the bridge   * it is attached to. The "biosbus" field is to be updated for each bus,  * whose bridge is probed. An entry with bus != 0 and biosbus == 0 is  * invalid and will be skipped in the search for a wired unit, but not  * in the test for a free unit number.  */
end_comment

begin_comment
unit|typedef struct { 	char		*name; 	int		unit; 	u_int8_t	bus; 	u_int8_t	slot; 	u_int8_t	func; 	u_int8_t	biosbus; } pciwirecfg;  static pciwirecfg pci_wireddevs[] = {
comment|/* driver,	unit,	bus,	slot,	func,	BIOS bus */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|PCI_DEBUG
end_ifdef

begin_endif
unit|{ "ncr",	2,	1,	4,	0,	0	}, 	{ "ed",		2,	1,	5,	0,	0	},
endif|#
directive|endif
end_endif

begin_comment
comment|/* PCI_DEBUG */
end_comment

begin_comment
comment|/* do not delete the end marker that follows this comment !!! */
end_comment

begin_comment
unit|{ NULL } };
comment|/* return unit number of wired device, or -1 if no match */
end_comment

begin_comment
unit|static int pci_wiredunit(pcicfgregs *cfg, char *name) { 	pciwirecfg *p;  	p = pci_wireddevs; 	while (p->name != NULL) { 		if (p->bus == cfg->bus&& p->slot == cfg->slot&& p->func == cfg->func&& strcmp(p->name, name) == 0) 			return (p->unit); 		p++; 	} 	return (-1); }
comment|/* return free unit number equal or greater to the one supplied as parameter */
end_comment

begin_comment
unit|static int pci_freeunit(pcicfgregs *cfg, char *name, int unit) { 	pciwirecfg *p;  	p = pci_wireddevs; 	while (p->name != NULL) { 		if (p->unit == unit&& strcmp(p->name, name) == 0) { 			p = pci_wireddevs; 			unit++; 		} else { 			p++; 		} 	} 	return (unit); }  static const char *drvname;  static const char* pci_probedrv(pcicfgregs *cfg, struct pci_device *dvp) { 	if (dvp&& dvp->pd_probe) { 		pcidi_t type = (cfg->device<< 16) + cfg->vendor; 		return (dvp->pd_probe(cfg, type)); 	} 	return (NULL); }  static struct pci_lkm *pci_lkm_head;  static struct pci_device* pci_finddrv(pcicfgregs *cfg) { 	struct pci_device **dvpp; 	struct pci_device *dvp = NULL; 	struct pci_lkm *lkm;  	drvname = NULL; 	lkm = pci_lkm_head; 	while (drvname == NULL&& lkm != NULL) { 		dvp = lkm->dvp; 		drvname = pci_probedrv(cfg, dvp); 		lkm = lkm->next; 	}  	dvpp = (struct pci_device **)pcidevice_set.ls_items; 	while (drvname == NULL&& (dvp = *dvpp++) != NULL) 		drvname = pci_probedrv(cfg, dvp); 	return (dvp); }  static void pci_drvmessage(pcicfgregs *cfg, char *name, int unit) { 	if (drvname == NULL || *drvname == '\0') 		return; 	printf("%s%d:<%s> rev 0x%02x", name, unit, drvname, cfg->revid); 	if (cfg->intpin != 0) 		printf(" int %c irq %d", cfg->intpin + 'a' -1, cfg->intline); 	printf(" on pci%d.%d.%d\n", cfg->bus, cfg->slot, cfg->func); }   void pci_drvattach(struct pci_devinfo *dinfo) { 	struct pci_device *dvp; 	pcicfgregs *cfg;  	cfg =&dinfo->cfg; 	dvp = pci_finddrv(cfg); 	if (dvp != NULL) { 		int unit;  		unit = pci_wiredunit(cfg, dvp->pd_name); 		if (unit< 0) { 			unit = pci_freeunit(cfg, dvp->pd_name, *dvp->pd_count); 			*dvp->pd_count = unit +1; 		} 		pci_drvmessage(cfg, dvp->pd_name, unit); 		if (dvp->pd_attach) 			dvp->pd_attach(cfg, unit);  		dinfo->device = dvp;
comment|/* 		 * XXX KDM for some devices, dvp->pd_name winds up NULL. 		 * I haven't investigated enough to figure out why this 		 * would happen. 		 */
end_comment

begin_comment
unit|if (dvp->pd_name != NULL) 			strncpy(dinfo->conf.pd_name, dvp->pd_name, 				sizeof(dinfo->conf.pd_name)); 		else 			strncpy(dinfo->conf.pd_name, "????", 				sizeof(dinfo->conf.pd_name)); 		dinfo->conf.pd_name[sizeof(dinfo->conf.pd_name) - 1] = 0;  		dinfo->conf.pd_unit = unit;  	} }
comment|/* ------------------------------------------------------------------------- */
end_comment

begin_comment
unit|static void pci_rescan(void) {
comment|/* XXX do nothing, currently, soon to come ... */
end_comment

begin_comment
unit|}  int pci_register_lkm (struct pci_device *dvp, int if_revision) { 	struct pci_lkm *lkm;  	if (if_revision != 0) { 		return (-1); 	} 	if (dvp == NULL || dvp->pd_probe == NULL || dvp->pd_attach == NULL) { 		return (-1); 	} 	lkm = malloc (sizeof (*lkm), M_DEVBUF, M_NOWAIT); 	if (lkm == NULL) { 		return (-1); 	} 	bzero(lkm, sizeof (*lkm));  	lkm->dvp = dvp; 	lkm->next = pci_lkm_head; 	pci_lkm_head = lkm; 	pci_rescan(); 	return (0); }  void pci_configure(void) { 	pci_probe(NULL); }
comment|/* ------------------------------------------------------------------------- */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* PCI_COMPAT */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NPCI> 0 */
end_comment

end_unit

