begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * ----------------------------------------------------------------------------  * "THE BEER-WARE LICENSE" (Revision 42):  *<phk@FreeBSD.org> wrote this file.  As long as you retain this notice you  * can do whatever you want with this stuff. If we meet some day, and you think  * this stuff is worth it, you can buy me a beer in return.   Poul-Henning Kamp  * ----------------------------------------------------------------------------  */
end_comment

begin_comment
comment|/*  * Driver for Siemens reference design card "Easy321-R1".  *  * This card contains a FALC54 E1/T1 framer and a MUNICH32X 32-channel HDLC  * controller.   *  * The driver supports E1 mode with up to 31 channels.  We send CRC4 but don't  * check it coming in.  *  * The FALC54 and MUNICH32X have far too many registers and weird modes for  * comfort, so I have not bothered typing it all into a "fooreg.h" file,  * you will (badly!) need the documentation anyway if you want to mess with  * this gadget.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Stuff to describe the MUNIC32X and FALC54 chips.  */
end_comment

begin_define
define|#
directive|define
name|M32_CHAN
value|32
end_define

begin_comment
comment|/* We have 32 channels */
end_comment

begin_define
define|#
directive|define
name|M32_TS
value|32
end_define

begin_comment
comment|/* We have 32 timeslots */
end_comment

begin_define
define|#
directive|define
name|NG_MN_NODE_TYPE
value|"mn"
end_define

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcireg.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcivar.h>
end_include

begin_include
include|#
directive|include
file|"pci_if.h"
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<netgraph/ng_message.h>
end_include

begin_include
include|#
directive|include
file|<netgraph/netgraph.h>
end_include

begin_decl_stmt
specifier|static
name|int
name|mn_maxlatency
init|=
literal|1000
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_debug
argument_list|,
name|OID_AUTO
argument_list|,
name|mn_maxlatency
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|mn_maxlatency
argument_list|,
literal|0
argument_list|,
literal|"The number of milliseconds a packet is allowed to spend in the output queue.  "
literal|"If the output queue is longer than this number of milliseconds when the packet "
literal|"arrives for output, the packet will be dropped."
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|NMN
end_ifndef

begin_comment
comment|/* Most machines don't support more than 4 busmaster PCI slots, if even that many */
end_comment

begin_define
define|#
directive|define
name|NMN
value|4
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* From: PEB 20321 data sheet, p187, table 22 */
end_comment

begin_struct
struct|struct
name|m32xreg
block|{
name|u_int32_t
name|conf
decl_stmt|,
name|cmd
decl_stmt|,
name|stat
decl_stmt|,
name|imask
decl_stmt|;
name|u_int32_t
name|fill10
decl_stmt|,
name|piqba
decl_stmt|,
name|piql
decl_stmt|,
name|fill1c
decl_stmt|;
name|u_int32_t
name|mode1
decl_stmt|,
name|mode2
decl_stmt|,
name|ccba
decl_stmt|,
name|txpoll
decl_stmt|;
name|u_int32_t
name|tiqba
decl_stmt|,
name|tiql
decl_stmt|,
name|riqba
decl_stmt|,
name|riql
decl_stmt|;
name|u_int32_t
name|lconf
decl_stmt|,
name|lccba
decl_stmt|,
name|fill48
decl_stmt|,
name|ltran
decl_stmt|;
name|u_int32_t
name|ltiqba
decl_stmt|,
name|ltiql
decl_stmt|,
name|lriqba
decl_stmt|,
name|lriql
decl_stmt|;
name|u_int32_t
name|lreg0
decl_stmt|,
name|lreg1
decl_stmt|,
name|lreg2
decl_stmt|,
name|lreg3
decl_stmt|;
name|u_int32_t
name|lreg4
decl_stmt|,
name|lreg5
decl_stmt|,
name|lre6
decl_stmt|,
name|lstat
decl_stmt|;
name|u_int32_t
name|gpdir
decl_stmt|,
name|gpdata
decl_stmt|,
name|gpod
decl_stmt|,
name|fill8c
decl_stmt|;
name|u_int32_t
name|ssccon
decl_stmt|,
name|sscbr
decl_stmt|,
name|ssctb
decl_stmt|,
name|sscrb
decl_stmt|;
name|u_int32_t
name|ssccse
decl_stmt|,
name|sscim
decl_stmt|,
name|fillab
decl_stmt|,
name|fillac
decl_stmt|;
name|u_int32_t
name|iomcon1
decl_stmt|,
name|iomcon2
decl_stmt|,
name|iomstat
decl_stmt|,
name|fillbc
decl_stmt|;
name|u_int32_t
name|iomcit0
decl_stmt|,
name|iomcit1
decl_stmt|,
name|iomcir0
decl_stmt|,
name|iomcir1
decl_stmt|;
name|u_int32_t
name|iomtmo
decl_stmt|,
name|iomrmo
decl_stmt|,
name|filld8
decl_stmt|,
name|filldc
decl_stmt|;
name|u_int32_t
name|mbcmd
decl_stmt|,
name|mbdata1
decl_stmt|,
name|mbdata2
decl_stmt|,
name|mbdata3
decl_stmt|;
name|u_int32_t
name|mbdata4
decl_stmt|,
name|mbdata5
decl_stmt|,
name|mbdata6
decl_stmt|,
name|mbdata7
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* From: PEB 2254 data sheet, p80, table 10 */
end_comment

begin_struct
struct|struct
name|f54wreg
block|{
name|u_int16_t
name|xfifo
decl_stmt|;
name|u_int8_t
name|cmdr
decl_stmt|,
name|mode
decl_stmt|,
name|rah1
decl_stmt|,
name|rah2
decl_stmt|,
name|ral1
decl_stmt|,
name|ral2
decl_stmt|;
name|u_int8_t
name|ipc
decl_stmt|,
name|ccr1
decl_stmt|,
name|ccr3
decl_stmt|,
name|pre
decl_stmt|,
name|rtr1
decl_stmt|,
name|rtr2
decl_stmt|,
name|rtr3
decl_stmt|,
name|rtr4
decl_stmt|;
name|u_int8_t
name|ttr1
decl_stmt|,
name|ttr2
decl_stmt|,
name|ttr3
decl_stmt|,
name|ttr4
decl_stmt|,
name|imr0
decl_stmt|,
name|imr1
decl_stmt|,
name|imr2
decl_stmt|,
name|imr3
decl_stmt|;
name|u_int8_t
name|imr4
decl_stmt|,
name|fill19
decl_stmt|,
name|fmr0
decl_stmt|,
name|fmr1
decl_stmt|,
name|fmr2
decl_stmt|,
name|loop
decl_stmt|,
name|xsw
decl_stmt|,
name|xsp
decl_stmt|;
name|u_int8_t
name|xc0
decl_stmt|,
name|xc1
decl_stmt|,
name|rc0
decl_stmt|,
name|rc1
decl_stmt|,
name|xpm0
decl_stmt|,
name|xpm1
decl_stmt|,
name|xpm2
decl_stmt|,
name|tswm
decl_stmt|;
name|u_int8_t
name|test1
decl_stmt|,
name|idle
decl_stmt|,
name|xsa4
decl_stmt|,
name|xsa5
decl_stmt|,
name|xsa6
decl_stmt|,
name|xsa7
decl_stmt|,
name|xsa8
decl_stmt|,
name|fmr3
decl_stmt|;
name|u_int8_t
name|icb1
decl_stmt|,
name|icb2
decl_stmt|,
name|icb3
decl_stmt|,
name|icb4
decl_stmt|,
name|lim0
decl_stmt|,
name|lim1
decl_stmt|,
name|pcd
decl_stmt|,
name|pcr
decl_stmt|;
name|u_int8_t
name|lim2
decl_stmt|,
name|fill39
index|[
literal|7
index|]
decl_stmt|;
name|u_int8_t
name|fill40
index|[
literal|8
index|]
decl_stmt|;
name|u_int8_t
name|fill48
index|[
literal|8
index|]
decl_stmt|;
name|u_int8_t
name|fill50
index|[
literal|8
index|]
decl_stmt|;
name|u_int8_t
name|fill58
index|[
literal|8
index|]
decl_stmt|;
name|u_int8_t
name|dec
decl_stmt|,
name|fill61
decl_stmt|,
name|test2
decl_stmt|,
name|fill63
index|[
literal|5
index|]
decl_stmt|;
name|u_int8_t
name|fill68
index|[
literal|8
index|]
decl_stmt|;
name|u_int8_t
name|xs
index|[
literal|16
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* From: PEB 2254 data sheet, p117, table 10 */
end_comment

begin_struct
struct|struct
name|f54rreg
block|{
name|u_int16_t
name|rfifo
decl_stmt|;
name|u_int8_t
name|fill2
decl_stmt|,
name|mode
decl_stmt|,
name|rah1
decl_stmt|,
name|rah2
decl_stmt|,
name|ral1
decl_stmt|,
name|ral2
decl_stmt|;
name|u_int8_t
name|ipc
decl_stmt|,
name|ccr1
decl_stmt|,
name|ccr3
decl_stmt|,
name|pre
decl_stmt|,
name|rtr1
decl_stmt|,
name|rtr2
decl_stmt|,
name|rtr3
decl_stmt|,
name|rtr4
decl_stmt|;
name|u_int8_t
name|ttr1
decl_stmt|,
name|ttr2
decl_stmt|,
name|ttr3
decl_stmt|,
name|ttr4
decl_stmt|,
name|imr0
decl_stmt|,
name|imr1
decl_stmt|,
name|imr2
decl_stmt|,
name|imr3
decl_stmt|;
name|u_int8_t
name|imr4
decl_stmt|,
name|fill19
decl_stmt|,
name|fmr0
decl_stmt|,
name|fmr1
decl_stmt|,
name|fmr2
decl_stmt|,
name|loop
decl_stmt|,
name|xsw
decl_stmt|,
name|xsp
decl_stmt|;
name|u_int8_t
name|xc0
decl_stmt|,
name|xc1
decl_stmt|,
name|rc0
decl_stmt|,
name|rc1
decl_stmt|,
name|xpm0
decl_stmt|,
name|xpm1
decl_stmt|,
name|xpm2
decl_stmt|,
name|tswm
decl_stmt|;
name|u_int8_t
name|test
decl_stmt|,
name|idle
decl_stmt|,
name|xsa4
decl_stmt|,
name|xsa5
decl_stmt|,
name|xsa6
decl_stmt|,
name|xsa7
decl_stmt|,
name|xsa8
decl_stmt|,
name|fmr13
decl_stmt|;
name|u_int8_t
name|icb1
decl_stmt|,
name|icb2
decl_stmt|,
name|icb3
decl_stmt|,
name|icb4
decl_stmt|,
name|lim0
decl_stmt|,
name|lim1
decl_stmt|,
name|pcd
decl_stmt|,
name|pcr
decl_stmt|;
name|u_int8_t
name|lim2
decl_stmt|,
name|fill39
index|[
literal|7
index|]
decl_stmt|;
name|u_int8_t
name|fill40
index|[
literal|8
index|]
decl_stmt|;
name|u_int8_t
name|fill48
index|[
literal|4
index|]
decl_stmt|,
name|frs0
decl_stmt|,
name|frs1
decl_stmt|,
name|rsw
decl_stmt|,
name|rsp
decl_stmt|;
name|u_int16_t
name|fec
decl_stmt|,
name|cvc
decl_stmt|,
name|cec1
decl_stmt|,
name|ebc
decl_stmt|;
name|u_int16_t
name|cec2
decl_stmt|,
name|cec3
decl_stmt|;
name|u_int8_t
name|rsa4
decl_stmt|,
name|rsa5
decl_stmt|,
name|rsa6
decl_stmt|,
name|rsa7
decl_stmt|;
name|u_int8_t
name|rsa8
decl_stmt|,
name|rsa6s
decl_stmt|,
name|tsr0
decl_stmt|,
name|tsr1
decl_stmt|,
name|sis
decl_stmt|,
name|rsis
decl_stmt|;
name|u_int16_t
name|rbc
decl_stmt|;
name|u_int8_t
name|isr0
decl_stmt|,
name|isr1
decl_stmt|,
name|isr2
decl_stmt|,
name|isr3
decl_stmt|,
name|fill6c
decl_stmt|,
name|fill6d
decl_stmt|,
name|gis
decl_stmt|,
name|vstr
decl_stmt|;
name|u_int8_t
name|rs
index|[
literal|16
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Transmit& receive descriptors */
end_comment

begin_struct
struct|struct
name|trxd
block|{
name|u_int32_t
name|flags
decl_stmt|;
name|vm_offset_t
name|next
decl_stmt|;
name|vm_offset_t
name|data
decl_stmt|;
name|u_int32_t
name|status
decl_stmt|;
comment|/* only used for receive */
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
comment|/* software use only */
name|struct
name|trxd
modifier|*
name|vnext
decl_stmt|;
comment|/* software use only */
block|}
struct|;
end_struct

begin_comment
comment|/* Channel specification */
end_comment

begin_struct
struct|struct
name|cspec
block|{
name|u_int32_t
name|flags
decl_stmt|;
name|vm_offset_t
name|rdesc
decl_stmt|;
name|vm_offset_t
name|tdesc
decl_stmt|;
name|u_int32_t
name|itbs
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|m32_mem
block|{
name|vm_offset_t
name|csa
decl_stmt|;
name|u_int32_t
name|ccb
decl_stmt|;
name|u_int32_t
name|reserve1
index|[
literal|2
index|]
decl_stmt|;
name|u_int32_t
name|ts
index|[
name|M32_TS
index|]
decl_stmt|;
name|struct
name|cspec
name|cs
index|[
name|M32_CHAN
index|]
decl_stmt|;
name|vm_offset_t
name|crxd
index|[
name|M32_CHAN
index|]
decl_stmt|;
name|vm_offset_t
name|ctxd
index|[
name|M32_CHAN
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_struct_decl
struct_decl|struct
name|mn_softc
struct_decl|;
end_struct_decl

begin_struct_decl
struct_decl|struct
name|sockaddr
struct_decl|;
end_struct_decl

begin_struct_decl
struct_decl|struct
name|rtentry
struct_decl|;
end_struct_decl

begin_function_decl
specifier|static
name|int
name|mn_probe
parameter_list|(
name|device_t
name|self
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mn_attach
parameter_list|(
name|device_t
name|self
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mn_create_channel
parameter_list|(
name|struct
name|mn_softc
modifier|*
name|sc
parameter_list|,
name|int
name|chan
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mn_reset
parameter_list|(
name|struct
name|mn_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|trxd
modifier|*
name|mn_alloc_desc
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mn_free_desc
parameter_list|(
name|struct
name|trxd
modifier|*
name|dp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mn_intr
parameter_list|(
name|void
modifier|*
name|xsc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u_int32_t
name|mn_parse_ts
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|,
name|int
modifier|*
name|nbit
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|notyet
end_ifdef

begin_function_decl
specifier|static
name|void
name|m32_dump
parameter_list|(
name|struct
name|mn_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|f54_dump
parameter_list|(
name|struct
name|mn_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mn_fmt_ts
parameter_list|(
name|char
modifier|*
name|p
parameter_list|,
name|u_int32_t
name|ts
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* notyet */
end_comment

begin_function_decl
specifier|static
name|void
name|f54_init
parameter_list|(
name|struct
name|mn_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|ng_constructor_t
name|ngmn_constructor
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ng_rcvmsg_t
name|ngmn_rcvmsg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ng_shutdown_t
name|ngmn_shutdown
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ng_newhook_t
name|ngmn_newhook
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ng_connect_t
name|ngmn_connect
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ng_rcvdata_t
name|ngmn_rcvdata
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ng_disconnect_t
name|ngmn_disconnect
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|ng_type
name|mntypestruct
init|=
block|{
operator|.
name|version
operator|=
name|NG_ABI_VERSION
block|,
operator|.
name|name
operator|=
name|NG_MN_NODE_TYPE
block|,
operator|.
name|constructor
operator|=
name|ngmn_constructor
block|,
operator|.
name|rcvmsg
operator|=
name|ngmn_rcvmsg
block|,
operator|.
name|shutdown
operator|=
name|ngmn_shutdown
block|,
operator|.
name|newhook
operator|=
name|ngmn_newhook
block|,
operator|.
name|connect
operator|=
name|ngmn_connect
block|,
operator|.
name|rcvdata
operator|=
name|ngmn_rcvdata
block|,
operator|.
name|disconnect
operator|=
name|ngmn_disconnect
block|, }
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|static
name|MALLOC_DEFINE
argument_list|(
name|M_MN
argument_list|,
literal|"mn"
argument_list|,
literal|"Mx driver related"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|NIQB
value|64
end_define

begin_struct
struct|struct
name|schan
block|{
enum|enum
block|{
name|DOWN
block|,
name|UP
block|}
name|state
enum|;
name|struct
name|mn_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|chan
decl_stmt|;
name|u_int32_t
name|ts
decl_stmt|;
name|char
name|name
index|[
literal|8
index|]
decl_stmt|;
name|struct
name|trxd
modifier|*
name|r1
decl_stmt|,
modifier|*
name|rl
decl_stmt|;
name|struct
name|trxd
modifier|*
name|x1
decl_stmt|,
modifier|*
name|xl
decl_stmt|;
name|hook_p
name|hook
decl_stmt|;
name|time_t
name|last_recv
decl_stmt|;
name|time_t
name|last_rxerr
decl_stmt|;
name|time_t
name|last_xmit
decl_stmt|;
name|u_long
name|rx_error
decl_stmt|;
name|u_long
name|short_error
decl_stmt|;
name|u_long
name|crc_error
decl_stmt|;
name|u_long
name|dribble_error
decl_stmt|;
name|u_long
name|long_error
decl_stmt|;
name|u_long
name|abort_error
decl_stmt|;
name|u_long
name|overflow_error
decl_stmt|;
name|int
name|last_error
decl_stmt|;
name|int
name|prev_error
decl_stmt|;
name|u_long
name|tx_pending
decl_stmt|;
name|u_long
name|tx_limit
decl_stmt|;
block|}
struct|;
end_struct

begin_enum
enum|enum
name|framing
block|{
name|WHOKNOWS
block|,
name|E1
block|,
name|E1U
block|,
name|T1
block|,
name|T1U
block|}
enum|;
end_enum

begin_struct
struct|struct
name|mn_softc
block|{
name|int
name|unit
decl_stmt|;
name|device_t
name|dev
decl_stmt|;
name|struct
name|resource
modifier|*
name|irq
decl_stmt|;
name|void
modifier|*
name|intrhand
decl_stmt|;
name|enum
name|framing
name|framing
decl_stmt|;
name|int
name|nhooks
decl_stmt|;
name|void
modifier|*
name|m0v
decl_stmt|,
modifier|*
name|m1v
decl_stmt|;
name|vm_offset_t
name|m0p
decl_stmt|,
name|m1p
decl_stmt|;
name|struct
name|m32xreg
modifier|*
name|m32x
decl_stmt|;
name|struct
name|f54wreg
modifier|*
name|f54w
decl_stmt|;
name|struct
name|f54rreg
modifier|*
name|f54r
decl_stmt|;
name|struct
name|m32_mem
name|m32_mem
decl_stmt|;
name|u_int32_t
name|tiqb
index|[
name|NIQB
index|]
decl_stmt|;
name|u_int32_t
name|riqb
index|[
name|NIQB
index|]
decl_stmt|;
name|u_int32_t
name|piqb
index|[
name|NIQB
index|]
decl_stmt|;
name|u_int32_t
name|ltiqb
index|[
name|NIQB
index|]
decl_stmt|;
name|u_int32_t
name|lriqb
index|[
name|NIQB
index|]
decl_stmt|;
name|char
name|name
index|[
literal|8
index|]
decl_stmt|;
name|u_int32_t
name|falc_irq
decl_stmt|,
name|falc_state
decl_stmt|,
name|framer_state
decl_stmt|;
name|struct
name|schan
modifier|*
name|ch
index|[
name|M32_CHAN
index|]
decl_stmt|;
name|char
name|nodename
index|[
name|NG_NODESIZ
index|]
decl_stmt|;
name|node_p
name|node
decl_stmt|;
name|u_long
name|cnt_fec
decl_stmt|;
name|u_long
name|cnt_cvc
decl_stmt|;
name|u_long
name|cnt_cec1
decl_stmt|;
name|u_long
name|cnt_ebc
decl_stmt|;
name|u_long
name|cnt_cec2
decl_stmt|;
name|u_long
name|cnt_cec3
decl_stmt|;
name|u_long
name|cnt_rbc
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|int
name|ngmn_constructor
parameter_list|(
name|node_p
name|node
parameter_list|)
block|{
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ngmn_shutdown
parameter_list|(
name|node_p
name|nodep
parameter_list|)
block|{
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ngmn_config
parameter_list|(
name|node_p
name|node
parameter_list|,
name|char
modifier|*
name|set
parameter_list|,
name|char
modifier|*
name|ret
parameter_list|)
block|{
name|struct
name|mn_softc
modifier|*
name|sc
decl_stmt|;
name|enum
name|framing
name|wframing
decl_stmt|;
name|sc
operator|=
name|NG_NODE_PRIVATE
argument_list|(
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|set
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|set
argument_list|,
literal|"line "
argument_list|,
literal|5
argument_list|)
condition|)
block|{
name|wframing
operator|=
name|sc
operator|->
name|framing
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|set
argument_list|,
literal|"line e1"
argument_list|)
condition|)
block|{
name|wframing
operator|=
name|E1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|set
argument_list|,
literal|"line e1u"
argument_list|)
condition|)
block|{
name|wframing
operator|=
name|E1U
expr_stmt|;
block|}
else|else
block|{
name|strcat
argument_list|(
name|ret
argument_list|,
literal|"ENOGROK\n"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|wframing
operator|==
name|sc
operator|->
name|framing
condition|)
return|return;
if|if
condition|(
name|sc
operator|->
name|nhooks
operator|>
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|ret
argument_list|,
literal|"Cannot change line when %d hooks open\n"
argument_list|,
name|sc
operator|->
name|nhooks
argument_list|)
expr_stmt|;
return|return;
block|}
name|sc
operator|->
name|framing
operator|=
name|wframing
expr_stmt|;
if|#
directive|if
literal|1
name|f54_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
else|#
directive|else
name|mn_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
name|printf
argument_list|(
literal|"%s CONFIG SET [%s]\n"
argument_list|,
name|sc
operator|->
name|nodename
argument_list|,
name|set
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|ret
argument_list|,
literal|"ENOGROK\n"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|ngmn_rcvmsg
parameter_list|(
name|node_p
name|node
parameter_list|,
name|item_p
name|item
parameter_list|,
name|hook_p
name|lasthook
parameter_list|)
block|{
name|struct
name|mn_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|ng_mesg
modifier|*
name|resp
init|=
name|NULL
decl_stmt|;
name|struct
name|schan
modifier|*
name|sch
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|r
decl_stmt|;
name|int
name|pos
decl_stmt|,
name|i
decl_stmt|;
name|struct
name|ng_mesg
modifier|*
name|msg
decl_stmt|;
name|NGI_GET_MSG
argument_list|(
name|item
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|sc
operator|=
name|NG_NODE_PRIVATE
argument_list|(
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|msg
operator|->
name|header
operator|.
name|typecookie
operator|!=
name|NGM_GENERIC_COOKIE
condition|)
block|{
name|NG_FREE_ITEM
argument_list|(
name|item
argument_list|)
expr_stmt|;
name|NG_FREE_MSG
argument_list|(
name|msg
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
name|msg
operator|->
name|header
operator|.
name|cmd
operator|!=
name|NGM_TEXT_CONFIG
operator|&&
name|msg
operator|->
name|header
operator|.
name|cmd
operator|!=
name|NGM_TEXT_STATUS
condition|)
block|{
name|NG_FREE_ITEM
argument_list|(
name|item
argument_list|)
expr_stmt|;
name|NG_FREE_MSG
argument_list|(
name|msg
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|NG_MKRESPONSE
argument_list|(
name|resp
argument_list|,
name|msg
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ng_mesg
argument_list|)
operator|+
name|NG_TEXTRESPONSE
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|resp
operator|==
name|NULL
condition|)
block|{
name|NG_FREE_ITEM
argument_list|(
name|item
argument_list|)
expr_stmt|;
name|NG_FREE_MSG
argument_list|(
name|msg
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
if|if
condition|(
name|msg
operator|->
name|header
operator|.
name|arglen
condition|)
name|s
operator|=
operator|(
name|char
operator|*
operator|)
name|msg
operator|->
name|data
expr_stmt|;
else|else
name|s
operator|=
name|NULL
expr_stmt|;
name|r
operator|=
operator|(
name|char
operator|*
operator|)
name|resp
operator|->
name|data
expr_stmt|;
operator|*
name|r
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|msg
operator|->
name|header
operator|.
name|cmd
operator|==
name|NGM_TEXT_CONFIG
condition|)
block|{
name|ngmn_config
argument_list|(
name|node
argument_list|,
name|s
argument_list|,
name|r
argument_list|)
expr_stmt|;
name|resp
operator|->
name|header
operator|.
name|arglen
operator|=
name|strlen
argument_list|(
name|r
argument_list|)
operator|+
literal|1
expr_stmt|;
name|NG_RESPOND_MSG
argument_list|(
name|i
argument_list|,
name|node
argument_list|,
name|item
argument_list|,
name|resp
argument_list|)
expr_stmt|;
name|NG_FREE_MSG
argument_list|(
name|msg
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|pos
operator|=
literal|0
expr_stmt|;
name|pos
operator|+=
name|sprintf
argument_list|(
name|pos
operator|+
name|r
argument_list|,
literal|"Framer status %b;\n"
argument_list|,
name|sc
operator|->
name|framer_state
argument_list|,
literal|"\20"
literal|"\40LOS\37AIS\36LFA\35RRA"
literal|"\34AUXP\33NMF\32LMFA\31frs0.0"
literal|"\30frs1.7\27TS16RA\26TS16LOS\25TS16AIS"
literal|"\24TS16LFA\23frs1.2\22XLS\21XLO"
literal|"\20RS1\17rsw.6\16RRA\15RY0"
literal|"\14RY1\13RY2\12RY3\11RY4"
literal|"\10SI1\7SI2\6rsp.5\5rsp.4"
literal|"\4rsp.3\3RSIF\2RS13\1RS15"
argument_list|)
expr_stmt|;
name|pos
operator|+=
name|sprintf
argument_list|(
name|pos
operator|+
name|r
argument_list|,
literal|"    Framing errors: %lu"
argument_list|,
name|sc
operator|->
name|cnt_fec
argument_list|)
expr_stmt|;
name|pos
operator|+=
name|sprintf
argument_list|(
name|pos
operator|+
name|r
argument_list|,
literal|"  Code Violations: %lu\n"
argument_list|,
name|sc
operator|->
name|cnt_cvc
argument_list|)
expr_stmt|;
name|pos
operator|+=
name|sprintf
argument_list|(
name|pos
operator|+
name|r
argument_list|,
literal|"    Falc State %b;\n"
argument_list|,
name|sc
operator|->
name|falc_state
argument_list|,
literal|"\20"
literal|"\40LOS\37AIS\36LFA\35RRA"
literal|"\34AUXP\33NMF\32LMFA\31frs0.0"
literal|"\30frs1.7\27TS16RA\26TS16LOS\25TS16AIS"
literal|"\24TS16LFA\23frs1.2\22XLS\21XLO"
literal|"\20RS1\17rsw.6\16RRA\15RY0"
literal|"\14RY1\13RY2\12RY3\11RY4"
literal|"\10SI1\7SI2\6rsp.5\5rsp.4"
literal|"\4rsp.3\3RSIF\2RS13\1RS15"
argument_list|)
expr_stmt|;
name|pos
operator|+=
name|sprintf
argument_list|(
name|pos
operator|+
name|r
argument_list|,
literal|"    Falc IRQ %b\n"
argument_list|,
name|sc
operator|->
name|falc_irq
argument_list|,
literal|"\20"
literal|"\40RME\37RFS\36T8MS\35RMB\34CASC\33CRC4\32SA6SC\31RPF"
literal|"\30b27\27RDO\26ALLS\25XDU\24XMB\23b22\22XLSC\21XPR"
literal|"\20FAR\17LFA\16MFAR\15T400MS\14AIS\13LOS\12RAR\11RA"
literal|"\10ES\7SEC\6LMFA16\5AIS16\4RA16\3API\2SLN\1SLP"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|M32_CHAN
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|sc
operator|->
name|ch
index|[
name|i
index|]
condition|)
continue|continue;
name|sch
operator|=
name|sc
operator|->
name|ch
index|[
name|i
index|]
expr_stmt|;
name|pos
operator|+=
name|sprintf
argument_list|(
name|r
operator|+
name|pos
argument_list|,
literal|"  Chan %d<%s> "
argument_list|,
name|i
argument_list|,
name|NG_HOOK_NAME
argument_list|(
name|sch
operator|->
name|hook
argument_list|)
argument_list|)
expr_stmt|;
name|pos
operator|+=
name|sprintf
argument_list|(
name|r
operator|+
name|pos
argument_list|,
literal|"  Last Rx: "
argument_list|)
expr_stmt|;
if|if
condition|(
name|sch
operator|->
name|last_recv
condition|)
name|pos
operator|+=
name|sprintf
argument_list|(
name|r
operator|+
name|pos
argument_list|,
literal|"%lu s"
argument_list|,
call|(
name|unsigned
name|long
call|)
argument_list|(
name|time_second
operator|-
name|sch
operator|->
name|last_recv
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|pos
operator|+=
name|sprintf
argument_list|(
name|r
operator|+
name|pos
argument_list|,
literal|"never"
argument_list|)
expr_stmt|;
name|pos
operator|+=
name|sprintf
argument_list|(
name|r
operator|+
name|pos
argument_list|,
literal|", last RxErr: "
argument_list|)
expr_stmt|;
if|if
condition|(
name|sch
operator|->
name|last_rxerr
condition|)
name|pos
operator|+=
name|sprintf
argument_list|(
name|r
operator|+
name|pos
argument_list|,
literal|"%lu s"
argument_list|,
call|(
name|unsigned
name|long
call|)
argument_list|(
name|time_second
operator|-
name|sch
operator|->
name|last_rxerr
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|pos
operator|+=
name|sprintf
argument_list|(
name|r
operator|+
name|pos
argument_list|,
literal|"never"
argument_list|)
expr_stmt|;
name|pos
operator|+=
name|sprintf
argument_list|(
name|r
operator|+
name|pos
argument_list|,
literal|", last Tx: "
argument_list|)
expr_stmt|;
if|if
condition|(
name|sch
operator|->
name|last_xmit
condition|)
name|pos
operator|+=
name|sprintf
argument_list|(
name|r
operator|+
name|pos
argument_list|,
literal|"%lu s\n"
argument_list|,
call|(
name|unsigned
name|long
call|)
argument_list|(
name|time_second
operator|-
name|sch
operator|->
name|last_xmit
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|pos
operator|+=
name|sprintf
argument_list|(
name|r
operator|+
name|pos
argument_list|,
literal|"never\n"
argument_list|)
expr_stmt|;
name|pos
operator|+=
name|sprintf
argument_list|(
name|r
operator|+
name|pos
argument_list|,
literal|"    RX error(s) %lu"
argument_list|,
name|sch
operator|->
name|rx_error
argument_list|)
expr_stmt|;
name|pos
operator|+=
name|sprintf
argument_list|(
name|r
operator|+
name|pos
argument_list|,
literal|" Short: %lu"
argument_list|,
name|sch
operator|->
name|short_error
argument_list|)
expr_stmt|;
name|pos
operator|+=
name|sprintf
argument_list|(
name|r
operator|+
name|pos
argument_list|,
literal|" CRC: %lu"
argument_list|,
name|sch
operator|->
name|crc_error
argument_list|)
expr_stmt|;
name|pos
operator|+=
name|sprintf
argument_list|(
name|r
operator|+
name|pos
argument_list|,
literal|" Mod8: %lu"
argument_list|,
name|sch
operator|->
name|dribble_error
argument_list|)
expr_stmt|;
name|pos
operator|+=
name|sprintf
argument_list|(
name|r
operator|+
name|pos
argument_list|,
literal|" Long: %lu"
argument_list|,
name|sch
operator|->
name|long_error
argument_list|)
expr_stmt|;
name|pos
operator|+=
name|sprintf
argument_list|(
name|r
operator|+
name|pos
argument_list|,
literal|" Abort: %lu"
argument_list|,
name|sch
operator|->
name|abort_error
argument_list|)
expr_stmt|;
name|pos
operator|+=
name|sprintf
argument_list|(
name|r
operator|+
name|pos
argument_list|,
literal|" Overflow: %lu\n"
argument_list|,
name|sch
operator|->
name|overflow_error
argument_list|)
expr_stmt|;
name|pos
operator|+=
name|sprintf
argument_list|(
name|r
operator|+
name|pos
argument_list|,
literal|"    Last error: %b  Prev error: %b\n"
argument_list|,
name|sch
operator|->
name|last_error
argument_list|,
literal|"\20\7SHORT\5CRC\4MOD8\3LONG\2ABORT\1OVERRUN"
argument_list|,
name|sch
operator|->
name|prev_error
argument_list|,
literal|"\20\7SHORT\5CRC\4MOD8\3LONG\2ABORT\1OVERRUN"
argument_list|)
expr_stmt|;
name|pos
operator|+=
name|sprintf
argument_list|(
name|r
operator|+
name|pos
argument_list|,
literal|"    Xmit bytes pending %ld\n"
argument_list|,
name|sch
operator|->
name|tx_pending
argument_list|)
expr_stmt|;
block|}
name|resp
operator|->
name|header
operator|.
name|arglen
operator|=
name|pos
operator|+
literal|1
expr_stmt|;
comment|/* Take care of synchronous response, if any */
name|NG_RESPOND_MSG
argument_list|(
name|i
argument_list|,
name|node
argument_list|,
name|item
argument_list|,
name|resp
argument_list|)
expr_stmt|;
name|NG_FREE_MSG
argument_list|(
name|msg
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ngmn_newhook
parameter_list|(
name|node_p
name|node
parameter_list|,
name|hook_p
name|hook
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|u_int32_t
name|ts
decl_stmt|,
name|chan
decl_stmt|;
name|struct
name|mn_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|nbit
decl_stmt|;
name|sc
operator|=
name|NG_NODE_PRIVATE
argument_list|(
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|!=
literal|'t'
operator|||
name|name
index|[
literal|1
index|]
operator|!=
literal|'s'
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|ts
operator|=
name|mn_parse_ts
argument_list|(
name|name
operator|+
literal|2
argument_list|,
operator|&
name|nbit
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%d bits %x\n"
argument_list|,
name|nbit
argument_list|,
name|ts
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|framing
operator|==
name|E1
operator|&&
operator|(
name|ts
operator|&
literal|1
operator|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|sc
operator|->
name|framing
operator|==
name|E1U
operator|&&
name|nbit
operator|!=
literal|32
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|ts
operator|==
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|sc
operator|->
name|framing
operator|==
name|E1
condition|)
name|chan
operator|=
name|ffs
argument_list|(
name|ts
argument_list|)
operator|-
literal|1
expr_stmt|;
else|else
name|chan
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|sc
operator|->
name|ch
index|[
name|chan
index|]
condition|)
name|mn_create_channel
argument_list|(
name|sc
argument_list|,
name|chan
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|sc
operator|->
name|ch
index|[
name|chan
index|]
operator|->
name|state
operator|==
name|UP
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
name|sc
operator|->
name|ch
index|[
name|chan
index|]
operator|->
name|ts
operator|=
name|ts
expr_stmt|;
name|sc
operator|->
name|ch
index|[
name|chan
index|]
operator|->
name|hook
operator|=
name|hook
expr_stmt|;
name|sc
operator|->
name|ch
index|[
name|chan
index|]
operator|->
name|tx_limit
operator|=
name|nbit
operator|*
literal|8
expr_stmt|;
name|NG_HOOK_SET_PRIVATE
argument_list|(
name|hook
argument_list|,
name|sc
operator|->
name|ch
index|[
name|chan
index|]
argument_list|)
expr_stmt|;
name|sc
operator|->
name|nhooks
operator|++
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|trxd
modifier|*
name|mn_desc_free
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|struct
name|trxd
modifier|*
name|mn_alloc_desc
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|trxd
modifier|*
name|dp
decl_stmt|;
name|dp
operator|=
name|mn_desc_free
expr_stmt|;
if|if
condition|(
name|dp
condition|)
name|mn_desc_free
operator|=
name|dp
operator|->
name|vnext
expr_stmt|;
else|else
name|dp
operator|=
operator|(
expr|struct
name|trxd
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
expr|*
name|dp
argument_list|,
name|M_MN
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
return|return
operator|(
name|dp
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mn_free_desc
parameter_list|(
name|struct
name|trxd
modifier|*
name|dp
parameter_list|)
block|{
name|dp
operator|->
name|vnext
operator|=
name|mn_desc_free
expr_stmt|;
name|mn_desc_free
operator|=
name|dp
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|u_int32_t
name|mn_parse_ts
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|,
name|int
modifier|*
name|nbit
parameter_list|)
block|{
name|unsigned
name|r
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|r
operator|=
literal|0
expr_stmt|;
name|j
operator|=
operator|-
literal|1
expr_stmt|;
operator|*
name|nbit
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
name|s
condition|)
block|{
name|i
operator|=
name|strtol
argument_list|(
name|s
argument_list|,
operator|&
name|p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
operator|||
name|i
operator|>
literal|31
condition|)
return|return
operator|(
literal|0
operator|)
return|;
while|while
condition|(
name|j
operator|!=
operator|-
literal|1
operator|&&
name|j
operator|<
name|i
condition|)
block|{
name|r
operator||=
literal|1
operator|<<
name|j
operator|++
expr_stmt|;
operator|(
operator|*
name|nbit
operator|)
operator|++
expr_stmt|;
block|}
name|j
operator|=
operator|-
literal|1
expr_stmt|;
name|r
operator||=
literal|1
operator|<<
name|i
expr_stmt|;
operator|(
operator|*
name|nbit
operator|)
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|','
condition|)
block|{
name|s
operator|=
name|p
operator|+
literal|1
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|'-'
condition|)
block|{
name|j
operator|=
name|i
operator|+
literal|1
expr_stmt|;
name|s
operator|=
name|p
operator|+
literal|1
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
operator|!
operator|*
name|p
condition|)
block|{
break|break;
block|}
else|else
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
return|return
operator|(
name|r
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|notyet
end_ifdef

begin_function
specifier|static
name|void
name|mn_fmt_ts
parameter_list|(
name|char
modifier|*
name|p
parameter_list|,
name|u_int32_t
name|ts
parameter_list|)
block|{
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|j
decl_stmt|;
name|s
operator|=
literal|""
expr_stmt|;
name|ts
operator|&=
literal|0xffffffff
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|32
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|ts
operator|&
operator|(
literal|1
operator|<<
name|j
operator|)
operator|)
condition|)
continue|continue;
name|sprintf
argument_list|(
name|p
argument_list|,
literal|"%s%d"
argument_list|,
name|s
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|p
operator|+=
name|strlen
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|s
operator|=
literal|","
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ts
operator|&
operator|(
literal|1
operator|<<
operator|(
name|j
operator|+
literal|1
operator|)
operator|)
operator|)
condition|)
continue|continue;
for|for
control|(
init|;
name|j
operator|<
literal|32
condition|;
name|j
operator|++
control|)
if|if
condition|(
operator|!
operator|(
name|ts
operator|&
operator|(
literal|1
operator|<<
operator|(
name|j
operator|+
literal|1
operator|)
operator|)
operator|)
condition|)
break|break;
name|sprintf
argument_list|(
name|p
argument_list|,
literal|"-%d"
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|p
operator|+=
name|strlen
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|s
operator|=
literal|","
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* notyet */
end_comment

begin_comment
comment|/*  * OUTPUT  */
end_comment

begin_function
specifier|static
name|int
name|ngmn_rcvdata
parameter_list|(
name|hook_p
name|hook
parameter_list|,
name|item_p
name|item
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m2
decl_stmt|;
name|struct
name|trxd
modifier|*
name|dp
decl_stmt|,
modifier|*
name|dp2
decl_stmt|;
name|struct
name|schan
modifier|*
name|sch
decl_stmt|;
name|struct
name|mn_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|chan
decl_stmt|,
name|pitch
decl_stmt|,
name|len
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|sch
operator|=
name|NG_HOOK_PRIVATE
argument_list|(
name|hook
argument_list|)
expr_stmt|;
name|sc
operator|=
name|sch
operator|->
name|sc
expr_stmt|;
name|chan
operator|=
name|sch
operator|->
name|chan
expr_stmt|;
if|if
condition|(
name|sch
operator|->
name|state
operator|!=
name|UP
condition|)
block|{
name|NG_FREE_ITEM
argument_list|(
name|item
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|NGI_GET_M
argument_list|(
name|item
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|sch
operator|->
name|tx_pending
operator|+
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|>
name|sch
operator|->
name|tx_limit
operator|*
name|mn_maxlatency
condition|)
block|{
name|NG_FREE_M
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|NG_FREE_ITEM
argument_list|(
name|item
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|NG_FREE_ITEM
argument_list|(
name|item
argument_list|)
expr_stmt|;
name|pitch
operator|=
literal|0
expr_stmt|;
name|m2
operator|=
name|m
expr_stmt|;
name|dp2
operator|=
name|sc
operator|->
name|ch
index|[
name|chan
index|]
operator|->
name|xl
expr_stmt|;
name|len
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
while|while
condition|(
name|len
condition|)
block|{
name|dp
operator|=
name|mn_alloc_desc
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|dp
condition|)
block|{
name|pitch
operator|++
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|sc
operator|->
name|ch
index|[
name|chan
index|]
operator|->
name|xl
operator|=
name|dp2
expr_stmt|;
name|dp
operator|=
name|dp2
operator|->
name|vnext
expr_stmt|;
while|while
condition|(
name|dp
condition|)
block|{
name|dp2
operator|=
name|dp
operator|->
name|vnext
expr_stmt|;
name|mn_free_desc
argument_list|(
name|dp
argument_list|)
expr_stmt|;
name|dp
operator|=
name|dp2
expr_stmt|;
block|}
name|sc
operator|->
name|ch
index|[
name|chan
index|]
operator|->
name|xl
operator|->
name|vnext
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|dp
operator|->
name|data
operator|=
name|vtophys
argument_list|(
name|m2
operator|->
name|m_data
argument_list|)
expr_stmt|;
name|dp
operator|->
name|flags
operator|=
name|m2
operator|->
name|m_len
operator|<<
literal|16
expr_stmt|;
name|dp
operator|->
name|flags
operator|+=
literal|1
expr_stmt|;
name|len
operator|-=
name|m2
operator|->
name|m_len
expr_stmt|;
name|dp
operator|->
name|next
operator|=
name|vtophys
argument_list|(
name|dp
argument_list|)
expr_stmt|;
name|dp
operator|->
name|vnext
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|ch
index|[
name|chan
index|]
operator|->
name|xl
operator|->
name|next
operator|=
name|vtophys
argument_list|(
name|dp
argument_list|)
expr_stmt|;
name|sc
operator|->
name|ch
index|[
name|chan
index|]
operator|->
name|xl
operator|->
name|vnext
operator|=
name|dp
expr_stmt|;
name|sc
operator|->
name|ch
index|[
name|chan
index|]
operator|->
name|xl
operator|=
name|dp
expr_stmt|;
if|if
condition|(
operator|!
name|len
condition|)
block|{
name|dp
operator|->
name|m
operator|=
name|m
expr_stmt|;
name|dp
operator|->
name|flags
operator||=
literal|0xc0000000
expr_stmt|;
name|dp2
operator|->
name|flags
operator|&=
operator|~
literal|0x40000000
expr_stmt|;
block|}
else|else
block|{
name|dp
operator|->
name|m
operator|=
literal|0
expr_stmt|;
name|m2
operator|=
name|m2
operator|->
name|m_next
expr_stmt|;
block|}
block|}
if|if
condition|(
name|pitch
condition|)
name|printf
argument_list|(
literal|"%s%d: Short on mem, pitched %d packets\n"
argument_list|,
name|sc
operator|->
name|name
argument_list|,
name|chan
argument_list|,
name|pitch
argument_list|)
expr_stmt|;
else|else
block|{
if|#
directive|if
literal|0
block|printf("%d = %d + %d (%p)\n", 		    sch->tx_pending + m->m_pkthdr.len, 		    sch->tx_pending , m->m_pkthdr.len, m);
endif|#
directive|endif
name|sch
operator|->
name|tx_pending
operator|+=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
name|sc
operator|->
name|m32x
operator|->
name|txpoll
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|chan
operator|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * OPEN  */
end_comment

begin_function
specifier|static
name|int
name|ngmn_connect
parameter_list|(
name|hook_p
name|hook
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|nts
decl_stmt|,
name|chan
decl_stmt|;
name|struct
name|trxd
modifier|*
name|dp
decl_stmt|,
modifier|*
name|dp2
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|mn_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|schan
modifier|*
name|sch
decl_stmt|;
name|u_int32_t
name|u
decl_stmt|;
name|sch
operator|=
name|NG_HOOK_PRIVATE
argument_list|(
name|hook
argument_list|)
expr_stmt|;
name|chan
operator|=
name|sch
operator|->
name|chan
expr_stmt|;
name|sc
operator|=
name|sch
operator|->
name|sc
expr_stmt|;
if|if
condition|(
name|sch
operator|->
name|state
operator|==
name|UP
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|sch
operator|->
name|state
operator|=
name|UP
expr_stmt|;
comment|/* Count and configure the timeslots for this channel */
for|for
control|(
name|nts
operator|=
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|32
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|sch
operator|->
name|ts
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
condition|)
block|{
name|sc
operator|->
name|m32_mem
operator|.
name|ts
index|[
name|i
index|]
operator|=
literal|0x00ff00ff
operator||
operator|(
name|chan
operator|<<
literal|24
operator|)
operator||
operator|(
name|chan
operator|<<
literal|8
operator|)
expr_stmt|;
name|nts
operator|++
expr_stmt|;
block|}
comment|/* Init the receiver& xmitter to HDLC */
name|sc
operator|->
name|m32_mem
operator|.
name|cs
index|[
name|chan
index|]
operator|.
name|flags
operator|=
literal|0x80e90006
expr_stmt|;
comment|/* Allocate two buffers per timeslot */
if|if
condition|(
name|nts
operator|==
literal|32
condition|)
name|sc
operator|->
name|m32_mem
operator|.
name|cs
index|[
name|chan
index|]
operator|.
name|itbs
operator|=
literal|63
expr_stmt|;
else|else
name|sc
operator|->
name|m32_mem
operator|.
name|cs
index|[
name|chan
index|]
operator|.
name|itbs
operator|=
name|nts
operator|*
literal|2
expr_stmt|;
comment|/* Setup a transmit chain with one descriptor */
comment|/* XXX: we actually send a 1 byte packet */
name|dp
operator|=
name|mn_alloc_desc
argument_list|()
expr_stmt|;
name|MGETHDR
argument_list|(
name|m
argument_list|,
name|M_TRYWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return
name|ENOBUFS
return|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
literal|0
expr_stmt|;
name|dp
operator|->
name|m
operator|=
name|m
expr_stmt|;
name|dp
operator|->
name|flags
operator|=
literal|0xc0000000
operator|+
operator|(
literal|1
operator|<<
literal|16
operator|)
expr_stmt|;
name|dp
operator|->
name|next
operator|=
name|vtophys
argument_list|(
name|dp
argument_list|)
expr_stmt|;
name|dp
operator|->
name|vnext
operator|=
literal|0
expr_stmt|;
name|dp
operator|->
name|data
operator|=
name|vtophys
argument_list|(
name|sc
operator|->
name|name
argument_list|)
expr_stmt|;
name|sc
operator|->
name|m32_mem
operator|.
name|cs
index|[
name|chan
index|]
operator|.
name|tdesc
operator|=
name|vtophys
argument_list|(
name|dp
argument_list|)
expr_stmt|;
name|sc
operator|->
name|ch
index|[
name|chan
index|]
operator|->
name|x1
operator|=
name|dp
expr_stmt|;
name|sc
operator|->
name|ch
index|[
name|chan
index|]
operator|->
name|xl
operator|=
name|dp
expr_stmt|;
comment|/* Setup a receive chain with 5 + NTS descriptors */
name|dp
operator|=
name|mn_alloc_desc
argument_list|()
expr_stmt|;
name|m
operator|=
name|NULL
expr_stmt|;
name|MGETHDR
argument_list|(
name|m
argument_list|,
name|M_TRYWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|mn_free_desc
argument_list|(
name|dp
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
name|MCLGET
argument_list|(
name|m
argument_list|,
name|M_TRYWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|m
operator|->
name|m_flags
operator|&
name|M_EXT
operator|)
operator|==
literal|0
condition|)
block|{
name|mn_free_desc
argument_list|(
name|dp
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
name|dp
operator|->
name|m
operator|=
name|m
expr_stmt|;
name|dp
operator|->
name|data
operator|=
name|vtophys
argument_list|(
name|m
operator|->
name|m_data
argument_list|)
expr_stmt|;
name|dp
operator|->
name|flags
operator|=
literal|0x40000000
expr_stmt|;
name|dp
operator|->
name|flags
operator|+=
literal|1600
operator|<<
literal|16
expr_stmt|;
name|dp
operator|->
name|next
operator|=
name|vtophys
argument_list|(
name|dp
argument_list|)
expr_stmt|;
name|dp
operator|->
name|vnext
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|ch
index|[
name|chan
index|]
operator|->
name|rl
operator|=
name|dp
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|nts
operator|+
literal|10
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|dp2
operator|=
name|dp
expr_stmt|;
name|dp
operator|=
name|mn_alloc_desc
argument_list|()
expr_stmt|;
name|m
operator|=
name|NULL
expr_stmt|;
name|MGETHDR
argument_list|(
name|m
argument_list|,
name|M_TRYWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|mn_free_desc
argument_list|(
name|dp
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
name|MCLGET
argument_list|(
name|m
argument_list|,
name|M_TRYWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|m
operator|->
name|m_flags
operator|&
name|M_EXT
operator|)
operator|==
literal|0
condition|)
block|{
name|mn_free_desc
argument_list|(
name|dp
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
name|dp
operator|->
name|m
operator|=
name|m
expr_stmt|;
name|dp
operator|->
name|data
operator|=
name|vtophys
argument_list|(
name|m
operator|->
name|m_data
argument_list|)
expr_stmt|;
name|dp
operator|->
name|flags
operator|=
literal|0x00000000
expr_stmt|;
name|dp
operator|->
name|flags
operator|+=
literal|1600
operator|<<
literal|16
expr_stmt|;
name|dp
operator|->
name|next
operator|=
name|vtophys
argument_list|(
name|dp2
argument_list|)
expr_stmt|;
name|dp
operator|->
name|vnext
operator|=
name|dp2
expr_stmt|;
block|}
name|sc
operator|->
name|m32_mem
operator|.
name|cs
index|[
name|chan
index|]
operator|.
name|rdesc
operator|=
name|vtophys
argument_list|(
name|dp
argument_list|)
expr_stmt|;
name|sc
operator|->
name|ch
index|[
name|chan
index|]
operator|->
name|r1
operator|=
name|dp
expr_stmt|;
comment|/* Initialize this channel */
name|sc
operator|->
name|m32_mem
operator|.
name|ccb
operator|=
literal|0x00008000
operator|+
operator|(
name|chan
operator|<<
literal|8
operator|)
expr_stmt|;
name|sc
operator|->
name|m32x
operator|->
name|cmd
operator|=
literal|0x1
expr_stmt|;
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
name|u
operator|=
name|sc
operator|->
name|m32x
operator|->
name|stat
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|u
operator|&
literal|1
operator|)
condition|)
name|printf
argument_list|(
literal|"%s: init chan %d stat %08x\n"
argument_list|,
name|sc
operator|->
name|name
argument_list|,
name|chan
argument_list|,
name|u
argument_list|)
expr_stmt|;
name|sc
operator|->
name|m32x
operator|->
name|stat
operator|=
literal|1
expr_stmt|;
comment|/* probably not at splnet, force outward queueing */
name|NG_HOOK_FORCE_QUEUE
argument_list|(
name|NG_HOOK_PEER
argument_list|(
name|hook
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * CLOSE  */
end_comment

begin_function
specifier|static
name|int
name|ngmn_disconnect
parameter_list|(
name|hook_p
name|hook
parameter_list|)
block|{
name|int
name|chan
decl_stmt|,
name|i
decl_stmt|;
name|struct
name|mn_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|schan
modifier|*
name|sch
decl_stmt|;
name|struct
name|trxd
modifier|*
name|dp
decl_stmt|,
modifier|*
name|dp2
decl_stmt|;
name|u_int32_t
name|u
decl_stmt|;
name|sch
operator|=
name|NG_HOOK_PRIVATE
argument_list|(
name|hook
argument_list|)
expr_stmt|;
name|chan
operator|=
name|sch
operator|->
name|chan
expr_stmt|;
name|sc
operator|=
name|sch
operator|->
name|sc
expr_stmt|;
if|if
condition|(
name|sch
operator|->
name|state
operator|==
name|DOWN
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|sch
operator|->
name|state
operator|=
name|DOWN
expr_stmt|;
comment|/* Set receiver& transmitter off */
name|sc
operator|->
name|m32_mem
operator|.
name|cs
index|[
name|chan
index|]
operator|.
name|flags
operator|=
literal|0x80920006
expr_stmt|;
name|sc
operator|->
name|m32_mem
operator|.
name|cs
index|[
name|chan
index|]
operator|.
name|itbs
operator|=
literal|0
expr_stmt|;
comment|/* free the timeslots */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|32
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|sc
operator|->
name|ch
index|[
name|chan
index|]
operator|->
name|ts
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
condition|)
name|sc
operator|->
name|m32_mem
operator|.
name|ts
index|[
name|i
index|]
operator|=
literal|0x20002000
expr_stmt|;
comment|/* Initialize this channel */
name|sc
operator|->
name|m32_mem
operator|.
name|ccb
operator|=
literal|0x00008000
operator|+
operator|(
name|chan
operator|<<
literal|8
operator|)
expr_stmt|;
name|sc
operator|->
name|m32x
operator|->
name|cmd
operator|=
literal|0x1
expr_stmt|;
name|DELAY
argument_list|(
literal|30
argument_list|)
expr_stmt|;
name|u
operator|=
name|sc
operator|->
name|m32x
operator|->
name|stat
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|u
operator|&
literal|1
operator|)
condition|)
name|printf
argument_list|(
literal|"%s: zap chan %d stat %08x\n"
argument_list|,
name|sc
operator|->
name|name
argument_list|,
name|chan
argument_list|,
name|u
argument_list|)
expr_stmt|;
name|sc
operator|->
name|m32x
operator|->
name|stat
operator|=
literal|1
expr_stmt|;
comment|/* Free all receive descriptors and mbufs */
for|for
control|(
name|dp
operator|=
name|sc
operator|->
name|ch
index|[
name|chan
index|]
operator|->
name|r1
init|;
name|dp
condition|;
name|dp
operator|=
name|dp2
control|)
block|{
if|if
condition|(
name|dp
operator|->
name|m
condition|)
name|m_freem
argument_list|(
name|dp
operator|->
name|m
argument_list|)
expr_stmt|;
name|sc
operator|->
name|ch
index|[
name|chan
index|]
operator|->
name|r1
operator|=
name|dp2
operator|=
name|dp
operator|->
name|vnext
expr_stmt|;
name|mn_free_desc
argument_list|(
name|dp
argument_list|)
expr_stmt|;
block|}
comment|/* Free all transmit descriptors and mbufs */
for|for
control|(
name|dp
operator|=
name|sc
operator|->
name|ch
index|[
name|chan
index|]
operator|->
name|x1
init|;
name|dp
condition|;
name|dp
operator|=
name|dp2
control|)
block|{
if|if
condition|(
name|dp
operator|->
name|m
condition|)
block|{
name|sc
operator|->
name|ch
index|[
name|chan
index|]
operator|->
name|tx_pending
operator|-=
name|dp
operator|->
name|m
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
name|m_freem
argument_list|(
name|dp
operator|->
name|m
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|ch
index|[
name|chan
index|]
operator|->
name|x1
operator|=
name|dp2
operator|=
name|dp
operator|->
name|vnext
expr_stmt|;
name|mn_free_desc
argument_list|(
name|dp
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|nhooks
operator|--
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Create a new channel.  */
end_comment

begin_function
specifier|static
name|void
name|mn_create_channel
parameter_list|(
name|struct
name|mn_softc
modifier|*
name|sc
parameter_list|,
name|int
name|chan
parameter_list|)
block|{
name|struct
name|schan
modifier|*
name|sch
decl_stmt|;
name|sch
operator|=
name|sc
operator|->
name|ch
index|[
name|chan
index|]
operator|=
operator|(
expr|struct
name|schan
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
expr|*
name|sc
operator|->
name|ch
index|[
name|chan
index|]
argument_list|,
name|M_MN
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|sch
operator|->
name|sc
operator|=
name|sc
expr_stmt|;
name|sch
operator|->
name|state
operator|=
name|DOWN
expr_stmt|;
name|sch
operator|->
name|chan
operator|=
name|chan
expr_stmt|;
name|sprintf
argument_list|(
name|sch
operator|->
name|name
argument_list|,
literal|"%s%d"
argument_list|,
name|sc
operator|->
name|name
argument_list|,
name|chan
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|notyet
end_ifdef

begin_comment
comment|/*  * Dump Munich32x state  */
end_comment

begin_function
specifier|static
name|void
name|m32_dump
parameter_list|(
name|struct
name|mn_softc
modifier|*
name|sc
parameter_list|)
block|{
name|u_int32_t
modifier|*
name|tp4
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|printf
argument_list|(
literal|"mn%d: MUNICH32X dump\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
name|tp4
operator|=
operator|(
name|u_int32_t
operator|*
operator|)
name|sc
operator|->
name|m0v
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|64
condition|;
name|j
operator|+=
literal|8
control|)
block|{
name|printf
argument_list|(
literal|"%02x"
argument_list|,
name|j
operator|*
sizeof|sizeof
expr|*
name|tp4
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|" %08x"
argument_list|,
name|tp4
index|[
name|i
operator|+
name|j
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|M32_CHAN
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|sc
operator|->
name|ch
index|[
name|j
index|]
condition|)
continue|continue;
name|printf
argument_list|(
literal|"CH%d: state %d ts %08x"
argument_list|,
name|j
argument_list|,
name|sc
operator|->
name|ch
index|[
name|j
index|]
operator|->
name|state
argument_list|,
name|sc
operator|->
name|ch
index|[
name|j
index|]
operator|->
name|ts
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  %08x %08x %08x %08x %08x %08x\n"
argument_list|,
name|sc
operator|->
name|m32_mem
operator|.
name|cs
index|[
name|j
index|]
operator|.
name|flags
argument_list|,
name|sc
operator|->
name|m32_mem
operator|.
name|cs
index|[
name|j
index|]
operator|.
name|rdesc
argument_list|,
name|sc
operator|->
name|m32_mem
operator|.
name|cs
index|[
name|j
index|]
operator|.
name|tdesc
argument_list|,
name|sc
operator|->
name|m32_mem
operator|.
name|cs
index|[
name|j
index|]
operator|.
name|itbs
argument_list|,
name|sc
operator|->
name|m32_mem
operator|.
name|crxd
index|[
name|j
index|]
argument_list|,
name|sc
operator|->
name|m32_mem
operator|.
name|ctxd
index|[
name|j
index|]
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Dump Falch54 state  */
end_comment

begin_function
specifier|static
name|void
name|f54_dump
parameter_list|(
name|struct
name|mn_softc
modifier|*
name|sc
parameter_list|)
block|{
name|u_int8_t
modifier|*
name|tp1
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|printf
argument_list|(
literal|"%s: FALC54 dump\n"
argument_list|,
name|sc
operator|->
name|name
argument_list|)
expr_stmt|;
name|tp1
operator|=
operator|(
name|u_int8_t
operator|*
operator|)
name|sc
operator|->
name|m1v
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|128
condition|;
name|j
operator|+=
literal|16
control|)
block|{
name|printf
argument_list|(
literal|"%s: %02x |"
argument_list|,
name|sc
operator|->
name|name
argument_list|,
name|j
operator|*
sizeof|sizeof
expr|*
name|tp1
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|" %02x"
argument_list|,
name|tp1
index|[
name|i
operator|+
name|j
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* notyet */
end_comment

begin_comment
comment|/*  * Init Munich32x  */
end_comment

begin_function
specifier|static
name|void
name|m32_init
parameter_list|(
name|struct
name|mn_softc
modifier|*
name|sc
parameter_list|)
block|{
name|sc
operator|->
name|m32x
operator|->
name|conf
operator|=
literal|0x00000000
expr_stmt|;
name|sc
operator|->
name|m32x
operator|->
name|mode1
operator|=
literal|0x81048000
operator|+
literal|1600
expr_stmt|;
comment|/* XXX: temp */
if|#
directive|if
literal|1
name|sc
operator|->
name|m32x
operator|->
name|mode2
operator|=
literal|0x00000081
expr_stmt|;
name|sc
operator|->
name|m32x
operator|->
name|txpoll
operator|=
literal|0xffffffff
expr_stmt|;
elif|#
directive|elif
literal|1
name|sc
operator|->
name|m32x
operator|->
name|mode2
operator|=
literal|0x00000081
expr_stmt|;
name|sc
operator|->
name|m32x
operator|->
name|txpoll
operator|=
literal|0xffffffff
expr_stmt|;
else|#
directive|else
name|sc
operator|->
name|m32x
operator|->
name|mode2
operator|=
literal|0x00000101
expr_stmt|;
endif|#
directive|endif
name|sc
operator|->
name|m32x
operator|->
name|lconf
operator|=
literal|0x6060009B
expr_stmt|;
name|sc
operator|->
name|m32x
operator|->
name|imask
operator|=
literal|0x00000000
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Init the Falc54  */
end_comment

begin_function
specifier|static
name|void
name|f54_init
parameter_list|(
name|struct
name|mn_softc
modifier|*
name|sc
parameter_list|)
block|{
name|sc
operator|->
name|f54w
operator|->
name|ipc
operator|=
literal|0x07
expr_stmt|;
name|sc
operator|->
name|f54w
operator|->
name|xpm0
operator|=
literal|0xbd
expr_stmt|;
name|sc
operator|->
name|f54w
operator|->
name|xpm1
operator|=
literal|0x03
expr_stmt|;
name|sc
operator|->
name|f54w
operator|->
name|xpm2
operator|=
literal|0x00
expr_stmt|;
name|sc
operator|->
name|f54w
operator|->
name|imr0
operator|=
literal|0x18
expr_stmt|;
comment|/* RMB, CASC */
name|sc
operator|->
name|f54w
operator|->
name|imr1
operator|=
literal|0x08
expr_stmt|;
comment|/* XMB */
name|sc
operator|->
name|f54w
operator|->
name|imr2
operator|=
literal|0x00
expr_stmt|;
name|sc
operator|->
name|f54w
operator|->
name|imr3
operator|=
literal|0x38
expr_stmt|;
comment|/* LMFA16, AIS16, RA16 */
name|sc
operator|->
name|f54w
operator|->
name|imr4
operator|=
literal|0x00
expr_stmt|;
name|sc
operator|->
name|f54w
operator|->
name|fmr0
operator|=
literal|0xf0
expr_stmt|;
comment|/* X: HDB3, R: HDB3 */
name|sc
operator|->
name|f54w
operator|->
name|fmr1
operator|=
literal|0x0e
expr_stmt|;
comment|/* Send CRC4, 2Mbit, ECM */
if|if
condition|(
name|sc
operator|->
name|framing
operator|==
name|E1
condition|)
name|sc
operator|->
name|f54w
operator|->
name|fmr2
operator|=
literal|0x03
expr_stmt|;
comment|/* Auto Rem-Alarm, Auto resync */
elseif|else
if|if
condition|(
name|sc
operator|->
name|framing
operator|==
name|E1U
condition|)
name|sc
operator|->
name|f54w
operator|->
name|fmr2
operator|=
literal|0x33
expr_stmt|;
comment|/* dais, rtm, Auto Rem-Alarm, Auto resync */
name|sc
operator|->
name|f54w
operator|->
name|lim1
operator|=
literal|0xb0
expr_stmt|;
comment|/* XCLK=8kHz, .62V threshold */
name|sc
operator|->
name|f54w
operator|->
name|pcd
operator|=
literal|0x0a
expr_stmt|;
name|sc
operator|->
name|f54w
operator|->
name|pcr
operator|=
literal|0x15
expr_stmt|;
name|sc
operator|->
name|f54w
operator|->
name|xsw
operator|=
literal|0x9f
expr_stmt|;
comment|/* fmr4 */
if|if
condition|(
name|sc
operator|->
name|framing
operator|==
name|E1
condition|)
name|sc
operator|->
name|f54w
operator|->
name|xsp
operator|=
literal|0x1c
expr_stmt|;
comment|/* fmr5 */
elseif|else
if|if
condition|(
name|sc
operator|->
name|framing
operator|==
name|E1U
condition|)
name|sc
operator|->
name|f54w
operator|->
name|xsp
operator|=
literal|0x3c
expr_stmt|;
comment|/* tt0, fmr5 */
name|sc
operator|->
name|f54w
operator|->
name|xc0
operator|=
literal|0x07
expr_stmt|;
name|sc
operator|->
name|f54w
operator|->
name|xc1
operator|=
literal|0x3d
expr_stmt|;
name|sc
operator|->
name|f54w
operator|->
name|rc0
operator|=
literal|0x05
expr_stmt|;
name|sc
operator|->
name|f54w
operator|->
name|rc1
operator|=
literal|0x00
expr_stmt|;
name|sc
operator|->
name|f54w
operator|->
name|cmdr
operator|=
literal|0x51
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|mn_reset
parameter_list|(
name|struct
name|mn_softc
modifier|*
name|sc
parameter_list|)
block|{
name|u_int32_t
name|u
decl_stmt|;
name|int
name|i
decl_stmt|;
name|sc
operator|->
name|m32x
operator|->
name|ccba
operator|=
name|vtophys
argument_list|(
operator|&
name|sc
operator|->
name|m32_mem
operator|.
name|csa
argument_list|)
expr_stmt|;
name|sc
operator|->
name|m32_mem
operator|.
name|csa
operator|=
name|vtophys
argument_list|(
operator|&
name|sc
operator|->
name|m32_mem
operator|.
name|ccb
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|sc
operator|->
name|tiqb
argument_list|,
sizeof|sizeof
name|sc
operator|->
name|tiqb
argument_list|)
expr_stmt|;
name|sc
operator|->
name|m32x
operator|->
name|tiqba
operator|=
name|vtophys
argument_list|(
operator|&
name|sc
operator|->
name|tiqb
argument_list|)
expr_stmt|;
name|sc
operator|->
name|m32x
operator|->
name|tiql
operator|=
name|NIQB
operator|/
literal|16
operator|-
literal|1
expr_stmt|;
name|bzero
argument_list|(
name|sc
operator|->
name|riqb
argument_list|,
sizeof|sizeof
name|sc
operator|->
name|riqb
argument_list|)
expr_stmt|;
name|sc
operator|->
name|m32x
operator|->
name|riqba
operator|=
name|vtophys
argument_list|(
operator|&
name|sc
operator|->
name|riqb
argument_list|)
expr_stmt|;
name|sc
operator|->
name|m32x
operator|->
name|riql
operator|=
name|NIQB
operator|/
literal|16
operator|-
literal|1
expr_stmt|;
name|bzero
argument_list|(
name|sc
operator|->
name|ltiqb
argument_list|,
sizeof|sizeof
name|sc
operator|->
name|ltiqb
argument_list|)
expr_stmt|;
name|sc
operator|->
name|m32x
operator|->
name|ltiqba
operator|=
name|vtophys
argument_list|(
operator|&
name|sc
operator|->
name|ltiqb
argument_list|)
expr_stmt|;
name|sc
operator|->
name|m32x
operator|->
name|ltiql
operator|=
name|NIQB
operator|/
literal|16
operator|-
literal|1
expr_stmt|;
name|bzero
argument_list|(
name|sc
operator|->
name|lriqb
argument_list|,
sizeof|sizeof
name|sc
operator|->
name|lriqb
argument_list|)
expr_stmt|;
name|sc
operator|->
name|m32x
operator|->
name|lriqba
operator|=
name|vtophys
argument_list|(
operator|&
name|sc
operator|->
name|lriqb
argument_list|)
expr_stmt|;
name|sc
operator|->
name|m32x
operator|->
name|lriql
operator|=
name|NIQB
operator|/
literal|16
operator|-
literal|1
expr_stmt|;
name|bzero
argument_list|(
name|sc
operator|->
name|piqb
argument_list|,
sizeof|sizeof
name|sc
operator|->
name|piqb
argument_list|)
expr_stmt|;
name|sc
operator|->
name|m32x
operator|->
name|piqba
operator|=
name|vtophys
argument_list|(
operator|&
name|sc
operator|->
name|piqb
argument_list|)
expr_stmt|;
name|sc
operator|->
name|m32x
operator|->
name|piql
operator|=
name|NIQB
operator|/
literal|16
operator|-
literal|1
expr_stmt|;
name|m32_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|f54_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|u
operator|=
name|sc
operator|->
name|m32x
operator|->
name|stat
expr_stmt|;
name|sc
operator|->
name|m32x
operator|->
name|stat
operator|=
name|u
expr_stmt|;
name|sc
operator|->
name|m32_mem
operator|.
name|ccb
operator|=
literal|0x4
expr_stmt|;
name|sc
operator|->
name|m32x
operator|->
name|cmd
operator|=
literal|0x1
expr_stmt|;
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
name|u
operator|=
name|sc
operator|->
name|m32x
operator|->
name|stat
expr_stmt|;
name|sc
operator|->
name|m32x
operator|->
name|stat
operator|=
name|u
expr_stmt|;
comment|/* set all timeslots to known state */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|32
condition|;
name|i
operator|++
control|)
name|sc
operator|->
name|m32_mem
operator|.
name|ts
index|[
name|i
index|]
operator|=
literal|0x20002000
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|u
operator|&
literal|1
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"mn%d: WARNING: Controller failed the PCI bus-master test.\n"
literal|"mn%d: WARNING: Use a PCI slot which can support bus-master cards.\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * FALC54 interrupt handling  */
end_comment

begin_function
specifier|static
name|void
name|f54_intr
parameter_list|(
name|struct
name|mn_softc
modifier|*
name|sc
parameter_list|)
block|{
name|unsigned
name|g
decl_stmt|,
name|u
decl_stmt|,
name|s
decl_stmt|;
name|g
operator|=
name|sc
operator|->
name|f54r
operator|->
name|gis
expr_stmt|;
name|u
operator|=
name|sc
operator|->
name|f54r
operator|->
name|isr0
operator|<<
literal|24
expr_stmt|;
name|u
operator||=
name|sc
operator|->
name|f54r
operator|->
name|isr1
operator|<<
literal|16
expr_stmt|;
name|u
operator||=
name|sc
operator|->
name|f54r
operator|->
name|isr2
operator|<<
literal|8
expr_stmt|;
name|u
operator||=
name|sc
operator|->
name|f54r
operator|->
name|isr3
expr_stmt|;
name|sc
operator|->
name|falc_irq
operator|=
name|u
expr_stmt|;
comment|/* don't chat about the 1 sec heart beat */
if|if
condition|(
name|u
operator|&
operator|~
literal|0x40
condition|)
block|{
if|#
directive|if
literal|0
block|printf("%s*: FALC54 IRQ GIS:%02x %b\n", sc->name, g, u, "\20" 		    "\40RME\37RFS\36T8MS\35RMB\34CASC\33CRC4\32SA6SC\31RPF" 		    "\30b27\27RDO\26ALLS\25XDU\24XMB\23b22\22XLSC\21XPR" 		    "\20FAR\17LFA\16MFAR\15T400MS\14AIS\13LOS\12RAR\11RA" 		    "\10ES\7SEC\6LMFA16\5AIS16\4RA16\3API\2SLN\1SLP");
endif|#
directive|endif
name|s
operator|=
name|sc
operator|->
name|f54r
operator|->
name|frs0
operator|<<
literal|24
expr_stmt|;
name|s
operator||=
name|sc
operator|->
name|f54r
operator|->
name|frs1
operator|<<
literal|16
expr_stmt|;
name|s
operator||=
name|sc
operator|->
name|f54r
operator|->
name|rsw
operator|<<
literal|8
expr_stmt|;
name|s
operator||=
name|sc
operator|->
name|f54r
operator|->
name|rsp
expr_stmt|;
name|sc
operator|->
name|falc_state
operator|=
name|s
expr_stmt|;
name|s
operator|&=
operator|~
literal|0x01844038
expr_stmt|;
comment|/* undefined or static bits */
name|s
operator|&=
operator|~
literal|0x00009fc7
expr_stmt|;
comment|/* bits we don't care about */
name|s
operator|&=
operator|~
literal|0x00780000
expr_stmt|;
comment|/* XXX: TS16 related */
name|s
operator|&=
operator|~
literal|0x06000000
expr_stmt|;
comment|/* XXX: Multiframe related */
if|#
directive|if
literal|0
block|printf("%s*: FALC54 Status %b\n", sc->name, s, "\20" 		    "\40LOS\37AIS\36LFA\35RRA\34AUXP\33NMF\32LMFA\31frs0.0" 		    "\30frs1.7\27TS16RA\26TS16LOS\25TS16AIS\24TS16LFA\23frs1.2\22XLS\21XLO" 		    "\20RS1\17rsw.6\16RRA\15RY0\14RY1\13RY2\12RY3\11RY4" 		    "\10SI1\7SI2\6rsp.5\5rsp.4\4rsp.3\3RSIF\2RS13\1RS15");
endif|#
directive|endif
if|if
condition|(
name|s
operator|!=
name|sc
operator|->
name|framer_state
condition|)
block|{
if|#
directive|if
literal|0
block|for (i = 0; i< M32_CHAN; i++) { 				if (!sc->ch[i]) 					continue; 			        sp =&sc->ch[i]->ifsppp; 				if (!(SP2IFP(sp)->if_flags& IFF_UP)) 					continue; 				if (s)  					timeout((timeout_t *)sp->pp_down, sp, 1 * hz); 				else  					timeout((timeout_t *)sp->pp_up, sp, 1 * hz); 			}
endif|#
directive|endif
name|sc
operator|->
name|framer_state
operator|=
name|s
expr_stmt|;
block|}
block|}
comment|/* Once per second check error counters */
comment|/* XXX: not clear if this is actually ok */
if|if
condition|(
operator|!
operator|(
name|u
operator|&
literal|0x40
operator|)
condition|)
return|return;
name|sc
operator|->
name|cnt_fec
operator|+=
name|sc
operator|->
name|f54r
operator|->
name|fec
expr_stmt|;
name|sc
operator|->
name|cnt_cvc
operator|+=
name|sc
operator|->
name|f54r
operator|->
name|cvc
expr_stmt|;
name|sc
operator|->
name|cnt_cec1
operator|+=
name|sc
operator|->
name|f54r
operator|->
name|cec1
expr_stmt|;
name|sc
operator|->
name|cnt_ebc
operator|+=
name|sc
operator|->
name|f54r
operator|->
name|ebc
expr_stmt|;
name|sc
operator|->
name|cnt_cec2
operator|+=
name|sc
operator|->
name|f54r
operator|->
name|cec2
expr_stmt|;
name|sc
operator|->
name|cnt_cec3
operator|+=
name|sc
operator|->
name|f54r
operator|->
name|cec3
expr_stmt|;
name|sc
operator|->
name|cnt_rbc
operator|+=
name|sc
operator|->
name|f54r
operator|->
name|rbc
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Transmit interrupt for one channel  */
end_comment

begin_function
specifier|static
name|void
name|mn_tx_intr
parameter_list|(
name|struct
name|mn_softc
modifier|*
name|sc
parameter_list|,
name|u_int32_t
name|vector
parameter_list|)
block|{
name|u_int32_t
name|chan
decl_stmt|;
name|struct
name|trxd
modifier|*
name|dp
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|chan
operator|=
name|vector
operator|&
literal|0x1f
expr_stmt|;
if|if
condition|(
operator|!
name|sc
operator|->
name|ch
index|[
name|chan
index|]
condition|)
return|return;
if|if
condition|(
name|sc
operator|->
name|ch
index|[
name|chan
index|]
operator|->
name|state
operator|!=
name|UP
condition|)
block|{
name|printf
argument_list|(
literal|"%s: tx_intr when not UP\n"
argument_list|,
name|sc
operator|->
name|name
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
init|;
condition|;
control|)
block|{
name|dp
operator|=
name|sc
operator|->
name|ch
index|[
name|chan
index|]
operator|->
name|x1
expr_stmt|;
if|if
condition|(
name|vtophys
argument_list|(
name|dp
argument_list|)
operator|==
name|sc
operator|->
name|m32_mem
operator|.
name|ctxd
index|[
name|chan
index|]
condition|)
return|return;
name|m
operator|=
name|dp
operator|->
name|m
expr_stmt|;
if|if
condition|(
name|m
condition|)
block|{
if|#
directive|if
literal|0
block|printf("%d = %d - %d (%p)\n", 			    sc->ch[chan]->tx_pending - m->m_pkthdr.len, 			    sc->ch[chan]->tx_pending , m->m_pkthdr.len, m);
endif|#
directive|endif
name|sc
operator|->
name|ch
index|[
name|chan
index|]
operator|->
name|tx_pending
operator|-=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|ch
index|[
name|chan
index|]
operator|->
name|last_xmit
operator|=
name|time_second
expr_stmt|;
name|sc
operator|->
name|ch
index|[
name|chan
index|]
operator|->
name|x1
operator|=
name|dp
operator|->
name|vnext
expr_stmt|;
name|mn_free_desc
argument_list|(
name|dp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Receive interrupt for one channel  */
end_comment

begin_function
specifier|static
name|void
name|mn_rx_intr
parameter_list|(
name|struct
name|mn_softc
modifier|*
name|sc
parameter_list|,
name|u_int32_t
name|vector
parameter_list|)
block|{
name|u_int32_t
name|chan
decl_stmt|,
name|err
decl_stmt|;
name|struct
name|trxd
modifier|*
name|dp
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|schan
modifier|*
name|sch
decl_stmt|;
name|chan
operator|=
name|vector
operator|&
literal|0x1f
expr_stmt|;
if|if
condition|(
operator|!
name|sc
operator|->
name|ch
index|[
name|chan
index|]
condition|)
return|return;
name|sch
operator|=
name|sc
operator|->
name|ch
index|[
name|chan
index|]
expr_stmt|;
if|if
condition|(
name|sch
operator|->
name|state
operator|!=
name|UP
condition|)
block|{
name|printf
argument_list|(
literal|"%s: rx_intr when not UP\n"
argument_list|,
name|sc
operator|->
name|name
argument_list|)
expr_stmt|;
return|return;
block|}
name|vector
operator|&=
operator|~
literal|0x1f
expr_stmt|;
if|if
condition|(
name|vector
operator|==
literal|0x30000b00
condition|)
name|sch
operator|->
name|rx_error
operator|++
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|dp
operator|=
name|sch
operator|->
name|r1
expr_stmt|;
if|if
condition|(
name|vtophys
argument_list|(
name|dp
argument_list|)
operator|==
name|sc
operator|->
name|m32_mem
operator|.
name|crxd
index|[
name|chan
index|]
condition|)
return|return;
name|m
operator|=
name|dp
operator|->
name|m
expr_stmt|;
name|dp
operator|->
name|m
operator|=
literal|0
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|m
operator|->
name|m_len
operator|=
operator|(
name|dp
operator|->
name|status
operator|>>
literal|16
operator|)
operator|&
literal|0x1fff
expr_stmt|;
name|err
operator|=
operator|(
name|dp
operator|->
name|status
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
if|if
condition|(
operator|!
name|err
condition|)
block|{
name|int
name|error
decl_stmt|;
name|NG_SEND_DATA_ONLY
argument_list|(
name|error
argument_list|,
name|sch
operator|->
name|hook
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|sch
operator|->
name|last_recv
operator|=
name|time_second
expr_stmt|;
comment|/* we could be down by now... */
if|if
condition|(
name|sch
operator|->
name|state
operator|!=
name|UP
condition|)
return|return;
block|}
elseif|else
if|if
condition|(
name|err
operator|&
literal|0x40
condition|)
block|{
name|sch
operator|->
name|short_error
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|err
operator|&
literal|0x10
condition|)
block|{
name|sch
operator|->
name|crc_error
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|err
operator|&
literal|0x08
condition|)
block|{
name|sch
operator|->
name|dribble_error
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|err
operator|&
literal|0x04
condition|)
block|{
name|sch
operator|->
name|long_error
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|err
operator|&
literal|0x02
condition|)
block|{
name|sch
operator|->
name|abort_error
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|err
operator|&
literal|0x01
condition|)
block|{
name|sch
operator|->
name|overflow_error
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|err
condition|)
block|{
name|sch
operator|->
name|last_rxerr
operator|=
name|time_second
expr_stmt|;
name|sch
operator|->
name|prev_error
operator|=
name|sch
operator|->
name|last_error
expr_stmt|;
name|sch
operator|->
name|last_error
operator|=
name|err
expr_stmt|;
block|}
name|sc
operator|->
name|ch
index|[
name|chan
index|]
operator|->
name|r1
operator|=
name|dp
operator|->
name|vnext
expr_stmt|;
comment|/* Replenish desc + mbuf supplies */
if|if
condition|(
operator|!
name|m
condition|)
block|{
name|MGETHDR
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|mn_free_desc
argument_list|(
name|dp
argument_list|)
expr_stmt|;
return|return;
comment|/* ENOBUFS */
block|}
name|MCLGET
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|m
operator|->
name|m_flags
operator|&
name|M_EXT
operator|)
operator|==
literal|0
condition|)
block|{
name|mn_free_desc
argument_list|(
name|dp
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return;
comment|/* ENOBUFS */
block|}
block|}
name|dp
operator|->
name|m
operator|=
name|m
expr_stmt|;
name|dp
operator|->
name|data
operator|=
name|vtophys
argument_list|(
name|m
operator|->
name|m_data
argument_list|)
expr_stmt|;
name|dp
operator|->
name|flags
operator|=
literal|0x40000000
expr_stmt|;
name|dp
operator|->
name|flags
operator|+=
literal|1600
operator|<<
literal|16
expr_stmt|;
name|dp
operator|->
name|next
operator|=
name|vtophys
argument_list|(
name|dp
argument_list|)
expr_stmt|;
name|dp
operator|->
name|vnext
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|ch
index|[
name|chan
index|]
operator|->
name|rl
operator|->
name|next
operator|=
name|vtophys
argument_list|(
name|dp
argument_list|)
expr_stmt|;
name|sc
operator|->
name|ch
index|[
name|chan
index|]
operator|->
name|rl
operator|->
name|vnext
operator|=
name|dp
expr_stmt|;
name|sc
operator|->
name|ch
index|[
name|chan
index|]
operator|->
name|rl
operator|->
name|flags
operator|&=
operator|~
literal|0x40000000
expr_stmt|;
name|sc
operator|->
name|ch
index|[
name|chan
index|]
operator|->
name|rl
operator|=
name|dp
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Interupt handler  */
end_comment

begin_function
specifier|static
name|void
name|mn_intr
parameter_list|(
name|void
modifier|*
name|xsc
parameter_list|)
block|{
name|struct
name|mn_softc
modifier|*
name|sc
decl_stmt|;
name|u_int32_t
name|stat
decl_stmt|,
name|lstat
decl_stmt|,
name|u
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|sc
operator|=
name|xsc
expr_stmt|;
name|stat
operator|=
name|sc
operator|->
name|m32x
operator|->
name|stat
expr_stmt|;
name|lstat
operator|=
name|sc
operator|->
name|m32x
operator|->
name|lstat
expr_stmt|;
if|#
directive|if
literal|0
block|if (!stat&& !(lstat& 2))  		return;
endif|#
directive|endif
if|if
condition|(
name|stat
operator|&
operator|~
literal|0xc200
condition|)
block|{
name|printf
argument_list|(
literal|"%s: I stat=%08x lstat=%08x\n"
argument_list|,
name|sc
operator|->
name|name
argument_list|,
name|stat
argument_list|,
name|lstat
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|stat
operator|&
literal|0x200
operator|)
operator|||
operator|(
name|lstat
operator|&
literal|2
operator|)
condition|)
name|f54_intr
argument_list|(
name|sc
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|64
condition|;
name|i
operator|++
control|)
block|{
name|u
operator|=
name|sc
operator|->
name|riqb
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|u
condition|)
block|{
name|sc
operator|->
name|riqb
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|mn_rx_intr
argument_list|(
name|sc
argument_list|,
name|u
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|u
operator|&
operator|~
literal|0x1f
operator|)
operator|==
literal|0x30000800
operator|||
operator|(
name|u
operator|&
operator|~
literal|0x1f
operator|)
operator|==
literal|0x30000b00
condition|)
continue|continue;
name|u
operator|&=
operator|~
literal|0x30000400
expr_stmt|;
comment|/* bits we don't care about */
if|if
condition|(
operator|(
name|u
operator|&
operator|~
literal|0x1f
operator|)
operator|==
literal|0x00000900
condition|)
continue|continue;
if|if
condition|(
operator|!
operator|(
name|u
operator|&
operator|~
literal|0x1f
operator|)
condition|)
continue|continue;
if|if
condition|(
operator|!
name|j
condition|)
name|printf
argument_list|(
literal|"%s*: RIQB:"
argument_list|,
name|sc
operator|->
name|name
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" [%d]=%08x"
argument_list|,
name|i
argument_list|,
name|u
argument_list|)
expr_stmt|;
name|j
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|j
condition|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|64
condition|;
name|i
operator|++
control|)
block|{
name|u
operator|=
name|sc
operator|->
name|tiqb
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|u
condition|)
block|{
name|sc
operator|->
name|tiqb
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|mn_tx_intr
argument_list|(
name|sc
argument_list|,
name|u
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|u
operator|&
operator|~
literal|0x1f
operator|)
operator|==
literal|0x20000800
condition|)
continue|continue;
name|u
operator|&=
operator|~
literal|0x20000000
expr_stmt|;
comment|/* bits we don't care about */
if|if
condition|(
operator|!
name|u
condition|)
continue|continue;
if|if
condition|(
operator|!
name|j
condition|)
name|printf
argument_list|(
literal|"%s*: TIQB:"
argument_list|,
name|sc
operator|->
name|name
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" [%d]=%08x"
argument_list|,
name|i
argument_list|,
name|u
argument_list|)
expr_stmt|;
name|j
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|j
condition|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|m32x
operator|->
name|stat
operator|=
name|stat
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|mn_timeout
parameter_list|(
name|void
modifier|*
name|xsc
parameter_list|)
block|{
specifier|static
name|int
name|round
init|=
literal|0
decl_stmt|;
name|struct
name|mn_softc
modifier|*
name|sc
decl_stmt|;
name|mn_intr
argument_list|(
name|xsc
argument_list|)
expr_stmt|;
name|sc
operator|=
name|xsc
expr_stmt|;
name|timeout
argument_list|(
name|mn_timeout
argument_list|,
name|xsc
argument_list|,
literal|10
operator|*
name|hz
argument_list|)
expr_stmt|;
name|round
operator|++
expr_stmt|;
if|if
condition|(
name|round
operator|==
literal|2
condition|)
block|{
name|sc
operator|->
name|m32_mem
operator|.
name|ccb
operator|=
literal|0x00008004
expr_stmt|;
name|sc
operator|->
name|m32x
operator|->
name|cmd
operator|=
literal|0x1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|round
operator|>
literal|2
condition|)
block|{
name|printf
argument_list|(
literal|"%s: timeout\n"
argument_list|,
name|sc
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * PCI initialization stuff  */
end_comment

begin_function
specifier|static
name|int
name|mn_probe
parameter_list|(
name|device_t
name|self
parameter_list|)
block|{
name|u_int
name|id
init|=
name|pci_get_devid
argument_list|(
name|self
argument_list|)
decl_stmt|;
if|if
condition|(
sizeof|sizeof
argument_list|(
expr|struct
name|m32xreg
argument_list|)
operator|!=
literal|256
condition|)
block|{
name|printf
argument_list|(
literal|"MN: sizeof(struct m32xreg) = %zd, should have been 256\n"
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|m32xreg
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
if|if
condition|(
sizeof|sizeof
argument_list|(
expr|struct
name|f54rreg
argument_list|)
operator|!=
literal|128
condition|)
block|{
name|printf
argument_list|(
literal|"MN: sizeof(struct f54rreg) = %zd, should have been 128\n"
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|f54rreg
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
if|if
condition|(
sizeof|sizeof
argument_list|(
expr|struct
name|f54wreg
argument_list|)
operator|!=
literal|128
condition|)
block|{
name|printf
argument_list|(
literal|"MN: sizeof(struct f54wreg) = %zd, should have been 128\n"
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|f54wreg
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
if|if
condition|(
name|id
operator|!=
literal|0x2101110a
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|device_set_desc_copy
argument_list|(
name|self
argument_list|,
literal|"Munich32X E1/T1 HDLC Controller"
argument_list|)
expr_stmt|;
return|return
operator|(
name|BUS_PROBE_DEFAULT
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mn_attach
parameter_list|(
name|device_t
name|self
parameter_list|)
block|{
name|struct
name|mn_softc
modifier|*
name|sc
decl_stmt|;
name|u_int32_t
name|u
decl_stmt|;
name|u_int32_t
name|ver
decl_stmt|;
specifier|static
name|int
name|once
decl_stmt|;
name|int
name|rid
decl_stmt|,
name|error
decl_stmt|;
name|struct
name|resource
modifier|*
name|res
decl_stmt|;
if|if
condition|(
operator|!
name|once
condition|)
block|{
if|if
condition|(
name|ng_newtype
argument_list|(
operator|&
name|mntypestruct
argument_list|)
condition|)
name|printf
argument_list|(
literal|"ng_newtype failed\n"
argument_list|)
expr_stmt|;
name|once
operator|++
expr_stmt|;
block|}
name|sc
operator|=
operator|(
expr|struct
name|mn_softc
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
expr|*
name|sc
argument_list|,
name|M_MN
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|device_set_softc
argument_list|(
name|self
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|dev
operator|=
name|self
expr_stmt|;
name|sc
operator|->
name|unit
operator|=
name|device_get_unit
argument_list|(
name|self
argument_list|)
expr_stmt|;
name|sc
operator|->
name|framing
operator|=
name|E1
expr_stmt|;
name|sprintf
argument_list|(
name|sc
operator|->
name|name
argument_list|,
literal|"mn%d"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
name|rid
operator|=
name|PCIR_BAR
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|res
operator|=
name|bus_alloc_resource_any
argument_list|(
name|self
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
operator|&
name|rid
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|self
argument_list|,
literal|"Could not map memory\n"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sc
argument_list|,
name|M_MN
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
name|sc
operator|->
name|m0v
operator|=
name|rman_get_virtual
argument_list|(
name|res
argument_list|)
expr_stmt|;
name|sc
operator|->
name|m0p
operator|=
name|rman_get_start
argument_list|(
name|res
argument_list|)
expr_stmt|;
name|rid
operator|=
name|PCIR_BAR
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|res
operator|=
name|bus_alloc_resource_any
argument_list|(
name|self
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
operator|&
name|rid
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|self
argument_list|,
literal|"Could not map memory\n"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sc
argument_list|,
name|M_MN
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
name|sc
operator|->
name|m1v
operator|=
name|rman_get_virtual
argument_list|(
name|res
argument_list|)
expr_stmt|;
name|sc
operator|->
name|m1p
operator|=
name|rman_get_start
argument_list|(
name|res
argument_list|)
expr_stmt|;
comment|/* Allocate interrupt */
name|rid
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|irq
operator|=
name|bus_alloc_resource_any
argument_list|(
name|self
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|rid
argument_list|,
name|RF_SHAREABLE
operator||
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|irq
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"couldn't map interrupt\n"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sc
argument_list|,
name|M_MN
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|error
operator|=
name|bus_setup_intr
argument_list|(
name|self
argument_list|,
name|sc
operator|->
name|irq
argument_list|,
name|INTR_TYPE_NET
argument_list|,
name|NULL
argument_list|,
name|mn_intr
argument_list|,
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|intrhand
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|printf
argument_list|(
literal|"couldn't set up irq\n"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sc
argument_list|,
name|M_MN
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|u
operator|=
name|pci_read_config
argument_list|(
name|self
argument_list|,
name|PCIR_COMMAND
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%x\n"
argument_list|,
name|u
argument_list|)
expr_stmt|;
name|pci_write_config
argument_list|(
name|self
argument_list|,
name|PCIR_COMMAND
argument_list|,
name|u
operator||
name|PCIM_CMD_PERRESPEN
operator||
name|PCIM_CMD_BUSMASTEREN
operator||
name|PCIM_CMD_MEMEN
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|pci_write_config(self, PCIR_COMMAND, 0x02800046, 4);
endif|#
directive|endif
name|u
operator|=
name|pci_read_config
argument_list|(
name|self
argument_list|,
name|PCIR_COMMAND
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%x\n"
argument_list|,
name|u
argument_list|)
expr_stmt|;
name|ver
operator|=
name|pci_get_revid
argument_list|(
name|self
argument_list|)
expr_stmt|;
name|sc
operator|->
name|m32x
operator|=
operator|(
expr|struct
name|m32xreg
operator|*
operator|)
name|sc
operator|->
name|m0v
expr_stmt|;
name|sc
operator|->
name|f54w
operator|=
operator|(
expr|struct
name|f54wreg
operator|*
operator|)
name|sc
operator|->
name|m1v
expr_stmt|;
name|sc
operator|->
name|f54r
operator|=
operator|(
expr|struct
name|f54rreg
operator|*
operator|)
name|sc
operator|->
name|m1v
expr_stmt|;
comment|/* We must reset before poking at FALC54 registers */
name|u
operator|=
name|mn_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|u
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|printf
argument_list|(
literal|"mn%d: Munich32X"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ver
condition|)
block|{
case|case
literal|0x13
case|:
name|printf
argument_list|(
literal|" Rev 2.2"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|" Rev 0x%x\n"
argument_list|,
name|ver
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|", Falc54"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|sc
operator|->
name|f54r
operator|->
name|vstr
condition|)
block|{
case|case
literal|0
case|:
name|printf
argument_list|(
literal|" Rev< 1.3\n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|printf
argument_list|(
literal|" Rev 1.3\n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|printf
argument_list|(
literal|" Rev 1.4\n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x10
case|:
name|printf
argument_list|(
literal|"-LH Rev 1.1\n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x13
case|:
name|printf
argument_list|(
literal|"-LH Rev 1.3\n"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|" Rev 0x%x\n"
argument_list|,
name|sc
operator|->
name|f54r
operator|->
name|vstr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ng_make_node_common
argument_list|(
operator|&
name|mntypestruct
argument_list|,
operator|&
name|sc
operator|->
name|node
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"ng_make_node_common failed\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|NG_NODE_SET_PRIVATE
argument_list|(
name|sc
operator|->
name|node
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|sc
operator|->
name|nodename
argument_list|,
literal|"%s%d"
argument_list|,
name|NG_MN_NODE_TYPE
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|ng_name_node
argument_list|(
name|sc
operator|->
name|node
argument_list|,
name|sc
operator|->
name|nodename
argument_list|)
condition|)
block|{
name|NG_NODE_UNREF
argument_list|(
name|sc
operator|->
name|node
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|device_method_t
name|mn_methods
index|[]
init|=
block|{
comment|/* Device interface */
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|mn_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|mn_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_suspend
argument_list|,
name|bus_generic_suspend
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_resume
argument_list|,
name|bus_generic_resume
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_shutdown
argument_list|,
name|bus_generic_shutdown
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|mn_driver
init|=
block|{
literal|"mn"
block|,
name|mn_methods
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|devclass_t
name|mn_devclass
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|mn
argument_list|,
name|pci
argument_list|,
name|mn_driver
argument_list|,
name|mn_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

