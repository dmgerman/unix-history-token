begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$NetBSD: smc90cx6.c,v 1.38 2001/07/07 15:57:53 thorpej Exp $ */
end_comment

begin_comment
comment|/*	$FreeBSD$ */
end_comment

begin_comment
comment|/*-  * Copyright (c) 1994, 1995, 1998 The NetBSD Foundation, Inc.  * All rights reserved.  *  * This code is derived from software contributed to The NetBSD Foundation  * by Ignatios Souvatzis.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *        This product includes software developed by the NetBSD  *        Foundation, Inc. and its contributors.  * 4. Neither the name of The NetBSD Foundation nor the names of its  *    contributors may be used to endorse or promote products derived  *    from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS  * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED  * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  * POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * Chip core driver for the SMC90c26 / SMC90c56 (and SMC90c66 in '56  * compatibility mode) boards  */
end_comment

begin_comment
comment|/* #define CMSOFTCOPY */
end_comment

begin_define
define|#
directive|define
name|CMRETRANSMIT
end_define

begin_comment
comment|/**/
end_comment

begin_undef
undef|#
directive|undef
name|CM_DEBUG
end_undef

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/syslog.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_if
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|500000
end_if

begin_include
include|#
directive|include
file|<machine/clock.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_dl.h>
end_include

begin_include
include|#
directive|include
file|<net/if_types.h>
end_include

begin_include
include|#
directive|include
file|<net/if_arc.h>
end_include

begin_include
include|#
directive|include
file|<net/bpf.h>
end_include

begin_if
if|#
directive|if
literal|0
end_if

begin_if
if|#
directive|if
name|NBPFILTER
operator|>
literal|0
end_if

begin_include
include|#
directive|include
file|<net/bpfdesc.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<dev/cm/smc90cx6reg.h>
end_include

begin_include
include|#
directive|include
file|<dev/cm/smc90cx6var.h>
end_include

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|if_cm
argument_list|,
name|arcnet
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* these should be elsewhere */
end_comment

begin_define
define|#
directive|define
name|ARC_MIN_LEN
value|1
end_define

begin_define
define|#
directive|define
name|ARC_MIN_FORBID_LEN
value|254
end_define

begin_define
define|#
directive|define
name|ARC_MAX_FORBID_LEN
value|256
end_define

begin_define
define|#
directive|define
name|ARC_MAX_LEN
value|508
end_define

begin_define
define|#
directive|define
name|ARC_ADDR_LEN
value|1
end_define

begin_comment
comment|/* for watchdog timer. This should be more than enough. */
end_comment

begin_define
define|#
directive|define
name|ARCTIMEOUT
value|(5*IFNET_SLOWHZ)
end_define

begin_comment
comment|/* short notation */
end_comment

begin_define
define|#
directive|define
name|GETREG
parameter_list|(
name|off
parameter_list|)
define|\
value|bus_space_read_1(rman_get_bustag((sc)->port_res),		\ 			 rman_get_bushandle((sc)->port_res),		\ 			 (off))
end_define

begin_define
define|#
directive|define
name|PUTREG
parameter_list|(
name|off
parameter_list|,
name|value
parameter_list|)
define|\
value|bus_space_write_1(rman_get_bustag((sc)->port_res),		\ 			  rman_get_bushandle((sc)->port_res),		\ 			  (off), (value))
end_define

begin_define
define|#
directive|define
name|GETMEM
parameter_list|(
name|off
parameter_list|)
define|\
value|bus_space_read_1(rman_get_bustag((sc)->mem_res),		\ 			 rman_get_bushandle((sc)->mem_res),		\ 			 (off))
end_define

begin_define
define|#
directive|define
name|PUTMEM
parameter_list|(
name|off
parameter_list|,
name|value
parameter_list|)
define|\
value|bus_space_write_1(rman_get_bustag((sc)->mem_res),		\ 			  rman_get_bushandle((sc)->mem_res),		\ 			  (off), (value))
end_define

begin_decl_stmt
name|devclass_t
name|cm_devclass
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * This currently uses 2 bufs for tx, 2 for rx  *  * New rx protocol:  *  * rx has a fillcount variable. If fillcount> (NRXBUF-1),  * rx can be switched off from rx hard int.  * Else rx is restarted on the other receiver.  * rx soft int counts down. if it is == (NRXBUF-1), it restarts  * the receiver.  * To ensure packet ordering (we need that for 1201 later), we have a counter  * which is incremented modulo 256 on each receive and a per buffer  * variable, which is set to the counter on filling. The soft int can  * compare both values to determine the older packet.  *  * Transmit direction:  *  * cm_start checks tx_fillcount  * case 2: return  *  * else fill tx_act ^ 1&& inc tx_fillcount  *  * check tx_fillcount again.  * case 2: set IFF_OACTIVE to stop arc_output from filling us.  * case 1: start tx  *  * tint clears IFF_OCATIVE, decrements and checks tx_fillcount  * case 1: start tx on tx_act ^ 1, softcall cm_start  * case 0: softcall cm_start  *  * #define fill(i) get mbuf&& copy mbuf to chip(i)  */
end_comment

begin_function_decl
name|void
name|cm_init
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|cm_reset
parameter_list|(
name|struct
name|cm_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|cm_start
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|cm_ioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|unsigned
name|long
parameter_list|,
name|caddr_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|cm_watchdog
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|cm_srint
parameter_list|(
name|void
modifier|*
name|vsc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cm_tint
parameter_list|(
name|struct
name|cm_softc
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|cm_reconwatch
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|int
name|cm_probe
parameter_list|(
name|dev
parameter_list|)
name|device_t
name|dev
decl_stmt|;
block|{
name|int
name|error
decl_stmt|;
name|struct
name|cm_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|error
operator|=
name|cm_alloc_port
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|,
name|CM_IO_PORTS
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
if|if
condition|(
name|GETREG
argument_list|(
name|CMSTAT
argument_list|)
operator|==
literal|0xff
condition|)
return|return
name|ENXIO
return|;
name|error
operator|=
name|cm_alloc_memory
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|,
literal|0x800
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Allocate a port resource with the given resource id.  */
end_comment

begin_function
name|int
name|cm_alloc_port
parameter_list|(
name|dev
parameter_list|,
name|rid
parameter_list|,
name|size
parameter_list|)
name|device_t
name|dev
decl_stmt|;
name|int
name|rid
decl_stmt|;
name|int
name|size
decl_stmt|;
block|{
name|struct
name|cm_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|resource
modifier|*
name|res
decl_stmt|;
name|res
operator|=
name|bus_alloc_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
operator|&
name|rid
argument_list|,
literal|0ul
argument_list|,
operator|~
literal|0ul
argument_list|,
name|size
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
condition|)
block|{
name|sc
operator|->
name|port_rid
operator|=
name|rid
expr_stmt|;
name|sc
operator|->
name|port_res
operator|=
name|res
expr_stmt|;
name|sc
operator|->
name|port_used
operator|=
name|size
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
block|{
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * Allocate a memory resource with the given resource id.  */
end_comment

begin_function
name|int
name|cm_alloc_memory
parameter_list|(
name|dev
parameter_list|,
name|rid
parameter_list|,
name|size
parameter_list|)
name|device_t
name|dev
decl_stmt|;
name|int
name|rid
decl_stmt|;
name|int
name|size
decl_stmt|;
block|{
name|struct
name|cm_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|resource
modifier|*
name|res
decl_stmt|;
name|res
operator|=
name|bus_alloc_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
operator|&
name|rid
argument_list|,
literal|0ul
argument_list|,
operator|~
literal|0ul
argument_list|,
name|size
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
condition|)
block|{
name|sc
operator|->
name|mem_rid
operator|=
name|rid
expr_stmt|;
name|sc
operator|->
name|mem_res
operator|=
name|res
expr_stmt|;
name|sc
operator|->
name|mem_used
operator|=
name|size
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
block|{
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * Allocate an irq resource with the given resource id.  */
end_comment

begin_function
name|int
name|cm_alloc_irq
parameter_list|(
name|dev
parameter_list|,
name|rid
parameter_list|)
name|device_t
name|dev
decl_stmt|;
name|int
name|rid
decl_stmt|;
block|{
name|struct
name|cm_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|resource
modifier|*
name|res
decl_stmt|;
name|res
operator|=
name|bus_alloc_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|rid
argument_list|,
literal|0ul
argument_list|,
operator|~
literal|0ul
argument_list|,
literal|1
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
condition|)
block|{
name|sc
operator|->
name|irq_rid
operator|=
name|rid
expr_stmt|;
name|sc
operator|->
name|irq_res
operator|=
name|res
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
block|{
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * Release all resources  */
end_comment

begin_function
name|void
name|cm_release_resources
parameter_list|(
name|dev
parameter_list|)
name|device_t
name|dev
decl_stmt|;
block|{
name|struct
name|cm_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|port_res
condition|)
block|{
name|bus_deactivate_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
name|sc
operator|->
name|port_rid
argument_list|,
name|sc
operator|->
name|port_res
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
name|sc
operator|->
name|port_rid
argument_list|,
name|sc
operator|->
name|port_res
argument_list|)
expr_stmt|;
name|sc
operator|->
name|port_res
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|mem_res
condition|)
block|{
name|bus_deactivate_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|sc
operator|->
name|mem_rid
argument_list|,
name|sc
operator|->
name|mem_res
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|sc
operator|->
name|mem_rid
argument_list|,
name|sc
operator|->
name|mem_res
argument_list|)
expr_stmt|;
name|sc
operator|->
name|mem_res
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|irq_res
condition|)
block|{
name|bus_deactivate_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|sc
operator|->
name|irq_rid
argument_list|,
name|sc
operator|->
name|irq_res
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|sc
operator|->
name|irq_rid
argument_list|,
name|sc
operator|->
name|irq_res
argument_list|)
expr_stmt|;
name|sc
operator|->
name|irq_res
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|cm_attach
parameter_list|(
name|sc
parameter_list|,
name|unit
parameter_list|)
name|struct
name|cm_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|unit
decl_stmt|;
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
operator|&
name|sc
operator|->
name|sc_arccom
operator|.
name|ac_if
decl_stmt|;
name|int
name|s
decl_stmt|;
name|u_int8_t
name|linkaddress
decl_stmt|;
name|s
operator|=
name|splhigh
argument_list|()
expr_stmt|;
comment|/* 	 * read the arcnet address from the board 	 */
name|GETREG
argument_list|(
name|CMRESET
argument_list|)
expr_stmt|;
do|do
block|{
name|DELAY
argument_list|(
literal|200
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|!
operator|(
name|GETREG
argument_list|(
name|CMSTAT
argument_list|)
operator|&
name|CM_POR
operator|)
condition|)
do|;
name|linkaddress
operator|=
name|GETMEM
argument_list|(
name|CMMACOFF
argument_list|)
expr_stmt|;
comment|/* clear the int mask... */
name|sc
operator|->
name|sc_intmask
operator|=
literal|0
expr_stmt|;
name|PUTREG
argument_list|(
name|CMSTAT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|PUTREG
argument_list|(
name|CMCMD
argument_list|,
name|CM_CONF
argument_list|(
name|CONF_LONG
argument_list|)
argument_list|)
expr_stmt|;
name|PUTREG
argument_list|(
name|CMCMD
argument_list|,
name|CM_CLR
argument_list|(
name|CLR_POR
operator||
name|CLR_RECONFIG
argument_list|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_recontime
operator|=
name|sc
operator|->
name|sc_reconcount
operator|=
literal|0
expr_stmt|;
comment|/* and reenable kernel int level */
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* 	 * set interface to stopped condition (reset) 	 */
name|cm_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ifp
operator|->
name|if_name
condition|)
block|{
name|ifp
operator|->
name|if_softc
operator|=
name|sc
expr_stmt|;
name|ifp
operator|->
name|if_unit
operator|=
name|unit
expr_stmt|;
name|ifp
operator|->
name|if_name
operator|=
literal|"cm"
expr_stmt|;
name|ifp
operator|->
name|if_output
operator|=
name|arc_output
expr_stmt|;
name|ifp
operator|->
name|if_start
operator|=
name|cm_start
expr_stmt|;
name|ifp
operator|->
name|if_ioctl
operator|=
name|cm_ioctl
expr_stmt|;
name|ifp
operator|->
name|if_watchdog
operator|=
name|cm_watchdog
expr_stmt|;
name|ifp
operator|->
name|if_init
operator|=
name|cm_init
expr_stmt|;
comment|/* XXX IFQ_SET_READY(&ifp->if_snd); */
name|ifp
operator|->
name|if_snd
operator|.
name|ifq_maxlen
operator|=
name|IFQ_MAXLEN
expr_stmt|;
name|ifp
operator|->
name|if_timer
operator|=
literal|0
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|=
name|IFF_BROADCAST
operator||
name|IFF_SIMPLEX
expr_stmt|;
name|arc_ifattach
argument_list|(
name|ifp
argument_list|,
name|linkaddress
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|CMSOFTCOPY
name|sc
operator|->
name|sc_rxcookie
operator|=
name|softintr_establish
argument_list|(
name|IPL_SOFTNET
argument_list|,
name|cm_srint
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_txcookie
operator|=
name|softintr_establish
argument_list|(
name|IPL_SOFTNET
argument_list|,
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
name|void
operator|*
argument_list|)
operator|)
name|cm_start
argument_list|,
name|ifp
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|500000
name|callout_init
argument_list|(
operator|&
name|sc
operator|->
name|sc_recon_ch
argument_list|)
expr_stmt|;
else|#
directive|else
name|callout_init
argument_list|(
operator|&
name|sc
operator|->
name|sc_recon_ch
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"link addr 0x%02x(%d)\n"
argument_list|,
name|linkaddress
argument_list|,
name|linkaddress
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Initialize device  *  */
end_comment

begin_function
name|void
name|cm_init
parameter_list|(
name|xsc
parameter_list|)
name|void
modifier|*
name|xsc
decl_stmt|;
block|{
name|struct
name|cm_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|cm_softc
operator|*
operator|)
name|xsc
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|int
name|s
decl_stmt|;
name|ifp
operator|=
operator|&
name|sc
operator|->
name|sc_arccom
operator|.
name|ac_if
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
operator|)
operator|==
literal|0
condition|)
block|{
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_RUNNING
expr_stmt|;
name|cm_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|cm_start
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Reset the interface...  *  * this assumes that it is called inside a critical section...  *  */
end_comment

begin_function
name|void
name|cm_reset
parameter_list|(
name|sc
parameter_list|)
name|struct
name|cm_softc
modifier|*
name|sc
decl_stmt|;
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|int
name|linkaddress
decl_stmt|;
name|ifp
operator|=
operator|&
name|sc
operator|->
name|sc_arccom
operator|.
name|ac_if
expr_stmt|;
ifdef|#
directive|ifdef
name|CM_DEBUG
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"reset\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* stop and restart hardware */
name|GETREG
argument_list|(
name|CMRESET
argument_list|)
expr_stmt|;
do|do
block|{
name|DELAY
argument_list|(
literal|200
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|!
operator|(
name|GETREG
argument_list|(
name|CMSTAT
argument_list|)
operator|&
name|CM_POR
operator|)
condition|)
do|;
name|linkaddress
operator|=
name|GETMEM
argument_list|(
name|CMMACOFF
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|CM_DEBUG
argument_list|)
operator|&&
operator|(
name|CM_DEBUG
operator|>
literal|2
operator|)
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"reset: card reset, link addr = 0x%02x (%d)\n"
argument_list|,
name|linkaddress
argument_list|,
name|linkaddress
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* tell the routing level about the (possibly changed) link address */
name|arc_storelladdr
argument_list|(
name|ifp
argument_list|,
name|linkaddress
argument_list|)
expr_stmt|;
name|arc_frag_init
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
comment|/* POR is NMI, but we need it below: */
name|sc
operator|->
name|sc_intmask
operator|=
name|CM_RECON
operator||
name|CM_POR
expr_stmt|;
name|PUTREG
argument_list|(
name|CMSTAT
argument_list|,
name|sc
operator|->
name|sc_intmask
argument_list|)
expr_stmt|;
name|PUTREG
argument_list|(
name|CMCMD
argument_list|,
name|CM_CONF
argument_list|(
name|CONF_LONG
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|CM_DEBUG
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"reset: chip configured, status=0x%02x\n"
argument_list|,
name|GETREG
argument_list|(
name|CMSTAT
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|PUTREG
argument_list|(
name|CMCMD
argument_list|,
name|CM_CLR
argument_list|(
name|CLR_POR
operator||
name|CLR_RECONFIG
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|CM_DEBUG
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"reset: bits cleared, status=0x%02x\n"
argument_list|,
name|GETREG
argument_list|(
name|CMSTAT
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sc
operator|->
name|sc_reconcount_excessive
operator|=
name|ARC_EXCESSIVE_RECONS
expr_stmt|;
comment|/* start receiver */
name|sc
operator|->
name|sc_intmask
operator||=
name|CM_RI
expr_stmt|;
name|sc
operator|->
name|sc_rx_fillcount
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_rx_act
operator|=
literal|2
expr_stmt|;
name|PUTREG
argument_list|(
name|CMCMD
argument_list|,
name|CM_RXBC
argument_list|(
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|PUTREG
argument_list|(
name|CMSTAT
argument_list|,
name|sc
operator|->
name|sc_intmask
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|CM_DEBUG
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"reset: started receiver, status=0x%02x\n"
argument_list|,
name|GETREG
argument_list|(
name|CMSTAT
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* and init transmitter status */
name|sc
operator|->
name|sc_tx_act
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_tx_fillcount
operator|=
literal|0
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_RUNNING
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
name|IFF_OACTIVE
expr_stmt|;
name|cm_start
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Take interface offline  */
end_comment

begin_function
name|void
name|cm_stop
parameter_list|(
name|sc
parameter_list|)
name|struct
name|cm_softc
modifier|*
name|sc
decl_stmt|;
block|{
comment|/* Stop the interrupts */
name|PUTREG
argument_list|(
name|CMSTAT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Stop the interface */
name|GETREG
argument_list|(
name|CMRESET
argument_list|)
expr_stmt|;
comment|/* Stop watchdog timer */
name|sc
operator|->
name|sc_arccom
operator|.
name|ac_if
operator|.
name|if_timer
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Start output on interface. Get another datagram to send  * off the interface queue, and copy it to the  * interface becore starting the output  *  * this assumes that it is called inside a critical section...  * XXX hm... does it still?  *  */
end_comment

begin_function
name|void
name|cm_start
parameter_list|(
name|ifp
parameter_list|)
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
block|{
name|struct
name|cm_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|,
modifier|*
name|mp
decl_stmt|;
name|int
name|cm_ram_ptr
decl_stmt|;
name|int
name|len
decl_stmt|,
name|tlen
decl_stmt|,
name|offset
decl_stmt|,
name|s
decl_stmt|,
name|buffer
decl_stmt|;
ifdef|#
directive|ifdef
name|CMTIMINGS
name|u_long
name|copystart
decl_stmt|,
name|lencopy
decl_stmt|,
name|perbyte
decl_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|CM_DEBUG
argument_list|)
operator|&&
operator|(
name|CM_DEBUG
operator|>
literal|3
operator|)
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"start(%p)\n"
argument_list|,
name|ifp
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
operator|)
operator|==
literal|0
condition|)
return|return;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_tx_fillcount
operator|>=
literal|2
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
name|m
operator|=
name|arc_frag_next
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|buffer
operator|=
name|sc
operator|->
name|sc_tx_act
operator|^
literal|1
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
literal|0
condition|)
return|return;
comment|/* 	 * If bpf is listening on this interface, let it 	 * see the packet before we commit it to the wire 	 * 	 * (can't give the copy in A2060 card RAM to bpf, because 	 * that RAM is just accessed as on every other byte) 	 */
name|BPF_MTAP
argument_list|(
name|ifp
argument_list|,
name|m
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|CM_DEBUG
if|if
condition|(
name|m
operator|->
name|m_len
operator|<
name|ARC_HDRLEN
condition|)
name|m
operator|=
name|m_pullup
argument_list|(
name|m
argument_list|,
name|ARC_HDRLEN
argument_list|)
expr_stmt|;
comment|/* gcc does structure padding */
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"start: filling %d from %d to %d type %d\n"
argument_list|,
name|buffer
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
name|u_char
operator|*
argument_list|)
index|[
literal|0
index|]
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
name|u_char
operator|*
argument_list|)
index|[
literal|1
index|]
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
name|u_char
operator|*
argument_list|)
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|m
operator|->
name|m_len
operator|<
literal|2
condition|)
name|m
operator|=
name|m_pullup
argument_list|(
name|m
argument_list|,
literal|2
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|cm_ram_ptr
operator|=
name|buffer
operator|*
literal|512
expr_stmt|;
if|if
condition|(
name|m
operator|==
literal|0
condition|)
return|return;
comment|/* write the addresses to RAM and throw them away */
comment|/* 	 * Hardware does this: Yet Another Microsecond Saved. 	 * (btw, timing code says usually 2 microseconds) 	 * PUTMEM(cm_ram_ptr + 0, mtod(m, u_char *)[0]); 	 */
name|PUTMEM
argument_list|(
name|cm_ram_ptr
operator|+
literal|1
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
name|u_char
operator|*
argument_list|)
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|m_adj
argument_list|(
name|m
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* get total length left at this point */
name|tlen
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
if|if
condition|(
name|tlen
operator|<
name|ARC_MIN_FORBID_LEN
condition|)
block|{
name|offset
operator|=
literal|256
operator|-
name|tlen
expr_stmt|;
name|PUTMEM
argument_list|(
name|cm_ram_ptr
operator|+
literal|2
argument_list|,
name|offset
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|PUTMEM
argument_list|(
name|cm_ram_ptr
operator|+
literal|2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|tlen
operator|<=
name|ARC_MAX_FORBID_LEN
condition|)
name|offset
operator|=
literal|255
expr_stmt|;
comment|/* !!! */
else|else
block|{
if|if
condition|(
name|tlen
operator|>
name|ARC_MAX_LEN
condition|)
name|tlen
operator|=
name|ARC_MAX_LEN
expr_stmt|;
name|offset
operator|=
literal|512
operator|-
name|tlen
expr_stmt|;
block|}
name|PUTMEM
argument_list|(
name|cm_ram_ptr
operator|+
literal|3
argument_list|,
name|offset
argument_list|)
expr_stmt|;
block|}
name|cm_ram_ptr
operator|+=
name|offset
expr_stmt|;
comment|/* lets loop through the mbuf chain */
for|for
control|(
name|mp
operator|=
name|m
init|;
name|mp
condition|;
name|mp
operator|=
name|mp
operator|->
name|m_next
control|)
block|{
if|if
condition|(
operator|(
name|len
operator|=
name|mp
operator|->
name|m_len
operator|)
condition|)
block|{
comment|/* YAMS */
name|bus_space_write_region_1
argument_list|(
name|rman_get_bustag
argument_list|(
name|sc
operator|->
name|mem_res
argument_list|)
argument_list|,
name|rman_get_bushandle
argument_list|(
name|sc
operator|->
name|mem_res
argument_list|)
argument_list|,
name|cm_ram_ptr
argument_list|,
name|mtod
argument_list|(
name|mp
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|cm_ram_ptr
operator|+=
name|len
expr_stmt|;
block|}
block|}
name|sc
operator|->
name|sc_broadcast
index|[
name|buffer
index|]
operator|=
operator|(
name|m
operator|->
name|m_flags
operator|&
name|M_BCAST
operator|)
operator|!=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_retransmits
index|[
name|buffer
index|]
operator|=
operator|(
name|m
operator|->
name|m_flags
operator|&
name|M_BCAST
operator|)
condition|?
literal|1
else|:
literal|5
expr_stmt|;
comment|/* actually transmit the packet */
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
if|if
condition|(
operator|++
name|sc
operator|->
name|sc_tx_fillcount
operator|>
literal|1
condition|)
block|{
comment|/* 		 * We are filled up to the rim. No more bufs for the moment, 		 * please. 		 */
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_OACTIVE
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|CM_DEBUG
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"start: starting transmitter on buffer %d\n"
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Transmitter was off, start it */
name|sc
operator|->
name|sc_tx_act
operator|=
name|buffer
expr_stmt|;
comment|/* 		 * We still can accept another buf, so don't: 		 * ifp->if_flags |= IFF_OACTIVE; 		 */
name|sc
operator|->
name|sc_intmask
operator||=
name|CM_TA
expr_stmt|;
name|PUTREG
argument_list|(
name|CMCMD
argument_list|,
name|CM_TX
argument_list|(
name|buffer
argument_list|)
argument_list|)
expr_stmt|;
name|PUTREG
argument_list|(
name|CMSTAT
argument_list|,
name|sc
operator|->
name|sc_intmask
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_arccom
operator|.
name|ac_if
operator|.
name|if_timer
operator|=
name|ARCTIMEOUT
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
comment|/* 	 * After 10 times reading the docs, I realized 	 * that in the case the receiver NAKs the buffer request, 	 * the hardware retries till shutdown. 	 * This is integrated now in the code above. 	 */
return|return;
block|}
end_function

begin_comment
comment|/*  * Arcnet interface receiver soft interrupt:  * get the stuff out of any filled buffer we find.  */
end_comment

begin_function
name|void
name|cm_srint
parameter_list|(
name|vsc
parameter_list|)
name|void
modifier|*
name|vsc
decl_stmt|;
block|{
name|struct
name|cm_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|cm_softc
operator|*
operator|)
name|vsc
decl_stmt|;
name|int
name|buffer
decl_stmt|,
name|len
decl_stmt|,
name|offset
decl_stmt|,
name|s
decl_stmt|,
name|type
decl_stmt|;
name|int
name|cm_ram_ptr
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|arc_header
modifier|*
name|ah
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|ifp
operator|=
operator|&
name|sc
operator|->
name|sc_arccom
operator|.
name|ac_if
expr_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|buffer
operator|=
name|sc
operator|->
name|sc_rx_act
operator|^
literal|1
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* Allocate header mbuf */
name|MGETHDR
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
literal|0
condition|)
block|{
comment|/* 		 * in case s.th. goes wrong with mem, drop it 		 * to make sure the receiver can be started again 		 * count it as input error (we dont have any other 		 * detectable) 		 */
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|ifp
expr_stmt|;
comment|/* 	 * Align so that IP packet will be longword aligned. Here we 	 * assume that m_data of new packet is longword aligned. 	 * When implementing PHDS, we might have to change it to 2, 	 * (2*sizeof(ulong) - CM_HDRNEWLEN)), packet type dependent. 	 */
name|cm_ram_ptr
operator|=
name|buffer
operator|*
literal|512
expr_stmt|;
name|offset
operator|=
name|GETMEM
argument_list|(
name|cm_ram_ptr
operator|+
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
condition|)
name|len
operator|=
literal|256
operator|-
name|offset
expr_stmt|;
else|else
block|{
name|offset
operator|=
name|GETMEM
argument_list|(
name|cm_ram_ptr
operator|+
literal|3
argument_list|)
expr_stmt|;
name|len
operator|=
literal|512
operator|-
name|offset
expr_stmt|;
block|}
comment|/* 	 * first +2 bytes for align fixup below 	 * second +2 bytes are for src/dst addresses 	 */
if|if
condition|(
operator|(
name|len
operator|+
literal|2
operator|+
literal|2
operator|)
operator|>
name|MHLEN
condition|)
block|{
comment|/* attach an mbuf cluster */
name|MCLGET
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
comment|/* Insist on getting a cluster */
if|if
condition|(
operator|(
name|m
operator|->
name|m_flags
operator|&
name|M_EXT
operator|)
operator|==
literal|0
condition|)
block|{
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
block|}
if|if
condition|(
name|m
operator|==
literal|0
condition|)
block|{
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
name|type
operator|=
name|GETMEM
argument_list|(
name|cm_ram_ptr
operator|+
name|offset
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_data
operator|+=
literal|1
operator|+
name|arc_isphds
argument_list|(
name|type
argument_list|)
expr_stmt|;
comment|/* mbuf filled with ARCnet addresses */
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|m
operator|->
name|m_len
operator|=
name|len
operator|+
literal|2
expr_stmt|;
name|ah
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|arc_header
operator|*
argument_list|)
expr_stmt|;
name|ah
operator|->
name|arc_shost
operator|=
name|GETMEM
argument_list|(
name|cm_ram_ptr
operator|+
literal|0
argument_list|)
expr_stmt|;
name|ah
operator|->
name|arc_dhost
operator|=
name|GETMEM
argument_list|(
name|cm_ram_ptr
operator|+
literal|1
argument_list|)
expr_stmt|;
name|bus_space_read_region_1
argument_list|(
name|rman_get_bustag
argument_list|(
name|sc
operator|->
name|mem_res
argument_list|)
argument_list|,
name|rman_get_bushandle
argument_list|(
name|sc
operator|->
name|mem_res
argument_list|)
argument_list|,
name|cm_ram_ptr
operator|+
name|offset
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
name|u_char
operator|*
argument_list|)
operator|+
literal|2
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|arc_input
argument_list|(
name|ifp
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|m
operator|=
name|NULL
expr_stmt|;
name|ifp
operator|->
name|if_ipackets
operator|++
expr_stmt|;
name|cleanup
label|:
if|if
condition|(
name|m
operator|!=
name|NULL
condition|)
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
comment|/* mark buffer as invalid by source id 0 */
name|PUTMEM
argument_list|(
name|buffer
operator|<<
literal|9
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
if|if
condition|(
operator|--
name|sc
operator|->
name|sc_rx_fillcount
operator|==
literal|2
operator|-
literal|1
condition|)
block|{
comment|/* was off, restart it on buffer just emptied */
name|sc
operator|->
name|sc_rx_act
operator|=
name|buffer
expr_stmt|;
name|sc
operator|->
name|sc_intmask
operator||=
name|CM_RI
expr_stmt|;
comment|/* this also clears the RI flag interupt: */
name|PUTREG
argument_list|(
name|CMCMD
argument_list|,
name|CM_RXBC
argument_list|(
name|buffer
argument_list|)
argument_list|)
expr_stmt|;
name|PUTREG
argument_list|(
name|CMSTAT
argument_list|,
name|sc
operator|->
name|sc_intmask
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|CM_DEBUG
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"srint: restarted rx on buf %d\n"
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|__inline
specifier|static
name|void
name|cm_tint
parameter_list|(
name|sc
parameter_list|,
name|isr
parameter_list|)
name|struct
name|cm_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|isr
decl_stmt|;
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|int
name|buffer
decl_stmt|;
ifdef|#
directive|ifdef
name|CMTIMINGS
name|int
name|clknow
decl_stmt|;
endif|#
directive|endif
name|ifp
operator|=
operator|&
operator|(
name|sc
operator|->
name|sc_arccom
operator|.
name|ac_if
operator|)
expr_stmt|;
name|buffer
operator|=
name|sc
operator|->
name|sc_tx_act
expr_stmt|;
comment|/* 	 * retransmit code: 	 * Normal situtations first for fast path: 	 * If acknowledgement received ok or broadcast, we're ok. 	 * else if 	 */
if|if
condition|(
name|isr
operator|&
name|CM_TMA
operator|||
name|sc
operator|->
name|sc_broadcast
index|[
name|buffer
index|]
condition|)
name|sc
operator|->
name|sc_arccom
operator|.
name|ac_if
operator|.
name|if_opackets
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|CMRETRANSMIT
elseif|else
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_LINK2
operator|&&
name|ifp
operator|->
name|if_timer
operator|>
literal|0
operator|&&
operator|--
name|sc
operator|->
name|sc_retransmits
index|[
name|buffer
index|]
operator|>
literal|0
condition|)
block|{
comment|/* retransmit same buffer */
name|PUTREG
argument_list|(
name|CMCMD
argument_list|,
name|CM_TX
argument_list|(
name|buffer
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
else|else
name|ifp
operator|->
name|if_oerrors
operator|++
expr_stmt|;
comment|/* We know we can accept another buffer at this point. */
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
name|IFF_OACTIVE
expr_stmt|;
if|if
condition|(
operator|--
name|sc
operator|->
name|sc_tx_fillcount
operator|>
literal|0
condition|)
block|{
comment|/* 		 * start tx on other buffer. 		 * This also clears the int flag 		 */
name|buffer
operator|^=
literal|1
expr_stmt|;
name|sc
operator|->
name|sc_tx_act
operator|=
name|buffer
expr_stmt|;
comment|/* 		 * already given: 		 * sc->sc_intmask |= CM_TA; 		 * PUTREG(CMSTAT, sc->sc_intmask); 		 */
name|PUTREG
argument_list|(
name|CMCMD
argument_list|,
name|CM_TX
argument_list|(
name|buffer
argument_list|)
argument_list|)
expr_stmt|;
comment|/* init watchdog timer */
name|ifp
operator|->
name|if_timer
operator|=
name|ARCTIMEOUT
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|CM_DEBUG
argument_list|)
operator|&&
operator|(
name|CM_DEBUG
operator|>
literal|1
operator|)
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"tint: starting tx on buffer %d, status 0x%02x\n"
argument_list|,
name|buffer
argument_list|,
name|GETREG
argument_list|(
name|CMSTAT
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
comment|/* have to disable TX interrupt */
name|sc
operator|->
name|sc_intmask
operator|&=
operator|~
name|CM_TA
expr_stmt|;
name|PUTREG
argument_list|(
name|CMSTAT
argument_list|,
name|sc
operator|->
name|sc_intmask
argument_list|)
expr_stmt|;
comment|/* ... and watchdog timer */
name|ifp
operator|->
name|if_timer
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|CM_DEBUG
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"tint: no more buffers to send, status 0x%02x\n"
argument_list|,
name|GETREG
argument_list|(
name|CMSTAT
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* XXXX TODO */
ifdef|#
directive|ifdef
name|CMSOFTCOPY
comment|/* schedule soft int to fill a new buffer for us */
name|softintr_schedule
argument_list|(
name|sc
operator|->
name|sc_txcookie
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* call it directly */
name|cm_start
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * Our interrupt routine  */
end_comment

begin_function
name|void
name|cmintr
parameter_list|(
name|arg
parameter_list|)
name|void
modifier|*
name|arg
decl_stmt|;
block|{
name|struct
name|cm_softc
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
operator|&
name|sc
operator|->
name|sc_arccom
operator|.
name|ac_if
decl_stmt|;
name|u_char
name|isr
decl_stmt|,
name|maskedisr
decl_stmt|;
name|int
name|buffer
decl_stmt|;
name|u_long
name|newsec
decl_stmt|;
name|isr
operator|=
name|GETREG
argument_list|(
name|CMSTAT
argument_list|)
expr_stmt|;
name|maskedisr
operator|=
name|isr
operator|&
name|sc
operator|->
name|sc_intmask
expr_stmt|;
if|if
condition|(
operator|!
name|maskedisr
condition|)
return|return;
do|do
block|{
if|#
directive|if
name|defined
argument_list|(
name|CM_DEBUG
argument_list|)
operator|&&
operator|(
name|CM_DEBUG
operator|>
literal|1
operator|)
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"intr: status 0x%02x, intmask 0x%02x\n"
argument_list|,
name|isr
argument_list|,
name|sc
operator|->
name|sc_intmask
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|maskedisr
operator|&
name|CM_POR
condition|)
block|{
comment|/* 			 * XXX We should never see this. Don't bother to store 			 * the address. 			 * sc->sc_arccom.ac_anaddr = GETMEM(CMMACOFF); 			 */
name|PUTREG
argument_list|(
name|CMCMD
argument_list|,
name|CM_CLR
argument_list|(
name|CLR_POR
argument_list|)
argument_list|)
expr_stmt|;
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"%s%d: intr: got spurious power on reset int\n"
argument_list|,
name|ifp
operator|->
name|if_name
argument_list|,
name|ifp
operator|->
name|if_unit
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|maskedisr
operator|&
name|CM_RECON
condition|)
block|{
comment|/* 			 * we dont need to: 			 * PUTREG(CMCMD, CM_CONF(CONF_LONG)); 			 */
name|PUTREG
argument_list|(
name|CMCMD
argument_list|,
name|CM_CLR
argument_list|(
name|CLR_RECONFIG
argument_list|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_arccom
operator|.
name|ac_if
operator|.
name|if_collisions
operator|++
expr_stmt|;
comment|/* 			 * If less than 2 seconds per reconfig: 			 *	If ARC_EXCESSIVE_RECONFIGS 			 *	since last burst, complain and set treshold for 			 *	warnings to ARC_EXCESSIVE_RECONS_REWARN. 			 * 			 * This allows for, e.g., new stations on the cable, or 			 * cable switching as long as it is over after 			 * (normally) 16 seconds. 			 * 			 * XXX TODO: check timeout bits in status word and 			 * double time if necessary. 			 */
name|callout_stop
argument_list|(
operator|&
name|sc
operator|->
name|sc_recon_ch
argument_list|)
expr_stmt|;
name|newsec
operator|=
name|time_second
expr_stmt|;
if|if
condition|(
operator|(
name|newsec
operator|-
name|sc
operator|->
name|sc_recontime
operator|<=
literal|2
operator|)
operator|&&
operator|(
operator|++
name|sc
operator|->
name|sc_reconcount
operator|==
name|ARC_EXCESSIVE_RECONS
operator|)
condition|)
block|{
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"%s%d: excessive token losses, "
literal|"cable problem?\n"
argument_list|,
name|ifp
operator|->
name|if_name
argument_list|,
name|ifp
operator|->
name|if_unit
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|sc_recontime
operator|=
name|newsec
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|sc_recon_ch
argument_list|,
literal|15
operator|*
name|hz
argument_list|,
name|cm_reconwatch
argument_list|,
operator|(
name|void
operator|*
operator|)
name|sc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|maskedisr
operator|&
name|CM_RI
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|CM_DEBUG
argument_list|)
operator|&&
operator|(
name|CM_DEBUG
operator|>
literal|1
operator|)
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"intr: hard rint, act %d\n"
argument_list|,
name|sc
operator|->
name|sc_rx_act
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|buffer
operator|=
name|sc
operator|->
name|sc_rx_act
expr_stmt|;
comment|/* look if buffer is marked invalid: */
if|if
condition|(
name|GETMEM
argument_list|(
name|buffer
operator|*
literal|512
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* 				 * invalid marked buffer (or illegally 				 * configured sender) 				 */
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"%s%d: spurious RX interupt or sender 0 "
literal|" (ignored)\n"
argument_list|,
name|ifp
operator|->
name|if_name
argument_list|,
name|ifp
operator|->
name|if_unit
argument_list|)
expr_stmt|;
comment|/* 				 * restart receiver on same buffer. 				 * XXX maybe better reset interface? 				 */
name|PUTREG
argument_list|(
name|CMCMD
argument_list|,
name|CM_RXBC
argument_list|(
name|buffer
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|++
name|sc
operator|->
name|sc_rx_fillcount
operator|>
literal|1
condition|)
block|{
name|sc
operator|->
name|sc_intmask
operator|&=
operator|~
name|CM_RI
expr_stmt|;
name|PUTREG
argument_list|(
name|CMSTAT
argument_list|,
name|sc
operator|->
name|sc_intmask
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|buffer
operator|^=
literal|1
expr_stmt|;
name|sc
operator|->
name|sc_rx_act
operator|=
name|buffer
expr_stmt|;
comment|/* 					 * Start receiver on other receive 					 * buffer. This also clears the RI 					 * interupt flag. 					 */
name|PUTREG
argument_list|(
name|CMCMD
argument_list|,
name|CM_RXBC
argument_list|(
name|buffer
argument_list|)
argument_list|)
expr_stmt|;
comment|/* in RX intr, so mask is ok for RX */
ifdef|#
directive|ifdef
name|CM_DEBUG
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"strt rx for buf %d, "
literal|"stat 0x%02x\n"
argument_list|,
name|sc
operator|->
name|sc_rx_act
argument_list|,
name|GETREG
argument_list|(
name|CMSTAT
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
ifdef|#
directive|ifdef
name|CMSOFTCOPY
comment|/* 				 * this one starts a soft int to copy out 				 * of the hw 				 */
name|softintr_schedule
argument_list|(
name|sc
operator|->
name|sc_rxcookie
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* this one does the copy here */
name|cm_srint
argument_list|(
name|sc
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
if|if
condition|(
name|maskedisr
operator|&
name|CM_TA
condition|)
block|{
name|cm_tint
argument_list|(
name|sc
argument_list|,
name|isr
argument_list|)
expr_stmt|;
block|}
name|isr
operator|=
name|GETREG
argument_list|(
name|CMSTAT
argument_list|)
expr_stmt|;
name|maskedisr
operator|=
name|isr
operator|&
name|sc
operator|->
name|sc_intmask
expr_stmt|;
block|}
do|while
condition|(
name|maskedisr
condition|)
do|;
if|#
directive|if
name|defined
argument_list|(
name|CM_DEBUG
argument_list|)
operator|&&
operator|(
name|CM_DEBUG
operator|>
literal|1
operator|)
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"intr (exit): status 0x%02x, intmask 0x%02x\n"
argument_list|,
name|isr
argument_list|,
name|sc
operator|->
name|sc_intmask
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|cm_reconwatch
parameter_list|(
name|arg
parameter_list|)
name|void
modifier|*
name|arg
decl_stmt|;
block|{
name|struct
name|cm_softc
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
operator|&
name|sc
operator|->
name|sc_arccom
operator|.
name|ac_if
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_reconcount
operator|>=
name|ARC_EXCESSIVE_RECONS
condition|)
block|{
name|sc
operator|->
name|sc_reconcount
operator|=
literal|0
expr_stmt|;
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"%s%d: token valid again.\n"
argument_list|,
name|ifp
operator|->
name|if_name
argument_list|,
name|ifp
operator|->
name|if_unit
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|sc_reconcount
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Process an ioctl request.  * This code needs some work - it looks pretty ugly.  */
end_comment

begin_function
name|int
name|cm_ioctl
parameter_list|(
name|ifp
parameter_list|,
name|command
parameter_list|,
name|data
parameter_list|)
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|u_long
name|command
decl_stmt|;
name|caddr_t
name|data
decl_stmt|;
block|{
name|struct
name|cm_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|ifaddr
modifier|*
name|ifa
decl_stmt|;
name|struct
name|ifreq
modifier|*
name|ifr
decl_stmt|;
name|int
name|s
decl_stmt|,
name|error
decl_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|sc
operator|=
name|ifp
operator|->
name|if_softc
expr_stmt|;
name|ifa
operator|=
operator|(
expr|struct
name|ifaddr
operator|*
operator|)
name|data
expr_stmt|;
name|ifr
operator|=
operator|(
expr|struct
name|ifreq
operator|*
operator|)
name|data
expr_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|CM_DEBUG
argument_list|)
operator|&&
operator|(
name|CM_DEBUG
operator|>
literal|2
operator|)
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"ioctl() called, cmd = 0x%lx\n"
argument_list|,
name|command
argument_list|)
expr_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|command
condition|)
block|{
case|case
name|SIOCSIFADDR
case|:
case|case
name|SIOCADDMULTI
case|:
case|case
name|SIOCDELMULTI
case|:
case|case
name|SIOCSIFMTU
case|:
name|error
operator|=
name|arc_ioctl
argument_list|(
name|ifp
argument_list|,
name|command
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCSIFFLAGS
case|:
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
operator|)
operator|==
literal|0
operator|&&
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* 			 * If interface is marked down and it is running, 			 * then stop it. 			 */
name|cm_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
name|IFF_RUNNING
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 			 * If interface is marked up and it is stopped, then 			 * start it. 			 */
name|cm_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * watchdog routine for transmitter.  *  * We need this, because else a receiver whose hardware is alive, but whose  * software has not enabled the Receiver, would make our hardware wait forever  * Discovered this after 20 times reading the docs.  *  * Only thing we do is disable transmitter. We'll get a transmit timeout,  * and the int handler will have to decide not to retransmit (in case  * retransmission is implemented).  *  * This one assumes being called inside splimp()  */
end_comment

begin_function
name|void
name|cm_watchdog
parameter_list|(
name|ifp
parameter_list|)
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
block|{
name|struct
name|cm_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|PUTREG
argument_list|(
name|CMCMD
argument_list|,
name|CM_TXDIS
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

end_unit

