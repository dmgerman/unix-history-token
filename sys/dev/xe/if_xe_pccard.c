begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2002 Takeshi Shibagaki  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* xe pccard interface driver */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<net/ethernet.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_arp.h>
end_include

begin_include
include|#
directive|include
file|<net/if_media.h>
end_include

begin_include
include|#
directive|include
file|<net/if_mib.h>
end_include

begin_include
include|#
directive|include
file|<dev/xe/if_xereg.h>
end_include

begin_include
include|#
directive|include
file|<dev/xe/if_xevar.h>
end_include

begin_include
include|#
directive|include
file|<dev/pccard/pccardvar.h>
end_include

begin_include
include|#
directive|include
file|<dev/pccard/pccard_cis.h>
end_include

begin_include
include|#
directive|include
file|"card_if.h"
end_include

begin_include
include|#
directive|include
file|"pccarddevs.h"
end_include

begin_comment
comment|/*  * Debug logging levels - set with hw.xe.debug sysctl  * 0 = None  * 1 = More hardware details, probe/attach progress  * 2 = Most function calls, ioctls and media selection progress  * 3 = Everything - interrupts, packets in/out and multicast address setup  */
end_comment

begin_define
define|#
directive|define
name|XE_DEBUG
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|XE_DEBUG
end_ifdef

begin_decl_stmt
specifier|extern
name|int
name|xe_debug
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|DEVPRINTF
parameter_list|(
name|level
parameter_list|,
name|arg
parameter_list|)
value|if (xe_debug>= (level)) device_printf arg
end_define

begin_define
define|#
directive|define
name|DPRINTF
parameter_list|(
name|level
parameter_list|,
name|arg
parameter_list|)
value|if (xe_debug>= (level)) printf arg
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|DEVPRINTF
parameter_list|(
name|level
parameter_list|,
name|arg
parameter_list|)
end_define

begin_define
define|#
directive|define
name|DPRINTF
parameter_list|(
name|level
parameter_list|,
name|arg
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|XE_CARD_TYPE_FLAGS_NO
value|0x0
end_define

begin_define
define|#
directive|define
name|XE_CARD_TYPE_FLAGS_CE2
value|0x1
end_define

begin_define
define|#
directive|define
name|XE_CARD_TYPE_FLAGS_MOHAWK
value|0x2
end_define

begin_define
define|#
directive|define
name|XE_CARD_TYPE_FLAGS_DINGO
value|0x4
end_define

begin_define
define|#
directive|define
name|XE_PROD_ETHER_MASK
value|0x0100
end_define

begin_define
define|#
directive|define
name|XE_PROD_MODEM_MASK
value|0x1000
end_define

begin_define
define|#
directive|define
name|XE_BOGUS_MAC_OFFSET
value|0x90
end_define

begin_comment
comment|/* MAC vendor prefix used by most Xircom cards is 00:80:c7 */
end_comment

begin_define
define|#
directive|define
name|XE_MAC_ADDR_0
value|0x00
end_define

begin_define
define|#
directive|define
name|XE_MAC_ADDR_1
value|0x80
end_define

begin_define
define|#
directive|define
name|XE_MAC_ADDR_2
value|0xc7
end_define

begin_comment
comment|/* Some (all?) REM56 cards have vendor prefix 00:10:a4 */
end_comment

begin_define
define|#
directive|define
name|XE_REM56_MAC_ADDR_0
value|0x00
end_define

begin_define
define|#
directive|define
name|XE_REM56_MAC_ADDR_1
value|0x10
end_define

begin_define
define|#
directive|define
name|XE_REM56_MAC_ADDR_2
value|0xa4
end_define

begin_struct
struct|struct
name|xe_pccard_product
block|{
name|struct
name|pccard_product
name|product
decl_stmt|;
name|uint16_t
name|prodext
decl_stmt|;
name|uint16_t
name|flags
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|xe_pccard_product
name|xe_pccard_products
index|[]
init|=
block|{
block|{
name|PCMCIA_CARD_D
argument_list|(
name|ACCTON
argument_list|,
name|EN2226
argument_list|)
block|,
literal|0x43
block|,
name|XE_CARD_TYPE_FLAGS_MOHAWK
block|}
block|,
block|{
name|PCMCIA_CARD_D
argument_list|(
name|COMPAQ2
argument_list|,
name|CPQ_10_100
argument_list|)
block|,
literal|0x43
block|,
name|XE_CARD_TYPE_FLAGS_MOHAWK
block|}
block|,
block|{
name|PCMCIA_CARD_D
argument_list|(
name|INTEL
argument_list|,
name|EEPRO100
argument_list|)
block|,
literal|0x43
block|,
name|XE_CARD_TYPE_FLAGS_MOHAWK
block|}
block|,
block|{
name|PCMCIA_CARD_D
argument_list|(
name|INTEL
argument_list|,
name|PRO100LAN56
argument_list|)
block|,
literal|0x46
block|,
name|XE_CARD_TYPE_FLAGS_DINGO
block|}
block|,
block|{
name|PCMCIA_CARD_D
argument_list|(
name|XIRCOM
argument_list|,
name|CE
argument_list|)
block|,
literal|0x41
block|,
name|XE_CARD_TYPE_FLAGS_NO
block|}
block|,
block|{
name|PCMCIA_CARD_D
argument_list|(
name|XIRCOM
argument_list|,
name|CE2
argument_list|)
block|,
literal|0x41
block|,
name|XE_CARD_TYPE_FLAGS_CE2
block|}
block|,
block|{
name|PCMCIA_CARD_D
argument_list|(
name|XIRCOM
argument_list|,
name|CE2
argument_list|)
block|,
literal|0x42
block|,
name|XE_CARD_TYPE_FLAGS_CE2
block|}
block|,
block|{
name|PCMCIA_CARD_D
argument_list|(
name|XIRCOM
argument_list|,
name|CE2_2
argument_list|)
block|,
literal|0x41
block|,
name|XE_CARD_TYPE_FLAGS_CE2
block|}
block|,
block|{
name|PCMCIA_CARD_D
argument_list|(
name|XIRCOM
argument_list|,
name|CE2_2
argument_list|)
block|,
literal|0x42
block|,
name|XE_CARD_TYPE_FLAGS_CE2
block|}
block|,
block|{
name|PCMCIA_CARD_D
argument_list|(
name|XIRCOM
argument_list|,
name|CE3
argument_list|)
block|,
literal|0x43
block|,
name|XE_CARD_TYPE_FLAGS_MOHAWK
block|}
block|,
block|{
name|PCMCIA_CARD_D
argument_list|(
name|XIRCOM
argument_list|,
name|CEM
argument_list|)
block|,
literal|0x41
block|,
name|XE_CARD_TYPE_FLAGS_NO
block|}
block|,
block|{
name|PCMCIA_CARD_D
argument_list|(
name|XIRCOM
argument_list|,
name|CEM2
argument_list|)
block|,
literal|0x42
block|,
name|XE_CARD_TYPE_FLAGS_CE2
block|}
block|,
block|{
name|PCMCIA_CARD_D
argument_list|(
name|XIRCOM
argument_list|,
name|CEM28
argument_list|)
block|,
literal|0x43
block|,
name|XE_CARD_TYPE_FLAGS_CE2
block|}
block|,
block|{
name|PCMCIA_CARD_D
argument_list|(
name|XIRCOM
argument_list|,
name|CEM33
argument_list|)
block|,
literal|0x44
block|,
name|XE_CARD_TYPE_FLAGS_CE2
block|}
block|,
block|{
name|PCMCIA_CARD_D
argument_list|(
name|XIRCOM
argument_list|,
name|CEM33_2
argument_list|)
block|,
literal|0x44
block|,
name|XE_CARD_TYPE_FLAGS_CE2
block|}
block|,
block|{
name|PCMCIA_CARD_D
argument_list|(
name|XIRCOM
argument_list|,
name|CEM56
argument_list|)
block|,
literal|0x45
block|,
name|XE_CARD_TYPE_FLAGS_DINGO
block|}
block|,
block|{
name|PCMCIA_CARD_D
argument_list|(
name|XIRCOM
argument_list|,
name|CEM56_2
argument_list|)
block|,
literal|0x46
block|,
name|XE_CARD_TYPE_FLAGS_DINGO
block|}
block|,
block|{
name|PCMCIA_CARD_D
argument_list|(
name|XIRCOM
argument_list|,
name|REM56
argument_list|)
block|,
literal|0x46
block|,
name|XE_CARD_TYPE_FLAGS_DINGO
block|}
block|,
block|{
name|PCMCIA_CARD_D
argument_list|(
name|XIRCOM
argument_list|,
name|REM10
argument_list|)
block|,
literal|0x47
block|,
name|XE_CARD_TYPE_FLAGS_DINGO
block|}
block|,
block|{
name|PCMCIA_CARD_D
argument_list|(
name|XIRCOM
argument_list|,
name|XEM5600
argument_list|)
block|,
literal|0x56
block|,
name|XE_CARD_TYPE_FLAGS_DINGO
block|}
block|,
block|{
block|{
name|NULL
block|}
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Fixing for CEM2, CEM3 and CEM56/REM56 cards.  These need some magic to  * enable the Ethernet function, which isn't mentioned anywhere in the CIS.  * Despite the register names, most of this isn't Dingo-specific.  */
end_comment

begin_function
specifier|static
name|int
name|xe_cemfix
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|xe_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|xe_softc
operator|*
operator|)
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|bus_space_tag_t
name|bst
decl_stmt|;
name|bus_space_handle_t
name|bsh
decl_stmt|;
name|struct
name|resource
modifier|*
name|r
decl_stmt|;
name|int
name|rid
decl_stmt|;
name|int
name|ioport
decl_stmt|;
name|DEVPRINTF
argument_list|(
literal|2
argument_list|,
operator|(
name|dev
operator|,
literal|"cemfix\n"
operator|)
argument_list|)
expr_stmt|;
name|DEVPRINTF
argument_list|(
literal|1
argument_list|,
operator|(
name|dev
operator|,
literal|"CEM I/O port 0x%0lx, size 0x%0lx\n"
operator|,
name|bus_get_resource_start
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
name|sc
operator|->
name|port_rid
argument_list|)
operator|,
name|bus_get_resource_count
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
name|sc
operator|->
name|port_rid
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|rid
operator|=
literal|0
expr_stmt|;
name|r
operator|=
name|bus_alloc_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
operator|&
name|rid
argument_list|,
literal|0
argument_list|,
operator|~
literal|0
argument_list|,
literal|4
operator|<<
literal|10
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|r
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"cemfix: Can't map in attribute memory\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|bsh
operator|=
name|rman_get_bushandle
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|bst
operator|=
name|rman_get_bustag
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|CARD_SET_RES_FLAGS
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|,
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|rid
argument_list|,
name|PCCARD_A_MEM_ATTR
argument_list|)
expr_stmt|;
name|bus_space_write_1
argument_list|(
name|bst
argument_list|,
name|bsh
argument_list|,
name|DINGO_ECOR
argument_list|,
name|DINGO_ECOR_IRQ_LEVEL
operator||
name|DINGO_ECOR_INT_ENABLE
operator||
name|DINGO_ECOR_IOB_ENABLE
operator||
name|DINGO_ECOR_ETH_ENABLE
argument_list|)
expr_stmt|;
name|ioport
operator|=
name|bus_get_resource_start
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
name|sc
operator|->
name|port_rid
argument_list|)
expr_stmt|;
name|bus_space_write_1
argument_list|(
name|bst
argument_list|,
name|bsh
argument_list|,
name|DINGO_EBAR0
argument_list|,
name|ioport
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|bus_space_write_1
argument_list|(
name|bst
argument_list|,
name|bsh
argument_list|,
name|DINGO_EBAR1
argument_list|,
operator|(
name|ioport
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|dingo
condition|)
block|{
name|bus_space_write_1
argument_list|(
name|bst
argument_list|,
name|bsh
argument_list|,
name|DINGO_DCOR0
argument_list|,
name|DINGO_DCOR0_SF_INT
argument_list|)
expr_stmt|;
name|bus_space_write_1
argument_list|(
name|bst
argument_list|,
name|bsh
argument_list|,
name|DINGO_DCOR1
argument_list|,
name|DINGO_DCOR1_INT_LEVEL
operator||
name|DINGO_DCOR1_EEDIO
argument_list|)
expr_stmt|;
name|bus_space_write_1
argument_list|(
name|bst
argument_list|,
name|bsh
argument_list|,
name|DINGO_DCOR2
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
name|bus_space_write_1
argument_list|(
name|bst
argument_list|,
name|bsh
argument_list|,
name|DINGO_DCOR3
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
name|bus_space_write_1
argument_list|(
name|bst
argument_list|,
name|bsh
argument_list|,
name|DINGO_DCOR4
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
block|}
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|rid
argument_list|,
name|r
argument_list|)
expr_stmt|;
comment|/* success! */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Fixing for CE2-class cards with bogus CIS entry for MAC address.  This  * should be in a type 0x22 tuple, but some cards seem to use 0x89.  * This function looks for a sensible MAC address tuple starting at the given  * offset in attribute memory, ignoring the tuple type field.  */
end_comment

begin_function
specifier|static
name|int
name|xe_macfix
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|int
name|offset
parameter_list|)
block|{
name|struct
name|xe_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|xe_softc
operator|*
operator|)
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|bus_space_tag_t
name|bst
decl_stmt|;
name|bus_space_handle_t
name|bsh
decl_stmt|;
name|struct
name|resource
modifier|*
name|r
decl_stmt|;
name|int
name|rid
decl_stmt|,
name|i
decl_stmt|;
name|uint8_t
name|cisdata
index|[
literal|9
index|]
decl_stmt|;
name|uint8_t
name|required
index|[
literal|6
index|]
init|=
block|{
literal|0x08
block|,
name|PCCARD_TPLFE_TYPE_LAN_NID
block|,
name|ETHER_ADDR_LEN
block|,
name|XE_MAC_ADDR_0
block|,
name|XE_MAC_ADDR_1
block|,
name|XE_MAC_ADDR_2
block|}
decl_stmt|;
name|DEVPRINTF
argument_list|(
literal|2
argument_list|,
operator|(
name|dev
operator|,
literal|"macfix\n"
operator|)
argument_list|)
expr_stmt|;
name|rid
operator|=
literal|0
expr_stmt|;
name|r
operator|=
name|bus_alloc_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
operator|&
name|rid
argument_list|,
literal|0
argument_list|,
operator|~
literal|0
argument_list|,
literal|4
operator|<<
literal|10
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|r
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"macfix: Can't map in attribute memory\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|bsh
operator|=
name|rman_get_bushandle
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|bst
operator|=
name|rman_get_bustag
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|CARD_SET_RES_FLAGS
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|,
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|rid
argument_list|,
name|PCCARD_A_MEM_ATTR
argument_list|)
expr_stmt|;
comment|/* 	 * Looking for (relative to offset): 	 * 	 *  0x00	0x??	Tuple type (ignored) 	 *  0x02 	0x08	Tuple length (must be 8) 	 *  0x04	0x04	Address type? (must be 4) 	 *  0x06	0x06	Address length (must be 6) 	 *  0x08	0x00	Manufacturer ID, byte 1 	 *  0x0a	0x80	Manufacturer ID, byte 2 	 *  0x0c	0xc7	Manufacturer ID, byte 3 	 *  0x0e	0x??	Card ID, byte 1 	 *  0x10	0x??	Card ID, byte 2 	 *  0x12	0x??	Card ID, byte 3 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|9
condition|;
name|i
operator|++
control|)
block|{
name|cisdata
index|[
name|i
index|]
operator|=
name|bus_space_read_1
argument_list|(
name|bst
argument_list|,
name|bsh
argument_list|,
name|offset
operator|+
operator|(
literal|2
operator|*
name|i
operator|)
operator|+
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|6
operator|&&
name|required
index|[
name|i
index|]
operator|!=
name|cisdata
index|[
name|i
index|]
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"macfix: Can't find valid MAC address\n"
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|rid
argument_list|,
name|r
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ETHER_ADDR_LEN
condition|;
name|i
operator|++
control|)
block|{
name|sc
operator|->
name|enaddr
index|[
name|i
index|]
operator|=
name|cisdata
index|[
name|i
operator|+
literal|3
index|]
expr_stmt|;
block|}
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|rid
argument_list|,
name|r
argument_list|)
expr_stmt|;
comment|/* success! */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * PCMCIA probe routine.  * Identify the device.  Called from the bus driver when the card is  * inserted or otherwise powers up.  */
end_comment

begin_function
specifier|static
name|int
name|xe_pccard_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|xe_softc
modifier|*
name|scp
init|=
operator|(
expr|struct
name|xe_softc
operator|*
operator|)
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|uint32_t
name|vendor
decl_stmt|,
name|product
decl_stmt|;
name|uint16_t
name|prodext
decl_stmt|;
specifier|const
name|char
modifier|*
name|vendor_str
init|=
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|product_str
init|=
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|cis4_str
init|=
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|cis3_str
init|=
name|NULL
decl_stmt|;
specifier|const
name|struct
name|xe_pccard_product
modifier|*
name|xpp
decl_stmt|;
name|DEVPRINTF
argument_list|(
literal|2
argument_list|,
operator|(
name|dev
operator|,
literal|"pccard_probe\n"
operator|)
argument_list|)
expr_stmt|;
name|pccard_get_vendor
argument_list|(
name|dev
argument_list|,
operator|&
name|vendor
argument_list|)
expr_stmt|;
name|pccard_get_product
argument_list|(
name|dev
argument_list|,
operator|&
name|product
argument_list|)
expr_stmt|;
name|pccard_get_prodext
argument_list|(
name|dev
argument_list|,
operator|&
name|prodext
argument_list|)
expr_stmt|;
name|pccard_get_vendor_str
argument_list|(
name|dev
argument_list|,
operator|&
name|vendor_str
argument_list|)
expr_stmt|;
name|pccard_get_product_str
argument_list|(
name|dev
argument_list|,
operator|&
name|product_str
argument_list|)
expr_stmt|;
name|pccard_get_cis3_str
argument_list|(
name|dev
argument_list|,
operator|&
name|cis3_str
argument_list|)
expr_stmt|;
name|pccard_get_cis4_str
argument_list|(
name|dev
argument_list|,
operator|&
name|cis4_str
argument_list|)
expr_stmt|;
name|DEVPRINTF
argument_list|(
literal|1
argument_list|,
operator|(
name|dev
operator|,
literal|"vendor = 0x%04x\n"
operator|,
name|vendor
operator|)
argument_list|)
expr_stmt|;
name|DEVPRINTF
argument_list|(
literal|1
argument_list|,
operator|(
name|dev
operator|,
literal|"product = 0x%04x\n"
operator|,
name|product
operator|)
argument_list|)
expr_stmt|;
name|DEVPRINTF
argument_list|(
literal|1
argument_list|,
operator|(
name|dev
operator|,
literal|"prodext = 0x%02x\n"
operator|,
name|prodext
operator|)
argument_list|)
expr_stmt|;
name|DEVPRINTF
argument_list|(
literal|1
argument_list|,
operator|(
name|dev
operator|,
literal|"vendor_str = %s\n"
operator|,
name|vendor_str
operator|)
argument_list|)
expr_stmt|;
name|DEVPRINTF
argument_list|(
literal|1
argument_list|,
operator|(
name|dev
operator|,
literal|"product_str = %s\n"
operator|,
name|product_str
operator|)
argument_list|)
expr_stmt|;
name|DEVPRINTF
argument_list|(
literal|1
argument_list|,
operator|(
name|dev
operator|,
literal|"cis3_str = %s\n"
operator|,
name|cis3_str
operator|)
argument_list|)
expr_stmt|;
name|DEVPRINTF
argument_list|(
literal|1
argument_list|,
operator|(
name|dev
operator|,
literal|"cis4_str = %s\n"
operator|,
name|cis4_str
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Possibly already did this search in xe_pccard_match(), 	 * but we need to do it here anyway to figure out which 	 * card we have. 	 */
for|for
control|(
name|xpp
operator|=
name|xe_pccard_products
init|;
name|xpp
operator|->
name|product
operator|.
name|pp_vendor
operator|!=
literal|0
condition|;
name|xpp
operator|++
control|)
block|{
if|if
condition|(
name|vendor
operator|==
name|xpp
operator|->
name|product
operator|.
name|pp_vendor
operator|&&
name|product
operator|==
name|xpp
operator|->
name|product
operator|.
name|pp_product
operator|&&
name|prodext
operator|==
name|xpp
operator|->
name|prodext
condition|)
break|break;
block|}
comment|/* Found a match? */
if|if
condition|(
name|xpp
operator|->
name|product
operator|.
name|pp_vendor
operator|==
literal|0
condition|)
return|return
operator|(
name|ENODEV
operator|)
return|;
comment|/* Set card name for logging later */
if|if
condition|(
name|xpp
operator|->
name|product
operator|.
name|pp_name
operator|!=
name|NULL
condition|)
name|device_set_desc
argument_list|(
name|dev
argument_list|,
name|xpp
operator|->
name|product
operator|.
name|pp_name
argument_list|)
expr_stmt|;
comment|/* Reject known but unsupported cards */
if|if
condition|(
name|xpp
operator|->
name|flags
operator|&
name|XE_CARD_TYPE_FLAGS_NO
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Sorry, your %s %s card is not supported :(\n"
argument_list|,
name|vendor_str
argument_list|,
name|product_str
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENODEV
operator|)
return|;
block|}
comment|/* Set various card ID fields in softc */
name|scp
operator|->
name|vendor
operator|=
name|vendor_str
expr_stmt|;
name|scp
operator|->
name|card_type
operator|=
name|product_str
expr_stmt|;
if|if
condition|(
name|xpp
operator|->
name|flags
operator|&
name|XE_CARD_TYPE_FLAGS_CE2
condition|)
name|scp
operator|->
name|ce2
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|xpp
operator|->
name|flags
operator|&
name|XE_CARD_TYPE_FLAGS_MOHAWK
condition|)
name|scp
operator|->
name|mohawk
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|xpp
operator|->
name|flags
operator|&
name|XE_CARD_TYPE_FLAGS_DINGO
condition|)
block|{
name|scp
operator|->
name|dingo
operator|=
literal|1
expr_stmt|;
name|scp
operator|->
name|mohawk
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|xpp
operator|->
name|product
operator|.
name|pp_product
operator|&
name|XE_PROD_MODEM_MASK
condition|)
name|scp
operator|->
name|modem
operator|=
literal|1
expr_stmt|;
comment|/* Get MAC address */
name|pccard_get_ether
argument_list|(
name|dev
argument_list|,
name|scp
operator|->
name|enaddr
argument_list|)
expr_stmt|;
comment|/* Deal with bogus MAC address */
if|if
condition|(
name|xpp
operator|->
name|product
operator|.
name|pp_vendor
operator|==
name|PCMCIA_VENDOR_XIRCOM
operator|&&
name|scp
operator|->
name|ce2
operator|&&
operator|(
name|scp
operator|->
name|enaddr
index|[
literal|0
index|]
operator|!=
name|XE_MAC_ADDR_0
operator|||
name|scp
operator|->
name|enaddr
index|[
literal|1
index|]
operator|!=
name|XE_MAC_ADDR_1
operator|||
name|scp
operator|->
name|enaddr
index|[
literal|2
index|]
operator|!=
name|XE_MAC_ADDR_2
operator|)
operator|&&
name|xe_macfix
argument_list|(
name|dev
argument_list|,
name|XE_BOGUS_MAC_OFFSET
argument_list|)
operator|<
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unable to find MAC address for your %s card\n"
argument_list|,
name|scp
operator|->
name|card_type
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENODEV
operator|)
return|;
block|}
comment|/* Success */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Attach a device.  */
end_comment

begin_function
specifier|static
name|int
name|xe_pccard_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|xe_softc
modifier|*
name|scp
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|err
decl_stmt|;
name|DEVPRINTF
argument_list|(
literal|2
argument_list|,
operator|(
name|dev
operator|,
literal|"pccard_attach\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|err
operator|=
name|xe_activate
argument_list|(
name|dev
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|err
operator|)
return|;
comment|/* Hack RealPorts into submission */
if|if
condition|(
name|scp
operator|->
name|modem
operator|&&
name|xe_cemfix
argument_list|(
name|dev
argument_list|)
operator|<
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unable to fix your %s %s combo card\n"
argument_list|,
name|scp
operator|->
name|vendor
argument_list|,
name|scp
operator|->
name|card_type
argument_list|)
expr_stmt|;
name|xe_deactivate
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENODEV
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|err
operator|=
name|xe_attach
argument_list|(
name|dev
argument_list|)
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"xe_attach() failed! (%d)\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * The device entry is being removed, probably because someone ejected the  * card.  The interface should have been brought down manually before calling  * this function; if not you may well lose packets.  In any case, I shut down  * the card and the interface, and hope for the best.  */
end_comment

begin_function
specifier|static
name|int
name|xe_pccard_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|xe_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|DEVPRINTF
argument_list|(
literal|2
argument_list|,
operator|(
name|dev
operator|,
literal|"pccard_detach\n"
operator|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
name|IFF_RUNNING
expr_stmt|;
name|ether_ifdetach
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
expr_stmt|;
name|if_free
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
expr_stmt|;
name|xe_deactivate
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|xe_pccard_product_match
parameter_list|(
name|device_t
name|dev
parameter_list|,
specifier|const
name|struct
name|pccard_product
modifier|*
name|ent
parameter_list|,
name|int
name|vpfmatch
parameter_list|)
block|{
specifier|const
name|struct
name|xe_pccard_product
modifier|*
name|xpp
decl_stmt|;
name|uint16_t
name|prodext
decl_stmt|;
name|DEVPRINTF
argument_list|(
literal|2
argument_list|,
operator|(
name|dev
operator|,
literal|"pccard_product_match\n"
operator|)
argument_list|)
expr_stmt|;
name|xpp
operator|=
operator|(
specifier|const
expr|struct
name|xe_pccard_product
operator|*
operator|)
name|ent
expr_stmt|;
name|pccard_get_prodext
argument_list|(
name|dev
argument_list|,
operator|&
name|prodext
argument_list|)
expr_stmt|;
if|if
condition|(
name|xpp
operator|->
name|prodext
operator|!=
name|prodext
condition|)
name|vpfmatch
operator|=
literal|0
expr_stmt|;
else|else
name|vpfmatch
operator|++
expr_stmt|;
return|return
operator|(
name|vpfmatch
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|xe_pccard_match
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
name|uint32_t
name|fcn
init|=
name|PCCARD_FUNCTION_UNSPEC
decl_stmt|;
specifier|const
name|struct
name|pccard_product
modifier|*
name|pp
decl_stmt|;
name|DEVPRINTF
argument_list|(
literal|2
argument_list|,
operator|(
name|dev
operator|,
literal|"pccard_match\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* Make sure we're a network function */
name|error
operator|=
name|pccard_get_function
argument_list|(
name|dev
argument_list|,
operator|&
name|fcn
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|fcn
operator|!=
name|PCCARD_FUNCTION_NETWORK
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
comment|/* If we match something in the table, it is our device. */
name|pp
operator|=
operator|(
specifier|const
expr|struct
name|pccard_product
operator|*
operator|)
name|xe_pccard_products
expr_stmt|;
if|if
condition|(
operator|(
name|pp
operator|=
name|pccard_product_lookup
argument_list|(
name|dev
argument_list|,
name|pp
argument_list|,
sizeof|sizeof
argument_list|(
name|xe_pccard_products
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|xe_pccard_product_match
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|device_method_t
name|xe_pccard_methods
index|[]
init|=
block|{
comment|/* Device interface */
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|pccard_compat_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|pccard_compat_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|xe_pccard_detach
argument_list|)
block|,
comment|/* Card interface */
name|DEVMETHOD
argument_list|(
name|card_compat_match
argument_list|,
name|xe_pccard_match
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|card_compat_probe
argument_list|,
name|xe_pccard_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|card_compat_attach
argument_list|,
name|xe_pccard_attach
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|xe_pccard_driver
init|=
block|{
literal|"xe"
block|,
name|xe_pccard_methods
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|xe_softc
argument_list|)
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|devclass_t
name|xe_devclass
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|xe
argument_list|,
name|pccard
argument_list|,
name|xe_pccard_driver
argument_list|,
name|xe_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

