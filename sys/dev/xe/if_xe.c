begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1998, 1999 Scott Mitchell  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *	$Id: if_xe.c,v 1.20 1999/06/13 19:17:40 scott Exp $  * $FreeBSD$  */
end_comment

begin_comment
comment|/*  * XXX TODO XXX  *  * I've pushed this fairly far, but there are some things that need to be  * done here.  I'm documenting them here in case I get destracted. -- imp  *  * xe_cem56fix -- need to figure out how to map the extra stuff.  */
end_comment

begin_comment
comment|/*  * Portions of this software were derived from Werner Koch's xirc2ps driver  * for Linux under the terms of the following license (from v1.30 of the  * xirc2ps driver):  *  * Copyright (c) 1997 by Werner Koch (dd9jn)  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, and the entire permission notice in its entirety,  *    including the disclaimer of warranties.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. The name of the author may not be used to endorse or promote  *    products derived from this software without specific prior  *    written permission.  *  * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED  * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE  * DISCLAIMED.	IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,  * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED  * OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*		  * FreeBSD device driver for Xircom CreditCard PCMCIA Ethernet adapters.  The  * following cards are currently known to work with the driver:  *   Xircom CreditCard 10/100 (CE3)  *   Xircom CreditCard Ethernet + Modem 28 (CEM28)  *   Xircom CreditCard Ethernet 10/100 + Modem 56 (CEM56)  *   Xircom RealPort Ethernet 10  *   Xircom RealPort Ethernet 10/100  *   Xircom RealPort Ethernet 10/100 + Modem 56 (REM56, REM56G)  *   Intel EtherExpress Pro/100 PC Card Mobile Adapter 16 (Pro/100 M16A)  *   Compaq Netelligent 10/100 PC Card (CPQ-10/100)  *  * Some other cards *should* work, but support for them is either broken or in   * an unknown state at the moment.  I'm always interested in hearing from  * people who own any of these cards:  *   Xircom CreditCard 10Base-T (PS-CE2-10)  *   Xircom CreditCard Ethernet + ModemII (CEM2)  *   Xircom CEM28 and CEM33 Ethernet/Modem cards (may be variants of CEM2?)  *  * Thanks to all who assisted with the development and testing of the driver,  * especially: Werner Koch, Duke Kamstra, Duncan Barclay, Jason George, Dru  * Nelson, Mike Kephart, Bill Rainey and Douglas Rand.  Apologies if I've left  * out anyone who deserves a mention here.  *  * Special thanks to Ade Lovett for both hosting the mailing list and doing  * the CEM56/REM56 support code; and the FreeBSD UK Users' Group for hosting  * the web pages.  *  * Contact points:  *  * Driver web page: http://ukug.uk.freebsd.org/~scott/xe_drv/  *  * Mailing list: http://www.lovett.com/lists/freebsd-xircom/  * or send "subscribe freebsd-xircom" to<majordomo@lovett.com>  *  * Author email:<scott@uk.freebsd.org>  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/select.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<net/ethernet.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_arp.h>
end_include

begin_include
include|#
directive|include
file|<net/if_dl.h>
end_include

begin_include
include|#
directive|include
file|<net/if_media.h>
end_include

begin_include
include|#
directive|include
file|<net/if_mib.h>
end_include

begin_include
include|#
directive|include
file|<net/bpf.h>
end_include

begin_include
include|#
directive|include
file|<dev/pccard/pccardvar.h>
end_include

begin_include
include|#
directive|include
file|"card_if.h"
end_include

begin_include
include|#
directive|include
file|<dev/xe/if_xereg.h>
end_include

begin_include
include|#
directive|include
file|<dev/xe/if_xevar.h>
end_include

begin_include
include|#
directive|include
file|<machine/clock.h>
end_include

begin_comment
comment|/*  * MII command structure  */
end_comment

begin_struct
struct|struct
name|xe_mii_frame
block|{
name|u_int8_t
name|mii_stdelim
decl_stmt|;
name|u_int8_t
name|mii_opcode
decl_stmt|;
name|u_int8_t
name|mii_phyaddr
decl_stmt|;
name|u_int8_t
name|mii_regaddr
decl_stmt|;
name|u_int8_t
name|mii_turnaround
decl_stmt|;
name|u_int16_t
name|mii_data
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * Media autonegotiation progress constants  */
end_comment

begin_define
define|#
directive|define
name|XE_AUTONEG_NONE
value|0
end_define

begin_comment
comment|/* No autonegotiation in progress */
end_comment

begin_define
define|#
directive|define
name|XE_AUTONEG_WAITING
value|1
end_define

begin_comment
comment|/* Waiting for transmitter to go idle */
end_comment

begin_define
define|#
directive|define
name|XE_AUTONEG_STARTED
value|2
end_define

begin_comment
comment|/* Waiting for autonegotiation to complete */
end_comment

begin_define
define|#
directive|define
name|XE_AUTONEG_100TX
value|3
end_define

begin_comment
comment|/* Trying to force 100baseTX link */
end_comment

begin_define
define|#
directive|define
name|XE_AUTONEG_FAIL
value|4
end_define

begin_comment
comment|/* Autonegotiation failed */
end_comment

begin_comment
comment|/*  * Prototypes start here  */
end_comment

begin_function_decl
specifier|static
name|int
name|xe_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|xe_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|xe_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|xe_activate
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xe_deactivate
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xe_init
parameter_list|(
name|void
modifier|*
name|xscp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xe_start
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|xe_ioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|u_long
name|command
parameter_list|,
name|caddr_t
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xe_watchdog
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|xe_media_change
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xe_media_status
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|ifmediareq
modifier|*
name|mrp
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|timeout_t
name|xe_setmedia
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|xe_hard_reset
parameter_list|(
name|struct
name|xe_softc
modifier|*
name|scp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xe_soft_reset
parameter_list|(
name|struct
name|xe_softc
modifier|*
name|scp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xe_stop
parameter_list|(
name|struct
name|xe_softc
modifier|*
name|scp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xe_enable_intr
parameter_list|(
name|struct
name|xe_softc
modifier|*
name|scp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xe_disable_intr
parameter_list|(
name|struct
name|xe_softc
modifier|*
name|scp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xe_setmulti
parameter_list|(
name|struct
name|xe_softc
modifier|*
name|scp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xe_setaddrs
parameter_list|(
name|struct
name|xe_softc
modifier|*
name|scp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|xe_pio_write_packet
parameter_list|(
name|struct
name|xe_softc
modifier|*
name|scp
parameter_list|,
name|struct
name|mbuf
modifier|*
name|mbp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u_int32_t
name|xe_compute_crc
parameter_list|(
name|u_int8_t
modifier|*
name|data
parameter_list|,
name|int
name|len
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|xe_compute_hashbit
parameter_list|(
name|u_int32_t
name|crc
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * MII functions  */
end_comment

begin_function_decl
specifier|static
name|void
name|xe_mii_sync
parameter_list|(
name|struct
name|xe_softc
modifier|*
name|scp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|xe_mii_init
parameter_list|(
name|struct
name|xe_softc
modifier|*
name|scp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xe_mii_send
parameter_list|(
name|struct
name|xe_softc
modifier|*
name|scp
parameter_list|,
name|u_int32_t
name|bits
parameter_list|,
name|int
name|cnt
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|xe_mii_readreg
parameter_list|(
name|struct
name|xe_softc
modifier|*
name|scp
parameter_list|,
name|struct
name|xe_mii_frame
modifier|*
name|frame
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|xe_mii_writereg
parameter_list|(
name|struct
name|xe_softc
modifier|*
name|scp
parameter_list|,
name|struct
name|xe_mii_frame
modifier|*
name|frame
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u_int16_t
name|xe_phy_readreg
parameter_list|(
name|struct
name|xe_softc
modifier|*
name|scp
parameter_list|,
name|u_int16_t
name|reg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xe_phy_writereg
parameter_list|(
name|struct
name|xe_softc
modifier|*
name|scp
parameter_list|,
name|u_int16_t
name|reg
parameter_list|,
name|u_int16_t
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Debug functions -- uncomment for VERY verbose dignostic information.  * Set to 1 for less verbose information  */
end_comment

begin_comment
comment|/* #define XE_DEBUG 2 */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|XE_DEBUG
end_ifdef

begin_define
define|#
directive|define
name|XE_REG_DUMP
parameter_list|(
name|scp
parameter_list|)
value|xe_reg_dump((scp))
end_define

begin_define
define|#
directive|define
name|XE_MII_DUMP
parameter_list|(
name|scp
parameter_list|)
value|xe_mii_dump((scp))
end_define

begin_function_decl
specifier|static
name|void
name|xe_reg_dump
parameter_list|(
name|struct
name|xe_softc
modifier|*
name|scp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xe_mii_dump
parameter_list|(
name|struct
name|xe_softc
modifier|*
name|scp
parameter_list|)
function_decl|;
end_function_decl

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|XE_REG_DUMP
parameter_list|(
name|scp
parameter_list|)
end_define

begin_define
define|#
directive|define
name|XE_MII_DUMP
parameter_list|(
name|scp
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Fixing for RealPort cards - they need a little furtling to get the  * ethernet working  */
end_comment

begin_function
specifier|static
name|int
name|xe_cem56fix
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|xe_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|xe_softc
operator|*
operator|)
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|bus_space_tag_t
name|bst
decl_stmt|;
name|bus_space_handle_t
name|bsh
decl_stmt|;
name|struct
name|resource
modifier|*
name|r
decl_stmt|;
name|int
name|rid
decl_stmt|;
name|int
name|ioport
decl_stmt|;
ifdef|#
directive|ifdef
name|XE_DEBUG
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Hacking your Realport, master\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|XE_DEBUG
operator|>
literal|1
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Realport port 0x%0lx, size 0x%0lx\n"
argument_list|,
name|bus_get_resource_start
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
name|sc
operator|->
name|port_rid
argument_list|)
argument_list|,
name|bus_get_resource_count
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
name|sc
operator|->
name|port_rid
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|rid
operator|=
literal|0
expr_stmt|;
name|r
operator|=
name|bus_alloc_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
operator|&
name|rid
argument_list|,
literal|0
argument_list|,
operator|~
literal|0
argument_list|,
literal|4
operator|<<
literal|10
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|r
condition|)
block|{
if|#
directive|if
name|XE_DEBUG
operator|>
literal|0
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Can't map in attribute memory\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|-
literal|1
return|;
block|}
name|bsh
operator|=
name|rman_get_bushandle
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|bst
operator|=
name|rman_get_bustag
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|CARD_SET_RES_FLAGS
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|,
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|rid
argument_list|,
name|PCCARD_A_MEM_ATTR
argument_list|)
expr_stmt|;
name|bus_space_write_1
argument_list|(
name|bst
argument_list|,
name|bsh
argument_list|,
name|DINGO_ECOR
argument_list|,
name|DINGO_ECOR_IRQ_LEVEL
operator||
name|DINGO_ECOR_INT_ENABLE
operator||
name|DINGO_ECOR_IOB_ENABLE
operator||
name|DINGO_ECOR_ETH_ENABLE
argument_list|)
expr_stmt|;
name|ioport
operator|=
name|bus_get_resource_start
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
name|sc
operator|->
name|port_rid
argument_list|)
expr_stmt|;
name|bus_space_write_1
argument_list|(
name|bst
argument_list|,
name|bsh
argument_list|,
name|DINGO_EBAR0
argument_list|,
name|ioport
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|bus_space_write_1
argument_list|(
name|bst
argument_list|,
name|bsh
argument_list|,
name|DINGO_EBAR1
argument_list|,
operator|(
name|ioport
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|bus_space_write_1
argument_list|(
name|bst
argument_list|,
name|bsh
argument_list|,
name|DINGO_DCOR0
argument_list|,
name|DINGO_DCOR0_SF_INT
argument_list|)
expr_stmt|;
name|bus_space_write_1
argument_list|(
name|bst
argument_list|,
name|bsh
argument_list|,
name|DINGO_DCOR1
argument_list|,
name|DINGO_DCOR1_INT_LEVEL
operator||
name|DINGO_DCOR1_EEDIO
argument_list|)
expr_stmt|;
name|bus_space_write_1
argument_list|(
name|bst
argument_list|,
name|bsh
argument_list|,
name|DINGO_DCOR2
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
name|bus_space_write_1
argument_list|(
name|bst
argument_list|,
name|bsh
argument_list|,
name|DINGO_DCOR3
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
name|bus_space_write_1
argument_list|(
name|bst
argument_list|,
name|bsh
argument_list|,
name|DINGO_DCOR4
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|rid
argument_list|,
name|r
argument_list|)
expr_stmt|;
comment|/* success! */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * PCMCIA probe routine.  * Probe and identify the device.  Called by the slot manager when the card is   * inserted or the machine wakes up from suspend mode.  Assmes that the slot  * structure has been initialised already.  */
end_comment

begin_function
specifier|static
name|int
name|xe_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|xe_softc
modifier|*
name|scp
init|=
operator|(
expr|struct
name|xe_softc
operator|*
operator|)
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|bus_space_tag_t
name|bst
decl_stmt|;
name|bus_space_handle_t
name|bsh
decl_stmt|;
name|int
name|buf
decl_stmt|;
name|u_char
name|ver_str
index|[
name|CISTPL_BUFSIZE
operator|>>
literal|1
index|]
expr_stmt|;
name|off_t
name|offs
decl_stmt|;
name|int
name|success
decl_stmt|,
name|rc
decl_stmt|,
name|i
decl_stmt|;
name|int
name|rid
decl_stmt|;
name|struct
name|resource
modifier|*
name|r
decl_stmt|;
name|success
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|XE_DEBUG
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"xe: Probing\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Map in the CIS */
name|rid
operator|=
literal|0
expr_stmt|;
name|r
operator|=
name|bus_alloc_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
operator|&
name|rid
argument_list|,
literal|0
argument_list|,
operator|~
literal|0
argument_list|,
literal|4
operator|<<
literal|10
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|r
condition|)
block|{
ifdef|#
directive|ifdef
name|XE_DEBUG
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Can't map in cis\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|ENOMEM
return|;
block|}
name|bsh
operator|=
name|rman_get_bushandle
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|bst
operator|=
name|rman_get_bustag
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|buf
operator|=
literal|0
expr_stmt|;
name|CARD_SET_RES_FLAGS
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|,
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|rid
argument_list|,
name|PCCARD_A_MEM_ATTR
argument_list|)
expr_stmt|;
comment|/* Grep through CIS looking for relevant tuples */
name|offs
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|u_int16_t
name|vendor
decl_stmt|;
name|u_int8_t
name|rev
decl_stmt|,
name|media
decl_stmt|,
name|prod
decl_stmt|;
switch|switch
condition|(
name|CISTPL_TYPE
argument_list|(
name|buf
argument_list|)
condition|)
block|{
case|case
literal|0x15
case|:
comment|/* Grab version string (needed to ID some weird CE2's) */
if|#
directive|if
name|XE_DEBUG
operator|>
literal|1
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Got version string (0x15)\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|CISTPL_LEN
argument_list|(
name|buf
argument_list|)
condition|;
name|ver_str
index|[
name|i
index|]
operator|=
name|CISTPL_DATA
argument_list|(
name|buf
argument_list|,
name|i
operator|++
argument_list|)
control|)
empty_stmt|;
name|ver_str
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
name|ver_str
index|[
operator|(
name|CISTPL_BUFSIZE
operator|>>
literal|1
operator|)
operator|-
literal|1
index|]
operator|=
name|CISTPL_LEN
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|success
operator|++
expr_stmt|;
break|break;
case|case
literal|0x20
case|:
comment|/* Figure out what type of card we have */
if|#
directive|if
name|XE_DEBUG
operator|>
literal|1
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Got card ID (0x20)\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|vendor
operator|=
name|CISTPL_DATA
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|)
operator|+
operator|(
name|CISTPL_DATA
argument_list|(
name|buf
argument_list|,
literal|1
argument_list|)
operator|<<
literal|8
operator|)
expr_stmt|;
name|rev
operator|=
name|CISTPL_DATA
argument_list|(
name|buf
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|media
operator|=
name|CISTPL_DATA
argument_list|(
name|buf
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|prod
operator|=
name|CISTPL_DATA
argument_list|(
name|buf
argument_list|,
literal|4
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|vendor
condition|)
block|{
comment|/* Get vendor ID */
case|case
literal|0x0105
case|:
name|scp
operator|->
name|vendor
operator|=
literal|"Xircom"
expr_stmt|;
break|break;
case|case
literal|0x0138
case|:
case|case
literal|0x0183
case|:
name|scp
operator|->
name|vendor
operator|=
literal|"Compaq"
expr_stmt|;
break|break;
case|case
literal|0x0089
case|:
name|scp
operator|->
name|vendor
operator|=
literal|"Intel"
expr_stmt|;
break|break;
default|default:
name|scp
operator|->
name|vendor
operator|=
literal|"Unknown"
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
operator|(
name|prod
operator|&
literal|0x40
operator|)
operator|&&
operator|(
name|media
operator|&
literal|0x01
operator|)
operator|)
condition|)
block|{
if|#
directive|if
name|XE_DEBUG
operator|>
literal|1
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Not a PCMCIA Ethernet card!\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|rc
operator|=
name|ENODEV
expr_stmt|;
comment|/* Not a PCMCIA Ethernet device */
block|}
else|else
block|{
if|if
condition|(
name|media
operator|&
literal|0x10
condition|)
block|{
comment|/* Ethernet/modem cards */
if|#
directive|if
name|XE_DEBUG
operator|>
literal|1
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Card is Ethernet/modem combo\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|scp
operator|->
name|modem
operator|=
literal|1
expr_stmt|;
switch|switch
condition|(
name|prod
operator|&
literal|0x0f
condition|)
block|{
case|case
literal|1
case|:
name|scp
operator|->
name|card_type
operator|=
literal|"CEM"
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|scp
operator|->
name|ce2
operator|=
literal|1
expr_stmt|;
name|scp
operator|->
name|card_type
operator|=
literal|"CEM2"
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|scp
operator|->
name|ce2
operator|=
literal|1
expr_stmt|;
name|scp
operator|->
name|card_type
operator|=
literal|"CEM3"
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|scp
operator|->
name|ce2
operator|=
literal|1
expr_stmt|;
name|scp
operator|->
name|card_type
operator|=
literal|"CEM33"
expr_stmt|;
break|break;
case|case
literal|5
case|:
name|scp
operator|->
name|mohawk
operator|=
literal|1
expr_stmt|;
name|scp
operator|->
name|card_type
operator|=
literal|"CEM56M"
expr_stmt|;
break|break;
case|case
literal|6
case|:
case|case
literal|7
case|:
comment|/* Some kind of RealPort card */
name|scp
operator|->
name|mohawk
operator|=
literal|1
expr_stmt|;
name|scp
operator|->
name|dingo
operator|=
literal|1
expr_stmt|;
name|scp
operator|->
name|card_type
operator|=
literal|"CEM56"
expr_stmt|;
break|break;
default|default:
name|rc
operator|=
name|ENODEV
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Ethernet-only cards */
if|#
directive|if
name|XE_DEBUG
operator|>
literal|1
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Card is Ethernet only\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|prod
operator|&
literal|0x0f
condition|)
block|{
case|case
literal|1
case|:
name|scp
operator|->
name|card_type
operator|=
literal|"CE"
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|scp
operator|->
name|ce2
operator|=
literal|1
expr_stmt|;
name|scp
operator|->
name|card_type
operator|=
literal|"CE2"
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|scp
operator|->
name|mohawk
operator|=
literal|1
expr_stmt|;
name|scp
operator|->
name|card_type
operator|=
literal|"CE3"
expr_stmt|;
break|break;
default|default:
name|rc
operator|=
name|ENODEV
expr_stmt|;
block|}
block|}
block|}
name|success
operator|++
expr_stmt|;
break|break;
case|case
literal|0x22
case|:
comment|/* Get MAC address */
if|if
condition|(
operator|(
name|CISTPL_LEN
argument_list|(
name|buf
argument_list|)
operator|==
literal|8
operator|)
operator|&&
operator|(
name|CISTPL_DATA
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|)
operator|==
literal|0x04
operator|)
operator|&&
operator|(
name|CISTPL_DATA
argument_list|(
name|buf
argument_list|,
literal|1
argument_list|)
operator|==
name|ETHER_ADDR_LEN
operator|)
condition|)
block|{
if|#
directive|if
name|XE_DEBUG
operator|>
literal|1
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Got MAC address (0x22)\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ETHER_ADDR_LEN
condition|;
name|i
operator|++
control|)
name|scp
operator|->
name|arpcom
operator|.
name|ac_enaddr
index|[
name|i
index|]
operator|=
name|CISTPL_DATA
argument_list|(
name|buf
argument_list|,
name|i
operator|+
literal|2
argument_list|)
expr_stmt|;
block|}
name|success
operator|++
expr_stmt|;
break|break;
default|default:
break|break;
block|}
if|if
condition|(
name|CISTPL_TYPE
argument_list|(
name|buf
argument_list|)
operator|==
literal|0xff
condition|)
break|break;
comment|/* Skip to next tuple */
name|buf
operator|+=
operator|(
operator|(
name|CISTPL_LEN
argument_list|(
name|buf
argument_list|)
operator|+
literal|2
operator|)
operator|<<
literal|1
operator|)
expr_stmt|;
block|}
do|while
condition|(
literal|1
condition|)
do|;
comment|/* unmap the cis */
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|rid
argument_list|,
name|r
argument_list|)
expr_stmt|;
comment|/* Die now if something went wrong above */
if|if
condition|(
name|success
operator|<
literal|3
condition|)
return|return
name|ENXIO
return|;
comment|/* Check for certain strange CE2's that look like CE's */
if|if
condition|(
name|strcmp
argument_list|(
name|scp
operator|->
name|card_type
argument_list|,
literal|"CE"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|u_char
modifier|*
name|str
init|=
name|ver_str
decl_stmt|;
if|#
directive|if
name|XE_DEBUG
operator|>
literal|1
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Checking for weird CE2 string\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|str
operator|+=
name|strlen
argument_list|(
name|str
argument_list|)
operator|+
literal|1
expr_stmt|;
comment|/* Skip forward to 3rd version string */
name|str
operator|+=
name|strlen
argument_list|(
name|str
argument_list|)
operator|+
literal|1
expr_stmt|;
name|str
operator|+=
name|strlen
argument_list|(
name|str
argument_list|)
operator|+
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|strlen
argument_list|(
name|str
argument_list|)
operator|-
literal|2
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|bcmp
argument_list|(
operator|&
name|str
index|[
name|i
index|]
argument_list|,
literal|"CE2"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Look for "CE2" string */
name|scp
operator|->
name|card_type
operator|=
literal|"CE2"
expr_stmt|;
block|}
block|}
block|}
comment|/* Reject unsupported cards */
if|if
condition|(
name|strcmp
argument_list|(
name|scp
operator|->
name|card_type
argument_list|,
literal|"CE"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|scp
operator|->
name|card_type
argument_list|,
literal|"CEM"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Sorry, your %s card is not supported :(\n"
argument_list|,
name|scp
operator|->
name|card_type
argument_list|)
expr_stmt|;
return|return
name|ENODEV
return|;
block|}
comment|/* Success */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * The device entry is being removed, probably because someone ejected the  * card.  The interface should have been brought down manually before calling  * this function; if not you may well lose packets.  In any case, I shut down  * the card and the interface, and hope for the best.  */
end_comment

begin_function
specifier|static
name|int
name|xe_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|xe_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_flags
operator|&=
operator|~
name|IFF_RUNNING
expr_stmt|;
name|ether_ifdetach
argument_list|(
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
argument_list|,
name|ETHER_BPF_SUPPORTED
argument_list|)
expr_stmt|;
name|xe_deactivate
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Attach a device.  */
end_comment

begin_function
specifier|static
name|int
name|xe_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|xe_softc
modifier|*
name|scp
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|err
decl_stmt|;
ifdef|#
directive|ifdef
name|XE_DEBUG
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"attach\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|err
operator|=
name|xe_activate
argument_list|(
name|dev
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|err
operator|)
return|;
comment|/* Fill in some private data */
name|scp
operator|->
name|ifp
operator|=
operator|&
name|scp
operator|->
name|arpcom
operator|.
name|ac_if
expr_stmt|;
name|scp
operator|->
name|ifm
operator|=
operator|&
name|scp
operator|->
name|ifmedia
expr_stmt|;
name|scp
operator|->
name|autoneg_status
operator|=
literal|0
expr_stmt|;
comment|/* Hack RealPorts into submission */
if|if
condition|(
name|scp
operator|->
name|dingo
operator|&&
name|xe_cem56fix
argument_list|(
name|dev
argument_list|)
operator|<
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unable to fix your RealPort\n"
argument_list|)
expr_stmt|;
name|xe_deactivate
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
name|ENODEV
return|;
block|}
comment|/* Hopefully safe to read this here */
name|XE_SELECT_PAGE
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|scp
operator|->
name|version
operator|=
name|XE_INB
argument_list|(
name|XE_BOV
argument_list|)
expr_stmt|;
name|scp
operator|->
name|dev
operator|=
name|dev
expr_stmt|;
comment|/* Initialise the ifnet structure */
if|if
condition|(
operator|!
name|scp
operator|->
name|ifp
operator|->
name|if_name
condition|)
block|{
name|scp
operator|->
name|ifp
operator|->
name|if_softc
operator|=
name|scp
expr_stmt|;
name|scp
operator|->
name|ifp
operator|->
name|if_name
operator|=
literal|"xe"
expr_stmt|;
name|scp
operator|->
name|ifp
operator|->
name|if_unit
operator|=
name|device_get_unit
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|scp
operator|->
name|ifp
operator|->
name|if_timer
operator|=
literal|0
expr_stmt|;
name|scp
operator|->
name|ifp
operator|->
name|if_flags
operator|=
operator|(
name|IFF_BROADCAST
operator||
name|IFF_SIMPLEX
operator||
name|IFF_MULTICAST
operator|)
expr_stmt|;
name|scp
operator|->
name|ifp
operator|->
name|if_linkmib
operator|=
operator|&
name|scp
operator|->
name|mibdata
expr_stmt|;
name|scp
operator|->
name|ifp
operator|->
name|if_linkmiblen
operator|=
sizeof|sizeof
name|scp
operator|->
name|mibdata
expr_stmt|;
name|scp
operator|->
name|ifp
operator|->
name|if_output
operator|=
name|ether_output
expr_stmt|;
name|scp
operator|->
name|ifp
operator|->
name|if_start
operator|=
name|xe_start
expr_stmt|;
name|scp
operator|->
name|ifp
operator|->
name|if_ioctl
operator|=
name|xe_ioctl
expr_stmt|;
name|scp
operator|->
name|ifp
operator|->
name|if_watchdog
operator|=
name|xe_watchdog
expr_stmt|;
name|scp
operator|->
name|ifp
operator|->
name|if_init
operator|=
name|xe_init
expr_stmt|;
name|scp
operator|->
name|ifp
operator|->
name|if_snd
operator|.
name|ifq_maxlen
operator|=
name|IFQ_MAXLEN
expr_stmt|;
block|}
comment|/* Initialise the ifmedia structure */
name|ifmedia_init
argument_list|(
name|scp
operator|->
name|ifm
argument_list|,
literal|0
argument_list|,
name|xe_media_change
argument_list|,
name|xe_media_status
argument_list|)
expr_stmt|;
name|callout_handle_init
argument_list|(
operator|&
name|scp
operator|->
name|chand
argument_list|)
expr_stmt|;
comment|/*    * Fill in supported media types.  Some cards _do_ support full duplex    * operation, but this driver doesn't, yet.  Therefore we leave those modes    * out of the list.  We support some form of autoselection in all cases.    */
if|if
condition|(
name|scp
operator|->
name|mohawk
condition|)
block|{
name|ifmedia_add
argument_list|(
name|scp
operator|->
name|ifm
argument_list|,
name|IFM_ETHER
operator||
name|IFM_100_TX
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ifmedia_add
argument_list|(
name|scp
operator|->
name|ifm
argument_list|,
name|IFM_ETHER
operator||
name|IFM_10_T
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ifmedia_add
argument_list|(
name|scp
operator|->
name|ifm
argument_list|,
name|IFM_ETHER
operator||
name|IFM_10_T
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ifmedia_add
argument_list|(
name|scp
operator|->
name|ifm
argument_list|,
name|IFM_ETHER
operator||
name|IFM_10_2
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
name|ifmedia_add
argument_list|(
name|scp
operator|->
name|ifm
argument_list|,
name|IFM_ETHER
operator||
name|IFM_AUTO
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Default is to autoselect best supported media type */
name|ifmedia_set
argument_list|(
name|scp
operator|->
name|ifm
argument_list|,
name|IFM_ETHER
operator||
name|IFM_AUTO
argument_list|)
expr_stmt|;
comment|/* Print some useful information */
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"%s %s, bonding version %#x%s%s\n"
argument_list|,
name|scp
operator|->
name|vendor
argument_list|,
name|scp
operator|->
name|card_type
argument_list|,
name|scp
operator|->
name|version
argument_list|,
name|scp
operator|->
name|mohawk
condition|?
literal|", 100Mbps capable"
else|:
literal|""
argument_list|,
name|scp
operator|->
name|modem
condition|?
literal|", with modem"
else|:
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|scp
operator|->
name|mohawk
condition|)
block|{
name|XE_SELECT_PAGE
argument_list|(
literal|0x10
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"DingoID = %#x, RevisionID = %#x, VendorID = %#x\n"
argument_list|,
name|XE_INW
argument_list|(
name|XE_DINGOID
argument_list|)
argument_list|,
name|XE_INW
argument_list|(
name|XE_RevID
argument_list|)
argument_list|,
name|XE_INW
argument_list|(
name|XE_VendorID
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|scp
operator|->
name|ce2
condition|)
block|{
name|XE_SELECT_PAGE
argument_list|(
literal|0x45
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"CE2 version = %#x\n"
argument_list|,
name|XE_INB
argument_list|(
name|XE_REV
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Print MAC address */
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Ethernet address %6D\n"
argument_list|,
name|scp
operator|->
name|arpcom
operator|.
name|ac_enaddr
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
comment|/* Attach the interface */
name|ether_ifattach
argument_list|(
name|scp
operator|->
name|ifp
argument_list|,
name|ETHER_BPF_SUPPORTED
argument_list|)
expr_stmt|;
comment|/* Done */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Initialize device.  Completes the reset procedure on the card and starts  * output.  If there's an autonegotiation in progress we DON'T do anything;  * the media selection code will call us again when it's done.  */
end_comment

begin_function
specifier|static
name|void
name|xe_init
parameter_list|(
name|void
modifier|*
name|xscp
parameter_list|)
block|{
name|struct
name|xe_softc
modifier|*
name|scp
init|=
name|xscp
decl_stmt|;
name|int
name|s
decl_stmt|;
ifdef|#
directive|ifdef
name|XE_DEBUG
name|device_printf
argument_list|(
name|scp
operator|->
name|dev
argument_list|,
literal|"init\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|scp
operator|->
name|ifp
operator|->
name|if_addrhead
argument_list|)
condition|)
return|return;
comment|/* Reset transmitter flags */
name|scp
operator|->
name|tx_queued
operator|=
literal|0
expr_stmt|;
name|scp
operator|->
name|tx_tpr
operator|=
literal|0
expr_stmt|;
name|scp
operator|->
name|tx_collisions
operator|=
literal|0
expr_stmt|;
name|scp
operator|->
name|ifp
operator|->
name|if_timer
operator|=
literal|0
expr_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|XE_SELECT_PAGE
argument_list|(
literal|0x42
argument_list|)
expr_stmt|;
name|XE_OUTB
argument_list|(
name|XE_SWC0
argument_list|,
literal|0x20
argument_list|)
expr_stmt|;
comment|/* Disable source insertion (WTF is that?) */
comment|/*    * Set the 'local memory dividing line' -- splits the 32K card memory into    * 8K for transmit buffers and 24K for receive.  This is done automatically    * on newer revision cards.    */
if|if
condition|(
name|scp
operator|->
name|srev
operator|!=
literal|1
condition|)
block|{
name|XE_SELECT_PAGE
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|XE_OUTW
argument_list|(
name|XE_RBS
argument_list|,
literal|0x2000
argument_list|)
expr_stmt|;
block|}
comment|/* Set up multicast addresses */
name|xe_setmulti
argument_list|(
name|scp
argument_list|)
expr_stmt|;
comment|/* Fix the data offset register -- reset leaves it off-by-one */
name|XE_SELECT_PAGE
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|XE_OUTW
argument_list|(
name|XE_DO
argument_list|,
literal|0x2000
argument_list|)
expr_stmt|;
comment|/*    * Set MAC interrupt masks and clear status regs.  The bit names are direct    * from the Linux code; I have no idea what most of them do.    */
name|XE_SELECT_PAGE
argument_list|(
literal|0x40
argument_list|)
expr_stmt|;
comment|/* Bit 7..0 */
name|XE_OUTB
argument_list|(
name|XE_RX0Msk
argument_list|,
literal|0xff
argument_list|)
expr_stmt|;
comment|/* ROK, RAB, rsv, RO,  CRC, AE,  PTL, MP  */
name|XE_OUTB
argument_list|(
name|XE_TX0Msk
argument_list|,
literal|0xff
argument_list|)
expr_stmt|;
comment|/* TOK, TAB, SQE, LL,  TU,  JAB, EXC, CRS */
name|XE_OUTB
argument_list|(
name|XE_TX0Msk
operator|+
literal|1
argument_list|,
literal|0xb0
argument_list|)
expr_stmt|;
comment|/* rsv, rsv, PTD, EXT, rsv, rsv, rsv, rsv */
name|XE_OUTB
argument_list|(
name|XE_RST0
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
comment|/* ROK, RAB, REN, RO,  CRC, AE,  PTL, MP  */
name|XE_OUTB
argument_list|(
name|XE_TXST0
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
comment|/* TOK, TAB, SQE, LL,  TU,  JAB, EXC, CRS */
name|XE_OUTB
argument_list|(
name|XE_TXST1
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
comment|/* TEN, rsv, PTD, EXT, retry_counter:4    */
comment|/*    * Check for an in-progress autonegotiation.  If one is active, just set    * IFF_RUNNING and return.  The media selection code will call us again when     * it's done.    */
if|if
condition|(
name|scp
operator|->
name|autoneg_status
condition|)
block|{
name|scp
operator|->
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_RUNNING
expr_stmt|;
block|}
else|else
block|{
comment|/* Enable receiver, put MAC online */
name|XE_SELECT_PAGE
argument_list|(
literal|0x40
argument_list|)
expr_stmt|;
name|XE_OUTB
argument_list|(
name|XE_CMD0
argument_list|,
name|XE_CMD0_RX_ENABLE
operator||
name|XE_CMD0_ONLINE
argument_list|)
expr_stmt|;
comment|/* Set up IMR, enable interrupts */
name|xe_enable_intr
argument_list|(
name|scp
argument_list|)
expr_stmt|;
comment|/* Attempt to start output */
name|scp
operator|->
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_RUNNING
expr_stmt|;
name|scp
operator|->
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
name|IFF_OACTIVE
expr_stmt|;
name|xe_start
argument_list|(
name|scp
operator|->
name|ifp
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Start output on interface.  We make two assumptions here:  *  1) that the current priority is set to splimp _before_ this code  *     is called *and* is returned to the appropriate priority after  *     return  *  2) that the IFF_OACTIVE flag is checked before this code is called  *     (i.e. that the output part of the interface is idle)  */
end_comment

begin_function
specifier|static
name|void
name|xe_start
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|xe_softc
modifier|*
name|scp
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|mbp
decl_stmt|;
comment|/*    * Loop while there are packets to be sent, and space to send them.    */
while|while
condition|(
literal|1
condition|)
block|{
name|IF_DEQUEUE
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|mbp
argument_list|)
expr_stmt|;
comment|/* Suck a packet off the send queue */
if|if
condition|(
name|mbp
operator|==
name|NULL
condition|)
block|{
comment|/*        * We are using the !OACTIVE flag to indicate to the outside world that        * we can accept an additional packet rather than that the transmitter        * is _actually_ active. Indeed, the transmitter may be active, but if        * we haven't filled all the buffers with data then we still want to        * accept more.        */
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
name|IFF_OACTIVE
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|xe_pio_write_packet
argument_list|(
name|scp
argument_list|,
name|mbp
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|IF_PREPEND
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|mbp
argument_list|)
expr_stmt|;
comment|/* Push the packet back onto the queue */
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_OACTIVE
expr_stmt|;
return|return;
block|}
comment|/* Tap off here if there is a bpf listener */
if|if
condition|(
name|ifp
operator|->
name|if_bpf
condition|)
block|{
if|#
directive|if
name|XE_DEBUG
operator|>
literal|1
name|device_printf
argument_list|(
name|scp
operator|->
name|dev
argument_list|,
literal|"sending output packet to BPF\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|bpf_mtap
argument_list|(
name|ifp
argument_list|,
name|mbp
argument_list|)
expr_stmt|;
block|}
name|ifp
operator|->
name|if_timer
operator|=
literal|5
expr_stmt|;
comment|/* In case we don't hear from the card again */
name|scp
operator|->
name|tx_queued
operator|++
expr_stmt|;
name|m_freem
argument_list|(
name|mbp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Process an ioctl request.  Adapted from the ed driver.  */
end_comment

begin_function
specifier|static
name|int
name|xe_ioctl
parameter_list|(
specifier|register
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|u_long
name|command
parameter_list|,
name|caddr_t
name|data
parameter_list|)
block|{
name|struct
name|xe_softc
modifier|*
name|scp
decl_stmt|;
name|int
name|s
decl_stmt|,
name|error
decl_stmt|;
name|scp
operator|=
name|ifp
operator|->
name|if_softc
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|command
condition|)
block|{
case|case
name|SIOCSIFADDR
case|:
case|case
name|SIOCGIFADDR
case|:
case|case
name|SIOCSIFMTU
case|:
name|error
operator|=
name|ether_ioctl
argument_list|(
name|ifp
argument_list|,
name|command
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCSIFFLAGS
case|:
comment|/*      * If the interface is marked up and stopped, then start it.  If it is      * marked down and running, then stop it.      */
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
operator|)
condition|)
block|{
name|xe_hard_reset
argument_list|(
name|scp
argument_list|)
expr_stmt|;
name|xe_setmedia
argument_list|(
name|scp
argument_list|)
expr_stmt|;
name|xe_init
argument_list|(
name|scp
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
condition|)
name|xe_stop
argument_list|(
name|scp
argument_list|)
expr_stmt|;
block|}
case|case
name|SIOCADDMULTI
case|:
case|case
name|SIOCDELMULTI
case|:
comment|/*      * Multicast list has (maybe) changed; set the hardware filter      * accordingly.  This also serves to deal with promiscuous mode if we have       * a BPF listener active.      */
name|xe_setmulti
argument_list|(
name|scp
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|SIOCSIFMEDIA
case|:
case|case
name|SIOCGIFMEDIA
case|:
comment|/*      * Someone wants to get/set media options.      */
name|error
operator|=
name|ifmedia_ioctl
argument_list|(
name|ifp
argument_list|,
operator|(
expr|struct
name|ifreq
operator|*
operator|)
name|data
argument_list|,
operator|&
name|scp
operator|->
name|ifmedia
argument_list|,
name|command
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  * Card interrupt handler.  *  * This function is probably more complicated than it needs to be, as it  * attempts to deal with the case where multiple packets get sent between  * interrupts.  This is especially annoying when working out the collision  * stats.  Not sure whether this case ever really happens or not (maybe on a  * slow/heavily loaded machine?) so it's probably best to leave this like it  * is.  *  * Note that the crappy PIO used to get packets on and off the card means that   * you will spend a lot of time in this routine -- I can get my P150 to spend  * 90% of its time servicing interrupts if I really hammer the network.  Could   * fix this, but then you'd start dropping/losing packets.  The moral of this  * story?  If you want good network performance _and_ some cycles left over to   * get your work done, don't buy a Xircom card.  Or convince them to tell me  * how to do memory-mapped I/O :)  */
end_comment

begin_function
specifier|static
name|void
name|xe_intr
parameter_list|(
name|void
modifier|*
name|xscp
parameter_list|)
block|{
name|struct
name|xe_softc
modifier|*
name|scp
init|=
operator|(
expr|struct
name|xe_softc
operator|*
operator|)
name|xscp
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|int
name|result
decl_stmt|;
name|u_int16_t
name|rx_bytes
decl_stmt|,
name|rxs
decl_stmt|,
name|txs
decl_stmt|;
name|u_int8_t
name|psr
decl_stmt|,
name|isr
decl_stmt|,
name|esr
decl_stmt|,
name|rsr
decl_stmt|;
name|ifp
operator|=
operator|&
name|scp
operator|->
name|arpcom
operator|.
name|ac_if
expr_stmt|;
name|rx_bytes
operator|=
literal|0
expr_stmt|;
comment|/* Bytes received on this interrupt */
name|result
operator|=
literal|0
expr_stmt|;
comment|/* Set true if the interrupt is for us */
if|if
condition|(
name|scp
operator|->
name|mohawk
condition|)
block|{
name|XE_OUTB
argument_list|(
name|XE_CR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Disable interrupts */
block|}
name|psr
operator|=
name|XE_INB
argument_list|(
name|XE_PR
argument_list|)
expr_stmt|;
comment|/* Stash the current register page */
comment|/*    * Read ISR to see what caused this interrupt.  Note that this clears the    * ISR on CE2 type cards.    */
if|if
condition|(
operator|(
name|isr
operator|=
name|XE_INB
argument_list|(
name|XE_ISR
argument_list|)
operator|)
operator|&&
name|isr
operator|!=
literal|0xff
condition|)
block|{
name|result
operator|=
literal|1
expr_stmt|;
comment|/* This device did generate an int */
name|esr
operator|=
name|XE_INB
argument_list|(
name|XE_ESR
argument_list|)
expr_stmt|;
comment|/* Read the other status registers */
name|XE_SELECT_PAGE
argument_list|(
literal|0x40
argument_list|)
expr_stmt|;
name|rxs
operator|=
name|XE_INB
argument_list|(
name|XE_RST0
argument_list|)
expr_stmt|;
name|XE_OUTB
argument_list|(
name|XE_RST0
argument_list|,
operator|~
name|rxs
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|txs
operator|=
name|XE_INB
argument_list|(
name|XE_TXST0
argument_list|)
expr_stmt|;
name|txs
operator||=
name|XE_INB
argument_list|(
name|XE_TXST1
argument_list|)
operator|<<
literal|8
expr_stmt|;
name|XE_OUTB
argument_list|(
name|XE_TXST0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|XE_OUTB
argument_list|(
name|XE_TXST1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|XE_SELECT_PAGE
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|#
directive|if
name|XE_DEBUG
operator|>
literal|2
name|printf
argument_list|(
literal|"xe%d: ISR=%#2.2x ESR=%#2.2x RST=%#2.2x TXST=%#4.4x\n"
argument_list|,
name|unit
argument_list|,
name|isr
argument_list|,
name|esr
argument_list|,
name|rxs
argument_list|,
name|txs
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*      * Handle transmit interrupts      */
if|if
condition|(
name|isr
operator|&
name|XE_ISR_TX_PACKET
condition|)
block|{
name|u_int8_t
name|new_tpr
decl_stmt|,
name|sent
decl_stmt|;
if|if
condition|(
operator|(
name|new_tpr
operator|=
name|XE_INB
argument_list|(
name|XE_TPR
argument_list|)
operator|)
operator|<
name|scp
operator|->
name|tx_tpr
condition|)
comment|/* Update packet count */
name|sent
operator|=
operator|(
literal|0xff
operator|-
name|scp
operator|->
name|tx_tpr
operator|)
operator|+
name|new_tpr
expr_stmt|;
comment|/* TPR rolled over */
else|else
name|sent
operator|=
name|new_tpr
operator|-
name|scp
operator|->
name|tx_tpr
expr_stmt|;
if|if
condition|(
name|sent
operator|>
literal|0
condition|)
block|{
comment|/* Packets sent since last interrupt */
name|scp
operator|->
name|tx_tpr
operator|=
name|new_tpr
expr_stmt|;
name|scp
operator|->
name|tx_queued
operator|-=
name|sent
expr_stmt|;
name|ifp
operator|->
name|if_opackets
operator|+=
name|sent
expr_stmt|;
name|ifp
operator|->
name|if_collisions
operator|+=
name|scp
operator|->
name|tx_collisions
expr_stmt|;
comment|/* 	 * Collision stats are a PITA.  If multiples frames have been sent, we  	 * distribute any outstanding collision count equally amongst them. 	 * However, if we're missing interrupts we're quite likely to also 	 * miss some collisions; thus the total count will be off anyway. 	 * Likewise, if we miss a frame dropped due to excessive collisions 	 * any outstanding collisions count will be held against the next 	 * frame to be successfully sent.  Hopefully it averages out in the 	 * end! 	 * XXX - This will screw up if tx_collisions/sent> 14. FIX IT! 	 */
switch|switch
condition|(
name|scp
operator|->
name|tx_collisions
condition|)
block|{
case|case
literal|0
case|:
break|break;
case|case
literal|1
case|:
name|scp
operator|->
name|mibdata
operator|.
name|dot3StatsSingleCollisionFrames
operator|++
expr_stmt|;
name|scp
operator|->
name|mibdata
operator|.
name|dot3StatsCollFrequencies
index|[
literal|0
index|]
operator|++
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|sent
operator|==
literal|1
condition|)
block|{
name|scp
operator|->
name|mibdata
operator|.
name|dot3StatsMultipleCollisionFrames
operator|++
expr_stmt|;
name|scp
operator|->
name|mibdata
operator|.
name|dot3StatsCollFrequencies
index|[
name|scp
operator|->
name|tx_collisions
operator|-
literal|1
index|]
operator|++
expr_stmt|;
block|}
else|else
block|{
comment|/* Distribute across multiple frames */
name|scp
operator|->
name|mibdata
operator|.
name|dot3StatsMultipleCollisionFrames
operator|+=
name|sent
expr_stmt|;
name|scp
operator|->
name|mibdata
operator|.
name|dot3StatsCollFrequencies
index|[
name|scp
operator|->
name|tx_collisions
operator|/
name|sent
index|]
operator|+=
name|sent
operator|-
name|scp
operator|->
name|tx_collisions
operator|%
name|sent
expr_stmt|;
name|scp
operator|->
name|mibdata
operator|.
name|dot3StatsCollFrequencies
index|[
name|scp
operator|->
name|tx_collisions
operator|/
name|sent
operator|+
literal|1
index|]
operator|+=
name|scp
operator|->
name|tx_collisions
operator|%
name|sent
expr_stmt|;
block|}
block|}
name|scp
operator|->
name|tx_collisions
operator|=
literal|0
expr_stmt|;
block|}
name|ifp
operator|->
name|if_timer
operator|=
literal|0
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
name|IFF_OACTIVE
expr_stmt|;
block|}
if|if
condition|(
name|txs
operator|&
literal|0x0002
condition|)
block|{
comment|/* Excessive collisions (packet dropped) */
name|ifp
operator|->
name|if_collisions
operator|+=
literal|16
expr_stmt|;
name|ifp
operator|->
name|if_oerrors
operator|++
expr_stmt|;
name|scp
operator|->
name|tx_collisions
operator|=
literal|0
expr_stmt|;
name|scp
operator|->
name|mibdata
operator|.
name|dot3StatsExcessiveCollisions
operator|++
expr_stmt|;
name|scp
operator|->
name|mibdata
operator|.
name|dot3StatsMultipleCollisionFrames
operator|++
expr_stmt|;
name|scp
operator|->
name|mibdata
operator|.
name|dot3StatsCollFrequencies
index|[
literal|15
index|]
operator|++
expr_stmt|;
name|XE_OUTB
argument_list|(
name|XE_CR
argument_list|,
name|XE_CR_RESTART_TX
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|txs
operator|&
literal|0x0040
condition|)
comment|/* Transmit aborted -- probably collisions */
name|scp
operator|->
name|tx_collisions
operator|++
expr_stmt|;
comment|/*      * Handle receive interrupts       */
while|while
condition|(
operator|(
name|esr
operator|=
name|XE_INB
argument_list|(
name|XE_ESR
argument_list|)
operator|)
operator|&
name|XE_ESR_FULL_PACKET_RX
condition|)
block|{
if|if
condition|(
operator|(
name|rsr
operator|=
name|XE_INB
argument_list|(
name|XE_RSR
argument_list|)
operator|)
operator|&
name|XE_RSR_RX_OK
condition|)
block|{
name|struct
name|ether_header
modifier|*
name|ehp
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|mbp
decl_stmt|;
name|u_int16_t
name|len
decl_stmt|;
name|len
operator|=
name|XE_INW
argument_list|(
name|XE_RBC
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
continue|continue;
if|#
directive|if
literal|0
comment|/* 	 * Limit the amount of time we spend in this loop, dropping packets if  	 * necessary.  The Linux code does this with considerably more 	 * finesse, adjusting the threshold dynamically. 	 */
block|if ((rx_bytes += len)> 22000) { 	  ifp->if_iqdrops++; 	  scp->mibData.dot3StatsMissedFrames++; 	  XE_OUTW(XE_DO, 0x8000); 	  continue; 	}
endif|#
directive|endif
if|if
condition|(
name|len
operator|&
literal|0x01
condition|)
name|len
operator|++
expr_stmt|;
name|MGETHDR
argument_list|(
name|mbp
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
comment|/* Allocate a header mbuf */
if|if
condition|(
name|mbp
operator|!=
name|NULL
condition|)
block|{
name|mbp
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|ifp
expr_stmt|;
name|mbp
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|mbp
operator|->
name|m_len
operator|=
name|len
expr_stmt|;
comment|/* 	   * If the mbuf header isn't big enough for the packet, attach an 	   * mbuf cluster to hold it.  The +2 is to allow for the nasty little  	   * alignment hack below. 	   */
if|if
condition|(
name|len
operator|+
literal|2
operator|>
name|MHLEN
condition|)
block|{
name|MCLGET
argument_list|(
name|mbp
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|mbp
operator|->
name|m_flags
operator|&
name|M_EXT
operator|)
operator|==
literal|0
condition|)
block|{
name|m_freem
argument_list|(
name|mbp
argument_list|)
expr_stmt|;
name|mbp
operator|=
name|NULL
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|mbp
operator|!=
name|NULL
condition|)
block|{
comment|/* 	   * The Ethernet header is 14 bytes long; thus the actual packet data  	   * won't be 32-bit aligned when it's dumped into the mbuf.  We 	   * offset everything by 2 bytes to fix this.  Apparently the 	   * alignment is important for NFS, damn its eyes. 	   */
name|mbp
operator|->
name|m_data
operator|+=
literal|2
expr_stmt|;
name|ehp
operator|=
name|mtod
argument_list|(
name|mbp
argument_list|,
expr|struct
name|ether_header
operator|*
argument_list|)
expr_stmt|;
comment|/* 	   * Now get the packet, including the Ethernet header and trailer (?) 	   * We use programmed I/O, because we don't know how to do shared 	   * memory with these cards.  So yes, it's real slow, and heavy on 	   * the interrupts (CPU on my P150 maxed out at ~950KBps incoming). 	   */
if|if
condition|(
name|scp
operator|->
name|srev
operator|==
literal|0
condition|)
block|{
comment|/* Workaround a bug in old cards */
name|u_short
name|rhs
decl_stmt|;
name|XE_SELECT_PAGE
argument_list|(
literal|5
argument_list|)
expr_stmt|;
name|rhs
operator|=
name|XE_INW
argument_list|(
name|XE_RHSA
argument_list|)
expr_stmt|;
name|XE_SELECT_PAGE
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|rhs
operator|+=
literal|3
expr_stmt|;
comment|/* Skip control info */
if|if
condition|(
name|rhs
operator|>=
literal|0x8000
condition|)
name|rhs
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|rhs
operator|+
name|len
operator|>
literal|0x8000
condition|)
block|{
name|int
name|i
decl_stmt|;
comment|/* 	       * XXX - This i-- seems very wrong, but it's what the Linux guys  	       * XXX - do.  Need someone with an old CE2 to test this for me. 	       * XXX - 99/3/28: Changed the first i-- to an i++, maybe that'll 	       * XXX - fix it?  It seems as though the previous version would 	       * XXX - have caused an infinite loop (what, another one?). 	       */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
operator|,
name|rhs
operator|++
control|)
block|{
operator|(
operator|(
name|char
operator|*
operator|)
name|ehp
operator|)
index|[
name|i
index|]
operator|=
name|XE_INB
argument_list|(
name|XE_EDP
argument_list|)
expr_stmt|;
if|if
condition|(
name|rhs
operator|==
literal|0x8000
condition|)
block|{
name|rhs
operator|=
literal|0
expr_stmt|;
name|i
operator|--
expr_stmt|;
block|}
block|}
block|}
else|else
name|bus_space_read_multi_2
argument_list|(
name|scp
operator|->
name|bst
argument_list|,
name|scp
operator|->
name|bsh
argument_list|,
name|XE_EDP
argument_list|,
operator|(
name|u_int16_t
operator|*
operator|)
name|ehp
argument_list|,
name|len
operator|>>
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
name|bus_space_read_multi_2
argument_list|(
name|scp
operator|->
name|bst
argument_list|,
name|scp
operator|->
name|bsh
argument_list|,
name|XE_EDP
argument_list|,
operator|(
name|u_int16_t
operator|*
operator|)
name|ehp
argument_list|,
name|len
operator|>>
literal|1
argument_list|)
expr_stmt|;
comment|/* Deliver packet to upper layers */
if|if
condition|(
name|mbp
operator|!=
name|NULL
condition|)
block|{
name|mbp
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|mbp
operator|->
name|m_len
operator|=
name|len
operator|-
name|ETHER_HDR_LEN
expr_stmt|;
name|mbp
operator|->
name|m_data
operator|+=
name|ETHER_HDR_LEN
expr_stmt|;
comment|/* Strip off Ethernet header */
name|ether_input
argument_list|(
name|ifp
argument_list|,
name|ehp
argument_list|,
name|mbp
argument_list|)
expr_stmt|;
comment|/* Send the packet on its way */
name|ifp
operator|->
name|if_ipackets
operator|++
expr_stmt|;
comment|/* Success! */
block|}
name|XE_OUTW
argument_list|(
name|XE_DO
argument_list|,
literal|0x8000
argument_list|)
expr_stmt|;
comment|/* skip_rx_packet command */
block|}
block|}
elseif|else
if|if
condition|(
name|rsr
operator|&
name|XE_RSR_LONG_PACKET
condition|)
block|{
comment|/* Packet length>1518 bytes */
name|scp
operator|->
name|mibdata
operator|.
name|dot3StatsFrameTooLongs
operator|++
expr_stmt|;
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rsr
operator|&
name|XE_RSR_CRC_ERROR
condition|)
block|{
comment|/* Bad checksum on packet */
name|scp
operator|->
name|mibdata
operator|.
name|dot3StatsFCSErrors
operator|++
expr_stmt|;
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rsr
operator|&
name|XE_RSR_ALIGN_ERROR
condition|)
block|{
comment|/* Packet alignment error */
name|scp
operator|->
name|mibdata
operator|.
name|dot3StatsAlignmentErrors
operator|++
expr_stmt|;
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|rxs
operator|&
literal|0x10
condition|)
block|{
comment|/* Receiver overrun */
name|scp
operator|->
name|mibdata
operator|.
name|dot3StatsInternalMacReceiveErrors
operator|++
expr_stmt|;
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
name|XE_OUTB
argument_list|(
name|XE_CR
argument_list|,
name|XE_CR_CLEAR_OVERRUN
argument_list|)
expr_stmt|;
block|}
block|}
name|XE_SELECT_PAGE
argument_list|(
name|psr
argument_list|)
expr_stmt|;
comment|/* Restore saved page */
name|XE_OUTB
argument_list|(
name|XE_CR
argument_list|,
name|XE_CR_ENABLE_INTR
argument_list|)
expr_stmt|;
comment|/* Re-enable interrupts */
comment|/* Could force an int here, instead of dropping packets? */
comment|/* XE_OUTB(XE_CR, XE_CR_ENABLE_INTR|XE_CE_FORCE_INTR); */
return|return;
block|}
end_function

begin_comment
comment|/*  * Device timeout/watchdog routine.  Called automatically if we queue a packet   * for transmission but don't get an interrupt within a specified timeout  * (usually 5 seconds).  When this happens we assume the worst and reset the  * card.  */
end_comment

begin_function
specifier|static
name|void
name|xe_watchdog
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|xe_softc
modifier|*
name|scp
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|device_printf
argument_list|(
name|scp
operator|->
name|dev
argument_list|,
literal|"watchdog timeout; resetting card\n"
argument_list|)
expr_stmt|;
name|scp
operator|->
name|tx_timeouts
operator|++
expr_stmt|;
name|ifp
operator|->
name|if_oerrors
operator|+=
name|scp
operator|->
name|tx_queued
expr_stmt|;
name|xe_stop
argument_list|(
name|scp
argument_list|)
expr_stmt|;
name|xe_hard_reset
argument_list|(
name|scp
argument_list|)
expr_stmt|;
name|xe_setmedia
argument_list|(
name|scp
argument_list|)
expr_stmt|;
name|xe_init
argument_list|(
name|scp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Change media selection.  */
end_comment

begin_function
specifier|static
name|int
name|xe_media_change
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|xe_softc
modifier|*
name|scp
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
ifdef|#
directive|ifdef
name|XE_DEBUG
name|printf
argument_list|(
literal|"xe%d: media_change\n"
argument_list|,
name|ifp
operator|->
name|if_unit
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|IFM_TYPE
argument_list|(
name|scp
operator|->
name|ifm
operator|->
name|ifm_media
argument_list|)
operator|!=
name|IFM_ETHER
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/*    * Some card/media combos aren't always possible -- filter those out here.    */
if|if
condition|(
operator|(
name|IFM_SUBTYPE
argument_list|(
name|scp
operator|->
name|ifm
operator|->
name|ifm_media
argument_list|)
operator|==
name|IFM_AUTO
operator|||
name|IFM_SUBTYPE
argument_list|(
name|scp
operator|->
name|ifm
operator|->
name|ifm_media
argument_list|)
operator|==
name|IFM_100_TX
operator|)
operator|&&
operator|!
name|scp
operator|->
name|phy_ok
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|xe_setmedia
argument_list|(
name|scp
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Return current media selection.  */
end_comment

begin_function
specifier|static
name|void
name|xe_media_status
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|ifmediareq
modifier|*
name|mrp
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|XE_DEBUG
name|printf
argument_list|(
literal|"xe%d: media_status\n"
argument_list|,
name|ifp
operator|->
name|if_unit
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|mrp
operator|->
name|ifm_active
operator|=
operator|(
operator|(
expr|struct
name|xe_softc
operator|*
operator|)
name|ifp
operator|->
name|if_softc
operator|)
operator|->
name|media
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * Select active media.  */
end_comment

begin_function
specifier|static
name|void
name|xe_setmedia
parameter_list|(
name|void
modifier|*
name|xscp
parameter_list|)
block|{
name|struct
name|xe_softc
modifier|*
name|scp
init|=
name|xscp
decl_stmt|;
name|u_int16_t
name|bmcr
decl_stmt|,
name|bmsr
decl_stmt|,
name|anar
decl_stmt|,
name|lpar
decl_stmt|;
ifdef|#
directive|ifdef
name|XE_DEBUG
name|device_printf
argument_list|(
name|scp
operator|->
name|dev
argument_list|,
literal|"setmedia\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Cancel any pending timeout */
name|untimeout
argument_list|(
name|xe_setmedia
argument_list|,
name|scp
argument_list|,
name|scp
operator|->
name|chand
argument_list|)
expr_stmt|;
name|xe_disable_intr
argument_list|(
name|scp
argument_list|)
expr_stmt|;
comment|/* Select media */
name|scp
operator|->
name|media
operator|=
name|IFM_ETHER
expr_stmt|;
switch|switch
condition|(
name|IFM_SUBTYPE
argument_list|(
name|scp
operator|->
name|ifm
operator|->
name|ifm_media
argument_list|)
condition|)
block|{
case|case
name|IFM_AUTO
case|:
comment|/* Autoselect media */
name|scp
operator|->
name|media
operator|=
name|IFM_ETHER
operator||
name|IFM_AUTO
expr_stmt|;
comment|/*      * Autoselection is really awful.  It goes something like this:      *      * Wait until the transmitter goes idle (2sec timeout).      * Reset card      *   IF a 100Mbit PHY exists      *     Start NWAY autonegotiation (3.5sec timeout)      *     IF that succeeds      *       Select 100baseTX or 10baseT, whichever was detected      *     ELSE      *       Reset card      *       IF a 100Mbit PHY exists      *         Try to force a 100baseTX link (3sec timeout)      *         IF that succeeds      *           Select 100baseTX      *         ELSE      *           Disable the PHY      *         ENDIF      *       ENDIF      *     ENDIF      *   ENDIF      * IF nothing selected so far      *   IF a 100Mbit PHY exists      *     Select 10baseT      *   ELSE      *     Select 10baseT or 10base2, whichever is connected      *   ENDIF      * ENDIF      */
switch|switch
condition|(
name|scp
operator|->
name|autoneg_status
condition|)
block|{
case|case
name|XE_AUTONEG_NONE
case|:
if|#
directive|if
name|XE_DEBUG
operator|>
literal|1
name|device_printf
argument_list|(
name|scp
operator|->
name|dev
argument_list|,
literal|"Waiting for idle transmitter\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|scp
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_flags
operator||=
name|IFF_OACTIVE
expr_stmt|;
name|scp
operator|->
name|autoneg_status
operator|=
name|XE_AUTONEG_WAITING
expr_stmt|;
name|scp
operator|->
name|chand
operator|=
name|timeout
argument_list|(
name|xe_setmedia
argument_list|,
name|scp
argument_list|,
name|hz
operator|*
literal|2
argument_list|)
expr_stmt|;
return|return;
case|case
name|XE_AUTONEG_WAITING
case|:
name|xe_soft_reset
argument_list|(
name|scp
argument_list|)
expr_stmt|;
if|if
condition|(
name|scp
operator|->
name|phy_ok
condition|)
block|{
if|#
directive|if
name|XE_DEBUG
operator|>
literal|1
name|device_printf
argument_list|(
name|scp
operator|->
name|dev
argument_list|,
literal|"Starting autonegotiation\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|bmcr
operator|=
name|xe_phy_readreg
argument_list|(
name|scp
argument_list|,
name|PHY_BMCR
argument_list|)
expr_stmt|;
name|bmcr
operator|&=
operator|~
operator|(
name|PHY_BMCR_AUTONEGENBL
operator|)
expr_stmt|;
name|xe_phy_writereg
argument_list|(
name|scp
argument_list|,
name|PHY_BMCR
argument_list|,
name|bmcr
argument_list|)
expr_stmt|;
name|anar
operator|=
name|xe_phy_readreg
argument_list|(
name|scp
argument_list|,
name|PHY_ANAR
argument_list|)
expr_stmt|;
name|anar
operator|&=
operator|~
operator|(
name|PHY_ANAR_100BT4
operator||
name|PHY_ANAR_100BTXFULL
operator||
name|PHY_ANAR_10BTFULL
operator|)
expr_stmt|;
name|anar
operator||=
name|PHY_ANAR_100BTXHALF
operator||
name|PHY_ANAR_10BTHALF
expr_stmt|;
name|xe_phy_writereg
argument_list|(
name|scp
argument_list|,
name|PHY_ANAR
argument_list|,
name|anar
argument_list|)
expr_stmt|;
name|bmcr
operator||=
name|PHY_BMCR_AUTONEGENBL
operator||
name|PHY_BMCR_AUTONEGRSTR
expr_stmt|;
name|xe_phy_writereg
argument_list|(
name|scp
argument_list|,
name|PHY_BMCR
argument_list|,
name|bmcr
argument_list|)
expr_stmt|;
name|scp
operator|->
name|autoneg_status
operator|=
name|XE_AUTONEG_STARTED
expr_stmt|;
name|scp
operator|->
name|chand
operator|=
name|timeout
argument_list|(
name|xe_setmedia
argument_list|,
name|scp
argument_list|,
name|hz
operator|*
literal|7
operator|/
literal|2
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
name|scp
operator|->
name|autoneg_status
operator|=
name|XE_AUTONEG_FAIL
expr_stmt|;
block|}
break|break;
case|case
name|XE_AUTONEG_STARTED
case|:
name|bmsr
operator|=
name|xe_phy_readreg
argument_list|(
name|scp
argument_list|,
name|PHY_BMSR
argument_list|)
expr_stmt|;
name|lpar
operator|=
name|xe_phy_readreg
argument_list|(
name|scp
argument_list|,
name|PHY_LPAR
argument_list|)
expr_stmt|;
if|if
condition|(
name|bmsr
operator|&
operator|(
name|PHY_BMSR_AUTONEGCOMP
operator||
name|PHY_BMSR_LINKSTAT
operator|)
condition|)
block|{
if|#
directive|if
name|XE_DEBUG
operator|>
literal|1
name|device_printf
argument_list|(
name|scp
operator|->
name|dev
argument_list|,
literal|"Autonegotiation complete!\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * XXX - Shouldn't have to do this, but (on my hub at least) the 	 * XXX - transmitter won't work after a successful autoneg.  So we see  	 * XXX - what the negotiation result was and force that mode.  I'm 	 * XXX - sure there is an easy fix for this. 	 */
if|if
condition|(
name|lpar
operator|&
name|PHY_LPAR_100BTXHALF
condition|)
block|{
name|xe_phy_writereg
argument_list|(
name|scp
argument_list|,
name|PHY_BMCR
argument_list|,
name|PHY_BMCR_SPEEDSEL
argument_list|)
expr_stmt|;
name|XE_MII_DUMP
argument_list|(
name|scp
argument_list|)
expr_stmt|;
name|XE_SELECT_PAGE
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|XE_OUTB
argument_list|(
name|XE_MSR
argument_list|,
name|XE_INB
argument_list|(
name|XE_MSR
argument_list|)
operator||
literal|0x08
argument_list|)
expr_stmt|;
name|scp
operator|->
name|media
operator|=
name|IFM_ETHER
operator||
name|IFM_100_TX
expr_stmt|;
name|scp
operator|->
name|autoneg_status
operator|=
name|XE_AUTONEG_NONE
expr_stmt|;
block|}
else|else
block|{
comment|/* 	   * XXX - Bit of a hack going on in here. 	   * XXX - This is derived from Ken Hughes patch to the Linux driver 	   * XXX - to make it work with 10Mbit _autonegotiated_ links on CE3B 	   * XXX - cards.  What's a CE3B and how's it differ from a plain CE3? 	   * XXX - these are the things we need to find out. 	   */
name|xe_phy_writereg
argument_list|(
name|scp
argument_list|,
name|PHY_BMCR
argument_list|,
literal|0x0000
argument_list|)
expr_stmt|;
name|XE_SELECT_PAGE
argument_list|(
literal|2
argument_list|)
expr_stmt|;
comment|/* BEGIN HACK */
name|XE_OUTB
argument_list|(
name|XE_MSR
argument_list|,
name|XE_INB
argument_list|(
name|XE_MSR
argument_list|)
operator||
literal|0x08
argument_list|)
expr_stmt|;
name|XE_SELECT_PAGE
argument_list|(
literal|0x42
argument_list|)
expr_stmt|;
name|XE_OUTB
argument_list|(
name|XE_SWC1
argument_list|,
literal|0x80
argument_list|)
expr_stmt|;
name|scp
operator|->
name|media
operator|=
name|IFM_ETHER
operator||
name|IFM_10_T
expr_stmt|;
name|scp
operator|->
name|autoneg_status
operator|=
name|XE_AUTONEG_NONE
expr_stmt|;
comment|/* END HACK */
comment|/*XE_OUTB(XE_MSR, XE_INB(XE_MSR)& ~0x08);*/
comment|/* Disable PHY? */
comment|/*scp->autoneg_status = XE_AUTONEG_FAIL;*/
block|}
block|}
else|else
block|{
if|#
directive|if
name|XE_DEBUG
operator|>
literal|1
name|device_printf
argument_list|(
name|scp
operator|->
name|dev
argument_list|,
literal|"Autonegotiation failed; trying 100baseTX\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|XE_MII_DUMP
argument_list|(
name|scp
argument_list|)
expr_stmt|;
name|xe_soft_reset
argument_list|(
name|scp
argument_list|)
expr_stmt|;
if|if
condition|(
name|scp
operator|->
name|phy_ok
condition|)
block|{
name|xe_phy_writereg
argument_list|(
name|scp
argument_list|,
name|PHY_BMCR
argument_list|,
name|PHY_BMCR_SPEEDSEL
argument_list|)
expr_stmt|;
name|scp
operator|->
name|autoneg_status
operator|=
name|XE_AUTONEG_100TX
expr_stmt|;
name|scp
operator|->
name|chand
operator|=
name|timeout
argument_list|(
name|xe_setmedia
argument_list|,
name|scp
argument_list|,
name|hz
operator|*
literal|3
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
name|scp
operator|->
name|autoneg_status
operator|=
name|XE_AUTONEG_FAIL
expr_stmt|;
block|}
block|}
break|break;
case|case
name|XE_AUTONEG_100TX
case|:
operator|(
name|void
operator|)
name|xe_phy_readreg
argument_list|(
name|scp
argument_list|,
name|PHY_BMSR
argument_list|)
expr_stmt|;
name|bmsr
operator|=
name|xe_phy_readreg
argument_list|(
name|scp
argument_list|,
name|PHY_BMSR
argument_list|)
expr_stmt|;
if|if
condition|(
name|bmsr
operator|&
name|PHY_BMSR_LINKSTAT
condition|)
block|{
if|#
directive|if
name|XE_DEBUG
operator|>
literal|1
name|device_printf
argument_list|(
name|scp
operator|->
name|dev
argument_list|,
literal|"Got 100baseTX link!\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|XE_MII_DUMP
argument_list|(
name|scp
argument_list|)
expr_stmt|;
name|XE_SELECT_PAGE
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|XE_OUTB
argument_list|(
name|XE_MSR
argument_list|,
name|XE_INB
argument_list|(
name|XE_MSR
argument_list|)
operator||
literal|0x08
argument_list|)
expr_stmt|;
name|scp
operator|->
name|media
operator|=
name|IFM_ETHER
operator||
name|IFM_100_TX
expr_stmt|;
name|scp
operator|->
name|autoneg_status
operator|=
name|XE_AUTONEG_NONE
expr_stmt|;
block|}
else|else
block|{
if|#
directive|if
name|XE_DEBUG
operator|>
literal|1
name|device_printf
argument_list|(
name|scp
operator|->
name|dev
argument_list|,
literal|"Autonegotiation failed; disabling PHY\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|XE_MII_DUMP
argument_list|(
name|scp
argument_list|)
expr_stmt|;
name|xe_phy_writereg
argument_list|(
name|scp
argument_list|,
name|PHY_BMCR
argument_list|,
literal|0x0000
argument_list|)
expr_stmt|;
name|XE_SELECT_PAGE
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|XE_OUTB
argument_list|(
name|XE_MSR
argument_list|,
name|XE_INB
argument_list|(
name|XE_MSR
argument_list|)
operator|&
operator|~
literal|0x08
argument_list|)
expr_stmt|;
comment|/* Disable PHY? */
name|scp
operator|->
name|autoneg_status
operator|=
name|XE_AUTONEG_FAIL
expr_stmt|;
block|}
break|break;
block|}
comment|/*      * If we got down here _and_ autoneg_status is XE_AUTONEG_FAIL, then      * either autonegotiation failed, or never got started to begin with.  In      * either case, select a suitable 10Mbit media and hope it works.  We      * don't need to reset the card again, since it will have been done      * already by the big switch above.      */
if|if
condition|(
name|scp
operator|->
name|autoneg_status
operator|==
name|XE_AUTONEG_FAIL
condition|)
block|{
if|#
directive|if
name|XE_DEBUG
operator|>
literal|1
name|device_printf
argument_list|(
name|scp
operator|->
name|dev
argument_list|,
literal|"Selecting 10baseX\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|scp
operator|->
name|mohawk
condition|)
block|{
name|XE_SELECT_PAGE
argument_list|(
literal|0x42
argument_list|)
expr_stmt|;
name|XE_OUTB
argument_list|(
name|XE_SWC1
argument_list|,
literal|0x80
argument_list|)
expr_stmt|;
name|scp
operator|->
name|media
operator|=
name|IFM_ETHER
operator||
name|IFM_10_T
expr_stmt|;
name|scp
operator|->
name|autoneg_status
operator|=
name|XE_AUTONEG_NONE
expr_stmt|;
block|}
else|else
block|{
name|XE_SELECT_PAGE
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|XE_OUTB
argument_list|(
name|XE_GPR0
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|50000
argument_list|)
expr_stmt|;
name|XE_SELECT_PAGE
argument_list|(
literal|0x42
argument_list|)
expr_stmt|;
name|XE_OUTB
argument_list|(
name|XE_SWC1
argument_list|,
operator|(
name|XE_INB
argument_list|(
name|XE_ESR
argument_list|)
operator|&
name|XE_ESR_MEDIA_SELECT
operator|)
condition|?
literal|0x80
else|:
literal|0xc0
argument_list|)
expr_stmt|;
name|scp
operator|->
name|media
operator|=
name|IFM_ETHER
operator||
operator|(
operator|(
name|XE_INB
argument_list|(
name|XE_ESR
argument_list|)
operator|&
name|XE_ESR_MEDIA_SELECT
operator|)
condition|?
name|IFM_10_T
else|:
name|IFM_10_2
operator|)
expr_stmt|;
name|scp
operator|->
name|autoneg_status
operator|=
name|XE_AUTONEG_NONE
expr_stmt|;
block|}
block|}
break|break;
comment|/*      * If a specific media has been requested, we just reset the card and      * select it (one small exception -- if 100baseTX is requested by there is       * no PHY, we fall back to 10baseT operation).      */
case|case
name|IFM_100_TX
case|:
comment|/* Force 100baseTX */
name|xe_soft_reset
argument_list|(
name|scp
argument_list|)
expr_stmt|;
if|if
condition|(
name|scp
operator|->
name|phy_ok
condition|)
block|{
if|#
directive|if
name|XE_DEBUG
operator|>
literal|1
name|device_printf
argument_list|(
name|scp
operator|->
name|dev
argument_list|,
literal|"Selecting 100baseTX\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|XE_SELECT_PAGE
argument_list|(
literal|0x42
argument_list|)
expr_stmt|;
name|XE_OUTB
argument_list|(
name|XE_SWC1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|xe_phy_writereg
argument_list|(
name|scp
argument_list|,
name|PHY_BMCR
argument_list|,
name|PHY_BMCR_SPEEDSEL
argument_list|)
expr_stmt|;
name|XE_SELECT_PAGE
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|XE_OUTB
argument_list|(
name|XE_MSR
argument_list|,
name|XE_INB
argument_list|(
name|XE_MSR
argument_list|)
operator||
literal|0x08
argument_list|)
expr_stmt|;
name|scp
operator|->
name|media
operator||=
name|IFM_100_TX
expr_stmt|;
break|break;
block|}
comment|/* FALLTHROUGH */
case|case
name|IFM_10_T
case|:
comment|/* Force 10baseT */
name|xe_soft_reset
argument_list|(
name|scp
argument_list|)
expr_stmt|;
if|#
directive|if
name|XE_DEBUG
operator|>
literal|1
name|device_printf
argument_list|(
name|scp
operator|->
name|dev
argument_list|,
literal|"Selecting 10baseT\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|scp
operator|->
name|phy_ok
condition|)
block|{
name|xe_phy_writereg
argument_list|(
name|scp
argument_list|,
name|PHY_BMCR
argument_list|,
literal|0x0000
argument_list|)
expr_stmt|;
name|XE_SELECT_PAGE
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|XE_OUTB
argument_list|(
name|XE_MSR
argument_list|,
name|XE_INB
argument_list|(
name|XE_MSR
argument_list|)
operator|&
operator|~
literal|0x08
argument_list|)
expr_stmt|;
comment|/* Disable PHY */
block|}
name|XE_SELECT_PAGE
argument_list|(
literal|0x42
argument_list|)
expr_stmt|;
name|XE_OUTB
argument_list|(
name|XE_SWC1
argument_list|,
literal|0x80
argument_list|)
expr_stmt|;
name|scp
operator|->
name|media
operator||=
name|IFM_10_T
expr_stmt|;
break|break;
case|case
name|IFM_10_2
case|:
name|xe_soft_reset
argument_list|(
name|scp
argument_list|)
expr_stmt|;
if|#
directive|if
name|XE_DEBUG
operator|>
literal|1
name|device_printf
argument_list|(
name|scp
operator|->
name|dev
argument_list|,
literal|"Selecting 10base2\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|XE_SELECT_PAGE
argument_list|(
literal|0x42
argument_list|)
expr_stmt|;
name|XE_OUTB
argument_list|(
name|XE_SWC1
argument_list|,
literal|0xc0
argument_list|)
expr_stmt|;
name|scp
operator|->
name|media
operator||=
name|IFM_10_2
expr_stmt|;
break|break;
block|}
comment|/*    * Finally, the LEDs are set to match whatever media was chosen and the    * transmitter is unblocked.     */
if|#
directive|if
name|XE_DEBUG
operator|>
literal|1
name|device_printf
argument_list|(
name|scp
operator|->
name|dev
argument_list|,
literal|"Setting LEDs\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|XE_SELECT_PAGE
argument_list|(
literal|2
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|IFM_SUBTYPE
argument_list|(
name|scp
operator|->
name|media
argument_list|)
condition|)
block|{
case|case
name|IFM_100_TX
case|:
case|case
name|IFM_10_T
case|:
name|XE_OUTB
argument_list|(
name|XE_LED
argument_list|,
literal|0x3b
argument_list|)
expr_stmt|;
if|if
condition|(
name|scp
operator|->
name|dingo
condition|)
name|XE_OUTB
argument_list|(
literal|0x0b
argument_list|,
literal|0x04
argument_list|)
expr_stmt|;
comment|/* 100Mbit LED */
break|break;
case|case
name|IFM_10_2
case|:
name|XE_OUTB
argument_list|(
name|XE_LED
argument_list|,
literal|0x3a
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Restart output? */
name|scp
operator|->
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
name|IFF_OACTIVE
expr_stmt|;
name|xe_init
argument_list|(
name|scp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Hard reset (power cycle) the card.  */
end_comment

begin_function
specifier|static
name|void
name|xe_hard_reset
parameter_list|(
name|struct
name|xe_softc
modifier|*
name|scp
parameter_list|)
block|{
name|int
name|s
decl_stmt|;
ifdef|#
directive|ifdef
name|XE_DEBUG
name|device_printf
argument_list|(
name|scp
operator|->
name|dev
argument_list|,
literal|"hard_reset\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
comment|/*    * Power cycle the card.    */
name|XE_SELECT_PAGE
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|XE_OUTB
argument_list|(
name|XE_GPR1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Power off */
name|DELAY
argument_list|(
literal|40000
argument_list|)
expr_stmt|;
if|if
condition|(
name|scp
operator|->
name|mohawk
condition|)
name|XE_OUTB
argument_list|(
name|XE_GPR1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* And back on again */
else|else
name|XE_OUTB
argument_list|(
name|XE_GPR1
argument_list|,
literal|5
argument_list|)
expr_stmt|;
comment|/* Also set AIC bit, whatever that is */
name|DELAY
argument_list|(
literal|40000
argument_list|)
expr_stmt|;
name|XE_SELECT_PAGE
argument_list|(
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Soft reset the card.  Also makes sure that the ML6692 and 10Mbit controller   * are powered up, sets the silicon revision number in softc, disables  * interrupts and checks for the prescence of a 100Mbit PHY.  This should  * leave us in a position where we can access the PHY and do media  * selection. The function imposes a 0.5s delay while the hardware powers up.  */
end_comment

begin_function
specifier|static
name|void
name|xe_soft_reset
parameter_list|(
name|struct
name|xe_softc
modifier|*
name|scp
parameter_list|)
block|{
name|int
name|s
decl_stmt|;
ifdef|#
directive|ifdef
name|XE_DEBUG
name|device_printf
argument_list|(
name|scp
operator|->
name|dev
argument_list|,
literal|"soft_reset\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
comment|/*    * Reset the card, (again).    */
name|XE_SELECT_PAGE
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|XE_OUTB
argument_list|(
name|XE_CR
argument_list|,
name|XE_CR_SOFT_RESET
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|40000
argument_list|)
expr_stmt|;
name|XE_OUTB
argument_list|(
name|XE_CR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|40000
argument_list|)
expr_stmt|;
if|if
condition|(
name|scp
operator|->
name|mohawk
condition|)
block|{
comment|/*      * set GP1 and GP2 as outputs (bits 2& 3)      * set GP1 low to power on the ML6692 (bit 0)      * set GP2 high to power on the 10Mhz chip (bit 1)      */
name|XE_SELECT_PAGE
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|XE_OUTB
argument_list|(
name|XE_GPR0
argument_list|,
literal|0x0e
argument_list|)
expr_stmt|;
block|}
comment|/*    * Wait for everything to wake up.    */
name|DELAY
argument_list|(
literal|500000
argument_list|)
expr_stmt|;
comment|/*    * Get silicon revision number.    */
name|XE_SELECT_PAGE
argument_list|(
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|scp
operator|->
name|mohawk
condition|)
name|scp
operator|->
name|srev
operator|=
operator|(
name|XE_INB
argument_list|(
name|XE_BOV
argument_list|)
operator|&
literal|0x70
operator|)
operator|>>
literal|4
expr_stmt|;
else|else
name|scp
operator|->
name|srev
operator|=
operator|(
name|XE_INB
argument_list|(
name|XE_BOV
argument_list|)
operator|&
literal|0x30
operator|)
operator|>>
literal|4
expr_stmt|;
ifdef|#
directive|ifdef
name|XE_DEBUG
name|device_printf
argument_list|(
name|scp
operator|->
name|dev
argument_list|,
literal|"silicon revision = %d\n"
argument_list|,
name|scp
operator|->
name|srev
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*    * Shut off interrupts.    */
name|xe_disable_intr
argument_list|(
name|scp
argument_list|)
expr_stmt|;
comment|/*    * Check for PHY.    */
if|if
condition|(
name|scp
operator|->
name|mohawk
condition|)
block|{
name|scp
operator|->
name|phy_ok
operator|=
name|xe_mii_init
argument_list|(
name|scp
argument_list|)
expr_stmt|;
block|}
name|XE_SELECT_PAGE
argument_list|(
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Take interface offline.  This is done by powering down the device, which I  * assume means just shutting down the transceiver and Ethernet logic.  This  * requires a _hard_ reset to recover from, as we need to power up again.  */
end_comment

begin_function
specifier|static
name|void
name|xe_stop
parameter_list|(
name|struct
name|xe_softc
modifier|*
name|scp
parameter_list|)
block|{
name|int
name|s
decl_stmt|;
ifdef|#
directive|ifdef
name|XE_DEBUG
name|device_printf
argument_list|(
name|scp
operator|->
name|dev
argument_list|,
literal|"stop\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
comment|/*    * Shut off interrupts.    */
name|xe_disable_intr
argument_list|(
name|scp
argument_list|)
expr_stmt|;
comment|/*    * Power down.    */
name|XE_SELECT_PAGE
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|XE_OUTB
argument_list|(
name|XE_GPR1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|XE_SELECT_PAGE
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/*    * ~IFF_RUNNING == interface down.    */
name|scp
operator|->
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
name|IFF_RUNNING
expr_stmt|;
name|scp
operator|->
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
name|IFF_OACTIVE
expr_stmt|;
name|scp
operator|->
name|ifp
operator|->
name|if_timer
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Enable Ethernet interrupts from the card.  */
end_comment

begin_function
specifier|static
name|void
name|xe_enable_intr
parameter_list|(
name|struct
name|xe_softc
modifier|*
name|scp
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|XE_DEBUG
name|device_printf
argument_list|(
name|scp
operator|->
name|dev
argument_list|,
literal|"enable_intr\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|XE_SELECT_PAGE
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|XE_OUTB
argument_list|(
name|XE_IMR0
argument_list|,
literal|0xff
argument_list|)
expr_stmt|;
comment|/* Unmask everything */
name|XE_OUTB
argument_list|(
name|XE_IMR1
argument_list|,
literal|0x01
argument_list|)
expr_stmt|;
comment|/* Unmask TX underrun detection */
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|XE_SELECT_PAGE
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|XE_OUTB
argument_list|(
name|XE_CR
argument_list|,
name|XE_CR_ENABLE_INTR
argument_list|)
expr_stmt|;
comment|/* Enable interrupts */
if|if
condition|(
name|scp
operator|->
name|modem
operator|&&
operator|!
name|scp
operator|->
name|dingo
condition|)
block|{
comment|/* This bit is just magic */
if|if
condition|(
operator|!
operator|(
name|XE_INB
argument_list|(
literal|0x10
argument_list|)
operator|&
literal|0x01
operator|)
condition|)
block|{
name|XE_OUTB
argument_list|(
literal|0x10
argument_list|,
literal|0x11
argument_list|)
expr_stmt|;
comment|/* Unmask master int enable bit */
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Disable all Ethernet interrupts from the card.  */
end_comment

begin_function
specifier|static
name|void
name|xe_disable_intr
parameter_list|(
name|struct
name|xe_softc
modifier|*
name|scp
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|XE_DEBUG
name|device_printf
argument_list|(
name|scp
operator|->
name|dev
argument_list|,
literal|"disable_intr\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|XE_SELECT_PAGE
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|XE_OUTB
argument_list|(
name|XE_CR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Disable interrupts */
if|if
condition|(
name|scp
operator|->
name|modem
operator|&&
operator|!
name|scp
operator|->
name|dingo
condition|)
block|{
comment|/* More magic (does this work?) */
name|XE_OUTB
argument_list|(
literal|0x10
argument_list|,
literal|0x10
argument_list|)
expr_stmt|;
comment|/* Mask the master int enable bit */
block|}
name|XE_SELECT_PAGE
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|XE_OUTB
argument_list|(
name|XE_IMR0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Forbid all interrupts */
name|XE_OUTB
argument_list|(
name|XE_IMR1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|XE_SELECT_PAGE
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Set up multicast filter and promiscuous mode  */
end_comment

begin_function
specifier|static
name|void
name|xe_setmulti
parameter_list|(
name|struct
name|xe_softc
modifier|*
name|scp
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|ifmultiaddr
modifier|*
name|maddr
decl_stmt|;
name|int
name|count
decl_stmt|;
name|ifp
operator|=
operator|&
name|scp
operator|->
name|arpcom
operator|.
name|ac_if
expr_stmt|;
name|maddr
operator|=
name|ifp
operator|->
name|if_multiaddrs
operator|.
name|lh_first
expr_stmt|;
comment|/* Get length of multicast list */
for|for
control|(
name|count
operator|=
literal|0
init|;
name|maddr
operator|!=
name|NULL
condition|;
name|maddr
operator|=
name|maddr
operator|->
name|ifma_link
operator|.
name|le_next
operator|,
name|count
operator|++
control|)
empty_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_PROMISC
operator|)
operator|||
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_ALLMULTI
operator|)
operator|||
operator|(
name|count
operator|>
literal|9
operator|)
condition|)
block|{
comment|/*      * Go into promiscuous mode if either of the PROMISC or ALLMULTI flags are      * set, or if we have been asked to deal with more than 9 multicast      * addresses.  To do this: set MPE and PME in SWC1      */
name|XE_SELECT_PAGE
argument_list|(
literal|0x42
argument_list|)
expr_stmt|;
name|XE_OUTB
argument_list|(
name|XE_SWC1
argument_list|,
literal|0x06
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_MULTICAST
operator|)
operator|&&
operator|(
name|count
operator|>
literal|0
operator|)
condition|)
block|{
comment|/*      * Program the filters for up to 9 addresses      */
name|XE_SELECT_PAGE
argument_list|(
literal|0x42
argument_list|)
expr_stmt|;
name|XE_OUTB
argument_list|(
name|XE_SWC1
argument_list|,
literal|0x01
argument_list|)
expr_stmt|;
name|XE_SELECT_PAGE
argument_list|(
literal|0x40
argument_list|)
expr_stmt|;
name|XE_OUTB
argument_list|(
name|XE_CMD0
argument_list|,
name|XE_CMD0_OFFLINE
argument_list|)
expr_stmt|;
comment|/*xe_reg_dump(scp);*/
name|xe_setaddrs
argument_list|(
name|scp
argument_list|)
expr_stmt|;
comment|/*xe_reg_dump(scp);*/
name|XE_SELECT_PAGE
argument_list|(
literal|0x40
argument_list|)
expr_stmt|;
name|XE_OUTB
argument_list|(
name|XE_CMD0
argument_list|,
name|XE_CMD0_RX_ENABLE
operator||
name|XE_CMD0_ONLINE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/*      * No multicast operation (default)      */
name|XE_SELECT_PAGE
argument_list|(
literal|0x42
argument_list|)
expr_stmt|;
name|XE_OUTB
argument_list|(
name|XE_SWC1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|XE_SELECT_PAGE
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Set up all on-chip addresses (for multicast).  AFAICS, there are 10  * of these things; the first is our MAC address, the other 9 are mcast  * addresses, padded with the MAC address if there aren't enough.  * XXX - This doesn't work right, but I'm not sure why yet.  We seem to be  * XXX - doing much the same as the Linux code, which is weird enough that  * XXX - it's probably right (despite my earlier comments to the contrary).  */
end_comment

begin_function
specifier|static
name|void
name|xe_setaddrs
parameter_list|(
name|struct
name|xe_softc
modifier|*
name|scp
parameter_list|)
block|{
name|struct
name|ifmultiaddr
modifier|*
name|maddr
decl_stmt|;
name|u_int8_t
modifier|*
name|addr
decl_stmt|;
name|u_int8_t
name|page
decl_stmt|,
name|slot
decl_stmt|,
name|byte
decl_stmt|,
name|i
decl_stmt|;
name|maddr
operator|=
name|scp
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_multiaddrs
operator|.
name|lh_first
expr_stmt|;
name|XE_SELECT_PAGE
argument_list|(
name|page
operator|=
literal|0x50
argument_list|)
expr_stmt|;
for|for
control|(
name|slot
operator|=
literal|0
operator|,
name|byte
operator|=
literal|8
init|;
name|slot
operator|<
literal|10
condition|;
name|slot
operator|++
control|)
block|{
if|if
condition|(
name|slot
operator|==
literal|0
condition|)
name|addr
operator|=
operator|(
name|u_int8_t
operator|*
operator|)
operator|(
operator|&
name|scp
operator|->
name|arpcom
operator|.
name|ac_enaddr
operator|)
expr_stmt|;
else|else
block|{
while|while
condition|(
name|maddr
operator|!=
name|NULL
operator|&&
name|maddr
operator|->
name|ifma_addr
operator|->
name|sa_family
operator|!=
name|AF_LINK
condition|)
name|maddr
operator|=
name|maddr
operator|->
name|ifma_link
operator|.
name|le_next
expr_stmt|;
if|if
condition|(
name|maddr
operator|!=
name|NULL
condition|)
name|addr
operator|=
name|LLADDR
argument_list|(
operator|(
expr|struct
name|sockaddr_dl
operator|*
operator|)
name|maddr
operator|->
name|ifma_addr
argument_list|)
expr_stmt|;
else|else
name|addr
operator|=
operator|(
name|u_int8_t
operator|*
operator|)
operator|(
operator|&
name|scp
operator|->
name|arpcom
operator|.
name|ac_enaddr
operator|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|6
condition|;
name|i
operator|++
operator|,
name|byte
operator|++
control|)
block|{
if|#
directive|if
name|XE_DEBUG
operator|>
literal|2
if|if
condition|(
name|i
condition|)
name|printf
argument_list|(
literal|":%x"
argument_list|,
name|addr
index|[
name|i
index|]
argument_list|)
expr_stmt|;
else|else
name|device_printf
argument_list|(
name|scp
operator|->
name|dev
argument_list|,
literal|"individual addresses %d: %x"
argument_list|,
name|slot
argument_list|,
name|addr
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|byte
operator|>
literal|15
condition|)
block|{
name|page
operator|++
expr_stmt|;
name|byte
operator|=
literal|8
expr_stmt|;
name|XE_SELECT_PAGE
argument_list|(
name|page
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|scp
operator|->
name|mohawk
condition|)
name|XE_OUTB
argument_list|(
name|byte
argument_list|,
name|addr
index|[
literal|5
operator|-
name|i
index|]
argument_list|)
expr_stmt|;
else|else
name|XE_OUTB
argument_list|(
name|byte
argument_list|,
name|addr
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|XE_DEBUG
operator|>
literal|2
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|XE_SELECT_PAGE
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Write an outgoing packet to the card using programmed I/O.  */
end_comment

begin_function
specifier|static
name|int
name|xe_pio_write_packet
parameter_list|(
name|struct
name|xe_softc
modifier|*
name|scp
parameter_list|,
name|struct
name|mbuf
modifier|*
name|mbp
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|mbp2
decl_stmt|;
name|u_int16_t
name|len
decl_stmt|,
name|pad
decl_stmt|,
name|free
decl_stmt|,
name|ok
decl_stmt|;
name|u_int8_t
modifier|*
name|data
decl_stmt|;
name|u_int8_t
name|savebyte
index|[
literal|2
index|]
decl_stmt|,
name|wantbyte
decl_stmt|;
comment|/* Get total packet length */
for|for
control|(
name|len
operator|=
literal|0
operator|,
name|mbp2
operator|=
name|mbp
init|;
name|mbp2
operator|!=
name|NULL
condition|;
name|len
operator|+=
name|mbp2
operator|->
name|m_len
operator|,
name|mbp2
operator|=
name|mbp2
operator|->
name|m_next
control|)
empty_stmt|;
comment|/* Packets< minimum length may need to be padded out */
name|pad
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|len
operator|<
name|ETHER_MIN_LEN
operator|-
name|ETHER_CRC_LEN
condition|)
block|{
name|pad
operator|=
operator|(
name|ETHER_MIN_LEN
operator|-
name|ETHER_CRC_LEN
operator|-
name|len
operator|+
literal|1
operator|)
operator|>>
literal|1
expr_stmt|;
name|len
operator|=
name|ETHER_MIN_LEN
operator|-
name|ETHER_CRC_LEN
expr_stmt|;
block|}
comment|/* Check transmit buffer space */
name|XE_SELECT_PAGE
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|XE_OUTW
argument_list|(
name|XE_TRS
argument_list|,
name|len
operator|+
literal|2
argument_list|)
expr_stmt|;
name|free
operator|=
name|XE_INW
argument_list|(
name|XE_TSO
argument_list|)
expr_stmt|;
name|ok
operator|=
name|free
operator|&
literal|0x8000
expr_stmt|;
name|free
operator|&=
literal|0x7fff
expr_stmt|;
if|if
condition|(
name|free
operator|<=
name|len
operator|+
literal|2
condition|)
return|return
literal|1
return|;
comment|/* Send packet length to card */
name|XE_OUTW
argument_list|(
name|XE_EDP
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|/*    * Write packet to card using PIO (code stolen from the ed driver)    */
name|wantbyte
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|mbp
operator|!=
name|NULL
condition|)
block|{
name|len
operator|=
name|mbp
operator|->
name|m_len
expr_stmt|;
if|if
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|data
operator|=
name|mtod
argument_list|(
name|mbp
argument_list|,
name|caddr_t
argument_list|)
expr_stmt|;
if|if
condition|(
name|wantbyte
condition|)
block|{
comment|/* Finish the last word */
name|savebyte
index|[
literal|1
index|]
operator|=
operator|*
name|data
expr_stmt|;
name|XE_OUTW
argument_list|(
name|XE_EDP
argument_list|,
operator|*
operator|(
name|u_short
operator|*
operator|)
name|savebyte
argument_list|)
expr_stmt|;
name|data
operator|++
expr_stmt|;
name|len
operator|--
expr_stmt|;
name|wantbyte
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|len
operator|>
literal|1
condition|)
block|{
comment|/* Output contiguous words */
name|bus_space_write_multi_2
argument_list|(
name|scp
operator|->
name|bst
argument_list|,
name|scp
operator|->
name|bsh
argument_list|,
name|XE_EDP
argument_list|,
operator|(
name|u_int16_t
operator|*
operator|)
name|data
argument_list|,
name|len
operator|>>
literal|1
argument_list|)
expr_stmt|;
name|data
operator|+=
name|len
operator|&
operator|~
literal|1
expr_stmt|;
name|len
operator|&=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|len
operator|==
literal|1
condition|)
block|{
comment|/* Save last byte, if necessary */
name|savebyte
index|[
literal|0
index|]
operator|=
operator|*
name|data
expr_stmt|;
name|wantbyte
operator|=
literal|1
expr_stmt|;
block|}
block|}
name|mbp
operator|=
name|mbp
operator|->
name|m_next
expr_stmt|;
block|}
if|if
condition|(
name|wantbyte
condition|)
comment|/* Last byte for odd-length packets */
name|XE_OUTW
argument_list|(
name|XE_EDP
argument_list|,
operator|*
operator|(
name|u_short
operator|*
operator|)
name|savebyte
argument_list|)
expr_stmt|;
comment|/*    * For CE3 cards, just tell 'em to send -- apparently the card will pad out    * short packets with random cruft.  Otherwise, write nonsense words to fill     * out the packet.  I guess it is then sent automatically (?)    */
if|if
condition|(
name|scp
operator|->
name|mohawk
condition|)
name|XE_OUTB
argument_list|(
name|XE_CR
argument_list|,
name|XE_CR_TX_PACKET
operator||
name|XE_CR_ENABLE_INTR
argument_list|)
expr_stmt|;
else|else
while|while
condition|(
name|pad
operator|>
literal|0
condition|)
block|{
name|XE_OUTW
argument_list|(
name|XE_EDP
argument_list|,
literal|0xdead
argument_list|)
expr_stmt|;
name|pad
operator|--
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Compute the 32-bit Ethernet CRC for the given buffer.  */
end_comment

begin_function
specifier|static
name|u_int32_t
name|xe_compute_crc
parameter_list|(
name|u_int8_t
modifier|*
name|data
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|u_int32_t
name|crc
init|=
literal|0xffffffff
decl_stmt|;
name|u_int32_t
name|poly
init|=
literal|0x04c11db6
decl_stmt|;
name|u_int8_t
name|current
decl_stmt|,
name|crc31
decl_stmt|,
name|bit
decl_stmt|;
name|int
name|i
decl_stmt|,
name|k
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|current
operator|=
name|data
index|[
name|i
index|]
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|1
init|;
name|k
operator|<=
literal|8
condition|;
name|k
operator|++
control|)
block|{
if|if
condition|(
name|crc
operator|&
literal|0x80000000
condition|)
block|{
name|crc31
operator|=
literal|0x01
expr_stmt|;
block|}
else|else
block|{
name|crc31
operator|=
literal|0
expr_stmt|;
block|}
name|bit
operator|=
name|crc31
operator|^
operator|(
name|current
operator|&
literal|0x01
operator|)
expr_stmt|;
name|crc
operator|<<=
literal|1
expr_stmt|;
name|current
operator|>>=
literal|1
expr_stmt|;
if|if
condition|(
name|bit
condition|)
block|{
name|crc
operator|=
operator|(
name|crc
operator|^
name|poly
operator|)
operator||
literal|1
expr_stmt|;
block|}
block|}
block|}
return|return
name|crc
return|;
block|}
end_function

begin_comment
comment|/*  * Convert a CRC into an index into the multicast hash table.  What we do is  * take the most-significant 6 bits of the CRC, reverse them, and use that as  * the bit number in the hash table.  Bits 5:3 of the result give the byte  * within the table (0-7); bits 2:0 give the bit number within that byte (also   * 0-7), ie. the number of shifts needed to get it into the lsb position.  */
end_comment

begin_function
specifier|static
name|int
name|xe_compute_hashbit
parameter_list|(
name|u_int32_t
name|crc
parameter_list|)
block|{
name|u_int8_t
name|hashbit
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|6
condition|;
name|i
operator|++
control|)
block|{
name|hashbit
operator|>>=
literal|1
expr_stmt|;
if|if
condition|(
name|crc
operator|&
literal|0x80000000
condition|)
block|{
name|hashbit
operator|&=
literal|0x80
expr_stmt|;
block|}
name|crc
operator|<<=
literal|1
expr_stmt|;
block|}
return|return
operator|(
name|hashbit
operator|>>
literal|2
operator|)
return|;
block|}
end_function

begin_comment
comment|/**************************************************************  *                                                            *  *                  M I I  F U N C T I O N S                  *  *                                                            *  **************************************************************/
end_comment

begin_comment
comment|/*  * Alternative MII/PHY handling code adapted from the xl driver.  It doesn't  * seem to work any better than the xirc2_ps stuff, but it's cleaner code.  * XXX - this stuff shouldn't be here.  It should all be abstracted off to  * XXX - some kind of common MII-handling code, shared by all drivers.  But  * XXX - that's a whole other mission.  */
end_comment

begin_define
define|#
directive|define
name|XE_MII_SET
parameter_list|(
name|x
parameter_list|)
value|XE_OUTB(XE_GPR2, (XE_INB(XE_GPR2) | 0x04) | (x))
end_define

begin_define
define|#
directive|define
name|XE_MII_CLR
parameter_list|(
name|x
parameter_list|)
value|XE_OUTB(XE_GPR2, (XE_INB(XE_GPR2) | 0x04)& ~(x))
end_define

begin_comment
comment|/*  * Sync the PHYs by setting data bit and strobing the clock 32 times.  */
end_comment

begin_function
specifier|static
name|void
name|xe_mii_sync
parameter_list|(
name|struct
name|xe_softc
modifier|*
name|scp
parameter_list|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|XE_SELECT_PAGE
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|XE_MII_SET
argument_list|(
name|XE_MII_DIR
operator||
name|XE_MII_WRD
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|32
condition|;
name|i
operator|++
control|)
block|{
name|XE_MII_SET
argument_list|(
name|XE_MII_CLK
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|XE_MII_CLR
argument_list|(
name|XE_MII_CLK
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Look for a MII-compliant PHY.  If we find one, reset it.  */
end_comment

begin_function
specifier|static
name|int
name|xe_mii_init
parameter_list|(
name|struct
name|xe_softc
modifier|*
name|scp
parameter_list|)
block|{
name|u_int16_t
name|status
decl_stmt|;
name|status
operator|=
name|xe_phy_readreg
argument_list|(
name|scp
argument_list|,
name|PHY_BMSR
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|status
operator|&
literal|0xff00
operator|)
operator|!=
literal|0x7800
condition|)
block|{
if|#
directive|if
name|XE_DEBUG
operator|>
literal|1
name|device_printf
argument_list|(
name|scp
operator|->
name|dev
argument_list|,
literal|"no PHY found, %0x\n"
argument_list|,
name|status
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|0
return|;
block|}
else|else
block|{
if|#
directive|if
name|XE_DEBUG
operator|>
literal|1
name|device_printf
argument_list|(
name|scp
operator|->
name|dev
argument_list|,
literal|"PHY OK!\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Reset the PHY */
name|xe_phy_writereg
argument_list|(
name|scp
argument_list|,
name|PHY_BMCR
argument_list|,
name|PHY_BMCR_RESET
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|500
argument_list|)
expr_stmt|;
while|while
condition|(
name|xe_phy_readreg
argument_list|(
name|scp
argument_list|,
name|PHY_BMCR
argument_list|)
operator|&
name|PHY_BMCR_RESET
condition|)
empty_stmt|;
name|XE_MII_DUMP
argument_list|(
name|scp
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * Clock a series of bits through the MII.  */
end_comment

begin_function
specifier|static
name|void
name|xe_mii_send
parameter_list|(
name|struct
name|xe_softc
modifier|*
name|scp
parameter_list|,
name|u_int32_t
name|bits
parameter_list|,
name|int
name|cnt
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|XE_SELECT_PAGE
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|XE_MII_CLR
argument_list|(
name|XE_MII_CLK
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
operator|(
literal|0x1
operator|<<
operator|(
name|cnt
operator|-
literal|1
operator|)
operator|)
init|;
name|i
condition|;
name|i
operator|>>=
literal|1
control|)
block|{
if|if
condition|(
name|bits
operator|&
name|i
condition|)
block|{
name|XE_MII_SET
argument_list|(
name|XE_MII_WRD
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|XE_MII_CLR
argument_list|(
name|XE_MII_WRD
argument_list|)
expr_stmt|;
block|}
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|XE_MII_CLR
argument_list|(
name|XE_MII_CLK
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|XE_MII_SET
argument_list|(
name|XE_MII_CLK
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Read an PHY register through the MII.  */
end_comment

begin_function
specifier|static
name|int
name|xe_mii_readreg
parameter_list|(
name|struct
name|xe_softc
modifier|*
name|scp
parameter_list|,
name|struct
name|xe_mii_frame
modifier|*
name|frame
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|ack
decl_stmt|,
name|s
decl_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
comment|/*    * Set up frame for RX.    */
name|frame
operator|->
name|mii_stdelim
operator|=
name|XE_MII_STARTDELIM
expr_stmt|;
name|frame
operator|->
name|mii_opcode
operator|=
name|XE_MII_READOP
expr_stmt|;
name|frame
operator|->
name|mii_turnaround
operator|=
literal|0
expr_stmt|;
name|frame
operator|->
name|mii_data
operator|=
literal|0
expr_stmt|;
name|XE_SELECT_PAGE
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|XE_OUTB
argument_list|(
name|XE_GPR2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/*    * Turn on data xmit.    */
name|XE_MII_SET
argument_list|(
name|XE_MII_DIR
argument_list|)
expr_stmt|;
name|xe_mii_sync
argument_list|(
name|scp
argument_list|)
expr_stmt|;
comment|/*	    * Send command/address info.    */
name|xe_mii_send
argument_list|(
name|scp
argument_list|,
name|frame
operator|->
name|mii_stdelim
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|xe_mii_send
argument_list|(
name|scp
argument_list|,
name|frame
operator|->
name|mii_opcode
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|xe_mii_send
argument_list|(
name|scp
argument_list|,
name|frame
operator|->
name|mii_phyaddr
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|xe_mii_send
argument_list|(
name|scp
argument_list|,
name|frame
operator|->
name|mii_regaddr
argument_list|,
literal|5
argument_list|)
expr_stmt|;
comment|/* Idle bit */
name|XE_MII_CLR
argument_list|(
operator|(
name|XE_MII_CLK
operator||
name|XE_MII_WRD
operator|)
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|XE_MII_SET
argument_list|(
name|XE_MII_CLK
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* Turn off xmit. */
name|XE_MII_CLR
argument_list|(
name|XE_MII_DIR
argument_list|)
expr_stmt|;
comment|/* Check for ack */
name|XE_MII_CLR
argument_list|(
name|XE_MII_CLK
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|XE_MII_SET
argument_list|(
name|XE_MII_CLK
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|ack
operator|=
name|XE_INB
argument_list|(
name|XE_GPR2
argument_list|)
operator|&
name|XE_MII_RDD
expr_stmt|;
comment|/*    * Now try reading data bits. If the ack failed, we still    * need to clock through 16 cycles to keep the PHY(s) in sync.    */
if|if
condition|(
name|ack
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
block|{
name|XE_MII_CLR
argument_list|(
name|XE_MII_CLK
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|XE_MII_SET
argument_list|(
name|XE_MII_CLK
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
goto|goto
name|fail
goto|;
block|}
for|for
control|(
name|i
operator|=
literal|0x8000
init|;
name|i
condition|;
name|i
operator|>>=
literal|1
control|)
block|{
name|XE_MII_CLR
argument_list|(
name|XE_MII_CLK
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ack
condition|)
block|{
if|if
condition|(
name|XE_INB
argument_list|(
name|XE_GPR2
argument_list|)
operator|&
name|XE_MII_RDD
condition|)
name|frame
operator|->
name|mii_data
operator||=
name|i
expr_stmt|;
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|XE_MII_SET
argument_list|(
name|XE_MII_CLK
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|fail
label|:
name|XE_MII_CLR
argument_list|(
name|XE_MII_CLK
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|XE_MII_SET
argument_list|(
name|XE_MII_CLK
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|ack
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Write to a PHY register through the MII.  */
end_comment

begin_function
specifier|static
name|int
name|xe_mii_writereg
parameter_list|(
name|struct
name|xe_softc
modifier|*
name|scp
parameter_list|,
name|struct
name|xe_mii_frame
modifier|*
name|frame
parameter_list|)
block|{
name|int
name|s
decl_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
comment|/*    * Set up frame for TX.    */
name|frame
operator|->
name|mii_stdelim
operator|=
name|XE_MII_STARTDELIM
expr_stmt|;
name|frame
operator|->
name|mii_opcode
operator|=
name|XE_MII_WRITEOP
expr_stmt|;
name|frame
operator|->
name|mii_turnaround
operator|=
name|XE_MII_TURNAROUND
expr_stmt|;
name|XE_SELECT_PAGE
argument_list|(
literal|2
argument_list|)
expr_stmt|;
comment|/*		    * Turn on data output.    */
name|XE_MII_SET
argument_list|(
name|XE_MII_DIR
argument_list|)
expr_stmt|;
name|xe_mii_sync
argument_list|(
name|scp
argument_list|)
expr_stmt|;
name|xe_mii_send
argument_list|(
name|scp
argument_list|,
name|frame
operator|->
name|mii_stdelim
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|xe_mii_send
argument_list|(
name|scp
argument_list|,
name|frame
operator|->
name|mii_opcode
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|xe_mii_send
argument_list|(
name|scp
argument_list|,
name|frame
operator|->
name|mii_phyaddr
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|xe_mii_send
argument_list|(
name|scp
argument_list|,
name|frame
operator|->
name|mii_regaddr
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|xe_mii_send
argument_list|(
name|scp
argument_list|,
name|frame
operator|->
name|mii_turnaround
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|xe_mii_send
argument_list|(
name|scp
argument_list|,
name|frame
operator|->
name|mii_data
argument_list|,
literal|16
argument_list|)
expr_stmt|;
comment|/* Idle bit. */
name|XE_MII_SET
argument_list|(
name|XE_MII_CLK
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|XE_MII_CLR
argument_list|(
name|XE_MII_CLK
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/*    * Turn off xmit.    */
name|XE_MII_CLR
argument_list|(
name|XE_MII_DIR
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Read a register from the PHY.  */
end_comment

begin_function
specifier|static
name|u_int16_t
name|xe_phy_readreg
parameter_list|(
name|struct
name|xe_softc
modifier|*
name|scp
parameter_list|,
name|u_int16_t
name|reg
parameter_list|)
block|{
name|struct
name|xe_mii_frame
name|frame
decl_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|frame
argument_list|,
sizeof|sizeof
argument_list|(
name|frame
argument_list|)
argument_list|)
expr_stmt|;
name|frame
operator|.
name|mii_phyaddr
operator|=
literal|0
expr_stmt|;
name|frame
operator|.
name|mii_regaddr
operator|=
name|reg
expr_stmt|;
name|xe_mii_readreg
argument_list|(
name|scp
argument_list|,
operator|&
name|frame
argument_list|)
expr_stmt|;
return|return
operator|(
name|frame
operator|.
name|mii_data
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Write to a PHY register.  */
end_comment

begin_function
specifier|static
name|void
name|xe_phy_writereg
parameter_list|(
name|struct
name|xe_softc
modifier|*
name|scp
parameter_list|,
name|u_int16_t
name|reg
parameter_list|,
name|u_int16_t
name|data
parameter_list|)
block|{
name|struct
name|xe_mii_frame
name|frame
decl_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|frame
argument_list|,
sizeof|sizeof
argument_list|(
name|frame
argument_list|)
argument_list|)
expr_stmt|;
name|frame
operator|.
name|mii_phyaddr
operator|=
literal|0
expr_stmt|;
name|frame
operator|.
name|mii_regaddr
operator|=
name|reg
expr_stmt|;
name|frame
operator|.
name|mii_data
operator|=
name|data
expr_stmt|;
name|xe_mii_writereg
argument_list|(
name|scp
argument_list|,
operator|&
name|frame
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|XE_DEBUG
end_ifdef

begin_comment
comment|/*  * A bit of debugging code.  */
end_comment

begin_function
specifier|static
name|void
name|xe_mii_dump
parameter_list|(
name|struct
name|xe_softc
modifier|*
name|scp
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|s
decl_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|device_printf
argument_list|(
name|scp
operator|->
name|dev
argument_list|,
literal|"MII registers: "
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
name|i
operator|++
control|)
block|{
name|printf
argument_list|(
literal|" %d:%04x"
argument_list|,
name|i
argument_list|,
name|xe_phy_readreg
argument_list|(
name|scp
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|4
init|;
name|i
operator|<
literal|7
condition|;
name|i
operator|++
control|)
block|{
name|printf
argument_list|(
literal|" %d:%04x"
argument_list|,
name|i
argument_list|,
name|xe_phy_readreg
argument_list|(
name|scp
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|xe_reg_dump
parameter_list|(
name|struct
name|xe_softc
modifier|*
name|scp
parameter_list|)
block|{
name|int
name|page
decl_stmt|,
name|i
decl_stmt|,
name|s
decl_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|device_printf
argument_list|(
name|scp
operator|->
name|dev
argument_list|,
literal|"Common registers: "
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
block|{
name|printf
argument_list|(
literal|" %2.2x"
argument_list|,
name|XE_INB
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|page
operator|=
literal|0
init|;
name|page
operator|<=
literal|8
condition|;
name|page
operator|++
control|)
block|{
name|device_printf
argument_list|(
name|scp
operator|->
name|dev
argument_list|,
literal|"Register page %2.2x: "
argument_list|,
name|page
argument_list|)
expr_stmt|;
name|XE_SELECT_PAGE
argument_list|(
name|page
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|8
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
block|{
name|printf
argument_list|(
literal|" %2.2x"
argument_list|,
name|XE_INB
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|page
operator|=
literal|0x10
init|;
name|page
operator|<
literal|0x5f
condition|;
name|page
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|page
operator|>=
literal|0x11
operator|&&
name|page
operator|<=
literal|0x3f
operator|)
operator|||
operator|(
name|page
operator|==
literal|0x41
operator|)
operator|||
operator|(
name|page
operator|>=
literal|0x43
operator|&&
name|page
operator|<=
literal|0x4f
operator|)
operator|||
operator|(
name|page
operator|>=
literal|0x59
operator|)
condition|)
continue|continue;
name|device_printf
argument_list|(
name|scp
operator|->
name|dev
argument_list|,
literal|"Register page %2.2x: "
argument_list|,
name|page
argument_list|)
expr_stmt|;
name|XE_SELECT_PAGE
argument_list|(
name|page
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|8
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
block|{
name|printf
argument_list|(
literal|" %2.2x"
argument_list|,
name|XE_INB
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|xe_activate
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|xe_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|start
decl_stmt|,
name|err
decl_stmt|;
if|if
condition|(
operator|!
name|sc
operator|->
name|dingo
condition|)
block|{
name|sc
operator|->
name|port_rid
operator|=
literal|0
expr_stmt|;
comment|/* 0 is managed by pccard */
name|sc
operator|->
name|port_res
operator|=
name|bus_alloc_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
operator|&
name|sc
operator|->
name|port_rid
argument_list|,
literal|0
argument_list|,
operator|~
literal|0
argument_list|,
literal|16
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Find a 16 byte aligned ioport for the card. 		 */
if|#
directive|if
name|XE_DEBUG
operator|>
literal|0
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Finding an aligned port for RealPort\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* XE_DEBUG */
name|sc
operator|->
name|port_rid
operator|=
literal|1
expr_stmt|;
comment|/* 0 is managed by pccard */
name|start
operator|=
literal|0x100
expr_stmt|;
do|do
block|{
name|sc
operator|->
name|port_res
operator|=
name|bus_alloc_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
operator|&
name|sc
operator|->
name|port_rid
argument_list|,
name|start
argument_list|,
literal|0x3ff
argument_list|,
literal|16
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|port_res
operator|==
literal|0
condition|)
break|break;
comment|/* we failed */
if|if
condition|(
operator|(
name|rman_get_start
argument_list|(
name|sc
operator|->
name|port_res
argument_list|)
operator|&
literal|0xf
operator|)
operator|==
literal|0
condition|)
break|break;
comment|/* good */
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
name|sc
operator|->
name|port_rid
argument_list|,
name|sc
operator|->
name|port_res
argument_list|)
expr_stmt|;
name|start
operator|=
operator|(
name|rman_get_start
argument_list|(
name|sc
operator|->
name|port_res
argument_list|)
operator|+
literal|15
operator|)
operator|&
operator|~
literal|0xf
expr_stmt|;
block|}
do|while
condition|(
literal|1
condition|)
do|;
if|#
directive|if
name|XE_DEBUG
operator|>
literal|2
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"port 0x%0lx, size 0x%0lx\n"
argument_list|,
name|bus_get_resource_start
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
name|sc
operator|->
name|port_rid
argument_list|)
argument_list|,
name|bus_get_resource_count
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
name|sc
operator|->
name|port_rid
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* XE_DEBUG */
block|}
if|if
condition|(
operator|!
name|sc
operator|->
name|port_res
condition|)
block|{
if|#
directive|if
name|XE_DEBUG
operator|>
literal|0
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Cannot allocate ioport\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|ENOMEM
return|;
block|}
name|sc
operator|->
name|irq_rid
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|irq_res
operator|=
name|bus_alloc_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|sc
operator|->
name|irq_rid
argument_list|,
literal|0
argument_list|,
operator|~
literal|0
argument_list|,
literal|1
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sc
operator|->
name|irq_res
condition|)
block|{
if|#
directive|if
name|XE_DEBUG
operator|>
literal|0
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Cannot allocate irq\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|xe_deactivate
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
if|if
condition|(
operator|(
name|err
operator|=
name|bus_setup_intr
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|irq_res
argument_list|,
name|INTR_TYPE_NET
argument_list|,
name|xe_intr
argument_list|,
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|intrhand
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|xe_deactivate
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
name|sc
operator|->
name|bst
operator|=
name|rman_get_bustag
argument_list|(
name|sc
operator|->
name|port_res
argument_list|)
expr_stmt|;
name|sc
operator|->
name|bsh
operator|=
name|rman_get_bushandle
argument_list|(
name|sc
operator|->
name|port_res
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|xe_deactivate
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|xe_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|intrhand
condition|)
name|bus_teardown_intr
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|irq_res
argument_list|,
name|sc
operator|->
name|intrhand
argument_list|)
expr_stmt|;
name|sc
operator|->
name|intrhand
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|port_res
condition|)
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
name|sc
operator|->
name|port_rid
argument_list|,
name|sc
operator|->
name|port_res
argument_list|)
expr_stmt|;
name|sc
operator|->
name|port_res
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|irq_res
condition|)
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|sc
operator|->
name|irq_rid
argument_list|,
name|sc
operator|->
name|irq_res
argument_list|)
expr_stmt|;
name|sc
operator|->
name|irq_res
operator|=
literal|0
expr_stmt|;
return|return;
block|}
end_function

begin_decl_stmt
specifier|static
name|device_method_t
name|xe_pccard_methods
index|[]
init|=
block|{
comment|/* Device interface */
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|xe_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|xe_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|xe_detach
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|xe_pccard_driver
init|=
block|{
literal|"xe"
block|,
name|xe_pccard_methods
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|xe_softc
argument_list|)
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|devclass_t
name|xe_devclass
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|xe
argument_list|,
name|pccard
argument_list|,
name|xe_pccard_driver
argument_list|,
name|xe_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

