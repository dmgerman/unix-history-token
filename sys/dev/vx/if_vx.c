begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1994 Herb Peyerl<hpeyerl@novatel.ca>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *      This product includes software developed by Herb Peyerl.  * 4. The name of Herb Peyerl may not be used to endorse or promote products  *    derived from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *  *  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Created from if_ep.c driver by Fred Gray (fgray@rice.edu) to support  * the 3c590 family.  */
end_comment

begin_comment
comment|/*  *	Modified from the FreeBSD 1.1.5.1 version by:  *		 	Andres Vega Garcia  *			INRIA - Sophia Antipolis, France  *			avega@sophia.inria.fr  */
end_comment

begin_comment
comment|/*  *  Promiscuous mode added and interrupt logic slightly changed  *  to reduce the number of adapter failures. Transceiver select  *  logic changed to use value from EEPROM. Autoconfiguration  *  features added.  *  Done by:  *          Serge Babkin  *          Chelindbank (Chelyabinsk, Russia)  *          babkin@hq.icb.chel.su  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/ethernet.h>
end_include

begin_include
include|#
directive|include
file|<net/if_dl.h>
end_include

begin_include
include|#
directive|include
file|<net/if_types.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<net/bpf.h>
end_include

begin_include
include|#
directive|include
file|<dev/vx/if_vxreg.h>
end_include

begin_include
include|#
directive|include
file|<dev/vx/if_vxvar.h>
end_include

begin_define
define|#
directive|define
name|ETHER_MAX_LEN
value|1518
end_define

begin_define
define|#
directive|define
name|ETHER_ADDR_LEN
value|6
end_define

begin_define
define|#
directive|define
name|ETHER_ALIGN
value|2
end_define

begin_struct
specifier|static
struct|struct
name|connector_entry
block|{
name|int
name|bit
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
block|}
name|conn_tab
index|[
name|VX_CONNECTORS
index|]
init|=
block|{
define|#
directive|define
name|CONNECTOR_UTP
value|0
block|{
literal|0x08
block|,
literal|"utp"
block|}
block|,
define|#
directive|define
name|CONNECTOR_AUI
value|1
block|{
literal|0x20
block|,
literal|"aui"
block|}
block|,
comment|/* dummy */
block|{
literal|0
block|,
literal|"???"
block|}
block|,
define|#
directive|define
name|CONNECTOR_BNC
value|3
block|{
literal|0x10
block|,
literal|"bnc"
block|}
block|,
define|#
directive|define
name|CONNECTOR_TX
value|4
block|{
literal|0x02
block|,
literal|"tx"
block|}
block|,
define|#
directive|define
name|CONNECTOR_FX
value|5
block|{
literal|0x04
block|,
literal|"fx"
block|}
block|,
define|#
directive|define
name|CONNECTOR_MII
value|6
block|{
literal|0x40
block|,
literal|"mii"
block|}
block|,
block|{
literal|0
block|,
literal|"???"
block|}
block|}
struct|;
end_struct

begin_function_decl
specifier|static
name|void
name|vx_txstat
parameter_list|(
name|struct
name|vx_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|vx_status
parameter_list|(
name|struct
name|vx_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|vx_init
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|vx_init_locked
parameter_list|(
name|struct
name|vx_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|vx_ioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|u_long
parameter_list|,
name|caddr_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|vx_start
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|vx_start_locked
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|vx_watchdog
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|vx_reset
parameter_list|(
name|struct
name|vx_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|vx_read
parameter_list|(
name|struct
name|vx_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|mbuf
modifier|*
name|vx_get
parameter_list|(
name|struct
name|vx_softc
modifier|*
parameter_list|,
name|u_int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|vx_mbuf_fill
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|vx_mbuf_empty
parameter_list|(
name|struct
name|vx_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|vx_setfilter
parameter_list|(
name|struct
name|vx_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|vx_getlink
parameter_list|(
name|struct
name|vx_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|vx_setlink
parameter_list|(
name|struct
name|vx_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|int
name|vx_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|vx_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|int
name|i
decl_stmt|;
name|u_char
name|eaddr
index|[
literal|6
index|]
decl_stmt|;
name|ifp
operator|=
name|sc
operator|->
name|vx_ifp
operator|=
name|if_alloc
argument_list|(
name|IFT_ETHER
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"can not if_alloc()\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|if_initname
argument_list|(
name|ifp
argument_list|,
name|device_get_name
argument_list|(
name|dev
argument_list|)
argument_list|,
name|device_get_unit
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|sc
operator|->
name|vx_mtx
argument_list|,
name|device_get_nameunit
argument_list|(
name|dev
argument_list|)
argument_list|,
name|MTX_NETWORK_LOCK
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|callout_init_mtx
argument_list|(
operator|&
name|sc
operator|->
name|vx_callout
argument_list|,
operator|&
name|sc
operator|->
name|vx_mtx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|GO_WINDOW
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|VX_COMMAND
argument_list|,
name|GLOBAL_RESET
argument_list|)
expr_stmt|;
name|VX_BUSY_WAIT
expr_stmt|;
name|vx_getlink
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/*          * Read the station address from the eeprom          */
name|GO_WINDOW
argument_list|(
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
name|i
operator|++
control|)
block|{
name|int
name|x
decl_stmt|;
if|if
condition|(
name|vx_busy_eeprom
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|mtx_destroy
argument_list|(
operator|&
name|sc
operator|->
name|vx_mtx
argument_list|)
expr_stmt|;
name|if_free
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|VX_W0_EEPROM_COMMAND
argument_list|,
name|EEPROM_CMD_RD
operator||
operator|(
name|EEPROM_OEM_ADDR0
operator|+
name|i
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|vx_busy_eeprom
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|mtx_destroy
argument_list|(
operator|&
name|sc
operator|->
name|vx_mtx
argument_list|)
expr_stmt|;
name|if_free
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|x
operator|=
name|CSR_READ_2
argument_list|(
name|sc
argument_list|,
name|VX_W0_EEPROM_DATA
argument_list|)
expr_stmt|;
name|eaddr
index|[
operator|(
name|i
operator|<<
literal|1
operator|)
index|]
operator|=
name|x
operator|>>
literal|8
expr_stmt|;
name|eaddr
index|[
operator|(
name|i
operator|<<
literal|1
operator|)
operator|+
literal|1
index|]
operator|=
name|x
expr_stmt|;
block|}
name|ifp
operator|->
name|if_mtu
operator|=
name|ETHERMTU
expr_stmt|;
name|ifp
operator|->
name|if_snd
operator|.
name|ifq_maxlen
operator|=
name|IFQ_MAXLEN
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|=
name|IFF_BROADCAST
operator||
name|IFF_SIMPLEX
operator||
name|IFF_MULTICAST
expr_stmt|;
name|ifp
operator|->
name|if_start
operator|=
name|vx_start
expr_stmt|;
name|ifp
operator|->
name|if_ioctl
operator|=
name|vx_ioctl
expr_stmt|;
name|ifp
operator|->
name|if_init
operator|=
name|vx_init
expr_stmt|;
name|ifp
operator|->
name|if_watchdog
operator|=
name|vx_watchdog
expr_stmt|;
name|ifp
operator|->
name|if_softc
operator|=
name|sc
expr_stmt|;
name|ether_ifattach
argument_list|(
name|ifp
argument_list|,
name|eaddr
argument_list|)
expr_stmt|;
name|sc
operator|->
name|vx_tx_start_thresh
operator|=
literal|20
expr_stmt|;
comment|/* probably a good starting point. */
name|vx_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * The order in here seems important. Otherwise we may not receive  * interrupts. ?!  */
end_comment

begin_function
specifier|static
name|void
name|vx_init
parameter_list|(
name|void
modifier|*
name|xsc
parameter_list|)
block|{
name|struct
name|vx_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|vx_softc
operator|*
operator|)
name|xsc
decl_stmt|;
name|VX_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|vx_init_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|VX_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|vx_init_locked
parameter_list|(
name|struct
name|vx_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|vx_ifp
decl_stmt|;
name|int
name|i
decl_stmt|;
name|VX_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|VX_BUSY_WAIT
expr_stmt|;
name|GO_WINDOW
argument_list|(
literal|2
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|6
condition|;
name|i
operator|++
control|)
comment|/* Reload the ether_addr. */
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|VX_W2_ADDR_0
operator|+
name|i
argument_list|,
name|IF_LLADDR
argument_list|(
name|sc
operator|->
name|vx_ifp
argument_list|)
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|VX_COMMAND
argument_list|,
name|RX_RESET
argument_list|)
expr_stmt|;
name|VX_BUSY_WAIT
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|VX_COMMAND
argument_list|,
name|TX_RESET
argument_list|)
expr_stmt|;
name|VX_BUSY_WAIT
expr_stmt|;
name|GO_WINDOW
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* Window 1 is operating window */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|31
condition|;
name|i
operator|++
control|)
name|CSR_READ_1
argument_list|(
name|sc
argument_list|,
name|VX_W1_TX_STATUS
argument_list|)
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|VX_COMMAND
argument_list|,
name|SET_RD_0_MASK
operator||
name|S_CARD_FAILURE
operator||
name|S_RX_COMPLETE
operator||
name|S_TX_COMPLETE
operator||
name|S_TX_AVAIL
argument_list|)
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|VX_COMMAND
argument_list|,
name|SET_INTR_MASK
operator||
name|S_CARD_FAILURE
operator||
name|S_RX_COMPLETE
operator||
name|S_TX_COMPLETE
operator||
name|S_TX_AVAIL
argument_list|)
expr_stmt|;
comment|/*          * Attempt to get rid of any stray interrupts that occured during          * configuration.  On the i386 this isn't possible because one may          * already be queued.  However, a single stray interrupt is          * unimportant.          */
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|VX_COMMAND
argument_list|,
name|ACK_INTR
operator||
literal|0xff
argument_list|)
expr_stmt|;
name|vx_setfilter
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|vx_setlink
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|VX_COMMAND
argument_list|,
name|RX_ENABLE
argument_list|)
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|VX_COMMAND
argument_list|,
name|TX_ENABLE
argument_list|)
expr_stmt|;
name|vx_mbuf_fill
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Interface is now `running', with no output active. */
name|ifp
operator|->
name|if_drv_flags
operator||=
name|IFF_DRV_RUNNING
expr_stmt|;
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_OACTIVE
expr_stmt|;
comment|/* Attempt to start output, if any. */
name|vx_start_locked
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|vx_setfilter
parameter_list|(
name|struct
name|vx_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|vx_ifp
decl_stmt|;
name|VX_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|GO_WINDOW
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* Window 1 is operating window */
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|VX_COMMAND
argument_list|,
name|SET_RX_FILTER
operator||
name|FIL_INDIVIDUAL
operator||
name|FIL_BRDCST
operator||
name|FIL_MULTICAST
operator||
operator|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_PROMISC
operator|)
condition|?
name|FIL_PROMISC
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|vx_getlink
parameter_list|(
name|struct
name|vx_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|n
decl_stmt|,
name|k
decl_stmt|;
name|GO_WINDOW
argument_list|(
literal|3
argument_list|)
expr_stmt|;
name|sc
operator|->
name|vx_connectors
operator|=
name|CSR_READ_2
argument_list|(
name|sc
argument_list|,
name|VX_W3_RESET_OPT
argument_list|)
operator|&
literal|0x7f
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
operator|,
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|VX_CONNECTORS
condition|;
name|k
operator|++
control|)
block|{
if|if
condition|(
name|sc
operator|->
name|vx_connectors
operator|&
name|conn_tab
index|[
name|k
index|]
operator|.
name|bit
condition|)
block|{
if|if
condition|(
name|n
operator|>
literal|0
condition|)
name|printf
argument_list|(
literal|"/"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|conn_tab
index|[
name|k
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
name|n
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|sc
operator|->
name|vx_connectors
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"no connectors!"
argument_list|)
expr_stmt|;
return|return;
block|}
name|GO_WINDOW
argument_list|(
literal|3
argument_list|)
expr_stmt|;
name|sc
operator|->
name|vx_connector
operator|=
operator|(
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|VX_W3_INTERNAL_CFG
argument_list|)
operator|&
name|INTERNAL_CONNECTOR_MASK
operator|)
operator|>>
name|INTERNAL_CONNECTOR_BITS
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|vx_connector
operator|&
literal|0x10
condition|)
block|{
name|sc
operator|->
name|vx_connector
operator|&=
literal|0x0f
expr_stmt|;
name|printf
argument_list|(
literal|"[*%s*]"
argument_list|,
name|conn_tab
index|[
operator|(
name|int
operator|)
name|sc
operator|->
name|vx_connector
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|": disable 'auto select' with DOS util!"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"[*%s*]"
argument_list|,
name|conn_tab
index|[
operator|(
name|int
operator|)
name|sc
operator|->
name|vx_connector
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|vx_setlink
parameter_list|(
name|struct
name|vx_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|vx_ifp
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|;
name|char
modifier|*
name|reason
decl_stmt|,
modifier|*
name|warning
decl_stmt|;
specifier|static
name|int
name|prev_flags
decl_stmt|;
specifier|static
name|signed
name|char
name|prev_conn
init|=
operator|-
literal|1
decl_stmt|;
name|VX_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|prev_conn
operator|==
operator|-
literal|1
condition|)
name|prev_conn
operator|=
name|sc
operator|->
name|vx_connector
expr_stmt|;
comment|/*          * S.B.          *          * Now behavior was slightly changed:          *          * if any of flags link[0-2] is used and its connector is          * physically present the following connectors are used:          *          *   link0 - AUI * highest precedence          *   link1 - BNC          *   link2 - UTP * lowest precedence          *          * If none of them is specified then          * connector specified in the EEPROM is used          * (if present on card or UTP if not).          */
name|i
operator|=
name|sc
operator|->
name|vx_connector
expr_stmt|;
comment|/* default in EEPROM */
name|reason
operator|=
literal|"default"
expr_stmt|;
name|warning
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_LINK0
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|vx_connectors
operator|&
name|conn_tab
index|[
name|CONNECTOR_AUI
index|]
operator|.
name|bit
condition|)
block|{
name|i
operator|=
name|CONNECTOR_AUI
expr_stmt|;
name|reason
operator|=
literal|"link0"
expr_stmt|;
block|}
else|else
block|{
name|warning
operator|=
literal|"aui not present! (link0)"
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_LINK1
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|vx_connectors
operator|&
name|conn_tab
index|[
name|CONNECTOR_BNC
index|]
operator|.
name|bit
condition|)
block|{
name|i
operator|=
name|CONNECTOR_BNC
expr_stmt|;
name|reason
operator|=
literal|"link1"
expr_stmt|;
block|}
else|else
block|{
name|warning
operator|=
literal|"bnc not present! (link1)"
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_LINK2
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|vx_connectors
operator|&
name|conn_tab
index|[
name|CONNECTOR_UTP
index|]
operator|.
name|bit
condition|)
block|{
name|i
operator|=
name|CONNECTOR_UTP
expr_stmt|;
name|reason
operator|=
literal|"link2"
expr_stmt|;
block|}
else|else
block|{
name|warning
operator|=
literal|"utp not present! (link2)"
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|sc
operator|->
name|vx_connectors
operator|&
name|conn_tab
index|[
operator|(
name|int
operator|)
name|sc
operator|->
name|vx_connector
index|]
operator|.
name|bit
operator|)
operator|==
literal|0
condition|)
block|{
name|warning
operator|=
literal|"strange connector type in EEPROM."
expr_stmt|;
name|reason
operator|=
literal|"forced"
expr_stmt|;
name|i
operator|=
name|CONNECTOR_UTP
expr_stmt|;
block|}
comment|/* Avoid unnecessary message. */
name|k
operator|=
operator|(
name|prev_flags
operator|^
name|ifp
operator|->
name|if_flags
operator|)
operator|&
operator|(
name|IFF_LINK0
operator||
name|IFF_LINK1
operator||
name|IFF_LINK2
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|k
operator|!=
literal|0
operator|)
operator|||
operator|(
name|prev_conn
operator|!=
name|i
operator|)
condition|)
block|{
if|if
condition|(
name|warning
operator|!=
name|NULL
condition|)
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"warning: %s\n"
argument_list|,
name|warning
argument_list|)
expr_stmt|;
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"selected %s. (%s)\n"
argument_list|,
name|conn_tab
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|reason
argument_list|)
expr_stmt|;
block|}
comment|/* Set the selected connector. */
name|GO_WINDOW
argument_list|(
literal|3
argument_list|)
expr_stmt|;
name|j
operator|=
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|VX_W3_INTERNAL_CFG
argument_list|)
operator|&
operator|~
name|INTERNAL_CONNECTOR_MASK
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|VX_W3_INTERNAL_CFG
argument_list|,
name|j
operator||
operator|(
name|i
operator|<<
name|INTERNAL_CONNECTOR_BITS
operator|)
argument_list|)
expr_stmt|;
comment|/* First, disable all. */
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|VX_COMMAND
argument_list|,
name|STOP_TRANSCEIVER
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|800
argument_list|)
expr_stmt|;
name|GO_WINDOW
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|VX_W4_MEDIA_TYPE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Second, enable the selected one. */
switch|switch
condition|(
name|i
condition|)
block|{
case|case
name|CONNECTOR_UTP
case|:
name|GO_WINDOW
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|VX_W4_MEDIA_TYPE
argument_list|,
name|ENABLE_UTP
argument_list|)
expr_stmt|;
break|break;
case|case
name|CONNECTOR_BNC
case|:
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|VX_COMMAND
argument_list|,
name|START_TRANSCEIVER
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|800
argument_list|)
expr_stmt|;
break|break;
case|case
name|CONNECTOR_TX
case|:
case|case
name|CONNECTOR_FX
case|:
name|GO_WINDOW
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|VX_W4_MEDIA_TYPE
argument_list|,
name|LINKBEAT_ENABLE
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* AUI and MII fall here */
break|break;
block|}
name|GO_WINDOW
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|prev_flags
operator|=
name|ifp
operator|->
name|if_flags
expr_stmt|;
name|prev_conn
operator|=
name|i
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|vx_start
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|vx_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|VX_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|vx_start_locked
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|VX_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|vx_start_locked
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|vx_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|len
decl_stmt|,
name|pad
decl_stmt|;
name|VX_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Don't transmit if interface is busy or not running */
if|if
condition|(
operator|(
name|sc
operator|->
name|vx_ifp
operator|->
name|if_drv_flags
operator|&
operator|(
name|IFF_DRV_RUNNING
operator||
name|IFF_DRV_OACTIVE
operator|)
operator|)
operator|!=
name|IFF_DRV_RUNNING
condition|)
return|return;
name|startagain
label|:
comment|/* Sneak a peek at the next packet */
name|m
operator|=
name|ifp
operator|->
name|if_snd
operator|.
name|ifq_head
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
return|return;
block|}
comment|/* We need to use m->m_pkthdr.len, so require the header */
name|M_ASSERTPKTHDR
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|len
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
name|pad
operator|=
operator|(
literal|4
operator|-
name|len
operator|)
operator|&
literal|3
expr_stmt|;
comment|/*          * The 3c509 automatically pads short packets to minimum ethernet 	 * length, but we drop packets that are too large. Perhaps we should 	 * truncate them instead?          */
if|if
condition|(
name|len
operator|+
name|pad
operator|>
name|ETHER_MAX_LEN
condition|)
block|{
comment|/* packet is obviously too large: toss it */
operator|++
name|ifp
operator|->
name|if_oerrors
expr_stmt|;
name|IF_DEQUEUE
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
goto|goto
name|readcheck
goto|;
block|}
name|VX_BUSY_WAIT
expr_stmt|;
if|if
condition|(
name|CSR_READ_2
argument_list|(
name|sc
argument_list|,
name|VX_W1_FREE_TX
argument_list|)
operator|<
name|len
operator|+
name|pad
operator|+
literal|4
condition|)
block|{
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|VX_COMMAND
argument_list|,
name|SET_TX_AVAIL_THRESH
operator||
operator|(
operator|(
name|len
operator|+
name|pad
operator|+
literal|4
operator|)
operator|>>
literal|2
operator|)
argument_list|)
expr_stmt|;
comment|/* not enough room in FIFO - make sure */
if|if
condition|(
name|CSR_READ_2
argument_list|(
name|sc
argument_list|,
name|VX_W1_FREE_TX
argument_list|)
operator|<
name|len
operator|+
name|pad
operator|+
literal|4
condition|)
block|{
name|ifp
operator|->
name|if_drv_flags
operator||=
name|IFF_DRV_OACTIVE
expr_stmt|;
name|ifp
operator|->
name|if_timer
operator|=
literal|1
expr_stmt|;
return|return;
block|}
block|}
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|VX_COMMAND
argument_list|,
name|SET_TX_AVAIL_THRESH
operator||
operator|(
literal|8188
operator|>>
literal|2
operator|)
argument_list|)
expr_stmt|;
name|IF_DEQUEUE
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
comment|/* not really needed */
return|return;
name|VX_BUSY_WAIT
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|VX_COMMAND
argument_list|,
name|SET_TX_START_THRESH
operator||
operator|(
operator|(
name|len
operator|/
literal|4
operator|+
name|sc
operator|->
name|vx_tx_start_thresh
operator|)
operator|>>
literal|2
operator|)
argument_list|)
expr_stmt|;
name|BPF_MTAP
argument_list|(
name|sc
operator|->
name|vx_ifp
argument_list|,
name|m
argument_list|)
expr_stmt|;
comment|/*          * Do the output at splhigh() so that an interrupt from another device          * won't cause a FIFO underrun. 	 * 	 * XXX: Can't enforce that anymore.          */
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|VX_W1_TX_PIO_WR_1
argument_list|,
name|len
operator||
name|TX_INDICATE
argument_list|)
expr_stmt|;
while|while
condition|(
name|m
condition|)
block|{
if|if
condition|(
name|m
operator|->
name|m_len
operator|>
literal|3
condition|)
name|bus_space_write_multi_4
argument_list|(
name|sc
operator|->
name|vx_bst
argument_list|,
name|sc
operator|->
name|vx_bsh
argument_list|,
name|VX_W1_TX_PIO_WR_1
argument_list|,
operator|(
name|u_int32_t
operator|*
operator|)
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
name|m
operator|->
name|m_len
operator|/
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_len
operator|&
literal|3
condition|)
name|bus_space_write_multi_1
argument_list|(
name|sc
operator|->
name|vx_bst
argument_list|,
name|sc
operator|->
name|vx_bsh
argument_list|,
name|VX_W1_TX_PIO_WR_1
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
operator|+
operator|(
name|m
operator|->
name|m_len
operator|&
operator|~
literal|3
operator|)
argument_list|,
name|m
operator|->
name|m_len
operator|&
literal|3
argument_list|)
expr_stmt|;
name|m
operator|=
name|m_free
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|pad
operator|--
condition|)
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|VX_W1_TX_PIO_WR_1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Padding */
operator|++
name|ifp
operator|->
name|if_opackets
expr_stmt|;
name|ifp
operator|->
name|if_timer
operator|=
literal|1
expr_stmt|;
name|readcheck
label|:
if|if
condition|(
operator|(
name|CSR_READ_2
argument_list|(
name|sc
argument_list|,
name|VX_W1_RX_STATUS
argument_list|)
operator|&
name|ERR_INCOMPLETE
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* We received a complete packet. */
if|if
condition|(
operator|(
name|CSR_READ_2
argument_list|(
name|sc
argument_list|,
name|VX_STATUS
argument_list|)
operator|&
name|S_INTR_LATCH
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 		         * No interrupt, read the packet and continue 		         * Is this supposed to happen?  Is my motherboard 		         * completely busted? 		         */
name|vx_read
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* 			 * Got an interrupt, return so that it gets 			 * serviced. 			 */
return|return;
block|}
else|else
block|{
comment|/* Check if we are stuck and reset [see XXX comment] */
if|if
condition|(
name|vx_status
argument_list|(
name|sc
argument_list|)
condition|)
block|{
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_DEBUG
condition|)
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"adapter reset\n"
argument_list|)
expr_stmt|;
name|vx_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
block|}
goto|goto
name|startagain
goto|;
block|}
end_function

begin_comment
comment|/*  * XXX: The 3c509 card can get in a mode where both the fifo status bit  *      FIFOS_RX_OVERRUN and the status bit ERR_INCOMPLETE are set  *      We detect this situation and we reset the adapter.  *      It happens at times when there is a lot of broadcast traffic  *      on the cable (once in a blue moon).  */
end_comment

begin_function
specifier|static
name|int
name|vx_status
parameter_list|(
name|struct
name|vx_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|int
name|fifost
decl_stmt|;
name|VX_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/*          * Check the FIFO status and act accordingly          */
name|GO_WINDOW
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|fifost
operator|=
name|CSR_READ_2
argument_list|(
name|sc
argument_list|,
name|VX_W4_FIFO_DIAG
argument_list|)
expr_stmt|;
name|GO_WINDOW
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|ifp
operator|=
name|sc
operator|->
name|vx_ifp
expr_stmt|;
if|if
condition|(
name|fifost
operator|&
name|FIFOS_RX_UNDERRUN
condition|)
block|{
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_DEBUG
condition|)
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"RX underrun\n"
argument_list|)
expr_stmt|;
name|vx_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|fifost
operator|&
name|FIFOS_RX_STATUS_OVERRUN
condition|)
block|{
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_DEBUG
condition|)
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"RX Status overrun\n"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|fifost
operator|&
name|FIFOS_RX_OVERRUN
condition|)
block|{
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_DEBUG
condition|)
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"RX overrun\n"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|fifost
operator|&
name|FIFOS_TX_OVERRUN
condition|)
block|{
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_DEBUG
condition|)
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"TX overrun\n"
argument_list|)
expr_stmt|;
name|vx_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|vx_txstat
parameter_list|(
name|struct
name|vx_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|int
name|i
decl_stmt|;
name|VX_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/*         * We need to read+write TX_STATUS until we get a 0 status         * in order to turn off the interrupt flag.         */
name|ifp
operator|=
name|sc
operator|->
name|vx_ifp
expr_stmt|;
while|while
condition|(
operator|(
name|i
operator|=
name|CSR_READ_1
argument_list|(
name|sc
argument_list|,
name|VX_W1_TX_STATUS
argument_list|)
operator|)
operator|&
name|TXS_COMPLETE
condition|)
block|{
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|VX_W1_TX_STATUS
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|&
name|TXS_JABBER
condition|)
block|{
operator|++
name|ifp
operator|->
name|if_oerrors
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_DEBUG
condition|)
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"jabber (%x)\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|vx_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|i
operator|&
name|TXS_UNDERRUN
condition|)
block|{
operator|++
name|ifp
operator|->
name|if_oerrors
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_DEBUG
condition|)
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"fifo underrun (%x) @%d\n"
argument_list|,
name|i
argument_list|,
name|sc
operator|->
name|vx_tx_start_thresh
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|vx_tx_succ_ok
operator|<
literal|100
condition|)
name|sc
operator|->
name|vx_tx_start_thresh
operator|=
name|min
argument_list|(
name|ETHER_MAX_LEN
argument_list|,
name|sc
operator|->
name|vx_tx_start_thresh
operator|+
literal|20
argument_list|)
expr_stmt|;
name|sc
operator|->
name|vx_tx_succ_ok
operator|=
literal|0
expr_stmt|;
name|vx_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|i
operator|&
name|TXS_MAX_COLLISION
condition|)
block|{
operator|++
name|ifp
operator|->
name|if_collisions
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|VX_COMMAND
argument_list|,
name|TX_ENABLE
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_OACTIVE
expr_stmt|;
block|}
else|else
name|sc
operator|->
name|vx_tx_succ_ok
operator|=
operator|(
name|sc
operator|->
name|vx_tx_succ_ok
operator|+
literal|1
operator|)
operator|&
literal|127
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|vx_intr
parameter_list|(
name|void
modifier|*
name|voidsc
parameter_list|)
block|{
name|short
name|status
decl_stmt|;
name|struct
name|vx_softc
modifier|*
name|sc
init|=
name|voidsc
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|vx_ifp
decl_stmt|;
name|VX_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|VX_COMMAND
argument_list|,
name|C_INTR_LATCH
argument_list|)
expr_stmt|;
name|status
operator|=
name|CSR_READ_2
argument_list|(
name|sc
argument_list|,
name|VX_STATUS
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|status
operator|&
operator|(
name|S_TX_COMPLETE
operator||
name|S_TX_AVAIL
operator||
name|S_RX_COMPLETE
operator||
name|S_CARD_FAILURE
operator|)
operator|)
operator|==
literal|0
condition|)
break|break;
comment|/* 		 * Acknowledge any interrupts.  It's important that we do this 		 * first, since there would otherwise be a race condition. 		 * Due to the i386 interrupt queueing, we may get spurious 		 * interrupts occasionally. 		 */
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|VX_COMMAND
argument_list|,
name|ACK_INTR
operator||
name|status
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|&
name|S_RX_COMPLETE
condition|)
name|vx_read
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|&
name|S_TX_AVAIL
condition|)
block|{
name|ifp
operator|->
name|if_timer
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|vx_ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_OACTIVE
expr_stmt|;
name|vx_start_locked
argument_list|(
name|sc
operator|->
name|vx_ifp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|status
operator|&
name|S_CARD_FAILURE
condition|)
block|{
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"adapter failure (%x)\n"
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_timer
operator|=
literal|0
expr_stmt|;
name|vx_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|status
operator|&
name|S_TX_COMPLETE
condition|)
block|{
name|ifp
operator|->
name|if_timer
operator|=
literal|0
expr_stmt|;
name|vx_txstat
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|vx_start_locked
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
block|}
block|}
name|VX_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* no more interrupts */
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|vx_read
parameter_list|(
name|struct
name|vx_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|vx_ifp
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|ether_header
modifier|*
name|eh
decl_stmt|;
name|u_int
name|len
decl_stmt|;
name|VX_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|len
operator|=
name|CSR_READ_2
argument_list|(
name|sc
argument_list|,
name|VX_W1_RX_STATUS
argument_list|)
expr_stmt|;
name|again
label|:
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_DEBUG
condition|)
block|{
name|int
name|err
init|=
name|len
operator|&
name|ERR_MASK
decl_stmt|;
name|char
modifier|*
name|s
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|len
operator|&
name|ERR_INCOMPLETE
condition|)
name|s
operator|=
literal|"incomplete packet"
expr_stmt|;
elseif|else
if|if
condition|(
name|err
operator|==
name|ERR_OVERRUN
condition|)
name|s
operator|=
literal|"packet overrun"
expr_stmt|;
elseif|else
if|if
condition|(
name|err
operator|==
name|ERR_RUNT
condition|)
name|s
operator|=
literal|"runt packet"
expr_stmt|;
elseif|else
if|if
condition|(
name|err
operator|==
name|ERR_ALIGNMENT
condition|)
name|s
operator|=
literal|"bad alignment"
expr_stmt|;
elseif|else
if|if
condition|(
name|err
operator|==
name|ERR_CRC
condition|)
name|s
operator|=
literal|"bad crc"
expr_stmt|;
elseif|else
if|if
condition|(
name|err
operator|==
name|ERR_OVERSIZE
condition|)
name|s
operator|=
literal|"oversized packet"
expr_stmt|;
elseif|else
if|if
condition|(
name|err
operator|==
name|ERR_DRIBBLE
condition|)
name|s
operator|=
literal|"dribble bits"
expr_stmt|;
if|if
condition|(
name|s
condition|)
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"%s\n"
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|len
operator|&
name|ERR_INCOMPLETE
condition|)
return|return;
if|if
condition|(
name|len
operator|&
name|ERR_RX
condition|)
block|{
operator|++
name|ifp
operator|->
name|if_ierrors
expr_stmt|;
goto|goto
name|abort
goto|;
block|}
name|len
operator|&=
name|RX_BYTES_MASK
expr_stmt|;
comment|/* Lower 11 bits = RX bytes. */
comment|/* Pull packet off interface. */
name|m
operator|=
name|vx_get
argument_list|(
name|sc
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
literal|0
condition|)
block|{
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
goto|goto
name|abort
goto|;
block|}
operator|++
name|ifp
operator|->
name|if_ipackets
expr_stmt|;
block|{
name|struct
name|mbuf
modifier|*
name|m0
decl_stmt|;
name|m0
operator|=
name|m_devget
argument_list|(
name|mtod
argument_list|(
name|m
argument_list|,
name|char
operator|*
argument_list|)
argument_list|,
name|m
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|,
name|ETHER_ALIGN
argument_list|,
name|ifp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|m0
operator|==
name|NULL
condition|)
block|{
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
goto|goto
name|abort
goto|;
block|}
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|m
operator|=
name|m0
expr_stmt|;
block|}
comment|/* We assume the header fit entirely in one mbuf. */
name|eh
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ether_header
operator|*
argument_list|)
expr_stmt|;
comment|/*          * XXX: Some cards seem to be in promiscous mode all the time.          * we need to make sure we only get our own stuff always.          * bleah!          */
if|if
condition|(
operator|!
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_PROMISC
operator|)
operator|&&
operator|(
name|eh
operator|->
name|ether_dhost
index|[
literal|0
index|]
operator|&
literal|1
operator|)
operator|==
literal|0
comment|/* !mcast and !bcast */
operator|&&
name|bcmp
argument_list|(
name|eh
operator|->
name|ether_dhost
argument_list|,
name|IF_LLADDR
argument_list|(
name|sc
operator|->
name|vx_ifp
argument_list|)
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return;
block|}
name|VX_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
call|(
modifier|*
name|ifp
operator|->
name|if_input
call|)
argument_list|(
name|ifp
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|VX_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/*         * In periods of high traffic we can actually receive enough         * packets so that the fifo overrun bit will be set at this point,         * even though we just read a packet. In this case we         * are not going to receive any more interrupts. We check for         * this condition and read again until the fifo is not full.         * We could simplify this test by not using vx_status(), but         * rechecking the RX_STATUS register directly. This test could         * result in unnecessary looping in cases where there is a new         * packet but the fifo is not full, but it will not fix the         * stuck behavior.         *         * Even with this improvement, we still get packet overrun errors         * which are hurting performance. Maybe when I get some more time         * I'll modify vx_read() so that it can handle RX_EARLY interrupts.         */
if|if
condition|(
name|vx_status
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|len
operator|=
name|CSR_READ_2
argument_list|(
name|sc
argument_list|,
name|VX_W1_RX_STATUS
argument_list|)
expr_stmt|;
comment|/* Check if we are stuck and reset [see XXX comment] */
if|if
condition|(
name|len
operator|&
name|ERR_INCOMPLETE
condition|)
block|{
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_DEBUG
condition|)
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"adapter reset\n"
argument_list|)
expr_stmt|;
name|vx_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
goto|goto
name|again
goto|;
block|}
return|return;
name|abort
label|:
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|VX_COMMAND
argument_list|,
name|RX_DISCARD_TOP_PACK
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|struct
name|mbuf
modifier|*
name|vx_get
parameter_list|(
name|struct
name|vx_softc
modifier|*
name|sc
parameter_list|,
name|u_int
name|totlen
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|vx_ifp
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|top
decl_stmt|,
modifier|*
modifier|*
name|mp
decl_stmt|,
modifier|*
name|m
decl_stmt|;
name|int
name|len
decl_stmt|;
name|VX_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|m
operator|=
name|sc
operator|->
name|vx_mb
index|[
name|sc
operator|->
name|vx_next_mb
index|]
expr_stmt|;
name|sc
operator|->
name|vx_mb
index|[
name|sc
operator|->
name|vx_next_mb
index|]
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|MGETHDR
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
block|}
else|else
block|{
comment|/* If the queue is no longer full, refill. */
if|if
condition|(
name|sc
operator|->
name|vx_last_mb
operator|==
name|sc
operator|->
name|vx_next_mb
operator|&&
name|sc
operator|->
name|vx_buffill_pending
operator|==
literal|0
condition|)
block|{
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|vx_callout
argument_list|,
name|hz
operator|/
literal|100
argument_list|,
name|vx_mbuf_fill
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|vx_buffill_pending
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Convert one of our saved mbuf's. */
name|sc
operator|->
name|vx_next_mb
operator|=
operator|(
name|sc
operator|->
name|vx_next_mb
operator|+
literal|1
operator|)
operator|%
name|MAX_MBS
expr_stmt|;
name|m
operator|->
name|m_data
operator|=
name|m
operator|->
name|m_pktdat
expr_stmt|;
name|m
operator|->
name|m_flags
operator|=
name|M_PKTHDR
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|m
operator|->
name|m_pkthdr
argument_list|,
sizeof|sizeof
argument_list|(
name|m
operator|->
name|m_pkthdr
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|ifp
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|totlen
expr_stmt|;
name|len
operator|=
name|MHLEN
expr_stmt|;
name|top
operator|=
name|NULL
expr_stmt|;
name|mp
operator|=
operator|&
name|top
expr_stmt|;
comment|/*          * We read the packet at splhigh() so that an interrupt from another          * device doesn't cause the card's buffer to overflow while we're          * reading it.  We may still lose packets at other times. 	 * 	 * XXX: Can't enforce this anymore.          */
comment|/*          * Since we don't set allowLargePackets bit in MacControl register,          * we can assume that totlen<= 1500bytes.          * The while loop will be performed iff we have a packet with          * MLEN< m_len< MINCLSIZE.          */
while|while
condition|(
name|totlen
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|top
condition|)
block|{
name|m
operator|=
name|sc
operator|->
name|vx_mb
index|[
name|sc
operator|->
name|vx_next_mb
index|]
expr_stmt|;
name|sc
operator|->
name|vx_mb
index|[
name|sc
operator|->
name|vx_next_mb
index|]
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|MGET
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|m_freem
argument_list|(
name|top
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
else|else
block|{
name|sc
operator|->
name|vx_next_mb
operator|=
operator|(
name|sc
operator|->
name|vx_next_mb
operator|+
literal|1
operator|)
operator|%
name|MAX_MBS
expr_stmt|;
block|}
name|len
operator|=
name|MLEN
expr_stmt|;
block|}
if|if
condition|(
name|totlen
operator|>=
name|MINCLSIZE
condition|)
block|{
name|MCLGET
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_flags
operator|&
name|M_EXT
condition|)
name|len
operator|=
name|MCLBYTES
expr_stmt|;
block|}
name|len
operator|=
name|min
argument_list|(
name|totlen
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
literal|3
condition|)
name|bus_space_read_multi_4
argument_list|(
name|sc
operator|->
name|vx_bst
argument_list|,
name|sc
operator|->
name|vx_bsh
argument_list|,
name|VX_W1_RX_PIO_RD_1
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
name|u_int32_t
operator|*
argument_list|)
argument_list|,
name|len
operator|/
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|&
literal|3
condition|)
block|{
name|bus_space_read_multi_1
argument_list|(
name|sc
operator|->
name|vx_bst
argument_list|,
name|sc
operator|->
name|vx_bsh
argument_list|,
name|VX_W1_RX_PIO_RD_1
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
name|u_int8_t
operator|*
argument_list|)
operator|+
operator|(
name|len
operator|&
operator|~
literal|3
operator|)
argument_list|,
name|len
operator|&
literal|3
argument_list|)
expr_stmt|;
block|}
name|m
operator|->
name|m_len
operator|=
name|len
expr_stmt|;
name|totlen
operator|-=
name|len
expr_stmt|;
operator|*
name|mp
operator|=
name|m
expr_stmt|;
name|mp
operator|=
operator|&
name|m
operator|->
name|m_next
expr_stmt|;
block|}
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|VX_COMMAND
argument_list|,
name|RX_DISCARD_TOP_PACK
argument_list|)
expr_stmt|;
return|return
name|top
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|vx_ioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|data
parameter_list|)
block|{
name|struct
name|vx_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|ifreq
modifier|*
name|ifr
init|=
operator|(
expr|struct
name|ifreq
operator|*
operator|)
name|data
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|SIOCSIFFLAGS
case|:
name|VX_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
operator|)
operator|==
literal|0
operator|&&
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* 	                 * If interface is marked up and it is stopped, then 	                 * start it. 	                 */
name|vx_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_RUNNING
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 	                 * If interface is marked up and it is stopped, then 	                 * start it. 	                 */
name|vx_init_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 	                 * deal with flags changes: 	                 * IFF_MULTICAST, IFF_PROMISC, 	                 * IFF_LINK0, IFF_LINK1, 	                 */
name|vx_setfilter
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|vx_setlink
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
name|VX_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCSIFMTU
case|:
comment|/* 	         * Set the interface MTU. 	         */
name|VX_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifr
operator|->
name|ifr_mtu
operator|>
name|ETHERMTU
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
else|else
block|{
name|ifp
operator|->
name|if_mtu
operator|=
name|ifr
operator|->
name|ifr_mtu
expr_stmt|;
block|}
name|VX_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCADDMULTI
case|:
case|case
name|SIOCDELMULTI
case|:
comment|/* 		 * Multicast list has changed; set the hardware filter 		 * accordingly. 		 */
name|VX_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|vx_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|VX_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|ether_ioctl
argument_list|(
name|ifp
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|vx_reset
parameter_list|(
name|struct
name|vx_softc
modifier|*
name|sc
parameter_list|)
block|{
name|VX_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|vx_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|vx_init_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|vx_watchdog
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|vx_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|VX_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_DEBUG
condition|)
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"device timeout\n"
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_OACTIVE
expr_stmt|;
name|vx_start_locked
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|vx_intr
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|VX_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|vx_stop
parameter_list|(
name|struct
name|vx_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|vx_ifp
decl_stmt|;
name|VX_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_timer
operator|=
literal|0
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|VX_COMMAND
argument_list|,
name|RX_DISABLE
argument_list|)
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|VX_COMMAND
argument_list|,
name|RX_DISCARD_TOP_PACK
argument_list|)
expr_stmt|;
name|VX_BUSY_WAIT
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|VX_COMMAND
argument_list|,
name|TX_DISABLE
argument_list|)
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|VX_COMMAND
argument_list|,
name|STOP_TRANSCEIVER
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|800
argument_list|)
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|VX_COMMAND
argument_list|,
name|RX_RESET
argument_list|)
expr_stmt|;
name|VX_BUSY_WAIT
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|VX_COMMAND
argument_list|,
name|TX_RESET
argument_list|)
expr_stmt|;
name|VX_BUSY_WAIT
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|VX_COMMAND
argument_list|,
name|C_INTR_LATCH
argument_list|)
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|VX_COMMAND
argument_list|,
name|SET_RD_0_MASK
argument_list|)
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|VX_COMMAND
argument_list|,
name|SET_INTR_MASK
argument_list|)
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|VX_COMMAND
argument_list|,
name|SET_RX_FILTER
argument_list|)
expr_stmt|;
name|vx_mbuf_empty
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|vx_busy_eeprom
parameter_list|(
name|struct
name|vx_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|j
decl_stmt|,
name|i
init|=
literal|100
decl_stmt|;
while|while
condition|(
name|i
operator|--
condition|)
block|{
name|j
operator|=
name|CSR_READ_2
argument_list|(
name|sc
argument_list|,
name|VX_W0_EEPROM_COMMAND
argument_list|)
expr_stmt|;
if|if
condition|(
name|j
operator|&
name|EEPROM_BUSY
condition|)
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
else|else
break|break;
block|}
if|if
condition|(
operator|!
name|i
condition|)
block|{
name|if_printf
argument_list|(
name|sc
operator|->
name|vx_ifp
argument_list|,
literal|"eeprom failed to come ready\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|vx_mbuf_fill
parameter_list|(
name|void
modifier|*
name|sp
parameter_list|)
block|{
name|struct
name|vx_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|vx_softc
operator|*
operator|)
name|sp
decl_stmt|;
name|int
name|i
decl_stmt|;
name|VX_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|i
operator|=
name|sc
operator|->
name|vx_last_mb
expr_stmt|;
do|do
block|{
if|if
condition|(
name|sc
operator|->
name|vx_mb
index|[
name|i
index|]
operator|==
name|NULL
condition|)
name|MGET
argument_list|(
name|sc
operator|->
name|vx_mb
index|[
name|i
index|]
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|vx_mb
index|[
name|i
index|]
operator|==
name|NULL
condition|)
break|break;
name|i
operator|=
operator|(
name|i
operator|+
literal|1
operator|)
operator|%
name|MAX_MBS
expr_stmt|;
block|}
do|while
condition|(
name|i
operator|!=
name|sc
operator|->
name|vx_next_mb
condition|)
do|;
name|sc
operator|->
name|vx_last_mb
operator|=
name|i
expr_stmt|;
comment|/* If the queue was not filled, try again. */
if|if
condition|(
name|sc
operator|->
name|vx_last_mb
operator|!=
name|sc
operator|->
name|vx_next_mb
condition|)
block|{
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|vx_callout
argument_list|,
name|hz
operator|/
literal|100
argument_list|,
name|vx_mbuf_fill
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|vx_buffill_pending
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|vx_buffill_pending
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|vx_mbuf_empty
parameter_list|(
name|struct
name|vx_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|VX_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_MBS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|sc
operator|->
name|vx_mb
index|[
name|i
index|]
condition|)
block|{
name|m_freem
argument_list|(
name|sc
operator|->
name|vx_mb
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|sc
operator|->
name|vx_mb
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
block|}
block|}
name|sc
operator|->
name|vx_last_mb
operator|=
name|sc
operator|->
name|vx_next_mb
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|vx_buffill_pending
operator|!=
literal|0
condition|)
name|callout_stop
argument_list|(
operator|&
name|sc
operator|->
name|vx_callout
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

