begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1994 Herb Peyerl<hpeyerl@novatel.ca>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *      This product includes software developed by Herb Peyerl.  * 4. The name of Herb Peyerl may not be used to endorse or promote products  *    derived from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *  * $FreeBSD$  *  */
end_comment

begin_comment
comment|/*  * Created from if_ep.c driver by Fred Gray (fgray@rice.edu) to support  * the 3c590 family.  */
end_comment

begin_comment
comment|/*  *	Modified from the FreeBSD 1.1.5.1 version by:  *		 	Andres Vega Garcia  *			INRIA - Sophia Antipolis, France  *			avega@sophia.inria.fr  */
end_comment

begin_comment
comment|/*  *  Promiscuous mode added and interrupt logic slightly changed  *  to reduce the number of adapter failures. Transceiver select  *  logic changed to use value from EEPROM. Autoconfiguration  *  features added.  *  Done by:  *          Serge Babkin  *          Chelindbank (Chelyabinsk, Russia)  *          babkin@hq.icb.chel.su  */
end_comment

begin_include
include|#
directive|include
file|"vx.h"
end_include

begin_if
if|#
directive|if
name|NVX
operator|<
literal|4
end_if

begin_comment
comment|/* These cost 4 bytes apiece, so give us 4 */
end_comment

begin_undef
undef|#
directive|undef
name|NVX
end_undef

begin_define
define|#
directive|define
name|NVX
value|4
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/ethernet.h>
end_include

begin_include
include|#
directive|include
file|<net/if_arp.h>
end_include

begin_include
include|#
directive|include
file|<net/bpf.h>
end_include

begin_include
include|#
directive|include
file|<machine/clock.h>
end_include

begin_include
include|#
directive|include
file|<dev/vx/if_vxreg.h>
end_include

begin_define
define|#
directive|define
name|ETHER_MAX_LEN
value|1518
end_define

begin_define
define|#
directive|define
name|ETHER_ADDR_LEN
value|6
end_define

begin_decl_stmt
name|struct
name|vx_softc
modifier|*
name|vx_softc
index|[
name|NVX
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_long
name|vx_count
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* both PCI and EISA */
end_comment

begin_struct
specifier|static
struct|struct
name|connector_entry
block|{
name|int
name|bit
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
block|}
name|conn_tab
index|[
name|VX_CONNECTORS
index|]
init|=
block|{
define|#
directive|define
name|CONNECTOR_UTP
value|0
block|{
literal|0x08
block|,
literal|"utp"
block|}
block|,
define|#
directive|define
name|CONNECTOR_AUI
value|1
block|{
literal|0x20
block|,
literal|"aui"
block|}
block|,
comment|/* dummy */
block|{
literal|0
block|,
literal|"???"
block|}
block|,
define|#
directive|define
name|CONNECTOR_BNC
value|3
block|{
literal|0x10
block|,
literal|"bnc"
block|}
block|,
define|#
directive|define
name|CONNECTOR_TX
value|4
block|{
literal|0x02
block|,
literal|"tx"
block|}
block|,
define|#
directive|define
name|CONNECTOR_FX
value|5
block|{
literal|0x04
block|,
literal|"fx"
block|}
block|,
define|#
directive|define
name|CONNECTOR_MII
value|6
block|{
literal|0x40
block|,
literal|"mii"
block|}
block|,
block|{
literal|0
block|,
literal|"???"
block|}
block|}
struct|;
end_struct

begin_comment
comment|/* struct vx_softc *vxalloc __P((int)); */
end_comment

begin_comment
comment|/* void *vxfree __P((struct vx_softc *)); */
end_comment

begin_comment
comment|/* int vxattach __P((struct vx_softc *)); */
end_comment

begin_decl_stmt
specifier|static
name|void
name|vxtxstat
name|__P
argument_list|(
operator|(
expr|struct
name|vx_softc
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|vxstatus
name|__P
argument_list|(
operator|(
expr|struct
name|vx_softc
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|vxinit
name|__P
argument_list|(
operator|(
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|vxioctl
name|__P
argument_list|(
operator|(
expr|struct
name|ifnet
operator|*
operator|,
name|u_long
operator|,
name|caddr_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|vxstart
name|__P
argument_list|(
operator|(
expr|struct
name|ifnet
operator|*
name|ifp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|vxwatchdog
name|__P
argument_list|(
operator|(
expr|struct
name|ifnet
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|vxreset
name|__P
argument_list|(
operator|(
expr|struct
name|vx_softc
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* void vxstop __P((struct vx_softc *)); */
end_comment

begin_decl_stmt
specifier|static
name|void
name|vxread
name|__P
argument_list|(
operator|(
expr|struct
name|vx_softc
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|mbuf
modifier|*
name|vxget
name|__P
argument_list|(
operator|(
expr|struct
name|vx_softc
operator|*
operator|,
name|u_int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|vxmbuffill
name|__P
argument_list|(
operator|(
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|vxmbufempty
name|__P
argument_list|(
operator|(
expr|struct
name|vx_softc
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|vxsetfilter
name|__P
argument_list|(
operator|(
expr|struct
name|vx_softc
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|vxgetlink
name|__P
argument_list|(
operator|(
expr|struct
name|vx_softc
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|vxsetlink
name|__P
argument_list|(
operator|(
expr|struct
name|vx_softc
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* int vxbusyeeprom __P((struct vx_softc *)); */
end_comment

begin_function
name|struct
name|vx_softc
modifier|*
name|vxalloc
parameter_list|(
name|unit
parameter_list|)
name|int
name|unit
decl_stmt|;
block|{
name|struct
name|vx_softc
modifier|*
name|sc
decl_stmt|;
if|if
condition|(
name|unit
operator|>=
name|NVX
condition|)
block|{
name|printf
argument_list|(
literal|"vx%d: unit number too high.\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|vx_softc
index|[
name|unit
index|]
condition|)
block|{
name|printf
argument_list|(
literal|"vx%d: already allocated.\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|sc
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|vx_softc
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"vx%d: cannot malloc.\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|bzero
argument_list|(
name|sc
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|vx_softc
argument_list|)
argument_list|)
expr_stmt|;
name|callout_handle_init
argument_list|(
operator|&
name|sc
operator|->
name|ch
argument_list|)
expr_stmt|;
name|vx_softc
index|[
name|unit
index|]
operator|=
name|sc
expr_stmt|;
name|sc
operator|->
name|unit
operator|=
name|unit
expr_stmt|;
return|return
operator|(
name|sc
operator|)
return|;
block|}
end_function

begin_function
name|void
name|vxfree
parameter_list|(
name|sc
parameter_list|)
name|struct
name|vx_softc
modifier|*
name|sc
decl_stmt|;
block|{
name|vx_softc
index|[
name|sc
operator|->
name|unit
index|]
operator|=
name|NULL
expr_stmt|;
name|free
argument_list|(
name|sc
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|int
name|vxattach
parameter_list|(
name|sc
parameter_list|)
name|struct
name|vx_softc
modifier|*
name|sc
decl_stmt|;
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
decl_stmt|;
name|int
name|i
decl_stmt|;
name|GO_WINDOW
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|outw
argument_list|(
name|VX_COMMAND
argument_list|,
name|GLOBAL_RESET
argument_list|)
expr_stmt|;
name|VX_BUSY_WAIT
expr_stmt|;
name|vxgetlink
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/*      * Read the station address from the eeprom      */
name|GO_WINDOW
argument_list|(
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
name|i
operator|++
control|)
block|{
name|int
name|x
decl_stmt|;
if|if
condition|(
name|vxbusyeeprom
argument_list|(
name|sc
argument_list|)
condition|)
return|return
literal|0
return|;
name|outw
argument_list|(
name|BASE
operator|+
name|VX_W0_EEPROM_COMMAND
argument_list|,
name|EEPROM_CMD_RD
operator||
operator|(
name|EEPROM_OEM_ADDR_0
operator|+
name|i
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|vxbusyeeprom
argument_list|(
name|sc
argument_list|)
condition|)
return|return
literal|0
return|;
name|x
operator|=
name|inw
argument_list|(
name|BASE
operator|+
name|VX_W0_EEPROM_DATA
argument_list|)
expr_stmt|;
name|sc
operator|->
name|arpcom
operator|.
name|ac_enaddr
index|[
operator|(
name|i
operator|<<
literal|1
operator|)
index|]
operator|=
name|x
operator|>>
literal|8
expr_stmt|;
name|sc
operator|->
name|arpcom
operator|.
name|ac_enaddr
index|[
operator|(
name|i
operator|<<
literal|1
operator|)
operator|+
literal|1
index|]
operator|=
name|x
expr_stmt|;
block|}
name|printf
argument_list|(
literal|" address %6D\n"
argument_list|,
name|sc
operator|->
name|arpcom
operator|.
name|ac_enaddr
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_unit
operator|=
name|sc
operator|->
name|unit
expr_stmt|;
name|ifp
operator|->
name|if_name
operator|=
literal|"vx"
expr_stmt|;
name|ifp
operator|->
name|if_mtu
operator|=
name|ETHERMTU
expr_stmt|;
name|ifp
operator|->
name|if_snd
operator|.
name|ifq_maxlen
operator|=
name|IFQ_MAXLEN
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|=
name|IFF_BROADCAST
operator||
name|IFF_SIMPLEX
operator||
name|IFF_MULTICAST
expr_stmt|;
name|ifp
operator|->
name|if_output
operator|=
name|ether_output
expr_stmt|;
name|ifp
operator|->
name|if_start
operator|=
name|vxstart
expr_stmt|;
name|ifp
operator|->
name|if_ioctl
operator|=
name|vxioctl
expr_stmt|;
name|ifp
operator|->
name|if_init
operator|=
name|vxinit
expr_stmt|;
name|ifp
operator|->
name|if_watchdog
operator|=
name|vxwatchdog
expr_stmt|;
name|ifp
operator|->
name|if_softc
operator|=
name|sc
expr_stmt|;
name|ether_ifattach
argument_list|(
name|ifp
argument_list|,
name|ETHER_BPF_SUPPORTED
argument_list|)
expr_stmt|;
name|sc
operator|->
name|tx_start_thresh
operator|=
literal|20
expr_stmt|;
comment|/* probably a good starting point. */
name|vxstop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * The order in here seems important. Otherwise we may not receive  * interrupts. ?!  */
end_comment

begin_function
specifier|static
name|void
name|vxinit
parameter_list|(
name|xsc
parameter_list|)
name|void
modifier|*
name|xsc
decl_stmt|;
block|{
name|struct
name|vx_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|vx_softc
operator|*
operator|)
name|xsc
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
decl_stmt|;
name|int
name|i
decl_stmt|;
name|VX_BUSY_WAIT
expr_stmt|;
name|GO_WINDOW
argument_list|(
literal|2
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|6
condition|;
name|i
operator|++
control|)
comment|/* Reload the ether_addr. */
name|outb
argument_list|(
name|BASE
operator|+
name|VX_W2_ADDR_0
operator|+
name|i
argument_list|,
name|sc
operator|->
name|arpcom
operator|.
name|ac_enaddr
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|outw
argument_list|(
name|BASE
operator|+
name|VX_COMMAND
argument_list|,
name|RX_RESET
argument_list|)
expr_stmt|;
name|VX_BUSY_WAIT
expr_stmt|;
name|outw
argument_list|(
name|BASE
operator|+
name|VX_COMMAND
argument_list|,
name|TX_RESET
argument_list|)
expr_stmt|;
name|VX_BUSY_WAIT
expr_stmt|;
name|GO_WINDOW
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* Window 1 is operating window */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|31
condition|;
name|i
operator|++
control|)
name|inb
argument_list|(
name|BASE
operator|+
name|VX_W1_TX_STATUS
argument_list|)
expr_stmt|;
name|outw
argument_list|(
name|BASE
operator|+
name|VX_COMMAND
argument_list|,
name|SET_RD_0_MASK
operator||
name|S_CARD_FAILURE
operator||
name|S_RX_COMPLETE
operator||
name|S_TX_COMPLETE
operator||
name|S_TX_AVAIL
argument_list|)
expr_stmt|;
name|outw
argument_list|(
name|BASE
operator|+
name|VX_COMMAND
argument_list|,
name|SET_INTR_MASK
operator||
name|S_CARD_FAILURE
operator||
name|S_RX_COMPLETE
operator||
name|S_TX_COMPLETE
operator||
name|S_TX_AVAIL
argument_list|)
expr_stmt|;
comment|/*      * Attempt to get rid of any stray interrupts that occured during      * configuration.  On the i386 this isn't possible because one may      * already be queued.  However, a single stray interrupt is      * unimportant.      */
name|outw
argument_list|(
name|BASE
operator|+
name|VX_COMMAND
argument_list|,
name|ACK_INTR
operator||
literal|0xff
argument_list|)
expr_stmt|;
name|vxsetfilter
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|vxsetlink
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|outw
argument_list|(
name|BASE
operator|+
name|VX_COMMAND
argument_list|,
name|RX_ENABLE
argument_list|)
expr_stmt|;
name|outw
argument_list|(
name|BASE
operator|+
name|VX_COMMAND
argument_list|,
name|TX_ENABLE
argument_list|)
expr_stmt|;
name|vxmbuffill
argument_list|(
operator|(
name|caddr_t
operator|)
name|sc
argument_list|)
expr_stmt|;
comment|/* Interface is now `running', with no output active. */
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_RUNNING
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
name|IFF_OACTIVE
expr_stmt|;
comment|/* Attempt to start output, if any. */
name|vxstart
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|vxsetfilter
parameter_list|(
name|sc
parameter_list|)
name|struct
name|vx_softc
modifier|*
name|sc
decl_stmt|;
block|{
specifier|register
name|struct
name|ifnet
modifier|*
name|ifp
init|=
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
decl_stmt|;
name|GO_WINDOW
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* Window 1 is operating window */
name|outw
argument_list|(
name|BASE
operator|+
name|VX_COMMAND
argument_list|,
name|SET_RX_FILTER
operator||
name|FIL_INDIVIDUAL
operator||
name|FIL_BRDCST
operator||
name|FIL_MULTICAST
operator||
operator|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_PROMISC
operator|)
condition|?
name|FIL_PROMISC
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|vxgetlink
parameter_list|(
name|sc
parameter_list|)
name|struct
name|vx_softc
modifier|*
name|sc
decl_stmt|;
block|{
name|int
name|n
decl_stmt|,
name|k
decl_stmt|;
name|GO_WINDOW
argument_list|(
literal|3
argument_list|)
expr_stmt|;
name|sc
operator|->
name|vx_connectors
operator|=
name|inw
argument_list|(
name|BASE
operator|+
name|VX_W3_RESET_OPT
argument_list|)
operator|&
literal|0x7f
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
operator|,
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|VX_CONNECTORS
condition|;
name|k
operator|++
control|)
block|{
if|if
condition|(
name|sc
operator|->
name|vx_connectors
operator|&
name|conn_tab
index|[
name|k
index|]
operator|.
name|bit
condition|)
block|{
if|if
condition|(
name|n
operator|>
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"/"
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|conn_tab
index|[
name|k
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
name|n
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|sc
operator|->
name|vx_connectors
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"no connectors!"
argument_list|)
expr_stmt|;
return|return;
block|}
name|GO_WINDOW
argument_list|(
literal|3
argument_list|)
expr_stmt|;
name|sc
operator|->
name|vx_connector
operator|=
operator|(
name|inl
argument_list|(
name|BASE
operator|+
name|VX_W3_INTERNAL_CFG
argument_list|)
operator|&
name|INTERNAL_CONNECTOR_MASK
operator|)
operator|>>
name|INTERNAL_CONNECTOR_BITS
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|vx_connector
operator|&
literal|0x10
condition|)
block|{
name|sc
operator|->
name|vx_connector
operator|&=
literal|0x0f
expr_stmt|;
name|printf
argument_list|(
literal|"[*%s*]"
argument_list|,
name|conn_tab
index|[
operator|(
name|int
operator|)
name|sc
operator|->
name|vx_connector
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|": disable 'auto select' with DOS util!"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"[*%s*]"
argument_list|,
name|conn_tab
index|[
operator|(
name|int
operator|)
name|sc
operator|->
name|vx_connector
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|vxsetlink
parameter_list|(
name|sc
parameter_list|)
name|struct
name|vx_softc
modifier|*
name|sc
decl_stmt|;
block|{
specifier|register
name|struct
name|ifnet
modifier|*
name|ifp
init|=
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|;
name|char
modifier|*
name|reason
decl_stmt|,
modifier|*
name|warning
decl_stmt|;
specifier|static
name|short
name|prev_flags
decl_stmt|;
specifier|static
name|char
name|prev_conn
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|prev_conn
operator|==
operator|-
literal|1
condition|)
block|{
name|prev_conn
operator|=
name|sc
operator|->
name|vx_connector
expr_stmt|;
block|}
comment|/*      * S.B.      *      * Now behavior was slightly changed:      *      * if any of flags link[0-2] is used and its connector is      * physically present the following connectors are used:      *      *   link0 - AUI * highest precedence      *   link1 - BNC      *   link2 - UTP * lowest precedence      *      * If none of them is specified then      * connector specified in the EEPROM is used      * (if present on card or UTP if not).      */
name|i
operator|=
name|sc
operator|->
name|vx_connector
expr_stmt|;
comment|/* default in EEPROM */
name|reason
operator|=
literal|"default"
expr_stmt|;
name|warning
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_LINK0
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|vx_connectors
operator|&
name|conn_tab
index|[
name|CONNECTOR_AUI
index|]
operator|.
name|bit
condition|)
block|{
name|i
operator|=
name|CONNECTOR_AUI
expr_stmt|;
name|reason
operator|=
literal|"link0"
expr_stmt|;
block|}
else|else
block|{
name|warning
operator|=
literal|"aui not present! (link0)"
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_LINK1
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|vx_connectors
operator|&
name|conn_tab
index|[
name|CONNECTOR_BNC
index|]
operator|.
name|bit
condition|)
block|{
name|i
operator|=
name|CONNECTOR_BNC
expr_stmt|;
name|reason
operator|=
literal|"link1"
expr_stmt|;
block|}
else|else
block|{
name|warning
operator|=
literal|"bnc not present! (link1)"
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_LINK2
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|vx_connectors
operator|&
name|conn_tab
index|[
name|CONNECTOR_UTP
index|]
operator|.
name|bit
condition|)
block|{
name|i
operator|=
name|CONNECTOR_UTP
expr_stmt|;
name|reason
operator|=
literal|"link2"
expr_stmt|;
block|}
else|else
block|{
name|warning
operator|=
literal|"utp not present! (link2)"
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|sc
operator|->
name|vx_connectors
operator|&
name|conn_tab
index|[
operator|(
name|int
operator|)
name|sc
operator|->
name|vx_connector
index|]
operator|.
name|bit
operator|)
operator|==
literal|0
condition|)
block|{
name|warning
operator|=
literal|"strange connector type in EEPROM."
expr_stmt|;
name|reason
operator|=
literal|"forced"
expr_stmt|;
name|i
operator|=
name|CONNECTOR_UTP
expr_stmt|;
block|}
comment|/* Avoid unnecessary message. */
name|k
operator|=
operator|(
name|prev_flags
operator|^
name|ifp
operator|->
name|if_flags
operator|)
operator|&
operator|(
name|IFF_LINK0
operator||
name|IFF_LINK1
operator||
name|IFF_LINK2
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|k
operator|!=
literal|0
operator|)
operator|||
operator|(
name|prev_conn
operator|!=
name|i
operator|)
condition|)
block|{
if|if
condition|(
name|warning
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"vx%d: warning: %s\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|,
name|warning
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"vx%d: selected %s. (%s)\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|,
name|conn_tab
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|reason
argument_list|)
expr_stmt|;
block|}
comment|/* Set the selected connector. */
name|GO_WINDOW
argument_list|(
literal|3
argument_list|)
expr_stmt|;
name|j
operator|=
name|inl
argument_list|(
name|BASE
operator|+
name|VX_W3_INTERNAL_CFG
argument_list|)
operator|&
operator|~
name|INTERNAL_CONNECTOR_MASK
expr_stmt|;
name|outl
argument_list|(
name|BASE
operator|+
name|VX_W3_INTERNAL_CFG
argument_list|,
name|j
operator||
operator|(
name|i
operator|<<
name|INTERNAL_CONNECTOR_BITS
operator|)
argument_list|)
expr_stmt|;
comment|/* First, disable all. */
name|outw
argument_list|(
name|BASE
operator|+
name|VX_COMMAND
argument_list|,
name|STOP_TRANSCEIVER
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|800
argument_list|)
expr_stmt|;
name|GO_WINDOW
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|outw
argument_list|(
name|BASE
operator|+
name|VX_W4_MEDIA_TYPE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Second, enable the selected one. */
switch|switch
condition|(
name|i
condition|)
block|{
case|case
name|CONNECTOR_UTP
case|:
name|GO_WINDOW
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|outw
argument_list|(
name|BASE
operator|+
name|VX_W4_MEDIA_TYPE
argument_list|,
name|ENABLE_UTP
argument_list|)
expr_stmt|;
break|break;
case|case
name|CONNECTOR_BNC
case|:
name|outw
argument_list|(
name|BASE
operator|+
name|VX_COMMAND
argument_list|,
name|START_TRANSCEIVER
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|800
argument_list|)
expr_stmt|;
break|break;
case|case
name|CONNECTOR_TX
case|:
case|case
name|CONNECTOR_FX
case|:
name|GO_WINDOW
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|outw
argument_list|(
name|BASE
operator|+
name|VX_W4_MEDIA_TYPE
argument_list|,
name|LINKBEAT_ENABLE
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* AUI and MII fall here */
break|break;
block|}
name|GO_WINDOW
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|prev_flags
operator|=
name|ifp
operator|->
name|if_flags
expr_stmt|;
name|prev_conn
operator|=
name|i
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|vxstart
parameter_list|(
name|ifp
parameter_list|)
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
block|{
specifier|register
name|struct
name|vx_softc
modifier|*
name|sc
init|=
name|vx_softc
index|[
name|ifp
operator|->
name|if_unit
index|]
decl_stmt|;
specifier|register
name|struct
name|mbuf
modifier|*
name|m0
decl_stmt|;
name|int
name|sh
decl_stmt|,
name|len
decl_stmt|,
name|pad
decl_stmt|;
comment|/* Don't transmit if interface is busy or not running */
if|if
condition|(
operator|(
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_flags
operator|&
operator|(
name|IFF_RUNNING
operator||
name|IFF_OACTIVE
operator|)
operator|)
operator|!=
name|IFF_RUNNING
condition|)
return|return;
name|startagain
label|:
comment|/* Sneak a peek at the next packet */
name|m0
operator|=
name|ifp
operator|->
name|if_snd
operator|.
name|ifq_head
expr_stmt|;
if|if
condition|(
name|m0
operator|==
literal|0
condition|)
block|{
return|return;
block|}
comment|/* We need to use m->m_pkthdr.len, so require the header */
if|if
condition|(
operator|(
name|m0
operator|->
name|m_flags
operator|&
name|M_PKTHDR
operator|)
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"vxstart: no header mbuf"
argument_list|)
expr_stmt|;
name|len
operator|=
name|m0
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
name|pad
operator|=
operator|(
literal|4
operator|-
name|len
operator|)
operator|&
literal|3
expr_stmt|;
comment|/*      * The 3c509 automatically pads short packets to minimum ethernet length,      * but we drop packets that are too large. Perhaps we should truncate      * them instead?      */
if|if
condition|(
name|len
operator|+
name|pad
operator|>
name|ETHER_MAX_LEN
condition|)
block|{
comment|/* packet is obviously too large: toss it */
operator|++
name|ifp
operator|->
name|if_oerrors
expr_stmt|;
name|IF_DEQUEUE
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|m0
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
goto|goto
name|readcheck
goto|;
block|}
name|VX_BUSY_WAIT
expr_stmt|;
if|if
condition|(
name|inw
argument_list|(
name|BASE
operator|+
name|VX_W1_FREE_TX
argument_list|)
operator|<
name|len
operator|+
name|pad
operator|+
literal|4
condition|)
block|{
name|outw
argument_list|(
name|BASE
operator|+
name|VX_COMMAND
argument_list|,
name|SET_TX_AVAIL_THRESH
operator||
operator|(
operator|(
name|len
operator|+
name|pad
operator|+
literal|4
operator|)
operator|>>
literal|2
operator|)
argument_list|)
expr_stmt|;
comment|/* not enough room in FIFO */
if|if
condition|(
name|inw
argument_list|(
name|BASE
operator|+
name|VX_W1_FREE_TX
argument_list|)
operator|<
name|len
operator|+
name|pad
operator|+
literal|4
condition|)
block|{
comment|/* make sure */
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_OACTIVE
expr_stmt|;
name|ifp
operator|->
name|if_timer
operator|=
literal|1
expr_stmt|;
return|return;
block|}
block|}
name|outw
argument_list|(
name|BASE
operator|+
name|VX_COMMAND
argument_list|,
name|SET_TX_AVAIL_THRESH
operator||
operator|(
literal|8188
operator|>>
literal|2
operator|)
argument_list|)
expr_stmt|;
name|IF_DEQUEUE
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|m0
argument_list|)
expr_stmt|;
if|if
condition|(
name|m0
operator|==
name|NULL
condition|)
block|{
comment|/* not really needed */
return|return;
block|}
name|VX_BUSY_WAIT
expr_stmt|;
name|outw
argument_list|(
name|BASE
operator|+
name|VX_COMMAND
argument_list|,
name|SET_TX_START_THRESH
operator||
operator|(
operator|(
name|len
operator|/
literal|4
operator|+
name|sc
operator|->
name|tx_start_thresh
operator|)
operator|>>
literal|2
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_bpf
condition|)
block|{
name|bpf_mtap
argument_list|(
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
argument_list|,
name|m0
argument_list|)
expr_stmt|;
block|}
comment|/*      * Do the output at splhigh() so that an interrupt from another device      * won't cause a FIFO underrun.      */
name|sh
operator|=
name|splhigh
argument_list|()
expr_stmt|;
name|outl
argument_list|(
name|BASE
operator|+
name|VX_W1_TX_PIO_WR_1
argument_list|,
name|len
operator||
name|TX_INDICATE
argument_list|)
expr_stmt|;
while|while
condition|(
name|m0
condition|)
block|{
if|if
condition|(
name|m0
operator|->
name|m_len
operator|>
literal|3
condition|)
name|outsl
argument_list|(
name|BASE
operator|+
name|VX_W1_TX_PIO_WR_1
argument_list|,
name|mtod
argument_list|(
name|m0
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
name|m0
operator|->
name|m_len
operator|/
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|m0
operator|->
name|m_len
operator|&
literal|3
condition|)
name|outsb
argument_list|(
name|BASE
operator|+
name|VX_W1_TX_PIO_WR_1
argument_list|,
name|mtod
argument_list|(
name|m0
argument_list|,
name|caddr_t
argument_list|)
operator|+
operator|(
name|m0
operator|->
name|m_len
operator|&
operator|~
literal|3
operator|)
argument_list|,
name|m0
operator|->
name|m_len
operator|&
literal|3
argument_list|)
expr_stmt|;
name|m0
operator|=
name|m_free
argument_list|(
name|m0
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|pad
operator|--
condition|)
name|outb
argument_list|(
name|BASE
operator|+
name|VX_W1_TX_PIO_WR_1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Padding */
name|splx
argument_list|(
name|sh
argument_list|)
expr_stmt|;
operator|++
name|ifp
operator|->
name|if_opackets
expr_stmt|;
name|ifp
operator|->
name|if_timer
operator|=
literal|1
expr_stmt|;
name|readcheck
label|:
if|if
condition|(
operator|(
name|inw
argument_list|(
name|BASE
operator|+
name|VX_W1_RX_STATUS
argument_list|)
operator|&
name|ERR_INCOMPLETE
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* We received a complete packet. */
if|if
condition|(
operator|(
name|inw
argument_list|(
name|BASE
operator|+
name|VX_STATUS
argument_list|)
operator|&
name|S_INTR_LATCH
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 	     * No interrupt, read the packet and continue 	     * Is  this supposed to happen? Is my motherboard 	     * completely busted? 	     */
name|vxread
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* Got an interrupt, return so that it gets serviced. */
return|return;
block|}
else|else
block|{
comment|/* Check if we are stuck and reset [see XXX comment] */
if|if
condition|(
name|vxstatus
argument_list|(
name|sc
argument_list|)
condition|)
block|{
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_DEBUG
condition|)
name|printf
argument_list|(
literal|"vx%d: adapter reset\n"
argument_list|,
name|ifp
operator|->
name|if_unit
argument_list|)
expr_stmt|;
name|vxreset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
block|}
goto|goto
name|startagain
goto|;
block|}
end_function

begin_comment
comment|/*  * XXX: The 3c509 card can get in a mode where both the fifo status bit  *      FIFOS_RX_OVERRUN and the status bit ERR_INCOMPLETE are set  *      We detect this situation and we reset the adapter.  *      It happens at times when there is a lot of broadcast traffic  *      on the cable (once in a blue moon).  */
end_comment

begin_function
specifier|static
name|int
name|vxstatus
parameter_list|(
name|sc
parameter_list|)
name|struct
name|vx_softc
modifier|*
name|sc
decl_stmt|;
block|{
name|int
name|fifost
decl_stmt|;
comment|/*      * Check the FIFO status and act accordingly      */
name|GO_WINDOW
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|fifost
operator|=
name|inw
argument_list|(
name|BASE
operator|+
name|VX_W4_FIFO_DIAG
argument_list|)
expr_stmt|;
name|GO_WINDOW
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|fifost
operator|&
name|FIFOS_RX_UNDERRUN
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_flags
operator|&
name|IFF_DEBUG
condition|)
name|printf
argument_list|(
literal|"vx%d: RX underrun\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
name|vxreset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|fifost
operator|&
name|FIFOS_RX_STATUS_OVERRUN
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_flags
operator|&
name|IFF_DEBUG
condition|)
name|printf
argument_list|(
literal|"vx%d: RX Status overrun\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|fifost
operator|&
name|FIFOS_RX_OVERRUN
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_flags
operator|&
name|IFF_DEBUG
condition|)
name|printf
argument_list|(
literal|"vx%d: RX overrun\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|fifost
operator|&
name|FIFOS_TX_OVERRUN
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_flags
operator|&
name|IFF_DEBUG
condition|)
name|printf
argument_list|(
literal|"vx%d: TX overrun\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
name|vxreset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|vxtxstat
parameter_list|(
name|sc
parameter_list|)
name|struct
name|vx_softc
modifier|*
name|sc
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
comment|/*     * We need to read+write TX_STATUS until we get a 0 status     * in order to turn off the interrupt flag.     */
while|while
condition|(
operator|(
name|i
operator|=
name|inb
argument_list|(
name|BASE
operator|+
name|VX_W1_TX_STATUS
argument_list|)
operator|)
operator|&
name|TXS_COMPLETE
condition|)
block|{
name|outb
argument_list|(
name|BASE
operator|+
name|VX_W1_TX_STATUS
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|&
name|TXS_JABBER
condition|)
block|{
operator|++
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_oerrors
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_flags
operator|&
name|IFF_DEBUG
condition|)
name|printf
argument_list|(
literal|"vx%d: jabber (%x)\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|vxreset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|i
operator|&
name|TXS_UNDERRUN
condition|)
block|{
operator|++
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_oerrors
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_flags
operator|&
name|IFF_DEBUG
condition|)
name|printf
argument_list|(
literal|"vx%d: fifo underrun (%x) @%d\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|,
name|i
argument_list|,
name|sc
operator|->
name|tx_start_thresh
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|tx_succ_ok
operator|<
literal|100
condition|)
name|sc
operator|->
name|tx_start_thresh
operator|=
name|min
argument_list|(
name|ETHER_MAX_LEN
argument_list|,
name|sc
operator|->
name|tx_start_thresh
operator|+
literal|20
argument_list|)
expr_stmt|;
name|sc
operator|->
name|tx_succ_ok
operator|=
literal|0
expr_stmt|;
name|vxreset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|i
operator|&
name|TXS_MAX_COLLISION
condition|)
block|{
operator|++
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_collisions
expr_stmt|;
name|outw
argument_list|(
name|BASE
operator|+
name|VX_COMMAND
argument_list|,
name|TX_ENABLE
argument_list|)
expr_stmt|;
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_flags
operator|&=
operator|~
name|IFF_OACTIVE
expr_stmt|;
block|}
else|else
name|sc
operator|->
name|tx_succ_ok
operator|=
operator|(
name|sc
operator|->
name|tx_succ_ok
operator|+
literal|1
operator|)
operator|&
literal|127
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|vxintr
parameter_list|(
name|voidsc
parameter_list|)
name|void
modifier|*
name|voidsc
decl_stmt|;
block|{
specifier|register
name|short
name|status
decl_stmt|;
name|struct
name|vx_softc
modifier|*
name|sc
init|=
name|voidsc
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|outw
argument_list|(
name|BASE
operator|+
name|VX_COMMAND
argument_list|,
name|C_INTR_LATCH
argument_list|)
expr_stmt|;
name|status
operator|=
name|inw
argument_list|(
name|BASE
operator|+
name|VX_STATUS
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|status
operator|&
operator|(
name|S_TX_COMPLETE
operator||
name|S_TX_AVAIL
operator||
name|S_RX_COMPLETE
operator||
name|S_CARD_FAILURE
operator|)
operator|)
operator|==
literal|0
condition|)
break|break;
comment|/* 	 * Acknowledge any interrupts.  It's important that we do this 	 * first, since there would otherwise be a race condition. 	 * Due to the i386 interrupt queueing, we may get spurious 	 * interrupts occasionally. 	 */
name|outw
argument_list|(
name|BASE
operator|+
name|VX_COMMAND
argument_list|,
name|ACK_INTR
operator||
name|status
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|&
name|S_RX_COMPLETE
condition|)
name|vxread
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|&
name|S_TX_AVAIL
condition|)
block|{
name|ifp
operator|->
name|if_timer
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_flags
operator|&=
operator|~
name|IFF_OACTIVE
expr_stmt|;
name|vxstart
argument_list|(
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|status
operator|&
name|S_CARD_FAILURE
condition|)
block|{
name|printf
argument_list|(
literal|"vx%d: adapter failure (%x)\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_timer
operator|=
literal|0
expr_stmt|;
name|vxreset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|status
operator|&
name|S_TX_COMPLETE
condition|)
block|{
name|ifp
operator|->
name|if_timer
operator|=
literal|0
expr_stmt|;
name|vxtxstat
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|vxstart
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* no more interrupts */
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|vxread
parameter_list|(
name|sc
parameter_list|)
name|struct
name|vx_softc
modifier|*
name|sc
decl_stmt|;
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|ether_header
modifier|*
name|eh
decl_stmt|;
name|u_int
name|len
decl_stmt|;
name|len
operator|=
name|inw
argument_list|(
name|BASE
operator|+
name|VX_W1_RX_STATUS
argument_list|)
expr_stmt|;
name|again
label|:
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_DEBUG
condition|)
block|{
name|int
name|err
init|=
name|len
operator|&
name|ERR_MASK
decl_stmt|;
name|char
modifier|*
name|s
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|len
operator|&
name|ERR_INCOMPLETE
condition|)
name|s
operator|=
literal|"incomplete packet"
expr_stmt|;
elseif|else
if|if
condition|(
name|err
operator|==
name|ERR_OVERRUN
condition|)
name|s
operator|=
literal|"packet overrun"
expr_stmt|;
elseif|else
if|if
condition|(
name|err
operator|==
name|ERR_RUNT
condition|)
name|s
operator|=
literal|"runt packet"
expr_stmt|;
elseif|else
if|if
condition|(
name|err
operator|==
name|ERR_ALIGNMENT
condition|)
name|s
operator|=
literal|"bad alignment"
expr_stmt|;
elseif|else
if|if
condition|(
name|err
operator|==
name|ERR_CRC
condition|)
name|s
operator|=
literal|"bad crc"
expr_stmt|;
elseif|else
if|if
condition|(
name|err
operator|==
name|ERR_OVERSIZE
condition|)
name|s
operator|=
literal|"oversized packet"
expr_stmt|;
elseif|else
if|if
condition|(
name|err
operator|==
name|ERR_DRIBBLE
condition|)
name|s
operator|=
literal|"dribble bits"
expr_stmt|;
if|if
condition|(
name|s
condition|)
name|printf
argument_list|(
literal|"vx%d: %s\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|len
operator|&
name|ERR_INCOMPLETE
condition|)
return|return;
if|if
condition|(
name|len
operator|&
name|ERR_RX
condition|)
block|{
operator|++
name|ifp
operator|->
name|if_ierrors
expr_stmt|;
goto|goto
name|abort
goto|;
block|}
name|len
operator|&=
name|RX_BYTES_MASK
expr_stmt|;
comment|/* Lower 11 bits = RX bytes. */
comment|/* Pull packet off interface. */
name|m
operator|=
name|vxget
argument_list|(
name|sc
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
literal|0
condition|)
block|{
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
goto|goto
name|abort
goto|;
block|}
operator|++
name|ifp
operator|->
name|if_ipackets
expr_stmt|;
comment|/* We assume the header fit entirely in one mbuf. */
name|eh
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ether_header
operator|*
argument_list|)
expr_stmt|;
comment|/*      * XXX: Some cards seem to be in promiscous mode all the time.      * we need to make sure we only get our own stuff always.      * bleah!      */
if|if
condition|(
operator|(
name|eh
operator|->
name|ether_dhost
index|[
literal|0
index|]
operator|&
literal|1
operator|)
operator|==
literal|0
comment|/* !mcast and !bcast */
operator|&&
name|bcmp
argument_list|(
name|eh
operator|->
name|ether_dhost
argument_list|,
name|sc
operator|->
name|arpcom
operator|.
name|ac_enaddr
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return;
block|}
name|m_adj
argument_list|(
name|m
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
argument_list|)
expr_stmt|;
name|ether_input
argument_list|(
name|ifp
argument_list|,
name|eh
argument_list|,
name|m
argument_list|)
expr_stmt|;
comment|/*     * In periods of high traffic we can actually receive enough     * packets so that the fifo overrun bit will be set at this point,     * even though we just read a packet. In this case we     * are not going to receive any more interrupts. We check for     * this condition and read again until the fifo is not full.     * We could simplify this test by not using vxstatus(), but     * rechecking the RX_STATUS register directly. This test could     * result in unnecessary looping in cases where there is a new     * packet but the fifo is not full, but it will not fix the     * stuck behavior.     *     * Even with this improvement, we still get packet overrun errors     * which are hurting performance. Maybe when I get some more time     * I'll modify vxread() so that it can handle RX_EARLY interrupts.     */
if|if
condition|(
name|vxstatus
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|len
operator|=
name|inw
argument_list|(
name|BASE
operator|+
name|VX_W1_RX_STATUS
argument_list|)
expr_stmt|;
comment|/* Check if we are stuck and reset [see XXX comment] */
if|if
condition|(
name|len
operator|&
name|ERR_INCOMPLETE
condition|)
block|{
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_DEBUG
condition|)
name|printf
argument_list|(
literal|"vx%d: adapter reset\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
name|vxreset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
goto|goto
name|again
goto|;
block|}
return|return;
name|abort
label|:
name|outw
argument_list|(
name|BASE
operator|+
name|VX_COMMAND
argument_list|,
name|RX_DISCARD_TOP_PACK
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|struct
name|mbuf
modifier|*
name|vxget
parameter_list|(
name|sc
parameter_list|,
name|totlen
parameter_list|)
name|struct
name|vx_softc
modifier|*
name|sc
decl_stmt|;
name|u_int
name|totlen
decl_stmt|;
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|top
decl_stmt|,
modifier|*
modifier|*
name|mp
decl_stmt|,
modifier|*
name|m
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
name|sh
decl_stmt|;
name|m
operator|=
name|sc
operator|->
name|mb
index|[
name|sc
operator|->
name|next_mb
index|]
expr_stmt|;
name|sc
operator|->
name|mb
index|[
name|sc
operator|->
name|next_mb
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|m
operator|==
literal|0
condition|)
block|{
name|MGETHDR
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
literal|0
condition|)
return|return
literal|0
return|;
block|}
else|else
block|{
comment|/* If the queue is no longer full, refill. */
if|if
condition|(
name|sc
operator|->
name|last_mb
operator|==
name|sc
operator|->
name|next_mb
operator|&&
name|sc
operator|->
name|buffill_pending
operator|==
literal|0
condition|)
block|{
name|sc
operator|->
name|ch
operator|=
name|timeout
argument_list|(
name|vxmbuffill
argument_list|,
name|sc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|sc
operator|->
name|buffill_pending
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Convert one of our saved mbuf's. */
name|sc
operator|->
name|next_mb
operator|=
operator|(
name|sc
operator|->
name|next_mb
operator|+
literal|1
operator|)
operator|%
name|MAX_MBS
expr_stmt|;
name|m
operator|->
name|m_data
operator|=
name|m
operator|->
name|m_pktdat
expr_stmt|;
name|m
operator|->
name|m_flags
operator|=
name|M_PKTHDR
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|m
operator|->
name|m_pkthdr
argument_list|,
sizeof|sizeof
argument_list|(
name|m
operator|->
name|m_pkthdr
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|ifp
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|totlen
expr_stmt|;
name|len
operator|=
name|MHLEN
expr_stmt|;
name|top
operator|=
literal|0
expr_stmt|;
name|mp
operator|=
operator|&
name|top
expr_stmt|;
comment|/*      * We read the packet at splhigh() so that an interrupt from another      * device doesn't cause the card's buffer to overflow while we're      * reading it.  We may still lose packets at other times.      */
name|sh
operator|=
name|splhigh
argument_list|()
expr_stmt|;
comment|/*      * Since we don't set allowLargePackets bit in MacControl register,      * we can assume that totlen<= 1500bytes.      * The while loop will be performed iff we have a packet with      * MLEN< m_len< MINCLSIZE.      */
while|while
condition|(
name|totlen
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|top
condition|)
block|{
name|m
operator|=
name|sc
operator|->
name|mb
index|[
name|sc
operator|->
name|next_mb
index|]
expr_stmt|;
name|sc
operator|->
name|mb
index|[
name|sc
operator|->
name|next_mb
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|m
operator|==
literal|0
condition|)
block|{
name|MGET
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
literal|0
condition|)
block|{
name|splx
argument_list|(
name|sh
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|top
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
else|else
block|{
name|sc
operator|->
name|next_mb
operator|=
operator|(
name|sc
operator|->
name|next_mb
operator|+
literal|1
operator|)
operator|%
name|MAX_MBS
expr_stmt|;
block|}
name|len
operator|=
name|MLEN
expr_stmt|;
block|}
if|if
condition|(
name|totlen
operator|>=
name|MINCLSIZE
condition|)
block|{
name|MCLGET
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_flags
operator|&
name|M_EXT
condition|)
name|len
operator|=
name|MCLBYTES
expr_stmt|;
block|}
name|len
operator|=
name|min
argument_list|(
name|totlen
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
literal|3
condition|)
name|insl
argument_list|(
name|BASE
operator|+
name|VX_W1_RX_PIO_RD_1
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
name|u_int32_t
operator|*
argument_list|)
argument_list|,
name|len
operator|/
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|&
literal|3
condition|)
block|{
name|insb
argument_list|(
name|BASE
operator|+
name|VX_W1_RX_PIO_RD_1
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
name|u_int8_t
operator|*
argument_list|)
operator|+
operator|(
name|len
operator|&
operator|~
literal|3
operator|)
argument_list|,
name|len
operator|&
literal|3
argument_list|)
expr_stmt|;
block|}
name|m
operator|->
name|m_len
operator|=
name|len
expr_stmt|;
name|totlen
operator|-=
name|len
expr_stmt|;
operator|*
name|mp
operator|=
name|m
expr_stmt|;
name|mp
operator|=
operator|&
name|m
operator|->
name|m_next
expr_stmt|;
block|}
name|outw
argument_list|(
name|BASE
operator|+
name|VX_COMMAND
argument_list|,
name|RX_DISCARD_TOP_PACK
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|sh
argument_list|)
expr_stmt|;
return|return
name|top
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|vxioctl
parameter_list|(
name|ifp
parameter_list|,
name|cmd
parameter_list|,
name|data
parameter_list|)
specifier|register
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|u_long
name|cmd
decl_stmt|;
name|caddr_t
name|data
decl_stmt|;
block|{
name|struct
name|vx_softc
modifier|*
name|sc
init|=
name|vx_softc
index|[
name|ifp
operator|->
name|if_unit
index|]
decl_stmt|;
name|struct
name|ifreq
modifier|*
name|ifr
init|=
operator|(
expr|struct
name|ifreq
operator|*
operator|)
name|data
decl_stmt|;
name|int
name|s
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|SIOCSIFADDR
case|:
case|case
name|SIOCGIFADDR
case|:
name|ether_ioctl
argument_list|(
name|ifp
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCSIFFLAGS
case|:
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
operator|)
operator|==
literal|0
operator|&&
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/*              * If interface is marked up and it is stopped, then              * start it.              */
name|vxstop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
name|IFF_RUNNING
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
operator|)
operator|==
literal|0
condition|)
block|{
comment|/*              * If interface is marked up and it is stopped, then              * start it.              */
name|vxinit
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/*              * deal with flags changes:              * IFF_MULTICAST, IFF_PROMISC,              * IFF_LINK0, IFF_LINK1,              */
name|vxsetfilter
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|vxsetlink
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SIOCSIFMTU
case|:
comment|/*          * Set the interface MTU.          */
if|if
condition|(
name|ifr
operator|->
name|ifr_mtu
operator|>
name|ETHERMTU
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
else|else
block|{
name|ifp
operator|->
name|if_mtu
operator|=
name|ifr
operator|->
name|ifr_mtu
expr_stmt|;
block|}
break|break;
case|case
name|SIOCADDMULTI
case|:
case|case
name|SIOCDELMULTI
case|:
comment|/* 	 * Multicast list has changed; set the hardware filter 	 * accordingly. 	 */
name|vxreset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|vxreset
parameter_list|(
name|sc
parameter_list|)
name|struct
name|vx_softc
modifier|*
name|sc
decl_stmt|;
block|{
name|int
name|s
decl_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|vxstop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|vxinit
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|vxwatchdog
parameter_list|(
name|ifp
parameter_list|)
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
block|{
name|struct
name|vx_softc
modifier|*
name|sc
init|=
name|vx_softc
index|[
name|ifp
operator|->
name|if_unit
index|]
decl_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_DEBUG
condition|)
name|printf
argument_list|(
literal|"vx%d: device timeout\n"
argument_list|,
name|ifp
operator|->
name|if_unit
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
name|IFF_OACTIVE
expr_stmt|;
name|vxstart
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|vxintr
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|vxstop
parameter_list|(
name|sc
parameter_list|)
name|struct
name|vx_softc
modifier|*
name|sc
decl_stmt|;
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
decl_stmt|;
name|ifp
operator|->
name|if_timer
operator|=
literal|0
expr_stmt|;
name|outw
argument_list|(
name|BASE
operator|+
name|VX_COMMAND
argument_list|,
name|RX_DISABLE
argument_list|)
expr_stmt|;
name|outw
argument_list|(
name|BASE
operator|+
name|VX_COMMAND
argument_list|,
name|RX_DISCARD_TOP_PACK
argument_list|)
expr_stmt|;
name|VX_BUSY_WAIT
expr_stmt|;
name|outw
argument_list|(
name|BASE
operator|+
name|VX_COMMAND
argument_list|,
name|TX_DISABLE
argument_list|)
expr_stmt|;
name|outw
argument_list|(
name|BASE
operator|+
name|VX_COMMAND
argument_list|,
name|STOP_TRANSCEIVER
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|800
argument_list|)
expr_stmt|;
name|outw
argument_list|(
name|BASE
operator|+
name|VX_COMMAND
argument_list|,
name|RX_RESET
argument_list|)
expr_stmt|;
name|VX_BUSY_WAIT
expr_stmt|;
name|outw
argument_list|(
name|BASE
operator|+
name|VX_COMMAND
argument_list|,
name|TX_RESET
argument_list|)
expr_stmt|;
name|VX_BUSY_WAIT
expr_stmt|;
name|outw
argument_list|(
name|BASE
operator|+
name|VX_COMMAND
argument_list|,
name|C_INTR_LATCH
argument_list|)
expr_stmt|;
name|outw
argument_list|(
name|BASE
operator|+
name|VX_COMMAND
argument_list|,
name|SET_RD_0_MASK
argument_list|)
expr_stmt|;
name|outw
argument_list|(
name|BASE
operator|+
name|VX_COMMAND
argument_list|,
name|SET_INTR_MASK
argument_list|)
expr_stmt|;
name|outw
argument_list|(
name|BASE
operator|+
name|VX_COMMAND
argument_list|,
name|SET_RX_FILTER
argument_list|)
expr_stmt|;
name|vxmbufempty
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|vxbusyeeprom
parameter_list|(
name|sc
parameter_list|)
name|struct
name|vx_softc
modifier|*
name|sc
decl_stmt|;
block|{
name|int
name|j
decl_stmt|,
name|i
init|=
literal|100
decl_stmt|;
while|while
condition|(
name|i
operator|--
condition|)
block|{
name|j
operator|=
name|inw
argument_list|(
name|BASE
operator|+
name|VX_W0_EEPROM_COMMAND
argument_list|)
expr_stmt|;
if|if
condition|(
name|j
operator|&
name|EEPROM_BUSY
condition|)
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
else|else
break|break;
block|}
if|if
condition|(
operator|!
name|i
condition|)
block|{
name|printf
argument_list|(
literal|"vx%d: eeprom failed to come ready\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|vxmbuffill
parameter_list|(
name|sp
parameter_list|)
name|void
modifier|*
name|sp
decl_stmt|;
block|{
name|struct
name|vx_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|vx_softc
operator|*
operator|)
name|sp
decl_stmt|;
name|int
name|s
decl_stmt|,
name|i
decl_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|i
operator|=
name|sc
operator|->
name|last_mb
expr_stmt|;
do|do
block|{
if|if
condition|(
name|sc
operator|->
name|mb
index|[
name|i
index|]
operator|==
name|NULL
condition|)
name|MGET
argument_list|(
name|sc
operator|->
name|mb
index|[
name|i
index|]
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|mb
index|[
name|i
index|]
operator|==
name|NULL
condition|)
break|break;
name|i
operator|=
operator|(
name|i
operator|+
literal|1
operator|)
operator|%
name|MAX_MBS
expr_stmt|;
block|}
do|while
condition|(
name|i
operator|!=
name|sc
operator|->
name|next_mb
condition|)
do|;
name|sc
operator|->
name|last_mb
operator|=
name|i
expr_stmt|;
comment|/* If the queue was not filled, try again. */
if|if
condition|(
name|sc
operator|->
name|last_mb
operator|!=
name|sc
operator|->
name|next_mb
condition|)
block|{
name|sc
operator|->
name|ch
operator|=
name|timeout
argument_list|(
name|vxmbuffill
argument_list|,
name|sc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|sc
operator|->
name|buffill_pending
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|buffill_pending
operator|=
literal|0
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|vxmbufempty
parameter_list|(
name|sc
parameter_list|)
name|struct
name|vx_softc
modifier|*
name|sc
decl_stmt|;
block|{
name|int
name|s
decl_stmt|,
name|i
decl_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_MBS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|sc
operator|->
name|mb
index|[
name|i
index|]
condition|)
block|{
name|m_freem
argument_list|(
name|sc
operator|->
name|mb
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|sc
operator|->
name|mb
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
block|}
block|}
name|sc
operator|->
name|last_mb
operator|=
name|sc
operator|->
name|next_mb
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|buffill_pending
operator|!=
literal|0
condition|)
name|untimeout
argument_list|(
name|vxmbuffill
argument_list|,
name|sc
argument_list|,
name|sc
operator|->
name|ch
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

