begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1996, Javier Mart√≠n Rueda (jmrueda@diatel.upm.es)  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice unmodified, this list of conditions, and the following  *    disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *  * MAINTAINER: Matthew N. Dodd<winter@jurai.net>  *<mdodd@FreeBSD.org>  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Intel EtherExpress Pro/10, Pro/10+ Ethernet driver  *  * Revision history:  *  * dd-mmm-yyyy: Multicast support ported from NetBSD's if_iy driver.  * 30-Oct-1996: first beta version. Inet and BPF supported, but no multicast.  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_arp.h>
end_include

begin_include
include|#
directive|include
file|<net/if_dl.h>
end_include

begin_include
include|#
directive|include
file|<net/if_media.h>
end_include

begin_include
include|#
directive|include
file|<net/if_types.h>
end_include

begin_include
include|#
directive|include
file|<net/ethernet.h>
end_include

begin_include
include|#
directive|include
file|<net/bpf.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/if_ether.h>
end_include

begin_include
include|#
directive|include
file|<isa/isavar.h>
end_include

begin_include
include|#
directive|include
file|<isa/pnpvar.h>
end_include

begin_include
include|#
directive|include
file|<dev/ex/if_exreg.h>
end_include

begin_include
include|#
directive|include
file|<dev/ex/if_exvar.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|EXDEBUG
end_ifdef

begin_define
define|#
directive|define
name|Start_End
value|1
end_define

begin_define
define|#
directive|define
name|Rcvd_Pkts
value|2
end_define

begin_define
define|#
directive|define
name|Sent_Pkts
value|4
end_define

begin_define
define|#
directive|define
name|Status
value|8
end_define

begin_decl_stmt
specifier|static
name|int
name|debug_mask
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|DODEBUG
parameter_list|(
name|level
parameter_list|,
name|action
parameter_list|)
value|if (level& debug_mask) action
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|DODEBUG
parameter_list|(
name|level
parameter_list|,
name|action
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|devclass_t
name|ex_devclass
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|irq2eemap
index|[]
init|=
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|,
literal|0
block|,
literal|1
block|,
operator|-
literal|1
block|,
literal|2
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
literal|0
block|,
literal|3
block|,
literal|4
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_char
name|ee2irqmap
index|[]
init|=
block|{
literal|9
block|,
literal|3
block|,
literal|5
block|,
literal|10
block|,
literal|11
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|plus_irq2eemap
index|[]
init|=
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|2
block|,
operator|-
literal|1
block|,
literal|3
block|,
operator|-
literal|1
block|,
literal|4
block|,
literal|5
block|,
literal|6
block|,
literal|7
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_char
name|plus_ee2irqmap
index|[]
init|=
block|{
literal|3
block|,
literal|4
block|,
literal|5
block|,
literal|7
block|,
literal|9
block|,
literal|10
block|,
literal|11
block|,
literal|12
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Network Interface Functions */
end_comment

begin_function_decl
specifier|static
name|void
name|ex_init
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ex_start
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ex_ioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|u_long
parameter_list|,
name|caddr_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ex_watchdog
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* ifmedia Functions	*/
end_comment

begin_function_decl
specifier|static
name|int
name|ex_ifmedia_upd
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ex_ifmedia_sts
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|struct
name|ifmediareq
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ex_get_media
parameter_list|(
name|struct
name|ex_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ex_reset
parameter_list|(
name|struct
name|ex_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ex_setmulti
parameter_list|(
name|struct
name|ex_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ex_tx_intr
parameter_list|(
name|struct
name|ex_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ex_rx_intr
parameter_list|(
name|struct
name|ex_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|void
name|ex_get_address
parameter_list|(
name|struct
name|ex_softc
modifier|*
name|sc
parameter_list|,
name|u_char
modifier|*
name|enaddr
parameter_list|)
block|{
name|uint16_t
name|eaddr_tmp
decl_stmt|;
name|eaddr_tmp
operator|=
name|ex_eeprom_read
argument_list|(
name|sc
argument_list|,
name|EE_Eth_Addr_Lo
argument_list|)
expr_stmt|;
name|enaddr
index|[
literal|5
index|]
operator|=
name|eaddr_tmp
operator|&
literal|0xff
expr_stmt|;
name|enaddr
index|[
literal|4
index|]
operator|=
name|eaddr_tmp
operator|>>
literal|8
expr_stmt|;
name|eaddr_tmp
operator|=
name|ex_eeprom_read
argument_list|(
name|sc
argument_list|,
name|EE_Eth_Addr_Mid
argument_list|)
expr_stmt|;
name|enaddr
index|[
literal|3
index|]
operator|=
name|eaddr_tmp
operator|&
literal|0xff
expr_stmt|;
name|enaddr
index|[
literal|2
index|]
operator|=
name|eaddr_tmp
operator|>>
literal|8
expr_stmt|;
name|eaddr_tmp
operator|=
name|ex_eeprom_read
argument_list|(
name|sc
argument_list|,
name|EE_Eth_Addr_Hi
argument_list|)
expr_stmt|;
name|enaddr
index|[
literal|1
index|]
operator|=
name|eaddr_tmp
operator|&
literal|0xff
expr_stmt|;
name|enaddr
index|[
literal|0
index|]
operator|=
name|eaddr_tmp
operator|>>
literal|8
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|int
name|ex_card_type
parameter_list|(
name|u_char
modifier|*
name|enaddr
parameter_list|)
block|{
if|if
condition|(
operator|(
name|enaddr
index|[
literal|0
index|]
operator|==
literal|0x00
operator|)
operator|&&
operator|(
name|enaddr
index|[
literal|1
index|]
operator|==
literal|0xA0
operator|)
operator|&&
operator|(
name|enaddr
index|[
literal|2
index|]
operator|==
literal|0xC9
operator|)
condition|)
return|return
operator|(
name|CARD_TYPE_EX_10_PLUS
operator|)
return|;
return|return
operator|(
name|CARD_TYPE_EX_10
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Caller is responsible for eventually calling  * ex_release_resources() on failure.  */
end_comment

begin_function
name|int
name|ex_alloc_resources
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|ex_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|sc
operator|->
name|ioport
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
operator|&
name|sc
operator|->
name|ioport_rid
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sc
operator|->
name|ioport
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"No I/O space?!\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|sc
operator|->
name|bst
operator|=
name|rman_get_bustag
argument_list|(
name|sc
operator|->
name|ioport
argument_list|)
expr_stmt|;
name|sc
operator|->
name|bsh
operator|=
name|rman_get_bushandle
argument_list|(
name|sc
operator|->
name|ioport
argument_list|)
expr_stmt|;
name|sc
operator|->
name|irq
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|sc
operator|->
name|irq_rid
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sc
operator|->
name|irq
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"No IRQ?!\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|bad
label|:
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|void
name|ex_release_resources
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|ex_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|ih
condition|)
block|{
name|bus_teardown_intr
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|irq
argument_list|,
name|sc
operator|->
name|ih
argument_list|)
expr_stmt|;
name|sc
operator|->
name|ih
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|ioport
condition|)
block|{
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
name|sc
operator|->
name|ioport_rid
argument_list|,
name|sc
operator|->
name|ioport
argument_list|)
expr_stmt|;
name|sc
operator|->
name|ioport
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|irq
condition|)
block|{
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|sc
operator|->
name|irq_rid
argument_list|,
name|sc
operator|->
name|irq
argument_list|)
expr_stmt|;
name|sc
operator|->
name|irq
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|ifp
condition|)
name|if_free
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|int
name|ex_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|ex_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|ifmedia
modifier|*
name|ifm
decl_stmt|;
name|uint16_t
name|temp
decl_stmt|;
name|ifp
operator|=
name|sc
operator|->
name|ifp
operator|=
name|if_alloc
argument_list|(
name|IFT_ETHER
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"can not if_alloc()\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOSPC
operator|)
return|;
block|}
comment|/* work out which set of irq<-> internal tables to use */
if|if
condition|(
name|ex_card_type
argument_list|(
name|sc
operator|->
name|enaddr
argument_list|)
operator|==
name|CARD_TYPE_EX_10_PLUS
condition|)
block|{
name|sc
operator|->
name|irq2ee
operator|=
name|plus_irq2eemap
expr_stmt|;
name|sc
operator|->
name|ee2irq
operator|=
name|plus_ee2irqmap
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|irq2ee
operator|=
name|irq2eemap
expr_stmt|;
name|sc
operator|->
name|ee2irq
operator|=
name|ee2irqmap
expr_stmt|;
block|}
name|sc
operator|->
name|mem_size
operator|=
name|CARD_RAM_SIZE
expr_stmt|;
comment|/* XXX This should be read from the card itself. */
comment|/* 	 * Initialize the ifnet structure. 	 */
name|ifp
operator|->
name|if_softc
operator|=
name|sc
expr_stmt|;
name|if_initname
argument_list|(
name|ifp
argument_list|,
name|device_get_name
argument_list|(
name|dev
argument_list|)
argument_list|,
name|device_get_unit
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_mtu
operator|=
name|ETHERMTU
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|=
name|IFF_SIMPLEX
operator||
name|IFF_BROADCAST
operator||
name|IFF_MULTICAST
operator||
name|IFF_NEEDSGIANT
expr_stmt|;
name|ifp
operator|->
name|if_start
operator|=
name|ex_start
expr_stmt|;
name|ifp
operator|->
name|if_ioctl
operator|=
name|ex_ioctl
expr_stmt|;
name|ifp
operator|->
name|if_watchdog
operator|=
name|ex_watchdog
expr_stmt|;
name|ifp
operator|->
name|if_init
operator|=
name|ex_init
expr_stmt|;
name|ifp
operator|->
name|if_snd
operator|.
name|ifq_maxlen
operator|=
name|IFQ_MAXLEN
expr_stmt|;
name|ifmedia_init
argument_list|(
operator|&
name|sc
operator|->
name|ifmedia
argument_list|,
literal|0
argument_list|,
name|ex_ifmedia_upd
argument_list|,
name|ex_ifmedia_sts
argument_list|)
expr_stmt|;
name|temp
operator|=
name|ex_eeprom_read
argument_list|(
name|sc
argument_list|,
name|EE_W5
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|&
name|EE_W5_PORT_TPE
condition|)
name|ifmedia_add
argument_list|(
operator|&
name|sc
operator|->
name|ifmedia
argument_list|,
name|IFM_ETHER
operator||
name|IFM_10_T
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|&
name|EE_W5_PORT_BNC
condition|)
name|ifmedia_add
argument_list|(
operator|&
name|sc
operator|->
name|ifmedia
argument_list|,
name|IFM_ETHER
operator||
name|IFM_10_2
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|&
name|EE_W5_PORT_AUI
condition|)
name|ifmedia_add
argument_list|(
operator|&
name|sc
operator|->
name|ifmedia
argument_list|,
name|IFM_ETHER
operator||
name|IFM_10_5
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ifmedia_add
argument_list|(
operator|&
name|sc
operator|->
name|ifmedia
argument_list|,
name|IFM_ETHER
operator||
name|IFM_AUTO
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ifmedia_add
argument_list|(
operator|&
name|sc
operator|->
name|ifmedia
argument_list|,
name|IFM_ETHER
operator||
name|IFM_NONE
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ifmedia_set
argument_list|(
operator|&
name|sc
operator|->
name|ifmedia
argument_list|,
name|ex_get_media
argument_list|(
name|sc
argument_list|)
argument_list|)
expr_stmt|;
name|ifm
operator|=
operator|&
name|sc
operator|->
name|ifmedia
expr_stmt|;
name|ifm
operator|->
name|ifm_media
operator|=
name|ifm
operator|->
name|ifm_cur
operator|->
name|ifm_media
expr_stmt|;
name|ex_ifmedia_upd
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
comment|/* 	 * Attach the interface. 	 */
name|ether_ifattach
argument_list|(
name|ifp
argument_list|,
name|sc
operator|->
name|enaddr
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ex_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|ex_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|ifp
operator|=
name|sc
operator|->
name|ifp
expr_stmt|;
name|ex_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_RUNNING
expr_stmt|;
name|ether_ifdetach
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|ex_release_resources
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ex_init
parameter_list|(
name|void
modifier|*
name|xsc
parameter_list|)
block|{
name|struct
name|ex_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|ex_softc
operator|*
operator|)
name|xsc
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|ifp
decl_stmt|;
name|int
name|s
decl_stmt|;
name|int
name|i
decl_stmt|;
name|unsigned
name|short
name|temp_reg
decl_stmt|;
name|DODEBUG
argument_list|(
argument|Start_End
argument_list|,
argument|printf(
literal|"%s: ex_init: start\n"
argument|, ifp->if_xname);
argument_list|)
empty_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|ifp
operator|->
name|if_timer
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Load the ethernet address into the card. 	 */
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|CMD_REG
argument_list|,
name|Bank2_Sel
argument_list|)
expr_stmt|;
name|temp_reg
operator|=
name|CSR_READ_1
argument_list|(
name|sc
argument_list|,
name|EEPROM_REG
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp_reg
operator|&
name|Trnoff_Enable
condition|)
block|{
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|EEPROM_REG
argument_list|,
name|temp_reg
operator|&
operator|~
name|Trnoff_Enable
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ETHER_ADDR_LEN
condition|;
name|i
operator|++
control|)
block|{
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|I_ADDR_REG0
operator|+
name|i
argument_list|,
name|IFP2ENADDR
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * - Setup transmit chaining and discard bad received frames. 	 * - Match broadcast. 	 * - Clear test mode. 	 * - Set receiving mode. 	 * - Set IRQ number. 	 */
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|REG1
argument_list|,
name|CSR_READ_1
argument_list|(
name|sc
argument_list|,
name|REG1
argument_list|)
operator||
name|Tx_Chn_Int_Md
operator||
name|Tx_Chn_ErStp
operator||
name|Disc_Bad_Fr
argument_list|)
expr_stmt|;
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|REG2
argument_list|,
name|CSR_READ_1
argument_list|(
name|sc
argument_list|,
name|REG2
argument_list|)
operator||
name|No_SA_Ins
operator||
name|RX_CRC_InMem
argument_list|)
expr_stmt|;
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|REG3
argument_list|,
name|CSR_READ_1
argument_list|(
name|sc
argument_list|,
name|REG3
argument_list|)
operator|&
literal|0x3f
comment|/* XXX constants. */
argument_list|)
expr_stmt|;
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|CMD_REG
argument_list|,
name|Bank1_Sel
argument_list|)
expr_stmt|;
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|INT_NO_REG
argument_list|,
operator|(
name|CSR_READ_1
argument_list|(
name|sc
argument_list|,
name|INT_NO_REG
argument_list|)
operator|&
literal|0xf8
operator|)
operator||
name|sc
operator|->
name|irq2ee
index|[
name|sc
operator|->
name|irq_no
index|]
argument_list|)
expr_stmt|;
comment|/* 	 * Divide the available memory in the card into rcv and xmt buffers. 	 * By default, I use the first 3/4 of the memory for the rcv buffer, 	 * and the remaining 1/4 of the memory for the xmt buffer. 	 */
name|sc
operator|->
name|rx_mem_size
operator|=
name|sc
operator|->
name|mem_size
operator|*
literal|3
operator|/
literal|4
expr_stmt|;
name|sc
operator|->
name|tx_mem_size
operator|=
name|sc
operator|->
name|mem_size
operator|-
name|sc
operator|->
name|rx_mem_size
expr_stmt|;
name|sc
operator|->
name|rx_lower_limit
operator|=
literal|0x0000
expr_stmt|;
name|sc
operator|->
name|rx_upper_limit
operator|=
name|sc
operator|->
name|rx_mem_size
operator|-
literal|2
expr_stmt|;
name|sc
operator|->
name|tx_lower_limit
operator|=
name|sc
operator|->
name|rx_mem_size
expr_stmt|;
name|sc
operator|->
name|tx_upper_limit
operator|=
name|sc
operator|->
name|mem_size
operator|-
literal|2
expr_stmt|;
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|RCV_LOWER_LIMIT_REG
argument_list|,
name|sc
operator|->
name|rx_lower_limit
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|RCV_UPPER_LIMIT_REG
argument_list|,
name|sc
operator|->
name|rx_upper_limit
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|XMT_LOWER_LIMIT_REG
argument_list|,
name|sc
operator|->
name|tx_lower_limit
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|XMT_UPPER_LIMIT_REG
argument_list|,
name|sc
operator|->
name|tx_upper_limit
operator|>>
literal|8
argument_list|)
expr_stmt|;
comment|/* 	 * Enable receive and transmit interrupts, and clear any pending int. 	 */
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|REG1
argument_list|,
name|CSR_READ_1
argument_list|(
name|sc
argument_list|,
name|REG1
argument_list|)
operator||
name|TriST_INT
argument_list|)
expr_stmt|;
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|CMD_REG
argument_list|,
name|Bank0_Sel
argument_list|)
expr_stmt|;
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|MASK_REG
argument_list|,
name|All_Int
operator|&
operator|~
operator|(
name|Rx_Int
operator||
name|Tx_Int
operator|)
argument_list|)
expr_stmt|;
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|STATUS_REG
argument_list|,
name|All_Int
argument_list|)
expr_stmt|;
comment|/* 	 * Initialize receive and transmit ring buffers. 	 */
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|RCV_BAR
argument_list|,
name|sc
operator|->
name|rx_lower_limit
argument_list|)
expr_stmt|;
name|sc
operator|->
name|rx_head
operator|=
name|sc
operator|->
name|rx_lower_limit
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|RCV_STOP_REG
argument_list|,
name|sc
operator|->
name|rx_upper_limit
operator||
literal|0xfe
argument_list|)
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|XMT_BAR
argument_list|,
name|sc
operator|->
name|tx_lower_limit
argument_list|)
expr_stmt|;
name|sc
operator|->
name|tx_head
operator|=
name|sc
operator|->
name|tx_tail
operator|=
name|sc
operator|->
name|tx_lower_limit
expr_stmt|;
name|ifp
operator|->
name|if_drv_flags
operator||=
name|IFF_DRV_RUNNING
expr_stmt|;
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_OACTIVE
expr_stmt|;
name|DODEBUG
argument_list|(
argument|Status
argument_list|,
argument|printf(
literal|"OIDLE init\n"
argument|);
argument_list|)
empty_stmt|;
name|ex_setmulti
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * Final reset of the board, and enable operation. 	 */
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|CMD_REG
argument_list|,
name|Sel_Reset_CMD
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|CMD_REG
argument_list|,
name|Rcv_Enable_CMD
argument_list|)
expr_stmt|;
name|ex_start
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|DODEBUG
argument_list|(
argument|Start_End
argument_list|,
argument|printf(
literal|"%s: ex_init: finish\n"
argument|, ifp->if_xname);
argument_list|)
empty_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ex_start
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|ex_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|int
name|i
decl_stmt|,
name|s
decl_stmt|,
name|len
decl_stmt|,
name|data_len
decl_stmt|,
name|avail
decl_stmt|,
name|dest
decl_stmt|,
name|next
decl_stmt|;
name|unsigned
name|char
name|tmp16
index|[
literal|2
index|]
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|opkt
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|DODEBUG
argument_list|(
argument|Start_End
argument_list|,
argument|printf(
literal|"ex_start%d: start\n"
argument|, unit);
argument_list|)
empty_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
comment|/* 	 * Main loop: send outgoing packets to network card until there are no 	 * more packets left, or the card cannot accept any more yet. 	 */
while|while
condition|(
operator|(
operator|(
name|opkt
operator|=
name|ifp
operator|->
name|if_snd
operator|.
name|ifq_head
operator|)
operator|!=
name|NULL
operator|)
operator|&&
operator|!
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_OACTIVE
operator|)
condition|)
block|{
comment|/* 		 * Ensure there is enough free transmit buffer space for 		 * this packet, including its header. Note: the header 		 * cannot wrap around the end of the transmit buffer and 		 * must be kept together, so we allow space for twice the 		 * length of the header, just in case. 		 */
for|for
control|(
name|len
operator|=
literal|0
operator|,
name|m
operator|=
name|opkt
init|;
name|m
operator|!=
name|NULL
condition|;
name|m
operator|=
name|m
operator|->
name|m_next
control|)
block|{
name|len
operator|+=
name|m
operator|->
name|m_len
expr_stmt|;
block|}
name|data_len
operator|=
name|len
expr_stmt|;
name|DODEBUG
argument_list|(
argument|Sent_Pkts
argument_list|,
argument|printf(
literal|"1. Sending packet with %d data bytes. "
argument|, data_len);
argument_list|)
empty_stmt|;
if|if
condition|(
name|len
operator|&
literal|1
condition|)
block|{
name|len
operator|+=
name|XMT_HEADER_LEN
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
name|len
operator|+=
name|XMT_HEADER_LEN
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|i
operator|=
name|sc
operator|->
name|tx_tail
operator|-
name|sc
operator|->
name|tx_head
operator|)
operator|>=
literal|0
condition|)
block|{
name|avail
operator|=
name|sc
operator|->
name|tx_mem_size
operator|-
name|i
expr_stmt|;
block|}
else|else
block|{
name|avail
operator|=
operator|-
name|i
expr_stmt|;
block|}
name|DODEBUG
argument_list|(
argument|Sent_Pkts
argument_list|,
argument|printf(
literal|"i=%d, avail=%d\n"
argument|, i, avail);
argument_list|)
empty_stmt|;
if|if
condition|(
name|avail
operator|>=
name|len
operator|+
name|XMT_HEADER_LEN
condition|)
block|{
name|IF_DEQUEUE
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|opkt
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|EX_PSA_INTR
comment|/* 			 * Disable rx and tx interrupts, to avoid corruption 			 * of the host address register by interrupt service 			 * routines. 			 * XXX Is this necessary with splimp() enabled? 			 */
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|MASK_REG
argument_list|,
name|All_Int
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 			 * Compute the start and end addresses of this 			 * frame in the tx buffer. 			 */
name|dest
operator|=
name|sc
operator|->
name|tx_tail
expr_stmt|;
name|next
operator|=
name|dest
operator|+
name|len
expr_stmt|;
if|if
condition|(
name|next
operator|>
name|sc
operator|->
name|tx_upper_limit
condition|)
block|{
if|if
condition|(
operator|(
name|sc
operator|->
name|tx_upper_limit
operator|+
literal|2
operator|-
name|sc
operator|->
name|tx_tail
operator|)
operator|<=
name|XMT_HEADER_LEN
condition|)
block|{
name|dest
operator|=
name|sc
operator|->
name|tx_lower_limit
expr_stmt|;
name|next
operator|=
name|dest
operator|+
name|len
expr_stmt|;
block|}
else|else
block|{
name|next
operator|=
name|sc
operator|->
name|tx_lower_limit
operator|+
name|next
operator|-
name|sc
operator|->
name|tx_upper_limit
operator|-
literal|2
expr_stmt|;
block|}
block|}
comment|/* 			 * Build the packet frame in the card's ring buffer. 			 */
name|DODEBUG
argument_list|(
argument|Sent_Pkts
argument_list|,
argument|printf(
literal|"2. dest=%d, next=%d. "
argument|, dest, next);
argument_list|)
empty_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|HOST_ADDR_REG
argument_list|,
name|dest
argument_list|)
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|IO_PORT_REG
argument_list|,
name|Transmit_CMD
argument_list|)
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|IO_PORT_REG
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|IO_PORT_REG
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|IO_PORT_REG
argument_list|,
name|data_len
argument_list|)
expr_stmt|;
comment|/* 			 * Output the packet data to the card. Ensure all 			 * transfers are 16-bit wide, even if individual 			 * mbufs have odd length. 			 */
for|for
control|(
name|m
operator|=
name|opkt
operator|,
name|i
operator|=
literal|0
init|;
name|m
operator|!=
name|NULL
condition|;
name|m
operator|=
name|m
operator|->
name|m_next
control|)
block|{
name|DODEBUG
argument_list|(
argument|Sent_Pkts
argument_list|,
argument|printf(
literal|"[%d]"
argument|, m->m_len);
argument_list|)
empty_stmt|;
if|if
condition|(
name|i
condition|)
block|{
name|tmp16
index|[
literal|1
index|]
operator|=
operator|*
operator|(
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
operator|)
expr_stmt|;
name|CSR_WRITE_MULTI_2
argument_list|(
name|sc
argument_list|,
name|IO_PORT_REG
argument_list|,
operator|(
name|uint16_t
operator|*
operator|)
name|tmp16
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|CSR_WRITE_MULTI_2
argument_list|(
name|sc
argument_list|,
name|IO_PORT_REG
argument_list|,
operator|(
name|uint16_t
operator|*
operator|)
operator|(
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
operator|+
name|i
operator|)
argument_list|,
operator|(
name|m
operator|->
name|m_len
operator|-
name|i
operator|)
operator|/
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|=
operator|(
name|m
operator|->
name|m_len
operator|-
name|i
operator|)
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
block|{
name|tmp16
index|[
literal|0
index|]
operator|=
operator|*
operator|(
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
operator|+
name|m
operator|->
name|m_len
operator|-
literal|1
operator|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|i
condition|)
name|CSR_WRITE_MULTI_2
argument_list|(
name|sc
argument_list|,
name|IO_PORT_REG
argument_list|,
operator|(
name|uint16_t
operator|*
operator|)
name|tmp16
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* 			 * If there were other frames chained, update the 			 * chain in the last one. 			 */
if|if
condition|(
name|sc
operator|->
name|tx_head
operator|!=
name|sc
operator|->
name|tx_tail
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|tx_tail
operator|!=
name|dest
condition|)
block|{
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|HOST_ADDR_REG
argument_list|,
name|sc
operator|->
name|tx_last
operator|+
name|XMT_Chain_Point
argument_list|)
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|IO_PORT_REG
argument_list|,
name|dest
argument_list|)
expr_stmt|;
block|}
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|HOST_ADDR_REG
argument_list|,
name|sc
operator|->
name|tx_last
operator|+
name|XMT_Byte_Count
argument_list|)
expr_stmt|;
name|i
operator|=
name|CSR_READ_2
argument_list|(
name|sc
argument_list|,
name|IO_PORT_REG
argument_list|)
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|HOST_ADDR_REG
argument_list|,
name|sc
operator|->
name|tx_last
operator|+
name|XMT_Byte_Count
argument_list|)
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|IO_PORT_REG
argument_list|,
name|i
operator||
name|Ch_bit
argument_list|)
expr_stmt|;
block|}
comment|/* 			 * Resume normal operation of the card: 			 * - Make a dummy read to flush the DRAM write 			 *   pipeline. 			 * - Enable receive and transmit interrupts. 			 * - Send Transmit or Resume_XMT command, as 			 *   appropriate. 			 */
name|CSR_READ_2
argument_list|(
name|sc
argument_list|,
name|IO_PORT_REG
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|EX_PSA_INTR
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|MASK_REG
argument_list|,
name|All_Int
operator|&
operator|~
operator|(
name|Rx_Int
operator||
name|Tx_Int
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|sc
operator|->
name|tx_head
operator|==
name|sc
operator|->
name|tx_tail
condition|)
block|{
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|XMT_BAR
argument_list|,
name|dest
argument_list|)
expr_stmt|;
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|CMD_REG
argument_list|,
name|Transmit_CMD
argument_list|)
expr_stmt|;
name|sc
operator|->
name|tx_head
operator|=
name|dest
expr_stmt|;
name|DODEBUG
argument_list|(
argument|Sent_Pkts
argument_list|,
argument|printf(
literal|"Transmit\n"
argument|);
argument_list|)
empty_stmt|;
block|}
else|else
block|{
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|CMD_REG
argument_list|,
name|Resume_XMT_List_CMD
argument_list|)
expr_stmt|;
name|DODEBUG
argument_list|(
argument|Sent_Pkts
argument_list|,
argument|printf(
literal|"Resume\n"
argument|);
argument_list|)
empty_stmt|;
block|}
name|sc
operator|->
name|tx_last
operator|=
name|dest
expr_stmt|;
name|sc
operator|->
name|tx_tail
operator|=
name|next
expr_stmt|;
name|BPF_MTAP
argument_list|(
name|ifp
argument_list|,
name|opkt
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_timer
operator|=
literal|2
expr_stmt|;
name|ifp
operator|->
name|if_opackets
operator|++
expr_stmt|;
name|m_freem
argument_list|(
name|opkt
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ifp
operator|->
name|if_drv_flags
operator||=
name|IFF_DRV_OACTIVE
expr_stmt|;
name|DODEBUG
argument_list|(
argument|Status
argument_list|,
argument|printf(
literal|"OACTIVE start\n"
argument|);
argument_list|)
empty_stmt|;
block|}
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|DODEBUG
argument_list|(
argument|Start_End
argument_list|,
argument|printf(
literal|"ex_start%d: finish\n"
argument|, unit);
argument_list|)
empty_stmt|;
block|}
end_function

begin_function
name|void
name|ex_stop
parameter_list|(
name|struct
name|ex_softc
modifier|*
name|sc
parameter_list|)
block|{
name|DODEBUG
argument_list|(
argument|Start_End
argument_list|,
argument|printf(
literal|"ex_stop%d: start\n"
argument|, unit);
argument_list|)
empty_stmt|;
comment|/* 	 * Disable card operation: 	 * - Disable the interrupt line. 	 * - Flush transmission and disable reception. 	 * - Mask and clear all interrupts. 	 * - Reset the 82595. 	 */
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|CMD_REG
argument_list|,
name|Bank1_Sel
argument_list|)
expr_stmt|;
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|REG1
argument_list|,
name|CSR_READ_1
argument_list|(
name|sc
argument_list|,
name|REG1
argument_list|)
operator|&
operator|~
name|TriST_INT
argument_list|)
expr_stmt|;
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|CMD_REG
argument_list|,
name|Bank0_Sel
argument_list|)
expr_stmt|;
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|CMD_REG
argument_list|,
name|Rcv_Stop
argument_list|)
expr_stmt|;
name|sc
operator|->
name|tx_head
operator|=
name|sc
operator|->
name|tx_tail
operator|=
name|sc
operator|->
name|tx_lower_limit
expr_stmt|;
name|sc
operator|->
name|tx_last
operator|=
literal|0
expr_stmt|;
comment|/* XXX I think these two lines are not necessary, because ex_init will always be called again to reinit the interface. */
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|MASK_REG
argument_list|,
name|All_Int
argument_list|)
expr_stmt|;
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|STATUS_REG
argument_list|,
name|All_Int
argument_list|)
expr_stmt|;
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|CMD_REG
argument_list|,
name|Reset_CMD
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|200
argument_list|)
expr_stmt|;
name|DODEBUG
argument_list|(
argument|Start_End
argument_list|,
argument|printf(
literal|"ex_stop%d: finish\n"
argument|, unit);
argument_list|)
empty_stmt|;
return|return;
block|}
end_function

begin_function
name|void
name|ex_intr
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ex_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|ex_softc
operator|*
operator|)
name|arg
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|ifp
decl_stmt|;
name|int
name|int_status
decl_stmt|,
name|send_pkts
decl_stmt|;
name|int
name|loops
init|=
literal|100
decl_stmt|;
name|DODEBUG
argument_list|(
argument|Start_End
argument_list|,
argument|printf(
literal|"ex_intr%d: start\n"
argument|, unit);
argument_list|)
empty_stmt|;
name|send_pkts
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|loops
operator|--
operator|>
literal|0
operator|&&
operator|(
name|int_status
operator|=
name|CSR_READ_1
argument_list|(
name|sc
argument_list|,
name|STATUS_REG
argument_list|)
operator|)
operator|&
operator|(
name|Tx_Int
operator||
name|Rx_Int
operator|)
condition|)
block|{
comment|/* don't loop forever */
if|if
condition|(
name|int_status
operator|==
literal|0xff
condition|)
break|break;
if|if
condition|(
name|int_status
operator|&
name|Rx_Int
condition|)
block|{
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|STATUS_REG
argument_list|,
name|Rx_Int
argument_list|)
expr_stmt|;
name|ex_rx_intr
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|int_status
operator|&
name|Tx_Int
condition|)
block|{
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|STATUS_REG
argument_list|,
name|Tx_Int
argument_list|)
expr_stmt|;
name|ex_tx_intr
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|send_pkts
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|loops
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"100 loops are not enough\n"
argument_list|)
expr_stmt|;
comment|/* 	 * If any packet has been transmitted, and there are queued packets to 	 * be sent, attempt to send more packets to the network card. 	 */
if|if
condition|(
name|send_pkts
operator|&&
operator|(
name|ifp
operator|->
name|if_snd
operator|.
name|ifq_head
operator|!=
name|NULL
operator|)
condition|)
name|ex_start
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|DODEBUG
argument_list|(
argument|Start_End
argument_list|,
argument|printf(
literal|"ex_intr%d: finish\n"
argument|, unit);
argument_list|)
empty_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|ex_tx_intr
parameter_list|(
name|struct
name|ex_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|ifp
decl_stmt|;
name|int
name|tx_status
decl_stmt|;
name|DODEBUG
argument_list|(
argument|Start_End
argument_list|,
argument|printf(
literal|"ex_tx_intr%d: start\n"
argument|, unit);
argument_list|)
empty_stmt|;
comment|/* 	 * - Cancel the watchdog. 	 * For all packets transmitted since last transmit interrupt: 	 * - Advance chain pointer to next queued packet. 	 * - Update statistics. 	 */
name|ifp
operator|->
name|if_timer
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|sc
operator|->
name|tx_head
operator|!=
name|sc
operator|->
name|tx_tail
condition|)
block|{
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|HOST_ADDR_REG
argument_list|,
name|sc
operator|->
name|tx_head
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|CSR_READ_2
argument_list|(
name|sc
argument_list|,
name|IO_PORT_REG
argument_list|)
operator|&
name|Done_bit
condition|)
break|break;
name|tx_status
operator|=
name|CSR_READ_2
argument_list|(
name|sc
argument_list|,
name|IO_PORT_REG
argument_list|)
expr_stmt|;
name|sc
operator|->
name|tx_head
operator|=
name|CSR_READ_2
argument_list|(
name|sc
argument_list|,
name|IO_PORT_REG
argument_list|)
expr_stmt|;
if|if
condition|(
name|tx_status
operator|&
name|TX_OK_bit
condition|)
block|{
name|ifp
operator|->
name|if_opackets
operator|++
expr_stmt|;
block|}
else|else
block|{
name|ifp
operator|->
name|if_oerrors
operator|++
expr_stmt|;
block|}
name|ifp
operator|->
name|if_collisions
operator|+=
name|tx_status
operator|&
name|No_Collisions_bits
expr_stmt|;
block|}
comment|/* 	 * The card should be ready to accept more packets now. 	 */
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_OACTIVE
expr_stmt|;
name|DODEBUG
argument_list|(
argument|Status
argument_list|,
argument|printf(
literal|"OIDLE tx_intr\n"
argument|);
argument_list|)
empty_stmt|;
name|DODEBUG
argument_list|(
argument|Start_End
argument_list|,
argument|printf(
literal|"ex_tx_intr%d: finish\n"
argument|, unit);
argument_list|)
empty_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|ex_rx_intr
parameter_list|(
name|struct
name|ex_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|ifp
decl_stmt|;
name|int
name|rx_status
decl_stmt|;
name|int
name|pkt_len
decl_stmt|;
name|int
name|QQQ
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|ipkt
decl_stmt|;
name|struct
name|ether_header
modifier|*
name|eh
decl_stmt|;
name|DODEBUG
argument_list|(
argument|Start_End
argument_list|,
argument|printf(
literal|"ex_rx_intr%d: start\n"
argument|, unit);
argument_list|)
empty_stmt|;
comment|/* 	 * For all packets received since last receive interrupt: 	 * - If packet ok, read it into a new mbuf and queue it to interface, 	 *   updating statistics. 	 * - If packet bad, just discard it, and update statistics. 	 * Finally, advance receive stop limit in card's memory to new location. 	 */
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|HOST_ADDR_REG
argument_list|,
name|sc
operator|->
name|rx_head
argument_list|)
expr_stmt|;
while|while
condition|(
name|CSR_READ_2
argument_list|(
name|sc
argument_list|,
name|IO_PORT_REG
argument_list|)
operator|==
name|RCV_Done
condition|)
block|{
name|rx_status
operator|=
name|CSR_READ_2
argument_list|(
name|sc
argument_list|,
name|IO_PORT_REG
argument_list|)
expr_stmt|;
name|sc
operator|->
name|rx_head
operator|=
name|CSR_READ_2
argument_list|(
name|sc
argument_list|,
name|IO_PORT_REG
argument_list|)
expr_stmt|;
name|QQQ
operator|=
name|pkt_len
operator|=
name|CSR_READ_2
argument_list|(
name|sc
argument_list|,
name|IO_PORT_REG
argument_list|)
expr_stmt|;
if|if
condition|(
name|rx_status
operator|&
name|RCV_OK_bit
condition|)
block|{
name|MGETHDR
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
name|ipkt
operator|=
name|m
expr_stmt|;
if|if
condition|(
name|ipkt
operator|==
name|NULL
condition|)
block|{
name|ifp
operator|->
name|if_iqdrops
operator|++
expr_stmt|;
block|}
else|else
block|{
name|ipkt
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|ifp
expr_stmt|;
name|ipkt
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|pkt_len
expr_stmt|;
name|ipkt
operator|->
name|m_len
operator|=
name|MHLEN
expr_stmt|;
while|while
condition|(
name|pkt_len
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|pkt_len
operator|>=
name|MINCLSIZE
condition|)
block|{
name|MCLGET
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_flags
operator|&
name|M_EXT
condition|)
block|{
name|m
operator|->
name|m_len
operator|=
name|MCLBYTES
expr_stmt|;
block|}
else|else
block|{
name|m_freem
argument_list|(
name|ipkt
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_iqdrops
operator|++
expr_stmt|;
goto|goto
name|rx_another
goto|;
block|}
block|}
name|m
operator|->
name|m_len
operator|=
name|min
argument_list|(
name|m
operator|->
name|m_len
argument_list|,
name|pkt_len
argument_list|)
expr_stmt|;
comment|/* 	   * NOTE: I'm assuming that all mbufs allocated are of even length, 	   * except for the last one in an odd-length packet. 	   */
name|CSR_READ_MULTI_2
argument_list|(
name|sc
argument_list|,
name|IO_PORT_REG
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
name|uint16_t
operator|*
argument_list|)
argument_list|,
name|m
operator|->
name|m_len
operator|/
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_len
operator|&
literal|1
condition|)
block|{
operator|*
operator|(
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
operator|+
name|m
operator|->
name|m_len
operator|-
literal|1
operator|)
operator|=
name|CSR_READ_1
argument_list|(
name|sc
argument_list|,
name|IO_PORT_REG
argument_list|)
expr_stmt|;
block|}
name|pkt_len
operator|-=
name|m
operator|->
name|m_len
expr_stmt|;
if|if
condition|(
name|pkt_len
operator|>
literal|0
condition|)
block|{
name|MGET
argument_list|(
name|m
operator|->
name|m_next
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_next
operator|==
name|NULL
condition|)
block|{
name|m_freem
argument_list|(
name|ipkt
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_iqdrops
operator|++
expr_stmt|;
goto|goto
name|rx_another
goto|;
block|}
name|m
operator|=
name|m
operator|->
name|m_next
expr_stmt|;
name|m
operator|->
name|m_len
operator|=
name|MLEN
expr_stmt|;
block|}
block|}
name|eh
operator|=
name|mtod
argument_list|(
name|ipkt
argument_list|,
expr|struct
name|ether_header
operator|*
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|EXDEBUG
if|if
condition|(
name|debug_mask
operator|&
name|Rcvd_Pkts
condition|)
block|{
if|if
condition|(
operator|(
name|eh
operator|->
name|ether_dhost
index|[
literal|5
index|]
operator|!=
literal|0xff
operator|)
operator|||
operator|(
name|eh
operator|->
name|ether_dhost
index|[
literal|0
index|]
operator|!=
literal|0xff
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"Receive packet with %d data bytes: %6D -> "
argument_list|,
name|QQQ
argument_list|,
name|eh
operator|->
name|ether_shost
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%6D\n"
argument_list|,
name|eh
operator|->
name|ether_dhost
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
block|}
comment|/* QQQ */
block|}
endif|#
directive|endif
call|(
modifier|*
name|ifp
operator|->
name|if_input
call|)
argument_list|(
name|ifp
argument_list|,
name|ipkt
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_ipackets
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
block|}
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|HOST_ADDR_REG
argument_list|,
name|sc
operator|->
name|rx_head
argument_list|)
expr_stmt|;
name|rx_another
label|:
empty_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|rx_head
operator|<
name|sc
operator|->
name|rx_lower_limit
operator|+
literal|2
condition|)
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|RCV_STOP_REG
argument_list|,
name|sc
operator|->
name|rx_upper_limit
argument_list|)
expr_stmt|;
else|else
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|RCV_STOP_REG
argument_list|,
name|sc
operator|->
name|rx_head
operator|-
literal|2
argument_list|)
expr_stmt|;
name|DODEBUG
argument_list|(
argument|Start_End
argument_list|,
argument|printf(
literal|"ex_rx_intr%d: finish\n"
argument|, unit);
argument_list|)
empty_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|int
name|ex_ioctl
parameter_list|(
specifier|register
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|data
parameter_list|)
block|{
name|struct
name|ex_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|ifreq
modifier|*
name|ifr
init|=
operator|(
expr|struct
name|ifreq
operator|*
operator|)
name|data
decl_stmt|;
name|int
name|s
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|DODEBUG
argument_list|(
argument|Start_End
argument_list|,
argument|printf(
literal|"%s: ex_ioctl: start "
argument|, ifp->if_xname);
argument_list|)
empty_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|SIOCSIFADDR
case|:
case|case
name|SIOCGIFADDR
case|:
case|case
name|SIOCSIFMTU
case|:
name|error
operator|=
name|ether_ioctl
argument_list|(
name|ifp
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCSIFFLAGS
case|:
name|DODEBUG
argument_list|(
argument|Start_End
argument_list|,
argument|printf(
literal|"SIOCSIFFLAGS"
argument|);
argument_list|)
empty_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
operator|)
operator|==
literal|0
operator|&&
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
condition|)
block|{
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_RUNNING
expr_stmt|;
name|ex_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ex_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
break|break;
ifdef|#
directive|ifdef
name|NODEF
case|case
name|SIOCGHWADDR
case|:
name|DODEBUG
argument_list|(
argument|Start_End
argument_list|,
argument|printf(
literal|"SIOCGHWADDR"
argument|);
argument_list|)
empty_stmt|;
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|sc
operator|->
name|sc_addr
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|ifr
operator|->
name|ifr_data
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|sc_addr
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|SIOCADDMULTI
case|:
case|case
name|SIOCDELMULTI
case|:
name|ex_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|SIOCSIFMEDIA
case|:
case|case
name|SIOCGIFMEDIA
case|:
name|error
operator|=
name|ifmedia_ioctl
argument_list|(
name|ifp
argument_list|,
name|ifr
argument_list|,
operator|&
name|sc
operator|->
name|ifmedia
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
break|break;
default|default:
name|DODEBUG
argument_list|(
argument|Start_End
argument_list|,
argument|printf(
literal|"unknown"
argument|);
argument_list|)
empty_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|DODEBUG
argument_list|(
argument|Start_End
argument_list|,
argument|printf(
literal|"\n%s: ex_ioctl: finish\n"
argument|, ifp->if_xname);
argument_list|)
empty_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ex_setmulti
parameter_list|(
name|struct
name|ex_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|ifmultiaddr
modifier|*
name|maddr
decl_stmt|;
name|uint16_t
modifier|*
name|addr
decl_stmt|;
name|int
name|count
decl_stmt|;
name|int
name|timeout
decl_stmt|,
name|status
decl_stmt|;
name|ifp
operator|=
name|sc
operator|->
name|ifp
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
name|IF_ADDR_LOCK
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|maddr
argument_list|,
argument|&ifp->if_multiaddrs
argument_list|,
argument|ifma_link
argument_list|)
block|{
if|if
condition|(
name|maddr
operator|->
name|ifma_addr
operator|->
name|sa_family
operator|!=
name|AF_LINK
condition|)
continue|continue;
name|count
operator|++
expr_stmt|;
block|}
name|IF_ADDR_UNLOCK
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_PROMISC
operator|)
operator|||
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_ALLMULTI
operator|)
operator|||
name|count
operator|>
literal|63
condition|)
block|{
comment|/* Interface is in promiscuous mode or there are too many 		 * multicast addresses for the card to handle */
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|CMD_REG
argument_list|,
name|Bank2_Sel
argument_list|)
expr_stmt|;
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|REG2
argument_list|,
name|CSR_READ_1
argument_list|(
name|sc
argument_list|,
name|REG2
argument_list|)
operator||
name|Promisc_Mode
argument_list|)
expr_stmt|;
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|REG3
argument_list|,
name|CSR_READ_1
argument_list|(
name|sc
argument_list|,
name|REG3
argument_list|)
argument_list|)
expr_stmt|;
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|CMD_REG
argument_list|,
name|Bank0_Sel
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_MULTICAST
operator|)
operator|&&
operator|(
name|count
operator|>
literal|0
operator|)
condition|)
block|{
comment|/* Program multicast addresses plus our MAC address 		 * into the filter */
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|CMD_REG
argument_list|,
name|Bank2_Sel
argument_list|)
expr_stmt|;
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|REG2
argument_list|,
name|CSR_READ_1
argument_list|(
name|sc
argument_list|,
name|REG2
argument_list|)
operator||
name|Multi_IA
argument_list|)
expr_stmt|;
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|REG3
argument_list|,
name|CSR_READ_1
argument_list|(
name|sc
argument_list|,
name|REG3
argument_list|)
argument_list|)
expr_stmt|;
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|CMD_REG
argument_list|,
name|Bank0_Sel
argument_list|)
expr_stmt|;
comment|/* Borrow space from TX buffer; this should be safe 		 * as this is only called from ex_init */
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|HOST_ADDR_REG
argument_list|,
name|sc
operator|->
name|tx_lower_limit
argument_list|)
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|IO_PORT_REG
argument_list|,
name|MC_Setup_CMD
argument_list|)
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|IO_PORT_REG
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|IO_PORT_REG
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|IO_PORT_REG
argument_list|,
operator|(
name|count
operator|+
literal|1
operator|)
operator|*
literal|6
argument_list|)
expr_stmt|;
name|IF_ADDR_LOCK
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|maddr
argument_list|,
argument|&ifp->if_multiaddrs
argument_list|,
argument|ifma_link
argument_list|)
block|{
if|if
condition|(
name|maddr
operator|->
name|ifma_addr
operator|->
name|sa_family
operator|!=
name|AF_LINK
condition|)
continue|continue;
name|addr
operator|=
operator|(
name|uint16_t
operator|*
operator|)
name|LLADDR
argument_list|(
operator|(
expr|struct
name|sockaddr_dl
operator|*
operator|)
name|maddr
operator|->
name|ifma_addr
argument_list|)
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|IO_PORT_REG
argument_list|,
operator|*
name|addr
operator|++
argument_list|)
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|IO_PORT_REG
argument_list|,
operator|*
name|addr
operator|++
argument_list|)
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|IO_PORT_REG
argument_list|,
operator|*
name|addr
operator|++
argument_list|)
expr_stmt|;
block|}
name|IF_ADDR_UNLOCK
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
comment|/* Program our MAC address as well */
comment|/* XXX: Is this necessary?  The Linux driver does this 		 * but the NetBSD driver does not */
name|addr
operator|=
operator|(
name|uint16_t
operator|*
operator|)
operator|(
name|IFP2ENADDR
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
operator|)
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|IO_PORT_REG
argument_list|,
operator|*
name|addr
operator|++
argument_list|)
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|IO_PORT_REG
argument_list|,
operator|*
name|addr
operator|++
argument_list|)
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|IO_PORT_REG
argument_list|,
operator|*
name|addr
operator|++
argument_list|)
expr_stmt|;
name|CSR_READ_2
argument_list|(
name|sc
argument_list|,
name|IO_PORT_REG
argument_list|)
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|XMT_BAR
argument_list|,
name|sc
operator|->
name|tx_lower_limit
argument_list|)
expr_stmt|;
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|CMD_REG
argument_list|,
name|MC_Setup_CMD
argument_list|)
expr_stmt|;
name|sc
operator|->
name|tx_head
operator|=
name|sc
operator|->
name|tx_lower_limit
expr_stmt|;
name|sc
operator|->
name|tx_tail
operator|=
name|sc
operator|->
name|tx_head
operator|+
name|XMT_HEADER_LEN
operator|+
operator|(
name|count
operator|+
literal|1
operator|)
operator|*
literal|6
expr_stmt|;
for|for
control|(
name|timeout
operator|=
literal|0
init|;
name|timeout
operator|<
literal|100
condition|;
name|timeout
operator|++
control|)
block|{
name|DELAY
argument_list|(
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|CSR_READ_1
argument_list|(
name|sc
argument_list|,
name|STATUS_REG
argument_list|)
operator|&
name|Exec_Int
operator|)
operator|==
literal|0
condition|)
continue|continue;
name|status
operator|=
name|CSR_READ_1
argument_list|(
name|sc
argument_list|,
name|CMD_REG
argument_list|)
expr_stmt|;
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|STATUS_REG
argument_list|,
name|Exec_Int
argument_list|)
expr_stmt|;
break|break;
block|}
name|sc
operator|->
name|tx_head
operator|=
name|sc
operator|->
name|tx_tail
expr_stmt|;
block|}
else|else
block|{
comment|/* No multicast or promiscuous mode */
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|CMD_REG
argument_list|,
name|Bank2_Sel
argument_list|)
expr_stmt|;
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|REG2
argument_list|,
name|CSR_READ_1
argument_list|(
name|sc
argument_list|,
name|REG2
argument_list|)
operator|&
literal|0xDE
argument_list|)
expr_stmt|;
comment|/* ~(Multi_IA | Promisc_Mode) */
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|REG3
argument_list|,
name|CSR_READ_1
argument_list|(
name|sc
argument_list|,
name|REG3
argument_list|)
argument_list|)
expr_stmt|;
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|CMD_REG
argument_list|,
name|Bank0_Sel
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ex_reset
parameter_list|(
name|struct
name|ex_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|s
decl_stmt|;
name|DODEBUG
argument_list|(
argument|Start_End
argument_list|,
argument|printf(
literal|"ex_reset%d: start\n"
argument|, unit);
argument_list|)
empty_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|ex_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ex_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|DODEBUG
argument_list|(
argument|Start_End
argument_list|,
argument|printf(
literal|"ex_reset%d: finish\n"
argument|, unit);
argument_list|)
empty_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|ex_watchdog
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|ex_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|DODEBUG
argument_list|(
argument|Start_End
argument_list|,
argument|printf(
literal|"%s: ex_watchdog: start\n"
argument|, ifp->if_xname);
argument_list|)
empty_stmt|;
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_OACTIVE
expr_stmt|;
name|DODEBUG
argument_list|(
argument|Status
argument_list|,
argument|printf(
literal|"OIDLE watchdog\n"
argument|);
argument_list|)
empty_stmt|;
name|ifp
operator|->
name|if_oerrors
operator|++
expr_stmt|;
name|ex_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ex_start
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|DODEBUG
argument_list|(
argument|Start_End
argument_list|,
argument|printf(
literal|"%s: ex_watchdog: finish\n"
argument|, ifp->if_xname);
argument_list|)
empty_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|int
name|ex_get_media
parameter_list|(
name|struct
name|ex_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|current
decl_stmt|;
name|int
name|media
decl_stmt|;
name|media
operator|=
name|ex_eeprom_read
argument_list|(
name|sc
argument_list|,
name|EE_W5
argument_list|)
expr_stmt|;
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|CMD_REG
argument_list|,
name|Bank2_Sel
argument_list|)
expr_stmt|;
name|current
operator|=
name|CSR_READ_1
argument_list|(
name|sc
argument_list|,
name|REG3
argument_list|)
expr_stmt|;
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|CMD_REG
argument_list|,
name|Bank0_Sel
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|current
operator|&
name|TPE_bit
operator|)
operator|&&
operator|(
name|media
operator|&
name|EE_W5_PORT_TPE
operator|)
condition|)
return|return
operator|(
name|IFM_ETHER
operator||
name|IFM_10_T
operator|)
return|;
if|if
condition|(
operator|(
name|current
operator|&
name|BNC_bit
operator|)
operator|&&
operator|(
name|media
operator|&
name|EE_W5_PORT_BNC
operator|)
condition|)
return|return
operator|(
name|IFM_ETHER
operator||
name|IFM_10_2
operator|)
return|;
if|if
condition|(
name|media
operator|&
name|EE_W5_PORT_AUI
condition|)
return|return
operator|(
name|IFM_ETHER
operator||
name|IFM_10_5
operator|)
return|;
return|return
operator|(
name|IFM_ETHER
operator||
name|IFM_AUTO
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ex_ifmedia_upd
parameter_list|(
name|ifp
parameter_list|)
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
block|{
name|struct
name|ex_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
if|if
condition|(
name|IFM_TYPE
argument_list|(
name|sc
operator|->
name|ifmedia
operator|.
name|ifm_media
argument_list|)
operator|!=
name|IFM_ETHER
condition|)
return|return
name|EINVAL
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ex_ifmedia_sts
parameter_list|(
name|ifp
parameter_list|,
name|ifmr
parameter_list|)
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|ifmediareq
modifier|*
name|ifmr
decl_stmt|;
block|{
name|struct
name|ex_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|ifmr
operator|->
name|ifm_active
operator|=
name|ex_get_media
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ifmr
operator|->
name|ifm_status
operator|=
name|IFM_AVALID
operator||
name|IFM_ACTIVE
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|u_short
name|ex_eeprom_read
parameter_list|(
name|struct
name|ex_softc
modifier|*
name|sc
parameter_list|,
name|int
name|location
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|u_short
name|data
init|=
literal|0
decl_stmt|;
name|int
name|read_cmd
init|=
name|location
operator||
name|EE_READ_CMD
decl_stmt|;
name|short
name|ctrl_val
init|=
name|EECS
decl_stmt|;
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|CMD_REG
argument_list|,
name|Bank2_Sel
argument_list|)
expr_stmt|;
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|EEPROM_REG
argument_list|,
name|EECS
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|8
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|short
name|outval
init|=
operator|(
name|read_cmd
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
operator|)
condition|?
name|ctrl_val
operator||
name|EEDI
else|:
name|ctrl_val
decl_stmt|;
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|EEPROM_REG
argument_list|,
name|outval
argument_list|)
expr_stmt|;
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|EEPROM_REG
argument_list|,
name|outval
operator||
name|EESK
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|3
argument_list|)
expr_stmt|;
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|EEPROM_REG
argument_list|,
name|outval
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|EEPROM_REG
argument_list|,
name|ctrl_val
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|16
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|EEPROM_REG
argument_list|,
name|ctrl_val
operator||
name|EESK
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|3
argument_list|)
expr_stmt|;
name|data
operator|=
operator|(
name|data
operator|<<
literal|1
operator|)
operator||
operator|(
operator|(
name|CSR_READ_1
argument_list|(
name|sc
argument_list|,
name|EEPROM_REG
argument_list|)
operator|&
name|EEDO
operator|)
condition|?
literal|1
else|:
literal|0
operator|)
expr_stmt|;
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|EEPROM_REG
argument_list|,
name|ctrl_val
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
name|ctrl_val
operator|&=
operator|~
name|EECS
expr_stmt|;
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|EEPROM_REG
argument_list|,
name|ctrl_val
operator||
name|EESK
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|3
argument_list|)
expr_stmt|;
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|EEPROM_REG
argument_list|,
name|ctrl_val
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|CMD_REG
argument_list|,
name|Bank0_Sel
argument_list|)
expr_stmt|;
return|return
operator|(
name|data
operator|)
return|;
block|}
end_function

end_unit

