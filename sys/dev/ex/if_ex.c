begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1996, Javier MartÃ­n Rueda (jmrueda@diatel.upm.es)  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice unmodified, this list of conditions, and the following  *    disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *	$Id$  */
end_comment

begin_comment
comment|/*  * Intel EtherExpress Pro/10, Pro/10+ Ethernet driver  *  * Revision history:  *  * 30-Oct-1996: first beta version. Inet and BPF supported, but no multicast.  */
end_comment

begin_include
include|#
directive|include
file|"ex.h"
end_include

begin_if
if|#
directive|if
name|NEX
operator|>
literal|0
end_if

begin_include
include|#
directive|include
file|"bpfilter.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|INET
end_ifdef

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/if_ether.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|IPX
end_ifdef

begin_include
include|#
directive|include
file|<netipx/ipx.h>
end_include

begin_include
include|#
directive|include
file|<netipx/ipx_if.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|NS
end_ifdef

begin_include
include|#
directive|include
file|<netns/ns.h>
end_include

begin_include
include|#
directive|include
file|<netns/ns_if.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|NBPFILTER
operator|>
literal|0
end_if

begin_include
include|#
directive|include
file|<net/bpf.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<machine/clock.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/isa_device.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/if_exreg.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|EXDEBUG
end_ifdef

begin_define
define|#
directive|define
name|Start_End
value|1
end_define

begin_define
define|#
directive|define
name|Rcvd_Pkts
value|2
end_define

begin_define
define|#
directive|define
name|Sent_Pkts
value|4
end_define

begin_define
define|#
directive|define
name|Status
value|8
end_define

begin_decl_stmt
specifier|static
name|int
name|debug_mask
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|exintr_count
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|DODEBUG
parameter_list|(
name|level
parameter_list|,
name|action
parameter_list|)
value|if (level& debug_mask) action
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|DODEBUG
parameter_list|(
name|level
parameter_list|,
name|action
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|Conn_BNC
value|1
end_define

begin_define
define|#
directive|define
name|Conn_TPE
value|2
end_define

begin_define
define|#
directive|define
name|Conn_AUI
value|3
end_define

begin_struct
struct|struct
name|ex_softc
block|{
name|struct
name|arpcom
name|arpcom
decl_stmt|;
comment|/* Ethernet common data */
name|u_int
name|iobase
decl_stmt|;
comment|/* I/O base address. */
name|u_short
name|connector
decl_stmt|;
comment|/* Connector type. */
name|u_short
name|irq_no
decl_stmt|;
comment|/* IRQ number. */
name|char
modifier|*
name|irq2ee
decl_stmt|;
comment|/* irq<-> internal representation conversion */
name|u_char
modifier|*
name|ee2irq
decl_stmt|;
name|u_int
name|mem_size
decl_stmt|;
comment|/* Total memory size, in bytes. */
name|u_int
name|rx_mem_size
decl_stmt|;
comment|/* Rx memory size (by default, first 3/4 of total memory). */
name|u_int
name|rx_lower_limit
decl_stmt|,
name|rx_upper_limit
decl_stmt|;
comment|/* Lower and upper limits of receive buffer. */
name|u_int
name|rx_head
decl_stmt|;
comment|/* Head of receive ring buffer. */
name|u_int
name|tx_mem_size
decl_stmt|;
comment|/* Tx memory size (by default, last quarter of total memory). */
name|u_int
name|tx_lower_limit
decl_stmt|,
name|tx_upper_limit
decl_stmt|;
comment|/* Lower and upper limits of transmit buffer. */
name|u_int
name|tx_head
decl_stmt|,
name|tx_tail
decl_stmt|;
comment|/* Head and tail of transmit ring buffer. */
name|u_int
name|tx_last
decl_stmt|;
comment|/* Pointer to beginning of last frame in the chain. */
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|ex_softc
name|ex_sc
index|[
name|NEX
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* XXX would it be better to malloc(3) the memory? */
end_comment

begin_decl_stmt
specifier|static
name|char
name|irq2eemap
index|[]
init|=
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|,
literal|0
block|,
literal|1
block|,
operator|-
literal|1
block|,
literal|2
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
literal|0
block|,
literal|3
block|,
literal|4
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_char
name|ee2irqmap
index|[]
init|=
block|{
literal|9
block|,
literal|3
block|,
literal|5
block|,
literal|10
block|,
literal|11
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|plus_irq2eemap
index|[]
init|=
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|2
block|,
operator|-
literal|1
block|,
literal|3
block|,
operator|-
literal|1
block|,
literal|4
block|,
literal|5
block|,
literal|6
block|,
literal|7
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_char
name|plus_ee2irqmap
index|[]
init|=
block|{
literal|3
block|,
literal|4
block|,
literal|5
block|,
literal|7
block|,
literal|9
block|,
literal|10
block|,
literal|11
block|,
literal|12
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ex_probe
name|__P
argument_list|(
operator|(
expr|struct
name|isa_device
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ex_attach
name|__P
argument_list|(
operator|(
expr|struct
name|isa_device
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ex_init
name|__P
argument_list|(
operator|(
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ex_start
name|__P
argument_list|(
operator|(
expr|struct
name|ifnet
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ex_stop
name|__P
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ex_ioctl
name|__P
argument_list|(
operator|(
expr|struct
name|ifnet
operator|*
operator|,
name|int
operator|,
name|caddr_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ex_reset
name|__P
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ex_watchdog
name|__P
argument_list|(
operator|(
expr|struct
name|ifnet
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_short
name|eeprom_read
name|__P
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|look_for_card
name|__P
argument_list|(
operator|(
name|u_int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ex_tx_intr
name|__P
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ex_rx_intr
name|__P
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|isa_driver
name|exdriver
init|=
block|{
name|ex_probe
block|,
name|ex_attach
block|,
literal|"ex"
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|look_for_card
parameter_list|(
name|u_int
name|iobase
parameter_list|)
block|{
name|int
name|count1
decl_stmt|,
name|count2
decl_stmt|;
comment|/* 	 * Check for the i82595 signature, and check that the round robin 	 * counter actually advances. 	 */
if|if
condition|(
operator|(
operator|(
name|count1
operator|=
name|inb
argument_list|(
name|iobase
operator|+
name|ID_REG
argument_list|)
operator|)
operator|&
name|Id_Mask
operator|)
operator|!=
name|Id_Sig
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|count2
operator|=
name|inb
argument_list|(
name|iobase
operator|+
name|ID_REG
argument_list|)
expr_stmt|;
name|count2
operator|=
name|inb
argument_list|(
name|iobase
operator|+
name|ID_REG
argument_list|)
expr_stmt|;
name|count2
operator|=
name|inb
argument_list|(
name|iobase
operator|+
name|ID_REG
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|count2
operator|&
name|Counter_bits
operator|)
operator|==
operator|(
operator|(
name|count1
operator|+
literal|0xc0
operator|)
operator|&
name|Counter_bits
operator|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ex_probe
parameter_list|(
name|struct
name|isa_device
modifier|*
name|dev
parameter_list|)
block|{
name|int
name|unit
init|=
name|dev
operator|->
name|id_unit
decl_stmt|;
name|struct
name|ex_softc
modifier|*
name|sc
init|=
operator|&
name|ex_sc
index|[
name|unit
index|]
decl_stmt|;
name|u_int
name|iobase
decl_stmt|;
name|u_short
name|eaddr_tmp
decl_stmt|;
name|int
name|tmp
decl_stmt|;
name|DODEBUG
argument_list|(
argument|Start_End
argument_list|,
argument|printf(
literal|"ex_probe%d: start\n"
argument|, unit);
argument_list|)
empty_stmt|;
comment|/* 	 * If an I/O address was supplied in the configuration file, probe only 	 * that. Otherwise, cycle through the predefined set of possible addresses. 	 */
if|if
condition|(
name|dev
operator|->
name|id_iobase
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
operator|!
name|look_for_card
argument_list|(
name|iobase
operator|=
name|dev
operator|->
name|id_iobase
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
block|{
for|for
control|(
name|iobase
operator|=
literal|0x200
init|;
name|iobase
operator|<
literal|0x3a0
condition|;
name|iobase
operator|+=
literal|0x10
control|)
if|if
condition|(
name|look_for_card
argument_list|(
name|iobase
argument_list|)
condition|)
break|break;
if|if
condition|(
name|iobase
operator|>=
literal|0x3a0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
else|else
name|dev
operator|->
name|id_iobase
operator|=
name|iobase
expr_stmt|;
block|}
comment|/* 	 * Reset the card. 	 */
name|outb
argument_list|(
name|iobase
operator|+
name|CMD_REG
argument_list|,
name|Reset_CMD
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|400
argument_list|)
expr_stmt|;
comment|/* 	 * Fill in several fields of the softc structure: 	 *	- I/O base address. 	 *	- Hardware Ethernet address. 	 *	- IRQ number (if not supplied in config file, read it from EEPROM). 	 *	- Connector type. 	 */
name|sc
operator|->
name|iobase
operator|=
name|iobase
expr_stmt|;
name|eaddr_tmp
operator|=
name|eeprom_read
argument_list|(
name|iobase
argument_list|,
name|EE_Eth_Addr_Lo
argument_list|)
expr_stmt|;
name|sc
operator|->
name|arpcom
operator|.
name|ac_enaddr
index|[
literal|5
index|]
operator|=
name|eaddr_tmp
operator|&
literal|0xff
expr_stmt|;
name|sc
operator|->
name|arpcom
operator|.
name|ac_enaddr
index|[
literal|4
index|]
operator|=
name|eaddr_tmp
operator|>>
literal|8
expr_stmt|;
name|eaddr_tmp
operator|=
name|eeprom_read
argument_list|(
name|iobase
argument_list|,
name|EE_Eth_Addr_Mid
argument_list|)
expr_stmt|;
name|sc
operator|->
name|arpcom
operator|.
name|ac_enaddr
index|[
literal|3
index|]
operator|=
name|eaddr_tmp
operator|&
literal|0xff
expr_stmt|;
name|sc
operator|->
name|arpcom
operator|.
name|ac_enaddr
index|[
literal|2
index|]
operator|=
name|eaddr_tmp
operator|>>
literal|8
expr_stmt|;
name|eaddr_tmp
operator|=
name|eeprom_read
argument_list|(
name|iobase
argument_list|,
name|EE_Eth_Addr_Hi
argument_list|)
expr_stmt|;
name|sc
operator|->
name|arpcom
operator|.
name|ac_enaddr
index|[
literal|1
index|]
operator|=
name|eaddr_tmp
operator|&
literal|0xff
expr_stmt|;
name|sc
operator|->
name|arpcom
operator|.
name|ac_enaddr
index|[
literal|0
index|]
operator|=
name|eaddr_tmp
operator|>>
literal|8
expr_stmt|;
name|tmp
operator|=
name|eeprom_read
argument_list|(
name|iobase
argument_list|,
name|EE_IRQ_No
argument_list|)
operator|&
name|IRQ_No_Mask
expr_stmt|;
comment|/* work out which set of irq<-> internal tables to use */
if|if
condition|(
name|sc
operator|->
name|arpcom
operator|.
name|ac_enaddr
index|[
literal|0
index|]
operator|==
literal|0x00
operator|&&
name|sc
operator|->
name|arpcom
operator|.
name|ac_enaddr
index|[
literal|1
index|]
operator|==
literal|0xA0
operator|&&
name|sc
operator|->
name|arpcom
operator|.
name|ac_enaddr
index|[
literal|2
index|]
operator|==
literal|0xC9
condition|)
block|{
comment|/* it's a 10+ */
name|sc
operator|->
name|irq2ee
operator|=
name|plus_irq2eemap
expr_stmt|;
name|sc
operator|->
name|ee2irq
operator|=
name|plus_ee2irqmap
expr_stmt|;
block|}
else|else
block|{
comment|/* it's an ordinary 10 */
name|sc
operator|->
name|irq2ee
operator|=
name|irq2eemap
expr_stmt|;
name|sc
operator|->
name|ee2irq
operator|=
name|ee2irqmap
expr_stmt|;
block|}
if|if
condition|(
name|dev
operator|->
name|id_irq
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|ee2irq
index|[
name|tmp
index|]
operator|!=
name|ffs
argument_list|(
name|dev
operator|->
name|id_irq
argument_list|)
operator|-
literal|1
condition|)
name|printf
argument_list|(
literal|"ex%d: WARNING: board's EEPROM is configured for IRQ %d, using %d\n"
argument_list|,
name|unit
argument_list|,
name|sc
operator|->
name|ee2irq
index|[
name|tmp
index|]
argument_list|,
name|ffs
argument_list|(
name|dev
operator|->
name|id_irq
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|sc
operator|->
name|irq_no
operator|=
name|ffs
argument_list|(
name|dev
operator|->
name|id_irq
argument_list|)
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|irq_no
operator|=
name|sc
operator|->
name|ee2irq
index|[
name|tmp
index|]
expr_stmt|;
name|dev
operator|->
name|id_irq
operator|=
literal|1
operator|<<
name|sc
operator|->
name|irq_no
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|irq_no
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"ex%d: invalid IRQ.\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|outb
argument_list|(
name|iobase
operator|+
name|CMD_REG
argument_list|,
name|Bank2_Sel
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|inb
argument_list|(
name|iobase
operator|+
name|REG3
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|&
name|TPE_bit
condition|)
name|sc
operator|->
name|connector
operator|=
name|Conn_TPE
expr_stmt|;
elseif|else
if|if
condition|(
name|tmp
operator|&
name|BNC_bit
condition|)
name|sc
operator|->
name|connector
operator|=
name|Conn_BNC
expr_stmt|;
else|else
name|sc
operator|->
name|connector
operator|=
name|Conn_AUI
expr_stmt|;
name|sc
operator|->
name|mem_size
operator|=
name|CARD_RAM_SIZE
expr_stmt|;
comment|/* XXX This should be read from the card itself. */
name|outb
argument_list|(
name|iobase
operator|+
name|CMD_REG
argument_list|,
name|Bank0_Sel
argument_list|)
expr_stmt|;
name|DODEBUG
argument_list|(
argument|Start_End
argument_list|,
argument|printf(
literal|"ex_probe%d: finish\n"
argument|, unit);
argument_list|)
empty_stmt|;
return|return
operator|(
name|EX_IOSIZE
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ex_attach
parameter_list|(
name|struct
name|isa_device
modifier|*
name|dev
parameter_list|)
block|{
name|int
name|unit
init|=
name|dev
operator|->
name|id_unit
decl_stmt|;
name|struct
name|ex_softc
modifier|*
name|sc
init|=
operator|&
name|ex_sc
index|[
name|unit
index|]
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
decl_stmt|;
name|struct
name|ifaddr
modifier|*
name|ifa
decl_stmt|;
name|struct
name|sockaddr_dl
modifier|*
name|sdl
decl_stmt|;
name|DODEBUG
argument_list|(
argument|Start_End
argument_list|,
argument|printf(
literal|"ex_attach%d: start\n"
argument|, unit);
argument_list|)
empty_stmt|;
comment|/* 	 * Initialize the ifnet structure. 	 */
name|ifp
operator|->
name|if_softc
operator|=
name|sc
expr_stmt|;
name|ifp
operator|->
name|if_unit
operator|=
name|unit
expr_stmt|;
name|ifp
operator|->
name|if_name
operator|=
literal|"ex"
expr_stmt|;
name|ifp
operator|->
name|if_init
operator|=
name|ex_init
expr_stmt|;
name|ifp
operator|->
name|if_output
operator|=
name|ether_output
expr_stmt|;
name|ifp
operator|->
name|if_start
operator|=
name|ex_start
expr_stmt|;
name|ifp
operator|->
name|if_ioctl
operator|=
name|ex_ioctl
expr_stmt|;
name|ifp
operator|->
name|if_watchdog
operator|=
name|ex_watchdog
expr_stmt|;
name|ifp
operator|->
name|if_mtu
operator|=
name|ETHERMTU
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|=
name|IFF_SIMPLEX
operator||
name|IFF_BROADCAST
comment|/* XXX not done yet. | IFF_MULTICAST */
expr_stmt|;
comment|/* 	 * Attach the interface. 	 */
name|if_attach
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|ether_ifattach
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|arpcom
operator|.
name|ac_enaddr
index|[
literal|0
index|]
operator|==
literal|0x00
operator|&&
name|sc
operator|->
name|arpcom
operator|.
name|ac_enaddr
index|[
literal|1
index|]
operator|==
literal|0xA0
operator|&&
name|sc
operator|->
name|arpcom
operator|.
name|ac_enaddr
index|[
literal|2
index|]
operator|==
literal|0xC9
condition|)
block|{
name|printf
argument_list|(
literal|"ex%d: Intel EtherExpress Pro/10+, address %6D, connector "
argument_list|,
name|dev
operator|->
name|id_unit
argument_list|,
name|sc
operator|->
name|arpcom
operator|.
name|ac_enaddr
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"ex%d: Intel EtherExpress Pro/10, address %6D, connector "
argument_list|,
name|dev
operator|->
name|id_unit
argument_list|,
name|sc
operator|->
name|arpcom
operator|.
name|ac_enaddr
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|sc
operator|->
name|connector
condition|)
block|{
case|case
name|Conn_TPE
case|:
name|printf
argument_list|(
literal|"TPE\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|Conn_BNC
case|:
name|printf
argument_list|(
literal|"BNC\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|Conn_AUI
case|:
name|printf
argument_list|(
literal|"AUI\n"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"???\n"
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If BPF is in the kernel, call the attach for it 	 */
if|#
directive|if
name|NBPFILTER
operator|>
literal|0
name|bpfattach
argument_list|(
name|ifp
argument_list|,
name|DLT_EN10MB
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|DODEBUG
argument_list|(
argument|Start_End
argument_list|,
argument|printf(
literal|"ex_attach%d: finish\n"
argument|, unit);
argument_list|)
empty_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|void
name|ex_init
parameter_list|(
name|void
modifier|*
name|xsc
parameter_list|)
block|{
specifier|register
name|struct
name|ex_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|ex_softc
operator|*
operator|)
name|xsc
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
decl_stmt|;
name|int
name|s
decl_stmt|,
name|i
decl_stmt|;
specifier|register
name|int
name|iobase
init|=
name|sc
operator|->
name|iobase
decl_stmt|;
name|unsigned
name|short
name|temp_reg
decl_stmt|;
name|DODEBUG
argument_list|(
argument|Start_End
argument_list|,
argument|printf(
literal|"ex_init%d: start\n"
argument|, ifp->if_unit);
argument_list|)
empty_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_addrhead
operator|.
name|tqh_first
operator|==
name|NULL
condition|)
return|return;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_timer
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Load the ethernet address into the card. 	 */
name|outb
argument_list|(
name|iobase
operator|+
name|CMD_REG
argument_list|,
name|Bank2_Sel
argument_list|)
expr_stmt|;
name|temp_reg
operator|=
name|inb
argument_list|(
name|iobase
operator|+
name|EEPROM_REG
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp_reg
operator|&
name|Trnoff_Enable
condition|)
name|outb
argument_list|(
name|iobase
operator|+
name|EEPROM_REG
argument_list|,
name|temp_reg
operator|&
operator|~
name|Trnoff_Enable
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ETHER_ADDR_LEN
condition|;
name|i
operator|++
control|)
name|outb
argument_list|(
name|iobase
operator|+
name|I_ADDR_REG0
operator|+
name|i
argument_list|,
name|sc
operator|->
name|arpcom
operator|.
name|ac_enaddr
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|/* 	 * - Setup transmit chaining and discard bad received frames. 	 * - Match broadcast. 	 * - Clear test mode. 	 * - Set receiving mode. 	 * - Set IRQ number. 	 */
name|outb
argument_list|(
name|iobase
operator|+
name|REG1
argument_list|,
name|inb
argument_list|(
name|iobase
operator|+
name|REG1
argument_list|)
operator||
name|Tx_Chn_Int_Md
operator||
name|Tx_Chn_ErStp
operator||
name|Disc_Bad_Fr
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|iobase
operator|+
name|REG2
argument_list|,
name|inb
argument_list|(
name|iobase
operator|+
name|REG2
argument_list|)
operator||
name|No_SA_Ins
operator||
name|RX_CRC_InMem
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|iobase
operator|+
name|REG3
argument_list|,
name|inb
argument_list|(
name|iobase
operator|+
name|REG3
argument_list|)
operator|&
literal|0x3f
comment|/* XXX constants. */
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|iobase
operator|+
name|CMD_REG
argument_list|,
name|Bank1_Sel
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|iobase
operator|+
name|INT_NO_REG
argument_list|,
operator|(
name|inb
argument_list|(
name|iobase
operator|+
name|INT_NO_REG
argument_list|)
operator|&
literal|0xf8
operator|)
operator||
name|sc
operator|->
name|irq2ee
index|[
name|sc
operator|->
name|irq_no
index|]
argument_list|)
expr_stmt|;
comment|/* 	 * Divide the available memory in the card into rcv and xmt buffers. 	 * By default, I use the first 3/4 of the memory for the rcv buffer, 	 * and the remaining 1/4 of the memory for the xmt buffer. 	 */
name|sc
operator|->
name|rx_mem_size
operator|=
name|sc
operator|->
name|mem_size
operator|*
literal|3
operator|/
literal|4
expr_stmt|;
name|sc
operator|->
name|tx_mem_size
operator|=
name|sc
operator|->
name|mem_size
operator|-
name|sc
operator|->
name|rx_mem_size
expr_stmt|;
name|sc
operator|->
name|rx_lower_limit
operator|=
literal|0x0000
expr_stmt|;
name|sc
operator|->
name|rx_upper_limit
operator|=
name|sc
operator|->
name|rx_mem_size
operator|-
literal|2
expr_stmt|;
name|sc
operator|->
name|tx_lower_limit
operator|=
name|sc
operator|->
name|rx_mem_size
expr_stmt|;
name|sc
operator|->
name|tx_upper_limit
operator|=
name|sc
operator|->
name|mem_size
operator|-
literal|2
expr_stmt|;
name|outb
argument_list|(
name|iobase
operator|+
name|RCV_LOWER_LIMIT_REG
argument_list|,
name|sc
operator|->
name|rx_lower_limit
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|iobase
operator|+
name|RCV_UPPER_LIMIT_REG
argument_list|,
name|sc
operator|->
name|rx_upper_limit
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|iobase
operator|+
name|XMT_LOWER_LIMIT_REG
argument_list|,
name|sc
operator|->
name|tx_lower_limit
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|iobase
operator|+
name|XMT_UPPER_LIMIT_REG
argument_list|,
name|sc
operator|->
name|tx_upper_limit
operator|>>
literal|8
argument_list|)
expr_stmt|;
comment|/* 	 * Enable receive and transmit interrupts, and clear any pending int. 	 */
name|outb
argument_list|(
name|iobase
operator|+
name|REG1
argument_list|,
name|inb
argument_list|(
name|iobase
operator|+
name|REG1
argument_list|)
operator||
name|TriST_INT
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|iobase
operator|+
name|CMD_REG
argument_list|,
name|Bank0_Sel
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|iobase
operator|+
name|MASK_REG
argument_list|,
name|All_Int
operator|&
operator|~
operator|(
name|Rx_Int
operator||
name|Tx_Int
operator|)
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|iobase
operator|+
name|STATUS_REG
argument_list|,
name|All_Int
argument_list|)
expr_stmt|;
comment|/* 	 * Initialize receive and transmit ring buffers. 	 */
name|outw
argument_list|(
name|iobase
operator|+
name|RCV_BAR
argument_list|,
name|sc
operator|->
name|rx_lower_limit
argument_list|)
expr_stmt|;
name|sc
operator|->
name|rx_head
operator|=
name|sc
operator|->
name|rx_lower_limit
expr_stmt|;
name|outw
argument_list|(
name|iobase
operator|+
name|RCV_STOP_REG
argument_list|,
name|sc
operator|->
name|rx_upper_limit
operator||
literal|0xfe
argument_list|)
expr_stmt|;
name|outw
argument_list|(
name|iobase
operator|+
name|XMT_BAR
argument_list|,
name|sc
operator|->
name|tx_lower_limit
argument_list|)
expr_stmt|;
name|sc
operator|->
name|tx_head
operator|=
name|sc
operator|->
name|tx_tail
operator|=
name|sc
operator|->
name|tx_lower_limit
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_RUNNING
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
name|IFF_OACTIVE
expr_stmt|;
name|DODEBUG
argument_list|(
argument|Status
argument_list|,
argument|printf(
literal|"OIDLE init\n"
argument|);
argument_list|)
empty_stmt|;
comment|/* 	 * Final reset of the board, and enable operation. 	 */
name|outb
argument_list|(
name|iobase
operator|+
name|CMD_REG
argument_list|,
name|Sel_Reset_CMD
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|iobase
operator|+
name|CMD_REG
argument_list|,
name|Rcv_Enable_CMD
argument_list|)
expr_stmt|;
name|ex_start
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|DODEBUG
argument_list|(
argument|Start_End
argument_list|,
argument|printf(
literal|"ex_init%d: finish\n"
argument|, ifp->if_unit);
argument_list|)
empty_stmt|;
block|}
end_function

begin_function
name|void
name|ex_start
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|int
name|unit
init|=
name|ifp
operator|->
name|if_unit
decl_stmt|;
specifier|register
name|struct
name|ex_softc
modifier|*
name|sc
init|=
operator|&
name|ex_sc
index|[
name|unit
index|]
decl_stmt|;
specifier|register
name|int
name|iobase
init|=
name|sc
operator|->
name|iobase
decl_stmt|;
name|int
name|i
decl_stmt|,
name|s
decl_stmt|,
name|len
decl_stmt|,
name|data_len
decl_stmt|,
name|avail
decl_stmt|,
name|dest
decl_stmt|,
name|next
decl_stmt|;
name|unsigned
name|char
name|tmp16
index|[
literal|2
index|]
decl_stmt|,
modifier|*
name|cP
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|opkt
decl_stmt|;
specifier|register
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|DODEBUG
argument_list|(
argument|Start_End
argument_list|,
argument|printf(
literal|"ex_start%d: start\n"
argument|, unit);
argument_list|)
empty_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
comment|/*    * Main loop: send outgoing packets to network card until there are no    * more packets left, or the card cannot accept any more yet.    */
while|while
condition|(
operator|(
operator|(
name|opkt
operator|=
name|ifp
operator|->
name|if_snd
operator|.
name|ifq_head
operator|)
operator|!=
name|NULL
operator|)
operator|&&
operator|!
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_OACTIVE
operator|)
condition|)
block|{
comment|/*      * Ensure there is enough free transmit buffer space for this packet,      * including its header. Note: the header cannot wrap around the end of      * the transmit buffer and must be kept together, so we allow space for      * twice the length of the header, just in case.      */
for|for
control|(
name|len
operator|=
literal|0
operator|,
name|m
operator|=
name|opkt
init|;
name|m
operator|!=
name|NULL
condition|;
name|m
operator|=
name|m
operator|->
name|m_next
control|)
name|len
operator|+=
name|m
operator|->
name|m_len
expr_stmt|;
name|data_len
operator|=
name|len
expr_stmt|;
name|DODEBUG
argument_list|(
argument|Sent_Pkts
argument_list|,
argument|printf(
literal|"1. Sending packet with %d data bytes. "
argument|, data_len);
argument_list|)
empty_stmt|;
if|if
condition|(
name|len
operator|&
literal|1
condition|)
name|len
operator|+=
name|XMT_HEADER_LEN
operator|+
literal|1
expr_stmt|;
else|else
name|len
operator|+=
name|XMT_HEADER_LEN
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|=
name|sc
operator|->
name|tx_tail
operator|-
name|sc
operator|->
name|tx_head
operator|)
operator|>=
literal|0
condition|)
name|avail
operator|=
name|sc
operator|->
name|tx_mem_size
operator|-
name|i
expr_stmt|;
else|else
name|avail
operator|=
operator|-
name|i
expr_stmt|;
name|DODEBUG
argument_list|(
argument|Sent_Pkts
argument_list|,
argument|printf(
literal|"i=%d, avail=%d\n"
argument|, i, avail);
argument_list|)
empty_stmt|;
if|if
condition|(
name|avail
operator|>=
name|len
operator|+
name|XMT_HEADER_LEN
condition|)
block|{
name|IF_DEQUEUE
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|opkt
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|EX_PSA_INTR
comment|/*        * Disable rx and tx interrupts, to avoid corruption of the host        * address register by interrupt service routines. XXX Is this necessary with splimp() enabled?        */
name|outb
argument_list|(
name|iobase
operator|+
name|MASK_REG
argument_list|,
name|All_Int
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*        * Compute the start and end addresses of this frame in the tx buffer.        */
name|dest
operator|=
name|sc
operator|->
name|tx_tail
expr_stmt|;
name|next
operator|=
name|dest
operator|+
name|len
expr_stmt|;
if|if
condition|(
name|next
operator|>
name|sc
operator|->
name|tx_upper_limit
condition|)
block|{
if|if
condition|(
operator|(
name|sc
operator|->
name|tx_upper_limit
operator|+
literal|2
operator|-
name|sc
operator|->
name|tx_tail
operator|)
operator|<=
name|XMT_HEADER_LEN
condition|)
block|{
name|dest
operator|=
name|sc
operator|->
name|tx_lower_limit
expr_stmt|;
name|next
operator|=
name|dest
operator|+
name|len
expr_stmt|;
block|}
else|else
name|next
operator|=
name|sc
operator|->
name|tx_lower_limit
operator|+
name|next
operator|-
name|sc
operator|->
name|tx_upper_limit
operator|-
literal|2
expr_stmt|;
block|}
comment|/*        * Build the packet frame in the card's ring buffer.        */
name|DODEBUG
argument_list|(
argument|Sent_Pkts
argument_list|,
argument|printf(
literal|"2. dest=%d, next=%d. "
argument|, dest, next);
argument_list|)
empty_stmt|;
name|outw
argument_list|(
name|iobase
operator|+
name|HOST_ADDR_REG
argument_list|,
name|dest
argument_list|)
expr_stmt|;
name|outw
argument_list|(
name|iobase
operator|+
name|IO_PORT_REG
argument_list|,
name|Transmit_CMD
argument_list|)
expr_stmt|;
name|outw
argument_list|(
name|iobase
operator|+
name|IO_PORT_REG
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|outw
argument_list|(
name|iobase
operator|+
name|IO_PORT_REG
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|outw
argument_list|(
name|iobase
operator|+
name|IO_PORT_REG
argument_list|,
name|data_len
argument_list|)
expr_stmt|;
comment|/* 	 * Output the packet data to the card. Ensure all transfers are 	 * 16-bit wide, even if individual mbufs have odd length. 	 */
for|for
control|(
name|m
operator|=
name|opkt
operator|,
name|i
operator|=
literal|0
init|;
name|m
operator|!=
name|NULL
condition|;
name|m
operator|=
name|m
operator|->
name|m_next
control|)
block|{
name|DODEBUG
argument_list|(
argument|Sent_Pkts
argument_list|,
argument|printf(
literal|"[%d]"
argument|, m->m_len);
argument_list|)
empty_stmt|;
if|if
condition|(
name|i
condition|)
block|{
name|tmp16
index|[
literal|1
index|]
operator|=
operator|*
operator|(
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
operator|)
expr_stmt|;
name|outsw
argument_list|(
name|iobase
operator|+
name|IO_PORT_REG
argument_list|,
name|tmp16
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|outsw
argument_list|(
name|iobase
operator|+
name|IO_PORT_REG
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
operator|+
name|i
argument_list|,
operator|(
name|m
operator|->
name|m_len
operator|-
name|i
operator|)
operator|/
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|=
operator|(
name|m
operator|->
name|m_len
operator|-
name|i
operator|)
operator|&
literal|1
condition|)
name|tmp16
index|[
literal|0
index|]
operator|=
operator|*
operator|(
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
operator|+
name|m
operator|->
name|m_len
operator|-
literal|1
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|i
condition|)
name|outsw
argument_list|(
name|iobase
operator|+
name|IO_PORT_REG
argument_list|,
name|tmp16
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/*        * If there were other frames chained, update the chain in the last one.        */
if|if
condition|(
name|sc
operator|->
name|tx_head
operator|!=
name|sc
operator|->
name|tx_tail
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|tx_tail
operator|!=
name|dest
condition|)
block|{
name|outw
argument_list|(
name|iobase
operator|+
name|HOST_ADDR_REG
argument_list|,
name|sc
operator|->
name|tx_last
operator|+
name|XMT_Chain_Point
argument_list|)
expr_stmt|;
name|outw
argument_list|(
name|iobase
operator|+
name|IO_PORT_REG
argument_list|,
name|dest
argument_list|)
expr_stmt|;
block|}
name|outw
argument_list|(
name|iobase
operator|+
name|HOST_ADDR_REG
argument_list|,
name|sc
operator|->
name|tx_last
operator|+
name|XMT_Byte_Count
argument_list|)
expr_stmt|;
name|i
operator|=
name|inw
argument_list|(
name|iobase
operator|+
name|IO_PORT_REG
argument_list|)
expr_stmt|;
name|outw
argument_list|(
name|iobase
operator|+
name|HOST_ADDR_REG
argument_list|,
name|sc
operator|->
name|tx_last
operator|+
name|XMT_Byte_Count
argument_list|)
expr_stmt|;
name|outw
argument_list|(
name|iobase
operator|+
name|IO_PORT_REG
argument_list|,
name|i
operator||
name|Ch_bit
argument_list|)
expr_stmt|;
block|}
comment|/*        * Resume normal operation of the card:        * - Make a dummy read to flush the DRAM write pipeline.        * - Enable receive and transmit interrupts.        * - Send Transmit or Resume_XMT command, as appropriate.        */
name|inw
argument_list|(
name|iobase
operator|+
name|IO_PORT_REG
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|EX_PSA_INTR
name|outb
argument_list|(
name|iobase
operator|+
name|MASK_REG
argument_list|,
name|All_Int
operator|&
operator|~
operator|(
name|Rx_Int
operator||
name|Tx_Int
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|sc
operator|->
name|tx_head
operator|==
name|sc
operator|->
name|tx_tail
condition|)
block|{
name|outw
argument_list|(
name|iobase
operator|+
name|XMT_BAR
argument_list|,
name|dest
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|iobase
operator|+
name|CMD_REG
argument_list|,
name|Transmit_CMD
argument_list|)
expr_stmt|;
name|sc
operator|->
name|tx_head
operator|=
name|dest
expr_stmt|;
name|DODEBUG
argument_list|(
argument|Sent_Pkts
argument_list|,
argument|printf(
literal|"Transmit\n"
argument|);
argument_list|)
empty_stmt|;
block|}
else|else
block|{
name|outb
argument_list|(
name|iobase
operator|+
name|CMD_REG
argument_list|,
name|Resume_XMT_List_CMD
argument_list|)
expr_stmt|;
name|DODEBUG
argument_list|(
argument|Sent_Pkts
argument_list|,
argument|printf(
literal|"Resume\n"
argument|);
argument_list|)
empty_stmt|;
block|}
name|sc
operator|->
name|tx_last
operator|=
name|dest
expr_stmt|;
name|sc
operator|->
name|tx_tail
operator|=
name|next
expr_stmt|;
if|#
directive|if
name|NBPFILTER
operator|>
literal|0
if|if
condition|(
name|ifp
operator|->
name|if_bpf
operator|!=
name|NULL
condition|)
name|bpf_mtap
argument_list|(
name|ifp
argument_list|,
name|opkt
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ifp
operator|->
name|if_timer
operator|=
literal|2
expr_stmt|;
name|ifp
operator|->
name|if_opackets
operator|++
expr_stmt|;
name|m_freem
argument_list|(
name|opkt
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_OACTIVE
expr_stmt|;
name|DODEBUG
argument_list|(
argument|Status
argument_list|,
argument|printf(
literal|"OACTIVE start\n"
argument|);
argument_list|)
empty_stmt|;
block|}
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|DODEBUG
argument_list|(
argument|Start_End
argument_list|,
argument|printf(
literal|"ex_start%d: finish\n"
argument|, unit);
argument_list|)
empty_stmt|;
block|}
end_function

begin_function
name|void
name|ex_stop
parameter_list|(
name|int
name|unit
parameter_list|)
block|{
name|struct
name|ex_softc
modifier|*
name|sc
init|=
operator|&
name|ex_sc
index|[
name|unit
index|]
decl_stmt|;
name|int
name|iobase
init|=
name|sc
operator|->
name|iobase
decl_stmt|;
name|DODEBUG
argument_list|(
argument|Start_End
argument_list|,
argument|printf(
literal|"ex_stop%d: start\n"
argument|, unit);
argument_list|)
empty_stmt|;
comment|/*    * Disable card operation:    * - Disable the interrupt line.    * - Flush transmission and disable reception.    * - Mask and clear all interrupts.    * - Reset the 82595.    */
name|outb
argument_list|(
name|iobase
operator|+
name|CMD_REG
argument_list|,
name|Bank1_Sel
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|iobase
operator|+
name|REG1
argument_list|,
name|inb
argument_list|(
name|iobase
operator|+
name|REG1
argument_list|)
operator|&
operator|~
name|TriST_INT
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|iobase
operator|+
name|CMD_REG
argument_list|,
name|Bank0_Sel
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|iobase
operator|+
name|CMD_REG
argument_list|,
name|Rcv_Stop
argument_list|)
expr_stmt|;
name|sc
operator|->
name|tx_head
operator|=
name|sc
operator|->
name|tx_tail
operator|=
name|sc
operator|->
name|tx_lower_limit
expr_stmt|;
name|sc
operator|->
name|tx_last
operator|=
literal|0
expr_stmt|;
comment|/* XXX I think these two lines are not necessary, because ex_init will always be called again to reinit the interface. */
name|outb
argument_list|(
name|iobase
operator|+
name|MASK_REG
argument_list|,
name|All_Int
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|iobase
operator|+
name|STATUS_REG
argument_list|,
name|All_Int
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|iobase
operator|+
name|CMD_REG
argument_list|,
name|Reset_CMD
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|200
argument_list|)
expr_stmt|;
name|DODEBUG
argument_list|(
argument|Start_End
argument_list|,
argument|printf(
literal|"ex_stop%d: finish\n"
argument|, unit);
argument_list|)
empty_stmt|;
block|}
end_function

begin_function
name|void
name|exintr
parameter_list|(
name|int
name|unit
parameter_list|)
block|{
name|struct
name|ex_softc
modifier|*
name|sc
init|=
operator|&
name|ex_sc
index|[
name|unit
index|]
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
decl_stmt|;
name|int
name|iobase
init|=
name|sc
operator|->
name|iobase
decl_stmt|;
name|int
name|s
decl_stmt|,
name|int_status
decl_stmt|,
name|send_pkts
decl_stmt|;
name|DODEBUG
argument_list|(
argument|Start_End
argument_list|,
argument|printf(
literal|"exintr%d: start\n"
argument|, unit);
argument_list|)
empty_stmt|;
ifdef|#
directive|ifdef
name|EXDEBUG
if|if
condition|(
operator|++
name|exintr_count
operator|!=
literal|1
condition|)
name|printf
argument_list|(
literal|"WARNING: nested interrupt (%d). Mail the author.\n"
argument_list|,
name|exintr_count
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|send_pkts
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|int_status
operator|=
name|inb
argument_list|(
name|iobase
operator|+
name|STATUS_REG
argument_list|)
operator|)
operator|&
operator|(
name|Tx_Int
operator||
name|Rx_Int
operator|)
condition|)
block|{
if|if
condition|(
name|int_status
operator|&
name|Rx_Int
condition|)
block|{
name|outb
argument_list|(
name|iobase
operator|+
name|STATUS_REG
argument_list|,
name|Rx_Int
argument_list|)
expr_stmt|;
name|ex_rx_intr
argument_list|(
name|unit
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|int_status
operator|&
name|Tx_Int
condition|)
block|{
name|outb
argument_list|(
name|iobase
operator|+
name|STATUS_REG
argument_list|,
name|Tx_Int
argument_list|)
expr_stmt|;
name|ex_tx_intr
argument_list|(
name|unit
argument_list|)
expr_stmt|;
name|send_pkts
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|/*    * If any packet has been transmitted, and there are queued packets to    * be sent, attempt to send more packets to the network card.    */
if|if
condition|(
name|send_pkts
operator|&&
operator|(
name|ifp
operator|->
name|if_snd
operator|.
name|ifq_head
operator|!=
name|NULL
operator|)
condition|)
name|ex_start
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|EXDEBUG
name|exintr_count
operator|--
expr_stmt|;
endif|#
directive|endif
name|DODEBUG
argument_list|(
argument|Start_End
argument_list|,
argument|printf(
literal|"exintr%d: finish\n"
argument|, unit);
argument_list|)
empty_stmt|;
block|}
end_function

begin_function
name|void
name|ex_tx_intr
parameter_list|(
name|int
name|unit
parameter_list|)
block|{
specifier|register
name|struct
name|ex_softc
modifier|*
name|sc
init|=
operator|&
name|ex_sc
index|[
name|unit
index|]
decl_stmt|;
specifier|register
name|struct
name|ifnet
modifier|*
name|ifp
init|=
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
decl_stmt|;
specifier|register
name|int
name|iobase
init|=
name|sc
operator|->
name|iobase
decl_stmt|;
name|int
name|tx_status
decl_stmt|;
name|DODEBUG
argument_list|(
argument|Start_End
argument_list|,
argument|printf(
literal|"ex_tx_intr%d: start\n"
argument|, unit);
argument_list|)
empty_stmt|;
comment|/*    * - Cancel the watchdog.    * For all packets transmitted since last transmit interrupt:    * - Advance chain pointer to next queued packet.    * - Update statistics.    */
name|ifp
operator|->
name|if_timer
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|sc
operator|->
name|tx_head
operator|!=
name|sc
operator|->
name|tx_tail
condition|)
block|{
name|outw
argument_list|(
name|iobase
operator|+
name|HOST_ADDR_REG
argument_list|,
name|sc
operator|->
name|tx_head
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|inw
argument_list|(
name|iobase
operator|+
name|IO_PORT_REG
argument_list|)
operator|&
name|Done_bit
condition|)
break|break;
name|tx_status
operator|=
name|inw
argument_list|(
name|iobase
operator|+
name|IO_PORT_REG
argument_list|)
expr_stmt|;
name|sc
operator|->
name|tx_head
operator|=
name|inw
argument_list|(
name|iobase
operator|+
name|IO_PORT_REG
argument_list|)
expr_stmt|;
if|if
condition|(
name|tx_status
operator|&
name|TX_OK_bit
condition|)
name|ifp
operator|->
name|if_opackets
operator|++
expr_stmt|;
else|else
name|ifp
operator|->
name|if_oerrors
operator|++
expr_stmt|;
name|ifp
operator|->
name|if_collisions
operator|+=
name|tx_status
operator|&
name|No_Collisions_bits
expr_stmt|;
block|}
comment|/*    * The card should be ready to accept more packets now.    */
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
name|IFF_OACTIVE
expr_stmt|;
name|DODEBUG
argument_list|(
argument|Status
argument_list|,
argument|printf(
literal|"OIDLE tx_intr\n"
argument|);
argument_list|)
empty_stmt|;
name|DODEBUG
argument_list|(
argument|Start_End
argument_list|,
argument|printf(
literal|"ex_tx_intr%d: finish\n"
argument|, unit);
argument_list|)
empty_stmt|;
block|}
end_function

begin_function
name|void
name|ex_rx_intr
parameter_list|(
name|int
name|unit
parameter_list|)
block|{
specifier|register
name|struct
name|ex_softc
modifier|*
name|sc
init|=
operator|&
name|ex_sc
index|[
name|unit
index|]
decl_stmt|;
specifier|register
name|struct
name|ifnet
modifier|*
name|ifp
init|=
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
decl_stmt|;
specifier|register
name|int
name|iobase
init|=
name|sc
operator|->
name|iobase
decl_stmt|;
name|int
name|rx_status
decl_stmt|,
name|pkt_len
decl_stmt|,
name|QQQ
decl_stmt|;
specifier|register
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|,
modifier|*
name|ipkt
decl_stmt|;
name|struct
name|ether_header
modifier|*
name|eh
decl_stmt|;
name|DODEBUG
argument_list|(
argument|Start_End
argument_list|,
argument|printf(
literal|"ex_rx_intr%d: start\n"
argument|, unit);
argument_list|)
empty_stmt|;
comment|/*    * For all packets received since last receive interrupt:    * - If packet ok, read it into a new mbuf and queue it to interface,    *   updating statistics.    * - If packet bad, just discard it, and update statistics.    * Finally, advance receive stop limit in card's memory to new location.    */
name|outw
argument_list|(
name|iobase
operator|+
name|HOST_ADDR_REG
argument_list|,
name|sc
operator|->
name|rx_head
argument_list|)
expr_stmt|;
while|while
condition|(
name|inw
argument_list|(
name|iobase
operator|+
name|IO_PORT_REG
argument_list|)
operator|==
name|RCV_Done
condition|)
block|{
name|rx_status
operator|=
name|inw
argument_list|(
name|iobase
operator|+
name|IO_PORT_REG
argument_list|)
expr_stmt|;
name|sc
operator|->
name|rx_head
operator|=
name|inw
argument_list|(
name|iobase
operator|+
name|IO_PORT_REG
argument_list|)
expr_stmt|;
name|QQQ
operator|=
name|pkt_len
operator|=
name|inw
argument_list|(
name|iobase
operator|+
name|IO_PORT_REG
argument_list|)
expr_stmt|;
if|if
condition|(
name|rx_status
operator|&
name|RCV_OK_bit
condition|)
block|{
name|MGETHDR
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
name|ipkt
operator|=
name|m
expr_stmt|;
if|if
condition|(
name|ipkt
operator|==
name|NULL
condition|)
name|ifp
operator|->
name|if_iqdrops
operator|++
expr_stmt|;
else|else
block|{
name|ipkt
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|ifp
expr_stmt|;
name|ipkt
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|pkt_len
expr_stmt|;
name|ipkt
operator|->
name|m_len
operator|=
name|MHLEN
expr_stmt|;
while|while
condition|(
name|pkt_len
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|pkt_len
operator|>
name|MINCLSIZE
condition|)
block|{
name|MCLGET
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_flags
operator|&
name|M_EXT
condition|)
name|m
operator|->
name|m_len
operator|=
name|MCLBYTES
expr_stmt|;
else|else
block|{
name|m_freem
argument_list|(
name|ipkt
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_iqdrops
operator|++
expr_stmt|;
goto|goto
name|rx_another
goto|;
block|}
block|}
name|m
operator|->
name|m_len
operator|=
name|min
argument_list|(
name|m
operator|->
name|m_len
argument_list|,
name|pkt_len
argument_list|)
expr_stmt|;
comment|/* 	   * NOTE: I'm assuming that all mbufs allocated are of even length, 	   * except for the last one in an odd-length packet. 	   */
name|insw
argument_list|(
name|iobase
operator|+
name|IO_PORT_REG
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
name|m
operator|->
name|m_len
operator|/
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_len
operator|&
literal|1
condition|)
operator|*
operator|(
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
operator|+
name|m
operator|->
name|m_len
operator|-
literal|1
operator|)
operator|=
name|inb
argument_list|(
name|iobase
operator|+
name|IO_PORT_REG
argument_list|)
expr_stmt|;
name|pkt_len
operator|-=
name|m
operator|->
name|m_len
expr_stmt|;
if|if
condition|(
name|pkt_len
operator|>
literal|0
condition|)
block|{
name|MGET
argument_list|(
name|m
operator|->
name|m_next
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_next
operator|==
name|NULL
condition|)
block|{
name|m_freem
argument_list|(
name|ipkt
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_iqdrops
operator|++
expr_stmt|;
goto|goto
name|rx_another
goto|;
block|}
name|m
operator|=
name|m
operator|->
name|m_next
expr_stmt|;
name|m
operator|->
name|m_len
operator|=
name|MLEN
expr_stmt|;
block|}
block|}
name|eh
operator|=
name|mtod
argument_list|(
name|ipkt
argument_list|,
expr|struct
name|ether_header
operator|*
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|EXDEBUG
if|if
condition|(
name|debug_mask
operator|&
name|Rcvd_Pkts
condition|)
block|{
if|if
condition|(
operator|(
name|eh
operator|->
name|ether_dhost
index|[
literal|5
index|]
operator|!=
literal|0xff
operator|)
operator|||
operator|(
name|eh
operator|->
name|ether_dhost
index|[
literal|0
index|]
operator|!=
literal|0xff
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"Receive packet with %d data bytes: %6D -> "
argument_list|,
name|QQQ
argument_list|,
name|eh
operator|->
name|ether_shost
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%6D\n"
argument_list|,
name|eh
operator|->
name|ether_dhost
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
block|}
comment|/* QQQ */
block|}
endif|#
directive|endif
if|#
directive|if
name|NBPFILTER
operator|>
literal|0
if|if
condition|(
name|ifp
operator|->
name|if_bpf
operator|!=
name|NULL
condition|)
block|{
name|bpf_mtap
argument_list|(
name|ifp
argument_list|,
name|ipkt
argument_list|)
expr_stmt|;
comment|/* 		 * Note that the interface cannot be in promiscuous mode if there are 		 * no BPF listeners. And if we are in promiscuous mode, we have to 		 * check if this packet is really ours. 		 */
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_PROMISC
operator|)
operator|&&
operator|(
name|eh
operator|->
name|ether_dhost
index|[
literal|0
index|]
operator|&
literal|1
operator|)
operator|==
literal|0
operator|&&
name|bcmp
argument_list|(
name|eh
operator|->
name|ether_dhost
argument_list|,
name|sc
operator|->
name|arpcom
operator|.
name|ac_enaddr
argument_list|,
sizeof|sizeof
argument_list|(
name|eh
operator|->
name|ether_dhost
argument_list|)
argument_list|)
operator|!=
literal|0
operator|&&
name|bcmp
argument_list|(
name|eh
operator|->
name|ether_dhost
argument_list|,
name|etherbroadcastaddr
argument_list|,
sizeof|sizeof
argument_list|(
name|eh
operator|->
name|ether_dhost
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|m_freem
argument_list|(
name|ipkt
argument_list|)
expr_stmt|;
goto|goto
name|rx_another
goto|;
block|}
block|}
endif|#
directive|endif
name|m_adj
argument_list|(
name|ipkt
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
argument_list|)
expr_stmt|;
name|ether_input
argument_list|(
name|ifp
argument_list|,
name|eh
argument_list|,
name|ipkt
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_ipackets
operator|++
expr_stmt|;
block|}
block|}
else|else
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
name|outw
argument_list|(
name|iobase
operator|+
name|HOST_ADDR_REG
argument_list|,
name|sc
operator|->
name|rx_head
argument_list|)
expr_stmt|;
name|rx_another
label|:
empty_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|rx_head
operator|<
name|sc
operator|->
name|rx_lower_limit
operator|+
literal|2
condition|)
name|outw
argument_list|(
name|iobase
operator|+
name|RCV_STOP_REG
argument_list|,
name|sc
operator|->
name|rx_upper_limit
argument_list|)
expr_stmt|;
else|else
name|outw
argument_list|(
name|iobase
operator|+
name|RCV_STOP_REG
argument_list|,
name|sc
operator|->
name|rx_head
operator|-
literal|2
argument_list|)
expr_stmt|;
name|DODEBUG
argument_list|(
argument|Start_End
argument_list|,
argument|printf(
literal|"ex_rx_intr%d: finish\n"
argument|, unit);
argument_list|)
empty_stmt|;
block|}
end_function

begin_function
name|int
name|ex_ioctl
parameter_list|(
specifier|register
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|int
name|cmd
parameter_list|,
name|caddr_t
name|data
parameter_list|)
block|{
specifier|register
name|struct
name|ifaddr
modifier|*
name|ifa
init|=
operator|(
expr|struct
name|ifaddr
operator|*
operator|)
name|data
decl_stmt|;
name|struct
name|ex_softc
modifier|*
name|sc
init|=
operator|&
name|ex_sc
index|[
name|ifp
operator|->
name|if_unit
index|]
decl_stmt|;
name|struct
name|ifreq
modifier|*
name|ifr
init|=
operator|(
expr|struct
name|ifreq
operator|*
operator|)
name|data
decl_stmt|;
name|int
name|s
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
name|DODEBUG
argument_list|(
argument|Start_End
argument_list|,
argument|printf(
literal|"ex_ioctl%d: start "
argument|, ifp->if_unit);
argument_list|)
empty_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|SIOCSIFADDR
case|:
name|DODEBUG
argument_list|(
argument|Start_End
argument_list|,
argument|printf(
literal|"SIOCSIFADDR"
argument|);
argument_list|)
empty_stmt|;
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_UP
expr_stmt|;
switch|switch
condition|(
name|ifa
operator|->
name|ifa_addr
operator|->
name|sa_family
condition|)
block|{
ifdef|#
directive|ifdef
name|INET
case|case
name|AF_INET
case|:
name|ex_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|arp_ifinit
argument_list|(
operator|(
expr|struct
name|arpcom
operator|*
operator|)
name|ifp
argument_list|,
name|ifa
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|IPX_NOTYET
case|case
name|AF_IPX
case|:
block|{
specifier|register
name|struct
name|ipx_addr
modifier|*
name|ina
init|=
operator|&
operator|(
name|IA_SIPX
argument_list|(
name|ifa
argument_list|)
operator|->
name|sipx_addr
operator|)
decl_stmt|;
if|if
condition|(
name|ipx_nullhost
argument_list|(
operator|*
name|ina
argument_list|)
condition|)
name|ina
operator|->
name|x_host
operator|=
operator|*
operator|(
expr|union
name|ipx_host
operator|*
operator|)
operator|(
name|sc
operator|->
name|arpcom
operator|.
name|ac_enaddr
operator|)
expr_stmt|;
else|else
block|{
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
name|IFF_RUNNING
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|ina
operator|->
name|x_host
operator|.
name|c_host
argument_list|,
operator|(
name|caddr_t
operator|)
name|sc
operator|->
name|arpcom
operator|.
name|ac_enaddr
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|arpcom
operator|.
name|ac_enaddr
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|ex_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|NS
case|case
name|AF_NS
case|:
block|{
specifier|register
name|struct
name|ns_addr
modifier|*
name|ina
init|=
operator|&
operator|(
name|IA_SNS
argument_list|(
name|ifa
argument_list|)
operator|->
name|sns_addr
operator|)
decl_stmt|;
if|if
condition|(
name|ns_nullhost
argument_list|(
operator|*
name|ina
argument_list|)
condition|)
name|ina
operator|->
name|x_host
operator|=
operator|*
operator|(
expr|union
name|ns_host
operator|*
operator|)
operator|(
name|sc
operator|->
name|arpcom
operator|.
name|ac_enaddr
operator|)
expr_stmt|;
else|else
block|{
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
name|IFF_RUNNING
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|ina
operator|->
name|x_host
operator|.
name|c_host
argument_list|,
operator|(
name|caddr_t
operator|)
name|sc
operator|->
name|arpcom
operator|.
name|ac_enaddr
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|arpcom
operator|.
name|ac_enaddr
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|ex_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
default|default:
name|ex_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|SIOCGIFADDR
case|:
block|{
name|struct
name|sockaddr
modifier|*
name|sa
decl_stmt|;
name|DODEBUG
argument_list|(
argument|Start_End
argument_list|,
argument|printf(
literal|"SIOCGIFADDR"
argument|);
argument_list|)
empty_stmt|;
name|sa
operator|=
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|ifr
operator|->
name|ifr_data
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|sc
operator|->
name|arpcom
operator|.
name|ac_enaddr
argument_list|,
operator|(
name|caddr_t
operator|)
name|sa
operator|->
name|sa_data
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SIOCSIFFLAGS
case|:
name|DODEBUG
argument_list|(
argument|Start_End
argument_list|,
argument|printf(
literal|"SIOCSIFFLAGS"
argument|);
argument_list|)
empty_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
operator|)
operator|==
literal|0
operator|&&
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
condition|)
block|{
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
name|IFF_RUNNING
expr_stmt|;
name|ex_stop
argument_list|(
name|ifp
operator|->
name|if_unit
argument_list|)
expr_stmt|;
block|}
else|else
name|ex_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|NODEF
case|case
name|SIOCGHWADDR
case|:
name|DODEBUG
argument_list|(
argument|Start_End
argument_list|,
argument|printf(
literal|"SIOCGHWADDR"
argument|);
argument_list|)
empty_stmt|;
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|sc
operator|->
name|sc_addr
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|ifr
operator|->
name|ifr_data
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|sc_addr
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|SIOCSIFMTU
case|:
name|DODEBUG
argument_list|(
argument|Start_End
argument_list|,
argument|printf(
literal|"SIOCSIFMTU"
argument|);
argument_list|)
empty_stmt|;
if|if
condition|(
name|ifr
operator|->
name|ifr_mtu
operator|>
name|ETHERMTU
condition|)
name|error
operator|=
name|EINVAL
expr_stmt|;
else|else
name|ifp
operator|->
name|if_mtu
operator|=
name|ifr
operator|->
name|ifr_mtu
expr_stmt|;
break|break;
case|case
name|SIOCADDMULTI
case|:
name|DODEBUG
argument_list|(
argument|Start_End
argument_list|,
argument|printf(
literal|"SIOCADDMULTI"
argument|);
argument_list|)
empty_stmt|;
case|case
name|SIOCDELMULTI
case|:
name|DODEBUG
argument_list|(
argument|Start_End
argument_list|,
argument|printf(
literal|"SIOCDELMULTI"
argument|);
argument_list|)
empty_stmt|;
comment|/* XXX Support not done yet. */
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
default|default:
name|DODEBUG
argument_list|(
argument|Start_End
argument_list|,
argument|printf(
literal|"unknown"
argument|);
argument_list|)
empty_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|DODEBUG
argument_list|(
argument|Start_End
argument_list|,
argument|printf(
literal|"\nex_ioctl%d: finish\n"
argument|, ifp->if_unit);
argument_list|)
empty_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|void
name|ex_reset
parameter_list|(
name|int
name|unit
parameter_list|)
block|{
name|struct
name|ex_softc
modifier|*
name|sc
init|=
operator|&
name|ex_sc
index|[
name|unit
index|]
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
decl_stmt|;
name|int
name|s
decl_stmt|;
name|DODEBUG
argument_list|(
argument|Start_End
argument_list|,
argument|printf(
literal|"ex_reset%d: start\n"
argument|, unit);
argument_list|)
empty_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|ex_stop
argument_list|(
name|unit
argument_list|)
expr_stmt|;
name|ex_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|DODEBUG
argument_list|(
argument|Start_End
argument_list|,
argument|printf(
literal|"ex_reset%d: finish\n"
argument|, unit);
argument_list|)
empty_stmt|;
block|}
end_function

begin_function
name|void
name|ex_watchdog
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|ex_softc
modifier|*
name|sc
init|=
operator|&
name|ex_sc
index|[
name|ifp
operator|->
name|if_unit
index|]
decl_stmt|;
name|DODEBUG
argument_list|(
argument|Start_End
argument_list|,
argument|printf(
literal|"ex_watchdog%d: start\n"
argument|, ifp->if_unit);
argument_list|)
empty_stmt|;
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
name|IFF_OACTIVE
expr_stmt|;
name|DODEBUG
argument_list|(
argument|Status
argument_list|,
argument|printf(
literal|"OIDLE watchdog\n"
argument|);
argument_list|)
empty_stmt|;
name|ifp
operator|->
name|if_oerrors
operator|++
expr_stmt|;
name|ex_reset
argument_list|(
name|ifp
operator|->
name|if_unit
argument_list|)
expr_stmt|;
name|ex_start
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|DODEBUG
argument_list|(
argument|Start_End
argument_list|,
argument|printf(
literal|"ex_watchdog%d: finish\n"
argument|, ifp->if_unit);
argument_list|)
empty_stmt|;
block|}
end_function

begin_function
specifier|static
name|u_short
name|eeprom_read
parameter_list|(
name|int
name|iobase
parameter_list|,
name|int
name|location
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|u_short
name|data
init|=
literal|0
decl_stmt|;
name|int
name|ee_addr
decl_stmt|;
name|int
name|read_cmd
init|=
name|location
operator||
name|EE_READ_CMD
decl_stmt|;
name|short
name|ctrl_val
init|=
name|EECS
decl_stmt|;
name|ee_addr
operator|=
name|iobase
operator|+
name|EEPROM_REG
expr_stmt|;
name|outb
argument_list|(
name|iobase
operator|+
name|CMD_REG
argument_list|,
name|Bank2_Sel
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|ee_addr
argument_list|,
name|EECS
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|8
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|short
name|outval
init|=
operator|(
name|read_cmd
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
operator|)
condition|?
name|ctrl_val
operator||
name|EEDI
else|:
name|ctrl_val
decl_stmt|;
name|outb
argument_list|(
name|ee_addr
argument_list|,
name|outval
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|ee_addr
argument_list|,
name|outval
operator||
name|EESK
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|3
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|ee_addr
argument_list|,
name|outval
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
name|outb
argument_list|(
name|ee_addr
argument_list|,
name|ctrl_val
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|16
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|outb
argument_list|(
name|ee_addr
argument_list|,
name|ctrl_val
operator||
name|EESK
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|3
argument_list|)
expr_stmt|;
name|data
operator|=
operator|(
name|data
operator|<<
literal|1
operator|)
operator||
operator|(
operator|(
name|inb
argument_list|(
name|ee_addr
argument_list|)
operator|&
name|EEDO
operator|)
condition|?
literal|1
else|:
literal|0
operator|)
expr_stmt|;
name|outb
argument_list|(
name|ee_addr
argument_list|,
name|ctrl_val
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
name|ctrl_val
operator|&=
operator|~
name|EECS
expr_stmt|;
name|outb
argument_list|(
name|ee_addr
argument_list|,
name|ctrl_val
operator||
name|EESK
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|3
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|ee_addr
argument_list|,
name|ctrl_val
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|iobase
operator|+
name|CMD_REG
argument_list|,
name|Bank0_Sel
argument_list|)
expr_stmt|;
return|return
operator|(
name|data
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NEX> 0 */
end_comment

end_unit

