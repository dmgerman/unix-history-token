begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1996, Javier Mart√≠n Rueda (jmrueda@diatel.upm.es)  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice unmodified, this list of conditions, and the following  *    disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $FreeBSD$  *  * MAINTAINER: Matthew N. Dodd<winter@jurai.net>  *<mdodd@FreeBSD.org>  */
end_comment

begin_comment
comment|/*  * Intel EtherExpress Pro/10, Pro/10+ Ethernet driver  *  * Revision history:  *  * 30-Oct-1996: first beta version. Inet and BPF supported, but no multicast.  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_arp.h>
end_include

begin_include
include|#
directive|include
file|<net/if_media.h>
end_include

begin_include
include|#
directive|include
file|<net/ethernet.h>
end_include

begin_include
include|#
directive|include
file|<net/bpf.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/if_ether.h>
end_include

begin_include
include|#
directive|include
file|<isa/isavar.h>
end_include

begin_include
include|#
directive|include
file|<isa/pnpvar.h>
end_include

begin_include
include|#
directive|include
file|<dev/ex/if_exreg.h>
end_include

begin_include
include|#
directive|include
file|<dev/ex/if_exvar.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|EXDEBUG
end_ifdef

begin_define
define|#
directive|define
name|Start_End
value|1
end_define

begin_define
define|#
directive|define
name|Rcvd_Pkts
value|2
end_define

begin_define
define|#
directive|define
name|Sent_Pkts
value|4
end_define

begin_define
define|#
directive|define
name|Status
value|8
end_define

begin_decl_stmt
specifier|static
name|int
name|debug_mask
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|exintr_count
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|DODEBUG
parameter_list|(
name|level
parameter_list|,
name|action
parameter_list|)
value|if (level& debug_mask) action
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|DODEBUG
parameter_list|(
name|level
parameter_list|,
name|action
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|char
name|irq2eemap
index|[]
init|=
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|,
literal|0
block|,
literal|1
block|,
operator|-
literal|1
block|,
literal|2
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
literal|0
block|,
literal|3
block|,
literal|4
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_char
name|ee2irqmap
index|[]
init|=
block|{
literal|9
block|,
literal|3
block|,
literal|5
block|,
literal|10
block|,
literal|11
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|plus_irq2eemap
index|[]
init|=
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|2
block|,
operator|-
literal|1
block|,
literal|3
block|,
operator|-
literal|1
block|,
literal|4
block|,
literal|5
block|,
literal|6
block|,
literal|7
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_char
name|plus_ee2irqmap
index|[]
init|=
block|{
literal|3
block|,
literal|4
block|,
literal|5
block|,
literal|7
block|,
literal|9
block|,
literal|10
block|,
literal|11
block|,
literal|12
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Network Interface Functions */
end_comment

begin_function_decl
specifier|static
name|void
name|ex_init
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ex_start
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ex_ioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|u_long
parameter_list|,
name|caddr_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ex_watchdog
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* ifmedia Functions	*/
end_comment

begin_function_decl
specifier|static
name|int
name|ex_ifmedia_upd
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ex_ifmedia_sts
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|struct
name|ifmediareq
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ex_get_media
parameter_list|(
name|u_int32_t
name|iobase
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ex_reset
parameter_list|(
name|struct
name|ex_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ex_tx_intr
parameter_list|(
name|struct
name|ex_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ex_rx_intr
parameter_list|(
name|struct
name|ex_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|int
name|look_for_card
parameter_list|(
name|u_int32_t
name|iobase
parameter_list|)
block|{
name|int
name|count1
decl_stmt|,
name|count2
decl_stmt|;
comment|/* 	 * Check for the i82595 signature, and check that the round robin 	 * counter actually advances. 	 */
if|if
condition|(
operator|(
operator|(
name|count1
operator|=
name|inb
argument_list|(
name|iobase
operator|+
name|ID_REG
argument_list|)
operator|)
operator|&
name|Id_Mask
operator|)
operator|!=
name|Id_Sig
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|count2
operator|=
name|inb
argument_list|(
name|iobase
operator|+
name|ID_REG
argument_list|)
expr_stmt|;
name|count2
operator|=
name|inb
argument_list|(
name|iobase
operator|+
name|ID_REG
argument_list|)
expr_stmt|;
name|count2
operator|=
name|inb
argument_list|(
name|iobase
operator|+
name|ID_REG
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|count2
operator|&
name|Counter_bits
operator|)
operator|==
operator|(
operator|(
name|count1
operator|+
literal|0xc0
operator|)
operator|&
name|Counter_bits
operator|)
operator|)
return|;
block|}
end_function

begin_function
name|void
name|ex_get_address
parameter_list|(
name|u_int32_t
name|iobase
parameter_list|,
name|u_char
modifier|*
name|enaddr
parameter_list|)
block|{
name|u_int16_t
name|eaddr_tmp
decl_stmt|;
name|eaddr_tmp
operator|=
name|eeprom_read
argument_list|(
name|iobase
argument_list|,
name|EE_Eth_Addr_Lo
argument_list|)
expr_stmt|;
name|enaddr
index|[
literal|5
index|]
operator|=
name|eaddr_tmp
operator|&
literal|0xff
expr_stmt|;
name|enaddr
index|[
literal|4
index|]
operator|=
name|eaddr_tmp
operator|>>
literal|8
expr_stmt|;
name|eaddr_tmp
operator|=
name|eeprom_read
argument_list|(
name|iobase
argument_list|,
name|EE_Eth_Addr_Mid
argument_list|)
expr_stmt|;
name|enaddr
index|[
literal|3
index|]
operator|=
name|eaddr_tmp
operator|&
literal|0xff
expr_stmt|;
name|enaddr
index|[
literal|2
index|]
operator|=
name|eaddr_tmp
operator|>>
literal|8
expr_stmt|;
name|eaddr_tmp
operator|=
name|eeprom_read
argument_list|(
name|iobase
argument_list|,
name|EE_Eth_Addr_Hi
argument_list|)
expr_stmt|;
name|enaddr
index|[
literal|1
index|]
operator|=
name|eaddr_tmp
operator|&
literal|0xff
expr_stmt|;
name|enaddr
index|[
literal|0
index|]
operator|=
name|eaddr_tmp
operator|>>
literal|8
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|int
name|ex_card_type
parameter_list|(
name|u_char
modifier|*
name|enaddr
parameter_list|)
block|{
if|if
condition|(
operator|(
name|enaddr
index|[
literal|0
index|]
operator|==
literal|0x00
operator|)
operator|&&
operator|(
name|enaddr
index|[
literal|1
index|]
operator|==
literal|0xA0
operator|)
operator|&&
operator|(
name|enaddr
index|[
literal|2
index|]
operator|==
literal|0xC9
operator|)
condition|)
return|return
operator|(
name|CARD_TYPE_EX_10_PLUS
operator|)
return|;
return|return
operator|(
name|CARD_TYPE_EX_10
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Caller is responsible for eventually calling  * ex_release_resources() on failure.  */
end_comment

begin_function
name|int
name|ex_alloc_resources
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|ex_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|sc
operator|->
name|ioport
operator|=
name|bus_alloc_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
operator|&
name|sc
operator|->
name|ioport_rid
argument_list|,
literal|0
argument_list|,
operator|~
literal|0
argument_list|,
literal|1
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sc
operator|->
name|ioport
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"No I/O space?!\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|sc
operator|->
name|irq
operator|=
name|bus_alloc_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|sc
operator|->
name|irq_rid
argument_list|,
literal|0
argument_list|,
operator|~
literal|0
argument_list|,
literal|1
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sc
operator|->
name|irq
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"No IRQ?!\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|bad
label|:
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|void
name|ex_release_resources
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|ex_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|ih
condition|)
block|{
name|bus_teardown_intr
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|irq
argument_list|,
name|sc
operator|->
name|ih
argument_list|)
expr_stmt|;
name|sc
operator|->
name|ih
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|ioport
condition|)
block|{
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
name|sc
operator|->
name|ioport_rid
argument_list|,
name|sc
operator|->
name|ioport
argument_list|)
expr_stmt|;
name|sc
operator|->
name|ioport
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|irq
condition|)
block|{
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|sc
operator|->
name|irq_rid
argument_list|,
name|sc
operator|->
name|irq
argument_list|)
expr_stmt|;
name|sc
operator|->
name|irq
operator|=
name|NULL
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_function
name|int
name|ex_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|ex_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
decl_stmt|;
name|struct
name|ifmedia
modifier|*
name|ifm
decl_stmt|;
name|int
name|unit
init|=
name|device_get_unit
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|u_int16_t
name|temp
decl_stmt|;
comment|/* work out which set of irq<-> internal tables to use */
if|if
condition|(
name|ex_card_type
argument_list|(
name|sc
operator|->
name|arpcom
operator|.
name|ac_enaddr
argument_list|)
operator|==
name|CARD_TYPE_EX_10_PLUS
condition|)
block|{
name|sc
operator|->
name|irq2ee
operator|=
name|plus_irq2eemap
expr_stmt|;
name|sc
operator|->
name|ee2irq
operator|=
name|plus_ee2irqmap
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|irq2ee
operator|=
name|irq2eemap
expr_stmt|;
name|sc
operator|->
name|ee2irq
operator|=
name|ee2irqmap
expr_stmt|;
block|}
name|sc
operator|->
name|mem_size
operator|=
name|CARD_RAM_SIZE
expr_stmt|;
comment|/* XXX This should be read from the card itself. */
comment|/* 	 * Initialize the ifnet structure. 	 */
name|ifp
operator|->
name|if_softc
operator|=
name|sc
expr_stmt|;
name|ifp
operator|->
name|if_unit
operator|=
name|unit
expr_stmt|;
name|ifp
operator|->
name|if_name
operator|=
literal|"ex"
expr_stmt|;
name|ifp
operator|->
name|if_mtu
operator|=
name|ETHERMTU
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|=
name|IFF_SIMPLEX
operator||
name|IFF_BROADCAST
comment|/* XXX not done yet. | IFF_MULTICAST */
expr_stmt|;
name|ifp
operator|->
name|if_output
operator|=
name|ether_output
expr_stmt|;
name|ifp
operator|->
name|if_start
operator|=
name|ex_start
expr_stmt|;
name|ifp
operator|->
name|if_ioctl
operator|=
name|ex_ioctl
expr_stmt|;
name|ifp
operator|->
name|if_watchdog
operator|=
name|ex_watchdog
expr_stmt|;
name|ifp
operator|->
name|if_init
operator|=
name|ex_init
expr_stmt|;
name|ifp
operator|->
name|if_snd
operator|.
name|ifq_maxlen
operator|=
name|IFQ_MAXLEN
expr_stmt|;
name|ifmedia_init
argument_list|(
operator|&
name|sc
operator|->
name|ifmedia
argument_list|,
literal|0
argument_list|,
name|ex_ifmedia_upd
argument_list|,
name|ex_ifmedia_sts
argument_list|)
expr_stmt|;
name|temp
operator|=
name|eeprom_read
argument_list|(
name|sc
operator|->
name|iobase
argument_list|,
name|EE_W5
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|&
name|EE_W5_PORT_TPE
condition|)
name|ifmedia_add
argument_list|(
operator|&
name|sc
operator|->
name|ifmedia
argument_list|,
name|IFM_ETHER
operator||
name|IFM_10_T
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|&
name|EE_W5_PORT_BNC
condition|)
name|ifmedia_add
argument_list|(
operator|&
name|sc
operator|->
name|ifmedia
argument_list|,
name|IFM_ETHER
operator||
name|IFM_10_2
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|&
name|EE_W5_PORT_AUI
condition|)
name|ifmedia_add
argument_list|(
operator|&
name|sc
operator|->
name|ifmedia
argument_list|,
name|IFM_ETHER
operator||
name|IFM_10_5
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ifmedia_set
argument_list|(
operator|&
name|sc
operator|->
name|ifmedia
argument_list|,
name|ex_get_media
argument_list|(
name|sc
operator|->
name|iobase
argument_list|)
argument_list|)
expr_stmt|;
name|ifm
operator|=
operator|&
name|sc
operator|->
name|ifmedia
expr_stmt|;
name|ifm
operator|->
name|ifm_media
operator|=
name|ifm
operator|->
name|ifm_cur
operator|->
name|ifm_media
expr_stmt|;
name|ex_ifmedia_upd
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
comment|/* 	 * Attach the interface. 	 */
name|ether_ifattach
argument_list|(
name|ifp
argument_list|,
name|ETHER_BPF_SUPPORTED
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Ethernet address %6D\n"
argument_list|,
name|sc
operator|->
name|arpcom
operator|.
name|ac_enaddr
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ex_init
parameter_list|(
name|void
modifier|*
name|xsc
parameter_list|)
block|{
name|struct
name|ex_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|ex_softc
operator|*
operator|)
name|xsc
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
decl_stmt|;
name|int
name|s
decl_stmt|;
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|iobase
init|=
name|sc
operator|->
name|iobase
decl_stmt|;
name|unsigned
name|short
name|temp_reg
decl_stmt|;
name|DODEBUG
argument_list|(
argument|Start_End
argument_list|,
argument|printf(
literal|"ex_init%d: start\n"
argument|, ifp->if_unit);
argument_list|)
empty_stmt|;
if|if
condition|(
name|TAILQ_FIRST
argument_list|(
operator|&
name|ifp
operator|->
name|if_addrhead
argument_list|)
operator|==
name|NULL
condition|)
block|{
return|return;
block|}
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|ifp
operator|->
name|if_timer
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Load the ethernet address into the card. 	 */
name|outb
argument_list|(
name|iobase
operator|+
name|CMD_REG
argument_list|,
name|Bank2_Sel
argument_list|)
expr_stmt|;
name|temp_reg
operator|=
name|inb
argument_list|(
name|iobase
operator|+
name|EEPROM_REG
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp_reg
operator|&
name|Trnoff_Enable
condition|)
block|{
name|outb
argument_list|(
name|iobase
operator|+
name|EEPROM_REG
argument_list|,
name|temp_reg
operator|&
operator|~
name|Trnoff_Enable
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ETHER_ADDR_LEN
condition|;
name|i
operator|++
control|)
block|{
name|outb
argument_list|(
name|iobase
operator|+
name|I_ADDR_REG0
operator|+
name|i
argument_list|,
name|sc
operator|->
name|arpcom
operator|.
name|ac_enaddr
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * - Setup transmit chaining and discard bad received frames. 	 * - Match broadcast. 	 * - Clear test mode. 	 * - Set receiving mode. 	 * - Set IRQ number. 	 */
name|outb
argument_list|(
name|iobase
operator|+
name|REG1
argument_list|,
name|inb
argument_list|(
name|iobase
operator|+
name|REG1
argument_list|)
operator||
name|Tx_Chn_Int_Md
operator||
name|Tx_Chn_ErStp
operator||
name|Disc_Bad_Fr
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|iobase
operator|+
name|REG2
argument_list|,
name|inb
argument_list|(
name|iobase
operator|+
name|REG2
argument_list|)
operator||
name|No_SA_Ins
operator||
name|RX_CRC_InMem
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|iobase
operator|+
name|REG3
argument_list|,
name|inb
argument_list|(
name|iobase
operator|+
name|REG3
argument_list|)
operator|&
literal|0x3f
comment|/* XXX constants. */
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|iobase
operator|+
name|CMD_REG
argument_list|,
name|Bank1_Sel
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|iobase
operator|+
name|INT_NO_REG
argument_list|,
operator|(
name|inb
argument_list|(
name|iobase
operator|+
name|INT_NO_REG
argument_list|)
operator|&
literal|0xf8
operator|)
operator||
name|sc
operator|->
name|irq2ee
index|[
name|sc
operator|->
name|irq_no
index|]
argument_list|)
expr_stmt|;
comment|/* 	 * Divide the available memory in the card into rcv and xmt buffers. 	 * By default, I use the first 3/4 of the memory for the rcv buffer, 	 * and the remaining 1/4 of the memory for the xmt buffer. 	 */
name|sc
operator|->
name|rx_mem_size
operator|=
name|sc
operator|->
name|mem_size
operator|*
literal|3
operator|/
literal|4
expr_stmt|;
name|sc
operator|->
name|tx_mem_size
operator|=
name|sc
operator|->
name|mem_size
operator|-
name|sc
operator|->
name|rx_mem_size
expr_stmt|;
name|sc
operator|->
name|rx_lower_limit
operator|=
literal|0x0000
expr_stmt|;
name|sc
operator|->
name|rx_upper_limit
operator|=
name|sc
operator|->
name|rx_mem_size
operator|-
literal|2
expr_stmt|;
name|sc
operator|->
name|tx_lower_limit
operator|=
name|sc
operator|->
name|rx_mem_size
expr_stmt|;
name|sc
operator|->
name|tx_upper_limit
operator|=
name|sc
operator|->
name|mem_size
operator|-
literal|2
expr_stmt|;
name|outb
argument_list|(
name|iobase
operator|+
name|RCV_LOWER_LIMIT_REG
argument_list|,
name|sc
operator|->
name|rx_lower_limit
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|iobase
operator|+
name|RCV_UPPER_LIMIT_REG
argument_list|,
name|sc
operator|->
name|rx_upper_limit
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|iobase
operator|+
name|XMT_LOWER_LIMIT_REG
argument_list|,
name|sc
operator|->
name|tx_lower_limit
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|iobase
operator|+
name|XMT_UPPER_LIMIT_REG
argument_list|,
name|sc
operator|->
name|tx_upper_limit
operator|>>
literal|8
argument_list|)
expr_stmt|;
comment|/* 	 * Enable receive and transmit interrupts, and clear any pending int. 	 */
name|outb
argument_list|(
name|iobase
operator|+
name|REG1
argument_list|,
name|inb
argument_list|(
name|iobase
operator|+
name|REG1
argument_list|)
operator||
name|TriST_INT
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|iobase
operator|+
name|CMD_REG
argument_list|,
name|Bank0_Sel
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|iobase
operator|+
name|MASK_REG
argument_list|,
name|All_Int
operator|&
operator|~
operator|(
name|Rx_Int
operator||
name|Tx_Int
operator|)
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|iobase
operator|+
name|STATUS_REG
argument_list|,
name|All_Int
argument_list|)
expr_stmt|;
comment|/* 	 * Initialize receive and transmit ring buffers. 	 */
name|outw
argument_list|(
name|iobase
operator|+
name|RCV_BAR
argument_list|,
name|sc
operator|->
name|rx_lower_limit
argument_list|)
expr_stmt|;
name|sc
operator|->
name|rx_head
operator|=
name|sc
operator|->
name|rx_lower_limit
expr_stmt|;
name|outw
argument_list|(
name|iobase
operator|+
name|RCV_STOP_REG
argument_list|,
name|sc
operator|->
name|rx_upper_limit
operator||
literal|0xfe
argument_list|)
expr_stmt|;
name|outw
argument_list|(
name|iobase
operator|+
name|XMT_BAR
argument_list|,
name|sc
operator|->
name|tx_lower_limit
argument_list|)
expr_stmt|;
name|sc
operator|->
name|tx_head
operator|=
name|sc
operator|->
name|tx_tail
operator|=
name|sc
operator|->
name|tx_lower_limit
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_RUNNING
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
name|IFF_OACTIVE
expr_stmt|;
name|DODEBUG
argument_list|(
argument|Status
argument_list|,
argument|printf(
literal|"OIDLE init\n"
argument|);
argument_list|)
empty_stmt|;
comment|/* 	 * Final reset of the board, and enable operation. 	 */
name|outb
argument_list|(
name|iobase
operator|+
name|CMD_REG
argument_list|,
name|Sel_Reset_CMD
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|iobase
operator|+
name|CMD_REG
argument_list|,
name|Rcv_Enable_CMD
argument_list|)
expr_stmt|;
name|ex_start
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|DODEBUG
argument_list|(
argument|Start_End
argument_list|,
argument|printf(
literal|"ex_init%d: finish\n"
argument|, ifp->if_unit);
argument_list|)
empty_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ex_start
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|ex_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|int
name|iobase
init|=
name|sc
operator|->
name|iobase
decl_stmt|;
name|int
name|i
decl_stmt|,
name|s
decl_stmt|,
name|len
decl_stmt|,
name|data_len
decl_stmt|,
name|avail
decl_stmt|,
name|dest
decl_stmt|,
name|next
decl_stmt|;
name|unsigned
name|char
name|tmp16
index|[
literal|2
index|]
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|opkt
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|DODEBUG
argument_list|(
argument|Start_End
argument_list|,
argument|printf(
literal|"ex_start%d: start\n"
argument|, unit);
argument_list|)
empty_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
comment|/* 	 * Main loop: send outgoing packets to network card until there are no 	 * more packets left, or the card cannot accept any more yet. 	 */
while|while
condition|(
operator|(
operator|(
name|opkt
operator|=
name|ifp
operator|->
name|if_snd
operator|.
name|ifq_head
operator|)
operator|!=
name|NULL
operator|)
operator|&&
operator|!
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_OACTIVE
operator|)
condition|)
block|{
comment|/* 		 * Ensure there is enough free transmit buffer space for 		 * this packet, including its header. Note: the header 		 * cannot wrap around the end of the transmit buffer and 		 * must be kept together, so we allow space for twice the 		 * length of the header, just in case. 		 */
for|for
control|(
name|len
operator|=
literal|0
operator|,
name|m
operator|=
name|opkt
init|;
name|m
operator|!=
name|NULL
condition|;
name|m
operator|=
name|m
operator|->
name|m_next
control|)
block|{
name|len
operator|+=
name|m
operator|->
name|m_len
expr_stmt|;
block|}
name|data_len
operator|=
name|len
expr_stmt|;
name|DODEBUG
argument_list|(
argument|Sent_Pkts
argument_list|,
argument|printf(
literal|"1. Sending packet with %d data bytes. "
argument|, data_len);
argument_list|)
empty_stmt|;
if|if
condition|(
name|len
operator|&
literal|1
condition|)
block|{
name|len
operator|+=
name|XMT_HEADER_LEN
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
name|len
operator|+=
name|XMT_HEADER_LEN
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|i
operator|=
name|sc
operator|->
name|tx_tail
operator|-
name|sc
operator|->
name|tx_head
operator|)
operator|>=
literal|0
condition|)
block|{
name|avail
operator|=
name|sc
operator|->
name|tx_mem_size
operator|-
name|i
expr_stmt|;
block|}
else|else
block|{
name|avail
operator|=
operator|-
name|i
expr_stmt|;
block|}
name|DODEBUG
argument_list|(
argument|Sent_Pkts
argument_list|,
argument|printf(
literal|"i=%d, avail=%d\n"
argument|, i, avail);
argument_list|)
empty_stmt|;
if|if
condition|(
name|avail
operator|>=
name|len
operator|+
name|XMT_HEADER_LEN
condition|)
block|{
name|IF_DEQUEUE
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|opkt
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|EX_PSA_INTR
comment|/* 			 * Disable rx and tx interrupts, to avoid corruption 			 * of the host address register by interrupt service 			 * routines. 			 * XXX Is this necessary with splimp() enabled? 			 */
name|outb
argument_list|(
name|iobase
operator|+
name|MASK_REG
argument_list|,
name|All_Int
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 			 * Compute the start and end addresses of this 			 * frame in the tx buffer. 			 */
name|dest
operator|=
name|sc
operator|->
name|tx_tail
expr_stmt|;
name|next
operator|=
name|dest
operator|+
name|len
expr_stmt|;
if|if
condition|(
name|next
operator|>
name|sc
operator|->
name|tx_upper_limit
condition|)
block|{
if|if
condition|(
operator|(
name|sc
operator|->
name|tx_upper_limit
operator|+
literal|2
operator|-
name|sc
operator|->
name|tx_tail
operator|)
operator|<=
name|XMT_HEADER_LEN
condition|)
block|{
name|dest
operator|=
name|sc
operator|->
name|tx_lower_limit
expr_stmt|;
name|next
operator|=
name|dest
operator|+
name|len
expr_stmt|;
block|}
else|else
block|{
name|next
operator|=
name|sc
operator|->
name|tx_lower_limit
operator|+
name|next
operator|-
name|sc
operator|->
name|tx_upper_limit
operator|-
literal|2
expr_stmt|;
block|}
block|}
comment|/* 			 * Build the packet frame in the card's ring buffer. 			 */
name|DODEBUG
argument_list|(
argument|Sent_Pkts
argument_list|,
argument|printf(
literal|"2. dest=%d, next=%d. "
argument|, dest, next);
argument_list|)
empty_stmt|;
name|outw
argument_list|(
name|iobase
operator|+
name|HOST_ADDR_REG
argument_list|,
name|dest
argument_list|)
expr_stmt|;
name|outw
argument_list|(
name|iobase
operator|+
name|IO_PORT_REG
argument_list|,
name|Transmit_CMD
argument_list|)
expr_stmt|;
name|outw
argument_list|(
name|iobase
operator|+
name|IO_PORT_REG
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|outw
argument_list|(
name|iobase
operator|+
name|IO_PORT_REG
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|outw
argument_list|(
name|iobase
operator|+
name|IO_PORT_REG
argument_list|,
name|data_len
argument_list|)
expr_stmt|;
comment|/* 			 * Output the packet data to the card. Ensure all 			 * transfers are 16-bit wide, even if individual 			 * mbufs have odd length. 			 */
for|for
control|(
name|m
operator|=
name|opkt
operator|,
name|i
operator|=
literal|0
init|;
name|m
operator|!=
name|NULL
condition|;
name|m
operator|=
name|m
operator|->
name|m_next
control|)
block|{
name|DODEBUG
argument_list|(
argument|Sent_Pkts
argument_list|,
argument|printf(
literal|"[%d]"
argument|, m->m_len);
argument_list|)
empty_stmt|;
if|if
condition|(
name|i
condition|)
block|{
name|tmp16
index|[
literal|1
index|]
operator|=
operator|*
operator|(
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
operator|)
expr_stmt|;
name|outsw
argument_list|(
name|iobase
operator|+
name|IO_PORT_REG
argument_list|,
name|tmp16
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|outsw
argument_list|(
name|iobase
operator|+
name|IO_PORT_REG
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
operator|+
name|i
argument_list|,
operator|(
name|m
operator|->
name|m_len
operator|-
name|i
operator|)
operator|/
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|=
operator|(
name|m
operator|->
name|m_len
operator|-
name|i
operator|)
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
block|{
name|tmp16
index|[
literal|0
index|]
operator|=
operator|*
operator|(
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
operator|+
name|m
operator|->
name|m_len
operator|-
literal|1
operator|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|i
condition|)
block|{
name|outsw
argument_list|(
name|iobase
operator|+
name|IO_PORT_REG
argument_list|,
name|tmp16
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* 			 * If there were other frames chained, update the 			 * chain in the last one. 			 */
if|if
condition|(
name|sc
operator|->
name|tx_head
operator|!=
name|sc
operator|->
name|tx_tail
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|tx_tail
operator|!=
name|dest
condition|)
block|{
name|outw
argument_list|(
name|iobase
operator|+
name|HOST_ADDR_REG
argument_list|,
name|sc
operator|->
name|tx_last
operator|+
name|XMT_Chain_Point
argument_list|)
expr_stmt|;
name|outw
argument_list|(
name|iobase
operator|+
name|IO_PORT_REG
argument_list|,
name|dest
argument_list|)
expr_stmt|;
block|}
name|outw
argument_list|(
name|iobase
operator|+
name|HOST_ADDR_REG
argument_list|,
name|sc
operator|->
name|tx_last
operator|+
name|XMT_Byte_Count
argument_list|)
expr_stmt|;
name|i
operator|=
name|inw
argument_list|(
name|iobase
operator|+
name|IO_PORT_REG
argument_list|)
expr_stmt|;
name|outw
argument_list|(
name|iobase
operator|+
name|HOST_ADDR_REG
argument_list|,
name|sc
operator|->
name|tx_last
operator|+
name|XMT_Byte_Count
argument_list|)
expr_stmt|;
name|outw
argument_list|(
name|iobase
operator|+
name|IO_PORT_REG
argument_list|,
name|i
operator||
name|Ch_bit
argument_list|)
expr_stmt|;
block|}
comment|/* 			 * Resume normal operation of the card: 			 * - Make a dummy read to flush the DRAM write 			 *   pipeline. 			 * - Enable receive and transmit interrupts. 			 * - Send Transmit or Resume_XMT command, as 			 *   appropriate. 			 */
name|inw
argument_list|(
name|iobase
operator|+
name|IO_PORT_REG
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|EX_PSA_INTR
name|outb
argument_list|(
name|iobase
operator|+
name|MASK_REG
argument_list|,
name|All_Int
operator|&
operator|~
operator|(
name|Rx_Int
operator||
name|Tx_Int
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|sc
operator|->
name|tx_head
operator|==
name|sc
operator|->
name|tx_tail
condition|)
block|{
name|outw
argument_list|(
name|iobase
operator|+
name|XMT_BAR
argument_list|,
name|dest
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|iobase
operator|+
name|CMD_REG
argument_list|,
name|Transmit_CMD
argument_list|)
expr_stmt|;
name|sc
operator|->
name|tx_head
operator|=
name|dest
expr_stmt|;
name|DODEBUG
argument_list|(
argument|Sent_Pkts
argument_list|,
argument|printf(
literal|"Transmit\n"
argument|);
argument_list|)
empty_stmt|;
block|}
else|else
block|{
name|outb
argument_list|(
name|iobase
operator|+
name|CMD_REG
argument_list|,
name|Resume_XMT_List_CMD
argument_list|)
expr_stmt|;
name|DODEBUG
argument_list|(
argument|Sent_Pkts
argument_list|,
argument|printf(
literal|"Resume\n"
argument|);
argument_list|)
empty_stmt|;
block|}
name|sc
operator|->
name|tx_last
operator|=
name|dest
expr_stmt|;
name|sc
operator|->
name|tx_tail
operator|=
name|next
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_bpf
operator|!=
name|NULL
condition|)
block|{
name|bpf_mtap
argument_list|(
name|ifp
argument_list|,
name|opkt
argument_list|)
expr_stmt|;
block|}
name|ifp
operator|->
name|if_timer
operator|=
literal|2
expr_stmt|;
name|ifp
operator|->
name|if_opackets
operator|++
expr_stmt|;
name|m_freem
argument_list|(
name|opkt
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_OACTIVE
expr_stmt|;
name|DODEBUG
argument_list|(
argument|Status
argument_list|,
argument|printf(
literal|"OACTIVE start\n"
argument|);
argument_list|)
empty_stmt|;
block|}
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|DODEBUG
argument_list|(
argument|Start_End
argument_list|,
argument|printf(
literal|"ex_start%d: finish\n"
argument|, unit);
argument_list|)
empty_stmt|;
block|}
end_function

begin_function
name|void
name|ex_stop
parameter_list|(
name|struct
name|ex_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|iobase
init|=
name|sc
operator|->
name|iobase
decl_stmt|;
name|DODEBUG
argument_list|(
argument|Start_End
argument_list|,
argument|printf(
literal|"ex_stop%d: start\n"
argument|, unit);
argument_list|)
empty_stmt|;
comment|/* 	 * Disable card operation: 	 * - Disable the interrupt line. 	 * - Flush transmission and disable reception. 	 * - Mask and clear all interrupts. 	 * - Reset the 82595. 	 */
name|outb
argument_list|(
name|iobase
operator|+
name|CMD_REG
argument_list|,
name|Bank1_Sel
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|iobase
operator|+
name|REG1
argument_list|,
name|inb
argument_list|(
name|iobase
operator|+
name|REG1
argument_list|)
operator|&
operator|~
name|TriST_INT
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|iobase
operator|+
name|CMD_REG
argument_list|,
name|Bank0_Sel
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|iobase
operator|+
name|CMD_REG
argument_list|,
name|Rcv_Stop
argument_list|)
expr_stmt|;
name|sc
operator|->
name|tx_head
operator|=
name|sc
operator|->
name|tx_tail
operator|=
name|sc
operator|->
name|tx_lower_limit
expr_stmt|;
name|sc
operator|->
name|tx_last
operator|=
literal|0
expr_stmt|;
comment|/* XXX I think these two lines are not necessary, because ex_init will always be called again to reinit the interface. */
name|outb
argument_list|(
name|iobase
operator|+
name|MASK_REG
argument_list|,
name|All_Int
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|iobase
operator|+
name|STATUS_REG
argument_list|,
name|All_Int
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|iobase
operator|+
name|CMD_REG
argument_list|,
name|Reset_CMD
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|200
argument_list|)
expr_stmt|;
name|DODEBUG
argument_list|(
argument|Start_End
argument_list|,
argument|printf(
literal|"ex_stop%d: finish\n"
argument|, unit);
argument_list|)
empty_stmt|;
return|return;
block|}
end_function

begin_function
name|void
name|ex_intr
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ex_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|ex_softc
operator|*
operator|)
name|arg
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
decl_stmt|;
name|int
name|iobase
init|=
name|sc
operator|->
name|iobase
decl_stmt|;
name|int
name|int_status
decl_stmt|,
name|send_pkts
decl_stmt|;
name|DODEBUG
argument_list|(
argument|Start_End
argument_list|,
argument|printf(
literal|"ex_intr%d: start\n"
argument|, unit);
argument_list|)
empty_stmt|;
ifdef|#
directive|ifdef
name|EXDEBUG
if|if
condition|(
operator|++
name|exintr_count
operator|!=
literal|1
condition|)
name|printf
argument_list|(
literal|"WARNING: nested interrupt (%d). Mail the author.\n"
argument_list|,
name|exintr_count
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|send_pkts
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|int_status
operator|=
name|inb
argument_list|(
name|iobase
operator|+
name|STATUS_REG
argument_list|)
operator|)
operator|&
operator|(
name|Tx_Int
operator||
name|Rx_Int
operator|)
condition|)
block|{
if|if
condition|(
name|int_status
operator|&
name|Rx_Int
condition|)
block|{
name|outb
argument_list|(
name|iobase
operator|+
name|STATUS_REG
argument_list|,
name|Rx_Int
argument_list|)
expr_stmt|;
name|ex_rx_intr
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|int_status
operator|&
name|Tx_Int
condition|)
block|{
name|outb
argument_list|(
name|iobase
operator|+
name|STATUS_REG
argument_list|,
name|Tx_Int
argument_list|)
expr_stmt|;
name|ex_tx_intr
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|send_pkts
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|/* 	 * If any packet has been transmitted, and there are queued packets to 	 * be sent, attempt to send more packets to the network card. 	 */
if|if
condition|(
name|send_pkts
operator|&&
operator|(
name|ifp
operator|->
name|if_snd
operator|.
name|ifq_head
operator|!=
name|NULL
operator|)
condition|)
block|{
name|ex_start
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|EXDEBUG
name|exintr_count
operator|--
expr_stmt|;
endif|#
directive|endif
name|DODEBUG
argument_list|(
argument|Start_End
argument_list|,
argument|printf(
literal|"ex_intr%d: finish\n"
argument|, unit);
argument_list|)
empty_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|ex_tx_intr
parameter_list|(
name|struct
name|ex_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
decl_stmt|;
name|int
name|iobase
init|=
name|sc
operator|->
name|iobase
decl_stmt|;
name|int
name|tx_status
decl_stmt|;
name|DODEBUG
argument_list|(
argument|Start_End
argument_list|,
argument|printf(
literal|"ex_tx_intr%d: start\n"
argument|, unit);
argument_list|)
empty_stmt|;
comment|/* 	 * - Cancel the watchdog. 	 * For all packets transmitted since last transmit interrupt: 	 * - Advance chain pointer to next queued packet. 	 * - Update statistics. 	 */
name|ifp
operator|->
name|if_timer
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|sc
operator|->
name|tx_head
operator|!=
name|sc
operator|->
name|tx_tail
condition|)
block|{
name|outw
argument_list|(
name|iobase
operator|+
name|HOST_ADDR_REG
argument_list|,
name|sc
operator|->
name|tx_head
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|inw
argument_list|(
name|iobase
operator|+
name|IO_PORT_REG
argument_list|)
operator|&
name|Done_bit
condition|)
break|break;
name|tx_status
operator|=
name|inw
argument_list|(
name|iobase
operator|+
name|IO_PORT_REG
argument_list|)
expr_stmt|;
name|sc
operator|->
name|tx_head
operator|=
name|inw
argument_list|(
name|iobase
operator|+
name|IO_PORT_REG
argument_list|)
expr_stmt|;
if|if
condition|(
name|tx_status
operator|&
name|TX_OK_bit
condition|)
block|{
name|ifp
operator|->
name|if_opackets
operator|++
expr_stmt|;
block|}
else|else
block|{
name|ifp
operator|->
name|if_oerrors
operator|++
expr_stmt|;
block|}
name|ifp
operator|->
name|if_collisions
operator|+=
name|tx_status
operator|&
name|No_Collisions_bits
expr_stmt|;
block|}
comment|/* 	 * The card should be ready to accept more packets now. 	 */
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
name|IFF_OACTIVE
expr_stmt|;
name|DODEBUG
argument_list|(
argument|Status
argument_list|,
argument|printf(
literal|"OIDLE tx_intr\n"
argument|);
argument_list|)
empty_stmt|;
name|DODEBUG
argument_list|(
argument|Start_End
argument_list|,
argument|printf(
literal|"ex_tx_intr%d: finish\n"
argument|, unit);
argument_list|)
empty_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|ex_rx_intr
parameter_list|(
name|struct
name|ex_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
decl_stmt|;
name|int
name|iobase
init|=
name|sc
operator|->
name|iobase
decl_stmt|;
name|int
name|rx_status
decl_stmt|;
name|int
name|pkt_len
decl_stmt|;
name|int
name|QQQ
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|ipkt
decl_stmt|;
name|struct
name|ether_header
modifier|*
name|eh
decl_stmt|;
name|DODEBUG
argument_list|(
argument|Start_End
argument_list|,
argument|printf(
literal|"ex_rx_intr%d: start\n"
argument|, unit);
argument_list|)
empty_stmt|;
comment|/* 	 * For all packets received since last receive interrupt: 	 * - If packet ok, read it into a new mbuf and queue it to interface, 	 *   updating statistics. 	 * - If packet bad, just discard it, and update statistics. 	 * Finally, advance receive stop limit in card's memory to new location. 	 */
name|outw
argument_list|(
name|iobase
operator|+
name|HOST_ADDR_REG
argument_list|,
name|sc
operator|->
name|rx_head
argument_list|)
expr_stmt|;
while|while
condition|(
name|inw
argument_list|(
name|iobase
operator|+
name|IO_PORT_REG
argument_list|)
operator|==
name|RCV_Done
condition|)
block|{
name|rx_status
operator|=
name|inw
argument_list|(
name|iobase
operator|+
name|IO_PORT_REG
argument_list|)
expr_stmt|;
name|sc
operator|->
name|rx_head
operator|=
name|inw
argument_list|(
name|iobase
operator|+
name|IO_PORT_REG
argument_list|)
expr_stmt|;
name|QQQ
operator|=
name|pkt_len
operator|=
name|inw
argument_list|(
name|iobase
operator|+
name|IO_PORT_REG
argument_list|)
expr_stmt|;
if|if
condition|(
name|rx_status
operator|&
name|RCV_OK_bit
condition|)
block|{
name|MGETHDR
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
name|ipkt
operator|=
name|m
expr_stmt|;
if|if
condition|(
name|ipkt
operator|==
name|NULL
condition|)
block|{
name|ifp
operator|->
name|if_iqdrops
operator|++
expr_stmt|;
block|}
else|else
block|{
name|ipkt
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|ifp
expr_stmt|;
name|ipkt
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|pkt_len
expr_stmt|;
name|ipkt
operator|->
name|m_len
operator|=
name|MHLEN
expr_stmt|;
while|while
condition|(
name|pkt_len
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|pkt_len
operator|>
name|MINCLSIZE
condition|)
block|{
name|MCLGET
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_flags
operator|&
name|M_EXT
condition|)
block|{
name|m
operator|->
name|m_len
operator|=
name|MCLBYTES
expr_stmt|;
block|}
else|else
block|{
name|m_freem
argument_list|(
name|ipkt
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_iqdrops
operator|++
expr_stmt|;
goto|goto
name|rx_another
goto|;
block|}
block|}
name|m
operator|->
name|m_len
operator|=
name|min
argument_list|(
name|m
operator|->
name|m_len
argument_list|,
name|pkt_len
argument_list|)
expr_stmt|;
comment|/* 	   * NOTE: I'm assuming that all mbufs allocated are of even length, 	   * except for the last one in an odd-length packet. 	   */
name|insw
argument_list|(
name|iobase
operator|+
name|IO_PORT_REG
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
name|m
operator|->
name|m_len
operator|/
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_len
operator|&
literal|1
condition|)
block|{
operator|*
operator|(
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
operator|+
name|m
operator|->
name|m_len
operator|-
literal|1
operator|)
operator|=
name|inb
argument_list|(
name|iobase
operator|+
name|IO_PORT_REG
argument_list|)
expr_stmt|;
block|}
name|pkt_len
operator|-=
name|m
operator|->
name|m_len
expr_stmt|;
if|if
condition|(
name|pkt_len
operator|>
literal|0
condition|)
block|{
name|MGET
argument_list|(
name|m
operator|->
name|m_next
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_next
operator|==
name|NULL
condition|)
block|{
name|m_freem
argument_list|(
name|ipkt
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_iqdrops
operator|++
expr_stmt|;
goto|goto
name|rx_another
goto|;
block|}
name|m
operator|=
name|m
operator|->
name|m_next
expr_stmt|;
name|m
operator|->
name|m_len
operator|=
name|MLEN
expr_stmt|;
block|}
block|}
name|eh
operator|=
name|mtod
argument_list|(
name|ipkt
argument_list|,
expr|struct
name|ether_header
operator|*
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|EXDEBUG
if|if
condition|(
name|debug_mask
operator|&
name|Rcvd_Pkts
condition|)
block|{
if|if
condition|(
operator|(
name|eh
operator|->
name|ether_dhost
index|[
literal|5
index|]
operator|!=
literal|0xff
operator|)
operator|||
operator|(
name|eh
operator|->
name|ether_dhost
index|[
literal|0
index|]
operator|!=
literal|0xff
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"Receive packet with %d data bytes: %6D -> "
argument_list|,
name|QQQ
argument_list|,
name|eh
operator|->
name|ether_shost
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%6D\n"
argument_list|,
name|eh
operator|->
name|ether_dhost
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
block|}
comment|/* QQQ */
block|}
endif|#
directive|endif
name|m_adj
argument_list|(
name|ipkt
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
argument_list|)
expr_stmt|;
name|ether_input
argument_list|(
name|ifp
argument_list|,
name|eh
argument_list|,
name|ipkt
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_ipackets
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
block|}
name|outw
argument_list|(
name|iobase
operator|+
name|HOST_ADDR_REG
argument_list|,
name|sc
operator|->
name|rx_head
argument_list|)
expr_stmt|;
name|rx_another
label|:
empty_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|rx_head
operator|<
name|sc
operator|->
name|rx_lower_limit
operator|+
literal|2
condition|)
name|outw
argument_list|(
name|iobase
operator|+
name|RCV_STOP_REG
argument_list|,
name|sc
operator|->
name|rx_upper_limit
argument_list|)
expr_stmt|;
else|else
name|outw
argument_list|(
name|iobase
operator|+
name|RCV_STOP_REG
argument_list|,
name|sc
operator|->
name|rx_head
operator|-
literal|2
argument_list|)
expr_stmt|;
name|DODEBUG
argument_list|(
argument|Start_End
argument_list|,
argument|printf(
literal|"ex_rx_intr%d: finish\n"
argument|, unit);
argument_list|)
empty_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|int
name|ex_ioctl
parameter_list|(
specifier|register
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|data
parameter_list|)
block|{
name|struct
name|ex_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|ifreq
modifier|*
name|ifr
init|=
operator|(
expr|struct
name|ifreq
operator|*
operator|)
name|data
decl_stmt|;
name|int
name|s
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|DODEBUG
argument_list|(
argument|Start_End
argument_list|,
argument|printf(
literal|"ex_ioctl%d: start "
argument|, ifp->if_unit);
argument_list|)
empty_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|SIOCSIFADDR
case|:
case|case
name|SIOCGIFADDR
case|:
case|case
name|SIOCSIFMTU
case|:
name|error
operator|=
name|ether_ioctl
argument_list|(
name|ifp
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCSIFFLAGS
case|:
name|DODEBUG
argument_list|(
argument|Start_End
argument_list|,
argument|printf(
literal|"SIOCSIFFLAGS"
argument|);
argument_list|)
empty_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
operator|)
operator|==
literal|0
operator|&&
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
operator|)
condition|)
block|{
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
name|IFF_RUNNING
expr_stmt|;
name|ex_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ex_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
break|break;
ifdef|#
directive|ifdef
name|NODEF
case|case
name|SIOCGHWADDR
case|:
name|DODEBUG
argument_list|(
argument|Start_End
argument_list|,
argument|printf(
literal|"SIOCGHWADDR"
argument|);
argument_list|)
empty_stmt|;
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|sc
operator|->
name|sc_addr
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|ifr
operator|->
name|ifr_data
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|sc_addr
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|SIOCADDMULTI
case|:
name|DODEBUG
argument_list|(
argument|Start_End
argument_list|,
argument|printf(
literal|"SIOCADDMULTI"
argument|);
argument_list|)
empty_stmt|;
case|case
name|SIOCDELMULTI
case|:
name|DODEBUG
argument_list|(
argument|Start_End
argument_list|,
argument|printf(
literal|"SIOCDELMULTI"
argument|);
argument_list|)
empty_stmt|;
comment|/* XXX Support not done yet. */
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
case|case
name|SIOCSIFMEDIA
case|:
case|case
name|SIOCGIFMEDIA
case|:
name|error
operator|=
name|ifmedia_ioctl
argument_list|(
name|ifp
argument_list|,
name|ifr
argument_list|,
operator|&
name|sc
operator|->
name|ifmedia
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
break|break;
default|default:
name|DODEBUG
argument_list|(
argument|Start_End
argument_list|,
argument|printf(
literal|"unknown"
argument|);
argument_list|)
empty_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|DODEBUG
argument_list|(
argument|Start_End
argument_list|,
argument|printf(
literal|"\nex_ioctl%d: finish\n"
argument|, ifp->if_unit);
argument_list|)
empty_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ex_reset
parameter_list|(
name|struct
name|ex_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|s
decl_stmt|;
name|DODEBUG
argument_list|(
argument|Start_End
argument_list|,
argument|printf(
literal|"ex_reset%d: start\n"
argument|, unit);
argument_list|)
empty_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|ex_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ex_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|DODEBUG
argument_list|(
argument|Start_End
argument_list|,
argument|printf(
literal|"ex_reset%d: finish\n"
argument|, unit);
argument_list|)
empty_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|ex_watchdog
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|ex_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|DODEBUG
argument_list|(
argument|Start_End
argument_list|,
argument|printf(
literal|"ex_watchdog%d: start\n"
argument|, ifp->if_unit);
argument_list|)
empty_stmt|;
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
name|IFF_OACTIVE
expr_stmt|;
name|DODEBUG
argument_list|(
argument|Status
argument_list|,
argument|printf(
literal|"OIDLE watchdog\n"
argument|);
argument_list|)
empty_stmt|;
name|ifp
operator|->
name|if_oerrors
operator|++
expr_stmt|;
name|ex_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ex_start
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|DODEBUG
argument_list|(
argument|Start_End
argument_list|,
argument|printf(
literal|"ex_watchdog%d: finish\n"
argument|, ifp->if_unit);
argument_list|)
empty_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|int
name|ex_get_media
parameter_list|(
name|u_int32_t
name|iobase
parameter_list|)
block|{
name|int
name|tmp
decl_stmt|;
name|outb
argument_list|(
name|iobase
operator|+
name|CMD_REG
argument_list|,
name|Bank2_Sel
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|inb
argument_list|(
name|iobase
operator|+
name|REG3
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|iobase
operator|+
name|CMD_REG
argument_list|,
name|Bank0_Sel
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|&
name|TPE_bit
condition|)
return|return
operator|(
name|IFM_ETHER
operator||
name|IFM_10_T
operator|)
return|;
if|if
condition|(
name|tmp
operator|&
name|BNC_bit
condition|)
return|return
operator|(
name|IFM_ETHER
operator||
name|IFM_10_2
operator|)
return|;
return|return
operator|(
name|IFM_ETHER
operator||
name|IFM_10_5
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ex_ifmedia_upd
parameter_list|(
name|ifp
parameter_list|)
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ex_ifmedia_sts
parameter_list|(
name|ifp
parameter_list|,
name|ifmr
parameter_list|)
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|ifmediareq
modifier|*
name|ifmr
decl_stmt|;
block|{
name|struct
name|ex_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|ifmr
operator|->
name|ifm_active
operator|=
name|ex_get_media
argument_list|(
name|sc
operator|->
name|iobase
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|u_short
name|eeprom_read
parameter_list|(
name|u_int32_t
name|iobase
parameter_list|,
name|int
name|location
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|u_short
name|data
init|=
literal|0
decl_stmt|;
name|int
name|ee_addr
decl_stmt|;
name|int
name|read_cmd
init|=
name|location
operator||
name|EE_READ_CMD
decl_stmt|;
name|short
name|ctrl_val
init|=
name|EECS
decl_stmt|;
name|ee_addr
operator|=
name|iobase
operator|+
name|EEPROM_REG
expr_stmt|;
name|outb
argument_list|(
name|iobase
operator|+
name|CMD_REG
argument_list|,
name|Bank2_Sel
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|ee_addr
argument_list|,
name|EECS
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|8
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|short
name|outval
init|=
operator|(
name|read_cmd
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
operator|)
condition|?
name|ctrl_val
operator||
name|EEDI
else|:
name|ctrl_val
decl_stmt|;
name|outb
argument_list|(
name|ee_addr
argument_list|,
name|outval
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|ee_addr
argument_list|,
name|outval
operator||
name|EESK
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|3
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|ee_addr
argument_list|,
name|outval
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
name|outb
argument_list|(
name|ee_addr
argument_list|,
name|ctrl_val
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|16
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|outb
argument_list|(
name|ee_addr
argument_list|,
name|ctrl_val
operator||
name|EESK
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|3
argument_list|)
expr_stmt|;
name|data
operator|=
operator|(
name|data
operator|<<
literal|1
operator|)
operator||
operator|(
operator|(
name|inb
argument_list|(
name|ee_addr
argument_list|)
operator|&
name|EEDO
operator|)
condition|?
literal|1
else|:
literal|0
operator|)
expr_stmt|;
name|outb
argument_list|(
name|ee_addr
argument_list|,
name|ctrl_val
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
name|ctrl_val
operator|&=
operator|~
name|EECS
expr_stmt|;
name|outb
argument_list|(
name|ee_addr
argument_list|,
name|ctrl_val
operator||
name|EESK
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|3
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|ee_addr
argument_list|,
name|ctrl_val
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|iobase
operator|+
name|CMD_REG
argument_list|,
name|Bank0_Sel
argument_list|)
expr_stmt|;
return|return
operator|(
name|data
operator|)
return|;
block|}
end_function

end_unit

