begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Inline routines shareable across OS platforms.  *  * Copyright (c) 1994-2001 Justin T. Gibbs.  * Copyright (c) 2000-2003 Adaptec Inc.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions, and the following disclaimer,  *    without modification.  * 2. Redistributions in binary form must reproduce at minimum a disclaimer  *    substantially similar to the "NO WARRANTY" disclaimer below  *    ("Disclaimer") and any redistribution must be conditioned upon  *    including a substantially similar Disclaimer requirement for further  *    binary redistribution.  * 3. Neither the names of the above-listed copyright holders nor the names  *    of any contributors may be used to endorse or promote products derived  *    from this software without specific prior written permission.  *  * Alternatively, this software may be distributed under the terms of the  * GNU General Public License ("GPL") version 2 as published by the Free  * Software Foundation.  *  * NO WARRANTY  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT  * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING  * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  * POSSIBILITY OF SUCH DAMAGES.  *  * $Id: //depot/aic7xxx/aic7xxx/aic79xx_inline.h#57 $  *  * $FreeBSD$  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|_AIC79XX_INLINE_H_
end_ifndef

begin_define
define|#
directive|define
name|_AIC79XX_INLINE_H_
end_define

begin_comment
comment|/******************************** Debugging ***********************************/
end_comment

begin_function_decl
specifier|static
name|__inline
name|char
modifier|*
name|ahd_name
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|__inline
name|char
modifier|*
name|ahd_name
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|)
block|{
return|return
operator|(
name|ahd
operator|->
name|name
operator|)
return|;
block|}
end_function

begin_comment
comment|/************************ Sequencer Execution Control *************************/
end_comment

begin_function_decl
specifier|static
name|__inline
name|void
name|ahd_known_modes
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|,
name|ahd_mode
name|src
parameter_list|,
name|ahd_mode
name|dst
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__inline
name|ahd_mode_state
name|ahd_build_mode_state
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|,
name|ahd_mode
name|src
parameter_list|,
name|ahd_mode
name|dst
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__inline
name|void
name|ahd_extract_mode_state
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|,
name|ahd_mode_state
name|state
parameter_list|,
name|ahd_mode
modifier|*
name|src
parameter_list|,
name|ahd_mode
modifier|*
name|dst
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__inline
name|void
name|ahd_set_modes
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|,
name|ahd_mode
name|src
parameter_list|,
name|ahd_mode
name|dst
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__inline
name|void
name|ahd_update_modes
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__inline
name|void
name|ahd_assert_modes
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|,
name|ahd_mode
name|srcmode
parameter_list|,
name|ahd_mode
name|dstmode
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__inline
name|ahd_mode_state
name|ahd_save_modes
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__inline
name|void
name|ahd_restore_modes
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|,
name|ahd_mode_state
name|state
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__inline
name|int
name|ahd_is_paused
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__inline
name|void
name|ahd_pause
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__inline
name|void
name|ahd_unpause
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|__inline
name|void
name|ahd_known_modes
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|,
name|ahd_mode
name|src
parameter_list|,
name|ahd_mode
name|dst
parameter_list|)
block|{
name|ahd
operator|->
name|src_mode
operator|=
name|src
expr_stmt|;
name|ahd
operator|->
name|dst_mode
operator|=
name|dst
expr_stmt|;
name|ahd
operator|->
name|saved_src_mode
operator|=
name|src
expr_stmt|;
name|ahd
operator|->
name|saved_dst_mode
operator|=
name|dst
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|ahd_mode_state
name|ahd_build_mode_state
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|,
name|ahd_mode
name|src
parameter_list|,
name|ahd_mode
name|dst
parameter_list|)
block|{
return|return
operator|(
operator|(
name|src
operator|<<
name|SRC_MODE_SHIFT
operator|)
operator||
operator|(
name|dst
operator|<<
name|DST_MODE_SHIFT
operator|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|ahd_extract_mode_state
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|,
name|ahd_mode_state
name|state
parameter_list|,
name|ahd_mode
modifier|*
name|src
parameter_list|,
name|ahd_mode
modifier|*
name|dst
parameter_list|)
block|{
operator|*
name|src
operator|=
operator|(
name|state
operator|&
name|SRC_MODE
operator|)
operator|>>
name|SRC_MODE_SHIFT
expr_stmt|;
operator|*
name|dst
operator|=
operator|(
name|state
operator|&
name|DST_MODE
operator|)
operator|>>
name|DST_MODE_SHIFT
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|ahd_set_modes
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|,
name|ahd_mode
name|src
parameter_list|,
name|ahd_mode
name|dst
parameter_list|)
block|{
if|if
condition|(
name|ahd
operator|->
name|src_mode
operator|==
name|src
operator|&&
name|ahd
operator|->
name|dst_mode
operator|==
name|dst
condition|)
return|return;
ifdef|#
directive|ifdef
name|AHD_DEBUG
if|if
condition|(
name|ahd
operator|->
name|src_mode
operator|==
name|AHD_MODE_UNKNOWN
operator|||
name|ahd
operator|->
name|dst_mode
operator|==
name|AHD_MODE_UNKNOWN
condition|)
name|panic
argument_list|(
literal|"Setting mode prior to saving it.\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ahd_debug
operator|&
name|AHD_SHOW_MODEPTR
operator|)
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|"%s: Setting mode 0x%x\n"
argument_list|,
name|ahd_name
argument_list|(
name|ahd
argument_list|)
argument_list|,
name|ahd_build_mode_state
argument_list|(
name|ahd
argument_list|,
name|src
argument_list|,
name|dst
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|MODE_PTR
argument_list|,
name|ahd_build_mode_state
argument_list|(
name|ahd
argument_list|,
name|src
argument_list|,
name|dst
argument_list|)
argument_list|)
expr_stmt|;
name|ahd
operator|->
name|src_mode
operator|=
name|src
expr_stmt|;
name|ahd
operator|->
name|dst_mode
operator|=
name|dst
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|ahd_update_modes
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|)
block|{
name|ahd_mode_state
name|mode_ptr
decl_stmt|;
name|ahd_mode
name|src
decl_stmt|;
name|ahd_mode
name|dst
decl_stmt|;
name|mode_ptr
operator|=
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|MODE_PTR
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|AHD_DEBUG
if|if
condition|(
operator|(
name|ahd_debug
operator|&
name|AHD_SHOW_MODEPTR
operator|)
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|"Reading mode 0x%x\n"
argument_list|,
name|mode_ptr
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ahd_extract_mode_state
argument_list|(
name|ahd
argument_list|,
name|mode_ptr
argument_list|,
operator|&
name|src
argument_list|,
operator|&
name|dst
argument_list|)
expr_stmt|;
name|ahd_known_modes
argument_list|(
name|ahd
argument_list|,
name|src
argument_list|,
name|dst
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|ahd_assert_modes
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|,
name|ahd_mode
name|srcmode
parameter_list|,
name|ahd_mode
name|dstmode
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|AHD_DEBUG
if|if
condition|(
operator|(
name|srcmode
operator|&
name|AHD_MK_MSK
argument_list|(
name|ahd
operator|->
name|src_mode
argument_list|)
operator|)
operator|==
literal|0
operator|||
operator|(
name|dstmode
operator|&
name|AHD_MK_MSK
argument_list|(
name|ahd
operator|->
name|dst_mode
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|panic
argument_list|(
literal|"%s:%s:%d: Mode assertion failed.\n"
argument_list|,
name|ahd_name
argument_list|(
name|ahd
argument_list|)
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|__inline
name|ahd_mode_state
name|ahd_save_modes
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|)
block|{
if|if
condition|(
name|ahd
operator|->
name|src_mode
operator|==
name|AHD_MODE_UNKNOWN
operator|||
name|ahd
operator|->
name|dst_mode
operator|==
name|AHD_MODE_UNKNOWN
condition|)
name|ahd_update_modes
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
return|return
operator|(
name|ahd_build_mode_state
argument_list|(
name|ahd
argument_list|,
name|ahd
operator|->
name|src_mode
argument_list|,
name|ahd
operator|->
name|dst_mode
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|ahd_restore_modes
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|,
name|ahd_mode_state
name|state
parameter_list|)
block|{
name|ahd_mode
name|src
decl_stmt|;
name|ahd_mode
name|dst
decl_stmt|;
name|ahd_extract_mode_state
argument_list|(
name|ahd
argument_list|,
name|state
argument_list|,
operator|&
name|src
argument_list|,
operator|&
name|dst
argument_list|)
expr_stmt|;
name|ahd_set_modes
argument_list|(
name|ahd
argument_list|,
name|src
argument_list|,
name|dst
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|AHD_ASSERT_MODES
parameter_list|(
name|ahd
parameter_list|,
name|source
parameter_list|,
name|dest
parameter_list|)
define|\
value|ahd_assert_modes(ahd, source, dest, __FILE__, __LINE__);
end_define

begin_comment
comment|/*  * Determine whether the sequencer has halted code execution.  * Returns non-zero status if the sequencer is stopped.  */
end_comment

begin_function
specifier|static
name|__inline
name|int
name|ahd_is_paused
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|)
block|{
return|return
operator|(
operator|(
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|HCNTRL
argument_list|)
operator|&
name|PAUSE
operator|)
operator|!=
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Request that the sequencer stop and wait, indefinitely, for it  * to stop.  The sequencer will only acknowledge that it is paused  * once it has reached an instruction boundary and PAUSEDIS is  * cleared in the SEQCTL register.  The sequencer may use PAUSEDIS  * for critical sections.  */
end_comment

begin_function
specifier|static
name|__inline
name|void
name|ahd_pause
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|)
block|{
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|HCNTRL
argument_list|,
name|ahd
operator|->
name|pause
argument_list|)
expr_stmt|;
comment|/* 	 * Since the sequencer can disable pausing in a critical section, we 	 * must loop until it actually stops. 	 */
while|while
condition|(
name|ahd_is_paused
argument_list|(
name|ahd
argument_list|)
operator|==
literal|0
condition|)
empty_stmt|;
block|}
end_function

begin_comment
comment|/*  * Allow the sequencer to continue program execution.  * We check here to ensure that no additional interrupt  * sources that would cause the sequencer to halt have been  * asserted.  If, for example, a SCSI bus reset is detected  * while we are fielding a different, pausing, interrupt type,  * we don't want to release the sequencer before going back  * into our interrupt handler and dealing with this new  * condition.  */
end_comment

begin_function
specifier|static
name|__inline
name|void
name|ahd_unpause
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|)
block|{
comment|/* 	 * Automatically restore our modes to those saved 	 * prior to the first change of the mode. 	 */
if|if
condition|(
name|ahd
operator|->
name|saved_src_mode
operator|!=
name|AHD_MODE_UNKNOWN
operator|&&
name|ahd
operator|->
name|saved_dst_mode
operator|!=
name|AHD_MODE_UNKNOWN
condition|)
block|{
if|if
condition|(
operator|(
name|ahd
operator|->
name|flags
operator|&
name|AHD_UPDATE_PEND_CMDS
operator|)
operator|!=
literal|0
condition|)
name|ahd_reset_cmds_pending
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
name|ahd_set_modes
argument_list|(
name|ahd
argument_list|,
name|ahd
operator|->
name|saved_src_mode
argument_list|,
name|ahd
operator|->
name|saved_dst_mode
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|INTSTAT
argument_list|)
operator|&
operator|~
name|CMDCMPLT
operator|)
operator|==
literal|0
condition|)
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|HCNTRL
argument_list|,
name|ahd
operator|->
name|unpause
argument_list|)
expr_stmt|;
name|ahd_known_modes
argument_list|(
name|ahd
argument_list|,
name|AHD_MODE_UNKNOWN
argument_list|,
name|AHD_MODE_UNKNOWN
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*********************** Scatter Gather List Handling *************************/
end_comment

begin_function_decl
specifier|static
name|__inline
name|void
modifier|*
name|ahd_sg_setup
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|,
name|struct
name|scb
modifier|*
name|scb
parameter_list|,
name|void
modifier|*
name|sgptr
parameter_list|,
name|bus_addr_t
name|addr
parameter_list|,
name|bus_size_t
name|len
parameter_list|,
name|int
name|last
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__inline
name|void
name|ahd_setup_scb_common
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|,
name|struct
name|scb
modifier|*
name|scb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__inline
name|void
name|ahd_setup_data_scb
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|,
name|struct
name|scb
modifier|*
name|scb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__inline
name|void
name|ahd_setup_noxfer_scb
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|,
name|struct
name|scb
modifier|*
name|scb
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|__inline
name|void
modifier|*
name|ahd_sg_setup
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|,
name|struct
name|scb
modifier|*
name|scb
parameter_list|,
name|void
modifier|*
name|sgptr
parameter_list|,
name|bus_addr_t
name|addr
parameter_list|,
name|bus_size_t
name|len
parameter_list|,
name|int
name|last
parameter_list|)
block|{
name|scb
operator|->
name|sg_count
operator|++
expr_stmt|;
if|if
condition|(
sizeof|sizeof
argument_list|(
name|bus_addr_t
argument_list|)
operator|>
literal|4
operator|&&
operator|(
name|ahd
operator|->
name|flags
operator|&
name|AHD_64BIT_ADDRESSING
operator|)
operator|!=
literal|0
condition|)
block|{
name|struct
name|ahd_dma64_seg
modifier|*
name|sg
decl_stmt|;
name|sg
operator|=
operator|(
expr|struct
name|ahd_dma64_seg
operator|*
operator|)
name|sgptr
expr_stmt|;
name|sg
operator|->
name|addr
operator|=
name|aic_htole64
argument_list|(
name|addr
argument_list|)
expr_stmt|;
name|sg
operator|->
name|len
operator|=
name|aic_htole32
argument_list|(
name|len
operator||
operator|(
name|last
condition|?
name|AHD_DMA_LAST_SEG
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|sg
operator|+
literal|1
operator|)
return|;
block|}
else|else
block|{
name|struct
name|ahd_dma_seg
modifier|*
name|sg
decl_stmt|;
name|sg
operator|=
operator|(
expr|struct
name|ahd_dma_seg
operator|*
operator|)
name|sgptr
expr_stmt|;
name|sg
operator|->
name|addr
operator|=
name|aic_htole32
argument_list|(
name|addr
operator|&
literal|0xFFFFFFFF
argument_list|)
expr_stmt|;
name|sg
operator|->
name|len
operator|=
name|aic_htole32
argument_list|(
name|len
operator||
operator|(
operator|(
name|addr
operator|>>
literal|8
operator|)
operator|&
literal|0x7F000000
operator|)
operator||
operator|(
name|last
condition|?
name|AHD_DMA_LAST_SEG
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|sg
operator|+
literal|1
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|ahd_setup_scb_common
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|,
name|struct
name|scb
modifier|*
name|scb
parameter_list|)
block|{
comment|/* XXX Handle target mode SCBs. */
name|scb
operator|->
name|crc_retry_count
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|scb
operator|->
name|flags
operator|&
name|SCB_PACKETIZED
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* XXX what about ACA??  It is type 4, but TAG_TYPE == 0x3. */
name|scb
operator|->
name|hscb
operator|->
name|task_attribute
operator|=
name|scb
operator|->
name|hscb
operator|->
name|control
operator|&
name|SCB_TAG_TYPE
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|aic_get_transfer_length
argument_list|(
name|scb
argument_list|)
operator|&
literal|0x01
condition|)
name|scb
operator|->
name|hscb
operator|->
name|task_attribute
operator|=
name|SCB_XFERLEN_ODD
expr_stmt|;
else|else
name|scb
operator|->
name|hscb
operator|->
name|task_attribute
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|scb
operator|->
name|hscb
operator|->
name|cdb_len
operator|<=
name|MAX_CDB_LEN_WITH_SENSE_ADDR
operator|||
operator|(
name|scb
operator|->
name|hscb
operator|->
name|cdb_len
operator|&
name|SCB_CDB_LEN_PTR
operator|)
operator|!=
literal|0
condition|)
name|scb
operator|->
name|hscb
operator|->
name|shared_data
operator|.
name|idata
operator|.
name|cdb_plus_saddr
operator|.
name|sense_addr
operator|=
name|aic_htole32
argument_list|(
name|scb
operator|->
name|sense_busaddr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|ahd_setup_data_scb
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|,
name|struct
name|scb
modifier|*
name|scb
parameter_list|)
block|{
comment|/* 	 * Copy the first SG into the "current" data ponter area. 	 */
if|if
condition|(
operator|(
name|ahd
operator|->
name|flags
operator|&
name|AHD_64BIT_ADDRESSING
operator|)
operator|!=
literal|0
condition|)
block|{
name|struct
name|ahd_dma64_seg
modifier|*
name|sg
decl_stmt|;
name|sg
operator|=
operator|(
expr|struct
name|ahd_dma64_seg
operator|*
operator|)
name|scb
operator|->
name|sg_list
expr_stmt|;
name|scb
operator|->
name|hscb
operator|->
name|dataptr
operator|=
name|sg
operator|->
name|addr
expr_stmt|;
name|scb
operator|->
name|hscb
operator|->
name|datacnt
operator|=
name|sg
operator|->
name|len
expr_stmt|;
block|}
else|else
block|{
name|struct
name|ahd_dma_seg
modifier|*
name|sg
decl_stmt|;
name|uint32_t
modifier|*
name|dataptr_words
decl_stmt|;
name|sg
operator|=
operator|(
expr|struct
name|ahd_dma_seg
operator|*
operator|)
name|scb
operator|->
name|sg_list
expr_stmt|;
name|dataptr_words
operator|=
operator|(
name|uint32_t
operator|*
operator|)
operator|&
name|scb
operator|->
name|hscb
operator|->
name|dataptr
expr_stmt|;
name|dataptr_words
index|[
literal|0
index|]
operator|=
name|sg
operator|->
name|addr
expr_stmt|;
name|dataptr_words
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|ahd
operator|->
name|flags
operator|&
name|AHD_39BIT_ADDRESSING
operator|)
operator|!=
literal|0
condition|)
block|{
name|uint64_t
name|high_addr
decl_stmt|;
name|high_addr
operator|=
name|aic_le32toh
argument_list|(
name|sg
operator|->
name|len
argument_list|)
operator|&
literal|0x7F000000
expr_stmt|;
name|scb
operator|->
name|hscb
operator|->
name|dataptr
operator||=
name|aic_htole64
argument_list|(
name|high_addr
operator|<<
literal|8
argument_list|)
expr_stmt|;
block|}
name|scb
operator|->
name|hscb
operator|->
name|datacnt
operator|=
name|sg
operator|->
name|len
expr_stmt|;
block|}
comment|/* 	 * Note where to find the SG entries in bus space. 	 * We also set the full residual flag which the  	 * sequencer will clear as soon as a data transfer 	 * occurs. 	 */
name|scb
operator|->
name|hscb
operator|->
name|sgptr
operator|=
name|aic_htole32
argument_list|(
name|scb
operator|->
name|sg_list_busaddr
operator||
name|SG_FULL_RESID
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|ahd_setup_noxfer_scb
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|,
name|struct
name|scb
modifier|*
name|scb
parameter_list|)
block|{
name|scb
operator|->
name|hscb
operator|->
name|sgptr
operator|=
name|aic_htole32
argument_list|(
name|SG_LIST_NULL
argument_list|)
expr_stmt|;
name|scb
operator|->
name|hscb
operator|->
name|dataptr
operator|=
literal|0
expr_stmt|;
name|scb
operator|->
name|hscb
operator|->
name|datacnt
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/************************** Memory mapping routines ***************************/
end_comment

begin_function_decl
specifier|static
name|__inline
name|size_t
name|ahd_sg_size
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__inline
name|void
modifier|*
name|ahd_sg_bus_to_virt
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|,
name|struct
name|scb
modifier|*
name|scb
parameter_list|,
name|uint32_t
name|sg_busaddr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__inline
name|uint32_t
name|ahd_sg_virt_to_bus
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|,
name|struct
name|scb
modifier|*
name|scb
parameter_list|,
name|void
modifier|*
name|sg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__inline
name|void
name|ahd_sync_scb
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|,
name|struct
name|scb
modifier|*
name|scb
parameter_list|,
name|int
name|op
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__inline
name|void
name|ahd_sync_sglist
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|,
name|struct
name|scb
modifier|*
name|scb
parameter_list|,
name|int
name|op
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__inline
name|void
name|ahd_sync_sense
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|,
name|struct
name|scb
modifier|*
name|scb
parameter_list|,
name|int
name|op
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__inline
name|uint32_t
name|ahd_targetcmd_offset
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|,
name|u_int
name|index
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|__inline
name|size_t
name|ahd_sg_size
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|)
block|{
if|if
condition|(
operator|(
name|ahd
operator|->
name|flags
operator|&
name|AHD_64BIT_ADDRESSING
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|ahd_dma64_seg
argument_list|)
operator|)
return|;
return|return
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|ahd_dma_seg
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
modifier|*
name|ahd_sg_bus_to_virt
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|,
name|struct
name|scb
modifier|*
name|scb
parameter_list|,
name|uint32_t
name|sg_busaddr
parameter_list|)
block|{
name|bus_addr_t
name|sg_offset
decl_stmt|;
comment|/* sg_list_phys points to entry 1, not 0 */
name|sg_offset
operator|=
name|sg_busaddr
operator|-
operator|(
name|scb
operator|->
name|sg_list_busaddr
operator|-
name|ahd_sg_size
argument_list|(
name|ahd
argument_list|)
operator|)
expr_stmt|;
return|return
operator|(
operator|(
name|uint8_t
operator|*
operator|)
name|scb
operator|->
name|sg_list
operator|+
name|sg_offset
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|uint32_t
name|ahd_sg_virt_to_bus
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|,
name|struct
name|scb
modifier|*
name|scb
parameter_list|,
name|void
modifier|*
name|sg
parameter_list|)
block|{
name|bus_addr_t
name|sg_offset
decl_stmt|;
comment|/* sg_list_phys points to entry 1, not 0 */
name|sg_offset
operator|=
operator|(
operator|(
name|uint8_t
operator|*
operator|)
name|sg
operator|-
operator|(
name|uint8_t
operator|*
operator|)
name|scb
operator|->
name|sg_list
operator|)
operator|-
name|ahd_sg_size
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
return|return
operator|(
name|scb
operator|->
name|sg_list_busaddr
operator|+
name|sg_offset
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|ahd_sync_scb
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|,
name|struct
name|scb
modifier|*
name|scb
parameter_list|,
name|int
name|op
parameter_list|)
block|{
name|aic_dmamap_sync
argument_list|(
name|ahd
argument_list|,
name|ahd
operator|->
name|scb_data
operator|.
name|hscb_dmat
argument_list|,
name|scb
operator|->
name|hscb_map
operator|->
name|dmamap
argument_list|,
comment|/*offset*/
operator|(
name|uint8_t
operator|*
operator|)
name|scb
operator|->
name|hscb
operator|-
name|scb
operator|->
name|hscb_map
operator|->
name|vaddr
argument_list|,
comment|/*len*/
sizeof|sizeof
argument_list|(
operator|*
name|scb
operator|->
name|hscb
argument_list|)
argument_list|,
name|op
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|ahd_sync_sglist
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|,
name|struct
name|scb
modifier|*
name|scb
parameter_list|,
name|int
name|op
parameter_list|)
block|{
if|if
condition|(
name|scb
operator|->
name|sg_count
operator|==
literal|0
condition|)
return|return;
name|aic_dmamap_sync
argument_list|(
name|ahd
argument_list|,
name|ahd
operator|->
name|scb_data
operator|.
name|sg_dmat
argument_list|,
name|scb
operator|->
name|sg_map
operator|->
name|dmamap
argument_list|,
comment|/*offset*/
name|scb
operator|->
name|sg_list_busaddr
operator|-
name|ahd_sg_size
argument_list|(
name|ahd
argument_list|)
argument_list|,
comment|/*len*/
name|ahd_sg_size
argument_list|(
name|ahd
argument_list|)
operator|*
name|scb
operator|->
name|sg_count
argument_list|,
name|op
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|ahd_sync_sense
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|,
name|struct
name|scb
modifier|*
name|scb
parameter_list|,
name|int
name|op
parameter_list|)
block|{
name|aic_dmamap_sync
argument_list|(
name|ahd
argument_list|,
name|ahd
operator|->
name|scb_data
operator|.
name|sense_dmat
argument_list|,
name|scb
operator|->
name|sense_map
operator|->
name|dmamap
argument_list|,
comment|/*offset*/
name|scb
operator|->
name|sense_busaddr
argument_list|,
comment|/*len*/
name|AHD_SENSE_BUFSIZE
argument_list|,
name|op
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|uint32_t
name|ahd_targetcmd_offset
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|,
name|u_int
name|index
parameter_list|)
block|{
return|return
operator|(
operator|(
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|ahd
operator|->
name|targetcmds
index|[
name|index
index|]
operator|)
operator|-
operator|(
name|uint8_t
operator|*
operator|)
name|ahd
operator|->
name|qoutfifo
operator|)
return|;
block|}
end_function

begin_comment
comment|/********************** Miscellaneous Support Functions ***********************/
end_comment

begin_function_decl
specifier|static
name|__inline
name|void
name|ahd_complete_scb
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|,
name|struct
name|scb
modifier|*
name|scb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__inline
name|void
name|ahd_update_residual
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|,
name|struct
name|scb
modifier|*
name|scb
parameter_list|)
function_decl|;
end_function_decl

begin_expr_stmt
specifier|static
name|__inline
expr|struct
name|ahd_initiator_tinfo
operator|*
name|ahd_fetch_transinfo
argument_list|(
argument|struct ahd_softc *ahd
argument_list|,
argument|char channel
argument_list|,
argument|u_int our_id
argument_list|,
argument|u_int remote_id
argument_list|,
argument|struct ahd_tmode_tstate **tstate
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function_decl
specifier|static
name|__inline
name|uint16_t
name|ahd_inw
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|,
name|u_int
name|port
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__inline
name|void
name|ahd_outw
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|,
name|u_int
name|port
parameter_list|,
name|u_int
name|value
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__inline
name|uint32_t
name|ahd_inl
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|,
name|u_int
name|port
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__inline
name|void
name|ahd_outl
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|,
name|u_int
name|port
parameter_list|,
name|uint32_t
name|value
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__inline
name|uint64_t
name|ahd_inq
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|,
name|u_int
name|port
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__inline
name|void
name|ahd_outq
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|,
name|u_int
name|port
parameter_list|,
name|uint64_t
name|value
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__inline
name|u_int
name|ahd_get_scbptr
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__inline
name|void
name|ahd_set_scbptr
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|,
name|u_int
name|scbptr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__inline
name|u_int
name|ahd_get_hnscb_qoff
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__inline
name|void
name|ahd_set_hnscb_qoff
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|,
name|u_int
name|value
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__inline
name|u_int
name|ahd_get_hescb_qoff
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__inline
name|void
name|ahd_set_hescb_qoff
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|,
name|u_int
name|value
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__inline
name|u_int
name|ahd_get_snscb_qoff
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__inline
name|void
name|ahd_set_snscb_qoff
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|,
name|u_int
name|value
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__inline
name|u_int
name|ahd_get_sescb_qoff
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__inline
name|void
name|ahd_set_sescb_qoff
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|,
name|u_int
name|value
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__inline
name|u_int
name|ahd_get_sdscb_qoff
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__inline
name|void
name|ahd_set_sdscb_qoff
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|,
name|u_int
name|value
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__inline
name|u_int
name|ahd_inb_scbram
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|,
name|u_int
name|offset
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__inline
name|u_int
name|ahd_inw_scbram
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|,
name|u_int
name|offset
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__inline
name|uint32_t
name|ahd_inl_scbram
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|,
name|u_int
name|offset
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__inline
name|uint64_t
name|ahd_inq_scbram
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|,
name|u_int
name|offset
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__inline
name|void
name|ahd_swap_with_next_hscb
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|,
name|struct
name|scb
modifier|*
name|scb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__inline
name|void
name|ahd_queue_scb
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|,
name|struct
name|scb
modifier|*
name|scb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__inline
name|uint8_t
modifier|*
name|ahd_get_sense_buf
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|,
name|struct
name|scb
modifier|*
name|scb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__inline
name|uint32_t
name|ahd_get_sense_bufaddr
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|,
name|struct
name|scb
modifier|*
name|scb
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|__inline
name|void
name|ahd_complete_scb
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|,
name|struct
name|scb
modifier|*
name|scb
parameter_list|)
block|{
name|uint32_t
name|sgptr
decl_stmt|;
name|sgptr
operator|=
name|aic_le32toh
argument_list|(
name|scb
operator|->
name|hscb
operator|->
name|sgptr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sgptr
operator|&
name|SG_STATUS_VALID
operator|)
operator|!=
literal|0
condition|)
name|ahd_handle_scb_status
argument_list|(
name|ahd
argument_list|,
name|scb
argument_list|)
expr_stmt|;
else|else
name|ahd_done
argument_list|(
name|ahd
argument_list|,
name|scb
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Determine whether the sequencer reported a residual  * for this SCB/transaction.  */
end_comment

begin_function
specifier|static
name|__inline
name|void
name|ahd_update_residual
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|,
name|struct
name|scb
modifier|*
name|scb
parameter_list|)
block|{
name|uint32_t
name|sgptr
decl_stmt|;
name|sgptr
operator|=
name|aic_le32toh
argument_list|(
name|scb
operator|->
name|hscb
operator|->
name|sgptr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sgptr
operator|&
name|SG_STATUS_VALID
operator|)
operator|!=
literal|0
condition|)
name|ahd_calc_residual
argument_list|(
name|ahd
argument_list|,
name|scb
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Return pointers to the transfer negotiation information  * for the specified our_id/remote_id pair.  */
end_comment

begin_expr_stmt
specifier|static
name|__inline
expr|struct
name|ahd_initiator_tinfo
operator|*
name|ahd_fetch_transinfo
argument_list|(
argument|struct ahd_softc *ahd
argument_list|,
argument|char channel
argument_list|,
argument|u_int our_id
argument_list|,
argument|u_int remote_id
argument_list|,
argument|struct ahd_tmode_tstate **tstate
argument_list|)
block|{
comment|/* 	 * Transfer data structures are stored from the perspective 	 * of the target role.  Since the parameters for a connection 	 * in the initiator role to a given target are the same as 	 * when the roles are reversed, we pretend we are the target. 	 */
if|if
condition|(
name|channel
operator|==
literal|'B'
condition|)
name|our_id
operator|+=
literal|8
expr_stmt|;
operator|*
name|tstate
operator|=
name|ahd
operator|->
name|enabled_targets
index|[
name|our_id
index|]
expr_stmt|;
end_expr_stmt

begin_return
return|return
operator|(
operator|&
operator|(
operator|*
name|tstate
operator|)
operator|->
name|transinfo
index|[
name|remote_id
index|]
operator|)
return|;
end_return

begin_define
unit|}
define|#
directive|define
name|AHD_COPY_COL_IDX
parameter_list|(
name|dst
parameter_list|,
name|src
parameter_list|)
define|\
value|do {								\ 	dst->hscb->scsiid = src->hscb->scsiid;			\ 	dst->hscb->lun = src->hscb->lun;			\ } while (0)
end_define

begin_function
unit|static
name|__inline
name|uint16_t
name|ahd_inw
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|,
name|u_int
name|port
parameter_list|)
block|{
comment|/* 	 * Read high byte first as some registers increment 	 * or have other side effects when the low byte is 	 * read. 	 */
return|return
operator|(
operator|(
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|port
operator|+
literal|1
argument_list|)
operator|<<
literal|8
operator|)
operator||
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|port
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|ahd_outw
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|,
name|u_int
name|port
parameter_list|,
name|u_int
name|value
parameter_list|)
block|{
comment|/* 	 * Write low byte first to accommodate registers 	 * such as PRGMCNT where the order maters. 	 */
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|port
argument_list|,
name|value
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|port
operator|+
literal|1
argument_list|,
operator|(
name|value
operator|>>
literal|8
operator|)
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|uint32_t
name|ahd_inl
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|,
name|u_int
name|port
parameter_list|)
block|{
return|return
operator|(
operator|(
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|port
argument_list|)
operator|)
operator||
operator|(
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|port
operator|+
literal|1
argument_list|)
operator|<<
literal|8
operator|)
operator||
operator|(
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|port
operator|+
literal|2
argument_list|)
operator|<<
literal|16
operator|)
operator||
operator|(
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|port
operator|+
literal|3
argument_list|)
operator|<<
literal|24
operator|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|ahd_outl
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|,
name|u_int
name|port
parameter_list|,
name|uint32_t
name|value
parameter_list|)
block|{
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|port
argument_list|,
operator|(
name|value
operator|)
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|port
operator|+
literal|1
argument_list|,
operator|(
operator|(
name|value
operator|)
operator|>>
literal|8
operator|)
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|port
operator|+
literal|2
argument_list|,
operator|(
operator|(
name|value
operator|)
operator|>>
literal|16
operator|)
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|port
operator|+
literal|3
argument_list|,
operator|(
operator|(
name|value
operator|)
operator|>>
literal|24
operator|)
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|uint64_t
name|ahd_inq
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|,
name|u_int
name|port
parameter_list|)
block|{
return|return
operator|(
operator|(
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|port
argument_list|)
operator|)
operator||
operator|(
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|port
operator|+
literal|1
argument_list|)
operator|<<
literal|8
operator|)
operator||
operator|(
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|port
operator|+
literal|2
argument_list|)
operator|<<
literal|16
operator|)
operator||
operator|(
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|port
operator|+
literal|3
argument_list|)
operator|<<
literal|24
operator|)
operator||
operator|(
operator|(
operator|(
name|uint64_t
operator|)
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|port
operator|+
literal|4
argument_list|)
operator|)
operator|<<
literal|32
operator|)
operator||
operator|(
operator|(
operator|(
name|uint64_t
operator|)
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|port
operator|+
literal|5
argument_list|)
operator|)
operator|<<
literal|40
operator|)
operator||
operator|(
operator|(
operator|(
name|uint64_t
operator|)
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|port
operator|+
literal|6
argument_list|)
operator|)
operator|<<
literal|48
operator|)
operator||
operator|(
operator|(
operator|(
name|uint64_t
operator|)
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|port
operator|+
literal|7
argument_list|)
operator|)
operator|<<
literal|56
operator|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|ahd_outq
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|,
name|u_int
name|port
parameter_list|,
name|uint64_t
name|value
parameter_list|)
block|{
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|port
argument_list|,
name|value
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|port
operator|+
literal|1
argument_list|,
operator|(
name|value
operator|>>
literal|8
operator|)
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|port
operator|+
literal|2
argument_list|,
operator|(
name|value
operator|>>
literal|16
operator|)
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|port
operator|+
literal|3
argument_list|,
operator|(
name|value
operator|>>
literal|24
operator|)
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|port
operator|+
literal|4
argument_list|,
operator|(
name|value
operator|>>
literal|32
operator|)
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|port
operator|+
literal|5
argument_list|,
operator|(
name|value
operator|>>
literal|40
operator|)
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|port
operator|+
literal|6
argument_list|,
operator|(
name|value
operator|>>
literal|48
operator|)
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|port
operator|+
literal|7
argument_list|,
operator|(
name|value
operator|>>
literal|56
operator|)
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|u_int
name|ahd_get_scbptr
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|)
block|{
name|AHD_ASSERT_MODES
argument_list|(
name|ahd
argument_list|,
operator|~
operator|(
name|AHD_MODE_UNKNOWN_MSK
operator||
name|AHD_MODE_CFG_MSK
operator|)
argument_list|,
operator|~
operator|(
name|AHD_MODE_UNKNOWN_MSK
operator||
name|AHD_MODE_CFG_MSK
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|SCBPTR
argument_list|)
operator||
operator|(
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|SCBPTR
operator|+
literal|1
argument_list|)
operator|<<
literal|8
operator|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|ahd_set_scbptr
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|,
name|u_int
name|scbptr
parameter_list|)
block|{
name|AHD_ASSERT_MODES
argument_list|(
name|ahd
argument_list|,
operator|~
operator|(
name|AHD_MODE_UNKNOWN_MSK
operator||
name|AHD_MODE_CFG_MSK
operator|)
argument_list|,
operator|~
operator|(
name|AHD_MODE_UNKNOWN_MSK
operator||
name|AHD_MODE_CFG_MSK
operator|)
argument_list|)
expr_stmt|;
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|SCBPTR
argument_list|,
name|scbptr
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|SCBPTR
operator|+
literal|1
argument_list|,
operator|(
name|scbptr
operator|>>
literal|8
operator|)
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|u_int
name|ahd_get_hnscb_qoff
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|)
block|{
return|return
operator|(
name|ahd_inw_atomic
argument_list|(
name|ahd
argument_list|,
name|HNSCB_QOFF
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|ahd_set_hnscb_qoff
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|,
name|u_int
name|value
parameter_list|)
block|{
name|ahd_outw_atomic
argument_list|(
name|ahd
argument_list|,
name|HNSCB_QOFF
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|u_int
name|ahd_get_hescb_qoff
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|)
block|{
return|return
operator|(
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|HESCB_QOFF
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|ahd_set_hescb_qoff
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|,
name|u_int
name|value
parameter_list|)
block|{
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|HESCB_QOFF
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|u_int
name|ahd_get_snscb_qoff
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|)
block|{
name|u_int
name|oldvalue
decl_stmt|;
name|AHD_ASSERT_MODES
argument_list|(
name|ahd
argument_list|,
name|AHD_MODE_CCHAN_MSK
argument_list|,
name|AHD_MODE_CCHAN_MSK
argument_list|)
expr_stmt|;
name|oldvalue
operator|=
name|ahd_inw
argument_list|(
name|ahd
argument_list|,
name|SNSCB_QOFF
argument_list|)
expr_stmt|;
name|ahd_outw
argument_list|(
name|ahd
argument_list|,
name|SNSCB_QOFF
argument_list|,
name|oldvalue
argument_list|)
expr_stmt|;
return|return
operator|(
name|oldvalue
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|ahd_set_snscb_qoff
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|,
name|u_int
name|value
parameter_list|)
block|{
name|AHD_ASSERT_MODES
argument_list|(
name|ahd
argument_list|,
name|AHD_MODE_CCHAN_MSK
argument_list|,
name|AHD_MODE_CCHAN_MSK
argument_list|)
expr_stmt|;
name|ahd_outw
argument_list|(
name|ahd
argument_list|,
name|SNSCB_QOFF
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|u_int
name|ahd_get_sescb_qoff
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|)
block|{
name|AHD_ASSERT_MODES
argument_list|(
name|ahd
argument_list|,
name|AHD_MODE_CCHAN_MSK
argument_list|,
name|AHD_MODE_CCHAN_MSK
argument_list|)
expr_stmt|;
return|return
operator|(
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|SESCB_QOFF
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|ahd_set_sescb_qoff
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|,
name|u_int
name|value
parameter_list|)
block|{
name|AHD_ASSERT_MODES
argument_list|(
name|ahd
argument_list|,
name|AHD_MODE_CCHAN_MSK
argument_list|,
name|AHD_MODE_CCHAN_MSK
argument_list|)
expr_stmt|;
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|SESCB_QOFF
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|u_int
name|ahd_get_sdscb_qoff
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|)
block|{
name|AHD_ASSERT_MODES
argument_list|(
name|ahd
argument_list|,
name|AHD_MODE_CCHAN_MSK
argument_list|,
name|AHD_MODE_CCHAN_MSK
argument_list|)
expr_stmt|;
return|return
operator|(
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|SDSCB_QOFF
argument_list|)
operator||
operator|(
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|SDSCB_QOFF
operator|+
literal|1
argument_list|)
operator|<<
literal|8
operator|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|ahd_set_sdscb_qoff
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|,
name|u_int
name|value
parameter_list|)
block|{
name|AHD_ASSERT_MODES
argument_list|(
name|ahd
argument_list|,
name|AHD_MODE_CCHAN_MSK
argument_list|,
name|AHD_MODE_CCHAN_MSK
argument_list|)
expr_stmt|;
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|SDSCB_QOFF
argument_list|,
name|value
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|SDSCB_QOFF
operator|+
literal|1
argument_list|,
operator|(
name|value
operator|>>
literal|8
operator|)
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|u_int
name|ahd_inb_scbram
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|,
name|u_int
name|offset
parameter_list|)
block|{
name|u_int
name|value
decl_stmt|;
comment|/* 	 * Workaround PCI-X Rev A. hardware bug. 	 * After a host read of SCB memory, the chip 	 * may become confused into thinking prefetch 	 * was required.  This starts the discard timer 	 * running and can cause an unexpected discard 	 * timer interrupt.  The work around is to read 	 * a normal register prior to the exhaustion of 	 * the discard timer.  The mode pointer register 	 * has no side effects and so serves well for 	 * this purpose. 	 * 	 * Razor #528 	 */
name|value
operator|=
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ahd
operator|->
name|bugs
operator|&
name|AHD_PCIX_SCBRAM_RD_BUG
operator|)
operator|!=
literal|0
condition|)
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|MODE_PTR
argument_list|)
expr_stmt|;
return|return
operator|(
name|value
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|u_int
name|ahd_inw_scbram
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|,
name|u_int
name|offset
parameter_list|)
block|{
return|return
operator|(
name|ahd_inb_scbram
argument_list|(
name|ahd
argument_list|,
name|offset
argument_list|)
operator||
operator|(
name|ahd_inb_scbram
argument_list|(
name|ahd
argument_list|,
name|offset
operator|+
literal|1
argument_list|)
operator|<<
literal|8
operator|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|uint32_t
name|ahd_inl_scbram
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|,
name|u_int
name|offset
parameter_list|)
block|{
return|return
operator|(
name|ahd_inw_scbram
argument_list|(
name|ahd
argument_list|,
name|offset
argument_list|)
operator||
operator|(
name|ahd_inw_scbram
argument_list|(
name|ahd
argument_list|,
name|offset
operator|+
literal|2
argument_list|)
operator|<<
literal|16
operator|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|uint64_t
name|ahd_inq_scbram
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|,
name|u_int
name|offset
parameter_list|)
block|{
return|return
operator|(
name|ahd_inl_scbram
argument_list|(
name|ahd
argument_list|,
name|offset
argument_list|)
operator||
operator|(
operator|(
name|uint64_t
operator|)
name|ahd_inl_scbram
argument_list|(
name|ahd
argument_list|,
name|offset
operator|+
literal|4
argument_list|)
operator|)
operator|<<
literal|32
operator|)
return|;
block|}
end_function

begin_expr_stmt
specifier|static
name|__inline
expr|struct
name|scb
operator|*
name|ahd_lookup_scb
argument_list|(
argument|struct ahd_softc *ahd
argument_list|,
argument|u_int tag
argument_list|)
block|{ 	struct
name|scb
operator|*
name|scb
block|;
if|if
condition|(
name|tag
operator|>=
name|AHD_SCB_MAX
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|scb
operator|=
name|ahd
operator|->
name|scb_data
operator|.
name|scbindex
index|[
name|tag
index|]
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|scb
operator|!=
name|NULL
condition|)
name|ahd_sync_scb
argument_list|(
name|ahd
argument_list|,
name|scb
argument_list|,
name|BUS_DMASYNC_POSTREAD
operator||
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
end_if

begin_return
return|return
operator|(
name|scb
operator|)
return|;
end_return

begin_function
unit|}  static
name|__inline
name|void
name|ahd_swap_with_next_hscb
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|,
name|struct
name|scb
modifier|*
name|scb
parameter_list|)
block|{
name|struct
name|hardware_scb
modifier|*
name|q_hscb
decl_stmt|;
name|struct
name|map_node
modifier|*
name|q_hscb_map
decl_stmt|;
name|uint32_t
name|saved_hscb_busaddr
decl_stmt|;
comment|/* 	 * Our queuing method is a bit tricky.  The card 	 * knows in advance which HSCB (by address) to download, 	 * and we can't disappoint it.  To achieve this, the next 	 * HSCB to download is saved off in ahd->next_queued_hscb. 	 * When we are called to queue "an arbitrary scb", 	 * we copy the contents of the incoming HSCB to the one 	 * the sequencer knows about, swap HSCB pointers and 	 * finally assign the SCB to the tag indexed location 	 * in the scb_array.  This makes sure that we can still 	 * locate the correct SCB by SCB_TAG. 	 */
name|q_hscb
operator|=
name|ahd
operator|->
name|next_queued_hscb
expr_stmt|;
name|q_hscb_map
operator|=
name|ahd
operator|->
name|next_queued_hscb_map
expr_stmt|;
name|saved_hscb_busaddr
operator|=
name|q_hscb
operator|->
name|hscb_busaddr
expr_stmt|;
name|memcpy
argument_list|(
name|q_hscb
argument_list|,
name|scb
operator|->
name|hscb
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|scb
operator|->
name|hscb
argument_list|)
argument_list|)
expr_stmt|;
name|q_hscb
operator|->
name|hscb_busaddr
operator|=
name|saved_hscb_busaddr
expr_stmt|;
name|q_hscb
operator|->
name|next_hscb_busaddr
operator|=
name|scb
operator|->
name|hscb
operator|->
name|hscb_busaddr
expr_stmt|;
comment|/* Now swap HSCB pointers. */
name|ahd
operator|->
name|next_queued_hscb
operator|=
name|scb
operator|->
name|hscb
expr_stmt|;
name|ahd
operator|->
name|next_queued_hscb_map
operator|=
name|scb
operator|->
name|hscb_map
expr_stmt|;
name|scb
operator|->
name|hscb
operator|=
name|q_hscb
expr_stmt|;
name|scb
operator|->
name|hscb_map
operator|=
name|q_hscb_map
expr_stmt|;
comment|/* Now define the mapping from tag to SCB in the scbindex */
name|ahd
operator|->
name|scb_data
operator|.
name|scbindex
index|[
name|SCB_GET_TAG
argument_list|(
name|scb
argument_list|)
index|]
operator|=
name|scb
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Tell the sequencer about a new transaction to execute.  */
end_comment

begin_function
specifier|static
name|__inline
name|void
name|ahd_queue_scb
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|,
name|struct
name|scb
modifier|*
name|scb
parameter_list|)
block|{
name|ahd_swap_with_next_hscb
argument_list|(
name|ahd
argument_list|,
name|scb
argument_list|)
expr_stmt|;
if|if
condition|(
name|SCBID_IS_NULL
argument_list|(
name|SCB_GET_TAG
argument_list|(
name|scb
argument_list|)
argument_list|)
condition|)
name|panic
argument_list|(
literal|"Attempt to queue invalid SCB tag %x\n"
argument_list|,
name|SCB_GET_TAG
argument_list|(
name|scb
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Keep a history of SCBs we've downloaded in the qinfifo. 	 */
name|ahd
operator|->
name|qinfifo
index|[
name|AHD_QIN_WRAP
argument_list|(
name|ahd
operator|->
name|qinfifonext
argument_list|)
index|]
operator|=
name|SCB_GET_TAG
argument_list|(
name|scb
argument_list|)
expr_stmt|;
name|ahd
operator|->
name|qinfifonext
operator|++
expr_stmt|;
if|if
condition|(
name|scb
operator|->
name|sg_count
operator|!=
literal|0
condition|)
name|ahd_setup_data_scb
argument_list|(
name|ahd
argument_list|,
name|scb
argument_list|)
expr_stmt|;
else|else
name|ahd_setup_noxfer_scb
argument_list|(
name|ahd
argument_list|,
name|scb
argument_list|)
expr_stmt|;
name|ahd_setup_scb_common
argument_list|(
name|ahd
argument_list|,
name|scb
argument_list|)
expr_stmt|;
comment|/* 	 * Make sure our data is consistent from the 	 * perspective of the adapter. 	 */
name|ahd_sync_scb
argument_list|(
name|ahd
argument_list|,
name|scb
argument_list|,
name|BUS_DMASYNC_PREREAD
operator||
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|AHD_DEBUG
if|if
condition|(
operator|(
name|ahd_debug
operator|&
name|AHD_SHOW_QUEUE
operator|)
operator|!=
literal|0
condition|)
block|{
name|uint64_t
name|host_dataptr
decl_stmt|;
name|host_dataptr
operator|=
name|aic_le64toh
argument_list|(
name|scb
operator|->
name|hscb
operator|->
name|dataptr
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s: Queueing SCB %d:0x%x bus addr 0x%x - 0x%x%x/0x%x\n"
argument_list|,
name|ahd_name
argument_list|(
name|ahd
argument_list|)
argument_list|,
name|SCB_GET_TAG
argument_list|(
name|scb
argument_list|)
argument_list|,
name|scb
operator|->
name|hscb
operator|->
name|scsiid
argument_list|,
name|aic_le32toh
argument_list|(
name|scb
operator|->
name|hscb
operator|->
name|hscb_busaddr
argument_list|)
argument_list|,
call|(
name|u_int
call|)
argument_list|(
operator|(
name|host_dataptr
operator|>>
literal|32
operator|)
operator|&
literal|0xFFFFFFFF
argument_list|)
argument_list|,
call|(
name|u_int
call|)
argument_list|(
name|host_dataptr
operator|&
literal|0xFFFFFFFF
argument_list|)
argument_list|,
name|aic_le32toh
argument_list|(
name|scb
operator|->
name|hscb
operator|->
name|datacnt
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Tell the adapter about the newly queued SCB */
name|ahd_set_hnscb_qoff
argument_list|(
name|ahd
argument_list|,
name|ahd
operator|->
name|qinfifonext
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|uint8_t
modifier|*
name|ahd_get_sense_buf
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|,
name|struct
name|scb
modifier|*
name|scb
parameter_list|)
block|{
return|return
operator|(
name|scb
operator|->
name|sense_data
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|uint32_t
name|ahd_get_sense_bufaddr
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|,
name|struct
name|scb
modifier|*
name|scb
parameter_list|)
block|{
return|return
operator|(
name|scb
operator|->
name|sense_busaddr
operator|)
return|;
block|}
end_function

begin_comment
comment|/************************** Interrupt Processing ******************************/
end_comment

begin_function_decl
specifier|static
name|__inline
name|void
name|ahd_sync_qoutfifo
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|,
name|int
name|op
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__inline
name|void
name|ahd_sync_tqinfifo
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|,
name|int
name|op
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__inline
name|u_int
name|ahd_check_cmdcmpltqueues
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__inline
name|int
name|ahd_intr
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|__inline
name|void
name|ahd_sync_qoutfifo
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|,
name|int
name|op
parameter_list|)
block|{
name|aic_dmamap_sync
argument_list|(
name|ahd
argument_list|,
name|ahd
operator|->
name|shared_data_dmat
argument_list|,
name|ahd
operator|->
name|shared_data_map
operator|.
name|dmamap
argument_list|,
comment|/*offset*/
literal|0
argument_list|,
comment|/*len*/
name|AHD_SCB_MAX
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|ahd_completion
argument_list|)
argument_list|,
name|op
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|ahd_sync_tqinfifo
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|,
name|int
name|op
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|AHD_TARGET_MODE
if|if
condition|(
operator|(
name|ahd
operator|->
name|flags
operator|&
name|AHD_TARGETROLE
operator|)
operator|!=
literal|0
condition|)
block|{
name|aic_dmamap_sync
argument_list|(
name|ahd
argument_list|,
name|ahd
operator|->
name|shared_data_dmat
argument_list|,
name|ahd
operator|->
name|shared_data_map
operator|.
name|dmamap
argument_list|,
name|ahd_targetcmd_offset
argument_list|(
name|ahd
argument_list|,
literal|0
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|target_cmd
argument_list|)
operator|*
name|AHD_TMODE_CMDS
argument_list|,
name|op
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * See if the firmware has posted any completed commands  * into our in-core command complete fifos.  */
end_comment

begin_define
define|#
directive|define
name|AHD_RUN_QOUTFIFO
value|0x1
end_define

begin_define
define|#
directive|define
name|AHD_RUN_TQINFIFO
value|0x2
end_define

begin_function
specifier|static
name|__inline
name|u_int
name|ahd_check_cmdcmpltqueues
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|)
block|{
name|u_int
name|retval
decl_stmt|;
name|retval
operator|=
literal|0
expr_stmt|;
name|aic_dmamap_sync
argument_list|(
name|ahd
argument_list|,
name|ahd
operator|->
name|shared_data_dmat
argument_list|,
name|ahd
operator|->
name|shared_data_map
operator|.
name|dmamap
argument_list|,
comment|/*offset*/
name|ahd
operator|->
name|qoutfifonext
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|ahd
operator|->
name|qoutfifo
argument_list|)
argument_list|,
comment|/*len*/
sizeof|sizeof
argument_list|(
operator|*
name|ahd
operator|->
name|qoutfifo
argument_list|)
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
if|if
condition|(
name|ahd
operator|->
name|qoutfifo
index|[
name|ahd
operator|->
name|qoutfifonext
index|]
operator|.
name|valid_tag
operator|==
name|ahd
operator|->
name|qoutfifonext_valid_tag
condition|)
name|retval
operator||=
name|AHD_RUN_QOUTFIFO
expr_stmt|;
ifdef|#
directive|ifdef
name|AHD_TARGET_MODE
if|if
condition|(
operator|(
name|ahd
operator|->
name|flags
operator|&
name|AHD_TARGETROLE
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|ahd
operator|->
name|flags
operator|&
name|AHD_TQINFIFO_BLOCKED
operator|)
operator|==
literal|0
condition|)
block|{
name|aic_dmamap_sync
argument_list|(
name|ahd
argument_list|,
name|ahd
operator|->
name|shared_data_dmat
argument_list|,
name|ahd
operator|->
name|shared_data_map
operator|.
name|dmamap
argument_list|,
name|ahd_targetcmd_offset
argument_list|(
name|ahd
argument_list|,
name|ahd
operator|->
name|tqinfifofnext
argument_list|)
argument_list|,
comment|/*len*/
sizeof|sizeof
argument_list|(
expr|struct
name|target_cmd
argument_list|)
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
if|if
condition|(
name|ahd
operator|->
name|targetcmds
index|[
name|ahd
operator|->
name|tqinfifonext
index|]
operator|.
name|cmd_valid
operator|!=
literal|0
condition|)
name|retval
operator||=
name|AHD_RUN_TQINFIFO
expr_stmt|;
block|}
endif|#
directive|endif
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Catch an interrupt from the adapter  */
end_comment

begin_function
specifier|static
name|__inline
name|int
name|ahd_intr
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|)
block|{
name|u_int
name|intstat
decl_stmt|;
if|if
condition|(
operator|(
name|ahd
operator|->
name|pause
operator|&
name|INTEN
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 		 * Our interrupt is not enabled on the chip 		 * and may be disabled for re-entrancy reasons, 		 * so just return.  This is likely just a shared 		 * interrupt. 		 */
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * Instead of directly reading the interrupt status register, 	 * infer the cause of the interrupt by checking our in-core 	 * completion queues.  This avoids a costly PCI bus read in 	 * most cases. 	 */
if|if
condition|(
operator|(
name|ahd
operator|->
name|flags
operator|&
name|AHD_ALL_INTERRUPTS
operator|)
operator|==
literal|0
operator|&&
operator|(
name|ahd_check_cmdcmpltqueues
argument_list|(
name|ahd
argument_list|)
operator|!=
literal|0
operator|)
condition|)
name|intstat
operator|=
name|CMDCMPLT
expr_stmt|;
else|else
name|intstat
operator|=
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|INTSTAT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|intstat
operator|&
name|INT_PEND
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|intstat
operator|&
name|CMDCMPLT
condition|)
block|{
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|CLRINT
argument_list|,
name|CLRCMDINT
argument_list|)
expr_stmt|;
comment|/* 		 * Ensure that the chip sees that we've cleared 		 * this interrupt before we walk the output fifo. 		 * Otherwise, we may, due to posted bus writes, 		 * clear the interrupt after we finish the scan, 		 * and after the sequencer has added new entries 		 * and asserted the interrupt again. 		 */
if|if
condition|(
operator|(
name|ahd
operator|->
name|bugs
operator|&
name|AHD_INTCOLLISION_BUG
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|ahd_is_paused
argument_list|(
name|ahd
argument_list|)
condition|)
block|{
comment|/* 				 * Potentially lost SEQINT. 				 * If SEQINTCODE is non-zero, 				 * simulate the SEQINT. 				 */
if|if
condition|(
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|SEQINTCODE
argument_list|)
operator|!=
name|NO_SEQINT
condition|)
name|intstat
operator||=
name|SEQINT
expr_stmt|;
block|}
block|}
else|else
block|{
name|ahd_flush_device_writes
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
block|}
name|ahd_run_qoutfifo
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
name|ahd
operator|->
name|cmdcmplt_counts
index|[
name|ahd
operator|->
name|cmdcmplt_bucket
index|]
operator|++
expr_stmt|;
name|ahd
operator|->
name|cmdcmplt_total
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|AHD_TARGET_MODE
if|if
condition|(
operator|(
name|ahd
operator|->
name|flags
operator|&
name|AHD_TARGETROLE
operator|)
operator|!=
literal|0
condition|)
name|ahd_run_tqinfifo
argument_list|(
name|ahd
argument_list|,
comment|/*paused*/
name|FALSE
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* 	 * Handle statuses that may invalidate our cached 	 * copy of INTSTAT separately. 	 */
if|if
condition|(
name|intstat
operator|==
literal|0xFF
operator|&&
operator|(
name|ahd
operator|->
name|features
operator|&
name|AHD_REMOVABLE
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* Hot eject.  Do nothing */
block|}
elseif|else
if|if
condition|(
name|intstat
operator|&
name|HWERRINT
condition|)
block|{
name|ahd_handle_hwerrint
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|intstat
operator|&
operator|(
name|PCIINT
operator||
name|SPLTINT
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|ahd
operator|->
name|bus_intr
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|intstat
operator|&
name|SEQINT
operator|)
operator|!=
literal|0
condition|)
name|ahd_handle_seqint
argument_list|(
name|ahd
argument_list|,
name|intstat
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|intstat
operator|&
name|SCSIINT
operator|)
operator|!=
literal|0
condition|)
name|ahd_handle_scsiint
argument_list|(
name|ahd
argument_list|,
name|intstat
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* _AIC79XX_INLINE_H_ */
end_comment

end_unit

