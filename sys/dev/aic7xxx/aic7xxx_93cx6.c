begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Interface for the 93C66/56/46/26/06 serial eeprom parts.  *  * Copyright (c) 1995, 1996 Daniel M. Eischen  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions, and the following disclaimer,  *    without modification.  * 2. The name of the author may not be used to endorse or promote products  *    derived from this software without specific prior written permission.  *  * Alternatively, this software may be distributed under the terms of the  * GNU Public License ("GPL").  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE FOR  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $Id: //depot/src/aic7xxx/aic7xxx_93cx6.c#8 $  *  * $FreeBSD$  */
end_comment

begin_comment
comment|/*  *   The instruction set of the 93C66/56/46/26/06 chips are as follows:  *  *               Start  OP	    *  *     Function   Bit  Code  Address**  Data     Description  *     -------------------------------------------------------------------  *     READ        1    10   A5 - A0             Reads data stored in memory,  *                                               starting at specified address  *     EWEN        1    00   11XXXX              Write enable must precede  *                                               all programming modes  *     ERASE       1    11   A5 - A0             Erase register A5A4A3A2A1A0  *     WRITE       1    01   A5 - A0   D15 - D0  Writes register  *     ERAL        1    00   10XXXX              Erase all registers  *     WRAL        1    00   01XXXX    D15 - D0  Writes to all registers  *     EWDS        1    00   00XXXX              Disables all programming  *                                               instructions  *     *Note: A value of X for address is a don't care condition.  *    **Note: There are 8 address bits for the 93C56/66 chips unlike  *	      the 93C46/26/06 chips which have 6 address bits.  *  *   The 93C46 has a four wire interface: clock, chip select, data in, and  *   data out.  In order to perform one of the above functions, you need  *   to enable the chip select for a clock period (typically a minimum of  *   1 usec, with the clock high and low a minimum of 750 and 250 nsec  *   respectively).  While the chip select remains high, you can clock in  *   the instructions (above) starting with the start bit, followed by the  *   OP code, Address, and Data (if needed).  For the READ instruction, the  *   requested 16-bit register contents is read from the data out line but  *   is preceded by an initial zero (leading 0, followed by 16-bits, MSB  *   first).  The clock cycling from low to high initiates the next data  *   bit to be sent from the chip.  *  */
end_comment

begin_include
include|#
directive|include
file|<dev/aic7xxx/aic7xxx_freebsd.h>
end_include

begin_include
include|#
directive|include
file|<dev/aic7xxx/aic7xxx_inline.h>
end_include

begin_include
include|#
directive|include
file|<dev/aic7xxx/aic7xxx_93cx6.h>
end_include

begin_comment
comment|/*  * Right now, we only have to read the SEEPROM.  But we make it easier to  * add other 93Cx6 functions.  */
end_comment

begin_struct
specifier|static
struct|struct
name|seeprom_cmd
block|{
name|uint8_t
name|len
decl_stmt|;
name|uint8_t
name|bits
index|[
literal|3
index|]
decl_stmt|;
block|}
name|seeprom_read
init|=
block|{
literal|3
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|0
block|}
block|}
struct|;
end_struct

begin_comment
comment|/*  * Wait for the SEERDY to go high; about 800 ns.  */
end_comment

begin_define
define|#
directive|define
name|CLOCK_PULSE
parameter_list|(
name|sd
parameter_list|,
name|rdy
parameter_list|)
define|\
value|while ((SEEPROM_STATUS_INB(sd)& rdy) == 0) {	\ 		;
comment|/* Do nothing */
value|\ 	}						\ 	(void)SEEPROM_INB(sd);
end_define

begin_comment
comment|/* Clear clock */
end_comment

begin_comment
comment|/*  * Read the serial EEPROM and returns 1 if successful and 0 if  * not successful.  */
end_comment

begin_function
name|int
name|read_seeprom
parameter_list|(
name|sd
parameter_list|,
name|buf
parameter_list|,
name|start_addr
parameter_list|,
name|count
parameter_list|)
name|struct
name|seeprom_descriptor
modifier|*
name|sd
decl_stmt|;
name|uint16_t
modifier|*
name|buf
decl_stmt|;
name|u_int
name|start_addr
decl_stmt|;
name|u_int
name|count
decl_stmt|;
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
name|u_int
name|k
init|=
literal|0
decl_stmt|;
name|uint16_t
name|v
decl_stmt|;
name|uint8_t
name|temp
decl_stmt|;
comment|/* 	 * Read the requested registers of the seeprom.  The loop 	 * will range from 0 to count-1. 	 */
for|for
control|(
name|k
operator|=
name|start_addr
init|;
name|k
operator|<
name|count
operator|+
name|start_addr
condition|;
name|k
operator|++
control|)
block|{
comment|/* Send chip select for one clock cycle. */
name|temp
operator|=
name|sd
operator|->
name|sd_MS
operator|^
name|sd
operator|->
name|sd_CS
expr_stmt|;
name|SEEPROM_OUTB
argument_list|(
name|sd
argument_list|,
name|temp
operator|^
name|sd
operator|->
name|sd_CK
argument_list|)
expr_stmt|;
name|CLOCK_PULSE
argument_list|(
name|sd
argument_list|,
name|sd
operator|->
name|sd_RDY
argument_list|)
expr_stmt|;
comment|/* 		 * Now we're ready to send the read command followed by the 		 * address of the 16-bit register we want to read. 		 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|seeprom_read
operator|.
name|len
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|seeprom_read
operator|.
name|bits
index|[
name|i
index|]
operator|!=
literal|0
condition|)
name|temp
operator|^=
name|sd
operator|->
name|sd_DO
expr_stmt|;
name|SEEPROM_OUTB
argument_list|(
name|sd
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|CLOCK_PULSE
argument_list|(
name|sd
argument_list|,
name|sd
operator|->
name|sd_RDY
argument_list|)
expr_stmt|;
name|SEEPROM_OUTB
argument_list|(
name|sd
argument_list|,
name|temp
operator|^
name|sd
operator|->
name|sd_CK
argument_list|)
expr_stmt|;
name|CLOCK_PULSE
argument_list|(
name|sd
argument_list|,
name|sd
operator|->
name|sd_RDY
argument_list|)
expr_stmt|;
if|if
condition|(
name|seeprom_read
operator|.
name|bits
index|[
name|i
index|]
operator|!=
literal|0
condition|)
name|temp
operator|^=
name|sd
operator|->
name|sd_DO
expr_stmt|;
block|}
comment|/* Send the 6 or 8 bit address (MSB first, LSB last). */
for|for
control|(
name|i
operator|=
operator|(
name|sd
operator|->
name|sd_chip
operator|-
literal|1
operator|)
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
operator|(
name|k
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
operator|)
operator|!=
literal|0
condition|)
name|temp
operator|^=
name|sd
operator|->
name|sd_DO
expr_stmt|;
name|SEEPROM_OUTB
argument_list|(
name|sd
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|CLOCK_PULSE
argument_list|(
name|sd
argument_list|,
name|sd
operator|->
name|sd_RDY
argument_list|)
expr_stmt|;
name|SEEPROM_OUTB
argument_list|(
name|sd
argument_list|,
name|temp
operator|^
name|sd
operator|->
name|sd_CK
argument_list|)
expr_stmt|;
name|CLOCK_PULSE
argument_list|(
name|sd
argument_list|,
name|sd
operator|->
name|sd_RDY
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|k
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
operator|)
operator|!=
literal|0
condition|)
name|temp
operator|^=
name|sd
operator|->
name|sd_DO
expr_stmt|;
block|}
comment|/* 		 * Now read the 16 bit register.  An initial 0 precedes the 		 * register contents which begins with bit 15 (MSB) and ends 		 * with bit 0 (LSB).  The initial 0 will be shifted off the 		 * top of our word as we let the loop run from 0 to 16. 		 */
name|v
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|16
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|SEEPROM_OUTB
argument_list|(
name|sd
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|CLOCK_PULSE
argument_list|(
name|sd
argument_list|,
name|sd
operator|->
name|sd_RDY
argument_list|)
expr_stmt|;
name|v
operator|<<=
literal|1
expr_stmt|;
if|if
condition|(
name|SEEPROM_DATA_INB
argument_list|(
name|sd
argument_list|)
operator|&
name|sd
operator|->
name|sd_DI
condition|)
name|v
operator||=
literal|1
expr_stmt|;
name|SEEPROM_OUTB
argument_list|(
name|sd
argument_list|,
name|temp
operator|^
name|sd
operator|->
name|sd_CK
argument_list|)
expr_stmt|;
name|CLOCK_PULSE
argument_list|(
name|sd
argument_list|,
name|sd
operator|->
name|sd_RDY
argument_list|)
expr_stmt|;
block|}
name|buf
index|[
name|k
operator|-
name|start_addr
index|]
operator|=
name|v
expr_stmt|;
comment|/* Reset the chip select for the next command cycle. */
name|temp
operator|=
name|sd
operator|->
name|sd_MS
expr_stmt|;
name|SEEPROM_OUTB
argument_list|(
name|sd
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|CLOCK_PULSE
argument_list|(
name|sd
argument_list|,
name|sd
operator|->
name|sd_RDY
argument_list|)
expr_stmt|;
name|SEEPROM_OUTB
argument_list|(
name|sd
argument_list|,
name|temp
operator|^
name|sd
operator|->
name|sd_CK
argument_list|)
expr_stmt|;
name|CLOCK_PULSE
argument_list|(
name|sd
argument_list|,
name|sd
operator|->
name|sd_RDY
argument_list|)
expr_stmt|;
name|SEEPROM_OUTB
argument_list|(
name|sd
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|CLOCK_PULSE
argument_list|(
name|sd
argument_list|,
name|sd
operator|->
name|sd_RDY
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|AHC_DUMP_EEPROM
name|printf
argument_list|(
literal|"\nSerial EEPROM:\n\t"
argument_list|)
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|count
condition|;
name|k
operator|=
name|k
operator|+
literal|1
control|)
block|{
if|if
condition|(
operator|(
operator|(
name|k
operator|%
literal|8
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|k
operator|!=
literal|0
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"\n\t"
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|" 0x%x"
argument_list|,
name|buf
index|[
name|k
index|]
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|int
name|verify_cksum
parameter_list|(
name|struct
name|seeprom_config
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|maxaddr
decl_stmt|;
name|uint32_t
name|checksum
decl_stmt|;
name|uint16_t
modifier|*
name|scarray
decl_stmt|;
name|maxaddr
operator|=
operator|(
sizeof|sizeof
argument_list|(
operator|*
name|sc
argument_list|)
operator|/
literal|2
operator|)
operator|-
literal|1
expr_stmt|;
name|checksum
operator|=
literal|0
expr_stmt|;
name|scarray
operator|=
operator|(
name|uint16_t
operator|*
operator|)
name|sc
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|maxaddr
condition|;
name|i
operator|++
control|)
name|checksum
operator|=
name|checksum
operator|+
name|scarray
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|checksum
operator|==
literal|0
operator|||
operator|(
name|checksum
operator|&
literal|0xFFFF
operator|)
operator|!=
name|sc
operator|->
name|checksum
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
block|{
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
end_function

end_unit

