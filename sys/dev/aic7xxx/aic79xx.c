begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Core routines and tables shareable across OS platforms.  *  * Copyright (c) 1994-2002, 2004 Justin T. Gibbs.  * Copyright (c) 2000-2003 Adaptec Inc.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions, and the following disclaimer,  *    without modification.  * 2. Redistributions in binary form must reproduce at minimum a disclaimer  *    substantially similar to the "NO WARRANTY" disclaimer below  *    ("Disclaimer") and any redistribution must be conditioned upon  *    including a substantially similar Disclaimer requirement for further  *    binary redistribution.  * 3. Neither the names of the above-listed copyright holders nor the names  *    of any contributors may be used to endorse or promote products derived  *    from this software without specific prior written permission.  *  * Alternatively, this software may be distributed under the terms of the  * GNU General Public License ("GPL") version 2 as published by the Free  * Software Foundation.  *  * NO WARRANTY  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT  * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING  * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  * POSSIBILITY OF SUCH DAMAGES.  *  * $Id: //depot/aic7xxx/aic7xxx/aic79xx.c#246 $  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__linux__
end_ifdef

begin_include
include|#
directive|include
file|"aic79xx_osm.h"
end_include

begin_include
include|#
directive|include
file|"aic79xx_inline.h"
end_include

begin_include
include|#
directive|include
file|"aicasm/aicasm_insformat.h"
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<dev/aic7xxx/aic79xx_osm.h>
end_include

begin_include
include|#
directive|include
file|<dev/aic7xxx/aic79xx_inline.h>
end_include

begin_include
include|#
directive|include
file|<dev/aic7xxx/aicasm/aicasm_insformat.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/******************************** Globals *************************************/
end_comment

begin_decl_stmt
name|struct
name|ahd_softc_tailq
name|ahd_tailq
init|=
name|TAILQ_HEAD_INITIALIZER
argument_list|(
name|ahd_tailq
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|uint32_t
name|ahd_attach_to_HostRAID_controllers
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/***************************** Lookup Tables **********************************/
end_comment

begin_decl_stmt
name|char
modifier|*
name|ahd_chip_names
index|[]
init|=
block|{
literal|"NONE"
block|,
literal|"aic7901"
block|,
literal|"aic7902"
block|,
literal|"aic7901A"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|u_int
name|num_chip_names
init|=
name|NUM_ELEMENTS
argument_list|(
name|ahd_chip_names
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Hardware error codes.  */
end_comment

begin_struct
struct|struct
name|ahd_hard_error_entry
block|{
name|uint8_t
name|errno
decl_stmt|;
name|char
modifier|*
name|errmesg
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|ahd_hard_error_entry
name|ahd_hard_errors
index|[]
init|=
block|{
block|{
name|DSCTMOUT
block|,
literal|"Discard Timer has timed out"
block|}
block|,
block|{
name|ILLOPCODE
block|,
literal|"Illegal Opcode in sequencer program"
block|}
block|,
block|{
name|SQPARERR
block|,
literal|"Sequencer Parity Error"
block|}
block|,
block|{
name|DPARERR
block|,
literal|"Data-path Parity Error"
block|}
block|,
block|{
name|MPARERR
block|,
literal|"Scratch or SCB Memory Parity Error"
block|}
block|,
block|{
name|CIOPARERR
block|,
literal|"CIOBUS Parity Error"
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|u_int
name|num_errors
init|=
name|NUM_ELEMENTS
argument_list|(
name|ahd_hard_errors
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|ahd_phase_table_entry
name|ahd_phase_table
index|[]
init|=
block|{
block|{
name|P_DATAOUT
block|,
name|MSG_NOOP
block|,
literal|"in Data-out phase"
block|}
block|,
block|{
name|P_DATAIN
block|,
name|MSG_INITIATOR_DET_ERR
block|,
literal|"in Data-in phase"
block|}
block|,
block|{
name|P_DATAOUT_DT
block|,
name|MSG_NOOP
block|,
literal|"in DT Data-out phase"
block|}
block|,
block|{
name|P_DATAIN_DT
block|,
name|MSG_INITIATOR_DET_ERR
block|,
literal|"in DT Data-in phase"
block|}
block|,
block|{
name|P_COMMAND
block|,
name|MSG_NOOP
block|,
literal|"in Command phase"
block|}
block|,
block|{
name|P_MESGOUT
block|,
name|MSG_NOOP
block|,
literal|"in Message-out phase"
block|}
block|,
block|{
name|P_STATUS
block|,
name|MSG_INITIATOR_DET_ERR
block|,
literal|"in Status phase"
block|}
block|,
block|{
name|P_MESGIN
block|,
name|MSG_PARITY_ERROR
block|,
literal|"in Message-in phase"
block|}
block|,
block|{
name|P_BUSFREE
block|,
name|MSG_NOOP
block|,
literal|"while idle"
block|}
block|,
block|{
literal|0
block|,
name|MSG_NOOP
block|,
literal|"in unknown phase"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * In most cases we only wish to itterate over real phases, so  * exclude the last element from the count.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|u_int
name|num_phases
init|=
name|NUM_ELEMENTS
argument_list|(
name|ahd_phase_table
argument_list|)
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Our Sequencer Program */
end_comment

begin_include
include|#
directive|include
file|"aic79xx_seq.h"
end_include

begin_comment
comment|/**************************** Function Declarations ***************************/
end_comment

begin_function_decl
specifier|static
name|void
name|ahd_handle_transmission_error
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ahd_handle_lqiphase_error
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|,
name|u_int
name|lqistat1
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ahd_handle_pkt_busfree
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|,
name|u_int
name|busfreetime
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ahd_handle_nonpkt_busfree
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ahd_handle_proto_violation
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ahd_force_renegotiation
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|,
name|struct
name|ahd_devinfo
modifier|*
name|devinfo
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|ahd_tmode_tstate
modifier|*
name|ahd_alloc_tstate
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|,
name|u_int
name|scsi_id
parameter_list|,
name|char
name|channel
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|AHD_TARGET_MODE
end_ifdef

begin_function_decl
specifier|static
name|void
name|ahd_free_tstate
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|,
name|u_int
name|scsi_id
parameter_list|,
name|char
name|channel
parameter_list|,
name|int
name|force
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|ahd_devlimited_syncrate
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|,
name|struct
name|ahd_initiator_tinfo
modifier|*
parameter_list|,
name|u_int
modifier|*
name|period
parameter_list|,
name|u_int
modifier|*
name|ppr_options
parameter_list|,
name|role_t
name|role
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ahd_update_neg_table
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|,
name|struct
name|ahd_devinfo
modifier|*
name|devinfo
parameter_list|,
name|struct
name|ahd_transinfo
modifier|*
name|tinfo
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ahd_update_pending_scbs
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ahd_fetch_devinfo
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|,
name|struct
name|ahd_devinfo
modifier|*
name|devinfo
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ahd_scb_devinfo
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|,
name|struct
name|ahd_devinfo
modifier|*
name|devinfo
parameter_list|,
name|struct
name|scb
modifier|*
name|scb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ahd_setup_initiator_msgout
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|,
name|struct
name|ahd_devinfo
modifier|*
name|devinfo
parameter_list|,
name|struct
name|scb
modifier|*
name|scb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ahd_build_transfer_msg
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|,
name|struct
name|ahd_devinfo
modifier|*
name|devinfo
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ahd_construct_sdtr
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|,
name|struct
name|ahd_devinfo
modifier|*
name|devinfo
parameter_list|,
name|u_int
name|period
parameter_list|,
name|u_int
name|offset
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ahd_construct_wdtr
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|,
name|struct
name|ahd_devinfo
modifier|*
name|devinfo
parameter_list|,
name|u_int
name|bus_width
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ahd_construct_ppr
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|,
name|struct
name|ahd_devinfo
modifier|*
name|devinfo
parameter_list|,
name|u_int
name|period
parameter_list|,
name|u_int
name|offset
parameter_list|,
name|u_int
name|bus_width
parameter_list|,
name|u_int
name|ppr_options
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ahd_clear_msg_state
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ahd_handle_message_phase
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|)
function_decl|;
end_function_decl

begin_typedef
typedef|typedef
enum|enum
block|{
name|AHDMSG_1B
block|,
name|AHDMSG_2B
block|,
name|AHDMSG_EXT
block|}
name|ahd_msgtype
typedef|;
end_typedef

begin_function_decl
specifier|static
name|int
name|ahd_sent_msg
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|,
name|ahd_msgtype
name|type
parameter_list|,
name|u_int
name|msgval
parameter_list|,
name|int
name|full
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ahd_parse_msg
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|,
name|struct
name|ahd_devinfo
modifier|*
name|devinfo
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ahd_handle_msg_reject
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|,
name|struct
name|ahd_devinfo
modifier|*
name|devinfo
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ahd_handle_ign_wide_residue
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|,
name|struct
name|ahd_devinfo
modifier|*
name|devinfo
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ahd_reinitialize_dataptrs
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ahd_handle_devreset
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|,
name|struct
name|ahd_devinfo
modifier|*
name|devinfo
parameter_list|,
name|u_int
name|lun
parameter_list|,
name|cam_status
name|status
parameter_list|,
name|char
modifier|*
name|message
parameter_list|,
name|int
name|verbose_level
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|AHD_TARGET_MODE
end_ifdef

begin_function_decl
specifier|static
name|void
name|ahd_setup_target_msgin
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|,
name|struct
name|ahd_devinfo
modifier|*
name|devinfo
parameter_list|,
name|struct
name|scb
modifier|*
name|scb
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|u_int
name|ahd_sglist_size
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u_int
name|ahd_sglist_allocsize
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|bus_dmamap_callback_t
name|ahd_dmamap_cb
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|ahd_initialize_hscbs
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ahd_init_scbdata
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ahd_fini_scbdata
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ahd_setup_iocell_workaround
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ahd_iocell_first_selection
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ahd_add_col_list
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|,
name|struct
name|scb
modifier|*
name|scb
parameter_list|,
name|u_int
name|col_idx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ahd_rem_col_list
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|,
name|struct
name|scb
modifier|*
name|scb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ahd_chip_init
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ahd_qinfifo_requeue
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|,
name|struct
name|scb
modifier|*
name|prev_scb
parameter_list|,
name|struct
name|scb
modifier|*
name|scb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ahd_qinfifo_count
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ahd_search_scb_list
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|,
name|int
name|target
parameter_list|,
name|char
name|channel
parameter_list|,
name|int
name|lun
parameter_list|,
name|u_int
name|tag
parameter_list|,
name|role_t
name|role
parameter_list|,
name|uint32_t
name|status
parameter_list|,
name|ahd_search_action
name|action
parameter_list|,
name|u_int
modifier|*
name|list_head
parameter_list|,
name|u_int
modifier|*
name|list_tail
parameter_list|,
name|u_int
name|tid
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ahd_stitch_tid_list
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|,
name|u_int
name|tid_prev
parameter_list|,
name|u_int
name|tid_cur
parameter_list|,
name|u_int
name|tid_next
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ahd_add_scb_to_free_list
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|,
name|u_int
name|scbid
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u_int
name|ahd_rem_wscb
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|,
name|u_int
name|scbid
parameter_list|,
name|u_int
name|prev
parameter_list|,
name|u_int
name|next
parameter_list|,
name|u_int
name|tid
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ahd_reset_current_bus
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|ahd_callback_t
name|ahd_reset_poll
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ahd_callback_t
name|ahd_stat_timer
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|AHD_DUMP_SEQ
end_ifdef

begin_function_decl
specifier|static
name|void
name|ahd_dumpseq
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|ahd_loadseq
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ahd_check_patch
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|,
name|struct
name|patch
modifier|*
modifier|*
name|start_patch
parameter_list|,
name|u_int
name|start_instr
parameter_list|,
name|u_int
modifier|*
name|skip_addr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u_int
name|ahd_resolve_seqaddr
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|,
name|u_int
name|address
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ahd_download_instr
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|,
name|u_int
name|instrptr
parameter_list|,
name|uint8_t
modifier|*
name|dconsts
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ahd_probe_stack_size
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ahd_other_scb_timeout
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|,
name|struct
name|scb
modifier|*
name|scb
parameter_list|,
name|struct
name|scb
modifier|*
name|other_scb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ahd_scb_active_in_fifo
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|,
name|struct
name|scb
modifier|*
name|scb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ahd_run_data_fifo
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|,
name|struct
name|scb
modifier|*
name|scb
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|AHD_TARGET_MODE
end_ifdef

begin_function_decl
specifier|static
name|void
name|ahd_queue_lstate_event
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|,
name|struct
name|ahd_tmode_lstate
modifier|*
name|lstate
parameter_list|,
name|u_int
name|initiator_id
parameter_list|,
name|u_int
name|event_type
parameter_list|,
name|u_int
name|event_arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ahd_update_scsiid
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|,
name|u_int
name|targid_mask
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ahd_handle_target_cmd
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|,
name|struct
name|target_cmd
modifier|*
name|cmd
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/******************************** Private Inlines *****************************/
end_comment

begin_function_decl
specifier|static
name|__inline
name|void
name|ahd_assert_atn
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__inline
name|int
name|ahd_currently_packetized
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__inline
name|int
name|ahd_set_active_fifo
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|__inline
name|void
name|ahd_assert_atn
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|)
block|{
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|SCSISIGO
argument_list|,
name|ATNO
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Determine if the current connection has a packetized  * agreement.  This does not necessarily mean that we  * are currently in a packetized transfer.  We could  * just as easily be sending or receiving a message.  */
end_comment

begin_function
specifier|static
name|__inline
name|int
name|ahd_currently_packetized
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|)
block|{
name|ahd_mode_state
name|saved_modes
decl_stmt|;
name|int
name|packetized
decl_stmt|;
name|saved_modes
operator|=
name|ahd_save_modes
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ahd
operator|->
name|bugs
operator|&
name|AHD_PKTIZED_STATUS_BUG
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * The packetized bit refers to the last 		 * connection, not the current one.  Check 		 * for non-zero LQISTATE instead. 		 */
name|ahd_set_modes
argument_list|(
name|ahd
argument_list|,
name|AHD_MODE_CFG
argument_list|,
name|AHD_MODE_CFG
argument_list|)
expr_stmt|;
name|packetized
operator|=
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|LQISTATE
argument_list|)
operator|!=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|ahd_set_modes
argument_list|(
name|ahd
argument_list|,
name|AHD_MODE_SCSI
argument_list|,
name|AHD_MODE_SCSI
argument_list|)
expr_stmt|;
name|packetized
operator|=
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|LQISTAT2
argument_list|)
operator|&
name|PACKETIZED
expr_stmt|;
block|}
name|ahd_restore_modes
argument_list|(
name|ahd
argument_list|,
name|saved_modes
argument_list|)
expr_stmt|;
return|return
operator|(
name|packetized
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|int
name|ahd_set_active_fifo
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|)
block|{
name|u_int
name|active_fifo
decl_stmt|;
name|AHD_ASSERT_MODES
argument_list|(
name|ahd
argument_list|,
name|AHD_MODE_SCSI_MSK
argument_list|,
name|AHD_MODE_SCSI_MSK
argument_list|)
expr_stmt|;
name|active_fifo
operator|=
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|DFFSTAT
argument_list|)
operator|&
name|CURRFIFO
expr_stmt|;
switch|switch
condition|(
name|active_fifo
condition|)
block|{
case|case
literal|0
case|:
case|case
literal|1
case|:
name|ahd_set_modes
argument_list|(
name|ahd
argument_list|,
name|active_fifo
argument_list|,
name|active_fifo
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
default|default:
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/************************* Sequencer Execution Control ************************/
end_comment

begin_comment
comment|/*  * Restart the sequencer program from address zero  */
end_comment

begin_function
name|void
name|ahd_restart
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|)
block|{
name|ahd_pause
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
name|ahd_set_modes
argument_list|(
name|ahd
argument_list|,
name|AHD_MODE_SCSI
argument_list|,
name|AHD_MODE_SCSI
argument_list|)
expr_stmt|;
comment|/* No more pending messages */
name|ahd_clear_msg_state
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|SCSISIGO
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* De-assert BSY */
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|MSG_OUT
argument_list|,
name|MSG_NOOP
argument_list|)
expr_stmt|;
comment|/* No message to send */
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|SXFRCTL1
argument_list|,
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|SXFRCTL1
argument_list|)
operator|&
operator|~
name|BITBUCKET
argument_list|)
expr_stmt|;
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|SEQINTCTL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|LASTPHASE
argument_list|,
name|P_BUSFREE
argument_list|)
expr_stmt|;
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|SEQ_FLAGS
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|SAVED_SCSIID
argument_list|,
literal|0xFF
argument_list|)
expr_stmt|;
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|SAVED_LUN
argument_list|,
literal|0xFF
argument_list|)
expr_stmt|;
comment|/* 	 * Ensure that the sequencer's idea of TQINPOS 	 * matches our own.  The sequencer increments TQINPOS 	 * only after it sees a DMA complete and a reset could 	 * occur before the increment leaving the kernel to believe 	 * the command arrived but the sequencer to not. 	 */
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|TQINPOS
argument_list|,
name|ahd
operator|->
name|tqinfifonext
argument_list|)
expr_stmt|;
comment|/* Always allow reselection */
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|SCSISEQ1
argument_list|,
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|SCSISEQ_TEMPLATE
argument_list|)
operator|&
operator|(
name|ENSELI
operator||
name|ENRSELI
operator||
name|ENAUTOATNP
operator|)
argument_list|)
expr_stmt|;
name|ahd_set_modes
argument_list|(
name|ahd
argument_list|,
name|AHD_MODE_CCHAN
argument_list|,
name|AHD_MODE_CCHAN
argument_list|)
expr_stmt|;
comment|/* 	 * Clear any pending sequencer interrupt.  It is no 	 * longer relevant since we're resetting the Program 	 * Counter. 	 */
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|CLRINT
argument_list|,
name|CLRSEQINT
argument_list|)
expr_stmt|;
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|SEQCTL0
argument_list|,
name|FASTMODE
operator||
name|SEQRESET
argument_list|)
expr_stmt|;
name|ahd_unpause
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ahd_clear_fifo
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|,
name|u_int
name|fifo
parameter_list|)
block|{
name|ahd_mode_state
name|saved_modes
decl_stmt|;
ifdef|#
directive|ifdef
name|AHD_DEBUG
if|if
condition|(
operator|(
name|ahd_debug
operator|&
name|AHD_SHOW_FIFOS
operator|)
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|"%s: Clearing FIFO %d\n"
argument_list|,
name|ahd_name
argument_list|(
name|ahd
argument_list|)
argument_list|,
name|fifo
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|saved_modes
operator|=
name|ahd_save_modes
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
name|ahd_set_modes
argument_list|(
name|ahd
argument_list|,
name|fifo
argument_list|,
name|fifo
argument_list|)
expr_stmt|;
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|DFFSXFRCTL
argument_list|,
name|RSTCHN
operator||
name|CLRSHCNT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|SG_STATE
argument_list|)
operator|&
name|FETCH_INPROG
operator|)
operator|!=
literal|0
condition|)
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|CCSGCTL
argument_list|,
name|CCSGRESET
argument_list|)
expr_stmt|;
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|LONGJMP_ADDR
operator|+
literal|1
argument_list|,
name|INVALID_ADDR
argument_list|)
expr_stmt|;
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|SG_STATE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ahd_restore_modes
argument_list|(
name|ahd
argument_list|,
name|saved_modes
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/************************* Input/Output Queues ********************************/
end_comment

begin_comment
comment|/*  * Flush and completed commands that are sitting in the command  * complete queues down on the chip but have yet to be dma'ed back up.  */
end_comment

begin_function
name|void
name|ahd_flush_qoutfifo
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|)
block|{
name|struct
name|scb
modifier|*
name|scb
decl_stmt|;
name|ahd_mode_state
name|saved_modes
decl_stmt|;
name|u_int
name|saved_scbptr
decl_stmt|;
name|u_int
name|ccscbctl
decl_stmt|;
name|u_int
name|scbid
decl_stmt|;
name|u_int
name|next_scbid
decl_stmt|;
name|saved_modes
operator|=
name|ahd_save_modes
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
comment|/* 	 * Flush the good status FIFO for completed packetized commands. 	 */
name|ahd_set_modes
argument_list|(
name|ahd
argument_list|,
name|AHD_MODE_SCSI
argument_list|,
name|AHD_MODE_SCSI
argument_list|)
expr_stmt|;
name|saved_scbptr
operator|=
name|ahd_get_scbptr
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|LQISTAT2
argument_list|)
operator|&
name|LQIGSAVAIL
operator|)
operator|!=
literal|0
condition|)
block|{
name|u_int
name|fifo_mode
decl_stmt|;
name|u_int
name|i
decl_stmt|;
name|scbid
operator|=
name|ahd_inw
argument_list|(
name|ahd
argument_list|,
name|GSFIFO
argument_list|)
expr_stmt|;
name|scb
operator|=
name|ahd_lookup_scb
argument_list|(
name|ahd
argument_list|,
name|scbid
argument_list|)
expr_stmt|;
if|if
condition|(
name|scb
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"%s: Warning - GSFIFO SCB %d invalid\n"
argument_list|,
name|ahd_name
argument_list|(
name|ahd
argument_list|)
argument_list|,
name|scbid
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * Determine if this transaction is still active in 		 * any FIFO.  If it is, we must flush that FIFO to 		 * the host before completing the  command. 		 */
name|fifo_mode
operator|=
literal|0
expr_stmt|;
name|rescan_fifos
label|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
name|i
operator|++
control|)
block|{
comment|/* Toggle to the other mode. */
name|fifo_mode
operator|^=
literal|1
expr_stmt|;
name|ahd_set_modes
argument_list|(
name|ahd
argument_list|,
name|fifo_mode
argument_list|,
name|fifo_mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|ahd_scb_active_in_fifo
argument_list|(
name|ahd
argument_list|,
name|scb
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
name|ahd_run_data_fifo
argument_list|(
name|ahd
argument_list|,
name|scb
argument_list|)
expr_stmt|;
comment|/* 			 * Running this FIFO may cause a CFG4DATA for 			 * this same transaction to assert in the other 			 * FIFO or a new snapshot SAVEPTRS interrupt 			 * in this FIFO.  Even running a FIFO may not 			 * clear the transaction if we are still waiting 			 * for data to drain to the host. We must loop 			 * until the transaction is not active in either 			 * FIFO just to be sure.  Reset our loop counter 			 * so we will visit both FIFOs again before 			 * declaring this transaction finished.  We 			 * also delay a bit so that status has a chance 			 * to change before we look at this FIFO again. 			 */
name|aic_delay
argument_list|(
literal|200
argument_list|)
expr_stmt|;
goto|goto
name|rescan_fifos
goto|;
block|}
name|ahd_set_modes
argument_list|(
name|ahd
argument_list|,
name|AHD_MODE_SCSI
argument_list|,
name|AHD_MODE_SCSI
argument_list|)
expr_stmt|;
name|ahd_set_scbptr
argument_list|(
name|ahd
argument_list|,
name|scbid
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ahd_inb_scbram
argument_list|(
name|ahd
argument_list|,
name|SCB_SGPTR
argument_list|)
operator|&
name|SG_LIST_NULL
operator|)
operator|==
literal|0
operator|&&
operator|(
operator|(
name|ahd_inb_scbram
argument_list|(
name|ahd
argument_list|,
name|SCB_SGPTR
argument_list|)
operator|&
name|SG_FULL_RESID
operator|)
operator|!=
literal|0
operator|||
operator|(
name|ahd_inb_scbram
argument_list|(
name|ahd
argument_list|,
name|SCB_RESIDUAL_SGPTR
argument_list|)
operator|&
name|SG_LIST_NULL
operator|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|u_int
name|comp_head
decl_stmt|;
comment|/* 			 * The transfer completed with a residual. 			 * Place this SCB on the complete DMA list 			 * so that we update our in-core copy of the 			 * SCB before completing the command. 			 */
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|SCB_SCSI_STATUS
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|SCB_SGPTR
argument_list|,
name|ahd_inb_scbram
argument_list|(
name|ahd
argument_list|,
name|SCB_SGPTR
argument_list|)
operator||
name|SG_STATUS_VALID
argument_list|)
expr_stmt|;
name|ahd_outw
argument_list|(
name|ahd
argument_list|,
name|SCB_TAG
argument_list|,
name|scbid
argument_list|)
expr_stmt|;
name|ahd_outw
argument_list|(
name|ahd
argument_list|,
name|SCB_NEXT_COMPLETE
argument_list|,
name|SCB_LIST_NULL
argument_list|)
expr_stmt|;
name|comp_head
operator|=
name|ahd_inw
argument_list|(
name|ahd
argument_list|,
name|COMPLETE_DMA_SCB_HEAD
argument_list|)
expr_stmt|;
if|if
condition|(
name|SCBID_IS_NULL
argument_list|(
name|comp_head
argument_list|)
condition|)
block|{
name|ahd_outw
argument_list|(
name|ahd
argument_list|,
name|COMPLETE_DMA_SCB_HEAD
argument_list|,
name|scbid
argument_list|)
expr_stmt|;
name|ahd_outw
argument_list|(
name|ahd
argument_list|,
name|COMPLETE_DMA_SCB_TAIL
argument_list|,
name|scbid
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|u_int
name|tail
decl_stmt|;
name|tail
operator|=
name|ahd_inw
argument_list|(
name|ahd
argument_list|,
name|COMPLETE_DMA_SCB_TAIL
argument_list|)
expr_stmt|;
name|ahd_set_scbptr
argument_list|(
name|ahd
argument_list|,
name|tail
argument_list|)
expr_stmt|;
name|ahd_outw
argument_list|(
name|ahd
argument_list|,
name|SCB_NEXT_COMPLETE
argument_list|,
name|scbid
argument_list|)
expr_stmt|;
name|ahd_outw
argument_list|(
name|ahd
argument_list|,
name|COMPLETE_DMA_SCB_TAIL
argument_list|,
name|scbid
argument_list|)
expr_stmt|;
name|ahd_set_scbptr
argument_list|(
name|ahd
argument_list|,
name|scbid
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|ahd_complete_scb
argument_list|(
name|ahd
argument_list|,
name|scb
argument_list|)
expr_stmt|;
block|}
name|ahd_set_scbptr
argument_list|(
name|ahd
argument_list|,
name|saved_scbptr
argument_list|)
expr_stmt|;
comment|/* 	 * Setup for command channel portion of flush. 	 */
name|ahd_set_modes
argument_list|(
name|ahd
argument_list|,
name|AHD_MODE_CCHAN
argument_list|,
name|AHD_MODE_CCHAN
argument_list|)
expr_stmt|;
comment|/* 	 * Wait for any inprogress DMA to complete and clear DMA state 	 * if this if for an SCB in the qinfifo. 	 */
while|while
condition|(
operator|(
operator|(
name|ccscbctl
operator|=
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|CCSCBCTL
argument_list|)
operator|)
operator|&
operator|(
name|CCARREN
operator||
name|CCSCBEN
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|ccscbctl
operator|&
operator|(
name|CCSCBDIR
operator||
name|CCARREN
operator|)
operator|)
operator|==
operator|(
name|CCSCBDIR
operator||
name|CCARREN
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|ccscbctl
operator|&
name|ARRDONE
operator|)
operator|!=
literal|0
condition|)
break|break;
block|}
elseif|else
if|if
condition|(
operator|(
name|ccscbctl
operator|&
name|CCSCBDONE
operator|)
operator|!=
literal|0
condition|)
break|break;
name|aic_delay
argument_list|(
literal|200
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * We leave the sequencer to cleanup in the case of DMA's to 	 * update the qoutfifo.  In all other cases (DMA's to the 	 * chip or a push of an SCB from the COMPLETE_DMA_SCB list), 	 * we disable the DMA engine so that the sequencer will not 	 * attempt to handle the DMA completion. 	 */
if|if
condition|(
operator|(
name|ccscbctl
operator|&
name|CCSCBDIR
operator|)
operator|!=
literal|0
operator|||
operator|(
name|ccscbctl
operator|&
name|ARRDONE
operator|)
operator|!=
literal|0
condition|)
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|CCSCBCTL
argument_list|,
name|ccscbctl
operator|&
operator|~
operator|(
name|CCARREN
operator||
name|CCSCBEN
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Complete any SCBs that just finished 	 * being DMA'ed into the qoutfifo. 	 */
name|ahd_run_qoutfifo
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
name|saved_scbptr
operator|=
name|ahd_get_scbptr
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
comment|/* 	 * Manually update/complete any completed SCBs that are waiting to be 	 * DMA'ed back up to the host. 	 */
name|scbid
operator|=
name|ahd_inw
argument_list|(
name|ahd
argument_list|,
name|COMPLETE_DMA_SCB_HEAD
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|SCBID_IS_NULL
argument_list|(
name|scbid
argument_list|)
condition|)
block|{
name|uint8_t
modifier|*
name|hscb_ptr
decl_stmt|;
name|u_int
name|i
decl_stmt|;
name|ahd_set_scbptr
argument_list|(
name|ahd
argument_list|,
name|scbid
argument_list|)
expr_stmt|;
name|next_scbid
operator|=
name|ahd_inw_scbram
argument_list|(
name|ahd
argument_list|,
name|SCB_NEXT_COMPLETE
argument_list|)
expr_stmt|;
name|scb
operator|=
name|ahd_lookup_scb
argument_list|(
name|ahd
argument_list|,
name|scbid
argument_list|)
expr_stmt|;
if|if
condition|(
name|scb
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"%s: Warning - DMA-up and complete "
literal|"SCB %d invalid\n"
argument_list|,
name|ahd_name
argument_list|(
name|ahd
argument_list|)
argument_list|,
name|scbid
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|hscb_ptr
operator|=
operator|(
name|uint8_t
operator|*
operator|)
name|scb
operator|->
name|hscb
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|hardware_scb
argument_list|)
condition|;
name|i
operator|++
control|)
operator|*
name|hscb_ptr
operator|++
operator|=
name|ahd_inb_scbram
argument_list|(
name|ahd
argument_list|,
name|SCB_BASE
operator|+
name|i
argument_list|)
expr_stmt|;
name|ahd_complete_scb
argument_list|(
name|ahd
argument_list|,
name|scb
argument_list|)
expr_stmt|;
name|scbid
operator|=
name|next_scbid
expr_stmt|;
block|}
name|ahd_outw
argument_list|(
name|ahd
argument_list|,
name|COMPLETE_DMA_SCB_HEAD
argument_list|,
name|SCB_LIST_NULL
argument_list|)
expr_stmt|;
name|ahd_outw
argument_list|(
name|ahd
argument_list|,
name|COMPLETE_DMA_SCB_TAIL
argument_list|,
name|SCB_LIST_NULL
argument_list|)
expr_stmt|;
name|scbid
operator|=
name|ahd_inw
argument_list|(
name|ahd
argument_list|,
name|COMPLETE_ON_QFREEZE_HEAD
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|SCBID_IS_NULL
argument_list|(
name|scbid
argument_list|)
condition|)
block|{
name|ahd_set_scbptr
argument_list|(
name|ahd
argument_list|,
name|scbid
argument_list|)
expr_stmt|;
name|next_scbid
operator|=
name|ahd_inw_scbram
argument_list|(
name|ahd
argument_list|,
name|SCB_NEXT_COMPLETE
argument_list|)
expr_stmt|;
name|scb
operator|=
name|ahd_lookup_scb
argument_list|(
name|ahd
argument_list|,
name|scbid
argument_list|)
expr_stmt|;
if|if
condition|(
name|scb
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"%s: Warning - Complete Qfrz SCB %d invalid\n"
argument_list|,
name|ahd_name
argument_list|(
name|ahd
argument_list|)
argument_list|,
name|scbid
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|ahd_complete_scb
argument_list|(
name|ahd
argument_list|,
name|scb
argument_list|)
expr_stmt|;
name|scbid
operator|=
name|next_scbid
expr_stmt|;
block|}
name|ahd_outw
argument_list|(
name|ahd
argument_list|,
name|COMPLETE_ON_QFREEZE_HEAD
argument_list|,
name|SCB_LIST_NULL
argument_list|)
expr_stmt|;
name|scbid
operator|=
name|ahd_inw
argument_list|(
name|ahd
argument_list|,
name|COMPLETE_SCB_HEAD
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|SCBID_IS_NULL
argument_list|(
name|scbid
argument_list|)
condition|)
block|{
name|ahd_set_scbptr
argument_list|(
name|ahd
argument_list|,
name|scbid
argument_list|)
expr_stmt|;
name|next_scbid
operator|=
name|ahd_inw_scbram
argument_list|(
name|ahd
argument_list|,
name|SCB_NEXT_COMPLETE
argument_list|)
expr_stmt|;
name|scb
operator|=
name|ahd_lookup_scb
argument_list|(
name|ahd
argument_list|,
name|scbid
argument_list|)
expr_stmt|;
if|if
condition|(
name|scb
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"%s: Warning - Complete SCB %d invalid\n"
argument_list|,
name|ahd_name
argument_list|(
name|ahd
argument_list|)
argument_list|,
name|scbid
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|ahd_complete_scb
argument_list|(
name|ahd
argument_list|,
name|scb
argument_list|)
expr_stmt|;
name|scbid
operator|=
name|next_scbid
expr_stmt|;
block|}
name|ahd_outw
argument_list|(
name|ahd
argument_list|,
name|COMPLETE_SCB_HEAD
argument_list|,
name|SCB_LIST_NULL
argument_list|)
expr_stmt|;
comment|/* 	 * Restore state. 	 */
name|ahd_set_scbptr
argument_list|(
name|ahd
argument_list|,
name|saved_scbptr
argument_list|)
expr_stmt|;
name|ahd_restore_modes
argument_list|(
name|ahd
argument_list|,
name|saved_modes
argument_list|)
expr_stmt|;
name|ahd
operator|->
name|flags
operator||=
name|AHD_UPDATE_PEND_CMDS
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Determine if an SCB for a packetized transaction  * is active in a FIFO.  */
end_comment

begin_function
specifier|static
name|int
name|ahd_scb_active_in_fifo
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|,
name|struct
name|scb
modifier|*
name|scb
parameter_list|)
block|{
comment|/* 	 * The FIFO is only active for our transaction if 	 * the SCBPTR matches the SCB's ID and the firmware 	 * has installed a handler for the FIFO or we have 	 * a pending SAVEPTRS or CFG4DATA interrupt. 	 */
if|if
condition|(
name|ahd_get_scbptr
argument_list|(
name|ahd
argument_list|)
operator|!=
name|SCB_GET_TAG
argument_list|(
name|scb
argument_list|)
operator|||
operator|(
operator|(
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|LONGJMP_ADDR
operator|+
literal|1
argument_list|)
operator|&
name|INVALID_ADDR
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|SEQINTSRC
argument_list|)
operator|&
operator|(
name|CFG4DATA
operator||
name|SAVEPTRS
operator|)
operator|)
operator|==
literal|0
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Run a data fifo to completion for a transaction we know  * has completed across the SCSI bus (good status has been  * received).  We are already set to the correct FIFO mode  * on entry to this routine.  *  * This function attempts to operate exactly as the firmware  * would when running this FIFO.  Care must be taken to update  * this routine any time the firmware's FIFO algorithm is  * changed.  */
end_comment

begin_function
specifier|static
name|void
name|ahd_run_data_fifo
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|,
name|struct
name|scb
modifier|*
name|scb
parameter_list|)
block|{
name|u_int
name|seqintsrc
decl_stmt|;
name|seqintsrc
operator|=
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|SEQINTSRC
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|seqintsrc
operator|&
name|CFG4DATA
operator|)
operator|!=
literal|0
condition|)
block|{
name|uint32_t
name|datacnt
decl_stmt|;
name|uint32_t
name|sgptr
decl_stmt|;
comment|/* 		 * Clear full residual flag. 		 */
name|sgptr
operator|=
name|ahd_inl_scbram
argument_list|(
name|ahd
argument_list|,
name|SCB_SGPTR
argument_list|)
operator|&
operator|~
name|SG_FULL_RESID
expr_stmt|;
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|SCB_SGPTR
argument_list|,
name|sgptr
argument_list|)
expr_stmt|;
comment|/* 		 * Load datacnt and address. 		 */
name|datacnt
operator|=
name|ahd_inl_scbram
argument_list|(
name|ahd
argument_list|,
name|SCB_DATACNT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|datacnt
operator|&
name|AHD_DMA_LAST_SEG
operator|)
operator|!=
literal|0
condition|)
block|{
name|sgptr
operator||=
name|LAST_SEG
expr_stmt|;
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|SG_STATE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|SG_STATE
argument_list|,
name|LOADING_NEEDED
argument_list|)
expr_stmt|;
name|ahd_outq
argument_list|(
name|ahd
argument_list|,
name|HADDR
argument_list|,
name|ahd_inq_scbram
argument_list|(
name|ahd
argument_list|,
name|SCB_DATAPTR
argument_list|)
argument_list|)
expr_stmt|;
name|ahd_outl
argument_list|(
name|ahd
argument_list|,
name|HCNT
argument_list|,
name|datacnt
operator|&
name|AHD_SG_LEN_MASK
argument_list|)
expr_stmt|;
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|SG_CACHE_PRE
argument_list|,
name|sgptr
argument_list|)
expr_stmt|;
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|DFCNTRL
argument_list|,
name|PRELOADEN
operator||
name|SCSIEN
operator||
name|HDMAEN
argument_list|)
expr_stmt|;
comment|/* 		 * Initialize Residual Fields. 		 */
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|SCB_RESIDUAL_DATACNT
operator|+
literal|3
argument_list|,
name|datacnt
operator|>>
literal|24
argument_list|)
expr_stmt|;
name|ahd_outl
argument_list|(
name|ahd
argument_list|,
name|SCB_RESIDUAL_SGPTR
argument_list|,
name|sgptr
operator|&
name|SG_PTR_MASK
argument_list|)
expr_stmt|;
comment|/* 		 * Mark the SCB as having a FIFO in use. 		 */
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|SCB_FIFO_USE_COUNT
argument_list|,
name|ahd_inb_scbram
argument_list|(
name|ahd
argument_list|,
name|SCB_FIFO_USE_COUNT
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* 		 * Install a "fake" handler for this FIFO. 		 */
name|ahd_outw
argument_list|(
name|ahd
argument_list|,
name|LONGJMP_ADDR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 		 * Notify the hardware that we have satisfied 		 * this sequencer interrupt. 		 */
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|CLRSEQINTSRC
argument_list|,
name|CLRCFG4DATA
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|seqintsrc
operator|&
name|SAVEPTRS
operator|)
operator|!=
literal|0
condition|)
block|{
name|uint32_t
name|sgptr
decl_stmt|;
name|uint32_t
name|resid
decl_stmt|;
if|if
condition|(
operator|(
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|LONGJMP_ADDR
operator|+
literal|1
argument_list|)
operator|&
name|INVALID_ADDR
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* 			 * Snapshot Save Pointers.  All that 			 * is necessary to clear the snapshot 			 * is a CLRCHN. 			 */
goto|goto
name|clrchn
goto|;
block|}
comment|/* 		 * Disable S/G fetch so the DMA engine 		 * is available to future users. 		 */
if|if
condition|(
operator|(
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|SG_STATE
argument_list|)
operator|&
name|FETCH_INPROG
operator|)
operator|!=
literal|0
condition|)
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|CCSGCTL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|SG_STATE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 		 * Flush the data FIFO.  Strickly only 		 * necessary for Rev A parts. 		 */
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|DFCNTRL
argument_list|,
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|DFCNTRL
argument_list|)
operator||
name|FIFOFLUSH
argument_list|)
expr_stmt|;
comment|/* 		 * Calculate residual. 		 */
name|sgptr
operator|=
name|ahd_inl_scbram
argument_list|(
name|ahd
argument_list|,
name|SCB_RESIDUAL_SGPTR
argument_list|)
expr_stmt|;
name|resid
operator|=
name|ahd_inl
argument_list|(
name|ahd
argument_list|,
name|SHCNT
argument_list|)
expr_stmt|;
name|resid
operator||=
name|ahd_inb_scbram
argument_list|(
name|ahd
argument_list|,
name|SCB_RESIDUAL_DATACNT
operator|+
literal|3
argument_list|)
operator|<<
literal|24
expr_stmt|;
name|ahd_outl
argument_list|(
name|ahd
argument_list|,
name|SCB_RESIDUAL_DATACNT
argument_list|,
name|resid
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|SG_CACHE_SHADOW
argument_list|)
operator|&
name|LAST_SEG
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 			 * Must back up to the correct S/G element. 			 * Typically this just means resetting our 			 * low byte to the offset in the SG_CACHE, 			 * but if we wrapped, we have to correct 			 * the other bytes of the sgptr too. 			 */
if|if
condition|(
operator|(
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|SG_CACHE_SHADOW
argument_list|)
operator|&
literal|0x80
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|sgptr
operator|&
literal|0x80
operator|)
operator|==
literal|0
condition|)
name|sgptr
operator|-=
literal|0x100
expr_stmt|;
name|sgptr
operator|&=
operator|~
literal|0xFF
expr_stmt|;
name|sgptr
operator||=
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|SG_CACHE_SHADOW
argument_list|)
operator|&
name|SG_ADDR_MASK
expr_stmt|;
name|ahd_outl
argument_list|(
name|ahd
argument_list|,
name|SCB_RESIDUAL_SGPTR
argument_list|,
name|sgptr
argument_list|)
expr_stmt|;
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|SCB_RESIDUAL_DATACNT
operator|+
literal|3
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|resid
operator|&
name|AHD_SG_LEN_MASK
operator|)
operator|==
literal|0
condition|)
block|{
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|SCB_RESIDUAL_SGPTR
argument_list|,
name|sgptr
operator||
name|SG_LIST_NULL
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Save Pointers. 		 */
name|ahd_outq
argument_list|(
name|ahd
argument_list|,
name|SCB_DATAPTR
argument_list|,
name|ahd_inq
argument_list|(
name|ahd
argument_list|,
name|SHADDR
argument_list|)
argument_list|)
expr_stmt|;
name|ahd_outl
argument_list|(
name|ahd
argument_list|,
name|SCB_DATACNT
argument_list|,
name|resid
argument_list|)
expr_stmt|;
name|ahd_outl
argument_list|(
name|ahd
argument_list|,
name|SCB_SGPTR
argument_list|,
name|sgptr
argument_list|)
expr_stmt|;
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|CLRSEQINTSRC
argument_list|,
name|CLRSAVEPTRS
argument_list|)
expr_stmt|;
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|SEQIMODE
argument_list|,
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|SEQIMODE
argument_list|)
operator||
name|ENSAVEPTRS
argument_list|)
expr_stmt|;
comment|/* 		 * If the data is to the SCSI bus, we are 		 * done, otherwise wait for FIFOEMP. 		 */
if|if
condition|(
operator|(
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|DFCNTRL
argument_list|)
operator|&
name|DIRECTION
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|clrchn
goto|;
block|}
elseif|else
if|if
condition|(
operator|(
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|SG_STATE
argument_list|)
operator|&
name|LOADING_NEEDED
operator|)
operator|!=
literal|0
condition|)
block|{
name|uint32_t
name|sgptr
decl_stmt|;
name|uint64_t
name|data_addr
decl_stmt|;
name|uint32_t
name|data_len
decl_stmt|;
name|u_int
name|dfcntrl
decl_stmt|;
comment|/* 		 * Disable S/G fetch so the DMA engine 		 * is available to future users.  We won't 		 * be using the DMA engine to load segments. 		 */
if|if
condition|(
operator|(
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|SG_STATE
argument_list|)
operator|&
name|FETCH_INPROG
operator|)
operator|!=
literal|0
condition|)
block|{
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|CCSGCTL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|SG_STATE
argument_list|,
name|LOADING_NEEDED
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Wait for the DMA engine to notice that the 		 * host transfer is enabled and that there is 		 * space in the S/G FIFO for new segments before 		 * loading more segments. 		 */
if|if
condition|(
operator|(
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|DFSTATUS
argument_list|)
operator|&
name|PRELOAD_AVAIL
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|DFCNTRL
argument_list|)
operator|&
name|HDMAENACK
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* 			 * Determine the offset of the next S/G 			 * element to load. 			 */
name|sgptr
operator|=
name|ahd_inl_scbram
argument_list|(
name|ahd
argument_list|,
name|SCB_RESIDUAL_SGPTR
argument_list|)
expr_stmt|;
name|sgptr
operator|&=
name|SG_PTR_MASK
expr_stmt|;
if|if
condition|(
operator|(
name|ahd
operator|->
name|flags
operator|&
name|AHD_64BIT_ADDRESSING
operator|)
operator|!=
literal|0
condition|)
block|{
name|struct
name|ahd_dma64_seg
modifier|*
name|sg
decl_stmt|;
name|sg
operator|=
name|ahd_sg_bus_to_virt
argument_list|(
name|ahd
argument_list|,
name|scb
argument_list|,
name|sgptr
argument_list|)
expr_stmt|;
name|data_addr
operator|=
name|sg
operator|->
name|addr
expr_stmt|;
name|data_len
operator|=
name|sg
operator|->
name|len
expr_stmt|;
name|sgptr
operator|+=
sizeof|sizeof
argument_list|(
operator|*
name|sg
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|struct
name|ahd_dma_seg
modifier|*
name|sg
decl_stmt|;
name|sg
operator|=
name|ahd_sg_bus_to_virt
argument_list|(
name|ahd
argument_list|,
name|scb
argument_list|,
name|sgptr
argument_list|)
expr_stmt|;
name|data_addr
operator|=
name|sg
operator|->
name|len
operator|&
name|AHD_SG_HIGH_ADDR_MASK
expr_stmt|;
name|data_addr
operator|<<=
literal|8
expr_stmt|;
name|data_addr
operator||=
name|sg
operator|->
name|addr
expr_stmt|;
name|data_len
operator|=
name|sg
operator|->
name|len
expr_stmt|;
name|sgptr
operator|+=
sizeof|sizeof
argument_list|(
operator|*
name|sg
argument_list|)
expr_stmt|;
block|}
comment|/* 			 * Update residual information. 			 */
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|SCB_RESIDUAL_DATACNT
operator|+
literal|3
argument_list|,
name|data_len
operator|>>
literal|24
argument_list|)
expr_stmt|;
name|ahd_outl
argument_list|(
name|ahd
argument_list|,
name|SCB_RESIDUAL_SGPTR
argument_list|,
name|sgptr
argument_list|)
expr_stmt|;
comment|/* 			 * Load the S/G. 			 */
if|if
condition|(
name|data_len
operator|&
name|AHD_DMA_LAST_SEG
condition|)
block|{
name|sgptr
operator||=
name|LAST_SEG
expr_stmt|;
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|SG_STATE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|ahd_outq
argument_list|(
name|ahd
argument_list|,
name|HADDR
argument_list|,
name|data_addr
argument_list|)
expr_stmt|;
name|ahd_outl
argument_list|(
name|ahd
argument_list|,
name|HCNT
argument_list|,
name|data_len
operator|&
name|AHD_SG_LEN_MASK
argument_list|)
expr_stmt|;
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|SG_CACHE_PRE
argument_list|,
name|sgptr
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
comment|/* 			 * Advertise the segment to the hardware. 			 */
name|dfcntrl
operator|=
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|DFCNTRL
argument_list|)
operator||
name|PRELOADEN
operator||
name|HDMAEN
expr_stmt|;
if|if
condition|(
operator|(
name|ahd
operator|->
name|features
operator|&
name|AHD_NEW_DFCNTRL_OPTS
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* 				 * Use SCSIENWRDIS so that SCSIEN 				 * is never modified by this 				 * operation. 				 */
name|dfcntrl
operator||=
name|SCSIENWRDIS
expr_stmt|;
block|}
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|DFCNTRL
argument_list|,
name|dfcntrl
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|SG_CACHE_SHADOW
argument_list|)
operator|&
name|LAST_SEG_DONE
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * Transfer completed to the end of SG list 		 * and has flushed to the host. 		 */
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|SCB_SGPTR
argument_list|,
name|ahd_inb_scbram
argument_list|(
name|ahd
argument_list|,
name|SCB_SGPTR
argument_list|)
operator||
name|SG_LIST_NULL
argument_list|)
expr_stmt|;
goto|goto
name|clrchn
goto|;
block|}
elseif|else
if|if
condition|(
operator|(
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|DFSTATUS
argument_list|)
operator|&
name|FIFOEMP
operator|)
operator|!=
literal|0
condition|)
block|{
name|clrchn
label|:
comment|/* 		 * Clear any handler for this FIFO, decrement 		 * the FIFO use count for the SCB, and release 		 * the FIFO. 		 */
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|LONGJMP_ADDR
operator|+
literal|1
argument_list|,
name|INVALID_ADDR
argument_list|)
expr_stmt|;
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|SCB_FIFO_USE_COUNT
argument_list|,
name|ahd_inb_scbram
argument_list|(
name|ahd
argument_list|,
name|SCB_FIFO_USE_COUNT
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|DFFSXFRCTL
argument_list|,
name|CLRCHN
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Look for entries in the QoutFIFO that have completed.  * The valid_tag completion field indicates the validity  * of the entry - the valid value toggles each time through  * the queue. We use the sg_status field in the completion  * entry to avoid referencing the hscb if the completion  * occurred with no errors and no residual.  sg_status is  * a copy of the first byte (little endian) of the sgptr  * hscb field.  */
end_comment

begin_function
name|void
name|ahd_run_qoutfifo
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|)
block|{
name|struct
name|ahd_completion
modifier|*
name|completion
decl_stmt|;
name|struct
name|scb
modifier|*
name|scb
decl_stmt|;
name|u_int
name|scb_index
decl_stmt|;
if|if
condition|(
operator|(
name|ahd
operator|->
name|flags
operator|&
name|AHD_RUNNING_QOUTFIFO
operator|)
operator|!=
literal|0
condition|)
name|panic
argument_list|(
literal|"ahd_run_qoutfifo recursion"
argument_list|)
expr_stmt|;
name|ahd
operator|->
name|flags
operator||=
name|AHD_RUNNING_QOUTFIFO
expr_stmt|;
name|ahd_sync_qoutfifo
argument_list|(
name|ahd
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|completion
operator|=
operator|&
name|ahd
operator|->
name|qoutfifo
index|[
name|ahd
operator|->
name|qoutfifonext
index|]
expr_stmt|;
if|if
condition|(
name|completion
operator|->
name|valid_tag
operator|!=
name|ahd
operator|->
name|qoutfifonext_valid_tag
condition|)
break|break;
name|scb_index
operator|=
name|aic_le16toh
argument_list|(
name|completion
operator|->
name|tag
argument_list|)
expr_stmt|;
name|scb
operator|=
name|ahd_lookup_scb
argument_list|(
name|ahd
argument_list|,
name|scb_index
argument_list|)
expr_stmt|;
if|if
condition|(
name|scb
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"%s: WARNING no command for scb %d "
literal|"(cmdcmplt)\nQOUTPOS = %d\n"
argument_list|,
name|ahd_name
argument_list|(
name|ahd
argument_list|)
argument_list|,
name|scb_index
argument_list|,
name|ahd
operator|->
name|qoutfifonext
argument_list|)
expr_stmt|;
name|ahd_dump_card_state
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|completion
operator|->
name|sg_status
operator|&
name|SG_STATUS_VALID
operator|)
operator|!=
literal|0
condition|)
block|{
name|ahd_handle_scb_status
argument_list|(
name|ahd
argument_list|,
name|scb
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ahd_done
argument_list|(
name|ahd
argument_list|,
name|scb
argument_list|)
expr_stmt|;
block|}
name|ahd
operator|->
name|qoutfifonext
operator|=
operator|(
name|ahd
operator|->
name|qoutfifonext
operator|+
literal|1
operator|)
operator|&
operator|(
name|AHD_QOUT_SIZE
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|ahd
operator|->
name|qoutfifonext
operator|==
literal|0
condition|)
name|ahd
operator|->
name|qoutfifonext_valid_tag
operator|^=
name|QOUTFIFO_ENTRY_VALID
expr_stmt|;
block|}
name|ahd
operator|->
name|flags
operator|&=
operator|~
name|AHD_RUNNING_QOUTFIFO
expr_stmt|;
block|}
end_function

begin_comment
comment|/************************* Interrupt Handling *********************************/
end_comment

begin_function
name|void
name|ahd_handle_hwerrint
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|)
block|{
comment|/* 	 * Some catastrophic hardware error has occurred. 	 * Print it for the user and disable the controller. 	 */
name|int
name|i
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|ERROR
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_errors
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|error
operator|&
name|ahd_hard_errors
index|[
name|i
index|]
operator|.
name|errno
operator|)
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|"%s: hwerrint, %s\n"
argument_list|,
name|ahd_name
argument_list|(
name|ahd
argument_list|)
argument_list|,
name|ahd_hard_errors
index|[
name|i
index|]
operator|.
name|errmesg
argument_list|)
expr_stmt|;
block|}
name|ahd_dump_card_state
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"BRKADRINT"
argument_list|)
expr_stmt|;
comment|/* Tell everyone that this HBA is no longer available */
name|ahd_abort_scbs
argument_list|(
name|ahd
argument_list|,
name|CAM_TARGET_WILDCARD
argument_list|,
name|ALL_CHANNELS
argument_list|,
name|CAM_LUN_WILDCARD
argument_list|,
name|SCB_LIST_NULL
argument_list|,
name|ROLE_UNKNOWN
argument_list|,
name|CAM_NO_HBA
argument_list|)
expr_stmt|;
comment|/* Tell the system that this controller has gone away. */
name|ahd_free
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ahd_handle_seqint
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|,
name|u_int
name|intstat
parameter_list|)
block|{
name|u_int
name|seqintcode
decl_stmt|;
comment|/* 	 * Save the sequencer interrupt code and clear the SEQINT 	 * bit. We will unpause the sequencer, if appropriate, 	 * after servicing the request. 	 */
name|seqintcode
operator|=
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|SEQINTCODE
argument_list|)
expr_stmt|;
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|CLRINT
argument_list|,
name|CLRSEQINT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ahd
operator|->
name|bugs
operator|&
name|AHD_INTCOLLISION_BUG
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * Unpause the sequencer and let it clear 		 * SEQINT by writing NO_SEQINT to it.  This 		 * will cause the sequencer to be paused again, 		 * which is the expected state of this routine. 		 */
name|ahd_unpause
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|ahd_is_paused
argument_list|(
name|ahd
argument_list|)
condition|)
empty_stmt|;
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|CLRINT
argument_list|,
name|CLRSEQINT
argument_list|)
expr_stmt|;
block|}
name|ahd_update_modes
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|AHD_DEBUG
if|if
condition|(
operator|(
name|ahd_debug
operator|&
name|AHD_SHOW_MISC
operator|)
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|"%s: Handle Seqint Called for code %d\n"
argument_list|,
name|ahd_name
argument_list|(
name|ahd
argument_list|)
argument_list|,
name|seqintcode
argument_list|)
expr_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|seqintcode
condition|)
block|{
case|case
name|ENTERING_NONPACK
case|:
block|{
name|struct
name|scb
modifier|*
name|scb
decl_stmt|;
name|u_int
name|scbid
decl_stmt|;
name|AHD_ASSERT_MODES
argument_list|(
name|ahd
argument_list|,
operator|~
operator|(
name|AHD_MODE_UNKNOWN_MSK
operator||
name|AHD_MODE_CFG_MSK
operator|)
argument_list|,
operator|~
operator|(
name|AHD_MODE_UNKNOWN_MSK
operator||
name|AHD_MODE_CFG_MSK
operator|)
argument_list|)
expr_stmt|;
name|scbid
operator|=
name|ahd_get_scbptr
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
name|scb
operator|=
name|ahd_lookup_scb
argument_list|(
name|ahd
argument_list|,
name|scbid
argument_list|)
expr_stmt|;
if|if
condition|(
name|scb
operator|==
name|NULL
condition|)
block|{
comment|/* 			 * Somehow need to know if this 			 * is from a selection or reselection. 			 * From that, we can determine target 			 * ID so we at least have an I_T nexus. 			 */
block|}
else|else
block|{
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|SAVED_SCSIID
argument_list|,
name|scb
operator|->
name|hscb
operator|->
name|scsiid
argument_list|)
expr_stmt|;
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|SAVED_LUN
argument_list|,
name|scb
operator|->
name|hscb
operator|->
name|lun
argument_list|)
expr_stmt|;
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|SEQ_FLAGS
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|LQISTAT2
argument_list|)
operator|&
name|LQIPHASE_OUTPKT
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|SCSISIGO
argument_list|)
operator|&
name|ATNO
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* 			 * Phase change after read stream with 			 * CRC error with P0 asserted on last 			 * packet. 			 */
ifdef|#
directive|ifdef
name|AHD_DEBUG
if|if
condition|(
operator|(
name|ahd_debug
operator|&
name|AHD_SHOW_RECOVERY
operator|)
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|"%s: Assuming LQIPHASE_NLQ with "
literal|"P0 assertion\n"
argument_list|,
name|ahd_name
argument_list|(
name|ahd
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
ifdef|#
directive|ifdef
name|AHD_DEBUG
if|if
condition|(
operator|(
name|ahd_debug
operator|&
name|AHD_SHOW_RECOVERY
operator|)
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|"%s: Entering NONPACK\n"
argument_list|,
name|ahd_name
argument_list|(
name|ahd
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
block|}
case|case
name|INVALID_SEQINT
case|:
name|printf
argument_list|(
literal|"%s: Invalid Sequencer interrupt occurred.\n"
argument_list|,
name|ahd_name
argument_list|(
name|ahd
argument_list|)
argument_list|)
expr_stmt|;
name|ahd_dump_card_state
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
name|ahd_reset_channel
argument_list|(
name|ahd
argument_list|,
literal|'A'
argument_list|,
comment|/*Initiate Reset*/
name|TRUE
argument_list|)
expr_stmt|;
break|break;
case|case
name|STATUS_OVERRUN
case|:
block|{
name|struct
name|scb
modifier|*
name|scb
decl_stmt|;
name|u_int
name|scbid
decl_stmt|;
name|scbid
operator|=
name|ahd_get_scbptr
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
name|scb
operator|=
name|ahd_lookup_scb
argument_list|(
name|ahd
argument_list|,
name|scbid
argument_list|)
expr_stmt|;
if|if
condition|(
name|scb
operator|!=
name|NULL
condition|)
name|ahd_print_path
argument_list|(
name|ahd
argument_list|,
name|scb
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"%s: "
argument_list|,
name|ahd_name
argument_list|(
name|ahd
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"SCB %d Packetized Status Overrun"
argument_list|,
name|scbid
argument_list|)
expr_stmt|;
name|ahd_dump_card_state
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
name|ahd_reset_channel
argument_list|(
name|ahd
argument_list|,
literal|'A'
argument_list|,
comment|/*Initiate Reset*/
name|TRUE
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|CFG4ISTAT_INTR
case|:
block|{
name|struct
name|scb
modifier|*
name|scb
decl_stmt|;
name|u_int
name|scbid
decl_stmt|;
name|scbid
operator|=
name|ahd_get_scbptr
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
name|scb
operator|=
name|ahd_lookup_scb
argument_list|(
name|ahd
argument_list|,
name|scbid
argument_list|)
expr_stmt|;
if|if
condition|(
name|scb
operator|==
name|NULL
condition|)
block|{
name|ahd_dump_card_state
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"CFG4ISTAT: Free SCB %d referenced"
argument_list|,
name|scbid
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"For safety"
argument_list|)
expr_stmt|;
block|}
name|ahd_outq
argument_list|(
name|ahd
argument_list|,
name|HADDR
argument_list|,
name|scb
operator|->
name|sense_busaddr
argument_list|)
expr_stmt|;
name|ahd_outw
argument_list|(
name|ahd
argument_list|,
name|HCNT
argument_list|,
name|AHD_SENSE_BUFSIZE
argument_list|)
expr_stmt|;
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|HCNT
operator|+
literal|2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|SG_CACHE_PRE
argument_list|,
name|SG_LAST_SEG
argument_list|)
expr_stmt|;
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|DFCNTRL
argument_list|,
name|PRELOADEN
operator||
name|SCSIEN
operator||
name|HDMAEN
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|ILLEGAL_PHASE
case|:
block|{
name|u_int
name|bus_phase
decl_stmt|;
name|bus_phase
operator|=
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|SCSISIGI
argument_list|)
operator|&
name|PHASE_MASK
expr_stmt|;
name|printf
argument_list|(
literal|"%s: ILLEGAL_PHASE 0x%x\n"
argument_list|,
name|ahd_name
argument_list|(
name|ahd
argument_list|)
argument_list|,
name|bus_phase
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|bus_phase
condition|)
block|{
case|case
name|P_DATAOUT
case|:
case|case
name|P_DATAIN
case|:
case|case
name|P_DATAOUT_DT
case|:
case|case
name|P_DATAIN_DT
case|:
case|case
name|P_MESGOUT
case|:
case|case
name|P_STATUS
case|:
case|case
name|P_MESGIN
case|:
name|ahd_reset_channel
argument_list|(
name|ahd
argument_list|,
literal|'A'
argument_list|,
comment|/*Initiate Reset*/
name|TRUE
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s: Issued Bus Reset.\n"
argument_list|,
name|ahd_name
argument_list|(
name|ahd
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|P_COMMAND
case|:
block|{
name|struct
name|ahd_devinfo
name|devinfo
decl_stmt|;
name|struct
name|scb
modifier|*
name|scb
decl_stmt|;
name|struct
name|ahd_initiator_tinfo
modifier|*
name|targ_info
decl_stmt|;
name|struct
name|ahd_tmode_tstate
modifier|*
name|tstate
decl_stmt|;
name|struct
name|ahd_transinfo
modifier|*
name|tinfo
decl_stmt|;
name|u_int
name|scbid
decl_stmt|;
comment|/* 			 * If a target takes us into the command phase 			 * assume that it has been externally reset and 			 * has thus lost our previous packetized negotiation 			 * agreement.  Since we have not sent an identify 			 * message and may not have fully qualified the 			 * connection, we change our command to TUR, assert 			 * ATN and ABORT the task when we go to message in 			 * phase.  The OSM will see the REQUEUE_REQUEST 			 * status and retry the command. 			 */
name|scbid
operator|=
name|ahd_get_scbptr
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
name|scb
operator|=
name|ahd_lookup_scb
argument_list|(
name|ahd
argument_list|,
name|scbid
argument_list|)
expr_stmt|;
if|if
condition|(
name|scb
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"Invalid phase with no valid SCB.  "
literal|"Resetting bus.\n"
argument_list|)
expr_stmt|;
name|ahd_reset_channel
argument_list|(
name|ahd
argument_list|,
literal|'A'
argument_list|,
comment|/*Initiate Reset*/
name|TRUE
argument_list|)
expr_stmt|;
break|break;
block|}
name|ahd_compile_devinfo
argument_list|(
operator|&
name|devinfo
argument_list|,
name|SCB_GET_OUR_ID
argument_list|(
name|scb
argument_list|)
argument_list|,
name|SCB_GET_TARGET
argument_list|(
name|ahd
argument_list|,
name|scb
argument_list|)
argument_list|,
name|SCB_GET_LUN
argument_list|(
name|scb
argument_list|)
argument_list|,
name|SCB_GET_CHANNEL
argument_list|(
name|ahd
argument_list|,
name|scb
argument_list|)
argument_list|,
name|ROLE_INITIATOR
argument_list|)
expr_stmt|;
name|targ_info
operator|=
name|ahd_fetch_transinfo
argument_list|(
name|ahd
argument_list|,
name|devinfo
operator|.
name|channel
argument_list|,
name|devinfo
operator|.
name|our_scsiid
argument_list|,
name|devinfo
operator|.
name|target
argument_list|,
operator|&
name|tstate
argument_list|)
expr_stmt|;
name|tinfo
operator|=
operator|&
name|targ_info
operator|->
name|curr
expr_stmt|;
name|ahd_set_width
argument_list|(
name|ahd
argument_list|,
operator|&
name|devinfo
argument_list|,
name|MSG_EXT_WDTR_BUS_8_BIT
argument_list|,
name|AHD_TRANS_ACTIVE
argument_list|,
comment|/*paused*/
name|TRUE
argument_list|)
expr_stmt|;
name|ahd_set_syncrate
argument_list|(
name|ahd
argument_list|,
operator|&
name|devinfo
argument_list|,
comment|/*period*/
literal|0
argument_list|,
comment|/*offset*/
literal|0
argument_list|,
comment|/*ppr_options*/
literal|0
argument_list|,
name|AHD_TRANS_ACTIVE
argument_list|,
comment|/*paused*/
name|TRUE
argument_list|)
expr_stmt|;
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|SCB_CDB_STORE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|SCB_CDB_STORE
operator|+
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|SCB_CDB_STORE
operator|+
literal|2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|SCB_CDB_STORE
operator|+
literal|3
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|SCB_CDB_STORE
operator|+
literal|4
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|SCB_CDB_STORE
operator|+
literal|5
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|SCB_CDB_LEN
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|scb
operator|->
name|hscb
operator|->
name|control
operator|&=
operator|~
operator|(
name|TAG_ENB
operator||
name|SCB_TAG_TYPE
operator|)
expr_stmt|;
name|scb
operator|->
name|hscb
operator|->
name|control
operator||=
name|MK_MESSAGE
expr_stmt|;
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|SCB_CONTROL
argument_list|,
name|scb
operator|->
name|hscb
operator|->
name|control
argument_list|)
expr_stmt|;
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|MSG_OUT
argument_list|,
name|HOST_MSG
argument_list|)
expr_stmt|;
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|SAVED_SCSIID
argument_list|,
name|scb
operator|->
name|hscb
operator|->
name|scsiid
argument_list|)
expr_stmt|;
comment|/* 			 * The lun is 0, regardless of the SCB's lun 			 * as we have not sent an identify message. 			 */
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|SAVED_LUN
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|SEQ_FLAGS
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ahd_assert_atn
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
name|scb
operator|->
name|flags
operator|&=
operator|~
name|SCB_PACKETIZED
expr_stmt|;
name|scb
operator|->
name|flags
operator||=
name|SCB_ABORT
operator||
name|SCB_CMDPHASE_ABORT
expr_stmt|;
name|ahd_freeze_devq
argument_list|(
name|ahd
argument_list|,
name|scb
argument_list|)
expr_stmt|;
name|aic_set_transaction_status
argument_list|(
name|scb
argument_list|,
name|CAM_REQUEUE_REQ
argument_list|)
expr_stmt|;
name|aic_freeze_scb
argument_list|(
name|scb
argument_list|)
expr_stmt|;
comment|/* 			 * Allow the sequencer to continue with 			 * non-pack processing. 			 */
name|ahd_set_modes
argument_list|(
name|ahd
argument_list|,
name|AHD_MODE_SCSI
argument_list|,
name|AHD_MODE_SCSI
argument_list|)
expr_stmt|;
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|CLRLQOINT1
argument_list|,
name|CLRLQOPHACHGINPKT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ahd
operator|->
name|bugs
operator|&
name|AHD_CLRLQO_AUTOCLR_BUG
operator|)
operator|!=
literal|0
condition|)
block|{
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|CLRLQOINT1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|AHD_DEBUG
if|if
condition|(
operator|(
name|ahd_debug
operator|&
name|AHD_SHOW_RECOVERY
operator|)
operator|!=
literal|0
condition|)
block|{
name|ahd_print_path
argument_list|(
name|ahd
argument_list|,
name|scb
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Unexpected command phase from "
literal|"packetized target\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
break|break;
block|}
block|}
break|break;
block|}
case|case
name|CFG4OVERRUN
case|:
block|{
name|struct
name|scb
modifier|*
name|scb
decl_stmt|;
name|u_int
name|scb_index
decl_stmt|;
ifdef|#
directive|ifdef
name|AHD_DEBUG
if|if
condition|(
operator|(
name|ahd_debug
operator|&
name|AHD_SHOW_RECOVERY
operator|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%s: CFG4OVERRUN mode = %x\n"
argument_list|,
name|ahd_name
argument_list|(
name|ahd
argument_list|)
argument_list|,
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|MODE_PTR
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|scb_index
operator|=
name|ahd_get_scbptr
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
name|scb
operator|=
name|ahd_lookup_scb
argument_list|(
name|ahd
argument_list|,
name|scb_index
argument_list|)
expr_stmt|;
if|if
condition|(
name|scb
operator|==
name|NULL
condition|)
block|{
comment|/* 			 * Attempt to transfer to an SCB that is 			 * not outstanding. 			 */
name|ahd_assert_atn
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|MSG_OUT
argument_list|,
name|HOST_MSG
argument_list|)
expr_stmt|;
name|ahd
operator|->
name|msgout_buf
index|[
literal|0
index|]
operator|=
name|MSG_ABORT_TASK
expr_stmt|;
name|ahd
operator|->
name|msgout_len
operator|=
literal|1
expr_stmt|;
name|ahd
operator|->
name|msgout_index
operator|=
literal|0
expr_stmt|;
name|ahd
operator|->
name|msg_type
operator|=
name|MSG_TYPE_INITIATOR_MSGOUT
expr_stmt|;
comment|/* 			 * Clear status received flag to prevent any 			 * attempt to complete this bogus SCB. 			 */
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|SCB_CONTROL
argument_list|,
name|ahd_inb_scbram
argument_list|(
name|ahd
argument_list|,
name|SCB_CONTROL
argument_list|)
operator|&
operator|~
name|STATUS_RCVD
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|DUMP_CARD_STATE
case|:
block|{
name|ahd_dump_card_state
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|PDATA_REINIT
case|:
block|{
ifdef|#
directive|ifdef
name|AHD_DEBUG
if|if
condition|(
operator|(
name|ahd_debug
operator|&
name|AHD_SHOW_RECOVERY
operator|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%s: PDATA_REINIT - DFCNTRL = 0x%x "
literal|"SG_CACHE_SHADOW = 0x%x\n"
argument_list|,
name|ahd_name
argument_list|(
name|ahd
argument_list|)
argument_list|,
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|DFCNTRL
argument_list|)
argument_list|,
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|SG_CACHE_SHADOW
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|ahd_reinitialize_dataptrs
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|HOST_MSG_LOOP
case|:
block|{
name|struct
name|ahd_devinfo
name|devinfo
decl_stmt|;
comment|/* 		 * The sequencer has encountered a message phase 		 * that requires host assistance for completion. 		 * While handling the message phase(s), we will be 		 * notified by the sequencer after each byte is 		 * transfered so we can track bus phase changes. 		 * 		 * If this is the first time we've seen a HOST_MSG_LOOP 		 * interrupt, initialize the state of the host message 		 * loop. 		 */
name|ahd_fetch_devinfo
argument_list|(
name|ahd
argument_list|,
operator|&
name|devinfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|ahd
operator|->
name|msg_type
operator|==
name|MSG_TYPE_NONE
condition|)
block|{
name|struct
name|scb
modifier|*
name|scb
decl_stmt|;
name|u_int
name|scb_index
decl_stmt|;
name|u_int
name|bus_phase
decl_stmt|;
name|bus_phase
operator|=
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|SCSISIGI
argument_list|)
operator|&
name|PHASE_MASK
expr_stmt|;
if|if
condition|(
name|bus_phase
operator|!=
name|P_MESGIN
operator|&&
name|bus_phase
operator|!=
name|P_MESGOUT
condition|)
block|{
name|printf
argument_list|(
literal|"ahd_intr: HOST_MSG_LOOP bad "
literal|"phase 0x%x\n"
argument_list|,
name|bus_phase
argument_list|)
expr_stmt|;
comment|/* 				 * Probably transitioned to bus free before 				 * we got here.  Just punt the message. 				 */
name|ahd_dump_card_state
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
name|ahd_clear_intstat
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
name|ahd_restart
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
return|return;
block|}
name|scb_index
operator|=
name|ahd_get_scbptr
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
name|scb
operator|=
name|ahd_lookup_scb
argument_list|(
name|ahd
argument_list|,
name|scb_index
argument_list|)
expr_stmt|;
if|if
condition|(
name|devinfo
operator|.
name|role
operator|==
name|ROLE_INITIATOR
condition|)
block|{
if|if
condition|(
name|bus_phase
operator|==
name|P_MESGOUT
condition|)
name|ahd_setup_initiator_msgout
argument_list|(
name|ahd
argument_list|,
operator|&
name|devinfo
argument_list|,
name|scb
argument_list|)
expr_stmt|;
else|else
block|{
name|ahd
operator|->
name|msg_type
operator|=
name|MSG_TYPE_INITIATOR_MSGIN
expr_stmt|;
name|ahd
operator|->
name|msgin_index
operator|=
literal|0
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|AHD_TARGET_MODE
else|else
block|{
if|if
condition|(
name|bus_phase
operator|==
name|P_MESGOUT
condition|)
block|{
name|ahd
operator|->
name|msg_type
operator|=
name|MSG_TYPE_TARGET_MSGOUT
expr_stmt|;
name|ahd
operator|->
name|msgin_index
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|ahd_setup_target_msgin
argument_list|(
name|ahd
argument_list|,
operator|&
name|devinfo
argument_list|,
name|scb
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
name|ahd_handle_message_phase
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|NO_MATCH
case|:
block|{
comment|/* Ensure we don't leave the selection hardware on */
name|AHD_ASSERT_MODES
argument_list|(
name|ahd
argument_list|,
name|AHD_MODE_SCSI_MSK
argument_list|,
name|AHD_MODE_SCSI_MSK
argument_list|)
expr_stmt|;
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|SCSISEQ0
argument_list|,
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|SCSISEQ0
argument_list|)
operator|&
operator|~
name|ENSELO
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s:%c:%d: no active SCB for reconnecting "
literal|"target - issuing BUS DEVICE RESET\n"
argument_list|,
name|ahd_name
argument_list|(
name|ahd
argument_list|)
argument_list|,
literal|'A'
argument_list|,
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|SELID
argument_list|)
operator|>>
literal|4
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"SAVED_SCSIID == 0x%x, SAVED_LUN == 0x%x, "
literal|"REG0 == 0x%x ACCUM = 0x%x\n"
argument_list|,
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|SAVED_SCSIID
argument_list|)
argument_list|,
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|SAVED_LUN
argument_list|)
argument_list|,
name|ahd_inw
argument_list|(
name|ahd
argument_list|,
name|REG0
argument_list|)
argument_list|,
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|ACCUM
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"SEQ_FLAGS == 0x%x, SCBPTR == 0x%x, BTT == 0x%x, "
literal|"SINDEX == 0x%x\n"
argument_list|,
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|SEQ_FLAGS
argument_list|)
argument_list|,
name|ahd_get_scbptr
argument_list|(
name|ahd
argument_list|)
argument_list|,
name|ahd_find_busy_tcl
argument_list|(
name|ahd
argument_list|,
name|BUILD_TCL
argument_list|(
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|SAVED_SCSIID
argument_list|)
argument_list|,
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|SAVED_LUN
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|ahd_inw
argument_list|(
name|ahd
argument_list|,
name|SINDEX
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"SELID == 0x%x, SCB_SCSIID == 0x%x, SCB_LUN == 0x%x, "
literal|"SCB_CONTROL == 0x%x\n"
argument_list|,
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|SELID
argument_list|)
argument_list|,
name|ahd_inb_scbram
argument_list|(
name|ahd
argument_list|,
name|SCB_SCSIID
argument_list|)
argument_list|,
name|ahd_inb_scbram
argument_list|(
name|ahd
argument_list|,
name|SCB_LUN
argument_list|)
argument_list|,
name|ahd_inb_scbram
argument_list|(
name|ahd
argument_list|,
name|SCB_CONTROL
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"SCSIBUS[0] == 0x%x, SCSISIGI == 0x%x\n"
argument_list|,
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|SCSIBUS
argument_list|)
argument_list|,
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|SCSISIGI
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"SXFRCTL0 == 0x%x\n"
argument_list|,
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|SXFRCTL0
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"SEQCTL0 == 0x%x\n"
argument_list|,
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|SEQCTL0
argument_list|)
argument_list|)
expr_stmt|;
name|ahd_dump_card_state
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
name|ahd
operator|->
name|msgout_buf
index|[
literal|0
index|]
operator|=
name|MSG_BUS_DEV_RESET
expr_stmt|;
name|ahd
operator|->
name|msgout_len
operator|=
literal|1
expr_stmt|;
name|ahd
operator|->
name|msgout_index
operator|=
literal|0
expr_stmt|;
name|ahd
operator|->
name|msg_type
operator|=
name|MSG_TYPE_INITIATOR_MSGOUT
expr_stmt|;
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|MSG_OUT
argument_list|,
name|HOST_MSG
argument_list|)
expr_stmt|;
name|ahd_assert_atn
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|PROTO_VIOLATION
case|:
block|{
name|ahd_handle_proto_violation
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|IGN_WIDE_RES
case|:
block|{
name|struct
name|ahd_devinfo
name|devinfo
decl_stmt|;
name|ahd_fetch_devinfo
argument_list|(
name|ahd
argument_list|,
operator|&
name|devinfo
argument_list|)
expr_stmt|;
name|ahd_handle_ign_wide_residue
argument_list|(
name|ahd
argument_list|,
operator|&
name|devinfo
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|BAD_PHASE
case|:
block|{
name|u_int
name|lastphase
decl_stmt|;
name|lastphase
operator|=
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|LASTPHASE
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s:%c:%d: unknown scsi bus phase %x, "
literal|"lastphase = 0x%x.  Attempting to continue\n"
argument_list|,
name|ahd_name
argument_list|(
name|ahd
argument_list|)
argument_list|,
literal|'A'
argument_list|,
name|SCSIID_TARGET
argument_list|(
name|ahd
argument_list|,
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|SAVED_SCSIID
argument_list|)
argument_list|)
argument_list|,
name|lastphase
argument_list|,
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|SCSISIGI
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|MISSED_BUSFREE
case|:
block|{
name|u_int
name|lastphase
decl_stmt|;
name|lastphase
operator|=
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|LASTPHASE
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s:%c:%d: Missed busfree. "
literal|"Lastphase = 0x%x, Curphase = 0x%x\n"
argument_list|,
name|ahd_name
argument_list|(
name|ahd
argument_list|)
argument_list|,
literal|'A'
argument_list|,
name|SCSIID_TARGET
argument_list|(
name|ahd
argument_list|,
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|SAVED_SCSIID
argument_list|)
argument_list|)
argument_list|,
name|lastphase
argument_list|,
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|SCSISIGI
argument_list|)
argument_list|)
expr_stmt|;
name|ahd_restart
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
return|return;
block|}
case|case
name|DATA_OVERRUN
case|:
block|{
comment|/* 		 * When the sequencer detects an overrun, it 		 * places the controller in "BITBUCKET" mode 		 * and allows the target to complete its transfer. 		 * Unfortunately, none of the counters get updated 		 * when the controller is in this mode, so we have 		 * no way of knowing how large the overrun was. 		 */
name|struct
name|scb
modifier|*
name|scb
decl_stmt|;
name|u_int
name|scbindex
decl_stmt|;
ifdef|#
directive|ifdef
name|AHD_DEBUG
name|u_int
name|lastphase
decl_stmt|;
endif|#
directive|endif
name|scbindex
operator|=
name|ahd_get_scbptr
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
name|scb
operator|=
name|ahd_lookup_scb
argument_list|(
name|ahd
argument_list|,
name|scbindex
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|AHD_DEBUG
name|lastphase
operator|=
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|LASTPHASE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ahd_debug
operator|&
name|AHD_SHOW_RECOVERY
operator|)
operator|!=
literal|0
condition|)
block|{
name|ahd_print_path
argument_list|(
name|ahd
argument_list|,
name|scb
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"data overrun detected %s.  Tag == 0x%x.\n"
argument_list|,
name|ahd_lookup_phase_entry
argument_list|(
name|lastphase
argument_list|)
operator|->
name|phasemsg
argument_list|,
name|SCB_GET_TAG
argument_list|(
name|scb
argument_list|)
argument_list|)
expr_stmt|;
name|ahd_print_path
argument_list|(
name|ahd
argument_list|,
name|scb
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s seen Data Phase.  Length = %ld.  "
literal|"NumSGs = %d.\n"
argument_list|,
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|SEQ_FLAGS
argument_list|)
operator|&
name|DPHASE
condition|?
literal|"Have"
else|:
literal|"Haven't"
argument_list|,
name|aic_get_transfer_length
argument_list|(
name|scb
argument_list|)
argument_list|,
name|scb
operator|->
name|sg_count
argument_list|)
expr_stmt|;
name|ahd_dump_sglist
argument_list|(
name|scb
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* 		 * Set this and it will take effect when the 		 * target does a command complete. 		 */
name|ahd_freeze_devq
argument_list|(
name|ahd
argument_list|,
name|scb
argument_list|)
expr_stmt|;
name|aic_set_transaction_status
argument_list|(
name|scb
argument_list|,
name|CAM_DATA_RUN_ERR
argument_list|)
expr_stmt|;
name|aic_freeze_scb
argument_list|(
name|scb
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|MKMSG_FAILED
case|:
block|{
name|struct
name|ahd_devinfo
name|devinfo
decl_stmt|;
name|struct
name|scb
modifier|*
name|scb
decl_stmt|;
name|u_int
name|scbid
decl_stmt|;
name|ahd_fetch_devinfo
argument_list|(
name|ahd
argument_list|,
operator|&
name|devinfo
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s:%c:%d:%d: Attempt to issue message failed\n"
argument_list|,
name|ahd_name
argument_list|(
name|ahd
argument_list|)
argument_list|,
name|devinfo
operator|.
name|channel
argument_list|,
name|devinfo
operator|.
name|target
argument_list|,
name|devinfo
operator|.
name|lun
argument_list|)
expr_stmt|;
name|scbid
operator|=
name|ahd_get_scbptr
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
name|scb
operator|=
name|ahd_lookup_scb
argument_list|(
name|ahd
argument_list|,
name|scbid
argument_list|)
expr_stmt|;
if|if
condition|(
name|scb
operator|!=
name|NULL
operator|&&
operator|(
name|scb
operator|->
name|flags
operator|&
name|SCB_RECOVERY_SCB
operator|)
operator|!=
literal|0
condition|)
comment|/* 			 * Ensure that we didn't put a second instance of this 			 * SCB into the QINFIFO. 			 */
name|ahd_search_qinfifo
argument_list|(
name|ahd
argument_list|,
name|SCB_GET_TARGET
argument_list|(
name|ahd
argument_list|,
name|scb
argument_list|)
argument_list|,
name|SCB_GET_CHANNEL
argument_list|(
name|ahd
argument_list|,
name|scb
argument_list|)
argument_list|,
name|SCB_GET_LUN
argument_list|(
name|scb
argument_list|)
argument_list|,
name|SCB_GET_TAG
argument_list|(
name|scb
argument_list|)
argument_list|,
name|ROLE_INITIATOR
argument_list|,
comment|/*status*/
literal|0
argument_list|,
name|SEARCH_REMOVE
argument_list|)
expr_stmt|;
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|SCB_CONTROL
argument_list|,
name|ahd_inb_scbram
argument_list|(
name|ahd
argument_list|,
name|SCB_CONTROL
argument_list|)
operator|&
operator|~
name|MK_MESSAGE
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|TASKMGMT_FUNC_COMPLETE
case|:
block|{
name|u_int
name|scbid
decl_stmt|;
name|struct
name|scb
modifier|*
name|scb
decl_stmt|;
name|scbid
operator|=
name|ahd_get_scbptr
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
name|scb
operator|=
name|ahd_lookup_scb
argument_list|(
name|ahd
argument_list|,
name|scbid
argument_list|)
expr_stmt|;
if|if
condition|(
name|scb
operator|!=
name|NULL
condition|)
block|{
name|u_int
name|lun
decl_stmt|;
name|u_int
name|tag
decl_stmt|;
name|cam_status
name|error
decl_stmt|;
name|ahd_print_path
argument_list|(
name|ahd
argument_list|,
name|scb
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Task Management Func 0x%x Complete\n"
argument_list|,
name|scb
operator|->
name|hscb
operator|->
name|task_management
argument_list|)
expr_stmt|;
name|lun
operator|=
name|CAM_LUN_WILDCARD
expr_stmt|;
name|tag
operator|=
name|SCB_LIST_NULL
expr_stmt|;
switch|switch
condition|(
name|scb
operator|->
name|hscb
operator|->
name|task_management
condition|)
block|{
case|case
name|SIU_TASKMGMT_ABORT_TASK
case|:
name|tag
operator|=
name|SCB_GET_TAG
argument_list|(
name|scb
argument_list|)
expr_stmt|;
case|case
name|SIU_TASKMGMT_ABORT_TASK_SET
case|:
case|case
name|SIU_TASKMGMT_CLEAR_TASK_SET
case|:
name|lun
operator|=
name|scb
operator|->
name|hscb
operator|->
name|lun
expr_stmt|;
name|error
operator|=
name|CAM_REQ_ABORTED
expr_stmt|;
name|ahd_abort_scbs
argument_list|(
name|ahd
argument_list|,
name|SCB_GET_TARGET
argument_list|(
name|ahd
argument_list|,
name|scb
argument_list|)
argument_list|,
literal|'A'
argument_list|,
name|lun
argument_list|,
name|tag
argument_list|,
name|ROLE_INITIATOR
argument_list|,
name|error
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIU_TASKMGMT_LUN_RESET
case|:
name|lun
operator|=
name|scb
operator|->
name|hscb
operator|->
name|lun
expr_stmt|;
case|case
name|SIU_TASKMGMT_TARGET_RESET
case|:
block|{
name|struct
name|ahd_devinfo
name|devinfo
decl_stmt|;
name|ahd_scb_devinfo
argument_list|(
name|ahd
argument_list|,
operator|&
name|devinfo
argument_list|,
name|scb
argument_list|)
expr_stmt|;
name|error
operator|=
name|CAM_BDR_SENT
expr_stmt|;
name|ahd_handle_devreset
argument_list|(
name|ahd
argument_list|,
operator|&
name|devinfo
argument_list|,
name|lun
argument_list|,
name|CAM_BDR_SENT
argument_list|,
name|lun
operator|!=
name|CAM_LUN_WILDCARD
condition|?
literal|"Lun Reset"
else|:
literal|"Target Reset"
argument_list|,
comment|/*verbose_level*/
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
name|panic
argument_list|(
literal|"Unexpected TaskMgmt Func\n"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
break|break;
block|}
case|case
name|TASKMGMT_CMD_CMPLT_OKAY
case|:
block|{
name|u_int
name|scbid
decl_stmt|;
name|struct
name|scb
modifier|*
name|scb
decl_stmt|;
comment|/* 		 * An ABORT TASK TMF failed to be delivered before 		 * the targeted command completed normally. 		 */
name|scbid
operator|=
name|ahd_get_scbptr
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
name|scb
operator|=
name|ahd_lookup_scb
argument_list|(
name|ahd
argument_list|,
name|scbid
argument_list|)
expr_stmt|;
if|if
condition|(
name|scb
operator|!=
name|NULL
condition|)
block|{
comment|/* 			 * Remove the second instance of this SCB from 			 * the QINFIFO if it is still there.                          */
name|ahd_print_path
argument_list|(
name|ahd
argument_list|,
name|scb
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"SCB completes before TMF\n"
argument_list|)
expr_stmt|;
comment|/* 			 * Handle losing the race.  Wait until any 			 * current selection completes.  We will then 			 * set the TMF back to zero in this SCB so that 			 * the sequencer doesn't bother to issue another 			 * sequencer interrupt for its completion. 			 */
while|while
condition|(
operator|(
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|SCSISEQ0
argument_list|)
operator|&
name|ENSELO
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|SSTAT0
argument_list|)
operator|&
name|SELDO
operator|)
operator|==
literal|0
operator|&&
operator|(
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|SSTAT1
argument_list|)
operator|&
name|SELTO
operator|)
operator|==
literal|0
condition|)
empty_stmt|;
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|SCB_TASK_MANAGEMENT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ahd_search_qinfifo
argument_list|(
name|ahd
argument_list|,
name|SCB_GET_TARGET
argument_list|(
name|ahd
argument_list|,
name|scb
argument_list|)
argument_list|,
name|SCB_GET_CHANNEL
argument_list|(
name|ahd
argument_list|,
name|scb
argument_list|)
argument_list|,
name|SCB_GET_LUN
argument_list|(
name|scb
argument_list|)
argument_list|,
name|SCB_GET_TAG
argument_list|(
name|scb
argument_list|)
argument_list|,
name|ROLE_INITIATOR
argument_list|,
comment|/*status*/
literal|0
argument_list|,
name|SEARCH_REMOVE
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|TRACEPOINT0
case|:
case|case
name|TRACEPOINT1
case|:
case|case
name|TRACEPOINT2
case|:
case|case
name|TRACEPOINT3
case|:
name|printf
argument_list|(
literal|"%s: Tracepoint %d\n"
argument_list|,
name|ahd_name
argument_list|(
name|ahd
argument_list|)
argument_list|,
name|seqintcode
operator|-
name|TRACEPOINT0
argument_list|)
expr_stmt|;
break|break;
case|case
name|NO_SEQINT
case|:
break|break;
case|case
name|SAW_HWERR
case|:
name|ahd_handle_hwerrint
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"%s: Unexpected SEQINTCODE %d\n"
argument_list|,
name|ahd_name
argument_list|(
name|ahd
argument_list|)
argument_list|,
name|seqintcode
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* 	 *  The sequencer is paused immediately on 	 *  a SEQINT, so we should restart it when 	 *  we're done. 	 */
name|ahd_unpause
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ahd_handle_scsiint
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|,
name|u_int
name|intstat
parameter_list|)
block|{
name|struct
name|scb
modifier|*
name|scb
decl_stmt|;
name|u_int
name|status0
decl_stmt|;
name|u_int
name|status3
decl_stmt|;
name|u_int
name|status
decl_stmt|;
name|u_int
name|lqistat1
decl_stmt|;
name|u_int
name|lqostat0
decl_stmt|;
name|u_int
name|scbid
decl_stmt|;
name|u_int
name|busfreetime
decl_stmt|;
name|ahd_update_modes
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
name|ahd_set_modes
argument_list|(
name|ahd
argument_list|,
name|AHD_MODE_SCSI
argument_list|,
name|AHD_MODE_SCSI
argument_list|)
expr_stmt|;
name|status3
operator|=
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|SSTAT3
argument_list|)
operator|&
operator|(
name|NTRAMPERR
operator||
name|OSRAMPERR
operator|)
expr_stmt|;
name|status0
operator|=
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|SSTAT0
argument_list|)
operator|&
operator|(
name|IOERR
operator||
name|OVERRUN
operator||
name|SELDI
operator||
name|SELDO
operator|)
expr_stmt|;
name|status
operator|=
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|SSTAT1
argument_list|)
operator|&
operator|(
name|SELTO
operator||
name|SCSIRSTI
operator||
name|BUSFREE
operator||
name|SCSIPERR
operator|)
expr_stmt|;
name|lqistat1
operator|=
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|LQISTAT1
argument_list|)
expr_stmt|;
name|lqostat0
operator|=
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|LQOSTAT0
argument_list|)
expr_stmt|;
name|busfreetime
operator|=
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|SSTAT2
argument_list|)
operator|&
name|BUSFREETIME
expr_stmt|;
if|if
condition|(
operator|(
name|status0
operator|&
operator|(
name|SELDI
operator||
name|SELDO
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|u_int
name|simode0
decl_stmt|;
name|ahd_set_modes
argument_list|(
name|ahd
argument_list|,
name|AHD_MODE_CFG
argument_list|,
name|AHD_MODE_CFG
argument_list|)
expr_stmt|;
name|simode0
operator|=
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|SIMODE0
argument_list|)
expr_stmt|;
name|status0
operator|&=
name|simode0
operator|&
operator|(
name|IOERR
operator||
name|OVERRUN
operator||
name|SELDI
operator||
name|SELDO
operator|)
expr_stmt|;
name|ahd_set_modes
argument_list|(
name|ahd
argument_list|,
name|AHD_MODE_SCSI
argument_list|,
name|AHD_MODE_SCSI
argument_list|)
expr_stmt|;
block|}
name|scbid
operator|=
name|ahd_get_scbptr
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
name|scb
operator|=
name|ahd_lookup_scb
argument_list|(
name|ahd
argument_list|,
name|scbid
argument_list|)
expr_stmt|;
if|if
condition|(
name|scb
operator|!=
name|NULL
operator|&&
operator|(
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|SEQ_FLAGS
argument_list|)
operator|&
name|NOT_IDENTIFIED
operator|)
operator|!=
literal|0
condition|)
name|scb
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|status0
operator|&
name|IOERR
operator|)
operator|!=
literal|0
condition|)
block|{
name|u_int
name|now_lvd
decl_stmt|;
name|now_lvd
operator|=
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|SBLKCTL
argument_list|)
operator|&
name|ENAB40
expr_stmt|;
name|printf
argument_list|(
literal|"%s: Transceiver State Has Changed to %s mode\n"
argument_list|,
name|ahd_name
argument_list|(
name|ahd
argument_list|)
argument_list|,
name|now_lvd
condition|?
literal|"LVD"
else|:
literal|"SE"
argument_list|)
expr_stmt|;
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|CLRSINT0
argument_list|,
name|CLRIOERR
argument_list|)
expr_stmt|;
comment|/* 		 * A change in I/O mode is equivalent to a bus reset. 		 */
name|ahd_reset_channel
argument_list|(
name|ahd
argument_list|,
literal|'A'
argument_list|,
comment|/*Initiate Reset*/
name|TRUE
argument_list|)
expr_stmt|;
name|ahd_pause
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
name|ahd_setup_iocell_workaround
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
name|ahd_unpause
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|status0
operator|&
name|OVERRUN
operator|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%s: SCSI offset overrun detected.  Resetting bus.\n"
argument_list|,
name|ahd_name
argument_list|(
name|ahd
argument_list|)
argument_list|)
expr_stmt|;
name|ahd_reset_channel
argument_list|(
name|ahd
argument_list|,
literal|'A'
argument_list|,
comment|/*Initiate Reset*/
name|TRUE
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|status
operator|&
name|SCSIRSTI
operator|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%s: Someone reset channel A\n"
argument_list|,
name|ahd_name
argument_list|(
name|ahd
argument_list|)
argument_list|)
expr_stmt|;
name|ahd_reset_channel
argument_list|(
name|ahd
argument_list|,
literal|'A'
argument_list|,
comment|/*Initiate Reset*/
name|FALSE
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|status
operator|&
name|SCSIPERR
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* Make sure the sequencer is in a safe location. */
name|ahd_clear_critical_section
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
name|ahd_handle_transmission_error
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|lqostat0
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%s: lqostat0 == 0x%x!\n"
argument_list|,
name|ahd_name
argument_list|(
name|ahd
argument_list|)
argument_list|,
name|lqostat0
argument_list|)
expr_stmt|;
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|CLRLQOINT0
argument_list|,
name|lqostat0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ahd
operator|->
name|bugs
operator|&
name|AHD_CLRLQO_AUTOCLR_BUG
operator|)
operator|!=
literal|0
condition|)
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|CLRLQOINT1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|status
operator|&
name|SELTO
operator|)
operator|!=
literal|0
condition|)
block|{
name|u_int
name|scbid
decl_stmt|;
comment|/* Stop the selection */
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|SCSISEQ0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Make sure the sequencer is in a safe location. */
name|ahd_clear_critical_section
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
comment|/* No more pending messages */
name|ahd_clear_msg_state
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
comment|/* Clear interrupt state */
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|CLRSINT1
argument_list|,
name|CLRSELTIMEO
operator||
name|CLRBUSFREE
operator||
name|CLRSCSIPERR
argument_list|)
expr_stmt|;
comment|/* 		 * Although the driver does not care about the 		 * 'Selection in Progress' status bit, the busy 		 * LED does.  SELINGO is only cleared by a sucessfull 		 * selection, so we must manually clear it to insure 		 * the LED turns off just incase no future successful 		 * selections occur (e.g. no devices on the bus). 		 */
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|CLRSINT0
argument_list|,
name|CLRSELINGO
argument_list|)
expr_stmt|;
name|scbid
operator|=
name|ahd_inw
argument_list|(
name|ahd
argument_list|,
name|WAITING_TID_HEAD
argument_list|)
expr_stmt|;
name|scb
operator|=
name|ahd_lookup_scb
argument_list|(
name|ahd
argument_list|,
name|scbid
argument_list|)
expr_stmt|;
if|if
condition|(
name|scb
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"%s: ahd_intr - referenced scb not "
literal|"valid during SELTO scb(0x%x)\n"
argument_list|,
name|ahd_name
argument_list|(
name|ahd
argument_list|)
argument_list|,
name|scbid
argument_list|)
expr_stmt|;
name|ahd_dump_card_state
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|struct
name|ahd_devinfo
name|devinfo
decl_stmt|;
ifdef|#
directive|ifdef
name|AHD_DEBUG
if|if
condition|(
operator|(
name|ahd_debug
operator|&
name|AHD_SHOW_SELTO
operator|)
operator|!=
literal|0
condition|)
block|{
name|ahd_print_path
argument_list|(
name|ahd
argument_list|,
name|scb
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Saw Selection Timeout for SCB 0x%x\n"
argument_list|,
name|scbid
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|ahd_scb_devinfo
argument_list|(
name|ahd
argument_list|,
operator|&
name|devinfo
argument_list|,
name|scb
argument_list|)
expr_stmt|;
name|aic_set_transaction_status
argument_list|(
name|scb
argument_list|,
name|CAM_SEL_TIMEOUT
argument_list|)
expr_stmt|;
name|ahd_freeze_devq
argument_list|(
name|ahd
argument_list|,
name|scb
argument_list|)
expr_stmt|;
comment|/* 			 * Cancel any pending transactions on the device 			 * now that it seems to be missing.  This will 			 * also revert us to async/narrow transfers until 			 * we can renegotiate with the device. 			 */
name|ahd_handle_devreset
argument_list|(
name|ahd
argument_list|,
operator|&
name|devinfo
argument_list|,
name|CAM_LUN_WILDCARD
argument_list|,
name|CAM_SEL_TIMEOUT
argument_list|,
literal|"Selection Timeout"
argument_list|,
comment|/*verbose_level*/
literal|1
argument_list|)
expr_stmt|;
block|}
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|CLRINT
argument_list|,
name|CLRSCSIINT
argument_list|)
expr_stmt|;
name|ahd_iocell_first_selection
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
name|ahd_unpause
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|status0
operator|&
operator|(
name|SELDI
operator||
name|SELDO
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|ahd_iocell_first_selection
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
name|ahd_unpause
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|status3
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%s: SCSI Cell parity error SSTAT3 == 0x%x\n"
argument_list|,
name|ahd_name
argument_list|(
name|ahd
argument_list|)
argument_list|,
name|status3
argument_list|)
expr_stmt|;
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|CLRSINT3
argument_list|,
name|status3
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|lqistat1
operator|&
operator|(
name|LQIPHASE_LQ
operator||
name|LQIPHASE_NLQ
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* Make sure the sequencer is in a safe location. */
name|ahd_clear_critical_section
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
name|ahd_handle_lqiphase_error
argument_list|(
name|ahd
argument_list|,
name|lqistat1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|lqistat1
operator|&
name|LQICRCI_NLQ
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * This status can be delayed during some 		 * streaming operations.  The SCSIPHASE 		 * handler has already dealt with this case 		 * so just clear the error. 		 */
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|CLRLQIINT1
argument_list|,
name|CLRLQICRCI_NLQ
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|status
operator|&
name|BUSFREE
operator|)
operator|!=
literal|0
operator|||
operator|(
name|lqistat1
operator|&
name|LQOBUSFREE
operator|)
operator|!=
literal|0
condition|)
block|{
name|u_int
name|lqostat1
decl_stmt|;
name|int
name|restart
decl_stmt|;
name|int
name|clear_fifo
decl_stmt|;
name|int
name|packetized
decl_stmt|;
name|u_int
name|mode
decl_stmt|;
comment|/* 		 * Clear our selection hardware as soon as possible. 		 * We may have an entry in the waiting Q for this target, 		 * that is affected by this busfree and we don't want to 		 * go about selecting the target while we handle the event. 		 */
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|SCSISEQ0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Make sure the sequencer is in a safe location. */
name|ahd_clear_critical_section
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
comment|/* 		 * Determine what we were up to at the time of 		 * the busfree. 		 */
name|mode
operator|=
name|AHD_MODE_SCSI
expr_stmt|;
name|busfreetime
operator|=
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|SSTAT2
argument_list|)
operator|&
name|BUSFREETIME
expr_stmt|;
name|lqostat1
operator|=
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|LQOSTAT1
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|busfreetime
condition|)
block|{
case|case
name|BUSFREE_DFF0
case|:
case|case
name|BUSFREE_DFF1
case|:
block|{
name|u_int
name|scbid
decl_stmt|;
name|struct
name|scb
modifier|*
name|scb
decl_stmt|;
name|mode
operator|=
name|busfreetime
operator|==
name|BUSFREE_DFF0
condition|?
name|AHD_MODE_DFF0
else|:
name|AHD_MODE_DFF1
expr_stmt|;
name|ahd_set_modes
argument_list|(
name|ahd
argument_list|,
name|mode
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|scbid
operator|=
name|ahd_get_scbptr
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
name|scb
operator|=
name|ahd_lookup_scb
argument_list|(
name|ahd
argument_list|,
name|scbid
argument_list|)
expr_stmt|;
if|if
condition|(
name|scb
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"%s: Invalid SCB %d in DFF%d "
literal|"during unexpected busfree\n"
argument_list|,
name|ahd_name
argument_list|(
name|ahd
argument_list|)
argument_list|,
name|scbid
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|packetized
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|packetized
operator|=
operator|(
name|scb
operator|->
name|flags
operator|&
name|SCB_PACKETIZED
operator|)
operator|!=
literal|0
expr_stmt|;
name|clear_fifo
operator|=
literal|1
expr_stmt|;
break|break;
block|}
case|case
name|BUSFREE_LQO
case|:
name|clear_fifo
operator|=
literal|0
expr_stmt|;
name|packetized
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
name|clear_fifo
operator|=
literal|0
expr_stmt|;
name|packetized
operator|=
operator|(
name|lqostat1
operator|&
name|LQOBUSFREE
operator|)
operator|!=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|packetized
operator|&&
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|LASTPHASE
argument_list|)
operator|==
name|P_BUSFREE
operator|&&
operator|(
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|SSTAT0
argument_list|)
operator|&
name|SELDI
operator|)
operator|==
literal|0
operator|&&
operator|(
operator|(
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|SSTAT0
argument_list|)
operator|&
name|SELDO
operator|)
operator|==
literal|0
operator|||
operator|(
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|SCSISEQ0
argument_list|)
operator|&
name|ENSELO
operator|)
operator|==
literal|0
operator|)
condition|)
comment|/* 				 * Assume packetized if we are not 				 * on the bus in a non-packetized 				 * capacity and any pending selection 				 * was a packetized selection. 				 */
name|packetized
operator|=
literal|1
expr_stmt|;
break|break;
block|}
ifdef|#
directive|ifdef
name|AHD_DEBUG
if|if
condition|(
operator|(
name|ahd_debug
operator|&
name|AHD_SHOW_MISC
operator|)
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|"Saw Busfree.  Busfreetime = 0x%x.\n"
argument_list|,
name|busfreetime
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 		 * Busfrees that occur in non-packetized phases are 		 * handled by the nonpkt_busfree handler. 		 */
if|if
condition|(
name|packetized
operator|&&
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|LASTPHASE
argument_list|)
operator|==
name|P_BUSFREE
condition|)
block|{
name|restart
operator|=
name|ahd_handle_pkt_busfree
argument_list|(
name|ahd
argument_list|,
name|busfreetime
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|packetized
operator|=
literal|0
expr_stmt|;
name|restart
operator|=
name|ahd_handle_nonpkt_busfree
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Clear the busfree interrupt status.  The setting of 		 * the interrupt is a pulse, so in a perfect world, we 		 * would not need to muck with the ENBUSFREE logic.  This 		 * would ensure that if the bus moves on to another 		 * connection, busfree protection is still in force.  If 		 * BUSFREEREV is broken, however, we must manually clear 		 * the ENBUSFREE if the busfree occurred during a non-pack 		 * connection so that we don't get false positives during 		 * future, packetized, connections. 		 */
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|CLRSINT1
argument_list|,
name|CLRBUSFREE
argument_list|)
expr_stmt|;
if|if
condition|(
name|packetized
operator|==
literal|0
operator|&&
operator|(
name|ahd
operator|->
name|bugs
operator|&
name|AHD_BUSFREEREV_BUG
operator|)
operator|!=
literal|0
condition|)
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|SIMODE1
argument_list|,
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|SIMODE1
argument_list|)
operator|&
operator|~
name|ENBUSFREE
argument_list|)
expr_stmt|;
if|if
condition|(
name|clear_fifo
condition|)
name|ahd_clear_fifo
argument_list|(
name|ahd
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|ahd_clear_msg_state
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|CLRINT
argument_list|,
name|CLRSCSIINT
argument_list|)
expr_stmt|;
if|if
condition|(
name|restart
condition|)
block|{
name|ahd_restart
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ahd_unpause
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|printf
argument_list|(
literal|"%s: Missing case in ahd_handle_scsiint. status = %x\n"
argument_list|,
name|ahd_name
argument_list|(
name|ahd
argument_list|)
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|ahd_dump_card_state
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
name|ahd_clear_intstat
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
name|ahd_unpause
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ahd_handle_transmission_error
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|)
block|{
name|struct
name|scb
modifier|*
name|scb
decl_stmt|;
name|u_int
name|scbid
decl_stmt|;
name|u_int
name|lqistat1
decl_stmt|;
name|u_int
name|lqistat2
decl_stmt|;
name|u_int
name|msg_out
decl_stmt|;
name|u_int
name|curphase
decl_stmt|;
name|u_int
name|lastphase
decl_stmt|;
name|u_int
name|perrdiag
decl_stmt|;
name|u_int
name|cur_col
decl_stmt|;
name|int
name|silent
decl_stmt|;
name|scb
operator|=
name|NULL
expr_stmt|;
name|ahd_set_modes
argument_list|(
name|ahd
argument_list|,
name|AHD_MODE_SCSI
argument_list|,
name|AHD_MODE_SCSI
argument_list|)
expr_stmt|;
name|lqistat1
operator|=
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|LQISTAT1
argument_list|)
operator|&
operator|~
operator|(
name|LQIPHASE_LQ
operator||
name|LQIPHASE_NLQ
operator|)
expr_stmt|;
name|lqistat2
operator|=
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|LQISTAT2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|lqistat1
operator|&
operator|(
name|LQICRCI_NLQ
operator||
name|LQICRCI_LQ
operator|)
operator|)
operator|==
literal|0
operator|&&
operator|(
name|ahd
operator|->
name|bugs
operator|&
name|AHD_NLQICRC_DELAYED_BUG
operator|)
operator|!=
literal|0
condition|)
block|{
name|u_int
name|lqistate
decl_stmt|;
name|ahd_set_modes
argument_list|(
name|ahd
argument_list|,
name|AHD_MODE_CFG
argument_list|,
name|AHD_MODE_CFG
argument_list|)
expr_stmt|;
name|lqistate
operator|=
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|LQISTATE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|lqistate
operator|>=
literal|0x1E
operator|&&
name|lqistate
operator|<=
literal|0x24
operator|)
operator|||
operator|(
name|lqistate
operator|==
literal|0x29
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|AHD_DEBUG
if|if
condition|(
operator|(
name|ahd_debug
operator|&
name|AHD_SHOW_RECOVERY
operator|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%s: NLQCRC found via LQISTATE\n"
argument_list|,
name|ahd_name
argument_list|(
name|ahd
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|lqistat1
operator||=
name|LQICRCI_NLQ
expr_stmt|;
block|}
name|ahd_set_modes
argument_list|(
name|ahd
argument_list|,
name|AHD_MODE_SCSI
argument_list|,
name|AHD_MODE_SCSI
argument_list|)
expr_stmt|;
block|}
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|CLRLQIINT1
argument_list|,
name|lqistat1
argument_list|)
expr_stmt|;
name|lastphase
operator|=
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|LASTPHASE
argument_list|)
expr_stmt|;
name|curphase
operator|=
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|SCSISIGI
argument_list|)
operator|&
name|PHASE_MASK
expr_stmt|;
name|perrdiag
operator|=
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|PERRDIAG
argument_list|)
expr_stmt|;
name|msg_out
operator|=
name|MSG_INITIATOR_DET_ERR
expr_stmt|;
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|CLRSINT1
argument_list|,
name|CLRSCSIPERR
argument_list|)
expr_stmt|;
comment|/* 	 * Try to find the SCB associated with this error. 	 */
name|silent
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|lqistat1
operator|==
literal|0
operator|||
operator|(
name|lqistat1
operator|&
name|LQICRCI_NLQ
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|lqistat1
operator|&
operator|(
name|LQICRCI_NLQ
operator||
name|LQIOVERI_NLQ
operator|)
operator|)
operator|!=
literal|0
condition|)
name|ahd_set_active_fifo
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
name|scbid
operator|=
name|ahd_get_scbptr
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
name|scb
operator|=
name|ahd_lookup_scb
argument_list|(
name|ahd
argument_list|,
name|scbid
argument_list|)
expr_stmt|;
if|if
condition|(
name|scb
operator|!=
name|NULL
operator|&&
name|SCB_IS_SILENT
argument_list|(
name|scb
argument_list|)
condition|)
name|silent
operator|=
name|TRUE
expr_stmt|;
block|}
name|cur_col
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|silent
operator|==
name|FALSE
condition|)
block|{
name|printf
argument_list|(
literal|"%s: Transmission error detected\n"
argument_list|,
name|ahd_name
argument_list|(
name|ahd
argument_list|)
argument_list|)
expr_stmt|;
name|ahd_lqistat1_print
argument_list|(
name|lqistat1
argument_list|,
operator|&
name|cur_col
argument_list|,
literal|50
argument_list|)
expr_stmt|;
name|ahd_lastphase_print
argument_list|(
name|lastphase
argument_list|,
operator|&
name|cur_col
argument_list|,
literal|50
argument_list|)
expr_stmt|;
name|ahd_scsisigi_print
argument_list|(
name|curphase
argument_list|,
operator|&
name|cur_col
argument_list|,
literal|50
argument_list|)
expr_stmt|;
name|ahd_perrdiag_print
argument_list|(
name|perrdiag
argument_list|,
operator|&
name|cur_col
argument_list|,
literal|50
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|ahd_dump_card_state
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|lqistat1
operator|&
operator|(
name|LQIOVERI_LQ
operator||
name|LQIOVERI_NLQ
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|silent
operator|==
name|FALSE
condition|)
block|{
name|printf
argument_list|(
literal|"%s: Gross protocol error during incoming "
literal|"packet.  lqistat1 == 0x%x.  Resetting bus.\n"
argument_list|,
name|ahd_name
argument_list|(
name|ahd
argument_list|)
argument_list|,
name|lqistat1
argument_list|)
expr_stmt|;
block|}
name|ahd_reset_channel
argument_list|(
name|ahd
argument_list|,
literal|'A'
argument_list|,
comment|/*Initiate Reset*/
name|TRUE
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
operator|(
name|lqistat1
operator|&
name|LQICRCI_LQ
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * A CRC error has been detected on an incoming LQ. 		 * The bus is currently hung on the last ACK. 		 * Hit LQIRETRY to release the last ack, and 		 * wait for the sequencer to determine that ATNO 		 * is asserted while in message out to take us 		 * to our host message loop.  No NONPACKREQ or 		 * LQIPHASE type errors will occur in this 		 * scenario.  After this first LQIRETRY, the LQI 		 * manager will be in ISELO where it will 		 * happily sit until another packet phase begins. 		 * Unexpected bus free detection is enabled 		 * through any phases that occur after we release 		 * this last ack until the LQI manager sees a 		 * packet phase.  This implies we may have to 		 * ignore a perfectly valid "unexected busfree" 		 * after our "initiator detected error" message is 		 * sent.  A busfree is the expected response after 		 * we tell the target that it's L_Q was corrupted. 		 * (SPI4R09 10.7.3.3.3) 		 */
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|LQCTL2
argument_list|,
name|LQIRETRY
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"LQIRetry for LQICRCI_LQ to release ACK\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|lqistat1
operator|&
name|LQICRCI_NLQ
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * We detected a CRC error in a NON-LQ packet. 		 * The hardware has varying behavior in this situation 		 * depending on whether this packet was part of a 		 * stream or not. 		 * 		 * PKT by PKT mode: 		 * The hardware has already acked the complete packet. 		 * If the target honors our outstanding ATN condition, 		 * we should be (or soon will be) in MSGOUT phase. 		 * This will trigger the LQIPHASE_LQ status bit as the 		 * hardware was expecting another LQ.  Unexpected 		 * busfree detection is enabled.  Once LQIPHASE_LQ is 		 * true (first entry into host message loop is much 		 * the same), we must clear LQIPHASE_LQ and hit 		 * LQIRETRY so the hardware is ready to handle 		 * a future LQ.  NONPACKREQ will not be asserted again 		 * once we hit LQIRETRY until another packet is 		 * processed.  The target may either go busfree 		 * or start another packet in response to our message. 		 * 		 * Read Streaming P0 asserted: 		 * If we raise ATN and the target completes the entire 		 * stream (P0 asserted during the last packet), the 		 * hardware will ack all data and return to the ISTART 		 * state.  When the target reponds to our ATN condition, 		 * LQIPHASE_LQ will be asserted.  We should respond to 		 * this with an LQIRETRY to prepare for any future 		 * packets.  NONPACKREQ will not be asserted again 		 * once we hit LQIRETRY until another packet is 		 * processed.  The target may either go busfree or 		 * start another packet in response to our message. 		 * Busfree detection is enabled. 		 * 		 * Read Streaming P0 not asserted: 		 * If we raise ATN and the target transitions to 		 * MSGOUT in or after a packet where P0 is not 		 * asserted, the hardware will assert LQIPHASE_NLQ. 		 * We should respond to the LQIPHASE_NLQ with an 		 * LQIRETRY.  Should the target stay in a non-pkt 		 * phase after we send our message, the hardware 		 * will assert LQIPHASE_LQ.  Recovery is then just as 		 * listed above for the read streaming with P0 asserted. 		 * Busfree detection is enabled. 		 */
if|if
condition|(
name|silent
operator|==
name|FALSE
condition|)
name|printf
argument_list|(
literal|"LQICRC_NLQ\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|scb
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"%s: No SCB valid for LQICRC_NLQ.  "
literal|"Resetting bus\n"
argument_list|,
name|ahd_name
argument_list|(
name|ahd
argument_list|)
argument_list|)
expr_stmt|;
name|ahd_reset_channel
argument_list|(
name|ahd
argument_list|,
literal|'A'
argument_list|,
comment|/*Initiate Reset*/
name|TRUE
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|lqistat1
operator|&
name|LQIBADLQI
operator|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"Need to handle BADLQI!\n"
argument_list|)
expr_stmt|;
name|ahd_reset_channel
argument_list|(
name|ahd
argument_list|,
literal|'A'
argument_list|,
comment|/*Initiate Reset*/
name|TRUE
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
operator|(
name|perrdiag
operator|&
operator|(
name|PARITYERR
operator||
name|PREVPHASE
operator|)
operator|)
operator|==
name|PARITYERR
condition|)
block|{
if|if
condition|(
operator|(
name|curphase
operator|&
operator|~
name|P_DATAIN_DT
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* Ack the byte.  So we can continue. */
if|if
condition|(
name|silent
operator|==
name|FALSE
condition|)
name|printf
argument_list|(
literal|"Acking %s to clear perror\n"
argument_list|,
name|ahd_lookup_phase_entry
argument_list|(
name|curphase
argument_list|)
operator|->
name|phasemsg
argument_list|)
expr_stmt|;
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|SCSIDAT
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|curphase
operator|==
name|P_MESGIN
condition|)
name|msg_out
operator|=
name|MSG_PARITY_ERROR
expr_stmt|;
block|}
comment|/* 	 * We've set the hardware to assert ATN if we  	 * get a parity error on "in" phases, so all we 	 * need to do is stuff the message buffer with 	 * the appropriate message.  "In" phases have set 	 * mesg_out to something other than MSG_NOP. 	 */
name|ahd
operator|->
name|send_msg_perror
operator|=
name|msg_out
expr_stmt|;
if|if
condition|(
name|scb
operator|!=
name|NULL
operator|&&
name|msg_out
operator|==
name|MSG_INITIATOR_DET_ERR
condition|)
name|scb
operator|->
name|flags
operator||=
name|SCB_TRANSMISSION_ERROR
expr_stmt|;
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|MSG_OUT
argument_list|,
name|HOST_MSG
argument_list|)
expr_stmt|;
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|CLRINT
argument_list|,
name|CLRSCSIINT
argument_list|)
expr_stmt|;
name|ahd_unpause
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ahd_handle_lqiphase_error
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|,
name|u_int
name|lqistat1
parameter_list|)
block|{
comment|/* 	 * Clear the sources of the interrupts. 	 */
name|ahd_set_modes
argument_list|(
name|ahd
argument_list|,
name|AHD_MODE_SCSI
argument_list|,
name|AHD_MODE_SCSI
argument_list|)
expr_stmt|;
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|CLRLQIINT1
argument_list|,
name|lqistat1
argument_list|)
expr_stmt|;
comment|/* 	 * If the "illegal" phase changes were in response 	 * to our ATN to flag a CRC error, AND we ended up 	 * on packet boundaries, clear the error, restart the 	 * LQI manager as appropriate, and go on our merry 	 * way toward sending the message.  Otherwise, reset 	 * the bus to clear the error. 	 */
name|ahd_set_active_fifo
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|SCSISIGO
argument_list|)
operator|&
name|ATNO
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|MDFFSTAT
argument_list|)
operator|&
name|DLZERO
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|lqistat1
operator|&
name|LQIPHASE_LQ
operator|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"LQIRETRY for LQIPHASE_LQ\n"
argument_list|)
expr_stmt|;
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|LQCTL2
argument_list|,
name|LQIRETRY
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|lqistat1
operator|&
name|LQIPHASE_NLQ
operator|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"LQIRETRY for LQIPHASE_NLQ\n"
argument_list|)
expr_stmt|;
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|LQCTL2
argument_list|,
name|LQIRETRY
argument_list|)
expr_stmt|;
block|}
else|else
name|panic
argument_list|(
literal|"ahd_handle_lqiphase_error: No phase errors\n"
argument_list|)
expr_stmt|;
name|ahd_dump_card_state
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|CLRINT
argument_list|,
name|CLRSCSIINT
argument_list|)
expr_stmt|;
name|ahd_unpause
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"Reseting Channel for LQI Phase error\n"
argument_list|)
expr_stmt|;
name|ahd_dump_card_state
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
name|ahd_reset_channel
argument_list|(
name|ahd
argument_list|,
literal|'A'
argument_list|,
comment|/*Initiate Reset*/
name|TRUE
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Packetized unexpected or expected busfree.  * Entered in mode based on busfreetime.  */
end_comment

begin_function
specifier|static
name|int
name|ahd_handle_pkt_busfree
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|,
name|u_int
name|busfreetime
parameter_list|)
block|{
name|u_int
name|lqostat1
decl_stmt|;
name|AHD_ASSERT_MODES
argument_list|(
name|ahd
argument_list|,
operator|~
operator|(
name|AHD_MODE_UNKNOWN_MSK
operator||
name|AHD_MODE_CFG_MSK
operator|)
argument_list|,
operator|~
operator|(
name|AHD_MODE_UNKNOWN_MSK
operator||
name|AHD_MODE_CFG_MSK
operator|)
argument_list|)
expr_stmt|;
name|lqostat1
operator|=
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|LQOSTAT1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|lqostat1
operator|&
name|LQOBUSFREE
operator|)
operator|!=
literal|0
condition|)
block|{
name|struct
name|scb
modifier|*
name|scb
decl_stmt|;
name|u_int
name|scbid
decl_stmt|;
name|u_int
name|saved_scbptr
decl_stmt|;
name|u_int
name|waiting_h
decl_stmt|;
name|u_int
name|waiting_t
decl_stmt|;
name|u_int
name|next
decl_stmt|;
comment|/* 		 * The LQO manager detected an unexpected busfree 		 * either: 		 * 		 * 1) During an outgoing LQ. 		 * 2) After an outgoing LQ but before the first 		 *    REQ of the command packet. 		 * 3) During an outgoing command packet. 		 * 		 * In all cases, CURRSCB is pointing to the 		 * SCB that encountered the failure.  Clean 		 * up the queue, clear SELDO and LQOBUSFREE, 		 * and allow the sequencer to restart the select 		 * out at its lesure. 		 */
name|ahd_set_modes
argument_list|(
name|ahd
argument_list|,
name|AHD_MODE_SCSI
argument_list|,
name|AHD_MODE_SCSI
argument_list|)
expr_stmt|;
name|scbid
operator|=
name|ahd_inw
argument_list|(
name|ahd
argument_list|,
name|CURRSCB
argument_list|)
expr_stmt|;
name|scb
operator|=
name|ahd_lookup_scb
argument_list|(
name|ahd
argument_list|,
name|scbid
argument_list|)
expr_stmt|;
if|if
condition|(
name|scb
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"SCB not valid during LQOBUSFREE"
argument_list|)
expr_stmt|;
comment|/* 		 * Clear the status. 		 */
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|CLRLQOINT1
argument_list|,
name|CLRLQOBUSFREE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ahd
operator|->
name|bugs
operator|&
name|AHD_CLRLQO_AUTOCLR_BUG
operator|)
operator|!=
literal|0
condition|)
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|CLRLQOINT1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|SCSISEQ0
argument_list|,
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|SCSISEQ0
argument_list|)
operator|&
operator|~
name|ENSELO
argument_list|)
expr_stmt|;
name|ahd_flush_device_writes
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|CLRSINT0
argument_list|,
name|CLRSELDO
argument_list|)
expr_stmt|;
comment|/* 		 * Return the LQO manager to its idle loop.  It will 		 * not do this automatically if the busfree occurs 		 * after the first REQ of either the LQ or command 		 * packet or between the LQ and command packet. 		 */
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|LQCTL2
argument_list|,
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|LQCTL2
argument_list|)
operator||
name|LQOTOIDLE
argument_list|)
expr_stmt|;
comment|/* 		 * Update the waiting for selection queue so 		 * we restart on the correct SCB. 		 */
name|waiting_h
operator|=
name|ahd_inw
argument_list|(
name|ahd
argument_list|,
name|WAITING_TID_HEAD
argument_list|)
expr_stmt|;
name|saved_scbptr
operator|=
name|ahd_get_scbptr
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
if|if
condition|(
name|waiting_h
operator|!=
name|scbid
condition|)
block|{
name|ahd_outw
argument_list|(
name|ahd
argument_list|,
name|WAITING_TID_HEAD
argument_list|,
name|scbid
argument_list|)
expr_stmt|;
name|waiting_t
operator|=
name|ahd_inw
argument_list|(
name|ahd
argument_list|,
name|WAITING_TID_TAIL
argument_list|)
expr_stmt|;
if|if
condition|(
name|waiting_t
operator|==
name|waiting_h
condition|)
block|{
name|ahd_outw
argument_list|(
name|ahd
argument_list|,
name|WAITING_TID_TAIL
argument_list|,
name|scbid
argument_list|)
expr_stmt|;
name|next
operator|=
name|SCB_LIST_NULL
expr_stmt|;
block|}
else|else
block|{
name|ahd_set_scbptr
argument_list|(
name|ahd
argument_list|,
name|waiting_h
argument_list|)
expr_stmt|;
name|next
operator|=
name|ahd_inw_scbram
argument_list|(
name|ahd
argument_list|,
name|SCB_NEXT2
argument_list|)
expr_stmt|;
block|}
name|ahd_set_scbptr
argument_list|(
name|ahd
argument_list|,
name|scbid
argument_list|)
expr_stmt|;
name|ahd_outw
argument_list|(
name|ahd
argument_list|,
name|SCB_NEXT2
argument_list|,
name|next
argument_list|)
expr_stmt|;
block|}
name|ahd_set_scbptr
argument_list|(
name|ahd
argument_list|,
name|saved_scbptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|scb
operator|->
name|crc_retry_count
operator|<
name|AHD_MAX_LQ_CRC_ERRORS
condition|)
block|{
if|if
condition|(
name|SCB_IS_SILENT
argument_list|(
name|scb
argument_list|)
operator|==
name|FALSE
condition|)
block|{
name|ahd_print_path
argument_list|(
name|ahd
argument_list|,
name|scb
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Probable outgoing LQ CRC error.  "
literal|"Retrying command\n"
argument_list|)
expr_stmt|;
block|}
name|scb
operator|->
name|crc_retry_count
operator|++
expr_stmt|;
block|}
else|else
block|{
name|aic_set_transaction_status
argument_list|(
name|scb
argument_list|,
name|CAM_UNCOR_PARITY
argument_list|)
expr_stmt|;
name|aic_freeze_scb
argument_list|(
name|scb
argument_list|)
expr_stmt|;
name|ahd_freeze_devq
argument_list|(
name|ahd
argument_list|,
name|scb
argument_list|)
expr_stmt|;
block|}
comment|/* Return unpausing the sequencer. */
return|return
operator|(
literal|0
operator|)
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|PERRDIAG
argument_list|)
operator|&
name|PARITYERR
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * Ignore what are really parity errors that 		 * occur on the last REQ of a free running 		 * clock prior to going busfree.  Some drives 		 * do not properly active negate just before 		 * going busfree resulting in a parity glitch. 		 */
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|CLRSINT1
argument_list|,
name|CLRSCSIPERR
operator||
name|CLRBUSFREE
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|AHD_DEBUG
if|if
condition|(
operator|(
name|ahd_debug
operator|&
name|AHD_SHOW_MASKED_ERRORS
operator|)
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|"%s: Parity on last REQ detected "
literal|"during busfree phase.\n"
argument_list|,
name|ahd_name
argument_list|(
name|ahd
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Return unpausing the sequencer. */
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|ahd
operator|->
name|src_mode
operator|!=
name|AHD_MODE_SCSI
condition|)
block|{
name|u_int
name|scbid
decl_stmt|;
name|struct
name|scb
modifier|*
name|scb
decl_stmt|;
name|scbid
operator|=
name|ahd_get_scbptr
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
name|scb
operator|=
name|ahd_lookup_scb
argument_list|(
name|ahd
argument_list|,
name|scbid
argument_list|)
expr_stmt|;
name|ahd_print_path
argument_list|(
name|ahd
argument_list|,
name|scb
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Unexpected PKT busfree condition\n"
argument_list|)
expr_stmt|;
name|ahd_dump_card_state
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
name|ahd_abort_scbs
argument_list|(
name|ahd
argument_list|,
name|SCB_GET_TARGET
argument_list|(
name|ahd
argument_list|,
name|scb
argument_list|)
argument_list|,
literal|'A'
argument_list|,
name|SCB_GET_LUN
argument_list|(
name|scb
argument_list|)
argument_list|,
name|SCB_GET_TAG
argument_list|(
name|scb
argument_list|)
argument_list|,
name|ROLE_INITIATOR
argument_list|,
name|CAM_UNEXP_BUSFREE
argument_list|)
expr_stmt|;
comment|/* Return restarting the sequencer. */
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|printf
argument_list|(
literal|"%s: Unexpected PKT busfree condition\n"
argument_list|,
name|ahd_name
argument_list|(
name|ahd
argument_list|)
argument_list|)
expr_stmt|;
name|ahd_dump_card_state
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
comment|/* Restart the sequencer. */
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Non-packetized unexpected or expected busfree.  */
end_comment

begin_function
specifier|static
name|int
name|ahd_handle_nonpkt_busfree
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|)
block|{
name|struct
name|ahd_devinfo
name|devinfo
decl_stmt|;
name|struct
name|scb
modifier|*
name|scb
decl_stmt|;
name|u_int
name|lastphase
decl_stmt|;
name|u_int
name|saved_scsiid
decl_stmt|;
name|u_int
name|saved_lun
decl_stmt|;
name|u_int
name|target
decl_stmt|;
name|u_int
name|initiator_role_id
decl_stmt|;
name|u_int
name|scbid
decl_stmt|;
name|u_int
name|ppr_busfree
decl_stmt|;
name|int
name|printerror
decl_stmt|;
comment|/* 	 * Look at what phase we were last in.  If its message out, 	 * chances are pretty good that the busfree was in response 	 * to one of our abort requests. 	 */
name|lastphase
operator|=
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|LASTPHASE
argument_list|)
expr_stmt|;
name|saved_scsiid
operator|=
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|SAVED_SCSIID
argument_list|)
expr_stmt|;
name|saved_lun
operator|=
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|SAVED_LUN
argument_list|)
expr_stmt|;
name|target
operator|=
name|SCSIID_TARGET
argument_list|(
name|ahd
argument_list|,
name|saved_scsiid
argument_list|)
expr_stmt|;
name|initiator_role_id
operator|=
name|SCSIID_OUR_ID
argument_list|(
name|saved_scsiid
argument_list|)
expr_stmt|;
name|ahd_compile_devinfo
argument_list|(
operator|&
name|devinfo
argument_list|,
name|initiator_role_id
argument_list|,
name|target
argument_list|,
name|saved_lun
argument_list|,
literal|'A'
argument_list|,
name|ROLE_INITIATOR
argument_list|)
expr_stmt|;
name|printerror
operator|=
literal|1
expr_stmt|;
name|scbid
operator|=
name|ahd_get_scbptr
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
name|scb
operator|=
name|ahd_lookup_scb
argument_list|(
name|ahd
argument_list|,
name|scbid
argument_list|)
expr_stmt|;
if|if
condition|(
name|scb
operator|!=
name|NULL
operator|&&
operator|(
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|SEQ_FLAGS
argument_list|)
operator|&
name|NOT_IDENTIFIED
operator|)
operator|!=
literal|0
condition|)
name|scb
operator|=
name|NULL
expr_stmt|;
name|ppr_busfree
operator|=
operator|(
name|ahd
operator|->
name|msg_flags
operator|&
name|MSG_FLAG_EXPECT_PPR_BUSFREE
operator|)
operator|!=
literal|0
expr_stmt|;
if|if
condition|(
name|lastphase
operator|==
name|P_MESGOUT
condition|)
block|{
name|u_int
name|tag
decl_stmt|;
name|tag
operator|=
name|SCB_LIST_NULL
expr_stmt|;
if|if
condition|(
name|ahd_sent_msg
argument_list|(
name|ahd
argument_list|,
name|AHDMSG_1B
argument_list|,
name|MSG_ABORT_TAG
argument_list|,
name|TRUE
argument_list|)
operator|||
name|ahd_sent_msg
argument_list|(
name|ahd
argument_list|,
name|AHDMSG_1B
argument_list|,
name|MSG_ABORT
argument_list|,
name|TRUE
argument_list|)
condition|)
block|{
name|int
name|found
decl_stmt|;
name|int
name|sent_msg
decl_stmt|;
if|if
condition|(
name|scb
operator|==
name|NULL
condition|)
block|{
name|ahd_print_devinfo
argument_list|(
name|ahd
argument_list|,
operator|&
name|devinfo
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Abort for unidentified "
literal|"connection completed.\n"
argument_list|)
expr_stmt|;
comment|/* restart the sequencer. */
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|sent_msg
operator|=
name|ahd
operator|->
name|msgout_buf
index|[
name|ahd
operator|->
name|msgout_index
operator|-
literal|1
index|]
expr_stmt|;
name|ahd_print_path
argument_list|(
name|ahd
argument_list|,
name|scb
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"SCB %d - Abort%s Completed.\n"
argument_list|,
name|SCB_GET_TAG
argument_list|(
name|scb
argument_list|)
argument_list|,
name|sent_msg
operator|==
name|MSG_ABORT_TAG
condition|?
literal|""
else|:
literal|" Tag"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sent_msg
operator|==
name|MSG_ABORT_TAG
condition|)
name|tag
operator|=
name|SCB_GET_TAG
argument_list|(
name|scb
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|scb
operator|->
name|flags
operator|&
name|SCB_CMDPHASE_ABORT
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* 				 * This abort is in response to an 				 * unexpected switch to command phase 				 * for a packetized connection.  Since 				 * the identify message was never sent, 				 * "saved lun" is 0.  We really want to 				 * abort only the SCB that encountered 				 * this error, which could have a different 				 * lun.  The SCB will be retried so the OS 				 * will see the UA after renegotiating to 				 * packetized. 				 */
name|tag
operator|=
name|SCB_GET_TAG
argument_list|(
name|scb
argument_list|)
expr_stmt|;
name|saved_lun
operator|=
name|scb
operator|->
name|hscb
operator|->
name|lun
expr_stmt|;
block|}
name|found
operator|=
name|ahd_abort_scbs
argument_list|(
name|ahd
argument_list|,
name|target
argument_list|,
literal|'A'
argument_list|,
name|saved_lun
argument_list|,
name|tag
argument_list|,
name|ROLE_INITIATOR
argument_list|,
name|CAM_REQ_ABORTED
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"found == 0x%x\n"
argument_list|,
name|found
argument_list|)
expr_stmt|;
name|printerror
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ahd_sent_msg
argument_list|(
name|ahd
argument_list|,
name|AHDMSG_1B
argument_list|,
name|MSG_BUS_DEV_RESET
argument_list|,
name|TRUE
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|__FreeBSD__
comment|/* 			 * Don't mark the user's request for this BDR 			 * as completing with CAM_BDR_SENT.  CAM3 			 * specifies CAM_REQ_CMP. 			 */
if|if
condition|(
name|scb
operator|!=
name|NULL
operator|&&
name|scb
operator|->
name|io_ctx
operator|->
name|ccb_h
operator|.
name|func_code
operator|==
name|XPT_RESET_DEV
operator|&&
name|ahd_match_scb
argument_list|(
name|ahd
argument_list|,
name|scb
argument_list|,
name|target
argument_list|,
literal|'A'
argument_list|,
name|CAM_LUN_WILDCARD
argument_list|,
name|SCB_LIST_NULL
argument_list|,
name|ROLE_INITIATOR
argument_list|)
condition|)
name|aic_set_transaction_status
argument_list|(
name|scb
argument_list|,
name|CAM_REQ_CMP
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ahd_handle_devreset
argument_list|(
name|ahd
argument_list|,
operator|&
name|devinfo
argument_list|,
name|CAM_LUN_WILDCARD
argument_list|,
name|CAM_BDR_SENT
argument_list|,
literal|"Bus Device Reset"
argument_list|,
comment|/*verbose_level*/
literal|0
argument_list|)
expr_stmt|;
name|printerror
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ahd_sent_msg
argument_list|(
name|ahd
argument_list|,
name|AHDMSG_EXT
argument_list|,
name|MSG_EXT_PPR
argument_list|,
name|FALSE
argument_list|)
operator|&&
name|ppr_busfree
operator|==
literal|0
condition|)
block|{
name|struct
name|ahd_initiator_tinfo
modifier|*
name|tinfo
decl_stmt|;
name|struct
name|ahd_tmode_tstate
modifier|*
name|tstate
decl_stmt|;
comment|/* 			 * PPR Rejected. 			 * 			 * If the previous negotiation was packetized, 			 * this could be because the device has been 			 * reset without our knowledge.  Force our 			 * current negotiation to async and retry the 			 * negotiation.  Otherwise retry the command 			 * with non-ppr negotiation. 			 */
ifdef|#
directive|ifdef
name|AHD_DEBUG
if|if
condition|(
operator|(
name|ahd_debug
operator|&
name|AHD_SHOW_MESSAGES
operator|)
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|"PPR negotiation rejected busfree.\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|tinfo
operator|=
name|ahd_fetch_transinfo
argument_list|(
name|ahd
argument_list|,
name|devinfo
operator|.
name|channel
argument_list|,
name|devinfo
operator|.
name|our_scsiid
argument_list|,
name|devinfo
operator|.
name|target
argument_list|,
operator|&
name|tstate
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tinfo
operator|->
name|curr
operator|.
name|ppr_options
operator|&
name|MSG_EXT_PPR_IU_REQ
operator|)
operator|!=
literal|0
condition|)
block|{
name|ahd_set_width
argument_list|(
name|ahd
argument_list|,
operator|&
name|devinfo
argument_list|,
name|MSG_EXT_WDTR_BUS_8_BIT
argument_list|,
name|AHD_TRANS_CUR
argument_list|,
comment|/*paused*/
name|TRUE
argument_list|)
expr_stmt|;
name|ahd_set_syncrate
argument_list|(
name|ahd
argument_list|,
operator|&
name|devinfo
argument_list|,
comment|/*period*/
literal|0
argument_list|,
comment|/*offset*/
literal|0
argument_list|,
comment|/*ppr_options*/
literal|0
argument_list|,
name|AHD_TRANS_CUR
argument_list|,
comment|/*paused*/
name|TRUE
argument_list|)
expr_stmt|;
comment|/* 				 * The expect PPR busfree handler below 				 * will effect the retry and necessary 				 * abort. 				 */
block|}
else|else
block|{
name|tinfo
operator|->
name|curr
operator|.
name|transport_version
operator|=
literal|2
expr_stmt|;
name|tinfo
operator|->
name|goal
operator|.
name|transport_version
operator|=
literal|2
expr_stmt|;
name|tinfo
operator|->
name|goal
operator|.
name|ppr_options
operator|=
literal|0
expr_stmt|;
comment|/* 				 * Remove any SCBs in the waiting for selection 				 * queue that may also be for this target so 				 * that command ordering is preserved. 				 */
name|ahd_freeze_devq
argument_list|(
name|ahd
argument_list|,
name|scb
argument_list|)
expr_stmt|;
name|ahd_qinfifo_requeue_tail
argument_list|(
name|ahd
argument_list|,
name|scb
argument_list|)
expr_stmt|;
name|printerror
operator|=
literal|0
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|ahd_sent_msg
argument_list|(
name|ahd
argument_list|,
name|AHDMSG_EXT
argument_list|,
name|MSG_EXT_WDTR
argument_list|,
name|FALSE
argument_list|)
operator|&&
name|ppr_busfree
operator|==
literal|0
condition|)
block|{
comment|/* 			 * Negotiation Rejected.  Go-narrow and 			 * retry command. 			 */
ifdef|#
directive|ifdef
name|AHD_DEBUG
if|if
condition|(
operator|(
name|ahd_debug
operator|&
name|AHD_SHOW_MESSAGES
operator|)
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|"WDTR negotiation rejected busfree.\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ahd_set_width
argument_list|(
name|ahd
argument_list|,
operator|&
name|devinfo
argument_list|,
name|MSG_EXT_WDTR_BUS_8_BIT
argument_list|,
name|AHD_TRANS_CUR
operator||
name|AHD_TRANS_GOAL
argument_list|,
comment|/*paused*/
name|TRUE
argument_list|)
expr_stmt|;
comment|/* 			 * Remove any SCBs in the waiting for selection 			 * queue that may also be for this target so that 			 * command ordering is preserved. 			 */
name|ahd_freeze_devq
argument_list|(
name|ahd
argument_list|,
name|scb
argument_list|)
expr_stmt|;
name|ahd_qinfifo_requeue_tail
argument_list|(
name|ahd
argument_list|,
name|scb
argument_list|)
expr_stmt|;
name|printerror
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ahd_sent_msg
argument_list|(
name|ahd
argument_list|,
name|AHDMSG_EXT
argument_list|,
name|MSG_EXT_SDTR
argument_list|,
name|FALSE
argument_list|)
operator|&&
name|ppr_busfree
operator|==
literal|0
condition|)
block|{
comment|/* 			 * Negotiation Rejected.  Go-async and 			 * retry command. 			 */
ifdef|#
directive|ifdef
name|AHD_DEBUG
if|if
condition|(
operator|(
name|ahd_debug
operator|&
name|AHD_SHOW_MESSAGES
operator|)
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|"SDTR negotiation rejected busfree.\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ahd_set_syncrate
argument_list|(
name|ahd
argument_list|,
operator|&
name|devinfo
argument_list|,
comment|/*period*/
literal|0
argument_list|,
comment|/*offset*/
literal|0
argument_list|,
comment|/*ppr_options*/
literal|0
argument_list|,
name|AHD_TRANS_CUR
operator||
name|AHD_TRANS_GOAL
argument_list|,
comment|/*paused*/
name|TRUE
argument_list|)
expr_stmt|;
comment|/* 			 * Remove any SCBs in the waiting for selection 			 * queue that may also be for this target so that 			 * command ordering is preserved. 			 */
name|ahd_freeze_devq
argument_list|(
name|ahd
argument_list|,
name|scb
argument_list|)
expr_stmt|;
name|ahd_qinfifo_requeue_tail
argument_list|(
name|ahd
argument_list|,
name|scb
argument_list|)
expr_stmt|;
name|printerror
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|ahd
operator|->
name|msg_flags
operator|&
name|MSG_FLAG_EXPECT_IDE_BUSFREE
operator|)
operator|!=
literal|0
operator|&&
name|ahd_sent_msg
argument_list|(
name|ahd
argument_list|,
name|AHDMSG_1B
argument_list|,
name|MSG_INITIATOR_DET_ERR
argument_list|,
name|TRUE
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|AHD_DEBUG
if|if
condition|(
operator|(
name|ahd_debug
operator|&
name|AHD_SHOW_MESSAGES
operator|)
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|"Expected IDE Busfree\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|printerror
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|ahd
operator|->
name|msg_flags
operator|&
name|MSG_FLAG_EXPECT_QASREJ_BUSFREE
operator|)
operator|&&
name|ahd_sent_msg
argument_list|(
name|ahd
argument_list|,
name|AHDMSG_1B
argument_list|,
name|MSG_MESSAGE_REJECT
argument_list|,
name|TRUE
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|AHD_DEBUG
if|if
condition|(
operator|(
name|ahd_debug
operator|&
name|AHD_SHOW_MESSAGES
operator|)
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|"Expected QAS Reject Busfree\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|printerror
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* 	 * The busfree required flag is honored at the end of 	 * the message phases.  We check it last in case we 	 * had to send some other message that caused a busfree. 	 */
if|if
condition|(
name|printerror
operator|!=
literal|0
operator|&&
operator|(
name|lastphase
operator|==
name|P_MESGIN
operator|||
name|lastphase
operator|==
name|P_MESGOUT
operator|)
operator|&&
operator|(
operator|(
name|ahd
operator|->
name|msg_flags
operator|&
name|MSG_FLAG_EXPECT_PPR_BUSFREE
operator|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|ahd_freeze_devq
argument_list|(
name|ahd
argument_list|,
name|scb
argument_list|)
expr_stmt|;
name|aic_set_transaction_status
argument_list|(
name|scb
argument_list|,
name|CAM_REQUEUE_REQ
argument_list|)
expr_stmt|;
name|aic_freeze_scb
argument_list|(
name|scb
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ahd
operator|->
name|msg_flags
operator|&
name|MSG_FLAG_IU_REQ_CHANGED
operator|)
operator|!=
literal|0
condition|)
block|{
name|ahd_abort_scbs
argument_list|(
name|ahd
argument_list|,
name|SCB_GET_TARGET
argument_list|(
name|ahd
argument_list|,
name|scb
argument_list|)
argument_list|,
name|SCB_GET_CHANNEL
argument_list|(
name|ahd
argument_list|,
name|scb
argument_list|)
argument_list|,
name|SCB_GET_LUN
argument_list|(
name|scb
argument_list|)
argument_list|,
name|SCB_LIST_NULL
argument_list|,
name|ROLE_INITIATOR
argument_list|,
name|CAM_REQ_ABORTED
argument_list|)
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|AHD_DEBUG
if|if
condition|(
operator|(
name|ahd_debug
operator|&
name|AHD_SHOW_MESSAGES
operator|)
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|"PPR Negotiation Busfree.\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ahd_done
argument_list|(
name|ahd
argument_list|,
name|scb
argument_list|)
expr_stmt|;
block|}
name|printerror
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|printerror
operator|!=
literal|0
condition|)
block|{
name|int
name|aborted
decl_stmt|;
name|aborted
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|scb
operator|!=
name|NULL
condition|)
block|{
name|u_int
name|tag
decl_stmt|;
if|if
condition|(
operator|(
name|scb
operator|->
name|hscb
operator|->
name|control
operator|&
name|TAG_ENB
operator|)
operator|!=
literal|0
condition|)
name|tag
operator|=
name|SCB_GET_TAG
argument_list|(
name|scb
argument_list|)
expr_stmt|;
else|else
name|tag
operator|=
name|SCB_LIST_NULL
expr_stmt|;
name|ahd_print_path
argument_list|(
name|ahd
argument_list|,
name|scb
argument_list|)
expr_stmt|;
name|aborted
operator|=
name|ahd_abort_scbs
argument_list|(
name|ahd
argument_list|,
name|target
argument_list|,
literal|'A'
argument_list|,
name|SCB_GET_LUN
argument_list|(
name|scb
argument_list|)
argument_list|,
name|tag
argument_list|,
name|ROLE_INITIATOR
argument_list|,
name|CAM_UNEXP_BUSFREE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * We had not fully identified this connection, 			 * so we cannot abort anything. 			 */
name|printf
argument_list|(
literal|"%s: "
argument_list|,
name|ahd_name
argument_list|(
name|ahd
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"Unexpected busfree %s, %d SCBs aborted, "
literal|"PRGMCNT == 0x%x\n"
argument_list|,
name|ahd_lookup_phase_entry
argument_list|(
name|lastphase
argument_list|)
operator|->
name|phasemsg
argument_list|,
name|aborted
argument_list|,
name|ahd_inw
argument_list|(
name|ahd
argument_list|,
name|PRGMCNT
argument_list|)
argument_list|)
expr_stmt|;
name|ahd_dump_card_state
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
if|if
condition|(
name|lastphase
operator|!=
name|P_BUSFREE
condition|)
name|ahd_force_renegotiation
argument_list|(
name|ahd
argument_list|,
operator|&
name|devinfo
argument_list|)
expr_stmt|;
block|}
comment|/* Always restart the sequencer. */
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ahd_handle_proto_violation
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|)
block|{
name|struct
name|ahd_devinfo
name|devinfo
decl_stmt|;
name|struct
name|scb
modifier|*
name|scb
decl_stmt|;
name|u_int
name|scbid
decl_stmt|;
name|u_int
name|seq_flags
decl_stmt|;
name|u_int
name|curphase
decl_stmt|;
name|u_int
name|lastphase
decl_stmt|;
name|int
name|found
decl_stmt|;
name|ahd_fetch_devinfo
argument_list|(
name|ahd
argument_list|,
operator|&
name|devinfo
argument_list|)
expr_stmt|;
name|scbid
operator|=
name|ahd_get_scbptr
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
name|scb
operator|=
name|ahd_lookup_scb
argument_list|(
name|ahd
argument_list|,
name|scbid
argument_list|)
expr_stmt|;
name|seq_flags
operator|=
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|SEQ_FLAGS
argument_list|)
expr_stmt|;
name|curphase
operator|=
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|SCSISIGI
argument_list|)
operator|&
name|PHASE_MASK
expr_stmt|;
name|lastphase
operator|=
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|LASTPHASE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|seq_flags
operator|&
name|NOT_IDENTIFIED
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * The reconnecting target either did not send an 		 * identify message, or did, but we didn't find an SCB 		 * to match. 		 */
name|ahd_print_devinfo
argument_list|(
name|ahd
argument_list|,
operator|&
name|devinfo
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Target did not send an IDENTIFY message. "
literal|"LASTPHASE = 0x%x.\n"
argument_list|,
name|lastphase
argument_list|)
expr_stmt|;
name|scb
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|scb
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * We don't seem to have an SCB active for this 		 * transaction.  Print an error and reset the bus. 		 */
name|ahd_print_devinfo
argument_list|(
name|ahd
argument_list|,
operator|&
name|devinfo
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"No SCB found during protocol violation\n"
argument_list|)
expr_stmt|;
goto|goto
name|proto_violation_reset
goto|;
block|}
else|else
block|{
name|aic_set_transaction_status
argument_list|(
name|scb
argument_list|,
name|CAM_SEQUENCE_FAIL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|seq_flags
operator|&
name|NO_CDB_SENT
operator|)
operator|!=
literal|0
condition|)
block|{
name|ahd_print_path
argument_list|(
name|ahd
argument_list|,
name|scb
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"No or incomplete CDB sent to device.\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|ahd_inb_scbram
argument_list|(
name|ahd
argument_list|,
name|SCB_CONTROL
argument_list|)
operator|&
name|STATUS_RCVD
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 			 * The target never bothered to provide status to 			 * us prior to completing the command.  Since we don't 			 * know the disposition of this command, we must attempt 			 * to abort it.  Assert ATN and prepare to send an abort 			 * message. 			 */
name|ahd_print_path
argument_list|(
name|ahd
argument_list|,
name|scb
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Completed command without status.\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ahd_print_path
argument_list|(
name|ahd
argument_list|,
name|scb
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Unknown protocol violation.\n"
argument_list|)
expr_stmt|;
name|ahd_dump_card_state
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|lastphase
operator|&
operator|~
name|P_DATAIN_DT
operator|)
operator|==
literal|0
operator|||
name|lastphase
operator|==
name|P_COMMAND
condition|)
block|{
name|proto_violation_reset
label|:
comment|/* 		 * Target either went directly to data 		 * phase or didn't respond to our ATN. 		 * The only safe thing to do is to blow 		 * it away with a bus reset. 		 */
name|found
operator|=
name|ahd_reset_channel
argument_list|(
name|ahd
argument_list|,
literal|'A'
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s: Issued Channel %c Bus Reset. "
literal|"%d SCBs aborted\n"
argument_list|,
name|ahd_name
argument_list|(
name|ahd
argument_list|)
argument_list|,
literal|'A'
argument_list|,
name|found
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Leave the selection hardware off in case 		 * this abort attempt will affect yet to 		 * be sent commands. 		 */
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|SCSISEQ0
argument_list|,
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|SCSISEQ0
argument_list|)
operator|&
operator|~
name|ENSELO
argument_list|)
expr_stmt|;
name|ahd_assert_atn
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|MSG_OUT
argument_list|,
name|HOST_MSG
argument_list|)
expr_stmt|;
if|if
condition|(
name|scb
operator|==
name|NULL
condition|)
block|{
name|ahd_print_devinfo
argument_list|(
name|ahd
argument_list|,
operator|&
name|devinfo
argument_list|)
expr_stmt|;
name|ahd
operator|->
name|msgout_buf
index|[
literal|0
index|]
operator|=
name|MSG_ABORT_TASK
expr_stmt|;
name|ahd
operator|->
name|msgout_len
operator|=
literal|1
expr_stmt|;
name|ahd
operator|->
name|msgout_index
operator|=
literal|0
expr_stmt|;
name|ahd
operator|->
name|msg_type
operator|=
name|MSG_TYPE_INITIATOR_MSGOUT
expr_stmt|;
block|}
else|else
block|{
name|ahd_print_path
argument_list|(
name|ahd
argument_list|,
name|scb
argument_list|)
expr_stmt|;
name|scb
operator|->
name|flags
operator||=
name|SCB_ABORT
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"Protocol violation %s.  Attempting to abort.\n"
argument_list|,
name|ahd_lookup_phase_entry
argument_list|(
name|curphase
argument_list|)
operator|->
name|phasemsg
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Force renegotiation to occur the next time we initiate  * a command to the current device.  */
end_comment

begin_function
specifier|static
name|void
name|ahd_force_renegotiation
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|,
name|struct
name|ahd_devinfo
modifier|*
name|devinfo
parameter_list|)
block|{
name|struct
name|ahd_initiator_tinfo
modifier|*
name|targ_info
decl_stmt|;
name|struct
name|ahd_tmode_tstate
modifier|*
name|tstate
decl_stmt|;
ifdef|#
directive|ifdef
name|AHD_DEBUG
if|if
condition|(
operator|(
name|ahd_debug
operator|&
name|AHD_SHOW_MESSAGES
operator|)
operator|!=
literal|0
condition|)
block|{
name|ahd_print_devinfo
argument_list|(
name|ahd
argument_list|,
name|devinfo
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Forcing renegotiation\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|targ_info
operator|=
name|ahd_fetch_transinfo
argument_list|(
name|ahd
argument_list|,
name|devinfo
operator|->
name|channel
argument_list|,
name|devinfo
operator|->
name|our_scsiid
argument_list|,
name|devinfo
operator|->
name|target
argument_list|,
operator|&
name|tstate
argument_list|)
expr_stmt|;
name|ahd_update_neg_request
argument_list|(
name|ahd
argument_list|,
name|devinfo
argument_list|,
name|tstate
argument_list|,
name|targ_info
argument_list|,
name|AHD_NEG_IF_NON_ASYNC
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|AHD_MAX_STEPS
value|2000
end_define

begin_function
name|void
name|ahd_clear_critical_section
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|)
block|{
name|ahd_mode_state
name|saved_modes
decl_stmt|;
name|int
name|stepping
decl_stmt|;
name|int
name|steps
decl_stmt|;
name|int
name|first_instr
decl_stmt|;
name|u_int
name|simode0
decl_stmt|;
name|u_int
name|simode1
decl_stmt|;
name|u_int
name|simode3
decl_stmt|;
name|u_int
name|lqimode0
decl_stmt|;
name|u_int
name|lqimode1
decl_stmt|;
name|u_int
name|lqomode0
decl_stmt|;
name|u_int
name|lqomode1
decl_stmt|;
if|if
condition|(
name|ahd
operator|->
name|num_critical_sections
operator|==
literal|0
condition|)
return|return;
name|stepping
operator|=
name|FALSE
expr_stmt|;
name|steps
operator|=
literal|0
expr_stmt|;
name|first_instr
operator|=
literal|0
expr_stmt|;
name|simode0
operator|=
literal|0
expr_stmt|;
name|simode1
operator|=
literal|0
expr_stmt|;
name|simode3
operator|=
literal|0
expr_stmt|;
name|lqimode0
operator|=
literal|0
expr_stmt|;
name|lqimode1
operator|=
literal|0
expr_stmt|;
name|lqomode0
operator|=
literal|0
expr_stmt|;
name|lqomode1
operator|=
literal|0
expr_stmt|;
name|saved_modes
operator|=
name|ahd_save_modes
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|struct
name|cs
modifier|*
name|cs
decl_stmt|;
name|u_int
name|seqaddr
decl_stmt|;
name|u_int
name|i
decl_stmt|;
name|ahd_set_modes
argument_list|(
name|ahd
argument_list|,
name|AHD_MODE_SCSI
argument_list|,
name|AHD_MODE_SCSI
argument_list|)
expr_stmt|;
name|seqaddr
operator|=
name|ahd_inw
argument_list|(
name|ahd
argument_list|,
name|CURADDR
argument_list|)
expr_stmt|;
name|cs
operator|=
name|ahd
operator|->
name|critical_sections
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ahd
operator|->
name|num_critical_sections
condition|;
name|i
operator|++
operator|,
name|cs
operator|++
control|)
block|{
if|if
condition|(
name|cs
operator|->
name|begin
operator|<
name|seqaddr
operator|&&
name|cs
operator|->
name|end
operator|>=
name|seqaddr
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|==
name|ahd
operator|->
name|num_critical_sections
condition|)
break|break;
if|if
condition|(
name|steps
operator|>
name|AHD_MAX_STEPS
condition|)
block|{
name|printf
argument_list|(
literal|"%s: Infinite loop in critical section\n"
literal|"%s: First Instruction 0x%x now 0x%x\n"
argument_list|,
name|ahd_name
argument_list|(
name|ahd
argument_list|)
argument_list|,
name|ahd_name
argument_list|(
name|ahd
argument_list|)
argument_list|,
name|first_instr
argument_list|,
name|seqaddr
argument_list|)
expr_stmt|;
name|ahd_dump_card_state
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"critical section loop"
argument_list|)
expr_stmt|;
block|}
name|steps
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|AHD_DEBUG
if|if
condition|(
operator|(
name|ahd_debug
operator|&
name|AHD_SHOW_MISC
operator|)
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|"%s: Single stepping at 0x%x\n"
argument_list|,
name|ahd_name
argument_list|(
name|ahd
argument_list|)
argument_list|,
name|seqaddr
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|stepping
operator|==
name|FALSE
condition|)
block|{
name|first_instr
operator|=
name|seqaddr
expr_stmt|;
name|ahd_set_modes
argument_list|(
name|ahd
argument_list|,
name|AHD_MODE_CFG
argument_list|,
name|AHD_MODE_CFG
argument_list|)
expr_stmt|;
name|simode0
operator|=
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|SIMODE0
argument_list|)
expr_stmt|;
name|simode3
operator|=
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|SIMODE3
argument_list|)
expr_stmt|;
name|lqimode0
operator|=
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|LQIMODE0
argument_list|)
expr_stmt|;
name|lqimode1
operator|=
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|LQIMODE1
argument_list|)
expr_stmt|;
name|lqomode0
operator|=
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|LQOMODE0
argument_list|)
expr_stmt|;
name|lqomode1
operator|=
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|LQOMODE1
argument_list|)
expr_stmt|;
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|SIMODE0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|SIMODE3
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|LQIMODE0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|LQIMODE1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|LQOMODE0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|LQOMODE1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ahd_set_modes
argument_list|(
name|ahd
argument_list|,
name|AHD_MODE_SCSI
argument_list|,
name|AHD_MODE_SCSI
argument_list|)
expr_stmt|;
name|simode1
operator|=
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|SIMODE1
argument_list|)
expr_stmt|;
comment|/* 			 * We don't clear ENBUSFREE.  Unfortunately 			 * we cannot re-enable busfree detection within 			 * the current connection, so we must leave it 			 * on while single stepping. 			 */
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|SIMODE1
argument_list|,
name|simode1
operator|&
name|ENBUSFREE
argument_list|)
expr_stmt|;
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|SEQCTL0
argument_list|,
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|SEQCTL0
argument_list|)
operator||
name|STEP
argument_list|)
expr_stmt|;
name|stepping
operator|=
name|TRUE
expr_stmt|;
block|}
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|CLRSINT1
argument_list|,
name|CLRBUSFREE
argument_list|)
expr_stmt|;
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|CLRINT
argument_list|,
name|CLRSCSIINT
argument_list|)
expr_stmt|;
name|ahd_set_modes
argument_list|(
name|ahd
argument_list|,
name|ahd
operator|->
name|saved_src_mode
argument_list|,
name|ahd
operator|->
name|saved_dst_mode
argument_list|)
expr_stmt|;
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|HCNTRL
argument_list|,
name|ahd
operator|->
name|unpause
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|ahd_is_paused
argument_list|(
name|ahd
argument_list|)
condition|)
name|aic_delay
argument_list|(
literal|200
argument_list|)
expr_stmt|;
name|ahd_update_modes
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|stepping
condition|)
block|{
name|ahd_set_modes
argument_list|(
name|ahd
argument_list|,
name|AHD_MODE_CFG
argument_list|,
name|AHD_MODE_CFG
argument_list|)
expr_stmt|;
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|SIMODE0
argument_list|,
name|simode0
argument_list|)
expr_stmt|;
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|SIMODE3
argument_list|,
name|simode3
argument_list|)
expr_stmt|;
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|LQIMODE0
argument_list|,
name|lqimode0
argument_list|)
expr_stmt|;
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|LQIMODE1
argument_list|,
name|lqimode1
argument_list|)
expr_stmt|;
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|LQOMODE0
argument_list|,
name|lqomode0
argument_list|)
expr_stmt|;
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|LQOMODE1
argument_list|,
name|lqomode1
argument_list|)
expr_stmt|;
name|ahd_set_modes
argument_list|(
name|ahd
argument_list|,
name|AHD_MODE_SCSI
argument_list|,
name|AHD_MODE_SCSI
argument_list|)
expr_stmt|;
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|SEQCTL0
argument_list|,
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|SEQCTL0
argument_list|)
operator|&
operator|~
name|STEP
argument_list|)
expr_stmt|;
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|SIMODE1
argument_list|,
name|simode1
argument_list|)
expr_stmt|;
comment|/* 		 * SCSIINT seems to glitch occassionally when 		 * the interrupt masks are restored.  Clear SCSIINT 		 * one more time so that only persistent errors 		 * are seen as a real interrupt. 		 */
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|CLRINT
argument_list|,
name|CLRSCSIINT
argument_list|)
expr_stmt|;
block|}
name|ahd_restore_modes
argument_list|(
name|ahd
argument_list|,
name|saved_modes
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Clear any pending interrupt status.  */
end_comment

begin_function
name|void
name|ahd_clear_intstat
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|)
block|{
name|AHD_ASSERT_MODES
argument_list|(
name|ahd
argument_list|,
operator|~
operator|(
name|AHD_MODE_UNKNOWN_MSK
operator||
name|AHD_MODE_CFG_MSK
operator|)
argument_list|,
operator|~
operator|(
name|AHD_MODE_UNKNOWN_MSK
operator||
name|AHD_MODE_CFG_MSK
operator|)
argument_list|)
expr_stmt|;
comment|/* Clear any interrupt conditions this may have caused */
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|CLRLQIINT0
argument_list|,
name|CLRLQIATNQAS
operator||
name|CLRLQICRCT1
operator||
name|CLRLQICRCT2
operator||
name|CLRLQIBADLQT
operator||
name|CLRLQIATNLQ
operator||
name|CLRLQIATNCMD
argument_list|)
expr_stmt|;
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|CLRLQIINT1
argument_list|,
name|CLRLQIPHASE_LQ
operator||
name|CLRLQIPHASE_NLQ
operator||
name|CLRLIQABORT
operator||
name|CLRLQICRCI_LQ
operator||
name|CLRLQICRCI_NLQ
operator||
name|CLRLQIBADLQI
operator||
name|CLRLQIOVERI_LQ
operator||
name|CLRLQIOVERI_NLQ
operator||
name|CLRNONPACKREQ
argument_list|)
expr_stmt|;
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|CLRLQOINT0
argument_list|,
name|CLRLQOTARGSCBPERR
operator||
name|CLRLQOSTOPT2
operator||
name|CLRLQOATNLQ
operator||
name|CLRLQOATNPKT
operator||
name|CLRLQOTCRC
argument_list|)
expr_stmt|;
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|CLRLQOINT1
argument_list|,
name|CLRLQOINITSCBPERR
operator||
name|CLRLQOSTOPI2
operator||
name|CLRLQOBADQAS
operator||
name|CLRLQOBUSFREE
operator||
name|CLRLQOPHACHGINPKT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ahd
operator|->
name|bugs
operator|&
name|AHD_CLRLQO_AUTOCLR_BUG
operator|)
operator|!=
literal|0
condition|)
block|{
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|CLRLQOINT0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|CLRLQOINT1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|CLRSINT3
argument_list|,
name|CLRNTRAMPERR
operator||
name|CLROSRAMPERR
argument_list|)
expr_stmt|;
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|CLRSINT1
argument_list|,
name|CLRSELTIMEO
operator||
name|CLRATNO
operator||
name|CLRSCSIRSTI
operator||
name|CLRBUSFREE
operator||
name|CLRSCSIPERR
operator||
name|CLRREQINIT
argument_list|)
expr_stmt|;
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|CLRSINT0
argument_list|,
name|CLRSELDO
operator||
name|CLRSELDI
operator||
name|CLRSELINGO
operator||
name|CLRIOERR
operator||
name|CLROVERRUN
argument_list|)
expr_stmt|;
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|CLRINT
argument_list|,
name|CLRSCSIINT
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**************************** Debugging Routines ******************************/
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|AHD_DEBUG
end_ifdef

begin_decl_stmt
name|uint32_t
name|ahd_debug
init|=
name|AHD_DEBUG_OPTS
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|ahd_print_scb
parameter_list|(
name|struct
name|scb
modifier|*
name|scb
parameter_list|)
block|{
name|struct
name|hardware_scb
modifier|*
name|hscb
decl_stmt|;
name|int
name|i
decl_stmt|;
name|hscb
operator|=
name|scb
operator|->
name|hscb
expr_stmt|;
name|printf
argument_list|(
literal|"scb:%p control:0x%x scsiid:0x%x lun:%d cdb_len:%d\n"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|scb
argument_list|,
name|hscb
operator|->
name|control
argument_list|,
name|hscb
operator|->
name|scsiid
argument_list|,
name|hscb
operator|->
name|lun
argument_list|,
name|hscb
operator|->
name|cdb_len
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Shared Data: "
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|hscb
operator|->
name|shared_data
operator|.
name|idata
operator|.
name|cdb
argument_list|)
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|"%#02x"
argument_list|,
name|hscb
operator|->
name|shared_data
operator|.
name|idata
operator|.
name|cdb
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"        dataptr:%#x%x datacnt:%#x sgptr:%#x tag:%#x\n"
argument_list|,
call|(
name|uint32_t
call|)
argument_list|(
operator|(
name|aic_le64toh
argument_list|(
name|hscb
operator|->
name|dataptr
argument_list|)
operator|>>
literal|32
operator|)
operator|&
literal|0xFFFFFFFF
argument_list|)
argument_list|,
call|(
name|uint32_t
call|)
argument_list|(
name|aic_le64toh
argument_list|(
name|hscb
operator|->
name|dataptr
argument_list|)
operator|&
literal|0xFFFFFFFF
argument_list|)
argument_list|,
name|aic_le32toh
argument_list|(
name|hscb
operator|->
name|datacnt
argument_list|)
argument_list|,
name|aic_le32toh
argument_list|(
name|hscb
operator|->
name|sgptr
argument_list|)
argument_list|,
name|SCB_GET_TAG
argument_list|(
name|scb
argument_list|)
argument_list|)
expr_stmt|;
name|ahd_dump_sglist
argument_list|(
name|scb
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ahd_dump_sglist
parameter_list|(
name|struct
name|scb
modifier|*
name|scb
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|scb
operator|->
name|sg_count
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|scb
operator|->
name|ahd_softc
operator|->
name|flags
operator|&
name|AHD_64BIT_ADDRESSING
operator|)
operator|!=
literal|0
condition|)
block|{
name|struct
name|ahd_dma64_seg
modifier|*
name|sg_list
decl_stmt|;
name|sg_list
operator|=
operator|(
expr|struct
name|ahd_dma64_seg
operator|*
operator|)
name|scb
operator|->
name|sg_list
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|scb
operator|->
name|sg_count
condition|;
name|i
operator|++
control|)
block|{
name|uint64_t
name|addr
decl_stmt|;
name|uint32_t
name|len
decl_stmt|;
name|addr
operator|=
name|aic_le64toh
argument_list|(
name|sg_list
index|[
name|i
index|]
operator|.
name|addr
argument_list|)
expr_stmt|;
name|len
operator|=
name|aic_le32toh
argument_list|(
name|sg_list
index|[
name|i
index|]
operator|.
name|len
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"sg[%d] - Addr 0x%x%x : Length %d%s\n"
argument_list|,
name|i
argument_list|,
call|(
name|uint32_t
call|)
argument_list|(
operator|(
name|addr
operator|>>
literal|32
operator|)
operator|&
literal|0xFFFFFFFF
argument_list|)
argument_list|,
call|(
name|uint32_t
call|)
argument_list|(
name|addr
operator|&
literal|0xFFFFFFFF
argument_list|)
argument_list|,
name|sg_list
index|[
name|i
index|]
operator|.
name|len
operator|&
name|AHD_SG_LEN_MASK
argument_list|,
operator|(
name|sg_list
index|[
name|i
index|]
operator|.
name|len
operator|&
name|AHD_DMA_LAST_SEG
operator|)
condition|?
literal|" Last"
else|:
literal|""
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|struct
name|ahd_dma_seg
modifier|*
name|sg_list
decl_stmt|;
name|sg_list
operator|=
operator|(
expr|struct
name|ahd_dma_seg
operator|*
operator|)
name|scb
operator|->
name|sg_list
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|scb
operator|->
name|sg_count
condition|;
name|i
operator|++
control|)
block|{
name|uint32_t
name|len
decl_stmt|;
name|len
operator|=
name|aic_le32toh
argument_list|(
name|sg_list
index|[
name|i
index|]
operator|.
name|len
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"sg[%d] - Addr 0x%x%x : Length %d%s\n"
argument_list|,
name|i
argument_list|,
operator|(
name|len
operator|&
name|AHD_SG_HIGH_ADDR_MASK
operator|)
operator|>>
literal|24
argument_list|,
name|aic_le32toh
argument_list|(
name|sg_list
index|[
name|i
index|]
operator|.
name|addr
argument_list|)
argument_list|,
name|len
operator|&
name|AHD_SG_LEN_MASK
argument_list|,
name|len
operator|&
name|AHD_DMA_LAST_SEG
condition|?
literal|" Last"
else|:
literal|""
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/************************* Transfer Negotiation *******************************/
end_comment

begin_comment
comment|/*  * Allocate per target mode instance (ID we respond to as a target)  * transfer negotiation data structures.  */
end_comment

begin_function
specifier|static
name|struct
name|ahd_tmode_tstate
modifier|*
name|ahd_alloc_tstate
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|,
name|u_int
name|scsi_id
parameter_list|,
name|char
name|channel
parameter_list|)
block|{
name|struct
name|ahd_tmode_tstate
modifier|*
name|master_tstate
decl_stmt|;
name|struct
name|ahd_tmode_tstate
modifier|*
name|tstate
decl_stmt|;
name|int
name|i
decl_stmt|;
name|master_tstate
operator|=
name|ahd
operator|->
name|enabled_targets
index|[
name|ahd
operator|->
name|our_id
index|]
expr_stmt|;
if|if
condition|(
name|ahd
operator|->
name|enabled_targets
index|[
name|scsi_id
index|]
operator|!=
name|NULL
operator|&&
name|ahd
operator|->
name|enabled_targets
index|[
name|scsi_id
index|]
operator|!=
name|master_tstate
condition|)
name|panic
argument_list|(
literal|"%s: ahd_alloc_tstate - Target already allocated"
argument_list|,
name|ahd_name
argument_list|(
name|ahd
argument_list|)
argument_list|)
expr_stmt|;
name|tstate
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|tstate
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|tstate
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* 	 * If we have allocated a master tstate, copy user settings from 	 * the master tstate (taken from SRAM or the EEPROM) for this 	 * channel, but reset our current and goal settings to async/narrow 	 * until an initiator talks to us. 	 */
if|if
condition|(
name|master_tstate
operator|!=
name|NULL
condition|)
block|{
name|memcpy
argument_list|(
name|tstate
argument_list|,
name|master_tstate
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|tstate
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|tstate
operator|->
name|enabled_luns
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|tstate
operator|->
name|enabled_luns
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
block|{
name|memset
argument_list|(
operator|&
name|tstate
operator|->
name|transinfo
index|[
name|i
index|]
operator|.
name|curr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|tstate
operator|->
name|transinfo
index|[
name|i
index|]
operator|.
name|curr
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|tstate
operator|->
name|transinfo
index|[
name|i
index|]
operator|.
name|goal
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|tstate
operator|->
name|transinfo
index|[
name|i
index|]
operator|.
name|goal
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|memset
argument_list|(
name|tstate
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|tstate
argument_list|)
argument_list|)
expr_stmt|;
name|ahd
operator|->
name|enabled_targets
index|[
name|scsi_id
index|]
operator|=
name|tstate
expr_stmt|;
return|return
operator|(
name|tstate
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|AHD_TARGET_MODE
end_ifdef

begin_comment
comment|/*  * Free per target mode instance (ID we respond to as a target)  * transfer negotiation data structures.  */
end_comment

begin_function
specifier|static
name|void
name|ahd_free_tstate
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|,
name|u_int
name|scsi_id
parameter_list|,
name|char
name|channel
parameter_list|,
name|int
name|force
parameter_list|)
block|{
name|struct
name|ahd_tmode_tstate
modifier|*
name|tstate
decl_stmt|;
comment|/* 	 * Don't clean up our "master" tstate. 	 * It has our default user settings. 	 */
if|if
condition|(
name|scsi_id
operator|==
name|ahd
operator|->
name|our_id
operator|&&
name|force
operator|==
name|FALSE
condition|)
return|return;
name|tstate
operator|=
name|ahd
operator|->
name|enabled_targets
index|[
name|scsi_id
index|]
expr_stmt|;
if|if
condition|(
name|tstate
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|tstate
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|ahd
operator|->
name|enabled_targets
index|[
name|scsi_id
index|]
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Called when we have an active connection to a target on the bus,  * this function finds the nearest period to the input period limited  * by the capabilities of the bus connectivity of and sync settings for  * the target.  */
end_comment

begin_function
name|void
name|ahd_devlimited_syncrate
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|,
name|struct
name|ahd_initiator_tinfo
modifier|*
name|tinfo
parameter_list|,
name|u_int
modifier|*
name|period
parameter_list|,
name|u_int
modifier|*
name|ppr_options
parameter_list|,
name|role_t
name|role
parameter_list|)
block|{
name|struct
name|ahd_transinfo
modifier|*
name|transinfo
decl_stmt|;
name|u_int
name|maxsync
decl_stmt|;
if|if
condition|(
operator|(
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|SBLKCTL
argument_list|)
operator|&
name|ENAB40
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|SSTAT2
argument_list|)
operator|&
name|EXP_ACTIVE
operator|)
operator|==
literal|0
condition|)
block|{
name|maxsync
operator|=
name|AHD_SYNCRATE_PACED
expr_stmt|;
block|}
else|else
block|{
name|maxsync
operator|=
name|AHD_SYNCRATE_ULTRA
expr_stmt|;
comment|/* Can't do DT related options on an SE bus */
operator|*
name|ppr_options
operator|&=
name|MSG_EXT_PPR_QAS_REQ
expr_stmt|;
block|}
comment|/* 	 * Never allow a value higher than our current goal 	 * period otherwise we may allow a target initiated 	 * negotiation to go above the limit as set by the 	 * user.  In the case of an initiator initiated 	 * sync negotiation, we limit based on the user 	 * setting.  This allows the system to still accept 	 * incoming negotiations even if target initiated 	 * negotiation is not performed. 	 */
if|if
condition|(
name|role
operator|==
name|ROLE_TARGET
condition|)
name|transinfo
operator|=
operator|&
name|tinfo
operator|->
name|user
expr_stmt|;
else|else
name|transinfo
operator|=
operator|&
name|tinfo
operator|->
name|goal
expr_stmt|;
operator|*
name|ppr_options
operator|&=
operator|(
name|transinfo
operator|->
name|ppr_options
operator||
name|MSG_EXT_PPR_PCOMP_EN
operator|)
expr_stmt|;
if|if
condition|(
name|transinfo
operator|->
name|width
operator|==
name|MSG_EXT_WDTR_BUS_8_BIT
condition|)
block|{
name|maxsync
operator|=
name|MAX
argument_list|(
name|maxsync
argument_list|,
name|AHD_SYNCRATE_ULTRA2
argument_list|)
expr_stmt|;
operator|*
name|ppr_options
operator|&=
operator|~
name|MSG_EXT_PPR_DT_REQ
expr_stmt|;
block|}
if|if
condition|(
name|transinfo
operator|->
name|period
operator|==
literal|0
condition|)
block|{
operator|*
name|period
operator|=
literal|0
expr_stmt|;
operator|*
name|ppr_options
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
operator|*
name|period
operator|=
name|MAX
argument_list|(
operator|*
name|period
argument_list|,
name|transinfo
operator|->
name|period
argument_list|)
expr_stmt|;
name|ahd_find_syncrate
argument_list|(
name|ahd
argument_list|,
name|period
argument_list|,
name|ppr_options
argument_list|,
name|maxsync
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Look up the valid period to SCSIRATE conversion in our table.  * Return the period and offset that should be sent to the target  * if this was the beginning of an SDTR.  */
end_comment

begin_function
name|void
name|ahd_find_syncrate
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|,
name|u_int
modifier|*
name|period
parameter_list|,
name|u_int
modifier|*
name|ppr_options
parameter_list|,
name|u_int
name|maxsync
parameter_list|)
block|{
if|if
condition|(
operator|*
name|period
operator|<
name|maxsync
condition|)
operator|*
name|period
operator|=
name|maxsync
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|ppr_options
operator|&
name|MSG_EXT_PPR_DT_REQ
operator|)
operator|!=
literal|0
operator|&&
operator|*
name|period
operator|>
name|AHD_SYNCRATE_MIN_DT
condition|)
operator|*
name|ppr_options
operator|&=
operator|~
name|MSG_EXT_PPR_DT_REQ
expr_stmt|;
if|if
condition|(
operator|*
name|period
operator|>
name|AHD_SYNCRATE_MIN
condition|)
operator|*
name|period
operator|=
literal|0
expr_stmt|;
comment|/* Honor PPR option conformance rules. */
if|if
condition|(
operator|*
name|period
operator|>
name|AHD_SYNCRATE_PACED
condition|)
operator|*
name|ppr_options
operator|&=
operator|~
name|MSG_EXT_PPR_RTI
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|ppr_options
operator|&
name|MSG_EXT_PPR_IU_REQ
operator|)
operator|==
literal|0
condition|)
operator|*
name|ppr_options
operator|&=
operator|(
name|MSG_EXT_PPR_DT_REQ
operator||
name|MSG_EXT_PPR_QAS_REQ
operator|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|ppr_options
operator|&
name|MSG_EXT_PPR_DT_REQ
operator|)
operator|==
literal|0
condition|)
operator|*
name|ppr_options
operator|&=
name|MSG_EXT_PPR_QAS_REQ
expr_stmt|;
comment|/* Skip all PACED only entries if IU is not available */
if|if
condition|(
operator|(
operator|*
name|ppr_options
operator|&
name|MSG_EXT_PPR_IU_REQ
operator|)
operator|==
literal|0
operator|&&
operator|*
name|period
operator|<
name|AHD_SYNCRATE_DT
condition|)
operator|*
name|period
operator|=
name|AHD_SYNCRATE_DT
expr_stmt|;
comment|/* Skip all DT only entries if DT is not available */
if|if
condition|(
operator|(
operator|*
name|ppr_options
operator|&
name|MSG_EXT_PPR_DT_REQ
operator|)
operator|==
literal|0
operator|&&
operator|*
name|period
operator|<
name|AHD_SYNCRATE_ULTRA2
condition|)
operator|*
name|period
operator|=
name|AHD_SYNCRATE_ULTRA2
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Truncate the given synchronous offset to a value the  * current adapter type and syncrate are capable of.  */
end_comment

begin_function
name|void
name|ahd_validate_offset
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|,
name|struct
name|ahd_initiator_tinfo
modifier|*
name|tinfo
parameter_list|,
name|u_int
name|period
parameter_list|,
name|u_int
modifier|*
name|offset
parameter_list|,
name|int
name|wide
parameter_list|,
name|role_t
name|role
parameter_list|)
block|{
name|u_int
name|maxoffset
decl_stmt|;
comment|/* Limit offset to what we can do */
if|if
condition|(
name|period
operator|==
literal|0
condition|)
name|maxoffset
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|period
operator|<=
name|AHD_SYNCRATE_PACED
condition|)
block|{
if|if
condition|(
operator|(
name|ahd
operator|->
name|bugs
operator|&
name|AHD_PACED_NEGTABLE_BUG
operator|)
operator|!=
literal|0
condition|)
name|maxoffset
operator|=
name|MAX_OFFSET_PACED_BUG
expr_stmt|;
else|else
name|maxoffset
operator|=
name|MAX_OFFSET_PACED
expr_stmt|;
block|}
else|else
name|maxoffset
operator|=
name|MAX_OFFSET_NON_PACED
expr_stmt|;
operator|*
name|offset
operator|=
name|MIN
argument_list|(
operator|*
name|offset
argument_list|,
name|maxoffset
argument_list|)
expr_stmt|;
if|if
condition|(
name|tinfo
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|role
operator|==
name|ROLE_TARGET
condition|)
operator|*
name|offset
operator|=
name|MIN
argument_list|(
operator|*
name|offset
argument_list|,
name|tinfo
operator|->
name|user
operator|.
name|offset
argument_list|)
expr_stmt|;
else|else
operator|*
name|offset
operator|=
name|MIN
argument_list|(
operator|*
name|offset
argument_list|,
name|tinfo
operator|->
name|goal
operator|.
name|offset
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Truncate the given transfer width parameter to a value the  * current adapter type is capable of.  */
end_comment

begin_function
name|void
name|ahd_validate_width
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|,
name|struct
name|ahd_initiator_tinfo
modifier|*
name|tinfo
parameter_list|,
name|u_int
modifier|*
name|bus_width
parameter_list|,
name|role_t
name|role
parameter_list|)
block|{
switch|switch
condition|(
operator|*
name|bus_width
condition|)
block|{
default|default:
if|if
condition|(
name|ahd
operator|->
name|features
operator|&
name|AHD_WIDE
condition|)
block|{
comment|/* Respond Wide */
operator|*
name|bus_width
operator|=
name|MSG_EXT_WDTR_BUS_16_BIT
expr_stmt|;
break|break;
block|}
comment|/* FALLTHROUGH */
case|case
name|MSG_EXT_WDTR_BUS_8_BIT
case|:
operator|*
name|bus_width
operator|=
name|MSG_EXT_WDTR_BUS_8_BIT
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|tinfo
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|role
operator|==
name|ROLE_TARGET
condition|)
operator|*
name|bus_width
operator|=
name|MIN
argument_list|(
name|tinfo
operator|->
name|user
operator|.
name|width
argument_list|,
operator|*
name|bus_width
argument_list|)
expr_stmt|;
else|else
operator|*
name|bus_width
operator|=
name|MIN
argument_list|(
name|tinfo
operator|->
name|goal
operator|.
name|width
argument_list|,
operator|*
name|bus_width
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Update the bitmask of targets for which the controller should  * negotiate with at the next convenient oportunity.  This currently  * means the next time we send the initial identify messages for  * a new transaction.  */
end_comment

begin_function
name|int
name|ahd_update_neg_request
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|,
name|struct
name|ahd_devinfo
modifier|*
name|devinfo
parameter_list|,
name|struct
name|ahd_tmode_tstate
modifier|*
name|tstate
parameter_list|,
name|struct
name|ahd_initiator_tinfo
modifier|*
name|tinfo
parameter_list|,
name|ahd_neg_type
name|neg_type
parameter_list|)
block|{
name|u_int
name|auto_negotiate_orig
decl_stmt|;
name|auto_negotiate_orig
operator|=
name|tstate
operator|->
name|auto_negotiate
expr_stmt|;
if|if
condition|(
name|neg_type
operator|==
name|AHD_NEG_ALWAYS
condition|)
block|{
comment|/* 		 * Force our "current" settings to be 		 * unknown so that unless a bus reset 		 * occurs the need to renegotiate is 		 * recorded persistently. 		 */
if|if
condition|(
operator|(
name|ahd
operator|->
name|features
operator|&
name|AHD_WIDE
operator|)
operator|!=
literal|0
condition|)
name|tinfo
operator|->
name|curr
operator|.
name|width
operator|=
name|AHD_WIDTH_UNKNOWN
expr_stmt|;
name|tinfo
operator|->
name|curr
operator|.
name|period
operator|=
name|AHD_PERIOD_UNKNOWN
expr_stmt|;
name|tinfo
operator|->
name|curr
operator|.
name|offset
operator|=
name|AHD_OFFSET_UNKNOWN
expr_stmt|;
block|}
if|if
condition|(
name|tinfo
operator|->
name|curr
operator|.
name|period
operator|!=
name|tinfo
operator|->
name|goal
operator|.
name|period
operator|||
name|tinfo
operator|->
name|curr
operator|.
name|width
operator|!=
name|tinfo
operator|->
name|goal
operator|.
name|width
operator|||
name|tinfo
operator|->
name|curr
operator|.
name|offset
operator|!=
name|tinfo
operator|->
name|goal
operator|.
name|offset
operator|||
name|tinfo
operator|->
name|curr
operator|.
name|ppr_options
operator|!=
name|tinfo
operator|->
name|goal
operator|.
name|ppr_options
operator|||
operator|(
name|neg_type
operator|==
name|AHD_NEG_IF_NON_ASYNC
operator|&&
operator|(
name|tinfo
operator|->
name|goal
operator|.
name|offset
operator|!=
literal|0
operator|||
name|tinfo
operator|->
name|goal
operator|.
name|width
operator|!=
name|MSG_EXT_WDTR_BUS_8_BIT
operator|||
name|tinfo
operator|->
name|goal
operator|.
name|ppr_options
operator|!=
literal|0
operator|)
operator|)
condition|)
name|tstate
operator|->
name|auto_negotiate
operator||=
name|devinfo
operator|->
name|target_mask
expr_stmt|;
else|else
name|tstate
operator|->
name|auto_negotiate
operator|&=
operator|~
name|devinfo
operator|->
name|target_mask
expr_stmt|;
return|return
operator|(
name|auto_negotiate_orig
operator|!=
name|tstate
operator|->
name|auto_negotiate
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Update the user/goal/curr tables of synchronous negotiation  * parameters as well as, in the case of a current or active update,  * any data structures on the host controller.  In the case of an  * active update, the specified target is currently talking to us on  * the bus, so the transfer parameter update must take effect  * immediately.  */
end_comment

begin_function
name|void
name|ahd_set_syncrate
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|,
name|struct
name|ahd_devinfo
modifier|*
name|devinfo
parameter_list|,
name|u_int
name|period
parameter_list|,
name|u_int
name|offset
parameter_list|,
name|u_int
name|ppr_options
parameter_list|,
name|u_int
name|type
parameter_list|,
name|int
name|paused
parameter_list|)
block|{
name|struct
name|ahd_initiator_tinfo
modifier|*
name|tinfo
decl_stmt|;
name|struct
name|ahd_tmode_tstate
modifier|*
name|tstate
decl_stmt|;
name|u_int
name|old_period
decl_stmt|;
name|u_int
name|old_offset
decl_stmt|;
name|u_int
name|old_ppr
decl_stmt|;
name|int
name|active
decl_stmt|;
name|int
name|update_needed
decl_stmt|;
name|active
operator|=
operator|(
name|type
operator|&
name|AHD_TRANS_ACTIVE
operator|)
operator|==
name|AHD_TRANS_ACTIVE
expr_stmt|;
name|update_needed
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|period
operator|==
literal|0
operator|||
name|offset
operator|==
literal|0
condition|)
block|{
name|period
operator|=
literal|0
expr_stmt|;
name|offset
operator|=
literal|0
expr_stmt|;
block|}
name|tinfo
operator|=
name|ahd_fetch_transinfo
argument_list|(
name|ahd
argument_list|,
name|devinfo
operator|->
name|channel
argument_list|,
name|devinfo
operator|->
name|our_scsiid
argument_list|,
name|devinfo
operator|->
name|target
argument_list|,
operator|&
name|tstate
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|type
operator|&
name|AHD_TRANS_USER
operator|)
operator|!=
literal|0
condition|)
block|{
name|tinfo
operator|->
name|user
operator|.
name|period
operator|=
name|period
expr_stmt|;
name|tinfo
operator|->
name|user
operator|.
name|offset
operator|=
name|offset
expr_stmt|;
name|tinfo
operator|->
name|user
operator|.
name|ppr_options
operator|=
name|ppr_options
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|type
operator|&
name|AHD_TRANS_GOAL
operator|)
operator|!=
literal|0
condition|)
block|{
name|tinfo
operator|->
name|goal
operator|.
name|period
operator|=
name|period
expr_stmt|;
name|tinfo
operator|->
name|goal
operator|.
name|offset
operator|=
name|offset
expr_stmt|;
name|tinfo
operator|->
name|goal
operator|.
name|ppr_options
operator|=
name|ppr_options
expr_stmt|;
block|}
name|old_period
operator|=
name|tinfo
operator|->
name|curr
operator|.
name|period
expr_stmt|;
name|old_offset
operator|=
name|tinfo
operator|->
name|curr
operator|.
name|offset
expr_stmt|;
name|old_ppr
operator|=
name|tinfo
operator|->
name|curr
operator|.
name|ppr_options
expr_stmt|;
if|if
condition|(
operator|(
name|type
operator|&
name|AHD_TRANS_CUR
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|old_period
operator|!=
name|period
operator|||
name|old_offset
operator|!=
name|offset
operator|||
name|old_ppr
operator|!=
name|ppr_options
operator|)
condition|)
block|{
name|update_needed
operator|++
expr_stmt|;
name|tinfo
operator|->
name|curr
operator|.
name|period
operator|=
name|period
expr_stmt|;
name|tinfo
operator|->
name|curr
operator|.
name|offset
operator|=
name|offset
expr_stmt|;
name|tinfo
operator|->
name|curr
operator|.
name|ppr_options
operator|=
name|ppr_options
expr_stmt|;
name|ahd_send_async
argument_list|(
name|ahd
argument_list|,
name|devinfo
operator|->
name|channel
argument_list|,
name|devinfo
operator|->
name|target
argument_list|,
name|CAM_LUN_WILDCARD
argument_list|,
name|AC_TRANSFER_NEG
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
block|{
if|if
condition|(
name|offset
operator|!=
literal|0
condition|)
block|{
name|int
name|options
decl_stmt|;
name|printf
argument_list|(
literal|"%s: target %d synchronous with "
literal|"period = 0x%x, offset = 0x%x"
argument_list|,
name|ahd_name
argument_list|(
name|ahd
argument_list|)
argument_list|,
name|devinfo
operator|->
name|target
argument_list|,
name|period
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|options
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|ppr_options
operator|&
name|MSG_EXT_PPR_RD_STRM
operator|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"(RDSTRM"
argument_list|)
expr_stmt|;
name|options
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|ppr_options
operator|&
name|MSG_EXT_PPR_DT_REQ
operator|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|options
condition|?
literal|"|DT"
else|:
literal|"(DT"
argument_list|)
expr_stmt|;
name|options
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|ppr_options
operator|&
name|MSG_EXT_PPR_IU_REQ
operator|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|options
condition|?
literal|"|IU"
else|:
literal|"(IU"
argument_list|)
expr_stmt|;
name|options
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|ppr_options
operator|&
name|MSG_EXT_PPR_RTI
operator|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|options
condition|?
literal|"|RTI"
else|:
literal|"(RTI"
argument_list|)
expr_stmt|;
name|options
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|ppr_options
operator|&
name|MSG_EXT_PPR_QAS_REQ
operator|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|options
condition|?
literal|"|QAS"
else|:
literal|"(QAS"
argument_list|)
expr_stmt|;
name|options
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|options
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|")\n"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"%s: target %d using "
literal|"asynchronous transfers%s\n"
argument_list|,
name|ahd_name
argument_list|(
name|ahd
argument_list|)
argument_list|,
name|devinfo
operator|->
name|target
argument_list|,
operator|(
name|ppr_options
operator|&
name|MSG_EXT_PPR_QAS_REQ
operator|)
operator|!=
literal|0
condition|?
literal|"(QAS)"
else|:
literal|""
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* 	 * Always refresh the neg-table to handle the case of the 	 * sequencer setting the ENATNO bit for a MK_MESSAGE request. 	 * We will always renegotiate in that case if this is a 	 * packetized request.  Also manage the busfree expected flag 	 * from this common routine so that we catch changes due to 	 * WDTR or SDTR messages. 	 */
if|if
condition|(
operator|(
name|type
operator|&
name|AHD_TRANS_CUR
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|paused
condition|)
name|ahd_pause
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
name|ahd_update_neg_table
argument_list|(
name|ahd
argument_list|,
name|devinfo
argument_list|,
operator|&
name|tinfo
operator|->
name|curr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|paused
condition|)
name|ahd_unpause
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
if|if
condition|(
name|ahd
operator|->
name|msg_type
operator|!=
name|MSG_TYPE_NONE
condition|)
block|{
if|if
condition|(
operator|(
name|old_ppr
operator|&
name|MSG_EXT_PPR_IU_REQ
operator|)
operator|!=
operator|(
name|ppr_options
operator|&
name|MSG_EXT_PPR_IU_REQ
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|AHD_DEBUG
if|if
condition|(
operator|(
name|ahd_debug
operator|&
name|AHD_SHOW_MESSAGES
operator|)
operator|!=
literal|0
condition|)
block|{
name|ahd_print_devinfo
argument_list|(
name|ahd
argument_list|,
name|devinfo
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Expecting IU Change busfree\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|ahd
operator|->
name|msg_flags
operator||=
name|MSG_FLAG_EXPECT_PPR_BUSFREE
operator||
name|MSG_FLAG_IU_REQ_CHANGED
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|old_ppr
operator|&
name|MSG_EXT_PPR_IU_REQ
operator|)
operator|!=
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|AHD_DEBUG
if|if
condition|(
operator|(
name|ahd_debug
operator|&
name|AHD_SHOW_MESSAGES
operator|)
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|"PPR with IU_REQ outstanding\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ahd
operator|->
name|msg_flags
operator||=
name|MSG_FLAG_EXPECT_PPR_BUSFREE
expr_stmt|;
block|}
block|}
block|}
name|update_needed
operator|+=
name|ahd_update_neg_request
argument_list|(
name|ahd
argument_list|,
name|devinfo
argument_list|,
name|tstate
argument_list|,
name|tinfo
argument_list|,
name|AHD_NEG_TO_GOAL
argument_list|)
expr_stmt|;
if|if
condition|(
name|update_needed
operator|&&
name|active
condition|)
name|ahd_update_pending_scbs
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Update the user/goal/curr tables of wide negotiation  * parameters as well as, in the case of a current or active update,  * any data structures on the host controller.  In the case of an  * active update, the specified target is currently talking to us on  * the bus, so the transfer parameter update must take effect  * immediately.  */
end_comment

begin_function
name|void
name|ahd_set_width
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|,
name|struct
name|ahd_devinfo
modifier|*
name|devinfo
parameter_list|,
name|u_int
name|width
parameter_list|,
name|u_int
name|type
parameter_list|,
name|int
name|paused
parameter_list|)
block|{
name|struct
name|ahd_initiator_tinfo
modifier|*
name|tinfo
decl_stmt|;
name|struct
name|ahd_tmode_tstate
modifier|*
name|tstate
decl_stmt|;
name|u_int
name|oldwidth
decl_stmt|;
name|int
name|active
decl_stmt|;
name|int
name|update_needed
decl_stmt|;
name|active
operator|=
operator|(
name|type
operator|&
name|AHD_TRANS_ACTIVE
operator|)
operator|==
name|AHD_TRANS_ACTIVE
expr_stmt|;
name|update_needed
operator|=
literal|0
expr_stmt|;
name|tinfo
operator|=
name|ahd_fetch_transinfo
argument_list|(
name|ahd
argument_list|,
name|devinfo
operator|->
name|channel
argument_list|,
name|devinfo
operator|->
name|our_scsiid
argument_list|,
name|devinfo
operator|->
name|target
argument_list|,
operator|&
name|tstate
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|type
operator|&
name|AHD_TRANS_USER
operator|)
operator|!=
literal|0
condition|)
name|tinfo
operator|->
name|user
operator|.
name|width
operator|=
name|width
expr_stmt|;
if|if
condition|(
operator|(
name|type
operator|&
name|AHD_TRANS_GOAL
operator|)
operator|!=
literal|0
condition|)
name|tinfo
operator|->
name|goal
operator|.
name|width
operator|=
name|width
expr_stmt|;
name|oldwidth
operator|=
name|tinfo
operator|->
name|curr
operator|.
name|width
expr_stmt|;
if|if
condition|(
operator|(
name|type
operator|&
name|AHD_TRANS_CUR
operator|)
operator|!=
literal|0
operator|&&
name|oldwidth
operator|!=
name|width
condition|)
block|{
name|update_needed
operator|++
expr_stmt|;
name|tinfo
operator|->
name|curr
operator|.
name|width
operator|=
name|width
expr_stmt|;
name|ahd_send_async
argument_list|(
name|ahd
argument_list|,
name|devinfo
operator|->
name|channel
argument_list|,
name|devinfo
operator|->
name|target
argument_list|,
name|CAM_LUN_WILDCARD
argument_list|,
name|AC_TRANSFER_NEG
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
block|{
name|printf
argument_list|(
literal|"%s: target %d using %dbit transfers\n"
argument_list|,
name|ahd_name
argument_list|(
name|ahd
argument_list|)
argument_list|,
name|devinfo
operator|->
name|target
argument_list|,
literal|8
operator|*
operator|(
literal|0x01
operator|<<
name|width
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|type
operator|&
name|AHD_TRANS_CUR
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|paused
condition|)
name|ahd_pause
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
name|ahd_update_neg_table
argument_list|(
name|ahd
argument_list|,
name|devinfo
argument_list|,
operator|&
name|tinfo
operator|->
name|curr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|paused
condition|)
name|ahd_unpause
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
block|}
name|update_needed
operator|+=
name|ahd_update_neg_request
argument_list|(
name|ahd
argument_list|,
name|devinfo
argument_list|,
name|tstate
argument_list|,
name|tinfo
argument_list|,
name|AHD_NEG_TO_GOAL
argument_list|)
expr_stmt|;
if|if
condition|(
name|update_needed
operator|&&
name|active
condition|)
name|ahd_update_pending_scbs
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Update the current state of tagged queuing for a given target.  */
end_comment

begin_function
name|void
name|ahd_set_tags
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|,
name|struct
name|ahd_devinfo
modifier|*
name|devinfo
parameter_list|,
name|ahd_queue_alg
name|alg
parameter_list|)
block|{
name|ahd_platform_set_tags
argument_list|(
name|ahd
argument_list|,
name|devinfo
argument_list|,
name|alg
argument_list|)
expr_stmt|;
name|ahd_send_async
argument_list|(
name|ahd
argument_list|,
name|devinfo
operator|->
name|channel
argument_list|,
name|devinfo
operator|->
name|target
argument_list|,
name|devinfo
operator|->
name|lun
argument_list|,
name|AC_TRANSFER_NEG
argument_list|,
operator|&
name|alg
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ahd_update_neg_table
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|,
name|struct
name|ahd_devinfo
modifier|*
name|devinfo
parameter_list|,
name|struct
name|ahd_transinfo
modifier|*
name|tinfo
parameter_list|)
block|{
name|ahd_mode_state
name|saved_modes
decl_stmt|;
name|u_int
name|period
decl_stmt|;
name|u_int
name|ppr_opts
decl_stmt|;
name|u_int
name|con_opts
decl_stmt|;
name|u_int
name|offset
decl_stmt|;
name|u_int
name|saved_negoaddr
decl_stmt|;
name|uint8_t
name|iocell_opts
index|[
sizeof|sizeof
argument_list|(
name|ahd
operator|->
name|iocell_opts
argument_list|)
index|]
decl_stmt|;
name|saved_modes
operator|=
name|ahd_save_modes
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
name|ahd_set_modes
argument_list|(
name|ahd
argument_list|,
name|AHD_MODE_SCSI
argument_list|,
name|AHD_MODE_SCSI
argument_list|)
expr_stmt|;
name|saved_negoaddr
operator|=
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|NEGOADDR
argument_list|)
expr_stmt|;
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|NEGOADDR
argument_list|,
name|devinfo
operator|->
name|target
argument_list|)
expr_stmt|;
name|period
operator|=
name|tinfo
operator|->
name|period
expr_stmt|;
name|offset
operator|=
name|tinfo
operator|->
name|offset
expr_stmt|;
name|memcpy
argument_list|(
name|iocell_opts
argument_list|,
name|ahd
operator|->
name|iocell_opts
argument_list|,
sizeof|sizeof
argument_list|(
name|ahd
operator|->
name|iocell_opts
argument_list|)
argument_list|)
expr_stmt|;
name|ppr_opts
operator|=
name|tinfo
operator|->
name|ppr_options
operator|&
operator|(
name|MSG_EXT_PPR_QAS_REQ
operator||
name|MSG_EXT_PPR_DT_REQ
operator||
name|MSG_EXT_PPR_IU_REQ
operator||
name|MSG_EXT_PPR_RTI
operator|)
expr_stmt|;
name|con_opts
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|period
operator|==
literal|0
condition|)
name|period
operator|=
name|AHD_SYNCRATE_ASYNC
expr_stmt|;
if|if
condition|(
name|period
operator|==
name|AHD_SYNCRATE_160
condition|)
block|{
if|if
condition|(
operator|(
name|ahd
operator|->
name|bugs
operator|&
name|AHD_PACED_NEGTABLE_BUG
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* 			 * When the SPI4 spec was finalized, PACE transfers 			 * was not made a configurable option in the PPR 			 * message.  Instead it is assumed to be enabled for 			 * any syncrate faster than 80MHz.  Nevertheless, 			 * Harpoon2A4 allows this to be configurable. 			 * 			 * Harpoon2A4 also assumes at most 2 data bytes per 			 * negotiated REQ/ACK offset.  Paced transfers take 			 * 4, so we must adjust our offset. 			 */
name|ppr_opts
operator||=
name|PPROPT_PACE
expr_stmt|;
name|offset
operator|*=
literal|2
expr_stmt|;
comment|/* 			 * Harpoon2A assumed that there would be a 			 * fallback rate between 160MHz and 80Mhz, 			 * so 7 is used as the period factor rather 			 * than 8 for 160MHz. 			 */
name|period
operator|=
name|AHD_SYNCRATE_REVA_160
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|tinfo
operator|->
name|ppr_options
operator|&
name|MSG_EXT_PPR_PCOMP_EN
operator|)
operator|==
literal|0
condition|)
name|iocell_opts
index|[
name|AHD_PRECOMP_SLEW_INDEX
index|]
operator|&=
operator|~
name|AHD_PRECOMP_MASK
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Precomp should be disabled for non-paced transfers. 		 */
name|iocell_opts
index|[
name|AHD_PRECOMP_SLEW_INDEX
index|]
operator|&=
operator|~
name|AHD_PRECOMP_MASK
expr_stmt|;
if|if
condition|(
operator|(
name|ahd
operator|->
name|features
operator|&
name|AHD_NEW_IOCELL_OPTS
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|ppr_opts
operator|&
name|MSG_EXT_PPR_DT_REQ
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|ppr_opts
operator|&
name|MSG_EXT_PPR_IU_REQ
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 			 * Slow down our CRC interval to be 			 * compatible with non-packetized 			 * U160 devices that can't handle a 			 * CRC at full speed. 			 */
name|con_opts
operator||=
name|ENSLOWCRC
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|ahd
operator|->
name|bugs
operator|&
name|AHD_PACED_NEGTABLE_BUG
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* 			 * On H2A4, revert to a slower slewrate 			 * on non-paced transfers. 			 */
name|iocell_opts
index|[
name|AHD_PRECOMP_SLEW_INDEX
index|]
operator|&=
operator|~
name|AHD_SLEWRATE_MASK
expr_stmt|;
block|}
block|}
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|ANNEXCOL
argument_list|,
name|AHD_ANNEXCOL_PRECOMP_SLEW
argument_list|)
expr_stmt|;
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|ANNEXDAT
argument_list|,
name|iocell_opts
index|[
name|AHD_PRECOMP_SLEW_INDEX
index|]
argument_list|)
expr_stmt|;
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|ANNEXCOL
argument_list|,
name|AHD_ANNEXCOL_AMPLITUDE
argument_list|)
expr_stmt|;
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|ANNEXDAT
argument_list|,
name|iocell_opts
index|[
name|AHD_AMPLITUDE_INDEX
index|]
argument_list|)
expr_stmt|;
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|NEGPERIOD
argument_list|,
name|period
argument_list|)
expr_stmt|;
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|NEGPPROPTS
argument_list|,
name|ppr_opts
argument_list|)
expr_stmt|;
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|NEGOFFSET
argument_list|,
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|tinfo
operator|->
name|width
operator|==
name|MSG_EXT_WDTR_BUS_16_BIT
condition|)
name|con_opts
operator||=
name|WIDEXFER
expr_stmt|;
comment|/* 	 * During packetized transfers, the target will 	 * give us the oportunity to send command packets 	 * without us asserting attention. 	 */
if|if
condition|(
operator|(
name|tinfo
operator|->
name|ppr_options
operator|&
name|MSG_EXT_PPR_IU_REQ
operator|)
operator|==
literal|0
condition|)
name|con_opts
operator||=
name|ENAUTOATNO
expr_stmt|;
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|NEGCONOPTS
argument_list|,
name|con_opts
argument_list|)
expr_stmt|;
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|NEGOADDR
argument_list|,
name|saved_negoaddr
argument_list|)
expr_stmt|;
name|ahd_restore_modes
argument_list|(
name|ahd
argument_list|,
name|saved_modes
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * When the transfer settings for a connection change, setup for  * negotiation in pending SCBs to effect the change as quickly as  * possible.  We also cancel any negotiations that are scheduled  * for inflight SCBs that have not been started yet.  */
end_comment

begin_function
specifier|static
name|void
name|ahd_update_pending_scbs
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|)
block|{
name|struct
name|scb
modifier|*
name|pending_scb
decl_stmt|;
name|int
name|pending_scb_count
decl_stmt|;
name|int
name|paused
decl_stmt|;
name|u_int
name|saved_scbptr
decl_stmt|;
name|ahd_mode_state
name|saved_modes
decl_stmt|;
comment|/* 	 * Traverse the pending SCB list and ensure that all of the 	 * SCBs there have the proper settings.  We can only safely 	 * clear the negotiation required flag (setting requires the 	 * execution queue to be modified) and this is only possible 	 * if we are not already attempting to select out for this 	 * SCB.  For this reason, all callers only call this routine 	 * if we are changing the negotiation settings for the currently 	 * active transaction on the bus. 	 */
name|pending_scb_count
operator|=
literal|0
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|pending_scb
argument_list|,
argument|&ahd->pending_scbs
argument_list|,
argument|pending_links
argument_list|)
block|{
name|struct
name|ahd_devinfo
name|devinfo
decl_stmt|;
name|struct
name|ahd_initiator_tinfo
modifier|*
name|tinfo
decl_stmt|;
name|struct
name|ahd_tmode_tstate
modifier|*
name|tstate
decl_stmt|;
name|ahd_scb_devinfo
argument_list|(
name|ahd
argument_list|,
operator|&
name|devinfo
argument_list|,
name|pending_scb
argument_list|)
expr_stmt|;
name|tinfo
operator|=
name|ahd_fetch_transinfo
argument_list|(
name|ahd
argument_list|,
name|devinfo
operator|.
name|channel
argument_list|,
name|devinfo
operator|.
name|our_scsiid
argument_list|,
name|devinfo
operator|.
name|target
argument_list|,
operator|&
name|tstate
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tstate
operator|->
name|auto_negotiate
operator|&
name|devinfo
operator|.
name|target_mask
operator|)
operator|==
literal|0
operator|&&
operator|(
name|pending_scb
operator|->
name|flags
operator|&
name|SCB_AUTO_NEGOTIATE
operator|)
operator|!=
literal|0
condition|)
block|{
name|pending_scb
operator|->
name|flags
operator|&=
operator|~
name|SCB_AUTO_NEGOTIATE
expr_stmt|;
name|pending_scb
operator|->
name|hscb
operator|->
name|control
operator|&=
operator|~
name|MK_MESSAGE
expr_stmt|;
block|}
name|ahd_sync_scb
argument_list|(
name|ahd
argument_list|,
name|pending_scb
argument_list|,
name|BUS_DMASYNC_PREREAD
operator||
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
name|pending_scb_count
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|pending_scb_count
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|ahd_is_paused
argument_list|(
name|ahd
argument_list|)
condition|)
block|{
name|paused
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|paused
operator|=
literal|0
expr_stmt|;
name|ahd_pause
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Force the sequencer to reinitialize the selection for 	 * the command at the head of the execution queue if it 	 * has already been setup.  The negotiation changes may 	 * effect whether we select-out with ATN.  It is only 	 * safe to clear ENSELO when the bus is not free and no 	 * selection is in progres or completed. 	 */
name|saved_modes
operator|=
name|ahd_save_modes
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
name|ahd_set_modes
argument_list|(
name|ahd
argument_list|,
name|AHD_MODE_SCSI
argument_list|,
name|AHD_MODE_SCSI
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|SCSISIGI
argument_list|)
operator|&
name|BSYI
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|SSTAT0
argument_list|)
operator|&
operator|(
name|SELDO
operator||
name|SELINGO
operator|)
operator|)
operator|==
literal|0
condition|)
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|SCSISEQ0
argument_list|,
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|SCSISEQ0
argument_list|)
operator|&
operator|~
name|ENSELO
argument_list|)
expr_stmt|;
name|saved_scbptr
operator|=
name|ahd_get_scbptr
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
comment|/* Ensure that the hscbs down on the card match the new information */
name|LIST_FOREACH
argument_list|(
argument|pending_scb
argument_list|,
argument|&ahd->pending_scbs
argument_list|,
argument|pending_links
argument_list|)
block|{
name|u_int
name|scb_tag
decl_stmt|;
name|u_int
name|control
decl_stmt|;
name|scb_tag
operator|=
name|SCB_GET_TAG
argument_list|(
name|pending_scb
argument_list|)
expr_stmt|;
name|ahd_set_scbptr
argument_list|(
name|ahd
argument_list|,
name|scb_tag
argument_list|)
expr_stmt|;
name|control
operator|=
name|ahd_inb_scbram
argument_list|(
name|ahd
argument_list|,
name|SCB_CONTROL
argument_list|)
expr_stmt|;
name|control
operator|&=
operator|~
name|MK_MESSAGE
expr_stmt|;
name|control
operator||=
name|pending_scb
operator|->
name|hscb
operator|->
name|control
operator|&
name|MK_MESSAGE
expr_stmt|;
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|SCB_CONTROL
argument_list|,
name|control
argument_list|)
expr_stmt|;
block|}
name|ahd_set_scbptr
argument_list|(
name|ahd
argument_list|,
name|saved_scbptr
argument_list|)
expr_stmt|;
name|ahd_restore_modes
argument_list|(
name|ahd
argument_list|,
name|saved_modes
argument_list|)
expr_stmt|;
if|if
condition|(
name|paused
operator|==
literal|0
condition|)
name|ahd_unpause
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**************************** Pathing Information *****************************/
end_comment

begin_function
specifier|static
name|void
name|ahd_fetch_devinfo
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|,
name|struct
name|ahd_devinfo
modifier|*
name|devinfo
parameter_list|)
block|{
name|ahd_mode_state
name|saved_modes
decl_stmt|;
name|u_int
name|saved_scsiid
decl_stmt|;
name|role_t
name|role
decl_stmt|;
name|int
name|our_id
decl_stmt|;
name|saved_modes
operator|=
name|ahd_save_modes
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
name|ahd_set_modes
argument_list|(
name|ahd
argument_list|,
name|AHD_MODE_SCSI
argument_list|,
name|AHD_MODE_SCSI
argument_list|)
expr_stmt|;
if|if
condition|(
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|SSTAT0
argument_list|)
operator|&
name|TARGET
condition|)
name|role
operator|=
name|ROLE_TARGET
expr_stmt|;
else|else
name|role
operator|=
name|ROLE_INITIATOR
expr_stmt|;
if|if
condition|(
name|role
operator|==
name|ROLE_TARGET
operator|&&
operator|(
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|SEQ_FLAGS
argument_list|)
operator|&
name|CMDPHASE_PENDING
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* We were selected, so pull our id from TARGIDIN */
name|our_id
operator|=
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|TARGIDIN
argument_list|)
operator|&
name|OID
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|role
operator|==
name|ROLE_TARGET
condition|)
name|our_id
operator|=
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|TOWNID
argument_list|)
expr_stmt|;
else|else
name|our_id
operator|=
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|IOWNID
argument_list|)
expr_stmt|;
name|saved_scsiid
operator|=
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|SAVED_SCSIID
argument_list|)
expr_stmt|;
name|ahd_compile_devinfo
argument_list|(
name|devinfo
argument_list|,
name|our_id
argument_list|,
name|SCSIID_TARGET
argument_list|(
name|ahd
argument_list|,
name|saved_scsiid
argument_list|)
argument_list|,
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|SAVED_LUN
argument_list|)
argument_list|,
name|SCSIID_CHANNEL
argument_list|(
name|ahd
argument_list|,
name|saved_scsiid
argument_list|)
argument_list|,
name|role
argument_list|)
expr_stmt|;
name|ahd_restore_modes
argument_list|(
name|ahd
argument_list|,
name|saved_modes
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ahd_print_devinfo
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|,
name|struct
name|ahd_devinfo
modifier|*
name|devinfo
parameter_list|)
block|{
name|printf
argument_list|(
literal|"%s:%c:%d:%d: "
argument_list|,
name|ahd_name
argument_list|(
name|ahd
argument_list|)
argument_list|,
literal|'A'
argument_list|,
name|devinfo
operator|->
name|target
argument_list|,
name|devinfo
operator|->
name|lun
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|struct
name|ahd_phase_table_entry
modifier|*
name|ahd_lookup_phase_entry
parameter_list|(
name|int
name|phase
parameter_list|)
block|{
name|struct
name|ahd_phase_table_entry
modifier|*
name|entry
decl_stmt|;
name|struct
name|ahd_phase_table_entry
modifier|*
name|last_entry
decl_stmt|;
comment|/* 	 * num_phases doesn't include the default entry which 	 * will be returned if the phase doesn't match. 	 */
name|last_entry
operator|=
operator|&
name|ahd_phase_table
index|[
name|num_phases
index|]
expr_stmt|;
for|for
control|(
name|entry
operator|=
name|ahd_phase_table
init|;
name|entry
operator|<
name|last_entry
condition|;
name|entry
operator|++
control|)
block|{
if|if
condition|(
name|phase
operator|==
name|entry
operator|->
name|phase
condition|)
break|break;
block|}
return|return
operator|(
name|entry
operator|)
return|;
block|}
end_function

begin_function
name|void
name|ahd_compile_devinfo
parameter_list|(
name|struct
name|ahd_devinfo
modifier|*
name|devinfo
parameter_list|,
name|u_int
name|our_id
parameter_list|,
name|u_int
name|target
parameter_list|,
name|u_int
name|lun
parameter_list|,
name|char
name|channel
parameter_list|,
name|role_t
name|role
parameter_list|)
block|{
name|devinfo
operator|->
name|our_scsiid
operator|=
name|our_id
expr_stmt|;
name|devinfo
operator|->
name|target
operator|=
name|target
expr_stmt|;
name|devinfo
operator|->
name|lun
operator|=
name|lun
expr_stmt|;
name|devinfo
operator|->
name|target_offset
operator|=
name|target
expr_stmt|;
name|devinfo
operator|->
name|channel
operator|=
name|channel
expr_stmt|;
name|devinfo
operator|->
name|role
operator|=
name|role
expr_stmt|;
if|if
condition|(
name|channel
operator|==
literal|'B'
condition|)
name|devinfo
operator|->
name|target_offset
operator|+=
literal|8
expr_stmt|;
name|devinfo
operator|->
name|target_mask
operator|=
operator|(
literal|0x01
operator|<<
name|devinfo
operator|->
name|target_offset
operator|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ahd_scb_devinfo
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|,
name|struct
name|ahd_devinfo
modifier|*
name|devinfo
parameter_list|,
name|struct
name|scb
modifier|*
name|scb
parameter_list|)
block|{
name|role_t
name|role
decl_stmt|;
name|int
name|our_id
decl_stmt|;
name|our_id
operator|=
name|SCSIID_OUR_ID
argument_list|(
name|scb
operator|->
name|hscb
operator|->
name|scsiid
argument_list|)
expr_stmt|;
name|role
operator|=
name|ROLE_INITIATOR
expr_stmt|;
if|if
condition|(
operator|(
name|scb
operator|->
name|hscb
operator|->
name|control
operator|&
name|TARGET_SCB
operator|)
operator|!=
literal|0
condition|)
name|role
operator|=
name|ROLE_TARGET
expr_stmt|;
name|ahd_compile_devinfo
argument_list|(
name|devinfo
argument_list|,
name|our_id
argument_list|,
name|SCB_GET_TARGET
argument_list|(
name|ahd
argument_list|,
name|scb
argument_list|)
argument_list|,
name|SCB_GET_LUN
argument_list|(
name|scb
argument_list|)
argument_list|,
name|SCB_GET_CHANNEL
argument_list|(
name|ahd
argument_list|,
name|scb
argument_list|)
argument_list|,
name|role
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/************************ Message Phase Processing ****************************/
end_comment

begin_comment
comment|/*  * When an initiator transaction with the MK_MESSAGE flag either reconnects  * or enters the initial message out phase, we are interrupted.  Fill our  * outgoing message buffer with the appropriate message and beging handing  * the message phase(s) manually.  */
end_comment

begin_function
specifier|static
name|void
name|ahd_setup_initiator_msgout
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|,
name|struct
name|ahd_devinfo
modifier|*
name|devinfo
parameter_list|,
name|struct
name|scb
modifier|*
name|scb
parameter_list|)
block|{
comment|/* 	 * To facilitate adding multiple messages together, 	 * each routine should increment the index and len 	 * variables instead of setting them explicitly. 	 */
name|ahd
operator|->
name|msgout_index
operator|=
literal|0
expr_stmt|;
name|ahd
operator|->
name|msgout_len
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ahd_currently_packetized
argument_list|(
name|ahd
argument_list|)
condition|)
name|ahd
operator|->
name|msg_flags
operator||=
name|MSG_FLAG_PACKETIZED
expr_stmt|;
if|if
condition|(
name|ahd
operator|->
name|send_msg_perror
operator|&&
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|MSG_OUT
argument_list|)
operator|==
name|HOST_MSG
condition|)
block|{
name|ahd
operator|->
name|msgout_buf
index|[
name|ahd
operator|->
name|msgout_index
operator|++
index|]
operator|=
name|ahd
operator|->
name|send_msg_perror
expr_stmt|;
name|ahd
operator|->
name|msgout_len
operator|++
expr_stmt|;
name|ahd
operator|->
name|msg_type
operator|=
name|MSG_TYPE_INITIATOR_MSGOUT
expr_stmt|;
ifdef|#
directive|ifdef
name|AHD_DEBUG
if|if
condition|(
operator|(
name|ahd_debug
operator|&
name|AHD_SHOW_MESSAGES
operator|)
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|"Setting up for Parity Error delivery\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
elseif|else
if|if
condition|(
name|scb
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"%s: WARNING. No pending message for "
literal|"I_T msgin.  Issuing NO-OP\n"
argument_list|,
name|ahd_name
argument_list|(
name|ahd
argument_list|)
argument_list|)
expr_stmt|;
name|ahd
operator|->
name|msgout_buf
index|[
name|ahd
operator|->
name|msgout_index
operator|++
index|]
operator|=
name|MSG_NOOP
expr_stmt|;
name|ahd
operator|->
name|msgout_len
operator|++
expr_stmt|;
name|ahd
operator|->
name|msg_type
operator|=
name|MSG_TYPE_INITIATOR_MSGOUT
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|scb
operator|->
name|flags
operator|&
name|SCB_DEVICE_RESET
operator|)
operator|==
literal|0
operator|&&
operator|(
name|scb
operator|->
name|flags
operator|&
name|SCB_PACKETIZED
operator|)
operator|==
literal|0
operator|&&
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|MSG_OUT
argument_list|)
operator|==
name|MSG_IDENTIFYFLAG
condition|)
block|{
name|u_int
name|identify_msg
decl_stmt|;
name|identify_msg
operator|=
name|MSG_IDENTIFYFLAG
operator||
name|SCB_GET_LUN
argument_list|(
name|scb
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|scb
operator|->
name|hscb
operator|->
name|control
operator|&
name|DISCENB
operator|)
operator|!=
literal|0
condition|)
name|identify_msg
operator||=
name|MSG_IDENTIFY_DISCFLAG
expr_stmt|;
name|ahd
operator|->
name|msgout_buf
index|[
name|ahd
operator|->
name|msgout_index
operator|++
index|]
operator|=
name|identify_msg
expr_stmt|;
name|ahd
operator|->
name|msgout_len
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|scb
operator|->
name|hscb
operator|->
name|control
operator|&
name|TAG_ENB
operator|)
operator|!=
literal|0
condition|)
block|{
name|ahd
operator|->
name|msgout_buf
index|[
name|ahd
operator|->
name|msgout_index
operator|++
index|]
operator|=
name|scb
operator|->
name|hscb
operator|->
name|control
operator|&
operator|(
name|TAG_ENB
operator||
name|SCB_TAG_TYPE
operator|)
expr_stmt|;
name|ahd
operator|->
name|msgout_buf
index|[
name|ahd
operator|->
name|msgout_index
operator|++
index|]
operator|=
name|SCB_GET_TAG
argument_list|(
name|scb
argument_list|)
expr_stmt|;
name|ahd
operator|->
name|msgout_len
operator|+=
literal|2
expr_stmt|;
block|}
block|}
if|if
condition|(
name|scb
operator|->
name|flags
operator|&
name|SCB_DEVICE_RESET
condition|)
block|{
name|ahd
operator|->
name|msgout_buf
index|[
name|ahd
operator|->
name|msgout_index
operator|++
index|]
operator|=
name|MSG_BUS_DEV_RESET
expr_stmt|;
name|ahd
operator|->
name|msgout_len
operator|++
expr_stmt|;
name|ahd_print_path
argument_list|(
name|ahd
argument_list|,
name|scb
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Bus Device Reset Message Sent\n"
argument_list|)
expr_stmt|;
comment|/* 		 * Clear our selection hardware in advance of 		 * the busfree.  We may have an entry in the waiting 		 * Q for this target, and we don't want to go about 		 * selecting while we handle the busfree and blow it 		 * away. 		 */
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|SCSISEQ0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|scb
operator|->
name|flags
operator|&
name|SCB_ABORT
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|scb
operator|->
name|hscb
operator|->
name|control
operator|&
name|TAG_ENB
operator|)
operator|!=
literal|0
condition|)
block|{
name|ahd
operator|->
name|msgout_buf
index|[
name|ahd
operator|->
name|msgout_index
operator|++
index|]
operator|=
name|MSG_ABORT_TAG
expr_stmt|;
block|}
else|else
block|{
name|ahd
operator|->
name|msgout_buf
index|[
name|ahd
operator|->
name|msgout_index
operator|++
index|]
operator|=
name|MSG_ABORT
expr_stmt|;
block|}
name|ahd
operator|->
name|msgout_len
operator|++
expr_stmt|;
name|ahd_print_path
argument_list|(
name|ahd
argument_list|,
name|scb
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Abort%s Message Sent\n"
argument_list|,
operator|(
name|scb
operator|->
name|hscb
operator|->
name|control
operator|&
name|TAG_ENB
operator|)
operator|!=
literal|0
condition|?
literal|" Tag"
else|:
literal|""
argument_list|)
expr_stmt|;
comment|/* 		 * Clear our selection hardware in advance of 		 * the busfree.  We may have an entry in the waiting 		 * Q for this target, and we don't want to go about 		 * selecting while we handle the busfree and blow it 		 * away. 		 */
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|SCSISEQ0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|scb
operator|->
name|flags
operator|&
operator|(
name|SCB_AUTO_NEGOTIATE
operator||
name|SCB_NEGOTIATE
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|ahd_build_transfer_msg
argument_list|(
name|ahd
argument_list|,
name|devinfo
argument_list|)
expr_stmt|;
comment|/* 		 * Clear our selection hardware in advance of potential 		 * PPR IU status change busfree.  We may have an entry in 		 * the waiting Q for this target, and we don't want to go 		 * about selecting while we handle the busfree and blow 		 * it away. 		 */
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|SCSISEQ0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"ahd_intr: AWAITING_MSG for an SCB that "
literal|"does not have a waiting message\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"SCSIID = %x, target_mask = %x\n"
argument_list|,
name|scb
operator|->
name|hscb
operator|->
name|scsiid
argument_list|,
name|devinfo
operator|->
name|target_mask
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"SCB = %d, SCB Control = %x:%x, MSG_OUT = %x "
literal|"SCB flags = %x"
argument_list|,
name|SCB_GET_TAG
argument_list|(
name|scb
argument_list|)
argument_list|,
name|scb
operator|->
name|hscb
operator|->
name|control
argument_list|,
name|ahd_inb_scbram
argument_list|(
name|ahd
argument_list|,
name|SCB_CONTROL
argument_list|)
argument_list|,
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|MSG_OUT
argument_list|)
argument_list|,
name|scb
operator|->
name|flags
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Clear the MK_MESSAGE flag from the SCB so we aren't 	 * asked to send this message again. 	 */
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|SCB_CONTROL
argument_list|,
name|ahd_inb_scbram
argument_list|(
name|ahd
argument_list|,
name|SCB_CONTROL
argument_list|)
operator|&
operator|~
name|MK_MESSAGE
argument_list|)
expr_stmt|;
name|scb
operator|->
name|hscb
operator|->
name|control
operator|&=
operator|~
name|MK_MESSAGE
expr_stmt|;
name|ahd
operator|->
name|msgout_index
operator|=
literal|0
expr_stmt|;
name|ahd
operator|->
name|msg_type
operator|=
name|MSG_TYPE_INITIATOR_MSGOUT
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Build an appropriate transfer negotiation message for the  * currently active target.  */
end_comment

begin_function
specifier|static
name|void
name|ahd_build_transfer_msg
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|,
name|struct
name|ahd_devinfo
modifier|*
name|devinfo
parameter_list|)
block|{
comment|/* 	 * We need to initiate transfer negotiations. 	 * If our current and goal settings are identical, 	 * we want to renegotiate due to a check condition. 	 */
name|struct
name|ahd_initiator_tinfo
modifier|*
name|tinfo
decl_stmt|;
name|struct
name|ahd_tmode_tstate
modifier|*
name|tstate
decl_stmt|;
name|int
name|dowide
decl_stmt|;
name|int
name|dosync
decl_stmt|;
name|int
name|doppr
decl_stmt|;
name|u_int
name|period
decl_stmt|;
name|u_int
name|ppr_options
decl_stmt|;
name|u_int
name|offset
decl_stmt|;
name|tinfo
operator|=
name|ahd_fetch_transinfo
argument_list|(
name|ahd
argument_list|,
name|devinfo
operator|->
name|channel
argument_list|,
name|devinfo
operator|->
name|our_scsiid
argument_list|,
name|devinfo
operator|->
name|target
argument_list|,
operator|&
name|tstate
argument_list|)
expr_stmt|;
comment|/* 	 * Filter our period based on the current connection. 	 * If we can't perform DT transfers on this segment (not in LVD 	 * mode for instance), then our decision to issue a PPR message 	 * may change. 	 */
name|period
operator|=
name|tinfo
operator|->
name|goal
operator|.
name|period
expr_stmt|;
name|offset
operator|=
name|tinfo
operator|->
name|goal
operator|.
name|offset
expr_stmt|;
name|ppr_options
operator|=
name|tinfo
operator|->
name|goal
operator|.
name|ppr_options
expr_stmt|;
comment|/* Target initiated PPR is not allowed in the SCSI spec */
if|if
condition|(
name|devinfo
operator|->
name|role
operator|==
name|ROLE_TARGET
condition|)
name|ppr_options
operator|=
literal|0
expr_stmt|;
name|ahd_devlimited_syncrate
argument_list|(
name|ahd
argument_list|,
name|tinfo
argument_list|,
operator|&
name|period
argument_list|,
operator|&
name|ppr_options
argument_list|,
name|devinfo
operator|->
name|role
argument_list|)
expr_stmt|;
name|dowide
operator|=
name|tinfo
operator|->
name|curr
operator|.
name|width
operator|!=
name|tinfo
operator|->
name|goal
operator|.
name|width
expr_stmt|;
name|dosync
operator|=
name|tinfo
operator|->
name|curr
operator|.
name|offset
operator|!=
name|offset
operator|||
name|tinfo
operator|->
name|curr
operator|.
name|period
operator|!=
name|period
expr_stmt|;
comment|/* 	 * Only use PPR if we have options that need it, even if the device 	 * claims to support it.  There might be an expander in the way 	 * that doesn't. 	 */
name|doppr
operator|=
name|ppr_options
operator|!=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|dowide
operator|&&
operator|!
name|dosync
operator|&&
operator|!
name|doppr
condition|)
block|{
name|dowide
operator|=
name|tinfo
operator|->
name|goal
operator|.
name|width
operator|!=
name|MSG_EXT_WDTR_BUS_8_BIT
expr_stmt|;
name|dosync
operator|=
name|tinfo
operator|->
name|goal
operator|.
name|offset
operator|!=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|dowide
operator|&&
operator|!
name|dosync
operator|&&
operator|!
name|doppr
condition|)
block|{
comment|/* 		 * Force async with a WDTR message if we have a wide bus, 		 * or just issue an SDTR with a 0 offset. 		 */
if|if
condition|(
operator|(
name|ahd
operator|->
name|features
operator|&
name|AHD_WIDE
operator|)
operator|!=
literal|0
condition|)
name|dowide
operator|=
literal|1
expr_stmt|;
else|else
name|dosync
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
block|{
name|ahd_print_devinfo
argument_list|(
name|ahd
argument_list|,
name|devinfo
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Ensuring async\n"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Target initiated PPR is not allowed in the SCSI spec */
if|if
condition|(
name|devinfo
operator|->
name|role
operator|==
name|ROLE_TARGET
condition|)
name|doppr
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Both the PPR message and SDTR message require the 	 * goal syncrate to be limited to what the target device 	 * is capable of handling (based on whether an LVD->SE 	 * expander is on the bus), so combine these two cases. 	 * Regardless, guarantee that if we are using WDTR and SDTR 	 * messages that WDTR comes first. 	 */
if|if
condition|(
name|doppr
operator|||
operator|(
name|dosync
operator|&&
operator|!
name|dowide
operator|)
condition|)
block|{
name|offset
operator|=
name|tinfo
operator|->
name|goal
operator|.
name|offset
expr_stmt|;
name|ahd_validate_offset
argument_list|(
name|ahd
argument_list|,
name|tinfo
argument_list|,
name|period
argument_list|,
operator|&
name|offset
argument_list|,
name|doppr
condition|?
name|tinfo
operator|->
name|goal
operator|.
name|width
else|:
name|tinfo
operator|->
name|curr
operator|.
name|width
argument_list|,
name|devinfo
operator|->
name|role
argument_list|)
expr_stmt|;
if|if
condition|(
name|doppr
condition|)
block|{
name|ahd_construct_ppr
argument_list|(
name|ahd
argument_list|,
name|devinfo
argument_list|,
name|period
argument_list|,
name|offset
argument_list|,
name|tinfo
operator|->
name|goal
operator|.
name|width
argument_list|,
name|ppr_options
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ahd_construct_sdtr
argument_list|(
name|ahd
argument_list|,
name|devinfo
argument_list|,
name|period
argument_list|,
name|offset
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|ahd_construct_wdtr
argument_list|(
name|ahd
argument_list|,
name|devinfo
argument_list|,
name|tinfo
operator|->
name|goal
operator|.
name|width
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Build a synchronous negotiation message in our message  * buffer based on the input parameters.  */
end_comment

begin_function
specifier|static
name|void
name|ahd_construct_sdtr
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|,
name|struct
name|ahd_devinfo
modifier|*
name|devinfo
parameter_list|,
name|u_int
name|period
parameter_list|,
name|u_int
name|offset
parameter_list|)
block|{
if|if
condition|(
name|offset
operator|==
literal|0
condition|)
name|period
operator|=
name|AHD_ASYNC_XFER_PERIOD
expr_stmt|;
name|ahd
operator|->
name|msgout_buf
index|[
name|ahd
operator|->
name|msgout_index
operator|++
index|]
operator|=
name|MSG_EXTENDED
expr_stmt|;
name|ahd
operator|->
name|msgout_buf
index|[
name|ahd
operator|->
name|msgout_index
operator|++
index|]
operator|=
name|MSG_EXT_SDTR_LEN
expr_stmt|;
name|ahd
operator|->
name|msgout_buf
index|[
name|ahd
operator|->
name|msgout_index
operator|++
index|]
operator|=
name|MSG_EXT_SDTR
expr_stmt|;
name|ahd
operator|->
name|msgout_buf
index|[
name|ahd
operator|->
name|msgout_index
operator|++
index|]
operator|=
name|period
expr_stmt|;
name|ahd
operator|->
name|msgout_buf
index|[
name|ahd
operator|->
name|msgout_index
operator|++
index|]
operator|=
name|offset
expr_stmt|;
name|ahd
operator|->
name|msgout_len
operator|+=
literal|5
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
block|{
name|printf
argument_list|(
literal|"(%s:%c:%d:%d): Sending SDTR period %x, offset %x\n"
argument_list|,
name|ahd_name
argument_list|(
name|ahd
argument_list|)
argument_list|,
name|devinfo
operator|->
name|channel
argument_list|,
name|devinfo
operator|->
name|target
argument_list|,
name|devinfo
operator|->
name|lun
argument_list|,
name|period
argument_list|,
name|offset
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Build a wide negotiateion message in our message  * buffer based on the input parameters.  */
end_comment

begin_function
specifier|static
name|void
name|ahd_construct_wdtr
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|,
name|struct
name|ahd_devinfo
modifier|*
name|devinfo
parameter_list|,
name|u_int
name|bus_width
parameter_list|)
block|{
name|ahd
operator|->
name|msgout_buf
index|[
name|ahd
operator|->
name|msgout_index
operator|++
index|]
operator|=
name|MSG_EXTENDED
expr_stmt|;
name|ahd
operator|->
name|msgout_buf
index|[
name|ahd
operator|->
name|msgout_index
operator|++
index|]
operator|=
name|MSG_EXT_WDTR_LEN
expr_stmt|;
name|ahd
operator|->
name|msgout_buf
index|[
name|ahd
operator|->
name|msgout_index
operator|++
index|]
operator|=
name|MSG_EXT_WDTR
expr_stmt|;
name|ahd
operator|->
name|msgout_buf
index|[
name|ahd
operator|->
name|msgout_index
operator|++
index|]
operator|=
name|bus_width
expr_stmt|;
name|ahd
operator|->
name|msgout_len
operator|+=
literal|4
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
block|{
name|printf
argument_list|(
literal|"(%s:%c:%d:%d): Sending WDTR %x\n"
argument_list|,
name|ahd_name
argument_list|(
name|ahd
argument_list|)
argument_list|,
name|devinfo
operator|->
name|channel
argument_list|,
name|devinfo
operator|->
name|target
argument_list|,
name|devinfo
operator|->
name|lun
argument_list|,
name|bus_width
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Build a parallel protocol request message in our message  * buffer based on the input parameters.  */
end_comment

begin_function
specifier|static
name|void
name|ahd_construct_ppr
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|,
name|struct
name|ahd_devinfo
modifier|*
name|devinfo
parameter_list|,
name|u_int
name|period
parameter_list|,
name|u_int
name|offset
parameter_list|,
name|u_int
name|bus_width
parameter_list|,
name|u_int
name|ppr_options
parameter_list|)
block|{
comment|/* 	 * Always request precompensation from 	 * the other target if we are running 	 * at paced syncrates. 	 */
if|if
condition|(
name|period
operator|<=
name|AHD_SYNCRATE_PACED
condition|)
name|ppr_options
operator||=
name|MSG_EXT_PPR_PCOMP_EN
expr_stmt|;
if|if
condition|(
name|offset
operator|==
literal|0
condition|)
name|period
operator|=
name|AHD_ASYNC_XFER_PERIOD
expr_stmt|;
name|ahd
operator|->
name|msgout_buf
index|[
name|ahd
operator|->
name|msgout_index
operator|++
index|]
operator|=
name|MSG_EXTENDED
expr_stmt|;
name|ahd
operator|->
name|msgout_buf
index|[
name|ahd
operator|->
name|msgout_index
operator|++
index|]
operator|=
name|MSG_EXT_PPR_LEN
expr_stmt|;
name|ahd
operator|->
name|msgout_buf
index|[
name|ahd
operator|->
name|msgout_index
operator|++
index|]
operator|=
name|MSG_EXT_PPR
expr_stmt|;
name|ahd
operator|->
name|msgout_buf
index|[
name|ahd
operator|->
name|msgout_index
operator|++
index|]
operator|=
name|period
expr_stmt|;
name|ahd
operator|->
name|msgout_buf
index|[
name|ahd
operator|->
name|msgout_index
operator|++
index|]
operator|=
literal|0
expr_stmt|;
name|ahd
operator|->
name|msgout_buf
index|[
name|ahd
operator|->
name|msgout_index
operator|++
index|]
operator|=
name|offset
expr_stmt|;
name|ahd
operator|->
name|msgout_buf
index|[
name|ahd
operator|->
name|msgout_index
operator|++
index|]
operator|=
name|bus_width
expr_stmt|;
name|ahd
operator|->
name|msgout_buf
index|[
name|ahd
operator|->
name|msgout_index
operator|++
index|]
operator|=
name|ppr_options
expr_stmt|;
name|ahd
operator|->
name|msgout_len
operator|+=
literal|8
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
block|{
name|printf
argument_list|(
literal|"(%s:%c:%d:%d): Sending PPR bus_width %x, period %x, "
literal|"offset %x, ppr_options %x\n"
argument_list|,
name|ahd_name
argument_list|(
name|ahd
argument_list|)
argument_list|,
name|devinfo
operator|->
name|channel
argument_list|,
name|devinfo
operator|->
name|target
argument_list|,
name|devinfo
operator|->
name|lun
argument_list|,
name|bus_width
argument_list|,
name|period
argument_list|,
name|offset
argument_list|,
name|ppr_options
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Clear any active message state.  */
end_comment

begin_function
specifier|static
name|void
name|ahd_clear_msg_state
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|)
block|{
name|ahd_mode_state
name|saved_modes
decl_stmt|;
name|saved_modes
operator|=
name|ahd_save_modes
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
name|ahd_set_modes
argument_list|(
name|ahd
argument_list|,
name|AHD_MODE_SCSI
argument_list|,
name|AHD_MODE_SCSI
argument_list|)
expr_stmt|;
name|ahd
operator|->
name|send_msg_perror
operator|=
literal|0
expr_stmt|;
name|ahd
operator|->
name|msg_flags
operator|=
name|MSG_FLAG_NONE
expr_stmt|;
name|ahd
operator|->
name|msgout_len
operator|=
literal|0
expr_stmt|;
name|ahd
operator|->
name|msgin_index
operator|=
literal|0
expr_stmt|;
name|ahd
operator|->
name|msg_type
operator|=
name|MSG_TYPE_NONE
expr_stmt|;
if|if
condition|(
operator|(
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|SCSISIGO
argument_list|)
operator|&
name|ATNO
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * The target didn't care to respond to our 		 * message request, so clear ATN. 		 */
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|CLRSINT1
argument_list|,
name|CLRATNO
argument_list|)
expr_stmt|;
block|}
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|MSG_OUT
argument_list|,
name|MSG_NOOP
argument_list|)
expr_stmt|;
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|SEQ_FLAGS2
argument_list|,
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|SEQ_FLAGS2
argument_list|)
operator|&
operator|~
name|TARGET_MSG_PENDING
argument_list|)
expr_stmt|;
name|ahd_restore_modes
argument_list|(
name|ahd
argument_list|,
name|saved_modes
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Manual message loop handler.  */
end_comment

begin_function
specifier|static
name|void
name|ahd_handle_message_phase
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|)
block|{
name|struct
name|ahd_devinfo
name|devinfo
decl_stmt|;
name|u_int
name|bus_phase
decl_stmt|;
name|int
name|end_session
decl_stmt|;
name|ahd_fetch_devinfo
argument_list|(
name|ahd
argument_list|,
operator|&
name|devinfo
argument_list|)
expr_stmt|;
name|end_session
operator|=
name|FALSE
expr_stmt|;
name|bus_phase
operator|=
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|LASTPHASE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|LQISTAT2
argument_list|)
operator|&
name|LQIPHASE_OUTPKT
operator|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"LQIRETRY for LQIPHASE_OUTPKT\n"
argument_list|)
expr_stmt|;
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|LQCTL2
argument_list|,
name|LQIRETRY
argument_list|)
expr_stmt|;
block|}
name|reswitch
label|:
switch|switch
condition|(
name|ahd
operator|->
name|msg_type
condition|)
block|{
case|case
name|MSG_TYPE_INITIATOR_MSGOUT
case|:
block|{
name|int
name|lastbyte
decl_stmt|;
name|int
name|phasemis
decl_stmt|;
name|int
name|msgdone
decl_stmt|;
if|if
condition|(
name|ahd
operator|->
name|msgout_len
operator|==
literal|0
operator|&&
name|ahd
operator|->
name|send_msg_perror
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"HOST_MSG_LOOP interrupt with no active message"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|AHD_DEBUG
if|if
condition|(
operator|(
name|ahd_debug
operator|&
name|AHD_SHOW_MESSAGES
operator|)
operator|!=
literal|0
condition|)
block|{
name|ahd_print_devinfo
argument_list|(
name|ahd
argument_list|,
operator|&
name|devinfo
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"INITIATOR_MSG_OUT"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|phasemis
operator|=
name|bus_phase
operator|!=
name|P_MESGOUT
expr_stmt|;
if|if
condition|(
name|phasemis
condition|)
block|{
ifdef|#
directive|ifdef
name|AHD_DEBUG
if|if
condition|(
operator|(
name|ahd_debug
operator|&
name|AHD_SHOW_MESSAGES
operator|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|" PHASEMIS %s\n"
argument_list|,
name|ahd_lookup_phase_entry
argument_list|(
name|bus_phase
argument_list|)
operator|->
name|phasemsg
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|bus_phase
operator|==
name|P_MESGIN
condition|)
block|{
comment|/* 				 * Change gears and see if 				 * this messages is of interest to 				 * us or should be passed back to 				 * the sequencer. 				 */
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|CLRSINT1
argument_list|,
name|CLRATNO
argument_list|)
expr_stmt|;
name|ahd
operator|->
name|send_msg_perror
operator|=
literal|0
expr_stmt|;
name|ahd
operator|->
name|msg_type
operator|=
name|MSG_TYPE_INITIATOR_MSGIN
expr_stmt|;
name|ahd
operator|->
name|msgin_index
operator|=
literal|0
expr_stmt|;
goto|goto
name|reswitch
goto|;
block|}
name|end_session
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ahd
operator|->
name|send_msg_perror
condition|)
block|{
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|CLRSINT1
argument_list|,
name|CLRATNO
argument_list|)
expr_stmt|;
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|CLRSINT1
argument_list|,
name|CLRREQINIT
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|AHD_DEBUG
if|if
condition|(
operator|(
name|ahd_debug
operator|&
name|AHD_SHOW_MESSAGES
operator|)
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|" byte 0x%x\n"
argument_list|,
name|ahd
operator|->
name|send_msg_perror
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 			 * If we are notifying the target of a CRC error 			 * during packetized operations, the target is 			 * within its rights to acknowledge our message 			 * with a busfree. 			 */
if|if
condition|(
operator|(
name|ahd
operator|->
name|msg_flags
operator|&
name|MSG_FLAG_PACKETIZED
operator|)
operator|!=
literal|0
operator|&&
name|ahd
operator|->
name|send_msg_perror
operator|==
name|MSG_INITIATOR_DET_ERR
condition|)
name|ahd
operator|->
name|msg_flags
operator||=
name|MSG_FLAG_EXPECT_IDE_BUSFREE
expr_stmt|;
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|RETURN_2
argument_list|,
name|ahd
operator|->
name|send_msg_perror
argument_list|)
expr_stmt|;
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|RETURN_1
argument_list|,
name|CONT_MSG_LOOP_WRITE
argument_list|)
expr_stmt|;
break|break;
block|}
name|msgdone
operator|=
name|ahd
operator|->
name|msgout_index
operator|==
name|ahd
operator|->
name|msgout_len
expr_stmt|;
if|if
condition|(
name|msgdone
condition|)
block|{
comment|/* 			 * The target has requested a retry. 			 * Re-assert ATN, reset our message index to 			 * 0, and try again. 			 */
name|ahd
operator|->
name|msgout_index
operator|=
literal|0
expr_stmt|;
name|ahd_assert_atn
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
block|}
name|lastbyte
operator|=
name|ahd
operator|->
name|msgout_index
operator|==
operator|(
name|ahd
operator|->
name|msgout_len
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|lastbyte
condition|)
block|{
comment|/* Last byte is signified by dropping ATN */
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|CLRSINT1
argument_list|,
name|CLRATNO
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Clear our interrupt status and present 		 * the next byte on the bus. 		 */
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|CLRSINT1
argument_list|,
name|CLRREQINIT
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|AHD_DEBUG
if|if
condition|(
operator|(
name|ahd_debug
operator|&
name|AHD_SHOW_MESSAGES
operator|)
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|" byte 0x%x\n"
argument_list|,
name|ahd
operator|->
name|msgout_buf
index|[
name|ahd
operator|->
name|msgout_index
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|RETURN_2
argument_list|,
name|ahd
operator|->
name|msgout_buf
index|[
name|ahd
operator|->
name|msgout_index
operator|++
index|]
argument_list|)
expr_stmt|;
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|RETURN_1
argument_list|,
name|CONT_MSG_LOOP_WRITE
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|MSG_TYPE_INITIATOR_MSGIN
case|:
block|{
name|int
name|phasemis
decl_stmt|;
name|int
name|message_done
decl_stmt|;
ifdef|#
directive|ifdef
name|AHD_DEBUG
if|if
condition|(
operator|(
name|ahd_debug
operator|&
name|AHD_SHOW_MESSAGES
operator|)
operator|!=
literal|0
condition|)
block|{
name|ahd_print_devinfo
argument_list|(
name|ahd
argument_list|,
operator|&
name|devinfo
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"INITIATOR_MSG_IN"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|phasemis
operator|=
name|bus_phase
operator|!=
name|P_MESGIN
expr_stmt|;
if|if
condition|(
name|phasemis
condition|)
block|{
ifdef|#
directive|ifdef
name|AHD_DEBUG
if|if
condition|(
operator|(
name|ahd_debug
operator|&
name|AHD_SHOW_MESSAGES
operator|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|" PHASEMIS %s\n"
argument_list|,
name|ahd_lookup_phase_entry
argument_list|(
name|bus_phase
argument_list|)
operator|->
name|phasemsg
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|ahd
operator|->
name|msgin_index
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|bus_phase
operator|==
name|P_MESGOUT
operator|&&
operator|(
name|ahd
operator|->
name|send_msg_perror
operator|!=
literal|0
operator|||
operator|(
name|ahd
operator|->
name|msgout_len
operator|!=
literal|0
operator|&&
name|ahd
operator|->
name|msgout_index
operator|==
literal|0
operator|)
operator|)
condition|)
block|{
name|ahd
operator|->
name|msg_type
operator|=
name|MSG_TYPE_INITIATOR_MSGOUT
expr_stmt|;
goto|goto
name|reswitch
goto|;
block|}
name|end_session
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
comment|/* Pull the byte in without acking it */
name|ahd
operator|->
name|msgin_buf
index|[
name|ahd
operator|->
name|msgin_index
index|]
operator|=
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|SCSIBUS
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|AHD_DEBUG
if|if
condition|(
operator|(
name|ahd_debug
operator|&
name|AHD_SHOW_MESSAGES
operator|)
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|" byte 0x%x\n"
argument_list|,
name|ahd
operator|->
name|msgin_buf
index|[
name|ahd
operator|->
name|msgin_index
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|message_done
operator|=
name|ahd_parse_msg
argument_list|(
name|ahd
argument_list|,
operator|&
name|devinfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|message_done
condition|)
block|{
comment|/* 			 * Clear our incoming message buffer in case there 			 * is another message following this one. 			 */
name|ahd
operator|->
name|msgin_index
operator|=
literal|0
expr_stmt|;
comment|/* 			 * If this message illicited a response, 			 * assert ATN so the target takes us to the 			 * message out phase. 			 */
if|if
condition|(
name|ahd
operator|->
name|msgout_len
operator|!=
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|AHD_DEBUG
if|if
condition|(
operator|(
name|ahd_debug
operator|&
name|AHD_SHOW_MESSAGES
operator|)
operator|!=
literal|0
condition|)
block|{
name|ahd_print_devinfo
argument_list|(
name|ahd
argument_list|,
operator|&
name|devinfo
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Asserting ATN for response\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|ahd_assert_atn
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|ahd
operator|->
name|msgin_index
operator|++
expr_stmt|;
if|if
condition|(
name|message_done
operator|==
name|MSGLOOP_TERMINATED
condition|)
block|{
name|end_session
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
comment|/* Ack the byte */
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|CLRSINT1
argument_list|,
name|CLRREQINIT
argument_list|)
expr_stmt|;
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|RETURN_1
argument_list|,
name|CONT_MSG_LOOP_READ
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|MSG_TYPE_TARGET_MSGIN
case|:
block|{
name|int
name|msgdone
decl_stmt|;
name|int
name|msgout_request
decl_stmt|;
comment|/* 		 * By default, the message loop will continue. 		 */
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|RETURN_1
argument_list|,
name|CONT_MSG_LOOP_TARG
argument_list|)
expr_stmt|;
if|if
condition|(
name|ahd
operator|->
name|msgout_len
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"Target MSGIN with no active message"
argument_list|)
expr_stmt|;
comment|/* 		 * If we interrupted a mesgout session, the initiator 		 * will not know this until our first REQ.  So, we 		 * only honor mesgout requests after we've sent our 		 * first byte. 		 */
if|if
condition|(
operator|(
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|SCSISIGI
argument_list|)
operator|&
name|ATNI
operator|)
operator|!=
literal|0
operator|&&
name|ahd
operator|->
name|msgout_index
operator|>
literal|0
condition|)
name|msgout_request
operator|=
name|TRUE
expr_stmt|;
else|else
name|msgout_request
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|msgout_request
condition|)
block|{
comment|/* 			 * Change gears and see if 			 * this messages is of interest to 			 * us or should be passed back to 			 * the sequencer. 			 */
name|ahd
operator|->
name|msg_type
operator|=
name|MSG_TYPE_TARGET_MSGOUT
expr_stmt|;
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|SCSISIGO
argument_list|,
name|P_MESGOUT
operator||
name|BSYO
argument_list|)
expr_stmt|;
name|ahd
operator|->
name|msgin_index
operator|=
literal|0
expr_stmt|;
comment|/* Dummy read to REQ for first byte */
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|SCSIDAT
argument_list|)
expr_stmt|;
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|SXFRCTL0
argument_list|,
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|SXFRCTL0
argument_list|)
operator||
name|SPIOEN
argument_list|)
expr_stmt|;
break|break;
block|}
name|msgdone
operator|=
name|ahd
operator|->
name|msgout_index
operator|==
name|ahd
operator|->
name|msgout_len
expr_stmt|;
if|if
condition|(
name|msgdone
condition|)
block|{
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|SXFRCTL0
argument_list|,
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|SXFRCTL0
argument_list|)
operator|&
operator|~
name|SPIOEN
argument_list|)
expr_stmt|;
name|end_session
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
comment|/* 		 * Present the next byte on the bus. 		 */
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|SXFRCTL0
argument_list|,
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|SXFRCTL0
argument_list|)
operator||
name|SPIOEN
argument_list|)
expr_stmt|;
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|SCSIDAT
argument_list|,
name|ahd
operator|->
name|msgout_buf
index|[
name|ahd
operator|->
name|msgout_index
operator|++
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|MSG_TYPE_TARGET_MSGOUT
case|:
block|{
name|int
name|lastbyte
decl_stmt|;
name|int
name|msgdone
decl_stmt|;
comment|/* 		 * By default, the message loop will continue. 		 */
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|RETURN_1
argument_list|,
name|CONT_MSG_LOOP_TARG
argument_list|)
expr_stmt|;
comment|/* 		 * The initiator signals that this is 		 * the last byte by dropping ATN. 		 */
name|lastbyte
operator|=
operator|(
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|SCSISIGI
argument_list|)
operator|&
name|ATNI
operator|)
operator|==
literal|0
expr_stmt|;
comment|/* 		 * Read the latched byte, but turn off SPIOEN first 		 * so that we don't inadvertently cause a REQ for the 		 * next byte. 		 */
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|SXFRCTL0
argument_list|,
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|SXFRCTL0
argument_list|)
operator|&
operator|~
name|SPIOEN
argument_list|)
expr_stmt|;
name|ahd
operator|->
name|msgin_buf
index|[
name|ahd
operator|->
name|msgin_index
index|]
operator|=
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|SCSIDAT
argument_list|)
expr_stmt|;
name|msgdone
operator|=
name|ahd_parse_msg
argument_list|(
name|ahd
argument_list|,
operator|&
name|devinfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|msgdone
operator|==
name|MSGLOOP_TERMINATED
condition|)
block|{
comment|/* 			 * The message is *really* done in that it caused 			 * us to go to bus free.  The sequencer has already 			 * been reset at this point, so pull the ejection 			 * handle. 			 */
return|return;
block|}
name|ahd
operator|->
name|msgin_index
operator|++
expr_stmt|;
comment|/* 		 * XXX Read spec about initiator dropping ATN too soon 		 *     and use msgdone to detect it. 		 */
if|if
condition|(
name|msgdone
operator|==
name|MSGLOOP_MSGCOMPLETE
condition|)
block|{
name|ahd
operator|->
name|msgin_index
operator|=
literal|0
expr_stmt|;
comment|/* 			 * If this message illicited a response, transition 			 * to the Message in phase and send it. 			 */
if|if
condition|(
name|ahd
operator|->
name|msgout_len
operator|!=
literal|0
condition|)
block|{
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|SCSISIGO
argument_list|,
name|P_MESGIN
operator||
name|BSYO
argument_list|)
expr_stmt|;
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|SXFRCTL0
argument_list|,
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|SXFRCTL0
argument_list|)
operator||
name|SPIOEN
argument_list|)
expr_stmt|;
name|ahd
operator|->
name|msg_type
operator|=
name|MSG_TYPE_TARGET_MSGIN
expr_stmt|;
name|ahd
operator|->
name|msgin_index
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|lastbyte
condition|)
name|end_session
operator|=
name|TRUE
expr_stmt|;
else|else
block|{
comment|/* Ask for the next byte. */
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|SXFRCTL0
argument_list|,
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|SXFRCTL0
argument_list|)
operator||
name|SPIOEN
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
default|default:
name|panic
argument_list|(
literal|"Unknown REQINIT message type"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|end_session
condition|)
block|{
if|if
condition|(
operator|(
name|ahd
operator|->
name|msg_flags
operator|&
name|MSG_FLAG_PACKETIZED
operator|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%s: Returning to Idle Loop\n"
argument_list|,
name|ahd_name
argument_list|(
name|ahd
argument_list|)
argument_list|)
expr_stmt|;
name|ahd_clear_msg_state
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
comment|/* 			 * Perform the equivalent of a clear_target_state. 			 */
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|LASTPHASE
argument_list|,
name|P_BUSFREE
argument_list|)
expr_stmt|;
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|SEQ_FLAGS
argument_list|,
name|NOT_IDENTIFIED
operator||
name|NO_CDB_SENT
argument_list|)
expr_stmt|;
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|SEQCTL0
argument_list|,
name|FASTMODE
operator||
name|SEQRESET
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ahd_clear_msg_state
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|RETURN_1
argument_list|,
name|EXIT_MSG_LOOP
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * See if we sent a particular extended message to the target.  * If "full" is true, return true only if the target saw the full  * message.  If "full" is false, return true if the target saw at  * least the first byte of the message.  */
end_comment

begin_function
specifier|static
name|int
name|ahd_sent_msg
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|,
name|ahd_msgtype
name|type
parameter_list|,
name|u_int
name|msgval
parameter_list|,
name|int
name|full
parameter_list|)
block|{
name|int
name|found
decl_stmt|;
name|u_int
name|index
decl_stmt|;
name|found
operator|=
name|FALSE
expr_stmt|;
name|index
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|index
operator|<
name|ahd
operator|->
name|msgout_len
condition|)
block|{
if|if
condition|(
name|ahd
operator|->
name|msgout_buf
index|[
name|index
index|]
operator|==
name|MSG_EXTENDED
condition|)
block|{
name|u_int
name|end_index
decl_stmt|;
name|end_index
operator|=
name|index
operator|+
literal|1
operator|+
name|ahd
operator|->
name|msgout_buf
index|[
name|index
operator|+
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|ahd
operator|->
name|msgout_buf
index|[
name|index
operator|+
literal|2
index|]
operator|==
name|msgval
operator|&&
name|type
operator|==
name|AHDMSG_EXT
condition|)
block|{
if|if
condition|(
name|full
condition|)
block|{
if|if
condition|(
name|ahd
operator|->
name|msgout_index
operator|>
name|end_index
condition|)
name|found
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ahd
operator|->
name|msgout_index
operator|>
name|index
condition|)
name|found
operator|=
name|TRUE
expr_stmt|;
block|}
name|index
operator|=
name|end_index
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ahd
operator|->
name|msgout_buf
index|[
name|index
index|]
operator|>=
name|MSG_SIMPLE_TASK
operator|&&
name|ahd
operator|->
name|msgout_buf
index|[
name|index
index|]
operator|<=
name|MSG_IGN_WIDE_RESIDUE
condition|)
block|{
comment|/* Skip tag type and tag id or residue param*/
name|index
operator|+=
literal|2
expr_stmt|;
block|}
else|else
block|{
comment|/* Single byte message */
if|if
condition|(
name|type
operator|==
name|AHDMSG_1B
operator|&&
name|ahd
operator|->
name|msgout_index
operator|>
name|index
operator|&&
operator|(
name|ahd
operator|->
name|msgout_buf
index|[
name|index
index|]
operator|==
name|msgval
operator|||
operator|(
operator|(
name|ahd
operator|->
name|msgout_buf
index|[
name|index
index|]
operator|&
name|MSG_IDENTIFYFLAG
operator|)
operator|!=
literal|0
operator|&&
name|msgval
operator|==
name|MSG_IDENTIFYFLAG
operator|)
operator|)
condition|)
name|found
operator|=
name|TRUE
expr_stmt|;
name|index
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|found
condition|)
break|break;
block|}
return|return
operator|(
name|found
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Wait for a complete incoming message, parse it, and respond accordingly.  */
end_comment

begin_function
specifier|static
name|int
name|ahd_parse_msg
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|,
name|struct
name|ahd_devinfo
modifier|*
name|devinfo
parameter_list|)
block|{
name|struct
name|ahd_initiator_tinfo
modifier|*
name|tinfo
decl_stmt|;
name|struct
name|ahd_tmode_tstate
modifier|*
name|tstate
decl_stmt|;
name|int
name|reject
decl_stmt|;
name|int
name|done
decl_stmt|;
name|int
name|response
decl_stmt|;
name|done
operator|=
name|MSGLOOP_IN_PROG
expr_stmt|;
name|response
operator|=
name|FALSE
expr_stmt|;
name|reject
operator|=
name|FALSE
expr_stmt|;
name|tinfo
operator|=
name|ahd_fetch_transinfo
argument_list|(
name|ahd
argument_list|,
name|devinfo
operator|->
name|channel
argument_list|,
name|devinfo
operator|->
name|our_scsiid
argument_list|,
name|devinfo
operator|->
name|target
argument_list|,
operator|&
name|tstate
argument_list|)
expr_stmt|;
comment|/* 	 * Parse as much of the message as is available, 	 * rejecting it if we don't support it.  When 	 * the entire message is available and has been 	 * handled, return MSGLOOP_MSGCOMPLETE, indicating 	 * that we have parsed an entire message. 	 * 	 * In the case of extended messages, we accept the length 	 * byte outright and perform more checking once we know the 	 * extended message type. 	 */
switch|switch
condition|(
name|ahd
operator|->
name|msgin_buf
index|[
literal|0
index|]
condition|)
block|{
case|case
name|MSG_DISCONNECT
case|:
case|case
name|MSG_SAVEDATAPOINTER
case|:
case|case
name|MSG_CMDCOMPLETE
case|:
case|case
name|MSG_RESTOREPOINTERS
case|:
case|case
name|MSG_IGN_WIDE_RESIDUE
case|:
comment|/* 		 * End our message loop as these are messages 		 * the sequencer handles on its own. 		 */
name|done
operator|=
name|MSGLOOP_TERMINATED
expr_stmt|;
break|break;
case|case
name|MSG_MESSAGE_REJECT
case|:
name|response
operator|=
name|ahd_handle_msg_reject
argument_list|(
name|ahd
argument_list|,
name|devinfo
argument_list|)
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
name|MSG_NOOP
case|:
name|done
operator|=
name|MSGLOOP_MSGCOMPLETE
expr_stmt|;
break|break;
case|case
name|MSG_EXTENDED
case|:
block|{
comment|/* Wait for enough of the message to begin validation */
if|if
condition|(
name|ahd
operator|->
name|msgin_index
operator|<
literal|2
condition|)
break|break;
switch|switch
condition|(
name|ahd
operator|->
name|msgin_buf
index|[
literal|2
index|]
condition|)
block|{
case|case
name|MSG_EXT_SDTR
case|:
block|{
name|u_int
name|period
decl_stmt|;
name|u_int
name|ppr_options
decl_stmt|;
name|u_int
name|offset
decl_stmt|;
name|u_int
name|saved_offset
decl_stmt|;
if|if
condition|(
name|ahd
operator|->
name|msgin_buf
index|[
literal|1
index|]
operator|!=
name|MSG_EXT_SDTR_LEN
condition|)
block|{
name|reject
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
comment|/* 			 * Wait until we have both args before validating 			 * and acting on this message. 			 * 			 * Add one to MSG_EXT_SDTR_LEN to account for 			 * the extended message preamble. 			 */
if|if
condition|(
name|ahd
operator|->
name|msgin_index
operator|<
operator|(
name|MSG_EXT_SDTR_LEN
operator|+
literal|1
operator|)
condition|)
break|break;
name|period
operator|=
name|ahd
operator|->
name|msgin_buf
index|[
literal|3
index|]
expr_stmt|;
name|ppr_options
operator|=
literal|0
expr_stmt|;
name|saved_offset
operator|=
name|offset
operator|=
name|ahd
operator|->
name|msgin_buf
index|[
literal|4
index|]
expr_stmt|;
name|ahd_devlimited_syncrate
argument_list|(
name|ahd
argument_list|,
name|tinfo
argument_list|,
operator|&
name|period
argument_list|,
operator|&
name|ppr_options
argument_list|,
name|devinfo
operator|->
name|role
argument_list|)
expr_stmt|;
name|ahd_validate_offset
argument_list|(
name|ahd
argument_list|,
name|tinfo
argument_list|,
name|period
argument_list|,
operator|&
name|offset
argument_list|,
name|tinfo
operator|->
name|curr
operator|.
name|width
argument_list|,
name|devinfo
operator|->
name|role
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
block|{
name|printf
argument_list|(
literal|"(%s:%c:%d:%d): Received "
literal|"SDTR period %x, offset %x\n\t"
literal|"Filtered to period %x, offset %x\n"
argument_list|,
name|ahd_name
argument_list|(
name|ahd
argument_list|)
argument_list|,
name|devinfo
operator|->
name|channel
argument_list|,
name|devinfo
operator|->
name|target
argument_list|,
name|devinfo
operator|->
name|lun
argument_list|,
name|ahd
operator|->
name|msgin_buf
index|[
literal|3
index|]
argument_list|,
name|saved_offset
argument_list|,
name|period
argument_list|,
name|offset
argument_list|)
expr_stmt|;
block|}
name|ahd_set_syncrate
argument_list|(
name|ahd
argument_list|,
name|devinfo
argument_list|,
name|period
argument_list|,
name|offset
argument_list|,
name|ppr_options
argument_list|,
name|AHD_TRANS_ACTIVE
operator||
name|AHD_TRANS_GOAL
argument_list|,
comment|/*paused*/
name|TRUE
argument_list|)
expr_stmt|;
comment|/* 			 * See if we initiated Sync Negotiation 			 * and didn't have to fall down to async 			 * transfers. 			 */
if|if
condition|(
name|ahd_sent_msg
argument_list|(
name|ahd
argument_list|,
name|AHDMSG_EXT
argument_list|,
name|MSG_EXT_SDTR
argument_list|,
name|TRUE
argument_list|)
condition|)
block|{
comment|/* We started it */
if|if
condition|(
name|saved_offset
operator|!=
name|offset
condition|)
block|{
comment|/* Went too low - force async */
name|reject
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 				 * Send our own SDTR in reply 				 */
if|if
condition|(
name|bootverbose
operator|&&
name|devinfo
operator|->
name|role
operator|==
name|ROLE_INITIATOR
condition|)
block|{
name|printf
argument_list|(
literal|"(%s:%c:%d:%d): Target "
literal|"Initiated SDTR\n"
argument_list|,
name|ahd_name
argument_list|(
name|ahd
argument_list|)
argument_list|,
name|devinfo
operator|->
name|channel
argument_list|,
name|devinfo
operator|->
name|target
argument_list|,
name|devinfo
operator|->
name|lun
argument_list|)
expr_stmt|;
block|}
name|ahd
operator|->
name|msgout_index
operator|=
literal|0
expr_stmt|;
name|ahd
operator|->
name|msgout_len
operator|=
literal|0
expr_stmt|;
name|ahd_construct_sdtr
argument_list|(
name|ahd
argument_list|,
name|devinfo
argument_list|,
name|period
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|ahd
operator|->
name|msgout_index
operator|=
literal|0
expr_stmt|;
name|response
operator|=
name|TRUE
expr_stmt|;
block|}
name|done
operator|=
name|MSGLOOP_MSGCOMPLETE
expr_stmt|;
break|break;
block|}
case|case
name|MSG_EXT_WDTR
case|:
block|{
name|u_int
name|bus_width
decl_stmt|;
name|u_int
name|saved_width
decl_stmt|;
name|u_int
name|sending_reply
decl_stmt|;
name|sending_reply
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|ahd
operator|->
name|msgin_buf
index|[
literal|1
index|]
operator|!=
name|MSG_EXT_WDTR_LEN
condition|)
block|{
name|reject
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
comment|/* 			 * Wait until we have our arg before validating 			 * and acting on this message. 			 * 			 * Add one to MSG_EXT_WDTR_LEN to account for 			 * the extended message preamble. 			 */
if|if
condition|(
name|ahd
operator|->
name|msgin_index
operator|<
operator|(
name|MSG_EXT_WDTR_LEN
operator|+
literal|1
operator|)
condition|)
break|break;
name|bus_width
operator|=
name|ahd
operator|->
name|msgin_buf
index|[
literal|3
index|]
expr_stmt|;
name|saved_width
operator|=
name|bus_width
expr_stmt|;
name|ahd_validate_width
argument_list|(
name|ahd
argument_list|,
name|tinfo
argument_list|,
operator|&
name|bus_width
argument_list|,
name|devinfo
operator|->
name|role
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
block|{
name|printf
argument_list|(
literal|"(%s:%c:%d:%d): Received WDTR "
literal|"%x filtered to %x\n"
argument_list|,
name|ahd_name
argument_list|(
name|ahd
argument_list|)
argument_list|,
name|devinfo
operator|->
name|channel
argument_list|,
name|devinfo
operator|->
name|target
argument_list|,
name|devinfo
operator|->
name|lun
argument_list|,
name|saved_width
argument_list|,
name|bus_width
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ahd_sent_msg
argument_list|(
name|ahd
argument_list|,
name|AHDMSG_EXT
argument_list|,
name|MSG_EXT_WDTR
argument_list|,
name|TRUE
argument_list|)
condition|)
block|{
comment|/* 				 * Don't send a WDTR back to the 				 * target, since we asked first. 				 * If the width went higher than our 				 * request, reject it. 				 */
if|if
condition|(
name|saved_width
operator|>
name|bus_width
condition|)
block|{
name|reject
operator|=
name|TRUE
expr_stmt|;
name|printf
argument_list|(
literal|"(%s:%c:%d:%d): requested %dBit "
literal|"transfers.  Rejecting...\n"
argument_list|,
name|ahd_name
argument_list|(
name|ahd
argument_list|)
argument_list|,
name|devinfo
operator|->
name|channel
argument_list|,
name|devinfo
operator|->
name|target
argument_list|,
name|devinfo
operator|->
name|lun
argument_list|,
literal|8
operator|*
operator|(
literal|0x01
operator|<<
name|bus_width
operator|)
argument_list|)
expr_stmt|;
name|bus_width
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 				 * Send our own WDTR in reply 				 */
if|if
condition|(
name|bootverbose
operator|&&
name|devinfo
operator|->
name|role
operator|==
name|ROLE_INITIATOR
condition|)
block|{
name|printf
argument_list|(
literal|"(%s:%c:%d:%d): Target "
literal|"Initiated WDTR\n"
argument_list|,
name|ahd_name
argument_list|(
name|ahd
argument_list|)
argument_list|,
name|devinfo
operator|->
name|channel
argument_list|,
name|devinfo
operator|->
name|target
argument_list|,
name|devinfo
operator|->
name|lun
argument_list|)
expr_stmt|;
block|}
name|ahd
operator|->
name|msgout_index
operator|=
literal|0
expr_stmt|;
name|ahd
operator|->
name|msgout_len
operator|=
literal|0
expr_stmt|;
name|ahd_construct_wdtr
argument_list|(
name|ahd
argument_list|,
name|devinfo
argument_list|,
name|bus_width
argument_list|)
expr_stmt|;
name|ahd
operator|->
name|msgout_index
operator|=
literal|0
expr_stmt|;
name|response
operator|=
name|TRUE
expr_stmt|;
name|sending_reply
operator|=
name|TRUE
expr_stmt|;
block|}
comment|/* 			 * After a wide message, we are async, but 			 * some devices don't seem to honor this portion 			 * of the spec.  Force a renegotiation of the 			 * sync component of our transfer agreement even 			 * if our goal is async.  By updating our width 			 * after forcing the negotiation, we avoid 			 * renegotiating for width. 			 */
name|ahd_update_neg_request
argument_list|(
name|ahd
argument_list|,
name|devinfo
argument_list|,
name|tstate
argument_list|,
name|tinfo
argument_list|,
name|AHD_NEG_ALWAYS
argument_list|)
expr_stmt|;
name|ahd_set_width
argument_list|(
name|ahd
argument_list|,
name|devinfo
argument_list|,
name|bus_width
argument_list|,
name|AHD_TRANS_ACTIVE
operator||
name|AHD_TRANS_GOAL
argument_list|,
comment|/*paused*/
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sending_reply
operator|==
name|FALSE
operator|&&
name|reject
operator|==
name|FALSE
condition|)
block|{
comment|/* 				 * We will always have an SDTR to send. 				 */
name|ahd
operator|->
name|msgout_index
operator|=
literal|0
expr_stmt|;
name|ahd
operator|->
name|msgout_len
operator|=
literal|0
expr_stmt|;
name|ahd_build_transfer_msg
argument_list|(
name|ahd
argument_list|,
name|devinfo
argument_list|)
expr_stmt|;
name|ahd
operator|->
name|msgout_index
operator|=
literal|0
expr_stmt|;
name|response
operator|=
name|TRUE
expr_stmt|;
block|}
name|done
operator|=
name|MSGLOOP_MSGCOMPLETE
expr_stmt|;
break|break;
block|}
case|case
name|MSG_EXT_PPR
case|:
block|{
name|u_int
name|period
decl_stmt|;
name|u_int
name|offset
decl_stmt|;
name|u_int
name|bus_width
decl_stmt|;
name|u_int
name|ppr_options
decl_stmt|;
name|u_int
name|saved_width
decl_stmt|;
name|u_int
name|saved_offset
decl_stmt|;
name|u_int
name|saved_ppr_options
decl_stmt|;
if|if
condition|(
name|ahd
operator|->
name|msgin_buf
index|[
literal|1
index|]
operator|!=
name|MSG_EXT_PPR_LEN
condition|)
block|{
name|reject
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
comment|/* 			 * Wait until we have all args before validating 			 * and acting on this message. 			 * 			 * Add one to MSG_EXT_PPR_LEN to account for 			 * the extended message preamble. 			 */
if|if
condition|(
name|ahd
operator|->
name|msgin_index
operator|<
operator|(
name|MSG_EXT_PPR_LEN
operator|+
literal|1
operator|)
condition|)
break|break;
name|period
operator|=
name|ahd
operator|->
name|msgin_buf
index|[
literal|3
index|]
expr_stmt|;
name|offset
operator|=
name|ahd
operator|->
name|msgin_buf
index|[
literal|5
index|]
expr_stmt|;
name|bus_width
operator|=
name|ahd
operator|->
name|msgin_buf
index|[
literal|6
index|]
expr_stmt|;
name|saved_width
operator|=
name|bus_width
expr_stmt|;
name|ppr_options
operator|=
name|ahd
operator|->
name|msgin_buf
index|[
literal|7
index|]
expr_stmt|;
comment|/* 			 * According to the spec, a DT only 			 * period factor with no DT option 			 * set implies async. 			 */
if|if
condition|(
operator|(
name|ppr_options
operator|&
name|MSG_EXT_PPR_DT_REQ
operator|)
operator|==
literal|0
operator|&&
name|period
operator|<=
literal|9
condition|)
name|offset
operator|=
literal|0
expr_stmt|;
name|saved_ppr_options
operator|=
name|ppr_options
expr_stmt|;
name|saved_offset
operator|=
name|offset
expr_stmt|;
comment|/* 			 * Transfer options are only available if we 			 * are negotiating wide. 			 */
if|if
condition|(
name|bus_width
operator|==
literal|0
condition|)
name|ppr_options
operator|&=
name|MSG_EXT_PPR_QAS_REQ
expr_stmt|;
name|ahd_validate_width
argument_list|(
name|ahd
argument_list|,
name|tinfo
argument_list|,
operator|&
name|bus_width
argument_list|,
name|devinfo
operator|->
name|role
argument_list|)
expr_stmt|;
name|ahd_devlimited_syncrate
argument_list|(
name|ahd
argument_list|,
name|tinfo
argument_list|,
operator|&
name|period
argument_list|,
operator|&
name|ppr_options
argument_list|,
name|devinfo
operator|->
name|role
argument_list|)
expr_stmt|;
name|ahd_validate_offset
argument_list|(
name|ahd
argument_list|,
name|tinfo
argument_list|,
name|period
argument_list|,
operator|&
name|offset
argument_list|,
name|bus_width
argument_list|,
name|devinfo
operator|->
name|role
argument_list|)
expr_stmt|;
if|if
condition|(
name|ahd_sent_msg
argument_list|(
name|ahd
argument_list|,
name|AHDMSG_EXT
argument_list|,
name|MSG_EXT_PPR
argument_list|,
name|TRUE
argument_list|)
condition|)
block|{
comment|/* 				 * If we are unable to do any of the 				 * requested options (we went too low), 				 * then we'll have to reject the message. 				 */
if|if
condition|(
name|saved_width
operator|>
name|bus_width
operator|||
name|saved_offset
operator|!=
name|offset
operator|||
name|saved_ppr_options
operator|!=
name|ppr_options
condition|)
block|{
name|reject
operator|=
name|TRUE
expr_stmt|;
name|period
operator|=
literal|0
expr_stmt|;
name|offset
operator|=
literal|0
expr_stmt|;
name|bus_width
operator|=
literal|0
expr_stmt|;
name|ppr_options
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|devinfo
operator|->
name|role
operator|!=
name|ROLE_TARGET
condition|)
name|printf
argument_list|(
literal|"(%s:%c:%d:%d): Target "
literal|"Initiated PPR\n"
argument_list|,
name|ahd_name
argument_list|(
name|ahd
argument_list|)
argument_list|,
name|devinfo
operator|->
name|channel
argument_list|,
name|devinfo
operator|->
name|target
argument_list|,
name|devinfo
operator|->
name|lun
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"(%s:%c:%d:%d): Initiator "
literal|"Initiated PPR\n"
argument_list|,
name|ahd_name
argument_list|(
name|ahd
argument_list|)
argument_list|,
name|devinfo
operator|->
name|channel
argument_list|,
name|devinfo
operator|->
name|target
argument_list|,
name|devinfo
operator|->
name|lun
argument_list|)
expr_stmt|;
name|ahd
operator|->
name|msgout_index
operator|=
literal|0
expr_stmt|;
name|ahd
operator|->
name|msgout_len
operator|=
literal|0
expr_stmt|;
name|ahd_construct_ppr
argument_list|(
name|ahd
argument_list|,
name|devinfo
argument_list|,
name|period
argument_list|,
name|offset
argument_list|,
name|bus_width
argument_list|,
name|ppr_options
argument_list|)
expr_stmt|;
name|ahd
operator|->
name|msgout_index
operator|=
literal|0
expr_stmt|;
name|response
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
name|bootverbose
condition|)
block|{
name|printf
argument_list|(
literal|"(%s:%c:%d:%d): Received PPR width %x, "
literal|"period %x, offset %x,options %x\n"
literal|"\tFiltered to width %x, period %x, "
literal|"offset %x, options %x\n"
argument_list|,
name|ahd_name
argument_list|(
name|ahd
argument_list|)
argument_list|,
name|devinfo
operator|->
name|channel
argument_list|,
name|devinfo
operator|->
name|target
argument_list|,
name|devinfo
operator|->
name|lun
argument_list|,
name|saved_width
argument_list|,
name|ahd
operator|->
name|msgin_buf
index|[
literal|3
index|]
argument_list|,
name|saved_offset
argument_list|,
name|saved_ppr_options
argument_list|,
name|bus_width
argument_list|,
name|period
argument_list|,
name|offset
argument_list|,
name|ppr_options
argument_list|)
expr_stmt|;
block|}
name|ahd_set_width
argument_list|(
name|ahd
argument_list|,
name|devinfo
argument_list|,
name|bus_width
argument_list|,
name|AHD_TRANS_ACTIVE
operator||
name|AHD_TRANS_GOAL
argument_list|,
comment|/*paused*/
name|TRUE
argument_list|)
expr_stmt|;
name|ahd_set_syncrate
argument_list|(
name|ahd
argument_list|,
name|devinfo
argument_list|,
name|period
argument_list|,
name|offset
argument_list|,
name|ppr_options
argument_list|,
name|AHD_TRANS_ACTIVE
operator||
name|AHD_TRANS_GOAL
argument_list|,
comment|/*paused*/
name|TRUE
argument_list|)
expr_stmt|;
name|done
operator|=
name|MSGLOOP_MSGCOMPLETE
expr_stmt|;
break|break;
block|}
default|default:
comment|/* Unknown extended message.  Reject it. */
name|reject
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
break|break;
block|}
ifdef|#
directive|ifdef
name|AHD_TARGET_MODE
case|case
name|MSG_BUS_DEV_RESET
case|:
name|ahd_handle_devreset
argument_list|(
name|ahd
argument_list|,
name|devinfo
argument_list|,
name|CAM_LUN_WILDCARD
argument_list|,
name|CAM_BDR_SENT
argument_list|,
literal|"Bus Device Reset Received"
argument_list|,
comment|/*verbose_level*/
literal|0
argument_list|)
expr_stmt|;
name|ahd_restart
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
name|done
operator|=
name|MSGLOOP_TERMINATED
expr_stmt|;
break|break;
case|case
name|MSG_ABORT_TAG
case|:
case|case
name|MSG_ABORT
case|:
case|case
name|MSG_CLEAR_QUEUE
case|:
block|{
name|int
name|tag
decl_stmt|;
comment|/* Target mode messages */
if|if
condition|(
name|devinfo
operator|->
name|role
operator|!=
name|ROLE_TARGET
condition|)
block|{
name|reject
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
name|tag
operator|=
name|SCB_LIST_NULL
expr_stmt|;
if|if
condition|(
name|ahd
operator|->
name|msgin_buf
index|[
literal|0
index|]
operator|==
name|MSG_ABORT_TAG
condition|)
name|tag
operator|=
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|INITIATOR_TAG
argument_list|)
expr_stmt|;
name|ahd_abort_scbs
argument_list|(
name|ahd
argument_list|,
name|devinfo
operator|->
name|target
argument_list|,
name|devinfo
operator|->
name|channel
argument_list|,
name|devinfo
operator|->
name|lun
argument_list|,
name|tag
argument_list|,
name|ROLE_TARGET
argument_list|,
name|CAM_REQ_ABORTED
argument_list|)
expr_stmt|;
name|tstate
operator|=
name|ahd
operator|->
name|enabled_targets
index|[
name|devinfo
operator|->
name|our_scsiid
index|]
expr_stmt|;
if|if
condition|(
name|tstate
operator|!=
name|NULL
condition|)
block|{
name|struct
name|ahd_tmode_lstate
modifier|*
name|lstate
decl_stmt|;
name|lstate
operator|=
name|tstate
operator|->
name|enabled_luns
index|[
name|devinfo
operator|->
name|lun
index|]
expr_stmt|;
if|if
condition|(
name|lstate
operator|!=
name|NULL
condition|)
block|{
name|ahd_queue_lstate_event
argument_list|(
name|ahd
argument_list|,
name|lstate
argument_list|,
name|devinfo
operator|->
name|our_scsiid
argument_list|,
name|ahd
operator|->
name|msgin_buf
index|[
literal|0
index|]
argument_list|,
comment|/*arg*/
name|tag
argument_list|)
expr_stmt|;
name|ahd_send_lstate_events
argument_list|(
name|ahd
argument_list|,
name|lstate
argument_list|)
expr_stmt|;
block|}
block|}
name|ahd_restart
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
name|done
operator|=
name|MSGLOOP_TERMINATED
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
case|case
name|MSG_QAS_REQUEST
case|:
ifdef|#
directive|ifdef
name|AHD_DEBUG
if|if
condition|(
operator|(
name|ahd_debug
operator|&
name|AHD_SHOW_MESSAGES
operator|)
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|"%s: QAS request.  SCSISIGI == 0x%x\n"
argument_list|,
name|ahd_name
argument_list|(
name|ahd
argument_list|)
argument_list|,
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|SCSISIGI
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ahd
operator|->
name|msg_flags
operator||=
name|MSG_FLAG_EXPECT_QASREJ_BUSFREE
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
name|MSG_TERM_IO_PROC
case|:
default|default:
name|reject
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|reject
condition|)
block|{
comment|/* 		 * Setup to reject the message. 		 */
name|ahd
operator|->
name|msgout_index
operator|=
literal|0
expr_stmt|;
name|ahd
operator|->
name|msgout_len
operator|=
literal|1
expr_stmt|;
name|ahd
operator|->
name|msgout_buf
index|[
literal|0
index|]
operator|=
name|MSG_MESSAGE_REJECT
expr_stmt|;
name|done
operator|=
name|MSGLOOP_MSGCOMPLETE
expr_stmt|;
name|response
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
name|done
operator|!=
name|MSGLOOP_IN_PROG
operator|&&
operator|!
name|response
condition|)
comment|/* Clear the outgoing message buffer */
name|ahd
operator|->
name|msgout_len
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|done
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Process a message reject message.  */
end_comment

begin_function
specifier|static
name|int
name|ahd_handle_msg_reject
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|,
name|struct
name|ahd_devinfo
modifier|*
name|devinfo
parameter_list|)
block|{
comment|/* 	 * What we care about here is if we had an 	 * outstanding SDTR or WDTR message for this 	 * target.  If we did, this is a signal that 	 * the target is refusing negotiation. 	 */
name|struct
name|scb
modifier|*
name|scb
decl_stmt|;
name|struct
name|ahd_initiator_tinfo
modifier|*
name|tinfo
decl_stmt|;
name|struct
name|ahd_tmode_tstate
modifier|*
name|tstate
decl_stmt|;
name|u_int
name|scb_index
decl_stmt|;
name|u_int
name|last_msg
decl_stmt|;
name|int
name|response
init|=
literal|0
decl_stmt|;
name|scb_index
operator|=
name|ahd_get_scbptr
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
name|scb
operator|=
name|ahd_lookup_scb
argument_list|(
name|ahd
argument_list|,
name|scb_index
argument_list|)
expr_stmt|;
name|tinfo
operator|=
name|ahd_fetch_transinfo
argument_list|(
name|ahd
argument_list|,
name|devinfo
operator|->
name|channel
argument_list|,
name|devinfo
operator|->
name|our_scsiid
argument_list|,
name|devinfo
operator|->
name|target
argument_list|,
operator|&
name|tstate
argument_list|)
expr_stmt|;
comment|/* Might be necessary */
name|last_msg
operator|=
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|LAST_MSG
argument_list|)
expr_stmt|;
if|if
condition|(
name|ahd_sent_msg
argument_list|(
name|ahd
argument_list|,
name|AHDMSG_EXT
argument_list|,
name|MSG_EXT_PPR
argument_list|,
comment|/*full*/
name|FALSE
argument_list|)
condition|)
block|{
if|if
condition|(
name|ahd_sent_msg
argument_list|(
name|ahd
argument_list|,
name|AHDMSG_EXT
argument_list|,
name|MSG_EXT_PPR
argument_list|,
comment|/*full*/
name|TRUE
argument_list|)
operator|&&
name|tinfo
operator|->
name|goal
operator|.
name|period
operator|<=
name|AHD_SYNCRATE_PACED
condition|)
block|{
comment|/* 			 * Target may not like our SPI-4 PPR Options. 			 * Attempt to negotiate 80MHz which will turn 			 * off these options. 			 */
if|if
condition|(
name|bootverbose
condition|)
block|{
name|printf
argument_list|(
literal|"(%s:%c:%d:%d): PPR Rejected. "
literal|"Trying simple U160 PPR\n"
argument_list|,
name|ahd_name
argument_list|(
name|ahd
argument_list|)
argument_list|,
name|devinfo
operator|->
name|channel
argument_list|,
name|devinfo
operator|->
name|target
argument_list|,
name|devinfo
operator|->
name|lun
argument_list|)
expr_stmt|;
block|}
name|tinfo
operator|->
name|goal
operator|.
name|period
operator|=
name|AHD_SYNCRATE_DT
expr_stmt|;
name|tinfo
operator|->
name|goal
operator|.
name|ppr_options
operator|&=
name|MSG_EXT_PPR_IU_REQ
operator||
name|MSG_EXT_PPR_QAS_REQ
operator||
name|MSG_EXT_PPR_DT_REQ
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * Target does not support the PPR message. 			 * Attempt to negotiate SPI-2 style. 			 */
if|if
condition|(
name|bootverbose
condition|)
block|{
name|printf
argument_list|(
literal|"(%s:%c:%d:%d): PPR Rejected. "
literal|"Trying WDTR/SDTR\n"
argument_list|,
name|ahd_name
argument_list|(
name|ahd
argument_list|)
argument_list|,
name|devinfo
operator|->
name|channel
argument_list|,
name|devinfo
operator|->
name|target
argument_list|,
name|devinfo
operator|->
name|lun
argument_list|)
expr_stmt|;
block|}
name|tinfo
operator|->
name|goal
operator|.
name|ppr_options
operator|=
literal|0
expr_stmt|;
name|tinfo
operator|->
name|curr
operator|.
name|transport_version
operator|=
literal|2
expr_stmt|;
name|tinfo
operator|->
name|goal
operator|.
name|transport_version
operator|=
literal|2
expr_stmt|;
block|}
name|ahd
operator|->
name|msgout_index
operator|=
literal|0
expr_stmt|;
name|ahd
operator|->
name|msgout_len
operator|=
literal|0
expr_stmt|;
name|ahd_build_transfer_msg
argument_list|(
name|ahd
argument_list|,
name|devinfo
argument_list|)
expr_stmt|;
name|ahd
operator|->
name|msgout_index
operator|=
literal|0
expr_stmt|;
name|response
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ahd_sent_msg
argument_list|(
name|ahd
argument_list|,
name|AHDMSG_EXT
argument_list|,
name|MSG_EXT_WDTR
argument_list|,
comment|/*full*/
name|FALSE
argument_list|)
condition|)
block|{
comment|/* note 8bit xfers */
name|printf
argument_list|(
literal|"(%s:%c:%d:%d): refuses WIDE negotiation.  Using "
literal|"8bit transfers\n"
argument_list|,
name|ahd_name
argument_list|(
name|ahd
argument_list|)
argument_list|,
name|devinfo
operator|->
name|channel
argument_list|,
name|devinfo
operator|->
name|target
argument_list|,
name|devinfo
operator|->
name|lun
argument_list|)
expr_stmt|;
name|ahd_set_width
argument_list|(
name|ahd
argument_list|,
name|devinfo
argument_list|,
name|MSG_EXT_WDTR_BUS_8_BIT
argument_list|,
name|AHD_TRANS_ACTIVE
operator||
name|AHD_TRANS_GOAL
argument_list|,
comment|/*paused*/
name|TRUE
argument_list|)
expr_stmt|;
comment|/* 		 * No need to clear the sync rate.  If the target 		 * did not accept the command, our syncrate is 		 * unaffected.  If the target started the negotiation, 		 * but rejected our response, we already cleared the 		 * sync rate before sending our WDTR. 		 */
if|if
condition|(
name|tinfo
operator|->
name|goal
operator|.
name|offset
operator|!=
name|tinfo
operator|->
name|curr
operator|.
name|offset
condition|)
block|{
comment|/* Start the sync negotiation */
name|ahd
operator|->
name|msgout_index
operator|=
literal|0
expr_stmt|;
name|ahd
operator|->
name|msgout_len
operator|=
literal|0
expr_stmt|;
name|ahd_build_transfer_msg
argument_list|(
name|ahd
argument_list|,
name|devinfo
argument_list|)
expr_stmt|;
name|ahd
operator|->
name|msgout_index
operator|=
literal|0
expr_stmt|;
name|response
operator|=
literal|1
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|ahd_sent_msg
argument_list|(
name|ahd
argument_list|,
name|AHDMSG_EXT
argument_list|,
name|MSG_EXT_SDTR
argument_list|,
comment|/*full*/
name|FALSE
argument_list|)
condition|)
block|{
comment|/* note asynch xfers and clear flag */
name|ahd_set_syncrate
argument_list|(
name|ahd
argument_list|,
name|devinfo
argument_list|,
comment|/*period*/
literal|0
argument_list|,
comment|/*offset*/
literal|0
argument_list|,
comment|/*ppr_options*/
literal|0
argument_list|,
name|AHD_TRANS_ACTIVE
operator||
name|AHD_TRANS_GOAL
argument_list|,
comment|/*paused*/
name|TRUE
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"(%s:%c:%d:%d): refuses synchronous negotiation. "
literal|"Using asynchronous transfers\n"
argument_list|,
name|ahd_name
argument_list|(
name|ahd
argument_list|)
argument_list|,
name|devinfo
operator|->
name|channel
argument_list|,
name|devinfo
operator|->
name|target
argument_list|,
name|devinfo
operator|->
name|lun
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|scb
operator|->
name|hscb
operator|->
name|control
operator|&
name|MSG_SIMPLE_TASK
operator|)
operator|!=
literal|0
condition|)
block|{
name|int
name|tag_type
decl_stmt|;
name|int
name|mask
decl_stmt|;
name|tag_type
operator|=
operator|(
name|scb
operator|->
name|hscb
operator|->
name|control
operator|&
name|MSG_SIMPLE_TASK
operator|)
expr_stmt|;
if|if
condition|(
name|tag_type
operator|==
name|MSG_SIMPLE_TASK
condition|)
block|{
name|printf
argument_list|(
literal|"(%s:%c:%d:%d): refuses tagged commands.  "
literal|"Performing non-tagged I/O\n"
argument_list|,
name|ahd_name
argument_list|(
name|ahd
argument_list|)
argument_list|,
name|devinfo
operator|->
name|channel
argument_list|,
name|devinfo
operator|->
name|target
argument_list|,
name|devinfo
operator|->
name|lun
argument_list|)
expr_stmt|;
name|ahd_set_tags
argument_list|(
name|ahd
argument_list|,
name|devinfo
argument_list|,
name|AHD_QUEUE_NONE
argument_list|)
expr_stmt|;
name|mask
operator|=
operator|~
literal|0x23
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"(%s:%c:%d:%d): refuses %s tagged commands.  "
literal|"Performing simple queue tagged I/O only\n"
argument_list|,
name|ahd_name
argument_list|(
name|ahd
argument_list|)
argument_list|,
name|devinfo
operator|->
name|channel
argument_list|,
name|devinfo
operator|->
name|target
argument_list|,
name|devinfo
operator|->
name|lun
argument_list|,
name|tag_type
operator|==
name|MSG_ORDERED_TASK
condition|?
literal|"ordered"
else|:
literal|"head of queue"
argument_list|)
expr_stmt|;
name|ahd_set_tags
argument_list|(
name|ahd
argument_list|,
name|devinfo
argument_list|,
name|AHD_QUEUE_BASIC
argument_list|)
expr_stmt|;
name|mask
operator|=
operator|~
literal|0x03
expr_stmt|;
block|}
comment|/* 		 * Resend the identify for this CCB as the target 		 * may believe that the selection is invalid otherwise. 		 */
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|SCB_CONTROL
argument_list|,
name|ahd_inb_scbram
argument_list|(
name|ahd
argument_list|,
name|SCB_CONTROL
argument_list|)
operator|&
name|mask
argument_list|)
expr_stmt|;
name|scb
operator|->
name|hscb
operator|->
name|control
operator|&=
name|mask
expr_stmt|;
name|aic_set_transaction_tag
argument_list|(
name|scb
argument_list|,
comment|/*enabled*/
name|FALSE
argument_list|,
comment|/*type*/
name|MSG_SIMPLE_TASK
argument_list|)
expr_stmt|;
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|MSG_OUT
argument_list|,
name|MSG_IDENTIFYFLAG
argument_list|)
expr_stmt|;
name|ahd_assert_atn
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
name|ahd_busy_tcl
argument_list|(
name|ahd
argument_list|,
name|BUILD_TCL
argument_list|(
name|scb
operator|->
name|hscb
operator|->
name|scsiid
argument_list|,
name|devinfo
operator|->
name|lun
argument_list|)
argument_list|,
name|SCB_GET_TAG
argument_list|(
name|scb
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 		 * Requeue all tagged commands for this target 		 * currently in our posession so they can be 		 * converted to untagged commands. 		 */
name|ahd_search_qinfifo
argument_list|(
name|ahd
argument_list|,
name|SCB_GET_TARGET
argument_list|(
name|ahd
argument_list|,
name|scb
argument_list|)
argument_list|,
name|SCB_GET_CHANNEL
argument_list|(
name|ahd
argument_list|,
name|scb
argument_list|)
argument_list|,
name|SCB_GET_LUN
argument_list|(
name|scb
argument_list|)
argument_list|,
comment|/*tag*/
name|SCB_LIST_NULL
argument_list|,
name|ROLE_INITIATOR
argument_list|,
name|CAM_REQUEUE_REQ
argument_list|,
name|SEARCH_COMPLETE
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ahd_sent_msg
argument_list|(
name|ahd
argument_list|,
name|AHDMSG_1B
argument_list|,
name|MSG_IDENTIFYFLAG
argument_list|,
name|TRUE
argument_list|)
condition|)
block|{
comment|/* 		 * Most likely the device believes that we had 		 * previously negotiated packetized. 		 */
name|ahd
operator|->
name|msg_flags
operator||=
name|MSG_FLAG_EXPECT_PPR_BUSFREE
operator||
name|MSG_FLAG_IU_REQ_CHANGED
expr_stmt|;
name|ahd_force_renegotiation
argument_list|(
name|ahd
argument_list|,
name|devinfo
argument_list|)
expr_stmt|;
name|ahd
operator|->
name|msgout_index
operator|=
literal|0
expr_stmt|;
name|ahd
operator|->
name|msgout_len
operator|=
literal|0
expr_stmt|;
name|ahd_build_transfer_msg
argument_list|(
name|ahd
argument_list|,
name|devinfo
argument_list|)
expr_stmt|;
name|ahd
operator|->
name|msgout_index
operator|=
literal|0
expr_stmt|;
name|response
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Otherwise, we ignore it. 		 */
name|printf
argument_list|(
literal|"%s:%c:%d: Message reject for %x -- ignored\n"
argument_list|,
name|ahd_name
argument_list|(
name|ahd
argument_list|)
argument_list|,
name|devinfo
operator|->
name|channel
argument_list|,
name|devinfo
operator|->
name|target
argument_list|,
name|last_msg
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|response
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Process an ingnore wide residue message.  */
end_comment

begin_function
specifier|static
name|void
name|ahd_handle_ign_wide_residue
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|,
name|struct
name|ahd_devinfo
modifier|*
name|devinfo
parameter_list|)
block|{
name|u_int
name|scb_index
decl_stmt|;
name|struct
name|scb
modifier|*
name|scb
decl_stmt|;
name|scb_index
operator|=
name|ahd_get_scbptr
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
name|scb
operator|=
name|ahd_lookup_scb
argument_list|(
name|ahd
argument_list|,
name|scb_index
argument_list|)
expr_stmt|;
comment|/* 	 * XXX Actually check data direction in the sequencer? 	 * Perhaps add datadir to some spare bits in the hscb? 	 */
if|if
condition|(
operator|(
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|SEQ_FLAGS
argument_list|)
operator|&
name|DPHASE
operator|)
operator|==
literal|0
operator|||
name|aic_get_transfer_dir
argument_list|(
name|scb
argument_list|)
operator|!=
name|CAM_DIR_IN
condition|)
block|{
comment|/* 		 * Ignore the message if we haven't 		 * seen an appropriate data phase yet. 		 */
block|}
else|else
block|{
comment|/* 		 * If the residual occurred on the last 		 * transfer and the transfer request was 		 * expected to end on an odd count, do 		 * nothing.  Otherwise, subtract a byte 		 * and update the residual count accordingly. 		 */
name|uint32_t
name|sgptr
decl_stmt|;
name|sgptr
operator|=
name|ahd_inb_scbram
argument_list|(
name|ahd
argument_list|,
name|SCB_RESIDUAL_SGPTR
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sgptr
operator|&
name|SG_LIST_NULL
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|ahd_inb_scbram
argument_list|(
name|ahd
argument_list|,
name|SCB_TASK_ATTRIBUTE
argument_list|)
operator|&
name|SCB_XFERLEN_ODD
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* 			 * If the residual occurred on the last 			 * transfer and the transfer request was 			 * expected to end on an odd count, do 			 * nothing. 			 */
block|}
else|else
block|{
name|uint32_t
name|data_cnt
decl_stmt|;
name|uint64_t
name|data_addr
decl_stmt|;
name|uint32_t
name|sglen
decl_stmt|;
comment|/* Pull in the rest of the sgptr */
name|sgptr
operator|=
name|ahd_inl_scbram
argument_list|(
name|ahd
argument_list|,
name|SCB_RESIDUAL_SGPTR
argument_list|)
expr_stmt|;
name|data_cnt
operator|=
name|ahd_inl_scbram
argument_list|(
name|ahd
argument_list|,
name|SCB_RESIDUAL_DATACNT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sgptr
operator|&
name|SG_LIST_NULL
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* 				 * The residual data count is not updated 				 * for the command run to completion case. 				 * Explicitly zero the count. 				 */
name|data_cnt
operator|&=
operator|~
name|AHD_SG_LEN_MASK
expr_stmt|;
block|}
name|data_addr
operator|=
name|ahd_inq
argument_list|(
name|ahd
argument_list|,
name|SHADDR
argument_list|)
expr_stmt|;
name|data_cnt
operator|+=
literal|1
expr_stmt|;
name|data_addr
operator|-=
literal|1
expr_stmt|;
name|sgptr
operator|&=
name|SG_PTR_MASK
expr_stmt|;
if|if
condition|(
operator|(
name|ahd
operator|->
name|flags
operator|&
name|AHD_64BIT_ADDRESSING
operator|)
operator|!=
literal|0
condition|)
block|{
name|struct
name|ahd_dma64_seg
modifier|*
name|sg
decl_stmt|;
name|sg
operator|=
name|ahd_sg_bus_to_virt
argument_list|(
name|ahd
argument_list|,
name|scb
argument_list|,
name|sgptr
argument_list|)
expr_stmt|;
comment|/* 				 * The residual sg ptr points to the next S/G 				 * to load so we must go back one. 				 */
name|sg
operator|--
expr_stmt|;
name|sglen
operator|=
name|aic_le32toh
argument_list|(
name|sg
operator|->
name|len
argument_list|)
operator|&
name|AHD_SG_LEN_MASK
expr_stmt|;
if|if
condition|(
name|sg
operator|!=
name|scb
operator|->
name|sg_list
operator|&&
name|sglen
operator|<
operator|(
name|data_cnt
operator|&
name|AHD_SG_LEN_MASK
operator|)
condition|)
block|{
name|sg
operator|--
expr_stmt|;
name|sglen
operator|=
name|aic_le32toh
argument_list|(
name|sg
operator|->
name|len
argument_list|)
expr_stmt|;
comment|/* 					 * Preserve High Address and SG_LIST 					 * bits while setting the count to 1. 					 */
name|data_cnt
operator|=
literal|1
operator||
operator|(
name|sglen
operator|&
operator|(
operator|~
name|AHD_SG_LEN_MASK
operator|)
operator|)
expr_stmt|;
name|data_addr
operator|=
name|aic_le64toh
argument_list|(
name|sg
operator|->
name|addr
argument_list|)
operator|+
operator|(
name|sglen
operator|&
name|AHD_SG_LEN_MASK
operator|)
operator|-
literal|1
expr_stmt|;
comment|/* 					 * Increment sg so it points to the 					 * "next" sg. 					 */
name|sg
operator|++
expr_stmt|;
name|sgptr
operator|=
name|ahd_sg_virt_to_bus
argument_list|(
name|ahd
argument_list|,
name|scb
argument_list|,
name|sg
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|struct
name|ahd_dma_seg
modifier|*
name|sg
decl_stmt|;
name|sg
operator|=
name|ahd_sg_bus_to_virt
argument_list|(
name|ahd
argument_list|,
name|scb
argument_list|,
name|sgptr
argument_list|)
expr_stmt|;
comment|/* 				 * The residual sg ptr points to the next S/G 				 * to load so we must go back one. 				 */
name|sg
operator|--
expr_stmt|;
name|sglen
operator|=
name|aic_le32toh
argument_list|(
name|sg
operator|->
name|len
argument_list|)
operator|&
name|AHD_SG_LEN_MASK
expr_stmt|;
if|if
condition|(
name|sg
operator|!=
name|scb
operator|->
name|sg_list
operator|&&
name|sglen
operator|<
operator|(
name|data_cnt
operator|&
name|AHD_SG_LEN_MASK
operator|)
condition|)
block|{
name|sg
operator|--
expr_stmt|;
name|sglen
operator|=
name|aic_le32toh
argument_list|(
name|sg
operator|->
name|len
argument_list|)
expr_stmt|;
comment|/* 					 * Preserve High Address and SG_LIST 					 * bits while setting the count to 1. 					 */
name|data_cnt
operator|=
literal|1
operator||
operator|(
name|sglen
operator|&
operator|(
operator|~
name|AHD_SG_LEN_MASK
operator|)
operator|)
expr_stmt|;
name|data_addr
operator|=
name|aic_le32toh
argument_list|(
name|sg
operator|->
name|addr
argument_list|)
operator|+
operator|(
name|sglen
operator|&
name|AHD_SG_LEN_MASK
operator|)
operator|-
literal|1
expr_stmt|;
comment|/* 					 * Increment sg so it points to the 					 * "next" sg. 					 */
name|sg
operator|++
expr_stmt|;
name|sgptr
operator|=
name|ahd_sg_virt_to_bus
argument_list|(
name|ahd
argument_list|,
name|scb
argument_list|,
name|sg
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 			 * Toggle the "oddness" of the transfer length 			 * to handle this mid-transfer ignore wide 			 * residue.  This ensures that the oddness is 			 * correct for subsequent data transfers. 			 */
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|SCB_TASK_ATTRIBUTE
argument_list|,
name|ahd_inb_scbram
argument_list|(
name|ahd
argument_list|,
name|SCB_TASK_ATTRIBUTE
argument_list|)
operator|^
name|SCB_XFERLEN_ODD
argument_list|)
expr_stmt|;
name|ahd_outl
argument_list|(
name|ahd
argument_list|,
name|SCB_RESIDUAL_SGPTR
argument_list|,
name|sgptr
argument_list|)
expr_stmt|;
name|ahd_outl
argument_list|(
name|ahd
argument_list|,
name|SCB_RESIDUAL_DATACNT
argument_list|,
name|data_cnt
argument_list|)
expr_stmt|;
comment|/* 			 * The FIFO's pointers will be updated if/when the 			 * sequencer re-enters a data phase. 			 */
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Reinitialize the data pointers for the active transfer  * based on its current residual.  */
end_comment

begin_function
specifier|static
name|void
name|ahd_reinitialize_dataptrs
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|)
block|{
name|struct
name|scb
modifier|*
name|scb
decl_stmt|;
name|ahd_mode_state
name|saved_modes
decl_stmt|;
name|u_int
name|scb_index
decl_stmt|;
name|u_int
name|wait
decl_stmt|;
name|uint32_t
name|sgptr
decl_stmt|;
name|uint32_t
name|resid
decl_stmt|;
name|uint64_t
name|dataptr
decl_stmt|;
name|AHD_ASSERT_MODES
argument_list|(
name|ahd
argument_list|,
name|AHD_MODE_DFF0_MSK
operator||
name|AHD_MODE_DFF1_MSK
argument_list|,
name|AHD_MODE_DFF0_MSK
operator||
name|AHD_MODE_DFF1_MSK
argument_list|)
expr_stmt|;
name|scb_index
operator|=
name|ahd_get_scbptr
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
name|scb
operator|=
name|ahd_lookup_scb
argument_list|(
name|ahd
argument_list|,
name|scb_index
argument_list|)
expr_stmt|;
comment|/* 	 * Release and reacquire the FIFO so we 	 * have a clean slate. 	 */
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|DFFSXFRCTL
argument_list|,
name|CLRCHN
argument_list|)
expr_stmt|;
name|wait
operator|=
literal|1000
expr_stmt|;
while|while
condition|(
operator|--
name|wait
operator|&&
operator|!
operator|(
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|MDFFSTAT
argument_list|)
operator|&
name|FIFOFREE
operator|)
condition|)
name|aic_delay
argument_list|(
literal|100
argument_list|)
expr_stmt|;
if|if
condition|(
name|wait
operator|==
literal|0
condition|)
block|{
name|ahd_print_path
argument_list|(
name|ahd
argument_list|,
name|scb
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"ahd_reinitialize_dataptrs: Forcing FIFO free.\n"
argument_list|)
expr_stmt|;
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|DFFSXFRCTL
argument_list|,
name|RSTCHN
operator||
name|CLRSHCNT
argument_list|)
expr_stmt|;
block|}
name|saved_modes
operator|=
name|ahd_save_modes
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
name|ahd_set_modes
argument_list|(
name|ahd
argument_list|,
name|AHD_MODE_SCSI
argument_list|,
name|AHD_MODE_SCSI
argument_list|)
expr_stmt|;
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|DFFSTAT
argument_list|,
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|DFFSTAT
argument_list|)
operator||
operator|(
name|saved_modes
operator|==
literal|0x11
condition|?
name|CURRFIFO_1
else|:
name|CURRFIFO_0
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Determine initial values for data_addr and data_cnt 	 * for resuming the data phase. 	 */
name|sgptr
operator|=
name|ahd_inl_scbram
argument_list|(
name|ahd
argument_list|,
name|SCB_RESIDUAL_SGPTR
argument_list|)
expr_stmt|;
name|sgptr
operator|&=
name|SG_PTR_MASK
expr_stmt|;
name|resid
operator|=
operator|(
name|ahd_inb_scbram
argument_list|(
name|ahd
argument_list|,
name|SCB_RESIDUAL_DATACNT
operator|+
literal|2
argument_list|)
operator|<<
literal|16
operator|)
operator||
operator|(
name|ahd_inb_scbram
argument_list|(
name|ahd
argument_list|,
name|SCB_RESIDUAL_DATACNT
operator|+
literal|1
argument_list|)
operator|<<
literal|8
operator|)
operator||
name|ahd_inb_scbram
argument_list|(
name|ahd
argument_list|,
name|SCB_RESIDUAL_DATACNT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ahd
operator|->
name|flags
operator|&
name|AHD_64BIT_ADDRESSING
operator|)
operator|!=
literal|0
condition|)
block|{
name|struct
name|ahd_dma64_seg
modifier|*
name|sg
decl_stmt|;
name|sg
operator|=
name|ahd_sg_bus_to_virt
argument_list|(
name|ahd
argument_list|,
name|scb
argument_list|,
name|sgptr
argument_list|)
expr_stmt|;
comment|/* The residual sg_ptr always points to the next sg */
name|sg
operator|--
expr_stmt|;
name|dataptr
operator|=
name|aic_le64toh
argument_list|(
name|sg
operator|->
name|addr
argument_list|)
operator|+
operator|(
name|aic_le32toh
argument_list|(
name|sg
operator|->
name|len
argument_list|)
operator|&
name|AHD_SG_LEN_MASK
operator|)
operator|-
name|resid
expr_stmt|;
name|ahd_outl
argument_list|(
name|ahd
argument_list|,
name|HADDR
operator|+
literal|4
argument_list|,
name|dataptr
operator|>>
literal|32
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|struct
name|ahd_dma_seg
modifier|*
name|sg
decl_stmt|;
name|sg
operator|=
name|ahd_sg_bus_to_virt
argument_list|(
name|ahd
argument_list|,
name|scb
argument_list|,
name|sgptr
argument_list|)
expr_stmt|;
comment|/* The residual sg_ptr always points to the next sg */
name|sg
operator|--
expr_stmt|;
name|dataptr
operator|=
name|aic_le32toh
argument_list|(
name|sg
operator|->
name|addr
argument_list|)
operator|+
operator|(
name|aic_le32toh
argument_list|(
name|sg
operator|->
name|len
argument_list|)
operator|&
name|AHD_SG_LEN_MASK
operator|)
operator|-
name|resid
expr_stmt|;
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|HADDR
operator|+
literal|4
argument_list|,
operator|(
name|aic_le32toh
argument_list|(
name|sg
operator|->
name|len
argument_list|)
operator|&
operator|~
name|AHD_SG_LEN_MASK
operator|)
operator|>>
literal|24
argument_list|)
expr_stmt|;
block|}
name|ahd_outl
argument_list|(
name|ahd
argument_list|,
name|HADDR
argument_list|,
name|dataptr
argument_list|)
expr_stmt|;
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|HCNT
operator|+
literal|2
argument_list|,
name|resid
operator|>>
literal|16
argument_list|)
expr_stmt|;
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|HCNT
operator|+
literal|1
argument_list|,
name|resid
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|HCNT
argument_list|,
name|resid
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Handle the effects of issuing a bus device reset message.  */
end_comment

begin_function
specifier|static
name|void
name|ahd_handle_devreset
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|,
name|struct
name|ahd_devinfo
modifier|*
name|devinfo
parameter_list|,
name|u_int
name|lun
parameter_list|,
name|cam_status
name|status
parameter_list|,
name|char
modifier|*
name|message
parameter_list|,
name|int
name|verbose_level
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|AHD_TARGET_MODE
name|struct
name|ahd_tmode_tstate
modifier|*
name|tstate
decl_stmt|;
endif|#
directive|endif
name|int
name|found
decl_stmt|;
name|found
operator|=
name|ahd_abort_scbs
argument_list|(
name|ahd
argument_list|,
name|devinfo
operator|->
name|target
argument_list|,
name|devinfo
operator|->
name|channel
argument_list|,
name|lun
argument_list|,
name|SCB_LIST_NULL
argument_list|,
name|devinfo
operator|->
name|role
argument_list|,
name|status
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|AHD_TARGET_MODE
comment|/* 	 * Send an immediate notify ccb to all target mord peripheral 	 * drivers affected by this action. 	 */
name|tstate
operator|=
name|ahd
operator|->
name|enabled_targets
index|[
name|devinfo
operator|->
name|our_scsiid
index|]
expr_stmt|;
if|if
condition|(
name|tstate
operator|!=
name|NULL
condition|)
block|{
name|u_int
name|cur_lun
decl_stmt|;
name|u_int
name|max_lun
decl_stmt|;
if|if
condition|(
name|lun
operator|!=
name|CAM_LUN_WILDCARD
condition|)
block|{
name|cur_lun
operator|=
literal|0
expr_stmt|;
name|max_lun
operator|=
name|AHD_NUM_LUNS
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|cur_lun
operator|=
name|lun
expr_stmt|;
name|max_lun
operator|=
name|lun
expr_stmt|;
block|}
for|for
control|(
name|cur_lun
operator|<=
name|max_lun
init|;
name|cur_lun
operator|++
control|)
block|{
name|struct
name|ahd_tmode_lstate
modifier|*
name|lstate
decl_stmt|;
name|lstate
operator|=
name|tstate
operator|->
name|enabled_luns
index|[
name|cur_lun
index|]
expr_stmt|;
if|if
condition|(
name|lstate
operator|==
name|NULL
condition|)
continue|continue;
name|ahd_queue_lstate_event
argument_list|(
name|ahd
argument_list|,
name|lstate
argument_list|,
name|devinfo
operator|->
name|our_scsiid
argument_list|,
name|MSG_BUS_DEV_RESET
argument_list|,
comment|/*arg*/
literal|0
argument_list|)
expr_stmt|;
name|ahd_send_lstate_events
argument_list|(
name|ahd
argument_list|,
name|lstate
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* 	 * Go back to async/narrow transfers and renegotiate. 	 */
name|ahd_set_width
argument_list|(
name|ahd
argument_list|,
name|devinfo
argument_list|,
name|MSG_EXT_WDTR_BUS_8_BIT
argument_list|,
name|AHD_TRANS_CUR
argument_list|,
comment|/*paused*/
name|TRUE
argument_list|)
expr_stmt|;
name|ahd_set_syncrate
argument_list|(
name|ahd
argument_list|,
name|devinfo
argument_list|,
comment|/*period*/
literal|0
argument_list|,
comment|/*offset*/
literal|0
argument_list|,
comment|/*ppr_options*/
literal|0
argument_list|,
name|AHD_TRANS_CUR
argument_list|,
comment|/*paused*/
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|CAM_SEL_TIMEOUT
condition|)
name|ahd_send_async
argument_list|(
name|ahd
argument_list|,
name|devinfo
operator|->
name|channel
argument_list|,
name|devinfo
operator|->
name|target
argument_list|,
name|lun
argument_list|,
name|AC_SENT_BDR
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|message
operator|!=
name|NULL
operator|&&
operator|(
name|verbose_level
operator|<=
name|bootverbose
operator|)
condition|)
name|printf
argument_list|(
literal|"%s: %s on %c:%d. %d SCBs aborted\n"
argument_list|,
name|ahd_name
argument_list|(
name|ahd
argument_list|)
argument_list|,
name|message
argument_list|,
name|devinfo
operator|->
name|channel
argument_list|,
name|devinfo
operator|->
name|target
argument_list|,
name|found
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|AHD_TARGET_MODE
end_ifdef

begin_function
specifier|static
name|void
name|ahd_setup_target_msgin
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|,
name|struct
name|ahd_devinfo
modifier|*
name|devinfo
parameter_list|,
name|struct
name|scb
modifier|*
name|scb
parameter_list|)
block|{
comment|/*               	 * To facilitate adding multiple messages together, 	 * each routine should increment the index and len 	 * variables instead of setting them explicitly. 	 */
name|ahd
operator|->
name|msgout_index
operator|=
literal|0
expr_stmt|;
name|ahd
operator|->
name|msgout_len
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|scb
operator|!=
name|NULL
operator|&&
operator|(
name|scb
operator|->
name|flags
operator|&
name|SCB_AUTO_NEGOTIATE
operator|)
operator|!=
literal|0
condition|)
name|ahd_build_transfer_msg
argument_list|(
name|ahd
argument_list|,
name|devinfo
argument_list|)
expr_stmt|;
else|else
name|panic
argument_list|(
literal|"ahd_intr: AWAITING target message with no message"
argument_list|)
expr_stmt|;
name|ahd
operator|->
name|msgout_index
operator|=
literal|0
expr_stmt|;
name|ahd
operator|->
name|msg_type
operator|=
name|MSG_TYPE_TARGET_MSGIN
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/**************************** Initialization **********************************/
end_comment

begin_function
specifier|static
name|u_int
name|ahd_sglist_size
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|)
block|{
name|bus_size_t
name|list_size
decl_stmt|;
name|list_size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ahd_dma_seg
argument_list|)
operator|*
name|AHD_NSEG
expr_stmt|;
if|if
condition|(
operator|(
name|ahd
operator|->
name|flags
operator|&
name|AHD_64BIT_ADDRESSING
operator|)
operator|!=
literal|0
condition|)
name|list_size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ahd_dma64_seg
argument_list|)
operator|*
name|AHD_NSEG
expr_stmt|;
return|return
operator|(
name|list_size
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Calculate the optimum S/G List allocation size.  S/G elements used  * for a given transaction must be physically contiguous.  Assume the  * OS will allocate full pages to us, so it doesn't make sense to request  * less than a page.  */
end_comment

begin_function
specifier|static
name|u_int
name|ahd_sglist_allocsize
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|)
block|{
name|bus_size_t
name|sg_list_increment
decl_stmt|;
name|bus_size_t
name|sg_list_size
decl_stmt|;
name|bus_size_t
name|max_list_size
decl_stmt|;
name|bus_size_t
name|best_list_size
decl_stmt|;
comment|/* Start out with the minimum required for AHD_NSEG. */
name|sg_list_increment
operator|=
name|ahd_sglist_size
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
name|sg_list_size
operator|=
name|sg_list_increment
expr_stmt|;
comment|/* Get us as close as possible to a page in size. */
while|while
condition|(
operator|(
name|sg_list_size
operator|+
name|sg_list_increment
operator|)
operator|<=
name|PAGE_SIZE
condition|)
name|sg_list_size
operator|+=
name|sg_list_increment
expr_stmt|;
comment|/* 	 * Try to reduce the amount of wastage by allocating 	 * multiple pages. 	 */
name|best_list_size
operator|=
name|sg_list_size
expr_stmt|;
name|max_list_size
operator|=
name|roundup
argument_list|(
name|sg_list_increment
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|max_list_size
operator|<
literal|4
operator|*
name|PAGE_SIZE
condition|)
name|max_list_size
operator|=
literal|4
operator|*
name|PAGE_SIZE
expr_stmt|;
if|if
condition|(
name|max_list_size
operator|>
operator|(
name|AHD_SCB_MAX_ALLOC
operator|*
name|sg_list_increment
operator|)
condition|)
name|max_list_size
operator|=
operator|(
name|AHD_SCB_MAX_ALLOC
operator|*
name|sg_list_increment
operator|)
expr_stmt|;
while|while
condition|(
operator|(
name|sg_list_size
operator|+
name|sg_list_increment
operator|)
operator|<=
name|max_list_size
operator|&&
operator|(
name|sg_list_size
operator|%
name|PAGE_SIZE
operator|)
operator|!=
literal|0
condition|)
block|{
name|bus_size_t
name|new_mod
decl_stmt|;
name|bus_size_t
name|best_mod
decl_stmt|;
name|sg_list_size
operator|+=
name|sg_list_increment
expr_stmt|;
name|new_mod
operator|=
name|sg_list_size
operator|%
name|PAGE_SIZE
expr_stmt|;
name|best_mod
operator|=
name|best_list_size
operator|%
name|PAGE_SIZE
expr_stmt|;
if|if
condition|(
name|new_mod
operator|>
name|best_mod
operator|||
name|new_mod
operator|==
literal|0
condition|)
block|{
name|best_list_size
operator|=
name|sg_list_size
expr_stmt|;
block|}
block|}
return|return
operator|(
name|best_list_size
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Allocate a controller structure for a new device  * and perform initial initializion.  */
end_comment

begin_function
name|struct
name|ahd_softc
modifier|*
name|ahd_alloc
parameter_list|(
name|void
modifier|*
name|platform_arg
parameter_list|,
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|ahd_softc
modifier|*
name|ahd
decl_stmt|;
ifndef|#
directive|ifndef
name|__FreeBSD__
name|ahd
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|ahd
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ahd
condition|)
block|{
name|printf
argument_list|(
literal|"aic7xxx: cannot malloc softc!\n"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|name
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
else|#
directive|else
name|ahd
operator|=
name|device_get_softc
argument_list|(
operator|(
name|device_t
operator|)
name|platform_arg
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|memset
argument_list|(
name|ahd
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ahd
argument_list|)
argument_list|)
expr_stmt|;
name|ahd
operator|->
name|seep_config
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|ahd
operator|->
name|seep_config
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|ahd
operator|->
name|seep_config
operator|==
name|NULL
condition|)
block|{
ifndef|#
directive|ifndef
name|__FreeBSD__
name|free
argument_list|(
name|ahd
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|free
argument_list|(
name|name
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|LIST_INIT
argument_list|(
operator|&
name|ahd
operator|->
name|pending_scbs
argument_list|)
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|ahd
operator|->
name|timedout_scbs
argument_list|)
expr_stmt|;
comment|/* We don't know our unit number until the OSM sets it */
name|ahd
operator|->
name|name
operator|=
name|name
expr_stmt|;
name|ahd
operator|->
name|unit
operator|=
operator|-
literal|1
expr_stmt|;
name|ahd
operator|->
name|description
operator|=
name|NULL
expr_stmt|;
name|ahd
operator|->
name|bus_description
operator|=
name|NULL
expr_stmt|;
name|ahd
operator|->
name|channel
operator|=
literal|'A'
expr_stmt|;
name|ahd
operator|->
name|chip
operator|=
name|AHD_NONE
expr_stmt|;
name|ahd
operator|->
name|features
operator|=
name|AHD_FENONE
expr_stmt|;
name|ahd
operator|->
name|bugs
operator|=
name|AHD_BUGNONE
expr_stmt|;
name|ahd
operator|->
name|flags
operator|=
name|AHD_SPCHK_ENB_A
operator||
name|AHD_RESET_BUS_A
operator||
name|AHD_TERM_ENB_A
operator||
name|AHD_EXTENDED_TRANS_A
operator||
name|AHD_STPWLEVEL_A
expr_stmt|;
name|aic_timer_init
argument_list|(
operator|&
name|ahd
operator|->
name|reset_timer
argument_list|)
expr_stmt|;
name|aic_timer_init
argument_list|(
operator|&
name|ahd
operator|->
name|stat_timer
argument_list|)
expr_stmt|;
name|ahd
operator|->
name|int_coalescing_timer
operator|=
name|AHD_INT_COALESCING_TIMER_DEFAULT
expr_stmt|;
name|ahd
operator|->
name|int_coalescing_maxcmds
operator|=
name|AHD_INT_COALESCING_MAXCMDS_DEFAULT
expr_stmt|;
name|ahd
operator|->
name|int_coalescing_mincmds
operator|=
name|AHD_INT_COALESCING_MINCMDS_DEFAULT
expr_stmt|;
name|ahd
operator|->
name|int_coalescing_threshold
operator|=
name|AHD_INT_COALESCING_THRESHOLD_DEFAULT
expr_stmt|;
name|ahd
operator|->
name|int_coalescing_stop_threshold
operator|=
name|AHD_INT_COALESCING_STOP_THRESHOLD_DEFAULT
expr_stmt|;
if|if
condition|(
name|ahd_platform_alloc
argument_list|(
name|ahd
argument_list|,
name|platform_arg
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|ahd_free
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
name|ahd
operator|=
name|NULL
expr_stmt|;
block|}
name|ahd_lockinit
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|AHD_DEBUG
if|if
condition|(
operator|(
name|ahd_debug
operator|&
name|AHD_SHOW_MEMORY
operator|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%s: scb size = 0x%x, hscb size = 0x%x\n"
argument_list|,
name|ahd_name
argument_list|(
name|ahd
argument_list|)
argument_list|,
operator|(
name|u_int
operator|)
sizeof|sizeof
argument_list|(
expr|struct
name|scb
argument_list|)
argument_list|,
operator|(
name|u_int
operator|)
sizeof|sizeof
argument_list|(
expr|struct
name|hardware_scb
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return
operator|(
name|ahd
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ahd_softc_init
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|)
block|{
name|ahd
operator|->
name|unpause
operator|=
literal|0
expr_stmt|;
name|ahd
operator|->
name|pause
operator|=
name|PAUSE
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|ahd_softc_insert
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|)
block|{
name|struct
name|ahd_softc
modifier|*
name|list_ahd
decl_stmt|;
if|#
directive|if
name|AIC_PCI_CONFIG
operator|>
literal|0
comment|/* 	 * Second Function PCI devices need to inherit some 	 * settings from function 0. 	 */
if|if
condition|(
operator|(
name|ahd
operator|->
name|features
operator|&
name|AHD_MULTI_FUNC
operator|)
operator|!=
literal|0
condition|)
block|{
name|TAILQ_FOREACH
argument_list|(
argument|list_ahd
argument_list|,
argument|&ahd_tailq
argument_list|,
argument|links
argument_list|)
block|{
name|aic_dev_softc_t
name|list_pci
decl_stmt|;
name|aic_dev_softc_t
name|pci
decl_stmt|;
name|list_pci
operator|=
name|list_ahd
operator|->
name|dev_softc
expr_stmt|;
name|pci
operator|=
name|ahd
operator|->
name|dev_softc
expr_stmt|;
if|if
condition|(
name|aic_get_pci_slot
argument_list|(
name|list_pci
argument_list|)
operator|==
name|aic_get_pci_slot
argument_list|(
name|pci
argument_list|)
operator|&&
name|aic_get_pci_bus
argument_list|(
name|list_pci
argument_list|)
operator|==
name|aic_get_pci_bus
argument_list|(
name|pci
argument_list|)
condition|)
block|{
name|struct
name|ahd_softc
modifier|*
name|master
decl_stmt|;
name|struct
name|ahd_softc
modifier|*
name|slave
decl_stmt|;
if|if
condition|(
name|aic_get_pci_function
argument_list|(
name|list_pci
argument_list|)
operator|==
literal|0
condition|)
block|{
name|master
operator|=
name|list_ahd
expr_stmt|;
name|slave
operator|=
name|ahd
expr_stmt|;
block|}
else|else
block|{
name|master
operator|=
name|ahd
expr_stmt|;
name|slave
operator|=
name|list_ahd
expr_stmt|;
block|}
name|slave
operator|->
name|flags
operator|&=
operator|~
name|AHD_BIOS_ENABLED
expr_stmt|;
name|slave
operator|->
name|flags
operator||=
name|master
operator|->
name|flags
operator|&
name|AHD_BIOS_ENABLED
expr_stmt|;
break|break;
block|}
block|}
block|}
endif|#
directive|endif
comment|/* 	 * Insertion sort into our list of softcs. 	 */
name|list_ahd
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|ahd_tailq
argument_list|)
expr_stmt|;
while|while
condition|(
name|list_ahd
operator|!=
name|NULL
operator|&&
name|ahd_softc_comp
argument_list|(
name|ahd
argument_list|,
name|list_ahd
argument_list|)
operator|<=
literal|0
condition|)
name|list_ahd
operator|=
name|TAILQ_NEXT
argument_list|(
name|list_ahd
argument_list|,
name|links
argument_list|)
expr_stmt|;
if|if
condition|(
name|list_ahd
operator|!=
name|NULL
condition|)
name|TAILQ_INSERT_BEFORE
argument_list|(
name|list_ahd
argument_list|,
name|ahd
argument_list|,
name|links
argument_list|)
expr_stmt|;
else|else
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|ahd_tailq
argument_list|,
name|ahd
argument_list|,
name|links
argument_list|)
expr_stmt|;
name|ahd
operator|->
name|init_level
operator|++
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ahd_set_unit
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|,
name|int
name|unit
parameter_list|)
block|{
name|ahd
operator|->
name|unit
operator|=
name|unit
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ahd_set_name
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|,
name|char
modifier|*
name|name
parameter_list|)
block|{
if|if
condition|(
name|ahd
operator|->
name|name
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|ahd
operator|->
name|name
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|ahd
operator|->
name|name
operator|=
name|name
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ahd_free
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|ahd_terminate_recovery_thread
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ahd
operator|->
name|init_level
condition|)
block|{
default|default:
case|case
literal|5
case|:
name|ahd_shutdown
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
literal|4
case|:
name|aic_dmamap_unload
argument_list|(
name|ahd
argument_list|,
name|ahd
operator|->
name|shared_data_dmat
argument_list|,
name|ahd
operator|->
name|shared_data_map
operator|.
name|dmamap
argument_list|)
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
literal|3
case|:
name|aic_dmamem_free
argument_list|(
name|ahd
argument_list|,
name|ahd
operator|->
name|shared_data_dmat
argument_list|,
name|ahd
operator|->
name|qoutfifo
argument_list|,
name|ahd
operator|->
name|shared_data_map
operator|.
name|dmamap
argument_list|)
expr_stmt|;
name|aic_dmamap_destroy
argument_list|(
name|ahd
argument_list|,
name|ahd
operator|->
name|shared_data_dmat
argument_list|,
name|ahd
operator|->
name|shared_data_map
operator|.
name|dmamap
argument_list|)
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
literal|2
case|:
name|aic_dma_tag_destroy
argument_list|(
name|ahd
argument_list|,
name|ahd
operator|->
name|shared_data_dmat
argument_list|)
expr_stmt|;
case|case
literal|1
case|:
ifndef|#
directive|ifndef
name|__linux__
name|aic_dma_tag_destroy
argument_list|(
name|ahd
argument_list|,
name|ahd
operator|->
name|buffer_dmat
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
literal|0
case|:
break|break;
block|}
ifndef|#
directive|ifndef
name|__linux__
name|aic_dma_tag_destroy
argument_list|(
name|ahd
argument_list|,
name|ahd
operator|->
name|parent_dmat
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ahd_platform_free
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
name|ahd_fini_scbdata
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|AHD_NUM_TARGETS
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|ahd_tmode_tstate
modifier|*
name|tstate
decl_stmt|;
name|tstate
operator|=
name|ahd
operator|->
name|enabled_targets
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|tstate
operator|!=
name|NULL
condition|)
block|{
ifdef|#
directive|ifdef
name|AHD_TARGET_MODE
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|AHD_NUM_LUNS
condition|;
name|j
operator|++
control|)
block|{
name|struct
name|ahd_tmode_lstate
modifier|*
name|lstate
decl_stmt|;
name|lstate
operator|=
name|tstate
operator|->
name|enabled_luns
index|[
name|j
index|]
expr_stmt|;
if|if
condition|(
name|lstate
operator|!=
name|NULL
condition|)
block|{
name|xpt_free_path
argument_list|(
name|lstate
operator|->
name|path
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|lstate
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
name|free
argument_list|(
name|tstate
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|AHD_TARGET_MODE
if|if
condition|(
name|ahd
operator|->
name|black_hole
operator|!=
name|NULL
condition|)
block|{
name|xpt_free_path
argument_list|(
name|ahd
operator|->
name|black_hole
operator|->
name|path
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ahd
operator|->
name|black_hole
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|ahd
operator|->
name|name
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|ahd
operator|->
name|name
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
if|if
condition|(
name|ahd
operator|->
name|seep_config
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|ahd
operator|->
name|seep_config
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
if|if
condition|(
name|ahd
operator|->
name|saved_stack
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|ahd
operator|->
name|saved_stack
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|__FreeBSD__
name|free
argument_list|(
name|ahd
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
end_function

begin_function
name|void
name|ahd_shutdown
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ahd_softc
modifier|*
name|ahd
decl_stmt|;
name|ahd
operator|=
operator|(
expr|struct
name|ahd_softc
operator|*
operator|)
name|arg
expr_stmt|;
comment|/* 	 * Stop periodic timer callbacks. 	 */
name|aic_timer_stop
argument_list|(
operator|&
name|ahd
operator|->
name|reset_timer
argument_list|)
expr_stmt|;
name|aic_timer_stop
argument_list|(
operator|&
name|ahd
operator|->
name|stat_timer
argument_list|)
expr_stmt|;
comment|/* This will reset most registers to 0, but not all */
name|ahd_reset
argument_list|(
name|ahd
argument_list|,
comment|/*reinit*/
name|FALSE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Reset the controller and record some information about it  * that is only available just after a reset.  If "reinit" is  * non-zero, this reset occured after initial configuration  * and the caller requests that the chip be fully reinitialized  * to a runable state.  Chip interrupts are *not* enabled after  * a reinitialization.  The caller must enable interrupts via  * ahd_intr_enable().  */
end_comment

begin_function
name|int
name|ahd_reset
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|,
name|int
name|reinit
parameter_list|)
block|{
name|u_int
name|sxfrctl1
decl_stmt|;
name|int
name|wait
decl_stmt|;
name|uint32_t
name|cmd
decl_stmt|;
comment|/* 	 * Preserve the value of the SXFRCTL1 register for all channels. 	 * It contains settings that affect termination and we don't want 	 * to disturb the integrity of the bus. 	 */
name|ahd_pause
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
name|ahd_update_modes
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
name|ahd_set_modes
argument_list|(
name|ahd
argument_list|,
name|AHD_MODE_SCSI
argument_list|,
name|AHD_MODE_SCSI
argument_list|)
expr_stmt|;
name|sxfrctl1
operator|=
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|SXFRCTL1
argument_list|)
expr_stmt|;
name|cmd
operator|=
name|aic_pci_read_config
argument_list|(
name|ahd
operator|->
name|dev_softc
argument_list|,
name|PCIR_COMMAND
argument_list|,
comment|/*bytes*/
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ahd
operator|->
name|bugs
operator|&
name|AHD_PCIX_CHIPRST_BUG
operator|)
operator|!=
literal|0
condition|)
block|{
name|uint32_t
name|mod_cmd
decl_stmt|;
comment|/* 		 * A4 Razor #632 		 * During the assertion of CHIPRST, the chip 		 * does not disable its parity logic prior to 		 * the start of the reset.  This may cause a 		 * parity error to be detected and thus a 		 * spurious SERR or PERR assertion.  Disble 		 * PERR and SERR responses during the CHIPRST. 		 */
name|mod_cmd
operator|=
name|cmd
operator|&
operator|~
operator|(
name|PCIM_CMD_PERRESPEN
operator||
name|PCIM_CMD_SERRESPEN
operator|)
expr_stmt|;
name|aic_pci_write_config
argument_list|(
name|ahd
operator|->
name|dev_softc
argument_list|,
name|PCIR_COMMAND
argument_list|,
name|mod_cmd
argument_list|,
comment|/*bytes*/
literal|2
argument_list|)
expr_stmt|;
block|}
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|HCNTRL
argument_list|,
name|CHIPRST
operator||
name|ahd
operator|->
name|pause
argument_list|)
expr_stmt|;
comment|/* 	 * Ensure that the reset has finished.  We delay 1000us 	 * prior to reading the register to make sure the chip 	 * has sufficiently completed its reset to handle register 	 * accesses. 	 */
name|wait
operator|=
literal|1000
expr_stmt|;
do|do
block|{
name|aic_delay
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|wait
operator|&&
operator|!
operator|(
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|HCNTRL
argument_list|)
operator|&
name|CHIPRSTACK
operator|)
condition|)
do|;
if|if
condition|(
name|wait
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%s: WARNING - Failed chip reset!  "
literal|"Trying to initialize anyway.\n"
argument_list|,
name|ahd_name
argument_list|(
name|ahd
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|HCNTRL
argument_list|,
name|ahd
operator|->
name|pause
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ahd
operator|->
name|bugs
operator|&
name|AHD_PCIX_CHIPRST_BUG
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * Clear any latched PCI error status and restore 		 * previous SERR and PERR response enables. 		 */
name|aic_pci_write_config
argument_list|(
name|ahd
operator|->
name|dev_softc
argument_list|,
name|PCIR_STATUS
operator|+
literal|1
argument_list|,
literal|0xFF
argument_list|,
comment|/*bytes*/
literal|1
argument_list|)
expr_stmt|;
name|aic_pci_write_config
argument_list|(
name|ahd
operator|->
name|dev_softc
argument_list|,
name|PCIR_COMMAND
argument_list|,
name|cmd
argument_list|,
comment|/*bytes*/
literal|2
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Mode should be SCSI after a chip reset, but lets 	 * set it just to be safe.  We touch the MODE_PTR 	 * register directly so as to bypass the lazy update 	 * code in ahd_set_modes(). 	 */
name|ahd_known_modes
argument_list|(
name|ahd
argument_list|,
name|AHD_MODE_SCSI
argument_list|,
name|AHD_MODE_SCSI
argument_list|)
expr_stmt|;
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|MODE_PTR
argument_list|,
name|ahd_build_mode_state
argument_list|(
name|ahd
argument_list|,
name|AHD_MODE_SCSI
argument_list|,
name|AHD_MODE_SCSI
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Restore SXFRCTL1. 	 * 	 * We must always initialize STPWEN to 1 before we 	 * restore the saved values.  STPWEN is initialized 	 * to a tri-state condition which can only be cleared 	 * by turning it on. 	 */
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|SXFRCTL1
argument_list|,
name|sxfrctl1
operator||
name|STPWEN
argument_list|)
expr_stmt|;
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|SXFRCTL1
argument_list|,
name|sxfrctl1
argument_list|)
expr_stmt|;
comment|/* Determine chip configuration */
name|ahd
operator|->
name|features
operator|&=
operator|~
name|AHD_WIDE
expr_stmt|;
if|if
condition|(
operator|(
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|SBLKCTL
argument_list|)
operator|&
name|SELWIDE
operator|)
operator|!=
literal|0
condition|)
name|ahd
operator|->
name|features
operator||=
name|AHD_WIDE
expr_stmt|;
comment|/* 	 * If a recovery action has forced a chip reset, 	 * re-initialize the chip to our liking. 	 */
if|if
condition|(
name|reinit
operator|!=
literal|0
condition|)
name|ahd_chip_init
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Determine the number of SCBs available on the controller  */
end_comment

begin_function
name|int
name|ahd_probe_scbs
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|AHD_ASSERT_MODES
argument_list|(
name|ahd
argument_list|,
operator|~
operator|(
name|AHD_MODE_UNKNOWN_MSK
operator||
name|AHD_MODE_CFG_MSK
operator|)
argument_list|,
operator|~
operator|(
name|AHD_MODE_UNKNOWN_MSK
operator||
name|AHD_MODE_CFG_MSK
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|AHD_SCB_MAX
condition|;
name|i
operator|++
control|)
block|{
name|int
name|j
decl_stmt|;
name|ahd_set_scbptr
argument_list|(
name|ahd
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|ahd_outw
argument_list|(
name|ahd
argument_list|,
name|SCB_BASE
argument_list|,
name|i
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|2
init|;
name|j
operator|<
literal|64
condition|;
name|j
operator|++
control|)
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|SCB_BASE
operator|+
name|j
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Start out life as unallocated (needing an abort) */
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|SCB_CONTROL
argument_list|,
name|MK_MESSAGE
argument_list|)
expr_stmt|;
if|if
condition|(
name|ahd_inw_scbram
argument_list|(
name|ahd
argument_list|,
name|SCB_BASE
argument_list|)
operator|!=
name|i
condition|)
break|break;
name|ahd_set_scbptr
argument_list|(
name|ahd
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ahd_inw_scbram
argument_list|(
name|ahd
argument_list|,
name|SCB_BASE
argument_list|)
operator|!=
literal|0
condition|)
break|break;
block|}
return|return
operator|(
name|i
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ahd_dmamap_cb
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
name|nseg
parameter_list|,
name|int
name|error
parameter_list|)
block|{
name|bus_addr_t
modifier|*
name|baddr
decl_stmt|;
name|baddr
operator|=
operator|(
name|bus_addr_t
operator|*
operator|)
name|arg
expr_stmt|;
operator|*
name|baddr
operator|=
name|segs
operator|->
name|ds_addr
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ahd_initialize_hscbs
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ahd
operator|->
name|scb_data
operator|.
name|maxhscbs
condition|;
name|i
operator|++
control|)
block|{
name|ahd_set_scbptr
argument_list|(
name|ahd
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* Clear the control byte. */
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|SCB_CONTROL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Set the next pointer */
name|ahd_outw
argument_list|(
name|ahd
argument_list|,
name|SCB_NEXT
argument_list|,
name|SCB_LIST_NULL
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|ahd_init_scbdata
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|)
block|{
name|struct
name|scb_data
modifier|*
name|scb_data
decl_stmt|;
name|int
name|i
decl_stmt|;
name|scb_data
operator|=
operator|&
name|ahd
operator|->
name|scb_data
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|scb_data
operator|->
name|free_scbs
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|AHD_NUM_TARGETS
operator|*
name|AHD_NUM_LUNS_NONPKT
condition|;
name|i
operator|++
control|)
name|LIST_INIT
argument_list|(
operator|&
name|scb_data
operator|->
name|free_scb_lists
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|scb_data
operator|->
name|any_dev_free_scb_list
argument_list|)
expr_stmt|;
name|SLIST_INIT
argument_list|(
operator|&
name|scb_data
operator|->
name|hscb_maps
argument_list|)
expr_stmt|;
name|SLIST_INIT
argument_list|(
operator|&
name|scb_data
operator|->
name|sg_maps
argument_list|)
expr_stmt|;
name|SLIST_INIT
argument_list|(
operator|&
name|scb_data
operator|->
name|sense_maps
argument_list|)
expr_stmt|;
comment|/* Determine the number of hardware SCBs and initialize them */
name|scb_data
operator|->
name|maxhscbs
operator|=
name|ahd_probe_scbs
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
if|if
condition|(
name|scb_data
operator|->
name|maxhscbs
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%s: No SCB space found\n"
argument_list|,
name|ahd_name
argument_list|(
name|ahd
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|ahd_initialize_hscbs
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
comment|/* 	 * Create our DMA tags.  These tags define the kinds of device 	 * accessible memory allocations and memory mappings we will 	 * need to perform during normal operation. 	 * 	 * Unless we need to further restrict the allocation, we rely 	 * on the restrictions of the parent dmat, hence the common 	 * use of MAXADDR and MAXSIZE. 	 */
comment|/* DMA tag for our hardware scb structures */
if|if
condition|(
name|aic_dma_tag_create
argument_list|(
name|ahd
argument_list|,
name|ahd
operator|->
name|parent_dmat
argument_list|,
comment|/*alignment*/
literal|1
argument_list|,
comment|/*boundary*/
name|BUS_SPACE_MAXADDR_32BIT
operator|+
literal|1
argument_list|,
comment|/*lowaddr*/
name|BUS_SPACE_MAXADDR_32BIT
argument_list|,
comment|/*highaddr*/
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/*filter*/
name|NULL
argument_list|,
comment|/*filterarg*/
name|NULL
argument_list|,
name|PAGE_SIZE
argument_list|,
comment|/*nsegments*/
literal|1
argument_list|,
comment|/*maxsegsz*/
name|BUS_SPACE_MAXSIZE_32BIT
argument_list|,
comment|/*flags*/
literal|0
argument_list|,
operator|&
name|scb_data
operator|->
name|hscb_dmat
argument_list|)
operator|!=
literal|0
condition|)
block|{
goto|goto
name|error_exit
goto|;
block|}
name|scb_data
operator|->
name|init_level
operator|++
expr_stmt|;
comment|/* DMA tag for our S/G structures. */
if|if
condition|(
name|aic_dma_tag_create
argument_list|(
name|ahd
argument_list|,
name|ahd
operator|->
name|parent_dmat
argument_list|,
comment|/*alignment*/
literal|8
argument_list|,
comment|/*boundary*/
name|BUS_SPACE_MAXADDR_32BIT
operator|+
literal|1
argument_list|,
comment|/*lowaddr*/
name|BUS_SPACE_MAXADDR_32BIT
argument_list|,
comment|/*highaddr*/
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/*filter*/
name|NULL
argument_list|,
comment|/*filterarg*/
name|NULL
argument_list|,
name|ahd_sglist_allocsize
argument_list|(
name|ahd
argument_list|)
argument_list|,
comment|/*nsegments*/
literal|1
argument_list|,
comment|/*maxsegsz*/
name|BUS_SPACE_MAXSIZE_32BIT
argument_list|,
comment|/*flags*/
literal|0
argument_list|,
operator|&
name|scb_data
operator|->
name|sg_dmat
argument_list|)
operator|!=
literal|0
condition|)
block|{
goto|goto
name|error_exit
goto|;
block|}
ifdef|#
directive|ifdef
name|AHD_DEBUG
if|if
condition|(
operator|(
name|ahd_debug
operator|&
name|AHD_SHOW_MEMORY
operator|)
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|"%s: ahd_sglist_allocsize = 0x%x\n"
argument_list|,
name|ahd_name
argument_list|(
name|ahd
argument_list|)
argument_list|,
name|ahd_sglist_allocsize
argument_list|(
name|ahd
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|scb_data
operator|->
name|init_level
operator|++
expr_stmt|;
comment|/* DMA tag for our sense buffers.  We allocate in page sized chunks */
if|if
condition|(
name|aic_dma_tag_create
argument_list|(
name|ahd
argument_list|,
name|ahd
operator|->
name|parent_dmat
argument_list|,
comment|/*alignment*/
literal|1
argument_list|,
comment|/*boundary*/
name|BUS_SPACE_MAXADDR_32BIT
operator|+
literal|1
argument_list|,
comment|/*lowaddr*/
name|BUS_SPACE_MAXADDR_32BIT
argument_list|,
comment|/*highaddr*/
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/*filter*/
name|NULL
argument_list|,
comment|/*filterarg*/
name|NULL
argument_list|,
name|PAGE_SIZE
argument_list|,
comment|/*nsegments*/
literal|1
argument_list|,
comment|/*maxsegsz*/
name|BUS_SPACE_MAXSIZE_32BIT
argument_list|,
comment|/*flags*/
literal|0
argument_list|,
operator|&
name|scb_data
operator|->
name|sense_dmat
argument_list|)
operator|!=
literal|0
condition|)
block|{
goto|goto
name|error_exit
goto|;
block|}
name|scb_data
operator|->
name|init_level
operator|++
expr_stmt|;
comment|/* Perform initial CCB allocation */
name|ahd_alloc_scbs
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
if|if
condition|(
name|scb_data
operator|->
name|numscbs
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%s: ahd_init_scbdata - "
literal|"Unable to allocate initial scbs\n"
argument_list|,
name|ahd_name
argument_list|(
name|ahd
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|error_exit
goto|;
block|}
comment|/* 	 * Note that we were successfull 	 */
return|return
operator|(
literal|0
operator|)
return|;
name|error_exit
label|:
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|scb
modifier|*
name|ahd_find_scb_by_tag
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|,
name|u_int
name|tag
parameter_list|)
block|{
name|struct
name|scb
modifier|*
name|scb
decl_stmt|;
comment|/* 	 * Look on the pending list. 	 */
name|LIST_FOREACH
argument_list|(
argument|scb
argument_list|,
argument|&ahd->pending_scbs
argument_list|,
argument|pending_links
argument_list|)
block|{
if|if
condition|(
name|SCB_GET_TAG
argument_list|(
name|scb
argument_list|)
operator|==
name|tag
condition|)
return|return
operator|(
name|scb
operator|)
return|;
block|}
comment|/* 	 * Then on all of the collision free lists. 	 */
name|TAILQ_FOREACH
argument_list|(
argument|scb
argument_list|,
argument|&ahd->scb_data.free_scbs
argument_list|,
argument|links.tqe
argument_list|)
block|{
name|struct
name|scb
modifier|*
name|list_scb
decl_stmt|;
name|list_scb
operator|=
name|scb
expr_stmt|;
do|do
block|{
if|if
condition|(
name|SCB_GET_TAG
argument_list|(
name|list_scb
argument_list|)
operator|==
name|tag
condition|)
return|return
operator|(
name|list_scb
operator|)
return|;
name|list_scb
operator|=
name|LIST_NEXT
argument_list|(
name|list_scb
argument_list|,
name|collision_links
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|list_scb
condition|)
do|;
block|}
comment|/* 	 * And finally on the generic free list. 	 */
name|LIST_FOREACH
argument_list|(
argument|scb
argument_list|,
argument|&ahd->scb_data.any_dev_free_scb_list
argument_list|,
argument|links.le
argument_list|)
block|{
if|if
condition|(
name|SCB_GET_TAG
argument_list|(
name|scb
argument_list|)
operator|==
name|tag
condition|)
return|return
operator|(
name|scb
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ahd_fini_scbdata
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|)
block|{
name|struct
name|scb_data
modifier|*
name|scb_data
decl_stmt|;
name|scb_data
operator|=
operator|&
name|ahd
operator|->
name|scb_data
expr_stmt|;
if|if
condition|(
name|scb_data
operator|==
name|NULL
condition|)
return|return;
switch|switch
condition|(
name|scb_data
operator|->
name|init_level
condition|)
block|{
default|default:
case|case
literal|7
case|:
block|{
name|struct
name|map_node
modifier|*
name|sns_map
decl_stmt|;
while|while
condition|(
operator|(
name|sns_map
operator|=
name|SLIST_FIRST
argument_list|(
operator|&
name|scb_data
operator|->
name|sense_maps
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|SLIST_REMOVE_HEAD
argument_list|(
operator|&
name|scb_data
operator|->
name|sense_maps
argument_list|,
name|links
argument_list|)
expr_stmt|;
name|aic_dmamap_unload
argument_list|(
name|ahd
argument_list|,
name|scb_data
operator|->
name|sense_dmat
argument_list|,
name|sns_map
operator|->
name|dmamap
argument_list|)
expr_stmt|;
name|aic_dmamem_free
argument_list|(
name|ahd
argument_list|,
name|scb_data
operator|->
name|sense_dmat
argument_list|,
name|sns_map
operator|->
name|vaddr
argument_list|,
name|sns_map
operator|->
name|dmamap
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sns_map
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
name|aic_dma_tag_destroy
argument_list|(
name|ahd
argument_list|,
name|scb_data
operator|->
name|sense_dmat
argument_list|)
expr_stmt|;
comment|/* FALLTHROUGH */
block|}
case|case
literal|6
case|:
block|{
name|struct
name|map_node
modifier|*
name|sg_map
decl_stmt|;
while|while
condition|(
operator|(
name|sg_map
operator|=
name|SLIST_FIRST
argument_list|(
operator|&
name|scb_data
operator|->
name|sg_maps
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|SLIST_REMOVE_HEAD
argument_list|(
operator|&
name|scb_data
operator|->
name|sg_maps
argument_list|,
name|links
argument_list|)
expr_stmt|;
name|aic_dmamap_unload
argument_list|(
name|ahd
argument_list|,
name|scb_data
operator|->
name|sg_dmat
argument_list|,
name|sg_map
operator|->
name|dmamap
argument_list|)
expr_stmt|;
name|aic_dmamem_free
argument_list|(
name|ahd
argument_list|,
name|scb_data
operator|->
name|sg_dmat
argument_list|,
name|sg_map
operator|->
name|vaddr
argument_list|,
name|sg_map
operator|->
name|dmamap
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sg_map
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
name|aic_dma_tag_destroy
argument_list|(
name|ahd
argument_list|,
name|scb_data
operator|->
name|sg_dmat
argument_list|)
expr_stmt|;
comment|/* FALLTHROUGH */
block|}
case|case
literal|5
case|:
block|{
name|struct
name|map_node
modifier|*
name|hscb_map
decl_stmt|;
while|while
condition|(
operator|(
name|hscb_map
operator|=
name|SLIST_FIRST
argument_list|(
operator|&
name|scb_data
operator|->
name|hscb_maps
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|SLIST_REMOVE_HEAD
argument_list|(
operator|&
name|scb_data
operator|->
name|hscb_maps
argument_list|,
name|links
argument_list|)
expr_stmt|;
name|aic_dmamap_unload
argument_list|(
name|ahd
argument_list|,
name|scb_data
operator|->
name|hscb_dmat
argument_list|,
name|hscb_map
operator|->
name|dmamap
argument_list|)
expr_stmt|;
name|aic_dmamem_free
argument_list|(
name|ahd
argument_list|,
name|scb_data
operator|->
name|hscb_dmat
argument_list|,
name|hscb_map
operator|->
name|vaddr
argument_list|,
name|hscb_map
operator|->
name|dmamap
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|hscb_map
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
name|aic_dma_tag_destroy
argument_list|(
name|ahd
argument_list|,
name|scb_data
operator|->
name|hscb_dmat
argument_list|)
expr_stmt|;
comment|/* FALLTHROUGH */
block|}
case|case
literal|4
case|:
case|case
literal|3
case|:
case|case
literal|2
case|:
case|case
literal|1
case|:
case|case
literal|0
case|:
break|break;
block|}
block|}
end_function

begin_comment
comment|/*  * DSP filter Bypass must be enabled until the first selection  * after a change in bus mode (Razor #491 and #493).  */
end_comment

begin_function
specifier|static
name|void
name|ahd_setup_iocell_workaround
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|)
block|{
name|ahd_mode_state
name|saved_modes
decl_stmt|;
name|saved_modes
operator|=
name|ahd_save_modes
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
name|ahd_set_modes
argument_list|(
name|ahd
argument_list|,
name|AHD_MODE_CFG
argument_list|,
name|AHD_MODE_CFG
argument_list|)
expr_stmt|;
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|DSPDATACTL
argument_list|,
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|DSPDATACTL
argument_list|)
operator||
name|BYPASSENAB
operator||
name|RCVROFFSTDIS
operator||
name|XMITOFFSTDIS
argument_list|)
expr_stmt|;
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|SIMODE0
argument_list|,
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|SIMODE0
argument_list|)
operator||
operator|(
name|ENSELDO
operator||
name|ENSELDI
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|AHD_DEBUG
if|if
condition|(
operator|(
name|ahd_debug
operator|&
name|AHD_SHOW_MISC
operator|)
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|"%s: Setting up iocell workaround\n"
argument_list|,
name|ahd_name
argument_list|(
name|ahd
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ahd_restore_modes
argument_list|(
name|ahd
argument_list|,
name|saved_modes
argument_list|)
expr_stmt|;
name|ahd
operator|->
name|flags
operator|&=
operator|~
name|AHD_HAD_FIRST_SEL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ahd_iocell_first_selection
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|)
block|{
name|ahd_mode_state
name|saved_modes
decl_stmt|;
name|u_int
name|sblkctl
decl_stmt|;
if|if
condition|(
operator|(
name|ahd
operator|->
name|flags
operator|&
name|AHD_HAD_FIRST_SEL
operator|)
operator|!=
literal|0
condition|)
return|return;
name|saved_modes
operator|=
name|ahd_save_modes
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
name|ahd_set_modes
argument_list|(
name|ahd
argument_list|,
name|AHD_MODE_SCSI
argument_list|,
name|AHD_MODE_SCSI
argument_list|)
expr_stmt|;
name|sblkctl
operator|=
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|SBLKCTL
argument_list|)
expr_stmt|;
name|ahd_set_modes
argument_list|(
name|ahd
argument_list|,
name|AHD_MODE_CFG
argument_list|,
name|AHD_MODE_CFG
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|AHD_DEBUG
if|if
condition|(
operator|(
name|ahd_debug
operator|&
name|AHD_SHOW_MISC
operator|)
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|"%s: iocell first selection\n"
argument_list|,
name|ahd_name
argument_list|(
name|ahd
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|sblkctl
operator|&
name|ENAB40
operator|)
operator|!=
literal|0
condition|)
block|{
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|DSPDATACTL
argument_list|,
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|DSPDATACTL
argument_list|)
operator|&
operator|~
name|BYPASSENAB
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|AHD_DEBUG
if|if
condition|(
operator|(
name|ahd_debug
operator|&
name|AHD_SHOW_MISC
operator|)
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|"%s: BYPASS now disabled\n"
argument_list|,
name|ahd_name
argument_list|(
name|ahd
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|SIMODE0
argument_list|,
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|SIMODE0
argument_list|)
operator|&
operator|~
operator|(
name|ENSELDO
operator||
name|ENSELDI
operator|)
argument_list|)
expr_stmt|;
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|CLRINT
argument_list|,
name|CLRSCSIINT
argument_list|)
expr_stmt|;
name|ahd_restore_modes
argument_list|(
name|ahd
argument_list|,
name|saved_modes
argument_list|)
expr_stmt|;
name|ahd
operator|->
name|flags
operator||=
name|AHD_HAD_FIRST_SEL
expr_stmt|;
block|}
end_function

begin_comment
comment|/*************************** SCB Management ***********************************/
end_comment

begin_function
specifier|static
name|void
name|ahd_add_col_list
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|,
name|struct
name|scb
modifier|*
name|scb
parameter_list|,
name|u_int
name|col_idx
parameter_list|)
block|{
name|struct
name|scb_list
modifier|*
name|free_list
decl_stmt|;
name|struct
name|scb_tailq
modifier|*
name|free_tailq
decl_stmt|;
name|struct
name|scb
modifier|*
name|first_scb
decl_stmt|;
name|scb
operator|->
name|flags
operator||=
name|SCB_ON_COL_LIST
expr_stmt|;
name|AHD_SET_SCB_COL_IDX
argument_list|(
name|scb
argument_list|,
name|col_idx
argument_list|)
expr_stmt|;
name|free_list
operator|=
operator|&
name|ahd
operator|->
name|scb_data
operator|.
name|free_scb_lists
index|[
name|col_idx
index|]
expr_stmt|;
name|free_tailq
operator|=
operator|&
name|ahd
operator|->
name|scb_data
operator|.
name|free_scbs
expr_stmt|;
name|first_scb
operator|=
name|LIST_FIRST
argument_list|(
name|free_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|first_scb
operator|!=
name|NULL
condition|)
block|{
name|LIST_INSERT_AFTER
argument_list|(
name|first_scb
argument_list|,
name|scb
argument_list|,
name|collision_links
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LIST_INSERT_HEAD
argument_list|(
name|free_list
argument_list|,
name|scb
argument_list|,
name|collision_links
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
name|free_tailq
argument_list|,
name|scb
argument_list|,
name|links
operator|.
name|tqe
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ahd_rem_col_list
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|,
name|struct
name|scb
modifier|*
name|scb
parameter_list|)
block|{
name|struct
name|scb_list
modifier|*
name|free_list
decl_stmt|;
name|struct
name|scb_tailq
modifier|*
name|free_tailq
decl_stmt|;
name|struct
name|scb
modifier|*
name|first_scb
decl_stmt|;
name|u_int
name|col_idx
decl_stmt|;
name|scb
operator|->
name|flags
operator|&=
operator|~
name|SCB_ON_COL_LIST
expr_stmt|;
name|col_idx
operator|=
name|AHD_GET_SCB_COL_IDX
argument_list|(
name|ahd
argument_list|,
name|scb
argument_list|)
expr_stmt|;
name|free_list
operator|=
operator|&
name|ahd
operator|->
name|scb_data
operator|.
name|free_scb_lists
index|[
name|col_idx
index|]
expr_stmt|;
name|free_tailq
operator|=
operator|&
name|ahd
operator|->
name|scb_data
operator|.
name|free_scbs
expr_stmt|;
name|first_scb
operator|=
name|LIST_FIRST
argument_list|(
name|free_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|first_scb
operator|==
name|scb
condition|)
block|{
name|struct
name|scb
modifier|*
name|next_scb
decl_stmt|;
comment|/* 		 * Maintain order in the collision free 		 * lists for fairness if this device has 		 * other colliding tags active. 		 */
name|next_scb
operator|=
name|LIST_NEXT
argument_list|(
name|scb
argument_list|,
name|collision_links
argument_list|)
expr_stmt|;
if|if
condition|(
name|next_scb
operator|!=
name|NULL
condition|)
block|{
name|TAILQ_INSERT_AFTER
argument_list|(
name|free_tailq
argument_list|,
name|scb
argument_list|,
name|next_scb
argument_list|,
name|links
operator|.
name|tqe
argument_list|)
expr_stmt|;
block|}
name|TAILQ_REMOVE
argument_list|(
name|free_tailq
argument_list|,
name|scb
argument_list|,
name|links
operator|.
name|tqe
argument_list|)
expr_stmt|;
block|}
name|LIST_REMOVE
argument_list|(
name|scb
argument_list|,
name|collision_links
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Get a free scb. If there are none, see if we can allocate a new SCB.  */
end_comment

begin_function
name|struct
name|scb
modifier|*
name|ahd_get_scb
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|,
name|u_int
name|col_idx
parameter_list|)
block|{
name|struct
name|scb
modifier|*
name|scb
decl_stmt|;
name|int
name|tries
decl_stmt|;
name|tries
operator|=
literal|0
expr_stmt|;
name|look_again
label|:
name|TAILQ_FOREACH
argument_list|(
argument|scb
argument_list|,
argument|&ahd->scb_data.free_scbs
argument_list|,
argument|links.tqe
argument_list|)
block|{
if|if
condition|(
name|AHD_GET_SCB_COL_IDX
argument_list|(
name|ahd
argument_list|,
name|scb
argument_list|)
operator|!=
name|col_idx
condition|)
block|{
name|ahd_rem_col_list
argument_list|(
name|ahd
argument_list|,
name|scb
argument_list|)
expr_stmt|;
goto|goto
name|found
goto|;
block|}
block|}
if|if
condition|(
operator|(
name|scb
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|ahd
operator|->
name|scb_data
operator|.
name|any_dev_free_scb_list
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|tries
operator|++
operator|!=
literal|0
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|ahd_alloc_scbs
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
goto|goto
name|look_again
goto|;
block|}
name|LIST_REMOVE
argument_list|(
name|scb
argument_list|,
name|links
operator|.
name|le
argument_list|)
expr_stmt|;
if|if
condition|(
name|col_idx
operator|!=
name|AHD_NEVER_COL_IDX
operator|&&
operator|(
name|scb
operator|->
name|col_scb
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|scb
operator|->
name|col_scb
operator|->
name|flags
operator|&
name|SCB_ACTIVE
operator|)
operator|==
literal|0
condition|)
block|{
name|LIST_REMOVE
argument_list|(
name|scb
operator|->
name|col_scb
argument_list|,
name|links
operator|.
name|le
argument_list|)
expr_stmt|;
name|ahd_add_col_list
argument_list|(
name|ahd
argument_list|,
name|scb
operator|->
name|col_scb
argument_list|,
name|col_idx
argument_list|)
expr_stmt|;
block|}
name|found
label|:
name|scb
operator|->
name|flags
operator||=
name|SCB_ACTIVE
expr_stmt|;
return|return
operator|(
name|scb
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return an SCB resource to the free list.  */
end_comment

begin_function
name|void
name|ahd_free_scb
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|,
name|struct
name|scb
modifier|*
name|scb
parameter_list|)
block|{
comment|/* Clean up for the next user */
name|scb
operator|->
name|flags
operator|=
name|SCB_FLAG_NONE
expr_stmt|;
name|scb
operator|->
name|hscb
operator|->
name|control
operator|=
literal|0
expr_stmt|;
name|ahd
operator|->
name|scb_data
operator|.
name|scbindex
index|[
name|SCB_GET_TAG
argument_list|(
name|scb
argument_list|)
index|]
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|scb
operator|->
name|col_scb
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * No collision possible.  Just free normally. 		 */
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|ahd
operator|->
name|scb_data
operator|.
name|any_dev_free_scb_list
argument_list|,
name|scb
argument_list|,
name|links
operator|.
name|le
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|scb
operator|->
name|col_scb
operator|->
name|flags
operator|&
name|SCB_ON_COL_LIST
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * The SCB we might have collided with is on 		 * a free collision list.  Put both SCBs on 		 * the generic list. 		 */
name|ahd_rem_col_list
argument_list|(
name|ahd
argument_list|,
name|scb
operator|->
name|col_scb
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|ahd
operator|->
name|scb_data
operator|.
name|any_dev_free_scb_list
argument_list|,
name|scb
argument_list|,
name|links
operator|.
name|le
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|ahd
operator|->
name|scb_data
operator|.
name|any_dev_free_scb_list
argument_list|,
name|scb
operator|->
name|col_scb
argument_list|,
name|links
operator|.
name|le
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|scb
operator|->
name|col_scb
operator|->
name|flags
operator|&
operator|(
name|SCB_PACKETIZED
operator||
name|SCB_ACTIVE
operator|)
operator|)
operator|==
name|SCB_ACTIVE
operator|&&
operator|(
name|scb
operator|->
name|col_scb
operator|->
name|hscb
operator|->
name|control
operator|&
name|TAG_ENB
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * The SCB we might collide with on the next allocation 		 * is still active in a non-packetized, tagged, context. 		 * Put us on the SCB collision list. 		 */
name|ahd_add_col_list
argument_list|(
name|ahd
argument_list|,
name|scb
argument_list|,
name|AHD_GET_SCB_COL_IDX
argument_list|(
name|ahd
argument_list|,
name|scb
operator|->
name|col_scb
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * The SCB we might collide with on the next allocation 		 * is either active in a packetized context, or free. 		 * Since we can't collide, put this SCB on the generic 		 * free list. 		 */
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|ahd
operator|->
name|scb_data
operator|.
name|any_dev_free_scb_list
argument_list|,
name|scb
argument_list|,
name|links
operator|.
name|le
argument_list|)
expr_stmt|;
block|}
name|aic_platform_scb_free
argument_list|(
name|ahd
argument_list|,
name|scb
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ahd_alloc_scbs
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|)
block|{
name|struct
name|scb_data
modifier|*
name|scb_data
decl_stmt|;
name|struct
name|scb
modifier|*
name|next_scb
decl_stmt|;
name|struct
name|hardware_scb
modifier|*
name|hscb
decl_stmt|;
name|struct
name|map_node
modifier|*
name|hscb_map
decl_stmt|;
name|struct
name|map_node
modifier|*
name|sg_map
decl_stmt|;
name|struct
name|map_node
modifier|*
name|sense_map
decl_stmt|;
name|uint8_t
modifier|*
name|segs
decl_stmt|;
name|uint8_t
modifier|*
name|sense_data
decl_stmt|;
name|bus_addr_t
name|hscb_busaddr
decl_stmt|;
name|bus_addr_t
name|sg_busaddr
decl_stmt|;
name|bus_addr_t
name|sense_busaddr
decl_stmt|;
name|int
name|newcount
decl_stmt|;
name|int
name|i
decl_stmt|;
name|scb_data
operator|=
operator|&
name|ahd
operator|->
name|scb_data
expr_stmt|;
if|if
condition|(
name|scb_data
operator|->
name|numscbs
operator|>=
name|AHD_SCB_MAX_ALLOC
condition|)
comment|/* Can't allocate any more */
return|return;
if|if
condition|(
name|scb_data
operator|->
name|scbs_left
operator|!=
literal|0
condition|)
block|{
name|int
name|offset
decl_stmt|;
name|offset
operator|=
operator|(
name|PAGE_SIZE
operator|/
sizeof|sizeof
argument_list|(
operator|*
name|hscb
argument_list|)
operator|)
operator|-
name|scb_data
operator|->
name|scbs_left
expr_stmt|;
name|hscb_map
operator|=
name|SLIST_FIRST
argument_list|(
operator|&
name|scb_data
operator|->
name|hscb_maps
argument_list|)
expr_stmt|;
name|hscb
operator|=
operator|&
operator|(
operator|(
expr|struct
name|hardware_scb
operator|*
operator|)
name|hscb_map
operator|->
name|vaddr
operator|)
index|[
name|offset
index|]
expr_stmt|;
name|hscb_busaddr
operator|=
name|hscb_map
operator|->
name|busaddr
operator|+
operator|(
name|offset
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|hscb
argument_list|)
operator|)
expr_stmt|;
block|}
else|else
block|{
name|hscb_map
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|hscb_map
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|hscb_map
operator|==
name|NULL
condition|)
return|return;
comment|/* Allocate the next batch of hardware SCBs */
if|if
condition|(
name|aic_dmamem_alloc
argument_list|(
name|ahd
argument_list|,
name|scb_data
operator|->
name|hscb_dmat
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|hscb_map
operator|->
name|vaddr
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|,
operator|&
name|hscb_map
operator|->
name|dmamap
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|free
argument_list|(
name|hscb_map
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return;
block|}
name|SLIST_INSERT_HEAD
argument_list|(
operator|&
name|scb_data
operator|->
name|hscb_maps
argument_list|,
name|hscb_map
argument_list|,
name|links
argument_list|)
expr_stmt|;
name|aic_dmamap_load
argument_list|(
name|ahd
argument_list|,
name|scb_data
operator|->
name|hscb_dmat
argument_list|,
name|hscb_map
operator|->
name|dmamap
argument_list|,
name|hscb_map
operator|->
name|vaddr
argument_list|,
name|PAGE_SIZE
argument_list|,
name|ahd_dmamap_cb
argument_list|,
operator|&
name|hscb_map
operator|->
name|busaddr
argument_list|,
comment|/*flags*/
literal|0
argument_list|)
expr_stmt|;
name|hscb
operator|=
operator|(
expr|struct
name|hardware_scb
operator|*
operator|)
name|hscb_map
operator|->
name|vaddr
expr_stmt|;
name|hscb_busaddr
operator|=
name|hscb_map
operator|->
name|busaddr
expr_stmt|;
name|scb_data
operator|->
name|scbs_left
operator|=
name|PAGE_SIZE
operator|/
sizeof|sizeof
argument_list|(
operator|*
name|hscb
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|scb_data
operator|->
name|sgs_left
operator|!=
literal|0
condition|)
block|{
name|int
name|offset
decl_stmt|;
name|offset
operator|=
operator|(
operator|(
name|ahd_sglist_allocsize
argument_list|(
name|ahd
argument_list|)
operator|/
name|ahd_sglist_size
argument_list|(
name|ahd
argument_list|)
operator|)
operator|-
name|scb_data
operator|->
name|sgs_left
operator|)
operator|*
name|ahd_sglist_size
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
name|sg_map
operator|=
name|SLIST_FIRST
argument_list|(
operator|&
name|scb_data
operator|->
name|sg_maps
argument_list|)
expr_stmt|;
name|segs
operator|=
name|sg_map
operator|->
name|vaddr
operator|+
name|offset
expr_stmt|;
name|sg_busaddr
operator|=
name|sg_map
operator|->
name|busaddr
operator|+
name|offset
expr_stmt|;
block|}
else|else
block|{
name|sg_map
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|sg_map
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|sg_map
operator|==
name|NULL
condition|)
return|return;
comment|/* Allocate the next batch of S/G lists */
if|if
condition|(
name|aic_dmamem_alloc
argument_list|(
name|ahd
argument_list|,
name|scb_data
operator|->
name|sg_dmat
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|sg_map
operator|->
name|vaddr
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|,
operator|&
name|sg_map
operator|->
name|dmamap
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|free
argument_list|(
name|sg_map
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return;
block|}
name|SLIST_INSERT_HEAD
argument_list|(
operator|&
name|scb_data
operator|->
name|sg_maps
argument_list|,
name|sg_map
argument_list|,
name|links
argument_list|)
expr_stmt|;
name|aic_dmamap_load
argument_list|(
name|ahd
argument_list|,
name|scb_data
operator|->
name|sg_dmat
argument_list|,
name|sg_map
operator|->
name|dmamap
argument_list|,
name|sg_map
operator|->
name|vaddr
argument_list|,
name|ahd_sglist_allocsize
argument_list|(
name|ahd
argument_list|)
argument_list|,
name|ahd_dmamap_cb
argument_list|,
operator|&
name|sg_map
operator|->
name|busaddr
argument_list|,
comment|/*flags*/
literal|0
argument_list|)
expr_stmt|;
name|segs
operator|=
name|sg_map
operator|->
name|vaddr
expr_stmt|;
name|sg_busaddr
operator|=
name|sg_map
operator|->
name|busaddr
expr_stmt|;
name|scb_data
operator|->
name|sgs_left
operator|=
name|ahd_sglist_allocsize
argument_list|(
name|ahd
argument_list|)
operator|/
name|ahd_sglist_size
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|AHD_DEBUG
if|if
condition|(
name|ahd_debug
operator|&
name|AHD_SHOW_MEMORY
condition|)
name|printf
argument_list|(
literal|"Mapped SG data\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|scb_data
operator|->
name|sense_left
operator|!=
literal|0
condition|)
block|{
name|int
name|offset
decl_stmt|;
name|offset
operator|=
name|PAGE_SIZE
operator|-
operator|(
name|AHD_SENSE_BUFSIZE
operator|*
name|scb_data
operator|->
name|sense_left
operator|)
expr_stmt|;
name|sense_map
operator|=
name|SLIST_FIRST
argument_list|(
operator|&
name|scb_data
operator|->
name|sense_maps
argument_list|)
expr_stmt|;
name|sense_data
operator|=
name|sense_map
operator|->
name|vaddr
operator|+
name|offset
expr_stmt|;
name|sense_busaddr
operator|=
name|sense_map
operator|->
name|busaddr
operator|+
name|offset
expr_stmt|;
block|}
else|else
block|{
name|sense_map
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|sense_map
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|sense_map
operator|==
name|NULL
condition|)
return|return;
comment|/* Allocate the next batch of sense buffers */
if|if
condition|(
name|aic_dmamem_alloc
argument_list|(
name|ahd
argument_list|,
name|scb_data
operator|->
name|sense_dmat
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|sense_map
operator|->
name|vaddr
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|,
operator|&
name|sense_map
operator|->
name|dmamap
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|free
argument_list|(
name|sense_map
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return;
block|}
name|SLIST_INSERT_HEAD
argument_list|(
operator|&
name|scb_data
operator|->
name|sense_maps
argument_list|,
name|sense_map
argument_list|,
name|links
argument_list|)
expr_stmt|;
name|aic_dmamap_load
argument_list|(
name|ahd
argument_list|,
name|scb_data
operator|->
name|sense_dmat
argument_list|,
name|sense_map
operator|->
name|dmamap
argument_list|,
name|sense_map
operator|->
name|vaddr
argument_list|,
name|PAGE_SIZE
argument_list|,
name|ahd_dmamap_cb
argument_list|,
operator|&
name|sense_map
operator|->
name|busaddr
argument_list|,
comment|/*flags*/
literal|0
argument_list|)
expr_stmt|;
name|sense_data
operator|=
name|sense_map
operator|->
name|vaddr
expr_stmt|;
name|sense_busaddr
operator|=
name|sense_map
operator|->
name|busaddr
expr_stmt|;
name|scb_data
operator|->
name|sense_left
operator|=
name|PAGE_SIZE
operator|/
name|AHD_SENSE_BUFSIZE
expr_stmt|;
ifdef|#
directive|ifdef
name|AHD_DEBUG
if|if
condition|(
name|ahd_debug
operator|&
name|AHD_SHOW_MEMORY
condition|)
name|printf
argument_list|(
literal|"Mapped sense data\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|newcount
operator|=
name|MIN
argument_list|(
name|scb_data
operator|->
name|sense_left
argument_list|,
name|scb_data
operator|->
name|scbs_left
argument_list|)
expr_stmt|;
name|newcount
operator|=
name|MIN
argument_list|(
name|newcount
argument_list|,
name|scb_data
operator|->
name|sgs_left
argument_list|)
expr_stmt|;
name|newcount
operator|=
name|MIN
argument_list|(
name|newcount
argument_list|,
operator|(
name|AHD_SCB_MAX_ALLOC
operator|-
name|scb_data
operator|->
name|numscbs
operator|)
argument_list|)
expr_stmt|;
name|scb_data
operator|->
name|sense_left
operator|-=
name|newcount
expr_stmt|;
name|scb_data
operator|->
name|scbs_left
operator|-=
name|newcount
expr_stmt|;
name|scb_data
operator|->
name|sgs_left
operator|-=
name|newcount
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|newcount
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|scb_platform_data
modifier|*
name|pdata
decl_stmt|;
name|u_int
name|col_tag
decl_stmt|;
ifndef|#
directive|ifndef
name|__linux__
name|int
name|error
decl_stmt|;
endif|#
directive|endif
name|next_scb
operator|=
operator|(
expr|struct
name|scb
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|next_scb
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|next_scb
operator|==
name|NULL
condition|)
break|break;
name|pdata
operator|=
operator|(
expr|struct
name|scb_platform_data
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|pdata
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|pdata
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|next_scb
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
break|break;
block|}
name|next_scb
operator|->
name|platform_data
operator|=
name|pdata
expr_stmt|;
name|next_scb
operator|->
name|hscb_map
operator|=
name|hscb_map
expr_stmt|;
name|next_scb
operator|->
name|sg_map
operator|=
name|sg_map
expr_stmt|;
name|next_scb
operator|->
name|sense_map
operator|=
name|sense_map
expr_stmt|;
name|next_scb
operator|->
name|sg_list
operator|=
name|segs
expr_stmt|;
name|next_scb
operator|->
name|sense_data
operator|=
name|sense_data
expr_stmt|;
name|next_scb
operator|->
name|sense_busaddr
operator|=
name|sense_busaddr
expr_stmt|;
name|memset
argument_list|(
name|hscb
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|hscb
argument_list|)
argument_list|)
expr_stmt|;
name|next_scb
operator|->
name|hscb
operator|=
name|hscb
expr_stmt|;
name|hscb
operator|->
name|hscb_busaddr
operator|=
name|aic_htole32
argument_list|(
name|hscb_busaddr
argument_list|)
expr_stmt|;
comment|/* 		 * The sequencer always starts with the second entry. 		 * The first entry is embedded in the scb. 		 */
name|next_scb
operator|->
name|sg_list_busaddr
operator|=
name|sg_busaddr
expr_stmt|;
if|if
condition|(
operator|(
name|ahd
operator|->
name|flags
operator|&
name|AHD_64BIT_ADDRESSING
operator|)
operator|!=
literal|0
condition|)
name|next_scb
operator|->
name|sg_list_busaddr
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|ahd_dma64_seg
argument_list|)
expr_stmt|;
else|else
name|next_scb
operator|->
name|sg_list_busaddr
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|ahd_dma_seg
argument_list|)
expr_stmt|;
name|next_scb
operator|->
name|ahd_softc
operator|=
name|ahd
expr_stmt|;
name|next_scb
operator|->
name|flags
operator|=
name|SCB_FLAG_NONE
expr_stmt|;
ifndef|#
directive|ifndef
name|__linux__
name|error
operator|=
name|aic_dmamap_create
argument_list|(
name|ahd
argument_list|,
name|ahd
operator|->
name|buffer_dmat
argument_list|,
comment|/*flags*/
literal|0
argument_list|,
operator|&
name|next_scb
operator|->
name|dmamap
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|free
argument_list|(
name|next_scb
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|pdata
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
name|next_scb
operator|->
name|hscb
operator|->
name|tag
operator|=
name|aic_htole16
argument_list|(
name|scb_data
operator|->
name|numscbs
argument_list|)
expr_stmt|;
name|col_tag
operator|=
name|scb_data
operator|->
name|numscbs
operator|^
literal|0x100
expr_stmt|;
name|next_scb
operator|->
name|col_scb
operator|=
name|ahd_find_scb_by_tag
argument_list|(
name|ahd
argument_list|,
name|col_tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|next_scb
operator|->
name|col_scb
operator|!=
name|NULL
condition|)
name|next_scb
operator|->
name|col_scb
operator|->
name|col_scb
operator|=
name|next_scb
expr_stmt|;
name|aic_timer_init
argument_list|(
operator|&
name|next_scb
operator|->
name|io_timer
argument_list|)
expr_stmt|;
name|ahd_free_scb
argument_list|(
name|ahd
argument_list|,
name|next_scb
argument_list|)
expr_stmt|;
name|hscb
operator|++
expr_stmt|;
name|hscb_busaddr
operator|+=
sizeof|sizeof
argument_list|(
operator|*
name|hscb
argument_list|)
expr_stmt|;
name|segs
operator|+=
name|ahd_sglist_size
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
name|sg_busaddr
operator|+=
name|ahd_sglist_size
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
name|sense_data
operator|+=
name|AHD_SENSE_BUFSIZE
expr_stmt|;
name|sense_busaddr
operator|+=
name|AHD_SENSE_BUFSIZE
expr_stmt|;
name|scb_data
operator|->
name|numscbs
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|ahd_controller_info
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|speed
decl_stmt|;
specifier|const
name|char
modifier|*
name|type
decl_stmt|;
name|int
name|len
decl_stmt|;
name|len
operator|=
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s: "
argument_list|,
name|ahd_chip_names
index|[
name|ahd
operator|->
name|chip
operator|&
name|AHD_CHIPID_MASK
index|]
argument_list|)
expr_stmt|;
name|buf
operator|+=
name|len
expr_stmt|;
name|speed
operator|=
literal|"Ultra320 "
expr_stmt|;
if|if
condition|(
operator|(
name|ahd
operator|->
name|features
operator|&
name|AHD_WIDE
operator|)
operator|!=
literal|0
condition|)
block|{
name|type
operator|=
literal|"Wide "
expr_stmt|;
block|}
else|else
block|{
name|type
operator|=
literal|"Single "
expr_stmt|;
block|}
name|len
operator|=
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s%sChannel %c, SCSI Id=%d, "
argument_list|,
name|speed
argument_list|,
name|type
argument_list|,
name|ahd
operator|->
name|channel
argument_list|,
name|ahd
operator|->
name|our_id
argument_list|)
expr_stmt|;
name|buf
operator|+=
name|len
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s, %d SCBs"
argument_list|,
name|ahd
operator|->
name|bus_description
argument_list|,
name|ahd
operator|->
name|scb_data
operator|.
name|maxhscbs
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|channel_strings
index|[]
init|=
block|{
literal|"Primary Low"
block|,
literal|"Primary High"
block|,
literal|"Secondary Low"
block|,
literal|"Secondary High"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|termstat_strings
index|[]
init|=
block|{
literal|"Terminated Correctly"
block|,
literal|"Over Terminated"
block|,
literal|"Under Terminated"
block|,
literal|"Not Configured"
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Start the board, ready for normal operation  */
end_comment

begin_function
name|int
name|ahd_init
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|)
block|{
name|uint8_t
modifier|*
name|next_vaddr
decl_stmt|;
name|bus_addr_t
name|next_baddr
decl_stmt|;
name|size_t
name|driver_data_size
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|error
decl_stmt|;
name|u_int
name|warn_user
decl_stmt|;
name|uint8_t
name|current_sensing
decl_stmt|;
name|uint8_t
name|fstat
decl_stmt|;
name|AHD_ASSERT_MODES
argument_list|(
name|ahd
argument_list|,
name|AHD_MODE_SCSI_MSK
argument_list|,
name|AHD_MODE_SCSI_MSK
argument_list|)
expr_stmt|;
name|ahd
operator|->
name|stack_size
operator|=
name|ahd_probe_stack_size
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
name|ahd
operator|->
name|saved_stack
operator|=
name|malloc
argument_list|(
name|ahd
operator|->
name|stack_size
operator|*
sizeof|sizeof
argument_list|(
name|uint16_t
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|ahd
operator|->
name|saved_stack
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
comment|/* 	 * Verify that the compiler hasn't over-agressively 	 * padded important structures. 	 */
if|if
condition|(
sizeof|sizeof
argument_list|(
expr|struct
name|hardware_scb
argument_list|)
operator|!=
literal|64
condition|)
name|panic
argument_list|(
literal|"Hardware SCB size is incorrect"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|AHD_DEBUG
if|if
condition|(
operator|(
name|ahd_debug
operator|&
name|AHD_DEBUG_SEQUENCER
operator|)
operator|!=
literal|0
condition|)
name|ahd
operator|->
name|flags
operator||=
name|AHD_SEQUENCER_DEBUG
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Default to allowing initiator operations. 	 */
name|ahd
operator|->
name|flags
operator||=
name|AHD_INITIATORROLE
expr_stmt|;
comment|/* 	 * Only allow target mode features if this unit has them enabled. 	 */
if|if
condition|(
operator|(
name|AHD_TMODE_ENABLE
operator|&
operator|(
literal|0x1
operator|<<
name|ahd
operator|->
name|unit
operator|)
operator|)
operator|==
literal|0
condition|)
name|ahd
operator|->
name|features
operator|&=
operator|~
name|AHD_TARGETMODE
expr_stmt|;
ifndef|#
directive|ifndef
name|__linux__
comment|/* DMA tag for mapping buffers into device visible space. */
if|if
condition|(
name|aic_dma_tag_create
argument_list|(
name|ahd
argument_list|,
name|ahd
operator|->
name|parent_dmat
argument_list|,
comment|/*alignment*/
literal|1
argument_list|,
comment|/*boundary*/
name|BUS_SPACE_MAXADDR_32BIT
operator|+
literal|1
argument_list|,
comment|/*lowaddr*/
name|ahd
operator|->
name|flags
operator|&
name|AHD_39BIT_ADDRESSING
condition|?
operator|(
name|bus_addr_t
operator|)
literal|0x7FFFFFFFFFULL
else|:
name|BUS_SPACE_MAXADDR_32BIT
argument_list|,
comment|/*highaddr*/
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/*filter*/
name|NULL
argument_list|,
comment|/*filterarg*/
name|NULL
argument_list|,
comment|/*maxsize*/
operator|(
name|AHD_NSEG
operator|-
literal|1
operator|)
operator|*
name|PAGE_SIZE
argument_list|,
comment|/*nsegments*/
name|AHD_NSEG
argument_list|,
comment|/*maxsegsz*/
name|AHD_MAXTRANSFER_SIZE
argument_list|,
comment|/*flags*/
name|BUS_DMA_ALLOCNOW
argument_list|,
operator|&
name|ahd
operator|->
name|buffer_dmat
argument_list|)
operator|!=
literal|0
condition|)
block|{
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
endif|#
directive|endif
name|ahd
operator|->
name|init_level
operator|++
expr_stmt|;
comment|/* 	 * DMA tag for our command fifos and other data in system memory 	 * the card's sequencer must be able to access.  For initiator 	 * roles, we need to allocate space for the qoutfifo.  When providing 	 * for the target mode role, we must additionally provide space for 	 * the incoming target command fifo. 	 */
name|driver_data_size
operator|=
name|AHD_SCB_MAX
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|ahd
operator|->
name|qoutfifo
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|hardware_scb
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ahd
operator|->
name|features
operator|&
name|AHD_TARGETMODE
operator|)
operator|!=
literal|0
condition|)
name|driver_data_size
operator|+=
name|AHD_TMODE_CMDS
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|target_cmd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ahd
operator|->
name|bugs
operator|&
name|AHD_PKT_BITBUCKET_BUG
operator|)
operator|!=
literal|0
condition|)
name|driver_data_size
operator|+=
name|PKT_OVERRUN_BUFSIZE
expr_stmt|;
if|if
condition|(
name|aic_dma_tag_create
argument_list|(
name|ahd
argument_list|,
name|ahd
operator|->
name|parent_dmat
argument_list|,
comment|/*alignment*/
literal|1
argument_list|,
comment|/*boundary*/
name|BUS_SPACE_MAXADDR_32BIT
operator|+
literal|1
argument_list|,
comment|/*lowaddr*/
name|BUS_SPACE_MAXADDR_32BIT
argument_list|,
comment|/*highaddr*/
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/*filter*/
name|NULL
argument_list|,
comment|/*filterarg*/
name|NULL
argument_list|,
name|driver_data_size
argument_list|,
comment|/*nsegments*/
literal|1
argument_list|,
comment|/*maxsegsz*/
name|BUS_SPACE_MAXSIZE_32BIT
argument_list|,
comment|/*flags*/
literal|0
argument_list|,
operator|&
name|ahd
operator|->
name|shared_data_dmat
argument_list|)
operator|!=
literal|0
condition|)
block|{
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|ahd
operator|->
name|init_level
operator|++
expr_stmt|;
comment|/* Allocation of driver data */
if|if
condition|(
name|aic_dmamem_alloc
argument_list|(
name|ahd
argument_list|,
name|ahd
operator|->
name|shared_data_dmat
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|ahd
operator|->
name|shared_data_map
operator|.
name|vaddr
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|,
operator|&
name|ahd
operator|->
name|shared_data_map
operator|.
name|dmamap
argument_list|)
operator|!=
literal|0
condition|)
block|{
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|ahd
operator|->
name|init_level
operator|++
expr_stmt|;
comment|/* And permanently map it in */
name|aic_dmamap_load
argument_list|(
name|ahd
argument_list|,
name|ahd
operator|->
name|shared_data_dmat
argument_list|,
name|ahd
operator|->
name|shared_data_map
operator|.
name|dmamap
argument_list|,
name|ahd
operator|->
name|shared_data_map
operator|.
name|vaddr
argument_list|,
name|driver_data_size
argument_list|,
name|ahd_dmamap_cb
argument_list|,
operator|&
name|ahd
operator|->
name|shared_data_map
operator|.
name|busaddr
argument_list|,
comment|/*flags*/
literal|0
argument_list|)
expr_stmt|;
name|ahd
operator|->
name|qoutfifo
operator|=
operator|(
expr|struct
name|ahd_completion
operator|*
operator|)
name|ahd
operator|->
name|shared_data_map
operator|.
name|vaddr
expr_stmt|;
name|next_vaddr
operator|=
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|ahd
operator|->
name|qoutfifo
index|[
name|AHD_QOUT_SIZE
index|]
expr_stmt|;
name|next_baddr
operator|=
name|ahd
operator|->
name|shared_data_map
operator|.
name|busaddr
operator|+
name|AHD_QOUT_SIZE
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|ahd_completion
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ahd
operator|->
name|features
operator|&
name|AHD_TARGETMODE
operator|)
operator|!=
literal|0
condition|)
block|{
name|ahd
operator|->
name|targetcmds
operator|=
operator|(
expr|struct
name|target_cmd
operator|*
operator|)
name|next_vaddr
expr_stmt|;
name|next_vaddr
operator|+=
name|AHD_TMODE_CMDS
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|target_cmd
argument_list|)
expr_stmt|;
name|next_baddr
operator|+=
name|AHD_TMODE_CMDS
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|target_cmd
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|ahd
operator|->
name|bugs
operator|&
name|AHD_PKT_BITBUCKET_BUG
operator|)
operator|!=
literal|0
condition|)
block|{
name|ahd
operator|->
name|overrun_buf
operator|=
name|next_vaddr
expr_stmt|;
name|next_vaddr
operator|+=
name|PKT_OVERRUN_BUFSIZE
expr_stmt|;
name|next_baddr
operator|+=
name|PKT_OVERRUN_BUFSIZE
expr_stmt|;
block|}
comment|/* 	 * We need one SCB to serve as the "next SCB".  Since the 	 * tag identifier in this SCB will never be used, there is 	 * no point in using a valid HSCB tag from an SCB pulled from 	 * the standard free pool.  So, we allocate this "sentinel" 	 * specially from the DMA safe memory chunk used for the QOUTFIFO. 	 */
name|ahd
operator|->
name|next_queued_hscb
operator|=
operator|(
expr|struct
name|hardware_scb
operator|*
operator|)
name|next_vaddr
expr_stmt|;
name|ahd
operator|->
name|next_queued_hscb_map
operator|=
operator|&
name|ahd
operator|->
name|shared_data_map
expr_stmt|;
name|ahd
operator|->
name|next_queued_hscb
operator|->
name|hscb_busaddr
operator|=
name|aic_htole32
argument_list|(
name|next_baddr
argument_list|)
expr_stmt|;
name|ahd
operator|->
name|init_level
operator|++
expr_stmt|;
comment|/* Allocate SCB data now that buffer_dmat is initialized */
if|if
condition|(
name|ahd_init_scbdata
argument_list|(
name|ahd
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
if|if
condition|(
operator|(
name|ahd
operator|->
name|flags
operator|&
name|AHD_INITIATORROLE
operator|)
operator|==
literal|0
condition|)
name|ahd
operator|->
name|flags
operator|&=
operator|~
name|AHD_RESET_BUS_A
expr_stmt|;
comment|/* 	 * Before committing these settings to the chip, give 	 * the OSM one last chance to modify our configuration. 	 */
name|ahd_platform_init
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
comment|/* Bring up the chip. */
name|ahd_chip_init
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
name|AHD_ASSERT_MODES
argument_list|(
name|ahd
argument_list|,
name|AHD_MODE_SCSI_MSK
argument_list|,
name|AHD_MODE_SCSI_MSK
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ahd
operator|->
name|flags
operator|&
name|AHD_CURRENT_SENSING
operator|)
operator|==
literal|0
condition|)
goto|goto
name|init_done
goto|;
comment|/* 	 * Verify termination based on current draw and 	 * warn user if the bus is over/under terminated. 	 */
name|error
operator|=
name|ahd_write_flexport
argument_list|(
name|ahd
argument_list|,
name|FLXADDR_ROMSTAT_CURSENSECTL
argument_list|,
name|CURSENSE_ENB
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%s: current sensing timeout 1\n"
argument_list|,
name|ahd_name
argument_list|(
name|ahd
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|init_done
goto|;
block|}
for|for
control|(
name|i
operator|=
literal|20
operator|,
name|fstat
operator|=
name|FLX_FSTAT_BUSY
init|;
operator|(
name|fstat
operator|&
name|FLX_FSTAT_BUSY
operator|)
operator|!=
literal|0
operator|&&
name|i
condition|;
name|i
operator|--
control|)
block|{
name|error
operator|=
name|ahd_read_flexport
argument_list|(
name|ahd
argument_list|,
name|FLXADDR_FLEXSTAT
argument_list|,
operator|&
name|fstat
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%s: current sensing timeout 2\n"
argument_list|,
name|ahd_name
argument_list|(
name|ahd
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|init_done
goto|;
block|}
block|}
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%s: Timedout during current-sensing test\n"
argument_list|,
name|ahd_name
argument_list|(
name|ahd
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|init_done
goto|;
block|}
comment|/* Latch Current Sensing status. */
name|error
operator|=
name|ahd_read_flexport
argument_list|(
name|ahd
argument_list|,
name|FLXADDR_CURRENT_STAT
argument_list|,
operator|&
name|current_sensing
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%s: current sensing timeout 3\n"
argument_list|,
name|ahd_name
argument_list|(
name|ahd
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|init_done
goto|;
block|}
comment|/* Diable current sensing. */
name|ahd_write_flexport
argument_list|(
name|ahd
argument_list|,
name|FLXADDR_ROMSTAT_CURSENSECTL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|AHD_DEBUG
if|if
condition|(
operator|(
name|ahd_debug
operator|&
name|AHD_SHOW_TERMCTL
operator|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%s: current_sensing == 0x%x\n"
argument_list|,
name|ahd_name
argument_list|(
name|ahd
argument_list|)
argument_list|,
name|current_sensing
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|warn_user
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
operator|,
name|current_sensing
operator|>>=
name|FLX_CSTAT_SHIFT
control|)
block|{
name|u_int
name|term_stat
decl_stmt|;
name|term_stat
operator|=
operator|(
name|current_sensing
operator|&
name|FLX_CSTAT_MASK
operator|)
expr_stmt|;
switch|switch
condition|(
name|term_stat
condition|)
block|{
case|case
name|FLX_CSTAT_OVER
case|:
case|case
name|FLX_CSTAT_UNDER
case|:
name|warn_user
operator|++
expr_stmt|;
case|case
name|FLX_CSTAT_INVALID
case|:
case|case
name|FLX_CSTAT_OKAY
case|:
if|if
condition|(
name|warn_user
operator|==
literal|0
operator|&&
name|bootverbose
operator|==
literal|0
condition|)
break|break;
name|printf
argument_list|(
literal|"%s: %s Channel %s\n"
argument_list|,
name|ahd_name
argument_list|(
name|ahd
argument_list|)
argument_list|,
name|channel_strings
index|[
name|i
index|]
argument_list|,
name|termstat_strings
index|[
name|term_stat
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|warn_user
condition|)
block|{
name|printf
argument_list|(
literal|"%s: WARNING. Termination is not configured correctly.\n"
literal|"%s: WARNING. SCSI bus operations may FAIL.\n"
argument_list|,
name|ahd_name
argument_list|(
name|ahd
argument_list|)
argument_list|,
name|ahd_name
argument_list|(
name|ahd
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|init_done
label|:
name|ahd_restart
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
name|aic_timer_reset
argument_list|(
operator|&
name|ahd
operator|->
name|stat_timer
argument_list|,
name|AHD_STAT_UPDATE_MS
argument_list|,
name|ahd_stat_timer
argument_list|,
name|ahd
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * (Re)initialize chip state after a chip reset.  */
end_comment

begin_function
specifier|static
name|void
name|ahd_chip_init
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|)
block|{
name|uint32_t
name|busaddr
decl_stmt|;
name|u_int
name|sxfrctl1
decl_stmt|;
name|u_int
name|scsiseq_template
decl_stmt|;
name|u_int
name|wait
decl_stmt|;
name|u_int
name|i
decl_stmt|;
name|u_int
name|target
decl_stmt|;
name|ahd_set_modes
argument_list|(
name|ahd
argument_list|,
name|AHD_MODE_SCSI
argument_list|,
name|AHD_MODE_SCSI
argument_list|)
expr_stmt|;
comment|/* 	 * Take the LED out of diagnostic mode 	 */
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|SBLKCTL
argument_list|,
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|SBLKCTL
argument_list|)
operator|&
operator|~
operator|(
name|DIAGLEDEN
operator||
name|DIAGLEDON
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Return HS_MAILBOX to its default value. 	 */
name|ahd
operator|->
name|hs_mailbox
operator|=
literal|0
expr_stmt|;
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|HS_MAILBOX
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Set the SCSI Id, SXFRCTL0, SXFRCTL1, and SIMODE1. */
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|IOWNID
argument_list|,
name|ahd
operator|->
name|our_id
argument_list|)
expr_stmt|;
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|TOWNID
argument_list|,
name|ahd
operator|->
name|our_id
argument_list|)
expr_stmt|;
name|sxfrctl1
operator|=
operator|(
name|ahd
operator|->
name|flags
operator|&
name|AHD_TERM_ENB_A
operator|)
operator|!=
literal|0
condition|?
name|STPWEN
else|:
literal|0
expr_stmt|;
name|sxfrctl1
operator||=
operator|(
name|ahd
operator|->
name|flags
operator|&
name|AHD_SPCHK_ENB_A
operator|)
operator|!=
literal|0
condition|?
name|ENSPCHK
else|:
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|ahd
operator|->
name|bugs
operator|&
name|AHD_LONG_SETIMO_BUG
operator|)
operator|&&
operator|(
name|ahd
operator|->
name|seltime
operator|!=
name|STIMESEL_MIN
operator|)
condition|)
block|{
comment|/* 		 * The selection timer duration is twice as long 		 * as it should be.  Halve it by adding "1" to 		 * the user specified setting. 		 */
name|sxfrctl1
operator||=
name|ahd
operator|->
name|seltime
operator|+
name|STIMESEL_BUG_ADJ
expr_stmt|;
block|}
else|else
block|{
name|sxfrctl1
operator||=
name|ahd
operator|->
name|seltime
expr_stmt|;
block|}
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|SXFRCTL0
argument_list|,
name|DFON
argument_list|)
expr_stmt|;
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|SXFRCTL1
argument_list|,
name|sxfrctl1
operator||
name|ahd
operator|->
name|seltime
operator||
name|ENSTIMER
operator||
name|ACTNEGEN
argument_list|)
expr_stmt|;
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|SIMODE1
argument_list|,
name|ENSELTIMO
operator||
name|ENSCSIRST
operator||
name|ENSCSIPERR
argument_list|)
expr_stmt|;
comment|/* 	 * Now that termination is set, wait for up 	 * to 500ms for our transceivers to settle.  If 	 * the adapter does not have a cable attached, 	 * the transceivers may never settle, so don't 	 * complain if we fail here. 	 */
for|for
control|(
name|wait
operator|=
literal|10000
init|;
operator|(
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|SBLKCTL
argument_list|)
operator|&
operator|(
name|ENAB40
operator||
name|ENAB20
operator|)
operator|)
operator|==
literal|0
operator|&&
name|wait
condition|;
name|wait
operator|--
control|)
name|aic_delay
argument_list|(
literal|100
argument_list|)
expr_stmt|;
comment|/* Clear any false bus resets due to the transceivers settling */
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|CLRSINT1
argument_list|,
name|CLRSCSIRSTI
argument_list|)
expr_stmt|;
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|CLRINT
argument_list|,
name|CLRSCSIINT
argument_list|)
expr_stmt|;
comment|/* Initialize mode specific S/G state. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
name|i
operator|++
control|)
block|{
name|ahd_set_modes
argument_list|(
name|ahd
argument_list|,
name|AHD_MODE_DFF0
operator|+
name|i
argument_list|,
name|AHD_MODE_DFF0
operator|+
name|i
argument_list|)
expr_stmt|;
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|LONGJMP_ADDR
operator|+
literal|1
argument_list|,
name|INVALID_ADDR
argument_list|)
expr_stmt|;
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|SG_STATE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|CLRSEQINTSRC
argument_list|,
literal|0xFF
argument_list|)
expr_stmt|;
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|SEQIMODE
argument_list|,
name|ENSAVEPTRS
operator||
name|ENCFG4DATA
operator||
name|ENCFG4ISTAT
operator||
name|ENCFG4TSTAT
operator||
name|ENCFG4ICMD
operator||
name|ENCFG4TCMD
argument_list|)
expr_stmt|;
block|}
name|ahd_set_modes
argument_list|(
name|ahd
argument_list|,
name|AHD_MODE_CFG
argument_list|,
name|AHD_MODE_CFG
argument_list|)
expr_stmt|;
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|DSCOMMAND0
argument_list|,
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|DSCOMMAND0
argument_list|)
operator||
name|MPARCKEN
operator||
name|CACHETHEN
argument_list|)
expr_stmt|;
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|DFF_THRSH
argument_list|,
name|RD_DFTHRSH_75
operator||
name|WR_DFTHRSH_75
argument_list|)
expr_stmt|;
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|SIMODE0
argument_list|,
name|ENIOERR
operator||
name|ENOVERRUN
argument_list|)
expr_stmt|;
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|SIMODE3
argument_list|,
name|ENNTRAMPERR
operator||
name|ENOSRAMPERR
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ahd
operator|->
name|bugs
operator|&
name|AHD_BUSFREEREV_BUG
operator|)
operator|!=
literal|0
condition|)
block|{
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|OPTIONMODE
argument_list|,
name|AUTOACKEN
operator||
name|AUTO_MSGOUT_DE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|OPTIONMODE
argument_list|,
name|AUTOACKEN
operator||
name|BUSFREEREV
operator||
name|AUTO_MSGOUT_DE
argument_list|)
expr_stmt|;
block|}
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|SCSCHKN
argument_list|,
name|CURRFIFODEF
operator||
name|WIDERESEN
operator||
name|SHVALIDSTDIS
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ahd
operator|->
name|chip
operator|&
name|AHD_BUS_MASK
operator|)
operator|==
name|AHD_PCIX
condition|)
comment|/* 		 * Do not issue a target abort when a split completion 		 * error occurs.  Let our PCIX interrupt handler deal 		 * with it instead. H2A4 Razor #625 		 */
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|PCIXCTL
argument_list|,
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|PCIXCTL
argument_list|)
operator||
name|SPLTSTADIS
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ahd
operator|->
name|bugs
operator|&
name|AHD_LQOOVERRUN_BUG
operator|)
operator|!=
literal|0
condition|)
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|LQOSCSCTL
argument_list|,
name|LQONOCHKOVER
argument_list|)
expr_stmt|;
comment|/* 	 * Tweak IOCELL settings. 	 */
if|if
condition|(
operator|(
name|ahd
operator|->
name|flags
operator|&
name|AHD_HP_BOARD
operator|)
operator|!=
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUMDSPS
condition|;
name|i
operator|++
control|)
block|{
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|DSPSELECT
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|WRTBIASCTL
argument_list|,
name|WRTBIASCTL_HP_DEFAULT
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|AHD_DEBUG
if|if
condition|(
operator|(
name|ahd_debug
operator|&
name|AHD_SHOW_MISC
operator|)
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|"%s: WRTBIASCTL now 0x%x\n"
argument_list|,
name|ahd_name
argument_list|(
name|ahd
argument_list|)
argument_list|,
name|WRTBIASCTL_HP_DEFAULT
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|ahd_setup_iocell_workaround
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
comment|/* 	 * Enable LQI Manager interrupts. 	 */
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|LQIMODE1
argument_list|,
name|ENLQIPHASE_LQ
operator||
name|ENLQIPHASE_NLQ
operator||
name|ENLIQABORT
operator||
name|ENLQICRCI_LQ
operator||
name|ENLQICRCI_NLQ
operator||
name|ENLQIBADLQI
operator||
name|ENLQIOVERI_LQ
operator||
name|ENLQIOVERI_NLQ
argument_list|)
expr_stmt|;
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|LQOMODE0
argument_list|,
name|ENLQOATNLQ
operator||
name|ENLQOATNPKT
operator||
name|ENLQOTCRC
argument_list|)
expr_stmt|;
comment|/* 	 * We choose to have the sequencer catch LQOPHCHGINPKT errors 	 * manually for the command phase at the start of a packetized 	 * selection case.  ENLQOBUSFREE should be made redundant by 	 * the BUSFREE interrupt, but it seems that some LQOBUSFREE 	 * events fail to assert the BUSFREE interrupt so we must 	 * also enable LQOBUSFREE interrupts. 	 */
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|LQOMODE1
argument_list|,
name|ENLQOBUSFREE
argument_list|)
expr_stmt|;
comment|/* 	 * Setup sequencer interrupt handlers. 	 */
name|ahd_outw
argument_list|(
name|ahd
argument_list|,
name|INTVEC1_ADDR
argument_list|,
name|ahd_resolve_seqaddr
argument_list|(
name|ahd
argument_list|,
name|LABEL_seq_isr
argument_list|)
argument_list|)
expr_stmt|;
name|ahd_outw
argument_list|(
name|ahd
argument_list|,
name|INTVEC2_ADDR
argument_list|,
name|ahd_resolve_seqaddr
argument_list|(
name|ahd
argument_list|,
name|LABEL_timer_isr
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Setup SCB Offset registers. 	 */
if|if
condition|(
operator|(
name|ahd
operator|->
name|bugs
operator|&
name|AHD_PKT_LUN_BUG
operator|)
operator|!=
literal|0
condition|)
block|{
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|LUNPTR
argument_list|,
name|offsetof
argument_list|(
expr|struct
name|hardware_scb
argument_list|,
name|pkt_long_lun
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|LUNPTR
argument_list|,
name|offsetof
argument_list|(
expr|struct
name|hardware_scb
argument_list|,
name|lun
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|CMDLENPTR
argument_list|,
name|offsetof
argument_list|(
expr|struct
name|hardware_scb
argument_list|,
name|cdb_len
argument_list|)
argument_list|)
expr_stmt|;
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|ATTRPTR
argument_list|,
name|offsetof
argument_list|(
expr|struct
name|hardware_scb
argument_list|,
name|task_attribute
argument_list|)
argument_list|)
expr_stmt|;
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|FLAGPTR
argument_list|,
name|offsetof
argument_list|(
expr|struct
name|hardware_scb
argument_list|,
name|task_management
argument_list|)
argument_list|)
expr_stmt|;
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|CMDPTR
argument_list|,
name|offsetof
argument_list|(
expr|struct
name|hardware_scb
argument_list|,
name|shared_data
operator|.
name|idata
operator|.
name|cdb
argument_list|)
argument_list|)
expr_stmt|;
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|QNEXTPTR
argument_list|,
name|offsetof
argument_list|(
expr|struct
name|hardware_scb
argument_list|,
name|next_hscb_busaddr
argument_list|)
argument_list|)
expr_stmt|;
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|ABRTBITPTR
argument_list|,
name|MK_MESSAGE_BIT_OFFSET
argument_list|)
expr_stmt|;
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|ABRTBYTEPTR
argument_list|,
name|offsetof
argument_list|(
expr|struct
name|hardware_scb
argument_list|,
name|control
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ahd
operator|->
name|bugs
operator|&
name|AHD_PKT_LUN_BUG
operator|)
operator|!=
literal|0
condition|)
block|{
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|LUNLEN
argument_list|,
sizeof|sizeof
argument_list|(
name|ahd
operator|->
name|next_queued_hscb
operator|->
name|pkt_long_lun
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|LUNLEN
argument_list|,
name|LUNLEN_SINGLE_LEVEL_LUN
argument_list|)
expr_stmt|;
block|}
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|CDBLIMIT
argument_list|,
name|SCB_CDB_LEN_PTR
operator|-
literal|1
argument_list|)
expr_stmt|;
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|MAXCMD
argument_list|,
literal|0xFF
argument_list|)
expr_stmt|;
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|SCBAUTOPTR
argument_list|,
name|AUSCBPTR_EN
operator||
name|offsetof
argument_list|(
expr|struct
name|hardware_scb
argument_list|,
name|tag
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We haven't been enabled for target mode yet. */
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|MULTARGID
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|MULTARGID
operator|+
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ahd_set_modes
argument_list|(
name|ahd
argument_list|,
name|AHD_MODE_SCSI
argument_list|,
name|AHD_MODE_SCSI
argument_list|)
expr_stmt|;
comment|/* Initialize the negotiation table. */
if|if
condition|(
operator|(
name|ahd
operator|->
name|features
operator|&
name|AHD_NEW_IOCELL_OPTS
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 		 * Clear the spare bytes in the neg table to avoid 		 * spurious parity errors. 		 */
for|for
control|(
name|target
operator|=
literal|0
init|;
name|target
operator|<
name|AHD_NUM_TARGETS
condition|;
name|target
operator|++
control|)
block|{
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|NEGOADDR
argument_list|,
name|target
argument_list|)
expr_stmt|;
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|ANNEXCOL
argument_list|,
name|AHD_ANNEXCOL_PER_DEV0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|AHD_NUM_PER_DEV_ANNEXCOLS
condition|;
name|i
operator|++
control|)
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|ANNEXDAT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|target
operator|=
literal|0
init|;
name|target
operator|<
name|AHD_NUM_TARGETS
condition|;
name|target
operator|++
control|)
block|{
name|struct
name|ahd_devinfo
name|devinfo
decl_stmt|;
name|struct
name|ahd_initiator_tinfo
modifier|*
name|tinfo
decl_stmt|;
name|struct
name|ahd_tmode_tstate
modifier|*
name|tstate
decl_stmt|;
name|tinfo
operator|=
name|ahd_fetch_transinfo
argument_list|(
name|ahd
argument_list|,
literal|'A'
argument_list|,
name|ahd
operator|->
name|our_id
argument_list|,
name|target
argument_list|,
operator|&
name|tstate
argument_list|)
expr_stmt|;
name|ahd_compile_devinfo
argument_list|(
operator|&
name|devinfo
argument_list|,
name|ahd
operator|->
name|our_id
argument_list|,
name|target
argument_list|,
name|CAM_LUN_WILDCARD
argument_list|,
literal|'A'
argument_list|,
name|ROLE_INITIATOR
argument_list|)
expr_stmt|;
name|ahd_update_neg_table
argument_list|(
name|ahd
argument_list|,
operator|&
name|devinfo
argument_list|,
operator|&
name|tinfo
operator|->
name|curr
argument_list|)
expr_stmt|;
block|}
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|CLRSINT3
argument_list|,
name|NTRAMPERR
operator||
name|OSRAMPERR
argument_list|)
expr_stmt|;
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|CLRINT
argument_list|,
name|CLRSCSIINT
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|NEEDS_MORE_TESTING
comment|/* 	 * Always enable abort on incoming L_Qs if this feature is 	 * supported.  We use this to catch invalid SCB references. 	 */
if|if
condition|(
operator|(
name|ahd
operator|->
name|bugs
operator|&
name|AHD_ABORT_LQI_BUG
operator|)
operator|==
literal|0
condition|)
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|LQCTL1
argument_list|,
name|ABORTPENDING
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|LQCTL1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* All of our queues are empty */
name|ahd
operator|->
name|qoutfifonext
operator|=
literal|0
expr_stmt|;
name|ahd
operator|->
name|qoutfifonext_valid_tag
operator|=
name|QOUTFIFO_ENTRY_VALID
expr_stmt|;
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|QOUTFIFO_ENTRY_VALID_TAG
argument_list|,
name|QOUTFIFO_ENTRY_VALID
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|AHD_QOUT_SIZE
condition|;
name|i
operator|++
control|)
name|ahd
operator|->
name|qoutfifo
index|[
name|i
index|]
operator|.
name|valid_tag
operator|=
literal|0
expr_stmt|;
name|ahd_sync_qoutfifo
argument_list|(
name|ahd
argument_list|,
name|BUS_DMASYNC_PREREAD
argument_list|)
expr_stmt|;
name|ahd
operator|->
name|qinfifonext
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|AHD_QIN_SIZE
condition|;
name|i
operator|++
control|)
name|ahd
operator|->
name|qinfifo
index|[
name|i
index|]
operator|=
name|SCB_LIST_NULL
expr_stmt|;
if|if
condition|(
operator|(
name|ahd
operator|->
name|features
operator|&
name|AHD_TARGETMODE
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* All target command blocks start out invalid. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|AHD_TMODE_CMDS
condition|;
name|i
operator|++
control|)
name|ahd
operator|->
name|targetcmds
index|[
name|i
index|]
operator|.
name|cmd_valid
operator|=
literal|0
expr_stmt|;
name|ahd_sync_tqinfifo
argument_list|(
name|ahd
argument_list|,
name|BUS_DMASYNC_PREREAD
argument_list|)
expr_stmt|;
name|ahd
operator|->
name|tqinfifonext
operator|=
literal|1
expr_stmt|;
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|KERNEL_TQINPOS
argument_list|,
name|ahd
operator|->
name|tqinfifonext
operator|-
literal|1
argument_list|)
expr_stmt|;
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|TQINPOS
argument_list|,
name|ahd
operator|->
name|tqinfifonext
argument_list|)
expr_stmt|;
block|}
comment|/* Initialize Scratch Ram. */
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|SEQ_FLAGS
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|SEQ_FLAGS2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* We don't have any waiting selections */
name|ahd_outw
argument_list|(
name|ahd
argument_list|,
name|WAITING_TID_HEAD
argument_list|,
name|SCB_LIST_NULL
argument_list|)
expr_stmt|;
name|ahd_outw
argument_list|(
name|ahd
argument_list|,
name|WAITING_TID_TAIL
argument_list|,
name|SCB_LIST_NULL
argument_list|)
expr_stmt|;
name|ahd_outw
argument_list|(
name|ahd
argument_list|,
name|MK_MESSAGE_SCB
argument_list|,
name|SCB_LIST_NULL
argument_list|)
expr_stmt|;
name|ahd_outw
argument_list|(
name|ahd
argument_list|,
name|MK_MESSAGE_SCSIID
argument_list|,
literal|0xFF
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|AHD_NUM_TARGETS
condition|;
name|i
operator|++
control|)
name|ahd_outw
argument_list|(
name|ahd
argument_list|,
name|WAITING_SCB_TAILS
operator|+
operator|(
literal|2
operator|*
name|i
operator|)
argument_list|,
name|SCB_LIST_NULL
argument_list|)
expr_stmt|;
comment|/* 	 * Nobody is waiting to be DMAed into the QOUTFIFO. 	 */
name|ahd_outw
argument_list|(
name|ahd
argument_list|,
name|COMPLETE_SCB_HEAD
argument_list|,
name|SCB_LIST_NULL
argument_list|)
expr_stmt|;
name|ahd_outw
argument_list|(
name|ahd
argument_list|,
name|COMPLETE_SCB_DMAINPROG_HEAD
argument_list|,
name|SCB_LIST_NULL
argument_list|)
expr_stmt|;
name|ahd_outw
argument_list|(
name|ahd
argument_list|,
name|COMPLETE_DMA_SCB_HEAD
argument_list|,
name|SCB_LIST_NULL
argument_list|)
expr_stmt|;
name|ahd_outw
argument_list|(
name|ahd
argument_list|,
name|COMPLETE_DMA_SCB_TAIL
argument_list|,
name|SCB_LIST_NULL
argument_list|)
expr_stmt|;
name|ahd_outw
argument_list|(
name|ahd
argument_list|,
name|COMPLETE_ON_QFREEZE_HEAD
argument_list|,
name|SCB_LIST_NULL
argument_list|)
expr_stmt|;
comment|/* 	 * The Freeze Count is 0. 	 */
name|ahd
operator|->
name|qfreeze_cnt
operator|=
literal|0
expr_stmt|;
name|ahd_outw
argument_list|(
name|ahd
argument_list|,
name|QFREEZE_COUNT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ahd_outw
argument_list|(
name|ahd
argument_list|,
name|KERNEL_QFREEZE_COUNT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Tell the sequencer where it can find our arrays in memory. 	 */
name|busaddr
operator|=
name|ahd
operator|->
name|shared_data_map
operator|.
name|busaddr
expr_stmt|;
name|ahd_outl
argument_list|(
name|ahd
argument_list|,
name|SHARED_DATA_ADDR
argument_list|,
name|busaddr
argument_list|)
expr_stmt|;
name|ahd_outl
argument_list|(
name|ahd
argument_list|,
name|QOUTFIFO_NEXT_ADDR
argument_list|,
name|busaddr
argument_list|)
expr_stmt|;
comment|/* 	 * Setup the allowed SCSI Sequences based on operational mode. 	 * If we are a target, we'll enable select in operations once 	 * we've had a lun enabled. 	 */
name|scsiseq_template
operator|=
name|ENAUTOATNP
expr_stmt|;
if|if
condition|(
operator|(
name|ahd
operator|->
name|flags
operator|&
name|AHD_INITIATORROLE
operator|)
operator|!=
literal|0
condition|)
name|scsiseq_template
operator||=
name|ENRSELI
expr_stmt|;
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|SCSISEQ_TEMPLATE
argument_list|,
name|scsiseq_template
argument_list|)
expr_stmt|;
comment|/* There are no busy SCBs yet. */
for|for
control|(
name|target
operator|=
literal|0
init|;
name|target
operator|<
name|AHD_NUM_TARGETS
condition|;
name|target
operator|++
control|)
block|{
name|int
name|lun
decl_stmt|;
for|for
control|(
name|lun
operator|=
literal|0
init|;
name|lun
operator|<
name|AHD_NUM_LUNS_NONPKT
condition|;
name|lun
operator|++
control|)
name|ahd_unbusy_tcl
argument_list|(
name|ahd
argument_list|,
name|BUILD_TCL_RAW
argument_list|(
name|target
argument_list|,
literal|'A'
argument_list|,
name|lun
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Initialize the group code to command length table. 	 * Vendor Unique codes are set to 0 so we only capture 	 * the first byte of the cdb.  These can be overridden 	 * when target mode is enabled. 	 */
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|CMDSIZE_TABLE
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|CMDSIZE_TABLE
operator|+
literal|1
argument_list|,
literal|9
argument_list|)
expr_stmt|;
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|CMDSIZE_TABLE
operator|+
literal|2
argument_list|,
literal|9
argument_list|)
expr_stmt|;
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|CMDSIZE_TABLE
operator|+
literal|3
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|CMDSIZE_TABLE
operator|+
literal|4
argument_list|,
literal|15
argument_list|)
expr_stmt|;
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|CMDSIZE_TABLE
operator|+
literal|5
argument_list|,
literal|11
argument_list|)
expr_stmt|;
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|CMDSIZE_TABLE
operator|+
literal|6
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|CMDSIZE_TABLE
operator|+
literal|7
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Tell the sequencer of our initial queue positions */
name|ahd_set_modes
argument_list|(
name|ahd
argument_list|,
name|AHD_MODE_CCHAN
argument_list|,
name|AHD_MODE_CCHAN
argument_list|)
expr_stmt|;
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|QOFF_CTLSTA
argument_list|,
name|SCB_QSIZE_512
argument_list|)
expr_stmt|;
name|ahd
operator|->
name|qinfifonext
operator|=
literal|0
expr_stmt|;
name|ahd_set_hnscb_qoff
argument_list|(
name|ahd
argument_list|,
name|ahd
operator|->
name|qinfifonext
argument_list|)
expr_stmt|;
name|ahd_set_hescb_qoff
argument_list|(
name|ahd
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ahd_set_snscb_qoff
argument_list|(
name|ahd
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ahd_set_sescb_qoff
argument_list|(
name|ahd
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ahd_set_sdscb_qoff
argument_list|(
name|ahd
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Tell the sequencer which SCB will be the next one it receives. 	 */
name|busaddr
operator|=
name|aic_le32toh
argument_list|(
name|ahd
operator|->
name|next_queued_hscb
operator|->
name|hscb_busaddr
argument_list|)
expr_stmt|;
name|ahd_outl
argument_list|(
name|ahd
argument_list|,
name|NEXT_QUEUED_SCB_ADDR
argument_list|,
name|busaddr
argument_list|)
expr_stmt|;
comment|/* 	 * Default to coalescing disabled. 	 */
name|ahd_outw
argument_list|(
name|ahd
argument_list|,
name|INT_COALESCING_CMDCOUNT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ahd_outw
argument_list|(
name|ahd
argument_list|,
name|CMDS_PENDING
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ahd_update_coalescing_values
argument_list|(
name|ahd
argument_list|,
name|ahd
operator|->
name|int_coalescing_timer
argument_list|,
name|ahd
operator|->
name|int_coalescing_maxcmds
argument_list|,
name|ahd
operator|->
name|int_coalescing_mincmds
argument_list|)
expr_stmt|;
name|ahd_enable_coalescing
argument_list|(
name|ahd
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|ahd_loadseq
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
name|ahd_set_modes
argument_list|(
name|ahd
argument_list|,
name|AHD_MODE_SCSI
argument_list|,
name|AHD_MODE_SCSI
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Setup default device and controller settings.  * This should only be called if our probe has  * determined that no configuration data is available.  */
end_comment

begin_function
name|int
name|ahd_default_config
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|)
block|{
name|int
name|targ
decl_stmt|;
name|ahd
operator|->
name|our_id
operator|=
literal|7
expr_stmt|;
comment|/* 	 * Allocate a tstate to house information for our 	 * initiator presence on the bus as well as the user 	 * data for any target mode initiator. 	 */
if|if
condition|(
name|ahd_alloc_tstate
argument_list|(
name|ahd
argument_list|,
name|ahd
operator|->
name|our_id
argument_list|,
literal|'A'
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"%s: unable to allocate ahd_tmode_tstate.  "
literal|"Failing attach\n"
argument_list|,
name|ahd_name
argument_list|(
name|ahd
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
for|for
control|(
name|targ
operator|=
literal|0
init|;
name|targ
operator|<
name|AHD_NUM_TARGETS
condition|;
name|targ
operator|++
control|)
block|{
name|struct
name|ahd_devinfo
name|devinfo
decl_stmt|;
name|struct
name|ahd_initiator_tinfo
modifier|*
name|tinfo
decl_stmt|;
name|struct
name|ahd_tmode_tstate
modifier|*
name|tstate
decl_stmt|;
name|uint16_t
name|target_mask
decl_stmt|;
name|tinfo
operator|=
name|ahd_fetch_transinfo
argument_list|(
name|ahd
argument_list|,
literal|'A'
argument_list|,
name|ahd
operator|->
name|our_id
argument_list|,
name|targ
argument_list|,
operator|&
name|tstate
argument_list|)
expr_stmt|;
comment|/* 		 * We support SPC2 and SPI4. 		 */
name|tinfo
operator|->
name|user
operator|.
name|protocol_version
operator|=
literal|4
expr_stmt|;
name|tinfo
operator|->
name|user
operator|.
name|transport_version
operator|=
literal|4
expr_stmt|;
name|target_mask
operator|=
literal|0x01
operator|<<
name|targ
expr_stmt|;
name|ahd
operator|->
name|user_discenable
operator||=
name|target_mask
expr_stmt|;
name|tstate
operator|->
name|discenable
operator||=
name|target_mask
expr_stmt|;
name|ahd
operator|->
name|user_tagenable
operator||=
name|target_mask
expr_stmt|;
ifdef|#
directive|ifdef
name|AHD_FORCE_160
name|tinfo
operator|->
name|user
operator|.
name|period
operator|=
name|AHD_SYNCRATE_DT
expr_stmt|;
else|#
directive|else
name|tinfo
operator|->
name|user
operator|.
name|period
operator|=
name|AHD_SYNCRATE_160
expr_stmt|;
endif|#
directive|endif
name|tinfo
operator|->
name|user
operator|.
name|offset
operator|=
name|MAX_OFFSET
expr_stmt|;
name|tinfo
operator|->
name|user
operator|.
name|ppr_options
operator|=
name|MSG_EXT_PPR_RD_STRM
operator||
name|MSG_EXT_PPR_WR_FLOW
operator||
name|MSG_EXT_PPR_HOLD_MCS
operator||
name|MSG_EXT_PPR_IU_REQ
operator||
name|MSG_EXT_PPR_QAS_REQ
operator||
name|MSG_EXT_PPR_DT_REQ
expr_stmt|;
if|if
condition|(
operator|(
name|ahd
operator|->
name|features
operator|&
name|AHD_RTI
operator|)
operator|!=
literal|0
condition|)
name|tinfo
operator|->
name|user
operator|.
name|ppr_options
operator||=
name|MSG_EXT_PPR_RTI
expr_stmt|;
name|tinfo
operator|->
name|user
operator|.
name|width
operator|=
name|MSG_EXT_WDTR_BUS_16_BIT
expr_stmt|;
comment|/* 		 * Start out Async/Narrow/Untagged and with 		 * conservative protocol support. 		 */
name|tinfo
operator|->
name|goal
operator|.
name|protocol_version
operator|=
literal|2
expr_stmt|;
name|tinfo
operator|->
name|goal
operator|.
name|transport_version
operator|=
literal|2
expr_stmt|;
name|tinfo
operator|->
name|curr
operator|.
name|protocol_version
operator|=
literal|2
expr_stmt|;
name|tinfo
operator|->
name|curr
operator|.
name|transport_version
operator|=
literal|2
expr_stmt|;
name|ahd_compile_devinfo
argument_list|(
operator|&
name|devinfo
argument_list|,
name|ahd
operator|->
name|our_id
argument_list|,
name|targ
argument_list|,
name|CAM_LUN_WILDCARD
argument_list|,
literal|'A'
argument_list|,
name|ROLE_INITIATOR
argument_list|)
expr_stmt|;
name|tstate
operator|->
name|tagenable
operator|&=
operator|~
name|target_mask
expr_stmt|;
name|ahd_set_width
argument_list|(
name|ahd
argument_list|,
operator|&
name|devinfo
argument_list|,
name|MSG_EXT_WDTR_BUS_8_BIT
argument_list|,
name|AHD_TRANS_CUR
operator||
name|AHD_TRANS_GOAL
argument_list|,
comment|/*paused*/
name|TRUE
argument_list|)
expr_stmt|;
name|ahd_set_syncrate
argument_list|(
name|ahd
argument_list|,
operator|&
name|devinfo
argument_list|,
comment|/*period*/
literal|0
argument_list|,
comment|/*offset*/
literal|0
argument_list|,
comment|/*ppr_options*/
literal|0
argument_list|,
name|AHD_TRANS_CUR
operator||
name|AHD_TRANS_GOAL
argument_list|,
comment|/*paused*/
name|TRUE
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Parse device configuration information.  */
end_comment

begin_function
name|int
name|ahd_parse_cfgdata
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|,
name|struct
name|seeprom_config
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|targ
decl_stmt|;
name|int
name|max_targ
decl_stmt|;
name|max_targ
operator|=
name|sc
operator|->
name|max_targets
operator|&
name|CFMAXTARG
expr_stmt|;
name|ahd
operator|->
name|our_id
operator|=
name|sc
operator|->
name|brtime_id
operator|&
name|CFSCSIID
expr_stmt|;
comment|/* 	 * Allocate a tstate to house information for our 	 * initiator presence on the bus as well as the user 	 * data for any target mode initiator. 	 */
if|if
condition|(
name|ahd_alloc_tstate
argument_list|(
name|ahd
argument_list|,
name|ahd
operator|->
name|our_id
argument_list|,
literal|'A'
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"%s: unable to allocate ahd_tmode_tstate.  "
literal|"Failing attach\n"
argument_list|,
name|ahd_name
argument_list|(
name|ahd
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
for|for
control|(
name|targ
operator|=
literal|0
init|;
name|targ
operator|<
name|max_targ
condition|;
name|targ
operator|++
control|)
block|{
name|struct
name|ahd_devinfo
name|devinfo
decl_stmt|;
name|struct
name|ahd_initiator_tinfo
modifier|*
name|tinfo
decl_stmt|;
name|struct
name|ahd_transinfo
modifier|*
name|user_tinfo
decl_stmt|;
name|struct
name|ahd_tmode_tstate
modifier|*
name|tstate
decl_stmt|;
name|uint16_t
name|target_mask
decl_stmt|;
name|tinfo
operator|=
name|ahd_fetch_transinfo
argument_list|(
name|ahd
argument_list|,
literal|'A'
argument_list|,
name|ahd
operator|->
name|our_id
argument_list|,
name|targ
argument_list|,
operator|&
name|tstate
argument_list|)
expr_stmt|;
name|user_tinfo
operator|=
operator|&
name|tinfo
operator|->
name|user
expr_stmt|;
comment|/* 		 * We support SPC2 and SPI4. 		 */
name|tinfo
operator|->
name|user
operator|.
name|protocol_version
operator|=
literal|4
expr_stmt|;
name|tinfo
operator|->
name|user
operator|.
name|transport_version
operator|=
literal|4
expr_stmt|;
name|target_mask
operator|=
literal|0x01
operator|<<
name|targ
expr_stmt|;
name|ahd
operator|->
name|user_discenable
operator|&=
operator|~
name|target_mask
expr_stmt|;
name|tstate
operator|->
name|discenable
operator|&=
operator|~
name|target_mask
expr_stmt|;
name|ahd
operator|->
name|user_tagenable
operator|&=
operator|~
name|target_mask
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|device_flags
index|[
name|targ
index|]
operator|&
name|CFDISC
condition|)
block|{
name|tstate
operator|->
name|discenable
operator||=
name|target_mask
expr_stmt|;
name|ahd
operator|->
name|user_discenable
operator||=
name|target_mask
expr_stmt|;
name|ahd
operator|->
name|user_tagenable
operator||=
name|target_mask
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * Cannot be packetized without disconnection. 			 */
name|sc
operator|->
name|device_flags
index|[
name|targ
index|]
operator|&=
operator|~
name|CFPACKETIZED
expr_stmt|;
block|}
name|user_tinfo
operator|->
name|ppr_options
operator|=
literal|0
expr_stmt|;
name|user_tinfo
operator|->
name|period
operator|=
operator|(
name|sc
operator|->
name|device_flags
index|[
name|targ
index|]
operator|&
name|CFXFER
operator|)
expr_stmt|;
if|if
condition|(
name|user_tinfo
operator|->
name|period
operator|<
name|CFXFER_ASYNC
condition|)
block|{
if|if
condition|(
name|user_tinfo
operator|->
name|period
operator|<=
name|AHD_PERIOD_10MHz
condition|)
name|user_tinfo
operator|->
name|ppr_options
operator||=
name|MSG_EXT_PPR_DT_REQ
expr_stmt|;
name|user_tinfo
operator|->
name|offset
operator|=
name|MAX_OFFSET
expr_stmt|;
block|}
else|else
block|{
name|user_tinfo
operator|->
name|offset
operator|=
literal|0
expr_stmt|;
name|user_tinfo
operator|->
name|period
operator|=
name|AHD_ASYNC_XFER_PERIOD
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|AHD_FORCE_160
if|if
condition|(
name|user_tinfo
operator|->
name|period
operator|<=
name|AHD_SYNCRATE_160
condition|)
name|user_tinfo
operator|->
name|period
operator|=
name|AHD_SYNCRATE_DT
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|sc
operator|->
name|device_flags
index|[
name|targ
index|]
operator|&
name|CFPACKETIZED
operator|)
operator|!=
literal|0
condition|)
block|{
name|user_tinfo
operator|->
name|ppr_options
operator||=
name|MSG_EXT_PPR_RD_STRM
operator||
name|MSG_EXT_PPR_WR_FLOW
operator||
name|MSG_EXT_PPR_HOLD_MCS
operator||
name|MSG_EXT_PPR_IU_REQ
expr_stmt|;
if|if
condition|(
operator|(
name|ahd
operator|->
name|features
operator|&
name|AHD_RTI
operator|)
operator|!=
literal|0
condition|)
name|user_tinfo
operator|->
name|ppr_options
operator||=
name|MSG_EXT_PPR_RTI
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|sc
operator|->
name|device_flags
index|[
name|targ
index|]
operator|&
name|CFQAS
operator|)
operator|!=
literal|0
condition|)
name|user_tinfo
operator|->
name|ppr_options
operator||=
name|MSG_EXT_PPR_QAS_REQ
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|device_flags
index|[
name|targ
index|]
operator|&
name|CFWIDEB
operator|)
operator|!=
literal|0
condition|)
name|user_tinfo
operator|->
name|width
operator|=
name|MSG_EXT_WDTR_BUS_16_BIT
expr_stmt|;
else|else
name|user_tinfo
operator|->
name|width
operator|=
name|MSG_EXT_WDTR_BUS_8_BIT
expr_stmt|;
ifdef|#
directive|ifdef
name|AHD_DEBUG
if|if
condition|(
operator|(
name|ahd_debug
operator|&
name|AHD_SHOW_MISC
operator|)
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|"(%d): %x:%x:%x:%x\n"
argument_list|,
name|targ
argument_list|,
name|user_tinfo
operator|->
name|width
argument_list|,
name|user_tinfo
operator|->
name|period
argument_list|,
name|user_tinfo
operator|->
name|offset
argument_list|,
name|user_tinfo
operator|->
name|ppr_options
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 		 * Start out Async/Narrow/Untagged and with 		 * conservative protocol support. 		 */
name|tstate
operator|->
name|tagenable
operator|&=
operator|~
name|target_mask
expr_stmt|;
name|tinfo
operator|->
name|goal
operator|.
name|protocol_version
operator|=
literal|2
expr_stmt|;
name|tinfo
operator|->
name|goal
operator|.
name|transport_version
operator|=
literal|2
expr_stmt|;
name|tinfo
operator|->
name|curr
operator|.
name|protocol_version
operator|=
literal|2
expr_stmt|;
name|tinfo
operator|->
name|curr
operator|.
name|transport_version
operator|=
literal|2
expr_stmt|;
name|ahd_compile_devinfo
argument_list|(
operator|&
name|devinfo
argument_list|,
name|ahd
operator|->
name|our_id
argument_list|,
name|targ
argument_list|,
name|CAM_LUN_WILDCARD
argument_list|,
literal|'A'
argument_list|,
name|ROLE_INITIATOR
argument_list|)
expr_stmt|;
name|ahd_set_width
argument_list|(
name|ahd
argument_list|,
operator|&
name|devinfo
argument_list|,
name|MSG_EXT_WDTR_BUS_8_BIT
argument_list|,
name|AHD_TRANS_CUR
operator||
name|AHD_TRANS_GOAL
argument_list|,
comment|/*paused*/
name|TRUE
argument_list|)
expr_stmt|;
name|ahd_set_syncrate
argument_list|(
name|ahd
argument_list|,
operator|&
name|devinfo
argument_list|,
comment|/*period*/
literal|0
argument_list|,
comment|/*offset*/
literal|0
argument_list|,
comment|/*ppr_options*/
literal|0
argument_list|,
name|AHD_TRANS_CUR
operator||
name|AHD_TRANS_GOAL
argument_list|,
comment|/*paused*/
name|TRUE
argument_list|)
expr_stmt|;
block|}
name|ahd
operator|->
name|flags
operator|&=
operator|~
name|AHD_SPCHK_ENB_A
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|bios_control
operator|&
name|CFSPARITY
condition|)
name|ahd
operator|->
name|flags
operator||=
name|AHD_SPCHK_ENB_A
expr_stmt|;
name|ahd
operator|->
name|flags
operator|&=
operator|~
name|AHD_RESET_BUS_A
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|bios_control
operator|&
name|CFRESETB
condition|)
name|ahd
operator|->
name|flags
operator||=
name|AHD_RESET_BUS_A
expr_stmt|;
name|ahd
operator|->
name|flags
operator|&=
operator|~
name|AHD_EXTENDED_TRANS_A
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|bios_control
operator|&
name|CFEXTEND
condition|)
name|ahd
operator|->
name|flags
operator||=
name|AHD_EXTENDED_TRANS_A
expr_stmt|;
name|ahd
operator|->
name|flags
operator|&=
operator|~
name|AHD_BIOS_ENABLED
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|bios_control
operator|&
name|CFBIOSSTATE
operator|)
operator|==
name|CFBS_ENABLED
condition|)
name|ahd
operator|->
name|flags
operator||=
name|AHD_BIOS_ENABLED
expr_stmt|;
name|ahd
operator|->
name|flags
operator|&=
operator|~
name|AHD_STPWLEVEL_A
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|adapter_control
operator|&
name|CFSTPWLEVEL
operator|)
operator|!=
literal|0
condition|)
name|ahd
operator|->
name|flags
operator||=
name|AHD_STPWLEVEL_A
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Parse device configuration information.  */
end_comment

begin_function
name|int
name|ahd_parse_vpddata
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|,
name|struct
name|vpd_config
modifier|*
name|vpd
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|error
operator|=
name|ahd_verify_vpd_cksum
argument_list|(
name|vpd
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
operator|(
name|vpd
operator|->
name|bios_flags
operator|&
name|VPDBOOTHOST
operator|)
operator|!=
literal|0
condition|)
name|ahd
operator|->
name|flags
operator||=
name|AHD_BOOT_CHANNEL
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|ahd_intr_enable
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|,
name|int
name|enable
parameter_list|)
block|{
name|u_int
name|hcntrl
decl_stmt|;
name|hcntrl
operator|=
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|HCNTRL
argument_list|)
expr_stmt|;
name|hcntrl
operator|&=
operator|~
name|INTEN
expr_stmt|;
name|ahd
operator|->
name|pause
operator|&=
operator|~
name|INTEN
expr_stmt|;
name|ahd
operator|->
name|unpause
operator|&=
operator|~
name|INTEN
expr_stmt|;
if|if
condition|(
name|enable
condition|)
block|{
name|hcntrl
operator||=
name|INTEN
expr_stmt|;
name|ahd
operator|->
name|pause
operator||=
name|INTEN
expr_stmt|;
name|ahd
operator|->
name|unpause
operator||=
name|INTEN
expr_stmt|;
block|}
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|HCNTRL
argument_list|,
name|hcntrl
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ahd_update_coalescing_values
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|,
name|u_int
name|timer
parameter_list|,
name|u_int
name|maxcmds
parameter_list|,
name|u_int
name|mincmds
parameter_list|)
block|{
if|if
condition|(
name|timer
operator|>
name|AHD_TIMER_MAX_US
condition|)
name|timer
operator|=
name|AHD_TIMER_MAX_US
expr_stmt|;
name|ahd
operator|->
name|int_coalescing_timer
operator|=
name|timer
expr_stmt|;
if|if
condition|(
name|maxcmds
operator|>
name|AHD_INT_COALESCING_MAXCMDS_MAX
condition|)
name|maxcmds
operator|=
name|AHD_INT_COALESCING_MAXCMDS_MAX
expr_stmt|;
if|if
condition|(
name|mincmds
operator|>
name|AHD_INT_COALESCING_MINCMDS_MAX
condition|)
name|mincmds
operator|=
name|AHD_INT_COALESCING_MINCMDS_MAX
expr_stmt|;
name|ahd
operator|->
name|int_coalescing_maxcmds
operator|=
name|maxcmds
expr_stmt|;
name|ahd_outw
argument_list|(
name|ahd
argument_list|,
name|INT_COALESCING_TIMER
argument_list|,
name|timer
operator|/
name|AHD_TIMER_US_PER_TICK
argument_list|)
expr_stmt|;
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|INT_COALESCING_MAXCMDS
argument_list|,
operator|-
name|maxcmds
argument_list|)
expr_stmt|;
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|INT_COALESCING_MINCMDS
argument_list|,
operator|-
name|mincmds
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ahd_enable_coalescing
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|,
name|int
name|enable
parameter_list|)
block|{
name|ahd
operator|->
name|hs_mailbox
operator|&=
operator|~
name|ENINT_COALESCE
expr_stmt|;
if|if
condition|(
name|enable
condition|)
name|ahd
operator|->
name|hs_mailbox
operator||=
name|ENINT_COALESCE
expr_stmt|;
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|HS_MAILBOX
argument_list|,
name|ahd
operator|->
name|hs_mailbox
argument_list|)
expr_stmt|;
name|ahd_flush_device_writes
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
name|ahd_run_qoutfifo
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Ensure that the card is paused in a location  * outside of all critical sections and that all  * pending work is completed prior to returning.  * This routine should only be called from outside  * an interrupt context.  */
end_comment

begin_function
name|void
name|ahd_pause_and_flushwork
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|)
block|{
name|u_int
name|intstat
decl_stmt|;
name|u_int
name|maxloops
decl_stmt|;
name|maxloops
operator|=
literal|1000
expr_stmt|;
name|ahd
operator|->
name|flags
operator||=
name|AHD_ALL_INTERRUPTS
expr_stmt|;
name|ahd_pause
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
comment|/* 	 * Freeze the outgoing selections.  We do this only 	 * until we are safely paused without further selections 	 * pending. 	 */
name|ahd
operator|->
name|qfreeze_cnt
operator|--
expr_stmt|;
name|ahd_outw
argument_list|(
name|ahd
argument_list|,
name|KERNEL_QFREEZE_COUNT
argument_list|,
name|ahd
operator|->
name|qfreeze_cnt
argument_list|)
expr_stmt|;
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|SEQ_FLAGS2
argument_list|,
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|SEQ_FLAGS2
argument_list|)
operator||
name|SELECTOUT_QFROZEN
argument_list|)
expr_stmt|;
do|do
block|{
name|ahd_unpause
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
comment|/* 		 * Give the sequencer some time to service 		 * any active selections. 		 */
name|aic_delay
argument_list|(
literal|500
argument_list|)
expr_stmt|;
name|ahd_intr
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
name|ahd_pause
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
name|intstat
operator|=
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|INTSTAT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|intstat
operator|&
name|INT_PEND
operator|)
operator|==
literal|0
condition|)
block|{
name|ahd_clear_critical_section
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
name|intstat
operator|=
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|INTSTAT
argument_list|)
expr_stmt|;
block|}
block|}
do|while
condition|(
operator|--
name|maxloops
operator|&&
operator|(
name|intstat
operator|!=
literal|0xFF
operator|||
operator|(
name|ahd
operator|->
name|features
operator|&
name|AHD_REMOVABLE
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|(
name|intstat
operator|&
name|INT_PEND
operator|)
operator|!=
literal|0
operator|||
operator|(
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|SCSISEQ0
argument_list|)
operator|&
name|ENSELO
operator|)
operator|!=
literal|0
operator|||
operator|(
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|SSTAT0
argument_list|)
operator|&
operator|(
name|SELDO
operator||
name|SELINGO
operator|)
operator|)
operator|!=
literal|0
operator|)
condition|)
do|;
if|if
condition|(
name|maxloops
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"Infinite interrupt loop, INTSTAT = %x"
argument_list|,
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|INTSTAT
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|ahd
operator|->
name|qfreeze_cnt
operator|++
expr_stmt|;
name|ahd_outw
argument_list|(
name|ahd
argument_list|,
name|KERNEL_QFREEZE_COUNT
argument_list|,
name|ahd
operator|->
name|qfreeze_cnt
argument_list|)
expr_stmt|;
name|ahd_flush_qoutfifo
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
name|ahd_platform_flushwork
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
name|ahd
operator|->
name|flags
operator|&=
operator|~
name|AHD_ALL_INTERRUPTS
expr_stmt|;
block|}
end_function

begin_function
name|int
name|ahd_suspend
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|)
block|{
name|ahd_pause_and_flushwork
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
if|if
condition|(
name|LIST_FIRST
argument_list|(
operator|&
name|ahd
operator|->
name|pending_scbs
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|ahd_unpause
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
return|return
operator|(
name|EBUSY
operator|)
return|;
block|}
name|ahd_shutdown
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ahd_resume
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|)
block|{
name|ahd_reset
argument_list|(
name|ahd
argument_list|,
comment|/*reinit*/
name|TRUE
argument_list|)
expr_stmt|;
name|ahd_intr_enable
argument_list|(
name|ahd
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|ahd_restart
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/************************** Busy Target Table *********************************/
end_comment

begin_comment
comment|/*  * Set SCBPTR to the SCB that contains the busy  * table entry for TCL.  Return the offset into  * the SCB that contains the entry for TCL.  * saved_scbid is dereferenced and set to the  * scbid that should be restored once manipualtion  * of the TCL entry is complete.  */
end_comment

begin_function
specifier|static
name|__inline
name|u_int
name|ahd_index_busy_tcl
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|,
name|u_int
modifier|*
name|saved_scbid
parameter_list|,
name|u_int
name|tcl
parameter_list|)
block|{
comment|/* 	 * Index to the SCB that contains the busy entry. 	 */
name|AHD_ASSERT_MODES
argument_list|(
name|ahd
argument_list|,
name|AHD_MODE_SCSI_MSK
argument_list|,
name|AHD_MODE_SCSI_MSK
argument_list|)
expr_stmt|;
operator|*
name|saved_scbid
operator|=
name|ahd_get_scbptr
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
name|ahd_set_scbptr
argument_list|(
name|ahd
argument_list|,
name|TCL_LUN
argument_list|(
name|tcl
argument_list|)
operator||
operator|(
operator|(
name|TCL_TARGET_OFFSET
argument_list|(
name|tcl
argument_list|)
operator|&
literal|0xC
operator|)
operator|<<
literal|4
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * And now calculate the SCB offset to the entry. 	 * Each entry is 2 bytes wide, hence the 	 * multiplication by 2. 	 */
return|return
operator|(
operator|(
operator|(
name|TCL_TARGET_OFFSET
argument_list|(
name|tcl
argument_list|)
operator|&
literal|0x3
operator|)
operator|<<
literal|1
operator|)
operator|+
name|SCB_DISCONNECTED_LISTS
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return the untagged transaction id for a given target/channel lun.  */
end_comment

begin_function
name|u_int
name|ahd_find_busy_tcl
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|,
name|u_int
name|tcl
parameter_list|)
block|{
name|u_int
name|scbid
decl_stmt|;
name|u_int
name|scb_offset
decl_stmt|;
name|u_int
name|saved_scbptr
decl_stmt|;
name|scb_offset
operator|=
name|ahd_index_busy_tcl
argument_list|(
name|ahd
argument_list|,
operator|&
name|saved_scbptr
argument_list|,
name|tcl
argument_list|)
expr_stmt|;
name|scbid
operator|=
name|ahd_inw_scbram
argument_list|(
name|ahd
argument_list|,
name|scb_offset
argument_list|)
expr_stmt|;
name|ahd_set_scbptr
argument_list|(
name|ahd
argument_list|,
name|saved_scbptr
argument_list|)
expr_stmt|;
return|return
operator|(
name|scbid
operator|)
return|;
block|}
end_function

begin_function
name|void
name|ahd_busy_tcl
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|,
name|u_int
name|tcl
parameter_list|,
name|u_int
name|scbid
parameter_list|)
block|{
name|u_int
name|scb_offset
decl_stmt|;
name|u_int
name|saved_scbptr
decl_stmt|;
name|scb_offset
operator|=
name|ahd_index_busy_tcl
argument_list|(
name|ahd
argument_list|,
operator|&
name|saved_scbptr
argument_list|,
name|tcl
argument_list|)
expr_stmt|;
name|ahd_outw
argument_list|(
name|ahd
argument_list|,
name|scb_offset
argument_list|,
name|scbid
argument_list|)
expr_stmt|;
name|ahd_set_scbptr
argument_list|(
name|ahd
argument_list|,
name|saved_scbptr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/************************** SCB and SCB queue management **********************/
end_comment

begin_function
name|int
name|ahd_match_scb
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|,
name|struct
name|scb
modifier|*
name|scb
parameter_list|,
name|int
name|target
parameter_list|,
name|char
name|channel
parameter_list|,
name|int
name|lun
parameter_list|,
name|u_int
name|tag
parameter_list|,
name|role_t
name|role
parameter_list|)
block|{
name|int
name|targ
init|=
name|SCB_GET_TARGET
argument_list|(
name|ahd
argument_list|,
name|scb
argument_list|)
decl_stmt|;
name|char
name|chan
init|=
name|SCB_GET_CHANNEL
argument_list|(
name|ahd
argument_list|,
name|scb
argument_list|)
decl_stmt|;
name|int
name|slun
init|=
name|SCB_GET_LUN
argument_list|(
name|scb
argument_list|)
decl_stmt|;
name|int
name|match
decl_stmt|;
name|match
operator|=
operator|(
operator|(
name|chan
operator|==
name|channel
operator|)
operator|||
operator|(
name|channel
operator|==
name|ALL_CHANNELS
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|match
operator|!=
literal|0
condition|)
name|match
operator|=
operator|(
operator|(
name|targ
operator|==
name|target
operator|)
operator|||
operator|(
name|target
operator|==
name|CAM_TARGET_WILDCARD
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|match
operator|!=
literal|0
condition|)
name|match
operator|=
operator|(
operator|(
name|lun
operator|==
name|slun
operator|)
operator|||
operator|(
name|lun
operator|==
name|CAM_LUN_WILDCARD
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|match
operator|!=
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|AHD_TARGET_MODE
name|int
name|group
decl_stmt|;
name|group
operator|=
name|XPT_FC_GROUP
argument_list|(
name|scb
operator|->
name|io_ctx
operator|->
name|ccb_h
operator|.
name|func_code
argument_list|)
expr_stmt|;
if|if
condition|(
name|role
operator|==
name|ROLE_INITIATOR
condition|)
block|{
name|match
operator|=
operator|(
name|group
operator|!=
name|XPT_FC_GROUP_TMODE
operator|)
operator|&&
operator|(
operator|(
name|tag
operator|==
name|SCB_GET_TAG
argument_list|(
name|scb
argument_list|)
operator|)
operator|||
operator|(
name|tag
operator|==
name|SCB_LIST_NULL
operator|)
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|role
operator|==
name|ROLE_TARGET
condition|)
block|{
name|match
operator|=
operator|(
name|group
operator|==
name|XPT_FC_GROUP_TMODE
operator|)
operator|&&
operator|(
operator|(
name|tag
operator|==
name|scb
operator|->
name|io_ctx
operator|->
name|csio
operator|.
name|tag_id
operator|)
operator|||
operator|(
name|tag
operator|==
name|SCB_LIST_NULL
operator|)
operator|)
expr_stmt|;
block|}
else|#
directive|else
comment|/* !AHD_TARGET_MODE */
name|match
operator|=
operator|(
operator|(
name|tag
operator|==
name|SCB_GET_TAG
argument_list|(
name|scb
argument_list|)
operator|)
operator|||
operator|(
name|tag
operator|==
name|SCB_LIST_NULL
operator|)
operator|)
expr_stmt|;
endif|#
directive|endif
comment|/* AHD_TARGET_MODE */
block|}
return|return
name|match
return|;
block|}
end_function

begin_function
name|void
name|ahd_freeze_devq
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|,
name|struct
name|scb
modifier|*
name|scb
parameter_list|)
block|{
name|int
name|target
decl_stmt|;
name|char
name|channel
decl_stmt|;
name|int
name|lun
decl_stmt|;
name|target
operator|=
name|SCB_GET_TARGET
argument_list|(
name|ahd
argument_list|,
name|scb
argument_list|)
expr_stmt|;
name|lun
operator|=
name|SCB_GET_LUN
argument_list|(
name|scb
argument_list|)
expr_stmt|;
name|channel
operator|=
name|SCB_GET_CHANNEL
argument_list|(
name|ahd
argument_list|,
name|scb
argument_list|)
expr_stmt|;
name|ahd_search_qinfifo
argument_list|(
name|ahd
argument_list|,
name|target
argument_list|,
name|channel
argument_list|,
name|lun
argument_list|,
comment|/*tag*/
name|SCB_LIST_NULL
argument_list|,
name|ROLE_UNKNOWN
argument_list|,
name|CAM_REQUEUE_REQ
argument_list|,
name|SEARCH_COMPLETE
argument_list|)
expr_stmt|;
name|ahd_platform_freeze_devq
argument_list|(
name|ahd
argument_list|,
name|scb
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ahd_qinfifo_requeue_tail
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|,
name|struct
name|scb
modifier|*
name|scb
parameter_list|)
block|{
name|struct
name|scb
modifier|*
name|prev_scb
decl_stmt|;
name|ahd_mode_state
name|saved_modes
decl_stmt|;
name|saved_modes
operator|=
name|ahd_save_modes
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
name|ahd_set_modes
argument_list|(
name|ahd
argument_list|,
name|AHD_MODE_CCHAN
argument_list|,
name|AHD_MODE_CCHAN
argument_list|)
expr_stmt|;
name|prev_scb
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|ahd_qinfifo_count
argument_list|(
name|ahd
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|u_int
name|prev_tag
decl_stmt|;
name|u_int
name|prev_pos
decl_stmt|;
name|prev_pos
operator|=
name|AHD_QIN_WRAP
argument_list|(
name|ahd
operator|->
name|qinfifonext
operator|-
literal|1
argument_list|)
expr_stmt|;
name|prev_tag
operator|=
name|ahd
operator|->
name|qinfifo
index|[
name|prev_pos
index|]
expr_stmt|;
name|prev_scb
operator|=
name|ahd_lookup_scb
argument_list|(
name|ahd
argument_list|,
name|prev_tag
argument_list|)
expr_stmt|;
block|}
name|ahd_qinfifo_requeue
argument_list|(
name|ahd
argument_list|,
name|prev_scb
argument_list|,
name|scb
argument_list|)
expr_stmt|;
name|ahd_set_hnscb_qoff
argument_list|(
name|ahd
argument_list|,
name|ahd
operator|->
name|qinfifonext
argument_list|)
expr_stmt|;
name|ahd_restore_modes
argument_list|(
name|ahd
argument_list|,
name|saved_modes
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ahd_qinfifo_requeue
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|,
name|struct
name|scb
modifier|*
name|prev_scb
parameter_list|,
name|struct
name|scb
modifier|*
name|scb
parameter_list|)
block|{
if|if
condition|(
name|prev_scb
operator|==
name|NULL
condition|)
block|{
name|uint32_t
name|busaddr
decl_stmt|;
name|busaddr
operator|=
name|aic_le32toh
argument_list|(
name|scb
operator|->
name|hscb
operator|->
name|hscb_busaddr
argument_list|)
expr_stmt|;
name|ahd_outl
argument_list|(
name|ahd
argument_list|,
name|NEXT_QUEUED_SCB_ADDR
argument_list|,
name|busaddr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|prev_scb
operator|->
name|hscb
operator|->
name|next_hscb_busaddr
operator|=
name|scb
operator|->
name|hscb
operator|->
name|hscb_busaddr
expr_stmt|;
name|ahd_sync_scb
argument_list|(
name|ahd
argument_list|,
name|prev_scb
argument_list|,
name|BUS_DMASYNC_PREREAD
operator||
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
block|}
name|ahd
operator|->
name|qinfifo
index|[
name|AHD_QIN_WRAP
argument_list|(
name|ahd
operator|->
name|qinfifonext
argument_list|)
index|]
operator|=
name|SCB_GET_TAG
argument_list|(
name|scb
argument_list|)
expr_stmt|;
name|ahd
operator|->
name|qinfifonext
operator|++
expr_stmt|;
name|scb
operator|->
name|hscb
operator|->
name|next_hscb_busaddr
operator|=
name|ahd
operator|->
name|next_queued_hscb
operator|->
name|hscb_busaddr
expr_stmt|;
name|ahd_sync_scb
argument_list|(
name|ahd
argument_list|,
name|scb
argument_list|,
name|BUS_DMASYNC_PREREAD
operator||
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|ahd_qinfifo_count
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|)
block|{
name|u_int
name|qinpos
decl_stmt|;
name|u_int
name|wrap_qinpos
decl_stmt|;
name|u_int
name|wrap_qinfifonext
decl_stmt|;
name|AHD_ASSERT_MODES
argument_list|(
name|ahd
argument_list|,
name|AHD_MODE_CCHAN_MSK
argument_list|,
name|AHD_MODE_CCHAN_MSK
argument_list|)
expr_stmt|;
name|qinpos
operator|=
name|ahd_get_snscb_qoff
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
name|wrap_qinpos
operator|=
name|AHD_QIN_WRAP
argument_list|(
name|qinpos
argument_list|)
expr_stmt|;
name|wrap_qinfifonext
operator|=
name|AHD_QIN_WRAP
argument_list|(
name|ahd
operator|->
name|qinfifonext
argument_list|)
expr_stmt|;
if|if
condition|(
name|wrap_qinfifonext
operator|>=
name|wrap_qinpos
condition|)
return|return
operator|(
name|wrap_qinfifonext
operator|-
name|wrap_qinpos
operator|)
return|;
else|else
return|return
operator|(
name|wrap_qinfifonext
operator|+
name|NUM_ELEMENTS
argument_list|(
name|ahd
operator|->
name|qinfifo
argument_list|)
operator|-
name|wrap_qinpos
operator|)
return|;
block|}
end_function

begin_function
name|void
name|ahd_reset_cmds_pending
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|)
block|{
name|struct
name|scb
modifier|*
name|scb
decl_stmt|;
name|ahd_mode_state
name|saved_modes
decl_stmt|;
name|u_int
name|pending_cmds
decl_stmt|;
name|saved_modes
operator|=
name|ahd_save_modes
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
name|ahd_set_modes
argument_list|(
name|ahd
argument_list|,
name|AHD_MODE_CCHAN
argument_list|,
name|AHD_MODE_CCHAN
argument_list|)
expr_stmt|;
comment|/* 	 * Don't count any commands as outstanding that the 	 * sequencer has already marked for completion. 	 */
name|ahd_flush_qoutfifo
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
name|pending_cmds
operator|=
literal|0
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|scb
argument_list|,
argument|&ahd->pending_scbs
argument_list|,
argument|pending_links
argument_list|)
block|{
name|pending_cmds
operator|++
expr_stmt|;
block|}
name|ahd_outw
argument_list|(
name|ahd
argument_list|,
name|CMDS_PENDING
argument_list|,
name|pending_cmds
operator|-
name|ahd_qinfifo_count
argument_list|(
name|ahd
argument_list|)
argument_list|)
expr_stmt|;
name|ahd_restore_modes
argument_list|(
name|ahd
argument_list|,
name|saved_modes
argument_list|)
expr_stmt|;
name|ahd
operator|->
name|flags
operator|&=
operator|~
name|AHD_UPDATE_PEND_CMDS
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ahd_done_with_status
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|,
name|struct
name|scb
modifier|*
name|scb
parameter_list|,
name|uint32_t
name|status
parameter_list|)
block|{
name|cam_status
name|ostat
decl_stmt|;
name|cam_status
name|cstat
decl_stmt|;
name|ostat
operator|=
name|aic_get_transaction_status
argument_list|(
name|scb
argument_list|)
expr_stmt|;
if|if
condition|(
name|ostat
operator|==
name|CAM_REQ_INPROG
condition|)
name|aic_set_transaction_status
argument_list|(
name|scb
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|cstat
operator|=
name|aic_get_transaction_status
argument_list|(
name|scb
argument_list|)
expr_stmt|;
if|if
condition|(
name|cstat
operator|!=
name|CAM_REQ_CMP
condition|)
name|aic_freeze_scb
argument_list|(
name|scb
argument_list|)
expr_stmt|;
name|ahd_done
argument_list|(
name|ahd
argument_list|,
name|scb
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|ahd_search_qinfifo
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|,
name|int
name|target
parameter_list|,
name|char
name|channel
parameter_list|,
name|int
name|lun
parameter_list|,
name|u_int
name|tag
parameter_list|,
name|role_t
name|role
parameter_list|,
name|uint32_t
name|status
parameter_list|,
name|ahd_search_action
name|action
parameter_list|)
block|{
name|struct
name|scb
modifier|*
name|scb
decl_stmt|;
name|struct
name|scb
modifier|*
name|mk_msg_scb
decl_stmt|;
name|struct
name|scb
modifier|*
name|prev_scb
decl_stmt|;
name|ahd_mode_state
name|saved_modes
decl_stmt|;
name|u_int
name|qinstart
decl_stmt|;
name|u_int
name|qinpos
decl_stmt|;
name|u_int
name|qintail
decl_stmt|;
name|u_int
name|tid_next
decl_stmt|;
name|u_int
name|tid_prev
decl_stmt|;
name|u_int
name|scbid
decl_stmt|;
name|u_int
name|seq_flags2
decl_stmt|;
name|u_int
name|savedscbptr
decl_stmt|;
name|uint32_t
name|busaddr
decl_stmt|;
name|int
name|found
decl_stmt|;
name|int
name|targets
decl_stmt|;
comment|/* Must be in CCHAN mode */
name|saved_modes
operator|=
name|ahd_save_modes
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
name|ahd_set_modes
argument_list|(
name|ahd
argument_list|,
name|AHD_MODE_CCHAN
argument_list|,
name|AHD_MODE_CCHAN
argument_list|)
expr_stmt|;
comment|/* 	 * Halt any pending SCB DMA.  The sequencer will reinitiate 	 * this dma if the qinfifo is not empty once we unpause. 	 */
if|if
condition|(
operator|(
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|CCSCBCTL
argument_list|)
operator|&
operator|(
name|CCARREN
operator||
name|CCSCBEN
operator||
name|CCSCBDIR
operator|)
operator|)
operator|==
operator|(
name|CCARREN
operator||
name|CCSCBEN
operator||
name|CCSCBDIR
operator|)
condition|)
block|{
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|CCSCBCTL
argument_list|,
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|CCSCBCTL
argument_list|)
operator|&
operator|~
operator|(
name|CCARREN
operator||
name|CCSCBEN
operator|)
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|CCSCBCTL
argument_list|)
operator|&
operator|(
name|CCARREN
operator||
name|CCSCBEN
operator|)
operator|)
operator|!=
literal|0
condition|)
empty_stmt|;
block|}
comment|/* Determine sequencer's position in the qinfifo. */
name|qintail
operator|=
name|AHD_QIN_WRAP
argument_list|(
name|ahd
operator|->
name|qinfifonext
argument_list|)
expr_stmt|;
name|qinstart
operator|=
name|ahd_get_snscb_qoff
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
name|qinpos
operator|=
name|AHD_QIN_WRAP
argument_list|(
name|qinstart
argument_list|)
expr_stmt|;
name|found
operator|=
literal|0
expr_stmt|;
name|prev_scb
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|action
operator|==
name|SEARCH_PRINT
condition|)
block|{
name|printf
argument_list|(
literal|"qinstart = %d qinfifonext = %d\nQINFIFO:"
argument_list|,
name|qinstart
argument_list|,
name|ahd
operator|->
name|qinfifonext
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Start with an empty queue.  Entries that are not chosen 	 * for removal will be re-added to the queue as we go. 	 */
name|ahd
operator|->
name|qinfifonext
operator|=
name|qinstart
expr_stmt|;
name|busaddr
operator|=
name|aic_le32toh
argument_list|(
name|ahd
operator|->
name|next_queued_hscb
operator|->
name|hscb_busaddr
argument_list|)
expr_stmt|;
name|ahd_outl
argument_list|(
name|ahd
argument_list|,
name|NEXT_QUEUED_SCB_ADDR
argument_list|,
name|busaddr
argument_list|)
expr_stmt|;
while|while
condition|(
name|qinpos
operator|!=
name|qintail
condition|)
block|{
name|scb
operator|=
name|ahd_lookup_scb
argument_list|(
name|ahd
argument_list|,
name|ahd
operator|->
name|qinfifo
index|[
name|qinpos
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|scb
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"qinpos = %d, SCB index = %d\n"
argument_list|,
name|qinpos
argument_list|,
name|ahd
operator|->
name|qinfifo
index|[
name|qinpos
index|]
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"Loop 1\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ahd_match_scb
argument_list|(
name|ahd
argument_list|,
name|scb
argument_list|,
name|target
argument_list|,
name|channel
argument_list|,
name|lun
argument_list|,
name|tag
argument_list|,
name|role
argument_list|)
condition|)
block|{
comment|/* 			 * We found an scb that needs to be acted on. 			 */
name|found
operator|++
expr_stmt|;
switch|switch
condition|(
name|action
condition|)
block|{
case|case
name|SEARCH_COMPLETE
case|:
if|if
condition|(
operator|(
name|scb
operator|->
name|flags
operator|&
name|SCB_ACTIVE
operator|)
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"Inactive SCB in qinfifo\n"
argument_list|)
expr_stmt|;
name|ahd_done_with_status
argument_list|(
name|ahd
argument_list|,
name|scb
argument_list|,
name|status
argument_list|)
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
name|SEARCH_REMOVE
case|:
break|break;
case|case
name|SEARCH_PRINT
case|:
name|printf
argument_list|(
literal|" 0x%x"
argument_list|,
name|ahd
operator|->
name|qinfifo
index|[
name|qinpos
index|]
argument_list|)
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
name|SEARCH_COUNT
case|:
name|ahd_qinfifo_requeue
argument_list|(
name|ahd
argument_list|,
name|prev_scb
argument_list|,
name|scb
argument_list|)
expr_stmt|;
name|prev_scb
operator|=
name|scb
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
name|ahd_qinfifo_requeue
argument_list|(
name|ahd
argument_list|,
name|prev_scb
argument_list|,
name|scb
argument_list|)
expr_stmt|;
name|prev_scb
operator|=
name|scb
expr_stmt|;
block|}
name|qinpos
operator|=
name|AHD_QIN_WRAP
argument_list|(
name|qinpos
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
name|ahd_set_hnscb_qoff
argument_list|(
name|ahd
argument_list|,
name|ahd
operator|->
name|qinfifonext
argument_list|)
expr_stmt|;
if|if
condition|(
name|action
operator|==
name|SEARCH_PRINT
condition|)
name|printf
argument_list|(
literal|"\nWAITING_TID_QUEUES:\n"
argument_list|)
expr_stmt|;
comment|/* 	 * Search waiting for selection lists.  We traverse the 	 * list of "their ids" waiting for selection and, if 	 * appropriate, traverse the SCBs of each "their id" 	 * looking for matches. 	 */
name|ahd_set_modes
argument_list|(
name|ahd
argument_list|,
name|AHD_MODE_SCSI
argument_list|,
name|AHD_MODE_SCSI
argument_list|)
expr_stmt|;
name|seq_flags2
operator|=
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|SEQ_FLAGS2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|seq_flags2
operator|&
name|PENDING_MK_MESSAGE
operator|)
operator|!=
literal|0
condition|)
block|{
name|scbid
operator|=
name|ahd_inw
argument_list|(
name|ahd
argument_list|,
name|MK_MESSAGE_SCB
argument_list|)
expr_stmt|;
name|mk_msg_scb
operator|=
name|ahd_lookup_scb
argument_list|(
name|ahd
argument_list|,
name|scbid
argument_list|)
expr_stmt|;
block|}
else|else
name|mk_msg_scb
operator|=
name|NULL
expr_stmt|;
name|savedscbptr
operator|=
name|ahd_get_scbptr
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
name|tid_next
operator|=
name|ahd_inw
argument_list|(
name|ahd
argument_list|,
name|WAITING_TID_HEAD
argument_list|)
expr_stmt|;
name|tid_prev
operator|=
name|SCB_LIST_NULL
expr_stmt|;
name|targets
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|scbid
operator|=
name|tid_next
init|;
operator|!
name|SCBID_IS_NULL
argument_list|(
name|scbid
argument_list|)
condition|;
name|scbid
operator|=
name|tid_next
control|)
block|{
name|u_int
name|tid_head
decl_stmt|;
name|u_int
name|tid_tail
decl_stmt|;
name|targets
operator|++
expr_stmt|;
if|if
condition|(
name|targets
operator|>
name|AHD_NUM_TARGETS
condition|)
name|panic
argument_list|(
literal|"TID LIST LOOP"
argument_list|)
expr_stmt|;
if|if
condition|(
name|scbid
operator|>=
name|ahd
operator|->
name|scb_data
operator|.
name|numscbs
condition|)
block|{
name|printf
argument_list|(
literal|"%s: Waiting TID List inconsistency. "
literal|"SCB index == 0x%x, yet numscbs == 0x%x."
argument_list|,
name|ahd_name
argument_list|(
name|ahd
argument_list|)
argument_list|,
name|scbid
argument_list|,
name|ahd
operator|->
name|scb_data
operator|.
name|numscbs
argument_list|)
expr_stmt|;
name|ahd_dump_card_state
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"for safety"
argument_list|)
expr_stmt|;
block|}
name|scb
operator|=
name|ahd_lookup_scb
argument_list|(
name|ahd
argument_list|,
name|scbid
argument_list|)
expr_stmt|;
if|if
condition|(
name|scb
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"%s: SCB = 0x%x Not Active!\n"
argument_list|,
name|ahd_name
argument_list|(
name|ahd
argument_list|)
argument_list|,
name|scbid
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"Waiting TID List traversal\n"
argument_list|)
expr_stmt|;
block|}
name|ahd_set_scbptr
argument_list|(
name|ahd
argument_list|,
name|scbid
argument_list|)
expr_stmt|;
name|tid_next
operator|=
name|ahd_inw_scbram
argument_list|(
name|ahd
argument_list|,
name|SCB_NEXT2
argument_list|)
expr_stmt|;
if|if
condition|(
name|ahd_match_scb
argument_list|(
name|ahd
argument_list|,
name|scb
argument_list|,
name|target
argument_list|,
name|channel
argument_list|,
name|CAM_LUN_WILDCARD
argument_list|,
name|SCB_LIST_NULL
argument_list|,
name|ROLE_UNKNOWN
argument_list|)
operator|==
literal|0
condition|)
block|{
name|tid_prev
operator|=
name|scbid
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * We found a list of scbs that needs to be searched. 		 */
if|if
condition|(
name|action
operator|==
name|SEARCH_PRINT
condition|)
name|printf
argument_list|(
literal|"       %d ( "
argument_list|,
name|SCB_GET_TARGET
argument_list|(
name|ahd
argument_list|,
name|scb
argument_list|)
argument_list|)
expr_stmt|;
name|tid_head
operator|=
name|scbid
expr_stmt|;
name|found
operator|+=
name|ahd_search_scb_list
argument_list|(
name|ahd
argument_list|,
name|target
argument_list|,
name|channel
argument_list|,
name|lun
argument_list|,
name|tag
argument_list|,
name|role
argument_list|,
name|status
argument_list|,
name|action
argument_list|,
operator|&
name|tid_head
argument_list|,
operator|&
name|tid_tail
argument_list|,
name|SCB_GET_TARGET
argument_list|(
name|ahd
argument_list|,
name|scb
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 		 * Check any MK_MESSAGE SCB that is still waiting to 		 * enter this target's waiting for selection queue. 		 */
if|if
condition|(
name|mk_msg_scb
operator|!=
name|NULL
operator|&&
name|ahd_match_scb
argument_list|(
name|ahd
argument_list|,
name|mk_msg_scb
argument_list|,
name|target
argument_list|,
name|channel
argument_list|,
name|lun
argument_list|,
name|tag
argument_list|,
name|role
argument_list|)
condition|)
block|{
comment|/* 			 * We found an scb that needs to be acted on. 			 */
name|found
operator|++
expr_stmt|;
switch|switch
condition|(
name|action
condition|)
block|{
case|case
name|SEARCH_COMPLETE
case|:
if|if
condition|(
operator|(
name|mk_msg_scb
operator|->
name|flags
operator|&
name|SCB_ACTIVE
operator|)
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"Inactive SCB pending MK_MSG\n"
argument_list|)
expr_stmt|;
name|ahd_done_with_status
argument_list|(
name|ahd
argument_list|,
name|mk_msg_scb
argument_list|,
name|status
argument_list|)
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
name|SEARCH_REMOVE
case|:
block|{
name|u_int
name|tail_offset
decl_stmt|;
name|printf
argument_list|(
literal|"Removing MK_MSG scb\n"
argument_list|)
expr_stmt|;
comment|/* 				 * Reset our tail to the tail of the 				 * main per-target list. 				 */
name|tail_offset
operator|=
name|WAITING_SCB_TAILS
operator|+
operator|(
literal|2
operator|*
name|SCB_GET_TARGET
argument_list|(
name|ahd
argument_list|,
name|mk_msg_scb
argument_list|)
operator|)
expr_stmt|;
name|ahd_outw
argument_list|(
name|ahd
argument_list|,
name|tail_offset
argument_list|,
name|tid_tail
argument_list|)
expr_stmt|;
name|seq_flags2
operator|&=
operator|~
name|PENDING_MK_MESSAGE
expr_stmt|;
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|SEQ_FLAGS2
argument_list|,
name|seq_flags2
argument_list|)
expr_stmt|;
name|ahd_outw
argument_list|(
name|ahd
argument_list|,
name|CMDS_PENDING
argument_list|,
name|ahd_inw
argument_list|(
name|ahd
argument_list|,
name|CMDS_PENDING
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|mk_msg_scb
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
case|case
name|SEARCH_PRINT
case|:
name|printf
argument_list|(
literal|" 0x%x"
argument_list|,
name|SCB_GET_TAG
argument_list|(
name|scb
argument_list|)
argument_list|)
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
name|SEARCH_COUNT
case|:
break|break;
block|}
block|}
if|if
condition|(
name|mk_msg_scb
operator|!=
name|NULL
operator|&&
name|SCBID_IS_NULL
argument_list|(
name|tid_head
argument_list|)
operator|&&
name|ahd_match_scb
argument_list|(
name|ahd
argument_list|,
name|scb
argument_list|,
name|target
argument_list|,
name|channel
argument_list|,
name|CAM_LUN_WILDCARD
argument_list|,
name|SCB_LIST_NULL
argument_list|,
name|ROLE_UNKNOWN
argument_list|)
condition|)
block|{
comment|/* 			 * When removing the last SCB for a target 			 * queue with a pending MK_MESSAGE scb, we 			 * must queue the MK_MESSAGE scb. 			 */
name|printf
argument_list|(
literal|"Queueing mk_msg_scb\n"
argument_list|)
expr_stmt|;
name|tid_head
operator|=
name|ahd_inw
argument_list|(
name|ahd
argument_list|,
name|MK_MESSAGE_SCB
argument_list|)
expr_stmt|;
name|seq_flags2
operator|&=
operator|~
name|PENDING_MK_MESSAGE
expr_stmt|;
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|SEQ_FLAGS2
argument_list|,
name|seq_flags2
argument_list|)
expr_stmt|;
name|mk_msg_scb
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|tid_head
operator|!=
name|scbid
condition|)
name|ahd_stitch_tid_list
argument_list|(
name|ahd
argument_list|,
name|tid_prev
argument_list|,
name|tid_head
argument_list|,
name|tid_next
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|SCBID_IS_NULL
argument_list|(
name|tid_head
argument_list|)
condition|)
name|tid_prev
operator|=
name|tid_head
expr_stmt|;
if|if
condition|(
name|action
operator|==
name|SEARCH_PRINT
condition|)
name|printf
argument_list|(
literal|")\n"
argument_list|)
expr_stmt|;
block|}
comment|/* Restore saved state. */
name|ahd_set_scbptr
argument_list|(
name|ahd
argument_list|,
name|savedscbptr
argument_list|)
expr_stmt|;
name|ahd_restore_modes
argument_list|(
name|ahd
argument_list|,
name|saved_modes
argument_list|)
expr_stmt|;
return|return
operator|(
name|found
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ahd_search_scb_list
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|,
name|int
name|target
parameter_list|,
name|char
name|channel
parameter_list|,
name|int
name|lun
parameter_list|,
name|u_int
name|tag
parameter_list|,
name|role_t
name|role
parameter_list|,
name|uint32_t
name|status
parameter_list|,
name|ahd_search_action
name|action
parameter_list|,
name|u_int
modifier|*
name|list_head
parameter_list|,
name|u_int
modifier|*
name|list_tail
parameter_list|,
name|u_int
name|tid
parameter_list|)
block|{
name|struct
name|scb
modifier|*
name|scb
decl_stmt|;
name|u_int
name|scbid
decl_stmt|;
name|u_int
name|next
decl_stmt|;
name|u_int
name|prev
decl_stmt|;
name|int
name|found
decl_stmt|;
name|AHD_ASSERT_MODES
argument_list|(
name|ahd
argument_list|,
name|AHD_MODE_SCSI_MSK
argument_list|,
name|AHD_MODE_SCSI_MSK
argument_list|)
expr_stmt|;
name|found
operator|=
literal|0
expr_stmt|;
name|prev
operator|=
name|SCB_LIST_NULL
expr_stmt|;
name|next
operator|=
operator|*
name|list_head
expr_stmt|;
operator|*
name|list_tail
operator|=
name|SCB_LIST_NULL
expr_stmt|;
for|for
control|(
name|scbid
operator|=
name|next
init|;
operator|!
name|SCBID_IS_NULL
argument_list|(
name|scbid
argument_list|)
condition|;
name|scbid
operator|=
name|next
control|)
block|{
if|if
condition|(
name|scbid
operator|>=
name|ahd
operator|->
name|scb_data
operator|.
name|numscbs
condition|)
block|{
name|printf
argument_list|(
literal|"%s:SCB List inconsistency. "
literal|"SCB == 0x%x, yet numscbs == 0x%x."
argument_list|,
name|ahd_name
argument_list|(
name|ahd
argument_list|)
argument_list|,
name|scbid
argument_list|,
name|ahd
operator|->
name|scb_data
operator|.
name|numscbs
argument_list|)
expr_stmt|;
name|ahd_dump_card_state
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"for safety"
argument_list|)
expr_stmt|;
block|}
name|scb
operator|=
name|ahd_lookup_scb
argument_list|(
name|ahd
argument_list|,
name|scbid
argument_list|)
expr_stmt|;
if|if
condition|(
name|scb
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"%s: SCB = %d Not Active!\n"
argument_list|,
name|ahd_name
argument_list|(
name|ahd
argument_list|)
argument_list|,
name|scbid
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"Waiting List traversal\n"
argument_list|)
expr_stmt|;
block|}
name|ahd_set_scbptr
argument_list|(
name|ahd
argument_list|,
name|scbid
argument_list|)
expr_stmt|;
operator|*
name|list_tail
operator|=
name|scbid
expr_stmt|;
name|next
operator|=
name|ahd_inw_scbram
argument_list|(
name|ahd
argument_list|,
name|SCB_NEXT
argument_list|)
expr_stmt|;
if|if
condition|(
name|ahd_match_scb
argument_list|(
name|ahd
argument_list|,
name|scb
argument_list|,
name|target
argument_list|,
name|channel
argument_list|,
name|lun
argument_list|,
name|SCB_LIST_NULL
argument_list|,
name|role
argument_list|)
operator|==
literal|0
condition|)
block|{
name|prev
operator|=
name|scbid
expr_stmt|;
continue|continue;
block|}
name|found
operator|++
expr_stmt|;
switch|switch
condition|(
name|action
condition|)
block|{
case|case
name|SEARCH_COMPLETE
case|:
if|if
condition|(
operator|(
name|scb
operator|->
name|flags
operator|&
name|SCB_ACTIVE
operator|)
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"Inactive SCB in Waiting List\n"
argument_list|)
expr_stmt|;
name|ahd_done_with_status
argument_list|(
name|ahd
argument_list|,
name|scb
argument_list|,
name|status
argument_list|)
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
name|SEARCH_REMOVE
case|:
name|ahd_rem_wscb
argument_list|(
name|ahd
argument_list|,
name|scbid
argument_list|,
name|prev
argument_list|,
name|next
argument_list|,
name|tid
argument_list|)
expr_stmt|;
operator|*
name|list_tail
operator|=
name|prev
expr_stmt|;
if|if
condition|(
name|SCBID_IS_NULL
argument_list|(
name|prev
argument_list|)
condition|)
operator|*
name|list_head
operator|=
name|next
expr_stmt|;
break|break;
case|case
name|SEARCH_PRINT
case|:
name|printf
argument_list|(
literal|"0x%x "
argument_list|,
name|scbid
argument_list|)
expr_stmt|;
case|case
name|SEARCH_COUNT
case|:
name|prev
operator|=
name|scbid
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|found
operator|>
name|AHD_SCB_MAX
condition|)
name|panic
argument_list|(
literal|"SCB LIST LOOP"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|action
operator|==
name|SEARCH_COMPLETE
operator|||
name|action
operator|==
name|SEARCH_REMOVE
condition|)
name|ahd_outw
argument_list|(
name|ahd
argument_list|,
name|CMDS_PENDING
argument_list|,
name|ahd_inw
argument_list|(
name|ahd
argument_list|,
name|CMDS_PENDING
argument_list|)
operator|-
name|found
argument_list|)
expr_stmt|;
return|return
operator|(
name|found
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ahd_stitch_tid_list
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|,
name|u_int
name|tid_prev
parameter_list|,
name|u_int
name|tid_cur
parameter_list|,
name|u_int
name|tid_next
parameter_list|)
block|{
name|AHD_ASSERT_MODES
argument_list|(
name|ahd
argument_list|,
name|AHD_MODE_SCSI_MSK
argument_list|,
name|AHD_MODE_SCSI_MSK
argument_list|)
expr_stmt|;
if|if
condition|(
name|SCBID_IS_NULL
argument_list|(
name|tid_cur
argument_list|)
condition|)
block|{
comment|/* Bypass current TID list */
if|if
condition|(
name|SCBID_IS_NULL
argument_list|(
name|tid_prev
argument_list|)
condition|)
block|{
name|ahd_outw
argument_list|(
name|ahd
argument_list|,
name|WAITING_TID_HEAD
argument_list|,
name|tid_next
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ahd_set_scbptr
argument_list|(
name|ahd
argument_list|,
name|tid_prev
argument_list|)
expr_stmt|;
name|ahd_outw
argument_list|(
name|ahd
argument_list|,
name|SCB_NEXT2
argument_list|,
name|tid_next
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|SCBID_IS_NULL
argument_list|(
name|tid_next
argument_list|)
condition|)
name|ahd_outw
argument_list|(
name|ahd
argument_list|,
name|WAITING_TID_TAIL
argument_list|,
name|tid_prev
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Stitch through tid_cur */
if|if
condition|(
name|SCBID_IS_NULL
argument_list|(
name|tid_prev
argument_list|)
condition|)
block|{
name|ahd_outw
argument_list|(
name|ahd
argument_list|,
name|WAITING_TID_HEAD
argument_list|,
name|tid_cur
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ahd_set_scbptr
argument_list|(
name|ahd
argument_list|,
name|tid_prev
argument_list|)
expr_stmt|;
name|ahd_outw
argument_list|(
name|ahd
argument_list|,
name|SCB_NEXT2
argument_list|,
name|tid_cur
argument_list|)
expr_stmt|;
block|}
name|ahd_set_scbptr
argument_list|(
name|ahd
argument_list|,
name|tid_cur
argument_list|)
expr_stmt|;
name|ahd_outw
argument_list|(
name|ahd
argument_list|,
name|SCB_NEXT2
argument_list|,
name|tid_next
argument_list|)
expr_stmt|;
if|if
condition|(
name|SCBID_IS_NULL
argument_list|(
name|tid_next
argument_list|)
condition|)
name|ahd_outw
argument_list|(
name|ahd
argument_list|,
name|WAITING_TID_TAIL
argument_list|,
name|tid_cur
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Manipulate the waiting for selection list and return the  * scb that follows the one that we remove.  */
end_comment

begin_function
specifier|static
name|u_int
name|ahd_rem_wscb
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|,
name|u_int
name|scbid
parameter_list|,
name|u_int
name|prev
parameter_list|,
name|u_int
name|next
parameter_list|,
name|u_int
name|tid
parameter_list|)
block|{
name|u_int
name|tail_offset
decl_stmt|;
name|AHD_ASSERT_MODES
argument_list|(
name|ahd
argument_list|,
name|AHD_MODE_SCSI_MSK
argument_list|,
name|AHD_MODE_SCSI_MSK
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|SCBID_IS_NULL
argument_list|(
name|prev
argument_list|)
condition|)
block|{
name|ahd_set_scbptr
argument_list|(
name|ahd
argument_list|,
name|prev
argument_list|)
expr_stmt|;
name|ahd_outw
argument_list|(
name|ahd
argument_list|,
name|SCB_NEXT
argument_list|,
name|next
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * SCBs that have MK_MESSAGE set in them may 	 * cause the tail pointer to be updated without 	 * setting the next pointer of the previous tail. 	 * Only clear the tail if the removed SCB was 	 * the tail. 	 */
name|tail_offset
operator|=
name|WAITING_SCB_TAILS
operator|+
operator|(
literal|2
operator|*
name|tid
operator|)
expr_stmt|;
if|if
condition|(
name|SCBID_IS_NULL
argument_list|(
name|next
argument_list|)
operator|&&
name|ahd_inw
argument_list|(
name|ahd
argument_list|,
name|tail_offset
argument_list|)
operator|==
name|scbid
condition|)
name|ahd_outw
argument_list|(
name|ahd
argument_list|,
name|tail_offset
argument_list|,
name|prev
argument_list|)
expr_stmt|;
name|ahd_add_scb_to_free_list
argument_list|(
name|ahd
argument_list|,
name|scbid
argument_list|)
expr_stmt|;
return|return
operator|(
name|next
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Add the SCB as selected by SCBPTR onto the on chip list of  * free hardware SCBs.  This list is empty/unused if we are not  * performing SCB paging.  */
end_comment

begin_function
specifier|static
name|void
name|ahd_add_scb_to_free_list
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|,
name|u_int
name|scbid
parameter_list|)
block|{
comment|/* XXX Need some other mechanism to designate "free". */
comment|/* 	 * Invalidate the tag so that our abort 	 * routines don't think it's active. 	ahd_outb(ahd, SCB_TAG, SCB_LIST_NULL); 	 */
block|}
end_function

begin_comment
comment|/******************************** Error Handling ******************************/
end_comment

begin_comment
comment|/*  * Abort all SCBs that match the given description (target/channel/lun/tag),  * setting their status to the passed in status if the status has not already  * been modified from CAM_REQ_INPROG.  This routine assumes that the sequencer  * is paused before it is called.  */
end_comment

begin_function
name|int
name|ahd_abort_scbs
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|,
name|int
name|target
parameter_list|,
name|char
name|channel
parameter_list|,
name|int
name|lun
parameter_list|,
name|u_int
name|tag
parameter_list|,
name|role_t
name|role
parameter_list|,
name|uint32_t
name|status
parameter_list|)
block|{
name|struct
name|scb
modifier|*
name|scbp
decl_stmt|;
name|struct
name|scb
modifier|*
name|scbp_next
decl_stmt|;
name|u_int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|u_int
name|maxtarget
decl_stmt|;
name|u_int
name|minlun
decl_stmt|;
name|u_int
name|maxlun
decl_stmt|;
name|int
name|found
decl_stmt|;
name|ahd_mode_state
name|saved_modes
decl_stmt|;
comment|/* restore this when we're done */
name|saved_modes
operator|=
name|ahd_save_modes
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
name|ahd_set_modes
argument_list|(
name|ahd
argument_list|,
name|AHD_MODE_SCSI
argument_list|,
name|AHD_MODE_SCSI
argument_list|)
expr_stmt|;
name|found
operator|=
name|ahd_search_qinfifo
argument_list|(
name|ahd
argument_list|,
name|target
argument_list|,
name|channel
argument_list|,
name|lun
argument_list|,
name|SCB_LIST_NULL
argument_list|,
name|role
argument_list|,
name|CAM_REQUEUE_REQ
argument_list|,
name|SEARCH_COMPLETE
argument_list|)
expr_stmt|;
comment|/* 	 * Clean out the busy target table for any untagged commands. 	 */
name|i
operator|=
literal|0
expr_stmt|;
name|maxtarget
operator|=
literal|16
expr_stmt|;
if|if
condition|(
name|target
operator|!=
name|CAM_TARGET_WILDCARD
condition|)
block|{
name|i
operator|=
name|target
expr_stmt|;
if|if
condition|(
name|channel
operator|==
literal|'B'
condition|)
name|i
operator|+=
literal|8
expr_stmt|;
name|maxtarget
operator|=
name|i
operator|+
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|lun
operator|==
name|CAM_LUN_WILDCARD
condition|)
block|{
name|minlun
operator|=
literal|0
expr_stmt|;
name|maxlun
operator|=
name|AHD_NUM_LUNS_NONPKT
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|lun
operator|>=
name|AHD_NUM_LUNS_NONPKT
condition|)
block|{
name|minlun
operator|=
name|maxlun
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|minlun
operator|=
name|lun
expr_stmt|;
name|maxlun
operator|=
name|lun
operator|+
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|role
operator|!=
name|ROLE_TARGET
condition|)
block|{
for|for
control|(
init|;
name|i
operator|<
name|maxtarget
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
name|minlun
init|;
name|j
operator|<
name|maxlun
condition|;
name|j
operator|++
control|)
block|{
name|u_int
name|scbid
decl_stmt|;
name|u_int
name|tcl
decl_stmt|;
name|tcl
operator|=
name|BUILD_TCL_RAW
argument_list|(
name|i
argument_list|,
literal|'A'
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|scbid
operator|=
name|ahd_find_busy_tcl
argument_list|(
name|ahd
argument_list|,
name|tcl
argument_list|)
expr_stmt|;
name|scbp
operator|=
name|ahd_lookup_scb
argument_list|(
name|ahd
argument_list|,
name|scbid
argument_list|)
expr_stmt|;
if|if
condition|(
name|scbp
operator|==
name|NULL
operator|||
name|ahd_match_scb
argument_list|(
name|ahd
argument_list|,
name|scbp
argument_list|,
name|target
argument_list|,
name|channel
argument_list|,
name|lun
argument_list|,
name|tag
argument_list|,
name|role
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
name|ahd_unbusy_tcl
argument_list|(
name|ahd
argument_list|,
name|BUILD_TCL_RAW
argument_list|(
name|i
argument_list|,
literal|'A'
argument_list|,
name|j
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* 	 * Don't abort commands that have already completed, 	 * but haven't quite made it up to the host yet. 	 */
name|ahd_flush_qoutfifo
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
comment|/* 	 * Go through the pending CCB list and look for 	 * commands for this target that are still active. 	 * These are other tagged commands that were 	 * disconnected when the reset occurred. 	 */
name|scbp_next
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|ahd
operator|->
name|pending_scbs
argument_list|)
expr_stmt|;
while|while
condition|(
name|scbp_next
operator|!=
name|NULL
condition|)
block|{
name|scbp
operator|=
name|scbp_next
expr_stmt|;
name|scbp_next
operator|=
name|LIST_NEXT
argument_list|(
name|scbp
argument_list|,
name|pending_links
argument_list|)
expr_stmt|;
if|if
condition|(
name|ahd_match_scb
argument_list|(
name|ahd
argument_list|,
name|scbp
argument_list|,
name|target
argument_list|,
name|channel
argument_list|,
name|lun
argument_list|,
name|tag
argument_list|,
name|role
argument_list|)
condition|)
block|{
name|cam_status
name|ostat
decl_stmt|;
name|ostat
operator|=
name|aic_get_transaction_status
argument_list|(
name|scbp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ostat
operator|==
name|CAM_REQ_INPROG
condition|)
name|aic_set_transaction_status
argument_list|(
name|scbp
argument_list|,
name|status
argument_list|)
expr_stmt|;
if|if
condition|(
name|aic_get_transaction_status
argument_list|(
name|scbp
argument_list|)
operator|!=
name|CAM_REQ_CMP
condition|)
name|aic_freeze_scb
argument_list|(
name|scbp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|scbp
operator|->
name|flags
operator|&
name|SCB_ACTIVE
operator|)
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"Inactive SCB on pending list\n"
argument_list|)
expr_stmt|;
name|ahd_done
argument_list|(
name|ahd
argument_list|,
name|scbp
argument_list|)
expr_stmt|;
name|found
operator|++
expr_stmt|;
block|}
block|}
name|ahd_restore_modes
argument_list|(
name|ahd
argument_list|,
name|saved_modes
argument_list|)
expr_stmt|;
name|ahd_platform_abort_scbs
argument_list|(
name|ahd
argument_list|,
name|target
argument_list|,
name|channel
argument_list|,
name|lun
argument_list|,
name|tag
argument_list|,
name|role
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|ahd
operator|->
name|flags
operator||=
name|AHD_UPDATE_PEND_CMDS
expr_stmt|;
return|return
name|found
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ahd_reset_current_bus
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|)
block|{
name|uint8_t
name|scsiseq
decl_stmt|;
name|AHD_ASSERT_MODES
argument_list|(
name|ahd
argument_list|,
name|AHD_MODE_SCSI_MSK
argument_list|,
name|AHD_MODE_SCSI_MSK
argument_list|)
expr_stmt|;
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|SIMODE1
argument_list|,
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|SIMODE1
argument_list|)
operator|&
operator|~
name|ENSCSIRST
argument_list|)
expr_stmt|;
name|scsiseq
operator|=
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|SCSISEQ0
argument_list|)
operator|&
operator|~
operator|(
name|ENSELO
operator||
name|ENARBO
operator||
name|SCSIRSTO
operator|)
expr_stmt|;
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|SCSISEQ0
argument_list|,
name|scsiseq
operator||
name|SCSIRSTO
argument_list|)
expr_stmt|;
name|ahd_flush_device_writes
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
name|aic_delay
argument_list|(
name|AHD_BUSRESET_DELAY
argument_list|)
expr_stmt|;
comment|/* Turn off the bus reset */
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|SCSISEQ0
argument_list|,
name|scsiseq
argument_list|)
expr_stmt|;
name|ahd_flush_device_writes
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
name|aic_delay
argument_list|(
name|AHD_BUSRESET_DELAY
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ahd
operator|->
name|bugs
operator|&
name|AHD_SCSIRST_BUG
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * 2A Razor #474 		 * Certain chip state is not cleared for 		 * SCSI bus resets that we initiate, so 		 * we must reset the chip. 		 */
name|ahd_reset
argument_list|(
name|ahd
argument_list|,
comment|/*reinit*/
name|TRUE
argument_list|)
expr_stmt|;
name|ahd_intr_enable
argument_list|(
name|ahd
argument_list|,
comment|/*enable*/
name|TRUE
argument_list|)
expr_stmt|;
name|AHD_ASSERT_MODES
argument_list|(
name|ahd
argument_list|,
name|AHD_MODE_SCSI_MSK
argument_list|,
name|AHD_MODE_SCSI_MSK
argument_list|)
expr_stmt|;
block|}
name|ahd_clear_intstat
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|ahd_reset_channel
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|,
name|char
name|channel
parameter_list|,
name|int
name|initiate_reset
parameter_list|)
block|{
name|struct
name|ahd_devinfo
name|devinfo
decl_stmt|;
name|u_int
name|initiator
decl_stmt|;
name|u_int
name|target
decl_stmt|;
name|u_int
name|max_scsiid
decl_stmt|;
name|int
name|found
decl_stmt|;
name|u_int
name|fifo
decl_stmt|;
name|u_int
name|next_fifo
decl_stmt|;
name|ahd
operator|->
name|pending_device
operator|=
name|NULL
expr_stmt|;
name|ahd_compile_devinfo
argument_list|(
operator|&
name|devinfo
argument_list|,
name|CAM_TARGET_WILDCARD
argument_list|,
name|CAM_TARGET_WILDCARD
argument_list|,
name|CAM_LUN_WILDCARD
argument_list|,
name|channel
argument_list|,
name|ROLE_UNKNOWN
argument_list|)
expr_stmt|;
name|ahd_pause
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
comment|/* Make sure the sequencer is in a safe location. */
name|ahd_clear_critical_section
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|AHD_TARGET_MODE
if|if
condition|(
operator|(
name|ahd
operator|->
name|flags
operator|&
name|AHD_TARGETROLE
operator|)
operator|!=
literal|0
condition|)
block|{
name|ahd_run_tqinfifo
argument_list|(
name|ahd
argument_list|,
comment|/*paused*/
name|TRUE
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|ahd_set_modes
argument_list|(
name|ahd
argument_list|,
name|AHD_MODE_SCSI
argument_list|,
name|AHD_MODE_SCSI
argument_list|)
expr_stmt|;
comment|/* 	 * Disable selections so no automatic hardware 	 * functions will modify chip state. 	 */
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|SCSISEQ0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|SCSISEQ1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Safely shut down our DMA engines.  Always start with 	 * the FIFO that is not currently active (if any are 	 * actively connected). 	 */
name|next_fifo
operator|=
name|fifo
operator|=
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|DFFSTAT
argument_list|)
operator|&
name|CURRFIFO
expr_stmt|;
if|if
condition|(
name|next_fifo
operator|>
name|CURRFIFO_1
condition|)
comment|/* If disconneced, arbitrarily start with FIFO1. */
name|next_fifo
operator|=
name|fifo
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|next_fifo
operator|^=
name|CURRFIFO_1
expr_stmt|;
name|ahd_set_modes
argument_list|(
name|ahd
argument_list|,
name|next_fifo
argument_list|,
name|next_fifo
argument_list|)
expr_stmt|;
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|DFCNTRL
argument_list|,
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|DFCNTRL
argument_list|)
operator|&
operator|~
operator|(
name|SCSIEN
operator||
name|HDMAEN
operator|)
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|DFCNTRL
argument_list|)
operator|&
name|HDMAENACK
operator|)
operator|!=
literal|0
condition|)
name|aic_delay
argument_list|(
literal|10
argument_list|)
expr_stmt|;
comment|/* 		 * Set CURRFIFO to the now inactive channel. 		 */
name|ahd_set_modes
argument_list|(
name|ahd
argument_list|,
name|AHD_MODE_SCSI
argument_list|,
name|AHD_MODE_SCSI
argument_list|)
expr_stmt|;
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|DFFSTAT
argument_list|,
name|next_fifo
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|next_fifo
operator|!=
name|fifo
condition|)
do|;
comment|/* 	 * Reset the bus if we are initiating this reset 	 */
name|ahd_clear_msg_state
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|SIMODE1
argument_list|,
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|SIMODE1
argument_list|)
operator|&
operator|~
operator|(
name|ENBUSFREE
operator||
name|ENSCSIRST
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|initiate_reset
condition|)
name|ahd_reset_current_bus
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
name|ahd_clear_intstat
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
comment|/* 	 * Clean up all the state information for the 	 * pending transactions on this bus. 	 */
name|found
operator|=
name|ahd_abort_scbs
argument_list|(
name|ahd
argument_list|,
name|CAM_TARGET_WILDCARD
argument_list|,
name|channel
argument_list|,
name|CAM_LUN_WILDCARD
argument_list|,
name|SCB_LIST_NULL
argument_list|,
name|ROLE_UNKNOWN
argument_list|,
name|CAM_SCSI_BUS_RESET
argument_list|)
expr_stmt|;
comment|/* 	 * Cleanup anything left in the FIFOs. 	 */
name|ahd_clear_fifo
argument_list|(
name|ahd
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ahd_clear_fifo
argument_list|(
name|ahd
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* 	 * Revert to async/narrow transfers until we renegotiate. 	 */
name|max_scsiid
operator|=
operator|(
name|ahd
operator|->
name|features
operator|&
name|AHD_WIDE
operator|)
condition|?
literal|15
else|:
literal|7
expr_stmt|;
for|for
control|(
name|target
operator|=
literal|0
init|;
name|target
operator|<=
name|max_scsiid
condition|;
name|target
operator|++
control|)
block|{
if|if
condition|(
name|ahd
operator|->
name|enabled_targets
index|[
name|target
index|]
operator|==
name|NULL
condition|)
continue|continue;
for|for
control|(
name|initiator
operator|=
literal|0
init|;
name|initiator
operator|<=
name|max_scsiid
condition|;
name|initiator
operator|++
control|)
block|{
name|struct
name|ahd_devinfo
name|devinfo
decl_stmt|;
name|ahd_compile_devinfo
argument_list|(
operator|&
name|devinfo
argument_list|,
name|target
argument_list|,
name|initiator
argument_list|,
name|CAM_LUN_WILDCARD
argument_list|,
literal|'A'
argument_list|,
name|ROLE_UNKNOWN
argument_list|)
expr_stmt|;
name|ahd_set_width
argument_list|(
name|ahd
argument_list|,
operator|&
name|devinfo
argument_list|,
name|MSG_EXT_WDTR_BUS_8_BIT
argument_list|,
name|AHD_TRANS_CUR
argument_list|,
comment|/*paused*/
name|TRUE
argument_list|)
expr_stmt|;
name|ahd_set_syncrate
argument_list|(
name|ahd
argument_list|,
operator|&
name|devinfo
argument_list|,
comment|/*period*/
literal|0
argument_list|,
comment|/*offset*/
literal|0
argument_list|,
comment|/*ppr_options*/
literal|0
argument_list|,
name|AHD_TRANS_CUR
argument_list|,
comment|/*paused*/
name|TRUE
argument_list|)
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|AHD_TARGET_MODE
name|max_scsiid
operator|=
operator|(
name|ahd
operator|->
name|features
operator|&
name|AHD_WIDE
operator|)
condition|?
literal|15
else|:
literal|7
expr_stmt|;
comment|/* 	 * Send an immediate notify ccb to all target more peripheral 	 * drivers affected by this action. 	 */
for|for
control|(
name|target
operator|=
literal|0
init|;
name|target
operator|<=
name|max_scsiid
condition|;
name|target
operator|++
control|)
block|{
name|struct
name|ahd_tmode_tstate
modifier|*
name|tstate
decl_stmt|;
name|u_int
name|lun
decl_stmt|;
name|tstate
operator|=
name|ahd
operator|->
name|enabled_targets
index|[
name|target
index|]
expr_stmt|;
if|if
condition|(
name|tstate
operator|==
name|NULL
condition|)
continue|continue;
for|for
control|(
name|lun
operator|=
literal|0
init|;
name|lun
operator|<
name|AHD_NUM_LUNS
condition|;
name|lun
operator|++
control|)
block|{
name|struct
name|ahd_tmode_lstate
modifier|*
name|lstate
decl_stmt|;
name|lstate
operator|=
name|tstate
operator|->
name|enabled_luns
index|[
name|lun
index|]
expr_stmt|;
if|if
condition|(
name|lstate
operator|==
name|NULL
condition|)
continue|continue;
name|ahd_queue_lstate_event
argument_list|(
name|ahd
argument_list|,
name|lstate
argument_list|,
name|CAM_TARGET_WILDCARD
argument_list|,
name|EVENT_TYPE_BUS_RESET
argument_list|,
comment|/*arg*/
literal|0
argument_list|)
expr_stmt|;
name|ahd_send_lstate_events
argument_list|(
name|ahd
argument_list|,
name|lstate
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* Notify the XPT that a bus reset occurred */
name|ahd_send_async
argument_list|(
name|ahd
argument_list|,
name|devinfo
operator|.
name|channel
argument_list|,
name|CAM_TARGET_WILDCARD
argument_list|,
name|CAM_LUN_WILDCARD
argument_list|,
name|AC_BUS_RESET
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ahd_restart
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
comment|/* 	 * Freeze the SIMQ until our poller can determine that 	 * the bus reset has really gone away.  We set the initial 	 * timer to 0 to have the check performed as soon as possible 	 * from the timer context. 	 */
if|if
condition|(
operator|(
name|ahd
operator|->
name|flags
operator|&
name|AHD_RESET_POLL_ACTIVE
operator|)
operator|==
literal|0
condition|)
block|{
name|ahd
operator|->
name|flags
operator||=
name|AHD_RESET_POLL_ACTIVE
expr_stmt|;
name|aic_freeze_simq
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
name|aic_timer_reset
argument_list|(
operator|&
name|ahd
operator|->
name|reset_timer
argument_list|,
literal|0
argument_list|,
name|ahd_reset_poll
argument_list|,
name|ahd
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|found
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|AHD_RESET_POLL_MS
value|1
end_define

begin_function
specifier|static
name|void
name|ahd_reset_poll
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ahd_softc
modifier|*
name|ahd
init|=
operator|(
expr|struct
name|ahd_softc
operator|*
operator|)
name|arg
decl_stmt|;
name|u_int
name|scsiseq1
decl_stmt|;
name|ahd_lock
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
name|ahd_pause
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
name|ahd_update_modes
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
name|ahd_set_modes
argument_list|(
name|ahd
argument_list|,
name|AHD_MODE_SCSI
argument_list|,
name|AHD_MODE_SCSI
argument_list|)
expr_stmt|;
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|CLRSINT1
argument_list|,
name|CLRSCSIRSTI
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|SSTAT1
argument_list|)
operator|&
name|SCSIRSTI
operator|)
operator|!=
literal|0
condition|)
block|{
name|aic_timer_reset
argument_list|(
operator|&
name|ahd
operator|->
name|reset_timer
argument_list|,
name|AHD_RESET_POLL_MS
argument_list|,
name|ahd_reset_poll
argument_list|,
name|ahd
argument_list|)
expr_stmt|;
name|ahd_unpause
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
name|ahd_unlock
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Reset is now low.  Complete chip reinitialization. */
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|SIMODE1
argument_list|,
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|SIMODE1
argument_list|)
operator||
name|ENSCSIRST
argument_list|)
expr_stmt|;
name|scsiseq1
operator|=
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|SCSISEQ_TEMPLATE
argument_list|)
expr_stmt|;
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|SCSISEQ1
argument_list|,
name|scsiseq1
operator|&
operator|(
name|ENSELI
operator||
name|ENRSELI
operator||
name|ENAUTOATNP
operator|)
argument_list|)
expr_stmt|;
name|ahd_unpause
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
name|ahd
operator|->
name|flags
operator|&=
operator|~
name|AHD_RESET_POLL_ACTIVE
expr_stmt|;
name|aic_release_simq
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
name|ahd_unlock
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**************************** Statistics Processing ***************************/
end_comment

begin_function
specifier|static
name|void
name|ahd_stat_timer
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ahd_softc
modifier|*
name|ahd
init|=
operator|(
expr|struct
name|ahd_softc
operator|*
operator|)
name|arg
decl_stmt|;
name|int
name|enint_coal
decl_stmt|;
name|ahd_lock
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
name|enint_coal
operator|=
name|ahd
operator|->
name|hs_mailbox
operator|&
name|ENINT_COALESCE
expr_stmt|;
if|if
condition|(
name|ahd
operator|->
name|cmdcmplt_total
operator|>
name|ahd
operator|->
name|int_coalescing_threshold
condition|)
name|enint_coal
operator||=
name|ENINT_COALESCE
expr_stmt|;
elseif|else
if|if
condition|(
name|ahd
operator|->
name|cmdcmplt_total
operator|<
name|ahd
operator|->
name|int_coalescing_stop_threshold
condition|)
name|enint_coal
operator|&=
operator|~
name|ENINT_COALESCE
expr_stmt|;
if|if
condition|(
name|enint_coal
operator|!=
operator|(
name|ahd
operator|->
name|hs_mailbox
operator|&
name|ENINT_COALESCE
operator|)
condition|)
block|{
name|ahd_enable_coalescing
argument_list|(
name|ahd
argument_list|,
name|enint_coal
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|AHD_DEBUG
if|if
condition|(
operator|(
name|ahd_debug
operator|&
name|AHD_SHOW_INT_COALESCING
operator|)
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|"%s: Interrupt coalescing "
literal|"now %sabled. Cmds %d\n"
argument_list|,
name|ahd_name
argument_list|(
name|ahd
argument_list|)
argument_list|,
operator|(
name|enint_coal
operator|&
name|ENINT_COALESCE
operator|)
condition|?
literal|"en"
else|:
literal|"dis"
argument_list|,
name|ahd
operator|->
name|cmdcmplt_total
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|ahd
operator|->
name|cmdcmplt_bucket
operator|=
operator|(
name|ahd
operator|->
name|cmdcmplt_bucket
operator|+
literal|1
operator|)
operator|&
operator|(
name|AHD_STAT_BUCKETS
operator|-
literal|1
operator|)
expr_stmt|;
name|ahd
operator|->
name|cmdcmplt_total
operator|-=
name|ahd
operator|->
name|cmdcmplt_counts
index|[
name|ahd
operator|->
name|cmdcmplt_bucket
index|]
expr_stmt|;
name|ahd
operator|->
name|cmdcmplt_counts
index|[
name|ahd
operator|->
name|cmdcmplt_bucket
index|]
operator|=
literal|0
expr_stmt|;
name|aic_timer_reset
argument_list|(
operator|&
name|ahd
operator|->
name|stat_timer
argument_list|,
name|AHD_STAT_UPDATE_MS
argument_list|,
name|ahd_stat_timer
argument_list|,
name|ahd
argument_list|)
expr_stmt|;
name|ahd_unlock
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/****************************** Status Processing *****************************/
end_comment

begin_function
name|void
name|ahd_handle_scb_status
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|,
name|struct
name|scb
modifier|*
name|scb
parameter_list|)
block|{
if|if
condition|(
name|scb
operator|->
name|hscb
operator|->
name|shared_data
operator|.
name|istatus
operator|.
name|scsi_status
operator|!=
literal|0
condition|)
block|{
name|ahd_handle_scsi_status
argument_list|(
name|ahd
argument_list|,
name|scb
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ahd_calc_residual
argument_list|(
name|ahd
argument_list|,
name|scb
argument_list|)
expr_stmt|;
name|ahd_done
argument_list|(
name|ahd
argument_list|,
name|scb
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|ahd_handle_scsi_status
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|,
name|struct
name|scb
modifier|*
name|scb
parameter_list|)
block|{
name|struct
name|hardware_scb
modifier|*
name|hscb
decl_stmt|;
name|int
name|paused
decl_stmt|;
comment|/* 	 * The sequencer freezes its select-out queue 	 * anytime a SCSI status error occurs.  We must 	 * handle the error and increment our qfreeze count 	 * to allow the sequencer to continue.  We don't 	 * bother clearing critical sections here since all 	 * operations are on data structures that the sequencer 	 * is not touching once the queue is frozen. 	 */
name|hscb
operator|=
name|scb
operator|->
name|hscb
expr_stmt|;
if|if
condition|(
name|ahd_is_paused
argument_list|(
name|ahd
argument_list|)
condition|)
block|{
name|paused
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|paused
operator|=
literal|0
expr_stmt|;
name|ahd_pause
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
block|}
comment|/* Freeze the queue until the client sees the error. */
name|ahd_freeze_devq
argument_list|(
name|ahd
argument_list|,
name|scb
argument_list|)
expr_stmt|;
name|aic_freeze_scb
argument_list|(
name|scb
argument_list|)
expr_stmt|;
name|ahd
operator|->
name|qfreeze_cnt
operator|++
expr_stmt|;
name|ahd_outw
argument_list|(
name|ahd
argument_list|,
name|KERNEL_QFREEZE_COUNT
argument_list|,
name|ahd
operator|->
name|qfreeze_cnt
argument_list|)
expr_stmt|;
if|if
condition|(
name|paused
operator|==
literal|0
condition|)
name|ahd_unpause
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
comment|/* Don't want to clobber the original sense code */
if|if
condition|(
operator|(
name|scb
operator|->
name|flags
operator|&
name|SCB_SENSE
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * Clear the SCB_SENSE Flag and perform 		 * a normal command completion. 		 */
name|scb
operator|->
name|flags
operator|&=
operator|~
name|SCB_SENSE
expr_stmt|;
name|aic_set_transaction_status
argument_list|(
name|scb
argument_list|,
name|CAM_AUTOSENSE_FAIL
argument_list|)
expr_stmt|;
name|ahd_done
argument_list|(
name|ahd
argument_list|,
name|scb
argument_list|)
expr_stmt|;
return|return;
block|}
name|aic_set_transaction_status
argument_list|(
name|scb
argument_list|,
name|CAM_SCSI_STATUS_ERROR
argument_list|)
expr_stmt|;
name|aic_set_scsi_status
argument_list|(
name|scb
argument_list|,
name|hscb
operator|->
name|shared_data
operator|.
name|istatus
operator|.
name|scsi_status
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|hscb
operator|->
name|shared_data
operator|.
name|istatus
operator|.
name|scsi_status
condition|)
block|{
case|case
name|STATUS_PKT_SENSE
case|:
block|{
name|struct
name|scsi_status_iu_header
modifier|*
name|siu
decl_stmt|;
name|ahd_sync_sense
argument_list|(
name|ahd
argument_list|,
name|scb
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
name|siu
operator|=
operator|(
expr|struct
name|scsi_status_iu_header
operator|*
operator|)
name|scb
operator|->
name|sense_data
expr_stmt|;
name|aic_set_scsi_status
argument_list|(
name|scb
argument_list|,
name|siu
operator|->
name|status
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|AHD_DEBUG
if|if
condition|(
operator|(
name|ahd_debug
operator|&
name|AHD_SHOW_SENSE
operator|)
operator|!=
literal|0
condition|)
block|{
name|ahd_print_path
argument_list|(
name|ahd
argument_list|,
name|scb
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"SCB 0x%x Received PKT Status of 0x%x\n"
argument_list|,
name|SCB_GET_TAG
argument_list|(
name|scb
argument_list|)
argument_list|,
name|siu
operator|->
name|status
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\tflags = 0x%x, sense len = 0x%x, "
literal|"pktfail = 0x%x\n"
argument_list|,
name|siu
operator|->
name|flags
argument_list|,
name|scsi_4btoul
argument_list|(
name|siu
operator|->
name|sense_length
argument_list|)
argument_list|,
name|scsi_4btoul
argument_list|(
name|siu
operator|->
name|pkt_failures_length
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
operator|(
name|siu
operator|->
name|flags
operator|&
name|SIU_RSPVALID
operator|)
operator|!=
literal|0
condition|)
block|{
name|ahd_print_path
argument_list|(
name|ahd
argument_list|,
name|scb
argument_list|)
expr_stmt|;
if|if
condition|(
name|scsi_4btoul
argument_list|(
name|siu
operator|->
name|pkt_failures_length
argument_list|)
operator|<
literal|4
condition|)
block|{
name|printf
argument_list|(
literal|"Unable to parse pkt_failures\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
switch|switch
condition|(
name|SIU_PKTFAIL_CODE
argument_list|(
name|siu
argument_list|)
condition|)
block|{
case|case
name|SIU_PFC_NONE
case|:
name|printf
argument_list|(
literal|"No packet failure found\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIU_PFC_CIU_FIELDS_INVALID
case|:
name|printf
argument_list|(
literal|"Invalid Command IU Field\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIU_PFC_TMF_NOT_SUPPORTED
case|:
name|printf
argument_list|(
literal|"TMF not supportd\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIU_PFC_TMF_FAILED
case|:
name|printf
argument_list|(
literal|"TMF failed\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIU_PFC_INVALID_TYPE_CODE
case|:
name|printf
argument_list|(
literal|"Invalid L_Q Type code\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIU_PFC_ILLEGAL_REQUEST
case|:
name|printf
argument_list|(
literal|"Illegal request\n"
argument_list|)
expr_stmt|;
default|default:
break|break;
block|}
block|}
if|if
condition|(
name|siu
operator|->
name|status
operator|==
name|SCSI_STATUS_OK
condition|)
name|aic_set_transaction_status
argument_list|(
name|scb
argument_list|,
name|CAM_REQ_CMP_ERR
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|siu
operator|->
name|flags
operator|&
name|SIU_SNSVALID
operator|)
operator|!=
literal|0
condition|)
block|{
name|scb
operator|->
name|flags
operator||=
name|SCB_PKT_SENSE
expr_stmt|;
ifdef|#
directive|ifdef
name|AHD_DEBUG
if|if
condition|(
operator|(
name|ahd_debug
operator|&
name|AHD_SHOW_SENSE
operator|)
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|"Sense data available\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|ahd_done
argument_list|(
name|ahd
argument_list|,
name|scb
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|SCSI_STATUS_CMD_TERMINATED
case|:
case|case
name|SCSI_STATUS_CHECK_COND
case|:
block|{
name|struct
name|ahd_devinfo
name|devinfo
decl_stmt|;
name|struct
name|ahd_dma_seg
modifier|*
name|sg
decl_stmt|;
name|struct
name|scsi_sense
modifier|*
name|sc
decl_stmt|;
name|struct
name|ahd_initiator_tinfo
modifier|*
name|targ_info
decl_stmt|;
name|struct
name|ahd_tmode_tstate
modifier|*
name|tstate
decl_stmt|;
name|struct
name|ahd_transinfo
modifier|*
name|tinfo
decl_stmt|;
ifdef|#
directive|ifdef
name|AHD_DEBUG
if|if
condition|(
name|ahd_debug
operator|&
name|AHD_SHOW_SENSE
condition|)
block|{
name|ahd_print_path
argument_list|(
name|ahd
argument_list|,
name|scb
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"SCB %d: requests Check Status\n"
argument_list|,
name|SCB_GET_TAG
argument_list|(
name|scb
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|aic_perform_autosense
argument_list|(
name|scb
argument_list|)
operator|==
literal|0
condition|)
break|break;
name|ahd_compile_devinfo
argument_list|(
operator|&
name|devinfo
argument_list|,
name|SCB_GET_OUR_ID
argument_list|(
name|scb
argument_list|)
argument_list|,
name|SCB_GET_TARGET
argument_list|(
name|ahd
argument_list|,
name|scb
argument_list|)
argument_list|,
name|SCB_GET_LUN
argument_list|(
name|scb
argument_list|)
argument_list|,
name|SCB_GET_CHANNEL
argument_list|(
name|ahd
argument_list|,
name|scb
argument_list|)
argument_list|,
name|ROLE_INITIATOR
argument_list|)
expr_stmt|;
name|targ_info
operator|=
name|ahd_fetch_transinfo
argument_list|(
name|ahd
argument_list|,
name|devinfo
operator|.
name|channel
argument_list|,
name|devinfo
operator|.
name|our_scsiid
argument_list|,
name|devinfo
operator|.
name|target
argument_list|,
operator|&
name|tstate
argument_list|)
expr_stmt|;
name|tinfo
operator|=
operator|&
name|targ_info
operator|->
name|curr
expr_stmt|;
name|sg
operator|=
name|scb
operator|->
name|sg_list
expr_stmt|;
name|sc
operator|=
operator|(
expr|struct
name|scsi_sense
operator|*
operator|)
name|hscb
operator|->
name|shared_data
operator|.
name|idata
operator|.
name|cdb
expr_stmt|;
comment|/* 		 * Save off the residual if there is one. 		 */
name|ahd_update_residual
argument_list|(
name|ahd
argument_list|,
name|scb
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|AHD_DEBUG
if|if
condition|(
name|ahd_debug
operator|&
name|AHD_SHOW_SENSE
condition|)
block|{
name|ahd_print_path
argument_list|(
name|ahd
argument_list|,
name|scb
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Sending Sense\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|scb
operator|->
name|sg_count
operator|=
literal|0
expr_stmt|;
name|sg
operator|=
name|ahd_sg_setup
argument_list|(
name|ahd
argument_list|,
name|scb
argument_list|,
name|sg
argument_list|,
name|ahd_get_sense_bufaddr
argument_list|(
name|ahd
argument_list|,
name|scb
argument_list|)
argument_list|,
name|aic_get_sense_bufsize
argument_list|(
name|ahd
argument_list|,
name|scb
argument_list|)
argument_list|,
comment|/*last*/
name|TRUE
argument_list|)
expr_stmt|;
name|sc
operator|->
name|opcode
operator|=
name|REQUEST_SENSE
expr_stmt|;
name|sc
operator|->
name|byte2
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|tinfo
operator|->
name|protocol_version
operator|<=
name|SCSI_REV_2
operator|&&
name|SCB_GET_LUN
argument_list|(
name|scb
argument_list|)
operator|<
literal|8
condition|)
name|sc
operator|->
name|byte2
operator|=
name|SCB_GET_LUN
argument_list|(
name|scb
argument_list|)
operator|<<
literal|5
expr_stmt|;
name|sc
operator|->
name|unused
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|unused
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|length
operator|=
name|aic_get_sense_bufsize
argument_list|(
name|ahd
argument_list|,
name|scb
argument_list|)
expr_stmt|;
name|sc
operator|->
name|control
operator|=
literal|0
expr_stmt|;
comment|/* 		 * We can't allow the target to disconnect. 		 * This will be an untagged transaction and 		 * having the target disconnect will make this 		 * transaction indestinguishable from outstanding 		 * tagged transactions. 		 */
name|hscb
operator|->
name|control
operator|=
literal|0
expr_stmt|;
comment|/* 		 * This request sense could be because the 		 * the device lost power or in some other 		 * way has lost our transfer negotiations. 		 * Renegotiate if appropriate.  Unit attention 		 * errors will be reported before any data 		 * phases occur. 		 */
if|if
condition|(
name|aic_get_residual
argument_list|(
name|scb
argument_list|)
operator|==
name|aic_get_transfer_length
argument_list|(
name|scb
argument_list|)
condition|)
block|{
name|ahd_update_neg_request
argument_list|(
name|ahd
argument_list|,
operator|&
name|devinfo
argument_list|,
name|tstate
argument_list|,
name|targ_info
argument_list|,
name|AHD_NEG_IF_NON_ASYNC
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tstate
operator|->
name|auto_negotiate
operator|&
name|devinfo
operator|.
name|target_mask
condition|)
block|{
name|hscb
operator|->
name|control
operator||=
name|MK_MESSAGE
expr_stmt|;
name|scb
operator|->
name|flags
operator|&=
operator|~
operator|(
name|SCB_NEGOTIATE
operator||
name|SCB_ABORT
operator||
name|SCB_DEVICE_RESET
operator|)
expr_stmt|;
name|scb
operator|->
name|flags
operator||=
name|SCB_AUTO_NEGOTIATE
expr_stmt|;
block|}
name|hscb
operator|->
name|cdb_len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|sc
argument_list|)
expr_stmt|;
name|ahd_setup_data_scb
argument_list|(
name|ahd
argument_list|,
name|scb
argument_list|)
expr_stmt|;
name|scb
operator|->
name|flags
operator||=
name|SCB_SENSE
expr_stmt|;
name|ahd_queue_scb
argument_list|(
name|ahd
argument_list|,
name|scb
argument_list|)
expr_stmt|;
comment|/* 		 * Ensure we have enough time to actually 		 * retrieve the sense, but only schedule 		 * the timer if we are not in recovery or 		 * this is a recovery SCB that is allowed 		 * to have an active timer. 		 */
if|if
condition|(
name|ahd
operator|->
name|scb_data
operator|.
name|recovery_scbs
operator|==
literal|0
operator|||
operator|(
name|scb
operator|->
name|flags
operator|&
name|SCB_RECOVERY_SCB
operator|)
operator|!=
literal|0
condition|)
name|aic_scb_timer_reset
argument_list|(
name|scb
argument_list|,
literal|5
operator|*
literal|1000
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|SCSI_STATUS_OK
case|:
name|printf
argument_list|(
literal|"%s: Interrupted for staus of 0???\n"
argument_list|,
name|ahd_name
argument_list|(
name|ahd
argument_list|)
argument_list|)
expr_stmt|;
comment|/* FALLTHROUGH */
default|default:
name|ahd_done
argument_list|(
name|ahd
argument_list|,
name|scb
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/*  * Calculate the residual for a just completed SCB.  */
end_comment

begin_function
name|void
name|ahd_calc_residual
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|,
name|struct
name|scb
modifier|*
name|scb
parameter_list|)
block|{
name|struct
name|hardware_scb
modifier|*
name|hscb
decl_stmt|;
name|struct
name|initiator_status
modifier|*
name|spkt
decl_stmt|;
name|uint32_t
name|sgptr
decl_stmt|;
name|uint32_t
name|resid_sgptr
decl_stmt|;
name|uint32_t
name|resid
decl_stmt|;
comment|/* 	 * 5 cases. 	 * 1) No residual. 	 *    SG_STATUS_VALID clear in sgptr. 	 * 2) Transferless command 	 * 3) Never performed any transfers. 	 *    sgptr has SG_FULL_RESID set. 	 * 4) No residual but target did not 	 *    save data pointers after the 	 *    last transfer, so sgptr was 	 *    never updated. 	 * 5) We have a partial residual. 	 *    Use residual_sgptr to determine 	 *    where we are. 	 */
name|hscb
operator|=
name|scb
operator|->
name|hscb
expr_stmt|;
name|sgptr
operator|=
name|aic_le32toh
argument_list|(
name|hscb
operator|->
name|sgptr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sgptr
operator|&
name|SG_STATUS_VALID
operator|)
operator|==
literal|0
condition|)
comment|/* Case 1 */
return|return;
name|sgptr
operator|&=
operator|~
name|SG_STATUS_VALID
expr_stmt|;
if|if
condition|(
operator|(
name|sgptr
operator|&
name|SG_LIST_NULL
operator|)
operator|!=
literal|0
condition|)
comment|/* Case 2 */
return|return;
comment|/* 	 * Residual fields are the same in both 	 * target and initiator status packets, 	 * so we can always use the initiator fields 	 * regardless of the role for this SCB. 	 */
name|spkt
operator|=
operator|&
name|hscb
operator|->
name|shared_data
operator|.
name|istatus
expr_stmt|;
name|resid_sgptr
operator|=
name|aic_le32toh
argument_list|(
name|spkt
operator|->
name|residual_sgptr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sgptr
operator|&
name|SG_FULL_RESID
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* Case 3 */
name|resid
operator|=
name|aic_get_transfer_length
argument_list|(
name|scb
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|resid_sgptr
operator|&
name|SG_LIST_NULL
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* Case 4 */
return|return;
block|}
elseif|else
if|if
condition|(
operator|(
name|resid_sgptr
operator|&
name|SG_OVERRUN_RESID
operator|)
operator|!=
literal|0
condition|)
block|{
name|ahd_print_path
argument_list|(
name|ahd
argument_list|,
name|scb
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"data overrun detected Tag == 0x%x.\n"
argument_list|,
name|SCB_GET_TAG
argument_list|(
name|scb
argument_list|)
argument_list|)
expr_stmt|;
name|ahd_freeze_devq
argument_list|(
name|ahd
argument_list|,
name|scb
argument_list|)
expr_stmt|;
name|aic_set_transaction_status
argument_list|(
name|scb
argument_list|,
name|CAM_DATA_RUN_ERR
argument_list|)
expr_stmt|;
name|aic_freeze_scb
argument_list|(
name|scb
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
operator|(
name|resid_sgptr
operator|&
operator|~
name|SG_PTR_MASK
operator|)
operator|!=
literal|0
condition|)
block|{
name|panic
argument_list|(
literal|"Bogus resid sgptr value 0x%x\n"
argument_list|,
name|resid_sgptr
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
else|else
block|{
name|struct
name|ahd_dma_seg
modifier|*
name|sg
decl_stmt|;
comment|/* 		 * Remainder of the SG where the transfer 		 * stopped.   		 */
name|resid
operator|=
name|aic_le32toh
argument_list|(
name|spkt
operator|->
name|residual_datacnt
argument_list|)
operator|&
name|AHD_SG_LEN_MASK
expr_stmt|;
name|sg
operator|=
name|ahd_sg_bus_to_virt
argument_list|(
name|ahd
argument_list|,
name|scb
argument_list|,
name|resid_sgptr
operator|&
name|SG_PTR_MASK
argument_list|)
expr_stmt|;
comment|/* The residual sg_ptr always points to the next sg */
name|sg
operator|--
expr_stmt|;
comment|/* 		 * Add up the contents of all residual 		 * SG segments that are after the SG where 		 * the transfer stopped. 		 */
while|while
condition|(
operator|(
name|aic_le32toh
argument_list|(
name|sg
operator|->
name|len
argument_list|)
operator|&
name|AHD_DMA_LAST_SEG
operator|)
operator|==
literal|0
condition|)
block|{
name|sg
operator|++
expr_stmt|;
name|resid
operator|+=
name|aic_le32toh
argument_list|(
name|sg
operator|->
name|len
argument_list|)
operator|&
name|AHD_SG_LEN_MASK
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|scb
operator|->
name|flags
operator|&
name|SCB_SENSE
operator|)
operator|==
literal|0
condition|)
name|aic_set_residual
argument_list|(
name|scb
argument_list|,
name|resid
argument_list|)
expr_stmt|;
else|else
name|aic_set_sense_residual
argument_list|(
name|scb
argument_list|,
name|resid
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|AHD_DEBUG
if|if
condition|(
operator|(
name|ahd_debug
operator|&
name|AHD_SHOW_MISC
operator|)
operator|!=
literal|0
condition|)
block|{
name|ahd_print_path
argument_list|(
name|ahd
argument_list|,
name|scb
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Handled %sResidual of %d bytes\n"
argument_list|,
operator|(
name|scb
operator|->
name|flags
operator|&
name|SCB_SENSE
operator|)
condition|?
literal|"Sense "
else|:
literal|""
argument_list|,
name|resid
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/******************************* Target Mode **********************************/
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|AHD_TARGET_MODE
end_ifdef

begin_comment
comment|/*  * Add a target mode event to this lun's queue  */
end_comment

begin_function
specifier|static
name|void
name|ahd_queue_lstate_event
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|,
name|struct
name|ahd_tmode_lstate
modifier|*
name|lstate
parameter_list|,
name|u_int
name|initiator_id
parameter_list|,
name|u_int
name|event_type
parameter_list|,
name|u_int
name|event_arg
parameter_list|)
block|{
name|struct
name|ahd_tmode_event
modifier|*
name|event
decl_stmt|;
name|int
name|pending
decl_stmt|;
name|xpt_freeze_devq
argument_list|(
name|lstate
operator|->
name|path
argument_list|,
comment|/*count*/
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|lstate
operator|->
name|event_w_idx
operator|>=
name|lstate
operator|->
name|event_r_idx
condition|)
name|pending
operator|=
name|lstate
operator|->
name|event_w_idx
operator|-
name|lstate
operator|->
name|event_r_idx
expr_stmt|;
else|else
name|pending
operator|=
name|AHD_TMODE_EVENT_BUFFER_SIZE
operator|+
literal|1
operator|-
operator|(
name|lstate
operator|->
name|event_r_idx
operator|-
name|lstate
operator|->
name|event_w_idx
operator|)
expr_stmt|;
if|if
condition|(
name|event_type
operator|==
name|EVENT_TYPE_BUS_RESET
operator|||
name|event_type
operator|==
name|MSG_BUS_DEV_RESET
condition|)
block|{
comment|/* 		 * Any earlier events are irrelevant, so reset our buffer. 		 * This has the effect of allowing us to deal with reset 		 * floods (an external device holding down the reset line) 		 * without losing the event that is really interesting. 		 */
name|lstate
operator|->
name|event_r_idx
operator|=
literal|0
expr_stmt|;
name|lstate
operator|->
name|event_w_idx
operator|=
literal|0
expr_stmt|;
name|xpt_release_devq
argument_list|(
name|lstate
operator|->
name|path
argument_list|,
name|pending
argument_list|,
comment|/*runqueue*/
name|FALSE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pending
operator|==
name|AHD_TMODE_EVENT_BUFFER_SIZE
condition|)
block|{
name|xpt_print_path
argument_list|(
name|lstate
operator|->
name|path
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"immediate event %x:%x lost\n"
argument_list|,
name|lstate
operator|->
name|event_buffer
index|[
name|lstate
operator|->
name|event_r_idx
index|]
operator|.
name|event_type
argument_list|,
name|lstate
operator|->
name|event_buffer
index|[
name|lstate
operator|->
name|event_r_idx
index|]
operator|.
name|event_arg
argument_list|)
expr_stmt|;
name|lstate
operator|->
name|event_r_idx
operator|++
expr_stmt|;
if|if
condition|(
name|lstate
operator|->
name|event_r_idx
operator|==
name|AHD_TMODE_EVENT_BUFFER_SIZE
condition|)
name|lstate
operator|->
name|event_r_idx
operator|=
literal|0
expr_stmt|;
name|xpt_release_devq
argument_list|(
name|lstate
operator|->
name|path
argument_list|,
comment|/*count*/
literal|1
argument_list|,
comment|/*runqueue*/
name|FALSE
argument_list|)
expr_stmt|;
block|}
name|event
operator|=
operator|&
name|lstate
operator|->
name|event_buffer
index|[
name|lstate
operator|->
name|event_w_idx
index|]
expr_stmt|;
name|event
operator|->
name|initiator_id
operator|=
name|initiator_id
expr_stmt|;
name|event
operator|->
name|event_type
operator|=
name|event_type
expr_stmt|;
name|event
operator|->
name|event_arg
operator|=
name|event_arg
expr_stmt|;
name|lstate
operator|->
name|event_w_idx
operator|++
expr_stmt|;
if|if
condition|(
name|lstate
operator|->
name|event_w_idx
operator|==
name|AHD_TMODE_EVENT_BUFFER_SIZE
condition|)
name|lstate
operator|->
name|event_w_idx
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Send any target mode events queued up waiting  * for immediate notify resources.  */
end_comment

begin_function
name|void
name|ahd_send_lstate_events
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|,
name|struct
name|ahd_tmode_lstate
modifier|*
name|lstate
parameter_list|)
block|{
name|struct
name|ccb_hdr
modifier|*
name|ccbh
decl_stmt|;
name|struct
name|ccb_immed_notify
modifier|*
name|inot
decl_stmt|;
while|while
condition|(
name|lstate
operator|->
name|event_r_idx
operator|!=
name|lstate
operator|->
name|event_w_idx
operator|&&
operator|(
name|ccbh
operator|=
name|SLIST_FIRST
argument_list|(
operator|&
name|lstate
operator|->
name|immed_notifies
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|struct
name|ahd_tmode_event
modifier|*
name|event
decl_stmt|;
name|event
operator|=
operator|&
name|lstate
operator|->
name|event_buffer
index|[
name|lstate
operator|->
name|event_r_idx
index|]
expr_stmt|;
name|SLIST_REMOVE_HEAD
argument_list|(
operator|&
name|lstate
operator|->
name|immed_notifies
argument_list|,
name|sim_links
operator|.
name|sle
argument_list|)
expr_stmt|;
name|inot
operator|=
operator|(
expr|struct
name|ccb_immed_notify
operator|*
operator|)
name|ccbh
expr_stmt|;
switch|switch
condition|(
name|event
operator|->
name|event_type
condition|)
block|{
case|case
name|EVENT_TYPE_BUS_RESET
case|:
name|ccbh
operator|->
name|status
operator|=
name|CAM_SCSI_BUS_RESET
operator||
name|CAM_DEV_QFRZN
expr_stmt|;
break|break;
default|default:
name|ccbh
operator|->
name|status
operator|=
name|CAM_MESSAGE_RECV
operator||
name|CAM_DEV_QFRZN
expr_stmt|;
name|inot
operator|->
name|message_args
index|[
literal|0
index|]
operator|=
name|event
operator|->
name|event_type
expr_stmt|;
name|inot
operator|->
name|message_args
index|[
literal|1
index|]
operator|=
name|event
operator|->
name|event_arg
expr_stmt|;
break|break;
block|}
name|inot
operator|->
name|initiator_id
operator|=
name|event
operator|->
name|initiator_id
expr_stmt|;
name|inot
operator|->
name|sense_len
operator|=
literal|0
expr_stmt|;
name|xpt_done
argument_list|(
operator|(
expr|union
name|ccb
operator|*
operator|)
name|inot
argument_list|)
expr_stmt|;
name|lstate
operator|->
name|event_r_idx
operator|++
expr_stmt|;
if|if
condition|(
name|lstate
operator|->
name|event_r_idx
operator|==
name|AHD_TMODE_EVENT_BUFFER_SIZE
condition|)
name|lstate
operator|->
name|event_r_idx
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/******************** Sequencer Program Patching/Download *********************/
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|AHD_DUMP_SEQ
end_ifdef

begin_function
name|void
name|ahd_dumpseq
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|max_prog
decl_stmt|;
name|max_prog
operator|=
literal|2048
expr_stmt|;
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|SEQCTL0
argument_list|,
name|PERRORDIS
operator||
name|FAILDIS
operator||
name|FASTMODE
operator||
name|LOADRAM
argument_list|)
expr_stmt|;
name|ahd_outw
argument_list|(
name|ahd
argument_list|,
name|PRGMCNT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|max_prog
condition|;
name|i
operator|++
control|)
block|{
name|uint8_t
name|ins_bytes
index|[
literal|4
index|]
decl_stmt|;
name|ahd_insb
argument_list|(
name|ahd
argument_list|,
name|SEQRAM
argument_list|,
name|ins_bytes
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"0x%08x\n"
argument_list|,
name|ins_bytes
index|[
literal|0
index|]
operator|<<
literal|24
operator||
name|ins_bytes
index|[
literal|1
index|]
operator|<<
literal|16
operator||
name|ins_bytes
index|[
literal|2
index|]
operator|<<
literal|8
operator||
name|ins_bytes
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|ahd_loadseq
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|)
block|{
name|struct
name|cs
name|cs_table
index|[
name|num_critical_sections
index|]
decl_stmt|;
name|u_int
name|begin_set
index|[
name|num_critical_sections
index|]
decl_stmt|;
name|u_int
name|end_set
index|[
name|num_critical_sections
index|]
decl_stmt|;
name|struct
name|patch
modifier|*
name|cur_patch
decl_stmt|;
name|u_int
name|cs_count
decl_stmt|;
name|u_int
name|cur_cs
decl_stmt|;
name|u_int
name|i
decl_stmt|;
name|int
name|downloaded
decl_stmt|;
name|u_int
name|skip_addr
decl_stmt|;
name|u_int
name|sg_prefetch_cnt
decl_stmt|;
name|u_int
name|sg_prefetch_cnt_limit
decl_stmt|;
name|u_int
name|sg_prefetch_align
decl_stmt|;
name|u_int
name|sg_size
decl_stmt|;
name|u_int
name|cacheline_mask
decl_stmt|;
name|uint8_t
name|download_consts
index|[
name|DOWNLOAD_CONST_COUNT
index|]
decl_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"%s: Downloading Sequencer Program..."
argument_list|,
name|ahd_name
argument_list|(
name|ahd
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
name|DOWNLOAD_CONST_COUNT
operator|!=
literal|8
error|#
directive|error
literal|"Download Const Mismatch"
endif|#
directive|endif
comment|/* 	 * Start out with 0 critical sections 	 * that apply to this firmware load. 	 */
name|cs_count
operator|=
literal|0
expr_stmt|;
name|cur_cs
operator|=
literal|0
expr_stmt|;
name|memset
argument_list|(
name|begin_set
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|begin_set
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|end_set
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|end_set
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Setup downloadable constant table. 	 *  	 * The computation for the S/G prefetch variables is 	 * a bit complicated.  We would like to always fetch 	 * in terms of cachelined sized increments.  However, 	 * if the cacheline is not an even multiple of the 	 * SG element size or is larger than our SG RAM, using 	 * just the cache size might leave us with only a portion 	 * of an SG element at the tail of a prefetch.  If the 	 * cacheline is larger than our S/G prefetch buffer less 	 * the size of an SG element, we may round down to a cacheline 	 * that doesn't contain any or all of the S/G of interest 	 * within the bounds of our S/G ram.  Provide variables to 	 * the sequencer that will allow it to handle these edge 	 * cases. 	 */
comment|/* Start by aligning to the nearest cacheline. */
name|sg_prefetch_align
operator|=
name|ahd
operator|->
name|pci_cachesize
expr_stmt|;
if|if
condition|(
name|sg_prefetch_align
operator|==
literal|0
condition|)
name|sg_prefetch_align
operator|=
literal|8
expr_stmt|;
comment|/* Round down to the nearest power of 2. */
while|while
condition|(
name|powerof2
argument_list|(
name|sg_prefetch_align
argument_list|)
operator|==
literal|0
condition|)
name|sg_prefetch_align
operator|--
expr_stmt|;
name|cacheline_mask
operator|=
name|sg_prefetch_align
operator|-
literal|1
expr_stmt|;
comment|/* 	 * If the cacheline boundary is greater than half our prefetch RAM 	 * we risk not being able to fetch even a single complete S/G 	 * segment if we align to that boundary. 	 */
if|if
condition|(
name|sg_prefetch_align
operator|>
name|CCSGADDR_MAX
operator|/
literal|2
condition|)
name|sg_prefetch_align
operator|=
name|CCSGADDR_MAX
operator|/
literal|2
expr_stmt|;
comment|/* Start by fetching a single cacheline. */
name|sg_prefetch_cnt
operator|=
name|sg_prefetch_align
expr_stmt|;
comment|/* 	 * Increment the prefetch count by cachelines until 	 * at least one S/G element will fit. 	 */
name|sg_size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ahd_dma_seg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ahd
operator|->
name|flags
operator|&
name|AHD_64BIT_ADDRESSING
operator|)
operator|!=
literal|0
condition|)
name|sg_size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ahd_dma64_seg
argument_list|)
expr_stmt|;
while|while
condition|(
name|sg_prefetch_cnt
operator|<
name|sg_size
condition|)
name|sg_prefetch_cnt
operator|+=
name|sg_prefetch_align
expr_stmt|;
comment|/* 	 * If the cacheline is not an even multiple of 	 * the S/G size, we may only get a partial S/G when 	 * we align. Add a cacheline if this is the case. 	 */
if|if
condition|(
operator|(
name|sg_prefetch_align
operator|%
name|sg_size
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|sg_prefetch_cnt
operator|<
name|CCSGADDR_MAX
operator|)
condition|)
name|sg_prefetch_cnt
operator|+=
name|sg_prefetch_align
expr_stmt|;
comment|/* 	 * Lastly, compute a value that the sequencer can use 	 * to determine if the remainder of the CCSGRAM buffer 	 * has a full S/G element in it. 	 */
name|sg_prefetch_cnt_limit
operator|=
operator|-
operator|(
name|sg_prefetch_cnt
operator|-
name|sg_size
operator|+
literal|1
operator|)
expr_stmt|;
name|download_consts
index|[
name|SG_PREFETCH_CNT
index|]
operator|=
name|sg_prefetch_cnt
expr_stmt|;
name|download_consts
index|[
name|SG_PREFETCH_CNT_LIMIT
index|]
operator|=
name|sg_prefetch_cnt_limit
expr_stmt|;
name|download_consts
index|[
name|SG_PREFETCH_ALIGN_MASK
index|]
operator|=
operator|~
operator|(
name|sg_prefetch_align
operator|-
literal|1
operator|)
expr_stmt|;
name|download_consts
index|[
name|SG_PREFETCH_ADDR_MASK
index|]
operator|=
operator|(
name|sg_prefetch_align
operator|-
literal|1
operator|)
expr_stmt|;
name|download_consts
index|[
name|SG_SIZEOF
index|]
operator|=
name|sg_size
expr_stmt|;
name|download_consts
index|[
name|PKT_OVERRUN_BUFOFFSET
index|]
operator|=
operator|(
name|ahd
operator|->
name|overrun_buf
operator|-
operator|(
name|uint8_t
operator|*
operator|)
name|ahd
operator|->
name|qoutfifo
operator|)
operator|/
literal|256
expr_stmt|;
name|download_consts
index|[
name|SCB_TRANSFER_SIZE
index|]
operator|=
name|SCB_TRANSFER_SIZE_1BYTE_LUN
expr_stmt|;
name|download_consts
index|[
name|CACHELINE_MASK
index|]
operator|=
name|cacheline_mask
expr_stmt|;
name|cur_patch
operator|=
name|patches
expr_stmt|;
name|downloaded
operator|=
literal|0
expr_stmt|;
name|skip_addr
operator|=
literal|0
expr_stmt|;
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|SEQCTL0
argument_list|,
name|PERRORDIS
operator||
name|FAILDIS
operator||
name|FASTMODE
operator||
name|LOADRAM
argument_list|)
expr_stmt|;
name|ahd_outw
argument_list|(
name|ahd
argument_list|,
name|PRGMCNT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|seqprog
argument_list|)
operator|/
literal|4
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ahd_check_patch
argument_list|(
name|ahd
argument_list|,
operator|&
name|cur_patch
argument_list|,
name|i
argument_list|,
operator|&
name|skip_addr
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* 			 * Don't download this instruction as it 			 * is in a patch that was removed. 			 */
continue|continue;
block|}
comment|/* 		 * Move through the CS table until we find a CS 		 * that might apply to this instruction. 		 */
for|for
control|(
init|;
name|cur_cs
operator|<
name|num_critical_sections
condition|;
name|cur_cs
operator|++
control|)
block|{
if|if
condition|(
name|critical_sections
index|[
name|cur_cs
index|]
operator|.
name|end
operator|<=
name|i
condition|)
block|{
if|if
condition|(
name|begin_set
index|[
name|cs_count
index|]
operator|==
name|TRUE
operator|&&
name|end_set
index|[
name|cs_count
index|]
operator|==
name|FALSE
condition|)
block|{
name|cs_table
index|[
name|cs_count
index|]
operator|.
name|end
operator|=
name|downloaded
expr_stmt|;
name|end_set
index|[
name|cs_count
index|]
operator|=
name|TRUE
expr_stmt|;
name|cs_count
operator|++
expr_stmt|;
block|}
continue|continue;
block|}
if|if
condition|(
name|critical_sections
index|[
name|cur_cs
index|]
operator|.
name|begin
operator|<=
name|i
operator|&&
name|begin_set
index|[
name|cs_count
index|]
operator|==
name|FALSE
condition|)
block|{
name|cs_table
index|[
name|cs_count
index|]
operator|.
name|begin
operator|=
name|downloaded
expr_stmt|;
name|begin_set
index|[
name|cs_count
index|]
operator|=
name|TRUE
expr_stmt|;
block|}
break|break;
block|}
name|ahd_download_instr
argument_list|(
name|ahd
argument_list|,
name|i
argument_list|,
name|download_consts
argument_list|)
expr_stmt|;
name|downloaded
operator|++
expr_stmt|;
block|}
name|ahd
operator|->
name|num_critical_sections
operator|=
name|cs_count
expr_stmt|;
if|if
condition|(
name|cs_count
operator|!=
literal|0
condition|)
block|{
name|cs_count
operator|*=
sizeof|sizeof
argument_list|(
expr|struct
name|cs
argument_list|)
expr_stmt|;
name|ahd
operator|->
name|critical_sections
operator|=
name|malloc
argument_list|(
name|cs_count
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|ahd
operator|->
name|critical_sections
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"ahd_loadseq: Could not malloc"
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|ahd
operator|->
name|critical_sections
argument_list|,
name|cs_table
argument_list|,
name|cs_count
argument_list|)
expr_stmt|;
block|}
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|SEQCTL0
argument_list|,
name|PERRORDIS
operator||
name|FAILDIS
operator||
name|FASTMODE
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
block|{
name|printf
argument_list|(
literal|" %d instructions downloaded\n"
argument_list|,
name|downloaded
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s: Features 0x%x, Bugs 0x%x, Flags 0x%x\n"
argument_list|,
name|ahd_name
argument_list|(
name|ahd
argument_list|)
argument_list|,
name|ahd
operator|->
name|features
argument_list|,
name|ahd
operator|->
name|bugs
argument_list|,
name|ahd
operator|->
name|flags
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|ahd_check_patch
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|,
name|struct
name|patch
modifier|*
modifier|*
name|start_patch
parameter_list|,
name|u_int
name|start_instr
parameter_list|,
name|u_int
modifier|*
name|skip_addr
parameter_list|)
block|{
name|struct
name|patch
modifier|*
name|cur_patch
decl_stmt|;
name|struct
name|patch
modifier|*
name|last_patch
decl_stmt|;
name|u_int
name|num_patches
decl_stmt|;
name|num_patches
operator|=
sizeof|sizeof
argument_list|(
name|patches
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|patch
argument_list|)
expr_stmt|;
name|last_patch
operator|=
operator|&
name|patches
index|[
name|num_patches
index|]
expr_stmt|;
name|cur_patch
operator|=
operator|*
name|start_patch
expr_stmt|;
while|while
condition|(
name|cur_patch
operator|<
name|last_patch
operator|&&
name|start_instr
operator|==
name|cur_patch
operator|->
name|begin
condition|)
block|{
if|if
condition|(
name|cur_patch
operator|->
name|patch_func
argument_list|(
name|ahd
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Start rejecting code */
operator|*
name|skip_addr
operator|=
name|start_instr
operator|+
name|cur_patch
operator|->
name|skip_instr
expr_stmt|;
name|cur_patch
operator|+=
name|cur_patch
operator|->
name|skip_patch
expr_stmt|;
block|}
else|else
block|{
comment|/* Accepted this patch.  Advance to the next 			 * one and wait for our intruction pointer to 			 * hit this point. 			 */
name|cur_patch
operator|++
expr_stmt|;
block|}
block|}
operator|*
name|start_patch
operator|=
name|cur_patch
expr_stmt|;
if|if
condition|(
name|start_instr
operator|<
operator|*
name|skip_addr
condition|)
comment|/* Still skipping */
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|u_int
name|ahd_resolve_seqaddr
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|,
name|u_int
name|address
parameter_list|)
block|{
name|struct
name|patch
modifier|*
name|cur_patch
decl_stmt|;
name|int
name|address_offset
decl_stmt|;
name|u_int
name|skip_addr
decl_stmt|;
name|u_int
name|i
decl_stmt|;
name|address_offset
operator|=
literal|0
expr_stmt|;
name|cur_patch
operator|=
name|patches
expr_stmt|;
name|skip_addr
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|address
condition|;
control|)
block|{
name|ahd_check_patch
argument_list|(
name|ahd
argument_list|,
operator|&
name|cur_patch
argument_list|,
name|i
argument_list|,
operator|&
name|skip_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|skip_addr
operator|>
name|i
condition|)
block|{
name|int
name|end_addr
decl_stmt|;
name|end_addr
operator|=
name|MIN
argument_list|(
name|address
argument_list|,
name|skip_addr
argument_list|)
expr_stmt|;
name|address_offset
operator|+=
name|end_addr
operator|-
name|i
expr_stmt|;
name|i
operator|=
name|skip_addr
expr_stmt|;
block|}
else|else
block|{
name|i
operator|++
expr_stmt|;
block|}
block|}
return|return
operator|(
name|address
operator|-
name|address_offset
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ahd_download_instr
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|,
name|u_int
name|instrptr
parameter_list|,
name|uint8_t
modifier|*
name|dconsts
parameter_list|)
block|{
name|union
name|ins_formats
name|instr
decl_stmt|;
name|struct
name|ins_format1
modifier|*
name|fmt1_ins
decl_stmt|;
name|struct
name|ins_format3
modifier|*
name|fmt3_ins
decl_stmt|;
name|u_int
name|opcode
decl_stmt|;
comment|/* 	 * The firmware is always compiled into a little endian format. 	 */
name|instr
operator|.
name|integer
operator|=
name|aic_le32toh
argument_list|(
operator|*
operator|(
name|uint32_t
operator|*
operator|)
operator|&
name|seqprog
index|[
name|instrptr
operator|*
literal|4
index|]
argument_list|)
expr_stmt|;
name|fmt1_ins
operator|=
operator|&
name|instr
operator|.
name|format1
expr_stmt|;
name|fmt3_ins
operator|=
name|NULL
expr_stmt|;
comment|/* Pull the opcode */
name|opcode
operator|=
name|instr
operator|.
name|format1
operator|.
name|opcode
expr_stmt|;
switch|switch
condition|(
name|opcode
condition|)
block|{
case|case
name|AIC_OP_JMP
case|:
case|case
name|AIC_OP_JC
case|:
case|case
name|AIC_OP_JNC
case|:
case|case
name|AIC_OP_CALL
case|:
case|case
name|AIC_OP_JNE
case|:
case|case
name|AIC_OP_JNZ
case|:
case|case
name|AIC_OP_JE
case|:
case|case
name|AIC_OP_JZ
case|:
block|{
name|fmt3_ins
operator|=
operator|&
name|instr
operator|.
name|format3
expr_stmt|;
name|fmt3_ins
operator|->
name|address
operator|=
name|ahd_resolve_seqaddr
argument_list|(
name|ahd
argument_list|,
name|fmt3_ins
operator|->
name|address
argument_list|)
expr_stmt|;
comment|/* FALLTHROUGH */
block|}
case|case
name|AIC_OP_OR
case|:
case|case
name|AIC_OP_AND
case|:
case|case
name|AIC_OP_XOR
case|:
case|case
name|AIC_OP_ADD
case|:
case|case
name|AIC_OP_ADC
case|:
case|case
name|AIC_OP_BMOV
case|:
if|if
condition|(
name|fmt1_ins
operator|->
name|parity
operator|!=
literal|0
condition|)
block|{
name|fmt1_ins
operator|->
name|immediate
operator|=
name|dconsts
index|[
name|fmt1_ins
operator|->
name|immediate
index|]
expr_stmt|;
block|}
name|fmt1_ins
operator|->
name|parity
operator|=
literal|0
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
name|AIC_OP_ROL
case|:
block|{
name|int
name|i
decl_stmt|,
name|count
decl_stmt|;
comment|/* Calculate odd parity for the instruction */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|count
operator|=
literal|0
init|;
name|i
operator|<
literal|31
condition|;
name|i
operator|++
control|)
block|{
name|uint32_t
name|mask
decl_stmt|;
name|mask
operator|=
literal|0x01
operator|<<
name|i
expr_stmt|;
if|if
condition|(
operator|(
name|instr
operator|.
name|integer
operator|&
name|mask
operator|)
operator|!=
literal|0
condition|)
name|count
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|count
operator|&
literal|0x01
operator|)
operator|==
literal|0
condition|)
name|instr
operator|.
name|format1
operator|.
name|parity
operator|=
literal|1
expr_stmt|;
comment|/* The sequencer is a little endian cpu */
name|instr
operator|.
name|integer
operator|=
name|aic_htole32
argument_list|(
name|instr
operator|.
name|integer
argument_list|)
expr_stmt|;
name|ahd_outsb
argument_list|(
name|ahd
argument_list|,
name|SEQRAM
argument_list|,
name|instr
operator|.
name|bytes
argument_list|,
literal|4
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
name|panic
argument_list|(
literal|"Unknown opcode encountered in seq program"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|ahd_probe_stack_size
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|)
block|{
name|int
name|last_probe
decl_stmt|;
name|last_probe
operator|=
literal|0
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|int
name|i
decl_stmt|;
comment|/* 		 * We avoid using 0 as a pattern to avoid 		 * confusion if the stack implementation 		 * "back-fills" with zeros when "poping' 		 * entries. 		 */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|last_probe
operator|+
literal|1
condition|;
name|i
operator|++
control|)
block|{
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|STACK
argument_list|,
name|i
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|STACK
argument_list|,
operator|(
name|i
operator|>>
literal|8
operator|)
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
block|}
comment|/* Verify */
for|for
control|(
name|i
operator|=
name|last_probe
operator|+
literal|1
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|u_int
name|stack_entry
decl_stmt|;
name|stack_entry
operator|=
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|STACK
argument_list|)
operator||
operator|(
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|STACK
argument_list|)
operator|<<
literal|8
operator|)
expr_stmt|;
if|if
condition|(
name|stack_entry
operator|!=
name|i
condition|)
goto|goto
name|sized
goto|;
block|}
name|last_probe
operator|++
expr_stmt|;
block|}
name|sized
label|:
return|return
operator|(
name|last_probe
operator|)
return|;
block|}
end_function

begin_function
name|void
name|ahd_dump_all_cards_state
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|ahd_softc
modifier|*
name|list_ahd
decl_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|list_ahd
argument_list|,
argument|&ahd_tailq
argument_list|,
argument|links
argument_list|)
block|{
name|ahd_dump_card_state
argument_list|(
name|list_ahd
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|ahd_print_register
parameter_list|(
name|ahd_reg_parse_entry_t
modifier|*
name|table
parameter_list|,
name|u_int
name|num_entries
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|u_int
name|address
parameter_list|,
name|u_int
name|value
parameter_list|,
name|u_int
modifier|*
name|cur_column
parameter_list|,
name|u_int
name|wrap_point
parameter_list|)
block|{
name|int
name|printed
decl_stmt|;
name|u_int
name|printed_mask
decl_stmt|;
name|u_int
name|dummy_column
decl_stmt|;
if|if
condition|(
name|cur_column
operator|==
name|NULL
condition|)
block|{
name|dummy_column
operator|=
literal|0
expr_stmt|;
name|cur_column
operator|=
operator|&
name|dummy_column
expr_stmt|;
block|}
if|if
condition|(
name|cur_column
operator|!=
name|NULL
operator|&&
operator|*
name|cur_column
operator|>=
name|wrap_point
condition|)
block|{
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
operator|*
name|cur_column
operator|=
literal|0
expr_stmt|;
block|}
name|printed
operator|=
name|printf
argument_list|(
literal|"%s[0x%x]"
argument_list|,
name|name
argument_list|,
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|table
operator|==
name|NULL
condition|)
block|{
name|printed
operator|+=
name|printf
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
operator|*
name|cur_column
operator|+=
name|printed
expr_stmt|;
return|return
operator|(
name|printed
operator|)
return|;
block|}
name|printed_mask
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|printed_mask
operator|!=
literal|0xFF
condition|)
block|{
name|int
name|entry
decl_stmt|;
for|for
control|(
name|entry
operator|=
literal|0
init|;
name|entry
operator|<
name|num_entries
condition|;
name|entry
operator|++
control|)
block|{
if|if
condition|(
operator|(
operator|(
name|value
operator|&
name|table
index|[
name|entry
index|]
operator|.
name|mask
operator|)
operator|!=
name|table
index|[
name|entry
index|]
operator|.
name|value
operator|)
operator|||
operator|(
operator|(
name|printed_mask
operator|&
name|table
index|[
name|entry
index|]
operator|.
name|mask
operator|)
operator|==
name|table
index|[
name|entry
index|]
operator|.
name|mask
operator|)
condition|)
continue|continue;
name|printed
operator|+=
name|printf
argument_list|(
literal|"%s%s"
argument_list|,
name|printed_mask
operator|==
literal|0
condition|?
literal|":("
else|:
literal|"|"
argument_list|,
name|table
index|[
name|entry
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
name|printed_mask
operator||=
name|table
index|[
name|entry
index|]
operator|.
name|mask
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|entry
operator|>=
name|num_entries
condition|)
break|break;
block|}
if|if
condition|(
name|printed_mask
operator|!=
literal|0
condition|)
name|printed
operator|+=
name|printf
argument_list|(
literal|") "
argument_list|)
expr_stmt|;
else|else
name|printed
operator|+=
name|printf
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
operator|*
name|cur_column
operator|+=
name|printed
expr_stmt|;
return|return
operator|(
name|printed
operator|)
return|;
block|}
end_function

begin_function
name|void
name|ahd_dump_card_state
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|)
block|{
name|struct
name|scb
modifier|*
name|scb
decl_stmt|;
name|ahd_mode_state
name|saved_modes
decl_stmt|;
name|u_int
name|dffstat
decl_stmt|;
name|int
name|paused
decl_stmt|;
name|u_int
name|scb_index
decl_stmt|;
name|u_int
name|saved_scb_index
decl_stmt|;
name|u_int
name|cur_col
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|ahd_is_paused
argument_list|(
name|ahd
argument_list|)
condition|)
block|{
name|paused
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|paused
operator|=
literal|0
expr_stmt|;
name|ahd_pause
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
block|}
name|saved_modes
operator|=
name|ahd_save_modes
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
name|ahd_set_modes
argument_list|(
name|ahd
argument_list|,
name|AHD_MODE_SCSI
argument_list|,
name|AHD_MODE_SCSI
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|">>>>>>>>>>>>>>>>>> Dump Card State Begins<<<<<<<<<<<<<<<<<\n"
literal|"%s: Dumping Card State at program address 0x%x Mode 0x%x\n"
argument_list|,
name|ahd_name
argument_list|(
name|ahd
argument_list|)
argument_list|,
name|ahd_inw
argument_list|(
name|ahd
argument_list|,
name|CURADDR
argument_list|)
argument_list|,
name|ahd_build_mode_state
argument_list|(
name|ahd
argument_list|,
name|ahd
operator|->
name|saved_src_mode
argument_list|,
name|ahd
operator|->
name|saved_dst_mode
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|paused
condition|)
name|printf
argument_list|(
literal|"Card was paused\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ahd_check_cmdcmpltqueues
argument_list|(
name|ahd
argument_list|)
condition|)
name|printf
argument_list|(
literal|"Completions are pending\n"
argument_list|)
expr_stmt|;
comment|/* 	 * Mode independent registers. 	 */
name|cur_col
operator|=
literal|0
expr_stmt|;
name|ahd_intstat_print
argument_list|(
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|INTSTAT
argument_list|)
argument_list|,
operator|&
name|cur_col
argument_list|,
literal|50
argument_list|)
expr_stmt|;
name|ahd_seloid_print
argument_list|(
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|SELOID
argument_list|)
argument_list|,
operator|&
name|cur_col
argument_list|,
literal|50
argument_list|)
expr_stmt|;
name|ahd_selid_print
argument_list|(
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|SELID
argument_list|)
argument_list|,
operator|&
name|cur_col
argument_list|,
literal|50
argument_list|)
expr_stmt|;
name|ahd_hs_mailbox_print
argument_list|(
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|LOCAL_HS_MAILBOX
argument_list|)
argument_list|,
operator|&
name|cur_col
argument_list|,
literal|50
argument_list|)
expr_stmt|;
name|ahd_intctl_print
argument_list|(
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|INTCTL
argument_list|)
argument_list|,
operator|&
name|cur_col
argument_list|,
literal|50
argument_list|)
expr_stmt|;
name|ahd_seqintstat_print
argument_list|(
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|SEQINTSTAT
argument_list|)
argument_list|,
operator|&
name|cur_col
argument_list|,
literal|50
argument_list|)
expr_stmt|;
name|ahd_saved_mode_print
argument_list|(
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|SAVED_MODE
argument_list|)
argument_list|,
operator|&
name|cur_col
argument_list|,
literal|50
argument_list|)
expr_stmt|;
name|ahd_dffstat_print
argument_list|(
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|DFFSTAT
argument_list|)
argument_list|,
operator|&
name|cur_col
argument_list|,
literal|50
argument_list|)
expr_stmt|;
name|ahd_scsisigi_print
argument_list|(
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|SCSISIGI
argument_list|)
argument_list|,
operator|&
name|cur_col
argument_list|,
literal|50
argument_list|)
expr_stmt|;
name|ahd_scsiphase_print
argument_list|(
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|SCSIPHASE
argument_list|)
argument_list|,
operator|&
name|cur_col
argument_list|,
literal|50
argument_list|)
expr_stmt|;
name|ahd_scsibus_print
argument_list|(
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|SCSIBUS
argument_list|)
argument_list|,
operator|&
name|cur_col
argument_list|,
literal|50
argument_list|)
expr_stmt|;
name|ahd_lastphase_print
argument_list|(
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|LASTPHASE
argument_list|)
argument_list|,
operator|&
name|cur_col
argument_list|,
literal|50
argument_list|)
expr_stmt|;
name|ahd_scsiseq0_print
argument_list|(
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|SCSISEQ0
argument_list|)
argument_list|,
operator|&
name|cur_col
argument_list|,
literal|50
argument_list|)
expr_stmt|;
name|ahd_scsiseq1_print
argument_list|(
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|SCSISEQ1
argument_list|)
argument_list|,
operator|&
name|cur_col
argument_list|,
literal|50
argument_list|)
expr_stmt|;
name|ahd_seqctl0_print
argument_list|(
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|SEQCTL0
argument_list|)
argument_list|,
operator|&
name|cur_col
argument_list|,
literal|50
argument_list|)
expr_stmt|;
name|ahd_seqintctl_print
argument_list|(
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|SEQINTCTL
argument_list|)
argument_list|,
operator|&
name|cur_col
argument_list|,
literal|50
argument_list|)
expr_stmt|;
name|ahd_seq_flags_print
argument_list|(
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|SEQ_FLAGS
argument_list|)
argument_list|,
operator|&
name|cur_col
argument_list|,
literal|50
argument_list|)
expr_stmt|;
name|ahd_seq_flags2_print
argument_list|(
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|SEQ_FLAGS2
argument_list|)
argument_list|,
operator|&
name|cur_col
argument_list|,
literal|50
argument_list|)
expr_stmt|;
name|ahd_qfreeze_count_print
argument_list|(
name|ahd_inw
argument_list|(
name|ahd
argument_list|,
name|QFREEZE_COUNT
argument_list|)
argument_list|,
operator|&
name|cur_col
argument_list|,
literal|50
argument_list|)
expr_stmt|;
name|ahd_kernel_qfreeze_count_print
argument_list|(
name|ahd_inw
argument_list|(
name|ahd
argument_list|,
name|KERNEL_QFREEZE_COUNT
argument_list|)
argument_list|,
operator|&
name|cur_col
argument_list|,
literal|50
argument_list|)
expr_stmt|;
name|ahd_mk_message_scb_print
argument_list|(
name|ahd_inw
argument_list|(
name|ahd
argument_list|,
name|MK_MESSAGE_SCB
argument_list|)
argument_list|,
operator|&
name|cur_col
argument_list|,
literal|50
argument_list|)
expr_stmt|;
name|ahd_mk_message_scsiid_print
argument_list|(
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|MK_MESSAGE_SCSIID
argument_list|)
argument_list|,
operator|&
name|cur_col
argument_list|,
literal|50
argument_list|)
expr_stmt|;
name|ahd_sstat0_print
argument_list|(
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|SSTAT0
argument_list|)
argument_list|,
operator|&
name|cur_col
argument_list|,
literal|50
argument_list|)
expr_stmt|;
name|ahd_sstat1_print
argument_list|(
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|SSTAT1
argument_list|)
argument_list|,
operator|&
name|cur_col
argument_list|,
literal|50
argument_list|)
expr_stmt|;
name|ahd_sstat2_print
argument_list|(
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|SSTAT2
argument_list|)
argument_list|,
operator|&
name|cur_col
argument_list|,
literal|50
argument_list|)
expr_stmt|;
name|ahd_sstat3_print
argument_list|(
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|SSTAT3
argument_list|)
argument_list|,
operator|&
name|cur_col
argument_list|,
literal|50
argument_list|)
expr_stmt|;
name|ahd_perrdiag_print
argument_list|(
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|PERRDIAG
argument_list|)
argument_list|,
operator|&
name|cur_col
argument_list|,
literal|50
argument_list|)
expr_stmt|;
name|ahd_simode1_print
argument_list|(
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|SIMODE1
argument_list|)
argument_list|,
operator|&
name|cur_col
argument_list|,
literal|50
argument_list|)
expr_stmt|;
name|ahd_lqistat0_print
argument_list|(
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|LQISTAT0
argument_list|)
argument_list|,
operator|&
name|cur_col
argument_list|,
literal|50
argument_list|)
expr_stmt|;
name|ahd_lqistat1_print
argument_list|(
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|LQISTAT1
argument_list|)
argument_list|,
operator|&
name|cur_col
argument_list|,
literal|50
argument_list|)
expr_stmt|;
name|ahd_lqistat2_print
argument_list|(
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|LQISTAT2
argument_list|)
argument_list|,
operator|&
name|cur_col
argument_list|,
literal|50
argument_list|)
expr_stmt|;
name|ahd_lqostat0_print
argument_list|(
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|LQOSTAT0
argument_list|)
argument_list|,
operator|&
name|cur_col
argument_list|,
literal|50
argument_list|)
expr_stmt|;
name|ahd_lqostat1_print
argument_list|(
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|LQOSTAT1
argument_list|)
argument_list|,
operator|&
name|cur_col
argument_list|,
literal|50
argument_list|)
expr_stmt|;
name|ahd_lqostat2_print
argument_list|(
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|LQOSTAT2
argument_list|)
argument_list|,
operator|&
name|cur_col
argument_list|,
literal|50
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\nSCB Count = %d CMDS_PENDING = %d LASTSCB 0x%x "
literal|"CURRSCB 0x%x NEXTSCB 0x%x\n"
argument_list|,
name|ahd
operator|->
name|scb_data
operator|.
name|numscbs
argument_list|,
name|ahd_inw
argument_list|(
name|ahd
argument_list|,
name|CMDS_PENDING
argument_list|)
argument_list|,
name|ahd_inw
argument_list|(
name|ahd
argument_list|,
name|LASTSCB
argument_list|)
argument_list|,
name|ahd_inw
argument_list|(
name|ahd
argument_list|,
name|CURRSCB
argument_list|)
argument_list|,
name|ahd_inw
argument_list|(
name|ahd
argument_list|,
name|NEXTSCB
argument_list|)
argument_list|)
expr_stmt|;
name|cur_col
operator|=
literal|0
expr_stmt|;
comment|/* QINFIFO */
name|ahd_search_qinfifo
argument_list|(
name|ahd
argument_list|,
name|CAM_TARGET_WILDCARD
argument_list|,
name|ALL_CHANNELS
argument_list|,
name|CAM_LUN_WILDCARD
argument_list|,
name|SCB_LIST_NULL
argument_list|,
name|ROLE_UNKNOWN
argument_list|,
comment|/*status*/
literal|0
argument_list|,
name|SEARCH_PRINT
argument_list|)
expr_stmt|;
name|saved_scb_index
operator|=
name|ahd_get_scbptr
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Pending list:"
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|scb
argument_list|,
argument|&ahd->pending_scbs
argument_list|,
argument|pending_links
argument_list|)
block|{
if|if
condition|(
name|i
operator|++
operator|>
name|AHD_SCB_MAX
condition|)
break|break;
name|cur_col
operator|=
name|printf
argument_list|(
literal|"\n%3d FIFO_USE[0x%x] "
argument_list|,
name|SCB_GET_TAG
argument_list|(
name|scb
argument_list|)
argument_list|,
name|ahd_inb_scbram
argument_list|(
name|ahd
argument_list|,
name|SCB_FIFO_USE_COUNT
argument_list|)
argument_list|)
expr_stmt|;
name|ahd_set_scbptr
argument_list|(
name|ahd
argument_list|,
name|SCB_GET_TAG
argument_list|(
name|scb
argument_list|)
argument_list|)
expr_stmt|;
name|ahd_scb_control_print
argument_list|(
name|ahd_inb_scbram
argument_list|(
name|ahd
argument_list|,
name|SCB_CONTROL
argument_list|)
argument_list|,
operator|&
name|cur_col
argument_list|,
literal|60
argument_list|)
expr_stmt|;
name|ahd_scb_scsiid_print
argument_list|(
name|ahd_inb_scbram
argument_list|(
name|ahd
argument_list|,
name|SCB_SCSIID
argument_list|)
argument_list|,
operator|&
name|cur_col
argument_list|,
literal|60
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\nTotal %d\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Kernel Free SCB lists: "
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|scb
argument_list|,
argument|&ahd->scb_data.free_scbs
argument_list|,
argument|links.tqe
argument_list|)
block|{
name|struct
name|scb
modifier|*
name|list_scb
decl_stmt|;
name|printf
argument_list|(
literal|"\n  COLIDX[%d]: "
argument_list|,
name|AHD_GET_SCB_COL_IDX
argument_list|(
name|ahd
argument_list|,
name|scb
argument_list|)
argument_list|)
expr_stmt|;
name|list_scb
operator|=
name|scb
expr_stmt|;
do|do
block|{
name|printf
argument_list|(
literal|"%d "
argument_list|,
name|SCB_GET_TAG
argument_list|(
name|list_scb
argument_list|)
argument_list|)
expr_stmt|;
name|list_scb
operator|=
name|LIST_NEXT
argument_list|(
name|list_scb
argument_list|,
name|collision_links
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|list_scb
operator|&&
name|i
operator|++
operator|<
name|AHD_SCB_MAX
condition|)
do|;
block|}
name|printf
argument_list|(
literal|"\n  Any Device: "
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|scb
argument_list|,
argument|&ahd->scb_data.any_dev_free_scb_list
argument_list|,
argument|links.le
argument_list|)
block|{
if|if
condition|(
name|i
operator|++
operator|>
name|AHD_SCB_MAX
condition|)
break|break;
name|printf
argument_list|(
literal|"%d "
argument_list|,
name|SCB_GET_TAG
argument_list|(
name|scb
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Sequencer Complete DMA-inprog list: "
argument_list|)
expr_stmt|;
name|scb_index
operator|=
name|ahd_inw
argument_list|(
name|ahd
argument_list|,
name|COMPLETE_SCB_DMAINPROG_HEAD
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|!
name|SCBID_IS_NULL
argument_list|(
name|scb_index
argument_list|)
operator|&&
name|i
operator|++
operator|<
name|AHD_SCB_MAX
condition|)
block|{
name|ahd_set_scbptr
argument_list|(
name|ahd
argument_list|,
name|scb_index
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%d "
argument_list|,
name|scb_index
argument_list|)
expr_stmt|;
name|scb_index
operator|=
name|ahd_inw_scbram
argument_list|(
name|ahd
argument_list|,
name|SCB_NEXT_COMPLETE
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Sequencer Complete list: "
argument_list|)
expr_stmt|;
name|scb_index
operator|=
name|ahd_inw
argument_list|(
name|ahd
argument_list|,
name|COMPLETE_SCB_HEAD
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|!
name|SCBID_IS_NULL
argument_list|(
name|scb_index
argument_list|)
operator|&&
name|i
operator|++
operator|<
name|AHD_SCB_MAX
condition|)
block|{
name|ahd_set_scbptr
argument_list|(
name|ahd
argument_list|,
name|scb_index
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%d "
argument_list|,
name|scb_index
argument_list|)
expr_stmt|;
name|scb_index
operator|=
name|ahd_inw_scbram
argument_list|(
name|ahd
argument_list|,
name|SCB_NEXT_COMPLETE
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Sequencer DMA-Up and Complete list: "
argument_list|)
expr_stmt|;
name|scb_index
operator|=
name|ahd_inw
argument_list|(
name|ahd
argument_list|,
name|COMPLETE_DMA_SCB_HEAD
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|!
name|SCBID_IS_NULL
argument_list|(
name|scb_index
argument_list|)
operator|&&
name|i
operator|++
operator|<
name|AHD_SCB_MAX
condition|)
block|{
name|ahd_set_scbptr
argument_list|(
name|ahd
argument_list|,
name|scb_index
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%d "
argument_list|,
name|scb_index
argument_list|)
expr_stmt|;
name|scb_index
operator|=
name|ahd_inw_scbram
argument_list|(
name|ahd
argument_list|,
name|SCB_NEXT_COMPLETE
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Sequencer On QFreeze and Complete list: "
argument_list|)
expr_stmt|;
name|scb_index
operator|=
name|ahd_inw
argument_list|(
name|ahd
argument_list|,
name|COMPLETE_ON_QFREEZE_HEAD
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|!
name|SCBID_IS_NULL
argument_list|(
name|scb_index
argument_list|)
operator|&&
name|i
operator|++
operator|<
name|AHD_SCB_MAX
condition|)
block|{
name|ahd_set_scbptr
argument_list|(
name|ahd
argument_list|,
name|scb_index
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%d "
argument_list|,
name|scb_index
argument_list|)
expr_stmt|;
name|scb_index
operator|=
name|ahd_inw_scbram
argument_list|(
name|ahd
argument_list|,
name|SCB_NEXT_COMPLETE
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|ahd_set_scbptr
argument_list|(
name|ahd
argument_list|,
name|saved_scb_index
argument_list|)
expr_stmt|;
name|dffstat
operator|=
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|DFFSTAT
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
name|i
operator|++
control|)
block|{
ifdef|#
directive|ifdef
name|AHD_DEBUG
name|struct
name|scb
modifier|*
name|fifo_scb
decl_stmt|;
endif|#
directive|endif
name|u_int
name|fifo_scbptr
decl_stmt|;
name|ahd_set_modes
argument_list|(
name|ahd
argument_list|,
name|AHD_MODE_DFF0
operator|+
name|i
argument_list|,
name|AHD_MODE_DFF0
operator|+
name|i
argument_list|)
expr_stmt|;
name|fifo_scbptr
operator|=
name|ahd_get_scbptr
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n\n%s: FIFO%d %s, LONGJMP == 0x%x, SCB 0x%x\n"
argument_list|,
name|ahd_name
argument_list|(
name|ahd
argument_list|)
argument_list|,
name|i
argument_list|,
operator|(
name|dffstat
operator|&
operator|(
name|FIFO0FREE
operator|<<
name|i
operator|)
operator|)
condition|?
literal|"Free"
else|:
literal|"Active"
argument_list|,
name|ahd_inw
argument_list|(
name|ahd
argument_list|,
name|LONGJMP_ADDR
argument_list|)
argument_list|,
name|fifo_scbptr
argument_list|)
expr_stmt|;
name|cur_col
operator|=
literal|0
expr_stmt|;
name|ahd_seqimode_print
argument_list|(
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|SEQIMODE
argument_list|)
argument_list|,
operator|&
name|cur_col
argument_list|,
literal|50
argument_list|)
expr_stmt|;
name|ahd_seqintsrc_print
argument_list|(
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|SEQINTSRC
argument_list|)
argument_list|,
operator|&
name|cur_col
argument_list|,
literal|50
argument_list|)
expr_stmt|;
name|ahd_dfcntrl_print
argument_list|(
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|DFCNTRL
argument_list|)
argument_list|,
operator|&
name|cur_col
argument_list|,
literal|50
argument_list|)
expr_stmt|;
name|ahd_dfstatus_print
argument_list|(
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|DFSTATUS
argument_list|)
argument_list|,
operator|&
name|cur_col
argument_list|,
literal|50
argument_list|)
expr_stmt|;
name|ahd_sg_cache_shadow_print
argument_list|(
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|SG_CACHE_SHADOW
argument_list|)
argument_list|,
operator|&
name|cur_col
argument_list|,
literal|50
argument_list|)
expr_stmt|;
name|ahd_sg_state_print
argument_list|(
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|SG_STATE
argument_list|)
argument_list|,
operator|&
name|cur_col
argument_list|,
literal|50
argument_list|)
expr_stmt|;
name|ahd_dffsxfrctl_print
argument_list|(
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|DFFSXFRCTL
argument_list|)
argument_list|,
operator|&
name|cur_col
argument_list|,
literal|50
argument_list|)
expr_stmt|;
name|ahd_soffcnt_print
argument_list|(
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|SOFFCNT
argument_list|)
argument_list|,
operator|&
name|cur_col
argument_list|,
literal|50
argument_list|)
expr_stmt|;
name|ahd_mdffstat_print
argument_list|(
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|MDFFSTAT
argument_list|)
argument_list|,
operator|&
name|cur_col
argument_list|,
literal|50
argument_list|)
expr_stmt|;
if|if
condition|(
name|cur_col
operator|>
literal|50
condition|)
block|{
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|cur_col
operator|=
literal|0
expr_stmt|;
block|}
name|cur_col
operator|+=
name|printf
argument_list|(
literal|"SHADDR = 0x%x%x, SHCNT = 0x%x "
argument_list|,
name|ahd_inl
argument_list|(
name|ahd
argument_list|,
name|SHADDR
operator|+
literal|4
argument_list|)
argument_list|,
name|ahd_inl
argument_list|(
name|ahd
argument_list|,
name|SHADDR
argument_list|)
argument_list|,
operator|(
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|SHCNT
argument_list|)
operator||
operator|(
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|SHCNT
operator|+
literal|1
argument_list|)
operator|<<
literal|8
operator|)
operator||
operator|(
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|SHCNT
operator|+
literal|2
argument_list|)
operator|<<
literal|16
operator|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cur_col
operator|>
literal|50
condition|)
block|{
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|cur_col
operator|=
literal|0
expr_stmt|;
block|}
name|cur_col
operator|+=
name|printf
argument_list|(
literal|"HADDR = 0x%x%x, HCNT = 0x%x "
argument_list|,
name|ahd_inl
argument_list|(
name|ahd
argument_list|,
name|HADDR
operator|+
literal|4
argument_list|)
argument_list|,
name|ahd_inl
argument_list|(
name|ahd
argument_list|,
name|HADDR
argument_list|)
argument_list|,
operator|(
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|HCNT
argument_list|)
operator||
operator|(
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|HCNT
operator|+
literal|1
argument_list|)
operator|<<
literal|8
operator|)
operator||
operator|(
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|HCNT
operator|+
literal|2
argument_list|)
operator|<<
literal|16
operator|)
operator|)
argument_list|)
expr_stmt|;
name|ahd_ccsgctl_print
argument_list|(
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|CCSGCTL
argument_list|)
argument_list|,
operator|&
name|cur_col
argument_list|,
literal|50
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|AHD_DEBUG
if|if
condition|(
operator|(
name|ahd_debug
operator|&
name|AHD_SHOW_SG
operator|)
operator|!=
literal|0
condition|)
block|{
name|fifo_scb
operator|=
name|ahd_lookup_scb
argument_list|(
name|ahd
argument_list|,
name|fifo_scbptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|fifo_scb
operator|!=
name|NULL
condition|)
name|ahd_dump_sglist
argument_list|(
name|fifo_scb
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
name|printf
argument_list|(
literal|"\nLQIN: "
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|20
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|"0x%x "
argument_list|,
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|LQIN
operator|+
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|ahd_set_modes
argument_list|(
name|ahd
argument_list|,
name|AHD_MODE_CFG
argument_list|,
name|AHD_MODE_CFG
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s: LQISTATE = 0x%x, LQOSTATE = 0x%x, OPTIONMODE = 0x%x\n"
argument_list|,
name|ahd_name
argument_list|(
name|ahd
argument_list|)
argument_list|,
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|LQISTATE
argument_list|)
argument_list|,
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|LQOSTATE
argument_list|)
argument_list|,
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|OPTIONMODE
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s: OS_SPACE_CNT = 0x%x MAXCMDCNT = 0x%x\n"
argument_list|,
name|ahd_name
argument_list|(
name|ahd
argument_list|)
argument_list|,
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|OS_SPACE_CNT
argument_list|)
argument_list|,
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|MAXCMDCNT
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s: SAVED_SCSIID = 0x%x SAVED_LUN = 0x%x\n"
argument_list|,
name|ahd_name
argument_list|(
name|ahd
argument_list|)
argument_list|,
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|SAVED_SCSIID
argument_list|)
argument_list|,
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|SAVED_LUN
argument_list|)
argument_list|)
expr_stmt|;
name|ahd_simode0_print
argument_list|(
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|SIMODE0
argument_list|)
argument_list|,
operator|&
name|cur_col
argument_list|,
literal|50
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|ahd_set_modes
argument_list|(
name|ahd
argument_list|,
name|AHD_MODE_CCHAN
argument_list|,
name|AHD_MODE_CCHAN
argument_list|)
expr_stmt|;
name|cur_col
operator|=
literal|0
expr_stmt|;
name|ahd_ccscbctl_print
argument_list|(
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|CCSCBCTL
argument_list|)
argument_list|,
operator|&
name|cur_col
argument_list|,
literal|50
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|ahd_set_modes
argument_list|(
name|ahd
argument_list|,
name|ahd
operator|->
name|saved_src_mode
argument_list|,
name|ahd
operator|->
name|saved_dst_mode
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s: REG0 == 0x%x, SINDEX = 0x%x, DINDEX = 0x%x\n"
argument_list|,
name|ahd_name
argument_list|(
name|ahd
argument_list|)
argument_list|,
name|ahd_inw
argument_list|(
name|ahd
argument_list|,
name|REG0
argument_list|)
argument_list|,
name|ahd_inw
argument_list|(
name|ahd
argument_list|,
name|SINDEX
argument_list|)
argument_list|,
name|ahd_inw
argument_list|(
name|ahd
argument_list|,
name|DINDEX
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s: SCBPTR == 0x%x, SCB_NEXT == 0x%x, SCB_NEXT2 == 0x%x\n"
argument_list|,
name|ahd_name
argument_list|(
name|ahd
argument_list|)
argument_list|,
name|ahd_get_scbptr
argument_list|(
name|ahd
argument_list|)
argument_list|,
name|ahd_inw_scbram
argument_list|(
name|ahd
argument_list|,
name|SCB_NEXT
argument_list|)
argument_list|,
name|ahd_inw_scbram
argument_list|(
name|ahd
argument_list|,
name|SCB_NEXT2
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"CDB %x %x %x %x %x %x\n"
argument_list|,
name|ahd_inb_scbram
argument_list|(
name|ahd
argument_list|,
name|SCB_CDB_STORE
argument_list|)
argument_list|,
name|ahd_inb_scbram
argument_list|(
name|ahd
argument_list|,
name|SCB_CDB_STORE
operator|+
literal|1
argument_list|)
argument_list|,
name|ahd_inb_scbram
argument_list|(
name|ahd
argument_list|,
name|SCB_CDB_STORE
operator|+
literal|2
argument_list|)
argument_list|,
name|ahd_inb_scbram
argument_list|(
name|ahd
argument_list|,
name|SCB_CDB_STORE
operator|+
literal|3
argument_list|)
argument_list|,
name|ahd_inb_scbram
argument_list|(
name|ahd
argument_list|,
name|SCB_CDB_STORE
operator|+
literal|4
argument_list|)
argument_list|,
name|ahd_inb_scbram
argument_list|(
name|ahd
argument_list|,
name|SCB_CDB_STORE
operator|+
literal|5
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"STACK:"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ahd
operator|->
name|stack_size
condition|;
name|i
operator|++
control|)
block|{
name|ahd
operator|->
name|saved_stack
index|[
name|i
index|]
operator|=
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|STACK
argument_list|)
operator||
operator|(
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|STACK
argument_list|)
operator|<<
literal|8
operator|)
expr_stmt|;
name|printf
argument_list|(
literal|" 0x%x"
argument_list|,
name|ahd
operator|->
name|saved_stack
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
name|ahd
operator|->
name|stack_size
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|STACK
argument_list|,
name|ahd
operator|->
name|saved_stack
index|[
name|i
index|]
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|STACK
argument_list|,
operator|(
name|ahd
operator|->
name|saved_stack
index|[
name|i
index|]
operator|>>
literal|8
operator|)
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n<<<<<<<<<<<<<<<<< Dump Card State Ends>>>>>>>>>>>>>>>>>>\n"
argument_list|)
expr_stmt|;
name|ahd_platform_dump_card_state
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
name|ahd_restore_modes
argument_list|(
name|ahd
argument_list|,
name|saved_modes
argument_list|)
expr_stmt|;
if|if
condition|(
name|paused
operator|==
literal|0
condition|)
name|ahd_unpause
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ahd_dump_scbs
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|)
block|{
name|ahd_mode_state
name|saved_modes
decl_stmt|;
name|u_int
name|saved_scb_index
decl_stmt|;
name|int
name|i
decl_stmt|;
name|saved_modes
operator|=
name|ahd_save_modes
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
name|ahd_set_modes
argument_list|(
name|ahd
argument_list|,
name|AHD_MODE_SCSI
argument_list|,
name|AHD_MODE_SCSI
argument_list|)
expr_stmt|;
name|saved_scb_index
operator|=
name|ahd_get_scbptr
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|AHD_SCB_MAX
condition|;
name|i
operator|++
control|)
block|{
name|ahd_set_scbptr
argument_list|(
name|ahd
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%3d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"(CTRL 0x%x ID 0x%x N 0x%x N2 0x%x SG 0x%x, RSG 0x%x)\n"
argument_list|,
name|ahd_inb_scbram
argument_list|(
name|ahd
argument_list|,
name|SCB_CONTROL
argument_list|)
argument_list|,
name|ahd_inb_scbram
argument_list|(
name|ahd
argument_list|,
name|SCB_SCSIID
argument_list|)
argument_list|,
name|ahd_inw_scbram
argument_list|(
name|ahd
argument_list|,
name|SCB_NEXT
argument_list|)
argument_list|,
name|ahd_inw_scbram
argument_list|(
name|ahd
argument_list|,
name|SCB_NEXT2
argument_list|)
argument_list|,
name|ahd_inl_scbram
argument_list|(
name|ahd
argument_list|,
name|SCB_SGPTR
argument_list|)
argument_list|,
name|ahd_inl_scbram
argument_list|(
name|ahd
argument_list|,
name|SCB_RESIDUAL_SGPTR
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|ahd_set_scbptr
argument_list|(
name|ahd
argument_list|,
name|saved_scb_index
argument_list|)
expr_stmt|;
name|ahd_restore_modes
argument_list|(
name|ahd
argument_list|,
name|saved_modes
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*************************** Timeout Handling *********************************/
end_comment

begin_function
name|void
name|ahd_timeout
parameter_list|(
name|struct
name|scb
modifier|*
name|scb
parameter_list|)
block|{
name|struct
name|ahd_softc
modifier|*
name|ahd
decl_stmt|;
name|ahd
operator|=
name|scb
operator|->
name|ahd_softc
expr_stmt|;
if|if
condition|(
operator|(
name|scb
operator|->
name|flags
operator|&
name|SCB_ACTIVE
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|scb
operator|->
name|flags
operator|&
name|SCB_TIMEDOUT
operator|)
operator|==
literal|0
condition|)
block|{
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|ahd
operator|->
name|timedout_scbs
argument_list|,
name|scb
argument_list|,
name|timedout_links
argument_list|)
expr_stmt|;
name|scb
operator|->
name|flags
operator||=
name|SCB_TIMEDOUT
expr_stmt|;
block|}
name|ahd_wakeup_recovery_thread
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * ahd_recover_commands determines if any of the commands that have currently  * timedout are the root cause for this timeout.  Innocent commands are given  * a new timeout while we wait for the command executing on the bus to timeout.  * This routine is invoked from a thread context so we are allowed to sleep.  * Our lock is not held on entry.  */
end_comment

begin_function
name|void
name|ahd_recover_commands
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|)
block|{
name|struct
name|scb
modifier|*
name|scb
decl_stmt|;
name|struct
name|scb
modifier|*
name|active_scb
decl_stmt|;
name|int
name|found
decl_stmt|;
name|int
name|was_paused
decl_stmt|;
name|u_int
name|active_scbptr
decl_stmt|;
name|u_int
name|last_phase
decl_stmt|;
comment|/* 	 * Pause the controller and manually flush any 	 * commands that have just completed but that our 	 * interrupt handler has yet to see. 	 */
name|was_paused
operator|=
name|ahd_is_paused
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s: Recovery Initiated - Card was %spaused\n"
argument_list|,
name|ahd_name
argument_list|(
name|ahd
argument_list|)
argument_list|,
name|was_paused
condition|?
literal|""
else|:
literal|"not "
argument_list|)
expr_stmt|;
name|ahd_dump_card_state
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
name|ahd_pause_and_flushwork
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
if|if
condition|(
name|LIST_EMPTY
argument_list|(
operator|&
name|ahd
operator|->
name|timedout_scbs
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * The timedout commands have already 		 * completed.  This typically means 		 * that either the timeout value was on 		 * the hairy edge of what the device 		 * requires or - more likely - interrupts 		 * are not happening. 		 */
name|printf
argument_list|(
literal|"%s: Timedout SCBs already complete. "
literal|"Interrupts may not be functioning.\n"
argument_list|,
name|ahd_name
argument_list|(
name|ahd
argument_list|)
argument_list|)
expr_stmt|;
name|ahd_unpause
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Determine identity of SCB acting on the bus. 	 * This test only catches non-packetized transactions. 	 * Due to the fleeting nature of packetized operations, 	 * we can't easily determine that a packetized operation 	 * is on the bus. 	 */
name|ahd_set_modes
argument_list|(
name|ahd
argument_list|,
name|AHD_MODE_SCSI
argument_list|,
name|AHD_MODE_SCSI
argument_list|)
expr_stmt|;
name|last_phase
operator|=
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|LASTPHASE
argument_list|)
expr_stmt|;
name|active_scbptr
operator|=
name|ahd_get_scbptr
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
name|active_scb
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|last_phase
operator|!=
name|P_BUSFREE
operator|||
operator|(
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|SEQ_FLAGS
argument_list|)
operator|&
name|NOT_IDENTIFIED
operator|)
operator|==
literal|0
condition|)
name|active_scb
operator|=
name|ahd_lookup_scb
argument_list|(
name|ahd
argument_list|,
name|active_scbptr
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|scb
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|ahd
operator|->
name|timedout_scbs
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|int
name|target
decl_stmt|;
name|int
name|lun
decl_stmt|;
name|char
name|channel
decl_stmt|;
name|target
operator|=
name|SCB_GET_TARGET
argument_list|(
name|ahd
argument_list|,
name|scb
argument_list|)
expr_stmt|;
name|channel
operator|=
name|SCB_GET_CHANNEL
argument_list|(
name|ahd
argument_list|,
name|scb
argument_list|)
expr_stmt|;
name|lun
operator|=
name|SCB_GET_LUN
argument_list|(
name|scb
argument_list|)
expr_stmt|;
name|ahd_print_path
argument_list|(
name|ahd
argument_list|,
name|scb
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"SCB %d - timed out\n"
argument_list|,
name|SCB_GET_TAG
argument_list|(
name|scb
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|scb
operator|->
name|flags
operator|&
operator|(
name|SCB_DEVICE_RESET
operator||
name|SCB_ABORT
operator|)
condition|)
block|{
comment|/* 			 * Been down this road before. 			 * Do a full bus reset. 			 */
name|aic_set_transaction_status
argument_list|(
name|scb
argument_list|,
name|CAM_CMD_TIMEOUT
argument_list|)
expr_stmt|;
name|bus_reset
label|:
name|found
operator|=
name|ahd_reset_channel
argument_list|(
name|ahd
argument_list|,
name|channel
argument_list|,
comment|/*Initiate Reset*/
name|TRUE
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s: Issued Channel %c Bus Reset. "
literal|"%d SCBs aborted\n"
argument_list|,
name|ahd_name
argument_list|(
name|ahd
argument_list|)
argument_list|,
name|channel
argument_list|,
name|found
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * Remove the command from the timedout list in 		 * preparation for requeing it. 		 */
name|LIST_REMOVE
argument_list|(
name|scb
argument_list|,
name|timedout_links
argument_list|)
expr_stmt|;
name|scb
operator|->
name|flags
operator|&=
operator|~
name|SCB_TIMEDOUT
expr_stmt|;
if|if
condition|(
name|active_scb
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|active_scb
operator|!=
name|scb
condition|)
block|{
comment|/* 				 * If the active SCB is not us, assume that 				 * the active SCB has a longer timeout than 				 * the timedout SCB, and wait for the active 				 * SCB to timeout.  As a safeguard, only 				 * allow this deferral to continue if some 				 * untimed-out command is outstanding. 				 */
if|if
condition|(
name|ahd_other_scb_timeout
argument_list|(
name|ahd
argument_list|,
name|scb
argument_list|,
name|active_scb
argument_list|)
operator|==
literal|0
condition|)
goto|goto
name|bus_reset
goto|;
continue|continue;
block|}
comment|/* 			 * We're active on the bus, so assert ATN 			 * and hope that the target responds. 			 */
name|ahd_set_recoveryscb
argument_list|(
name|ahd
argument_list|,
name|active_scb
argument_list|)
expr_stmt|;
name|active_scb
operator|->
name|flags
operator||=
name|SCB_RECOVERY_SCB
operator||
name|SCB_DEVICE_RESET
expr_stmt|;
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|MSG_OUT
argument_list|,
name|HOST_MSG
argument_list|)
expr_stmt|;
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|SCSISIGO
argument_list|,
name|last_phase
operator||
name|ATNO
argument_list|)
expr_stmt|;
name|ahd_print_path
argument_list|(
name|ahd
argument_list|,
name|active_scb
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"BDR message in message buffer\n"
argument_list|)
expr_stmt|;
name|aic_scb_timer_reset
argument_list|(
name|scb
argument_list|,
literal|2
operator|*
literal|1000
argument_list|)
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|last_phase
operator|!=
name|P_BUSFREE
operator|&&
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|SCSIPHASE
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* 			 * SCB is not identified, there 			 * is no pending REQ, and the sequencer 			 * has not seen a busfree.  Looks like 			 * a stuck connection waiting to 			 * go busfree.  Reset the bus. 			 */
name|printf
argument_list|(
literal|"%s: Connection stuck awaiting busfree or "
literal|"Identify Msg.\n"
argument_list|,
name|ahd_name
argument_list|(
name|ahd
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|bus_reset
goto|;
block|}
elseif|else
if|if
condition|(
name|ahd_search_qinfifo
argument_list|(
name|ahd
argument_list|,
name|target
argument_list|,
name|channel
argument_list|,
name|lun
argument_list|,
name|SCB_GET_TAG
argument_list|(
name|scb
argument_list|)
argument_list|,
name|ROLE_INITIATOR
argument_list|,
comment|/*status*/
literal|0
argument_list|,
name|SEARCH_COUNT
argument_list|)
operator|>
literal|0
condition|)
block|{
comment|/* 			 * We haven't even gone out on the bus 			 * yet, so the timeout must be due to 			 * some other command.  Reset the timer 			 * and go on. 			 */
if|if
condition|(
name|ahd_other_scb_timeout
argument_list|(
name|ahd
argument_list|,
name|scb
argument_list|,
name|NULL
argument_list|)
operator|==
literal|0
condition|)
goto|goto
name|bus_reset
goto|;
block|}
else|else
block|{
comment|/* 			 * This SCB is for a disconnected transaction 			 * and we haven't found a better candidate on 			 * the bus to explain this timeout. 			 */
name|ahd_set_recoveryscb
argument_list|(
name|ahd
argument_list|,
name|scb
argument_list|)
expr_stmt|;
comment|/* 			 * Actually re-queue this SCB in an attempt 			 * to select the device before it reconnects. 			 * In either case (selection or reselection), 			 * we will now issue a target reset to the 			 * timed-out device. 			 */
name|scb
operator|->
name|flags
operator||=
name|SCB_DEVICE_RESET
expr_stmt|;
name|scb
operator|->
name|hscb
operator|->
name|cdb_len
operator|=
literal|0
expr_stmt|;
name|scb
operator|->
name|hscb
operator|->
name|task_attribute
operator|=
literal|0
expr_stmt|;
name|scb
operator|->
name|hscb
operator|->
name|task_management
operator|=
name|SIU_TASKMGMT_ABORT_TASK
expr_stmt|;
name|ahd_set_scbptr
argument_list|(
name|ahd
argument_list|,
name|SCB_GET_TAG
argument_list|(
name|scb
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|scb
operator|->
name|flags
operator|&
name|SCB_PACKETIZED
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* 				 * Mark the SCB has having an outstanding 				 * task management function.  Should the command 				 * complete normally before the task management 				 * function can be sent, the host will be 				 * notified to abort our requeued SCB. 				 */
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|SCB_TASK_MANAGEMENT
argument_list|,
name|scb
operator|->
name|hscb
operator|->
name|task_management
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 				 * If non-packetized, set the MK_MESSAGE control 				 * bit indicating that we desire to send a 				 * message.  We also set the disconnected flag 				 * since there is no guarantee that our SCB 				 * control byte matches the version on the 				 * card.  We don't want the sequencer to abort 				 * the command thinking an unsolicited 				 * reselection occurred. 				 */
name|scb
operator|->
name|hscb
operator|->
name|control
operator||=
name|MK_MESSAGE
operator||
name|DISCONNECTED
expr_stmt|;
comment|/* 				 * The sequencer will never re-reference the 				 * in-core SCB.  To make sure we are notified 				 * during reslection, set the MK_MESSAGE flag in 				 * the card's copy of the SCB. 				 */
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|SCB_CONTROL
argument_list|,
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|SCB_CONTROL
argument_list|)
operator||
name|MK_MESSAGE
argument_list|)
expr_stmt|;
block|}
comment|/* 			 * Clear out any entries in the QINFIFO first 			 * so we are the next SCB for this target 			 * to run. 			 */
name|ahd_search_qinfifo
argument_list|(
name|ahd
argument_list|,
name|target
argument_list|,
name|channel
argument_list|,
name|lun
argument_list|,
name|SCB_LIST_NULL
argument_list|,
name|ROLE_INITIATOR
argument_list|,
name|CAM_REQUEUE_REQ
argument_list|,
name|SEARCH_COMPLETE
argument_list|)
expr_stmt|;
name|ahd_qinfifo_requeue_tail
argument_list|(
name|ahd
argument_list|,
name|scb
argument_list|)
expr_stmt|;
name|ahd_set_scbptr
argument_list|(
name|ahd
argument_list|,
name|active_scbptr
argument_list|)
expr_stmt|;
name|ahd_print_path
argument_list|(
name|ahd
argument_list|,
name|scb
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Queuing a BDR SCB\n"
argument_list|)
expr_stmt|;
name|aic_scb_timer_reset
argument_list|(
name|scb
argument_list|,
literal|2
operator|*
literal|1000
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
comment|/* 	 * Any remaining SCBs were not the "culprit", so remove 	 * them from the timeout list.  The timer for these commands 	 * will be reset once the recovery SCB completes. 	 */
while|while
condition|(
operator|(
name|scb
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|ahd
operator|->
name|timedout_scbs
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|LIST_REMOVE
argument_list|(
name|scb
argument_list|,
name|timedout_links
argument_list|)
expr_stmt|;
name|scb
operator|->
name|flags
operator|&=
operator|~
name|SCB_TIMEDOUT
expr_stmt|;
block|}
name|ahd_unpause
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Re-schedule a timeout for the passed in SCB if we determine that some  * other SCB is in the process of recovery or an SCB with a longer  * timeout is still pending.  Limit our search to just "other_scb"  * if it is non-NULL.  */
end_comment

begin_function
specifier|static
name|int
name|ahd_other_scb_timeout
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|,
name|struct
name|scb
modifier|*
name|scb
parameter_list|,
name|struct
name|scb
modifier|*
name|other_scb
parameter_list|)
block|{
name|u_int
name|newtimeout
decl_stmt|;
name|int
name|found
decl_stmt|;
name|ahd_print_path
argument_list|(
name|ahd
argument_list|,
name|scb
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Other SCB Timeout%s"
argument_list|,
operator|(
name|scb
operator|->
name|flags
operator|&
name|SCB_OTHERTCL_TIMEOUT
operator|)
operator|!=
literal|0
condition|?
literal|" again\n"
else|:
literal|"\n"
argument_list|)
expr_stmt|;
name|newtimeout
operator|=
name|aic_get_timeout
argument_list|(
name|scb
argument_list|)
expr_stmt|;
name|scb
operator|->
name|flags
operator||=
name|SCB_OTHERTCL_TIMEOUT
expr_stmt|;
name|found
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|other_scb
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|other_scb
operator|->
name|flags
operator|&
operator|(
name|SCB_OTHERTCL_TIMEOUT
operator||
name|SCB_TIMEDOUT
operator|)
operator|)
operator|==
literal|0
operator|||
operator|(
name|other_scb
operator|->
name|flags
operator|&
name|SCB_RECOVERY_SCB
operator|)
operator|!=
literal|0
condition|)
block|{
name|found
operator|++
expr_stmt|;
name|newtimeout
operator|=
name|MAX
argument_list|(
name|aic_get_timeout
argument_list|(
name|other_scb
argument_list|)
argument_list|,
name|newtimeout
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|LIST_FOREACH
argument_list|(
argument|other_scb
argument_list|,
argument|&ahd->pending_scbs
argument_list|,
argument|pending_links
argument_list|)
block|{
if|if
condition|(
operator|(
name|other_scb
operator|->
name|flags
operator|&
operator|(
name|SCB_OTHERTCL_TIMEOUT
operator||
name|SCB_TIMEDOUT
operator|)
operator|)
operator|==
literal|0
operator|||
operator|(
name|other_scb
operator|->
name|flags
operator|&
name|SCB_RECOVERY_SCB
operator|)
operator|!=
literal|0
condition|)
block|{
name|found
operator|++
expr_stmt|;
name|newtimeout
operator|=
name|MAX
argument_list|(
name|aic_get_timeout
argument_list|(
name|other_scb
argument_list|)
argument_list|,
name|newtimeout
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|found
operator|!=
literal|0
condition|)
name|aic_scb_timer_reset
argument_list|(
name|scb
argument_list|,
name|newtimeout
argument_list|)
expr_stmt|;
else|else
block|{
name|ahd_print_path
argument_list|(
name|ahd
argument_list|,
name|scb
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"No other SCB worth waiting for...\n"
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|found
operator|!=
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**************************** Flexport Logic **********************************/
end_comment

begin_comment
comment|/*  * Read count 16bit words from 16bit word address start_addr from the  * SEEPROM attached to the controller, into buf, using the controller's  * SEEPROM reading state machine.  Optionally treat the data as a byte  * stream in terms of byte order.  */
end_comment

begin_function
name|int
name|ahd_read_seeprom
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|,
name|uint16_t
modifier|*
name|buf
parameter_list|,
name|u_int
name|start_addr
parameter_list|,
name|u_int
name|count
parameter_list|,
name|int
name|bytestream
parameter_list|)
block|{
name|u_int
name|cur_addr
decl_stmt|;
name|u_int
name|end_addr
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* 	 * If we never make it through the loop even once, 	 * we were passed invalid arguments. 	 */
name|error
operator|=
name|EINVAL
expr_stmt|;
name|AHD_ASSERT_MODES
argument_list|(
name|ahd
argument_list|,
name|AHD_MODE_SCSI_MSK
argument_list|,
name|AHD_MODE_SCSI_MSK
argument_list|)
expr_stmt|;
name|end_addr
operator|=
name|start_addr
operator|+
name|count
expr_stmt|;
for|for
control|(
name|cur_addr
operator|=
name|start_addr
init|;
name|cur_addr
operator|<
name|end_addr
condition|;
name|cur_addr
operator|++
control|)
block|{
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|SEEADR
argument_list|,
name|cur_addr
argument_list|)
expr_stmt|;
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|SEECTL
argument_list|,
name|SEEOP_READ
operator||
name|SEESTART
argument_list|)
expr_stmt|;
name|error
operator|=
name|ahd_wait_seeprom
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
if|if
condition|(
name|bytestream
operator|!=
literal|0
condition|)
block|{
name|uint8_t
modifier|*
name|bytestream_ptr
decl_stmt|;
name|bytestream_ptr
operator|=
operator|(
name|uint8_t
operator|*
operator|)
name|buf
expr_stmt|;
operator|*
name|bytestream_ptr
operator|++
operator|=
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|SEEDAT
argument_list|)
expr_stmt|;
operator|*
name|bytestream_ptr
operator|=
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|SEEDAT
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * ahd_inw() already handles machine byte order. 			 */
operator|*
name|buf
operator|=
name|ahd_inw
argument_list|(
name|ahd
argument_list|,
name|SEEDAT
argument_list|)
expr_stmt|;
block|}
name|buf
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Write count 16bit words from buf, into SEEPROM attache to the  * controller starting at 16bit word address start_addr, using the  * controller's SEEPROM writing state machine.  */
end_comment

begin_function
name|int
name|ahd_write_seeprom
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|,
name|uint16_t
modifier|*
name|buf
parameter_list|,
name|u_int
name|start_addr
parameter_list|,
name|u_int
name|count
parameter_list|)
block|{
name|u_int
name|cur_addr
decl_stmt|;
name|u_int
name|end_addr
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|AHD_ASSERT_MODES
argument_list|(
name|ahd
argument_list|,
name|AHD_MODE_SCSI_MSK
argument_list|,
name|AHD_MODE_SCSI_MSK
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOENT
expr_stmt|;
comment|/* Place the chip into write-enable mode */
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|SEEADR
argument_list|,
name|SEEOP_EWEN_ADDR
argument_list|)
expr_stmt|;
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|SEECTL
argument_list|,
name|SEEOP_EWEN
operator||
name|SEESTART
argument_list|)
expr_stmt|;
name|error
operator|=
name|ahd_wait_seeprom
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* 	 * Write the data.  If we don't get throught the loop at 	 * least once, the arguments were invalid. 	 */
name|retval
operator|=
name|EINVAL
expr_stmt|;
name|end_addr
operator|=
name|start_addr
operator|+
name|count
expr_stmt|;
for|for
control|(
name|cur_addr
operator|=
name|start_addr
init|;
name|cur_addr
operator|<
name|end_addr
condition|;
name|cur_addr
operator|++
control|)
block|{
name|ahd_outw
argument_list|(
name|ahd
argument_list|,
name|SEEDAT
argument_list|,
operator|*
name|buf
operator|++
argument_list|)
expr_stmt|;
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|SEEADR
argument_list|,
name|cur_addr
argument_list|)
expr_stmt|;
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|SEECTL
argument_list|,
name|SEEOP_WRITE
operator||
name|SEESTART
argument_list|)
expr_stmt|;
name|retval
operator|=
name|ahd_wait_seeprom
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
condition|)
break|break;
block|}
comment|/* 	 * Disable writes. 	 */
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|SEEADR
argument_list|,
name|SEEOP_EWDS_ADDR
argument_list|)
expr_stmt|;
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|SEECTL
argument_list|,
name|SEEOP_EWDS
operator||
name|SEESTART
argument_list|)
expr_stmt|;
name|error
operator|=
name|ahd_wait_seeprom
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Wait ~100us for the serial eeprom to satisfy our request.  */
end_comment

begin_function
name|int
name|ahd_wait_seeprom
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|)
block|{
name|int
name|cnt
decl_stmt|;
name|cnt
operator|=
literal|5000
expr_stmt|;
while|while
condition|(
operator|(
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|SEESTAT
argument_list|)
operator|&
operator|(
name|SEEARBACK
operator||
name|SEEBUSY
operator|)
operator|)
operator|!=
literal|0
operator|&&
operator|--
name|cnt
condition|)
name|aic_delay
argument_list|(
literal|5
argument_list|)
expr_stmt|;
if|if
condition|(
name|cnt
operator|==
literal|0
condition|)
return|return
operator|(
name|ETIMEDOUT
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Validate the two checksums in the per_channel  * vital product data struct.  */
end_comment

begin_function
name|int
name|ahd_verify_vpd_cksum
parameter_list|(
name|struct
name|vpd_config
modifier|*
name|vpd
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|maxaddr
decl_stmt|;
name|uint32_t
name|checksum
decl_stmt|;
name|uint8_t
modifier|*
name|vpdarray
decl_stmt|;
name|vpdarray
operator|=
operator|(
name|uint8_t
operator|*
operator|)
name|vpd
expr_stmt|;
name|maxaddr
operator|=
name|offsetof
argument_list|(
expr|struct
name|vpd_config
argument_list|,
name|vpd_checksum
argument_list|)
expr_stmt|;
name|checksum
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|offsetof
argument_list|(
expr|struct
name|vpd_config
argument_list|,
name|resource_type
argument_list|)
init|;
name|i
operator|<
name|maxaddr
condition|;
name|i
operator|++
control|)
name|checksum
operator|=
name|checksum
operator|+
name|vpdarray
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|checksum
operator|==
literal|0
operator|||
operator|(
operator|-
name|checksum
operator|&
literal|0xFF
operator|)
operator|!=
name|vpd
operator|->
name|vpd_checksum
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|checksum
operator|=
literal|0
expr_stmt|;
name|maxaddr
operator|=
name|offsetof
argument_list|(
expr|struct
name|vpd_config
argument_list|,
name|checksum
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|offsetof
argument_list|(
expr|struct
name|vpd_config
argument_list|,
name|default_target_flags
argument_list|)
init|;
name|i
operator|<
name|maxaddr
condition|;
name|i
operator|++
control|)
name|checksum
operator|=
name|checksum
operator|+
name|vpdarray
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|checksum
operator|==
literal|0
operator|||
operator|(
operator|-
name|checksum
operator|&
literal|0xFF
operator|)
operator|!=
name|vpd
operator|->
name|checksum
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ahd_verify_cksum
parameter_list|(
name|struct
name|seeprom_config
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|maxaddr
decl_stmt|;
name|uint32_t
name|checksum
decl_stmt|;
name|uint16_t
modifier|*
name|scarray
decl_stmt|;
name|maxaddr
operator|=
operator|(
sizeof|sizeof
argument_list|(
operator|*
name|sc
argument_list|)
operator|/
literal|2
operator|)
operator|-
literal|1
expr_stmt|;
name|checksum
operator|=
literal|0
expr_stmt|;
name|scarray
operator|=
operator|(
name|uint16_t
operator|*
operator|)
name|sc
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|maxaddr
condition|;
name|i
operator|++
control|)
name|checksum
operator|=
name|checksum
operator|+
name|scarray
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|checksum
operator|==
literal|0
operator|||
operator|(
name|checksum
operator|&
literal|0xFFFF
operator|)
operator|!=
name|sc
operator|->
name|checksum
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
block|{
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
end_function

begin_function
name|int
name|ahd_acquire_seeprom
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|)
block|{
comment|/* 	 * We should be able to determine the SEEPROM type 	 * from the flexport logic, but unfortunately not 	 * all implementations have this logic and there is 	 * no programatic method for determining if the logic 	 * is present. 	 */
return|return
operator|(
literal|1
operator|)
return|;
if|#
directive|if
literal|0
block|uint8_t	seetype; 	int	error;  	error = ahd_read_flexport(ahd, FLXADDR_ROMSTAT_CURSENSECTL,&seetype); 	if (error != 0          || ((seetype& FLX_ROMSTAT_SEECFG) == FLX_ROMSTAT_SEE_NONE)) 		return (0); 	return (1);
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|ahd_release_seeprom
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|)
block|{
comment|/* Currently a no-op */
block|}
end_function

begin_function
name|int
name|ahd_write_flexport
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|,
name|u_int
name|addr
parameter_list|,
name|u_int
name|value
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|AHD_ASSERT_MODES
argument_list|(
name|ahd
argument_list|,
name|AHD_MODE_SCSI_MSK
argument_list|,
name|AHD_MODE_SCSI_MSK
argument_list|)
expr_stmt|;
if|if
condition|(
name|addr
operator|>
literal|7
condition|)
name|panic
argument_list|(
literal|"ahd_write_flexport: address out of range"
argument_list|)
expr_stmt|;
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|BRDCTL
argument_list|,
name|BRDEN
operator||
operator|(
name|addr
operator|<<
literal|3
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|ahd_wait_flexport
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|BRDDAT
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|ahd_flush_device_writes
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|BRDCTL
argument_list|,
name|BRDSTB
operator||
name|BRDEN
operator||
operator|(
name|addr
operator|<<
literal|3
operator|)
argument_list|)
expr_stmt|;
name|ahd_flush_device_writes
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|BRDCTL
argument_list|,
name|BRDEN
operator||
operator|(
name|addr
operator|<<
literal|3
operator|)
argument_list|)
expr_stmt|;
name|ahd_flush_device_writes
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|BRDCTL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ahd_flush_device_writes
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ahd_read_flexport
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|,
name|u_int
name|addr
parameter_list|,
name|uint8_t
modifier|*
name|value
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|AHD_ASSERT_MODES
argument_list|(
name|ahd
argument_list|,
name|AHD_MODE_SCSI_MSK
argument_list|,
name|AHD_MODE_SCSI_MSK
argument_list|)
expr_stmt|;
if|if
condition|(
name|addr
operator|>
literal|7
condition|)
name|panic
argument_list|(
literal|"ahd_read_flexport: address out of range"
argument_list|)
expr_stmt|;
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|BRDCTL
argument_list|,
name|BRDRW
operator||
name|BRDEN
operator||
operator|(
name|addr
operator|<<
literal|3
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|ahd_wait_flexport
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
operator|*
name|value
operator|=
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|BRDDAT
argument_list|)
expr_stmt|;
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|BRDCTL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ahd_flush_device_writes
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Wait at most 2 seconds for flexport arbitration to succeed.  */
end_comment

begin_function
name|int
name|ahd_wait_flexport
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|)
block|{
name|int
name|cnt
decl_stmt|;
name|AHD_ASSERT_MODES
argument_list|(
name|ahd
argument_list|,
name|AHD_MODE_SCSI_MSK
argument_list|,
name|AHD_MODE_SCSI_MSK
argument_list|)
expr_stmt|;
name|cnt
operator|=
literal|1000000
operator|*
literal|2
operator|/
literal|5
expr_stmt|;
while|while
condition|(
operator|(
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|BRDCTL
argument_list|)
operator|&
name|FLXARBACK
operator|)
operator|==
literal|0
operator|&&
operator|--
name|cnt
condition|)
name|aic_delay
argument_list|(
literal|5
argument_list|)
expr_stmt|;
if|if
condition|(
name|cnt
operator|==
literal|0
condition|)
return|return
operator|(
name|ETIMEDOUT
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/************************* Target Mode ****************************************/
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|AHD_TARGET_MODE
end_ifdef

begin_function
name|cam_status
name|ahd_find_tmode_devs
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|,
name|struct
name|cam_sim
modifier|*
name|sim
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|,
name|struct
name|ahd_tmode_tstate
modifier|*
modifier|*
name|tstate
parameter_list|,
name|struct
name|ahd_tmode_lstate
modifier|*
modifier|*
name|lstate
parameter_list|,
name|int
name|notfound_failure
parameter_list|)
block|{
if|if
condition|(
operator|(
name|ahd
operator|->
name|features
operator|&
name|AHD_TARGETMODE
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|CAM_REQ_INVALID
operator|)
return|;
comment|/* 	 * Handle the 'black hole' device that sucks up 	 * requests to unattached luns on enabled targets. 	 */
if|if
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
operator|==
name|CAM_TARGET_WILDCARD
operator|&&
name|ccb
operator|->
name|ccb_h
operator|.
name|target_lun
operator|==
name|CAM_LUN_WILDCARD
condition|)
block|{
operator|*
name|tstate
operator|=
name|NULL
expr_stmt|;
operator|*
name|lstate
operator|=
name|ahd
operator|->
name|black_hole
expr_stmt|;
block|}
else|else
block|{
name|u_int
name|max_id
decl_stmt|;
name|max_id
operator|=
operator|(
name|ahd
operator|->
name|features
operator|&
name|AHD_WIDE
operator|)
condition|?
literal|15
else|:
literal|7
expr_stmt|;
if|if
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
operator|>
name|max_id
condition|)
return|return
operator|(
name|CAM_TID_INVALID
operator|)
return|;
if|if
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|target_lun
operator|>=
name|AHD_NUM_LUNS
condition|)
return|return
operator|(
name|CAM_LUN_INVALID
operator|)
return|;
operator|*
name|tstate
operator|=
name|ahd
operator|->
name|enabled_targets
index|[
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
index|]
expr_stmt|;
operator|*
name|lstate
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|*
name|tstate
operator|!=
name|NULL
condition|)
operator|*
name|lstate
operator|=
operator|(
operator|*
name|tstate
operator|)
operator|->
name|enabled_luns
index|[
name|ccb
operator|->
name|ccb_h
operator|.
name|target_lun
index|]
expr_stmt|;
block|}
if|if
condition|(
name|notfound_failure
operator|!=
literal|0
operator|&&
operator|*
name|lstate
operator|==
name|NULL
condition|)
return|return
operator|(
name|CAM_PATH_INVALID
operator|)
return|;
return|return
operator|(
name|CAM_REQ_CMP
operator|)
return|;
block|}
end_function

begin_function
name|void
name|ahd_handle_en_lun
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|,
name|struct
name|cam_sim
modifier|*
name|sim
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
block|{
if|#
directive|if
name|NOT_YET
name|struct
name|ahd_tmode_tstate
modifier|*
name|tstate
decl_stmt|;
name|struct
name|ahd_tmode_lstate
modifier|*
name|lstate
decl_stmt|;
name|struct
name|ccb_en_lun
modifier|*
name|cel
decl_stmt|;
name|cam_status
name|status
decl_stmt|;
name|u_int
name|target
decl_stmt|;
name|u_int
name|lun
decl_stmt|;
name|u_int
name|target_mask
decl_stmt|;
name|u_long
name|s
decl_stmt|;
name|char
name|channel
decl_stmt|;
name|status
operator|=
name|ahd_find_tmode_devs
argument_list|(
name|ahd
argument_list|,
name|sim
argument_list|,
name|ccb
argument_list|,
operator|&
name|tstate
argument_list|,
operator|&
name|lstate
argument_list|,
comment|/*notfound_failure*/
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|status
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|ahd
operator|->
name|features
operator|&
name|AHD_MULTIROLE
operator|)
operator|!=
literal|0
condition|)
block|{
name|u_int
name|our_id
decl_stmt|;
name|our_id
operator|=
name|ahd
operator|->
name|our_id
expr_stmt|;
if|if
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
operator|!=
name|our_id
condition|)
block|{
if|if
condition|(
operator|(
name|ahd
operator|->
name|features
operator|&
name|AHD_MULTI_TID
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|ahd
operator|->
name|flags
operator|&
name|AHD_INITIATORROLE
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* 				 * Only allow additional targets if 				 * the initiator role is disabled. 				 * The hardware cannot handle a re-select-in 				 * on the initiator id during a re-select-out 				 * on a different target id. 				 */
name|status
operator|=
name|CAM_TID_INVALID
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|ahd
operator|->
name|flags
operator|&
name|AHD_INITIATORROLE
operator|)
operator|!=
literal|0
operator|||
name|ahd
operator|->
name|enabled_luns
operator|>
literal|0
condition|)
block|{
comment|/* 				 * Only allow our target id to change 				 * if the initiator role is not configured 				 * and there are no enabled luns which 				 * are attached to the currently registered 				 * scsi id. 				 */
name|status
operator|=
name|CAM_TID_INVALID
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|status
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|status
expr_stmt|;
return|return;
block|}
comment|/* 	 * We now have an id that is valid. 	 * If we aren't in target mode, switch modes. 	 */
if|if
condition|(
operator|(
name|ahd
operator|->
name|flags
operator|&
name|AHD_TARGETROLE
operator|)
operator|==
literal|0
operator|&&
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
operator|!=
name|CAM_TARGET_WILDCARD
condition|)
block|{
name|printf
argument_list|(
literal|"Configuring Target Mode\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|LIST_FIRST
argument_list|(
operator|&
name|ahd
operator|->
name|pending_scbs
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_BUSY
expr_stmt|;
return|return;
block|}
name|ahd
operator|->
name|flags
operator||=
name|AHD_TARGETROLE
expr_stmt|;
if|if
condition|(
operator|(
name|ahd
operator|->
name|features
operator|&
name|AHD_MULTIROLE
operator|)
operator|==
literal|0
condition|)
name|ahd
operator|->
name|flags
operator|&=
operator|~
name|AHD_INITIATORROLE
expr_stmt|;
name|ahd_pause
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
name|ahd_loadseq
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
name|ahd_restart
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
block|}
name|cel
operator|=
operator|&
name|ccb
operator|->
name|cel
expr_stmt|;
name|target
operator|=
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
expr_stmt|;
name|lun
operator|=
name|ccb
operator|->
name|ccb_h
operator|.
name|target_lun
expr_stmt|;
name|channel
operator|=
name|SIM_CHANNEL
argument_list|(
name|ahd
argument_list|,
name|sim
argument_list|)
expr_stmt|;
name|target_mask
operator|=
literal|0x01
operator|<<
name|target
expr_stmt|;
if|if
condition|(
name|channel
operator|==
literal|'B'
condition|)
name|target_mask
operator|<<=
literal|8
expr_stmt|;
if|if
condition|(
name|cel
operator|->
name|enable
operator|!=
literal|0
condition|)
block|{
name|u_int
name|scsiseq1
decl_stmt|;
comment|/* Are we already enabled?? */
if|if
condition|(
name|lstate
operator|!=
name|NULL
condition|)
block|{
name|xpt_print_path
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Lun already enabled\n"
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_LUN_ALRDY_ENA
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|cel
operator|->
name|grp6_len
operator|!=
literal|0
operator|||
name|cel
operator|->
name|grp7_len
operator|!=
literal|0
condition|)
block|{
comment|/* 			 * Don't (yet?) support vendor 			 * specific commands. 			 */
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_INVALID
expr_stmt|;
name|printf
argument_list|(
literal|"Non-zero Group Codes\n"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 		 * Seems to be okay. 		 * Setup our data structures. 		 */
if|if
condition|(
name|target
operator|!=
name|CAM_TARGET_WILDCARD
operator|&&
name|tstate
operator|==
name|NULL
condition|)
block|{
name|tstate
operator|=
name|ahd_alloc_tstate
argument_list|(
name|ahd
argument_list|,
name|target
argument_list|,
name|channel
argument_list|)
expr_stmt|;
if|if
condition|(
name|tstate
operator|==
name|NULL
condition|)
block|{
name|xpt_print_path
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Couldn't allocate tstate\n"
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_RESRC_UNAVAIL
expr_stmt|;
return|return;
block|}
block|}
name|lstate
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|lstate
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|lstate
operator|==
name|NULL
condition|)
block|{
name|xpt_print_path
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Couldn't allocate lstate\n"
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_RESRC_UNAVAIL
expr_stmt|;
return|return;
block|}
name|memset
argument_list|(
name|lstate
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|lstate
argument_list|)
argument_list|)
expr_stmt|;
name|status
operator|=
name|xpt_create_path
argument_list|(
operator|&
name|lstate
operator|->
name|path
argument_list|,
comment|/*periph*/
name|NULL
argument_list|,
name|xpt_path_path_id
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|)
argument_list|,
name|xpt_path_target_id
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|)
argument_list|,
name|xpt_path_lun_id
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|free
argument_list|(
name|lstate
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|xpt_print_path
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Couldn't allocate path\n"
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_RESRC_UNAVAIL
expr_stmt|;
return|return;
block|}
name|SLIST_INIT
argument_list|(
operator|&
name|lstate
operator|->
name|accept_tios
argument_list|)
expr_stmt|;
name|SLIST_INIT
argument_list|(
operator|&
name|lstate
operator|->
name|immed_notifies
argument_list|)
expr_stmt|;
name|ahd_pause
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
operator|!=
name|CAM_TARGET_WILDCARD
condition|)
block|{
name|tstate
operator|->
name|enabled_luns
index|[
name|lun
index|]
operator|=
name|lstate
expr_stmt|;
name|ahd
operator|->
name|enabled_luns
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|ahd
operator|->
name|features
operator|&
name|AHD_MULTI_TID
operator|)
operator|!=
literal|0
condition|)
block|{
name|u_int
name|targid_mask
decl_stmt|;
name|targid_mask
operator|=
name|ahd_inw
argument_list|(
name|ahd
argument_list|,
name|TARGID
argument_list|)
expr_stmt|;
name|targid_mask
operator||=
name|target_mask
expr_stmt|;
name|ahd_outw
argument_list|(
name|ahd
argument_list|,
name|TARGID
argument_list|,
name|targid_mask
argument_list|)
expr_stmt|;
name|ahd_update_scsiid
argument_list|(
name|ahd
argument_list|,
name|targid_mask
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|u_int
name|our_id
decl_stmt|;
name|char
name|channel
decl_stmt|;
name|channel
operator|=
name|SIM_CHANNEL
argument_list|(
name|ahd
argument_list|,
name|sim
argument_list|)
expr_stmt|;
name|our_id
operator|=
name|SIM_SCSI_ID
argument_list|(
name|ahd
argument_list|,
name|sim
argument_list|)
expr_stmt|;
comment|/* 				 * This can only happen if selections 				 * are not enabled 				 */
if|if
condition|(
name|target
operator|!=
name|our_id
condition|)
block|{
name|u_int
name|sblkctl
decl_stmt|;
name|char
name|cur_channel
decl_stmt|;
name|int
name|swap
decl_stmt|;
name|sblkctl
operator|=
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|SBLKCTL
argument_list|)
expr_stmt|;
name|cur_channel
operator|=
operator|(
name|sblkctl
operator|&
name|SELBUSB
operator|)
condition|?
literal|'B'
else|:
literal|'A'
expr_stmt|;
if|if
condition|(
operator|(
name|ahd
operator|->
name|features
operator|&
name|AHD_TWIN
operator|)
operator|==
literal|0
condition|)
name|cur_channel
operator|=
literal|'A'
expr_stmt|;
name|swap
operator|=
name|cur_channel
operator|!=
name|channel
expr_stmt|;
name|ahd
operator|->
name|our_id
operator|=
name|target
expr_stmt|;
if|if
condition|(
name|swap
condition|)
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|SBLKCTL
argument_list|,
name|sblkctl
operator|^
name|SELBUSB
argument_list|)
expr_stmt|;
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|SCSIID
argument_list|,
name|target
argument_list|)
expr_stmt|;
if|if
condition|(
name|swap
condition|)
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|SBLKCTL
argument_list|,
name|sblkctl
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
name|ahd
operator|->
name|black_hole
operator|=
name|lstate
expr_stmt|;
comment|/* Allow select-in operations */
if|if
condition|(
name|ahd
operator|->
name|black_hole
operator|!=
name|NULL
operator|&&
name|ahd
operator|->
name|enabled_luns
operator|>
literal|0
condition|)
block|{
name|scsiseq1
operator|=
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|SCSISEQ_TEMPLATE
argument_list|)
expr_stmt|;
name|scsiseq1
operator||=
name|ENSELI
expr_stmt|;
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|SCSISEQ_TEMPLATE
argument_list|,
name|scsiseq1
argument_list|)
expr_stmt|;
name|scsiseq1
operator|=
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|SCSISEQ1
argument_list|)
expr_stmt|;
name|scsiseq1
operator||=
name|ENSELI
expr_stmt|;
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|SCSISEQ1
argument_list|,
name|scsiseq1
argument_list|)
expr_stmt|;
block|}
name|ahd_unpause
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
name|xpt_print_path
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Lun now enabled for target mode\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|struct
name|scb
modifier|*
name|scb
decl_stmt|;
name|int
name|i
decl_stmt|,
name|empty
decl_stmt|;
if|if
condition|(
name|lstate
operator|==
name|NULL
condition|)
block|{
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_LUN_INVALID
expr_stmt|;
return|return;
block|}
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|scb
argument_list|,
argument|&ahd->pending_scbs
argument_list|,
argument|pending_links
argument_list|)
block|{
name|struct
name|ccb_hdr
modifier|*
name|ccbh
decl_stmt|;
name|ccbh
operator|=
operator|&
name|scb
operator|->
name|io_ctx
operator|->
name|ccb_h
expr_stmt|;
if|if
condition|(
name|ccbh
operator|->
name|func_code
operator|==
name|XPT_CONT_TARGET_IO
operator|&&
operator|!
name|xpt_path_comp
argument_list|(
name|ccbh
operator|->
name|path
argument_list|,
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"CTIO pending\n"
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_INVALID
expr_stmt|;
return|return;
block|}
block|}
if|if
condition|(
name|SLIST_FIRST
argument_list|(
operator|&
name|lstate
operator|->
name|accept_tios
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"ATIOs pending\n"
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_INVALID
expr_stmt|;
block|}
if|if
condition|(
name|SLIST_FIRST
argument_list|(
operator|&
name|lstate
operator|->
name|immed_notifies
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"INOTs pending\n"
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_INVALID
expr_stmt|;
block|}
if|if
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
return|return;
block|}
name|xpt_print_path
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Target mode disabled\n"
argument_list|)
expr_stmt|;
name|xpt_free_path
argument_list|(
name|lstate
operator|->
name|path
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|lstate
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|ahd_pause
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
comment|/* Can we clean up the target too? */
if|if
condition|(
name|target
operator|!=
name|CAM_TARGET_WILDCARD
condition|)
block|{
name|tstate
operator|->
name|enabled_luns
index|[
name|lun
index|]
operator|=
name|NULL
expr_stmt|;
name|ahd
operator|->
name|enabled_luns
operator|--
expr_stmt|;
for|for
control|(
name|empty
operator|=
literal|1
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|tstate
operator|->
name|enabled_luns
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
block|{
name|empty
operator|=
literal|0
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|empty
condition|)
block|{
name|ahd_free_tstate
argument_list|(
name|ahd
argument_list|,
name|target
argument_list|,
name|channel
argument_list|,
comment|/*force*/
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|ahd
operator|->
name|features
operator|&
name|AHD_MULTI_TID
condition|)
block|{
name|u_int
name|targid_mask
decl_stmt|;
name|targid_mask
operator|=
name|ahd_inw
argument_list|(
name|ahd
argument_list|,
name|TARGID
argument_list|)
expr_stmt|;
name|targid_mask
operator|&=
operator|~
name|target_mask
expr_stmt|;
name|ahd_outw
argument_list|(
name|ahd
argument_list|,
name|TARGID
argument_list|,
name|targid_mask
argument_list|)
expr_stmt|;
name|ahd_update_scsiid
argument_list|(
name|ahd
argument_list|,
name|targid_mask
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|ahd
operator|->
name|black_hole
operator|=
name|NULL
expr_stmt|;
comment|/* 			 * We can't allow selections without 			 * our black hole device. 			 */
name|empty
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
name|ahd
operator|->
name|enabled_luns
operator|==
literal|0
condition|)
block|{
comment|/* Disallow select-in */
name|u_int
name|scsiseq1
decl_stmt|;
name|scsiseq1
operator|=
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|SCSISEQ_TEMPLATE
argument_list|)
expr_stmt|;
name|scsiseq1
operator|&=
operator|~
name|ENSELI
expr_stmt|;
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|SCSISEQ_TEMPLATE
argument_list|,
name|scsiseq1
argument_list|)
expr_stmt|;
name|scsiseq1
operator|=
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|SCSISEQ1
argument_list|)
expr_stmt|;
name|scsiseq1
operator|&=
operator|~
name|ENSELI
expr_stmt|;
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|SCSISEQ1
argument_list|,
name|scsiseq1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ahd
operator|->
name|features
operator|&
name|AHD_MULTIROLE
operator|)
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"Configuring Initiator Mode\n"
argument_list|)
expr_stmt|;
name|ahd
operator|->
name|flags
operator|&=
operator|~
name|AHD_TARGETROLE
expr_stmt|;
name|ahd
operator|->
name|flags
operator||=
name|AHD_INITIATORROLE
expr_stmt|;
name|ahd_pause
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
name|ahd_loadseq
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
name|ahd_restart
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
comment|/* 				 * Unpaused.  The extra unpause 				 * that follows is harmless. 				 */
block|}
block|}
name|ahd_unpause
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|void
name|ahd_update_scsiid
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|,
name|u_int
name|targid_mask
parameter_list|)
block|{
if|#
directive|if
name|NOT_YET
name|u_int
name|scsiid_mask
decl_stmt|;
name|u_int
name|scsiid
decl_stmt|;
if|if
condition|(
operator|(
name|ahd
operator|->
name|features
operator|&
name|AHD_MULTI_TID
operator|)
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"ahd_update_scsiid called on non-multitid unit\n"
argument_list|)
expr_stmt|;
comment|/* 	 * Since we will rely on the TARGID mask 	 * for selection enables, ensure that OID 	 * in SCSIID is not set to some other ID 	 * that we don't want to allow selections on. 	 */
if|if
condition|(
operator|(
name|ahd
operator|->
name|features
operator|&
name|AHD_ULTRA2
operator|)
operator|!=
literal|0
condition|)
name|scsiid
operator|=
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|SCSIID_ULTRA2
argument_list|)
expr_stmt|;
else|else
name|scsiid
operator|=
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|SCSIID
argument_list|)
expr_stmt|;
name|scsiid_mask
operator|=
literal|0x1
operator|<<
operator|(
name|scsiid
operator|&
name|OID
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|targid_mask
operator|&
name|scsiid_mask
operator|)
operator|==
literal|0
condition|)
block|{
name|u_int
name|our_id
decl_stmt|;
comment|/* ffs counts from 1 */
name|our_id
operator|=
name|ffs
argument_list|(
name|targid_mask
argument_list|)
expr_stmt|;
if|if
condition|(
name|our_id
operator|==
literal|0
condition|)
name|our_id
operator|=
name|ahd
operator|->
name|our_id
expr_stmt|;
else|else
name|our_id
operator|--
expr_stmt|;
name|scsiid
operator|&=
name|TID
expr_stmt|;
name|scsiid
operator||=
name|our_id
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|ahd
operator|->
name|features
operator|&
name|AHD_ULTRA2
operator|)
operator|!=
literal|0
condition|)
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|SCSIID_ULTRA2
argument_list|,
name|scsiid
argument_list|)
expr_stmt|;
else|else
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|SCSIID
argument_list|,
name|scsiid
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|ahd_run_tqinfifo
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|,
name|int
name|paused
parameter_list|)
block|{
name|struct
name|target_cmd
modifier|*
name|cmd
decl_stmt|;
name|ahd_sync_tqinfifo
argument_list|(
name|ahd
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|cmd
operator|=
operator|&
name|ahd
operator|->
name|targetcmds
index|[
name|ahd
operator|->
name|tqinfifonext
index|]
operator|)
operator|->
name|cmd_valid
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * Only advance through the queue if we 		 * have the resources to process the command. 		 */
if|if
condition|(
name|ahd_handle_target_cmd
argument_list|(
name|ahd
argument_list|,
name|cmd
argument_list|)
operator|!=
literal|0
condition|)
break|break;
name|cmd
operator|->
name|cmd_valid
operator|=
literal|0
expr_stmt|;
name|ahd_dmamap_sync
argument_list|(
name|ahd
argument_list|,
name|ahd
operator|->
name|shared_data_dmat
argument_list|,
name|ahd
operator|->
name|shared_data_dmamap
argument_list|,
name|ahd_targetcmd_offset
argument_list|(
name|ahd
argument_list|,
name|ahd
operator|->
name|tqinfifonext
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|target_cmd
argument_list|)
argument_list|,
name|BUS_DMASYNC_PREREAD
argument_list|)
expr_stmt|;
name|ahd
operator|->
name|tqinfifonext
operator|++
expr_stmt|;
comment|/* 		 * Lazily update our position in the target mode incoming 		 * command queue as seen by the sequencer. 		 */
if|if
condition|(
operator|(
name|ahd
operator|->
name|tqinfifonext
operator|&
operator|(
name|HOST_TQINPOS
operator|-
literal|1
operator|)
operator|)
operator|==
literal|1
condition|)
block|{
name|u_int
name|hs_mailbox
decl_stmt|;
name|hs_mailbox
operator|=
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|HS_MAILBOX
argument_list|)
expr_stmt|;
name|hs_mailbox
operator|&=
operator|~
name|HOST_TQINPOS
expr_stmt|;
name|hs_mailbox
operator||=
name|ahd
operator|->
name|tqinfifonext
operator|&
name|HOST_TQINPOS
expr_stmt|;
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|HS_MAILBOX
argument_list|,
name|hs_mailbox
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|ahd_handle_target_cmd
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|,
name|struct
name|target_cmd
modifier|*
name|cmd
parameter_list|)
block|{
name|struct
name|ahd_tmode_tstate
modifier|*
name|tstate
decl_stmt|;
name|struct
name|ahd_tmode_lstate
modifier|*
name|lstate
decl_stmt|;
name|struct
name|ccb_accept_tio
modifier|*
name|atio
decl_stmt|;
name|uint8_t
modifier|*
name|byte
decl_stmt|;
name|int
name|initiator
decl_stmt|;
name|int
name|target
decl_stmt|;
name|int
name|lun
decl_stmt|;
name|initiator
operator|=
name|SCSIID_TARGET
argument_list|(
name|ahd
argument_list|,
name|cmd
operator|->
name|scsiid
argument_list|)
expr_stmt|;
name|target
operator|=
name|SCSIID_OUR_ID
argument_list|(
name|cmd
operator|->
name|scsiid
argument_list|)
expr_stmt|;
name|lun
operator|=
operator|(
name|cmd
operator|->
name|identify
operator|&
name|MSG_IDENTIFY_LUNMASK
operator|)
expr_stmt|;
name|byte
operator|=
name|cmd
operator|->
name|bytes
expr_stmt|;
name|tstate
operator|=
name|ahd
operator|->
name|enabled_targets
index|[
name|target
index|]
expr_stmt|;
name|lstate
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|tstate
operator|!=
name|NULL
condition|)
name|lstate
operator|=
name|tstate
operator|->
name|enabled_luns
index|[
name|lun
index|]
expr_stmt|;
comment|/* 	 * Commands for disabled luns go to the black hole driver. 	 */
if|if
condition|(
name|lstate
operator|==
name|NULL
condition|)
name|lstate
operator|=
name|ahd
operator|->
name|black_hole
expr_stmt|;
name|atio
operator|=
operator|(
expr|struct
name|ccb_accept_tio
operator|*
operator|)
name|SLIST_FIRST
argument_list|(
operator|&
name|lstate
operator|->
name|accept_tios
argument_list|)
expr_stmt|;
if|if
condition|(
name|atio
operator|==
name|NULL
condition|)
block|{
name|ahd
operator|->
name|flags
operator||=
name|AHD_TQINFIFO_BLOCKED
expr_stmt|;
comment|/* 		 * Wait for more ATIOs from the peripheral driver for this lun. 		 */
return|return
operator|(
literal|1
operator|)
return|;
block|}
else|else
name|ahd
operator|->
name|flags
operator|&=
operator|~
name|AHD_TQINFIFO_BLOCKED
expr_stmt|;
ifdef|#
directive|ifdef
name|AHD_DEBUG
if|if
condition|(
operator|(
name|ahd_debug
operator|&
name|AHD_SHOW_TQIN
operator|)
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|"Incoming command from %d for %d:%d%s\n"
argument_list|,
name|initiator
argument_list|,
name|target
argument_list|,
name|lun
argument_list|,
name|lstate
operator|==
name|ahd
operator|->
name|black_hole
condition|?
literal|"(Black Holed)"
else|:
literal|""
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|SLIST_REMOVE_HEAD
argument_list|(
operator|&
name|lstate
operator|->
name|accept_tios
argument_list|,
name|sim_links
operator|.
name|sle
argument_list|)
expr_stmt|;
if|if
condition|(
name|lstate
operator|==
name|ahd
operator|->
name|black_hole
condition|)
block|{
comment|/* Fill in the wildcards */
name|atio
operator|->
name|ccb_h
operator|.
name|target_id
operator|=
name|target
expr_stmt|;
name|atio
operator|->
name|ccb_h
operator|.
name|target_lun
operator|=
name|lun
expr_stmt|;
block|}
comment|/* 	 * Package it up and send it off to 	 * whomever has this lun enabled. 	 */
name|atio
operator|->
name|sense_len
operator|=
literal|0
expr_stmt|;
name|atio
operator|->
name|init_id
operator|=
name|initiator
expr_stmt|;
if|if
condition|(
name|byte
index|[
literal|0
index|]
operator|!=
literal|0xFF
condition|)
block|{
comment|/* Tag was included */
name|atio
operator|->
name|tag_action
operator|=
operator|*
name|byte
operator|++
expr_stmt|;
name|atio
operator|->
name|tag_id
operator|=
operator|*
name|byte
operator|++
expr_stmt|;
name|atio
operator|->
name|ccb_h
operator|.
name|flags
operator|=
name|CAM_TAG_ACTION_VALID
expr_stmt|;
block|}
else|else
block|{
name|atio
operator|->
name|ccb_h
operator|.
name|flags
operator|=
literal|0
expr_stmt|;
block|}
name|byte
operator|++
expr_stmt|;
comment|/* Okay.  Now determine the cdb size based on the command code */
switch|switch
condition|(
operator|*
name|byte
operator|>>
name|CMD_GROUP_CODE_SHIFT
condition|)
block|{
case|case
literal|0
case|:
name|atio
operator|->
name|cdb_len
operator|=
literal|6
expr_stmt|;
break|break;
case|case
literal|1
case|:
case|case
literal|2
case|:
name|atio
operator|->
name|cdb_len
operator|=
literal|10
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|atio
operator|->
name|cdb_len
operator|=
literal|16
expr_stmt|;
break|break;
case|case
literal|5
case|:
name|atio
operator|->
name|cdb_len
operator|=
literal|12
expr_stmt|;
break|break;
case|case
literal|3
case|:
default|default:
comment|/* Only copy the opcode. */
name|atio
operator|->
name|cdb_len
operator|=
literal|1
expr_stmt|;
name|printf
argument_list|(
literal|"Reserved or VU command code type encountered\n"
argument_list|)
expr_stmt|;
break|break;
block|}
name|memcpy
argument_list|(
name|atio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
argument_list|,
name|byte
argument_list|,
name|atio
operator|->
name|cdb_len
argument_list|)
expr_stmt|;
name|atio
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_CDB_RECVD
expr_stmt|;
if|if
condition|(
operator|(
name|cmd
operator|->
name|identify
operator|&
name|MSG_IDENTIFY_DISCFLAG
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 		 * We weren't allowed to disconnect. 		 * We're hanging on the bus until a 		 * continue target I/O comes in response 		 * to this accept tio. 		 */
ifdef|#
directive|ifdef
name|AHD_DEBUG
if|if
condition|(
operator|(
name|ahd_debug
operator|&
name|AHD_SHOW_TQIN
operator|)
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|"Received Immediate Command %d:%d:%d - %p\n"
argument_list|,
name|initiator
argument_list|,
name|target
argument_list|,
name|lun
argument_list|,
name|ahd
operator|->
name|pending_device
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ahd
operator|->
name|pending_device
operator|=
name|lstate
expr_stmt|;
name|ahd_freeze_ccb
argument_list|(
operator|(
expr|union
name|ccb
operator|*
operator|)
name|atio
argument_list|)
expr_stmt|;
name|atio
operator|->
name|ccb_h
operator|.
name|flags
operator||=
name|CAM_DIS_DISCONNECT
expr_stmt|;
block|}
name|xpt_done
argument_list|(
operator|(
expr|union
name|ccb
operator|*
operator|)
name|atio
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

