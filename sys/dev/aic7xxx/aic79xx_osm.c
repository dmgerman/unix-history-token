begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Bus independent FreeBSD shim for the aic79xx based Adaptec SCSI controllers  *  * Copyright (c) 1994-2002, 2004 Justin T. Gibbs.  * Copyright (c) 2001-2002 Adaptec Inc.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions, and the following disclaimer,  *    without modification.  * 2. The name of the author may not be used to endorse or promote products  *    derived from this software without specific prior written permission.  *  * Alternatively, this software may be distributed under the terms of the  * GNU Public License ("GPL").  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE FOR  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $Id: //depot/aic7xxx/freebsd/dev/aic7xxx/aic79xx_osm.c#35 $  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<dev/aic7xxx/aic79xx_osm.h>
end_include

begin_include
include|#
directive|include
file|<dev/aic7xxx/aic79xx_inline.h>
end_include

begin_include
include|#
directive|include
file|<sys/kthread.h>
end_include

begin_include
include|#
directive|include
file|"opt_ddb.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|DDB
end_ifdef

begin_include
include|#
directive|include
file|<ddb/ddb.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|AHD_TMODE_ENABLE
end_ifndef

begin_define
define|#
directive|define
name|AHD_TMODE_ENABLE
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<dev/aic7xxx/aic_osm_lib.c>
end_include

begin_define
define|#
directive|define
name|ccb_scb_ptr
value|spriv_ptr0
end_define

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static void	ahd_dump_targcmd(struct target_cmd *cmd);
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|int
name|ahd_modevent
parameter_list|(
name|module_t
name|mod
parameter_list|,
name|int
name|type
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ahd_action
parameter_list|(
name|struct
name|cam_sim
modifier|*
name|sim
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ahd_set_tran_settings
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|,
name|int
name|our_id
parameter_list|,
name|char
name|channel
parameter_list|,
name|struct
name|ccb_trans_settings
modifier|*
name|cts
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ahd_get_tran_settings
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|,
name|int
name|our_id
parameter_list|,
name|char
name|channel
parameter_list|,
name|struct
name|ccb_trans_settings
modifier|*
name|cts
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ahd_async
parameter_list|(
name|void
modifier|*
name|callback_arg
parameter_list|,
name|uint32_t
name|code
parameter_list|,
name|struct
name|cam_path
modifier|*
name|path
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ahd_execute_scb
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|dm_segs
parameter_list|,
name|int
name|nsegments
parameter_list|,
name|int
name|error
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ahd_poll
parameter_list|(
name|struct
name|cam_sim
modifier|*
name|sim
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ahd_setup_data
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|,
name|struct
name|cam_sim
modifier|*
name|sim
parameter_list|,
name|struct
name|ccb_scsiio
modifier|*
name|csio
parameter_list|,
name|struct
name|scb
modifier|*
name|scb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ahd_abort_ccb
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|,
name|struct
name|cam_sim
modifier|*
name|sim
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ahd_create_path
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|,
name|char
name|channel
parameter_list|,
name|u_int
name|target
parameter_list|,
name|u_int
name|lun
parameter_list|,
name|struct
name|cam_path
modifier|*
modifier|*
name|path
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|int
name|ahd_create_path
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|,
name|char
name|channel
parameter_list|,
name|u_int
name|target
parameter_list|,
name|u_int
name|lun
parameter_list|,
name|struct
name|cam_path
modifier|*
modifier|*
name|path
parameter_list|)
block|{
name|path_id_t
name|path_id
decl_stmt|;
name|path_id
operator|=
name|cam_sim_path
argument_list|(
name|ahd
operator|->
name|platform_data
operator|->
name|sim
argument_list|)
expr_stmt|;
return|return
operator|(
name|xpt_create_path
argument_list|(
name|path
argument_list|,
comment|/*periph*/
name|NULL
argument_list|,
name|path_id
argument_list|,
name|target
argument_list|,
name|lun
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ahd_map_int
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
comment|/* Hook up our interrupt handler */
name|error
operator|=
name|bus_setup_intr
argument_list|(
name|ahd
operator|->
name|dev_softc
argument_list|,
name|ahd
operator|->
name|platform_data
operator|->
name|irq
argument_list|,
name|INTR_TYPE_CAM
argument_list|,
name|NULL
argument_list|,
name|ahd_platform_intr
argument_list|,
name|ahd
argument_list|,
operator|&
name|ahd
operator|->
name|platform_data
operator|->
name|ih
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
name|device_printf
argument_list|(
name|ahd
operator|->
name|dev_softc
argument_list|,
literal|"bus_setup_intr() failed: %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Attach all the sub-devices we can find  */
end_comment

begin_function
name|int
name|ahd_attach
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|)
block|{
name|char
name|ahd_info
index|[
literal|256
index|]
decl_stmt|;
name|struct
name|ccb_setasync
name|csa
decl_stmt|;
name|struct
name|cam_devq
modifier|*
name|devq
decl_stmt|;
name|struct
name|cam_sim
modifier|*
name|sim
decl_stmt|;
name|struct
name|cam_path
modifier|*
name|path
decl_stmt|;
name|long
name|s
decl_stmt|;
name|int
name|count
decl_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
name|devq
operator|=
name|NULL
expr_stmt|;
name|sim
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * Create a thread to perform all recovery. 	 */
if|if
condition|(
name|ahd_spawn_recovery_thread
argument_list|(
name|ahd
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|fail
goto|;
name|ahd_controller_info
argument_list|(
name|ahd
argument_list|,
name|ahd_info
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|ahd_info
argument_list|)
expr_stmt|;
name|ahd_lock
argument_list|(
name|ahd
argument_list|,
operator|&
name|s
argument_list|)
expr_stmt|;
comment|/* 	 * Create the device queue for our SIM(s). 	 */
name|devq
operator|=
name|cam_simq_alloc
argument_list|(
name|AHD_MAX_QUEUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|devq
operator|==
name|NULL
condition|)
goto|goto
name|fail
goto|;
comment|/* 	 * Construct our SIM entry 	 */
name|sim
operator|=
name|cam_sim_alloc
argument_list|(
name|ahd_action
argument_list|,
name|ahd_poll
argument_list|,
literal|"ahd"
argument_list|,
name|ahd
argument_list|,
name|device_get_unit
argument_list|(
name|ahd
operator|->
name|dev_softc
argument_list|)
argument_list|,
operator|&
name|Giant
argument_list|,
literal|1
argument_list|,
comment|/*XXX*/
literal|256
argument_list|,
name|devq
argument_list|)
expr_stmt|;
if|if
condition|(
name|sim
operator|==
name|NULL
condition|)
block|{
name|cam_simq_free
argument_list|(
name|devq
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
if|if
condition|(
name|xpt_bus_register
argument_list|(
name|sim
argument_list|,
comment|/*bus_id*/
literal|0
argument_list|)
operator|!=
name|CAM_SUCCESS
condition|)
block|{
name|cam_sim_free
argument_list|(
name|sim
argument_list|,
comment|/*free_devq*/
name|TRUE
argument_list|)
expr_stmt|;
name|sim
operator|=
name|NULL
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
if|if
condition|(
name|xpt_create_path
argument_list|(
operator|&
name|path
argument_list|,
comment|/*periph*/
name|NULL
argument_list|,
name|cam_sim_path
argument_list|(
name|sim
argument_list|)
argument_list|,
name|CAM_TARGET_WILDCARD
argument_list|,
name|CAM_LUN_WILDCARD
argument_list|)
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|xpt_bus_deregister
argument_list|(
name|cam_sim_path
argument_list|(
name|sim
argument_list|)
argument_list|)
expr_stmt|;
name|cam_sim_free
argument_list|(
name|sim
argument_list|,
comment|/*free_devq*/
name|TRUE
argument_list|)
expr_stmt|;
name|sim
operator|=
name|NULL
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|xpt_setup_ccb
argument_list|(
operator|&
name|csa
operator|.
name|ccb_h
argument_list|,
name|path
argument_list|,
comment|/*priority*/
literal|5
argument_list|)
expr_stmt|;
name|csa
operator|.
name|ccb_h
operator|.
name|func_code
operator|=
name|XPT_SASYNC_CB
expr_stmt|;
name|csa
operator|.
name|event_enable
operator|=
name|AC_LOST_DEVICE
expr_stmt|;
name|csa
operator|.
name|callback
operator|=
name|ahd_async
expr_stmt|;
name|csa
operator|.
name|callback_arg
operator|=
name|sim
expr_stmt|;
name|xpt_action
argument_list|(
operator|(
expr|union
name|ccb
operator|*
operator|)
operator|&
name|csa
argument_list|)
expr_stmt|;
name|count
operator|++
expr_stmt|;
name|fail
label|:
name|ahd
operator|->
name|platform_data
operator|->
name|sim
operator|=
name|sim
expr_stmt|;
name|ahd
operator|->
name|platform_data
operator|->
name|path
operator|=
name|path
expr_stmt|;
if|if
condition|(
name|count
operator|!=
literal|0
condition|)
block|{
comment|/* We have to wait until after any system dumps... */
name|ahd
operator|->
name|platform_data
operator|->
name|eh
operator|=
name|EVENTHANDLER_REGISTER
argument_list|(
name|shutdown_final
argument_list|,
name|ahd_shutdown
argument_list|,
name|ahd
argument_list|,
name|SHUTDOWN_PRI_DEFAULT
argument_list|)
expr_stmt|;
name|ahd_intr_enable
argument_list|(
name|ahd
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
name|ahd_unlock
argument_list|(
name|ahd
argument_list|,
operator|&
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|count
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Catch an interrupt from the adapter  */
end_comment

begin_function
name|void
name|ahd_platform_intr
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ahd_softc
modifier|*
name|ahd
decl_stmt|;
name|ahd
operator|=
operator|(
expr|struct
name|ahd_softc
operator|*
operator|)
name|arg
expr_stmt|;
name|ahd_intr
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * We have an scb which has been processed by the  * adaptor, now we look to see how the operation  * went.  */
end_comment

begin_function
name|void
name|ahd_done
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|,
name|struct
name|scb
modifier|*
name|scb
parameter_list|)
block|{
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|CAM_DEBUG
argument_list|(
name|scb
operator|->
name|io_ctx
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
name|CAM_DEBUG_TRACE
argument_list|,
operator|(
literal|"ahd_done - scb %d\n"
operator|,
name|SCB_GET_TAG
argument_list|(
name|scb
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|ccb
operator|=
name|scb
operator|->
name|io_ctx
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|scb
argument_list|,
name|pending_links
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|scb
operator|->
name|flags
operator|&
name|SCB_TIMEDOUT
operator|)
operator|!=
literal|0
condition|)
name|LIST_REMOVE
argument_list|(
name|scb
argument_list|,
name|timedout_links
argument_list|)
expr_stmt|;
name|untimeout
argument_list|(
name|ahd_platform_timeout
argument_list|,
operator|(
name|caddr_t
operator|)
name|scb
argument_list|,
name|ccb
operator|->
name|ccb_h
operator|.
name|timeout_ch
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DIR_MASK
operator|)
operator|!=
name|CAM_DIR_NONE
condition|)
block|{
name|bus_dmasync_op_t
name|op
decl_stmt|;
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DIR_MASK
operator|)
operator|==
name|CAM_DIR_IN
condition|)
name|op
operator|=
name|BUS_DMASYNC_POSTREAD
expr_stmt|;
else|else
name|op
operator|=
name|BUS_DMASYNC_POSTWRITE
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|ahd
operator|->
name|buffer_dmat
argument_list|,
name|scb
operator|->
name|dmamap
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|ahd
operator|->
name|buffer_dmat
argument_list|,
name|scb
operator|->
name|dmamap
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|AHD_TARGET_MODE
if|if
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|==
name|XPT_CONT_TARGET_IO
condition|)
block|{
name|struct
name|cam_path
modifier|*
name|ccb_path
decl_stmt|;
comment|/* 		 * If we have finally disconnected, clean up our 		 * pending device state. 		 * XXX - There may be error states that cause where 		 *       we will remain connected. 		 */
name|ccb_path
operator|=
name|ccb
operator|->
name|ccb_h
operator|.
name|path
expr_stmt|;
if|if
condition|(
name|ahd
operator|->
name|pending_device
operator|!=
name|NULL
operator|&&
name|xpt_path_comp
argument_list|(
name|ahd
operator|->
name|pending_device
operator|->
name|path
argument_list|,
name|ccb_path
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_SEND_STATUS
operator|)
operator|!=
literal|0
condition|)
block|{
name|ahd
operator|->
name|pending_device
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|xpt_print_path
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Still disconnected\n"
argument_list|)
expr_stmt|;
name|ahd_freeze_ccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|aic_get_transaction_status
argument_list|(
name|scb
argument_list|)
operator|==
name|CAM_REQ_INPROG
condition|)
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_REQ_CMP
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&=
operator|~
name|CAM_SIM_QUEUED
expr_stmt|;
name|ahd_free_scb
argument_list|(
name|ahd
argument_list|,
name|scb
argument_list|)
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
if|if
condition|(
operator|(
name|scb
operator|->
name|flags
operator|&
name|SCB_RECOVERY_SCB
operator|)
operator|!=
literal|0
condition|)
block|{
name|struct
name|scb
modifier|*
name|list_scb
decl_stmt|;
name|ahd
operator|->
name|scb_data
operator|.
name|recovery_scbs
operator|--
expr_stmt|;
if|if
condition|(
name|aic_get_transaction_status
argument_list|(
name|scb
argument_list|)
operator|==
name|CAM_BDR_SENT
operator|||
name|aic_get_transaction_status
argument_list|(
name|scb
argument_list|)
operator|==
name|CAM_REQ_ABORTED
condition|)
name|aic_set_transaction_status
argument_list|(
name|scb
argument_list|,
name|CAM_CMD_TIMEOUT
argument_list|)
expr_stmt|;
if|if
condition|(
name|ahd
operator|->
name|scb_data
operator|.
name|recovery_scbs
operator|==
literal|0
condition|)
block|{
comment|/* 			 * All recovery actions have completed successfully, 			 * so reinstate the timeouts for all other pending 			 * commands. 			 */
name|LIST_FOREACH
argument_list|(
argument|list_scb
argument_list|,
argument|&ahd->pending_scbs
argument_list|,
argument|pending_links
argument_list|)
block|{
name|aic_scb_timer_reset
argument_list|(
name|list_scb
argument_list|,
name|aic_get_timeout
argument_list|(
name|scb
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|ahd_print_path
argument_list|(
name|ahd
argument_list|,
name|scb
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"no longer in timeout, status = %x\n"
argument_list|,
name|ccb
operator|->
name|ccb_h
operator|.
name|status
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Don't clobber any existing error state */
if|if
condition|(
name|aic_get_transaction_status
argument_list|(
name|scb
argument_list|)
operator|==
name|CAM_REQ_INPROG
condition|)
block|{
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_REQ_CMP
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|scb
operator|->
name|flags
operator|&
name|SCB_SENSE
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * We performed autosense retrieval. 		 * 		 * Zero any sense not transferred by the 		 * device.  The SCSI spec mandates that any 		 * untransfered data should be assumed to be 		 * zero.  Complete the 'bounce' of sense information 		 * through buffers accessible via bus-space by 		 * copying it into the clients csio. 		 */
name|memset
argument_list|(
operator|&
name|ccb
operator|->
name|csio
operator|.
name|sense_data
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ccb
operator|->
name|csio
operator|.
name|sense_data
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|ccb
operator|->
name|csio
operator|.
name|sense_data
argument_list|,
name|ahd_get_sense_buf
argument_list|(
name|ahd
argument_list|,
name|scb
argument_list|)
argument_list|,
comment|/* XXX What size do we want to use??? */
sizeof|sizeof
argument_list|(
name|ccb
operator|->
name|csio
operator|.
name|sense_data
argument_list|)
operator|-
name|ccb
operator|->
name|csio
operator|.
name|sense_resid
argument_list|)
expr_stmt|;
name|scb
operator|->
name|io_ctx
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_AUTOSNS_VALID
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|scb
operator|->
name|flags
operator|&
name|SCB_PKT_SENSE
operator|)
operator|!=
literal|0
condition|)
block|{
name|struct
name|scsi_status_iu_header
modifier|*
name|siu
decl_stmt|;
name|u_int
name|sense_len
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* 		 * Copy only the sense data into the provided buffer. 		 */
name|siu
operator|=
operator|(
expr|struct
name|scsi_status_iu_header
operator|*
operator|)
name|scb
operator|->
name|sense_data
expr_stmt|;
name|sense_len
operator|=
name|MIN
argument_list|(
name|scsi_4btoul
argument_list|(
name|siu
operator|->
name|sense_length
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|ccb
operator|->
name|csio
operator|.
name|sense_data
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|ccb
operator|->
name|csio
operator|.
name|sense_data
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ccb
operator|->
name|csio
operator|.
name|sense_data
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|ccb
operator|->
name|csio
operator|.
name|sense_data
argument_list|,
name|ahd_get_sense_buf
argument_list|(
name|ahd
argument_list|,
name|scb
argument_list|)
operator|+
name|SIU_SENSE_OFFSET
argument_list|(
name|siu
argument_list|)
argument_list|,
name|sense_len
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Copied %d bytes of sense data offset %d:"
argument_list|,
name|sense_len
argument_list|,
name|SIU_SENSE_OFFSET
argument_list|(
name|siu
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sense_len
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|" 0x%x"
argument_list|,
operator|(
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|ccb
operator|->
name|csio
operator|.
name|sense_data
operator|)
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|scb
operator|->
name|io_ctx
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_AUTOSNS_VALID
expr_stmt|;
block|}
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&=
operator|~
name|CAM_SIM_QUEUED
expr_stmt|;
name|ahd_free_scb
argument_list|(
name|ahd
argument_list|,
name|scb
argument_list|)
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ahd_action
parameter_list|(
name|struct
name|cam_sim
modifier|*
name|sim
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
block|{
name|struct
name|ahd_softc
modifier|*
name|ahd
decl_stmt|;
ifdef|#
directive|ifdef
name|AHD_TARGET_MODE
name|struct
name|ahd_tmode_lstate
modifier|*
name|lstate
decl_stmt|;
endif|#
directive|endif
name|u_int
name|target_id
decl_stmt|;
name|u_int
name|our_id
decl_stmt|;
name|long
name|s
decl_stmt|;
name|CAM_DEBUG
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
name|CAM_DEBUG_TRACE
argument_list|,
operator|(
literal|"ahd_action\n"
operator|)
argument_list|)
expr_stmt|;
name|ahd
operator|=
operator|(
expr|struct
name|ahd_softc
operator|*
operator|)
name|cam_sim_softc
argument_list|(
name|sim
argument_list|)
expr_stmt|;
name|target_id
operator|=
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
expr_stmt|;
name|our_id
operator|=
name|SIM_SCSI_ID
argument_list|(
name|ahd
argument_list|,
name|sim
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
condition|)
block|{
comment|/* Common cases first */
ifdef|#
directive|ifdef
name|AHD_TARGET_MODE
case|case
name|XPT_ACCEPT_TARGET_IO
case|:
comment|/* Accept Host Target Mode CDB */
case|case
name|XPT_CONT_TARGET_IO
case|:
comment|/* Continue Host Target I/O Connection*/
block|{
name|struct
name|ahd_tmode_tstate
modifier|*
name|tstate
decl_stmt|;
name|cam_status
name|status
decl_stmt|;
name|status
operator|=
name|ahd_find_tmode_devs
argument_list|(
name|ahd
argument_list|,
name|sim
argument_list|,
name|ccb
argument_list|,
operator|&
name|tstate
argument_list|,
operator|&
name|lstate
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
if|if
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|==
name|XPT_CONT_TARGET_IO
condition|)
block|{
comment|/* Response from the black hole device */
name|tstate
operator|=
name|NULL
expr_stmt|;
name|lstate
operator|=
name|ahd
operator|->
name|black_hole
expr_stmt|;
block|}
else|else
block|{
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|status
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|==
name|XPT_ACCEPT_TARGET_IO
condition|)
block|{
name|ahd_lock
argument_list|(
name|ahd
argument_list|,
operator|&
name|s
argument_list|)
expr_stmt|;
name|SLIST_INSERT_HEAD
argument_list|(
operator|&
name|lstate
operator|->
name|accept_tios
argument_list|,
operator|&
name|ccb
operator|->
name|ccb_h
argument_list|,
name|sim_links
operator|.
name|sle
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_INPROG
expr_stmt|;
if|if
condition|(
operator|(
name|ahd
operator|->
name|flags
operator|&
name|AHD_TQINFIFO_BLOCKED
operator|)
operator|!=
literal|0
condition|)
name|ahd_run_tqinfifo
argument_list|(
name|ahd
argument_list|,
comment|/*paused*/
name|FALSE
argument_list|)
expr_stmt|;
name|ahd_unlock
argument_list|(
name|ahd
argument_list|,
operator|&
name|s
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* 		 * The target_id represents the target we attempt to 		 * select.  In target mode, this is the initiator of 		 * the original command. 		 */
name|our_id
operator|=
name|target_id
expr_stmt|;
name|target_id
operator|=
name|ccb
operator|->
name|csio
operator|.
name|init_id
expr_stmt|;
comment|/* FALLTHROUGH */
block|}
endif|#
directive|endif
case|case
name|XPT_SCSI_IO
case|:
comment|/* Execute the requested I/O operation */
case|case
name|XPT_RESET_DEV
case|:
comment|/* Bus Device Reset the specified SCSI device */
block|{
name|struct
name|scb
modifier|*
name|scb
decl_stmt|;
name|struct
name|hardware_scb
modifier|*
name|hscb
decl_stmt|;
name|struct
name|ahd_initiator_tinfo
modifier|*
name|tinfo
decl_stmt|;
name|struct
name|ahd_tmode_tstate
modifier|*
name|tstate
decl_stmt|;
name|u_int
name|col_idx
decl_stmt|;
if|if
condition|(
operator|(
name|ahd
operator|->
name|flags
operator|&
name|AHD_INITIATORROLE
operator|)
operator|==
literal|0
operator|&&
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|==
name|XPT_SCSI_IO
operator|||
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|==
name|XPT_RESET_DEV
operator|)
condition|)
block|{
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_PROVIDE_FAIL
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 		 * get an scb to use. 		 */
name|ahd_lock
argument_list|(
name|ahd
argument_list|,
operator|&
name|s
argument_list|)
expr_stmt|;
name|tinfo
operator|=
name|ahd_fetch_transinfo
argument_list|(
name|ahd
argument_list|,
literal|'A'
argument_list|,
name|our_id
argument_list|,
name|target_id
argument_list|,
operator|&
name|tstate
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_TAG_ACTION_VALID
operator|)
operator|==
literal|0
operator|||
operator|(
name|tinfo
operator|->
name|curr
operator|.
name|ppr_options
operator|&
name|MSG_EXT_PPR_IU_REQ
operator|)
operator|!=
literal|0
operator|||
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|==
name|XPT_CONT_TARGET_IO
condition|)
block|{
name|col_idx
operator|=
name|AHD_NEVER_COL_IDX
expr_stmt|;
block|}
else|else
block|{
name|col_idx
operator|=
name|AHD_BUILD_COL_IDX
argument_list|(
name|target_id
argument_list|,
name|ccb
operator|->
name|ccb_h
operator|.
name|target_lun
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|scb
operator|=
name|ahd_get_scb
argument_list|(
name|ahd
argument_list|,
name|col_idx
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|xpt_freeze_simq
argument_list|(
name|sim
argument_list|,
comment|/*count*/
literal|1
argument_list|)
expr_stmt|;
name|ahd
operator|->
name|flags
operator||=
name|AHD_RESOURCE_SHORTAGE
expr_stmt|;
name|ahd_unlock
argument_list|(
name|ahd
argument_list|,
operator|&
name|s
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQUEUE_REQ
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return;
block|}
name|ahd_unlock
argument_list|(
name|ahd
argument_list|,
operator|&
name|s
argument_list|)
expr_stmt|;
name|hscb
operator|=
name|scb
operator|->
name|hscb
expr_stmt|;
name|CAM_DEBUG
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
name|CAM_DEBUG_SUBTRACE
argument_list|,
operator|(
literal|"start scb(%p)\n"
operator|,
name|scb
operator|)
argument_list|)
expr_stmt|;
name|scb
operator|->
name|io_ctx
operator|=
name|ccb
expr_stmt|;
comment|/* 		 * So we can find the SCB when an abort is requested 		 */
name|ccb
operator|->
name|ccb_h
operator|.
name|ccb_scb_ptr
operator|=
name|scb
expr_stmt|;
comment|/* 		 * Put all the arguments for the xfer in the scb 		 */
name|hscb
operator|->
name|control
operator|=
literal|0
expr_stmt|;
name|hscb
operator|->
name|scsiid
operator|=
name|BUILD_SCSIID
argument_list|(
name|ahd
argument_list|,
name|sim
argument_list|,
name|target_id
argument_list|,
name|our_id
argument_list|)
expr_stmt|;
name|hscb
operator|->
name|lun
operator|=
name|ccb
operator|->
name|ccb_h
operator|.
name|target_lun
expr_stmt|;
if|if
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|==
name|XPT_RESET_DEV
condition|)
block|{
name|hscb
operator|->
name|cdb_len
operator|=
literal|0
expr_stmt|;
name|scb
operator|->
name|flags
operator||=
name|SCB_DEVICE_RESET
expr_stmt|;
name|hscb
operator|->
name|control
operator||=
name|MK_MESSAGE
expr_stmt|;
name|hscb
operator|->
name|task_management
operator|=
name|SIU_TASKMGMT_LUN_RESET
expr_stmt|;
name|ahd_execute_scb
argument_list|(
name|scb
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|AHD_TARGET_MODE
if|if
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|==
name|XPT_CONT_TARGET_IO
condition|)
block|{
name|struct
name|target_data
modifier|*
name|tdata
decl_stmt|;
name|tdata
operator|=
operator|&
name|hscb
operator|->
name|shared_data
operator|.
name|tdata
expr_stmt|;
if|if
condition|(
name|ahd
operator|->
name|pending_device
operator|==
name|lstate
condition|)
name|scb
operator|->
name|flags
operator||=
name|SCB_TARGET_IMMEDIATE
expr_stmt|;
name|hscb
operator|->
name|control
operator||=
name|TARGET_SCB
expr_stmt|;
name|tdata
operator|->
name|target_phases
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_SEND_STATUS
operator|)
operator|!=
literal|0
condition|)
block|{
name|tdata
operator|->
name|target_phases
operator||=
name|SPHASE_PENDING
expr_stmt|;
name|tdata
operator|->
name|scsi_status
operator|=
name|ccb
operator|->
name|csio
operator|.
name|scsi_status
expr_stmt|;
block|}
if|if
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DIS_DISCONNECT
condition|)
name|tdata
operator|->
name|target_phases
operator||=
name|NO_DISCONNECT
expr_stmt|;
name|tdata
operator|->
name|initiator_tag
operator|=
name|ahd_htole16
argument_list|(
name|ccb
operator|->
name|csio
operator|.
name|tag_id
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|hscb
operator|->
name|task_management
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_TAG_ACTION_VALID
condition|)
name|hscb
operator|->
name|control
operator||=
name|ccb
operator|->
name|csio
operator|.
name|tag_action
expr_stmt|;
name|ahd_setup_data
argument_list|(
name|ahd
argument_list|,
name|sim
argument_list|,
operator|&
name|ccb
operator|->
name|csio
argument_list|,
name|scb
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
ifdef|#
directive|ifdef
name|AHD_TARGET_MODE
case|case
name|XPT_NOTIFY_ACK
case|:
case|case
name|XPT_IMMED_NOTIFY
case|:
block|{
name|struct
name|ahd_tmode_tstate
modifier|*
name|tstate
decl_stmt|;
name|struct
name|ahd_tmode_lstate
modifier|*
name|lstate
decl_stmt|;
name|cam_status
name|status
decl_stmt|;
name|status
operator|=
name|ahd_find_tmode_devs
argument_list|(
name|ahd
argument_list|,
name|sim
argument_list|,
name|ccb
argument_list|,
operator|&
name|tstate
argument_list|,
operator|&
name|lstate
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|status
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
block|}
name|SLIST_INSERT_HEAD
argument_list|(
operator|&
name|lstate
operator|->
name|immed_notifies
argument_list|,
operator|&
name|ccb
operator|->
name|ccb_h
argument_list|,
name|sim_links
operator|.
name|sle
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_INPROG
expr_stmt|;
name|ahd_send_lstate_events
argument_list|(
name|ahd
argument_list|,
name|lstate
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|XPT_EN_LUN
case|:
comment|/* Enable LUN as a target */
name|ahd_handle_en_lun
argument_list|(
name|ahd
argument_list|,
name|sim
argument_list|,
name|ccb
argument_list|)
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|XPT_ABORT
case|:
comment|/* Abort the specified CCB */
block|{
name|ahd_abort_ccb
argument_list|(
name|ahd
argument_list|,
name|sim
argument_list|,
name|ccb
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|XPT_SET_TRAN_SETTINGS
case|:
block|{
name|ahd_lock
argument_list|(
name|ahd
argument_list|,
operator|&
name|s
argument_list|)
expr_stmt|;
name|ahd_set_tran_settings
argument_list|(
name|ahd
argument_list|,
name|SIM_SCSI_ID
argument_list|(
name|ahd
argument_list|,
name|sim
argument_list|)
argument_list|,
name|SIM_CHANNEL
argument_list|(
name|ahd
argument_list|,
name|sim
argument_list|)
argument_list|,
operator|&
name|ccb
operator|->
name|cts
argument_list|)
expr_stmt|;
name|ahd_unlock
argument_list|(
name|ahd
argument_list|,
operator|&
name|s
argument_list|)
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|XPT_GET_TRAN_SETTINGS
case|:
comment|/* Get default/user set transfer settings for the target */
block|{
name|ahd_lock
argument_list|(
name|ahd
argument_list|,
operator|&
name|s
argument_list|)
expr_stmt|;
name|ahd_get_tran_settings
argument_list|(
name|ahd
argument_list|,
name|SIM_SCSI_ID
argument_list|(
name|ahd
argument_list|,
name|sim
argument_list|)
argument_list|,
name|SIM_CHANNEL
argument_list|(
name|ahd
argument_list|,
name|sim
argument_list|)
argument_list|,
operator|&
name|ccb
operator|->
name|cts
argument_list|)
expr_stmt|;
name|ahd_unlock
argument_list|(
name|ahd
argument_list|,
operator|&
name|s
argument_list|)
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|XPT_CALC_GEOMETRY
case|:
block|{
name|aic_calc_geometry
argument_list|(
operator|&
name|ccb
operator|->
name|ccg
argument_list|,
name|ahd
operator|->
name|flags
operator|&
name|AHD_EXTENDED_TRANS_A
argument_list|)
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|XPT_RESET_BUS
case|:
comment|/* Reset the specified SCSI bus */
block|{
name|int
name|found
decl_stmt|;
name|ahd_lock
argument_list|(
name|ahd
argument_list|,
operator|&
name|s
argument_list|)
expr_stmt|;
name|found
operator|=
name|ahd_reset_channel
argument_list|(
name|ahd
argument_list|,
name|SIM_CHANNEL
argument_list|(
name|ahd
argument_list|,
name|sim
argument_list|)
argument_list|,
comment|/*initiate reset*/
name|TRUE
argument_list|)
expr_stmt|;
name|ahd_unlock
argument_list|(
name|ahd
argument_list|,
operator|&
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
block|{
name|xpt_print_path
argument_list|(
name|SIM_PATH
argument_list|(
name|ahd
argument_list|,
name|sim
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"SCSI bus reset delivered. "
literal|"%d SCBs aborted.\n"
argument_list|,
name|found
argument_list|)
expr_stmt|;
block|}
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|XPT_TERM_IO
case|:
comment|/* Terminate the I/O process */
comment|/* XXX Implement */
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_INVALID
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
case|case
name|XPT_PATH_INQ
case|:
comment|/* Path routing inquiry */
block|{
name|struct
name|ccb_pathinq
modifier|*
name|cpi
init|=
operator|&
name|ccb
operator|->
name|cpi
decl_stmt|;
name|cpi
operator|->
name|version_num
operator|=
literal|1
expr_stmt|;
comment|/* XXX??? */
name|cpi
operator|->
name|hba_inquiry
operator|=
name|PI_SDTR_ABLE
operator||
name|PI_TAG_ABLE
expr_stmt|;
if|if
condition|(
operator|(
name|ahd
operator|->
name|features
operator|&
name|AHD_WIDE
operator|)
operator|!=
literal|0
condition|)
name|cpi
operator|->
name|hba_inquiry
operator||=
name|PI_WIDE_16
expr_stmt|;
if|if
condition|(
operator|(
name|ahd
operator|->
name|features
operator|&
name|AHD_TARGETMODE
operator|)
operator|!=
literal|0
condition|)
block|{
name|cpi
operator|->
name|target_sprt
operator|=
name|PIT_PROCESSOR
operator||
name|PIT_DISCONNECT
operator||
name|PIT_TERM_IO
expr_stmt|;
block|}
else|else
block|{
name|cpi
operator|->
name|target_sprt
operator|=
literal|0
expr_stmt|;
block|}
name|cpi
operator|->
name|hba_misc
operator|=
literal|0
expr_stmt|;
name|cpi
operator|->
name|hba_eng_cnt
operator|=
literal|0
expr_stmt|;
name|cpi
operator|->
name|max_target
operator|=
operator|(
name|ahd
operator|->
name|features
operator|&
name|AHD_WIDE
operator|)
condition|?
literal|15
else|:
literal|7
expr_stmt|;
name|cpi
operator|->
name|max_lun
operator|=
name|AHD_NUM_LUNS_NONPKT
operator|-
literal|1
expr_stmt|;
name|cpi
operator|->
name|initiator_id
operator|=
name|ahd
operator|->
name|our_id
expr_stmt|;
if|if
condition|(
operator|(
name|ahd
operator|->
name|flags
operator|&
name|AHD_RESET_BUS_A
operator|)
operator|==
literal|0
condition|)
block|{
name|cpi
operator|->
name|hba_misc
operator||=
name|PIM_NOBUSRESET
expr_stmt|;
block|}
name|cpi
operator|->
name|bus_id
operator|=
name|cam_sim_bus
argument_list|(
name|sim
argument_list|)
expr_stmt|;
name|cpi
operator|->
name|base_transfer_speed
operator|=
literal|3300
expr_stmt|;
name|strncpy
argument_list|(
name|cpi
operator|->
name|sim_vid
argument_list|,
literal|"FreeBSD"
argument_list|,
name|SIM_IDLEN
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|cpi
operator|->
name|hba_vid
argument_list|,
literal|"Adaptec"
argument_list|,
name|HBA_IDLEN
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|cpi
operator|->
name|dev_name
argument_list|,
name|cam_sim_name
argument_list|(
name|sim
argument_list|)
argument_list|,
name|DEV_IDLEN
argument_list|)
expr_stmt|;
name|cpi
operator|->
name|unit_number
operator|=
name|cam_sim_unit
argument_list|(
name|sim
argument_list|)
expr_stmt|;
name|cpi
operator|->
name|protocol
operator|=
name|PROTO_SCSI
expr_stmt|;
name|cpi
operator|->
name|protocol_version
operator|=
name|SCSI_REV_2
expr_stmt|;
name|cpi
operator|->
name|transport
operator|=
name|XPORT_SPI
expr_stmt|;
name|cpi
operator|->
name|transport_version
operator|=
literal|2
expr_stmt|;
name|cpi
operator|->
name|xport_specific
operator|.
name|spi
operator|.
name|ppr_options
operator|=
name|SID_SPI_CLOCK_ST
expr_stmt|;
name|cpi
operator|->
name|transport_version
operator|=
literal|4
expr_stmt|;
name|cpi
operator|->
name|xport_specific
operator|.
name|spi
operator|.
name|ppr_options
operator|=
name|SID_SPI_CLOCK_DT_ST
expr_stmt|;
name|cpi
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_PROVIDE_FAIL
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ahd_set_tran_settings
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|,
name|int
name|our_id
parameter_list|,
name|char
name|channel
parameter_list|,
name|struct
name|ccb_trans_settings
modifier|*
name|cts
parameter_list|)
block|{
name|struct
name|ahd_devinfo
name|devinfo
decl_stmt|;
name|struct
name|ccb_trans_settings_scsi
modifier|*
name|scsi
decl_stmt|;
name|struct
name|ccb_trans_settings_spi
modifier|*
name|spi
decl_stmt|;
name|struct
name|ahd_initiator_tinfo
modifier|*
name|tinfo
decl_stmt|;
name|struct
name|ahd_tmode_tstate
modifier|*
name|tstate
decl_stmt|;
name|uint16_t
modifier|*
name|discenable
decl_stmt|;
name|uint16_t
modifier|*
name|tagenable
decl_stmt|;
name|u_int
name|update_type
decl_stmt|;
name|scsi
operator|=
operator|&
name|cts
operator|->
name|proto_specific
operator|.
name|scsi
expr_stmt|;
name|spi
operator|=
operator|&
name|cts
operator|->
name|xport_specific
operator|.
name|spi
expr_stmt|;
name|ahd_compile_devinfo
argument_list|(
operator|&
name|devinfo
argument_list|,
name|SIM_SCSI_ID
argument_list|(
name|ahd
argument_list|,
name|sim
argument_list|)
argument_list|,
name|cts
operator|->
name|ccb_h
operator|.
name|target_id
argument_list|,
name|cts
operator|->
name|ccb_h
operator|.
name|target_lun
argument_list|,
name|SIM_CHANNEL
argument_list|(
name|ahd
argument_list|,
name|sim
argument_list|)
argument_list|,
name|ROLE_UNKNOWN
argument_list|)
expr_stmt|;
name|tinfo
operator|=
name|ahd_fetch_transinfo
argument_list|(
name|ahd
argument_list|,
name|devinfo
operator|.
name|channel
argument_list|,
name|devinfo
operator|.
name|our_scsiid
argument_list|,
name|devinfo
operator|.
name|target
argument_list|,
operator|&
name|tstate
argument_list|)
expr_stmt|;
name|update_type
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|cts
operator|->
name|type
operator|==
name|CTS_TYPE_CURRENT_SETTINGS
condition|)
block|{
name|update_type
operator||=
name|AHD_TRANS_GOAL
expr_stmt|;
name|discenable
operator|=
operator|&
name|tstate
operator|->
name|discenable
expr_stmt|;
name|tagenable
operator|=
operator|&
name|tstate
operator|->
name|tagenable
expr_stmt|;
name|tinfo
operator|->
name|curr
operator|.
name|protocol_version
operator|=
name|cts
operator|->
name|protocol_version
expr_stmt|;
name|tinfo
operator|->
name|curr
operator|.
name|transport_version
operator|=
name|cts
operator|->
name|transport_version
expr_stmt|;
name|tinfo
operator|->
name|goal
operator|.
name|protocol_version
operator|=
name|cts
operator|->
name|protocol_version
expr_stmt|;
name|tinfo
operator|->
name|goal
operator|.
name|transport_version
operator|=
name|cts
operator|->
name|transport_version
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cts
operator|->
name|type
operator|==
name|CTS_TYPE_USER_SETTINGS
condition|)
block|{
name|update_type
operator||=
name|AHD_TRANS_USER
expr_stmt|;
name|discenable
operator|=
operator|&
name|ahd
operator|->
name|user_discenable
expr_stmt|;
name|tagenable
operator|=
operator|&
name|ahd
operator|->
name|user_tagenable
expr_stmt|;
name|tinfo
operator|->
name|user
operator|.
name|protocol_version
operator|=
name|cts
operator|->
name|protocol_version
expr_stmt|;
name|tinfo
operator|->
name|user
operator|.
name|transport_version
operator|=
name|cts
operator|->
name|transport_version
expr_stmt|;
block|}
else|else
block|{
name|cts
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_INVALID
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|spi
operator|->
name|valid
operator|&
name|CTS_SPI_VALID_DISC
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|spi
operator|->
name|flags
operator|&
name|CTS_SPI_FLAGS_DISC_ENB
operator|)
operator|!=
literal|0
condition|)
operator|*
name|discenable
operator||=
name|devinfo
operator|.
name|target_mask
expr_stmt|;
else|else
operator|*
name|discenable
operator|&=
operator|~
name|devinfo
operator|.
name|target_mask
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|scsi
operator|->
name|valid
operator|&
name|CTS_SCSI_VALID_TQ
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|scsi
operator|->
name|flags
operator|&
name|CTS_SCSI_FLAGS_TAG_ENB
operator|)
operator|!=
literal|0
condition|)
operator|*
name|tagenable
operator||=
name|devinfo
operator|.
name|target_mask
expr_stmt|;
else|else
operator|*
name|tagenable
operator|&=
operator|~
name|devinfo
operator|.
name|target_mask
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|spi
operator|->
name|valid
operator|&
name|CTS_SPI_VALID_BUS_WIDTH
operator|)
operator|!=
literal|0
condition|)
block|{
name|ahd_validate_width
argument_list|(
name|ahd
argument_list|,
comment|/*tinfo limit*/
name|NULL
argument_list|,
operator|&
name|spi
operator|->
name|bus_width
argument_list|,
name|ROLE_UNKNOWN
argument_list|)
expr_stmt|;
name|ahd_set_width
argument_list|(
name|ahd
argument_list|,
operator|&
name|devinfo
argument_list|,
name|spi
operator|->
name|bus_width
argument_list|,
name|update_type
argument_list|,
comment|/*paused*/
name|FALSE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|spi
operator|->
name|valid
operator|&
name|CTS_SPI_VALID_PPR_OPTIONS
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|update_type
operator|==
name|AHD_TRANS_USER
condition|)
name|spi
operator|->
name|ppr_options
operator|=
name|tinfo
operator|->
name|user
operator|.
name|ppr_options
expr_stmt|;
else|else
name|spi
operator|->
name|ppr_options
operator|=
name|tinfo
operator|->
name|goal
operator|.
name|ppr_options
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|spi
operator|->
name|valid
operator|&
name|CTS_SPI_VALID_SYNC_OFFSET
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|update_type
operator|==
name|AHD_TRANS_USER
condition|)
name|spi
operator|->
name|sync_offset
operator|=
name|tinfo
operator|->
name|user
operator|.
name|offset
expr_stmt|;
else|else
name|spi
operator|->
name|sync_offset
operator|=
name|tinfo
operator|->
name|goal
operator|.
name|offset
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|spi
operator|->
name|valid
operator|&
name|CTS_SPI_VALID_SYNC_RATE
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|update_type
operator|==
name|AHD_TRANS_USER
condition|)
name|spi
operator|->
name|sync_period
operator|=
name|tinfo
operator|->
name|user
operator|.
name|period
expr_stmt|;
else|else
name|spi
operator|->
name|sync_period
operator|=
name|tinfo
operator|->
name|goal
operator|.
name|period
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|(
name|spi
operator|->
name|valid
operator|&
name|CTS_SPI_VALID_SYNC_RATE
operator|)
operator|!=
literal|0
operator|)
operator|||
operator|(
operator|(
name|spi
operator|->
name|valid
operator|&
name|CTS_SPI_VALID_SYNC_OFFSET
operator|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|u_int
name|maxsync
decl_stmt|;
name|maxsync
operator|=
name|AHD_SYNCRATE_MAX
expr_stmt|;
if|if
condition|(
name|spi
operator|->
name|bus_width
operator|!=
name|MSG_EXT_WDTR_BUS_16_BIT
condition|)
name|spi
operator|->
name|ppr_options
operator|&=
operator|~
name|MSG_EXT_PPR_DT_REQ
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|discenable
operator|&
name|devinfo
operator|.
name|target_mask
operator|)
operator|==
literal|0
condition|)
name|spi
operator|->
name|ppr_options
operator|&=
operator|~
name|MSG_EXT_PPR_IU_REQ
expr_stmt|;
name|ahd_find_syncrate
argument_list|(
name|ahd
argument_list|,
operator|&
name|spi
operator|->
name|sync_period
argument_list|,
operator|&
name|spi
operator|->
name|ppr_options
argument_list|,
name|maxsync
argument_list|)
expr_stmt|;
name|ahd_validate_offset
argument_list|(
name|ahd
argument_list|,
comment|/*tinfo limit*/
name|NULL
argument_list|,
name|spi
operator|->
name|sync_period
argument_list|,
operator|&
name|spi
operator|->
name|sync_offset
argument_list|,
name|spi
operator|->
name|bus_width
argument_list|,
name|ROLE_UNKNOWN
argument_list|)
expr_stmt|;
comment|/* We use a period of 0 to represent async */
if|if
condition|(
name|spi
operator|->
name|sync_offset
operator|==
literal|0
condition|)
block|{
name|spi
operator|->
name|sync_period
operator|=
literal|0
expr_stmt|;
name|spi
operator|->
name|ppr_options
operator|=
literal|0
expr_stmt|;
block|}
name|ahd_set_syncrate
argument_list|(
name|ahd
argument_list|,
operator|&
name|devinfo
argument_list|,
name|spi
operator|->
name|sync_period
argument_list|,
name|spi
operator|->
name|sync_offset
argument_list|,
name|spi
operator|->
name|ppr_options
argument_list|,
name|update_type
argument_list|,
comment|/*paused*/
name|FALSE
argument_list|)
expr_stmt|;
block|}
name|cts
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ahd_get_tran_settings
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|,
name|int
name|our_id
parameter_list|,
name|char
name|channel
parameter_list|,
name|struct
name|ccb_trans_settings
modifier|*
name|cts
parameter_list|)
block|{
name|struct
name|ahd_devinfo
name|devinfo
decl_stmt|;
name|struct
name|ccb_trans_settings_scsi
modifier|*
name|scsi
decl_stmt|;
name|struct
name|ccb_trans_settings_spi
modifier|*
name|spi
decl_stmt|;
name|struct
name|ahd_initiator_tinfo
modifier|*
name|targ_info
decl_stmt|;
name|struct
name|ahd_tmode_tstate
modifier|*
name|tstate
decl_stmt|;
name|struct
name|ahd_transinfo
modifier|*
name|tinfo
decl_stmt|;
name|scsi
operator|=
operator|&
name|cts
operator|->
name|proto_specific
operator|.
name|scsi
expr_stmt|;
name|spi
operator|=
operator|&
name|cts
operator|->
name|xport_specific
operator|.
name|spi
expr_stmt|;
name|ahd_compile_devinfo
argument_list|(
operator|&
name|devinfo
argument_list|,
name|our_id
argument_list|,
name|cts
operator|->
name|ccb_h
operator|.
name|target_id
argument_list|,
name|cts
operator|->
name|ccb_h
operator|.
name|target_lun
argument_list|,
name|channel
argument_list|,
name|ROLE_UNKNOWN
argument_list|)
expr_stmt|;
name|targ_info
operator|=
name|ahd_fetch_transinfo
argument_list|(
name|ahd
argument_list|,
name|devinfo
operator|.
name|channel
argument_list|,
name|devinfo
operator|.
name|our_scsiid
argument_list|,
name|devinfo
operator|.
name|target
argument_list|,
operator|&
name|tstate
argument_list|)
expr_stmt|;
if|if
condition|(
name|cts
operator|->
name|type
operator|==
name|CTS_TYPE_CURRENT_SETTINGS
condition|)
name|tinfo
operator|=
operator|&
name|targ_info
operator|->
name|curr
expr_stmt|;
else|else
name|tinfo
operator|=
operator|&
name|targ_info
operator|->
name|user
expr_stmt|;
name|scsi
operator|->
name|flags
operator|&=
operator|~
name|CTS_SCSI_FLAGS_TAG_ENB
expr_stmt|;
name|spi
operator|->
name|flags
operator|&=
operator|~
name|CTS_SPI_FLAGS_DISC_ENB
expr_stmt|;
if|if
condition|(
name|cts
operator|->
name|type
operator|==
name|CTS_TYPE_USER_SETTINGS
condition|)
block|{
if|if
condition|(
operator|(
name|ahd
operator|->
name|user_discenable
operator|&
name|devinfo
operator|.
name|target_mask
operator|)
operator|!=
literal|0
condition|)
name|spi
operator|->
name|flags
operator||=
name|CTS_SPI_FLAGS_DISC_ENB
expr_stmt|;
if|if
condition|(
operator|(
name|ahd
operator|->
name|user_tagenable
operator|&
name|devinfo
operator|.
name|target_mask
operator|)
operator|!=
literal|0
condition|)
name|scsi
operator|->
name|flags
operator||=
name|CTS_SCSI_FLAGS_TAG_ENB
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|tstate
operator|->
name|discenable
operator|&
name|devinfo
operator|.
name|target_mask
operator|)
operator|!=
literal|0
condition|)
name|spi
operator|->
name|flags
operator||=
name|CTS_SPI_FLAGS_DISC_ENB
expr_stmt|;
if|if
condition|(
operator|(
name|tstate
operator|->
name|tagenable
operator|&
name|devinfo
operator|.
name|target_mask
operator|)
operator|!=
literal|0
condition|)
name|scsi
operator|->
name|flags
operator||=
name|CTS_SCSI_FLAGS_TAG_ENB
expr_stmt|;
block|}
name|cts
operator|->
name|protocol_version
operator|=
name|tinfo
operator|->
name|protocol_version
expr_stmt|;
name|cts
operator|->
name|transport_version
operator|=
name|tinfo
operator|->
name|transport_version
expr_stmt|;
name|spi
operator|->
name|sync_period
operator|=
name|tinfo
operator|->
name|period
expr_stmt|;
name|spi
operator|->
name|sync_offset
operator|=
name|tinfo
operator|->
name|offset
expr_stmt|;
name|spi
operator|->
name|bus_width
operator|=
name|tinfo
operator|->
name|width
expr_stmt|;
name|spi
operator|->
name|ppr_options
operator|=
name|tinfo
operator|->
name|ppr_options
expr_stmt|;
name|cts
operator|->
name|protocol
operator|=
name|PROTO_SCSI
expr_stmt|;
name|cts
operator|->
name|transport
operator|=
name|XPORT_SPI
expr_stmt|;
name|spi
operator|->
name|valid
operator|=
name|CTS_SPI_VALID_SYNC_RATE
operator||
name|CTS_SPI_VALID_SYNC_OFFSET
operator||
name|CTS_SPI_VALID_BUS_WIDTH
operator||
name|CTS_SPI_VALID_PPR_OPTIONS
expr_stmt|;
if|if
condition|(
name|cts
operator|->
name|ccb_h
operator|.
name|target_lun
operator|!=
name|CAM_LUN_WILDCARD
condition|)
block|{
name|scsi
operator|->
name|valid
operator|=
name|CTS_SCSI_VALID_TQ
expr_stmt|;
name|spi
operator|->
name|valid
operator||=
name|CTS_SPI_VALID_DISC
expr_stmt|;
block|}
else|else
block|{
name|scsi
operator|->
name|valid
operator|=
literal|0
expr_stmt|;
block|}
name|cts
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ahd_async
parameter_list|(
name|void
modifier|*
name|callback_arg
parameter_list|,
name|uint32_t
name|code
parameter_list|,
name|struct
name|cam_path
modifier|*
name|path
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ahd_softc
modifier|*
name|ahd
decl_stmt|;
name|struct
name|cam_sim
modifier|*
name|sim
decl_stmt|;
name|sim
operator|=
operator|(
expr|struct
name|cam_sim
operator|*
operator|)
name|callback_arg
expr_stmt|;
name|ahd
operator|=
operator|(
expr|struct
name|ahd_softc
operator|*
operator|)
name|cam_sim_softc
argument_list|(
name|sim
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|AC_LOST_DEVICE
case|:
block|{
name|struct
name|ahd_devinfo
name|devinfo
decl_stmt|;
name|long
name|s
decl_stmt|;
name|ahd_compile_devinfo
argument_list|(
operator|&
name|devinfo
argument_list|,
name|SIM_SCSI_ID
argument_list|(
name|ahd
argument_list|,
name|sim
argument_list|)
argument_list|,
name|xpt_path_target_id
argument_list|(
name|path
argument_list|)
argument_list|,
name|xpt_path_lun_id
argument_list|(
name|path
argument_list|)
argument_list|,
name|SIM_CHANNEL
argument_list|(
name|ahd
argument_list|,
name|sim
argument_list|)
argument_list|,
name|ROLE_UNKNOWN
argument_list|)
expr_stmt|;
comment|/* 		 * Revert to async/narrow transfers 		 * for the next device. 		 */
name|ahd_lock
argument_list|(
name|ahd
argument_list|,
operator|&
name|s
argument_list|)
expr_stmt|;
name|ahd_set_width
argument_list|(
name|ahd
argument_list|,
operator|&
name|devinfo
argument_list|,
name|MSG_EXT_WDTR_BUS_8_BIT
argument_list|,
name|AHD_TRANS_GOAL
operator||
name|AHD_TRANS_CUR
argument_list|,
comment|/*paused*/
name|FALSE
argument_list|)
expr_stmt|;
name|ahd_set_syncrate
argument_list|(
name|ahd
argument_list|,
operator|&
name|devinfo
argument_list|,
comment|/*period*/
literal|0
argument_list|,
comment|/*offset*/
literal|0
argument_list|,
comment|/*ppr_options*/
literal|0
argument_list|,
name|AHD_TRANS_GOAL
operator||
name|AHD_TRANS_CUR
argument_list|,
comment|/*paused*/
name|FALSE
argument_list|)
expr_stmt|;
name|ahd_unlock
argument_list|(
name|ahd
argument_list|,
operator|&
name|s
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ahd_execute_scb
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|dm_segs
parameter_list|,
name|int
name|nsegments
parameter_list|,
name|int
name|error
parameter_list|)
block|{
name|struct
name|scb
modifier|*
name|scb
decl_stmt|;
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|struct
name|ahd_softc
modifier|*
name|ahd
decl_stmt|;
name|struct
name|ahd_initiator_tinfo
modifier|*
name|tinfo
decl_stmt|;
name|struct
name|ahd_tmode_tstate
modifier|*
name|tstate
decl_stmt|;
name|u_int
name|mask
decl_stmt|;
name|u_long
name|s
decl_stmt|;
name|scb
operator|=
operator|(
expr|struct
name|scb
operator|*
operator|)
name|arg
expr_stmt|;
name|ccb
operator|=
name|scb
operator|->
name|io_ctx
expr_stmt|;
name|ahd
operator|=
name|scb
operator|->
name|ahd_softc
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|error
operator|==
name|EFBIG
condition|)
name|aic_set_transaction_status
argument_list|(
name|scb
argument_list|,
name|CAM_REQ_TOO_BIG
argument_list|)
expr_stmt|;
else|else
name|aic_set_transaction_status
argument_list|(
name|scb
argument_list|,
name|CAM_REQ_CMP_ERR
argument_list|)
expr_stmt|;
if|if
condition|(
name|nsegments
operator|!=
literal|0
condition|)
name|bus_dmamap_unload
argument_list|(
name|ahd
operator|->
name|buffer_dmat
argument_list|,
name|scb
operator|->
name|dmamap
argument_list|)
expr_stmt|;
name|ahd_lock
argument_list|(
name|ahd
argument_list|,
operator|&
name|s
argument_list|)
expr_stmt|;
name|ahd_free_scb
argument_list|(
name|ahd
argument_list|,
name|scb
argument_list|)
expr_stmt|;
name|ahd_unlock
argument_list|(
name|ahd
argument_list|,
operator|&
name|s
argument_list|)
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return;
block|}
name|scb
operator|->
name|sg_count
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|nsegments
operator|!=
literal|0
condition|)
block|{
name|void
modifier|*
name|sg
decl_stmt|;
name|bus_dmasync_op_t
name|op
decl_stmt|;
name|u_int
name|i
decl_stmt|;
comment|/* Copy the segments into our SG list */
for|for
control|(
name|i
operator|=
name|nsegments
operator|,
name|sg
operator|=
name|scb
operator|->
name|sg_list
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|sg
operator|=
name|ahd_sg_setup
argument_list|(
name|ahd
argument_list|,
name|scb
argument_list|,
name|sg
argument_list|,
name|dm_segs
operator|->
name|ds_addr
argument_list|,
name|dm_segs
operator|->
name|ds_len
argument_list|,
comment|/*last*/
name|i
operator|==
literal|1
argument_list|)
expr_stmt|;
name|dm_segs
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DIR_MASK
operator|)
operator|==
name|CAM_DIR_IN
condition|)
name|op
operator|=
name|BUS_DMASYNC_PREREAD
expr_stmt|;
else|else
name|op
operator|=
name|BUS_DMASYNC_PREWRITE
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|ahd
operator|->
name|buffer_dmat
argument_list|,
name|scb
operator|->
name|dmamap
argument_list|,
name|op
argument_list|)
expr_stmt|;
if|if
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|==
name|XPT_CONT_TARGET_IO
condition|)
block|{
name|struct
name|target_data
modifier|*
name|tdata
decl_stmt|;
name|tdata
operator|=
operator|&
name|scb
operator|->
name|hscb
operator|->
name|shared_data
operator|.
name|tdata
expr_stmt|;
name|tdata
operator|->
name|target_phases
operator||=
name|DPHASE_PENDING
expr_stmt|;
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DIR_MASK
operator|)
operator|==
name|CAM_DIR_OUT
condition|)
name|tdata
operator|->
name|data_phase
operator|=
name|P_DATAOUT
expr_stmt|;
else|else
name|tdata
operator|->
name|data_phase
operator|=
name|P_DATAIN
expr_stmt|;
block|}
block|}
name|ahd_lock
argument_list|(
name|ahd
argument_list|,
operator|&
name|s
argument_list|)
expr_stmt|;
comment|/* 	 * Last time we need to check if this SCB needs to 	 * be aborted. 	 */
if|if
condition|(
name|aic_get_transaction_status
argument_list|(
name|scb
argument_list|)
operator|!=
name|CAM_REQ_INPROG
condition|)
block|{
if|if
condition|(
name|nsegments
operator|!=
literal|0
condition|)
name|bus_dmamap_unload
argument_list|(
name|ahd
operator|->
name|buffer_dmat
argument_list|,
name|scb
operator|->
name|dmamap
argument_list|)
expr_stmt|;
name|ahd_free_scb
argument_list|(
name|ahd
argument_list|,
name|scb
argument_list|)
expr_stmt|;
name|ahd_unlock
argument_list|(
name|ahd
argument_list|,
operator|&
name|s
argument_list|)
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return;
block|}
name|tinfo
operator|=
name|ahd_fetch_transinfo
argument_list|(
name|ahd
argument_list|,
name|SCSIID_CHANNEL
argument_list|(
name|ahd
argument_list|,
name|scb
operator|->
name|hscb
operator|->
name|scsiid
argument_list|)
argument_list|,
name|SCSIID_OUR_ID
argument_list|(
name|scb
operator|->
name|hscb
operator|->
name|scsiid
argument_list|)
argument_list|,
name|SCSIID_TARGET
argument_list|(
name|ahd
argument_list|,
name|scb
operator|->
name|hscb
operator|->
name|scsiid
argument_list|)
argument_list|,
operator|&
name|tstate
argument_list|)
expr_stmt|;
name|mask
operator|=
name|SCB_GET_TARGET_MASK
argument_list|(
name|ahd
argument_list|,
name|scb
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tstate
operator|->
name|discenable
operator|&
name|mask
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DIS_DISCONNECT
operator|)
operator|==
literal|0
condition|)
name|scb
operator|->
name|hscb
operator|->
name|control
operator||=
name|DISCENB
expr_stmt|;
if|if
condition|(
operator|(
name|tinfo
operator|->
name|curr
operator|.
name|ppr_options
operator|&
name|MSG_EXT_PPR_IU_REQ
operator|)
operator|!=
literal|0
condition|)
block|{
name|scb
operator|->
name|flags
operator||=
name|SCB_PACKETIZED
expr_stmt|;
if|if
condition|(
name|scb
operator|->
name|hscb
operator|->
name|task_management
operator|!=
literal|0
condition|)
name|scb
operator|->
name|hscb
operator|->
name|control
operator|&=
operator|~
name|MK_MESSAGE
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_NEGOTIATE
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|tinfo
operator|->
name|goal
operator|.
name|width
operator|!=
literal|0
operator|||
name|tinfo
operator|->
name|goal
operator|.
name|period
operator|!=
literal|0
operator|||
name|tinfo
operator|->
name|goal
operator|.
name|ppr_options
operator|!=
literal|0
operator|)
condition|)
block|{
name|scb
operator|->
name|flags
operator||=
name|SCB_NEGOTIATE
expr_stmt|;
name|scb
operator|->
name|hscb
operator|->
name|control
operator||=
name|MK_MESSAGE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|tstate
operator|->
name|auto_negotiate
operator|&
name|mask
operator|)
operator|!=
literal|0
condition|)
block|{
name|scb
operator|->
name|flags
operator||=
name|SCB_AUTO_NEGOTIATE
expr_stmt|;
name|scb
operator|->
name|hscb
operator|->
name|control
operator||=
name|MK_MESSAGE
expr_stmt|;
block|}
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|ahd
operator|->
name|pending_scbs
argument_list|,
name|scb
argument_list|,
name|pending_links
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_SIM_QUEUED
expr_stmt|;
name|aic_scb_timer_start
argument_list|(
name|scb
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|scb
operator|->
name|flags
operator|&
name|SCB_TARGET_IMMEDIATE
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* Define a mapping from our tag to the SCB. */
name|ahd
operator|->
name|scb_data
operator|.
name|scbindex
index|[
name|SCB_GET_TAG
argument_list|(
name|scb
argument_list|)
index|]
operator|=
name|scb
expr_stmt|;
name|ahd_pause
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
name|ahd_set_scbptr
argument_list|(
name|ahd
argument_list|,
name|SCB_GET_TAG
argument_list|(
name|scb
argument_list|)
argument_list|)
expr_stmt|;
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|RETURN_1
argument_list|,
name|CONT_MSG_LOOP_TARG
argument_list|)
expr_stmt|;
name|ahd_unpause
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ahd_queue_scb
argument_list|(
name|ahd
argument_list|,
name|scb
argument_list|)
expr_stmt|;
block|}
name|ahd_unlock
argument_list|(
name|ahd
argument_list|,
operator|&
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ahd_poll
parameter_list|(
name|struct
name|cam_sim
modifier|*
name|sim
parameter_list|)
block|{
name|ahd_intr
argument_list|(
name|cam_sim_softc
argument_list|(
name|sim
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ahd_setup_data
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|,
name|struct
name|cam_sim
modifier|*
name|sim
parameter_list|,
name|struct
name|ccb_scsiio
modifier|*
name|csio
parameter_list|,
name|struct
name|scb
modifier|*
name|scb
parameter_list|)
block|{
name|struct
name|hardware_scb
modifier|*
name|hscb
decl_stmt|;
name|struct
name|ccb_hdr
modifier|*
name|ccb_h
decl_stmt|;
name|hscb
operator|=
name|scb
operator|->
name|hscb
expr_stmt|;
name|ccb_h
operator|=
operator|&
name|csio
operator|->
name|ccb_h
expr_stmt|;
name|csio
operator|->
name|resid
operator|=
literal|0
expr_stmt|;
name|csio
operator|->
name|sense_resid
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ccb_h
operator|->
name|func_code
operator|==
name|XPT_SCSI_IO
condition|)
block|{
name|hscb
operator|->
name|cdb_len
operator|=
name|csio
operator|->
name|cdb_len
expr_stmt|;
if|if
condition|(
operator|(
name|ccb_h
operator|->
name|flags
operator|&
name|CAM_CDB_POINTER
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|hscb
operator|->
name|cdb_len
operator|>
name|MAX_CDB_LEN
operator|&&
operator|(
name|ccb_h
operator|->
name|flags
operator|&
name|CAM_CDB_PHYS
operator|)
operator|==
literal|0
condition|)
block|{
name|u_long
name|s
decl_stmt|;
comment|/* 				 * Should CAM start to support CDB sizes 				 * greater than 16 bytes, we could use 				 * the sense buffer to store the CDB. 				 */
name|aic_set_transaction_status
argument_list|(
name|scb
argument_list|,
name|CAM_REQ_INVALID
argument_list|)
expr_stmt|;
name|ahd_lock
argument_list|(
name|ahd
argument_list|,
operator|&
name|s
argument_list|)
expr_stmt|;
name|ahd_free_scb
argument_list|(
name|ahd
argument_list|,
name|scb
argument_list|)
expr_stmt|;
name|ahd_unlock
argument_list|(
name|ahd
argument_list|,
operator|&
name|s
argument_list|)
expr_stmt|;
name|xpt_done
argument_list|(
operator|(
expr|union
name|ccb
operator|*
operator|)
name|csio
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|ccb_h
operator|->
name|flags
operator|&
name|CAM_CDB_PHYS
operator|)
operator|!=
literal|0
condition|)
block|{
name|hscb
operator|->
name|shared_data
operator|.
name|idata
operator|.
name|cdb_from_host
operator|.
name|cdbptr
operator|=
name|aic_htole64
argument_list|(
operator|(
name|uintptr_t
operator|)
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_ptr
argument_list|)
expr_stmt|;
name|hscb
operator|->
name|shared_data
operator|.
name|idata
operator|.
name|cdb_from_host
operator|.
name|cdblen
operator|=
name|csio
operator|->
name|cdb_len
expr_stmt|;
name|hscb
operator|->
name|cdb_len
operator||=
name|SCB_CDB_LEN_PTR
expr_stmt|;
block|}
else|else
block|{
name|memcpy
argument_list|(
name|hscb
operator|->
name|shared_data
operator|.
name|idata
operator|.
name|cdb
argument_list|,
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_ptr
argument_list|,
name|hscb
operator|->
name|cdb_len
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|hscb
operator|->
name|cdb_len
operator|>
name|MAX_CDB_LEN
condition|)
block|{
name|u_long
name|s
decl_stmt|;
name|aic_set_transaction_status
argument_list|(
name|scb
argument_list|,
name|CAM_REQ_INVALID
argument_list|)
expr_stmt|;
name|ahd_lock
argument_list|(
name|ahd
argument_list|,
operator|&
name|s
argument_list|)
expr_stmt|;
name|ahd_free_scb
argument_list|(
name|ahd
argument_list|,
name|scb
argument_list|)
expr_stmt|;
name|ahd_unlock
argument_list|(
name|ahd
argument_list|,
operator|&
name|s
argument_list|)
expr_stmt|;
name|xpt_done
argument_list|(
operator|(
expr|union
name|ccb
operator|*
operator|)
name|csio
argument_list|)
expr_stmt|;
return|return;
block|}
name|memcpy
argument_list|(
name|hscb
operator|->
name|shared_data
operator|.
name|idata
operator|.
name|cdb
argument_list|,
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
argument_list|,
name|hscb
operator|->
name|cdb_len
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Only use S/G if there is a transfer */
if|if
condition|(
operator|(
name|ccb_h
operator|->
name|flags
operator|&
name|CAM_DIR_MASK
operator|)
operator|!=
name|CAM_DIR_NONE
condition|)
block|{
if|if
condition|(
operator|(
name|ccb_h
operator|->
name|flags
operator|&
name|CAM_SCATTER_VALID
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* We've been given a pointer to a single buffer */
if|if
condition|(
operator|(
name|ccb_h
operator|->
name|flags
operator|&
name|CAM_DATA_PHYS
operator|)
operator|==
literal|0
condition|)
block|{
name|int
name|s
decl_stmt|;
name|int
name|error
decl_stmt|;
name|s
operator|=
name|splsoftvm
argument_list|()
expr_stmt|;
name|error
operator|=
name|bus_dmamap_load
argument_list|(
name|ahd
operator|->
name|buffer_dmat
argument_list|,
name|scb
operator|->
name|dmamap
argument_list|,
name|csio
operator|->
name|data_ptr
argument_list|,
name|csio
operator|->
name|dxfer_len
argument_list|,
name|ahd_execute_scb
argument_list|,
name|scb
argument_list|,
comment|/*flags*/
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|EINPROGRESS
condition|)
block|{
comment|/* 					 * So as to maintain ordering, 					 * freeze the controller queue 					 * until our mapping is 					 * returned. 					 */
name|xpt_freeze_simq
argument_list|(
name|sim
argument_list|,
comment|/*count*/
literal|1
argument_list|)
expr_stmt|;
name|scb
operator|->
name|io_ctx
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_RELEASE_SIMQ
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|struct
name|bus_dma_segment
name|seg
decl_stmt|;
comment|/* Pointer to physical buffer */
if|if
condition|(
name|csio
operator|->
name|dxfer_len
operator|>
name|AHD_MAXTRANSFER_SIZE
condition|)
name|panic
argument_list|(
literal|"ahd_setup_data - Transfer size "
literal|"larger than can device max"
argument_list|)
expr_stmt|;
name|seg
operator|.
name|ds_addr
operator|=
operator|(
name|bus_addr_t
operator|)
operator|(
name|vm_offset_t
operator|)
name|csio
operator|->
name|data_ptr
expr_stmt|;
name|seg
operator|.
name|ds_len
operator|=
name|csio
operator|->
name|dxfer_len
expr_stmt|;
name|ahd_execute_scb
argument_list|(
name|scb
argument_list|,
operator|&
name|seg
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|struct
name|bus_dma_segment
modifier|*
name|segs
decl_stmt|;
if|if
condition|(
operator|(
name|ccb_h
operator|->
name|flags
operator|&
name|CAM_DATA_PHYS
operator|)
operator|!=
literal|0
condition|)
name|panic
argument_list|(
literal|"ahd_setup_data - Physical segment "
literal|"pointers unsupported"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ccb_h
operator|->
name|flags
operator|&
name|CAM_SG_LIST_PHYS
operator|)
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"ahd_setup_data - Virtual segment "
literal|"addresses unsupported"
argument_list|)
expr_stmt|;
comment|/* Just use the segments provided */
name|segs
operator|=
operator|(
expr|struct
name|bus_dma_segment
operator|*
operator|)
name|csio
operator|->
name|data_ptr
expr_stmt|;
name|ahd_execute_scb
argument_list|(
name|scb
argument_list|,
name|segs
argument_list|,
name|csio
operator|->
name|sglist_cnt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|ahd_execute_scb
argument_list|(
name|scb
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ahd_abort_ccb
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|,
name|struct
name|cam_sim
modifier|*
name|sim
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
block|{
name|union
name|ccb
modifier|*
name|abort_ccb
decl_stmt|;
name|abort_ccb
operator|=
name|ccb
operator|->
name|cab
operator|.
name|abort_ccb
expr_stmt|;
switch|switch
condition|(
name|abort_ccb
operator|->
name|ccb_h
operator|.
name|func_code
condition|)
block|{
ifdef|#
directive|ifdef
name|AHD_TARGET_MODE
case|case
name|XPT_ACCEPT_TARGET_IO
case|:
case|case
name|XPT_IMMED_NOTIFY
case|:
case|case
name|XPT_CONT_TARGET_IO
case|:
block|{
name|struct
name|ahd_tmode_tstate
modifier|*
name|tstate
decl_stmt|;
name|struct
name|ahd_tmode_lstate
modifier|*
name|lstate
decl_stmt|;
name|struct
name|ccb_hdr_slist
modifier|*
name|list
decl_stmt|;
name|cam_status
name|status
decl_stmt|;
name|status
operator|=
name|ahd_find_tmode_devs
argument_list|(
name|ahd
argument_list|,
name|sim
argument_list|,
name|abort_ccb
argument_list|,
operator|&
name|tstate
argument_list|,
operator|&
name|lstate
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|status
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|abort_ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|==
name|XPT_ACCEPT_TARGET_IO
condition|)
name|list
operator|=
operator|&
name|lstate
operator|->
name|accept_tios
expr_stmt|;
elseif|else
if|if
condition|(
name|abort_ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|==
name|XPT_IMMED_NOTIFY
condition|)
name|list
operator|=
operator|&
name|lstate
operator|->
name|immed_notifies
expr_stmt|;
else|else
name|list
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|list
operator|!=
name|NULL
condition|)
block|{
name|struct
name|ccb_hdr
modifier|*
name|curelm
decl_stmt|;
name|int
name|found
decl_stmt|;
name|curelm
operator|=
name|SLIST_FIRST
argument_list|(
name|list
argument_list|)
expr_stmt|;
name|found
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|curelm
operator|==
operator|&
name|abort_ccb
operator|->
name|ccb_h
condition|)
block|{
name|found
operator|=
literal|1
expr_stmt|;
name|SLIST_REMOVE_HEAD
argument_list|(
name|list
argument_list|,
name|sim_links
operator|.
name|sle
argument_list|)
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
name|curelm
operator|!=
name|NULL
condition|)
block|{
name|struct
name|ccb_hdr
modifier|*
name|nextelm
decl_stmt|;
name|nextelm
operator|=
name|SLIST_NEXT
argument_list|(
name|curelm
argument_list|,
name|sim_links
operator|.
name|sle
argument_list|)
expr_stmt|;
if|if
condition|(
name|nextelm
operator|==
operator|&
name|abort_ccb
operator|->
name|ccb_h
condition|)
block|{
name|found
operator|=
literal|1
expr_stmt|;
name|SLIST_NEXT
argument_list|(
name|curelm
argument_list|,
name|sim_links
operator|.
name|sle
argument_list|)
operator|=
name|SLIST_NEXT
argument_list|(
name|nextelm
argument_list|,
name|sim_links
operator|.
name|sle
argument_list|)
expr_stmt|;
break|break;
block|}
name|curelm
operator|=
name|nextelm
expr_stmt|;
block|}
block|}
if|if
condition|(
name|found
condition|)
block|{
name|abort_ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_ABORTED
expr_stmt|;
name|xpt_done
argument_list|(
name|abort_ccb
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
block|}
else|else
block|{
name|xpt_print_path
argument_list|(
name|abort_ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Not found\n"
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_PATH_INVALID
expr_stmt|;
block|}
break|break;
block|}
comment|/* FALLTHROUGH */
block|}
endif|#
directive|endif
case|case
name|XPT_SCSI_IO
case|:
comment|/* XXX Fully implement the hard ones */
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_UA_ABORT
expr_stmt|;
break|break;
default|default:
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_INVALID
expr_stmt|;
break|break;
block|}
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ahd_send_async
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|,
name|char
name|channel
parameter_list|,
name|u_int
name|target
parameter_list|,
name|u_int
name|lun
parameter_list|,
name|ac_code
name|code
parameter_list|,
name|void
modifier|*
name|opt_arg
parameter_list|)
block|{
name|struct
name|ccb_trans_settings
name|cts
decl_stmt|;
name|struct
name|cam_path
modifier|*
name|path
decl_stmt|;
name|void
modifier|*
name|arg
decl_stmt|;
name|int
name|error
decl_stmt|;
name|arg
operator|=
name|NULL
expr_stmt|;
name|error
operator|=
name|ahd_create_path
argument_list|(
name|ahd
argument_list|,
name|channel
argument_list|,
name|target
argument_list|,
name|lun
argument_list|,
operator|&
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
name|CAM_REQ_CMP
condition|)
return|return;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|AC_TRANSFER_NEG
case|:
block|{
name|struct
name|ccb_trans_settings_scsi
modifier|*
name|scsi
decl_stmt|;
name|cts
operator|.
name|type
operator|=
name|CTS_TYPE_CURRENT_SETTINGS
expr_stmt|;
name|scsi
operator|=
operator|&
name|cts
operator|.
name|proto_specific
operator|.
name|scsi
expr_stmt|;
name|cts
operator|.
name|ccb_h
operator|.
name|path
operator|=
name|path
expr_stmt|;
name|cts
operator|.
name|ccb_h
operator|.
name|target_id
operator|=
name|target
expr_stmt|;
name|cts
operator|.
name|ccb_h
operator|.
name|target_lun
operator|=
name|lun
expr_stmt|;
name|ahd_get_tran_settings
argument_list|(
name|ahd
argument_list|,
name|ahd
operator|->
name|our_id
argument_list|,
name|channel
argument_list|,
operator|&
name|cts
argument_list|)
expr_stmt|;
name|arg
operator|=
operator|&
name|cts
expr_stmt|;
name|scsi
operator|->
name|valid
operator|&=
operator|~
name|CTS_SCSI_VALID_TQ
expr_stmt|;
name|scsi
operator|->
name|flags
operator|&=
operator|~
name|CTS_SCSI_FLAGS_TAG_ENB
expr_stmt|;
if|if
condition|(
name|opt_arg
operator|==
name|NULL
condition|)
break|break;
if|if
condition|(
operator|*
operator|(
operator|(
name|ahd_queue_alg
operator|*
operator|)
name|opt_arg
operator|)
operator|==
name|AHD_QUEUE_TAGGED
condition|)
name|scsi
operator|->
name|flags
operator||=
operator|~
name|CTS_SCSI_FLAGS_TAG_ENB
expr_stmt|;
name|scsi
operator|->
name|valid
operator||=
name|CTS_SCSI_VALID_TQ
expr_stmt|;
break|break;
block|}
case|case
name|AC_SENT_BDR
case|:
case|case
name|AC_BUS_RESET
case|:
break|break;
default|default:
name|panic
argument_list|(
literal|"ahd_send_async: Unexpected async event"
argument_list|)
expr_stmt|;
block|}
name|xpt_async
argument_list|(
name|code
argument_list|,
name|path
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|xpt_free_path
argument_list|(
name|path
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ahd_platform_set_tags
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|,
name|struct
name|ahd_devinfo
modifier|*
name|devinfo
parameter_list|,
name|int
name|enable
parameter_list|)
block|{ }
end_function

begin_function
name|int
name|ahd_platform_alloc
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|,
name|void
modifier|*
name|platform_arg
parameter_list|)
block|{
name|ahd
operator|->
name|platform_data
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ahd_platform_data
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|ahd
operator|->
name|platform_data
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|ahd_platform_free
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|)
block|{
name|struct
name|ahd_platform_data
modifier|*
name|pdata
decl_stmt|;
name|pdata
operator|=
name|ahd
operator|->
name|platform_data
expr_stmt|;
if|if
condition|(
name|pdata
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|pdata
operator|->
name|regs
index|[
literal|0
index|]
operator|!=
name|NULL
condition|)
name|bus_release_resource
argument_list|(
name|ahd
operator|->
name|dev_softc
argument_list|,
name|pdata
operator|->
name|regs_res_type
index|[
literal|0
index|]
argument_list|,
name|pdata
operator|->
name|regs_res_id
index|[
literal|0
index|]
argument_list|,
name|pdata
operator|->
name|regs
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|pdata
operator|->
name|regs
index|[
literal|1
index|]
operator|!=
name|NULL
condition|)
name|bus_release_resource
argument_list|(
name|ahd
operator|->
name|dev_softc
argument_list|,
name|pdata
operator|->
name|regs_res_type
index|[
literal|1
index|]
argument_list|,
name|pdata
operator|->
name|regs_res_id
index|[
literal|1
index|]
argument_list|,
name|pdata
operator|->
name|regs
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|pdata
operator|->
name|irq
operator|!=
name|NULL
condition|)
name|bus_release_resource
argument_list|(
name|ahd
operator|->
name|dev_softc
argument_list|,
name|pdata
operator|->
name|irq_res_type
argument_list|,
literal|0
argument_list|,
name|pdata
operator|->
name|irq
argument_list|)
expr_stmt|;
if|if
condition|(
name|pdata
operator|->
name|sim
operator|!=
name|NULL
condition|)
block|{
name|xpt_async
argument_list|(
name|AC_LOST_DEVICE
argument_list|,
name|pdata
operator|->
name|path
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|xpt_free_path
argument_list|(
name|pdata
operator|->
name|path
argument_list|)
expr_stmt|;
name|xpt_bus_deregister
argument_list|(
name|cam_sim_path
argument_list|(
name|pdata
operator|->
name|sim
argument_list|)
argument_list|)
expr_stmt|;
name|cam_sim_free
argument_list|(
name|pdata
operator|->
name|sim
argument_list|,
comment|/*free_devq*/
name|TRUE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pdata
operator|->
name|eh
operator|!=
name|NULL
condition|)
name|EVENTHANDLER_DEREGISTER
argument_list|(
name|shutdown_final
argument_list|,
name|pdata
operator|->
name|eh
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ahd
operator|->
name|platform_data
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|ahd_softc_comp
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|lahd
parameter_list|,
name|struct
name|ahd_softc
modifier|*
name|rahd
parameter_list|)
block|{
comment|/* We don't sort softcs under FreeBSD so report equal always */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ahd_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|ahd_softc
modifier|*
name|ahd
decl_stmt|;
name|u_long
name|l
decl_stmt|;
name|u_long
name|s
decl_stmt|;
name|ahd_list_lock
argument_list|(
operator|&
name|l
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"detaching device\n"
argument_list|)
expr_stmt|;
name|ahd
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|ahd
operator|=
name|ahd_find_softc
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
if|if
condition|(
name|ahd
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"aic7xxx already detached\n"
argument_list|)
expr_stmt|;
name|ahd_list_unlock
argument_list|(
operator|&
name|l
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
name|TAILQ_REMOVE
argument_list|(
operator|&
name|ahd_tailq
argument_list|,
name|ahd
argument_list|,
name|links
argument_list|)
expr_stmt|;
name|ahd_list_unlock
argument_list|(
operator|&
name|l
argument_list|)
expr_stmt|;
name|ahd_lock
argument_list|(
name|ahd
argument_list|,
operator|&
name|s
argument_list|)
expr_stmt|;
name|ahd_intr_enable
argument_list|(
name|ahd
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|bus_teardown_intr
argument_list|(
name|dev
argument_list|,
name|ahd
operator|->
name|platform_data
operator|->
name|irq
argument_list|,
name|ahd
operator|->
name|platform_data
operator|->
name|ih
argument_list|)
expr_stmt|;
name|ahd_unlock
argument_list|(
name|ahd
argument_list|,
operator|&
name|s
argument_list|)
expr_stmt|;
name|ahd_free
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
unit|static void ahd_dump_targcmd(struct target_cmd *cmd) { 	uint8_t *byte; 	uint8_t *last_byte; 	int i;  	byte =&cmd->initiator_channel;
comment|/* Debugging info for received commands */
end_comment

begin_endif
unit|last_byte =&cmd[1].initiator_channel;  	i = 0; 	while (byte< last_byte) { 		if (i == 0) 			printf("\t"); 		printf("%#x", *byte++); 		i++; 		if (i == 8) { 			printf("\n"); 			i = 0; 		} else { 			printf(", "); 		} 	} }
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|int
name|ahd_modevent
parameter_list|(
name|module_t
name|mod
parameter_list|,
name|int
name|type
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
comment|/* XXX Deal with busy status on unload. */
comment|/* XXX Deal with unknown events */
return|return
literal|0
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|moduledata_t
name|ahd_mod
init|=
block|{
literal|"ahd"
block|,
name|ahd_modevent
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/********************************** DDB Hooks *********************************/
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|DDB
end_ifdef

begin_decl_stmt
specifier|static
name|struct
name|ahd_softc
modifier|*
name|ahd_ddb_softc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ahd_ddb_paused
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ahd_ddb_paused_on_entry
decl_stmt|;
end_decl_stmt

begin_macro
name|DB_COMMAND
argument_list|(
argument|ahd_sunit
argument_list|,
argument|ahd_ddb_sunit
argument_list|)
end_macro

begin_block
block|{
name|struct
name|ahd_softc
modifier|*
name|list_ahd
decl_stmt|;
name|ahd_ddb_softc
operator|=
name|NULL
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|list_ahd
argument_list|,
argument|&ahd_tailq
argument_list|,
argument|links
argument_list|)
block|{
if|if
condition|(
name|list_ahd
operator|->
name|unit
operator|==
name|addr
condition|)
name|ahd_ddb_softc
operator|=
name|list_ahd
expr_stmt|;
block|}
if|if
condition|(
name|ahd_ddb_softc
operator|==
name|NULL
condition|)
name|db_error
argument_list|(
literal|"No matching softc found!\n"
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|DB_COMMAND
argument_list|(
argument|ahd_pause
argument_list|,
argument|ahd_ddb_pause
argument_list|)
end_macro

begin_block
block|{
if|if
condition|(
name|ahd_ddb_softc
operator|==
name|NULL
condition|)
block|{
name|db_error
argument_list|(
literal|"Must set unit with ahd_sunit first!\n"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|ahd_ddb_paused
operator|==
literal|0
condition|)
block|{
name|ahd_ddb_paused
operator|++
expr_stmt|;
if|if
condition|(
name|ahd_is_paused
argument_list|(
name|ahd_ddb_softc
argument_list|)
condition|)
block|{
name|ahd_ddb_paused_on_entry
operator|++
expr_stmt|;
return|return;
block|}
name|ahd_pause
argument_list|(
name|ahd_ddb_softc
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|DB_COMMAND
argument_list|(
argument|ahd_unpause
argument_list|,
argument|ahd_ddb_unpause
argument_list|)
end_macro

begin_block
block|{
if|if
condition|(
name|ahd_ddb_softc
operator|==
name|NULL
condition|)
block|{
name|db_error
argument_list|(
literal|"Must set unit with ahd_sunit first!\n"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|ahd_ddb_paused
operator|!=
literal|0
condition|)
block|{
name|ahd_ddb_paused
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ahd_ddb_paused_on_entry
condition|)
return|return;
name|ahd_unpause
argument_list|(
name|ahd_ddb_softc
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ahd_ddb_paused_on_entry
operator|!=
literal|0
condition|)
block|{
comment|/* Two unpauses to clear a paused on entry. */
name|ahd_ddb_paused_on_entry
operator|=
literal|0
expr_stmt|;
name|ahd_unpause
argument_list|(
name|ahd_ddb_softc
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|DB_COMMAND
argument_list|(
argument|ahd_in
argument_list|,
argument|ahd_ddb_in
argument_list|)
end_macro

begin_block
block|{
name|int
name|c
decl_stmt|;
name|int
name|size
decl_stmt|;
if|if
condition|(
name|ahd_ddb_softc
operator|==
name|NULL
condition|)
block|{
name|db_error
argument_list|(
literal|"Must set unit with ahd_sunit first!\n"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|have_addr
operator|==
literal|0
condition|)
return|return;
name|size
operator|=
literal|1
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|modif
operator|++
operator|)
operator|!=
literal|'\0'
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'b'
case|:
name|size
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
name|size
operator|=
literal|2
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
name|size
operator|=
literal|4
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|count
operator|<=
literal|0
condition|)
name|count
operator|=
literal|1
expr_stmt|;
while|while
condition|(
operator|--
name|count
operator|>=
literal|0
condition|)
block|{
name|db_printf
argument_list|(
literal|"%04lx (M)%x: \t"
argument_list|,
operator|(
name|u_long
operator|)
name|addr
argument_list|,
name|ahd_inb
argument_list|(
name|ahd_ddb_softc
argument_list|,
name|MODE_PTR
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|size
condition|)
block|{
case|case
literal|1
case|:
name|db_printf
argument_list|(
literal|"%02x\n"
argument_list|,
name|ahd_inb
argument_list|(
name|ahd_ddb_softc
argument_list|,
name|addr
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|db_printf
argument_list|(
literal|"%04x\n"
argument_list|,
name|ahd_inw
argument_list|(
name|ahd_ddb_softc
argument_list|,
name|addr
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|db_printf
argument_list|(
literal|"%08x\n"
argument_list|,
name|ahd_inl
argument_list|(
name|ahd_ddb_softc
argument_list|,
name|addr
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
end_block

begin_macro
name|DB_FUNC
argument_list|(
argument|ahd_out
argument_list|,
argument|ahd_ddb_out
argument_list|,
argument|db_cmd_set
argument_list|,
argument|CS_MORE
argument_list|,
argument|NULL
argument_list|)
end_macro

begin_block
block|{
name|db_expr_t
name|old_value
decl_stmt|;
name|db_expr_t
name|new_value
decl_stmt|;
name|int
name|size
decl_stmt|;
if|if
condition|(
name|ahd_ddb_softc
operator|==
name|NULL
condition|)
block|{
name|db_error
argument_list|(
literal|"Must set unit with ahd_sunit first!\n"
argument_list|)
expr_stmt|;
return|return;
block|}
switch|switch
condition|(
name|modif
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|'\0'
case|:
case|case
literal|'b'
case|:
name|size
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
name|size
operator|=
literal|2
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
name|size
operator|=
literal|4
expr_stmt|;
break|break;
default|default:
name|db_error
argument_list|(
literal|"Unknown size\n"
argument_list|)
expr_stmt|;
return|return;
block|}
while|while
condition|(
name|db_expression
argument_list|(
operator|&
name|new_value
argument_list|)
condition|)
block|{
switch|switch
condition|(
name|size
condition|)
block|{
default|default:
case|case
literal|1
case|:
name|old_value
operator|=
name|ahd_inb
argument_list|(
name|ahd_ddb_softc
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|ahd_outb
argument_list|(
name|ahd_ddb_softc
argument_list|,
name|addr
argument_list|,
name|new_value
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|old_value
operator|=
name|ahd_inw
argument_list|(
name|ahd_ddb_softc
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|ahd_outw
argument_list|(
name|ahd_ddb_softc
argument_list|,
name|addr
argument_list|,
name|new_value
argument_list|)
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|old_value
operator|=
name|ahd_inl
argument_list|(
name|ahd_ddb_softc
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|ahd_outl
argument_list|(
name|ahd_ddb_softc
argument_list|,
name|addr
argument_list|,
name|new_value
argument_list|)
expr_stmt|;
break|break;
block|}
name|db_printf
argument_list|(
literal|"%04lx (M)%x: \t0x%lx\t=\t0x%lx"
argument_list|,
operator|(
name|u_long
operator|)
name|addr
argument_list|,
name|ahd_inb
argument_list|(
name|ahd_ddb_softc
argument_list|,
name|MODE_PTR
argument_list|)
argument_list|,
operator|(
name|u_long
operator|)
name|old_value
argument_list|,
operator|(
name|u_long
operator|)
name|new_value
argument_list|)
expr_stmt|;
name|addr
operator|+=
name|size
expr_stmt|;
block|}
name|db_skip_to_eol
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|DB_COMMAND
argument_list|(
argument|ahd_dump
argument_list|,
argument|ahd_ddb_dump
argument_list|)
end_macro

begin_block
block|{
if|if
condition|(
name|ahd_ddb_softc
operator|==
name|NULL
condition|)
block|{
name|db_error
argument_list|(
literal|"Must set unit with ahd_sunit first!\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|ahd_dump_card_state
argument_list|(
name|ahd_ddb_softc
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_expr_stmt
name|DECLARE_MODULE
argument_list|(
name|ahd
argument_list|,
name|ahd_mod
argument_list|,
name|SI_SUB_DRIVERS
argument_list|,
name|SI_ORDER_MIDDLE
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|ahd
argument_list|,
name|cam
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_VERSION
argument_list|(
name|ahd
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

