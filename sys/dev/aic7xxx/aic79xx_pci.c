begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Product specific probe and attach routines for:  *	aic7901 and aic7902 SCSI controllers  *  * Copyright (c) 1994-2001 Justin T. Gibbs.  * Copyright (c) 2000-2002 Adaptec Inc.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions, and the following disclaimer,  *    without modification.  * 2. Redistributions in binary form must reproduce at minimum a disclaimer  *    substantially similar to the "NO WARRANTY" disclaimer below  *    ("Disclaimer") and any redistribution must be conditioned upon  *    including a substantially similar Disclaimer requirement for further  *    binary redistribution.  * 3. Neither the names of the above-listed copyright holders nor the names  *    of any contributors may be used to endorse or promote products derived  *    from this software without specific prior written permission.  *  * Alternatively, this software may be distributed under the terms of the  * GNU General Public License ("GPL") version 2 as published by the Free  * Software Foundation.  *  * NO WARRANTY  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT  * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING  * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  * POSSIBILITY OF SUCH DAMAGES.  *  * $Id: //depot/aic7xxx/aic7xxx/aic79xx_pci.c#88 $  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__linux__
end_ifdef

begin_include
include|#
directive|include
file|"aic79xx_osm.h"
end_include

begin_include
include|#
directive|include
file|"aic79xx_inline.h"
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<dev/aic7xxx/aic79xx_osm.h>
end_include

begin_include
include|#
directive|include
file|<dev/aic7xxx/aic79xx_inline.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|__inline
name|uint64_t
name|ahd_compose_id
parameter_list|(
name|u_int
name|device
parameter_list|,
name|u_int
name|vendor
parameter_list|,
name|u_int
name|subdevice
parameter_list|,
name|u_int
name|subvendor
parameter_list|)
block|{
name|uint64_t
name|id
decl_stmt|;
name|id
operator|=
name|subvendor
operator||
operator|(
name|subdevice
operator|<<
literal|16
operator|)
operator||
operator|(
operator|(
name|uint64_t
operator|)
name|vendor
operator|<<
literal|32
operator|)
operator||
operator|(
operator|(
name|uint64_t
operator|)
name|device
operator|<<
literal|48
operator|)
expr_stmt|;
return|return
operator|(
name|id
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|ID_ALL_MASK
value|0xFFFFFFFFFFFFFFFFull
end_define

begin_define
define|#
directive|define
name|ID_ALL_IROC_MASK
value|0xFF7FFFFFFFFFFFFFull
end_define

begin_define
define|#
directive|define
name|ID_DEV_VENDOR_MASK
value|0xFFFFFFFF00000000ull
end_define

begin_define
define|#
directive|define
name|ID_9005_GENERIC_MASK
value|0xFFF0FFFF00000000ull
end_define

begin_define
define|#
directive|define
name|ID_9005_GENERIC_IROC_MASK
value|0xFF70FFFF00000000ull
end_define

begin_define
define|#
directive|define
name|ID_AIC7901
value|0x800F9005FFFF9005ull
end_define

begin_define
define|#
directive|define
name|ID_AHA_29320A
value|0x8000900500609005ull
end_define

begin_define
define|#
directive|define
name|ID_AHA_29320ALP
value|0x8017900500449005ull
end_define

begin_define
define|#
directive|define
name|ID_AIC7901A
value|0x801E9005FFFF9005ull
end_define

begin_define
define|#
directive|define
name|ID_AHA_29320LP
value|0x8014900500449005ull
end_define

begin_define
define|#
directive|define
name|ID_AIC7902
value|0x801F9005FFFF9005ull
end_define

begin_define
define|#
directive|define
name|ID_AIC7902_B
value|0x801D9005FFFF9005ull
end_define

begin_define
define|#
directive|define
name|ID_AHA_39320
value|0x8010900500409005ull
end_define

begin_define
define|#
directive|define
name|ID_AHA_29320
value|0x8012900500429005ull
end_define

begin_define
define|#
directive|define
name|ID_AHA_29320B
value|0x8013900500439005ull
end_define

begin_define
define|#
directive|define
name|ID_AHA_39320_B
value|0x8015900500409005ull
end_define

begin_define
define|#
directive|define
name|ID_AHA_39320_B_DELL
value|0x8015900501681028ull
end_define

begin_define
define|#
directive|define
name|ID_AHA_39320A
value|0x8016900500409005ull
end_define

begin_define
define|#
directive|define
name|ID_AHA_39320D
value|0x8011900500419005ull
end_define

begin_define
define|#
directive|define
name|ID_AHA_39320D_B
value|0x801C900500419005ull
end_define

begin_define
define|#
directive|define
name|ID_AHA_39320D_HP
value|0x8011900500AC0E11ull
end_define

begin_define
define|#
directive|define
name|ID_AHA_39320D_B_HP
value|0x801C900500AC0E11ull
end_define

begin_define
define|#
directive|define
name|ID_AIC7902_PCI_REV_A4
value|0x3
end_define

begin_define
define|#
directive|define
name|ID_AIC7902_PCI_REV_B0
value|0x10
end_define

begin_define
define|#
directive|define
name|SUBID_HP
value|0x0E11
end_define

begin_define
define|#
directive|define
name|DEVID_9005_HOSTRAID
parameter_list|(
name|id
parameter_list|)
value|((id)& 0x80)
end_define

begin_define
define|#
directive|define
name|DEVID_9005_TYPE
parameter_list|(
name|id
parameter_list|)
value|((id)& 0xF)
end_define

begin_define
define|#
directive|define
name|DEVID_9005_TYPE_HBA
value|0x0
end_define

begin_comment
comment|/* Standard Card */
end_comment

begin_define
define|#
directive|define
name|DEVID_9005_TYPE_HBA_2EXT
value|0x1
end_define

begin_comment
comment|/* 2 External Ports */
end_comment

begin_define
define|#
directive|define
name|DEVID_9005_TYPE_MB
value|0xF
end_define

begin_comment
comment|/* On Motherboard */
end_comment

begin_define
define|#
directive|define
name|DEVID_9005_MFUNC
parameter_list|(
name|id
parameter_list|)
value|((id)& 0x10)
end_define

begin_define
define|#
directive|define
name|DEVID_9005_PACKETIZED
parameter_list|(
name|id
parameter_list|)
value|((id)& 0x8000)
end_define

begin_define
define|#
directive|define
name|SUBID_9005_TYPE
parameter_list|(
name|id
parameter_list|)
value|((id)& 0xF)
end_define

begin_define
define|#
directive|define
name|SUBID_9005_TYPE_HBA
value|0x0
end_define

begin_comment
comment|/* Standard Card */
end_comment

begin_define
define|#
directive|define
name|SUBID_9005_TYPE_MB
value|0xF
end_define

begin_comment
comment|/* On Motherboard */
end_comment

begin_define
define|#
directive|define
name|SUBID_9005_AUTOTERM
parameter_list|(
name|id
parameter_list|)
value|(((id)& 0x10) == 0)
end_define

begin_define
define|#
directive|define
name|SUBID_9005_LEGACYCONN_FUNC
parameter_list|(
name|id
parameter_list|)
value|((id)& 0x20)
end_define

begin_define
define|#
directive|define
name|SUBID_9005_SEEPTYPE
parameter_list|(
name|id
parameter_list|)
value|((id)& 0x0C0)>> 6)
end_define

begin_define
define|#
directive|define
name|SUBID_9005_SEEPTYPE_NONE
value|0x0
end_define

begin_define
define|#
directive|define
name|SUBID_9005_SEEPTYPE_4K
value|0x1
end_define

begin_decl_stmt
specifier|static
name|ahd_device_setup_t
name|ahd_aic7901_setup
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ahd_device_setup_t
name|ahd_aic7901A_setup
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ahd_device_setup_t
name|ahd_aic7902_setup
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ahd_device_setup_t
name|ahd_aic790X_setup
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|ahd_pci_identity
name|ahd_pci_ident_table
index|[]
init|=
block|{
comment|/* aic7901 based controllers */
block|{
name|ID_AHA_29320A
block|,
name|ID_ALL_MASK
block|,
literal|"Adaptec 29320A Ultra320 SCSI adapter"
block|,
name|ahd_aic7901_setup
block|}
block|,
block|{
name|ID_AHA_29320ALP
block|,
name|ID_ALL_MASK
block|,
literal|"Adaptec 29320ALP Ultra320 SCSI adapter"
block|,
name|ahd_aic7901_setup
block|}
block|,
comment|/* aic7901A based controllers */
block|{
name|ID_AHA_29320LP
block|,
name|ID_ALL_MASK
block|,
literal|"Adaptec 29320LP Ultra320 SCSI adapter"
block|,
name|ahd_aic7901A_setup
block|}
block|,
comment|/* aic7902 based controllers */
block|{
name|ID_AHA_29320
block|,
name|ID_ALL_MASK
block|,
literal|"Adaptec 29320 Ultra320 SCSI adapter"
block|,
name|ahd_aic7902_setup
block|}
block|,
block|{
name|ID_AHA_29320B
block|,
name|ID_ALL_MASK
block|,
literal|"Adaptec 29320B Ultra320 SCSI adapter"
block|,
name|ahd_aic7902_setup
block|}
block|,
block|{
name|ID_AHA_39320
block|,
name|ID_ALL_MASK
block|,
literal|"Adaptec 39320 Ultra320 SCSI adapter"
block|,
name|ahd_aic7902_setup
block|}
block|,
block|{
name|ID_AHA_39320_B
block|,
name|ID_ALL_MASK
block|,
literal|"Adaptec 39320 Ultra320 SCSI adapter"
block|,
name|ahd_aic7902_setup
block|}
block|,
block|{
name|ID_AHA_39320_B_DELL
block|,
name|ID_ALL_MASK
block|,
literal|"Adaptec (Dell OEM) 39320 Ultra320 SCSI adapter"
block|,
name|ahd_aic7902_setup
block|}
block|,
block|{
name|ID_AHA_39320A
block|,
name|ID_ALL_MASK
block|,
literal|"Adaptec 39320A Ultra320 SCSI adapter"
block|,
name|ahd_aic7902_setup
block|}
block|,
block|{
name|ID_AHA_39320D
block|,
name|ID_ALL_MASK
block|,
literal|"Adaptec 39320D Ultra320 SCSI adapter"
block|,
name|ahd_aic7902_setup
block|}
block|,
block|{
name|ID_AHA_39320D_HP
block|,
name|ID_ALL_MASK
block|,
literal|"Adaptec (HP OEM) 39320D Ultra320 SCSI adapter"
block|,
name|ahd_aic7902_setup
block|}
block|,
block|{
name|ID_AHA_39320D_B
block|,
name|ID_ALL_MASK
block|,
literal|"Adaptec 39320D Ultra320 SCSI adapter"
block|,
name|ahd_aic7902_setup
block|}
block|,
block|{
name|ID_AHA_39320D_B_HP
block|,
name|ID_ALL_MASK
block|,
literal|"Adaptec (HP OEM) 39320D Ultra320 SCSI adapter"
block|,
name|ahd_aic7902_setup
block|}
block|,
comment|/* Generic chip probes for devices we don't know 'exactly' */
block|{
name|ID_AIC7901
operator|&
name|ID_9005_GENERIC_MASK
block|,
name|ID_9005_GENERIC_MASK
block|,
literal|"Adaptec AIC7901 Ultra320 SCSI adapter"
block|,
name|ahd_aic7901_setup
block|}
block|,
block|{
name|ID_AIC7901A
operator|&
name|ID_DEV_VENDOR_MASK
block|,
name|ID_DEV_VENDOR_MASK
block|,
literal|"Adaptec AIC7901A Ultra320 SCSI adapter"
block|,
name|ahd_aic7901A_setup
block|}
block|,
block|{
name|ID_AIC7902
operator|&
name|ID_9005_GENERIC_MASK
block|,
name|ID_9005_GENERIC_MASK
block|,
literal|"Adaptec AIC7902 Ultra320 SCSI adapter"
block|,
name|ahd_aic7902_setup
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|u_int
name|ahd_num_pci_devs
init|=
name|NUM_ELEMENTS
argument_list|(
name|ahd_pci_ident_table
argument_list|)
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|DEVCONFIG
value|0x40
end_define

begin_define
define|#
directive|define
name|PCIXINITPAT
value|0x0000E000ul
end_define

begin_define
define|#
directive|define
name|PCIXINIT_PCI33_66
value|0x0000E000ul
end_define

begin_define
define|#
directive|define
name|PCIXINIT_PCIX50_66
value|0x0000C000ul
end_define

begin_define
define|#
directive|define
name|PCIXINIT_PCIX66_100
value|0x0000A000ul
end_define

begin_define
define|#
directive|define
name|PCIXINIT_PCIX100_133
value|0x00008000ul
end_define

begin_define
define|#
directive|define
name|PCI_BUS_MODES_INDEX
parameter_list|(
name|devconfig
parameter_list|)
define|\
value|(((devconfig)& PCIXINITPAT)>> 13)
end_define

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|pci_bus_modes
index|[]
init|=
block|{
literal|"PCI bus mode unknown"
block|,
literal|"PCI bus mode unknown"
block|,
literal|"PCI bus mode unknown"
block|,
literal|"PCI bus mode unknown"
block|,
literal|"PCI-X 101-133Mhz"
block|,
literal|"PCI-X 67-100Mhz"
block|,
literal|"PCI-X 50-66Mhz"
block|,
literal|"PCI 33 or 66Mhz"
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|TESTMODE
value|0x00000800ul
end_define

begin_define
define|#
directive|define
name|IRDY_RST
value|0x00000200ul
end_define

begin_define
define|#
directive|define
name|FRAME_RST
value|0x00000100ul
end_define

begin_define
define|#
directive|define
name|PCI64BIT
value|0x00000080ul
end_define

begin_define
define|#
directive|define
name|MRDCEN
value|0x00000040ul
end_define

begin_define
define|#
directive|define
name|ENDIANSEL
value|0x00000020ul
end_define

begin_define
define|#
directive|define
name|MIXQWENDIANEN
value|0x00000008ul
end_define

begin_define
define|#
directive|define
name|DACEN
value|0x00000004ul
end_define

begin_define
define|#
directive|define
name|STPWLEVEL
value|0x00000002ul
end_define

begin_define
define|#
directive|define
name|QWENDIANSEL
value|0x00000001ul
end_define

begin_define
define|#
directive|define
name|DEVCONFIG1
value|0x44
end_define

begin_define
define|#
directive|define
name|PREQDIS
value|0x01
end_define

begin_define
define|#
directive|define
name|CSIZE_LATTIME
value|0x0c
end_define

begin_define
define|#
directive|define
name|CACHESIZE
value|0x000000fful
end_define

begin_define
define|#
directive|define
name|LATTIME
value|0x0000ff00ul
end_define

begin_function_decl
specifier|static
name|int
name|ahd_check_extport
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ahd_configure_termination
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|,
name|u_int
name|adapter_control
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ahd_pci_split_intr
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|,
name|u_int
name|intstat
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|struct
name|ahd_pci_identity
modifier|*
name|ahd_find_pci_device
parameter_list|(
name|aic_dev_softc_t
name|pci
parameter_list|)
block|{
name|uint64_t
name|full_id
decl_stmt|;
name|uint16_t
name|device
decl_stmt|;
name|uint16_t
name|vendor
decl_stmt|;
name|uint16_t
name|subdevice
decl_stmt|;
name|uint16_t
name|subvendor
decl_stmt|;
name|struct
name|ahd_pci_identity
modifier|*
name|entry
decl_stmt|;
name|u_int
name|i
decl_stmt|;
name|vendor
operator|=
name|aic_pci_read_config
argument_list|(
name|pci
argument_list|,
name|PCIR_DEVVENDOR
argument_list|,
comment|/*bytes*/
literal|2
argument_list|)
expr_stmt|;
name|device
operator|=
name|aic_pci_read_config
argument_list|(
name|pci
argument_list|,
name|PCIR_DEVICE
argument_list|,
comment|/*bytes*/
literal|2
argument_list|)
expr_stmt|;
name|subvendor
operator|=
name|aic_pci_read_config
argument_list|(
name|pci
argument_list|,
name|PCIR_SUBVEND_0
argument_list|,
comment|/*bytes*/
literal|2
argument_list|)
expr_stmt|;
name|subdevice
operator|=
name|aic_pci_read_config
argument_list|(
name|pci
argument_list|,
name|PCIR_SUBDEV_0
argument_list|,
comment|/*bytes*/
literal|2
argument_list|)
expr_stmt|;
name|full_id
operator|=
name|ahd_compose_id
argument_list|(
name|device
argument_list|,
name|vendor
argument_list|,
name|subdevice
argument_list|,
name|subvendor
argument_list|)
expr_stmt|;
comment|/* 	 * If we are configured to attach to HostRAID 	 * controllers, mask out the IROC/HostRAID bit 	 * in the  	 */
if|if
condition|(
name|ahd_attach_to_HostRAID_controllers
condition|)
name|full_id
operator|&=
name|ID_ALL_IROC_MASK
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ahd_num_pci_devs
condition|;
name|i
operator|++
control|)
block|{
name|entry
operator|=
operator|&
name|ahd_pci_ident_table
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|full_id
operator|==
operator|(
name|full_id
operator|&
name|entry
operator|->
name|id_mask
operator|)
condition|)
block|{
comment|/* Honor exclusion entries. */
if|if
condition|(
name|entry
operator|->
name|name
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
return|return
operator|(
name|entry
operator|)
return|;
block|}
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ahd_pci_config
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|,
name|struct
name|ahd_pci_identity
modifier|*
name|entry
parameter_list|)
block|{
name|struct
name|scb_data
modifier|*
name|shared_scb_data
decl_stmt|;
name|u_int
name|command
decl_stmt|;
name|uint32_t
name|devconfig
decl_stmt|;
name|uint16_t
name|device
decl_stmt|;
name|uint16_t
name|subvendor
decl_stmt|;
name|int
name|error
decl_stmt|;
name|shared_scb_data
operator|=
name|NULL
expr_stmt|;
name|ahd
operator|->
name|description
operator|=
name|entry
operator|->
name|name
expr_stmt|;
comment|/* 	 * Record if this is a HostRAID board. 	 */
name|device
operator|=
name|aic_pci_read_config
argument_list|(
name|ahd
operator|->
name|dev_softc
argument_list|,
name|PCIR_DEVICE
argument_list|,
comment|/*bytes*/
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|DEVID_9005_HOSTRAID
argument_list|(
name|device
argument_list|)
condition|)
name|ahd
operator|->
name|flags
operator||=
name|AHD_HOSTRAID_BOARD
expr_stmt|;
comment|/* 	 * Record if this is an HP board. 	 */
name|subvendor
operator|=
name|aic_pci_read_config
argument_list|(
name|ahd
operator|->
name|dev_softc
argument_list|,
name|PCIR_SUBVEND_0
argument_list|,
comment|/*bytes*/
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|subvendor
operator|==
name|SUBID_HP
condition|)
name|ahd
operator|->
name|flags
operator||=
name|AHD_HP_BOARD
expr_stmt|;
name|error
operator|=
name|entry
operator|->
name|setup
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* 	 * Find the PCI-X cap pointer.  If we don't find it, 	 * pcix_ptr will be 0. 	 */
name|pci_find_extcap
argument_list|(
name|ahd
operator|->
name|dev_softc
argument_list|,
name|PCIY_PCIX
argument_list|,
operator|&
name|ahd
operator|->
name|pcix_ptr
argument_list|)
expr_stmt|;
name|devconfig
operator|=
name|aic_pci_read_config
argument_list|(
name|ahd
operator|->
name|dev_softc
argument_list|,
name|DEVCONFIG
argument_list|,
comment|/*bytes*/
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|devconfig
operator|&
name|PCIXINITPAT
operator|)
operator|==
name|PCIXINIT_PCI33_66
condition|)
block|{
name|ahd
operator|->
name|chip
operator||=
name|AHD_PCI
expr_stmt|;
comment|/* Disable PCIX workarounds when running in PCI mode. */
name|ahd
operator|->
name|bugs
operator|&=
operator|~
name|AHD_PCIX_BUG_MASK
expr_stmt|;
block|}
else|else
block|{
name|ahd
operator|->
name|chip
operator||=
name|AHD_PCIX
expr_stmt|;
if|if
condition|(
name|ahd
operator|->
name|pcix_ptr
operator|==
literal|0
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|ahd
operator|->
name|bus_description
operator|=
name|pci_bus_modes
index|[
name|PCI_BUS_MODES_INDEX
argument_list|(
name|devconfig
argument_list|)
index|]
expr_stmt|;
name|aic_power_state_change
argument_list|(
name|ahd
argument_list|,
name|AIC_POWER_STATE_D0
argument_list|)
expr_stmt|;
name|error
operator|=
name|ahd_pci_map_registers
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* 	 * If we need to support high memory, enable dual 	 * address cycles.  This bit must be set to enable 	 * high address bit generation even if we are on a 	 * 64bit bus (PCI64BIT set in devconfig). 	 */
if|if
condition|(
operator|(
name|ahd
operator|->
name|flags
operator|&
operator|(
name|AHD_39BIT_ADDRESSING
operator||
name|AHD_64BIT_ADDRESSING
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|uint32_t
name|devconfig
decl_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"%s: Enabling 39Bit Addressing\n"
argument_list|,
name|ahd_name
argument_list|(
name|ahd
argument_list|)
argument_list|)
expr_stmt|;
name|devconfig
operator|=
name|aic_pci_read_config
argument_list|(
name|ahd
operator|->
name|dev_softc
argument_list|,
name|DEVCONFIG
argument_list|,
comment|/*bytes*/
literal|4
argument_list|)
expr_stmt|;
name|devconfig
operator||=
name|DACEN
expr_stmt|;
name|aic_pci_write_config
argument_list|(
name|ahd
operator|->
name|dev_softc
argument_list|,
name|DEVCONFIG
argument_list|,
name|devconfig
argument_list|,
comment|/*bytes*/
literal|4
argument_list|)
expr_stmt|;
block|}
comment|/* Ensure busmastering is enabled */
name|command
operator|=
name|aic_pci_read_config
argument_list|(
name|ahd
operator|->
name|dev_softc
argument_list|,
name|PCIR_COMMAND
argument_list|,
comment|/*bytes*/
literal|2
argument_list|)
expr_stmt|;
name|command
operator||=
name|PCIM_CMD_BUSMASTEREN
expr_stmt|;
name|aic_pci_write_config
argument_list|(
name|ahd
operator|->
name|dev_softc
argument_list|,
name|PCIR_COMMAND
argument_list|,
name|command
argument_list|,
comment|/*bytes*/
literal|2
argument_list|)
expr_stmt|;
name|error
operator|=
name|ahd_softc_init
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|ahd
operator|->
name|bus_intr
operator|=
name|ahd_pci_intr
expr_stmt|;
name|error
operator|=
name|ahd_reset
argument_list|(
name|ahd
argument_list|,
comment|/*reinit*/
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|ahd
operator|->
name|pci_cachesize
operator|=
name|aic_pci_read_config
argument_list|(
name|ahd
operator|->
name|dev_softc
argument_list|,
name|CSIZE_LATTIME
argument_list|,
comment|/*bytes*/
literal|1
argument_list|)
operator|&
name|CACHESIZE
expr_stmt|;
name|ahd
operator|->
name|pci_cachesize
operator|*=
literal|4
expr_stmt|;
name|ahd_set_modes
argument_list|(
name|ahd
argument_list|,
name|AHD_MODE_SCSI
argument_list|,
name|AHD_MODE_SCSI
argument_list|)
expr_stmt|;
comment|/* See if we have a SEEPROM and perform auto-term */
name|error
operator|=
name|ahd_check_extport
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* Core initialization */
name|error
operator|=
name|ahd_init
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* 	 * Allow interrupts now that we are completely setup. 	 */
name|error
operator|=
name|ahd_pci_map_int
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|ahd_lock
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
comment|/* 	 * Link this softc in with all other ahd instances. 	 */
name|ahd_softc_insert
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
name|ahd_unlock
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Perform some simple tests that should catch situations where  * our registers are invalidly mapped.  */
end_comment

begin_function
name|int
name|ahd_pci_test_register_access
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|)
block|{
name|uint32_t
name|cmd
decl_stmt|;
name|u_int
name|targpcistat
decl_stmt|;
name|u_int
name|pci_status1
decl_stmt|;
name|int
name|error
decl_stmt|;
name|uint8_t
name|hcntrl
decl_stmt|;
name|error
operator|=
name|EIO
expr_stmt|;
comment|/* 	 * Enable PCI error interrupt status, but suppress NMIs 	 * generated by SERR raised due to target aborts. 	 */
name|cmd
operator|=
name|aic_pci_read_config
argument_list|(
name|ahd
operator|->
name|dev_softc
argument_list|,
name|PCIR_COMMAND
argument_list|,
comment|/*bytes*/
literal|2
argument_list|)
expr_stmt|;
name|aic_pci_write_config
argument_list|(
name|ahd
operator|->
name|dev_softc
argument_list|,
name|PCIR_COMMAND
argument_list|,
name|cmd
operator|&
operator|~
name|PCIM_CMD_SERRESPEN
argument_list|,
comment|/*bytes*/
literal|2
argument_list|)
expr_stmt|;
comment|/* 	 * First a simple test to see if any 	 * registers can be read.  Reading 	 * HCNTRL has no side effects and has 	 * at least one bit that is guaranteed to 	 * be zero so it is a good register to 	 * use for this test. 	 */
name|hcntrl
operator|=
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|HCNTRL
argument_list|)
expr_stmt|;
if|if
condition|(
name|hcntrl
operator|==
literal|0xFF
condition|)
goto|goto
name|fail
goto|;
comment|/* 	 * Next create a situation where write combining 	 * or read prefetching could be initiated by the 	 * CPU or host bridge.  Our device does not support 	 * either, so look for data corruption and/or flaged 	 * PCI errors.  First pause without causing another 	 * chip reset. 	 */
name|hcntrl
operator|&=
operator|~
name|CHIPRST
expr_stmt|;
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|HCNTRL
argument_list|,
name|hcntrl
operator||
name|PAUSE
argument_list|)
expr_stmt|;
while|while
condition|(
name|ahd_is_paused
argument_list|(
name|ahd
argument_list|)
operator|==
literal|0
condition|)
empty_stmt|;
comment|/* Clear any PCI errors that occurred before our driver attached. */
name|ahd_set_modes
argument_list|(
name|ahd
argument_list|,
name|AHD_MODE_CFG
argument_list|,
name|AHD_MODE_CFG
argument_list|)
expr_stmt|;
name|targpcistat
operator|=
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|TARGPCISTAT
argument_list|)
expr_stmt|;
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|TARGPCISTAT
argument_list|,
name|targpcistat
argument_list|)
expr_stmt|;
name|pci_status1
operator|=
name|aic_pci_read_config
argument_list|(
name|ahd
operator|->
name|dev_softc
argument_list|,
name|PCIR_STATUS
operator|+
literal|1
argument_list|,
comment|/*bytes*/
literal|1
argument_list|)
expr_stmt|;
name|aic_pci_write_config
argument_list|(
name|ahd
operator|->
name|dev_softc
argument_list|,
name|PCIR_STATUS
operator|+
literal|1
argument_list|,
name|pci_status1
argument_list|,
comment|/*bytes*/
literal|1
argument_list|)
expr_stmt|;
name|ahd_set_modes
argument_list|(
name|ahd
argument_list|,
name|AHD_MODE_SCSI
argument_list|,
name|AHD_MODE_SCSI
argument_list|)
expr_stmt|;
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|CLRINT
argument_list|,
name|CLRPCIINT
argument_list|)
expr_stmt|;
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|SEQCTL0
argument_list|,
name|PERRORDIS
argument_list|)
expr_stmt|;
name|ahd_outl
argument_list|(
name|ahd
argument_list|,
name|SRAM_BASE
argument_list|,
literal|0x5aa555aa
argument_list|)
expr_stmt|;
if|if
condition|(
name|ahd_inl
argument_list|(
name|ahd
argument_list|,
name|SRAM_BASE
argument_list|)
operator|!=
literal|0x5aa555aa
condition|)
goto|goto
name|fail
goto|;
if|if
condition|(
operator|(
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|INTSTAT
argument_list|)
operator|&
name|PCIINT
operator|)
operator|!=
literal|0
condition|)
block|{
name|u_int
name|targpcistat
decl_stmt|;
name|ahd_set_modes
argument_list|(
name|ahd
argument_list|,
name|AHD_MODE_CFG
argument_list|,
name|AHD_MODE_CFG
argument_list|)
expr_stmt|;
name|targpcistat
operator|=
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|TARGPCISTAT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|targpcistat
operator|&
name|STA
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|fail
goto|;
block|}
name|error
operator|=
literal|0
expr_stmt|;
name|fail
label|:
if|if
condition|(
operator|(
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|INTSTAT
argument_list|)
operator|&
name|PCIINT
operator|)
operator|!=
literal|0
condition|)
block|{
name|ahd_set_modes
argument_list|(
name|ahd
argument_list|,
name|AHD_MODE_CFG
argument_list|,
name|AHD_MODE_CFG
argument_list|)
expr_stmt|;
name|targpcistat
operator|=
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|TARGPCISTAT
argument_list|)
expr_stmt|;
comment|/* Silently clear any latched errors. */
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|TARGPCISTAT
argument_list|,
name|targpcistat
argument_list|)
expr_stmt|;
name|pci_status1
operator|=
name|aic_pci_read_config
argument_list|(
name|ahd
operator|->
name|dev_softc
argument_list|,
name|PCIR_STATUS
operator|+
literal|1
argument_list|,
comment|/*bytes*/
literal|1
argument_list|)
expr_stmt|;
name|aic_pci_write_config
argument_list|(
name|ahd
operator|->
name|dev_softc
argument_list|,
name|PCIR_STATUS
operator|+
literal|1
argument_list|,
name|pci_status1
argument_list|,
comment|/*bytes*/
literal|1
argument_list|)
expr_stmt|;
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|CLRINT
argument_list|,
name|CLRPCIINT
argument_list|)
expr_stmt|;
block|}
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|SEQCTL0
argument_list|,
name|PERRORDIS
operator||
name|FAILDIS
argument_list|)
expr_stmt|;
name|aic_pci_write_config
argument_list|(
name|ahd
operator|->
name|dev_softc
argument_list|,
name|PCIR_COMMAND
argument_list|,
name|cmd
argument_list|,
comment|/*bytes*/
literal|2
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Check the external port logic for a serial eeprom  * and termination/cable detection contrls.  */
end_comment

begin_function
specifier|static
name|int
name|ahd_check_extport
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|)
block|{
name|struct
name|vpd_config
name|vpd
decl_stmt|;
name|struct
name|seeprom_config
modifier|*
name|sc
decl_stmt|;
name|u_int
name|adapter_control
decl_stmt|;
name|int
name|have_seeprom
decl_stmt|;
name|int
name|error
decl_stmt|;
name|sc
operator|=
name|ahd
operator|->
name|seep_config
expr_stmt|;
name|have_seeprom
operator|=
name|ahd_acquire_seeprom
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
if|if
condition|(
name|have_seeprom
condition|)
block|{
name|u_int
name|start_addr
decl_stmt|;
comment|/* 		 * Fetch VPD for this function and parse it. 		 */
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"%s: Reading VPD from SEEPROM..."
argument_list|,
name|ahd_name
argument_list|(
name|ahd
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Address is always in units of 16bit words */
name|start_addr
operator|=
operator|(
operator|(
literal|2
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|sc
argument_list|)
operator|)
operator|+
operator|(
sizeof|sizeof
argument_list|(
name|vpd
argument_list|)
operator|*
operator|(
name|ahd
operator|->
name|channel
operator|-
literal|'A'
operator|)
operator|)
operator|)
operator|/
literal|2
expr_stmt|;
name|error
operator|=
name|ahd_read_seeprom
argument_list|(
name|ahd
argument_list|,
operator|(
name|uint16_t
operator|*
operator|)
operator|&
name|vpd
argument_list|,
name|start_addr
argument_list|,
sizeof|sizeof
argument_list|(
name|vpd
argument_list|)
operator|/
literal|2
argument_list|,
comment|/*bytestream*/
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|error
operator|=
name|ahd_parse_vpddata
argument_list|(
name|ahd
argument_list|,
operator|&
name|vpd
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"%s: VPD parsing %s\n"
argument_list|,
name|ahd_name
argument_list|(
name|ahd
argument_list|)
argument_list|,
name|error
operator|==
literal|0
condition|?
literal|"successful"
else|:
literal|"failed"
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"%s: Reading SEEPROM..."
argument_list|,
name|ahd_name
argument_list|(
name|ahd
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Address is always in units of 16bit words */
name|start_addr
operator|=
operator|(
sizeof|sizeof
argument_list|(
operator|*
name|sc
argument_list|)
operator|/
literal|2
operator|)
operator|*
operator|(
name|ahd
operator|->
name|channel
operator|-
literal|'A'
operator|)
expr_stmt|;
name|error
operator|=
name|ahd_read_seeprom
argument_list|(
name|ahd
argument_list|,
operator|(
name|uint16_t
operator|*
operator|)
name|sc
argument_list|,
name|start_addr
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sc
argument_list|)
operator|/
literal|2
argument_list|,
comment|/*bytestream*/
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"Unable to read SEEPROM\n"
argument_list|)
expr_stmt|;
name|have_seeprom
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|have_seeprom
operator|=
name|ahd_verify_cksum
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
block|{
if|if
condition|(
name|have_seeprom
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"checksum error\n"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"done.\n"
argument_list|)
expr_stmt|;
block|}
block|}
name|ahd_release_seeprom
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|have_seeprom
condition|)
block|{
name|u_int
name|nvram_scb
decl_stmt|;
comment|/* 		 * Pull scratch ram settings and treat them as 		 * if they are the contents of an seeprom if 		 * the 'ADPT', 'BIOS', or 'ASPI' signature is found 		 * in SCB 0xFF.  We manually compose the data as 16bit 		 * values to avoid endian issues. 		 */
name|ahd_set_scbptr
argument_list|(
name|ahd
argument_list|,
literal|0xFF
argument_list|)
expr_stmt|;
name|nvram_scb
operator|=
name|ahd_inb_scbram
argument_list|(
name|ahd
argument_list|,
name|SCB_BASE
operator|+
name|NVRAM_SCB_OFFSET
argument_list|)
expr_stmt|;
if|if
condition|(
name|nvram_scb
operator|!=
literal|0xFF
operator|&&
operator|(
operator|(
name|ahd_inb_scbram
argument_list|(
name|ahd
argument_list|,
name|SCB_BASE
operator|+
literal|0
argument_list|)
operator|==
literal|'A'
operator|&&
name|ahd_inb_scbram
argument_list|(
name|ahd
argument_list|,
name|SCB_BASE
operator|+
literal|1
argument_list|)
operator|==
literal|'D'
operator|&&
name|ahd_inb_scbram
argument_list|(
name|ahd
argument_list|,
name|SCB_BASE
operator|+
literal|2
argument_list|)
operator|==
literal|'P'
operator|&&
name|ahd_inb_scbram
argument_list|(
name|ahd
argument_list|,
name|SCB_BASE
operator|+
literal|3
argument_list|)
operator|==
literal|'T'
operator|)
operator|||
operator|(
name|ahd_inb_scbram
argument_list|(
name|ahd
argument_list|,
name|SCB_BASE
operator|+
literal|0
argument_list|)
operator|==
literal|'B'
operator|&&
name|ahd_inb_scbram
argument_list|(
name|ahd
argument_list|,
name|SCB_BASE
operator|+
literal|1
argument_list|)
operator|==
literal|'I'
operator|&&
name|ahd_inb_scbram
argument_list|(
name|ahd
argument_list|,
name|SCB_BASE
operator|+
literal|2
argument_list|)
operator|==
literal|'O'
operator|&&
name|ahd_inb_scbram
argument_list|(
name|ahd
argument_list|,
name|SCB_BASE
operator|+
literal|3
argument_list|)
operator|==
literal|'S'
operator|)
operator|||
operator|(
name|ahd_inb_scbram
argument_list|(
name|ahd
argument_list|,
name|SCB_BASE
operator|+
literal|0
argument_list|)
operator|==
literal|'A'
operator|&&
name|ahd_inb_scbram
argument_list|(
name|ahd
argument_list|,
name|SCB_BASE
operator|+
literal|1
argument_list|)
operator|==
literal|'S'
operator|&&
name|ahd_inb_scbram
argument_list|(
name|ahd
argument_list|,
name|SCB_BASE
operator|+
literal|2
argument_list|)
operator|==
literal|'P'
operator|&&
name|ahd_inb_scbram
argument_list|(
name|ahd
argument_list|,
name|SCB_BASE
operator|+
literal|3
argument_list|)
operator|==
literal|'I'
operator|)
operator|)
condition|)
block|{
name|uint16_t
modifier|*
name|sc_data
decl_stmt|;
name|int
name|i
decl_stmt|;
name|ahd_set_scbptr
argument_list|(
name|ahd
argument_list|,
name|nvram_scb
argument_list|)
expr_stmt|;
name|sc_data
operator|=
operator|(
name|uint16_t
operator|*
operator|)
name|sc
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|64
condition|;
name|i
operator|+=
literal|2
control|)
operator|*
name|sc_data
operator|++
operator|=
name|ahd_inw_scbram
argument_list|(
name|ahd
argument_list|,
name|SCB_BASE
operator|+
name|i
argument_list|)
expr_stmt|;
name|have_seeprom
operator|=
name|ahd_verify_cksum
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|have_seeprom
condition|)
name|ahd
operator|->
name|flags
operator||=
name|AHD_SCB_CONFIG_USED
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|AHD_DEBUG
if|if
condition|(
name|have_seeprom
operator|!=
literal|0
operator|&&
operator|(
name|ahd_debug
operator|&
name|AHD_DUMP_SEEPROM
operator|)
operator|!=
literal|0
condition|)
block|{
name|uint16_t
modifier|*
name|sc_data
decl_stmt|;
name|int
name|i
decl_stmt|;
name|printf
argument_list|(
literal|"%s: Seeprom Contents:"
argument_list|,
name|ahd_name
argument_list|(
name|ahd
argument_list|)
argument_list|)
expr_stmt|;
name|sc_data
operator|=
operator|(
name|uint16_t
operator|*
operator|)
name|sc
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
sizeof|sizeof
argument_list|(
operator|*
name|sc
argument_list|)
operator|)
condition|;
name|i
operator|+=
literal|2
control|)
name|printf
argument_list|(
literal|"\n\t0x%.4x"
argument_list|,
name|sc_data
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
operator|!
name|have_seeprom
condition|)
block|{
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"%s: No SEEPROM available.\n"
argument_list|,
name|ahd_name
argument_list|(
name|ahd
argument_list|)
argument_list|)
expr_stmt|;
name|ahd
operator|->
name|flags
operator||=
name|AHD_USEDEFAULTS
expr_stmt|;
name|error
operator|=
name|ahd_default_config
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
name|adapter_control
operator|=
name|CFAUTOTERM
operator||
name|CFSEAUTOTERM
expr_stmt|;
name|free
argument_list|(
name|ahd
operator|->
name|seep_config
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|ahd
operator|->
name|seep_config
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|ahd_parse_cfgdata
argument_list|(
name|ahd
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|adapter_control
operator|=
name|sc
operator|->
name|adapter_control
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|ahd_configure_termination
argument_list|(
name|ahd
argument_list|,
name|adapter_control
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ahd_configure_termination
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|,
name|u_int
name|adapter_control
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|u_int
name|sxfrctl1
decl_stmt|;
name|uint8_t
name|termctl
decl_stmt|;
name|uint32_t
name|devconfig
decl_stmt|;
name|devconfig
operator|=
name|aic_pci_read_config
argument_list|(
name|ahd
operator|->
name|dev_softc
argument_list|,
name|DEVCONFIG
argument_list|,
comment|/*bytes*/
literal|4
argument_list|)
expr_stmt|;
name|devconfig
operator|&=
operator|~
name|STPWLEVEL
expr_stmt|;
if|if
condition|(
operator|(
name|ahd
operator|->
name|flags
operator|&
name|AHD_STPWLEVEL_A
operator|)
operator|!=
literal|0
condition|)
name|devconfig
operator||=
name|STPWLEVEL
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"%s: STPWLEVEL is %s\n"
argument_list|,
name|ahd_name
argument_list|(
name|ahd
argument_list|)
argument_list|,
operator|(
name|devconfig
operator|&
name|STPWLEVEL
operator|)
condition|?
literal|"on"
else|:
literal|"off"
argument_list|)
expr_stmt|;
name|aic_pci_write_config
argument_list|(
name|ahd
operator|->
name|dev_softc
argument_list|,
name|DEVCONFIG
argument_list|,
name|devconfig
argument_list|,
comment|/*bytes*/
literal|4
argument_list|)
expr_stmt|;
comment|/* Make sure current sensing is off. */
if|if
condition|(
operator|(
name|ahd
operator|->
name|flags
operator|&
name|AHD_CURRENT_SENSING
operator|)
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|ahd_write_flexport
argument_list|(
name|ahd
argument_list|,
name|FLXADDR_ROMSTAT_CURSENSECTL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Read to sense.  Write to set. 	 */
name|error
operator|=
name|ahd_read_flexport
argument_list|(
name|ahd
argument_list|,
name|FLXADDR_TERMCTL
argument_list|,
operator|&
name|termctl
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|adapter_control
operator|&
name|CFAUTOTERM
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"%s: Manual Primary Termination\n"
argument_list|,
name|ahd_name
argument_list|(
name|ahd
argument_list|)
argument_list|)
expr_stmt|;
name|termctl
operator|&=
operator|~
operator|(
name|FLX_TERMCTL_ENPRILOW
operator||
name|FLX_TERMCTL_ENPRIHIGH
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|adapter_control
operator|&
name|CFSTERM
operator|)
operator|!=
literal|0
condition|)
name|termctl
operator||=
name|FLX_TERMCTL_ENPRILOW
expr_stmt|;
if|if
condition|(
operator|(
name|adapter_control
operator|&
name|CFWSTERM
operator|)
operator|!=
literal|0
condition|)
name|termctl
operator||=
name|FLX_TERMCTL_ENPRIHIGH
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%s: Primary Auto-Term Sensing failed! "
literal|"Using Defaults.\n"
argument_list|,
name|ahd_name
argument_list|(
name|ahd
argument_list|)
argument_list|)
expr_stmt|;
name|termctl
operator|=
name|FLX_TERMCTL_ENPRILOW
operator||
name|FLX_TERMCTL_ENPRIHIGH
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|adapter_control
operator|&
name|CFSEAUTOTERM
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"%s: Manual Secondary Termination\n"
argument_list|,
name|ahd_name
argument_list|(
name|ahd
argument_list|)
argument_list|)
expr_stmt|;
name|termctl
operator|&=
operator|~
operator|(
name|FLX_TERMCTL_ENSECLOW
operator||
name|FLX_TERMCTL_ENSECHIGH
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|adapter_control
operator|&
name|CFSELOWTERM
operator|)
operator|!=
literal|0
condition|)
name|termctl
operator||=
name|FLX_TERMCTL_ENSECLOW
expr_stmt|;
if|if
condition|(
operator|(
name|adapter_control
operator|&
name|CFSEHIGHTERM
operator|)
operator|!=
literal|0
condition|)
name|termctl
operator||=
name|FLX_TERMCTL_ENSECHIGH
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%s: Secondary Auto-Term Sensing failed! "
literal|"Using Defaults.\n"
argument_list|,
name|ahd_name
argument_list|(
name|ahd
argument_list|)
argument_list|)
expr_stmt|;
name|termctl
operator||=
name|FLX_TERMCTL_ENSECLOW
operator||
name|FLX_TERMCTL_ENSECHIGH
expr_stmt|;
block|}
comment|/* 	 * Now set the termination based on what we found. 	 */
name|sxfrctl1
operator|=
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|SXFRCTL1
argument_list|)
operator|&
operator|~
name|STPWEN
expr_stmt|;
name|ahd
operator|->
name|flags
operator|&=
operator|~
name|AHD_TERM_ENB_A
expr_stmt|;
if|if
condition|(
operator|(
name|termctl
operator|&
name|FLX_TERMCTL_ENPRILOW
operator|)
operator|!=
literal|0
condition|)
block|{
name|ahd
operator|->
name|flags
operator||=
name|AHD_TERM_ENB_A
expr_stmt|;
name|sxfrctl1
operator||=
name|STPWEN
expr_stmt|;
block|}
comment|/* Must set the latch once in order to be effective. */
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|SXFRCTL1
argument_list|,
name|sxfrctl1
operator||
name|STPWEN
argument_list|)
expr_stmt|;
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|SXFRCTL1
argument_list|,
name|sxfrctl1
argument_list|)
expr_stmt|;
name|error
operator|=
name|ahd_write_flexport
argument_list|(
name|ahd
argument_list|,
name|FLXADDR_TERMCTL
argument_list|,
name|termctl
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%s: Unable to set termination settings!\n"
argument_list|,
name|ahd_name
argument_list|(
name|ahd
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bootverbose
condition|)
block|{
name|printf
argument_list|(
literal|"%s: Primary High byte termination %sabled\n"
argument_list|,
name|ahd_name
argument_list|(
name|ahd
argument_list|)
argument_list|,
operator|(
name|termctl
operator|&
name|FLX_TERMCTL_ENPRIHIGH
operator|)
condition|?
literal|"En"
else|:
literal|"Dis"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s: Primary Low byte termination %sabled\n"
argument_list|,
name|ahd_name
argument_list|(
name|ahd
argument_list|)
argument_list|,
operator|(
name|termctl
operator|&
name|FLX_TERMCTL_ENPRILOW
operator|)
condition|?
literal|"En"
else|:
literal|"Dis"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s: Secondary High byte termination %sabled\n"
argument_list|,
name|ahd_name
argument_list|(
name|ahd
argument_list|)
argument_list|,
operator|(
name|termctl
operator|&
name|FLX_TERMCTL_ENSECHIGH
operator|)
condition|?
literal|"En"
else|:
literal|"Dis"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s: Secondary Low byte termination %sabled\n"
argument_list|,
name|ahd_name
argument_list|(
name|ahd
argument_list|)
argument_list|,
operator|(
name|termctl
operator|&
name|FLX_TERMCTL_ENSECLOW
operator|)
condition|?
literal|"En"
else|:
literal|"Dis"
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_define
define|#
directive|define
name|DPE
value|0x80
end_define

begin_define
define|#
directive|define
name|SSE
value|0x40
end_define

begin_define
define|#
directive|define
name|RMA
value|0x20
end_define

begin_define
define|#
directive|define
name|RTA
value|0x10
end_define

begin_define
define|#
directive|define
name|STA
value|0x08
end_define

begin_define
define|#
directive|define
name|DPR
value|0x01
end_define

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|split_status_source
index|[]
init|=
block|{
literal|"DFF0"
block|,
literal|"DFF1"
block|,
literal|"OVLY"
block|,
literal|"CMC"
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|pci_status_source
index|[]
init|=
block|{
literal|"DFF0"
block|,
literal|"DFF1"
block|,
literal|"SG"
block|,
literal|"CMC"
block|,
literal|"OVLY"
block|,
literal|"NONE"
block|,
literal|"MSI"
block|,
literal|"TARG"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|split_status_strings
index|[]
init|=
block|{
literal|"%s: Received split response in %s.\n"
block|,
literal|"%s: Received split completion error message in %s\n"
block|,
literal|"%s: Receive overrun in %s\n"
block|,
literal|"%s: Count not complete in %s\n"
block|,
literal|"%s: Split completion data bucket in %s\n"
block|,
literal|"%s: Split completion address error in %s\n"
block|,
literal|"%s: Split completion byte count error in %s\n"
block|,
literal|"%s: Signaled Target-abort to early terminate a split in %s\n"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|pci_status_strings
index|[]
init|=
block|{
literal|"%s: Data Parity Error has been reported via PERR# in %s\n"
block|,
literal|"%s: Target initial wait state error in %s\n"
block|,
literal|"%s: Split completion read data parity error in %s\n"
block|,
literal|"%s: Split completion address attribute parity error in %s\n"
block|,
literal|"%s: Received a Target Abort in %s\n"
block|,
literal|"%s: Received a Master Abort in %s\n"
block|,
literal|"%s: Signal System Error Detected in %s\n"
block|,
literal|"%s: Address or Write Phase Parity Error Detected in %s.\n"
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|ahd_pci_intr
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|)
block|{
name|uint8_t
name|pci_status
index|[
literal|8
index|]
decl_stmt|;
name|ahd_mode_state
name|saved_modes
decl_stmt|;
name|u_int
name|pci_status1
decl_stmt|;
name|u_int
name|intstat
decl_stmt|;
name|u_int
name|i
decl_stmt|;
name|u_int
name|reg
decl_stmt|;
name|intstat
operator|=
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|INTSTAT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|intstat
operator|&
name|SPLTINT
operator|)
operator|!=
literal|0
condition|)
name|ahd_pci_split_intr
argument_list|(
name|ahd
argument_list|,
name|intstat
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|intstat
operator|&
name|PCIINT
operator|)
operator|==
literal|0
condition|)
return|return;
name|printf
argument_list|(
literal|"%s: PCI error Interrupt\n"
argument_list|,
name|ahd_name
argument_list|(
name|ahd
argument_list|)
argument_list|)
expr_stmt|;
name|saved_modes
operator|=
name|ahd_save_modes
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
name|ahd_dump_card_state
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
name|ahd_set_modes
argument_list|(
name|ahd
argument_list|,
name|AHD_MODE_CFG
argument_list|,
name|AHD_MODE_CFG
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|reg
operator|=
name|DF0PCISTAT
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
operator|,
name|reg
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|==
literal|5
condition|)
continue|continue;
name|pci_status
index|[
name|i
index|]
operator|=
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|reg
argument_list|)
expr_stmt|;
comment|/* Clear latched errors.  So our interrupt deasserts. */
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|reg
argument_list|,
name|pci_status
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
block|{
name|u_int
name|bit
decl_stmt|;
if|if
condition|(
name|i
operator|==
literal|5
condition|)
continue|continue;
for|for
control|(
name|bit
operator|=
literal|0
init|;
name|bit
operator|<
literal|8
condition|;
name|bit
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|pci_status
index|[
name|i
index|]
operator|&
operator|(
literal|0x1
operator|<<
name|bit
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
specifier|static
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
name|s
operator|=
name|pci_status_strings
index|[
name|bit
index|]
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|7
comment|/*TARG*/
operator|&&
name|bit
operator|==
literal|3
condition|)
name|s
operator|=
literal|"%s: Signaled Target Abort\n"
expr_stmt|;
name|printf
argument_list|(
name|s
argument_list|,
name|ahd_name
argument_list|(
name|ahd
argument_list|)
argument_list|,
name|pci_status_source
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|pci_status1
operator|=
name|aic_pci_read_config
argument_list|(
name|ahd
operator|->
name|dev_softc
argument_list|,
name|PCIR_STATUS
operator|+
literal|1
argument_list|,
comment|/*bytes*/
literal|1
argument_list|)
expr_stmt|;
name|aic_pci_write_config
argument_list|(
name|ahd
operator|->
name|dev_softc
argument_list|,
name|PCIR_STATUS
operator|+
literal|1
argument_list|,
name|pci_status1
argument_list|,
comment|/*bytes*/
literal|1
argument_list|)
expr_stmt|;
name|ahd_restore_modes
argument_list|(
name|ahd
argument_list|,
name|saved_modes
argument_list|)
expr_stmt|;
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|CLRINT
argument_list|,
name|CLRPCIINT
argument_list|)
expr_stmt|;
name|ahd_unpause
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ahd_pci_split_intr
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|,
name|u_int
name|intstat
parameter_list|)
block|{
name|uint8_t
name|split_status
index|[
literal|4
index|]
decl_stmt|;
name|uint8_t
name|split_status1
index|[
literal|4
index|]
decl_stmt|;
name|uint8_t
name|sg_split_status
index|[
literal|2
index|]
decl_stmt|;
name|uint8_t
name|sg_split_status1
index|[
literal|2
index|]
decl_stmt|;
name|ahd_mode_state
name|saved_modes
decl_stmt|;
name|u_int
name|i
decl_stmt|;
name|uint32_t
name|pcix_status
decl_stmt|;
comment|/* 	 * Check for splits in all modes.  Modes 0 and 1 	 * additionally have SG engine splits to look at. 	 */
name|pcix_status
operator|=
name|aic_pci_read_config
argument_list|(
name|ahd
operator|->
name|dev_softc
argument_list|,
name|ahd
operator|->
name|pcix_ptr
operator|+
name|PCIXR_STATUS
argument_list|,
comment|/*bytes*/
literal|4
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s: PCI Split Interrupt - PCI-X status = 0x%x\n"
argument_list|,
name|ahd_name
argument_list|(
name|ahd
argument_list|)
argument_list|,
name|pcix_status
operator|>>
literal|16
argument_list|)
expr_stmt|;
name|saved_modes
operator|=
name|ahd_save_modes
argument_list|(
name|ahd
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
name|ahd_set_modes
argument_list|(
name|ahd
argument_list|,
name|i
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|split_status
index|[
name|i
index|]
operator|=
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|DCHSPLTSTAT0
argument_list|)
expr_stmt|;
name|split_status1
index|[
name|i
index|]
operator|=
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|DCHSPLTSTAT1
argument_list|)
expr_stmt|;
comment|/* Clear latched errors.  So our interrupt deasserts. */
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|DCHSPLTSTAT0
argument_list|,
name|split_status
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|DCHSPLTSTAT1
argument_list|,
name|split_status1
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|1
condition|)
continue|continue;
name|sg_split_status
index|[
name|i
index|]
operator|=
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|SGSPLTSTAT0
argument_list|)
expr_stmt|;
name|sg_split_status1
index|[
name|i
index|]
operator|=
name|ahd_inb
argument_list|(
name|ahd
argument_list|,
name|SGSPLTSTAT1
argument_list|)
expr_stmt|;
comment|/* Clear latched errors.  So our interrupt deasserts. */
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|SGSPLTSTAT0
argument_list|,
name|sg_split_status
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|SGSPLTSTAT1
argument_list|,
name|sg_split_status1
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
name|u_int
name|bit
decl_stmt|;
for|for
control|(
name|bit
operator|=
literal|0
init|;
name|bit
operator|<
literal|8
condition|;
name|bit
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|split_status
index|[
name|i
index|]
operator|&
operator|(
literal|0x1
operator|<<
name|bit
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
specifier|static
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
name|s
operator|=
name|split_status_strings
index|[
name|bit
index|]
expr_stmt|;
name|printf
argument_list|(
name|s
argument_list|,
name|ahd_name
argument_list|(
name|ahd
argument_list|)
argument_list|,
name|split_status_source
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|>
literal|1
condition|)
continue|continue;
if|if
condition|(
operator|(
name|sg_split_status
index|[
name|i
index|]
operator|&
operator|(
literal|0x1
operator|<<
name|bit
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
specifier|static
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
name|s
operator|=
name|split_status_strings
index|[
name|bit
index|]
expr_stmt|;
name|printf
argument_list|(
name|s
argument_list|,
name|ahd_name
argument_list|(
name|ahd
argument_list|)
argument_list|,
literal|"SG"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* 	 * Clear PCI-X status bits. 	 */
name|aic_pci_write_config
argument_list|(
name|ahd
operator|->
name|dev_softc
argument_list|,
name|ahd
operator|->
name|pcix_ptr
operator|+
name|PCIXR_STATUS
argument_list|,
name|pcix_status
argument_list|,
comment|/*bytes*/
literal|4
argument_list|)
expr_stmt|;
name|ahd_outb
argument_list|(
name|ahd
argument_list|,
name|CLRINT
argument_list|,
name|CLRSPLTINT
argument_list|)
expr_stmt|;
name|ahd_restore_modes
argument_list|(
name|ahd
argument_list|,
name|saved_modes
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|ahd_aic7901_setup
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|)
block|{
name|ahd
operator|->
name|chip
operator|=
name|AHD_AIC7901
expr_stmt|;
name|ahd
operator|->
name|features
operator|=
name|AHD_AIC7901_FE
expr_stmt|;
return|return
operator|(
name|ahd_aic790X_setup
argument_list|(
name|ahd
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ahd_aic7901A_setup
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|)
block|{
name|ahd
operator|->
name|chip
operator|=
name|AHD_AIC7901A
expr_stmt|;
name|ahd
operator|->
name|features
operator|=
name|AHD_AIC7901A_FE
expr_stmt|;
return|return
operator|(
name|ahd_aic790X_setup
argument_list|(
name|ahd
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ahd_aic7902_setup
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|)
block|{
name|ahd
operator|->
name|chip
operator|=
name|AHD_AIC7902
expr_stmt|;
name|ahd
operator|->
name|features
operator|=
name|AHD_AIC7902_FE
expr_stmt|;
return|return
operator|(
name|ahd_aic790X_setup
argument_list|(
name|ahd
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ahd_aic790X_setup
parameter_list|(
name|struct
name|ahd_softc
modifier|*
name|ahd
parameter_list|)
block|{
name|aic_dev_softc_t
name|pci
decl_stmt|;
name|u_int
name|rev
decl_stmt|;
name|pci
operator|=
name|ahd
operator|->
name|dev_softc
expr_stmt|;
name|rev
operator|=
name|aic_pci_read_config
argument_list|(
name|pci
argument_list|,
name|PCIR_REVID
argument_list|,
comment|/*bytes*/
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|rev
operator|<
name|ID_AIC7902_PCI_REV_A4
condition|)
block|{
name|printf
argument_list|(
literal|"%s: Unable to attach to unsupported chip revision %d\n"
argument_list|,
name|ahd_name
argument_list|(
name|ahd
argument_list|)
argument_list|,
name|rev
argument_list|)
expr_stmt|;
name|aic_pci_write_config
argument_list|(
name|pci
argument_list|,
name|PCIR_COMMAND
argument_list|,
literal|0
argument_list|,
comment|/*bytes*/
literal|2
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|ahd
operator|->
name|channel
operator|=
name|aic_get_pci_function
argument_list|(
name|pci
argument_list|)
operator|+
literal|'A'
expr_stmt|;
if|if
condition|(
name|rev
operator|<
name|ID_AIC7902_PCI_REV_B0
condition|)
block|{
comment|/* 		 * Enable A series workarounds. 		 */
name|ahd
operator|->
name|bugs
operator||=
name|AHD_SENT_SCB_UPDATE_BUG
operator||
name|AHD_ABORT_LQI_BUG
operator||
name|AHD_PKT_BITBUCKET_BUG
operator||
name|AHD_LONG_SETIMO_BUG
operator||
name|AHD_NLQICRC_DELAYED_BUG
operator||
name|AHD_SCSIRST_BUG
operator||
name|AHD_LQO_ATNO_BUG
operator||
name|AHD_AUTOFLUSH_BUG
operator||
name|AHD_CLRLQO_AUTOCLR_BUG
operator||
name|AHD_PCIX_MMAPIO_BUG
operator||
name|AHD_PCIX_CHIPRST_BUG
operator||
name|AHD_PCIX_SCBRAM_RD_BUG
operator||
name|AHD_PKTIZED_STATUS_BUG
operator||
name|AHD_PKT_LUN_BUG
operator||
name|AHD_MDFF_WSCBPTR_BUG
operator||
name|AHD_REG_SLOW_SETTLE_BUG
operator||
name|AHD_SET_MODE_BUG
operator||
name|AHD_BUSFREEREV_BUG
operator||
name|AHD_NONPACKFIFO_BUG
operator||
name|AHD_PACED_NEGTABLE_BUG
operator||
name|AHD_FAINT_LED_BUG
expr_stmt|;
comment|/* 		 * IO Cell paramter setup. 		 */
name|AHD_SET_PRECOMP
argument_list|(
name|ahd
argument_list|,
name|AHD_PRECOMP_CUTBACK_29
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ahd
operator|->
name|flags
operator|&
name|AHD_HP_BOARD
operator|)
operator|==
literal|0
condition|)
name|AHD_SET_SLEWRATE
argument_list|(
name|ahd
argument_list|,
name|AHD_SLEWRATE_DEF_REVA
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|u_int
name|devconfig1
decl_stmt|;
name|ahd
operator|->
name|features
operator||=
name|AHD_RTI
operator||
name|AHD_NEW_IOCELL_OPTS
operator||
name|AHD_NEW_DFCNTRL_OPTS
operator||
name|AHD_FAST_CDB_DELIVERY
expr_stmt|;
name|ahd
operator|->
name|bugs
operator||=
name|AHD_LQOOVERRUN_BUG
operator||
name|AHD_EARLY_REQ_BUG
expr_stmt|;
comment|/* 		 * Some issues have been resolved in the 7901B. 		 */
if|if
condition|(
operator|(
name|ahd
operator|->
name|features
operator|&
name|AHD_MULTI_FUNC
operator|)
operator|!=
literal|0
condition|)
name|ahd
operator|->
name|bugs
operator||=
name|AHD_INTCOLLISION_BUG
operator||
name|AHD_ABORT_LQI_BUG
operator||
name|AHD_BUSFREEREV_BUG
expr_stmt|;
comment|/* 		 * IO Cell paramter setup. 		 */
name|AHD_SET_PRECOMP
argument_list|(
name|ahd
argument_list|,
name|AHD_PRECOMP_CUTBACK_29
argument_list|)
expr_stmt|;
name|AHD_SET_SLEWRATE
argument_list|(
name|ahd
argument_list|,
name|AHD_SLEWRATE_DEF_REVB
argument_list|)
expr_stmt|;
name|AHD_SET_AMPLITUDE
argument_list|(
name|ahd
argument_list|,
name|AHD_AMPLITUDE_DEF
argument_list|)
expr_stmt|;
comment|/* 		 * Set the PREQDIS bit for H2B which disables some workaround 		 * that doesn't work on regular PCI busses. 		 * XXX - Find out exactly what this does from the hardware 		 * 	 folks! 		 */
name|devconfig1
operator|=
name|aic_pci_read_config
argument_list|(
name|pci
argument_list|,
name|DEVCONFIG1
argument_list|,
comment|/*bytes*/
literal|1
argument_list|)
expr_stmt|;
name|aic_pci_write_config
argument_list|(
name|pci
argument_list|,
name|DEVCONFIG1
argument_list|,
name|devconfig1
operator||
name|PREQDIS
argument_list|,
comment|/*bytes*/
literal|1
argument_list|)
expr_stmt|;
name|devconfig1
operator|=
name|aic_pci_read_config
argument_list|(
name|pci
argument_list|,
name|DEVCONFIG1
argument_list|,
comment|/*bytes*/
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

end_unit

