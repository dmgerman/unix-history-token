begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*+M*************************************************************************  * Adaptec AIC7770/AIC7870 sequencer code assembler.  *  * Copyright (c) 1994 John Aycock  *   The University of Calgary Department of Computer Science.  *   All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions, and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *      This product includes software developed by the University of Calgary  *      Department of Computer Science and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * Comments are started by `#' and continue to the end of the line; lines  * may be of the form:  *<label>*  *<label>*<undef-sym> =<value>  *<label>*<opcode><operand>*  *  * A<label> is an<undef-sym> ending in a colon.  Spaces, tabs, and commas  * are token separators.  *  *-M*************************************************************************/
end_comment

begin_decl_stmt
specifier|static
name|char
name|id
index|[]
init|=
literal|"$Id: aic7xxx_asm.c,v 1.12 1996/03/31 03:02:35 gibbs Exp $"
decl_stmt|;
end_decl_stmt

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_define
define|#
directive|define
name|MEMORY
value|448
end_define

begin_define
define|#
directive|define
name|MAXLINE
value|1024
end_define

begin_define
define|#
directive|define
name|MAXTOKEN
value|32
end_define

begin_define
define|#
directive|define
name|ADOTOUT
value|"a.out"
end_define

begin_define
define|#
directive|define
name|NOVALUE
value|-1
end_define

begin_comment
comment|/*  * AIC-7770/AIC-7870 register definitions  */
end_comment

begin_define
define|#
directive|define
name|R_SINDEX
value|0x65
end_define

begin_define
define|#
directive|define
name|R_ALLONES
value|0x69
end_define

begin_define
define|#
directive|define
name|R_ALLZEROS
value|0x6a
end_define

begin_define
define|#
directive|define
name|R_NONE
value|0x6a
end_define

begin_decl_stmt
name|int
name|debug
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|lineno
decl_stmt|,
name|LC
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|filename
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|char
name|M
index|[
name|MEMORY
index|]
index|[
literal|4
index|]
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|error
parameter_list|(
name|char
modifier|*
name|s
parameter_list|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: %s at line %d\n"
argument_list|,
name|filename
argument_list|,
name|s
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
modifier|*
name|Malloc
parameter_list|(
name|size_t
name|size
parameter_list|)
block|{
name|void
modifier|*
name|p
init|=
name|malloc
argument_list|(
name|size
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|p
condition|)
name|error
argument_list|(
literal|"out of memory"
argument_list|)
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_function
name|void
modifier|*
name|Realloc
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|void
modifier|*
name|p
init|=
name|realloc
argument_list|(
name|ptr
argument_list|,
name|size
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|p
condition|)
name|error
argument_list|(
literal|"out of memory"
argument_list|)
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|Strdup
parameter_list|(
name|char
modifier|*
name|s
parameter_list|)
block|{
name|char
modifier|*
name|p
init|=
operator|(
name|char
operator|*
operator|)
name|Malloc
argument_list|(
name|strlen
argument_list|(
name|s
argument_list|)
operator|+
literal|1
argument_list|)
decl_stmt|;
name|strcpy
argument_list|(
name|p
argument_list|,
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_typedef
typedef|typedef
struct|struct
name|sym_t
block|{
name|struct
name|sym_t
modifier|*
name|next
decl_stmt|;
comment|/* MUST BE FIRST */
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|value
decl_stmt|;
name|int
name|npatch
decl_stmt|;
name|int
modifier|*
name|patch
decl_stmt|;
block|}
name|sym_t
typedef|;
end_typedef

begin_decl_stmt
name|sym_t
modifier|*
name|head
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|define
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|int
name|value
parameter_list|)
block|{
name|sym_t
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
for|for
control|(
name|p
operator|=
name|head
operator|,
name|q
operator|=
operator|(
name|sym_t
operator|*
operator|)
operator|&
name|head
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
operator|->
name|name
argument_list|,
name|name
argument_list|)
condition|)
name|error
argument_list|(
literal|"redefined symbol"
argument_list|)
expr_stmt|;
name|q
operator|=
name|p
expr_stmt|;
block|}
name|p
operator|=
name|q
operator|->
name|next
operator|=
operator|(
name|sym_t
operator|*
operator|)
name|Malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|sym_t
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|p
operator|->
name|name
operator|=
name|Strdup
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|p
operator|->
name|value
operator|=
name|value
expr_stmt|;
name|p
operator|->
name|npatch
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|patch
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|debug
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\"%s\" "
argument_list|,
name|p
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|value
operator|!=
name|NOVALUE
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"defined as 0x%x\n"
argument_list|,
name|p
operator|->
name|value
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"undefined\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|sym_t
modifier|*
name|lookup
parameter_list|(
name|char
modifier|*
name|name
parameter_list|)
block|{
name|sym_t
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|head
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
operator|->
name|name
argument_list|,
name|name
argument_list|)
condition|)
return|return
operator|(
name|p
operator|)
return|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
name|void
name|patch
parameter_list|(
name|sym_t
modifier|*
name|p
parameter_list|,
name|int
name|location
parameter_list|)
block|{
name|p
operator|->
name|npatch
operator|+=
literal|1
expr_stmt|;
name|p
operator|->
name|patch
operator|=
operator|(
name|int
operator|*
operator|)
name|Realloc
argument_list|(
name|p
operator|->
name|patch
argument_list|,
name|p
operator|->
name|npatch
operator|*
sizeof|sizeof
argument_list|(
name|int
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|->
name|patch
index|[
name|p
operator|->
name|npatch
operator|-
literal|1
index|]
operator|=
name|location
expr_stmt|;
block|}
end_function

begin_function
name|void
name|backpatch
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|sym_t
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|head
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
if|if
condition|(
name|p
operator|->
name|value
operator|==
name|NOVALUE
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: undefined symbol \"%s\"\n"
argument_list|,
name|filename
argument_list|,
name|p
operator|->
name|name
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|->
name|npatch
condition|)
block|{
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\"%s\" (0x%x) patched at"
argument_list|,
name|p
operator|->
name|name
argument_list|,
name|p
operator|->
name|value
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|p
operator|->
name|npatch
condition|;
name|i
operator|++
control|)
block|{
name|M
index|[
name|p
operator|->
name|patch
index|[
name|i
index|]
index|]
index|[
literal|0
index|]
operator|&=
operator|~
literal|1
expr_stmt|;
name|M
index|[
name|p
operator|->
name|patch
index|[
name|i
index|]
index|]
index|[
literal|0
index|]
operator||=
operator|(
operator|(
name|p
operator|->
name|value
operator|>>
literal|8
operator|)
operator|&
literal|1
operator|)
expr_stmt|;
name|M
index|[
name|p
operator|->
name|patch
index|[
name|i
index|]
index|]
index|[
literal|1
index|]
operator|=
name|p
operator|->
name|value
operator|&
literal|0xff
expr_stmt|;
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" 0x%x"
argument_list|,
name|p
operator|->
name|patch
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|debug
condition|)
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  *  Output words in byte-reversed order (least significant first)  *  since the sequencer RAM is loaded that way.  */
end_comment

begin_function
name|void
name|output
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|LC
condition|;
name|i
operator|++
control|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\t0x%02x, 0x%02x, 0x%02x, 0x%02x,\n"
argument_list|,
name|M
index|[
name|i
index|]
index|[
literal|3
index|]
argument_list|,
name|M
index|[
name|i
index|]
index|[
literal|2
index|]
argument_list|,
name|M
index|[
name|i
index|]
index|[
literal|1
index|]
argument_list|,
name|M
index|[
name|i
index|]
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%d out of %d instructions used.\n"
argument_list|,
name|LC
argument_list|,
name|MEMORY
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|char
modifier|*
modifier|*
name|getl
parameter_list|(
name|int
modifier|*
name|n
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|quote
decl_stmt|;
specifier|static
name|char
name|buf
index|[
name|MAXLINE
index|]
decl_stmt|;
specifier|static
name|char
modifier|*
name|a
index|[
name|MAXTOKEN
index|]
decl_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|fgets
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|stdin
argument_list|)
condition|)
block|{
name|lineno
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
name|buf
index|[
name|strlen
argument_list|(
name|buf
argument_list|)
operator|-
literal|1
index|]
operator|!=
literal|'\n'
condition|)
name|error
argument_list|(
literal|"line too long"
argument_list|)
expr_stmt|;
name|p
operator|=
name|strchr
argument_list|(
name|buf
argument_list|,
literal|'#'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
condition|)
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
name|p
operator|=
name|buf
expr_stmt|;
name|rescan
label|:
name|quote
operator|=
name|strchr
argument_list|(
name|p
argument_list|,
literal|'\"'
argument_list|)
expr_stmt|;
if|if
condition|(
name|quote
condition|)
operator|*
name|quote
operator|=
literal|'\0'
expr_stmt|;
for|for
control|(
name|p
operator|=
name|strtok
argument_list|(
name|p
argument_list|,
literal|", \t\n"
argument_list|)
init|;
name|p
condition|;
name|p
operator|=
name|strtok
argument_list|(
name|NULL
argument_list|,
literal|", \t\n"
argument_list|)
control|)
if|if
condition|(
name|i
operator|<
name|MAXTOKEN
operator|-
literal|1
condition|)
name|a
index|[
name|i
operator|++
index|]
operator|=
name|p
expr_stmt|;
else|else
name|error
argument_list|(
literal|"too many tokens"
argument_list|)
expr_stmt|;
if|if
condition|(
name|quote
condition|)
block|{
name|quote
operator|++
expr_stmt|;
name|p
operator|=
name|strchr
argument_list|(
name|quote
argument_list|,
literal|'\"'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p
condition|)
name|error
argument_list|(
literal|"unterminated string constant"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|<
name|MAXTOKEN
operator|-
literal|1
condition|)
block|{
name|a
index|[
name|i
operator|++
index|]
operator|=
name|quote
expr_stmt|;
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|"too many tokens"
argument_list|)
expr_stmt|;
goto|goto
name|rescan
goto|;
block|}
if|if
condition|(
name|i
condition|)
block|{
operator|*
name|n
operator|=
name|i
expr_stmt|;
return|return
operator|(
name|a
operator|)
return|;
block|}
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|A
value|0x8000
end_define

begin_comment
comment|/* `A'ccumulator ok */
end_comment

begin_define
define|#
directive|define
name|I
value|0x4000
end_define

begin_comment
comment|/* use as immediate value */
end_comment

begin_define
define|#
directive|define
name|SL
value|0x2000
end_define

begin_comment
comment|/* shift left */
end_comment

begin_define
define|#
directive|define
name|SR
value|0x1000
end_define

begin_comment
comment|/* shift right */
end_comment

begin_define
define|#
directive|define
name|RL
value|0x0800
end_define

begin_comment
comment|/* rotate left */
end_comment

begin_define
define|#
directive|define
name|RR
value|0x0400
end_define

begin_comment
comment|/* rotate right */
end_comment

begin_define
define|#
directive|define
name|LO
value|0x8000
end_define

begin_comment
comment|/* lookup: ori-{jmp,jc,jnc,call} */
end_comment

begin_define
define|#
directive|define
name|LA
value|0x4000
end_define

begin_comment
comment|/* lookup: and-{jz,jnz} */
end_comment

begin_define
define|#
directive|define
name|LX
value|0x2000
end_define

begin_comment
comment|/* lookup: xor-{je,jne} */
end_comment

begin_define
define|#
directive|define
name|NA
value|-1
end_define

begin_comment
comment|/* not applicable */
end_comment

begin_struct
struct|struct
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|n
decl_stmt|;
comment|/* number of operands, including opcode */
name|unsigned
name|int
name|op
decl_stmt|;
comment|/* immediate or L?|pos_from_0 */
name|unsigned
name|int
name|dest
decl_stmt|;
comment|/* NA, pos_from_0, or I|immediate */
name|unsigned
name|int
name|src
decl_stmt|;
comment|/* NA, pos_from_0, or I|immediate */
name|unsigned
name|int
name|imm
decl_stmt|;
comment|/* pos_from_0, A|pos_from_0, or I|immediate */
name|unsigned
name|int
name|addr
decl_stmt|;
comment|/* NA or pos_from_0 */
name|int
name|fmt
decl_stmt|;
comment|/* instruction format - 1, 2, or 3 */
block|}
name|instr
index|[]
init|=
block|{
comment|/*  *		  N  OP    DEST		SRC		IMM	ADDR	FMT  */
block|{
literal|"mov"
block|,
literal|3
block|,
literal|1
block|,
literal|1
block|,
literal|2
block|,
name|I
operator||
literal|0xff
block|,
name|NA
block|,
literal|1
block|}
block|,
block|{
literal|"mov"
block|,
literal|4
block|,
name|LO
operator||
literal|2
block|,
name|NA
block|,
literal|1
block|,
name|I
operator||
literal|0
block|,
literal|3
block|,
literal|3
block|}
block|,
block|{
literal|"mvi"
block|,
literal|3
block|,
literal|0
block|,
literal|1
block|,
name|I
operator||
name|R_ALLZEROS
block|,
name|A
operator||
literal|2
block|,
name|NA
block|,
literal|1
block|}
block|,
block|{
literal|"mvi"
block|,
literal|4
block|,
name|LO
operator||
literal|2
block|,
name|NA
block|,
name|I
operator||
name|R_ALLZEROS
block|,
literal|1
block|,
literal|3
block|,
literal|3
block|}
block|,
block|{
literal|"not"
block|,
literal|2
block|,
literal|2
block|,
literal|1
block|,
literal|1
block|,
name|I
operator||
literal|0xff
block|,
name|NA
block|,
literal|1
block|}
block|,
block|{
literal|"and"
block|,
literal|3
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
name|A
operator||
literal|2
block|,
name|NA
block|,
literal|1
block|}
block|,
block|{
literal|"and"
block|,
literal|4
block|,
literal|1
block|,
literal|1
block|,
literal|3
block|,
name|A
operator||
literal|2
block|,
name|NA
block|,
literal|1
block|}
block|,
block|{
literal|"or"
block|,
literal|3
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
name|A
operator||
literal|2
block|,
name|NA
block|,
literal|1
block|}
block|,
block|{
literal|"or"
block|,
literal|4
block|,
literal|0
block|,
literal|1
block|,
literal|3
block|,
name|A
operator||
literal|2
block|,
name|NA
block|,
literal|1
block|}
block|,
block|{
literal|"or"
block|,
literal|5
block|,
name|LO
operator||
literal|3
block|,
name|NA
block|,
literal|1
block|,
literal|2
block|,
literal|4
block|,
literal|3
block|}
block|,
block|{
literal|"xor"
block|,
literal|3
block|,
literal|2
block|,
literal|1
block|,
literal|1
block|,
name|A
operator||
literal|2
block|,
name|NA
block|,
literal|1
block|}
block|,
block|{
literal|"xor"
block|,
literal|4
block|,
literal|2
block|,
literal|1
block|,
literal|3
block|,
name|A
operator||
literal|2
block|,
name|NA
block|,
literal|1
block|}
block|,
block|{
literal|"nop"
block|,
literal|1
block|,
literal|1
block|,
name|I
operator||
name|R_NONE
block|,
name|I
operator||
name|R_ALLZEROS
block|,
name|I
operator||
literal|0xff
block|,
name|NA
block|,
literal|1
block|}
block|,
block|{
literal|"inc"
block|,
literal|2
block|,
literal|3
block|,
literal|1
block|,
literal|1
block|,
name|I
operator||
literal|1
block|,
name|NA
block|,
literal|1
block|}
block|,
block|{
literal|"inc"
block|,
literal|3
block|,
literal|3
block|,
literal|1
block|,
literal|2
block|,
name|I
operator||
literal|1
block|,
name|NA
block|,
literal|1
block|}
block|,
block|{
literal|"dec"
block|,
literal|2
block|,
literal|3
block|,
literal|1
block|,
literal|1
block|,
name|I
operator||
literal|0xff
block|,
name|NA
block|,
literal|1
block|}
block|,
block|{
literal|"dec"
block|,
literal|3
block|,
literal|3
block|,
literal|1
block|,
literal|2
block|,
name|I
operator||
literal|0xff
block|,
name|NA
block|,
literal|1
block|}
block|,
block|{
literal|"jmp"
block|,
literal|2
block|,
name|LO
operator||
literal|0
block|,
name|NA
block|,
name|I
operator||
name|R_SINDEX
block|,
name|I
operator||
literal|0
block|,
literal|1
block|,
literal|3
block|}
block|,
block|{
literal|"jc"
block|,
literal|2
block|,
name|LO
operator||
literal|0
block|,
name|NA
block|,
name|I
operator||
name|R_SINDEX
block|,
name|I
operator||
literal|0
block|,
literal|1
block|,
literal|3
block|}
block|,
block|{
literal|"jnc"
block|,
literal|2
block|,
name|LO
operator||
literal|0
block|,
name|NA
block|,
name|I
operator||
name|R_SINDEX
block|,
name|I
operator||
literal|0
block|,
literal|1
block|,
literal|3
block|}
block|,
block|{
literal|"call"
block|,
literal|2
block|,
name|LO
operator||
literal|0
block|,
name|NA
block|,
name|I
operator||
name|R_SINDEX
block|,
name|I
operator||
literal|0
block|,
literal|1
block|,
literal|3
block|}
block|,
block|{
literal|"test"
block|,
literal|5
block|,
name|LA
operator||
literal|3
block|,
name|NA
block|,
literal|1
block|,
name|A
operator||
literal|2
block|,
literal|4
block|,
literal|3
block|}
block|,
block|{
literal|"cmp"
block|,
literal|5
block|,
name|LX
operator||
literal|3
block|,
name|NA
block|,
literal|1
block|,
name|A
operator||
literal|2
block|,
literal|4
block|,
literal|3
block|}
block|,
block|{
literal|"ret"
block|,
literal|1
block|,
literal|1
block|,
name|I
operator||
name|R_NONE
block|,
name|I
operator||
name|R_ALLZEROS
block|,
name|I
operator||
literal|0xff
block|,
name|NA
block|,
literal|1
block|}
block|,
block|{
literal|"ret"
block|,
literal|1
block|,
literal|1
block|,
name|I
operator||
name|R_NONE
block|,
name|I
operator||
name|R_ALLZEROS
block|,
name|I
operator||
literal|0xff
block|,
name|NA
block|,
literal|1
block|}
block|,
block|{
literal|"clc"
block|,
literal|1
block|,
literal|3
block|,
name|I
operator||
name|R_NONE
block|,
name|I
operator||
name|R_ALLZEROS
block|,
name|I
operator||
literal|1
block|,
name|NA
block|,
literal|1
block|}
block|,
block|{
literal|"clc"
block|,
literal|4
block|,
literal|3
block|,
literal|2
block|,
name|I
operator||
name|R_ALLZEROS
block|,
name|A
operator||
literal|3
block|,
name|NA
block|,
literal|1
block|}
block|,
block|{
literal|"stc"
block|,
literal|2
block|,
literal|3
block|,
literal|1
block|,
name|I
operator||
name|R_ALLONES
block|,
name|I
operator||
literal|1
block|,
name|NA
block|,
literal|1
block|}
block|,
block|{
literal|"add"
block|,
literal|3
block|,
literal|3
block|,
literal|1
block|,
literal|1
block|,
name|A
operator||
literal|2
block|,
name|NA
block|,
literal|1
block|}
block|,
block|{
literal|"add"
block|,
literal|4
block|,
literal|3
block|,
literal|1
block|,
literal|3
block|,
name|A
operator||
literal|2
block|,
name|NA
block|,
literal|1
block|}
block|,
block|{
literal|"adc"
block|,
literal|3
block|,
literal|4
block|,
literal|1
block|,
literal|1
block|,
name|A
operator||
literal|2
block|,
name|NA
block|,
literal|1
block|}
block|,
block|{
literal|"adc"
block|,
literal|4
block|,
literal|4
block|,
literal|1
block|,
literal|3
block|,
name|A
operator||
literal|2
block|,
name|NA
block|,
literal|1
block|}
block|,
block|{
literal|"shl"
block|,
literal|3
block|,
literal|5
block|,
literal|1
block|,
literal|1
block|,
name|SL
operator||
literal|2
block|,
name|NA
block|,
literal|2
block|}
block|,
block|{
literal|"shl"
block|,
literal|4
block|,
literal|5
block|,
literal|1
block|,
literal|2
block|,
name|SL
operator||
literal|3
block|,
name|NA
block|,
literal|2
block|}
block|,
block|{
literal|"shr"
block|,
literal|3
block|,
literal|5
block|,
literal|1
block|,
literal|1
block|,
name|SR
operator||
literal|2
block|,
name|NA
block|,
literal|2
block|}
block|,
block|{
literal|"shr"
block|,
literal|4
block|,
literal|5
block|,
literal|1
block|,
literal|2
block|,
name|SR
operator||
literal|3
block|,
name|NA
block|,
literal|2
block|}
block|,
block|{
literal|"rol"
block|,
literal|3
block|,
literal|5
block|,
literal|1
block|,
literal|1
block|,
name|RL
operator||
literal|2
block|,
name|NA
block|,
literal|2
block|}
block|,
block|{
literal|"rol"
block|,
literal|4
block|,
literal|5
block|,
literal|1
block|,
literal|2
block|,
name|RL
operator||
literal|3
block|,
name|NA
block|,
literal|2
block|}
block|,
block|{
literal|"ror"
block|,
literal|3
block|,
literal|5
block|,
literal|1
block|,
literal|1
block|,
name|RR
operator||
literal|2
block|,
name|NA
block|,
literal|2
block|}
block|,
block|{
literal|"ror"
block|,
literal|4
block|,
literal|5
block|,
literal|1
block|,
literal|2
block|,
name|RR
operator||
literal|3
block|,
name|NA
block|,
literal|2
block|}
block|,
comment|/* 	 *  Extensions (note also that mvi allows A) 	 */
block|{
literal|"clr"
block|,
literal|2
block|,
literal|1
block|,
literal|1
block|,
name|I
operator||
name|R_ALLZEROS
block|,
name|I
operator||
literal|0xff
block|,
name|NA
block|,
literal|1
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
struct|;
end_struct

begin_function
name|int
name|eval_operand
parameter_list|(
name|char
modifier|*
modifier|*
name|a
parameter_list|,
name|int
name|spec
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|unsigned
name|int
name|want
init|=
name|spec
operator|&
operator|(
name|LO
operator||
name|LA
operator||
name|LX
operator|)
decl_stmt|;
specifier|static
struct|struct
block|{
name|unsigned
name|int
name|what
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|value
decl_stmt|;
block|}
name|jmptab
index|[]
init|=
block|{
block|{
name|LO
block|,
literal|"jmp"
block|,
literal|8
block|}
block|,
block|{
name|LO
block|,
literal|"jc"
block|,
literal|9
block|}
block|,
block|{
name|LO
block|,
literal|"jnc"
block|,
literal|10
block|}
block|,
block|{
name|LO
block|,
literal|"call"
block|,
literal|11
block|}
block|,
block|{
name|LA
block|,
literal|"jz"
block|,
literal|15
block|}
block|,
block|{
name|LA
block|,
literal|"jnz"
block|,
literal|13
block|}
block|,
block|{
name|LX
block|,
literal|"je"
block|,
literal|14
block|}
block|,
block|{
name|LX
block|,
literal|"jne"
block|,
literal|12
block|}
block|, 	}
struct|;
name|spec
operator|&=
operator|~
operator|(
name|LO
operator||
name|LA
operator||
name|LX
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|jmptab
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|jmptab
index|[
literal|0
index|]
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|jmptab
index|[
name|i
index|]
operator|.
name|what
operator|==
name|want
operator|&&
operator|!
name|strcmp
argument_list|(
name|jmptab
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|a
index|[
name|spec
index|]
argument_list|)
condition|)
block|{
return|return
operator|(
name|jmptab
index|[
name|i
index|]
operator|.
name|value
operator|)
return|;
block|}
if|if
condition|(
name|want
condition|)
name|error
argument_list|(
literal|"invalid jump"
argument_list|)
expr_stmt|;
return|return
operator|(
name|spec
operator|)
return|;
comment|/* "case 0" - no flags set */
block|}
end_function

begin_function
name|int
name|eval_sdi
parameter_list|(
name|char
modifier|*
modifier|*
name|a
parameter_list|,
name|int
name|spec
parameter_list|)
block|{
name|sym_t
modifier|*
name|p
decl_stmt|;
name|unsigned
name|val
decl_stmt|;
if|if
condition|(
name|spec
operator|==
name|NA
condition|)
return|return
operator|(
name|NA
operator|)
return|;
switch|switch
condition|(
name|spec
operator|&
operator|(
name|A
operator||
name|I
operator||
name|SL
operator||
name|SR
operator||
name|RL
operator||
name|RR
operator|)
condition|)
block|{
case|case
name|SL
case|:
case|case
name|SR
case|:
case|case
name|RL
case|:
case|case
name|RR
case|:
if|if
condition|(
name|isdigit
argument_list|(
operator|*
name|a
index|[
name|spec
operator|&
operator|~
operator|(
name|SL
operator||
name|SR
operator||
name|RL
operator||
name|RR
operator|)
index|]
argument_list|)
condition|)
name|val
operator|=
name|strtol
argument_list|(
name|a
index|[
name|spec
operator|&
operator|~
operator|(
name|SL
operator||
name|SR
operator||
name|RL
operator||
name|RR
operator|)
index|]
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
block|{
name|p
operator|=
name|lookup
argument_list|(
name|a
index|[
name|spec
operator|&
operator|~
operator|(
name|SL
operator||
name|SR
operator||
name|RL
operator||
name|RR
operator|)
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p
condition|)
name|error
argument_list|(
literal|"undefined symbol used"
argument_list|)
expr_stmt|;
name|val
operator|=
name|p
operator|->
name|value
expr_stmt|;
block|}
switch|switch
condition|(
name|spec
operator|&
operator|(
name|SL
operator||
name|SR
operator||
name|RL
operator||
name|RR
operator|)
condition|)
block|{
comment|/* blech */
case|case
name|SL
case|:
if|if
condition|(
name|val
operator|>
literal|7
condition|)
return|return
operator|(
literal|0xf0
operator|)
return|;
return|return
operator|(
operator|(
operator|(
name|val
operator|%
literal|8
operator|)
operator|<<
literal|4
operator|)
operator||
operator|(
name|val
operator|%
literal|8
operator|)
operator|)
return|;
case|case
name|SR
case|:
if|if
condition|(
name|val
operator|>
literal|7
condition|)
return|return
operator|(
literal|0xf0
operator|)
return|;
return|return
operator|(
operator|(
operator|(
name|val
operator|%
literal|8
operator|)
operator|<<
literal|4
operator|)
operator||
operator|(
literal|1
operator|<<
literal|3
operator|)
operator||
operator|(
operator|(
literal|8
operator|-
operator|(
name|val
operator|%
literal|8
operator|)
operator|)
operator|%
literal|8
operator|)
operator|)
return|;
case|case
name|RL
case|:
return|return
operator|(
name|val
operator|%
literal|8
operator|)
return|;
case|case
name|RR
case|:
return|return
operator|(
operator|(
literal|8
operator|-
operator|(
name|val
operator|%
literal|8
operator|)
operator|)
operator|%
literal|8
operator|)
return|;
block|}
case|case
name|I
case|:
return|return
operator|(
name|spec
operator|&
operator|~
name|I
operator|)
return|;
case|case
name|A
case|:
comment|/* 		 *  An immediate field of zero selects 		 *  the accumulator.  Vigorously object 		 *  if zero is given otherwise - it's 		 *  most likely an error. 		 */
name|spec
operator|&=
operator|~
name|A
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
literal|"A"
argument_list|,
name|a
index|[
name|spec
index|]
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|isdigit
argument_list|(
operator|*
name|a
index|[
name|spec
index|]
argument_list|)
operator|&&
name|strtol
argument_list|(
name|a
index|[
name|spec
index|]
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"immediate value of zero selects accumulator"
argument_list|)
expr_stmt|;
block|}
comment|/* falls through */
case|case
literal|0
case|:
if|if
condition|(
name|isdigit
argument_list|(
operator|*
name|a
index|[
name|spec
index|]
argument_list|)
condition|)
return|return
operator|(
name|strtol
argument_list|(
name|a
index|[
name|spec
index|]
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
operator|)
return|;
name|p
operator|=
name|lookup
argument_list|(
name|a
index|[
name|spec
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
condition|)
return|return
operator|(
name|p
operator|->
name|value
operator|)
return|;
name|error
argument_list|(
literal|"undefined symbol used"
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|NA
operator|)
return|;
comment|/* shut the compiler up */
block|}
end_function

begin_function
name|int
name|eval_addr
parameter_list|(
name|char
modifier|*
modifier|*
name|a
parameter_list|,
name|int
name|spec
parameter_list|)
block|{
name|sym_t
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|spec
operator|==
name|NA
condition|)
return|return
operator|(
name|NA
operator|)
return|;
if|if
condition|(
name|isdigit
argument_list|(
operator|*
name|a
index|[
name|spec
index|]
argument_list|)
condition|)
return|return
operator|(
name|strtol
argument_list|(
name|a
index|[
name|spec
index|]
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
operator|)
return|;
name|p
operator|=
name|lookup
argument_list|(
name|a
index|[
name|spec
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|value
operator|!=
name|NOVALUE
condition|)
return|return
operator|(
name|p
operator|->
name|value
operator|)
return|;
name|patch
argument_list|(
name|p
argument_list|,
name|LC
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|define
argument_list|(
name|a
index|[
name|spec
index|]
argument_list|,
name|NOVALUE
argument_list|)
expr_stmt|;
name|p
operator|=
name|lookup
argument_list|(
name|a
index|[
name|spec
index|]
argument_list|)
expr_stmt|;
name|patch
argument_list|(
name|p
argument_list|,
name|LC
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|NA
operator|)
return|;
comment|/* will be patched in later */
block|}
end_function

begin_function
name|int
name|crack
parameter_list|(
name|char
modifier|*
modifier|*
name|a
parameter_list|,
name|int
name|n
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|I_imm
decl_stmt|,
name|I_addr
decl_stmt|;
name|int
name|I_op
decl_stmt|,
name|I_dest
decl_stmt|,
name|I_src
decl_stmt|,
name|I_ret
decl_stmt|;
comment|/* 	 *  Check for "ret" at the end of the line; remove 	 *  it unless it's "ret" alone - we still want to 	 *  look it up in the table. 	 */
name|I_ret
operator|=
operator|(
name|strcmp
argument_list|(
name|a
index|[
name|n
operator|-
literal|1
index|]
argument_list|,
literal|"ret"
argument_list|)
condition|?
literal|0
else|:
operator|!
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|I_ret
operator|&&
name|n
operator|>
literal|1
condition|)
name|n
operator|-=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|instr
index|[
name|i
index|]
operator|.
name|name
condition|;
name|i
operator|++
control|)
block|{
comment|/* 		 *  Look for match in table given constraints, 		 *  currently just the name and the number of 		 *  operands. 		 */
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|instr
index|[
name|i
index|]
operator|.
name|name
argument_list|,
operator|*
name|a
argument_list|)
operator|&&
name|instr
index|[
name|i
index|]
operator|.
name|n
operator|==
name|n
condition|)
break|break;
block|}
if|if
condition|(
operator|!
name|instr
index|[
name|i
index|]
operator|.
name|name
condition|)
name|error
argument_list|(
literal|"unknown opcode or wrong number of operands"
argument_list|)
expr_stmt|;
name|I_op
operator|=
name|eval_operand
argument_list|(
name|a
argument_list|,
name|instr
index|[
name|i
index|]
operator|.
name|op
argument_list|)
expr_stmt|;
name|I_src
operator|=
name|eval_sdi
argument_list|(
name|a
argument_list|,
name|instr
index|[
name|i
index|]
operator|.
name|src
argument_list|)
expr_stmt|;
name|I_imm
operator|=
name|eval_sdi
argument_list|(
name|a
argument_list|,
name|instr
index|[
name|i
index|]
operator|.
name|imm
argument_list|)
expr_stmt|;
name|I_dest
operator|=
name|eval_sdi
argument_list|(
name|a
argument_list|,
name|instr
index|[
name|i
index|]
operator|.
name|dest
argument_list|)
expr_stmt|;
name|I_addr
operator|=
name|eval_addr
argument_list|(
name|a
argument_list|,
name|instr
index|[
name|i
index|]
operator|.
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|LC
operator|>=
name|MEMORY
condition|)
name|error
argument_list|(
literal|"Memory exhausted!\n"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|instr
index|[
name|i
index|]
operator|.
name|fmt
condition|)
block|{
case|case
literal|1
case|:
case|case
literal|2
case|:
name|M
index|[
name|LC
index|]
index|[
literal|0
index|]
operator|=
operator|(
name|I_op
operator|<<
literal|1
operator|)
operator||
name|I_ret
expr_stmt|;
name|M
index|[
name|LC
index|]
index|[
literal|1
index|]
operator|=
name|I_dest
expr_stmt|;
name|M
index|[
name|LC
index|]
index|[
literal|2
index|]
operator|=
name|I_src
expr_stmt|;
name|M
index|[
name|LC
index|]
index|[
literal|3
index|]
operator|=
name|I_imm
expr_stmt|;
break|break;
case|case
literal|3
case|:
if|if
condition|(
name|I_ret
condition|)
name|error
argument_list|(
literal|"illegal use of \"ret\""
argument_list|)
expr_stmt|;
name|M
index|[
name|LC
index|]
index|[
literal|0
index|]
operator|=
operator|(
name|I_op
operator|<<
literal|1
operator|)
operator||
operator|(
operator|(
name|I_addr
operator|>>
literal|8
operator|)
operator|&
literal|1
operator|)
expr_stmt|;
name|M
index|[
name|LC
index|]
index|[
literal|1
index|]
operator|=
name|I_addr
operator|&
literal|0xff
expr_stmt|;
name|M
index|[
name|LC
index|]
index|[
literal|2
index|]
operator|=
name|I_src
expr_stmt|;
name|M
index|[
name|LC
index|]
index|[
literal|3
index|]
operator|=
name|I_imm
expr_stmt|;
break|break;
block|}
return|return
operator|(
literal|1
operator|)
return|;
comment|/* no two-byte instructions yet */
block|}
end_function

begin_undef
undef|#
directive|undef
name|SL
end_undef

begin_undef
undef|#
directive|undef
name|SR
end_undef

begin_undef
undef|#
directive|undef
name|RL
end_undef

begin_undef
undef|#
directive|undef
name|RR
end_undef

begin_undef
undef|#
directive|undef
name|LX
end_undef

begin_undef
undef|#
directive|undef
name|LA
end_undef

begin_undef
undef|#
directive|undef
name|LO
end_undef

begin_undef
undef|#
directive|undef
name|I
end_undef

begin_undef
undef|#
directive|undef
name|A
end_undef

begin_function
name|void
name|assemble
parameter_list|(
name|FILE
modifier|*
name|ofile
parameter_list|)
block|{
name|int
name|n
decl_stmt|;
name|char
modifier|*
modifier|*
name|a
decl_stmt|;
name|sym_t
modifier|*
name|p
decl_stmt|;
while|while
condition|(
operator|(
name|a
operator|=
name|getl
argument_list|(
operator|&
name|n
argument_list|)
operator|)
condition|)
block|{
while|while
condition|(
name|a
index|[
literal|0
index|]
index|[
name|strlen
argument_list|(
operator|*
name|a
argument_list|)
operator|-
literal|1
index|]
operator|==
literal|':'
condition|)
block|{
name|a
index|[
literal|0
index|]
index|[
name|strlen
argument_list|(
operator|*
name|a
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|p
operator|=
name|lookup
argument_list|(
operator|*
name|a
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
condition|)
name|p
operator|->
name|value
operator|=
name|LC
expr_stmt|;
else|else
name|define
argument_list|(
operator|*
name|a
argument_list|,
name|LC
argument_list|)
expr_stmt|;
name|a
operator|+=
literal|1
expr_stmt|;
name|n
operator|-=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|n
condition|)
comment|/* line was all labels */
continue|continue;
if|if
condition|(
name|n
operator|==
literal|3
operator|&&
operator|!
name|strcmp
argument_list|(
literal|"VERSION"
argument_list|,
operator|*
name|a
argument_list|)
condition|)
name|fprintf
argument_list|(
name|ofile
argument_list|,
literal|"#define %s \"%s\"\n"
argument_list|,
name|a
index|[
literal|1
index|]
argument_list|,
name|a
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|n
operator|==
literal|3
operator|&&
operator|!
name|strcmp
argument_list|(
literal|"="
argument_list|,
name|a
index|[
literal|1
index|]
argument_list|)
condition|)
name|define
argument_list|(
operator|*
name|a
argument_list|,
name|strtol
argument_list|(
name|a
index|[
literal|2
index|]
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|LC
operator|+=
name|crack
argument_list|(
name|a
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
block|}
name|backpatch
argument_list|()
expr_stmt|;
name|output
argument_list|(
name|ofile
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
condition|)
name|output
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
name|int
name|pid
decl_stmt|;
name|int
name|ifile
decl_stmt|;
name|FILE
modifier|*
name|ofile
decl_stmt|;
name|int
name|fd
index|[
literal|2
index|]
decl_stmt|;
name|ofile
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"dho:vD:"
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'d'
case|:
name|debug
operator|=
operator|!
literal|0
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
block|{
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|strchr
argument_list|(
name|optarg
argument_list|,
literal|'='
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
name|define
argument_list|(
name|optarg
argument_list|,
name|strtol
argument_list|(
name|p
operator|+
literal|1
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|define
argument_list|(
name|optarg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
literal|'o'
case|:
if|if
condition|(
operator|(
name|ofile
operator|=
name|fopen
argument_list|(
name|optarg
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|perror
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'h'
case|:
name|printf
argument_list|(
literal|"usage: %s [-d] [-Dname] [-ooutput] input\n"
argument_list|,
operator|*
name|argv
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_SUCCESS
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|id
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_SUCCESS
argument_list|)
expr_stmt|;
break|break;
default|default:
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|argc
operator|-
name|optind
operator|!=
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: must have one input file\n"
argument_list|,
operator|*
name|argv
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
name|filename
operator|=
name|argv
index|[
name|optind
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|ifile
operator|=
name|open
argument_list|(
name|filename
argument_list|,
name|O_RDONLY
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|ofile
condition|)
block|{
if|if
condition|(
operator|(
name|ofile
operator|=
name|fopen
argument_list|(
name|ADOTOUT
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|perror
argument_list|(
name|ADOTOUT
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|pipe
argument_list|(
name|fd
argument_list|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"pipe failed"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|pid
operator|=
name|fork
argument_list|()
operator|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"fork failed"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pid
operator|>
literal|0
condition|)
block|{
comment|/* Parent */
name|close
argument_list|(
name|fd
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
comment|/* Close write end */
if|if
condition|(
name|fd
index|[
literal|0
index|]
operator|!=
name|STDIN_FILENO
condition|)
block|{
if|if
condition|(
name|dup2
argument_list|(
name|fd
index|[
literal|0
index|]
argument_list|,
name|STDIN_FILENO
argument_list|)
operator|!=
name|STDIN_FILENO
condition|)
block|{
name|perror
argument_list|(
literal|"dup2 error on stdin"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
name|close
argument_list|(
name|fd
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
name|assemble
argument_list|(
name|ofile
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_SUCCESS
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Child */
name|close
argument_list|(
name|fd
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|/* Close Read end */
if|if
condition|(
name|fd
index|[
literal|1
index|]
operator|!=
name|STDOUT_FILENO
condition|)
block|{
if|if
condition|(
name|dup2
argument_list|(
name|fd
index|[
literal|1
index|]
argument_list|,
name|STDOUT_FILENO
argument_list|)
operator|!=
name|STDOUT_FILENO
condition|)
block|{
name|perror
argument_list|(
literal|"dup2 error on stdout"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
name|close
argument_list|(
name|fd
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ifile
operator|!=
name|STDIN_FILENO
condition|)
block|{
if|if
condition|(
name|dup2
argument_list|(
name|ifile
argument_list|,
name|STDIN_FILENO
argument_list|)
operator|!=
name|STDIN_FILENO
condition|)
block|{
name|perror
argument_list|(
literal|"dup2 error on stdin"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
name|close
argument_list|(
name|ifile
argument_list|)
expr_stmt|;
block|}
name|execl
argument_list|(
literal|"/usr/bin/cpp"
argument_list|,
literal|"/usr/bin/cpp"
argument_list|,
literal|"-P"
argument_list|,
literal|"-"
argument_list|,
literal|"-"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|EXIT_SUCCESS
operator|)
return|;
block|}
end_function

end_unit

