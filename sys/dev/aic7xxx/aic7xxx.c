begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Generic driver for the aic7xxx based adaptec SCSI controllers  * Product specific probe and attach routines can be found in:  * i386/eisa/ahc_eisa.c	27/284X and aic7770 motherboard controllers  * pci/ahc_pci.c	3985, 3980, 3940, 2940, aic7895, aic7890,  *			aic7880, aic7870, aic7860, and aic7850 controllers  *  * Copyright (c) 1994, 1995, 1996, 1997, 1998 Justin T. Gibbs.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions, and the following disclaimer,  *    without modification, immediately at the beginning of the file.  * 2. The name of the author may not be used to endorse or promote products  *    derived from this software without specific prior written permission.  *  * Where this Software is combined with software released under the terms of   * the GNU Public License ("GPL") and the terms of the GPL would require the   * combined work to also be released under the terms of the GPL, the terms  * and conditions of this License will apply in addition to those of the  * GPL with the exception of any terms or conditions of this License that  * conflict with, or are expressly prohibited by, the GPL.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE FOR  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *      $Id: aic7xxx.c,v 1.7 1998/10/09 17:41:39 gibbs Exp $  */
end_comment

begin_comment
comment|/*  * A few notes on features of the driver.  *  * SCB paging takes advantage of the fact that devices stay disconnected  * from the bus a relatively long time and that while they're disconnected,  * having the SCBs for these transactions down on the host adapter is of  * little use.  Instead of leaving this idle SCB down on the card we copy  * it back up into kernel memory and reuse the SCB slot on the card to  * schedule another transaction.  This can be a real payoff when doing random  * I/O to tagged queueing devices since there are more transactions active at  * once for the device to sort for optimal seek reduction. The algorithm goes  * like this...  *  * The sequencer maintains two lists of its hardware SCBs.  The first is the  * singly linked free list which tracks all SCBs that are not currently in  * use.  The second is the doubly linked disconnected list which holds the  * SCBs of transactions that are in the disconnected state sorted most  * recently disconnected first.  When the kernel queues a transaction to  * the card, a hardware SCB to "house" this transaction is retrieved from  * either of these two lists.  If the SCB came from the disconnected list,  * a check is made to see if any data transfer or SCB linking (more on linking  * in a bit) information has been changed since it was copied from the host  * and if so, DMAs the SCB back up before it can be used.  Once a hardware  * SCB has been obtained, the SCB is DMAed from the host.  Before any work  * can begin on this SCB, the sequencer must ensure that either the SCB is  * for a tagged transaction or the target is not already working on another  * non-tagged transaction.  If a conflict arises in the non-tagged case, the  * sequencer finds the SCB for the active transactions and sets the SCB_LINKED  * field in that SCB to this next SCB to execute.  To facilitate finding  * active non-tagged SCBs, the last four bytes of up to the first four hardware  * SCBs serve as a storage area for the currently active SCB ID for each  * target.  *  * When a device reconnects, a search is made of the hardware SCBs to find  * the SCB for this transaction.  If the search fails, a hardware SCB is  * pulled from either the free or disconnected SCB list and the proper  * SCB is DMAed from the host.  If the MK_MESSAGE control bit is set  * in the control byte of the SCB while it was disconnected, the sequencer  * will assert ATN and attempt to issue a message to the host.  *  * When a command completes, a check for non-zero status and residuals is  * made.  If either of these conditions exists, the SCB is DMAed back up to  * the host so that it can interpret this information.  Additionally, in the  * case of bad status, the sequencer generates a special interrupt and pauses  * itself.  This allows the host to setup a request sense command if it   * chooses for this target synchronously with the error so that sense  * information isn't lost.  *  */
end_comment

begin_include
include|#
directive|include
file|<opt_aic7xxx.h>
end_include

begin_include
include|#
directive|include
file|<pci.h>
end_include

begin_include
include|#
directive|include
file|<stddef.h>
end_include

begin_comment
comment|/* For offsetof */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/buf.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_ccb.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_sim.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_xpt_sim.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_debug.h>
end_include

begin_include
include|#
directive|include
file|<cam/scsi/scsi_all.h>
end_include

begin_include
include|#
directive|include
file|<cam/scsi/scsi_message.h>
end_include

begin_if
if|#
directive|if
name|NPCI
operator|>
literal|0
end_if

begin_include
include|#
directive|include
file|<machine/bus_memio.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<machine/bus_pio.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/clock.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_param.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<dev/aic7xxx/aic7xxx.h>
end_include

begin_include
include|#
directive|include
file|<dev/aic7xxx/sequencer.h>
end_include

begin_include
include|#
directive|include
file|<aic7xxx_reg.h>
end_include

begin_include
include|#
directive|include
file|<aic7xxx_seq.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|AHC_TMODE_ENABLE
end_ifndef

begin_define
define|#
directive|define
name|AHC_TMODE_ENABLE
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|MAX
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|(((a)> (b)) ? (a) : (b))
end_define

begin_define
define|#
directive|define
name|MIN
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|(((a)< (b)) ? (a) : (b))
end_define

begin_define
define|#
directive|define
name|ALL_TARGETS
value|(~0)
end_define

begin_define
define|#
directive|define
name|ALL_LUNS
value|(~0)
end_define

begin_define
define|#
directive|define
name|ALL_CHANNELS
value|'\0'
end_define

begin_define
define|#
directive|define
name|SIM_IS_SCSIBUS_B
parameter_list|(
name|ahc
parameter_list|,
name|sim
parameter_list|)
define|\
value|(sim == ahc->sim_b)
end_define

begin_define
define|#
directive|define
name|SCB_IS_SCSIBUS_B
parameter_list|(
name|scb
parameter_list|)
define|\
value|(((scb)->hscb->tcl& SELBUSB) != 0)
end_define

begin_define
define|#
directive|define
name|SCB_TARGET
parameter_list|(
name|scb
parameter_list|)
define|\
value|(((scb)->hscb->tcl& TID)>> 4)
end_define

begin_define
define|#
directive|define
name|SCB_CHANNEL
parameter_list|(
name|scb
parameter_list|)
define|\
value|(SCB_IS_SCSIBUS_B(scb) ? 'B' : 'A')
end_define

begin_define
define|#
directive|define
name|SCB_LUN
parameter_list|(
name|scb
parameter_list|)
define|\
value|((scb)->hscb->tcl& LID)
end_define

begin_define
define|#
directive|define
name|SCB_TARGET_OFFSET
parameter_list|(
name|scb
parameter_list|)
define|\
value|(SCB_TARGET(scb) + (SCB_IS_SCSIBUS_B(scb) ? 8 : 0))
end_define

begin_define
define|#
directive|define
name|SCB_TARGET_MASK
parameter_list|(
name|scb
parameter_list|)
define|\
value|(0x01<< (SCB_TARGET_OFFSET(scb)))
end_define

begin_define
define|#
directive|define
name|ccb_scb_ptr
value|spriv_ptr0
end_define

begin_define
define|#
directive|define
name|ccb_ahc_ptr
value|spriv_ptr1
end_define

begin_struct
struct|struct
name|ahc_devinfo
block|{
name|int
name|target_offset
decl_stmt|;
name|u_int16_t
name|target_mask
decl_stmt|;
name|u_int8_t
name|target
decl_stmt|;
name|char
name|channel
decl_stmt|;
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
enum|enum
block|{
name|SEARCH_COMPLETE
block|,
name|SEARCH_COUNT
block|,
name|SEARCH_REMOVE
block|}
name|ahc_search_action
typedef|;
end_typedef

begin_decl_stmt
name|u_long
name|ahc_unit
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|AHC_DEBUG
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|ahc_debug
init|=
name|AHC_DEBUG
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|NPCI
operator|>
literal|0
end_if

begin_function_decl
name|void
name|ahc_pci_intr
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|ahc_dump_targcmd
parameter_list|(
name|struct
name|target_cmd
modifier|*
name|cmd
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ahc_shutdown
parameter_list|(
name|int
name|howto
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ahcminphys
parameter_list|(
name|struct
name|buf
modifier|*
name|bp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|cam_status
name|ahc_find_tmode_devs
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|struct
name|cam_sim
modifier|*
name|sim
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|,
name|struct
name|tmode_tstate
modifier|*
modifier|*
name|tstate
parameter_list|,
name|struct
name|tmode_lstate
modifier|*
modifier|*
name|lstate
parameter_list|,
name|int
name|notfound_failure
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ahc_action
parameter_list|(
name|struct
name|cam_sim
modifier|*
name|sim
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ahc_async
parameter_list|(
name|void
modifier|*
name|callback_arg
parameter_list|,
name|u_int32_t
name|code
parameter_list|,
name|struct
name|cam_path
modifier|*
name|path
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ahc_execute_scb
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|dm_segs
parameter_list|,
name|int
name|nsegments
parameter_list|,
name|int
name|error
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ahc_poll
parameter_list|(
name|struct
name|cam_sim
modifier|*
name|sim
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ahc_setup_data
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|struct
name|ccb_scsiio
modifier|*
name|csio
parameter_list|,
name|struct
name|scb
modifier|*
name|scb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ahc_freeze_devq
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|struct
name|cam_path
modifier|*
name|path
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|scb
modifier|*
name|ahc_get_scb
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ahc_free_scb
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|struct
name|scb
modifier|*
name|scb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|scb
modifier|*
name|ahc_alloc_scb
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ahc_fetch_devinfo
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|struct
name|ahc_devinfo
modifier|*
name|devinfo
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ahc_compile_devinfo
parameter_list|(
name|struct
name|ahc_devinfo
modifier|*
name|devinfo
parameter_list|,
name|u_int
name|target
parameter_list|,
name|char
name|channel
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u_int
name|ahc_abort_wscb
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|u_int
name|scbpos
parameter_list|,
name|u_int
name|prev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ahc_done
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|struct
name|scb
modifier|*
name|scbp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ahc_handle_target_cmd
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ahc_handle_seqint
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|u_int
name|intstat
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ahc_handle_scsiint
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|u_int
name|intstat
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ahc_handle_reqinit
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|struct
name|scb
modifier|*
name|scb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ahc_parse_msg
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|struct
name|scb
modifier|*
name|scb
parameter_list|,
name|struct
name|ahc_devinfo
modifier|*
name|devinfo
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ahc_handle_devreset
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|int
name|target
parameter_list|,
name|char
name|channel
parameter_list|,
name|cam_status
name|status
parameter_list|,
name|ac_code
name|acode
parameter_list|,
name|char
modifier|*
name|message
parameter_list|,
name|int
name|verbose_only
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ahc_loadseq
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ahc_check_patch
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|struct
name|patch
modifier|*
modifier|*
name|start_patch
parameter_list|,
name|int
name|start_instr
parameter_list|,
name|int
modifier|*
name|skip_addr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ahc_download_instr
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|int
name|instrptr
parameter_list|,
name|u_int8_t
modifier|*
name|dconsts
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ahc_match_scb
parameter_list|(
name|struct
name|scb
modifier|*
name|scb
parameter_list|,
name|int
name|target
parameter_list|,
name|char
name|channel
parameter_list|,
name|int
name|lun
parameter_list|,
name|u_int
name|tag
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|AHC_DEBUG
end_ifdef

begin_function_decl
specifier|static
name|void
name|ahc_print_scb
parameter_list|(
name|struct
name|scb
modifier|*
name|scb
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|int
name|ahc_search_qinfifo
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|int
name|target
parameter_list|,
name|char
name|channel
parameter_list|,
name|int
name|lun
parameter_list|,
name|u_int
name|tag
parameter_list|,
name|u_int32_t
name|status
parameter_list|,
name|ahc_search_action
name|action
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ahc_reset_channel
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|char
name|channel
parameter_list|,
name|int
name|initiate_reset
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ahc_abort_scbs
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|int
name|target
parameter_list|,
name|char
name|channel
parameter_list|,
name|int
name|lun
parameter_list|,
name|u_int
name|tag
parameter_list|,
name|u_int32_t
name|status
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ahc_search_disc_list
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|int
name|target
parameter_list|,
name|char
name|channel
parameter_list|,
name|int
name|lun
parameter_list|,
name|u_int
name|tag
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u_int
name|ahc_rem_scb_from_disc_list
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|u_int
name|prev
parameter_list|,
name|u_int
name|scbptr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ahc_add_curscb_to_free_list
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ahc_clear_intstat
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ahc_reset_current_bus
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|ahc_syncrate
modifier|*
name|ahc_find_syncrate
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|u_int
modifier|*
name|period
parameter_list|,
name|u_int
name|maxsync
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u_int
name|ahc_find_period
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|u_int
name|scsirate
parameter_list|,
name|u_int
name|maxsync
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ahc_validate_offset
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|struct
name|ahc_syncrate
modifier|*
name|syncrate
parameter_list|,
name|u_int
modifier|*
name|offset
parameter_list|,
name|int
name|wide
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ahc_set_syncrate
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|struct
name|ahc_devinfo
modifier|*
name|devinfo
parameter_list|,
name|struct
name|cam_path
modifier|*
name|path
parameter_list|,
name|struct
name|ahc_syncrate
modifier|*
name|syncrate
parameter_list|,
name|u_int
name|period
parameter_list|,
name|u_int
name|offset
parameter_list|,
name|u_int
name|type
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ahc_set_width
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|struct
name|ahc_devinfo
modifier|*
name|devinfo
parameter_list|,
name|struct
name|cam_path
modifier|*
name|path
parameter_list|,
name|u_int
name|width
parameter_list|,
name|u_int
name|type
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ahc_construct_sdtr
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|u_int
name|period
parameter_list|,
name|u_int
name|offset
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ahc_construct_wdtr
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|u_int
name|bus_width
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ahc_calc_residual
parameter_list|(
name|struct
name|scb
modifier|*
name|scb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ahc_update_pending_syncrates
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ahc_set_recoveryscb
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|struct
name|scb
modifier|*
name|scb
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|timeout_t
name|ahc_timeout
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|__inline
name|void
name|pause_sequencer
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__inline
name|void
name|unpause_sequencer
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|int
name|unpause_always
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__inline
name|void
name|restart_sequencer
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__inline
name|u_int
name|ahc_index_busy_tcl
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|u_int
name|tcl
parameter_list|,
name|int
name|unbusy
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__inline
name|void
name|ahc_busy_tcl
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|struct
name|scb
modifier|*
name|scb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__inline
name|void
name|ahc_freeze_ccb
parameter_list|(
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__inline
name|cam_status
name|ahc_ccb_status
parameter_list|(
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__inline
name|void
name|ahc_set_ccb_status
parameter_list|(
name|union
name|ccb
modifier|*
name|ccb
parameter_list|,
name|cam_status
name|status
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|__inline
name|u_int32_t
name|ahc_hscb_busaddr
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|u_int
name|index
parameter_list|)
block|{
return|return
operator|(
name|ahc
operator|->
name|hscb_busaddr
operator|+
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|hardware_scb
argument_list|)
operator|*
name|index
operator|)
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|AHC_BUSRESET_DELAY
value|25
end_define

begin_comment
comment|/* Reset delay in us */
end_comment

begin_function
specifier|static
name|__inline
name|void
name|pause_sequencer
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|)
block|{
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|HCNTRL
argument_list|,
name|ahc
operator|->
name|pause
argument_list|)
expr_stmt|;
comment|/* 	 * Since the sequencer can disable pausing in a critical section, we 	 * must loop until it actually stops. 	 */
while|while
condition|(
operator|(
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|HCNTRL
argument_list|)
operator|&
name|PAUSE
operator|)
operator|==
literal|0
condition|)
empty_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|unpause_sequencer
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|int
name|unpause_always
parameter_list|)
block|{
if|if
condition|(
operator|(
name|ahc
operator|->
name|flags
operator|&
name|AHC_HANDLING_REQINITS
operator|)
operator|==
literal|0
operator|&&
operator|(
name|unpause_always
operator|||
operator|(
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|INTSTAT
argument_list|)
operator|&
operator|(
name|SCSIINT
operator||
name|SEQINT
operator||
name|BRKADRINT
operator|)
operator|)
operator|==
literal|0
operator|)
condition|)
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|HCNTRL
argument_list|,
name|ahc
operator|->
name|unpause
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Restart the sequencer program from address zero  */
end_comment

begin_function
specifier|static
name|__inline
name|void
name|restart_sequencer
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|)
block|{
name|pause_sequencer
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SEQCTL
argument_list|,
name|FASTMODE
operator||
name|SEQRESET
argument_list|)
expr_stmt|;
name|unpause_sequencer
argument_list|(
name|ahc
argument_list|,
comment|/*unpause_always*/
name|TRUE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|u_int
name|ahc_index_busy_tcl
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|u_int
name|tcl
parameter_list|,
name|int
name|unbusy
parameter_list|)
block|{
name|u_int
name|scbid
decl_stmt|;
name|scbid
operator|=
name|ahc
operator|->
name|untagged_scbs
index|[
name|tcl
index|]
expr_stmt|;
if|if
condition|(
name|unbusy
condition|)
name|ahc
operator|->
name|untagged_scbs
index|[
name|tcl
index|]
operator|=
name|SCB_LIST_NULL
expr_stmt|;
return|return
operator|(
name|scbid
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|ahc_busy_tcl
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|struct
name|scb
modifier|*
name|scb
parameter_list|)
block|{
name|ahc
operator|->
name|untagged_scbs
index|[
name|scb
operator|->
name|hscb
operator|->
name|tcl
index|]
operator|=
name|scb
operator|->
name|hscb
operator|->
name|tag
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|ahc_freeze_ccb
parameter_list|(
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
block|{
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_DEV_QFRZN
operator|)
operator|==
literal|0
condition|)
block|{
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_DEV_QFRZN
expr_stmt|;
name|xpt_freeze_devq
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
comment|/*count*/
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|__inline
name|cam_status
name|ahc_ccb_status
parameter_list|(
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
block|{
return|return
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|ahc_set_ccb_status
parameter_list|(
name|union
name|ccb
modifier|*
name|ccb
parameter_list|,
name|cam_status
name|status
parameter_list|)
block|{
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&=
operator|~
name|CAM_STATUS_MASK
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|status
expr_stmt|;
block|}
end_function

begin_function
name|char
modifier|*
name|ahc_name
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|)
block|{
specifier|static
name|char
name|name
index|[
literal|10
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|name
argument_list|,
literal|"ahc%d"
argument_list|,
name|ahc
operator|->
name|unit
argument_list|)
expr_stmt|;
return|return
operator|(
name|name
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|AHC_DEBUG
end_ifdef

begin_function
specifier|static
name|void
name|ahc_print_scb
parameter_list|(
name|struct
name|scb
modifier|*
name|scb
parameter_list|)
block|{
name|struct
name|hardware_scb
modifier|*
name|hscb
init|=
name|scb
operator|->
name|hscb
decl_stmt|;
name|printf
argument_list|(
literal|"scb:%p control:0x%x tcl:0x%x cmdlen:%d cmdpointer:0x%lx\n"
argument_list|,
name|scb
argument_list|,
name|hscb
operator|->
name|control
argument_list|,
name|hscb
operator|->
name|tcl
argument_list|,
name|hscb
operator|->
name|cmdlen
argument_list|,
name|hscb
operator|->
name|cmdpointer
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"        datlen:%d data:0x%lx segs:0x%x segp:0x%lx\n"
argument_list|,
name|hscb
operator|->
name|datalen
argument_list|,
name|hscb
operator|->
name|data
argument_list|,
name|hscb
operator|->
name|SG_count
argument_list|,
name|hscb
operator|->
name|SG_pointer
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"	sg_addr:%lx sg_len:%ld\n"
argument_list|,
name|scb
operator|->
name|ahc_dma
index|[
literal|0
index|]
operator|.
name|addr
argument_list|,
name|scb
operator|->
name|ahc_dma
index|[
literal|0
index|]
operator|.
name|len
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"	cdb:%x %x %x %x %x %x %x %x %x %x %x %x\n"
argument_list|,
name|hscb
operator|->
name|cmdstore
index|[
literal|0
index|]
argument_list|,
name|hscb
operator|->
name|cmdstore
index|[
literal|1
index|]
argument_list|,
name|hscb
operator|->
name|cmdstore
index|[
literal|2
index|]
argument_list|,
name|hscb
operator|->
name|cmdstore
index|[
literal|3
index|]
argument_list|,
name|hscb
operator|->
name|cmdstore
index|[
literal|4
index|]
argument_list|,
name|hscb
operator|->
name|cmdstore
index|[
literal|5
index|]
argument_list|,
name|hscb
operator|->
name|cmdstore
index|[
literal|6
index|]
argument_list|,
name|hscb
operator|->
name|cmdstore
index|[
literal|7
index|]
argument_list|,
name|hscb
operator|->
name|cmdstore
index|[
literal|8
index|]
argument_list|,
name|hscb
operator|->
name|cmdstore
index|[
literal|9
index|]
argument_list|,
name|hscb
operator|->
name|cmdstore
index|[
literal|10
index|]
argument_list|,
name|hscb
operator|->
name|cmdstore
index|[
literal|11
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_struct
specifier|static
struct|struct
block|{
name|u_int8_t
name|errno
decl_stmt|;
name|char
modifier|*
name|errmesg
decl_stmt|;
block|}
name|hard_error
index|[]
init|=
block|{
block|{
name|ILLHADDR
block|,
literal|"Illegal Host Access"
block|}
block|,
block|{
name|ILLSADDR
block|,
literal|"Illegal Sequencer Address referrenced"
block|}
block|,
block|{
name|ILLOPCODE
block|,
literal|"Illegal Opcode in sequencer program"
block|}
block|,
block|{
name|SQPARERR
block|,
literal|"Sequencer Parity Error"
block|}
block|,
block|{
name|DPARERR
block|,
literal|"Data-path Parity Error"
block|}
block|,
block|{
name|MPARERR
block|,
literal|"Scratch or SCB Memory Parity Error"
block|}
block|,
block|{
name|PCIERRSTAT
block|,
literal|"PCI Error detected"
block|}
block|,
block|{
name|CIOPARERR
block|,
literal|"CIOBUS Parity Error"
block|}
block|, }
struct|;
end_struct

begin_comment
comment|/*  * Valid SCSIRATE values.  (p. 3-17)  * Provides a mapping of tranfer periods in ns to the proper value to  * stick in the scsiscfr reg to use that transfer rate.  */
end_comment

begin_define
define|#
directive|define
name|AHC_SYNCRATE_ULTRA2
value|0
end_define

begin_define
define|#
directive|define
name|AHC_SYNCRATE_ULTRA
value|2
end_define

begin_define
define|#
directive|define
name|AHC_SYNCRATE_FAST
value|5
end_define

begin_decl_stmt
specifier|static
name|struct
name|ahc_syncrate
name|ahc_syncrates
index|[]
init|=
block|{
comment|/* ultra2  fast/ultra  period	rate */
block|{
literal|0x13
block|,
literal|0x000
block|,
literal|10
block|,
literal|"40.0"
block|}
block|,
block|{
literal|0x14
block|,
literal|0x000
block|,
literal|11
block|,
literal|"33.0"
block|}
block|,
block|{
literal|0x15
block|,
literal|0x100
block|,
literal|12
block|,
literal|"20.0"
block|}
block|,
block|{
literal|0x16
block|,
literal|0x110
block|,
literal|15
block|,
literal|"16.0"
block|}
block|,
block|{
literal|0x17
block|,
literal|0x120
block|,
literal|18
block|,
literal|"13.4"
block|}
block|,
block|{
literal|0x18
block|,
literal|0x000
block|,
literal|25
block|,
literal|"10.0"
block|}
block|,
block|{
literal|0x19
block|,
literal|0x010
block|,
literal|31
block|,
literal|"8.0"
block|}
block|,
block|{
literal|0x1a
block|,
literal|0x020
block|,
literal|37
block|,
literal|"6.67"
block|}
block|,
block|{
literal|0x1b
block|,
literal|0x030
block|,
literal|43
block|,
literal|"5.7"
block|}
block|,
block|{
literal|0x10
block|,
literal|0x040
block|,
literal|50
block|,
literal|"5.0"
block|}
block|,
block|{
literal|0x00
block|,
literal|0x050
block|,
literal|56
block|,
literal|"4.4"
block|}
block|,
block|{
literal|0x00
block|,
literal|0x060
block|,
literal|62
block|,
literal|"4.0"
block|}
block|,
block|{
literal|0x00
block|,
literal|0x070
block|,
literal|68
block|,
literal|"3.6"
block|}
block|,
block|{
literal|0x00
block|,
literal|0x000
block|,
literal|0
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Allocate a controller structure for a new device and initialize it.  */
end_comment

begin_function
name|struct
name|ahc_softc
modifier|*
name|ahc_alloc
parameter_list|(
name|int
name|unit
parameter_list|,
name|u_int32_t
name|iobase
parameter_list|,
name|vm_offset_t
name|maddr
parameter_list|,
name|ahc_chip
name|chip
parameter_list|,
name|ahc_feature
name|features
parameter_list|,
name|ahc_flag
name|flags
parameter_list|,
name|struct
name|scb_data
modifier|*
name|scb_data
parameter_list|)
block|{
comment|/* 	 * find unit and check we have that many defined 	 */
name|struct
name|ahc_softc
modifier|*
name|ahc
decl_stmt|;
name|size_t
name|alloc_size
decl_stmt|;
comment|/* 	 * Allocate a storage area for us 	 */
if|if
condition|(
name|scb_data
operator|==
name|NULL
condition|)
comment|/* 		 * We are not sharing SCB space with another controller 		 * so allocate our own SCB data space. 		 */
name|alloc_size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|full_ahc_softc
argument_list|)
expr_stmt|;
else|else
name|alloc_size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ahc_softc
argument_list|)
expr_stmt|;
name|ahc
operator|=
name|malloc
argument_list|(
name|alloc_size
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ahc
condition|)
block|{
name|printf
argument_list|(
literal|"ahc%d: cannot malloc!\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|bzero
argument_list|(
name|ahc
argument_list|,
name|alloc_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|scb_data
operator|==
name|NULL
condition|)
block|{
name|struct
name|full_ahc_softc
modifier|*
name|full_softc
init|=
operator|(
expr|struct
name|full_ahc_softc
operator|*
operator|)
name|ahc
decl_stmt|;
name|ahc
operator|->
name|scb_data
operator|=
operator|&
name|full_softc
operator|->
name|scb_data_storage
expr_stmt|;
name|STAILQ_INIT
argument_list|(
operator|&
name|ahc
operator|->
name|scb_data
operator|->
name|free_scbs
argument_list|)
expr_stmt|;
block|}
else|else
name|ahc
operator|->
name|scb_data
operator|=
name|scb_data
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|ahc
operator|->
name|pending_ccbs
argument_list|)
expr_stmt|;
name|ahc
operator|->
name|unit
operator|=
name|unit
expr_stmt|;
comment|/* 	 * XXX This should be done by the bus specific probe stubs with 	 *     the bus layer providing the bsh and tag.  Unfortunately, 	 *     we need to clean up how we configure things before this 	 *     can happen. 	 */
if|if
condition|(
name|maddr
operator|!=
name|NULL
condition|)
block|{
name|ahc
operator|->
name|tag
operator|=
name|I386_BUS_SPACE_MEM
expr_stmt|;
name|ahc
operator|->
name|bsh
operator|=
operator|(
name|bus_space_handle_t
operator|)
name|maddr
expr_stmt|;
block|}
else|else
block|{
name|ahc
operator|->
name|tag
operator|=
name|I386_BUS_SPACE_IO
expr_stmt|;
name|ahc
operator|->
name|bsh
operator|=
operator|(
name|bus_space_handle_t
operator|)
name|iobase
expr_stmt|;
block|}
name|ahc
operator|->
name|chip
operator|=
name|chip
expr_stmt|;
name|ahc
operator|->
name|features
operator|=
name|features
expr_stmt|;
name|ahc
operator|->
name|flags
operator|=
name|flags
expr_stmt|;
name|ahc
operator|->
name|unpause
operator|=
operator|(
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|HCNTRL
argument_list|)
operator|&
name|IRQMS
operator|)
operator||
name|INTEN
expr_stmt|;
name|ahc
operator|->
name|pause
operator|=
name|ahc
operator|->
name|unpause
operator||
name|PAUSE
expr_stmt|;
return|return
operator|(
name|ahc
operator|)
return|;
block|}
end_function

begin_function
name|void
name|ahc_free
parameter_list|(
name|ahc
parameter_list|)
name|struct
name|ahc_softc
modifier|*
name|ahc
decl_stmt|;
block|{
name|free
argument_list|(
name|ahc
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|int
name|ahc_reset
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|)
block|{
name|u_int
name|sblkctl
decl_stmt|;
name|int
name|wait
decl_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|HCNTRL
argument_list|,
name|CHIPRST
operator||
name|ahc
operator|->
name|pause
argument_list|)
expr_stmt|;
comment|/* 	 * Ensure that the reset has finished 	 */
name|wait
operator|=
literal|1000
expr_stmt|;
while|while
condition|(
operator|--
name|wait
operator|&&
operator|!
operator|(
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|HCNTRL
argument_list|)
operator|&
name|CHIPRSTACK
operator|)
condition|)
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
if|if
condition|(
name|wait
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%s: WARNING - Failed chip reset!  "
literal|"Trying to initialize anyway.\n"
argument_list|,
name|ahc_name
argument_list|(
name|ahc
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|HCNTRL
argument_list|,
name|ahc
operator|->
name|pause
argument_list|)
expr_stmt|;
comment|/* Determine channel configuration */
name|sblkctl
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SBLKCTL
argument_list|)
operator|&
operator|(
name|SELBUSB
operator||
name|SELWIDE
operator|)
expr_stmt|;
comment|/* No Twin Channel PCI cards */
if|if
condition|(
operator|(
name|ahc
operator|->
name|chip
operator|&
name|AHC_PCI
operator|)
operator|!=
literal|0
condition|)
name|sblkctl
operator|&=
operator|~
name|SELBUSB
expr_stmt|;
switch|switch
condition|(
name|sblkctl
condition|)
block|{
case|case
literal|0
case|:
comment|/* Single Narrow Channel */
break|break;
case|case
literal|2
case|:
comment|/* Wide Channel */
name|ahc
operator|->
name|features
operator||=
name|AHC_WIDE
expr_stmt|;
break|break;
case|case
literal|8
case|:
comment|/* Twin Channel */
name|ahc
operator|->
name|features
operator||=
name|AHC_TWIN
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|" Unsupported adapter type.  Ignoring\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Look up the valid period to SCSIRATE conversion in our table.  * Return the period and offset that should be sent to the target  * if this was the beginning of an SDTR.  */
end_comment

begin_function
specifier|static
name|struct
name|ahc_syncrate
modifier|*
name|ahc_find_syncrate
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|u_int
modifier|*
name|period
parameter_list|,
name|u_int
name|maxsync
parameter_list|)
block|{
name|struct
name|ahc_syncrate
modifier|*
name|syncrate
decl_stmt|;
name|syncrate
operator|=
operator|&
name|ahc_syncrates
index|[
name|maxsync
index|]
expr_stmt|;
while|while
condition|(
operator|(
name|syncrate
operator|->
name|rate
operator|!=
name|NULL
operator|)
operator|&&
operator|(
operator|(
name|ahc
operator|->
name|features
operator|&
name|AHC_ULTRA2
operator|)
operator|==
literal|0
operator|||
operator|(
name|syncrate
operator|->
name|sxfr_ultra2
operator|!=
literal|0
operator|)
operator|)
condition|)
block|{
if|if
condition|(
operator|*
name|period
operator|<=
name|syncrate
operator|->
name|period
condition|)
block|{
comment|/* 			 * When responding to a target that requests 			 * sync, the requested rate may fall between 			 * two rates that we can output, but still be 			 * a rate that we can receive.  Because of this, 			 * we want to respond to the target with 			 * the same rate that it sent to us even 			 * if the period we use to send data to it 			 * is lower.  Only lower the response period 			 * if we must. 			 */
if|if
condition|(
name|syncrate
operator|==
operator|&
name|ahc_syncrates
index|[
name|maxsync
index|]
condition|)
block|{
operator|*
name|period
operator|=
name|syncrate
operator|->
name|period
expr_stmt|;
block|}
break|break;
block|}
name|syncrate
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|*
name|period
operator|==
literal|0
operator|)
operator|||
operator|(
name|syncrate
operator|->
name|rate
operator|==
name|NULL
operator|)
operator|||
operator|(
operator|(
name|ahc
operator|->
name|features
operator|&
name|AHC_ULTRA2
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|syncrate
operator|->
name|sxfr_ultra2
operator|==
literal|0
operator|)
operator|)
condition|)
block|{
comment|/* Use asynchronous transfers. */
operator|*
name|period
operator|=
literal|0
expr_stmt|;
name|syncrate
operator|=
name|NULL
expr_stmt|;
block|}
return|return
operator|(
name|syncrate
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|u_int
name|ahc_find_period
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|u_int
name|scsirate
parameter_list|,
name|u_int
name|maxsync
parameter_list|)
block|{
name|struct
name|ahc_syncrate
modifier|*
name|syncrate
decl_stmt|;
if|if
condition|(
operator|(
name|ahc
operator|->
name|features
operator|&
name|AHC_ULTRA2
operator|)
operator|!=
literal|0
condition|)
block|{
name|scsirate
operator|&=
name|SXFR_ULTRA2
expr_stmt|;
block|}
else|else
block|{
name|scsirate
operator|&=
name|SXFR
expr_stmt|;
block|}
name|syncrate
operator|=
operator|&
name|ahc_syncrates
index|[
name|maxsync
index|]
expr_stmt|;
while|while
condition|(
name|syncrate
operator|->
name|rate
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|ahc
operator|->
name|features
operator|&
name|AHC_ULTRA2
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|syncrate
operator|->
name|sxfr_ultra2
operator|==
literal|0
condition|)
break|break;
elseif|else
if|if
condition|(
name|scsirate
operator|==
name|syncrate
operator|->
name|sxfr_ultra2
condition|)
return|return
operator|(
name|syncrate
operator|->
name|period
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|scsirate
operator|==
operator|(
name|syncrate
operator|->
name|sxfr
operator|&
operator|~
name|ULTRA_SXFR
operator|)
condition|)
block|{
return|return
operator|(
name|syncrate
operator|->
name|period
operator|)
return|;
block|}
name|syncrate
operator|++
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
comment|/* async */
block|}
end_function

begin_function
specifier|static
name|void
name|ahc_validate_offset
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|struct
name|ahc_syncrate
modifier|*
name|syncrate
parameter_list|,
name|u_int
modifier|*
name|offset
parameter_list|,
name|int
name|wide
parameter_list|)
block|{
name|u_int
name|maxoffset
decl_stmt|;
comment|/* Limit offset to what we can do */
if|if
condition|(
name|syncrate
operator|==
name|NULL
condition|)
block|{
name|maxoffset
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|ahc
operator|->
name|features
operator|&
name|AHC_ULTRA2
operator|)
operator|!=
literal|0
condition|)
block|{
name|maxoffset
operator|=
name|MAX_OFFSET_ULTRA2
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|wide
condition|)
name|maxoffset
operator|=
name|MAX_OFFSET_16BIT
expr_stmt|;
else|else
name|maxoffset
operator|=
name|MAX_OFFSET_8BIT
expr_stmt|;
block|}
operator|*
name|offset
operator|=
name|MIN
argument_list|(
operator|*
name|offset
argument_list|,
name|maxoffset
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ahc_set_syncrate
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|struct
name|ahc_devinfo
modifier|*
name|devinfo
parameter_list|,
name|struct
name|cam_path
modifier|*
name|path
parameter_list|,
name|struct
name|ahc_syncrate
modifier|*
name|syncrate
parameter_list|,
name|u_int
name|period
parameter_list|,
name|u_int
name|offset
parameter_list|,
name|u_int
name|type
parameter_list|)
block|{
name|u_int
name|old_period
decl_stmt|;
name|u_int
name|old_offset
decl_stmt|;
if|if
condition|(
name|syncrate
operator|==
name|NULL
condition|)
block|{
name|period
operator|=
literal|0
expr_stmt|;
name|offset
operator|=
literal|0
expr_stmt|;
block|}
name|old_period
operator|=
name|ahc
operator|->
name|transinfo
index|[
name|devinfo
operator|->
name|target_offset
index|]
operator|.
name|current
operator|.
name|period
expr_stmt|;
name|old_offset
operator|=
name|ahc
operator|->
name|transinfo
index|[
name|devinfo
operator|->
name|target_offset
index|]
operator|.
name|current
operator|.
name|offset
expr_stmt|;
if|if
condition|(
operator|(
name|type
operator|&
name|AHC_TRANS_CUR
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|old_period
operator|!=
name|period
operator|||
name|old_offset
operator|!=
name|offset
operator|)
condition|)
block|{
name|struct
name|ccb_trans_settings
name|neg
decl_stmt|;
name|u_int
name|scsirate
decl_stmt|;
name|scsirate
operator|=
name|ahc
operator|->
name|transinfo
index|[
name|devinfo
operator|->
name|target_offset
index|]
operator|.
name|scsirate
expr_stmt|;
if|if
condition|(
operator|(
name|ahc
operator|->
name|features
operator|&
name|AHC_ULTRA2
operator|)
operator|!=
literal|0
condition|)
block|{
name|scsirate
operator|&=
operator|~
name|SXFR_ULTRA2
expr_stmt|;
if|if
condition|(
name|syncrate
operator|!=
name|NULL
condition|)
block|{
name|scsirate
operator||=
name|syncrate
operator|->
name|sxfr_ultra2
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|type
operator|&
name|AHC_TRANS_ACTIVE
operator|)
operator|==
name|AHC_TRANS_ACTIVE
condition|)
block|{
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCSIOFFSET
argument_list|,
name|offset
argument_list|)
expr_stmt|;
block|}
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|TARG_OFFSET
operator|+
name|devinfo
operator|->
name|target_offset
argument_list|,
name|offset
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|scsirate
operator|&=
operator|~
operator|(
name|SXFR
operator||
name|SOFS
operator|)
expr_stmt|;
comment|/* 			 * Ensure Ultra mode is set properly for 			 * this target. 			 */
name|ahc
operator|->
name|ultraenb
operator|&=
operator|~
name|devinfo
operator|->
name|target_mask
expr_stmt|;
if|if
condition|(
name|syncrate
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|syncrate
operator|->
name|sxfr
operator|&
name|ULTRA_SXFR
condition|)
block|{
name|ahc
operator|->
name|ultraenb
operator||=
name|devinfo
operator|->
name|target_mask
expr_stmt|;
block|}
name|scsirate
operator||=
name|syncrate
operator|->
name|sxfr
operator|&
name|SXFR
expr_stmt|;
name|scsirate
operator||=
name|offset
operator|&
name|SOFS
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|type
operator|&
name|AHC_TRANS_ACTIVE
operator|)
operator|==
name|AHC_TRANS_ACTIVE
condition|)
block|{
name|u_int
name|sxfrctl0
decl_stmt|;
name|sxfrctl0
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SXFRCTL0
argument_list|)
expr_stmt|;
name|sxfrctl0
operator|&=
operator|~
name|FAST20
expr_stmt|;
if|if
condition|(
name|ahc
operator|->
name|ultraenb
operator|&
name|devinfo
operator|->
name|target_mask
condition|)
name|sxfrctl0
operator||=
name|FAST20
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SXFRCTL0
argument_list|,
name|sxfrctl0
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|type
operator|&
name|AHC_TRANS_ACTIVE
operator|)
operator|==
name|AHC_TRANS_ACTIVE
condition|)
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCSIRATE
argument_list|,
name|scsirate
argument_list|)
expr_stmt|;
name|ahc
operator|->
name|transinfo
index|[
name|devinfo
operator|->
name|target_offset
index|]
operator|.
name|scsirate
operator|=
name|scsirate
expr_stmt|;
name|ahc
operator|->
name|transinfo
index|[
name|devinfo
operator|->
name|target_offset
index|]
operator|.
name|current
operator|.
name|period
operator|=
name|period
expr_stmt|;
name|ahc
operator|->
name|transinfo
index|[
name|devinfo
operator|->
name|target_offset
index|]
operator|.
name|current
operator|.
name|offset
operator|=
name|offset
expr_stmt|;
comment|/* Update the syncrates in any pending scbs */
name|ahc_update_pending_syncrates
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
comment|/* 		 * Tell the SCSI layer about the 		 * new transfer parameters. 		 */
name|neg
operator|.
name|sync_period
operator|=
name|period
expr_stmt|;
name|neg
operator|.
name|sync_offset
operator|=
name|offset
expr_stmt|;
name|neg
operator|.
name|valid
operator|=
name|CCB_TRANS_SYNC_RATE_VALID
operator||
name|CCB_TRANS_SYNC_OFFSET_VALID
expr_stmt|;
name|xpt_setup_ccb
argument_list|(
operator|&
name|neg
operator|.
name|ccb_h
argument_list|,
name|path
argument_list|,
comment|/*priority*/
literal|1
argument_list|)
expr_stmt|;
name|xpt_async
argument_list|(
name|AC_TRANSFER_NEG
argument_list|,
name|path
argument_list|,
operator|&
name|neg
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
block|{
if|if
condition|(
name|neg
operator|.
name|sync_offset
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%s: target %d synchronous at %sMHz, "
literal|"offset = 0x%x\n"
argument_list|,
name|ahc_name
argument_list|(
name|ahc
argument_list|)
argument_list|,
name|devinfo
operator|->
name|target
argument_list|,
name|syncrate
operator|->
name|rate
argument_list|,
name|offset
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"%s: target %d using "
literal|"asynchronous transfers\n"
argument_list|,
name|ahc_name
argument_list|(
name|ahc
argument_list|)
argument_list|,
name|devinfo
operator|->
name|target
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|(
name|type
operator|&
name|AHC_TRANS_GOAL
operator|)
operator|!=
literal|0
condition|)
block|{
name|ahc
operator|->
name|transinfo
index|[
name|devinfo
operator|->
name|target_offset
index|]
operator|.
name|goal
operator|.
name|period
operator|=
name|period
expr_stmt|;
name|ahc
operator|->
name|transinfo
index|[
name|devinfo
operator|->
name|target_offset
index|]
operator|.
name|goal
operator|.
name|offset
operator|=
name|offset
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|type
operator|&
name|AHC_TRANS_USER
operator|)
operator|!=
literal|0
condition|)
block|{
name|ahc
operator|->
name|transinfo
index|[
name|devinfo
operator|->
name|target_offset
index|]
operator|.
name|user
operator|.
name|period
operator|=
name|period
expr_stmt|;
name|ahc
operator|->
name|transinfo
index|[
name|devinfo
operator|->
name|target_offset
index|]
operator|.
name|user
operator|.
name|offset
operator|=
name|offset
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ahc_set_width
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|struct
name|ahc_devinfo
modifier|*
name|devinfo
parameter_list|,
name|struct
name|cam_path
modifier|*
name|path
parameter_list|,
name|u_int
name|width
parameter_list|,
name|u_int
name|type
parameter_list|)
block|{
name|u_int
name|oldwidth
decl_stmt|;
name|oldwidth
operator|=
name|ahc
operator|->
name|transinfo
index|[
name|devinfo
operator|->
name|target_offset
index|]
operator|.
name|current
operator|.
name|width
expr_stmt|;
if|if
condition|(
operator|(
name|type
operator|&
name|AHC_TRANS_CUR
operator|)
operator|!=
literal|0
operator|&&
name|oldwidth
operator|!=
name|width
condition|)
block|{
name|struct
name|ccb_trans_settings
name|neg
decl_stmt|;
name|u_int
name|scsirate
decl_stmt|;
name|scsirate
operator|=
name|ahc
operator|->
name|transinfo
index|[
name|devinfo
operator|->
name|target_offset
index|]
operator|.
name|scsirate
expr_stmt|;
name|scsirate
operator|&=
operator|~
name|WIDEXFER
expr_stmt|;
if|if
condition|(
name|width
operator|==
name|MSG_EXT_WDTR_BUS_16_BIT
condition|)
name|scsirate
operator||=
name|WIDEXFER
expr_stmt|;
name|ahc
operator|->
name|transinfo
index|[
name|devinfo
operator|->
name|target_offset
index|]
operator|.
name|scsirate
operator|=
name|scsirate
expr_stmt|;
if|if
condition|(
operator|(
name|type
operator|&
name|AHC_TRANS_ACTIVE
operator|)
operator|==
name|AHC_TRANS_ACTIVE
condition|)
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCSIRATE
argument_list|,
name|scsirate
argument_list|)
expr_stmt|;
name|ahc
operator|->
name|transinfo
index|[
name|devinfo
operator|->
name|target_offset
index|]
operator|.
name|current
operator|.
name|width
operator|=
name|width
expr_stmt|;
comment|/* Tell the SCSI layer about the new transfer params */
name|neg
operator|.
name|bus_width
operator|=
name|width
expr_stmt|;
name|neg
operator|.
name|valid
operator|=
name|CCB_TRANS_BUS_WIDTH_VALID
expr_stmt|;
name|xpt_setup_ccb
argument_list|(
operator|&
name|neg
operator|.
name|ccb_h
argument_list|,
name|path
argument_list|,
comment|/*priority*/
literal|1
argument_list|)
expr_stmt|;
name|xpt_async
argument_list|(
name|AC_TRANSFER_NEG
argument_list|,
name|path
argument_list|,
operator|&
name|neg
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
block|{
name|printf
argument_list|(
literal|"%s: target %d using %dbit transfers\n"
argument_list|,
name|ahc_name
argument_list|(
name|ahc
argument_list|)
argument_list|,
name|devinfo
operator|->
name|target
argument_list|,
literal|8
operator|*
operator|(
literal|0x01
operator|<<
name|neg
operator|.
name|bus_width
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|type
operator|&
name|AHC_TRANS_GOAL
operator|)
operator|!=
literal|0
condition|)
block|{
name|ahc
operator|->
name|transinfo
index|[
name|devinfo
operator|->
name|target_offset
index|]
operator|.
name|goal
operator|.
name|width
operator|=
name|width
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|type
operator|&
name|AHC_TRANS_USER
operator|)
operator|!=
literal|0
condition|)
block|{
name|ahc
operator|->
name|transinfo
index|[
name|devinfo
operator|->
name|target_offset
index|]
operator|.
name|user
operator|.
name|width
operator|=
name|width
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Attach all the sub-devices we can find  */
end_comment

begin_function
name|int
name|ahc_attach
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|)
block|{
name|struct
name|ccb_setasync
name|csa
decl_stmt|;
name|struct
name|cam_devq
modifier|*
name|devq
decl_stmt|;
name|int
name|bus_id
decl_stmt|;
name|int
name|bus_id2
decl_stmt|;
name|struct
name|cam_sim
modifier|*
name|sim
decl_stmt|;
name|struct
name|cam_sim
modifier|*
name|sim2
decl_stmt|;
name|struct
name|cam_path
modifier|*
name|path
decl_stmt|;
name|struct
name|cam_path
modifier|*
name|path2
decl_stmt|;
name|int
name|count
decl_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
name|sim
operator|=
name|NULL
expr_stmt|;
name|sim2
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * Attach secondary channel first if the user has 	 * declared it the primary channel. 	 */
if|if
condition|(
operator|(
name|ahc
operator|->
name|flags
operator|&
name|AHC_CHANNEL_B_PRIMARY
operator|)
operator|!=
literal|0
condition|)
block|{
name|bus_id
operator|=
literal|1
expr_stmt|;
name|bus_id2
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|bus_id
operator|=
literal|0
expr_stmt|;
name|bus_id2
operator|=
literal|1
expr_stmt|;
block|}
comment|/* 	 * Create the device queue for our SIM(s). 	 */
name|devq
operator|=
name|cam_simq_alloc
argument_list|(
name|ahc
operator|->
name|scb_data
operator|->
name|maxscbs
argument_list|)
expr_stmt|;
if|if
condition|(
name|devq
operator|==
name|NULL
condition|)
goto|goto
name|fail
goto|;
comment|/* 	 * Construct our first channel SIM entry 	 */
name|sim
operator|=
name|cam_sim_alloc
argument_list|(
name|ahc_action
argument_list|,
name|ahc_poll
argument_list|,
literal|"ahc"
argument_list|,
name|ahc
argument_list|,
name|ahc
operator|->
name|unit
argument_list|,
literal|1
argument_list|,
name|ahc
operator|->
name|scb_data
operator|->
name|maxscbs
argument_list|,
name|devq
argument_list|)
expr_stmt|;
if|if
condition|(
name|sim
operator|==
name|NULL
condition|)
block|{
name|cam_simq_free
argument_list|(
name|devq
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
if|if
condition|(
name|xpt_bus_register
argument_list|(
name|sim
argument_list|,
name|bus_id
argument_list|)
operator|!=
name|CAM_SUCCESS
condition|)
block|{
name|cam_sim_free
argument_list|(
name|sim
argument_list|,
comment|/*free_devq*/
name|TRUE
argument_list|)
expr_stmt|;
name|sim
operator|=
name|NULL
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
if|if
condition|(
name|xpt_create_path
argument_list|(
operator|&
name|path
argument_list|,
comment|/*periph*/
name|NULL
argument_list|,
name|cam_sim_path
argument_list|(
name|sim
argument_list|)
argument_list|,
name|CAM_TARGET_WILDCARD
argument_list|,
name|CAM_LUN_WILDCARD
argument_list|)
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|xpt_bus_deregister
argument_list|(
name|cam_sim_path
argument_list|(
name|sim
argument_list|)
argument_list|)
expr_stmt|;
name|cam_sim_free
argument_list|(
name|sim
argument_list|,
comment|/*free_devq*/
name|TRUE
argument_list|)
expr_stmt|;
name|sim
operator|=
name|NULL
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|xpt_setup_ccb
argument_list|(
operator|&
name|csa
operator|.
name|ccb_h
argument_list|,
name|path
argument_list|,
comment|/*priority*/
literal|5
argument_list|)
expr_stmt|;
name|csa
operator|.
name|ccb_h
operator|.
name|func_code
operator|=
name|XPT_SASYNC_CB
expr_stmt|;
name|csa
operator|.
name|event_enable
operator|=
name|AC_LOST_DEVICE
expr_stmt|;
name|csa
operator|.
name|callback
operator|=
name|ahc_async
expr_stmt|;
name|csa
operator|.
name|callback_arg
operator|=
name|sim
expr_stmt|;
name|xpt_action
argument_list|(
operator|(
expr|union
name|ccb
operator|*
operator|)
operator|&
name|csa
argument_list|)
expr_stmt|;
name|count
operator|++
expr_stmt|;
if|if
condition|(
name|ahc
operator|->
name|features
operator|&
name|AHC_TWIN
condition|)
block|{
name|sim2
operator|=
name|cam_sim_alloc
argument_list|(
name|ahc_action
argument_list|,
name|ahc_poll
argument_list|,
literal|"ahc"
argument_list|,
name|ahc
argument_list|,
name|ahc
operator|->
name|unit
argument_list|,
literal|1
argument_list|,
name|ahc
operator|->
name|scb_data
operator|->
name|maxscbs
argument_list|,
name|devq
argument_list|)
expr_stmt|;
if|if
condition|(
name|sim2
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"ahc_attach: Unable to attach second "
literal|"bus due to resource shortage"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
if|if
condition|(
name|xpt_bus_register
argument_list|(
name|sim2
argument_list|,
name|bus_id2
argument_list|)
operator|!=
name|CAM_SUCCESS
condition|)
block|{
name|printf
argument_list|(
literal|"ahc_attach: Unable to attach second "
literal|"bus due to resource shortage"
argument_list|)
expr_stmt|;
comment|/* 			 * We do not want to destroy the device queue 			 * because the first bus is using it. 			 */
name|cam_sim_free
argument_list|(
name|sim2
argument_list|,
comment|/*free_devq*/
name|FALSE
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
if|if
condition|(
name|xpt_create_path
argument_list|(
operator|&
name|path2
argument_list|,
comment|/*periph*/
name|NULL
argument_list|,
name|cam_sim_path
argument_list|(
name|sim2
argument_list|)
argument_list|,
name|CAM_TARGET_WILDCARD
argument_list|,
name|CAM_LUN_WILDCARD
argument_list|)
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|xpt_bus_deregister
argument_list|(
name|cam_sim_path
argument_list|(
name|sim2
argument_list|)
argument_list|)
expr_stmt|;
name|cam_sim_free
argument_list|(
name|sim2
argument_list|,
comment|/*free_devq*/
name|FALSE
argument_list|)
expr_stmt|;
name|sim2
operator|=
name|NULL
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|xpt_setup_ccb
argument_list|(
operator|&
name|csa
operator|.
name|ccb_h
argument_list|,
name|path2
argument_list|,
comment|/*priority*/
literal|5
argument_list|)
expr_stmt|;
name|csa
operator|.
name|ccb_h
operator|.
name|func_code
operator|=
name|XPT_SASYNC_CB
expr_stmt|;
name|csa
operator|.
name|event_enable
operator|=
name|AC_LOST_DEVICE
expr_stmt|;
name|csa
operator|.
name|callback
operator|=
name|ahc_async
expr_stmt|;
name|csa
operator|.
name|callback_arg
operator|=
name|sim2
expr_stmt|;
name|xpt_action
argument_list|(
operator|(
expr|union
name|ccb
operator|*
operator|)
operator|&
name|csa
argument_list|)
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
name|fail
label|:
if|if
condition|(
operator|(
name|ahc
operator|->
name|flags
operator|&
name|AHC_CHANNEL_B_PRIMARY
operator|)
operator|!=
literal|0
condition|)
block|{
name|ahc
operator|->
name|sim_b
operator|=
name|sim
expr_stmt|;
name|ahc
operator|->
name|path_b
operator|=
name|path
expr_stmt|;
name|ahc
operator|->
name|sim
operator|=
name|sim2
expr_stmt|;
name|ahc
operator|->
name|path
operator|=
name|path2
expr_stmt|;
block|}
else|else
block|{
name|ahc
operator|->
name|sim
operator|=
name|sim
expr_stmt|;
name|ahc
operator|->
name|path
operator|=
name|path
expr_stmt|;
name|ahc
operator|->
name|sim_b
operator|=
name|sim2
expr_stmt|;
name|ahc
operator|->
name|path_b
operator|=
name|path2
expr_stmt|;
block|}
return|return
operator|(
name|count
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ahc_fetch_devinfo
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|struct
name|ahc_devinfo
modifier|*
name|devinfo
parameter_list|)
block|{
name|u_int
name|saved_tcl
decl_stmt|;
name|saved_tcl
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SAVED_TCL
argument_list|)
expr_stmt|;
name|ahc_compile_devinfo
argument_list|(
name|devinfo
argument_list|,
operator|(
name|saved_tcl
operator|>>
literal|4
operator|)
operator|&
literal|0x0f
argument_list|,
operator|(
name|saved_tcl
operator|&
name|SELBUSB
operator|)
condition|?
literal|'B'
else|:
literal|'A'
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ahc_compile_devinfo
parameter_list|(
name|struct
name|ahc_devinfo
modifier|*
name|devinfo
parameter_list|,
name|u_int
name|target
parameter_list|,
name|char
name|channel
parameter_list|)
block|{
name|devinfo
operator|->
name|target
operator|=
name|target
expr_stmt|;
name|devinfo
operator|->
name|target_offset
operator|=
name|target
expr_stmt|;
name|devinfo
operator|->
name|channel
operator|=
name|channel
expr_stmt|;
if|if
condition|(
name|channel
operator|==
literal|'B'
condition|)
name|devinfo
operator|->
name|target_offset
operator|+=
literal|8
expr_stmt|;
name|devinfo
operator|->
name|target_mask
operator|=
operator|(
literal|0x01
operator|<<
name|devinfo
operator|->
name|target_offset
operator|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Catch an interrupt from the adapter  */
end_comment

begin_function
name|void
name|ahc_intr
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ahc_softc
modifier|*
name|ahc
decl_stmt|;
name|u_int
name|intstat
decl_stmt|;
name|ahc
operator|=
operator|(
expr|struct
name|ahc_softc
operator|*
operator|)
name|arg
expr_stmt|;
name|intstat
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|INTSTAT
argument_list|)
expr_stmt|;
comment|/* 	 * Any interrupts to process? 	 */
if|#
directive|if
name|NPCI
operator|>
literal|0
if|if
condition|(
operator|(
name|intstat
operator|&
name|INT_PEND
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|ahc
operator|->
name|chip
operator|&
name|AHC_PCI
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|ahc
operator|->
name|unsolicited_ints
operator|>
literal|500
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|ERROR
argument_list|)
operator|&
name|PCIERRSTAT
operator|)
operator|!=
literal|0
condition|)
name|ahc_pci_intr
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
name|ahc
operator|->
name|unsolicited_ints
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|ahc
operator|->
name|unsolicited_ints
operator|++
expr_stmt|;
block|}
return|return;
block|}
else|else
block|{
name|ahc
operator|->
name|unsolicited_ints
operator|=
literal|0
expr_stmt|;
block|}
else|#
directive|else
if|if
condition|(
operator|(
name|intstat
operator|&
name|INT_PEND
operator|)
operator|==
literal|0
condition|)
return|return;
endif|#
directive|endif
if|if
condition|(
name|intstat
operator|&
name|CMDCMPLT
condition|)
block|{
name|struct
name|scb
modifier|*
name|scb
decl_stmt|;
name|u_int
name|scb_index
decl_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|CLRINT
argument_list|,
name|CLRCMDINT
argument_list|)
expr_stmt|;
while|while
condition|(
name|ahc
operator|->
name|qoutfifo
index|[
name|ahc
operator|->
name|qoutfifonext
index|]
operator|!=
name|SCB_LIST_NULL
condition|)
block|{
name|scb_index
operator|=
name|ahc
operator|->
name|qoutfifo
index|[
name|ahc
operator|->
name|qoutfifonext
index|]
expr_stmt|;
name|ahc
operator|->
name|qoutfifo
index|[
name|ahc
operator|->
name|qoutfifonext
operator|++
index|]
operator|=
name|SCB_LIST_NULL
expr_stmt|;
if|if
condition|(
name|scb_index
operator|==
name|TARGET_CMD_CMPLT
operator|&&
operator|(
name|ahc
operator|->
name|flags
operator|&
name|AHC_TARGETMODE
operator|)
operator|!=
literal|0
condition|)
block|{
name|ahc_handle_target_cmd
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|scb
operator|=
name|ahc
operator|->
name|scb_data
operator|->
name|scbarray
index|[
name|scb_index
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|scb
operator|||
operator|!
operator|(
name|scb
operator|->
name|flags
operator|&
name|SCB_ACTIVE
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"%s: WARNING no command for scb %d "
literal|"(cmdcmplt)\nQOUTPOS = %d\n"
argument_list|,
name|ahc_name
argument_list|(
name|ahc
argument_list|)
argument_list|,
name|scb_index
argument_list|,
name|ahc
operator|->
name|qoutfifonext
operator|-
literal|1
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* 			 * Save off the residual 			 * if there is one. 			 */
if|if
condition|(
name|scb
operator|->
name|hscb
operator|->
name|residual_SG_count
operator|!=
literal|0
condition|)
name|ahc_calc_residual
argument_list|(
name|scb
argument_list|)
expr_stmt|;
name|ahc_done
argument_list|(
name|ahc
argument_list|,
name|scb
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|intstat
operator|&
name|BRKADRINT
condition|)
block|{
comment|/* 		 * We upset the sequencer :-( 		 * Lookup the error message 		 */
name|int
name|i
decl_stmt|,
name|error
decl_stmt|,
name|num_errors
decl_stmt|;
name|error
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|ERROR
argument_list|)
expr_stmt|;
name|num_errors
operator|=
sizeof|sizeof
argument_list|(
name|hard_error
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|hard_error
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|error
operator|!=
literal|1
operator|&&
name|i
operator|<
name|num_errors
condition|;
name|i
operator|++
control|)
name|error
operator|>>=
literal|1
expr_stmt|;
name|panic
argument_list|(
literal|"%s: brkadrint, %s at seqaddr = 0x%x\n"
argument_list|,
name|ahc_name
argument_list|(
name|ahc
argument_list|)
argument_list|,
name|hard_error
index|[
name|i
index|]
operator|.
name|errmesg
argument_list|,
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SEQADDR0
argument_list|)
operator||
operator|(
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SEQADDR1
argument_list|)
operator|<<
literal|8
operator|)
argument_list|)
expr_stmt|;
comment|/* Tell everyone that this HBA is no longer availible */
name|ahc_abort_scbs
argument_list|(
name|ahc
argument_list|,
name|ALL_TARGETS
argument_list|,
name|ALL_CHANNELS
argument_list|,
name|ALL_LUNS
argument_list|,
name|SCB_LIST_NULL
argument_list|,
name|CAM_NO_HBA
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|intstat
operator|&
name|SEQINT
condition|)
name|ahc_handle_seqint
argument_list|(
name|ahc
argument_list|,
name|intstat
argument_list|)
expr_stmt|;
if|if
condition|(
name|intstat
operator|&
name|SCSIINT
condition|)
name|ahc_handle_scsiint
argument_list|(
name|ahc
argument_list|,
name|intstat
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ahc_handle_target_cmd
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|)
block|{
name|struct
name|tmode_tstate
modifier|*
name|tstate
decl_stmt|;
name|struct
name|tmode_lstate
modifier|*
name|lstate
decl_stmt|;
name|struct
name|ccb_accept_tio
modifier|*
name|atio
decl_stmt|;
name|struct
name|target_cmd
modifier|*
name|cmd
decl_stmt|;
name|u_int8_t
modifier|*
name|byte
decl_stmt|;
name|int
name|initiator
decl_stmt|;
name|int
name|target
decl_stmt|;
name|int
name|lun
decl_stmt|;
name|cmd
operator|=
operator|&
name|ahc
operator|->
name|targetcmds
index|[
name|ahc
operator|->
name|next_targetcmd
index|]
expr_stmt|;
name|ahc
operator|->
name|next_targetcmd
operator|++
expr_stmt|;
if|if
condition|(
name|ahc
operator|->
name|next_targetcmd
operator|>=
name|ahc
operator|->
name|num_targetcmds
condition|)
name|ahc
operator|->
name|next_targetcmd
operator|=
literal|0
expr_stmt|;
name|initiator
operator|=
name|cmd
operator|->
name|icl
operator|>>
literal|4
expr_stmt|;
name|target
operator|=
name|cmd
operator|->
name|targ_id
expr_stmt|;
name|lun
operator|=
operator|(
name|cmd
operator|->
name|identify
operator|&
name|MSG_IDENTIFY_LUNMASK
operator|)
expr_stmt|;
name|xpt_print_path
argument_list|(
name|ahc
operator|->
name|path
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Received Target Command (%d:%d:%d)\n"
argument_list|,
name|initiator
argument_list|,
name|target
argument_list|,
name|lun
argument_list|)
expr_stmt|;
name|ahc_dump_targcmd
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
name|byte
operator|=
name|cmd
operator|->
name|bytes
expr_stmt|;
name|tstate
operator|=
name|ahc
operator|->
name|enabled_targets
index|[
name|target
index|]
expr_stmt|;
name|lstate
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|tstate
operator|!=
name|NULL
operator|&&
name|lun
operator|<
literal|8
condition|)
name|lstate
operator|=
name|tstate
operator|->
name|enabled_luns
index|[
name|lun
index|]
expr_stmt|;
comment|/* 	 * XXX Need to have a default TMODE devce that attaches to luns 	 *     that wouldn't otherwise be enabled and returns the proper 	 *     inquiry information.  After all, we don't want to duplicate 	 *     this code in each driver.  For now, simply drop it on the 	 *     floor. 	 */
if|if
condition|(
name|lstate
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"Incoming Command on disabled lun\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|atio
operator|=
operator|(
expr|struct
name|ccb_accept_tio
operator|*
operator|)
name|SLIST_FIRST
argument_list|(
operator|&
name|lstate
operator|->
name|accept_tios
argument_list|)
expr_stmt|;
comment|/* XXX Should reconnect and return BUSY status */
if|if
condition|(
name|atio
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"No ATIOs for incoming command\n"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Package it up and send it off to 	 * whomever has this lun enabled. 	 */
name|atio
operator|->
name|init_id
operator|=
name|initiator
expr_stmt|;
if|if
condition|(
name|byte
index|[
literal|0
index|]
operator|!=
literal|0xFF
condition|)
block|{
comment|/* Tag was included */
name|atio
operator|->
name|tag_action
operator|=
operator|*
name|byte
operator|++
expr_stmt|;
name|atio
operator|->
name|tag_id
operator|=
operator|*
name|byte
operator|++
expr_stmt|;
name|atio
operator|->
name|ccb_h
operator|.
name|flags
operator|=
name|CAM_TAG_ACTION_VALID
expr_stmt|;
block|}
else|else
block|{
name|byte
operator|++
expr_stmt|;
name|atio
operator|->
name|ccb_h
operator|.
name|flags
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Okay.  Now determine the cdb size based on the command code */
switch|switch
condition|(
operator|*
name|byte
operator|>>
name|CMD_GROUP_CODE_SHIFT
condition|)
block|{
case|case
literal|0
case|:
name|atio
operator|->
name|cdb_len
operator|=
literal|6
expr_stmt|;
break|break;
case|case
literal|1
case|:
case|case
literal|2
case|:
name|atio
operator|->
name|cdb_len
operator|=
literal|10
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|atio
operator|->
name|cdb_len
operator|=
literal|16
expr_stmt|;
break|break;
case|case
literal|5
case|:
name|atio
operator|->
name|cdb_len
operator|=
literal|12
expr_stmt|;
break|break;
case|case
literal|3
case|:
default|default:
comment|/* Only copy the opcode. */
name|atio
operator|->
name|cdb_len
operator|=
literal|1
expr_stmt|;
name|printf
argument_list|(
literal|"Reserved or VU command code type encountered\n"
argument_list|)
expr_stmt|;
break|break;
block|}
name|bcopy
argument_list|(
name|byte
argument_list|,
name|atio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
argument_list|,
name|atio
operator|->
name|cdb_len
argument_list|)
expr_stmt|;
name|SLIST_REMOVE_HEAD
argument_list|(
operator|&
name|lstate
operator|->
name|accept_tios
argument_list|,
name|sim_links
operator|.
name|sle
argument_list|)
expr_stmt|;
name|atio
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_CDB_RECVD
expr_stmt|;
if|if
condition|(
operator|(
name|cmd
operator|->
name|identify
operator|&
name|MSG_IDENTIFY_DISCFLAG
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 		 * We weren't allowed to disconnect. 		 * We're hanging on the bus until a 		 * continue target I/O comes in response 		 * to this accept tio. 		 */
name|xpt_print_path
argument_list|(
name|atio
operator|->
name|ccb_h
operator|.
name|path
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Incoming Command did not disconnect %p\n"
argument_list|,
name|lstate
argument_list|)
expr_stmt|;
name|ahc
operator|->
name|pending_device
operator|=
name|lstate
expr_stmt|;
block|}
name|xpt_done
argument_list|(
operator|(
expr|union
name|ccb
operator|*
operator|)
name|atio
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ahc_handle_seqint
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|u_int
name|intstat
parameter_list|)
block|{
name|struct
name|scb
modifier|*
name|scb
decl_stmt|;
name|struct
name|ahc_devinfo
name|devinfo
decl_stmt|;
name|ahc_fetch_devinfo
argument_list|(
name|ahc
argument_list|,
operator|&
name|devinfo
argument_list|)
expr_stmt|;
comment|/* 	 * Clear the upper byte that holds SEQINT status 	 * codes and clear the SEQINT bit. We will unpause 	 * the sequencer, if appropriate, after servicing 	 * the request. 	 */
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|CLRINT
argument_list|,
name|CLRSEQINT
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|intstat
operator|&
name|SEQINT_MASK
condition|)
block|{
case|case
name|NO_MATCH
case|:
block|{
comment|/* Ensure we don't leave the selection hardware on */
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCSISEQ
argument_list|,
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCSISEQ
argument_list|)
operator|&
operator|(
name|ENSELI
operator||
name|ENRSELI
operator||
name|ENAUTOATNP
operator|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s:%c:%d: no active SCB for reconnecting "
literal|"target - issuing BUS DEVICE RESET\n"
argument_list|,
name|ahc_name
argument_list|(
name|ahc
argument_list|)
argument_list|,
name|devinfo
operator|.
name|channel
argument_list|,
name|devinfo
operator|.
name|target
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"SAVED_TCL == 0x%x, ARG_1 == 0x%x, SEQ_FLAGS == 0x%x\n"
argument_list|,
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SAVED_TCL
argument_list|)
argument_list|,
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|ARG_1
argument_list|)
argument_list|,
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SEQ_FLAGS
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|SEND_REJECT
case|:
block|{
name|u_int
name|rejbyte
init|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|ACCUM
argument_list|)
decl_stmt|;
name|printf
argument_list|(
literal|"%s:%c:%d: Warning - unknown message received from "
literal|"target (0x%x).  Rejecting\n"
argument_list|,
name|ahc_name
argument_list|(
name|ahc
argument_list|)
argument_list|,
name|devinfo
operator|.
name|channel
argument_list|,
name|devinfo
operator|.
name|target
argument_list|,
name|rejbyte
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|NO_IDENT
case|:
block|{
comment|/* 		 * The reconnecting target either did not send an identify 		 * message, or did, but we didn't find and SCB to match and 		 * before it could respond to our ATN/abort, it hit a dataphase. 		 * The only safe thing to do is to blow it away with a bus 		 * reset. 		 */
name|int
name|found
decl_stmt|;
name|printf
argument_list|(
literal|"%s:%c:%d: Target did not send an IDENTIFY message. "
literal|"LASTPHASE = 0x%x, SAVED_TCL == 0x%x\n"
argument_list|,
name|ahc_name
argument_list|(
name|ahc
argument_list|)
argument_list|,
name|devinfo
operator|.
name|channel
argument_list|,
name|devinfo
operator|.
name|target
argument_list|,
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|LASTPHASE
argument_list|)
argument_list|,
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SAVED_TCL
argument_list|)
argument_list|)
expr_stmt|;
name|found
operator|=
name|ahc_reset_channel
argument_list|(
name|ahc
argument_list|,
name|devinfo
operator|.
name|channel
argument_list|,
comment|/*initiate reset*/
name|TRUE
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s: Issued Channel %c Bus Reset. "
literal|"%d SCBs aborted\n"
argument_list|,
name|ahc_name
argument_list|(
name|ahc
argument_list|)
argument_list|,
name|devinfo
operator|.
name|channel
argument_list|,
name|found
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|BAD_PHASE
case|:
if|if
condition|(
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|LASTPHASE
argument_list|)
operator|==
name|P_BUSFREE
condition|)
block|{
name|printf
argument_list|(
literal|"%s:%c:%d: Missed busfree.\n"
argument_list|,
name|ahc_name
argument_list|(
name|ahc
argument_list|)
argument_list|,
name|devinfo
operator|.
name|channel
argument_list|,
name|devinfo
operator|.
name|target
argument_list|)
expr_stmt|;
name|restart_sequencer
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"%s:%c:%d: unknown scsi bus phase.  Attempting "
literal|"to continue\n"
argument_list|,
name|ahc_name
argument_list|(
name|ahc
argument_list|)
argument_list|,
name|devinfo
operator|.
name|channel
argument_list|,
name|devinfo
operator|.
name|target
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|EXTENDED_MSG
case|:
block|{
name|ahc
operator|->
name|msg_type
operator|=
name|MSG_TYPE_INITIATOR_MSGIN
expr_stmt|;
name|ahc
operator|->
name|msg_len
operator|=
literal|0
expr_stmt|;
name|ahc
operator|->
name|msg_index
operator|=
literal|0
expr_stmt|;
comment|/*       		 * To actually receive the message, simply turn on 		 * REQINIT interrupts and let our interrupt handler 		 * do the rest (REQINIT should already be true). 		 */
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SIMODE1
argument_list|,
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SIMODE1
argument_list|)
operator||
name|ENREQINIT
argument_list|)
expr_stmt|;
name|ahc
operator|->
name|flags
operator||=
name|AHC_HANDLING_REQINITS
expr_stmt|;
return|return;
block|}
case|case
name|REJECT_MSG
case|:
block|{
comment|/* 		 * What we care about here is if we had an 		 * outstanding SDTR or WDTR message for this 		 * target.  If we did, this is a signal that 		 * the target is refusing negotiation. 		 */
name|u_int
name|scb_index
decl_stmt|;
name|u_int
name|last_msg
decl_stmt|;
name|scb_index
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCB_TAG
argument_list|)
expr_stmt|;
name|scb
operator|=
name|ahc
operator|->
name|scb_data
operator|->
name|scbarray
index|[
name|scb_index
index|]
expr_stmt|;
name|last_msg
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|LAST_MSG
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|last_msg
operator|==
name|MSG_IDENTIFYFLAG
operator|||
name|last_msg
operator|==
name|HOST_MSG
operator|)
operator|&&
operator|(
name|scb
operator|->
name|flags
operator|&
name|SCB_MSGOUT_WDTR
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|scb
operator|->
name|flags
operator|&
name|SCB_MSGOUT_SENT
operator|)
operator|!=
literal|0
condition|)
block|{
name|struct
name|ahc_target_tinfo
modifier|*
name|tinfo
decl_stmt|;
comment|/* note 8bit xfers and clear flag */
name|printf
argument_list|(
literal|"%s:%c:%d: refuses WIDE negotiation.  Using "
literal|"8bit transfers\n"
argument_list|,
name|ahc_name
argument_list|(
name|ahc
argument_list|)
argument_list|,
name|devinfo
operator|.
name|channel
argument_list|,
name|devinfo
operator|.
name|target
argument_list|)
expr_stmt|;
name|scb
operator|->
name|flags
operator|&=
operator|~
name|SCB_MSGOUT_BITS
expr_stmt|;
name|ahc
operator|->
name|wdtrpending
operator|&=
operator|~
name|devinfo
operator|.
name|target_mask
expr_stmt|;
name|ahc_set_width
argument_list|(
name|ahc
argument_list|,
operator|&
name|devinfo
argument_list|,
name|scb
operator|->
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
name|MSG_EXT_WDTR_BUS_8_BIT
argument_list|,
name|AHC_TRANS_ACTIVE
operator||
name|AHC_TRANS_GOAL
argument_list|)
expr_stmt|;
name|ahc_set_syncrate
argument_list|(
name|ahc
argument_list|,
operator|&
name|devinfo
argument_list|,
name|scb
operator|->
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
comment|/*syncrate*/
name|NULL
argument_list|,
comment|/*period*/
literal|0
argument_list|,
comment|/*offset*/
literal|0
argument_list|,
name|AHC_TRANS_ACTIVE
argument_list|)
expr_stmt|;
name|tinfo
operator|=
operator|&
name|ahc
operator|->
name|transinfo
index|[
name|devinfo
operator|.
name|target_offset
index|]
expr_stmt|;
if|if
condition|(
name|tinfo
operator|->
name|goal
operator|.
name|period
condition|)
block|{
comment|/* Start the sync negotiation */
name|ahc
operator|->
name|sdtrpending
operator||=
name|devinfo
operator|.
name|target_mask
expr_stmt|;
name|scb
operator|->
name|flags
operator||=
name|SCB_MSGOUT_SDTR
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|MSG_OUT
argument_list|,
name|HOST_MSG
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCSISIGO
argument_list|,
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCSISIGO
argument_list|)
operator||
name|ATNO
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|last_msg
operator|==
name|MSG_IDENTIFYFLAG
operator|||
name|last_msg
operator|==
name|HOST_MSG
operator|)
operator|&&
operator|(
name|scb
operator|->
name|flags
operator|&
name|SCB_MSGOUT_SDTR
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|scb
operator|->
name|flags
operator|&
name|SCB_MSGOUT_SENT
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* note asynch xfers and clear flag */
name|ahc_set_syncrate
argument_list|(
name|ahc
argument_list|,
operator|&
name|devinfo
argument_list|,
name|scb
operator|->
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
comment|/*syncrate*/
name|NULL
argument_list|,
comment|/*period*/
literal|0
argument_list|,
comment|/*offset*/
literal|0
argument_list|,
name|AHC_TRANS_ACTIVE
operator||
name|AHC_TRANS_GOAL
argument_list|)
expr_stmt|;
name|scb
operator|->
name|flags
operator|&=
operator|~
name|SCB_MSGOUT_BITS
expr_stmt|;
name|ahc
operator|->
name|sdtrpending
operator|&=
operator|~
name|devinfo
operator|.
name|target_mask
expr_stmt|;
name|printf
argument_list|(
literal|"%s:%c:%d: refuses synchronous negotiation. "
literal|"Using asynchronous transfers\n"
argument_list|,
name|ahc_name
argument_list|(
name|ahc
argument_list|)
argument_list|,
name|devinfo
operator|.
name|channel
argument_list|,
name|devinfo
operator|.
name|target
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|last_msg
operator|==
name|MSG_IDENTIFYFLAG
operator|)
operator|&&
operator|(
name|scb
operator|->
name|hscb
operator|->
name|control
operator|&
name|MSG_SIMPLE_Q_TAG
operator|)
operator|!=
literal|0
condition|)
block|{
name|struct
name|ccb_trans_settings
name|neg
decl_stmt|;
name|printf
argument_list|(
literal|"%s:%c:%d: refuses tagged commands.  Performing "
literal|"non-tagged I/O\n"
argument_list|,
name|ahc_name
argument_list|(
name|ahc
argument_list|)
argument_list|,
name|devinfo
operator|.
name|channel
argument_list|,
name|devinfo
operator|.
name|target
argument_list|)
expr_stmt|;
name|ahc
operator|->
name|tagenable
operator|&=
operator|~
name|devinfo
operator|.
name|target_mask
expr_stmt|;
name|neg
operator|.
name|flags
operator|=
literal|0
expr_stmt|;
name|neg
operator|.
name|valid
operator|=
name|CCB_TRANS_TQ_VALID
expr_stmt|;
name|xpt_setup_ccb
argument_list|(
operator|&
name|neg
operator|.
name|ccb_h
argument_list|,
name|scb
operator|->
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
comment|/*priority*/
literal|1
argument_list|)
expr_stmt|;
name|xpt_async
argument_list|(
name|AC_TRANSFER_NEG
argument_list|,
name|scb
operator|->
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
operator|&
name|neg
argument_list|)
expr_stmt|;
comment|/* 			 * Resend the identify for this CCB as the target 			 * may believe that the selection is invalid otherwise. 			 */
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCB_CONTROL
argument_list|,
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCB_CONTROL
argument_list|)
operator|&
operator|~
name|MSG_SIMPLE_Q_TAG
argument_list|)
expr_stmt|;
name|scb
operator|->
name|hscb
operator|->
name|control
operator|&=
operator|~
name|MSG_SIMPLE_Q_TAG
expr_stmt|;
name|scb
operator|->
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&=
operator|~
name|CAM_TAG_ACTION_VALID
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|MSG_OUT
argument_list|,
name|MSG_IDENTIFYFLAG
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCSISIGO
argument_list|,
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCSISIGO
argument_list|)
operator||
name|ATNO
argument_list|)
expr_stmt|;
comment|/* 			 * Requeue all tagged commands for this target 			 * currently in our posession so they can be 			 * converted to untagged commands. 			 */
name|ahc_search_qinfifo
argument_list|(
name|ahc
argument_list|,
name|SCB_TARGET
argument_list|(
name|scb
argument_list|)
argument_list|,
name|SCB_CHANNEL
argument_list|(
name|scb
argument_list|)
argument_list|,
name|SCB_LUN
argument_list|(
name|scb
argument_list|)
argument_list|,
comment|/*tag*/
name|SCB_LIST_NULL
argument_list|,
name|CAM_REQUEUE_REQ
argument_list|,
name|SEARCH_COMPLETE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * Otherwise, we ignore it. 			 */
ifdef|#
directive|ifdef
name|AHC_DEBUG
if|if
condition|(
name|ahc_debug
operator|&
name|AHC_SHOWMISC
condition|)
name|printf
argument_list|(
literal|"%s:%c:%d: Message reject -- ignored\n"
argument_list|,
name|ahc_name
argument_list|(
name|ahc
argument_list|)
argument_list|,
name|devinfo
operator|.
name|channel
argument_list|,
name|devinfo
operator|.
name|target
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
block|}
break|break;
block|}
case|case
name|BAD_STATUS
case|:
block|{
name|u_int
name|scb_index
decl_stmt|;
name|struct
name|hardware_scb
modifier|*
name|hscb
decl_stmt|;
name|struct
name|ccb_scsiio
modifier|*
name|csio
decl_stmt|;
comment|/* 		 * The sequencer will notify us when a command 		 * has an error that would be of interest to 		 * the kernel.  This allows us to leave the sequencer 		 * running in the common case of command completes 		 * without error.  The sequencer will already have 		 * dma'd the SCB back up to us, so we can reference 		 * the in kernel copy directly. 		 */
name|scb_index
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCB_TAG
argument_list|)
expr_stmt|;
name|scb
operator|=
name|ahc
operator|->
name|scb_data
operator|->
name|scbarray
index|[
name|scb_index
index|]
expr_stmt|;
name|hscb
operator|=
name|scb
operator|->
name|hscb
expr_stmt|;
comment|/* 		 * Set the default return value to 0 (don't 		 * send sense).  The sense code will change 		 * this if needed. 		 */
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|RETURN_1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|scb
operator|&&
operator|(
name|scb
operator|->
name|flags
operator|&
name|SCB_ACTIVE
operator|)
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"%s:%c:%d: ahc_intr - referenced scb "
literal|"not valid during seqint 0x%x scb(%d)\n"
argument_list|,
name|ahc_name
argument_list|(
name|ahc
argument_list|)
argument_list|,
name|devinfo
operator|.
name|channel
argument_list|,
name|devinfo
operator|.
name|target
argument_list|,
name|intstat
argument_list|,
name|scb_index
argument_list|)
expr_stmt|;
goto|goto
name|unpause
goto|;
block|}
comment|/* Don't want to clobber the original sense code */
if|if
condition|(
operator|(
name|scb
operator|->
name|flags
operator|&
name|SCB_SENSE
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* 			 * Clear the SCB_SENSE Flag and have 			 * the sequencer do a normal command 			 * complete. 			 */
name|scb
operator|->
name|flags
operator|&=
operator|~
name|SCB_SENSE
expr_stmt|;
name|ahc_set_ccb_status
argument_list|(
name|scb
operator|->
name|ccb
argument_list|,
name|CAM_AUTOSENSE_FAIL
argument_list|)
expr_stmt|;
break|break;
block|}
name|ahc_set_ccb_status
argument_list|(
name|scb
operator|->
name|ccb
argument_list|,
name|CAM_SCSI_STATUS_ERROR
argument_list|)
expr_stmt|;
name|csio
operator|=
operator|&
name|scb
operator|->
name|ccb
operator|->
name|csio
expr_stmt|;
name|csio
operator|->
name|scsi_status
operator|=
name|hscb
operator|->
name|status
expr_stmt|;
switch|switch
condition|(
name|hscb
operator|->
name|status
condition|)
block|{
case|case
name|SCSI_STATUS_OK
case|:
name|printf
argument_list|(
literal|"%s: Interrupted for staus of 0???\n"
argument_list|,
name|ahc_name
argument_list|(
name|ahc
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCSI_STATUS_CMD_TERMINATED
case|:
case|case
name|SCSI_STATUS_CHECK_COND
case|:
ifdef|#
directive|ifdef
name|AHC_DEBUG
if|if
condition|(
name|ahc_debug
operator|&
name|AHC_SHOWSENSE
condition|)
block|{
name|xpt_print_path
argument_list|(
name|csio
operator|->
name|ccb_h
operator|.
name|path
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"SCB %d: requests Check Status\n"
argument_list|,
name|scb
operator|->
name|hscb
operator|->
name|tag
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
operator|(
name|csio
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DIS_AUTOSENSE
operator|)
operator|==
literal|0
condition|)
block|{
name|struct
name|ahc_dma_seg
modifier|*
name|sg
init|=
name|scb
operator|->
name|ahc_dma
decl_stmt|;
name|struct
name|scsi_sense
modifier|*
name|sc
init|=
operator|(
expr|struct
name|scsi_sense
operator|*
operator|)
operator|(
operator|&
name|hscb
operator|->
name|cmdstore
operator|)
decl_stmt|;
name|struct
name|ahc_target_tinfo
modifier|*
name|tinfo
decl_stmt|;
comment|/* 				 * Save off the residual if there is one. 				 */
if|if
condition|(
name|hscb
operator|->
name|residual_SG_count
operator|!=
literal|0
condition|)
name|ahc_calc_residual
argument_list|(
name|scb
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|AHC_DEBUG
if|if
condition|(
name|ahc_debug
operator|&
name|AHC_SHOWSENSE
condition|)
block|{
name|xpt_print_path
argument_list|(
name|csio
operator|->
name|ccb_h
operator|.
name|path
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Sending Sense\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* 				 * bzero from the sense data before having 				 * the drive fill it.  The SCSI spec mandates 				 * that any untransfered data should be 				 * assumed to be zero. 				 */
name|bzero
argument_list|(
operator|&
name|csio
operator|->
name|sense_data
argument_list|,
sizeof|sizeof
argument_list|(
name|csio
operator|->
name|sense_data
argument_list|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|opcode
operator|=
name|REQUEST_SENSE
expr_stmt|;
name|sc
operator|->
name|byte2
operator|=
name|SCB_LUN
argument_list|(
name|scb
argument_list|)
operator|<<
literal|5
expr_stmt|;
name|sc
operator|->
name|unused
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|unused
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|length
operator|=
name|csio
operator|->
name|sense_len
expr_stmt|;
name|sc
operator|->
name|control
operator|=
literal|0
expr_stmt|;
name|sg
operator|->
name|addr
operator|=
name|vtophys
argument_list|(
operator|&
name|csio
operator|->
name|sense_data
argument_list|)
expr_stmt|;
name|sg
operator|->
name|len
operator|=
name|csio
operator|->
name|sense_len
expr_stmt|;
comment|/* 				 * Would be nice to preserve DISCENB here, 				 * but due to the way we page SCBs, we can't. 				 */
name|hscb
operator|->
name|control
operator|=
literal|0
expr_stmt|;
comment|/* 				 * This request sense could be because the 				 * the device lost power or in some other 				 * way has lost our transfer negotiations. 				 * Renegotiate if appropriate. 				 */
name|ahc_set_width
argument_list|(
name|ahc
argument_list|,
operator|&
name|devinfo
argument_list|,
name|scb
operator|->
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
name|MSG_EXT_WDTR_BUS_8_BIT
argument_list|,
name|AHC_TRANS_CUR
argument_list|)
expr_stmt|;
name|ahc_set_syncrate
argument_list|(
name|ahc
argument_list|,
operator|&
name|devinfo
argument_list|,
name|scb
operator|->
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
comment|/*syncrate*/
name|NULL
argument_list|,
comment|/*period*/
literal|0
argument_list|,
comment|/*offset*/
literal|0
argument_list|,
name|AHC_TRANS_CUR
argument_list|)
expr_stmt|;
name|scb
operator|->
name|flags
operator|&=
operator|~
name|SCB_MSGOUT_BITS
expr_stmt|;
name|tinfo
operator|=
operator|&
name|ahc
operator|->
name|transinfo
index|[
name|devinfo
operator|.
name|target_offset
index|]
expr_stmt|;
if|if
condition|(
name|tinfo
operator|->
name|goal
operator|.
name|width
condition|)
block|{
name|ahc
operator|->
name|wdtrpending
operator||=
name|devinfo
operator|.
name|target_mask
expr_stmt|;
name|hscb
operator|->
name|control
operator||=
name|MK_MESSAGE
expr_stmt|;
name|scb
operator|->
name|flags
operator||=
name|SCB_MSGOUT_WDTR
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tinfo
operator|->
name|goal
operator|.
name|period
condition|)
block|{
name|ahc
operator|->
name|sdtrpending
operator||=
name|devinfo
operator|.
name|target_mask
expr_stmt|;
name|hscb
operator|->
name|control
operator||=
name|MK_MESSAGE
expr_stmt|;
name|scb
operator|->
name|flags
operator||=
name|SCB_MSGOUT_SDTR
expr_stmt|;
block|}
name|hscb
operator|->
name|status
operator|=
literal|0
expr_stmt|;
name|hscb
operator|->
name|SG_count
operator|=
literal|1
expr_stmt|;
name|hscb
operator|->
name|SG_pointer
operator|=
name|scb
operator|->
name|ahc_dmaphys
expr_stmt|;
name|hscb
operator|->
name|data
operator|=
name|sg
operator|->
name|addr
expr_stmt|;
name|hscb
operator|->
name|datalen
operator|=
name|sg
operator|->
name|len
expr_stmt|;
name|hscb
operator|->
name|cmdpointer
operator|=
name|hscb
operator|->
name|cmdstore_busaddr
expr_stmt|;
name|hscb
operator|->
name|cmdlen
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|sc
argument_list|)
expr_stmt|;
name|scb
operator|->
name|sg_count
operator|=
name|hscb
operator|->
name|SG_count
expr_stmt|;
name|scb
operator|->
name|flags
operator||=
name|SCB_SENSE
expr_stmt|;
comment|/* 				 * Ensure the target is busy since this 				 * will be an untagged request. 				 */
name|ahc_busy_tcl
argument_list|(
name|ahc
argument_list|,
name|scb
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|RETURN_1
argument_list|,
name|SEND_SENSE
argument_list|)
expr_stmt|;
comment|/* 				 * Ensure we have enough time to actually 				 * retrieve the sense. 				 */
name|untimeout
argument_list|(
name|ahc_timeout
argument_list|,
operator|(
name|caddr_t
operator|)
name|scb
argument_list|,
name|scb
operator|->
name|ccb
operator|->
name|ccb_h
operator|.
name|timeout_ch
argument_list|)
expr_stmt|;
name|scb
operator|->
name|ccb
operator|->
name|ccb_h
operator|.
name|timeout_ch
operator|=
name|timeout
argument_list|(
name|ahc_timeout
argument_list|,
operator|(
name|caddr_t
operator|)
name|scb
argument_list|,
literal|5
operator|*
name|hz
argument_list|)
expr_stmt|;
comment|/* Freeze the queue while the sense occurs. */
name|ahc_freeze_devq
argument_list|(
name|ahc
argument_list|,
name|scb
operator|->
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|)
expr_stmt|;
name|ahc_freeze_ccb
argument_list|(
name|scb
operator|->
name|ccb
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|SCSI_STATUS_BUSY
case|:
case|case
name|SCSI_STATUS_QUEUE_FULL
case|:
comment|/* 			 * Requeue any transactions that haven't been 			 * sent yet. 			 */
name|ahc_freeze_devq
argument_list|(
name|ahc
argument_list|,
name|scb
operator|->
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|)
expr_stmt|;
name|ahc_freeze_ccb
argument_list|(
name|scb
operator|->
name|ccb
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
block|}
case|case
name|TARGET_SYNC_CMD
case|:
block|{
comment|/* 		 * We've already processed the command.  If the command 		 * is still pending, don't unpause the sequencer until 		 * it returns. 		 */
name|xpt_print_path
argument_list|(
name|ahc
operator|->
name|path
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Saw a target sync cmd\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ahc
operator|->
name|pending_device
operator|!=
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"	Pending device too.\n"
argument_list|)
expr_stmt|;
return|return;
block|}
break|break;
block|}
case|case
name|TARGET_MSG_HELP
case|:
block|{
comment|/* 		 * XXX Handle BDR, Abort, Abort Tag, and transfer negotiations. 		 */
name|restart_sequencer
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
return|return;
block|}
case|case
name|AWAITING_MSG
case|:
block|{
name|u_int
name|scb_index
decl_stmt|;
name|scb_index
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCB_TAG
argument_list|)
expr_stmt|;
name|scb
operator|=
name|ahc
operator|->
name|scb_data
operator|->
name|scbarray
index|[
name|scb_index
index|]
expr_stmt|;
comment|/*               		 * To facilitate adding multiple messages together, 		 * each routine should increment the index and len 		 * variables instead of setting them explicitly. 		 */
name|ahc
operator|->
name|msg_index
operator|=
literal|0
expr_stmt|;
name|ahc
operator|->
name|msg_len
operator|=
literal|0
expr_stmt|;
comment|/* 		 * This SCB had MK_MESSAGE set in its control byte or 		 * we have explicitly set HOST_MSG in MSG_OUT, 		 * informing the sequencer that we want to send a 		 * special message to this target. 		 */
if|if
condition|(
operator|(
name|scb
operator|->
name|flags
operator|&
name|SCB_DEVICE_RESET
operator|)
operator|==
literal|0
operator|&&
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|MSG_OUT
argument_list|)
operator|==
name|MSG_IDENTIFYFLAG
operator|&&
operator|(
name|scb
operator|->
name|hscb
operator|->
name|control
operator|&
name|TAG_ENB
operator|)
operator|!=
literal|0
condition|)
block|{
name|ahc
operator|->
name|msg_buf
index|[
name|ahc
operator|->
name|msg_index
operator|++
index|]
operator|=
name|scb
operator|->
name|ccb
operator|->
name|csio
operator|.
name|tag_action
expr_stmt|;
name|ahc
operator|->
name|msg_buf
index|[
name|ahc
operator|->
name|msg_index
operator|++
index|]
operator|=
name|scb
operator|->
name|hscb
operator|->
name|tag
expr_stmt|;
name|ahc
operator|->
name|msg_len
operator|+=
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|scb
operator|->
name|flags
operator|&
name|SCB_DEVICE_RESET
condition|)
block|{
name|ahc
operator|->
name|msg_buf
index|[
name|ahc
operator|->
name|msg_index
operator|++
index|]
operator|=
name|MSG_BUS_DEV_RESET
expr_stmt|;
name|ahc
operator|->
name|msg_len
operator|++
expr_stmt|;
name|xpt_print_path
argument_list|(
name|scb
operator|->
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Bus Device Reset Message Sent\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|scb
operator|->
name|flags
operator|&
name|SCB_ABORT
condition|)
block|{
if|if
condition|(
operator|(
name|scb
operator|->
name|hscb
operator|->
name|control
operator|&
name|TAG_ENB
operator|)
operator|!=
literal|0
condition|)
name|ahc
operator|->
name|msg_buf
index|[
name|ahc
operator|->
name|msg_index
operator|++
index|]
operator|=
name|MSG_ABORT_TAG
expr_stmt|;
else|else
name|ahc
operator|->
name|msg_buf
index|[
name|ahc
operator|->
name|msg_index
operator|++
index|]
operator|=
name|MSG_ABORT
expr_stmt|;
name|ahc
operator|->
name|msg_len
operator|++
expr_stmt|;
name|xpt_print_path
argument_list|(
name|scb
operator|->
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Abort Message Sent\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|scb
operator|->
name|flags
operator|&
name|SCB_MSGOUT_WDTR
condition|)
block|{
name|struct
name|ahc_target_tinfo
modifier|*
name|tinfo
decl_stmt|;
name|tinfo
operator|=
operator|&
name|ahc
operator|->
name|transinfo
index|[
name|devinfo
operator|.
name|target_offset
index|]
expr_stmt|;
name|ahc_construct_wdtr
argument_list|(
name|ahc
argument_list|,
name|tinfo
operator|->
name|goal
operator|.
name|width
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|scb
operator|->
name|flags
operator|&
name|SCB_MSGOUT_SDTR
condition|)
block|{
name|struct
name|ahc_target_tinfo
modifier|*
name|tinfo
decl_stmt|;
name|u_int
name|period
decl_stmt|;
name|u_int
name|maxsync
decl_stmt|;
comment|/* 			 * Now that the target is actually selected, we 			 * can further refine our sync rate based on the 			 * output transceiver mode. 			 */
if|if
condition|(
operator|(
name|ahc
operator|->
name|features
operator|&
name|AHC_ULTRA2
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SBLKCTL
argument_list|)
operator|&
name|ENAB40
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SSTAT2
argument_list|)
operator|&
name|EXP_ACTIVE
operator|)
operator|==
literal|0
condition|)
block|{
name|maxsync
operator|=
name|AHC_SYNCRATE_ULTRA2
expr_stmt|;
block|}
else|else
block|{
name|maxsync
operator|=
name|AHC_SYNCRATE_ULTRA
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|ahc
operator|->
name|features
operator|&
name|AHC_ULTRA
operator|)
operator|!=
literal|0
condition|)
block|{
name|maxsync
operator|=
name|AHC_SYNCRATE_ULTRA
expr_stmt|;
block|}
else|else
block|{
name|maxsync
operator|=
name|AHC_SYNCRATE_FAST
expr_stmt|;
block|}
name|tinfo
operator|=
operator|&
name|ahc
operator|->
name|transinfo
index|[
name|devinfo
operator|.
name|target_offset
index|]
expr_stmt|;
name|period
operator|=
name|tinfo
operator|->
name|goal
operator|.
name|period
expr_stmt|;
name|ahc_find_syncrate
argument_list|(
name|ahc
argument_list|,
operator|&
name|period
argument_list|,
name|maxsync
argument_list|)
expr_stmt|;
name|ahc_construct_sdtr
argument_list|(
name|ahc
argument_list|,
name|period
argument_list|,
name|tinfo
operator|->
name|goal
operator|.
name|offset
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"ahc_intr: AWAITING_MSG for an SCB that "
literal|"does not have a waiting message"
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"SCB = %d, SCB Control = %x, MSG_OUT = %x "
literal|"SCB flags = %x"
argument_list|,
name|scb_index
argument_list|,
name|scb
operator|->
name|hscb
operator|->
name|control
argument_list|,
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|MSG_OUT
argument_list|)
argument_list|,
name|scb
operator|->
name|flags
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Record the fact that we attempted to send a message. 		 */
name|scb
operator|->
name|flags
operator||=
name|SCB_MSGOUT_SENT
expr_stmt|;
comment|/* 		 * To actually send the message, simply turn on 		 * REQINIT interrupts and let our interrupt handler 		 * do the rest (REQINIT should already be true). 		 */
name|ahc
operator|->
name|msg_index
operator|=
literal|0
expr_stmt|;
name|ahc
operator|->
name|msg_type
operator|=
name|MSG_TYPE_INITIATOR_MSGOUT
expr_stmt|;
name|ahc
operator|->
name|flags
operator||=
name|AHC_HANDLING_REQINITS
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SIMODE1
argument_list|,
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SIMODE1
argument_list|)
operator||
name|ENREQINIT
argument_list|)
expr_stmt|;
return|return;
block|}
case|case
name|DATA_OVERRUN
case|:
block|{
comment|/* 		 * When the sequencer detects an overrun, it 		 * places the controller in "BITBUCKET" mode 		 * and allows the target to complete its transfer. 		 * Unfortunately, none of the counters get updated 		 * when the controller is in this mode, so we have 		 * no way of knowing how large the overrun was. 		 */
name|u_int
name|scbindex
init|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCB_TAG
argument_list|)
decl_stmt|;
name|u_int
name|lastphase
init|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|LASTPHASE
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
name|scb
operator|=
name|ahc
operator|->
name|scb_data
operator|->
name|scbarray
index|[
name|scbindex
index|]
expr_stmt|;
name|xpt_print_path
argument_list|(
name|scb
operator|->
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"data overrun detected in %s phase."
literal|"  Tag == 0x%x.\n"
argument_list|,
name|lastphase
operator|==
name|P_DATAIN
condition|?
literal|"Data-In"
else|:
literal|"Data-Out"
argument_list|,
name|scb
operator|->
name|hscb
operator|->
name|tag
argument_list|)
expr_stmt|;
name|xpt_print_path
argument_list|(
name|scb
operator|->
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s seen Data Phase.  Length = %d.  NumSGs = %d.\n"
argument_list|,
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SEQ_FLAGS
argument_list|)
operator|&
name|DPHASE
condition|?
literal|"Have"
else|:
literal|"Haven't"
argument_list|,
name|scb
operator|->
name|ccb
operator|->
name|csio
operator|.
name|dxfer_len
argument_list|,
name|scb
operator|->
name|sg_count
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|scb
operator|->
name|sg_count
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
name|printf
argument_list|(
literal|"sg[%d] - Addr 0x%x : Length %d\n"
argument_list|,
name|i
argument_list|,
name|scb
operator|->
name|ahc_dma
index|[
name|i
index|]
operator|.
name|addr
argument_list|,
name|scb
operator|->
name|ahc_dma
index|[
name|i
index|]
operator|.
name|len
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Set this and it will take affect when the 		 * target does a command complete. 		 */
name|ahc_freeze_devq
argument_list|(
name|ahc
argument_list|,
name|scb
operator|->
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|)
expr_stmt|;
name|ahc_set_ccb_status
argument_list|(
name|scb
operator|->
name|ccb
argument_list|,
name|CAM_DATA_RUN_ERR
argument_list|)
expr_stmt|;
name|ahc_freeze_ccb
argument_list|(
name|scb
operator|->
name|ccb
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|TRACEPOINT
case|:
block|{
name|printf
argument_list|(
literal|"TRACEPOINT: RETURN_2 = %d\n"
argument_list|,
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|RETURN_2
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|printf("SSTAT1 == 0x%x\n", ahc_inb(ahc, SSTAT1)); 		printf("SSTAT0 == 0x%x\n", ahc_inb(ahc, SSTAT0)); 		printf(", SCSISIGI == 0x%x\n", ahc_inb(ahc, SCSISIGI)); 		printf("TRACEPOINT: CCHCNT = %d, SG_COUNT = %d\n", 		       ahc_inb(ahc, CCHCNT), ahc_inb(ahc, SG_COUNT)); 		printf("TRACEPOINT: SCB_TAG = %d\n", ahc_inb(ahc, SCB_TAG)); 		printf("TRACEPOINT1: CCHADDR = %d, CCHCNT = %d, SCBPTR = %d\n", 		       ahc_inb(ahc, CCHADDR) 		    | (ahc_inb(ahc, CCHADDR+1)<< 8) 		    | (ahc_inb(ahc, CCHADDR+2)<< 16) 		    | (ahc_inb(ahc, CCHADDR+3)<< 24), 		       ahc_inb(ahc, CCHCNT) 		    | (ahc_inb(ahc, CCHCNT+1)<< 8) 		    | (ahc_inb(ahc, CCHCNT+2)<< 16), 		       ahc_inb(ahc, SCBPTR)); 		printf("TRACEPOINT: WAITING_SCBH = %d\n", ahc_inb(ahc, WAITING_SCBH)); 		printf("TRACEPOINT: SCB_TAG = %d\n", ahc_inb(ahc, SCB_TAG));
endif|#
directive|endif
break|break;
block|}
if|#
directive|if
name|NOT_YET
comment|/* XXX Fill these in later */
case|case
name|MESG_BUFFER_BUSY
case|:
break|break;
case|case
name|MSGIN_PHASEMIS
case|:
break|break;
endif|#
directive|endif
default|default:
name|printf
argument_list|(
literal|"ahc_intr: seqint, "
literal|"intstat == 0x%x, scsisigi = 0x%x\n"
argument_list|,
name|intstat
argument_list|,
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCSISIGI
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|unpause
label|:
comment|/* 	 *  The sequencer is paused immediately on 	 *  a SEQINT, so we should restart it when 	 *  we're done. 	 */
name|unpause_sequencer
argument_list|(
name|ahc
argument_list|,
comment|/*unpause_always*/
name|TRUE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ahc_handle_scsiint
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|u_int
name|intstat
parameter_list|)
block|{
name|u_int
name|scb_index
decl_stmt|;
name|u_int
name|status
decl_stmt|;
name|struct
name|scb
modifier|*
name|scb
decl_stmt|;
name|scb_index
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCB_TAG
argument_list|)
expr_stmt|;
name|status
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SSTAT1
argument_list|)
expr_stmt|;
if|if
condition|(
name|scb_index
operator|<
name|ahc
operator|->
name|scb_data
operator|->
name|numscbs
condition|)
block|{
name|scb
operator|=
name|ahc
operator|->
name|scb_data
operator|->
name|scbarray
index|[
name|scb_index
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|scb
operator|->
name|flags
operator|&
name|SCB_ACTIVE
operator|)
operator|==
literal|0
condition|)
name|scb
operator|=
name|NULL
expr_stmt|;
block|}
else|else
name|scb
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|status
operator|&
name|SCSIRSTI
operator|)
operator|!=
literal|0
condition|)
block|{
name|char
name|channel
decl_stmt|;
name|channel
operator|=
literal|'A'
expr_stmt|;
if|if
condition|(
operator|(
name|ahc
operator|->
name|features
operator|&
name|AHC_TWIN
operator|)
operator|!=
literal|0
operator|&&
operator|(
operator|(
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SBLKCTL
argument_list|)
operator|&
name|SELBUSB
operator|)
operator|!=
literal|0
operator|)
condition|)
name|channel
operator|=
literal|'B'
expr_stmt|;
name|printf
argument_list|(
literal|"%s: Someone reset channel %c\n"
argument_list|,
name|ahc_name
argument_list|(
name|ahc
argument_list|)
argument_list|,
name|channel
argument_list|)
expr_stmt|;
name|ahc_reset_channel
argument_list|(
name|ahc
argument_list|,
name|channel
argument_list|,
comment|/* Initiate Reset */
name|FALSE
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|status
operator|&
name|BUSFREE
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|status
operator|&
name|SELTO
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 		 * First look at what phase we were last in. 		 * If its message out, chances are pretty good 		 * that the busfree was in response to one of 		 * our abort requests. 		 */
name|u_int
name|lastphase
init|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|LASTPHASE
argument_list|)
decl_stmt|;
name|u_int
name|saved_tcl
init|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SAVED_TCL
argument_list|)
decl_stmt|;
name|u_int
name|target
init|=
operator|(
name|saved_tcl
operator|>>
literal|4
operator|)
operator|&
literal|0x0f
decl_stmt|;
name|char
name|channel
init|=
name|saved_tcl
operator|&
name|SELBUSB
condition|?
literal|'B'
else|:
literal|'A'
decl_stmt|;
name|int
name|printerror
init|=
literal|1
decl_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCSISEQ
argument_list|,
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCSISEQ
argument_list|)
operator|&
operator|(
name|ENSELI
operator||
name|ENRSELI
operator||
name|ENAUTOATNP
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|lastphase
operator|==
name|P_MESGOUT
condition|)
block|{
name|u_int
name|message
decl_stmt|;
name|u_int
name|tag
decl_stmt|;
name|message
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SINDEX
argument_list|)
expr_stmt|;
name|tag
operator|=
name|SCB_LIST_NULL
expr_stmt|;
switch|switch
condition|(
name|message
condition|)
block|{
case|case
name|MSG_ABORT_TAG
case|:
name|tag
operator|=
name|scb
operator|->
name|hscb
operator|->
name|tag
expr_stmt|;
comment|/* FALLTRHOUGH */
case|case
name|MSG_ABORT
case|:
name|xpt_print_path
argument_list|(
name|scb
operator|->
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"SCB %d - Abort %s Completed.\n"
argument_list|,
name|scb
operator|->
name|hscb
operator|->
name|tag
argument_list|,
name|tag
operator|==
name|SCB_LIST_NULL
condition|?
literal|""
else|:
literal|"Tag"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|scb
operator|->
name|flags
operator|&
name|SCB_RECOVERY_SCB
operator|)
operator|!=
literal|0
condition|)
block|{
name|ahc_set_ccb_status
argument_list|(
name|scb
operator|->
name|ccb
argument_list|,
name|CAM_REQ_ABORTED
argument_list|)
expr_stmt|;
name|ahc_done
argument_list|(
name|ahc
argument_list|,
name|scb
argument_list|)
expr_stmt|;
block|}
name|printerror
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|MSG_BUS_DEV_RESET
case|:
name|ahc_handle_devreset
argument_list|(
name|ahc
argument_list|,
name|target
argument_list|,
name|channel
argument_list|,
name|CAM_BDR_SENT
argument_list|,
name|AC_SENT_BDR
argument_list|,
literal|"Bus Device Reset"
argument_list|,
comment|/*verbose_only*/
name|FALSE
argument_list|)
expr_stmt|;
name|printerror
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
if|if
condition|(
name|printerror
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|scb
operator|!=
name|NULL
condition|)
block|{
name|u_int
name|tag
decl_stmt|;
if|if
condition|(
operator|(
name|scb
operator|->
name|hscb
operator|->
name|control
operator|&
name|TAG_ENB
operator|)
operator|!=
literal|0
condition|)
name|tag
operator|=
name|scb
operator|->
name|hscb
operator|->
name|tag
expr_stmt|;
else|else
name|tag
operator|=
name|SCB_LIST_NULL
expr_stmt|;
name|ahc_abort_scbs
argument_list|(
name|ahc
argument_list|,
name|target
argument_list|,
name|channel
argument_list|,
name|SCB_LUN
argument_list|(
name|scb
argument_list|)
argument_list|,
name|tag
argument_list|,
name|CAM_UNEXP_BUSFREE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ahc_abort_scbs
argument_list|(
name|ahc
argument_list|,
name|target
argument_list|,
name|channel
argument_list|,
name|ALL_LUNS
argument_list|,
name|SCB_LIST_NULL
argument_list|,
name|CAM_UNEXP_BUSFREE
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s: "
argument_list|,
name|ahc_name
argument_list|(
name|ahc
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"Unexpected busfree.  LASTPHASE == 0x%x\n"
literal|"SEQADDR == 0x%x\n"
argument_list|,
name|lastphase
argument_list|,
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SEQADDR0
argument_list|)
operator||
operator|(
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SEQADDR1
argument_list|)
operator|<<
literal|8
operator|)
argument_list|)
expr_stmt|;
block|}
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|MSG_OUT
argument_list|,
name|MSG_NOOP
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SIMODE1
argument_list|,
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SIMODE1
argument_list|)
operator|&
operator|~
operator|(
name|ENBUSFREE
operator||
name|ENREQINIT
operator|)
argument_list|)
expr_stmt|;
name|ahc
operator|->
name|flags
operator|&=
operator|~
name|AHC_HANDLING_REQINITS
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|CLRSINT1
argument_list|,
name|CLRBUSFREE
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|CLRINT
argument_list|,
name|CLRSCSIINT
argument_list|)
expr_stmt|;
name|restart_sequencer
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|status
operator|&
name|SELTO
operator|)
operator|!=
literal|0
condition|)
block|{
name|u_int
name|scbptr
decl_stmt|;
name|scbptr
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|WAITING_SCBH
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCBPTR
argument_list|,
name|scbptr
argument_list|)
expr_stmt|;
name|scb_index
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCB_TAG
argument_list|)
expr_stmt|;
if|if
condition|(
name|scb_index
operator|<
name|ahc
operator|->
name|scb_data
operator|->
name|numscbs
condition|)
block|{
name|scb
operator|=
name|ahc
operator|->
name|scb_data
operator|->
name|scbarray
index|[
name|scb_index
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|scb
operator|->
name|flags
operator|&
name|SCB_ACTIVE
operator|)
operator|==
literal|0
condition|)
name|scb
operator|=
name|NULL
expr_stmt|;
block|}
else|else
name|scb
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|scb
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"%s: ahc_intr - referenced scb not "
literal|"valid during SELTO scb(%d, %d)\n"
argument_list|,
name|ahc_name
argument_list|(
name|ahc
argument_list|)
argument_list|,
name|scbptr
argument_list|,
name|scb_index
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * Clear any pending messages for the timed out 			 * target. 			 */
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|MSG_OUT
argument_list|,
name|MSG_NOOP
argument_list|)
expr_stmt|;
name|ahc_handle_devreset
argument_list|(
name|ahc
argument_list|,
name|SCB_TARGET
argument_list|(
name|scb
argument_list|)
argument_list|,
name|SCB_CHANNEL
argument_list|(
name|scb
argument_list|)
argument_list|,
name|CAM_SEL_TIMEOUT
argument_list|,
comment|/*ac_code*/
literal|0
argument_list|,
literal|"Selection Timeout"
argument_list|,
comment|/*verbose_only*/
name|TRUE
argument_list|)
expr_stmt|;
block|}
comment|/* Stop the selection */
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCSISEQ
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SIMODE1
argument_list|,
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SIMODE1
argument_list|)
operator|&
operator|~
name|ENREQINIT
argument_list|)
expr_stmt|;
name|ahc
operator|->
name|flags
operator|&=
operator|~
name|AHC_HANDLING_REQINITS
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|CLRSINT1
argument_list|,
name|CLRSELTIMEO
operator||
name|CLRBUSFREE
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|CLRINT
argument_list|,
name|CLRSCSIINT
argument_list|)
expr_stmt|;
name|restart_sequencer
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|scb
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"%s: ahc_intr - referenced scb not "
literal|"valid during scsiint 0x%x scb(%d)\n"
literal|"SIMODE0 = 0x%x, SIMODE1 = 0x%x, SSTAT0 = 0x%x\n"
literal|"SEQADDR = 0x%x\n"
argument_list|,
name|ahc_name
argument_list|(
name|ahc
argument_list|)
argument_list|,
name|status
argument_list|,
name|scb_index
argument_list|,
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SIMODE0
argument_list|)
argument_list|,
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SIMODE1
argument_list|)
argument_list|,
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SSTAT0
argument_list|)
argument_list|,
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SEQADDR0
argument_list|)
operator||
operator|(
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SEQADDR1
argument_list|)
operator|<<
literal|8
operator|)
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|CLRSINT1
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|CLRINT
argument_list|,
name|CLRSCSIINT
argument_list|)
expr_stmt|;
name|unpause_sequencer
argument_list|(
name|ahc
argument_list|,
comment|/*unpause_always*/
name|TRUE
argument_list|)
expr_stmt|;
name|scb
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|status
operator|&
name|SCSIPERR
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * Determine the bus phase and 		 * queue an appropriate message 		 */
name|char
modifier|*
name|phase
decl_stmt|;
name|u_int
name|mesg_out
init|=
name|MSG_NOOP
decl_stmt|;
name|u_int
name|lastphase
init|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|LASTPHASE
argument_list|)
decl_stmt|;
name|xpt_print_path
argument_list|(
name|scb
operator|->
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|lastphase
condition|)
block|{
case|case
name|P_DATAOUT
case|:
name|phase
operator|=
literal|"Data-Out"
expr_stmt|;
break|break;
case|case
name|P_DATAIN
case|:
name|phase
operator|=
literal|"Data-In"
expr_stmt|;
name|mesg_out
operator|=
name|MSG_INITIATOR_DET_ERR
expr_stmt|;
break|break;
case|case
name|P_COMMAND
case|:
name|phase
operator|=
literal|"Command"
expr_stmt|;
break|break;
case|case
name|P_MESGOUT
case|:
name|phase
operator|=
literal|"Message-Out"
expr_stmt|;
break|break;
case|case
name|P_STATUS
case|:
name|phase
operator|=
literal|"Status"
expr_stmt|;
name|mesg_out
operator|=
name|MSG_INITIATOR_DET_ERR
expr_stmt|;
break|break;
case|case
name|P_MESGIN
case|:
name|phase
operator|=
literal|"Message-In"
expr_stmt|;
name|mesg_out
operator|=
name|MSG_PARITY_ERROR
expr_stmt|;
break|break;
default|default:
name|phase
operator|=
literal|"unknown"
expr_stmt|;
break|break;
block|}
name|printf
argument_list|(
literal|"parity error during %s phase.\n"
argument_list|,
name|phase
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"SEQADDR == 0x%x\n"
argument_list|,
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SEQADDR0
argument_list|)
operator||
operator|(
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SEQADDR1
argument_list|)
operator|<<
literal|8
operator|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"SCSIRATE == 0x%x\n"
argument_list|,
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCSIRATE
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 		 * We've set the hardware to assert ATN if we    		 * get a parity error on "in" phases, so all we   		 * need to do is stuff the message buffer with 		 * the appropriate message.  "In" phases have set 		 * mesg_out to something other than MSG_NOP. 		 */
if|if
condition|(
name|mesg_out
operator|!=
name|MSG_NOOP
condition|)
block|{
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|MSG_OUT
argument_list|,
name|mesg_out
argument_list|)
expr_stmt|;
block|}
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|CLRSINT1
argument_list|,
name|CLRSCSIPERR
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|CLRINT
argument_list|,
name|CLRSCSIINT
argument_list|)
expr_stmt|;
name|unpause_sequencer
argument_list|(
name|ahc
argument_list|,
comment|/*unpause_always*/
name|TRUE
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|status
operator|&
name|REQINIT
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|ahc
operator|->
name|flags
operator|&
name|AHC_HANDLING_REQINITS
operator|)
operator|!=
literal|0
condition|)
block|{
name|ahc_handle_reqinit
argument_list|(
name|ahc
argument_list|,
name|scb
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|xpt_print_path
argument_list|(
name|scb
operator|->
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Unknown SCSIINT. Status = 0x%x\n"
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|CLRSINT1
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|CLRINT
argument_list|,
name|CLRSCSIINT
argument_list|)
expr_stmt|;
name|unpause_sequencer
argument_list|(
name|ahc
argument_list|,
comment|/*unpause_always*/
name|TRUE
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ahc_handle_reqinit
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|struct
name|scb
modifier|*
name|scb
parameter_list|)
block|{
name|struct
name|ahc_devinfo
name|devinfo
decl_stmt|;
name|u_int
name|simode1
decl_stmt|;
name|ahc_fetch_devinfo
argument_list|(
name|ahc
argument_list|,
operator|&
name|devinfo
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ahc
operator|->
name|msg_type
condition|)
block|{
case|case
name|MSG_TYPE_INITIATOR_MSGOUT
case|:
block|{
name|int
name|lastbyte
decl_stmt|;
name|int
name|phasemis
decl_stmt|;
name|u_int
name|bus_phase
decl_stmt|;
if|if
condition|(
name|ahc
operator|->
name|msg_len
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"REQINIT interrupt with no active message"
argument_list|)
expr_stmt|;
name|lastbyte
operator|=
operator|(
name|ahc
operator|->
name|msg_index
operator|==
name|ahc
operator|->
name|msg_len
operator|-
literal|1
operator|)
expr_stmt|;
name|bus_phase
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCSISIGI
argument_list|)
operator|&
name|PHASE_MASK
expr_stmt|;
name|phasemis
operator|=
name|bus_phase
operator|!=
name|P_MESGOUT
expr_stmt|;
if|if
condition|(
name|lastbyte
operator|||
name|phasemis
condition|)
block|{
comment|/* Time to end our message session */
name|ahc
operator|->
name|msg_len
operator|=
literal|0
expr_stmt|;
name|ahc
operator|->
name|msg_type
operator|=
name|MSG_TYPE_NONE
expr_stmt|;
name|simode1
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SIMODE1
argument_list|)
operator|&
operator|~
name|ENREQINIT
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SIMODE1
argument_list|,
name|simode1
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|CLRINT
argument_list|,
name|CLRSCSIINT
argument_list|)
expr_stmt|;
name|ahc
operator|->
name|flags
operator|&=
operator|~
name|AHC_HANDLING_REQINITS
expr_stmt|;
if|if
condition|(
name|phasemis
operator|==
literal|0
condition|)
block|{
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SINDEX
argument_list|,
name|ahc
operator|->
name|msg_buf
index|[
name|ahc
operator|->
name|msg_index
index|]
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|RETURN_1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|RETURN_1
argument_list|,
name|MSGOUT_PHASEMIS
argument_list|)
expr_stmt|;
block|}
name|unpause_sequencer
argument_list|(
name|ahc
argument_list|,
comment|/* unpause_always */
name|TRUE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * Clear our interrupt status and present the byte 			 * on the bus, but don't unpause the sequencer. 			 */
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|CLRSINT1
argument_list|,
name|CLRREQINIT
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|CLRINT
argument_list|,
name|CLRSCSIINT
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCSIDATL
argument_list|,
name|ahc
operator|->
name|msg_buf
index|[
name|ahc
operator|->
name|msg_index
operator|++
index|]
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|MSG_TYPE_INITIATOR_MSGIN
case|:
block|{
name|int
name|phasemis
decl_stmt|;
name|int
name|done
decl_stmt|;
name|phasemis
operator|=
operator|(
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCSISIGI
argument_list|)
operator|&
name|PHASE_MASK
operator|)
operator|!=
name|P_MESGIN
expr_stmt|;
if|if
condition|(
name|phasemis
operator|==
literal|0
condition|)
block|{
name|ahc
operator|->
name|msg_len
operator|++
expr_stmt|;
comment|/* Pull the byte in without acking it */
name|ahc
operator|->
name|msg_buf
index|[
name|ahc
operator|->
name|msg_index
index|]
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCSIBUSL
argument_list|)
expr_stmt|;
name|done
operator|=
name|ahc_parse_msg
argument_list|(
name|ahc
argument_list|,
name|scb
argument_list|,
operator|&
name|devinfo
argument_list|)
expr_stmt|;
comment|/* Ack the byte */
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|CLRSINT1
argument_list|,
name|CLRREQINIT
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|CLRINT
argument_list|,
name|CLRSCSIINT
argument_list|)
expr_stmt|;
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCSIDATL
argument_list|)
expr_stmt|;
name|ahc
operator|->
name|msg_index
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|phasemis
operator|||
name|done
condition|)
block|{
comment|/* Time to end our message session */
name|ahc
operator|->
name|msg_len
operator|=
literal|0
expr_stmt|;
name|ahc
operator|->
name|msg_type
operator|=
name|MSG_TYPE_NONE
expr_stmt|;
name|simode1
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SIMODE1
argument_list|)
operator|&
operator|~
name|ENREQINIT
expr_stmt|;
name|ahc
operator|->
name|flags
operator|&=
operator|~
name|AHC_HANDLING_REQINITS
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SIMODE1
argument_list|,
name|simode1
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|CLRINT
argument_list|,
name|CLRSCSIINT
argument_list|)
expr_stmt|;
name|unpause_sequencer
argument_list|(
name|ahc
argument_list|,
comment|/* unpause_always */
name|TRUE
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
default|default:
name|panic
argument_list|(
literal|"Unknown REQINIT message type"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|ahc_parse_msg
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|struct
name|scb
modifier|*
name|scb
parameter_list|,
name|struct
name|ahc_devinfo
modifier|*
name|devinfo
parameter_list|)
block|{
name|int
name|reject
decl_stmt|;
name|int
name|done
decl_stmt|;
name|u_int
name|targ_scsirate
decl_stmt|;
name|done
operator|=
name|FALSE
expr_stmt|;
name|reject
operator|=
name|FALSE
expr_stmt|;
name|targ_scsirate
operator|=
name|ahc
operator|->
name|transinfo
index|[
name|devinfo
operator|->
name|target_offset
index|]
operator|.
name|scsirate
expr_stmt|;
comment|/* 	 * Parse as much of the message as is availible, 	 * rejecting it if we don't support it.  When 	 * the entire message is availible and has been 	 * handled, return TRUE indicating that we have 	 * parsed an entire message. 	 */
if|if
condition|(
name|ahc
operator|->
name|msg_buf
index|[
literal|0
index|]
operator|!=
name|MSG_EXTENDED
condition|)
block|{
name|reject
operator|=
name|TRUE
expr_stmt|;
block|}
comment|/* 	 * Just accept the length byte outright and perform 	 * more checking once we know the message type. 	 */
if|if
condition|(
operator|!
name|reject
operator|&&
operator|(
name|ahc
operator|->
name|msg_len
operator|>
literal|2
operator|)
condition|)
block|{
switch|switch
condition|(
name|ahc
operator|->
name|msg_buf
index|[
literal|2
index|]
condition|)
block|{
case|case
name|MSG_EXT_SDTR
case|:
block|{
name|struct
name|ahc_syncrate
modifier|*
name|syncrate
decl_stmt|;
name|u_int
name|period
decl_stmt|;
name|u_int
name|offset
decl_stmt|;
name|u_int
name|saved_offset
decl_stmt|;
name|u_int
name|maxsync
decl_stmt|;
if|if
condition|(
name|ahc
operator|->
name|msg_buf
index|[
literal|1
index|]
operator|!=
name|MSG_EXT_SDTR_LEN
condition|)
block|{
name|reject
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
comment|/* 			 * Wait until we have both args before validating 			 * and acting on this message. 			 */
if|if
condition|(
name|ahc
operator|->
name|msg_len
operator|<
operator|(
name|MSG_EXT_SDTR_LEN
operator|+
comment|/*preamble*/
literal|2
operator|)
condition|)
break|break;
name|period
operator|=
name|ahc
operator|->
name|msg_buf
index|[
literal|3
index|]
expr_stmt|;
name|saved_offset
operator|=
name|offset
operator|=
name|ahc
operator|->
name|msg_buf
index|[
literal|4
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|ahc
operator|->
name|features
operator|&
name|AHC_ULTRA2
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SBLKCTL
argument_list|)
operator|&
name|ENAB40
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SSTAT2
argument_list|)
operator|&
name|EXP_ACTIVE
operator|)
operator|==
literal|0
condition|)
block|{
name|maxsync
operator|=
name|AHC_SYNCRATE_ULTRA2
expr_stmt|;
block|}
else|else
block|{
name|maxsync
operator|=
name|AHC_SYNCRATE_ULTRA
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|ahc
operator|->
name|features
operator|&
name|AHC_ULTRA
operator|)
operator|!=
literal|0
condition|)
block|{
name|maxsync
operator|=
name|AHC_SYNCRATE_ULTRA
expr_stmt|;
block|}
else|else
block|{
name|maxsync
operator|=
name|AHC_SYNCRATE_FAST
expr_stmt|;
block|}
name|syncrate
operator|=
name|ahc_find_syncrate
argument_list|(
name|ahc
argument_list|,
operator|&
name|period
argument_list|,
name|maxsync
argument_list|)
expr_stmt|;
name|ahc_validate_offset
argument_list|(
name|ahc
argument_list|,
name|syncrate
argument_list|,
operator|&
name|offset
argument_list|,
name|targ_scsirate
operator|&
name|WIDEXFER
argument_list|)
expr_stmt|;
name|ahc_set_syncrate
argument_list|(
name|ahc
argument_list|,
name|devinfo
argument_list|,
name|scb
operator|->
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
name|syncrate
argument_list|,
name|period
argument_list|,
name|offset
argument_list|,
name|AHC_TRANS_ACTIVE
operator||
name|AHC_TRANS_GOAL
argument_list|)
expr_stmt|;
comment|/* 			 * See if we initiated Sync Negotiation 			 * and didn't have to fall down to async 			 * transfers. 			 */
if|if
condition|(
operator|(
name|scb
operator|->
name|flags
operator|&
operator|(
name|SCB_MSGOUT_SDTR
operator||
name|SCB_MSGOUT_SENT
operator|)
operator|)
operator|==
operator|(
name|SCB_MSGOUT_SDTR
operator||
name|SCB_MSGOUT_SENT
operator|)
condition|)
block|{
comment|/* We started it */
if|if
condition|(
name|saved_offset
operator|!=
name|offset
condition|)
block|{
comment|/* Went too low - force async */
name|reject
operator|=
name|TRUE
expr_stmt|;
block|}
name|scb
operator|->
name|flags
operator|&=
operator|~
name|SCB_MSGOUT_BITS
expr_stmt|;
name|ahc
operator|->
name|sdtrpending
operator|&=
operator|~
name|devinfo
operator|->
name|target_mask
expr_stmt|;
block|}
else|else
block|{
comment|/* 				 * Send our own SDTR in reply 				 */
name|scb
operator|->
name|flags
operator|&=
operator|~
name|SCB_MSGOUT_BITS
expr_stmt|;
name|scb
operator|->
name|flags
operator||=
name|SCB_MSGOUT_SDTR
expr_stmt|;
name|ahc
operator|->
name|sdtrpending
operator||=
name|devinfo
operator|->
name|target_mask
expr_stmt|;
name|xpt_print_path
argument_list|(
name|scb
operator|->
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Sending SDTR!!\n"
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|MSG_OUT
argument_list|,
name|HOST_MSG
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCSISIGO
argument_list|,
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCSISIGO
argument_list|)
operator||
name|ATNO
argument_list|)
expr_stmt|;
block|}
name|done
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
case|case
name|MSG_EXT_WDTR
case|:
block|{
name|struct
name|ccb_trans_settings
name|neg
decl_stmt|;
name|u_int
name|bus_width
decl_stmt|;
if|if
condition|(
name|ahc
operator|->
name|msg_buf
index|[
literal|1
index|]
operator|!=
name|MSG_EXT_WDTR_LEN
condition|)
block|{
name|reject
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
comment|/* 			 * Wait until we have our arg before validating 			 * and acting on this message. 			 */
if|if
condition|(
name|ahc
operator|->
name|msg_len
operator|<
operator|(
name|MSG_EXT_WDTR_LEN
operator|+
comment|/*preamble*/
literal|2
operator|)
condition|)
break|break;
name|bus_width
operator|=
name|ahc
operator|->
name|msg_buf
index|[
literal|3
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|scb
operator|->
name|flags
operator|&
operator|(
name|SCB_MSGOUT_WDTR
operator||
name|SCB_MSGOUT_SENT
operator|)
operator|)
operator|==
operator|(
name|SCB_MSGOUT_WDTR
operator||
name|SCB_MSGOUT_SENT
operator|)
condition|)
block|{
comment|/* 				 * Don't send a WDTR back to the 				 * target, since we asked first. 				 */
switch|switch
condition|(
name|bus_width
condition|)
block|{
default|default:
comment|/* 					 * How can we do anything greater 					 * than 16bit transfers on a 16bit 					 * bus? 					 */
name|reject
operator|=
name|TRUE
expr_stmt|;
name|printf
argument_list|(
literal|"%s: target %d requested %dBit "
literal|"transfers.  Rejecting...\n"
argument_list|,
name|ahc_name
argument_list|(
name|ahc
argument_list|)
argument_list|,
name|devinfo
operator|->
name|target
argument_list|,
literal|8
operator|*
operator|(
literal|0x01
operator|<<
name|bus_width
operator|)
argument_list|)
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
name|MSG_EXT_WDTR_BUS_8_BIT
case|:
name|bus_width
operator|=
name|MSG_EXT_WDTR_BUS_8_BIT
expr_stmt|;
break|break;
case|case
name|MSG_EXT_WDTR_BUS_16_BIT
case|:
break|break;
block|}
name|scb
operator|->
name|flags
operator|&=
operator|~
name|SCB_MSGOUT_WDTR
expr_stmt|;
name|ahc
operator|->
name|wdtrpending
operator|&=
operator|~
name|devinfo
operator|->
name|target_mask
expr_stmt|;
block|}
else|else
block|{
comment|/* 				 * Send our own WDTR in reply 				 */
name|printf
argument_list|(
literal|"Sending WDTR!\n"
argument_list|)
expr_stmt|;
name|scb
operator|->
name|flags
operator|&=
operator|~
name|SCB_MSGOUT_BITS
expr_stmt|;
name|scb
operator|->
name|flags
operator||=
name|SCB_MSGOUT_WDTR
expr_stmt|;
switch|switch
condition|(
name|bus_width
condition|)
block|{
default|default:
if|if
condition|(
name|ahc
operator|->
name|features
operator|&
name|AHC_WIDE
condition|)
block|{
comment|/* Respond Wide */
name|bus_width
operator|=
name|MSG_EXT_WDTR_BUS_16_BIT
expr_stmt|;
break|break;
block|}
comment|/* FALLTHROUGH */
case|case
name|MSG_EXT_WDTR_BUS_8_BIT
case|:
name|bus_width
operator|=
name|MSG_EXT_WDTR_BUS_8_BIT
expr_stmt|;
break|break;
block|}
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|MSG_OUT
argument_list|,
name|HOST_MSG
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCSISIGO
argument_list|,
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCSISIGO
argument_list|)
operator||
name|ATNO
argument_list|)
expr_stmt|;
name|ahc
operator|->
name|wdtrpending
operator||=
name|devinfo
operator|->
name|target_mask
expr_stmt|;
block|}
name|ahc_set_width
argument_list|(
name|ahc
argument_list|,
name|devinfo
argument_list|,
name|scb
operator|->
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
name|bus_width
argument_list|,
name|AHC_TRANS_ACTIVE
operator||
name|AHC_TRANS_GOAL
argument_list|)
expr_stmt|;
comment|/* After a wide message, we are async */
name|ahc_set_syncrate
argument_list|(
name|ahc
argument_list|,
name|devinfo
argument_list|,
name|scb
operator|->
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
comment|/*syncrate*/
name|NULL
argument_list|,
comment|/*period*/
literal|0
argument_list|,
comment|/*offset*/
literal|0
argument_list|,
name|AHC_TRANS_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ahc
operator|->
name|wdtrpending
operator|&
name|devinfo
operator|->
name|target_mask
operator|)
operator|==
literal|0
operator|&&
operator|(
name|reject
operator|==
literal|0
operator|)
condition|)
block|{
name|struct
name|ahc_target_tinfo
modifier|*
name|tinfo
decl_stmt|;
name|scb
operator|->
name|flags
operator|&=
operator|~
name|SCB_MSGOUT_WDTR
expr_stmt|;
name|tinfo
operator|=
operator|&
name|ahc
operator|->
name|transinfo
index|[
name|devinfo
operator|->
name|target_offset
index|]
expr_stmt|;
if|if
condition|(
name|tinfo
operator|->
name|goal
operator|.
name|period
condition|)
block|{
comment|/* Start the sync negotiation */
name|ahc
operator|->
name|sdtrpending
operator||=
name|devinfo
operator|->
name|target_mask
expr_stmt|;
name|scb
operator|->
name|flags
operator||=
name|SCB_MSGOUT_SDTR
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|MSG_OUT
argument_list|,
name|HOST_MSG
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCSISIGO
argument_list|,
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCSISIGO
argument_list|)
operator||
name|ATNO
argument_list|)
expr_stmt|;
block|}
block|}
name|done
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
default|default:
comment|/* Unknown extended message.  Reject it. */
name|reject
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|reject
condition|)
block|{
comment|/* 		 * Assert attention and setup to 		 * reject the message. 		 */
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|MSG_OUT
argument_list|,
name|MSG_MESSAGE_REJECT
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCSISIGO
argument_list|,
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCSISIGO
argument_list|)
operator||
name|ATNO
argument_list|)
expr_stmt|;
name|done
operator|=
name|TRUE
expr_stmt|;
block|}
return|return
operator|(
name|done
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ahc_handle_devreset
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|int
name|target
parameter_list|,
name|char
name|channel
parameter_list|,
name|cam_status
name|status
parameter_list|,
name|ac_code
name|acode
parameter_list|,
name|char
modifier|*
name|message
parameter_list|,
name|int
name|verbose_only
parameter_list|)
block|{
name|struct
name|ahc_devinfo
name|devinfo
decl_stmt|;
name|struct
name|cam_path
modifier|*
name|path
decl_stmt|;
name|path_id_t
name|path_id
decl_stmt|;
name|u_int16_t
name|targ_mask
decl_stmt|;
name|int
name|scratch_offset
init|=
name|target
decl_stmt|;
name|int
name|found
decl_stmt|;
name|int
name|error
decl_stmt|;
name|ahc_compile_devinfo
argument_list|(
operator|&
name|devinfo
argument_list|,
name|target
argument_list|,
name|channel
argument_list|)
expr_stmt|;
if|if
condition|(
name|channel
operator|==
literal|'B'
condition|)
name|path_id
operator|=
name|cam_sim_path
argument_list|(
name|ahc
operator|->
name|sim_b
argument_list|)
expr_stmt|;
else|else
name|path_id
operator|=
name|cam_sim_path
argument_list|(
name|ahc
operator|->
name|sim
argument_list|)
expr_stmt|;
name|error
operator|=
name|xpt_create_path
argument_list|(
operator|&
name|path
argument_list|,
comment|/*periph*/
name|NULL
argument_list|,
name|path_id
argument_list|,
name|target
argument_list|,
name|CAM_LUN_WILDCARD
argument_list|)
expr_stmt|;
comment|/* 	 * Go back to async/narrow transfers and renegotiate. 	 */
if|if
condition|(
name|error
operator|==
name|CAM_REQ_CMP
condition|)
block|{
name|ahc_set_width
argument_list|(
name|ahc
argument_list|,
operator|&
name|devinfo
argument_list|,
name|path
argument_list|,
name|MSG_EXT_WDTR_BUS_8_BIT
argument_list|,
name|AHC_TRANS_CUR
argument_list|)
expr_stmt|;
name|ahc_set_syncrate
argument_list|(
name|ahc
argument_list|,
operator|&
name|devinfo
argument_list|,
name|path
argument_list|,
comment|/*syncrate*/
name|NULL
argument_list|,
comment|/*period*/
literal|0
argument_list|,
comment|/*offset*/
literal|0
argument_list|,
name|AHC_TRANS_CUR
argument_list|)
expr_stmt|;
block|}
name|found
operator|=
name|ahc_abort_scbs
argument_list|(
name|ahc
argument_list|,
name|target
argument_list|,
name|channel
argument_list|,
name|ALL_LUNS
argument_list|,
name|SCB_LIST_NULL
argument_list|,
name|status
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|CAM_REQ_CMP
operator|&&
name|acode
operator|!=
literal|0
condition|)
name|xpt_async
argument_list|(
name|AC_SENT_BDR
argument_list|,
name|path
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|CAM_REQ_CMP
condition|)
name|xpt_free_path
argument_list|(
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|message
operator|!=
name|NULL
operator|&&
operator|(
name|verbose_only
operator|==
literal|0
operator|||
name|bootverbose
operator|!=
literal|0
operator|)
condition|)
name|printf
argument_list|(
literal|"%s: %s on %c:%d. %d SCBs aborted\n"
argument_list|,
name|ahc_name
argument_list|(
name|ahc
argument_list|)
argument_list|,
name|message
argument_list|,
name|channel
argument_list|,
name|target
argument_list|,
name|found
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * We have an scb which has been processed by the  * adaptor, now we look to see how the operation  * went.  */
end_comment

begin_function
specifier|static
name|void
name|ahc_done
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|struct
name|scb
modifier|*
name|scb
parameter_list|)
block|{
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|CAM_DEBUG
argument_list|(
name|scb
operator|->
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
name|CAM_DEBUG_TRACE
argument_list|,
operator|(
literal|"ahc_done - scb %d\n"
operator|,
name|scb
operator|->
name|hscb
operator|->
name|tag
operator|)
argument_list|)
expr_stmt|;
name|ccb
operator|=
name|scb
operator|->
name|ccb
expr_stmt|;
name|LIST_REMOVE
argument_list|(
operator|&
name|ccb
operator|->
name|ccb_h
argument_list|,
name|sim_links
operator|.
name|le
argument_list|)
expr_stmt|;
name|untimeout
argument_list|(
name|ahc_timeout
argument_list|,
operator|(
name|caddr_t
operator|)
name|scb
argument_list|,
name|ccb
operator|->
name|ccb_h
operator|.
name|timeout_ch
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DIR_MASK
operator|)
operator|!=
name|CAM_DIR_NONE
condition|)
block|{
name|bus_dmasync_op_t
name|op
decl_stmt|;
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DIR_MASK
operator|)
operator|==
name|CAM_DIR_IN
condition|)
name|op
operator|=
name|BUS_DMASYNC_POSTREAD
expr_stmt|;
else|else
name|op
operator|=
name|BUS_DMASYNC_POSTWRITE
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|ahc
operator|->
name|dmat
argument_list|,
name|scb
operator|->
name|dmamap
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|ahc
operator|->
name|dmat
argument_list|,
name|scb
operator|->
name|dmamap
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Unbusy this target/channel/lun. 	 * XXX if we are holding two commands per lun,  	 *     send the next command. 	 */
name|ahc_index_busy_tcl
argument_list|(
name|ahc
argument_list|,
name|scb
operator|->
name|hscb
operator|->
name|tcl
argument_list|,
comment|/*unbusy*/
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|==
name|XPT_CONT_TARGET_IO
condition|)
block|{
name|xpt_print_path
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"CONT_TARGET_IO complete\n"
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
name|ahc_free_scb
argument_list|(
name|ahc
argument_list|,
name|scb
argument_list|)
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * If the recovery SCB completes, we have to be 	 * out of our timeout. 	 */
if|if
condition|(
operator|(
name|scb
operator|->
name|flags
operator|&
name|SCB_RECOVERY_SCB
operator|)
operator|!=
literal|0
condition|)
block|{
name|struct
name|ccb_hdr
modifier|*
name|ccbh
decl_stmt|;
comment|/* 		 * We were able to complete the command successfully, 		 * so reinstate the timeouts for all other pending 		 * commands. 		 */
name|ccbh
operator|=
name|ahc
operator|->
name|pending_ccbs
operator|.
name|lh_first
expr_stmt|;
while|while
condition|(
name|ccbh
operator|!=
name|NULL
condition|)
block|{
name|struct
name|scb
modifier|*
name|pending_scb
decl_stmt|;
name|pending_scb
operator|=
operator|(
expr|struct
name|scb
operator|*
operator|)
name|ccbh
operator|->
name|ccb_scb_ptr
expr_stmt|;
name|ccbh
operator|->
name|timeout_ch
operator|=
name|timeout
argument_list|(
name|ahc_timeout
argument_list|,
name|pending_scb
argument_list|,
operator|(
name|ccbh
operator|->
name|timeout
operator|*
name|hz
operator|)
operator|/
literal|1000
argument_list|)
expr_stmt|;
name|ccbh
operator|=
name|LIST_NEXT
argument_list|(
name|ccbh
argument_list|,
name|sim_links
operator|.
name|le
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Ensure that we didn't put a second instance of this 		 * SCB into the QINFIFO. 		 */
name|ahc_search_qinfifo
argument_list|(
name|ahc
argument_list|,
name|SCB_TARGET
argument_list|(
name|scb
argument_list|)
argument_list|,
name|SCB_CHANNEL
argument_list|(
name|scb
argument_list|)
argument_list|,
name|SCB_LUN
argument_list|(
name|scb
argument_list|)
argument_list|,
name|scb
operator|->
name|hscb
operator|->
name|tag
argument_list|,
comment|/*status*/
literal|0
argument_list|,
name|SEARCH_REMOVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|ahc_ccb_status
argument_list|(
name|ccb
argument_list|)
operator|==
name|CAM_BDR_SENT
condition|)
name|ahc_set_ccb_status
argument_list|(
name|ccb
argument_list|,
name|CAM_CMD_TIMEOUT
argument_list|)
expr_stmt|;
name|xpt_print_path
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"no longer in timeout, status = %x\n"
argument_list|,
name|ccb
operator|->
name|ccb_h
operator|.
name|status
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|scb
operator|->
name|flags
operator|&
operator|(
name|SCB_MSGOUT_WDTR
operator||
name|SCB_MSGOUT_SDTR
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * Turn off the pending flags for any DTR messages 		 * regardless of whether they completed successfully  		 * or not.  This ensures that we don't have lingering 		 * state after we abort an SCB. 		 */
name|u_int16_t
name|mask
decl_stmt|;
name|mask
operator|=
operator|(
literal|0x01
operator|<<
operator|(
name|SCB_TARGET
argument_list|(
name|scb
argument_list|)
operator||
operator|(
name|SCB_IS_SCSIBUS_B
argument_list|(
name|scb
argument_list|)
condition|?
name|SELBUSB
else|:
literal|0
operator|)
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|scb
operator|->
name|flags
operator|&
name|SCB_MSGOUT_WDTR
condition|)
name|ahc
operator|->
name|wdtrpending
operator|&=
operator|~
name|mask
expr_stmt|;
if|if
condition|(
name|scb
operator|->
name|flags
operator|&
name|SCB_MSGOUT_SDTR
condition|)
name|ahc
operator|->
name|sdtrpending
operator|&=
operator|~
name|mask
expr_stmt|;
block|}
comment|/* Don't clobber any existing error state */
if|if
condition|(
name|ahc_ccb_status
argument_list|(
name|ccb
argument_list|)
operator|==
name|CAM_REQ_INPROG
condition|)
block|{
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_REQ_CMP
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|scb
operator|->
name|flags
operator|&
name|SCB_SENSE
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* We performed autosense retrieval */
name|scb
operator|->
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_AUTOSNS_VALID
expr_stmt|;
block|}
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&=
operator|~
name|CAM_SIM_QUEUED
expr_stmt|;
name|ahc_free_scb
argument_list|(
name|ahc
argument_list|,
name|scb
argument_list|)
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Determine the number of SCBs available on the controller  */
end_comment

begin_function
name|int
name|ahc_probe_scbs
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|AHC_SCB_MAX
condition|;
name|i
operator|++
control|)
block|{
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCBPTR
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCB_CONTROL
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCB_CONTROL
argument_list|)
operator|!=
name|i
condition|)
break|break;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCBPTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCB_CONTROL
argument_list|)
operator|!=
literal|0
condition|)
break|break;
block|}
return|return
operator|(
name|i
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Start the board, ready for normal operation  */
end_comment

begin_function
name|int
name|ahc_init
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|)
block|{
name|int
name|max_targ
init|=
literal|15
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|term
decl_stmt|;
name|u_int
name|scsi_conf
decl_stmt|;
ifdef|#
directive|ifdef
name|AHC_PRINT_SRAM
name|printf
argument_list|(
literal|"Scratch Ram:"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0x20
init|;
name|i
operator|<
literal|0x5f
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
operator|(
name|i
operator|%
literal|8
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|i
operator|!=
literal|0
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"\n              "
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|" 0x%x"
argument_list|,
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|ahc
operator|->
name|features
operator|&
name|AHC_MORE_SRAM
operator|)
operator|!=
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0x70
init|;
name|i
operator|<
literal|0x7f
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
operator|(
name|i
operator|%
literal|8
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|i
operator|!=
literal|0
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"\n              "
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|" 0x%x"
argument_list|,
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Assume we have a board at this stage and it has been reset. 	 */
if|if
condition|(
operator|(
name|ahc
operator|->
name|flags
operator|&
name|AHC_USEDEFAULTS
operator|)
operator|!=
literal|0
condition|)
block|{
name|ahc
operator|->
name|our_id
operator|=
name|ahc
operator|->
name|our_id_b
operator|=
literal|7
expr_stmt|;
block|}
comment|/* 	 * XXX Would be better to use a per device flag, but PCI and EISA 	 *     devices don't have them yet. 	 */
if|if
condition|(
operator|(
name|AHC_TMODE_ENABLE
operator|&
operator|(
literal|0x01
operator|<<
name|ahc
operator|->
name|unit
operator|)
operator|)
operator|!=
literal|0
condition|)
name|ahc
operator|->
name|flags
operator||=
name|AHC_TARGETMODE
expr_stmt|;
if|if
condition|(
operator|(
name|ahc
operator|->
name|features
operator|&
name|AHC_TWIN
operator|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"Twin Channel, A SCSI Id=%d, B SCSI Id=%d, primary %c, "
argument_list|,
name|ahc
operator|->
name|our_id
argument_list|,
name|ahc
operator|->
name|our_id_b
argument_list|,
name|ahc
operator|->
name|flags
operator|&
name|AHC_CHANNEL_B_PRIMARY
condition|?
literal|'B'
else|:
literal|'A'
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|ahc
operator|->
name|features
operator|&
name|AHC_WIDE
operator|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"Wide "
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"Single "
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"Channel %c, SCSI Id=%d, "
argument_list|,
name|ahc
operator|->
name|channel
argument_list|,
name|ahc
operator|->
name|our_id
argument_list|)
expr_stmt|;
block|}
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SEQ_FLAGS
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Determine the number of SCBs and initialize them */
if|if
condition|(
name|ahc
operator|->
name|scb_data
operator|->
name|maxhscbs
operator|==
literal|0
condition|)
block|{
name|ahc
operator|->
name|scb_data
operator|->
name|maxhscbs
operator|=
name|ahc_probe_scbs
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
comment|/* SCB 0 heads the free list */
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|FREE_SCBH
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ahc
operator|->
name|scb_data
operator|->
name|maxhscbs
condition|;
name|i
operator|++
control|)
block|{
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCBPTR
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* Clear the control byte. */
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCB_CONTROL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Set the next pointer */
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCB_NEXT
argument_list|,
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* Make the tag number invalid */
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCB_TAG
argument_list|,
name|SCB_LIST_NULL
argument_list|)
expr_stmt|;
block|}
comment|/* Make that the last SCB terminates the free list */
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCBPTR
argument_list|,
name|i
operator|-
literal|1
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCB_NEXT
argument_list|,
name|SCB_LIST_NULL
argument_list|)
expr_stmt|;
comment|/* Ensure we clear the 0 SCB's control byte. */
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCBPTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCB_CONTROL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ahc
operator|->
name|scb_data
operator|->
name|maxhscbs
operator|=
name|i
expr_stmt|;
block|}
if|if
condition|(
name|ahc
operator|->
name|scb_data
operator|->
name|maxhscbs
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"%s: No SCB space found"
argument_list|,
name|ahc_name
argument_list|(
name|ahc
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ahc
operator|->
name|scb_data
operator|->
name|maxhscbs
operator|<
name|AHC_SCB_MAX
condition|)
block|{
name|ahc
operator|->
name|flags
operator||=
name|AHC_PAGESCBS
expr_stmt|;
name|ahc
operator|->
name|scb_data
operator|->
name|maxscbs
operator|=
name|AHC_SCB_MAX
expr_stmt|;
if|if
condition|(
operator|(
name|ahc
operator|->
name|flags
operator|&
name|AHC_TARGETMODE
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* Steal one slot for TMODE commands */
name|ahc
operator|->
name|scb_data
operator|->
name|maxscbs
operator|--
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"%d/%d SCBs\n"
argument_list|,
name|ahc
operator|->
name|scb_data
operator|->
name|maxhscbs
argument_list|,
name|ahc
operator|->
name|scb_data
operator|->
name|maxscbs
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ahc
operator|->
name|scb_data
operator|->
name|maxscbs
operator|=
name|ahc
operator|->
name|scb_data
operator|->
name|maxhscbs
expr_stmt|;
if|if
condition|(
operator|(
name|ahc
operator|->
name|flags
operator|&
name|AHC_TARGETMODE
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* Steal one slot for TMODE commands */
name|ahc
operator|->
name|scb_data
operator|->
name|maxscbs
operator|--
expr_stmt|;
block|}
name|ahc
operator|->
name|flags
operator|&=
operator|~
name|AHC_PAGESCBS
expr_stmt|;
name|printf
argument_list|(
literal|"%d SCBs\n"
argument_list|,
name|ahc
operator|->
name|scb_data
operator|->
name|maxhscbs
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|AHC_DEBUG
if|if
condition|(
name|ahc_debug
operator|&
name|AHC_SHOWMISC
condition|)
block|{
name|printf
argument_list|(
literal|"%s: hardware scb %d bytes; kernel scb %d bytes; "
literal|"ahc_dma %d bytes\n"
argument_list|,
name|ahc_name
argument_list|(
name|ahc
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|hardware_scb
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|scb
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ahc_dma_seg
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* AHC_DEBUG */
comment|/* Set the SCSI Id, SXFRCTL0, SXFRCTL1, and SIMODE1, for both channels*/
if|if
condition|(
name|ahc
operator|->
name|features
operator|&
name|AHC_TWIN
condition|)
block|{
comment|/* 		 * The device is gated to channel B after a chip reset, 		 * so set those values first 		 */
name|term
operator|=
operator|(
name|ahc
operator|->
name|flags
operator|&
name|AHC_TERM_ENB_B
operator|)
operator|!=
literal|0
condition|?
name|STPWEN
else|:
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|ahc
operator|->
name|features
operator|&
name|AHC_ULTRA2
operator|)
operator|!=
literal|0
condition|)
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCSIID_ULTRA2
argument_list|,
name|ahc
operator|->
name|our_id_b
argument_list|)
expr_stmt|;
else|else
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCSIID
argument_list|,
name|ahc
operator|->
name|our_id_b
argument_list|)
expr_stmt|;
name|scsi_conf
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCSICONF
operator|+
literal|1
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SXFRCTL1
argument_list|,
operator|(
name|scsi_conf
operator|&
operator|(
name|ENSPCHK
operator||
name|STIMESEL
operator|)
operator|)
operator||
name|term
operator||
name|ENSTIMER
operator||
name|ACTNEGEN
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SIMODE1
argument_list|,
name|ENSELTIMO
operator||
name|ENSCSIRST
operator||
name|ENSCSIPERR
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SXFRCTL0
argument_list|,
name|DFON
operator||
name|SPIOEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|scsi_conf
operator|&
name|RESET_SCSI
condition|)
block|{
comment|/* Reset the bus */
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"%s: Resetting Channel B\n"
argument_list|,
name|ahc_name
argument_list|(
name|ahc
argument_list|)
argument_list|)
expr_stmt|;
name|ahc_reset_current_bus
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
block|}
comment|/* Select Channel A */
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SBLKCTL
argument_list|,
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SBLKCTL
argument_list|)
operator|&
operator|~
name|SELBUSB
argument_list|)
expr_stmt|;
block|}
name|term
operator|=
operator|(
name|ahc
operator|->
name|flags
operator|&
name|AHC_TERM_ENB_A
operator|)
operator|!=
literal|0
condition|?
name|STPWEN
else|:
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|ahc
operator|->
name|features
operator|&
name|AHC_ULTRA2
operator|)
operator|!=
literal|0
condition|)
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCSIID_ULTRA2
argument_list|,
name|ahc
operator|->
name|our_id
argument_list|)
expr_stmt|;
else|else
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCSIID
argument_list|,
name|ahc
operator|->
name|our_id
argument_list|)
expr_stmt|;
name|scsi_conf
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCSICONF
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SXFRCTL1
argument_list|,
operator|(
name|scsi_conf
operator|&
operator|(
name|ENSPCHK
operator||
name|STIMESEL
operator|)
operator|)
operator||
name|term
operator||
name|ENSTIMER
operator||
name|ACTNEGEN
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SIMODE1
argument_list|,
name|ENSELTIMO
operator||
name|ENSCSIRST
operator||
name|ENSCSIPERR
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SXFRCTL0
argument_list|,
name|DFON
operator||
name|SPIOEN
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ahc
operator|->
name|features
operator|&
name|AHC_ULTRA2
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* Wait for our transceiver status to settle */
name|i
operator|=
literal|1000000
expr_stmt|;
while|while
condition|(
operator|--
name|i
operator|&&
operator|(
operator|(
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SBLKCTL
argument_list|)
operator|&
operator|(
name|ENAB40
operator||
name|ENAB20
operator|)
operator|)
operator|==
literal|0
operator|)
condition|)
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"%s: Transceiver state never settled\n"
argument_list|,
name|ahc_name
argument_list|(
name|ahc
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|scsi_conf
operator|&
name|RESET_SCSI
condition|)
block|{
comment|/* Reset the bus */
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"%s: Resetting Channel %c\n"
argument_list|,
name|ahc_name
argument_list|(
name|ahc
argument_list|)
argument_list|,
name|ahc
operator|->
name|channel
argument_list|)
expr_stmt|;
name|ahc_reset_current_bus
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Look at the information that board initialization or 	 * the board bios has left us.  In the lower four bits of each 	 * target's scratch space any value other than 0 indicates 	 * that we should initiate synchronous transfers.  If it's zero, 	 * the user or the BIOS has decided to disable synchronous 	 * negotiation to that target so we don't activate the needsdtr 	 * flag. 	 */
name|ahc
operator|->
name|ultraenb
operator|=
literal|0
expr_stmt|;
name|ahc
operator|->
name|tagenable
operator|=
name|ALL_TARGETS
expr_stmt|;
comment|/* Grab the disconnection disable table and invert it for our needs */
if|if
condition|(
name|ahc
operator|->
name|flags
operator|&
name|AHC_USEDEFAULTS
condition|)
block|{
name|printf
argument_list|(
literal|"%s: Host Adapter Bios disabled.  Using default SCSI "
literal|"device parameters\n"
argument_list|,
name|ahc_name
argument_list|(
name|ahc
argument_list|)
argument_list|)
expr_stmt|;
name|ahc
operator|->
name|flags
operator||=
name|AHC_EXTENDED_TRANS_A
operator||
name|AHC_EXTENDED_TRANS_B
operator||
name|AHC_TERM_ENB_A
operator||
name|AHC_TERM_ENB_B
expr_stmt|;
name|ahc
operator|->
name|discenable
operator|=
name|ALL_TARGETS
expr_stmt|;
if|if
condition|(
operator|(
name|ahc
operator|->
name|features
operator|&
name|AHC_ULTRA
operator|)
operator|!=
literal|0
condition|)
name|ahc
operator|->
name|ultraenb
operator|=
literal|0xffff
expr_stmt|;
block|}
else|else
block|{
name|ahc
operator|->
name|discenable
operator|=
operator|~
operator|(
operator|(
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|DISC_DSB
operator|+
literal|1
argument_list|)
operator|<<
literal|8
operator|)
operator||
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|DISC_DSB
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|ahc
operator|->
name|features
operator|&
operator|(
name|AHC_ULTRA
operator||
name|AHC_ULTRA2
operator|)
operator|)
operator|!=
literal|0
condition|)
name|ahc
operator|->
name|ultraenb
operator|=
operator|(
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|ULTRA_ENB
operator|+
literal|1
argument_list|)
operator|<<
literal|8
operator|)
operator||
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|ULTRA_ENB
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|ahc
operator|->
name|features
operator|&
operator|(
name|AHC_WIDE
operator||
name|AHC_TWIN
operator|)
operator|)
operator|==
literal|0
condition|)
name|max_targ
operator|=
literal|7
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|max_targ
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|ahc_target_tinfo
modifier|*
name|transinfo
decl_stmt|;
name|transinfo
operator|=
operator|&
name|ahc
operator|->
name|transinfo
index|[
name|i
index|]
expr_stmt|;
comment|/* Default to async narrow across the board */
name|bzero
argument_list|(
name|transinfo
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|transinfo
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ahc
operator|->
name|flags
operator|&
name|AHC_USEDEFAULTS
condition|)
block|{
if|if
condition|(
operator|(
name|ahc
operator|->
name|features
operator|&
name|AHC_WIDE
operator|)
operator|!=
literal|0
condition|)
name|transinfo
operator|->
name|user
operator|.
name|width
operator|=
name|MSG_EXT_WDTR_BUS_16_BIT
expr_stmt|;
comment|/* 			 * These will be truncated when we determine the 			 * connection type we have with the target. 			 */
name|transinfo
operator|->
name|user
operator|.
name|period
operator|=
name|ahc_syncrates
operator|->
name|period
expr_stmt|;
name|transinfo
operator|->
name|user
operator|.
name|offset
operator|=
operator|~
literal|0
expr_stmt|;
block|}
else|else
block|{
name|u_int
name|scsirate
decl_stmt|;
name|u_int16_t
name|mask
decl_stmt|;
comment|/* Take the settings leftover in scratch RAM. */
name|scsirate
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|TARG_SCSIRATE
operator|+
name|i
argument_list|)
expr_stmt|;
name|mask
operator|=
operator|(
literal|0x01
operator|<<
name|i
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|ahc
operator|->
name|features
operator|&
name|AHC_ULTRA2
operator|)
operator|!=
literal|0
condition|)
block|{
name|u_int
name|offset
decl_stmt|;
if|if
condition|(
operator|(
name|scsirate
operator|&
name|SOFS
operator|)
operator|==
literal|0x0F
condition|)
block|{
comment|/* 					 * Haven't negotiated yet, 					 * so the format is different. 					 */
name|scsirate
operator|=
operator|(
name|scsirate
operator|&
name|SXFR
operator|)
operator|>>
literal|4
operator||
operator|(
name|ahc
operator|->
name|ultraenb
operator|&
name|mask
operator|)
condition|?
literal|0x18
else|:
literal|0x10
operator||
operator|(
name|scsirate
operator|&
name|WIDEXFER
operator|)
expr_stmt|;
name|offset
operator|=
name|MAX_OFFSET_ULTRA2
expr_stmt|;
block|}
else|else
name|offset
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|TARG_OFFSET
operator|+
name|i
argument_list|)
expr_stmt|;
name|ahc_find_period
argument_list|(
name|ahc
argument_list|,
name|scsirate
argument_list|,
name|AHC_SYNCRATE_ULTRA2
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
operator|==
literal|0
condition|)
name|transinfo
operator|->
name|user
operator|.
name|period
operator|=
literal|0
expr_stmt|;
else|else
name|transinfo
operator|->
name|user
operator|.
name|offset
operator|=
operator|~
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|scsirate
operator|&
name|SOFS
operator|)
operator|!=
literal|0
condition|)
block|{
name|transinfo
operator|->
name|user
operator|.
name|period
operator|=
name|ahc_find_period
argument_list|(
name|ahc
argument_list|,
name|scsirate
argument_list|,
operator|(
name|ahc
operator|->
name|ultraenb
operator|&
name|mask
operator|)
condition|?
name|AHC_SYNCRATE_ULTRA
else|:
name|AHC_SYNCRATE_FAST
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|scsirate
operator|&
name|SOFS
operator|)
operator|!=
literal|0
operator|&&
name|transinfo
operator|->
name|user
operator|.
name|period
operator|!=
literal|0
condition|)
block|{
name|transinfo
operator|->
name|user
operator|.
name|offset
operator|=
operator|~
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|scsirate
operator|&
name|WIDEXFER
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|ahc
operator|->
name|features
operator|&
name|AHC_WIDE
operator|)
operator|!=
literal|0
condition|)
block|{
name|transinfo
operator|->
name|user
operator|.
name|width
operator|=
name|MSG_EXT_WDTR_BUS_16_BIT
expr_stmt|;
block|}
block|}
block|}
name|ahc
operator|->
name|sdtrpending
operator|=
literal|0
expr_stmt|;
name|ahc
operator|->
name|wdtrpending
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|AHC_DEBUG
if|if
condition|(
name|ahc_debug
operator|&
name|AHC_SHOWMISC
condition|)
name|printf
argument_list|(
literal|"NEEDSDTR == 0x%x\nNEEDWDTR == 0x%x\n"
literal|"DISCENABLE == 0x%x\nULTRAENB == 0x%x\n"
argument_list|,
name|ahc
operator|->
name|needsdtr_orig
argument_list|,
name|ahc
operator|->
name|needwdtr_orig
argument_list|,
name|ahc
operator|->
name|discenable
argument_list|,
name|ahc
operator|->
name|ultraenb
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Allocate enough "hardware scbs" to handle 	 * the maximum number of concurrent transactions 	 * we can have active.  We have to use contigmalloc 	 * if this array crosses a page boundary since the 	 * sequencer depends on this array being physically 	 * contiguous. 	 */
if|if
condition|(
name|ahc
operator|->
name|scb_data
operator|->
name|hscbs
operator|==
name|NULL
condition|)
block|{
name|size_t
name|array_size
decl_stmt|;
name|array_size
operator|=
name|ahc
operator|->
name|scb_data
operator|->
name|maxscbs
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|hardware_scb
argument_list|)
expr_stmt|;
if|if
condition|(
name|array_size
operator|>
name|PAGE_SIZE
condition|)
block|{
name|ahc
operator|->
name|scb_data
operator|->
name|hscbs
operator|=
operator|(
expr|struct
name|hardware_scb
operator|*
operator|)
name|contigmalloc
argument_list|(
name|array_size
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|,
literal|0ul
argument_list|,
literal|0xffffffff
argument_list|,
name|PAGE_SIZE
argument_list|,
literal|0x10000
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ahc
operator|->
name|scb_data
operator|->
name|hscbs
operator|=
operator|(
expr|struct
name|hardware_scb
operator|*
operator|)
name|malloc
argument_list|(
name|array_size
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ahc
operator|->
name|scb_data
operator|->
name|hscbs
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"%s: unable to allocate hardware SCB array.  "
literal|"Failing attach\n"
argument_list|,
name|ahc_name
argument_list|(
name|ahc
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* At least the control byte of each hscb needs to be zeroed */
name|bzero
argument_list|(
name|ahc
operator|->
name|scb_data
operator|->
name|hscbs
argument_list|,
name|array_size
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|ahc
operator|->
name|flags
operator|&
name|AHC_TARGETMODE
operator|)
operator|!=
literal|0
condition|)
block|{
name|size_t
name|array_size
decl_stmt|;
name|ahc
operator|->
name|num_targetcmds
operator|=
literal|32
expr_stmt|;
name|array_size
operator|=
name|ahc
operator|->
name|num_targetcmds
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|target_cmd
argument_list|)
expr_stmt|;
name|ahc
operator|->
name|targetcmds
operator|=
name|malloc
argument_list|(
name|array_size
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|ahc
operator|->
name|targetcmds
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"%s: unable to allocate targetcmd array.  "
literal|"Failing attach\n"
argument_list|,
name|ahc_name
argument_list|(
name|ahc
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|bzero
argument_list|(
name|ahc
operator|->
name|targetcmds
argument_list|,
name|array_size
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|TMODE_CMDADDR_NEXT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Tell the sequencer where it can find the our arrays in memory. 	 */
block|{
name|u_int32_t
name|physaddr
decl_stmt|;
comment|/* Tell the sequencer where it can find the hscb array. */
name|physaddr
operator|=
name|vtophys
argument_list|(
name|ahc
operator|->
name|scb_data
operator|->
name|hscbs
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|HSCB_ADDR
argument_list|,
name|physaddr
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|HSCB_ADDR
operator|+
literal|1
argument_list|,
operator|(
name|physaddr
operator|>>
literal|8
operator|)
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|HSCB_ADDR
operator|+
literal|2
argument_list|,
operator|(
name|physaddr
operator|>>
literal|16
operator|)
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|HSCB_ADDR
operator|+
literal|3
argument_list|,
operator|(
name|physaddr
operator|>>
literal|24
operator|)
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
name|ahc
operator|->
name|hscb_busaddr
operator|=
name|physaddr
expr_stmt|;
name|physaddr
operator|=
name|vtophys
argument_list|(
name|ahc
operator|->
name|qoutfifo
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCBID_ADDR
argument_list|,
name|physaddr
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCBID_ADDR
operator|+
literal|1
argument_list|,
operator|(
name|physaddr
operator|>>
literal|8
operator|)
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCBID_ADDR
operator|+
literal|2
argument_list|,
operator|(
name|physaddr
operator|>>
literal|16
operator|)
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCBID_ADDR
operator|+
literal|3
argument_list|,
operator|(
name|physaddr
operator|>>
literal|24
operator|)
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ahc
operator|->
name|flags
operator|&
name|AHC_TARGETMODE
operator|)
operator|!=
literal|0
condition|)
block|{
name|physaddr
operator|=
name|vtophys
argument_list|(
name|ahc
operator|->
name|targetcmds
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|TMODE_CMDADDR
argument_list|,
name|physaddr
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|TMODE_CMDADDR
operator|+
literal|1
argument_list|,
operator|(
name|physaddr
operator|>>
literal|8
operator|)
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|TMODE_CMDADDR
operator|+
literal|2
argument_list|,
operator|(
name|physaddr
operator|>>
literal|16
operator|)
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|TMODE_CMDADDR
operator|+
literal|3
argument_list|,
operator|(
name|physaddr
operator|>>
literal|24
operator|)
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|CMDSIZE_TABLE
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|CMDSIZE_TABLE
operator|+
literal|1
argument_list|,
literal|9
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|CMDSIZE_TABLE
operator|+
literal|2
argument_list|,
literal|9
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|CMDSIZE_TABLE
operator|+
literal|3
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|CMDSIZE_TABLE
operator|+
literal|4
argument_list|,
literal|15
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|CMDSIZE_TABLE
operator|+
literal|5
argument_list|,
literal|11
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|CMDSIZE_TABLE
operator|+
literal|6
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|CMDSIZE_TABLE
operator|+
literal|7
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* There are no untagged SCBs active yet. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|ahc
operator|->
name|untagged_scbs
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|ahc
operator|->
name|untagged_scbs
index|[
name|i
index|]
operator|=
name|SCB_LIST_NULL
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|ahc
operator|->
name|qoutfifo
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|ahc
operator|->
name|qoutfifo
index|[
name|i
index|]
operator|=
name|SCB_LIST_NULL
expr_stmt|;
block|}
block|}
comment|/* Our Q FIFOs are empty. */
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|KERNEL_QINPOS
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|QINPOS
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|QOUTPOS
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Use the built in queue management registers 	 * if they are available. 	 */
if|if
condition|(
operator|(
name|ahc
operator|->
name|features
operator|&
name|AHC_QUEUE_REGS
operator|)
operator|!=
literal|0
condition|)
block|{
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|QOFF_CTLSTA
argument_list|,
name|SCB_QSIZE_256
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SDSCB_QOFF
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SNSCB_QOFF
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|HNSCB_QOFF
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* We don't have any waiting selections */
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|WAITING_SCBH
argument_list|,
name|SCB_LIST_NULL
argument_list|)
expr_stmt|;
comment|/* Our disconnection list is empty too */
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|DISCONNECTED_SCBH
argument_list|,
name|SCB_LIST_NULL
argument_list|)
expr_stmt|;
comment|/* Message out buffer starts empty */
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|MSG_OUT
argument_list|,
name|MSG_NOOP
argument_list|)
expr_stmt|;
comment|/* 	 * Load the Sequencer program and Enable the adapter 	 * in "fast" mode.          */
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"%s: Downloading Sequencer Program..."
argument_list|,
name|ahc_name
argument_list|(
name|ahc
argument_list|)
argument_list|)
expr_stmt|;
name|ahc_loadseq
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
comment|/* We have to wait until after any system dumps... */
name|at_shutdown
argument_list|(
name|ahc_shutdown
argument_list|,
name|ahc
argument_list|,
name|SHUTDOWN_FINAL
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ahcminphys
parameter_list|(
name|struct
name|buf
modifier|*
name|bp
parameter_list|)
block|{
comment|/*  * Even though the card can transfer up to 16megs per command  * we are limited by the number of segments in the dma segment  * list that we can hold.  The worst case is that all pages are  * discontinuous physically, hense the "page per segment" limit  * enforced here.  */
if|if
condition|(
name|bp
operator|->
name|b_bcount
operator|>
operator|(
operator|(
name|AHC_NSEG
operator|-
literal|1
operator|)
operator|*
name|PAGE_SIZE
operator|)
condition|)
block|{
name|bp
operator|->
name|b_bcount
operator|=
operator|(
operator|(
name|AHC_NSEG
operator|-
literal|1
operator|)
operator|*
name|PAGE_SIZE
operator|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|cam_status
name|ahc_find_tmode_devs
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|struct
name|cam_sim
modifier|*
name|sim
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|,
name|struct
name|tmode_tstate
modifier|*
modifier|*
name|tstate
parameter_list|,
name|struct
name|tmode_lstate
modifier|*
modifier|*
name|lstate
parameter_list|,
name|int
name|notfound_failure
parameter_list|)
block|{
name|int
name|our_id
decl_stmt|;
comment|/* 	 * If we are not configured for target mode, someone 	 * is really confused to be sending this to us. 	 */
if|if
condition|(
operator|(
name|ahc
operator|->
name|flags
operator|&
name|AHC_TARGETMODE
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|CAM_REQ_INVALID
operator|)
return|;
comment|/* Range check target and lun */
if|if
condition|(
name|cam_sim_bus
argument_list|(
name|sim
argument_list|)
operator|==
literal|0
condition|)
name|our_id
operator|=
name|ahc
operator|->
name|our_id
expr_stmt|;
else|else
name|our_id
operator|=
name|ahc
operator|->
name|our_id_b
expr_stmt|;
if|if
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
operator|>
operator|(
operator|(
name|ahc
operator|->
name|features
operator|&
name|AHC_WIDE
operator|)
condition|?
literal|15
else|:
literal|7
operator|)
operator|||
operator|(
operator|(
name|ahc
operator|->
name|features
operator|&
name|AHC_MULTI_TID
operator|)
operator|==
literal|0
operator|&&
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
operator|!=
name|our_id
operator|)
operator|)
condition|)
return|return
operator|(
name|CAM_TID_INVALID
operator|)
return|;
if|if
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|target_lun
operator|>
literal|8
condition|)
return|return
operator|(
name|CAM_LUN_INVALID
operator|)
return|;
operator|*
name|tstate
operator|=
name|ahc
operator|->
name|enabled_targets
index|[
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
index|]
expr_stmt|;
operator|*
name|lstate
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|*
name|tstate
operator|!=
name|NULL
condition|)
operator|*
name|lstate
operator|=
operator|(
operator|*
name|tstate
operator|)
operator|->
name|enabled_luns
index|[
name|ccb
operator|->
name|ccb_h
operator|.
name|target_lun
index|]
expr_stmt|;
if|if
condition|(
name|notfound_failure
operator|!=
literal|0
operator|&&
operator|*
name|lstate
operator|==
name|NULL
condition|)
return|return
operator|(
name|CAM_PATH_INVALID
operator|)
return|;
return|return
operator|(
name|CAM_REQ_CMP
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ahc_action
parameter_list|(
name|struct
name|cam_sim
modifier|*
name|sim
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
block|{
name|struct
name|ahc_softc
modifier|*
name|ahc
decl_stmt|;
name|struct
name|tmode_lstate
modifier|*
name|lstate
decl_stmt|;
name|int
name|target_id
decl_stmt|;
name|int
name|s
decl_stmt|;
name|CAM_DEBUG
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
name|CAM_DEBUG_TRACE
argument_list|,
operator|(
literal|"ahc_action\n"
operator|)
argument_list|)
expr_stmt|;
name|ahc
operator|=
operator|(
expr|struct
name|ahc_softc
operator|*
operator|)
name|cam_sim_softc
argument_list|(
name|sim
argument_list|)
expr_stmt|;
name|target_id
operator|=
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
expr_stmt|;
switch|switch
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
condition|)
block|{
comment|/* Common cases first */
case|case
name|XPT_ACCEPT_TARGET_IO
case|:
comment|/* Accept Host Target Mode CDB */
case|case
name|XPT_CONT_TARGET_IO
case|:
comment|/* Continue Host Target I/O Connection*/
block|{
name|struct
name|tmode_tstate
modifier|*
name|tstate
decl_stmt|;
name|cam_status
name|status
decl_stmt|;
name|status
operator|=
name|ahc_find_tmode_devs
argument_list|(
name|ahc
argument_list|,
name|sim
argument_list|,
name|ccb
argument_list|,
operator|&
name|tstate
argument_list|,
operator|&
name|lstate
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|status
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|==
name|XPT_ACCEPT_TARGET_IO
condition|)
block|{
name|SLIST_INSERT_HEAD
argument_list|(
operator|&
name|lstate
operator|->
name|accept_tios
argument_list|,
operator|&
name|ccb
operator|->
name|ccb_h
argument_list|,
name|sim_links
operator|.
name|sle
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_INPROG
expr_stmt|;
break|break;
block|}
comment|/* 		 * The target_id represents the target we attempt to 		 * select.  In target mode, this is the initiator of 		 * the original command. 		 */
name|target_id
operator|=
name|ccb
operator|->
name|csio
operator|.
name|init_id
expr_stmt|;
name|xpt_print_path
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Sending a continue TIO\n"
argument_list|)
expr_stmt|;
comment|/* FALLTHROUGH */
block|}
case|case
name|XPT_SCSI_IO
case|:
comment|/* Execute the requested I/O operation */
case|case
name|XPT_RESET_DEV
case|:
comment|/* Bus Device Reset the specified SCSI device */
block|{
name|struct
name|scb
modifier|*
name|scb
decl_stmt|;
name|struct
name|hardware_scb
modifier|*
name|hscb
decl_stmt|;
name|struct
name|ahc_target_tinfo
modifier|*
name|tinfo
decl_stmt|;
name|u_int16_t
name|mask
decl_stmt|;
comment|/* 		 * get an scb to use. 		 */
if|if
condition|(
operator|(
name|scb
operator|=
name|ahc_get_scb
argument_list|(
name|ahc
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|int
name|s
decl_stmt|;
name|s
operator|=
name|splcam
argument_list|()
expr_stmt|;
name|ahc
operator|->
name|flags
operator||=
name|AHC_RESOURCE_SHORTAGE
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|xpt_freeze_simq
argument_list|(
name|ahc
operator|->
name|sim
argument_list|,
comment|/*count*/
literal|1
argument_list|)
expr_stmt|;
name|ahc_set_ccb_status
argument_list|(
name|ccb
argument_list|,
name|CAM_REQUEUE_REQ
argument_list|)
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return;
block|}
name|hscb
operator|=
name|scb
operator|->
name|hscb
expr_stmt|;
name|CAM_DEBUG
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
name|CAM_DEBUG_SUBTRACE
argument_list|,
operator|(
literal|"start scb(%p)\n"
operator|,
name|scb
operator|)
argument_list|)
expr_stmt|;
name|scb
operator|->
name|ccb
operator|=
name|ccb
expr_stmt|;
comment|/* 		 * So we can find the SCB when an abort is requested 		 */
name|ccb
operator|->
name|ccb_h
operator|.
name|ccb_scb_ptr
operator|=
name|scb
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|ccb_ahc_ptr
operator|=
name|ahc
expr_stmt|;
comment|/* 		 * Put all the arguments for the xfer in the scb 		 */
name|hscb
operator|->
name|tcl
operator|=
operator|(
operator|(
name|target_id
operator|<<
literal|4
operator|)
operator|&
literal|0xF0
operator|)
operator||
operator|(
name|SIM_IS_SCSIBUS_B
argument_list|(
name|ahc
argument_list|,
name|sim
argument_list|)
condition|?
name|SELBUSB
else|:
literal|0
operator|)
operator||
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|target_lun
operator|&
literal|0x07
operator|)
expr_stmt|;
name|mask
operator|=
name|SCB_TARGET_MASK
argument_list|(
name|scb
argument_list|)
expr_stmt|;
name|tinfo
operator|=
operator|&
name|ahc
operator|->
name|transinfo
index|[
name|SCB_TARGET_OFFSET
argument_list|(
name|scb
argument_list|)
index|]
expr_stmt|;
name|hscb
operator|->
name|scsirate
operator|=
name|tinfo
operator|->
name|scsirate
expr_stmt|;
name|hscb
operator|->
name|scsioffset
operator|=
name|tinfo
operator|->
name|current
operator|.
name|offset
expr_stmt|;
if|if
condition|(
operator|(
name|ahc
operator|->
name|ultraenb
operator|&
name|mask
operator|)
operator|!=
literal|0
condition|)
name|hscb
operator|->
name|control
operator||=
name|ULTRAENB
expr_stmt|;
if|if
condition|(
operator|(
name|ahc
operator|->
name|discenable
operator|&
name|mask
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DIS_DISCONNECT
operator|)
operator|==
literal|0
condition|)
name|hscb
operator|->
name|control
operator||=
name|DISCENB
expr_stmt|;
if|if
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|==
name|XPT_RESET_DEV
condition|)
block|{
name|hscb
operator|->
name|cmdpointer
operator|=
name|NULL
expr_stmt|;
name|scb
operator|->
name|flags
operator||=
name|SCB_DEVICE_RESET
expr_stmt|;
name|hscb
operator|->
name|control
operator||=
name|MK_MESSAGE
expr_stmt|;
name|ahc_execute_scb
argument_list|(
name|scb
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|==
name|XPT_SCSI_IO
condition|)
block|{
if|if
condition|(
name|tinfo
operator|->
name|current
operator|.
name|width
operator|!=
name|tinfo
operator|->
name|goal
operator|.
name|width
condition|)
block|{
if|if
condition|(
operator|(
name|ahc
operator|->
name|wdtrpending
operator|&
name|mask
operator|)
operator|==
literal|0
condition|)
block|{
name|ahc
operator|->
name|wdtrpending
operator||=
name|mask
expr_stmt|;
name|hscb
operator|->
name|control
operator||=
name|MK_MESSAGE
expr_stmt|;
name|scb
operator|->
name|flags
operator||=
name|SCB_MSGOUT_WDTR
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|tinfo
operator|->
name|current
operator|.
name|period
operator|!=
name|tinfo
operator|->
name|goal
operator|.
name|period
operator|)
operator|&&
operator|(
name|ahc
operator|->
name|sdtrpending
operator|&
name|mask
operator|)
operator|==
literal|0
condition|)
block|{
name|ahc
operator|->
name|sdtrpending
operator||=
name|mask
expr_stmt|;
name|hscb
operator|->
name|control
operator||=
name|MK_MESSAGE
expr_stmt|;
name|scb
operator|->
name|flags
operator||=
name|SCB_MSGOUT_SDTR
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|ahc
operator|->
name|pending_device
operator|==
name|lstate
condition|)
block|{
name|scb
operator|->
name|flags
operator||=
name|SCB_TARGET_IMMEDIATE
expr_stmt|;
name|ahc
operator|->
name|pending_device
operator|=
name|NULL
expr_stmt|;
block|}
name|hscb
operator|->
name|control
operator||=
name|TARGET_SCB
expr_stmt|;
name|hscb
operator|->
name|cmdpointer
operator|=
name|IDENTIFY_SEEN
expr_stmt|;
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_SEND_STATUS
operator|)
operator|!=
literal|0
condition|)
block|{
name|hscb
operator|->
name|cmdpointer
operator||=
name|SPHASE_PENDING
expr_stmt|;
name|hscb
operator|->
name|status
operator|=
name|ccb
operator|->
name|csio
operator|.
name|scsi_status
expr_stmt|;
block|}
comment|/* Overloaded with tag ID */
name|hscb
operator|->
name|cmdlen
operator|=
name|ccb
operator|->
name|csio
operator|.
name|tag_id
expr_stmt|;
comment|/* 				 * Overloaded with our target ID to 				 * use for reselection. 				 */
name|hscb
operator|->
name|next
operator|=
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
expr_stmt|;
block|}
if|if
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_TAG_ACTION_VALID
condition|)
name|hscb
operator|->
name|control
operator||=
name|ccb
operator|->
name|csio
operator|.
name|tag_action
expr_stmt|;
name|ahc_setup_data
argument_list|(
name|ahc
argument_list|,
operator|&
name|ccb
operator|->
name|csio
argument_list|,
name|scb
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|XPT_NOTIFY_ACK
case|:
case|case
name|XPT_IMMED_NOTIFY
case|:
block|{
name|struct
name|tmode_tstate
modifier|*
name|tstate
decl_stmt|;
name|struct
name|tmode_lstate
modifier|*
name|lstate
decl_stmt|;
name|cam_status
name|status
decl_stmt|;
name|status
operator|=
name|ahc_find_tmode_devs
argument_list|(
name|ahc
argument_list|,
name|sim
argument_list|,
name|ccb
argument_list|,
operator|&
name|tstate
argument_list|,
operator|&
name|lstate
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|status
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|==
name|XPT_NOTIFY_ACK
condition|)
block|{
comment|/* Clear notification state */
block|}
name|SLIST_INSERT_HEAD
argument_list|(
operator|&
name|lstate
operator|->
name|immed_notifies
argument_list|,
operator|&
name|ccb
operator|->
name|ccb_h
argument_list|,
name|sim_links
operator|.
name|sle
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_INPROG
expr_stmt|;
break|break;
block|}
case|case
name|XPT_EN_LUN
case|:
comment|/* Enable LUN as a target */
block|{
name|struct
name|tmode_tstate
modifier|*
name|tstate
decl_stmt|;
name|struct
name|tmode_lstate
modifier|*
name|lstate
decl_stmt|;
name|struct
name|ccb_en_lun
modifier|*
name|cel
decl_stmt|;
name|cam_status
name|status
decl_stmt|;
name|int
name|target
decl_stmt|;
name|int
name|lun
decl_stmt|;
name|status
operator|=
name|ahc_find_tmode_devs
argument_list|(
name|ahc
argument_list|,
name|sim
argument_list|,
name|ccb
argument_list|,
operator|&
name|tstate
argument_list|,
operator|&
name|lstate
argument_list|,
comment|/* notfound_failure*/
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|status
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
block|}
name|cel
operator|=
operator|&
name|ccb
operator|->
name|cel
expr_stmt|;
name|target
operator|=
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
expr_stmt|;
name|lun
operator|=
name|ccb
operator|->
name|ccb_h
operator|.
name|target_lun
expr_stmt|;
if|if
condition|(
name|cel
operator|->
name|enable
operator|!=
literal|0
condition|)
block|{
comment|/* Are we already enabled?? */
if|if
condition|(
name|lstate
operator|!=
name|NULL
condition|)
block|{
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_LUN_ALRDY_ENA
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|cel
operator|->
name|grp6_len
operator|!=
literal|0
operator|||
name|cel
operator|->
name|grp7_len
operator|!=
literal|0
condition|)
block|{
comment|/* 				 * Don't (yet?) support vendor 				 * specific commands. 				 */
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_INVALID
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* 			 * Seems to be okay. 			 * Setup our data structures. 			 */
if|if
condition|(
name|tstate
operator|==
name|NULL
condition|)
block|{
name|tstate
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|tstate
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|tstate
operator|==
name|NULL
condition|)
block|{
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_RESRC_UNAVAIL
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
block|}
name|bzero
argument_list|(
name|tstate
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|tstate
argument_list|)
argument_list|)
expr_stmt|;
name|ahc
operator|->
name|enabled_targets
index|[
name|target
index|]
operator|=
name|tstate
expr_stmt|;
block|}
name|lstate
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|lstate
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|lstate
operator|==
name|NULL
condition|)
block|{
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_RESRC_UNAVAIL
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
block|}
name|bzero
argument_list|(
name|lstate
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|lstate
argument_list|)
argument_list|)
expr_stmt|;
name|SLIST_INIT
argument_list|(
operator|&
name|lstate
operator|->
name|accept_tios
argument_list|)
expr_stmt|;
name|SLIST_INIT
argument_list|(
operator|&
name|lstate
operator|->
name|immed_notifies
argument_list|)
expr_stmt|;
name|tstate
operator|->
name|enabled_luns
index|[
name|lun
index|]
operator|=
name|lstate
expr_stmt|;
if|if
condition|(
operator|(
name|ahc
operator|->
name|features
operator|&
name|AHC_MULTI_TID
operator|)
operator|!=
literal|0
condition|)
block|{
name|u_int16_t
name|targid_mask
decl_stmt|;
name|pause_sequencer
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
name|targid_mask
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|TARGID
argument_list|)
operator||
operator|(
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|TARGID
operator|+
literal|1
argument_list|)
operator|<<
literal|8
operator|)
expr_stmt|;
name|targid_mask
operator||=
operator|(
literal|0x01
operator|<<
name|target
operator|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|TARGID
argument_list|,
name|targid_mask
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|TARGID
operator|+
literal|1
argument_list|,
operator|(
name|targid_mask
operator|>>
literal|8
operator|)
argument_list|)
expr_stmt|;
name|unpause_sequencer
argument_list|(
name|ahc
argument_list|,
comment|/*always?*/
name|FALSE
argument_list|)
expr_stmt|;
block|}
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
name|xpt_print_path
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Lun now enabled for target mode\n"
argument_list|)
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
block|}
else|else
block|{
comment|/* XXX Fully Implement Disable */
if|if
condition|(
name|lstate
operator|==
name|NULL
condition|)
block|{
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_LUN_INVALID
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
block|}
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
block|}
case|case
name|XPT_ABORT
case|:
comment|/* Abort the specified CCB */
comment|/* XXX Implement */
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_INVALID
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
case|case
name|XPT_SET_TRAN_SETTINGS
case|:
block|{
name|struct
name|ahc_devinfo
name|devinfo
decl_stmt|;
name|struct
name|ccb_trans_settings
modifier|*
name|cts
decl_stmt|;
name|struct
name|ahc_target_tinfo
modifier|*
name|tinfo
decl_stmt|;
name|u_int
name|update_type
decl_stmt|;
name|int
name|s
decl_stmt|;
name|cts
operator|=
operator|&
name|ccb
operator|->
name|cts
expr_stmt|;
name|ahc_compile_devinfo
argument_list|(
operator|&
name|devinfo
argument_list|,
name|cts
operator|->
name|ccb_h
operator|.
name|target_id
argument_list|,
name|SIM_IS_SCSIBUS_B
argument_list|(
name|ahc
argument_list|,
name|sim
argument_list|)
condition|?
literal|'B'
else|:
literal|'A'
argument_list|)
expr_stmt|;
name|tinfo
operator|=
operator|&
name|ahc
operator|->
name|transinfo
index|[
name|devinfo
operator|.
name|target_offset
index|]
expr_stmt|;
name|update_type
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|cts
operator|->
name|flags
operator|&
name|CCB_TRANS_CURRENT_SETTINGS
operator|)
operator|!=
literal|0
condition|)
name|update_type
operator||=
name|AHC_TRANS_GOAL
expr_stmt|;
if|if
condition|(
operator|(
name|cts
operator|->
name|flags
operator|&
name|CCB_TRANS_USER_SETTINGS
operator|)
operator|!=
literal|0
condition|)
name|update_type
operator||=
name|AHC_TRANS_USER
expr_stmt|;
name|s
operator|=
name|splcam
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|cts
operator|->
name|valid
operator|&
name|CCB_TRANS_DISC_VALID
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|cts
operator|->
name|flags
operator|&
name|CCB_TRANS_DISC_ENB
operator|)
operator|!=
literal|0
condition|)
name|ahc
operator|->
name|discenable
operator||=
name|devinfo
operator|.
name|target_mask
expr_stmt|;
else|else
name|ahc
operator|->
name|discenable
operator|&=
operator|~
name|devinfo
operator|.
name|target_mask
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|cts
operator|->
name|valid
operator|&
name|CCB_TRANS_TQ_VALID
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|cts
operator|->
name|flags
operator|&
name|CCB_TRANS_TAG_ENB
operator|)
operator|!=
literal|0
condition|)
name|ahc
operator|->
name|tagenable
operator||=
name|devinfo
operator|.
name|target_mask
expr_stmt|;
else|else
name|ahc
operator|->
name|tagenable
operator|&=
operator|~
name|devinfo
operator|.
name|target_mask
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|cts
operator|->
name|valid
operator|&
name|CCB_TRANS_BUS_WIDTH_VALID
operator|)
operator|!=
literal|0
condition|)
block|{
switch|switch
condition|(
name|cts
operator|->
name|bus_width
condition|)
block|{
case|case
name|MSG_EXT_WDTR_BUS_16_BIT
case|:
if|if
condition|(
operator|(
name|ahc
operator|->
name|features
operator|&
name|AHC_WIDE
operator|)
operator|!=
literal|0
condition|)
break|break;
comment|/* FALLTHROUGH to 8bit */
case|case
name|MSG_EXT_WDTR_BUS_32_BIT
case|:
case|case
name|MSG_EXT_WDTR_BUS_8_BIT
case|:
default|default:
name|cts
operator|->
name|bus_width
operator|=
name|MSG_EXT_WDTR_BUS_8_BIT
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|update_type
operator|&
name|AHC_TRANS_GOAL
operator|)
operator|!=
literal|0
condition|)
name|tinfo
operator|->
name|goal
operator|.
name|width
operator|=
name|cts
operator|->
name|bus_width
expr_stmt|;
if|if
condition|(
operator|(
name|update_type
operator|&
name|AHC_TRANS_USER
operator|)
operator|!=
literal|0
condition|)
name|tinfo
operator|->
name|user
operator|.
name|width
operator|=
name|cts
operator|->
name|bus_width
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|cts
operator|->
name|valid
operator|&
name|CCB_TRANS_SYNC_RATE_VALID
operator|)
operator|!=
literal|0
condition|)
block|{
name|struct
name|ahc_syncrate
modifier|*
name|syncrate
decl_stmt|;
name|u_int
name|maxsync
decl_stmt|;
if|if
condition|(
operator|(
name|ahc
operator|->
name|features
operator|&
name|AHC_ULTRA2
operator|)
operator|!=
literal|0
condition|)
name|maxsync
operator|=
name|AHC_SYNCRATE_ULTRA2
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|ahc
operator|->
name|features
operator|&
name|AHC_ULTRA
operator|)
operator|!=
literal|0
condition|)
name|maxsync
operator|=
name|AHC_SYNCRATE_ULTRA
expr_stmt|;
else|else
name|maxsync
operator|=
name|AHC_SYNCRATE_FAST
expr_stmt|;
if|if
condition|(
operator|(
name|cts
operator|->
name|valid
operator|&
name|CCB_TRANS_SYNC_OFFSET_VALID
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|cts
operator|->
name|sync_offset
operator|!=
literal|0
condition|)
name|cts
operator|->
name|sync_offset
operator|=
operator|~
literal|0
expr_stmt|;
block|}
else|else
block|{
name|cts
operator|->
name|sync_offset
operator|=
literal|0
expr_stmt|;
block|}
name|syncrate
operator|=
name|ahc_find_syncrate
argument_list|(
name|ahc
argument_list|,
operator|&
name|cts
operator|->
name|sync_period
argument_list|,
name|maxsync
argument_list|)
expr_stmt|;
name|ahc_validate_offset
argument_list|(
name|ahc
argument_list|,
name|syncrate
argument_list|,
operator|&
name|cts
operator|->
name|sync_offset
argument_list|,
name|tinfo
operator|->
name|goal
operator|.
name|width
argument_list|)
expr_stmt|;
comment|/* We use a period of 0 to represent async */
if|if
condition|(
name|cts
operator|->
name|sync_offset
operator|==
literal|0
condition|)
name|cts
operator|->
name|sync_period
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|update_type
operator|&
name|AHC_TRANS_GOAL
operator|)
operator|!=
literal|0
condition|)
block|{
name|tinfo
operator|->
name|goal
operator|.
name|period
operator|=
name|cts
operator|->
name|sync_period
expr_stmt|;
name|tinfo
operator|->
name|goal
operator|.
name|offset
operator|=
name|cts
operator|->
name|sync_offset
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|update_type
operator|&
name|AHC_TRANS_USER
operator|)
operator|!=
literal|0
condition|)
block|{
name|tinfo
operator|->
name|user
operator|.
name|period
operator|=
name|cts
operator|->
name|sync_period
expr_stmt|;
name|tinfo
operator|->
name|user
operator|.
name|offset
operator|=
name|cts
operator|->
name|sync_offset
expr_stmt|;
block|}
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|XPT_GET_TRAN_SETTINGS
case|:
comment|/* Get default/user set transfer settings for the target */
block|{
name|struct
name|ahc_devinfo
name|devinfo
decl_stmt|;
name|struct
name|ccb_trans_settings
modifier|*
name|cts
decl_stmt|;
name|struct
name|ahc_target_tinfo
modifier|*
name|targ_info
decl_stmt|;
name|struct
name|ahc_transinfo
modifier|*
name|tinfo
decl_stmt|;
name|int
name|s
decl_stmt|;
name|cts
operator|=
operator|&
name|ccb
operator|->
name|cts
expr_stmt|;
name|ahc_compile_devinfo
argument_list|(
operator|&
name|devinfo
argument_list|,
name|cts
operator|->
name|ccb_h
operator|.
name|target_id
argument_list|,
name|SIM_IS_SCSIBUS_B
argument_list|(
name|ahc
argument_list|,
name|sim
argument_list|)
condition|?
literal|'B'
else|:
literal|'A'
argument_list|)
expr_stmt|;
name|targ_info
operator|=
operator|&
name|ahc
operator|->
name|transinfo
index|[
name|devinfo
operator|.
name|target_offset
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|cts
operator|->
name|flags
operator|&
name|CCB_TRANS_CURRENT_SETTINGS
operator|)
operator|!=
literal|0
condition|)
name|tinfo
operator|=
operator|&
name|targ_info
operator|->
name|current
expr_stmt|;
else|else
name|tinfo
operator|=
operator|&
name|targ_info
operator|->
name|user
expr_stmt|;
name|s
operator|=
name|splcam
argument_list|()
expr_stmt|;
name|cts
operator|->
name|flags
operator|&=
operator|~
operator|(
name|CCB_TRANS_DISC_ENB
operator||
name|CCB_TRANS_TAG_ENB
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|ahc
operator|->
name|discenable
operator|&
name|devinfo
operator|.
name|target_mask
operator|)
operator|!=
literal|0
condition|)
name|cts
operator|->
name|flags
operator||=
name|CCB_TRANS_DISC_ENB
expr_stmt|;
if|if
condition|(
operator|(
name|ahc
operator|->
name|tagenable
operator|&
name|devinfo
operator|.
name|target_mask
operator|)
operator|!=
literal|0
condition|)
name|cts
operator|->
name|flags
operator||=
name|CCB_TRANS_TAG_ENB
expr_stmt|;
name|cts
operator|->
name|sync_period
operator|=
name|tinfo
operator|->
name|period
expr_stmt|;
name|cts
operator|->
name|sync_offset
operator|=
name|tinfo
operator|->
name|offset
expr_stmt|;
name|cts
operator|->
name|bus_width
operator|=
name|tinfo
operator|->
name|width
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|cts
operator|->
name|valid
operator|=
name|CCB_TRANS_SYNC_RATE_VALID
operator||
name|CCB_TRANS_SYNC_OFFSET_VALID
operator||
name|CCB_TRANS_BUS_WIDTH_VALID
operator||
name|CCB_TRANS_DISC_VALID
operator||
name|CCB_TRANS_TQ_VALID
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|XPT_CALC_GEOMETRY
case|:
block|{
name|struct
name|ccb_calc_geometry
modifier|*
name|ccg
decl_stmt|;
name|u_int32_t
name|size_mb
decl_stmt|;
name|u_int32_t
name|secs_per_cylinder
decl_stmt|;
name|int
name|extended
decl_stmt|;
name|ccg
operator|=
operator|&
name|ccb
operator|->
name|ccg
expr_stmt|;
name|size_mb
operator|=
name|ccg
operator|->
name|volume_size
operator|/
operator|(
operator|(
literal|1024L
operator|*
literal|1024L
operator|)
operator|/
name|ccg
operator|->
name|block_size
operator|)
expr_stmt|;
name|extended
operator|=
name|SIM_IS_SCSIBUS_B
argument_list|(
name|ahc
argument_list|,
name|sim
argument_list|)
condition|?
name|ahc
operator|->
name|flags
operator|&
name|AHC_EXTENDED_TRANS_B
else|:
name|ahc
operator|->
name|flags
operator|&
name|AHC_EXTENDED_TRANS_A
expr_stmt|;
if|if
condition|(
name|size_mb
operator|>
literal|1024
operator|&&
name|extended
condition|)
block|{
name|ccg
operator|->
name|heads
operator|=
literal|255
expr_stmt|;
name|ccg
operator|->
name|secs_per_track
operator|=
literal|63
expr_stmt|;
block|}
else|else
block|{
name|ccg
operator|->
name|heads
operator|=
literal|64
expr_stmt|;
name|ccg
operator|->
name|secs_per_track
operator|=
literal|32
expr_stmt|;
block|}
name|secs_per_cylinder
operator|=
name|ccg
operator|->
name|heads
operator|*
name|ccg
operator|->
name|secs_per_track
expr_stmt|;
name|ccg
operator|->
name|cylinders
operator|=
name|ccg
operator|->
name|volume_size
operator|/
name|secs_per_cylinder
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|XPT_RESET_BUS
case|:
comment|/* Reset the specified SCSI bus */
block|{
name|struct
name|cam_path
modifier|*
name|path
decl_stmt|;
name|char
name|channel
decl_stmt|;
name|int
name|found
decl_stmt|;
name|s
operator|=
name|splcam
argument_list|()
expr_stmt|;
if|if
condition|(
name|SIM_IS_SCSIBUS_B
argument_list|(
name|ahc
argument_list|,
name|sim
argument_list|)
condition|)
block|{
name|channel
operator|=
literal|'B'
expr_stmt|;
name|path
operator|=
name|ahc
operator|->
name|path_b
expr_stmt|;
block|}
else|else
block|{
name|channel
operator|=
literal|'A'
expr_stmt|;
name|path
operator|=
name|ahc
operator|->
name|path
expr_stmt|;
block|}
name|found
operator|=
name|ahc_reset_channel
argument_list|(
name|ahc
argument_list|,
name|channel
argument_list|,
comment|/*initiate reset*/
name|TRUE
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
block|{
name|xpt_print_path
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"SCSI bus reset delivered. "
literal|"%d SCBs aborted.\n"
argument_list|,
name|found
argument_list|)
expr_stmt|;
block|}
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|XPT_TERM_IO
case|:
comment|/* Terminate the I/O process */
comment|/* XXX Implement */
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_INVALID
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
case|case
name|XPT_PATH_INQ
case|:
comment|/* Path routing inquiry */
block|{
name|struct
name|ccb_pathinq
modifier|*
name|cpi
init|=
operator|&
name|ccb
operator|->
name|cpi
decl_stmt|;
name|cpi
operator|->
name|version_num
operator|=
literal|1
expr_stmt|;
comment|/* XXX??? */
name|cpi
operator|->
name|hba_inquiry
operator|=
name|PI_SDTR_ABLE
operator||
name|PI_TAG_ABLE
expr_stmt|;
if|if
condition|(
operator|(
name|ahc
operator|->
name|features
operator|&
name|AHC_WIDE
operator|)
operator|!=
literal|0
condition|)
name|cpi
operator|->
name|hba_inquiry
operator||=
name|PI_WIDE_16
expr_stmt|;
if|if
condition|(
operator|(
name|ahc
operator|->
name|flags
operator|&
name|AHC_TARGETMODE
operator|)
operator|!=
literal|0
condition|)
block|{
name|cpi
operator|->
name|target_sprt
operator|=
name|PIT_PROCESSOR
operator||
name|PIT_DISCONNECT
operator||
name|PIT_TERM_IO
expr_stmt|;
block|}
else|else
block|{
name|cpi
operator|->
name|target_sprt
operator|=
literal|0
expr_stmt|;
block|}
name|cpi
operator|->
name|hba_misc
operator|=
literal|0
expr_stmt|;
name|cpi
operator|->
name|hba_eng_cnt
operator|=
literal|0
expr_stmt|;
name|cpi
operator|->
name|max_target
operator|=
operator|(
name|ahc
operator|->
name|features
operator|&
name|AHC_WIDE
operator|)
condition|?
literal|15
else|:
literal|7
expr_stmt|;
name|cpi
operator|->
name|max_lun
operator|=
literal|7
expr_stmt|;
if|if
condition|(
name|SIM_IS_SCSIBUS_B
argument_list|(
name|ahc
argument_list|,
name|sim
argument_list|)
condition|)
name|cpi
operator|->
name|initiator_id
operator|=
name|ahc
operator|->
name|our_id_b
expr_stmt|;
else|else
name|cpi
operator|->
name|initiator_id
operator|=
name|ahc
operator|->
name|our_id
expr_stmt|;
name|cpi
operator|->
name|bus_id
operator|=
name|cam_sim_bus
argument_list|(
name|sim
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|cpi
operator|->
name|sim_vid
argument_list|,
literal|"FreeBSD"
argument_list|,
name|SIM_IDLEN
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|cpi
operator|->
name|hba_vid
argument_list|,
literal|"Adaptec"
argument_list|,
name|HBA_IDLEN
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|cpi
operator|->
name|dev_name
argument_list|,
name|cam_sim_name
argument_list|(
name|sim
argument_list|)
argument_list|,
name|DEV_IDLEN
argument_list|)
expr_stmt|;
name|cpi
operator|->
name|unit_number
operator|=
name|cam_sim_unit
argument_list|(
name|sim
argument_list|)
expr_stmt|;
name|cpi
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_INVALID
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ahc_async
parameter_list|(
name|void
modifier|*
name|callback_arg
parameter_list|,
name|u_int32_t
name|code
parameter_list|,
name|struct
name|cam_path
modifier|*
name|path
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ahc_softc
modifier|*
name|ahc
decl_stmt|;
name|struct
name|cam_sim
modifier|*
name|sim
decl_stmt|;
name|sim
operator|=
operator|(
expr|struct
name|cam_sim
operator|*
operator|)
name|callback_arg
expr_stmt|;
name|ahc
operator|=
operator|(
expr|struct
name|ahc_softc
operator|*
operator|)
name|cam_sim_softc
argument_list|(
name|sim
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|AC_LOST_DEVICE
case|:
block|{
name|struct
name|ahc_devinfo
name|devinfo
decl_stmt|;
name|ahc_compile_devinfo
argument_list|(
operator|&
name|devinfo
argument_list|,
name|xpt_path_target_id
argument_list|(
name|path
argument_list|)
argument_list|,
name|SIM_IS_SCSIBUS_B
argument_list|(
name|ahc
argument_list|,
name|sim
argument_list|)
condition|?
literal|'B'
else|:
literal|'A'
argument_list|)
expr_stmt|;
comment|/* 		 * Revert to async/narrow transfers 		 * for the next device. 		 */
name|pause_sequencer
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
name|ahc_set_width
argument_list|(
name|ahc
argument_list|,
operator|&
name|devinfo
argument_list|,
name|path
argument_list|,
name|MSG_EXT_WDTR_BUS_8_BIT
argument_list|,
name|AHC_TRANS_GOAL
operator||
name|AHC_TRANS_CUR
argument_list|)
expr_stmt|;
name|ahc_set_syncrate
argument_list|(
name|ahc
argument_list|,
operator|&
name|devinfo
argument_list|,
name|path
argument_list|,
comment|/*syncrate*/
name|NULL
argument_list|,
comment|/*period*/
literal|0
argument_list|,
comment|/*offset*/
literal|0
argument_list|,
name|AHC_TRANS_GOAL
operator||
name|AHC_TRANS_CUR
argument_list|)
expr_stmt|;
name|unpause_sequencer
argument_list|(
name|ahc
argument_list|,
comment|/*unpause always*/
name|FALSE
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ahc_execute_scb
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|dm_segs
parameter_list|,
name|int
name|nsegments
parameter_list|,
name|int
name|error
parameter_list|)
block|{
name|struct
name|scb
modifier|*
name|scb
decl_stmt|;
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|struct
name|ahc_softc
modifier|*
name|ahc
decl_stmt|;
name|int
name|s
decl_stmt|;
name|scb
operator|=
operator|(
expr|struct
name|scb
operator|*
operator|)
name|arg
expr_stmt|;
name|ccb
operator|=
name|scb
operator|->
name|ccb
expr_stmt|;
name|ahc
operator|=
operator|(
expr|struct
name|ahc_softc
operator|*
operator|)
name|ccb
operator|->
name|ccb_h
operator|.
name|ccb_ahc_ptr
expr_stmt|;
if|if
condition|(
name|nsegments
operator|!=
literal|0
condition|)
block|{
name|struct
name|ahc_dma_seg
modifier|*
name|sg
decl_stmt|;
name|bus_dma_segment_t
modifier|*
name|end_seg
decl_stmt|;
name|bus_dmasync_op_t
name|op
decl_stmt|;
name|end_seg
operator|=
name|dm_segs
operator|+
name|nsegments
expr_stmt|;
comment|/* Copy the first SG into the data pointer area */
name|scb
operator|->
name|hscb
operator|->
name|SG_pointer
operator|=
name|scb
operator|->
name|ahc_dmaphys
expr_stmt|;
name|scb
operator|->
name|hscb
operator|->
name|data
operator|=
name|dm_segs
operator|->
name|ds_addr
expr_stmt|;
name|scb
operator|->
name|hscb
operator|->
name|datalen
operator|=
name|dm_segs
operator|->
name|ds_len
expr_stmt|;
name|dm_segs
operator|++
expr_stmt|;
comment|/* Copy the remaining segments into our SG list */
name|sg
operator|=
name|scb
operator|->
name|ahc_dma
expr_stmt|;
while|while
condition|(
name|dm_segs
operator|<
name|end_seg
condition|)
block|{
name|sg
operator|->
name|addr
operator|=
name|dm_segs
operator|->
name|ds_addr
expr_stmt|;
name|sg
operator|->
name|len
operator|=
name|dm_segs
operator|->
name|ds_len
expr_stmt|;
name|sg
operator|++
expr_stmt|;
name|dm_segs
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DIR_MASK
operator|)
operator|==
name|CAM_DIR_IN
condition|)
name|op
operator|=
name|BUS_DMASYNC_PREREAD
expr_stmt|;
else|else
name|op
operator|=
name|BUS_DMASYNC_PREWRITE
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|ahc
operator|->
name|dmat
argument_list|,
name|scb
operator|->
name|dmamap
argument_list|,
name|op
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|scb
operator|->
name|hscb
operator|->
name|SG_pointer
operator|=
literal|0
expr_stmt|;
name|scb
operator|->
name|hscb
operator|->
name|data
operator|=
literal|0
expr_stmt|;
name|scb
operator|->
name|hscb
operator|->
name|datalen
operator|=
literal|0
expr_stmt|;
block|}
name|scb
operator|->
name|sg_count
operator|=
name|scb
operator|->
name|hscb
operator|->
name|SG_count
operator|=
name|nsegments
expr_stmt|;
name|s
operator|=
name|splcam
argument_list|()
expr_stmt|;
comment|/* 	 * Last time we need to check if this SCB needs to 	 * be aborted. 	 */
if|if
condition|(
name|ahc_ccb_status
argument_list|(
name|ccb
argument_list|)
operator|!=
name|CAM_REQ_INPROG
condition|)
block|{
if|if
condition|(
name|nsegments
operator|!=
literal|0
condition|)
name|bus_dmamap_unload
argument_list|(
name|ahc
operator|->
name|dmat
argument_list|,
name|scb
operator|->
name|dmamap
argument_list|)
expr_stmt|;
name|ahc_free_scb
argument_list|(
name|ahc
argument_list|,
name|scb
argument_list|)
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Busy this tcl if we are untagged */
if|if
condition|(
operator|(
name|scb
operator|->
name|hscb
operator|->
name|control
operator|&
name|TAG_ENB
operator|)
operator|==
literal|0
condition|)
name|ahc_busy_tcl
argument_list|(
name|ahc
argument_list|,
name|scb
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|ahc
operator|->
name|pending_ccbs
argument_list|,
operator|&
name|ccb
operator|->
name|ccb_h
argument_list|,
name|sim_links
operator|.
name|le
argument_list|)
expr_stmt|;
name|scb
operator|->
name|flags
operator||=
name|SCB_ACTIVE
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_SIM_QUEUED
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|timeout_ch
operator|=
name|timeout
argument_list|(
name|ahc_timeout
argument_list|,
operator|(
name|caddr_t
operator|)
name|scb
argument_list|,
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|timeout
operator|*
name|hz
operator|)
operator|/
literal|1000
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|scb
operator|->
name|flags
operator|&
name|SCB_TARGET_IMMEDIATE
operator|)
operator|!=
literal|0
condition|)
block|{
name|xpt_print_path
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Returning an immediate CTIO\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ahc
operator|->
name|flags
operator|&
name|AHC_PAGESCBS
operator|)
operator|==
literal|0
condition|)
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCBPTR
argument_list|,
name|scb
operator|->
name|hscb
operator|->
name|tag
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCB_TAG
argument_list|,
name|scb
operator|->
name|hscb
operator|->
name|tag
argument_list|)
expr_stmt|;
name|unpause_sequencer
argument_list|(
name|ahc
argument_list|,
comment|/*unpause_always*/
name|TRUE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ahc
operator|->
name|qinfifo
index|[
name|ahc
operator|->
name|qinfifonext
operator|++
index|]
operator|=
name|scb
operator|->
name|hscb
operator|->
name|tag
expr_stmt|;
if|if
condition|(
operator|(
name|ahc
operator|->
name|features
operator|&
name|AHC_QUEUE_REGS
operator|)
operator|!=
literal|0
condition|)
block|{
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|HNSCB_QOFF
argument_list|,
name|ahc
operator|->
name|qinfifonext
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pause_sequencer
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|KERNEL_QINPOS
argument_list|,
name|ahc
operator|->
name|qinfifonext
argument_list|)
expr_stmt|;
name|unpause_sequencer
argument_list|(
name|ahc
argument_list|,
comment|/*unpause_always*/
name|FALSE
argument_list|)
expr_stmt|;
block|}
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ahc_poll
parameter_list|(
name|struct
name|cam_sim
modifier|*
name|sim
parameter_list|)
block|{
name|ahc_intr
argument_list|(
name|cam_sim_softc
argument_list|(
name|sim
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ahc_setup_data
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|struct
name|ccb_scsiio
modifier|*
name|csio
parameter_list|,
name|struct
name|scb
modifier|*
name|scb
parameter_list|)
block|{
name|struct
name|hardware_scb
modifier|*
name|hscb
decl_stmt|;
name|struct
name|ccb_hdr
modifier|*
name|ccb_h
decl_stmt|;
name|hscb
operator|=
name|scb
operator|->
name|hscb
expr_stmt|;
name|ccb_h
operator|=
operator|&
name|csio
operator|->
name|ccb_h
expr_stmt|;
if|if
condition|(
name|ccb_h
operator|->
name|func_code
operator|==
name|XPT_SCSI_IO
condition|)
block|{
name|hscb
operator|->
name|cmdlen
operator|=
name|csio
operator|->
name|cdb_len
expr_stmt|;
if|if
condition|(
operator|(
name|ccb_h
operator|->
name|flags
operator|&
name|CAM_CDB_POINTER
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|ccb_h
operator|->
name|flags
operator|&
name|CAM_CDB_PHYS
operator|)
operator|==
literal|0
condition|)
if|if
condition|(
name|hscb
operator|->
name|cmdlen
operator|<=
literal|16
condition|)
block|{
name|memcpy
argument_list|(
name|hscb
operator|->
name|cmdstore
argument_list|,
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_ptr
argument_list|,
name|hscb
operator|->
name|cmdlen
argument_list|)
expr_stmt|;
name|hscb
operator|->
name|cmdpointer
operator|=
name|hscb
operator|->
name|cmdstore_busaddr
expr_stmt|;
block|}
else|else
name|hscb
operator|->
name|cmdpointer
operator|=
name|vtophys
argument_list|(
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_ptr
argument_list|)
expr_stmt|;
else|else
name|hscb
operator|->
name|cmdpointer
operator|=
operator|(
name|u_int32_t
operator|)
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_ptr
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * CCB CDB Data Storage area is only 16 bytes 			 * so no additional testing is required 			 */
name|memcpy
argument_list|(
name|hscb
operator|->
name|cmdstore
argument_list|,
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
argument_list|,
name|hscb
operator|->
name|cmdlen
argument_list|)
expr_stmt|;
name|hscb
operator|->
name|cmdpointer
operator|=
name|hscb
operator|->
name|cmdstore_busaddr
expr_stmt|;
block|}
block|}
comment|/* Only use S/G if there is a transfer */
if|if
condition|(
operator|(
name|ccb_h
operator|->
name|flags
operator|&
name|CAM_DIR_MASK
operator|)
operator|!=
name|CAM_DIR_NONE
condition|)
block|{
if|if
condition|(
operator|(
name|ccb_h
operator|->
name|flags
operator|&
name|CAM_SCATTER_VALID
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* We've been given a pointer to a single buffer */
if|if
condition|(
operator|(
name|ccb_h
operator|->
name|flags
operator|&
name|CAM_DATA_PHYS
operator|)
operator|==
literal|0
condition|)
block|{
name|int
name|s
decl_stmt|;
name|int
name|error
decl_stmt|;
name|s
operator|=
name|splsoftvm
argument_list|()
expr_stmt|;
name|error
operator|=
name|bus_dmamap_load
argument_list|(
name|ahc
operator|->
name|dmat
argument_list|,
name|scb
operator|->
name|dmamap
argument_list|,
name|csio
operator|->
name|data_ptr
argument_list|,
name|csio
operator|->
name|dxfer_len
argument_list|,
name|ahc_execute_scb
argument_list|,
name|scb
argument_list|,
comment|/*flags*/
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|EINPROGRESS
condition|)
block|{
comment|/* 					 * So as to maintain ordering, 					 * freeze the controller queue 					 * until our mapping is 					 * returned. 					 */
name|xpt_freeze_simq
argument_list|(
name|ahc
operator|->
name|sim
argument_list|,
comment|/*count*/
literal|1
argument_list|)
expr_stmt|;
name|scb
operator|->
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_RELEASE_SIMQ
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|struct
name|bus_dma_segment
name|seg
decl_stmt|;
comment|/* Pointer to physical buffer */
if|if
condition|(
name|csio
operator|->
name|dxfer_len
operator|>
name|AHC_MAXTRANSFER_SIZE
condition|)
name|panic
argument_list|(
literal|"ahc_setup_data - Transfer size "
literal|"larger than can device max"
argument_list|)
expr_stmt|;
name|seg
operator|.
name|ds_addr
operator|=
operator|(
name|bus_addr_t
operator|)
name|csio
operator|->
name|data_ptr
expr_stmt|;
name|seg
operator|.
name|ds_len
operator|=
name|csio
operator|->
name|dxfer_len
expr_stmt|;
name|ahc_execute_scb
argument_list|(
name|scb
argument_list|,
operator|&
name|seg
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|struct
name|bus_dma_segment
modifier|*
name|segs
decl_stmt|;
if|if
condition|(
operator|(
name|ccb_h
operator|->
name|flags
operator|&
name|CAM_DATA_PHYS
operator|)
operator|!=
literal|0
condition|)
name|panic
argument_list|(
literal|"ahc_setup_data - Physical segment "
literal|"pointers unsupported"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ccb_h
operator|->
name|flags
operator|&
name|CAM_SG_LIST_PHYS
operator|)
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"ahc_setup_data - Virtual segment "
literal|"addresses unsupported"
argument_list|)
expr_stmt|;
comment|/* Just use the segments provided */
name|segs
operator|=
operator|(
expr|struct
name|bus_dma_segment
operator|*
operator|)
name|csio
operator|->
name|data_ptr
expr_stmt|;
name|ahc_execute_scb
argument_list|(
name|scb
argument_list|,
name|segs
argument_list|,
name|csio
operator|->
name|sglist_cnt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ccb_h
operator|->
name|func_code
operator|==
name|XPT_CONT_TARGET_IO
condition|)
block|{
name|hscb
operator|->
name|cmdpointer
operator||=
name|DPHASE_PENDING
expr_stmt|;
if|if
condition|(
operator|(
name|ccb_h
operator|->
name|flags
operator|&
name|CAM_DIR_MASK
operator|)
operator|==
name|CAM_DIR_IN
condition|)
name|hscb
operator|->
name|cmdpointer
operator||=
operator|(
name|TARGET_DATA_IN
operator|<<
literal|8
operator|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|ahc_execute_scb
argument_list|(
name|scb
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ahc_freeze_devq
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|struct
name|cam_path
modifier|*
name|path
parameter_list|)
block|{
name|int
name|target
decl_stmt|;
name|char
name|channel
decl_stmt|;
name|int
name|lun
decl_stmt|;
name|target
operator|=
name|xpt_path_target_id
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|lun
operator|=
name|xpt_path_lun_id
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|channel
operator|=
name|xpt_path_sim
argument_list|(
name|path
argument_list|)
operator|->
name|bus_id
operator|==
literal|0
condition|?
literal|'A'
else|:
literal|'B'
expr_stmt|;
name|ahc_search_qinfifo
argument_list|(
name|ahc
argument_list|,
name|target
argument_list|,
name|channel
argument_list|,
name|lun
argument_list|,
comment|/*tag*/
name|SCB_LIST_NULL
argument_list|,
name|CAM_REQUEUE_REQ
argument_list|,
name|SEARCH_COMPLETE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * An scb (and hence an scb entry on the board) is put onto the  * free list.  */
end_comment

begin_function
specifier|static
name|void
name|ahc_free_scb
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|struct
name|scb
modifier|*
name|scb
parameter_list|)
block|{
name|struct
name|hardware_scb
modifier|*
name|hscb
decl_stmt|;
name|int
name|opri
decl_stmt|;
name|hscb
operator|=
name|scb
operator|->
name|hscb
expr_stmt|;
name|opri
operator|=
name|splcam
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|ahc
operator|->
name|flags
operator|&
name|AHC_RESOURCE_SHORTAGE
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|scb
operator|->
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_RELEASE_SIMQ
operator|)
operator|==
literal|0
condition|)
block|{
name|scb
operator|->
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_RELEASE_SIMQ
expr_stmt|;
name|ahc
operator|->
name|flags
operator|&=
operator|~
name|AHC_RESOURCE_SHORTAGE
expr_stmt|;
block|}
comment|/* Clean up for the next user */
name|scb
operator|->
name|flags
operator|=
name|SCB_FREE
expr_stmt|;
name|hscb
operator|->
name|control
operator|=
literal|0
expr_stmt|;
name|hscb
operator|->
name|status
operator|=
literal|0
expr_stmt|;
name|STAILQ_INSERT_HEAD
argument_list|(
operator|&
name|ahc
operator|->
name|scb_data
operator|->
name|free_scbs
argument_list|,
name|scb
argument_list|,
name|links
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|opri
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Get a free scb, either one already assigned to a hardware slot  * on the adapter or one that will require an SCB to be paged out before  * use. If there are none, see if we can allocate a new SCB.  Otherwise  * either return an error or sleep.  */
end_comment

begin_function
specifier|static
name|struct
name|scb
modifier|*
name|ahc_get_scb
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|)
block|{
name|struct
name|scb
modifier|*
name|scbp
decl_stmt|;
name|int
name|opri
decl_stmt|;
name|opri
operator|=
name|splcam
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|scbp
operator|=
name|STAILQ_FIRST
argument_list|(
operator|&
name|ahc
operator|->
name|scb_data
operator|->
name|free_scbs
argument_list|)
operator|)
condition|)
block|{
name|STAILQ_REMOVE_HEAD
argument_list|(
operator|&
name|ahc
operator|->
name|scb_data
operator|->
name|free_scbs
argument_list|,
name|links
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ahc
operator|->
name|scb_data
operator|->
name|numscbs
operator|<
name|ahc
operator|->
name|scb_data
operator|->
name|maxscbs
condition|)
block|{
name|scbp
operator|=
name|ahc_alloc_scb
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
if|if
condition|(
name|scbp
operator|==
name|NULL
condition|)
name|printf
argument_list|(
literal|"%s: Can't malloc SCB\n"
argument_list|,
name|ahc_name
argument_list|(
name|ahc
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|opri
argument_list|)
expr_stmt|;
return|return
operator|(
name|scbp
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|scb
modifier|*
name|ahc_alloc_scb
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|)
block|{
specifier|static
name|struct
name|ahc_dma_seg
modifier|*
name|next_sg_array
init|=
name|NULL
decl_stmt|;
specifier|static
name|int
name|sg_arrays_free
init|=
literal|0
decl_stmt|;
name|struct
name|scb
modifier|*
name|newscb
decl_stmt|;
name|int
name|error
decl_stmt|;
name|newscb
operator|=
operator|(
expr|struct
name|scb
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|scb
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|newscb
operator|!=
name|NULL
condition|)
block|{
name|bzero
argument_list|(
name|newscb
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|scb
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|bus_dmamap_create
argument_list|(
name|ahc
operator|->
name|dmat
argument_list|,
comment|/*flags*/
literal|0
argument_list|,
operator|&
name|newscb
operator|->
name|dmamap
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|"%s: Unable to allocate SCB dmamap - error %d\n"
argument_list|,
name|ahc_name
argument_list|(
name|ahc
argument_list|)
argument_list|,
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
operator|&&
name|next_sg_array
operator|==
name|NULL
condition|)
block|{
name|size_t
name|alloc_size
init|=
sizeof|sizeof
argument_list|(
expr|struct
name|ahc_dma_seg
argument_list|)
operator|*
name|AHC_NSEG
decl_stmt|;
name|sg_arrays_free
operator|=
name|PAGE_SIZE
operator|/
name|alloc_size
expr_stmt|;
name|alloc_size
operator|*=
name|sg_arrays_free
expr_stmt|;
if|if
condition|(
name|alloc_size
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"%s: SG list doesn't fit in a page"
argument_list|,
name|ahc_name
argument_list|(
name|ahc
argument_list|)
argument_list|)
expr_stmt|;
name|next_sg_array
operator|=
operator|(
expr|struct
name|ahc_dma_seg
operator|*
operator|)
name|malloc
argument_list|(
name|alloc_size
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|==
literal|0
operator|&&
name|next_sg_array
operator|!=
name|NULL
condition|)
block|{
name|struct
name|hardware_scb
modifier|*
name|hscb
decl_stmt|;
name|newscb
operator|->
name|ahc_dma
operator|=
name|next_sg_array
expr_stmt|;
name|newscb
operator|->
name|ahc_dmaphys
operator|=
name|vtophys
argument_list|(
name|next_sg_array
argument_list|)
expr_stmt|;
name|sg_arrays_free
operator|--
expr_stmt|;
if|if
condition|(
name|sg_arrays_free
operator|==
literal|0
condition|)
name|next_sg_array
operator|=
name|NULL
expr_stmt|;
else|else
name|next_sg_array
operator|=
operator|&
name|next_sg_array
index|[
name|AHC_NSEG
index|]
expr_stmt|;
name|hscb
operator|=
operator|&
name|ahc
operator|->
name|scb_data
operator|->
name|hscbs
index|[
name|ahc
operator|->
name|scb_data
operator|->
name|numscbs
index|]
expr_stmt|;
name|newscb
operator|->
name|hscb
operator|=
name|hscb
expr_stmt|;
name|hscb
operator|->
name|control
operator|=
literal|0
expr_stmt|;
name|hscb
operator|->
name|status
operator|=
literal|0
expr_stmt|;
name|hscb
operator|->
name|tag
operator|=
name|ahc
operator|->
name|scb_data
operator|->
name|numscbs
expr_stmt|;
name|hscb
operator|->
name|residual_data_count
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|hscb
operator|->
name|residual_data_count
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|hscb
operator|->
name|residual_data_count
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|hscb
operator|->
name|residual_SG_count
operator|=
literal|0
expr_stmt|;
name|hscb
operator|->
name|cmdstore_busaddr
operator|=
name|ahc_hscb_busaddr
argument_list|(
name|ahc
argument_list|,
name|hscb
operator|->
name|tag
argument_list|)
operator|+
name|offsetof
argument_list|(
expr|struct
name|hardware_scb
argument_list|,
name|cmdstore
argument_list|)
expr_stmt|;
comment|/* 			 * Place in the scbarray 			 * Never is removed. 			 */
name|ahc
operator|->
name|scb_data
operator|->
name|scbarray
index|[
name|hscb
operator|->
name|tag
index|]
operator|=
name|newscb
expr_stmt|;
name|ahc
operator|->
name|scb_data
operator|->
name|numscbs
operator|++
expr_stmt|;
block|}
else|else
block|{
name|free
argument_list|(
name|newscb
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|newscb
operator|=
name|NULL
expr_stmt|;
block|}
block|}
return|return
name|newscb
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ahc_loadseq
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|)
block|{
name|struct
name|patch
modifier|*
name|cur_patch
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|downloaded
decl_stmt|;
name|int
name|skip_addr
decl_stmt|;
name|u_int8_t
name|download_consts
index|[
literal|4
index|]
decl_stmt|;
comment|/* Setup downloadable constant table */
name|download_consts
index|[
name|TMODE_NUMCMDS
index|]
operator|=
name|ahc
operator|->
name|num_targetcmds
expr_stmt|;
name|cur_patch
operator|=
name|patches
expr_stmt|;
name|downloaded
operator|=
literal|0
expr_stmt|;
name|skip_addr
operator|=
literal|0
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SEQCTL
argument_list|,
name|PERRORDIS
operator||
name|FAILDIS
operator||
name|FASTMODE
operator||
name|LOADRAM
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SEQADDR0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SEQADDR1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|seqprog
argument_list|)
operator|/
literal|4
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ahc_check_patch
argument_list|(
name|ahc
argument_list|,
operator|&
name|cur_patch
argument_list|,
name|i
argument_list|,
operator|&
name|skip_addr
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* 			 * Don't download this instruction as it 			 * is in a patch that was removed. 			 */
continue|continue;
block|}
name|ahc_download_instr
argument_list|(
name|ahc
argument_list|,
name|i
argument_list|,
name|download_consts
argument_list|)
expr_stmt|;
name|downloaded
operator|++
expr_stmt|;
block|}
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SEQCTL
argument_list|,
name|PERRORDIS
operator||
name|FAILDIS
operator||
name|FASTMODE
argument_list|)
expr_stmt|;
name|restart_sequencer
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|" %d instructions downloaded\n"
argument_list|,
name|downloaded
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|ahc_check_patch
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|struct
name|patch
modifier|*
modifier|*
name|start_patch
parameter_list|,
name|int
name|start_instr
parameter_list|,
name|int
modifier|*
name|skip_addr
parameter_list|)
block|{
name|struct
name|patch
modifier|*
name|cur_patch
decl_stmt|;
name|struct
name|patch
modifier|*
name|last_patch
decl_stmt|;
name|int
name|patch_index
decl_stmt|;
name|int
name|num_patches
decl_stmt|;
name|num_patches
operator|=
sizeof|sizeof
argument_list|(
name|patches
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|patch
argument_list|)
expr_stmt|;
name|last_patch
operator|=
operator|&
name|patches
index|[
name|num_patches
index|]
expr_stmt|;
name|cur_patch
operator|=
operator|*
name|start_patch
expr_stmt|;
while|while
condition|(
name|cur_patch
operator|<
name|last_patch
operator|&&
name|start_instr
operator|==
name|cur_patch
operator|->
name|begin
condition|)
block|{
if|if
condition|(
name|cur_patch
operator|->
name|patch_func
argument_list|(
name|ahc
argument_list|)
operator|==
literal|0
condition|)
block|{
name|int
name|skip
decl_stmt|;
comment|/* Start rejecting code */
operator|*
name|skip_addr
operator|=
name|start_instr
operator|+
name|cur_patch
operator|->
name|skip_instr
expr_stmt|;
name|cur_patch
operator|+=
name|cur_patch
operator|->
name|skip_patch
expr_stmt|;
block|}
else|else
block|{
comment|/* Accepted this patch.  Advance to the next 			 * one and wait for our intruction pointer to 			 * hit this point. 			 */
name|cur_patch
operator|++
expr_stmt|;
block|}
block|}
operator|*
name|start_patch
operator|=
name|cur_patch
expr_stmt|;
if|if
condition|(
name|start_instr
operator|<
operator|*
name|skip_addr
condition|)
comment|/* Still skipping */
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ahc_download_instr
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|int
name|instrptr
parameter_list|,
name|u_int8_t
modifier|*
name|dconsts
parameter_list|)
block|{
name|union
name|ins_formats
name|instr
decl_stmt|;
name|struct
name|ins_format1
modifier|*
name|fmt1_ins
decl_stmt|;
name|struct
name|ins_format3
modifier|*
name|fmt3_ins
decl_stmt|;
name|int
name|fmt3
decl_stmt|;
name|u_int
name|opcode
decl_stmt|;
comment|/* Structure copy */
name|instr
operator|=
operator|*
operator|(
expr|union
name|ins_formats
operator|*
operator|)
operator|&
name|seqprog
index|[
name|instrptr
operator|*
literal|4
index|]
expr_stmt|;
name|fmt1_ins
operator|=
operator|&
name|instr
operator|.
name|format1
expr_stmt|;
name|fmt3_ins
operator|=
name|NULL
expr_stmt|;
comment|/* Pull the opcode */
name|opcode
operator|=
name|instr
operator|.
name|format1
operator|.
name|opcode
expr_stmt|;
switch|switch
condition|(
name|opcode
condition|)
block|{
case|case
name|AIC_OP_JMP
case|:
case|case
name|AIC_OP_JC
case|:
case|case
name|AIC_OP_JNC
case|:
case|case
name|AIC_OP_CALL
case|:
case|case
name|AIC_OP_JNE
case|:
case|case
name|AIC_OP_JNZ
case|:
case|case
name|AIC_OP_JE
case|:
case|case
name|AIC_OP_JZ
case|:
block|{
name|struct
name|patch
modifier|*
name|cur_patch
decl_stmt|;
name|int
name|address_offset
decl_stmt|;
name|u_int
name|address
decl_stmt|;
name|int
name|skip_addr
decl_stmt|;
name|int
name|i
decl_stmt|;
name|fmt3_ins
operator|=
operator|&
name|instr
operator|.
name|format3
expr_stmt|;
name|address_offset
operator|=
literal|0
expr_stmt|;
name|address
operator|=
name|fmt3_ins
operator|->
name|address
expr_stmt|;
name|cur_patch
operator|=
name|patches
expr_stmt|;
name|skip_addr
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|address
condition|;
control|)
block|{
name|ahc_check_patch
argument_list|(
name|ahc
argument_list|,
operator|&
name|cur_patch
argument_list|,
name|i
argument_list|,
operator|&
name|skip_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|skip_addr
operator|>
name|i
condition|)
block|{
name|int
name|end_addr
decl_stmt|;
name|end_addr
operator|=
name|MIN
argument_list|(
name|address
argument_list|,
name|skip_addr
argument_list|)
expr_stmt|;
name|address_offset
operator|+=
name|end_addr
operator|-
name|i
expr_stmt|;
name|i
operator|=
name|skip_addr
expr_stmt|;
block|}
else|else
block|{
name|i
operator|++
expr_stmt|;
block|}
block|}
name|address
operator|-=
name|address_offset
expr_stmt|;
name|fmt3_ins
operator|->
name|address
operator|=
name|address
expr_stmt|;
comment|/* FALLTHROUGH */
block|}
case|case
name|AIC_OP_OR
case|:
case|case
name|AIC_OP_AND
case|:
case|case
name|AIC_OP_XOR
case|:
case|case
name|AIC_OP_ADD
case|:
case|case
name|AIC_OP_ADC
case|:
case|case
name|AIC_OP_BMOV
case|:
if|if
condition|(
name|fmt1_ins
operator|->
name|parity
operator|!=
literal|0
condition|)
block|{
name|fmt1_ins
operator|->
name|immediate
operator|=
name|dconsts
index|[
name|fmt1_ins
operator|->
name|immediate
index|]
expr_stmt|;
block|}
name|fmt1_ins
operator|->
name|parity
operator|=
literal|0
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
name|AIC_OP_ROL
case|:
if|if
condition|(
operator|(
name|ahc
operator|->
name|features
operator|&
name|AHC_ULTRA2
operator|)
operator|!=
literal|0
condition|)
block|{
name|int
name|i
decl_stmt|,
name|count
decl_stmt|;
comment|/* Calculate odd parity for the instruction */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|count
operator|=
literal|0
init|;
name|i
operator|<
literal|31
condition|;
name|i
operator|++
control|)
block|{
name|u_int32_t
name|mask
decl_stmt|;
name|mask
operator|=
literal|0x01
operator|<<
name|i
expr_stmt|;
if|if
condition|(
operator|(
name|instr
operator|.
name|integer
operator|&
name|mask
operator|)
operator|!=
literal|0
condition|)
name|count
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|count
operator|&
literal|0x01
operator|)
operator|==
literal|0
condition|)
name|instr
operator|.
name|format1
operator|.
name|parity
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* Compress the instruction for older sequencers */
if|if
condition|(
name|fmt3_ins
operator|!=
name|NULL
condition|)
block|{
name|instr
operator|.
name|integer
operator|=
name|fmt3_ins
operator|->
name|immediate
operator||
operator|(
name|fmt3_ins
operator|->
name|source
operator|<<
literal|8
operator|)
operator||
operator|(
name|fmt3_ins
operator|->
name|address
operator|<<
literal|16
operator|)
operator||
operator|(
name|fmt3_ins
operator|->
name|opcode
operator|<<
literal|25
operator|)
expr_stmt|;
block|}
else|else
block|{
name|instr
operator|.
name|integer
operator|=
name|fmt1_ins
operator|->
name|immediate
operator||
operator|(
name|fmt1_ins
operator|->
name|source
operator|<<
literal|8
operator|)
operator||
operator|(
name|fmt1_ins
operator|->
name|destination
operator|<<
literal|16
operator|)
operator||
operator|(
name|fmt1_ins
operator|->
name|ret
operator|<<
literal|24
operator|)
operator||
operator|(
name|fmt1_ins
operator|->
name|opcode
operator|<<
literal|25
operator|)
expr_stmt|;
block|}
block|}
name|ahc_outsb
argument_list|(
name|ahc
argument_list|,
name|SEQRAM
argument_list|,
name|instr
operator|.
name|bytes
argument_list|,
literal|4
argument_list|)
expr_stmt|;
break|break;
default|default:
name|panic
argument_list|(
literal|"Unknown opcode encountered in seq program"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ahc_set_recoveryscb
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|struct
name|scb
modifier|*
name|scb
parameter_list|)
block|{
if|if
condition|(
operator|(
name|scb
operator|->
name|flags
operator|&
name|SCB_RECOVERY_SCB
operator|)
operator|==
literal|0
condition|)
block|{
name|struct
name|ccb_hdr
modifier|*
name|ccbh
decl_stmt|;
name|scb
operator|->
name|flags
operator||=
name|SCB_RECOVERY_SCB
expr_stmt|;
comment|/* 		 * Take all queued, but not sent SCBs out of the equation. 		 * Also ensure that no new CCBs are queued to us while we 		 * try to fix this problem. 		 */
if|if
condition|(
operator|(
name|scb
operator|->
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_RELEASE_SIMQ
operator|)
operator|==
literal|0
condition|)
block|{
name|xpt_freeze_simq
argument_list|(
name|ahc
operator|->
name|sim
argument_list|,
comment|/*count*/
literal|1
argument_list|)
expr_stmt|;
name|scb
operator|->
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_RELEASE_SIMQ
expr_stmt|;
block|}
comment|/* 		 * Go through all of our pending SCBs and remove 		 * any scheduled timeouts for them.  We will reschedule 		 * them after we've successfully fixed this problem. 		 */
name|ccbh
operator|=
name|ahc
operator|->
name|pending_ccbs
operator|.
name|lh_first
expr_stmt|;
while|while
condition|(
name|ccbh
operator|!=
name|NULL
condition|)
block|{
name|struct
name|scb
modifier|*
name|pending_scb
decl_stmt|;
name|pending_scb
operator|=
operator|(
expr|struct
name|scb
operator|*
operator|)
name|ccbh
operator|->
name|ccb_scb_ptr
expr_stmt|;
name|untimeout
argument_list|(
name|ahc_timeout
argument_list|,
name|pending_scb
argument_list|,
name|ccbh
operator|->
name|timeout_ch
argument_list|)
expr_stmt|;
name|ccbh
operator|=
name|ccbh
operator|->
name|sim_links
operator|.
name|le
operator|.
name|le_next
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ahc_timeout
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|scb
modifier|*
name|scb
decl_stmt|;
name|struct
name|ahc_softc
modifier|*
name|ahc
decl_stmt|;
name|int
name|s
decl_stmt|,
name|found
decl_stmt|;
name|u_int
name|bus_state
decl_stmt|;
name|int
name|target
decl_stmt|;
name|int
name|lun
decl_stmt|;
name|char
name|channel
decl_stmt|;
name|scb
operator|=
operator|(
expr|struct
name|scb
operator|*
operator|)
name|arg
expr_stmt|;
name|ahc
operator|=
operator|(
expr|struct
name|ahc_softc
operator|*
operator|)
name|scb
operator|->
name|ccb
operator|->
name|ccb_h
operator|.
name|ccb_ahc_ptr
expr_stmt|;
name|s
operator|=
name|splcam
argument_list|()
expr_stmt|;
comment|/* 	 * Ensure that the card doesn't do anything 	 * behind our back.  Also make sure that we 	 * didn't "just" miss an interrupt that would 	 * affect this timeout. 	 */
do|do
block|{
name|ahc_intr
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
name|pause_sequencer
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|INTSTAT
argument_list|)
operator|&
name|INT_PEND
condition|)
do|;
if|if
condition|(
operator|(
name|scb
operator|->
name|flags
operator|&
name|SCB_ACTIVE
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* Previous timeout took care of me already */
name|printf
argument_list|(
literal|"Timedout SCB handled by another timeout\n"
argument_list|)
expr_stmt|;
name|unpause_sequencer
argument_list|(
name|ahc
argument_list|,
comment|/*unpause_always*/
name|TRUE
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
name|target
operator|=
name|SCB_TARGET
argument_list|(
name|scb
argument_list|)
expr_stmt|;
name|channel
operator|=
name|SCB_CHANNEL
argument_list|(
name|scb
argument_list|)
expr_stmt|;
name|lun
operator|=
name|SCB_LUN
argument_list|(
name|scb
argument_list|)
expr_stmt|;
name|xpt_print_path
argument_list|(
name|scb
operator|->
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"SCB 0x%x - timed out "
argument_list|,
name|scb
operator|->
name|hscb
operator|->
name|tag
argument_list|)
expr_stmt|;
comment|/* 	 * Take a snapshot of the bus state and print out 	 * some information so we can track down driver bugs. 	 */
name|bus_state
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|LASTPHASE
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|bus_state
condition|)
block|{
case|case
name|P_DATAOUT
case|:
name|printf
argument_list|(
literal|"in dataout phase"
argument_list|)
expr_stmt|;
break|break;
case|case
name|P_DATAIN
case|:
name|printf
argument_list|(
literal|"in datain phase"
argument_list|)
expr_stmt|;
break|break;
case|case
name|P_COMMAND
case|:
name|printf
argument_list|(
literal|"in command phase"
argument_list|)
expr_stmt|;
break|break;
case|case
name|P_MESGOUT
case|:
name|printf
argument_list|(
literal|"in message out phase"
argument_list|)
expr_stmt|;
break|break;
case|case
name|P_STATUS
case|:
name|printf
argument_list|(
literal|"in status phase"
argument_list|)
expr_stmt|;
break|break;
case|case
name|P_MESGIN
case|:
name|printf
argument_list|(
literal|"in message in phase"
argument_list|)
expr_stmt|;
break|break;
case|case
name|P_BUSFREE
case|:
name|printf
argument_list|(
literal|"while idle, LASTPHASE == 0x%x"
argument_list|,
name|bus_state
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/*  		 * We aren't in a valid phase, so assume we're 		 * idle. 		 */
name|printf
argument_list|(
literal|"invalid phase, LASTPHASE == 0x%x"
argument_list|,
name|bus_state
argument_list|)
expr_stmt|;
name|bus_state
operator|=
name|P_BUSFREE
expr_stmt|;
break|break;
block|}
name|printf
argument_list|(
literal|", SCSISIGI == 0x%x\n"
argument_list|,
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCSISIGI
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"SEQADDR == 0x%x\n"
argument_list|,
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SEQADDR0
argument_list|)
operator||
operator|(
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SEQADDR1
argument_list|)
operator|<<
literal|8
operator|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"SSTAT1 == 0x%x\n"
argument_list|,
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SSTAT1
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|printf("SCSIRATE == 0x%x\n", ahc_inb(ahc, SCSIRATE)); 	printf("CCSCBCTL == 0x%x\n", ahc_inb(ahc, CCSCBCTL)); 	printf("CCSCBCNT == 0x%x\n", ahc_inb(ahc, CCSCBCNT)); 	printf("DFCNTRL == 0x%x\n", ahc_inb(ahc, DFCNTRL)); 	printf("DFSTATUS == 0x%x\n", ahc_inb(ahc, DFSTATUS)); 	printf("CCHCNT == 0x%x\n", ahc_inb(ahc, CCHCNT));
endif|#
directive|endif
comment|/* Decide our course of action */
if|if
condition|(
name|scb
operator|->
name|flags
operator|&
name|SCB_DEVICE_RESET
condition|)
block|{
comment|/* 		 * Been down this road before. 		 * Do a full bus reset. 		 */
name|bus_reset
label|:
name|ahc_set_ccb_status
argument_list|(
name|scb
operator|->
name|ccb
argument_list|,
name|CAM_CMD_TIMEOUT
argument_list|)
expr_stmt|;
name|found
operator|=
name|ahc_reset_channel
argument_list|(
name|ahc
argument_list|,
name|channel
argument_list|,
comment|/*Initiate Reset*/
name|TRUE
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s: Issued Channel %c Bus Reset. "
literal|"%d SCBs aborted\n"
argument_list|,
name|ahc_name
argument_list|(
name|ahc
argument_list|)
argument_list|,
name|channel
argument_list|,
name|found
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Send a Bus Device Reset message: 		 * The target that is holding up the bus may not 		 * be the same as the one that triggered this timeout 		 * (different commands have different timeout lengths). 		 * Our strategy here is to queue a BDR message 		 * to the timed out target if the bus is idle. 		 * Otherwise, if we have an active target we stuff the 		 * message buffer with a BDR message and assert ATN 		 * in the hopes that the target will let go of the bus 		 * and go to the mesgout phase.  If this fails, we'll 		 * get another timeout 2 seconds later which will attempt 		 * a bus reset. 		 */
name|u_int
name|active_scb_index
decl_stmt|;
name|active_scb_index
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCB_TAG
argument_list|)
expr_stmt|;
if|if
condition|(
name|bus_state
operator|!=
name|P_BUSFREE
operator|&&
operator|(
name|active_scb_index
operator|<
name|ahc
operator|->
name|scb_data
operator|->
name|numscbs
operator|)
condition|)
block|{
name|struct
name|scb
modifier|*
name|active_scb
decl_stmt|;
comment|/* 			 * If the active SCB is not from our device, 			 * assume that another device is hogging the bus 			 * and wait for it's timeout to expire before 			 * taking additional action. 			 */
name|active_scb
operator|=
name|ahc
operator|->
name|scb_data
operator|->
name|scbarray
index|[
name|active_scb_index
index|]
expr_stmt|;
if|if
condition|(
name|active_scb
operator|->
name|hscb
operator|->
name|tcl
operator|!=
name|scb
operator|->
name|hscb
operator|->
name|tcl
operator|&&
operator|(
name|scb
operator|->
name|flags
operator|&
name|SCB_OTHERTCL_TIMEOUT
operator|)
operator|==
literal|0
condition|)
block|{
name|struct
name|ccb_hdr
modifier|*
name|ccbh
decl_stmt|;
name|u_int
name|newtimeout
decl_stmt|;
name|scb
operator|->
name|flags
operator||=
name|SCB_OTHERTCL_TIMEOUT
expr_stmt|;
name|newtimeout
operator|=
name|MAX
argument_list|(
name|active_scb
operator|->
name|ccb
operator|->
name|ccb_h
operator|.
name|timeout
argument_list|,
name|scb
operator|->
name|ccb
operator|->
name|ccb_h
operator|.
name|timeout
argument_list|)
expr_stmt|;
name|ccbh
operator|=
operator|&
name|scb
operator|->
name|ccb
operator|->
name|ccb_h
expr_stmt|;
name|scb
operator|->
name|ccb
operator|->
name|ccb_h
operator|.
name|timeout_ch
operator|=
name|timeout
argument_list|(
name|ahc_timeout
argument_list|,
name|scb
argument_list|,
operator|(
name|newtimeout
operator|*
name|hz
operator|)
operator|/
literal|1000
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
name|ahc_set_recoveryscb
argument_list|(
name|ahc
argument_list|,
name|active_scb
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|MSG_OUT
argument_list|,
name|MSG_BUS_DEV_RESET
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCSISIGO
argument_list|,
name|bus_state
operator||
name|ATNO
argument_list|)
expr_stmt|;
name|xpt_print_path
argument_list|(
name|active_scb
operator|->
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"BDR message in message buffer\n"
argument_list|)
expr_stmt|;
name|active_scb
operator|->
name|flags
operator||=
name|SCB_DEVICE_RESET
expr_stmt|;
name|active_scb
operator|->
name|ccb
operator|->
name|ccb_h
operator|.
name|timeout_ch
operator|=
name|timeout
argument_list|(
name|ahc_timeout
argument_list|,
operator|(
name|caddr_t
operator|)
name|active_scb
argument_list|,
literal|2
operator|*
name|hz
argument_list|)
expr_stmt|;
name|unpause_sequencer
argument_list|(
name|ahc
argument_list|,
comment|/*unpause_always*/
name|TRUE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|disconnected
decl_stmt|;
if|if
condition|(
name|ahc_search_qinfifo
argument_list|(
name|ahc
argument_list|,
name|target
argument_list|,
name|channel
argument_list|,
name|lun
argument_list|,
name|scb
operator|->
name|hscb
operator|->
name|tag
argument_list|,
comment|/*status*/
literal|0
argument_list|,
name|SEARCH_COUNT
argument_list|)
operator|>
literal|0
condition|)
block|{
name|disconnected
operator|=
name|FALSE
expr_stmt|;
block|}
else|else
block|{
name|disconnected
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
name|disconnected
condition|)
block|{
name|ahc_set_recoveryscb
argument_list|(
name|ahc
argument_list|,
name|scb
argument_list|)
expr_stmt|;
comment|/* 				 * Simply set the MK_MESSAGE control bit. 				 */
name|scb
operator|->
name|hscb
operator|->
name|control
operator||=
name|MK_MESSAGE
expr_stmt|;
name|scb
operator|->
name|flags
operator||=
name|SCB_QUEUED_MSG
operator||
name|SCB_DEVICE_RESET
expr_stmt|;
comment|/* 				 * Remove this SCB from the disconnected 				 * list so that a reconnect at this point 				 * causes a BDR. 				 */
name|ahc_search_disc_list
argument_list|(
name|ahc
argument_list|,
name|target
argument_list|,
name|channel
argument_list|,
name|lun
argument_list|,
name|scb
operator|->
name|hscb
operator|->
name|tag
argument_list|)
expr_stmt|;
name|ahc_index_busy_tcl
argument_list|(
name|ahc
argument_list|,
name|scb
operator|->
name|hscb
operator|->
name|tcl
argument_list|,
comment|/*unbusy*/
name|TRUE
argument_list|)
expr_stmt|;
comment|/* 				 * Actually re-queue this SCB in case we can 				 * select the device before it reconnects. 				 * Clear out any entries in the QINFIFO first 				 * so we are the next SCB for this target 				 * to run. 				 */
name|ahc_search_qinfifo
argument_list|(
name|ahc
argument_list|,
name|SCB_TARGET
argument_list|(
name|scb
argument_list|)
argument_list|,
name|channel
argument_list|,
name|SCB_LUN
argument_list|(
name|scb
argument_list|)
argument_list|,
name|SCB_LIST_NULL
argument_list|,
name|CAM_REQUEUE_REQ
argument_list|,
name|SEARCH_COMPLETE
argument_list|)
expr_stmt|;
name|xpt_print_path
argument_list|(
name|scb
operator|->
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Queuing a BDR SCB\n"
argument_list|)
expr_stmt|;
name|ahc
operator|->
name|qinfifo
index|[
name|ahc
operator|->
name|qinfifonext
operator|++
index|]
operator|=
name|scb
operator|->
name|hscb
operator|->
name|tag
expr_stmt|;
if|if
condition|(
operator|(
name|ahc
operator|->
name|features
operator|&
name|AHC_QUEUE_REGS
operator|)
operator|!=
literal|0
condition|)
block|{
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|HNSCB_QOFF
argument_list|,
name|ahc
operator|->
name|qinfifonext
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|KERNEL_QINPOS
argument_list|,
name|ahc
operator|->
name|qinfifonext
argument_list|)
expr_stmt|;
block|}
name|scb
operator|->
name|ccb
operator|->
name|ccb_h
operator|.
name|timeout_ch
operator|=
name|timeout
argument_list|(
name|ahc_timeout
argument_list|,
operator|(
name|caddr_t
operator|)
name|scb
argument_list|,
literal|2
operator|*
name|hz
argument_list|)
expr_stmt|;
name|unpause_sequencer
argument_list|(
name|ahc
argument_list|,
comment|/*unpause_always*/
name|FALSE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Go "immediatly" to the bus reset */
comment|/* This shouldn't happen */
name|ahc_set_recoveryscb
argument_list|(
name|ahc
argument_list|,
name|scb
argument_list|)
expr_stmt|;
name|xpt_print_path
argument_list|(
name|scb
operator|->
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"SCB %d: Immediate reset.  "
literal|"Flags = 0x%x\n"
argument_list|,
name|scb
operator|->
name|hscb
operator|->
name|tag
argument_list|,
name|scb
operator|->
name|flags
argument_list|)
expr_stmt|;
goto|goto
name|bus_reset
goto|;
block|}
block|}
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|ahc_search_qinfifo
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|int
name|target
parameter_list|,
name|char
name|channel
parameter_list|,
name|int
name|lun
parameter_list|,
name|u_int
name|tag
parameter_list|,
name|u_int32_t
name|status
parameter_list|,
name|ahc_search_action
name|action
parameter_list|)
block|{
name|struct
name|scb
modifier|*
name|scbp
decl_stmt|;
name|u_int8_t
name|qinpos
decl_stmt|;
name|u_int8_t
name|qintail
decl_stmt|;
name|int
name|found
decl_stmt|;
name|qinpos
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|QINPOS
argument_list|)
expr_stmt|;
name|qintail
operator|=
name|ahc
operator|->
name|qinfifonext
expr_stmt|;
name|found
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Start with an empty queue.  Entries that are not chosen 	 * for removal will be re-added to the queue as we go. 	 */
name|ahc
operator|->
name|qinfifonext
operator|=
name|qinpos
expr_stmt|;
while|while
condition|(
name|qinpos
operator|!=
name|qintail
condition|)
block|{
name|scbp
operator|=
name|ahc
operator|->
name|scb_data
operator|->
name|scbarray
index|[
name|ahc
operator|->
name|qinfifo
index|[
name|qinpos
index|]
index|]
expr_stmt|;
if|if
condition|(
name|ahc_match_scb
argument_list|(
name|scbp
argument_list|,
name|target
argument_list|,
name|channel
argument_list|,
name|lun
argument_list|,
name|tag
argument_list|)
condition|)
block|{
comment|/* 			 * We found an scb that needs to be removed. 			 */
switch|switch
condition|(
name|action
condition|)
block|{
case|case
name|SEARCH_COMPLETE
case|:
if|if
condition|(
name|ahc_ccb_status
argument_list|(
name|scbp
operator|->
name|ccb
argument_list|)
operator|==
name|CAM_REQ_INPROG
condition|)
name|ahc_set_ccb_status
argument_list|(
name|scbp
operator|->
name|ccb
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|ahc_freeze_ccb
argument_list|(
name|scbp
operator|->
name|ccb
argument_list|)
expr_stmt|;
name|ahc_done
argument_list|(
name|ahc
argument_list|,
name|scbp
argument_list|)
expr_stmt|;
break|break;
case|case
name|SEARCH_COUNT
case|:
name|ahc
operator|->
name|qinfifo
index|[
name|ahc
operator|->
name|qinfifonext
operator|++
index|]
operator|=
name|scbp
operator|->
name|hscb
operator|->
name|tag
expr_stmt|;
break|break;
case|case
name|SEARCH_REMOVE
case|:
break|break;
block|}
name|found
operator|++
expr_stmt|;
block|}
else|else
block|{
name|ahc
operator|->
name|qinfifo
index|[
name|ahc
operator|->
name|qinfifonext
operator|++
index|]
operator|=
name|scbp
operator|->
name|hscb
operator|->
name|tag
expr_stmt|;
block|}
name|qinpos
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|ahc
operator|->
name|features
operator|&
name|AHC_QUEUE_REGS
operator|)
operator|!=
literal|0
condition|)
block|{
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|HNSCB_QOFF
argument_list|,
name|ahc
operator|->
name|qinfifonext
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|KERNEL_QINPOS
argument_list|,
name|ahc
operator|->
name|qinfifonext
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|found
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Abort all SCBs that match the given description (target/channel/lun/tag),  * setting their status to the passed in status if the status has not already  * been modified from CAM_REQ_INPROG.  This routine assumes that the sequencer  * is paused before it is called.  */
end_comment

begin_function
specifier|static
name|int
name|ahc_abort_scbs
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|int
name|target
parameter_list|,
name|char
name|channel
parameter_list|,
name|int
name|lun
parameter_list|,
name|u_int
name|tag
parameter_list|,
name|u_int32_t
name|status
parameter_list|)
block|{
name|struct
name|scb
modifier|*
name|scbp
decl_stmt|;
name|u_int
name|active_scb
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|found
decl_stmt|;
comment|/* restore this when we're done */
name|active_scb
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCBPTR
argument_list|)
expr_stmt|;
name|found
operator|=
name|ahc_search_qinfifo
argument_list|(
name|ahc
argument_list|,
name|target
argument_list|,
name|channel
argument_list|,
name|lun
argument_list|,
name|tag
argument_list|,
name|CAM_REQUEUE_REQ
argument_list|,
name|SEARCH_COMPLETE
argument_list|)
expr_stmt|;
comment|/* 	 * Search waiting for selection list. 	 */
block|{
name|u_int8_t
name|next
decl_stmt|,
name|prev
decl_stmt|;
name|next
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|WAITING_SCBH
argument_list|)
expr_stmt|;
comment|/* Start at head of list. */
name|prev
operator|=
name|SCB_LIST_NULL
expr_stmt|;
while|while
condition|(
name|next
operator|!=
name|SCB_LIST_NULL
condition|)
block|{
name|u_int8_t
name|scb_index
decl_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCBPTR
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|scb_index
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCB_TAG
argument_list|)
expr_stmt|;
if|if
condition|(
name|scb_index
operator|>=
name|ahc
operator|->
name|scb_data
operator|->
name|numscbs
condition|)
block|{
name|panic
argument_list|(
literal|"Waiting List inconsistency. "
literal|"SCB index == %d, yet numscbs == %d."
argument_list|,
name|scb_index
argument_list|,
name|ahc
operator|->
name|scb_data
operator|->
name|numscbs
argument_list|)
expr_stmt|;
block|}
name|scbp
operator|=
name|ahc
operator|->
name|scb_data
operator|->
name|scbarray
index|[
name|scb_index
index|]
expr_stmt|;
if|if
condition|(
name|ahc_match_scb
argument_list|(
name|scbp
argument_list|,
name|target
argument_list|,
name|channel
argument_list|,
name|lun
argument_list|,
name|tag
argument_list|)
condition|)
block|{
name|next
operator|=
name|ahc_abort_wscb
argument_list|(
name|ahc
argument_list|,
name|next
argument_list|,
name|prev
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|prev
operator|=
name|next
expr_stmt|;
name|next
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCB_NEXT
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* 	 * Go through the disconnected list and remove any entries we 	 * have queued for completion, 0'ing their control byte too. 	 */
name|ahc_search_disc_list
argument_list|(
name|ahc
argument_list|,
name|target
argument_list|,
name|channel
argument_list|,
name|lun
argument_list|,
name|tag
argument_list|)
expr_stmt|;
comment|/* 	 * Go through the hardware SCB array looking for commands that 	 * were active but not on any list. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ahc
operator|->
name|scb_data
operator|->
name|maxhscbs
condition|;
name|i
operator|++
control|)
block|{
name|u_int
name|scbid
decl_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCBPTR
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|scbid
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCB_TAG
argument_list|)
expr_stmt|;
if|if
condition|(
name|scbid
operator|<
name|ahc
operator|->
name|scb_data
operator|->
name|numscbs
condition|)
block|{
name|scbp
operator|=
name|ahc
operator|->
name|scb_data
operator|->
name|scbarray
index|[
name|scbid
index|]
expr_stmt|;
if|if
condition|(
name|ahc_match_scb
argument_list|(
name|scbp
argument_list|,
name|target
argument_list|,
name|channel
argument_list|,
name|lun
argument_list|,
name|tag
argument_list|)
condition|)
block|{
name|ahc_add_curscb_to_free_list
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* 	 * Go through the pending CCB list and look for 	 * commands for this target that are still active. 	 * These are other tagged commands that were 	 * disconnected when the reset occured. 	 */
block|{
name|struct
name|ccb_hdr
modifier|*
name|ccb_h
decl_stmt|;
name|ccb_h
operator|=
name|ahc
operator|->
name|pending_ccbs
operator|.
name|lh_first
expr_stmt|;
while|while
condition|(
name|ccb_h
operator|!=
name|NULL
condition|)
block|{
name|scbp
operator|=
operator|(
expr|struct
name|scb
operator|*
operator|)
name|ccb_h
operator|->
name|ccb_scb_ptr
expr_stmt|;
name|ccb_h
operator|=
name|ccb_h
operator|->
name|sim_links
operator|.
name|le
operator|.
name|le_next
expr_stmt|;
if|if
condition|(
name|ahc_match_scb
argument_list|(
name|scbp
argument_list|,
name|target
argument_list|,
name|channel
argument_list|,
name|lun
argument_list|,
name|tag
argument_list|)
condition|)
block|{
if|if
condition|(
name|ahc_ccb_status
argument_list|(
name|scbp
operator|->
name|ccb
argument_list|)
operator|==
name|CAM_REQ_INPROG
condition|)
name|ahc_set_ccb_status
argument_list|(
name|scbp
operator|->
name|ccb
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|ahc_freeze_ccb
argument_list|(
name|scbp
operator|->
name|ccb
argument_list|)
expr_stmt|;
name|ahc_done
argument_list|(
name|ahc
argument_list|,
name|scbp
argument_list|)
expr_stmt|;
name|found
operator|++
expr_stmt|;
block|}
block|}
block|}
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCBPTR
argument_list|,
name|active_scb
argument_list|)
expr_stmt|;
return|return
name|found
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ahc_search_disc_list
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|int
name|target
parameter_list|,
name|char
name|channel
parameter_list|,
name|int
name|lun
parameter_list|,
name|u_int
name|tag
parameter_list|)
block|{
name|struct
name|scb
modifier|*
name|scbp
decl_stmt|;
name|u_int
name|next
decl_stmt|;
name|u_int
name|prev
decl_stmt|;
name|u_int
name|count
decl_stmt|;
name|u_int
name|active_scb
decl_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
name|next
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|DISCONNECTED_SCBH
argument_list|)
expr_stmt|;
name|prev
operator|=
name|SCB_LIST_NULL
expr_stmt|;
comment|/* restore this when we're done */
name|active_scb
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCBPTR
argument_list|)
expr_stmt|;
while|while
condition|(
name|next
operator|!=
name|SCB_LIST_NULL
condition|)
block|{
name|u_int
name|scb_index
decl_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCBPTR
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|scb_index
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCB_TAG
argument_list|)
expr_stmt|;
if|if
condition|(
name|scb_index
operator|>=
name|ahc
operator|->
name|scb_data
operator|->
name|numscbs
condition|)
block|{
name|panic
argument_list|(
literal|"Disconnected List inconsistency. "
literal|"SCB index == %d, yet numscbs == %d."
argument_list|,
name|scb_index
argument_list|,
name|ahc
operator|->
name|scb_data
operator|->
name|numscbs
argument_list|)
expr_stmt|;
block|}
name|scbp
operator|=
name|ahc
operator|->
name|scb_data
operator|->
name|scbarray
index|[
name|scb_index
index|]
expr_stmt|;
if|if
condition|(
name|ahc_match_scb
argument_list|(
name|scbp
argument_list|,
name|target
argument_list|,
name|channel
argument_list|,
name|lun
argument_list|,
name|tag
argument_list|)
condition|)
block|{
name|next
operator|=
name|ahc_rem_scb_from_disc_list
argument_list|(
name|ahc
argument_list|,
name|prev
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
else|else
block|{
name|prev
operator|=
name|next
expr_stmt|;
name|next
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCB_NEXT
argument_list|)
expr_stmt|;
block|}
block|}
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCBPTR
argument_list|,
name|active_scb
argument_list|)
expr_stmt|;
return|return
operator|(
name|count
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|u_int
name|ahc_rem_scb_from_disc_list
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|u_int
name|prev
parameter_list|,
name|u_int
name|scbptr
parameter_list|)
block|{
name|u_int
name|next
decl_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCBPTR
argument_list|,
name|scbptr
argument_list|)
expr_stmt|;
name|next
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCB_NEXT
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCB_CONTROL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ahc_add_curscb_to_free_list
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
if|if
condition|(
name|prev
operator|!=
name|SCB_LIST_NULL
condition|)
block|{
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCBPTR
argument_list|,
name|prev
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCB_NEXT
argument_list|,
name|next
argument_list|)
expr_stmt|;
block|}
else|else
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|DISCONNECTED_SCBH
argument_list|,
name|next
argument_list|)
expr_stmt|;
return|return
name|next
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ahc_add_curscb_to_free_list
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|)
block|{
comment|/* Invalidate the tag so that ahc_find_scb doesn't think it's active */
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCB_TAG
argument_list|,
name|SCB_LIST_NULL
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCB_NEXT
argument_list|,
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|FREE_SCBH
argument_list|)
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|FREE_SCBH
argument_list|,
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCBPTR
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Manipulate the waiting for selection list and return the  * scb that follows the one that we remove.  */
end_comment

begin_function
specifier|static
name|u_int
name|ahc_abort_wscb
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|u_int
name|scbpos
parameter_list|,
name|u_int
name|prev
parameter_list|)
block|{
name|u_int
name|curscb
decl_stmt|,
name|next
decl_stmt|;
comment|/* 	 * Select the SCB we want to abort and 	 * pull the next pointer out of it. 	 */
name|curscb
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCBPTR
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCBPTR
argument_list|,
name|scbpos
argument_list|)
expr_stmt|;
name|next
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCB_NEXT
argument_list|)
expr_stmt|;
comment|/* Clear the necessary fields */
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCB_CONTROL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ahc_add_curscb_to_free_list
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
comment|/* update the waiting list */
if|if
condition|(
name|prev
operator|==
name|SCB_LIST_NULL
condition|)
block|{
comment|/* First in the list */
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|WAITING_SCBH
argument_list|,
name|next
argument_list|)
expr_stmt|;
comment|/* 		 * Ensure we aren't attempting to perform 		 * selection for this entry. 		 */
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCSISEQ
argument_list|,
operator|(
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCSISEQ
argument_list|)
operator|&
operator|~
name|ENSELO
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Select the scb that pointed to us  		 * and update its next pointer. 		 */
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCBPTR
argument_list|,
name|prev
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCB_NEXT
argument_list|,
name|next
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Point us back at the original scb position. 	 */
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCBPTR
argument_list|,
name|curscb
argument_list|)
expr_stmt|;
return|return
name|next
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ahc_clear_intstat
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|)
block|{
comment|/* Clear any interrupt conditions this may have caused */
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|CLRSINT0
argument_list|,
name|CLRSELDO
operator||
name|CLRSELDI
operator||
name|CLRSELINGO
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|CLRSINT1
argument_list|,
name|CLRSELTIMEO
operator||
name|CLRATNO
operator||
name|CLRSCSIRSTI
operator||
name|CLRBUSFREE
operator||
name|CLRSCSIPERR
operator||
name|CLRPHASECHG
operator||
name|CLRREQINIT
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|CLRINT
argument_list|,
name|CLRSCSIINT
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ahc_reset_current_bus
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|)
block|{
name|u_int8_t
name|scsiseq
decl_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SIMODE1
argument_list|,
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SIMODE1
argument_list|)
operator|&
operator|~
name|ENSCSIRST
argument_list|)
expr_stmt|;
name|scsiseq
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCSISEQ
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCSISEQ
argument_list|,
name|scsiseq
operator||
name|SCSIRSTO
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
name|AHC_BUSRESET_DELAY
argument_list|)
expr_stmt|;
comment|/* Turn off the bus reset */
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCSISEQ
argument_list|,
name|scsiseq
operator|&
operator|~
name|SCSIRSTO
argument_list|)
expr_stmt|;
name|ahc_clear_intstat
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
comment|/* Re-enable reset interrupts */
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SIMODE1
argument_list|,
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SIMODE1
argument_list|)
operator||
name|ENSCSIRST
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|ahc_reset_channel
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|char
name|channel
parameter_list|,
name|int
name|initiate_reset
parameter_list|)
block|{
name|u_int
name|target
decl_stmt|,
name|max_target
decl_stmt|;
name|int
name|found
decl_stmt|;
name|u_int8_t
name|sblkctl
decl_stmt|;
name|char
name|cur_channel
decl_stmt|;
name|struct
name|cam_path
modifier|*
name|path
decl_stmt|;
name|pause_sequencer
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
comment|/* 	 * Clean up all the state information for the 	 * pending transactions on this bus. 	 */
name|found
operator|=
name|ahc_abort_scbs
argument_list|(
name|ahc
argument_list|,
name|ALL_TARGETS
argument_list|,
name|channel
argument_list|,
name|ALL_LUNS
argument_list|,
name|SCB_LIST_NULL
argument_list|,
name|CAM_SCSI_BUS_RESET
argument_list|)
expr_stmt|;
name|path
operator|=
name|channel
operator|==
literal|'B'
condition|?
name|ahc
operator|->
name|path_b
else|:
name|ahc
operator|->
name|path
expr_stmt|;
comment|/* Notify the XPT that a bus reset occurred */
name|xpt_async
argument_list|(
name|AC_BUS_RESET
argument_list|,
name|path
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* 	 * Revert to async/narrow transfers until we renegotiate. 	 */
name|max_target
operator|=
operator|(
name|ahc
operator|->
name|features
operator|&
name|AHC_WIDE
operator|)
condition|?
literal|15
else|:
literal|7
expr_stmt|;
for|for
control|(
name|target
operator|=
literal|0
init|;
name|target
operator|<=
name|max_target
condition|;
name|target
operator|++
control|)
block|{
name|struct
name|ahc_devinfo
name|devinfo
decl_stmt|;
name|ahc_compile_devinfo
argument_list|(
operator|&
name|devinfo
argument_list|,
name|target
argument_list|,
name|channel
argument_list|)
expr_stmt|;
name|ahc_set_width
argument_list|(
name|ahc
argument_list|,
operator|&
name|devinfo
argument_list|,
name|path
argument_list|,
name|MSG_EXT_WDTR_BUS_8_BIT
argument_list|,
name|AHC_TRANS_CUR
argument_list|)
expr_stmt|;
name|ahc_set_syncrate
argument_list|(
name|ahc
argument_list|,
operator|&
name|devinfo
argument_list|,
name|path
argument_list|,
comment|/*syncrate*/
name|NULL
argument_list|,
comment|/*period*/
literal|0
argument_list|,
comment|/*offset*/
literal|0
argument_list|,
name|AHC_TRANS_CUR
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Reset the bus if we are initiating this reset and 	 * restart/unpause the sequencer 	 */
name|sblkctl
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SBLKCTL
argument_list|)
expr_stmt|;
name|cur_channel
operator|=
literal|'A'
expr_stmt|;
if|if
condition|(
operator|(
name|ahc
operator|->
name|features
operator|&
name|AHC_TWIN
operator|)
operator|!=
literal|0
operator|&&
operator|(
operator|(
name|sblkctl
operator|&
name|SELBUSB
operator|)
operator|!=
literal|0
operator|)
condition|)
name|cur_channel
operator|=
literal|'B'
expr_stmt|;
if|if
condition|(
name|cur_channel
operator|!=
name|channel
condition|)
block|{
comment|/* Case 1: Command for another bus is active 		 * Stealthily reset the other bus without 		 * upsetting the current bus. 		 */
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SBLKCTL
argument_list|,
name|sblkctl
operator|^
name|SELBUSB
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SIMODE1
argument_list|,
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SIMODE1
argument_list|)
operator|&
operator|~
operator|(
name|ENBUSFREE
operator||
name|ENREQINIT
operator|)
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCSISEQ
argument_list|,
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCSISEQ
argument_list|)
operator|&
operator|(
name|ENSELI
operator||
name|ENRSELI
operator||
name|ENAUTOATNP
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|initiate_reset
condition|)
name|ahc_reset_current_bus
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
name|ahc_clear_intstat
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SBLKCTL
argument_list|,
name|sblkctl
argument_list|)
expr_stmt|;
name|unpause_sequencer
argument_list|(
name|ahc
argument_list|,
comment|/*unpause_always*/
name|FALSE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Case 2: A command from this bus is active or we're idle */
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SIMODE1
argument_list|,
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SIMODE1
argument_list|)
operator|&
operator|~
operator|(
name|ENBUSFREE
operator||
name|ENREQINIT
operator|)
argument_list|)
expr_stmt|;
name|ahc
operator|->
name|flags
operator|&=
operator|~
name|AHC_HANDLING_REQINITS
expr_stmt|;
name|ahc
operator|->
name|msg_type
operator|=
name|MSG_TYPE_NONE
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCSISEQ
argument_list|,
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCSISEQ
argument_list|)
operator|&
operator|(
name|ENSELI
operator||
name|ENRSELI
operator||
name|ENAUTOATNP
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|initiate_reset
condition|)
name|ahc_reset_current_bus
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
name|ahc_clear_intstat
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
name|restart_sequencer
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
block|}
return|return
name|found
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ahc_match_scb
parameter_list|(
name|struct
name|scb
modifier|*
name|scb
parameter_list|,
name|int
name|target
parameter_list|,
name|char
name|channel
parameter_list|,
name|int
name|lun
parameter_list|,
name|u_int
name|tag
parameter_list|)
block|{
name|int
name|targ
init|=
name|SCB_TARGET
argument_list|(
name|scb
argument_list|)
decl_stmt|;
name|char
name|chan
init|=
name|SCB_CHANNEL
argument_list|(
name|scb
argument_list|)
decl_stmt|;
name|int
name|slun
init|=
name|SCB_LUN
argument_list|(
name|scb
argument_list|)
decl_stmt|;
name|int
name|match
decl_stmt|;
name|match
operator|=
operator|(
operator|(
name|chan
operator|==
name|channel
operator|)
operator|||
operator|(
name|channel
operator|==
name|ALL_CHANNELS
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|match
operator|!=
literal|0
condition|)
name|match
operator|=
operator|(
operator|(
name|targ
operator|==
name|target
operator|)
operator|||
operator|(
name|target
operator|==
name|ALL_TARGETS
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|match
operator|!=
literal|0
condition|)
name|match
operator|=
operator|(
operator|(
name|lun
operator|==
name|slun
operator|)
operator|||
operator|(
name|lun
operator|==
name|ALL_LUNS
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|match
operator|!=
literal|0
condition|)
name|match
operator|=
operator|(
operator|(
name|tag
operator|==
name|scb
operator|->
name|hscb
operator|->
name|tag
operator|)
operator|||
operator|(
name|tag
operator|==
name|SCB_LIST_NULL
operator|)
operator|)
expr_stmt|;
return|return
name|match
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ahc_construct_sdtr
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|u_int
name|period
parameter_list|,
name|u_int
name|offset
parameter_list|)
block|{
name|ahc
operator|->
name|msg_buf
index|[
name|ahc
operator|->
name|msg_index
operator|++
index|]
operator|=
name|MSG_EXTENDED
expr_stmt|;
name|ahc
operator|->
name|msg_buf
index|[
name|ahc
operator|->
name|msg_index
operator|++
index|]
operator|=
name|MSG_EXT_SDTR_LEN
expr_stmt|;
name|ahc
operator|->
name|msg_buf
index|[
name|ahc
operator|->
name|msg_index
operator|++
index|]
operator|=
name|MSG_EXT_SDTR
expr_stmt|;
name|ahc
operator|->
name|msg_buf
index|[
name|ahc
operator|->
name|msg_index
operator|++
index|]
operator|=
name|period
expr_stmt|;
name|ahc
operator|->
name|msg_buf
index|[
name|ahc
operator|->
name|msg_index
operator|++
index|]
operator|=
name|offset
expr_stmt|;
name|ahc
operator|->
name|msg_len
operator|+=
literal|5
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ahc_construct_wdtr
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|u_int
name|bus_width
parameter_list|)
block|{
name|ahc
operator|->
name|msg_buf
index|[
name|ahc
operator|->
name|msg_index
operator|++
index|]
operator|=
name|MSG_EXTENDED
expr_stmt|;
name|ahc
operator|->
name|msg_buf
index|[
name|ahc
operator|->
name|msg_index
operator|++
index|]
operator|=
name|MSG_EXT_WDTR_LEN
expr_stmt|;
name|ahc
operator|->
name|msg_buf
index|[
name|ahc
operator|->
name|msg_index
operator|++
index|]
operator|=
name|MSG_EXT_WDTR
expr_stmt|;
name|ahc
operator|->
name|msg_buf
index|[
name|ahc
operator|->
name|msg_index
operator|++
index|]
operator|=
name|bus_width
expr_stmt|;
name|ahc
operator|->
name|msg_len
operator|+=
literal|4
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ahc_calc_residual
parameter_list|(
name|struct
name|scb
modifier|*
name|scb
parameter_list|)
block|{
name|struct
name|hardware_scb
modifier|*
name|hscb
decl_stmt|;
name|hscb
operator|=
name|scb
operator|->
name|hscb
expr_stmt|;
comment|/* 	 * If the disconnected flag is still set, this is bogus 	 * residual information left over from a sequencer 	 * pagin/pageout, so ignore this case. 	 */
if|if
condition|(
operator|(
name|scb
operator|->
name|hscb
operator|->
name|control
operator|&
name|DISCONNECTED
operator|)
operator|==
literal|0
condition|)
block|{
name|u_int32_t
name|resid
decl_stmt|;
name|int
name|resid_sgs
decl_stmt|;
name|int
name|sg
decl_stmt|;
comment|/* 		 * Remainder of the SG where the transfer 		 * stopped. 		 */
name|resid
operator|=
operator|(
name|hscb
operator|->
name|residual_data_count
index|[
literal|2
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
name|hscb
operator|->
name|residual_data_count
index|[
literal|1
index|]
operator|<<
literal|8
operator|)
operator||
operator|(
name|hscb
operator|->
name|residual_data_count
index|[
literal|0
index|]
operator|)
expr_stmt|;
comment|/* 		 * Add up the contents of all residual 		 * SG segments that are after the SG where 		 * the transfer stopped. 		 */
name|resid_sgs
operator|=
name|scb
operator|->
name|hscb
operator|->
name|residual_SG_count
operator|-
literal|1
comment|/*current*/
expr_stmt|;
name|sg
operator|=
name|scb
operator|->
name|sg_count
operator|-
name|resid_sgs
operator|-
literal|1
comment|/*first SG*/
expr_stmt|;
while|while
condition|(
name|resid_sgs
operator|>
literal|0
condition|)
block|{
name|resid
operator|+=
name|scb
operator|->
name|ahc_dma
index|[
name|sg
index|]
operator|.
name|len
expr_stmt|;
name|sg
operator|++
expr_stmt|;
name|resid_sgs
operator|--
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|scb
operator|->
name|flags
operator|&
name|SCB_SENSE
operator|)
operator|==
literal|0
condition|)
block|{
name|scb
operator|->
name|ccb
operator|->
name|csio
operator|.
name|resid
operator|=
name|resid
expr_stmt|;
block|}
else|else
block|{
name|scb
operator|->
name|ccb
operator|->
name|csio
operator|.
name|sense_resid
operator|=
name|resid
expr_stmt|;
block|}
block|}
comment|/* 	 * Clean out the residual information in this SCB for its 	 * next consumer. 	 */
name|hscb
operator|->
name|residual_data_count
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|hscb
operator|->
name|residual_data_count
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|hscb
operator|->
name|residual_data_count
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|hscb
operator|->
name|residual_SG_count
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|AHC_DEBUG
if|if
condition|(
name|ahc_debug
operator|&
name|AHC_SHOWMISC
condition|)
block|{
name|sc_print_addr
argument_list|(
name|xs
operator|->
name|sc_link
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Handled Residual of %ld bytes\n"
argument_list|,
name|xs
operator|->
name|resid
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|void
name|ahc_update_pending_syncrates
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|)
block|{
comment|/* 	 * Traverse the pending SCB list and ensure that all of the 	 * SCBs there have the proper settings. 	 */
name|struct
name|ccb_hdr
modifier|*
name|ccbh
decl_stmt|;
name|int
name|pending_ccb_count
decl_stmt|;
name|int
name|i
decl_stmt|;
name|u_int
name|saved_scbptr
decl_stmt|;
comment|/* 	 * We were able to complete the command successfully, 	 * so reinstate the timeouts for all other pending 	 * commands. 	 */
name|ccbh
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|ahc
operator|->
name|pending_ccbs
argument_list|)
expr_stmt|;
name|pending_ccb_count
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|ccbh
operator|!=
name|NULL
condition|)
block|{
name|struct
name|scb
modifier|*
name|pending_scb
decl_stmt|;
name|struct
name|hardware_scb
modifier|*
name|pending_hscb
decl_stmt|;
name|struct
name|ahc_target_tinfo
modifier|*
name|tinfo
decl_stmt|;
name|struct
name|ahc_devinfo
name|devinfo
decl_stmt|;
name|pending_scb
operator|=
operator|(
expr|struct
name|scb
operator|*
operator|)
name|ccbh
operator|->
name|ccb_scb_ptr
expr_stmt|;
name|pending_hscb
operator|=
name|pending_scb
operator|->
name|hscb
expr_stmt|;
name|ahc_compile_devinfo
argument_list|(
operator|&
name|devinfo
argument_list|,
name|SCB_TARGET
argument_list|(
name|pending_scb
argument_list|)
argument_list|,
name|SCB_CHANNEL
argument_list|(
name|pending_scb
argument_list|)
argument_list|)
expr_stmt|;
name|tinfo
operator|=
operator|&
name|ahc
operator|->
name|transinfo
index|[
name|devinfo
operator|.
name|target_offset
index|]
expr_stmt|;
name|pending_hscb
operator|->
name|control
operator|&=
operator|~
name|ULTRAENB
expr_stmt|;
if|if
condition|(
operator|(
name|ahc
operator|->
name|ultraenb
operator|&
name|devinfo
operator|.
name|target_mask
operator|)
operator|!=
literal|0
condition|)
name|pending_hscb
operator|->
name|control
operator||=
name|ULTRAENB
expr_stmt|;
name|pending_hscb
operator|->
name|scsirate
operator|=
name|tinfo
operator|->
name|scsirate
expr_stmt|;
name|pending_hscb
operator|->
name|scsioffset
operator|=
name|tinfo
operator|->
name|current
operator|.
name|offset
expr_stmt|;
name|pending_ccb_count
operator|++
expr_stmt|;
name|ccbh
operator|=
name|LIST_NEXT
argument_list|(
name|ccbh
argument_list|,
name|sim_links
operator|.
name|le
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pending_ccb_count
operator|==
literal|0
condition|)
return|return;
name|saved_scbptr
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCBPTR
argument_list|)
expr_stmt|;
comment|/* Ensure that the hscbs down on the card match the new information */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ahc
operator|->
name|scb_data
operator|->
name|maxhscbs
condition|;
name|i
operator|++
control|)
block|{
name|u_int
name|scb_tag
decl_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCBPTR
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|scb_tag
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCB_TAG
argument_list|)
expr_stmt|;
if|if
condition|(
name|scb_tag
operator|!=
name|SCB_LIST_NULL
condition|)
block|{
name|struct
name|scb
modifier|*
name|pending_scb
decl_stmt|;
name|struct
name|hardware_scb
modifier|*
name|pending_hscb
decl_stmt|;
name|struct
name|ahc_target_tinfo
modifier|*
name|tinfo
decl_stmt|;
name|struct
name|ahc_devinfo
name|devinfo
decl_stmt|;
name|u_int
name|control
decl_stmt|;
name|pending_scb
operator|=
name|ahc
operator|->
name|scb_data
operator|->
name|scbarray
index|[
name|scb_tag
index|]
expr_stmt|;
name|pending_hscb
operator|=
name|pending_scb
operator|->
name|hscb
expr_stmt|;
name|ahc_compile_devinfo
argument_list|(
operator|&
name|devinfo
argument_list|,
name|SCB_TARGET
argument_list|(
name|pending_scb
argument_list|)
argument_list|,
name|SCB_CHANNEL
argument_list|(
name|pending_scb
argument_list|)
argument_list|)
expr_stmt|;
name|tinfo
operator|=
operator|&
name|ahc
operator|->
name|transinfo
index|[
name|devinfo
operator|.
name|target_offset
index|]
expr_stmt|;
name|control
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCB_CONTROL
argument_list|)
expr_stmt|;
name|control
operator|&=
operator|~
name|ULTRAENB
expr_stmt|;
if|if
condition|(
operator|(
name|ahc
operator|->
name|ultraenb
operator|&
name|devinfo
operator|.
name|target_mask
operator|)
operator|!=
literal|0
condition|)
name|control
operator||=
name|ULTRAENB
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCB_CONTROL
argument_list|,
name|control
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCB_SCSIRATE
argument_list|,
name|tinfo
operator|->
name|scsirate
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCB_SCSIOFFSET
argument_list|,
name|tinfo
operator|->
name|current
operator|.
name|offset
argument_list|)
expr_stmt|;
block|}
block|}
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCBPTR
argument_list|,
name|saved_scbptr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ahc_dump_targcmd
parameter_list|(
name|struct
name|target_cmd
modifier|*
name|cmd
parameter_list|)
block|{
name|u_int8_t
modifier|*
name|byte
decl_stmt|;
name|u_int8_t
modifier|*
name|last_byte
decl_stmt|;
name|int
name|initiator
decl_stmt|;
name|int
name|target
decl_stmt|;
name|int
name|lun
decl_stmt|;
name|int
name|i
decl_stmt|;
name|byte
operator|=
operator|&
name|cmd
operator|->
name|icl
expr_stmt|;
comment|/* Debugging info for received commands */
name|last_byte
operator|=
operator|&
name|cmd
index|[
literal|1
index|]
operator|.
name|icl
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|byte
operator|<
name|last_byte
condition|)
block|{
if|if
condition|(
name|i
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"\t"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%#x"
argument_list|,
operator|*
name|byte
operator|++
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|8
condition|)
block|{
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ahc_shutdown
parameter_list|(
name|int
name|howto
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ahc_softc
modifier|*
name|ahc
decl_stmt|;
name|int
name|i
decl_stmt|;
name|ahc
operator|=
operator|(
expr|struct
name|ahc_softc
operator|*
operator|)
name|arg
expr_stmt|;
name|ahc_reset
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCSISEQ
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SXFRCTL0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|DSPCISTATUS
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|TARG_SCSIRATE
init|;
name|i
operator|<
name|HA_274_BIOSCTRL
condition|;
name|i
operator|++
control|)
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|i
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

