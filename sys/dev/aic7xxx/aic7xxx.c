begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Generic driver for the aic7xxx based adaptec SCSI controllers  * Product specific probe and attach routines can be found in:  * i386/eisa/ahc_eisa.c	27/284X and aic7770 motherboard controllers  * pci/ahc_pci.c	3985, 3980, 3940, 2940, aic7895, aic7890,  *			aic7880, aic7870, aic7860, and aic7850 controllers  *  * Copyright (c) 1994, 1995, 1996, 1997, 1998, 1999 Justin T. Gibbs.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions, and the following disclaimer,  *    without modification.  * 2. The name of the author may not be used to endorse or promote products  *    derived from this software without specific prior written permission.  *  * Alternatively, this software may be distributed under the terms of the  * the GNU Public License ("GPL").  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE FOR  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_comment
comment|/*  * A few notes on features of the driver.  *  * SCB paging takes advantage of the fact that devices stay disconnected  * from the bus a relatively long time and that while they're disconnected,  * having the SCBs for these transactions down on the host adapter is of  * little use.  Instead of leaving this idle SCB down on the card we copy  * it back up into kernel memory and reuse the SCB slot on the card to  * schedule another transaction.  This can be a real payoff when doing random  * I/O to tagged queueing devices since there are more transactions active at  * once for the device to sort for optimal seek reduction. The algorithm goes  * like this...  *  * The sequencer maintains two lists of its hardware SCBs.  The first is the  * singly linked free list which tracks all SCBs that are not currently in  * use.  The second is the doubly linked disconnected list which holds the  * SCBs of transactions that are in the disconnected state sorted most  * recently disconnected first.  When the kernel queues a transaction to  * the card, a hardware SCB to "house" this transaction is retrieved from  * either of these two lists.  If the SCB came from the disconnected list,  * a check is made to see if any data transfer or SCB linking (more on linking  * in a bit) information has been changed since it was copied from the host  * and if so, DMAs the SCB back up before it can be used.  Once a hardware  * SCB has been obtained, the SCB is DMAed from the host.  Before any work  * can begin on this SCB, the sequencer must ensure that either the SCB is  * for a tagged transaction or the target is not already working on another  * non-tagged transaction.  If a conflict arises in the non-tagged case, the  * sequencer finds the SCB for the active transactions and sets the SCB_LINKED  * field in that SCB to this next SCB to execute.  To facilitate finding  * active non-tagged SCBs, the last four bytes of up to the first four hardware  * SCBs serve as a storage area for the currently active SCB ID for each  * target.  *  * When a device reconnects, a search is made of the hardware SCBs to find  * the SCB for this transaction.  If the search fails, a hardware SCB is  * pulled from either the free or disconnected SCB list and the proper  * SCB is DMAed from the host.  If the MK_MESSAGE control bit is set  * in the control byte of the SCB while it was disconnected, the sequencer  * will assert ATN and attempt to issue a message to the host.  *  * When a command completes, a check for non-zero status and residuals is  * made.  If either of these conditions exists, the SCB is DMAed back up to  * the host so that it can interpret this information.  Additionally, in the  * case of bad status, the sequencer generates a special interrupt and pauses  * itself.  This allows the host to setup a request sense command if it   * chooses for this target synchronously with the error so that sense  * information isn't lost.  *  */
end_comment

begin_include
include|#
directive|include
file|<opt_aic7xxx.h>
end_include

begin_include
include|#
directive|include
file|<pci.h>
end_include

begin_include
include|#
directive|include
file|<stddef.h>
end_include

begin_comment
comment|/* For offsetof */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/eventhandler.h>
end_include

begin_include
include|#
directive|include
file|<sys/buf.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_ccb.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_sim.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_xpt_sim.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_debug.h>
end_include

begin_include
include|#
directive|include
file|<cam/scsi/scsi_all.h>
end_include

begin_include
include|#
directive|include
file|<cam/scsi/scsi_message.h>
end_include

begin_if
if|#
directive|if
name|NPCI
operator|>
literal|0
end_if

begin_include
include|#
directive|include
file|<machine/bus_memio.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<machine/bus_pio.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/clock.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_param.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<dev/aic7xxx/aic7xxx.h>
end_include

begin_include
include|#
directive|include
file|<dev/aic7xxx/sequencer.h>
end_include

begin_include
include|#
directive|include
file|<aic7xxx_reg.h>
end_include

begin_include
include|#
directive|include
file|<aic7xxx_seq.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|AHC_TMODE_ENABLE
end_ifndef

begin_define
define|#
directive|define
name|AHC_TMODE_ENABLE
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|MAX
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|(((a)> (b)) ? (a) : (b))
end_define

begin_define
define|#
directive|define
name|MIN
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|(((a)< (b)) ? (a) : (b))
end_define

begin_define
define|#
directive|define
name|ALL_CHANNELS
value|'\0'
end_define

begin_define
define|#
directive|define
name|ALL_TARGETS_MASK
value|0xFFFF
end_define

begin_define
define|#
directive|define
name|INITIATOR_WILDCARD
value|(~0)
end_define

begin_define
define|#
directive|define
name|SIM_IS_SCSIBUS_B
parameter_list|(
name|ahc
parameter_list|,
name|sim
parameter_list|)
define|\
value|((sim) == ahc->sim_b)
end_define

begin_define
define|#
directive|define
name|SIM_CHANNEL
parameter_list|(
name|ahc
parameter_list|,
name|sim
parameter_list|)
define|\
value|(((sim) == ahc->sim_b) ? 'B' : 'A')
end_define

begin_define
define|#
directive|define
name|SIM_SCSI_ID
parameter_list|(
name|ahc
parameter_list|,
name|sim
parameter_list|)
define|\
value|(((sim) == ahc->sim_b) ? ahc->our_id_b : ahc->our_id)
end_define

begin_define
define|#
directive|define
name|SIM_PATH
parameter_list|(
name|ahc
parameter_list|,
name|sim
parameter_list|)
define|\
value|(((sim) == ahc->sim_b) ? ahc->path_b : ahc->path)
end_define

begin_define
define|#
directive|define
name|SCB_IS_SCSIBUS_B
parameter_list|(
name|scb
parameter_list|)
define|\
value|(((scb)->hscb->tcl& SELBUSB) != 0)
end_define

begin_define
define|#
directive|define
name|SCB_TARGET
parameter_list|(
name|scb
parameter_list|)
define|\
value|(((scb)->hscb->tcl& TID)>> 4)
end_define

begin_define
define|#
directive|define
name|SCB_CHANNEL
parameter_list|(
name|scb
parameter_list|)
define|\
value|(SCB_IS_SCSIBUS_B(scb) ? 'B' : 'A')
end_define

begin_define
define|#
directive|define
name|SCB_LUN
parameter_list|(
name|scb
parameter_list|)
define|\
value|((scb)->hscb->tcl& LID)
end_define

begin_define
define|#
directive|define
name|SCB_TARGET_OFFSET
parameter_list|(
name|scb
parameter_list|)
define|\
value|(SCB_TARGET(scb) + (SCB_IS_SCSIBUS_B(scb) ? 8 : 0))
end_define

begin_define
define|#
directive|define
name|SCB_TARGET_MASK
parameter_list|(
name|scb
parameter_list|)
define|\
value|(0x01<< (SCB_TARGET_OFFSET(scb)))
end_define

begin_define
define|#
directive|define
name|TCL_CHANNEL
parameter_list|(
name|ahc
parameter_list|,
name|tcl
parameter_list|)
define|\
value|((((ahc)->features& AHC_TWIN)&& ((tcl)& SELBUSB)) ? 'B' : 'A')
end_define

begin_define
define|#
directive|define
name|TCL_SCSI_ID
parameter_list|(
name|ahc
parameter_list|,
name|tcl
parameter_list|)
define|\
value|(TCL_CHANNEL((ahc), (tcl)) == 'B' ? (ahc)->our_id_b : (ahc)->our_id)
end_define

begin_define
define|#
directive|define
name|TCL_TARGET
parameter_list|(
name|tcl
parameter_list|)
value|(((tcl)& TID)>> TCL_TARGET_SHIFT)
end_define

begin_define
define|#
directive|define
name|TCL_LUN
parameter_list|(
name|tcl
parameter_list|)
value|((tcl)& LID)
end_define

begin_define
define|#
directive|define
name|ccb_scb_ptr
value|spriv_ptr0
end_define

begin_define
define|#
directive|define
name|ccb_ahc_ptr
value|spriv_ptr1
end_define

begin_typedef
typedef|typedef
enum|enum
block|{
name|ROLE_UNKNOWN
block|,
name|ROLE_INITIATOR
block|,
name|ROLE_TARGET
block|}
name|role_t
typedef|;
end_typedef

begin_struct
struct|struct
name|ahc_devinfo
block|{
name|int
name|our_scsiid
decl_stmt|;
name|int
name|target_offset
decl_stmt|;
name|u_int16_t
name|target_mask
decl_stmt|;
name|u_int8_t
name|target
decl_stmt|;
name|u_int8_t
name|lun
decl_stmt|;
name|char
name|channel
decl_stmt|;
name|role_t
name|role
decl_stmt|;
comment|/* 				 * Only guaranteed to be correct if not 				 * in the busfree state. 				 */
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
enum|enum
block|{
name|SEARCH_COMPLETE
block|,
name|SEARCH_COUNT
block|,
name|SEARCH_REMOVE
block|}
name|ahc_search_action
typedef|;
end_typedef

begin_ifdef
ifdef|#
directive|ifdef
name|AHC_DEBUG
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|ahc_debug
init|=
name|AHC_DEBUG
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|NPCI
operator|>
literal|0
end_if

begin_function_decl
name|void
name|ahc_pci_intr
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|int
name|ahcinitscbdata
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ahcfiniscbdata
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|bus_dmamap_callback_t
name|ahcdmamapcb
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|UNUSED
end_if

begin_function_decl
specifier|static
name|void
name|ahc_dump_targcmd
parameter_list|(
name|struct
name|target_cmd
modifier|*
name|cmd
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|ahc_shutdown
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|howto
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|cam_status
name|ahc_find_tmode_devs
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|struct
name|cam_sim
modifier|*
name|sim
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|,
name|struct
name|tmode_tstate
modifier|*
modifier|*
name|tstate
parameter_list|,
name|struct
name|tmode_lstate
modifier|*
modifier|*
name|lstate
parameter_list|,
name|int
name|notfound_failure
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ahc_action
parameter_list|(
name|struct
name|cam_sim
modifier|*
name|sim
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ahc_async
parameter_list|(
name|void
modifier|*
name|callback_arg
parameter_list|,
name|u_int32_t
name|code
parameter_list|,
name|struct
name|cam_path
modifier|*
name|path
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ahc_execute_scb
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|dm_segs
parameter_list|,
name|int
name|nsegments
parameter_list|,
name|int
name|error
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ahc_poll
parameter_list|(
name|struct
name|cam_sim
modifier|*
name|sim
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ahc_setup_data
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|struct
name|ccb_scsiio
modifier|*
name|csio
parameter_list|,
name|struct
name|scb
modifier|*
name|scb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ahc_freeze_devq
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|struct
name|cam_path
modifier|*
name|path
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ahcallocscbs
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ahc_scb_devinfo
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|struct
name|ahc_devinfo
modifier|*
name|devinfo
parameter_list|,
name|struct
name|scb
modifier|*
name|scb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ahc_fetch_devinfo
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|struct
name|ahc_devinfo
modifier|*
name|devinfo
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ahc_compile_devinfo
parameter_list|(
name|struct
name|ahc_devinfo
modifier|*
name|devinfo
parameter_list|,
name|u_int
name|our_id
parameter_list|,
name|u_int
name|target
parameter_list|,
name|u_int
name|lun
parameter_list|,
name|char
name|channel
parameter_list|,
name|role_t
name|role
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u_int
name|ahc_abort_wscb
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|u_int
name|scbpos
parameter_list|,
name|u_int
name|prev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ahc_done
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|struct
name|scb
modifier|*
name|scbp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|tmode_tstate
modifier|*
name|ahc_alloc_tstate
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|u_int
name|scsi_id
parameter_list|,
name|char
name|channel
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ahc_free_tstate
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|u_int
name|scsi_id
parameter_list|,
name|char
name|channel
parameter_list|,
name|int
name|force
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ahc_handle_en_lun
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|struct
name|cam_sim
modifier|*
name|sim
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ahc_handle_target_cmd
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|struct
name|target_cmd
modifier|*
name|cmd
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ahc_handle_seqint
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|u_int
name|intstat
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ahc_handle_scsiint
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|u_int
name|intstat
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ahc_build_transfer_msg
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|struct
name|ahc_devinfo
modifier|*
name|devinfo
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ahc_setup_initiator_msgout
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|struct
name|ahc_devinfo
modifier|*
name|devinfo
parameter_list|,
name|struct
name|scb
modifier|*
name|scb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ahc_setup_target_msgin
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|struct
name|ahc_devinfo
modifier|*
name|devinfo
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ahc_handle_msg_reject
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|struct
name|ahc_devinfo
modifier|*
name|devinfo
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ahc_clear_msg_state
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ahc_handle_message_phase
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|struct
name|cam_path
modifier|*
name|path
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ahc_sent_msg
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|u_int
name|msgtype
parameter_list|,
name|int
name|full
parameter_list|)
function_decl|;
end_function_decl

begin_typedef
typedef|typedef
enum|enum
block|{
name|MSGLOOP_IN_PROG
block|,
name|MSGLOOP_MSGCOMPLETE
block|,
name|MSGLOOP_TERMINATED
block|}
name|msg_loop_stat
typedef|;
end_typedef

begin_function_decl
specifier|static
name|int
name|ahc_parse_msg
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|struct
name|cam_path
modifier|*
name|path
parameter_list|,
name|struct
name|ahc_devinfo
modifier|*
name|devinfo
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ahc_handle_ign_wide_residue
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|struct
name|ahc_devinfo
modifier|*
name|devinfo
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ahc_handle_devreset
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|struct
name|ahc_devinfo
modifier|*
name|devinfo
parameter_list|,
name|cam_status
name|status
parameter_list|,
name|ac_code
name|acode
parameter_list|,
name|char
modifier|*
name|message
parameter_list|,
name|int
name|verbose_level
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|AHC_DUMP_SEQ
end_ifdef

begin_function_decl
specifier|static
name|void
name|ahc_dumpseq
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|ahc_loadseq
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ahc_check_patch
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|struct
name|patch
modifier|*
modifier|*
name|start_patch
parameter_list|,
name|int
name|start_instr
parameter_list|,
name|int
modifier|*
name|skip_addr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ahc_download_instr
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|int
name|instrptr
parameter_list|,
name|u_int8_t
modifier|*
name|dconsts
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ahc_match_scb
parameter_list|(
name|struct
name|scb
modifier|*
name|scb
parameter_list|,
name|int
name|target
parameter_list|,
name|char
name|channel
parameter_list|,
name|int
name|lun
parameter_list|,
name|u_int
name|tag
parameter_list|,
name|role_t
name|role
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|AHC_DEBUG
end_ifdef

begin_function_decl
specifier|static
name|void
name|ahc_print_scb
parameter_list|(
name|struct
name|scb
modifier|*
name|scb
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|int
name|ahc_search_qinfifo
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|int
name|target
parameter_list|,
name|char
name|channel
parameter_list|,
name|int
name|lun
parameter_list|,
name|u_int
name|tag
parameter_list|,
name|role_t
name|role
parameter_list|,
name|u_int32_t
name|status
parameter_list|,
name|ahc_search_action
name|action
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ahc_abort_ccb
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|struct
name|cam_sim
modifier|*
name|sim
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ahc_reset_channel
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|char
name|channel
parameter_list|,
name|int
name|initiate_reset
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ahc_abort_scbs
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|int
name|target
parameter_list|,
name|char
name|channel
parameter_list|,
name|int
name|lun
parameter_list|,
name|u_int
name|tag
parameter_list|,
name|role_t
name|role
parameter_list|,
name|u_int32_t
name|status
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ahc_search_disc_list
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|int
name|target
parameter_list|,
name|char
name|channel
parameter_list|,
name|int
name|lun
parameter_list|,
name|u_int
name|tag
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u_int
name|ahc_rem_scb_from_disc_list
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|u_int
name|prev
parameter_list|,
name|u_int
name|scbptr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ahc_add_curscb_to_free_list
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ahc_clear_intstat
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ahc_reset_current_bus
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|ahc_syncrate
modifier|*
name|ahc_devlimited_syncrate
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|u_int
modifier|*
name|period
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|ahc_syncrate
modifier|*
name|ahc_find_syncrate
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|u_int
modifier|*
name|period
parameter_list|,
name|u_int
name|maxsync
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u_int
name|ahc_find_period
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|u_int
name|scsirate
parameter_list|,
name|u_int
name|maxsync
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ahc_validate_offset
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|struct
name|ahc_syncrate
modifier|*
name|syncrate
parameter_list|,
name|u_int
modifier|*
name|offset
parameter_list|,
name|int
name|wide
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ahc_update_target_msg_request
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|struct
name|ahc_devinfo
modifier|*
name|devinfo
parameter_list|,
name|struct
name|ahc_initiator_tinfo
modifier|*
name|tinfo
parameter_list|,
name|int
name|force
parameter_list|,
name|int
name|paused
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ahc_create_path
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|struct
name|ahc_devinfo
modifier|*
name|devinfo
parameter_list|,
name|struct
name|cam_path
modifier|*
modifier|*
name|path
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ahc_set_syncrate
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|struct
name|ahc_devinfo
modifier|*
name|devinfo
parameter_list|,
name|struct
name|cam_path
modifier|*
name|path
parameter_list|,
name|struct
name|ahc_syncrate
modifier|*
name|syncrate
parameter_list|,
name|u_int
name|period
parameter_list|,
name|u_int
name|offset
parameter_list|,
name|u_int
name|type
parameter_list|,
name|int
name|paused
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ahc_set_width
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|struct
name|ahc_devinfo
modifier|*
name|devinfo
parameter_list|,
name|struct
name|cam_path
modifier|*
name|path
parameter_list|,
name|u_int
name|width
parameter_list|,
name|u_int
name|type
parameter_list|,
name|int
name|paused
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ahc_set_tags
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|struct
name|ahc_devinfo
modifier|*
name|devinfo
parameter_list|,
name|int
name|enable
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ahc_construct_sdtr
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|u_int
name|period
parameter_list|,
name|u_int
name|offset
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ahc_construct_wdtr
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|u_int
name|bus_width
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ahc_calc_residual
parameter_list|(
name|struct
name|scb
modifier|*
name|scb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ahc_update_pending_syncrates
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ahc_set_recoveryscb
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|struct
name|scb
modifier|*
name|scb
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|timeout_t
name|ahc_timeout
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|ahc_queue_lstate_event
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|struct
name|tmode_lstate
modifier|*
name|lstate
parameter_list|,
name|u_int
name|initiator_id
parameter_list|,
name|u_int
name|event_type
parameter_list|,
name|u_int
name|event_arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ahc_send_lstate_events
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|struct
name|tmode_lstate
modifier|*
name|lstate
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__inline
name|int
name|sequencer_paused
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__inline
name|void
name|pause_sequencer
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__inline
name|void
name|unpause_sequencer
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|int
name|unpause_always
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__inline
name|void
name|restart_sequencer
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__inline
name|u_int
name|ahc_index_busy_tcl
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|u_int
name|tcl
parameter_list|,
name|int
name|unbusy
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__inline
name|void
name|ahc_busy_tcl
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|struct
name|scb
modifier|*
name|scb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__inline
name|void
name|ahc_freeze_ccb
parameter_list|(
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__inline
name|cam_status
name|ahc_ccb_status
parameter_list|(
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__inline
name|void
name|ahcsetccbstatus
parameter_list|(
name|union
name|ccb
modifier|*
name|ccb
parameter_list|,
name|cam_status
name|status
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ahc_run_tqinfifo
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ahc_run_qoutfifo
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|)
function_decl|;
end_function_decl

begin_expr_stmt
specifier|static
name|__inline
expr|struct
name|ahc_initiator_tinfo
operator|*
name|ahc_fetch_transinfo
argument_list|(
argument|struct ahc_softc *ahc
argument_list|,
argument|char channel
argument_list|,
argument|u_int our_id
argument_list|,
argument|u_int target
argument_list|,
argument|struct tmode_tstate **tstate
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function_decl
specifier|static
name|void
name|ahcfreescb
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|struct
name|scb
modifier|*
name|scb
parameter_list|)
function_decl|;
end_function_decl

begin_expr_stmt
specifier|static
name|__inline
expr|struct
name|scb
operator|*
name|ahcgetscb
argument_list|(
expr|struct
name|ahc_softc
operator|*
name|ahc
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|__inline
name|u_int32_t
name|ahc_hscb_busaddr
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|u_int
name|index
parameter_list|)
block|{
return|return
operator|(
name|ahc
operator|->
name|scb_data
operator|->
name|hscb_busaddr
operator|+
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|hardware_scb
argument_list|)
operator|*
name|index
operator|)
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|AHC_BUSRESET_DELAY
value|25
end_define

begin_comment
comment|/* Reset delay in us */
end_comment

begin_function
specifier|static
name|__inline
name|int
name|sequencer_paused
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|)
block|{
return|return
operator|(
operator|(
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|HCNTRL
argument_list|)
operator|&
name|PAUSE
operator|)
operator|!=
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|pause_sequencer
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|)
block|{
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|HCNTRL
argument_list|,
name|ahc
operator|->
name|pause
argument_list|)
expr_stmt|;
comment|/* 	 * Since the sequencer can disable pausing in a critical section, we 	 * must loop until it actually stops. 	 */
while|while
condition|(
name|sequencer_paused
argument_list|(
name|ahc
argument_list|)
operator|==
literal|0
condition|)
empty_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|unpause_sequencer
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|int
name|unpause_always
parameter_list|)
block|{
if|if
condition|(
name|unpause_always
operator|||
operator|(
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|INTSTAT
argument_list|)
operator|&
operator|(
name|SCSIINT
operator||
name|SEQINT
operator||
name|BRKADRINT
operator|)
operator|)
operator|==
literal|0
condition|)
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|HCNTRL
argument_list|,
name|ahc
operator|->
name|unpause
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Restart the sequencer program from address zero  */
end_comment

begin_function
specifier|static
name|__inline
name|void
name|restart_sequencer
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|)
block|{
name|pause_sequencer
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SEQCTL
argument_list|,
name|FASTMODE
operator||
name|SEQRESET
argument_list|)
expr_stmt|;
name|unpause_sequencer
argument_list|(
name|ahc
argument_list|,
comment|/*unpause_always*/
name|TRUE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|u_int
name|ahc_index_busy_tcl
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|u_int
name|tcl
parameter_list|,
name|int
name|unbusy
parameter_list|)
block|{
name|u_int
name|scbid
decl_stmt|;
name|scbid
operator|=
name|ahc
operator|->
name|untagged_scbs
index|[
name|tcl
index|]
expr_stmt|;
if|if
condition|(
name|unbusy
condition|)
name|ahc
operator|->
name|untagged_scbs
index|[
name|tcl
index|]
operator|=
name|SCB_LIST_NULL
expr_stmt|;
return|return
operator|(
name|scbid
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|ahc_busy_tcl
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|struct
name|scb
modifier|*
name|scb
parameter_list|)
block|{
name|ahc
operator|->
name|untagged_scbs
index|[
name|scb
operator|->
name|hscb
operator|->
name|tcl
index|]
operator|=
name|scb
operator|->
name|hscb
operator|->
name|tag
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|ahc_freeze_ccb
parameter_list|(
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
block|{
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_DEV_QFRZN
operator|)
operator|==
literal|0
condition|)
block|{
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_DEV_QFRZN
expr_stmt|;
name|xpt_freeze_devq
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
comment|/*count*/
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|__inline
name|cam_status
name|ahc_ccb_status
parameter_list|(
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
block|{
return|return
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|ahcsetccbstatus
parameter_list|(
name|union
name|ccb
modifier|*
name|ccb
parameter_list|,
name|cam_status
name|status
parameter_list|)
block|{
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&=
operator|~
name|CAM_STATUS_MASK
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|status
expr_stmt|;
block|}
end_function

begin_expr_stmt
specifier|static
name|__inline
expr|struct
name|ahc_initiator_tinfo
operator|*
name|ahc_fetch_transinfo
argument_list|(
argument|struct ahc_softc *ahc
argument_list|,
argument|char channel
argument_list|,
argument|u_int our_id
argument_list|,
argument|u_int remote_id
argument_list|,
argument|struct tmode_tstate **tstate
argument_list|)
block|{
comment|/* 	 * Transfer data structures are stored from the perspective 	 * of the target role.  Since the parameters for a connection 	 * in the initiator role to a given target are the same as 	 * when the roles are reversed, we pretend we are the target. 	 */
if|if
condition|(
name|channel
operator|==
literal|'B'
condition|)
name|our_id
operator|+=
literal|8
expr_stmt|;
operator|*
name|tstate
operator|=
name|ahc
operator|->
name|enabled_targets
index|[
name|our_id
index|]
expr_stmt|;
end_expr_stmt

begin_return
return|return
operator|(
operator|&
operator|(
operator|*
name|tstate
operator|)
operator|->
name|transinfo
index|[
name|remote_id
index|]
operator|)
return|;
end_return

begin_function
unit|}  static
name|void
name|ahc_run_tqinfifo
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|)
block|{
name|struct
name|target_cmd
modifier|*
name|cmd
decl_stmt|;
while|while
condition|(
operator|(
name|cmd
operator|=
operator|&
name|ahc
operator|->
name|targetcmds
index|[
name|ahc
operator|->
name|tqinfifonext
index|]
operator|)
operator|->
name|cmd_valid
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * Only advance through the queue if we 		 * had the resources to process the command. 		 */
if|if
condition|(
name|ahc_handle_target_cmd
argument_list|(
name|ahc
argument_list|,
name|cmd
argument_list|)
operator|!=
literal|0
condition|)
break|break;
name|ahc
operator|->
name|tqinfifonext
operator|++
expr_stmt|;
name|cmd
operator|->
name|cmd_valid
operator|=
literal|0
expr_stmt|;
comment|/* 		 * Lazily update our position in the target mode incomming 		 * command queue as seen by the sequencer. 		 */
if|if
condition|(
operator|(
name|ahc
operator|->
name|tqinfifonext
operator|&
operator|(
name|TQINFIFO_UPDATE_CNT
operator|-
literal|1
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
name|pause_sequencer
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|KERNEL_TQINPOS
argument_list|,
name|ahc
operator|->
name|tqinfifonext
operator|-
literal|1
argument_list|)
expr_stmt|;
name|unpause_sequencer
argument_list|(
name|ahc
argument_list|,
comment|/*unpause_always*/
name|FALSE
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ahc_run_qoutfifo
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|)
block|{
name|struct
name|scb
modifier|*
name|scb
decl_stmt|;
name|u_int
name|scb_index
decl_stmt|;
while|while
condition|(
name|ahc
operator|->
name|qoutfifo
index|[
name|ahc
operator|->
name|qoutfifonext
index|]
operator|!=
name|SCB_LIST_NULL
condition|)
block|{
name|scb_index
operator|=
name|ahc
operator|->
name|qoutfifo
index|[
name|ahc
operator|->
name|qoutfifonext
index|]
expr_stmt|;
name|ahc
operator|->
name|qoutfifo
index|[
name|ahc
operator|->
name|qoutfifonext
operator|++
index|]
operator|=
name|SCB_LIST_NULL
expr_stmt|;
name|scb
operator|=
operator|&
name|ahc
operator|->
name|scb_data
operator|->
name|scbarray
index|[
name|scb_index
index|]
expr_stmt|;
if|if
condition|(
name|scb_index
operator|>=
name|ahc
operator|->
name|scb_data
operator|->
name|numscbs
operator|||
operator|(
name|scb
operator|->
name|flags
operator|&
name|SCB_ACTIVE
operator|)
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%s: WARNING no command for scb %d "
literal|"(cmdcmplt)\nQOUTPOS = %d\n"
argument_list|,
name|ahc_name
argument_list|(
name|ahc
argument_list|)
argument_list|,
name|scb_index
argument_list|,
name|ahc
operator|->
name|qoutfifonext
operator|-
literal|1
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * Save off the residual 		 * if there is one. 		 */
if|if
condition|(
name|scb
operator|->
name|hscb
operator|->
name|residual_SG_count
operator|!=
literal|0
condition|)
name|ahc_calc_residual
argument_list|(
name|scb
argument_list|)
expr_stmt|;
else|else
name|scb
operator|->
name|ccb
operator|->
name|csio
operator|.
name|resid
operator|=
literal|0
expr_stmt|;
name|ahc_done
argument_list|(
name|ahc
argument_list|,
name|scb
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * An scb (and hence an scb entry on the board) is put onto the  * free list.  */
end_comment

begin_function
specifier|static
name|void
name|ahcfreescb
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|struct
name|scb
modifier|*
name|scb
parameter_list|)
block|{
name|struct
name|hardware_scb
modifier|*
name|hscb
decl_stmt|;
name|int
name|opri
decl_stmt|;
name|hscb
operator|=
name|scb
operator|->
name|hscb
expr_stmt|;
name|opri
operator|=
name|splcam
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|ahc
operator|->
name|flags
operator|&
name|AHC_RESOURCE_SHORTAGE
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|scb
operator|->
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_RELEASE_SIMQ
operator|)
operator|==
literal|0
condition|)
block|{
name|scb
operator|->
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_RELEASE_SIMQ
expr_stmt|;
name|ahc
operator|->
name|flags
operator|&=
operator|~
name|AHC_RESOURCE_SHORTAGE
expr_stmt|;
block|}
comment|/* Clean up for the next user */
name|scb
operator|->
name|flags
operator|=
name|SCB_FREE
expr_stmt|;
name|hscb
operator|->
name|control
operator|=
literal|0
expr_stmt|;
name|hscb
operator|->
name|status
operator|=
literal|0
expr_stmt|;
name|SLIST_INSERT_HEAD
argument_list|(
operator|&
name|ahc
operator|->
name|scb_data
operator|->
name|free_scbs
argument_list|,
name|scb
argument_list|,
name|links
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|opri
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Get a free scb, either one already assigned to a hardware slot  * on the adapter or one that will require an SCB to be paged out before  * use. If there are none, see if we can allocate a new SCB.  Otherwise  * either return an error or sleep.  */
end_comment

begin_expr_stmt
specifier|static
name|__inline
expr|struct
name|scb
operator|*
name|ahcgetscb
argument_list|(
argument|struct ahc_softc *ahc
argument_list|)
block|{ 	struct
name|scb
operator|*
name|scbp
block|;
name|int
name|opri
block|;
name|opri
operator|=
name|splcam
argument_list|()
block|;
if|if
condition|(
operator|(
name|scbp
operator|=
name|SLIST_FIRST
argument_list|(
operator|&
name|ahc
operator|->
name|scb_data
operator|->
name|free_scbs
argument_list|)
operator|)
condition|)
block|{
name|SLIST_REMOVE_HEAD
argument_list|(
operator|&
name|ahc
operator|->
name|scb_data
operator|->
name|free_scbs
argument_list|,
name|links
argument_list|)
expr_stmt|;
block|}
end_expr_stmt

begin_else
else|else
block|{
name|ahcallocscbs
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
name|scbp
operator|=
name|SLIST_FIRST
argument_list|(
operator|&
name|ahc
operator|->
name|scb_data
operator|->
name|free_scbs
argument_list|)
expr_stmt|;
if|if
condition|(
name|scbp
operator|!=
name|NULL
condition|)
name|SLIST_REMOVE_HEAD
argument_list|(
operator|&
name|ahc
operator|->
name|scb_data
operator|->
name|free_scbs
argument_list|,
name|links
argument_list|)
expr_stmt|;
block|}
end_else

begin_expr_stmt
name|splx
argument_list|(
name|opri
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
operator|(
name|scbp
operator|)
return|;
end_return

begin_expr_stmt
unit|}  char
operator|*
name|ahc_name
argument_list|(
argument|struct ahc_softc *ahc
argument_list|)
block|{
specifier|static
name|char
name|name
index|[
literal|10
index|]
block|;
name|snprintf
argument_list|(
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|name
argument_list|)
argument_list|,
literal|"ahc%d"
argument_list|,
name|ahc
operator|->
name|unit
argument_list|)
block|;
return|return
operator|(
name|name
operator|)
return|;
block|}
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|AHC_DEBUG
end_ifdef

begin_function
specifier|static
name|void
name|ahc_print_scb
parameter_list|(
name|struct
name|scb
modifier|*
name|scb
parameter_list|)
block|{
name|struct
name|hardware_scb
modifier|*
name|hscb
init|=
name|scb
operator|->
name|hscb
decl_stmt|;
name|printf
argument_list|(
literal|"scb:%p control:0x%x tcl:0x%x cmdlen:%d cmdpointer:0x%lx\n"
argument_list|,
name|scb
argument_list|,
name|hscb
operator|->
name|control
argument_list|,
name|hscb
operator|->
name|tcl
argument_list|,
name|hscb
operator|->
name|cmdlen
argument_list|,
name|hscb
operator|->
name|cmdpointer
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"        datlen:%d data:0x%lx segs:0x%x segp:0x%lx\n"
argument_list|,
name|hscb
operator|->
name|datalen
argument_list|,
name|hscb
operator|->
name|data
argument_list|,
name|hscb
operator|->
name|SG_count
argument_list|,
name|hscb
operator|->
name|SG_pointer
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"	sg_addr:%lx sg_len:%ld\n"
argument_list|,
name|scb
operator|->
name|sg_list
index|[
literal|0
index|]
operator|.
name|addr
argument_list|,
name|scb
operator|->
name|sg_list
index|[
literal|0
index|]
operator|.
name|len
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"	cdb:%x %x %x %x %x %x %x %x %x %x %x %x\n"
argument_list|,
name|hscb
operator|->
name|cmdstore
index|[
literal|0
index|]
argument_list|,
name|hscb
operator|->
name|cmdstore
index|[
literal|1
index|]
argument_list|,
name|hscb
operator|->
name|cmdstore
index|[
literal|2
index|]
argument_list|,
name|hscb
operator|->
name|cmdstore
index|[
literal|3
index|]
argument_list|,
name|hscb
operator|->
name|cmdstore
index|[
literal|4
index|]
argument_list|,
name|hscb
operator|->
name|cmdstore
index|[
literal|5
index|]
argument_list|,
name|hscb
operator|->
name|cmdstore
index|[
literal|6
index|]
argument_list|,
name|hscb
operator|->
name|cmdstore
index|[
literal|7
index|]
argument_list|,
name|hscb
operator|->
name|cmdstore
index|[
literal|8
index|]
argument_list|,
name|hscb
operator|->
name|cmdstore
index|[
literal|9
index|]
argument_list|,
name|hscb
operator|->
name|cmdstore
index|[
literal|10
index|]
argument_list|,
name|hscb
operator|->
name|cmdstore
index|[
literal|11
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_struct
specifier|static
struct|struct
block|{
name|u_int8_t
name|errno
decl_stmt|;
name|char
modifier|*
name|errmesg
decl_stmt|;
block|}
name|hard_error
index|[]
init|=
block|{
block|{
name|ILLHADDR
block|,
literal|"Illegal Host Access"
block|}
block|,
block|{
name|ILLSADDR
block|,
literal|"Illegal Sequencer Address referrenced"
block|}
block|,
block|{
name|ILLOPCODE
block|,
literal|"Illegal Opcode in sequencer program"
block|}
block|,
block|{
name|SQPARERR
block|,
literal|"Sequencer Parity Error"
block|}
block|,
block|{
name|DPARERR
block|,
literal|"Data-path Parity Error"
block|}
block|,
block|{
name|MPARERR
block|,
literal|"Scratch or SCB Memory Parity Error"
block|}
block|,
block|{
name|PCIERRSTAT
block|,
literal|"PCI Error detected"
block|}
block|,
block|{
name|CIOPARERR
block|,
literal|"CIOBUS Parity Error"
block|}
block|, }
struct|;
end_struct

begin_comment
comment|/*  * Valid SCSIRATE values.  (p. 3-17)  * Provides a mapping of tranfer periods in ns to the proper value to  * stick in the scsiscfr reg to use that transfer rate.  */
end_comment

begin_define
define|#
directive|define
name|AHC_SYNCRATE_ULTRA2
value|0
end_define

begin_define
define|#
directive|define
name|AHC_SYNCRATE_ULTRA
value|2
end_define

begin_define
define|#
directive|define
name|AHC_SYNCRATE_FAST
value|5
end_define

begin_decl_stmt
specifier|static
name|struct
name|ahc_syncrate
name|ahc_syncrates
index|[]
init|=
block|{
comment|/* ultra2  fast/ultra  period	rate */
block|{
literal|0x13
block|,
literal|0x000
block|,
literal|10
block|,
literal|"40.0"
block|}
block|,
block|{
literal|0x14
block|,
literal|0x000
block|,
literal|11
block|,
literal|"33.0"
block|}
block|,
block|{
literal|0x15
block|,
literal|0x100
block|,
literal|12
block|,
literal|"20.0"
block|}
block|,
block|{
literal|0x16
block|,
literal|0x110
block|,
literal|15
block|,
literal|"16.0"
block|}
block|,
block|{
literal|0x17
block|,
literal|0x120
block|,
literal|18
block|,
literal|"13.4"
block|}
block|,
block|{
literal|0x18
block|,
literal|0x000
block|,
literal|25
block|,
literal|"10.0"
block|}
block|,
block|{
literal|0x19
block|,
literal|0x010
block|,
literal|31
block|,
literal|"8.0"
block|}
block|,
block|{
literal|0x1a
block|,
literal|0x020
block|,
literal|37
block|,
literal|"6.67"
block|}
block|,
block|{
literal|0x1b
block|,
literal|0x030
block|,
literal|43
block|,
literal|"5.7"
block|}
block|,
block|{
literal|0x10
block|,
literal|0x040
block|,
literal|50
block|,
literal|"5.0"
block|}
block|,
block|{
literal|0x00
block|,
literal|0x050
block|,
literal|56
block|,
literal|"4.4"
block|}
block|,
block|{
literal|0x00
block|,
literal|0x060
block|,
literal|62
block|,
literal|"4.0"
block|}
block|,
block|{
literal|0x00
block|,
literal|0x070
block|,
literal|68
block|,
literal|"3.6"
block|}
block|,
block|{
literal|0x00
block|,
literal|0x000
block|,
literal|0
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Allocate a controller structure for a new device and initialize it.  */
end_comment

begin_function
name|struct
name|ahc_softc
modifier|*
name|ahc_alloc
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|struct
name|resource
modifier|*
name|regs
parameter_list|,
name|int
name|regs_type
parameter_list|,
name|int
name|regs_id
parameter_list|,
name|bus_dma_tag_t
name|parent_dmat
parameter_list|,
name|ahc_chip
name|chip
parameter_list|,
name|ahc_feature
name|features
parameter_list|,
name|ahc_flag
name|flags
parameter_list|,
name|struct
name|scb_data
modifier|*
name|scb_data
parameter_list|)
block|{
comment|/* 	 * find unit and check we have that many defined 	 */
name|struct
name|ahc_softc
modifier|*
name|ahc
decl_stmt|;
name|size_t
name|alloc_size
decl_stmt|;
comment|/* 	 * Allocate a storage area for us 	 */
if|if
condition|(
name|scb_data
operator|==
name|NULL
condition|)
comment|/* 		 * We are not sharing SCB space with another controller 		 * so allocate our own SCB data space. 		 */
name|alloc_size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|full_ahc_softc
argument_list|)
expr_stmt|;
else|else
name|alloc_size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ahc_softc
argument_list|)
expr_stmt|;
name|ahc
operator|=
name|malloc
argument_list|(
name|alloc_size
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ahc
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"cannot malloc softc!\n"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|bzero
argument_list|(
name|ahc
argument_list|,
name|alloc_size
argument_list|)
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|ahc
operator|->
name|pending_ccbs
argument_list|)
expr_stmt|;
name|ahc
operator|->
name|device
operator|=
name|dev
expr_stmt|;
name|ahc
operator|->
name|unit
operator|=
name|device_get_unit
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|ahc
operator|->
name|regs_res_type
operator|=
name|regs_type
expr_stmt|;
name|ahc
operator|->
name|regs_res_id
operator|=
name|regs_id
expr_stmt|;
name|ahc
operator|->
name|regs
operator|=
name|regs
expr_stmt|;
name|ahc
operator|->
name|tag
operator|=
name|rman_get_bustag
argument_list|(
name|regs
argument_list|)
expr_stmt|;
name|ahc
operator|->
name|bsh
operator|=
name|rman_get_bushandle
argument_list|(
name|regs
argument_list|)
expr_stmt|;
name|ahc
operator|->
name|parent_dmat
operator|=
name|parent_dmat
expr_stmt|;
name|ahc
operator|->
name|chip
operator|=
name|chip
expr_stmt|;
name|ahc
operator|->
name|features
operator|=
name|features
expr_stmt|;
name|ahc
operator|->
name|flags
operator|=
name|flags
expr_stmt|;
if|if
condition|(
name|scb_data
operator|==
name|NULL
condition|)
block|{
name|struct
name|full_ahc_softc
modifier|*
name|full_softc
init|=
operator|(
expr|struct
name|full_ahc_softc
operator|*
operator|)
name|ahc
decl_stmt|;
name|ahc
operator|->
name|scb_data
operator|=
operator|&
name|full_softc
operator|->
name|scb_data_storage
expr_stmt|;
block|}
else|else
name|ahc
operator|->
name|scb_data
operator|=
name|scb_data
expr_stmt|;
name|ahc
operator|->
name|unpause
operator|=
operator|(
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|HCNTRL
argument_list|)
operator|&
name|IRQMS
operator|)
operator||
name|INTEN
expr_stmt|;
comment|/* The IRQMS bit is only valid on VL and EISA chips */
if|if
condition|(
operator|(
name|ahc
operator|->
name|chip
operator|&
name|AHC_PCI
operator|)
operator|!=
literal|0
condition|)
name|ahc
operator|->
name|unpause
operator|&=
operator|~
name|IRQMS
expr_stmt|;
name|ahc
operator|->
name|pause
operator|=
name|ahc
operator|->
name|unpause
operator||
name|PAUSE
expr_stmt|;
return|return
operator|(
name|ahc
operator|)
return|;
block|}
end_function

begin_function
name|void
name|ahc_free
parameter_list|(
name|ahc
parameter_list|)
name|struct
name|ahc_softc
modifier|*
name|ahc
decl_stmt|;
block|{
name|ahcfiniscbdata
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ahc
operator|->
name|init_level
condition|)
block|{
case|case
literal|3
case|:
name|bus_dmamap_unload
argument_list|(
name|ahc
operator|->
name|shared_data_dmat
argument_list|,
name|ahc
operator|->
name|shared_data_dmamap
argument_list|)
expr_stmt|;
case|case
literal|2
case|:
name|bus_dmamem_free
argument_list|(
name|ahc
operator|->
name|shared_data_dmat
argument_list|,
name|ahc
operator|->
name|qoutfifo
argument_list|,
name|ahc
operator|->
name|shared_data_dmamap
argument_list|)
expr_stmt|;
name|bus_dmamap_destroy
argument_list|(
name|ahc
operator|->
name|shared_data_dmat
argument_list|,
name|ahc
operator|->
name|shared_data_dmamap
argument_list|)
expr_stmt|;
case|case
literal|1
case|:
name|bus_dma_tag_destroy
argument_list|(
name|ahc
operator|->
name|buffer_dmat
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ahc
operator|->
name|regs
operator|!=
name|NULL
condition|)
name|bus_release_resource
argument_list|(
name|ahc
operator|->
name|device
argument_list|,
name|ahc
operator|->
name|regs_res_type
argument_list|,
name|ahc
operator|->
name|regs_res_id
argument_list|,
name|ahc
operator|->
name|regs
argument_list|)
expr_stmt|;
if|if
condition|(
name|ahc
operator|->
name|irq
operator|!=
name|NULL
condition|)
name|bus_release_resource
argument_list|(
name|ahc
operator|->
name|device
argument_list|,
name|ahc
operator|->
name|irq_res_type
argument_list|,
literal|0
argument_list|,
name|ahc
operator|->
name|irq
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ahc
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|int
name|ahcinitscbdata
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|)
block|{
name|struct
name|scb_data
modifier|*
name|scb_data
decl_stmt|;
name|int
name|i
decl_stmt|;
name|scb_data
operator|=
name|ahc
operator|->
name|scb_data
expr_stmt|;
name|SLIST_INIT
argument_list|(
operator|&
name|scb_data
operator|->
name|free_scbs
argument_list|)
expr_stmt|;
name|SLIST_INIT
argument_list|(
operator|&
name|scb_data
operator|->
name|sg_maps
argument_list|)
expr_stmt|;
comment|/* Allocate SCB resources */
name|scb_data
operator|->
name|scbarray
operator|=
operator|(
expr|struct
name|scb
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|scb
argument_list|)
operator|*
name|AHC_SCB_MAX
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|scb_data
operator|->
name|scbarray
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|bzero
argument_list|(
name|scb_data
operator|->
name|scbarray
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|scb
argument_list|)
operator|*
name|AHC_SCB_MAX
argument_list|)
expr_stmt|;
comment|/* Determine the number of hardware SCBs and initialize them */
name|scb_data
operator|->
name|maxhscbs
operator|=
name|ahc_probe_scbs
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
comment|/* SCB 0 heads the free list */
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|FREE_SCBH
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ahc
operator|->
name|scb_data
operator|->
name|maxhscbs
condition|;
name|i
operator|++
control|)
block|{
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCBPTR
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* Clear the control byte. */
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCB_CONTROL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Set the next pointer */
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCB_NEXT
argument_list|,
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* Make the tag number invalid */
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCB_TAG
argument_list|,
name|SCB_LIST_NULL
argument_list|)
expr_stmt|;
block|}
comment|/* Make sure that the last SCB terminates the free list */
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCBPTR
argument_list|,
name|i
operator|-
literal|1
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCB_NEXT
argument_list|,
name|SCB_LIST_NULL
argument_list|)
expr_stmt|;
comment|/* Ensure we clear the 0 SCB's control byte. */
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCBPTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCB_CONTROL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|scb_data
operator|->
name|maxhscbs
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|ahc
operator|->
name|scb_data
operator|->
name|maxhscbs
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"%s: No SCB space found"
argument_list|,
name|ahc_name
argument_list|(
name|ahc
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Create our DMA tags.  These tags define the kinds of device 	 * accessable memory allocations and memory mappings we will 	 * need to perform during normal operation. 	 * 	 * Unless we need to further restrict the allocation, we rely 	 * on the restrictions of the parent dmat, hence the common 	 * use of MAXADDR and MAXSIZE. 	 */
comment|/* DMA tag for our hardware scb structures */
if|if
condition|(
name|bus_dma_tag_create
argument_list|(
name|ahc
operator|->
name|parent_dmat
argument_list|,
comment|/*alignment*/
literal|1
argument_list|,
comment|/*boundary*/
literal|0
argument_list|,
comment|/*lowaddr*/
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/*highaddr*/
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/*filter*/
name|NULL
argument_list|,
comment|/*filterarg*/
name|NULL
argument_list|,
name|AHC_SCB_MAX
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|hardware_scb
argument_list|)
argument_list|,
comment|/*nsegments*/
literal|1
argument_list|,
comment|/*maxsegsz*/
name|BUS_SPACE_MAXSIZE_32BIT
argument_list|,
comment|/*flags*/
literal|0
argument_list|,
operator|&
name|scb_data
operator|->
name|hscb_dmat
argument_list|)
operator|!=
literal|0
condition|)
block|{
goto|goto
name|error_exit
goto|;
block|}
name|scb_data
operator|->
name|init_level
operator|++
expr_stmt|;
comment|/* Allocation for our ccbs */
if|if
condition|(
name|bus_dmamem_alloc
argument_list|(
name|scb_data
operator|->
name|hscb_dmat
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|scb_data
operator|->
name|hscbs
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|,
operator|&
name|scb_data
operator|->
name|hscb_dmamap
argument_list|)
operator|!=
literal|0
condition|)
block|{
goto|goto
name|error_exit
goto|;
block|}
name|scb_data
operator|->
name|init_level
operator|++
expr_stmt|;
comment|/* And permanently map them */
name|bus_dmamap_load
argument_list|(
name|scb_data
operator|->
name|hscb_dmat
argument_list|,
name|scb_data
operator|->
name|hscb_dmamap
argument_list|,
name|scb_data
operator|->
name|hscbs
argument_list|,
name|AHC_SCB_MAX
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|hardware_scb
argument_list|)
argument_list|,
name|ahcdmamapcb
argument_list|,
operator|&
name|scb_data
operator|->
name|hscb_busaddr
argument_list|,
comment|/*flags*/
literal|0
argument_list|)
expr_stmt|;
name|scb_data
operator|->
name|init_level
operator|++
expr_stmt|;
comment|/* DMA tag for our sense buffers */
if|if
condition|(
name|bus_dma_tag_create
argument_list|(
name|ahc
operator|->
name|parent_dmat
argument_list|,
comment|/*alignment*/
literal|1
argument_list|,
comment|/*boundary*/
literal|0
argument_list|,
comment|/*lowaddr*/
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/*highaddr*/
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/*filter*/
name|NULL
argument_list|,
comment|/*filterarg*/
name|NULL
argument_list|,
name|AHC_SCB_MAX
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_sense_data
argument_list|)
argument_list|,
comment|/*nsegments*/
literal|1
argument_list|,
comment|/*maxsegsz*/
name|BUS_SPACE_MAXSIZE_32BIT
argument_list|,
comment|/*flags*/
literal|0
argument_list|,
operator|&
name|scb_data
operator|->
name|sense_dmat
argument_list|)
operator|!=
literal|0
condition|)
block|{
goto|goto
name|error_exit
goto|;
block|}
name|scb_data
operator|->
name|init_level
operator|++
expr_stmt|;
comment|/* Allocate them */
if|if
condition|(
name|bus_dmamem_alloc
argument_list|(
name|scb_data
operator|->
name|sense_dmat
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|scb_data
operator|->
name|sense
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|,
operator|&
name|scb_data
operator|->
name|sense_dmamap
argument_list|)
operator|!=
literal|0
condition|)
block|{
goto|goto
name|error_exit
goto|;
block|}
name|scb_data
operator|->
name|init_level
operator|++
expr_stmt|;
comment|/* And permanently map them */
name|bus_dmamap_load
argument_list|(
name|scb_data
operator|->
name|sense_dmat
argument_list|,
name|scb_data
operator|->
name|sense_dmamap
argument_list|,
name|scb_data
operator|->
name|sense
argument_list|,
name|AHC_SCB_MAX
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_sense_data
argument_list|)
argument_list|,
name|ahcdmamapcb
argument_list|,
operator|&
name|scb_data
operator|->
name|sense_busaddr
argument_list|,
comment|/*flags*/
literal|0
argument_list|)
expr_stmt|;
name|scb_data
operator|->
name|init_level
operator|++
expr_stmt|;
comment|/* DMA tag for our S/G structures.  We allocate in page sized chunks */
if|if
condition|(
name|bus_dma_tag_create
argument_list|(
name|ahc
operator|->
name|parent_dmat
argument_list|,
comment|/*alignment*/
literal|1
argument_list|,
comment|/*boundary*/
literal|0
argument_list|,
comment|/*lowaddr*/
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/*highaddr*/
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/*filter*/
name|NULL
argument_list|,
comment|/*filterarg*/
name|NULL
argument_list|,
name|PAGE_SIZE
argument_list|,
comment|/*nsegments*/
literal|1
argument_list|,
comment|/*maxsegsz*/
name|BUS_SPACE_MAXSIZE_32BIT
argument_list|,
comment|/*flags*/
literal|0
argument_list|,
operator|&
name|scb_data
operator|->
name|sg_dmat
argument_list|)
operator|!=
literal|0
condition|)
block|{
goto|goto
name|error_exit
goto|;
block|}
name|scb_data
operator|->
name|init_level
operator|++
expr_stmt|;
comment|/* Perform initial CCB allocation */
name|bzero
argument_list|(
name|scb_data
operator|->
name|hscbs
argument_list|,
name|AHC_SCB_MAX
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|hardware_scb
argument_list|)
argument_list|)
expr_stmt|;
name|ahcallocscbs
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
if|if
condition|(
name|scb_data
operator|->
name|numscbs
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%s: ahc_init_scb_data - "
literal|"Unable to allocate initial scbs\n"
argument_list|,
name|ahc_name
argument_list|(
name|ahc
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|error_exit
goto|;
block|}
comment|/*          * Note that we were successfull          */
return|return
literal|0
return|;
name|error_exit
label|:
return|return
name|ENOMEM
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ahcfiniscbdata
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|)
block|{
name|struct
name|scb_data
modifier|*
name|scb_data
decl_stmt|;
name|scb_data
operator|=
name|ahc
operator|->
name|scb_data
expr_stmt|;
switch|switch
condition|(
name|scb_data
operator|->
name|init_level
condition|)
block|{
default|default:
case|case
literal|7
case|:
block|{
name|struct
name|sg_map_node
modifier|*
name|sg_map
decl_stmt|;
while|while
condition|(
operator|(
name|sg_map
operator|=
name|SLIST_FIRST
argument_list|(
operator|&
name|scb_data
operator|->
name|sg_maps
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|SLIST_REMOVE_HEAD
argument_list|(
operator|&
name|scb_data
operator|->
name|sg_maps
argument_list|,
name|links
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|scb_data
operator|->
name|sg_dmat
argument_list|,
name|sg_map
operator|->
name|sg_dmamap
argument_list|)
expr_stmt|;
name|bus_dmamem_free
argument_list|(
name|scb_data
operator|->
name|sg_dmat
argument_list|,
name|sg_map
operator|->
name|sg_vaddr
argument_list|,
name|sg_map
operator|->
name|sg_dmamap
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sg_map
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
name|bus_dma_tag_destroy
argument_list|(
name|scb_data
operator|->
name|sg_dmat
argument_list|)
expr_stmt|;
block|}
case|case
literal|6
case|:
name|bus_dmamap_unload
argument_list|(
name|scb_data
operator|->
name|sense_dmat
argument_list|,
name|scb_data
operator|->
name|sense_dmamap
argument_list|)
expr_stmt|;
case|case
literal|5
case|:
name|bus_dmamem_free
argument_list|(
name|scb_data
operator|->
name|sense_dmat
argument_list|,
name|scb_data
operator|->
name|sense
argument_list|,
name|scb_data
operator|->
name|sense_dmamap
argument_list|)
expr_stmt|;
name|bus_dmamap_destroy
argument_list|(
name|scb_data
operator|->
name|sense_dmat
argument_list|,
name|scb_data
operator|->
name|sense_dmamap
argument_list|)
expr_stmt|;
case|case
literal|4
case|:
name|bus_dma_tag_destroy
argument_list|(
name|scb_data
operator|->
name|sense_dmat
argument_list|)
expr_stmt|;
case|case
literal|3
case|:
name|bus_dmamap_unload
argument_list|(
name|scb_data
operator|->
name|hscb_dmat
argument_list|,
name|scb_data
operator|->
name|hscb_dmamap
argument_list|)
expr_stmt|;
case|case
literal|2
case|:
name|bus_dmamem_free
argument_list|(
name|scb_data
operator|->
name|hscb_dmat
argument_list|,
name|scb_data
operator|->
name|hscbs
argument_list|,
name|scb_data
operator|->
name|hscb_dmamap
argument_list|)
expr_stmt|;
name|bus_dmamap_destroy
argument_list|(
name|scb_data
operator|->
name|hscb_dmat
argument_list|,
name|scb_data
operator|->
name|hscb_dmamap
argument_list|)
expr_stmt|;
case|case
literal|1
case|:
name|bus_dma_tag_destroy
argument_list|(
name|scb_data
operator|->
name|hscb_dmat
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|scb_data
operator|->
name|scbarray
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|scb_data
operator|->
name|scbarray
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ahcdmamapcb
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
name|nseg
parameter_list|,
name|int
name|error
parameter_list|)
block|{
name|bus_addr_t
modifier|*
name|baddr
decl_stmt|;
name|baddr
operator|=
operator|(
name|bus_addr_t
operator|*
operator|)
name|arg
expr_stmt|;
operator|*
name|baddr
operator|=
name|segs
operator|->
name|ds_addr
expr_stmt|;
block|}
end_function

begin_function
name|int
name|ahc_reset
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|)
block|{
name|u_int
name|sblkctl
decl_stmt|;
name|int
name|wait
decl_stmt|;
ifdef|#
directive|ifdef
name|AHC_DUMP_SEQ
name|ahc_dumpseq
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|HCNTRL
argument_list|,
name|CHIPRST
operator||
name|ahc
operator|->
name|pause
argument_list|)
expr_stmt|;
comment|/* 	 * Ensure that the reset has finished 	 */
name|wait
operator|=
literal|1000
expr_stmt|;
do|do
block|{
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|wait
operator|&&
operator|!
operator|(
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|HCNTRL
argument_list|)
operator|&
name|CHIPRSTACK
operator|)
condition|)
do|;
if|if
condition|(
name|wait
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%s: WARNING - Failed chip reset!  "
literal|"Trying to initialize anyway.\n"
argument_list|,
name|ahc_name
argument_list|(
name|ahc
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|HCNTRL
argument_list|,
name|ahc
operator|->
name|pause
argument_list|)
expr_stmt|;
comment|/* Determine channel configuration */
name|sblkctl
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SBLKCTL
argument_list|)
operator|&
operator|(
name|SELBUSB
operator||
name|SELWIDE
operator|)
expr_stmt|;
comment|/* No Twin Channel PCI cards */
if|if
condition|(
operator|(
name|ahc
operator|->
name|chip
operator|&
name|AHC_PCI
operator|)
operator|!=
literal|0
condition|)
name|sblkctl
operator|&=
operator|~
name|SELBUSB
expr_stmt|;
switch|switch
condition|(
name|sblkctl
condition|)
block|{
case|case
literal|0
case|:
comment|/* Single Narrow Channel */
break|break;
case|case
literal|2
case|:
comment|/* Wide Channel */
name|ahc
operator|->
name|features
operator||=
name|AHC_WIDE
expr_stmt|;
break|break;
case|case
literal|8
case|:
comment|/* Twin Channel */
name|ahc
operator|->
name|features
operator||=
name|AHC_TWIN
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|" Unsupported adapter type.  Ignoring\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Called when we have an active connection to a target on the bus,  * this function finds the nearest syncrate to the input period limited  * by the capabilities of the bus connectivity of the target.  */
end_comment

begin_function
specifier|static
name|struct
name|ahc_syncrate
modifier|*
name|ahc_devlimited_syncrate
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|u_int
modifier|*
name|period
parameter_list|)
block|{
name|u_int
name|maxsync
decl_stmt|;
if|if
condition|(
operator|(
name|ahc
operator|->
name|features
operator|&
name|AHC_ULTRA2
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SBLKCTL
argument_list|)
operator|&
name|ENAB40
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SSTAT2
argument_list|)
operator|&
name|EXP_ACTIVE
operator|)
operator|==
literal|0
condition|)
block|{
name|maxsync
operator|=
name|AHC_SYNCRATE_ULTRA2
expr_stmt|;
block|}
else|else
block|{
name|maxsync
operator|=
name|AHC_SYNCRATE_ULTRA
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|ahc
operator|->
name|features
operator|&
name|AHC_ULTRA
operator|)
operator|!=
literal|0
condition|)
block|{
name|maxsync
operator|=
name|AHC_SYNCRATE_ULTRA
expr_stmt|;
block|}
else|else
block|{
name|maxsync
operator|=
name|AHC_SYNCRATE_FAST
expr_stmt|;
block|}
return|return
operator|(
name|ahc_find_syncrate
argument_list|(
name|ahc
argument_list|,
name|period
argument_list|,
name|maxsync
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Look up the valid period to SCSIRATE conversion in our table.  * Return the period and offset that should be sent to the target  * if this was the beginning of an SDTR.  */
end_comment

begin_function
specifier|static
name|struct
name|ahc_syncrate
modifier|*
name|ahc_find_syncrate
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|u_int
modifier|*
name|period
parameter_list|,
name|u_int
name|maxsync
parameter_list|)
block|{
name|struct
name|ahc_syncrate
modifier|*
name|syncrate
decl_stmt|;
name|syncrate
operator|=
operator|&
name|ahc_syncrates
index|[
name|maxsync
index|]
expr_stmt|;
while|while
condition|(
operator|(
name|syncrate
operator|->
name|rate
operator|!=
name|NULL
operator|)
operator|&&
operator|(
operator|(
name|ahc
operator|->
name|features
operator|&
name|AHC_ULTRA2
operator|)
operator|==
literal|0
operator|||
operator|(
name|syncrate
operator|->
name|sxfr_ultra2
operator|!=
literal|0
operator|)
operator|)
condition|)
block|{
if|if
condition|(
operator|*
name|period
operator|<=
name|syncrate
operator|->
name|period
condition|)
block|{
comment|/* 			 * When responding to a target that requests 			 * sync, the requested rate may fall between 			 * two rates that we can output, but still be 			 * a rate that we can receive.  Because of this, 			 * we want to respond to the target with 			 * the same rate that it sent to us even 			 * if the period we use to send data to it 			 * is lower.  Only lower the response period 			 * if we must. 			 */
if|if
condition|(
name|syncrate
operator|==
operator|&
name|ahc_syncrates
index|[
name|maxsync
index|]
condition|)
block|{
operator|*
name|period
operator|=
name|syncrate
operator|->
name|period
expr_stmt|;
block|}
break|break;
block|}
name|syncrate
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|*
name|period
operator|==
literal|0
operator|)
operator|||
operator|(
name|syncrate
operator|->
name|rate
operator|==
name|NULL
operator|)
operator|||
operator|(
operator|(
name|ahc
operator|->
name|features
operator|&
name|AHC_ULTRA2
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|syncrate
operator|->
name|sxfr_ultra2
operator|==
literal|0
operator|)
operator|)
condition|)
block|{
comment|/* Use asynchronous transfers. */
operator|*
name|period
operator|=
literal|0
expr_stmt|;
name|syncrate
operator|=
name|NULL
expr_stmt|;
block|}
return|return
operator|(
name|syncrate
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|u_int
name|ahc_find_period
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|u_int
name|scsirate
parameter_list|,
name|u_int
name|maxsync
parameter_list|)
block|{
name|struct
name|ahc_syncrate
modifier|*
name|syncrate
decl_stmt|;
if|if
condition|(
operator|(
name|ahc
operator|->
name|features
operator|&
name|AHC_ULTRA2
operator|)
operator|!=
literal|0
condition|)
block|{
name|scsirate
operator|&=
name|SXFR_ULTRA2
expr_stmt|;
block|}
else|else
block|{
name|scsirate
operator|&=
name|SXFR
expr_stmt|;
block|}
name|syncrate
operator|=
operator|&
name|ahc_syncrates
index|[
name|maxsync
index|]
expr_stmt|;
while|while
condition|(
name|syncrate
operator|->
name|rate
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|ahc
operator|->
name|features
operator|&
name|AHC_ULTRA2
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|syncrate
operator|->
name|sxfr_ultra2
operator|==
literal|0
condition|)
break|break;
elseif|else
if|if
condition|(
name|scsirate
operator|==
name|syncrate
operator|->
name|sxfr_ultra2
condition|)
return|return
operator|(
name|syncrate
operator|->
name|period
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|scsirate
operator|==
operator|(
name|syncrate
operator|->
name|sxfr
operator|&
operator|~
name|ULTRA_SXFR
operator|)
condition|)
block|{
return|return
operator|(
name|syncrate
operator|->
name|period
operator|)
return|;
block|}
name|syncrate
operator|++
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
comment|/* async */
block|}
end_function

begin_function
specifier|static
name|void
name|ahc_validate_offset
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|struct
name|ahc_syncrate
modifier|*
name|syncrate
parameter_list|,
name|u_int
modifier|*
name|offset
parameter_list|,
name|int
name|wide
parameter_list|)
block|{
name|u_int
name|maxoffset
decl_stmt|;
comment|/* Limit offset to what we can do */
if|if
condition|(
name|syncrate
operator|==
name|NULL
condition|)
block|{
name|maxoffset
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|ahc
operator|->
name|features
operator|&
name|AHC_ULTRA2
operator|)
operator|!=
literal|0
condition|)
block|{
name|maxoffset
operator|=
name|MAX_OFFSET_ULTRA2
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|wide
condition|)
name|maxoffset
operator|=
name|MAX_OFFSET_16BIT
expr_stmt|;
else|else
name|maxoffset
operator|=
name|MAX_OFFSET_8BIT
expr_stmt|;
block|}
operator|*
name|offset
operator|=
name|MIN
argument_list|(
operator|*
name|offset
argument_list|,
name|maxoffset
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ahc_update_target_msg_request
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|struct
name|ahc_devinfo
modifier|*
name|devinfo
parameter_list|,
name|struct
name|ahc_initiator_tinfo
modifier|*
name|tinfo
parameter_list|,
name|int
name|force
parameter_list|,
name|int
name|paused
parameter_list|)
block|{
name|u_int
name|targ_msg_req_orig
decl_stmt|;
name|targ_msg_req_orig
operator|=
name|ahc
operator|->
name|targ_msg_req
expr_stmt|;
if|if
condition|(
name|tinfo
operator|->
name|current
operator|.
name|period
operator|!=
name|tinfo
operator|->
name|goal
operator|.
name|period
operator|||
name|tinfo
operator|->
name|current
operator|.
name|width
operator|!=
name|tinfo
operator|->
name|goal
operator|.
name|width
operator|||
name|tinfo
operator|->
name|current
operator|.
name|offset
operator|!=
name|tinfo
operator|->
name|goal
operator|.
name|offset
operator|||
operator|(
name|force
operator|&&
operator|(
name|tinfo
operator|->
name|goal
operator|.
name|period
operator|!=
literal|0
operator|||
name|tinfo
operator|->
name|goal
operator|.
name|width
operator|!=
name|MSG_EXT_WDTR_BUS_8_BIT
operator|)
operator|)
condition|)
name|ahc
operator|->
name|targ_msg_req
operator||=
name|devinfo
operator|->
name|target_mask
expr_stmt|;
else|else
name|ahc
operator|->
name|targ_msg_req
operator|&=
operator|~
name|devinfo
operator|->
name|target_mask
expr_stmt|;
if|if
condition|(
name|ahc
operator|->
name|targ_msg_req
operator|!=
name|targ_msg_req_orig
condition|)
block|{
comment|/* Update the message request bit for this target */
if|if
condition|(
operator|(
name|ahc
operator|->
name|features
operator|&
name|AHC_HS_MAILBOX
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|paused
condition|)
block|{
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|TARGET_MSG_REQUEST
argument_list|,
name|ahc
operator|->
name|targ_msg_req
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|TARGET_MSG_REQUEST
operator|+
literal|1
argument_list|,
operator|(
name|ahc
operator|->
name|targ_msg_req
operator|>>
literal|8
operator|)
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|HS_MAILBOX
argument_list|,
literal|0x01
operator|<<
name|HOST_MAILBOX_SHIFT
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
name|paused
condition|)
name|pause_sequencer
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|TARGET_MSG_REQUEST
argument_list|,
name|ahc
operator|->
name|targ_msg_req
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|TARGET_MSG_REQUEST
operator|+
literal|1
argument_list|,
operator|(
name|ahc
operator|->
name|targ_msg_req
operator|>>
literal|8
operator|)
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|paused
condition|)
name|unpause_sequencer
argument_list|(
name|ahc
argument_list|,
comment|/*unpause always*/
name|FALSE
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|ahc_create_path
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|struct
name|ahc_devinfo
modifier|*
name|devinfo
parameter_list|,
name|struct
name|cam_path
modifier|*
modifier|*
name|path
parameter_list|)
block|{
name|path_id_t
name|path_id
decl_stmt|;
if|if
condition|(
name|devinfo
operator|->
name|channel
operator|==
literal|'B'
condition|)
name|path_id
operator|=
name|cam_sim_path
argument_list|(
name|ahc
operator|->
name|sim_b
argument_list|)
expr_stmt|;
else|else
name|path_id
operator|=
name|cam_sim_path
argument_list|(
name|ahc
operator|->
name|sim
argument_list|)
expr_stmt|;
return|return
operator|(
name|xpt_create_path
argument_list|(
name|path
argument_list|,
comment|/*periph*/
name|NULL
argument_list|,
name|path_id
argument_list|,
name|devinfo
operator|->
name|target
argument_list|,
name|devinfo
operator|->
name|lun
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ahc_set_syncrate
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|struct
name|ahc_devinfo
modifier|*
name|devinfo
parameter_list|,
name|struct
name|cam_path
modifier|*
name|path
parameter_list|,
name|struct
name|ahc_syncrate
modifier|*
name|syncrate
parameter_list|,
name|u_int
name|period
parameter_list|,
name|u_int
name|offset
parameter_list|,
name|u_int
name|type
parameter_list|,
name|int
name|paused
parameter_list|)
block|{
name|struct
name|ahc_initiator_tinfo
modifier|*
name|tinfo
decl_stmt|;
name|struct
name|tmode_tstate
modifier|*
name|tstate
decl_stmt|;
name|u_int
name|old_period
decl_stmt|;
name|u_int
name|old_offset
decl_stmt|;
name|int
name|active
init|=
operator|(
name|type
operator|&
name|AHC_TRANS_ACTIVE
operator|)
operator|==
name|AHC_TRANS_ACTIVE
decl_stmt|;
if|if
condition|(
name|syncrate
operator|==
name|NULL
condition|)
block|{
name|period
operator|=
literal|0
expr_stmt|;
name|offset
operator|=
literal|0
expr_stmt|;
block|}
name|tinfo
operator|=
name|ahc_fetch_transinfo
argument_list|(
name|ahc
argument_list|,
name|devinfo
operator|->
name|channel
argument_list|,
name|devinfo
operator|->
name|our_scsiid
argument_list|,
name|devinfo
operator|->
name|target
argument_list|,
operator|&
name|tstate
argument_list|)
expr_stmt|;
name|old_period
operator|=
name|tinfo
operator|->
name|current
operator|.
name|period
expr_stmt|;
name|old_offset
operator|=
name|tinfo
operator|->
name|current
operator|.
name|offset
expr_stmt|;
if|if
condition|(
operator|(
name|type
operator|&
name|AHC_TRANS_CUR
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|old_period
operator|!=
name|period
operator|||
name|old_offset
operator|!=
name|offset
operator|)
condition|)
block|{
name|struct
name|cam_path
modifier|*
name|path2
decl_stmt|;
name|u_int
name|scsirate
decl_stmt|;
name|scsirate
operator|=
name|tinfo
operator|->
name|scsirate
expr_stmt|;
if|if
condition|(
operator|(
name|ahc
operator|->
name|features
operator|&
name|AHC_ULTRA2
operator|)
operator|!=
literal|0
condition|)
block|{
name|scsirate
operator|&=
operator|~
name|SXFR_ULTRA2
expr_stmt|;
if|if
condition|(
name|syncrate
operator|!=
name|NULL
condition|)
block|{
name|scsirate
operator||=
name|syncrate
operator|->
name|sxfr_ultra2
expr_stmt|;
block|}
if|if
condition|(
name|active
condition|)
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCSIOFFSET
argument_list|,
name|offset
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|scsirate
operator|&=
operator|~
operator|(
name|SXFR
operator||
name|SOFS
operator|)
expr_stmt|;
comment|/* 			 * Ensure Ultra mode is set properly for 			 * this target. 			 */
name|tstate
operator|->
name|ultraenb
operator|&=
operator|~
name|devinfo
operator|->
name|target_mask
expr_stmt|;
if|if
condition|(
name|syncrate
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|syncrate
operator|->
name|sxfr
operator|&
name|ULTRA_SXFR
condition|)
block|{
name|tstate
operator|->
name|ultraenb
operator||=
name|devinfo
operator|->
name|target_mask
expr_stmt|;
block|}
name|scsirate
operator||=
name|syncrate
operator|->
name|sxfr
operator|&
name|SXFR
expr_stmt|;
name|scsirate
operator||=
name|offset
operator|&
name|SOFS
expr_stmt|;
block|}
if|if
condition|(
name|active
condition|)
block|{
name|u_int
name|sxfrctl0
decl_stmt|;
name|sxfrctl0
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SXFRCTL0
argument_list|)
expr_stmt|;
name|sxfrctl0
operator|&=
operator|~
name|FAST20
expr_stmt|;
if|if
condition|(
name|tstate
operator|->
name|ultraenb
operator|&
name|devinfo
operator|->
name|target_mask
condition|)
name|sxfrctl0
operator||=
name|FAST20
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SXFRCTL0
argument_list|,
name|sxfrctl0
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|active
condition|)
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCSIRATE
argument_list|,
name|scsirate
argument_list|)
expr_stmt|;
name|tinfo
operator|->
name|scsirate
operator|=
name|scsirate
expr_stmt|;
name|tinfo
operator|->
name|current
operator|.
name|period
operator|=
name|period
expr_stmt|;
name|tinfo
operator|->
name|current
operator|.
name|offset
operator|=
name|offset
expr_stmt|;
comment|/* Update the syncrates in any pending scbs */
name|ahc_update_pending_syncrates
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
comment|/* 		 * If possible, tell the SCSI layer about the 		 * new transfer parameters. 		 */
comment|/* If possible, update the XPT's notion of our transfer rate */
name|path2
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|path
operator|==
name|NULL
condition|)
block|{
name|int
name|error
decl_stmt|;
name|error
operator|=
name|ahc_create_path
argument_list|(
name|ahc
argument_list|,
name|devinfo
argument_list|,
operator|&
name|path2
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|CAM_REQ_CMP
condition|)
name|path
operator|=
name|path2
expr_stmt|;
else|else
name|path2
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|path
operator|!=
name|NULL
condition|)
block|{
name|struct
name|ccb_trans_settings
name|neg
decl_stmt|;
name|neg
operator|.
name|sync_period
operator|=
name|period
expr_stmt|;
name|neg
operator|.
name|sync_offset
operator|=
name|offset
expr_stmt|;
name|neg
operator|.
name|valid
operator|=
name|CCB_TRANS_SYNC_RATE_VALID
operator||
name|CCB_TRANS_SYNC_OFFSET_VALID
expr_stmt|;
name|xpt_setup_ccb
argument_list|(
operator|&
name|neg
operator|.
name|ccb_h
argument_list|,
name|path
argument_list|,
comment|/*priority*/
literal|1
argument_list|)
expr_stmt|;
name|xpt_async
argument_list|(
name|AC_TRANSFER_NEG
argument_list|,
name|path
argument_list|,
operator|&
name|neg
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|path2
operator|!=
name|NULL
condition|)
name|xpt_free_path
argument_list|(
name|path2
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
block|{
if|if
condition|(
name|offset
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%s: target %d synchronous at %sMHz, "
literal|"offset = 0x%x\n"
argument_list|,
name|ahc_name
argument_list|(
name|ahc
argument_list|)
argument_list|,
name|devinfo
operator|->
name|target
argument_list|,
name|syncrate
operator|->
name|rate
argument_list|,
name|offset
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"%s: target %d using "
literal|"asynchronous transfers\n"
argument_list|,
name|ahc_name
argument_list|(
name|ahc
argument_list|)
argument_list|,
name|devinfo
operator|->
name|target
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|(
name|type
operator|&
name|AHC_TRANS_GOAL
operator|)
operator|!=
literal|0
condition|)
block|{
name|tinfo
operator|->
name|goal
operator|.
name|period
operator|=
name|period
expr_stmt|;
name|tinfo
operator|->
name|goal
operator|.
name|offset
operator|=
name|offset
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|type
operator|&
name|AHC_TRANS_USER
operator|)
operator|!=
literal|0
condition|)
block|{
name|tinfo
operator|->
name|user
operator|.
name|period
operator|=
name|period
expr_stmt|;
name|tinfo
operator|->
name|user
operator|.
name|offset
operator|=
name|offset
expr_stmt|;
block|}
name|ahc_update_target_msg_request
argument_list|(
name|ahc
argument_list|,
name|devinfo
argument_list|,
name|tinfo
argument_list|,
comment|/*force*/
name|FALSE
argument_list|,
name|paused
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ahc_set_width
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|struct
name|ahc_devinfo
modifier|*
name|devinfo
parameter_list|,
name|struct
name|cam_path
modifier|*
name|path
parameter_list|,
name|u_int
name|width
parameter_list|,
name|u_int
name|type
parameter_list|,
name|int
name|paused
parameter_list|)
block|{
name|struct
name|ahc_initiator_tinfo
modifier|*
name|tinfo
decl_stmt|;
name|struct
name|tmode_tstate
modifier|*
name|tstate
decl_stmt|;
name|u_int
name|oldwidth
decl_stmt|;
name|int
name|active
init|=
operator|(
name|type
operator|&
name|AHC_TRANS_ACTIVE
operator|)
operator|==
name|AHC_TRANS_ACTIVE
decl_stmt|;
name|tinfo
operator|=
name|ahc_fetch_transinfo
argument_list|(
name|ahc
argument_list|,
name|devinfo
operator|->
name|channel
argument_list|,
name|devinfo
operator|->
name|our_scsiid
argument_list|,
name|devinfo
operator|->
name|target
argument_list|,
operator|&
name|tstate
argument_list|)
expr_stmt|;
name|oldwidth
operator|=
name|tinfo
operator|->
name|current
operator|.
name|width
expr_stmt|;
if|if
condition|(
operator|(
name|type
operator|&
name|AHC_TRANS_CUR
operator|)
operator|!=
literal|0
operator|&&
name|oldwidth
operator|!=
name|width
condition|)
block|{
name|struct
name|cam_path
modifier|*
name|path2
decl_stmt|;
name|u_int
name|scsirate
decl_stmt|;
name|scsirate
operator|=
name|tinfo
operator|->
name|scsirate
expr_stmt|;
name|scsirate
operator|&=
operator|~
name|WIDEXFER
expr_stmt|;
if|if
condition|(
name|width
operator|==
name|MSG_EXT_WDTR_BUS_16_BIT
condition|)
name|scsirate
operator||=
name|WIDEXFER
expr_stmt|;
name|tinfo
operator|->
name|scsirate
operator|=
name|scsirate
expr_stmt|;
if|if
condition|(
name|active
condition|)
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCSIRATE
argument_list|,
name|scsirate
argument_list|)
expr_stmt|;
name|tinfo
operator|->
name|current
operator|.
name|width
operator|=
name|width
expr_stmt|;
comment|/* If possible, update the XPT's notion of our transfer rate */
name|path2
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|path
operator|==
name|NULL
condition|)
block|{
name|int
name|error
decl_stmt|;
name|error
operator|=
name|ahc_create_path
argument_list|(
name|ahc
argument_list|,
name|devinfo
argument_list|,
operator|&
name|path2
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|CAM_REQ_CMP
condition|)
name|path
operator|=
name|path2
expr_stmt|;
else|else
name|path2
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|path
operator|!=
name|NULL
condition|)
block|{
name|struct
name|ccb_trans_settings
name|neg
decl_stmt|;
name|neg
operator|.
name|bus_width
operator|=
name|width
expr_stmt|;
name|neg
operator|.
name|valid
operator|=
name|CCB_TRANS_BUS_WIDTH_VALID
expr_stmt|;
name|xpt_setup_ccb
argument_list|(
operator|&
name|neg
operator|.
name|ccb_h
argument_list|,
name|path
argument_list|,
comment|/*priority*/
literal|1
argument_list|)
expr_stmt|;
name|xpt_async
argument_list|(
name|AC_TRANSFER_NEG
argument_list|,
name|path
argument_list|,
operator|&
name|neg
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|path2
operator|!=
name|NULL
condition|)
name|xpt_free_path
argument_list|(
name|path2
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
block|{
name|printf
argument_list|(
literal|"%s: target %d using %dbit transfers\n"
argument_list|,
name|ahc_name
argument_list|(
name|ahc
argument_list|)
argument_list|,
name|devinfo
operator|->
name|target
argument_list|,
literal|8
operator|*
operator|(
literal|0x01
operator|<<
name|width
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|type
operator|&
name|AHC_TRANS_GOAL
operator|)
operator|!=
literal|0
condition|)
name|tinfo
operator|->
name|goal
operator|.
name|width
operator|=
name|width
expr_stmt|;
if|if
condition|(
operator|(
name|type
operator|&
name|AHC_TRANS_USER
operator|)
operator|!=
literal|0
condition|)
name|tinfo
operator|->
name|user
operator|.
name|width
operator|=
name|width
expr_stmt|;
name|ahc_update_target_msg_request
argument_list|(
name|ahc
argument_list|,
name|devinfo
argument_list|,
name|tinfo
argument_list|,
comment|/*force*/
name|FALSE
argument_list|,
name|paused
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ahc_set_tags
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|struct
name|ahc_devinfo
modifier|*
name|devinfo
parameter_list|,
name|int
name|enable
parameter_list|)
block|{
name|struct
name|ahc_initiator_tinfo
modifier|*
name|tinfo
decl_stmt|;
name|struct
name|tmode_tstate
modifier|*
name|tstate
decl_stmt|;
name|tinfo
operator|=
name|ahc_fetch_transinfo
argument_list|(
name|ahc
argument_list|,
name|devinfo
operator|->
name|channel
argument_list|,
name|devinfo
operator|->
name|our_scsiid
argument_list|,
name|devinfo
operator|->
name|target
argument_list|,
operator|&
name|tstate
argument_list|)
expr_stmt|;
if|if
condition|(
name|enable
condition|)
name|tstate
operator|->
name|tagenable
operator||=
name|devinfo
operator|->
name|target_mask
expr_stmt|;
else|else
name|tstate
operator|->
name|tagenable
operator|&=
operator|~
name|devinfo
operator|->
name|target_mask
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Attach all the sub-devices we can find  */
end_comment

begin_function
name|int
name|ahc_attach
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|)
block|{
name|struct
name|ccb_setasync
name|csa
decl_stmt|;
name|struct
name|cam_devq
modifier|*
name|devq
decl_stmt|;
name|int
name|bus_id
decl_stmt|;
name|int
name|bus_id2
decl_stmt|;
name|struct
name|cam_sim
modifier|*
name|sim
decl_stmt|;
name|struct
name|cam_sim
modifier|*
name|sim2
decl_stmt|;
name|struct
name|cam_path
modifier|*
name|path
decl_stmt|;
name|struct
name|cam_path
modifier|*
name|path2
decl_stmt|;
name|int
name|count
decl_stmt|;
name|int
name|s
decl_stmt|;
name|int
name|error
decl_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
name|sim
operator|=
name|NULL
expr_stmt|;
name|sim2
operator|=
name|NULL
expr_stmt|;
name|s
operator|=
name|splcam
argument_list|()
expr_stmt|;
comment|/* Hook up our interrupt handler */
if|if
condition|(
operator|(
name|error
operator|=
name|bus_setup_intr
argument_list|(
name|ahc
operator|->
name|device
argument_list|,
name|ahc
operator|->
name|irq
argument_list|,
name|INTR_TYPE_CAM
argument_list|,
name|ahc_intr
argument_list|,
name|ahc
argument_list|,
operator|&
name|ahc
operator|->
name|ih
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|ahc
operator|->
name|device
argument_list|,
literal|"bus_setup_intr() failed: %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* 	 * Attach secondary channel first if the user has 	 * declared it the primary channel. 	 */
if|if
condition|(
operator|(
name|ahc
operator|->
name|flags
operator|&
name|AHC_CHANNEL_B_PRIMARY
operator|)
operator|!=
literal|0
condition|)
block|{
name|bus_id
operator|=
literal|1
expr_stmt|;
name|bus_id2
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|bus_id
operator|=
literal|0
expr_stmt|;
name|bus_id2
operator|=
literal|1
expr_stmt|;
block|}
comment|/* 	 * Create the device queue for our SIM(s). 	 */
name|devq
operator|=
name|cam_simq_alloc
argument_list|(
name|AHC_SCB_MAX
argument_list|)
expr_stmt|;
if|if
condition|(
name|devq
operator|==
name|NULL
condition|)
goto|goto
name|fail
goto|;
comment|/* 	 * Construct our first channel SIM entry 	 */
name|sim
operator|=
name|cam_sim_alloc
argument_list|(
name|ahc_action
argument_list|,
name|ahc_poll
argument_list|,
literal|"ahc"
argument_list|,
name|ahc
argument_list|,
name|ahc
operator|->
name|unit
argument_list|,
literal|1
argument_list|,
name|AHC_SCB_MAX
argument_list|,
name|devq
argument_list|)
expr_stmt|;
if|if
condition|(
name|sim
operator|==
name|NULL
condition|)
block|{
name|cam_simq_free
argument_list|(
name|devq
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
if|if
condition|(
name|xpt_bus_register
argument_list|(
name|sim
argument_list|,
name|bus_id
argument_list|)
operator|!=
name|CAM_SUCCESS
condition|)
block|{
name|cam_sim_free
argument_list|(
name|sim
argument_list|,
comment|/*free_devq*/
name|TRUE
argument_list|)
expr_stmt|;
name|sim
operator|=
name|NULL
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
if|if
condition|(
name|xpt_create_path
argument_list|(
operator|&
name|path
argument_list|,
comment|/*periph*/
name|NULL
argument_list|,
name|cam_sim_path
argument_list|(
name|sim
argument_list|)
argument_list|,
name|CAM_TARGET_WILDCARD
argument_list|,
name|CAM_LUN_WILDCARD
argument_list|)
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|xpt_bus_deregister
argument_list|(
name|cam_sim_path
argument_list|(
name|sim
argument_list|)
argument_list|)
expr_stmt|;
name|cam_sim_free
argument_list|(
name|sim
argument_list|,
comment|/*free_devq*/
name|TRUE
argument_list|)
expr_stmt|;
name|sim
operator|=
name|NULL
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|xpt_setup_ccb
argument_list|(
operator|&
name|csa
operator|.
name|ccb_h
argument_list|,
name|path
argument_list|,
comment|/*priority*/
literal|5
argument_list|)
expr_stmt|;
name|csa
operator|.
name|ccb_h
operator|.
name|func_code
operator|=
name|XPT_SASYNC_CB
expr_stmt|;
name|csa
operator|.
name|event_enable
operator|=
name|AC_LOST_DEVICE
expr_stmt|;
name|csa
operator|.
name|callback
operator|=
name|ahc_async
expr_stmt|;
name|csa
operator|.
name|callback_arg
operator|=
name|sim
expr_stmt|;
name|xpt_action
argument_list|(
operator|(
expr|union
name|ccb
operator|*
operator|)
operator|&
name|csa
argument_list|)
expr_stmt|;
name|count
operator|++
expr_stmt|;
if|if
condition|(
name|ahc
operator|->
name|features
operator|&
name|AHC_TWIN
condition|)
block|{
name|sim2
operator|=
name|cam_sim_alloc
argument_list|(
name|ahc_action
argument_list|,
name|ahc_poll
argument_list|,
literal|"ahc"
argument_list|,
name|ahc
argument_list|,
name|ahc
operator|->
name|unit
argument_list|,
literal|1
argument_list|,
name|AHC_SCB_MAX
argument_list|,
name|devq
argument_list|)
expr_stmt|;
if|if
condition|(
name|sim2
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"ahc_attach: Unable to attach second "
literal|"bus due to resource shortage"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
if|if
condition|(
name|xpt_bus_register
argument_list|(
name|sim2
argument_list|,
name|bus_id2
argument_list|)
operator|!=
name|CAM_SUCCESS
condition|)
block|{
name|printf
argument_list|(
literal|"ahc_attach: Unable to attach second "
literal|"bus due to resource shortage"
argument_list|)
expr_stmt|;
comment|/* 			 * We do not want to destroy the device queue 			 * because the first bus is using it. 			 */
name|cam_sim_free
argument_list|(
name|sim2
argument_list|,
comment|/*free_devq*/
name|FALSE
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
if|if
condition|(
name|xpt_create_path
argument_list|(
operator|&
name|path2
argument_list|,
comment|/*periph*/
name|NULL
argument_list|,
name|cam_sim_path
argument_list|(
name|sim2
argument_list|)
argument_list|,
name|CAM_TARGET_WILDCARD
argument_list|,
name|CAM_LUN_WILDCARD
argument_list|)
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|xpt_bus_deregister
argument_list|(
name|cam_sim_path
argument_list|(
name|sim2
argument_list|)
argument_list|)
expr_stmt|;
name|cam_sim_free
argument_list|(
name|sim2
argument_list|,
comment|/*free_devq*/
name|FALSE
argument_list|)
expr_stmt|;
name|sim2
operator|=
name|NULL
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|xpt_setup_ccb
argument_list|(
operator|&
name|csa
operator|.
name|ccb_h
argument_list|,
name|path2
argument_list|,
comment|/*priority*/
literal|5
argument_list|)
expr_stmt|;
name|csa
operator|.
name|ccb_h
operator|.
name|func_code
operator|=
name|XPT_SASYNC_CB
expr_stmt|;
name|csa
operator|.
name|event_enable
operator|=
name|AC_LOST_DEVICE
expr_stmt|;
name|csa
operator|.
name|callback
operator|=
name|ahc_async
expr_stmt|;
name|csa
operator|.
name|callback_arg
operator|=
name|sim2
expr_stmt|;
name|xpt_action
argument_list|(
operator|(
expr|union
name|ccb
operator|*
operator|)
operator|&
name|csa
argument_list|)
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
name|fail
label|:
if|if
condition|(
operator|(
name|ahc
operator|->
name|flags
operator|&
name|AHC_CHANNEL_B_PRIMARY
operator|)
operator|!=
literal|0
condition|)
block|{
name|ahc
operator|->
name|sim_b
operator|=
name|sim
expr_stmt|;
name|ahc
operator|->
name|path_b
operator|=
name|path
expr_stmt|;
name|ahc
operator|->
name|sim
operator|=
name|sim2
expr_stmt|;
name|ahc
operator|->
name|path
operator|=
name|path2
expr_stmt|;
block|}
else|else
block|{
name|ahc
operator|->
name|sim
operator|=
name|sim
expr_stmt|;
name|ahc
operator|->
name|path
operator|=
name|path
expr_stmt|;
name|ahc
operator|->
name|sim_b
operator|=
name|sim2
expr_stmt|;
name|ahc
operator|->
name|path_b
operator|=
name|path2
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|count
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ahc_scb_devinfo
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|struct
name|ahc_devinfo
modifier|*
name|devinfo
parameter_list|,
name|struct
name|scb
modifier|*
name|scb
parameter_list|)
block|{
name|role_t
name|role
decl_stmt|;
name|int
name|our_id
decl_stmt|;
if|if
condition|(
name|scb
operator|->
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|==
name|XPT_CONT_TARGET_IO
condition|)
block|{
name|our_id
operator|=
name|scb
operator|->
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
expr_stmt|;
name|role
operator|=
name|ROLE_TARGET
expr_stmt|;
block|}
else|else
block|{
name|our_id
operator|=
name|SCB_CHANNEL
argument_list|(
name|scb
argument_list|)
operator|==
literal|'B'
condition|?
name|ahc
operator|->
name|our_id_b
else|:
name|ahc
operator|->
name|our_id
expr_stmt|;
name|role
operator|=
name|ROLE_INITIATOR
expr_stmt|;
block|}
name|ahc_compile_devinfo
argument_list|(
name|devinfo
argument_list|,
name|our_id
argument_list|,
name|SCB_TARGET
argument_list|(
name|scb
argument_list|)
argument_list|,
name|SCB_LUN
argument_list|(
name|scb
argument_list|)
argument_list|,
name|SCB_CHANNEL
argument_list|(
name|scb
argument_list|)
argument_list|,
name|role
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ahc_fetch_devinfo
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|struct
name|ahc_devinfo
modifier|*
name|devinfo
parameter_list|)
block|{
name|u_int
name|saved_tcl
decl_stmt|;
name|role_t
name|role
decl_stmt|;
name|int
name|our_id
decl_stmt|;
if|if
condition|(
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SSTAT0
argument_list|)
operator|&
name|TARGET
condition|)
name|role
operator|=
name|ROLE_TARGET
expr_stmt|;
else|else
name|role
operator|=
name|ROLE_INITIATOR
expr_stmt|;
if|if
condition|(
name|role
operator|==
name|ROLE_TARGET
operator|&&
operator|(
name|ahc
operator|->
name|features
operator|&
name|AHC_MULTI_TID
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SEQ_FLAGS
argument_list|)
operator|&
name|CMDPHASE_PENDING
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* We were selected, so pull our id from TARGIDIN */
name|our_id
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|TARGIDIN
argument_list|)
operator|&
name|OID
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|ahc
operator|->
name|features
operator|&
name|AHC_ULTRA2
operator|)
operator|!=
literal|0
condition|)
name|our_id
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCSIID_ULTRA2
argument_list|)
operator|&
name|OID
expr_stmt|;
else|else
name|our_id
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCSIID
argument_list|)
operator|&
name|OID
expr_stmt|;
name|saved_tcl
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SAVED_TCL
argument_list|)
expr_stmt|;
name|ahc_compile_devinfo
argument_list|(
name|devinfo
argument_list|,
name|our_id
argument_list|,
name|TCL_TARGET
argument_list|(
name|saved_tcl
argument_list|)
argument_list|,
name|TCL_LUN
argument_list|(
name|saved_tcl
argument_list|)
argument_list|,
name|TCL_CHANNEL
argument_list|(
name|ahc
argument_list|,
name|saved_tcl
argument_list|)
argument_list|,
name|role
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ahc_compile_devinfo
parameter_list|(
name|struct
name|ahc_devinfo
modifier|*
name|devinfo
parameter_list|,
name|u_int
name|our_id
parameter_list|,
name|u_int
name|target
parameter_list|,
name|u_int
name|lun
parameter_list|,
name|char
name|channel
parameter_list|,
name|role_t
name|role
parameter_list|)
block|{
name|devinfo
operator|->
name|our_scsiid
operator|=
name|our_id
expr_stmt|;
name|devinfo
operator|->
name|target
operator|=
name|target
expr_stmt|;
name|devinfo
operator|->
name|lun
operator|=
name|lun
expr_stmt|;
name|devinfo
operator|->
name|target_offset
operator|=
name|target
expr_stmt|;
name|devinfo
operator|->
name|channel
operator|=
name|channel
expr_stmt|;
name|devinfo
operator|->
name|role
operator|=
name|role
expr_stmt|;
if|if
condition|(
name|channel
operator|==
literal|'B'
condition|)
name|devinfo
operator|->
name|target_offset
operator|+=
literal|8
expr_stmt|;
name|devinfo
operator|->
name|target_mask
operator|=
operator|(
literal|0x01
operator|<<
name|devinfo
operator|->
name|target_offset
operator|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Catch an interrupt from the adapter  */
end_comment

begin_function
name|void
name|ahc_intr
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ahc_softc
modifier|*
name|ahc
decl_stmt|;
name|u_int
name|intstat
decl_stmt|;
name|ahc
operator|=
operator|(
expr|struct
name|ahc_softc
operator|*
operator|)
name|arg
expr_stmt|;
name|intstat
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|INTSTAT
argument_list|)
expr_stmt|;
comment|/* 	 * Any interrupts to process? 	 */
if|#
directive|if
name|NPCI
operator|>
literal|0
if|if
condition|(
operator|(
name|intstat
operator|&
name|INT_PEND
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|ahc
operator|->
name|chip
operator|&
name|AHC_PCI
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|ahc
operator|->
name|unsolicited_ints
operator|>
literal|500
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|ERROR
argument_list|)
operator|&
name|PCIERRSTAT
operator|)
operator|!=
literal|0
condition|)
name|ahc_pci_intr
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
name|ahc
operator|->
name|unsolicited_ints
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|ahc
operator|->
name|unsolicited_ints
operator|++
expr_stmt|;
block|}
return|return;
block|}
else|else
block|{
name|ahc
operator|->
name|unsolicited_ints
operator|=
literal|0
expr_stmt|;
block|}
else|#
directive|else
if|if
condition|(
operator|(
name|intstat
operator|&
name|INT_PEND
operator|)
operator|==
literal|0
condition|)
return|return;
endif|#
directive|endif
if|if
condition|(
name|intstat
operator|&
name|CMDCMPLT
condition|)
block|{
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|CLRINT
argument_list|,
name|CLRCMDINT
argument_list|)
expr_stmt|;
name|ahc_run_qoutfifo
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ahc
operator|->
name|flags
operator|&
name|AHC_TARGETMODE
operator|)
operator|!=
literal|0
condition|)
block|{
name|ahc_run_tqinfifo
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|intstat
operator|&
name|BRKADRINT
condition|)
block|{
comment|/* 		 * We upset the sequencer :-( 		 * Lookup the error message 		 */
name|int
name|i
decl_stmt|,
name|error
decl_stmt|,
name|num_errors
decl_stmt|;
name|error
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|ERROR
argument_list|)
expr_stmt|;
name|num_errors
operator|=
sizeof|sizeof
argument_list|(
name|hard_error
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|hard_error
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|error
operator|!=
literal|1
operator|&&
name|i
operator|<
name|num_errors
condition|;
name|i
operator|++
control|)
name|error
operator|>>=
literal|1
expr_stmt|;
name|panic
argument_list|(
literal|"%s: brkadrint, %s at seqaddr = 0x%x\n"
argument_list|,
name|ahc_name
argument_list|(
name|ahc
argument_list|)
argument_list|,
name|hard_error
index|[
name|i
index|]
operator|.
name|errmesg
argument_list|,
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SEQADDR0
argument_list|)
operator||
operator|(
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SEQADDR1
argument_list|)
operator|<<
literal|8
operator|)
argument_list|)
expr_stmt|;
comment|/* Tell everyone that this HBA is no longer availible */
name|ahc_abort_scbs
argument_list|(
name|ahc
argument_list|,
name|CAM_TARGET_WILDCARD
argument_list|,
name|ALL_CHANNELS
argument_list|,
name|CAM_LUN_WILDCARD
argument_list|,
name|SCB_LIST_NULL
argument_list|,
name|ROLE_UNKNOWN
argument_list|,
name|CAM_NO_HBA
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|intstat
operator|&
name|SEQINT
condition|)
name|ahc_handle_seqint
argument_list|(
name|ahc
argument_list|,
name|intstat
argument_list|)
expr_stmt|;
if|if
condition|(
name|intstat
operator|&
name|SCSIINT
condition|)
name|ahc_handle_scsiint
argument_list|(
name|ahc
argument_list|,
name|intstat
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|struct
name|tmode_tstate
modifier|*
name|ahc_alloc_tstate
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|u_int
name|scsi_id
parameter_list|,
name|char
name|channel
parameter_list|)
block|{
name|struct
name|tmode_tstate
modifier|*
name|master_tstate
decl_stmt|;
name|struct
name|tmode_tstate
modifier|*
name|tstate
decl_stmt|;
name|int
name|i
decl_stmt|,
name|s
decl_stmt|;
name|master_tstate
operator|=
name|ahc
operator|->
name|enabled_targets
index|[
name|ahc
operator|->
name|our_id
index|]
expr_stmt|;
if|if
condition|(
name|channel
operator|==
literal|'B'
condition|)
block|{
name|scsi_id
operator|+=
literal|8
expr_stmt|;
name|master_tstate
operator|=
name|ahc
operator|->
name|enabled_targets
index|[
name|ahc
operator|->
name|our_id_b
operator|+
literal|8
index|]
expr_stmt|;
block|}
if|if
condition|(
name|ahc
operator|->
name|enabled_targets
index|[
name|scsi_id
index|]
operator|!=
name|NULL
operator|&&
name|ahc
operator|->
name|enabled_targets
index|[
name|scsi_id
index|]
operator|!=
name|master_tstate
condition|)
name|panic
argument_list|(
literal|"%s: ahc_alloc_tstate - Target already allocated"
argument_list|,
name|ahc_name
argument_list|(
name|ahc
argument_list|)
argument_list|)
expr_stmt|;
name|tstate
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|tstate
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|tstate
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* 	 * If we have allocated a master tstate, copy user settings from 	 * the master tstate (taken from SRAM or the EEPROM) for this 	 * channel, but reset our current and goal settings to async/narrow 	 * until an initiator talks to us. 	 */
if|if
condition|(
name|master_tstate
operator|!=
name|NULL
condition|)
block|{
name|bcopy
argument_list|(
name|master_tstate
argument_list|,
name|tstate
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|tstate
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|tstate
operator|->
name|enabled_luns
argument_list|,
sizeof|sizeof
argument_list|(
name|tstate
operator|->
name|enabled_luns
argument_list|)
argument_list|)
expr_stmt|;
name|tstate
operator|->
name|ultraenb
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
block|{
name|bzero
argument_list|(
operator|&
name|tstate
operator|->
name|transinfo
index|[
name|i
index|]
operator|.
name|current
argument_list|,
sizeof|sizeof
argument_list|(
name|tstate
operator|->
name|transinfo
index|[
name|i
index|]
operator|.
name|current
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|tstate
operator|->
name|transinfo
index|[
name|i
index|]
operator|.
name|goal
argument_list|,
sizeof|sizeof
argument_list|(
name|tstate
operator|->
name|transinfo
index|[
name|i
index|]
operator|.
name|goal
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|bzero
argument_list|(
name|tstate
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|tstate
argument_list|)
argument_list|)
expr_stmt|;
name|s
operator|=
name|splcam
argument_list|()
expr_stmt|;
name|ahc
operator|->
name|enabled_targets
index|[
name|scsi_id
index|]
operator|=
name|tstate
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|tstate
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ahc_free_tstate
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|u_int
name|scsi_id
parameter_list|,
name|char
name|channel
parameter_list|,
name|int
name|force
parameter_list|)
block|{
name|struct
name|tmode_tstate
modifier|*
name|tstate
decl_stmt|;
comment|/* Don't clean up the entry for our initiator role */
if|if
condition|(
operator|(
name|ahc
operator|->
name|flags
operator|&
name|AHC_INITIATORMODE
operator|)
operator|!=
literal|0
operator|&&
operator|(
operator|(
name|channel
operator|==
literal|'B'
operator|&&
name|scsi_id
operator|==
name|ahc
operator|->
name|our_id_b
operator|)
operator|||
operator|(
name|channel
operator|==
literal|'A'
operator|&&
name|scsi_id
operator|==
name|ahc
operator|->
name|our_id
operator|)
operator|)
operator|&&
name|force
operator|==
name|FALSE
condition|)
return|return;
if|if
condition|(
name|channel
operator|==
literal|'B'
condition|)
name|scsi_id
operator|+=
literal|8
expr_stmt|;
name|tstate
operator|=
name|ahc
operator|->
name|enabled_targets
index|[
name|scsi_id
index|]
expr_stmt|;
if|if
condition|(
name|tstate
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|tstate
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|ahc
operator|->
name|enabled_targets
index|[
name|scsi_id
index|]
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ahc_handle_en_lun
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|struct
name|cam_sim
modifier|*
name|sim
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
block|{
name|struct
name|tmode_tstate
modifier|*
name|tstate
decl_stmt|;
name|struct
name|tmode_lstate
modifier|*
name|lstate
decl_stmt|;
name|struct
name|ccb_en_lun
modifier|*
name|cel
decl_stmt|;
name|cam_status
name|status
decl_stmt|;
name|int
name|target
decl_stmt|;
name|int
name|lun
decl_stmt|;
name|u_int
name|target_mask
decl_stmt|;
name|char
name|channel
decl_stmt|;
name|int
name|s
decl_stmt|;
name|status
operator|=
name|ahc_find_tmode_devs
argument_list|(
name|ahc
argument_list|,
name|sim
argument_list|,
name|ccb
argument_list|,
operator|&
name|tstate
argument_list|,
operator|&
name|lstate
argument_list|,
comment|/* notfound_failure*/
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|status
expr_stmt|;
return|return;
block|}
name|cel
operator|=
operator|&
name|ccb
operator|->
name|cel
expr_stmt|;
name|target
operator|=
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
expr_stmt|;
name|lun
operator|=
name|ccb
operator|->
name|ccb_h
operator|.
name|target_lun
expr_stmt|;
name|channel
operator|=
name|SIM_CHANNEL
argument_list|(
name|ahc
argument_list|,
name|sim
argument_list|)
expr_stmt|;
name|target_mask
operator|=
literal|0x01
operator|<<
name|target
expr_stmt|;
if|if
condition|(
name|channel
operator|==
literal|'B'
condition|)
name|target_mask
operator|<<=
literal|8
expr_stmt|;
if|if
condition|(
name|cel
operator|->
name|enable
operator|!=
literal|0
condition|)
block|{
name|u_int
name|scsiseq
decl_stmt|;
comment|/* Are we already enabled?? */
if|if
condition|(
name|lstate
operator|!=
name|NULL
condition|)
block|{
name|xpt_print_path
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Lun already enabled\n"
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_LUN_ALRDY_ENA
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|cel
operator|->
name|grp6_len
operator|!=
literal|0
operator|||
name|cel
operator|->
name|grp7_len
operator|!=
literal|0
condition|)
block|{
comment|/* 			 * Don't (yet?) support vendor 			 * specific commands. 			 */
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_INVALID
expr_stmt|;
name|printf
argument_list|(
literal|"Non-zero Group Codes\n"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 		 * Seems to be okay. 		 * Setup our data structures. 		 */
if|if
condition|(
name|target
operator|!=
name|CAM_TARGET_WILDCARD
operator|&&
name|tstate
operator|==
name|NULL
condition|)
block|{
name|tstate
operator|=
name|ahc_alloc_tstate
argument_list|(
name|ahc
argument_list|,
name|target
argument_list|,
name|channel
argument_list|)
expr_stmt|;
if|if
condition|(
name|tstate
operator|==
name|NULL
condition|)
block|{
name|xpt_print_path
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Couldn't allocate tstate\n"
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_RESRC_UNAVAIL
expr_stmt|;
return|return;
block|}
block|}
name|lstate
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|lstate
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|lstate
operator|==
name|NULL
condition|)
block|{
name|xpt_print_path
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Couldn't allocate lstate\n"
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_RESRC_UNAVAIL
expr_stmt|;
return|return;
block|}
name|bzero
argument_list|(
name|lstate
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|lstate
argument_list|)
argument_list|)
expr_stmt|;
name|status
operator|=
name|xpt_create_path
argument_list|(
operator|&
name|lstate
operator|->
name|path
argument_list|,
comment|/*periph*/
name|NULL
argument_list|,
name|xpt_path_path_id
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|)
argument_list|,
name|xpt_path_target_id
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|)
argument_list|,
name|xpt_path_lun_id
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|free
argument_list|(
name|lstate
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|xpt_print_path
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Couldn't allocate path\n"
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_RESRC_UNAVAIL
expr_stmt|;
return|return;
block|}
name|SLIST_INIT
argument_list|(
operator|&
name|lstate
operator|->
name|accept_tios
argument_list|)
expr_stmt|;
name|SLIST_INIT
argument_list|(
operator|&
name|lstate
operator|->
name|immed_notifies
argument_list|)
expr_stmt|;
name|s
operator|=
name|splcam
argument_list|()
expr_stmt|;
name|pause_sequencer
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
operator|!=
name|CAM_TARGET_WILDCARD
condition|)
block|{
name|tstate
operator|->
name|enabled_luns
index|[
name|lun
index|]
operator|=
name|lstate
expr_stmt|;
name|ahc
operator|->
name|enabled_luns
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|ahc
operator|->
name|features
operator|&
name|AHC_MULTI_TID
operator|)
operator|!=
literal|0
condition|)
block|{
name|u_int16_t
name|targid_mask
decl_stmt|;
name|targid_mask
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|TARGID
argument_list|)
operator||
operator|(
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|TARGID
operator|+
literal|1
argument_list|)
operator|<<
literal|8
operator|)
expr_stmt|;
name|targid_mask
operator||=
name|target_mask
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|TARGID
argument_list|,
name|targid_mask
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|TARGID
operator|+
literal|1
argument_list|,
operator|(
name|targid_mask
operator|>>
literal|8
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|our_id
decl_stmt|;
name|char
name|channel
decl_stmt|;
name|channel
operator|=
name|SIM_CHANNEL
argument_list|(
name|ahc
argument_list|,
name|sim
argument_list|)
expr_stmt|;
name|our_id
operator|=
name|SIM_SCSI_ID
argument_list|(
name|ahc
argument_list|,
name|sim
argument_list|)
expr_stmt|;
comment|/* 				 * This can only happen if selections 				 * are not enabled 				 */
if|if
condition|(
name|target
operator|!=
name|our_id
condition|)
block|{
name|u_int
name|sblkctl
decl_stmt|;
name|char
name|cur_channel
decl_stmt|;
name|int
name|swap
decl_stmt|;
name|sblkctl
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SBLKCTL
argument_list|)
expr_stmt|;
name|cur_channel
operator|=
operator|(
name|sblkctl
operator|&
name|SELBUSB
operator|)
condition|?
literal|'B'
else|:
literal|'A'
expr_stmt|;
if|if
condition|(
operator|(
name|ahc
operator|->
name|features
operator|&
name|AHC_TWIN
operator|)
operator|==
literal|0
condition|)
name|cur_channel
operator|=
literal|'A'
expr_stmt|;
name|swap
operator|=
name|cur_channel
operator|!=
name|channel
expr_stmt|;
if|if
condition|(
name|channel
operator|==
literal|'A'
condition|)
name|ahc
operator|->
name|our_id
operator|=
name|target
expr_stmt|;
else|else
name|ahc
operator|->
name|our_id_b
operator|=
name|target
expr_stmt|;
if|if
condition|(
name|swap
condition|)
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SBLKCTL
argument_list|,
name|sblkctl
operator|^
name|SELBUSB
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCSIID
argument_list|,
name|target
argument_list|)
expr_stmt|;
if|if
condition|(
name|swap
condition|)
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SBLKCTL
argument_list|,
name|sblkctl
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
name|ahc
operator|->
name|black_hole
operator|=
name|lstate
expr_stmt|;
comment|/* Allow select-in operations */
if|if
condition|(
name|ahc
operator|->
name|black_hole
operator|!=
name|NULL
operator|&&
name|ahc
operator|->
name|enabled_luns
operator|>
literal|0
condition|)
block|{
name|scsiseq
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCSISEQ_TEMPLATE
argument_list|)
expr_stmt|;
name|scsiseq
operator||=
name|ENSELI
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCSISEQ_TEMPLATE
argument_list|,
name|scsiseq
argument_list|)
expr_stmt|;
name|scsiseq
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCSISEQ
argument_list|)
expr_stmt|;
name|scsiseq
operator||=
name|ENSELI
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCSISEQ
argument_list|,
name|scsiseq
argument_list|)
expr_stmt|;
block|}
name|unpause_sequencer
argument_list|(
name|ahc
argument_list|,
comment|/*always?*/
name|FALSE
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
name|xpt_print_path
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Lun now enabled for target mode\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|struct
name|ccb_hdr
modifier|*
name|elm
decl_stmt|;
if|if
condition|(
name|lstate
operator|==
name|NULL
condition|)
block|{
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_LUN_INVALID
expr_stmt|;
return|return;
block|}
name|s
operator|=
name|splcam
argument_list|()
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|elm
argument_list|,
argument|&ahc->pending_ccbs
argument_list|,
argument|sim_links.le
argument_list|)
block|{
if|if
condition|(
name|elm
operator|->
name|func_code
operator|==
name|XPT_CONT_TARGET_IO
operator|&&
operator|!
name|xpt_path_comp
argument_list|(
name|elm
operator|->
name|path
argument_list|,
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"CTIO pending\n"
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_INVALID
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
if|if
condition|(
name|SLIST_FIRST
argument_list|(
operator|&
name|lstate
operator|->
name|accept_tios
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"ATIOs pending\n"
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_INVALID
expr_stmt|;
block|}
if|if
condition|(
name|SLIST_FIRST
argument_list|(
operator|&
name|lstate
operator|->
name|immed_notifies
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"INOTs pending\n"
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_INVALID
expr_stmt|;
block|}
if|if
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|==
name|CAM_REQ_CMP
condition|)
block|{
name|int
name|i
decl_stmt|,
name|empty
decl_stmt|;
name|xpt_print_path
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Target mode disabled\n"
argument_list|)
expr_stmt|;
name|xpt_free_path
argument_list|(
name|lstate
operator|->
name|path
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|lstate
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|pause_sequencer
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
comment|/* Can we clean up the target too? */
if|if
condition|(
name|target
operator|!=
name|CAM_TARGET_WILDCARD
condition|)
block|{
name|tstate
operator|->
name|enabled_luns
index|[
name|lun
index|]
operator|=
name|NULL
expr_stmt|;
name|ahc
operator|->
name|enabled_luns
operator|--
expr_stmt|;
for|for
control|(
name|empty
operator|=
literal|1
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|tstate
operator|->
name|enabled_luns
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
block|{
name|empty
operator|=
literal|0
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|empty
condition|)
block|{
name|ahc_free_tstate
argument_list|(
name|ahc
argument_list|,
name|target
argument_list|,
name|channel
argument_list|,
comment|/*force*/
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|ahc
operator|->
name|features
operator|&
name|AHC_MULTI_TID
condition|)
block|{
name|u_int16_t
name|targid_mask
decl_stmt|;
name|targid_mask
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|TARGID
argument_list|)
operator||
operator|(
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|TARGID
operator|+
literal|1
argument_list|)
operator|<<
literal|8
operator|)
expr_stmt|;
name|targid_mask
operator|&=
operator|~
name|target_mask
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|TARGID
argument_list|,
name|targid_mask
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|TARGID
operator|+
literal|1
argument_list|,
operator|(
name|targid_mask
operator|>>
literal|8
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|ahc
operator|->
name|black_hole
operator|=
name|NULL
expr_stmt|;
comment|/* 				 * We can't allow selections without 				 * our black hole device. 				 */
name|empty
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
name|ahc
operator|->
name|enabled_luns
operator|==
literal|0
condition|)
block|{
comment|/* Disallow select-in */
name|u_int
name|scsiseq
decl_stmt|;
name|scsiseq
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCSISEQ_TEMPLATE
argument_list|)
expr_stmt|;
name|scsiseq
operator|&=
operator|~
name|ENSELI
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCSISEQ_TEMPLATE
argument_list|,
name|scsiseq
argument_list|)
expr_stmt|;
name|scsiseq
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCSISEQ
argument_list|)
expr_stmt|;
name|scsiseq
operator|&=
operator|~
name|ENSELI
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCSISEQ
argument_list|,
name|scsiseq
argument_list|)
expr_stmt|;
block|}
name|unpause_sequencer
argument_list|(
name|ahc
argument_list|,
comment|/*always?*/
name|FALSE
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|ahc_handle_target_cmd
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|struct
name|target_cmd
modifier|*
name|cmd
parameter_list|)
block|{
name|struct
name|tmode_tstate
modifier|*
name|tstate
decl_stmt|;
name|struct
name|tmode_lstate
modifier|*
name|lstate
decl_stmt|;
name|struct
name|ccb_accept_tio
modifier|*
name|atio
decl_stmt|;
name|u_int8_t
modifier|*
name|byte
decl_stmt|;
name|int
name|initiator
decl_stmt|;
name|int
name|target
decl_stmt|;
name|int
name|lun
decl_stmt|;
name|initiator
operator|=
name|cmd
operator|->
name|initiator_channel
operator|>>
literal|4
expr_stmt|;
name|target
operator|=
name|cmd
operator|->
name|targ_id
expr_stmt|;
name|lun
operator|=
operator|(
name|cmd
operator|->
name|identify
operator|&
name|MSG_IDENTIFY_LUNMASK
operator|)
expr_stmt|;
name|byte
operator|=
name|cmd
operator|->
name|bytes
expr_stmt|;
name|tstate
operator|=
name|ahc
operator|->
name|enabled_targets
index|[
name|target
index|]
expr_stmt|;
name|lstate
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|tstate
operator|!=
name|NULL
operator|&&
name|lun
operator|<
literal|8
condition|)
name|lstate
operator|=
name|tstate
operator|->
name|enabled_luns
index|[
name|lun
index|]
expr_stmt|;
comment|/* 	 * Commands for disabled luns go to the black hole driver. 	 */
if|if
condition|(
name|lstate
operator|==
name|NULL
condition|)
block|{
name|lstate
operator|=
name|ahc
operator|->
name|black_hole
expr_stmt|;
name|atio
operator|=
operator|(
expr|struct
name|ccb_accept_tio
operator|*
operator|)
name|SLIST_FIRST
argument_list|(
operator|&
name|lstate
operator|->
name|accept_tios
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|atio
operator|=
operator|(
expr|struct
name|ccb_accept_tio
operator|*
operator|)
name|SLIST_FIRST
argument_list|(
operator|&
name|lstate
operator|->
name|accept_tios
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|atio
operator|==
name|NULL
condition|)
block|{
name|ahc
operator|->
name|flags
operator||=
name|AHC_TQINFIFO_BLOCKED
expr_stmt|;
name|printf
argument_list|(
literal|"No ATIOs for incoming command\n"
argument_list|)
expr_stmt|;
comment|/* 		 * Wait for more ATIOs from the peripheral driver for this lun. 		 */
return|return
operator|(
literal|1
operator|)
return|;
block|}
else|else
name|ahc
operator|->
name|flags
operator|&=
operator|~
name|AHC_TQINFIFO_BLOCKED
expr_stmt|;
name|SLIST_REMOVE_HEAD
argument_list|(
operator|&
name|lstate
operator|->
name|accept_tios
argument_list|,
name|sim_links
operator|.
name|sle
argument_list|)
expr_stmt|;
if|if
condition|(
name|lstate
operator|==
name|ahc
operator|->
name|black_hole
condition|)
block|{
comment|/* Fill in the wildcards */
name|atio
operator|->
name|ccb_h
operator|.
name|target_id
operator|=
name|target
expr_stmt|;
name|atio
operator|->
name|ccb_h
operator|.
name|target_lun
operator|=
name|lun
expr_stmt|;
block|}
comment|/* 	 * Package it up and send it off to 	 * whomever has this lun enabled. 	 */
name|atio
operator|->
name|init_id
operator|=
name|initiator
expr_stmt|;
if|if
condition|(
name|byte
index|[
literal|0
index|]
operator|!=
literal|0xFF
condition|)
block|{
comment|/* Tag was included */
name|atio
operator|->
name|tag_action
operator|=
operator|*
name|byte
operator|++
expr_stmt|;
name|atio
operator|->
name|tag_id
operator|=
operator|*
name|byte
operator|++
expr_stmt|;
name|atio
operator|->
name|ccb_h
operator|.
name|flags
operator|=
name|CAM_TAG_ACTION_VALID
expr_stmt|;
block|}
else|else
block|{
name|byte
operator|++
expr_stmt|;
name|atio
operator|->
name|ccb_h
operator|.
name|flags
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Okay.  Now determine the cdb size based on the command code */
switch|switch
condition|(
operator|*
name|byte
operator|>>
name|CMD_GROUP_CODE_SHIFT
condition|)
block|{
case|case
literal|0
case|:
name|atio
operator|->
name|cdb_len
operator|=
literal|6
expr_stmt|;
break|break;
case|case
literal|1
case|:
case|case
literal|2
case|:
name|atio
operator|->
name|cdb_len
operator|=
literal|10
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|atio
operator|->
name|cdb_len
operator|=
literal|16
expr_stmt|;
break|break;
case|case
literal|5
case|:
name|atio
operator|->
name|cdb_len
operator|=
literal|12
expr_stmt|;
break|break;
case|case
literal|3
case|:
default|default:
comment|/* Only copy the opcode. */
name|atio
operator|->
name|cdb_len
operator|=
literal|1
expr_stmt|;
name|printf
argument_list|(
literal|"Reserved or VU command code type encountered\n"
argument_list|)
expr_stmt|;
break|break;
block|}
name|bcopy
argument_list|(
name|byte
argument_list|,
name|atio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
argument_list|,
name|atio
operator|->
name|cdb_len
argument_list|)
expr_stmt|;
name|atio
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_CDB_RECVD
expr_stmt|;
if|if
condition|(
operator|(
name|cmd
operator|->
name|identify
operator|&
name|MSG_IDENTIFY_DISCFLAG
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 		 * We weren't allowed to disconnect. 		 * We're hanging on the bus until a 		 * continue target I/O comes in response 		 * to this accept tio. 		 */
if|#
directive|if
literal|0
block|printf("Received Immediate Command %d:%d:%d - %p\n", 		       initiator, target, lun, ahc->pending_device);
endif|#
directive|endif
name|ahc
operator|->
name|pending_device
operator|=
name|lstate
expr_stmt|;
block|}
name|xpt_done
argument_list|(
operator|(
expr|union
name|ccb
operator|*
operator|)
name|atio
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ahc_handle_seqint
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|u_int
name|intstat
parameter_list|)
block|{
name|struct
name|scb
modifier|*
name|scb
decl_stmt|;
name|struct
name|ahc_devinfo
name|devinfo
decl_stmt|;
name|ahc_fetch_devinfo
argument_list|(
name|ahc
argument_list|,
operator|&
name|devinfo
argument_list|)
expr_stmt|;
comment|/* 	 * Clear the upper byte that holds SEQINT status 	 * codes and clear the SEQINT bit. We will unpause 	 * the sequencer, if appropriate, after servicing 	 * the request. 	 */
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|CLRINT
argument_list|,
name|CLRSEQINT
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|intstat
operator|&
name|SEQINT_MASK
condition|)
block|{
case|case
name|NO_MATCH
case|:
block|{
comment|/* Ensure we don't leave the selection hardware on */
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCSISEQ
argument_list|,
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCSISEQ
argument_list|)
operator|&
operator|(
name|ENSELI
operator||
name|ENRSELI
operator||
name|ENAUTOATNP
operator|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s:%c:%d: no active SCB for reconnecting "
literal|"target - issuing BUS DEVICE RESET\n"
argument_list|,
name|ahc_name
argument_list|(
name|ahc
argument_list|)
argument_list|,
name|devinfo
operator|.
name|channel
argument_list|,
name|devinfo
operator|.
name|target
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"SAVED_TCL == 0x%x, ARG_1 == 0x%x, SEQ_FLAGS == 0x%x\n"
argument_list|,
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SAVED_TCL
argument_list|)
argument_list|,
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|ARG_1
argument_list|)
argument_list|,
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SEQ_FLAGS
argument_list|)
argument_list|)
expr_stmt|;
name|ahc
operator|->
name|msgout_buf
index|[
literal|0
index|]
operator|=
name|MSG_BUS_DEV_RESET
expr_stmt|;
name|ahc
operator|->
name|msgout_len
operator|=
literal|1
expr_stmt|;
name|ahc
operator|->
name|msgout_index
operator|=
literal|0
expr_stmt|;
name|ahc
operator|->
name|msg_type
operator|=
name|MSG_TYPE_INITIATOR_MSGOUT
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|MSG_OUT
argument_list|,
name|HOST_MSG
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCSISIGO
argument_list|,
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|LASTPHASE
argument_list|)
operator||
name|ATNO
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|UPDATE_TMSG_REQ
case|:
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|TARGET_MSG_REQUEST
argument_list|,
name|ahc
operator|->
name|targ_msg_req
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|TARGET_MSG_REQUEST
operator|+
literal|1
argument_list|,
operator|(
name|ahc
operator|->
name|targ_msg_req
operator|>>
literal|8
operator|)
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|HS_MAILBOX
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|SEND_REJECT
case|:
block|{
name|u_int
name|rejbyte
init|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|ACCUM
argument_list|)
decl_stmt|;
name|printf
argument_list|(
literal|"%s:%c:%d: Warning - unknown message received from "
literal|"target (0x%x).  Rejecting\n"
argument_list|,
name|ahc_name
argument_list|(
name|ahc
argument_list|)
argument_list|,
name|devinfo
operator|.
name|channel
argument_list|,
name|devinfo
operator|.
name|target
argument_list|,
name|rejbyte
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|NO_IDENT
case|:
block|{
comment|/* 		 * The reconnecting target either did not send an identify 		 * message, or did, but we didn't find and SCB to match and 		 * before it could respond to our ATN/abort, it hit a dataphase. 		 * The only safe thing to do is to blow it away with a bus 		 * reset. 		 */
name|int
name|found
decl_stmt|;
name|printf
argument_list|(
literal|"%s:%c:%d: Target did not send an IDENTIFY message. "
literal|"LASTPHASE = 0x%x, SAVED_TCL == 0x%x\n"
argument_list|,
name|ahc_name
argument_list|(
name|ahc
argument_list|)
argument_list|,
name|devinfo
operator|.
name|channel
argument_list|,
name|devinfo
operator|.
name|target
argument_list|,
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|LASTPHASE
argument_list|)
argument_list|,
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SAVED_TCL
argument_list|)
argument_list|)
expr_stmt|;
name|found
operator|=
name|ahc_reset_channel
argument_list|(
name|ahc
argument_list|,
name|devinfo
operator|.
name|channel
argument_list|,
comment|/*initiate reset*/
name|TRUE
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s: Issued Channel %c Bus Reset. "
literal|"%d SCBs aborted\n"
argument_list|,
name|ahc_name
argument_list|(
name|ahc
argument_list|)
argument_list|,
name|devinfo
operator|.
name|channel
argument_list|,
name|found
argument_list|)
expr_stmt|;
return|return;
block|}
case|case
name|BAD_PHASE
case|:
if|if
condition|(
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|LASTPHASE
argument_list|)
operator|==
name|P_BUSFREE
condition|)
block|{
name|printf
argument_list|(
literal|"%s:%c:%d: Missed busfree.\n"
argument_list|,
name|ahc_name
argument_list|(
name|ahc
argument_list|)
argument_list|,
name|devinfo
operator|.
name|channel
argument_list|,
name|devinfo
operator|.
name|target
argument_list|)
expr_stmt|;
name|restart_sequencer
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"%s:%c:%d: unknown scsi bus phase.  Attempting "
literal|"to continue\n"
argument_list|,
name|ahc_name
argument_list|(
name|ahc
argument_list|)
argument_list|,
name|devinfo
operator|.
name|channel
argument_list|,
name|devinfo
operator|.
name|target
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|BAD_STATUS
case|:
block|{
name|u_int
name|scb_index
decl_stmt|;
name|struct
name|hardware_scb
modifier|*
name|hscb
decl_stmt|;
name|struct
name|ccb_scsiio
modifier|*
name|csio
decl_stmt|;
comment|/* 		 * The sequencer will notify us when a command 		 * has an error that would be of interest to 		 * the kernel.  This allows us to leave the sequencer 		 * running in the common case of command completes 		 * without error.  The sequencer will already have 		 * dma'd the SCB back up to us, so we can reference 		 * the in kernel copy directly. 		 */
name|scb_index
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCB_TAG
argument_list|)
expr_stmt|;
name|scb
operator|=
operator|&
name|ahc
operator|->
name|scb_data
operator|->
name|scbarray
index|[
name|scb_index
index|]
expr_stmt|;
comment|/* 		 * Set the default return value to 0 (don't 		 * send sense).  The sense code will change 		 * this if needed. 		 */
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|RETURN_1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|scb_index
operator|<
name|ahc
operator|->
name|scb_data
operator|->
name|numscbs
operator|&&
operator|(
name|scb
operator|->
name|flags
operator|&
name|SCB_ACTIVE
operator|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"%s:%c:%d: ahc_intr - referenced scb "
literal|"not valid during seqint 0x%x scb(%d)\n"
argument_list|,
name|ahc_name
argument_list|(
name|ahc
argument_list|)
argument_list|,
name|devinfo
operator|.
name|channel
argument_list|,
name|devinfo
operator|.
name|target
argument_list|,
name|intstat
argument_list|,
name|scb_index
argument_list|)
expr_stmt|;
goto|goto
name|unpause
goto|;
block|}
name|hscb
operator|=
name|scb
operator|->
name|hscb
expr_stmt|;
comment|/* Don't want to clobber the original sense code */
if|if
condition|(
operator|(
name|scb
operator|->
name|flags
operator|&
name|SCB_SENSE
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* 			 * Clear the SCB_SENSE Flag and have 			 * the sequencer do a normal command 			 * complete. 			 */
name|scb
operator|->
name|flags
operator|&=
operator|~
name|SCB_SENSE
expr_stmt|;
name|ahcsetccbstatus
argument_list|(
name|scb
operator|->
name|ccb
argument_list|,
name|CAM_AUTOSENSE_FAIL
argument_list|)
expr_stmt|;
break|break;
block|}
name|ahcsetccbstatus
argument_list|(
name|scb
operator|->
name|ccb
argument_list|,
name|CAM_SCSI_STATUS_ERROR
argument_list|)
expr_stmt|;
comment|/* Freeze the queue unit the client sees the error. */
name|ahc_freeze_devq
argument_list|(
name|ahc
argument_list|,
name|scb
operator|->
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|)
expr_stmt|;
name|ahc_freeze_ccb
argument_list|(
name|scb
operator|->
name|ccb
argument_list|)
expr_stmt|;
name|csio
operator|=
operator|&
name|scb
operator|->
name|ccb
operator|->
name|csio
expr_stmt|;
name|csio
operator|->
name|scsi_status
operator|=
name|hscb
operator|->
name|status
expr_stmt|;
switch|switch
condition|(
name|hscb
operator|->
name|status
condition|)
block|{
case|case
name|SCSI_STATUS_OK
case|:
name|printf
argument_list|(
literal|"%s: Interrupted for staus of 0???\n"
argument_list|,
name|ahc_name
argument_list|(
name|ahc
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCSI_STATUS_CMD_TERMINATED
case|:
case|case
name|SCSI_STATUS_CHECK_COND
case|:
ifdef|#
directive|ifdef
name|AHC_DEBUG
if|if
condition|(
name|ahc_debug
operator|&
name|AHC_SHOWSENSE
condition|)
block|{
name|xpt_print_path
argument_list|(
name|csio
operator|->
name|ccb_h
operator|.
name|path
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"SCB %d: requests Check Status\n"
argument_list|,
name|scb
operator|->
name|hscb
operator|->
name|tag
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
operator|(
name|csio
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DIS_AUTOSENSE
operator|)
operator|==
literal|0
condition|)
block|{
name|struct
name|ahc_dma_seg
modifier|*
name|sg
decl_stmt|;
name|struct
name|scsi_sense
modifier|*
name|sc
decl_stmt|;
name|struct
name|ahc_initiator_tinfo
modifier|*
name|tinfo
decl_stmt|;
name|struct
name|tmode_tstate
modifier|*
name|tstate
decl_stmt|;
name|sg
operator|=
name|scb
operator|->
name|sg_list
expr_stmt|;
name|sc
operator|=
operator|(
expr|struct
name|scsi_sense
operator|*
operator|)
operator|(
operator|&
name|hscb
operator|->
name|cmdstore
operator|)
expr_stmt|;
comment|/* 				 * Save off the residual if there is one. 				 */
if|if
condition|(
name|hscb
operator|->
name|residual_SG_count
operator|!=
literal|0
condition|)
name|ahc_calc_residual
argument_list|(
name|scb
argument_list|)
expr_stmt|;
else|else
name|scb
operator|->
name|ccb
operator|->
name|csio
operator|.
name|resid
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|AHC_DEBUG
if|if
condition|(
name|ahc_debug
operator|&
name|AHC_SHOWSENSE
condition|)
block|{
name|xpt_print_path
argument_list|(
name|csio
operator|->
name|ccb_h
operator|.
name|path
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Sending Sense\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|sg
operator|->
name|addr
operator|=
name|ahc
operator|->
name|scb_data
operator|->
name|sense_busaddr
operator|+
operator|(
name|hscb
operator|->
name|tag
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_sense_data
argument_list|)
operator|)
expr_stmt|;
name|sg
operator|->
name|len
operator|=
name|MIN
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_sense_data
argument_list|)
argument_list|,
name|csio
operator|->
name|sense_len
argument_list|)
expr_stmt|;
name|sc
operator|->
name|opcode
operator|=
name|REQUEST_SENSE
expr_stmt|;
name|sc
operator|->
name|byte2
operator|=
name|SCB_LUN
argument_list|(
name|scb
argument_list|)
operator|<<
literal|5
expr_stmt|;
name|sc
operator|->
name|unused
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|unused
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|length
operator|=
name|sg
operator|->
name|len
expr_stmt|;
name|sc
operator|->
name|control
operator|=
literal|0
expr_stmt|;
comment|/* 				 * Would be nice to preserve DISCENB here, 				 * but due to the way we page SCBs, we can't. 				 */
name|hscb
operator|->
name|control
operator|=
literal|0
expr_stmt|;
comment|/* 				 * This request sense could be because the 				 * the device lost power or in some other 				 * way has lost our transfer negotiations. 				 * Renegotiate if appropriate. 				 */
name|tinfo
operator|=
name|ahc_fetch_transinfo
argument_list|(
name|ahc
argument_list|,
name|devinfo
operator|.
name|channel
argument_list|,
name|devinfo
operator|.
name|our_scsiid
argument_list|,
name|devinfo
operator|.
name|target
argument_list|,
operator|&
name|tstate
argument_list|)
expr_stmt|;
name|ahc_update_target_msg_request
argument_list|(
name|ahc
argument_list|,
operator|&
name|devinfo
argument_list|,
name|tinfo
argument_list|,
comment|/*force*/
name|TRUE
argument_list|,
comment|/*paused*/
name|TRUE
argument_list|)
expr_stmt|;
name|hscb
operator|->
name|status
operator|=
literal|0
expr_stmt|;
name|hscb
operator|->
name|SG_count
operator|=
literal|1
expr_stmt|;
name|hscb
operator|->
name|SG_pointer
operator|=
name|scb
operator|->
name|sg_list_phys
expr_stmt|;
name|hscb
operator|->
name|data
operator|=
name|sg
operator|->
name|addr
expr_stmt|;
name|hscb
operator|->
name|datalen
operator|=
name|sg
operator|->
name|len
expr_stmt|;
name|hscb
operator|->
name|cmdpointer
operator|=
name|hscb
operator|->
name|cmdstore_busaddr
expr_stmt|;
name|hscb
operator|->
name|cmdlen
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|sc
argument_list|)
expr_stmt|;
name|scb
operator|->
name|sg_count
operator|=
name|hscb
operator|->
name|SG_count
expr_stmt|;
name|scb
operator|->
name|flags
operator||=
name|SCB_SENSE
expr_stmt|;
comment|/* 				 * Ensure the target is busy since this 				 * will be an untagged request. 				 */
name|ahc_busy_tcl
argument_list|(
name|ahc
argument_list|,
name|scb
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|RETURN_1
argument_list|,
name|SEND_SENSE
argument_list|)
expr_stmt|;
comment|/* 				 * Ensure we have enough time to actually 				 * retrieve the sense. 				 */
name|untimeout
argument_list|(
name|ahc_timeout
argument_list|,
operator|(
name|caddr_t
operator|)
name|scb
argument_list|,
name|scb
operator|->
name|ccb
operator|->
name|ccb_h
operator|.
name|timeout_ch
argument_list|)
expr_stmt|;
name|scb
operator|->
name|ccb
operator|->
name|ccb_h
operator|.
name|timeout_ch
operator|=
name|timeout
argument_list|(
name|ahc_timeout
argument_list|,
operator|(
name|caddr_t
operator|)
name|scb
argument_list|,
literal|5
operator|*
name|hz
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SCSI_STATUS_BUSY
case|:
case|case
name|SCSI_STATUS_QUEUE_FULL
case|:
comment|/* 			 * Requeue any transactions that haven't been 			 * sent yet. 			 */
name|ahc_freeze_devq
argument_list|(
name|ahc
argument_list|,
name|scb
operator|->
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|)
expr_stmt|;
name|ahc_freeze_ccb
argument_list|(
name|scb
operator|->
name|ccb
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
block|}
case|case
name|TRACE_POINT
case|:
block|{
name|printf
argument_list|(
literal|"SSTAT2 = 0x%x DFCNTRL = 0x%x\n"
argument_list|,
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SSTAT2
argument_list|)
argument_list|,
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|DFCNTRL
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"SSTAT3 = 0x%x DSTATUS = 0x%x\n"
argument_list|,
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SSTAT3
argument_list|)
argument_list|,
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|DFSTATUS
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"SSTAT0 = 0x%x, SCB_DATACNT = 0x%x\n"
argument_list|,
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SSTAT0
argument_list|)
argument_list|,
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCB_DATACNT
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|HOST_MSG_LOOP
case|:
block|{
comment|/* 		 * The sequencer has encountered a message phase 		 * that requires host assistance for completion. 		 * While handling the message phase(s), we will be 		 * notified by the sequencer after each byte is 		 * transfered so we can track bus phases. 		 * 		 * If this is the first time we've seen a HOST_MSG_LOOP, 		 * initialize the state of the host message loop. 		 */
if|if
condition|(
name|ahc
operator|->
name|msg_type
operator|==
name|MSG_TYPE_NONE
condition|)
block|{
name|u_int
name|bus_phase
decl_stmt|;
name|bus_phase
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCSISIGI
argument_list|)
operator|&
name|PHASE_MASK
expr_stmt|;
if|if
condition|(
name|bus_phase
operator|!=
name|P_MESGIN
operator|&&
name|bus_phase
operator|!=
name|P_MESGOUT
condition|)
block|{
name|printf
argument_list|(
literal|"ahc_intr: HOST_MSG_LOOP bad "
literal|"phase 0x%x\n"
argument_list|,
name|bus_phase
argument_list|)
expr_stmt|;
comment|/* 				 * Probably transitioned to bus free before 				 * we got here.  Just punt the message. 				 */
name|ahc_clear_intstat
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
name|restart_sequencer
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|devinfo
operator|.
name|role
operator|==
name|ROLE_INITIATOR
condition|)
block|{
name|struct
name|scb
modifier|*
name|scb
decl_stmt|;
name|u_int
name|scb_index
decl_stmt|;
name|scb_index
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCB_TAG
argument_list|)
expr_stmt|;
name|scb
operator|=
operator|&
name|ahc
operator|->
name|scb_data
operator|->
name|scbarray
index|[
name|scb_index
index|]
expr_stmt|;
if|if
condition|(
name|bus_phase
operator|==
name|P_MESGOUT
condition|)
name|ahc_setup_initiator_msgout
argument_list|(
name|ahc
argument_list|,
operator|&
name|devinfo
argument_list|,
name|scb
argument_list|)
expr_stmt|;
else|else
block|{
name|ahc
operator|->
name|msg_type
operator|=
name|MSG_TYPE_INITIATOR_MSGIN
expr_stmt|;
name|ahc
operator|->
name|msgin_index
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|bus_phase
operator|==
name|P_MESGOUT
condition|)
block|{
name|ahc
operator|->
name|msg_type
operator|=
name|MSG_TYPE_TARGET_MSGOUT
expr_stmt|;
name|ahc
operator|->
name|msgin_index
operator|=
literal|0
expr_stmt|;
block|}
else|else
comment|/* XXX Ever executed??? */
name|ahc_setup_target_msgin
argument_list|(
name|ahc
argument_list|,
operator|&
name|devinfo
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Pass a NULL path so that handlers generate their own */
name|ahc_handle_message_phase
argument_list|(
name|ahc
argument_list|,
comment|/*path*/
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|DATA_OVERRUN
case|:
block|{
comment|/* 		 * When the sequencer detects an overrun, it 		 * places the controller in "BITBUCKET" mode 		 * and allows the target to complete its transfer. 		 * Unfortunately, none of the counters get updated 		 * when the controller is in this mode, so we have 		 * no way of knowing how large the overrun was. 		 */
name|u_int
name|scbindex
init|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCB_TAG
argument_list|)
decl_stmt|;
name|u_int
name|lastphase
init|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|LASTPHASE
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
name|scb
operator|=
operator|&
name|ahc
operator|->
name|scb_data
operator|->
name|scbarray
index|[
name|scbindex
index|]
expr_stmt|;
name|xpt_print_path
argument_list|(
name|scb
operator|->
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"data overrun detected in %s phase."
literal|"  Tag == 0x%x.\n"
argument_list|,
name|lastphase
operator|==
name|P_DATAIN
condition|?
literal|"Data-In"
else|:
literal|"Data-Out"
argument_list|,
name|scb
operator|->
name|hscb
operator|->
name|tag
argument_list|)
expr_stmt|;
name|xpt_print_path
argument_list|(
name|scb
operator|->
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s seen Data Phase.  Length = %d.  NumSGs = %d.\n"
argument_list|,
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SEQ_FLAGS
argument_list|)
operator|&
name|DPHASE
condition|?
literal|"Have"
else|:
literal|"Haven't"
argument_list|,
name|scb
operator|->
name|ccb
operator|->
name|csio
operator|.
name|dxfer_len
argument_list|,
name|scb
operator|->
name|sg_count
argument_list|)
expr_stmt|;
if|if
condition|(
name|scb
operator|->
name|sg_count
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|scb
operator|->
name|sg_count
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
name|printf
argument_list|(
literal|"sg[%d] - Addr 0x%x : Length %d\n"
argument_list|,
name|i
argument_list|,
name|scb
operator|->
name|sg_list
index|[
name|i
index|]
operator|.
name|addr
argument_list|,
name|scb
operator|->
name|sg_list
index|[
name|i
index|]
operator|.
name|len
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 		 * Set this and it will take affect when the 		 * target does a command complete. 		 */
name|ahc_freeze_devq
argument_list|(
name|ahc
argument_list|,
name|scb
operator|->
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|)
expr_stmt|;
name|ahcsetccbstatus
argument_list|(
name|scb
operator|->
name|ccb
argument_list|,
name|CAM_DATA_RUN_ERR
argument_list|)
expr_stmt|;
name|ahc_freeze_ccb
argument_list|(
name|scb
operator|->
name|ccb
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|TRACEPOINT
case|:
block|{
name|printf
argument_list|(
literal|"TRACEPOINT: RETURN_2 = %d\n"
argument_list|,
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|RETURN_2
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|printf("SSTAT1 == 0x%x\n", ahc_inb(ahc, SSTAT1)); 		printf("SSTAT0 == 0x%x\n", ahc_inb(ahc, SSTAT0)); 		printf(", SCSISIGI == 0x%x\n", ahc_inb(ahc, SCSISIGI)); 		printf("TRACEPOINT: CCHCNT = %d, SG_COUNT = %d\n", 		       ahc_inb(ahc, CCHCNT), ahc_inb(ahc, SG_COUNT)); 		printf("TRACEPOINT: SCB_TAG = %d\n", ahc_inb(ahc, SCB_TAG)); 		printf("TRACEPOINT1: CCHADDR = %d, CCHCNT = %d, SCBPTR = %d\n", 		       ahc_inb(ahc, CCHADDR) 		    | (ahc_inb(ahc, CCHADDR+1)<< 8) 		    | (ahc_inb(ahc, CCHADDR+2)<< 16) 		    | (ahc_inb(ahc, CCHADDR+3)<< 24), 		       ahc_inb(ahc, CCHCNT) 		    | (ahc_inb(ahc, CCHCNT+1)<< 8) 		    | (ahc_inb(ahc, CCHCNT+2)<< 16), 		       ahc_inb(ahc, SCBPTR)); 		printf("TRACEPOINT: WAITING_SCBH = %d\n", ahc_inb(ahc, WAITING_SCBH)); 		printf("TRACEPOINT: SCB_TAG = %d\n", ahc_inb(ahc, SCB_TAG));
endif|#
directive|endif
break|break;
block|}
if|#
directive|if
name|NOT_YET
comment|/* XXX Fill these in later */
case|case
name|MESG_BUFFER_BUSY
case|:
break|break;
case|case
name|MSGIN_PHASEMIS
case|:
break|break;
endif|#
directive|endif
default|default:
name|printf
argument_list|(
literal|"ahc_intr: seqint, "
literal|"intstat == 0x%x, scsisigi = 0x%x\n"
argument_list|,
name|intstat
argument_list|,
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCSISIGI
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|unpause
label|:
comment|/* 	 *  The sequencer is paused immediately on 	 *  a SEQINT, so we should restart it when 	 *  we're done. 	 */
name|unpause_sequencer
argument_list|(
name|ahc
argument_list|,
comment|/*unpause_always*/
name|TRUE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ahc_handle_scsiint
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|u_int
name|intstat
parameter_list|)
block|{
name|u_int
name|scb_index
decl_stmt|;
name|u_int
name|status
decl_stmt|;
name|struct
name|scb
modifier|*
name|scb
decl_stmt|;
name|char
name|cur_channel
decl_stmt|;
name|char
name|intr_channel
decl_stmt|;
if|if
condition|(
operator|(
name|ahc
operator|->
name|features
operator|&
name|AHC_TWIN
operator|)
operator|!=
literal|0
operator|&&
operator|(
operator|(
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SBLKCTL
argument_list|)
operator|&
name|SELBUSB
operator|)
operator|!=
literal|0
operator|)
condition|)
name|cur_channel
operator|=
literal|'B'
expr_stmt|;
else|else
name|cur_channel
operator|=
literal|'A'
expr_stmt|;
name|intr_channel
operator|=
name|cur_channel
expr_stmt|;
name|status
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SSTAT1
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|ahc
operator|->
name|features
operator|&
name|AHC_TWIN
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* Try the other channel */
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SBLKCTL
argument_list|,
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SBLKCTL
argument_list|)
operator|^
name|SELBUSB
argument_list|)
expr_stmt|;
name|status
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SSTAT1
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SBLKCTL
argument_list|,
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SBLKCTL
argument_list|)
operator|^
name|SELBUSB
argument_list|)
expr_stmt|;
name|intr_channel
operator|=
operator|(
name|cur_channel
operator|==
literal|'A'
operator|)
condition|?
literal|'B'
else|:
literal|'A'
expr_stmt|;
block|}
if|if
condition|(
name|status
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%s: Spurious SCSI interrupt\n"
argument_list|,
name|ahc_name
argument_list|(
name|ahc
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|scb_index
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCB_TAG
argument_list|)
expr_stmt|;
if|if
condition|(
name|scb_index
operator|<
name|ahc
operator|->
name|scb_data
operator|->
name|numscbs
condition|)
block|{
name|scb
operator|=
operator|&
name|ahc
operator|->
name|scb_data
operator|->
name|scbarray
index|[
name|scb_index
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|scb
operator|->
name|flags
operator|&
name|SCB_ACTIVE
operator|)
operator|==
literal|0
condition|)
name|scb
operator|=
name|NULL
expr_stmt|;
block|}
else|else
name|scb
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|status
operator|&
name|SCSIRSTI
operator|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%s: Someone reset channel %c\n"
argument_list|,
name|ahc_name
argument_list|(
name|ahc
argument_list|)
argument_list|,
name|intr_channel
argument_list|)
expr_stmt|;
name|ahc_reset_channel
argument_list|(
name|ahc
argument_list|,
name|intr_channel
argument_list|,
comment|/* Initiate Reset */
name|FALSE
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|status
operator|&
name|BUSFREE
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|status
operator|&
name|SELTO
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 		 * First look at what phase we were last in. 		 * If its message out, chances are pretty good 		 * that the busfree was in response to one of 		 * our abort requests. 		 */
name|u_int
name|lastphase
init|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|LASTPHASE
argument_list|)
decl_stmt|;
name|u_int
name|saved_tcl
init|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SAVED_TCL
argument_list|)
decl_stmt|;
name|u_int
name|target
init|=
name|TCL_TARGET
argument_list|(
name|saved_tcl
argument_list|)
decl_stmt|;
name|u_int
name|initiator_role_id
init|=
name|TCL_SCSI_ID
argument_list|(
name|ahc
argument_list|,
name|saved_tcl
argument_list|)
decl_stmt|;
name|char
name|channel
init|=
name|TCL_CHANNEL
argument_list|(
name|ahc
argument_list|,
name|saved_tcl
argument_list|)
decl_stmt|;
name|int
name|printerror
init|=
literal|1
decl_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCSISEQ
argument_list|,
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCSISEQ
argument_list|)
operator|&
operator|(
name|ENSELI
operator||
name|ENRSELI
operator||
name|ENAUTOATNP
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|lastphase
operator|==
name|P_MESGOUT
condition|)
block|{
name|u_int
name|message
decl_stmt|;
name|u_int
name|tag
decl_stmt|;
name|message
operator|=
name|ahc
operator|->
name|msgout_buf
index|[
name|ahc
operator|->
name|msgout_index
operator|-
literal|1
index|]
expr_stmt|;
name|tag
operator|=
name|SCB_LIST_NULL
expr_stmt|;
switch|switch
condition|(
name|message
condition|)
block|{
case|case
name|MSG_ABORT_TAG
case|:
name|tag
operator|=
name|scb
operator|->
name|hscb
operator|->
name|tag
expr_stmt|;
comment|/* FALLTRHOUGH */
case|case
name|MSG_ABORT
case|:
name|xpt_print_path
argument_list|(
name|scb
operator|->
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"SCB %d - Abort %s Completed.\n"
argument_list|,
name|scb
operator|->
name|hscb
operator|->
name|tag
argument_list|,
name|tag
operator|==
name|SCB_LIST_NULL
condition|?
literal|""
else|:
literal|"Tag"
argument_list|)
expr_stmt|;
name|ahc_abort_scbs
argument_list|(
name|ahc
argument_list|,
name|target
argument_list|,
name|channel
argument_list|,
name|TCL_LUN
argument_list|(
name|saved_tcl
argument_list|)
argument_list|,
name|tag
argument_list|,
name|ROLE_INITIATOR
argument_list|,
name|CAM_REQ_ABORTED
argument_list|)
expr_stmt|;
name|printerror
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|MSG_BUS_DEV_RESET
case|:
block|{
name|struct
name|ahc_devinfo
name|devinfo
decl_stmt|;
comment|/* 				 * Don't mark the user's request for this BDR 				 * as completing with CAM_BDR_SENT.  CAM3 				 * specifies CAM_REQ_CMP. 				 */
if|if
condition|(
name|scb
operator|!=
name|NULL
operator|&&
name|scb
operator|->
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|==
name|XPT_RESET_DEV
operator|&&
name|ahc_match_scb
argument_list|(
name|scb
argument_list|,
name|target
argument_list|,
name|channel
argument_list|,
name|TCL_LUN
argument_list|(
name|saved_tcl
argument_list|)
argument_list|,
name|ROLE_INITIATOR
argument_list|,
name|SCB_LIST_NULL
argument_list|)
condition|)
block|{
name|ahcsetccbstatus
argument_list|(
name|scb
operator|->
name|ccb
argument_list|,
name|CAM_REQ_CMP
argument_list|)
expr_stmt|;
block|}
name|ahc_compile_devinfo
argument_list|(
operator|&
name|devinfo
argument_list|,
name|initiator_role_id
argument_list|,
name|target
argument_list|,
name|TCL_LUN
argument_list|(
name|saved_tcl
argument_list|)
argument_list|,
name|channel
argument_list|,
name|ROLE_INITIATOR
argument_list|)
expr_stmt|;
name|ahc_handle_devreset
argument_list|(
name|ahc
argument_list|,
operator|&
name|devinfo
argument_list|,
name|CAM_BDR_SENT
argument_list|,
name|AC_SENT_BDR
argument_list|,
literal|"Bus Device Reset"
argument_list|,
comment|/*verbose_level*/
literal|0
argument_list|)
expr_stmt|;
name|printerror
operator|=
literal|0
expr_stmt|;
break|break;
block|}
default|default:
break|break;
block|}
block|}
if|if
condition|(
name|printerror
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|scb
operator|!=
name|NULL
condition|)
block|{
name|u_int
name|tag
decl_stmt|;
if|if
condition|(
operator|(
name|scb
operator|->
name|hscb
operator|->
name|control
operator|&
name|TAG_ENB
operator|)
operator|!=
literal|0
condition|)
name|tag
operator|=
name|scb
operator|->
name|hscb
operator|->
name|tag
expr_stmt|;
else|else
name|tag
operator|=
name|SCB_LIST_NULL
expr_stmt|;
name|ahc_abort_scbs
argument_list|(
name|ahc
argument_list|,
name|target
argument_list|,
name|channel
argument_list|,
name|SCB_LUN
argument_list|(
name|scb
argument_list|)
argument_list|,
name|tag
argument_list|,
name|ROLE_INITIATOR
argument_list|,
name|CAM_UNEXP_BUSFREE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ahc_abort_scbs
argument_list|(
name|ahc
argument_list|,
name|target
argument_list|,
name|channel
argument_list|,
name|CAM_LUN_WILDCARD
argument_list|,
name|SCB_LIST_NULL
argument_list|,
name|ROLE_INITIATOR
argument_list|,
name|CAM_UNEXP_BUSFREE
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s: "
argument_list|,
name|ahc_name
argument_list|(
name|ahc
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"Unexpected busfree.  LASTPHASE == 0x%x\n"
literal|"SEQADDR == 0x%x\n"
argument_list|,
name|lastphase
argument_list|,
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SEQADDR0
argument_list|)
operator||
operator|(
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SEQADDR1
argument_list|)
operator|<<
literal|8
operator|)
argument_list|)
expr_stmt|;
block|}
name|ahc_clear_msg_state
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SIMODE1
argument_list|,
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SIMODE1
argument_list|)
operator|&
operator|~
name|ENBUSFREE
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|CLRSINT1
argument_list|,
name|CLRBUSFREE
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|CLRINT
argument_list|,
name|CLRSCSIINT
argument_list|)
expr_stmt|;
name|restart_sequencer
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|status
operator|&
name|SELTO
operator|)
operator|!=
literal|0
condition|)
block|{
name|u_int
name|scbptr
decl_stmt|;
name|scbptr
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|WAITING_SCBH
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCBPTR
argument_list|,
name|scbptr
argument_list|)
expr_stmt|;
name|scb_index
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCB_TAG
argument_list|)
expr_stmt|;
if|if
condition|(
name|scb_index
operator|<
name|ahc
operator|->
name|scb_data
operator|->
name|numscbs
condition|)
block|{
name|scb
operator|=
operator|&
name|ahc
operator|->
name|scb_data
operator|->
name|scbarray
index|[
name|scb_index
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|scb
operator|->
name|flags
operator|&
name|SCB_ACTIVE
operator|)
operator|==
literal|0
condition|)
name|scb
operator|=
name|NULL
expr_stmt|;
block|}
else|else
name|scb
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|scb
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"%s: ahc_intr - referenced scb not "
literal|"valid during SELTO scb(%d, %d)\n"
argument_list|,
name|ahc_name
argument_list|(
name|ahc
argument_list|)
argument_list|,
name|scbptr
argument_list|,
name|scb_index
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|struct
name|ahc_devinfo
name|devinfo
decl_stmt|;
name|ahc_scb_devinfo
argument_list|(
name|ahc
argument_list|,
operator|&
name|devinfo
argument_list|,
name|scb
argument_list|)
expr_stmt|;
name|ahc_handle_devreset
argument_list|(
name|ahc
argument_list|,
operator|&
name|devinfo
argument_list|,
name|CAM_SEL_TIMEOUT
argument_list|,
comment|/*ac_code*/
literal|0
argument_list|,
literal|"Selection Timeout"
argument_list|,
comment|/*verbose_level*/
literal|2
argument_list|)
expr_stmt|;
block|}
comment|/* Stop the selection */
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCSISEQ
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* No more pending messages */
name|ahc_clear_msg_state
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
comment|/* 		 * Although the driver does not care about the 		 * 'Selection in Progress' status bit, the busy 		 * LED does.  SELINGO is only cleared by a sucessful 		 * selection, so we must manually clear it to ensure 		 * the LED turns off just incase no future successful 		 * selections occur (e.g. no devices on the bus). 		 */
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|CLRSINT0
argument_list|,
name|CLRSELINGO
argument_list|)
expr_stmt|;
comment|/* Clear interrupt state */
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|CLRSINT1
argument_list|,
name|CLRSELTIMEO
operator||
name|CLRBUSFREE
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|CLRINT
argument_list|,
name|CLRSCSIINT
argument_list|)
expr_stmt|;
name|restart_sequencer
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|scb
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"%s: ahc_intr - referenced scb not "
literal|"valid during scsiint 0x%x scb(%d)\n"
literal|"SIMODE0 = 0x%x, SIMODE1 = 0x%x, SSTAT0 = 0x%x\n"
literal|"SEQADDR = 0x%x\n"
argument_list|,
name|ahc_name
argument_list|(
name|ahc
argument_list|)
argument_list|,
name|status
argument_list|,
name|scb_index
argument_list|,
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SIMODE0
argument_list|)
argument_list|,
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SIMODE1
argument_list|)
argument_list|,
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SSTAT0
argument_list|)
argument_list|,
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SEQADDR0
argument_list|)
operator||
operator|(
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SEQADDR1
argument_list|)
operator|<<
literal|8
operator|)
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|CLRSINT1
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|CLRINT
argument_list|,
name|CLRSCSIINT
argument_list|)
expr_stmt|;
name|unpause_sequencer
argument_list|(
name|ahc
argument_list|,
comment|/*unpause_always*/
name|TRUE
argument_list|)
expr_stmt|;
name|scb
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|status
operator|&
name|SCSIPERR
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * Determine the bus phase and 		 * queue an appropriate message 		 */
name|char
modifier|*
name|phase
decl_stmt|;
name|u_int
name|mesg_out
init|=
name|MSG_NOOP
decl_stmt|;
name|u_int
name|lastphase
init|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|LASTPHASE
argument_list|)
decl_stmt|;
name|xpt_print_path
argument_list|(
name|scb
operator|->
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|lastphase
condition|)
block|{
case|case
name|P_DATAOUT
case|:
name|phase
operator|=
literal|"Data-Out"
expr_stmt|;
break|break;
case|case
name|P_DATAIN
case|:
name|phase
operator|=
literal|"Data-In"
expr_stmt|;
name|mesg_out
operator|=
name|MSG_INITIATOR_DET_ERR
expr_stmt|;
break|break;
case|case
name|P_COMMAND
case|:
name|phase
operator|=
literal|"Command"
expr_stmt|;
break|break;
case|case
name|P_MESGOUT
case|:
name|phase
operator|=
literal|"Message-Out"
expr_stmt|;
break|break;
case|case
name|P_STATUS
case|:
name|phase
operator|=
literal|"Status"
expr_stmt|;
name|mesg_out
operator|=
name|MSG_INITIATOR_DET_ERR
expr_stmt|;
break|break;
case|case
name|P_MESGIN
case|:
name|phase
operator|=
literal|"Message-In"
expr_stmt|;
name|mesg_out
operator|=
name|MSG_PARITY_ERROR
expr_stmt|;
break|break;
default|default:
name|phase
operator|=
literal|"unknown"
expr_stmt|;
break|break;
block|}
name|printf
argument_list|(
literal|"parity error during %s phase.\n"
argument_list|,
name|phase
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"SEQADDR == 0x%x\n"
argument_list|,
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SEQADDR0
argument_list|)
operator||
operator|(
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SEQADDR1
argument_list|)
operator|<<
literal|8
operator|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"SCSIRATE == 0x%x\n"
argument_list|,
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCSIRATE
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 		 * We've set the hardware to assert ATN if we    		 * get a parity error on "in" phases, so all we   		 * need to do is stuff the message buffer with 		 * the appropriate message.  "In" phases have set 		 * mesg_out to something other than MSG_NOP. 		 */
if|if
condition|(
name|mesg_out
operator|!=
name|MSG_NOOP
condition|)
block|{
if|if
condition|(
name|ahc
operator|->
name|msg_type
operator|!=
name|MSG_TYPE_NONE
condition|)
name|ahc
operator|->
name|send_msg_perror
operator|=
name|TRUE
expr_stmt|;
else|else
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|MSG_OUT
argument_list|,
name|mesg_out
argument_list|)
expr_stmt|;
block|}
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|CLRSINT1
argument_list|,
name|CLRSCSIPERR
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|CLRINT
argument_list|,
name|CLRSCSIINT
argument_list|)
expr_stmt|;
name|unpause_sequencer
argument_list|(
name|ahc
argument_list|,
comment|/*unpause_always*/
name|TRUE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|xpt_print_path
argument_list|(
name|scb
operator|->
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Unknown SCSIINT. Status = 0x%x\n"
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|CLRSINT1
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|CLRINT
argument_list|,
name|CLRSCSIINT
argument_list|)
expr_stmt|;
name|unpause_sequencer
argument_list|(
name|ahc
argument_list|,
comment|/*unpause_always*/
name|TRUE
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ahc_build_transfer_msg
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|struct
name|ahc_devinfo
modifier|*
name|devinfo
parameter_list|)
block|{
comment|/* 	 * We need to initiate transfer negotiations. 	 * If our current and goal settings are identical, 	 * we want to renegotiate due to a check condition. 	 */
name|struct
name|ahc_initiator_tinfo
modifier|*
name|tinfo
decl_stmt|;
name|struct
name|tmode_tstate
modifier|*
name|tstate
decl_stmt|;
name|int
name|dowide
decl_stmt|;
name|int
name|dosync
decl_stmt|;
name|tinfo
operator|=
name|ahc_fetch_transinfo
argument_list|(
name|ahc
argument_list|,
name|devinfo
operator|->
name|channel
argument_list|,
name|devinfo
operator|->
name|our_scsiid
argument_list|,
name|devinfo
operator|->
name|target
argument_list|,
operator|&
name|tstate
argument_list|)
expr_stmt|;
name|dowide
operator|=
name|tinfo
operator|->
name|current
operator|.
name|width
operator|!=
name|tinfo
operator|->
name|goal
operator|.
name|width
expr_stmt|;
name|dosync
operator|=
name|tinfo
operator|->
name|current
operator|.
name|period
operator|!=
name|tinfo
operator|->
name|goal
operator|.
name|period
expr_stmt|;
if|if
condition|(
operator|!
name|dowide
operator|&&
operator|!
name|dosync
condition|)
block|{
name|dowide
operator|=
name|tinfo
operator|->
name|goal
operator|.
name|width
operator|!=
name|MSG_EXT_WDTR_BUS_8_BIT
expr_stmt|;
name|dosync
operator|=
name|tinfo
operator|->
name|goal
operator|.
name|period
operator|!=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|dowide
condition|)
block|{
name|ahc_construct_wdtr
argument_list|(
name|ahc
argument_list|,
name|tinfo
operator|->
name|goal
operator|.
name|width
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dosync
condition|)
block|{
name|struct
name|ahc_syncrate
modifier|*
name|rate
decl_stmt|;
name|u_int
name|period
decl_stmt|;
name|u_int
name|offset
decl_stmt|;
name|period
operator|=
name|tinfo
operator|->
name|goal
operator|.
name|period
expr_stmt|;
name|rate
operator|=
name|ahc_devlimited_syncrate
argument_list|(
name|ahc
argument_list|,
operator|&
name|period
argument_list|)
expr_stmt|;
name|offset
operator|=
name|tinfo
operator|->
name|goal
operator|.
name|offset
expr_stmt|;
name|ahc_validate_offset
argument_list|(
name|ahc
argument_list|,
name|rate
argument_list|,
operator|&
name|offset
argument_list|,
name|tinfo
operator|->
name|current
operator|.
name|width
argument_list|)
expr_stmt|;
name|ahc_construct_sdtr
argument_list|(
name|ahc
argument_list|,
name|period
argument_list|,
name|offset
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|panic
argument_list|(
literal|"ahc_intr: AWAITING_MSG for negotiation, "
literal|"but no negotiation needed\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ahc_setup_initiator_msgout
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|struct
name|ahc_devinfo
modifier|*
name|devinfo
parameter_list|,
name|struct
name|scb
modifier|*
name|scb
parameter_list|)
block|{
comment|/*               	 * To facilitate adding multiple messages together, 	 * each routine should increment the index and len 	 * variables instead of setting them explicitly. 	 */
name|ahc
operator|->
name|msgout_index
operator|=
literal|0
expr_stmt|;
name|ahc
operator|->
name|msgout_len
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|scb
operator|->
name|flags
operator|&
name|SCB_DEVICE_RESET
operator|)
operator|==
literal|0
operator|&&
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|MSG_OUT
argument_list|)
operator|==
name|MSG_IDENTIFYFLAG
condition|)
block|{
name|u_int
name|identify_msg
decl_stmt|;
name|identify_msg
operator|=
name|MSG_IDENTIFYFLAG
operator||
name|SCB_LUN
argument_list|(
name|scb
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|scb
operator|->
name|hscb
operator|->
name|control
operator|&
name|DISCENB
operator|)
operator|!=
literal|0
condition|)
name|identify_msg
operator||=
name|MSG_IDENTIFY_DISCFLAG
expr_stmt|;
name|ahc
operator|->
name|msgout_buf
index|[
name|ahc
operator|->
name|msgout_index
operator|++
index|]
operator|=
name|identify_msg
expr_stmt|;
name|ahc
operator|->
name|msgout_len
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|scb
operator|->
name|hscb
operator|->
name|control
operator|&
name|TAG_ENB
operator|)
operator|!=
literal|0
condition|)
block|{
name|ahc
operator|->
name|msgout_buf
index|[
name|ahc
operator|->
name|msgout_index
operator|++
index|]
operator|=
name|scb
operator|->
name|ccb
operator|->
name|csio
operator|.
name|tag_action
expr_stmt|;
name|ahc
operator|->
name|msgout_buf
index|[
name|ahc
operator|->
name|msgout_index
operator|++
index|]
operator|=
name|scb
operator|->
name|hscb
operator|->
name|tag
expr_stmt|;
name|ahc
operator|->
name|msgout_len
operator|+=
literal|2
expr_stmt|;
block|}
block|}
if|if
condition|(
name|scb
operator|->
name|flags
operator|&
name|SCB_DEVICE_RESET
condition|)
block|{
name|ahc
operator|->
name|msgout_buf
index|[
name|ahc
operator|->
name|msgout_index
operator|++
index|]
operator|=
name|MSG_BUS_DEV_RESET
expr_stmt|;
name|ahc
operator|->
name|msgout_len
operator|++
expr_stmt|;
name|xpt_print_path
argument_list|(
name|scb
operator|->
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Bus Device Reset Message Sent\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|scb
operator|->
name|flags
operator|&
name|SCB_ABORT
condition|)
block|{
if|if
condition|(
operator|(
name|scb
operator|->
name|hscb
operator|->
name|control
operator|&
name|TAG_ENB
operator|)
operator|!=
literal|0
condition|)
name|ahc
operator|->
name|msgout_buf
index|[
name|ahc
operator|->
name|msgout_index
operator|++
index|]
operator|=
name|MSG_ABORT_TAG
expr_stmt|;
else|else
name|ahc
operator|->
name|msgout_buf
index|[
name|ahc
operator|->
name|msgout_index
operator|++
index|]
operator|=
name|MSG_ABORT
expr_stmt|;
name|ahc
operator|->
name|msgout_len
operator|++
expr_stmt|;
name|xpt_print_path
argument_list|(
name|scb
operator|->
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Abort Message Sent\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|ahc
operator|->
name|targ_msg_req
operator|&
name|devinfo
operator|->
name|target_mask
operator|)
operator|!=
literal|0
condition|)
block|{
name|ahc_build_transfer_msg
argument_list|(
name|ahc
argument_list|,
name|devinfo
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"ahc_intr: AWAITING_MSG for an SCB that "
literal|"does not have a waiting message"
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"SCB = %d, SCB Control = %x, MSG_OUT = %x "
literal|"SCB flags = %x"
argument_list|,
name|scb
operator|->
name|hscb
operator|->
name|tag
argument_list|,
name|scb
operator|->
name|hscb
operator|->
name|control
argument_list|,
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|MSG_OUT
argument_list|)
argument_list|,
name|scb
operator|->
name|flags
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Clear the MK_MESSAGE flag from the SCB so we aren't 	 * asked to send this message again. 	 */
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCB_CONTROL
argument_list|,
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCB_CONTROL
argument_list|)
operator|&
operator|~
name|MK_MESSAGE
argument_list|)
expr_stmt|;
name|ahc
operator|->
name|msgout_index
operator|=
literal|0
expr_stmt|;
name|ahc
operator|->
name|msg_type
operator|=
name|MSG_TYPE_INITIATOR_MSGOUT
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ahc_setup_target_msgin
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|struct
name|ahc_devinfo
modifier|*
name|devinfo
parameter_list|)
block|{
comment|/*               	 * To facilitate adding multiple messages together, 	 * each routine should increment the index and len 	 * variables instead of setting them explicitly. 	 */
name|ahc
operator|->
name|msgout_index
operator|=
literal|0
expr_stmt|;
name|ahc
operator|->
name|msgout_len
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|ahc
operator|->
name|targ_msg_req
operator|&
name|devinfo
operator|->
name|target_mask
operator|)
operator|!=
literal|0
condition|)
name|ahc_build_transfer_msg
argument_list|(
name|ahc
argument_list|,
name|devinfo
argument_list|)
expr_stmt|;
else|else
name|panic
argument_list|(
literal|"ahc_intr: AWAITING target message with no message"
argument_list|)
expr_stmt|;
name|ahc
operator|->
name|msgout_index
operator|=
literal|0
expr_stmt|;
name|ahc
operator|->
name|msg_type
operator|=
name|MSG_TYPE_TARGET_MSGIN
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|ahc_handle_msg_reject
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|struct
name|ahc_devinfo
modifier|*
name|devinfo
parameter_list|)
block|{
comment|/* 	 * What we care about here is if we had an 	 * outstanding SDTR or WDTR message for this 	 * target.  If we did, this is a signal that 	 * the target is refusing negotiation. 	 */
name|struct
name|scb
modifier|*
name|scb
decl_stmt|;
name|u_int
name|scb_index
decl_stmt|;
name|u_int
name|last_msg
decl_stmt|;
name|int
name|response
init|=
literal|0
decl_stmt|;
name|scb_index
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCB_TAG
argument_list|)
expr_stmt|;
name|scb
operator|=
operator|&
name|ahc
operator|->
name|scb_data
operator|->
name|scbarray
index|[
name|scb_index
index|]
expr_stmt|;
comment|/* Might be necessary */
name|last_msg
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|LAST_MSG
argument_list|)
expr_stmt|;
if|if
condition|(
name|ahc_sent_msg
argument_list|(
name|ahc
argument_list|,
name|MSG_EXT_WDTR
argument_list|,
comment|/*full*/
name|FALSE
argument_list|)
condition|)
block|{
name|struct
name|ahc_initiator_tinfo
modifier|*
name|tinfo
decl_stmt|;
name|struct
name|tmode_tstate
modifier|*
name|tstate
decl_stmt|;
comment|/* note 8bit xfers */
name|printf
argument_list|(
literal|"%s:%c:%d: refuses WIDE negotiation.  Using "
literal|"8bit transfers\n"
argument_list|,
name|ahc_name
argument_list|(
name|ahc
argument_list|)
argument_list|,
name|devinfo
operator|->
name|channel
argument_list|,
name|devinfo
operator|->
name|target
argument_list|)
expr_stmt|;
name|ahc_set_width
argument_list|(
name|ahc
argument_list|,
name|devinfo
argument_list|,
name|scb
operator|->
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
name|MSG_EXT_WDTR_BUS_8_BIT
argument_list|,
name|AHC_TRANS_ACTIVE
operator||
name|AHC_TRANS_GOAL
argument_list|,
comment|/*paused*/
name|TRUE
argument_list|)
expr_stmt|;
comment|/* 		 * No need to clear the sync rate.  If the target 		 * did not accept the command, our syncrate is 		 * unaffected.  If the target started the negotiation, 		 * but rejected our response, we already cleared the 		 * sync rate before sending our WDTR. 		 */
name|tinfo
operator|=
name|ahc_fetch_transinfo
argument_list|(
name|ahc
argument_list|,
name|devinfo
operator|->
name|channel
argument_list|,
name|devinfo
operator|->
name|our_scsiid
argument_list|,
name|devinfo
operator|->
name|target
argument_list|,
operator|&
name|tstate
argument_list|)
expr_stmt|;
if|if
condition|(
name|tinfo
operator|->
name|goal
operator|.
name|period
condition|)
block|{
name|u_int
name|period
decl_stmt|;
comment|/* Start the sync negotiation */
name|period
operator|=
name|tinfo
operator|->
name|goal
operator|.
name|period
expr_stmt|;
name|ahc_devlimited_syncrate
argument_list|(
name|ahc
argument_list|,
operator|&
name|period
argument_list|)
expr_stmt|;
name|ahc
operator|->
name|msgout_index
operator|=
literal|0
expr_stmt|;
name|ahc
operator|->
name|msgout_len
operator|=
literal|0
expr_stmt|;
name|ahc_construct_sdtr
argument_list|(
name|ahc
argument_list|,
name|period
argument_list|,
name|tinfo
operator|->
name|goal
operator|.
name|offset
argument_list|)
expr_stmt|;
name|ahc
operator|->
name|msgout_index
operator|=
literal|0
expr_stmt|;
name|response
operator|=
literal|1
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|ahc_sent_msg
argument_list|(
name|ahc
argument_list|,
name|MSG_EXT_SDTR
argument_list|,
comment|/*full*/
name|FALSE
argument_list|)
condition|)
block|{
comment|/* note asynch xfers and clear flag */
name|ahc_set_syncrate
argument_list|(
name|ahc
argument_list|,
name|devinfo
argument_list|,
name|scb
operator|->
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
comment|/*syncrate*/
name|NULL
argument_list|,
comment|/*period*/
literal|0
argument_list|,
comment|/*offset*/
literal|0
argument_list|,
name|AHC_TRANS_ACTIVE
operator||
name|AHC_TRANS_GOAL
argument_list|,
comment|/*paused*/
name|TRUE
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s:%c:%d: refuses synchronous negotiation. "
literal|"Using asynchronous transfers\n"
argument_list|,
name|ahc_name
argument_list|(
name|ahc
argument_list|)
argument_list|,
name|devinfo
operator|->
name|channel
argument_list|,
name|devinfo
operator|->
name|target
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|scb
operator|->
name|hscb
operator|->
name|control
operator|&
name|MSG_SIMPLE_Q_TAG
operator|)
operator|!=
literal|0
condition|)
block|{
name|struct
name|ccb_trans_settings
name|neg
decl_stmt|;
name|printf
argument_list|(
literal|"%s:%c:%d: refuses tagged commands.  Performing "
literal|"non-tagged I/O\n"
argument_list|,
name|ahc_name
argument_list|(
name|ahc
argument_list|)
argument_list|,
name|devinfo
operator|->
name|channel
argument_list|,
name|devinfo
operator|->
name|target
argument_list|)
expr_stmt|;
name|ahc_set_tags
argument_list|(
name|ahc
argument_list|,
name|devinfo
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|neg
operator|.
name|flags
operator|=
literal|0
expr_stmt|;
name|neg
operator|.
name|valid
operator|=
name|CCB_TRANS_TQ_VALID
expr_stmt|;
name|xpt_setup_ccb
argument_list|(
operator|&
name|neg
operator|.
name|ccb_h
argument_list|,
name|scb
operator|->
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
comment|/*priority*/
literal|1
argument_list|)
expr_stmt|;
name|xpt_async
argument_list|(
name|AC_TRANSFER_NEG
argument_list|,
name|scb
operator|->
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
operator|&
name|neg
argument_list|)
expr_stmt|;
comment|/* 		 * Resend the identify for this CCB as the target 		 * may believe that the selection is invalid otherwise. 		 */
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCB_CONTROL
argument_list|,
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCB_CONTROL
argument_list|)
operator|&
operator|~
name|MSG_SIMPLE_Q_TAG
argument_list|)
expr_stmt|;
name|scb
operator|->
name|hscb
operator|->
name|control
operator|&=
operator|~
name|MSG_SIMPLE_Q_TAG
expr_stmt|;
name|scb
operator|->
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&=
operator|~
name|CAM_TAG_ACTION_VALID
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|MSG_OUT
argument_list|,
name|MSG_IDENTIFYFLAG
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCSISIGO
argument_list|,
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCSISIGO
argument_list|)
operator||
name|ATNO
argument_list|)
expr_stmt|;
comment|/* 		 * Requeue all tagged commands for this target 		 * currently in our posession so they can be 		 * converted to untagged commands. 		 */
name|ahc_search_qinfifo
argument_list|(
name|ahc
argument_list|,
name|SCB_TARGET
argument_list|(
name|scb
argument_list|)
argument_list|,
name|SCB_CHANNEL
argument_list|(
name|scb
argument_list|)
argument_list|,
name|SCB_LUN
argument_list|(
name|scb
argument_list|)
argument_list|,
comment|/*tag*/
name|SCB_LIST_NULL
argument_list|,
name|ROLE_INITIATOR
argument_list|,
name|CAM_REQUEUE_REQ
argument_list|,
name|SEARCH_COMPLETE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Otherwise, we ignore it. 		 */
name|printf
argument_list|(
literal|"%s:%c:%d: Message reject for %x -- ignored\n"
argument_list|,
name|ahc_name
argument_list|(
name|ahc
argument_list|)
argument_list|,
name|devinfo
operator|->
name|channel
argument_list|,
name|devinfo
operator|->
name|target
argument_list|,
name|last_msg
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|response
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ahc_clear_msg_state
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|)
block|{
name|ahc
operator|->
name|msgout_len
operator|=
literal|0
expr_stmt|;
name|ahc
operator|->
name|msgin_index
operator|=
literal|0
expr_stmt|;
name|ahc
operator|->
name|msg_type
operator|=
name|MSG_TYPE_NONE
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|MSG_OUT
argument_list|,
name|MSG_NOOP
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ahc_handle_message_phase
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|struct
name|cam_path
modifier|*
name|path
parameter_list|)
block|{
name|struct
name|ahc_devinfo
name|devinfo
decl_stmt|;
name|u_int
name|bus_phase
decl_stmt|;
name|int
name|end_session
decl_stmt|;
name|ahc_fetch_devinfo
argument_list|(
name|ahc
argument_list|,
operator|&
name|devinfo
argument_list|)
expr_stmt|;
name|end_session
operator|=
name|FALSE
expr_stmt|;
name|bus_phase
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCSISIGI
argument_list|)
operator|&
name|PHASE_MASK
expr_stmt|;
name|reswitch
label|:
switch|switch
condition|(
name|ahc
operator|->
name|msg_type
condition|)
block|{
case|case
name|MSG_TYPE_INITIATOR_MSGOUT
case|:
block|{
name|int
name|lastbyte
decl_stmt|;
name|int
name|phasemis
decl_stmt|;
name|int
name|msgdone
decl_stmt|;
if|if
condition|(
name|ahc
operator|->
name|msgout_len
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"REQINIT interrupt with no active message"
argument_list|)
expr_stmt|;
name|phasemis
operator|=
name|bus_phase
operator|!=
name|P_MESGOUT
expr_stmt|;
if|if
condition|(
name|phasemis
condition|)
block|{
if|if
condition|(
name|bus_phase
operator|==
name|P_MESGIN
condition|)
block|{
comment|/* 				 * Change gears and see if 				 * this messages is of interest to 				 * us or should be passed back to 				 * the sequencer. 				 */
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|CLRSINT1
argument_list|,
name|CLRATNO
argument_list|)
expr_stmt|;
name|ahc
operator|->
name|send_msg_perror
operator|=
name|FALSE
expr_stmt|;
name|ahc
operator|->
name|msg_type
operator|=
name|MSG_TYPE_INITIATOR_MSGIN
expr_stmt|;
name|ahc
operator|->
name|msgin_index
operator|=
literal|0
expr_stmt|;
goto|goto
name|reswitch
goto|;
block|}
name|end_session
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ahc
operator|->
name|send_msg_perror
condition|)
block|{
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|CLRSINT1
argument_list|,
name|CLRATNO
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|CLRSINT1
argument_list|,
name|CLRREQINIT
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCSIDATL
argument_list|,
name|MSG_PARITY_ERROR
argument_list|)
expr_stmt|;
break|break;
block|}
name|msgdone
operator|=
name|ahc
operator|->
name|msgout_index
operator|==
name|ahc
operator|->
name|msgout_len
expr_stmt|;
if|if
condition|(
name|msgdone
condition|)
block|{
comment|/* 			 * The target has requested a retry. 			 * Re-assert ATN, reset our message index to 			 * 0, and try again. 			 */
name|ahc
operator|->
name|msgout_index
operator|=
literal|0
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCSISIGO
argument_list|,
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCSISIGO
argument_list|)
operator||
name|ATNO
argument_list|)
expr_stmt|;
block|}
name|lastbyte
operator|=
name|ahc
operator|->
name|msgout_index
operator|==
operator|(
name|ahc
operator|->
name|msgout_len
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|lastbyte
condition|)
block|{
comment|/* Last byte is signified by dropping ATN */
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|CLRSINT1
argument_list|,
name|CLRATNO
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Clear our interrupt status and present 		 * the next byte on the bus. 		 */
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|CLRSINT1
argument_list|,
name|CLRREQINIT
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCSIDATL
argument_list|,
name|ahc
operator|->
name|msgout_buf
index|[
name|ahc
operator|->
name|msgout_index
operator|++
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|MSG_TYPE_INITIATOR_MSGIN
case|:
block|{
name|int
name|phasemis
decl_stmt|;
name|int
name|message_done
decl_stmt|;
name|phasemis
operator|=
name|bus_phase
operator|!=
name|P_MESGIN
expr_stmt|;
if|if
condition|(
name|phasemis
condition|)
block|{
name|ahc
operator|->
name|msgin_index
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|bus_phase
operator|==
name|P_MESGOUT
operator|&&
operator|(
name|ahc
operator|->
name|send_msg_perror
operator|==
name|TRUE
operator|||
operator|(
name|ahc
operator|->
name|msgout_len
operator|!=
literal|0
operator|&&
name|ahc
operator|->
name|msgout_index
operator|==
literal|0
operator|)
operator|)
condition|)
block|{
name|ahc
operator|->
name|msg_type
operator|=
name|MSG_TYPE_INITIATOR_MSGOUT
expr_stmt|;
goto|goto
name|reswitch
goto|;
block|}
name|end_session
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
comment|/* Pull the byte in without acking it */
name|ahc
operator|->
name|msgin_buf
index|[
name|ahc
operator|->
name|msgin_index
index|]
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCSIBUSL
argument_list|)
expr_stmt|;
name|message_done
operator|=
name|ahc_parse_msg
argument_list|(
name|ahc
argument_list|,
name|path
argument_list|,
operator|&
name|devinfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|message_done
condition|)
block|{
comment|/* 			 * Clear our incoming message buffer in case there 			 * is another message following this one. 			 */
name|ahc
operator|->
name|msgin_index
operator|=
literal|0
expr_stmt|;
comment|/* 			 * If this message illicited a response, 			 * assert ATN so the target takes us to the 			 * message out phase. 			 */
if|if
condition|(
name|ahc
operator|->
name|msgout_len
operator|!=
literal|0
condition|)
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCSISIGO
argument_list|,
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCSISIGO
argument_list|)
operator||
name|ATNO
argument_list|)
expr_stmt|;
block|}
else|else
name|ahc
operator|->
name|msgin_index
operator|++
expr_stmt|;
comment|/* Ack the byte */
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|CLRSINT1
argument_list|,
name|CLRREQINIT
argument_list|)
expr_stmt|;
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCSIDATL
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|MSG_TYPE_TARGET_MSGIN
case|:
block|{
name|int
name|msgdone
decl_stmt|;
name|int
name|msgout_request
decl_stmt|;
if|if
condition|(
name|ahc
operator|->
name|msgout_len
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"Target MSGIN with no active message"
argument_list|)
expr_stmt|;
comment|/* 		 * If we interrupted a mesgout session, the initiator 		 * will not know this until our first REQ.  So, we 		 * only honor mesgout requests after we've sent our 		 * first byte. 		 */
if|if
condition|(
operator|(
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCSISIGI
argument_list|)
operator|&
name|ATNI
operator|)
operator|!=
literal|0
operator|&&
name|ahc
operator|->
name|msgout_index
operator|>
literal|0
condition|)
name|msgout_request
operator|=
name|TRUE
expr_stmt|;
else|else
name|msgout_request
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|msgout_request
condition|)
block|{
comment|/* 			 * Change gears and see if 			 * this messages is of interest to 			 * us or should be passed back to 			 * the sequencer. 			 */
name|ahc
operator|->
name|msg_type
operator|=
name|MSG_TYPE_TARGET_MSGOUT
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCSISIGO
argument_list|,
name|P_MESGOUT
operator||
name|BSYO
argument_list|)
expr_stmt|;
name|ahc
operator|->
name|msgin_index
operator|=
literal|0
expr_stmt|;
comment|/* Dummy read to REQ for first byte */
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCSIDATL
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SXFRCTL0
argument_list|,
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SXFRCTL0
argument_list|)
operator||
name|SPIOEN
argument_list|)
expr_stmt|;
break|break;
block|}
name|msgdone
operator|=
name|ahc
operator|->
name|msgout_index
operator|==
name|ahc
operator|->
name|msgout_len
expr_stmt|;
if|if
condition|(
name|msgdone
condition|)
block|{
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SXFRCTL0
argument_list|,
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SXFRCTL0
argument_list|)
operator|&
operator|~
name|SPIOEN
argument_list|)
expr_stmt|;
name|end_session
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
comment|/* 		 * Present the next byte on the bus. 		 */
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SXFRCTL0
argument_list|,
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SXFRCTL0
argument_list|)
operator||
name|SPIOEN
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCSIDATL
argument_list|,
name|ahc
operator|->
name|msgout_buf
index|[
name|ahc
operator|->
name|msgout_index
operator|++
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|MSG_TYPE_TARGET_MSGOUT
case|:
block|{
name|int
name|lastbyte
decl_stmt|;
name|int
name|msgdone
decl_stmt|;
comment|/* 		 * The initiator signals that this is 		 * the last byte by dropping ATN. 		 */
name|lastbyte
operator|=
operator|(
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCSISIGI
argument_list|)
operator|&
name|ATNI
operator|)
operator|==
literal|0
expr_stmt|;
comment|/* 		 * Read the latched byte, but turn off SPIOEN first 		 * so that we don't inadvertantly cause a REQ for the 		 * next byte. 		 */
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SXFRCTL0
argument_list|,
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SXFRCTL0
argument_list|)
operator|&
operator|~
name|SPIOEN
argument_list|)
expr_stmt|;
name|ahc
operator|->
name|msgin_buf
index|[
name|ahc
operator|->
name|msgin_index
index|]
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCSIDATL
argument_list|)
expr_stmt|;
name|msgdone
operator|=
name|ahc_parse_msg
argument_list|(
name|ahc
argument_list|,
name|path
argument_list|,
operator|&
name|devinfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|msgdone
operator|==
name|MSGLOOP_TERMINATED
condition|)
block|{
comment|/* 			 * The message is *really* done in that it caused 			 * us to go to bus free.  The sequencer has already 			 * been reset at this point, so pull the ejection 			 * handle. 			 */
return|return;
block|}
name|ahc
operator|->
name|msgin_index
operator|++
expr_stmt|;
comment|/* 		 * XXX Read spec about initiator dropping ATN too soon 		 *     and use msgdone to detect it. 		 */
if|if
condition|(
name|msgdone
operator|==
name|MSGLOOP_MSGCOMPLETE
condition|)
block|{
name|ahc
operator|->
name|msgin_index
operator|=
literal|0
expr_stmt|;
comment|/* 			 * If this message illicited a response, transition 			 * to the Message in phase and send it. 			 */
if|if
condition|(
name|ahc
operator|->
name|msgout_len
operator|!=
literal|0
condition|)
block|{
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCSISIGO
argument_list|,
name|P_MESGIN
operator||
name|BSYO
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SXFRCTL0
argument_list|,
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SXFRCTL0
argument_list|)
operator||
name|SPIOEN
argument_list|)
expr_stmt|;
name|ahc
operator|->
name|msg_type
operator|=
name|MSG_TYPE_TARGET_MSGIN
expr_stmt|;
name|ahc
operator|->
name|msgin_index
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|lastbyte
condition|)
name|end_session
operator|=
name|TRUE
expr_stmt|;
else|else
block|{
comment|/* Ask for the next byte. */
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SXFRCTL0
argument_list|,
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SXFRCTL0
argument_list|)
operator||
name|SPIOEN
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
default|default:
name|panic
argument_list|(
literal|"Unknown REQINIT message type"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|end_session
condition|)
block|{
name|ahc_clear_msg_state
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|RETURN_1
argument_list|,
name|EXIT_MSG_LOOP
argument_list|)
expr_stmt|;
block|}
else|else
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|RETURN_1
argument_list|,
name|CONT_MSG_LOOP
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * See if we sent a particular extended message to the target.  * If "full" is true, the target saw the full message.  * If "full" is false, the target saw at least the first  * byte of the message.  */
end_comment

begin_function
specifier|static
name|int
name|ahc_sent_msg
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|u_int
name|msgtype
parameter_list|,
name|int
name|full
parameter_list|)
block|{
name|int
name|found
decl_stmt|;
name|int
name|index
decl_stmt|;
name|found
operator|=
name|FALSE
expr_stmt|;
name|index
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|index
operator|<
name|ahc
operator|->
name|msgout_len
condition|)
block|{
if|if
condition|(
operator|(
name|ahc
operator|->
name|msgout_buf
index|[
name|index
index|]
operator|&
name|MSG_IDENTIFYFLAG
operator|)
operator|!=
literal|0
operator|||
name|ahc
operator|->
name|msgout_buf
index|[
name|index
index|]
operator|==
name|MSG_MESSAGE_REJECT
condition|)
name|index
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|ahc
operator|->
name|msgout_buf
index|[
name|index
index|]
operator|>=
name|MSG_SIMPLE_Q_TAG
operator|&&
name|ahc
operator|->
name|msgout_buf
index|[
name|index
index|]
operator|<
name|MSG_IGN_WIDE_RESIDUE
condition|)
block|{
comment|/* Skip tag type and tag id */
name|index
operator|+=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ahc
operator|->
name|msgout_buf
index|[
name|index
index|]
operator|==
name|MSG_EXTENDED
condition|)
block|{
comment|/* Found a candidate */
if|if
condition|(
name|ahc
operator|->
name|msgout_buf
index|[
name|index
operator|+
literal|2
index|]
operator|==
name|msgtype
condition|)
block|{
name|u_int
name|end_index
decl_stmt|;
name|end_index
operator|=
name|index
operator|+
literal|1
operator|+
name|ahc
operator|->
name|msgout_buf
index|[
name|index
operator|+
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|full
condition|)
block|{
if|if
condition|(
name|ahc
operator|->
name|msgout_index
operator|>
name|end_index
condition|)
name|found
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ahc
operator|->
name|msgout_index
operator|>
name|index
condition|)
name|found
operator|=
name|TRUE
expr_stmt|;
block|}
break|break;
block|}
else|else
block|{
name|panic
argument_list|(
literal|"ahc_sent_msg: Inconsistent msg buffer"
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|found
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ahc_parse_msg
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|struct
name|cam_path
modifier|*
name|path
parameter_list|,
name|struct
name|ahc_devinfo
modifier|*
name|devinfo
parameter_list|)
block|{
name|struct
name|ahc_initiator_tinfo
modifier|*
name|tinfo
decl_stmt|;
name|struct
name|tmode_tstate
modifier|*
name|tstate
decl_stmt|;
name|int
name|reject
decl_stmt|;
name|int
name|done
decl_stmt|;
name|int
name|response
decl_stmt|;
name|u_int
name|targ_scsirate
decl_stmt|;
name|done
operator|=
name|MSGLOOP_IN_PROG
expr_stmt|;
name|response
operator|=
name|FALSE
expr_stmt|;
name|reject
operator|=
name|FALSE
expr_stmt|;
name|tinfo
operator|=
name|ahc_fetch_transinfo
argument_list|(
name|ahc
argument_list|,
name|devinfo
operator|->
name|channel
argument_list|,
name|devinfo
operator|->
name|our_scsiid
argument_list|,
name|devinfo
operator|->
name|target
argument_list|,
operator|&
name|tstate
argument_list|)
expr_stmt|;
name|targ_scsirate
operator|=
name|tinfo
operator|->
name|scsirate
expr_stmt|;
comment|/* 	 * Parse as much of the message as is availible, 	 * rejecting it if we don't support it.  When 	 * the entire message is availible and has been 	 * handled, return TRUE indicating that we have 	 * parsed an entire message. 	 * 	 * In the case of extended messages, we accept the length 	 * byte outright and perform more checking once we know the 	 * extended message type. 	 */
switch|switch
condition|(
name|ahc
operator|->
name|msgin_buf
index|[
literal|0
index|]
condition|)
block|{
case|case
name|MSG_MESSAGE_REJECT
case|:
name|response
operator|=
name|ahc_handle_msg_reject
argument_list|(
name|ahc
argument_list|,
name|devinfo
argument_list|)
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
name|MSG_NOOP
case|:
name|done
operator|=
name|MSGLOOP_MSGCOMPLETE
expr_stmt|;
break|break;
case|case
name|MSG_IGN_WIDE_RESIDUE
case|:
block|{
comment|/* Wait for the whole message */
if|if
condition|(
name|ahc
operator|->
name|msgin_index
operator|>=
literal|1
condition|)
block|{
if|if
condition|(
name|ahc
operator|->
name|msgin_buf
index|[
literal|1
index|]
operator|!=
literal|1
operator|||
name|tinfo
operator|->
name|current
operator|.
name|width
operator|==
name|MSG_EXT_WDTR_BUS_8_BIT
condition|)
block|{
name|reject
operator|=
name|TRUE
expr_stmt|;
name|done
operator|=
name|MSGLOOP_MSGCOMPLETE
expr_stmt|;
block|}
else|else
name|ahc_handle_ign_wide_residue
argument_list|(
name|ahc
argument_list|,
name|devinfo
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|MSG_EXTENDED
case|:
block|{
comment|/* Wait for enough of the message to begin validation */
if|if
condition|(
name|ahc
operator|->
name|msgin_index
operator|<
literal|2
condition|)
break|break;
switch|switch
condition|(
name|ahc
operator|->
name|msgin_buf
index|[
literal|2
index|]
condition|)
block|{
case|case
name|MSG_EXT_SDTR
case|:
block|{
name|struct
name|ahc_syncrate
modifier|*
name|syncrate
decl_stmt|;
name|u_int
name|period
decl_stmt|;
name|u_int
name|offset
decl_stmt|;
name|u_int
name|saved_offset
decl_stmt|;
if|if
condition|(
name|ahc
operator|->
name|msgin_buf
index|[
literal|1
index|]
operator|!=
name|MSG_EXT_SDTR_LEN
condition|)
block|{
name|reject
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
comment|/* 			 * Wait until we have both args before validating 			 * and acting on this message. 			 * 			 * Add one to MSG_EXT_SDTR_LEN to account for 			 * the extended message preamble. 			 */
if|if
condition|(
name|ahc
operator|->
name|msgin_index
operator|<
operator|(
name|MSG_EXT_SDTR_LEN
operator|+
literal|1
operator|)
condition|)
break|break;
name|period
operator|=
name|ahc
operator|->
name|msgin_buf
index|[
literal|3
index|]
expr_stmt|;
name|saved_offset
operator|=
name|offset
operator|=
name|ahc
operator|->
name|msgin_buf
index|[
literal|4
index|]
expr_stmt|;
name|syncrate
operator|=
name|ahc_devlimited_syncrate
argument_list|(
name|ahc
argument_list|,
operator|&
name|period
argument_list|)
expr_stmt|;
name|ahc_validate_offset
argument_list|(
name|ahc
argument_list|,
name|syncrate
argument_list|,
operator|&
name|offset
argument_list|,
name|targ_scsirate
operator|&
name|WIDEXFER
argument_list|)
expr_stmt|;
name|ahc_set_syncrate
argument_list|(
name|ahc
argument_list|,
name|devinfo
argument_list|,
name|path
argument_list|,
name|syncrate
argument_list|,
name|period
argument_list|,
name|offset
argument_list|,
name|AHC_TRANS_ACTIVE
operator||
name|AHC_TRANS_GOAL
argument_list|,
comment|/*paused*/
name|TRUE
argument_list|)
expr_stmt|;
comment|/* 			 * See if we initiated Sync Negotiation 			 * and didn't have to fall down to async 			 * transfers. 			 */
if|if
condition|(
name|ahc_sent_msg
argument_list|(
name|ahc
argument_list|,
name|MSG_EXT_SDTR
argument_list|,
comment|/*full*/
name|TRUE
argument_list|)
condition|)
block|{
comment|/* We started it */
if|if
condition|(
name|saved_offset
operator|!=
name|offset
condition|)
block|{
comment|/* Went too low - force async */
name|reject
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 				 * Send our own SDTR in reply 				 */
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"Sending SDTR!\n"
argument_list|)
expr_stmt|;
name|ahc
operator|->
name|msgout_index
operator|=
literal|0
expr_stmt|;
name|ahc
operator|->
name|msgout_len
operator|=
literal|0
expr_stmt|;
name|ahc_construct_sdtr
argument_list|(
name|ahc
argument_list|,
name|period
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|ahc
operator|->
name|msgout_index
operator|=
literal|0
expr_stmt|;
name|response
operator|=
name|TRUE
expr_stmt|;
block|}
name|done
operator|=
name|MSGLOOP_MSGCOMPLETE
expr_stmt|;
break|break;
block|}
case|case
name|MSG_EXT_WDTR
case|:
block|{
name|u_int
name|bus_width
decl_stmt|;
name|u_int
name|sending_reply
decl_stmt|;
name|sending_reply
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|ahc
operator|->
name|msgin_buf
index|[
literal|1
index|]
operator|!=
name|MSG_EXT_WDTR_LEN
condition|)
block|{
name|reject
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
comment|/* 			 * Wait until we have our arg before validating 			 * and acting on this message. 			 * 			 * Add one to MSG_EXT_WDTR_LEN to account for 			 * the extended message preamble. 			 */
if|if
condition|(
name|ahc
operator|->
name|msgin_index
operator|<
operator|(
name|MSG_EXT_WDTR_LEN
operator|+
literal|1
operator|)
condition|)
break|break;
comment|/* 			 * Due to a problem with sync/wide transfers 			 * on the aic7880 only allow this on Ultra2 			 * controllers for the moment. 			 */
if|if
condition|(
name|devinfo
operator|->
name|role
operator|==
name|ROLE_TARGET
operator|&&
operator|(
name|ahc
operator|->
name|features
operator|&
name|AHC_ULTRA2
operator|)
operator|==
literal|0
condition|)
block|{
name|reject
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
name|bus_width
operator|=
name|ahc
operator|->
name|msgin_buf
index|[
literal|3
index|]
expr_stmt|;
if|if
condition|(
name|ahc_sent_msg
argument_list|(
name|ahc
argument_list|,
name|MSG_EXT_WDTR
argument_list|,
comment|/*full*/
name|TRUE
argument_list|)
condition|)
block|{
comment|/* 				 * Don't send a WDTR back to the 				 * target, since we asked first. 				 */
switch|switch
condition|(
name|bus_width
condition|)
block|{
default|default:
comment|/* 					 * How can we do anything greater 					 * than 16bit transfers on a 16bit 					 * bus? 					 */
name|reject
operator|=
name|TRUE
expr_stmt|;
name|printf
argument_list|(
literal|"%s: target %d requested %dBit "
literal|"transfers.  Rejecting...\n"
argument_list|,
name|ahc_name
argument_list|(
name|ahc
argument_list|)
argument_list|,
name|devinfo
operator|->
name|target
argument_list|,
literal|8
operator|*
operator|(
literal|0x01
operator|<<
name|bus_width
operator|)
argument_list|)
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
name|MSG_EXT_WDTR_BUS_8_BIT
case|:
name|bus_width
operator|=
name|MSG_EXT_WDTR_BUS_8_BIT
expr_stmt|;
break|break;
case|case
name|MSG_EXT_WDTR_BUS_16_BIT
case|:
break|break;
block|}
block|}
else|else
block|{
comment|/* 				 * Send our own WDTR in reply 				 */
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"Sending WDTR!\n"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|bus_width
condition|)
block|{
default|default:
if|if
condition|(
name|ahc
operator|->
name|features
operator|&
name|AHC_WIDE
condition|)
block|{
comment|/* Respond Wide */
name|bus_width
operator|=
name|MSG_EXT_WDTR_BUS_16_BIT
expr_stmt|;
break|break;
block|}
comment|/* FALLTHROUGH */
case|case
name|MSG_EXT_WDTR_BUS_8_BIT
case|:
name|bus_width
operator|=
name|MSG_EXT_WDTR_BUS_8_BIT
expr_stmt|;
break|break;
block|}
name|ahc
operator|->
name|msgout_index
operator|=
literal|0
expr_stmt|;
name|ahc
operator|->
name|msgout_len
operator|=
literal|0
expr_stmt|;
name|ahc_construct_wdtr
argument_list|(
name|ahc
argument_list|,
name|bus_width
argument_list|)
expr_stmt|;
name|ahc
operator|->
name|msgout_index
operator|=
literal|0
expr_stmt|;
name|response
operator|=
name|TRUE
expr_stmt|;
name|sending_reply
operator|=
name|TRUE
expr_stmt|;
block|}
name|ahc_set_width
argument_list|(
name|ahc
argument_list|,
name|devinfo
argument_list|,
name|path
argument_list|,
name|bus_width
argument_list|,
name|AHC_TRANS_ACTIVE
operator||
name|AHC_TRANS_GOAL
argument_list|,
comment|/*paused*/
name|TRUE
argument_list|)
expr_stmt|;
comment|/* After a wide message, we are async */
name|ahc_set_syncrate
argument_list|(
name|ahc
argument_list|,
name|devinfo
argument_list|,
name|path
argument_list|,
comment|/*syncrate*/
name|NULL
argument_list|,
comment|/*period*/
literal|0
argument_list|,
comment|/*offset*/
literal|0
argument_list|,
name|AHC_TRANS_ACTIVE
argument_list|,
comment|/*paused*/
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sending_reply
operator|==
name|FALSE
operator|&&
name|reject
operator|==
name|FALSE
condition|)
block|{
if|if
condition|(
name|tinfo
operator|->
name|goal
operator|.
name|period
condition|)
block|{
name|struct
name|ahc_syncrate
modifier|*
name|rate
decl_stmt|;
name|u_int
name|period
decl_stmt|;
name|u_int
name|offset
decl_stmt|;
comment|/* Start the sync negotiation */
name|period
operator|=
name|tinfo
operator|->
name|goal
operator|.
name|period
expr_stmt|;
name|rate
operator|=
name|ahc_devlimited_syncrate
argument_list|(
name|ahc
argument_list|,
operator|&
name|period
argument_list|)
expr_stmt|;
name|offset
operator|=
name|tinfo
operator|->
name|goal
operator|.
name|offset
expr_stmt|;
name|ahc_validate_offset
argument_list|(
name|ahc
argument_list|,
name|rate
argument_list|,
operator|&
name|offset
argument_list|,
name|tinfo
operator|->
name|current
operator|.
name|width
argument_list|)
expr_stmt|;
name|ahc
operator|->
name|msgout_index
operator|=
literal|0
expr_stmt|;
name|ahc
operator|->
name|msgout_len
operator|=
literal|0
expr_stmt|;
name|ahc_construct_sdtr
argument_list|(
name|ahc
argument_list|,
name|period
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|ahc
operator|->
name|msgout_index
operator|=
literal|0
expr_stmt|;
name|response
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
name|done
operator|=
name|MSGLOOP_MSGCOMPLETE
expr_stmt|;
break|break;
block|}
default|default:
comment|/* Unknown extended message.  Reject it. */
name|reject
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
break|break;
block|}
case|case
name|MSG_BUS_DEV_RESET
case|:
name|ahc_handle_devreset
argument_list|(
name|ahc
argument_list|,
name|devinfo
argument_list|,
name|CAM_BDR_SENT
argument_list|,
name|AC_SENT_BDR
argument_list|,
literal|"Bus Device Reset Received"
argument_list|,
comment|/*verbose_level*/
literal|0
argument_list|)
expr_stmt|;
name|restart_sequencer
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
name|done
operator|=
name|MSGLOOP_TERMINATED
expr_stmt|;
break|break;
case|case
name|MSG_ABORT_TAG
case|:
case|case
name|MSG_ABORT
case|:
case|case
name|MSG_CLEAR_QUEUE
case|:
comment|/* Target mode messages */
if|if
condition|(
name|devinfo
operator|->
name|role
operator|!=
name|ROLE_TARGET
condition|)
block|{
name|reject
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
name|ahc_abort_scbs
argument_list|(
name|ahc
argument_list|,
name|devinfo
operator|->
name|target
argument_list|,
name|devinfo
operator|->
name|channel
argument_list|,
name|devinfo
operator|->
name|lun
argument_list|,
name|ahc
operator|->
name|msgin_buf
index|[
literal|0
index|]
operator|==
name|MSG_ABORT_TAG
condition|?
name|SCB_LIST_NULL
else|:
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|INITIATOR_TAG
argument_list|)
argument_list|,
name|ROLE_TARGET
argument_list|,
name|CAM_REQ_ABORTED
argument_list|)
expr_stmt|;
name|tstate
operator|=
name|ahc
operator|->
name|enabled_targets
index|[
name|devinfo
operator|->
name|our_scsiid
index|]
expr_stmt|;
if|if
condition|(
name|tstate
operator|!=
name|NULL
condition|)
block|{
name|struct
name|tmode_lstate
modifier|*
name|lstate
decl_stmt|;
name|lstate
operator|=
name|tstate
operator|->
name|enabled_luns
index|[
name|devinfo
operator|->
name|lun
index|]
expr_stmt|;
if|if
condition|(
name|lstate
operator|!=
name|NULL
condition|)
block|{
name|ahc_queue_lstate_event
argument_list|(
name|ahc
argument_list|,
name|lstate
argument_list|,
name|devinfo
operator|->
name|our_scsiid
argument_list|,
name|ahc
operator|->
name|msgin_buf
index|[
literal|0
index|]
argument_list|,
comment|/*arg*/
literal|0
argument_list|)
expr_stmt|;
name|ahc_send_lstate_events
argument_list|(
name|ahc
argument_list|,
name|lstate
argument_list|)
expr_stmt|;
block|}
block|}
name|done
operator|=
name|MSGLOOP_MSGCOMPLETE
expr_stmt|;
break|break;
case|case
name|MSG_TERM_IO_PROC
case|:
default|default:
name|reject
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|reject
condition|)
block|{
comment|/* 		 * Setup to reject the message. 		 */
name|ahc
operator|->
name|msgout_index
operator|=
literal|0
expr_stmt|;
name|ahc
operator|->
name|msgout_len
operator|=
literal|1
expr_stmt|;
name|ahc
operator|->
name|msgout_buf
index|[
literal|0
index|]
operator|=
name|MSG_MESSAGE_REJECT
expr_stmt|;
name|done
operator|=
name|MSGLOOP_MSGCOMPLETE
expr_stmt|;
name|response
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
name|done
operator|!=
name|MSGLOOP_IN_PROG
operator|&&
operator|!
name|response
condition|)
comment|/* Clear the outgoing message buffer */
name|ahc
operator|->
name|msgout_len
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|done
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ahc_handle_ign_wide_residue
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|struct
name|ahc_devinfo
modifier|*
name|devinfo
parameter_list|)
block|{
name|u_int
name|scb_index
decl_stmt|;
name|struct
name|scb
modifier|*
name|scb
decl_stmt|;
name|scb_index
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCB_TAG
argument_list|)
expr_stmt|;
name|scb
operator|=
operator|&
name|ahc
operator|->
name|scb_data
operator|->
name|scbarray
index|[
name|scb_index
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SEQ_FLAGS
argument_list|)
operator|&
name|DPHASE
operator|)
operator|==
literal|0
operator|||
operator|(
name|scb
operator|->
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DIR_MASK
operator|)
operator|!=
name|CAM_DIR_IN
condition|)
block|{
comment|/* 		 * Ignore the message if we haven't 		 * seen an appropriate data phase yet. 		 */
block|}
else|else
block|{
comment|/* 		 * If the residual occurred on the last 		 * transfer and the transfer request was 		 * expected to end on an odd count, do 		 * nothing.  Otherwise, subtract a byte 		 * and update the residual count accordingly. 		 */
name|u_int
name|resid_sgcnt
decl_stmt|;
name|resid_sgcnt
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCB_RESID_SGCNT
argument_list|)
expr_stmt|;
if|if
condition|(
name|resid_sgcnt
operator|==
literal|0
operator|&&
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|DATA_COUNT_ODD
argument_list|)
operator|==
literal|1
condition|)
block|{
comment|/* 			 * If the residual occurred on the last 			 * transfer and the transfer request was 			 * expected to end on an odd count, do 			 * nothing. 			 */
block|}
else|else
block|{
name|u_int
name|data_cnt
decl_stmt|;
name|u_int
name|data_addr
decl_stmt|;
name|u_int
name|sg_index
decl_stmt|;
name|data_cnt
operator|=
operator|(
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCB_RESID_DCNT
operator|+
literal|2
argument_list|)
operator|<<
literal|16
operator|)
operator||
operator|(
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCB_RESID_DCNT
operator|+
literal|1
argument_list|)
operator|<<
literal|8
operator|)
operator||
operator|(
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCB_RESID_DCNT
argument_list|)
operator|)
expr_stmt|;
name|data_addr
operator|=
operator|(
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SHADDR
operator|+
literal|3
argument_list|)
operator|<<
literal|24
operator|)
operator||
operator|(
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SHADDR
operator|+
literal|2
argument_list|)
operator|<<
literal|16
operator|)
operator||
operator|(
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SHADDR
operator|+
literal|1
argument_list|)
operator|<<
literal|8
operator|)
operator||
operator|(
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SHADDR
argument_list|)
operator|)
expr_stmt|;
name|data_cnt
operator|+=
literal|1
expr_stmt|;
name|data_addr
operator|-=
literal|1
expr_stmt|;
name|sg_index
operator|=
name|scb
operator|->
name|sg_count
operator|-
name|resid_sgcnt
expr_stmt|;
comment|/* 			 * scb->sg_list starts with the second S/G entry. 			 */
if|if
condition|(
name|sg_index
operator|--
operator|!=
literal|0
operator|&&
operator|(
name|scb
operator|->
name|sg_list
index|[
name|sg_index
index|]
operator|.
name|len
operator|<
name|data_cnt
operator|)
condition|)
block|{
name|u_int
name|sg_addr
decl_stmt|;
name|data_cnt
operator|=
literal|1
expr_stmt|;
name|data_addr
operator|=
name|scb
operator|->
name|sg_list
index|[
name|sg_index
operator|-
literal|1
index|]
operator|.
name|addr
operator|+
name|scb
operator|->
name|sg_list
index|[
name|sg_index
operator|-
literal|1
index|]
operator|.
name|len
operator|-
literal|1
expr_stmt|;
name|sg_addr
operator|=
name|scb
operator|->
name|sg_list_phys
operator|+
operator|(
name|sg_index
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|scb
operator|->
name|sg_list
argument_list|)
operator|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SG_NEXT
operator|+
literal|3
argument_list|,
name|sg_addr
operator|>>
literal|24
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SG_NEXT
operator|+
literal|2
argument_list|,
name|sg_addr
operator|>>
literal|16
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SG_NEXT
operator|+
literal|1
argument_list|,
name|sg_addr
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SG_NEXT
argument_list|,
name|sg_addr
argument_list|)
expr_stmt|;
block|}
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCB_RESID_DCNT
operator|+
literal|2
argument_list|,
name|data_cnt
operator|>>
literal|16
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCB_RESID_DCNT
operator|+
literal|1
argument_list|,
name|data_cnt
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCB_RESID_DCNT
argument_list|,
name|data_cnt
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SHADDR
operator|+
literal|3
argument_list|,
name|data_addr
operator|>>
literal|24
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SHADDR
operator|+
literal|2
argument_list|,
name|data_addr
operator|>>
literal|16
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SHADDR
operator|+
literal|1
argument_list|,
name|data_addr
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SHADDR
argument_list|,
name|data_addr
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ahc_handle_devreset
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|struct
name|ahc_devinfo
modifier|*
name|devinfo
parameter_list|,
name|cam_status
name|status
parameter_list|,
name|ac_code
name|acode
parameter_list|,
name|char
modifier|*
name|message
parameter_list|,
name|int
name|verbose_level
parameter_list|)
block|{
name|struct
name|cam_path
modifier|*
name|path
decl_stmt|;
name|int
name|found
decl_stmt|;
name|int
name|error
decl_stmt|;
name|struct
name|tmode_tstate
modifier|*
name|tstate
decl_stmt|;
name|u_int
name|lun
decl_stmt|;
name|error
operator|=
name|ahc_create_path
argument_list|(
name|ahc
argument_list|,
name|devinfo
argument_list|,
operator|&
name|path
argument_list|)
expr_stmt|;
name|found
operator|=
name|ahc_abort_scbs
argument_list|(
name|ahc
argument_list|,
name|devinfo
operator|->
name|target
argument_list|,
name|devinfo
operator|->
name|channel
argument_list|,
name|CAM_LUN_WILDCARD
argument_list|,
name|SCB_LIST_NULL
argument_list|,
name|devinfo
operator|->
name|role
argument_list|,
name|status
argument_list|)
expr_stmt|;
comment|/* 	 * Send an immediate notify ccb to all target more peripheral 	 * drivers affected by this action. 	 */
name|tstate
operator|=
name|ahc
operator|->
name|enabled_targets
index|[
name|devinfo
operator|->
name|our_scsiid
index|]
expr_stmt|;
if|if
condition|(
name|tstate
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|lun
operator|=
literal|0
init|;
name|lun
operator|<=
literal|7
condition|;
name|lun
operator|++
control|)
block|{
name|struct
name|tmode_lstate
modifier|*
name|lstate
decl_stmt|;
name|lstate
operator|=
name|tstate
operator|->
name|enabled_luns
index|[
name|lun
index|]
expr_stmt|;
if|if
condition|(
name|lstate
operator|==
name|NULL
condition|)
continue|continue;
name|ahc_queue_lstate_event
argument_list|(
name|ahc
argument_list|,
name|lstate
argument_list|,
name|devinfo
operator|->
name|our_scsiid
argument_list|,
name|MSG_BUS_DEV_RESET
argument_list|,
comment|/*arg*/
literal|0
argument_list|)
expr_stmt|;
name|ahc_send_lstate_events
argument_list|(
name|ahc
argument_list|,
name|lstate
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * Go back to async/narrow transfers and renegotiate. 	 * ahc_set_width and ahc_set_syncrate can cope with NULL 	 * paths. 	 */
name|ahc_set_width
argument_list|(
name|ahc
argument_list|,
name|devinfo
argument_list|,
name|path
argument_list|,
name|MSG_EXT_WDTR_BUS_8_BIT
argument_list|,
name|AHC_TRANS_CUR
argument_list|,
comment|/*paused*/
name|TRUE
argument_list|)
expr_stmt|;
name|ahc_set_syncrate
argument_list|(
name|ahc
argument_list|,
name|devinfo
argument_list|,
name|path
argument_list|,
comment|/*syncrate*/
name|NULL
argument_list|,
comment|/*period*/
literal|0
argument_list|,
comment|/*offset*/
literal|0
argument_list|,
name|AHC_TRANS_CUR
argument_list|,
comment|/*paused*/
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|CAM_REQ_CMP
operator|&&
name|acode
operator|!=
literal|0
condition|)
name|xpt_async
argument_list|(
name|AC_SENT_BDR
argument_list|,
name|path
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|CAM_REQ_CMP
condition|)
name|xpt_free_path
argument_list|(
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|message
operator|!=
name|NULL
operator|&&
operator|(
name|verbose_level
operator|<=
name|bootverbose
operator|)
condition|)
name|printf
argument_list|(
literal|"%s: %s on %c:%d. %d SCBs aborted\n"
argument_list|,
name|ahc_name
argument_list|(
name|ahc
argument_list|)
argument_list|,
name|message
argument_list|,
name|devinfo
operator|->
name|channel
argument_list|,
name|devinfo
operator|->
name|target
argument_list|,
name|found
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * We have an scb which has been processed by the  * adaptor, now we look to see how the operation  * went.  */
end_comment

begin_function
specifier|static
name|void
name|ahc_done
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|struct
name|scb
modifier|*
name|scb
parameter_list|)
block|{
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|CAM_DEBUG
argument_list|(
name|scb
operator|->
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
name|CAM_DEBUG_TRACE
argument_list|,
operator|(
literal|"ahc_done - scb %d\n"
operator|,
name|scb
operator|->
name|hscb
operator|->
name|tag
operator|)
argument_list|)
expr_stmt|;
name|ccb
operator|=
name|scb
operator|->
name|ccb
expr_stmt|;
name|LIST_REMOVE
argument_list|(
operator|&
name|ccb
operator|->
name|ccb_h
argument_list|,
name|sim_links
operator|.
name|le
argument_list|)
expr_stmt|;
name|untimeout
argument_list|(
name|ahc_timeout
argument_list|,
operator|(
name|caddr_t
operator|)
name|scb
argument_list|,
name|ccb
operator|->
name|ccb_h
operator|.
name|timeout_ch
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DIR_MASK
operator|)
operator|!=
name|CAM_DIR_NONE
condition|)
block|{
name|bus_dmasync_op_t
name|op
decl_stmt|;
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DIR_MASK
operator|)
operator|==
name|CAM_DIR_IN
condition|)
name|op
operator|=
name|BUS_DMASYNC_POSTREAD
expr_stmt|;
else|else
name|op
operator|=
name|BUS_DMASYNC_POSTWRITE
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|ahc
operator|->
name|buffer_dmat
argument_list|,
name|scb
operator|->
name|dmamap
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|ahc
operator|->
name|buffer_dmat
argument_list|,
name|scb
operator|->
name|dmamap
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Unbusy this target/channel/lun. 	 * XXX if we are holding two commands per lun,  	 *     send the next command. 	 */
name|ahc_index_busy_tcl
argument_list|(
name|ahc
argument_list|,
name|scb
operator|->
name|hscb
operator|->
name|tcl
argument_list|,
comment|/*unbusy*/
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|==
name|XPT_CONT_TARGET_IO
condition|)
block|{
if|if
condition|(
name|ahc_ccb_status
argument_list|(
name|ccb
argument_list|)
operator|==
name|CAM_REQ_INPROG
condition|)
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_REQ_CMP
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&=
operator|~
name|CAM_SIM_QUEUED
expr_stmt|;
name|ahcfreescb
argument_list|(
name|ahc
argument_list|,
name|scb
argument_list|)
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * If the recovery SCB completes, we have to be 	 * out of our timeout. 	 */
if|if
condition|(
operator|(
name|scb
operator|->
name|flags
operator|&
name|SCB_RECOVERY_SCB
operator|)
operator|!=
literal|0
condition|)
block|{
name|struct
name|ccb_hdr
modifier|*
name|ccbh
decl_stmt|;
comment|/* 		 * We were able to complete the command successfully, 		 * so reinstate the timeouts for all other pending 		 * commands. 		 */
name|ccbh
operator|=
name|ahc
operator|->
name|pending_ccbs
operator|.
name|lh_first
expr_stmt|;
while|while
condition|(
name|ccbh
operator|!=
name|NULL
condition|)
block|{
name|struct
name|scb
modifier|*
name|pending_scb
decl_stmt|;
name|pending_scb
operator|=
operator|(
expr|struct
name|scb
operator|*
operator|)
name|ccbh
operator|->
name|ccb_scb_ptr
expr_stmt|;
name|ccbh
operator|->
name|timeout_ch
operator|=
name|timeout
argument_list|(
name|ahc_timeout
argument_list|,
name|pending_scb
argument_list|,
operator|(
name|ccbh
operator|->
name|timeout
operator|*
name|hz
operator|)
operator|/
literal|1000
argument_list|)
expr_stmt|;
name|ccbh
operator|=
name|LIST_NEXT
argument_list|(
name|ccbh
argument_list|,
name|sim_links
operator|.
name|le
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Ensure that we didn't put a second instance of this 		 * SCB into the QINFIFO. 		 */
name|ahc_search_qinfifo
argument_list|(
name|ahc
argument_list|,
name|SCB_TARGET
argument_list|(
name|scb
argument_list|)
argument_list|,
name|SCB_CHANNEL
argument_list|(
name|scb
argument_list|)
argument_list|,
name|SCB_LUN
argument_list|(
name|scb
argument_list|)
argument_list|,
name|scb
operator|->
name|hscb
operator|->
name|tag
argument_list|,
name|ROLE_INITIATOR
argument_list|,
comment|/*status*/
literal|0
argument_list|,
name|SEARCH_REMOVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|ahc_ccb_status
argument_list|(
name|ccb
argument_list|)
operator|==
name|CAM_BDR_SENT
operator|||
name|ahc_ccb_status
argument_list|(
name|ccb
argument_list|)
operator|==
name|CAM_REQ_ABORTED
condition|)
name|ahcsetccbstatus
argument_list|(
name|ccb
argument_list|,
name|CAM_CMD_TIMEOUT
argument_list|)
expr_stmt|;
name|xpt_print_path
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"no longer in timeout, status = %x\n"
argument_list|,
name|ccb
operator|->
name|ccb_h
operator|.
name|status
argument_list|)
expr_stmt|;
block|}
comment|/* Don't clobber any existing error state */
if|if
condition|(
name|ahc_ccb_status
argument_list|(
name|ccb
argument_list|)
operator|==
name|CAM_REQ_INPROG
condition|)
block|{
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_REQ_CMP
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|scb
operator|->
name|flags
operator|&
name|SCB_SENSE
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * We performed autosense retrieval. 		 * 		 * bzero the sense data before having 		 * the drive fill it.  The SCSI spec mandates 		 * that any untransfered data should be 		 * assumed to be zero.  Complete the 'bounce' 		 * of sense information through buffers accessible 		 * via bus-space by copying it into the clients 		 * csio. 		 */
name|bzero
argument_list|(
operator|&
name|ccb
operator|->
name|csio
operator|.
name|sense_data
argument_list|,
sizeof|sizeof
argument_list|(
name|ccb
operator|->
name|csio
operator|.
name|sense_data
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|ahc
operator|->
name|scb_data
operator|->
name|sense
index|[
name|scb
operator|->
name|hscb
operator|->
name|tag
index|]
argument_list|,
operator|&
name|ccb
operator|->
name|csio
operator|.
name|sense_data
argument_list|,
name|scb
operator|->
name|sg_list
operator|->
name|len
argument_list|)
expr_stmt|;
name|scb
operator|->
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_AUTOSNS_VALID
expr_stmt|;
block|}
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&=
operator|~
name|CAM_SIM_QUEUED
expr_stmt|;
name|ahcfreescb
argument_list|(
name|ahc
argument_list|,
name|scb
argument_list|)
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Determine the number of SCBs available on the controller  */
end_comment

begin_function
name|int
name|ahc_probe_scbs
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|AHC_SCB_MAX
condition|;
name|i
operator|++
control|)
block|{
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCBPTR
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCB_CONTROL
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCB_CONTROL
argument_list|)
operator|!=
name|i
condition|)
break|break;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCBPTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCB_CONTROL
argument_list|)
operator|!=
literal|0
condition|)
break|break;
block|}
return|return
operator|(
name|i
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Start the board, ready for normal operation  */
end_comment

begin_function
name|int
name|ahc_init
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|)
block|{
name|int
name|max_targ
init|=
literal|15
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|term
decl_stmt|;
name|u_int
name|scsi_conf
decl_stmt|;
name|u_int
name|scsiseq_template
decl_stmt|;
name|u_int
name|ultraenb
decl_stmt|;
name|u_int
name|discenable
decl_stmt|;
name|u_int
name|tagenable
decl_stmt|;
name|size_t
name|driver_data_size
decl_stmt|;
name|u_int32_t
name|physaddr
decl_stmt|;
ifdef|#
directive|ifdef
name|AHC_PRINT_SRAM
name|printf
argument_list|(
literal|"Scratch Ram:"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0x20
init|;
name|i
operator|<
literal|0x5f
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
operator|(
name|i
operator|%
literal|8
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|i
operator|!=
literal|0
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"\n              "
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|" 0x%x"
argument_list|,
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|ahc
operator|->
name|features
operator|&
name|AHC_MORE_SRAM
operator|)
operator|!=
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0x70
init|;
name|i
operator|<
literal|0x7f
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
operator|(
name|i
operator|%
literal|8
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|i
operator|!=
literal|0
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"\n              "
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|" 0x%x"
argument_list|,
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Assume we have a board at this stage and it has been reset. 	 */
if|if
condition|(
operator|(
name|ahc
operator|->
name|flags
operator|&
name|AHC_USEDEFAULTS
operator|)
operator|!=
literal|0
condition|)
block|{
name|ahc
operator|->
name|our_id
operator|=
name|ahc
operator|->
name|our_id_b
operator|=
literal|7
expr_stmt|;
block|}
comment|/* 	 * Default to allowing initiator operations. 	 */
name|ahc
operator|->
name|flags
operator||=
name|AHC_INITIATORMODE
expr_stmt|;
comment|/* 	 * XXX Would be better to use a per device flag, but PCI and EISA 	 *     devices don't have them yet. 	 */
if|if
condition|(
operator|(
name|AHC_TMODE_ENABLE
operator|&
operator|(
literal|0x01
operator|<<
name|ahc
operator|->
name|unit
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|ahc
operator|->
name|flags
operator||=
name|AHC_TARGETMODE
expr_stmt|;
comment|/* 		 * Although we have space for both the initiator and 		 * target roles on ULTRA2 chips, we currently disable 		 * the initiator role to allow multi-scsi-id target mode 		 * configurations.  We can only respond on the same SCSI 		 * ID as our initiator role if we allow initiator operation. 		 * At some point, we should add a configuration knob to 		 * allow both roles to be loaded. 		 */
name|ahc
operator|->
name|flags
operator|&=
operator|~
name|AHC_INITIATORMODE
expr_stmt|;
block|}
comment|/* DMA tag for mapping buffers into device visible space. */
if|if
condition|(
name|bus_dma_tag_create
argument_list|(
name|ahc
operator|->
name|parent_dmat
argument_list|,
comment|/*alignment*/
literal|1
argument_list|,
comment|/*boundary*/
literal|0
argument_list|,
comment|/*lowaddr*/
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/*highaddr*/
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/*filter*/
name|NULL
argument_list|,
comment|/*filterarg*/
name|NULL
argument_list|,
comment|/*maxsize*/
name|MAXBSIZE
argument_list|,
comment|/*nsegments*/
name|AHC_NSEG
argument_list|,
comment|/*maxsegsz*/
name|AHC_MAXTRANSFER_SIZE
argument_list|,
comment|/*flags*/
name|BUS_DMA_ALLOCNOW
argument_list|,
operator|&
name|ahc
operator|->
name|buffer_dmat
argument_list|)
operator|!=
literal|0
condition|)
block|{
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|ahc
operator|->
name|init_level
operator|++
expr_stmt|;
comment|/* 	 * DMA tag for our command fifos and other data in system memory 	 * the card's sequencer must be able to access.  For initiator 	 * roles, we need to allocate space for the qinfifo, qoutfifo, 	 * and untagged_scb arrays each of which are composed of 256 	 * 1 byte elements.  When providing for the target mode role, 	 * we additionally must provide space for the incoming target 	 * command fifo. 	 */
name|driver_data_size
operator|=
literal|3
operator|*
literal|256
operator|*
sizeof|sizeof
argument_list|(
name|u_int8_t
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ahc
operator|->
name|flags
operator|&
name|AHC_TARGETMODE
operator|)
operator|!=
literal|0
condition|)
name|driver_data_size
operator|+=
name|AHC_TMODE_CMDS
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|target_cmd
argument_list|)
expr_stmt|;
if|if
condition|(
name|bus_dma_tag_create
argument_list|(
name|ahc
operator|->
name|parent_dmat
argument_list|,
comment|/*alignment*/
literal|1
argument_list|,
comment|/*boundary*/
literal|0
argument_list|,
comment|/*lowaddr*/
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/*highaddr*/
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/*filter*/
name|NULL
argument_list|,
comment|/*filterarg*/
name|NULL
argument_list|,
name|driver_data_size
argument_list|,
comment|/*nsegments*/
literal|1
argument_list|,
comment|/*maxsegsz*/
name|BUS_SPACE_MAXSIZE_32BIT
argument_list|,
comment|/*flags*/
literal|0
argument_list|,
operator|&
name|ahc
operator|->
name|shared_data_dmat
argument_list|)
operator|!=
literal|0
condition|)
block|{
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|ahc
operator|->
name|init_level
operator|++
expr_stmt|;
comment|/* Allocation of driver data */
if|if
condition|(
name|bus_dmamem_alloc
argument_list|(
name|ahc
operator|->
name|shared_data_dmat
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|ahc
operator|->
name|qoutfifo
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|,
operator|&
name|ahc
operator|->
name|shared_data_dmamap
argument_list|)
operator|!=
literal|0
condition|)
block|{
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|ahc
operator|->
name|init_level
operator|++
expr_stmt|;
comment|/* And permanently map it in */
name|bus_dmamap_load
argument_list|(
name|ahc
operator|->
name|shared_data_dmat
argument_list|,
name|ahc
operator|->
name|shared_data_dmamap
argument_list|,
name|ahc
operator|->
name|qoutfifo
argument_list|,
name|driver_data_size
argument_list|,
name|ahcdmamapcb
argument_list|,
operator|&
name|ahc
operator|->
name|shared_data_busaddr
argument_list|,
comment|/*flags*/
literal|0
argument_list|)
expr_stmt|;
name|ahc
operator|->
name|init_level
operator|++
expr_stmt|;
comment|/* Allocate SCB data now that buffer_dmat is initialized) */
if|if
condition|(
name|ahc
operator|->
name|scb_data
operator|->
name|maxhscbs
operator|==
literal|0
condition|)
if|if
condition|(
name|ahcinitscbdata
argument_list|(
name|ahc
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|ahc
operator|->
name|qinfifo
operator|=
operator|&
name|ahc
operator|->
name|qoutfifo
index|[
literal|256
index|]
expr_stmt|;
name|ahc
operator|->
name|untagged_scbs
operator|=
operator|&
name|ahc
operator|->
name|qinfifo
index|[
literal|256
index|]
expr_stmt|;
comment|/* There are no untagged SCBs active yet. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
control|)
name|ahc
operator|->
name|untagged_scbs
index|[
name|i
index|]
operator|=
name|SCB_LIST_NULL
expr_stmt|;
comment|/* All of our queues are empty */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
control|)
name|ahc
operator|->
name|qoutfifo
index|[
name|i
index|]
operator|=
name|SCB_LIST_NULL
expr_stmt|;
if|if
condition|(
operator|(
name|ahc
operator|->
name|flags
operator|&
name|AHC_TARGETMODE
operator|)
operator|!=
literal|0
condition|)
block|{
name|ahc
operator|->
name|targetcmds
operator|=
operator|(
expr|struct
name|target_cmd
operator|*
operator|)
operator|&
name|ahc
operator|->
name|untagged_scbs
index|[
literal|256
index|]
expr_stmt|;
comment|/* All target command blocks start out invalid. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|AHC_TMODE_CMDS
condition|;
name|i
operator|++
control|)
name|ahc
operator|->
name|targetcmds
index|[
name|i
index|]
operator|.
name|cmd_valid
operator|=
literal|0
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|KERNEL_TQINPOS
argument_list|,
name|ahc
operator|->
name|tqinfifonext
operator|-
literal|1
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|TQINPOS
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Allocate a tstate to house information for our 	 * initiator presence on the bus as well as the user 	 * data for any target mode initiator. 	 */
if|if
condition|(
name|ahc_alloc_tstate
argument_list|(
name|ahc
argument_list|,
name|ahc
operator|->
name|our_id
argument_list|,
literal|'A'
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"%s: unable to allocate tmode_tstate.  "
literal|"Failing attach\n"
argument_list|,
name|ahc_name
argument_list|(
name|ahc
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|ahc
operator|->
name|features
operator|&
name|AHC_TWIN
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|ahc_alloc_tstate
argument_list|(
name|ahc
argument_list|,
name|ahc
operator|->
name|our_id_b
argument_list|,
literal|'B'
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"%s: unable to allocate tmode_tstate.  "
literal|"Failing attach\n"
argument_list|,
name|ahc_name
argument_list|(
name|ahc
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|printf
argument_list|(
literal|"Twin Channel, A SCSI Id=%d, B SCSI Id=%d, primary %c, "
argument_list|,
name|ahc
operator|->
name|our_id
argument_list|,
name|ahc
operator|->
name|our_id_b
argument_list|,
name|ahc
operator|->
name|flags
operator|&
name|AHC_CHANNEL_B_PRIMARY
condition|?
literal|'B'
else|:
literal|'A'
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|ahc
operator|->
name|features
operator|&
name|AHC_WIDE
operator|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"Wide "
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"Single "
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"Channel %c, SCSI Id=%d, "
argument_list|,
name|ahc
operator|->
name|channel
argument_list|,
name|ahc
operator|->
name|our_id
argument_list|)
expr_stmt|;
block|}
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SEQ_FLAGS
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ahc
operator|->
name|scb_data
operator|->
name|maxhscbs
operator|<
name|AHC_SCB_MAX
condition|)
block|{
name|ahc
operator|->
name|flags
operator||=
name|AHC_PAGESCBS
expr_stmt|;
name|printf
argument_list|(
literal|"%d/%d SCBs\n"
argument_list|,
name|ahc
operator|->
name|scb_data
operator|->
name|maxhscbs
argument_list|,
name|AHC_SCB_MAX
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ahc
operator|->
name|flags
operator|&=
operator|~
name|AHC_PAGESCBS
expr_stmt|;
name|printf
argument_list|(
literal|"%d SCBs\n"
argument_list|,
name|ahc
operator|->
name|scb_data
operator|->
name|maxhscbs
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|AHC_DEBUG
if|if
condition|(
name|ahc_debug
operator|&
name|AHC_SHOWMISC
condition|)
block|{
name|printf
argument_list|(
literal|"%s: hardware scb %d bytes; kernel scb %d bytes; "
literal|"ahc_dma %d bytes\n"
argument_list|,
name|ahc_name
argument_list|(
name|ahc
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|hardware_scb
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|scb
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ahc_dma_seg
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* AHC_DEBUG */
comment|/* Set the SCSI Id, SXFRCTL0, SXFRCTL1, and SIMODE1, for both channels*/
if|if
condition|(
name|ahc
operator|->
name|features
operator|&
name|AHC_TWIN
condition|)
block|{
comment|/* 		 * The device is gated to channel B after a chip reset, 		 * so set those values first 		 */
name|term
operator|=
operator|(
name|ahc
operator|->
name|flags
operator|&
name|AHC_TERM_ENB_B
operator|)
operator|!=
literal|0
condition|?
name|STPWEN
else|:
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|ahc
operator|->
name|features
operator|&
name|AHC_ULTRA2
operator|)
operator|!=
literal|0
condition|)
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCSIID_ULTRA2
argument_list|,
name|ahc
operator|->
name|our_id_b
argument_list|)
expr_stmt|;
else|else
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCSIID
argument_list|,
name|ahc
operator|->
name|our_id_b
argument_list|)
expr_stmt|;
name|scsi_conf
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCSICONF
operator|+
literal|1
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SXFRCTL1
argument_list|,
operator|(
name|scsi_conf
operator|&
operator|(
name|ENSPCHK
operator||
name|STIMESEL
operator|)
operator|)
operator||
name|term
operator||
name|ENSTIMER
operator||
name|ACTNEGEN
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SIMODE1
argument_list|,
name|ENSELTIMO
operator||
name|ENSCSIRST
operator||
name|ENSCSIPERR
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SXFRCTL0
argument_list|,
name|DFON
operator||
name|SPIOEN
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|scsi_conf
operator|&
name|RESET_SCSI
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|ahc
operator|->
name|flags
operator|&
name|AHC_INITIATORMODE
operator|)
operator|!=
literal|0
condition|)
name|ahc
operator|->
name|flags
operator||=
name|AHC_RESET_BUS_B
expr_stmt|;
comment|/* Select Channel A */
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SBLKCTL
argument_list|,
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SBLKCTL
argument_list|)
operator|&
operator|~
name|SELBUSB
argument_list|)
expr_stmt|;
block|}
name|term
operator|=
operator|(
name|ahc
operator|->
name|flags
operator|&
name|AHC_TERM_ENB_A
operator|)
operator|!=
literal|0
condition|?
name|STPWEN
else|:
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|ahc
operator|->
name|features
operator|&
name|AHC_ULTRA2
operator|)
operator|!=
literal|0
condition|)
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCSIID_ULTRA2
argument_list|,
name|ahc
operator|->
name|our_id
argument_list|)
expr_stmt|;
else|else
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCSIID
argument_list|,
name|ahc
operator|->
name|our_id
argument_list|)
expr_stmt|;
name|scsi_conf
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCSICONF
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SXFRCTL1
argument_list|,
operator|(
name|scsi_conf
operator|&
operator|(
name|ENSPCHK
operator||
name|STIMESEL
operator|)
operator|)
operator||
name|term
operator||
name|ENSTIMER
operator||
name|ACTNEGEN
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SIMODE1
argument_list|,
name|ENSELTIMO
operator||
name|ENSCSIRST
operator||
name|ENSCSIPERR
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SXFRCTL0
argument_list|,
name|DFON
operator||
name|SPIOEN
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|scsi_conf
operator|&
name|RESET_SCSI
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|ahc
operator|->
name|flags
operator|&
name|AHC_INITIATORMODE
operator|)
operator|!=
literal|0
condition|)
name|ahc
operator|->
name|flags
operator||=
name|AHC_RESET_BUS_A
expr_stmt|;
comment|/* 	 * Look at the information that board initialization or 	 * the board bios has left us.  In the lower four bits of each 	 * target's scratch space any value other than 0 indicates 	 * that we should initiate synchronous transfers.  If it's zero, 	 * the user or the BIOS has decided to disable synchronous 	 * negotiation to that target so we don't activate the needsdtr 	 * flag. 	 */
name|ultraenb
operator|=
literal|0
expr_stmt|;
name|tagenable
operator|=
name|ALL_TARGETS_MASK
expr_stmt|;
comment|/* Grab the disconnection disable table and invert it for our needs */
if|if
condition|(
name|ahc
operator|->
name|flags
operator|&
name|AHC_USEDEFAULTS
condition|)
block|{
name|printf
argument_list|(
literal|"%s: Host Adapter Bios disabled.  Using default SCSI "
literal|"device parameters\n"
argument_list|,
name|ahc_name
argument_list|(
name|ahc
argument_list|)
argument_list|)
expr_stmt|;
name|ahc
operator|->
name|flags
operator||=
name|AHC_EXTENDED_TRANS_A
operator||
name|AHC_EXTENDED_TRANS_B
operator||
name|AHC_TERM_ENB_A
operator||
name|AHC_TERM_ENB_B
expr_stmt|;
name|discenable
operator|=
name|ALL_TARGETS_MASK
expr_stmt|;
if|if
condition|(
operator|(
name|ahc
operator|->
name|features
operator|&
name|AHC_ULTRA
operator|)
operator|!=
literal|0
condition|)
name|ultraenb
operator|=
name|ALL_TARGETS_MASK
expr_stmt|;
block|}
else|else
block|{
name|discenable
operator|=
operator|~
operator|(
operator|(
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|DISC_DSB
operator|+
literal|1
argument_list|)
operator|<<
literal|8
operator|)
operator||
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|DISC_DSB
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|ahc
operator|->
name|features
operator|&
operator|(
name|AHC_ULTRA
operator||
name|AHC_ULTRA2
operator|)
operator|)
operator|!=
literal|0
condition|)
name|ultraenb
operator|=
operator|(
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|ULTRA_ENB
operator|+
literal|1
argument_list|)
operator|<<
literal|8
operator|)
operator||
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|ULTRA_ENB
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|ahc
operator|->
name|features
operator|&
operator|(
name|AHC_WIDE
operator||
name|AHC_TWIN
operator|)
operator|)
operator|==
literal|0
condition|)
name|max_targ
operator|=
literal|7
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|max_targ
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|ahc_initiator_tinfo
modifier|*
name|tinfo
decl_stmt|;
name|struct
name|tmode_tstate
modifier|*
name|tstate
decl_stmt|;
name|u_int
name|our_id
decl_stmt|;
name|u_int
name|target_id
decl_stmt|;
name|char
name|channel
decl_stmt|;
name|channel
operator|=
literal|'A'
expr_stmt|;
name|our_id
operator|=
name|ahc
operator|->
name|our_id
expr_stmt|;
name|target_id
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|7
operator|&&
operator|(
name|ahc
operator|->
name|features
operator|&
name|AHC_TWIN
operator|)
operator|!=
literal|0
condition|)
block|{
name|channel
operator|=
literal|'B'
expr_stmt|;
name|our_id
operator|=
name|ahc
operator|->
name|our_id_b
expr_stmt|;
name|target_id
operator|=
name|i
operator|%
literal|8
expr_stmt|;
block|}
name|tinfo
operator|=
name|ahc_fetch_transinfo
argument_list|(
name|ahc
argument_list|,
name|channel
argument_list|,
name|our_id
argument_list|,
name|target_id
argument_list|,
operator|&
name|tstate
argument_list|)
expr_stmt|;
comment|/* Default to async narrow across the board */
name|bzero
argument_list|(
name|tinfo
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|tinfo
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ahc
operator|->
name|flags
operator|&
name|AHC_USEDEFAULTS
condition|)
block|{
if|if
condition|(
operator|(
name|ahc
operator|->
name|features
operator|&
name|AHC_WIDE
operator|)
operator|!=
literal|0
condition|)
name|tinfo
operator|->
name|user
operator|.
name|width
operator|=
name|MSG_EXT_WDTR_BUS_16_BIT
expr_stmt|;
comment|/* 			 * These will be truncated when we determine the 			 * connection type we have with the target. 			 */
name|tinfo
operator|->
name|user
operator|.
name|period
operator|=
name|ahc_syncrates
operator|->
name|period
expr_stmt|;
name|tinfo
operator|->
name|user
operator|.
name|offset
operator|=
operator|~
literal|0
expr_stmt|;
block|}
else|else
block|{
name|u_int
name|scsirate
decl_stmt|;
name|u_int16_t
name|mask
decl_stmt|;
comment|/* Take the settings leftover in scratch RAM. */
name|scsirate
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|TARG_SCSIRATE
operator|+
name|i
argument_list|)
expr_stmt|;
name|mask
operator|=
operator|(
literal|0x01
operator|<<
name|i
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|ahc
operator|->
name|features
operator|&
name|AHC_ULTRA2
operator|)
operator|!=
literal|0
condition|)
block|{
name|u_int
name|offset
decl_stmt|;
if|if
condition|(
operator|(
name|scsirate
operator|&
name|SOFS
operator|)
operator|==
literal|0x0F
condition|)
block|{
comment|/* 					 * Haven't negotiated yet, 					 * so the format is different. 					 */
name|scsirate
operator|=
operator|(
name|scsirate
operator|&
name|SXFR
operator|)
operator|>>
literal|4
operator||
operator|(
name|ultraenb
operator|&
name|mask
operator|)
condition|?
literal|0x18
else|:
literal|0x10
operator||
operator|(
name|scsirate
operator|&
name|WIDEXFER
operator|)
expr_stmt|;
name|offset
operator|=
name|MAX_OFFSET_ULTRA2
expr_stmt|;
block|}
else|else
name|offset
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|TARG_OFFSET
operator|+
name|i
argument_list|)
expr_stmt|;
name|tinfo
operator|->
name|user
operator|.
name|period
operator|=
name|ahc_find_period
argument_list|(
name|ahc
argument_list|,
name|scsirate
argument_list|,
name|AHC_SYNCRATE_ULTRA2
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
operator|==
literal|0
condition|)
name|tinfo
operator|->
name|user
operator|.
name|period
operator|=
literal|0
expr_stmt|;
else|else
name|tinfo
operator|->
name|user
operator|.
name|offset
operator|=
operator|~
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|scsirate
operator|&
name|SOFS
operator|)
operator|!=
literal|0
condition|)
block|{
name|tinfo
operator|->
name|user
operator|.
name|period
operator|=
name|ahc_find_period
argument_list|(
name|ahc
argument_list|,
name|scsirate
argument_list|,
operator|(
name|ultraenb
operator|&
name|mask
operator|)
condition|?
name|AHC_SYNCRATE_ULTRA
else|:
name|AHC_SYNCRATE_FAST
argument_list|)
expr_stmt|;
if|if
condition|(
name|tinfo
operator|->
name|user
operator|.
name|period
operator|!=
literal|0
condition|)
name|tinfo
operator|->
name|user
operator|.
name|offset
operator|=
operator|~
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|scsirate
operator|&
name|WIDEXFER
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|ahc
operator|->
name|features
operator|&
name|AHC_WIDE
operator|)
operator|!=
literal|0
condition|)
name|tinfo
operator|->
name|user
operator|.
name|width
operator|=
name|MSG_EXT_WDTR_BUS_16_BIT
expr_stmt|;
block|}
name|tstate
operator|->
name|ultraenb
operator|=
name|ultraenb
expr_stmt|;
name|tstate
operator|->
name|discenable
operator|=
name|discenable
expr_stmt|;
name|tstate
operator|->
name|tagenable
operator|=
literal|0
expr_stmt|;
comment|/* Wait until the XPT says its okay */
block|}
name|ahc
operator|->
name|user_discenable
operator|=
name|discenable
expr_stmt|;
name|ahc
operator|->
name|user_tagenable
operator|=
name|tagenable
expr_stmt|;
comment|/* 	 * Tell the sequencer where it can find the our arrays in memory. 	 */
name|physaddr
operator|=
name|ahc
operator|->
name|scb_data
operator|->
name|hscb_busaddr
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|HSCB_ADDR
argument_list|,
name|physaddr
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|HSCB_ADDR
operator|+
literal|1
argument_list|,
operator|(
name|physaddr
operator|>>
literal|8
operator|)
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|HSCB_ADDR
operator|+
literal|2
argument_list|,
operator|(
name|physaddr
operator|>>
literal|16
operator|)
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|HSCB_ADDR
operator|+
literal|3
argument_list|,
operator|(
name|physaddr
operator|>>
literal|24
operator|)
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
name|physaddr
operator|=
name|ahc
operator|->
name|shared_data_busaddr
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCBID_ADDR
argument_list|,
name|physaddr
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCBID_ADDR
operator|+
literal|1
argument_list|,
operator|(
name|physaddr
operator|>>
literal|8
operator|)
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCBID_ADDR
operator|+
literal|2
argument_list|,
operator|(
name|physaddr
operator|>>
literal|16
operator|)
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCBID_ADDR
operator|+
literal|3
argument_list|,
operator|(
name|physaddr
operator|>>
literal|24
operator|)
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
comment|/* Target mode incomding command fifo */
name|physaddr
operator|+=
literal|3
operator|*
literal|256
operator|*
sizeof|sizeof
argument_list|(
name|u_int8_t
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|TMODE_CMDADDR
argument_list|,
name|physaddr
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|TMODE_CMDADDR
operator|+
literal|1
argument_list|,
operator|(
name|physaddr
operator|>>
literal|8
operator|)
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|TMODE_CMDADDR
operator|+
literal|2
argument_list|,
operator|(
name|physaddr
operator|>>
literal|16
operator|)
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|TMODE_CMDADDR
operator|+
literal|3
argument_list|,
operator|(
name|physaddr
operator|>>
literal|24
operator|)
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
comment|/* 	 * Initialize the group code to command length table. 	 * This overrides the values in TARG_SCSIRATE, so only 	 * setup the table after we have processed that information. 	 */
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|CMDSIZE_TABLE
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|CMDSIZE_TABLE
operator|+
literal|1
argument_list|,
literal|9
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|CMDSIZE_TABLE
operator|+
literal|2
argument_list|,
literal|9
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|CMDSIZE_TABLE
operator|+
literal|3
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|CMDSIZE_TABLE
operator|+
literal|4
argument_list|,
literal|15
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|CMDSIZE_TABLE
operator|+
literal|5
argument_list|,
literal|11
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|CMDSIZE_TABLE
operator|+
literal|6
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|CMDSIZE_TABLE
operator|+
literal|7
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Tell the sequencer of our initial queue positions */
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|KERNEL_QINPOS
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|QINPOS
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|QOUTPOS
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|AHC_DEBUG
if|if
condition|(
name|ahc_debug
operator|&
name|AHC_SHOWMISC
condition|)
name|printf
argument_list|(
literal|"NEEDSDTR == 0x%x\nNEEDWDTR == 0x%x\n"
literal|"DISCENABLE == 0x%x\nULTRAENB == 0x%x\n"
argument_list|,
name|ahc
operator|->
name|needsdtr_orig
argument_list|,
name|ahc
operator|->
name|needwdtr_orig
argument_list|,
name|discenable
argument_list|,
name|ultraenb
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Don't have any special messages to send to targets */
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|TARGET_MSG_REQUEST
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|TARGET_MSG_REQUEST
operator|+
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Use the built in queue management registers 	 * if they are available. 	 */
if|if
condition|(
operator|(
name|ahc
operator|->
name|features
operator|&
name|AHC_QUEUE_REGS
operator|)
operator|!=
literal|0
condition|)
block|{
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|QOFF_CTLSTA
argument_list|,
name|SCB_QSIZE_256
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SDSCB_QOFF
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SNSCB_QOFF
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|HNSCB_QOFF
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* We don't have any waiting selections */
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|WAITING_SCBH
argument_list|,
name|SCB_LIST_NULL
argument_list|)
expr_stmt|;
comment|/* Our disconnection list is empty too */
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|DISCONNECTED_SCBH
argument_list|,
name|SCB_LIST_NULL
argument_list|)
expr_stmt|;
comment|/* Message out buffer starts empty */
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|MSG_OUT
argument_list|,
name|MSG_NOOP
argument_list|)
expr_stmt|;
comment|/* 	 * Setup the allowed SCSI Sequences based on operational mode. 	 * If we are a target, we'll enalbe select in operations once 	 * we've had a lun enabled. 	 */
name|scsiseq_template
operator|=
name|ENSELO
operator||
name|ENAUTOATNO
operator||
name|ENAUTOATNP
expr_stmt|;
if|if
condition|(
operator|(
name|ahc
operator|->
name|flags
operator|&
name|AHC_INITIATORMODE
operator|)
operator|!=
literal|0
condition|)
name|scsiseq_template
operator||=
name|ENRSELI
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCSISEQ_TEMPLATE
argument_list|,
name|scsiseq_template
argument_list|)
expr_stmt|;
comment|/* 	 * Load the Sequencer program and Enable the adapter 	 * in "fast" mode.          */
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"%s: Downloading Sequencer Program..."
argument_list|,
name|ahc_name
argument_list|(
name|ahc
argument_list|)
argument_list|)
expr_stmt|;
name|ahc_loadseq
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
comment|/* We have to wait until after any system dumps... */
name|EVENTHANDLER_REGISTER
argument_list|(
name|shutdown_final
argument_list|,
name|ahc_shutdown
argument_list|,
name|ahc
argument_list|,
name|SHUTDOWN_PRI_DEFAULT
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|cam_status
name|ahc_find_tmode_devs
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|struct
name|cam_sim
modifier|*
name|sim
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|,
name|struct
name|tmode_tstate
modifier|*
modifier|*
name|tstate
parameter_list|,
name|struct
name|tmode_lstate
modifier|*
modifier|*
name|lstate
parameter_list|,
name|int
name|notfound_failure
parameter_list|)
block|{
name|int
name|our_id
decl_stmt|;
comment|/* 	 * If we are not configured for target mode, someone 	 * is really confused to be sending this to us. 	 */
if|if
condition|(
operator|(
name|ahc
operator|->
name|flags
operator|&
name|AHC_TARGETMODE
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|CAM_REQ_INVALID
operator|)
return|;
comment|/* Range check target and lun */
comment|/* 	 * Handle the 'black hole' device that sucks up 	 * requests to unattached luns on enabled targets. 	 */
if|if
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
operator|==
name|CAM_TARGET_WILDCARD
operator|&&
name|ccb
operator|->
name|ccb_h
operator|.
name|target_lun
operator|==
name|CAM_LUN_WILDCARD
condition|)
block|{
operator|*
name|tstate
operator|=
name|NULL
expr_stmt|;
operator|*
name|lstate
operator|=
name|ahc
operator|->
name|black_hole
expr_stmt|;
block|}
else|else
block|{
name|u_int
name|max_id
decl_stmt|;
if|if
condition|(
name|cam_sim_bus
argument_list|(
name|sim
argument_list|)
operator|==
literal|0
condition|)
name|our_id
operator|=
name|ahc
operator|->
name|our_id
expr_stmt|;
else|else
name|our_id
operator|=
name|ahc
operator|->
name|our_id_b
expr_stmt|;
name|max_id
operator|=
operator|(
name|ahc
operator|->
name|features
operator|&
name|AHC_WIDE
operator|)
condition|?
literal|15
else|:
literal|7
expr_stmt|;
if|if
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
operator|>
name|max_id
condition|)
return|return
operator|(
name|CAM_TID_INVALID
operator|)
return|;
if|if
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|target_lun
operator|>
literal|7
condition|)
return|return
operator|(
name|CAM_LUN_INVALID
operator|)
return|;
if|if
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
operator|!=
name|our_id
condition|)
block|{
if|if
condition|(
operator|(
name|ahc
operator|->
name|features
operator|&
name|AHC_MULTI_TID
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* 				 * Only allow additional targets if 				 * the initiator role is disabled. 				 * The hardware cannot handle a re-select-in 				 * on the initiator id during a re-select-out 				 * on a different target id. 				 */
if|if
condition|(
operator|(
name|ahc
operator|->
name|flags
operator|&
name|AHC_INITIATORMODE
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|CAM_TID_INVALID
operator|)
return|;
block|}
else|else
block|{
comment|/* 				 * Only allow our target id to change 				 * if the initiator role is not configured 				 * and there are no enabled luns which 				 * are attached to the currently registered 				 * scsi id. 				 */
if|if
condition|(
operator|(
name|ahc
operator|->
name|flags
operator|&
name|AHC_INITIATORMODE
operator|)
operator|!=
literal|0
operator|||
name|ahc
operator|->
name|enabled_luns
operator|>
literal|0
condition|)
return|return
operator|(
name|CAM_TID_INVALID
operator|)
return|;
block|}
block|}
operator|*
name|tstate
operator|=
name|ahc
operator|->
name|enabled_targets
index|[
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
index|]
expr_stmt|;
operator|*
name|lstate
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|*
name|tstate
operator|!=
name|NULL
condition|)
operator|*
name|lstate
operator|=
operator|(
operator|*
name|tstate
operator|)
operator|->
name|enabled_luns
index|[
name|ccb
operator|->
name|ccb_h
operator|.
name|target_lun
index|]
expr_stmt|;
block|}
if|if
condition|(
name|notfound_failure
operator|!=
literal|0
operator|&&
operator|*
name|lstate
operator|==
name|NULL
condition|)
return|return
operator|(
name|CAM_PATH_INVALID
operator|)
return|;
return|return
operator|(
name|CAM_REQ_CMP
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ahc_action
parameter_list|(
name|struct
name|cam_sim
modifier|*
name|sim
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
block|{
name|struct
name|ahc_softc
modifier|*
name|ahc
decl_stmt|;
name|struct
name|tmode_lstate
modifier|*
name|lstate
decl_stmt|;
name|u_int
name|target_id
decl_stmt|;
name|u_int
name|our_id
decl_stmt|;
name|int
name|s
decl_stmt|;
name|CAM_DEBUG
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
name|CAM_DEBUG_TRACE
argument_list|,
operator|(
literal|"ahc_action\n"
operator|)
argument_list|)
expr_stmt|;
name|ahc
operator|=
operator|(
expr|struct
name|ahc_softc
operator|*
operator|)
name|cam_sim_softc
argument_list|(
name|sim
argument_list|)
expr_stmt|;
name|target_id
operator|=
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
expr_stmt|;
name|our_id
operator|=
name|SIM_SCSI_ID
argument_list|(
name|ahc
argument_list|,
name|sim
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
condition|)
block|{
comment|/* Common cases first */
case|case
name|XPT_ACCEPT_TARGET_IO
case|:
comment|/* Accept Host Target Mode CDB */
case|case
name|XPT_CONT_TARGET_IO
case|:
comment|/* Continue Host Target I/O Connection*/
block|{
name|struct
name|tmode_tstate
modifier|*
name|tstate
decl_stmt|;
name|cam_status
name|status
decl_stmt|;
name|status
operator|=
name|ahc_find_tmode_devs
argument_list|(
name|ahc
argument_list|,
name|sim
argument_list|,
name|ccb
argument_list|,
operator|&
name|tstate
argument_list|,
operator|&
name|lstate
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
if|if
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|==
name|XPT_CONT_TARGET_IO
condition|)
block|{
comment|/* Response from the black hole device */
name|tstate
operator|=
name|NULL
expr_stmt|;
name|lstate
operator|=
name|ahc
operator|->
name|black_hole
expr_stmt|;
block|}
else|else
block|{
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|status
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|==
name|XPT_ACCEPT_TARGET_IO
condition|)
block|{
name|int
name|s
decl_stmt|;
name|s
operator|=
name|splcam
argument_list|()
expr_stmt|;
name|SLIST_INSERT_HEAD
argument_list|(
operator|&
name|lstate
operator|->
name|accept_tios
argument_list|,
operator|&
name|ccb
operator|->
name|ccb_h
argument_list|,
name|sim_links
operator|.
name|sle
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_INPROG
expr_stmt|;
if|if
condition|(
operator|(
name|ahc
operator|->
name|flags
operator|&
name|AHC_TQINFIFO_BLOCKED
operator|)
operator|!=
literal|0
condition|)
name|ahc_run_tqinfifo
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* 		 * The target_id represents the target we attempt to 		 * select.  In target mode, this is the initiator of 		 * the original command. 		 */
name|our_id
operator|=
name|target_id
expr_stmt|;
name|target_id
operator|=
name|ccb
operator|->
name|csio
operator|.
name|init_id
expr_stmt|;
comment|/* FALLTHROUGH */
block|}
case|case
name|XPT_SCSI_IO
case|:
comment|/* Execute the requested I/O operation */
case|case
name|XPT_RESET_DEV
case|:
comment|/* Bus Device Reset the specified SCSI device */
block|{
name|struct
name|scb
modifier|*
name|scb
decl_stmt|;
name|struct
name|hardware_scb
modifier|*
name|hscb
decl_stmt|;
name|struct
name|ahc_initiator_tinfo
modifier|*
name|tinfo
decl_stmt|;
name|struct
name|tmode_tstate
modifier|*
name|tstate
decl_stmt|;
name|u_int16_t
name|mask
decl_stmt|;
comment|/* 		 * get an scb to use. 		 */
if|if
condition|(
operator|(
name|scb
operator|=
name|ahcgetscb
argument_list|(
name|ahc
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|int
name|s
decl_stmt|;
name|s
operator|=
name|splcam
argument_list|()
expr_stmt|;
name|ahc
operator|->
name|flags
operator||=
name|AHC_RESOURCE_SHORTAGE
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|xpt_freeze_simq
argument_list|(
name|ahc
operator|->
name|sim
argument_list|,
comment|/*count*/
literal|1
argument_list|)
expr_stmt|;
name|ahcsetccbstatus
argument_list|(
name|ccb
argument_list|,
name|CAM_REQUEUE_REQ
argument_list|)
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return;
block|}
name|hscb
operator|=
name|scb
operator|->
name|hscb
expr_stmt|;
name|CAM_DEBUG
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
name|CAM_DEBUG_SUBTRACE
argument_list|,
operator|(
literal|"start scb(%p)\n"
operator|,
name|scb
operator|)
argument_list|)
expr_stmt|;
name|scb
operator|->
name|ccb
operator|=
name|ccb
expr_stmt|;
comment|/* 		 * So we can find the SCB when an abort is requested 		 */
name|ccb
operator|->
name|ccb_h
operator|.
name|ccb_scb_ptr
operator|=
name|scb
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|ccb_ahc_ptr
operator|=
name|ahc
expr_stmt|;
comment|/* 		 * Put all the arguments for the xfer in the scb 		 */
name|hscb
operator|->
name|tcl
operator|=
operator|(
operator|(
name|target_id
operator|<<
literal|4
operator|)
operator|&
literal|0xF0
operator|)
operator||
operator|(
name|SIM_IS_SCSIBUS_B
argument_list|(
name|ahc
argument_list|,
name|sim
argument_list|)
condition|?
name|SELBUSB
else|:
literal|0
operator|)
operator||
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|target_lun
operator|&
literal|0x07
operator|)
expr_stmt|;
name|mask
operator|=
name|SCB_TARGET_MASK
argument_list|(
name|scb
argument_list|)
expr_stmt|;
name|tinfo
operator|=
name|ahc_fetch_transinfo
argument_list|(
name|ahc
argument_list|,
name|SIM_CHANNEL
argument_list|(
name|ahc
argument_list|,
name|sim
argument_list|)
argument_list|,
name|our_id
argument_list|,
name|target_id
argument_list|,
operator|&
name|tstate
argument_list|)
expr_stmt|;
name|hscb
operator|->
name|scsirate
operator|=
name|tinfo
operator|->
name|scsirate
expr_stmt|;
name|hscb
operator|->
name|scsioffset
operator|=
name|tinfo
operator|->
name|current
operator|.
name|offset
expr_stmt|;
if|if
condition|(
operator|(
name|tstate
operator|->
name|ultraenb
operator|&
name|mask
operator|)
operator|!=
literal|0
condition|)
name|hscb
operator|->
name|control
operator||=
name|ULTRAENB
expr_stmt|;
if|if
condition|(
operator|(
name|tstate
operator|->
name|discenable
operator|&
name|mask
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DIS_DISCONNECT
operator|)
operator|==
literal|0
condition|)
name|hscb
operator|->
name|control
operator||=
name|DISCENB
expr_stmt|;
if|if
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|==
name|XPT_RESET_DEV
condition|)
block|{
name|hscb
operator|->
name|cmdpointer
operator|=
name|NULL
expr_stmt|;
name|scb
operator|->
name|flags
operator||=
name|SCB_DEVICE_RESET
expr_stmt|;
name|hscb
operator|->
name|control
operator||=
name|MK_MESSAGE
expr_stmt|;
name|ahc_execute_scb
argument_list|(
name|scb
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|==
name|XPT_CONT_TARGET_IO
condition|)
block|{
if|if
condition|(
name|ahc
operator|->
name|pending_device
operator|==
name|lstate
condition|)
block|{
name|scb
operator|->
name|flags
operator||=
name|SCB_TARGET_IMMEDIATE
expr_stmt|;
name|ahc
operator|->
name|pending_device
operator|=
name|NULL
expr_stmt|;
block|}
name|hscb
operator|->
name|control
operator||=
name|TARGET_SCB
expr_stmt|;
name|hscb
operator|->
name|cmdpointer
operator|=
name|IDENTIFY_SEEN
expr_stmt|;
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_SEND_STATUS
operator|)
operator|!=
literal|0
condition|)
block|{
name|hscb
operator|->
name|cmdpointer
operator||=
name|SPHASE_PENDING
expr_stmt|;
name|hscb
operator|->
name|status
operator|=
name|ccb
operator|->
name|csio
operator|.
name|scsi_status
expr_stmt|;
block|}
comment|/* Overloaded with tag ID */
name|hscb
operator|->
name|cmdlen
operator|=
name|ccb
operator|->
name|csio
operator|.
name|tag_id
expr_stmt|;
comment|/* 				 * Overloaded with the value to place 				 * in SCSIID for reselection. 				 */
name|hscb
operator|->
name|cmdpointer
operator||=
operator|(
name|our_id
operator||
operator|(
name|hscb
operator|->
name|tcl
operator|&
literal|0xF0
operator|)
operator|)
operator|<<
literal|16
expr_stmt|;
block|}
if|if
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_TAG_ACTION_VALID
condition|)
name|hscb
operator|->
name|control
operator||=
name|ccb
operator|->
name|csio
operator|.
name|tag_action
expr_stmt|;
name|ahc_setup_data
argument_list|(
name|ahc
argument_list|,
operator|&
name|ccb
operator|->
name|csio
argument_list|,
name|scb
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|XPT_NOTIFY_ACK
case|:
case|case
name|XPT_IMMED_NOTIFY
case|:
block|{
name|struct
name|tmode_tstate
modifier|*
name|tstate
decl_stmt|;
name|struct
name|tmode_lstate
modifier|*
name|lstate
decl_stmt|;
name|cam_status
name|status
decl_stmt|;
name|status
operator|=
name|ahc_find_tmode_devs
argument_list|(
name|ahc
argument_list|,
name|sim
argument_list|,
name|ccb
argument_list|,
operator|&
name|tstate
argument_list|,
operator|&
name|lstate
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|status
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
block|}
name|SLIST_INSERT_HEAD
argument_list|(
operator|&
name|lstate
operator|->
name|immed_notifies
argument_list|,
operator|&
name|ccb
operator|->
name|ccb_h
argument_list|,
name|sim_links
operator|.
name|sle
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_INPROG
expr_stmt|;
name|ahc_send_lstate_events
argument_list|(
name|ahc
argument_list|,
name|lstate
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|XPT_EN_LUN
case|:
comment|/* Enable LUN as a target */
name|ahc_handle_en_lun
argument_list|(
name|ahc
argument_list|,
name|sim
argument_list|,
name|ccb
argument_list|)
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
case|case
name|XPT_ABORT
case|:
comment|/* Abort the specified CCB */
block|{
name|ahc_abort_ccb
argument_list|(
name|ahc
argument_list|,
name|sim
argument_list|,
name|ccb
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|XPT_SET_TRAN_SETTINGS
case|:
block|{
name|struct
name|ahc_devinfo
name|devinfo
decl_stmt|;
name|struct
name|ccb_trans_settings
modifier|*
name|cts
decl_stmt|;
name|struct
name|ahc_initiator_tinfo
modifier|*
name|tinfo
decl_stmt|;
name|struct
name|tmode_tstate
modifier|*
name|tstate
decl_stmt|;
name|u_int16_t
modifier|*
name|discenable
decl_stmt|;
name|u_int16_t
modifier|*
name|tagenable
decl_stmt|;
name|u_int
name|update_type
decl_stmt|;
name|int
name|s
decl_stmt|;
name|cts
operator|=
operator|&
name|ccb
operator|->
name|cts
expr_stmt|;
name|ahc_compile_devinfo
argument_list|(
operator|&
name|devinfo
argument_list|,
name|SIM_SCSI_ID
argument_list|(
name|ahc
argument_list|,
name|sim
argument_list|)
argument_list|,
name|cts
operator|->
name|ccb_h
operator|.
name|target_id
argument_list|,
name|cts
operator|->
name|ccb_h
operator|.
name|target_lun
argument_list|,
name|SIM_CHANNEL
argument_list|(
name|ahc
argument_list|,
name|sim
argument_list|)
argument_list|,
name|ROLE_UNKNOWN
argument_list|)
expr_stmt|;
name|tinfo
operator|=
name|ahc_fetch_transinfo
argument_list|(
name|ahc
argument_list|,
name|devinfo
operator|.
name|channel
argument_list|,
name|devinfo
operator|.
name|our_scsiid
argument_list|,
name|devinfo
operator|.
name|target
argument_list|,
operator|&
name|tstate
argument_list|)
expr_stmt|;
name|update_type
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|cts
operator|->
name|flags
operator|&
name|CCB_TRANS_CURRENT_SETTINGS
operator|)
operator|!=
literal|0
condition|)
block|{
name|update_type
operator||=
name|AHC_TRANS_GOAL
expr_stmt|;
name|discenable
operator|=
operator|&
name|tstate
operator|->
name|discenable
expr_stmt|;
name|tagenable
operator|=
operator|&
name|tstate
operator|->
name|tagenable
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|cts
operator|->
name|flags
operator|&
name|CCB_TRANS_USER_SETTINGS
operator|)
operator|!=
literal|0
condition|)
block|{
name|update_type
operator||=
name|AHC_TRANS_USER
expr_stmt|;
name|discenable
operator|=
operator|&
name|ahc
operator|->
name|user_discenable
expr_stmt|;
name|tagenable
operator|=
operator|&
name|ahc
operator|->
name|user_tagenable
expr_stmt|;
block|}
else|else
block|{
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_INVALID
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
block|}
name|s
operator|=
name|splcam
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|cts
operator|->
name|valid
operator|&
name|CCB_TRANS_DISC_VALID
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|cts
operator|->
name|flags
operator|&
name|CCB_TRANS_DISC_ENB
operator|)
operator|!=
literal|0
condition|)
operator|*
name|discenable
operator||=
name|devinfo
operator|.
name|target_mask
expr_stmt|;
else|else
operator|*
name|discenable
operator|&=
operator|~
name|devinfo
operator|.
name|target_mask
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|cts
operator|->
name|valid
operator|&
name|CCB_TRANS_TQ_VALID
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|cts
operator|->
name|flags
operator|&
name|CCB_TRANS_TAG_ENB
operator|)
operator|!=
literal|0
condition|)
operator|*
name|tagenable
operator||=
name|devinfo
operator|.
name|target_mask
expr_stmt|;
else|else
operator|*
name|tagenable
operator|&=
operator|~
name|devinfo
operator|.
name|target_mask
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|cts
operator|->
name|valid
operator|&
name|CCB_TRANS_BUS_WIDTH_VALID
operator|)
operator|!=
literal|0
condition|)
block|{
switch|switch
condition|(
name|cts
operator|->
name|bus_width
condition|)
block|{
case|case
name|MSG_EXT_WDTR_BUS_16_BIT
case|:
if|if
condition|(
operator|(
name|ahc
operator|->
name|features
operator|&
name|AHC_WIDE
operator|)
operator|!=
literal|0
condition|)
break|break;
comment|/* FALLTHROUGH to 8bit */
case|case
name|MSG_EXT_WDTR_BUS_32_BIT
case|:
case|case
name|MSG_EXT_WDTR_BUS_8_BIT
case|:
default|default:
name|cts
operator|->
name|bus_width
operator|=
name|MSG_EXT_WDTR_BUS_8_BIT
expr_stmt|;
break|break;
block|}
name|ahc_set_width
argument_list|(
name|ahc
argument_list|,
operator|&
name|devinfo
argument_list|,
name|cts
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
name|cts
operator|->
name|bus_width
argument_list|,
name|update_type
argument_list|,
comment|/*paused*/
name|FALSE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|(
name|cts
operator|->
name|valid
operator|&
name|CCB_TRANS_SYNC_RATE_VALID
operator|)
operator|!=
literal|0
operator|)
operator|||
operator|(
operator|(
name|cts
operator|->
name|valid
operator|&
name|CCB_TRANS_SYNC_OFFSET_VALID
operator|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|struct
name|ahc_syncrate
modifier|*
name|syncrate
decl_stmt|;
name|u_int
name|maxsync
decl_stmt|;
if|if
condition|(
operator|(
name|ahc
operator|->
name|features
operator|&
name|AHC_ULTRA2
operator|)
operator|!=
literal|0
condition|)
name|maxsync
operator|=
name|AHC_SYNCRATE_ULTRA2
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|ahc
operator|->
name|features
operator|&
name|AHC_ULTRA
operator|)
operator|!=
literal|0
condition|)
name|maxsync
operator|=
name|AHC_SYNCRATE_ULTRA
expr_stmt|;
else|else
name|maxsync
operator|=
name|AHC_SYNCRATE_FAST
expr_stmt|;
if|if
condition|(
operator|(
name|cts
operator|->
name|valid
operator|&
name|CCB_TRANS_SYNC_OFFSET_VALID
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|update_type
operator|&
name|AHC_TRANS_USER
condition|)
name|cts
operator|->
name|sync_offset
operator|=
name|tinfo
operator|->
name|user
operator|.
name|offset
expr_stmt|;
else|else
name|cts
operator|->
name|sync_offset
operator|=
name|tinfo
operator|->
name|goal
operator|.
name|offset
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|cts
operator|->
name|valid
operator|&
name|CCB_TRANS_SYNC_RATE_VALID
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|update_type
operator|&
name|AHC_TRANS_USER
condition|)
name|cts
operator|->
name|sync_period
operator|=
name|tinfo
operator|->
name|user
operator|.
name|period
expr_stmt|;
else|else
name|cts
operator|->
name|sync_period
operator|=
name|tinfo
operator|->
name|goal
operator|.
name|period
expr_stmt|;
block|}
name|syncrate
operator|=
name|ahc_find_syncrate
argument_list|(
name|ahc
argument_list|,
operator|&
name|cts
operator|->
name|sync_period
argument_list|,
name|maxsync
argument_list|)
expr_stmt|;
name|ahc_validate_offset
argument_list|(
name|ahc
argument_list|,
name|syncrate
argument_list|,
operator|&
name|cts
operator|->
name|sync_offset
argument_list|,
name|MSG_EXT_WDTR_BUS_8_BIT
argument_list|)
expr_stmt|;
comment|/* We use a period of 0 to represent async */
if|if
condition|(
name|cts
operator|->
name|sync_offset
operator|==
literal|0
condition|)
name|cts
operator|->
name|sync_period
operator|=
literal|0
expr_stmt|;
name|ahc_set_syncrate
argument_list|(
name|ahc
argument_list|,
operator|&
name|devinfo
argument_list|,
name|cts
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
name|syncrate
argument_list|,
name|cts
operator|->
name|sync_period
argument_list|,
name|cts
operator|->
name|sync_offset
argument_list|,
name|update_type
argument_list|,
comment|/*paused*/
name|FALSE
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|XPT_GET_TRAN_SETTINGS
case|:
comment|/* Get default/user set transfer settings for the target */
block|{
name|struct
name|ahc_devinfo
name|devinfo
decl_stmt|;
name|struct
name|ccb_trans_settings
modifier|*
name|cts
decl_stmt|;
name|struct
name|ahc_initiator_tinfo
modifier|*
name|targ_info
decl_stmt|;
name|struct
name|tmode_tstate
modifier|*
name|tstate
decl_stmt|;
name|struct
name|ahc_transinfo
modifier|*
name|tinfo
decl_stmt|;
name|int
name|s
decl_stmt|;
name|cts
operator|=
operator|&
name|ccb
operator|->
name|cts
expr_stmt|;
name|ahc_compile_devinfo
argument_list|(
operator|&
name|devinfo
argument_list|,
name|SIM_SCSI_ID
argument_list|(
name|ahc
argument_list|,
name|sim
argument_list|)
argument_list|,
name|cts
operator|->
name|ccb_h
operator|.
name|target_id
argument_list|,
name|cts
operator|->
name|ccb_h
operator|.
name|target_lun
argument_list|,
name|SIM_CHANNEL
argument_list|(
name|ahc
argument_list|,
name|sim
argument_list|)
argument_list|,
name|ROLE_UNKNOWN
argument_list|)
expr_stmt|;
name|targ_info
operator|=
name|ahc_fetch_transinfo
argument_list|(
name|ahc
argument_list|,
name|devinfo
operator|.
name|channel
argument_list|,
name|devinfo
operator|.
name|our_scsiid
argument_list|,
name|devinfo
operator|.
name|target
argument_list|,
operator|&
name|tstate
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cts
operator|->
name|flags
operator|&
name|CCB_TRANS_CURRENT_SETTINGS
operator|)
operator|!=
literal|0
condition|)
name|tinfo
operator|=
operator|&
name|targ_info
operator|->
name|current
expr_stmt|;
else|else
name|tinfo
operator|=
operator|&
name|targ_info
operator|->
name|user
expr_stmt|;
name|s
operator|=
name|splcam
argument_list|()
expr_stmt|;
name|cts
operator|->
name|flags
operator|&=
operator|~
operator|(
name|CCB_TRANS_DISC_ENB
operator||
name|CCB_TRANS_TAG_ENB
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|cts
operator|->
name|flags
operator|&
name|CCB_TRANS_USER_SETTINGS
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|ahc
operator|->
name|user_discenable
operator|&
name|devinfo
operator|.
name|target_mask
operator|)
operator|!=
literal|0
condition|)
name|cts
operator|->
name|flags
operator||=
name|CCB_TRANS_DISC_ENB
expr_stmt|;
if|if
condition|(
operator|(
name|ahc
operator|->
name|user_tagenable
operator|&
name|devinfo
operator|.
name|target_mask
operator|)
operator|!=
literal|0
condition|)
name|cts
operator|->
name|flags
operator||=
name|CCB_TRANS_TAG_ENB
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|tstate
operator|->
name|discenable
operator|&
name|devinfo
operator|.
name|target_mask
operator|)
operator|!=
literal|0
condition|)
name|cts
operator|->
name|flags
operator||=
name|CCB_TRANS_DISC_ENB
expr_stmt|;
if|if
condition|(
operator|(
name|tstate
operator|->
name|tagenable
operator|&
name|devinfo
operator|.
name|target_mask
operator|)
operator|!=
literal|0
condition|)
name|cts
operator|->
name|flags
operator||=
name|CCB_TRANS_TAG_ENB
expr_stmt|;
block|}
name|cts
operator|->
name|sync_period
operator|=
name|tinfo
operator|->
name|period
expr_stmt|;
name|cts
operator|->
name|sync_offset
operator|=
name|tinfo
operator|->
name|offset
expr_stmt|;
name|cts
operator|->
name|bus_width
operator|=
name|tinfo
operator|->
name|width
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|cts
operator|->
name|valid
operator|=
name|CCB_TRANS_SYNC_RATE_VALID
operator||
name|CCB_TRANS_SYNC_OFFSET_VALID
operator||
name|CCB_TRANS_BUS_WIDTH_VALID
operator||
name|CCB_TRANS_DISC_VALID
operator||
name|CCB_TRANS_TQ_VALID
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|XPT_CALC_GEOMETRY
case|:
block|{
name|struct
name|ccb_calc_geometry
modifier|*
name|ccg
decl_stmt|;
name|u_int32_t
name|size_mb
decl_stmt|;
name|u_int32_t
name|secs_per_cylinder
decl_stmt|;
name|int
name|extended
decl_stmt|;
name|ccg
operator|=
operator|&
name|ccb
operator|->
name|ccg
expr_stmt|;
name|size_mb
operator|=
name|ccg
operator|->
name|volume_size
operator|/
operator|(
operator|(
literal|1024L
operator|*
literal|1024L
operator|)
operator|/
name|ccg
operator|->
name|block_size
operator|)
expr_stmt|;
name|extended
operator|=
name|SIM_IS_SCSIBUS_B
argument_list|(
name|ahc
argument_list|,
name|sim
argument_list|)
condition|?
name|ahc
operator|->
name|flags
operator|&
name|AHC_EXTENDED_TRANS_B
else|:
name|ahc
operator|->
name|flags
operator|&
name|AHC_EXTENDED_TRANS_A
expr_stmt|;
if|if
condition|(
name|size_mb
operator|>
literal|1024
operator|&&
name|extended
condition|)
block|{
name|ccg
operator|->
name|heads
operator|=
literal|255
expr_stmt|;
name|ccg
operator|->
name|secs_per_track
operator|=
literal|63
expr_stmt|;
block|}
else|else
block|{
name|ccg
operator|->
name|heads
operator|=
literal|64
expr_stmt|;
name|ccg
operator|->
name|secs_per_track
operator|=
literal|32
expr_stmt|;
block|}
name|secs_per_cylinder
operator|=
name|ccg
operator|->
name|heads
operator|*
name|ccg
operator|->
name|secs_per_track
expr_stmt|;
name|ccg
operator|->
name|cylinders
operator|=
name|ccg
operator|->
name|volume_size
operator|/
name|secs_per_cylinder
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|XPT_RESET_BUS
case|:
comment|/* Reset the specified SCSI bus */
block|{
name|int
name|found
decl_stmt|;
name|s
operator|=
name|splcam
argument_list|()
expr_stmt|;
name|found
operator|=
name|ahc_reset_channel
argument_list|(
name|ahc
argument_list|,
name|SIM_CHANNEL
argument_list|(
name|ahc
argument_list|,
name|sim
argument_list|)
argument_list|,
comment|/*initiate reset*/
name|TRUE
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
block|{
name|xpt_print_path
argument_list|(
name|SIM_PATH
argument_list|(
name|ahc
argument_list|,
name|sim
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"SCSI bus reset delivered. "
literal|"%d SCBs aborted.\n"
argument_list|,
name|found
argument_list|)
expr_stmt|;
block|}
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|XPT_TERM_IO
case|:
comment|/* Terminate the I/O process */
comment|/* XXX Implement */
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_INVALID
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
case|case
name|XPT_PATH_INQ
case|:
comment|/* Path routing inquiry */
block|{
name|struct
name|ccb_pathinq
modifier|*
name|cpi
init|=
operator|&
name|ccb
operator|->
name|cpi
decl_stmt|;
name|cpi
operator|->
name|version_num
operator|=
literal|1
expr_stmt|;
comment|/* XXX??? */
name|cpi
operator|->
name|hba_inquiry
operator|=
name|PI_SDTR_ABLE
operator||
name|PI_TAG_ABLE
expr_stmt|;
if|if
condition|(
operator|(
name|ahc
operator|->
name|features
operator|&
name|AHC_WIDE
operator|)
operator|!=
literal|0
condition|)
name|cpi
operator|->
name|hba_inquiry
operator||=
name|PI_WIDE_16
expr_stmt|;
if|if
condition|(
operator|(
name|ahc
operator|->
name|flags
operator|&
name|AHC_TARGETMODE
operator|)
operator|!=
literal|0
condition|)
block|{
name|cpi
operator|->
name|target_sprt
operator|=
name|PIT_PROCESSOR
operator||
name|PIT_DISCONNECT
operator||
name|PIT_TERM_IO
expr_stmt|;
block|}
else|else
block|{
name|cpi
operator|->
name|target_sprt
operator|=
literal|0
expr_stmt|;
block|}
name|cpi
operator|->
name|hba_misc
operator|=
operator|(
name|ahc
operator|->
name|flags
operator|&
name|AHC_INITIATORMODE
operator|)
condition|?
literal|0
else|:
name|PIM_NOINITIATOR
expr_stmt|;
name|cpi
operator|->
name|hba_eng_cnt
operator|=
literal|0
expr_stmt|;
name|cpi
operator|->
name|max_target
operator|=
operator|(
name|ahc
operator|->
name|features
operator|&
name|AHC_WIDE
operator|)
condition|?
literal|15
else|:
literal|7
expr_stmt|;
name|cpi
operator|->
name|max_lun
operator|=
literal|7
expr_stmt|;
if|if
condition|(
name|SIM_IS_SCSIBUS_B
argument_list|(
name|ahc
argument_list|,
name|sim
argument_list|)
condition|)
block|{
name|cpi
operator|->
name|initiator_id
operator|=
name|ahc
operator|->
name|our_id_b
expr_stmt|;
if|if
condition|(
operator|(
name|ahc
operator|->
name|flags
operator|&
name|AHC_RESET_BUS_B
operator|)
operator|==
literal|0
condition|)
name|cpi
operator|->
name|hba_misc
operator||=
name|PIM_NOBUSRESET
expr_stmt|;
block|}
else|else
block|{
name|cpi
operator|->
name|initiator_id
operator|=
name|ahc
operator|->
name|our_id
expr_stmt|;
if|if
condition|(
operator|(
name|ahc
operator|->
name|flags
operator|&
name|AHC_RESET_BUS_A
operator|)
operator|==
literal|0
condition|)
name|cpi
operator|->
name|hba_misc
operator||=
name|PIM_NOBUSRESET
expr_stmt|;
block|}
name|cpi
operator|->
name|bus_id
operator|=
name|cam_sim_bus
argument_list|(
name|sim
argument_list|)
expr_stmt|;
name|cpi
operator|->
name|base_transfer_speed
operator|=
literal|3300
expr_stmt|;
name|strncpy
argument_list|(
name|cpi
operator|->
name|sim_vid
argument_list|,
literal|"FreeBSD"
argument_list|,
name|SIM_IDLEN
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|cpi
operator|->
name|hba_vid
argument_list|,
literal|"Adaptec"
argument_list|,
name|HBA_IDLEN
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|cpi
operator|->
name|dev_name
argument_list|,
name|cam_sim_name
argument_list|(
name|sim
argument_list|)
argument_list|,
name|DEV_IDLEN
argument_list|)
expr_stmt|;
name|cpi
operator|->
name|unit_number
operator|=
name|cam_sim_unit
argument_list|(
name|sim
argument_list|)
expr_stmt|;
name|cpi
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_INVALID
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ahc_async
parameter_list|(
name|void
modifier|*
name|callback_arg
parameter_list|,
name|u_int32_t
name|code
parameter_list|,
name|struct
name|cam_path
modifier|*
name|path
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ahc_softc
modifier|*
name|ahc
decl_stmt|;
name|struct
name|cam_sim
modifier|*
name|sim
decl_stmt|;
name|sim
operator|=
operator|(
expr|struct
name|cam_sim
operator|*
operator|)
name|callback_arg
expr_stmt|;
name|ahc
operator|=
operator|(
expr|struct
name|ahc_softc
operator|*
operator|)
name|cam_sim_softc
argument_list|(
name|sim
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|AC_LOST_DEVICE
case|:
block|{
name|struct
name|ahc_devinfo
name|devinfo
decl_stmt|;
name|int
name|s
decl_stmt|;
name|ahc_compile_devinfo
argument_list|(
operator|&
name|devinfo
argument_list|,
name|SIM_SCSI_ID
argument_list|(
name|ahc
argument_list|,
name|sim
argument_list|)
argument_list|,
name|xpt_path_target_id
argument_list|(
name|path
argument_list|)
argument_list|,
name|xpt_path_lun_id
argument_list|(
name|path
argument_list|)
argument_list|,
name|SIM_CHANNEL
argument_list|(
name|ahc
argument_list|,
name|sim
argument_list|)
argument_list|,
name|ROLE_UNKNOWN
argument_list|)
expr_stmt|;
comment|/* 		 * Revert to async/narrow transfers 		 * for the next device. 		 */
name|s
operator|=
name|splcam
argument_list|()
expr_stmt|;
name|ahc_set_width
argument_list|(
name|ahc
argument_list|,
operator|&
name|devinfo
argument_list|,
name|path
argument_list|,
name|MSG_EXT_WDTR_BUS_8_BIT
argument_list|,
name|AHC_TRANS_GOAL
operator||
name|AHC_TRANS_CUR
argument_list|,
comment|/*paused*/
name|FALSE
argument_list|)
expr_stmt|;
name|ahc_set_syncrate
argument_list|(
name|ahc
argument_list|,
operator|&
name|devinfo
argument_list|,
name|path
argument_list|,
comment|/*syncrate*/
name|NULL
argument_list|,
comment|/*period*/
literal|0
argument_list|,
comment|/*offset*/
literal|0
argument_list|,
name|AHC_TRANS_GOAL
operator||
name|AHC_TRANS_CUR
argument_list|,
comment|/*paused*/
name|FALSE
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ahc_execute_scb
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|dm_segs
parameter_list|,
name|int
name|nsegments
parameter_list|,
name|int
name|error
parameter_list|)
block|{
name|struct
name|scb
modifier|*
name|scb
decl_stmt|;
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|struct
name|ahc_softc
modifier|*
name|ahc
decl_stmt|;
name|int
name|s
decl_stmt|;
name|scb
operator|=
operator|(
expr|struct
name|scb
operator|*
operator|)
name|arg
expr_stmt|;
name|ccb
operator|=
name|scb
operator|->
name|ccb
expr_stmt|;
name|ahc
operator|=
operator|(
expr|struct
name|ahc_softc
operator|*
operator|)
name|ccb
operator|->
name|ccb_h
operator|.
name|ccb_ahc_ptr
expr_stmt|;
if|if
condition|(
name|nsegments
operator|!=
literal|0
condition|)
block|{
name|struct
name|ahc_dma_seg
modifier|*
name|sg
decl_stmt|;
name|bus_dma_segment_t
modifier|*
name|end_seg
decl_stmt|;
name|bus_dmasync_op_t
name|op
decl_stmt|;
name|end_seg
operator|=
name|dm_segs
operator|+
name|nsegments
expr_stmt|;
comment|/* Copy the first SG into the data pointer area */
name|scb
operator|->
name|hscb
operator|->
name|SG_pointer
operator|=
name|scb
operator|->
name|sg_list_phys
expr_stmt|;
name|scb
operator|->
name|hscb
operator|->
name|data
operator|=
name|dm_segs
operator|->
name|ds_addr
expr_stmt|;
name|scb
operator|->
name|hscb
operator|->
name|datalen
operator|=
name|dm_segs
operator|->
name|ds_len
expr_stmt|;
name|dm_segs
operator|++
expr_stmt|;
comment|/* Copy the remaining segments into our SG list */
name|sg
operator|=
name|scb
operator|->
name|sg_list
expr_stmt|;
while|while
condition|(
name|dm_segs
operator|<
name|end_seg
condition|)
block|{
name|sg
operator|->
name|addr
operator|=
name|dm_segs
operator|->
name|ds_addr
expr_stmt|;
name|sg
operator|->
name|len
operator|=
name|dm_segs
operator|->
name|ds_len
expr_stmt|;
name|sg
operator|++
expr_stmt|;
name|dm_segs
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DIR_MASK
operator|)
operator|==
name|CAM_DIR_IN
condition|)
name|op
operator|=
name|BUS_DMASYNC_PREREAD
expr_stmt|;
else|else
name|op
operator|=
name|BUS_DMASYNC_PREWRITE
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|ahc
operator|->
name|buffer_dmat
argument_list|,
name|scb
operator|->
name|dmamap
argument_list|,
name|op
argument_list|)
expr_stmt|;
if|if
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|==
name|XPT_CONT_TARGET_IO
condition|)
block|{
name|scb
operator|->
name|hscb
operator|->
name|cmdpointer
operator||=
name|DPHASE_PENDING
expr_stmt|;
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DIR_MASK
operator|)
operator|==
name|CAM_DIR_IN
condition|)
name|scb
operator|->
name|hscb
operator|->
name|cmdpointer
operator||=
operator|(
name|TARGET_DATA_IN
operator|<<
literal|8
operator|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|scb
operator|->
name|hscb
operator|->
name|SG_pointer
operator|=
literal|0
expr_stmt|;
name|scb
operator|->
name|hscb
operator|->
name|data
operator|=
literal|0
expr_stmt|;
name|scb
operator|->
name|hscb
operator|->
name|datalen
operator|=
literal|0
expr_stmt|;
block|}
name|scb
operator|->
name|sg_count
operator|=
name|scb
operator|->
name|hscb
operator|->
name|SG_count
operator|=
name|nsegments
expr_stmt|;
name|s
operator|=
name|splcam
argument_list|()
expr_stmt|;
comment|/* 	 * Last time we need to check if this SCB needs to 	 * be aborted. 	 */
if|if
condition|(
name|ahc_ccb_status
argument_list|(
name|ccb
argument_list|)
operator|!=
name|CAM_REQ_INPROG
condition|)
block|{
if|if
condition|(
name|nsegments
operator|!=
literal|0
condition|)
name|bus_dmamap_unload
argument_list|(
name|ahc
operator|->
name|buffer_dmat
argument_list|,
name|scb
operator|->
name|dmamap
argument_list|)
expr_stmt|;
name|ahcfreescb
argument_list|(
name|ahc
argument_list|,
name|scb
argument_list|)
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Busy this tcl if we are untagged */
if|if
condition|(
operator|(
name|scb
operator|->
name|hscb
operator|->
name|control
operator|&
name|TAG_ENB
operator|)
operator|==
literal|0
condition|)
name|ahc_busy_tcl
argument_list|(
name|ahc
argument_list|,
name|scb
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|ahc
operator|->
name|pending_ccbs
argument_list|,
operator|&
name|ccb
operator|->
name|ccb_h
argument_list|,
name|sim_links
operator|.
name|le
argument_list|)
expr_stmt|;
name|scb
operator|->
name|flags
operator||=
name|SCB_ACTIVE
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_SIM_QUEUED
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|timeout_ch
operator|=
name|timeout
argument_list|(
name|ahc_timeout
argument_list|,
operator|(
name|caddr_t
operator|)
name|scb
argument_list|,
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|timeout
operator|*
name|hz
operator|)
operator|/
literal|1000
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|scb
operator|->
name|flags
operator|&
name|SCB_TARGET_IMMEDIATE
operator|)
operator|!=
literal|0
condition|)
block|{
if|#
directive|if
literal|0
block|printf("Continueing Immediate Command %d:%d\n", 		       ccb->ccb_h.target_id, ccb->ccb_h.target_lun);
endif|#
directive|endif
name|pause_sequencer
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ahc
operator|->
name|flags
operator|&
name|AHC_PAGESCBS
operator|)
operator|==
literal|0
condition|)
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCBPTR
argument_list|,
name|scb
operator|->
name|hscb
operator|->
name|tag
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCB_TAG
argument_list|,
name|scb
operator|->
name|hscb
operator|->
name|tag
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|RETURN_1
argument_list|,
name|CONT_MSG_LOOP
argument_list|)
expr_stmt|;
name|unpause_sequencer
argument_list|(
name|ahc
argument_list|,
comment|/*unpause_always*/
name|FALSE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ahc
operator|->
name|qinfifo
index|[
name|ahc
operator|->
name|qinfifonext
operator|++
index|]
operator|=
name|scb
operator|->
name|hscb
operator|->
name|tag
expr_stmt|;
if|if
condition|(
operator|(
name|ahc
operator|->
name|features
operator|&
name|AHC_QUEUE_REGS
operator|)
operator|!=
literal|0
condition|)
block|{
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|HNSCB_QOFF
argument_list|,
name|ahc
operator|->
name|qinfifonext
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pause_sequencer
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|KERNEL_QINPOS
argument_list|,
name|ahc
operator|->
name|qinfifonext
argument_list|)
expr_stmt|;
name|unpause_sequencer
argument_list|(
name|ahc
argument_list|,
comment|/*unpause_always*/
name|FALSE
argument_list|)
expr_stmt|;
block|}
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ahc_poll
parameter_list|(
name|struct
name|cam_sim
modifier|*
name|sim
parameter_list|)
block|{
name|ahc_intr
argument_list|(
name|cam_sim_softc
argument_list|(
name|sim
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ahc_setup_data
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|struct
name|ccb_scsiio
modifier|*
name|csio
parameter_list|,
name|struct
name|scb
modifier|*
name|scb
parameter_list|)
block|{
name|struct
name|hardware_scb
modifier|*
name|hscb
decl_stmt|;
name|struct
name|ccb_hdr
modifier|*
name|ccb_h
decl_stmt|;
name|hscb
operator|=
name|scb
operator|->
name|hscb
expr_stmt|;
name|ccb_h
operator|=
operator|&
name|csio
operator|->
name|ccb_h
expr_stmt|;
if|if
condition|(
name|ccb_h
operator|->
name|func_code
operator|==
name|XPT_SCSI_IO
condition|)
block|{
name|hscb
operator|->
name|cmdlen
operator|=
name|csio
operator|->
name|cdb_len
expr_stmt|;
if|if
condition|(
operator|(
name|ccb_h
operator|->
name|flags
operator|&
name|CAM_CDB_POINTER
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|ccb_h
operator|->
name|flags
operator|&
name|CAM_CDB_PHYS
operator|)
operator|==
literal|0
condition|)
if|if
condition|(
name|hscb
operator|->
name|cmdlen
operator|<=
literal|16
condition|)
block|{
name|memcpy
argument_list|(
name|hscb
operator|->
name|cmdstore
argument_list|,
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_ptr
argument_list|,
name|hscb
operator|->
name|cmdlen
argument_list|)
expr_stmt|;
name|hscb
operator|->
name|cmdpointer
operator|=
name|hscb
operator|->
name|cmdstore_busaddr
expr_stmt|;
block|}
else|else
block|{
name|ahcsetccbstatus
argument_list|(
name|scb
operator|->
name|ccb
argument_list|,
name|CAM_REQ_INVALID
argument_list|)
expr_stmt|;
name|xpt_done
argument_list|(
name|scb
operator|->
name|ccb
argument_list|)
expr_stmt|;
name|ahcfreescb
argument_list|(
name|ahc
argument_list|,
name|scb
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
name|hscb
operator|->
name|cmdpointer
operator|=
operator|(
operator|(
name|intptr_t
operator|)
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_ptr
operator|)
operator|&
literal|0xffffffff
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * CCB CDB Data Storage area is only 16 bytes 			 * so no additional testing is required 			 */
name|memcpy
argument_list|(
name|hscb
operator|->
name|cmdstore
argument_list|,
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
argument_list|,
name|hscb
operator|->
name|cmdlen
argument_list|)
expr_stmt|;
name|hscb
operator|->
name|cmdpointer
operator|=
name|hscb
operator|->
name|cmdstore_busaddr
expr_stmt|;
block|}
block|}
comment|/* Only use S/G if there is a transfer */
if|if
condition|(
operator|(
name|ccb_h
operator|->
name|flags
operator|&
name|CAM_DIR_MASK
operator|)
operator|!=
name|CAM_DIR_NONE
condition|)
block|{
if|if
condition|(
operator|(
name|ccb_h
operator|->
name|flags
operator|&
name|CAM_SCATTER_VALID
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* We've been given a pointer to a single buffer */
if|if
condition|(
operator|(
name|ccb_h
operator|->
name|flags
operator|&
name|CAM_DATA_PHYS
operator|)
operator|==
literal|0
condition|)
block|{
name|int
name|s
decl_stmt|;
name|int
name|error
decl_stmt|;
name|s
operator|=
name|splsoftvm
argument_list|()
expr_stmt|;
name|error
operator|=
name|bus_dmamap_load
argument_list|(
name|ahc
operator|->
name|buffer_dmat
argument_list|,
name|scb
operator|->
name|dmamap
argument_list|,
name|csio
operator|->
name|data_ptr
argument_list|,
name|csio
operator|->
name|dxfer_len
argument_list|,
name|ahc_execute_scb
argument_list|,
name|scb
argument_list|,
comment|/*flags*/
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|EINPROGRESS
condition|)
block|{
comment|/* 					 * So as to maintain ordering, 					 * freeze the controller queue 					 * until our mapping is 					 * returned. 					 */
name|xpt_freeze_simq
argument_list|(
name|ahc
operator|->
name|sim
argument_list|,
comment|/*count*/
literal|1
argument_list|)
expr_stmt|;
name|scb
operator|->
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_RELEASE_SIMQ
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|struct
name|bus_dma_segment
name|seg
decl_stmt|;
comment|/* Pointer to physical buffer */
if|if
condition|(
name|csio
operator|->
name|dxfer_len
operator|>
name|AHC_MAXTRANSFER_SIZE
condition|)
name|panic
argument_list|(
literal|"ahc_setup_data - Transfer size "
literal|"larger than can device max"
argument_list|)
expr_stmt|;
name|seg
operator|.
name|ds_addr
operator|=
operator|(
name|bus_addr_t
operator|)
name|csio
operator|->
name|data_ptr
expr_stmt|;
name|seg
operator|.
name|ds_len
operator|=
name|csio
operator|->
name|dxfer_len
expr_stmt|;
name|ahc_execute_scb
argument_list|(
name|scb
argument_list|,
operator|&
name|seg
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|struct
name|bus_dma_segment
modifier|*
name|segs
decl_stmt|;
if|if
condition|(
operator|(
name|ccb_h
operator|->
name|flags
operator|&
name|CAM_DATA_PHYS
operator|)
operator|!=
literal|0
condition|)
name|panic
argument_list|(
literal|"ahc_setup_data - Physical segment "
literal|"pointers unsupported"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ccb_h
operator|->
name|flags
operator|&
name|CAM_SG_LIST_PHYS
operator|)
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"ahc_setup_data - Virtual segment "
literal|"addresses unsupported"
argument_list|)
expr_stmt|;
comment|/* Just use the segments provided */
name|segs
operator|=
operator|(
expr|struct
name|bus_dma_segment
operator|*
operator|)
name|csio
operator|->
name|data_ptr
expr_stmt|;
name|ahc_execute_scb
argument_list|(
name|scb
argument_list|,
name|segs
argument_list|,
name|csio
operator|->
name|sglist_cnt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|ahc_execute_scb
argument_list|(
name|scb
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ahc_freeze_devq
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|struct
name|cam_path
modifier|*
name|path
parameter_list|)
block|{
name|int
name|target
decl_stmt|;
name|char
name|channel
decl_stmt|;
name|int
name|lun
decl_stmt|;
name|target
operator|=
name|xpt_path_target_id
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|lun
operator|=
name|xpt_path_lun_id
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|channel
operator|=
name|xpt_path_sim
argument_list|(
name|path
argument_list|)
operator|->
name|bus_id
operator|==
literal|0
condition|?
literal|'A'
else|:
literal|'B'
expr_stmt|;
name|ahc_search_qinfifo
argument_list|(
name|ahc
argument_list|,
name|target
argument_list|,
name|channel
argument_list|,
name|lun
argument_list|,
comment|/*tag*/
name|SCB_LIST_NULL
argument_list|,
name|ROLE_UNKNOWN
argument_list|,
name|CAM_REQUEUE_REQ
argument_list|,
name|SEARCH_COMPLETE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ahcallocscbs
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|)
block|{
name|struct
name|scb_data
modifier|*
name|scb_data
decl_stmt|;
name|struct
name|scb
modifier|*
name|next_scb
decl_stmt|;
name|struct
name|sg_map_node
modifier|*
name|sg_map
decl_stmt|;
name|bus_addr_t
name|physaddr
decl_stmt|;
name|struct
name|ahc_dma_seg
modifier|*
name|segs
decl_stmt|;
name|int
name|newcount
decl_stmt|;
name|int
name|i
decl_stmt|;
name|scb_data
operator|=
name|ahc
operator|->
name|scb_data
expr_stmt|;
if|if
condition|(
name|scb_data
operator|->
name|numscbs
operator|>=
name|AHC_SCB_MAX
condition|)
comment|/* Can't allocate any more */
return|return;
name|next_scb
operator|=
operator|&
name|scb_data
operator|->
name|scbarray
index|[
name|scb_data
operator|->
name|numscbs
index|]
expr_stmt|;
name|sg_map
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|sg_map
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|sg_map
operator|==
name|NULL
condition|)
return|return;
comment|/* Allocate S/G space for the next batch of SCBS */
if|if
condition|(
name|bus_dmamem_alloc
argument_list|(
name|scb_data
operator|->
name|sg_dmat
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|sg_map
operator|->
name|sg_vaddr
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|,
operator|&
name|sg_map
operator|->
name|sg_dmamap
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|free
argument_list|(
name|sg_map
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return;
block|}
name|SLIST_INSERT_HEAD
argument_list|(
operator|&
name|scb_data
operator|->
name|sg_maps
argument_list|,
name|sg_map
argument_list|,
name|links
argument_list|)
expr_stmt|;
name|bus_dmamap_load
argument_list|(
name|scb_data
operator|->
name|sg_dmat
argument_list|,
name|sg_map
operator|->
name|sg_dmamap
argument_list|,
name|sg_map
operator|->
name|sg_vaddr
argument_list|,
name|PAGE_SIZE
argument_list|,
name|ahcdmamapcb
argument_list|,
operator|&
name|sg_map
operator|->
name|sg_physaddr
argument_list|,
comment|/*flags*/
literal|0
argument_list|)
expr_stmt|;
name|segs
operator|=
name|sg_map
operator|->
name|sg_vaddr
expr_stmt|;
name|physaddr
operator|=
name|sg_map
operator|->
name|sg_physaddr
expr_stmt|;
name|newcount
operator|=
operator|(
name|PAGE_SIZE
operator|/
operator|(
name|AHC_NSEG
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|ahc_dma_seg
argument_list|)
operator|)
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|scb_data
operator|->
name|numscbs
operator|<
name|AHC_SCB_MAX
operator|&&
name|i
operator|<
name|newcount
condition|;
name|i
operator|++
control|)
block|{
name|int
name|error
decl_stmt|;
name|next_scb
operator|->
name|sg_list
operator|=
name|segs
expr_stmt|;
name|next_scb
operator|->
name|sg_list_phys
operator|=
name|physaddr
expr_stmt|;
name|next_scb
operator|->
name|flags
operator|=
name|SCB_FREE
expr_stmt|;
name|error
operator|=
name|bus_dmamap_create
argument_list|(
name|ahc
operator|->
name|buffer_dmat
argument_list|,
comment|/*flags*/
literal|0
argument_list|,
operator|&
name|next_scb
operator|->
name|dmamap
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
break|break;
name|next_scb
operator|->
name|hscb
operator|=
operator|&
name|scb_data
operator|->
name|hscbs
index|[
name|scb_data
operator|->
name|numscbs
index|]
expr_stmt|;
name|next_scb
operator|->
name|hscb
operator|->
name|tag
operator|=
name|ahc
operator|->
name|scb_data
operator|->
name|numscbs
expr_stmt|;
name|next_scb
operator|->
name|hscb
operator|->
name|cmdstore_busaddr
operator|=
name|ahc_hscb_busaddr
argument_list|(
name|ahc
argument_list|,
name|next_scb
operator|->
name|hscb
operator|->
name|tag
argument_list|)
operator|+
name|offsetof
argument_list|(
expr|struct
name|hardware_scb
argument_list|,
name|cmdstore
argument_list|)
expr_stmt|;
name|SLIST_INSERT_HEAD
argument_list|(
operator|&
name|ahc
operator|->
name|scb_data
operator|->
name|free_scbs
argument_list|,
name|next_scb
argument_list|,
name|links
argument_list|)
expr_stmt|;
name|segs
operator|+=
name|AHC_NSEG
expr_stmt|;
name|physaddr
operator|+=
operator|(
name|AHC_NSEG
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|ahc_dma_seg
argument_list|)
operator|)
expr_stmt|;
name|next_scb
operator|++
expr_stmt|;
name|ahc
operator|->
name|scb_data
operator|->
name|numscbs
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|AHC_DUMP_SEQ
end_ifdef

begin_function
specifier|static
name|void
name|ahc_dumpseq
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|max_prog
decl_stmt|;
if|if
condition|(
operator|(
name|ahc
operator|->
name|chip
operator|&
name|AHC_BUS_MASK
operator|)
operator|<
name|AHC_PCI
condition|)
name|max_prog
operator|=
literal|448
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|ahc
operator|->
name|features
operator|&
name|AHC_ULTRA2
operator|)
operator|!=
literal|0
condition|)
name|max_prog
operator|=
literal|768
expr_stmt|;
else|else
name|max_prog
operator|=
literal|512
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SEQCTL
argument_list|,
name|PERRORDIS
operator||
name|FAILDIS
operator||
name|FASTMODE
operator||
name|LOADRAM
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SEQADDR0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SEQADDR1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|max_prog
condition|;
name|i
operator|++
control|)
block|{
name|u_int8_t
name|ins_bytes
index|[
literal|4
index|]
decl_stmt|;
name|ahc_insb
argument_list|(
name|ahc
argument_list|,
name|SEQRAM
argument_list|,
name|ins_bytes
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"0x%2.2x%2.2x%2.2x%2.2x\n"
argument_list|,
name|ins_bytes
index|[
literal|0
index|]
argument_list|,
name|ins_bytes
index|[
literal|1
index|]
argument_list|,
name|ins_bytes
index|[
literal|2
index|]
argument_list|,
name|ins_bytes
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|ahc_loadseq
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|)
block|{
name|struct
name|patch
modifier|*
name|cur_patch
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|downloaded
decl_stmt|;
name|int
name|skip_addr
decl_stmt|;
name|u_int8_t
name|download_consts
index|[
literal|4
index|]
decl_stmt|;
comment|/* Setup downloadable constant table */
if|#
directive|if
literal|0
comment|/* No downloaded constants are currently defined. */
block|download_consts[TMODE_NUMCMDS] = ahc->num_targetcmds;
endif|#
directive|endif
name|cur_patch
operator|=
name|patches
expr_stmt|;
name|downloaded
operator|=
literal|0
expr_stmt|;
name|skip_addr
operator|=
literal|0
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SEQCTL
argument_list|,
name|PERRORDIS
operator||
name|FAILDIS
operator||
name|FASTMODE
operator||
name|LOADRAM
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SEQADDR0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SEQADDR1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|seqprog
argument_list|)
operator|/
literal|4
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ahc_check_patch
argument_list|(
name|ahc
argument_list|,
operator|&
name|cur_patch
argument_list|,
name|i
argument_list|,
operator|&
name|skip_addr
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* 			 * Don't download this instruction as it 			 * is in a patch that was removed. 			 */
continue|continue;
block|}
name|ahc_download_instr
argument_list|(
name|ahc
argument_list|,
name|i
argument_list|,
name|download_consts
argument_list|)
expr_stmt|;
name|downloaded
operator|++
expr_stmt|;
block|}
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SEQCTL
argument_list|,
name|PERRORDIS
operator||
name|FAILDIS
operator||
name|FASTMODE
argument_list|)
expr_stmt|;
name|restart_sequencer
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|" %d instructions downloaded\n"
argument_list|,
name|downloaded
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|ahc_check_patch
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|struct
name|patch
modifier|*
modifier|*
name|start_patch
parameter_list|,
name|int
name|start_instr
parameter_list|,
name|int
modifier|*
name|skip_addr
parameter_list|)
block|{
name|struct
name|patch
modifier|*
name|cur_patch
decl_stmt|;
name|struct
name|patch
modifier|*
name|last_patch
decl_stmt|;
name|int
name|num_patches
decl_stmt|;
name|num_patches
operator|=
sizeof|sizeof
argument_list|(
name|patches
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|patch
argument_list|)
expr_stmt|;
name|last_patch
operator|=
operator|&
name|patches
index|[
name|num_patches
index|]
expr_stmt|;
name|cur_patch
operator|=
operator|*
name|start_patch
expr_stmt|;
while|while
condition|(
name|cur_patch
operator|<
name|last_patch
operator|&&
name|start_instr
operator|==
name|cur_patch
operator|->
name|begin
condition|)
block|{
if|if
condition|(
name|cur_patch
operator|->
name|patch_func
argument_list|(
name|ahc
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Start rejecting code */
operator|*
name|skip_addr
operator|=
name|start_instr
operator|+
name|cur_patch
operator|->
name|skip_instr
expr_stmt|;
name|cur_patch
operator|+=
name|cur_patch
operator|->
name|skip_patch
expr_stmt|;
block|}
else|else
block|{
comment|/* Accepted this patch.  Advance to the next 			 * one and wait for our intruction pointer to 			 * hit this point. 			 */
name|cur_patch
operator|++
expr_stmt|;
block|}
block|}
operator|*
name|start_patch
operator|=
name|cur_patch
expr_stmt|;
if|if
condition|(
name|start_instr
operator|<
operator|*
name|skip_addr
condition|)
comment|/* Still skipping */
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ahc_download_instr
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|int
name|instrptr
parameter_list|,
name|u_int8_t
modifier|*
name|dconsts
parameter_list|)
block|{
name|union
name|ins_formats
name|instr
decl_stmt|;
name|struct
name|ins_format1
modifier|*
name|fmt1_ins
decl_stmt|;
name|struct
name|ins_format3
modifier|*
name|fmt3_ins
decl_stmt|;
name|u_int
name|opcode
decl_stmt|;
comment|/* Structure copy */
name|instr
operator|=
operator|*
operator|(
expr|union
name|ins_formats
operator|*
operator|)
operator|&
name|seqprog
index|[
name|instrptr
operator|*
literal|4
index|]
expr_stmt|;
name|fmt1_ins
operator|=
operator|&
name|instr
operator|.
name|format1
expr_stmt|;
name|fmt3_ins
operator|=
name|NULL
expr_stmt|;
comment|/* Pull the opcode */
name|opcode
operator|=
name|instr
operator|.
name|format1
operator|.
name|opcode
expr_stmt|;
switch|switch
condition|(
name|opcode
condition|)
block|{
case|case
name|AIC_OP_JMP
case|:
case|case
name|AIC_OP_JC
case|:
case|case
name|AIC_OP_JNC
case|:
case|case
name|AIC_OP_CALL
case|:
case|case
name|AIC_OP_JNE
case|:
case|case
name|AIC_OP_JNZ
case|:
case|case
name|AIC_OP_JE
case|:
case|case
name|AIC_OP_JZ
case|:
block|{
name|struct
name|patch
modifier|*
name|cur_patch
decl_stmt|;
name|int
name|address_offset
decl_stmt|;
name|u_int
name|address
decl_stmt|;
name|int
name|skip_addr
decl_stmt|;
name|int
name|i
decl_stmt|;
name|fmt3_ins
operator|=
operator|&
name|instr
operator|.
name|format3
expr_stmt|;
name|address_offset
operator|=
literal|0
expr_stmt|;
name|address
operator|=
name|fmt3_ins
operator|->
name|address
expr_stmt|;
name|cur_patch
operator|=
name|patches
expr_stmt|;
name|skip_addr
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|address
condition|;
control|)
block|{
name|ahc_check_patch
argument_list|(
name|ahc
argument_list|,
operator|&
name|cur_patch
argument_list|,
name|i
argument_list|,
operator|&
name|skip_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|skip_addr
operator|>
name|i
condition|)
block|{
name|int
name|end_addr
decl_stmt|;
name|end_addr
operator|=
name|MIN
argument_list|(
name|address
argument_list|,
name|skip_addr
argument_list|)
expr_stmt|;
name|address_offset
operator|+=
name|end_addr
operator|-
name|i
expr_stmt|;
name|i
operator|=
name|skip_addr
expr_stmt|;
block|}
else|else
block|{
name|i
operator|++
expr_stmt|;
block|}
block|}
name|address
operator|-=
name|address_offset
expr_stmt|;
name|fmt3_ins
operator|->
name|address
operator|=
name|address
expr_stmt|;
comment|/* FALLTHROUGH */
block|}
case|case
name|AIC_OP_OR
case|:
case|case
name|AIC_OP_AND
case|:
case|case
name|AIC_OP_XOR
case|:
case|case
name|AIC_OP_ADD
case|:
case|case
name|AIC_OP_ADC
case|:
case|case
name|AIC_OP_BMOV
case|:
if|if
condition|(
name|fmt1_ins
operator|->
name|parity
operator|!=
literal|0
condition|)
block|{
name|fmt1_ins
operator|->
name|immediate
operator|=
name|dconsts
index|[
name|fmt1_ins
operator|->
name|immediate
index|]
expr_stmt|;
block|}
name|fmt1_ins
operator|->
name|parity
operator|=
literal|0
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
name|AIC_OP_ROL
case|:
if|if
condition|(
operator|(
name|ahc
operator|->
name|features
operator|&
name|AHC_ULTRA2
operator|)
operator|!=
literal|0
condition|)
block|{
name|int
name|i
decl_stmt|,
name|count
decl_stmt|;
comment|/* Calculate odd parity for the instruction */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|count
operator|=
literal|0
init|;
name|i
operator|<
literal|31
condition|;
name|i
operator|++
control|)
block|{
name|u_int32_t
name|mask
decl_stmt|;
name|mask
operator|=
literal|0x01
operator|<<
name|i
expr_stmt|;
if|if
condition|(
operator|(
name|instr
operator|.
name|integer
operator|&
name|mask
operator|)
operator|!=
literal|0
condition|)
name|count
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|count
operator|&
literal|0x01
operator|)
operator|==
literal|0
condition|)
name|instr
operator|.
name|format1
operator|.
name|parity
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* Compress the instruction for older sequencers */
if|if
condition|(
name|fmt3_ins
operator|!=
name|NULL
condition|)
block|{
name|instr
operator|.
name|integer
operator|=
name|fmt3_ins
operator|->
name|immediate
operator||
operator|(
name|fmt3_ins
operator|->
name|source
operator|<<
literal|8
operator|)
operator||
operator|(
name|fmt3_ins
operator|->
name|address
operator|<<
literal|16
operator|)
operator||
operator|(
name|fmt3_ins
operator|->
name|opcode
operator|<<
literal|25
operator|)
expr_stmt|;
block|}
else|else
block|{
name|instr
operator|.
name|integer
operator|=
name|fmt1_ins
operator|->
name|immediate
operator||
operator|(
name|fmt1_ins
operator|->
name|source
operator|<<
literal|8
operator|)
operator||
operator|(
name|fmt1_ins
operator|->
name|destination
operator|<<
literal|16
operator|)
operator||
operator|(
name|fmt1_ins
operator|->
name|ret
operator|<<
literal|24
operator|)
operator||
operator|(
name|fmt1_ins
operator|->
name|opcode
operator|<<
literal|25
operator|)
expr_stmt|;
block|}
block|}
name|ahc_outsb
argument_list|(
name|ahc
argument_list|,
name|SEQRAM
argument_list|,
name|instr
operator|.
name|bytes
argument_list|,
literal|4
argument_list|)
expr_stmt|;
break|break;
default|default:
name|panic
argument_list|(
literal|"Unknown opcode encountered in seq program"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ahc_set_recoveryscb
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|struct
name|scb
modifier|*
name|scb
parameter_list|)
block|{
if|if
condition|(
operator|(
name|scb
operator|->
name|flags
operator|&
name|SCB_RECOVERY_SCB
operator|)
operator|==
literal|0
condition|)
block|{
name|struct
name|ccb_hdr
modifier|*
name|ccbh
decl_stmt|;
name|scb
operator|->
name|flags
operator||=
name|SCB_RECOVERY_SCB
expr_stmt|;
comment|/* 		 * Take all queued, but not sent SCBs out of the equation. 		 * Also ensure that no new CCBs are queued to us while we 		 * try to fix this problem. 		 */
if|if
condition|(
operator|(
name|scb
operator|->
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_RELEASE_SIMQ
operator|)
operator|==
literal|0
condition|)
block|{
name|xpt_freeze_simq
argument_list|(
name|ahc
operator|->
name|sim
argument_list|,
comment|/*count*/
literal|1
argument_list|)
expr_stmt|;
name|scb
operator|->
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_RELEASE_SIMQ
expr_stmt|;
block|}
comment|/* 		 * Go through all of our pending SCBs and remove 		 * any scheduled timeouts for them.  We will reschedule 		 * them after we've successfully fixed this problem. 		 */
name|ccbh
operator|=
name|ahc
operator|->
name|pending_ccbs
operator|.
name|lh_first
expr_stmt|;
while|while
condition|(
name|ccbh
operator|!=
name|NULL
condition|)
block|{
name|struct
name|scb
modifier|*
name|pending_scb
decl_stmt|;
name|pending_scb
operator|=
operator|(
expr|struct
name|scb
operator|*
operator|)
name|ccbh
operator|->
name|ccb_scb_ptr
expr_stmt|;
name|untimeout
argument_list|(
name|ahc_timeout
argument_list|,
name|pending_scb
argument_list|,
name|ccbh
operator|->
name|timeout_ch
argument_list|)
expr_stmt|;
name|ccbh
operator|=
name|ccbh
operator|->
name|sim_links
operator|.
name|le
operator|.
name|le_next
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ahc_timeout
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|scb
modifier|*
name|scb
decl_stmt|;
name|struct
name|ahc_softc
modifier|*
name|ahc
decl_stmt|;
name|int
name|s
decl_stmt|,
name|found
decl_stmt|;
name|u_int
name|bus_state
decl_stmt|;
name|int
name|target
decl_stmt|;
name|int
name|lun
decl_stmt|;
name|char
name|channel
decl_stmt|;
name|scb
operator|=
operator|(
expr|struct
name|scb
operator|*
operator|)
name|arg
expr_stmt|;
name|ahc
operator|=
operator|(
expr|struct
name|ahc_softc
operator|*
operator|)
name|scb
operator|->
name|ccb
operator|->
name|ccb_h
operator|.
name|ccb_ahc_ptr
expr_stmt|;
name|s
operator|=
name|splcam
argument_list|()
expr_stmt|;
comment|/* 	 * Ensure that the card doesn't do anything 	 * behind our back.  Also make sure that we 	 * didn't "just" miss an interrupt that would 	 * affect this timeout. 	 */
do|do
block|{
name|ahc_intr
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
name|pause_sequencer
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|INTSTAT
argument_list|)
operator|&
name|INT_PEND
condition|)
do|;
if|if
condition|(
operator|(
name|scb
operator|->
name|flags
operator|&
name|SCB_ACTIVE
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* Previous timeout took care of me already */
name|printf
argument_list|(
literal|"Timedout SCB handled by another timeout\n"
argument_list|)
expr_stmt|;
name|unpause_sequencer
argument_list|(
name|ahc
argument_list|,
comment|/*unpause_always*/
name|TRUE
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
name|target
operator|=
name|SCB_TARGET
argument_list|(
name|scb
argument_list|)
expr_stmt|;
name|channel
operator|=
name|SCB_CHANNEL
argument_list|(
name|scb
argument_list|)
expr_stmt|;
name|lun
operator|=
name|SCB_LUN
argument_list|(
name|scb
argument_list|)
expr_stmt|;
name|xpt_print_path
argument_list|(
name|scb
operator|->
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"SCB 0x%x - timed out "
argument_list|,
name|scb
operator|->
name|hscb
operator|->
name|tag
argument_list|)
expr_stmt|;
comment|/* 	 * Take a snapshot of the bus state and print out 	 * some information so we can track down driver bugs. 	 */
name|bus_state
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|LASTPHASE
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|bus_state
condition|)
block|{
case|case
name|P_DATAOUT
case|:
name|printf
argument_list|(
literal|"in dataout phase"
argument_list|)
expr_stmt|;
break|break;
case|case
name|P_DATAIN
case|:
name|printf
argument_list|(
literal|"in datain phase"
argument_list|)
expr_stmt|;
break|break;
case|case
name|P_COMMAND
case|:
name|printf
argument_list|(
literal|"in command phase"
argument_list|)
expr_stmt|;
break|break;
case|case
name|P_MESGOUT
case|:
name|printf
argument_list|(
literal|"in message out phase"
argument_list|)
expr_stmt|;
break|break;
case|case
name|P_STATUS
case|:
name|printf
argument_list|(
literal|"in status phase"
argument_list|)
expr_stmt|;
break|break;
case|case
name|P_MESGIN
case|:
name|printf
argument_list|(
literal|"in message in phase"
argument_list|)
expr_stmt|;
break|break;
case|case
name|P_BUSFREE
case|:
name|printf
argument_list|(
literal|"while idle, LASTPHASE == 0x%x"
argument_list|,
name|bus_state
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/*  		 * We aren't in a valid phase, so assume we're 		 * idle. 		 */
name|printf
argument_list|(
literal|"invalid phase, LASTPHASE == 0x%x"
argument_list|,
name|bus_state
argument_list|)
expr_stmt|;
name|bus_state
operator|=
name|P_BUSFREE
expr_stmt|;
break|break;
block|}
name|printf
argument_list|(
literal|", SEQADDR == 0x%x\n"
argument_list|,
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SEQADDR0
argument_list|)
operator||
operator|(
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SEQADDR1
argument_list|)
operator|<<
literal|8
operator|)
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|printf(", SCSISIGI == 0x%x\n", ahc_inb(ahc, SCSISIGI)); 	printf("SIMODE1 = 0x%x\n", ahc_inb(ahc, SIMODE1)); 	printf("INTSTAT = 0x%x\n", ahc_inb(ahc, INTSTAT)); 	printf("SSTAT1 == 0x%x\n", ahc_inb(ahc, SSTAT1)); 	printf("SCSIRATE == 0x%x\n", ahc_inb(ahc, SCSIRATE)); 	printf("CCSCBCTL == 0x%x\n", ahc_inb(ahc, CCSCBCTL)); 	printf("CCSCBCNT == 0x%x\n", ahc_inb(ahc, CCSCBCNT)); 	printf("DFCNTRL == 0x%x\n", ahc_inb(ahc, DFCNTRL)); 	printf("DFSTATUS == 0x%x\n", ahc_inb(ahc, DFSTATUS)); 	printf("CCHCNT == 0x%x\n", ahc_inb(ahc, CCHCNT));
endif|#
directive|endif
if|if
condition|(
name|scb
operator|->
name|flags
operator|&
name|SCB_DEVICE_RESET
condition|)
block|{
comment|/* 		 * Been down this road before. 		 * Do a full bus reset. 		 */
name|bus_reset
label|:
name|ahcsetccbstatus
argument_list|(
name|scb
operator|->
name|ccb
argument_list|,
name|CAM_CMD_TIMEOUT
argument_list|)
expr_stmt|;
name|found
operator|=
name|ahc_reset_channel
argument_list|(
name|ahc
argument_list|,
name|channel
argument_list|,
comment|/*Initiate Reset*/
name|TRUE
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s: Issued Channel %c Bus Reset. "
literal|"%d SCBs aborted\n"
argument_list|,
name|ahc_name
argument_list|(
name|ahc
argument_list|)
argument_list|,
name|channel
argument_list|,
name|found
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * If we are a target, transition to bus free and report 		 * the timeout. 		 *  		 * The target/initiator that is holding up the bus may not 		 * be the same as the one that triggered this timeout 		 * (different commands have different timeout lengths). 		 * If the bus is idle and we are actiing as the initiator 		 * for this request, queue a BDR message to the timed out 		 * target.  Otherwise, if the timed out transaction is 		 * active: 		 *   Initiator transaction: 		 *	Stuff the message buffer with a BDR message and assert 		 *	ATN in the hopes that the target will let go of the bus 		 *	and go to the mesgout phase.  If this fails, we'll 		 *	get another timeout 2 seconds later which will attempt 		 *	a bus reset. 		 * 		 *   Target transaction: 		 *	Transition to BUS FREE and report the error. 		 *	It's good to be the target! 		 */
name|u_int
name|active_scb_index
decl_stmt|;
name|active_scb_index
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCB_TAG
argument_list|)
expr_stmt|;
if|if
condition|(
name|bus_state
operator|!=
name|P_BUSFREE
operator|&&
operator|(
name|active_scb_index
operator|<
name|ahc
operator|->
name|scb_data
operator|->
name|numscbs
operator|)
condition|)
block|{
name|struct
name|scb
modifier|*
name|active_scb
decl_stmt|;
comment|/* 			 * If the active SCB is not from our device, 			 * assume that another device is hogging the bus 			 * and wait for it's timeout to expire before 			 * taking additional action. 			 */
name|active_scb
operator|=
operator|&
name|ahc
operator|->
name|scb_data
operator|->
name|scbarray
index|[
name|active_scb_index
index|]
expr_stmt|;
if|if
condition|(
name|active_scb
operator|->
name|hscb
operator|->
name|tcl
operator|!=
name|scb
operator|->
name|hscb
operator|->
name|tcl
operator|&&
operator|(
name|scb
operator|->
name|flags
operator|&
name|SCB_OTHERTCL_TIMEOUT
operator|)
operator|==
literal|0
condition|)
block|{
name|struct
name|ccb_hdr
modifier|*
name|ccbh
decl_stmt|;
name|u_int
name|newtimeout
decl_stmt|;
name|xpt_print_path
argument_list|(
name|scb
operator|->
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Other SCB Timeout\n"
argument_list|)
expr_stmt|;
name|scb
operator|->
name|flags
operator||=
name|SCB_OTHERTCL_TIMEOUT
expr_stmt|;
name|newtimeout
operator|=
name|MAX
argument_list|(
name|active_scb
operator|->
name|ccb
operator|->
name|ccb_h
operator|.
name|timeout
argument_list|,
name|scb
operator|->
name|ccb
operator|->
name|ccb_h
operator|.
name|timeout
argument_list|)
expr_stmt|;
name|ccbh
operator|=
operator|&
name|scb
operator|->
name|ccb
operator|->
name|ccb_h
expr_stmt|;
name|scb
operator|->
name|ccb
operator|->
name|ccb_h
operator|.
name|timeout_ch
operator|=
name|timeout
argument_list|(
name|ahc_timeout
argument_list|,
name|scb
argument_list|,
operator|(
name|newtimeout
operator|*
name|hz
operator|)
operator|/
literal|1000
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* It's us */
if|if
condition|(
operator|(
name|scb
operator|->
name|hscb
operator|->
name|control
operator|&
name|TARGET_SCB
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* 				 * Send back any queued up transactions 				 * and properly record the error condition. 				 */
name|ahc_freeze_devq
argument_list|(
name|ahc
argument_list|,
name|scb
operator|->
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|)
expr_stmt|;
name|ahcsetccbstatus
argument_list|(
name|scb
operator|->
name|ccb
argument_list|,
name|CAM_CMD_TIMEOUT
argument_list|)
expr_stmt|;
name|ahc_freeze_ccb
argument_list|(
name|scb
operator|->
name|ccb
argument_list|)
expr_stmt|;
name|ahc_done
argument_list|(
name|ahc
argument_list|,
name|scb
argument_list|)
expr_stmt|;
comment|/* Will clear us from the bus */
name|restart_sequencer
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
return|return;
block|}
name|ahc_set_recoveryscb
argument_list|(
name|ahc
argument_list|,
name|active_scb
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|MSG_OUT
argument_list|,
name|MSG_BUS_DEV_RESET
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCSISIGO
argument_list|,
name|bus_state
operator||
name|ATNO
argument_list|)
expr_stmt|;
name|xpt_print_path
argument_list|(
name|active_scb
operator|->
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"BDR message in message buffer\n"
argument_list|)
expr_stmt|;
name|active_scb
operator|->
name|flags
operator||=
name|SCB_DEVICE_RESET
expr_stmt|;
name|active_scb
operator|->
name|ccb
operator|->
name|ccb_h
operator|.
name|timeout_ch
operator|=
name|timeout
argument_list|(
name|ahc_timeout
argument_list|,
operator|(
name|caddr_t
operator|)
name|active_scb
argument_list|,
literal|2
operator|*
name|hz
argument_list|)
expr_stmt|;
name|unpause_sequencer
argument_list|(
name|ahc
argument_list|,
comment|/*unpause_always*/
name|FALSE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|disconnected
decl_stmt|;
comment|/* XXX Shouldn't panic.  Just punt instead */
if|if
condition|(
operator|(
name|scb
operator|->
name|hscb
operator|->
name|control
operator|&
name|TARGET_SCB
operator|)
operator|!=
literal|0
condition|)
name|panic
argument_list|(
literal|"Timed-out target SCB but bus idle"
argument_list|)
expr_stmt|;
if|if
condition|(
name|bus_state
operator|!=
name|P_BUSFREE
operator|&&
operator|(
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SSTAT0
argument_list|)
operator|&
name|TARGET
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* XXX What happened to the SCB? */
comment|/* Hung target selection.  Goto busfree */
name|printf
argument_list|(
literal|"%s: Hung target selection\n"
argument_list|,
name|ahc_name
argument_list|(
name|ahc
argument_list|)
argument_list|)
expr_stmt|;
name|restart_sequencer
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|ahc_search_qinfifo
argument_list|(
name|ahc
argument_list|,
name|target
argument_list|,
name|channel
argument_list|,
name|lun
argument_list|,
name|scb
operator|->
name|hscb
operator|->
name|tag
argument_list|,
name|ROLE_INITIATOR
argument_list|,
comment|/*status*/
literal|0
argument_list|,
name|SEARCH_COUNT
argument_list|)
operator|>
literal|0
condition|)
block|{
name|disconnected
operator|=
name|FALSE
expr_stmt|;
block|}
else|else
block|{
name|disconnected
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
name|disconnected
condition|)
block|{
name|ahc_set_recoveryscb
argument_list|(
name|ahc
argument_list|,
name|scb
argument_list|)
expr_stmt|;
comment|/* 				 * Simply set the MK_MESSAGE control bit. 				 */
name|scb
operator|->
name|hscb
operator|->
name|control
operator||=
name|MK_MESSAGE
expr_stmt|;
name|scb
operator|->
name|flags
operator||=
name|SCB_QUEUED_MSG
operator||
name|SCB_DEVICE_RESET
expr_stmt|;
comment|/* 				 * Remove this SCB from the disconnected 				 * list so that a reconnect at this point 				 * causes a BDR or abort. 				 */
name|ahc_search_disc_list
argument_list|(
name|ahc
argument_list|,
name|target
argument_list|,
name|channel
argument_list|,
name|lun
argument_list|,
name|scb
operator|->
name|hscb
operator|->
name|tag
argument_list|)
expr_stmt|;
name|ahc_index_busy_tcl
argument_list|(
name|ahc
argument_list|,
name|scb
operator|->
name|hscb
operator|->
name|tcl
argument_list|,
comment|/*unbusy*/
name|TRUE
argument_list|)
expr_stmt|;
comment|/* 				 * Actually re-queue this SCB in case we can 				 * select the device before it reconnects. 				 * Clear out any entries in the QINFIFO first 				 * so we are the next SCB for this target 				 * to run. 				 */
name|ahc_search_qinfifo
argument_list|(
name|ahc
argument_list|,
name|SCB_TARGET
argument_list|(
name|scb
argument_list|)
argument_list|,
name|channel
argument_list|,
name|SCB_LUN
argument_list|(
name|scb
argument_list|)
argument_list|,
name|SCB_LIST_NULL
argument_list|,
name|CAM_REQUEUE_REQ
argument_list|,
name|ROLE_INITIATOR
argument_list|,
name|SEARCH_COMPLETE
argument_list|)
expr_stmt|;
name|xpt_print_path
argument_list|(
name|scb
operator|->
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Queuing a BDR SCB\n"
argument_list|)
expr_stmt|;
name|ahc
operator|->
name|qinfifo
index|[
name|ahc
operator|->
name|qinfifonext
operator|++
index|]
operator|=
name|scb
operator|->
name|hscb
operator|->
name|tag
expr_stmt|;
if|if
condition|(
operator|(
name|ahc
operator|->
name|features
operator|&
name|AHC_QUEUE_REGS
operator|)
operator|!=
literal|0
condition|)
block|{
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|HNSCB_QOFF
argument_list|,
name|ahc
operator|->
name|qinfifonext
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|KERNEL_QINPOS
argument_list|,
name|ahc
operator|->
name|qinfifonext
argument_list|)
expr_stmt|;
block|}
name|scb
operator|->
name|ccb
operator|->
name|ccb_h
operator|.
name|timeout_ch
operator|=
name|timeout
argument_list|(
name|ahc_timeout
argument_list|,
operator|(
name|caddr_t
operator|)
name|scb
argument_list|,
literal|2
operator|*
name|hz
argument_list|)
expr_stmt|;
name|unpause_sequencer
argument_list|(
name|ahc
argument_list|,
comment|/*unpause_always*/
name|FALSE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Go "immediatly" to the bus reset */
comment|/* This shouldn't happen */
name|ahc_set_recoveryscb
argument_list|(
name|ahc
argument_list|,
name|scb
argument_list|)
expr_stmt|;
name|xpt_print_path
argument_list|(
name|scb
operator|->
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"SCB %d: Immediate reset.  "
literal|"Flags = 0x%x\n"
argument_list|,
name|scb
operator|->
name|hscb
operator|->
name|tag
argument_list|,
name|scb
operator|->
name|flags
argument_list|)
expr_stmt|;
goto|goto
name|bus_reset
goto|;
block|}
block|}
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|ahc_search_qinfifo
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|int
name|target
parameter_list|,
name|char
name|channel
parameter_list|,
name|int
name|lun
parameter_list|,
name|u_int
name|tag
parameter_list|,
name|role_t
name|role
parameter_list|,
name|u_int32_t
name|status
parameter_list|,
name|ahc_search_action
name|action
parameter_list|)
block|{
name|struct
name|scb
modifier|*
name|scbp
decl_stmt|;
name|u_int8_t
name|qinpos
decl_stmt|;
name|u_int8_t
name|qintail
decl_stmt|;
name|int
name|found
decl_stmt|;
name|qinpos
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|QINPOS
argument_list|)
expr_stmt|;
name|qintail
operator|=
name|ahc
operator|->
name|qinfifonext
expr_stmt|;
name|found
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Start with an empty queue.  Entries that are not chosen 	 * for removal will be re-added to the queue as we go. 	 */
name|ahc
operator|->
name|qinfifonext
operator|=
name|qinpos
expr_stmt|;
while|while
condition|(
name|qinpos
operator|!=
name|qintail
condition|)
block|{
name|scbp
operator|=
operator|&
name|ahc
operator|->
name|scb_data
operator|->
name|scbarray
index|[
name|ahc
operator|->
name|qinfifo
index|[
name|qinpos
index|]
index|]
expr_stmt|;
if|if
condition|(
name|ahc_match_scb
argument_list|(
name|scbp
argument_list|,
name|target
argument_list|,
name|channel
argument_list|,
name|lun
argument_list|,
name|tag
argument_list|,
name|role
argument_list|)
condition|)
block|{
comment|/* 			 * We found an scb that needs to be removed. 			 */
switch|switch
condition|(
name|action
condition|)
block|{
case|case
name|SEARCH_COMPLETE
case|:
if|if
condition|(
name|ahc_ccb_status
argument_list|(
name|scbp
operator|->
name|ccb
argument_list|)
operator|==
name|CAM_REQ_INPROG
condition|)
name|ahcsetccbstatus
argument_list|(
name|scbp
operator|->
name|ccb
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|ahc_freeze_ccb
argument_list|(
name|scbp
operator|->
name|ccb
argument_list|)
expr_stmt|;
name|ahc_done
argument_list|(
name|ahc
argument_list|,
name|scbp
argument_list|)
expr_stmt|;
break|break;
case|case
name|SEARCH_COUNT
case|:
name|ahc
operator|->
name|qinfifo
index|[
name|ahc
operator|->
name|qinfifonext
operator|++
index|]
operator|=
name|scbp
operator|->
name|hscb
operator|->
name|tag
expr_stmt|;
break|break;
case|case
name|SEARCH_REMOVE
case|:
break|break;
block|}
name|found
operator|++
expr_stmt|;
block|}
else|else
block|{
name|ahc
operator|->
name|qinfifo
index|[
name|ahc
operator|->
name|qinfifonext
operator|++
index|]
operator|=
name|scbp
operator|->
name|hscb
operator|->
name|tag
expr_stmt|;
block|}
name|qinpos
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|ahc
operator|->
name|features
operator|&
name|AHC_QUEUE_REGS
operator|)
operator|!=
literal|0
condition|)
block|{
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|HNSCB_QOFF
argument_list|,
name|ahc
operator|->
name|qinfifonext
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|KERNEL_QINPOS
argument_list|,
name|ahc
operator|->
name|qinfifonext
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|found
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ahc_abort_ccb
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|struct
name|cam_sim
modifier|*
name|sim
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
block|{
name|union
name|ccb
modifier|*
name|abort_ccb
decl_stmt|;
name|abort_ccb
operator|=
name|ccb
operator|->
name|cab
operator|.
name|abort_ccb
expr_stmt|;
switch|switch
condition|(
name|abort_ccb
operator|->
name|ccb_h
operator|.
name|func_code
condition|)
block|{
case|case
name|XPT_ACCEPT_TARGET_IO
case|:
case|case
name|XPT_IMMED_NOTIFY
case|:
case|case
name|XPT_CONT_TARGET_IO
case|:
block|{
name|struct
name|tmode_tstate
modifier|*
name|tstate
decl_stmt|;
name|struct
name|tmode_lstate
modifier|*
name|lstate
decl_stmt|;
name|struct
name|ccb_hdr_slist
modifier|*
name|list
decl_stmt|;
name|cam_status
name|status
decl_stmt|;
name|status
operator|=
name|ahc_find_tmode_devs
argument_list|(
name|ahc
argument_list|,
name|sim
argument_list|,
name|abort_ccb
argument_list|,
operator|&
name|tstate
argument_list|,
operator|&
name|lstate
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|status
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|abort_ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|==
name|XPT_ACCEPT_TARGET_IO
condition|)
name|list
operator|=
operator|&
name|lstate
operator|->
name|accept_tios
expr_stmt|;
elseif|else
if|if
condition|(
name|abort_ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|==
name|XPT_IMMED_NOTIFY
condition|)
name|list
operator|=
operator|&
name|lstate
operator|->
name|immed_notifies
expr_stmt|;
else|else
name|list
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|list
operator|!=
name|NULL
condition|)
block|{
name|struct
name|ccb_hdr
modifier|*
name|curelm
decl_stmt|;
name|int
name|found
decl_stmt|;
name|curelm
operator|=
name|SLIST_FIRST
argument_list|(
name|list
argument_list|)
expr_stmt|;
name|found
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|curelm
operator|==
operator|&
name|abort_ccb
operator|->
name|ccb_h
condition|)
block|{
name|found
operator|=
literal|1
expr_stmt|;
name|SLIST_REMOVE_HEAD
argument_list|(
name|list
argument_list|,
name|sim_links
operator|.
name|sle
argument_list|)
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
name|curelm
operator|!=
name|NULL
condition|)
block|{
name|struct
name|ccb_hdr
modifier|*
name|nextelm
decl_stmt|;
name|nextelm
operator|=
name|SLIST_NEXT
argument_list|(
name|curelm
argument_list|,
name|sim_links
operator|.
name|sle
argument_list|)
expr_stmt|;
if|if
condition|(
name|nextelm
operator|==
operator|&
name|abort_ccb
operator|->
name|ccb_h
condition|)
block|{
name|found
operator|=
literal|1
expr_stmt|;
name|SLIST_NEXT
argument_list|(
name|curelm
argument_list|,
name|sim_links
operator|.
name|sle
argument_list|)
operator|=
name|SLIST_NEXT
argument_list|(
name|nextelm
argument_list|,
name|sim_links
operator|.
name|sle
argument_list|)
expr_stmt|;
break|break;
block|}
name|curelm
operator|=
name|nextelm
expr_stmt|;
block|}
block|}
if|if
condition|(
name|found
condition|)
block|{
name|abort_ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_ABORTED
expr_stmt|;
name|xpt_done
argument_list|(
name|abort_ccb
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"Not found\n"
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_PATH_INVALID
expr_stmt|;
block|}
break|break;
block|}
comment|/* FALLTHROUGH */
block|}
case|case
name|XPT_SCSI_IO
case|:
comment|/* XXX Fully implement the hard ones */
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_UA_ABORT
expr_stmt|;
break|break;
default|default:
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_INVALID
expr_stmt|;
break|break;
block|}
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Abort all SCBs that match the given description (target/channel/lun/tag),  * setting their status to the passed in status if the status has not already  * been modified from CAM_REQ_INPROG.  This routine assumes that the sequencer  * is paused before it is called.  */
end_comment

begin_function
specifier|static
name|int
name|ahc_abort_scbs
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|int
name|target
parameter_list|,
name|char
name|channel
parameter_list|,
name|int
name|lun
parameter_list|,
name|u_int
name|tag
parameter_list|,
name|role_t
name|role
parameter_list|,
name|u_int32_t
name|status
parameter_list|)
block|{
name|struct
name|scb
modifier|*
name|scbp
decl_stmt|;
name|u_int
name|active_scb
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|found
decl_stmt|;
comment|/* restore this when we're done */
name|active_scb
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCBPTR
argument_list|)
expr_stmt|;
name|found
operator|=
name|ahc_search_qinfifo
argument_list|(
name|ahc
argument_list|,
name|target
argument_list|,
name|channel
argument_list|,
name|lun
argument_list|,
name|tag
argument_list|,
name|CAM_REQUEUE_REQ
argument_list|,
name|role
argument_list|,
name|SEARCH_COMPLETE
argument_list|)
expr_stmt|;
comment|/* 	 * Search waiting for selection list. 	 */
block|{
name|u_int8_t
name|next
decl_stmt|,
name|prev
decl_stmt|;
name|next
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|WAITING_SCBH
argument_list|)
expr_stmt|;
comment|/* Start at head of list. */
name|prev
operator|=
name|SCB_LIST_NULL
expr_stmt|;
while|while
condition|(
name|next
operator|!=
name|SCB_LIST_NULL
condition|)
block|{
name|u_int8_t
name|scb_index
decl_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCBPTR
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|scb_index
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCB_TAG
argument_list|)
expr_stmt|;
if|if
condition|(
name|scb_index
operator|>=
name|ahc
operator|->
name|scb_data
operator|->
name|numscbs
condition|)
block|{
name|panic
argument_list|(
literal|"Waiting List inconsistency. "
literal|"SCB index == %d, yet numscbs == %d."
argument_list|,
name|scb_index
argument_list|,
name|ahc
operator|->
name|scb_data
operator|->
name|numscbs
argument_list|)
expr_stmt|;
block|}
name|scbp
operator|=
operator|&
name|ahc
operator|->
name|scb_data
operator|->
name|scbarray
index|[
name|scb_index
index|]
expr_stmt|;
if|if
condition|(
name|ahc_match_scb
argument_list|(
name|scbp
argument_list|,
name|target
argument_list|,
name|channel
argument_list|,
name|lun
argument_list|,
name|tag
argument_list|,
name|role
argument_list|)
condition|)
block|{
name|next
operator|=
name|ahc_abort_wscb
argument_list|(
name|ahc
argument_list|,
name|next
argument_list|,
name|prev
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|prev
operator|=
name|next
expr_stmt|;
name|next
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCB_NEXT
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* 	 * Go through the disconnected list and remove any entries we 	 * have queued for completion, 0'ing their control byte too. 	 */
name|ahc_search_disc_list
argument_list|(
name|ahc
argument_list|,
name|target
argument_list|,
name|channel
argument_list|,
name|lun
argument_list|,
name|tag
argument_list|)
expr_stmt|;
comment|/* 	 * Go through the hardware SCB array looking for commands that 	 * were active but not on any list. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ahc
operator|->
name|scb_data
operator|->
name|maxhscbs
condition|;
name|i
operator|++
control|)
block|{
name|u_int
name|scbid
decl_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCBPTR
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|scbid
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCB_TAG
argument_list|)
expr_stmt|;
if|if
condition|(
name|scbid
operator|<
name|ahc
operator|->
name|scb_data
operator|->
name|numscbs
condition|)
block|{
name|scbp
operator|=
operator|&
name|ahc
operator|->
name|scb_data
operator|->
name|scbarray
index|[
name|scbid
index|]
expr_stmt|;
if|if
condition|(
name|ahc_match_scb
argument_list|(
name|scbp
argument_list|,
name|target
argument_list|,
name|channel
argument_list|,
name|lun
argument_list|,
name|tag
argument_list|,
name|role
argument_list|)
condition|)
block|{
name|ahc_add_curscb_to_free_list
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* 	 * Go through the pending CCB list and look for 	 * commands for this target that are still active. 	 * These are other tagged commands that were 	 * disconnected when the reset occured. 	 */
block|{
name|struct
name|ccb_hdr
modifier|*
name|ccb_h
decl_stmt|;
name|ccb_h
operator|=
name|ahc
operator|->
name|pending_ccbs
operator|.
name|lh_first
expr_stmt|;
while|while
condition|(
name|ccb_h
operator|!=
name|NULL
condition|)
block|{
name|scbp
operator|=
operator|(
expr|struct
name|scb
operator|*
operator|)
name|ccb_h
operator|->
name|ccb_scb_ptr
expr_stmt|;
name|ccb_h
operator|=
name|ccb_h
operator|->
name|sim_links
operator|.
name|le
operator|.
name|le_next
expr_stmt|;
if|if
condition|(
name|ahc_match_scb
argument_list|(
name|scbp
argument_list|,
name|target
argument_list|,
name|channel
argument_list|,
name|lun
argument_list|,
name|tag
argument_list|,
name|role
argument_list|)
condition|)
block|{
if|if
condition|(
name|ahc_ccb_status
argument_list|(
name|scbp
operator|->
name|ccb
argument_list|)
operator|==
name|CAM_REQ_INPROG
condition|)
name|ahcsetccbstatus
argument_list|(
name|scbp
operator|->
name|ccb
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|ahc_freeze_ccb
argument_list|(
name|scbp
operator|->
name|ccb
argument_list|)
expr_stmt|;
name|ahc_done
argument_list|(
name|ahc
argument_list|,
name|scbp
argument_list|)
expr_stmt|;
name|found
operator|++
expr_stmt|;
block|}
block|}
block|}
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCBPTR
argument_list|,
name|active_scb
argument_list|)
expr_stmt|;
return|return
name|found
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ahc_search_disc_list
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|int
name|target
parameter_list|,
name|char
name|channel
parameter_list|,
name|int
name|lun
parameter_list|,
name|u_int
name|tag
parameter_list|)
block|{
name|struct
name|scb
modifier|*
name|scbp
decl_stmt|;
name|u_int
name|next
decl_stmt|;
name|u_int
name|prev
decl_stmt|;
name|u_int
name|count
decl_stmt|;
name|u_int
name|active_scb
decl_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
name|next
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|DISCONNECTED_SCBH
argument_list|)
expr_stmt|;
name|prev
operator|=
name|SCB_LIST_NULL
expr_stmt|;
comment|/* restore this when we're done */
name|active_scb
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCBPTR
argument_list|)
expr_stmt|;
while|while
condition|(
name|next
operator|!=
name|SCB_LIST_NULL
condition|)
block|{
name|u_int
name|scb_index
decl_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCBPTR
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|scb_index
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCB_TAG
argument_list|)
expr_stmt|;
if|if
condition|(
name|scb_index
operator|>=
name|ahc
operator|->
name|scb_data
operator|->
name|numscbs
condition|)
block|{
name|panic
argument_list|(
literal|"Disconnected List inconsistency. "
literal|"SCB index == %d, yet numscbs == %d."
argument_list|,
name|scb_index
argument_list|,
name|ahc
operator|->
name|scb_data
operator|->
name|numscbs
argument_list|)
expr_stmt|;
block|}
name|scbp
operator|=
operator|&
name|ahc
operator|->
name|scb_data
operator|->
name|scbarray
index|[
name|scb_index
index|]
expr_stmt|;
if|if
condition|(
name|ahc_match_scb
argument_list|(
name|scbp
argument_list|,
name|target
argument_list|,
name|channel
argument_list|,
name|lun
argument_list|,
name|tag
argument_list|,
name|ROLE_INITIATOR
argument_list|)
condition|)
block|{
name|next
operator|=
name|ahc_rem_scb_from_disc_list
argument_list|(
name|ahc
argument_list|,
name|prev
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
else|else
block|{
name|prev
operator|=
name|next
expr_stmt|;
name|next
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCB_NEXT
argument_list|)
expr_stmt|;
block|}
block|}
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCBPTR
argument_list|,
name|active_scb
argument_list|)
expr_stmt|;
return|return
operator|(
name|count
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|u_int
name|ahc_rem_scb_from_disc_list
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|u_int
name|prev
parameter_list|,
name|u_int
name|scbptr
parameter_list|)
block|{
name|u_int
name|next
decl_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCBPTR
argument_list|,
name|scbptr
argument_list|)
expr_stmt|;
name|next
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCB_NEXT
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCB_CONTROL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ahc_add_curscb_to_free_list
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
if|if
condition|(
name|prev
operator|!=
name|SCB_LIST_NULL
condition|)
block|{
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCBPTR
argument_list|,
name|prev
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCB_NEXT
argument_list|,
name|next
argument_list|)
expr_stmt|;
block|}
else|else
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|DISCONNECTED_SCBH
argument_list|,
name|next
argument_list|)
expr_stmt|;
return|return
operator|(
name|next
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ahc_add_curscb_to_free_list
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|)
block|{
comment|/* Invalidate the tag so that ahc_find_scb doesn't think it's active */
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCB_TAG
argument_list|,
name|SCB_LIST_NULL
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCB_NEXT
argument_list|,
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|FREE_SCBH
argument_list|)
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|FREE_SCBH
argument_list|,
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCBPTR
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Manipulate the waiting for selection list and return the  * scb that follows the one that we remove.  */
end_comment

begin_function
specifier|static
name|u_int
name|ahc_abort_wscb
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|u_int
name|scbpos
parameter_list|,
name|u_int
name|prev
parameter_list|)
block|{
name|u_int
name|curscb
decl_stmt|,
name|next
decl_stmt|;
comment|/* 	 * Select the SCB we want to abort and 	 * pull the next pointer out of it. 	 */
name|curscb
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCBPTR
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCBPTR
argument_list|,
name|scbpos
argument_list|)
expr_stmt|;
name|next
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCB_NEXT
argument_list|)
expr_stmt|;
comment|/* Clear the necessary fields */
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCB_CONTROL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ahc_add_curscb_to_free_list
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
comment|/* update the waiting list */
if|if
condition|(
name|prev
operator|==
name|SCB_LIST_NULL
condition|)
block|{
comment|/* First in the list */
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|WAITING_SCBH
argument_list|,
name|next
argument_list|)
expr_stmt|;
comment|/* 		 * Ensure we aren't attempting to perform 		 * selection for this entry. 		 */
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCSISEQ
argument_list|,
operator|(
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCSISEQ
argument_list|)
operator|&
operator|~
name|ENSELO
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Select the scb that pointed to us  		 * and update its next pointer. 		 */
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCBPTR
argument_list|,
name|prev
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCB_NEXT
argument_list|,
name|next
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Point us back at the original scb position. 	 */
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCBPTR
argument_list|,
name|curscb
argument_list|)
expr_stmt|;
return|return
name|next
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ahc_clear_intstat
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|)
block|{
comment|/* Clear any interrupt conditions this may have caused */
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|CLRSINT0
argument_list|,
name|CLRSELDO
operator||
name|CLRSELDI
operator||
name|CLRSELINGO
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|CLRSINT1
argument_list|,
name|CLRSELTIMEO
operator||
name|CLRATNO
operator||
name|CLRSCSIRSTI
operator||
name|CLRBUSFREE
operator||
name|CLRSCSIPERR
operator||
name|CLRPHASECHG
operator||
name|CLRREQINIT
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|CLRINT
argument_list|,
name|CLRSCSIINT
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ahc_reset_current_bus
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|)
block|{
name|u_int8_t
name|scsiseq
decl_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SIMODE1
argument_list|,
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SIMODE1
argument_list|)
operator|&
operator|~
name|ENSCSIRST
argument_list|)
expr_stmt|;
name|scsiseq
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCSISEQ
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCSISEQ
argument_list|,
name|scsiseq
operator||
name|SCSIRSTO
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
name|AHC_BUSRESET_DELAY
argument_list|)
expr_stmt|;
comment|/* Turn off the bus reset */
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCSISEQ
argument_list|,
name|scsiseq
operator|&
operator|~
name|SCSIRSTO
argument_list|)
expr_stmt|;
name|ahc_clear_intstat
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
comment|/* Re-enable reset interrupts */
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SIMODE1
argument_list|,
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SIMODE1
argument_list|)
operator||
name|ENSCSIRST
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|ahc_reset_channel
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|char
name|channel
parameter_list|,
name|int
name|initiate_reset
parameter_list|)
block|{
name|struct
name|cam_path
modifier|*
name|path
decl_stmt|;
name|u_int
name|initiator
decl_stmt|,
name|target
decl_stmt|,
name|max_scsiid
decl_stmt|;
name|u_int
name|sblkctl
decl_stmt|;
name|u_int
name|our_id
decl_stmt|;
name|int
name|found
decl_stmt|;
name|int
name|restart_needed
decl_stmt|;
name|char
name|cur_channel
decl_stmt|;
name|ahc
operator|->
name|pending_device
operator|=
name|NULL
expr_stmt|;
name|pause_sequencer
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
comment|/* 	 * Run our command complete fifos to ensure that we perform 	 * completion processing on any commands that 'completed' 	 * before the reset occurred. 	 */
name|ahc_run_qoutfifo
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ahc
operator|->
name|flags
operator|&
name|AHC_TARGETMODE
operator|)
operator|!=
literal|0
condition|)
block|{
name|ahc_run_tqinfifo
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Reset the bus if we are initiating this reset 	 */
name|sblkctl
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SBLKCTL
argument_list|)
expr_stmt|;
name|cur_channel
operator|=
literal|'A'
expr_stmt|;
if|if
condition|(
operator|(
name|ahc
operator|->
name|features
operator|&
name|AHC_TWIN
operator|)
operator|!=
literal|0
operator|&&
operator|(
operator|(
name|sblkctl
operator|&
name|SELBUSB
operator|)
operator|!=
literal|0
operator|)
condition|)
name|cur_channel
operator|=
literal|'B'
expr_stmt|;
if|if
condition|(
name|cur_channel
operator|!=
name|channel
condition|)
block|{
comment|/* Case 1: Command for another bus is active 		 * Stealthily reset the other bus without 		 * upsetting the current bus. 		 */
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SBLKCTL
argument_list|,
name|sblkctl
operator|^
name|SELBUSB
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SIMODE1
argument_list|,
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SIMODE1
argument_list|)
operator|&
operator|~
name|ENBUSFREE
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCSISEQ
argument_list|,
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCSISEQ
argument_list|)
operator|&
operator|(
name|ENSELI
operator||
name|ENRSELI
operator||
name|ENAUTOATNP
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|initiate_reset
condition|)
name|ahc_reset_current_bus
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
name|ahc_clear_intstat
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SBLKCTL
argument_list|,
name|sblkctl
argument_list|)
expr_stmt|;
name|restart_needed
operator|=
name|FALSE
expr_stmt|;
block|}
else|else
block|{
comment|/* Case 2: A command from this bus is active or we're idle */
name|ahc_clear_msg_state
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SIMODE1
argument_list|,
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SIMODE1
argument_list|)
operator|&
operator|~
name|ENBUSFREE
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCSISEQ
argument_list|,
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCSISEQ
argument_list|)
operator|&
operator|(
name|ENSELI
operator||
name|ENRSELI
operator||
name|ENAUTOATNP
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|initiate_reset
condition|)
name|ahc_reset_current_bus
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
name|ahc_clear_intstat
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
comment|/* 		 * Since we are going to restart the sequencer, avoid 		 * a race in the sequencer that could cause corruption 		 * of our Q pointers by starting over from index 0. 		 */
name|ahc
operator|->
name|qoutfifonext
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|ahc
operator|->
name|features
operator|&
name|AHC_QUEUE_REGS
operator|)
operator|!=
literal|0
condition|)
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SDSCB_QOFF
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|QOUTPOS
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ahc
operator|->
name|flags
operator|&
name|AHC_TARGETMODE
operator|)
operator|!=
literal|0
condition|)
block|{
name|ahc
operator|->
name|tqinfifonext
operator|=
literal|0
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|KERNEL_TQINPOS
argument_list|,
name|ahc
operator|->
name|tqinfifonext
operator|-
literal|1
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|TQINPOS
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|restart_needed
operator|=
name|TRUE
expr_stmt|;
block|}
comment|/* 	 * Clean up all the state information for the 	 * pending transactions on this bus. 	 */
name|found
operator|=
name|ahc_abort_scbs
argument_list|(
name|ahc
argument_list|,
name|CAM_TARGET_WILDCARD
argument_list|,
name|channel
argument_list|,
name|CAM_LUN_WILDCARD
argument_list|,
name|SCB_LIST_NULL
argument_list|,
name|ROLE_UNKNOWN
argument_list|,
name|CAM_SCSI_BUS_RESET
argument_list|)
expr_stmt|;
if|if
condition|(
name|channel
operator|==
literal|'B'
condition|)
block|{
name|path
operator|=
name|ahc
operator|->
name|path_b
expr_stmt|;
name|our_id
operator|=
name|ahc
operator|->
name|our_id_b
expr_stmt|;
block|}
else|else
block|{
name|path
operator|=
name|ahc
operator|->
name|path
expr_stmt|;
name|our_id
operator|=
name|ahc
operator|->
name|our_id
expr_stmt|;
block|}
name|max_scsiid
operator|=
operator|(
name|ahc
operator|->
name|features
operator|&
name|AHC_WIDE
operator|)
condition|?
literal|15
else|:
literal|7
expr_stmt|;
comment|/* 	 * Send an immediate notify ccb to all target more peripheral 	 * drivers affected by this action. 	 */
for|for
control|(
name|target
operator|=
literal|0
init|;
name|target
operator|<=
name|max_scsiid
condition|;
name|target
operator|++
control|)
block|{
name|struct
name|tmode_tstate
modifier|*
name|tstate
decl_stmt|;
name|u_int
name|lun
decl_stmt|;
name|tstate
operator|=
name|ahc
operator|->
name|enabled_targets
index|[
name|target
index|]
expr_stmt|;
if|if
condition|(
name|tstate
operator|==
name|NULL
condition|)
continue|continue;
for|for
control|(
name|lun
operator|=
literal|0
init|;
name|lun
operator|<=
literal|7
condition|;
name|lun
operator|++
control|)
block|{
name|struct
name|tmode_lstate
modifier|*
name|lstate
decl_stmt|;
name|lstate
operator|=
name|tstate
operator|->
name|enabled_luns
index|[
name|lun
index|]
expr_stmt|;
if|if
condition|(
name|lstate
operator|==
name|NULL
condition|)
continue|continue;
name|ahc_queue_lstate_event
argument_list|(
name|ahc
argument_list|,
name|lstate
argument_list|,
name|CAM_TARGET_WILDCARD
argument_list|,
name|EVENT_TYPE_BUS_RESET
argument_list|,
comment|/*arg*/
literal|0
argument_list|)
expr_stmt|;
name|ahc_send_lstate_events
argument_list|(
name|ahc
argument_list|,
name|lstate
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Notify the XPT that a bus reset occurred */
name|xpt_async
argument_list|(
name|AC_BUS_RESET
argument_list|,
name|path
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* 	 * Revert to async/narrow transfers until we renegotiate. 	 */
for|for
control|(
name|target
operator|=
literal|0
init|;
name|target
operator|<=
name|max_scsiid
condition|;
name|target
operator|++
control|)
block|{
if|if
condition|(
name|ahc
operator|->
name|enabled_targets
index|[
name|target
index|]
operator|==
name|NULL
condition|)
continue|continue;
for|for
control|(
name|initiator
operator|=
literal|0
init|;
name|initiator
operator|<=
name|max_scsiid
condition|;
name|initiator
operator|++
control|)
block|{
name|struct
name|ahc_devinfo
name|devinfo
decl_stmt|;
name|ahc_compile_devinfo
argument_list|(
operator|&
name|devinfo
argument_list|,
name|target
argument_list|,
name|initiator
argument_list|,
name|CAM_LUN_WILDCARD
argument_list|,
name|channel
argument_list|,
name|ROLE_UNKNOWN
argument_list|)
expr_stmt|;
name|ahc_set_width
argument_list|(
name|ahc
argument_list|,
operator|&
name|devinfo
argument_list|,
name|path
argument_list|,
name|MSG_EXT_WDTR_BUS_8_BIT
argument_list|,
name|AHC_TRANS_CUR
argument_list|,
comment|/*paused*/
name|TRUE
argument_list|)
expr_stmt|;
name|ahc_set_syncrate
argument_list|(
name|ahc
argument_list|,
operator|&
name|devinfo
argument_list|,
name|path
argument_list|,
comment|/*syncrate*/
name|NULL
argument_list|,
comment|/*period*/
literal|0
argument_list|,
comment|/*offset*/
literal|0
argument_list|,
name|AHC_TRANS_CUR
argument_list|,
comment|/*paused*/
name|TRUE
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|restart_needed
condition|)
name|restart_sequencer
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
else|else
name|unpause_sequencer
argument_list|(
name|ahc
argument_list|,
comment|/*unpause_always*/
name|FALSE
argument_list|)
expr_stmt|;
return|return
name|found
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ahc_match_scb
parameter_list|(
name|struct
name|scb
modifier|*
name|scb
parameter_list|,
name|int
name|target
parameter_list|,
name|char
name|channel
parameter_list|,
name|int
name|lun
parameter_list|,
name|role_t
name|role
parameter_list|,
name|u_int
name|tag
parameter_list|)
block|{
name|int
name|targ
init|=
name|SCB_TARGET
argument_list|(
name|scb
argument_list|)
decl_stmt|;
name|char
name|chan
init|=
name|SCB_CHANNEL
argument_list|(
name|scb
argument_list|)
decl_stmt|;
name|int
name|slun
init|=
name|SCB_LUN
argument_list|(
name|scb
argument_list|)
decl_stmt|;
name|int
name|match
decl_stmt|;
name|match
operator|=
operator|(
operator|(
name|chan
operator|==
name|channel
operator|)
operator|||
operator|(
name|channel
operator|==
name|ALL_CHANNELS
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|match
operator|!=
literal|0
condition|)
name|match
operator|=
operator|(
operator|(
name|targ
operator|==
name|target
operator|)
operator|||
operator|(
name|target
operator|==
name|CAM_TARGET_WILDCARD
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|match
operator|!=
literal|0
condition|)
name|match
operator|=
operator|(
operator|(
name|lun
operator|==
name|slun
operator|)
operator|||
operator|(
name|lun
operator|==
name|CAM_LUN_WILDCARD
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|match
operator|!=
literal|0
condition|)
block|{
name|int
name|group
decl_stmt|;
name|group
operator|=
name|XPT_FC_GROUP
argument_list|(
name|scb
operator|->
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
argument_list|)
expr_stmt|;
if|if
condition|(
name|role
operator|==
name|ROLE_INITIATOR
condition|)
block|{
name|match
operator|=
operator|(
name|group
operator|==
name|XPT_FC_GROUP_COMMON
operator|)
operator|&&
operator|(
operator|(
name|tag
operator|==
name|scb
operator|->
name|ccb
operator|->
name|csio
operator|.
name|tag_id
operator|)
operator|||
operator|(
name|tag
operator|==
name|SCB_LIST_NULL
operator|)
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|role
operator|==
name|ROLE_TARGET
condition|)
block|{
name|match
operator|=
operator|(
name|group
operator|==
name|XPT_FC_GROUP_TMODE
operator|)
operator|&&
operator|(
operator|(
name|tag
operator|==
name|scb
operator|->
name|ccb
operator|->
name|csio
operator|.
name|tag_id
operator|)
operator|||
operator|(
name|tag
operator|==
name|SCB_LIST_NULL
operator|)
operator|)
expr_stmt|;
block|}
block|}
return|return
name|match
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ahc_construct_sdtr
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|u_int
name|period
parameter_list|,
name|u_int
name|offset
parameter_list|)
block|{
name|ahc
operator|->
name|msgout_buf
index|[
name|ahc
operator|->
name|msgout_index
operator|++
index|]
operator|=
name|MSG_EXTENDED
expr_stmt|;
name|ahc
operator|->
name|msgout_buf
index|[
name|ahc
operator|->
name|msgout_index
operator|++
index|]
operator|=
name|MSG_EXT_SDTR_LEN
expr_stmt|;
name|ahc
operator|->
name|msgout_buf
index|[
name|ahc
operator|->
name|msgout_index
operator|++
index|]
operator|=
name|MSG_EXT_SDTR
expr_stmt|;
name|ahc
operator|->
name|msgout_buf
index|[
name|ahc
operator|->
name|msgout_index
operator|++
index|]
operator|=
name|period
expr_stmt|;
name|ahc
operator|->
name|msgout_buf
index|[
name|ahc
operator|->
name|msgout_index
operator|++
index|]
operator|=
name|offset
expr_stmt|;
name|ahc
operator|->
name|msgout_len
operator|+=
literal|5
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ahc_construct_wdtr
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|u_int
name|bus_width
parameter_list|)
block|{
name|ahc
operator|->
name|msgout_buf
index|[
name|ahc
operator|->
name|msgout_index
operator|++
index|]
operator|=
name|MSG_EXTENDED
expr_stmt|;
name|ahc
operator|->
name|msgout_buf
index|[
name|ahc
operator|->
name|msgout_index
operator|++
index|]
operator|=
name|MSG_EXT_WDTR_LEN
expr_stmt|;
name|ahc
operator|->
name|msgout_buf
index|[
name|ahc
operator|->
name|msgout_index
operator|++
index|]
operator|=
name|MSG_EXT_WDTR
expr_stmt|;
name|ahc
operator|->
name|msgout_buf
index|[
name|ahc
operator|->
name|msgout_index
operator|++
index|]
operator|=
name|bus_width
expr_stmt|;
name|ahc
operator|->
name|msgout_len
operator|+=
literal|4
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ahc_calc_residual
parameter_list|(
name|struct
name|scb
modifier|*
name|scb
parameter_list|)
block|{
name|struct
name|hardware_scb
modifier|*
name|hscb
decl_stmt|;
name|hscb
operator|=
name|scb
operator|->
name|hscb
expr_stmt|;
comment|/* 	 * If the disconnected flag is still set, this is bogus 	 * residual information left over from a sequencer 	 * pagin/pageout, so ignore this case. 	 */
if|if
condition|(
operator|(
name|scb
operator|->
name|hscb
operator|->
name|control
operator|&
name|DISCONNECTED
operator|)
operator|==
literal|0
condition|)
block|{
name|u_int32_t
name|resid
decl_stmt|;
name|int
name|resid_sgs
decl_stmt|;
name|int
name|sg
decl_stmt|;
comment|/* 		 * Remainder of the SG where the transfer 		 * stopped. 		 */
name|resid
operator|=
operator|(
name|hscb
operator|->
name|residual_data_count
index|[
literal|2
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
name|hscb
operator|->
name|residual_data_count
index|[
literal|1
index|]
operator|<<
literal|8
operator|)
operator||
operator|(
name|hscb
operator|->
name|residual_data_count
index|[
literal|0
index|]
operator|)
expr_stmt|;
comment|/* 		 * Add up the contents of all residual 		 * SG segments that are after the SG where 		 * the transfer stopped. 		 */
name|resid_sgs
operator|=
name|scb
operator|->
name|hscb
operator|->
name|residual_SG_count
operator|-
literal|1
comment|/*current*/
expr_stmt|;
name|sg
operator|=
name|scb
operator|->
name|sg_count
operator|-
name|resid_sgs
operator|-
literal|1
comment|/*first SG*/
expr_stmt|;
while|while
condition|(
name|resid_sgs
operator|>
literal|0
condition|)
block|{
name|resid
operator|+=
name|scb
operator|->
name|sg_list
index|[
name|sg
index|]
operator|.
name|len
expr_stmt|;
name|sg
operator|++
expr_stmt|;
name|resid_sgs
operator|--
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|scb
operator|->
name|flags
operator|&
name|SCB_SENSE
operator|)
operator|==
literal|0
condition|)
block|{
name|scb
operator|->
name|ccb
operator|->
name|csio
operator|.
name|resid
operator|=
name|resid
expr_stmt|;
block|}
else|else
block|{
name|scb
operator|->
name|ccb
operator|->
name|csio
operator|.
name|sense_resid
operator|=
name|resid
expr_stmt|;
block|}
block|}
comment|/* 	 * Clean out the residual information in this SCB for its 	 * next consumer. 	 */
name|hscb
operator|->
name|residual_SG_count
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|AHC_DEBUG
if|if
condition|(
name|ahc_debug
operator|&
name|AHC_SHOWMISC
condition|)
block|{
name|sc_print_addr
argument_list|(
name|xs
operator|->
name|sc_link
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Handled Residual of %ld bytes\n"
argument_list|,
name|xs
operator|->
name|resid
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|void
name|ahc_update_pending_syncrates
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|)
block|{
name|struct
name|ccb_hdr
modifier|*
name|ccbh
decl_stmt|;
name|int
name|pending_ccb_count
decl_stmt|;
name|int
name|i
decl_stmt|;
name|u_int
name|saved_scbptr
decl_stmt|;
comment|/* 	 * Traverse the pending SCB list and ensure that all of the 	 * SCBs there have the proper settings. 	 */
name|ccbh
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|ahc
operator|->
name|pending_ccbs
argument_list|)
expr_stmt|;
name|pending_ccb_count
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|ccbh
operator|!=
name|NULL
condition|)
block|{
name|struct
name|ahc_devinfo
name|devinfo
decl_stmt|;
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|struct
name|scb
modifier|*
name|pending_scb
decl_stmt|;
name|struct
name|hardware_scb
modifier|*
name|pending_hscb
decl_stmt|;
name|struct
name|ahc_initiator_tinfo
modifier|*
name|tinfo
decl_stmt|;
name|struct
name|tmode_tstate
modifier|*
name|tstate
decl_stmt|;
name|u_int
name|our_id
decl_stmt|,
name|remote_id
decl_stmt|;
name|ccb
operator|=
operator|(
expr|union
name|ccb
operator|*
operator|)
name|ccbh
expr_stmt|;
name|pending_scb
operator|=
operator|(
expr|struct
name|scb
operator|*
operator|)
name|ccbh
operator|->
name|ccb_scb_ptr
expr_stmt|;
name|pending_hscb
operator|=
name|pending_scb
operator|->
name|hscb
expr_stmt|;
if|if
condition|(
name|ccbh
operator|->
name|func_code
operator|==
name|XPT_CONT_TARGET_IO
condition|)
block|{
name|our_id
operator|=
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
expr_stmt|;
name|remote_id
operator|=
name|ccb
operator|->
name|ctio
operator|.
name|init_id
expr_stmt|;
block|}
else|else
block|{
name|our_id
operator|=
name|SCB_IS_SCSIBUS_B
argument_list|(
name|pending_scb
argument_list|)
condition|?
name|ahc
operator|->
name|our_id_b
else|:
name|ahc
operator|->
name|our_id
expr_stmt|;
name|remote_id
operator|=
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
expr_stmt|;
block|}
name|ahc_compile_devinfo
argument_list|(
operator|&
name|devinfo
argument_list|,
name|our_id
argument_list|,
name|remote_id
argument_list|,
name|SCB_LUN
argument_list|(
name|pending_scb
argument_list|)
argument_list|,
name|SCB_CHANNEL
argument_list|(
name|pending_scb
argument_list|)
argument_list|,
name|ROLE_UNKNOWN
argument_list|)
expr_stmt|;
name|tinfo
operator|=
name|ahc_fetch_transinfo
argument_list|(
name|ahc
argument_list|,
name|devinfo
operator|.
name|channel
argument_list|,
name|our_id
argument_list|,
name|remote_id
argument_list|,
operator|&
name|tstate
argument_list|)
expr_stmt|;
name|pending_hscb
operator|->
name|control
operator|&=
operator|~
name|ULTRAENB
expr_stmt|;
if|if
condition|(
operator|(
name|tstate
operator|->
name|ultraenb
operator|&
name|devinfo
operator|.
name|target_mask
operator|)
operator|!=
literal|0
condition|)
name|pending_hscb
operator|->
name|control
operator||=
name|ULTRAENB
expr_stmt|;
name|pending_hscb
operator|->
name|scsirate
operator|=
name|tinfo
operator|->
name|scsirate
expr_stmt|;
name|pending_hscb
operator|->
name|scsioffset
operator|=
name|tinfo
operator|->
name|current
operator|.
name|offset
expr_stmt|;
name|pending_ccb_count
operator|++
expr_stmt|;
name|ccbh
operator|=
name|LIST_NEXT
argument_list|(
name|ccbh
argument_list|,
name|sim_links
operator|.
name|le
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pending_ccb_count
operator|==
literal|0
condition|)
return|return;
name|saved_scbptr
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCBPTR
argument_list|)
expr_stmt|;
comment|/* Ensure that the hscbs down on the card match the new information */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ahc
operator|->
name|scb_data
operator|->
name|maxhscbs
condition|;
name|i
operator|++
control|)
block|{
name|u_int
name|scb_tag
decl_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCBPTR
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|scb_tag
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCB_TAG
argument_list|)
expr_stmt|;
if|if
condition|(
name|scb_tag
operator|!=
name|SCB_LIST_NULL
condition|)
block|{
name|struct
name|ahc_devinfo
name|devinfo
decl_stmt|;
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|struct
name|scb
modifier|*
name|pending_scb
decl_stmt|;
name|struct
name|hardware_scb
modifier|*
name|pending_hscb
decl_stmt|;
name|struct
name|ahc_initiator_tinfo
modifier|*
name|tinfo
decl_stmt|;
name|struct
name|tmode_tstate
modifier|*
name|tstate
decl_stmt|;
name|u_int
name|our_id
decl_stmt|,
name|remote_id
decl_stmt|;
name|u_int
name|control
decl_stmt|;
name|pending_scb
operator|=
operator|&
name|ahc
operator|->
name|scb_data
operator|->
name|scbarray
index|[
name|scb_tag
index|]
expr_stmt|;
if|if
condition|(
name|pending_scb
operator|->
name|flags
operator|==
name|SCB_FREE
condition|)
continue|continue;
name|pending_hscb
operator|=
name|pending_scb
operator|->
name|hscb
expr_stmt|;
name|ccb
operator|=
name|pending_scb
operator|->
name|ccb
expr_stmt|;
if|if
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|==
name|XPT_CONT_TARGET_IO
condition|)
block|{
name|our_id
operator|=
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
expr_stmt|;
name|remote_id
operator|=
name|ccb
operator|->
name|ctio
operator|.
name|init_id
expr_stmt|;
block|}
else|else
block|{
name|our_id
operator|=
name|SCB_IS_SCSIBUS_B
argument_list|(
name|pending_scb
argument_list|)
condition|?
name|ahc
operator|->
name|our_id_b
else|:
name|ahc
operator|->
name|our_id
expr_stmt|;
name|remote_id
operator|=
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
expr_stmt|;
block|}
name|ahc_compile_devinfo
argument_list|(
operator|&
name|devinfo
argument_list|,
name|our_id
argument_list|,
name|remote_id
argument_list|,
name|SCB_LUN
argument_list|(
name|pending_scb
argument_list|)
argument_list|,
name|SCB_CHANNEL
argument_list|(
name|pending_scb
argument_list|)
argument_list|,
name|ROLE_UNKNOWN
argument_list|)
expr_stmt|;
name|tinfo
operator|=
name|ahc_fetch_transinfo
argument_list|(
name|ahc
argument_list|,
name|devinfo
operator|.
name|channel
argument_list|,
name|our_id
argument_list|,
name|remote_id
argument_list|,
operator|&
name|tstate
argument_list|)
expr_stmt|;
name|control
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCB_CONTROL
argument_list|)
expr_stmt|;
name|control
operator|&=
operator|~
name|ULTRAENB
expr_stmt|;
if|if
condition|(
operator|(
name|tstate
operator|->
name|ultraenb
operator|&
name|devinfo
operator|.
name|target_mask
operator|)
operator|!=
literal|0
condition|)
name|control
operator||=
name|ULTRAENB
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCB_CONTROL
argument_list|,
name|control
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCB_SCSIRATE
argument_list|,
name|tinfo
operator|->
name|scsirate
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCB_SCSIOFFSET
argument_list|,
name|tinfo
operator|->
name|current
operator|.
name|offset
argument_list|)
expr_stmt|;
block|}
block|}
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCBPTR
argument_list|,
name|saved_scbptr
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
name|UNUSED
end_if

begin_function
specifier|static
name|void
name|ahc_dump_targcmd
parameter_list|(
name|struct
name|target_cmd
modifier|*
name|cmd
parameter_list|)
block|{
name|u_int8_t
modifier|*
name|byte
decl_stmt|;
name|u_int8_t
modifier|*
name|last_byte
decl_stmt|;
name|int
name|i
decl_stmt|;
name|byte
operator|=
operator|&
name|cmd
operator|->
name|initiator_channel
expr_stmt|;
comment|/* Debugging info for received commands */
name|last_byte
operator|=
operator|&
name|cmd
index|[
literal|1
index|]
operator|.
name|initiator_channel
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|byte
operator|<
name|last_byte
condition|)
block|{
if|if
condition|(
name|i
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"\t"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%#x"
argument_list|,
operator|*
name|byte
operator|++
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|8
condition|)
block|{
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|ahc_shutdown
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|howto
parameter_list|)
block|{
name|struct
name|ahc_softc
modifier|*
name|ahc
decl_stmt|;
name|int
name|i
decl_stmt|;
name|u_int
name|sxfrctl1_a
decl_stmt|,
name|sxfrctl1_b
decl_stmt|;
name|ahc
operator|=
operator|(
expr|struct
name|ahc_softc
operator|*
operator|)
name|arg
expr_stmt|;
name|pause_sequencer
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
comment|/* 	 * Preserve the value of the SXFRCTL1 register for all channels. 	 * It contains settings that affect termination and we don't want 	 * to disturb the integrity of the bus during shutdown in case 	 * we are in a multi-initiator setup. 	 */
name|sxfrctl1_b
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|ahc
operator|->
name|features
operator|&
name|AHC_TWIN
operator|)
operator|!=
literal|0
condition|)
block|{
name|u_int
name|sblkctl
decl_stmt|;
name|sblkctl
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SBLKCTL
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SBLKCTL
argument_list|,
name|sblkctl
operator||
name|SELBUSB
argument_list|)
expr_stmt|;
name|sxfrctl1_b
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SXFRCTL1
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SBLKCTL
argument_list|,
name|sblkctl
operator|&
operator|~
name|SELBUSB
argument_list|)
expr_stmt|;
block|}
name|sxfrctl1_a
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SXFRCTL1
argument_list|)
expr_stmt|;
comment|/* This will reset most registers to 0, but not all */
name|ahc_reset
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ahc
operator|->
name|features
operator|&
name|AHC_TWIN
operator|)
operator|!=
literal|0
condition|)
block|{
name|u_int
name|sblkctl
decl_stmt|;
name|sblkctl
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SBLKCTL
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SBLKCTL
argument_list|,
name|sblkctl
operator||
name|SELBUSB
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SXFRCTL1
argument_list|,
name|sxfrctl1_b
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SBLKCTL
argument_list|,
name|sblkctl
operator|&
operator|~
name|SELBUSB
argument_list|)
expr_stmt|;
block|}
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SXFRCTL1
argument_list|,
name|sxfrctl1_a
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCSISEQ
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SXFRCTL0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|DSPCISTATUS
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|TARG_SCSIRATE
init|;
name|i
operator|<
name|HA_274_BIOSCTRL
condition|;
name|i
operator|++
control|)
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|i
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Add a target mode event to this lun's queue  */
end_comment

begin_function
specifier|static
name|void
name|ahc_queue_lstate_event
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|struct
name|tmode_lstate
modifier|*
name|lstate
parameter_list|,
name|u_int
name|initiator_id
parameter_list|,
name|u_int
name|event_type
parameter_list|,
name|u_int
name|event_arg
parameter_list|)
block|{
name|struct
name|ahc_tmode_event
modifier|*
name|event
decl_stmt|;
name|int
name|pending
decl_stmt|;
name|xpt_freeze_devq
argument_list|(
name|lstate
operator|->
name|path
argument_list|,
comment|/*count*/
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|lstate
operator|->
name|event_w_idx
operator|>=
name|lstate
operator|->
name|event_r_idx
condition|)
name|pending
operator|=
name|lstate
operator|->
name|event_w_idx
operator|-
name|lstate
operator|->
name|event_r_idx
expr_stmt|;
else|else
name|pending
operator|=
name|AHC_TMODE_EVENT_BUFFER_SIZE
operator|+
literal|1
operator|-
operator|(
name|lstate
operator|->
name|event_r_idx
operator|-
name|lstate
operator|->
name|event_w_idx
operator|)
expr_stmt|;
if|if
condition|(
name|event_type
operator|==
name|EVENT_TYPE_BUS_RESET
operator|||
name|event_type
operator|==
name|MSG_BUS_DEV_RESET
condition|)
block|{
comment|/* 		 * Any earlier events are irrelevant, so reset our buffer. 		 * This has the effect of allowing us to deal with reset 		 * floods (an external device holding down the reset line) 		 * without losing the event that is really interesting. 		 */
name|lstate
operator|->
name|event_r_idx
operator|=
literal|0
expr_stmt|;
name|lstate
operator|->
name|event_w_idx
operator|=
literal|0
expr_stmt|;
name|xpt_release_devq
argument_list|(
name|lstate
operator|->
name|path
argument_list|,
name|pending
argument_list|,
comment|/*runqueue*/
name|FALSE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pending
operator|==
name|AHC_TMODE_EVENT_BUFFER_SIZE
condition|)
block|{
name|xpt_print_path
argument_list|(
name|lstate
operator|->
name|path
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"immediate event %x:%x lost\n"
argument_list|,
name|lstate
operator|->
name|event_buffer
index|[
name|lstate
operator|->
name|event_r_idx
index|]
operator|.
name|event_type
argument_list|,
name|lstate
operator|->
name|event_buffer
index|[
name|lstate
operator|->
name|event_r_idx
index|]
operator|.
name|event_arg
argument_list|)
expr_stmt|;
name|lstate
operator|->
name|event_r_idx
operator|++
expr_stmt|;
if|if
condition|(
name|lstate
operator|->
name|event_r_idx
operator|==
name|AHC_TMODE_EVENT_BUFFER_SIZE
condition|)
name|lstate
operator|->
name|event_r_idx
operator|=
literal|0
expr_stmt|;
name|xpt_release_devq
argument_list|(
name|lstate
operator|->
name|path
argument_list|,
comment|/*count*/
literal|1
argument_list|,
comment|/*runqueue*/
name|FALSE
argument_list|)
expr_stmt|;
block|}
name|event
operator|=
operator|&
name|lstate
operator|->
name|event_buffer
index|[
name|lstate
operator|->
name|event_w_idx
index|]
expr_stmt|;
name|event
operator|->
name|initiator_id
operator|=
name|initiator_id
expr_stmt|;
name|event
operator|->
name|event_type
operator|=
name|event_type
expr_stmt|;
name|event
operator|->
name|event_arg
operator|=
name|event_arg
expr_stmt|;
name|lstate
operator|->
name|event_w_idx
operator|++
expr_stmt|;
if|if
condition|(
name|lstate
operator|->
name|event_w_idx
operator|==
name|AHC_TMODE_EVENT_BUFFER_SIZE
condition|)
name|lstate
operator|->
name|event_w_idx
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Send any target mode events queued up waiting  * for immediate notify resources.  */
end_comment

begin_function
specifier|static
name|void
name|ahc_send_lstate_events
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|struct
name|tmode_lstate
modifier|*
name|lstate
parameter_list|)
block|{
name|struct
name|ccb_hdr
modifier|*
name|ccbh
decl_stmt|;
name|struct
name|ccb_immed_notify
modifier|*
name|inot
decl_stmt|;
while|while
condition|(
name|lstate
operator|->
name|event_r_idx
operator|!=
name|lstate
operator|->
name|event_w_idx
operator|&&
operator|(
name|ccbh
operator|=
name|SLIST_FIRST
argument_list|(
operator|&
name|lstate
operator|->
name|immed_notifies
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|struct
name|ahc_tmode_event
modifier|*
name|event
decl_stmt|;
name|event
operator|=
operator|&
name|lstate
operator|->
name|event_buffer
index|[
name|lstate
operator|->
name|event_r_idx
index|]
expr_stmt|;
name|SLIST_REMOVE_HEAD
argument_list|(
operator|&
name|lstate
operator|->
name|immed_notifies
argument_list|,
name|sim_links
operator|.
name|sle
argument_list|)
expr_stmt|;
name|inot
operator|=
operator|(
expr|struct
name|ccb_immed_notify
operator|*
operator|)
name|ccbh
expr_stmt|;
switch|switch
condition|(
name|event
operator|->
name|event_type
condition|)
block|{
case|case
name|EVENT_TYPE_BUS_RESET
case|:
name|ccbh
operator|->
name|status
operator|=
name|CAM_SCSI_BUS_RESET
operator||
name|CAM_DEV_QFRZN
expr_stmt|;
break|break;
default|default:
name|ccbh
operator|->
name|status
operator|=
name|CAM_MESSAGE_RECV
operator||
name|CAM_DEV_QFRZN
expr_stmt|;
name|inot
operator|->
name|message_args
index|[
literal|0
index|]
operator|=
name|event
operator|->
name|event_type
expr_stmt|;
name|inot
operator|->
name|message_args
index|[
literal|1
index|]
operator|=
name|event
operator|->
name|event_arg
expr_stmt|;
break|break;
block|}
name|inot
operator|->
name|initiator_id
operator|=
name|event
operator|->
name|initiator_id
expr_stmt|;
name|inot
operator|->
name|sense_len
operator|=
literal|0
expr_stmt|;
name|xpt_done
argument_list|(
operator|(
expr|union
name|ccb
operator|*
operator|)
name|inot
argument_list|)
expr_stmt|;
name|lstate
operator|->
name|event_r_idx
operator|++
expr_stmt|;
if|if
condition|(
name|lstate
operator|->
name|event_r_idx
operator|==
name|AHC_TMODE_EVENT_BUFFER_SIZE
condition|)
name|lstate
operator|->
name|event_r_idx
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

end_unit

