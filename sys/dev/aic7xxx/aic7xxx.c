begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Core routines and tables shareable across OS platforms.  *  * Copyright (c) 1994-2002 Justin T. Gibbs.  * Copyright (c) 2000-2002 Adaptec Inc.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions, and the following disclaimer,  *    without modification.  * 2. Redistributions in binary form must reproduce at minimum a disclaimer  *    substantially similar to the "NO WARRANTY" disclaimer below  *    ("Disclaimer") and any redistribution must be conditioned upon  *    including a substantially similar Disclaimer requirement for further  *    binary redistribution.  * 3. Neither the names of the above-listed copyright holders nor the names  *    of any contributors may be used to endorse or promote products derived  *    from this software without specific prior written permission.  *  * Alternatively, this software may be distributed under the terms of the  * GNU General Public License ("GPL") version 2 as published by the Free  * Software Foundation.  *  * NO WARRANTY  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT  * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING  * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  * POSSIBILITY OF SUCH DAMAGES.  *  * $Id: //depot/aic7xxx/aic7xxx/aic7xxx.c#155 $  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__linux__
end_ifdef

begin_include
include|#
directive|include
file|"aic7xxx_osm.h"
end_include

begin_include
include|#
directive|include
file|"aic7xxx_inline.h"
end_include

begin_include
include|#
directive|include
file|"aicasm/aicasm_insformat.h"
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<dev/aic7xxx/aic7xxx_osm.h>
end_include

begin_include
include|#
directive|include
file|<dev/aic7xxx/aic7xxx_inline.h>
end_include

begin_include
include|#
directive|include
file|<dev/aic7xxx/aicasm/aicasm_insformat.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/****************************** Softc Data ************************************/
end_comment

begin_decl_stmt
name|struct
name|ahc_softc_tailq
name|ahc_tailq
init|=
name|TAILQ_HEAD_INITIALIZER
argument_list|(
name|ahc_tailq
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/***************************** Lookup Tables **********************************/
end_comment

begin_decl_stmt
name|char
modifier|*
name|ahc_chip_names
index|[]
init|=
block|{
literal|"NONE"
block|,
literal|"aic7770"
block|,
literal|"aic7850"
block|,
literal|"aic7855"
block|,
literal|"aic7859"
block|,
literal|"aic7860"
block|,
literal|"aic7870"
block|,
literal|"aic7880"
block|,
literal|"aic7895"
block|,
literal|"aic7895C"
block|,
literal|"aic7890/91"
block|,
literal|"aic7896/97"
block|,
literal|"aic7892"
block|,
literal|"aic7899"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|u_int
name|num_chip_names
init|=
name|NUM_ELEMENTS
argument_list|(
name|ahc_chip_names
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Hardware error codes.  */
end_comment

begin_struct
struct|struct
name|ahc_hard_error_entry
block|{
name|uint8_t
name|errno
decl_stmt|;
name|char
modifier|*
name|errmesg
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|ahc_hard_error_entry
name|ahc_hard_errors
index|[]
init|=
block|{
block|{
name|ILLHADDR
block|,
literal|"Illegal Host Access"
block|}
block|,
block|{
name|ILLSADDR
block|,
literal|"Illegal Sequencer Address referrenced"
block|}
block|,
block|{
name|ILLOPCODE
block|,
literal|"Illegal Opcode in sequencer program"
block|}
block|,
block|{
name|SQPARERR
block|,
literal|"Sequencer Parity Error"
block|}
block|,
block|{
name|DPARERR
block|,
literal|"Data-path Parity Error"
block|}
block|,
block|{
name|MPARERR
block|,
literal|"Scratch or SCB Memory Parity Error"
block|}
block|,
block|{
name|PCIERRSTAT
block|,
literal|"PCI Error detected"
block|}
block|,
block|{
name|CIOPARERR
block|,
literal|"CIOBUS Parity Error"
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|u_int
name|num_errors
init|=
name|NUM_ELEMENTS
argument_list|(
name|ahc_hard_errors
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|ahc_phase_table_entry
name|ahc_phase_table
index|[]
init|=
block|{
block|{
name|P_DATAOUT
block|,
name|MSG_NOOP
block|,
literal|"in Data-out phase"
block|}
block|,
block|{
name|P_DATAIN
block|,
name|MSG_INITIATOR_DET_ERR
block|,
literal|"in Data-in phase"
block|}
block|,
block|{
name|P_DATAOUT_DT
block|,
name|MSG_NOOP
block|,
literal|"in DT Data-out phase"
block|}
block|,
block|{
name|P_DATAIN_DT
block|,
name|MSG_INITIATOR_DET_ERR
block|,
literal|"in DT Data-in phase"
block|}
block|,
block|{
name|P_COMMAND
block|,
name|MSG_NOOP
block|,
literal|"in Command phase"
block|}
block|,
block|{
name|P_MESGOUT
block|,
name|MSG_NOOP
block|,
literal|"in Message-out phase"
block|}
block|,
block|{
name|P_STATUS
block|,
name|MSG_INITIATOR_DET_ERR
block|,
literal|"in Status phase"
block|}
block|,
block|{
name|P_MESGIN
block|,
name|MSG_PARITY_ERROR
block|,
literal|"in Message-in phase"
block|}
block|,
block|{
name|P_BUSFREE
block|,
name|MSG_NOOP
block|,
literal|"while idle"
block|}
block|,
block|{
literal|0
block|,
name|MSG_NOOP
block|,
literal|"in unknown phase"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * In most cases we only wish to itterate over real phases, so  * exclude the last element from the count.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|u_int
name|num_phases
init|=
name|NUM_ELEMENTS
argument_list|(
name|ahc_phase_table
argument_list|)
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Valid SCSIRATE values.  (p. 3-17)  * Provides a mapping of tranfer periods in ns to the proper value to  * stick in the scsixfer reg.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|ahc_syncrate
name|ahc_syncrates
index|[]
init|=
block|{
comment|/* ultra2    fast/ultra  period     rate */
block|{
literal|0x42
block|,
literal|0x000
block|,
literal|9
block|,
literal|"80.0"
block|}
block|,
block|{
literal|0x03
block|,
literal|0x000
block|,
literal|10
block|,
literal|"40.0"
block|}
block|,
block|{
literal|0x04
block|,
literal|0x000
block|,
literal|11
block|,
literal|"33.0"
block|}
block|,
block|{
literal|0x05
block|,
literal|0x100
block|,
literal|12
block|,
literal|"20.0"
block|}
block|,
block|{
literal|0x06
block|,
literal|0x110
block|,
literal|15
block|,
literal|"16.0"
block|}
block|,
block|{
literal|0x07
block|,
literal|0x120
block|,
literal|18
block|,
literal|"13.4"
block|}
block|,
block|{
literal|0x08
block|,
literal|0x000
block|,
literal|25
block|,
literal|"10.0"
block|}
block|,
block|{
literal|0x19
block|,
literal|0x010
block|,
literal|31
block|,
literal|"8.0"
block|}
block|,
block|{
literal|0x1a
block|,
literal|0x020
block|,
literal|37
block|,
literal|"6.67"
block|}
block|,
block|{
literal|0x1b
block|,
literal|0x030
block|,
literal|43
block|,
literal|"5.7"
block|}
block|,
block|{
literal|0x1c
block|,
literal|0x040
block|,
literal|50
block|,
literal|"5.0"
block|}
block|,
block|{
literal|0x00
block|,
literal|0x050
block|,
literal|56
block|,
literal|"4.4"
block|}
block|,
block|{
literal|0x00
block|,
literal|0x060
block|,
literal|62
block|,
literal|"4.0"
block|}
block|,
block|{
literal|0x00
block|,
literal|0x070
block|,
literal|68
block|,
literal|"3.6"
block|}
block|,
block|{
literal|0x00
block|,
literal|0x000
block|,
literal|0
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Our Sequencer Program */
end_comment

begin_include
include|#
directive|include
file|"aic7xxx_seq.h"
end_include

begin_comment
comment|/**************************** Function Declarations ***************************/
end_comment

begin_function_decl
specifier|static
name|void
name|ahc_force_renegotiation
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|struct
name|ahc_devinfo
modifier|*
name|devinfo
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|ahc_tmode_tstate
modifier|*
name|ahc_alloc_tstate
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|u_int
name|scsi_id
parameter_list|,
name|char
name|channel
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|AHC_TARGET_MODE
end_ifdef

begin_function_decl
specifier|static
name|void
name|ahc_free_tstate
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|u_int
name|scsi_id
parameter_list|,
name|char
name|channel
parameter_list|,
name|int
name|force
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|struct
name|ahc_syncrate
modifier|*
name|ahc_devlimited_syncrate
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|struct
name|ahc_initiator_tinfo
modifier|*
parameter_list|,
name|u_int
modifier|*
name|period
parameter_list|,
name|u_int
modifier|*
name|ppr_options
parameter_list|,
name|role_t
name|role
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ahc_update_pending_scbs
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ahc_fetch_devinfo
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|struct
name|ahc_devinfo
modifier|*
name|devinfo
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ahc_scb_devinfo
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|struct
name|ahc_devinfo
modifier|*
name|devinfo
parameter_list|,
name|struct
name|scb
modifier|*
name|scb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ahc_assert_atn
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ahc_setup_initiator_msgout
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|struct
name|ahc_devinfo
modifier|*
name|devinfo
parameter_list|,
name|struct
name|scb
modifier|*
name|scb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ahc_build_transfer_msg
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|struct
name|ahc_devinfo
modifier|*
name|devinfo
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ahc_construct_sdtr
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|struct
name|ahc_devinfo
modifier|*
name|devinfo
parameter_list|,
name|u_int
name|period
parameter_list|,
name|u_int
name|offset
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ahc_construct_wdtr
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|struct
name|ahc_devinfo
modifier|*
name|devinfo
parameter_list|,
name|u_int
name|bus_width
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ahc_construct_ppr
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|struct
name|ahc_devinfo
modifier|*
name|devinfo
parameter_list|,
name|u_int
name|period
parameter_list|,
name|u_int
name|offset
parameter_list|,
name|u_int
name|bus_width
parameter_list|,
name|u_int
name|ppr_options
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ahc_clear_msg_state
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ahc_handle_proto_violation
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ahc_handle_message_phase
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|)
function_decl|;
end_function_decl

begin_typedef
typedef|typedef
enum|enum
block|{
name|AHCMSG_1B
block|,
name|AHCMSG_2B
block|,
name|AHCMSG_EXT
block|}
name|ahc_msgtype
typedef|;
end_typedef

begin_function_decl
specifier|static
name|int
name|ahc_sent_msg
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|ahc_msgtype
name|type
parameter_list|,
name|u_int
name|msgval
parameter_list|,
name|int
name|full
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ahc_parse_msg
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|struct
name|ahc_devinfo
modifier|*
name|devinfo
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ahc_handle_msg_reject
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|struct
name|ahc_devinfo
modifier|*
name|devinfo
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ahc_handle_ign_wide_residue
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|struct
name|ahc_devinfo
modifier|*
name|devinfo
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ahc_reinitialize_dataptrs
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ahc_handle_devreset
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|struct
name|ahc_devinfo
modifier|*
name|devinfo
parameter_list|,
name|cam_status
name|status
parameter_list|,
name|char
modifier|*
name|message
parameter_list|,
name|int
name|verbose_level
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|AHC_TARGET_MODE
end_ifdef

begin_function_decl
specifier|static
name|void
name|ahc_setup_target_msgin
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|struct
name|ahc_devinfo
modifier|*
name|devinfo
parameter_list|,
name|struct
name|scb
modifier|*
name|scb
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|bus_dmamap_callback_t
name|ahc_dmamap_cb
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|ahc_build_free_scb_list
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ahc_init_scbdata
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ahc_fini_scbdata
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ahc_qinfifo_requeue
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|struct
name|scb
modifier|*
name|prev_scb
parameter_list|,
name|struct
name|scb
modifier|*
name|scb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ahc_qinfifo_count
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u_int
name|ahc_rem_scb_from_disc_list
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|u_int
name|prev
parameter_list|,
name|u_int
name|scbptr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ahc_add_curscb_to_free_list
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u_int
name|ahc_rem_wscb
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|u_int
name|scbpos
parameter_list|,
name|u_int
name|prev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ahc_reset_current_bus
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|AHC_DUMP_SEQ
end_ifdef

begin_function_decl
specifier|static
name|void
name|ahc_dumpseq
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|int
name|ahc_loadseq
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ahc_check_patch
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|struct
name|patch
modifier|*
modifier|*
name|start_patch
parameter_list|,
name|u_int
name|start_instr
parameter_list|,
name|u_int
modifier|*
name|skip_addr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ahc_download_instr
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|u_int
name|instrptr
parameter_list|,
name|uint8_t
modifier|*
name|dconsts
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ahc_other_scb_timeout
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|struct
name|scb
modifier|*
name|scb
parameter_list|,
name|struct
name|scb
modifier|*
name|other_scb
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|AHC_TARGET_MODE
end_ifdef

begin_function_decl
specifier|static
name|void
name|ahc_queue_lstate_event
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|struct
name|ahc_tmode_lstate
modifier|*
name|lstate
parameter_list|,
name|u_int
name|initiator_id
parameter_list|,
name|u_int
name|event_type
parameter_list|,
name|u_int
name|event_arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ahc_update_scsiid
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|u_int
name|targid_mask
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ahc_handle_target_cmd
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|struct
name|target_cmd
modifier|*
name|cmd
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/************************* Sequencer Execution Control ************************/
end_comment

begin_comment
comment|/*  * Restart the sequencer program from address zero  */
end_comment

begin_function
name|void
name|ahc_restart
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|)
block|{
name|ahc_pause
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
comment|/* No more pending messages. */
name|ahc_clear_msg_state
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCSISIGO
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* De-assert BSY */
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|MSG_OUT
argument_list|,
name|MSG_NOOP
argument_list|)
expr_stmt|;
comment|/* No message to send */
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SXFRCTL1
argument_list|,
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SXFRCTL1
argument_list|)
operator|&
operator|~
name|BITBUCKET
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|LASTPHASE
argument_list|,
name|P_BUSFREE
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SAVED_SCSIID
argument_list|,
literal|0xFF
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SAVED_LUN
argument_list|,
literal|0xFF
argument_list|)
expr_stmt|;
comment|/* 	 * Ensure that the sequencer's idea of TQINPOS 	 * matches our own.  The sequencer increments TQINPOS 	 * only after it sees a DMA complete and a reset could 	 * occur before the increment leaving the kernel to believe 	 * the command arrived but the sequencer to not. 	 */
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|TQINPOS
argument_list|,
name|ahc
operator|->
name|tqinfifonext
argument_list|)
expr_stmt|;
comment|/* Always allow reselection */
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCSISEQ
argument_list|,
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCSISEQ_TEMPLATE
argument_list|)
operator|&
operator|(
name|ENSELI
operator||
name|ENRSELI
operator||
name|ENAUTOATNP
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ahc
operator|->
name|features
operator|&
name|AHC_CMD_CHAN
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* Ensure that no DMA operations are in progress */
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|CCSCBCNT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|CCSGCTL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|CCSCBCTL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If we were in the process of DMA'ing SCB data into 	 * an SCB, replace that SCB on the free list.  This prevents 	 * an SCB leak. 	 */
if|if
condition|(
operator|(
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SEQ_FLAGS2
argument_list|)
operator|&
name|SCB_DMA
operator|)
operator|!=
literal|0
condition|)
block|{
name|ahc_add_curscb_to_free_list
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SEQ_FLAGS2
argument_list|,
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SEQ_FLAGS2
argument_list|)
operator|&
operator|~
name|SCB_DMA
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Clear any pending sequencer interrupt.  It is no 	 * longer relevant since we're resetting the Program 	 * Counter. 	 */
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|CLRINT
argument_list|,
name|CLRSEQINT
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|MWI_RESIDUAL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SEQCTL
argument_list|,
name|ahc
operator|->
name|seqctl
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SEQADDR0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SEQADDR1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ahc_unpause
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/************************* Input/Output Queues ********************************/
end_comment

begin_function
name|void
name|ahc_run_qoutfifo
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|)
block|{
name|struct
name|scb
modifier|*
name|scb
decl_stmt|;
name|u_int
name|scb_index
decl_stmt|;
name|ahc_sync_qoutfifo
argument_list|(
name|ahc
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
while|while
condition|(
name|ahc
operator|->
name|qoutfifo
index|[
name|ahc
operator|->
name|qoutfifonext
index|]
operator|!=
name|SCB_LIST_NULL
condition|)
block|{
name|scb_index
operator|=
name|ahc
operator|->
name|qoutfifo
index|[
name|ahc
operator|->
name|qoutfifonext
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|ahc
operator|->
name|qoutfifonext
operator|&
literal|0x03
operator|)
operator|==
literal|0x03
condition|)
block|{
name|u_int
name|modnext
decl_stmt|;
comment|/* 			 * Clear 32bits of QOUTFIFO at a time 			 * so that we don't clobber an incoming 			 * byte DMA to the array on architectures 			 * that only support 32bit load and store 			 * operations. 			 */
name|modnext
operator|=
name|ahc
operator|->
name|qoutfifonext
operator|&
operator|~
literal|0x3
expr_stmt|;
operator|*
operator|(
operator|(
name|uint32_t
operator|*
operator|)
operator|(
operator|&
name|ahc
operator|->
name|qoutfifo
index|[
name|modnext
index|]
operator|)
operator|)
operator|=
literal|0xFFFFFFFFUL
expr_stmt|;
name|aic_dmamap_sync
argument_list|(
name|ahc
argument_list|,
name|ahc
operator|->
name|shared_data_dmat
argument_list|,
name|ahc
operator|->
name|shared_data_dmamap
argument_list|,
comment|/*offset*/
name|modnext
argument_list|,
comment|/*len*/
literal|4
argument_list|,
name|BUS_DMASYNC_PREREAD
argument_list|)
expr_stmt|;
block|}
name|ahc
operator|->
name|qoutfifonext
operator|++
expr_stmt|;
name|scb
operator|=
name|ahc_lookup_scb
argument_list|(
name|ahc
argument_list|,
name|scb_index
argument_list|)
expr_stmt|;
if|if
condition|(
name|scb
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"%s: WARNING no command for scb %d "
literal|"(cmdcmplt)\nQOUTPOS = %d\n"
argument_list|,
name|ahc_name
argument_list|(
name|ahc
argument_list|)
argument_list|,
name|scb_index
argument_list|,
operator|(
name|ahc
operator|->
name|qoutfifonext
operator|-
literal|1
operator|)
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * Save off the residual 		 * if there is one. 		 */
name|ahc_update_residual
argument_list|(
name|ahc
argument_list|,
name|scb
argument_list|)
expr_stmt|;
name|ahc_done
argument_list|(
name|ahc
argument_list|,
name|scb
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|ahc_run_untagged_queues
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
name|ahc_run_untagged_queue
argument_list|(
name|ahc
argument_list|,
operator|&
name|ahc
operator|->
name|untagged_queues
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ahc_run_untagged_queue
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|struct
name|scb_tailq
modifier|*
name|queue
parameter_list|)
block|{
name|struct
name|scb
modifier|*
name|scb
decl_stmt|;
if|if
condition|(
name|ahc
operator|->
name|untagged_queue_lock
operator|!=
literal|0
condition|)
return|return;
if|if
condition|(
operator|(
name|scb
operator|=
name|TAILQ_FIRST
argument_list|(
name|queue
argument_list|)
operator|)
operator|!=
name|NULL
operator|&&
operator|(
name|scb
operator|->
name|flags
operator|&
name|SCB_ACTIVE
operator|)
operator|==
literal|0
condition|)
block|{
name|scb
operator|->
name|flags
operator||=
name|SCB_ACTIVE
expr_stmt|;
comment|/* 		 * Timers are disabled while recovery is in progress. 		 */
name|aic_scb_timer_start
argument_list|(
name|scb
argument_list|)
expr_stmt|;
name|ahc_queue_scb
argument_list|(
name|ahc
argument_list|,
name|scb
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/************************* Interrupt Handling *********************************/
end_comment

begin_function
name|void
name|ahc_handle_brkadrint
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|)
block|{
comment|/* 	 * We upset the sequencer :-( 	 * Lookup the error message 	 */
name|int
name|i
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|ERROR
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|error
operator|!=
literal|1
operator|&&
name|i
operator|<
name|num_errors
condition|;
name|i
operator|++
control|)
name|error
operator|>>=
literal|1
expr_stmt|;
name|printf
argument_list|(
literal|"%s: brkadrint, %s at seqaddr = 0x%x\n"
argument_list|,
name|ahc_name
argument_list|(
name|ahc
argument_list|)
argument_list|,
name|ahc_hard_errors
index|[
name|i
index|]
operator|.
name|errmesg
argument_list|,
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SEQADDR0
argument_list|)
operator||
operator|(
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SEQADDR1
argument_list|)
operator|<<
literal|8
operator|)
argument_list|)
expr_stmt|;
name|ahc_dump_card_state
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
comment|/* Tell everyone that this HBA is no longer available */
name|ahc_abort_scbs
argument_list|(
name|ahc
argument_list|,
name|CAM_TARGET_WILDCARD
argument_list|,
name|ALL_CHANNELS
argument_list|,
name|CAM_LUN_WILDCARD
argument_list|,
name|SCB_LIST_NULL
argument_list|,
name|ROLE_UNKNOWN
argument_list|,
name|CAM_NO_HBA
argument_list|)
expr_stmt|;
comment|/* Disable all interrupt sources by resetting the controller */
name|ahc_shutdown
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ahc_handle_seqint
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|u_int
name|intstat
parameter_list|)
block|{
name|struct
name|scb
modifier|*
name|scb
decl_stmt|;
name|struct
name|ahc_devinfo
name|devinfo
decl_stmt|;
name|ahc_fetch_devinfo
argument_list|(
name|ahc
argument_list|,
operator|&
name|devinfo
argument_list|)
expr_stmt|;
comment|/* 	 * Clear the upper byte that holds SEQINT status 	 * codes and clear the SEQINT bit. We will unpause 	 * the sequencer, if appropriate, after servicing 	 * the request. 	 */
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|CLRINT
argument_list|,
name|CLRSEQINT
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|intstat
operator|&
name|SEQINT_MASK
condition|)
block|{
case|case
name|BAD_STATUS
case|:
block|{
name|u_int
name|scb_index
decl_stmt|;
name|struct
name|hardware_scb
modifier|*
name|hscb
decl_stmt|;
comment|/* 		 * Set the default return value to 0 (don't 		 * send sense).  The sense code will change 		 * this if needed. 		 */
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|RETURN_1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 		 * The sequencer will notify us when a command 		 * has an error that would be of interest to 		 * the kernel.  This allows us to leave the sequencer 		 * running in the common case of command completes 		 * without error.  The sequencer will already have 		 * dma'd the SCB back up to us, so we can reference 		 * the in kernel copy directly. 		 */
name|scb_index
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCB_TAG
argument_list|)
expr_stmt|;
name|scb
operator|=
name|ahc_lookup_scb
argument_list|(
name|ahc
argument_list|,
name|scb_index
argument_list|)
expr_stmt|;
if|if
condition|(
name|scb
operator|==
name|NULL
condition|)
block|{
name|ahc_print_devinfo
argument_list|(
name|ahc
argument_list|,
operator|&
name|devinfo
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"ahc_intr - referenced scb "
literal|"not valid during seqint 0x%x scb(%d)\n"
argument_list|,
name|intstat
argument_list|,
name|scb_index
argument_list|)
expr_stmt|;
name|ahc_dump_card_state
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"for safety"
argument_list|)
expr_stmt|;
goto|goto
name|unpause
goto|;
block|}
name|hscb
operator|=
name|scb
operator|->
name|hscb
expr_stmt|;
comment|/* Don't want to clobber the original sense code */
if|if
condition|(
operator|(
name|scb
operator|->
name|flags
operator|&
name|SCB_SENSE
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* 			 * Clear the SCB_SENSE Flag and have 			 * the sequencer do a normal command 			 * complete. 			 */
name|scb
operator|->
name|flags
operator|&=
operator|~
name|SCB_SENSE
expr_stmt|;
name|aic_set_transaction_status
argument_list|(
name|scb
argument_list|,
name|CAM_AUTOSENSE_FAIL
argument_list|)
expr_stmt|;
break|break;
block|}
name|aic_set_transaction_status
argument_list|(
name|scb
argument_list|,
name|CAM_SCSI_STATUS_ERROR
argument_list|)
expr_stmt|;
comment|/* Freeze the queue until the client sees the error. */
name|ahc_freeze_devq
argument_list|(
name|ahc
argument_list|,
name|scb
argument_list|)
expr_stmt|;
name|aic_freeze_scb
argument_list|(
name|scb
argument_list|)
expr_stmt|;
name|aic_set_scsi_status
argument_list|(
name|scb
argument_list|,
name|hscb
operator|->
name|shared_data
operator|.
name|status
operator|.
name|scsi_status
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|hscb
operator|->
name|shared_data
operator|.
name|status
operator|.
name|scsi_status
condition|)
block|{
case|case
name|SCSI_STATUS_OK
case|:
name|printf
argument_list|(
literal|"%s: Interrupted for staus of 0???\n"
argument_list|,
name|ahc_name
argument_list|(
name|ahc
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCSI_STATUS_CMD_TERMINATED
case|:
case|case
name|SCSI_STATUS_CHECK_COND
case|:
block|{
name|struct
name|ahc_dma_seg
modifier|*
name|sg
decl_stmt|;
name|struct
name|scsi_sense
modifier|*
name|sc
decl_stmt|;
name|struct
name|ahc_initiator_tinfo
modifier|*
name|targ_info
decl_stmt|;
name|struct
name|ahc_tmode_tstate
modifier|*
name|tstate
decl_stmt|;
name|struct
name|ahc_transinfo
modifier|*
name|tinfo
decl_stmt|;
ifdef|#
directive|ifdef
name|AHC_DEBUG
if|if
condition|(
name|ahc_debug
operator|&
name|AHC_SHOW_SENSE
condition|)
block|{
name|ahc_print_path
argument_list|(
name|ahc
argument_list|,
name|scb
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"SCB %d: requests Check Status\n"
argument_list|,
name|scb
operator|->
name|hscb
operator|->
name|tag
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|aic_perform_autosense
argument_list|(
name|scb
argument_list|)
operator|==
literal|0
condition|)
break|break;
name|targ_info
operator|=
name|ahc_fetch_transinfo
argument_list|(
name|ahc
argument_list|,
name|devinfo
operator|.
name|channel
argument_list|,
name|devinfo
operator|.
name|our_scsiid
argument_list|,
name|devinfo
operator|.
name|target
argument_list|,
operator|&
name|tstate
argument_list|)
expr_stmt|;
name|tinfo
operator|=
operator|&
name|targ_info
operator|->
name|curr
expr_stmt|;
name|sg
operator|=
name|scb
operator|->
name|sg_list
expr_stmt|;
name|sc
operator|=
operator|(
expr|struct
name|scsi_sense
operator|*
operator|)
operator|(
operator|&
name|hscb
operator|->
name|shared_data
operator|.
name|cdb
operator|)
expr_stmt|;
comment|/* 			 * Save off the residual if there is one. 			 */
name|ahc_update_residual
argument_list|(
name|ahc
argument_list|,
name|scb
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|AHC_DEBUG
if|if
condition|(
name|ahc_debug
operator|&
name|AHC_SHOW_SENSE
condition|)
block|{
name|ahc_print_path
argument_list|(
name|ahc
argument_list|,
name|scb
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Sending Sense\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|sg
operator|->
name|addr
operator|=
name|ahc_get_sense_bufaddr
argument_list|(
name|ahc
argument_list|,
name|scb
argument_list|)
expr_stmt|;
name|sg
operator|->
name|len
operator|=
name|aic_get_sense_bufsize
argument_list|(
name|ahc
argument_list|,
name|scb
argument_list|)
expr_stmt|;
name|sg
operator|->
name|len
operator||=
name|AHC_DMA_LAST_SEG
expr_stmt|;
comment|/* Fixup byte order */
name|sg
operator|->
name|addr
operator|=
name|aic_htole32
argument_list|(
name|sg
operator|->
name|addr
argument_list|)
expr_stmt|;
name|sg
operator|->
name|len
operator|=
name|aic_htole32
argument_list|(
name|sg
operator|->
name|len
argument_list|)
expr_stmt|;
name|sc
operator|->
name|opcode
operator|=
name|REQUEST_SENSE
expr_stmt|;
name|sc
operator|->
name|byte2
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|tinfo
operator|->
name|protocol_version
operator|<=
name|SCSI_REV_2
operator|&&
name|SCB_GET_LUN
argument_list|(
name|scb
argument_list|)
operator|<
literal|8
condition|)
name|sc
operator|->
name|byte2
operator|=
name|SCB_GET_LUN
argument_list|(
name|scb
argument_list|)
operator|<<
literal|5
expr_stmt|;
name|sc
operator|->
name|unused
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|unused
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|length
operator|=
name|sg
operator|->
name|len
expr_stmt|;
name|sc
operator|->
name|control
operator|=
literal|0
expr_stmt|;
comment|/* 			 * We can't allow the target to disconnect. 			 * This will be an untagged transaction and 			 * having the target disconnect will make this 			 * transaction indestinguishable from outstanding 			 * tagged transactions. 			 */
name|hscb
operator|->
name|control
operator|=
literal|0
expr_stmt|;
comment|/* 			 * This request sense could be because the 			 * the device lost power or in some other 			 * way has lost our transfer negotiations. 			 * Renegotiate if appropriate.  Unit attention 			 * errors will be reported before any data 			 * phases occur. 			 */
if|if
condition|(
name|aic_get_residual
argument_list|(
name|scb
argument_list|)
operator|==
name|aic_get_transfer_length
argument_list|(
name|scb
argument_list|)
condition|)
block|{
name|ahc_update_neg_request
argument_list|(
name|ahc
argument_list|,
operator|&
name|devinfo
argument_list|,
name|tstate
argument_list|,
name|targ_info
argument_list|,
name|AHC_NEG_IF_NON_ASYNC
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tstate
operator|->
name|auto_negotiate
operator|&
name|devinfo
operator|.
name|target_mask
condition|)
block|{
name|hscb
operator|->
name|control
operator||=
name|MK_MESSAGE
expr_stmt|;
name|scb
operator|->
name|flags
operator|&=
operator|~
name|SCB_NEGOTIATE
expr_stmt|;
name|scb
operator|->
name|flags
operator||=
name|SCB_AUTO_NEGOTIATE
expr_stmt|;
block|}
name|hscb
operator|->
name|cdb_len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|sc
argument_list|)
expr_stmt|;
name|hscb
operator|->
name|dataptr
operator|=
name|sg
operator|->
name|addr
expr_stmt|;
name|hscb
operator|->
name|datacnt
operator|=
name|sg
operator|->
name|len
expr_stmt|;
name|hscb
operator|->
name|sgptr
operator|=
name|scb
operator|->
name|sg_list_phys
operator||
name|SG_FULL_RESID
expr_stmt|;
name|hscb
operator|->
name|sgptr
operator|=
name|aic_htole32
argument_list|(
name|hscb
operator|->
name|sgptr
argument_list|)
expr_stmt|;
name|scb
operator|->
name|sg_count
operator|=
literal|1
expr_stmt|;
name|scb
operator|->
name|flags
operator||=
name|SCB_SENSE
expr_stmt|;
name|ahc_qinfifo_requeue_tail
argument_list|(
name|ahc
argument_list|,
name|scb
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|RETURN_1
argument_list|,
name|SEND_SENSE
argument_list|)
expr_stmt|;
comment|/* 			 * Ensure we have enough time to actually 			 * retrieve the sense, but only schedule 			 * the timer if we are not in recovery or 			 * this is a recovery SCB that is allowed 			 * to have an active timer. 			 */
if|if
condition|(
name|ahc
operator|->
name|scb_data
operator|->
name|recovery_scbs
operator|==
literal|0
operator|||
operator|(
name|scb
operator|->
name|flags
operator|&
name|SCB_RECOVERY_SCB
operator|)
operator|!=
literal|0
condition|)
name|aic_scb_timer_reset
argument_list|(
name|scb
argument_list|,
literal|5
operator|*
literal|1000
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
break|break;
block|}
break|break;
block|}
case|case
name|NO_MATCH
case|:
block|{
comment|/* Ensure we don't leave the selection hardware on */
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCSISEQ
argument_list|,
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCSISEQ
argument_list|)
operator|&
operator|(
name|ENSELI
operator||
name|ENRSELI
operator||
name|ENAUTOATNP
operator|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s:%c:%d: no active SCB for reconnecting "
literal|"target - issuing BUS DEVICE RESET\n"
argument_list|,
name|ahc_name
argument_list|(
name|ahc
argument_list|)
argument_list|,
name|devinfo
operator|.
name|channel
argument_list|,
name|devinfo
operator|.
name|target
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"SAVED_SCSIID == 0x%x, SAVED_LUN == 0x%x, "
literal|"ARG_1 == 0x%x ACCUM = 0x%x\n"
argument_list|,
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SAVED_SCSIID
argument_list|)
argument_list|,
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SAVED_LUN
argument_list|)
argument_list|,
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|ARG_1
argument_list|)
argument_list|,
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|ACCUM
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"SEQ_FLAGS == 0x%x, SCBPTR == 0x%x, BTT == 0x%x, "
literal|"SINDEX == 0x%x\n"
argument_list|,
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SEQ_FLAGS
argument_list|)
argument_list|,
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCBPTR
argument_list|)
argument_list|,
name|ahc_index_busy_tcl
argument_list|(
name|ahc
argument_list|,
name|BUILD_TCL
argument_list|(
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SAVED_SCSIID
argument_list|)
argument_list|,
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SAVED_LUN
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SINDEX
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"SCSIID == 0x%x, SCB_SCSIID == 0x%x, SCB_LUN == 0x%x, "
literal|"SCB_TAG == 0x%x, SCB_CONTROL == 0x%x\n"
argument_list|,
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCSIID
argument_list|)
argument_list|,
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCB_SCSIID
argument_list|)
argument_list|,
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCB_LUN
argument_list|)
argument_list|,
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCB_TAG
argument_list|)
argument_list|,
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCB_CONTROL
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"SCSIBUSL == 0x%x, SCSISIGI == 0x%x\n"
argument_list|,
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCSIBUSL
argument_list|)
argument_list|,
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCSISIGI
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"SXFRCTL0 == 0x%x\n"
argument_list|,
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SXFRCTL0
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"SEQCTL == 0x%x\n"
argument_list|,
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SEQCTL
argument_list|)
argument_list|)
expr_stmt|;
name|ahc_dump_card_state
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
name|ahc
operator|->
name|msgout_buf
index|[
literal|0
index|]
operator|=
name|MSG_BUS_DEV_RESET
expr_stmt|;
name|ahc
operator|->
name|msgout_len
operator|=
literal|1
expr_stmt|;
name|ahc
operator|->
name|msgout_index
operator|=
literal|0
expr_stmt|;
name|ahc
operator|->
name|msg_type
operator|=
name|MSG_TYPE_INITIATOR_MSGOUT
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|MSG_OUT
argument_list|,
name|HOST_MSG
argument_list|)
expr_stmt|;
name|ahc_assert_atn
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|SEND_REJECT
case|:
block|{
name|u_int
name|rejbyte
init|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|ACCUM
argument_list|)
decl_stmt|;
name|printf
argument_list|(
literal|"%s:%c:%d: Warning - unknown message received from "
literal|"target (0x%x).  Rejecting\n"
argument_list|,
name|ahc_name
argument_list|(
name|ahc
argument_list|)
argument_list|,
name|devinfo
operator|.
name|channel
argument_list|,
name|devinfo
operator|.
name|target
argument_list|,
name|rejbyte
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|PROTO_VIOLATION
case|:
block|{
name|ahc_handle_proto_violation
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|IGN_WIDE_RES
case|:
name|ahc_handle_ign_wide_residue
argument_list|(
name|ahc
argument_list|,
operator|&
name|devinfo
argument_list|)
expr_stmt|;
break|break;
case|case
name|PDATA_REINIT
case|:
name|ahc_reinitialize_dataptrs
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
break|break;
case|case
name|BAD_PHASE
case|:
block|{
name|u_int
name|lastphase
decl_stmt|;
name|lastphase
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|LASTPHASE
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s:%c:%d: unknown scsi bus phase %x, "
literal|"lastphase = 0x%x.  Attempting to continue\n"
argument_list|,
name|ahc_name
argument_list|(
name|ahc
argument_list|)
argument_list|,
name|devinfo
operator|.
name|channel
argument_list|,
name|devinfo
operator|.
name|target
argument_list|,
name|lastphase
argument_list|,
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCSISIGI
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|MISSED_BUSFREE
case|:
block|{
name|u_int
name|lastphase
decl_stmt|;
name|lastphase
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|LASTPHASE
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s:%c:%d: Missed busfree. "
literal|"Lastphase = 0x%x, Curphase = 0x%x\n"
argument_list|,
name|ahc_name
argument_list|(
name|ahc
argument_list|)
argument_list|,
name|devinfo
operator|.
name|channel
argument_list|,
name|devinfo
operator|.
name|target
argument_list|,
name|lastphase
argument_list|,
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCSISIGI
argument_list|)
argument_list|)
expr_stmt|;
name|ahc_restart
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
return|return;
block|}
case|case
name|HOST_MSG_LOOP
case|:
block|{
comment|/* 		 * The sequencer has encountered a message phase 		 * that requires host assistance for completion. 		 * While handling the message phase(s), we will be 		 * notified by the sequencer after each byte is 		 * transfered so we can track bus phase changes. 		 * 		 * If this is the first time we've seen a HOST_MSG_LOOP 		 * interrupt, initialize the state of the host message 		 * loop. 		 */
if|if
condition|(
name|ahc
operator|->
name|msg_type
operator|==
name|MSG_TYPE_NONE
condition|)
block|{
name|struct
name|scb
modifier|*
name|scb
decl_stmt|;
name|u_int
name|scb_index
decl_stmt|;
name|u_int
name|bus_phase
decl_stmt|;
name|bus_phase
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCSISIGI
argument_list|)
operator|&
name|PHASE_MASK
expr_stmt|;
if|if
condition|(
name|bus_phase
operator|!=
name|P_MESGIN
operator|&&
name|bus_phase
operator|!=
name|P_MESGOUT
condition|)
block|{
name|printf
argument_list|(
literal|"ahc_intr: HOST_MSG_LOOP bad "
literal|"phase 0x%x\n"
argument_list|,
name|bus_phase
argument_list|)
expr_stmt|;
comment|/* 				 * Probably transitioned to bus free before 				 * we got here.  Just punt the message. 				 */
name|ahc_clear_intstat
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
name|ahc_restart
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
return|return;
block|}
name|scb_index
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCB_TAG
argument_list|)
expr_stmt|;
name|scb
operator|=
name|ahc_lookup_scb
argument_list|(
name|ahc
argument_list|,
name|scb_index
argument_list|)
expr_stmt|;
if|if
condition|(
name|devinfo
operator|.
name|role
operator|==
name|ROLE_INITIATOR
condition|)
block|{
if|if
condition|(
name|scb
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"HOST_MSG_LOOP with "
literal|"invalid SCB %x\n"
argument_list|,
name|scb_index
argument_list|)
expr_stmt|;
if|if
condition|(
name|bus_phase
operator|==
name|P_MESGOUT
condition|)
name|ahc_setup_initiator_msgout
argument_list|(
name|ahc
argument_list|,
operator|&
name|devinfo
argument_list|,
name|scb
argument_list|)
expr_stmt|;
else|else
block|{
name|ahc
operator|->
name|msg_type
operator|=
name|MSG_TYPE_INITIATOR_MSGIN
expr_stmt|;
name|ahc
operator|->
name|msgin_index
operator|=
literal|0
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|AHC_TARGET_MODE
else|else
block|{
if|if
condition|(
name|bus_phase
operator|==
name|P_MESGOUT
condition|)
block|{
name|ahc
operator|->
name|msg_type
operator|=
name|MSG_TYPE_TARGET_MSGOUT
expr_stmt|;
name|ahc
operator|->
name|msgin_index
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|ahc_setup_target_msgin
argument_list|(
name|ahc
argument_list|,
operator|&
name|devinfo
argument_list|,
name|scb
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
name|ahc_handle_message_phase
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|PERR_DETECTED
case|:
block|{
comment|/* 		 * If we've cleared the parity error interrupt 		 * but the sequencer still believes that SCSIPERR 		 * is true, it must be that the parity error is 		 * for the currently presented byte on the bus, 		 * and we are not in a phase (data-in) where we will 		 * eventually ack this byte.  Ack the byte and 		 * throw it away in the hope that the target will 		 * take us to message out to deliver the appropriate 		 * error message. 		 */
if|if
condition|(
operator|(
name|intstat
operator|&
name|SCSIINT
operator|)
operator|==
literal|0
operator|&&
operator|(
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SSTAT1
argument_list|)
operator|&
name|SCSIPERR
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|ahc
operator|->
name|features
operator|&
name|AHC_DT
operator|)
operator|==
literal|0
condition|)
block|{
name|u_int
name|curphase
decl_stmt|;
comment|/* 				 * The hardware will only let you ack bytes 				 * if the expected phase in SCSISIGO matches 				 * the current phase.  Make sure this is 				 * currently the case. 				 */
name|curphase
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCSISIGI
argument_list|)
operator|&
name|PHASE_MASK
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|LASTPHASE
argument_list|,
name|curphase
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCSISIGO
argument_list|,
name|curphase
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCSISIGI
argument_list|)
operator|&
operator|(
name|CDI
operator||
name|MSGI
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
name|int
name|wait
decl_stmt|;
comment|/* 				 * In a data phase.  Faster to bitbucket 				 * the data than to individually ack each 				 * byte.  This is also the only strategy 				 * that will work with AUTOACK enabled. 				 */
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SXFRCTL1
argument_list|,
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SXFRCTL1
argument_list|)
operator||
name|BITBUCKET
argument_list|)
expr_stmt|;
name|wait
operator|=
literal|5000
expr_stmt|;
while|while
condition|(
operator|--
name|wait
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCSISIGI
argument_list|)
operator|&
operator|(
name|CDI
operator||
name|MSGI
operator|)
operator|)
operator|!=
literal|0
condition|)
break|break;
name|aic_delay
argument_list|(
literal|100
argument_list|)
expr_stmt|;
block|}
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SXFRCTL1
argument_list|,
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SXFRCTL1
argument_list|)
operator|&
operator|~
name|BITBUCKET
argument_list|)
expr_stmt|;
if|if
condition|(
name|wait
operator|==
literal|0
condition|)
block|{
name|struct
name|scb
modifier|*
name|scb
decl_stmt|;
name|u_int
name|scb_index
decl_stmt|;
name|ahc_print_devinfo
argument_list|(
name|ahc
argument_list|,
operator|&
name|devinfo
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Unable to clear parity error.  "
literal|"Resetting bus.\n"
argument_list|)
expr_stmt|;
name|scb_index
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCB_TAG
argument_list|)
expr_stmt|;
name|scb
operator|=
name|ahc_lookup_scb
argument_list|(
name|ahc
argument_list|,
name|scb_index
argument_list|)
expr_stmt|;
if|if
condition|(
name|scb
operator|!=
name|NULL
condition|)
name|aic_set_transaction_status
argument_list|(
name|scb
argument_list|,
name|CAM_UNCOR_PARITY
argument_list|)
expr_stmt|;
name|ahc_reset_channel
argument_list|(
name|ahc
argument_list|,
name|devinfo
operator|.
name|channel
argument_list|,
comment|/*init reset*/
name|TRUE
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCSIDATL
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
block|}
case|case
name|DATA_OVERRUN
case|:
block|{
comment|/* 		 * When the sequencer detects an overrun, it 		 * places the controller in "BITBUCKET" mode 		 * and allows the target to complete its transfer. 		 * Unfortunately, none of the counters get updated 		 * when the controller is in this mode, so we have 		 * no way of knowing how large the overrun was. 		 */
name|u_int
name|scbindex
init|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCB_TAG
argument_list|)
decl_stmt|;
name|u_int
name|lastphase
init|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|LASTPHASE
argument_list|)
decl_stmt|;
name|u_int
name|i
decl_stmt|;
name|scb
operator|=
name|ahc_lookup_scb
argument_list|(
name|ahc
argument_list|,
name|scbindex
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_phases
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|lastphase
operator|==
name|ahc_phase_table
index|[
name|i
index|]
operator|.
name|phase
condition|)
break|break;
block|}
name|ahc_print_path
argument_list|(
name|ahc
argument_list|,
name|scb
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"data overrun detected %s."
literal|"  Tag == 0x%x.\n"
argument_list|,
name|ahc_phase_table
index|[
name|i
index|]
operator|.
name|phasemsg
argument_list|,
name|scb
operator|->
name|hscb
operator|->
name|tag
argument_list|)
expr_stmt|;
name|ahc_print_path
argument_list|(
name|ahc
argument_list|,
name|scb
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s seen Data Phase.  Length = %ld.  NumSGs = %d.\n"
argument_list|,
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SEQ_FLAGS
argument_list|)
operator|&
name|DPHASE
condition|?
literal|"Have"
else|:
literal|"Haven't"
argument_list|,
name|aic_get_transfer_length
argument_list|(
name|scb
argument_list|)
argument_list|,
name|scb
operator|->
name|sg_count
argument_list|)
expr_stmt|;
if|if
condition|(
name|scb
operator|->
name|sg_count
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|scb
operator|->
name|sg_count
condition|;
name|i
operator|++
control|)
block|{
name|printf
argument_list|(
literal|"sg[%d] - Addr 0x%x%x : Length %d\n"
argument_list|,
name|i
argument_list|,
operator|(
name|aic_le32toh
argument_list|(
name|scb
operator|->
name|sg_list
index|[
name|i
index|]
operator|.
name|len
argument_list|)
operator|>>
literal|24
operator|&
name|SG_HIGH_ADDR_BITS
operator|)
argument_list|,
name|aic_le32toh
argument_list|(
name|scb
operator|->
name|sg_list
index|[
name|i
index|]
operator|.
name|addr
argument_list|)
argument_list|,
name|aic_le32toh
argument_list|(
name|scb
operator|->
name|sg_list
index|[
name|i
index|]
operator|.
name|len
argument_list|)
operator|&
name|AHC_SG_LEN_MASK
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 		 * Set this and it will take effect when the 		 * target does a command complete. 		 */
name|ahc_freeze_devq
argument_list|(
name|ahc
argument_list|,
name|scb
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|scb
operator|->
name|flags
operator|&
name|SCB_SENSE
operator|)
operator|==
literal|0
condition|)
block|{
name|aic_set_transaction_status
argument_list|(
name|scb
argument_list|,
name|CAM_DATA_RUN_ERR
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|scb
operator|->
name|flags
operator|&=
operator|~
name|SCB_SENSE
expr_stmt|;
name|aic_set_transaction_status
argument_list|(
name|scb
argument_list|,
name|CAM_AUTOSENSE_FAIL
argument_list|)
expr_stmt|;
block|}
name|aic_freeze_scb
argument_list|(
name|scb
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ahc
operator|->
name|features
operator|&
name|AHC_ULTRA2
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* 			 * Clear the channel in case we return 			 * to data phase later. 			 */
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SXFRCTL0
argument_list|,
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SXFRCTL0
argument_list|)
operator||
name|CLRSTCNT
operator||
name|CLRCHN
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SXFRCTL0
argument_list|,
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SXFRCTL0
argument_list|)
operator||
name|CLRSTCNT
operator||
name|CLRCHN
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|ahc
operator|->
name|flags
operator|&
name|AHC_39BIT_ADDRESSING
operator|)
operator|!=
literal|0
condition|)
block|{
name|u_int
name|dscommand1
decl_stmt|;
comment|/* Ensure HHADDR is 0 for future DMA operations. */
name|dscommand1
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|DSCOMMAND1
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|DSCOMMAND1
argument_list|,
name|dscommand1
operator||
name|HADDLDSEL0
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|HADDR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|DSCOMMAND1
argument_list|,
name|dscommand1
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|MKMSG_FAILED
case|:
block|{
name|u_int
name|scbindex
decl_stmt|;
name|printf
argument_list|(
literal|"%s:%c:%d:%d: Attempt to issue message failed\n"
argument_list|,
name|ahc_name
argument_list|(
name|ahc
argument_list|)
argument_list|,
name|devinfo
operator|.
name|channel
argument_list|,
name|devinfo
operator|.
name|target
argument_list|,
name|devinfo
operator|.
name|lun
argument_list|)
expr_stmt|;
name|scbindex
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCB_TAG
argument_list|)
expr_stmt|;
name|scb
operator|=
name|ahc_lookup_scb
argument_list|(
name|ahc
argument_list|,
name|scbindex
argument_list|)
expr_stmt|;
if|if
condition|(
name|scb
operator|!=
name|NULL
operator|&&
operator|(
name|scb
operator|->
name|flags
operator|&
name|SCB_RECOVERY_SCB
operator|)
operator|!=
literal|0
condition|)
comment|/* 			 * Ensure that we didn't put a second instance of this 			 * SCB into the QINFIFO. 			 */
name|ahc_search_qinfifo
argument_list|(
name|ahc
argument_list|,
name|SCB_GET_TARGET
argument_list|(
name|ahc
argument_list|,
name|scb
argument_list|)
argument_list|,
name|SCB_GET_CHANNEL
argument_list|(
name|ahc
argument_list|,
name|scb
argument_list|)
argument_list|,
name|SCB_GET_LUN
argument_list|(
name|scb
argument_list|)
argument_list|,
name|scb
operator|->
name|hscb
operator|->
name|tag
argument_list|,
name|ROLE_INITIATOR
argument_list|,
comment|/*status*/
literal|0
argument_list|,
name|SEARCH_REMOVE
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|NO_FREE_SCB
case|:
block|{
name|printf
argument_list|(
literal|"%s: No free or disconnected SCBs\n"
argument_list|,
name|ahc_name
argument_list|(
name|ahc
argument_list|)
argument_list|)
expr_stmt|;
name|ahc_dump_card_state
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"for safety"
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|SCB_MISMATCH
case|:
block|{
name|u_int
name|scbptr
decl_stmt|;
name|scbptr
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCBPTR
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Bogus TAG after DMA.  SCBPTR %d, tag %d, our tag %d\n"
argument_list|,
name|scbptr
argument_list|,
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|ARG_1
argument_list|)
argument_list|,
name|ahc
operator|->
name|scb_data
operator|->
name|hscbs
index|[
name|scbptr
index|]
operator|.
name|tag
argument_list|)
expr_stmt|;
name|ahc_dump_card_state
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"for saftey"
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|OUT_OF_RANGE
case|:
block|{
name|printf
argument_list|(
literal|"%s: BTT calculation out of range\n"
argument_list|,
name|ahc_name
argument_list|(
name|ahc
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"SAVED_SCSIID == 0x%x, SAVED_LUN == 0x%x, "
literal|"ARG_1 == 0x%x ACCUM = 0x%x\n"
argument_list|,
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SAVED_SCSIID
argument_list|)
argument_list|,
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SAVED_LUN
argument_list|)
argument_list|,
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|ARG_1
argument_list|)
argument_list|,
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|ACCUM
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"SEQ_FLAGS == 0x%x, SCBPTR == 0x%x, BTT == 0x%x, "
literal|"SINDEX == 0x%x\n, A == 0x%x\n"
argument_list|,
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SEQ_FLAGS
argument_list|)
argument_list|,
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCBPTR
argument_list|)
argument_list|,
name|ahc_index_busy_tcl
argument_list|(
name|ahc
argument_list|,
name|BUILD_TCL
argument_list|(
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SAVED_SCSIID
argument_list|)
argument_list|,
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SAVED_LUN
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SINDEX
argument_list|)
argument_list|,
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|ACCUM
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"SCSIID == 0x%x, SCB_SCSIID == 0x%x, SCB_LUN == 0x%x, "
literal|"SCB_TAG == 0x%x, SCB_CONTROL == 0x%x\n"
argument_list|,
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCSIID
argument_list|)
argument_list|,
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCB_SCSIID
argument_list|)
argument_list|,
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCB_LUN
argument_list|)
argument_list|,
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCB_TAG
argument_list|)
argument_list|,
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCB_CONTROL
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"SCSIBUSL == 0x%x, SCSISIGI == 0x%x\n"
argument_list|,
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCSIBUSL
argument_list|)
argument_list|,
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCSISIGI
argument_list|)
argument_list|)
expr_stmt|;
name|ahc_dump_card_state
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"for safety"
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
name|printf
argument_list|(
literal|"ahc_intr: seqint, "
literal|"intstat == 0x%x, scsisigi = 0x%x\n"
argument_list|,
name|intstat
argument_list|,
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCSISIGI
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|unpause
label|:
comment|/* 	 *  The sequencer is paused immediately on 	 *  a SEQINT, so we should restart it when 	 *  we're done. 	 */
name|ahc_unpause
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ahc_handle_scsiint
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|u_int
name|intstat
parameter_list|)
block|{
name|u_int
name|scb_index
decl_stmt|;
name|u_int
name|status0
decl_stmt|;
name|u_int
name|status
decl_stmt|;
name|struct
name|scb
modifier|*
name|scb
decl_stmt|;
name|char
name|cur_channel
decl_stmt|;
name|char
name|intr_channel
decl_stmt|;
if|if
condition|(
operator|(
name|ahc
operator|->
name|features
operator|&
name|AHC_TWIN
operator|)
operator|!=
literal|0
operator|&&
operator|(
operator|(
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SBLKCTL
argument_list|)
operator|&
name|SELBUSB
operator|)
operator|!=
literal|0
operator|)
condition|)
name|cur_channel
operator|=
literal|'B'
expr_stmt|;
else|else
name|cur_channel
operator|=
literal|'A'
expr_stmt|;
name|intr_channel
operator|=
name|cur_channel
expr_stmt|;
if|if
condition|(
operator|(
name|ahc
operator|->
name|features
operator|&
name|AHC_ULTRA2
operator|)
operator|!=
literal|0
condition|)
name|status0
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SSTAT0
argument_list|)
operator|&
name|IOERR
expr_stmt|;
else|else
name|status0
operator|=
literal|0
expr_stmt|;
name|status
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SSTAT1
argument_list|)
operator|&
operator|(
name|SELTO
operator||
name|SCSIRSTI
operator||
name|BUSFREE
operator||
name|SCSIPERR
operator|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
literal|0
operator|&&
name|status0
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|ahc
operator|->
name|features
operator|&
name|AHC_TWIN
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* Try the other channel */
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SBLKCTL
argument_list|,
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SBLKCTL
argument_list|)
operator|^
name|SELBUSB
argument_list|)
expr_stmt|;
name|status
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SSTAT1
argument_list|)
operator|&
operator|(
name|SELTO
operator||
name|SCSIRSTI
operator||
name|BUSFREE
operator||
name|SCSIPERR
operator|)
expr_stmt|;
name|intr_channel
operator|=
operator|(
name|cur_channel
operator|==
literal|'A'
operator|)
condition|?
literal|'B'
else|:
literal|'A'
expr_stmt|;
block|}
if|if
condition|(
name|status
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%s: Spurious SCSI interrupt\n"
argument_list|,
name|ahc_name
argument_list|(
name|ahc
argument_list|)
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|CLRINT
argument_list|,
name|CLRSCSIINT
argument_list|)
expr_stmt|;
name|ahc_unpause
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* Make sure the sequencer is in a safe location. */
name|ahc_clear_critical_section
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
name|scb_index
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCB_TAG
argument_list|)
expr_stmt|;
name|scb
operator|=
name|ahc_lookup_scb
argument_list|(
name|ahc
argument_list|,
name|scb_index
argument_list|)
expr_stmt|;
if|if
condition|(
name|scb
operator|!=
name|NULL
operator|&&
operator|(
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SEQ_FLAGS
argument_list|)
operator|&
name|NOT_IDENTIFIED
operator|)
operator|!=
literal|0
condition|)
name|scb
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|ahc
operator|->
name|features
operator|&
name|AHC_ULTRA2
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|status0
operator|&
name|IOERR
operator|)
operator|!=
literal|0
condition|)
block|{
name|int
name|now_lvd
decl_stmt|;
name|now_lvd
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SBLKCTL
argument_list|)
operator|&
name|ENAB40
expr_stmt|;
name|printf
argument_list|(
literal|"%s: Transceiver State Has Changed to %s mode\n"
argument_list|,
name|ahc_name
argument_list|(
name|ahc
argument_list|)
argument_list|,
name|now_lvd
condition|?
literal|"LVD"
else|:
literal|"SE"
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|CLRSINT0
argument_list|,
name|CLRIOERR
argument_list|)
expr_stmt|;
comment|/* 		 * When transitioning to SE mode, the reset line 		 * glitches, triggering an arbitration bug in some 		 * Ultra2 controllers.  This bug is cleared when we 		 * assert the reset line.  Since a reset glitch has 		 * already occurred with this transition and a 		 * transceiver state change is handled just like 		 * a bus reset anyway, asserting the reset line 		 * ourselves is safe. 		 */
name|ahc_reset_channel
argument_list|(
name|ahc
argument_list|,
name|intr_channel
argument_list|,
comment|/*Initiate Reset*/
name|now_lvd
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|status
operator|&
name|SCSIRSTI
operator|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%s: Someone reset channel %c\n"
argument_list|,
name|ahc_name
argument_list|(
name|ahc
argument_list|)
argument_list|,
name|intr_channel
argument_list|)
expr_stmt|;
if|if
condition|(
name|intr_channel
operator|!=
name|cur_channel
condition|)
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SBLKCTL
argument_list|,
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SBLKCTL
argument_list|)
operator|^
name|SELBUSB
argument_list|)
expr_stmt|;
name|ahc_reset_channel
argument_list|(
name|ahc
argument_list|,
name|intr_channel
argument_list|,
comment|/*Initiate Reset*/
name|FALSE
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|status
operator|&
name|SCSIPERR
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * Determine the bus phase and queue an appropriate message. 		 * SCSIPERR is latched true as soon as a parity error 		 * occurs.  If the sequencer acked the transfer that 		 * caused the parity error and the currently presented 		 * transfer on the bus has correct parity, SCSIPERR will 		 * be cleared by CLRSCSIPERR.  Use this to determine if 		 * we should look at the last phase the sequencer recorded, 		 * or the current phase presented on the bus. 		 */
name|struct
name|ahc_devinfo
name|devinfo
decl_stmt|;
name|u_int
name|mesg_out
decl_stmt|;
name|u_int
name|curphase
decl_stmt|;
name|u_int
name|errorphase
decl_stmt|;
name|u_int
name|lastphase
decl_stmt|;
name|u_int
name|scsirate
decl_stmt|;
name|u_int
name|i
decl_stmt|;
name|u_int
name|sstat2
decl_stmt|;
name|int
name|silent
decl_stmt|;
name|lastphase
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|LASTPHASE
argument_list|)
expr_stmt|;
name|curphase
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCSISIGI
argument_list|)
operator|&
name|PHASE_MASK
expr_stmt|;
name|sstat2
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SSTAT2
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|CLRSINT1
argument_list|,
name|CLRSCSIPERR
argument_list|)
expr_stmt|;
comment|/* 		 * For all phases save DATA, the sequencer won't 		 * automatically ack a byte that has a parity error 		 * in it.  So the only way that the current phase 		 * could be 'data-in' is if the parity error is for 		 * an already acked byte in the data phase.  During 		 * synchronous data-in transfers, we may actually 		 * ack bytes before latching the current phase in 		 * LASTPHASE, leading to the discrepancy between 		 * curphase and lastphase. 		 */
if|if
condition|(
operator|(
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SSTAT1
argument_list|)
operator|&
name|SCSIPERR
operator|)
operator|!=
literal|0
operator|||
name|curphase
operator|==
name|P_DATAIN
operator|||
name|curphase
operator|==
name|P_DATAIN_DT
condition|)
name|errorphase
operator|=
name|curphase
expr_stmt|;
else|else
name|errorphase
operator|=
name|lastphase
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_phases
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|errorphase
operator|==
name|ahc_phase_table
index|[
name|i
index|]
operator|.
name|phase
condition|)
break|break;
block|}
name|mesg_out
operator|=
name|ahc_phase_table
index|[
name|i
index|]
operator|.
name|mesg_out
expr_stmt|;
name|silent
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|scb
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|SCB_IS_SILENT
argument_list|(
name|scb
argument_list|)
condition|)
name|silent
operator|=
name|TRUE
expr_stmt|;
else|else
name|ahc_print_path
argument_list|(
name|ahc
argument_list|,
name|scb
argument_list|)
expr_stmt|;
name|scb
operator|->
name|flags
operator||=
name|SCB_TRANSMISSION_ERROR
expr_stmt|;
block|}
else|else
name|printf
argument_list|(
literal|"%s:%c:%d: "
argument_list|,
name|ahc_name
argument_list|(
name|ahc
argument_list|)
argument_list|,
name|intr_channel
argument_list|,
name|SCSIID_TARGET
argument_list|(
name|ahc
argument_list|,
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SAVED_SCSIID
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|scsirate
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCSIRATE
argument_list|)
expr_stmt|;
if|if
condition|(
name|silent
operator|==
name|FALSE
condition|)
block|{
name|printf
argument_list|(
literal|"parity error detected %s. "
literal|"SEQADDR(0x%x) SCSIRATE(0x%x)\n"
argument_list|,
name|ahc_phase_table
index|[
name|i
index|]
operator|.
name|phasemsg
argument_list|,
name|ahc_inw
argument_list|(
name|ahc
argument_list|,
name|SEQADDR0
argument_list|)
argument_list|,
name|scsirate
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ahc
operator|->
name|features
operator|&
name|AHC_DT
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|sstat2
operator|&
name|CRCVALERR
operator|)
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|"\tCRC Value Mismatch\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sstat2
operator|&
name|CRCENDERR
operator|)
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|"\tNo terminal CRC packet "
literal|"recevied\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sstat2
operator|&
name|CRCREQERR
operator|)
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|"\tIllegal CRC packet "
literal|"request\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sstat2
operator|&
name|DUAL_EDGE_ERR
operator|)
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|"\tUnexpected %sDT Data Phase\n"
argument_list|,
operator|(
name|scsirate
operator|&
name|SINGLE_EDGE
operator|)
condition|?
literal|""
else|:
literal|"non-"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|ahc
operator|->
name|features
operator|&
name|AHC_DT
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|sstat2
operator|&
name|DUAL_EDGE_ERR
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* 			 * This error applies regardless of 			 * data direction, so ignore the value 			 * in the phase table. 			 */
name|mesg_out
operator|=
name|MSG_INITIATOR_DET_ERR
expr_stmt|;
block|}
comment|/* 		 * We've set the hardware to assert ATN if we    		 * get a parity error on "in" phases, so all we   		 * need to do is stuff the message buffer with 		 * the appropriate message.  "In" phases have set 		 * mesg_out to something other than MSG_NOP. 		 */
if|if
condition|(
name|mesg_out
operator|!=
name|MSG_NOOP
condition|)
block|{
if|if
condition|(
name|ahc
operator|->
name|msg_type
operator|!=
name|MSG_TYPE_NONE
condition|)
name|ahc
operator|->
name|send_msg_perror
operator|=
name|TRUE
expr_stmt|;
else|else
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|MSG_OUT
argument_list|,
name|mesg_out
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Force a renegotiation with this target just in 		 * case we are out of sync for some external reason 		 * unknown (or unreported) by the target. 		 */
name|ahc_fetch_devinfo
argument_list|(
name|ahc
argument_list|,
operator|&
name|devinfo
argument_list|)
expr_stmt|;
name|ahc_force_renegotiation
argument_list|(
name|ahc
argument_list|,
operator|&
name|devinfo
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|CLRINT
argument_list|,
name|CLRSCSIINT
argument_list|)
expr_stmt|;
name|ahc_unpause
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|status
operator|&
name|SELTO
operator|)
operator|!=
literal|0
condition|)
block|{
name|u_int
name|scbptr
decl_stmt|;
comment|/* Stop the selection */
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCSISEQ
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* No more pending messages */
name|ahc_clear_msg_state
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
comment|/* Clear interrupt state */
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SIMODE1
argument_list|,
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SIMODE1
argument_list|)
operator|&
operator|~
name|ENBUSFREE
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|CLRSINT1
argument_list|,
name|CLRSELTIMEO
operator||
name|CLRBUSFREE
operator||
name|CLRSCSIPERR
argument_list|)
expr_stmt|;
comment|/* 		 * Although the driver does not care about the 		 * 'Selection in Progress' status bit, the busy 		 * LED does.  SELINGO is only cleared by a sucessfull 		 * selection, so we must manually clear it to insure 		 * the LED turns off just incase no future successful 		 * selections occur (e.g. no devices on the bus). 		 */
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|CLRSINT0
argument_list|,
name|CLRSELINGO
argument_list|)
expr_stmt|;
name|scbptr
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|WAITING_SCBH
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCBPTR
argument_list|,
name|scbptr
argument_list|)
expr_stmt|;
name|scb_index
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCB_TAG
argument_list|)
expr_stmt|;
name|scb
operator|=
name|ahc_lookup_scb
argument_list|(
name|ahc
argument_list|,
name|scb_index
argument_list|)
expr_stmt|;
if|if
condition|(
name|scb
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"%s: ahc_intr - referenced scb not "
literal|"valid during SELTO scb(%d, %d)\n"
argument_list|,
name|ahc_name
argument_list|(
name|ahc
argument_list|)
argument_list|,
name|scbptr
argument_list|,
name|scb_index
argument_list|)
expr_stmt|;
name|ahc_dump_card_state
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|struct
name|ahc_devinfo
name|devinfo
decl_stmt|;
ifdef|#
directive|ifdef
name|AHC_DEBUG
if|if
condition|(
operator|(
name|ahc_debug
operator|&
name|AHC_SHOW_SELTO
operator|)
operator|!=
literal|0
condition|)
block|{
name|ahc_print_path
argument_list|(
name|ahc
argument_list|,
name|scb
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Saw Selection Timeout for SCB 0x%x\n"
argument_list|,
name|scb_index
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|ahc_scb_devinfo
argument_list|(
name|ahc
argument_list|,
operator|&
name|devinfo
argument_list|,
name|scb
argument_list|)
expr_stmt|;
name|aic_set_transaction_status
argument_list|(
name|scb
argument_list|,
name|CAM_SEL_TIMEOUT
argument_list|)
expr_stmt|;
name|ahc_freeze_devq
argument_list|(
name|ahc
argument_list|,
name|scb
argument_list|)
expr_stmt|;
comment|/* 			 * Cancel any pending transactions on the device 			 * now that it seems to be missing.  This will 			 * also revert us to async/narrow transfers until 			 * we can renegotiate with the device. 			 */
name|ahc_handle_devreset
argument_list|(
name|ahc
argument_list|,
operator|&
name|devinfo
argument_list|,
name|CAM_SEL_TIMEOUT
argument_list|,
literal|"Selection Timeout"
argument_list|,
comment|/*verbose_level*/
literal|1
argument_list|)
expr_stmt|;
block|}
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|CLRINT
argument_list|,
name|CLRSCSIINT
argument_list|)
expr_stmt|;
name|ahc_restart
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|status
operator|&
name|BUSFREE
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SIMODE1
argument_list|)
operator|&
name|ENBUSFREE
operator|)
operator|!=
literal|0
condition|)
block|{
name|struct
name|ahc_devinfo
name|devinfo
decl_stmt|;
name|u_int
name|lastphase
decl_stmt|;
name|u_int
name|saved_scsiid
decl_stmt|;
name|u_int
name|saved_lun
decl_stmt|;
name|u_int
name|target
decl_stmt|;
name|u_int
name|initiator_role_id
decl_stmt|;
name|char
name|channel
decl_stmt|;
name|int
name|printerror
decl_stmt|;
comment|/* 		 * Clear our selection hardware as soon as possible. 		 * We may have an entry in the waiting Q for this target, 		 * that is affected by this busfree and we don't want to 		 * go about selecting the target while we handle the event. 		 */
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCSISEQ
argument_list|,
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCSISEQ
argument_list|)
operator|&
operator|(
name|ENSELI
operator||
name|ENRSELI
operator||
name|ENAUTOATNP
operator|)
argument_list|)
expr_stmt|;
comment|/* 		 * Disable busfree interrupts and clear the busfree 		 * interrupt status.  We do this here so that several 		 * bus transactions occur prior to clearing the SCSIINT 		 * latch.  It can take a bit for the clearing to take effect. 		 */
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SIMODE1
argument_list|,
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SIMODE1
argument_list|)
operator|&
operator|~
name|ENBUSFREE
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|CLRSINT1
argument_list|,
name|CLRBUSFREE
operator||
name|CLRSCSIPERR
argument_list|)
expr_stmt|;
comment|/* 		 * Look at what phase we were last in. 		 * If its message out, chances are pretty good 		 * that the busfree was in response to one of 		 * our abort requests. 		 */
name|lastphase
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|LASTPHASE
argument_list|)
expr_stmt|;
name|saved_scsiid
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SAVED_SCSIID
argument_list|)
expr_stmt|;
name|saved_lun
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SAVED_LUN
argument_list|)
expr_stmt|;
name|target
operator|=
name|SCSIID_TARGET
argument_list|(
name|ahc
argument_list|,
name|saved_scsiid
argument_list|)
expr_stmt|;
name|initiator_role_id
operator|=
name|SCSIID_OUR_ID
argument_list|(
name|saved_scsiid
argument_list|)
expr_stmt|;
name|channel
operator|=
name|SCSIID_CHANNEL
argument_list|(
name|ahc
argument_list|,
name|saved_scsiid
argument_list|)
expr_stmt|;
name|ahc_compile_devinfo
argument_list|(
operator|&
name|devinfo
argument_list|,
name|initiator_role_id
argument_list|,
name|target
argument_list|,
name|saved_lun
argument_list|,
name|channel
argument_list|,
name|ROLE_INITIATOR
argument_list|)
expr_stmt|;
name|printerror
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|lastphase
operator|==
name|P_MESGOUT
condition|)
block|{
name|u_int
name|tag
decl_stmt|;
name|tag
operator|=
name|SCB_LIST_NULL
expr_stmt|;
if|if
condition|(
name|ahc_sent_msg
argument_list|(
name|ahc
argument_list|,
name|AHCMSG_1B
argument_list|,
name|MSG_ABORT_TAG
argument_list|,
name|TRUE
argument_list|)
operator|||
name|ahc_sent_msg
argument_list|(
name|ahc
argument_list|,
name|AHCMSG_1B
argument_list|,
name|MSG_ABORT
argument_list|,
name|TRUE
argument_list|)
condition|)
block|{
if|if
condition|(
name|ahc
operator|->
name|msgout_buf
index|[
name|ahc
operator|->
name|msgout_index
operator|-
literal|1
index|]
operator|==
name|MSG_ABORT_TAG
condition|)
name|tag
operator|=
name|scb
operator|->
name|hscb
operator|->
name|tag
expr_stmt|;
name|ahc_print_path
argument_list|(
name|ahc
argument_list|,
name|scb
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"SCB %d - Abort%s Completed.\n"
argument_list|,
name|scb
operator|->
name|hscb
operator|->
name|tag
argument_list|,
name|tag
operator|==
name|SCB_LIST_NULL
condition|?
literal|""
else|:
literal|" Tag"
argument_list|)
expr_stmt|;
name|ahc_abort_scbs
argument_list|(
name|ahc
argument_list|,
name|target
argument_list|,
name|channel
argument_list|,
name|saved_lun
argument_list|,
name|tag
argument_list|,
name|ROLE_INITIATOR
argument_list|,
name|CAM_REQ_ABORTED
argument_list|)
expr_stmt|;
name|printerror
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ahc_sent_msg
argument_list|(
name|ahc
argument_list|,
name|AHCMSG_1B
argument_list|,
name|MSG_BUS_DEV_RESET
argument_list|,
name|TRUE
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|__FreeBSD__
comment|/* 				 * Don't mark the user's request for this BDR 				 * as completing with CAM_BDR_SENT.  CAM3 				 * specifies CAM_REQ_CMP. 				 */
if|if
condition|(
name|scb
operator|!=
name|NULL
operator|&&
name|scb
operator|->
name|io_ctx
operator|->
name|ccb_h
operator|.
name|func_code
operator|==
name|XPT_RESET_DEV
operator|&&
name|ahc_match_scb
argument_list|(
name|ahc
argument_list|,
name|scb
argument_list|,
name|target
argument_list|,
name|channel
argument_list|,
name|CAM_LUN_WILDCARD
argument_list|,
name|SCB_LIST_NULL
argument_list|,
name|ROLE_INITIATOR
argument_list|)
condition|)
block|{
name|aic_set_transaction_status
argument_list|(
name|scb
argument_list|,
name|CAM_REQ_CMP
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|ahc_compile_devinfo
argument_list|(
operator|&
name|devinfo
argument_list|,
name|initiator_role_id
argument_list|,
name|target
argument_list|,
name|CAM_LUN_WILDCARD
argument_list|,
name|channel
argument_list|,
name|ROLE_INITIATOR
argument_list|)
expr_stmt|;
name|ahc_handle_devreset
argument_list|(
name|ahc
argument_list|,
operator|&
name|devinfo
argument_list|,
name|CAM_BDR_SENT
argument_list|,
literal|"Bus Device Reset"
argument_list|,
comment|/*verbose_level*/
literal|0
argument_list|)
expr_stmt|;
name|printerror
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ahc_sent_msg
argument_list|(
name|ahc
argument_list|,
name|AHCMSG_EXT
argument_list|,
name|MSG_EXT_PPR
argument_list|,
name|FALSE
argument_list|)
condition|)
block|{
name|struct
name|ahc_initiator_tinfo
modifier|*
name|tinfo
decl_stmt|;
name|struct
name|ahc_tmode_tstate
modifier|*
name|tstate
decl_stmt|;
comment|/* 				 * PPR Rejected.  Try non-ppr negotiation 				 * and retry command. 				 */
name|tinfo
operator|=
name|ahc_fetch_transinfo
argument_list|(
name|ahc
argument_list|,
name|devinfo
operator|.
name|channel
argument_list|,
name|devinfo
operator|.
name|our_scsiid
argument_list|,
name|devinfo
operator|.
name|target
argument_list|,
operator|&
name|tstate
argument_list|)
expr_stmt|;
name|tinfo
operator|->
name|curr
operator|.
name|transport_version
operator|=
literal|2
expr_stmt|;
name|tinfo
operator|->
name|goal
operator|.
name|transport_version
operator|=
literal|2
expr_stmt|;
name|tinfo
operator|->
name|goal
operator|.
name|ppr_options
operator|=
literal|0
expr_stmt|;
name|ahc_qinfifo_requeue_tail
argument_list|(
name|ahc
argument_list|,
name|scb
argument_list|)
expr_stmt|;
name|printerror
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ahc_sent_msg
argument_list|(
name|ahc
argument_list|,
name|AHCMSG_EXT
argument_list|,
name|MSG_EXT_WDTR
argument_list|,
name|FALSE
argument_list|)
condition|)
block|{
comment|/* 				 * Negotiation Rejected.  Go-narrow and 				 * retry command. 				 */
name|ahc_set_width
argument_list|(
name|ahc
argument_list|,
operator|&
name|devinfo
argument_list|,
name|MSG_EXT_WDTR_BUS_8_BIT
argument_list|,
name|AHC_TRANS_CUR
operator||
name|AHC_TRANS_GOAL
argument_list|,
comment|/*paused*/
name|TRUE
argument_list|)
expr_stmt|;
name|ahc_qinfifo_requeue_tail
argument_list|(
name|ahc
argument_list|,
name|scb
argument_list|)
expr_stmt|;
name|printerror
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ahc_sent_msg
argument_list|(
name|ahc
argument_list|,
name|AHCMSG_EXT
argument_list|,
name|MSG_EXT_SDTR
argument_list|,
name|FALSE
argument_list|)
condition|)
block|{
comment|/* 				 * Negotiation Rejected.  Go-async and 				 * retry command. 				 */
name|ahc_set_syncrate
argument_list|(
name|ahc
argument_list|,
operator|&
name|devinfo
argument_list|,
comment|/*syncrate*/
name|NULL
argument_list|,
comment|/*period*/
literal|0
argument_list|,
comment|/*offset*/
literal|0
argument_list|,
comment|/*ppr_options*/
literal|0
argument_list|,
name|AHC_TRANS_CUR
operator||
name|AHC_TRANS_GOAL
argument_list|,
comment|/*paused*/
name|TRUE
argument_list|)
expr_stmt|;
name|ahc_qinfifo_requeue_tail
argument_list|(
name|ahc
argument_list|,
name|scb
argument_list|)
expr_stmt|;
name|printerror
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|printerror
operator|!=
literal|0
condition|)
block|{
name|u_int
name|i
decl_stmt|;
if|if
condition|(
name|scb
operator|!=
name|NULL
condition|)
block|{
name|u_int
name|tag
decl_stmt|;
if|if
condition|(
operator|(
name|scb
operator|->
name|hscb
operator|->
name|control
operator|&
name|TAG_ENB
operator|)
operator|!=
literal|0
condition|)
name|tag
operator|=
name|scb
operator|->
name|hscb
operator|->
name|tag
expr_stmt|;
else|else
name|tag
operator|=
name|SCB_LIST_NULL
expr_stmt|;
name|ahc_print_path
argument_list|(
name|ahc
argument_list|,
name|scb
argument_list|)
expr_stmt|;
name|ahc_abort_scbs
argument_list|(
name|ahc
argument_list|,
name|target
argument_list|,
name|channel
argument_list|,
name|SCB_GET_LUN
argument_list|(
name|scb
argument_list|)
argument_list|,
name|tag
argument_list|,
name|ROLE_INITIATOR
argument_list|,
name|CAM_UNEXP_BUSFREE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 				 * We had not fully identified this connection, 				 * so we cannot abort anything. 				 */
name|printf
argument_list|(
literal|"%s: "
argument_list|,
name|ahc_name
argument_list|(
name|ahc
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_phases
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|lastphase
operator|==
name|ahc_phase_table
index|[
name|i
index|]
operator|.
name|phase
condition|)
break|break;
block|}
if|if
condition|(
name|lastphase
operator|!=
name|P_BUSFREE
condition|)
block|{
comment|/* 				 * Renegotiate with this device at the 				 * next oportunity just in case this busfree 				 * is due to a negotiation mismatch with the 				 * device. 				 */
name|ahc_force_renegotiation
argument_list|(
name|ahc
argument_list|,
operator|&
name|devinfo
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"Unexpected busfree %s\n"
literal|"SEQADDR == 0x%x\n"
argument_list|,
name|ahc_phase_table
index|[
name|i
index|]
operator|.
name|phasemsg
argument_list|,
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SEQADDR0
argument_list|)
operator||
operator|(
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SEQADDR1
argument_list|)
operator|<<
literal|8
operator|)
argument_list|)
expr_stmt|;
block|}
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|CLRINT
argument_list|,
name|CLRSCSIINT
argument_list|)
expr_stmt|;
name|ahc_restart
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"%s: Missing case in ahc_handle_scsiint. status = %x\n"
argument_list|,
name|ahc_name
argument_list|(
name|ahc
argument_list|)
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|CLRINT
argument_list|,
name|CLRSCSIINT
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Force renegotiation to occur the next time we initiate  * a command to the current device.  */
end_comment

begin_function
specifier|static
name|void
name|ahc_force_renegotiation
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|struct
name|ahc_devinfo
modifier|*
name|devinfo
parameter_list|)
block|{
name|struct
name|ahc_initiator_tinfo
modifier|*
name|targ_info
decl_stmt|;
name|struct
name|ahc_tmode_tstate
modifier|*
name|tstate
decl_stmt|;
name|targ_info
operator|=
name|ahc_fetch_transinfo
argument_list|(
name|ahc
argument_list|,
name|devinfo
operator|->
name|channel
argument_list|,
name|devinfo
operator|->
name|our_scsiid
argument_list|,
name|devinfo
operator|->
name|target
argument_list|,
operator|&
name|tstate
argument_list|)
expr_stmt|;
name|ahc_update_neg_request
argument_list|(
name|ahc
argument_list|,
name|devinfo
argument_list|,
name|tstate
argument_list|,
name|targ_info
argument_list|,
name|AHC_NEG_IF_NON_ASYNC
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|AHC_MAX_STEPS
value|2000
end_define

begin_function
name|void
name|ahc_clear_critical_section
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|)
block|{
name|int
name|stepping
decl_stmt|;
name|int
name|steps
decl_stmt|;
name|u_int
name|simode0
decl_stmt|;
name|u_int
name|simode1
decl_stmt|;
if|if
condition|(
name|ahc
operator|->
name|num_critical_sections
operator|==
literal|0
condition|)
return|return;
name|stepping
operator|=
name|FALSE
expr_stmt|;
name|steps
operator|=
literal|0
expr_stmt|;
name|simode0
operator|=
literal|0
expr_stmt|;
name|simode1
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|struct
name|cs
modifier|*
name|cs
decl_stmt|;
name|u_int
name|seqaddr
decl_stmt|;
name|u_int
name|i
decl_stmt|;
name|seqaddr
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SEQADDR0
argument_list|)
operator||
operator|(
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SEQADDR1
argument_list|)
operator|<<
literal|8
operator|)
expr_stmt|;
comment|/* 		 * Seqaddr represents the next instruction to execute,  		 * so we are really executing the instruction just 		 * before it. 		 */
name|cs
operator|=
name|ahc
operator|->
name|critical_sections
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ahc
operator|->
name|num_critical_sections
condition|;
name|i
operator|++
operator|,
name|cs
operator|++
control|)
block|{
if|if
condition|(
name|cs
operator|->
name|begin
operator|<
name|seqaddr
operator|&&
name|cs
operator|->
name|end
operator|>=
name|seqaddr
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|==
name|ahc
operator|->
name|num_critical_sections
condition|)
break|break;
if|if
condition|(
name|steps
operator|>
name|AHC_MAX_STEPS
condition|)
block|{
name|printf
argument_list|(
literal|"%s: Infinite loop in critical section\n"
argument_list|,
name|ahc_name
argument_list|(
name|ahc
argument_list|)
argument_list|)
expr_stmt|;
name|ahc_dump_card_state
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"critical section loop"
argument_list|)
expr_stmt|;
block|}
name|steps
operator|++
expr_stmt|;
if|if
condition|(
name|stepping
operator|==
name|FALSE
condition|)
block|{
comment|/* 			 * Disable all interrupt sources so that the 			 * sequencer will not be stuck by a pausing 			 * interrupt condition while we attempt to 			 * leave a critical section. 			 */
name|simode0
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SIMODE0
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SIMODE0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|simode1
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SIMODE1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ahc
operator|->
name|features
operator|&
name|AHC_DT
operator|)
operator|!=
literal|0
condition|)
comment|/* 				 * On DT class controllers, we 				 * use the enhanced busfree logic. 				 * Unfortunately we cannot re-enable 				 * busfree detection within the 				 * current connection, so we must 				 * leave it on while single stepping. 				 */
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SIMODE1
argument_list|,
name|simode1
operator|&
name|ENBUSFREE
argument_list|)
expr_stmt|;
else|else
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SIMODE1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|CLRINT
argument_list|,
name|CLRSCSIINT
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SEQCTL
argument_list|,
name|ahc
operator|->
name|seqctl
operator||
name|STEP
argument_list|)
expr_stmt|;
name|stepping
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|ahc
operator|->
name|features
operator|&
name|AHC_DT
operator|)
operator|!=
literal|0
condition|)
block|{
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|CLRSINT1
argument_list|,
name|CLRBUSFREE
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|CLRINT
argument_list|,
name|CLRSCSIINT
argument_list|)
expr_stmt|;
block|}
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|HCNTRL
argument_list|,
name|ahc
operator|->
name|unpause
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|ahc_is_paused
argument_list|(
name|ahc
argument_list|)
condition|)
name|aic_delay
argument_list|(
literal|200
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|stepping
condition|)
block|{
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SIMODE0
argument_list|,
name|simode0
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SIMODE1
argument_list|,
name|simode1
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SEQCTL
argument_list|,
name|ahc
operator|->
name|seqctl
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Clear any pending interrupt status.  */
end_comment

begin_function
name|void
name|ahc_clear_intstat
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|)
block|{
comment|/* Clear any interrupt conditions this may have caused */
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|CLRSINT1
argument_list|,
name|CLRSELTIMEO
operator||
name|CLRATNO
operator||
name|CLRSCSIRSTI
operator||
name|CLRBUSFREE
operator||
name|CLRSCSIPERR
operator||
name|CLRPHASECHG
operator||
name|CLRREQINIT
argument_list|)
expr_stmt|;
name|ahc_flush_device_writes
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|CLRSINT0
argument_list|,
name|CLRSELDO
operator||
name|CLRSELDI
operator||
name|CLRSELINGO
argument_list|)
expr_stmt|;
name|ahc_flush_device_writes
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|CLRINT
argument_list|,
name|CLRSCSIINT
argument_list|)
expr_stmt|;
name|ahc_flush_device_writes
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**************************** Debugging Routines ******************************/
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|AHC_DEBUG
end_ifdef

begin_decl_stmt
name|uint32_t
name|ahc_debug
init|=
name|AHC_DEBUG_OPTS
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|ahc_print_scb
parameter_list|(
name|struct
name|scb
modifier|*
name|scb
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|hardware_scb
modifier|*
name|hscb
init|=
name|scb
operator|->
name|hscb
decl_stmt|;
name|printf
argument_list|(
literal|"scb:%p control:0x%x scsiid:0x%x lun:%d cdb_len:%d\n"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|scb
argument_list|,
name|hscb
operator|->
name|control
argument_list|,
name|hscb
operator|->
name|scsiid
argument_list|,
name|hscb
operator|->
name|lun
argument_list|,
name|hscb
operator|->
name|cdb_len
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Shared Data: "
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|hscb
operator|->
name|shared_data
operator|.
name|cdb
argument_list|)
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|"%#02x"
argument_list|,
name|hscb
operator|->
name|shared_data
operator|.
name|cdb
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"        dataptr:%#x datacnt:%#x sgptr:%#x tag:%#x\n"
argument_list|,
name|aic_le32toh
argument_list|(
name|hscb
operator|->
name|dataptr
argument_list|)
argument_list|,
name|aic_le32toh
argument_list|(
name|hscb
operator|->
name|datacnt
argument_list|)
argument_list|,
name|aic_le32toh
argument_list|(
name|hscb
operator|->
name|sgptr
argument_list|)
argument_list|,
name|hscb
operator|->
name|tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|scb
operator|->
name|sg_count
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|scb
operator|->
name|sg_count
condition|;
name|i
operator|++
control|)
block|{
name|printf
argument_list|(
literal|"sg[%d] - Addr 0x%x%x : Length %d\n"
argument_list|,
name|i
argument_list|,
operator|(
name|aic_le32toh
argument_list|(
name|scb
operator|->
name|sg_list
index|[
name|i
index|]
operator|.
name|len
argument_list|)
operator|>>
literal|24
operator|&
name|SG_HIGH_ADDR_BITS
operator|)
argument_list|,
name|aic_le32toh
argument_list|(
name|scb
operator|->
name|sg_list
index|[
name|i
index|]
operator|.
name|addr
argument_list|)
argument_list|,
name|aic_le32toh
argument_list|(
name|scb
operator|->
name|sg_list
index|[
name|i
index|]
operator|.
name|len
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/************************* Transfer Negotiation *******************************/
end_comment

begin_comment
comment|/*  * Allocate per target mode instance (ID we respond to as a target)  * transfer negotiation data structures.  */
end_comment

begin_function
specifier|static
name|struct
name|ahc_tmode_tstate
modifier|*
name|ahc_alloc_tstate
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|u_int
name|scsi_id
parameter_list|,
name|char
name|channel
parameter_list|)
block|{
name|struct
name|ahc_tmode_tstate
modifier|*
name|master_tstate
decl_stmt|;
name|struct
name|ahc_tmode_tstate
modifier|*
name|tstate
decl_stmt|;
name|int
name|i
decl_stmt|;
name|master_tstate
operator|=
name|ahc
operator|->
name|enabled_targets
index|[
name|ahc
operator|->
name|our_id
index|]
expr_stmt|;
if|if
condition|(
name|channel
operator|==
literal|'B'
condition|)
block|{
name|scsi_id
operator|+=
literal|8
expr_stmt|;
name|master_tstate
operator|=
name|ahc
operator|->
name|enabled_targets
index|[
name|ahc
operator|->
name|our_id_b
operator|+
literal|8
index|]
expr_stmt|;
block|}
if|if
condition|(
name|ahc
operator|->
name|enabled_targets
index|[
name|scsi_id
index|]
operator|!=
name|NULL
operator|&&
name|ahc
operator|->
name|enabled_targets
index|[
name|scsi_id
index|]
operator|!=
name|master_tstate
condition|)
name|panic
argument_list|(
literal|"%s: ahc_alloc_tstate - Target already allocated"
argument_list|,
name|ahc_name
argument_list|(
name|ahc
argument_list|)
argument_list|)
expr_stmt|;
name|tstate
operator|=
operator|(
expr|struct
name|ahc_tmode_tstate
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|tstate
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|tstate
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* 	 * If we have allocated a master tstate, copy user settings from 	 * the master tstate (taken from SRAM or the EEPROM) for this 	 * channel, but reset our current and goal settings to async/narrow 	 * until an initiator talks to us. 	 */
if|if
condition|(
name|master_tstate
operator|!=
name|NULL
condition|)
block|{
name|memcpy
argument_list|(
name|tstate
argument_list|,
name|master_tstate
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|tstate
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|tstate
operator|->
name|enabled_luns
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|tstate
operator|->
name|enabled_luns
argument_list|)
argument_list|)
expr_stmt|;
name|tstate
operator|->
name|ultraenb
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|AHC_NUM_TARGETS
condition|;
name|i
operator|++
control|)
block|{
name|memset
argument_list|(
operator|&
name|tstate
operator|->
name|transinfo
index|[
name|i
index|]
operator|.
name|curr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|tstate
operator|->
name|transinfo
index|[
name|i
index|]
operator|.
name|curr
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|tstate
operator|->
name|transinfo
index|[
name|i
index|]
operator|.
name|goal
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|tstate
operator|->
name|transinfo
index|[
name|i
index|]
operator|.
name|goal
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|memset
argument_list|(
name|tstate
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|tstate
argument_list|)
argument_list|)
expr_stmt|;
name|ahc
operator|->
name|enabled_targets
index|[
name|scsi_id
index|]
operator|=
name|tstate
expr_stmt|;
return|return
operator|(
name|tstate
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|AHC_TARGET_MODE
end_ifdef

begin_comment
comment|/*  * Free per target mode instance (ID we respond to as a target)  * transfer negotiation data structures.  */
end_comment

begin_function
specifier|static
name|void
name|ahc_free_tstate
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|u_int
name|scsi_id
parameter_list|,
name|char
name|channel
parameter_list|,
name|int
name|force
parameter_list|)
block|{
name|struct
name|ahc_tmode_tstate
modifier|*
name|tstate
decl_stmt|;
comment|/* 	 * Don't clean up our "master" tstate. 	 * It has our default user settings. 	 */
if|if
condition|(
operator|(
operator|(
name|channel
operator|==
literal|'B'
operator|&&
name|scsi_id
operator|==
name|ahc
operator|->
name|our_id_b
operator|)
operator|||
operator|(
name|channel
operator|==
literal|'A'
operator|&&
name|scsi_id
operator|==
name|ahc
operator|->
name|our_id
operator|)
operator|)
operator|&&
name|force
operator|==
name|FALSE
condition|)
return|return;
if|if
condition|(
name|channel
operator|==
literal|'B'
condition|)
name|scsi_id
operator|+=
literal|8
expr_stmt|;
name|tstate
operator|=
name|ahc
operator|->
name|enabled_targets
index|[
name|scsi_id
index|]
expr_stmt|;
if|if
condition|(
name|tstate
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|tstate
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|ahc
operator|->
name|enabled_targets
index|[
name|scsi_id
index|]
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Called when we have an active connection to a target on the bus,  * this function finds the nearest syncrate to the input period limited  * by the capabilities of the bus connectivity of and sync settings for  * the target.  */
end_comment

begin_function
name|struct
name|ahc_syncrate
modifier|*
name|ahc_devlimited_syncrate
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|struct
name|ahc_initiator_tinfo
modifier|*
name|tinfo
parameter_list|,
name|u_int
modifier|*
name|period
parameter_list|,
name|u_int
modifier|*
name|ppr_options
parameter_list|,
name|role_t
name|role
parameter_list|)
block|{
name|struct
name|ahc_transinfo
modifier|*
name|transinfo
decl_stmt|;
name|u_int
name|maxsync
decl_stmt|;
if|if
condition|(
operator|(
name|ahc
operator|->
name|features
operator|&
name|AHC_ULTRA2
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SBLKCTL
argument_list|)
operator|&
name|ENAB40
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SSTAT2
argument_list|)
operator|&
name|EXP_ACTIVE
operator|)
operator|==
literal|0
condition|)
block|{
name|maxsync
operator|=
name|AHC_SYNCRATE_DT
expr_stmt|;
block|}
else|else
block|{
name|maxsync
operator|=
name|AHC_SYNCRATE_ULTRA
expr_stmt|;
comment|/* Can't do DT on an SE bus */
operator|*
name|ppr_options
operator|&=
operator|~
name|MSG_EXT_PPR_DT_REQ
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|ahc
operator|->
name|features
operator|&
name|AHC_ULTRA
operator|)
operator|!=
literal|0
condition|)
block|{
name|maxsync
operator|=
name|AHC_SYNCRATE_ULTRA
expr_stmt|;
block|}
else|else
block|{
name|maxsync
operator|=
name|AHC_SYNCRATE_FAST
expr_stmt|;
block|}
comment|/* 	 * Never allow a value higher than our current goal 	 * period otherwise we may allow a target initiated 	 * negotiation to go above the limit as set by the 	 * user.  In the case of an initiator initiated 	 * sync negotiation, we limit based on the user 	 * setting.  This allows the system to still accept 	 * incoming negotiations even if target initiated 	 * negotiation is not performed. 	 */
if|if
condition|(
name|role
operator|==
name|ROLE_TARGET
condition|)
name|transinfo
operator|=
operator|&
name|tinfo
operator|->
name|user
expr_stmt|;
else|else
name|transinfo
operator|=
operator|&
name|tinfo
operator|->
name|goal
expr_stmt|;
operator|*
name|ppr_options
operator|&=
name|transinfo
operator|->
name|ppr_options
expr_stmt|;
if|if
condition|(
name|transinfo
operator|->
name|width
operator|==
name|MSG_EXT_WDTR_BUS_8_BIT
condition|)
block|{
name|maxsync
operator|=
name|MAX
argument_list|(
name|maxsync
argument_list|,
name|AHC_SYNCRATE_ULTRA2
argument_list|)
expr_stmt|;
operator|*
name|ppr_options
operator|&=
operator|~
name|MSG_EXT_PPR_DT_REQ
expr_stmt|;
block|}
if|if
condition|(
name|transinfo
operator|->
name|period
operator|==
literal|0
condition|)
block|{
operator|*
name|period
operator|=
literal|0
expr_stmt|;
operator|*
name|ppr_options
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
operator|*
name|period
operator|=
name|MAX
argument_list|(
operator|*
name|period
argument_list|,
name|transinfo
operator|->
name|period
argument_list|)
expr_stmt|;
return|return
operator|(
name|ahc_find_syncrate
argument_list|(
name|ahc
argument_list|,
name|period
argument_list|,
name|ppr_options
argument_list|,
name|maxsync
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Look up the valid period to SCSIRATE conversion in our table.  * Return the period and offset that should be sent to the target  * if this was the beginning of an SDTR.  */
end_comment

begin_function
name|struct
name|ahc_syncrate
modifier|*
name|ahc_find_syncrate
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|u_int
modifier|*
name|period
parameter_list|,
name|u_int
modifier|*
name|ppr_options
parameter_list|,
name|u_int
name|maxsync
parameter_list|)
block|{
name|struct
name|ahc_syncrate
modifier|*
name|syncrate
decl_stmt|;
if|if
condition|(
operator|(
name|ahc
operator|->
name|features
operator|&
name|AHC_DT
operator|)
operator|==
literal|0
condition|)
operator|*
name|ppr_options
operator|&=
operator|~
name|MSG_EXT_PPR_DT_REQ
expr_stmt|;
comment|/* Skip all DT only entries if DT is not available */
if|if
condition|(
operator|(
operator|*
name|ppr_options
operator|&
name|MSG_EXT_PPR_DT_REQ
operator|)
operator|==
literal|0
operator|&&
name|maxsync
operator|<
name|AHC_SYNCRATE_ULTRA2
condition|)
name|maxsync
operator|=
name|AHC_SYNCRATE_ULTRA2
expr_stmt|;
for|for
control|(
name|syncrate
operator|=
operator|&
name|ahc_syncrates
index|[
name|maxsync
index|]
init|;
name|syncrate
operator|->
name|rate
operator|!=
name|NULL
condition|;
name|syncrate
operator|++
control|)
block|{
comment|/* 		 * The Ultra2 table doesn't go as low 		 * as for the Fast/Ultra cards. 		 */
if|if
condition|(
operator|(
name|ahc
operator|->
name|features
operator|&
name|AHC_ULTRA2
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|syncrate
operator|->
name|sxfr_u2
operator|==
literal|0
operator|)
condition|)
break|break;
if|if
condition|(
operator|*
name|period
operator|<=
name|syncrate
operator|->
name|period
condition|)
block|{
comment|/* 			 * When responding to a target that requests 			 * sync, the requested rate may fall between 			 * two rates that we can output, but still be 			 * a rate that we can receive.  Because of this, 			 * we want to respond to the target with 			 * the same rate that it sent to us even 			 * if the period we use to send data to it 			 * is lower.  Only lower the response period 			 * if we must. 			 */
if|if
condition|(
name|syncrate
operator|==
operator|&
name|ahc_syncrates
index|[
name|maxsync
index|]
condition|)
operator|*
name|period
operator|=
name|syncrate
operator|->
name|period
expr_stmt|;
comment|/* 			 * At some speeds, we only support 			 * ST transfers. 			 */
if|if
condition|(
operator|(
name|syncrate
operator|->
name|sxfr_u2
operator|&
name|ST_SXFR
operator|)
operator|!=
literal|0
condition|)
operator|*
name|ppr_options
operator|&=
operator|~
name|MSG_EXT_PPR_DT_REQ
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|(
operator|*
name|period
operator|==
literal|0
operator|)
operator|||
operator|(
name|syncrate
operator|->
name|rate
operator|==
name|NULL
operator|)
operator|||
operator|(
operator|(
name|ahc
operator|->
name|features
operator|&
name|AHC_ULTRA2
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|syncrate
operator|->
name|sxfr_u2
operator|==
literal|0
operator|)
operator|)
condition|)
block|{
comment|/* Use asynchronous transfers. */
operator|*
name|period
operator|=
literal|0
expr_stmt|;
name|syncrate
operator|=
name|NULL
expr_stmt|;
operator|*
name|ppr_options
operator|&=
operator|~
name|MSG_EXT_PPR_DT_REQ
expr_stmt|;
block|}
return|return
operator|(
name|syncrate
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Convert from an entry in our syncrate table to the SCSI equivalent  * sync "period" factor.  */
end_comment

begin_function
name|u_int
name|ahc_find_period
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|u_int
name|scsirate
parameter_list|,
name|u_int
name|maxsync
parameter_list|)
block|{
name|struct
name|ahc_syncrate
modifier|*
name|syncrate
decl_stmt|;
if|if
condition|(
operator|(
name|ahc
operator|->
name|features
operator|&
name|AHC_ULTRA2
operator|)
operator|!=
literal|0
condition|)
name|scsirate
operator|&=
name|SXFR_ULTRA2
expr_stmt|;
else|else
name|scsirate
operator|&=
name|SXFR
expr_stmt|;
name|syncrate
operator|=
operator|&
name|ahc_syncrates
index|[
name|maxsync
index|]
expr_stmt|;
while|while
condition|(
name|syncrate
operator|->
name|rate
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|ahc
operator|->
name|features
operator|&
name|AHC_ULTRA2
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|syncrate
operator|->
name|sxfr_u2
operator|==
literal|0
condition|)
break|break;
elseif|else
if|if
condition|(
name|scsirate
operator|==
operator|(
name|syncrate
operator|->
name|sxfr_u2
operator|&
name|SXFR_ULTRA2
operator|)
condition|)
return|return
operator|(
name|syncrate
operator|->
name|period
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|scsirate
operator|==
operator|(
name|syncrate
operator|->
name|sxfr
operator|&
name|SXFR
operator|)
condition|)
block|{
return|return
operator|(
name|syncrate
operator|->
name|period
operator|)
return|;
block|}
name|syncrate
operator|++
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
comment|/* async */
block|}
end_function

begin_comment
comment|/*  * Truncate the given synchronous offset to a value the  * current adapter type and syncrate are capable of.  */
end_comment

begin_function
name|void
name|ahc_validate_offset
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|struct
name|ahc_initiator_tinfo
modifier|*
name|tinfo
parameter_list|,
name|struct
name|ahc_syncrate
modifier|*
name|syncrate
parameter_list|,
name|u_int
modifier|*
name|offset
parameter_list|,
name|int
name|wide
parameter_list|,
name|role_t
name|role
parameter_list|)
block|{
name|u_int
name|maxoffset
decl_stmt|;
comment|/* Limit offset to what we can do */
if|if
condition|(
name|syncrate
operator|==
name|NULL
condition|)
block|{
name|maxoffset
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|ahc
operator|->
name|features
operator|&
name|AHC_ULTRA2
operator|)
operator|!=
literal|0
condition|)
block|{
name|maxoffset
operator|=
name|MAX_OFFSET_ULTRA2
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|wide
condition|)
name|maxoffset
operator|=
name|MAX_OFFSET_16BIT
expr_stmt|;
else|else
name|maxoffset
operator|=
name|MAX_OFFSET_8BIT
expr_stmt|;
block|}
operator|*
name|offset
operator|=
name|MIN
argument_list|(
operator|*
name|offset
argument_list|,
name|maxoffset
argument_list|)
expr_stmt|;
if|if
condition|(
name|tinfo
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|role
operator|==
name|ROLE_TARGET
condition|)
operator|*
name|offset
operator|=
name|MIN
argument_list|(
operator|*
name|offset
argument_list|,
name|tinfo
operator|->
name|user
operator|.
name|offset
argument_list|)
expr_stmt|;
else|else
operator|*
name|offset
operator|=
name|MIN
argument_list|(
operator|*
name|offset
argument_list|,
name|tinfo
operator|->
name|goal
operator|.
name|offset
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Truncate the given transfer width parameter to a value the  * current adapter type is capable of.  */
end_comment

begin_function
name|void
name|ahc_validate_width
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|struct
name|ahc_initiator_tinfo
modifier|*
name|tinfo
parameter_list|,
name|u_int
modifier|*
name|bus_width
parameter_list|,
name|role_t
name|role
parameter_list|)
block|{
switch|switch
condition|(
operator|*
name|bus_width
condition|)
block|{
default|default:
if|if
condition|(
name|ahc
operator|->
name|features
operator|&
name|AHC_WIDE
condition|)
block|{
comment|/* Respond Wide */
operator|*
name|bus_width
operator|=
name|MSG_EXT_WDTR_BUS_16_BIT
expr_stmt|;
break|break;
block|}
comment|/* FALLTHROUGH */
case|case
name|MSG_EXT_WDTR_BUS_8_BIT
case|:
operator|*
name|bus_width
operator|=
name|MSG_EXT_WDTR_BUS_8_BIT
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|tinfo
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|role
operator|==
name|ROLE_TARGET
condition|)
operator|*
name|bus_width
operator|=
name|MIN
argument_list|(
name|tinfo
operator|->
name|user
operator|.
name|width
argument_list|,
operator|*
name|bus_width
argument_list|)
expr_stmt|;
else|else
operator|*
name|bus_width
operator|=
name|MIN
argument_list|(
name|tinfo
operator|->
name|goal
operator|.
name|width
argument_list|,
operator|*
name|bus_width
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Update the bitmask of targets for which the controller should  * negotiate with at the next convenient oportunity.  This currently  * means the next time we send the initial identify messages for  * a new transaction.  */
end_comment

begin_function
name|int
name|ahc_update_neg_request
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|struct
name|ahc_devinfo
modifier|*
name|devinfo
parameter_list|,
name|struct
name|ahc_tmode_tstate
modifier|*
name|tstate
parameter_list|,
name|struct
name|ahc_initiator_tinfo
modifier|*
name|tinfo
parameter_list|,
name|ahc_neg_type
name|neg_type
parameter_list|)
block|{
name|u_int
name|auto_negotiate_orig
decl_stmt|;
name|auto_negotiate_orig
operator|=
name|tstate
operator|->
name|auto_negotiate
expr_stmt|;
if|if
condition|(
name|neg_type
operator|==
name|AHC_NEG_ALWAYS
condition|)
block|{
comment|/* 		 * Force our "current" settings to be 		 * unknown so that unless a bus reset 		 * occurs the need to renegotiate is 		 * recorded persistently. 		 */
if|if
condition|(
operator|(
name|ahc
operator|->
name|features
operator|&
name|AHC_WIDE
operator|)
operator|!=
literal|0
condition|)
name|tinfo
operator|->
name|curr
operator|.
name|width
operator|=
name|AHC_WIDTH_UNKNOWN
expr_stmt|;
name|tinfo
operator|->
name|curr
operator|.
name|period
operator|=
name|AHC_PERIOD_UNKNOWN
expr_stmt|;
name|tinfo
operator|->
name|curr
operator|.
name|offset
operator|=
name|AHC_OFFSET_UNKNOWN
expr_stmt|;
block|}
if|if
condition|(
name|tinfo
operator|->
name|curr
operator|.
name|period
operator|!=
name|tinfo
operator|->
name|goal
operator|.
name|period
operator|||
name|tinfo
operator|->
name|curr
operator|.
name|width
operator|!=
name|tinfo
operator|->
name|goal
operator|.
name|width
operator|||
name|tinfo
operator|->
name|curr
operator|.
name|offset
operator|!=
name|tinfo
operator|->
name|goal
operator|.
name|offset
operator|||
name|tinfo
operator|->
name|curr
operator|.
name|ppr_options
operator|!=
name|tinfo
operator|->
name|goal
operator|.
name|ppr_options
operator|||
operator|(
name|neg_type
operator|==
name|AHC_NEG_IF_NON_ASYNC
operator|&&
operator|(
name|tinfo
operator|->
name|goal
operator|.
name|offset
operator|!=
literal|0
operator|||
name|tinfo
operator|->
name|goal
operator|.
name|width
operator|!=
name|MSG_EXT_WDTR_BUS_8_BIT
operator|||
name|tinfo
operator|->
name|goal
operator|.
name|ppr_options
operator|!=
literal|0
operator|)
operator|)
condition|)
name|tstate
operator|->
name|auto_negotiate
operator||=
name|devinfo
operator|->
name|target_mask
expr_stmt|;
else|else
name|tstate
operator|->
name|auto_negotiate
operator|&=
operator|~
name|devinfo
operator|->
name|target_mask
expr_stmt|;
return|return
operator|(
name|auto_negotiate_orig
operator|!=
name|tstate
operator|->
name|auto_negotiate
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Update the user/goal/curr tables of synchronous negotiation  * parameters as well as, in the case of a current or active update,  * any data structures on the host controller.  In the case of an  * active update, the specified target is currently talking to us on  * the bus, so the transfer parameter update must take effect  * immediately.  */
end_comment

begin_function
name|void
name|ahc_set_syncrate
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|struct
name|ahc_devinfo
modifier|*
name|devinfo
parameter_list|,
name|struct
name|ahc_syncrate
modifier|*
name|syncrate
parameter_list|,
name|u_int
name|period
parameter_list|,
name|u_int
name|offset
parameter_list|,
name|u_int
name|ppr_options
parameter_list|,
name|u_int
name|type
parameter_list|,
name|int
name|paused
parameter_list|)
block|{
name|struct
name|ahc_initiator_tinfo
modifier|*
name|tinfo
decl_stmt|;
name|struct
name|ahc_tmode_tstate
modifier|*
name|tstate
decl_stmt|;
name|u_int
name|old_period
decl_stmt|;
name|u_int
name|old_offset
decl_stmt|;
name|u_int
name|old_ppr
decl_stmt|;
name|int
name|active
decl_stmt|;
name|int
name|update_needed
decl_stmt|;
name|active
operator|=
operator|(
name|type
operator|&
name|AHC_TRANS_ACTIVE
operator|)
operator|==
name|AHC_TRANS_ACTIVE
expr_stmt|;
name|update_needed
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|syncrate
operator|==
name|NULL
condition|)
block|{
name|period
operator|=
literal|0
expr_stmt|;
name|offset
operator|=
literal|0
expr_stmt|;
block|}
name|tinfo
operator|=
name|ahc_fetch_transinfo
argument_list|(
name|ahc
argument_list|,
name|devinfo
operator|->
name|channel
argument_list|,
name|devinfo
operator|->
name|our_scsiid
argument_list|,
name|devinfo
operator|->
name|target
argument_list|,
operator|&
name|tstate
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|type
operator|&
name|AHC_TRANS_USER
operator|)
operator|!=
literal|0
condition|)
block|{
name|tinfo
operator|->
name|user
operator|.
name|period
operator|=
name|period
expr_stmt|;
name|tinfo
operator|->
name|user
operator|.
name|offset
operator|=
name|offset
expr_stmt|;
name|tinfo
operator|->
name|user
operator|.
name|ppr_options
operator|=
name|ppr_options
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|type
operator|&
name|AHC_TRANS_GOAL
operator|)
operator|!=
literal|0
condition|)
block|{
name|tinfo
operator|->
name|goal
operator|.
name|period
operator|=
name|period
expr_stmt|;
name|tinfo
operator|->
name|goal
operator|.
name|offset
operator|=
name|offset
expr_stmt|;
name|tinfo
operator|->
name|goal
operator|.
name|ppr_options
operator|=
name|ppr_options
expr_stmt|;
block|}
name|old_period
operator|=
name|tinfo
operator|->
name|curr
operator|.
name|period
expr_stmt|;
name|old_offset
operator|=
name|tinfo
operator|->
name|curr
operator|.
name|offset
expr_stmt|;
name|old_ppr
operator|=
name|tinfo
operator|->
name|curr
operator|.
name|ppr_options
expr_stmt|;
if|if
condition|(
operator|(
name|type
operator|&
name|AHC_TRANS_CUR
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|old_period
operator|!=
name|period
operator|||
name|old_offset
operator|!=
name|offset
operator|||
name|old_ppr
operator|!=
name|ppr_options
operator|)
condition|)
block|{
name|u_int
name|scsirate
decl_stmt|;
name|update_needed
operator|++
expr_stmt|;
name|scsirate
operator|=
name|tinfo
operator|->
name|scsirate
expr_stmt|;
if|if
condition|(
operator|(
name|ahc
operator|->
name|features
operator|&
name|AHC_ULTRA2
operator|)
operator|!=
literal|0
condition|)
block|{
name|scsirate
operator|&=
operator|~
operator|(
name|SXFR_ULTRA2
operator||
name|SINGLE_EDGE
operator||
name|ENABLE_CRC
operator|)
expr_stmt|;
if|if
condition|(
name|syncrate
operator|!=
name|NULL
condition|)
block|{
name|scsirate
operator||=
name|syncrate
operator|->
name|sxfr_u2
expr_stmt|;
if|if
condition|(
operator|(
name|ppr_options
operator|&
name|MSG_EXT_PPR_DT_REQ
operator|)
operator|!=
literal|0
condition|)
name|scsirate
operator||=
name|ENABLE_CRC
expr_stmt|;
else|else
name|scsirate
operator||=
name|SINGLE_EDGE
expr_stmt|;
block|}
block|}
else|else
block|{
name|scsirate
operator|&=
operator|~
operator|(
name|SXFR
operator||
name|SOFS
operator|)
expr_stmt|;
comment|/* 			 * Ensure Ultra mode is set properly for 			 * this target. 			 */
name|tstate
operator|->
name|ultraenb
operator|&=
operator|~
name|devinfo
operator|->
name|target_mask
expr_stmt|;
if|if
condition|(
name|syncrate
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|syncrate
operator|->
name|sxfr
operator|&
name|ULTRA_SXFR
condition|)
block|{
name|tstate
operator|->
name|ultraenb
operator||=
name|devinfo
operator|->
name|target_mask
expr_stmt|;
block|}
name|scsirate
operator||=
name|syncrate
operator|->
name|sxfr
operator|&
name|SXFR
expr_stmt|;
name|scsirate
operator||=
name|offset
operator|&
name|SOFS
expr_stmt|;
block|}
if|if
condition|(
name|active
condition|)
block|{
name|u_int
name|sxfrctl0
decl_stmt|;
name|sxfrctl0
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SXFRCTL0
argument_list|)
expr_stmt|;
name|sxfrctl0
operator|&=
operator|~
name|FAST20
expr_stmt|;
if|if
condition|(
name|tstate
operator|->
name|ultraenb
operator|&
name|devinfo
operator|->
name|target_mask
condition|)
name|sxfrctl0
operator||=
name|FAST20
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SXFRCTL0
argument_list|,
name|sxfrctl0
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|active
condition|)
block|{
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCSIRATE
argument_list|,
name|scsirate
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ahc
operator|->
name|features
operator|&
name|AHC_ULTRA2
operator|)
operator|!=
literal|0
condition|)
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCSIOFFSET
argument_list|,
name|offset
argument_list|)
expr_stmt|;
block|}
name|tinfo
operator|->
name|scsirate
operator|=
name|scsirate
expr_stmt|;
name|tinfo
operator|->
name|curr
operator|.
name|period
operator|=
name|period
expr_stmt|;
name|tinfo
operator|->
name|curr
operator|.
name|offset
operator|=
name|offset
expr_stmt|;
name|tinfo
operator|->
name|curr
operator|.
name|ppr_options
operator|=
name|ppr_options
expr_stmt|;
name|ahc_send_async
argument_list|(
name|ahc
argument_list|,
name|devinfo
operator|->
name|channel
argument_list|,
name|devinfo
operator|->
name|target
argument_list|,
name|CAM_LUN_WILDCARD
argument_list|,
name|AC_TRANSFER_NEG
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
block|{
if|if
condition|(
name|offset
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%s: target %d synchronous at %sMHz%s, "
literal|"offset = 0x%x\n"
argument_list|,
name|ahc_name
argument_list|(
name|ahc
argument_list|)
argument_list|,
name|devinfo
operator|->
name|target
argument_list|,
name|syncrate
operator|->
name|rate
argument_list|,
operator|(
name|ppr_options
operator|&
name|MSG_EXT_PPR_DT_REQ
operator|)
condition|?
literal|" DT"
else|:
literal|""
argument_list|,
name|offset
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"%s: target %d using "
literal|"asynchronous transfers\n"
argument_list|,
name|ahc_name
argument_list|(
name|ahc
argument_list|)
argument_list|,
name|devinfo
operator|->
name|target
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|update_needed
operator|+=
name|ahc_update_neg_request
argument_list|(
name|ahc
argument_list|,
name|devinfo
argument_list|,
name|tstate
argument_list|,
name|tinfo
argument_list|,
name|AHC_NEG_TO_GOAL
argument_list|)
expr_stmt|;
if|if
condition|(
name|update_needed
condition|)
name|ahc_update_pending_scbs
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Update the user/goal/curr tables of wide negotiation  * parameters as well as, in the case of a current or active update,  * any data structures on the host controller.  In the case of an  * active update, the specified target is currently talking to us on  * the bus, so the transfer parameter update must take effect  * immediately.  */
end_comment

begin_function
name|void
name|ahc_set_width
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|struct
name|ahc_devinfo
modifier|*
name|devinfo
parameter_list|,
name|u_int
name|width
parameter_list|,
name|u_int
name|type
parameter_list|,
name|int
name|paused
parameter_list|)
block|{
name|struct
name|ahc_initiator_tinfo
modifier|*
name|tinfo
decl_stmt|;
name|struct
name|ahc_tmode_tstate
modifier|*
name|tstate
decl_stmt|;
name|u_int
name|oldwidth
decl_stmt|;
name|int
name|active
decl_stmt|;
name|int
name|update_needed
decl_stmt|;
name|active
operator|=
operator|(
name|type
operator|&
name|AHC_TRANS_ACTIVE
operator|)
operator|==
name|AHC_TRANS_ACTIVE
expr_stmt|;
name|update_needed
operator|=
literal|0
expr_stmt|;
name|tinfo
operator|=
name|ahc_fetch_transinfo
argument_list|(
name|ahc
argument_list|,
name|devinfo
operator|->
name|channel
argument_list|,
name|devinfo
operator|->
name|our_scsiid
argument_list|,
name|devinfo
operator|->
name|target
argument_list|,
operator|&
name|tstate
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|type
operator|&
name|AHC_TRANS_USER
operator|)
operator|!=
literal|0
condition|)
name|tinfo
operator|->
name|user
operator|.
name|width
operator|=
name|width
expr_stmt|;
if|if
condition|(
operator|(
name|type
operator|&
name|AHC_TRANS_GOAL
operator|)
operator|!=
literal|0
condition|)
name|tinfo
operator|->
name|goal
operator|.
name|width
operator|=
name|width
expr_stmt|;
name|oldwidth
operator|=
name|tinfo
operator|->
name|curr
operator|.
name|width
expr_stmt|;
if|if
condition|(
operator|(
name|type
operator|&
name|AHC_TRANS_CUR
operator|)
operator|!=
literal|0
operator|&&
name|oldwidth
operator|!=
name|width
condition|)
block|{
name|u_int
name|scsirate
decl_stmt|;
name|update_needed
operator|++
expr_stmt|;
name|scsirate
operator|=
name|tinfo
operator|->
name|scsirate
expr_stmt|;
name|scsirate
operator|&=
operator|~
name|WIDEXFER
expr_stmt|;
if|if
condition|(
name|width
operator|==
name|MSG_EXT_WDTR_BUS_16_BIT
condition|)
name|scsirate
operator||=
name|WIDEXFER
expr_stmt|;
name|tinfo
operator|->
name|scsirate
operator|=
name|scsirate
expr_stmt|;
if|if
condition|(
name|active
condition|)
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCSIRATE
argument_list|,
name|scsirate
argument_list|)
expr_stmt|;
name|tinfo
operator|->
name|curr
operator|.
name|width
operator|=
name|width
expr_stmt|;
name|ahc_send_async
argument_list|(
name|ahc
argument_list|,
name|devinfo
operator|->
name|channel
argument_list|,
name|devinfo
operator|->
name|target
argument_list|,
name|CAM_LUN_WILDCARD
argument_list|,
name|AC_TRANSFER_NEG
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
block|{
name|printf
argument_list|(
literal|"%s: target %d using %dbit transfers\n"
argument_list|,
name|ahc_name
argument_list|(
name|ahc
argument_list|)
argument_list|,
name|devinfo
operator|->
name|target
argument_list|,
literal|8
operator|*
operator|(
literal|0x01
operator|<<
name|width
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
name|update_needed
operator|+=
name|ahc_update_neg_request
argument_list|(
name|ahc
argument_list|,
name|devinfo
argument_list|,
name|tstate
argument_list|,
name|tinfo
argument_list|,
name|AHC_NEG_TO_GOAL
argument_list|)
expr_stmt|;
if|if
condition|(
name|update_needed
condition|)
name|ahc_update_pending_scbs
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Update the current state of tagged queuing for a given target.  */
end_comment

begin_function
name|void
name|ahc_set_tags
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|struct
name|ahc_devinfo
modifier|*
name|devinfo
parameter_list|,
name|ahc_queue_alg
name|alg
parameter_list|)
block|{
name|ahc_platform_set_tags
argument_list|(
name|ahc
argument_list|,
name|devinfo
argument_list|,
name|alg
argument_list|)
expr_stmt|;
name|ahc_send_async
argument_list|(
name|ahc
argument_list|,
name|devinfo
operator|->
name|channel
argument_list|,
name|devinfo
operator|->
name|target
argument_list|,
name|devinfo
operator|->
name|lun
argument_list|,
name|AC_TRANSFER_NEG
argument_list|,
operator|&
name|alg
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * When the transfer settings for a connection change, update any  * in-transit SCBs to contain the new data so the hardware will  * be set correctly during future (re)selections.  */
end_comment

begin_function
specifier|static
name|void
name|ahc_update_pending_scbs
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|)
block|{
name|struct
name|scb
modifier|*
name|pending_scb
decl_stmt|;
name|int
name|pending_scb_count
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|paused
decl_stmt|;
name|u_int
name|saved_scbptr
decl_stmt|;
comment|/* 	 * Traverse the pending SCB list and ensure that all of the 	 * SCBs there have the proper settings. 	 */
name|pending_scb_count
operator|=
literal|0
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|pending_scb
argument_list|,
argument|&ahc->pending_scbs
argument_list|,
argument|pending_links
argument_list|)
block|{
name|struct
name|ahc_devinfo
name|devinfo
decl_stmt|;
name|struct
name|hardware_scb
modifier|*
name|pending_hscb
decl_stmt|;
name|struct
name|ahc_initiator_tinfo
modifier|*
name|tinfo
decl_stmt|;
name|struct
name|ahc_tmode_tstate
modifier|*
name|tstate
decl_stmt|;
name|ahc_scb_devinfo
argument_list|(
name|ahc
argument_list|,
operator|&
name|devinfo
argument_list|,
name|pending_scb
argument_list|)
expr_stmt|;
name|tinfo
operator|=
name|ahc_fetch_transinfo
argument_list|(
name|ahc
argument_list|,
name|devinfo
operator|.
name|channel
argument_list|,
name|devinfo
operator|.
name|our_scsiid
argument_list|,
name|devinfo
operator|.
name|target
argument_list|,
operator|&
name|tstate
argument_list|)
expr_stmt|;
name|pending_hscb
operator|=
name|pending_scb
operator|->
name|hscb
expr_stmt|;
name|pending_hscb
operator|->
name|control
operator|&=
operator|~
name|ULTRAENB
expr_stmt|;
if|if
condition|(
operator|(
name|tstate
operator|->
name|ultraenb
operator|&
name|devinfo
operator|.
name|target_mask
operator|)
operator|!=
literal|0
condition|)
name|pending_hscb
operator|->
name|control
operator||=
name|ULTRAENB
expr_stmt|;
name|pending_hscb
operator|->
name|scsirate
operator|=
name|tinfo
operator|->
name|scsirate
expr_stmt|;
name|pending_hscb
operator|->
name|scsioffset
operator|=
name|tinfo
operator|->
name|curr
operator|.
name|offset
expr_stmt|;
if|if
condition|(
operator|(
name|tstate
operator|->
name|auto_negotiate
operator|&
name|devinfo
operator|.
name|target_mask
operator|)
operator|==
literal|0
operator|&&
operator|(
name|pending_scb
operator|->
name|flags
operator|&
name|SCB_AUTO_NEGOTIATE
operator|)
operator|!=
literal|0
condition|)
block|{
name|pending_scb
operator|->
name|flags
operator|&=
operator|~
name|SCB_AUTO_NEGOTIATE
expr_stmt|;
name|pending_hscb
operator|->
name|control
operator|&=
operator|~
name|MK_MESSAGE
expr_stmt|;
block|}
name|ahc_sync_scb
argument_list|(
name|ahc
argument_list|,
name|pending_scb
argument_list|,
name|BUS_DMASYNC_PREREAD
operator||
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
name|pending_scb_count
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|pending_scb_count
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|ahc_is_paused
argument_list|(
name|ahc
argument_list|)
condition|)
block|{
name|paused
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|paused
operator|=
literal|0
expr_stmt|;
name|ahc_pause
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
block|}
name|saved_scbptr
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCBPTR
argument_list|)
expr_stmt|;
comment|/* Ensure that the hscbs down on the card match the new information */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ahc
operator|->
name|scb_data
operator|->
name|maxhscbs
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|hardware_scb
modifier|*
name|pending_hscb
decl_stmt|;
name|u_int
name|control
decl_stmt|;
name|u_int
name|scb_tag
decl_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCBPTR
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|scb_tag
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCB_TAG
argument_list|)
expr_stmt|;
name|pending_scb
operator|=
name|ahc_lookup_scb
argument_list|(
name|ahc
argument_list|,
name|scb_tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|pending_scb
operator|==
name|NULL
condition|)
continue|continue;
name|pending_hscb
operator|=
name|pending_scb
operator|->
name|hscb
expr_stmt|;
name|control
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCB_CONTROL
argument_list|)
expr_stmt|;
name|control
operator|&=
operator|~
operator|(
name|ULTRAENB
operator||
name|MK_MESSAGE
operator|)
expr_stmt|;
name|control
operator||=
name|pending_hscb
operator|->
name|control
operator|&
operator|(
name|ULTRAENB
operator||
name|MK_MESSAGE
operator|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCB_CONTROL
argument_list|,
name|control
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCB_SCSIRATE
argument_list|,
name|pending_hscb
operator|->
name|scsirate
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCB_SCSIOFFSET
argument_list|,
name|pending_hscb
operator|->
name|scsioffset
argument_list|)
expr_stmt|;
block|}
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCBPTR
argument_list|,
name|saved_scbptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|paused
operator|==
literal|0
condition|)
name|ahc_unpause
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**************************** Pathing Information *****************************/
end_comment

begin_function
specifier|static
name|void
name|ahc_fetch_devinfo
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|struct
name|ahc_devinfo
modifier|*
name|devinfo
parameter_list|)
block|{
name|u_int
name|saved_scsiid
decl_stmt|;
name|role_t
name|role
decl_stmt|;
name|int
name|our_id
decl_stmt|;
if|if
condition|(
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SSTAT0
argument_list|)
operator|&
name|TARGET
condition|)
name|role
operator|=
name|ROLE_TARGET
expr_stmt|;
else|else
name|role
operator|=
name|ROLE_INITIATOR
expr_stmt|;
if|if
condition|(
name|role
operator|==
name|ROLE_TARGET
operator|&&
operator|(
name|ahc
operator|->
name|features
operator|&
name|AHC_MULTI_TID
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SEQ_FLAGS
argument_list|)
operator|&
operator|(
name|CMDPHASE_PENDING
operator||
name|TARG_CMD_PENDING
operator||
name|NO_DISCONNECT
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* We were selected, so pull our id from TARGIDIN */
name|our_id
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|TARGIDIN
argument_list|)
operator|&
name|OID
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|ahc
operator|->
name|features
operator|&
name|AHC_ULTRA2
operator|)
operator|!=
literal|0
condition|)
name|our_id
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCSIID_ULTRA2
argument_list|)
operator|&
name|OID
expr_stmt|;
else|else
name|our_id
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCSIID
argument_list|)
operator|&
name|OID
expr_stmt|;
name|saved_scsiid
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SAVED_SCSIID
argument_list|)
expr_stmt|;
name|ahc_compile_devinfo
argument_list|(
name|devinfo
argument_list|,
name|our_id
argument_list|,
name|SCSIID_TARGET
argument_list|(
name|ahc
argument_list|,
name|saved_scsiid
argument_list|)
argument_list|,
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SAVED_LUN
argument_list|)
argument_list|,
name|SCSIID_CHANNEL
argument_list|(
name|ahc
argument_list|,
name|saved_scsiid
argument_list|)
argument_list|,
name|role
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|struct
name|ahc_phase_table_entry
modifier|*
name|ahc_lookup_phase_entry
parameter_list|(
name|int
name|phase
parameter_list|)
block|{
name|struct
name|ahc_phase_table_entry
modifier|*
name|entry
decl_stmt|;
name|struct
name|ahc_phase_table_entry
modifier|*
name|last_entry
decl_stmt|;
comment|/* 	 * num_phases doesn't include the default entry which 	 * will be returned if the phase doesn't match. 	 */
name|last_entry
operator|=
operator|&
name|ahc_phase_table
index|[
name|num_phases
index|]
expr_stmt|;
for|for
control|(
name|entry
operator|=
name|ahc_phase_table
init|;
name|entry
operator|<
name|last_entry
condition|;
name|entry
operator|++
control|)
block|{
if|if
condition|(
name|phase
operator|==
name|entry
operator|->
name|phase
condition|)
break|break;
block|}
return|return
operator|(
name|entry
operator|)
return|;
block|}
end_function

begin_function
name|void
name|ahc_compile_devinfo
parameter_list|(
name|struct
name|ahc_devinfo
modifier|*
name|devinfo
parameter_list|,
name|u_int
name|our_id
parameter_list|,
name|u_int
name|target
parameter_list|,
name|u_int
name|lun
parameter_list|,
name|char
name|channel
parameter_list|,
name|role_t
name|role
parameter_list|)
block|{
name|devinfo
operator|->
name|our_scsiid
operator|=
name|our_id
expr_stmt|;
name|devinfo
operator|->
name|target
operator|=
name|target
expr_stmt|;
name|devinfo
operator|->
name|lun
operator|=
name|lun
expr_stmt|;
name|devinfo
operator|->
name|target_offset
operator|=
name|target
expr_stmt|;
name|devinfo
operator|->
name|channel
operator|=
name|channel
expr_stmt|;
name|devinfo
operator|->
name|role
operator|=
name|role
expr_stmt|;
if|if
condition|(
name|channel
operator|==
literal|'B'
condition|)
name|devinfo
operator|->
name|target_offset
operator|+=
literal|8
expr_stmt|;
name|devinfo
operator|->
name|target_mask
operator|=
operator|(
literal|0x01
operator|<<
name|devinfo
operator|->
name|target_offset
operator|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ahc_print_devinfo
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|struct
name|ahc_devinfo
modifier|*
name|devinfo
parameter_list|)
block|{
name|printf
argument_list|(
literal|"%s:%c:%d:%d: "
argument_list|,
name|ahc_name
argument_list|(
name|ahc
argument_list|)
argument_list|,
name|devinfo
operator|->
name|channel
argument_list|,
name|devinfo
operator|->
name|target
argument_list|,
name|devinfo
operator|->
name|lun
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ahc_scb_devinfo
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|struct
name|ahc_devinfo
modifier|*
name|devinfo
parameter_list|,
name|struct
name|scb
modifier|*
name|scb
parameter_list|)
block|{
name|role_t
name|role
decl_stmt|;
name|int
name|our_id
decl_stmt|;
name|our_id
operator|=
name|SCSIID_OUR_ID
argument_list|(
name|scb
operator|->
name|hscb
operator|->
name|scsiid
argument_list|)
expr_stmt|;
name|role
operator|=
name|ROLE_INITIATOR
expr_stmt|;
if|if
condition|(
operator|(
name|scb
operator|->
name|flags
operator|&
name|SCB_TARGET_SCB
operator|)
operator|!=
literal|0
condition|)
name|role
operator|=
name|ROLE_TARGET
expr_stmt|;
name|ahc_compile_devinfo
argument_list|(
name|devinfo
argument_list|,
name|our_id
argument_list|,
name|SCB_GET_TARGET
argument_list|(
name|ahc
argument_list|,
name|scb
argument_list|)
argument_list|,
name|SCB_GET_LUN
argument_list|(
name|scb
argument_list|)
argument_list|,
name|SCB_GET_CHANNEL
argument_list|(
name|ahc
argument_list|,
name|scb
argument_list|)
argument_list|,
name|role
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/************************ Message Phase Processing ****************************/
end_comment

begin_function
specifier|static
name|void
name|ahc_assert_atn
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|)
block|{
name|u_int
name|scsisigo
decl_stmt|;
name|scsisigo
operator|=
name|ATNO
expr_stmt|;
if|if
condition|(
operator|(
name|ahc
operator|->
name|features
operator|&
name|AHC_DT
operator|)
operator|==
literal|0
condition|)
name|scsisigo
operator||=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCSISIGI
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCSISIGO
argument_list|,
name|scsisigo
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * When an initiator transaction with the MK_MESSAGE flag either reconnects  * or enters the initial message out phase, we are interrupted.  Fill our  * outgoing message buffer with the appropriate message and beging handing  * the message phase(s) manually.  */
end_comment

begin_function
specifier|static
name|void
name|ahc_setup_initiator_msgout
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|struct
name|ahc_devinfo
modifier|*
name|devinfo
parameter_list|,
name|struct
name|scb
modifier|*
name|scb
parameter_list|)
block|{
comment|/* 	 * To facilitate adding multiple messages together, 	 * each routine should increment the index and len 	 * variables instead of setting them explicitly. 	 */
name|ahc
operator|->
name|msgout_index
operator|=
literal|0
expr_stmt|;
name|ahc
operator|->
name|msgout_len
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|scb
operator|->
name|flags
operator|&
name|SCB_DEVICE_RESET
operator|)
operator|==
literal|0
operator|&&
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|MSG_OUT
argument_list|)
operator|==
name|MSG_IDENTIFYFLAG
condition|)
block|{
name|u_int
name|identify_msg
decl_stmt|;
name|identify_msg
operator|=
name|MSG_IDENTIFYFLAG
operator||
name|SCB_GET_LUN
argument_list|(
name|scb
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|scb
operator|->
name|hscb
operator|->
name|control
operator|&
name|DISCENB
operator|)
operator|!=
literal|0
condition|)
name|identify_msg
operator||=
name|MSG_IDENTIFY_DISCFLAG
expr_stmt|;
name|ahc
operator|->
name|msgout_buf
index|[
name|ahc
operator|->
name|msgout_index
operator|++
index|]
operator|=
name|identify_msg
expr_stmt|;
name|ahc
operator|->
name|msgout_len
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|scb
operator|->
name|hscb
operator|->
name|control
operator|&
name|TAG_ENB
operator|)
operator|!=
literal|0
condition|)
block|{
name|ahc
operator|->
name|msgout_buf
index|[
name|ahc
operator|->
name|msgout_index
operator|++
index|]
operator|=
name|scb
operator|->
name|hscb
operator|->
name|control
operator|&
operator|(
name|TAG_ENB
operator||
name|SCB_TAG_TYPE
operator|)
expr_stmt|;
name|ahc
operator|->
name|msgout_buf
index|[
name|ahc
operator|->
name|msgout_index
operator|++
index|]
operator|=
name|scb
operator|->
name|hscb
operator|->
name|tag
expr_stmt|;
name|ahc
operator|->
name|msgout_len
operator|+=
literal|2
expr_stmt|;
block|}
block|}
if|if
condition|(
name|scb
operator|->
name|flags
operator|&
name|SCB_DEVICE_RESET
condition|)
block|{
name|ahc
operator|->
name|msgout_buf
index|[
name|ahc
operator|->
name|msgout_index
operator|++
index|]
operator|=
name|MSG_BUS_DEV_RESET
expr_stmt|;
name|ahc
operator|->
name|msgout_len
operator|++
expr_stmt|;
name|ahc_print_path
argument_list|(
name|ahc
argument_list|,
name|scb
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Bus Device Reset Message Sent\n"
argument_list|)
expr_stmt|;
comment|/* 		 * Clear our selection hardware in advance of 		 * the busfree.  We may have an entry in the waiting 		 * Q for this target, and we don't want to go about 		 * selecting while we handle the busfree and blow it 		 * away. 		 */
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCSISEQ
argument_list|,
operator|(
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCSISEQ
argument_list|)
operator|&
operator|~
name|ENSELO
operator|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|scb
operator|->
name|flags
operator|&
name|SCB_ABORT
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|scb
operator|->
name|hscb
operator|->
name|control
operator|&
name|TAG_ENB
operator|)
operator|!=
literal|0
condition|)
name|ahc
operator|->
name|msgout_buf
index|[
name|ahc
operator|->
name|msgout_index
operator|++
index|]
operator|=
name|MSG_ABORT_TAG
expr_stmt|;
else|else
name|ahc
operator|->
name|msgout_buf
index|[
name|ahc
operator|->
name|msgout_index
operator|++
index|]
operator|=
name|MSG_ABORT
expr_stmt|;
name|ahc
operator|->
name|msgout_len
operator|++
expr_stmt|;
name|ahc_print_path
argument_list|(
name|ahc
argument_list|,
name|scb
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Abort%s Message Sent\n"
argument_list|,
operator|(
name|scb
operator|->
name|hscb
operator|->
name|control
operator|&
name|TAG_ENB
operator|)
operator|!=
literal|0
condition|?
literal|" Tag"
else|:
literal|""
argument_list|)
expr_stmt|;
comment|/* 		 * Clear our selection hardware in advance of 		 * the busfree.  We may have an entry in the waiting 		 * Q for this target, and we don't want to go about 		 * selecting while we handle the busfree and blow it 		 * away. 		 */
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCSISEQ
argument_list|,
operator|(
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCSISEQ
argument_list|)
operator|&
operator|~
name|ENSELO
operator|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|scb
operator|->
name|flags
operator|&
operator|(
name|SCB_AUTO_NEGOTIATE
operator||
name|SCB_NEGOTIATE
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|ahc_build_transfer_msg
argument_list|(
name|ahc
argument_list|,
name|devinfo
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"ahc_intr: AWAITING_MSG for an SCB that "
literal|"does not have a waiting message\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"SCSIID = %x, target_mask = %x\n"
argument_list|,
name|scb
operator|->
name|hscb
operator|->
name|scsiid
argument_list|,
name|devinfo
operator|->
name|target_mask
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"SCB = %d, SCB Control = %x, MSG_OUT = %x "
literal|"SCB flags = %x"
argument_list|,
name|scb
operator|->
name|hscb
operator|->
name|tag
argument_list|,
name|scb
operator|->
name|hscb
operator|->
name|control
argument_list|,
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|MSG_OUT
argument_list|)
argument_list|,
name|scb
operator|->
name|flags
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Clear the MK_MESSAGE flag from the SCB so we aren't 	 * asked to send this message again. 	 */
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCB_CONTROL
argument_list|,
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCB_CONTROL
argument_list|)
operator|&
operator|~
name|MK_MESSAGE
argument_list|)
expr_stmt|;
name|scb
operator|->
name|hscb
operator|->
name|control
operator|&=
operator|~
name|MK_MESSAGE
expr_stmt|;
name|ahc
operator|->
name|msgout_index
operator|=
literal|0
expr_stmt|;
name|ahc
operator|->
name|msg_type
operator|=
name|MSG_TYPE_INITIATOR_MSGOUT
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Build an appropriate transfer negotiation message for the  * currently active target.  */
end_comment

begin_function
specifier|static
name|void
name|ahc_build_transfer_msg
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|struct
name|ahc_devinfo
modifier|*
name|devinfo
parameter_list|)
block|{
comment|/* 	 * We need to initiate transfer negotiations. 	 * If our current and goal settings are identical, 	 * we want to renegotiate due to a check condition. 	 */
name|struct
name|ahc_initiator_tinfo
modifier|*
name|tinfo
decl_stmt|;
name|struct
name|ahc_tmode_tstate
modifier|*
name|tstate
decl_stmt|;
name|struct
name|ahc_syncrate
modifier|*
name|rate
decl_stmt|;
name|int
name|dowide
decl_stmt|;
name|int
name|dosync
decl_stmt|;
name|int
name|doppr
decl_stmt|;
name|u_int
name|period
decl_stmt|;
name|u_int
name|ppr_options
decl_stmt|;
name|u_int
name|offset
decl_stmt|;
name|tinfo
operator|=
name|ahc_fetch_transinfo
argument_list|(
name|ahc
argument_list|,
name|devinfo
operator|->
name|channel
argument_list|,
name|devinfo
operator|->
name|our_scsiid
argument_list|,
name|devinfo
operator|->
name|target
argument_list|,
operator|&
name|tstate
argument_list|)
expr_stmt|;
comment|/* 	 * Filter our period based on the current connection. 	 * If we can't perform DT transfers on this segment (not in LVD 	 * mode for instance), then our decision to issue a PPR message 	 * may change. 	 */
name|period
operator|=
name|tinfo
operator|->
name|goal
operator|.
name|period
expr_stmt|;
name|offset
operator|=
name|tinfo
operator|->
name|goal
operator|.
name|offset
expr_stmt|;
name|ppr_options
operator|=
name|tinfo
operator|->
name|goal
operator|.
name|ppr_options
expr_stmt|;
comment|/* Target initiated PPR is not allowed in the SCSI spec */
if|if
condition|(
name|devinfo
operator|->
name|role
operator|==
name|ROLE_TARGET
condition|)
name|ppr_options
operator|=
literal|0
expr_stmt|;
name|rate
operator|=
name|ahc_devlimited_syncrate
argument_list|(
name|ahc
argument_list|,
name|tinfo
argument_list|,
operator|&
name|period
argument_list|,
operator|&
name|ppr_options
argument_list|,
name|devinfo
operator|->
name|role
argument_list|)
expr_stmt|;
name|dowide
operator|=
name|tinfo
operator|->
name|curr
operator|.
name|width
operator|!=
name|tinfo
operator|->
name|goal
operator|.
name|width
expr_stmt|;
name|dosync
operator|=
name|tinfo
operator|->
name|curr
operator|.
name|offset
operator|!=
name|offset
operator|||
name|tinfo
operator|->
name|curr
operator|.
name|period
operator|!=
name|period
expr_stmt|;
comment|/* 	 * Only use PPR if we have options that need it, even if the device 	 * claims to support it.  There might be an expander in the way 	 * that doesn't. 	 */
name|doppr
operator|=
name|ppr_options
operator|!=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|dowide
operator|&&
operator|!
name|dosync
operator|&&
operator|!
name|doppr
condition|)
block|{
name|dowide
operator|=
name|tinfo
operator|->
name|goal
operator|.
name|width
operator|!=
name|MSG_EXT_WDTR_BUS_8_BIT
expr_stmt|;
name|dosync
operator|=
name|tinfo
operator|->
name|goal
operator|.
name|offset
operator|!=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|dowide
operator|&&
operator|!
name|dosync
operator|&&
operator|!
name|doppr
condition|)
block|{
comment|/* 		 * Force async with a WDTR message if we have a wide bus, 		 * or just issue an SDTR with a 0 offset. 		 */
if|if
condition|(
operator|(
name|ahc
operator|->
name|features
operator|&
name|AHC_WIDE
operator|)
operator|!=
literal|0
condition|)
name|dowide
operator|=
literal|1
expr_stmt|;
else|else
name|dosync
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
block|{
name|ahc_print_devinfo
argument_list|(
name|ahc
argument_list|,
name|devinfo
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Ensuring async\n"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Target initiated PPR is not allowed in the SCSI spec */
if|if
condition|(
name|devinfo
operator|->
name|role
operator|==
name|ROLE_TARGET
condition|)
name|doppr
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Both the PPR message and SDTR message require the 	 * goal syncrate to be limited to what the target device 	 * is capable of handling (based on whether an LVD->SE 	 * expander is on the bus), so combine these two cases. 	 * Regardless, guarantee that if we are using WDTR and SDTR 	 * messages that WDTR comes first. 	 */
if|if
condition|(
name|doppr
operator|||
operator|(
name|dosync
operator|&&
operator|!
name|dowide
operator|)
condition|)
block|{
name|offset
operator|=
name|tinfo
operator|->
name|goal
operator|.
name|offset
expr_stmt|;
name|ahc_validate_offset
argument_list|(
name|ahc
argument_list|,
name|tinfo
argument_list|,
name|rate
argument_list|,
operator|&
name|offset
argument_list|,
name|doppr
condition|?
name|tinfo
operator|->
name|goal
operator|.
name|width
else|:
name|tinfo
operator|->
name|curr
operator|.
name|width
argument_list|,
name|devinfo
operator|->
name|role
argument_list|)
expr_stmt|;
if|if
condition|(
name|doppr
condition|)
block|{
name|ahc_construct_ppr
argument_list|(
name|ahc
argument_list|,
name|devinfo
argument_list|,
name|period
argument_list|,
name|offset
argument_list|,
name|tinfo
operator|->
name|goal
operator|.
name|width
argument_list|,
name|ppr_options
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ahc_construct_sdtr
argument_list|(
name|ahc
argument_list|,
name|devinfo
argument_list|,
name|period
argument_list|,
name|offset
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|ahc_construct_wdtr
argument_list|(
name|ahc
argument_list|,
name|devinfo
argument_list|,
name|tinfo
operator|->
name|goal
operator|.
name|width
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Build a synchronous negotiation message in our message  * buffer based on the input parameters.  */
end_comment

begin_function
specifier|static
name|void
name|ahc_construct_sdtr
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|struct
name|ahc_devinfo
modifier|*
name|devinfo
parameter_list|,
name|u_int
name|period
parameter_list|,
name|u_int
name|offset
parameter_list|)
block|{
if|if
condition|(
name|offset
operator|==
literal|0
condition|)
name|period
operator|=
name|AHC_ASYNC_XFER_PERIOD
expr_stmt|;
name|ahc
operator|->
name|msgout_buf
index|[
name|ahc
operator|->
name|msgout_index
operator|++
index|]
operator|=
name|MSG_EXTENDED
expr_stmt|;
name|ahc
operator|->
name|msgout_buf
index|[
name|ahc
operator|->
name|msgout_index
operator|++
index|]
operator|=
name|MSG_EXT_SDTR_LEN
expr_stmt|;
name|ahc
operator|->
name|msgout_buf
index|[
name|ahc
operator|->
name|msgout_index
operator|++
index|]
operator|=
name|MSG_EXT_SDTR
expr_stmt|;
name|ahc
operator|->
name|msgout_buf
index|[
name|ahc
operator|->
name|msgout_index
operator|++
index|]
operator|=
name|period
expr_stmt|;
name|ahc
operator|->
name|msgout_buf
index|[
name|ahc
operator|->
name|msgout_index
operator|++
index|]
operator|=
name|offset
expr_stmt|;
name|ahc
operator|->
name|msgout_len
operator|+=
literal|5
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
block|{
name|printf
argument_list|(
literal|"(%s:%c:%d:%d): Sending SDTR period %x, offset %x\n"
argument_list|,
name|ahc_name
argument_list|(
name|ahc
argument_list|)
argument_list|,
name|devinfo
operator|->
name|channel
argument_list|,
name|devinfo
operator|->
name|target
argument_list|,
name|devinfo
operator|->
name|lun
argument_list|,
name|period
argument_list|,
name|offset
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Build a wide negotiation message in our message  * buffer based on the input parameters.  */
end_comment

begin_function
specifier|static
name|void
name|ahc_construct_wdtr
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|struct
name|ahc_devinfo
modifier|*
name|devinfo
parameter_list|,
name|u_int
name|bus_width
parameter_list|)
block|{
name|ahc
operator|->
name|msgout_buf
index|[
name|ahc
operator|->
name|msgout_index
operator|++
index|]
operator|=
name|MSG_EXTENDED
expr_stmt|;
name|ahc
operator|->
name|msgout_buf
index|[
name|ahc
operator|->
name|msgout_index
operator|++
index|]
operator|=
name|MSG_EXT_WDTR_LEN
expr_stmt|;
name|ahc
operator|->
name|msgout_buf
index|[
name|ahc
operator|->
name|msgout_index
operator|++
index|]
operator|=
name|MSG_EXT_WDTR
expr_stmt|;
name|ahc
operator|->
name|msgout_buf
index|[
name|ahc
operator|->
name|msgout_index
operator|++
index|]
operator|=
name|bus_width
expr_stmt|;
name|ahc
operator|->
name|msgout_len
operator|+=
literal|4
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
block|{
name|printf
argument_list|(
literal|"(%s:%c:%d:%d): Sending WDTR %x\n"
argument_list|,
name|ahc_name
argument_list|(
name|ahc
argument_list|)
argument_list|,
name|devinfo
operator|->
name|channel
argument_list|,
name|devinfo
operator|->
name|target
argument_list|,
name|devinfo
operator|->
name|lun
argument_list|,
name|bus_width
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Build a parallel protocol request message in our message  * buffer based on the input parameters.  */
end_comment

begin_function
specifier|static
name|void
name|ahc_construct_ppr
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|struct
name|ahc_devinfo
modifier|*
name|devinfo
parameter_list|,
name|u_int
name|period
parameter_list|,
name|u_int
name|offset
parameter_list|,
name|u_int
name|bus_width
parameter_list|,
name|u_int
name|ppr_options
parameter_list|)
block|{
if|if
condition|(
name|offset
operator|==
literal|0
condition|)
name|period
operator|=
name|AHC_ASYNC_XFER_PERIOD
expr_stmt|;
name|ahc
operator|->
name|msgout_buf
index|[
name|ahc
operator|->
name|msgout_index
operator|++
index|]
operator|=
name|MSG_EXTENDED
expr_stmt|;
name|ahc
operator|->
name|msgout_buf
index|[
name|ahc
operator|->
name|msgout_index
operator|++
index|]
operator|=
name|MSG_EXT_PPR_LEN
expr_stmt|;
name|ahc
operator|->
name|msgout_buf
index|[
name|ahc
operator|->
name|msgout_index
operator|++
index|]
operator|=
name|MSG_EXT_PPR
expr_stmt|;
name|ahc
operator|->
name|msgout_buf
index|[
name|ahc
operator|->
name|msgout_index
operator|++
index|]
operator|=
name|period
expr_stmt|;
name|ahc
operator|->
name|msgout_buf
index|[
name|ahc
operator|->
name|msgout_index
operator|++
index|]
operator|=
literal|0
expr_stmt|;
name|ahc
operator|->
name|msgout_buf
index|[
name|ahc
operator|->
name|msgout_index
operator|++
index|]
operator|=
name|offset
expr_stmt|;
name|ahc
operator|->
name|msgout_buf
index|[
name|ahc
operator|->
name|msgout_index
operator|++
index|]
operator|=
name|bus_width
expr_stmt|;
name|ahc
operator|->
name|msgout_buf
index|[
name|ahc
operator|->
name|msgout_index
operator|++
index|]
operator|=
name|ppr_options
expr_stmt|;
name|ahc
operator|->
name|msgout_len
operator|+=
literal|8
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
block|{
name|printf
argument_list|(
literal|"(%s:%c:%d:%d): Sending PPR bus_width %x, period %x, "
literal|"offset %x, ppr_options %x\n"
argument_list|,
name|ahc_name
argument_list|(
name|ahc
argument_list|)
argument_list|,
name|devinfo
operator|->
name|channel
argument_list|,
name|devinfo
operator|->
name|target
argument_list|,
name|devinfo
operator|->
name|lun
argument_list|,
name|bus_width
argument_list|,
name|period
argument_list|,
name|offset
argument_list|,
name|ppr_options
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Clear any active message state.  */
end_comment

begin_function
specifier|static
name|void
name|ahc_clear_msg_state
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|)
block|{
name|ahc
operator|->
name|msgout_len
operator|=
literal|0
expr_stmt|;
name|ahc
operator|->
name|msgin_index
operator|=
literal|0
expr_stmt|;
name|ahc
operator|->
name|msg_type
operator|=
name|MSG_TYPE_NONE
expr_stmt|;
if|if
condition|(
operator|(
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCSISIGI
argument_list|)
operator|&
name|ATNI
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * The target didn't care to respond to our 		 * message request, so clear ATN. 		 */
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|CLRSINT1
argument_list|,
name|CLRATNO
argument_list|)
expr_stmt|;
block|}
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|MSG_OUT
argument_list|,
name|MSG_NOOP
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SEQ_FLAGS2
argument_list|,
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SEQ_FLAGS2
argument_list|)
operator|&
operator|~
name|TARGET_MSG_PENDING
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ahc_handle_proto_violation
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|)
block|{
name|struct
name|ahc_devinfo
name|devinfo
decl_stmt|;
name|struct
name|scb
modifier|*
name|scb
decl_stmt|;
name|u_int
name|scbid
decl_stmt|;
name|u_int
name|seq_flags
decl_stmt|;
name|u_int
name|curphase
decl_stmt|;
name|u_int
name|lastphase
decl_stmt|;
name|int
name|found
decl_stmt|;
name|ahc_fetch_devinfo
argument_list|(
name|ahc
argument_list|,
operator|&
name|devinfo
argument_list|)
expr_stmt|;
name|scbid
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCB_TAG
argument_list|)
expr_stmt|;
name|scb
operator|=
name|ahc_lookup_scb
argument_list|(
name|ahc
argument_list|,
name|scbid
argument_list|)
expr_stmt|;
name|seq_flags
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SEQ_FLAGS
argument_list|)
expr_stmt|;
name|curphase
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCSISIGI
argument_list|)
operator|&
name|PHASE_MASK
expr_stmt|;
name|lastphase
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|LASTPHASE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|seq_flags
operator|&
name|NOT_IDENTIFIED
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * The reconnecting target either did not send an 		 * identify message, or did, but we didn't find an SCB 		 * to match. 		 */
name|ahc_print_devinfo
argument_list|(
name|ahc
argument_list|,
operator|&
name|devinfo
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Target did not send an IDENTIFY message. "
literal|"LASTPHASE = 0x%x.\n"
argument_list|,
name|lastphase
argument_list|)
expr_stmt|;
name|scb
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|scb
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * We don't seem to have an SCB active for this 		 * transaction.  Print an error and reset the bus. 		 */
name|ahc_print_devinfo
argument_list|(
name|ahc
argument_list|,
operator|&
name|devinfo
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"No SCB found during protocol violation\n"
argument_list|)
expr_stmt|;
goto|goto
name|proto_violation_reset
goto|;
block|}
else|else
block|{
name|aic_set_transaction_status
argument_list|(
name|scb
argument_list|,
name|CAM_SEQUENCE_FAIL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|seq_flags
operator|&
name|NO_CDB_SENT
operator|)
operator|!=
literal|0
condition|)
block|{
name|ahc_print_path
argument_list|(
name|ahc
argument_list|,
name|scb
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"No or incomplete CDB sent to device.\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCB_CONTROL
argument_list|)
operator|&
name|STATUS_RCVD
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 			 * The target never bothered to provide status to 			 * us prior to completing the command.  Since we don't 			 * know the disposition of this command, we must attempt 			 * to abort it.  Assert ATN and prepare to send an abort 			 * message. 			 */
name|ahc_print_path
argument_list|(
name|ahc
argument_list|,
name|scb
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Completed command without status.\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ahc_print_path
argument_list|(
name|ahc
argument_list|,
name|scb
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Unknown protocol violation.\n"
argument_list|)
expr_stmt|;
name|ahc_dump_card_state
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|lastphase
operator|&
operator|~
name|P_DATAIN_DT
operator|)
operator|==
literal|0
operator|||
name|lastphase
operator|==
name|P_COMMAND
condition|)
block|{
name|proto_violation_reset
label|:
comment|/* 		 * Target either went directly to data/command 		 * phase or didn't respond to our ATN. 		 * The only safe thing to do is to blow 		 * it away with a bus reset. 		 */
name|found
operator|=
name|ahc_reset_channel
argument_list|(
name|ahc
argument_list|,
literal|'A'
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s: Issued Channel %c Bus Reset. "
literal|"%d SCBs aborted\n"
argument_list|,
name|ahc_name
argument_list|(
name|ahc
argument_list|)
argument_list|,
literal|'A'
argument_list|,
name|found
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Leave the selection hardware off in case 		 * this abort attempt will affect yet to 		 * be sent commands. 		 */
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCSISEQ
argument_list|,
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCSISEQ
argument_list|)
operator|&
operator|~
name|ENSELO
argument_list|)
expr_stmt|;
name|ahc_assert_atn
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|MSG_OUT
argument_list|,
name|HOST_MSG
argument_list|)
expr_stmt|;
if|if
condition|(
name|scb
operator|==
name|NULL
condition|)
block|{
name|ahc_print_devinfo
argument_list|(
name|ahc
argument_list|,
operator|&
name|devinfo
argument_list|)
expr_stmt|;
name|ahc
operator|->
name|msgout_buf
index|[
literal|0
index|]
operator|=
name|MSG_ABORT_TASK
expr_stmt|;
name|ahc
operator|->
name|msgout_len
operator|=
literal|1
expr_stmt|;
name|ahc
operator|->
name|msgout_index
operator|=
literal|0
expr_stmt|;
name|ahc
operator|->
name|msg_type
operator|=
name|MSG_TYPE_INITIATOR_MSGOUT
expr_stmt|;
block|}
else|else
block|{
name|ahc_print_path
argument_list|(
name|ahc
argument_list|,
name|scb
argument_list|)
expr_stmt|;
name|scb
operator|->
name|flags
operator||=
name|SCB_ABORT
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"Protocol violation %s.  Attempting to abort.\n"
argument_list|,
name|ahc_lookup_phase_entry
argument_list|(
name|curphase
argument_list|)
operator|->
name|phasemsg
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Manual message loop handler.  */
end_comment

begin_function
specifier|static
name|void
name|ahc_handle_message_phase
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|)
block|{
name|struct
name|ahc_devinfo
name|devinfo
decl_stmt|;
name|u_int
name|bus_phase
decl_stmt|;
name|int
name|end_session
decl_stmt|;
name|ahc_fetch_devinfo
argument_list|(
name|ahc
argument_list|,
operator|&
name|devinfo
argument_list|)
expr_stmt|;
name|end_session
operator|=
name|FALSE
expr_stmt|;
name|bus_phase
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCSISIGI
argument_list|)
operator|&
name|PHASE_MASK
expr_stmt|;
name|reswitch
label|:
switch|switch
condition|(
name|ahc
operator|->
name|msg_type
condition|)
block|{
case|case
name|MSG_TYPE_INITIATOR_MSGOUT
case|:
block|{
name|int
name|lastbyte
decl_stmt|;
name|int
name|phasemis
decl_stmt|;
name|int
name|msgdone
decl_stmt|;
if|if
condition|(
name|ahc
operator|->
name|msgout_len
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"HOST_MSG_LOOP interrupt with no active message"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|AHC_DEBUG
if|if
condition|(
operator|(
name|ahc_debug
operator|&
name|AHC_SHOW_MESSAGES
operator|)
operator|!=
literal|0
condition|)
block|{
name|ahc_print_devinfo
argument_list|(
name|ahc
argument_list|,
operator|&
name|devinfo
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"INITIATOR_MSG_OUT"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|phasemis
operator|=
name|bus_phase
operator|!=
name|P_MESGOUT
expr_stmt|;
if|if
condition|(
name|phasemis
condition|)
block|{
ifdef|#
directive|ifdef
name|AHC_DEBUG
if|if
condition|(
operator|(
name|ahc_debug
operator|&
name|AHC_SHOW_MESSAGES
operator|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|" PHASEMIS %s\n"
argument_list|,
name|ahc_lookup_phase_entry
argument_list|(
name|bus_phase
argument_list|)
operator|->
name|phasemsg
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|bus_phase
operator|==
name|P_MESGIN
condition|)
block|{
comment|/* 				 * Change gears and see if 				 * this messages is of interest to 				 * us or should be passed back to 				 * the sequencer. 				 */
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|CLRSINT1
argument_list|,
name|CLRATNO
argument_list|)
expr_stmt|;
name|ahc
operator|->
name|send_msg_perror
operator|=
name|FALSE
expr_stmt|;
name|ahc
operator|->
name|msg_type
operator|=
name|MSG_TYPE_INITIATOR_MSGIN
expr_stmt|;
name|ahc
operator|->
name|msgin_index
operator|=
literal|0
expr_stmt|;
goto|goto
name|reswitch
goto|;
block|}
name|end_session
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ahc
operator|->
name|send_msg_perror
condition|)
block|{
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|CLRSINT1
argument_list|,
name|CLRATNO
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|CLRSINT1
argument_list|,
name|CLRREQINIT
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|AHC_DEBUG
if|if
condition|(
operator|(
name|ahc_debug
operator|&
name|AHC_SHOW_MESSAGES
operator|)
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|" byte 0x%x\n"
argument_list|,
name|ahc
operator|->
name|send_msg_perror
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCSIDATL
argument_list|,
name|MSG_PARITY_ERROR
argument_list|)
expr_stmt|;
break|break;
block|}
name|msgdone
operator|=
name|ahc
operator|->
name|msgout_index
operator|==
name|ahc
operator|->
name|msgout_len
expr_stmt|;
if|if
condition|(
name|msgdone
condition|)
block|{
comment|/* 			 * The target has requested a retry. 			 * Re-assert ATN, reset our message index to 			 * 0, and try again. 			 */
name|ahc
operator|->
name|msgout_index
operator|=
literal|0
expr_stmt|;
name|ahc_assert_atn
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
block|}
name|lastbyte
operator|=
name|ahc
operator|->
name|msgout_index
operator|==
operator|(
name|ahc
operator|->
name|msgout_len
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|lastbyte
condition|)
block|{
comment|/* Last byte is signified by dropping ATN */
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|CLRSINT1
argument_list|,
name|CLRATNO
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Clear our interrupt status and present 		 * the next byte on the bus. 		 */
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|CLRSINT1
argument_list|,
name|CLRREQINIT
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|AHC_DEBUG
if|if
condition|(
operator|(
name|ahc_debug
operator|&
name|AHC_SHOW_MESSAGES
operator|)
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|" byte 0x%x\n"
argument_list|,
name|ahc
operator|->
name|msgout_buf
index|[
name|ahc
operator|->
name|msgout_index
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCSIDATL
argument_list|,
name|ahc
operator|->
name|msgout_buf
index|[
name|ahc
operator|->
name|msgout_index
operator|++
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|MSG_TYPE_INITIATOR_MSGIN
case|:
block|{
name|int
name|phasemis
decl_stmt|;
name|int
name|message_done
decl_stmt|;
ifdef|#
directive|ifdef
name|AHC_DEBUG
if|if
condition|(
operator|(
name|ahc_debug
operator|&
name|AHC_SHOW_MESSAGES
operator|)
operator|!=
literal|0
condition|)
block|{
name|ahc_print_devinfo
argument_list|(
name|ahc
argument_list|,
operator|&
name|devinfo
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"INITIATOR_MSG_IN"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|phasemis
operator|=
name|bus_phase
operator|!=
name|P_MESGIN
expr_stmt|;
if|if
condition|(
name|phasemis
condition|)
block|{
ifdef|#
directive|ifdef
name|AHC_DEBUG
if|if
condition|(
operator|(
name|ahc_debug
operator|&
name|AHC_SHOW_MESSAGES
operator|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|" PHASEMIS %s\n"
argument_list|,
name|ahc_lookup_phase_entry
argument_list|(
name|bus_phase
argument_list|)
operator|->
name|phasemsg
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|ahc
operator|->
name|msgin_index
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|bus_phase
operator|==
name|P_MESGOUT
operator|&&
operator|(
name|ahc
operator|->
name|send_msg_perror
operator|==
name|TRUE
operator|||
operator|(
name|ahc
operator|->
name|msgout_len
operator|!=
literal|0
operator|&&
name|ahc
operator|->
name|msgout_index
operator|==
literal|0
operator|)
operator|)
condition|)
block|{
name|ahc
operator|->
name|msg_type
operator|=
name|MSG_TYPE_INITIATOR_MSGOUT
expr_stmt|;
goto|goto
name|reswitch
goto|;
block|}
name|end_session
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
comment|/* Pull the byte in without acking it */
name|ahc
operator|->
name|msgin_buf
index|[
name|ahc
operator|->
name|msgin_index
index|]
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCSIBUSL
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|AHC_DEBUG
if|if
condition|(
operator|(
name|ahc_debug
operator|&
name|AHC_SHOW_MESSAGES
operator|)
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|" byte 0x%x\n"
argument_list|,
name|ahc
operator|->
name|msgin_buf
index|[
name|ahc
operator|->
name|msgin_index
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|message_done
operator|=
name|ahc_parse_msg
argument_list|(
name|ahc
argument_list|,
operator|&
name|devinfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|message_done
condition|)
block|{
comment|/* 			 * Clear our incoming message buffer in case there 			 * is another message following this one. 			 */
name|ahc
operator|->
name|msgin_index
operator|=
literal|0
expr_stmt|;
comment|/* 			 * If this message illicited a response, 			 * assert ATN so the target takes us to the 			 * message out phase. 			 */
if|if
condition|(
name|ahc
operator|->
name|msgout_len
operator|!=
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|AHC_DEBUG
if|if
condition|(
operator|(
name|ahc_debug
operator|&
name|AHC_SHOW_MESSAGES
operator|)
operator|!=
literal|0
condition|)
block|{
name|ahc_print_devinfo
argument_list|(
name|ahc
argument_list|,
operator|&
name|devinfo
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Asserting ATN for response\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|ahc_assert_atn
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|ahc
operator|->
name|msgin_index
operator|++
expr_stmt|;
if|if
condition|(
name|message_done
operator|==
name|MSGLOOP_TERMINATED
condition|)
block|{
name|end_session
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
comment|/* Ack the byte */
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|CLRSINT1
argument_list|,
name|CLRREQINIT
argument_list|)
expr_stmt|;
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCSIDATL
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|MSG_TYPE_TARGET_MSGIN
case|:
block|{
name|int
name|msgdone
decl_stmt|;
if|if
condition|(
name|ahc
operator|->
name|msgout_len
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"Target MSGIN with no active message"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|AHC_DEBUG
if|if
condition|(
operator|(
name|ahc_debug
operator|&
name|AHC_SHOW_MESSAGES
operator|)
operator|!=
literal|0
condition|)
block|{
name|ahc_print_devinfo
argument_list|(
name|ahc
argument_list|,
operator|&
name|devinfo
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"TARGET_MSG_IN"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* 		 * If we interrupted a mesgout session, the initiator 		 * will not know this until our first REQ.  So, we 		 * only honor mesgout requests after we've sent our 		 * first byte. 		 */
if|if
condition|(
operator|(
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCSISIGI
argument_list|)
operator|&
name|ATNI
operator|)
operator|!=
literal|0
operator|&&
name|ahc
operator|->
name|msgout_index
operator|>
literal|0
condition|)
block|{
comment|/* 			 * Change gears and see if this messages is 			 * of interest to us or should be passed back 			 * to the sequencer. 			 */
ifdef|#
directive|ifdef
name|AHC_DEBUG
if|if
condition|(
operator|(
name|ahc_debug
operator|&
name|AHC_SHOW_MESSAGES
operator|)
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|" Honoring ATN Request.\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ahc
operator|->
name|msg_type
operator|=
name|MSG_TYPE_TARGET_MSGOUT
expr_stmt|;
comment|/* 			 * Disable SCSI Programmed I/O during the 			 * phase change so as to avoid phantom REQs. 			 */
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SXFRCTL0
argument_list|,
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SXFRCTL0
argument_list|)
operator|&
operator|~
name|SPIOEN
argument_list|)
expr_stmt|;
comment|/* 			 * Since SPIORDY asserts when ACK is asserted 			 * for P_MSGOUT, and SPIORDY's assertion triggered 			 * our entry into this routine, wait for ACK to 			 * *de-assert* before changing phases. 			 */
while|while
condition|(
operator|(
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCSISIGI
argument_list|)
operator|&
name|ACKI
operator|)
operator|!=
literal|0
condition|)
empty_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCSISIGO
argument_list|,
name|P_MESGOUT
operator||
name|BSYO
argument_list|)
expr_stmt|;
comment|/* 			 * All phase line changes require a bus 			 * settle delay before REQ is asserted. 			 * [SCSI SPI4 10.7.1] 			 */
name|ahc_flush_device_writes
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
name|aic_delay
argument_list|(
name|AHC_BUSSETTLE_DELAY
argument_list|)
expr_stmt|;
name|ahc
operator|->
name|msgin_index
operator|=
literal|0
expr_stmt|;
comment|/* Enable SCSI Programmed I/O to REQ for first byte */
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SXFRCTL0
argument_list|,
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SXFRCTL0
argument_list|)
operator||
name|SPIOEN
argument_list|)
expr_stmt|;
break|break;
block|}
name|msgdone
operator|=
name|ahc
operator|->
name|msgout_index
operator|==
name|ahc
operator|->
name|msgout_len
expr_stmt|;
if|if
condition|(
name|msgdone
condition|)
block|{
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SXFRCTL0
argument_list|,
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SXFRCTL0
argument_list|)
operator|&
operator|~
name|SPIOEN
argument_list|)
expr_stmt|;
name|end_session
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
comment|/* 		 * Present the next byte on the bus. 		 */
ifdef|#
directive|ifdef
name|AHC_DEBUG
if|if
condition|(
operator|(
name|ahc_debug
operator|&
name|AHC_SHOW_MESSAGES
operator|)
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|" byte 0x%x\n"
argument_list|,
name|ahc
operator|->
name|msgout_buf
index|[
name|ahc
operator|->
name|msgout_index
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SXFRCTL0
argument_list|,
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SXFRCTL0
argument_list|)
operator||
name|SPIOEN
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCSIDATL
argument_list|,
name|ahc
operator|->
name|msgout_buf
index|[
name|ahc
operator|->
name|msgout_index
operator|++
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|MSG_TYPE_TARGET_MSGOUT
case|:
block|{
name|int
name|lastbyte
decl_stmt|;
name|int
name|msgdone
decl_stmt|;
ifdef|#
directive|ifdef
name|AHC_DEBUG
if|if
condition|(
operator|(
name|ahc_debug
operator|&
name|AHC_SHOW_MESSAGES
operator|)
operator|!=
literal|0
condition|)
block|{
name|ahc_print_devinfo
argument_list|(
name|ahc
argument_list|,
operator|&
name|devinfo
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"TARGET_MSG_OUT"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* 		 * The initiator signals that this is 		 * the last byte by dropping ATN. 		 */
name|lastbyte
operator|=
operator|(
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCSISIGI
argument_list|)
operator|&
name|ATNI
operator|)
operator|==
literal|0
expr_stmt|;
comment|/* 		 * Read the latched byte, but turn off SPIOEN first 		 * so that we don't inadvertently cause a REQ for the 		 * next byte. 		 */
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SXFRCTL0
argument_list|,
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SXFRCTL0
argument_list|)
operator|&
operator|~
name|SPIOEN
argument_list|)
expr_stmt|;
name|ahc
operator|->
name|msgin_buf
index|[
name|ahc
operator|->
name|msgin_index
index|]
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCSIDATL
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|AHC_DEBUG
if|if
condition|(
operator|(
name|ahc_debug
operator|&
name|AHC_SHOW_MESSAGES
operator|)
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|" byte 0x%x\n"
argument_list|,
name|ahc
operator|->
name|msgin_buf
index|[
name|ahc
operator|->
name|msgin_index
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|msgdone
operator|=
name|ahc_parse_msg
argument_list|(
name|ahc
argument_list|,
operator|&
name|devinfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|msgdone
operator|==
name|MSGLOOP_TERMINATED
condition|)
block|{
comment|/* 			 * The message is *really* done in that it caused 			 * us to go to bus free.  The sequencer has already 			 * been reset at this point, so pull the ejection 			 * handle. 			 */
return|return;
block|}
name|ahc
operator|->
name|msgin_index
operator|++
expr_stmt|;
comment|/* 		 * XXX Read spec about initiator dropping ATN too soon 		 *     and use msgdone to detect it. 		 */
if|if
condition|(
name|msgdone
operator|==
name|MSGLOOP_MSGCOMPLETE
condition|)
block|{
name|ahc
operator|->
name|msgin_index
operator|=
literal|0
expr_stmt|;
comment|/* 			 * If this message illicited a response, transition 			 * to the Message in phase and send it. 			 */
if|if
condition|(
name|ahc
operator|->
name|msgout_len
operator|!=
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|AHC_DEBUG
if|if
condition|(
operator|(
name|ahc_debug
operator|&
name|AHC_SHOW_MESSAGES
operator|)
operator|!=
literal|0
condition|)
block|{
name|ahc_print_devinfo
argument_list|(
name|ahc
argument_list|,
operator|&
name|devinfo
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" preparing response.\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCSISIGO
argument_list|,
name|P_MESGIN
operator||
name|BSYO
argument_list|)
expr_stmt|;
comment|/* 				 * All phase line changes require a bus 				 * settle delay before REQ is asserted. 				 * [SCSI SPI4 10.7.1]  When transitioning 				 * from an OUT to an IN phase, we must 				 * also wait a data release delay to allow 				 * the initiator time to release the data 				 * lines. [SCSI SPI4 10.12] 				 */
name|ahc_flush_device_writes
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
name|aic_delay
argument_list|(
name|AHC_BUSSETTLE_DELAY
operator|+
name|AHC_DATARELEASE_DELAY
argument_list|)
expr_stmt|;
comment|/* 				 * Enable SCSI Programmed I/O.  This will 				 * immediately cause SPIORDY to assert, 				 * and the sequencer will call our message 				 * loop again. 				 */
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SXFRCTL0
argument_list|,
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SXFRCTL0
argument_list|)
operator||
name|SPIOEN
argument_list|)
expr_stmt|;
name|ahc
operator|->
name|msg_type
operator|=
name|MSG_TYPE_TARGET_MSGIN
expr_stmt|;
name|ahc
operator|->
name|msgin_index
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|lastbyte
condition|)
name|end_session
operator|=
name|TRUE
expr_stmt|;
else|else
block|{
comment|/* Ask for the next byte. */
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SXFRCTL0
argument_list|,
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SXFRCTL0
argument_list|)
operator||
name|SPIOEN
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
default|default:
name|panic
argument_list|(
literal|"Unknown REQINIT message type"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|end_session
condition|)
block|{
name|ahc_clear_msg_state
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|RETURN_1
argument_list|,
name|EXIT_MSG_LOOP
argument_list|)
expr_stmt|;
block|}
else|else
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|RETURN_1
argument_list|,
name|CONT_MSG_LOOP
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * See if we sent a particular extended message to the target.  * If "full" is true, return true only if the target saw the full  * message.  If "full" is false, return true if the target saw at  * least the first byte of the message.  */
end_comment

begin_function
specifier|static
name|int
name|ahc_sent_msg
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|ahc_msgtype
name|type
parameter_list|,
name|u_int
name|msgval
parameter_list|,
name|int
name|full
parameter_list|)
block|{
name|int
name|found
decl_stmt|;
name|u_int
name|index
decl_stmt|;
name|found
operator|=
name|FALSE
expr_stmt|;
name|index
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|index
operator|<
name|ahc
operator|->
name|msgout_len
condition|)
block|{
if|if
condition|(
name|ahc
operator|->
name|msgout_buf
index|[
name|index
index|]
operator|==
name|MSG_EXTENDED
condition|)
block|{
name|u_int
name|end_index
decl_stmt|;
name|end_index
operator|=
name|index
operator|+
literal|1
operator|+
name|ahc
operator|->
name|msgout_buf
index|[
name|index
operator|+
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|ahc
operator|->
name|msgout_buf
index|[
name|index
operator|+
literal|2
index|]
operator|==
name|msgval
operator|&&
name|type
operator|==
name|AHCMSG_EXT
condition|)
block|{
if|if
condition|(
name|full
condition|)
block|{
if|if
condition|(
name|ahc
operator|->
name|msgout_index
operator|>
name|end_index
condition|)
name|found
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ahc
operator|->
name|msgout_index
operator|>
name|index
condition|)
name|found
operator|=
name|TRUE
expr_stmt|;
block|}
name|index
operator|=
name|end_index
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ahc
operator|->
name|msgout_buf
index|[
name|index
index|]
operator|>=
name|MSG_SIMPLE_TASK
operator|&&
name|ahc
operator|->
name|msgout_buf
index|[
name|index
index|]
operator|<=
name|MSG_IGN_WIDE_RESIDUE
condition|)
block|{
comment|/* Skip tag type and tag id or residue param*/
name|index
operator|+=
literal|2
expr_stmt|;
block|}
else|else
block|{
comment|/* Single byte message */
if|if
condition|(
name|type
operator|==
name|AHCMSG_1B
operator|&&
name|ahc
operator|->
name|msgout_buf
index|[
name|index
index|]
operator|==
name|msgval
operator|&&
name|ahc
operator|->
name|msgout_index
operator|>
name|index
condition|)
name|found
operator|=
name|TRUE
expr_stmt|;
name|index
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|found
condition|)
break|break;
block|}
return|return
operator|(
name|found
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Wait for a complete incoming message, parse it, and respond accordingly.  */
end_comment

begin_function
specifier|static
name|int
name|ahc_parse_msg
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|struct
name|ahc_devinfo
modifier|*
name|devinfo
parameter_list|)
block|{
name|struct
name|ahc_initiator_tinfo
modifier|*
name|tinfo
decl_stmt|;
name|struct
name|ahc_tmode_tstate
modifier|*
name|tstate
decl_stmt|;
name|int
name|reject
decl_stmt|;
name|int
name|done
decl_stmt|;
name|int
name|response
decl_stmt|;
name|u_int
name|targ_scsirate
decl_stmt|;
name|done
operator|=
name|MSGLOOP_IN_PROG
expr_stmt|;
name|response
operator|=
name|FALSE
expr_stmt|;
name|reject
operator|=
name|FALSE
expr_stmt|;
name|tinfo
operator|=
name|ahc_fetch_transinfo
argument_list|(
name|ahc
argument_list|,
name|devinfo
operator|->
name|channel
argument_list|,
name|devinfo
operator|->
name|our_scsiid
argument_list|,
name|devinfo
operator|->
name|target
argument_list|,
operator|&
name|tstate
argument_list|)
expr_stmt|;
name|targ_scsirate
operator|=
name|tinfo
operator|->
name|scsirate
expr_stmt|;
comment|/* 	 * Parse as much of the message as is available, 	 * rejecting it if we don't support it.  When 	 * the entire message is available and has been 	 * handled, return MSGLOOP_MSGCOMPLETE, indicating 	 * that we have parsed an entire message. 	 * 	 * In the case of extended messages, we accept the length 	 * byte outright and perform more checking once we know the 	 * extended message type. 	 */
switch|switch
condition|(
name|ahc
operator|->
name|msgin_buf
index|[
literal|0
index|]
condition|)
block|{
case|case
name|MSG_DISCONNECT
case|:
case|case
name|MSG_SAVEDATAPOINTER
case|:
case|case
name|MSG_CMDCOMPLETE
case|:
case|case
name|MSG_RESTOREPOINTERS
case|:
case|case
name|MSG_IGN_WIDE_RESIDUE
case|:
comment|/* 		 * End our message loop as these are messages 		 * the sequencer handles on its own. 		 */
name|done
operator|=
name|MSGLOOP_TERMINATED
expr_stmt|;
break|break;
case|case
name|MSG_MESSAGE_REJECT
case|:
name|response
operator|=
name|ahc_handle_msg_reject
argument_list|(
name|ahc
argument_list|,
name|devinfo
argument_list|)
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
name|MSG_NOOP
case|:
name|done
operator|=
name|MSGLOOP_MSGCOMPLETE
expr_stmt|;
break|break;
case|case
name|MSG_EXTENDED
case|:
block|{
comment|/* Wait for enough of the message to begin validation */
if|if
condition|(
name|ahc
operator|->
name|msgin_index
operator|<
literal|2
condition|)
break|break;
switch|switch
condition|(
name|ahc
operator|->
name|msgin_buf
index|[
literal|2
index|]
condition|)
block|{
case|case
name|MSG_EXT_SDTR
case|:
block|{
name|struct
name|ahc_syncrate
modifier|*
name|syncrate
decl_stmt|;
name|u_int
name|period
decl_stmt|;
name|u_int
name|ppr_options
decl_stmt|;
name|u_int
name|offset
decl_stmt|;
name|u_int
name|saved_offset
decl_stmt|;
if|if
condition|(
name|ahc
operator|->
name|msgin_buf
index|[
literal|1
index|]
operator|!=
name|MSG_EXT_SDTR_LEN
condition|)
block|{
name|reject
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
comment|/* 			 * Wait until we have both args before validating 			 * and acting on this message. 			 * 			 * Add one to MSG_EXT_SDTR_LEN to account for 			 * the extended message preamble. 			 */
if|if
condition|(
name|ahc
operator|->
name|msgin_index
operator|<
operator|(
name|MSG_EXT_SDTR_LEN
operator|+
literal|1
operator|)
condition|)
break|break;
name|period
operator|=
name|ahc
operator|->
name|msgin_buf
index|[
literal|3
index|]
expr_stmt|;
name|ppr_options
operator|=
literal|0
expr_stmt|;
name|saved_offset
operator|=
name|offset
operator|=
name|ahc
operator|->
name|msgin_buf
index|[
literal|4
index|]
expr_stmt|;
name|syncrate
operator|=
name|ahc_devlimited_syncrate
argument_list|(
name|ahc
argument_list|,
name|tinfo
argument_list|,
operator|&
name|period
argument_list|,
operator|&
name|ppr_options
argument_list|,
name|devinfo
operator|->
name|role
argument_list|)
expr_stmt|;
name|ahc_validate_offset
argument_list|(
name|ahc
argument_list|,
name|tinfo
argument_list|,
name|syncrate
argument_list|,
operator|&
name|offset
argument_list|,
name|targ_scsirate
operator|&
name|WIDEXFER
argument_list|,
name|devinfo
operator|->
name|role
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
block|{
name|printf
argument_list|(
literal|"(%s:%c:%d:%d): Received "
literal|"SDTR period %x, offset %x\n\t"
literal|"Filtered to period %x, offset %x\n"
argument_list|,
name|ahc_name
argument_list|(
name|ahc
argument_list|)
argument_list|,
name|devinfo
operator|->
name|channel
argument_list|,
name|devinfo
operator|->
name|target
argument_list|,
name|devinfo
operator|->
name|lun
argument_list|,
name|ahc
operator|->
name|msgin_buf
index|[
literal|3
index|]
argument_list|,
name|saved_offset
argument_list|,
name|period
argument_list|,
name|offset
argument_list|)
expr_stmt|;
block|}
name|ahc_set_syncrate
argument_list|(
name|ahc
argument_list|,
name|devinfo
argument_list|,
name|syncrate
argument_list|,
name|period
argument_list|,
name|offset
argument_list|,
name|ppr_options
argument_list|,
name|AHC_TRANS_ACTIVE
operator||
name|AHC_TRANS_GOAL
argument_list|,
comment|/*paused*/
name|TRUE
argument_list|)
expr_stmt|;
comment|/* 			 * See if we initiated Sync Negotiation 			 * and didn't have to fall down to async 			 * transfers. 			 */
if|if
condition|(
name|ahc_sent_msg
argument_list|(
name|ahc
argument_list|,
name|AHCMSG_EXT
argument_list|,
name|MSG_EXT_SDTR
argument_list|,
name|TRUE
argument_list|)
condition|)
block|{
comment|/* We started it */
if|if
condition|(
name|saved_offset
operator|!=
name|offset
condition|)
block|{
comment|/* Went too low - force async */
name|reject
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 				 * Send our own SDTR in reply 				 */
if|if
condition|(
name|bootverbose
operator|&&
name|devinfo
operator|->
name|role
operator|==
name|ROLE_INITIATOR
condition|)
block|{
name|printf
argument_list|(
literal|"(%s:%c:%d:%d): Target "
literal|"Initiated SDTR\n"
argument_list|,
name|ahc_name
argument_list|(
name|ahc
argument_list|)
argument_list|,
name|devinfo
operator|->
name|channel
argument_list|,
name|devinfo
operator|->
name|target
argument_list|,
name|devinfo
operator|->
name|lun
argument_list|)
expr_stmt|;
block|}
name|ahc
operator|->
name|msgout_index
operator|=
literal|0
expr_stmt|;
name|ahc
operator|->
name|msgout_len
operator|=
literal|0
expr_stmt|;
name|ahc_construct_sdtr
argument_list|(
name|ahc
argument_list|,
name|devinfo
argument_list|,
name|period
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|ahc
operator|->
name|msgout_index
operator|=
literal|0
expr_stmt|;
name|response
operator|=
name|TRUE
expr_stmt|;
block|}
name|done
operator|=
name|MSGLOOP_MSGCOMPLETE
expr_stmt|;
break|break;
block|}
case|case
name|MSG_EXT_WDTR
case|:
block|{
name|u_int
name|bus_width
decl_stmt|;
name|u_int
name|saved_width
decl_stmt|;
name|u_int
name|sending_reply
decl_stmt|;
name|sending_reply
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|ahc
operator|->
name|msgin_buf
index|[
literal|1
index|]
operator|!=
name|MSG_EXT_WDTR_LEN
condition|)
block|{
name|reject
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
comment|/* 			 * Wait until we have our arg before validating 			 * and acting on this message. 			 * 			 * Add one to MSG_EXT_WDTR_LEN to account for 			 * the extended message preamble. 			 */
if|if
condition|(
name|ahc
operator|->
name|msgin_index
operator|<
operator|(
name|MSG_EXT_WDTR_LEN
operator|+
literal|1
operator|)
condition|)
break|break;
name|bus_width
operator|=
name|ahc
operator|->
name|msgin_buf
index|[
literal|3
index|]
expr_stmt|;
name|saved_width
operator|=
name|bus_width
expr_stmt|;
name|ahc_validate_width
argument_list|(
name|ahc
argument_list|,
name|tinfo
argument_list|,
operator|&
name|bus_width
argument_list|,
name|devinfo
operator|->
name|role
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
block|{
name|printf
argument_list|(
literal|"(%s:%c:%d:%d): Received WDTR "
literal|"%x filtered to %x\n"
argument_list|,
name|ahc_name
argument_list|(
name|ahc
argument_list|)
argument_list|,
name|devinfo
operator|->
name|channel
argument_list|,
name|devinfo
operator|->
name|target
argument_list|,
name|devinfo
operator|->
name|lun
argument_list|,
name|saved_width
argument_list|,
name|bus_width
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ahc_sent_msg
argument_list|(
name|ahc
argument_list|,
name|AHCMSG_EXT
argument_list|,
name|MSG_EXT_WDTR
argument_list|,
name|TRUE
argument_list|)
condition|)
block|{
comment|/* 				 * Don't send a WDTR back to the 				 * target, since we asked first. 				 * If the width went higher than our 				 * request, reject it. 				 */
if|if
condition|(
name|saved_width
operator|>
name|bus_width
condition|)
block|{
name|reject
operator|=
name|TRUE
expr_stmt|;
name|printf
argument_list|(
literal|"(%s:%c:%d:%d): requested %dBit "
literal|"transfers.  Rejecting...\n"
argument_list|,
name|ahc_name
argument_list|(
name|ahc
argument_list|)
argument_list|,
name|devinfo
operator|->
name|channel
argument_list|,
name|devinfo
operator|->
name|target
argument_list|,
name|devinfo
operator|->
name|lun
argument_list|,
literal|8
operator|*
operator|(
literal|0x01
operator|<<
name|bus_width
operator|)
argument_list|)
expr_stmt|;
name|bus_width
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 				 * Send our own WDTR in reply 				 */
if|if
condition|(
name|bootverbose
operator|&&
name|devinfo
operator|->
name|role
operator|==
name|ROLE_INITIATOR
condition|)
block|{
name|printf
argument_list|(
literal|"(%s:%c:%d:%d): Target "
literal|"Initiated WDTR\n"
argument_list|,
name|ahc_name
argument_list|(
name|ahc
argument_list|)
argument_list|,
name|devinfo
operator|->
name|channel
argument_list|,
name|devinfo
operator|->
name|target
argument_list|,
name|devinfo
operator|->
name|lun
argument_list|)
expr_stmt|;
block|}
name|ahc
operator|->
name|msgout_index
operator|=
literal|0
expr_stmt|;
name|ahc
operator|->
name|msgout_len
operator|=
literal|0
expr_stmt|;
name|ahc_construct_wdtr
argument_list|(
name|ahc
argument_list|,
name|devinfo
argument_list|,
name|bus_width
argument_list|)
expr_stmt|;
name|ahc
operator|->
name|msgout_index
operator|=
literal|0
expr_stmt|;
name|response
operator|=
name|TRUE
expr_stmt|;
name|sending_reply
operator|=
name|TRUE
expr_stmt|;
block|}
comment|/* 			 * After a wide message, we are async, but 			 * some devices don't seem to honor this portion 			 * of the spec.  Force a renegotiation of the 			 * sync component of our transfer agreement even 			 * if our goal is async.  By updating our width 			 * after forcing the negotiation, we avoid 			 * renegotiating for width. 			 */
name|ahc_update_neg_request
argument_list|(
name|ahc
argument_list|,
name|devinfo
argument_list|,
name|tstate
argument_list|,
name|tinfo
argument_list|,
name|AHC_NEG_ALWAYS
argument_list|)
expr_stmt|;
name|ahc_set_width
argument_list|(
name|ahc
argument_list|,
name|devinfo
argument_list|,
name|bus_width
argument_list|,
name|AHC_TRANS_ACTIVE
operator||
name|AHC_TRANS_GOAL
argument_list|,
comment|/*paused*/
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sending_reply
operator|==
name|FALSE
operator|&&
name|reject
operator|==
name|FALSE
condition|)
block|{
comment|/* 				 * We will always have an SDTR to send. 				 */
name|ahc
operator|->
name|msgout_index
operator|=
literal|0
expr_stmt|;
name|ahc
operator|->
name|msgout_len
operator|=
literal|0
expr_stmt|;
name|ahc_build_transfer_msg
argument_list|(
name|ahc
argument_list|,
name|devinfo
argument_list|)
expr_stmt|;
name|ahc
operator|->
name|msgout_index
operator|=
literal|0
expr_stmt|;
name|response
operator|=
name|TRUE
expr_stmt|;
block|}
name|done
operator|=
name|MSGLOOP_MSGCOMPLETE
expr_stmt|;
break|break;
block|}
case|case
name|MSG_EXT_PPR
case|:
block|{
name|struct
name|ahc_syncrate
modifier|*
name|syncrate
decl_stmt|;
name|u_int
name|period
decl_stmt|;
name|u_int
name|offset
decl_stmt|;
name|u_int
name|bus_width
decl_stmt|;
name|u_int
name|ppr_options
decl_stmt|;
name|u_int
name|saved_width
decl_stmt|;
name|u_int
name|saved_offset
decl_stmt|;
name|u_int
name|saved_ppr_options
decl_stmt|;
if|if
condition|(
name|ahc
operator|->
name|msgin_buf
index|[
literal|1
index|]
operator|!=
name|MSG_EXT_PPR_LEN
condition|)
block|{
name|reject
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
comment|/* 			 * Wait until we have all args before validating 			 * and acting on this message. 			 * 			 * Add one to MSG_EXT_PPR_LEN to account for 			 * the extended message preamble. 			 */
if|if
condition|(
name|ahc
operator|->
name|msgin_index
operator|<
operator|(
name|MSG_EXT_PPR_LEN
operator|+
literal|1
operator|)
condition|)
break|break;
name|period
operator|=
name|ahc
operator|->
name|msgin_buf
index|[
literal|3
index|]
expr_stmt|;
name|offset
operator|=
name|ahc
operator|->
name|msgin_buf
index|[
literal|5
index|]
expr_stmt|;
name|bus_width
operator|=
name|ahc
operator|->
name|msgin_buf
index|[
literal|6
index|]
expr_stmt|;
name|saved_width
operator|=
name|bus_width
expr_stmt|;
name|ppr_options
operator|=
name|ahc
operator|->
name|msgin_buf
index|[
literal|7
index|]
expr_stmt|;
comment|/* 			 * According to the spec, a DT only 			 * period factor with no DT option 			 * set implies async. 			 */
if|if
condition|(
operator|(
name|ppr_options
operator|&
name|MSG_EXT_PPR_DT_REQ
operator|)
operator|==
literal|0
operator|&&
name|period
operator|==
literal|9
condition|)
name|offset
operator|=
literal|0
expr_stmt|;
name|saved_ppr_options
operator|=
name|ppr_options
expr_stmt|;
name|saved_offset
operator|=
name|offset
expr_stmt|;
comment|/* 			 * Mask out any options we don't support 			 * on any controller.  Transfer options are 			 * only available if we are negotiating wide. 			 */
name|ppr_options
operator|&=
name|MSG_EXT_PPR_DT_REQ
expr_stmt|;
if|if
condition|(
name|bus_width
operator|==
literal|0
condition|)
name|ppr_options
operator|=
literal|0
expr_stmt|;
name|ahc_validate_width
argument_list|(
name|ahc
argument_list|,
name|tinfo
argument_list|,
operator|&
name|bus_width
argument_list|,
name|devinfo
operator|->
name|role
argument_list|)
expr_stmt|;
name|syncrate
operator|=
name|ahc_devlimited_syncrate
argument_list|(
name|ahc
argument_list|,
name|tinfo
argument_list|,
operator|&
name|period
argument_list|,
operator|&
name|ppr_options
argument_list|,
name|devinfo
operator|->
name|role
argument_list|)
expr_stmt|;
name|ahc_validate_offset
argument_list|(
name|ahc
argument_list|,
name|tinfo
argument_list|,
name|syncrate
argument_list|,
operator|&
name|offset
argument_list|,
name|bus_width
argument_list|,
name|devinfo
operator|->
name|role
argument_list|)
expr_stmt|;
if|if
condition|(
name|ahc_sent_msg
argument_list|(
name|ahc
argument_list|,
name|AHCMSG_EXT
argument_list|,
name|MSG_EXT_PPR
argument_list|,
name|TRUE
argument_list|)
condition|)
block|{
comment|/* 				 * If we are unable to do any of the 				 * requested options (we went too low), 				 * then we'll have to reject the message. 				 */
if|if
condition|(
name|saved_width
operator|>
name|bus_width
operator|||
name|saved_offset
operator|!=
name|offset
operator|||
name|saved_ppr_options
operator|!=
name|ppr_options
condition|)
block|{
name|reject
operator|=
name|TRUE
expr_stmt|;
name|period
operator|=
literal|0
expr_stmt|;
name|offset
operator|=
literal|0
expr_stmt|;
name|bus_width
operator|=
literal|0
expr_stmt|;
name|ppr_options
operator|=
literal|0
expr_stmt|;
name|syncrate
operator|=
name|NULL
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|devinfo
operator|->
name|role
operator|!=
name|ROLE_TARGET
condition|)
name|printf
argument_list|(
literal|"(%s:%c:%d:%d): Target "
literal|"Initiated PPR\n"
argument_list|,
name|ahc_name
argument_list|(
name|ahc
argument_list|)
argument_list|,
name|devinfo
operator|->
name|channel
argument_list|,
name|devinfo
operator|->
name|target
argument_list|,
name|devinfo
operator|->
name|lun
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"(%s:%c:%d:%d): Initiator "
literal|"Initiated PPR\n"
argument_list|,
name|ahc_name
argument_list|(
name|ahc
argument_list|)
argument_list|,
name|devinfo
operator|->
name|channel
argument_list|,
name|devinfo
operator|->
name|target
argument_list|,
name|devinfo
operator|->
name|lun
argument_list|)
expr_stmt|;
name|ahc
operator|->
name|msgout_index
operator|=
literal|0
expr_stmt|;
name|ahc
operator|->
name|msgout_len
operator|=
literal|0
expr_stmt|;
name|ahc_construct_ppr
argument_list|(
name|ahc
argument_list|,
name|devinfo
argument_list|,
name|period
argument_list|,
name|offset
argument_list|,
name|bus_width
argument_list|,
name|ppr_options
argument_list|)
expr_stmt|;
name|ahc
operator|->
name|msgout_index
operator|=
literal|0
expr_stmt|;
name|response
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
name|bootverbose
condition|)
block|{
name|printf
argument_list|(
literal|"(%s:%c:%d:%d): Received PPR width %x, "
literal|"period %x, offset %x,options %x\n"
literal|"\tFiltered to width %x, period %x, "
literal|"offset %x, options %x\n"
argument_list|,
name|ahc_name
argument_list|(
name|ahc
argument_list|)
argument_list|,
name|devinfo
operator|->
name|channel
argument_list|,
name|devinfo
operator|->
name|target
argument_list|,
name|devinfo
operator|->
name|lun
argument_list|,
name|saved_width
argument_list|,
name|ahc
operator|->
name|msgin_buf
index|[
literal|3
index|]
argument_list|,
name|saved_offset
argument_list|,
name|saved_ppr_options
argument_list|,
name|bus_width
argument_list|,
name|period
argument_list|,
name|offset
argument_list|,
name|ppr_options
argument_list|)
expr_stmt|;
block|}
name|ahc_set_width
argument_list|(
name|ahc
argument_list|,
name|devinfo
argument_list|,
name|bus_width
argument_list|,
name|AHC_TRANS_ACTIVE
operator||
name|AHC_TRANS_GOAL
argument_list|,
comment|/*paused*/
name|TRUE
argument_list|)
expr_stmt|;
name|ahc_set_syncrate
argument_list|(
name|ahc
argument_list|,
name|devinfo
argument_list|,
name|syncrate
argument_list|,
name|period
argument_list|,
name|offset
argument_list|,
name|ppr_options
argument_list|,
name|AHC_TRANS_ACTIVE
operator||
name|AHC_TRANS_GOAL
argument_list|,
comment|/*paused*/
name|TRUE
argument_list|)
expr_stmt|;
name|done
operator|=
name|MSGLOOP_MSGCOMPLETE
expr_stmt|;
break|break;
block|}
default|default:
comment|/* Unknown extended message.  Reject it. */
name|reject
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
break|break;
block|}
ifdef|#
directive|ifdef
name|AHC_TARGET_MODE
case|case
name|MSG_BUS_DEV_RESET
case|:
name|ahc_handle_devreset
argument_list|(
name|ahc
argument_list|,
name|devinfo
argument_list|,
name|CAM_BDR_SENT
argument_list|,
literal|"Bus Device Reset Received"
argument_list|,
comment|/*verbose_level*/
literal|0
argument_list|)
expr_stmt|;
name|ahc_restart
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
name|done
operator|=
name|MSGLOOP_TERMINATED
expr_stmt|;
break|break;
case|case
name|MSG_ABORT_TAG
case|:
case|case
name|MSG_ABORT
case|:
case|case
name|MSG_CLEAR_QUEUE
case|:
block|{
name|int
name|tag
decl_stmt|;
comment|/* Target mode messages */
if|if
condition|(
name|devinfo
operator|->
name|role
operator|!=
name|ROLE_TARGET
condition|)
block|{
name|reject
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
name|tag
operator|=
name|SCB_LIST_NULL
expr_stmt|;
if|if
condition|(
name|ahc
operator|->
name|msgin_buf
index|[
literal|0
index|]
operator|==
name|MSG_ABORT_TAG
condition|)
name|tag
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|INITIATOR_TAG
argument_list|)
expr_stmt|;
name|ahc_abort_scbs
argument_list|(
name|ahc
argument_list|,
name|devinfo
operator|->
name|target
argument_list|,
name|devinfo
operator|->
name|channel
argument_list|,
name|devinfo
operator|->
name|lun
argument_list|,
name|tag
argument_list|,
name|ROLE_TARGET
argument_list|,
name|CAM_REQ_ABORTED
argument_list|)
expr_stmt|;
name|tstate
operator|=
name|ahc
operator|->
name|enabled_targets
index|[
name|devinfo
operator|->
name|our_scsiid
index|]
expr_stmt|;
if|if
condition|(
name|tstate
operator|!=
name|NULL
condition|)
block|{
name|struct
name|ahc_tmode_lstate
modifier|*
name|lstate
decl_stmt|;
name|lstate
operator|=
name|tstate
operator|->
name|enabled_luns
index|[
name|devinfo
operator|->
name|lun
index|]
expr_stmt|;
if|if
condition|(
name|lstate
operator|!=
name|NULL
condition|)
block|{
name|ahc_queue_lstate_event
argument_list|(
name|ahc
argument_list|,
name|lstate
argument_list|,
name|devinfo
operator|->
name|our_scsiid
argument_list|,
name|ahc
operator|->
name|msgin_buf
index|[
literal|0
index|]
argument_list|,
comment|/*arg*/
name|tag
argument_list|)
expr_stmt|;
name|ahc_send_lstate_events
argument_list|(
name|ahc
argument_list|,
name|lstate
argument_list|)
expr_stmt|;
block|}
block|}
name|ahc_restart
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
name|done
operator|=
name|MSGLOOP_TERMINATED
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
case|case
name|MSG_TERM_IO_PROC
case|:
default|default:
name|reject
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|reject
condition|)
block|{
comment|/* 		 * Setup to reject the message. 		 */
name|ahc
operator|->
name|msgout_index
operator|=
literal|0
expr_stmt|;
name|ahc
operator|->
name|msgout_len
operator|=
literal|1
expr_stmt|;
name|ahc
operator|->
name|msgout_buf
index|[
literal|0
index|]
operator|=
name|MSG_MESSAGE_REJECT
expr_stmt|;
name|done
operator|=
name|MSGLOOP_MSGCOMPLETE
expr_stmt|;
name|response
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
name|done
operator|!=
name|MSGLOOP_IN_PROG
operator|&&
operator|!
name|response
condition|)
comment|/* Clear the outgoing message buffer */
name|ahc
operator|->
name|msgout_len
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|done
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Process a message reject message.  */
end_comment

begin_function
specifier|static
name|int
name|ahc_handle_msg_reject
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|struct
name|ahc_devinfo
modifier|*
name|devinfo
parameter_list|)
block|{
comment|/* 	 * What we care about here is if we had an 	 * outstanding SDTR or WDTR message for this 	 * target.  If we did, this is a signal that 	 * the target is refusing negotiation. 	 */
name|struct
name|scb
modifier|*
name|scb
decl_stmt|;
name|struct
name|ahc_initiator_tinfo
modifier|*
name|tinfo
decl_stmt|;
name|struct
name|ahc_tmode_tstate
modifier|*
name|tstate
decl_stmt|;
name|u_int
name|scb_index
decl_stmt|;
name|u_int
name|last_msg
decl_stmt|;
name|int
name|response
init|=
literal|0
decl_stmt|;
name|scb_index
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCB_TAG
argument_list|)
expr_stmt|;
name|scb
operator|=
name|ahc_lookup_scb
argument_list|(
name|ahc
argument_list|,
name|scb_index
argument_list|)
expr_stmt|;
name|tinfo
operator|=
name|ahc_fetch_transinfo
argument_list|(
name|ahc
argument_list|,
name|devinfo
operator|->
name|channel
argument_list|,
name|devinfo
operator|->
name|our_scsiid
argument_list|,
name|devinfo
operator|->
name|target
argument_list|,
operator|&
name|tstate
argument_list|)
expr_stmt|;
comment|/* Might be necessary */
name|last_msg
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|LAST_MSG
argument_list|)
expr_stmt|;
if|if
condition|(
name|ahc_sent_msg
argument_list|(
name|ahc
argument_list|,
name|AHCMSG_EXT
argument_list|,
name|MSG_EXT_PPR
argument_list|,
comment|/*full*/
name|FALSE
argument_list|)
condition|)
block|{
comment|/* 		 * Target does not support the PPR message. 		 * Attempt to negotiate SPI-2 style. 		 */
if|if
condition|(
name|bootverbose
condition|)
block|{
name|printf
argument_list|(
literal|"(%s:%c:%d:%d): PPR Rejected. "
literal|"Trying WDTR/SDTR\n"
argument_list|,
name|ahc_name
argument_list|(
name|ahc
argument_list|)
argument_list|,
name|devinfo
operator|->
name|channel
argument_list|,
name|devinfo
operator|->
name|target
argument_list|,
name|devinfo
operator|->
name|lun
argument_list|)
expr_stmt|;
block|}
name|tinfo
operator|->
name|goal
operator|.
name|ppr_options
operator|=
literal|0
expr_stmt|;
name|tinfo
operator|->
name|curr
operator|.
name|transport_version
operator|=
literal|2
expr_stmt|;
name|tinfo
operator|->
name|goal
operator|.
name|transport_version
operator|=
literal|2
expr_stmt|;
name|ahc
operator|->
name|msgout_index
operator|=
literal|0
expr_stmt|;
name|ahc
operator|->
name|msgout_len
operator|=
literal|0
expr_stmt|;
name|ahc_build_transfer_msg
argument_list|(
name|ahc
argument_list|,
name|devinfo
argument_list|)
expr_stmt|;
name|ahc
operator|->
name|msgout_index
operator|=
literal|0
expr_stmt|;
name|response
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ahc_sent_msg
argument_list|(
name|ahc
argument_list|,
name|AHCMSG_EXT
argument_list|,
name|MSG_EXT_WDTR
argument_list|,
comment|/*full*/
name|FALSE
argument_list|)
condition|)
block|{
comment|/* note 8bit xfers */
name|printf
argument_list|(
literal|"(%s:%c:%d:%d): refuses WIDE negotiation.  Using "
literal|"8bit transfers\n"
argument_list|,
name|ahc_name
argument_list|(
name|ahc
argument_list|)
argument_list|,
name|devinfo
operator|->
name|channel
argument_list|,
name|devinfo
operator|->
name|target
argument_list|,
name|devinfo
operator|->
name|lun
argument_list|)
expr_stmt|;
name|ahc_set_width
argument_list|(
name|ahc
argument_list|,
name|devinfo
argument_list|,
name|MSG_EXT_WDTR_BUS_8_BIT
argument_list|,
name|AHC_TRANS_ACTIVE
operator||
name|AHC_TRANS_GOAL
argument_list|,
comment|/*paused*/
name|TRUE
argument_list|)
expr_stmt|;
comment|/* 		 * No need to clear the sync rate.  If the target 		 * did not accept the command, our syncrate is 		 * unaffected.  If the target started the negotiation, 		 * but rejected our response, we already cleared the 		 * sync rate before sending our WDTR. 		 */
if|if
condition|(
name|tinfo
operator|->
name|goal
operator|.
name|offset
operator|!=
name|tinfo
operator|->
name|curr
operator|.
name|offset
condition|)
block|{
comment|/* Start the sync negotiation */
name|ahc
operator|->
name|msgout_index
operator|=
literal|0
expr_stmt|;
name|ahc
operator|->
name|msgout_len
operator|=
literal|0
expr_stmt|;
name|ahc_build_transfer_msg
argument_list|(
name|ahc
argument_list|,
name|devinfo
argument_list|)
expr_stmt|;
name|ahc
operator|->
name|msgout_index
operator|=
literal|0
expr_stmt|;
name|response
operator|=
literal|1
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|ahc_sent_msg
argument_list|(
name|ahc
argument_list|,
name|AHCMSG_EXT
argument_list|,
name|MSG_EXT_SDTR
argument_list|,
comment|/*full*/
name|FALSE
argument_list|)
condition|)
block|{
comment|/* note asynch xfers and clear flag */
name|ahc_set_syncrate
argument_list|(
name|ahc
argument_list|,
name|devinfo
argument_list|,
comment|/*syncrate*/
name|NULL
argument_list|,
comment|/*period*/
literal|0
argument_list|,
comment|/*offset*/
literal|0
argument_list|,
comment|/*ppr_options*/
literal|0
argument_list|,
name|AHC_TRANS_ACTIVE
operator||
name|AHC_TRANS_GOAL
argument_list|,
comment|/*paused*/
name|TRUE
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"(%s:%c:%d:%d): refuses synchronous negotiation. "
literal|"Using asynchronous transfers\n"
argument_list|,
name|ahc_name
argument_list|(
name|ahc
argument_list|)
argument_list|,
name|devinfo
operator|->
name|channel
argument_list|,
name|devinfo
operator|->
name|target
argument_list|,
name|devinfo
operator|->
name|lun
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|scb
operator|->
name|hscb
operator|->
name|control
operator|&
name|MSG_SIMPLE_TASK
operator|)
operator|!=
literal|0
condition|)
block|{
name|int
name|tag_type
decl_stmt|;
name|int
name|mask
decl_stmt|;
name|tag_type
operator|=
operator|(
name|scb
operator|->
name|hscb
operator|->
name|control
operator|&
name|MSG_SIMPLE_TASK
operator|)
expr_stmt|;
if|if
condition|(
name|tag_type
operator|==
name|MSG_SIMPLE_TASK
condition|)
block|{
name|printf
argument_list|(
literal|"(%s:%c:%d:%d): refuses tagged commands.  "
literal|"Performing non-tagged I/O\n"
argument_list|,
name|ahc_name
argument_list|(
name|ahc
argument_list|)
argument_list|,
name|devinfo
operator|->
name|channel
argument_list|,
name|devinfo
operator|->
name|target
argument_list|,
name|devinfo
operator|->
name|lun
argument_list|)
expr_stmt|;
name|ahc_set_tags
argument_list|(
name|ahc
argument_list|,
name|devinfo
argument_list|,
name|AHC_QUEUE_NONE
argument_list|)
expr_stmt|;
name|mask
operator|=
operator|~
literal|0x23
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"(%s:%c:%d:%d): refuses %s tagged commands.  "
literal|"Performing simple queue tagged I/O only\n"
argument_list|,
name|ahc_name
argument_list|(
name|ahc
argument_list|)
argument_list|,
name|devinfo
operator|->
name|channel
argument_list|,
name|devinfo
operator|->
name|target
argument_list|,
name|devinfo
operator|->
name|lun
argument_list|,
name|tag_type
operator|==
name|MSG_ORDERED_TASK
condition|?
literal|"ordered"
else|:
literal|"head of queue"
argument_list|)
expr_stmt|;
name|ahc_set_tags
argument_list|(
name|ahc
argument_list|,
name|devinfo
argument_list|,
name|AHC_QUEUE_BASIC
argument_list|)
expr_stmt|;
name|mask
operator|=
operator|~
literal|0x03
expr_stmt|;
block|}
comment|/* 		 * Resend the identify for this CCB as the target 		 * may believe that the selection is invalid otherwise. 		 */
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCB_CONTROL
argument_list|,
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCB_CONTROL
argument_list|)
operator|&
name|mask
argument_list|)
expr_stmt|;
name|scb
operator|->
name|hscb
operator|->
name|control
operator|&=
name|mask
expr_stmt|;
name|aic_set_transaction_tag
argument_list|(
name|scb
argument_list|,
comment|/*enabled*/
name|FALSE
argument_list|,
comment|/*type*/
name|MSG_SIMPLE_TASK
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|MSG_OUT
argument_list|,
name|MSG_IDENTIFYFLAG
argument_list|)
expr_stmt|;
name|ahc_assert_atn
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
comment|/* 		 * This transaction is now at the head of 		 * the untagged queue for this target. 		 */
if|if
condition|(
operator|(
name|ahc
operator|->
name|flags
operator|&
name|AHC_SCB_BTT
operator|)
operator|==
literal|0
condition|)
block|{
name|struct
name|scb_tailq
modifier|*
name|untagged_q
decl_stmt|;
name|untagged_q
operator|=
operator|&
operator|(
name|ahc
operator|->
name|untagged_queues
index|[
name|devinfo
operator|->
name|target_offset
index|]
operator|)
expr_stmt|;
name|TAILQ_INSERT_HEAD
argument_list|(
name|untagged_q
argument_list|,
name|scb
argument_list|,
name|links
operator|.
name|tqe
argument_list|)
expr_stmt|;
name|scb
operator|->
name|flags
operator||=
name|SCB_UNTAGGEDQ
expr_stmt|;
block|}
name|ahc_busy_tcl
argument_list|(
name|ahc
argument_list|,
name|BUILD_TCL
argument_list|(
name|scb
operator|->
name|hscb
operator|->
name|scsiid
argument_list|,
name|devinfo
operator|->
name|lun
argument_list|)
argument_list|,
name|scb
operator|->
name|hscb
operator|->
name|tag
argument_list|)
expr_stmt|;
comment|/* 		 * Requeue all tagged commands for this target 		 * currently in our posession so they can be 		 * converted to untagged commands. 		 */
name|ahc_search_qinfifo
argument_list|(
name|ahc
argument_list|,
name|SCB_GET_TARGET
argument_list|(
name|ahc
argument_list|,
name|scb
argument_list|)
argument_list|,
name|SCB_GET_CHANNEL
argument_list|(
name|ahc
argument_list|,
name|scb
argument_list|)
argument_list|,
name|SCB_GET_LUN
argument_list|(
name|scb
argument_list|)
argument_list|,
comment|/*tag*/
name|SCB_LIST_NULL
argument_list|,
name|ROLE_INITIATOR
argument_list|,
name|CAM_REQUEUE_REQ
argument_list|,
name|SEARCH_COMPLETE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Otherwise, we ignore it. 		 */
name|printf
argument_list|(
literal|"%s:%c:%d: Message reject for %x -- ignored\n"
argument_list|,
name|ahc_name
argument_list|(
name|ahc
argument_list|)
argument_list|,
name|devinfo
operator|->
name|channel
argument_list|,
name|devinfo
operator|->
name|target
argument_list|,
name|last_msg
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|response
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Process an ingnore wide residue message.  */
end_comment

begin_function
specifier|static
name|void
name|ahc_handle_ign_wide_residue
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|struct
name|ahc_devinfo
modifier|*
name|devinfo
parameter_list|)
block|{
name|u_int
name|scb_index
decl_stmt|;
name|struct
name|scb
modifier|*
name|scb
decl_stmt|;
name|scb_index
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCB_TAG
argument_list|)
expr_stmt|;
name|scb
operator|=
name|ahc_lookup_scb
argument_list|(
name|ahc
argument_list|,
name|scb_index
argument_list|)
expr_stmt|;
comment|/* 	 * XXX Actually check data direction in the sequencer? 	 * Perhaps add datadir to some spare bits in the hscb? 	 */
if|if
condition|(
operator|(
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SEQ_FLAGS
argument_list|)
operator|&
name|DPHASE
operator|)
operator|==
literal|0
operator|||
name|aic_get_transfer_dir
argument_list|(
name|scb
argument_list|)
operator|!=
name|CAM_DIR_IN
condition|)
block|{
comment|/* 		 * Ignore the message if we haven't 		 * seen an appropriate data phase yet. 		 */
block|}
else|else
block|{
comment|/* 		 * If the residual occurred on the last 		 * transfer and the transfer request was 		 * expected to end on an odd count, do 		 * nothing.  Otherwise, subtract a byte 		 * and update the residual count accordingly. 		 */
name|uint32_t
name|sgptr
decl_stmt|;
name|sgptr
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCB_RESIDUAL_SGPTR
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sgptr
operator|&
name|SG_LIST_NULL
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCB_LUN
argument_list|)
operator|&
name|SCB_XFERLEN_ODD
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* 			 * If the residual occurred on the last 			 * transfer and the transfer request was 			 * expected to end on an odd count, do 			 * nothing. 			 */
block|}
else|else
block|{
name|struct
name|ahc_dma_seg
modifier|*
name|sg
decl_stmt|;
name|uint32_t
name|data_cnt
decl_stmt|;
name|uint32_t
name|data_addr
decl_stmt|;
name|uint32_t
name|sglen
decl_stmt|;
comment|/* Pull in all of the sgptr */
name|sgptr
operator|=
name|ahc_inl
argument_list|(
name|ahc
argument_list|,
name|SCB_RESIDUAL_SGPTR
argument_list|)
expr_stmt|;
name|data_cnt
operator|=
name|ahc_inl
argument_list|(
name|ahc
argument_list|,
name|SCB_RESIDUAL_DATACNT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sgptr
operator|&
name|SG_LIST_NULL
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* 				 * The residual data count is not updated 				 * for the command run to completion case. 				 * Explicitly zero the count. 				 */
name|data_cnt
operator|&=
operator|~
name|AHC_SG_LEN_MASK
expr_stmt|;
block|}
name|data_addr
operator|=
name|ahc_inl
argument_list|(
name|ahc
argument_list|,
name|SHADDR
argument_list|)
expr_stmt|;
name|data_cnt
operator|+=
literal|1
expr_stmt|;
name|data_addr
operator|-=
literal|1
expr_stmt|;
name|sgptr
operator|&=
name|SG_PTR_MASK
expr_stmt|;
name|sg
operator|=
name|ahc_sg_bus_to_virt
argument_list|(
name|scb
argument_list|,
name|sgptr
argument_list|)
expr_stmt|;
comment|/* 			 * The residual sg ptr points to the next S/G 			 * to load so we must go back one. 			 */
name|sg
operator|--
expr_stmt|;
name|sglen
operator|=
name|aic_le32toh
argument_list|(
name|sg
operator|->
name|len
argument_list|)
operator|&
name|AHC_SG_LEN_MASK
expr_stmt|;
if|if
condition|(
name|sg
operator|!=
name|scb
operator|->
name|sg_list
operator|&&
name|sglen
operator|<
operator|(
name|data_cnt
operator|&
name|AHC_SG_LEN_MASK
operator|)
condition|)
block|{
name|sg
operator|--
expr_stmt|;
name|sglen
operator|=
name|aic_le32toh
argument_list|(
name|sg
operator|->
name|len
argument_list|)
expr_stmt|;
comment|/* 				 * Preserve High Address and SG_LIST bits 				 * while setting the count to 1. 				 */
name|data_cnt
operator|=
literal|1
operator||
operator|(
name|sglen
operator|&
operator|(
operator|~
name|AHC_SG_LEN_MASK
operator|)
operator|)
expr_stmt|;
name|data_addr
operator|=
name|aic_le32toh
argument_list|(
name|sg
operator|->
name|addr
argument_list|)
operator|+
operator|(
name|sglen
operator|&
name|AHC_SG_LEN_MASK
operator|)
operator|-
literal|1
expr_stmt|;
comment|/* 				 * Increment sg so it points to the 				 * "next" sg. 				 */
name|sg
operator|++
expr_stmt|;
name|sgptr
operator|=
name|ahc_sg_virt_to_bus
argument_list|(
name|scb
argument_list|,
name|sg
argument_list|)
expr_stmt|;
block|}
name|ahc_outl
argument_list|(
name|ahc
argument_list|,
name|SCB_RESIDUAL_SGPTR
argument_list|,
name|sgptr
argument_list|)
expr_stmt|;
name|ahc_outl
argument_list|(
name|ahc
argument_list|,
name|SCB_RESIDUAL_DATACNT
argument_list|,
name|data_cnt
argument_list|)
expr_stmt|;
comment|/* 			 * Toggle the "oddness" of the transfer length 			 * to handle this mid-transfer ignore wide 			 * residue.  This ensures that the oddness is 			 * correct for subsequent data transfers. 			 */
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCB_LUN
argument_list|,
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCB_LUN
argument_list|)
operator|^
name|SCB_XFERLEN_ODD
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Reinitialize the data pointers for the active transfer  * based on its current residual.  */
end_comment

begin_function
specifier|static
name|void
name|ahc_reinitialize_dataptrs
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|)
block|{
name|struct
name|scb
modifier|*
name|scb
decl_stmt|;
name|struct
name|ahc_dma_seg
modifier|*
name|sg
decl_stmt|;
name|u_int
name|scb_index
decl_stmt|;
name|uint32_t
name|sgptr
decl_stmt|;
name|uint32_t
name|resid
decl_stmt|;
name|uint32_t
name|dataptr
decl_stmt|;
name|scb_index
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCB_TAG
argument_list|)
expr_stmt|;
name|scb
operator|=
name|ahc_lookup_scb
argument_list|(
name|ahc
argument_list|,
name|scb_index
argument_list|)
expr_stmt|;
name|sgptr
operator|=
operator|(
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCB_RESIDUAL_SGPTR
operator|+
literal|3
argument_list|)
operator|<<
literal|24
operator|)
operator||
operator|(
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCB_RESIDUAL_SGPTR
operator|+
literal|2
argument_list|)
operator|<<
literal|16
operator|)
operator||
operator|(
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCB_RESIDUAL_SGPTR
operator|+
literal|1
argument_list|)
operator|<<
literal|8
operator|)
operator||
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCB_RESIDUAL_SGPTR
argument_list|)
expr_stmt|;
name|sgptr
operator|&=
name|SG_PTR_MASK
expr_stmt|;
name|sg
operator|=
name|ahc_sg_bus_to_virt
argument_list|(
name|scb
argument_list|,
name|sgptr
argument_list|)
expr_stmt|;
comment|/* The residual sg_ptr always points to the next sg */
name|sg
operator|--
expr_stmt|;
name|resid
operator|=
operator|(
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCB_RESIDUAL_DATACNT
operator|+
literal|2
argument_list|)
operator|<<
literal|16
operator|)
operator||
operator|(
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCB_RESIDUAL_DATACNT
operator|+
literal|1
argument_list|)
operator|<<
literal|8
operator|)
operator||
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCB_RESIDUAL_DATACNT
argument_list|)
expr_stmt|;
name|dataptr
operator|=
name|aic_le32toh
argument_list|(
name|sg
operator|->
name|addr
argument_list|)
operator|+
operator|(
name|aic_le32toh
argument_list|(
name|sg
operator|->
name|len
argument_list|)
operator|&
name|AHC_SG_LEN_MASK
operator|)
operator|-
name|resid
expr_stmt|;
if|if
condition|(
operator|(
name|ahc
operator|->
name|flags
operator|&
name|AHC_39BIT_ADDRESSING
operator|)
operator|!=
literal|0
condition|)
block|{
name|u_int
name|dscommand1
decl_stmt|;
name|dscommand1
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|DSCOMMAND1
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|DSCOMMAND1
argument_list|,
name|dscommand1
operator||
name|HADDLDSEL0
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|HADDR
argument_list|,
operator|(
name|aic_le32toh
argument_list|(
name|sg
operator|->
name|len
argument_list|)
operator|>>
literal|24
operator|)
operator|&
name|SG_HIGH_ADDR_BITS
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|DSCOMMAND1
argument_list|,
name|dscommand1
argument_list|)
expr_stmt|;
block|}
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|HADDR
operator|+
literal|3
argument_list|,
name|dataptr
operator|>>
literal|24
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|HADDR
operator|+
literal|2
argument_list|,
name|dataptr
operator|>>
literal|16
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|HADDR
operator|+
literal|1
argument_list|,
name|dataptr
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|HADDR
argument_list|,
name|dataptr
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|HCNT
operator|+
literal|2
argument_list|,
name|resid
operator|>>
literal|16
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|HCNT
operator|+
literal|1
argument_list|,
name|resid
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|HCNT
argument_list|,
name|resid
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ahc
operator|->
name|features
operator|&
name|AHC_ULTRA2
operator|)
operator|==
literal|0
condition|)
block|{
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|STCNT
operator|+
literal|2
argument_list|,
name|resid
operator|>>
literal|16
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|STCNT
operator|+
literal|1
argument_list|,
name|resid
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|STCNT
argument_list|,
name|resid
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Handle the effects of issuing a bus device reset message.  */
end_comment

begin_function
specifier|static
name|void
name|ahc_handle_devreset
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|struct
name|ahc_devinfo
modifier|*
name|devinfo
parameter_list|,
name|cam_status
name|status
parameter_list|,
name|char
modifier|*
name|message
parameter_list|,
name|int
name|verbose_level
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|AHC_TARGET_MODE
name|struct
name|ahc_tmode_tstate
modifier|*
name|tstate
decl_stmt|;
name|u_int
name|lun
decl_stmt|;
endif|#
directive|endif
name|int
name|found
decl_stmt|;
name|found
operator|=
name|ahc_abort_scbs
argument_list|(
name|ahc
argument_list|,
name|devinfo
operator|->
name|target
argument_list|,
name|devinfo
operator|->
name|channel
argument_list|,
name|CAM_LUN_WILDCARD
argument_list|,
name|SCB_LIST_NULL
argument_list|,
name|devinfo
operator|->
name|role
argument_list|,
name|status
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|AHC_TARGET_MODE
comment|/* 	 * Send an immediate notify ccb to all target mord peripheral 	 * drivers affected by this action. 	 */
name|tstate
operator|=
name|ahc
operator|->
name|enabled_targets
index|[
name|devinfo
operator|->
name|our_scsiid
index|]
expr_stmt|;
if|if
condition|(
name|tstate
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|lun
operator|=
literal|0
init|;
name|lun
operator|<
name|AHC_NUM_LUNS
condition|;
name|lun
operator|++
control|)
block|{
name|struct
name|ahc_tmode_lstate
modifier|*
name|lstate
decl_stmt|;
name|lstate
operator|=
name|tstate
operator|->
name|enabled_luns
index|[
name|lun
index|]
expr_stmt|;
if|if
condition|(
name|lstate
operator|==
name|NULL
condition|)
continue|continue;
name|ahc_queue_lstate_event
argument_list|(
name|ahc
argument_list|,
name|lstate
argument_list|,
name|devinfo
operator|->
name|our_scsiid
argument_list|,
name|MSG_BUS_DEV_RESET
argument_list|,
comment|/*arg*/
literal|0
argument_list|)
expr_stmt|;
name|ahc_send_lstate_events
argument_list|(
name|ahc
argument_list|,
name|lstate
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* 	 * Go back to async/narrow transfers and renegotiate. 	 */
name|ahc_set_width
argument_list|(
name|ahc
argument_list|,
name|devinfo
argument_list|,
name|MSG_EXT_WDTR_BUS_8_BIT
argument_list|,
name|AHC_TRANS_CUR
argument_list|,
comment|/*paused*/
name|TRUE
argument_list|)
expr_stmt|;
name|ahc_set_syncrate
argument_list|(
name|ahc
argument_list|,
name|devinfo
argument_list|,
comment|/*syncrate*/
name|NULL
argument_list|,
comment|/*period*/
literal|0
argument_list|,
comment|/*offset*/
literal|0
argument_list|,
comment|/*ppr_options*/
literal|0
argument_list|,
name|AHC_TRANS_CUR
argument_list|,
comment|/*paused*/
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|CAM_SEL_TIMEOUT
condition|)
name|ahc_send_async
argument_list|(
name|ahc
argument_list|,
name|devinfo
operator|->
name|channel
argument_list|,
name|devinfo
operator|->
name|target
argument_list|,
name|CAM_LUN_WILDCARD
argument_list|,
name|AC_SENT_BDR
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|message
operator|!=
name|NULL
operator|&&
operator|(
name|verbose_level
operator|<=
name|bootverbose
operator|)
condition|)
name|printf
argument_list|(
literal|"%s: %s on %c:%d. %d SCBs aborted\n"
argument_list|,
name|ahc_name
argument_list|(
name|ahc
argument_list|)
argument_list|,
name|message
argument_list|,
name|devinfo
operator|->
name|channel
argument_list|,
name|devinfo
operator|->
name|target
argument_list|,
name|found
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|AHC_TARGET_MODE
end_ifdef

begin_function
specifier|static
name|void
name|ahc_setup_target_msgin
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|struct
name|ahc_devinfo
modifier|*
name|devinfo
parameter_list|,
name|struct
name|scb
modifier|*
name|scb
parameter_list|)
block|{
comment|/*               	 * To facilitate adding multiple messages together, 	 * each routine should increment the index and len 	 * variables instead of setting them explicitly. 	 */
name|ahc
operator|->
name|msgout_index
operator|=
literal|0
expr_stmt|;
name|ahc
operator|->
name|msgout_len
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|scb
operator|!=
name|NULL
operator|&&
operator|(
name|scb
operator|->
name|flags
operator|&
name|SCB_AUTO_NEGOTIATE
operator|)
operator|!=
literal|0
condition|)
name|ahc_build_transfer_msg
argument_list|(
name|ahc
argument_list|,
name|devinfo
argument_list|)
expr_stmt|;
else|else
name|panic
argument_list|(
literal|"ahc_intr: AWAITING target message with no message"
argument_list|)
expr_stmt|;
name|ahc
operator|->
name|msgout_index
operator|=
literal|0
expr_stmt|;
name|ahc
operator|->
name|msg_type
operator|=
name|MSG_TYPE_TARGET_MSGIN
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/**************************** Initialization **********************************/
end_comment

begin_comment
comment|/*  * Allocate a controller structure for a new device  * and perform initial initializion.  */
end_comment

begin_function
name|struct
name|ahc_softc
modifier|*
name|ahc_alloc
parameter_list|(
name|void
modifier|*
name|platform_arg
parameter_list|,
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|ahc_softc
modifier|*
name|ahc
decl_stmt|;
name|int
name|i
decl_stmt|;
ifndef|#
directive|ifndef
name|__FreeBSD__
name|ahc
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|ahc
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ahc
condition|)
block|{
name|printf
argument_list|(
literal|"aic7xxx: cannot malloc softc!\n"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|name
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
else|#
directive|else
name|ahc
operator|=
name|device_get_softc
argument_list|(
operator|(
name|device_t
operator|)
name|platform_arg
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|memset
argument_list|(
name|ahc
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ahc
argument_list|)
argument_list|)
expr_stmt|;
name|ahc
operator|->
name|seep_config
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|ahc
operator|->
name|seep_config
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|ahc
operator|->
name|seep_config
operator|==
name|NULL
condition|)
block|{
ifndef|#
directive|ifndef
name|__FreeBSD__
name|free
argument_list|(
name|ahc
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|free
argument_list|(
name|name
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|LIST_INIT
argument_list|(
operator|&
name|ahc
operator|->
name|pending_scbs
argument_list|)
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|ahc
operator|->
name|timedout_scbs
argument_list|)
expr_stmt|;
comment|/* We don't know our unit number until the OSM sets it */
name|ahc
operator|->
name|name
operator|=
name|name
expr_stmt|;
name|ahc
operator|->
name|unit
operator|=
operator|-
literal|1
expr_stmt|;
name|ahc
operator|->
name|description
operator|=
name|NULL
expr_stmt|;
name|ahc
operator|->
name|channel
operator|=
literal|'A'
expr_stmt|;
name|ahc
operator|->
name|channel_b
operator|=
literal|'B'
expr_stmt|;
name|ahc
operator|->
name|chip
operator|=
name|AHC_NONE
expr_stmt|;
name|ahc
operator|->
name|features
operator|=
name|AHC_FENONE
expr_stmt|;
name|ahc
operator|->
name|bugs
operator|=
name|AHC_BUGNONE
expr_stmt|;
name|ahc
operator|->
name|flags
operator|=
name|AHC_FNONE
expr_stmt|;
comment|/* 	 * Default to all error reporting enabled with the 	 * sequencer operating at its fastest speed. 	 * The bus attach code may modify this. 	 */
name|ahc
operator|->
name|seqctl
operator|=
name|FASTMODE
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|AHC_NUM_TARGETS
condition|;
name|i
operator|++
control|)
name|TAILQ_INIT
argument_list|(
operator|&
name|ahc
operator|->
name|untagged_queues
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|ahc_platform_alloc
argument_list|(
name|ahc
argument_list|,
name|platform_arg
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|ahc_free
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
name|ahc
operator|=
name|NULL
expr_stmt|;
block|}
name|ahc_lockinit
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
return|return
operator|(
name|ahc
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ahc_softc_init
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|)
block|{
comment|/* The IRQMS bit is only valid on VL and EISA chips */
if|if
condition|(
operator|(
name|ahc
operator|->
name|chip
operator|&
name|AHC_PCI
operator|)
operator|==
literal|0
condition|)
name|ahc
operator|->
name|unpause
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|HCNTRL
argument_list|)
operator|&
name|IRQMS
expr_stmt|;
else|else
name|ahc
operator|->
name|unpause
operator|=
literal|0
expr_stmt|;
name|ahc
operator|->
name|pause
operator|=
name|ahc
operator|->
name|unpause
operator||
name|PAUSE
expr_stmt|;
comment|/* XXX The shared scb data stuff should be deprecated */
if|if
condition|(
name|ahc
operator|->
name|scb_data
operator|==
name|NULL
condition|)
block|{
name|ahc
operator|->
name|scb_data
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|ahc
operator|->
name|scb_data
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|ahc
operator|->
name|scb_data
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|memset
argument_list|(
name|ahc
operator|->
name|scb_data
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ahc
operator|->
name|scb_data
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|ahc_softc_insert
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|)
block|{
name|struct
name|ahc_softc
modifier|*
name|list_ahc
decl_stmt|;
if|#
directive|if
name|AIC_PCI_CONFIG
operator|>
literal|0
comment|/* 	 * Second Function PCI devices need to inherit some 	 * settings from function 0. 	 */
if|if
condition|(
operator|(
name|ahc
operator|->
name|chip
operator|&
name|AHC_BUS_MASK
operator|)
operator|==
name|AHC_PCI
operator|&&
operator|(
name|ahc
operator|->
name|features
operator|&
name|AHC_MULTI_FUNC
operator|)
operator|!=
literal|0
condition|)
block|{
name|TAILQ_FOREACH
argument_list|(
argument|list_ahc
argument_list|,
argument|&ahc_tailq
argument_list|,
argument|links
argument_list|)
block|{
name|aic_dev_softc_t
name|list_pci
decl_stmt|;
name|aic_dev_softc_t
name|pci
decl_stmt|;
name|list_pci
operator|=
name|list_ahc
operator|->
name|dev_softc
expr_stmt|;
name|pci
operator|=
name|ahc
operator|->
name|dev_softc
expr_stmt|;
if|if
condition|(
name|aic_get_pci_slot
argument_list|(
name|list_pci
argument_list|)
operator|==
name|aic_get_pci_slot
argument_list|(
name|pci
argument_list|)
operator|&&
name|aic_get_pci_bus
argument_list|(
name|list_pci
argument_list|)
operator|==
name|aic_get_pci_bus
argument_list|(
name|pci
argument_list|)
condition|)
block|{
name|struct
name|ahc_softc
modifier|*
name|master
decl_stmt|;
name|struct
name|ahc_softc
modifier|*
name|slave
decl_stmt|;
if|if
condition|(
name|aic_get_pci_function
argument_list|(
name|list_pci
argument_list|)
operator|==
literal|0
condition|)
block|{
name|master
operator|=
name|list_ahc
expr_stmt|;
name|slave
operator|=
name|ahc
expr_stmt|;
block|}
else|else
block|{
name|master
operator|=
name|ahc
expr_stmt|;
name|slave
operator|=
name|list_ahc
expr_stmt|;
block|}
name|slave
operator|->
name|flags
operator|&=
operator|~
name|AHC_BIOS_ENABLED
expr_stmt|;
name|slave
operator|->
name|flags
operator||=
name|master
operator|->
name|flags
operator|&
name|AHC_BIOS_ENABLED
expr_stmt|;
name|slave
operator|->
name|flags
operator|&=
operator|~
name|AHC_PRIMARY_CHANNEL
expr_stmt|;
name|slave
operator|->
name|flags
operator||=
name|master
operator|->
name|flags
operator|&
name|AHC_PRIMARY_CHANNEL
expr_stmt|;
break|break;
block|}
block|}
block|}
endif|#
directive|endif
comment|/* 	 * Insertion sort into our list of softcs. 	 */
name|list_ahc
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|ahc_tailq
argument_list|)
expr_stmt|;
while|while
condition|(
name|list_ahc
operator|!=
name|NULL
operator|&&
name|ahc_softc_comp
argument_list|(
name|ahc
argument_list|,
name|list_ahc
argument_list|)
operator|<=
literal|0
condition|)
name|list_ahc
operator|=
name|TAILQ_NEXT
argument_list|(
name|list_ahc
argument_list|,
name|links
argument_list|)
expr_stmt|;
if|if
condition|(
name|list_ahc
operator|!=
name|NULL
condition|)
name|TAILQ_INSERT_BEFORE
argument_list|(
name|list_ahc
argument_list|,
name|ahc
argument_list|,
name|links
argument_list|)
expr_stmt|;
else|else
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|ahc_tailq
argument_list|,
name|ahc
argument_list|,
name|links
argument_list|)
expr_stmt|;
name|ahc
operator|->
name|init_level
operator|++
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ahc_set_unit
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|int
name|unit
parameter_list|)
block|{
name|ahc
operator|->
name|unit
operator|=
name|unit
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ahc_set_name
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|char
modifier|*
name|name
parameter_list|)
block|{
if|if
condition|(
name|ahc
operator|->
name|name
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|ahc
operator|->
name|name
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|ahc
operator|->
name|name
operator|=
name|name
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ahc_free
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|ahc_terminate_recovery_thread
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ahc
operator|->
name|init_level
condition|)
block|{
default|default:
case|case
literal|5
case|:
name|ahc_shutdown
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
literal|4
case|:
name|aic_dmamap_unload
argument_list|(
name|ahc
argument_list|,
name|ahc
operator|->
name|shared_data_dmat
argument_list|,
name|ahc
operator|->
name|shared_data_dmamap
argument_list|)
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
literal|3
case|:
name|aic_dmamem_free
argument_list|(
name|ahc
argument_list|,
name|ahc
operator|->
name|shared_data_dmat
argument_list|,
name|ahc
operator|->
name|qoutfifo
argument_list|,
name|ahc
operator|->
name|shared_data_dmamap
argument_list|)
expr_stmt|;
name|aic_dmamap_destroy
argument_list|(
name|ahc
argument_list|,
name|ahc
operator|->
name|shared_data_dmat
argument_list|,
name|ahc
operator|->
name|shared_data_dmamap
argument_list|)
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
literal|2
case|:
name|aic_dma_tag_destroy
argument_list|(
name|ahc
argument_list|,
name|ahc
operator|->
name|shared_data_dmat
argument_list|)
expr_stmt|;
case|case
literal|1
case|:
ifndef|#
directive|ifndef
name|__linux__
name|aic_dma_tag_destroy
argument_list|(
name|ahc
argument_list|,
name|ahc
operator|->
name|buffer_dmat
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
literal|0
case|:
break|break;
block|}
ifndef|#
directive|ifndef
name|__linux__
name|aic_dma_tag_destroy
argument_list|(
name|ahc
argument_list|,
name|ahc
operator|->
name|parent_dmat
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ahc_platform_free
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
name|ahc_fini_scbdata
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|AHC_NUM_TARGETS
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|ahc_tmode_tstate
modifier|*
name|tstate
decl_stmt|;
name|tstate
operator|=
name|ahc
operator|->
name|enabled_targets
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|tstate
operator|!=
name|NULL
condition|)
block|{
ifdef|#
directive|ifdef
name|AHC_TARGET_MODE
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|AHC_NUM_LUNS
condition|;
name|j
operator|++
control|)
block|{
name|struct
name|ahc_tmode_lstate
modifier|*
name|lstate
decl_stmt|;
name|lstate
operator|=
name|tstate
operator|->
name|enabled_luns
index|[
name|j
index|]
expr_stmt|;
if|if
condition|(
name|lstate
operator|!=
name|NULL
condition|)
block|{
name|xpt_free_path
argument_list|(
name|lstate
operator|->
name|path
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|lstate
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
name|free
argument_list|(
name|tstate
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|AHC_TARGET_MODE
if|if
condition|(
name|ahc
operator|->
name|black_hole
operator|!=
name|NULL
condition|)
block|{
name|xpt_free_path
argument_list|(
name|ahc
operator|->
name|black_hole
operator|->
name|path
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ahc
operator|->
name|black_hole
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|ahc
operator|->
name|name
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|ahc
operator|->
name|name
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
if|if
condition|(
name|ahc
operator|->
name|seep_config
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|ahc
operator|->
name|seep_config
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|__FreeBSD__
name|free
argument_list|(
name|ahc
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
end_function

begin_function
name|void
name|ahc_shutdown
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ahc_softc
modifier|*
name|ahc
decl_stmt|;
name|int
name|i
decl_stmt|;
name|ahc
operator|=
operator|(
expr|struct
name|ahc_softc
operator|*
operator|)
name|arg
expr_stmt|;
comment|/* This will reset most registers to 0, but not all */
name|ahc_reset
argument_list|(
name|ahc
argument_list|,
comment|/*reinit*/
name|FALSE
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCSISEQ
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SXFRCTL0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|DSPCISTATUS
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|TARG_SCSIRATE
init|;
name|i
operator|<
name|SCSICONF
condition|;
name|i
operator|++
control|)
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|i
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Reset the controller and record some information about it  * that is only available just after a reset.  If "reinit" is  * non-zero, this reset occured after initial configuration  * and the caller requests that the chip be fully reinitialized  * to a runable state.  Chip interrupts are *not* enabled after  * a reinitialization.  The caller must enable interrupts via  * ahc_intr_enable().  */
end_comment

begin_function
name|int
name|ahc_reset
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|int
name|reinit
parameter_list|)
block|{
name|u_int
name|sblkctl
decl_stmt|;
name|u_int
name|sxfrctl1_a
decl_stmt|,
name|sxfrctl1_b
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|wait
decl_stmt|;
comment|/* 	 * Preserve the value of the SXFRCTL1 register for all channels. 	 * It contains settings that affect termination and we don't want 	 * to disturb the integrity of the bus. 	 */
name|ahc_pause
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
name|sxfrctl1_b
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|ahc
operator|->
name|chip
operator|&
name|AHC_CHIPID_MASK
operator|)
operator|==
name|AHC_AIC7770
condition|)
block|{
name|u_int
name|sblkctl
decl_stmt|;
comment|/* 		 * Save channel B's settings in case this chip 		 * is setup for TWIN channel operation. 		 */
name|sblkctl
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SBLKCTL
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SBLKCTL
argument_list|,
name|sblkctl
operator||
name|SELBUSB
argument_list|)
expr_stmt|;
name|sxfrctl1_b
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SXFRCTL1
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SBLKCTL
argument_list|,
name|sblkctl
operator|&
operator|~
name|SELBUSB
argument_list|)
expr_stmt|;
block|}
name|sxfrctl1_a
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SXFRCTL1
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|HCNTRL
argument_list|,
name|CHIPRST
operator||
name|ahc
operator|->
name|pause
argument_list|)
expr_stmt|;
comment|/* 	 * Ensure that the reset has finished.  We delay 1000us 	 * prior to reading the register to make sure the chip 	 * has sufficiently completed its reset to handle register 	 * accesses. 	 */
name|wait
operator|=
literal|1000
expr_stmt|;
do|do
block|{
name|aic_delay
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|wait
operator|&&
operator|!
operator|(
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|HCNTRL
argument_list|)
operator|&
name|CHIPRSTACK
operator|)
condition|)
do|;
if|if
condition|(
name|wait
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%s: WARNING - Failed chip reset!  "
literal|"Trying to initialize anyway.\n"
argument_list|,
name|ahc_name
argument_list|(
name|ahc
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|HCNTRL
argument_list|,
name|ahc
operator|->
name|pause
argument_list|)
expr_stmt|;
comment|/* Determine channel configuration */
name|sblkctl
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SBLKCTL
argument_list|)
operator|&
operator|(
name|SELBUSB
operator||
name|SELWIDE
operator|)
expr_stmt|;
comment|/* No Twin Channel PCI cards */
if|if
condition|(
operator|(
name|ahc
operator|->
name|chip
operator|&
name|AHC_PCI
operator|)
operator|!=
literal|0
condition|)
name|sblkctl
operator|&=
operator|~
name|SELBUSB
expr_stmt|;
switch|switch
condition|(
name|sblkctl
condition|)
block|{
case|case
literal|0
case|:
comment|/* Single Narrow Channel */
break|break;
case|case
literal|2
case|:
comment|/* Wide Channel */
name|ahc
operator|->
name|features
operator||=
name|AHC_WIDE
expr_stmt|;
break|break;
case|case
literal|8
case|:
comment|/* Twin Channel */
name|ahc
operator|->
name|features
operator||=
name|AHC_TWIN
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|" Unsupported adapter type.  Ignoring\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* 	 * Reload sxfrctl1. 	 * 	 * We must always initialize STPWEN to 1 before we 	 * restore the saved values.  STPWEN is initialized 	 * to a tri-state condition which can only be cleared 	 * by turning it on. 	 */
if|if
condition|(
operator|(
name|ahc
operator|->
name|features
operator|&
name|AHC_TWIN
operator|)
operator|!=
literal|0
condition|)
block|{
name|u_int
name|sblkctl
decl_stmt|;
name|sblkctl
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SBLKCTL
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SBLKCTL
argument_list|,
name|sblkctl
operator||
name|SELBUSB
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SXFRCTL1
argument_list|,
name|sxfrctl1_b
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SBLKCTL
argument_list|,
name|sblkctl
operator|&
operator|~
name|SELBUSB
argument_list|)
expr_stmt|;
block|}
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SXFRCTL1
argument_list|,
name|sxfrctl1_a
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|reinit
operator|!=
literal|0
condition|)
comment|/* 		 * If a recovery action has forced a chip reset, 		 * re-initialize the chip to our liking. 		 */
name|error
operator|=
name|ahc
operator|->
name|bus_chip_init
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|AHC_DUMP_SEQ
else|else
name|ahc_dumpseq
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Determine the number of SCBs available on the controller  */
end_comment

begin_function
name|int
name|ahc_probe_scbs
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|AHC_SCB_MAX
condition|;
name|i
operator|++
control|)
block|{
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCBPTR
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCB_BASE
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCB_BASE
argument_list|)
operator|!=
name|i
condition|)
break|break;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCBPTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCB_BASE
argument_list|)
operator|!=
literal|0
condition|)
break|break;
block|}
return|return
operator|(
name|i
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ahc_dmamap_cb
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
name|nseg
parameter_list|,
name|int
name|error
parameter_list|)
block|{
name|bus_addr_t
modifier|*
name|baddr
decl_stmt|;
name|baddr
operator|=
operator|(
name|bus_addr_t
operator|*
operator|)
name|arg
expr_stmt|;
operator|*
name|baddr
operator|=
name|segs
operator|->
name|ds_addr
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ahc_build_free_scb_list
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|)
block|{
name|int
name|scbsize
decl_stmt|;
name|int
name|i
decl_stmt|;
name|scbsize
operator|=
literal|32
expr_stmt|;
if|if
condition|(
operator|(
name|ahc
operator|->
name|flags
operator|&
name|AHC_LSCBS_ENABLED
operator|)
operator|!=
literal|0
condition|)
name|scbsize
operator|=
literal|64
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ahc
operator|->
name|scb_data
operator|->
name|maxhscbs
condition|;
name|i
operator|++
control|)
block|{
name|int
name|j
decl_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCBPTR
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* 		 * Touch all SCB bytes to avoid parity errors 		 * should one of our debugging routines read 		 * an otherwise uninitiatlized byte. 		 */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|scbsize
condition|;
name|j
operator|++
control|)
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCB_BASE
operator|+
name|j
argument_list|,
literal|0xFF
argument_list|)
expr_stmt|;
comment|/* Clear the control byte. */
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCB_CONTROL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Set the next pointer */
if|if
condition|(
operator|(
name|ahc
operator|->
name|flags
operator|&
name|AHC_PAGESCBS
operator|)
operator|!=
literal|0
condition|)
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCB_NEXT
argument_list|,
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
else|else
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCB_NEXT
argument_list|,
name|SCB_LIST_NULL
argument_list|)
expr_stmt|;
comment|/* Make the tag number, SCSIID, and lun invalid */
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCB_TAG
argument_list|,
name|SCB_LIST_NULL
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCB_SCSIID
argument_list|,
literal|0xFF
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCB_LUN
argument_list|,
literal|0xFF
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|ahc
operator|->
name|flags
operator|&
name|AHC_PAGESCBS
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* SCB 0 heads the free list. */
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|FREE_SCBH
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* No free list. */
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|FREE_SCBH
argument_list|,
name|SCB_LIST_NULL
argument_list|)
expr_stmt|;
block|}
comment|/* Make sure that the last SCB terminates the free list */
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCBPTR
argument_list|,
name|i
operator|-
literal|1
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCB_NEXT
argument_list|,
name|SCB_LIST_NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|ahc_init_scbdata
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|)
block|{
name|struct
name|scb_data
modifier|*
name|scb_data
decl_stmt|;
name|scb_data
operator|=
name|ahc
operator|->
name|scb_data
expr_stmt|;
name|SLIST_INIT
argument_list|(
operator|&
name|scb_data
operator|->
name|free_scbs
argument_list|)
expr_stmt|;
name|SLIST_INIT
argument_list|(
operator|&
name|scb_data
operator|->
name|sg_maps
argument_list|)
expr_stmt|;
comment|/* Allocate SCB resources */
name|scb_data
operator|->
name|scbarray
operator|=
operator|(
expr|struct
name|scb
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|scb
argument_list|)
operator|*
name|AHC_SCB_MAX_ALLOC
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|scb_data
operator|->
name|scbarray
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|memset
argument_list|(
name|scb_data
operator|->
name|scbarray
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|scb
argument_list|)
operator|*
name|AHC_SCB_MAX_ALLOC
argument_list|)
expr_stmt|;
comment|/* Determine the number of hardware SCBs and initialize them */
name|scb_data
operator|->
name|maxhscbs
operator|=
name|ahc_probe_scbs
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
if|if
condition|(
name|ahc
operator|->
name|scb_data
operator|->
name|maxhscbs
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%s: No SCB space found\n"
argument_list|,
name|ahc_name
argument_list|(
name|ahc
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/* 	 * Create our DMA tags.  These tags define the kinds of device 	 * accessible memory allocations and memory mappings we will 	 * need to perform during normal operation. 	 * 	 * Unless we need to further restrict the allocation, we rely 	 * on the restrictions of the parent dmat, hence the common 	 * use of MAXADDR and MAXSIZE. 	 */
comment|/* DMA tag for our hardware scb structures */
if|if
condition|(
name|aic_dma_tag_create
argument_list|(
name|ahc
argument_list|,
name|ahc
operator|->
name|parent_dmat
argument_list|,
comment|/*alignment*/
literal|1
argument_list|,
comment|/*boundary*/
name|BUS_SPACE_MAXADDR_32BIT
operator|+
literal|1
argument_list|,
comment|/*lowaddr*/
name|BUS_SPACE_MAXADDR_32BIT
argument_list|,
comment|/*highaddr*/
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/*filter*/
name|NULL
argument_list|,
comment|/*filterarg*/
name|NULL
argument_list|,
name|AHC_SCB_MAX_ALLOC
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|hardware_scb
argument_list|)
argument_list|,
comment|/*nsegments*/
literal|1
argument_list|,
comment|/*maxsegsz*/
name|BUS_SPACE_MAXSIZE_32BIT
argument_list|,
comment|/*flags*/
literal|0
argument_list|,
operator|&
name|scb_data
operator|->
name|hscb_dmat
argument_list|)
operator|!=
literal|0
condition|)
block|{
goto|goto
name|error_exit
goto|;
block|}
name|scb_data
operator|->
name|init_level
operator|++
expr_stmt|;
comment|/* Allocation for our hscbs */
if|if
condition|(
name|aic_dmamem_alloc
argument_list|(
name|ahc
argument_list|,
name|scb_data
operator|->
name|hscb_dmat
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|scb_data
operator|->
name|hscbs
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|,
operator|&
name|scb_data
operator|->
name|hscb_dmamap
argument_list|)
operator|!=
literal|0
condition|)
block|{
goto|goto
name|error_exit
goto|;
block|}
name|scb_data
operator|->
name|init_level
operator|++
expr_stmt|;
comment|/* And permanently map them */
name|aic_dmamap_load
argument_list|(
name|ahc
argument_list|,
name|scb_data
operator|->
name|hscb_dmat
argument_list|,
name|scb_data
operator|->
name|hscb_dmamap
argument_list|,
name|scb_data
operator|->
name|hscbs
argument_list|,
name|AHC_SCB_MAX_ALLOC
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|hardware_scb
argument_list|)
argument_list|,
name|ahc_dmamap_cb
argument_list|,
operator|&
name|scb_data
operator|->
name|hscb_busaddr
argument_list|,
comment|/*flags*/
literal|0
argument_list|)
expr_stmt|;
name|scb_data
operator|->
name|init_level
operator|++
expr_stmt|;
comment|/* DMA tag for our sense buffers */
if|if
condition|(
name|aic_dma_tag_create
argument_list|(
name|ahc
argument_list|,
name|ahc
operator|->
name|parent_dmat
argument_list|,
comment|/*alignment*/
literal|1
argument_list|,
comment|/*boundary*/
name|BUS_SPACE_MAXADDR_32BIT
operator|+
literal|1
argument_list|,
comment|/*lowaddr*/
name|BUS_SPACE_MAXADDR_32BIT
argument_list|,
comment|/*highaddr*/
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/*filter*/
name|NULL
argument_list|,
comment|/*filterarg*/
name|NULL
argument_list|,
name|AHC_SCB_MAX_ALLOC
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_sense_data
argument_list|)
argument_list|,
comment|/*nsegments*/
literal|1
argument_list|,
comment|/*maxsegsz*/
name|BUS_SPACE_MAXSIZE_32BIT
argument_list|,
comment|/*flags*/
literal|0
argument_list|,
operator|&
name|scb_data
operator|->
name|sense_dmat
argument_list|)
operator|!=
literal|0
condition|)
block|{
goto|goto
name|error_exit
goto|;
block|}
name|scb_data
operator|->
name|init_level
operator|++
expr_stmt|;
comment|/* Allocate them */
if|if
condition|(
name|aic_dmamem_alloc
argument_list|(
name|ahc
argument_list|,
name|scb_data
operator|->
name|sense_dmat
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|scb_data
operator|->
name|sense
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|,
operator|&
name|scb_data
operator|->
name|sense_dmamap
argument_list|)
operator|!=
literal|0
condition|)
block|{
goto|goto
name|error_exit
goto|;
block|}
name|scb_data
operator|->
name|init_level
operator|++
expr_stmt|;
comment|/* And permanently map them */
name|aic_dmamap_load
argument_list|(
name|ahc
argument_list|,
name|scb_data
operator|->
name|sense_dmat
argument_list|,
name|scb_data
operator|->
name|sense_dmamap
argument_list|,
name|scb_data
operator|->
name|sense
argument_list|,
name|AHC_SCB_MAX_ALLOC
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_sense_data
argument_list|)
argument_list|,
name|ahc_dmamap_cb
argument_list|,
operator|&
name|scb_data
operator|->
name|sense_busaddr
argument_list|,
comment|/*flags*/
literal|0
argument_list|)
expr_stmt|;
name|scb_data
operator|->
name|init_level
operator|++
expr_stmt|;
comment|/* DMA tag for our S/G structures.  We allocate in page sized chunks */
if|if
condition|(
name|aic_dma_tag_create
argument_list|(
name|ahc
argument_list|,
name|ahc
operator|->
name|parent_dmat
argument_list|,
comment|/*alignment*/
literal|8
argument_list|,
comment|/*boundary*/
name|BUS_SPACE_MAXADDR_32BIT
operator|+
literal|1
argument_list|,
comment|/*lowaddr*/
name|BUS_SPACE_MAXADDR_32BIT
argument_list|,
comment|/*highaddr*/
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/*filter*/
name|NULL
argument_list|,
comment|/*filterarg*/
name|NULL
argument_list|,
name|PAGE_SIZE
argument_list|,
comment|/*nsegments*/
literal|1
argument_list|,
comment|/*maxsegsz*/
name|BUS_SPACE_MAXSIZE_32BIT
argument_list|,
comment|/*flags*/
literal|0
argument_list|,
operator|&
name|scb_data
operator|->
name|sg_dmat
argument_list|)
operator|!=
literal|0
condition|)
block|{
goto|goto
name|error_exit
goto|;
block|}
name|scb_data
operator|->
name|init_level
operator|++
expr_stmt|;
comment|/* Perform initial CCB allocation */
name|memset
argument_list|(
name|scb_data
operator|->
name|hscbs
argument_list|,
literal|0
argument_list|,
name|AHC_SCB_MAX_ALLOC
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|hardware_scb
argument_list|)
argument_list|)
expr_stmt|;
name|ahc_alloc_scbs
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
if|if
condition|(
name|scb_data
operator|->
name|numscbs
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%s: ahc_init_scbdata - "
literal|"Unable to allocate initial scbs\n"
argument_list|,
name|ahc_name
argument_list|(
name|ahc
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|error_exit
goto|;
block|}
comment|/* 	 * Reserve the next queued SCB. 	 */
name|ahc
operator|->
name|next_queued_scb
operator|=
name|ahc_get_scb
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
comment|/* 	 * Note that we were successfull 	 */
return|return
operator|(
literal|0
operator|)
return|;
name|error_exit
label|:
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ahc_fini_scbdata
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|)
block|{
name|struct
name|scb_data
modifier|*
name|scb_data
decl_stmt|;
name|scb_data
operator|=
name|ahc
operator|->
name|scb_data
expr_stmt|;
if|if
condition|(
name|scb_data
operator|==
name|NULL
condition|)
return|return;
switch|switch
condition|(
name|scb_data
operator|->
name|init_level
condition|)
block|{
default|default:
case|case
literal|7
case|:
block|{
name|struct
name|sg_map_node
modifier|*
name|sg_map
decl_stmt|;
while|while
condition|(
operator|(
name|sg_map
operator|=
name|SLIST_FIRST
argument_list|(
operator|&
name|scb_data
operator|->
name|sg_maps
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|SLIST_REMOVE_HEAD
argument_list|(
operator|&
name|scb_data
operator|->
name|sg_maps
argument_list|,
name|links
argument_list|)
expr_stmt|;
name|aic_dmamap_unload
argument_list|(
name|ahc
argument_list|,
name|scb_data
operator|->
name|sg_dmat
argument_list|,
name|sg_map
operator|->
name|sg_dmamap
argument_list|)
expr_stmt|;
name|aic_dmamem_free
argument_list|(
name|ahc
argument_list|,
name|scb_data
operator|->
name|sg_dmat
argument_list|,
name|sg_map
operator|->
name|sg_vaddr
argument_list|,
name|sg_map
operator|->
name|sg_dmamap
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sg_map
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
name|aic_dma_tag_destroy
argument_list|(
name|ahc
argument_list|,
name|scb_data
operator|->
name|sg_dmat
argument_list|)
expr_stmt|;
block|}
case|case
literal|6
case|:
name|aic_dmamap_unload
argument_list|(
name|ahc
argument_list|,
name|scb_data
operator|->
name|sense_dmat
argument_list|,
name|scb_data
operator|->
name|sense_dmamap
argument_list|)
expr_stmt|;
case|case
literal|5
case|:
name|aic_dmamem_free
argument_list|(
name|ahc
argument_list|,
name|scb_data
operator|->
name|sense_dmat
argument_list|,
name|scb_data
operator|->
name|sense
argument_list|,
name|scb_data
operator|->
name|sense_dmamap
argument_list|)
expr_stmt|;
name|aic_dmamap_destroy
argument_list|(
name|ahc
argument_list|,
name|scb_data
operator|->
name|sense_dmat
argument_list|,
name|scb_data
operator|->
name|sense_dmamap
argument_list|)
expr_stmt|;
case|case
literal|4
case|:
name|aic_dma_tag_destroy
argument_list|(
name|ahc
argument_list|,
name|scb_data
operator|->
name|sense_dmat
argument_list|)
expr_stmt|;
case|case
literal|3
case|:
name|aic_dmamap_unload
argument_list|(
name|ahc
argument_list|,
name|scb_data
operator|->
name|hscb_dmat
argument_list|,
name|scb_data
operator|->
name|hscb_dmamap
argument_list|)
expr_stmt|;
case|case
literal|2
case|:
name|aic_dmamem_free
argument_list|(
name|ahc
argument_list|,
name|scb_data
operator|->
name|hscb_dmat
argument_list|,
name|scb_data
operator|->
name|hscbs
argument_list|,
name|scb_data
operator|->
name|hscb_dmamap
argument_list|)
expr_stmt|;
name|aic_dmamap_destroy
argument_list|(
name|ahc
argument_list|,
name|scb_data
operator|->
name|hscb_dmat
argument_list|,
name|scb_data
operator|->
name|hscb_dmamap
argument_list|)
expr_stmt|;
case|case
literal|1
case|:
name|aic_dma_tag_destroy
argument_list|(
name|ahc
argument_list|,
name|scb_data
operator|->
name|hscb_dmat
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0
case|:
break|break;
block|}
if|if
condition|(
name|scb_data
operator|->
name|scbarray
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|scb_data
operator|->
name|scbarray
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ahc_alloc_scbs
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|)
block|{
name|struct
name|scb_data
modifier|*
name|scb_data
decl_stmt|;
name|struct
name|scb
modifier|*
name|next_scb
decl_stmt|;
name|struct
name|sg_map_node
modifier|*
name|sg_map
decl_stmt|;
name|bus_addr_t
name|physaddr
decl_stmt|;
name|struct
name|ahc_dma_seg
modifier|*
name|segs
decl_stmt|;
name|int
name|newcount
decl_stmt|;
name|int
name|i
decl_stmt|;
name|scb_data
operator|=
name|ahc
operator|->
name|scb_data
expr_stmt|;
if|if
condition|(
name|scb_data
operator|->
name|numscbs
operator|>=
name|AHC_SCB_MAX_ALLOC
condition|)
comment|/* Can't allocate any more */
return|return;
name|next_scb
operator|=
operator|&
name|scb_data
operator|->
name|scbarray
index|[
name|scb_data
operator|->
name|numscbs
index|]
expr_stmt|;
name|sg_map
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|sg_map
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|sg_map
operator|==
name|NULL
condition|)
return|return;
comment|/* Allocate S/G space for the next batch of SCBS */
if|if
condition|(
name|aic_dmamem_alloc
argument_list|(
name|ahc
argument_list|,
name|scb_data
operator|->
name|sg_dmat
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|sg_map
operator|->
name|sg_vaddr
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|,
operator|&
name|sg_map
operator|->
name|sg_dmamap
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|free
argument_list|(
name|sg_map
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return;
block|}
name|SLIST_INSERT_HEAD
argument_list|(
operator|&
name|scb_data
operator|->
name|sg_maps
argument_list|,
name|sg_map
argument_list|,
name|links
argument_list|)
expr_stmt|;
name|aic_dmamap_load
argument_list|(
name|ahc
argument_list|,
name|scb_data
operator|->
name|sg_dmat
argument_list|,
name|sg_map
operator|->
name|sg_dmamap
argument_list|,
name|sg_map
operator|->
name|sg_vaddr
argument_list|,
name|PAGE_SIZE
argument_list|,
name|ahc_dmamap_cb
argument_list|,
operator|&
name|sg_map
operator|->
name|sg_physaddr
argument_list|,
comment|/*flags*/
literal|0
argument_list|)
expr_stmt|;
name|segs
operator|=
name|sg_map
operator|->
name|sg_vaddr
expr_stmt|;
name|physaddr
operator|=
name|sg_map
operator|->
name|sg_physaddr
expr_stmt|;
name|newcount
operator|=
operator|(
name|PAGE_SIZE
operator|/
operator|(
name|AHC_NSEG
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|ahc_dma_seg
argument_list|)
operator|)
operator|)
expr_stmt|;
name|newcount
operator|=
name|MIN
argument_list|(
name|newcount
argument_list|,
operator|(
name|AHC_SCB_MAX_ALLOC
operator|-
name|scb_data
operator|->
name|numscbs
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|newcount
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|scb_platform_data
modifier|*
name|pdata
decl_stmt|;
ifndef|#
directive|ifndef
name|__linux__
name|int
name|error
decl_stmt|;
endif|#
directive|endif
name|pdata
operator|=
operator|(
expr|struct
name|scb_platform_data
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|pdata
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|pdata
operator|==
name|NULL
condition|)
break|break;
name|next_scb
operator|->
name|platform_data
operator|=
name|pdata
expr_stmt|;
name|next_scb
operator|->
name|sg_map
operator|=
name|sg_map
expr_stmt|;
name|next_scb
operator|->
name|sg_list
operator|=
name|segs
expr_stmt|;
comment|/* 		 * The sequencer always starts with the second entry. 		 * The first entry is embedded in the scb. 		 */
name|next_scb
operator|->
name|sg_list_phys
operator|=
name|physaddr
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ahc_dma_seg
argument_list|)
expr_stmt|;
name|next_scb
operator|->
name|ahc_softc
operator|=
name|ahc
expr_stmt|;
name|next_scb
operator|->
name|flags
operator|=
name|SCB_FLAG_NONE
expr_stmt|;
ifndef|#
directive|ifndef
name|__linux__
name|error
operator|=
name|aic_dmamap_create
argument_list|(
name|ahc
argument_list|,
name|ahc
operator|->
name|buffer_dmat
argument_list|,
comment|/*flags*/
literal|0
argument_list|,
operator|&
name|next_scb
operator|->
name|dmamap
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
break|break;
endif|#
directive|endif
name|next_scb
operator|->
name|hscb
operator|=
operator|&
name|scb_data
operator|->
name|hscbs
index|[
name|scb_data
operator|->
name|numscbs
index|]
expr_stmt|;
name|next_scb
operator|->
name|hscb
operator|->
name|tag
operator|=
name|ahc
operator|->
name|scb_data
operator|->
name|numscbs
expr_stmt|;
name|aic_timer_init
argument_list|(
operator|&
name|next_scb
operator|->
name|io_timer
argument_list|)
expr_stmt|;
name|SLIST_INSERT_HEAD
argument_list|(
operator|&
name|ahc
operator|->
name|scb_data
operator|->
name|free_scbs
argument_list|,
name|next_scb
argument_list|,
name|links
operator|.
name|sle
argument_list|)
expr_stmt|;
name|segs
operator|+=
name|AHC_NSEG
expr_stmt|;
name|physaddr
operator|+=
operator|(
name|AHC_NSEG
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|ahc_dma_seg
argument_list|)
operator|)
expr_stmt|;
name|next_scb
operator|++
expr_stmt|;
name|ahc
operator|->
name|scb_data
operator|->
name|numscbs
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|ahc_controller_info
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|)
block|{
name|int
name|len
decl_stmt|;
name|len
operator|=
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s: "
argument_list|,
name|ahc_chip_names
index|[
name|ahc
operator|->
name|chip
operator|&
name|AHC_CHIPID_MASK
index|]
argument_list|)
expr_stmt|;
name|buf
operator|+=
name|len
expr_stmt|;
if|if
condition|(
operator|(
name|ahc
operator|->
name|features
operator|&
name|AHC_TWIN
operator|)
operator|!=
literal|0
condition|)
name|len
operator|=
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"Twin Channel, A SCSI Id=%d, "
literal|"B SCSI Id=%d, primary %c, "
argument_list|,
name|ahc
operator|->
name|our_id
argument_list|,
name|ahc
operator|->
name|our_id_b
argument_list|,
operator|(
name|ahc
operator|->
name|flags
operator|&
name|AHC_PRIMARY_CHANNEL
operator|)
operator|+
literal|'A'
argument_list|)
expr_stmt|;
else|else
block|{
specifier|const
name|char
modifier|*
name|speed
decl_stmt|;
specifier|const
name|char
modifier|*
name|type
decl_stmt|;
name|speed
operator|=
literal|""
expr_stmt|;
if|if
condition|(
operator|(
name|ahc
operator|->
name|features
operator|&
name|AHC_ULTRA
operator|)
operator|!=
literal|0
condition|)
block|{
name|speed
operator|=
literal|"Ultra "
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|ahc
operator|->
name|features
operator|&
name|AHC_DT
operator|)
operator|!=
literal|0
condition|)
block|{
name|speed
operator|=
literal|"Ultra160 "
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|ahc
operator|->
name|features
operator|&
name|AHC_ULTRA2
operator|)
operator|!=
literal|0
condition|)
block|{
name|speed
operator|=
literal|"Ultra2 "
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|ahc
operator|->
name|features
operator|&
name|AHC_WIDE
operator|)
operator|!=
literal|0
condition|)
block|{
name|type
operator|=
literal|"Wide"
expr_stmt|;
block|}
else|else
block|{
name|type
operator|=
literal|"Single"
expr_stmt|;
block|}
name|len
operator|=
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s%s Channel %c, SCSI Id=%d, "
argument_list|,
name|speed
argument_list|,
name|type
argument_list|,
name|ahc
operator|->
name|channel
argument_list|,
name|ahc
operator|->
name|our_id
argument_list|)
expr_stmt|;
block|}
name|buf
operator|+=
name|len
expr_stmt|;
if|if
condition|(
operator|(
name|ahc
operator|->
name|flags
operator|&
name|AHC_PAGESCBS
operator|)
operator|!=
literal|0
condition|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%d/%d SCBs"
argument_list|,
name|ahc
operator|->
name|scb_data
operator|->
name|maxhscbs
argument_list|,
name|AHC_MAX_QUEUE
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%d SCBs"
argument_list|,
name|ahc
operator|->
name|scb_data
operator|->
name|maxhscbs
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|ahc_chip_init
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|)
block|{
name|int
name|term
decl_stmt|;
name|int
name|error
decl_stmt|;
name|u_int
name|i
decl_stmt|;
name|u_int
name|scsi_conf
decl_stmt|;
name|u_int
name|scsiseq_template
decl_stmt|;
name|uint32_t
name|physaddr
decl_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SEQ_FLAGS
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SEQ_FLAGS2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Set the SCSI Id, SXFRCTL0, SXFRCTL1, and SIMODE1, for both channels*/
if|if
condition|(
name|ahc
operator|->
name|features
operator|&
name|AHC_TWIN
condition|)
block|{
comment|/* 		 * Setup Channel B first. 		 */
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SBLKCTL
argument_list|,
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SBLKCTL
argument_list|)
operator||
name|SELBUSB
argument_list|)
expr_stmt|;
name|term
operator|=
operator|(
name|ahc
operator|->
name|flags
operator|&
name|AHC_TERM_ENB_B
operator|)
operator|!=
literal|0
condition|?
name|STPWEN
else|:
literal|0
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCSIID
argument_list|,
name|ahc
operator|->
name|our_id_b
argument_list|)
expr_stmt|;
name|scsi_conf
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCSICONF
operator|+
literal|1
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SXFRCTL1
argument_list|,
operator|(
name|scsi_conf
operator|&
operator|(
name|ENSPCHK
operator||
name|STIMESEL
operator|)
operator|)
operator||
name|term
operator||
name|ahc
operator|->
name|seltime_b
operator||
name|ENSTIMER
operator||
name|ACTNEGEN
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ahc
operator|->
name|features
operator|&
name|AHC_ULTRA2
operator|)
operator|!=
literal|0
condition|)
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SIMODE0
argument_list|,
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SIMODE0
argument_list|)
operator||
name|ENIOERR
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SIMODE1
argument_list|,
name|ENSELTIMO
operator||
name|ENSCSIRST
operator||
name|ENSCSIPERR
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SXFRCTL0
argument_list|,
name|DFON
operator||
name|SPIOEN
argument_list|)
expr_stmt|;
comment|/* Select Channel A */
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SBLKCTL
argument_list|,
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SBLKCTL
argument_list|)
operator|&
operator|~
name|SELBUSB
argument_list|)
expr_stmt|;
block|}
name|term
operator|=
operator|(
name|ahc
operator|->
name|flags
operator|&
name|AHC_TERM_ENB_A
operator|)
operator|!=
literal|0
condition|?
name|STPWEN
else|:
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|ahc
operator|->
name|features
operator|&
name|AHC_ULTRA2
operator|)
operator|!=
literal|0
condition|)
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCSIID_ULTRA2
argument_list|,
name|ahc
operator|->
name|our_id
argument_list|)
expr_stmt|;
else|else
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCSIID
argument_list|,
name|ahc
operator|->
name|our_id
argument_list|)
expr_stmt|;
name|scsi_conf
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCSICONF
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SXFRCTL1
argument_list|,
operator|(
name|scsi_conf
operator|&
operator|(
name|ENSPCHK
operator||
name|STIMESEL
operator|)
operator|)
operator||
name|term
operator||
name|ahc
operator|->
name|seltime
operator||
name|ENSTIMER
operator||
name|ACTNEGEN
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ahc
operator|->
name|features
operator|&
name|AHC_ULTRA2
operator|)
operator|!=
literal|0
condition|)
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SIMODE0
argument_list|,
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SIMODE0
argument_list|)
operator||
name|ENIOERR
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SIMODE1
argument_list|,
name|ENSELTIMO
operator||
name|ENSCSIRST
operator||
name|ENSCSIPERR
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SXFRCTL0
argument_list|,
name|DFON
operator||
name|SPIOEN
argument_list|)
expr_stmt|;
comment|/* There are no untagged SCBs active yet. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
block|{
name|ahc_unbusy_tcl
argument_list|(
name|ahc
argument_list|,
name|BUILD_TCL
argument_list|(
name|i
operator|<<
literal|4
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ahc
operator|->
name|flags
operator|&
name|AHC_SCB_BTT
operator|)
operator|!=
literal|0
condition|)
block|{
name|int
name|lun
decl_stmt|;
comment|/* 			 * The SCB based BTT allows an entry per 			 * target and lun pair. 			 */
for|for
control|(
name|lun
operator|=
literal|1
init|;
name|lun
operator|<
name|AHC_NUM_LUNS
condition|;
name|lun
operator|++
control|)
name|ahc_unbusy_tcl
argument_list|(
name|ahc
argument_list|,
name|BUILD_TCL
argument_list|(
name|i
operator|<<
literal|4
argument_list|,
name|lun
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* All of our queues are empty */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
control|)
name|ahc
operator|->
name|qoutfifo
index|[
name|i
index|]
operator|=
name|SCB_LIST_NULL
expr_stmt|;
name|ahc_sync_qoutfifo
argument_list|(
name|ahc
argument_list|,
name|BUS_DMASYNC_PREREAD
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
control|)
name|ahc
operator|->
name|qinfifo
index|[
name|i
index|]
operator|=
name|SCB_LIST_NULL
expr_stmt|;
if|if
condition|(
operator|(
name|ahc
operator|->
name|features
operator|&
name|AHC_MULTI_TID
operator|)
operator|!=
literal|0
condition|)
block|{
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|TARGID
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|TARGID
operator|+
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Tell the sequencer where it can find our arrays in memory. 	 */
name|physaddr
operator|=
name|ahc
operator|->
name|scb_data
operator|->
name|hscb_busaddr
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|HSCB_ADDR
argument_list|,
name|physaddr
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|HSCB_ADDR
operator|+
literal|1
argument_list|,
operator|(
name|physaddr
operator|>>
literal|8
operator|)
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|HSCB_ADDR
operator|+
literal|2
argument_list|,
operator|(
name|physaddr
operator|>>
literal|16
operator|)
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|HSCB_ADDR
operator|+
literal|3
argument_list|,
operator|(
name|physaddr
operator|>>
literal|24
operator|)
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
name|physaddr
operator|=
name|ahc
operator|->
name|shared_data_busaddr
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SHARED_DATA_ADDR
argument_list|,
name|physaddr
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SHARED_DATA_ADDR
operator|+
literal|1
argument_list|,
operator|(
name|physaddr
operator|>>
literal|8
operator|)
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SHARED_DATA_ADDR
operator|+
literal|2
argument_list|,
operator|(
name|physaddr
operator|>>
literal|16
operator|)
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SHARED_DATA_ADDR
operator|+
literal|3
argument_list|,
operator|(
name|physaddr
operator|>>
literal|24
operator|)
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
comment|/* 	 * Initialize the group code to command length table. 	 * This overrides the values in TARG_SCSIRATE, so only 	 * setup the table after we have processed that information. 	 */
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|CMDSIZE_TABLE
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|CMDSIZE_TABLE
operator|+
literal|1
argument_list|,
literal|9
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|CMDSIZE_TABLE
operator|+
literal|2
argument_list|,
literal|9
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|CMDSIZE_TABLE
operator|+
literal|3
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|CMDSIZE_TABLE
operator|+
literal|4
argument_list|,
literal|15
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|CMDSIZE_TABLE
operator|+
literal|5
argument_list|,
literal|11
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|CMDSIZE_TABLE
operator|+
literal|6
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|CMDSIZE_TABLE
operator|+
literal|7
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ahc
operator|->
name|features
operator|&
name|AHC_HS_MAILBOX
operator|)
operator|!=
literal|0
condition|)
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|HS_MAILBOX
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Tell the sequencer of our initial queue positions */
if|if
condition|(
operator|(
name|ahc
operator|->
name|features
operator|&
name|AHC_TARGETMODE
operator|)
operator|!=
literal|0
condition|)
block|{
name|ahc
operator|->
name|tqinfifonext
operator|=
literal|1
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|KERNEL_TQINPOS
argument_list|,
name|ahc
operator|->
name|tqinfifonext
operator|-
literal|1
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|TQINPOS
argument_list|,
name|ahc
operator|->
name|tqinfifonext
argument_list|)
expr_stmt|;
block|}
name|ahc
operator|->
name|qinfifonext
operator|=
literal|0
expr_stmt|;
name|ahc
operator|->
name|qoutfifonext
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|ahc
operator|->
name|features
operator|&
name|AHC_QUEUE_REGS
operator|)
operator|!=
literal|0
condition|)
block|{
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|QOFF_CTLSTA
argument_list|,
name|SCB_QSIZE_256
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|HNSCB_QOFF
argument_list|,
name|ahc
operator|->
name|qinfifonext
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SNSCB_QOFF
argument_list|,
name|ahc
operator|->
name|qinfifonext
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SDSCB_QOFF
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|KERNEL_QINPOS
argument_list|,
name|ahc
operator|->
name|qinfifonext
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|QINPOS
argument_list|,
name|ahc
operator|->
name|qinfifonext
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|QOUTPOS
argument_list|,
name|ahc
operator|->
name|qoutfifonext
argument_list|)
expr_stmt|;
block|}
comment|/* We don't have any waiting selections */
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|WAITING_SCBH
argument_list|,
name|SCB_LIST_NULL
argument_list|)
expr_stmt|;
comment|/* Our disconnection list is empty too */
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|DISCONNECTED_SCBH
argument_list|,
name|SCB_LIST_NULL
argument_list|)
expr_stmt|;
comment|/* Message out buffer starts empty */
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|MSG_OUT
argument_list|,
name|MSG_NOOP
argument_list|)
expr_stmt|;
comment|/* 	 * Setup the allowed SCSI Sequences based on operational mode. 	 * If we are a target, we'll enalbe select in operations once 	 * we've had a lun enabled. 	 */
name|scsiseq_template
operator|=
name|ENSELO
operator||
name|ENAUTOATNO
operator||
name|ENAUTOATNP
expr_stmt|;
if|if
condition|(
operator|(
name|ahc
operator|->
name|flags
operator|&
name|AHC_INITIATORROLE
operator|)
operator|!=
literal|0
condition|)
name|scsiseq_template
operator||=
name|ENRSELI
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCSISEQ_TEMPLATE
argument_list|,
name|scsiseq_template
argument_list|)
expr_stmt|;
comment|/* Initialize our list of free SCBs. */
name|ahc_build_free_scb_list
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
comment|/* 	 * Tell the sequencer which SCB will be the next one it receives. 	 */
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|NEXT_QUEUED_SCB
argument_list|,
name|ahc
operator|->
name|next_queued_scb
operator|->
name|hscb
operator|->
name|tag
argument_list|)
expr_stmt|;
comment|/* 	 * Load the Sequencer program and Enable the adapter 	 * in "fast" mode. 	 */
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"%s: Downloading Sequencer Program..."
argument_list|,
name|ahc_name
argument_list|(
name|ahc
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|ahc_loadseq
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
operator|(
name|ahc
operator|->
name|features
operator|&
name|AHC_ULTRA2
operator|)
operator|!=
literal|0
condition|)
block|{
name|int
name|wait
decl_stmt|;
comment|/* 		 * Wait for up to 500ms for our transceivers 		 * to settle.  If the adapter does not have 		 * a cable attached, the transceivers may 		 * never settle, so don't complain if we 		 * fail here. 		 */
for|for
control|(
name|wait
operator|=
literal|5000
init|;
operator|(
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SBLKCTL
argument_list|)
operator|&
operator|(
name|ENAB40
operator||
name|ENAB20
operator|)
operator|)
operator|==
literal|0
operator|&&
name|wait
condition|;
name|wait
operator|--
control|)
name|aic_delay
argument_list|(
literal|100
argument_list|)
expr_stmt|;
block|}
name|ahc_restart
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Start the board, ready for normal operation  */
end_comment

begin_function
name|int
name|ahc_init
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|)
block|{
name|int
name|max_targ
decl_stmt|;
name|int
name|error
decl_stmt|;
name|u_int
name|i
decl_stmt|;
name|u_int
name|scsi_conf
decl_stmt|;
name|u_int
name|ultraenb
decl_stmt|;
name|u_int
name|discenable
decl_stmt|;
name|u_int
name|tagenable
decl_stmt|;
name|size_t
name|driver_data_size
decl_stmt|;
ifdef|#
directive|ifdef
name|AHC_DEBUG
if|if
condition|(
operator|(
name|ahc_debug
operator|&
name|AHC_DEBUG_SEQUENCER
operator|)
operator|!=
literal|0
condition|)
name|ahc
operator|->
name|flags
operator||=
name|AHC_SEQUENCER_DEBUG
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|AHC_PRINT_SRAM
name|printf
argument_list|(
literal|"Scratch Ram:"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0x20
init|;
name|i
operator|<
literal|0x5f
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
operator|(
name|i
operator|%
literal|8
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|i
operator|!=
literal|0
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"\n              "
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|" 0x%x"
argument_list|,
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|ahc
operator|->
name|features
operator|&
name|AHC_MORE_SRAM
operator|)
operator|!=
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0x70
init|;
name|i
operator|<
literal|0x7f
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
operator|(
name|i
operator|%
literal|8
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|i
operator|!=
literal|0
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"\n              "
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|" 0x%x"
argument_list|,
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
comment|/* 	 * Reading uninitialized scratch ram may 	 * generate parity errors. 	 */
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|CLRINT
argument_list|,
name|CLRPARERR
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|CLRINT
argument_list|,
name|CLRBRKADRINT
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|max_targ
operator|=
literal|15
expr_stmt|;
comment|/* 	 * Assume we have a board at this stage and it has been reset. 	 */
if|if
condition|(
operator|(
name|ahc
operator|->
name|flags
operator|&
name|AHC_USEDEFAULTS
operator|)
operator|!=
literal|0
condition|)
name|ahc
operator|->
name|our_id
operator|=
name|ahc
operator|->
name|our_id_b
operator|=
literal|7
expr_stmt|;
comment|/* 	 * Default to allowing initiator operations. 	 */
name|ahc
operator|->
name|flags
operator||=
name|AHC_INITIATORROLE
expr_stmt|;
comment|/* 	 * Only allow target mode features if this unit has them enabled. 	 */
if|if
condition|(
operator|(
name|AHC_TMODE_ENABLE
operator|&
operator|(
literal|0x1
operator|<<
name|ahc
operator|->
name|unit
operator|)
operator|)
operator|==
literal|0
condition|)
name|ahc
operator|->
name|features
operator|&=
operator|~
name|AHC_TARGETMODE
expr_stmt|;
ifndef|#
directive|ifndef
name|__linux__
comment|/* DMA tag for mapping buffers into device visible space. */
if|if
condition|(
name|aic_dma_tag_create
argument_list|(
name|ahc
argument_list|,
name|ahc
operator|->
name|parent_dmat
argument_list|,
comment|/*alignment*/
literal|1
argument_list|,
comment|/*boundary*/
name|BUS_SPACE_MAXADDR_32BIT
operator|+
literal|1
argument_list|,
comment|/*lowaddr*/
name|ahc
operator|->
name|flags
operator|&
name|AHC_39BIT_ADDRESSING
condition|?
operator|(
name|bus_addr_t
operator|)
literal|0x7FFFFFFFFFULL
else|:
name|BUS_SPACE_MAXADDR_32BIT
argument_list|,
comment|/*highaddr*/
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/*filter*/
name|NULL
argument_list|,
comment|/*filterarg*/
name|NULL
argument_list|,
comment|/*maxsize*/
operator|(
name|AHC_NSEG
operator|-
literal|1
operator|)
operator|*
name|PAGE_SIZE
argument_list|,
comment|/*nsegments*/
name|AHC_NSEG
argument_list|,
comment|/*maxsegsz*/
name|AHC_MAXTRANSFER_SIZE
argument_list|,
comment|/*flags*/
name|BUS_DMA_ALLOCNOW
argument_list|,
operator|&
name|ahc
operator|->
name|buffer_dmat
argument_list|)
operator|!=
literal|0
condition|)
block|{
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
endif|#
directive|endif
name|ahc
operator|->
name|init_level
operator|++
expr_stmt|;
comment|/* 	 * DMA tag for our command fifos and other data in system memory 	 * the card's sequencer must be able to access.  For initiator 	 * roles, we need to allocate space for the qinfifo and qoutfifo. 	 * The qinfifo and qoutfifo are composed of 256 1 byte elements.  	 * When providing for the target mode role, we must additionally 	 * provide space for the incoming target command fifo and an extra 	 * byte to deal with a dma bug in some chip versions. 	 */
name|driver_data_size
operator|=
literal|2
operator|*
literal|256
operator|*
sizeof|sizeof
argument_list|(
name|uint8_t
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ahc
operator|->
name|features
operator|&
name|AHC_TARGETMODE
operator|)
operator|!=
literal|0
condition|)
name|driver_data_size
operator|+=
name|AHC_TMODE_CMDS
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|target_cmd
argument_list|)
operator|+
comment|/*DMA WideOdd Bug Buffer*/
literal|1
expr_stmt|;
if|if
condition|(
name|aic_dma_tag_create
argument_list|(
name|ahc
argument_list|,
name|ahc
operator|->
name|parent_dmat
argument_list|,
comment|/*alignment*/
literal|1
argument_list|,
comment|/*boundary*/
name|BUS_SPACE_MAXADDR_32BIT
operator|+
literal|1
argument_list|,
comment|/*lowaddr*/
name|BUS_SPACE_MAXADDR_32BIT
argument_list|,
comment|/*highaddr*/
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/*filter*/
name|NULL
argument_list|,
comment|/*filterarg*/
name|NULL
argument_list|,
name|driver_data_size
argument_list|,
comment|/*nsegments*/
literal|1
argument_list|,
comment|/*maxsegsz*/
name|BUS_SPACE_MAXSIZE_32BIT
argument_list|,
comment|/*flags*/
literal|0
argument_list|,
operator|&
name|ahc
operator|->
name|shared_data_dmat
argument_list|)
operator|!=
literal|0
condition|)
block|{
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|ahc
operator|->
name|init_level
operator|++
expr_stmt|;
comment|/* Allocation of driver data */
if|if
condition|(
name|aic_dmamem_alloc
argument_list|(
name|ahc
argument_list|,
name|ahc
operator|->
name|shared_data_dmat
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|ahc
operator|->
name|qoutfifo
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|,
operator|&
name|ahc
operator|->
name|shared_data_dmamap
argument_list|)
operator|!=
literal|0
condition|)
block|{
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|ahc
operator|->
name|init_level
operator|++
expr_stmt|;
comment|/* And permanently map it in */
name|aic_dmamap_load
argument_list|(
name|ahc
argument_list|,
name|ahc
operator|->
name|shared_data_dmat
argument_list|,
name|ahc
operator|->
name|shared_data_dmamap
argument_list|,
name|ahc
operator|->
name|qoutfifo
argument_list|,
name|driver_data_size
argument_list|,
name|ahc_dmamap_cb
argument_list|,
operator|&
name|ahc
operator|->
name|shared_data_busaddr
argument_list|,
comment|/*flags*/
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ahc
operator|->
name|features
operator|&
name|AHC_TARGETMODE
operator|)
operator|!=
literal|0
condition|)
block|{
name|ahc
operator|->
name|targetcmds
operator|=
operator|(
expr|struct
name|target_cmd
operator|*
operator|)
name|ahc
operator|->
name|qoutfifo
expr_stmt|;
name|ahc
operator|->
name|qoutfifo
operator|=
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|ahc
operator|->
name|targetcmds
index|[
name|AHC_TMODE_CMDS
index|]
expr_stmt|;
name|ahc
operator|->
name|dma_bug_buf
operator|=
name|ahc
operator|->
name|shared_data_busaddr
operator|+
name|driver_data_size
operator|-
literal|1
expr_stmt|;
comment|/* All target command blocks start out invalid. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|AHC_TMODE_CMDS
condition|;
name|i
operator|++
control|)
name|ahc
operator|->
name|targetcmds
index|[
name|i
index|]
operator|.
name|cmd_valid
operator|=
literal|0
expr_stmt|;
name|ahc_sync_tqinfifo
argument_list|(
name|ahc
argument_list|,
name|BUS_DMASYNC_PREREAD
argument_list|)
expr_stmt|;
name|ahc
operator|->
name|qoutfifo
operator|=
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|ahc
operator|->
name|targetcmds
index|[
literal|256
index|]
expr_stmt|;
block|}
name|ahc
operator|->
name|qinfifo
operator|=
operator|&
name|ahc
operator|->
name|qoutfifo
index|[
literal|256
index|]
expr_stmt|;
name|ahc
operator|->
name|init_level
operator|++
expr_stmt|;
comment|/* Allocate SCB data now that buffer_dmat is initialized */
if|if
condition|(
name|ahc
operator|->
name|scb_data
operator|->
name|maxhscbs
operator|==
literal|0
condition|)
if|if
condition|(
name|ahc_init_scbdata
argument_list|(
name|ahc
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
comment|/* 	 * Allocate a tstate to house information for our 	 * initiator presence on the bus as well as the user 	 * data for any target mode initiator. 	 */
if|if
condition|(
name|ahc_alloc_tstate
argument_list|(
name|ahc
argument_list|,
name|ahc
operator|->
name|our_id
argument_list|,
literal|'A'
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"%s: unable to allocate ahc_tmode_tstate.  "
literal|"Failing attach\n"
argument_list|,
name|ahc_name
argument_list|(
name|ahc
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|ahc
operator|->
name|features
operator|&
name|AHC_TWIN
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|ahc_alloc_tstate
argument_list|(
name|ahc
argument_list|,
name|ahc
operator|->
name|our_id_b
argument_list|,
literal|'B'
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"%s: unable to allocate ahc_tmode_tstate.  "
literal|"Failing attach\n"
argument_list|,
name|ahc_name
argument_list|(
name|ahc
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
block|}
comment|/* 	 * Fire up a recovery thread for this controller. 	 */
name|error
operator|=
name|ahc_spawn_recovery_thread
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|ahc
operator|->
name|scb_data
operator|->
name|maxhscbs
operator|<
name|AHC_SCB_MAX_ALLOC
condition|)
block|{
name|ahc
operator|->
name|flags
operator||=
name|AHC_PAGESCBS
expr_stmt|;
block|}
else|else
block|{
name|ahc
operator|->
name|flags
operator|&=
operator|~
name|AHC_PAGESCBS
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|AHC_DEBUG
if|if
condition|(
name|ahc_debug
operator|&
name|AHC_SHOW_MISC
condition|)
block|{
name|printf
argument_list|(
literal|"%s: hardware scb %u bytes; kernel scb %u bytes; "
literal|"ahc_dma %u bytes\n"
argument_list|,
name|ahc_name
argument_list|(
name|ahc
argument_list|)
argument_list|,
operator|(
name|u_int
operator|)
sizeof|sizeof
argument_list|(
expr|struct
name|hardware_scb
argument_list|)
argument_list|,
operator|(
name|u_int
operator|)
sizeof|sizeof
argument_list|(
expr|struct
name|scb
argument_list|)
argument_list|,
operator|(
name|u_int
operator|)
sizeof|sizeof
argument_list|(
expr|struct
name|ahc_dma_seg
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* AHC_DEBUG */
comment|/* 	 * Look at the information that board initialization or 	 * the board bios has left us. 	 */
if|if
condition|(
name|ahc
operator|->
name|features
operator|&
name|AHC_TWIN
condition|)
block|{
name|scsi_conf
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCSICONF
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|scsi_conf
operator|&
name|RESET_SCSI
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|ahc
operator|->
name|flags
operator|&
name|AHC_INITIATORROLE
operator|)
operator|!=
literal|0
condition|)
name|ahc
operator|->
name|flags
operator||=
name|AHC_RESET_BUS_B
expr_stmt|;
block|}
name|scsi_conf
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCSICONF
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|scsi_conf
operator|&
name|RESET_SCSI
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|ahc
operator|->
name|flags
operator|&
name|AHC_INITIATORROLE
operator|)
operator|!=
literal|0
condition|)
name|ahc
operator|->
name|flags
operator||=
name|AHC_RESET_BUS_A
expr_stmt|;
name|ultraenb
operator|=
literal|0
expr_stmt|;
name|tagenable
operator|=
name|ALL_TARGETS_MASK
expr_stmt|;
comment|/* Grab the disconnection disable table and invert it for our needs */
if|if
condition|(
operator|(
name|ahc
operator|->
name|flags
operator|&
name|AHC_USEDEFAULTS
operator|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%s: Host Adapter Bios disabled.  Using default SCSI "
literal|"device parameters\n"
argument_list|,
name|ahc_name
argument_list|(
name|ahc
argument_list|)
argument_list|)
expr_stmt|;
name|ahc
operator|->
name|flags
operator||=
name|AHC_EXTENDED_TRANS_A
operator||
name|AHC_EXTENDED_TRANS_B
operator||
name|AHC_TERM_ENB_A
operator||
name|AHC_TERM_ENB_B
expr_stmt|;
name|discenable
operator|=
name|ALL_TARGETS_MASK
expr_stmt|;
if|if
condition|(
operator|(
name|ahc
operator|->
name|features
operator|&
name|AHC_ULTRA
operator|)
operator|!=
literal|0
condition|)
name|ultraenb
operator|=
name|ALL_TARGETS_MASK
expr_stmt|;
block|}
else|else
block|{
name|discenable
operator|=
operator|~
operator|(
operator|(
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|DISC_DSB
operator|+
literal|1
argument_list|)
operator|<<
literal|8
operator|)
operator||
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|DISC_DSB
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|ahc
operator|->
name|features
operator|&
operator|(
name|AHC_ULTRA
operator||
name|AHC_ULTRA2
operator|)
operator|)
operator|!=
literal|0
condition|)
name|ultraenb
operator|=
operator|(
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|ULTRA_ENB
operator|+
literal|1
argument_list|)
operator|<<
literal|8
operator|)
operator||
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|ULTRA_ENB
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|ahc
operator|->
name|features
operator|&
operator|(
name|AHC_WIDE
operator||
name|AHC_TWIN
operator|)
operator|)
operator|==
literal|0
condition|)
name|max_targ
operator|=
literal|7
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|max_targ
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|ahc_initiator_tinfo
modifier|*
name|tinfo
decl_stmt|;
name|struct
name|ahc_tmode_tstate
modifier|*
name|tstate
decl_stmt|;
name|u_int
name|our_id
decl_stmt|;
name|u_int
name|target_id
decl_stmt|;
name|char
name|channel
decl_stmt|;
name|channel
operator|=
literal|'A'
expr_stmt|;
name|our_id
operator|=
name|ahc
operator|->
name|our_id
expr_stmt|;
name|target_id
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|7
operator|&&
operator|(
name|ahc
operator|->
name|features
operator|&
name|AHC_TWIN
operator|)
operator|!=
literal|0
condition|)
block|{
name|channel
operator|=
literal|'B'
expr_stmt|;
name|our_id
operator|=
name|ahc
operator|->
name|our_id_b
expr_stmt|;
name|target_id
operator|=
name|i
operator|%
literal|8
expr_stmt|;
block|}
name|tinfo
operator|=
name|ahc_fetch_transinfo
argument_list|(
name|ahc
argument_list|,
name|channel
argument_list|,
name|our_id
argument_list|,
name|target_id
argument_list|,
operator|&
name|tstate
argument_list|)
expr_stmt|;
comment|/* Default to async narrow across the board */
name|memset
argument_list|(
name|tinfo
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|tinfo
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ahc
operator|->
name|flags
operator|&
name|AHC_USEDEFAULTS
condition|)
block|{
if|if
condition|(
operator|(
name|ahc
operator|->
name|features
operator|&
name|AHC_WIDE
operator|)
operator|!=
literal|0
condition|)
name|tinfo
operator|->
name|user
operator|.
name|width
operator|=
name|MSG_EXT_WDTR_BUS_16_BIT
expr_stmt|;
comment|/* 			 * These will be truncated when we determine the 			 * connection type we have with the target. 			 */
name|tinfo
operator|->
name|user
operator|.
name|period
operator|=
name|ahc_syncrates
operator|->
name|period
expr_stmt|;
name|tinfo
operator|->
name|user
operator|.
name|offset
operator|=
name|MAX_OFFSET
expr_stmt|;
block|}
else|else
block|{
name|u_int
name|scsirate
decl_stmt|;
name|uint16_t
name|mask
decl_stmt|;
comment|/* Take the settings leftover in scratch RAM. */
name|scsirate
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|TARG_SCSIRATE
operator|+
name|i
argument_list|)
expr_stmt|;
name|mask
operator|=
operator|(
literal|0x01
operator|<<
name|i
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|ahc
operator|->
name|features
operator|&
name|AHC_ULTRA2
operator|)
operator|!=
literal|0
condition|)
block|{
name|u_int
name|offset
decl_stmt|;
name|u_int
name|maxsync
decl_stmt|;
if|if
condition|(
operator|(
name|scsirate
operator|&
name|SOFS
operator|)
operator|==
literal|0x0F
condition|)
block|{
comment|/* 					 * Haven't negotiated yet, 					 * so the format is different. 					 */
name|scsirate
operator|=
operator|(
name|scsirate
operator|&
name|SXFR
operator|)
operator|>>
literal|4
operator||
operator|(
name|ultraenb
operator|&
name|mask
operator|)
condition|?
literal|0x08
else|:
literal|0x0
operator||
operator|(
name|scsirate
operator|&
name|WIDEXFER
operator|)
expr_stmt|;
name|offset
operator|=
name|MAX_OFFSET_ULTRA2
expr_stmt|;
block|}
else|else
name|offset
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|TARG_OFFSET
operator|+
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|scsirate
operator|&
operator|~
name|WIDEXFER
operator|)
operator|==
literal|0
operator|&&
name|offset
operator|!=
literal|0
condition|)
comment|/* Set to the lowest sync rate, 5MHz */
name|scsirate
operator||=
literal|0x1c
expr_stmt|;
name|maxsync
operator|=
name|AHC_SYNCRATE_ULTRA2
expr_stmt|;
if|if
condition|(
operator|(
name|ahc
operator|->
name|features
operator|&
name|AHC_DT
operator|)
operator|!=
literal|0
condition|)
name|maxsync
operator|=
name|AHC_SYNCRATE_DT
expr_stmt|;
name|tinfo
operator|->
name|user
operator|.
name|period
operator|=
name|ahc_find_period
argument_list|(
name|ahc
argument_list|,
name|scsirate
argument_list|,
name|maxsync
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
operator|==
literal|0
condition|)
name|tinfo
operator|->
name|user
operator|.
name|period
operator|=
literal|0
expr_stmt|;
else|else
name|tinfo
operator|->
name|user
operator|.
name|offset
operator|=
name|MAX_OFFSET
expr_stmt|;
if|if
condition|(
operator|(
name|scsirate
operator|&
name|SXFR_ULTRA2
operator|)
operator|<=
literal|8
comment|/*10MHz*/
operator|&&
operator|(
name|ahc
operator|->
name|features
operator|&
name|AHC_DT
operator|)
operator|!=
literal|0
condition|)
name|tinfo
operator|->
name|user
operator|.
name|ppr_options
operator|=
name|MSG_EXT_PPR_DT_REQ
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|scsirate
operator|&
name|SOFS
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|scsirate
operator|&
name|SXFR
operator|)
operator|==
literal|0x40
operator|&&
operator|(
name|ultraenb
operator|&
name|mask
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* Treat 10MHz as a non-ultra speed */
name|scsirate
operator|&=
operator|~
name|SXFR
expr_stmt|;
name|ultraenb
operator|&=
operator|~
name|mask
expr_stmt|;
block|}
name|tinfo
operator|->
name|user
operator|.
name|period
operator|=
name|ahc_find_period
argument_list|(
name|ahc
argument_list|,
name|scsirate
argument_list|,
operator|(
name|ultraenb
operator|&
name|mask
operator|)
condition|?
name|AHC_SYNCRATE_ULTRA
else|:
name|AHC_SYNCRATE_FAST
argument_list|)
expr_stmt|;
if|if
condition|(
name|tinfo
operator|->
name|user
operator|.
name|period
operator|!=
literal|0
condition|)
name|tinfo
operator|->
name|user
operator|.
name|offset
operator|=
name|MAX_OFFSET
expr_stmt|;
block|}
if|if
condition|(
name|tinfo
operator|->
name|user
operator|.
name|period
operator|==
literal|0
condition|)
name|tinfo
operator|->
name|user
operator|.
name|offset
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|scsirate
operator|&
name|WIDEXFER
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|ahc
operator|->
name|features
operator|&
name|AHC_WIDE
operator|)
operator|!=
literal|0
condition|)
name|tinfo
operator|->
name|user
operator|.
name|width
operator|=
name|MSG_EXT_WDTR_BUS_16_BIT
expr_stmt|;
name|tinfo
operator|->
name|user
operator|.
name|protocol_version
operator|=
literal|4
expr_stmt|;
if|if
condition|(
operator|(
name|ahc
operator|->
name|features
operator|&
name|AHC_DT
operator|)
operator|!=
literal|0
condition|)
name|tinfo
operator|->
name|user
operator|.
name|transport_version
operator|=
literal|3
expr_stmt|;
else|else
name|tinfo
operator|->
name|user
operator|.
name|transport_version
operator|=
literal|2
expr_stmt|;
name|tinfo
operator|->
name|goal
operator|.
name|protocol_version
operator|=
literal|2
expr_stmt|;
name|tinfo
operator|->
name|goal
operator|.
name|transport_version
operator|=
literal|2
expr_stmt|;
name|tinfo
operator|->
name|curr
operator|.
name|protocol_version
operator|=
literal|2
expr_stmt|;
name|tinfo
operator|->
name|curr
operator|.
name|transport_version
operator|=
literal|2
expr_stmt|;
block|}
name|tstate
operator|->
name|ultraenb
operator|=
literal|0
expr_stmt|;
block|}
name|ahc
operator|->
name|user_discenable
operator|=
name|discenable
expr_stmt|;
name|ahc
operator|->
name|user_tagenable
operator|=
name|tagenable
expr_stmt|;
return|return
operator|(
name|ahc
operator|->
name|bus_chip_init
argument_list|(
name|ahc
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|void
name|ahc_intr_enable
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|int
name|enable
parameter_list|)
block|{
name|u_int
name|hcntrl
decl_stmt|;
name|hcntrl
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|HCNTRL
argument_list|)
expr_stmt|;
name|hcntrl
operator|&=
operator|~
name|INTEN
expr_stmt|;
name|ahc
operator|->
name|pause
operator|&=
operator|~
name|INTEN
expr_stmt|;
name|ahc
operator|->
name|unpause
operator|&=
operator|~
name|INTEN
expr_stmt|;
if|if
condition|(
name|enable
condition|)
block|{
name|hcntrl
operator||=
name|INTEN
expr_stmt|;
name|ahc
operator|->
name|pause
operator||=
name|INTEN
expr_stmt|;
name|ahc
operator|->
name|unpause
operator||=
name|INTEN
expr_stmt|;
block|}
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|HCNTRL
argument_list|,
name|hcntrl
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Ensure that the card is paused in a location  * outside of all critical sections and that all  * pending work is completed prior to returning.  * This routine should only be called from outside  * an interrupt context.  */
end_comment

begin_function
name|void
name|ahc_pause_and_flushwork
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|)
block|{
name|int
name|intstat
decl_stmt|;
name|int
name|maxloops
decl_stmt|;
name|int
name|paused
decl_stmt|;
name|maxloops
operator|=
literal|1000
expr_stmt|;
name|ahc
operator|->
name|flags
operator||=
name|AHC_ALL_INTERRUPTS
expr_stmt|;
name|paused
operator|=
name|FALSE
expr_stmt|;
do|do
block|{
if|if
condition|(
name|paused
condition|)
block|{
name|ahc_unpause
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
comment|/* 			 * Give the sequencer some time to service 			 * any active selections. 			 */
name|aic_delay
argument_list|(
literal|500
argument_list|)
expr_stmt|;
block|}
name|ahc_intr
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
name|ahc_pause
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
name|paused
operator|=
name|TRUE
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCSISEQ
argument_list|,
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCSISEQ
argument_list|)
operator|&
operator|~
name|ENSELO
argument_list|)
expr_stmt|;
name|intstat
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|INTSTAT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|intstat
operator|&
name|INT_PEND
operator|)
operator|==
literal|0
condition|)
block|{
name|ahc_clear_critical_section
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
name|intstat
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|INTSTAT
argument_list|)
expr_stmt|;
block|}
block|}
do|while
condition|(
operator|--
name|maxloops
operator|&&
operator|(
name|intstat
operator|!=
literal|0xFF
operator|||
operator|(
name|ahc
operator|->
name|features
operator|&
name|AHC_REMOVABLE
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|(
name|intstat
operator|&
name|INT_PEND
operator|)
operator|!=
literal|0
operator|||
operator|(
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SSTAT0
argument_list|)
operator|&
operator|(
name|SELDO
operator||
name|SELINGO
operator|)
operator|)
operator|!=
literal|0
operator|)
condition|)
do|;
if|if
condition|(
name|maxloops
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"Infinite interrupt loop, INTSTAT = %x"
argument_list|,
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|INTSTAT
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|ahc_platform_flushwork
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
name|ahc
operator|->
name|flags
operator|&=
operator|~
name|AHC_ALL_INTERRUPTS
expr_stmt|;
block|}
end_function

begin_function
name|int
name|ahc_suspend
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|)
block|{
name|ahc_pause_and_flushwork
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
if|if
condition|(
name|LIST_FIRST
argument_list|(
operator|&
name|ahc
operator|->
name|pending_scbs
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|ahc_unpause
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
return|return
operator|(
name|EBUSY
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|AHC_TARGET_MODE
comment|/* 	 * XXX What about ATIOs that have not yet been serviced? 	 * Perhaps we should just refuse to be suspended if we 	 * are acting in a target role. 	 */
if|if
condition|(
name|ahc
operator|->
name|pending_device
operator|!=
name|NULL
condition|)
block|{
name|ahc_unpause
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
return|return
operator|(
name|EBUSY
operator|)
return|;
block|}
endif|#
directive|endif
name|ahc_shutdown
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ahc_resume
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|)
block|{
name|ahc_reset
argument_list|(
name|ahc
argument_list|,
comment|/*reinit*/
name|TRUE
argument_list|)
expr_stmt|;
name|ahc_intr_enable
argument_list|(
name|ahc
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|ahc_restart
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/************************** Busy Target Table *********************************/
end_comment

begin_comment
comment|/*  * Return the untagged transaction id for a given target/channel lun.  * Optionally, clear the entry.  */
end_comment

begin_function
name|u_int
name|ahc_index_busy_tcl
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|u_int
name|tcl
parameter_list|)
block|{
name|u_int
name|scbid
decl_stmt|;
name|u_int
name|target_offset
decl_stmt|;
if|if
condition|(
operator|(
name|ahc
operator|->
name|flags
operator|&
name|AHC_SCB_BTT
operator|)
operator|!=
literal|0
condition|)
block|{
name|u_int
name|saved_scbptr
decl_stmt|;
name|saved_scbptr
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCBPTR
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCBPTR
argument_list|,
name|TCL_LUN
argument_list|(
name|tcl
argument_list|)
argument_list|)
expr_stmt|;
name|scbid
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCB_64_BTT
operator|+
name|TCL_TARGET_OFFSET
argument_list|(
name|tcl
argument_list|)
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCBPTR
argument_list|,
name|saved_scbptr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|target_offset
operator|=
name|TCL_TARGET_OFFSET
argument_list|(
name|tcl
argument_list|)
expr_stmt|;
name|scbid
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|BUSY_TARGETS
operator|+
name|target_offset
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|scbid
operator|)
return|;
block|}
end_function

begin_function
name|void
name|ahc_unbusy_tcl
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|u_int
name|tcl
parameter_list|)
block|{
name|u_int
name|target_offset
decl_stmt|;
if|if
condition|(
operator|(
name|ahc
operator|->
name|flags
operator|&
name|AHC_SCB_BTT
operator|)
operator|!=
literal|0
condition|)
block|{
name|u_int
name|saved_scbptr
decl_stmt|;
name|saved_scbptr
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCBPTR
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCBPTR
argument_list|,
name|TCL_LUN
argument_list|(
name|tcl
argument_list|)
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCB_64_BTT
operator|+
name|TCL_TARGET_OFFSET
argument_list|(
name|tcl
argument_list|)
argument_list|,
name|SCB_LIST_NULL
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCBPTR
argument_list|,
name|saved_scbptr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|target_offset
operator|=
name|TCL_TARGET_OFFSET
argument_list|(
name|tcl
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|BUSY_TARGETS
operator|+
name|target_offset
argument_list|,
name|SCB_LIST_NULL
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|ahc_busy_tcl
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|u_int
name|tcl
parameter_list|,
name|u_int
name|scbid
parameter_list|)
block|{
name|u_int
name|target_offset
decl_stmt|;
if|if
condition|(
operator|(
name|ahc
operator|->
name|flags
operator|&
name|AHC_SCB_BTT
operator|)
operator|!=
literal|0
condition|)
block|{
name|u_int
name|saved_scbptr
decl_stmt|;
name|saved_scbptr
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCBPTR
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCBPTR
argument_list|,
name|TCL_LUN
argument_list|(
name|tcl
argument_list|)
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCB_64_BTT
operator|+
name|TCL_TARGET_OFFSET
argument_list|(
name|tcl
argument_list|)
argument_list|,
name|scbid
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCBPTR
argument_list|,
name|saved_scbptr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|target_offset
operator|=
name|TCL_TARGET_OFFSET
argument_list|(
name|tcl
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|BUSY_TARGETS
operator|+
name|target_offset
argument_list|,
name|scbid
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/************************** SCB and SCB queue management **********************/
end_comment

begin_function
name|int
name|ahc_match_scb
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|struct
name|scb
modifier|*
name|scb
parameter_list|,
name|int
name|target
parameter_list|,
name|char
name|channel
parameter_list|,
name|int
name|lun
parameter_list|,
name|u_int
name|tag
parameter_list|,
name|role_t
name|role
parameter_list|)
block|{
name|int
name|targ
init|=
name|SCB_GET_TARGET
argument_list|(
name|ahc
argument_list|,
name|scb
argument_list|)
decl_stmt|;
name|char
name|chan
init|=
name|SCB_GET_CHANNEL
argument_list|(
name|ahc
argument_list|,
name|scb
argument_list|)
decl_stmt|;
name|int
name|slun
init|=
name|SCB_GET_LUN
argument_list|(
name|scb
argument_list|)
decl_stmt|;
name|int
name|match
decl_stmt|;
name|match
operator|=
operator|(
operator|(
name|chan
operator|==
name|channel
operator|)
operator|||
operator|(
name|channel
operator|==
name|ALL_CHANNELS
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|match
operator|!=
literal|0
condition|)
name|match
operator|=
operator|(
operator|(
name|targ
operator|==
name|target
operator|)
operator|||
operator|(
name|target
operator|==
name|CAM_TARGET_WILDCARD
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|match
operator|!=
literal|0
condition|)
name|match
operator|=
operator|(
operator|(
name|lun
operator|==
name|slun
operator|)
operator|||
operator|(
name|lun
operator|==
name|CAM_LUN_WILDCARD
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|match
operator|!=
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|AHC_TARGET_MODE
name|int
name|group
decl_stmt|;
name|group
operator|=
name|XPT_FC_GROUP
argument_list|(
name|scb
operator|->
name|io_ctx
operator|->
name|ccb_h
operator|.
name|func_code
argument_list|)
expr_stmt|;
if|if
condition|(
name|role
operator|==
name|ROLE_INITIATOR
condition|)
block|{
name|match
operator|=
operator|(
name|group
operator|!=
name|XPT_FC_GROUP_TMODE
operator|)
operator|&&
operator|(
operator|(
name|tag
operator|==
name|scb
operator|->
name|hscb
operator|->
name|tag
operator|)
operator|||
operator|(
name|tag
operator|==
name|SCB_LIST_NULL
operator|)
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|role
operator|==
name|ROLE_TARGET
condition|)
block|{
name|match
operator|=
operator|(
name|group
operator|==
name|XPT_FC_GROUP_TMODE
operator|)
operator|&&
operator|(
operator|(
name|tag
operator|==
name|scb
operator|->
name|io_ctx
operator|->
name|csio
operator|.
name|tag_id
operator|)
operator|||
operator|(
name|tag
operator|==
name|SCB_LIST_NULL
operator|)
operator|)
expr_stmt|;
block|}
else|#
directive|else
comment|/* !AHC_TARGET_MODE */
name|match
operator|=
operator|(
operator|(
name|tag
operator|==
name|scb
operator|->
name|hscb
operator|->
name|tag
operator|)
operator|||
operator|(
name|tag
operator|==
name|SCB_LIST_NULL
operator|)
operator|)
expr_stmt|;
endif|#
directive|endif
comment|/* AHC_TARGET_MODE */
block|}
return|return
name|match
return|;
block|}
end_function

begin_function
name|void
name|ahc_freeze_devq
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|struct
name|scb
modifier|*
name|scb
parameter_list|)
block|{
name|int
name|target
decl_stmt|;
name|char
name|channel
decl_stmt|;
name|int
name|lun
decl_stmt|;
name|target
operator|=
name|SCB_GET_TARGET
argument_list|(
name|ahc
argument_list|,
name|scb
argument_list|)
expr_stmt|;
name|lun
operator|=
name|SCB_GET_LUN
argument_list|(
name|scb
argument_list|)
expr_stmt|;
name|channel
operator|=
name|SCB_GET_CHANNEL
argument_list|(
name|ahc
argument_list|,
name|scb
argument_list|)
expr_stmt|;
name|ahc_search_qinfifo
argument_list|(
name|ahc
argument_list|,
name|target
argument_list|,
name|channel
argument_list|,
name|lun
argument_list|,
comment|/*tag*/
name|SCB_LIST_NULL
argument_list|,
name|ROLE_UNKNOWN
argument_list|,
name|CAM_REQUEUE_REQ
argument_list|,
name|SEARCH_COMPLETE
argument_list|)
expr_stmt|;
name|ahc_platform_freeze_devq
argument_list|(
name|ahc
argument_list|,
name|scb
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ahc_qinfifo_requeue_tail
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|struct
name|scb
modifier|*
name|scb
parameter_list|)
block|{
name|struct
name|scb
modifier|*
name|prev_scb
decl_stmt|;
name|prev_scb
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|ahc_qinfifo_count
argument_list|(
name|ahc
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|u_int
name|prev_tag
decl_stmt|;
name|uint8_t
name|prev_pos
decl_stmt|;
name|prev_pos
operator|=
name|ahc
operator|->
name|qinfifonext
operator|-
literal|1
expr_stmt|;
name|prev_tag
operator|=
name|ahc
operator|->
name|qinfifo
index|[
name|prev_pos
index|]
expr_stmt|;
name|prev_scb
operator|=
name|ahc_lookup_scb
argument_list|(
name|ahc
argument_list|,
name|prev_tag
argument_list|)
expr_stmt|;
block|}
name|ahc_qinfifo_requeue
argument_list|(
name|ahc
argument_list|,
name|prev_scb
argument_list|,
name|scb
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ahc
operator|->
name|features
operator|&
name|AHC_QUEUE_REGS
operator|)
operator|!=
literal|0
condition|)
block|{
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|HNSCB_QOFF
argument_list|,
name|ahc
operator|->
name|qinfifonext
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|KERNEL_QINPOS
argument_list|,
name|ahc
operator|->
name|qinfifonext
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ahc_qinfifo_requeue
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|struct
name|scb
modifier|*
name|prev_scb
parameter_list|,
name|struct
name|scb
modifier|*
name|scb
parameter_list|)
block|{
if|if
condition|(
name|prev_scb
operator|==
name|NULL
condition|)
block|{
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|NEXT_QUEUED_SCB
argument_list|,
name|scb
operator|->
name|hscb
operator|->
name|tag
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|prev_scb
operator|->
name|hscb
operator|->
name|next
operator|=
name|scb
operator|->
name|hscb
operator|->
name|tag
expr_stmt|;
name|ahc_sync_scb
argument_list|(
name|ahc
argument_list|,
name|prev_scb
argument_list|,
name|BUS_DMASYNC_PREREAD
operator||
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
block|}
name|ahc
operator|->
name|qinfifo
index|[
name|ahc
operator|->
name|qinfifonext
operator|++
index|]
operator|=
name|scb
operator|->
name|hscb
operator|->
name|tag
expr_stmt|;
name|scb
operator|->
name|hscb
operator|->
name|next
operator|=
name|ahc
operator|->
name|next_queued_scb
operator|->
name|hscb
operator|->
name|tag
expr_stmt|;
name|ahc_sync_scb
argument_list|(
name|ahc
argument_list|,
name|scb
argument_list|,
name|BUS_DMASYNC_PREREAD
operator||
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|ahc_qinfifo_count
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|)
block|{
name|uint8_t
name|qinpos
decl_stmt|;
name|uint8_t
name|diff
decl_stmt|;
if|if
condition|(
operator|(
name|ahc
operator|->
name|features
operator|&
name|AHC_QUEUE_REGS
operator|)
operator|!=
literal|0
condition|)
block|{
name|qinpos
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SNSCB_QOFF
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SNSCB_QOFF
argument_list|,
name|qinpos
argument_list|)
expr_stmt|;
block|}
else|else
name|qinpos
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|QINPOS
argument_list|)
expr_stmt|;
name|diff
operator|=
name|ahc
operator|->
name|qinfifonext
operator|-
name|qinpos
expr_stmt|;
return|return
operator|(
name|diff
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ahc_search_qinfifo
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|int
name|target
parameter_list|,
name|char
name|channel
parameter_list|,
name|int
name|lun
parameter_list|,
name|u_int
name|tag
parameter_list|,
name|role_t
name|role
parameter_list|,
name|uint32_t
name|status
parameter_list|,
name|ahc_search_action
name|action
parameter_list|)
block|{
name|struct
name|scb
modifier|*
name|scb
decl_stmt|;
name|struct
name|scb
modifier|*
name|prev_scb
decl_stmt|;
name|uint8_t
name|qinstart
decl_stmt|;
name|uint8_t
name|qinpos
decl_stmt|;
name|uint8_t
name|qintail
decl_stmt|;
name|uint8_t
name|next
decl_stmt|;
name|uint8_t
name|prev
decl_stmt|;
name|uint8_t
name|curscbptr
decl_stmt|;
name|int
name|found
decl_stmt|;
name|int
name|have_qregs
decl_stmt|;
name|qintail
operator|=
name|ahc
operator|->
name|qinfifonext
expr_stmt|;
name|have_qregs
operator|=
operator|(
name|ahc
operator|->
name|features
operator|&
name|AHC_QUEUE_REGS
operator|)
operator|!=
literal|0
expr_stmt|;
if|if
condition|(
name|have_qregs
condition|)
block|{
name|qinstart
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SNSCB_QOFF
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SNSCB_QOFF
argument_list|,
name|qinstart
argument_list|)
expr_stmt|;
block|}
else|else
name|qinstart
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|QINPOS
argument_list|)
expr_stmt|;
name|qinpos
operator|=
name|qinstart
expr_stmt|;
name|found
operator|=
literal|0
expr_stmt|;
name|prev_scb
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|action
operator|==
name|SEARCH_COMPLETE
condition|)
block|{
comment|/* 		 * Don't attempt to run any queued untagged transactions 		 * until we are done with the abort process. 		 */
name|ahc_freeze_untagged_queues
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Start with an empty queue.  Entries that are not chosen 	 * for removal will be re-added to the queue as we go. 	 */
name|ahc
operator|->
name|qinfifonext
operator|=
name|qinpos
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|NEXT_QUEUED_SCB
argument_list|,
name|ahc
operator|->
name|next_queued_scb
operator|->
name|hscb
operator|->
name|tag
argument_list|)
expr_stmt|;
while|while
condition|(
name|qinpos
operator|!=
name|qintail
condition|)
block|{
name|scb
operator|=
name|ahc_lookup_scb
argument_list|(
name|ahc
argument_list|,
name|ahc
operator|->
name|qinfifo
index|[
name|qinpos
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|scb
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"qinpos = %d, SCB index = %d\n"
argument_list|,
name|qinpos
argument_list|,
name|ahc
operator|->
name|qinfifo
index|[
name|qinpos
index|]
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"Loop 1\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ahc_match_scb
argument_list|(
name|ahc
argument_list|,
name|scb
argument_list|,
name|target
argument_list|,
name|channel
argument_list|,
name|lun
argument_list|,
name|tag
argument_list|,
name|role
argument_list|)
condition|)
block|{
comment|/* 			 * We found an scb that needs to be acted on. 			 */
name|found
operator|++
expr_stmt|;
switch|switch
condition|(
name|action
condition|)
block|{
case|case
name|SEARCH_COMPLETE
case|:
block|{
name|cam_status
name|ostat
decl_stmt|;
name|cam_status
name|cstat
decl_stmt|;
name|ostat
operator|=
name|aic_get_transaction_status
argument_list|(
name|scb
argument_list|)
expr_stmt|;
if|if
condition|(
name|ostat
operator|==
name|CAM_REQ_INPROG
condition|)
name|aic_set_transaction_status
argument_list|(
name|scb
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|cstat
operator|=
name|aic_get_transaction_status
argument_list|(
name|scb
argument_list|)
expr_stmt|;
if|if
condition|(
name|cstat
operator|!=
name|CAM_REQ_CMP
condition|)
name|aic_freeze_scb
argument_list|(
name|scb
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|scb
operator|->
name|flags
operator|&
name|SCB_ACTIVE
operator|)
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"Inactive SCB in qinfifo\n"
argument_list|)
expr_stmt|;
name|ahc_done
argument_list|(
name|ahc
argument_list|,
name|scb
argument_list|)
expr_stmt|;
comment|/* FALLTHROUGH */
block|}
case|case
name|SEARCH_REMOVE
case|:
break|break;
case|case
name|SEARCH_COUNT
case|:
name|ahc_qinfifo_requeue
argument_list|(
name|ahc
argument_list|,
name|prev_scb
argument_list|,
name|scb
argument_list|)
expr_stmt|;
name|prev_scb
operator|=
name|scb
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
name|ahc_qinfifo_requeue
argument_list|(
name|ahc
argument_list|,
name|prev_scb
argument_list|,
name|scb
argument_list|)
expr_stmt|;
name|prev_scb
operator|=
name|scb
expr_stmt|;
block|}
name|qinpos
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|ahc
operator|->
name|features
operator|&
name|AHC_QUEUE_REGS
operator|)
operator|!=
literal|0
condition|)
block|{
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|HNSCB_QOFF
argument_list|,
name|ahc
operator|->
name|qinfifonext
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|KERNEL_QINPOS
argument_list|,
name|ahc
operator|->
name|qinfifonext
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|action
operator|!=
name|SEARCH_COUNT
operator|&&
operator|(
name|found
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|qinstart
operator|!=
name|ahc
operator|->
name|qinfifonext
operator|)
condition|)
block|{
comment|/* 		 * The sequencer may be in the process of dmaing 		 * down the SCB at the beginning of the queue. 		 * This could be problematic if either the first, 		 * or the second SCB is removed from the queue 		 * (the first SCB includes a pointer to the "next" 		 * SCB to dma). If we have removed any entries, swap 		 * the first element in the queue with the next HSCB 		 * so the sequencer will notice that NEXT_QUEUED_SCB 		 * has changed during its dma attempt and will retry 		 * the DMA. 		 */
name|scb
operator|=
name|ahc_lookup_scb
argument_list|(
name|ahc
argument_list|,
name|ahc
operator|->
name|qinfifo
index|[
name|qinstart
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|scb
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"found = %d, qinstart = %d, qinfifionext = %d\n"
argument_list|,
name|found
argument_list|,
name|qinstart
argument_list|,
name|ahc
operator|->
name|qinfifonext
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"First/Second Qinfifo fixup\n"
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * ahc_swap_with_next_hscb forces our next pointer to 		 * point to the reserved SCB for future commands.  Save 		 * and restore our original next pointer to maintain 		 * queue integrity. 		 */
name|next
operator|=
name|scb
operator|->
name|hscb
operator|->
name|next
expr_stmt|;
name|ahc
operator|->
name|scb_data
operator|->
name|scbindex
index|[
name|scb
operator|->
name|hscb
operator|->
name|tag
index|]
operator|=
name|NULL
expr_stmt|;
name|ahc_swap_with_next_hscb
argument_list|(
name|ahc
argument_list|,
name|scb
argument_list|)
expr_stmt|;
name|scb
operator|->
name|hscb
operator|->
name|next
operator|=
name|next
expr_stmt|;
name|ahc
operator|->
name|qinfifo
index|[
name|qinstart
index|]
operator|=
name|scb
operator|->
name|hscb
operator|->
name|tag
expr_stmt|;
comment|/* Tell the card about the new head of the qinfifo. */
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|NEXT_QUEUED_SCB
argument_list|,
name|scb
operator|->
name|hscb
operator|->
name|tag
argument_list|)
expr_stmt|;
comment|/* Fixup the tail "next" pointer. */
name|qintail
operator|=
name|ahc
operator|->
name|qinfifonext
operator|-
literal|1
expr_stmt|;
name|scb
operator|=
name|ahc_lookup_scb
argument_list|(
name|ahc
argument_list|,
name|ahc
operator|->
name|qinfifo
index|[
name|qintail
index|]
argument_list|)
expr_stmt|;
name|scb
operator|->
name|hscb
operator|->
name|next
operator|=
name|ahc
operator|->
name|next_queued_scb
operator|->
name|hscb
operator|->
name|tag
expr_stmt|;
block|}
comment|/* 	 * Search waiting for selection list. 	 */
name|curscbptr
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCBPTR
argument_list|)
expr_stmt|;
name|next
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|WAITING_SCBH
argument_list|)
expr_stmt|;
comment|/* Start at head of list. */
name|prev
operator|=
name|SCB_LIST_NULL
expr_stmt|;
while|while
condition|(
name|next
operator|!=
name|SCB_LIST_NULL
condition|)
block|{
name|uint8_t
name|scb_index
decl_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCBPTR
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|scb_index
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCB_TAG
argument_list|)
expr_stmt|;
if|if
condition|(
name|scb_index
operator|>=
name|ahc
operator|->
name|scb_data
operator|->
name|numscbs
condition|)
block|{
name|printf
argument_list|(
literal|"Waiting List inconsistency. "
literal|"SCB index == %d, yet numscbs == %d."
argument_list|,
name|scb_index
argument_list|,
name|ahc
operator|->
name|scb_data
operator|->
name|numscbs
argument_list|)
expr_stmt|;
name|ahc_dump_card_state
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"for safety"
argument_list|)
expr_stmt|;
block|}
name|scb
operator|=
name|ahc_lookup_scb
argument_list|(
name|ahc
argument_list|,
name|scb_index
argument_list|)
expr_stmt|;
if|if
condition|(
name|scb
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"scb_index = %d, next = %d\n"
argument_list|,
name|scb_index
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"Waiting List traversal\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ahc_match_scb
argument_list|(
name|ahc
argument_list|,
name|scb
argument_list|,
name|target
argument_list|,
name|channel
argument_list|,
name|lun
argument_list|,
name|SCB_LIST_NULL
argument_list|,
name|role
argument_list|)
condition|)
block|{
comment|/* 			 * We found an scb that needs to be acted on. 			 */
name|found
operator|++
expr_stmt|;
switch|switch
condition|(
name|action
condition|)
block|{
case|case
name|SEARCH_COMPLETE
case|:
block|{
name|cam_status
name|ostat
decl_stmt|;
name|cam_status
name|cstat
decl_stmt|;
name|ostat
operator|=
name|aic_get_transaction_status
argument_list|(
name|scb
argument_list|)
expr_stmt|;
if|if
condition|(
name|ostat
operator|==
name|CAM_REQ_INPROG
condition|)
name|aic_set_transaction_status
argument_list|(
name|scb
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|cstat
operator|=
name|aic_get_transaction_status
argument_list|(
name|scb
argument_list|)
expr_stmt|;
if|if
condition|(
name|cstat
operator|!=
name|CAM_REQ_CMP
condition|)
name|aic_freeze_scb
argument_list|(
name|scb
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|scb
operator|->
name|flags
operator|&
name|SCB_ACTIVE
operator|)
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"Inactive SCB in Wait List\n"
argument_list|)
expr_stmt|;
name|ahc_done
argument_list|(
name|ahc
argument_list|,
name|scb
argument_list|)
expr_stmt|;
comment|/* FALLTHROUGH */
block|}
case|case
name|SEARCH_REMOVE
case|:
name|next
operator|=
name|ahc_rem_wscb
argument_list|(
name|ahc
argument_list|,
name|next
argument_list|,
name|prev
argument_list|)
expr_stmt|;
break|break;
case|case
name|SEARCH_COUNT
case|:
name|prev
operator|=
name|next
expr_stmt|;
name|next
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCB_NEXT
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
name|prev
operator|=
name|next
expr_stmt|;
name|next
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCB_NEXT
argument_list|)
expr_stmt|;
block|}
block|}
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCBPTR
argument_list|,
name|curscbptr
argument_list|)
expr_stmt|;
name|found
operator|+=
name|ahc_search_untagged_queues
argument_list|(
name|ahc
argument_list|,
comment|/*aic_io_ctx_t*/
name|NULL
argument_list|,
name|target
argument_list|,
name|channel
argument_list|,
name|lun
argument_list|,
name|status
argument_list|,
name|action
argument_list|)
expr_stmt|;
if|if
condition|(
name|action
operator|==
name|SEARCH_COMPLETE
condition|)
name|ahc_release_untagged_queues
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
return|return
operator|(
name|found
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ahc_search_untagged_queues
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|aic_io_ctx_t
name|ctx
parameter_list|,
name|int
name|target
parameter_list|,
name|char
name|channel
parameter_list|,
name|int
name|lun
parameter_list|,
name|uint32_t
name|status
parameter_list|,
name|ahc_search_action
name|action
parameter_list|)
block|{
name|struct
name|scb
modifier|*
name|scb
decl_stmt|;
name|int
name|maxtarget
decl_stmt|;
name|int
name|found
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|action
operator|==
name|SEARCH_COMPLETE
condition|)
block|{
comment|/* 		 * Don't attempt to run any queued untagged transactions 		 * until we are done with the abort process. 		 */
name|ahc_freeze_untagged_queues
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
block|}
name|found
operator|=
literal|0
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|ahc
operator|->
name|flags
operator|&
name|AHC_SCB_BTT
operator|)
operator|==
literal|0
condition|)
block|{
name|maxtarget
operator|=
literal|16
expr_stmt|;
if|if
condition|(
name|target
operator|!=
name|CAM_TARGET_WILDCARD
condition|)
block|{
name|i
operator|=
name|target
expr_stmt|;
if|if
condition|(
name|channel
operator|==
literal|'B'
condition|)
name|i
operator|+=
literal|8
expr_stmt|;
name|maxtarget
operator|=
name|i
operator|+
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
name|maxtarget
operator|=
literal|0
expr_stmt|;
block|}
for|for
control|(
init|;
name|i
operator|<
name|maxtarget
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|scb_tailq
modifier|*
name|untagged_q
decl_stmt|;
name|struct
name|scb
modifier|*
name|next_scb
decl_stmt|;
name|untagged_q
operator|=
operator|&
operator|(
name|ahc
operator|->
name|untagged_queues
index|[
name|i
index|]
operator|)
expr_stmt|;
name|next_scb
operator|=
name|TAILQ_FIRST
argument_list|(
name|untagged_q
argument_list|)
expr_stmt|;
while|while
condition|(
name|next_scb
operator|!=
name|NULL
condition|)
block|{
name|scb
operator|=
name|next_scb
expr_stmt|;
name|next_scb
operator|=
name|TAILQ_NEXT
argument_list|(
name|scb
argument_list|,
name|links
operator|.
name|tqe
argument_list|)
expr_stmt|;
comment|/* 			 * The head of the list may be the currently 			 * active untagged command for a device. 			 * We're only searching for commands that 			 * have not been started.  A transaction 			 * marked active but still in the qinfifo 			 * is removed by the qinfifo scanning code 			 * above. 			 */
if|if
condition|(
operator|(
name|scb
operator|->
name|flags
operator|&
name|SCB_ACTIVE
operator|)
operator|!=
literal|0
condition|)
continue|continue;
if|if
condition|(
name|ahc_match_scb
argument_list|(
name|ahc
argument_list|,
name|scb
argument_list|,
name|target
argument_list|,
name|channel
argument_list|,
name|lun
argument_list|,
name|SCB_LIST_NULL
argument_list|,
name|ROLE_INITIATOR
argument_list|)
operator|==
literal|0
operator|||
operator|(
name|ctx
operator|!=
name|NULL
operator|&&
name|ctx
operator|!=
name|scb
operator|->
name|io_ctx
operator|)
condition|)
continue|continue;
comment|/* 			 * We found an scb that needs to be acted on. 			 */
name|found
operator|++
expr_stmt|;
switch|switch
condition|(
name|action
condition|)
block|{
case|case
name|SEARCH_COMPLETE
case|:
block|{
name|cam_status
name|ostat
decl_stmt|;
name|cam_status
name|cstat
decl_stmt|;
name|ostat
operator|=
name|aic_get_transaction_status
argument_list|(
name|scb
argument_list|)
expr_stmt|;
if|if
condition|(
name|ostat
operator|==
name|CAM_REQ_INPROG
condition|)
name|aic_set_transaction_status
argument_list|(
name|scb
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|cstat
operator|=
name|aic_get_transaction_status
argument_list|(
name|scb
argument_list|)
expr_stmt|;
if|if
condition|(
name|cstat
operator|!=
name|CAM_REQ_CMP
condition|)
name|aic_freeze_scb
argument_list|(
name|scb
argument_list|)
expr_stmt|;
name|ahc_done
argument_list|(
name|ahc
argument_list|,
name|scb
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|SEARCH_REMOVE
case|:
name|scb
operator|->
name|flags
operator|&=
operator|~
name|SCB_UNTAGGEDQ
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
name|untagged_q
argument_list|,
name|scb
argument_list|,
name|links
operator|.
name|tqe
argument_list|)
expr_stmt|;
break|break;
case|case
name|SEARCH_COUNT
case|:
break|break;
block|}
block|}
block|}
if|if
condition|(
name|action
operator|==
name|SEARCH_COMPLETE
condition|)
name|ahc_release_untagged_queues
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
return|return
operator|(
name|found
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ahc_search_disc_list
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|int
name|target
parameter_list|,
name|char
name|channel
parameter_list|,
name|int
name|lun
parameter_list|,
name|u_int
name|tag
parameter_list|,
name|int
name|stop_on_first
parameter_list|,
name|int
name|remove
parameter_list|,
name|int
name|save_state
parameter_list|)
block|{
name|struct
name|scb
modifier|*
name|scbp
decl_stmt|;
name|u_int
name|next
decl_stmt|;
name|u_int
name|prev
decl_stmt|;
name|u_int
name|count
decl_stmt|;
name|u_int
name|active_scb
decl_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
name|next
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|DISCONNECTED_SCBH
argument_list|)
expr_stmt|;
name|prev
operator|=
name|SCB_LIST_NULL
expr_stmt|;
if|if
condition|(
name|save_state
condition|)
block|{
comment|/* restore this when we're done */
name|active_scb
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCBPTR
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* Silence compiler */
name|active_scb
operator|=
name|SCB_LIST_NULL
expr_stmt|;
while|while
condition|(
name|next
operator|!=
name|SCB_LIST_NULL
condition|)
block|{
name|u_int
name|scb_index
decl_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCBPTR
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|scb_index
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCB_TAG
argument_list|)
expr_stmt|;
if|if
condition|(
name|scb_index
operator|>=
name|ahc
operator|->
name|scb_data
operator|->
name|numscbs
condition|)
block|{
name|printf
argument_list|(
literal|"Disconnected List inconsistency. "
literal|"SCB index == %d, yet numscbs == %d."
argument_list|,
name|scb_index
argument_list|,
name|ahc
operator|->
name|scb_data
operator|->
name|numscbs
argument_list|)
expr_stmt|;
name|ahc_dump_card_state
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"for safety"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|next
operator|==
name|prev
condition|)
block|{
name|panic
argument_list|(
literal|"Disconnected List Loop. "
literal|"cur SCBPTR == %x, prev SCBPTR == %x."
argument_list|,
name|next
argument_list|,
name|prev
argument_list|)
expr_stmt|;
block|}
name|scbp
operator|=
name|ahc_lookup_scb
argument_list|(
name|ahc
argument_list|,
name|scb_index
argument_list|)
expr_stmt|;
if|if
condition|(
name|ahc_match_scb
argument_list|(
name|ahc
argument_list|,
name|scbp
argument_list|,
name|target
argument_list|,
name|channel
argument_list|,
name|lun
argument_list|,
name|tag
argument_list|,
name|ROLE_INITIATOR
argument_list|)
condition|)
block|{
name|count
operator|++
expr_stmt|;
if|if
condition|(
name|remove
condition|)
block|{
name|next
operator|=
name|ahc_rem_scb_from_disc_list
argument_list|(
name|ahc
argument_list|,
name|prev
argument_list|,
name|next
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|prev
operator|=
name|next
expr_stmt|;
name|next
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCB_NEXT
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|stop_on_first
condition|)
break|break;
block|}
else|else
block|{
name|prev
operator|=
name|next
expr_stmt|;
name|next
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCB_NEXT
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|save_state
condition|)
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCBPTR
argument_list|,
name|active_scb
argument_list|)
expr_stmt|;
return|return
operator|(
name|count
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Remove an SCB from the on chip list of disconnected transactions.  * This is empty/unused if we are not performing SCB paging.  */
end_comment

begin_function
specifier|static
name|u_int
name|ahc_rem_scb_from_disc_list
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|u_int
name|prev
parameter_list|,
name|u_int
name|scbptr
parameter_list|)
block|{
name|u_int
name|next
decl_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCBPTR
argument_list|,
name|scbptr
argument_list|)
expr_stmt|;
name|next
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCB_NEXT
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCB_CONTROL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ahc_add_curscb_to_free_list
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
if|if
condition|(
name|prev
operator|!=
name|SCB_LIST_NULL
condition|)
block|{
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCBPTR
argument_list|,
name|prev
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCB_NEXT
argument_list|,
name|next
argument_list|)
expr_stmt|;
block|}
else|else
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|DISCONNECTED_SCBH
argument_list|,
name|next
argument_list|)
expr_stmt|;
return|return
operator|(
name|next
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Add the SCB as selected by SCBPTR onto the on chip list of  * free hardware SCBs.  This list is empty/unused if we are not  * performing SCB paging.  */
end_comment

begin_function
specifier|static
name|void
name|ahc_add_curscb_to_free_list
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|)
block|{
comment|/* 	 * Invalidate the tag so that our abort 	 * routines don't think it's active. 	 */
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCB_TAG
argument_list|,
name|SCB_LIST_NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ahc
operator|->
name|flags
operator|&
name|AHC_PAGESCBS
operator|)
operator|!=
literal|0
condition|)
block|{
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCB_NEXT
argument_list|,
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|FREE_SCBH
argument_list|)
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|FREE_SCBH
argument_list|,
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCBPTR
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Manipulate the waiting for selection list and return the  * scb that follows the one that we remove.  */
end_comment

begin_function
specifier|static
name|u_int
name|ahc_rem_wscb
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|u_int
name|scbpos
parameter_list|,
name|u_int
name|prev
parameter_list|)
block|{
name|u_int
name|curscb
decl_stmt|,
name|next
decl_stmt|;
comment|/* 	 * Select the SCB we want to abort and 	 * pull the next pointer out of it. 	 */
name|curscb
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCBPTR
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCBPTR
argument_list|,
name|scbpos
argument_list|)
expr_stmt|;
name|next
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCB_NEXT
argument_list|)
expr_stmt|;
comment|/* Clear the necessary fields */
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCB_CONTROL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ahc_add_curscb_to_free_list
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
comment|/* update the waiting list */
if|if
condition|(
name|prev
operator|==
name|SCB_LIST_NULL
condition|)
block|{
comment|/* First in the list */
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|WAITING_SCBH
argument_list|,
name|next
argument_list|)
expr_stmt|;
comment|/* 		 * Ensure we aren't attempting to perform 		 * selection for this entry. 		 */
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCSISEQ
argument_list|,
operator|(
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCSISEQ
argument_list|)
operator|&
operator|~
name|ENSELO
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Select the scb that pointed to us  		 * and update its next pointer. 		 */
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCBPTR
argument_list|,
name|prev
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCB_NEXT
argument_list|,
name|next
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Point us back at the original scb position. 	 */
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCBPTR
argument_list|,
name|curscb
argument_list|)
expr_stmt|;
return|return
name|next
return|;
block|}
end_function

begin_comment
comment|/******************************** Error Handling ******************************/
end_comment

begin_comment
comment|/*  * Abort all SCBs that match the given description (target/channel/lun/tag),  * setting their status to the passed in status if the status has not already  * been modified from CAM_REQ_INPROG.  This routine assumes that the sequencer  * is paused before it is called.  */
end_comment

begin_function
name|int
name|ahc_abort_scbs
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|int
name|target
parameter_list|,
name|char
name|channel
parameter_list|,
name|int
name|lun
parameter_list|,
name|u_int
name|tag
parameter_list|,
name|role_t
name|role
parameter_list|,
name|uint32_t
name|status
parameter_list|)
block|{
name|struct
name|scb
modifier|*
name|scbp
decl_stmt|;
name|struct
name|scb
modifier|*
name|scbp_next
decl_stmt|;
name|u_int
name|active_scb
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|int
name|maxtarget
decl_stmt|;
name|int
name|minlun
decl_stmt|;
name|int
name|maxlun
decl_stmt|;
name|int
name|found
decl_stmt|;
comment|/* 	 * Don't attempt to run any queued untagged transactions 	 * until we are done with the abort process. 	 */
name|ahc_freeze_untagged_queues
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
comment|/* restore this when we're done */
name|active_scb
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCBPTR
argument_list|)
expr_stmt|;
name|found
operator|=
name|ahc_search_qinfifo
argument_list|(
name|ahc
argument_list|,
name|target
argument_list|,
name|channel
argument_list|,
name|lun
argument_list|,
name|SCB_LIST_NULL
argument_list|,
name|role
argument_list|,
name|CAM_REQUEUE_REQ
argument_list|,
name|SEARCH_COMPLETE
argument_list|)
expr_stmt|;
comment|/* 	 * Clean out the busy target table for any untagged commands. 	 */
name|i
operator|=
literal|0
expr_stmt|;
name|maxtarget
operator|=
literal|16
expr_stmt|;
if|if
condition|(
name|target
operator|!=
name|CAM_TARGET_WILDCARD
condition|)
block|{
name|i
operator|=
name|target
expr_stmt|;
if|if
condition|(
name|channel
operator|==
literal|'B'
condition|)
name|i
operator|+=
literal|8
expr_stmt|;
name|maxtarget
operator|=
name|i
operator|+
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|lun
operator|==
name|CAM_LUN_WILDCARD
condition|)
block|{
comment|/* 		 * Unless we are using an SCB based 		 * busy targets table, there is only 		 * one table entry for all luns of 		 * a target. 		 */
name|minlun
operator|=
literal|0
expr_stmt|;
name|maxlun
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|ahc
operator|->
name|flags
operator|&
name|AHC_SCB_BTT
operator|)
operator|!=
literal|0
condition|)
name|maxlun
operator|=
name|AHC_NUM_LUNS
expr_stmt|;
block|}
else|else
block|{
name|minlun
operator|=
name|lun
expr_stmt|;
name|maxlun
operator|=
name|lun
operator|+
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|role
operator|!=
name|ROLE_TARGET
condition|)
block|{
for|for
control|(
init|;
name|i
operator|<
name|maxtarget
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
name|minlun
init|;
name|j
operator|<
name|maxlun
condition|;
name|j
operator|++
control|)
block|{
name|u_int
name|scbid
decl_stmt|;
name|u_int
name|tcl
decl_stmt|;
name|tcl
operator|=
name|BUILD_TCL
argument_list|(
name|i
operator|<<
literal|4
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|scbid
operator|=
name|ahc_index_busy_tcl
argument_list|(
name|ahc
argument_list|,
name|tcl
argument_list|)
expr_stmt|;
name|scbp
operator|=
name|ahc_lookup_scb
argument_list|(
name|ahc
argument_list|,
name|scbid
argument_list|)
expr_stmt|;
if|if
condition|(
name|scbp
operator|==
name|NULL
operator|||
name|ahc_match_scb
argument_list|(
name|ahc
argument_list|,
name|scbp
argument_list|,
name|target
argument_list|,
name|channel
argument_list|,
name|lun
argument_list|,
name|tag
argument_list|,
name|role
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
name|ahc_unbusy_tcl
argument_list|(
name|ahc
argument_list|,
name|BUILD_TCL
argument_list|(
name|i
operator|<<
literal|4
argument_list|,
name|j
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 		 * Go through the disconnected list and remove any entries we 		 * have queued for completion, 0'ing their control byte too. 		 * We save the active SCB and restore it ourselves, so there 		 * is no reason for this search to restore it too. 		 */
name|ahc_search_disc_list
argument_list|(
name|ahc
argument_list|,
name|target
argument_list|,
name|channel
argument_list|,
name|lun
argument_list|,
name|tag
argument_list|,
comment|/*stop_on_first*/
name|FALSE
argument_list|,
comment|/*remove*/
name|TRUE
argument_list|,
comment|/*save_state*/
name|FALSE
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Go through the hardware SCB array looking for commands that 	 * were active but not on any list.  In some cases, these remnants 	 * might not still have mappings in the scbindex array (e.g. unexpected 	 * bus free with the same scb queued for an abort).  Don't hold this 	 * against them. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ahc
operator|->
name|scb_data
operator|->
name|maxhscbs
condition|;
name|i
operator|++
control|)
block|{
name|u_int
name|scbid
decl_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCBPTR
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|scbid
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCB_TAG
argument_list|)
expr_stmt|;
name|scbp
operator|=
name|ahc_lookup_scb
argument_list|(
name|ahc
argument_list|,
name|scbid
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|scbp
operator|==
name|NULL
operator|&&
name|scbid
operator|!=
name|SCB_LIST_NULL
operator|)
operator|||
operator|(
name|scbp
operator|!=
name|NULL
operator|&&
name|ahc_match_scb
argument_list|(
name|ahc
argument_list|,
name|scbp
argument_list|,
name|target
argument_list|,
name|channel
argument_list|,
name|lun
argument_list|,
name|tag
argument_list|,
name|role
argument_list|)
operator|)
condition|)
name|ahc_add_curscb_to_free_list
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Go through the pending CCB list and look for 	 * commands for this target that are still active. 	 * These are other tagged commands that were 	 * disconnected when the reset occurred. 	 */
name|scbp_next
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|ahc
operator|->
name|pending_scbs
argument_list|)
expr_stmt|;
while|while
condition|(
name|scbp_next
operator|!=
name|NULL
condition|)
block|{
name|scbp
operator|=
name|scbp_next
expr_stmt|;
name|scbp_next
operator|=
name|LIST_NEXT
argument_list|(
name|scbp
argument_list|,
name|pending_links
argument_list|)
expr_stmt|;
if|if
condition|(
name|ahc_match_scb
argument_list|(
name|ahc
argument_list|,
name|scbp
argument_list|,
name|target
argument_list|,
name|channel
argument_list|,
name|lun
argument_list|,
name|tag
argument_list|,
name|role
argument_list|)
condition|)
block|{
name|cam_status
name|ostat
decl_stmt|;
name|ostat
operator|=
name|aic_get_transaction_status
argument_list|(
name|scbp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ostat
operator|==
name|CAM_REQ_INPROG
condition|)
name|aic_set_transaction_status
argument_list|(
name|scbp
argument_list|,
name|status
argument_list|)
expr_stmt|;
if|if
condition|(
name|aic_get_transaction_status
argument_list|(
name|scbp
argument_list|)
operator|!=
name|CAM_REQ_CMP
condition|)
name|aic_freeze_scb
argument_list|(
name|scbp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|scbp
operator|->
name|flags
operator|&
name|SCB_ACTIVE
operator|)
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"Inactive SCB on pending list\n"
argument_list|)
expr_stmt|;
name|ahc_done
argument_list|(
name|ahc
argument_list|,
name|scbp
argument_list|)
expr_stmt|;
name|found
operator|++
expr_stmt|;
block|}
block|}
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCBPTR
argument_list|,
name|active_scb
argument_list|)
expr_stmt|;
name|ahc_platform_abort_scbs
argument_list|(
name|ahc
argument_list|,
name|target
argument_list|,
name|channel
argument_list|,
name|lun
argument_list|,
name|tag
argument_list|,
name|role
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|ahc_release_untagged_queues
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
return|return
name|found
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ahc_reset_current_bus
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|)
block|{
name|uint8_t
name|scsiseq
decl_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SIMODE1
argument_list|,
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SIMODE1
argument_list|)
operator|&
operator|~
name|ENSCSIRST
argument_list|)
expr_stmt|;
name|scsiseq
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCSISEQ
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCSISEQ
argument_list|,
name|scsiseq
operator||
name|SCSIRSTO
argument_list|)
expr_stmt|;
name|ahc_flush_device_writes
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
name|aic_delay
argument_list|(
name|AHC_BUSRESET_DELAY
argument_list|)
expr_stmt|;
comment|/* Turn off the bus reset */
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCSISEQ
argument_list|,
name|scsiseq
operator|&
operator|~
name|SCSIRSTO
argument_list|)
expr_stmt|;
name|ahc_clear_intstat
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
comment|/* Re-enable reset interrupts */
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SIMODE1
argument_list|,
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SIMODE1
argument_list|)
operator||
name|ENSCSIRST
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|ahc_reset_channel
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|char
name|channel
parameter_list|,
name|int
name|initiate_reset
parameter_list|)
block|{
name|struct
name|ahc_devinfo
name|devinfo
decl_stmt|;
name|u_int
name|initiator
decl_stmt|,
name|target
decl_stmt|,
name|max_scsiid
decl_stmt|;
name|u_int
name|sblkctl
decl_stmt|;
name|u_int
name|scsiseq
decl_stmt|;
name|u_int
name|simode1
decl_stmt|;
name|int
name|found
decl_stmt|;
name|int
name|restart_needed
decl_stmt|;
name|char
name|cur_channel
decl_stmt|;
name|ahc
operator|->
name|pending_device
operator|=
name|NULL
expr_stmt|;
name|ahc_compile_devinfo
argument_list|(
operator|&
name|devinfo
argument_list|,
name|CAM_TARGET_WILDCARD
argument_list|,
name|CAM_TARGET_WILDCARD
argument_list|,
name|CAM_LUN_WILDCARD
argument_list|,
name|channel
argument_list|,
name|ROLE_UNKNOWN
argument_list|)
expr_stmt|;
name|ahc_pause
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
comment|/* Make sure the sequencer is in a safe location. */
name|ahc_clear_critical_section
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
comment|/* 	 * Run our command complete fifos to ensure that we perform 	 * completion processing on any commands that 'completed' 	 * before the reset occurred. 	 */
name|ahc_run_qoutfifo
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|AHC_TARGET_MODE
comment|/* 	 * XXX - In Twin mode, the tqinfifo may have commands 	 *	 for an unaffected channel in it.  However, if 	 *	 we have run out of ATIO resources to drain that 	 *	 queue, we may not get them all out here.  Further, 	 *	 the blocked transactions for the reset channel 	 *	 should just be killed off, irrespecitve of whether 	 *	 we are blocked on ATIO resources.  Write a routine 	 *	 to compact the tqinfifo appropriately. 	 */
if|if
condition|(
operator|(
name|ahc
operator|->
name|flags
operator|&
name|AHC_TARGETROLE
operator|)
operator|!=
literal|0
condition|)
block|{
name|ahc_run_tqinfifo
argument_list|(
name|ahc
argument_list|,
comment|/*paused*/
name|TRUE
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* 	 * Reset the bus if we are initiating this reset 	 */
name|sblkctl
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SBLKCTL
argument_list|)
expr_stmt|;
name|cur_channel
operator|=
literal|'A'
expr_stmt|;
if|if
condition|(
operator|(
name|ahc
operator|->
name|features
operator|&
name|AHC_TWIN
operator|)
operator|!=
literal|0
operator|&&
operator|(
operator|(
name|sblkctl
operator|&
name|SELBUSB
operator|)
operator|!=
literal|0
operator|)
condition|)
name|cur_channel
operator|=
literal|'B'
expr_stmt|;
name|scsiseq
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCSISEQ_TEMPLATE
argument_list|)
expr_stmt|;
if|if
condition|(
name|cur_channel
operator|!=
name|channel
condition|)
block|{
comment|/* Case 1: Command for another bus is active 		 * Stealthily reset the other bus without 		 * upsetting the current bus. 		 */
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SBLKCTL
argument_list|,
name|sblkctl
operator|^
name|SELBUSB
argument_list|)
expr_stmt|;
name|simode1
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SIMODE1
argument_list|)
operator|&
operator|~
operator|(
name|ENBUSFREE
operator||
name|ENSCSIRST
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|AHC_TARGET_MODE
comment|/* 		 * Bus resets clear ENSELI, so we cannot 		 * defer re-enabling bus reset interrupts 		 * if we are in target mode. 		 */
if|if
condition|(
operator|(
name|ahc
operator|->
name|flags
operator|&
name|AHC_TARGETROLE
operator|)
operator|!=
literal|0
condition|)
name|simode1
operator||=
name|ENSCSIRST
expr_stmt|;
endif|#
directive|endif
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SIMODE1
argument_list|,
name|simode1
argument_list|)
expr_stmt|;
if|if
condition|(
name|initiate_reset
condition|)
name|ahc_reset_current_bus
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
name|ahc_clear_intstat
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCSISEQ
argument_list|,
name|scsiseq
operator|&
operator|(
name|ENSELI
operator||
name|ENRSELI
operator||
name|ENAUTOATNP
operator|)
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SBLKCTL
argument_list|,
name|sblkctl
argument_list|)
expr_stmt|;
name|restart_needed
operator|=
name|FALSE
expr_stmt|;
block|}
else|else
block|{
comment|/* Case 2: A command from this bus is active or we're idle */
name|simode1
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SIMODE1
argument_list|)
operator|&
operator|~
operator|(
name|ENBUSFREE
operator||
name|ENSCSIRST
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|AHC_TARGET_MODE
comment|/* 		 * Bus resets clear ENSELI, so we cannot 		 * defer re-enabling bus reset interrupts 		 * if we are in target mode. 		 */
if|if
condition|(
operator|(
name|ahc
operator|->
name|flags
operator|&
name|AHC_TARGETROLE
operator|)
operator|!=
literal|0
condition|)
name|simode1
operator||=
name|ENSCSIRST
expr_stmt|;
endif|#
directive|endif
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SIMODE1
argument_list|,
name|simode1
argument_list|)
expr_stmt|;
if|if
condition|(
name|initiate_reset
condition|)
name|ahc_reset_current_bus
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
name|ahc_clear_intstat
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCSISEQ
argument_list|,
name|scsiseq
operator|&
operator|(
name|ENSELI
operator||
name|ENRSELI
operator||
name|ENAUTOATNP
operator|)
argument_list|)
expr_stmt|;
name|restart_needed
operator|=
name|TRUE
expr_stmt|;
block|}
comment|/* 	 * Clean up all the state information for the 	 * pending transactions on this bus. 	 */
name|found
operator|=
name|ahc_abort_scbs
argument_list|(
name|ahc
argument_list|,
name|CAM_TARGET_WILDCARD
argument_list|,
name|channel
argument_list|,
name|CAM_LUN_WILDCARD
argument_list|,
name|SCB_LIST_NULL
argument_list|,
name|ROLE_UNKNOWN
argument_list|,
name|CAM_SCSI_BUS_RESET
argument_list|)
expr_stmt|;
name|max_scsiid
operator|=
operator|(
name|ahc
operator|->
name|features
operator|&
name|AHC_WIDE
operator|)
condition|?
literal|15
else|:
literal|7
expr_stmt|;
ifdef|#
directive|ifdef
name|AHC_TARGET_MODE
comment|/* 	 * Send an immediate notify ccb to all target more peripheral 	 * drivers affected by this action. 	 */
for|for
control|(
name|target
operator|=
literal|0
init|;
name|target
operator|<=
name|max_scsiid
condition|;
name|target
operator|++
control|)
block|{
name|struct
name|ahc_tmode_tstate
modifier|*
name|tstate
decl_stmt|;
name|u_int
name|lun
decl_stmt|;
name|tstate
operator|=
name|ahc
operator|->
name|enabled_targets
index|[
name|target
index|]
expr_stmt|;
if|if
condition|(
name|tstate
operator|==
name|NULL
condition|)
continue|continue;
for|for
control|(
name|lun
operator|=
literal|0
init|;
name|lun
operator|<
name|AHC_NUM_LUNS
condition|;
name|lun
operator|++
control|)
block|{
name|struct
name|ahc_tmode_lstate
modifier|*
name|lstate
decl_stmt|;
name|lstate
operator|=
name|tstate
operator|->
name|enabled_luns
index|[
name|lun
index|]
expr_stmt|;
if|if
condition|(
name|lstate
operator|==
name|NULL
condition|)
continue|continue;
name|ahc_queue_lstate_event
argument_list|(
name|ahc
argument_list|,
name|lstate
argument_list|,
name|CAM_TARGET_WILDCARD
argument_list|,
name|EVENT_TYPE_BUS_RESET
argument_list|,
comment|/*arg*/
literal|0
argument_list|)
expr_stmt|;
name|ahc_send_lstate_events
argument_list|(
name|ahc
argument_list|,
name|lstate
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* Notify the XPT that a bus reset occurred */
name|ahc_send_async
argument_list|(
name|ahc
argument_list|,
name|devinfo
operator|.
name|channel
argument_list|,
name|CAM_TARGET_WILDCARD
argument_list|,
name|CAM_LUN_WILDCARD
argument_list|,
name|AC_BUS_RESET
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* 	 * Revert to async/narrow transfers until we renegotiate. 	 */
for|for
control|(
name|target
operator|=
literal|0
init|;
name|target
operator|<=
name|max_scsiid
condition|;
name|target
operator|++
control|)
block|{
if|if
condition|(
name|ahc
operator|->
name|enabled_targets
index|[
name|target
index|]
operator|==
name|NULL
condition|)
continue|continue;
for|for
control|(
name|initiator
operator|=
literal|0
init|;
name|initiator
operator|<=
name|max_scsiid
condition|;
name|initiator
operator|++
control|)
block|{
name|struct
name|ahc_devinfo
name|devinfo
decl_stmt|;
name|ahc_compile_devinfo
argument_list|(
operator|&
name|devinfo
argument_list|,
name|target
argument_list|,
name|initiator
argument_list|,
name|CAM_LUN_WILDCARD
argument_list|,
name|channel
argument_list|,
name|ROLE_UNKNOWN
argument_list|)
expr_stmt|;
name|ahc_set_width
argument_list|(
name|ahc
argument_list|,
operator|&
name|devinfo
argument_list|,
name|MSG_EXT_WDTR_BUS_8_BIT
argument_list|,
name|AHC_TRANS_CUR
argument_list|,
comment|/*paused*/
name|TRUE
argument_list|)
expr_stmt|;
name|ahc_set_syncrate
argument_list|(
name|ahc
argument_list|,
operator|&
name|devinfo
argument_list|,
comment|/*syncrate*/
name|NULL
argument_list|,
comment|/*period*/
literal|0
argument_list|,
comment|/*offset*/
literal|0
argument_list|,
comment|/*ppr_options*/
literal|0
argument_list|,
name|AHC_TRANS_CUR
argument_list|,
comment|/*paused*/
name|TRUE
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|restart_needed
condition|)
name|ahc_restart
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
else|else
name|ahc_unpause
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
return|return
name|found
return|;
block|}
end_function

begin_comment
comment|/***************************** Residual Processing ****************************/
end_comment

begin_comment
comment|/*  * Calculate the residual for a just completed SCB.  */
end_comment

begin_function
name|void
name|ahc_calc_residual
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|struct
name|scb
modifier|*
name|scb
parameter_list|)
block|{
name|struct
name|hardware_scb
modifier|*
name|hscb
decl_stmt|;
name|struct
name|status_pkt
modifier|*
name|spkt
decl_stmt|;
name|uint32_t
name|sgptr
decl_stmt|;
name|uint32_t
name|resid_sgptr
decl_stmt|;
name|uint32_t
name|resid
decl_stmt|;
comment|/* 	 * 5 cases. 	 * 1) No residual. 	 *    SG_RESID_VALID clear in sgptr. 	 * 2) Transferless command 	 * 3) Never performed any transfers. 	 *    sgptr has SG_FULL_RESID set. 	 * 4) No residual but target did not 	 *    save data pointers after the 	 *    last transfer, so sgptr was 	 *    never updated. 	 * 5) We have a partial residual. 	 *    Use residual_sgptr to determine 	 *    where we are. 	 */
name|hscb
operator|=
name|scb
operator|->
name|hscb
expr_stmt|;
name|sgptr
operator|=
name|aic_le32toh
argument_list|(
name|hscb
operator|->
name|sgptr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sgptr
operator|&
name|SG_RESID_VALID
operator|)
operator|==
literal|0
condition|)
comment|/* Case 1 */
return|return;
name|sgptr
operator|&=
operator|~
name|SG_RESID_VALID
expr_stmt|;
if|if
condition|(
operator|(
name|sgptr
operator|&
name|SG_LIST_NULL
operator|)
operator|!=
literal|0
condition|)
comment|/* Case 2 */
return|return;
name|spkt
operator|=
operator|&
name|hscb
operator|->
name|shared_data
operator|.
name|status
expr_stmt|;
name|resid_sgptr
operator|=
name|aic_le32toh
argument_list|(
name|spkt
operator|->
name|residual_sg_ptr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sgptr
operator|&
name|SG_FULL_RESID
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* Case 3 */
name|resid
operator|=
name|aic_get_transfer_length
argument_list|(
name|scb
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|resid_sgptr
operator|&
name|SG_LIST_NULL
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* Case 4 */
return|return;
block|}
elseif|else
if|if
condition|(
operator|(
name|resid_sgptr
operator|&
operator|~
name|SG_PTR_MASK
operator|)
operator|!=
literal|0
condition|)
block|{
name|panic
argument_list|(
literal|"Bogus resid sgptr value 0x%x\n"
argument_list|,
name|resid_sgptr
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
return|return;
block|}
else|else
block|{
name|struct
name|ahc_dma_seg
modifier|*
name|sg
decl_stmt|;
comment|/* 		 * Remainder of the SG where the transfer 		 * stopped.   		 */
name|resid
operator|=
name|aic_le32toh
argument_list|(
name|spkt
operator|->
name|residual_datacnt
argument_list|)
operator|&
name|AHC_SG_LEN_MASK
expr_stmt|;
name|sg
operator|=
name|ahc_sg_bus_to_virt
argument_list|(
name|scb
argument_list|,
name|resid_sgptr
operator|&
name|SG_PTR_MASK
argument_list|)
expr_stmt|;
comment|/* The residual sg_ptr always points to the next sg */
name|sg
operator|--
expr_stmt|;
comment|/* 		 * Add up the contents of all residual 		 * SG segments that are after the SG where 		 * the transfer stopped. 		 */
while|while
condition|(
operator|(
name|aic_le32toh
argument_list|(
name|sg
operator|->
name|len
argument_list|)
operator|&
name|AHC_DMA_LAST_SEG
operator|)
operator|==
literal|0
condition|)
block|{
name|sg
operator|++
expr_stmt|;
name|resid
operator|+=
name|aic_le32toh
argument_list|(
name|sg
operator|->
name|len
argument_list|)
operator|&
name|AHC_SG_LEN_MASK
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|scb
operator|->
name|flags
operator|&
name|SCB_SENSE
operator|)
operator|==
literal|0
condition|)
name|aic_set_residual
argument_list|(
name|scb
argument_list|,
name|resid
argument_list|)
expr_stmt|;
else|else
name|aic_set_sense_residual
argument_list|(
name|scb
argument_list|,
name|resid
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|AHC_DEBUG
if|if
condition|(
operator|(
name|ahc_debug
operator|&
name|AHC_SHOW_MISC
operator|)
operator|!=
literal|0
condition|)
block|{
name|ahc_print_path
argument_list|(
name|ahc
argument_list|,
name|scb
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Handled %sResidual of %d bytes\n"
argument_list|,
operator|(
name|scb
operator|->
name|flags
operator|&
name|SCB_SENSE
operator|)
condition|?
literal|"Sense "
else|:
literal|""
argument_list|,
name|resid
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/******************************* Target Mode **********************************/
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|AHC_TARGET_MODE
end_ifdef

begin_comment
comment|/*  * Add a target mode event to this lun's queue  */
end_comment

begin_function
specifier|static
name|void
name|ahc_queue_lstate_event
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|struct
name|ahc_tmode_lstate
modifier|*
name|lstate
parameter_list|,
name|u_int
name|initiator_id
parameter_list|,
name|u_int
name|event_type
parameter_list|,
name|u_int
name|event_arg
parameter_list|)
block|{
name|struct
name|ahc_tmode_event
modifier|*
name|event
decl_stmt|;
name|int
name|pending
decl_stmt|;
name|xpt_freeze_devq
argument_list|(
name|lstate
operator|->
name|path
argument_list|,
comment|/*count*/
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|lstate
operator|->
name|event_w_idx
operator|>=
name|lstate
operator|->
name|event_r_idx
condition|)
name|pending
operator|=
name|lstate
operator|->
name|event_w_idx
operator|-
name|lstate
operator|->
name|event_r_idx
expr_stmt|;
else|else
name|pending
operator|=
name|AHC_TMODE_EVENT_BUFFER_SIZE
operator|+
literal|1
operator|-
operator|(
name|lstate
operator|->
name|event_r_idx
operator|-
name|lstate
operator|->
name|event_w_idx
operator|)
expr_stmt|;
if|if
condition|(
name|event_type
operator|==
name|EVENT_TYPE_BUS_RESET
operator|||
name|event_type
operator|==
name|MSG_BUS_DEV_RESET
condition|)
block|{
comment|/* 		 * Any earlier events are irrelevant, so reset our buffer. 		 * This has the effect of allowing us to deal with reset 		 * floods (an external device holding down the reset line) 		 * without losing the event that is really interesting. 		 */
name|lstate
operator|->
name|event_r_idx
operator|=
literal|0
expr_stmt|;
name|lstate
operator|->
name|event_w_idx
operator|=
literal|0
expr_stmt|;
name|xpt_release_devq
argument_list|(
name|lstate
operator|->
name|path
argument_list|,
name|pending
argument_list|,
comment|/*runqueue*/
name|FALSE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pending
operator|==
name|AHC_TMODE_EVENT_BUFFER_SIZE
condition|)
block|{
name|xpt_print_path
argument_list|(
name|lstate
operator|->
name|path
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"immediate event %x:%x lost\n"
argument_list|,
name|lstate
operator|->
name|event_buffer
index|[
name|lstate
operator|->
name|event_r_idx
index|]
operator|.
name|event_type
argument_list|,
name|lstate
operator|->
name|event_buffer
index|[
name|lstate
operator|->
name|event_r_idx
index|]
operator|.
name|event_arg
argument_list|)
expr_stmt|;
name|lstate
operator|->
name|event_r_idx
operator|++
expr_stmt|;
if|if
condition|(
name|lstate
operator|->
name|event_r_idx
operator|==
name|AHC_TMODE_EVENT_BUFFER_SIZE
condition|)
name|lstate
operator|->
name|event_r_idx
operator|=
literal|0
expr_stmt|;
name|xpt_release_devq
argument_list|(
name|lstate
operator|->
name|path
argument_list|,
comment|/*count*/
literal|1
argument_list|,
comment|/*runqueue*/
name|FALSE
argument_list|)
expr_stmt|;
block|}
name|event
operator|=
operator|&
name|lstate
operator|->
name|event_buffer
index|[
name|lstate
operator|->
name|event_w_idx
index|]
expr_stmt|;
name|event
operator|->
name|initiator_id
operator|=
name|initiator_id
expr_stmt|;
name|event
operator|->
name|event_type
operator|=
name|event_type
expr_stmt|;
name|event
operator|->
name|event_arg
operator|=
name|event_arg
expr_stmt|;
name|lstate
operator|->
name|event_w_idx
operator|++
expr_stmt|;
if|if
condition|(
name|lstate
operator|->
name|event_w_idx
operator|==
name|AHC_TMODE_EVENT_BUFFER_SIZE
condition|)
name|lstate
operator|->
name|event_w_idx
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Send any target mode events queued up waiting  * for immediate notify resources.  */
end_comment

begin_function
name|void
name|ahc_send_lstate_events
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|struct
name|ahc_tmode_lstate
modifier|*
name|lstate
parameter_list|)
block|{
name|struct
name|ccb_hdr
modifier|*
name|ccbh
decl_stmt|;
name|struct
name|ccb_immed_notify
modifier|*
name|inot
decl_stmt|;
while|while
condition|(
name|lstate
operator|->
name|event_r_idx
operator|!=
name|lstate
operator|->
name|event_w_idx
operator|&&
operator|(
name|ccbh
operator|=
name|SLIST_FIRST
argument_list|(
operator|&
name|lstate
operator|->
name|immed_notifies
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|struct
name|ahc_tmode_event
modifier|*
name|event
decl_stmt|;
name|event
operator|=
operator|&
name|lstate
operator|->
name|event_buffer
index|[
name|lstate
operator|->
name|event_r_idx
index|]
expr_stmt|;
name|SLIST_REMOVE_HEAD
argument_list|(
operator|&
name|lstate
operator|->
name|immed_notifies
argument_list|,
name|sim_links
operator|.
name|sle
argument_list|)
expr_stmt|;
name|inot
operator|=
operator|(
expr|struct
name|ccb_immed_notify
operator|*
operator|)
name|ccbh
expr_stmt|;
switch|switch
condition|(
name|event
operator|->
name|event_type
condition|)
block|{
case|case
name|EVENT_TYPE_BUS_RESET
case|:
name|ccbh
operator|->
name|status
operator|=
name|CAM_SCSI_BUS_RESET
operator||
name|CAM_DEV_QFRZN
expr_stmt|;
break|break;
default|default:
name|ccbh
operator|->
name|status
operator|=
name|CAM_MESSAGE_RECV
operator||
name|CAM_DEV_QFRZN
expr_stmt|;
name|inot
operator|->
name|message_args
index|[
literal|0
index|]
operator|=
name|event
operator|->
name|event_type
expr_stmt|;
name|inot
operator|->
name|message_args
index|[
literal|1
index|]
operator|=
name|event
operator|->
name|event_arg
expr_stmt|;
break|break;
block|}
name|inot
operator|->
name|initiator_id
operator|=
name|event
operator|->
name|initiator_id
expr_stmt|;
name|inot
operator|->
name|sense_len
operator|=
literal|0
expr_stmt|;
name|xpt_done
argument_list|(
operator|(
expr|union
name|ccb
operator|*
operator|)
name|inot
argument_list|)
expr_stmt|;
name|lstate
operator|->
name|event_r_idx
operator|++
expr_stmt|;
if|if
condition|(
name|lstate
operator|->
name|event_r_idx
operator|==
name|AHC_TMODE_EVENT_BUFFER_SIZE
condition|)
name|lstate
operator|->
name|event_r_idx
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/******************** Sequencer Program Patching/Download *********************/
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|AHC_DUMP_SEQ
end_ifdef

begin_function
name|void
name|ahc_dumpseq
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SEQCTL
argument_list|,
name|PERRORDIS
operator||
name|FAILDIS
operator||
name|FASTMODE
operator||
name|LOADRAM
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SEQADDR0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SEQADDR1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ahc
operator|->
name|instruction_ram_size
condition|;
name|i
operator|++
control|)
block|{
name|uint8_t
name|ins_bytes
index|[
literal|4
index|]
decl_stmt|;
name|ahc_insb
argument_list|(
name|ahc
argument_list|,
name|SEQRAM
argument_list|,
name|ins_bytes
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"0x%08x\n"
argument_list|,
name|ins_bytes
index|[
literal|0
index|]
operator|<<
literal|24
operator||
name|ins_bytes
index|[
literal|1
index|]
operator|<<
literal|16
operator||
name|ins_bytes
index|[
literal|2
index|]
operator|<<
literal|8
operator||
name|ins_bytes
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|int
name|ahc_loadseq
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|)
block|{
name|struct
name|cs
name|cs_table
index|[
name|num_critical_sections
index|]
decl_stmt|;
name|u_int
name|begin_set
index|[
name|num_critical_sections
index|]
decl_stmt|;
name|u_int
name|end_set
index|[
name|num_critical_sections
index|]
decl_stmt|;
name|struct
name|patch
modifier|*
name|cur_patch
decl_stmt|;
name|u_int
name|cs_count
decl_stmt|;
name|u_int
name|cur_cs
decl_stmt|;
name|u_int
name|i
decl_stmt|;
name|u_int
name|skip_addr
decl_stmt|;
name|u_int
name|sg_prefetch_cnt
decl_stmt|;
name|int
name|downloaded
decl_stmt|;
name|uint8_t
name|download_consts
index|[
literal|7
index|]
decl_stmt|;
comment|/* 	 * Start out with 0 critical sections 	 * that apply to this firmware load. 	 */
name|cs_count
operator|=
literal|0
expr_stmt|;
name|cur_cs
operator|=
literal|0
expr_stmt|;
name|memset
argument_list|(
name|begin_set
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|begin_set
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|end_set
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|end_set
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Setup downloadable constant table */
name|download_consts
index|[
name|QOUTFIFO_OFFSET
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ahc
operator|->
name|targetcmds
operator|!=
name|NULL
condition|)
name|download_consts
index|[
name|QOUTFIFO_OFFSET
index|]
operator|+=
literal|32
expr_stmt|;
name|download_consts
index|[
name|QINFIFO_OFFSET
index|]
operator|=
name|download_consts
index|[
name|QOUTFIFO_OFFSET
index|]
operator|+
literal|1
expr_stmt|;
name|download_consts
index|[
name|CACHESIZE_MASK
index|]
operator|=
name|ahc
operator|->
name|pci_cachesize
operator|-
literal|1
expr_stmt|;
name|download_consts
index|[
name|INVERTED_CACHESIZE_MASK
index|]
operator|=
operator|~
operator|(
name|ahc
operator|->
name|pci_cachesize
operator|-
literal|1
operator|)
expr_stmt|;
name|sg_prefetch_cnt
operator|=
name|ahc
operator|->
name|pci_cachesize
expr_stmt|;
if|if
condition|(
name|sg_prefetch_cnt
operator|<
operator|(
literal|2
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|ahc_dma_seg
argument_list|)
operator|)
condition|)
name|sg_prefetch_cnt
operator|=
literal|2
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|ahc_dma_seg
argument_list|)
expr_stmt|;
name|download_consts
index|[
name|SG_PREFETCH_CNT
index|]
operator|=
name|sg_prefetch_cnt
expr_stmt|;
name|download_consts
index|[
name|SG_PREFETCH_ALIGN_MASK
index|]
operator|=
operator|~
operator|(
name|sg_prefetch_cnt
operator|-
literal|1
operator|)
expr_stmt|;
name|download_consts
index|[
name|SG_PREFETCH_ADDR_MASK
index|]
operator|=
operator|(
name|sg_prefetch_cnt
operator|-
literal|1
operator|)
expr_stmt|;
name|cur_patch
operator|=
name|patches
expr_stmt|;
name|downloaded
operator|=
literal|0
expr_stmt|;
name|skip_addr
operator|=
literal|0
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SEQCTL
argument_list|,
name|PERRORDIS
operator||
name|FAILDIS
operator||
name|FASTMODE
operator||
name|LOADRAM
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SEQADDR0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SEQADDR1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|seqprog
argument_list|)
operator|/
literal|4
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ahc_check_patch
argument_list|(
name|ahc
argument_list|,
operator|&
name|cur_patch
argument_list|,
name|i
argument_list|,
operator|&
name|skip_addr
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* 			 * Don't download this instruction as it 			 * is in a patch that was removed. 			 */
continue|continue;
block|}
if|if
condition|(
name|downloaded
operator|==
name|ahc
operator|->
name|instruction_ram_size
condition|)
block|{
comment|/* 			 * We're about to exceed the instruction 			 * storage capacity for this chip.  Fail 			 * the load. 			 */
name|printf
argument_list|(
literal|"\n%s: Program too large for instruction memory "
literal|"size of %d!\n"
argument_list|,
name|ahc_name
argument_list|(
name|ahc
argument_list|)
argument_list|,
name|ahc
operator|->
name|instruction_ram_size
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
comment|/* 		 * Move through the CS table until we find a CS 		 * that might apply to this instruction. 		 */
for|for
control|(
init|;
name|cur_cs
operator|<
name|num_critical_sections
condition|;
name|cur_cs
operator|++
control|)
block|{
if|if
condition|(
name|critical_sections
index|[
name|cur_cs
index|]
operator|.
name|end
operator|<=
name|i
condition|)
block|{
if|if
condition|(
name|begin_set
index|[
name|cs_count
index|]
operator|==
name|TRUE
operator|&&
name|end_set
index|[
name|cs_count
index|]
operator|==
name|FALSE
condition|)
block|{
name|cs_table
index|[
name|cs_count
index|]
operator|.
name|end
operator|=
name|downloaded
expr_stmt|;
name|end_set
index|[
name|cs_count
index|]
operator|=
name|TRUE
expr_stmt|;
name|cs_count
operator|++
expr_stmt|;
block|}
continue|continue;
block|}
if|if
condition|(
name|critical_sections
index|[
name|cur_cs
index|]
operator|.
name|begin
operator|<=
name|i
operator|&&
name|begin_set
index|[
name|cs_count
index|]
operator|==
name|FALSE
condition|)
block|{
name|cs_table
index|[
name|cs_count
index|]
operator|.
name|begin
operator|=
name|downloaded
expr_stmt|;
name|begin_set
index|[
name|cs_count
index|]
operator|=
name|TRUE
expr_stmt|;
block|}
break|break;
block|}
name|ahc_download_instr
argument_list|(
name|ahc
argument_list|,
name|i
argument_list|,
name|download_consts
argument_list|)
expr_stmt|;
name|downloaded
operator|++
expr_stmt|;
block|}
name|ahc
operator|->
name|num_critical_sections
operator|=
name|cs_count
expr_stmt|;
if|if
condition|(
name|cs_count
operator|!=
literal|0
condition|)
block|{
name|cs_count
operator|*=
sizeof|sizeof
argument_list|(
expr|struct
name|cs
argument_list|)
expr_stmt|;
name|ahc
operator|->
name|critical_sections
operator|=
name|malloc
argument_list|(
name|cs_count
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|ahc
operator|->
name|critical_sections
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"ahc_loadseq: Could not malloc"
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|ahc
operator|->
name|critical_sections
argument_list|,
name|cs_table
argument_list|,
name|cs_count
argument_list|)
expr_stmt|;
block|}
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SEQCTL
argument_list|,
name|PERRORDIS
operator||
name|FAILDIS
operator||
name|FASTMODE
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
block|{
name|printf
argument_list|(
literal|" %d instructions downloaded\n"
argument_list|,
name|downloaded
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s: Features 0x%x, Bugs 0x%x, Flags 0x%x\n"
argument_list|,
name|ahc_name
argument_list|(
name|ahc
argument_list|)
argument_list|,
name|ahc
operator|->
name|features
argument_list|,
name|ahc
operator|->
name|bugs
argument_list|,
name|ahc
operator|->
name|flags
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ahc_check_patch
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|struct
name|patch
modifier|*
modifier|*
name|start_patch
parameter_list|,
name|u_int
name|start_instr
parameter_list|,
name|u_int
modifier|*
name|skip_addr
parameter_list|)
block|{
name|struct
name|patch
modifier|*
name|cur_patch
decl_stmt|;
name|struct
name|patch
modifier|*
name|last_patch
decl_stmt|;
name|u_int
name|num_patches
decl_stmt|;
name|num_patches
operator|=
sizeof|sizeof
argument_list|(
name|patches
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|patch
argument_list|)
expr_stmt|;
name|last_patch
operator|=
operator|&
name|patches
index|[
name|num_patches
index|]
expr_stmt|;
name|cur_patch
operator|=
operator|*
name|start_patch
expr_stmt|;
while|while
condition|(
name|cur_patch
operator|<
name|last_patch
operator|&&
name|start_instr
operator|==
name|cur_patch
operator|->
name|begin
condition|)
block|{
if|if
condition|(
name|cur_patch
operator|->
name|patch_func
argument_list|(
name|ahc
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Start rejecting code */
operator|*
name|skip_addr
operator|=
name|start_instr
operator|+
name|cur_patch
operator|->
name|skip_instr
expr_stmt|;
name|cur_patch
operator|+=
name|cur_patch
operator|->
name|skip_patch
expr_stmt|;
block|}
else|else
block|{
comment|/* Accepted this patch.  Advance to the next 			 * one and wait for our intruction pointer to 			 * hit this point. 			 */
name|cur_patch
operator|++
expr_stmt|;
block|}
block|}
operator|*
name|start_patch
operator|=
name|cur_patch
expr_stmt|;
if|if
condition|(
name|start_instr
operator|<
operator|*
name|skip_addr
condition|)
comment|/* Still skipping */
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ahc_download_instr
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|u_int
name|instrptr
parameter_list|,
name|uint8_t
modifier|*
name|dconsts
parameter_list|)
block|{
name|union
name|ins_formats
name|instr
decl_stmt|;
name|struct
name|ins_format1
modifier|*
name|fmt1_ins
decl_stmt|;
name|struct
name|ins_format3
modifier|*
name|fmt3_ins
decl_stmt|;
name|u_int
name|opcode
decl_stmt|;
comment|/* 	 * The firmware is always compiled into a little endian format. 	 */
name|instr
operator|.
name|integer
operator|=
name|aic_le32toh
argument_list|(
operator|*
operator|(
name|uint32_t
operator|*
operator|)
operator|&
name|seqprog
index|[
name|instrptr
operator|*
literal|4
index|]
argument_list|)
expr_stmt|;
name|fmt1_ins
operator|=
operator|&
name|instr
operator|.
name|format1
expr_stmt|;
name|fmt3_ins
operator|=
name|NULL
expr_stmt|;
comment|/* Pull the opcode */
name|opcode
operator|=
name|instr
operator|.
name|format1
operator|.
name|opcode
expr_stmt|;
switch|switch
condition|(
name|opcode
condition|)
block|{
case|case
name|AIC_OP_JMP
case|:
case|case
name|AIC_OP_JC
case|:
case|case
name|AIC_OP_JNC
case|:
case|case
name|AIC_OP_CALL
case|:
case|case
name|AIC_OP_JNE
case|:
case|case
name|AIC_OP_JNZ
case|:
case|case
name|AIC_OP_JE
case|:
case|case
name|AIC_OP_JZ
case|:
block|{
name|struct
name|patch
modifier|*
name|cur_patch
decl_stmt|;
name|int
name|address_offset
decl_stmt|;
name|u_int
name|address
decl_stmt|;
name|u_int
name|skip_addr
decl_stmt|;
name|u_int
name|i
decl_stmt|;
name|fmt3_ins
operator|=
operator|&
name|instr
operator|.
name|format3
expr_stmt|;
name|address_offset
operator|=
literal|0
expr_stmt|;
name|address
operator|=
name|fmt3_ins
operator|->
name|address
expr_stmt|;
name|cur_patch
operator|=
name|patches
expr_stmt|;
name|skip_addr
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|address
condition|;
control|)
block|{
name|ahc_check_patch
argument_list|(
name|ahc
argument_list|,
operator|&
name|cur_patch
argument_list|,
name|i
argument_list|,
operator|&
name|skip_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|skip_addr
operator|>
name|i
condition|)
block|{
name|int
name|end_addr
decl_stmt|;
name|end_addr
operator|=
name|MIN
argument_list|(
name|address
argument_list|,
name|skip_addr
argument_list|)
expr_stmt|;
name|address_offset
operator|+=
name|end_addr
operator|-
name|i
expr_stmt|;
name|i
operator|=
name|skip_addr
expr_stmt|;
block|}
else|else
block|{
name|i
operator|++
expr_stmt|;
block|}
block|}
name|address
operator|-=
name|address_offset
expr_stmt|;
name|fmt3_ins
operator|->
name|address
operator|=
name|address
expr_stmt|;
comment|/* FALLTHROUGH */
block|}
case|case
name|AIC_OP_OR
case|:
case|case
name|AIC_OP_AND
case|:
case|case
name|AIC_OP_XOR
case|:
case|case
name|AIC_OP_ADD
case|:
case|case
name|AIC_OP_ADC
case|:
case|case
name|AIC_OP_BMOV
case|:
if|if
condition|(
name|fmt1_ins
operator|->
name|parity
operator|!=
literal|0
condition|)
block|{
name|fmt1_ins
operator|->
name|immediate
operator|=
name|dconsts
index|[
name|fmt1_ins
operator|->
name|immediate
index|]
expr_stmt|;
block|}
name|fmt1_ins
operator|->
name|parity
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|ahc
operator|->
name|features
operator|&
name|AHC_CMD_CHAN
operator|)
operator|==
literal|0
operator|&&
name|opcode
operator|==
name|AIC_OP_BMOV
condition|)
block|{
comment|/* 			 * Block move was added at the same time 			 * as the command channel.  Verify that 			 * this is only a move of a single element 			 * and convert the BMOV to a MOV 			 * (AND with an immediate of FF). 			 */
if|if
condition|(
name|fmt1_ins
operator|->
name|immediate
operator|!=
literal|1
condition|)
name|panic
argument_list|(
literal|"%s: BMOV not supported\n"
argument_list|,
name|ahc_name
argument_list|(
name|ahc
argument_list|)
argument_list|)
expr_stmt|;
name|fmt1_ins
operator|->
name|opcode
operator|=
name|AIC_OP_AND
expr_stmt|;
name|fmt1_ins
operator|->
name|immediate
operator|=
literal|0xff
expr_stmt|;
block|}
comment|/* FALLTHROUGH */
case|case
name|AIC_OP_ROL
case|:
if|if
condition|(
operator|(
name|ahc
operator|->
name|features
operator|&
name|AHC_ULTRA2
operator|)
operator|!=
literal|0
condition|)
block|{
name|int
name|i
decl_stmt|,
name|count
decl_stmt|;
comment|/* Calculate odd parity for the instruction */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|count
operator|=
literal|0
init|;
name|i
operator|<
literal|31
condition|;
name|i
operator|++
control|)
block|{
name|uint32_t
name|mask
decl_stmt|;
name|mask
operator|=
literal|0x01
operator|<<
name|i
expr_stmt|;
if|if
condition|(
operator|(
name|instr
operator|.
name|integer
operator|&
name|mask
operator|)
operator|!=
literal|0
condition|)
name|count
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|count
operator|&
literal|0x01
operator|)
operator|==
literal|0
condition|)
name|instr
operator|.
name|format1
operator|.
name|parity
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* Compress the instruction for older sequencers */
if|if
condition|(
name|fmt3_ins
operator|!=
name|NULL
condition|)
block|{
name|instr
operator|.
name|integer
operator|=
name|fmt3_ins
operator|->
name|immediate
operator||
operator|(
name|fmt3_ins
operator|->
name|source
operator|<<
literal|8
operator|)
operator||
operator|(
name|fmt3_ins
operator|->
name|address
operator|<<
literal|16
operator|)
operator||
operator|(
name|fmt3_ins
operator|->
name|opcode
operator|<<
literal|25
operator|)
expr_stmt|;
block|}
else|else
block|{
name|instr
operator|.
name|integer
operator|=
name|fmt1_ins
operator|->
name|immediate
operator||
operator|(
name|fmt1_ins
operator|->
name|source
operator|<<
literal|8
operator|)
operator||
operator|(
name|fmt1_ins
operator|->
name|destination
operator|<<
literal|16
operator|)
operator||
operator|(
name|fmt1_ins
operator|->
name|ret
operator|<<
literal|24
operator|)
operator||
operator|(
name|fmt1_ins
operator|->
name|opcode
operator|<<
literal|25
operator|)
expr_stmt|;
block|}
block|}
comment|/* The sequencer is a little endian cpu */
name|instr
operator|.
name|integer
operator|=
name|aic_htole32
argument_list|(
name|instr
operator|.
name|integer
argument_list|)
expr_stmt|;
name|ahc_outsb
argument_list|(
name|ahc
argument_list|,
name|SEQRAM
argument_list|,
name|instr
operator|.
name|bytes
argument_list|,
literal|4
argument_list|)
expr_stmt|;
break|break;
default|default:
name|panic
argument_list|(
literal|"Unknown opcode encountered in seq program"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
name|int
name|ahc_print_register
parameter_list|(
name|ahc_reg_parse_entry_t
modifier|*
name|table
parameter_list|,
name|u_int
name|num_entries
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|u_int
name|address
parameter_list|,
name|u_int
name|value
parameter_list|,
name|u_int
modifier|*
name|cur_column
parameter_list|,
name|u_int
name|wrap_point
parameter_list|)
block|{
name|int
name|printed
decl_stmt|;
name|u_int
name|printed_mask
decl_stmt|;
name|u_int
name|dummy_column
decl_stmt|;
if|if
condition|(
name|cur_column
operator|==
name|NULL
condition|)
block|{
name|dummy_column
operator|=
literal|0
expr_stmt|;
name|cur_column
operator|=
operator|&
name|dummy_column
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|cur_column
operator|>=
name|wrap_point
condition|)
block|{
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
operator|*
name|cur_column
operator|=
literal|0
expr_stmt|;
block|}
name|printed
operator|=
name|printf
argument_list|(
literal|"%s[0x%x]"
argument_list|,
name|name
argument_list|,
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|table
operator|==
name|NULL
condition|)
block|{
name|printed
operator|+=
name|printf
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
operator|*
name|cur_column
operator|+=
name|printed
expr_stmt|;
return|return
operator|(
name|printed
operator|)
return|;
block|}
name|printed_mask
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|printed_mask
operator|!=
literal|0xFF
condition|)
block|{
name|int
name|entry
decl_stmt|;
for|for
control|(
name|entry
operator|=
literal|0
init|;
name|entry
operator|<
name|num_entries
condition|;
name|entry
operator|++
control|)
block|{
if|if
condition|(
operator|(
operator|(
name|value
operator|&
name|table
index|[
name|entry
index|]
operator|.
name|mask
operator|)
operator|!=
name|table
index|[
name|entry
index|]
operator|.
name|value
operator|)
operator|||
operator|(
operator|(
name|printed_mask
operator|&
name|table
index|[
name|entry
index|]
operator|.
name|mask
operator|)
operator|==
name|table
index|[
name|entry
index|]
operator|.
name|mask
operator|)
condition|)
continue|continue;
name|printed
operator|+=
name|printf
argument_list|(
literal|"%s%s"
argument_list|,
name|printed_mask
operator|==
literal|0
condition|?
literal|":("
else|:
literal|"|"
argument_list|,
name|table
index|[
name|entry
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
name|printed_mask
operator||=
name|table
index|[
name|entry
index|]
operator|.
name|mask
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|entry
operator|>=
name|num_entries
condition|)
break|break;
block|}
if|if
condition|(
name|printed_mask
operator|!=
literal|0
condition|)
name|printed
operator|+=
name|printf
argument_list|(
literal|") "
argument_list|)
expr_stmt|;
else|else
name|printed
operator|+=
name|printf
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
if|if
condition|(
name|cur_column
operator|!=
name|NULL
condition|)
operator|*
name|cur_column
operator|+=
name|printed
expr_stmt|;
return|return
operator|(
name|printed
operator|)
return|;
block|}
end_function

begin_function
name|void
name|ahc_dump_card_state
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|)
block|{
name|struct
name|scb
modifier|*
name|scb
decl_stmt|;
name|struct
name|scb_tailq
modifier|*
name|untagged_q
decl_stmt|;
name|u_int
name|cur_col
decl_stmt|;
name|int
name|paused
decl_stmt|;
name|int
name|target
decl_stmt|;
name|int
name|maxtarget
decl_stmt|;
name|int
name|i
decl_stmt|;
name|uint8_t
name|last_phase
decl_stmt|;
name|uint8_t
name|qinpos
decl_stmt|;
name|uint8_t
name|qintail
decl_stmt|;
name|uint8_t
name|qoutpos
decl_stmt|;
name|uint8_t
name|scb_index
decl_stmt|;
name|uint8_t
name|saved_scbptr
decl_stmt|;
if|if
condition|(
name|ahc_is_paused
argument_list|(
name|ahc
argument_list|)
condition|)
block|{
name|paused
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|paused
operator|=
literal|0
expr_stmt|;
name|ahc_pause
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
block|}
name|saved_scbptr
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCBPTR
argument_list|)
expr_stmt|;
name|last_phase
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|LASTPHASE
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|">>>>>>>>>>>>>>>>>> Dump Card State Begins<<<<<<<<<<<<<<<<<\n"
literal|"%s: Dumping Card State %s, at SEQADDR 0x%x\n"
argument_list|,
name|ahc_name
argument_list|(
name|ahc
argument_list|)
argument_list|,
name|ahc_lookup_phase_entry
argument_list|(
name|last_phase
argument_list|)
operator|->
name|phasemsg
argument_list|,
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SEQADDR0
argument_list|)
operator||
operator|(
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SEQADDR1
argument_list|)
operator|<<
literal|8
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|paused
condition|)
name|printf
argument_list|(
literal|"Card was paused\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"ACCUM = 0x%x, SINDEX = 0x%x, DINDEX = 0x%x, ARG_2 = 0x%x\n"
argument_list|,
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|ACCUM
argument_list|)
argument_list|,
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SINDEX
argument_list|)
argument_list|,
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|DINDEX
argument_list|)
argument_list|,
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|ARG_2
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"HCNT = 0x%x SCBPTR = 0x%x\n"
argument_list|,
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|HCNT
argument_list|)
argument_list|,
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCBPTR
argument_list|)
argument_list|)
expr_stmt|;
name|cur_col
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|ahc
operator|->
name|features
operator|&
name|AHC_DT
operator|)
operator|!=
literal|0
condition|)
name|ahc_scsiphase_print
argument_list|(
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCSIPHASE
argument_list|)
argument_list|,
operator|&
name|cur_col
argument_list|,
literal|50
argument_list|)
expr_stmt|;
name|ahc_scsisigi_print
argument_list|(
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCSISIGI
argument_list|)
argument_list|,
operator|&
name|cur_col
argument_list|,
literal|50
argument_list|)
expr_stmt|;
name|ahc_error_print
argument_list|(
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|ERROR
argument_list|)
argument_list|,
operator|&
name|cur_col
argument_list|,
literal|50
argument_list|)
expr_stmt|;
name|ahc_scsibusl_print
argument_list|(
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCSIBUSL
argument_list|)
argument_list|,
operator|&
name|cur_col
argument_list|,
literal|50
argument_list|)
expr_stmt|;
name|ahc_lastphase_print
argument_list|(
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|LASTPHASE
argument_list|)
argument_list|,
operator|&
name|cur_col
argument_list|,
literal|50
argument_list|)
expr_stmt|;
name|ahc_scsiseq_print
argument_list|(
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCSISEQ
argument_list|)
argument_list|,
operator|&
name|cur_col
argument_list|,
literal|50
argument_list|)
expr_stmt|;
name|ahc_sblkctl_print
argument_list|(
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SBLKCTL
argument_list|)
argument_list|,
operator|&
name|cur_col
argument_list|,
literal|50
argument_list|)
expr_stmt|;
name|ahc_scsirate_print
argument_list|(
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCSIRATE
argument_list|)
argument_list|,
operator|&
name|cur_col
argument_list|,
literal|50
argument_list|)
expr_stmt|;
name|ahc_seqctl_print
argument_list|(
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SEQCTL
argument_list|)
argument_list|,
operator|&
name|cur_col
argument_list|,
literal|50
argument_list|)
expr_stmt|;
name|ahc_seq_flags_print
argument_list|(
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SEQ_FLAGS
argument_list|)
argument_list|,
operator|&
name|cur_col
argument_list|,
literal|50
argument_list|)
expr_stmt|;
name|ahc_sstat0_print
argument_list|(
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SSTAT0
argument_list|)
argument_list|,
operator|&
name|cur_col
argument_list|,
literal|50
argument_list|)
expr_stmt|;
name|ahc_sstat1_print
argument_list|(
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SSTAT1
argument_list|)
argument_list|,
operator|&
name|cur_col
argument_list|,
literal|50
argument_list|)
expr_stmt|;
name|ahc_sstat2_print
argument_list|(
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SSTAT2
argument_list|)
argument_list|,
operator|&
name|cur_col
argument_list|,
literal|50
argument_list|)
expr_stmt|;
name|ahc_sstat3_print
argument_list|(
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SSTAT3
argument_list|)
argument_list|,
operator|&
name|cur_col
argument_list|,
literal|50
argument_list|)
expr_stmt|;
name|ahc_simode0_print
argument_list|(
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SIMODE0
argument_list|)
argument_list|,
operator|&
name|cur_col
argument_list|,
literal|50
argument_list|)
expr_stmt|;
name|ahc_simode1_print
argument_list|(
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SIMODE1
argument_list|)
argument_list|,
operator|&
name|cur_col
argument_list|,
literal|50
argument_list|)
expr_stmt|;
name|ahc_sxfrctl0_print
argument_list|(
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SXFRCTL0
argument_list|)
argument_list|,
operator|&
name|cur_col
argument_list|,
literal|50
argument_list|)
expr_stmt|;
name|ahc_dfcntrl_print
argument_list|(
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|DFCNTRL
argument_list|)
argument_list|,
operator|&
name|cur_col
argument_list|,
literal|50
argument_list|)
expr_stmt|;
name|ahc_dfstatus_print
argument_list|(
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|DFSTATUS
argument_list|)
argument_list|,
operator|&
name|cur_col
argument_list|,
literal|50
argument_list|)
expr_stmt|;
if|if
condition|(
name|cur_col
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"STACK:"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|STACK_SIZE
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|" 0x%x"
argument_list|,
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|STACK
argument_list|)
operator||
operator|(
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|STACK
argument_list|)
operator|<<
literal|8
operator|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\nSCB count = %d\n"
argument_list|,
name|ahc
operator|->
name|scb_data
operator|->
name|numscbs
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Kernel NEXTQSCB = %d\n"
argument_list|,
name|ahc
operator|->
name|next_queued_scb
operator|->
name|hscb
operator|->
name|tag
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Card NEXTQSCB = %d\n"
argument_list|,
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|NEXT_QUEUED_SCB
argument_list|)
argument_list|)
expr_stmt|;
comment|/* QINFIFO */
name|printf
argument_list|(
literal|"QINFIFO entries: "
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ahc
operator|->
name|features
operator|&
name|AHC_QUEUE_REGS
operator|)
operator|!=
literal|0
condition|)
block|{
name|qinpos
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SNSCB_QOFF
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SNSCB_QOFF
argument_list|,
name|qinpos
argument_list|)
expr_stmt|;
block|}
else|else
name|qinpos
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|QINPOS
argument_list|)
expr_stmt|;
name|qintail
operator|=
name|ahc
operator|->
name|qinfifonext
expr_stmt|;
while|while
condition|(
name|qinpos
operator|!=
name|qintail
condition|)
block|{
name|printf
argument_list|(
literal|"%d "
argument_list|,
name|ahc
operator|->
name|qinfifo
index|[
name|qinpos
index|]
argument_list|)
expr_stmt|;
name|qinpos
operator|++
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Waiting Queue entries: "
argument_list|)
expr_stmt|;
name|scb_index
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|WAITING_SCBH
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|scb_index
operator|!=
name|SCB_LIST_NULL
operator|&&
name|i
operator|++
operator|<
literal|256
condition|)
block|{
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCBPTR
argument_list|,
name|scb_index
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%d:%d "
argument_list|,
name|scb_index
argument_list|,
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCB_TAG
argument_list|)
argument_list|)
expr_stmt|;
name|scb_index
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCB_NEXT
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Disconnected Queue entries: "
argument_list|)
expr_stmt|;
name|scb_index
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|DISCONNECTED_SCBH
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|scb_index
operator|!=
name|SCB_LIST_NULL
operator|&&
name|i
operator|++
operator|<
literal|256
condition|)
block|{
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCBPTR
argument_list|,
name|scb_index
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%d:%d "
argument_list|,
name|scb_index
argument_list|,
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCB_TAG
argument_list|)
argument_list|)
expr_stmt|;
name|scb_index
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCB_NEXT
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|ahc_sync_qoutfifo
argument_list|(
name|ahc
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"QOUTFIFO entries: "
argument_list|)
expr_stmt|;
name|qoutpos
operator|=
name|ahc
operator|->
name|qoutfifonext
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|ahc
operator|->
name|qoutfifo
index|[
name|qoutpos
index|]
operator|!=
name|SCB_LIST_NULL
operator|&&
name|i
operator|++
operator|<
literal|256
condition|)
block|{
name|printf
argument_list|(
literal|"%d "
argument_list|,
name|ahc
operator|->
name|qoutfifo
index|[
name|qoutpos
index|]
argument_list|)
expr_stmt|;
name|qoutpos
operator|++
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Sequencer Free SCB List: "
argument_list|)
expr_stmt|;
name|scb_index
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|FREE_SCBH
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|scb_index
operator|!=
name|SCB_LIST_NULL
operator|&&
name|i
operator|++
operator|<
literal|256
condition|)
block|{
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCBPTR
argument_list|,
name|scb_index
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%d "
argument_list|,
name|scb_index
argument_list|)
expr_stmt|;
name|scb_index
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCB_NEXT
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Sequencer SCB Info: "
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ahc
operator|->
name|scb_data
operator|->
name|maxhscbs
condition|;
name|i
operator|++
control|)
block|{
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCBPTR
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|cur_col
operator|=
name|printf
argument_list|(
literal|"\n%3d "
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|ahc_scb_control_print
argument_list|(
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCB_CONTROL
argument_list|)
argument_list|,
operator|&
name|cur_col
argument_list|,
literal|60
argument_list|)
expr_stmt|;
name|ahc_scb_scsiid_print
argument_list|(
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCB_SCSIID
argument_list|)
argument_list|,
operator|&
name|cur_col
argument_list|,
literal|60
argument_list|)
expr_stmt|;
name|ahc_scb_lun_print
argument_list|(
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCB_LUN
argument_list|)
argument_list|,
operator|&
name|cur_col
argument_list|,
literal|60
argument_list|)
expr_stmt|;
name|ahc_scb_tag_print
argument_list|(
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCB_TAG
argument_list|)
argument_list|,
operator|&
name|cur_col
argument_list|,
literal|60
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Pending list: "
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|scb
argument_list|,
argument|&ahc->pending_scbs
argument_list|,
argument|pending_links
argument_list|)
block|{
if|if
condition|(
name|i
operator|++
operator|>
literal|256
condition|)
break|break;
name|cur_col
operator|=
name|printf
argument_list|(
literal|"\n%3d "
argument_list|,
name|scb
operator|->
name|hscb
operator|->
name|tag
argument_list|)
expr_stmt|;
name|ahc_scb_control_print
argument_list|(
name|scb
operator|->
name|hscb
operator|->
name|control
argument_list|,
operator|&
name|cur_col
argument_list|,
literal|60
argument_list|)
expr_stmt|;
name|ahc_scb_scsiid_print
argument_list|(
name|scb
operator|->
name|hscb
operator|->
name|scsiid
argument_list|,
operator|&
name|cur_col
argument_list|,
literal|60
argument_list|)
expr_stmt|;
name|ahc_scb_lun_print
argument_list|(
name|scb
operator|->
name|hscb
operator|->
name|lun
argument_list|,
operator|&
name|cur_col
argument_list|,
literal|60
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ahc
operator|->
name|flags
operator|&
name|AHC_PAGESCBS
operator|)
operator|==
literal|0
condition|)
block|{
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCBPTR
argument_list|,
name|scb
operator|->
name|hscb
operator|->
name|tag
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"("
argument_list|)
expr_stmt|;
name|ahc_scb_control_print
argument_list|(
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCB_CONTROL
argument_list|)
argument_list|,
operator|&
name|cur_col
argument_list|,
literal|60
argument_list|)
expr_stmt|;
name|ahc_scb_tag_print
argument_list|(
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCB_TAG
argument_list|)
argument_list|,
operator|&
name|cur_col
argument_list|,
literal|60
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|")"
argument_list|)
expr_stmt|;
block|}
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Kernel Free SCB list: "
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
name|SLIST_FOREACH
argument_list|(
argument|scb
argument_list|,
argument|&ahc->scb_data->free_scbs
argument_list|,
argument|links.sle
argument_list|)
block|{
if|if
condition|(
name|i
operator|++
operator|>
literal|256
condition|)
break|break;
name|printf
argument_list|(
literal|"%d "
argument_list|,
name|scb
operator|->
name|hscb
operator|->
name|tag
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|maxtarget
operator|=
operator|(
name|ahc
operator|->
name|features
operator|&
operator|(
name|AHC_WIDE
operator||
name|AHC_TWIN
operator|)
operator|)
condition|?
literal|15
else|:
literal|7
expr_stmt|;
for|for
control|(
name|target
operator|=
literal|0
init|;
name|target
operator|<=
name|maxtarget
condition|;
name|target
operator|++
control|)
block|{
name|untagged_q
operator|=
operator|&
name|ahc
operator|->
name|untagged_queues
index|[
name|target
index|]
expr_stmt|;
if|if
condition|(
name|TAILQ_FIRST
argument_list|(
name|untagged_q
argument_list|)
operator|==
name|NULL
condition|)
continue|continue;
name|printf
argument_list|(
literal|"Untagged Q(%d): "
argument_list|,
name|target
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|scb
argument_list|,
argument|untagged_q
argument_list|,
argument|links.tqe
argument_list|)
block|{
if|if
condition|(
name|i
operator|++
operator|>
literal|256
condition|)
break|break;
name|printf
argument_list|(
literal|"%d "
argument_list|,
name|scb
operator|->
name|hscb
operator|->
name|tag
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|ahc_platform_dump_card_state
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n<<<<<<<<<<<<<<<<< Dump Card State Ends>>>>>>>>>>>>>>>>>>\n"
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCBPTR
argument_list|,
name|saved_scbptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|paused
operator|==
literal|0
condition|)
name|ahc_unpause
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*************************** Timeout Handling *********************************/
end_comment

begin_function
name|void
name|ahc_timeout
parameter_list|(
name|struct
name|scb
modifier|*
name|scb
parameter_list|)
block|{
name|struct
name|ahc_softc
modifier|*
name|ahc
decl_stmt|;
name|ahc
operator|=
name|scb
operator|->
name|ahc_softc
expr_stmt|;
name|ahc_lock
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|scb
operator|->
name|flags
operator|&
name|SCB_ACTIVE
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|scb
operator|->
name|flags
operator|&
name|SCB_TIMEDOUT
operator|)
operator|==
literal|0
condition|)
block|{
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|ahc
operator|->
name|timedout_scbs
argument_list|,
name|scb
argument_list|,
name|timedout_links
argument_list|)
expr_stmt|;
name|scb
operator|->
name|flags
operator||=
name|SCB_TIMEDOUT
expr_stmt|;
block|}
name|ahc_wakeup_recovery_thread
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
block|}
name|ahc_unlock
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Re-schedule a timeout for the passed in SCB if we determine that some  * other SCB is in the process of recovery or an SCB with a longer  * timeout is still pending.  Limit our search to just "other_scb"  * if it is non-NULL.  */
end_comment

begin_function
specifier|static
name|int
name|ahc_other_scb_timeout
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|struct
name|scb
modifier|*
name|scb
parameter_list|,
name|struct
name|scb
modifier|*
name|other_scb
parameter_list|)
block|{
name|u_int
name|newtimeout
decl_stmt|;
name|int
name|found
decl_stmt|;
name|ahc_print_path
argument_list|(
name|ahc
argument_list|,
name|scb
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Other SCB Timeout%s"
argument_list|,
operator|(
name|scb
operator|->
name|flags
operator|&
name|SCB_OTHERTCL_TIMEOUT
operator|)
operator|!=
literal|0
condition|?
literal|" again\n"
else|:
literal|"\n"
argument_list|)
expr_stmt|;
name|newtimeout
operator|=
name|aic_get_timeout
argument_list|(
name|scb
argument_list|)
expr_stmt|;
name|scb
operator|->
name|flags
operator||=
name|SCB_OTHERTCL_TIMEOUT
expr_stmt|;
name|found
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|other_scb
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|other_scb
operator|->
name|flags
operator|&
operator|(
name|SCB_OTHERTCL_TIMEOUT
operator||
name|SCB_TIMEDOUT
operator|)
operator|)
operator|==
literal|0
operator|||
operator|(
name|other_scb
operator|->
name|flags
operator|&
name|SCB_RECOVERY_SCB
operator|)
operator|!=
literal|0
condition|)
block|{
name|found
operator|++
expr_stmt|;
name|newtimeout
operator|=
name|MAX
argument_list|(
name|aic_get_timeout
argument_list|(
name|other_scb
argument_list|)
argument_list|,
name|newtimeout
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|LIST_FOREACH
argument_list|(
argument|other_scb
argument_list|,
argument|&ahc->pending_scbs
argument_list|,
argument|pending_links
argument_list|)
block|{
if|if
condition|(
operator|(
name|other_scb
operator|->
name|flags
operator|&
operator|(
name|SCB_OTHERTCL_TIMEOUT
operator||
name|SCB_TIMEDOUT
operator|)
operator|)
operator|==
literal|0
operator|||
operator|(
name|other_scb
operator|->
name|flags
operator|&
name|SCB_RECOVERY_SCB
operator|)
operator|!=
literal|0
condition|)
block|{
name|found
operator|++
expr_stmt|;
name|newtimeout
operator|=
name|MAX
argument_list|(
name|aic_get_timeout
argument_list|(
name|other_scb
argument_list|)
argument_list|,
name|newtimeout
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|found
operator|!=
literal|0
condition|)
name|aic_scb_timer_reset
argument_list|(
name|scb
argument_list|,
name|newtimeout
argument_list|)
expr_stmt|;
else|else
block|{
name|ahc_print_path
argument_list|(
name|ahc
argument_list|,
name|scb
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"No other SCB worth waiting for...\n"
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|found
operator|!=
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * ahc_recover_commands determines if any of the commands that have currently  * timedout are the root cause for this timeout.  Innocent commands are given  * a new timeout while we wait for the command executing on the bus to timeout.  * This routine is invoked from a thread context so we are allowed to sleep.  * Our lock is not held on entry.  */
end_comment

begin_function
name|void
name|ahc_recover_commands
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|)
block|{
name|struct
name|scb
modifier|*
name|scb
decl_stmt|;
name|int
name|found
decl_stmt|;
name|int
name|restart_needed
decl_stmt|;
name|u_int
name|last_phase
decl_stmt|;
comment|/* 	 * Pause the controller and manually flush any 	 * commands that have just completed but that our 	 * interrupt handler has yet to see. 	 */
name|ahc_pause_and_flushwork
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
if|if
condition|(
name|LIST_EMPTY
argument_list|(
operator|&
name|ahc
operator|->
name|timedout_scbs
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * The timedout commands have already 		 * completed.  This typically means 		 * that either the timeout value was on 		 * the hairy edge of what the device 		 * requires or - more likely - interrupts 		 * are not happening. 		 */
name|printf
argument_list|(
literal|"%s: Timedout SCBs already complete. "
literal|"Interrupts may not be functioning.\n"
argument_list|,
name|ahc_name
argument_list|(
name|ahc
argument_list|)
argument_list|)
expr_stmt|;
name|ahc_unpause
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
return|return;
block|}
name|restart_needed
operator|=
literal|0
expr_stmt|;
name|printf
argument_list|(
literal|"%s: Recovery Initiated\n"
argument_list|,
name|ahc_name
argument_list|(
name|ahc
argument_list|)
argument_list|)
expr_stmt|;
name|ahc_dump_card_state
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
name|last_phase
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|LASTPHASE
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|scb
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|ahc
operator|->
name|timedout_scbs
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|u_int
name|active_scb_index
decl_stmt|;
name|u_int
name|saved_scbptr
decl_stmt|;
name|int
name|target
decl_stmt|;
name|int
name|lun
decl_stmt|;
name|int
name|i
decl_stmt|;
name|char
name|channel
decl_stmt|;
name|target
operator|=
name|SCB_GET_TARGET
argument_list|(
name|ahc
argument_list|,
name|scb
argument_list|)
expr_stmt|;
name|channel
operator|=
name|SCB_GET_CHANNEL
argument_list|(
name|ahc
argument_list|,
name|scb
argument_list|)
expr_stmt|;
name|lun
operator|=
name|SCB_GET_LUN
argument_list|(
name|scb
argument_list|)
expr_stmt|;
name|ahc_print_path
argument_list|(
name|ahc
argument_list|,
name|scb
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"SCB 0x%x - timed out\n"
argument_list|,
name|scb
operator|->
name|hscb
operator|->
name|tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|scb
operator|->
name|sg_count
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|scb
operator|->
name|sg_count
condition|;
name|i
operator|++
control|)
block|{
name|printf
argument_list|(
literal|"sg[%d] - Addr 0x%x : Length %d\n"
argument_list|,
name|i
argument_list|,
name|scb
operator|->
name|sg_list
index|[
name|i
index|]
operator|.
name|addr
argument_list|,
name|scb
operator|->
name|sg_list
index|[
name|i
index|]
operator|.
name|len
operator|&
name|AHC_SG_LEN_MASK
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|scb
operator|->
name|flags
operator|&
operator|(
name|SCB_DEVICE_RESET
operator||
name|SCB_ABORT
operator|)
condition|)
block|{
comment|/* 			 * Been down this road before. 			 * Do a full bus reset. 			 */
name|aic_set_transaction_status
argument_list|(
name|scb
argument_list|,
name|CAM_CMD_TIMEOUT
argument_list|)
expr_stmt|;
name|bus_reset
label|:
name|found
operator|=
name|ahc_reset_channel
argument_list|(
name|ahc
argument_list|,
name|channel
argument_list|,
comment|/*Initiate Reset*/
name|TRUE
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s: Issued Channel %c Bus Reset. "
literal|"%d SCBs aborted\n"
argument_list|,
name|ahc_name
argument_list|(
name|ahc
argument_list|)
argument_list|,
name|channel
argument_list|,
name|found
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * Remove the command from the timedout list in 		 * preparation for requeing it. 		 */
name|LIST_REMOVE
argument_list|(
name|scb
argument_list|,
name|timedout_links
argument_list|)
expr_stmt|;
name|scb
operator|->
name|flags
operator|&=
operator|~
name|SCB_TIMEDOUT
expr_stmt|;
comment|/* 		 * If we are a target, transition to bus free and report 		 * the timeout. 		 *  		 * The target/initiator that is holding up the bus may not 		 * be the same as the one that triggered this timeout 		 * (different commands have different timeout lengths). 		 * If the bus is idle and we are actiing as the initiator 		 * for this request, queue a BDR message to the timed out 		 * target.  Otherwise, if the timed out transaction is 		 * active: 		 *   Initiator transaction: 		 *	Stuff the message buffer with a BDR message and assert 		 *	ATN in the hopes that the target will let go of the bus 		 *	and go to the mesgout phase.  If this fails, we'll 		 *	get another timeout 2 seconds later which will attempt 		 *	a bus reset. 		 * 		 *   Target transaction: 		 *	Transition to BUS FREE and report the error. 		 *	It's good to be the target! 		 */
name|saved_scbptr
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCBPTR
argument_list|)
expr_stmt|;
name|active_scb_index
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCB_TAG
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SEQ_FLAGS
argument_list|)
operator|&
name|NOT_IDENTIFIED
operator|)
operator|==
literal|0
operator|&&
operator|(
name|active_scb_index
operator|<
name|ahc
operator|->
name|scb_data
operator|->
name|numscbs
operator|)
condition|)
block|{
name|struct
name|scb
modifier|*
name|active_scb
decl_stmt|;
comment|/* 			 * If the active SCB is not us, assume that 			 * the active SCB has a longer timeout than 			 * the timedout SCB, and wait for the active 			 * SCB to timeout. 			 */
name|active_scb
operator|=
name|ahc_lookup_scb
argument_list|(
name|ahc
argument_list|,
name|active_scb_index
argument_list|)
expr_stmt|;
if|if
condition|(
name|active_scb
operator|!=
name|scb
condition|)
block|{
if|if
condition|(
name|ahc_other_scb_timeout
argument_list|(
name|ahc
argument_list|,
name|scb
argument_list|,
name|active_scb
argument_list|)
operator|==
literal|0
condition|)
goto|goto
name|bus_reset
goto|;
continue|continue;
block|}
comment|/* It's us */
if|if
condition|(
operator|(
name|scb
operator|->
name|flags
operator|&
name|SCB_TARGET_SCB
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* 				 * Send back any queued up transactions 				 * and properly record the error condition. 				 */
name|ahc_abort_scbs
argument_list|(
name|ahc
argument_list|,
name|SCB_GET_TARGET
argument_list|(
name|ahc
argument_list|,
name|scb
argument_list|)
argument_list|,
name|SCB_GET_CHANNEL
argument_list|(
name|ahc
argument_list|,
name|scb
argument_list|)
argument_list|,
name|SCB_GET_LUN
argument_list|(
name|scb
argument_list|)
argument_list|,
name|scb
operator|->
name|hscb
operator|->
name|tag
argument_list|,
name|ROLE_TARGET
argument_list|,
name|CAM_CMD_TIMEOUT
argument_list|)
expr_stmt|;
comment|/* Will clear us from the bus */
name|restart_needed
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|ahc_set_recoveryscb
argument_list|(
name|ahc
argument_list|,
name|active_scb
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|MSG_OUT
argument_list|,
name|HOST_MSG
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCSISIGO
argument_list|,
name|last_phase
operator||
name|ATNO
argument_list|)
expr_stmt|;
name|ahc_print_path
argument_list|(
name|ahc
argument_list|,
name|active_scb
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"BDR message in message buffer\n"
argument_list|)
expr_stmt|;
name|active_scb
operator|->
name|flags
operator||=
name|SCB_DEVICE_RESET
expr_stmt|;
name|aic_scb_timer_reset
argument_list|(
name|scb
argument_list|,
literal|2
operator|*
literal|1000
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|last_phase
operator|!=
name|P_BUSFREE
operator|&&
operator|(
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SSTAT1
argument_list|)
operator|&
name|REQINIT
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 			 * SCB is not identified, there 			 * is no pending REQ, and the sequencer 			 * has not seen a busfree.  Looks like 			 * a stuck connection waiting to 			 * go busfree.  Reset the bus. 			 */
name|printf
argument_list|(
literal|"%s: Connection stuck awaiting busfree or "
literal|"Identify Msg.\n"
argument_list|,
name|ahc_name
argument_list|(
name|ahc
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|bus_reset
goto|;
block|}
else|else
block|{
name|int
name|disconnected
decl_stmt|;
if|if
condition|(
name|last_phase
operator|!=
name|P_BUSFREE
operator|&&
operator|(
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SSTAT0
argument_list|)
operator|&
name|TARGET
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* Hung target selection.  Goto busfree */
name|printf
argument_list|(
literal|"%s: Hung target selection\n"
argument_list|,
name|ahc_name
argument_list|(
name|ahc
argument_list|)
argument_list|)
expr_stmt|;
name|restart_needed
operator|=
literal|1
expr_stmt|;
break|break;
block|}
comment|/* XXX Shouldn't panic.  Just punt instead? */
if|if
condition|(
operator|(
name|scb
operator|->
name|flags
operator|&
name|SCB_TARGET_SCB
operator|)
operator|!=
literal|0
condition|)
name|panic
argument_list|(
literal|"Timed-out target SCB but bus idle"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ahc_search_qinfifo
argument_list|(
name|ahc
argument_list|,
name|target
argument_list|,
name|channel
argument_list|,
name|lun
argument_list|,
name|scb
operator|->
name|hscb
operator|->
name|tag
argument_list|,
name|ROLE_INITIATOR
argument_list|,
comment|/*status*/
literal|0
argument_list|,
name|SEARCH_COUNT
argument_list|)
operator|>
literal|0
condition|)
block|{
name|disconnected
operator|=
name|FALSE
expr_stmt|;
block|}
else|else
block|{
name|disconnected
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
name|disconnected
condition|)
block|{
name|ahc_set_recoveryscb
argument_list|(
name|ahc
argument_list|,
name|scb
argument_list|)
expr_stmt|;
comment|/* 				 * Actually re-queue this SCB in an attempt 				 * to select the device before it reconnects. 				 * In either case (selection or reselection), 				 * we will now issue a target reset to the 				 * timed-out device. 				 * 				 * Set the MK_MESSAGE control bit indicating 				 * that we desire to send a message.  We 				 * also set the disconnected flag since 				 * in the paging case there is no guarantee 				 * that our SCB control byte matches the 				 * version on the card.  We don't want the 				 * sequencer to abort the command thinking 				 * an unsolicited reselection occurred. 				 */
name|scb
operator|->
name|hscb
operator|->
name|control
operator||=
name|MK_MESSAGE
operator||
name|DISCONNECTED
expr_stmt|;
name|scb
operator|->
name|flags
operator||=
name|SCB_DEVICE_RESET
expr_stmt|;
comment|/* 				 * Remove any cached copy of this SCB in the 				 * disconnected list in preparation for the 				 * queuing of our abort SCB.  We use the 				 * same element in the SCB, SCB_NEXT, for 				 * both the qinfifo and the disconnected list. 				 */
name|ahc_search_disc_list
argument_list|(
name|ahc
argument_list|,
name|target
argument_list|,
name|channel
argument_list|,
name|lun
argument_list|,
name|scb
operator|->
name|hscb
operator|->
name|tag
argument_list|,
comment|/*stop_on_first*/
name|TRUE
argument_list|,
comment|/*remove*/
name|TRUE
argument_list|,
comment|/*save_state*/
name|FALSE
argument_list|)
expr_stmt|;
comment|/* 				 * In the non-paging case, the sequencer will 				 * never re-reference the in-core SCB. 				 * To make sure we are notified during 				 * reslection, set the MK_MESSAGE flag in 				 * the card's copy of the SCB. 				 */
if|if
condition|(
operator|(
name|ahc
operator|->
name|flags
operator|&
name|AHC_PAGESCBS
operator|)
operator|==
literal|0
condition|)
block|{
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCBPTR
argument_list|,
name|scb
operator|->
name|hscb
operator|->
name|tag
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCB_CONTROL
argument_list|,
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCB_CONTROL
argument_list|)
operator||
name|MK_MESSAGE
argument_list|)
expr_stmt|;
block|}
comment|/* 				 * Clear out any entries in the QINFIFO first 				 * so we are the next SCB for this target 				 * to run. 				 */
name|ahc_search_qinfifo
argument_list|(
name|ahc
argument_list|,
name|SCB_GET_TARGET
argument_list|(
name|ahc
argument_list|,
name|scb
argument_list|)
argument_list|,
name|channel
argument_list|,
name|SCB_GET_LUN
argument_list|(
name|scb
argument_list|)
argument_list|,
name|SCB_LIST_NULL
argument_list|,
name|ROLE_INITIATOR
argument_list|,
name|CAM_REQUEUE_REQ
argument_list|,
name|SEARCH_COMPLETE
argument_list|)
expr_stmt|;
name|ahc_print_path
argument_list|(
name|ahc
argument_list|,
name|scb
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Queuing a BDR SCB\n"
argument_list|)
expr_stmt|;
name|ahc_qinfifo_requeue_tail
argument_list|(
name|ahc
argument_list|,
name|scb
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCBPTR
argument_list|,
name|saved_scbptr
argument_list|)
expr_stmt|;
name|aic_scb_timer_reset
argument_list|(
name|scb
argument_list|,
literal|2
operator|*
literal|1000
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Go "immediatly" to the bus reset */
comment|/* This shouldn't happen */
name|ahc_set_recoveryscb
argument_list|(
name|ahc
argument_list|,
name|scb
argument_list|)
expr_stmt|;
name|ahc_print_path
argument_list|(
name|ahc
argument_list|,
name|scb
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"SCB %d: Immediate reset.  "
literal|"Flags = 0x%x\n"
argument_list|,
name|scb
operator|->
name|hscb
operator|->
name|tag
argument_list|,
name|scb
operator|->
name|flags
argument_list|)
expr_stmt|;
goto|goto
name|bus_reset
goto|;
block|}
block|}
break|break;
block|}
comment|/* 	 * Any remaining SCBs were not the "culprit", so remove 	 * them from the timeout list.  The timer for these commands 	 * will be reset once the recovery SCB completes. 	 */
while|while
condition|(
operator|(
name|scb
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|ahc
operator|->
name|timedout_scbs
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|LIST_REMOVE
argument_list|(
name|scb
argument_list|,
name|timedout_links
argument_list|)
expr_stmt|;
name|scb
operator|->
name|flags
operator|&=
operator|~
name|SCB_TIMEDOUT
expr_stmt|;
block|}
if|if
condition|(
name|restart_needed
condition|)
name|ahc_restart
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
else|else
name|ahc_unpause
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/************************* Target Mode ****************************************/
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|AHC_TARGET_MODE
end_ifdef

begin_function
name|cam_status
name|ahc_find_tmode_devs
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|struct
name|cam_sim
modifier|*
name|sim
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|,
name|struct
name|ahc_tmode_tstate
modifier|*
modifier|*
name|tstate
parameter_list|,
name|struct
name|ahc_tmode_lstate
modifier|*
modifier|*
name|lstate
parameter_list|,
name|int
name|notfound_failure
parameter_list|)
block|{
if|if
condition|(
operator|(
name|ahc
operator|->
name|features
operator|&
name|AHC_TARGETMODE
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|CAM_REQ_INVALID
operator|)
return|;
comment|/* 	 * Handle the 'black hole' device that sucks up 	 * requests to unattached luns on enabled targets. 	 */
if|if
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
operator|==
name|CAM_TARGET_WILDCARD
operator|&&
name|ccb
operator|->
name|ccb_h
operator|.
name|target_lun
operator|==
name|CAM_LUN_WILDCARD
condition|)
block|{
operator|*
name|tstate
operator|=
name|NULL
expr_stmt|;
operator|*
name|lstate
operator|=
name|ahc
operator|->
name|black_hole
expr_stmt|;
block|}
else|else
block|{
name|u_int
name|max_id
decl_stmt|;
name|max_id
operator|=
operator|(
name|ahc
operator|->
name|features
operator|&
name|AHC_WIDE
operator|)
condition|?
literal|15
else|:
literal|7
expr_stmt|;
if|if
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
operator|>
name|max_id
condition|)
return|return
operator|(
name|CAM_TID_INVALID
operator|)
return|;
if|if
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|target_lun
operator|>=
name|AHC_NUM_LUNS
condition|)
return|return
operator|(
name|CAM_LUN_INVALID
operator|)
return|;
operator|*
name|tstate
operator|=
name|ahc
operator|->
name|enabled_targets
index|[
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
index|]
expr_stmt|;
operator|*
name|lstate
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|*
name|tstate
operator|!=
name|NULL
condition|)
operator|*
name|lstate
operator|=
operator|(
operator|*
name|tstate
operator|)
operator|->
name|enabled_luns
index|[
name|ccb
operator|->
name|ccb_h
operator|.
name|target_lun
index|]
expr_stmt|;
block|}
if|if
condition|(
name|notfound_failure
operator|!=
literal|0
operator|&&
operator|*
name|lstate
operator|==
name|NULL
condition|)
return|return
operator|(
name|CAM_PATH_INVALID
operator|)
return|;
return|return
operator|(
name|CAM_REQ_CMP
operator|)
return|;
block|}
end_function

begin_function
name|void
name|ahc_handle_en_lun
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|struct
name|cam_sim
modifier|*
name|sim
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
block|{
name|struct
name|ahc_tmode_tstate
modifier|*
name|tstate
decl_stmt|;
name|struct
name|ahc_tmode_lstate
modifier|*
name|lstate
decl_stmt|;
name|struct
name|ccb_en_lun
modifier|*
name|cel
decl_stmt|;
name|cam_status
name|status
decl_stmt|;
name|u_int
name|target
decl_stmt|;
name|u_int
name|lun
decl_stmt|;
name|u_int
name|target_mask
decl_stmt|;
name|u_int
name|our_id
decl_stmt|;
name|int
name|error
decl_stmt|;
name|char
name|channel
decl_stmt|;
name|status
operator|=
name|ahc_find_tmode_devs
argument_list|(
name|ahc
argument_list|,
name|sim
argument_list|,
name|ccb
argument_list|,
operator|&
name|tstate
argument_list|,
operator|&
name|lstate
argument_list|,
comment|/*notfound_failure*/
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|status
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|cam_sim_bus
argument_list|(
name|sim
argument_list|)
operator|==
literal|0
condition|)
name|our_id
operator|=
name|ahc
operator|->
name|our_id
expr_stmt|;
else|else
name|our_id
operator|=
name|ahc
operator|->
name|our_id_b
expr_stmt|;
if|if
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
operator|!=
name|our_id
condition|)
block|{
comment|/* 		 * our_id represents our initiator ID, or 		 * the ID of the first target to have an 		 * enabled lun in target mode.  There are 		 * two cases that may preclude enabling a 		 * target id other than our_id. 		 * 		 *   o our_id is for an active initiator role. 		 *     Since the hardware does not support 		 *     reselections to the initiator role at 		 *     anything other than our_id, and our_id 		 *     is used by the hardware to indicate the 		 *     ID to use for both select-out and 		 *     reselect-out operations, the only target 		 *     ID we can support in this mode is our_id. 		 * 		 *   o The MULTARGID feature is not available and 		 *     a previous target mode ID has been enabled. 		 */
if|if
condition|(
operator|(
name|ahc
operator|->
name|features
operator|&
name|AHC_MULTIROLE
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|ahc
operator|->
name|features
operator|&
name|AHC_MULTI_TID
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|ahc
operator|->
name|flags
operator|&
name|AHC_INITIATORROLE
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* 				 * Only allow additional targets if 				 * the initiator role is disabled. 				 * The hardware cannot handle a re-select-in 				 * on the initiator id during a re-select-out 				 * on a different target id. 				 */
name|status
operator|=
name|CAM_TID_INVALID
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|ahc
operator|->
name|flags
operator|&
name|AHC_INITIATORROLE
operator|)
operator|!=
literal|0
operator|||
name|ahc
operator|->
name|enabled_luns
operator|>
literal|0
condition|)
block|{
comment|/* 				 * Only allow our target id to change 				 * if the initiator role is not configured 				 * and there are no enabled luns which 				 * are attached to the currently registered 				 * scsi id. 				 */
name|status
operator|=
name|CAM_TID_INVALID
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|ahc
operator|->
name|features
operator|&
name|AHC_MULTI_TID
operator|)
operator|==
literal|0
operator|&&
name|ahc
operator|->
name|enabled_luns
operator|>
literal|0
condition|)
block|{
name|status
operator|=
name|CAM_TID_INVALID
expr_stmt|;
block|}
block|}
if|if
condition|(
name|status
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|status
expr_stmt|;
return|return;
block|}
comment|/* 	 * We now have an id that is valid. 	 * If we aren't in target mode, switch modes. 	 */
if|if
condition|(
operator|(
name|ahc
operator|->
name|flags
operator|&
name|AHC_TARGETROLE
operator|)
operator|==
literal|0
operator|&&
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
operator|!=
name|CAM_TARGET_WILDCARD
condition|)
block|{
name|ahc_flag
name|saved_flags
decl_stmt|;
name|printf
argument_list|(
literal|"Configuring Target Mode\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|LIST_FIRST
argument_list|(
operator|&
name|ahc
operator|->
name|pending_scbs
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_BUSY
expr_stmt|;
return|return;
block|}
name|saved_flags
operator|=
name|ahc
operator|->
name|flags
expr_stmt|;
name|ahc
operator|->
name|flags
operator||=
name|AHC_TARGETROLE
expr_stmt|;
if|if
condition|(
operator|(
name|ahc
operator|->
name|features
operator|&
name|AHC_MULTIROLE
operator|)
operator|==
literal|0
condition|)
name|ahc
operator|->
name|flags
operator|&=
operator|~
name|AHC_INITIATORROLE
expr_stmt|;
name|ahc_pause
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
name|error
operator|=
name|ahc_loadseq
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
comment|/* 			 * Restore original configuration and notify 			 * the caller that we cannot support target mode. 			 * Since the adapter started out in this 			 * configuration, the firmware load will succeed, 			 * so there is no point in checking ahc_loadseq's 			 * return value. 			 */
name|ahc
operator|->
name|flags
operator|=
name|saved_flags
expr_stmt|;
operator|(
name|void
operator|)
name|ahc_loadseq
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
name|ahc_restart
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_FUNC_NOTAVAIL
expr_stmt|;
return|return;
block|}
name|ahc_restart
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
block|}
name|cel
operator|=
operator|&
name|ccb
operator|->
name|cel
expr_stmt|;
name|target
operator|=
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
expr_stmt|;
name|lun
operator|=
name|ccb
operator|->
name|ccb_h
operator|.
name|target_lun
expr_stmt|;
name|channel
operator|=
name|SIM_CHANNEL
argument_list|(
name|ahc
argument_list|,
name|sim
argument_list|)
expr_stmt|;
name|target_mask
operator|=
literal|0x01
operator|<<
name|target
expr_stmt|;
if|if
condition|(
name|channel
operator|==
literal|'B'
condition|)
name|target_mask
operator|<<=
literal|8
expr_stmt|;
if|if
condition|(
name|cel
operator|->
name|enable
operator|!=
literal|0
condition|)
block|{
name|u_int
name|scsiseq
decl_stmt|;
comment|/* Are we already enabled?? */
if|if
condition|(
name|lstate
operator|!=
name|NULL
condition|)
block|{
name|xpt_print_path
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Lun already enabled\n"
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_LUN_ALRDY_ENA
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|cel
operator|->
name|grp6_len
operator|!=
literal|0
operator|||
name|cel
operator|->
name|grp7_len
operator|!=
literal|0
condition|)
block|{
comment|/* 			 * Don't (yet?) support vendor 			 * specific commands. 			 */
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_INVALID
expr_stmt|;
name|printf
argument_list|(
literal|"Non-zero Group Codes\n"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 		 * Seems to be okay. 		 * Setup our data structures. 		 */
if|if
condition|(
name|target
operator|!=
name|CAM_TARGET_WILDCARD
operator|&&
name|tstate
operator|==
name|NULL
condition|)
block|{
name|tstate
operator|=
name|ahc_alloc_tstate
argument_list|(
name|ahc
argument_list|,
name|target
argument_list|,
name|channel
argument_list|)
expr_stmt|;
if|if
condition|(
name|tstate
operator|==
name|NULL
condition|)
block|{
name|xpt_print_path
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Couldn't allocate tstate\n"
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_RESRC_UNAVAIL
expr_stmt|;
return|return;
block|}
block|}
name|lstate
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|lstate
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|lstate
operator|==
name|NULL
condition|)
block|{
name|xpt_print_path
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Couldn't allocate lstate\n"
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_RESRC_UNAVAIL
expr_stmt|;
return|return;
block|}
name|memset
argument_list|(
name|lstate
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|lstate
argument_list|)
argument_list|)
expr_stmt|;
name|status
operator|=
name|xpt_create_path
argument_list|(
operator|&
name|lstate
operator|->
name|path
argument_list|,
comment|/*periph*/
name|NULL
argument_list|,
name|xpt_path_path_id
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|)
argument_list|,
name|xpt_path_target_id
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|)
argument_list|,
name|xpt_path_lun_id
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|free
argument_list|(
name|lstate
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|xpt_print_path
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Couldn't allocate path\n"
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_RESRC_UNAVAIL
expr_stmt|;
return|return;
block|}
name|SLIST_INIT
argument_list|(
operator|&
name|lstate
operator|->
name|accept_tios
argument_list|)
expr_stmt|;
name|SLIST_INIT
argument_list|(
operator|&
name|lstate
operator|->
name|immed_notifies
argument_list|)
expr_stmt|;
name|ahc_pause
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
operator|!=
name|CAM_TARGET_WILDCARD
condition|)
block|{
name|tstate
operator|->
name|enabled_luns
index|[
name|lun
index|]
operator|=
name|lstate
expr_stmt|;
name|ahc
operator|->
name|enabled_luns
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|ahc
operator|->
name|features
operator|&
name|AHC_MULTI_TID
operator|)
operator|!=
literal|0
condition|)
block|{
name|u_int
name|targid_mask
decl_stmt|;
name|targid_mask
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|TARGID
argument_list|)
operator||
operator|(
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|TARGID
operator|+
literal|1
argument_list|)
operator|<<
literal|8
operator|)
expr_stmt|;
name|targid_mask
operator||=
name|target_mask
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|TARGID
argument_list|,
name|targid_mask
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|TARGID
operator|+
literal|1
argument_list|,
operator|(
name|targid_mask
operator|>>
literal|8
operator|)
argument_list|)
expr_stmt|;
name|ahc_update_scsiid
argument_list|(
name|ahc
argument_list|,
name|targid_mask
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|u_int
name|our_id
decl_stmt|;
name|char
name|channel
decl_stmt|;
name|channel
operator|=
name|SIM_CHANNEL
argument_list|(
name|ahc
argument_list|,
name|sim
argument_list|)
expr_stmt|;
name|our_id
operator|=
name|SIM_SCSI_ID
argument_list|(
name|ahc
argument_list|,
name|sim
argument_list|)
expr_stmt|;
comment|/* 				 * This can only happen if selections 				 * are not enabled 				 */
if|if
condition|(
name|target
operator|!=
name|our_id
condition|)
block|{
name|u_int
name|sblkctl
decl_stmt|;
name|char
name|cur_channel
decl_stmt|;
name|int
name|swap
decl_stmt|;
name|sblkctl
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SBLKCTL
argument_list|)
expr_stmt|;
name|cur_channel
operator|=
operator|(
name|sblkctl
operator|&
name|SELBUSB
operator|)
condition|?
literal|'B'
else|:
literal|'A'
expr_stmt|;
if|if
condition|(
operator|(
name|ahc
operator|->
name|features
operator|&
name|AHC_TWIN
operator|)
operator|==
literal|0
condition|)
name|cur_channel
operator|=
literal|'A'
expr_stmt|;
name|swap
operator|=
name|cur_channel
operator|!=
name|channel
expr_stmt|;
if|if
condition|(
name|channel
operator|==
literal|'A'
condition|)
name|ahc
operator|->
name|our_id
operator|=
name|target
expr_stmt|;
else|else
name|ahc
operator|->
name|our_id_b
operator|=
name|target
expr_stmt|;
if|if
condition|(
name|swap
condition|)
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SBLKCTL
argument_list|,
name|sblkctl
operator|^
name|SELBUSB
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCSIID
argument_list|,
name|target
argument_list|)
expr_stmt|;
if|if
condition|(
name|swap
condition|)
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SBLKCTL
argument_list|,
name|sblkctl
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
name|ahc
operator|->
name|black_hole
operator|=
name|lstate
expr_stmt|;
comment|/* Allow select-in operations */
if|if
condition|(
name|ahc
operator|->
name|black_hole
operator|!=
name|NULL
operator|&&
name|ahc
operator|->
name|enabled_luns
operator|>
literal|0
condition|)
block|{
name|scsiseq
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCSISEQ_TEMPLATE
argument_list|)
expr_stmt|;
name|scsiseq
operator||=
name|ENSELI
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCSISEQ_TEMPLATE
argument_list|,
name|scsiseq
argument_list|)
expr_stmt|;
name|scsiseq
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCSISEQ
argument_list|)
expr_stmt|;
name|scsiseq
operator||=
name|ENSELI
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCSISEQ
argument_list|,
name|scsiseq
argument_list|)
expr_stmt|;
block|}
name|ahc_unpause
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
name|xpt_print_path
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Lun now enabled for target mode\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|struct
name|scb
modifier|*
name|scb
decl_stmt|;
name|int
name|i
decl_stmt|,
name|empty
decl_stmt|;
if|if
condition|(
name|lstate
operator|==
name|NULL
condition|)
block|{
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_LUN_INVALID
expr_stmt|;
return|return;
block|}
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|scb
argument_list|,
argument|&ahc->pending_scbs
argument_list|,
argument|pending_links
argument_list|)
block|{
name|struct
name|ccb_hdr
modifier|*
name|ccbh
decl_stmt|;
name|ccbh
operator|=
operator|&
name|scb
operator|->
name|io_ctx
operator|->
name|ccb_h
expr_stmt|;
if|if
condition|(
name|ccbh
operator|->
name|func_code
operator|==
name|XPT_CONT_TARGET_IO
operator|&&
operator|!
name|xpt_path_comp
argument_list|(
name|ccbh
operator|->
name|path
argument_list|,
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"CTIO pending\n"
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_INVALID
expr_stmt|;
return|return;
block|}
block|}
if|if
condition|(
name|SLIST_FIRST
argument_list|(
operator|&
name|lstate
operator|->
name|accept_tios
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"ATIOs pending\n"
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_INVALID
expr_stmt|;
block|}
if|if
condition|(
name|SLIST_FIRST
argument_list|(
operator|&
name|lstate
operator|->
name|immed_notifies
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"INOTs pending\n"
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_INVALID
expr_stmt|;
block|}
if|if
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
return|return;
block|}
name|xpt_print_path
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Target mode disabled\n"
argument_list|)
expr_stmt|;
name|xpt_free_path
argument_list|(
name|lstate
operator|->
name|path
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|lstate
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|ahc_pause
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
comment|/* Can we clean up the target too? */
if|if
condition|(
name|target
operator|!=
name|CAM_TARGET_WILDCARD
condition|)
block|{
name|tstate
operator|->
name|enabled_luns
index|[
name|lun
index|]
operator|=
name|NULL
expr_stmt|;
name|ahc
operator|->
name|enabled_luns
operator|--
expr_stmt|;
for|for
control|(
name|empty
operator|=
literal|1
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|tstate
operator|->
name|enabled_luns
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
block|{
name|empty
operator|=
literal|0
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|empty
condition|)
block|{
name|ahc_free_tstate
argument_list|(
name|ahc
argument_list|,
name|target
argument_list|,
name|channel
argument_list|,
comment|/*force*/
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|ahc
operator|->
name|features
operator|&
name|AHC_MULTI_TID
condition|)
block|{
name|u_int
name|targid_mask
decl_stmt|;
name|targid_mask
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|TARGID
argument_list|)
operator||
operator|(
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|TARGID
operator|+
literal|1
argument_list|)
operator|<<
literal|8
operator|)
expr_stmt|;
name|targid_mask
operator|&=
operator|~
name|target_mask
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|TARGID
argument_list|,
name|targid_mask
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|TARGID
operator|+
literal|1
argument_list|,
operator|(
name|targid_mask
operator|>>
literal|8
operator|)
argument_list|)
expr_stmt|;
name|ahc_update_scsiid
argument_list|(
name|ahc
argument_list|,
name|targid_mask
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|ahc
operator|->
name|black_hole
operator|=
name|NULL
expr_stmt|;
comment|/* 			 * We can't allow selections without 			 * our black hole device. 			 */
name|empty
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
name|ahc
operator|->
name|enabled_luns
operator|==
literal|0
condition|)
block|{
comment|/* Disallow select-in */
name|u_int
name|scsiseq
decl_stmt|;
name|scsiseq
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCSISEQ_TEMPLATE
argument_list|)
expr_stmt|;
name|scsiseq
operator|&=
operator|~
name|ENSELI
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCSISEQ_TEMPLATE
argument_list|,
name|scsiseq
argument_list|)
expr_stmt|;
name|scsiseq
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCSISEQ
argument_list|)
expr_stmt|;
name|scsiseq
operator|&=
operator|~
name|ENSELI
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCSISEQ
argument_list|,
name|scsiseq
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ahc
operator|->
name|features
operator|&
name|AHC_MULTIROLE
operator|)
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"Configuring Initiator Mode\n"
argument_list|)
expr_stmt|;
name|ahc
operator|->
name|flags
operator|&=
operator|~
name|AHC_TARGETROLE
expr_stmt|;
name|ahc
operator|->
name|flags
operator||=
name|AHC_INITIATORROLE
expr_stmt|;
comment|/* 				 * Returning to a configuration that 				 * fit previously will always succeed. 				 */
operator|(
name|void
operator|)
name|ahc_loadseq
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
name|ahc_restart
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
comment|/* 				 * Unpaused.  The extra unpause 				 * that follows is harmless. 				 */
block|}
block|}
name|ahc_unpause
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ahc_update_scsiid
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|u_int
name|targid_mask
parameter_list|)
block|{
name|u_int
name|scsiid_mask
decl_stmt|;
name|u_int
name|scsiid
decl_stmt|;
if|if
condition|(
operator|(
name|ahc
operator|->
name|features
operator|&
name|AHC_MULTI_TID
operator|)
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"ahc_update_scsiid called on non-multitid unit\n"
argument_list|)
expr_stmt|;
comment|/* 	 * Since we will rely on the TARGID mask 	 * for selection enables, ensure that OID 	 * in SCSIID is not set to some other ID 	 * that we don't want to allow selections on. 	 */
if|if
condition|(
operator|(
name|ahc
operator|->
name|features
operator|&
name|AHC_ULTRA2
operator|)
operator|!=
literal|0
condition|)
name|scsiid
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCSIID_ULTRA2
argument_list|)
expr_stmt|;
else|else
name|scsiid
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCSIID
argument_list|)
expr_stmt|;
name|scsiid_mask
operator|=
literal|0x1
operator|<<
operator|(
name|scsiid
operator|&
name|OID
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|targid_mask
operator|&
name|scsiid_mask
operator|)
operator|==
literal|0
condition|)
block|{
name|u_int
name|our_id
decl_stmt|;
comment|/* ffs counts from 1 */
name|our_id
operator|=
name|ffs
argument_list|(
name|targid_mask
argument_list|)
expr_stmt|;
if|if
condition|(
name|our_id
operator|==
literal|0
condition|)
name|our_id
operator|=
name|ahc
operator|->
name|our_id
expr_stmt|;
else|else
name|our_id
operator|--
expr_stmt|;
name|scsiid
operator|&=
name|TID
expr_stmt|;
name|scsiid
operator||=
name|our_id
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|ahc
operator|->
name|features
operator|&
name|AHC_ULTRA2
operator|)
operator|!=
literal|0
condition|)
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCSIID_ULTRA2
argument_list|,
name|scsiid
argument_list|)
expr_stmt|;
else|else
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCSIID
argument_list|,
name|scsiid
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ahc_run_tqinfifo
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|int
name|paused
parameter_list|)
block|{
name|struct
name|target_cmd
modifier|*
name|cmd
decl_stmt|;
comment|/* 	 * If the card supports auto-access pause, 	 * we can access the card directly regardless 	 * of whether it is paused or not. 	 */
if|if
condition|(
operator|(
name|ahc
operator|->
name|features
operator|&
name|AHC_AUTOPAUSE
operator|)
operator|!=
literal|0
condition|)
name|paused
operator|=
name|TRUE
expr_stmt|;
name|ahc_sync_tqinfifo
argument_list|(
name|ahc
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|cmd
operator|=
operator|&
name|ahc
operator|->
name|targetcmds
index|[
name|ahc
operator|->
name|tqinfifonext
index|]
operator|)
operator|->
name|cmd_valid
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * Only advance through the queue if we 		 * have the resources to process the command. 		 */
if|if
condition|(
name|ahc_handle_target_cmd
argument_list|(
name|ahc
argument_list|,
name|cmd
argument_list|)
operator|!=
literal|0
condition|)
break|break;
name|cmd
operator|->
name|cmd_valid
operator|=
literal|0
expr_stmt|;
name|aic_dmamap_sync
argument_list|(
name|ahc
argument_list|,
name|ahc
operator|->
name|shared_data_dmat
argument_list|,
name|ahc
operator|->
name|shared_data_dmamap
argument_list|,
name|ahc_targetcmd_offset
argument_list|(
name|ahc
argument_list|,
name|ahc
operator|->
name|tqinfifonext
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|target_cmd
argument_list|)
argument_list|,
name|BUS_DMASYNC_PREREAD
argument_list|)
expr_stmt|;
name|ahc
operator|->
name|tqinfifonext
operator|++
expr_stmt|;
comment|/* 		 * Lazily update our position in the target mode incoming 		 * command queue as seen by the sequencer. 		 */
if|if
condition|(
operator|(
name|ahc
operator|->
name|tqinfifonext
operator|&
operator|(
name|HOST_TQINPOS
operator|-
literal|1
operator|)
operator|)
operator|==
literal|1
condition|)
block|{
if|if
condition|(
operator|(
name|ahc
operator|->
name|features
operator|&
name|AHC_HS_MAILBOX
operator|)
operator|!=
literal|0
condition|)
block|{
name|u_int
name|hs_mailbox
decl_stmt|;
name|hs_mailbox
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|HS_MAILBOX
argument_list|)
expr_stmt|;
name|hs_mailbox
operator|&=
operator|~
name|HOST_TQINPOS
expr_stmt|;
name|hs_mailbox
operator||=
name|ahc
operator|->
name|tqinfifonext
operator|&
name|HOST_TQINPOS
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|HS_MAILBOX
argument_list|,
name|hs_mailbox
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|paused
condition|)
name|ahc_pause
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|KERNEL_TQINPOS
argument_list|,
name|ahc
operator|->
name|tqinfifonext
operator|&
name|HOST_TQINPOS
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|paused
condition|)
name|ahc_unpause
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|ahc_handle_target_cmd
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|struct
name|target_cmd
modifier|*
name|cmd
parameter_list|)
block|{
name|struct
name|ahc_tmode_tstate
modifier|*
name|tstate
decl_stmt|;
name|struct
name|ahc_tmode_lstate
modifier|*
name|lstate
decl_stmt|;
name|struct
name|ccb_accept_tio
modifier|*
name|atio
decl_stmt|;
name|uint8_t
modifier|*
name|byte
decl_stmt|;
name|int
name|initiator
decl_stmt|;
name|int
name|target
decl_stmt|;
name|int
name|lun
decl_stmt|;
name|initiator
operator|=
name|SCSIID_TARGET
argument_list|(
name|ahc
argument_list|,
name|cmd
operator|->
name|scsiid
argument_list|)
expr_stmt|;
name|target
operator|=
name|SCSIID_OUR_ID
argument_list|(
name|cmd
operator|->
name|scsiid
argument_list|)
expr_stmt|;
name|lun
operator|=
operator|(
name|cmd
operator|->
name|identify
operator|&
name|MSG_IDENTIFY_LUNMASK
operator|)
expr_stmt|;
name|byte
operator|=
name|cmd
operator|->
name|bytes
expr_stmt|;
name|tstate
operator|=
name|ahc
operator|->
name|enabled_targets
index|[
name|target
index|]
expr_stmt|;
name|lstate
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|tstate
operator|!=
name|NULL
condition|)
name|lstate
operator|=
name|tstate
operator|->
name|enabled_luns
index|[
name|lun
index|]
expr_stmt|;
comment|/* 	 * Commands for disabled luns go to the black hole driver. 	 */
if|if
condition|(
name|lstate
operator|==
name|NULL
condition|)
name|lstate
operator|=
name|ahc
operator|->
name|black_hole
expr_stmt|;
name|atio
operator|=
operator|(
expr|struct
name|ccb_accept_tio
operator|*
operator|)
name|SLIST_FIRST
argument_list|(
operator|&
name|lstate
operator|->
name|accept_tios
argument_list|)
expr_stmt|;
if|if
condition|(
name|atio
operator|==
name|NULL
condition|)
block|{
name|ahc
operator|->
name|flags
operator||=
name|AHC_TQINFIFO_BLOCKED
expr_stmt|;
comment|/* 		 * Wait for more ATIOs from the peripheral driver for this lun. 		 */
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"%s: ATIOs exhausted\n"
argument_list|,
name|ahc_name
argument_list|(
name|ahc
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
else|else
name|ahc
operator|->
name|flags
operator|&=
operator|~
name|AHC_TQINFIFO_BLOCKED
expr_stmt|;
ifdef|#
directive|ifdef
name|AHC_DEBUG
if|if
condition|(
name|ahc_debug
operator|&
name|AHC_SHOW_TQIN
condition|)
block|{
name|printf
argument_list|(
literal|"Incoming command from %d for %d:%d%s\n"
argument_list|,
name|initiator
argument_list|,
name|target
argument_list|,
name|lun
argument_list|,
name|lstate
operator|==
name|ahc
operator|->
name|black_hole
condition|?
literal|"(Black Holed)"
else|:
literal|""
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|SLIST_REMOVE_HEAD
argument_list|(
operator|&
name|lstate
operator|->
name|accept_tios
argument_list|,
name|sim_links
operator|.
name|sle
argument_list|)
expr_stmt|;
if|if
condition|(
name|lstate
operator|==
name|ahc
operator|->
name|black_hole
condition|)
block|{
comment|/* Fill in the wildcards */
name|atio
operator|->
name|ccb_h
operator|.
name|target_id
operator|=
name|target
expr_stmt|;
name|atio
operator|->
name|ccb_h
operator|.
name|target_lun
operator|=
name|lun
expr_stmt|;
block|}
comment|/* 	 * Package it up and send it off to 	 * whomever has this lun enabled. 	 */
name|atio
operator|->
name|sense_len
operator|=
literal|0
expr_stmt|;
name|atio
operator|->
name|init_id
operator|=
name|initiator
expr_stmt|;
if|if
condition|(
name|byte
index|[
literal|0
index|]
operator|!=
literal|0xFF
condition|)
block|{
comment|/* Tag was included */
name|atio
operator|->
name|tag_action
operator|=
operator|*
name|byte
operator|++
expr_stmt|;
name|atio
operator|->
name|tag_id
operator|=
operator|*
name|byte
operator|++
expr_stmt|;
name|atio
operator|->
name|ccb_h
operator|.
name|flags
operator|=
name|CAM_TAG_ACTION_VALID
expr_stmt|;
block|}
else|else
block|{
name|atio
operator|->
name|ccb_h
operator|.
name|flags
operator|=
literal|0
expr_stmt|;
block|}
name|byte
operator|++
expr_stmt|;
comment|/* Okay.  Now determine the cdb size based on the command code */
switch|switch
condition|(
operator|*
name|byte
operator|>>
name|CMD_GROUP_CODE_SHIFT
condition|)
block|{
case|case
literal|0
case|:
name|atio
operator|->
name|cdb_len
operator|=
literal|6
expr_stmt|;
break|break;
case|case
literal|1
case|:
case|case
literal|2
case|:
name|atio
operator|->
name|cdb_len
operator|=
literal|10
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|atio
operator|->
name|cdb_len
operator|=
literal|16
expr_stmt|;
break|break;
case|case
literal|5
case|:
name|atio
operator|->
name|cdb_len
operator|=
literal|12
expr_stmt|;
break|break;
case|case
literal|3
case|:
default|default:
comment|/* Only copy the opcode. */
name|atio
operator|->
name|cdb_len
operator|=
literal|1
expr_stmt|;
name|printf
argument_list|(
literal|"Reserved or VU command code type encountered\n"
argument_list|)
expr_stmt|;
break|break;
block|}
name|memcpy
argument_list|(
name|atio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
argument_list|,
name|byte
argument_list|,
name|atio
operator|->
name|cdb_len
argument_list|)
expr_stmt|;
name|atio
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_CDB_RECVD
expr_stmt|;
if|if
condition|(
operator|(
name|cmd
operator|->
name|identify
operator|&
name|MSG_IDENTIFY_DISCFLAG
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 		 * We weren't allowed to disconnect. 		 * We're hanging on the bus until a 		 * continue target I/O comes in response 		 * to this accept tio. 		 */
ifdef|#
directive|ifdef
name|AHC_DEBUG
if|if
condition|(
name|ahc_debug
operator|&
name|AHC_SHOW_TQIN
condition|)
block|{
name|printf
argument_list|(
literal|"Received Immediate Command %d:%d:%d - %p\n"
argument_list|,
name|initiator
argument_list|,
name|target
argument_list|,
name|lun
argument_list|,
name|ahc
operator|->
name|pending_device
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|ahc
operator|->
name|pending_device
operator|=
name|lstate
expr_stmt|;
name|aic_freeze_ccb
argument_list|(
operator|(
expr|union
name|ccb
operator|*
operator|)
name|atio
argument_list|)
expr_stmt|;
name|atio
operator|->
name|ccb_h
operator|.
name|flags
operator||=
name|CAM_DIS_DISCONNECT
expr_stmt|;
block|}
name|xpt_done
argument_list|(
operator|(
expr|union
name|ccb
operator|*
operator|)
name|atio
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

