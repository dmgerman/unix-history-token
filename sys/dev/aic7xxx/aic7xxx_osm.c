begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Bus independent FreeBSD shim for the aic7xxx based adaptec SCSI controllers  *  * Copyright (c) 1994, 1995, 1996, 1997, 1998, 1999, 2000 Justin T. Gibbs.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions, and the following disclaimer,  *    without modification.  * 2. The name of the author may not be used to endorse or promote products  *    derived from this software without specific prior written permission.  *  * Alternatively, this software may be distributed under the terms of the  * GNU Public License ("GPL").  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE FOR  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $Id$  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|<dev/aic7xxx/aic7xxx_freebsd.h>
end_include

begin_include
include|#
directive|include
file|<dev/aic7xxx/aic7xxx_inline.h>
end_include

begin_include
include|#
directive|include
file|<sys/eventhandler.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|AHC_TMODE_ENABLE
end_ifndef

begin_define
define|#
directive|define
name|AHC_TMODE_ENABLE
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|ccb_scb_ptr
value|spriv_ptr0
end_define

begin_define
define|#
directive|define
name|ccb_ahc_ptr
value|spriv_ptr1
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|AHC_DEBUG
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|ahc_debug
init|=
name|AHC_DEBUG
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|ahc_freebsd_intr
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_if
if|#
directive|if
name|UNUSED
end_if

begin_function_decl
specifier|static
name|void
name|ahc_dump_targcmd
parameter_list|(
name|struct
name|target_cmd
modifier|*
name|cmd
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|ahc_action
parameter_list|(
name|struct
name|cam_sim
modifier|*
name|sim
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ahc_get_tran_settings
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|int
name|our_id
parameter_list|,
name|char
name|channel
parameter_list|,
name|struct
name|ccb_trans_settings
modifier|*
name|cts
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ahc_async
parameter_list|(
name|void
modifier|*
name|callback_arg
parameter_list|,
name|uint32_t
name|code
parameter_list|,
name|struct
name|cam_path
modifier|*
name|path
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ahc_execute_scb
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|dm_segs
parameter_list|,
name|int
name|nsegments
parameter_list|,
name|int
name|error
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ahc_poll
parameter_list|(
name|struct
name|cam_sim
modifier|*
name|sim
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ahc_setup_data
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|struct
name|cam_sim
modifier|*
name|sim
parameter_list|,
name|struct
name|ccb_scsiio
modifier|*
name|csio
parameter_list|,
name|struct
name|scb
modifier|*
name|scb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ahc_abort_ccb
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|struct
name|cam_sim
modifier|*
name|sim
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ahc_create_path
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|char
name|channel
parameter_list|,
name|u_int
name|target
parameter_list|,
name|u_int
name|lun
parameter_list|,
name|struct
name|cam_path
modifier|*
modifier|*
name|path
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ahc_set_recoveryscb
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|struct
name|scb
modifier|*
name|scb
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|int
name|ahc_create_path
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|char
name|channel
parameter_list|,
name|u_int
name|target
parameter_list|,
name|u_int
name|lun
parameter_list|,
name|struct
name|cam_path
modifier|*
modifier|*
name|path
parameter_list|)
block|{
name|path_id_t
name|path_id
decl_stmt|;
if|if
condition|(
name|channel
operator|==
literal|'B'
condition|)
name|path_id
operator|=
name|cam_sim_path
argument_list|(
name|ahc
operator|->
name|platform_data
operator|->
name|sim_b
argument_list|)
expr_stmt|;
else|else
name|path_id
operator|=
name|cam_sim_path
argument_list|(
name|ahc
operator|->
name|platform_data
operator|->
name|sim
argument_list|)
expr_stmt|;
return|return
operator|(
name|xpt_create_path
argument_list|(
name|path
argument_list|,
comment|/*periph*/
name|NULL
argument_list|,
name|path_id
argument_list|,
name|target
argument_list|,
name|lun
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Attach all the sub-devices we can find  */
end_comment

begin_function
name|int
name|ahc_attach
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|)
block|{
name|char
name|ahc_info
index|[
literal|256
index|]
decl_stmt|;
name|struct
name|ccb_setasync
name|csa
decl_stmt|;
name|struct
name|cam_devq
modifier|*
name|devq
decl_stmt|;
name|int
name|bus_id
decl_stmt|;
name|int
name|bus_id2
decl_stmt|;
name|struct
name|cam_sim
modifier|*
name|sim
decl_stmt|;
name|struct
name|cam_sim
modifier|*
name|sim2
decl_stmt|;
name|struct
name|cam_path
modifier|*
name|path
decl_stmt|;
name|struct
name|cam_path
modifier|*
name|path2
decl_stmt|;
name|long
name|s
decl_stmt|;
name|int
name|count
decl_stmt|;
name|int
name|error
decl_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
name|sim
operator|=
name|NULL
expr_stmt|;
name|sim2
operator|=
name|NULL
expr_stmt|;
name|ahc_controller_info
argument_list|(
name|ahc
argument_list|,
name|ahc_info
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|ahc_info
argument_list|)
expr_stmt|;
name|ahc_lock
argument_list|(
name|ahc
argument_list|,
operator|&
name|s
argument_list|)
expr_stmt|;
comment|/* Hook up our interrupt handler */
if|if
condition|(
operator|(
name|error
operator|=
name|bus_setup_intr
argument_list|(
name|ahc
operator|->
name|dev_softc
argument_list|,
name|ahc
operator|->
name|platform_data
operator|->
name|irq
argument_list|,
name|INTR_TYPE_CAM
argument_list|,
name|ahc_freebsd_intr
argument_list|,
name|ahc
argument_list|,
operator|&
name|ahc
operator|->
name|platform_data
operator|->
name|ih
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|ahc
operator|->
name|dev_softc
argument_list|,
literal|"bus_setup_intr() failed: %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* 	 * Attach secondary channel first if the user has 	 * declared it the primary channel. 	 */
if|if
condition|(
operator|(
name|ahc
operator|->
name|flags
operator|&
name|AHC_CHANNEL_B_PRIMARY
operator|)
operator|!=
literal|0
condition|)
block|{
name|bus_id
operator|=
literal|1
expr_stmt|;
name|bus_id2
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|bus_id
operator|=
literal|0
expr_stmt|;
name|bus_id2
operator|=
literal|1
expr_stmt|;
block|}
comment|/* 	 * Create the device queue for our SIM(s). 	 */
name|devq
operator|=
name|cam_simq_alloc
argument_list|(
name|AHC_SCB_MAX
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|devq
operator|==
name|NULL
condition|)
goto|goto
name|fail
goto|;
comment|/* 	 * Construct our first channel SIM entry 	 */
name|sim
operator|=
name|cam_sim_alloc
argument_list|(
name|ahc_action
argument_list|,
name|ahc_poll
argument_list|,
literal|"ahc"
argument_list|,
name|ahc
argument_list|,
name|device_get_unit
argument_list|(
name|ahc
operator|->
name|dev_softc
argument_list|)
argument_list|,
literal|1
argument_list|,
name|AHC_SCB_MAX
operator|-
literal|1
argument_list|,
name|devq
argument_list|)
expr_stmt|;
if|if
condition|(
name|sim
operator|==
name|NULL
condition|)
block|{
name|cam_simq_free
argument_list|(
name|devq
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
if|if
condition|(
name|xpt_bus_register
argument_list|(
name|sim
argument_list|,
name|bus_id
argument_list|)
operator|!=
name|CAM_SUCCESS
condition|)
block|{
name|cam_sim_free
argument_list|(
name|sim
argument_list|,
comment|/*free_devq*/
name|TRUE
argument_list|)
expr_stmt|;
name|sim
operator|=
name|NULL
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
if|if
condition|(
name|xpt_create_path
argument_list|(
operator|&
name|path
argument_list|,
comment|/*periph*/
name|NULL
argument_list|,
name|cam_sim_path
argument_list|(
name|sim
argument_list|)
argument_list|,
name|CAM_TARGET_WILDCARD
argument_list|,
name|CAM_LUN_WILDCARD
argument_list|)
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|xpt_bus_deregister
argument_list|(
name|cam_sim_path
argument_list|(
name|sim
argument_list|)
argument_list|)
expr_stmt|;
name|cam_sim_free
argument_list|(
name|sim
argument_list|,
comment|/*free_devq*/
name|TRUE
argument_list|)
expr_stmt|;
name|sim
operator|=
name|NULL
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|xpt_setup_ccb
argument_list|(
operator|&
name|csa
operator|.
name|ccb_h
argument_list|,
name|path
argument_list|,
comment|/*priority*/
literal|5
argument_list|)
expr_stmt|;
name|csa
operator|.
name|ccb_h
operator|.
name|func_code
operator|=
name|XPT_SASYNC_CB
expr_stmt|;
name|csa
operator|.
name|event_enable
operator|=
name|AC_LOST_DEVICE
expr_stmt|;
name|csa
operator|.
name|callback
operator|=
name|ahc_async
expr_stmt|;
name|csa
operator|.
name|callback_arg
operator|=
name|sim
expr_stmt|;
name|xpt_action
argument_list|(
operator|(
expr|union
name|ccb
operator|*
operator|)
operator|&
name|csa
argument_list|)
expr_stmt|;
name|count
operator|++
expr_stmt|;
if|if
condition|(
name|ahc
operator|->
name|features
operator|&
name|AHC_TWIN
condition|)
block|{
name|sim2
operator|=
name|cam_sim_alloc
argument_list|(
name|ahc_action
argument_list|,
name|ahc_poll
argument_list|,
literal|"ahc"
argument_list|,
name|ahc
argument_list|,
name|device_get_unit
argument_list|(
name|ahc
operator|->
name|dev_softc
argument_list|)
argument_list|,
literal|1
argument_list|,
name|AHC_SCB_MAX
operator|-
literal|1
argument_list|,
name|devq
argument_list|)
expr_stmt|;
if|if
condition|(
name|sim2
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"ahc_attach: Unable to attach second "
literal|"bus due to resource shortage"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
if|if
condition|(
name|xpt_bus_register
argument_list|(
name|sim2
argument_list|,
name|bus_id2
argument_list|)
operator|!=
name|CAM_SUCCESS
condition|)
block|{
name|printf
argument_list|(
literal|"ahc_attach: Unable to attach second "
literal|"bus due to resource shortage"
argument_list|)
expr_stmt|;
comment|/* 			 * We do not want to destroy the device queue 			 * because the first bus is using it. 			 */
name|cam_sim_free
argument_list|(
name|sim2
argument_list|,
comment|/*free_devq*/
name|FALSE
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
if|if
condition|(
name|xpt_create_path
argument_list|(
operator|&
name|path2
argument_list|,
comment|/*periph*/
name|NULL
argument_list|,
name|cam_sim_path
argument_list|(
name|sim2
argument_list|)
argument_list|,
name|CAM_TARGET_WILDCARD
argument_list|,
name|CAM_LUN_WILDCARD
argument_list|)
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|xpt_bus_deregister
argument_list|(
name|cam_sim_path
argument_list|(
name|sim2
argument_list|)
argument_list|)
expr_stmt|;
name|cam_sim_free
argument_list|(
name|sim2
argument_list|,
comment|/*free_devq*/
name|FALSE
argument_list|)
expr_stmt|;
name|sim2
operator|=
name|NULL
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|xpt_setup_ccb
argument_list|(
operator|&
name|csa
operator|.
name|ccb_h
argument_list|,
name|path2
argument_list|,
comment|/*priority*/
literal|5
argument_list|)
expr_stmt|;
name|csa
operator|.
name|ccb_h
operator|.
name|func_code
operator|=
name|XPT_SASYNC_CB
expr_stmt|;
name|csa
operator|.
name|event_enable
operator|=
name|AC_LOST_DEVICE
expr_stmt|;
name|csa
operator|.
name|callback
operator|=
name|ahc_async
expr_stmt|;
name|csa
operator|.
name|callback_arg
operator|=
name|sim2
expr_stmt|;
name|xpt_action
argument_list|(
operator|(
expr|union
name|ccb
operator|*
operator|)
operator|&
name|csa
argument_list|)
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
name|fail
label|:
if|if
condition|(
operator|(
name|ahc
operator|->
name|flags
operator|&
name|AHC_CHANNEL_B_PRIMARY
operator|)
operator|!=
literal|0
condition|)
block|{
name|ahc
operator|->
name|platform_data
operator|->
name|sim_b
operator|=
name|sim
expr_stmt|;
name|ahc
operator|->
name|platform_data
operator|->
name|path_b
operator|=
name|path
expr_stmt|;
name|ahc
operator|->
name|platform_data
operator|->
name|sim
operator|=
name|sim2
expr_stmt|;
name|ahc
operator|->
name|platform_data
operator|->
name|path
operator|=
name|path2
expr_stmt|;
block|}
else|else
block|{
name|ahc
operator|->
name|platform_data
operator|->
name|sim
operator|=
name|sim
expr_stmt|;
name|ahc
operator|->
name|platform_data
operator|->
name|path
operator|=
name|path
expr_stmt|;
name|ahc
operator|->
name|platform_data
operator|->
name|sim_b
operator|=
name|sim2
expr_stmt|;
name|ahc
operator|->
name|platform_data
operator|->
name|path_b
operator|=
name|path2
expr_stmt|;
block|}
name|ahc_unlock
argument_list|(
name|ahc
argument_list|,
operator|&
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|!=
literal|0
condition|)
comment|/* We have to wait until after any system dumps... */
name|EVENTHANDLER_REGISTER
argument_list|(
name|shutdown_final
argument_list|,
name|ahc_shutdown
argument_list|,
name|ahc
argument_list|,
name|SHUTDOWN_PRI_DEFAULT
argument_list|)
expr_stmt|;
return|return
operator|(
name|count
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Catch an interrupt from the adapter  */
end_comment

begin_function
name|void
name|ahc_freebsd_intr
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ahc_softc
modifier|*
name|ahc
decl_stmt|;
name|ahc
operator|=
operator|(
expr|struct
name|ahc_softc
operator|*
operator|)
name|arg
expr_stmt|;
name|ahc_intr
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * We have an scb which has been processed by the  * adaptor, now we look to see how the operation  * went.  */
end_comment

begin_function
name|void
name|ahc_done
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|struct
name|scb
modifier|*
name|scb
parameter_list|)
block|{
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|CAM_DEBUG
argument_list|(
name|scb
operator|->
name|io_ctx
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
name|CAM_DEBUG_TRACE
argument_list|,
operator|(
literal|"ahc_done - scb %d\n"
operator|,
name|scb
operator|->
name|hscb
operator|->
name|tag
operator|)
argument_list|)
expr_stmt|;
name|ccb
operator|=
name|scb
operator|->
name|io_ctx
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|scb
argument_list|,
name|pending_links
argument_list|)
expr_stmt|;
if|if
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|==
name|XPT_SCSI_IO
operator|&&
operator|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_TAG_ACTION_VALID
operator|)
operator|==
literal|0
operator|||
name|ccb
operator|->
name|csio
operator|.
name|tag_action
operator|==
name|CAM_TAG_ACTION_NONE
operator|)
operator|&&
operator|(
name|ahc
operator|->
name|features
operator|&
name|AHC_SCB_BTT
operator|)
operator|==
literal|0
condition|)
block|{
name|struct
name|scb_tailq
modifier|*
name|untagged_q
decl_stmt|;
name|untagged_q
operator|=
operator|&
name|ahc
operator|->
name|untagged_queues
index|[
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
index|]
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
name|untagged_q
argument_list|,
name|scb
argument_list|,
name|links
operator|.
name|tqe
argument_list|)
expr_stmt|;
name|ahc_run_untagged_queue
argument_list|(
name|ahc
argument_list|,
name|untagged_q
argument_list|)
expr_stmt|;
block|}
name|untimeout
argument_list|(
name|ahc_timeout
argument_list|,
operator|(
name|caddr_t
operator|)
name|scb
argument_list|,
name|ccb
operator|->
name|ccb_h
operator|.
name|timeout_ch
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DIR_MASK
operator|)
operator|!=
name|CAM_DIR_NONE
condition|)
block|{
name|bus_dmasync_op_t
name|op
decl_stmt|;
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DIR_MASK
operator|)
operator|==
name|CAM_DIR_IN
condition|)
name|op
operator|=
name|BUS_DMASYNC_POSTREAD
expr_stmt|;
else|else
name|op
operator|=
name|BUS_DMASYNC_POSTWRITE
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|ahc
operator|->
name|buffer_dmat
argument_list|,
name|scb
operator|->
name|dmamap
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|ahc
operator|->
name|buffer_dmat
argument_list|,
name|scb
operator|->
name|dmamap
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|==
name|XPT_CONT_TARGET_IO
condition|)
block|{
if|if
condition|(
name|ahc_get_transaction_status
argument_list|(
name|scb
argument_list|)
operator|==
name|CAM_REQ_INPROG
condition|)
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_REQ_CMP
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&=
operator|~
name|CAM_SIM_QUEUED
expr_stmt|;
name|ahc_free_scb
argument_list|(
name|ahc
argument_list|,
name|scb
argument_list|)
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * If the recovery SCB completes, we have to be 	 * out of our timeout. 	 */
if|if
condition|(
operator|(
name|scb
operator|->
name|flags
operator|&
name|SCB_RECOVERY_SCB
operator|)
operator|!=
literal|0
condition|)
block|{
name|struct
name|scb
modifier|*
name|list_scb
decl_stmt|;
comment|/* 		 * We were able to complete the command successfully, 		 * so reinstate the timeouts for all other pending 		 * commands. 		 */
name|LIST_FOREACH
argument_list|(
argument|list_scb
argument_list|,
argument|&ahc->pending_scbs
argument_list|,
argument|pending_links
argument_list|)
block|{
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|ccb
operator|=
name|list_scb
operator|->
name|io_ctx
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|timeout_ch
operator|=
name|timeout
argument_list|(
name|ahc_timeout
argument_list|,
name|list_scb
argument_list|,
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|timeout
operator|*
name|hz
operator|)
operator|/
literal|1000
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Ensure that we didn't put a second instance of this 		 * SCB into the QINFIFO. 		 */
name|ahc_search_qinfifo
argument_list|(
name|ahc
argument_list|,
name|SCB_GET_TARGET
argument_list|(
name|ahc
argument_list|,
name|scb
argument_list|)
argument_list|,
name|SCB_GET_CHANNEL
argument_list|(
name|ahc
argument_list|,
name|scb
argument_list|)
argument_list|,
name|SCB_GET_LUN
argument_list|(
name|scb
argument_list|)
argument_list|,
name|scb
operator|->
name|hscb
operator|->
name|tag
argument_list|,
name|ROLE_INITIATOR
argument_list|,
comment|/*status*/
literal|0
argument_list|,
name|SEARCH_REMOVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|ahc_get_transaction_status
argument_list|(
name|scb
argument_list|)
operator|==
name|CAM_BDR_SENT
operator|||
name|ahc_get_transaction_status
argument_list|(
name|scb
argument_list|)
operator|==
name|CAM_REQ_ABORTED
condition|)
name|ahc_set_transaction_status
argument_list|(
name|scb
argument_list|,
name|CAM_CMD_TIMEOUT
argument_list|)
expr_stmt|;
name|ahc_print_path
argument_list|(
name|ahc
argument_list|,
name|scb
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"no longer in timeout, status = %x\n"
argument_list|,
name|ccb
operator|->
name|ccb_h
operator|.
name|status
argument_list|)
expr_stmt|;
block|}
comment|/* Don't clobber any existing error state */
if|if
condition|(
name|ahc_get_transaction_status
argument_list|(
name|scb
argument_list|)
operator|==
name|CAM_REQ_INPROG
condition|)
block|{
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_REQ_CMP
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|scb
operator|->
name|flags
operator|&
name|SCB_SENSE
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * We performed autosense retrieval. 		 * 		 * Zero any sense not transferred by the 		 * device.  The SCSI spec mandates that any 		 * untransfered data should be assumed to be 		 * zero.  Complete the 'bounce' of sense information 		 * through buffers accessible via bus-space by 		 * copying it into the clients csio. 		 */
name|memset
argument_list|(
operator|&
name|ccb
operator|->
name|csio
operator|.
name|sense_data
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ccb
operator|->
name|csio
operator|.
name|sense_data
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|ccb
operator|->
name|csio
operator|.
name|sense_data
argument_list|,
operator|&
name|ahc
operator|->
name|scb_data
operator|->
name|sense
index|[
name|scb
operator|->
name|hscb
operator|->
name|tag
index|]
argument_list|,
operator|(
name|scb
operator|->
name|sg_list
operator|->
name|len
operator|&
name|AHC_SG_LEN_MASK
operator|)
operator|-
name|ccb
operator|->
name|csio
operator|.
name|sense_resid
argument_list|)
expr_stmt|;
name|scb
operator|->
name|io_ctx
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_AUTOSNS_VALID
expr_stmt|;
block|}
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&=
operator|~
name|CAM_SIM_QUEUED
expr_stmt|;
name|ahc_free_scb
argument_list|(
name|ahc
argument_list|,
name|scb
argument_list|)
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ahc_action
parameter_list|(
name|struct
name|cam_sim
modifier|*
name|sim
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
block|{
name|struct
name|ahc_softc
modifier|*
name|ahc
decl_stmt|;
name|struct
name|tmode_lstate
modifier|*
name|lstate
decl_stmt|;
name|u_int
name|target_id
decl_stmt|;
name|u_int
name|our_id
decl_stmt|;
name|long
name|s
decl_stmt|;
name|CAM_DEBUG
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
name|CAM_DEBUG_TRACE
argument_list|,
operator|(
literal|"ahc_action\n"
operator|)
argument_list|)
expr_stmt|;
name|ahc
operator|=
operator|(
expr|struct
name|ahc_softc
operator|*
operator|)
name|cam_sim_softc
argument_list|(
name|sim
argument_list|)
expr_stmt|;
name|target_id
operator|=
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
expr_stmt|;
name|our_id
operator|=
name|SIM_SCSI_ID
argument_list|(
name|ahc
argument_list|,
name|sim
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
condition|)
block|{
comment|/* Common cases first */
case|case
name|XPT_ACCEPT_TARGET_IO
case|:
comment|/* Accept Host Target Mode CDB */
case|case
name|XPT_CONT_TARGET_IO
case|:
comment|/* Continue Host Target I/O Connection*/
block|{
name|struct
name|tmode_tstate
modifier|*
name|tstate
decl_stmt|;
name|cam_status
name|status
decl_stmt|;
name|status
operator|=
name|ahc_find_tmode_devs
argument_list|(
name|ahc
argument_list|,
name|sim
argument_list|,
name|ccb
argument_list|,
operator|&
name|tstate
argument_list|,
operator|&
name|lstate
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
if|if
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|==
name|XPT_CONT_TARGET_IO
condition|)
block|{
comment|/* Response from the black hole device */
name|tstate
operator|=
name|NULL
expr_stmt|;
name|lstate
operator|=
name|ahc
operator|->
name|black_hole
expr_stmt|;
block|}
else|else
block|{
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|status
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|==
name|XPT_ACCEPT_TARGET_IO
condition|)
block|{
name|ahc_lock
argument_list|(
name|ahc
argument_list|,
operator|&
name|s
argument_list|)
expr_stmt|;
name|SLIST_INSERT_HEAD
argument_list|(
operator|&
name|lstate
operator|->
name|accept_tios
argument_list|,
operator|&
name|ccb
operator|->
name|ccb_h
argument_list|,
name|sim_links
operator|.
name|sle
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_INPROG
expr_stmt|;
if|if
condition|(
operator|(
name|ahc
operator|->
name|flags
operator|&
name|AHC_TQINFIFO_BLOCKED
operator|)
operator|!=
literal|0
condition|)
name|ahc_run_tqinfifo
argument_list|(
name|ahc
argument_list|,
comment|/*paused*/
name|FALSE
argument_list|)
expr_stmt|;
name|ahc_unlock
argument_list|(
name|ahc
argument_list|,
operator|&
name|s
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* 		 * The target_id represents the target we attempt to 		 * select.  In target mode, this is the initiator of 		 * the original command. 		 */
name|our_id
operator|=
name|target_id
expr_stmt|;
name|target_id
operator|=
name|ccb
operator|->
name|csio
operator|.
name|init_id
expr_stmt|;
comment|/* FALLTHROUGH */
block|}
case|case
name|XPT_SCSI_IO
case|:
comment|/* Execute the requested I/O operation */
case|case
name|XPT_RESET_DEV
case|:
comment|/* Bus Device Reset the specified SCSI device */
block|{
name|struct
name|scb
modifier|*
name|scb
decl_stmt|;
name|struct
name|hardware_scb
modifier|*
name|hscb
decl_stmt|;
comment|/* 		 * get an scb to use. 		 */
name|ahc_lock
argument_list|(
name|ahc
argument_list|,
operator|&
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|scb
operator|=
name|ahc_get_scb
argument_list|(
name|ahc
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|ahc
operator|->
name|flags
operator||=
name|AHC_RESOURCE_SHORTAGE
expr_stmt|;
name|ahc_unlock
argument_list|(
name|ahc
argument_list|,
operator|&
name|s
argument_list|)
expr_stmt|;
name|xpt_freeze_simq
argument_list|(
name|sim
argument_list|,
comment|/*count*/
literal|1
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQUEUE_REQ
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return;
block|}
name|ahc_unlock
argument_list|(
name|ahc
argument_list|,
operator|&
name|s
argument_list|)
expr_stmt|;
name|hscb
operator|=
name|scb
operator|->
name|hscb
expr_stmt|;
name|CAM_DEBUG
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
name|CAM_DEBUG_SUBTRACE
argument_list|,
operator|(
literal|"start scb(%p)\n"
operator|,
name|scb
operator|)
argument_list|)
expr_stmt|;
name|scb
operator|->
name|io_ctx
operator|=
name|ccb
expr_stmt|;
comment|/* 		 * So we can find the SCB when an abort is requested 		 */
name|ccb
operator|->
name|ccb_h
operator|.
name|ccb_scb_ptr
operator|=
name|scb
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|ccb_ahc_ptr
operator|=
name|ahc
expr_stmt|;
comment|/* 		 * Put all the arguments for the xfer in the scb 		 */
name|hscb
operator|->
name|control
operator|=
literal|0
expr_stmt|;
name|hscb
operator|->
name|scsiid
operator|=
name|BUILD_SCSIID
argument_list|(
name|ahc
argument_list|,
name|sim
argument_list|,
name|target_id
argument_list|,
name|our_id
argument_list|)
expr_stmt|;
name|hscb
operator|->
name|lun
operator|=
name|ccb
operator|->
name|ccb_h
operator|.
name|target_lun
expr_stmt|;
if|if
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|==
name|XPT_RESET_DEV
condition|)
block|{
name|hscb
operator|->
name|cdb_len
operator|=
literal|0
expr_stmt|;
name|scb
operator|->
name|flags
operator||=
name|SCB_DEVICE_RESET
expr_stmt|;
name|hscb
operator|->
name|control
operator||=
name|MK_MESSAGE
expr_stmt|;
name|ahc_execute_scb
argument_list|(
name|scb
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|==
name|XPT_CONT_TARGET_IO
condition|)
block|{
name|struct
name|target_data
modifier|*
name|tdata
decl_stmt|;
name|tdata
operator|=
operator|&
name|hscb
operator|->
name|shared_data
operator|.
name|tdata
expr_stmt|;
if|if
condition|(
name|ahc
operator|->
name|pending_device
operator|==
name|lstate
condition|)
block|{
name|scb
operator|->
name|flags
operator||=
name|SCB_TARGET_IMMEDIATE
expr_stmt|;
name|ahc
operator|->
name|pending_device
operator|=
name|NULL
expr_stmt|;
block|}
name|hscb
operator|->
name|control
operator||=
name|TARGET_SCB
expr_stmt|;
name|tdata
operator|->
name|target_phases
operator|=
name|IDENTIFY_SEEN
expr_stmt|;
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_SEND_STATUS
operator|)
operator|!=
literal|0
condition|)
block|{
name|tdata
operator|->
name|target_phases
operator||=
name|SPHASE_PENDING
expr_stmt|;
name|tdata
operator|->
name|scsi_status
operator|=
name|ccb
operator|->
name|csio
operator|.
name|scsi_status
expr_stmt|;
block|}
name|tdata
operator|->
name|initiator_tag
operator|=
name|ccb
operator|->
name|csio
operator|.
name|tag_id
expr_stmt|;
block|}
if|if
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_TAG_ACTION_VALID
condition|)
name|hscb
operator|->
name|control
operator||=
name|ccb
operator|->
name|csio
operator|.
name|tag_action
expr_stmt|;
name|ahc_setup_data
argument_list|(
name|ahc
argument_list|,
name|sim
argument_list|,
operator|&
name|ccb
operator|->
name|csio
argument_list|,
name|scb
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|XPT_NOTIFY_ACK
case|:
case|case
name|XPT_IMMED_NOTIFY
case|:
block|{
name|struct
name|tmode_tstate
modifier|*
name|tstate
decl_stmt|;
name|struct
name|tmode_lstate
modifier|*
name|lstate
decl_stmt|;
name|cam_status
name|status
decl_stmt|;
name|status
operator|=
name|ahc_find_tmode_devs
argument_list|(
name|ahc
argument_list|,
name|sim
argument_list|,
name|ccb
argument_list|,
operator|&
name|tstate
argument_list|,
operator|&
name|lstate
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|status
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
block|}
name|SLIST_INSERT_HEAD
argument_list|(
operator|&
name|lstate
operator|->
name|immed_notifies
argument_list|,
operator|&
name|ccb
operator|->
name|ccb_h
argument_list|,
name|sim_links
operator|.
name|sle
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_INPROG
expr_stmt|;
name|ahc_send_lstate_events
argument_list|(
name|ahc
argument_list|,
name|lstate
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|XPT_EN_LUN
case|:
comment|/* Enable LUN as a target */
name|ahc_handle_en_lun
argument_list|(
name|ahc
argument_list|,
name|sim
argument_list|,
name|ccb
argument_list|)
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
case|case
name|XPT_ABORT
case|:
comment|/* Abort the specified CCB */
block|{
name|ahc_abort_ccb
argument_list|(
name|ahc
argument_list|,
name|sim
argument_list|,
name|ccb
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|XPT_SET_TRAN_SETTINGS
case|:
block|{
ifdef|#
directive|ifdef
name|AHC_NEW_TRAN_SETTINGS
name|struct
name|ahc_devinfo
name|devinfo
decl_stmt|;
name|struct
name|ccb_trans_settings
modifier|*
name|cts
decl_stmt|;
name|struct
name|ccb_trans_settings_scsi
modifier|*
name|scsi
decl_stmt|;
name|struct
name|ccb_trans_settings_spi
modifier|*
name|spi
decl_stmt|;
name|struct
name|ahc_initiator_tinfo
modifier|*
name|tinfo
decl_stmt|;
name|struct
name|tmode_tstate
modifier|*
name|tstate
decl_stmt|;
name|uint16_t
modifier|*
name|discenable
decl_stmt|;
name|uint16_t
modifier|*
name|tagenable
decl_stmt|;
name|u_int
name|update_type
decl_stmt|;
name|cts
operator|=
operator|&
name|ccb
operator|->
name|cts
expr_stmt|;
name|scsi
operator|=
operator|&
name|cts
operator|->
name|proto_specific
operator|.
name|scsi
expr_stmt|;
name|spi
operator|=
operator|&
name|cts
operator|->
name|xport_specific
operator|.
name|spi
expr_stmt|;
name|ahc_compile_devinfo
argument_list|(
operator|&
name|devinfo
argument_list|,
name|SIM_SCSI_ID
argument_list|(
name|ahc
argument_list|,
name|sim
argument_list|)
argument_list|,
name|cts
operator|->
name|ccb_h
operator|.
name|target_id
argument_list|,
name|cts
operator|->
name|ccb_h
operator|.
name|target_lun
argument_list|,
name|SIM_CHANNEL
argument_list|(
name|ahc
argument_list|,
name|sim
argument_list|)
argument_list|,
name|ROLE_UNKNOWN
argument_list|)
expr_stmt|;
name|tinfo
operator|=
name|ahc_fetch_transinfo
argument_list|(
name|ahc
argument_list|,
name|devinfo
operator|.
name|channel
argument_list|,
name|devinfo
operator|.
name|our_scsiid
argument_list|,
name|devinfo
operator|.
name|target
argument_list|,
operator|&
name|tstate
argument_list|)
expr_stmt|;
name|update_type
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|cts
operator|->
name|type
operator|==
name|CTS_TYPE_CURRENT_SETTINGS
condition|)
block|{
name|update_type
operator||=
name|AHC_TRANS_GOAL
expr_stmt|;
name|discenable
operator|=
operator|&
name|tstate
operator|->
name|discenable
expr_stmt|;
name|tagenable
operator|=
operator|&
name|tstate
operator|->
name|tagenable
expr_stmt|;
name|tinfo
operator|->
name|current
operator|.
name|protocol_version
operator|=
name|cts
operator|->
name|protocol_version
expr_stmt|;
name|tinfo
operator|->
name|current
operator|.
name|transport_version
operator|=
name|cts
operator|->
name|transport_version
expr_stmt|;
name|tinfo
operator|->
name|goal
operator|.
name|protocol_version
operator|=
name|cts
operator|->
name|protocol_version
expr_stmt|;
name|tinfo
operator|->
name|goal
operator|.
name|transport_version
operator|=
name|cts
operator|->
name|transport_version
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cts
operator|->
name|type
operator|==
name|CTS_TYPE_USER_SETTINGS
condition|)
block|{
name|update_type
operator||=
name|AHC_TRANS_USER
expr_stmt|;
name|discenable
operator|=
operator|&
name|ahc
operator|->
name|user_discenable
expr_stmt|;
name|tagenable
operator|=
operator|&
name|ahc
operator|->
name|user_tagenable
expr_stmt|;
name|tinfo
operator|->
name|user
operator|.
name|protocol_version
operator|=
name|cts
operator|->
name|protocol_version
expr_stmt|;
name|tinfo
operator|->
name|user
operator|.
name|transport_version
operator|=
name|cts
operator|->
name|transport_version
expr_stmt|;
block|}
else|else
block|{
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_INVALID
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
block|}
name|ahc_lock
argument_list|(
name|ahc
argument_list|,
operator|&
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|spi
operator|->
name|valid
operator|&
name|CTS_SPI_VALID_DISC
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|spi
operator|->
name|flags
operator|&
name|CTS_SPI_FLAGS_DISC_ENB
operator|)
operator|!=
literal|0
condition|)
operator|*
name|discenable
operator||=
name|devinfo
operator|.
name|target_mask
expr_stmt|;
else|else
operator|*
name|discenable
operator|&=
operator|~
name|devinfo
operator|.
name|target_mask
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|scsi
operator|->
name|valid
operator|&
name|CTS_SCSI_VALID_TQ
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|scsi
operator|->
name|flags
operator|&
name|CTS_SCSI_FLAGS_TAG_ENB
operator|)
operator|!=
literal|0
condition|)
operator|*
name|tagenable
operator||=
name|devinfo
operator|.
name|target_mask
expr_stmt|;
else|else
operator|*
name|tagenable
operator|&=
operator|~
name|devinfo
operator|.
name|target_mask
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|spi
operator|->
name|valid
operator|&
name|CTS_SPI_VALID_BUS_WIDTH
operator|)
operator|!=
literal|0
condition|)
block|{
name|ahc_validate_width
argument_list|(
name|ahc
argument_list|,
operator|&
name|spi
operator|->
name|bus_width
argument_list|)
expr_stmt|;
name|ahc_set_width
argument_list|(
name|ahc
argument_list|,
operator|&
name|devinfo
argument_list|,
name|spi
operator|->
name|bus_width
argument_list|,
name|update_type
argument_list|,
comment|/*paused*/
name|FALSE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|spi
operator|->
name|valid
operator|&
name|CTS_SPI_VALID_PPR_OPTIONS
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|update_type
operator|==
name|AHC_TRANS_USER
condition|)
name|spi
operator|->
name|ppr_options
operator|=
name|tinfo
operator|->
name|user
operator|.
name|ppr_options
expr_stmt|;
else|else
name|spi
operator|->
name|ppr_options
operator|=
name|tinfo
operator|->
name|goal
operator|.
name|ppr_options
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|spi
operator|->
name|valid
operator|&
name|CTS_SPI_VALID_SYNC_OFFSET
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|update_type
operator|==
name|AHC_TRANS_USER
condition|)
name|spi
operator|->
name|sync_offset
operator|=
name|tinfo
operator|->
name|user
operator|.
name|offset
expr_stmt|;
else|else
name|spi
operator|->
name|sync_offset
operator|=
name|tinfo
operator|->
name|goal
operator|.
name|offset
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|spi
operator|->
name|valid
operator|&
name|CTS_SPI_VALID_SYNC_RATE
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|update_type
operator|==
name|AHC_TRANS_USER
condition|)
name|spi
operator|->
name|sync_period
operator|=
name|tinfo
operator|->
name|user
operator|.
name|period
expr_stmt|;
else|else
name|spi
operator|->
name|sync_period
operator|=
name|tinfo
operator|->
name|goal
operator|.
name|period
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|(
name|spi
operator|->
name|valid
operator|&
name|CTS_SPI_VALID_SYNC_RATE
operator|)
operator|!=
literal|0
operator|)
operator|||
operator|(
operator|(
name|spi
operator|->
name|valid
operator|&
name|CTS_SPI_VALID_SYNC_OFFSET
operator|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|struct
name|ahc_syncrate
modifier|*
name|syncrate
decl_stmt|;
name|u_int
name|maxsync
decl_stmt|;
if|if
condition|(
operator|(
name|ahc
operator|->
name|features
operator|&
name|AHC_ULTRA2
operator|)
operator|!=
literal|0
condition|)
name|maxsync
operator|=
name|AHC_SYNCRATE_DT
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|ahc
operator|->
name|features
operator|&
name|AHC_ULTRA
operator|)
operator|!=
literal|0
condition|)
name|maxsync
operator|=
name|AHC_SYNCRATE_ULTRA
expr_stmt|;
else|else
name|maxsync
operator|=
name|AHC_SYNCRATE_FAST
expr_stmt|;
name|syncrate
operator|=
name|ahc_find_syncrate
argument_list|(
name|ahc
argument_list|,
operator|&
name|spi
operator|->
name|sync_period
argument_list|,
operator|&
name|spi
operator|->
name|ppr_options
argument_list|,
name|maxsync
argument_list|)
expr_stmt|;
name|ahc_validate_offset
argument_list|(
name|ahc
argument_list|,
name|syncrate
argument_list|,
operator|&
name|spi
operator|->
name|sync_offset
argument_list|,
name|spi
operator|->
name|bus_width
argument_list|)
expr_stmt|;
comment|/* We use a period of 0 to represent async */
if|if
condition|(
name|spi
operator|->
name|sync_offset
operator|==
literal|0
condition|)
block|{
name|spi
operator|->
name|sync_period
operator|=
literal|0
expr_stmt|;
name|spi
operator|->
name|ppr_options
operator|=
literal|0
expr_stmt|;
block|}
name|ahc_set_syncrate
argument_list|(
name|ahc
argument_list|,
operator|&
name|devinfo
argument_list|,
name|syncrate
argument_list|,
name|spi
operator|->
name|sync_period
argument_list|,
name|spi
operator|->
name|sync_offset
argument_list|,
name|spi
operator|->
name|ppr_options
argument_list|,
name|update_type
argument_list|,
comment|/*paused*/
name|FALSE
argument_list|)
expr_stmt|;
block|}
name|ahc_unlock
argument_list|(
name|ahc
argument_list|,
operator|&
name|s
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
else|#
directive|else
name|struct
name|ahc_devinfo
name|devinfo
decl_stmt|;
name|struct
name|ccb_trans_settings
modifier|*
name|cts
decl_stmt|;
name|struct
name|ahc_initiator_tinfo
modifier|*
name|tinfo
decl_stmt|;
name|struct
name|tmode_tstate
modifier|*
name|tstate
decl_stmt|;
name|uint16_t
modifier|*
name|discenable
decl_stmt|;
name|uint16_t
modifier|*
name|tagenable
decl_stmt|;
name|u_int
name|update_type
decl_stmt|;
name|long
name|s
decl_stmt|;
name|cts
operator|=
operator|&
name|ccb
operator|->
name|cts
expr_stmt|;
name|ahc_compile_devinfo
argument_list|(
operator|&
name|devinfo
argument_list|,
name|SIM_SCSI_ID
argument_list|(
name|ahc
argument_list|,
name|sim
argument_list|)
argument_list|,
name|cts
operator|->
name|ccb_h
operator|.
name|target_id
argument_list|,
name|cts
operator|->
name|ccb_h
operator|.
name|target_lun
argument_list|,
name|SIM_CHANNEL
argument_list|(
name|ahc
argument_list|,
name|sim
argument_list|)
argument_list|,
name|ROLE_UNKNOWN
argument_list|)
expr_stmt|;
name|tinfo
operator|=
name|ahc_fetch_transinfo
argument_list|(
name|ahc
argument_list|,
name|devinfo
operator|.
name|channel
argument_list|,
name|devinfo
operator|.
name|our_scsiid
argument_list|,
name|devinfo
operator|.
name|target
argument_list|,
operator|&
name|tstate
argument_list|)
expr_stmt|;
name|update_type
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|cts
operator|->
name|flags
operator|&
name|CCB_TRANS_CURRENT_SETTINGS
operator|)
operator|!=
literal|0
condition|)
block|{
name|update_type
operator||=
name|AHC_TRANS_GOAL
expr_stmt|;
name|discenable
operator|=
operator|&
name|tstate
operator|->
name|discenable
expr_stmt|;
name|tagenable
operator|=
operator|&
name|tstate
operator|->
name|tagenable
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|cts
operator|->
name|flags
operator|&
name|CCB_TRANS_USER_SETTINGS
operator|)
operator|!=
literal|0
condition|)
block|{
name|update_type
operator||=
name|AHC_TRANS_USER
expr_stmt|;
name|discenable
operator|=
operator|&
name|ahc
operator|->
name|user_discenable
expr_stmt|;
name|tagenable
operator|=
operator|&
name|ahc
operator|->
name|user_tagenable
expr_stmt|;
block|}
else|else
block|{
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_INVALID
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
block|}
name|ahc_lock
argument_list|(
name|ahc
argument_list|,
operator|&
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cts
operator|->
name|valid
operator|&
name|CCB_TRANS_DISC_VALID
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|cts
operator|->
name|flags
operator|&
name|CCB_TRANS_DISC_ENB
operator|)
operator|!=
literal|0
condition|)
operator|*
name|discenable
operator||=
name|devinfo
operator|.
name|target_mask
expr_stmt|;
else|else
operator|*
name|discenable
operator|&=
operator|~
name|devinfo
operator|.
name|target_mask
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|cts
operator|->
name|valid
operator|&
name|CCB_TRANS_TQ_VALID
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|cts
operator|->
name|flags
operator|&
name|CCB_TRANS_TAG_ENB
operator|)
operator|!=
literal|0
condition|)
operator|*
name|tagenable
operator||=
name|devinfo
operator|.
name|target_mask
expr_stmt|;
else|else
operator|*
name|tagenable
operator|&=
operator|~
name|devinfo
operator|.
name|target_mask
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|cts
operator|->
name|valid
operator|&
name|CCB_TRANS_BUS_WIDTH_VALID
operator|)
operator|!=
literal|0
condition|)
block|{
name|ahc_validate_width
argument_list|(
name|ahc
argument_list|,
operator|&
name|cts
operator|->
name|bus_width
argument_list|)
expr_stmt|;
name|ahc_set_width
argument_list|(
name|ahc
argument_list|,
operator|&
name|devinfo
argument_list|,
name|cts
operator|->
name|bus_width
argument_list|,
name|update_type
argument_list|,
comment|/*paused*/
name|FALSE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|cts
operator|->
name|valid
operator|&
name|CCB_TRANS_SYNC_OFFSET_VALID
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|update_type
operator|==
name|AHC_TRANS_USER
condition|)
name|cts
operator|->
name|sync_offset
operator|=
name|tinfo
operator|->
name|user
operator|.
name|offset
expr_stmt|;
else|else
name|cts
operator|->
name|sync_offset
operator|=
name|tinfo
operator|->
name|goal
operator|.
name|offset
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|cts
operator|->
name|valid
operator|&
name|CCB_TRANS_SYNC_RATE_VALID
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|update_type
operator|==
name|AHC_TRANS_USER
condition|)
name|cts
operator|->
name|sync_period
operator|=
name|tinfo
operator|->
name|user
operator|.
name|period
expr_stmt|;
else|else
name|cts
operator|->
name|sync_period
operator|=
name|tinfo
operator|->
name|goal
operator|.
name|period
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|(
name|cts
operator|->
name|valid
operator|&
name|CCB_TRANS_SYNC_RATE_VALID
operator|)
operator|!=
literal|0
operator|)
operator|||
operator|(
operator|(
name|cts
operator|->
name|valid
operator|&
name|CCB_TRANS_SYNC_OFFSET_VALID
operator|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|struct
name|ahc_syncrate
modifier|*
name|syncrate
decl_stmt|;
name|u_int
name|ppr_options
decl_stmt|;
name|u_int
name|maxsync
decl_stmt|;
if|if
condition|(
operator|(
name|ahc
operator|->
name|features
operator|&
name|AHC_ULTRA2
operator|)
operator|!=
literal|0
condition|)
name|maxsync
operator|=
name|AHC_SYNCRATE_DT
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|ahc
operator|->
name|features
operator|&
name|AHC_ULTRA
operator|)
operator|!=
literal|0
condition|)
name|maxsync
operator|=
name|AHC_SYNCRATE_ULTRA
expr_stmt|;
else|else
name|maxsync
operator|=
name|AHC_SYNCRATE_FAST
expr_stmt|;
name|ppr_options
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|cts
operator|->
name|sync_period
operator|<=
literal|9
condition|)
name|ppr_options
operator|=
name|MSG_EXT_PPR_DT_REQ
expr_stmt|;
name|syncrate
operator|=
name|ahc_find_syncrate
argument_list|(
name|ahc
argument_list|,
operator|&
name|cts
operator|->
name|sync_period
argument_list|,
operator|&
name|ppr_options
argument_list|,
name|maxsync
argument_list|)
expr_stmt|;
name|ahc_validate_offset
argument_list|(
name|ahc
argument_list|,
name|syncrate
argument_list|,
operator|&
name|cts
operator|->
name|sync_offset
argument_list|,
name|MSG_EXT_WDTR_BUS_8_BIT
argument_list|)
expr_stmt|;
comment|/* We use a period of 0 to represent async */
if|if
condition|(
name|cts
operator|->
name|sync_offset
operator|==
literal|0
condition|)
block|{
name|cts
operator|->
name|sync_period
operator|=
literal|0
expr_stmt|;
name|ppr_options
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|ppr_options
operator|==
name|MSG_EXT_PPR_DT_REQ
operator|&&
name|tinfo
operator|->
name|user
operator|.
name|transport_version
operator|>=
literal|3
condition|)
block|{
name|tinfo
operator|->
name|goal
operator|.
name|transport_version
operator|=
name|tinfo
operator|->
name|user
operator|.
name|transport_version
expr_stmt|;
name|tinfo
operator|->
name|current
operator|.
name|transport_version
operator|=
name|tinfo
operator|->
name|user
operator|.
name|transport_version
expr_stmt|;
block|}
name|ahc_set_syncrate
argument_list|(
name|ahc
argument_list|,
operator|&
name|devinfo
argument_list|,
name|syncrate
argument_list|,
name|cts
operator|->
name|sync_period
argument_list|,
name|cts
operator|->
name|sync_offset
argument_list|,
name|ppr_options
argument_list|,
name|update_type
argument_list|,
comment|/*paused*/
name|FALSE
argument_list|)
expr_stmt|;
block|}
name|ahc_unlock
argument_list|(
name|ahc
argument_list|,
operator|&
name|s
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
block|}
case|case
name|XPT_GET_TRAN_SETTINGS
case|:
comment|/* Get default/user set transfer settings for the target */
block|{
name|ahc_lock
argument_list|(
name|ahc
argument_list|,
operator|&
name|s
argument_list|)
expr_stmt|;
name|ahc_get_tran_settings
argument_list|(
name|ahc
argument_list|,
name|SIM_SCSI_ID
argument_list|(
name|ahc
argument_list|,
name|sim
argument_list|)
argument_list|,
name|SIM_CHANNEL
argument_list|(
name|ahc
argument_list|,
name|sim
argument_list|)
argument_list|,
operator|&
name|ccb
operator|->
name|cts
argument_list|)
expr_stmt|;
name|ahc_unlock
argument_list|(
name|ahc
argument_list|,
operator|&
name|s
argument_list|)
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|XPT_CALC_GEOMETRY
case|:
block|{
name|struct
name|ccb_calc_geometry
modifier|*
name|ccg
decl_stmt|;
name|uint32_t
name|size_mb
decl_stmt|;
name|uint32_t
name|secs_per_cylinder
decl_stmt|;
name|int
name|extended
decl_stmt|;
name|ccg
operator|=
operator|&
name|ccb
operator|->
name|ccg
expr_stmt|;
name|size_mb
operator|=
name|ccg
operator|->
name|volume_size
operator|/
operator|(
operator|(
literal|1024L
operator|*
literal|1024L
operator|)
operator|/
name|ccg
operator|->
name|block_size
operator|)
expr_stmt|;
name|extended
operator|=
name|SIM_IS_SCSIBUS_B
argument_list|(
name|ahc
argument_list|,
name|sim
argument_list|)
condition|?
name|ahc
operator|->
name|flags
operator|&
name|AHC_EXTENDED_TRANS_B
else|:
name|ahc
operator|->
name|flags
operator|&
name|AHC_EXTENDED_TRANS_A
expr_stmt|;
if|if
condition|(
name|size_mb
operator|>
literal|1024
operator|&&
name|extended
condition|)
block|{
name|ccg
operator|->
name|heads
operator|=
literal|255
expr_stmt|;
name|ccg
operator|->
name|secs_per_track
operator|=
literal|63
expr_stmt|;
block|}
else|else
block|{
name|ccg
operator|->
name|heads
operator|=
literal|64
expr_stmt|;
name|ccg
operator|->
name|secs_per_track
operator|=
literal|32
expr_stmt|;
block|}
name|secs_per_cylinder
operator|=
name|ccg
operator|->
name|heads
operator|*
name|ccg
operator|->
name|secs_per_track
expr_stmt|;
name|ccg
operator|->
name|cylinders
operator|=
name|ccg
operator|->
name|volume_size
operator|/
name|secs_per_cylinder
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|XPT_RESET_BUS
case|:
comment|/* Reset the specified SCSI bus */
block|{
name|int
name|found
decl_stmt|;
name|ahc_lock
argument_list|(
name|ahc
argument_list|,
operator|&
name|s
argument_list|)
expr_stmt|;
name|found
operator|=
name|ahc_reset_channel
argument_list|(
name|ahc
argument_list|,
name|SIM_CHANNEL
argument_list|(
name|ahc
argument_list|,
name|sim
argument_list|)
argument_list|,
comment|/*initiate reset*/
name|TRUE
argument_list|)
expr_stmt|;
name|ahc_unlock
argument_list|(
name|ahc
argument_list|,
operator|&
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
block|{
name|xpt_print_path
argument_list|(
name|SIM_PATH
argument_list|(
name|ahc
argument_list|,
name|sim
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"SCSI bus reset delivered. "
literal|"%d SCBs aborted.\n"
argument_list|,
name|found
argument_list|)
expr_stmt|;
block|}
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|XPT_TERM_IO
case|:
comment|/* Terminate the I/O process */
comment|/* XXX Implement */
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_INVALID
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
case|case
name|XPT_PATH_INQ
case|:
comment|/* Path routing inquiry */
block|{
name|struct
name|ccb_pathinq
modifier|*
name|cpi
init|=
operator|&
name|ccb
operator|->
name|cpi
decl_stmt|;
name|cpi
operator|->
name|version_num
operator|=
literal|1
expr_stmt|;
comment|/* XXX??? */
name|cpi
operator|->
name|hba_inquiry
operator|=
name|PI_SDTR_ABLE
operator||
name|PI_TAG_ABLE
expr_stmt|;
if|if
condition|(
operator|(
name|ahc
operator|->
name|features
operator|&
name|AHC_WIDE
operator|)
operator|!=
literal|0
condition|)
name|cpi
operator|->
name|hba_inquiry
operator||=
name|PI_WIDE_16
expr_stmt|;
if|if
condition|(
operator|(
name|ahc
operator|->
name|flags
operator|&
name|AHC_TARGETMODE
operator|)
operator|!=
literal|0
condition|)
block|{
name|cpi
operator|->
name|target_sprt
operator|=
name|PIT_PROCESSOR
operator||
name|PIT_DISCONNECT
operator||
name|PIT_TERM_IO
expr_stmt|;
block|}
else|else
block|{
name|cpi
operator|->
name|target_sprt
operator|=
literal|0
expr_stmt|;
block|}
name|cpi
operator|->
name|hba_misc
operator|=
operator|(
name|ahc
operator|->
name|flags
operator|&
name|AHC_INITIATORMODE
operator|)
condition|?
literal|0
else|:
name|PIM_NOINITIATOR
expr_stmt|;
name|cpi
operator|->
name|hba_eng_cnt
operator|=
literal|0
expr_stmt|;
name|cpi
operator|->
name|max_target
operator|=
operator|(
name|ahc
operator|->
name|features
operator|&
name|AHC_WIDE
operator|)
condition|?
literal|15
else|:
literal|7
expr_stmt|;
name|cpi
operator|->
name|max_lun
operator|=
literal|64
expr_stmt|;
if|if
condition|(
name|SIM_IS_SCSIBUS_B
argument_list|(
name|ahc
argument_list|,
name|sim
argument_list|)
condition|)
block|{
name|cpi
operator|->
name|initiator_id
operator|=
name|ahc
operator|->
name|our_id_b
expr_stmt|;
if|if
condition|(
operator|(
name|ahc
operator|->
name|flags
operator|&
name|AHC_RESET_BUS_B
operator|)
operator|==
literal|0
condition|)
name|cpi
operator|->
name|hba_misc
operator||=
name|PIM_NOBUSRESET
expr_stmt|;
block|}
else|else
block|{
name|cpi
operator|->
name|initiator_id
operator|=
name|ahc
operator|->
name|our_id
expr_stmt|;
if|if
condition|(
operator|(
name|ahc
operator|->
name|flags
operator|&
name|AHC_RESET_BUS_A
operator|)
operator|==
literal|0
condition|)
name|cpi
operator|->
name|hba_misc
operator||=
name|PIM_NOBUSRESET
expr_stmt|;
block|}
name|cpi
operator|->
name|bus_id
operator|=
name|cam_sim_bus
argument_list|(
name|sim
argument_list|)
expr_stmt|;
name|cpi
operator|->
name|base_transfer_speed
operator|=
literal|3300
expr_stmt|;
name|strncpy
argument_list|(
name|cpi
operator|->
name|sim_vid
argument_list|,
literal|"FreeBSD"
argument_list|,
name|SIM_IDLEN
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|cpi
operator|->
name|hba_vid
argument_list|,
literal|"Adaptec"
argument_list|,
name|HBA_IDLEN
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|cpi
operator|->
name|dev_name
argument_list|,
name|cam_sim_name
argument_list|(
name|sim
argument_list|)
argument_list|,
name|DEV_IDLEN
argument_list|)
expr_stmt|;
name|cpi
operator|->
name|unit_number
operator|=
name|cam_sim_unit
argument_list|(
name|sim
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|AHC_NEW_TRAN_SETTINGS
name|cpi
operator|->
name|protocol
operator|=
name|PROTO_SCSI
expr_stmt|;
name|cpi
operator|->
name|protocol_version
operator|=
name|SCSI_REV_2
expr_stmt|;
name|cpi
operator|->
name|transport
operator|=
name|XPORT_SPI
expr_stmt|;
name|cpi
operator|->
name|transport_version
operator|=
literal|2
expr_stmt|;
name|cpi
operator|->
name|xport_specific
operator|.
name|spi
operator|.
name|ppr_options
operator|=
name|SID_SPI_CLOCK_ST
expr_stmt|;
if|if
condition|(
operator|(
name|ahc
operator|->
name|features
operator|&
name|AHC_DT
operator|)
operator|!=
literal|0
condition|)
block|{
name|cpi
operator|->
name|transport_version
operator|=
literal|3
expr_stmt|;
name|cpi
operator|->
name|xport_specific
operator|.
name|spi
operator|.
name|ppr_options
operator|=
name|SID_SPI_CLOCK_DT_ST
expr_stmt|;
block|}
endif|#
directive|endif
name|cpi
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_INVALID
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ahc_get_tran_settings
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|int
name|our_id
parameter_list|,
name|char
name|channel
parameter_list|,
name|struct
name|ccb_trans_settings
modifier|*
name|cts
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|AHC_NEW_TRAN_SETTINGS
name|struct
name|ahc_devinfo
name|devinfo
decl_stmt|;
name|struct
name|ccb_trans_settings_scsi
modifier|*
name|scsi
decl_stmt|;
name|struct
name|ccb_trans_settings_spi
modifier|*
name|spi
decl_stmt|;
name|struct
name|ahc_initiator_tinfo
modifier|*
name|targ_info
decl_stmt|;
name|struct
name|tmode_tstate
modifier|*
name|tstate
decl_stmt|;
name|struct
name|ahc_transinfo
modifier|*
name|tinfo
decl_stmt|;
name|scsi
operator|=
operator|&
name|cts
operator|->
name|proto_specific
operator|.
name|scsi
expr_stmt|;
name|spi
operator|=
operator|&
name|cts
operator|->
name|xport_specific
operator|.
name|spi
expr_stmt|;
name|ahc_compile_devinfo
argument_list|(
operator|&
name|devinfo
argument_list|,
name|our_id
argument_list|,
name|cts
operator|->
name|ccb_h
operator|.
name|target_id
argument_list|,
name|cts
operator|->
name|ccb_h
operator|.
name|target_lun
argument_list|,
name|channel
argument_list|,
name|ROLE_UNKNOWN
argument_list|)
expr_stmt|;
name|targ_info
operator|=
name|ahc_fetch_transinfo
argument_list|(
name|ahc
argument_list|,
name|devinfo
operator|.
name|channel
argument_list|,
name|devinfo
operator|.
name|our_scsiid
argument_list|,
name|devinfo
operator|.
name|target
argument_list|,
operator|&
name|tstate
argument_list|)
expr_stmt|;
if|if
condition|(
name|cts
operator|->
name|type
operator|==
name|CTS_TYPE_CURRENT_SETTINGS
condition|)
name|tinfo
operator|=
operator|&
name|targ_info
operator|->
name|current
expr_stmt|;
else|else
name|tinfo
operator|=
operator|&
name|targ_info
operator|->
name|user
expr_stmt|;
name|scsi
operator|->
name|flags
operator|&=
operator|~
name|CTS_SCSI_FLAGS_TAG_ENB
expr_stmt|;
name|spi
operator|->
name|flags
operator|&=
operator|~
name|CTS_SPI_FLAGS_DISC_ENB
expr_stmt|;
if|if
condition|(
name|cts
operator|->
name|type
operator|==
name|CTS_TYPE_USER_SETTINGS
condition|)
block|{
if|if
condition|(
operator|(
name|ahc
operator|->
name|user_discenable
operator|&
name|devinfo
operator|.
name|target_mask
operator|)
operator|!=
literal|0
condition|)
name|spi
operator|->
name|flags
operator||=
name|CTS_SPI_FLAGS_DISC_ENB
expr_stmt|;
if|if
condition|(
operator|(
name|ahc
operator|->
name|user_tagenable
operator|&
name|devinfo
operator|.
name|target_mask
operator|)
operator|!=
literal|0
condition|)
name|scsi
operator|->
name|flags
operator||=
name|CTS_SCSI_FLAGS_TAG_ENB
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|tstate
operator|->
name|discenable
operator|&
name|devinfo
operator|.
name|target_mask
operator|)
operator|!=
literal|0
condition|)
name|spi
operator|->
name|flags
operator||=
name|CTS_SPI_FLAGS_DISC_ENB
expr_stmt|;
if|if
condition|(
operator|(
name|tstate
operator|->
name|tagenable
operator|&
name|devinfo
operator|.
name|target_mask
operator|)
operator|!=
literal|0
condition|)
name|scsi
operator|->
name|flags
operator||=
name|CTS_SCSI_FLAGS_TAG_ENB
expr_stmt|;
block|}
name|cts
operator|->
name|protocol_version
operator|=
name|tinfo
operator|->
name|protocol_version
expr_stmt|;
name|cts
operator|->
name|transport_version
operator|=
name|tinfo
operator|->
name|transport_version
expr_stmt|;
name|spi
operator|->
name|sync_period
operator|=
name|tinfo
operator|->
name|period
expr_stmt|;
name|spi
operator|->
name|sync_offset
operator|=
name|tinfo
operator|->
name|offset
expr_stmt|;
name|spi
operator|->
name|bus_width
operator|=
name|tinfo
operator|->
name|width
expr_stmt|;
name|spi
operator|->
name|ppr_options
operator|=
name|tinfo
operator|->
name|ppr_options
expr_stmt|;
name|cts
operator|->
name|protocol
operator|=
name|PROTO_SCSI
expr_stmt|;
name|cts
operator|->
name|transport
operator|=
name|XPORT_SPI
expr_stmt|;
name|spi
operator|->
name|valid
operator|=
name|CTS_SPI_VALID_SYNC_RATE
operator||
name|CTS_SPI_VALID_SYNC_OFFSET
operator||
name|CTS_SPI_VALID_BUS_WIDTH
operator||
name|CTS_SPI_VALID_PPR_OPTIONS
expr_stmt|;
if|if
condition|(
name|cts
operator|->
name|ccb_h
operator|.
name|target_lun
operator|!=
name|CAM_LUN_WILDCARD
condition|)
block|{
name|scsi
operator|->
name|valid
operator|=
name|CTS_SCSI_VALID_TQ
expr_stmt|;
name|spi
operator|->
name|valid
operator||=
name|CTS_SPI_VALID_DISC
expr_stmt|;
block|}
else|else
block|{
name|scsi
operator|->
name|valid
operator|=
literal|0
expr_stmt|;
block|}
name|cts
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
else|#
directive|else
name|struct
name|ahc_devinfo
name|devinfo
decl_stmt|;
name|struct
name|ahc_initiator_tinfo
modifier|*
name|targ_info
decl_stmt|;
name|struct
name|tmode_tstate
modifier|*
name|tstate
decl_stmt|;
name|struct
name|ahc_transinfo
modifier|*
name|tinfo
decl_stmt|;
name|long
name|s
decl_stmt|;
name|ahc_compile_devinfo
argument_list|(
operator|&
name|devinfo
argument_list|,
name|our_id
argument_list|,
name|cts
operator|->
name|ccb_h
operator|.
name|target_id
argument_list|,
name|cts
operator|->
name|ccb_h
operator|.
name|target_lun
argument_list|,
name|channel
argument_list|,
name|ROLE_UNKNOWN
argument_list|)
expr_stmt|;
name|targ_info
operator|=
name|ahc_fetch_transinfo
argument_list|(
name|ahc
argument_list|,
name|devinfo
operator|.
name|channel
argument_list|,
name|devinfo
operator|.
name|our_scsiid
argument_list|,
name|devinfo
operator|.
name|target
argument_list|,
operator|&
name|tstate
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cts
operator|->
name|flags
operator|&
name|CCB_TRANS_CURRENT_SETTINGS
operator|)
operator|!=
literal|0
condition|)
name|tinfo
operator|=
operator|&
name|targ_info
operator|->
name|current
expr_stmt|;
else|else
name|tinfo
operator|=
operator|&
name|targ_info
operator|->
name|user
expr_stmt|;
name|ahc_lock
argument_list|(
name|ahc
argument_list|,
operator|&
name|s
argument_list|)
expr_stmt|;
name|cts
operator|->
name|flags
operator|&=
operator|~
operator|(
name|CCB_TRANS_DISC_ENB
operator||
name|CCB_TRANS_TAG_ENB
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|cts
operator|->
name|flags
operator|&
name|CCB_TRANS_CURRENT_SETTINGS
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|ahc
operator|->
name|user_discenable
operator|&
name|devinfo
operator|.
name|target_mask
operator|)
operator|!=
literal|0
condition|)
name|cts
operator|->
name|flags
operator||=
name|CCB_TRANS_DISC_ENB
expr_stmt|;
if|if
condition|(
operator|(
name|ahc
operator|->
name|user_tagenable
operator|&
name|devinfo
operator|.
name|target_mask
operator|)
operator|!=
literal|0
condition|)
name|cts
operator|->
name|flags
operator||=
name|CCB_TRANS_TAG_ENB
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|tstate
operator|->
name|discenable
operator|&
name|devinfo
operator|.
name|target_mask
operator|)
operator|!=
literal|0
condition|)
name|cts
operator|->
name|flags
operator||=
name|CCB_TRANS_DISC_ENB
expr_stmt|;
if|if
condition|(
operator|(
name|tstate
operator|->
name|tagenable
operator|&
name|devinfo
operator|.
name|target_mask
operator|)
operator|!=
literal|0
condition|)
name|cts
operator|->
name|flags
operator||=
name|CCB_TRANS_TAG_ENB
expr_stmt|;
block|}
name|cts
operator|->
name|sync_period
operator|=
name|tinfo
operator|->
name|period
expr_stmt|;
name|cts
operator|->
name|sync_offset
operator|=
name|tinfo
operator|->
name|offset
expr_stmt|;
name|cts
operator|->
name|bus_width
operator|=
name|tinfo
operator|->
name|width
expr_stmt|;
name|ahc_unlock
argument_list|(
name|ahc
argument_list|,
operator|&
name|s
argument_list|)
expr_stmt|;
name|cts
operator|->
name|valid
operator|=
name|CCB_TRANS_SYNC_RATE_VALID
operator||
name|CCB_TRANS_SYNC_OFFSET_VALID
operator||
name|CCB_TRANS_BUS_WIDTH_VALID
expr_stmt|;
if|if
condition|(
name|cts
operator|->
name|ccb_h
operator|.
name|target_lun
operator|!=
name|CAM_LUN_WILDCARD
condition|)
name|cts
operator|->
name|valid
operator||=
name|CCB_TRANS_DISC_VALID
operator||
name|CCB_TRANS_TQ_VALID
expr_stmt|;
name|cts
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|void
name|ahc_async
parameter_list|(
name|void
modifier|*
name|callback_arg
parameter_list|,
name|uint32_t
name|code
parameter_list|,
name|struct
name|cam_path
modifier|*
name|path
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ahc_softc
modifier|*
name|ahc
decl_stmt|;
name|struct
name|cam_sim
modifier|*
name|sim
decl_stmt|;
name|sim
operator|=
operator|(
expr|struct
name|cam_sim
operator|*
operator|)
name|callback_arg
expr_stmt|;
name|ahc
operator|=
operator|(
expr|struct
name|ahc_softc
operator|*
operator|)
name|cam_sim_softc
argument_list|(
name|sim
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|AC_LOST_DEVICE
case|:
block|{
name|struct
name|ahc_devinfo
name|devinfo
decl_stmt|;
name|long
name|s
decl_stmt|;
name|ahc_compile_devinfo
argument_list|(
operator|&
name|devinfo
argument_list|,
name|SIM_SCSI_ID
argument_list|(
name|ahc
argument_list|,
name|sim
argument_list|)
argument_list|,
name|xpt_path_target_id
argument_list|(
name|path
argument_list|)
argument_list|,
name|xpt_path_lun_id
argument_list|(
name|path
argument_list|)
argument_list|,
name|SIM_CHANNEL
argument_list|(
name|ahc
argument_list|,
name|sim
argument_list|)
argument_list|,
name|ROLE_UNKNOWN
argument_list|)
expr_stmt|;
comment|/* 		 * Revert to async/narrow transfers 		 * for the next device. 		 */
name|ahc_lock
argument_list|(
name|ahc
argument_list|,
operator|&
name|s
argument_list|)
expr_stmt|;
name|ahc_set_width
argument_list|(
name|ahc
argument_list|,
operator|&
name|devinfo
argument_list|,
name|MSG_EXT_WDTR_BUS_8_BIT
argument_list|,
name|AHC_TRANS_GOAL
operator||
name|AHC_TRANS_CUR
argument_list|,
comment|/*paused*/
name|FALSE
argument_list|)
expr_stmt|;
name|ahc_set_syncrate
argument_list|(
name|ahc
argument_list|,
operator|&
name|devinfo
argument_list|,
comment|/*syncrate*/
name|NULL
argument_list|,
comment|/*period*/
literal|0
argument_list|,
comment|/*offset*/
literal|0
argument_list|,
comment|/*ppr_options*/
literal|0
argument_list|,
name|AHC_TRANS_GOAL
operator||
name|AHC_TRANS_CUR
argument_list|,
comment|/*paused*/
name|FALSE
argument_list|)
expr_stmt|;
name|ahc_unlock
argument_list|(
name|ahc
argument_list|,
operator|&
name|s
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ahc_execute_scb
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|dm_segs
parameter_list|,
name|int
name|nsegments
parameter_list|,
name|int
name|error
parameter_list|)
block|{
name|struct
name|scb
modifier|*
name|scb
decl_stmt|;
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|struct
name|ahc_softc
modifier|*
name|ahc
decl_stmt|;
name|struct
name|ahc_initiator_tinfo
modifier|*
name|tinfo
decl_stmt|;
name|struct
name|tmode_tstate
modifier|*
name|tstate
decl_stmt|;
name|u_int
name|mask
decl_stmt|;
name|long
name|s
decl_stmt|;
name|scb
operator|=
operator|(
expr|struct
name|scb
operator|*
operator|)
name|arg
expr_stmt|;
name|ccb
operator|=
name|scb
operator|->
name|io_ctx
expr_stmt|;
name|ahc
operator|=
operator|(
expr|struct
name|ahc_softc
operator|*
operator|)
name|ccb
operator|->
name|ccb_h
operator|.
name|ccb_ahc_ptr
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|error
operator|==
name|EFBIG
condition|)
name|ahc_set_transaction_status
argument_list|(
name|scb
argument_list|,
name|CAM_REQ_TOO_BIG
argument_list|)
expr_stmt|;
else|else
name|ahc_set_transaction_status
argument_list|(
name|scb
argument_list|,
name|CAM_REQ_CMP_ERR
argument_list|)
expr_stmt|;
if|if
condition|(
name|nsegments
operator|!=
literal|0
condition|)
name|bus_dmamap_unload
argument_list|(
name|ahc
operator|->
name|buffer_dmat
argument_list|,
name|scb
operator|->
name|dmamap
argument_list|)
expr_stmt|;
name|ahc_lock
argument_list|(
name|ahc
argument_list|,
operator|&
name|s
argument_list|)
expr_stmt|;
name|ahc_free_scb
argument_list|(
name|ahc
argument_list|,
name|scb
argument_list|)
expr_stmt|;
name|ahc_unlock
argument_list|(
name|ahc
argument_list|,
operator|&
name|s
argument_list|)
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|nsegments
operator|!=
literal|0
condition|)
block|{
name|struct
name|ahc_dma_seg
modifier|*
name|sg
decl_stmt|;
name|bus_dma_segment_t
modifier|*
name|end_seg
decl_stmt|;
name|bus_dmasync_op_t
name|op
decl_stmt|;
name|end_seg
operator|=
name|dm_segs
operator|+
name|nsegments
expr_stmt|;
comment|/* Copy the segments into our SG list */
name|sg
operator|=
name|scb
operator|->
name|sg_list
expr_stmt|;
while|while
condition|(
name|dm_segs
operator|<
name|end_seg
condition|)
block|{
name|sg
operator|->
name|addr
operator|=
name|dm_segs
operator|->
name|ds_addr
expr_stmt|;
comment|/* XXX Add in the 5th byte of the address later. */
name|sg
operator|->
name|len
operator|=
name|dm_segs
operator|->
name|ds_len
expr_stmt|;
name|sg
operator|++
expr_stmt|;
name|dm_segs
operator|++
expr_stmt|;
block|}
comment|/* 		 * Note where to find the SG entries in bus space. 		 * We also set the full residual flag which the  		 * sequencer will clear as soon as a data transfer 		 * occurs. 		 */
name|scb
operator|->
name|hscb
operator|->
name|sgptr
operator|=
name|scb
operator|->
name|sg_list_phys
operator||
name|SG_FULL_RESID
expr_stmt|;
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DIR_MASK
operator|)
operator|==
name|CAM_DIR_IN
condition|)
name|op
operator|=
name|BUS_DMASYNC_PREREAD
expr_stmt|;
else|else
name|op
operator|=
name|BUS_DMASYNC_PREWRITE
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|ahc
operator|->
name|buffer_dmat
argument_list|,
name|scb
operator|->
name|dmamap
argument_list|,
name|op
argument_list|)
expr_stmt|;
if|if
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|==
name|XPT_CONT_TARGET_IO
condition|)
block|{
name|struct
name|target_data
modifier|*
name|tdata
decl_stmt|;
name|tdata
operator|=
operator|&
name|scb
operator|->
name|hscb
operator|->
name|shared_data
operator|.
name|tdata
expr_stmt|;
name|tdata
operator|->
name|target_phases
operator||=
name|DPHASE_PENDING
expr_stmt|;
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DIR_MASK
operator|)
operator|==
name|CAM_DIR_OUT
condition|)
name|tdata
operator|->
name|data_phase
operator|=
name|P_DATAOUT
expr_stmt|;
else|else
name|tdata
operator|->
name|data_phase
operator|=
name|P_DATAIN
expr_stmt|;
comment|/* 			 * If the transfer is of an odd length and in the 			 * "in" direction (scsi->HostBus), then it may 			 * trigger a bug in the 'WideODD' feature of 			 * non-Ultra2 chips.  Force the total data-length 			 * to be even by adding an extra, 1 byte, SG, 			 * element.  We do this even if we are not currently 			 * negotiated wide as negotiation could occur before 			 * this command is executed. 			 */
if|if
condition|(
operator|(
name|ahc
operator|->
name|bugs
operator|&
name|AHC_TMODE_WIDEODD_BUG
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|ccb
operator|->
name|csio
operator|.
name|dxfer_len
operator|&
literal|0x1
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DIR_MASK
operator|)
operator|==
name|CAM_DIR_IN
condition|)
block|{
name|nsegments
operator|++
expr_stmt|;
if|if
condition|(
name|nsegments
operator|>
name|AHC_NSEG
condition|)
block|{
name|ahc_set_transaction_status
argument_list|(
name|scb
argument_list|,
name|CAM_REQ_TOO_BIG
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|ahc
operator|->
name|buffer_dmat
argument_list|,
name|scb
operator|->
name|dmamap
argument_list|)
expr_stmt|;
name|ahc_lock
argument_list|(
name|ahc
argument_list|,
operator|&
name|s
argument_list|)
expr_stmt|;
name|ahc_free_scb
argument_list|(
name|ahc
argument_list|,
name|scb
argument_list|)
expr_stmt|;
name|ahc_unlock
argument_list|(
name|ahc
argument_list|,
operator|&
name|s
argument_list|)
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return;
block|}
name|sg
operator|->
name|addr
operator|=
name|ahc
operator|->
name|dma_bug_buf
expr_stmt|;
name|sg
operator|->
name|len
operator|=
literal|1
expr_stmt|;
name|sg
operator|++
expr_stmt|;
block|}
block|}
name|sg
operator|--
expr_stmt|;
name|sg
operator|->
name|len
operator||=
name|AHC_DMA_LAST_SEG
expr_stmt|;
comment|/* Copy the first SG into the "current" data pointer area */
name|scb
operator|->
name|hscb
operator|->
name|dataptr
operator|=
name|scb
operator|->
name|sg_list
operator|->
name|addr
expr_stmt|;
name|scb
operator|->
name|hscb
operator|->
name|datacnt
operator|=
name|scb
operator|->
name|sg_list
operator|->
name|len
expr_stmt|;
block|}
else|else
block|{
name|scb
operator|->
name|hscb
operator|->
name|sgptr
operator|=
name|SG_LIST_NULL
expr_stmt|;
name|scb
operator|->
name|hscb
operator|->
name|dataptr
operator|=
literal|0
expr_stmt|;
name|scb
operator|->
name|hscb
operator|->
name|datacnt
operator|=
literal|0
expr_stmt|;
block|}
name|scb
operator|->
name|sg_count
operator|=
name|nsegments
expr_stmt|;
name|ahc_lock
argument_list|(
name|ahc
argument_list|,
operator|&
name|s
argument_list|)
expr_stmt|;
comment|/* 	 * Last time we need to check if this SCB needs to 	 * be aborted. 	 */
if|if
condition|(
name|ahc_get_transaction_status
argument_list|(
name|scb
argument_list|)
operator|!=
name|CAM_REQ_INPROG
condition|)
block|{
if|if
condition|(
name|nsegments
operator|!=
literal|0
condition|)
name|bus_dmamap_unload
argument_list|(
name|ahc
operator|->
name|buffer_dmat
argument_list|,
name|scb
operator|->
name|dmamap
argument_list|)
expr_stmt|;
name|ahc_free_scb
argument_list|(
name|ahc
argument_list|,
name|scb
argument_list|)
expr_stmt|;
name|ahc_unlock
argument_list|(
name|ahc
argument_list|,
operator|&
name|s
argument_list|)
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return;
block|}
name|tinfo
operator|=
name|ahc_fetch_transinfo
argument_list|(
name|ahc
argument_list|,
name|SCSIID_CHANNEL
argument_list|(
name|ahc
argument_list|,
name|scb
operator|->
name|hscb
operator|->
name|scsiid
argument_list|)
argument_list|,
name|SCSIID_OUR_ID
argument_list|(
name|scb
operator|->
name|hscb
operator|->
name|scsiid
argument_list|)
argument_list|,
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
argument_list|,
operator|&
name|tstate
argument_list|)
expr_stmt|;
name|mask
operator|=
name|SCB_GET_TARGET_MASK
argument_list|(
name|ahc
argument_list|,
name|scb
argument_list|)
expr_stmt|;
name|scb
operator|->
name|hscb
operator|->
name|scsirate
operator|=
name|tinfo
operator|->
name|scsirate
expr_stmt|;
name|scb
operator|->
name|hscb
operator|->
name|scsioffset
operator|=
name|tinfo
operator|->
name|current
operator|.
name|offset
expr_stmt|;
if|if
condition|(
operator|(
name|tstate
operator|->
name|ultraenb
operator|&
name|mask
operator|)
operator|!=
literal|0
condition|)
name|scb
operator|->
name|hscb
operator|->
name|control
operator||=
name|ULTRAENB
expr_stmt|;
if|if
condition|(
operator|(
name|tstate
operator|->
name|discenable
operator|&
name|mask
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DIS_DISCONNECT
operator|)
operator|==
literal|0
condition|)
name|scb
operator|->
name|hscb
operator|->
name|control
operator||=
name|DISCENB
expr_stmt|;
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_NEGOTIATE
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|tinfo
operator|->
name|current
operator|.
name|width
operator|!=
literal|0
operator|||
name|tinfo
operator|->
name|current
operator|.
name|period
operator|!=
literal|0
operator|)
condition|)
block|{
name|scb
operator|->
name|flags
operator||=
name|SCB_NEGOTIATE
expr_stmt|;
name|scb
operator|->
name|hscb
operator|->
name|control
operator||=
name|MK_MESSAGE
expr_stmt|;
block|}
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|ahc
operator|->
name|pending_scbs
argument_list|,
name|scb
argument_list|,
name|pending_links
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_SIM_QUEUED
expr_stmt|;
if|if
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|timeout
operator|!=
name|CAM_TIME_INFINITY
condition|)
block|{
if|if
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|timeout
operator|==
name|CAM_TIME_DEFAULT
condition|)
name|ccb
operator|->
name|ccb_h
operator|.
name|timeout
operator|=
literal|5
operator|*
literal|1000
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|timeout_ch
operator|=
name|timeout
argument_list|(
name|ahc_timeout
argument_list|,
operator|(
name|caddr_t
operator|)
name|scb
argument_list|,
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|timeout
operator|*
name|hz
operator|)
operator|/
literal|1000
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * We only allow one untagged transaction 	 * per target in the initiator role unless 	 * we are storing a full busy target *lun* 	 * table in SCB space. 	 */
if|if
condition|(
operator|(
name|scb
operator|->
name|hscb
operator|->
name|control
operator|&
operator|(
name|TARGET_SCB
operator||
name|TAG_ENB
operator|)
operator|)
operator|==
literal|0
operator|&&
operator|(
name|ahc
operator|->
name|features
operator|&
name|AHC_SCB_BTT
operator|)
operator|==
literal|0
condition|)
block|{
name|struct
name|scb_tailq
modifier|*
name|untagged_q
decl_stmt|;
name|untagged_q
operator|=
operator|&
operator|(
name|ahc
operator|->
name|untagged_queues
index|[
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
index|]
operator|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
name|untagged_q
argument_list|,
name|scb
argument_list|,
name|links
operator|.
name|tqe
argument_list|)
expr_stmt|;
if|if
condition|(
name|TAILQ_FIRST
argument_list|(
name|untagged_q
argument_list|)
operator|!=
name|scb
condition|)
block|{
name|ahc_unlock
argument_list|(
name|ahc
argument_list|,
operator|&
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|scb
operator|->
name|flags
operator||=
name|SCB_ACTIVE
expr_stmt|;
if|if
condition|(
operator|(
name|scb
operator|->
name|flags
operator|&
name|SCB_TARGET_IMMEDIATE
operator|)
operator|!=
literal|0
condition|)
block|{
name|pause_sequencer
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ahc
operator|->
name|flags
operator|&
name|AHC_PAGESCBS
operator|)
operator|==
literal|0
condition|)
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCBPTR
argument_list|,
name|scb
operator|->
name|hscb
operator|->
name|tag
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCB_TAG
argument_list|,
name|scb
operator|->
name|hscb
operator|->
name|tag
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|RETURN_1
argument_list|,
name|CONT_MSG_LOOP
argument_list|)
expr_stmt|;
name|unpause_sequencer
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ahc_queue_scb
argument_list|(
name|ahc
argument_list|,
name|scb
argument_list|)
expr_stmt|;
block|}
name|ahc_unlock
argument_list|(
name|ahc
argument_list|,
operator|&
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ahc_poll
parameter_list|(
name|struct
name|cam_sim
modifier|*
name|sim
parameter_list|)
block|{
name|ahc_intr
argument_list|(
name|cam_sim_softc
argument_list|(
name|sim
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ahc_setup_data
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|struct
name|cam_sim
modifier|*
name|sim
parameter_list|,
name|struct
name|ccb_scsiio
modifier|*
name|csio
parameter_list|,
name|struct
name|scb
modifier|*
name|scb
parameter_list|)
block|{
name|struct
name|hardware_scb
modifier|*
name|hscb
decl_stmt|;
name|struct
name|ccb_hdr
modifier|*
name|ccb_h
decl_stmt|;
name|hscb
operator|=
name|scb
operator|->
name|hscb
expr_stmt|;
name|ccb_h
operator|=
operator|&
name|csio
operator|->
name|ccb_h
expr_stmt|;
if|if
condition|(
name|ccb_h
operator|->
name|func_code
operator|==
name|XPT_SCSI_IO
condition|)
block|{
name|hscb
operator|->
name|cdb_len
operator|=
name|csio
operator|->
name|cdb_len
expr_stmt|;
if|if
condition|(
operator|(
name|ccb_h
operator|->
name|flags
operator|&
name|CAM_CDB_POINTER
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|hscb
operator|->
name|cdb_len
operator|>
sizeof|sizeof
argument_list|(
name|hscb
operator|->
name|cdb32
argument_list|)
operator|||
operator|(
name|ccb_h
operator|->
name|flags
operator|&
name|CAM_CDB_PHYS
operator|)
operator|!=
literal|0
condition|)
block|{
name|u_long
name|s
decl_stmt|;
name|ahc_set_transaction_status
argument_list|(
name|scb
argument_list|,
name|CAM_REQ_INVALID
argument_list|)
expr_stmt|;
name|ahc_lock
argument_list|(
name|ahc
argument_list|,
operator|&
name|s
argument_list|)
expr_stmt|;
name|ahc_free_scb
argument_list|(
name|ahc
argument_list|,
name|scb
argument_list|)
expr_stmt|;
name|ahc_unlock
argument_list|(
name|ahc
argument_list|,
operator|&
name|s
argument_list|)
expr_stmt|;
name|xpt_done
argument_list|(
operator|(
expr|union
name|ccb
operator|*
operator|)
name|csio
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|hscb
operator|->
name|cdb_len
operator|>
literal|12
condition|)
block|{
name|memcpy
argument_list|(
name|hscb
operator|->
name|cdb32
argument_list|,
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_ptr
argument_list|,
name|hscb
operator|->
name|cdb_len
argument_list|)
expr_stmt|;
name|hscb
operator|->
name|shared_data
operator|.
name|cdb_ptr
operator|=
name|scb
operator|->
name|cdb32_busaddr
expr_stmt|;
block|}
else|else
block|{
name|memcpy
argument_list|(
name|hscb
operator|->
name|shared_data
operator|.
name|cdb
argument_list|,
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_ptr
argument_list|,
name|hscb
operator|->
name|cdb_len
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|hscb
operator|->
name|cdb_len
operator|>
literal|12
condition|)
block|{
name|memcpy
argument_list|(
name|hscb
operator|->
name|cdb32
argument_list|,
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
argument_list|,
name|hscb
operator|->
name|cdb_len
argument_list|)
expr_stmt|;
name|hscb
operator|->
name|shared_data
operator|.
name|cdb_ptr
operator|=
name|scb
operator|->
name|cdb32_busaddr
expr_stmt|;
block|}
else|else
block|{
name|memcpy
argument_list|(
name|hscb
operator|->
name|shared_data
operator|.
name|cdb
argument_list|,
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
argument_list|,
name|hscb
operator|->
name|cdb_len
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* Only use S/G if there is a transfer */
if|if
condition|(
operator|(
name|ccb_h
operator|->
name|flags
operator|&
name|CAM_DIR_MASK
operator|)
operator|!=
name|CAM_DIR_NONE
condition|)
block|{
if|if
condition|(
operator|(
name|ccb_h
operator|->
name|flags
operator|&
name|CAM_SCATTER_VALID
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* We've been given a pointer to a single buffer */
if|if
condition|(
operator|(
name|ccb_h
operator|->
name|flags
operator|&
name|CAM_DATA_PHYS
operator|)
operator|==
literal|0
condition|)
block|{
name|int
name|s
decl_stmt|;
name|int
name|error
decl_stmt|;
name|s
operator|=
name|splsoftvm
argument_list|()
expr_stmt|;
name|error
operator|=
name|bus_dmamap_load
argument_list|(
name|ahc
operator|->
name|buffer_dmat
argument_list|,
name|scb
operator|->
name|dmamap
argument_list|,
name|csio
operator|->
name|data_ptr
argument_list|,
name|csio
operator|->
name|dxfer_len
argument_list|,
name|ahc_execute_scb
argument_list|,
name|scb
argument_list|,
comment|/*flags*/
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|EINPROGRESS
condition|)
block|{
comment|/* 					 * So as to maintain ordering, 					 * freeze the controller queue 					 * until our mapping is 					 * returned. 					 */
name|xpt_freeze_simq
argument_list|(
name|sim
argument_list|,
comment|/*count*/
literal|1
argument_list|)
expr_stmt|;
name|scb
operator|->
name|io_ctx
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_RELEASE_SIMQ
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|struct
name|bus_dma_segment
name|seg
decl_stmt|;
comment|/* Pointer to physical buffer */
if|if
condition|(
name|csio
operator|->
name|dxfer_len
operator|>
name|AHC_MAXTRANSFER_SIZE
condition|)
name|panic
argument_list|(
literal|"ahc_setup_data - Transfer size "
literal|"larger than can device max"
argument_list|)
expr_stmt|;
name|seg
operator|.
name|ds_addr
operator|=
operator|(
name|bus_addr_t
operator|)
name|csio
operator|->
name|data_ptr
expr_stmt|;
name|seg
operator|.
name|ds_len
operator|=
name|csio
operator|->
name|dxfer_len
expr_stmt|;
name|ahc_execute_scb
argument_list|(
name|scb
argument_list|,
operator|&
name|seg
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|struct
name|bus_dma_segment
modifier|*
name|segs
decl_stmt|;
if|if
condition|(
operator|(
name|ccb_h
operator|->
name|flags
operator|&
name|CAM_DATA_PHYS
operator|)
operator|!=
literal|0
condition|)
name|panic
argument_list|(
literal|"ahc_setup_data - Physical segment "
literal|"pointers unsupported"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ccb_h
operator|->
name|flags
operator|&
name|CAM_SG_LIST_PHYS
operator|)
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"ahc_setup_data - Virtual segment "
literal|"addresses unsupported"
argument_list|)
expr_stmt|;
comment|/* Just use the segments provided */
name|segs
operator|=
operator|(
expr|struct
name|bus_dma_segment
operator|*
operator|)
name|csio
operator|->
name|data_ptr
expr_stmt|;
name|ahc_execute_scb
argument_list|(
name|scb
argument_list|,
name|segs
argument_list|,
name|csio
operator|->
name|sglist_cnt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|ahc_execute_scb
argument_list|(
name|scb
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ahc_set_recoveryscb
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|struct
name|scb
modifier|*
name|scb
parameter_list|)
block|{
if|if
condition|(
operator|(
name|scb
operator|->
name|flags
operator|&
name|SCB_RECOVERY_SCB
operator|)
operator|==
literal|0
condition|)
block|{
name|struct
name|scb
modifier|*
name|list_scb
decl_stmt|;
name|scb
operator|->
name|flags
operator||=
name|SCB_RECOVERY_SCB
expr_stmt|;
comment|/* 		 * Take all queued, but not sent SCBs out of the equation. 		 * Also ensure that no new CCBs are queued to us while we 		 * try to fix this problem. 		 */
if|if
condition|(
operator|(
name|scb
operator|->
name|io_ctx
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_RELEASE_SIMQ
operator|)
operator|==
literal|0
condition|)
block|{
name|xpt_freeze_simq
argument_list|(
name|SCB_GET_SIM
argument_list|(
name|ahc
argument_list|,
name|scb
argument_list|)
argument_list|,
comment|/*count*/
literal|1
argument_list|)
expr_stmt|;
name|scb
operator|->
name|io_ctx
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_RELEASE_SIMQ
expr_stmt|;
block|}
comment|/* 		 * Go through all of our pending SCBs and remove 		 * any scheduled timeouts for them.  We will reschedule 		 * them after we've successfully fixed this problem. 		 */
name|LIST_FOREACH
argument_list|(
argument|list_scb
argument_list|,
argument|&ahc->pending_scbs
argument_list|,
argument|pending_links
argument_list|)
block|{
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|ccb
operator|=
name|list_scb
operator|->
name|io_ctx
expr_stmt|;
name|untimeout
argument_list|(
name|ahc_timeout
argument_list|,
name|list_scb
argument_list|,
name|ccb
operator|->
name|ccb_h
operator|.
name|timeout_ch
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|void
name|ahc_timeout
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|scb
modifier|*
name|scb
decl_stmt|;
name|struct
name|ahc_softc
modifier|*
name|ahc
decl_stmt|;
name|long
name|s
decl_stmt|;
name|int
name|found
decl_stmt|;
name|u_int
name|last_phase
decl_stmt|;
name|int
name|target
decl_stmt|;
name|int
name|lun
decl_stmt|;
name|int
name|i
decl_stmt|;
name|char
name|channel
decl_stmt|;
name|scb
operator|=
operator|(
expr|struct
name|scb
operator|*
operator|)
name|arg
expr_stmt|;
name|ahc
operator|=
operator|(
expr|struct
name|ahc_softc
operator|*
operator|)
name|scb
operator|->
name|io_ctx
operator|->
name|ccb_h
operator|.
name|ccb_ahc_ptr
expr_stmt|;
name|ahc_lock
argument_list|(
name|ahc
argument_list|,
operator|&
name|s
argument_list|)
expr_stmt|;
comment|/* 	 * Ensure that the card doesn't do anything 	 * behind our back.  Also make sure that we 	 * didn't "just" miss an interrupt that would 	 * affect this timeout. 	 */
do|do
block|{
name|ahc_intr
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
name|pause_sequencer
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|INTSTAT
argument_list|)
operator|&
name|INT_PEND
condition|)
do|;
comment|/* Make sure the sequencer is in a safe location. */
name|ahc_clear_critical_section
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
name|ahc_print_path
argument_list|(
name|ahc
argument_list|,
name|scb
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|scb
operator|->
name|flags
operator|&
name|SCB_ACTIVE
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* Previous timeout took care of me already */
name|printf
argument_list|(
literal|"Timedout SCB %d handled by another timeout\n"
argument_list|,
name|scb
operator|->
name|hscb
operator|->
name|tag
argument_list|)
expr_stmt|;
name|unpause_sequencer
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
name|ahc_unlock
argument_list|(
name|ahc
argument_list|,
operator|&
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
name|target
operator|=
name|SCB_GET_TARGET
argument_list|(
name|ahc
argument_list|,
name|scb
argument_list|)
expr_stmt|;
name|channel
operator|=
name|SCB_GET_CHANNEL
argument_list|(
name|ahc
argument_list|,
name|scb
argument_list|)
expr_stmt|;
name|lun
operator|=
name|SCB_GET_LUN
argument_list|(
name|scb
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"SCB 0x%x - timed out "
argument_list|,
name|scb
operator|->
name|hscb
operator|->
name|tag
argument_list|)
expr_stmt|;
comment|/* 	 * Take a snapshot of the bus state and print out 	 * some information so we can track down driver bugs. 	 */
name|last_phase
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|LASTPHASE
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_phases
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|last_phase
operator|==
name|phase_table
index|[
name|i
index|]
operator|.
name|phase
condition|)
break|break;
block|}
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|phase_table
index|[
name|i
index|]
operator|.
name|phasemsg
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|", SEQADDR == 0x%x\n"
argument_list|,
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SEQADDR0
argument_list|)
operator||
operator|(
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SEQADDR1
argument_list|)
operator|<<
literal|8
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|scb
operator|->
name|sg_count
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|scb
operator|->
name|sg_count
condition|;
name|i
operator|++
control|)
block|{
name|printf
argument_list|(
literal|"sg[%d] - Addr 0x%x : Length %d\n"
argument_list|,
name|i
argument_list|,
name|scb
operator|->
name|sg_list
index|[
name|i
index|]
operator|.
name|addr
argument_list|,
name|scb
operator|->
name|sg_list
index|[
name|i
index|]
operator|.
name|len
operator|&
name|AHC_SG_LEN_MASK
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|scb
operator|->
name|flags
operator|&
operator|(
name|SCB_DEVICE_RESET
operator||
name|SCB_ABORT
operator|)
condition|)
block|{
comment|/* 		 * Been down this road before. 		 * Do a full bus reset. 		 */
name|bus_reset
label|:
name|ahc_set_transaction_status
argument_list|(
name|scb
argument_list|,
name|CAM_CMD_TIMEOUT
argument_list|)
expr_stmt|;
name|found
operator|=
name|ahc_reset_channel
argument_list|(
name|ahc
argument_list|,
name|channel
argument_list|,
comment|/*Initiate Reset*/
name|TRUE
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s: Issued Channel %c Bus Reset. "
literal|"%d SCBs aborted\n"
argument_list|,
name|ahc_name
argument_list|(
name|ahc
argument_list|)
argument_list|,
name|channel
argument_list|,
name|found
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * If we are a target, transition to bus free and report 		 * the timeout. 		 *  		 * The target/initiator that is holding up the bus may not 		 * be the same as the one that triggered this timeout 		 * (different commands have different timeout lengths). 		 * If the bus is idle and we are actiing as the initiator 		 * for this request, queue a BDR message to the timed out 		 * target.  Otherwise, if the timed out transaction is 		 * active: 		 *   Initiator transaction: 		 *	Stuff the message buffer with a BDR message and assert 		 *	ATN in the hopes that the target will let go of the bus 		 *	and go to the mesgout phase.  If this fails, we'll 		 *	get another timeout 2 seconds later which will attempt 		 *	a bus reset. 		 * 		 *   Target transaction: 		 *	Transition to BUS FREE and report the error. 		 *	It's good to be the target! 		 */
name|u_int
name|active_scb_index
decl_stmt|;
name|active_scb_index
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCB_TAG
argument_list|)
expr_stmt|;
if|if
condition|(
name|last_phase
operator|!=
name|P_BUSFREE
operator|&&
operator|(
name|active_scb_index
operator|<
name|ahc
operator|->
name|scb_data
operator|->
name|numscbs
operator|)
condition|)
block|{
name|struct
name|scb
modifier|*
name|active_scb
decl_stmt|;
comment|/* 			 * If the active SCB is not from our device, 			 * assume that another device is hogging the bus 			 * and wait for it's timeout to expire before 			 * taking additional action. 			 */
name|active_scb
operator|=
name|ahc_lookup_scb
argument_list|(
name|ahc
argument_list|,
name|active_scb_index
argument_list|)
expr_stmt|;
if|if
condition|(
name|active_scb
operator|->
name|hscb
operator|->
name|scsiid
operator|!=
name|scb
operator|->
name|hscb
operator|->
name|scsiid
operator|||
name|active_scb
operator|->
name|hscb
operator|->
name|lun
operator|!=
name|scb
operator|->
name|hscb
operator|->
name|lun
condition|)
block|{
name|struct
name|ccb_hdr
modifier|*
name|ccbh
decl_stmt|;
name|u_int
name|newtimeout
decl_stmt|;
name|ahc_print_path
argument_list|(
name|ahc
argument_list|,
name|scb
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Other SCB Timeout%s"
argument_list|,
operator|(
name|scb
operator|->
name|flags
operator|&
name|SCB_OTHERTCL_TIMEOUT
operator|)
operator|!=
literal|0
condition|?
literal|" again\n"
else|:
literal|"\n"
argument_list|)
expr_stmt|;
name|scb
operator|->
name|flags
operator||=
name|SCB_OTHERTCL_TIMEOUT
expr_stmt|;
name|newtimeout
operator|=
name|MAX
argument_list|(
name|active_scb
operator|->
name|io_ctx
operator|->
name|ccb_h
operator|.
name|timeout
argument_list|,
name|scb
operator|->
name|io_ctx
operator|->
name|ccb_h
operator|.
name|timeout
argument_list|)
expr_stmt|;
name|ccbh
operator|=
operator|&
name|scb
operator|->
name|io_ctx
operator|->
name|ccb_h
expr_stmt|;
name|scb
operator|->
name|io_ctx
operator|->
name|ccb_h
operator|.
name|timeout_ch
operator|=
name|timeout
argument_list|(
name|ahc_timeout
argument_list|,
name|scb
argument_list|,
operator|(
name|newtimeout
operator|*
name|hz
operator|)
operator|/
literal|1000
argument_list|)
expr_stmt|;
name|ahc_unlock
argument_list|(
name|ahc
argument_list|,
operator|&
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* It's us */
if|if
condition|(
operator|(
name|scb
operator|->
name|hscb
operator|->
name|control
operator|&
name|TARGET_SCB
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* 				 * Send back any queued up transactions 				 * and properly record the error condition. 				 */
name|ahc_freeze_devq
argument_list|(
name|ahc
argument_list|,
name|scb
argument_list|)
expr_stmt|;
name|ahc_set_transaction_status
argument_list|(
name|scb
argument_list|,
name|CAM_CMD_TIMEOUT
argument_list|)
expr_stmt|;
name|ahc_freeze_scb
argument_list|(
name|scb
argument_list|)
expr_stmt|;
name|ahc_done
argument_list|(
name|ahc
argument_list|,
name|scb
argument_list|)
expr_stmt|;
comment|/* Will clear us from the bus */
name|restart_sequencer
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
name|ahc_unlock
argument_list|(
name|ahc
argument_list|,
operator|&
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
name|ahc_set_recoveryscb
argument_list|(
name|ahc
argument_list|,
name|active_scb
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|MSG_OUT
argument_list|,
name|MSG_BUS_DEV_RESET
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCSISIGO
argument_list|,
name|last_phase
operator||
name|ATNO
argument_list|)
expr_stmt|;
name|ahc_print_path
argument_list|(
name|ahc
argument_list|,
name|active_scb
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"BDR message in message buffer\n"
argument_list|)
expr_stmt|;
name|active_scb
operator|->
name|flags
operator||=
name|SCB_DEVICE_RESET
expr_stmt|;
name|active_scb
operator|->
name|io_ctx
operator|->
name|ccb_h
operator|.
name|timeout_ch
operator|=
name|timeout
argument_list|(
name|ahc_timeout
argument_list|,
operator|(
name|caddr_t
operator|)
name|active_scb
argument_list|,
literal|2
operator|*
name|hz
argument_list|)
expr_stmt|;
name|unpause_sequencer
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|disconnected
decl_stmt|;
comment|/* XXX Shouldn't panic.  Just punt instead */
if|if
condition|(
operator|(
name|scb
operator|->
name|hscb
operator|->
name|control
operator|&
name|TARGET_SCB
operator|)
operator|!=
literal|0
condition|)
name|panic
argument_list|(
literal|"Timed-out target SCB but bus idle"
argument_list|)
expr_stmt|;
if|if
condition|(
name|last_phase
operator|!=
name|P_BUSFREE
operator|&&
operator|(
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SSTAT0
argument_list|)
operator|&
name|TARGET
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* XXX What happened to the SCB? */
comment|/* Hung target selection.  Goto busfree */
name|printf
argument_list|(
literal|"%s: Hung target selection\n"
argument_list|,
name|ahc_name
argument_list|(
name|ahc
argument_list|)
argument_list|)
expr_stmt|;
name|restart_sequencer
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
name|ahc_unlock
argument_list|(
name|ahc
argument_list|,
operator|&
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|ahc_search_qinfifo
argument_list|(
name|ahc
argument_list|,
name|target
argument_list|,
name|channel
argument_list|,
name|lun
argument_list|,
name|scb
operator|->
name|hscb
operator|->
name|tag
argument_list|,
name|ROLE_INITIATOR
argument_list|,
comment|/*status*/
literal|0
argument_list|,
name|SEARCH_COUNT
argument_list|)
operator|>
literal|0
condition|)
block|{
name|disconnected
operator|=
name|FALSE
expr_stmt|;
block|}
else|else
block|{
name|disconnected
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
name|disconnected
condition|)
block|{
name|struct
name|scb
modifier|*
name|prev_scb
decl_stmt|;
name|ahc_set_recoveryscb
argument_list|(
name|ahc
argument_list|,
name|scb
argument_list|)
expr_stmt|;
comment|/* 				 * Simply set the MK_MESSAGE control bit. 				 */
name|scb
operator|->
name|hscb
operator|->
name|control
operator||=
name|MK_MESSAGE
expr_stmt|;
name|scb
operator|->
name|flags
operator||=
name|SCB_QUEUED_MSG
operator||
name|SCB_DEVICE_RESET
expr_stmt|;
comment|/* 				 * Actually re-queue this SCB in an attempt 				 * to select the device before it reconnects. 				 * In either case (selection or reselection), 				 * we will now issue a target reset to the 				 * timed-out device. 				 * 				 * Remove any cached copy of this SCB in the 				 * disconnected list in preparation for the 				 * queuing of our abort SCB.  We use the 				 * same element in the SCB, SCB_NEXT, for 				 * both the qinfifo and the disconnected list. 				 */
name|ahc_search_disc_list
argument_list|(
name|ahc
argument_list|,
name|target
argument_list|,
name|channel
argument_list|,
name|lun
argument_list|,
name|scb
operator|->
name|hscb
operator|->
name|tag
argument_list|,
comment|/*stop_on_first*/
name|TRUE
argument_list|,
comment|/*remove*/
name|TRUE
argument_list|,
comment|/*save_state*/
name|TRUE
argument_list|)
expr_stmt|;
comment|/* 				 * Clear out any entries in the QINFIFO first 				 * so we are the next SCB for this target 				 * to run. 				 */
name|ahc_search_qinfifo
argument_list|(
name|ahc
argument_list|,
name|SCB_GET_TARGET
argument_list|(
name|ahc
argument_list|,
name|scb
argument_list|)
argument_list|,
name|channel
argument_list|,
name|SCB_GET_LUN
argument_list|(
name|scb
argument_list|)
argument_list|,
name|SCB_LIST_NULL
argument_list|,
name|ROLE_INITIATOR
argument_list|,
name|CAM_REQUEUE_REQ
argument_list|,
name|SEARCH_COMPLETE
argument_list|)
expr_stmt|;
name|ahc_print_path
argument_list|(
name|ahc
argument_list|,
name|scb
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Queuing a BDR SCB\n"
argument_list|)
expr_stmt|;
name|prev_scb
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|ahc_qinfifo_count
argument_list|(
name|ahc
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|u_int
name|prev_tag
decl_stmt|;
name|prev_tag
operator|=
name|ahc
operator|->
name|qinfifo
index|[
name|ahc
operator|->
name|qinfifonext
operator|-
literal|1
index|]
expr_stmt|;
name|prev_scb
operator|=
name|ahc_lookup_scb
argument_list|(
name|ahc
argument_list|,
name|prev_tag
argument_list|)
expr_stmt|;
block|}
name|ahc_qinfifo_requeue
argument_list|(
name|ahc
argument_list|,
name|prev_scb
argument_list|,
name|scb
argument_list|)
expr_stmt|;
name|scb
operator|->
name|io_ctx
operator|->
name|ccb_h
operator|.
name|timeout_ch
operator|=
name|timeout
argument_list|(
name|ahc_timeout
argument_list|,
operator|(
name|caddr_t
operator|)
name|scb
argument_list|,
literal|2
operator|*
name|hz
argument_list|)
expr_stmt|;
name|unpause_sequencer
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Go "immediatly" to the bus reset */
comment|/* This shouldn't happen */
name|ahc_set_recoveryscb
argument_list|(
name|ahc
argument_list|,
name|scb
argument_list|)
expr_stmt|;
name|ahc_print_path
argument_list|(
name|ahc
argument_list|,
name|scb
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"SCB %d: Immediate reset.  "
literal|"Flags = 0x%x\n"
argument_list|,
name|scb
operator|->
name|hscb
operator|->
name|tag
argument_list|,
name|scb
operator|->
name|flags
argument_list|)
expr_stmt|;
goto|goto
name|bus_reset
goto|;
block|}
block|}
block|}
name|ahc_unlock
argument_list|(
name|ahc
argument_list|,
operator|&
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ahc_abort_ccb
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|struct
name|cam_sim
modifier|*
name|sim
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
block|{
name|union
name|ccb
modifier|*
name|abort_ccb
decl_stmt|;
name|abort_ccb
operator|=
name|ccb
operator|->
name|cab
operator|.
name|abort_ccb
expr_stmt|;
switch|switch
condition|(
name|abort_ccb
operator|->
name|ccb_h
operator|.
name|func_code
condition|)
block|{
case|case
name|XPT_ACCEPT_TARGET_IO
case|:
case|case
name|XPT_IMMED_NOTIFY
case|:
case|case
name|XPT_CONT_TARGET_IO
case|:
block|{
name|struct
name|tmode_tstate
modifier|*
name|tstate
decl_stmt|;
name|struct
name|tmode_lstate
modifier|*
name|lstate
decl_stmt|;
name|struct
name|ccb_hdr_slist
modifier|*
name|list
decl_stmt|;
name|cam_status
name|status
decl_stmt|;
name|status
operator|=
name|ahc_find_tmode_devs
argument_list|(
name|ahc
argument_list|,
name|sim
argument_list|,
name|abort_ccb
argument_list|,
operator|&
name|tstate
argument_list|,
operator|&
name|lstate
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|status
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|abort_ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|==
name|XPT_ACCEPT_TARGET_IO
condition|)
name|list
operator|=
operator|&
name|lstate
operator|->
name|accept_tios
expr_stmt|;
elseif|else
if|if
condition|(
name|abort_ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|==
name|XPT_IMMED_NOTIFY
condition|)
name|list
operator|=
operator|&
name|lstate
operator|->
name|immed_notifies
expr_stmt|;
else|else
name|list
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|list
operator|!=
name|NULL
condition|)
block|{
name|struct
name|ccb_hdr
modifier|*
name|curelm
decl_stmt|;
name|int
name|found
decl_stmt|;
name|curelm
operator|=
name|SLIST_FIRST
argument_list|(
name|list
argument_list|)
expr_stmt|;
name|found
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|curelm
operator|==
operator|&
name|abort_ccb
operator|->
name|ccb_h
condition|)
block|{
name|found
operator|=
literal|1
expr_stmt|;
name|SLIST_REMOVE_HEAD
argument_list|(
name|list
argument_list|,
name|sim_links
operator|.
name|sle
argument_list|)
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
name|curelm
operator|!=
name|NULL
condition|)
block|{
name|struct
name|ccb_hdr
modifier|*
name|nextelm
decl_stmt|;
name|nextelm
operator|=
name|SLIST_NEXT
argument_list|(
name|curelm
argument_list|,
name|sim_links
operator|.
name|sle
argument_list|)
expr_stmt|;
if|if
condition|(
name|nextelm
operator|==
operator|&
name|abort_ccb
operator|->
name|ccb_h
condition|)
block|{
name|found
operator|=
literal|1
expr_stmt|;
name|SLIST_NEXT
argument_list|(
name|curelm
argument_list|,
name|sim_links
operator|.
name|sle
argument_list|)
operator|=
name|SLIST_NEXT
argument_list|(
name|nextelm
argument_list|,
name|sim_links
operator|.
name|sle
argument_list|)
expr_stmt|;
break|break;
block|}
name|curelm
operator|=
name|nextelm
expr_stmt|;
block|}
block|}
if|if
condition|(
name|found
condition|)
block|{
name|abort_ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_ABORTED
expr_stmt|;
name|xpt_done
argument_list|(
name|abort_ccb
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"Not found\n"
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_PATH_INVALID
expr_stmt|;
block|}
break|break;
block|}
comment|/* FALLTHROUGH */
block|}
case|case
name|XPT_SCSI_IO
case|:
comment|/* XXX Fully implement the hard ones */
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_UA_ABORT
expr_stmt|;
break|break;
default|default:
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_INVALID
expr_stmt|;
break|break;
block|}
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ahc_send_async
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|char
name|channel
parameter_list|,
name|u_int
name|target
parameter_list|,
name|u_int
name|lun
parameter_list|,
name|ac_code
name|code
parameter_list|)
block|{
name|struct
name|ccb_trans_settings
name|cts
decl_stmt|;
name|struct
name|cam_path
modifier|*
name|path
decl_stmt|;
name|void
modifier|*
name|arg
decl_stmt|;
name|int
name|error
decl_stmt|;
name|arg
operator|=
name|NULL
expr_stmt|;
name|error
operator|=
name|ahc_create_path
argument_list|(
name|ahc
argument_list|,
name|channel
argument_list|,
name|target
argument_list|,
name|lun
argument_list|,
operator|&
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
name|CAM_REQ_CMP
condition|)
return|return;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|AC_TRANSFER_NEG
case|:
ifdef|#
directive|ifdef
name|AHC_NEW_TRAN_SETTINGS
name|cts
operator|.
name|type
operator|=
name|CTS_TYPE_CURRENT_SETTINGS
expr_stmt|;
else|#
directive|else
name|cts
operator|.
name|flags
operator|=
name|CCB_TRANS_CURRENT_SETTINGS
expr_stmt|;
endif|#
directive|endif
name|cts
operator|.
name|ccb_h
operator|.
name|path
operator|=
name|path
expr_stmt|;
name|cts
operator|.
name|ccb_h
operator|.
name|target_id
operator|=
name|target
expr_stmt|;
name|cts
operator|.
name|ccb_h
operator|.
name|target_lun
operator|=
name|lun
expr_stmt|;
name|ahc_get_tran_settings
argument_list|(
name|ahc
argument_list|,
name|channel
operator|==
literal|'A'
condition|?
name|ahc
operator|->
name|our_id
else|:
name|ahc
operator|->
name|our_id_b
argument_list|,
name|channel
argument_list|,
operator|&
name|cts
argument_list|)
expr_stmt|;
name|arg
operator|=
operator|&
name|cts
expr_stmt|;
break|break;
case|case
name|AC_SENT_BDR
case|:
case|case
name|AC_BUS_RESET
case|:
break|break;
default|default:
name|panic
argument_list|(
literal|"ahc_send_async: Unexpected async event"
argument_list|)
expr_stmt|;
block|}
name|xpt_async
argument_list|(
name|code
argument_list|,
name|path
argument_list|,
name|arg
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ahc_platform_set_tags
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|struct
name|ahc_devinfo
modifier|*
name|devinfo
parameter_list|,
name|int
name|enable
parameter_list|)
block|{ }
end_function

begin_function
name|int
name|ahc_platform_alloc
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|void
modifier|*
name|platform_arg
parameter_list|)
block|{
name|ahc
operator|->
name|platform_data
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ahc_platform_data
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|ahc
operator|->
name|platform_data
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|memset
argument_list|(
name|ahc
operator|->
name|platform_data
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ahc_platform_data
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|ahc_platform_free
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|)
block|{
if|if
condition|(
name|ahc
operator|->
name|platform_data
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|ahc
operator|->
name|platform_data
operator|->
name|regs
operator|!=
name|NULL
condition|)
name|bus_release_resource
argument_list|(
name|ahc
operator|->
name|dev_softc
argument_list|,
name|ahc
operator|->
name|platform_data
operator|->
name|regs_res_type
argument_list|,
name|ahc
operator|->
name|platform_data
operator|->
name|regs_res_id
argument_list|,
name|ahc
operator|->
name|platform_data
operator|->
name|regs
argument_list|)
expr_stmt|;
if|if
condition|(
name|ahc
operator|->
name|platform_data
operator|->
name|irq
operator|!=
name|NULL
condition|)
name|bus_release_resource
argument_list|(
name|ahc
operator|->
name|dev_softc
argument_list|,
name|ahc
operator|->
name|platform_data
operator|->
name|irq_res_type
argument_list|,
literal|0
argument_list|,
name|ahc
operator|->
name|platform_data
operator|->
name|irq
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ahc
operator|->
name|platform_data
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|ahc_softc_comp
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|lahc
parameter_list|,
name|struct
name|ahc_softc
modifier|*
name|rahc
parameter_list|)
block|{
comment|/* We don't sort softcs under FreeBSD so report equal always */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
name|UNUSED
end_if

begin_function
specifier|static
name|void
name|ahc_dump_targcmd
parameter_list|(
name|struct
name|target_cmd
modifier|*
name|cmd
parameter_list|)
block|{
name|uint8_t
modifier|*
name|byte
decl_stmt|;
name|uint8_t
modifier|*
name|last_byte
decl_stmt|;
name|int
name|i
decl_stmt|;
name|byte
operator|=
operator|&
name|cmd
operator|->
name|initiator_channel
expr_stmt|;
comment|/* Debugging info for received commands */
name|last_byte
operator|=
operator|&
name|cmd
index|[
literal|1
index|]
operator|.
name|initiator_channel
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|byte
operator|<
name|last_byte
condition|)
block|{
if|if
condition|(
name|i
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"\t"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%#x"
argument_list|,
operator|*
name|byte
operator|++
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|8
condition|)
block|{
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

