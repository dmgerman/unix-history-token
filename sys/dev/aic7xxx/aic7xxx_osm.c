begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Bus independent FreeBSD shim for the aic7xxx based Adaptec SCSI controllers  *  * Copyright (c) 1994-2001 Justin T. Gibbs.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions, and the following disclaimer,  *    without modification.  * 2. The name of the author may not be used to endorse or promote products  *    derived from this software without specific prior written permission.  *  * Alternatively, this software may be distributed under the terms of the  * GNU Public License ("GPL").  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE FOR  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $Id: //depot/aic7xxx/freebsd/dev/aic7xxx/aic7xxx_osm.c#20 $  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<dev/aic7xxx/aic7xxx_osm.h>
end_include

begin_include
include|#
directive|include
file|<dev/aic7xxx/aic7xxx_inline.h>
end_include

begin_include
include|#
directive|include
file|<sys/kthread.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|AHC_TMODE_ENABLE
end_ifndef

begin_define
define|#
directive|define
name|AHC_TMODE_ENABLE
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<dev/aic7xxx/aic_osm_lib.c>
end_include

begin_define
define|#
directive|define
name|ccb_scb_ptr
value|spriv_ptr0
end_define

begin_decl_stmt
name|devclass_t
name|ahc_devclass
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static void	ahc_dump_targcmd(struct target_cmd *cmd);
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|int
name|ahc_modevent
parameter_list|(
name|module_t
name|mod
parameter_list|,
name|int
name|type
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ahc_action
parameter_list|(
name|struct
name|cam_sim
modifier|*
name|sim
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ahc_get_tran_settings
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|int
name|our_id
parameter_list|,
name|char
name|channel
parameter_list|,
name|struct
name|ccb_trans_settings
modifier|*
name|cts
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ahc_async
parameter_list|(
name|void
modifier|*
name|callback_arg
parameter_list|,
name|uint32_t
name|code
parameter_list|,
name|struct
name|cam_path
modifier|*
name|path
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ahc_execute_scb
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|dm_segs
parameter_list|,
name|int
name|nsegments
parameter_list|,
name|int
name|error
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ahc_poll
parameter_list|(
name|struct
name|cam_sim
modifier|*
name|sim
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ahc_setup_data
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|struct
name|cam_sim
modifier|*
name|sim
parameter_list|,
name|struct
name|ccb_scsiio
modifier|*
name|csio
parameter_list|,
name|struct
name|scb
modifier|*
name|scb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ahc_abort_ccb
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|struct
name|cam_sim
modifier|*
name|sim
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ahc_create_path
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|char
name|channel
parameter_list|,
name|u_int
name|target
parameter_list|,
name|u_int
name|lun
parameter_list|,
name|struct
name|cam_path
modifier|*
modifier|*
name|path
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|int
name|ahc_create_path
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|char
name|channel
parameter_list|,
name|u_int
name|target
parameter_list|,
name|u_int
name|lun
parameter_list|,
name|struct
name|cam_path
modifier|*
modifier|*
name|path
parameter_list|)
block|{
name|path_id_t
name|path_id
decl_stmt|;
if|if
condition|(
name|channel
operator|==
literal|'B'
condition|)
name|path_id
operator|=
name|cam_sim_path
argument_list|(
name|ahc
operator|->
name|platform_data
operator|->
name|sim_b
argument_list|)
expr_stmt|;
else|else
name|path_id
operator|=
name|cam_sim_path
argument_list|(
name|ahc
operator|->
name|platform_data
operator|->
name|sim
argument_list|)
expr_stmt|;
return|return
operator|(
name|xpt_create_path
argument_list|(
name|path
argument_list|,
comment|/*periph*/
name|NULL
argument_list|,
name|path_id
argument_list|,
name|target
argument_list|,
name|lun
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ahc_map_int
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|int
name|zero
decl_stmt|;
name|int
name|shareable
decl_stmt|;
name|zero
operator|=
literal|0
expr_stmt|;
name|shareable
operator|=
operator|(
name|ahc
operator|->
name|flags
operator|&
name|AHC_EDGE_INTERRUPT
operator|)
condition|?
literal|0
else|:
name|RF_SHAREABLE
expr_stmt|;
name|ahc
operator|->
name|platform_data
operator|->
name|irq
operator|=
name|bus_alloc_resource_any
argument_list|(
name|ahc
operator|->
name|dev_softc
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|zero
argument_list|,
name|RF_ACTIVE
operator||
name|shareable
argument_list|)
expr_stmt|;
if|if
condition|(
name|ahc
operator|->
name|platform_data
operator|->
name|irq
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|ahc
operator|->
name|dev_softc
argument_list|,
literal|"bus_alloc_resource() failed to allocate IRQ\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|ahc
operator|->
name|platform_data
operator|->
name|irq_res_type
operator|=
name|SYS_RES_IRQ
expr_stmt|;
comment|/* Hook up our interrupt handler */
name|error
operator|=
name|bus_setup_intr
argument_list|(
name|ahc
operator|->
name|dev_softc
argument_list|,
name|ahc
operator|->
name|platform_data
operator|->
name|irq
argument_list|,
name|INTR_TYPE_CAM
argument_list|,
name|NULL
argument_list|,
name|ahc_platform_intr
argument_list|,
name|ahc
argument_list|,
operator|&
name|ahc
operator|->
name|platform_data
operator|->
name|ih
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
name|device_printf
argument_list|(
name|ahc
operator|->
name|dev_softc
argument_list|,
literal|"bus_setup_intr() failed: %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|aic7770_map_registers
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|u_int
name|unused_ioport_arg
parameter_list|)
block|{
name|struct
name|resource
modifier|*
name|regs
decl_stmt|;
name|int
name|rid
decl_stmt|;
name|rid
operator|=
literal|0
expr_stmt|;
name|regs
operator|=
name|bus_alloc_resource_any
argument_list|(
name|ahc
operator|->
name|dev_softc
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
operator|&
name|rid
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|regs
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|ahc
operator|->
name|dev_softc
argument_list|,
literal|"Unable to map I/O space?!\n"
argument_list|)
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
name|ahc
operator|->
name|platform_data
operator|->
name|regs_res_type
operator|=
name|SYS_RES_IOPORT
expr_stmt|;
name|ahc
operator|->
name|platform_data
operator|->
name|regs_res_id
operator|=
name|rid
operator|,
name|ahc
operator|->
name|platform_data
operator|->
name|regs
operator|=
name|regs
expr_stmt|;
name|ahc
operator|->
name|tag
operator|=
name|rman_get_bustag
argument_list|(
name|regs
argument_list|)
expr_stmt|;
name|ahc
operator|->
name|bsh
operator|=
name|rman_get_bushandle
argument_list|(
name|regs
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Attach all the sub-devices we can find  */
end_comment

begin_function
name|int
name|ahc_attach
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|)
block|{
name|char
name|ahc_info
index|[
literal|256
index|]
decl_stmt|;
name|struct
name|ccb_setasync
name|csa
decl_stmt|;
name|struct
name|cam_devq
modifier|*
name|devq
decl_stmt|;
name|int
name|bus_id
decl_stmt|;
name|int
name|bus_id2
decl_stmt|;
name|struct
name|cam_sim
modifier|*
name|sim
decl_stmt|;
name|struct
name|cam_sim
modifier|*
name|sim2
decl_stmt|;
name|struct
name|cam_path
modifier|*
name|path
decl_stmt|;
name|struct
name|cam_path
modifier|*
name|path2
decl_stmt|;
name|long
name|s
decl_stmt|;
name|int
name|count
decl_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
name|sim
operator|=
name|NULL
expr_stmt|;
name|sim2
operator|=
name|NULL
expr_stmt|;
name|path
operator|=
name|NULL
expr_stmt|;
name|path2
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * Create a thread to perform all recovery. 	 */
if|if
condition|(
name|ahc_spawn_recovery_thread
argument_list|(
name|ahc
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|fail
goto|;
name|ahc_controller_info
argument_list|(
name|ahc
argument_list|,
name|ahc_info
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|ahc_info
argument_list|)
expr_stmt|;
name|ahc_lock
argument_list|(
name|ahc
argument_list|,
operator|&
name|s
argument_list|)
expr_stmt|;
comment|/* 	 * Attach secondary channel first if the user has 	 * declared it the primary channel. 	 */
if|if
condition|(
operator|(
name|ahc
operator|->
name|features
operator|&
name|AHC_TWIN
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|ahc
operator|->
name|flags
operator|&
name|AHC_PRIMARY_CHANNEL
operator|)
operator|!=
literal|0
condition|)
block|{
name|bus_id
operator|=
literal|1
expr_stmt|;
name|bus_id2
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|bus_id
operator|=
literal|0
expr_stmt|;
name|bus_id2
operator|=
literal|1
expr_stmt|;
block|}
comment|/* 	 * Create the device queue for our SIM(s). 	 */
name|devq
operator|=
name|cam_simq_alloc
argument_list|(
name|AHC_MAX_QUEUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|devq
operator|==
name|NULL
condition|)
goto|goto
name|fail
goto|;
comment|/* 	 * Construct our first channel SIM entry 	 */
name|sim
operator|=
name|cam_sim_alloc
argument_list|(
name|ahc_action
argument_list|,
name|ahc_poll
argument_list|,
literal|"ahc"
argument_list|,
name|ahc
argument_list|,
name|device_get_unit
argument_list|(
name|ahc
operator|->
name|dev_softc
argument_list|)
argument_list|,
operator|&
name|Giant
argument_list|,
literal|1
argument_list|,
name|AHC_MAX_QUEUE
argument_list|,
name|devq
argument_list|)
expr_stmt|;
if|if
condition|(
name|sim
operator|==
name|NULL
condition|)
block|{
name|cam_simq_free
argument_list|(
name|devq
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
if|if
condition|(
name|xpt_bus_register
argument_list|(
name|sim
argument_list|,
name|bus_id
argument_list|)
operator|!=
name|CAM_SUCCESS
condition|)
block|{
name|cam_sim_free
argument_list|(
name|sim
argument_list|,
comment|/*free_devq*/
name|TRUE
argument_list|)
expr_stmt|;
name|sim
operator|=
name|NULL
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
if|if
condition|(
name|xpt_create_path
argument_list|(
operator|&
name|path
argument_list|,
comment|/*periph*/
name|NULL
argument_list|,
name|cam_sim_path
argument_list|(
name|sim
argument_list|)
argument_list|,
name|CAM_TARGET_WILDCARD
argument_list|,
name|CAM_LUN_WILDCARD
argument_list|)
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|xpt_bus_deregister
argument_list|(
name|cam_sim_path
argument_list|(
name|sim
argument_list|)
argument_list|)
expr_stmt|;
name|cam_sim_free
argument_list|(
name|sim
argument_list|,
comment|/*free_devq*/
name|TRUE
argument_list|)
expr_stmt|;
name|sim
operator|=
name|NULL
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|xpt_setup_ccb
argument_list|(
operator|&
name|csa
operator|.
name|ccb_h
argument_list|,
name|path
argument_list|,
comment|/*priority*/
literal|5
argument_list|)
expr_stmt|;
name|csa
operator|.
name|ccb_h
operator|.
name|func_code
operator|=
name|XPT_SASYNC_CB
expr_stmt|;
name|csa
operator|.
name|event_enable
operator|=
name|AC_LOST_DEVICE
expr_stmt|;
name|csa
operator|.
name|callback
operator|=
name|ahc_async
expr_stmt|;
name|csa
operator|.
name|callback_arg
operator|=
name|sim
expr_stmt|;
name|xpt_action
argument_list|(
operator|(
expr|union
name|ccb
operator|*
operator|)
operator|&
name|csa
argument_list|)
expr_stmt|;
name|count
operator|++
expr_stmt|;
if|if
condition|(
name|ahc
operator|->
name|features
operator|&
name|AHC_TWIN
condition|)
block|{
name|sim2
operator|=
name|cam_sim_alloc
argument_list|(
name|ahc_action
argument_list|,
name|ahc_poll
argument_list|,
literal|"ahc"
argument_list|,
name|ahc
argument_list|,
name|device_get_unit
argument_list|(
name|ahc
operator|->
name|dev_softc
argument_list|)
argument_list|,
operator|&
name|Giant
argument_list|,
literal|1
argument_list|,
name|AHC_MAX_QUEUE
argument_list|,
name|devq
argument_list|)
expr_stmt|;
if|if
condition|(
name|sim2
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"ahc_attach: Unable to attach second "
literal|"bus due to resource shortage"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
if|if
condition|(
name|xpt_bus_register
argument_list|(
name|sim2
argument_list|,
name|bus_id2
argument_list|)
operator|!=
name|CAM_SUCCESS
condition|)
block|{
name|printf
argument_list|(
literal|"ahc_attach: Unable to attach second "
literal|"bus due to resource shortage"
argument_list|)
expr_stmt|;
comment|/* 			 * We do not want to destroy the device queue 			 * because the first bus is using it. 			 */
name|cam_sim_free
argument_list|(
name|sim2
argument_list|,
comment|/*free_devq*/
name|FALSE
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
if|if
condition|(
name|xpt_create_path
argument_list|(
operator|&
name|path2
argument_list|,
comment|/*periph*/
name|NULL
argument_list|,
name|cam_sim_path
argument_list|(
name|sim2
argument_list|)
argument_list|,
name|CAM_TARGET_WILDCARD
argument_list|,
name|CAM_LUN_WILDCARD
argument_list|)
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|xpt_bus_deregister
argument_list|(
name|cam_sim_path
argument_list|(
name|sim2
argument_list|)
argument_list|)
expr_stmt|;
name|cam_sim_free
argument_list|(
name|sim2
argument_list|,
comment|/*free_devq*/
name|FALSE
argument_list|)
expr_stmt|;
name|sim2
operator|=
name|NULL
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|xpt_setup_ccb
argument_list|(
operator|&
name|csa
operator|.
name|ccb_h
argument_list|,
name|path2
argument_list|,
comment|/*priority*/
literal|5
argument_list|)
expr_stmt|;
name|csa
operator|.
name|ccb_h
operator|.
name|func_code
operator|=
name|XPT_SASYNC_CB
expr_stmt|;
name|csa
operator|.
name|event_enable
operator|=
name|AC_LOST_DEVICE
expr_stmt|;
name|csa
operator|.
name|callback
operator|=
name|ahc_async
expr_stmt|;
name|csa
operator|.
name|callback_arg
operator|=
name|sim2
expr_stmt|;
name|xpt_action
argument_list|(
operator|(
expr|union
name|ccb
operator|*
operator|)
operator|&
name|csa
argument_list|)
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
name|fail
label|:
if|if
condition|(
operator|(
name|ahc
operator|->
name|features
operator|&
name|AHC_TWIN
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|ahc
operator|->
name|flags
operator|&
name|AHC_PRIMARY_CHANNEL
operator|)
operator|!=
literal|0
condition|)
block|{
name|ahc
operator|->
name|platform_data
operator|->
name|sim_b
operator|=
name|sim
expr_stmt|;
name|ahc
operator|->
name|platform_data
operator|->
name|path_b
operator|=
name|path
expr_stmt|;
name|ahc
operator|->
name|platform_data
operator|->
name|sim
operator|=
name|sim2
expr_stmt|;
name|ahc
operator|->
name|platform_data
operator|->
name|path
operator|=
name|path2
expr_stmt|;
block|}
else|else
block|{
name|ahc
operator|->
name|platform_data
operator|->
name|sim
operator|=
name|sim
expr_stmt|;
name|ahc
operator|->
name|platform_data
operator|->
name|path
operator|=
name|path
expr_stmt|;
name|ahc
operator|->
name|platform_data
operator|->
name|sim_b
operator|=
name|sim2
expr_stmt|;
name|ahc
operator|->
name|platform_data
operator|->
name|path_b
operator|=
name|path2
expr_stmt|;
block|}
if|if
condition|(
name|count
operator|!=
literal|0
condition|)
block|{
comment|/* We have to wait until after any system dumps... */
name|ahc
operator|->
name|platform_data
operator|->
name|eh
operator|=
name|EVENTHANDLER_REGISTER
argument_list|(
name|shutdown_final
argument_list|,
name|ahc_shutdown
argument_list|,
name|ahc
argument_list|,
name|SHUTDOWN_PRI_DEFAULT
argument_list|)
expr_stmt|;
name|ahc_intr_enable
argument_list|(
name|ahc
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
name|ahc_unlock
argument_list|(
name|ahc
argument_list|,
operator|&
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|count
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Catch an interrupt from the adapter  */
end_comment

begin_function
name|void
name|ahc_platform_intr
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ahc_softc
modifier|*
name|ahc
decl_stmt|;
name|ahc
operator|=
operator|(
expr|struct
name|ahc_softc
operator|*
operator|)
name|arg
expr_stmt|;
name|ahc_intr
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * We have an scb which has been processed by the  * adaptor, now we look to see how the operation  * went.  */
end_comment

begin_function
name|void
name|ahc_done
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|struct
name|scb
modifier|*
name|scb
parameter_list|)
block|{
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|CAM_DEBUG
argument_list|(
name|scb
operator|->
name|io_ctx
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
name|CAM_DEBUG_TRACE
argument_list|,
operator|(
literal|"ahc_done - scb %d\n"
operator|,
name|scb
operator|->
name|hscb
operator|->
name|tag
operator|)
argument_list|)
expr_stmt|;
name|ccb
operator|=
name|scb
operator|->
name|io_ctx
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|scb
argument_list|,
name|pending_links
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|scb
operator|->
name|flags
operator|&
name|SCB_TIMEDOUT
operator|)
operator|!=
literal|0
condition|)
name|LIST_REMOVE
argument_list|(
name|scb
argument_list|,
name|timedout_links
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|scb
operator|->
name|flags
operator|&
name|SCB_UNTAGGEDQ
operator|)
operator|!=
literal|0
condition|)
block|{
name|struct
name|scb_tailq
modifier|*
name|untagged_q
decl_stmt|;
name|int
name|target_offset
decl_stmt|;
name|target_offset
operator|=
name|SCB_GET_TARGET_OFFSET
argument_list|(
name|ahc
argument_list|,
name|scb
argument_list|)
expr_stmt|;
name|untagged_q
operator|=
operator|&
name|ahc
operator|->
name|untagged_queues
index|[
name|target_offset
index|]
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
name|untagged_q
argument_list|,
name|scb
argument_list|,
name|links
operator|.
name|tqe
argument_list|)
expr_stmt|;
name|scb
operator|->
name|flags
operator|&=
operator|~
name|SCB_UNTAGGEDQ
expr_stmt|;
name|ahc_run_untagged_queue
argument_list|(
name|ahc
argument_list|,
name|untagged_q
argument_list|)
expr_stmt|;
block|}
name|untimeout
argument_list|(
name|ahc_platform_timeout
argument_list|,
operator|(
name|caddr_t
operator|)
name|scb
argument_list|,
name|ccb
operator|->
name|ccb_h
operator|.
name|timeout_ch
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DIR_MASK
operator|)
operator|!=
name|CAM_DIR_NONE
condition|)
block|{
name|bus_dmasync_op_t
name|op
decl_stmt|;
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DIR_MASK
operator|)
operator|==
name|CAM_DIR_IN
condition|)
name|op
operator|=
name|BUS_DMASYNC_POSTREAD
expr_stmt|;
else|else
name|op
operator|=
name|BUS_DMASYNC_POSTWRITE
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|ahc
operator|->
name|buffer_dmat
argument_list|,
name|scb
operator|->
name|dmamap
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|ahc
operator|->
name|buffer_dmat
argument_list|,
name|scb
operator|->
name|dmamap
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|==
name|XPT_CONT_TARGET_IO
condition|)
block|{
name|struct
name|cam_path
modifier|*
name|ccb_path
decl_stmt|;
comment|/* 		 * If we have finally disconnected, clean up our 		 * pending device state. 		 * XXX - There may be error states that cause where 		 *       we will remain connected. 		 */
name|ccb_path
operator|=
name|ccb
operator|->
name|ccb_h
operator|.
name|path
expr_stmt|;
if|if
condition|(
name|ahc
operator|->
name|pending_device
operator|!=
name|NULL
operator|&&
name|xpt_path_comp
argument_list|(
name|ahc
operator|->
name|pending_device
operator|->
name|path
argument_list|,
name|ccb_path
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_SEND_STATUS
operator|)
operator|!=
literal|0
condition|)
block|{
name|ahc
operator|->
name|pending_device
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|bootverbose
condition|)
block|{
name|xpt_print_path
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Still connected\n"
argument_list|)
expr_stmt|;
block|}
name|aic_freeze_ccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|aic_get_transaction_status
argument_list|(
name|scb
argument_list|)
operator|==
name|CAM_REQ_INPROG
condition|)
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_REQ_CMP
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&=
operator|~
name|CAM_SIM_QUEUED
expr_stmt|;
name|ahc_free_scb
argument_list|(
name|ahc
argument_list|,
name|scb
argument_list|)
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * If the recovery SCB completes, we have to be 	 * out of our timeout. 	 */
if|if
condition|(
operator|(
name|scb
operator|->
name|flags
operator|&
name|SCB_RECOVERY_SCB
operator|)
operator|!=
literal|0
condition|)
block|{
name|struct
name|scb
modifier|*
name|list_scb
decl_stmt|;
name|ahc
operator|->
name|scb_data
operator|->
name|recovery_scbs
operator|--
expr_stmt|;
if|if
condition|(
name|aic_get_transaction_status
argument_list|(
name|scb
argument_list|)
operator|==
name|CAM_BDR_SENT
operator|||
name|aic_get_transaction_status
argument_list|(
name|scb
argument_list|)
operator|==
name|CAM_REQ_ABORTED
condition|)
name|aic_set_transaction_status
argument_list|(
name|scb
argument_list|,
name|CAM_CMD_TIMEOUT
argument_list|)
expr_stmt|;
if|if
condition|(
name|ahc
operator|->
name|scb_data
operator|->
name|recovery_scbs
operator|==
literal|0
condition|)
block|{
comment|/* 			 * All recovery actions have completed successfully, 			 * so reinstate the timeouts for all other pending 			 * commands. 			 */
name|LIST_FOREACH
argument_list|(
argument|list_scb
argument_list|,
argument|&ahc->pending_scbs
argument_list|,
argument|pending_links
argument_list|)
block|{
name|aic_scb_timer_reset
argument_list|(
name|list_scb
argument_list|,
name|aic_get_timeout
argument_list|(
name|scb
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|ahc_print_path
argument_list|(
name|ahc
argument_list|,
name|scb
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"no longer in timeout, status = %x\n"
argument_list|,
name|ccb
operator|->
name|ccb_h
operator|.
name|status
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Don't clobber any existing error state */
if|if
condition|(
name|aic_get_transaction_status
argument_list|(
name|scb
argument_list|)
operator|==
name|CAM_REQ_INPROG
condition|)
block|{
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_REQ_CMP
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|scb
operator|->
name|flags
operator|&
name|SCB_SENSE
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * We performed autosense retrieval. 		 * 		 * Zero any sense not transferred by the 		 * device.  The SCSI spec mandates that any 		 * untransfered data should be assumed to be 		 * zero.  Complete the 'bounce' of sense information 		 * through buffers accessible via bus-space by 		 * copying it into the clients csio. 		 */
name|memset
argument_list|(
operator|&
name|ccb
operator|->
name|csio
operator|.
name|sense_data
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ccb
operator|->
name|csio
operator|.
name|sense_data
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|ccb
operator|->
name|csio
operator|.
name|sense_data
argument_list|,
name|ahc_get_sense_buf
argument_list|(
name|ahc
argument_list|,
name|scb
argument_list|)
argument_list|,
operator|(
name|aic_le32toh
argument_list|(
name|scb
operator|->
name|sg_list
operator|->
name|len
argument_list|)
operator|&
name|AHC_SG_LEN_MASK
operator|)
operator|-
name|ccb
operator|->
name|csio
operator|.
name|sense_resid
argument_list|)
expr_stmt|;
name|scb
operator|->
name|io_ctx
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_AUTOSNS_VALID
expr_stmt|;
block|}
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&=
operator|~
name|CAM_SIM_QUEUED
expr_stmt|;
name|ahc_free_scb
argument_list|(
name|ahc
argument_list|,
name|scb
argument_list|)
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ahc_action
parameter_list|(
name|struct
name|cam_sim
modifier|*
name|sim
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
block|{
name|struct
name|ahc_softc
modifier|*
name|ahc
decl_stmt|;
name|struct
name|ahc_tmode_lstate
modifier|*
name|lstate
decl_stmt|;
name|u_int
name|target_id
decl_stmt|;
name|u_int
name|our_id
decl_stmt|;
name|long
name|s
decl_stmt|;
name|CAM_DEBUG
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
name|CAM_DEBUG_TRACE
argument_list|,
operator|(
literal|"ahc_action\n"
operator|)
argument_list|)
expr_stmt|;
name|ahc
operator|=
operator|(
expr|struct
name|ahc_softc
operator|*
operator|)
name|cam_sim_softc
argument_list|(
name|sim
argument_list|)
expr_stmt|;
name|target_id
operator|=
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
expr_stmt|;
name|our_id
operator|=
name|SIM_SCSI_ID
argument_list|(
name|ahc
argument_list|,
name|sim
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
condition|)
block|{
comment|/* Common cases first */
case|case
name|XPT_ACCEPT_TARGET_IO
case|:
comment|/* Accept Host Target Mode CDB */
case|case
name|XPT_CONT_TARGET_IO
case|:
comment|/* Continue Host Target I/O Connection*/
block|{
name|struct
name|ahc_tmode_tstate
modifier|*
name|tstate
decl_stmt|;
name|cam_status
name|status
decl_stmt|;
name|status
operator|=
name|ahc_find_tmode_devs
argument_list|(
name|ahc
argument_list|,
name|sim
argument_list|,
name|ccb
argument_list|,
operator|&
name|tstate
argument_list|,
operator|&
name|lstate
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
if|if
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|==
name|XPT_CONT_TARGET_IO
condition|)
block|{
comment|/* Response from the black hole device */
name|tstate
operator|=
name|NULL
expr_stmt|;
name|lstate
operator|=
name|ahc
operator|->
name|black_hole
expr_stmt|;
block|}
else|else
block|{
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|status
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|==
name|XPT_ACCEPT_TARGET_IO
condition|)
block|{
name|ahc_lock
argument_list|(
name|ahc
argument_list|,
operator|&
name|s
argument_list|)
expr_stmt|;
name|SLIST_INSERT_HEAD
argument_list|(
operator|&
name|lstate
operator|->
name|accept_tios
argument_list|,
operator|&
name|ccb
operator|->
name|ccb_h
argument_list|,
name|sim_links
operator|.
name|sle
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_INPROG
expr_stmt|;
if|if
condition|(
operator|(
name|ahc
operator|->
name|flags
operator|&
name|AHC_TQINFIFO_BLOCKED
operator|)
operator|!=
literal|0
condition|)
name|ahc_run_tqinfifo
argument_list|(
name|ahc
argument_list|,
comment|/*paused*/
name|FALSE
argument_list|)
expr_stmt|;
name|ahc_unlock
argument_list|(
name|ahc
argument_list|,
operator|&
name|s
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* 		 * The target_id represents the target we attempt to 		 * select.  In target mode, this is the initiator of 		 * the original command. 		 */
name|our_id
operator|=
name|target_id
expr_stmt|;
name|target_id
operator|=
name|ccb
operator|->
name|csio
operator|.
name|init_id
expr_stmt|;
comment|/* FALLTHROUGH */
block|}
case|case
name|XPT_SCSI_IO
case|:
comment|/* Execute the requested I/O operation */
case|case
name|XPT_RESET_DEV
case|:
comment|/* Bus Device Reset the specified SCSI device */
block|{
name|struct
name|scb
modifier|*
name|scb
decl_stmt|;
name|struct
name|hardware_scb
modifier|*
name|hscb
decl_stmt|;
if|if
condition|(
operator|(
name|ahc
operator|->
name|flags
operator|&
name|AHC_INITIATORROLE
operator|)
operator|==
literal|0
operator|&&
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|==
name|XPT_SCSI_IO
operator|||
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|==
name|XPT_RESET_DEV
operator|)
condition|)
block|{
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_PROVIDE_FAIL
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 		 * get an scb to use. 		 */
name|ahc_lock
argument_list|(
name|ahc
argument_list|,
operator|&
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|scb
operator|=
name|ahc_get_scb
argument_list|(
name|ahc
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|xpt_freeze_simq
argument_list|(
name|sim
argument_list|,
comment|/*count*/
literal|1
argument_list|)
expr_stmt|;
name|ahc
operator|->
name|flags
operator||=
name|AHC_RESOURCE_SHORTAGE
expr_stmt|;
name|ahc_unlock
argument_list|(
name|ahc
argument_list|,
operator|&
name|s
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQUEUE_REQ
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return;
block|}
name|ahc_unlock
argument_list|(
name|ahc
argument_list|,
operator|&
name|s
argument_list|)
expr_stmt|;
name|hscb
operator|=
name|scb
operator|->
name|hscb
expr_stmt|;
name|CAM_DEBUG
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
name|CAM_DEBUG_SUBTRACE
argument_list|,
operator|(
literal|"start scb(%p)\n"
operator|,
name|scb
operator|)
argument_list|)
expr_stmt|;
name|scb
operator|->
name|io_ctx
operator|=
name|ccb
expr_stmt|;
comment|/* 		 * So we can find the SCB when an abort is requested 		 */
name|ccb
operator|->
name|ccb_h
operator|.
name|ccb_scb_ptr
operator|=
name|scb
expr_stmt|;
comment|/* 		 * Put all the arguments for the xfer in the scb 		 */
name|hscb
operator|->
name|control
operator|=
literal|0
expr_stmt|;
name|hscb
operator|->
name|scsiid
operator|=
name|BUILD_SCSIID
argument_list|(
name|ahc
argument_list|,
name|sim
argument_list|,
name|target_id
argument_list|,
name|our_id
argument_list|)
expr_stmt|;
name|hscb
operator|->
name|lun
operator|=
name|ccb
operator|->
name|ccb_h
operator|.
name|target_lun
expr_stmt|;
if|if
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|==
name|XPT_RESET_DEV
condition|)
block|{
name|hscb
operator|->
name|cdb_len
operator|=
literal|0
expr_stmt|;
name|scb
operator|->
name|flags
operator||=
name|SCB_DEVICE_RESET
expr_stmt|;
name|hscb
operator|->
name|control
operator||=
name|MK_MESSAGE
expr_stmt|;
name|ahc_execute_scb
argument_list|(
name|scb
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|==
name|XPT_CONT_TARGET_IO
condition|)
block|{
name|struct
name|target_data
modifier|*
name|tdata
decl_stmt|;
name|tdata
operator|=
operator|&
name|hscb
operator|->
name|shared_data
operator|.
name|tdata
expr_stmt|;
if|if
condition|(
name|ahc
operator|->
name|pending_device
operator|==
name|lstate
condition|)
name|scb
operator|->
name|flags
operator||=
name|SCB_TARGET_IMMEDIATE
expr_stmt|;
name|hscb
operator|->
name|control
operator||=
name|TARGET_SCB
expr_stmt|;
name|scb
operator|->
name|flags
operator||=
name|SCB_TARGET_SCB
expr_stmt|;
name|tdata
operator|->
name|target_phases
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_SEND_STATUS
operator|)
operator|!=
literal|0
condition|)
block|{
name|tdata
operator|->
name|target_phases
operator||=
name|SPHASE_PENDING
expr_stmt|;
name|tdata
operator|->
name|scsi_status
operator|=
name|ccb
operator|->
name|csio
operator|.
name|scsi_status
expr_stmt|;
block|}
if|if
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DIS_DISCONNECT
condition|)
name|tdata
operator|->
name|target_phases
operator||=
name|NO_DISCONNECT
expr_stmt|;
name|tdata
operator|->
name|initiator_tag
operator|=
name|ccb
operator|->
name|csio
operator|.
name|tag_id
expr_stmt|;
block|}
if|if
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_TAG_ACTION_VALID
condition|)
name|hscb
operator|->
name|control
operator||=
name|ccb
operator|->
name|csio
operator|.
name|tag_action
expr_stmt|;
name|ahc_setup_data
argument_list|(
name|ahc
argument_list|,
name|sim
argument_list|,
operator|&
name|ccb
operator|->
name|csio
argument_list|,
name|scb
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|XPT_NOTIFY_ACK
case|:
case|case
name|XPT_IMMED_NOTIFY
case|:
block|{
name|struct
name|ahc_tmode_tstate
modifier|*
name|tstate
decl_stmt|;
name|struct
name|ahc_tmode_lstate
modifier|*
name|lstate
decl_stmt|;
name|cam_status
name|status
decl_stmt|;
name|status
operator|=
name|ahc_find_tmode_devs
argument_list|(
name|ahc
argument_list|,
name|sim
argument_list|,
name|ccb
argument_list|,
operator|&
name|tstate
argument_list|,
operator|&
name|lstate
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|status
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
block|}
name|SLIST_INSERT_HEAD
argument_list|(
operator|&
name|lstate
operator|->
name|immed_notifies
argument_list|,
operator|&
name|ccb
operator|->
name|ccb_h
argument_list|,
name|sim_links
operator|.
name|sle
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_INPROG
expr_stmt|;
name|ahc_send_lstate_events
argument_list|(
name|ahc
argument_list|,
name|lstate
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|XPT_EN_LUN
case|:
comment|/* Enable LUN as a target */
name|ahc_handle_en_lun
argument_list|(
name|ahc
argument_list|,
name|sim
argument_list|,
name|ccb
argument_list|)
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
case|case
name|XPT_ABORT
case|:
comment|/* Abort the specified CCB */
block|{
name|ahc_abort_ccb
argument_list|(
name|ahc
argument_list|,
name|sim
argument_list|,
name|ccb
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|XPT_SET_TRAN_SETTINGS
case|:
block|{
name|struct
name|ahc_devinfo
name|devinfo
decl_stmt|;
name|struct
name|ccb_trans_settings
modifier|*
name|cts
decl_stmt|;
name|struct
name|ccb_trans_settings_scsi
modifier|*
name|scsi
decl_stmt|;
name|struct
name|ccb_trans_settings_spi
modifier|*
name|spi
decl_stmt|;
name|struct
name|ahc_initiator_tinfo
modifier|*
name|tinfo
decl_stmt|;
name|struct
name|ahc_tmode_tstate
modifier|*
name|tstate
decl_stmt|;
name|uint16_t
modifier|*
name|discenable
decl_stmt|;
name|uint16_t
modifier|*
name|tagenable
decl_stmt|;
name|u_int
name|update_type
decl_stmt|;
name|cts
operator|=
operator|&
name|ccb
operator|->
name|cts
expr_stmt|;
name|scsi
operator|=
operator|&
name|cts
operator|->
name|proto_specific
operator|.
name|scsi
expr_stmt|;
name|spi
operator|=
operator|&
name|cts
operator|->
name|xport_specific
operator|.
name|spi
expr_stmt|;
name|ahc_compile_devinfo
argument_list|(
operator|&
name|devinfo
argument_list|,
name|SIM_SCSI_ID
argument_list|(
name|ahc
argument_list|,
name|sim
argument_list|)
argument_list|,
name|cts
operator|->
name|ccb_h
operator|.
name|target_id
argument_list|,
name|cts
operator|->
name|ccb_h
operator|.
name|target_lun
argument_list|,
name|SIM_CHANNEL
argument_list|(
name|ahc
argument_list|,
name|sim
argument_list|)
argument_list|,
name|ROLE_UNKNOWN
argument_list|)
expr_stmt|;
name|tinfo
operator|=
name|ahc_fetch_transinfo
argument_list|(
name|ahc
argument_list|,
name|devinfo
operator|.
name|channel
argument_list|,
name|devinfo
operator|.
name|our_scsiid
argument_list|,
name|devinfo
operator|.
name|target
argument_list|,
operator|&
name|tstate
argument_list|)
expr_stmt|;
name|update_type
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|cts
operator|->
name|type
operator|==
name|CTS_TYPE_CURRENT_SETTINGS
condition|)
block|{
name|update_type
operator||=
name|AHC_TRANS_GOAL
expr_stmt|;
name|discenable
operator|=
operator|&
name|tstate
operator|->
name|discenable
expr_stmt|;
name|tagenable
operator|=
operator|&
name|tstate
operator|->
name|tagenable
expr_stmt|;
name|tinfo
operator|->
name|curr
operator|.
name|protocol_version
operator|=
name|cts
operator|->
name|protocol_version
expr_stmt|;
name|tinfo
operator|->
name|curr
operator|.
name|transport_version
operator|=
name|cts
operator|->
name|transport_version
expr_stmt|;
name|tinfo
operator|->
name|goal
operator|.
name|protocol_version
operator|=
name|cts
operator|->
name|protocol_version
expr_stmt|;
name|tinfo
operator|->
name|goal
operator|.
name|transport_version
operator|=
name|cts
operator|->
name|transport_version
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cts
operator|->
name|type
operator|==
name|CTS_TYPE_USER_SETTINGS
condition|)
block|{
name|update_type
operator||=
name|AHC_TRANS_USER
expr_stmt|;
name|discenable
operator|=
operator|&
name|ahc
operator|->
name|user_discenable
expr_stmt|;
name|tagenable
operator|=
operator|&
name|ahc
operator|->
name|user_tagenable
expr_stmt|;
name|tinfo
operator|->
name|user
operator|.
name|protocol_version
operator|=
name|cts
operator|->
name|protocol_version
expr_stmt|;
name|tinfo
operator|->
name|user
operator|.
name|transport_version
operator|=
name|cts
operator|->
name|transport_version
expr_stmt|;
block|}
else|else
block|{
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_INVALID
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
block|}
name|ahc_lock
argument_list|(
name|ahc
argument_list|,
operator|&
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|spi
operator|->
name|valid
operator|&
name|CTS_SPI_VALID_DISC
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|spi
operator|->
name|flags
operator|&
name|CTS_SPI_FLAGS_DISC_ENB
operator|)
operator|!=
literal|0
condition|)
operator|*
name|discenable
operator||=
name|devinfo
operator|.
name|target_mask
expr_stmt|;
else|else
operator|*
name|discenable
operator|&=
operator|~
name|devinfo
operator|.
name|target_mask
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|scsi
operator|->
name|valid
operator|&
name|CTS_SCSI_VALID_TQ
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|scsi
operator|->
name|flags
operator|&
name|CTS_SCSI_FLAGS_TAG_ENB
operator|)
operator|!=
literal|0
condition|)
operator|*
name|tagenable
operator||=
name|devinfo
operator|.
name|target_mask
expr_stmt|;
else|else
operator|*
name|tagenable
operator|&=
operator|~
name|devinfo
operator|.
name|target_mask
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|spi
operator|->
name|valid
operator|&
name|CTS_SPI_VALID_BUS_WIDTH
operator|)
operator|!=
literal|0
condition|)
block|{
name|ahc_validate_width
argument_list|(
name|ahc
argument_list|,
comment|/*tinfo limit*/
name|NULL
argument_list|,
operator|&
name|spi
operator|->
name|bus_width
argument_list|,
name|ROLE_UNKNOWN
argument_list|)
expr_stmt|;
name|ahc_set_width
argument_list|(
name|ahc
argument_list|,
operator|&
name|devinfo
argument_list|,
name|spi
operator|->
name|bus_width
argument_list|,
name|update_type
argument_list|,
comment|/*paused*/
name|FALSE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|spi
operator|->
name|valid
operator|&
name|CTS_SPI_VALID_PPR_OPTIONS
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|update_type
operator|==
name|AHC_TRANS_USER
condition|)
name|spi
operator|->
name|ppr_options
operator|=
name|tinfo
operator|->
name|user
operator|.
name|ppr_options
expr_stmt|;
else|else
name|spi
operator|->
name|ppr_options
operator|=
name|tinfo
operator|->
name|goal
operator|.
name|ppr_options
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|spi
operator|->
name|valid
operator|&
name|CTS_SPI_VALID_SYNC_OFFSET
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|update_type
operator|==
name|AHC_TRANS_USER
condition|)
name|spi
operator|->
name|sync_offset
operator|=
name|tinfo
operator|->
name|user
operator|.
name|offset
expr_stmt|;
else|else
name|spi
operator|->
name|sync_offset
operator|=
name|tinfo
operator|->
name|goal
operator|.
name|offset
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|spi
operator|->
name|valid
operator|&
name|CTS_SPI_VALID_SYNC_RATE
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|update_type
operator|==
name|AHC_TRANS_USER
condition|)
name|spi
operator|->
name|sync_period
operator|=
name|tinfo
operator|->
name|user
operator|.
name|period
expr_stmt|;
else|else
name|spi
operator|->
name|sync_period
operator|=
name|tinfo
operator|->
name|goal
operator|.
name|period
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|(
name|spi
operator|->
name|valid
operator|&
name|CTS_SPI_VALID_SYNC_RATE
operator|)
operator|!=
literal|0
operator|)
operator|||
operator|(
operator|(
name|spi
operator|->
name|valid
operator|&
name|CTS_SPI_VALID_SYNC_OFFSET
operator|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|struct
name|ahc_syncrate
modifier|*
name|syncrate
decl_stmt|;
name|u_int
name|maxsync
decl_stmt|;
if|if
condition|(
operator|(
name|ahc
operator|->
name|features
operator|&
name|AHC_ULTRA2
operator|)
operator|!=
literal|0
condition|)
name|maxsync
operator|=
name|AHC_SYNCRATE_DT
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|ahc
operator|->
name|features
operator|&
name|AHC_ULTRA
operator|)
operator|!=
literal|0
condition|)
name|maxsync
operator|=
name|AHC_SYNCRATE_ULTRA
expr_stmt|;
else|else
name|maxsync
operator|=
name|AHC_SYNCRATE_FAST
expr_stmt|;
if|if
condition|(
name|spi
operator|->
name|bus_width
operator|!=
name|MSG_EXT_WDTR_BUS_16_BIT
condition|)
name|spi
operator|->
name|ppr_options
operator|&=
operator|~
name|MSG_EXT_PPR_DT_REQ
expr_stmt|;
name|syncrate
operator|=
name|ahc_find_syncrate
argument_list|(
name|ahc
argument_list|,
operator|&
name|spi
operator|->
name|sync_period
argument_list|,
operator|&
name|spi
operator|->
name|ppr_options
argument_list|,
name|maxsync
argument_list|)
expr_stmt|;
name|ahc_validate_offset
argument_list|(
name|ahc
argument_list|,
comment|/*tinfo limit*/
name|NULL
argument_list|,
name|syncrate
argument_list|,
operator|&
name|spi
operator|->
name|sync_offset
argument_list|,
name|spi
operator|->
name|bus_width
argument_list|,
name|ROLE_UNKNOWN
argument_list|)
expr_stmt|;
comment|/* We use a period of 0 to represent async */
if|if
condition|(
name|spi
operator|->
name|sync_offset
operator|==
literal|0
condition|)
block|{
name|spi
operator|->
name|sync_period
operator|=
literal|0
expr_stmt|;
name|spi
operator|->
name|ppr_options
operator|=
literal|0
expr_stmt|;
block|}
name|ahc_set_syncrate
argument_list|(
name|ahc
argument_list|,
operator|&
name|devinfo
argument_list|,
name|syncrate
argument_list|,
name|spi
operator|->
name|sync_period
argument_list|,
name|spi
operator|->
name|sync_offset
argument_list|,
name|spi
operator|->
name|ppr_options
argument_list|,
name|update_type
argument_list|,
comment|/*paused*/
name|FALSE
argument_list|)
expr_stmt|;
block|}
name|ahc_unlock
argument_list|(
name|ahc
argument_list|,
operator|&
name|s
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|XPT_GET_TRAN_SETTINGS
case|:
comment|/* Get default/user set transfer settings for the target */
block|{
name|ahc_lock
argument_list|(
name|ahc
argument_list|,
operator|&
name|s
argument_list|)
expr_stmt|;
name|ahc_get_tran_settings
argument_list|(
name|ahc
argument_list|,
name|SIM_SCSI_ID
argument_list|(
name|ahc
argument_list|,
name|sim
argument_list|)
argument_list|,
name|SIM_CHANNEL
argument_list|(
name|ahc
argument_list|,
name|sim
argument_list|)
argument_list|,
operator|&
name|ccb
operator|->
name|cts
argument_list|)
expr_stmt|;
name|ahc_unlock
argument_list|(
name|ahc
argument_list|,
operator|&
name|s
argument_list|)
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|XPT_CALC_GEOMETRY
case|:
block|{
name|int
name|extended
decl_stmt|;
name|extended
operator|=
name|SIM_IS_SCSIBUS_B
argument_list|(
name|ahc
argument_list|,
name|sim
argument_list|)
condition|?
name|ahc
operator|->
name|flags
operator|&
name|AHC_EXTENDED_TRANS_B
else|:
name|ahc
operator|->
name|flags
operator|&
name|AHC_EXTENDED_TRANS_A
expr_stmt|;
name|aic_calc_geometry
argument_list|(
operator|&
name|ccb
operator|->
name|ccg
argument_list|,
name|extended
argument_list|)
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|XPT_RESET_BUS
case|:
comment|/* Reset the specified SCSI bus */
block|{
name|int
name|found
decl_stmt|;
name|ahc_lock
argument_list|(
name|ahc
argument_list|,
operator|&
name|s
argument_list|)
expr_stmt|;
name|found
operator|=
name|ahc_reset_channel
argument_list|(
name|ahc
argument_list|,
name|SIM_CHANNEL
argument_list|(
name|ahc
argument_list|,
name|sim
argument_list|)
argument_list|,
comment|/*initiate reset*/
name|TRUE
argument_list|)
expr_stmt|;
name|ahc_unlock
argument_list|(
name|ahc
argument_list|,
operator|&
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
block|{
name|xpt_print_path
argument_list|(
name|SIM_PATH
argument_list|(
name|ahc
argument_list|,
name|sim
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"SCSI bus reset delivered. "
literal|"%d SCBs aborted.\n"
argument_list|,
name|found
argument_list|)
expr_stmt|;
block|}
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|XPT_TERM_IO
case|:
comment|/* Terminate the I/O process */
comment|/* XXX Implement */
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_INVALID
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
case|case
name|XPT_PATH_INQ
case|:
comment|/* Path routing inquiry */
block|{
name|struct
name|ccb_pathinq
modifier|*
name|cpi
init|=
operator|&
name|ccb
operator|->
name|cpi
decl_stmt|;
name|cpi
operator|->
name|version_num
operator|=
literal|1
expr_stmt|;
comment|/* XXX??? */
name|cpi
operator|->
name|hba_inquiry
operator|=
name|PI_SDTR_ABLE
operator||
name|PI_TAG_ABLE
expr_stmt|;
if|if
condition|(
operator|(
name|ahc
operator|->
name|features
operator|&
name|AHC_WIDE
operator|)
operator|!=
literal|0
condition|)
name|cpi
operator|->
name|hba_inquiry
operator||=
name|PI_WIDE_16
expr_stmt|;
if|if
condition|(
operator|(
name|ahc
operator|->
name|features
operator|&
name|AHC_TARGETMODE
operator|)
operator|!=
literal|0
condition|)
block|{
name|cpi
operator|->
name|target_sprt
operator|=
name|PIT_PROCESSOR
operator||
name|PIT_DISCONNECT
operator||
name|PIT_TERM_IO
expr_stmt|;
block|}
else|else
block|{
name|cpi
operator|->
name|target_sprt
operator|=
literal|0
expr_stmt|;
block|}
name|cpi
operator|->
name|hba_misc
operator|=
literal|0
expr_stmt|;
name|cpi
operator|->
name|hba_eng_cnt
operator|=
literal|0
expr_stmt|;
name|cpi
operator|->
name|max_target
operator|=
operator|(
name|ahc
operator|->
name|features
operator|&
name|AHC_WIDE
operator|)
condition|?
literal|15
else|:
literal|7
expr_stmt|;
name|cpi
operator|->
name|max_lun
operator|=
name|AHC_NUM_LUNS
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|SIM_IS_SCSIBUS_B
argument_list|(
name|ahc
argument_list|,
name|sim
argument_list|)
condition|)
block|{
name|cpi
operator|->
name|initiator_id
operator|=
name|ahc
operator|->
name|our_id_b
expr_stmt|;
if|if
condition|(
operator|(
name|ahc
operator|->
name|flags
operator|&
name|AHC_RESET_BUS_B
operator|)
operator|==
literal|0
condition|)
name|cpi
operator|->
name|hba_misc
operator||=
name|PIM_NOBUSRESET
expr_stmt|;
block|}
else|else
block|{
name|cpi
operator|->
name|initiator_id
operator|=
name|ahc
operator|->
name|our_id
expr_stmt|;
if|if
condition|(
operator|(
name|ahc
operator|->
name|flags
operator|&
name|AHC_RESET_BUS_A
operator|)
operator|==
literal|0
condition|)
name|cpi
operator|->
name|hba_misc
operator||=
name|PIM_NOBUSRESET
expr_stmt|;
block|}
name|cpi
operator|->
name|bus_id
operator|=
name|cam_sim_bus
argument_list|(
name|sim
argument_list|)
expr_stmt|;
name|cpi
operator|->
name|base_transfer_speed
operator|=
literal|3300
expr_stmt|;
name|strncpy
argument_list|(
name|cpi
operator|->
name|sim_vid
argument_list|,
literal|"FreeBSD"
argument_list|,
name|SIM_IDLEN
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|cpi
operator|->
name|hba_vid
argument_list|,
literal|"Adaptec"
argument_list|,
name|HBA_IDLEN
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|cpi
operator|->
name|dev_name
argument_list|,
name|cam_sim_name
argument_list|(
name|sim
argument_list|)
argument_list|,
name|DEV_IDLEN
argument_list|)
expr_stmt|;
name|cpi
operator|->
name|unit_number
operator|=
name|cam_sim_unit
argument_list|(
name|sim
argument_list|)
expr_stmt|;
name|cpi
operator|->
name|protocol
operator|=
name|PROTO_SCSI
expr_stmt|;
name|cpi
operator|->
name|protocol_version
operator|=
name|SCSI_REV_2
expr_stmt|;
name|cpi
operator|->
name|transport
operator|=
name|XPORT_SPI
expr_stmt|;
name|cpi
operator|->
name|transport_version
operator|=
literal|2
expr_stmt|;
name|cpi
operator|->
name|xport_specific
operator|.
name|spi
operator|.
name|ppr_options
operator|=
name|SID_SPI_CLOCK_ST
expr_stmt|;
if|if
condition|(
operator|(
name|ahc
operator|->
name|features
operator|&
name|AHC_DT
operator|)
operator|!=
literal|0
condition|)
block|{
name|cpi
operator|->
name|transport_version
operator|=
literal|3
expr_stmt|;
name|cpi
operator|->
name|xport_specific
operator|.
name|spi
operator|.
name|ppr_options
operator|=
name|SID_SPI_CLOCK_DT_ST
expr_stmt|;
block|}
name|cpi
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_PROVIDE_FAIL
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ahc_get_tran_settings
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|int
name|our_id
parameter_list|,
name|char
name|channel
parameter_list|,
name|struct
name|ccb_trans_settings
modifier|*
name|cts
parameter_list|)
block|{
name|struct
name|ahc_devinfo
name|devinfo
decl_stmt|;
name|struct
name|ccb_trans_settings_scsi
modifier|*
name|scsi
decl_stmt|;
name|struct
name|ccb_trans_settings_spi
modifier|*
name|spi
decl_stmt|;
name|struct
name|ahc_initiator_tinfo
modifier|*
name|targ_info
decl_stmt|;
name|struct
name|ahc_tmode_tstate
modifier|*
name|tstate
decl_stmt|;
name|struct
name|ahc_transinfo
modifier|*
name|tinfo
decl_stmt|;
name|scsi
operator|=
operator|&
name|cts
operator|->
name|proto_specific
operator|.
name|scsi
expr_stmt|;
name|spi
operator|=
operator|&
name|cts
operator|->
name|xport_specific
operator|.
name|spi
expr_stmt|;
name|ahc_compile_devinfo
argument_list|(
operator|&
name|devinfo
argument_list|,
name|our_id
argument_list|,
name|cts
operator|->
name|ccb_h
operator|.
name|target_id
argument_list|,
name|cts
operator|->
name|ccb_h
operator|.
name|target_lun
argument_list|,
name|channel
argument_list|,
name|ROLE_UNKNOWN
argument_list|)
expr_stmt|;
name|targ_info
operator|=
name|ahc_fetch_transinfo
argument_list|(
name|ahc
argument_list|,
name|devinfo
operator|.
name|channel
argument_list|,
name|devinfo
operator|.
name|our_scsiid
argument_list|,
name|devinfo
operator|.
name|target
argument_list|,
operator|&
name|tstate
argument_list|)
expr_stmt|;
if|if
condition|(
name|cts
operator|->
name|type
operator|==
name|CTS_TYPE_CURRENT_SETTINGS
condition|)
name|tinfo
operator|=
operator|&
name|targ_info
operator|->
name|curr
expr_stmt|;
else|else
name|tinfo
operator|=
operator|&
name|targ_info
operator|->
name|user
expr_stmt|;
name|scsi
operator|->
name|flags
operator|&=
operator|~
name|CTS_SCSI_FLAGS_TAG_ENB
expr_stmt|;
name|spi
operator|->
name|flags
operator|&=
operator|~
name|CTS_SPI_FLAGS_DISC_ENB
expr_stmt|;
if|if
condition|(
name|cts
operator|->
name|type
operator|==
name|CTS_TYPE_USER_SETTINGS
condition|)
block|{
if|if
condition|(
operator|(
name|ahc
operator|->
name|user_discenable
operator|&
name|devinfo
operator|.
name|target_mask
operator|)
operator|!=
literal|0
condition|)
name|spi
operator|->
name|flags
operator||=
name|CTS_SPI_FLAGS_DISC_ENB
expr_stmt|;
if|if
condition|(
operator|(
name|ahc
operator|->
name|user_tagenable
operator|&
name|devinfo
operator|.
name|target_mask
operator|)
operator|!=
literal|0
condition|)
name|scsi
operator|->
name|flags
operator||=
name|CTS_SCSI_FLAGS_TAG_ENB
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|tstate
operator|->
name|discenable
operator|&
name|devinfo
operator|.
name|target_mask
operator|)
operator|!=
literal|0
condition|)
name|spi
operator|->
name|flags
operator||=
name|CTS_SPI_FLAGS_DISC_ENB
expr_stmt|;
if|if
condition|(
operator|(
name|tstate
operator|->
name|tagenable
operator|&
name|devinfo
operator|.
name|target_mask
operator|)
operator|!=
literal|0
condition|)
name|scsi
operator|->
name|flags
operator||=
name|CTS_SCSI_FLAGS_TAG_ENB
expr_stmt|;
block|}
name|cts
operator|->
name|protocol_version
operator|=
name|tinfo
operator|->
name|protocol_version
expr_stmt|;
name|cts
operator|->
name|transport_version
operator|=
name|tinfo
operator|->
name|transport_version
expr_stmt|;
name|spi
operator|->
name|sync_period
operator|=
name|tinfo
operator|->
name|period
expr_stmt|;
name|spi
operator|->
name|sync_offset
operator|=
name|tinfo
operator|->
name|offset
expr_stmt|;
name|spi
operator|->
name|bus_width
operator|=
name|tinfo
operator|->
name|width
expr_stmt|;
name|spi
operator|->
name|ppr_options
operator|=
name|tinfo
operator|->
name|ppr_options
expr_stmt|;
name|cts
operator|->
name|protocol
operator|=
name|PROTO_SCSI
expr_stmt|;
name|cts
operator|->
name|transport
operator|=
name|XPORT_SPI
expr_stmt|;
name|spi
operator|->
name|valid
operator|=
name|CTS_SPI_VALID_SYNC_RATE
operator||
name|CTS_SPI_VALID_SYNC_OFFSET
operator||
name|CTS_SPI_VALID_BUS_WIDTH
operator||
name|CTS_SPI_VALID_PPR_OPTIONS
expr_stmt|;
if|if
condition|(
name|cts
operator|->
name|ccb_h
operator|.
name|target_lun
operator|!=
name|CAM_LUN_WILDCARD
condition|)
block|{
name|scsi
operator|->
name|valid
operator|=
name|CTS_SCSI_VALID_TQ
expr_stmt|;
name|spi
operator|->
name|valid
operator||=
name|CTS_SPI_VALID_DISC
expr_stmt|;
block|}
else|else
block|{
name|scsi
operator|->
name|valid
operator|=
literal|0
expr_stmt|;
block|}
name|cts
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ahc_async
parameter_list|(
name|void
modifier|*
name|callback_arg
parameter_list|,
name|uint32_t
name|code
parameter_list|,
name|struct
name|cam_path
modifier|*
name|path
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ahc_softc
modifier|*
name|ahc
decl_stmt|;
name|struct
name|cam_sim
modifier|*
name|sim
decl_stmt|;
name|sim
operator|=
operator|(
expr|struct
name|cam_sim
operator|*
operator|)
name|callback_arg
expr_stmt|;
name|ahc
operator|=
operator|(
expr|struct
name|ahc_softc
operator|*
operator|)
name|cam_sim_softc
argument_list|(
name|sim
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|AC_LOST_DEVICE
case|:
block|{
name|struct
name|ahc_devinfo
name|devinfo
decl_stmt|;
name|long
name|s
decl_stmt|;
name|ahc_compile_devinfo
argument_list|(
operator|&
name|devinfo
argument_list|,
name|SIM_SCSI_ID
argument_list|(
name|ahc
argument_list|,
name|sim
argument_list|)
argument_list|,
name|xpt_path_target_id
argument_list|(
name|path
argument_list|)
argument_list|,
name|xpt_path_lun_id
argument_list|(
name|path
argument_list|)
argument_list|,
name|SIM_CHANNEL
argument_list|(
name|ahc
argument_list|,
name|sim
argument_list|)
argument_list|,
name|ROLE_UNKNOWN
argument_list|)
expr_stmt|;
comment|/* 		 * Revert to async/narrow transfers 		 * for the next device. 		 */
name|ahc_lock
argument_list|(
name|ahc
argument_list|,
operator|&
name|s
argument_list|)
expr_stmt|;
name|ahc_set_width
argument_list|(
name|ahc
argument_list|,
operator|&
name|devinfo
argument_list|,
name|MSG_EXT_WDTR_BUS_8_BIT
argument_list|,
name|AHC_TRANS_GOAL
operator||
name|AHC_TRANS_CUR
argument_list|,
comment|/*paused*/
name|FALSE
argument_list|)
expr_stmt|;
name|ahc_set_syncrate
argument_list|(
name|ahc
argument_list|,
operator|&
name|devinfo
argument_list|,
comment|/*syncrate*/
name|NULL
argument_list|,
comment|/*period*/
literal|0
argument_list|,
comment|/*offset*/
literal|0
argument_list|,
comment|/*ppr_options*/
literal|0
argument_list|,
name|AHC_TRANS_GOAL
operator||
name|AHC_TRANS_CUR
argument_list|,
comment|/*paused*/
name|FALSE
argument_list|)
expr_stmt|;
name|ahc_unlock
argument_list|(
name|ahc
argument_list|,
operator|&
name|s
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ahc_execute_scb
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|dm_segs
parameter_list|,
name|int
name|nsegments
parameter_list|,
name|int
name|error
parameter_list|)
block|{
name|struct
name|scb
modifier|*
name|scb
decl_stmt|;
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|struct
name|ahc_softc
modifier|*
name|ahc
decl_stmt|;
name|struct
name|ahc_initiator_tinfo
modifier|*
name|tinfo
decl_stmt|;
name|struct
name|ahc_tmode_tstate
modifier|*
name|tstate
decl_stmt|;
name|u_int
name|mask
decl_stmt|;
name|long
name|s
decl_stmt|;
name|scb
operator|=
operator|(
expr|struct
name|scb
operator|*
operator|)
name|arg
expr_stmt|;
name|ccb
operator|=
name|scb
operator|->
name|io_ctx
expr_stmt|;
name|ahc
operator|=
name|scb
operator|->
name|ahc_softc
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|error
operator|==
name|EFBIG
condition|)
name|aic_set_transaction_status
argument_list|(
name|scb
argument_list|,
name|CAM_REQ_TOO_BIG
argument_list|)
expr_stmt|;
else|else
name|aic_set_transaction_status
argument_list|(
name|scb
argument_list|,
name|CAM_REQ_CMP_ERR
argument_list|)
expr_stmt|;
if|if
condition|(
name|nsegments
operator|!=
literal|0
condition|)
name|bus_dmamap_unload
argument_list|(
name|ahc
operator|->
name|buffer_dmat
argument_list|,
name|scb
operator|->
name|dmamap
argument_list|)
expr_stmt|;
name|ahc_lock
argument_list|(
name|ahc
argument_list|,
operator|&
name|s
argument_list|)
expr_stmt|;
name|ahc_free_scb
argument_list|(
name|ahc
argument_list|,
name|scb
argument_list|)
expr_stmt|;
name|ahc_unlock
argument_list|(
name|ahc
argument_list|,
operator|&
name|s
argument_list|)
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|nsegments
operator|!=
literal|0
condition|)
block|{
name|struct
name|ahc_dma_seg
modifier|*
name|sg
decl_stmt|;
name|bus_dma_segment_t
modifier|*
name|end_seg
decl_stmt|;
name|bus_dmasync_op_t
name|op
decl_stmt|;
name|end_seg
operator|=
name|dm_segs
operator|+
name|nsegments
expr_stmt|;
comment|/* Copy the segments into our SG list */
name|sg
operator|=
name|scb
operator|->
name|sg_list
expr_stmt|;
while|while
condition|(
name|dm_segs
operator|<
name|end_seg
condition|)
block|{
name|uint32_t
name|len
decl_stmt|;
name|sg
operator|->
name|addr
operator|=
name|aic_htole32
argument_list|(
name|dm_segs
operator|->
name|ds_addr
argument_list|)
expr_stmt|;
name|len
operator|=
name|dm_segs
operator|->
name|ds_len
operator||
operator|(
operator|(
name|dm_segs
operator|->
name|ds_addr
operator|>>
literal|8
operator|)
operator|&
literal|0x7F000000
operator|)
expr_stmt|;
name|sg
operator|->
name|len
operator|=
name|aic_htole32
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|sg
operator|++
expr_stmt|;
name|dm_segs
operator|++
expr_stmt|;
block|}
comment|/* 		 * Note where to find the SG entries in bus space. 		 * We also set the full residual flag which the  		 * sequencer will clear as soon as a data transfer 		 * occurs. 		 */
name|scb
operator|->
name|hscb
operator|->
name|sgptr
operator|=
name|aic_htole32
argument_list|(
name|scb
operator|->
name|sg_list_phys
operator||
name|SG_FULL_RESID
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DIR_MASK
operator|)
operator|==
name|CAM_DIR_IN
condition|)
name|op
operator|=
name|BUS_DMASYNC_PREREAD
expr_stmt|;
else|else
name|op
operator|=
name|BUS_DMASYNC_PREWRITE
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|ahc
operator|->
name|buffer_dmat
argument_list|,
name|scb
operator|->
name|dmamap
argument_list|,
name|op
argument_list|)
expr_stmt|;
if|if
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|==
name|XPT_CONT_TARGET_IO
condition|)
block|{
name|struct
name|target_data
modifier|*
name|tdata
decl_stmt|;
name|tdata
operator|=
operator|&
name|scb
operator|->
name|hscb
operator|->
name|shared_data
operator|.
name|tdata
expr_stmt|;
name|tdata
operator|->
name|target_phases
operator||=
name|DPHASE_PENDING
expr_stmt|;
comment|/* 			 * CAM data direction is relative to the initiator. 			 */
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DIR_MASK
operator|)
operator|==
name|CAM_DIR_OUT
condition|)
name|tdata
operator|->
name|data_phase
operator|=
name|P_DATAOUT
expr_stmt|;
else|else
name|tdata
operator|->
name|data_phase
operator|=
name|P_DATAIN
expr_stmt|;
comment|/* 			 * If the transfer is of an odd length and in the 			 * "in" direction (scsi->HostBus), then it may 			 * trigger a bug in the 'WideODD' feature of 			 * non-Ultra2 chips.  Force the total data-length 			 * to be even by adding an extra, 1 byte, SG, 			 * element.  We do this even if we are not currently 			 * negotiated wide as negotiation could occur before 			 * this command is executed. 			 */
if|if
condition|(
operator|(
name|ahc
operator|->
name|bugs
operator|&
name|AHC_TMODE_WIDEODD_BUG
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|ccb
operator|->
name|csio
operator|.
name|dxfer_len
operator|&
literal|0x1
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DIR_MASK
operator|)
operator|==
name|CAM_DIR_OUT
condition|)
block|{
name|nsegments
operator|++
expr_stmt|;
if|if
condition|(
name|nsegments
operator|>
name|AHC_NSEG
condition|)
block|{
name|aic_set_transaction_status
argument_list|(
name|scb
argument_list|,
name|CAM_REQ_TOO_BIG
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|ahc
operator|->
name|buffer_dmat
argument_list|,
name|scb
operator|->
name|dmamap
argument_list|)
expr_stmt|;
name|ahc_lock
argument_list|(
name|ahc
argument_list|,
operator|&
name|s
argument_list|)
expr_stmt|;
name|ahc_free_scb
argument_list|(
name|ahc
argument_list|,
name|scb
argument_list|)
expr_stmt|;
name|ahc_unlock
argument_list|(
name|ahc
argument_list|,
operator|&
name|s
argument_list|)
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return;
block|}
name|sg
operator|->
name|addr
operator|=
name|aic_htole32
argument_list|(
name|ahc
operator|->
name|dma_bug_buf
argument_list|)
expr_stmt|;
name|sg
operator|->
name|len
operator|=
name|aic_htole32
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|sg
operator|++
expr_stmt|;
block|}
block|}
name|sg
operator|--
expr_stmt|;
name|sg
operator|->
name|len
operator||=
name|aic_htole32
argument_list|(
name|AHC_DMA_LAST_SEG
argument_list|)
expr_stmt|;
comment|/* Copy the first SG into the "current" data pointer area */
name|scb
operator|->
name|hscb
operator|->
name|dataptr
operator|=
name|scb
operator|->
name|sg_list
operator|->
name|addr
expr_stmt|;
name|scb
operator|->
name|hscb
operator|->
name|datacnt
operator|=
name|scb
operator|->
name|sg_list
operator|->
name|len
expr_stmt|;
block|}
else|else
block|{
name|scb
operator|->
name|hscb
operator|->
name|sgptr
operator|=
name|aic_htole32
argument_list|(
name|SG_LIST_NULL
argument_list|)
expr_stmt|;
name|scb
operator|->
name|hscb
operator|->
name|dataptr
operator|=
literal|0
expr_stmt|;
name|scb
operator|->
name|hscb
operator|->
name|datacnt
operator|=
literal|0
expr_stmt|;
block|}
name|scb
operator|->
name|sg_count
operator|=
name|nsegments
expr_stmt|;
name|ahc_lock
argument_list|(
name|ahc
argument_list|,
operator|&
name|s
argument_list|)
expr_stmt|;
comment|/* 	 * Last time we need to check if this SCB needs to 	 * be aborted. 	 */
if|if
condition|(
name|aic_get_transaction_status
argument_list|(
name|scb
argument_list|)
operator|!=
name|CAM_REQ_INPROG
condition|)
block|{
if|if
condition|(
name|nsegments
operator|!=
literal|0
condition|)
name|bus_dmamap_unload
argument_list|(
name|ahc
operator|->
name|buffer_dmat
argument_list|,
name|scb
operator|->
name|dmamap
argument_list|)
expr_stmt|;
name|ahc_free_scb
argument_list|(
name|ahc
argument_list|,
name|scb
argument_list|)
expr_stmt|;
name|ahc_unlock
argument_list|(
name|ahc
argument_list|,
operator|&
name|s
argument_list|)
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return;
block|}
name|tinfo
operator|=
name|ahc_fetch_transinfo
argument_list|(
name|ahc
argument_list|,
name|SCSIID_CHANNEL
argument_list|(
name|ahc
argument_list|,
name|scb
operator|->
name|hscb
operator|->
name|scsiid
argument_list|)
argument_list|,
name|SCSIID_OUR_ID
argument_list|(
name|scb
operator|->
name|hscb
operator|->
name|scsiid
argument_list|)
argument_list|,
name|SCSIID_TARGET
argument_list|(
name|ahc
argument_list|,
name|scb
operator|->
name|hscb
operator|->
name|scsiid
argument_list|)
argument_list|,
operator|&
name|tstate
argument_list|)
expr_stmt|;
name|mask
operator|=
name|SCB_GET_TARGET_MASK
argument_list|(
name|ahc
argument_list|,
name|scb
argument_list|)
expr_stmt|;
name|scb
operator|->
name|hscb
operator|->
name|scsirate
operator|=
name|tinfo
operator|->
name|scsirate
expr_stmt|;
name|scb
operator|->
name|hscb
operator|->
name|scsioffset
operator|=
name|tinfo
operator|->
name|curr
operator|.
name|offset
expr_stmt|;
if|if
condition|(
operator|(
name|tstate
operator|->
name|ultraenb
operator|&
name|mask
operator|)
operator|!=
literal|0
condition|)
name|scb
operator|->
name|hscb
operator|->
name|control
operator||=
name|ULTRAENB
expr_stmt|;
if|if
condition|(
operator|(
name|tstate
operator|->
name|discenable
operator|&
name|mask
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DIS_DISCONNECT
operator|)
operator|==
literal|0
condition|)
name|scb
operator|->
name|hscb
operator|->
name|control
operator||=
name|DISCENB
expr_stmt|;
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_NEGOTIATE
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|tinfo
operator|->
name|goal
operator|.
name|width
operator|!=
literal|0
operator|||
name|tinfo
operator|->
name|goal
operator|.
name|offset
operator|!=
literal|0
operator|||
name|tinfo
operator|->
name|goal
operator|.
name|ppr_options
operator|!=
literal|0
operator|)
condition|)
block|{
name|scb
operator|->
name|flags
operator||=
name|SCB_NEGOTIATE
expr_stmt|;
name|scb
operator|->
name|hscb
operator|->
name|control
operator||=
name|MK_MESSAGE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|tstate
operator|->
name|auto_negotiate
operator|&
name|mask
operator|)
operator|!=
literal|0
condition|)
block|{
name|scb
operator|->
name|flags
operator||=
name|SCB_AUTO_NEGOTIATE
expr_stmt|;
name|scb
operator|->
name|hscb
operator|->
name|control
operator||=
name|MK_MESSAGE
expr_stmt|;
block|}
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|ahc
operator|->
name|pending_scbs
argument_list|,
name|scb
argument_list|,
name|pending_links
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_SIM_QUEUED
expr_stmt|;
comment|/* 	 * We only allow one untagged transaction 	 * per target in the initiator role unless 	 * we are storing a full busy target *lun* 	 * table in SCB space. 	 */
if|if
condition|(
operator|(
name|scb
operator|->
name|hscb
operator|->
name|control
operator|&
operator|(
name|TARGET_SCB
operator||
name|TAG_ENB
operator|)
operator|)
operator|==
literal|0
operator|&&
operator|(
name|ahc
operator|->
name|flags
operator|&
name|AHC_SCB_BTT
operator|)
operator|==
literal|0
condition|)
block|{
name|struct
name|scb_tailq
modifier|*
name|untagged_q
decl_stmt|;
name|int
name|target_offset
decl_stmt|;
name|target_offset
operator|=
name|SCB_GET_TARGET_OFFSET
argument_list|(
name|ahc
argument_list|,
name|scb
argument_list|)
expr_stmt|;
name|untagged_q
operator|=
operator|&
operator|(
name|ahc
operator|->
name|untagged_queues
index|[
name|target_offset
index|]
operator|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
name|untagged_q
argument_list|,
name|scb
argument_list|,
name|links
operator|.
name|tqe
argument_list|)
expr_stmt|;
name|scb
operator|->
name|flags
operator||=
name|SCB_UNTAGGEDQ
expr_stmt|;
if|if
condition|(
name|TAILQ_FIRST
argument_list|(
name|untagged_q
argument_list|)
operator|!=
name|scb
condition|)
block|{
name|ahc_unlock
argument_list|(
name|ahc
argument_list|,
operator|&
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|scb
operator|->
name|flags
operator||=
name|SCB_ACTIVE
expr_stmt|;
comment|/* 	 * Timers are disabled while recovery is in progress. 	 */
name|aic_scb_timer_start
argument_list|(
name|scb
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|scb
operator|->
name|flags
operator|&
name|SCB_TARGET_IMMEDIATE
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* Define a mapping from our tag to the SCB. */
name|ahc
operator|->
name|scb_data
operator|->
name|scbindex
index|[
name|scb
operator|->
name|hscb
operator|->
name|tag
index|]
operator|=
name|scb
expr_stmt|;
name|ahc_pause
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ahc
operator|->
name|flags
operator|&
name|AHC_PAGESCBS
operator|)
operator|==
literal|0
condition|)
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCBPTR
argument_list|,
name|scb
operator|->
name|hscb
operator|->
name|tag
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|TARG_IMMEDIATE_SCB
argument_list|,
name|scb
operator|->
name|hscb
operator|->
name|tag
argument_list|)
expr_stmt|;
name|ahc_unpause
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ahc_queue_scb
argument_list|(
name|ahc
argument_list|,
name|scb
argument_list|)
expr_stmt|;
block|}
name|ahc_unlock
argument_list|(
name|ahc
argument_list|,
operator|&
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ahc_poll
parameter_list|(
name|struct
name|cam_sim
modifier|*
name|sim
parameter_list|)
block|{
name|struct
name|ahc_softc
modifier|*
name|ahc
decl_stmt|;
name|ahc
operator|=
operator|(
expr|struct
name|ahc_softc
operator|*
operator|)
name|cam_sim_softc
argument_list|(
name|sim
argument_list|)
expr_stmt|;
name|ahc_intr
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ahc_setup_data
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|struct
name|cam_sim
modifier|*
name|sim
parameter_list|,
name|struct
name|ccb_scsiio
modifier|*
name|csio
parameter_list|,
name|struct
name|scb
modifier|*
name|scb
parameter_list|)
block|{
name|struct
name|hardware_scb
modifier|*
name|hscb
decl_stmt|;
name|struct
name|ccb_hdr
modifier|*
name|ccb_h
decl_stmt|;
name|hscb
operator|=
name|scb
operator|->
name|hscb
expr_stmt|;
name|ccb_h
operator|=
operator|&
name|csio
operator|->
name|ccb_h
expr_stmt|;
name|csio
operator|->
name|resid
operator|=
literal|0
expr_stmt|;
name|csio
operator|->
name|sense_resid
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ccb_h
operator|->
name|func_code
operator|==
name|XPT_SCSI_IO
condition|)
block|{
name|hscb
operator|->
name|cdb_len
operator|=
name|csio
operator|->
name|cdb_len
expr_stmt|;
if|if
condition|(
operator|(
name|ccb_h
operator|->
name|flags
operator|&
name|CAM_CDB_POINTER
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|hscb
operator|->
name|cdb_len
operator|>
sizeof|sizeof
argument_list|(
name|hscb
operator|->
name|cdb32
argument_list|)
operator|||
operator|(
name|ccb_h
operator|->
name|flags
operator|&
name|CAM_CDB_PHYS
operator|)
operator|!=
literal|0
condition|)
block|{
name|u_long
name|s
decl_stmt|;
name|aic_set_transaction_status
argument_list|(
name|scb
argument_list|,
name|CAM_REQ_INVALID
argument_list|)
expr_stmt|;
name|ahc_lock
argument_list|(
name|ahc
argument_list|,
operator|&
name|s
argument_list|)
expr_stmt|;
name|ahc_free_scb
argument_list|(
name|ahc
argument_list|,
name|scb
argument_list|)
expr_stmt|;
name|ahc_unlock
argument_list|(
name|ahc
argument_list|,
operator|&
name|s
argument_list|)
expr_stmt|;
name|xpt_done
argument_list|(
operator|(
expr|union
name|ccb
operator|*
operator|)
name|csio
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|hscb
operator|->
name|cdb_len
operator|>
literal|12
condition|)
block|{
name|memcpy
argument_list|(
name|hscb
operator|->
name|cdb32
argument_list|,
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_ptr
argument_list|,
name|hscb
operator|->
name|cdb_len
argument_list|)
expr_stmt|;
name|scb
operator|->
name|flags
operator||=
name|SCB_CDB32_PTR
expr_stmt|;
block|}
else|else
block|{
name|memcpy
argument_list|(
name|hscb
operator|->
name|shared_data
operator|.
name|cdb
argument_list|,
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_ptr
argument_list|,
name|hscb
operator|->
name|cdb_len
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|hscb
operator|->
name|cdb_len
operator|>
literal|12
condition|)
block|{
name|memcpy
argument_list|(
name|hscb
operator|->
name|cdb32
argument_list|,
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
argument_list|,
name|hscb
operator|->
name|cdb_len
argument_list|)
expr_stmt|;
name|scb
operator|->
name|flags
operator||=
name|SCB_CDB32_PTR
expr_stmt|;
block|}
else|else
block|{
name|memcpy
argument_list|(
name|hscb
operator|->
name|shared_data
operator|.
name|cdb
argument_list|,
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
argument_list|,
name|hscb
operator|->
name|cdb_len
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* Only use S/G if there is a transfer */
if|if
condition|(
operator|(
name|ccb_h
operator|->
name|flags
operator|&
name|CAM_DIR_MASK
operator|)
operator|!=
name|CAM_DIR_NONE
condition|)
block|{
if|if
condition|(
operator|(
name|ccb_h
operator|->
name|flags
operator|&
name|CAM_SCATTER_VALID
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* We've been given a pointer to a single buffer */
if|if
condition|(
operator|(
name|ccb_h
operator|->
name|flags
operator|&
name|CAM_DATA_PHYS
operator|)
operator|==
literal|0
condition|)
block|{
name|int
name|s
decl_stmt|;
name|int
name|error
decl_stmt|;
name|s
operator|=
name|splsoftvm
argument_list|()
expr_stmt|;
name|error
operator|=
name|bus_dmamap_load
argument_list|(
name|ahc
operator|->
name|buffer_dmat
argument_list|,
name|scb
operator|->
name|dmamap
argument_list|,
name|csio
operator|->
name|data_ptr
argument_list|,
name|csio
operator|->
name|dxfer_len
argument_list|,
name|ahc_execute_scb
argument_list|,
name|scb
argument_list|,
comment|/*flags*/
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|EINPROGRESS
condition|)
block|{
comment|/* 					 * So as to maintain ordering, 					 * freeze the controller queue 					 * until our mapping is 					 * returned. 					 */
name|xpt_freeze_simq
argument_list|(
name|sim
argument_list|,
comment|/*count*/
literal|1
argument_list|)
expr_stmt|;
name|scb
operator|->
name|io_ctx
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_RELEASE_SIMQ
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|struct
name|bus_dma_segment
name|seg
decl_stmt|;
comment|/* Pointer to physical buffer */
if|if
condition|(
name|csio
operator|->
name|dxfer_len
operator|>
name|AHC_MAXTRANSFER_SIZE
condition|)
name|panic
argument_list|(
literal|"ahc_setup_data - Transfer size "
literal|"larger than can device max"
argument_list|)
expr_stmt|;
name|seg
operator|.
name|ds_addr
operator|=
operator|(
name|bus_addr_t
operator|)
operator|(
name|vm_offset_t
operator|)
name|csio
operator|->
name|data_ptr
expr_stmt|;
name|seg
operator|.
name|ds_len
operator|=
name|csio
operator|->
name|dxfer_len
expr_stmt|;
name|ahc_execute_scb
argument_list|(
name|scb
argument_list|,
operator|&
name|seg
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|struct
name|bus_dma_segment
modifier|*
name|segs
decl_stmt|;
if|if
condition|(
operator|(
name|ccb_h
operator|->
name|flags
operator|&
name|CAM_DATA_PHYS
operator|)
operator|!=
literal|0
condition|)
name|panic
argument_list|(
literal|"ahc_setup_data - Physical segment "
literal|"pointers unsupported"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ccb_h
operator|->
name|flags
operator|&
name|CAM_SG_LIST_PHYS
operator|)
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"ahc_setup_data - Virtual segment "
literal|"addresses unsupported"
argument_list|)
expr_stmt|;
comment|/* Just use the segments provided */
name|segs
operator|=
operator|(
expr|struct
name|bus_dma_segment
operator|*
operator|)
name|csio
operator|->
name|data_ptr
expr_stmt|;
name|ahc_execute_scb
argument_list|(
name|scb
argument_list|,
name|segs
argument_list|,
name|csio
operator|->
name|sglist_cnt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|ahc_execute_scb
argument_list|(
name|scb
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ahc_abort_ccb
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|struct
name|cam_sim
modifier|*
name|sim
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
block|{
name|union
name|ccb
modifier|*
name|abort_ccb
decl_stmt|;
name|abort_ccb
operator|=
name|ccb
operator|->
name|cab
operator|.
name|abort_ccb
expr_stmt|;
switch|switch
condition|(
name|abort_ccb
operator|->
name|ccb_h
operator|.
name|func_code
condition|)
block|{
case|case
name|XPT_ACCEPT_TARGET_IO
case|:
case|case
name|XPT_IMMED_NOTIFY
case|:
case|case
name|XPT_CONT_TARGET_IO
case|:
block|{
name|struct
name|ahc_tmode_tstate
modifier|*
name|tstate
decl_stmt|;
name|struct
name|ahc_tmode_lstate
modifier|*
name|lstate
decl_stmt|;
name|struct
name|ccb_hdr_slist
modifier|*
name|list
decl_stmt|;
name|cam_status
name|status
decl_stmt|;
name|status
operator|=
name|ahc_find_tmode_devs
argument_list|(
name|ahc
argument_list|,
name|sim
argument_list|,
name|abort_ccb
argument_list|,
operator|&
name|tstate
argument_list|,
operator|&
name|lstate
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|status
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|abort_ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|==
name|XPT_ACCEPT_TARGET_IO
condition|)
name|list
operator|=
operator|&
name|lstate
operator|->
name|accept_tios
expr_stmt|;
elseif|else
if|if
condition|(
name|abort_ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|==
name|XPT_IMMED_NOTIFY
condition|)
name|list
operator|=
operator|&
name|lstate
operator|->
name|immed_notifies
expr_stmt|;
else|else
name|list
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|list
operator|!=
name|NULL
condition|)
block|{
name|struct
name|ccb_hdr
modifier|*
name|curelm
decl_stmt|;
name|int
name|found
decl_stmt|;
name|curelm
operator|=
name|SLIST_FIRST
argument_list|(
name|list
argument_list|)
expr_stmt|;
name|found
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|curelm
operator|==
operator|&
name|abort_ccb
operator|->
name|ccb_h
condition|)
block|{
name|found
operator|=
literal|1
expr_stmt|;
name|SLIST_REMOVE_HEAD
argument_list|(
name|list
argument_list|,
name|sim_links
operator|.
name|sle
argument_list|)
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
name|curelm
operator|!=
name|NULL
condition|)
block|{
name|struct
name|ccb_hdr
modifier|*
name|nextelm
decl_stmt|;
name|nextelm
operator|=
name|SLIST_NEXT
argument_list|(
name|curelm
argument_list|,
name|sim_links
operator|.
name|sle
argument_list|)
expr_stmt|;
if|if
condition|(
name|nextelm
operator|==
operator|&
name|abort_ccb
operator|->
name|ccb_h
condition|)
block|{
name|found
operator|=
literal|1
expr_stmt|;
name|SLIST_NEXT
argument_list|(
name|curelm
argument_list|,
name|sim_links
operator|.
name|sle
argument_list|)
operator|=
name|SLIST_NEXT
argument_list|(
name|nextelm
argument_list|,
name|sim_links
operator|.
name|sle
argument_list|)
expr_stmt|;
break|break;
block|}
name|curelm
operator|=
name|nextelm
expr_stmt|;
block|}
block|}
if|if
condition|(
name|found
condition|)
block|{
name|abort_ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_ABORTED
expr_stmt|;
name|xpt_done
argument_list|(
name|abort_ccb
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
block|}
else|else
block|{
name|xpt_print_path
argument_list|(
name|abort_ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Not found\n"
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_PATH_INVALID
expr_stmt|;
block|}
break|break;
block|}
comment|/* FALLTHROUGH */
block|}
case|case
name|XPT_SCSI_IO
case|:
comment|/* XXX Fully implement the hard ones */
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_UA_ABORT
expr_stmt|;
break|break;
default|default:
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_INVALID
expr_stmt|;
break|break;
block|}
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ahc_send_async
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|char
name|channel
parameter_list|,
name|u_int
name|target
parameter_list|,
name|u_int
name|lun
parameter_list|,
name|ac_code
name|code
parameter_list|,
name|void
modifier|*
name|opt_arg
parameter_list|)
block|{
name|struct
name|ccb_trans_settings
name|cts
decl_stmt|;
name|struct
name|cam_path
modifier|*
name|path
decl_stmt|;
name|void
modifier|*
name|arg
decl_stmt|;
name|int
name|error
decl_stmt|;
name|arg
operator|=
name|NULL
expr_stmt|;
name|error
operator|=
name|ahc_create_path
argument_list|(
name|ahc
argument_list|,
name|channel
argument_list|,
name|target
argument_list|,
name|lun
argument_list|,
operator|&
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
name|CAM_REQ_CMP
condition|)
return|return;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|AC_TRANSFER_NEG
case|:
block|{
name|struct
name|ccb_trans_settings_scsi
modifier|*
name|scsi
decl_stmt|;
name|cts
operator|.
name|type
operator|=
name|CTS_TYPE_CURRENT_SETTINGS
expr_stmt|;
name|scsi
operator|=
operator|&
name|cts
operator|.
name|proto_specific
operator|.
name|scsi
expr_stmt|;
name|cts
operator|.
name|ccb_h
operator|.
name|path
operator|=
name|path
expr_stmt|;
name|cts
operator|.
name|ccb_h
operator|.
name|target_id
operator|=
name|target
expr_stmt|;
name|cts
operator|.
name|ccb_h
operator|.
name|target_lun
operator|=
name|lun
expr_stmt|;
name|ahc_get_tran_settings
argument_list|(
name|ahc
argument_list|,
name|channel
operator|==
literal|'A'
condition|?
name|ahc
operator|->
name|our_id
else|:
name|ahc
operator|->
name|our_id_b
argument_list|,
name|channel
argument_list|,
operator|&
name|cts
argument_list|)
expr_stmt|;
name|arg
operator|=
operator|&
name|cts
expr_stmt|;
name|scsi
operator|->
name|valid
operator|&=
operator|~
name|CTS_SCSI_VALID_TQ
expr_stmt|;
name|scsi
operator|->
name|flags
operator|&=
operator|~
name|CTS_SCSI_FLAGS_TAG_ENB
expr_stmt|;
if|if
condition|(
name|opt_arg
operator|==
name|NULL
condition|)
break|break;
if|if
condition|(
operator|*
operator|(
operator|(
name|ahc_queue_alg
operator|*
operator|)
name|opt_arg
operator|)
operator|==
name|AHC_QUEUE_TAGGED
condition|)
name|scsi
operator|->
name|flags
operator||=
operator|~
name|CTS_SCSI_FLAGS_TAG_ENB
expr_stmt|;
name|scsi
operator|->
name|valid
operator||=
name|CTS_SCSI_VALID_TQ
expr_stmt|;
break|break;
block|}
case|case
name|AC_SENT_BDR
case|:
case|case
name|AC_BUS_RESET
case|:
break|break;
default|default:
name|panic
argument_list|(
literal|"ahc_send_async: Unexpected async event"
argument_list|)
expr_stmt|;
block|}
name|xpt_async
argument_list|(
name|code
argument_list|,
name|path
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|xpt_free_path
argument_list|(
name|path
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ahc_platform_set_tags
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|struct
name|ahc_devinfo
modifier|*
name|devinfo
parameter_list|,
name|int
name|enable
parameter_list|)
block|{ }
end_function

begin_function
name|int
name|ahc_platform_alloc
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|void
modifier|*
name|platform_arg
parameter_list|)
block|{
name|ahc
operator|->
name|platform_data
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ahc_platform_data
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|ahc
operator|->
name|platform_data
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|ahc_platform_free
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|)
block|{
name|struct
name|ahc_platform_data
modifier|*
name|pdata
decl_stmt|;
name|pdata
operator|=
name|ahc
operator|->
name|platform_data
expr_stmt|;
if|if
condition|(
name|pdata
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|pdata
operator|->
name|regs
operator|!=
name|NULL
condition|)
name|bus_release_resource
argument_list|(
name|ahc
operator|->
name|dev_softc
argument_list|,
name|pdata
operator|->
name|regs_res_type
argument_list|,
name|pdata
operator|->
name|regs_res_id
argument_list|,
name|pdata
operator|->
name|regs
argument_list|)
expr_stmt|;
if|if
condition|(
name|pdata
operator|->
name|irq
operator|!=
name|NULL
condition|)
name|bus_release_resource
argument_list|(
name|ahc
operator|->
name|dev_softc
argument_list|,
name|pdata
operator|->
name|irq_res_type
argument_list|,
literal|0
argument_list|,
name|pdata
operator|->
name|irq
argument_list|)
expr_stmt|;
if|if
condition|(
name|pdata
operator|->
name|sim_b
operator|!=
name|NULL
condition|)
block|{
name|xpt_async
argument_list|(
name|AC_LOST_DEVICE
argument_list|,
name|pdata
operator|->
name|path_b
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|xpt_free_path
argument_list|(
name|pdata
operator|->
name|path_b
argument_list|)
expr_stmt|;
name|xpt_bus_deregister
argument_list|(
name|cam_sim_path
argument_list|(
name|pdata
operator|->
name|sim_b
argument_list|)
argument_list|)
expr_stmt|;
name|cam_sim_free
argument_list|(
name|pdata
operator|->
name|sim_b
argument_list|,
comment|/*free_devq*/
name|TRUE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pdata
operator|->
name|sim
operator|!=
name|NULL
condition|)
block|{
name|xpt_async
argument_list|(
name|AC_LOST_DEVICE
argument_list|,
name|pdata
operator|->
name|path
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|xpt_free_path
argument_list|(
name|pdata
operator|->
name|path
argument_list|)
expr_stmt|;
name|xpt_bus_deregister
argument_list|(
name|cam_sim_path
argument_list|(
name|pdata
operator|->
name|sim
argument_list|)
argument_list|)
expr_stmt|;
name|cam_sim_free
argument_list|(
name|pdata
operator|->
name|sim
argument_list|,
comment|/*free_devq*/
name|TRUE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pdata
operator|->
name|eh
operator|!=
name|NULL
condition|)
name|EVENTHANDLER_DEREGISTER
argument_list|(
name|shutdown_final
argument_list|,
name|pdata
operator|->
name|eh
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ahc
operator|->
name|platform_data
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|ahc_softc_comp
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|lahc
parameter_list|,
name|struct
name|ahc_softc
modifier|*
name|rahc
parameter_list|)
block|{
comment|/* We don't sort softcs under FreeBSD so report equal always */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ahc_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|ahc_softc
modifier|*
name|ahc
decl_stmt|;
name|u_long
name|l
decl_stmt|;
name|u_long
name|s
decl_stmt|;
name|ahc_list_lock
argument_list|(
operator|&
name|l
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"detaching device\n"
argument_list|)
expr_stmt|;
name|ahc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|ahc
operator|=
name|ahc_find_softc
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
if|if
condition|(
name|ahc
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"aic7xxx already detached\n"
argument_list|)
expr_stmt|;
name|ahc_list_unlock
argument_list|(
operator|&
name|l
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
name|TAILQ_REMOVE
argument_list|(
operator|&
name|ahc_tailq
argument_list|,
name|ahc
argument_list|,
name|links
argument_list|)
expr_stmt|;
name|ahc_list_unlock
argument_list|(
operator|&
name|l
argument_list|)
expr_stmt|;
name|ahc_lock
argument_list|(
name|ahc
argument_list|,
operator|&
name|s
argument_list|)
expr_stmt|;
name|ahc_intr_enable
argument_list|(
name|ahc
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|bus_teardown_intr
argument_list|(
name|dev
argument_list|,
name|ahc
operator|->
name|platform_data
operator|->
name|irq
argument_list|,
name|ahc
operator|->
name|platform_data
operator|->
name|ih
argument_list|)
expr_stmt|;
name|ahc_unlock
argument_list|(
name|ahc
argument_list|,
operator|&
name|s
argument_list|)
expr_stmt|;
name|ahc_free
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
unit|static void ahc_dump_targcmd(struct target_cmd *cmd) { 	uint8_t *byte; 	uint8_t *last_byte; 	int i;  	byte =&cmd->initiator_channel;
comment|/* Debugging info for received commands */
end_comment

begin_endif
unit|last_byte =&cmd[1].initiator_channel;  	i = 0; 	while (byte< last_byte) { 		if (i == 0) 			printf("\t"); 		printf("%#x", *byte++); 		i++; 		if (i == 8) { 			printf("\n"); 			i = 0; 		} else { 			printf(", "); 		} 	} }
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|int
name|ahc_modevent
parameter_list|(
name|module_t
name|mod
parameter_list|,
name|int
name|type
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
comment|/* XXX Deal with busy status on unload. */
comment|/* XXX Deal with unknown events */
return|return
literal|0
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|moduledata_t
name|ahc_mod
init|=
block|{
literal|"ahc"
block|,
name|ahc_modevent
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DECLARE_MODULE
argument_list|(
name|ahc
argument_list|,
name|ahc_mod
argument_list|,
name|SI_SUB_DRIVERS
argument_list|,
name|SI_ORDER_MIDDLE
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|ahc
argument_list|,
name|cam
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_VERSION
argument_list|(
name|ahc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

