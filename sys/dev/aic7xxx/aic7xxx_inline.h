begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Inline routines shareable across OS platforms.  *  * Copyright (c) 1994-2001 Justin T. Gibbs.  * Copyright (c) 2000-2001 Adaptec Inc.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions, and the following disclaimer,  *    without modification.  * 2. Redistributions in binary form must reproduce at minimum a disclaimer  *    substantially similar to the "NO WARRANTY" disclaimer below  *    ("Disclaimer") and any redistribution must be conditioned upon  *    including a substantially similar Disclaimer requirement for further  *    binary redistribution.  * 3. Neither the names of the above-listed copyright holders nor the names  *    of any contributors may be used to endorse or promote products derived  *    from this software without specific prior written permission.  *  * Alternatively, this software may be distributed under the terms of the  * GNU General Public License ("GPL") version 2 as published by the Free  * Software Foundation.  *  * NO WARRANTY  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT  * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING  * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  * POSSIBILITY OF SUCH DAMAGES.  *  * $Id: //depot/aic7xxx/aic7xxx/aic7xxx_inline.h#47 $  *  * $FreeBSD$  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|_AIC7XXX_INLINE_H_
end_ifndef

begin_define
define|#
directive|define
name|_AIC7XXX_INLINE_H_
end_define

begin_comment
comment|/************************* Sequencer Execution Control ************************/
end_comment

begin_function_decl
specifier|static
name|__inline
name|void
name|ahc_pause_bug_fix
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__inline
name|int
name|ahc_is_paused
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__inline
name|void
name|ahc_pause
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__inline
name|void
name|ahc_unpause
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Work around any chip bugs related to halting sequencer execution.  * On Ultra2 controllers, we must clear the CIOBUS stretch signal by  * reading a register that will set this signal and deassert it.  * Without this workaround, if the chip is paused, by an interrupt or  * manual pause while accessing scb ram, accesses to certain registers  * will hang the system (infinite pci retries).  */
end_comment

begin_function
specifier|static
name|__inline
name|void
name|ahc_pause_bug_fix
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|)
block|{
if|if
condition|(
operator|(
name|ahc
operator|->
name|features
operator|&
name|AHC_ULTRA2
operator|)
operator|!=
literal|0
condition|)
operator|(
name|void
operator|)
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|CCSCBCTL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Determine whether the sequencer has halted code execution.  * Returns non-zero status if the sequencer is stopped.  */
end_comment

begin_function
specifier|static
name|__inline
name|int
name|ahc_is_paused
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|)
block|{
return|return
operator|(
operator|(
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|HCNTRL
argument_list|)
operator|&
name|PAUSE
operator|)
operator|!=
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Request that the sequencer stop and wait, indefinitely, for it  * to stop.  The sequencer will only acknowledge that it is paused  * once it has reached an instruction boundary and PAUSEDIS is  * cleared in the SEQCTL register.  The sequencer may use PAUSEDIS  * for critical sections.  */
end_comment

begin_function
specifier|static
name|__inline
name|void
name|ahc_pause
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|)
block|{
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|HCNTRL
argument_list|,
name|ahc
operator|->
name|pause
argument_list|)
expr_stmt|;
comment|/* 	 * Since the sequencer can disable pausing in a critical section, we 	 * must loop until it actually stops. 	 */
while|while
condition|(
name|ahc_is_paused
argument_list|(
name|ahc
argument_list|)
operator|==
literal|0
condition|)
empty_stmt|;
name|ahc_pause_bug_fix
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Allow the sequencer to continue program execution.  * We check here to ensure that no additional interrupt  * sources that would cause the sequencer to halt have been  * asserted.  If, for example, a SCSI bus reset is detected  * while we are fielding a different, pausing, interrupt type,  * we don't want to release the sequencer before going back  * into our interrupt handler and dealing with this new  * condition.  */
end_comment

begin_function
specifier|static
name|__inline
name|void
name|ahc_unpause
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|)
block|{
if|if
condition|(
operator|(
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|INTSTAT
argument_list|)
operator|&
operator|(
name|SCSIINT
operator||
name|SEQINT
operator||
name|BRKADRINT
operator|)
operator|)
operator|==
literal|0
condition|)
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|HCNTRL
argument_list|,
name|ahc
operator|->
name|unpause
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*********************** Untagged Transaction Routines ************************/
end_comment

begin_function_decl
specifier|static
name|__inline
name|void
name|ahc_freeze_untagged_queues
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__inline
name|void
name|ahc_release_untagged_queues
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Block our completion routine from starting the next untagged  * transaction for this target or target lun.  */
end_comment

begin_function
specifier|static
name|__inline
name|void
name|ahc_freeze_untagged_queues
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|)
block|{
if|if
condition|(
operator|(
name|ahc
operator|->
name|flags
operator|&
name|AHC_SCB_BTT
operator|)
operator|==
literal|0
condition|)
name|ahc
operator|->
name|untagged_queue_lock
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Allow the next untagged transaction for this target or target lun  * to be executed.  We use a counting semaphore to allow the lock  * to be acquired recursively.  Once the count drops to zero, the  * transaction queues will be run.  */
end_comment

begin_function
specifier|static
name|__inline
name|void
name|ahc_release_untagged_queues
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|)
block|{
if|if
condition|(
operator|(
name|ahc
operator|->
name|flags
operator|&
name|AHC_SCB_BTT
operator|)
operator|==
literal|0
condition|)
block|{
name|ahc
operator|->
name|untagged_queue_lock
operator|--
expr_stmt|;
if|if
condition|(
name|ahc
operator|->
name|untagged_queue_lock
operator|==
literal|0
condition|)
name|ahc_run_untagged_queues
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/************************** Memory mapping routines ***************************/
end_comment

begin_expr_stmt
specifier|static
name|__inline
expr|struct
name|ahc_dma_seg
operator|*
name|ahc_sg_bus_to_virt
argument_list|(
argument|struct scb *scb
argument_list|,
argument|uint32_t sg_busaddr
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function_decl
specifier|static
name|__inline
name|uint32_t
name|ahc_sg_virt_to_bus
parameter_list|(
name|struct
name|scb
modifier|*
name|scb
parameter_list|,
name|struct
name|ahc_dma_seg
modifier|*
name|sg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__inline
name|uint32_t
name|ahc_hscb_busaddr
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|u_int
name|index
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__inline
name|void
name|ahc_sync_scb
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|struct
name|scb
modifier|*
name|scb
parameter_list|,
name|int
name|op
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__inline
name|void
name|ahc_sync_sglist
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|struct
name|scb
modifier|*
name|scb
parameter_list|,
name|int
name|op
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__inline
name|uint32_t
name|ahc_targetcmd_offset
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|u_int
name|index
parameter_list|)
function_decl|;
end_function_decl

begin_expr_stmt
specifier|static
name|__inline
expr|struct
name|ahc_dma_seg
operator|*
name|ahc_sg_bus_to_virt
argument_list|(
argument|struct scb *scb
argument_list|,
argument|uint32_t sg_busaddr
argument_list|)
block|{
name|int
name|sg_index
block|;
name|sg_index
operator|=
operator|(
name|sg_busaddr
operator|-
name|scb
operator|->
name|sg_list_phys
operator|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|ahc_dma_seg
argument_list|)
block|;
comment|/* sg_list_phys points to entry 1, not 0 */
name|sg_index
operator|++
block|;
return|return
operator|(
operator|&
name|scb
operator|->
name|sg_list
index|[
name|sg_index
index|]
operator|)
return|;
block|}
end_expr_stmt

begin_function
specifier|static
name|__inline
name|uint32_t
name|ahc_sg_virt_to_bus
parameter_list|(
name|struct
name|scb
modifier|*
name|scb
parameter_list|,
name|struct
name|ahc_dma_seg
modifier|*
name|sg
parameter_list|)
block|{
name|int
name|sg_index
decl_stmt|;
comment|/* sg_list_phys points to entry 1, not 0 */
name|sg_index
operator|=
name|sg
operator|-
operator|&
name|scb
operator|->
name|sg_list
index|[
literal|1
index|]
expr_stmt|;
return|return
operator|(
name|scb
operator|->
name|sg_list_phys
operator|+
operator|(
name|sg_index
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|scb
operator|->
name|sg_list
argument_list|)
operator|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|uint32_t
name|ahc_hscb_busaddr
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|u_int
name|index
parameter_list|)
block|{
return|return
operator|(
name|ahc
operator|->
name|scb_data
operator|->
name|hscb_busaddr
operator|+
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|hardware_scb
argument_list|)
operator|*
name|index
operator|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|ahc_sync_scb
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|struct
name|scb
modifier|*
name|scb
parameter_list|,
name|int
name|op
parameter_list|)
block|{
name|aic_dmamap_sync
argument_list|(
name|ahc
argument_list|,
name|ahc
operator|->
name|scb_data
operator|->
name|hscb_dmat
argument_list|,
name|ahc
operator|->
name|scb_data
operator|->
name|hscb_dmamap
argument_list|,
comment|/*offset*/
operator|(
name|scb
operator|->
name|hscb
operator|-
name|ahc
operator|->
name|hscbs
operator|)
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|scb
operator|->
name|hscb
argument_list|)
argument_list|,
comment|/*len*/
sizeof|sizeof
argument_list|(
operator|*
name|scb
operator|->
name|hscb
argument_list|)
argument_list|,
name|op
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|ahc_sync_sglist
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|struct
name|scb
modifier|*
name|scb
parameter_list|,
name|int
name|op
parameter_list|)
block|{
if|if
condition|(
name|scb
operator|->
name|sg_count
operator|==
literal|0
condition|)
return|return;
name|aic_dmamap_sync
argument_list|(
name|ahc
argument_list|,
name|ahc
operator|->
name|scb_data
operator|->
name|sg_dmat
argument_list|,
name|scb
operator|->
name|sg_map
operator|->
name|sg_dmamap
argument_list|,
comment|/*offset*/
operator|(
name|scb
operator|->
name|sg_list
operator|-
name|scb
operator|->
name|sg_map
operator|->
name|sg_vaddr
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|ahc_dma_seg
argument_list|)
argument_list|,
comment|/*len*/
sizeof|sizeof
argument_list|(
expr|struct
name|ahc_dma_seg
argument_list|)
operator|*
name|scb
operator|->
name|sg_count
argument_list|,
name|op
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|uint32_t
name|ahc_targetcmd_offset
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|u_int
name|index
parameter_list|)
block|{
return|return
operator|(
operator|(
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|ahc
operator|->
name|targetcmds
index|[
name|index
index|]
operator|)
operator|-
name|ahc
operator|->
name|qoutfifo
operator|)
return|;
block|}
end_function

begin_comment
comment|/******************************** Debugging ***********************************/
end_comment

begin_function_decl
specifier|static
name|__inline
name|char
modifier|*
name|ahc_name
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|__inline
name|char
modifier|*
name|ahc_name
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|)
block|{
return|return
operator|(
name|ahc
operator|->
name|name
operator|)
return|;
block|}
end_function

begin_comment
comment|/*********************** Miscelaneous Support Functions ***********************/
end_comment

begin_function_decl
specifier|static
name|__inline
name|void
name|ahc_update_residual
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|struct
name|scb
modifier|*
name|scb
parameter_list|)
function_decl|;
end_function_decl

begin_expr_stmt
specifier|static
name|__inline
expr|struct
name|ahc_initiator_tinfo
operator|*
name|ahc_fetch_transinfo
argument_list|(
argument|struct ahc_softc *ahc
argument_list|,
argument|char channel
argument_list|,
argument|u_int our_id
argument_list|,
argument|u_int remote_id
argument_list|,
argument|struct ahc_tmode_tstate **tstate
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function_decl
specifier|static
name|__inline
name|uint16_t
name|ahc_inw
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|u_int
name|port
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__inline
name|void
name|ahc_outw
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|u_int
name|port
parameter_list|,
name|u_int
name|value
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__inline
name|uint32_t
name|ahc_inl
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|u_int
name|port
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__inline
name|void
name|ahc_outl
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|u_int
name|port
parameter_list|,
name|uint32_t
name|value
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__inline
name|uint64_t
name|ahc_inq
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|u_int
name|port
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__inline
name|void
name|ahc_outq
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|u_int
name|port
parameter_list|,
name|uint64_t
name|value
parameter_list|)
function_decl|;
end_function_decl

begin_expr_stmt
specifier|static
name|__inline
expr|struct
name|scb
operator|*
name|ahc_get_scb
argument_list|(
expr|struct
name|ahc_softc
operator|*
name|ahc
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function_decl
specifier|static
name|__inline
name|void
name|ahc_free_scb
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|struct
name|scb
modifier|*
name|scb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__inline
name|void
name|ahc_swap_with_next_hscb
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|struct
name|scb
modifier|*
name|scb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__inline
name|void
name|ahc_queue_scb
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|struct
name|scb
modifier|*
name|scb
parameter_list|)
function_decl|;
end_function_decl

begin_expr_stmt
specifier|static
name|__inline
expr|struct
name|scsi_sense_data
operator|*
name|ahc_get_sense_buf
argument_list|(
expr|struct
name|ahc_softc
operator|*
name|ahc
argument_list|,
expr|struct
name|scb
operator|*
name|scb
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function_decl
specifier|static
name|__inline
name|uint32_t
name|ahc_get_sense_bufaddr
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|struct
name|scb
modifier|*
name|scb
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Determine whether the sequencer reported a residual  * for this SCB/transaction.  */
end_comment

begin_function
specifier|static
name|__inline
name|void
name|ahc_update_residual
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|struct
name|scb
modifier|*
name|scb
parameter_list|)
block|{
name|uint32_t
name|sgptr
decl_stmt|;
name|sgptr
operator|=
name|aic_le32toh
argument_list|(
name|scb
operator|->
name|hscb
operator|->
name|sgptr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sgptr
operator|&
name|SG_RESID_VALID
operator|)
operator|!=
literal|0
condition|)
name|ahc_calc_residual
argument_list|(
name|ahc
argument_list|,
name|scb
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Return pointers to the transfer negotiation information  * for the specified our_id/remote_id pair.  */
end_comment

begin_expr_stmt
specifier|static
name|__inline
expr|struct
name|ahc_initiator_tinfo
operator|*
name|ahc_fetch_transinfo
argument_list|(
argument|struct ahc_softc *ahc
argument_list|,
argument|char channel
argument_list|,
argument|u_int our_id
argument_list|,
argument|u_int remote_id
argument_list|,
argument|struct ahc_tmode_tstate **tstate
argument_list|)
block|{
comment|/* 	 * Transfer data structures are stored from the perspective 	 * of the target role.  Since the parameters for a connection 	 * in the initiator role to a given target are the same as 	 * when the roles are reversed, we pretend we are the target. 	 */
if|if
condition|(
name|channel
operator|==
literal|'B'
condition|)
name|our_id
operator|+=
literal|8
expr_stmt|;
operator|*
name|tstate
operator|=
name|ahc
operator|->
name|enabled_targets
index|[
name|our_id
index|]
expr_stmt|;
end_expr_stmt

begin_return
return|return
operator|(
operator|&
operator|(
operator|*
name|tstate
operator|)
operator|->
name|transinfo
index|[
name|remote_id
index|]
operator|)
return|;
end_return

begin_function
unit|}  static
name|__inline
name|uint16_t
name|ahc_inw
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|u_int
name|port
parameter_list|)
block|{
return|return
operator|(
operator|(
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|port
operator|+
literal|1
argument_list|)
operator|<<
literal|8
operator|)
operator||
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|port
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|ahc_outw
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|u_int
name|port
parameter_list|,
name|u_int
name|value
parameter_list|)
block|{
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|port
argument_list|,
name|value
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|port
operator|+
literal|1
argument_list|,
operator|(
name|value
operator|>>
literal|8
operator|)
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|uint32_t
name|ahc_inl
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|u_int
name|port
parameter_list|)
block|{
return|return
operator|(
operator|(
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|port
argument_list|)
operator|)
operator||
operator|(
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|port
operator|+
literal|1
argument_list|)
operator|<<
literal|8
operator|)
operator||
operator|(
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|port
operator|+
literal|2
argument_list|)
operator|<<
literal|16
operator|)
operator||
operator|(
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|port
operator|+
literal|3
argument_list|)
operator|<<
literal|24
operator|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|ahc_outl
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|u_int
name|port
parameter_list|,
name|uint32_t
name|value
parameter_list|)
block|{
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|port
argument_list|,
operator|(
name|value
operator|)
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|port
operator|+
literal|1
argument_list|,
operator|(
operator|(
name|value
operator|)
operator|>>
literal|8
operator|)
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|port
operator|+
literal|2
argument_list|,
operator|(
operator|(
name|value
operator|)
operator|>>
literal|16
operator|)
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|port
operator|+
literal|3
argument_list|,
operator|(
operator|(
name|value
operator|)
operator|>>
literal|24
operator|)
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|uint64_t
name|ahc_inq
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|u_int
name|port
parameter_list|)
block|{
return|return
operator|(
operator|(
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|port
argument_list|)
operator|)
operator||
operator|(
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|port
operator|+
literal|1
argument_list|)
operator|<<
literal|8
operator|)
operator||
operator|(
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|port
operator|+
literal|2
argument_list|)
operator|<<
literal|16
operator|)
operator||
operator|(
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|port
operator|+
literal|3
argument_list|)
operator|<<
literal|24
operator|)
operator||
operator|(
operator|(
operator|(
name|uint64_t
operator|)
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|port
operator|+
literal|4
argument_list|)
operator|)
operator|<<
literal|32
operator|)
operator||
operator|(
operator|(
operator|(
name|uint64_t
operator|)
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|port
operator|+
literal|5
argument_list|)
operator|)
operator|<<
literal|40
operator|)
operator||
operator|(
operator|(
operator|(
name|uint64_t
operator|)
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|port
operator|+
literal|6
argument_list|)
operator|)
operator|<<
literal|48
operator|)
operator||
operator|(
operator|(
operator|(
name|uint64_t
operator|)
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|port
operator|+
literal|7
argument_list|)
operator|)
operator|<<
literal|56
operator|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|ahc_outq
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|u_int
name|port
parameter_list|,
name|uint64_t
name|value
parameter_list|)
block|{
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|port
argument_list|,
name|value
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|port
operator|+
literal|1
argument_list|,
operator|(
name|value
operator|>>
literal|8
operator|)
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|port
operator|+
literal|2
argument_list|,
operator|(
name|value
operator|>>
literal|16
operator|)
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|port
operator|+
literal|3
argument_list|,
operator|(
name|value
operator|>>
literal|24
operator|)
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|port
operator|+
literal|4
argument_list|,
operator|(
name|value
operator|>>
literal|32
operator|)
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|port
operator|+
literal|5
argument_list|,
operator|(
name|value
operator|>>
literal|40
operator|)
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|port
operator|+
literal|6
argument_list|,
operator|(
name|value
operator|>>
literal|48
operator|)
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|port
operator|+
literal|7
argument_list|,
operator|(
name|value
operator|>>
literal|56
operator|)
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Get a free scb. If there are none, see if we can allocate a new SCB.  */
end_comment

begin_expr_stmt
specifier|static
name|__inline
expr|struct
name|scb
operator|*
name|ahc_get_scb
argument_list|(
argument|struct ahc_softc *ahc
argument_list|)
block|{ 	struct
name|scb
operator|*
name|scb
block|;
if|if
condition|(
operator|(
name|scb
operator|=
name|SLIST_FIRST
argument_list|(
operator|&
name|ahc
operator|->
name|scb_data
operator|->
name|free_scbs
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|ahc_alloc_scbs
argument_list|(
name|ahc
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|scb
operator|=
name|SLIST_FIRST
argument_list|(
operator|&
name|ahc
operator|->
name|scb_data
operator|->
name|free_scbs
argument_list|)
expr_stmt|;
if|if
condition|(
name|scb
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|SLIST_REMOVE_HEAD
argument_list|(
operator|&
name|ahc
operator|->
name|scb_data
operator|->
name|free_scbs
argument_list|,
name|links
operator|.
name|sle
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
operator|(
name|scb
operator|)
return|;
end_return

begin_comment
unit|}
comment|/*  * Return an SCB resource to the free list.  */
end_comment

begin_function
unit|static
name|__inline
name|void
name|ahc_free_scb
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|struct
name|scb
modifier|*
name|scb
parameter_list|)
block|{
name|struct
name|hardware_scb
modifier|*
name|hscb
decl_stmt|;
name|hscb
operator|=
name|scb
operator|->
name|hscb
expr_stmt|;
comment|/* Clean up for the next user */
name|ahc
operator|->
name|scb_data
operator|->
name|scbindex
index|[
name|hscb
operator|->
name|tag
index|]
operator|=
name|NULL
expr_stmt|;
name|scb
operator|->
name|flags
operator|=
name|SCB_FLAG_NONE
expr_stmt|;
name|hscb
operator|->
name|control
operator|=
literal|0
expr_stmt|;
name|SLIST_INSERT_HEAD
argument_list|(
operator|&
name|ahc
operator|->
name|scb_data
operator|->
name|free_scbs
argument_list|,
name|scb
argument_list|,
name|links
operator|.
name|sle
argument_list|)
expr_stmt|;
comment|/* Notify the OSM that a resource is now available. */
name|aic_platform_scb_free
argument_list|(
name|ahc
argument_list|,
name|scb
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
specifier|static
name|__inline
expr|struct
name|scb
operator|*
name|ahc_lookup_scb
argument_list|(
argument|struct ahc_softc *ahc
argument_list|,
argument|u_int tag
argument_list|)
block|{ 	struct
name|scb
operator|*
name|scb
block|;
name|scb
operator|=
name|ahc
operator|->
name|scb_data
operator|->
name|scbindex
index|[
name|tag
index|]
block|;
if|if
condition|(
name|scb
operator|!=
name|NULL
condition|)
name|ahc_sync_scb
argument_list|(
name|ahc
argument_list|,
name|scb
argument_list|,
name|BUS_DMASYNC_POSTREAD
operator||
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
operator|(
name|scb
operator|)
return|;
end_return

begin_function
unit|}  static
name|__inline
name|void
name|ahc_swap_with_next_hscb
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|struct
name|scb
modifier|*
name|scb
parameter_list|)
block|{
name|struct
name|hardware_scb
modifier|*
name|q_hscb
decl_stmt|;
name|u_int
name|saved_tag
decl_stmt|;
comment|/* 	 * Our queuing method is a bit tricky.  The card 	 * knows in advance which HSCB to download, and we 	 * can't disappoint it.  To achieve this, the next 	 * SCB to download is saved off in ahc->next_queued_scb. 	 * When we are called to queue "an arbitrary scb", 	 * we copy the contents of the incoming HSCB to the one 	 * the sequencer knows about, swap HSCB pointers and 	 * finally assign the SCB to the tag indexed location 	 * in the scb_array.  This makes sure that we can still 	 * locate the correct SCB by SCB_TAG. 	 */
name|q_hscb
operator|=
name|ahc
operator|->
name|next_queued_scb
operator|->
name|hscb
expr_stmt|;
name|saved_tag
operator|=
name|q_hscb
operator|->
name|tag
expr_stmt|;
name|memcpy
argument_list|(
name|q_hscb
argument_list|,
name|scb
operator|->
name|hscb
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|scb
operator|->
name|hscb
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|scb
operator|->
name|flags
operator|&
name|SCB_CDB32_PTR
operator|)
operator|!=
literal|0
condition|)
block|{
name|q_hscb
operator|->
name|shared_data
operator|.
name|cdb_ptr
operator|=
name|aic_htole32
argument_list|(
name|ahc_hscb_busaddr
argument_list|(
name|ahc
argument_list|,
name|q_hscb
operator|->
name|tag
argument_list|)
operator|+
name|offsetof
argument_list|(
expr|struct
name|hardware_scb
argument_list|,
name|cdb32
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|q_hscb
operator|->
name|tag
operator|=
name|saved_tag
expr_stmt|;
name|q_hscb
operator|->
name|next
operator|=
name|scb
operator|->
name|hscb
operator|->
name|tag
expr_stmt|;
comment|/* Now swap HSCB pointers. */
name|ahc
operator|->
name|next_queued_scb
operator|->
name|hscb
operator|=
name|scb
operator|->
name|hscb
expr_stmt|;
name|scb
operator|->
name|hscb
operator|=
name|q_hscb
expr_stmt|;
comment|/* Now define the mapping from tag to SCB in the scbindex */
name|ahc
operator|->
name|scb_data
operator|->
name|scbindex
index|[
name|scb
operator|->
name|hscb
operator|->
name|tag
index|]
operator|=
name|scb
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Tell the sequencer about a new transaction to execute.  */
end_comment

begin_function
specifier|static
name|__inline
name|void
name|ahc_queue_scb
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|struct
name|scb
modifier|*
name|scb
parameter_list|)
block|{
name|ahc_swap_with_next_hscb
argument_list|(
name|ahc
argument_list|,
name|scb
argument_list|)
expr_stmt|;
if|if
condition|(
name|scb
operator|->
name|hscb
operator|->
name|tag
operator|==
name|SCB_LIST_NULL
operator|||
name|scb
operator|->
name|hscb
operator|->
name|next
operator|==
name|SCB_LIST_NULL
condition|)
name|panic
argument_list|(
literal|"Attempt to queue invalid SCB tag %x:%x\n"
argument_list|,
name|scb
operator|->
name|hscb
operator|->
name|tag
argument_list|,
name|scb
operator|->
name|hscb
operator|->
name|next
argument_list|)
expr_stmt|;
comment|/* 	 * Setup data "oddness". 	 */
name|scb
operator|->
name|hscb
operator|->
name|lun
operator|&=
name|LID
expr_stmt|;
if|if
condition|(
name|aic_get_transfer_length
argument_list|(
name|scb
argument_list|)
operator|&
literal|0x1
condition|)
name|scb
operator|->
name|hscb
operator|->
name|lun
operator||=
name|SCB_XFERLEN_ODD
expr_stmt|;
comment|/* 	 * Keep a history of SCBs we've downloaded in the qinfifo. 	 */
name|ahc
operator|->
name|qinfifo
index|[
name|ahc
operator|->
name|qinfifonext
operator|++
index|]
operator|=
name|scb
operator|->
name|hscb
operator|->
name|tag
expr_stmt|;
comment|/* 	 * Make sure our data is consistent from the 	 * perspective of the adapter. 	 */
name|ahc_sync_scb
argument_list|(
name|ahc
argument_list|,
name|scb
argument_list|,
name|BUS_DMASYNC_PREREAD
operator||
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
comment|/* Tell the adapter about the newly queued SCB */
if|if
condition|(
operator|(
name|ahc
operator|->
name|features
operator|&
name|AHC_QUEUE_REGS
operator|)
operator|!=
literal|0
condition|)
block|{
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|HNSCB_QOFF
argument_list|,
name|ahc
operator|->
name|qinfifonext
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|ahc
operator|->
name|features
operator|&
name|AHC_AUTOPAUSE
operator|)
operator|==
literal|0
condition|)
name|ahc_pause
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|KERNEL_QINPOS
argument_list|,
name|ahc
operator|->
name|qinfifonext
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ahc
operator|->
name|features
operator|&
name|AHC_AUTOPAUSE
operator|)
operator|==
literal|0
condition|)
name|ahc_unpause
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_expr_stmt
specifier|static
name|__inline
expr|struct
name|scsi_sense_data
operator|*
name|ahc_get_sense_buf
argument_list|(
argument|struct ahc_softc *ahc
argument_list|,
argument|struct scb *scb
argument_list|)
block|{
name|int
name|offset
block|;
name|offset
operator|=
name|scb
operator|-
name|ahc
operator|->
name|scb_data
operator|->
name|scbarray
block|;
return|return
operator|(
operator|&
name|ahc
operator|->
name|scb_data
operator|->
name|sense
index|[
name|offset
index|]
operator|)
return|;
block|}
end_expr_stmt

begin_function
specifier|static
name|__inline
name|uint32_t
name|ahc_get_sense_bufaddr
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|struct
name|scb
modifier|*
name|scb
parameter_list|)
block|{
name|int
name|offset
decl_stmt|;
name|offset
operator|=
name|scb
operator|-
name|ahc
operator|->
name|scb_data
operator|->
name|scbarray
expr_stmt|;
return|return
operator|(
name|ahc
operator|->
name|scb_data
operator|->
name|sense_busaddr
operator|+
operator|(
name|offset
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_sense_data
argument_list|)
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/************************** Interrupt Processing ******************************/
end_comment

begin_function_decl
specifier|static
name|__inline
name|void
name|ahc_sync_qoutfifo
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|int
name|op
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__inline
name|void
name|ahc_sync_tqinfifo
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|int
name|op
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__inline
name|u_int
name|ahc_check_cmdcmpltqueues
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__inline
name|int
name|ahc_intr
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|__inline
name|void
name|ahc_sync_qoutfifo
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|int
name|op
parameter_list|)
block|{
name|aic_dmamap_sync
argument_list|(
name|ahc
argument_list|,
name|ahc
operator|->
name|shared_data_dmat
argument_list|,
name|ahc
operator|->
name|shared_data_dmamap
argument_list|,
comment|/*offset*/
literal|0
argument_list|,
comment|/*len*/
literal|256
argument_list|,
name|op
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|ahc_sync_tqinfifo
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|int
name|op
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|AHC_TARGET_MODE
if|if
condition|(
operator|(
name|ahc
operator|->
name|flags
operator|&
name|AHC_TARGETROLE
operator|)
operator|!=
literal|0
condition|)
block|{
name|aic_dmamap_sync
argument_list|(
name|ahc
argument_list|,
name|ahc
operator|->
name|shared_data_dmat
argument_list|,
name|ahc
operator|->
name|shared_data_dmamap
argument_list|,
name|ahc_targetcmd_offset
argument_list|(
name|ahc
argument_list|,
literal|0
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|target_cmd
argument_list|)
operator|*
name|AHC_TMODE_CMDS
argument_list|,
name|op
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * See if the firmware has posted any completed commands  * into our in-core command complete fifos.  */
end_comment

begin_define
define|#
directive|define
name|AHC_RUN_QOUTFIFO
value|0x1
end_define

begin_define
define|#
directive|define
name|AHC_RUN_TQINFIFO
value|0x2
end_define

begin_function
specifier|static
name|__inline
name|u_int
name|ahc_check_cmdcmpltqueues
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|)
block|{
name|u_int
name|retval
decl_stmt|;
name|retval
operator|=
literal|0
expr_stmt|;
name|aic_dmamap_sync
argument_list|(
name|ahc
argument_list|,
name|ahc
operator|->
name|shared_data_dmat
argument_list|,
name|ahc
operator|->
name|shared_data_dmamap
argument_list|,
comment|/*offset*/
name|ahc
operator|->
name|qoutfifonext
argument_list|,
comment|/*len*/
literal|1
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
if|if
condition|(
name|ahc
operator|->
name|qoutfifo
index|[
name|ahc
operator|->
name|qoutfifonext
index|]
operator|!=
name|SCB_LIST_NULL
condition|)
name|retval
operator||=
name|AHC_RUN_QOUTFIFO
expr_stmt|;
ifdef|#
directive|ifdef
name|AHC_TARGET_MODE
if|if
condition|(
operator|(
name|ahc
operator|->
name|flags
operator|&
name|AHC_TARGETROLE
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|ahc
operator|->
name|flags
operator|&
name|AHC_TQINFIFO_BLOCKED
operator|)
operator|==
literal|0
condition|)
block|{
name|aic_dmamap_sync
argument_list|(
name|ahc
argument_list|,
name|ahc
operator|->
name|shared_data_dmat
argument_list|,
name|ahc
operator|->
name|shared_data_dmamap
argument_list|,
name|ahc_targetcmd_offset
argument_list|(
name|ahc
argument_list|,
name|ahc
operator|->
name|tqinfifofnext
argument_list|)
argument_list|,
comment|/*len*/
sizeof|sizeof
argument_list|(
expr|struct
name|target_cmd
argument_list|)
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
if|if
condition|(
name|ahc
operator|->
name|targetcmds
index|[
name|ahc
operator|->
name|tqinfifonext
index|]
operator|.
name|cmd_valid
operator|!=
literal|0
condition|)
name|retval
operator||=
name|AHC_RUN_TQINFIFO
expr_stmt|;
block|}
endif|#
directive|endif
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Catch an interrupt from the adapter  */
end_comment

begin_function
specifier|static
name|__inline
name|int
name|ahc_intr
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|)
block|{
name|u_int
name|intstat
decl_stmt|;
if|if
condition|(
operator|(
name|ahc
operator|->
name|pause
operator|&
name|INTEN
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 		 * Our interrupt is not enabled on the chip 		 * and may be disabled for re-entrancy reasons, 		 * so just return.  This is likely just a shared 		 * interrupt. 		 */
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * Instead of directly reading the interrupt status register, 	 * infer the cause of the interrupt by checking our in-core 	 * completion queues.  This avoids a costly PCI bus read in 	 * most cases. 	 */
if|if
condition|(
operator|(
name|ahc
operator|->
name|flags
operator|&
operator|(
name|AHC_ALL_INTERRUPTS
operator||
name|AHC_EDGE_INTERRUPT
operator|)
operator|)
operator|==
literal|0
operator|&&
operator|(
name|ahc_check_cmdcmpltqueues
argument_list|(
name|ahc
argument_list|)
operator|!=
literal|0
operator|)
condition|)
name|intstat
operator|=
name|CMDCMPLT
expr_stmt|;
else|else
block|{
name|intstat
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|INTSTAT
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|intstat
operator|&
name|INT_PEND
operator|)
operator|==
literal|0
condition|)
block|{
if|#
directive|if
name|AIC_PCI_CONFIG
operator|>
literal|0
if|if
condition|(
name|ahc
operator|->
name|unsolicited_ints
operator|>
literal|500
condition|)
block|{
name|ahc
operator|->
name|unsolicited_ints
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|ahc
operator|->
name|chip
operator|&
name|AHC_PCI
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|ERROR
argument_list|)
operator|&
name|PCIERRSTAT
operator|)
operator|!=
literal|0
condition|)
name|ahc
operator|->
name|bus_intr
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|ahc
operator|->
name|unsolicited_ints
operator|++
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|ahc
operator|->
name|unsolicited_ints
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|intstat
operator|&
name|CMDCMPLT
condition|)
block|{
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|CLRINT
argument_list|,
name|CLRCMDINT
argument_list|)
expr_stmt|;
comment|/* 		 * Ensure that the chip sees that we've cleared 		 * this interrupt before we walk the output fifo. 		 * Otherwise, we may, due to posted bus writes, 		 * clear the interrupt after we finish the scan, 		 * and after the sequencer has added new entries 		 * and asserted the interrupt again. 		 */
name|ahc_flush_device_writes
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
name|ahc_run_qoutfifo
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|AHC_TARGET_MODE
if|if
condition|(
operator|(
name|ahc
operator|->
name|flags
operator|&
name|AHC_TARGETROLE
operator|)
operator|!=
literal|0
condition|)
name|ahc_run_tqinfifo
argument_list|(
name|ahc
argument_list|,
comment|/*paused*/
name|FALSE
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* 	 * Handle statuses that may invalidate our cached 	 * copy of INTSTAT separately. 	 */
if|if
condition|(
name|intstat
operator|==
literal|0xFF
operator|&&
operator|(
name|ahc
operator|->
name|features
operator|&
name|AHC_REMOVABLE
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* Hot eject.  Do nothing */
block|}
elseif|else
if|if
condition|(
name|intstat
operator|&
name|BRKADRINT
condition|)
block|{
name|ahc_handle_brkadrint
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|intstat
operator|&
operator|(
name|SEQINT
operator||
name|SCSIINT
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|ahc_pause_bug_fix
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|intstat
operator|&
name|SEQINT
operator|)
operator|!=
literal|0
condition|)
name|ahc_handle_seqint
argument_list|(
name|ahc
argument_list|,
name|intstat
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|intstat
operator|&
name|SCSIINT
operator|)
operator|!=
literal|0
condition|)
name|ahc_handle_scsiint
argument_list|(
name|ahc
argument_list|,
name|intstat
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* _AIC7XXX_INLINE_H_ */
end_comment

end_unit

