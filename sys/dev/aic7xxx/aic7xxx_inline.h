begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Inline routines shareable across OS platforms.  *  * Copyright (c) 1994-2001 Justin T. Gibbs.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions, and the following disclaimer,  *    without modification.  * 2. The name of the author may not be used to endorse or promote products  *    derived from this software without specific prior written permission.  *  * Alternatively, this software may be distributed under the terms of the  * GNU Public License ("GPL").  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE FOR  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $Id: //depot/src/aic7xxx/aic7xxx_inline.h#19 $  *  * $FreeBSD$  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|_AIC7XXX_INLINE_H_
end_ifndef

begin_define
define|#
directive|define
name|_AIC7XXX_INLINE_H_
end_define

begin_comment
comment|/************************* Sequencer Execution Control ************************/
end_comment

begin_function_decl
specifier|static
name|__inline
name|int
name|ahc_is_paused
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__inline
name|void
name|ahc_pause_bug_fix
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__inline
name|void
name|ahc_pause
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__inline
name|void
name|ahc_unpause
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Work around any chip bugs related to halting sequencer execution.  * On Ultra2 controllers, we must clear the CIOBUS stretch signal by  * reading a register that will set this signal and deassert it.  * Without this workaround, if the chip is paused, by an interrupt or  * manual pause while accessing scb ram, accesses to certain registers  * will hang the system (infinite pci retries).  */
end_comment

begin_function
specifier|static
name|__inline
name|void
name|ahc_pause_bug_fix
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|)
block|{
if|if
condition|(
operator|(
name|ahc
operator|->
name|features
operator|&
name|AHC_ULTRA2
operator|)
operator|!=
literal|0
condition|)
operator|(
name|void
operator|)
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|CCSCBCTL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Determine whether the sequencer has halted code execution.  * Returns non-zero status if the sequencer is stopped.  */
end_comment

begin_function
specifier|static
name|__inline
name|int
name|ahc_is_paused
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|)
block|{
return|return
operator|(
operator|(
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|HCNTRL
argument_list|)
operator|&
name|PAUSE
operator|)
operator|!=
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Request that the sequencer stop and wait, indefinitely, for it  * to stop.  The sequencer will only acknowledge that it is paused  * once it has reached an instruction boundary and PAUSEDIS is  * cleared in the SEQCTL register.  The sequencer may use PAUSEDIS  * for critical sections.  */
end_comment

begin_function
specifier|static
name|__inline
name|void
name|ahc_pause
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|)
block|{
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|HCNTRL
argument_list|,
name|ahc
operator|->
name|pause
argument_list|)
expr_stmt|;
comment|/* 	 * Since the sequencer can disable pausing in a critical section, we 	 * must loop until it actually stops. 	 */
while|while
condition|(
name|ahc_is_paused
argument_list|(
name|ahc
argument_list|)
operator|==
literal|0
condition|)
empty_stmt|;
name|ahc_pause_bug_fix
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Allow the sequencer to continue program execution.  * We check here to ensure that no additional interrupt  * sources that would cause the sequencer to halt have been  * asserted.  If, for example, a SCSI bus reset is detected  * while we are fielding a different, pausing, interrupt type,  * we don't want to release the sequencer before going back  * into our interrupt handler and dealing with this new  * condition.  */
end_comment

begin_function
specifier|static
name|__inline
name|void
name|ahc_unpause
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|)
block|{
if|if
condition|(
operator|(
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|INTSTAT
argument_list|)
operator|&
operator|(
name|SCSIINT
operator||
name|SEQINT
operator||
name|BRKADRINT
operator|)
operator|)
operator|==
literal|0
condition|)
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|HCNTRL
argument_list|,
name|ahc
operator|->
name|unpause
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*********************** Untagged Transaction Routines ************************/
end_comment

begin_function_decl
specifier|static
name|__inline
name|void
name|ahc_freeze_untagged_queues
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__inline
name|void
name|ahc_release_untagged_queues
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Block our completion routine from starting the next untagged  * transaction for this target or target lun.  */
end_comment

begin_function
specifier|static
name|__inline
name|void
name|ahc_freeze_untagged_queues
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|)
block|{
if|if
condition|(
operator|(
name|ahc
operator|->
name|flags
operator|&
name|AHC_SCB_BTT
operator|)
operator|==
literal|0
condition|)
name|ahc
operator|->
name|untagged_queue_lock
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Allow the next untagged transaction for this target or target lun  * to be executed.  We use a counting semaphore to allow the lock  * to be acquired recursively.  Once the count drops to zero, the  * transaction queues will be run.  */
end_comment

begin_function
specifier|static
name|__inline
name|void
name|ahc_release_untagged_queues
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|)
block|{
if|if
condition|(
operator|(
name|ahc
operator|->
name|flags
operator|&
name|AHC_SCB_BTT
operator|)
operator|==
literal|0
condition|)
block|{
name|ahc
operator|->
name|untagged_queue_lock
operator|--
expr_stmt|;
if|if
condition|(
name|ahc
operator|->
name|untagged_queue_lock
operator|==
literal|0
condition|)
name|ahc_run_untagged_queues
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/************************** Memory mapping routines ***************************/
end_comment

begin_expr_stmt
specifier|static
name|__inline
expr|struct
name|ahc_dma_seg
operator|*
name|ahc_sg_bus_to_virt
argument_list|(
argument|struct scb *scb
argument_list|,
argument|uint32_t sg_busaddr
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function_decl
specifier|static
name|__inline
name|uint32_t
name|ahc_sg_virt_to_bus
parameter_list|(
name|struct
name|scb
modifier|*
name|scb
parameter_list|,
name|struct
name|ahc_dma_seg
modifier|*
name|sg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__inline
name|uint32_t
name|ahc_hscb_busaddr
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|u_int
name|index
parameter_list|)
function_decl|;
end_function_decl

begin_expr_stmt
specifier|static
name|__inline
expr|struct
name|ahc_dma_seg
operator|*
name|ahc_sg_bus_to_virt
argument_list|(
argument|struct scb *scb
argument_list|,
argument|uint32_t sg_busaddr
argument_list|)
block|{
name|int
name|sg_index
block|;
name|sg_index
operator|=
operator|(
name|sg_busaddr
operator|-
name|scb
operator|->
name|sg_list_phys
operator|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|ahc_dma_seg
argument_list|)
block|;
comment|/* sg_list_phys points to entry 1, not 0 */
name|sg_index
operator|++
block|;
return|return
operator|(
operator|&
name|scb
operator|->
name|sg_list
index|[
name|sg_index
index|]
operator|)
return|;
block|}
end_expr_stmt

begin_function
specifier|static
name|__inline
name|uint32_t
name|ahc_sg_virt_to_bus
parameter_list|(
name|struct
name|scb
modifier|*
name|scb
parameter_list|,
name|struct
name|ahc_dma_seg
modifier|*
name|sg
parameter_list|)
block|{
name|int
name|sg_index
decl_stmt|;
comment|/* sg_list_phys points to entry 1, not 0 */
name|sg_index
operator|=
name|sg
operator|-
operator|&
name|scb
operator|->
name|sg_list
index|[
literal|1
index|]
expr_stmt|;
return|return
operator|(
name|scb
operator|->
name|sg_list_phys
operator|+
operator|(
name|sg_index
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|scb
operator|->
name|sg_list
argument_list|)
operator|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|uint32_t
name|ahc_hscb_busaddr
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|u_int
name|index
parameter_list|)
block|{
return|return
operator|(
name|ahc
operator|->
name|scb_data
operator|->
name|hscb_busaddr
operator|+
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|hardware_scb
argument_list|)
operator|*
name|index
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/******************************** Debugging ***********************************/
end_comment

begin_function_decl
specifier|static
name|__inline
name|char
modifier|*
name|ahc_name
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|__inline
name|char
modifier|*
name|ahc_name
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|)
block|{
return|return
operator|(
name|ahc
operator|->
name|name
operator|)
return|;
block|}
end_function

begin_comment
comment|/*********************** Miscelaneous Support Functions ***********************/
end_comment

begin_function_decl
specifier|static
name|__inline
name|int
name|ahc_check_residual
parameter_list|(
name|struct
name|scb
modifier|*
name|scb
parameter_list|)
function_decl|;
end_function_decl

begin_expr_stmt
specifier|static
name|__inline
expr|struct
name|ahc_initiator_tinfo
operator|*
name|ahc_fetch_transinfo
argument_list|(
argument|struct ahc_softc *ahc
argument_list|,
argument|char channel
argument_list|,
argument|u_int our_id
argument_list|,
argument|u_int remote_id
argument_list|,
argument|struct ahc_tmode_tstate **tstate
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|__inline
expr|struct
name|scb
operator|*
name|ahc_get_scb
argument_list|(
expr|struct
name|ahc_softc
operator|*
name|ahc
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function_decl
specifier|static
name|__inline
name|void
name|ahc_free_scb
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|struct
name|scb
modifier|*
name|scb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__inline
name|void
name|ahc_swap_with_next_hscb
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|struct
name|scb
modifier|*
name|scb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__inline
name|void
name|ahc_queue_scb
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|struct
name|scb
modifier|*
name|scb
parameter_list|)
function_decl|;
end_function_decl

begin_expr_stmt
specifier|static
name|__inline
expr|struct
name|scsi_sense_data
operator|*
name|ahc_get_sense_buf
argument_list|(
expr|struct
name|ahc_softc
operator|*
name|ahc
argument_list|,
expr|struct
name|scb
operator|*
name|scb
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function_decl
specifier|static
name|__inline
name|uint32_t
name|ahc_get_sense_bufaddr
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|struct
name|scb
modifier|*
name|scb
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Determine whether the sequencer reported a residual  * for this SCB/transaction.  */
end_comment

begin_function
specifier|static
name|__inline
name|int
name|ahc_check_residual
parameter_list|(
name|struct
name|scb
modifier|*
name|scb
parameter_list|)
block|{
name|struct
name|status_pkt
modifier|*
name|sp
decl_stmt|;
name|sp
operator|=
operator|&
name|scb
operator|->
name|hscb
operator|->
name|shared_data
operator|.
name|status
expr_stmt|;
if|if
condition|(
operator|(
name|scb
operator|->
name|hscb
operator|->
name|sgptr
operator|&
name|SG_RESID_VALID
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return pointers to the transfer negotiation information  * for the specified our_id/remote_id pair.  */
end_comment

begin_expr_stmt
specifier|static
name|__inline
expr|struct
name|ahc_initiator_tinfo
operator|*
name|ahc_fetch_transinfo
argument_list|(
argument|struct ahc_softc *ahc
argument_list|,
argument|char channel
argument_list|,
argument|u_int our_id
argument_list|,
argument|u_int remote_id
argument_list|,
argument|struct ahc_tmode_tstate **tstate
argument_list|)
block|{
comment|/* 	 * Transfer data structures are stored from the perspective 	 * of the target role.  Since the parameters for a connection 	 * in the initiator role to a given target are the same as 	 * when the roles are reversed, we pretend we are the target. 	 */
if|if
condition|(
name|channel
operator|==
literal|'B'
condition|)
name|our_id
operator|+=
literal|8
expr_stmt|;
operator|*
name|tstate
operator|=
name|ahc
operator|->
name|enabled_targets
index|[
name|our_id
index|]
expr_stmt|;
end_expr_stmt

begin_return
return|return
operator|(
operator|&
operator|(
operator|*
name|tstate
operator|)
operator|->
name|transinfo
index|[
name|remote_id
index|]
operator|)
return|;
end_return

begin_comment
unit|}
comment|/*  * Get a free scb. If there are none, see if we can allocate a new SCB.  */
end_comment

begin_function
unit|static
name|__inline
name|struct
name|scb
modifier|*
name|ahc_get_scb
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|)
block|{
name|struct
name|scb
modifier|*
name|scb
decl_stmt|;
if|if
condition|(
operator|(
name|scb
operator|=
name|SLIST_FIRST
argument_list|(
operator|&
name|ahc
operator|->
name|scb_data
operator|->
name|free_scbs
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|ahc_alloc_scbs
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
name|scb
operator|=
name|SLIST_FIRST
argument_list|(
operator|&
name|ahc
operator|->
name|scb_data
operator|->
name|free_scbs
argument_list|)
expr_stmt|;
if|if
condition|(
name|scb
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|SLIST_REMOVE_HEAD
argument_list|(
operator|&
name|ahc
operator|->
name|scb_data
operator|->
name|free_scbs
argument_list|,
name|links
operator|.
name|sle
argument_list|)
expr_stmt|;
return|return
operator|(
name|scb
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return an SCB resource to the free list.  */
end_comment

begin_function
specifier|static
name|__inline
name|void
name|ahc_free_scb
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|struct
name|scb
modifier|*
name|scb
parameter_list|)
block|{
name|struct
name|hardware_scb
modifier|*
name|hscb
decl_stmt|;
name|hscb
operator|=
name|scb
operator|->
name|hscb
expr_stmt|;
comment|/* Clean up for the next user */
name|ahc
operator|->
name|scb_data
operator|->
name|scbindex
index|[
name|hscb
operator|->
name|tag
index|]
operator|=
name|NULL
expr_stmt|;
name|scb
operator|->
name|flags
operator|=
name|SCB_FREE
expr_stmt|;
name|hscb
operator|->
name|control
operator|=
literal|0
expr_stmt|;
name|SLIST_INSERT_HEAD
argument_list|(
operator|&
name|ahc
operator|->
name|scb_data
operator|->
name|free_scbs
argument_list|,
name|scb
argument_list|,
name|links
operator|.
name|sle
argument_list|)
expr_stmt|;
comment|/* Notify the OSM that a resource is now available. */
name|ahc_platform_scb_free
argument_list|(
name|ahc
argument_list|,
name|scb
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
specifier|static
name|__inline
expr|struct
name|scb
operator|*
name|ahc_lookup_scb
argument_list|(
argument|struct ahc_softc *ahc
argument_list|,
argument|u_int tag
argument_list|)
block|{
return|return
operator|(
name|ahc
operator|->
name|scb_data
operator|->
name|scbindex
index|[
name|tag
index|]
operator|)
return|;
block|}
end_expr_stmt

begin_function
specifier|static
name|__inline
name|void
name|ahc_swap_with_next_hscb
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|struct
name|scb
modifier|*
name|scb
parameter_list|)
block|{
name|struct
name|hardware_scb
modifier|*
name|q_hscb
decl_stmt|;
name|u_int
name|saved_tag
decl_stmt|;
comment|/* 	 * Our queuing method is a bit tricky.  The card 	 * knows in advance which HSCB to download, and we 	 * can't disappoint it.  To achieve this, the next 	 * SCB to download is saved off in ahc->next_queued_scb. 	 * When we are called to queue "an arbitrary scb", 	 * we copy the contents of the incoming HSCB to the one 	 * the sequencer knows about, swap HSCB pointers and 	 * finally assign the SCB to the tag indexed location 	 * in the scb_array.  This makes sure that we can still 	 * locate the correct SCB by SCB_TAG. 	 */
name|q_hscb
operator|=
name|ahc
operator|->
name|next_queued_scb
operator|->
name|hscb
expr_stmt|;
name|saved_tag
operator|=
name|q_hscb
operator|->
name|tag
expr_stmt|;
name|memcpy
argument_list|(
name|q_hscb
argument_list|,
name|scb
operator|->
name|hscb
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|scb
operator|->
name|hscb
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|scb
operator|->
name|flags
operator|&
name|SCB_CDB32_PTR
operator|)
operator|!=
literal|0
condition|)
block|{
name|q_hscb
operator|->
name|shared_data
operator|.
name|cdb_ptr
operator|=
name|ahc_hscb_busaddr
argument_list|(
name|ahc
argument_list|,
name|q_hscb
operator|->
name|tag
argument_list|)
operator|+
name|offsetof
argument_list|(
expr|struct
name|hardware_scb
argument_list|,
name|cdb32
argument_list|)
expr_stmt|;
block|}
name|q_hscb
operator|->
name|tag
operator|=
name|saved_tag
expr_stmt|;
name|q_hscb
operator|->
name|next
operator|=
name|scb
operator|->
name|hscb
operator|->
name|tag
expr_stmt|;
comment|/* Now swap HSCB pointers. */
name|ahc
operator|->
name|next_queued_scb
operator|->
name|hscb
operator|=
name|scb
operator|->
name|hscb
expr_stmt|;
name|scb
operator|->
name|hscb
operator|=
name|q_hscb
expr_stmt|;
comment|/* Now define the mapping from tag to SCB in the scbindex */
name|ahc
operator|->
name|scb_data
operator|->
name|scbindex
index|[
name|scb
operator|->
name|hscb
operator|->
name|tag
index|]
operator|=
name|scb
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Tell the sequencer about a new transaction to execute.  */
end_comment

begin_function
specifier|static
name|__inline
name|void
name|ahc_queue_scb
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|struct
name|scb
modifier|*
name|scb
parameter_list|)
block|{
name|ahc_swap_with_next_hscb
argument_list|(
name|ahc
argument_list|,
name|scb
argument_list|)
expr_stmt|;
if|if
condition|(
name|scb
operator|->
name|hscb
operator|->
name|tag
operator|==
name|SCB_LIST_NULL
operator|||
name|scb
operator|->
name|hscb
operator|->
name|next
operator|==
name|SCB_LIST_NULL
condition|)
name|panic
argument_list|(
literal|"Attempt to queue invalid SCB tag %x:%x\n"
argument_list|,
name|scb
operator|->
name|hscb
operator|->
name|tag
argument_list|,
name|scb
operator|->
name|hscb
operator|->
name|next
argument_list|)
expr_stmt|;
comment|/* 	 * Keep a history of SCBs we've downloaded in the qinfifo. 	 */
name|ahc
operator|->
name|qinfifo
index|[
name|ahc
operator|->
name|qinfifonext
operator|++
index|]
operator|=
name|scb
operator|->
name|hscb
operator|->
name|tag
expr_stmt|;
if|if
condition|(
operator|(
name|ahc
operator|->
name|features
operator|&
name|AHC_QUEUE_REGS
operator|)
operator|!=
literal|0
condition|)
block|{
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|HNSCB_QOFF
argument_list|,
name|ahc
operator|->
name|qinfifonext
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|ahc
operator|->
name|features
operator|&
name|AHC_AUTOPAUSE
operator|)
operator|==
literal|0
condition|)
name|ahc_pause
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|KERNEL_QINPOS
argument_list|,
name|ahc
operator|->
name|qinfifonext
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ahc
operator|->
name|features
operator|&
name|AHC_AUTOPAUSE
operator|)
operator|==
literal|0
condition|)
name|ahc_unpause
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_expr_stmt
specifier|static
name|__inline
expr|struct
name|scsi_sense_data
operator|*
name|ahc_get_sense_buf
argument_list|(
argument|struct ahc_softc *ahc
argument_list|,
argument|struct scb *scb
argument_list|)
block|{
name|int
name|offset
block|;
name|offset
operator|=
name|scb
operator|-
name|ahc
operator|->
name|scb_data
operator|->
name|scbarray
block|;
return|return
operator|(
operator|&
name|ahc
operator|->
name|scb_data
operator|->
name|sense
index|[
name|offset
index|]
operator|)
return|;
block|}
end_expr_stmt

begin_function
specifier|static
name|__inline
name|uint32_t
name|ahc_get_sense_bufaddr
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|struct
name|scb
modifier|*
name|scb
parameter_list|)
block|{
name|int
name|offset
decl_stmt|;
name|offset
operator|=
name|scb
operator|-
name|ahc
operator|->
name|scb_data
operator|->
name|scbarray
expr_stmt|;
return|return
operator|(
name|ahc
operator|->
name|scb_data
operator|->
name|sense_busaddr
operator|+
operator|(
name|offset
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_sense_data
argument_list|)
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/************************** Interrupt Processing ******************************/
end_comment

begin_function_decl
specifier|static
name|__inline
name|u_int
name|ahc_check_cmdcmpltqueues
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__inline
name|void
name|ahc_intr
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * See if the firmware has posted any completed commands  * into our in-core command complete fifos.  */
end_comment

begin_define
define|#
directive|define
name|AHC_RUN_QOUTFIFO
value|0x1
end_define

begin_define
define|#
directive|define
name|AHC_RUN_TQINFIFO
value|0x2
end_define

begin_function
specifier|static
name|__inline
name|u_int
name|ahc_check_cmdcmpltqueues
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|)
block|{
name|u_int
name|retval
decl_stmt|;
name|retval
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ahc
operator|->
name|qoutfifo
index|[
name|ahc
operator|->
name|qoutfifonext
index|]
operator|!=
name|SCB_LIST_NULL
condition|)
name|retval
operator||=
name|AHC_RUN_QOUTFIFO
expr_stmt|;
ifdef|#
directive|ifdef
name|AHC_TARGET_MODE
if|if
condition|(
operator|(
name|ahc
operator|->
name|flags
operator|&
name|AHC_TARGETROLE
operator|)
operator|!=
literal|0
operator|&&
name|ahc
operator|->
name|targetcmds
index|[
name|ahc
operator|->
name|tqinfifonext
index|]
operator|.
name|cmd_valid
operator|!=
literal|0
condition|)
name|retval
operator||=
name|AHC_RUN_TQINFIFO
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Catch an interrupt from the adapter  */
end_comment

begin_function
specifier|static
name|__inline
name|void
name|ahc_intr
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|)
block|{
name|u_int
name|intstat
decl_stmt|;
name|u_int
name|queuestat
decl_stmt|;
comment|/* 	 * Instead of directly reading the interrupt status register, 	 * infer the cause of the interrupt by checking our in-core 	 * completion queues.  This avoids a costly PCI bus read in 	 * most cases. 	 */
if|if
condition|(
operator|(
name|ahc
operator|->
name|flags
operator|&
operator|(
name|AHC_ALL_INTERRUPTS
operator||
name|AHC_EDGE_INTERRUPT
operator|)
operator|)
operator|==
literal|0
operator|&&
operator|(
name|queuestat
operator|=
name|ahc_check_cmdcmpltqueues
argument_list|(
name|ahc
argument_list|)
operator|)
operator|!=
literal|0
condition|)
name|intstat
operator|=
name|CMDCMPLT
expr_stmt|;
else|else
block|{
name|intstat
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|INTSTAT
argument_list|)
expr_stmt|;
comment|/* 		 * We can't generate queuestat once above 		 * or we are exposed to a race when our 		 * interrupt is shared with another device. 		 * if instat showed a command complete interrupt, 		 * but our first generation of queue stat 		 * "just missed" the delivery of this transaction, 		 * we would clear the command complete interrupt 		 * below without ever servicing the completed 		 * command. 		 */
name|queuestat
operator|=
name|ahc_check_cmdcmpltqueues
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
if|#
directive|if
name|AHC_PCI_CONFIG
operator|>
literal|0
if|if
condition|(
name|ahc
operator|->
name|unsolicited_ints
operator|>
literal|500
operator|&&
operator|(
name|ahc
operator|->
name|chip
operator|&
name|AHC_PCI
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|ERROR
argument_list|)
operator|&
name|PCIERRSTAT
operator|)
operator|!=
literal|0
condition|)
name|ahc
operator|->
name|bus_intr
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|intstat
operator|==
literal|0xFF
operator|&&
operator|(
name|ahc
operator|->
name|features
operator|&
name|AHC_REMOVABLE
operator|)
operator|!=
literal|0
condition|)
comment|/* Hot eject */
return|return;
if|if
condition|(
operator|(
name|intstat
operator|&
name|INT_PEND
operator|)
operator|==
literal|0
condition|)
block|{
name|ahc
operator|->
name|unsolicited_ints
operator|++
expr_stmt|;
return|return;
block|}
name|ahc
operator|->
name|unsolicited_ints
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|intstat
operator|&
name|CMDCMPLT
condition|)
block|{
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|CLRINT
argument_list|,
name|CLRCMDINT
argument_list|)
expr_stmt|;
comment|/* 		 * Ensure that the chip sees that we've cleared 		 * this interrupt before we walk the output fifo. 		 * Otherwise, we may, due to posted bus writes, 		 * clear the interrupt after we finish the scan, 		 * and after the sequencer has added new entries 		 * and asserted the interrupt again. 		 */
name|ahc_flush_device_writes
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|AHC_TARGET_MODE
if|if
condition|(
operator|(
name|queuestat
operator|&
name|AHC_RUN_QOUTFIFO
operator|)
operator|!=
literal|0
condition|)
endif|#
directive|endif
name|ahc_run_qoutfifo
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|AHC_TARGET_MODE
if|if
condition|(
operator|(
name|queuestat
operator|&
name|AHC_RUN_TQINFIFO
operator|)
operator|!=
literal|0
condition|)
name|ahc_run_tqinfifo
argument_list|(
name|ahc
argument_list|,
comment|/*paused*/
name|FALSE
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|intstat
operator|&
name|BRKADRINT
condition|)
block|{
name|ahc_handle_brkadrint
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
comment|/* Fatal error, no more interrupts to handle. */
return|return;
block|}
if|if
condition|(
operator|(
name|intstat
operator|&
operator|(
name|SEQINT
operator||
name|SCSIINT
operator|)
operator|)
operator|!=
literal|0
condition|)
name|ahc_pause_bug_fix
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|intstat
operator|&
name|SEQINT
operator|)
operator|!=
literal|0
condition|)
name|ahc_handle_seqint
argument_list|(
name|ahc
argument_list|,
name|intstat
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|intstat
operator|&
name|SCSIINT
operator|)
operator|!=
literal|0
condition|)
name|ahc_handle_scsiint
argument_list|(
name|ahc
argument_list|,
name|intstat
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* _AIC7XXX_INLINE_H_ */
end_comment

end_unit

