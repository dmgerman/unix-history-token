begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2003-2005 Joseph Koshy  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Support for the AMD K7 and later processors */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/pmc.h>
end_include

begin_include
include|#
directive|include
file|<sys/smp.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<machine/cpufunc.h>
end_include

begin_include
include|#
directive|include
file|<machine/md_var.h>
end_include

begin_include
include|#
directive|include
file|<machine/pmc_mdep.h>
end_include

begin_include
include|#
directive|include
file|<machine/specialreg.h>
end_include

begin_if
if|#
directive|if
name|DEBUG
end_if

begin_decl_stmt
name|enum
name|pmc_class
name|amd_pmc_class
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* AMD K7& K8 PMCs */
end_comment

begin_struct
struct|struct
name|amd_descr
block|{
name|struct
name|pmc_descr
name|pm_descr
decl_stmt|;
comment|/* "base class" */
name|uint32_t
name|pm_evsel
decl_stmt|;
comment|/* address of EVSEL register */
name|uint32_t
name|pm_perfctr
decl_stmt|;
comment|/* address of PERFCTR register */
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|amd_descr
name|amd_pmcdesc
index|[
name|AMD_NPMCS
index|]
init|=
block|{
block|{
operator|.
name|pm_descr
operator|=
block|{
operator|.
name|pd_name
operator|=
literal|"TSC"
block|,
operator|.
name|pd_class
operator|=
name|PMC_CLASS_TSC
block|,
operator|.
name|pd_caps
operator|=
name|PMC_CAP_READ
block|,
operator|.
name|pd_width
operator|=
literal|64
block|}
block|,
operator|.
name|pm_evsel
operator|=
name|MSR_TSC
block|,
operator|.
name|pm_perfctr
operator|=
literal|0
comment|/* unused */
block|}
block|,
block|{
operator|.
name|pm_descr
operator|=
block|{
operator|.
name|pd_name
operator|=
literal|""
block|,
operator|.
name|pd_class
operator|=
operator|-
literal|1
block|,
operator|.
name|pd_caps
operator|=
name|AMD_PMC_CAPS
block|,
operator|.
name|pd_width
operator|=
literal|48
block|}
block|,
operator|.
name|pm_evsel
operator|=
name|AMD_PMC_EVSEL_0
block|,
operator|.
name|pm_perfctr
operator|=
name|AMD_PMC_PERFCTR_0
block|}
block|,
block|{
operator|.
name|pm_descr
operator|=
block|{
operator|.
name|pd_name
operator|=
literal|""
block|,
operator|.
name|pd_class
operator|=
operator|-
literal|1
block|,
operator|.
name|pd_caps
operator|=
name|AMD_PMC_CAPS
block|,
operator|.
name|pd_width
operator|=
literal|48
block|}
block|,
operator|.
name|pm_evsel
operator|=
name|AMD_PMC_EVSEL_1
block|,
operator|.
name|pm_perfctr
operator|=
name|AMD_PMC_PERFCTR_1
block|}
block|,
block|{
operator|.
name|pm_descr
operator|=
block|{
operator|.
name|pd_name
operator|=
literal|""
block|,
operator|.
name|pd_class
operator|=
operator|-
literal|1
block|,
operator|.
name|pd_caps
operator|=
name|AMD_PMC_CAPS
block|,
operator|.
name|pd_width
operator|=
literal|48
block|}
block|,
operator|.
name|pm_evsel
operator|=
name|AMD_PMC_EVSEL_2
block|,
operator|.
name|pm_perfctr
operator|=
name|AMD_PMC_PERFCTR_2
block|}
block|,
block|{
operator|.
name|pm_descr
operator|=
block|{
operator|.
name|pd_name
operator|=
literal|""
block|,
operator|.
name|pd_class
operator|=
operator|-
literal|1
block|,
operator|.
name|pd_caps
operator|=
name|AMD_PMC_CAPS
block|,
operator|.
name|pd_width
operator|=
literal|48
block|}
block|,
operator|.
name|pm_evsel
operator|=
name|AMD_PMC_EVSEL_3
block|,
operator|.
name|pm_perfctr
operator|=
name|AMD_PMC_PERFCTR_3
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|amd_event_code_map
block|{
name|enum
name|pmc_event
name|pe_ev
decl_stmt|;
comment|/* enum value */
name|uint8_t
name|pe_code
decl_stmt|;
comment|/* encoded event mask */
name|uint8_t
name|pe_mask
decl_stmt|;
comment|/* bits allowed in unit mask */
block|}
struct|;
end_struct

begin_decl_stmt
specifier|const
name|struct
name|amd_event_code_map
name|amd_event_codes
index|[]
init|=
block|{
if|#
directive|if
name|defined
argument_list|(
name|__i386__
argument_list|)
comment|/* 32 bit Athlon (K7) only */
block|{
name|PMC_EV_K7_DC_ACCESSES
block|,
literal|0x40
block|,
literal|0
block|}
block|,
block|{
name|PMC_EV_K7_DC_MISSES
block|,
literal|0x41
block|,
literal|0
block|}
block|,
block|{
name|PMC_EV_K7_DC_REFILLS_FROM_L2
block|,
literal|0x42
block|,
name|AMD_PMC_UNITMASK_MOESI
block|}
block|,
block|{
name|PMC_EV_K7_DC_REFILLS_FROM_SYSTEM
block|,
literal|0x43
block|,
name|AMD_PMC_UNITMASK_MOESI
block|}
block|,
block|{
name|PMC_EV_K7_DC_WRITEBACKS
block|,
literal|0x44
block|,
name|AMD_PMC_UNITMASK_MOESI
block|}
block|,
block|{
name|PMC_EV_K7_L1_DTLB_MISS_AND_L2_DTLB_HITS
block|,
literal|0x45
block|,
literal|0
block|}
block|,
block|{
name|PMC_EV_K7_L1_AND_L2_DTLB_MISSES
block|,
literal|0x46
block|,
literal|0
block|}
block|,
block|{
name|PMC_EV_K7_MISALIGNED_REFERENCES
block|,
literal|0x47
block|,
literal|0
block|}
block|,
block|{
name|PMC_EV_K7_IC_FETCHES
block|,
literal|0x80
block|,
literal|0
block|}
block|,
block|{
name|PMC_EV_K7_IC_MISSES
block|,
literal|0x81
block|,
literal|0
block|}
block|,
block|{
name|PMC_EV_K7_L1_ITLB_MISSES
block|,
literal|0x84
block|,
literal|0
block|}
block|,
block|{
name|PMC_EV_K7_L1_L2_ITLB_MISSES
block|,
literal|0x85
block|,
literal|0
block|}
block|,
block|{
name|PMC_EV_K7_RETIRED_INSTRUCTIONS
block|,
literal|0xC0
block|,
literal|0
block|}
block|,
block|{
name|PMC_EV_K7_RETIRED_OPS
block|,
literal|0xC1
block|,
literal|0
block|}
block|,
block|{
name|PMC_EV_K7_RETIRED_BRANCHES
block|,
literal|0xC2
block|,
literal|0
block|}
block|,
block|{
name|PMC_EV_K7_RETIRED_BRANCHES_MISPREDICTED
block|,
literal|0xC3
block|,
literal|0
block|}
block|,
block|{
name|PMC_EV_K7_RETIRED_TAKEN_BRANCHES
block|,
literal|0xC4
block|,
literal|0
block|}
block|,
block|{
name|PMC_EV_K7_RETIRED_TAKEN_BRANCHES_MISPREDICTED
block|,
literal|0xC5
block|,
literal|0
block|}
block|,
block|{
name|PMC_EV_K7_RETIRED_FAR_CONTROL_TRANSFERS
block|,
literal|0xC6
block|,
literal|0
block|}
block|,
block|{
name|PMC_EV_K7_RETIRED_RESYNC_BRANCHES
block|,
literal|0xC7
block|,
literal|0
block|}
block|,
block|{
name|PMC_EV_K7_INTERRUPTS_MASKED_CYCLES
block|,
literal|0xCD
block|,
literal|0
block|}
block|,
block|{
name|PMC_EV_K7_INTERRUPTS_MASKED_WHILE_PENDING_CYCLES
block|,
literal|0xCE
block|,
literal|0
block|}
block|,
block|{
name|PMC_EV_K7_HARDWARE_INTERRUPTS
block|,
literal|0xCF
block|,
literal|0
block|}
block|,
endif|#
directive|endif
block|{
name|PMC_EV_K8_FP_DISPATCHED_FPU_OPS
block|,
literal|0x00
block|,
literal|0x3F
block|}
block|,
block|{
name|PMC_EV_K8_FP_CYCLES_WITH_NO_FPU_OPS_RETIRED
block|,
literal|0x01
block|,
literal|0x00
block|}
block|,
block|{
name|PMC_EV_K8_FP_DISPATCHED_FPU_FAST_FLAG_OPS
block|,
literal|0x02
block|,
literal|0x00
block|}
block|,
block|{
name|PMC_EV_K8_LS_SEGMENT_REGISTER_LOAD
block|,
literal|0x20
block|,
literal|0x7F
block|}
block|,
block|{
name|PMC_EV_K8_LS_MICROARCHITECTURAL_RESYNC_BY_SELF_MODIFYING_CODE
block|,
literal|0x21
block|,
literal|0x00
block|}
block|,
block|{
name|PMC_EV_K8_LS_MICROARCHITECTURAL_RESYNC_BY_SNOOP
block|,
literal|0x22
block|,
literal|0x00
block|}
block|,
block|{
name|PMC_EV_K8_LS_BUFFER2_FULL
block|,
literal|0x23
block|,
literal|0x00
block|}
block|,
block|{
name|PMC_EV_K8_LS_LOCKED_OPERATION
block|,
literal|0x24
block|,
literal|0x07
block|}
block|,
block|{
name|PMC_EV_K8_LS_MICROARCHITECTURAL_LATE_CANCEL
block|,
literal|0x25
block|,
literal|0x00
block|}
block|,
block|{
name|PMC_EV_K8_LS_RETIRED_CFLUSH_INSTRUCTIONS
block|,
literal|0x26
block|,
literal|0x00
block|}
block|,
block|{
name|PMC_EV_K8_LS_RETIRED_CPUID_INSTRUCTIONS
block|,
literal|0x27
block|,
literal|0x00
block|}
block|,
block|{
name|PMC_EV_K8_DC_ACCESS
block|,
literal|0x40
block|,
literal|0x00
block|}
block|,
block|{
name|PMC_EV_K8_DC_MISS
block|,
literal|0x41
block|,
literal|0x00
block|}
block|,
block|{
name|PMC_EV_K8_DC_REFILL_FROM_L2
block|,
literal|0x42
block|,
literal|0x1F
block|}
block|,
block|{
name|PMC_EV_K8_DC_REFILL_FROM_SYSTEM
block|,
literal|0x43
block|,
literal|0x1F
block|}
block|,
block|{
name|PMC_EV_K8_DC_COPYBACK
block|,
literal|0x44
block|,
literal|0x1F
block|}
block|,
block|{
name|PMC_EV_K8_DC_L1_DTLB_MISS_AND_L2_DTLB_HIT
block|,
literal|0x45
block|,
literal|0x00
block|}
block|,
block|{
name|PMC_EV_K8_DC_L1_DTLB_MISS_AND_L2_DTLB_MISS
block|,
literal|0x46
block|,
literal|0x00
block|}
block|,
block|{
name|PMC_EV_K8_DC_MISALIGNED_DATA_REFERENCE
block|,
literal|0x47
block|,
literal|0x00
block|}
block|,
block|{
name|PMC_EV_K8_DC_MICROARCHITECTURAL_LATE_CANCEL
block|,
literal|0x48
block|,
literal|0x00
block|}
block|,
block|{
name|PMC_EV_K8_DC_MICROARCHITECTURAL_EARLY_CANCEL
block|,
literal|0x49
block|,
literal|0x00
block|}
block|,
block|{
name|PMC_EV_K8_DC_ONE_BIT_ECC_ERROR
block|,
literal|0x4A
block|,
literal|0x03
block|}
block|,
block|{
name|PMC_EV_K8_DC_DISPATCHED_PREFETCH_INSTRUCTIONS
block|,
literal|0x4B
block|,
literal|0x07
block|}
block|,
block|{
name|PMC_EV_K8_DC_DCACHE_ACCESSES_BY_LOCKS
block|,
literal|0x4C
block|,
literal|0x03
block|}
block|,
block|{
name|PMC_EV_K8_BU_CPU_CLK_UNHALTED
block|,
literal|0x76
block|,
literal|0x00
block|}
block|,
block|{
name|PMC_EV_K8_BU_INTERNAL_L2_REQUEST
block|,
literal|0x7D
block|,
literal|0x1F
block|}
block|,
block|{
name|PMC_EV_K8_BU_FILL_REQUEST_L2_MISS
block|,
literal|0x7E
block|,
literal|0x07
block|}
block|,
block|{
name|PMC_EV_K8_BU_FILL_INTO_L2
block|,
literal|0x7F
block|,
literal|0x03
block|}
block|,
block|{
name|PMC_EV_K8_IC_FETCH
block|,
literal|0x80
block|,
literal|0x00
block|}
block|,
block|{
name|PMC_EV_K8_IC_MISS
block|,
literal|0x81
block|,
literal|0x00
block|}
block|,
block|{
name|PMC_EV_K8_IC_REFILL_FROM_L2
block|,
literal|0x82
block|,
literal|0x00
block|}
block|,
block|{
name|PMC_EV_K8_IC_REFILL_FROM_SYSTEM
block|,
literal|0x83
block|,
literal|0x00
block|}
block|,
block|{
name|PMC_EV_K8_IC_L1_ITLB_MISS_AND_L2_ITLB_HIT
block|,
literal|0x84
block|,
literal|0x00
block|}
block|,
block|{
name|PMC_EV_K8_IC_L1_ITLB_MISS_AND_L2_ITLB_MISS
block|,
literal|0x85
block|,
literal|0x00
block|}
block|,
block|{
name|PMC_EV_K8_IC_MICROARCHITECTURAL_RESYNC_BY_SNOOP
block|,
literal|0x86
block|,
literal|0x00
block|}
block|,
block|{
name|PMC_EV_K8_IC_INSTRUCTION_FETCH_STALL
block|,
literal|0x87
block|,
literal|0x00
block|}
block|,
block|{
name|PMC_EV_K8_IC_RETURN_STACK_HIT
block|,
literal|0x88
block|,
literal|0x00
block|}
block|,
block|{
name|PMC_EV_K8_IC_RETURN_STACK_OVERFLOW
block|,
literal|0x89
block|,
literal|0x00
block|}
block|,
block|{
name|PMC_EV_K8_FR_RETIRED_X86_INSTRUCTIONS
block|,
literal|0xC0
block|,
literal|0x00
block|}
block|,
block|{
name|PMC_EV_K8_FR_RETIRED_UOPS
block|,
literal|0xC1
block|,
literal|0x00
block|}
block|,
block|{
name|PMC_EV_K8_FR_RETIRED_BRANCHES
block|,
literal|0xC2
block|,
literal|0x00
block|}
block|,
block|{
name|PMC_EV_K8_FR_RETIRED_BRANCHES_MISPREDICTED
block|,
literal|0xC3
block|,
literal|0x00
block|}
block|,
block|{
name|PMC_EV_K8_FR_RETIRED_TAKEN_BRANCHES
block|,
literal|0xC4
block|,
literal|0x00
block|}
block|,
block|{
name|PMC_EV_K8_FR_RETIRED_TAKEN_BRANCHES_MISPREDICTED
block|,
literal|0xC5
block|,
literal|0x00
block|}
block|,
block|{
name|PMC_EV_K8_FR_RETIRED_FAR_CONTROL_TRANSFERS
block|,
literal|0xC6
block|,
literal|0x00
block|}
block|,
block|{
name|PMC_EV_K8_FR_RETIRED_RESYNCS
block|,
literal|0xC7
block|,
literal|0x00
block|}
block|,
block|{
name|PMC_EV_K8_FR_RETIRED_NEAR_RETURNS
block|,
literal|0xC8
block|,
literal|0x00
block|}
block|,
block|{
name|PMC_EV_K8_FR_RETIRED_NEAR_RETURNS_MISPREDICTED
block|,
literal|0xC9
block|,
literal|0x00
block|}
block|,
block|{
name|PMC_EV_K8_FR_RETIRED_TAKEN_BRANCHES_MISPREDICTED_BY_ADDR_MISCOMPARE
block|,
literal|0xCA
block|,
literal|0x00
block|}
block|,
block|{
name|PMC_EV_K8_FR_RETIRED_FPU_INSTRUCTIONS
block|,
literal|0xCB
block|,
literal|0x0F
block|}
block|,
block|{
name|PMC_EV_K8_FR_RETIRED_FASTPATH_DOUBLE_OP_INSTRUCTIONS
block|,
literal|0xCC
block|,
literal|0x07
block|}
block|,
block|{
name|PMC_EV_K8_FR_INTERRUPTS_MASKED_CYCLES
block|,
literal|0xCD
block|,
literal|0x00
block|}
block|,
block|{
name|PMC_EV_K8_FR_INTERRUPTS_MASKED_WHILE_PENDING_CYCLES
block|,
literal|0xCE
block|,
literal|0x00
block|}
block|,
block|{
name|PMC_EV_K8_FR_TAKEN_HARDWARE_INTERRUPTS
block|,
literal|0xCF
block|,
literal|0x00
block|}
block|,
block|{
name|PMC_EV_K8_FR_DECODER_EMPTY
block|,
literal|0xD0
block|,
literal|0x00
block|}
block|,
block|{
name|PMC_EV_K8_FR_DISPATCH_STALLS
block|,
literal|0xD1
block|,
literal|0x00
block|}
block|,
block|{
name|PMC_EV_K8_FR_DISPATCH_STALL_FROM_BRANCH_ABORT_TO_RETIRE
block|,
literal|0xD2
block|,
literal|0x00
block|}
block|,
block|{
name|PMC_EV_K8_FR_DISPATCH_STALL_FOR_SERIALIZATION
block|,
literal|0xD3
block|,
literal|0x00
block|}
block|,
block|{
name|PMC_EV_K8_FR_DISPATCH_STALL_FOR_SEGMENT_LOAD
block|,
literal|0xD4
block|,
literal|0x00
block|}
block|,
block|{
name|PMC_EV_K8_FR_DISPATCH_STALL_WHEN_REORDER_BUFFER_IS_FULL
block|,
literal|0xD5
block|,
literal|0x00
block|}
block|,
block|{
name|PMC_EV_K8_FR_DISPATCH_STALL_WHEN_RESERVATION_STATIONS_ARE_FULL
block|,
literal|0xD6
block|,
literal|0x00
block|}
block|,
block|{
name|PMC_EV_K8_FR_DISPATCH_STALL_WHEN_FPU_IS_FULL
block|,
literal|0xD7
block|,
literal|0x00
block|}
block|,
block|{
name|PMC_EV_K8_FR_DISPATCH_STALL_WHEN_LS_IS_FULL
block|,
literal|0xD8
block|,
literal|0x00
block|}
block|,
block|{
name|PMC_EV_K8_FR_DISPATCH_STALL_WHEN_WAITING_FOR_ALL_TO_BE_QUIET
block|,
literal|0xD9
block|,
literal|0x00
block|}
block|,
block|{
name|PMC_EV_K8_FR_DISPATCH_STALL_WHEN_FAR_XFER_OR_RESYNC_BRANCH_PENDING
block|,
literal|0xDA
block|,
literal|0x00
block|}
block|,
block|{
name|PMC_EV_K8_FR_FPU_EXCEPTIONS
block|,
literal|0xDB
block|,
literal|0x0F
block|}
block|,
block|{
name|PMC_EV_K8_FR_NUMBER_OF_BREAKPOINTS_FOR_DR0
block|,
literal|0xDC
block|,
literal|0x00
block|}
block|,
block|{
name|PMC_EV_K8_FR_NUMBER_OF_BREAKPOINTS_FOR_DR1
block|,
literal|0xDD
block|,
literal|0x00
block|}
block|,
block|{
name|PMC_EV_K8_FR_NUMBER_OF_BREAKPOINTS_FOR_DR2
block|,
literal|0xDE
block|,
literal|0x00
block|}
block|,
block|{
name|PMC_EV_K8_FR_NUMBER_OF_BREAKPOINTS_FOR_DR3
block|,
literal|0xDF
block|,
literal|0x00
block|}
block|,
block|{
name|PMC_EV_K8_NB_MEMORY_CONTROLLER_PAGE_ACCESS_EVENT
block|,
literal|0xE0
block|,
literal|0x7
block|}
block|,
block|{
name|PMC_EV_K8_NB_MEMORY_CONTROLLER_PAGE_TABLE_OVERFLOW
block|,
literal|0xE1
block|,
literal|0x00
block|}
block|,
block|{
name|PMC_EV_K8_NB_MEMORY_CONTROLLER_DRAM_COMMAND_SLOTS_MISSED
block|,
literal|0xE2
block|,
literal|0x00
block|}
block|,
block|{
name|PMC_EV_K8_NB_MEMORY_CONTROLLER_TURNAROUND
block|,
literal|0xE3
block|,
literal|0x07
block|}
block|,
block|{
name|PMC_EV_K8_NB_MEMORY_CONTROLLER_BYPASS_SATURATION
block|,
literal|0xE4
block|,
literal|0x0F
block|}
block|,
block|{
name|PMC_EV_K8_NB_SIZED_COMMANDS
block|,
literal|0xEB
block|,
literal|0x7F
block|}
block|,
block|{
name|PMC_EV_K8_NB_PROBE_RESULT
block|,
literal|0xEC
block|,
literal|0x0F
block|}
block|,
block|{
name|PMC_EV_K8_NB_HT_BUS0_BANDWIDTH
block|,
literal|0xF6
block|,
literal|0x0F
block|}
block|,
block|{
name|PMC_EV_K8_NB_HT_BUS1_BANDWIDTH
block|,
literal|0xF7
block|,
literal|0x0F
block|}
block|,
block|{
name|PMC_EV_K8_NB_HT_BUS2_BANDWIDTH
block|,
literal|0xF8
block|,
literal|0x0F
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|int
name|amd_event_codes_size
init|=
sizeof|sizeof
argument_list|(
name|amd_event_codes
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|amd_event_codes
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * read a pmc register  */
end_comment

begin_function
specifier|static
name|int
name|amd_read_pmc
parameter_list|(
name|int
name|cpu
parameter_list|,
name|int
name|ri
parameter_list|,
name|pmc_value_t
modifier|*
name|v
parameter_list|)
block|{
name|enum
name|pmc_mode
name|mode
decl_stmt|;
specifier|const
name|struct
name|amd_descr
modifier|*
name|pd
decl_stmt|;
name|struct
name|pmc
modifier|*
name|pm
decl_stmt|;
specifier|const
name|struct
name|pmc_hw
modifier|*
name|phw
decl_stmt|;
name|pmc_value_t
name|tmp
decl_stmt|;
name|KASSERT
argument_list|(
name|cpu
operator|>=
literal|0
operator|&&
name|cpu
operator|<
name|mp_ncpus
argument_list|,
operator|(
literal|"[amd,%d] illegal CPU value %d"
operator|,
name|__LINE__
operator|,
name|cpu
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|ri
operator|>=
literal|0
operator|&&
name|ri
operator|<
name|AMD_NPMCS
argument_list|,
operator|(
literal|"[amd,%d] illegal row-index %d"
operator|,
name|__LINE__
operator|,
name|ri
operator|)
argument_list|)
expr_stmt|;
name|phw
operator|=
name|pmc_pcpu
index|[
name|cpu
index|]
operator|->
name|pc_hwpmcs
index|[
name|ri
index|]
expr_stmt|;
name|pd
operator|=
operator|&
name|amd_pmcdesc
index|[
name|ri
index|]
expr_stmt|;
name|pm
operator|=
name|phw
operator|->
name|phw_pmc
expr_stmt|;
name|KASSERT
argument_list|(
name|pm
operator|!=
name|NULL
argument_list|,
operator|(
literal|"[amd,%d] No owner for HWPMC [cpu%d,pmc%d]"
operator|,
name|__LINE__
operator|,
name|cpu
operator|,
name|ri
operator|)
argument_list|)
expr_stmt|;
name|mode
operator|=
name|PMC_TO_MODE
argument_list|(
name|pm
argument_list|)
expr_stmt|;
name|PMCDBG
argument_list|(
name|MDP
argument_list|,
name|REA
argument_list|,
literal|1
argument_list|,
literal|"amd-read id=%d class=%d"
argument_list|,
name|ri
argument_list|,
name|pd
operator|->
name|pm_descr
operator|.
name|pd_class
argument_list|)
expr_stmt|;
comment|/* Reading the TSC is a special case */
if|if
condition|(
name|pd
operator|->
name|pm_descr
operator|.
name|pd_class
operator|==
name|PMC_CLASS_TSC
condition|)
block|{
name|KASSERT
argument_list|(
name|PMC_IS_COUNTING_MODE
argument_list|(
name|mode
argument_list|)
argument_list|,
operator|(
literal|"[amd,%d] TSC counter in non-counting mode"
operator|,
name|__LINE__
operator|)
argument_list|)
expr_stmt|;
operator|*
name|v
operator|=
name|rdtsc
argument_list|()
expr_stmt|;
name|PMCDBG
argument_list|(
name|MDP
argument_list|,
name|REA
argument_list|,
literal|2
argument_list|,
literal|"amd-read id=%d -> %jd"
argument_list|,
name|ri
argument_list|,
operator|*
name|v
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|#
directive|if
name|DEBUG
name|KASSERT
argument_list|(
name|pd
operator|->
name|pm_descr
operator|.
name|pd_class
operator|==
name|amd_pmc_class
argument_list|,
operator|(
literal|"[amd,%d] unknown PMC class (%d)"
operator|,
name|__LINE__
operator|,
name|pd
operator|->
name|pm_descr
operator|.
name|pd_class
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|tmp
operator|=
name|rdmsr
argument_list|(
name|pd
operator|->
name|pm_perfctr
argument_list|)
expr_stmt|;
comment|/* RDMSR serializes */
if|if
condition|(
name|PMC_IS_SAMPLING_MODE
argument_list|(
name|mode
argument_list|)
condition|)
operator|*
name|v
operator|=
name|AMD_PERFCTR_VALUE_TO_RELOAD_COUNT
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
else|else
operator|*
name|v
operator|=
name|tmp
expr_stmt|;
name|PMCDBG
argument_list|(
name|MDP
argument_list|,
name|REA
argument_list|,
literal|2
argument_list|,
literal|"amd-read id=%d -> %jd"
argument_list|,
name|ri
argument_list|,
operator|*
name|v
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Write a PMC MSR.  */
end_comment

begin_function
specifier|static
name|int
name|amd_write_pmc
parameter_list|(
name|int
name|cpu
parameter_list|,
name|int
name|ri
parameter_list|,
name|pmc_value_t
name|v
parameter_list|)
block|{
specifier|const
name|struct
name|amd_descr
modifier|*
name|pd
decl_stmt|;
name|struct
name|pmc
modifier|*
name|pm
decl_stmt|;
specifier|const
name|struct
name|pmc_hw
modifier|*
name|phw
decl_stmt|;
name|enum
name|pmc_mode
name|mode
decl_stmt|;
name|KASSERT
argument_list|(
name|cpu
operator|>=
literal|0
operator|&&
name|cpu
operator|<
name|mp_ncpus
argument_list|,
operator|(
literal|"[amd,%d] illegal CPU value %d"
operator|,
name|__LINE__
operator|,
name|cpu
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|ri
operator|>=
literal|0
operator|&&
name|ri
operator|<
name|AMD_NPMCS
argument_list|,
operator|(
literal|"[amd,%d] illegal row-index %d"
operator|,
name|__LINE__
operator|,
name|ri
operator|)
argument_list|)
expr_stmt|;
name|phw
operator|=
name|pmc_pcpu
index|[
name|cpu
index|]
operator|->
name|pc_hwpmcs
index|[
name|ri
index|]
expr_stmt|;
name|pd
operator|=
operator|&
name|amd_pmcdesc
index|[
name|ri
index|]
expr_stmt|;
name|pm
operator|=
name|phw
operator|->
name|phw_pmc
expr_stmt|;
name|KASSERT
argument_list|(
name|pm
operator|!=
name|NULL
argument_list|,
operator|(
literal|"[amd,%d] PMC not owned (cpu%d,pmc%d)"
operator|,
name|__LINE__
operator|,
name|cpu
operator|,
name|ri
operator|)
argument_list|)
expr_stmt|;
name|mode
operator|=
name|PMC_TO_MODE
argument_list|(
name|pm
argument_list|)
expr_stmt|;
if|if
condition|(
name|pd
operator|->
name|pm_descr
operator|.
name|pd_class
operator|==
name|PMC_CLASS_TSC
condition|)
return|return
literal|0
return|;
if|#
directive|if
name|DEBUG
name|KASSERT
argument_list|(
name|pd
operator|->
name|pm_descr
operator|.
name|pd_class
operator|==
name|amd_pmc_class
argument_list|,
operator|(
literal|"[amd,%d] unknown PMC class (%d)"
operator|,
name|__LINE__
operator|,
name|pd
operator|->
name|pm_descr
operator|.
name|pd_class
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* use 2's complement of the count for sampling mode PMCs */
if|if
condition|(
name|PMC_IS_SAMPLING_MODE
argument_list|(
name|mode
argument_list|)
condition|)
name|v
operator|=
name|AMD_RELOAD_COUNT_TO_PERFCTR_VALUE
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|PMCDBG
argument_list|(
name|MDP
argument_list|,
name|WRI
argument_list|,
literal|1
argument_list|,
literal|"amd-write cpu=%d ri=%d v=%jx"
argument_list|,
name|cpu
argument_list|,
name|ri
argument_list|,
name|v
argument_list|)
expr_stmt|;
comment|/* write the PMC value */
name|wrmsr
argument_list|(
name|pd
operator|->
name|pm_perfctr
argument_list|,
name|v
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * configure hardware pmc according to the configuration recorded in  * pmc 'pm'.  */
end_comment

begin_function
specifier|static
name|int
name|amd_config_pmc
parameter_list|(
name|int
name|cpu
parameter_list|,
name|int
name|ri
parameter_list|,
name|struct
name|pmc
modifier|*
name|pm
parameter_list|)
block|{
name|struct
name|pmc_hw
modifier|*
name|phw
decl_stmt|;
name|PMCDBG
argument_list|(
name|MDP
argument_list|,
name|CFG
argument_list|,
literal|1
argument_list|,
literal|"cpu=%d ri=%d pm=%p"
argument_list|,
name|cpu
argument_list|,
name|ri
argument_list|,
name|pm
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|cpu
operator|>=
literal|0
operator|&&
name|cpu
operator|<
name|mp_ncpus
argument_list|,
operator|(
literal|"[amd,%d] illegal CPU value %d"
operator|,
name|__LINE__
operator|,
name|cpu
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|ri
operator|>=
literal|0
operator|&&
name|ri
operator|<
name|AMD_NPMCS
argument_list|,
operator|(
literal|"[amd,%d] illegal row-index %d"
operator|,
name|__LINE__
operator|,
name|ri
operator|)
argument_list|)
expr_stmt|;
name|phw
operator|=
name|pmc_pcpu
index|[
name|cpu
index|]
operator|->
name|pc_hwpmcs
index|[
name|ri
index|]
expr_stmt|;
name|KASSERT
argument_list|(
name|pm
operator|==
name|NULL
operator|||
name|phw
operator|->
name|phw_pmc
operator|==
name|NULL
argument_list|,
operator|(
literal|"[amd,%d] pm=%p phw->pm=%p hwpmc not unconfigured"
operator|,
name|__LINE__
operator|,
name|pm
operator|,
name|phw
operator|->
name|phw_pmc
operator|)
argument_list|)
expr_stmt|;
name|phw
operator|->
name|phw_pmc
operator|=
name|pm
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Retrieve a configured PMC pointer from hardware state.  */
end_comment

begin_function
specifier|static
name|int
name|amd_get_config
parameter_list|(
name|int
name|cpu
parameter_list|,
name|int
name|ri
parameter_list|,
name|struct
name|pmc
modifier|*
modifier|*
name|ppm
parameter_list|)
block|{
operator|*
name|ppm
operator|=
name|pmc_pcpu
index|[
name|cpu
index|]
operator|->
name|pc_hwpmcs
index|[
name|ri
index|]
operator|->
name|phw_pmc
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Machine dependent actions taken during the context switch in of a  * thread.  */
end_comment

begin_function
specifier|static
name|int
name|amd_switch_in
parameter_list|(
name|struct
name|pmc_cpu
modifier|*
name|pc
parameter_list|,
name|struct
name|pmc_process
modifier|*
name|pp
parameter_list|)
block|{
operator|(
name|void
operator|)
name|pc
expr_stmt|;
name|PMCDBG
argument_list|(
name|MDP
argument_list|,
name|SWI
argument_list|,
literal|1
argument_list|,
literal|"pc=%p pp=%p enable-msr=%d"
argument_list|,
name|pc
argument_list|,
name|pp
argument_list|,
operator|(
name|pp
operator|->
name|pp_flags
operator|&
name|PMC_PP_ENABLE_MSR_ACCESS
operator|)
operator|!=
literal|0
argument_list|)
expr_stmt|;
comment|/* enable the RDPMC instruction if needed */
if|if
condition|(
name|pp
operator|->
name|pp_flags
operator|&
name|PMC_PP_ENABLE_MSR_ACCESS
condition|)
name|load_cr4
argument_list|(
name|rcr4
argument_list|()
operator||
name|CR4_PCE
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Machine dependent actions taken during the context switch out of a  * thread.  */
end_comment

begin_function
specifier|static
name|int
name|amd_switch_out
parameter_list|(
name|struct
name|pmc_cpu
modifier|*
name|pc
parameter_list|,
name|struct
name|pmc_process
modifier|*
name|pp
parameter_list|)
block|{
operator|(
name|void
operator|)
name|pc
expr_stmt|;
operator|(
name|void
operator|)
name|pp
expr_stmt|;
comment|/* can be NULL */
name|PMCDBG
argument_list|(
name|MDP
argument_list|,
name|SWO
argument_list|,
literal|1
argument_list|,
literal|"pc=%p pp=%p enable-msr=%d"
argument_list|,
name|pc
argument_list|,
name|pp
argument_list|,
name|pp
condition|?
operator|(
name|pp
operator|->
name|pp_flags
operator|&
name|PMC_PP_ENABLE_MSR_ACCESS
operator|)
operator|==
literal|1
else|:
literal|0
argument_list|)
expr_stmt|;
comment|/* always turn off the RDPMC instruction */
name|load_cr4
argument_list|(
name|rcr4
argument_list|()
operator|&
operator|~
name|CR4_PCE
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Check if a given allocation is feasible.  */
end_comment

begin_function
specifier|static
name|int
name|amd_allocate_pmc
parameter_list|(
name|int
name|cpu
parameter_list|,
name|int
name|ri
parameter_list|,
name|struct
name|pmc
modifier|*
name|pm
parameter_list|,
specifier|const
name|struct
name|pmc_op_pmcallocate
modifier|*
name|a
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|uint32_t
name|allowed_unitmask
decl_stmt|,
name|caps
decl_stmt|,
name|config
decl_stmt|,
name|unitmask
decl_stmt|;
name|enum
name|pmc_event
name|pe
decl_stmt|;
specifier|const
name|struct
name|pmc_descr
modifier|*
name|pd
decl_stmt|;
operator|(
name|void
operator|)
name|cpu
expr_stmt|;
name|KASSERT
argument_list|(
name|cpu
operator|>=
literal|0
operator|&&
name|cpu
operator|<
name|mp_ncpus
argument_list|,
operator|(
literal|"[amd,%d] illegal CPU value %d"
operator|,
name|__LINE__
operator|,
name|cpu
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|ri
operator|>=
literal|0
operator|&&
name|ri
operator|<
name|AMD_NPMCS
argument_list|,
operator|(
literal|"[amd,%d] illegal row index %d"
operator|,
name|__LINE__
operator|,
name|ri
operator|)
argument_list|)
expr_stmt|;
name|pd
operator|=
operator|&
name|amd_pmcdesc
index|[
name|ri
index|]
operator|.
name|pm_descr
expr_stmt|;
comment|/* check class match */
if|if
condition|(
name|pd
operator|->
name|pd_class
operator|!=
name|a
operator|->
name|pm_class
condition|)
return|return
name|EINVAL
return|;
name|caps
operator|=
name|pm
operator|->
name|pm_caps
expr_stmt|;
name|PMCDBG
argument_list|(
name|MDP
argument_list|,
name|ALL
argument_list|,
literal|1
argument_list|,
literal|"amd-allocate ri=%d caps=0x%x"
argument_list|,
name|ri
argument_list|,
name|caps
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pd
operator|->
name|pd_caps
operator|&
name|caps
operator|)
operator|!=
name|caps
condition|)
return|return
name|EPERM
return|;
if|if
condition|(
name|pd
operator|->
name|pd_class
operator|==
name|PMC_CLASS_TSC
condition|)
block|{
comment|/* TSC's are always allocated in system-wide counting mode */
if|if
condition|(
name|a
operator|->
name|pm_ev
operator|!=
name|PMC_EV_TSC_TSC
operator|||
name|a
operator|->
name|pm_mode
operator|!=
name|PMC_MODE_SC
condition|)
return|return
name|EINVAL
return|;
return|return
literal|0
return|;
block|}
if|#
directive|if
name|DEBUG
name|KASSERT
argument_list|(
name|pd
operator|->
name|pd_class
operator|==
name|amd_pmc_class
argument_list|,
operator|(
literal|"[amd,%d] Unknown PMC class (%d)"
operator|,
name|__LINE__
operator|,
name|pd
operator|->
name|pd_class
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|pe
operator|=
name|a
operator|->
name|pm_ev
expr_stmt|;
comment|/* map ev to the correct event mask code */
name|config
operator|=
name|allowed_unitmask
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|amd_event_codes_size
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|amd_event_codes
index|[
name|i
index|]
operator|.
name|pe_ev
operator|==
name|pe
condition|)
block|{
name|config
operator|=
name|AMD_PMC_TO_EVENTMASK
argument_list|(
name|amd_event_codes
index|[
name|i
index|]
operator|.
name|pe_code
argument_list|)
expr_stmt|;
name|allowed_unitmask
operator|=
name|AMD_PMC_TO_UNITMASK
argument_list|(
name|amd_event_codes
index|[
name|i
index|]
operator|.
name|pe_mask
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|i
operator|==
name|amd_event_codes_size
condition|)
return|return
name|EINVAL
return|;
name|unitmask
operator|=
name|a
operator|->
name|pm_md
operator|.
name|pm_amd
operator|.
name|pm_amd_config
operator|&
name|AMD_PMC_UNITMASK
expr_stmt|;
if|if
condition|(
name|unitmask
operator|&
operator|~
name|allowed_unitmask
condition|)
comment|/* disallow reserved bits */
return|return
name|EINVAL
return|;
if|if
condition|(
name|unitmask
operator|&&
operator|(
name|caps
operator|&
name|PMC_CAP_QUALIFIER
operator|)
condition|)
name|config
operator||=
name|unitmask
expr_stmt|;
if|if
condition|(
name|caps
operator|&
name|PMC_CAP_THRESHOLD
condition|)
name|config
operator||=
name|a
operator|->
name|pm_md
operator|.
name|pm_amd
operator|.
name|pm_amd_config
operator|&
name|AMD_PMC_COUNTERMASK
expr_stmt|;
comment|/* set at least one of the 'usr' or 'os' caps */
if|if
condition|(
name|caps
operator|&
name|PMC_CAP_USER
condition|)
name|config
operator||=
name|AMD_PMC_USR
expr_stmt|;
if|if
condition|(
name|caps
operator|&
name|PMC_CAP_SYSTEM
condition|)
name|config
operator||=
name|AMD_PMC_OS
expr_stmt|;
if|if
condition|(
operator|(
name|caps
operator|&
operator|(
name|PMC_CAP_USER
operator||
name|PMC_CAP_SYSTEM
operator|)
operator|)
operator|==
literal|0
condition|)
name|config
operator||=
operator|(
name|AMD_PMC_USR
operator||
name|AMD_PMC_OS
operator|)
expr_stmt|;
if|if
condition|(
name|caps
operator|&
name|PMC_CAP_EDGE
condition|)
name|config
operator||=
name|AMD_PMC_EDGE
expr_stmt|;
if|if
condition|(
name|caps
operator|&
name|PMC_CAP_INVERT
condition|)
name|config
operator||=
name|AMD_PMC_INVERT
expr_stmt|;
if|if
condition|(
name|caps
operator|&
name|PMC_CAP_INTERRUPT
condition|)
name|config
operator||=
name|AMD_PMC_INT
expr_stmt|;
name|pm
operator|->
name|pm_md
operator|.
name|pm_amd
operator|.
name|pm_amd_evsel
operator|=
name|config
expr_stmt|;
comment|/* save config value */
name|PMCDBG
argument_list|(
name|MDP
argument_list|,
name|ALL
argument_list|,
literal|2
argument_list|,
literal|"amd-allocate ri=%d -> config=0x%x"
argument_list|,
name|ri
argument_list|,
name|config
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Release machine dependent state associated with a PMC.  This is a  * no-op on this architecture.  *  */
end_comment

begin_comment
comment|/* ARGSUSED0 */
end_comment

begin_function
specifier|static
name|int
name|amd_release_pmc
parameter_list|(
name|int
name|cpu
parameter_list|,
name|int
name|ri
parameter_list|,
name|struct
name|pmc
modifier|*
name|pmc
parameter_list|)
block|{
if|#
directive|if
name|DEBUG
specifier|const
name|struct
name|amd_descr
modifier|*
name|pd
decl_stmt|;
endif|#
directive|endif
name|struct
name|pmc_hw
modifier|*
name|phw
decl_stmt|;
operator|(
name|void
operator|)
name|pmc
expr_stmt|;
name|KASSERT
argument_list|(
name|cpu
operator|>=
literal|0
operator|&&
name|cpu
operator|<
name|mp_ncpus
argument_list|,
operator|(
literal|"[amd,%d] illegal CPU value %d"
operator|,
name|__LINE__
operator|,
name|cpu
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|ri
operator|>=
literal|0
operator|&&
name|ri
operator|<
name|AMD_NPMCS
argument_list|,
operator|(
literal|"[amd,%d] illegal row-index %d"
operator|,
name|__LINE__
operator|,
name|ri
operator|)
argument_list|)
expr_stmt|;
name|phw
operator|=
name|pmc_pcpu
index|[
name|cpu
index|]
operator|->
name|pc_hwpmcs
index|[
name|ri
index|]
expr_stmt|;
name|KASSERT
argument_list|(
name|phw
operator|->
name|phw_pmc
operator|==
name|NULL
argument_list|,
operator|(
literal|"[amd,%d] PHW pmc %p non-NULL"
operator|,
name|__LINE__
operator|,
name|phw
operator|->
name|phw_pmc
operator|)
argument_list|)
expr_stmt|;
if|#
directive|if
name|DEBUG
name|pd
operator|=
operator|&
name|amd_pmcdesc
index|[
name|ri
index|]
expr_stmt|;
if|if
condition|(
name|pd
operator|->
name|pm_descr
operator|.
name|pd_class
operator|==
name|amd_pmc_class
condition|)
name|KASSERT
argument_list|(
name|AMD_PMC_IS_STOPPED
argument_list|(
name|pd
operator|->
name|pm_evsel
argument_list|)
argument_list|,
operator|(
literal|"[amd,%d] PMC %d released while active"
operator|,
name|__LINE__
operator|,
name|ri
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * start a PMC.  */
end_comment

begin_function
specifier|static
name|int
name|amd_start_pmc
parameter_list|(
name|int
name|cpu
parameter_list|,
name|int
name|ri
parameter_list|)
block|{
name|uint32_t
name|config
decl_stmt|;
name|struct
name|pmc
modifier|*
name|pm
decl_stmt|;
name|struct
name|pmc_hw
modifier|*
name|phw
decl_stmt|;
specifier|const
name|struct
name|amd_descr
modifier|*
name|pd
decl_stmt|;
name|KASSERT
argument_list|(
name|cpu
operator|>=
literal|0
operator|&&
name|cpu
operator|<
name|mp_ncpus
argument_list|,
operator|(
literal|"[amd,%d] illegal CPU value %d"
operator|,
name|__LINE__
operator|,
name|cpu
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|ri
operator|>=
literal|0
operator|&&
name|ri
operator|<
name|AMD_NPMCS
argument_list|,
operator|(
literal|"[amd,%d] illegal row-index %d"
operator|,
name|__LINE__
operator|,
name|ri
operator|)
argument_list|)
expr_stmt|;
name|phw
operator|=
name|pmc_pcpu
index|[
name|cpu
index|]
operator|->
name|pc_hwpmcs
index|[
name|ri
index|]
expr_stmt|;
name|pm
operator|=
name|phw
operator|->
name|phw_pmc
expr_stmt|;
name|pd
operator|=
operator|&
name|amd_pmcdesc
index|[
name|ri
index|]
expr_stmt|;
name|KASSERT
argument_list|(
name|pm
operator|!=
name|NULL
argument_list|,
operator|(
literal|"[amd,%d] starting cpu%d,pmc%d with null pmc record"
operator|,
name|__LINE__
operator|,
name|cpu
operator|,
name|ri
operator|)
argument_list|)
expr_stmt|;
name|PMCDBG
argument_list|(
name|MDP
argument_list|,
name|STA
argument_list|,
literal|1
argument_list|,
literal|"amd-start cpu=%d ri=%d"
argument_list|,
name|cpu
argument_list|,
name|ri
argument_list|)
expr_stmt|;
if|if
condition|(
name|pd
operator|->
name|pm_descr
operator|.
name|pd_class
operator|==
name|PMC_CLASS_TSC
condition|)
return|return
literal|0
return|;
comment|/* TSCs are always running */
if|#
directive|if
name|DEBUG
name|KASSERT
argument_list|(
name|pd
operator|->
name|pm_descr
operator|.
name|pd_class
operator|==
name|amd_pmc_class
argument_list|,
operator|(
literal|"[amd,%d] unknown PMC class (%d)"
operator|,
name|__LINE__
operator|,
name|pd
operator|->
name|pm_descr
operator|.
name|pd_class
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|KASSERT
argument_list|(
name|AMD_PMC_IS_STOPPED
argument_list|(
name|pd
operator|->
name|pm_evsel
argument_list|)
argument_list|,
operator|(
literal|"[amd,%d] pmc%d,cpu%d: Starting active PMC \"%s\""
operator|,
name|__LINE__
operator|,
name|ri
operator|,
name|cpu
operator|,
name|pd
operator|->
name|pm_descr
operator|.
name|pd_name
operator|)
argument_list|)
expr_stmt|;
comment|/* turn on the PMC ENABLE bit */
name|config
operator|=
name|pm
operator|->
name|pm_md
operator|.
name|pm_amd
operator|.
name|pm_amd_evsel
operator||
name|AMD_PMC_ENABLE
expr_stmt|;
name|PMCDBG
argument_list|(
name|MDP
argument_list|,
name|STA
argument_list|,
literal|2
argument_list|,
literal|"amd-start config=0x%x"
argument_list|,
name|config
argument_list|)
expr_stmt|;
name|wrmsr
argument_list|(
name|pd
operator|->
name|pm_evsel
argument_list|,
name|config
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Stop a PMC.  */
end_comment

begin_function
specifier|static
name|int
name|amd_stop_pmc
parameter_list|(
name|int
name|cpu
parameter_list|,
name|int
name|ri
parameter_list|)
block|{
name|struct
name|pmc
modifier|*
name|pm
decl_stmt|;
name|struct
name|pmc_hw
modifier|*
name|phw
decl_stmt|;
specifier|const
name|struct
name|amd_descr
modifier|*
name|pd
decl_stmt|;
name|uint64_t
name|config
decl_stmt|;
name|KASSERT
argument_list|(
name|cpu
operator|>=
literal|0
operator|&&
name|cpu
operator|<
name|mp_ncpus
argument_list|,
operator|(
literal|"[amd,%d] illegal CPU value %d"
operator|,
name|__LINE__
operator|,
name|cpu
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|ri
operator|>=
literal|0
operator|&&
name|ri
operator|<
name|AMD_NPMCS
argument_list|,
operator|(
literal|"[amd,%d] illegal row-index %d"
operator|,
name|__LINE__
operator|,
name|ri
operator|)
argument_list|)
expr_stmt|;
name|phw
operator|=
name|pmc_pcpu
index|[
name|cpu
index|]
operator|->
name|pc_hwpmcs
index|[
name|ri
index|]
expr_stmt|;
name|pm
operator|=
name|phw
operator|->
name|phw_pmc
expr_stmt|;
name|pd
operator|=
operator|&
name|amd_pmcdesc
index|[
name|ri
index|]
expr_stmt|;
name|KASSERT
argument_list|(
name|pm
operator|!=
name|NULL
argument_list|,
operator|(
literal|"[amd,%d] cpu%d,pmc%d no PMC to stop"
operator|,
name|__LINE__
operator|,
name|cpu
operator|,
name|ri
operator|)
argument_list|)
expr_stmt|;
comment|/* can't stop a TSC */
if|if
condition|(
name|pd
operator|->
name|pm_descr
operator|.
name|pd_class
operator|==
name|PMC_CLASS_TSC
condition|)
return|return
literal|0
return|;
if|#
directive|if
name|DEBUG
name|KASSERT
argument_list|(
name|pd
operator|->
name|pm_descr
operator|.
name|pd_class
operator|==
name|amd_pmc_class
argument_list|,
operator|(
literal|"[amd,%d] unknown PMC class (%d)"
operator|,
name|__LINE__
operator|,
name|pd
operator|->
name|pm_descr
operator|.
name|pd_class
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|KASSERT
argument_list|(
operator|!
name|AMD_PMC_IS_STOPPED
argument_list|(
name|pd
operator|->
name|pm_evsel
argument_list|)
argument_list|,
operator|(
literal|"[amd,%d] PMC%d, CPU%d \"%s\" already stopped"
operator|,
name|__LINE__
operator|,
name|ri
operator|,
name|cpu
operator|,
name|pd
operator|->
name|pm_descr
operator|.
name|pd_name
operator|)
argument_list|)
expr_stmt|;
name|PMCDBG
argument_list|(
name|MDP
argument_list|,
name|STO
argument_list|,
literal|1
argument_list|,
literal|"amd-stop ri=%d"
argument_list|,
name|ri
argument_list|)
expr_stmt|;
comment|/* turn off the PMC ENABLE bit */
name|config
operator|=
name|pm
operator|->
name|pm_md
operator|.
name|pm_amd
operator|.
name|pm_amd_evsel
operator|&
operator|~
name|AMD_PMC_ENABLE
expr_stmt|;
name|wrmsr
argument_list|(
name|pd
operator|->
name|pm_evsel
argument_list|,
name|config
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Interrupt handler.  This function needs to return '1' if the  * interrupt was this CPU's PMCs or '0' otherwise.  It is not allowed  * to sleep or do anything a 'fast' interrupt handler is not allowed  * to do.  */
end_comment

begin_function
specifier|static
name|int
name|amd_intr
parameter_list|(
name|int
name|cpu
parameter_list|,
name|uintptr_t
name|eip
parameter_list|,
name|int
name|usermode
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|error
decl_stmt|,
name|retval
decl_stmt|,
name|ri
decl_stmt|;
name|uint32_t
name|config
decl_stmt|,
name|evsel
decl_stmt|,
name|perfctr
decl_stmt|;
name|struct
name|pmc
modifier|*
name|pm
decl_stmt|;
name|struct
name|pmc_cpu
modifier|*
name|pc
decl_stmt|;
name|struct
name|pmc_hw
modifier|*
name|phw
decl_stmt|;
name|pmc_value_t
name|v
decl_stmt|;
name|KASSERT
argument_list|(
name|cpu
operator|>=
literal|0
operator|&&
name|cpu
operator|<
name|mp_ncpus
argument_list|,
operator|(
literal|"[amd,%d] out of range CPU %d"
operator|,
name|__LINE__
operator|,
name|cpu
operator|)
argument_list|)
expr_stmt|;
name|PMCDBG
argument_list|(
name|MDP
argument_list|,
name|INT
argument_list|,
literal|1
argument_list|,
literal|"cpu=%d eip=%p um=%d"
argument_list|,
name|cpu
argument_list|,
operator|(
name|void
operator|*
operator|)
name|eip
argument_list|,
name|usermode
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|0
expr_stmt|;
name|pc
operator|=
name|pmc_pcpu
index|[
name|cpu
index|]
expr_stmt|;
comment|/* 	 * look for all PMCs that have interrupted: 	 * - skip over the TSC [PMC#0] 	 * - look for a running, sampling PMC which has overflowed 	 *   and which has a valid 'struct pmc' association 	 * 	 * If found, we call a helper to process the interrupt. 	 * 	 * If multiple PMCs interrupt at the same time, the AMD64 	 * processor appears to deliver as many NMIs as there are 	 * outstanding PMC interrupts.  Thus we need to only process 	 * one interrupt at a time. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|retval
operator|==
literal|0
operator|&&
name|i
operator|<
name|AMD_NPMCS
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
name|ri
operator|=
name|i
operator|+
literal|1
expr_stmt|;
comment|/* row index; TSC is at ri == 0 */
if|if
condition|(
operator|!
name|AMD_PMC_HAS_OVERFLOWED
argument_list|(
name|i
argument_list|)
condition|)
continue|continue;
name|phw
operator|=
name|pc
operator|->
name|pc_hwpmcs
index|[
name|ri
index|]
expr_stmt|;
name|KASSERT
argument_list|(
name|phw
operator|!=
name|NULL
argument_list|,
operator|(
literal|"[amd,%d] null PHW pointer"
operator|,
name|__LINE__
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pm
operator|=
name|phw
operator|->
name|phw_pmc
operator|)
operator|==
name|NULL
operator|||
name|pm
operator|->
name|pm_state
operator|!=
name|PMC_STATE_RUNNING
operator|||
operator|!
name|PMC_IS_SAMPLING_MODE
argument_list|(
name|PMC_TO_MODE
argument_list|(
name|pm
argument_list|)
argument_list|)
condition|)
block|{
continue|continue;
block|}
name|retval
operator|=
literal|1
expr_stmt|;
comment|/* found an interrupting PMC */
comment|/* stop the PMC, reload count */
name|evsel
operator|=
name|AMD_PMC_EVSEL_0
operator|+
name|i
expr_stmt|;
name|perfctr
operator|=
name|AMD_PMC_PERFCTR_0
operator|+
name|i
expr_stmt|;
name|v
operator|=
name|pm
operator|->
name|pm_sc
operator|.
name|pm_reloadcount
expr_stmt|;
name|config
operator|=
name|rdmsr
argument_list|(
name|evsel
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|config
operator|&
operator|~
name|AMD_PMC_ENABLE
operator|)
operator|==
operator|(
name|pm
operator|->
name|pm_md
operator|.
name|pm_amd
operator|.
name|pm_amd_evsel
operator|&
operator|~
name|AMD_PMC_ENABLE
operator|)
argument_list|,
operator|(
literal|"[amd,%d] config mismatch reg=0x%x pm=0x%x"
operator|,
name|__LINE__
operator|,
name|config
operator|,
name|pm
operator|->
name|pm_md
operator|.
name|pm_amd
operator|.
name|pm_amd_evsel
operator|)
argument_list|)
expr_stmt|;
name|wrmsr
argument_list|(
name|evsel
argument_list|,
name|config
operator|&
operator|~
name|AMD_PMC_ENABLE
argument_list|)
expr_stmt|;
name|wrmsr
argument_list|(
name|perfctr
argument_list|,
name|AMD_RELOAD_COUNT_TO_PERFCTR_VALUE
argument_list|(
name|v
argument_list|)
argument_list|)
expr_stmt|;
comment|/* restart the counter if there was no error during logging */
name|error
operator|=
name|pmc_process_interrupt
argument_list|(
name|cpu
argument_list|,
name|pm
argument_list|,
name|eip
argument_list|,
name|usermode
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|wrmsr
argument_list|(
name|evsel
argument_list|,
name|config
operator||
name|AMD_PMC_ENABLE
argument_list|)
expr_stmt|;
block|}
name|atomic_add_int
argument_list|(
name|retval
condition|?
operator|&
name|pmc_stats
operator|.
name|pm_intr_processed
else|:
operator|&
name|pmc_stats
operator|.
name|pm_intr_ignored
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_comment
comment|/*  * describe a PMC  */
end_comment

begin_function
specifier|static
name|int
name|amd_describe
parameter_list|(
name|int
name|cpu
parameter_list|,
name|int
name|ri
parameter_list|,
name|struct
name|pmc_info
modifier|*
name|pi
parameter_list|,
name|struct
name|pmc
modifier|*
modifier|*
name|ppmc
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|size_t
name|copied
decl_stmt|;
specifier|const
name|struct
name|amd_descr
modifier|*
name|pd
decl_stmt|;
name|struct
name|pmc_hw
modifier|*
name|phw
decl_stmt|;
name|KASSERT
argument_list|(
name|cpu
operator|>=
literal|0
operator|&&
name|cpu
operator|<
name|mp_ncpus
argument_list|,
operator|(
literal|"[amd,%d] illegal CPU %d"
operator|,
name|__LINE__
operator|,
name|cpu
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|ri
operator|>=
literal|0
operator|&&
name|ri
operator|<
name|AMD_NPMCS
argument_list|,
operator|(
literal|"[amd,%d] row-index %d out of range"
operator|,
name|__LINE__
operator|,
name|ri
operator|)
argument_list|)
expr_stmt|;
name|phw
operator|=
name|pmc_pcpu
index|[
name|cpu
index|]
operator|->
name|pc_hwpmcs
index|[
name|ri
index|]
expr_stmt|;
name|pd
operator|=
operator|&
name|amd_pmcdesc
index|[
name|ri
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|copystr
argument_list|(
name|pd
operator|->
name|pm_descr
operator|.
name|pd_name
argument_list|,
name|pi
operator|->
name|pm_name
argument_list|,
name|PMC_NAME_MAX
argument_list|,
operator|&
name|copied
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|error
return|;
name|pi
operator|->
name|pm_class
operator|=
name|pd
operator|->
name|pm_descr
operator|.
name|pd_class
expr_stmt|;
if|if
condition|(
name|phw
operator|->
name|phw_state
operator|&
name|PMC_PHW_FLAG_IS_ENABLED
condition|)
block|{
name|pi
operator|->
name|pm_enabled
operator|=
name|TRUE
expr_stmt|;
operator|*
name|ppmc
operator|=
name|phw
operator|->
name|phw_pmc
expr_stmt|;
block|}
else|else
block|{
name|pi
operator|->
name|pm_enabled
operator|=
name|FALSE
expr_stmt|;
operator|*
name|ppmc
operator|=
name|NULL
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * i386 specific entry points  */
end_comment

begin_comment
comment|/*  * return the MSR address of the given PMC.  */
end_comment

begin_function
specifier|static
name|int
name|amd_get_msr
parameter_list|(
name|int
name|ri
parameter_list|,
name|uint32_t
modifier|*
name|msr
parameter_list|)
block|{
name|KASSERT
argument_list|(
name|ri
operator|>=
literal|0
operator|&&
name|ri
operator|<
name|AMD_NPMCS
argument_list|,
operator|(
literal|"[amd,%d] ri %d out of range"
operator|,
name|__LINE__
operator|,
name|ri
operator|)
argument_list|)
expr_stmt|;
operator|*
name|msr
operator|=
name|amd_pmcdesc
index|[
name|ri
index|]
operator|.
name|pm_perfctr
operator|-
name|AMD_PMC_PERFCTR_0
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * processor dependent initialization.  */
end_comment

begin_comment
comment|/*  * Per-processor data structure  *  * [common stuff]  * [5 struct pmc_hw pointers]  * [5 struct pmc_hw structures]  */
end_comment

begin_struct
struct|struct
name|amd_cpu
block|{
name|struct
name|pmc_cpu
name|pc_common
decl_stmt|;
name|struct
name|pmc_hw
modifier|*
name|pc_hwpmcs
index|[
name|AMD_NPMCS
index|]
decl_stmt|;
name|struct
name|pmc_hw
name|pc_amdpmcs
index|[
name|AMD_NPMCS
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|int
name|amd_init
parameter_list|(
name|int
name|cpu
parameter_list|)
block|{
name|int
name|n
decl_stmt|;
name|struct
name|amd_cpu
modifier|*
name|pcs
decl_stmt|;
name|struct
name|pmc_hw
modifier|*
name|phw
decl_stmt|;
name|KASSERT
argument_list|(
name|cpu
operator|>=
literal|0
operator|&&
name|cpu
operator|<
name|mp_ncpus
argument_list|,
operator|(
literal|"[amd,%d] insane cpu number %d"
operator|,
name|__LINE__
operator|,
name|cpu
operator|)
argument_list|)
expr_stmt|;
name|PMCDBG
argument_list|(
name|MDP
argument_list|,
name|INI
argument_list|,
literal|1
argument_list|,
literal|"amd-init cpu=%d"
argument_list|,
name|cpu
argument_list|)
expr_stmt|;
name|MALLOC
argument_list|(
name|pcs
argument_list|,
expr|struct
name|amd_cpu
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|amd_cpu
argument_list|)
argument_list|,
name|M_PMC
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|phw
operator|=
operator|&
name|pcs
operator|->
name|pc_amdpmcs
index|[
literal|0
index|]
expr_stmt|;
comment|/* 	 * Initialize the per-cpu mutex and set the content of the 	 * hardware descriptors to a known state. 	 */
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|AMD_NPMCS
condition|;
name|n
operator|++
operator|,
name|phw
operator|++
control|)
block|{
name|phw
operator|->
name|phw_state
operator|=
name|PMC_PHW_FLAG_IS_ENABLED
operator||
name|PMC_PHW_CPU_TO_STATE
argument_list|(
name|cpu
argument_list|)
operator||
name|PMC_PHW_INDEX_TO_STATE
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|phw
operator|->
name|phw_pmc
operator|=
name|NULL
expr_stmt|;
name|pcs
operator|->
name|pc_hwpmcs
index|[
name|n
index|]
operator|=
name|phw
expr_stmt|;
block|}
comment|/* Mark the TSC as shareable */
name|pcs
operator|->
name|pc_hwpmcs
index|[
literal|0
index|]
operator|->
name|phw_state
operator||=
name|PMC_PHW_FLAG_IS_SHAREABLE
expr_stmt|;
name|pmc_pcpu
index|[
name|cpu
index|]
operator|=
operator|(
expr|struct
name|pmc_cpu
operator|*
operator|)
name|pcs
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * processor dependent cleanup prior to the KLD  * being unloaded  */
end_comment

begin_function
specifier|static
name|int
name|amd_cleanup
parameter_list|(
name|int
name|cpu
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|uint32_t
name|evsel
decl_stmt|;
name|struct
name|pmc_cpu
modifier|*
name|pcs
decl_stmt|;
name|KASSERT
argument_list|(
name|cpu
operator|>=
literal|0
operator|&&
name|cpu
operator|<
name|mp_ncpus
argument_list|,
operator|(
literal|"[amd,%d] insane cpu number (%d)"
operator|,
name|__LINE__
operator|,
name|cpu
operator|)
argument_list|)
expr_stmt|;
name|PMCDBG
argument_list|(
name|MDP
argument_list|,
name|INI
argument_list|,
literal|1
argument_list|,
literal|"amd-cleanup cpu=%d"
argument_list|,
name|cpu
argument_list|)
expr_stmt|;
comment|/* 	 * First, turn off all PMCs on this CPU. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
comment|/* XXX this loop is now not needed */
name|evsel
operator|=
name|rdmsr
argument_list|(
name|AMD_PMC_EVSEL_0
operator|+
name|i
argument_list|)
expr_stmt|;
name|evsel
operator|&=
operator|~
name|AMD_PMC_ENABLE
expr_stmt|;
name|wrmsr
argument_list|(
name|AMD_PMC_EVSEL_0
operator|+
name|i
argument_list|,
name|evsel
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Next, free up allocated space. 	 */
if|if
condition|(
operator|(
name|pcs
operator|=
name|pmc_pcpu
index|[
name|cpu
index|]
operator|)
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
if|#
directive|if
name|DEBUG
comment|/* check the TSC */
name|KASSERT
argument_list|(
name|pcs
operator|->
name|pc_hwpmcs
index|[
literal|0
index|]
operator|->
name|phw_pmc
operator|==
name|NULL
argument_list|,
operator|(
literal|"[amd,%d] CPU%d,PMC0 still in use"
operator|,
name|__LINE__
operator|,
name|cpu
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|AMD_NPMCS
condition|;
name|i
operator|++
control|)
block|{
name|KASSERT
argument_list|(
name|pcs
operator|->
name|pc_hwpmcs
index|[
name|i
index|]
operator|->
name|phw_pmc
operator|==
name|NULL
argument_list|,
operator|(
literal|"[amd,%d] CPU%d/PMC%d in use"
operator|,
name|__LINE__
operator|,
name|cpu
operator|,
name|i
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|AMD_PMC_IS_STOPPED
argument_list|(
name|AMD_PMC_EVSEL_0
operator|+
operator|(
name|i
operator|-
literal|1
operator|)
argument_list|)
argument_list|,
operator|(
literal|"[amd,%d] CPU%d/PMC%d not stopped"
operator|,
name|__LINE__
operator|,
name|cpu
operator|,
name|i
operator|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|pmc_pcpu
index|[
name|cpu
index|]
operator|=
name|NULL
expr_stmt|;
name|FREE
argument_list|(
name|pcs
argument_list|,
name|M_PMC
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Initialize ourselves.  */
end_comment

begin_function
name|struct
name|pmc_mdep
modifier|*
name|pmc_amd_initialize
parameter_list|(
name|void
parameter_list|)
block|{
name|enum
name|pmc_cputype
name|cputype
decl_stmt|;
name|enum
name|pmc_class
name|class
decl_stmt|;
name|struct
name|pmc_mdep
modifier|*
name|pmc_mdep
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* 	 * The presence of hardware performance counters on the AMD 	 * Athlon, Duron or later processors, is _not_ indicated by 	 * any of the processor feature flags set by the 'CPUID' 	 * instruction, so we only check the 'instruction family' 	 * field returned by CPUID for instruction family>= 6. 	 */
name|class
operator|=
name|cputype
operator|=
operator|-
literal|1
expr_stmt|;
name|name
operator|=
name|NULL
expr_stmt|;
switch|switch
condition|(
name|cpu_id
operator|&
literal|0xF00
condition|)
block|{
case|case
literal|0x600
case|:
comment|/* Athlon(tm) processor */
name|cputype
operator|=
name|PMC_CPU_AMD_K7
expr_stmt|;
name|class
operator|=
name|PMC_CLASS_K7
expr_stmt|;
name|name
operator|=
literal|"K7"
expr_stmt|;
break|break;
case|case
literal|0xF00
case|:
comment|/* Athlon64/Opteron processor */
name|cputype
operator|=
name|PMC_CPU_AMD_K8
expr_stmt|;
name|class
operator|=
name|PMC_CLASS_K8
expr_stmt|;
name|name
operator|=
literal|"K8"
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|int
operator|)
name|cputype
operator|==
operator|-
literal|1
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"pmc: Unknown AMD CPU.\n"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|#
directive|if
name|DEBUG
name|amd_pmc_class
operator|=
name|class
expr_stmt|;
endif|#
directive|endif
name|MALLOC
argument_list|(
name|pmc_mdep
argument_list|,
expr|struct
name|pmc_mdep
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|pmc_mdep
argument_list|)
argument_list|,
name|M_PMC
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|pmc_mdep
operator|->
name|pmd_cputype
operator|=
name|cputype
expr_stmt|;
name|pmc_mdep
operator|->
name|pmd_npmc
operator|=
name|AMD_NPMCS
expr_stmt|;
comment|/* this processor has two classes of usable PMCs */
name|pmc_mdep
operator|->
name|pmd_nclass
operator|=
literal|2
expr_stmt|;
comment|/* TSC */
name|pmc_mdep
operator|->
name|pmd_classes
index|[
literal|0
index|]
operator|.
name|pm_class
operator|=
name|PMC_CLASS_TSC
expr_stmt|;
name|pmc_mdep
operator|->
name|pmd_classes
index|[
literal|0
index|]
operator|.
name|pm_caps
operator|=
name|PMC_CAP_READ
expr_stmt|;
name|pmc_mdep
operator|->
name|pmd_classes
index|[
literal|0
index|]
operator|.
name|pm_width
operator|=
literal|64
expr_stmt|;
comment|/* AMD K7/K8 PMCs */
name|pmc_mdep
operator|->
name|pmd_classes
index|[
literal|1
index|]
operator|.
name|pm_class
operator|=
name|class
expr_stmt|;
name|pmc_mdep
operator|->
name|pmd_classes
index|[
literal|1
index|]
operator|.
name|pm_caps
operator|=
name|AMD_PMC_CAPS
expr_stmt|;
name|pmc_mdep
operator|->
name|pmd_classes
index|[
literal|1
index|]
operator|.
name|pm_width
operator|=
literal|48
expr_stmt|;
name|pmc_mdep
operator|->
name|pmd_nclasspmcs
index|[
literal|0
index|]
operator|=
literal|1
expr_stmt|;
name|pmc_mdep
operator|->
name|pmd_nclasspmcs
index|[
literal|1
index|]
operator|=
operator|(
name|AMD_NPMCS
operator|-
literal|1
operator|)
expr_stmt|;
comment|/* fill in the correct pmc name and class */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|AMD_NPMCS
condition|;
name|i
operator|++
control|)
block|{
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|amd_pmcdesc
index|[
name|i
index|]
operator|.
name|pm_descr
operator|.
name|pd_name
argument_list|,
sizeof|sizeof
argument_list|(
name|amd_pmcdesc
index|[
name|i
index|]
operator|.
name|pm_descr
operator|.
name|pd_name
argument_list|)
argument_list|,
literal|"%s-%d"
argument_list|,
name|name
argument_list|,
name|i
operator|-
literal|1
argument_list|)
expr_stmt|;
name|amd_pmcdesc
index|[
name|i
index|]
operator|.
name|pm_descr
operator|.
name|pd_class
operator|=
name|class
expr_stmt|;
block|}
name|pmc_mdep
operator|->
name|pmd_init
operator|=
name|amd_init
expr_stmt|;
name|pmc_mdep
operator|->
name|pmd_cleanup
operator|=
name|amd_cleanup
expr_stmt|;
name|pmc_mdep
operator|->
name|pmd_switch_in
operator|=
name|amd_switch_in
expr_stmt|;
name|pmc_mdep
operator|->
name|pmd_switch_out
operator|=
name|amd_switch_out
expr_stmt|;
name|pmc_mdep
operator|->
name|pmd_read_pmc
operator|=
name|amd_read_pmc
expr_stmt|;
name|pmc_mdep
operator|->
name|pmd_write_pmc
operator|=
name|amd_write_pmc
expr_stmt|;
name|pmc_mdep
operator|->
name|pmd_config_pmc
operator|=
name|amd_config_pmc
expr_stmt|;
name|pmc_mdep
operator|->
name|pmd_get_config
operator|=
name|amd_get_config
expr_stmt|;
name|pmc_mdep
operator|->
name|pmd_allocate_pmc
operator|=
name|amd_allocate_pmc
expr_stmt|;
name|pmc_mdep
operator|->
name|pmd_release_pmc
operator|=
name|amd_release_pmc
expr_stmt|;
name|pmc_mdep
operator|->
name|pmd_start_pmc
operator|=
name|amd_start_pmc
expr_stmt|;
name|pmc_mdep
operator|->
name|pmd_stop_pmc
operator|=
name|amd_stop_pmc
expr_stmt|;
name|pmc_mdep
operator|->
name|pmd_intr
operator|=
name|amd_intr
expr_stmt|;
name|pmc_mdep
operator|->
name|pmd_describe
operator|=
name|amd_describe
expr_stmt|;
name|pmc_mdep
operator|->
name|pmd_get_msr
operator|=
name|amd_get_msr
expr_stmt|;
comment|/* i386 */
name|PMCDBG
argument_list|(
name|MDP
argument_list|,
name|INI
argument_list|,
literal|0
argument_list|,
literal|"%s"
argument_list|,
literal|"amd-initialize"
argument_list|)
expr_stmt|;
return|return
name|pmc_mdep
return|;
block|}
end_function

end_unit

