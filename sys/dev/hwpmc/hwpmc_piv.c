begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2003-2005 Joseph Koshy  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/pmc.h>
end_include

begin_include
include|#
directive|include
file|<sys/pmckern.h>
end_include

begin_include
include|#
directive|include
file|<sys/smp.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<machine/cpufunc.h>
end_include

begin_include
include|#
directive|include
file|<machine/md_var.h>
end_include

begin_include
include|#
directive|include
file|<machine/specialreg.h>
end_include

begin_comment
comment|/*  * PENTIUM 4 SUPPORT  *  * The P4 has 18 PMCs, divided into 4 groups with 4,4,4 and 6 PMCs  * respectively.  Each PMC comprises of two model specific registers:  * a counter configuration control register (CCCR) and a counter  * register that holds the actual event counts.  *  * Configuring an event requires the use of one of 45 event selection  * control registers (ESCR).  Events are associated with specific  * ESCRs.  Each PMC group has a set of ESCRs it can use.  *  * - The BPU counter group (4 PMCs) can use the 16 ESCRs:  *   BPU_ESCR{0,1}, IS_ESCR{0,1}, MOB_ESCR{0,1}, ITLB_ESCR{0,1},  *   PMH_ESCR{0,1}, IX_ESCR{0,1}, FSB_ESCR{0,}, BSU_ESCR{0,1}.  *  * - The MS counter group (4 PMCs) can use the 6 ESCRs: MS_ESCR{0,1},  *   TC_ESCR{0,1}, TBPU_ESCR{0,1}.  *  * - The FLAME counter group (4 PMCs) can use the 10 ESCRs:  *   FLAME_ESCR{0,1}, FIRM_ESCR{0,1}, SAAT_ESCR{0,1}, U2L_ESCR{0,1},  *   DAC_ESCR{0,1}.  *  * - The IQ counter group (6 PMCs) can use the 13 ESCRs: IQ_ESCR{0,1},  *   ALF_ESCR{0,1}, RAT_ESCR{0,1}, SSU_ESCR0, CRU_ESCR{0,1,2,3,4,5}.  *  * Even-numbered ESCRs can be used with counters 0, 1 and 4 (if  * present) of a counter group.  Odd-numbers ESCRs can be used with  * counters 2, 3 and 5 (if present) of a counter group.  The  * 'p4_escrs[]' table describes these restrictions in a form that  * function 'p4_allocate()' uses for making allocation decisions.  *  * SYSTEM-MODE AND THREAD-MODE ALLOCATION  *  * In addition to remembering the state of PMC rows  * ('FREE','STANDALONE', or 'THREAD'), we similar need to track the  * state of ESCR rows.  If an ESCR is allocated to a system-mode PMC  * on a CPU we cannot allocate this to a thread-mode PMC.  On a  * multi-cpu (multiple physical CPUs) system, ESCR allocation on each  * CPU is tracked by the pc_escrs[] array.  *  * Each system-mode PMC that is using an ESCR records its row-index in  * the appropriate entry and system-mode allocation attempts check  * that an ESCR is available using this array.  Process-mode PMCs do  * not use the pc_escrs[] array, since ESCR row itself would have been  * marked as in 'THREAD' mode.  *  * HYPERTHREADING SUPPORT  *  * When HTT is enabled, the FreeBSD kernel treats the two 'logical'  * cpus as independent CPUs and can schedule kernel threads on them  * independently.  However, the two logical CPUs share the same set of  * PMC resources.  We need to ensure that:  * - PMCs that use the PMC_F_DESCENDANTS semantics are handled correctly,  *   and,  * - Threads of multi-threaded processes that get scheduled on the same  *   physical CPU are handled correctly.  *  * HTT Detection  *  * Not all HTT capable systems will have HTT enabled since users may  * have turned HTT support off using the appropriate sysctls  * (machdep.hlt_logical_cpus or machdep.logical_cpus_mask).  We detect  * the presence of HTT by remembering if 'p4_init()' was called for a  * logical CPU.  Note that hwpmc(4) cannot deal with a change in HTT  * status once it is loaded.  *  * Handling HTT READ / WRITE / START / STOP  *  * PMC resources are shared across multiple logical CPUs.  In each  * physical CPU's state we keep track of a 'runcount' which reflects  * the number of PMC-using processes that have been scheduled on the  * logical CPUs of this physical CPU.  Process-mode PMC operations  * will actually 'start' or 'stop' hardware only if these are the  * first or last processes respectively to use the hardware.  PMC  * values written by a 'write' operation are saved and are transferred  * to hardware at PMC 'start' time if the runcount is 0.  If the  * runcount is greater than 0 at the time of a 'start' operation, we  * keep track of the actual hardware value at the time of the 'start'  * operation and use this to adjust the final readings at PMC 'stop'  * or 'read' time.  *  * Execution sequences:  *  * Case 1:   CPUx   +...-		(no overlap)  *	     CPUy         +...-  *           RC   0 1   0 1   0  *  * Case 2:   CPUx   +........-		(partial overlap)  * 	     CPUy       +........-  *           RC   0 1   2    1   0  *  * Case 3:   CPUx   +..............-	(fully overlapped)  *	     CPUy       +.....-  *	     RC   0 1   2     1    0  *  *     Key:  *     'CPU[xy]' : one of the two logical processors on a HTT CPU.  *     'RC'      : run count (#threads per physical core).  *     '+'       : point in time when a thread is put on a CPU.  *     '-'       : point in time where a thread is taken off a CPU.  *  * Handling HTT CONFIG  *  * Different processes attached to the same PMC may get scheduled on  * the two logical processors in the package.  We keep track of config  * and de-config operations using the CFGFLAGS fields of the per-physical  * cpu state.  */
end_comment

begin_define
define|#
directive|define
name|P4_PMCS
parameter_list|()
define|\
value|P4_PMC(BPU_COUNTER0)			\ 	P4_PMC(BPU_COUNTER1)			\ 	P4_PMC(BPU_COUNTER2)			\ 	P4_PMC(BPU_COUNTER3)			\ 	P4_PMC(MS_COUNTER0)			\ 	P4_PMC(MS_COUNTER1)			\ 	P4_PMC(MS_COUNTER2)			\ 	P4_PMC(MS_COUNTER3)			\ 	P4_PMC(FLAME_COUNTER0)			\ 	P4_PMC(FLAME_COUNTER1)			\ 	P4_PMC(FLAME_COUNTER2)			\ 	P4_PMC(FLAME_COUNTER3)			\ 	P4_PMC(IQ_COUNTER0)			\ 	P4_PMC(IQ_COUNTER1)			\ 	P4_PMC(IQ_COUNTER2)			\ 	P4_PMC(IQ_COUNTER3)			\ 	P4_PMC(IQ_COUNTER4)			\ 	P4_PMC(IQ_COUNTER5)			\ 	P4_PMC(NONE)
end_define

begin_enum
enum|enum
name|pmc_p4pmc
block|{
undef|#
directive|undef
name|P4_PMC
define|#
directive|define
name|P4_PMC
parameter_list|(
name|N
parameter_list|)
value|P4_PMC_##N ,
name|P4_PMCS
argument_list|()
block|}
enum|;
end_enum

begin_comment
comment|/*  * P4 ESCR descriptors  */
end_comment

begin_define
define|#
directive|define
name|P4_ESCRS
parameter_list|()
define|\
value|P4_ESCR(BSU_ESCR0,	0x3A0, BPU_COUNTER0, BPU_COUNTER1, NONE)	\     P4_ESCR(BSU_ESCR1,	0x3A1, BPU_COUNTER2, BPU_COUNTER3, NONE)	\     P4_ESCR(FSB_ESCR0,	0x3A2, BPU_COUNTER0, BPU_COUNTER1, NONE)	\     P4_ESCR(FSB_ESCR1,	0x3A3, BPU_COUNTER2, BPU_COUNTER3, NONE)	\     P4_ESCR(FIRM_ESCR0,	0x3A4, FLAME_COUNTER0, FLAME_COUNTER1, NONE)	\     P4_ESCR(FIRM_ESCR1,	0x3A5, FLAME_COUNTER2, FLAME_COUNTER3, NONE)	\     P4_ESCR(FLAME_ESCR0, 0x3A6, FLAME_COUNTER0, FLAME_COUNTER1, NONE)	\     P4_ESCR(FLAME_ESCR1, 0x3A7, FLAME_COUNTER2, FLAME_COUNTER3, NONE)	\     P4_ESCR(DAC_ESCR0,	0x3A8, FLAME_COUNTER0, FLAME_COUNTER1, NONE)	\     P4_ESCR(DAC_ESCR1,	0x3A9, FLAME_COUNTER2, FLAME_COUNTER3, NONE)	\     P4_ESCR(MOB_ESCR0,	0x3AA, BPU_COUNTER0, BPU_COUNTER1, NONE)	\     P4_ESCR(MOB_ESCR1,	0x3AB, BPU_COUNTER2, BPU_COUNTER3, NONE)	\     P4_ESCR(PMH_ESCR0,	0x3AC, BPU_COUNTER0, BPU_COUNTER1, NONE)	\     P4_ESCR(PMH_ESCR1,	0x3AD, BPU_COUNTER2, BPU_COUNTER3, NONE)	\     P4_ESCR(SAAT_ESCR0,	0x3AE, FLAME_COUNTER0, FLAME_COUNTER1, NONE)	\     P4_ESCR(SAAT_ESCR1,	0x3AF, FLAME_COUNTER2, FLAME_COUNTER3, NONE)	\     P4_ESCR(U2L_ESCR0,	0x3B0, FLAME_COUNTER0, FLAME_COUNTER1, NONE)	\     P4_ESCR(U2L_ESCR1,	0x3B1, FLAME_COUNTER2, FLAME_COUNTER3, NONE)	\     P4_ESCR(BPU_ESCR0,	0x3B2, BPU_COUNTER0, BPU_COUNTER1, NONE)	\     P4_ESCR(BPU_ESCR1,	0x3B3, BPU_COUNTER2, BPU_COUNTER3, NONE)	\     P4_ESCR(IS_ESCR0,	0x3B4, BPU_COUNTER0, BPU_COUNTER1, NONE)	\     P4_ESCR(IS_ESCR1,	0x3B5, BPU_COUNTER2, BPU_COUNTER3, NONE)	\     P4_ESCR(ITLB_ESCR0,	0x3B6, BPU_COUNTER0, BPU_COUNTER1, NONE)	\     P4_ESCR(ITLB_ESCR1,	0x3B7, BPU_COUNTER2, BPU_COUNTER3, NONE)	\     P4_ESCR(CRU_ESCR0,	0x3B8, IQ_COUNTER0, IQ_COUNTER1, IQ_COUNTER4)	\     P4_ESCR(CRU_ESCR1,	0x3B9, IQ_COUNTER2, IQ_COUNTER3, IQ_COUNTER5)	\     P4_ESCR(IQ_ESCR0,	0x3BA, IQ_COUNTER0, IQ_COUNTER1, IQ_COUNTER4)	\     P4_ESCR(IQ_ESCR1,	0x3BB, IQ_COUNTER1, IQ_COUNTER3, IQ_COUNTER5)	\     P4_ESCR(RAT_ESCR0,	0x3BC, IQ_COUNTER0, IQ_COUNTER1, IQ_COUNTER4)	\     P4_ESCR(RAT_ESCR1,	0x3BD, IQ_COUNTER2, IQ_COUNTER3, IQ_COUNTER5)	\     P4_ESCR(SSU_ESCR0,	0x3BE, IQ_COUNTER0, IQ_COUNTER2, IQ_COUNTER4)	\     P4_ESCR(MS_ESCR0,	0x3C0, MS_COUNTER0, MS_COUNTER1, NONE)		\     P4_ESCR(MS_ESCR1,	0x3C1, MS_COUNTER2, MS_COUNTER3, NONE)		\     P4_ESCR(TBPU_ESCR0,	0x3C2, MS_COUNTER0, MS_COUNTER1, NONE)		\     P4_ESCR(TBPU_ESCR1,	0x3C3, MS_COUNTER2, MS_COUNTER3, NONE)		\     P4_ESCR(TC_ESCR0,	0x3C4, MS_COUNTER0, MS_COUNTER1, NONE)		\     P4_ESCR(TC_ESCR1,	0x3C5, MS_COUNTER2, MS_COUNTER3, NONE)		\     P4_ESCR(IX_ESCR0,	0x3C8, BPU_COUNTER0, BPU_COUNTER1, NONE)	\     P4_ESCR(IX_ESCR1,	0x3C9, BPU_COUNTER2, BPU_COUNTER3, NONE)	\     P4_ESCR(ALF_ESCR0,	0x3CA, IQ_COUNTER0, IQ_COUNTER1, IQ_COUNTER4)	\     P4_ESCR(ALF_ESCR1,	0x3CB, IQ_COUNTER2, IQ_COUNTER3, IQ_COUNTER5)	\     P4_ESCR(CRU_ESCR2,	0x3CC, IQ_COUNTER0, IQ_COUNTER1, IQ_COUNTER4)	\     P4_ESCR(CRU_ESCR3,	0x3CD, IQ_COUNTER2, IQ_COUNTER3, IQ_COUNTER5)	\     P4_ESCR(CRU_ESCR4,	0x3E0, IQ_COUNTER0, IQ_COUNTER1, IQ_COUNTER4)	\     P4_ESCR(CRU_ESCR5,	0x3E1, IQ_COUNTER2, IQ_COUNTER3, IQ_COUNTER5)	\     P4_ESCR(NONE,		~0,    NONE, NONE, NONE)
end_define

begin_enum
enum|enum
name|pmc_p4escr
block|{
define|#
directive|define
name|P4_ESCR
parameter_list|(
name|N
parameter_list|,
name|MSR
parameter_list|,
name|P1
parameter_list|,
name|P2
parameter_list|,
name|P3
parameter_list|)
value|P4_ESCR_##N ,
name|P4_ESCRS
argument_list|()
undef|#
directive|undef
name|P4_ESCR
block|}
enum|;
end_enum

begin_struct
struct|struct
name|pmc_p4escr_descr
block|{
specifier|const
name|char
name|pm_escrname
index|[
name|PMC_NAME_MAX
index|]
decl_stmt|;
name|u_short
name|pm_escr_msr
decl_stmt|;
specifier|const
name|enum
name|pmc_p4pmc
name|pm_pmcs
index|[
name|P4_MAX_PMC_PER_ESCR
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|pmc_p4escr_descr
name|p4_escrs
index|[]
init|=
block|{
define|#
directive|define
name|P4_ESCR
parameter_list|(
name|N
parameter_list|,
name|MSR
parameter_list|,
name|P1
parameter_list|,
name|P2
parameter_list|,
name|P3
parameter_list|)
define|\
value|{					\ 		.pm_escrname = #N,		\ 		.pm_escr_msr = (MSR),		\ 		.pm_pmcs =			\ 		{				\ 			P4_PMC_##P1,		\ 			P4_PMC_##P2,		\ 			P4_PMC_##P3		\ 		}				\ 	} ,
name|P4_ESCRS
argument_list|()
undef|#
directive|undef
name|P4_ESCR
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * P4 Event descriptor  */
end_comment

begin_struct
struct|struct
name|p4_event_descr
block|{
specifier|const
name|enum
name|pmc_event
name|pm_event
decl_stmt|;
specifier|const
name|uint32_t
name|pm_escr_eventselect
decl_stmt|;
specifier|const
name|uint32_t
name|pm_cccr_select
decl_stmt|;
specifier|const
name|char
name|pm_is_ti_event
decl_stmt|;
name|enum
name|pmc_p4escr
name|pm_escrs
index|[
name|P4_MAX_ESCR_PER_EVENT
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|p4_event_descr
name|p4_events
index|[]
init|=
block|{
define|#
directive|define
name|P4_EVDESCR
parameter_list|(
name|NAME
parameter_list|,
name|ESCREVENTSEL
parameter_list|,
name|CCCRSEL
parameter_list|,
name|TI_EVENT
parameter_list|,
name|ESCR0
parameter_list|,
name|ESCR1
parameter_list|)
define|\
value|{								\ 		.pm_event            = PMC_EV_P4_##NAME,		\ 		.pm_escr_eventselect = (ESCREVENTSEL),			\ 		.pm_cccr_select      = (CCCRSEL),			\ 		.pm_is_ti_event	     = (TI_EVENT),			\ 		.pm_escrs            =					\ 		{							\ 			P4_ESCR_##ESCR0,				\ 			P4_ESCR_##ESCR1					\ 		}							\ 	}
name|P4_EVDESCR
argument_list|(
name|TC_DELIVER_MODE
argument_list|,
literal|0x01
argument_list|,
literal|0x01
argument_list|,
name|TRUE
argument_list|,
name|TC_ESCR0
argument_list|,
name|TC_ESCR1
argument_list|)
block|,
name|P4_EVDESCR
argument_list|(
name|BPU_FETCH_REQUEST
argument_list|,
literal|0x03
argument_list|,
literal|0x00
argument_list|,
name|FALSE
argument_list|,
name|BPU_ESCR0
argument_list|,
name|BPU_ESCR1
argument_list|)
block|,
name|P4_EVDESCR
argument_list|(
name|ITLB_REFERENCE
argument_list|,
literal|0x18
argument_list|,
literal|0x03
argument_list|,
name|FALSE
argument_list|,
name|ITLB_ESCR0
argument_list|,
name|ITLB_ESCR1
argument_list|)
block|,
name|P4_EVDESCR
argument_list|(
name|MEMORY_CANCEL
argument_list|,
literal|0x02
argument_list|,
literal|0x05
argument_list|,
name|FALSE
argument_list|,
name|DAC_ESCR0
argument_list|,
name|DAC_ESCR1
argument_list|)
block|,
name|P4_EVDESCR
argument_list|(
name|MEMORY_COMPLETE
argument_list|,
literal|0x08
argument_list|,
literal|0x02
argument_list|,
name|FALSE
argument_list|,
name|SAAT_ESCR0
argument_list|,
name|SAAT_ESCR1
argument_list|)
block|,
name|P4_EVDESCR
argument_list|(
name|LOAD_PORT_REPLAY
argument_list|,
literal|0x04
argument_list|,
literal|0x02
argument_list|,
name|FALSE
argument_list|,
name|SAAT_ESCR0
argument_list|,
name|SAAT_ESCR1
argument_list|)
block|,
name|P4_EVDESCR
argument_list|(
name|STORE_PORT_REPLAY
argument_list|,
literal|0x05
argument_list|,
literal|0x02
argument_list|,
name|FALSE
argument_list|,
name|SAAT_ESCR0
argument_list|,
name|SAAT_ESCR1
argument_list|)
block|,
name|P4_EVDESCR
argument_list|(
name|MOB_LOAD_REPLAY
argument_list|,
literal|0x03
argument_list|,
literal|0x02
argument_list|,
name|FALSE
argument_list|,
name|MOB_ESCR0
argument_list|,
name|MOB_ESCR1
argument_list|)
block|,
name|P4_EVDESCR
argument_list|(
name|PAGE_WALK_TYPE
argument_list|,
literal|0x01
argument_list|,
literal|0x04
argument_list|,
name|TRUE
argument_list|,
name|PMH_ESCR0
argument_list|,
name|PMH_ESCR1
argument_list|)
block|,
name|P4_EVDESCR
argument_list|(
name|BSQ_CACHE_REFERENCE
argument_list|,
literal|0x0C
argument_list|,
literal|0x07
argument_list|,
name|FALSE
argument_list|,
name|BSU_ESCR0
argument_list|,
name|BSU_ESCR1
argument_list|)
block|,
name|P4_EVDESCR
argument_list|(
name|IOQ_ALLOCATION
argument_list|,
literal|0x03
argument_list|,
literal|0x06
argument_list|,
name|FALSE
argument_list|,
name|FSB_ESCR0
argument_list|,
name|FSB_ESCR1
argument_list|)
block|,
name|P4_EVDESCR
argument_list|(
name|IOQ_ACTIVE_ENTRIES
argument_list|,
literal|0x1A
argument_list|,
literal|0x06
argument_list|,
name|FALSE
argument_list|,
name|FSB_ESCR1
argument_list|,
name|NONE
argument_list|)
block|,
name|P4_EVDESCR
argument_list|(
name|FSB_DATA_ACTIVITY
argument_list|,
literal|0x17
argument_list|,
literal|0x06
argument_list|,
name|TRUE
argument_list|,
name|FSB_ESCR0
argument_list|,
name|FSB_ESCR1
argument_list|)
block|,
name|P4_EVDESCR
argument_list|(
name|BSQ_ALLOCATION
argument_list|,
literal|0x05
argument_list|,
literal|0x07
argument_list|,
name|FALSE
argument_list|,
name|BSU_ESCR0
argument_list|,
name|NONE
argument_list|)
block|,
name|P4_EVDESCR
argument_list|(
name|BSQ_ACTIVE_ENTRIES
argument_list|,
literal|0x06
argument_list|,
literal|0x07
argument_list|,
name|FALSE
argument_list|,
name|BSU_ESCR1
argument_list|,
name|NONE
argument_list|)
block|,
comment|/* BSQ_ACTIVE_ENTRIES inherits CPU specificity from BSQ_ALLOCATION */
name|P4_EVDESCR
argument_list|(
name|SSE_INPUT_ASSIST
argument_list|,
literal|0x34
argument_list|,
literal|0x01
argument_list|,
name|TRUE
argument_list|,
name|FIRM_ESCR0
argument_list|,
name|FIRM_ESCR1
argument_list|)
block|,
name|P4_EVDESCR
argument_list|(
name|PACKED_SP_UOP
argument_list|,
literal|0x08
argument_list|,
literal|0x01
argument_list|,
name|TRUE
argument_list|,
name|FIRM_ESCR0
argument_list|,
name|FIRM_ESCR1
argument_list|)
block|,
name|P4_EVDESCR
argument_list|(
name|PACKED_DP_UOP
argument_list|,
literal|0x0C
argument_list|,
literal|0x01
argument_list|,
name|TRUE
argument_list|,
name|FIRM_ESCR0
argument_list|,
name|FIRM_ESCR1
argument_list|)
block|,
name|P4_EVDESCR
argument_list|(
name|SCALAR_SP_UOP
argument_list|,
literal|0x0A
argument_list|,
literal|0x01
argument_list|,
name|TRUE
argument_list|,
name|FIRM_ESCR0
argument_list|,
name|FIRM_ESCR1
argument_list|)
block|,
name|P4_EVDESCR
argument_list|(
name|SCALAR_DP_UOP
argument_list|,
literal|0x0E
argument_list|,
literal|0x01
argument_list|,
name|TRUE
argument_list|,
name|FIRM_ESCR0
argument_list|,
name|FIRM_ESCR1
argument_list|)
block|,
name|P4_EVDESCR
argument_list|(
literal|64BIT_MMX_UOP
argument_list|,
literal|0x02
argument_list|,
literal|0x01
argument_list|,
name|TRUE
argument_list|,
name|FIRM_ESCR0
argument_list|,
name|FIRM_ESCR1
argument_list|)
block|,
name|P4_EVDESCR
argument_list|(
literal|128BIT_MMX_UOP
argument_list|,
literal|0x1A
argument_list|,
literal|0x01
argument_list|,
name|TRUE
argument_list|,
name|FIRM_ESCR0
argument_list|,
name|FIRM_ESCR1
argument_list|)
block|,
name|P4_EVDESCR
argument_list|(
name|X87_FP_UOP
argument_list|,
literal|0x04
argument_list|,
literal|0x01
argument_list|,
name|TRUE
argument_list|,
name|FIRM_ESCR0
argument_list|,
name|FIRM_ESCR1
argument_list|)
block|,
name|P4_EVDESCR
argument_list|(
name|X87_SIMD_MOVES_UOP
argument_list|,
literal|0x2E
argument_list|,
literal|0x01
argument_list|,
name|TRUE
argument_list|,
name|FIRM_ESCR0
argument_list|,
name|FIRM_ESCR1
argument_list|)
block|,
name|P4_EVDESCR
argument_list|(
name|GLOBAL_POWER_EVENTS
argument_list|,
literal|0x13
argument_list|,
literal|0x06
argument_list|,
name|FALSE
argument_list|,
name|FSB_ESCR0
argument_list|,
name|FSB_ESCR1
argument_list|)
block|,
name|P4_EVDESCR
argument_list|(
name|TC_MS_XFER
argument_list|,
literal|0x05
argument_list|,
literal|0x00
argument_list|,
name|FALSE
argument_list|,
name|MS_ESCR0
argument_list|,
name|MS_ESCR1
argument_list|)
block|,
name|P4_EVDESCR
argument_list|(
name|UOP_QUEUE_WRITES
argument_list|,
literal|0x09
argument_list|,
literal|0x00
argument_list|,
name|FALSE
argument_list|,
name|MS_ESCR0
argument_list|,
name|MS_ESCR1
argument_list|)
block|,
name|P4_EVDESCR
argument_list|(
name|RETIRED_MISPRED_BRANCH_TYPE
argument_list|,
literal|0x05
argument_list|,
literal|0x02
argument_list|,
name|FALSE
argument_list|,
name|TBPU_ESCR0
argument_list|,
name|TBPU_ESCR1
argument_list|)
block|,
name|P4_EVDESCR
argument_list|(
name|RETIRED_BRANCH_TYPE
argument_list|,
literal|0x04
argument_list|,
literal|0x02
argument_list|,
name|FALSE
argument_list|,
name|TBPU_ESCR0
argument_list|,
name|TBPU_ESCR1
argument_list|)
block|,
name|P4_EVDESCR
argument_list|(
name|RESOURCE_STALL
argument_list|,
literal|0x01
argument_list|,
literal|0x01
argument_list|,
name|FALSE
argument_list|,
name|ALF_ESCR0
argument_list|,
name|ALF_ESCR1
argument_list|)
block|,
name|P4_EVDESCR
argument_list|(
name|WC_BUFFER
argument_list|,
literal|0x05
argument_list|,
literal|0x05
argument_list|,
name|TRUE
argument_list|,
name|DAC_ESCR0
argument_list|,
name|DAC_ESCR1
argument_list|)
block|,
name|P4_EVDESCR
argument_list|(
name|B2B_CYCLES
argument_list|,
literal|0x16
argument_list|,
literal|0x03
argument_list|,
name|TRUE
argument_list|,
name|FSB_ESCR0
argument_list|,
name|FSB_ESCR1
argument_list|)
block|,
name|P4_EVDESCR
argument_list|(
name|BNR
argument_list|,
literal|0x08
argument_list|,
literal|0x03
argument_list|,
name|TRUE
argument_list|,
name|FSB_ESCR0
argument_list|,
name|FSB_ESCR1
argument_list|)
block|,
name|P4_EVDESCR
argument_list|(
name|SNOOP
argument_list|,
literal|0x06
argument_list|,
literal|0x03
argument_list|,
name|TRUE
argument_list|,
name|FSB_ESCR0
argument_list|,
name|FSB_ESCR1
argument_list|)
block|,
name|P4_EVDESCR
argument_list|(
name|RESPONSE
argument_list|,
literal|0x04
argument_list|,
literal|0x03
argument_list|,
name|TRUE
argument_list|,
name|FSB_ESCR0
argument_list|,
name|FSB_ESCR1
argument_list|)
block|,
name|P4_EVDESCR
argument_list|(
name|FRONT_END_EVENT
argument_list|,
literal|0x08
argument_list|,
literal|0x05
argument_list|,
name|FALSE
argument_list|,
name|CRU_ESCR2
argument_list|,
name|CRU_ESCR3
argument_list|)
block|,
name|P4_EVDESCR
argument_list|(
name|EXECUTION_EVENT
argument_list|,
literal|0x0C
argument_list|,
literal|0x05
argument_list|,
name|FALSE
argument_list|,
name|CRU_ESCR2
argument_list|,
name|CRU_ESCR3
argument_list|)
block|,
name|P4_EVDESCR
argument_list|(
name|REPLAY_EVENT
argument_list|,
literal|0x09
argument_list|,
literal|0x05
argument_list|,
name|FALSE
argument_list|,
name|CRU_ESCR2
argument_list|,
name|CRU_ESCR3
argument_list|)
block|,
name|P4_EVDESCR
argument_list|(
name|INSTR_RETIRED
argument_list|,
literal|0x02
argument_list|,
literal|0x04
argument_list|,
name|FALSE
argument_list|,
name|CRU_ESCR0
argument_list|,
name|CRU_ESCR1
argument_list|)
block|,
name|P4_EVDESCR
argument_list|(
name|UOPS_RETIRED
argument_list|,
literal|0x01
argument_list|,
literal|0x04
argument_list|,
name|FALSE
argument_list|,
name|CRU_ESCR0
argument_list|,
name|CRU_ESCR1
argument_list|)
block|,
name|P4_EVDESCR
argument_list|(
name|UOP_TYPE
argument_list|,
literal|0x02
argument_list|,
literal|0x02
argument_list|,
name|FALSE
argument_list|,
name|RAT_ESCR0
argument_list|,
name|RAT_ESCR1
argument_list|)
block|,
name|P4_EVDESCR
argument_list|(
name|BRANCH_RETIRED
argument_list|,
literal|0x06
argument_list|,
literal|0x05
argument_list|,
name|FALSE
argument_list|,
name|CRU_ESCR2
argument_list|,
name|CRU_ESCR3
argument_list|)
block|,
name|P4_EVDESCR
argument_list|(
name|MISPRED_BRANCH_RETIRED
argument_list|,
literal|0x03
argument_list|,
literal|0x04
argument_list|,
name|FALSE
argument_list|,
name|CRU_ESCR0
argument_list|,
name|CRU_ESCR1
argument_list|)
block|,
name|P4_EVDESCR
argument_list|(
name|X87_ASSIST
argument_list|,
literal|0x03
argument_list|,
literal|0x05
argument_list|,
name|FALSE
argument_list|,
name|CRU_ESCR2
argument_list|,
name|CRU_ESCR3
argument_list|)
block|,
name|P4_EVDESCR
argument_list|(
argument|MACHINE_CLEAR
argument_list|,
literal|0x02
argument_list|,
literal|0x05
argument_list|,
argument|FALSE
argument_list|,
argument|CRU_ESCR2
argument_list|,
argument|CRU_ESCR3
argument_list|)
undef|#
directive|undef
name|P4_EVDESCR
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|P4_EVENT_IS_TI
parameter_list|(
name|E
parameter_list|)
value|((E)->pm_is_ti_event == TRUE)
end_define

begin_define
define|#
directive|define
name|P4_NEVENTS
value|(PMC_EV_P4_LAST - PMC_EV_P4_FIRST + 1)
end_define

begin_comment
comment|/*  * P4 PMC descriptors  */
end_comment

begin_struct
struct|struct
name|p4pmc_descr
block|{
name|struct
name|pmc_descr
name|pm_descr
decl_stmt|;
comment|/* common information */
name|enum
name|pmc_p4pmc
name|pm_pmcnum
decl_stmt|;
comment|/* PMC number */
name|uint32_t
name|pm_pmc_msr
decl_stmt|;
comment|/* PERFCTR MSR address */
name|uint32_t
name|pm_cccr_msr
decl_stmt|;
comment|/* CCCR MSR address */
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|p4pmc_descr
name|p4_pmcdesc
index|[
name|P4_NPMCS
index|]
init|=
block|{
comment|/* 	 * TSC descriptor 	 */
block|{
operator|.
name|pm_descr
operator|=
block|{
operator|.
name|pd_name
operator|=
literal|"TSC"
block|,
operator|.
name|pd_class
operator|=
name|PMC_CLASS_TSC
block|,
operator|.
name|pd_caps
operator|=
name|PMC_CAP_READ
operator||
name|PMC_CAP_WRITE
block|,
operator|.
name|pd_width
operator|=
literal|64
block|}
block|,
operator|.
name|pm_pmcnum
operator|=
operator|~
literal|0
block|,
operator|.
name|pm_cccr_msr
operator|=
operator|~
literal|0
block|,
operator|.
name|pm_pmc_msr
operator|=
literal|0x10
block|, 	}
block|,
comment|/* 	 * P4 PMCS 	 */
define|#
directive|define
name|P4_PMC_CAPS
value|(PMC_CAP_INTERRUPT | PMC_CAP_USER | PMC_CAP_SYSTEM |  \ 	PMC_CAP_EDGE | PMC_CAP_THRESHOLD | PMC_CAP_READ | PMC_CAP_WRITE | \ 	PMC_CAP_INVERT | PMC_CAP_QUALIFIER | PMC_CAP_PRECISE |            \ 	PMC_CAP_TAGGING | PMC_CAP_CASCADE)
define|#
directive|define
name|P4_PMCDESCR
parameter_list|(
name|N
parameter_list|,
name|PMC
parameter_list|,
name|CCCR
parameter_list|)
define|\
value|{						\ 		.pm_descr =				\ 		{					\ 			.pd_name = #N,			\ 			.pd_class = PMC_CLASS_P4,	\ 			.pd_caps = P4_PMC_CAPS,		\ 			.pd_width = 40			\ 		},					\ 		.pm_pmcnum      = P4_PMC_##N,		\ 		.pm_cccr_msr 	= (CCCR),		\ 		.pm_pmc_msr	= (PMC)			\ 	}
name|P4_PMCDESCR
argument_list|(
name|BPU_COUNTER0
argument_list|,
literal|0x300
argument_list|,
literal|0x360
argument_list|)
block|,
name|P4_PMCDESCR
argument_list|(
name|BPU_COUNTER1
argument_list|,
literal|0x301
argument_list|,
literal|0x361
argument_list|)
block|,
name|P4_PMCDESCR
argument_list|(
name|BPU_COUNTER2
argument_list|,
literal|0x302
argument_list|,
literal|0x362
argument_list|)
block|,
name|P4_PMCDESCR
argument_list|(
name|BPU_COUNTER3
argument_list|,
literal|0x303
argument_list|,
literal|0x363
argument_list|)
block|,
name|P4_PMCDESCR
argument_list|(
name|MS_COUNTER0
argument_list|,
literal|0x304
argument_list|,
literal|0x364
argument_list|)
block|,
name|P4_PMCDESCR
argument_list|(
name|MS_COUNTER1
argument_list|,
literal|0x305
argument_list|,
literal|0x365
argument_list|)
block|,
name|P4_PMCDESCR
argument_list|(
name|MS_COUNTER2
argument_list|,
literal|0x306
argument_list|,
literal|0x366
argument_list|)
block|,
name|P4_PMCDESCR
argument_list|(
name|MS_COUNTER3
argument_list|,
literal|0x307
argument_list|,
literal|0x367
argument_list|)
block|,
name|P4_PMCDESCR
argument_list|(
name|FLAME_COUNTER0
argument_list|,
literal|0x308
argument_list|,
literal|0x368
argument_list|)
block|,
name|P4_PMCDESCR
argument_list|(
name|FLAME_COUNTER1
argument_list|,
literal|0x309
argument_list|,
literal|0x369
argument_list|)
block|,
name|P4_PMCDESCR
argument_list|(
name|FLAME_COUNTER2
argument_list|,
literal|0x30A
argument_list|,
literal|0x36A
argument_list|)
block|,
name|P4_PMCDESCR
argument_list|(
name|FLAME_COUNTER3
argument_list|,
literal|0x30B
argument_list|,
literal|0x36B
argument_list|)
block|,
name|P4_PMCDESCR
argument_list|(
name|IQ_COUNTER0
argument_list|,
literal|0x30C
argument_list|,
literal|0x36C
argument_list|)
block|,
name|P4_PMCDESCR
argument_list|(
name|IQ_COUNTER1
argument_list|,
literal|0x30D
argument_list|,
literal|0x36D
argument_list|)
block|,
name|P4_PMCDESCR
argument_list|(
name|IQ_COUNTER2
argument_list|,
literal|0x30E
argument_list|,
literal|0x36E
argument_list|)
block|,
name|P4_PMCDESCR
argument_list|(
name|IQ_COUNTER3
argument_list|,
literal|0x30F
argument_list|,
literal|0x36F
argument_list|)
block|,
name|P4_PMCDESCR
argument_list|(
name|IQ_COUNTER4
argument_list|,
literal|0x310
argument_list|,
literal|0x370
argument_list|)
block|,
name|P4_PMCDESCR
argument_list|(
name|IQ_COUNTER5
argument_list|,
literal|0x311
argument_list|,
literal|0x371
argument_list|)
block|,
undef|#
directive|undef
name|P4_PMCDESCR
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* HTT support */
end_comment

begin_define
define|#
directive|define
name|P4_NHTT
value|2
end_define

begin_comment
comment|/* logical processors/chip */
end_comment

begin_define
define|#
directive|define
name|P4_HTT_CPU_INDEX_0
value|0
end_define

begin_define
define|#
directive|define
name|P4_HTT_CPU_INDEX_1
value|1
end_define

begin_decl_stmt
specifier|static
name|int
name|p4_system_has_htt
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Per-CPU data structure for P4 class CPUs  *  * [common stuff]  * [19 struct pmc_hw pointers]  * [19 struct pmc_hw structures]  * [45 ESCRs status bytes]  * [per-cpu spin mutex]  * [19 flag fields for holding config flags and a runcount]  * [19*2 hw value fields]	(Thread mode PMC support)  *    or  * [19*2 EIP values]		(Sampling mode PMCs)  * [19*2 pmc value fields]	(Thread mode PMC support))  */
end_comment

begin_struct
struct|struct
name|p4_cpu
block|{
name|struct
name|pmc_cpu
name|pc_common
decl_stmt|;
name|struct
name|pmc_hw
modifier|*
name|pc_hwpmcs
index|[
name|P4_NPMCS
index|]
decl_stmt|;
name|struct
name|pmc_hw
name|pc_p4pmcs
index|[
name|P4_NPMCS
index|]
decl_stmt|;
name|char
name|pc_escrs
index|[
name|P4_NESCR
index|]
decl_stmt|;
name|struct
name|mtx
name|pc_mtx
decl_stmt|;
comment|/* spin lock */
name|uint32_t
name|pc_intrflag
decl_stmt|;
comment|/* NMI handler flags */
name|unsigned
name|int
name|pc_intrlock
decl_stmt|;
comment|/* NMI handler spin lock */
name|unsigned
name|char
name|pc_flags
index|[
name|P4_NPMCS
index|]
decl_stmt|;
comment|/* 4 bits each: {cfg,run}count */
union|union
block|{
name|pmc_value_t
name|pc_hw
index|[
name|P4_NPMCS
operator|*
name|P4_NHTT
index|]
decl_stmt|;
name|uintptr_t
name|pc_ip
index|[
name|P4_NPMCS
operator|*
name|P4_NHTT
index|]
decl_stmt|;
block|}
name|pc_si
union|;
name|pmc_value_t
name|pc_pmc_values
index|[
name|P4_NPMCS
operator|*
name|P4_NHTT
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * A 'logical' CPU shares PMC resources with partner 'physical' CPU,  * except the TSC, which is architectural and hence seperate.  The  * 'logical' CPU descriptor thus has pointers to the physical CPUs  * descriptor state except for the TSC (rowindex 0) which is not  * shared.  */
end_comment

begin_struct
struct|struct
name|p4_logicalcpu
block|{
name|struct
name|pmc_cpu
name|pc_common
decl_stmt|;
name|struct
name|pmc_hw
modifier|*
name|pc_hwpmcs
index|[
name|P4_NPMCS
index|]
decl_stmt|;
name|struct
name|pmc_hw
name|pc_tsc
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|P4_PCPU_PMC_VALUE
parameter_list|(
name|PC
parameter_list|,
name|RI
parameter_list|,
name|CPU
parameter_list|)
value|(PC)->pc_pmc_values[(RI)*((CPU)& 1)]
end_define

begin_define
define|#
directive|define
name|P4_PCPU_HW_VALUE
parameter_list|(
name|PC
parameter_list|,
name|RI
parameter_list|,
name|CPU
parameter_list|)
value|(PC)->pc_si.pc_hw[(RI)*((CPU)& 1)]
end_define

begin_define
define|#
directive|define
name|P4_PCPU_SAVED_IP
parameter_list|(
name|PC
parameter_list|,
name|RI
parameter_list|,
name|CPU
parameter_list|)
value|(PC)->pc_si.pc_ip[(RI)*((CPU)& 1)]
end_define

begin_define
define|#
directive|define
name|P4_PCPU_GET_FLAGS
parameter_list|(
name|PC
parameter_list|,
name|RI
parameter_list|,
name|MASK
parameter_list|)
value|((PC)->pc_flags[(RI)]& (MASK))
end_define

begin_define
define|#
directive|define
name|P4_PCPU_SET_FLAGS
parameter_list|(
name|PC
parameter_list|,
name|RI
parameter_list|,
name|MASK
parameter_list|,
name|VAL
parameter_list|)
value|do {	\ 	char _tmp;					\ 	_tmp = (PC)->pc_flags[(RI)];			\ 	_tmp&= ~(MASK);				\ 	_tmp |= (VAL)& (MASK);				\ 	(PC)->pc_flags[(RI)] = _tmp;			\ } while (0)
end_define

begin_define
define|#
directive|define
name|P4_PCPU_GET_RUNCOUNT
parameter_list|(
name|PC
parameter_list|,
name|RI
parameter_list|)
value|P4_PCPU_GET_FLAGS(PC,RI,0x0F)
end_define

begin_define
define|#
directive|define
name|P4_PCPU_SET_RUNCOUNT
parameter_list|(
name|PC
parameter_list|,
name|RI
parameter_list|,
name|V
parameter_list|)
value|P4_PCPU_SET_FLAGS(PC,RI,0x0F,V)
end_define

begin_define
define|#
directive|define
name|P4_PCPU_GET_CFGFLAGS
parameter_list|(
name|PC
parameter_list|,
name|RI
parameter_list|)
value|(P4_PCPU_GET_FLAGS(PC,RI,0xF0)>> 4)
end_define

begin_define
define|#
directive|define
name|P4_PCPU_SET_CFGFLAGS
parameter_list|(
name|PC
parameter_list|,
name|RI
parameter_list|,
name|C
parameter_list|)
value|P4_PCPU_SET_FLAGS(PC,RI,0xF0,((C)<<4))
end_define

begin_define
define|#
directive|define
name|P4_CPU_TO_FLAG
parameter_list|(
name|C
parameter_list|)
value|(pmc_cpu_is_logical(cpu) ? 0x2 : 0x1)
end_define

begin_define
define|#
directive|define
name|P4_PCPU_GET_INTRFLAG
parameter_list|(
name|PC
parameter_list|,
name|I
parameter_list|)
value|((PC)->pc_intrflag& (1<< (I)))
end_define

begin_define
define|#
directive|define
name|P4_PCPU_SET_INTRFLAG
parameter_list|(
name|PC
parameter_list|,
name|I
parameter_list|,
name|V
parameter_list|)
value|do {		\ 		uint32_t __mask;			\ 		__mask = 1<< (I);			\ 		if ((V))				\ 			(PC)->pc_intrflag |= __mask;	\ 		else					\ 			(PC)->pc_intrflag&= ~__mask;	\ 	} while (0)
end_define

begin_comment
comment|/*  * A minimal spin lock implementation for use inside the NMI handler.  *  * We don't want to use a regular spin lock here, because curthread  * may not be consistent at the time the handler is invoked.  */
end_comment

begin_define
define|#
directive|define
name|P4_PCPU_ACQ_INTR_SPINLOCK
parameter_list|(
name|PC
parameter_list|)
value|do {				\ 		while (!atomic_cmpset_acq_int(&pc->pc_intrlock, 0, 1))	\ 			ia32_pause();					\ 	} while (0)
end_define

begin_define
define|#
directive|define
name|P4_PCPU_REL_INTR_SPINLOCK
parameter_list|(
name|PC
parameter_list|)
define|\
value|atomic_store_rel_int(&pc->pc_intrlock, 0);
end_define

begin_comment
comment|/* ESCR row disposition */
end_comment

begin_decl_stmt
specifier|static
name|int
name|p4_escrdisp
index|[
name|P4_NESCR
index|]
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|P4_ESCR_ROW_DISP_IS_THREAD
parameter_list|(
name|E
parameter_list|)
value|(p4_escrdisp[(E)]> 0)
end_define

begin_define
define|#
directive|define
name|P4_ESCR_ROW_DISP_IS_STANDALONE
parameter_list|(
name|E
parameter_list|)
value|(p4_escrdisp[(E)]< 0)
end_define

begin_define
define|#
directive|define
name|P4_ESCR_ROW_DISP_IS_FREE
parameter_list|(
name|E
parameter_list|)
value|(p4_escrdisp[(E)] == 0)
end_define

begin_define
define|#
directive|define
name|P4_ESCR_MARK_ROW_STANDALONE
parameter_list|(
name|E
parameter_list|)
value|do {				\ 	KASSERT(p4_escrdisp[(E)]<= 0, ("[p4,%d] row disposition error",\ 		    __LINE__));						\ 	atomic_add_int(&p4_escrdisp[(E)], -1);				\ 	KASSERT(p4_escrdisp[(E)]>= (-mp_ncpus), ("[p4,%d] row "	\ 		"disposition error", __LINE__));			\ } while (0)
end_define

begin_define
define|#
directive|define
name|P4_ESCR_UNMARK_ROW_STANDALONE
parameter_list|(
name|E
parameter_list|)
value|do {				\ 	atomic_add_int(&p4_escrdisp[(E)], 1);				\ 	KASSERT(p4_escrdisp[(E)]<= 0, ("[p4,%d] row disposition error",\ 		    __LINE__));						\ } while (0)
end_define

begin_define
define|#
directive|define
name|P4_ESCR_MARK_ROW_THREAD
parameter_list|(
name|E
parameter_list|)
value|do {					 \ 	KASSERT(p4_escrdisp[(E)]>= 0, ("[p4,%d] row disposition error", \ 		    __LINE__));						 \ 	atomic_add_int(&p4_escrdisp[(E)], 1);				 \ } while (0)
end_define

begin_define
define|#
directive|define
name|P4_ESCR_UNMARK_ROW_THREAD
parameter_list|(
name|E
parameter_list|)
value|do {				 \ 	atomic_add_int(&p4_escrdisp[(E)], -1);				 \ 	KASSERT(p4_escrdisp[(E)]>= 0, ("[p4,%d] row disposition error",\ 		    __LINE__));						 \ } while (0)
end_define

begin_define
define|#
directive|define
name|P4_PMC_IS_STOPPED
parameter_list|(
name|cccr
parameter_list|)
value|((rdmsr(cccr)& P4_CCCR_ENABLE) == 0)
end_define

begin_define
define|#
directive|define
name|P4_TO_PHYSICAL_CPU
parameter_list|(
name|cpu
parameter_list|)
value|(pmc_cpu_is_logical(cpu) ?		\     ((cpu)& ~1) : (cpu))
end_define

begin_define
define|#
directive|define
name|P4_CCCR_Tx_MASK
value|(~(P4_CCCR_OVF_PMI_T0|P4_CCCR_OVF_PMI_T1|	\ 			     P4_CCCR_ENABLE|P4_CCCR_OVF))
end_define

begin_define
define|#
directive|define
name|P4_ESCR_Tx_MASK
value|(~(P4_ESCR_T0_OS|P4_ESCR_T0_USR|P4_ESCR_T1_OS|	\ 			     P4_ESCR_T1_USR))
end_define

begin_comment
comment|/*  * support routines  */
end_comment

begin_function
specifier|static
name|struct
name|p4_event_descr
modifier|*
name|p4_find_event
parameter_list|(
name|enum
name|pmc_event
name|ev
parameter_list|)
block|{
name|int
name|n
decl_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|P4_NEVENTS
condition|;
name|n
operator|++
control|)
if|if
condition|(
name|p4_events
index|[
name|n
index|]
operator|.
name|pm_event
operator|==
name|ev
condition|)
break|break;
if|if
condition|(
name|n
operator|==
name|P4_NEVENTS
condition|)
return|return
name|NULL
return|;
return|return
operator|&
name|p4_events
index|[
name|n
index|]
return|;
block|}
end_function

begin_comment
comment|/*  * Initialize per-cpu state  */
end_comment

begin_function
specifier|static
name|int
name|p4_init
parameter_list|(
name|int
name|cpu
parameter_list|)
block|{
name|int
name|n
decl_stmt|,
name|phycpu
decl_stmt|;
name|char
modifier|*
name|pescr
decl_stmt|;
name|struct
name|p4_cpu
modifier|*
name|pcs
decl_stmt|;
name|struct
name|p4_logicalcpu
modifier|*
name|plcs
decl_stmt|;
name|struct
name|pmc_hw
modifier|*
name|phw
decl_stmt|;
name|KASSERT
argument_list|(
name|cpu
operator|>=
literal|0
operator|&&
name|cpu
operator|<
name|mp_ncpus
argument_list|,
operator|(
literal|"[p4,%d] insane cpu number %d"
operator|,
name|__LINE__
operator|,
name|cpu
operator|)
argument_list|)
expr_stmt|;
name|PMCDBG
argument_list|(
name|MDP
argument_list|,
name|INI
argument_list|,
literal|0
argument_list|,
literal|"p4-init cpu=%d logical=%d"
argument_list|,
name|cpu
argument_list|,
name|pmc_cpu_is_logical
argument_list|(
name|cpu
argument_list|)
operator|!=
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * A 'logical' CPU shares its per-cpu state with its physical 	 * CPU.  The physical CPU would have been initialized prior to 	 * the initialization for this cpu. 	 */
if|if
condition|(
name|pmc_cpu_is_logical
argument_list|(
name|cpu
argument_list|)
condition|)
block|{
name|phycpu
operator|=
name|P4_TO_PHYSICAL_CPU
argument_list|(
name|cpu
argument_list|)
expr_stmt|;
name|pcs
operator|=
operator|(
expr|struct
name|p4_cpu
operator|*
operator|)
name|pmc_pcpu
index|[
name|phycpu
index|]
expr_stmt|;
name|PMCDBG
argument_list|(
name|MDP
argument_list|,
name|INI
argument_list|,
literal|1
argument_list|,
literal|"p4-init cpu=%d phycpu=%d pcs=%p"
argument_list|,
name|cpu
argument_list|,
name|phycpu
argument_list|,
name|pcs
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|pcs
argument_list|,
operator|(
literal|"[p4,%d] Null Per-Cpu state cpu=%d phycpu=%d"
operator|,
name|__LINE__
operator|,
name|cpu
operator|,
name|phycpu
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcs
operator|==
name|NULL
condition|)
comment|/* decline to init */
return|return
name|ENXIO
return|;
name|p4_system_has_htt
operator|=
literal|1
expr_stmt|;
name|MALLOC
argument_list|(
name|plcs
argument_list|,
expr|struct
name|p4_logicalcpu
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|p4_logicalcpu
argument_list|)
argument_list|,
name|M_PMC
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
comment|/* The TSC is architectural state and is not shared */
name|plcs
operator|->
name|pc_hwpmcs
index|[
literal|0
index|]
operator|=
operator|&
name|plcs
operator|->
name|pc_tsc
expr_stmt|;
name|plcs
operator|->
name|pc_tsc
operator|.
name|phw_state
operator|=
name|PMC_PHW_FLAG_IS_ENABLED
operator||
name|PMC_PHW_CPU_TO_STATE
argument_list|(
name|cpu
argument_list|)
operator||
name|PMC_PHW_INDEX_TO_STATE
argument_list|(
literal|0
argument_list|)
operator||
name|PMC_PHW_FLAG_IS_SHAREABLE
expr_stmt|;
comment|/* Other PMCs are shared with the physical CPU */
for|for
control|(
name|n
operator|=
literal|1
init|;
name|n
operator|<
name|P4_NPMCS
condition|;
name|n
operator|++
control|)
name|plcs
operator|->
name|pc_hwpmcs
index|[
name|n
index|]
operator|=
name|pcs
operator|->
name|pc_hwpmcs
index|[
name|n
index|]
expr_stmt|;
name|pmc_pcpu
index|[
name|cpu
index|]
operator|=
operator|(
expr|struct
name|pmc_cpu
operator|*
operator|)
name|plcs
expr_stmt|;
return|return
literal|0
return|;
block|}
name|MALLOC
argument_list|(
name|pcs
argument_list|,
expr|struct
name|p4_cpu
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|p4_cpu
argument_list|)
argument_list|,
name|M_PMC
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcs
operator|==
name|NULL
condition|)
return|return
name|ENOMEM
return|;
name|phw
operator|=
name|pcs
operator|->
name|pc_p4pmcs
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|P4_NPMCS
condition|;
name|n
operator|++
operator|,
name|phw
operator|++
control|)
block|{
name|phw
operator|->
name|phw_state
operator|=
name|PMC_PHW_FLAG_IS_ENABLED
operator||
name|PMC_PHW_CPU_TO_STATE
argument_list|(
name|cpu
argument_list|)
operator||
name|PMC_PHW_INDEX_TO_STATE
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|phw
operator|->
name|phw_pmc
operator|=
name|NULL
expr_stmt|;
name|pcs
operator|->
name|pc_hwpmcs
index|[
name|n
index|]
operator|=
name|phw
expr_stmt|;
block|}
comment|/* Mark the TSC as shareable */
name|pcs
operator|->
name|pc_hwpmcs
index|[
literal|0
index|]
operator|->
name|phw_state
operator||=
name|PMC_PHW_FLAG_IS_SHAREABLE
expr_stmt|;
name|pescr
operator|=
name|pcs
operator|->
name|pc_escrs
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|P4_NESCR
condition|;
name|n
operator|++
control|)
operator|*
name|pescr
operator|++
operator|=
name|P4_INVALID_PMC_INDEX
expr_stmt|;
name|pmc_pcpu
index|[
name|cpu
index|]
operator|=
operator|(
expr|struct
name|pmc_cpu
operator|*
operator|)
name|pcs
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|pcs
operator|->
name|pc_mtx
argument_list|,
literal|"p4-pcpu"
argument_list|,
literal|"pmc"
argument_list|,
name|MTX_SPIN
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Destroy per-cpu state.  */
end_comment

begin_function
specifier|static
name|int
name|p4_cleanup
parameter_list|(
name|int
name|cpu
parameter_list|)
block|{
name|struct
name|p4_cpu
modifier|*
name|pcs
decl_stmt|;
name|PMCDBG
argument_list|(
name|MDP
argument_list|,
name|INI
argument_list|,
literal|0
argument_list|,
literal|"p4-cleanup cpu=%d"
argument_list|,
name|cpu
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pcs
operator|=
operator|(
expr|struct
name|p4_cpu
operator|*
operator|)
name|pmc_pcpu
index|[
name|cpu
index|]
operator|)
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
comment|/* 	 * If the CPU is physical we need to teardown the 	 * full MD state. 	 */
if|if
condition|(
operator|!
name|pmc_cpu_is_logical
argument_list|(
name|cpu
argument_list|)
condition|)
name|mtx_destroy
argument_list|(
operator|&
name|pcs
operator|->
name|pc_mtx
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|pcs
argument_list|,
name|M_PMC
argument_list|)
expr_stmt|;
name|pmc_pcpu
index|[
name|cpu
index|]
operator|=
name|NULL
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Context switch in.  */
end_comment

begin_function
specifier|static
name|int
name|p4_switch_in
parameter_list|(
name|struct
name|pmc_cpu
modifier|*
name|pc
parameter_list|,
name|struct
name|pmc_process
modifier|*
name|pp
parameter_list|)
block|{
operator|(
name|void
operator|)
name|pc
expr_stmt|;
name|PMCDBG
argument_list|(
name|MDP
argument_list|,
name|SWI
argument_list|,
literal|1
argument_list|,
literal|"pc=%p pp=%p enable-msr=%d"
argument_list|,
name|pc
argument_list|,
name|pp
argument_list|,
operator|(
name|pp
operator|->
name|pp_flags
operator|&
name|PMC_PP_ENABLE_MSR_ACCESS
operator|)
operator|!=
literal|0
argument_list|)
expr_stmt|;
comment|/* enable the RDPMC instruction */
if|if
condition|(
name|pp
operator|->
name|pp_flags
operator|&
name|PMC_PP_ENABLE_MSR_ACCESS
condition|)
name|load_cr4
argument_list|(
name|rcr4
argument_list|()
operator||
name|CR4_PCE
argument_list|)
expr_stmt|;
name|PMCDBG
argument_list|(
name|MDP
argument_list|,
name|SWI
argument_list|,
literal|2
argument_list|,
literal|"cr4=0x%x"
argument_list|,
operator|(
name|uint32_t
operator|)
name|rcr4
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Context switch out.  */
end_comment

begin_function
specifier|static
name|int
name|p4_switch_out
parameter_list|(
name|struct
name|pmc_cpu
modifier|*
name|pc
parameter_list|,
name|struct
name|pmc_process
modifier|*
name|pp
parameter_list|)
block|{
operator|(
name|void
operator|)
name|pc
expr_stmt|;
operator|(
name|void
operator|)
name|pp
expr_stmt|;
comment|/* can be null */
name|PMCDBG
argument_list|(
name|MDP
argument_list|,
name|SWO
argument_list|,
literal|1
argument_list|,
literal|"pc=%p pp=%p"
argument_list|,
name|pc
argument_list|,
name|pp
argument_list|)
expr_stmt|;
comment|/* always disallow the RDPMC instruction */
name|load_cr4
argument_list|(
name|rcr4
argument_list|()
operator|&
operator|~
name|CR4_PCE
argument_list|)
expr_stmt|;
name|PMCDBG
argument_list|(
name|MDP
argument_list|,
name|SWO
argument_list|,
literal|2
argument_list|,
literal|"cr4=0x%x"
argument_list|,
operator|(
name|uint32_t
operator|)
name|rcr4
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Read a PMC  */
end_comment

begin_function
specifier|static
name|int
name|p4_read_pmc
parameter_list|(
name|int
name|cpu
parameter_list|,
name|int
name|ri
parameter_list|,
name|pmc_value_t
modifier|*
name|v
parameter_list|)
block|{
name|enum
name|pmc_mode
name|mode
decl_stmt|;
name|struct
name|p4pmc_descr
modifier|*
name|pd
decl_stmt|;
name|struct
name|pmc
modifier|*
name|pm
decl_stmt|;
name|struct
name|p4_cpu
modifier|*
name|pc
decl_stmt|;
name|struct
name|pmc_hw
modifier|*
name|phw
decl_stmt|;
name|pmc_value_t
name|tmp
decl_stmt|;
name|KASSERT
argument_list|(
name|cpu
operator|>=
literal|0
operator|&&
name|cpu
operator|<
name|mp_ncpus
argument_list|,
operator|(
literal|"[p4,%d] illegal CPU value %d"
operator|,
name|__LINE__
operator|,
name|cpu
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|ri
operator|>=
literal|0
operator|&&
name|ri
operator|<
name|P4_NPMCS
argument_list|,
operator|(
literal|"[p4,%d] illegal row-index %d"
operator|,
name|__LINE__
operator|,
name|ri
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ri
operator|==
literal|0
condition|)
block|{
comment|/* TSC */
if|#
directive|if
name|DEBUG
name|pc
operator|=
operator|(
expr|struct
name|p4_cpu
operator|*
operator|)
name|pmc_pcpu
index|[
name|cpu
index|]
expr_stmt|;
name|phw
operator|=
name|pc
operator|->
name|pc_hwpmcs
index|[
name|ri
index|]
expr_stmt|;
name|pm
operator|=
name|phw
operator|->
name|phw_pmc
expr_stmt|;
name|KASSERT
argument_list|(
name|pm
argument_list|,
operator|(
literal|"[p4,%d] cpu=%d ri=%d not configured"
operator|,
name|__LINE__
operator|,
name|cpu
operator|,
name|ri
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|PMC_TO_CLASS
argument_list|(
name|pm
argument_list|)
operator|==
name|PMC_CLASS_TSC
argument_list|,
operator|(
literal|"[p4,%d] cpu=%d ri=%d not a TSC (%d)"
operator|,
name|__LINE__
operator|,
name|cpu
operator|,
name|ri
operator|,
name|PMC_TO_CLASS
argument_list|(
name|pm
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|PMC_IS_COUNTING_MODE
argument_list|(
name|PMC_TO_MODE
argument_list|(
name|pm
argument_list|)
argument_list|)
argument_list|,
operator|(
literal|"[p4,%d] TSC counter in non-counting mode"
operator|,
name|__LINE__
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|*
name|v
operator|=
name|rdtsc
argument_list|()
expr_stmt|;
name|PMCDBG
argument_list|(
name|MDP
argument_list|,
name|REA
argument_list|,
literal|2
argument_list|,
literal|"p4-read -> %jx"
argument_list|,
operator|*
name|v
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|pc
operator|=
operator|(
expr|struct
name|p4_cpu
operator|*
operator|)
name|pmc_pcpu
index|[
name|P4_TO_PHYSICAL_CPU
argument_list|(
name|cpu
argument_list|)
index|]
expr_stmt|;
name|phw
operator|=
name|pc
operator|->
name|pc_hwpmcs
index|[
name|ri
index|]
expr_stmt|;
name|pd
operator|=
operator|&
name|p4_pmcdesc
index|[
name|ri
index|]
expr_stmt|;
name|pm
operator|=
name|phw
operator|->
name|phw_pmc
expr_stmt|;
name|KASSERT
argument_list|(
name|pm
operator|!=
name|NULL
argument_list|,
operator|(
literal|"[p4,%d] No owner for HWPMC [cpu%d,pmc%d]"
operator|,
name|__LINE__
operator|,
name|cpu
operator|,
name|ri
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|pd
operator|->
name|pm_descr
operator|.
name|pd_class
operator|==
name|PMC_TO_CLASS
argument_list|(
name|pm
argument_list|)
argument_list|,
operator|(
literal|"[p4,%d] class mismatch pd %d != id class %d"
operator|,
name|__LINE__
operator|,
name|pd
operator|->
name|pm_descr
operator|.
name|pd_class
operator|,
name|PMC_TO_CLASS
argument_list|(
name|pm
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|mode
operator|=
name|PMC_TO_MODE
argument_list|(
name|pm
argument_list|)
expr_stmt|;
name|PMCDBG
argument_list|(
name|MDP
argument_list|,
name|REA
argument_list|,
literal|1
argument_list|,
literal|"p4-read cpu=%d ri=%d mode=%d"
argument_list|,
name|cpu
argument_list|,
name|ri
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|pd
operator|->
name|pm_descr
operator|.
name|pd_class
operator|==
name|PMC_CLASS_P4
argument_list|,
operator|(
literal|"[p4,%d] unknown PMC class %d"
operator|,
name|__LINE__
operator|,
name|pd
operator|->
name|pm_descr
operator|.
name|pd_class
operator|)
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|rdmsr
argument_list|(
name|p4_pmcdesc
index|[
name|ri
index|]
operator|.
name|pm_pmc_msr
argument_list|)
expr_stmt|;
if|if
condition|(
name|PMC_IS_VIRTUAL_MODE
argument_list|(
name|mode
argument_list|)
condition|)
block|{
if|if
condition|(
name|tmp
operator|<
name|P4_PCPU_HW_VALUE
argument_list|(
name|pc
argument_list|,
name|ri
argument_list|,
name|cpu
argument_list|)
condition|)
comment|/* 40 bit overflow */
name|tmp
operator|+=
operator|(
name|P4_PERFCTR_MASK
operator|+
literal|1
operator|)
operator|-
name|P4_PCPU_HW_VALUE
argument_list|(
name|pc
argument_list|,
name|ri
argument_list|,
name|cpu
argument_list|)
expr_stmt|;
else|else
name|tmp
operator|-=
name|P4_PCPU_HW_VALUE
argument_list|(
name|pc
argument_list|,
name|ri
argument_list|,
name|cpu
argument_list|)
expr_stmt|;
name|tmp
operator|+=
name|P4_PCPU_PMC_VALUE
argument_list|(
name|pc
argument_list|,
name|ri
argument_list|,
name|cpu
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|PMC_IS_SAMPLING_MODE
argument_list|(
name|mode
argument_list|)
condition|)
comment|/* undo transformation */
operator|*
name|v
operator|=
name|P4_PERFCTR_VALUE_TO_RELOAD_COUNT
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
else|else
operator|*
name|v
operator|=
name|tmp
expr_stmt|;
name|PMCDBG
argument_list|(
name|MDP
argument_list|,
name|REA
argument_list|,
literal|2
argument_list|,
literal|"p4-read -> %jx"
argument_list|,
operator|*
name|v
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Write a PMC  */
end_comment

begin_function
specifier|static
name|int
name|p4_write_pmc
parameter_list|(
name|int
name|cpu
parameter_list|,
name|int
name|ri
parameter_list|,
name|pmc_value_t
name|v
parameter_list|)
block|{
name|enum
name|pmc_mode
name|mode
decl_stmt|;
name|struct
name|pmc
modifier|*
name|pm
decl_stmt|;
name|struct
name|p4_cpu
modifier|*
name|pc
decl_stmt|;
specifier|const
name|struct
name|pmc_hw
modifier|*
name|phw
decl_stmt|;
specifier|const
name|struct
name|p4pmc_descr
modifier|*
name|pd
decl_stmt|;
name|KASSERT
argument_list|(
name|cpu
operator|>=
literal|0
operator|&&
name|cpu
operator|<
name|mp_ncpus
argument_list|,
operator|(
literal|"[amd,%d] illegal CPU value %d"
operator|,
name|__LINE__
operator|,
name|cpu
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|ri
operator|>=
literal|0
operator|&&
name|ri
operator|<
name|P4_NPMCS
argument_list|,
operator|(
literal|"[amd,%d] illegal row-index %d"
operator|,
name|__LINE__
operator|,
name|ri
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * The P4's TSC register is writeable, but we don't allow a 	 * write as changing the TSC's value could interfere with 	 * timekeeping and other system functions. 	 */
if|if
condition|(
name|ri
operator|==
literal|0
condition|)
block|{
if|#
directive|if
name|DEBUG
name|pc
operator|=
operator|(
expr|struct
name|p4_cpu
operator|*
operator|)
name|pmc_pcpu
index|[
name|cpu
index|]
expr_stmt|;
name|phw
operator|=
name|pc
operator|->
name|pc_hwpmcs
index|[
name|ri
index|]
expr_stmt|;
name|pm
operator|=
name|phw
operator|->
name|phw_pmc
expr_stmt|;
name|KASSERT
argument_list|(
name|pm
argument_list|,
operator|(
literal|"[p4,%d] cpu=%d ri=%d not configured"
operator|,
name|__LINE__
operator|,
name|cpu
operator|,
name|ri
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|PMC_TO_CLASS
argument_list|(
name|pm
argument_list|)
operator|==
name|PMC_CLASS_TSC
argument_list|,
operator|(
literal|"[p4,%d] cpu=%d ri=%d not a TSC (%d)"
operator|,
name|__LINE__
operator|,
name|cpu
operator|,
name|ri
operator|,
name|PMC_TO_CLASS
argument_list|(
name|pm
argument_list|)
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|0
return|;
block|}
comment|/* Shared PMCs */
name|pc
operator|=
operator|(
expr|struct
name|p4_cpu
operator|*
operator|)
name|pmc_pcpu
index|[
name|P4_TO_PHYSICAL_CPU
argument_list|(
name|cpu
argument_list|)
index|]
expr_stmt|;
name|phw
operator|=
name|pc
operator|->
name|pc_hwpmcs
index|[
name|ri
index|]
expr_stmt|;
name|pm
operator|=
name|phw
operator|->
name|phw_pmc
expr_stmt|;
name|pd
operator|=
operator|&
name|p4_pmcdesc
index|[
name|ri
index|]
expr_stmt|;
name|KASSERT
argument_list|(
name|pm
operator|!=
name|NULL
argument_list|,
operator|(
literal|"[p4,%d] No owner for HWPMC [cpu%d,pmc%d]"
operator|,
name|__LINE__
operator|,
name|cpu
operator|,
name|ri
operator|)
argument_list|)
expr_stmt|;
name|mode
operator|=
name|PMC_TO_MODE
argument_list|(
name|pm
argument_list|)
expr_stmt|;
name|PMCDBG
argument_list|(
name|MDP
argument_list|,
name|WRI
argument_list|,
literal|1
argument_list|,
literal|"p4-write cpu=%d ri=%d mode=%d v=%jx"
argument_list|,
name|cpu
argument_list|,
name|ri
argument_list|,
name|mode
argument_list|,
name|v
argument_list|)
expr_stmt|;
comment|/* 	 * write the PMC value to the register/saved value: for 	 * sampling mode PMCs, the value to be programmed into the PMC 	 * counter is -(C+1) where 'C' is the requested sample rate. 	 */
if|if
condition|(
name|PMC_IS_SAMPLING_MODE
argument_list|(
name|mode
argument_list|)
condition|)
name|v
operator|=
name|P4_RELOAD_COUNT_TO_PERFCTR_VALUE
argument_list|(
name|v
argument_list|)
expr_stmt|;
if|if
condition|(
name|PMC_IS_SYSTEM_MODE
argument_list|(
name|mode
argument_list|)
condition|)
name|wrmsr
argument_list|(
name|pd
operator|->
name|pm_pmc_msr
argument_list|,
name|v
argument_list|)
expr_stmt|;
else|else
name|P4_PCPU_PMC_VALUE
argument_list|(
name|pc
argument_list|,
name|ri
argument_list|,
name|cpu
argument_list|)
operator|=
name|v
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Configure a PMC 'pm' on the given CPU and row-index.  *  * 'pm' may be NULL to indicate de-configuration.  *  * On HTT systems, a PMC may get configured twice, once for each  * "logical" CPU.  We track this using the CFGFLAGS field of the  * per-cpu state; this field is a bit mask with one bit each for  * logical CPUs 0& 1.  */
end_comment

begin_function
specifier|static
name|int
name|p4_config_pmc
parameter_list|(
name|int
name|cpu
parameter_list|,
name|int
name|ri
parameter_list|,
name|struct
name|pmc
modifier|*
name|pm
parameter_list|)
block|{
name|struct
name|pmc_hw
modifier|*
name|phw
decl_stmt|;
name|struct
name|p4_cpu
modifier|*
name|pc
decl_stmt|;
name|int
name|cfgflags
decl_stmt|,
name|cpuflag
decl_stmt|;
name|KASSERT
argument_list|(
name|cpu
operator|>=
literal|0
operator|&&
name|cpu
operator|<
name|mp_ncpus
argument_list|,
operator|(
literal|"[p4,%d] illegal CPU %d"
operator|,
name|__LINE__
operator|,
name|cpu
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|ri
operator|>=
literal|0
operator|&&
name|ri
operator|<
name|P4_NPMCS
argument_list|,
operator|(
literal|"[p4,%d] illegal row-index %d"
operator|,
name|__LINE__
operator|,
name|ri
operator|)
argument_list|)
expr_stmt|;
name|PMCDBG
argument_list|(
name|MDP
argument_list|,
name|CFG
argument_list|,
literal|1
argument_list|,
literal|"cpu=%d ri=%d pm=%p"
argument_list|,
name|cpu
argument_list|,
name|ri
argument_list|,
name|pm
argument_list|)
expr_stmt|;
if|if
condition|(
name|ri
operator|==
literal|0
condition|)
block|{
comment|/* TSC */
name|pc
operator|=
operator|(
expr|struct
name|p4_cpu
operator|*
operator|)
name|pmc_pcpu
index|[
name|cpu
index|]
expr_stmt|;
name|phw
operator|=
name|pc
operator|->
name|pc_hwpmcs
index|[
name|ri
index|]
expr_stmt|;
name|KASSERT
argument_list|(
name|pm
operator|==
name|NULL
operator|||
name|phw
operator|->
name|phw_pmc
operator|==
name|NULL
argument_list|,
operator|(
literal|"[p4,%d] hwpmc doubly config'ed"
operator|,
name|__LINE__
operator|)
argument_list|)
expr_stmt|;
name|phw
operator|->
name|phw_pmc
operator|=
name|pm
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Shared PMCs */
name|pc
operator|=
operator|(
expr|struct
name|p4_cpu
operator|*
operator|)
name|pmc_pcpu
index|[
name|P4_TO_PHYSICAL_CPU
argument_list|(
name|cpu
argument_list|)
index|]
expr_stmt|;
name|phw
operator|=
name|pc
operator|->
name|pc_hwpmcs
index|[
name|ri
index|]
expr_stmt|;
name|KASSERT
argument_list|(
name|pm
operator|==
name|NULL
operator|||
name|phw
operator|->
name|phw_pmc
operator|==
name|NULL
operator|||
operator|(
name|p4_system_has_htt
operator|&&
name|phw
operator|->
name|phw_pmc
operator|==
name|pm
operator|)
argument_list|,
operator|(
literal|"[p4,%d] hwpmc not unconfigured before re-config"
operator|,
name|__LINE__
operator|)
argument_list|)
expr_stmt|;
name|mtx_lock_spin
argument_list|(
operator|&
name|pc
operator|->
name|pc_mtx
argument_list|)
expr_stmt|;
name|cfgflags
operator|=
name|P4_PCPU_GET_CFGFLAGS
argument_list|(
name|pc
argument_list|,
name|ri
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|cfgflags
operator|>=
literal|0
operator|||
name|cfgflags
operator|<=
literal|3
argument_list|,
operator|(
literal|"[p4,%d] illegal cfgflags cfg=%d on cpu=%d ri=%d"
operator|,
name|__LINE__
operator|,
name|cfgflags
operator|,
name|cpu
operator|,
name|ri
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|cfgflags
operator|==
literal|0
operator|||
name|phw
operator|->
name|phw_pmc
argument_list|,
operator|(
literal|"[p4,%d] cpu=%d ri=%d pmc configured with zero cfg count"
operator|,
name|__LINE__
operator|,
name|cpu
operator|,
name|ri
operator|)
argument_list|)
expr_stmt|;
name|cpuflag
operator|=
name|P4_CPU_TO_FLAG
argument_list|(
name|cpu
argument_list|)
expr_stmt|;
if|if
condition|(
name|pm
condition|)
block|{
comment|/* config */
if|if
condition|(
name|cfgflags
operator|==
literal|0
condition|)
name|phw
operator|->
name|phw_pmc
operator|=
name|pm
expr_stmt|;
name|KASSERT
argument_list|(
name|phw
operator|->
name|phw_pmc
operator|==
name|pm
argument_list|,
operator|(
literal|"[p4,%d] cpu=%d ri=%d config %p != hw %p"
operator|,
name|__LINE__
operator|,
name|cpu
operator|,
name|ri
operator|,
name|pm
operator|,
name|phw
operator|->
name|phw_pmc
operator|)
argument_list|)
expr_stmt|;
name|cfgflags
operator||=
name|cpuflag
expr_stmt|;
block|}
else|else
block|{
comment|/* unconfig */
name|cfgflags
operator|&=
operator|~
name|cpuflag
expr_stmt|;
if|if
condition|(
name|cfgflags
operator|==
literal|0
condition|)
name|phw
operator|->
name|phw_pmc
operator|=
name|NULL
expr_stmt|;
block|}
name|KASSERT
argument_list|(
name|cfgflags
operator|>=
literal|0
operator|||
name|cfgflags
operator|<=
literal|3
argument_list|,
operator|(
literal|"[p4,%d] illegal runcount cfg=%d on cpu=%d ri=%d"
operator|,
name|__LINE__
operator|,
name|cfgflags
operator|,
name|cpu
operator|,
name|ri
operator|)
argument_list|)
expr_stmt|;
name|P4_PCPU_SET_CFGFLAGS
argument_list|(
name|pc
argument_list|,
name|ri
argument_list|,
name|cfgflags
argument_list|)
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|pc
operator|->
name|pc_mtx
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Retrieve a configured PMC pointer from hardware state.  */
end_comment

begin_function
specifier|static
name|int
name|p4_get_config
parameter_list|(
name|int
name|cpu
parameter_list|,
name|int
name|ri
parameter_list|,
name|struct
name|pmc
modifier|*
modifier|*
name|ppm
parameter_list|)
block|{
name|struct
name|p4_cpu
modifier|*
name|pc
decl_stmt|;
name|struct
name|pmc_hw
modifier|*
name|phw
decl_stmt|;
name|int
name|cfgflags
decl_stmt|;
name|pc
operator|=
operator|(
expr|struct
name|p4_cpu
operator|*
operator|)
name|pmc_pcpu
index|[
name|P4_TO_PHYSICAL_CPU
argument_list|(
name|cpu
argument_list|)
index|]
expr_stmt|;
name|phw
operator|=
name|pc
operator|->
name|pc_hwpmcs
index|[
name|ri
index|]
expr_stmt|;
name|mtx_lock_spin
argument_list|(
operator|&
name|pc
operator|->
name|pc_mtx
argument_list|)
expr_stmt|;
name|cfgflags
operator|=
name|P4_PCPU_GET_CFGFLAGS
argument_list|(
name|pc
argument_list|,
name|ri
argument_list|)
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|pc
operator|->
name|pc_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|cfgflags
operator|&
name|P4_CPU_TO_FLAG
argument_list|(
name|cpu
argument_list|)
condition|)
operator|*
name|ppm
operator|=
name|phw
operator|->
name|phw_pmc
expr_stmt|;
comment|/* PMC config'ed on this CPU */
else|else
operator|*
name|ppm
operator|=
name|NULL
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Allocate a PMC.  *  * The allocation strategy differs between HTT and non-HTT systems.  *  * The non-HTT case:  *   - Given the desired event and the PMC row-index, lookup the  *   list of valid ESCRs for the event.  *   - For each valid ESCR:  *     - Check if the ESCR is free and the ESCR row is in a compatible  *       mode (i.e., system or process))  *     - Check if the ESCR is usable with a P4 PMC at the desired row-index.  *   If everything matches, we determine the appropriate bit values for the  *   ESCR and CCCR registers.  *  * The HTT case:  *  * - Process mode PMCs require special care.  The FreeBSD scheduler could  *   schedule any two processes on the same physical CPU.  We need to ensure  *   that a given PMC row-index is never allocated to two different  *   PMCs owned by different user-processes.  *   This is ensured by always allocating a PMC from a 'FREE' PMC row  *   if the system has HTT active.  * - A similar check needs to be done for ESCRs; we do not want two PMCs  *   using the same ESCR to be scheduled at the same time.  Thus ESCR  *   allocation is also restricted to FREE rows if the system has HTT  *   enabled.  * - Thirdly, some events are 'thread-independent' terminology, i.e.,  *   the PMC hardware cannot distinguish between events caused by  *   different logical CPUs.  This makes it impossible to assign events  *   to a given thread of execution.  If the system has HTT enabled,  *   these events are not allowed for process-mode PMCs.  */
end_comment

begin_function
specifier|static
name|int
name|p4_allocate_pmc
parameter_list|(
name|int
name|cpu
parameter_list|,
name|int
name|ri
parameter_list|,
name|struct
name|pmc
modifier|*
name|pm
parameter_list|,
specifier|const
name|struct
name|pmc_op_pmcallocate
modifier|*
name|a
parameter_list|)
block|{
name|int
name|found
decl_stmt|,
name|n
decl_stmt|,
name|m
decl_stmt|;
name|uint32_t
name|caps
decl_stmt|,
name|cccrvalue
decl_stmt|,
name|escrvalue
decl_stmt|,
name|tflags
decl_stmt|;
name|enum
name|pmc_p4escr
name|escr
decl_stmt|;
name|struct
name|p4_cpu
modifier|*
name|pc
decl_stmt|;
name|struct
name|p4_event_descr
modifier|*
name|pevent
decl_stmt|;
specifier|const
name|struct
name|p4pmc_descr
modifier|*
name|pd
decl_stmt|;
name|KASSERT
argument_list|(
name|cpu
operator|>=
literal|0
operator|&&
name|cpu
operator|<
name|mp_ncpus
argument_list|,
operator|(
literal|"[p4,%d] illegal CPU %d"
operator|,
name|__LINE__
operator|,
name|cpu
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|ri
operator|>=
literal|0
operator|&&
name|ri
operator|<
name|P4_NPMCS
argument_list|,
operator|(
literal|"[p4,%d] illegal row-index value %d"
operator|,
name|__LINE__
operator|,
name|ri
operator|)
argument_list|)
expr_stmt|;
name|pd
operator|=
operator|&
name|p4_pmcdesc
index|[
name|ri
index|]
expr_stmt|;
name|PMCDBG
argument_list|(
name|MDP
argument_list|,
name|ALL
argument_list|,
literal|1
argument_list|,
literal|"p4-allocate ri=%d class=%d pmccaps=0x%x "
literal|"reqcaps=0x%x"
argument_list|,
name|ri
argument_list|,
name|pd
operator|->
name|pm_descr
operator|.
name|pd_class
argument_list|,
name|pd
operator|->
name|pm_descr
operator|.
name|pd_caps
argument_list|,
name|pm
operator|->
name|pm_caps
argument_list|)
expr_stmt|;
comment|/* check class */
if|if
condition|(
name|pd
operator|->
name|pm_descr
operator|.
name|pd_class
operator|!=
name|a
operator|->
name|pm_class
condition|)
return|return
name|EINVAL
return|;
comment|/* check requested capabilities */
name|caps
operator|=
name|a
operator|->
name|pm_caps
expr_stmt|;
if|if
condition|(
operator|(
name|pd
operator|->
name|pm_descr
operator|.
name|pd_caps
operator|&
name|caps
operator|)
operator|!=
name|caps
condition|)
return|return
name|EPERM
return|;
if|if
condition|(
name|pd
operator|->
name|pm_descr
operator|.
name|pd_class
operator|==
name|PMC_CLASS_TSC
condition|)
block|{
comment|/* TSC's are always allocated in system-wide counting mode */
if|if
condition|(
name|a
operator|->
name|pm_ev
operator|!=
name|PMC_EV_TSC_TSC
operator|||
name|a
operator|->
name|pm_mode
operator|!=
name|PMC_MODE_SC
condition|)
return|return
name|EINVAL
return|;
return|return
literal|0
return|;
block|}
comment|/* 	 * If the system has HTT enabled, and the desired allocation 	 * mode is process-private, and the PMC row disposition is not 	 * FREE (0), decline the allocation. 	 */
if|if
condition|(
name|p4_system_has_htt
operator|&&
name|PMC_IS_VIRTUAL_MODE
argument_list|(
name|PMC_TO_MODE
argument_list|(
name|pm
argument_list|)
argument_list|)
operator|&&
name|pmc_getrowdisp
argument_list|(
name|ri
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|EBUSY
return|;
name|KASSERT
argument_list|(
name|pd
operator|->
name|pm_descr
operator|.
name|pd_class
operator|==
name|PMC_CLASS_P4
argument_list|,
operator|(
literal|"[p4,%d] unknown PMC class %d"
operator|,
name|__LINE__
operator|,
name|pd
operator|->
name|pm_descr
operator|.
name|pd_class
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pm
operator|->
name|pm_event
operator|<
name|PMC_EV_P4_FIRST
operator|||
name|pm
operator|->
name|pm_event
operator|>
name|PMC_EV_P4_LAST
condition|)
return|return
name|EINVAL
return|;
if|if
condition|(
operator|(
name|pevent
operator|=
name|p4_find_event
argument_list|(
name|pm
operator|->
name|pm_event
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|ESRCH
return|;
name|PMCDBG
argument_list|(
name|MDP
argument_list|,
name|ALL
argument_list|,
literal|2
argument_list|,
literal|"pevent={ev=%d,escrsel=0x%x,cccrsel=0x%x,isti=%d}"
argument_list|,
name|pevent
operator|->
name|pm_event
argument_list|,
name|pevent
operator|->
name|pm_escr_eventselect
argument_list|,
name|pevent
operator|->
name|pm_cccr_select
argument_list|,
name|pevent
operator|->
name|pm_is_ti_event
argument_list|)
expr_stmt|;
comment|/* 	 * Some PMC events are 'thread independent'and therefore 	 * cannot be used for process-private modes if HTT is being 	 * used. 	 */
if|if
condition|(
name|P4_EVENT_IS_TI
argument_list|(
name|pevent
argument_list|)
operator|&&
name|PMC_IS_VIRTUAL_MODE
argument_list|(
name|PMC_TO_MODE
argument_list|(
name|pm
argument_list|)
argument_list|)
operator|&&
name|p4_system_has_htt
condition|)
return|return
name|EINVAL
return|;
name|pc
operator|=
operator|(
expr|struct
name|p4_cpu
operator|*
operator|)
name|pmc_pcpu
index|[
name|P4_TO_PHYSICAL_CPU
argument_list|(
name|cpu
argument_list|)
index|]
expr_stmt|;
name|found
operator|=
literal|0
expr_stmt|;
comment|/* look for a suitable ESCR for this event */
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|P4_MAX_ESCR_PER_EVENT
operator|&&
operator|!
name|found
condition|;
name|n
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|escr
operator|=
name|pevent
operator|->
name|pm_escrs
index|[
name|n
index|]
operator|)
operator|==
name|P4_ESCR_NONE
condition|)
break|break;
comment|/* out of ESCRs */
comment|/* 		 * Check ESCR row disposition. 		 * 		 * If the request is for a system-mode PMC, then the 		 * ESCR row should not be in process-virtual mode, and 		 * should also be free on the current CPU. 		 */
if|if
condition|(
name|PMC_IS_SYSTEM_MODE
argument_list|(
name|PMC_TO_MODE
argument_list|(
name|pm
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|P4_ESCR_ROW_DISP_IS_THREAD
argument_list|(
name|escr
argument_list|)
operator|||
name|pc
operator|->
name|pc_escrs
index|[
name|escr
index|]
operator|!=
name|P4_INVALID_PMC_INDEX
condition|)
continue|continue;
block|}
comment|/* 		 * If the request is for a process-virtual PMC, and if 		 * HTT is not enabled, we can use an ESCR row that is 		 * either FREE or already in process mode. 		 * 		 * If HTT is enabled, then we need to ensure that a 		 * given ESCR is never allocated to two PMCS that 		 * could run simultaneously on the two logical CPUs of 		 * a CPU package.  We ensure this be only allocating 		 * ESCRs from rows marked as 'FREE'. 		 */
if|if
condition|(
name|PMC_IS_VIRTUAL_MODE
argument_list|(
name|PMC_TO_MODE
argument_list|(
name|pm
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|p4_system_has_htt
condition|)
block|{
if|if
condition|(
operator|!
name|P4_ESCR_ROW_DISP_IS_FREE
argument_list|(
name|escr
argument_list|)
condition|)
continue|continue;
block|}
elseif|else
if|if
condition|(
name|P4_ESCR_ROW_DISP_IS_STANDALONE
argument_list|(
name|escr
argument_list|)
condition|)
continue|continue;
block|}
comment|/* 		 * We found a suitable ESCR for this event.  Now check if 		 * this escr can work with the PMC at row-index 'ri'. 		 */
for|for
control|(
name|m
operator|=
literal|0
init|;
name|m
operator|<
name|P4_MAX_PMC_PER_ESCR
condition|;
name|m
operator|++
control|)
if|if
condition|(
name|p4_escrs
index|[
name|escr
index|]
operator|.
name|pm_pmcs
index|[
name|m
index|]
operator|==
name|pd
operator|->
name|pm_pmcnum
condition|)
block|{
name|found
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|found
operator|==
literal|0
condition|)
return|return
name|ESRCH
return|;
name|KASSERT
argument_list|(
operator|(
name|int
operator|)
name|escr
operator|>=
literal|0
operator|&&
name|escr
operator|<
name|P4_NESCR
argument_list|,
operator|(
literal|"[p4,%d] illegal ESCR value %d"
operator|,
name|__LINE__
operator|,
name|escr
operator|)
argument_list|)
expr_stmt|;
comment|/* mark ESCR row mode */
if|if
condition|(
name|PMC_IS_SYSTEM_MODE
argument_list|(
name|PMC_TO_MODE
argument_list|(
name|pm
argument_list|)
argument_list|)
condition|)
block|{
name|pc
operator|->
name|pc_escrs
index|[
name|escr
index|]
operator|=
name|ri
expr_stmt|;
comment|/* mark ESCR as in use on this cpu */
name|P4_ESCR_MARK_ROW_STANDALONE
argument_list|(
name|escr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|KASSERT
argument_list|(
name|pc
operator|->
name|pc_escrs
index|[
name|escr
index|]
operator|==
name|P4_INVALID_PMC_INDEX
argument_list|,
operator|(
literal|"[p4,%d] escr[%d] already in use"
operator|,
name|__LINE__
operator|,
name|escr
operator|)
argument_list|)
expr_stmt|;
name|P4_ESCR_MARK_ROW_THREAD
argument_list|(
name|escr
argument_list|)
expr_stmt|;
block|}
name|pm
operator|->
name|pm_md
operator|.
name|pm_p4
operator|.
name|pm_p4_escrmsr
operator|=
name|p4_escrs
index|[
name|escr
index|]
operator|.
name|pm_escr_msr
expr_stmt|;
name|pm
operator|->
name|pm_md
operator|.
name|pm_p4
operator|.
name|pm_p4_escr
operator|=
name|escr
expr_stmt|;
name|cccrvalue
operator|=
name|P4_CCCR_TO_ESCR_SELECT
argument_list|(
name|pevent
operator|->
name|pm_cccr_select
argument_list|)
expr_stmt|;
name|escrvalue
operator|=
name|P4_ESCR_TO_EVENT_SELECT
argument_list|(
name|pevent
operator|->
name|pm_escr_eventselect
argument_list|)
expr_stmt|;
comment|/* CCCR fields */
if|if
condition|(
name|caps
operator|&
name|PMC_CAP_THRESHOLD
condition|)
name|cccrvalue
operator||=
operator|(
name|a
operator|->
name|pm_md
operator|.
name|pm_p4
operator|.
name|pm_p4_cccrconfig
operator|&
name|P4_CCCR_THRESHOLD_MASK
operator|)
operator||
name|P4_CCCR_COMPARE
expr_stmt|;
if|if
condition|(
name|caps
operator|&
name|PMC_CAP_EDGE
condition|)
name|cccrvalue
operator||=
name|P4_CCCR_EDGE
expr_stmt|;
if|if
condition|(
name|caps
operator|&
name|PMC_CAP_INVERT
condition|)
name|cccrvalue
operator||=
name|P4_CCCR_COMPLEMENT
expr_stmt|;
if|if
condition|(
name|p4_system_has_htt
condition|)
name|cccrvalue
operator||=
name|a
operator|->
name|pm_md
operator|.
name|pm_p4
operator|.
name|pm_p4_cccrconfig
operator|&
name|P4_CCCR_ACTIVE_THREAD_MASK
expr_stmt|;
else|else
comment|/* no HTT; thread field should be '11b' */
name|cccrvalue
operator||=
name|P4_CCCR_TO_ACTIVE_THREAD
argument_list|(
literal|0x3
argument_list|)
expr_stmt|;
if|if
condition|(
name|caps
operator|&
name|PMC_CAP_CASCADE
condition|)
name|cccrvalue
operator||=
name|P4_CCCR_CASCADE
expr_stmt|;
comment|/* On HTT systems the PMI T0 field may get moved to T1 at pmc start */
if|if
condition|(
name|caps
operator|&
name|PMC_CAP_INTERRUPT
condition|)
name|cccrvalue
operator||=
name|P4_CCCR_OVF_PMI_T0
expr_stmt|;
comment|/* ESCR fields */
if|if
condition|(
name|caps
operator|&
name|PMC_CAP_QUALIFIER
condition|)
name|escrvalue
operator||=
name|a
operator|->
name|pm_md
operator|.
name|pm_p4
operator|.
name|pm_p4_escrconfig
operator|&
name|P4_ESCR_EVENT_MASK_MASK
expr_stmt|;
if|if
condition|(
name|caps
operator|&
name|PMC_CAP_TAGGING
condition|)
name|escrvalue
operator||=
operator|(
name|a
operator|->
name|pm_md
operator|.
name|pm_p4
operator|.
name|pm_p4_escrconfig
operator|&
name|P4_ESCR_TAG_VALUE_MASK
operator|)
operator||
name|P4_ESCR_TAG_ENABLE
expr_stmt|;
if|if
condition|(
name|caps
operator|&
name|PMC_CAP_QUALIFIER
condition|)
name|escrvalue
operator||=
operator|(
name|a
operator|->
name|pm_md
operator|.
name|pm_p4
operator|.
name|pm_p4_escrconfig
operator|&
name|P4_ESCR_EVENT_MASK_MASK
operator|)
expr_stmt|;
comment|/* HTT: T0_{OS,USR} bits may get moved to T1 at pmc start */
name|tflags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|caps
operator|&
name|PMC_CAP_SYSTEM
condition|)
name|tflags
operator||=
name|P4_ESCR_T0_OS
expr_stmt|;
if|if
condition|(
name|caps
operator|&
name|PMC_CAP_USER
condition|)
name|tflags
operator||=
name|P4_ESCR_T0_USR
expr_stmt|;
if|if
condition|(
name|tflags
operator|==
literal|0
condition|)
name|tflags
operator|=
operator|(
name|P4_ESCR_T0_OS
operator||
name|P4_ESCR_T0_USR
operator|)
expr_stmt|;
name|escrvalue
operator||=
name|tflags
expr_stmt|;
name|pm
operator|->
name|pm_md
operator|.
name|pm_p4
operator|.
name|pm_p4_cccrvalue
operator|=
name|cccrvalue
expr_stmt|;
name|pm
operator|->
name|pm_md
operator|.
name|pm_p4
operator|.
name|pm_p4_escrvalue
operator|=
name|escrvalue
expr_stmt|;
name|PMCDBG
argument_list|(
name|MDP
argument_list|,
name|ALL
argument_list|,
literal|2
argument_list|,
literal|"p4-allocate cccrsel=0x%x cccrval=0x%x "
literal|"escr=%d escrmsr=0x%x escrval=0x%x"
argument_list|,
name|pevent
operator|->
name|pm_cccr_select
argument_list|,
name|cccrvalue
argument_list|,
name|escr
argument_list|,
name|pm
operator|->
name|pm_md
operator|.
name|pm_p4
operator|.
name|pm_p4_escrmsr
argument_list|,
name|escrvalue
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * release a PMC.  */
end_comment

begin_function
specifier|static
name|int
name|p4_release_pmc
parameter_list|(
name|int
name|cpu
parameter_list|,
name|int
name|ri
parameter_list|,
name|struct
name|pmc
modifier|*
name|pm
parameter_list|)
block|{
name|enum
name|pmc_p4escr
name|escr
decl_stmt|;
name|struct
name|pmc_hw
modifier|*
name|phw
decl_stmt|;
name|struct
name|p4_cpu
modifier|*
name|pc
decl_stmt|;
if|if
condition|(
name|p4_pmcdesc
index|[
name|ri
index|]
operator|.
name|pm_descr
operator|.
name|pd_class
operator|==
name|PMC_CLASS_TSC
condition|)
return|return
literal|0
return|;
name|escr
operator|=
name|pm
operator|->
name|pm_md
operator|.
name|pm_p4
operator|.
name|pm_p4_escr
expr_stmt|;
name|PMCDBG
argument_list|(
name|MDP
argument_list|,
name|REL
argument_list|,
literal|1
argument_list|,
literal|"p4-release cpu=%d ri=%d escr=%d"
argument_list|,
name|cpu
argument_list|,
name|ri
argument_list|,
name|escr
argument_list|)
expr_stmt|;
if|if
condition|(
name|PMC_IS_SYSTEM_MODE
argument_list|(
name|PMC_TO_MODE
argument_list|(
name|pm
argument_list|)
argument_list|)
condition|)
block|{
name|pc
operator|=
operator|(
expr|struct
name|p4_cpu
operator|*
operator|)
name|pmc_pcpu
index|[
name|P4_TO_PHYSICAL_CPU
argument_list|(
name|cpu
argument_list|)
index|]
expr_stmt|;
name|phw
operator|=
name|pc
operator|->
name|pc_hwpmcs
index|[
name|ri
index|]
expr_stmt|;
name|KASSERT
argument_list|(
name|phw
operator|->
name|phw_pmc
operator|==
name|NULL
argument_list|,
operator|(
literal|"[p4,%d] releasing configured PMC ri=%d"
operator|,
name|__LINE__
operator|,
name|ri
operator|)
argument_list|)
expr_stmt|;
name|P4_ESCR_UNMARK_ROW_STANDALONE
argument_list|(
name|escr
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|pc
operator|->
name|pc_escrs
index|[
name|escr
index|]
operator|==
name|ri
argument_list|,
operator|(
literal|"[p4,%d] escr[%d] not allocated to ri %d"
operator|,
name|__LINE__
operator|,
name|escr
operator|,
name|ri
operator|)
argument_list|)
expr_stmt|;
name|pc
operator|->
name|pc_escrs
index|[
name|escr
index|]
operator|=
name|P4_INVALID_PMC_INDEX
expr_stmt|;
comment|/* mark as free */
block|}
else|else
name|P4_ESCR_UNMARK_ROW_THREAD
argument_list|(
name|escr
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Start a PMC  */
end_comment

begin_function
specifier|static
name|int
name|p4_start_pmc
parameter_list|(
name|int
name|cpu
parameter_list|,
name|int
name|ri
parameter_list|)
block|{
name|int
name|rc
decl_stmt|;
name|uint32_t
name|cccrvalue
decl_stmt|,
name|cccrtbits
decl_stmt|,
name|escrvalue
decl_stmt|,
name|escrmsr
decl_stmt|,
name|escrtbits
decl_stmt|;
name|struct
name|pmc
modifier|*
name|pm
decl_stmt|;
name|struct
name|p4_cpu
modifier|*
name|pc
decl_stmt|;
name|struct
name|pmc_hw
modifier|*
name|phw
decl_stmt|;
name|struct
name|p4pmc_descr
modifier|*
name|pd
decl_stmt|;
name|KASSERT
argument_list|(
name|cpu
operator|>=
literal|0
operator|&&
name|cpu
operator|<
name|mp_ncpus
argument_list|,
operator|(
literal|"[p4,%d] illegal CPU value %d"
operator|,
name|__LINE__
operator|,
name|cpu
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|ri
operator|>=
literal|0
operator|&&
name|ri
operator|<
name|P4_NPMCS
argument_list|,
operator|(
literal|"[p4,%d] illegal row-index %d"
operator|,
name|__LINE__
operator|,
name|ri
operator|)
argument_list|)
expr_stmt|;
name|pc
operator|=
operator|(
expr|struct
name|p4_cpu
operator|*
operator|)
name|pmc_pcpu
index|[
name|P4_TO_PHYSICAL_CPU
argument_list|(
name|cpu
argument_list|)
index|]
expr_stmt|;
name|phw
operator|=
name|pc
operator|->
name|pc_hwpmcs
index|[
name|ri
index|]
expr_stmt|;
name|pm
operator|=
name|phw
operator|->
name|phw_pmc
expr_stmt|;
name|pd
operator|=
operator|&
name|p4_pmcdesc
index|[
name|ri
index|]
expr_stmt|;
name|KASSERT
argument_list|(
name|pm
operator|!=
name|NULL
argument_list|,
operator|(
literal|"[p4,%d] starting cpu%d,pmc%d with null pmc"
operator|,
name|__LINE__
operator|,
name|cpu
operator|,
name|ri
operator|)
argument_list|)
expr_stmt|;
name|PMCDBG
argument_list|(
name|MDP
argument_list|,
name|STA
argument_list|,
literal|1
argument_list|,
literal|"p4-start cpu=%d ri=%d"
argument_list|,
name|cpu
argument_list|,
name|ri
argument_list|)
expr_stmt|;
if|if
condition|(
name|pd
operator|->
name|pm_descr
operator|.
name|pd_class
operator|==
name|PMC_CLASS_TSC
condition|)
comment|/* TSC are always on */
return|return
literal|0
return|;
name|KASSERT
argument_list|(
name|pd
operator|->
name|pm_descr
operator|.
name|pd_class
operator|==
name|PMC_CLASS_P4
argument_list|,
operator|(
literal|"[p4,%d] wrong PMC class %d"
operator|,
name|__LINE__
operator|,
name|pd
operator|->
name|pm_descr
operator|.
name|pd_class
operator|)
argument_list|)
expr_stmt|;
comment|/* retrieve the desired CCCR/ESCR values from the PMC */
name|cccrvalue
operator|=
name|pm
operator|->
name|pm_md
operator|.
name|pm_p4
operator|.
name|pm_p4_cccrvalue
expr_stmt|;
name|escrvalue
operator|=
name|pm
operator|->
name|pm_md
operator|.
name|pm_p4
operator|.
name|pm_p4_escrvalue
expr_stmt|;
name|escrmsr
operator|=
name|pm
operator|->
name|pm_md
operator|.
name|pm_p4
operator|.
name|pm_p4_escrmsr
expr_stmt|;
comment|/* extract and zero the logical processor selection bits */
name|cccrtbits
operator|=
name|cccrvalue
operator|&
name|P4_CCCR_OVF_PMI_T0
expr_stmt|;
name|escrtbits
operator|=
name|escrvalue
operator|&
operator|(
name|P4_ESCR_T0_OS
operator||
name|P4_ESCR_T0_USR
operator|)
expr_stmt|;
name|cccrvalue
operator|&=
operator|~
name|P4_CCCR_OVF_PMI_T0
expr_stmt|;
name|escrvalue
operator|&=
operator|~
operator|(
name|P4_ESCR_T0_OS
operator||
name|P4_ESCR_T0_USR
operator|)
expr_stmt|;
if|if
condition|(
name|pmc_cpu_is_logical
argument_list|(
name|cpu
argument_list|)
condition|)
block|{
comment|/* shift T0 bits to T1 position */
name|cccrtbits
operator|<<=
literal|1
expr_stmt|;
name|escrtbits
operator|>>=
literal|2
expr_stmt|;
block|}
comment|/* start system mode PMCs directly */
if|if
condition|(
name|PMC_IS_SYSTEM_MODE
argument_list|(
name|PMC_TO_MODE
argument_list|(
name|pm
argument_list|)
argument_list|)
condition|)
block|{
name|wrmsr
argument_list|(
name|escrmsr
argument_list|,
name|escrvalue
operator||
name|escrtbits
argument_list|)
expr_stmt|;
name|wrmsr
argument_list|(
name|pd
operator|->
name|pm_cccr_msr
argument_list|,
name|cccrvalue
operator||
name|cccrtbits
operator||
name|P4_CCCR_ENABLE
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* 	 * Thread mode PMCs 	 * 	 * On HTT machines, the same PMC could be scheduled on the 	 * same physical CPU twice (once for each logical CPU), for 	 * example, if two threads of a multi-threaded process get 	 * scheduled on the same CPU. 	 * 	 */
name|mtx_lock_spin
argument_list|(
operator|&
name|pc
operator|->
name|pc_mtx
argument_list|)
expr_stmt|;
name|rc
operator|=
name|P4_PCPU_GET_RUNCOUNT
argument_list|(
name|pc
argument_list|,
name|ri
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|rc
operator|==
literal|0
operator|||
name|rc
operator|==
literal|1
argument_list|,
operator|(
literal|"[p4,%d] illegal runcount cpu=%d ri=%d rc=%d"
operator|,
name|__LINE__
operator|,
name|cpu
operator|,
name|ri
operator|,
name|rc
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|==
literal|0
condition|)
block|{
comment|/* 1st CPU and the non-HTT case */
name|KASSERT
argument_list|(
name|P4_PMC_IS_STOPPED
argument_list|(
name|pd
operator|->
name|pm_cccr_msr
argument_list|)
argument_list|,
operator|(
literal|"[p4,%d] cpu=%d ri=%d cccr=0x%x not stopped"
operator|,
name|__LINE__
operator|,
name|cpu
operator|,
name|ri
operator|,
name|pd
operator|->
name|pm_cccr_msr
operator|)
argument_list|)
expr_stmt|;
comment|/* write out the low 40 bits of the saved value to hardware */
name|wrmsr
argument_list|(
name|pd
operator|->
name|pm_pmc_msr
argument_list|,
name|P4_PCPU_PMC_VALUE
argument_list|(
name|pc
argument_list|,
name|ri
argument_list|,
name|cpu
argument_list|)
operator|&
name|P4_PERFCTR_MASK
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rc
operator|==
literal|1
condition|)
block|{
comment|/* 2nd CPU */
comment|/* 		 * Stop the PMC and retrieve the CCCR and ESCR values 		 * from their MSRs, and turn on the additional T[0/1] 		 * bits for the 2nd CPU. 		 */
name|cccrvalue
operator|=
name|rdmsr
argument_list|(
name|pd
operator|->
name|pm_cccr_msr
argument_list|)
expr_stmt|;
name|wrmsr
argument_list|(
name|pd
operator|->
name|pm_cccr_msr
argument_list|,
name|cccrvalue
operator|&
operator|~
name|P4_CCCR_ENABLE
argument_list|)
expr_stmt|;
comment|/* check that the configuration bits read back match the PMC */
name|KASSERT
argument_list|(
operator|(
name|cccrvalue
operator|&
name|P4_CCCR_Tx_MASK
operator|)
operator|==
operator|(
name|pm
operator|->
name|pm_md
operator|.
name|pm_p4
operator|.
name|pm_p4_cccrvalue
operator|&
name|P4_CCCR_Tx_MASK
operator|)
argument_list|,
operator|(
literal|"[p4,%d] Extra CCCR bits cpu=%d rc=%d ri=%d "
literal|"cccr=0x%x PMC=0x%x"
operator|,
name|__LINE__
operator|,
name|cpu
operator|,
name|rc
operator|,
name|ri
operator|,
name|cccrvalue
operator|&
name|P4_CCCR_Tx_MASK
operator|,
name|pm
operator|->
name|pm_md
operator|.
name|pm_p4
operator|.
name|pm_p4_cccrvalue
operator|&
name|P4_CCCR_Tx_MASK
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|cccrvalue
operator|&
name|P4_CCCR_ENABLE
argument_list|,
operator|(
literal|"[p4,%d] 2nd cpu rc=%d cpu=%d ri=%d not running"
operator|,
name|__LINE__
operator|,
name|rc
operator|,
name|cpu
operator|,
name|ri
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|cccrvalue
operator|&
name|cccrtbits
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"[p4,%d] CCCR T0/T1 mismatch rc=%d cpu=%d ri=%d"
literal|"cccrvalue=0x%x tbits=0x%x"
operator|,
name|__LINE__
operator|,
name|rc
operator|,
name|cpu
operator|,
name|ri
operator|,
name|cccrvalue
operator|,
name|cccrtbits
operator|)
argument_list|)
expr_stmt|;
name|escrvalue
operator|=
name|rdmsr
argument_list|(
name|escrmsr
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|escrvalue
operator|&
name|P4_ESCR_Tx_MASK
operator|)
operator|==
operator|(
name|pm
operator|->
name|pm_md
operator|.
name|pm_p4
operator|.
name|pm_p4_escrvalue
operator|&
name|P4_ESCR_Tx_MASK
operator|)
argument_list|,
operator|(
literal|"[p4,%d] Extra ESCR bits cpu=%d rc=%d ri=%d "
literal|"escr=0x%x pm=0x%x"
operator|,
name|__LINE__
operator|,
name|cpu
operator|,
name|rc
operator|,
name|ri
operator|,
name|escrvalue
operator|&
name|P4_ESCR_Tx_MASK
operator|,
name|pm
operator|->
name|pm_md
operator|.
name|pm_p4
operator|.
name|pm_p4_escrvalue
operator|&
name|P4_ESCR_Tx_MASK
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|escrvalue
operator|&
name|escrtbits
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"[p4,%d] ESCR T0/T1 mismatch rc=%d cpu=%d ri=%d "
literal|"escrmsr=0x%x escrvalue=0x%x tbits=0x%x"
operator|,
name|__LINE__
operator|,
name|rc
operator|,
name|cpu
operator|,
name|ri
operator|,
name|escrmsr
operator|,
name|escrvalue
operator|,
name|escrtbits
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* Enable the correct bits for this CPU. */
name|escrvalue
operator||=
name|escrtbits
expr_stmt|;
name|cccrvalue
operator||=
name|cccrtbits
operator||
name|P4_CCCR_ENABLE
expr_stmt|;
comment|/* Save HW value at the time of starting hardware */
name|P4_PCPU_HW_VALUE
argument_list|(
name|pc
argument_list|,
name|ri
argument_list|,
name|cpu
argument_list|)
operator|=
name|rdmsr
argument_list|(
name|pd
operator|->
name|pm_pmc_msr
argument_list|)
expr_stmt|;
comment|/* Program the ESCR and CCCR and start the PMC */
name|wrmsr
argument_list|(
name|escrmsr
argument_list|,
name|escrvalue
argument_list|)
expr_stmt|;
name|wrmsr
argument_list|(
name|pd
operator|->
name|pm_cccr_msr
argument_list|,
name|cccrvalue
argument_list|)
expr_stmt|;
operator|++
name|rc
expr_stmt|;
name|P4_PCPU_SET_RUNCOUNT
argument_list|(
name|pc
argument_list|,
name|ri
argument_list|,
name|rc
argument_list|)
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|pc
operator|->
name|pc_mtx
argument_list|)
expr_stmt|;
name|PMCDBG
argument_list|(
name|MDP
argument_list|,
name|STA
argument_list|,
literal|2
argument_list|,
literal|"p4-start cpu=%d rc=%d ri=%d escr=%d "
literal|"escrmsr=0x%x escrvalue=0x%x cccr_config=0x%x v=%jx"
argument_list|,
name|cpu
argument_list|,
name|rc
argument_list|,
name|ri
argument_list|,
name|pm
operator|->
name|pm_md
operator|.
name|pm_p4
operator|.
name|pm_p4_escr
argument_list|,
name|escrmsr
argument_list|,
name|escrvalue
argument_list|,
name|cccrvalue
argument_list|,
name|P4_PCPU_HW_VALUE
argument_list|(
name|pc
argument_list|,
name|ri
argument_list|,
name|cpu
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Stop a PMC.  */
end_comment

begin_function
specifier|static
name|int
name|p4_stop_pmc
parameter_list|(
name|int
name|cpu
parameter_list|,
name|int
name|ri
parameter_list|)
block|{
name|int
name|rc
decl_stmt|;
name|uint32_t
name|cccrvalue
decl_stmt|,
name|cccrtbits
decl_stmt|,
name|escrvalue
decl_stmt|,
name|escrmsr
decl_stmt|,
name|escrtbits
decl_stmt|;
name|struct
name|pmc
modifier|*
name|pm
decl_stmt|;
name|struct
name|p4_cpu
modifier|*
name|pc
decl_stmt|;
name|struct
name|pmc_hw
modifier|*
name|phw
decl_stmt|;
name|struct
name|p4pmc_descr
modifier|*
name|pd
decl_stmt|;
name|pmc_value_t
name|tmp
decl_stmt|;
name|KASSERT
argument_list|(
name|cpu
operator|>=
literal|0
operator|&&
name|cpu
operator|<
name|mp_ncpus
argument_list|,
operator|(
literal|"[p4,%d] illegal CPU value %d"
operator|,
name|__LINE__
operator|,
name|cpu
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|ri
operator|>=
literal|0
operator|&&
name|ri
operator|<
name|P4_NPMCS
argument_list|,
operator|(
literal|"[p4,%d] illegal row index %d"
operator|,
name|__LINE__
operator|,
name|ri
operator|)
argument_list|)
expr_stmt|;
name|pd
operator|=
operator|&
name|p4_pmcdesc
index|[
name|ri
index|]
expr_stmt|;
if|if
condition|(
name|pd
operator|->
name|pm_descr
operator|.
name|pd_class
operator|==
name|PMC_CLASS_TSC
condition|)
return|return
literal|0
return|;
name|pc
operator|=
operator|(
expr|struct
name|p4_cpu
operator|*
operator|)
name|pmc_pcpu
index|[
name|P4_TO_PHYSICAL_CPU
argument_list|(
name|cpu
argument_list|)
index|]
expr_stmt|;
name|phw
operator|=
name|pc
operator|->
name|pc_hwpmcs
index|[
name|ri
index|]
expr_stmt|;
name|KASSERT
argument_list|(
name|phw
operator|!=
name|NULL
argument_list|,
operator|(
literal|"[p4,%d] null phw for cpu%d, ri%d"
operator|,
name|__LINE__
operator|,
name|cpu
operator|,
name|ri
operator|)
argument_list|)
expr_stmt|;
name|pm
operator|=
name|phw
operator|->
name|phw_pmc
expr_stmt|;
name|KASSERT
argument_list|(
name|pm
operator|!=
name|NULL
argument_list|,
operator|(
literal|"[p4,%d] null pmc for cpu%d, ri%d"
operator|,
name|__LINE__
operator|,
name|cpu
operator|,
name|ri
operator|)
argument_list|)
expr_stmt|;
name|PMCDBG
argument_list|(
name|MDP
argument_list|,
name|STO
argument_list|,
literal|1
argument_list|,
literal|"p4-stop cpu=%d ri=%d"
argument_list|,
name|cpu
argument_list|,
name|ri
argument_list|)
expr_stmt|;
if|if
condition|(
name|PMC_IS_SYSTEM_MODE
argument_list|(
name|PMC_TO_MODE
argument_list|(
name|pm
argument_list|)
argument_list|)
condition|)
block|{
name|wrmsr
argument_list|(
name|pd
operator|->
name|pm_cccr_msr
argument_list|,
name|pm
operator|->
name|pm_md
operator|.
name|pm_p4
operator|.
name|pm_p4_cccrvalue
operator|&
operator|~
name|P4_CCCR_ENABLE
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* 	 * Thread mode PMCs. 	 * 	 * On HTT machines, this PMC may be in use by two threads 	 * running on two logical CPUS.  Thus we look at the 	 * 'pm_runcount' field and only turn off the appropriate TO/T1 	 * bits (and keep the PMC running) if two logical CPUs were 	 * using the PMC. 	 * 	 */
comment|/* bits to mask */
name|cccrtbits
operator|=
name|P4_CCCR_OVF_PMI_T0
expr_stmt|;
name|escrtbits
operator|=
name|P4_ESCR_T0_OS
operator||
name|P4_ESCR_T0_USR
expr_stmt|;
if|if
condition|(
name|pmc_cpu_is_logical
argument_list|(
name|cpu
argument_list|)
condition|)
block|{
name|cccrtbits
operator|<<=
literal|1
expr_stmt|;
name|escrtbits
operator|>>=
literal|2
expr_stmt|;
block|}
name|mtx_lock_spin
argument_list|(
operator|&
name|pc
operator|->
name|pc_mtx
argument_list|)
expr_stmt|;
name|rc
operator|=
name|P4_PCPU_GET_RUNCOUNT
argument_list|(
name|pc
argument_list|,
name|ri
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|rc
operator|==
literal|2
operator|||
name|rc
operator|==
literal|1
argument_list|,
operator|(
literal|"[p4,%d] illegal runcount cpu=%d ri=%d rc=%d"
operator|,
name|__LINE__
operator|,
name|cpu
operator|,
name|ri
operator|,
name|rc
operator|)
argument_list|)
expr_stmt|;
operator|--
name|rc
expr_stmt|;
name|P4_PCPU_SET_RUNCOUNT
argument_list|(
name|pc
argument_list|,
name|ri
argument_list|,
name|rc
argument_list|)
expr_stmt|;
comment|/* Stop this PMC */
name|cccrvalue
operator|=
name|rdmsr
argument_list|(
name|pd
operator|->
name|pm_cccr_msr
argument_list|)
expr_stmt|;
name|wrmsr
argument_list|(
name|pd
operator|->
name|pm_cccr_msr
argument_list|,
name|cccrvalue
operator|&
operator|~
name|P4_CCCR_ENABLE
argument_list|)
expr_stmt|;
name|escrmsr
operator|=
name|pm
operator|->
name|pm_md
operator|.
name|pm_p4
operator|.
name|pm_p4_escrmsr
expr_stmt|;
name|escrvalue
operator|=
name|rdmsr
argument_list|(
name|escrmsr
argument_list|)
expr_stmt|;
comment|/* The current CPU should be running on this PMC */
name|KASSERT
argument_list|(
name|escrvalue
operator|&
name|escrtbits
argument_list|,
operator|(
literal|"[p4,%d] ESCR T0/T1 mismatch cpu=%d rc=%d ri=%d escrmsr=0x%x "
literal|"escrvalue=0x%x tbits=0x%x"
operator|,
name|__LINE__
operator|,
name|cpu
operator|,
name|rc
operator|,
name|ri
operator|,
name|escrmsr
operator|,
name|escrvalue
operator|,
name|escrtbits
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|PMC_IS_COUNTING_MODE
argument_list|(
name|PMC_TO_MODE
argument_list|(
name|pm
argument_list|)
argument_list|)
operator|||
operator|(
name|cccrvalue
operator|&
name|cccrtbits
operator|)
argument_list|,
operator|(
literal|"[p4,%d] CCCR T0/T1 mismatch cpu=%d ri=%d cccrvalue=0x%x "
literal|"tbits=0x%x"
operator|,
name|__LINE__
operator|,
name|cpu
operator|,
name|ri
operator|,
name|cccrvalue
operator|,
name|cccrtbits
operator|)
argument_list|)
expr_stmt|;
comment|/* get the current hardware reading */
name|tmp
operator|=
name|rdmsr
argument_list|(
name|pd
operator|->
name|pm_pmc_msr
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|==
literal|1
condition|)
block|{
comment|/* need to keep the PMC running */
name|escrvalue
operator|&=
operator|~
name|escrtbits
expr_stmt|;
name|cccrvalue
operator|&=
operator|~
name|cccrtbits
expr_stmt|;
name|wrmsr
argument_list|(
name|escrmsr
argument_list|,
name|escrvalue
argument_list|)
expr_stmt|;
name|wrmsr
argument_list|(
name|pd
operator|->
name|pm_cccr_msr
argument_list|,
name|cccrvalue
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock_spin
argument_list|(
operator|&
name|pc
operator|->
name|pc_mtx
argument_list|)
expr_stmt|;
name|PMCDBG
argument_list|(
name|MDP
argument_list|,
name|STO
argument_list|,
literal|2
argument_list|,
literal|"p4-stop cpu=%d rc=%d ri=%d escrmsr=0x%x "
literal|"escrval=0x%x cccrval=0x%x v=%jx"
argument_list|,
name|cpu
argument_list|,
name|rc
argument_list|,
name|ri
argument_list|,
name|escrmsr
argument_list|,
name|escrvalue
argument_list|,
name|cccrvalue
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|<
name|P4_PCPU_HW_VALUE
argument_list|(
name|pc
argument_list|,
name|ri
argument_list|,
name|cpu
argument_list|)
condition|)
comment|/* 40 bit counter overflow */
name|tmp
operator|+=
operator|(
name|P4_PERFCTR_MASK
operator|+
literal|1
operator|)
operator|-
name|P4_PCPU_HW_VALUE
argument_list|(
name|pc
argument_list|,
name|ri
argument_list|,
name|cpu
argument_list|)
expr_stmt|;
else|else
name|tmp
operator|-=
name|P4_PCPU_HW_VALUE
argument_list|(
name|pc
argument_list|,
name|ri
argument_list|,
name|cpu
argument_list|)
expr_stmt|;
name|P4_PCPU_PMC_VALUE
argument_list|(
name|pc
argument_list|,
name|ri
argument_list|,
name|cpu
argument_list|)
operator|+=
name|tmp
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Handle an interrupt.  *  * The hardware sets the CCCR_OVF whenever a counter overflow occurs, so the handler  * examines all the 18 CCCR registers, processing the counters that have overflowed.  *  * On HTT machines, the CCCR register is shared and will interrupt  * both logical processors if so configured.  Thus multiple logical  * CPUs could enter the NMI service routine at the same time.  These  * will get serialized using a per-cpu spinlock dedicated for use in  * the NMI handler.  */
end_comment

begin_function
specifier|static
name|int
name|p4_intr
parameter_list|(
name|int
name|cpu
parameter_list|,
name|uintptr_t
name|eip
parameter_list|,
name|int
name|usermode
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|did_interrupt
decl_stmt|,
name|error
decl_stmt|,
name|ri
decl_stmt|;
name|uint32_t
name|cccrval
decl_stmt|,
name|ovf_mask
decl_stmt|,
name|ovf_partner
decl_stmt|;
name|struct
name|p4_cpu
modifier|*
name|pc
decl_stmt|;
name|struct
name|pmc_hw
modifier|*
name|phw
decl_stmt|;
name|struct
name|pmc
modifier|*
name|pm
decl_stmt|;
name|pmc_value_t
name|v
decl_stmt|;
name|PMCDBG
argument_list|(
name|MDP
argument_list|,
name|INT
argument_list|,
literal|1
argument_list|,
literal|"cpu=%d eip=%p um=%d"
argument_list|,
name|cpu
argument_list|,
operator|(
name|void
operator|*
operator|)
name|eip
argument_list|,
name|usermode
argument_list|)
expr_stmt|;
name|pc
operator|=
operator|(
expr|struct
name|p4_cpu
operator|*
operator|)
name|pmc_pcpu
index|[
name|P4_TO_PHYSICAL_CPU
argument_list|(
name|cpu
argument_list|)
index|]
expr_stmt|;
name|ovf_mask
operator|=
name|pmc_cpu_is_logical
argument_list|(
name|cpu
argument_list|)
condition|?
name|P4_CCCR_OVF_PMI_T1
else|:
name|P4_CCCR_OVF_PMI_T0
expr_stmt|;
name|ovf_mask
operator||=
name|P4_CCCR_OVF
expr_stmt|;
if|if
condition|(
name|p4_system_has_htt
condition|)
name|ovf_partner
operator|=
name|pmc_cpu_is_logical
argument_list|(
name|cpu
argument_list|)
condition|?
name|P4_CCCR_OVF_PMI_T0
else|:
name|P4_CCCR_OVF_PMI_T1
expr_stmt|;
else|else
name|ovf_partner
operator|=
literal|0
expr_stmt|;
name|did_interrupt
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|p4_system_has_htt
condition|)
name|P4_PCPU_ACQ_INTR_SPINLOCK
argument_list|(
name|pc
argument_list|)
expr_stmt|;
comment|/* 	 * Loop through all CCCRs, looking for ones that have 	 * interrupted this CPU. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|P4_NPMCS
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
name|ri
operator|=
name|i
operator|+
literal|1
expr_stmt|;
comment|/* row index */
comment|/* 		 * Check if our partner logical CPU has already marked 		 * this PMC has having interrupted it.  If so, reset 		 * the flag and process the interrupt, but leave the 		 * hardware alone. 		 */
if|if
condition|(
name|p4_system_has_htt
operator|&&
name|P4_PCPU_GET_INTRFLAG
argument_list|(
name|pc
argument_list|,
name|ri
argument_list|)
condition|)
block|{
name|P4_PCPU_SET_INTRFLAG
argument_list|(
name|pc
argument_list|,
name|ri
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|did_interrupt
operator|=
literal|1
expr_stmt|;
comment|/* 			 * Ignore de-configured or stopped PMCs. 			 * Ignore PMCs not in sampling mode. 			 */
name|phw
operator|=
name|pc
operator|->
name|pc_hwpmcs
index|[
name|ri
index|]
expr_stmt|;
name|pm
operator|=
name|phw
operator|->
name|phw_pmc
expr_stmt|;
if|if
condition|(
name|pm
operator|==
name|NULL
operator|||
name|pm
operator|->
name|pm_state
operator|!=
name|PMC_STATE_RUNNING
operator|||
operator|!
name|PMC_IS_SAMPLING_MODE
argument_list|(
name|PMC_TO_MODE
argument_list|(
name|pm
argument_list|)
argument_list|)
condition|)
block|{
continue|continue;
block|}
operator|(
name|void
operator|)
name|pmc_process_interrupt
argument_list|(
name|cpu
argument_list|,
name|pm
argument_list|,
name|eip
argument_list|,
name|usermode
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * Fresh interrupt.  Look for the CCCR_OVF bit 		 * and the OVF_Tx bit for this logical 		 * processor being set. 		 */
name|cccrval
operator|=
name|rdmsr
argument_list|(
name|P4_CCCR_MSR_FIRST
operator|+
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cccrval
operator|&
name|ovf_mask
operator|)
operator|!=
name|ovf_mask
condition|)
continue|continue;
comment|/* 		 * If the other logical CPU would also have been 		 * interrupted due to the PMC being shared, record 		 * this fact in the per-cpu saved interrupt flag 		 * bitmask. 		 */
if|if
condition|(
name|p4_system_has_htt
operator|&&
operator|(
name|cccrval
operator|&
name|ovf_partner
operator|)
condition|)
name|P4_PCPU_SET_INTRFLAG
argument_list|(
name|pc
argument_list|,
name|ri
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|v
operator|=
name|rdmsr
argument_list|(
name|P4_PERFCTR_MSR_FIRST
operator|+
name|i
argument_list|)
expr_stmt|;
name|PMCDBG
argument_list|(
name|MDP
argument_list|,
name|INT
argument_list|,
literal|2
argument_list|,
literal|"ri=%d v=%jx"
argument_list|,
name|ri
argument_list|,
name|v
argument_list|)
expr_stmt|;
comment|/* Stop the counter, and reset the overflow  bit */
name|cccrval
operator|&=
operator|~
operator|(
name|P4_CCCR_OVF
operator||
name|P4_CCCR_ENABLE
operator|)
expr_stmt|;
name|wrmsr
argument_list|(
name|P4_CCCR_MSR_FIRST
operator|+
name|i
argument_list|,
name|cccrval
argument_list|)
expr_stmt|;
name|did_interrupt
operator|=
literal|1
expr_stmt|;
comment|/* 		 * Ignore de-configured or stopped PMCs.  Ignore PMCs 		 * not in sampling mode. 		 */
name|phw
operator|=
name|pc
operator|->
name|pc_hwpmcs
index|[
name|ri
index|]
expr_stmt|;
name|pm
operator|=
name|phw
operator|->
name|phw_pmc
expr_stmt|;
if|if
condition|(
name|pm
operator|==
name|NULL
operator|||
name|pm
operator|->
name|pm_state
operator|!=
name|PMC_STATE_RUNNING
operator|||
operator|!
name|PMC_IS_SAMPLING_MODE
argument_list|(
name|PMC_TO_MODE
argument_list|(
name|pm
argument_list|)
argument_list|)
condition|)
block|{
continue|continue;
block|}
comment|/* 		 * Process the interrupt.  Re-enable the PMC if 		 * processing was successful. 		 */
name|error
operator|=
name|pmc_process_interrupt
argument_list|(
name|cpu
argument_list|,
name|pm
argument_list|,
name|eip
argument_list|,
name|usermode
argument_list|)
expr_stmt|;
comment|/* 		 * Only the first processor executing the NMI handler 		 * in a HTT pair will restart a PMC, and that too 		 * only if there were no errors. 		 */
name|v
operator|=
name|P4_RELOAD_COUNT_TO_PERFCTR_VALUE
argument_list|(
name|pm
operator|->
name|pm_sc
operator|.
name|pm_reloadcount
argument_list|)
expr_stmt|;
name|wrmsr
argument_list|(
name|P4_PERFCTR_MSR_FIRST
operator|+
name|i
argument_list|,
name|v
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|wrmsr
argument_list|(
name|P4_CCCR_MSR_FIRST
operator|+
name|i
argument_list|,
name|cccrval
operator||
name|P4_CCCR_ENABLE
argument_list|)
expr_stmt|;
block|}
comment|/* allow the other CPU to proceed */
if|if
condition|(
name|p4_system_has_htt
condition|)
name|P4_PCPU_REL_INTR_SPINLOCK
argument_list|(
name|pc
argument_list|)
expr_stmt|;
comment|/* 	 * On Intel P4 CPUs, the PMC 'pcint' entry in the LAPIC gets 	 * masked when a PMC interrupts the CPU.  We need to unmask 	 * the interrupt source explicitly. 	 */
if|if
condition|(
name|did_interrupt
condition|)
name|pmc_x86_lapic_enable_pmc_interrupt
argument_list|()
expr_stmt|;
else|else
name|atomic_add_int
argument_list|(
operator|&
name|pmc_stats
operator|.
name|pm_intr_ignored
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
name|did_interrupt
return|;
block|}
end_function

begin_comment
comment|/*  * Describe a CPU's PMC state.  */
end_comment

begin_function
specifier|static
name|int
name|p4_describe
parameter_list|(
name|int
name|cpu
parameter_list|,
name|int
name|ri
parameter_list|,
name|struct
name|pmc_info
modifier|*
name|pi
parameter_list|,
name|struct
name|pmc
modifier|*
modifier|*
name|ppmc
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|size_t
name|copied
decl_stmt|;
name|struct
name|pmc_hw
modifier|*
name|phw
decl_stmt|;
specifier|const
name|struct
name|p4pmc_descr
modifier|*
name|pd
decl_stmt|;
name|KASSERT
argument_list|(
name|cpu
operator|>=
literal|0
operator|&&
name|cpu
operator|<
name|mp_ncpus
argument_list|,
operator|(
literal|"[p4,%d] illegal CPU %d"
operator|,
name|__LINE__
operator|,
name|cpu
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|ri
operator|>=
literal|0
operator|&&
name|ri
operator|<
name|P4_NPMCS
argument_list|,
operator|(
literal|"[p4,%d] row-index %d out of range"
operator|,
name|__LINE__
operator|,
name|ri
operator|)
argument_list|)
expr_stmt|;
name|PMCDBG
argument_list|(
name|MDP
argument_list|,
name|OPS
argument_list|,
literal|1
argument_list|,
literal|"p4-describe cpu=%d ri=%d"
argument_list|,
name|cpu
argument_list|,
name|ri
argument_list|)
expr_stmt|;
if|if
condition|(
name|pmc_cpu_is_logical
argument_list|(
name|cpu
argument_list|)
condition|)
return|return
name|EINVAL
return|;
name|phw
operator|=
name|pmc_pcpu
index|[
name|cpu
index|]
operator|->
name|pc_hwpmcs
index|[
name|ri
index|]
expr_stmt|;
name|pd
operator|=
operator|&
name|p4_pmcdesc
index|[
name|ri
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|copystr
argument_list|(
name|pd
operator|->
name|pm_descr
operator|.
name|pd_name
argument_list|,
name|pi
operator|->
name|pm_name
argument_list|,
name|PMC_NAME_MAX
argument_list|,
operator|&
name|copied
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|error
return|;
name|pi
operator|->
name|pm_class
operator|=
name|pd
operator|->
name|pm_descr
operator|.
name|pd_class
expr_stmt|;
if|if
condition|(
name|phw
operator|->
name|phw_state
operator|&
name|PMC_PHW_FLAG_IS_ENABLED
condition|)
block|{
name|pi
operator|->
name|pm_enabled
operator|=
name|TRUE
expr_stmt|;
operator|*
name|ppmc
operator|=
name|phw
operator|->
name|phw_pmc
expr_stmt|;
block|}
else|else
block|{
name|pi
operator|->
name|pm_enabled
operator|=
name|FALSE
expr_stmt|;
operator|*
name|ppmc
operator|=
name|NULL
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Get MSR# for use with RDPMC.  */
end_comment

begin_function
specifier|static
name|int
name|p4_get_msr
parameter_list|(
name|int
name|ri
parameter_list|,
name|uint32_t
modifier|*
name|msr
parameter_list|)
block|{
name|KASSERT
argument_list|(
name|ri
operator|>=
literal|0
operator|&&
name|ri
operator|<
name|P4_NPMCS
argument_list|,
operator|(
literal|"[p4,%d] ri %d out of range"
operator|,
name|__LINE__
operator|,
name|ri
operator|)
argument_list|)
expr_stmt|;
operator|*
name|msr
operator|=
name|p4_pmcdesc
index|[
name|ri
index|]
operator|.
name|pm_pmc_msr
operator|-
name|P4_PERFCTR_MSR_FIRST
expr_stmt|;
name|PMCDBG
argument_list|(
name|MDP
argument_list|,
name|OPS
argument_list|,
literal|1
argument_list|,
literal|"ri=%d getmsr=0x%x"
argument_list|,
name|ri
argument_list|,
operator|*
name|msr
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|pmc_initialize_p4
parameter_list|(
name|struct
name|pmc_mdep
modifier|*
name|pmc_mdep
parameter_list|)
block|{
name|struct
name|p4_event_descr
modifier|*
name|pe
decl_stmt|;
name|KASSERT
argument_list|(
name|strcmp
argument_list|(
name|cpu_vendor
argument_list|,
literal|"GenuineIntel"
argument_list|)
operator|==
literal|0
argument_list|,
operator|(
literal|"[p4,%d] Initializing non-intel processor"
operator|,
name|__LINE__
operator|)
argument_list|)
expr_stmt|;
name|PMCDBG
argument_list|(
name|MDP
argument_list|,
name|INI
argument_list|,
literal|1
argument_list|,
literal|"%s"
argument_list|,
literal|"p4-initialize"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|pmc_mdep
operator|->
name|pmd_cputype
condition|)
block|{
case|case
name|PMC_CPU_INTEL_PIV
case|:
name|pmc_mdep
operator|->
name|pmd_npmc
operator|=
name|P4_NPMCS
expr_stmt|;
name|pmc_mdep
operator|->
name|pmd_classes
index|[
literal|1
index|]
operator|.
name|pm_class
operator|=
name|PMC_CLASS_P4
expr_stmt|;
name|pmc_mdep
operator|->
name|pmd_classes
index|[
literal|1
index|]
operator|.
name|pm_caps
operator|=
name|P4_PMC_CAPS
expr_stmt|;
name|pmc_mdep
operator|->
name|pmd_classes
index|[
literal|1
index|]
operator|.
name|pm_width
operator|=
literal|40
expr_stmt|;
name|pmc_mdep
operator|->
name|pmd_nclasspmcs
index|[
literal|1
index|]
operator|=
literal|18
expr_stmt|;
name|pmc_mdep
operator|->
name|pmd_init
operator|=
name|p4_init
expr_stmt|;
name|pmc_mdep
operator|->
name|pmd_cleanup
operator|=
name|p4_cleanup
expr_stmt|;
name|pmc_mdep
operator|->
name|pmd_switch_in
operator|=
name|p4_switch_in
expr_stmt|;
name|pmc_mdep
operator|->
name|pmd_switch_out
operator|=
name|p4_switch_out
expr_stmt|;
name|pmc_mdep
operator|->
name|pmd_read_pmc
operator|=
name|p4_read_pmc
expr_stmt|;
name|pmc_mdep
operator|->
name|pmd_write_pmc
operator|=
name|p4_write_pmc
expr_stmt|;
name|pmc_mdep
operator|->
name|pmd_config_pmc
operator|=
name|p4_config_pmc
expr_stmt|;
name|pmc_mdep
operator|->
name|pmd_get_config
operator|=
name|p4_get_config
expr_stmt|;
name|pmc_mdep
operator|->
name|pmd_allocate_pmc
operator|=
name|p4_allocate_pmc
expr_stmt|;
name|pmc_mdep
operator|->
name|pmd_release_pmc
operator|=
name|p4_release_pmc
expr_stmt|;
name|pmc_mdep
operator|->
name|pmd_start_pmc
operator|=
name|p4_start_pmc
expr_stmt|;
name|pmc_mdep
operator|->
name|pmd_stop_pmc
operator|=
name|p4_stop_pmc
expr_stmt|;
name|pmc_mdep
operator|->
name|pmd_intr
operator|=
name|p4_intr
expr_stmt|;
name|pmc_mdep
operator|->
name|pmd_describe
operator|=
name|p4_describe
expr_stmt|;
name|pmc_mdep
operator|->
name|pmd_get_msr
operator|=
name|p4_get_msr
expr_stmt|;
comment|/* i386 */
comment|/* model specific munging */
if|if
condition|(
operator|(
name|cpu_id
operator|&
literal|0xFFF
operator|)
operator|<
literal|0xF27
condition|)
block|{
comment|/* 			 * On P4 and Xeon with CPUID< (Family 15, 			 * Model 2, Stepping 7), only one ESCR is 			 * available for the IOQ_ALLOCATION event. 			 */
name|pe
operator|=
name|p4_find_event
argument_list|(
name|PMC_EV_P4_IOQ_ALLOCATION
argument_list|)
expr_stmt|;
name|pe
operator|->
name|pm_escrs
index|[
literal|1
index|]
operator|=
name|P4_ESCR_NONE
expr_stmt|;
block|}
break|break;
default|default:
name|KASSERT
argument_list|(
literal|0
argument_list|,
operator|(
literal|"[p4,%d] Unknown CPU type"
operator|,
name|__LINE__
operator|)
argument_list|)
expr_stmt|;
return|return
name|ENOSYS
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

end_unit

